{% extends "base.html" %}
{% block title %}{{ shader.data.info.name if shader.data and shader.data.get('info') and shader.data.info.get('name') else shader.id }} - Shadertoy Browser{% endblock %}
{% block content %}
<div class="shader-detail">
    <h1>{{ shader.data.info.name if shader.data and shader.data.get('info') and shader.data.info.get('name') else shader.id }}</h1>
    <div class="shader-meta">
        <p><strong>Author:</strong> {{ shader.data.info.username if shader.data and shader.data.get('info') and shader.data.info.get('username') else 'Unknown' }}</p>
        <p><strong>Published:</strong> {{ shader.data.info.date if shader.data and shader.data.get('info') and shader.data.info.get('date') else 'Unknown' }}</p>
        <p><strong>Views:</strong> {{ shader.data.info.viewed if shader.data and shader.data.get('info') and shader.data.info.get('viewed') else 0 }}</p>
        <p><strong>Likes:</strong> {{ shader.data.info.likes if shader.data and shader.data.get('info') and shader.data.info.get('likes') else 0 }}</p>
    </div>
    
    <div class="shader-render">
        <canvas id="shader-canvas" width="800" height="600" style="width: 100%; max-width: 800px; border: 1px solid #ccc;"></canvas>
    </div>
    
    <div class="shader-description">
        <h2>Description</h2>
        <p>{{ shader.data.info.description if shader.data and shader.data.get('info') and shader.data.info.get('description') else 'No description available.' }}</p>
    </div>
    
    {% if shader.data.get('renderpass') %}
    <div class="shader-code">
        <h2>Code</h2>
        {% for pass in shader.data.renderpass %}
        <div class="pass-block">
            <h3>Pass {{ loop.index }} ({{ pass.type }})</h3>
            <pre class="shader-source">{{ pass.code }}</pre>
        </div>
        {% endfor %}
    </div>
    {% endif %}
</div>

<style>
.shader-detail {
    max-width: 1000px;
    margin: 0 auto;
    padding: 20px;
}

.shader-meta {
    background-color: #f5f5f5;
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
}

.shader-render {
    text-align: center;
    margin: 20px 0;
}

.shader-description {
    margin: 20px 0;
}

.shader-code {
    margin: 20px 0;
}

.pass-block {
    margin: 20px 0;
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
}

.shader-source {
    background-color: #2d2d2d;
    color: #f8f8f2;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
    font-size: 0.9em;
    line-height: 1.4;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('shader-canvas');
    if (!canvas) return;
    
    // Initialize WebGL context
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) {
        console.error('WebGL not supported');
        return;
    }
    
    // Vertex shader source - full-screen quad
    const vertexShaderSource = `
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
            vUv = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }
    `;
    
    // Fragment shader source - base for shaderToy compatibility
    const fragmentShaderSource = `
        precision highp float;
        varying vec2 vUv;
        uniform vec3 iResolution;
        uniform float iTime;
        uniform vec4 iMouse;
        uniform vec4 iDate;
        uniform float iSampleRate;
        
        void main() {
            vec2 uv = vUv;
            uv = uv * 2.0 - 1.0; // remap to [-1,1]
            uv.x *= iResolution.x / iResolution.y; // aspect ratio correction
            
            // Basic animation for demonstration
            float time = iTime * 0.5;
            
            // Example pattern - this would be replaced by actual shader code
            vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));
            
            // Add a moving circle
            float dist = length(uv);
            vec3 circ = vec3(smoothstep(0.5, 0.49, dist));
            
            // Combine patterns
            vec3 finalColor = mix(col, vec3(1.0, 0.0, 0.0), circ.r);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
        
        // Utility functions for shader compatibility
        float smoothstep(float edge0, float edge1, float x) {
            float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
            return t * t * (3.0 - 2.0 * t);
        }
    `;
    
    // Helper function to create shader
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    // Create shaders
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
    if (!vertexShader || !fragmentShader) {
        console.error('Failed to create shaders');
        return;
    }
    
    // Create shader program
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program linking error:', gl.getProgramInfoLog(program));
        return;
    }
    
    // Get attribute and uniform locations
    const positionAttributeLocation = gl.getAttribLocation(program, 'position');
    const resolutionUniformLocation = gl.getUniformLocation(program, 'iResolution');
    const timeUniformLocation = gl.getUniformLocation(program, 'iTime');
    const mouseUniformLocation = gl.getUniformLocation(program, 'iMouse');
    const dateUniformLocation = gl.getUniformLocation(program, 'iDate');
    
    // Set up position buffer for full-screen quad
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    
    // Animation variables
    let startTime = Date.now();
    
    // Render function
    function render() {
        // Set viewport to match canvas
        gl.viewport(0, 0, canvas.width, canvas.height);
        
        // Clear canvas
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Use program
        gl.useProgram(program);
        
        // Bind position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Set uniforms
        gl.uniform3f(resolutionUniformLocation, canvas.width, canvas.height, 1.0);
        gl.uniform1f(timeUniformLocation, (Date.now() - startTime) / 1000);
        gl.uniform4f(mouseUniformLocation, 0, 0, 0, 0); // No mouse interaction for demo
        
        const now = new Date();
        gl.uniform4f(dateUniformLocation, 
            now.getFullYear(), 
            now.getMonth(), 
            now.getDate(), 
            now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds() + now.getMilliseconds() / 1000
        );
        
        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        
        // Continue animation
        requestAnimationFrame(render);
    }
    
    // Start rendering
    render();
});
</script>
{% endblock %}