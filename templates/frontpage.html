{% extends "base.html" %}
{% block content %}
<div id="blockTop">
    <div id="block0">
        <div class="normalText"><a class="regular" href="{{ url_for('browse') }}">Featured Shaders</a></div>
        <div class="shaderBig">
            <!-- Feature a few popular shaders -->
            {% if shaders %}
                {% for shader in shaders[:1] %}
                    <div class="shaderPreviewContainer" id="Preview_0_Container" style="visibility: visible;">
                        <a class="shaderPreview shaderPreviewContent" id="Preview_0_Link" style="visibility: visible;" href="{{ url_for('shader_detail', shader_id=shader.id) }}">
                            <div class="previewCanvas" id="Preview_0_Canvas" width="800" height="450" style="visibility: hidden; opacity: 0.0; background-color: rgb(0, 0, 0);">
                                <canvas id="canvas_{{ shader.id }}" width="800" height="450" style="border: none; margin: 0px; display: inline-block; width: 100%; height: 100%; border-radius: 8px;"></canvas>
                    <script>
                    // Initialize shader preview for featured shader
                    document.addEventListener('DOMContentLoaded', function() {
                        const canvas = document.getElementById('canvas_{{ shader.id }}');
                        if (!canvas) return;
                        
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        if (!gl) return;
                        
                        // Simplified shader for preview
                        const vertCode = `
                            attribute vec2 position;
                            varying vec2 uv;
                            void main() {
                                uv = position * 0.5 + 0.5;
                                gl_Position = vec4(position, 0.0, 1.0);
                            }
                        `;
                        
                        const fragCode = `
                            precision highp float;
                            varying vec2 uv;
                            uniform float time;
                            
                            void main() {
                                vec2 p = uv * 2.0 - 1.0;
                                p.x *= 800.0/450.0; // Aspect ratio correction
                                
                                // Create animated pattern
                                float r = length(sin(p * 3.0 + time));
                                float g = length(cos(p * 3.0 + time));
                                float b = length(sin(p * 2.0 + time * 1.5));
                                
                                gl_FragColor = vec4(r, g, b, 1.0);
                            }
                        `;
                        
                        // Create and compile shaders
                        function createShader(gl, type, source) {
                            const shader = gl.createShader(type);
                            gl.shaderSource(shader, source);
                            gl.compileShader(shader);
                            return shader;
                        }
                        
                        const vertShader = createShader(gl, gl.VERTEX_SHADER, vertCode);
                        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragCode);
                        
                        const program = gl.createProgram();
                        gl.attachShader(program, vertShader);
                        gl.attachShader(program, fragShader);
                        gl.linkProgram(program);
                        
                        const positionLoc = gl.getAttribLocation(program, 'position');
                        const timeLoc = gl.getUniformLocation(program, 'time');
                        
                        // Set up geometry
                        const buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                            -1, -1,
                             1, -1,
                            -1,  1,
                            -1,  1,
                             1, -1,
                             1,  1,
                        ]), gl.STATIC_DRAW);
                        
                        gl.useProgram(program);
                        gl.enableVertexAttribArray(positionLoc);
                        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        // Simple animation
                        function animate() {
                            gl.viewport(0, 0, canvas.width, canvas.height);
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            
                            gl.uniform1f(timeLoc, performance.now() / 1000);
                            gl.drawArrays(gl.TRIANGLES, 0, 6);
                            
                            requestAnimationFrame(animate);
                        }
                        
                        animate();
                    });
                    </script>
                            </div>
                        </a>
                        <div class="previewInfo" id="Preview_0_Info" style="visibility: visible;">
                            <span class="previewText" id="Preview_0_Text">{{ shader.data.info.name if shader.data and shader.data.get('info') else shader.id }}</span>
                            <span>by</span>
                            <span class="previewTextUser" id="Preview_0_TextUser">
                                <a class="user" href="#">{{ shader.data.info.username if shader.data and shader.data.get('info') and shader.data.info.get('username') else 'Unknown' }}</a>
                            </span>
                            <span class="previewStats" id="Preview_0_Stats">
                                Views: {{ shader.data.info.viewed if shader.data and shader.data.get('info') and shader.data.info.get('viewed') else 0 }}
                                &nbsp;&nbsp;
                                Likes: {{ shader.data.info.likes if shader.data and shader.data.get('info') and shader.data.info.get('likes') else 0 }}
                            </span>
                        </div>
                    </div>
                {% endfor %}
            {% endif %}
        </div>
    </div>

    <div id="block1">
        <div class="bigText">
            <span class="boldText">Build</span> <span class="grayText">and </span><span class="boldText">Share</span> 
            <span class="grayText">your best shaders with the world and get</span> 
            <span class="boldText">Inspired</span>
        </div>
    </div>
</div>

<div id="blockBottom">
    <div class="normalText"><a class="regular" href="{{ url_for('browse') }}">Recently Added Shaders</a></div>
    <div id="blockPreviews">
        {% if shaders %}
            {% for shader in shaders[1:5] %}
            <div class="shaderSmall">
                <div class="shaderPreviewContainer" id="Preview_{{ loop.index }}_Container" style="visibility: visible;">
                    <a class="shaderPreview shaderPreviewContent" id="Preview_{{ loop.index }}_Link" style="visibility: visible;" href="{{ url_for('shader_detail', shader_id=shader.id) }}">
                        <div class="previewCanvas" id="Preview_{{ loop.index }}_Canvas" width="476" height="268" style="visibility: hidden; opacity: 0.0; background-color: rgb(0, 0, 0);">
                            <canvas id="canvas_{{ shader.id }}_{{ loop.index }}" width="476" height="268" style="border: none; margin: 0px; display: inline-block; width: 100%; height: 100%; border-radius: 8px;"></canvas>
                    <script>
                    // Initialize shader preview for small shaders
                    document.addEventListener('DOMContentLoaded', function() {
                        const canvas = document.getElementById('canvas_{{ shader.id }}_{{ loop.index }}');
                        if (!canvas) return;
                        
                        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        if (!gl) return;
                        
                        // Simplified shader for preview
                        const vertCode = `
                            attribute vec2 position;
                            varying vec2 uv;
                            void main() {
                                uv = position * 0.5 + 0.5;
                                gl_Position = vec4(position, 0.0, 1.0);
                            }
                        `;
                        
                        const fragCode = `
                            precision highp float;
                            varying vec2 uv;
                            uniform float time;
                            
                            void main() {
                                vec2 p = uv * 2.0 - 1.0;
                                p.x *= 476.0/268.0; // Aspect ratio correction
                                
                                // Create animated pattern
                                float r = length(sin(p * 3.0 + time));
                                float g = length(cos(p * 3.0 + time));
                                float b = length(sin(p * 2.0 + time * 1.5));
                                
                                gl_FragColor = vec4(r, g, b, 1.0);
                            }
                        `;
                        
                        // Create and compile shaders
                        function createShader(gl, type, source) {
                            const shader = gl.createShader(type);
                            gl.shaderSource(shader, source);
                            gl.compileShader(shader);
                            return shader;
                        }
                        
                        const vertShader = createShader(gl, gl.VERTEX_SHADER, vertCode);
                        const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragCode);
                        
                        const program = gl.createProgram();
                        gl.attachShader(program, vertShader);
                        gl.attachShader(program, fragShader);
                        gl.linkProgram(program);
                        
                        const positionLoc = gl.getAttribLocation(program, 'position');
                        const timeLoc = gl.getUniformLocation(program, 'time');
                        
                        // Set up geometry
                        const buffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                            -1, -1,
                             1, -1,
                            -1,  1,
                            -1,  1,
                             1, -1,
                             1,  1,
                        ]), gl.STATIC_DRAW);
                        
                        gl.useProgram(program);
                        gl.enableVertexAttribArray(positionLoc);
                        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
                        
                        // Simple animation
                        function animate() {
                            gl.viewport(0, 0, canvas.width, canvas.height);
                            gl.clear(gl.COLOR_BUFFER_BIT);
                            
                            gl.uniform1f(timeLoc, performance.now() / 1000);
                            gl.drawArrays(gl.TRIANGLES, 0, 6);
                            
                            requestAnimationFrame(animate);
                        }
                        
                        animate();
                    });
                    </script>
                        </div>
                    </a>
                    <div class="previewInfo" id="Preview_{{ loop.index }}_Info" style="visibility: visible;">
                        <span class="previewText" id="Preview_{{ loop.index }}_Text">{{ shader.data.info.name if shader.data and shader.data.get('info') else shader.id }}</span>
                        <span>by</span>
                        <span class="previewTextUser" id="Preview_{{ loop.index }}_TextUser">
                            <a class="user" href="#">{{ shader.data.info.username if shader.data and shader.data.get('info') and shader.data.info.get('username') else 'Unknown' }}</a>
                        </span>
                        <span class="previewStats" id="Preview_{{ loop.index }}_Stats">
                            Views: {{ shader.data.info.viewed if shader.data and shader.data.get('info') and shader.data.info.get('viewed') else 0 }}
                            &nbsp;&nbsp;
                            Likes: {{ shader.data.info.likes if shader.data and shader.data.get('info') and shader.data.info.get('likes') else 0 }}
                        </span>
                    </div>
                </div>
            </div>
            {% endfor %}
        {% endif %}
    </div>
</div>
{% endblock %}