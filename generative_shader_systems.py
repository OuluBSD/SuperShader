"""
Generative Shader Systems
Part of SuperShader Project - Phase 7: Neural Network Integration and AI Features

This module implements AI systems that can generate new shader modules,
neural networks for procedural shader creation, and systems for evolving
shaders based on user feedback.
"""

import numpy as np
import random
from typing import Dict, List, Tuple, Any, Optional, Callable
from dataclasses import dataclass
import json


@dataclass
class ShaderGene:
    """Represents a gene in the shader genome"""
    name: str
    type: str  # 'parameter', 'function', 'structure', 'algorithm'
    value_range: Tuple[float, float]
    current_value: float
    description: str


@dataclass
class GeneratedShader:
    """Represents a shader generated by the AI system"""
    id: str
    vertex_shader: str
    fragment_shader: str
    geometry_shader: Optional[str]
    parameters: Dict[str, float]
    fitness_score: float
    generation: int
    parent_ids: List[str]


class ProceduralShaderGenerator:
    """
    System for generating procedural shaders using neural networks
    """
    
    def __init__(self):
        self.shader_genes: List[ShaderGene] = []
        self.generated_shaders: List[GeneratedShader] = []
        self.generation_count = 0
        self.template_shaders: Dict[str, str] = self._load_shader_templates()
    
    def _load_shader_templates(self) -> Dict[str, str]:
        """
        Load base shader templates that can be modified by the neural network
        """
        templates = {
            'basic_lighting': '''
// Basic Lighting Shader Template
uniform float time;
uniform vec3 light_position;
uniform vec3 camera_position;
varying vec3 normal;
varying vec3 world_position;

void main() {
    vec3 light_dir = normalize(light_position - world_position);
    vec3 view_dir = normalize(camera_position - world_position);
    vec3 reflect_dir = reflect(-light_dir, normal);
    
    float diff = max(dot(normal, light_dir), 0.0);
    float spec = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);
    
    vec3 result = /*MATERIAL_COLOR*/ * diff + vec3(1.0) * spec;
    gl_FragColor = vec4(result, 1.0);
}
            ''',
            'procedural_texture': '''
// Procedural Texture Shader Template
uniform float time;
uniform vec2 resolution;

float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    uv = uv * /*SCALE_FACTOR*/ - /*OFFSET_VALUE*/;
    
    // Procedural pattern
    float pattern = /*PATTERN_FUNCTION*/;
    
    gl_FragColor = vec4(vec3(pattern), 1.0);
}
            ''',
            'post_processing': '''
// Post-Processing Shader Template
uniform sampler2D texture_input;
uniform float time;
uniform vec2 resolution;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    
    vec4 color = texture2D(texture_input, uv);
    
    // Post-processing effect
    color = /*EFFECT_FUNCTION*/;
    
    gl_FragColor = color;
}
            '''
        }
        return templates
    
    def define_shader_genes(self) -> None:
        """
        Define the genes that control shader generation
        """
        self.shader_genes = [
            ShaderGene("material_metallic", "parameter", (0.0, 1.0), 0.5, "Material metallic property"),
            ShaderGene("material_roughness", "parameter", (0.0, 1.0), 0.5, "Material roughness property"),
            ShaderGene("light_intensity", "parameter", (0.0, 5.0), 1.0, "Light intensity factor"),
            ShaderGene("time_factor", "parameter", (0.0, 10.0), 1.0, "Time-based animation factor"),
            ShaderGene("scale_factor", "parameter", (0.1, 10.0), 1.0, "Scale factor for patterns"),
            ShaderGene("pattern_frequency", "parameter", (1.0, 20.0), 5.0, "Frequency of procedural patterns"),
            ShaderGene("effect_intensity", "parameter", (0.0, 2.0), 1.0, "Intensity of effects"),
            ShaderGene("shader_type", "structure", (0.0, 3.0), 0.0, "Type of shader (0: lighting, 1: texture, 2: post)"),
            ShaderGene("complexity_level", "algorithm", (1.0, 5.0), 2.0, "Complexity of the algorithm"),
        ]
    
    def generate_random_shader_params(self) -> Dict[str, float]:
        """
        Generate random shader parameters based on defined genes
        """
        params = {}
        for gene in self.shader_genes:
            if gene.type == "structure":
                # For structure genes, pick an integer value
                params[gene.name] = float(random.randint(int(gene.value_range[0]), int(gene.value_range[1])))
            else:
                # For other genes, pick a continuous value
                params[gene.name] = random.uniform(gene.value_range[0], gene.value_range[1])
        
        return params
    
    def create_shader_from_params(self, params: Dict[str, float]) -> GeneratedShader:
        """
        Create a shader based on the given parameters
        """
        # Determine shader type from parameters
        shader_type_idx = int(params.get("shader_type", 0))
        shader_types = list(self.template_shaders.keys())
        
        if shader_type_idx >= len(shader_types):
            shader_type_idx = 0
        
        template_key = shader_types[shader_type_idx]
        base_template = self.template_shaders[template_key]
        
        # Apply parameter substitutions to the template
        shader_code = self._apply_parameters_to_template(base_template, params)
        
        # Create the generated shader object
        shader_id = f"gen_{self.generation_count}_{len(self.generated_shaders)}"
        generated_shader = GeneratedShader(
            id=shader_id,
            vertex_shader="// Generated vertex shader\nvoid main() { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; }",
            fragment_shader=shader_code,
            geometry_shader=None,
            parameters=params,
            fitness_score=0.0,
            generation=self.generation_count,
            parent_ids=[]
        )
        
        return generated_shader
    
    def _apply_parameters_to_template(self, template: str, params: Dict[str, float]) -> str:
        """
        Apply the given parameters to the shader template
        """
        result = template
        
        # Replace placeholders with actual parameter values
        replacements = {
            '/*MATERIAL_COLOR*/': f'vec3({params.get("material_metallic", 0.5)}, {params.get("material_roughness", 0.5)}, 0.7)',
            '/*SCALE_FACTOR*/': f'{params.get("scale_factor", 1.0)}',
            '/*OFFSET_VALUE*/': f'{params.get("light_intensity", 1.0)}',
            '/*PATTERN_FUNCTION*/': self._generate_pattern_function(params),
            '/*EFFECT_FUNCTION*/': self._generate_effect_function(params),
        }
        
        for placeholder, value in replacements.items():
            result = result.replace(placeholder, value)
        
        return result
    
    def _generate_pattern_function(self, params: Dict[str, float]) -> str:
        """
        Generate a procedural pattern function based on parameters
        """
        freq = params.get("pattern_frequency", 5.0)
        complexity = int(params.get("complexity_level", 2))
        
        if complexity <= 1:
            # Simple pattern
            return f"sin(uv.x * {freq}) * sin(uv.y * {freq})"
        elif complexity <= 2:
            # Medium complexity pattern
            return f"abs(sin(uv.x * {freq})) * abs(cos(uv.y * {freq}))"
        elif complexity <= 3:
            # Complex pattern
            return f"0.5 + 0.5 * sin(uv.x * {freq}) * cos(uv.y * {freq}) * sin(length(uv) * {freq * 0.5})"
        else:
            # Very complex pattern
            return f"noise(uv * {freq}) + 0.5 * sin(uv.x * {freq * 2.0}) * cos(uv.y * {freq * 2.0})"
    
    def _generate_effect_function(self, params: Dict[str, float]) -> str:
        """
        Generate a post-processing effect function based on parameters
        """
        intensity = params.get("effect_intensity", 1.0)
        
        # For now, a simple vignette effect modulated by intensity
        return f"color * (1.0 - length(uv - 0.5) * {0.5 * intensity})"


class NeuralShaderEvolver:
    """
    System for evolving shaders based on user feedback using neural networks
    """
    
    def __init__(self):
        self.feedback_history: List[Tuple[str, float]] = []  # (shader_id, rating)
        self.population_size = 20
        self.mutation_rate = 0.1
        self.crossover_rate = 0.7
        self.generator = ProceduralShaderGenerator()
        self.generator.define_shader_genes()
    
    def provide_feedback(self, shader_id: str, rating: float) -> None:
        """
        Record user feedback for a generated shader
        Rating should be between 0 and 1
        """
        self.feedback_history.append((shader_id, max(0.0, min(1.0, rating))))
    
    def select_parents(self, population: List[GeneratedShader]) -> Tuple[GeneratedShader, GeneratedShader]:
        """
        Select two parents for crossover based on their fitness scores
        """
        # Sort population by fitness score (highest first)
        sorted_population = sorted(population, key=lambda s: s.fitness_score, reverse=True)
        
        # Use tournament selection to pick two parents
        def tournament_select(k=3):
            tournament = random.sample(sorted_population, min(k, len(sorted_population)))
            return max(tournament, key=lambda s: s.fitness_score)
        
        parent1 = tournament_select()
        parent2 = tournament_select()
        
        return parent1, parent2
    
    def crossover(self, parent1: GeneratedShader, parent2: GeneratedShader) -> GeneratedShader:
        """
        Perform crossover between two parent shaders to create a child
        """
        child_params = {}
        
        for param_name in parent1.parameters:
            # Randomly choose parameter from either parent
            if random.random() < 0.5:
                child_params[param_name] = parent1.parameters[param_name]
            else:
                child_params[param_name] = parent2.parameters[param_name]
        
        # Create child shader
        child_shader = self.generator.create_shader_from_params(child_params)
        child_shader.parent_ids = [parent1.id, parent2.id]
        
        return child_shader
    
    def mutate(self, shader: GeneratedShader) -> GeneratedShader:
        """
        Mutate a shader by randomly changing some parameters
        """
        mutated_params = shader.parameters.copy()
        
        for param_name, value in mutated_params.items():
            if random.random() < self.mutation_rate:
                # Find the gene for this parameter to get its value range
                gene = next((g for g in self.generator.shader_genes if g.name == param_name), None)
                if gene:
                    # Apply mutation within the allowed range
                    range_min, range_max = gene.value_range
                    mutation_delta = (range_max - range_min) * 0.1 * (random.random() - 0.5) * 2
                    mutated_params[param_name] = max(range_min, min(range_max, value + mutation_delta))
        
        # Create new shader with mutated parameters
        mutated_shader = self.generator.create_shader_from_params(mutated_params)
        mutated_shader.parent_ids = [shader.id]
        mutated_shader.fitness_score = shader.fitness_score  # Preserve fitness score
        
        return mutated_shader
    
    def evolve_generation(self, current_generation: List[GeneratedShader]) -> List[GeneratedShader]:
        """
        Evolve a new generation of shaders based on the current generation
        """
        new_generation = []
        
        # Copy the best shader (elitism)
        if current_generation:
            best_shader = max(current_generation, key=lambda s: s.fitness_score)
            new_generation.append(best_shader)
        
        # Fill the rest of the population
        while len(new_generation) < self.population_size:
            # Select parents
            parent1, parent2 = self.select_parents(current_generation)
            
            # Create child through crossover
            if random.random() < self.crossover_rate:
                child = self.crossover(parent1, parent2)
            else:
                # If no crossover, pick a random parent
                child = random.choice([parent1, parent2])
            
            # Apply mutation
            mutated_child = self.mutate(child)
            
            new_generation.append(mutated_child)
        
        return new_generation
    
    def assign_fitness_scores(self) -> None:
        """
        Assign fitness scores to shaders based on user feedback
        """
        feedback_dict = {shader_id: rating for shader_id, rating in self.feedback_history}
        
        for shader in self.generator.generated_shaders:
            if shader.id in feedback_dict:
                shader.fitness_score = feedback_dict[shader.id]
            else:
                # Default score for shaders without feedback
                shader.fitness_score = 0.5


class GenerativeAdversarialShaderSystem:
    """
    Generative Adversarial Networks for creative shader generation
    """
    
    def __init__(self):
        self.generator_network = self._create_generator_network()
        self.discriminator_network = self._create_discriminator_network()
        self.training_data: List[str] = []  # List of shader code strings
    
    def _create_generator_network(self) -> Callable[[Dict[str, float]], str]:
        """
        Create a simple generator network (simulated)
        In a real implementation, this would be a neural network
        """
        def generate_shader(parameters: Dict[str, float]) -> str:
            # This is a simplified simulation of a neural network generator
            # In reality, this would be implemented with actual neural network code
            
            # Generate shader based on parameters
            metallic = parameters.get("material_metallic", 0.5)
            roughness = parameters.get("material_roughness", 0.5)
            light_intensity = parameters.get("light_intensity", 1.0)
            
            vertex_shader = f"""
// Generated Vertex Shader
attribute vec3 position;
attribute vec3 normal;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;

varying vec3 vNormal;
varying vec3 vWorldPosition;

void main() {{
    vNormal = normalMatrix * normal;
    vec4 worldPosition = modelViewMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    gl_Position = projectionMatrix * worldPosition;
}}
            """
            
            fragment_shader = f"""
// Generated Fragment Shader
precision mediump float;

varying vec3 vNormal;
varying vec3 vWorldPosition;

uniform float metallic;
uniform float roughness;
uniform float lightIntensity;

void main() {{
    vec3 normal = normalize(vNormal);
    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
    
    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(reflect(-lightDir, normal), normalize(vec3(0.0) - vWorldPosition)), 0.0), 32.0);
    
    vec3 color = vec3({metallic}, {roughness}, 0.7) * diff + vec3(1.0) * spec * {light_intensity};
    
    gl_FragColor = vec4(color, 1.0);
}}
            """
            
            return vertex_shader + "\n" + fragment_shader
        
        return generate_shader
    
    def _create_discriminator_network(self) -> Callable[[str], float]:
        """
        Create a simple discriminator network (simulated)
        In a real implementation, this would be a neural network
        """
        def discriminator(shader_code: str) -> float:
            # This is a simplified simulation of a neural network discriminator
            # In reality, this would be implemented with actual neural network code
            
            # Simple heuristic evaluation
            score = 0.5  # Base score
            
            # Check for essential elements
            if "gl_Position" in shader_code:
                score += 0.1
            if "gl_FragColor" in shader_code or "out vec4" in shader_code:
                score += 0.1
            if "uniform" in shader_code:
                score += 0.1
            if "attribute" in shader_code or "in " in shader_code:
                score += 0.1
            if "main()" in shader_code:
                score += 0.1
            
            # Apply bounds
            return max(0.0, min(1.0, score))
        
        return discriminator
    
    def train_gan(self, training_steps: int = 100) -> None:
        """
        Train the GAN system (simulated)
        """
        print(f"Training GAN for {training_steps} steps...")
        
        for step in range(training_steps):
            # Generate a shader
            params = {
                "material_metallic": random.uniform(0.0, 1.0),
                "material_roughness": random.uniform(0.0, 1.0),
                "light_intensity": random.uniform(0.5, 2.0)
            }
            
            generated_shader = self.generator_network(params)
            
            # Get discriminator score
            disc_score = self.discriminator_network(generated_shader)
            
            # In a real GAN, we would use this score to train both networks
            # Here we just simulate the process
            
            if step % 20 == 0:
                print(f"Step {step}: Discriminator score: {disc_score:.3f}")
    
    def generate_creative_shader(self, inspiration: str = "") -> str:
        """
        Generate a creative shader inspired by the input
        """
        params = {
            "material_metallic": random.uniform(0.0, 1.0),
            "material_roughness": random.uniform(0.0, 1.0),
            "light_intensity": random.uniform(0.5, 2.0)
        }
        
        return self.generator_network(params)


def main():
    """
    Example usage of the Generative Shader Systems
    """
    print("Generative Shader Systems")
    print("Part of SuperShader Project - Phase 7")
    
    # Example 1: Procedural Shader Generator
    print("\n--- Procedural Shader Generator ---")
    generator = ProceduralShaderGenerator()
    generator.define_shader_genes()
    
    # Generate a few shaders
    for i in range(3):
        params = generator.generate_random_shader_params()
        shader = generator.create_shader_from_params(params)
        generator.generated_shaders.append(shader)
        print(f"Generated shader {i+1}: {shader.id}")
        print(f"Parameters: {params}")
    
    # Example 2: Neural Shader Evolver
    print("\n--- Neural Shader Evolver ---")
    evolver = NeuralShaderEvolver()
    
    # Simulate user feedback
    for shader in generator.generated_shaders:
        # Simulate user ratings (could be based on aesthetic preference, performance, etc.)
        rating = random.uniform(0.3, 0.9)
        evolver.provide_feedback(shader.id, rating)
        shader.fitness_score = rating
        print(f"Shader {shader.id} rated: {rating:.2f}")
    
    # Evolve a new generation
    evolver.generator = generator  # Link the generator to the evolver
    new_generation = evolver.evolve_generation(generator.generated_shaders)
    print(f"Evolved {len(new_generation)} shaders for next generation")
    
    # Example 3: GAN System
    print("\n--- Generative Adversarial Shader System ---")
    gan_system = GenerativeAdversarialShaderSystem()
    
    # Train the GAN
    gan_system.train_gan(training_steps=20)
    
    # Generate a creative shader
    creative_shader = gan_system.generate_creative_shader()
    print("Generated creative shader:")
    print(creative_shader[:200] + "...")  # Print first 200 chars


if __name__ == "__main__":
    main()