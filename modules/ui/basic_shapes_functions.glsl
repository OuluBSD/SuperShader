// Reusable Basic Shapes UI/2D Functions
// Automatically extracted from UI/2D graphics-related shaders

// Function 1
vec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {
    float x = ro.x, y = ro.y, z = ro.z;
    float u = rd.x, v = rd.y, w = rd.z;

    float ba = b - a, ca = c - a, ea = e - a;
    float q = ba + c - d + e - f - g + h;
    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;
    float xy = x * y, uv1 = u * v;
    float xvuy = x * v + u * y;

    float coeff1 = q * uv1 * w;
    float coeff2 = dbac * uv1 + (fbae * u + gcae * v) * w + (xvuy * w + uv1 * z) * q;
    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;
    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;

    return solveCubic2(coeff1, coeff2, coeff3, coeff4);
}

// Function 2
float linear_to_srgb(float channel) {
    if(channel <= 0.0031308)
        return 12.92 * channel;
    else
        return (1.0 + SRGB_ALPHA) * pow(channel, 1.0/2.4) - SRGB_ALPHA;
}

// Function 3
float toLinear(float c) { return pow(c,GAMMA); }

// Function 4
float rectSolidAngle(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3)
{
    vec3 v0 = p0 - p;
    vec3 v1 = p1 - p;
    vec3 v2 = p2 - p;
    vec3 v3 = p3 - p;
    
    vec3 n0 = normalize(cross(v0, v1));
    vec3 n1 = normalize(cross(v1, v2));
    vec3 n2 = normalize(cross(v2, v3));
    vec3 n3 = normalize(cross(v3, v0));
    
    float g0 = acos(dot(-n0, n1));
	float g1 = acos(dot(-n1, n2));
	float g2 = acos(dot(-n2, n3));
	float g3 = acos(dot(-n3, n0));
    
    return g0 + g1 + g2 + g3 - TWO_PI;
}

// Function 5
float EdgeDirectFilter(vec2 a0,vec2 a1,vec2 a2,vec2 a3,vec2 a4){
    vec4 lum = vec4(a1.x,a2.x,a3.x,a4.x);
    vec4 w = 1.-step(THRESH,abs(lum - a0.x));
    float W = w.x + w.y + w.z + w.w;
    W = (W==0.0) ? W : 1./W;
    return dot(w,vec4(a1.y,a2.y,a3.y,a4.y))*W;
}

// Function 6
vec4
circle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )
{
    vec4 ret = vec4(0);
    color.rgb *= color.a;
    
    float dist = length( point - pos );
    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );
    
    return ret;
}

// Function 7
float sdBentLine(vec2 p, vec3 a, vec3 b, float bend, float bendWidth /*, out float distToCurve, out vec2 uv*/) {
    vec2 d = b.xy - a.xy;
    
    vec2 pd = p - a.xy;
    float t = dot(pd, d) / dot(d, d);
    t = min(1., max(0., t));
    vec2 cp = a.xy + t * d;
    cp += bend*rot90(d)*L(.5-bendWidth, .5+bendWidth, t);
    
    vec2 n = p - cp;
    float distToCurve = length(n); // optionally output this
    
    // remember a.z & b.z are radius
    float cr = mix(a.z, b.z, t);
    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;
    vec2 uv = vec2(t, v); // optionally output this

    float distToBoundary = distToCurve - cr;
    return distToBoundary;
}

// Function 8
vec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)
{
	const mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,
							         3.0, -6.0,  0.0, 4.0,
							        -3.0,  3.0,  3.0, 1.0,
							         1.0,  0.0,  0.0, 0.0) / 6.0;	
	
	float t2 = t * t;
	vec4 T = vec4(t2 * t, t2, t, 1.0);
	
	vec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);
	vec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);
	vec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);
	
	vec4 vWeights = T * mSplineBasis;
	
	vec3 vResult;
	
	vResult.x = dot(vWeights, vCoeffsX);
	vResult.y = dot(vWeights, vCoeffsY);
	vResult.z = dot(vWeights, vCoeffsZ);
	
	return vResult;
}

// Function 9
float DrawChar(in vec2 p, int chr)
{
	float cRet = 0.;

    COMP(_A) (PP(0,0) + PP(1,0) + PP(2,0) +
              PP(0,1)           + PP(2,1) +
              PP(0,2) + PP(1,2) + PP(2,2) +
              PP(0,3)           + PP(2,3) +
              PP(0,4)           + PP(2,4));
    COMP(_B) (          PP(1,0) + PP(2,0) +
              PP(0,1)           + PP(2,1) +
              PP(0,2) + PP(1,2) + PP(2,2) +
              PP(0,3)           + PP(2,3) +
                        PP(1,4) + PP(2,4));
    COMP(_C) (PP(0,0) + PP(1,0) + PP(2,0) +
              PP(0,1)           + PP(2,1) +
                                  PP(2,2) +
              PP(0,3)           + PP(2,3) +
              PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_D)  (          PP(1,0) + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3)           + PP(2,3) +
                         PP(1,4) + PP(2,4));
    COMP(_E)  (PP(0,0) + PP(1,0) + PP(2,0) +
                                   PP(2,1) +
               PP(0,2) + PP(1,2) + PP(2,2) +
                                   PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_F)  (PP(0,0) + PP(1,0) + PP(2,0) +
                                   PP(2,1) +
                         PP(1,2) + PP(2,2) +
                                   PP(2,3) +
                                   PP(2,4));
    COMP(_G)  (PP(0,0) + PP(1,0) + PP(2,0) +
                                   PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_H)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2) + PP(1,2) + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_I)            (PP(1,0) +
               		     PP(1,1) +
             			 PP(1,2) +
               		     PP(1,3) +
               			 PP(1,4));
    COMP(_J)  (PP(0,0) +
               PP(0,1) +	
               PP(0,2) +
               PP(0,3) +         + PP(2,3) +	
                       + PP(1,4));
    COMP(_K)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
                	     PP(1,2) + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_L)                     (PP(2,0) +
               		              PP(2,1) +
             					  PP(2,2) +
               		              PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_M)  (PP(0,0)           + PP(2,0) +
               PP(0,1) + PP(1,1) + PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_N)  (PP(0,0)           + PP(2,0) +
               PP(0,1) + PP(1,1) + PP(2,1) +
               PP(0,2) + PP(1,2) + PP(2,2) +
               PP(0,3) + PP(1,3) + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_O)  (PP(0,0) + PP(1,0) + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_P)            (PP(1,0) + PP(2,0) +
               PP(0,1)           + PP(2,1) +
                         PP(1,2) + PP(2,2) +
                                   PP(2,3) +
                                   PP(2,4));
    COMP(_Q)  (PP(0,0) + PP(1,0) + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
                         PP(1,3) + PP(2,3) +
               PP(0,4) + PP(1,4));
    COMP(_R)  (PP(1,0) + PP(2,0) +
               PP(0,1)           + PP(2,1) +
                	     PP(1,2) + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_S)  (PP(0,0) + PP(1,0) +
                                   PP(2,1) +
                	     PP(1,2) + 
               PP(0,3) + 
                         PP(1,4) + PP(2,4));
    COMP(_T)  (PP(0,0) + PP(1,0) + PP(2,0) +
               		     PP(1,1) +
             			 PP(1,2) +
               		     PP(1,3) +
               			 PP(1,4));
    COMP(_U)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_V)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
                         PP(1,3) +
                         PP(1,4));
    COMP(_W)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
               PP(0,2)           + PP(2,2) +
               PP(0,3) + PP(1,3) + PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    COMP(_X)  (PP(0,0)           + PP(2,0) +
               PP(0,1)           + PP(2,1) +
                	     PP(1,2) +
               PP(0,3)           + PP(2,3) +
               PP(0,4)           + PP(2,4));
    COMP(_Y)  (PP(0,0)           + PP(2,0) +
               PP(0,1) + PP(1,1) + PP(2,1) +
             			 PP(1,2) +
               		     PP(1,3) +
               			 PP(1,4));
    COMP(_Z)  (PP(0,0) + PP(1,0) + PP(2,0) +
               PP(0,1) +
                	     PP(1,2) + 
                                   PP(2,3) +
               PP(0,4) + PP(1,4) + PP(2,4));
    
   	return cRet;
}

// Function 10
float circle( vec2 uv, vec2 pos, float r, float blur )
{
	float d = length( vec2( pos.x * iResolution.x / iResolution.y, pos.y ) - uv );
	float c = smoothstep( r+blur, r-blur, d );
    return c;
}

// Function 11
float sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)
{
    // flatten the line to be axis-aligned.
    vec2 rectDimensions = b - a;
    float angle = atan(rectDimensions.x, rectDimensions.y);
    mat2 rotMat = rot2D(-angle);
    a *= rotMat;
    b *= rotMat;
    float halfLineWidth = lineWidth / 2.;
    a -= halfLineWidth;
    b += halfLineWidth;
	return sdAxisAlignedRect(uv * rotMat, a, b);
}

// Function 12
float PatternCircles(vec2 p,float m//https://www.shadertoy.com/view/MsSyRz
){p.x-=m*.5*step(0.,sin(pi*p.y/m))
 ;p=mod(p,m)-m*.5
 ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}

// Function 13
void DrawSplash(inout vec3 color, AppState s, vec2 p)
{
    vec2 resMult = floor(iResolution.xy / 64.);
    float resRcp = 1. / max(min(resMult.x, resMult.y), 1.);
    vec2 screenSize = floor(iResolution.xy * resRcp);
    vec2 pixel      = floor(gl_FragCoord.xy * resRcp - screenSize * .5);
    SpriteLeft(color, pixel  + vec2(32,8));
    SpriteRight(color, pixel + vec2(0,8));

    vec2 p2 = p;
    p2 *= 55. + 5. * abs(sin(2.0*iTime));
    p2 -= vec2(-40, -25.0);
    SpaceText(color, p2, s);

    vec2 p4 = p;
    p4 *= 90.;
    p4 -= vec2(-100, -80.0);
    CreditText(color, p4, s);

    if (s.highscore > 0.0)
    {
        vec2 p5 = p;
        p5 *= 50.;
        p5 -= vec2(-28, -38.0);
        HighscoreText(color, p5, s);
    }

    vec2 p3 = p;
    p3 *= 10.0;
    p3 -= vec2( 3.5, -7.3);
    p3 -= vec2(-0.5 * ceil(log2(s.score)/log2(10.0)), 0.0);
    float scoreColor = PrintInt(p3, s.highscore);
    color = mix(color, vec3(1.0), scoreColor);
}

// Function 14
void drawTopPipe(vec2 co, float xPos, float height)
{	
	vec2 bounds = getLevelBounds();
	
	if ((co.x < xPos) || (co.x > (xPos + PIPE_WIDTH)) ||
		(co.y < (bounds.y - height)) || (co.y > bounds.y))
	{
		return;
	}
	
	// draw the bottom part of the pipe
	// outlines
	float bottomPartEnd = bounds.y + PIPE_HOLE_HEIGHT - height;
	drawVertLine(co, xPos+1.0, bottomPartEnd, bounds.y, PIPE_OUTLINE_COLOR);
	drawVertLine(co, xPos+PIPE_WIDTH-2.0, bottomPartEnd, bounds.y, PIPE_OUTLINE_COLOR);
	
	// gradient fills
	drawHorzGradientRect(co, vec2(xPos+2.0, bottomPartEnd), vec2(xPos + 10.0, bounds.y), RGB(133, 168, 75), RGB(228, 250, 145)); 
	drawHorzGradientRect(co, vec2(xPos+10.0, bottomPartEnd), vec2(xPos + 20.0, bounds.y), RGB(228, 250, 145), RGB(86, 126, 41)); 
	drawHorzGradientRect(co, vec2(xPos+20.0, bottomPartEnd), vec2(xPos + 24.0, bounds.y), RGB(86, 126, 41), RGB(86, 126, 41));
	
	// shadows
	drawHorzLine(co, bottomPartEnd+1.0, xPos + 2.0, xPos+PIPE_WIDTH-2.0, RGB(86, 126, 41));
	
	// draw the pipe opening
	// outlines
	drawVertLine(co, xPos, bottomPartEnd - PIPE_HOLE_HEIGHT, bottomPartEnd, PIPE_OUTLINE_COLOR);
	drawVertLine(co, xPos+PIPE_WIDTH-1.0, bottomPartEnd - PIPE_HOLE_HEIGHT, bottomPartEnd, PIPE_OUTLINE_COLOR);	
	drawHorzLine(co, bottomPartEnd, xPos, xPos+PIPE_WIDTH, PIPE_OUTLINE_COLOR);
	drawHorzLine(co, bottomPartEnd - PIPE_HOLE_HEIGHT, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);
		
	// gradient fills
	float gradientBottom = bottomPartEnd - PIPE_HOLE_HEIGHT + 1.0;
	float gradientTop = bottomPartEnd;
	drawHorzGradientRect(co, vec2(xPos+1.0, gradientBottom), vec2(xPos + 5.0, gradientTop), RGB(221, 234, 131), RGB(228, 250, 145)); 
	drawHorzGradientRect(co, vec2(xPos+5.0, gradientBottom), vec2(xPos + 22.0, gradientTop), RGB(228, 250, 145), RGB(86, 126, 41)); 
	drawHorzGradientRect(co, vec2(xPos+22.0, gradientBottom), vec2(xPos + 25.0, gradientTop), RGB(86, 126, 41), RGB(86, 126, 41));
	
	// shadows
	drawHorzLine(co, gradientBottom, xPos+1.0, xPos+25.0, RGB(122, 158, 67));
	drawHorzLine(co, gradientTop-1.0, xPos+1.0, xPos+25.0, RGB(86, 126, 41));
}

// Function 15
vec4 draw_cardx(float id, bool tp) {
    int cid = int(10. * rand(vec2(10. - g_time, 5. + 2. * id + g_time)));
    //balance
    //he1 he2 pat
    float val = encodeval(vec3(floor(1. + 14. * rand(vec2(g_time, id + g_time))), floor(1. + 14. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 14. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (tp)if (cid == c_mn)cid = c_he2; //do not draw "draw" card for AI
    //other types
    if (cid == c_he2)val = encodeval(vec3(floor(1. + 25. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (cid == c_at2)val = encodeval(vec3(floor(5. + 10. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (cid == c_at1)val = encodeval(vec3(floor(1. + 10. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (cid == c_cr)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(1. + 9. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (cid == c_cr2)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(1. + 14. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(5. + 10. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    if (cid == c_cr3)val = encodeval(vec3(floor(1. + 6. * rand(vec2(g_time, id + g_time))), floor(5. + 15. * rand(vec2(g_time, id + 20. * sin(g_time)))), floor(1. + 9. * rand(vec2(0.5 * g_time, id + 20. * cos(g_time))))));
    return vec4(val, 0., get_card_col(cid), float(cid));
}

// Function 16
vec4 rect(vec2 uv, vec2 minV, vec2 maxV, vec3 color, bool isSolid)
{
	float d = max(max(uv.x-maxV.x, minV.x-uv.x), max(uv.y-maxV.y, minV.y-uv.y)) * FADE_SCALE;
    d = isSolid ? d : abs(d);
	return vec4(color, 1. - clamp(d, 0., 1.));
}

// Function 17
float line2(float d,vec2 p,vec4 l){vec2 pa=p-l.xy;vec2 ba=l.zw-l.xy;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return min(d,length(pa-ba*h));}

// Function 18
vec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {
    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);
}

// Function 19
vec2 DirectRand(uint index) {
    uvec2 v = index * uvec2(391234230u, 3332033867u) + uvec2(1196435762u, 3519870697u);
    v = v ^ (v>>16u);
    v.x += v.y * 1664525u;
    v.y += v.x * 1664525u;
    return vec2(v >> 16u) / float(0x10000);
}

// Function 20
float drawInt(int v,int m){float c=0.;
 if(v<0){v=-v;if(m<1)m=1;else m--; _sub}
 int f=v,d=1;d=getNumberOfDigits(f,d);//for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} 
 d=max(m,d);tpm*float(d);
 for(int n=1;n<11;n++){tpp;c+=char(48+(v-((v/=10)*10)));if(n>=d)break;} 
 tpm*float(d);return c;}

// Function 21
void DrawSpectrum( inout DrawContext drawContext, vec3 vColBG )
{   
    vec2 vSpectrumUV = GetSpectrumUV( drawContext.vUV, 0 );
    
    float fGap = 0.01;

    float fSpread0 = 0.01;
    float x0 = vPrismPoint.x - 0.1 - fSpread0;
    float x1 = vPrismPoint.x - 0.1 + fSpread0;
    
    vec2 v0 = vec2(x0, ProjectPlane( x0, vPrismN1, fPrismD1 ) );
    vec2 v1 = vec2(x1, ProjectPlane( x1, vPrismN1, fPrismD1 ) );
    vec2 v2 = vec2(fSpMaxX, fSpMinY - fGap);
    vec2 v3 = vec2(fSpMinX, fSpMinY - fGap);
    
    vec2 vSpreadUV = invBilinear( drawContext.vUV, v0, v1, v2, v3 );    
    bool inSpreadLight = InUnitSquare( vSpreadUV );

    float fSpread1 = 0.005;
    float x4 = vPrismPoint.x - 0.09 - fSpread1;
    float x5 = vPrismPoint.x - 0.09 + fSpread1;
    
    vec2 v4 = vec2(x4, ProjectPlane( x4, vPrismN2, fPrismD2 ) );
    vec2 v5 = vec2(x5, ProjectPlane( x5, vPrismN2, fPrismD2 ) );

    vec2 vSpreadUV_B = invBilinear( drawContext.vUV, v0, v1, v5, v4 );    
    bool inSpreadLightB = InUnitSquare( vSpreadUV_B );
    

    
    if ( !inSpreadLight )
    {
        if ( inSpreadLightB )
        {
            inSpreadLight = true;
            vSpreadUV = vSpreadUV_B;
            vSpreadUV.y = 0.0;
        }
    }
    
#if !SHOW_SPREAD
    inSpreadLight = false;
#endif    
    
    // Hack convergence color
    vSpreadUV.y = vSpreadUV.y * 0.96 + 0.04;
    
    vec2 vBeamA = (v4 + v5) * 0.5;
    vec2 vBeamB = vec2(0.66 + fGlobalXOffset,0);
    
    float fBeamDist = LineInfo( drawContext.vUV, vBeamA, vBeamB );
    float fBeam = clamp( abs(fBeamDist) * 200.0, 0.0, 1.0 );
    fBeam = sqrt( 1.0 - fBeam * fBeam);
    fBeam += GetGlare( abs( fBeamDist ) ) * 0.2;
    
    float fGlareDist = length( drawContext.vUV - vBeamA );
    float fBeamGlare = GetGlare( fGlareDist );

    
#if !SHOW_BEAM    
    fBeam = 0.0;
    fBeamGlare = 0.0;
#endif    

    bool inSpectrum = InUnitSquare( vSpectrumUV );    

#if SEPARATE_SPECTRUM    
	inSpectrum = inSpectrum || InUnitSquare( GetSpectrumUV( drawContext.vUV, 1 ) ) || InUnitSquare( GetSpectrumUV( drawContext.vUV, 2 ) );
#endif
    
#if !SHOW_SPECTRUM
    inSpectrum = false;
#endif
    
    float fSpreadLightW0 = mix(standardObserver1931_w_min - 20.0, standardObserver1931_w_max + 20.0, vSpreadUV.x);
    float fSpectrumW0 = mix(standardObserver1931_w_min - 20.0, standardObserver1931_w_max + 20.0, vSpectrumUV.x);
    
    
    vec3 vLightColor = vec3(0);
    
    vec3 vTotXYZ = vec3(0);
    for( float w = standardObserver1931_w_min; w < NO_UNROLLF(standardObserver1931_w_max); w += 5.0 )
    {
        vec3 vCurrXYZ = WavelengthToXYZLinear( w );

        float fPower = GetSPD( w );
        
        if ( inSpreadLight )
        {
            float fWeight = UnitGaussian( w, fSpreadLightW0, 0.2 * vSpreadUV.y);
        	vTotXYZ += vCurrXYZ * fWeight * fPower * 0.01;
        }

        float t = (w - standardObserver1931_w_min) / (standardObserver1931_w_max - standardObserver1931_w_min);
        
#if SHOW_SPREAD        
        {
            vec2 vSpPos = vec2( mix( fSpMinX, fSpMaxX, t), fSpMinY - fGap);
            
            vec2 vOffset = vSpPos - drawContext.vUV;
            float d = length( vOffset );
            if ( vOffset.y > 0.0 && d < 0.5 )
            {
	        	vTotXYZ += vCurrXYZ * GetSpectrumGlare( d ) * fPower;
            }
        }
        
        {
            vec2 vPrismPos = mix( v0, v1, t );
            
            vec2 vOffset = vPrismPos - drawContext.vUV;
            float d = length( vOffset );
            if ( d < 0.5 )
            {
	        	vTotXYZ += vCurrXYZ * GetPrismGlare( d ) * fPower;
            }
        }
#endif        
        
        vLightColor += vCurrXYZ * fPower;
    }
    
    vTotXYZ += vLightColor * (fBeam + fBeamGlare) * 0.03;

#if DRAW_PRISM        
    float fPrismShade = PrismShade( drawContext.vUV );    
    vTotXYZ += vLightColor * fPrismShade * 0.1 * vec3( 0.8, 0.9, 1 );
    vTotXYZ += fPrismShade * .3 * vec3( 0.8, 0.9, 1 );
#endif    
    
    if ( inSpectrum )
    {
        vTotXYZ += WavelengthToXYZLinear(fSpectrumW0) * 0.3;
    }
    
    /*if (  drawContext.vUV.y > fSpMinY - fGap )
    {
    	vTotXYZ += 0.5;
    }*/
    
    mat3 cat = GetChromaticAdaptionTransform( mCAT_Bradford, XYZ_D65, XYZ_E );           
	vTotXYZ = vTotXYZ * cat;
        
    vec3 vColor = XYZtosRGB( vTotXYZ );    
    vColor = max( vColor, vec3(0) );
    
    vColor += vColBG;

#if SHOW_LUMINOSITY_BAR    
    vec2 vLuminosityUV = vSpectrumUV;
    vLuminosityUV.y += 1.5;
    if ( InUnitSquare( vLuminosityUV ) )
    {
        float l = WavelengthToLuminosityLinear( fSpectrumW0 ) ;
        vColor += vec3(l);
    }
#endif    
    
    vColor = 1.0 - exp2( vColor * -2.0 ); // Tonemap
    
    vColor = pow( vColor, vec3(1.0 / 2.2) );
        
    drawContext.vResult = vColor;
}

// Function 22
vec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, float NdotV, float roughness,
              vec3 f0, out vec3 fresnel, out vec3 diffCol, out vec3 specCol)
{
  
    vec4 result = vec4(0.);
    // ensure the points are wound counter-clockwise (only debug)
    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);
    if (windingCheck > 0.)
		return result;
    
    float solidAngle = rectSolidAngle(p, rect.a, rect.b, rect.c, rect.d);
    
    // diffuse
    result.w = solidAngle * .2 * (
        saturate(dot(normalize(rect.a - p), n)) +
        saturate(dot(normalize(rect.b - p), n)) +
        saturate(dot(normalize(rect.c - p), n)) +
        saturate(dot(normalize(rect.d - p), n)) +
        saturate(dot(normalize(rect.center - p), n)));   
    
    Ray rectRay = Ray(p, r);
    
    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point
    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;
    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), 
                               dot(planePointCenter, rect.up));
    //vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);
    vec2 c = clamp(planePointProj, -rect.halfSize, rect.halfSize);
    vec3 L = rect.center + rect.right * c.x + rect.up * c.y;
#ifdef LIGHT_TEXTURE
    // calculate light uv
    vec3 L0 = L - rect.c;
    vec2 luv = vec2(dot(rect.right, L0), dot(rect.up, L0)) / (rect.halfSize * 2.);
#endif
    L -= p;
    
    vec3 l = normalize(L);
    vec3 h = normalize(l + v);
    float lightDist = length(L);
    
    float NdotH = max(0., dot(n, h));
    float VdotH = dot(v, h);
    
    float alpha = roughness * roughness;
    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));
    
#ifdef LIGHT_TEXTURE
    // calculate approx light diffuse and specular colors (super experimental :p) 
    diffCol = pow(textureLod(iChannel1, luv, pow(exp(lightDist + .5), 2.)).rgb, vec3(2.2));
    specCol = pow(textureLod(iChannel1, luv, exp(lightDist * alpha + .5) + 1.).rgb, vec3(2.2));
#endif
    
    result.xyz += geometrySmith(NdotV, result.w, roughness) 
        * ndfTrowbridgeReitzRect(NdotH, alpha, alphaPrime)
        * fresnelSchlick(f0, VdotH);
    
    return result;
}

// Function 23
vec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2, out float pdf ) {
    pdf = 1.0 / (2.0 * PI);
    vec2 r = vec2(Xi1,Xi2)*TWO_PI;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dot(dr,n) * dr;
}

// Function 24
float sdCircleStairs (vec3 q) {
  float a = length (q.xz) > 0. ? atan (q.z,- q.x) / TAO : 0.;
  q.xz = vec2(24.* a, length(q.xz) - 6.);
  pR45(q.xy);
  float s = mod(q.x, sqrt(.5));
  return max (q.y - min(s, sqrt(.5) - s), abs(q.z-3.)-6.);
}

// Function 25
void line (
    inout vec4 fragColorR, 
    in float lat180,  
    in float lat180target, 
    in float lat180radius,

	float a)
{
    if (lat180 < (lat180target + lat180radius))
        if (lat180 >( lat180target - lat180radius))
            
 		//if (lat180 < 108.)
     //   if (lat180 > 72.)            
        {

            
            //float a = 0.3;

            

            fragColorR.r = a;
            fragColorR.b = a;
            fragColorR.g = a;

        }
}

// Function 26
float ToLinear1(float c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}

// Function 27
float line(vec2 p, vec2 p0, vec2 p1)
{
    vec2 a = p-p0; // the vector that we want to project on b
    vec2 b = p1-p0; // this line is our goal.
    
    vec2 proj = clamp((dot(a,b)/dot(b,b)),0.0,1.0)*b; // vector projection of a onto b
    vec2 rejc = a-proj; // vector rejection or distance in other words
    
    return smoothstep(0.0,1.2,1.0-dot(rejc, rejc)*1e4);
}

// Function 28
vec3 randomDirection( in float Xi1, in float Xi2 ) {
    float theta = acos(1.0 - 2.0*Xi1);
    float phi = TWO_PI * Xi2;
    
    return sphericalToCartesian( 1.0, phi, theta );
}

// Function 29
float sDistLine(vec2 a, vec2 b) {
       
    b -= a; return dot(a, vec2(-b.y, b.x)/length(b)); //return dot(a, normalize(vec2(-b.y, b.x)));
    
}

// Function 30
void initRect(vec2 rot)
{
    rect.up = rotateYX(vec3(0., 1., 0.), rot);
    rect.right = rotateYX(vec3(1., 0., 0.), rot);;
    rect.front = normalize(cross(rect.right, rect.up));
    rect.halfSize = vec2(5., 3.);
    
    rect.center = vec3(0., 5., 0.);
    
    rect.a = rect.center + rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;
    rect.b = rect.center - rect.halfSize.x * rect.right + rect.halfSize.y * rect.up;
    rect.c = rect.center - rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;
    rect.d = rect.center + rect.halfSize.x * rect.right - rect.halfSize.y * rect.up;
}

// Function 31
vec3 srgbToLinear(const vec3 x){
    return 0.315206*x*((2.10545+x)*(0.0231872+x));
}

// Function 32
vec3 drawPacman ( vec3 col, in vec2 fragCoord)
{
	// normalize pixel coords to 0-1  : fragCoord / iResolution.y
    // 31 is the nr of cells across the screen
    // map pixel coords to 0 - 31 cells
    
    float cells = 31.0;
    vec2 pp = cells * fragCoord / iResolution.y;
   
    // read pacman pos
    vec2 pacmanPos = texture(iChannel0, vec2( 50.5/iChannelResolution[0].xy)).xy;
    
    // create a circle with center in pacmanPos and radius = 1 cell
    float r = length (pp - pacmanPos);
    // The biggest the difference between a and b in 
    // smoothstep ( a, b, r) below, the smoother the margin
    float f = 1.0 - smoothstep(1.0, 1.5, r);
    // paint the circle black and leave the rest as is
    col = mix(col, vec3(0.0, 0.0, 0.0), f);
    
    return col;
}

// Function 33
void LineTest(in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv, inout vec4 dis_col)
{
    vec2 pa = p-a;
    vec2 ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);
    float d = length(pa-h*ba);
    if( d<dis_col.x )
    {
        float s = pa.x*ba.y-pa.y*ba.x;
        dis_col = vec4(d,(s<0.0)?cu:cv);
    }
}

// Function 34
float drawHope(vec2 uv) {
	return fill(vesicaSDF(uv,.2),.3);
}

// Function 35
maybe_vec2 get_distances_along_3d_line_to_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r
){
    vec3 B = normalize(B2 - B1);
    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);
    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);
    float a_in = min(a1.value, a2.value);
    float a_out = max(a1.value, a2.value);
    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);
    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);
    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);
    // TODO: do we need this line?
    float entrance = max(tube.value.y,  a_in);
    float exit     = min(tube.value.x, a_out);
    return maybe_vec2( 
        vec2(entrance, exit), 
        tube.exists && entrance < exit
    );
}

// Function 36
Rect GetFontRect( PrintState state, LayoutStyle style, bool initialLineOffset )
{
    Rect rect;
    
    rect.vPos = state.vLayoutStart;
    if ( initialLineOffset )
    {
    	rect.vPos.y += style.vSize.y * (style.fLineGap + g_fFontAscent);
    }
	rect.vPos.y -= style.vSize.y * (g_fFontAscent);
    rect.vSize.x = state.vCursorPos.x - state.vLayoutStart.x;
    rect.vSize.y = style.vSize.y * ( g_fFontAscent + g_fFontDescent );
    
    return rect;
}

// Function 37
float drawObject(in vec3 p){
  
    p = fract(p)-3.14;
    return dot(p, p);
    
}

// Function 38
vec3 linearTosRGB(const in vec3 color) {
    return vec3(LIN_SRGB(color.r), LIN_SRGB(color.g), LIN_SRGB(color.b));
}

// Function 39
vec3 LinearToSRGB(vec3 rgb)
{
    rgb = clamp(rgb, 0.0f, 1.0f);
    
    return mix(
        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,
        rgb * 12.92f,
        LessThan(rgb, 0.0031308f)
    );
}

// Function 40
ReducedQuintic tschirnhausLinear(in GeneralQuintic eq) {
    float a = eq.a, b = eq.b, c = eq.c, d = eq.d, e = eq.e, f = eq.f;
    b /= a, c /= a, d /= a, e /= a, f /= a;
    float p = c - 2.0 * b * b / 5.0;
    float q = d - 3.0 * b * c / 5.0 + 4.0 * b * b * b / 25.0;
    float r = e - 2.0 * b * d / 5.0 + 3.0 * b * b * c / 25.0 - 3.0 * b * b * b * b / 125.0;
    float s = f -       e * b / 5.0 +       b * b * d / 25.0 -       b * b * b * c / 125.0 + 4.0 * b * b * b * b * b / 3125.0;
    return ReducedQuintic(p, q, r, s, b / 5.0);
}

// Function 41
vec4 tex3D_trilinear(in sampler2D texAtlas, in vec3 uvw, in vec2 numTilesXY)
{
    // calculate the number of tiles to be accessed. This is required within the following
    // "numSamples" variable.
    float numTiles = numTilesXY.x * numTilesXY.y;
    
    // "tileIncrement" controls how much we need to increment the current Z value to reach
    // the next tile.
    float tileIncrement = 1.0 / numTiles;
    
    // X & Y would normally be incremented by an offset to filter pixels in the horizontal
    // and vertical directions, but we're only filtering in the Z direction for now.
    float z = uvw.z;
    vec3 sampleCoord0 = vec3(uvw.xy, z);
    vec3 sampleCoord1 = vec3(uvw.xy, max(z+tileIncrement, 0.0));

    // convert 3D texture coordinates to 2D.
    vec2 uv0 = convert_3d_to_2d(sampleCoord0, numTilesXY);
    vec2 uv1 = convert_3d_to_2d(sampleCoord1, numTilesXY);

    // Perform the texture lookups.
    // NOTE: This code only two texture-lookups because we're filtering tiles in the
    // z-direction (bilinear filtering is assumed to be applied already. One tile is needed
    // for the current tile, and another is needed to filter against the next closest tile.
    // coordinates.
    vec4 cz0 = texture(texAtlas, uv0);
    vec4 cz1 = texture(texAtlas, uv1);

    // Calculate the texel weights along the texture's z-axis. The weights of the final
    // output color must sum to 1.
    z = z * numTiles;
    float weight0 = fract(z);
    float weight1 = 1.0 - weight0;

    // Blend the textures together using the weighted values from the textures.
    return cz1*weight1 + cz0*weight0; // may compile into one MUL and one FMA
}

// Function 42
float torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)
{
    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
    //  ⇓
	//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
	//  ⇓
    
    vec3 tk = torusKnot(t, tkp);
    vec3 tkd = torusKnotDerivative(t, tkp);
        
    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);
    //  ⇓
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));
    //  ⇓
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));
    //  ⇓
    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));
}

// Function 43
float linear_srgb(float x) {
    return mix(1.055*pow(x, 1./2.4) - 0.055, 12.92*x, step(x,0.0031308));
}

// Function 44
float drawMoon(in vec2 st, in float offset, in float smallRad){
    return positive(drawCircle(st+.5,.4)-drawCircle(st+.5-offset,smallRad));
}

// Function 45
vec3 drawText( in vec4 fragColor, in vec2 fragCoord ) {
    float display_width = 1010.;
    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line
    
    vec2 uv = (fragCoord.xy) / iResolution.xx;
    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   
    uv *= display_width;

    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));

    uv = mod_uv(uv);
    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner
    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   
    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);
    
    float tx = 10000.;
    int idx = 0;
    
    NL 
    NL 
    NL 
    NL 
    NL 
    NL 
    SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP G A M E SP O V E R 
    NL
        
    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);
    
    vec3 terminal_color = tcol;
    
    return terminal_color;
}

// Function 46
float circle(vec2 u, vec2 p, float r) {
	return 1.-smoothstep(r,r+A,distance(u,p));
}

// Function 47
float DrawSymbol(in vec2 p, int chr)
{
    float cRet = 0.;
    
    COMP(_SLASH) (PP(0,0) +
                  PP(0,1) +
                            PP(1,2) +
                                      PP(2,3) + 
                                      PP(2,4));
    
    COMP(_PLUS)            (PP(1,1) +
                  PP(0,2) + PP(1,2) + PP(2,2) +
               		        PP(1,3));
    
    COMP(_EXCLAM)       (PP(1,0) +
               		     PP(1,1) +
             			 PP(1,2) +
               		     
               			 PP(1,4));
    
    COMP(_HYPHEN) (PP(0,2) + PP(1,2) + PP(2,2));
 
    return cRet;
}

// Function 48
float circleeq(vec2 pos, float radius){
float x = uv.x - pos.x;
float y = uv.y - pos.y;
return sqrt(x*x + y*y) - radius;
    
}

// Function 49
vec3 draw3DScene(Cam perspectiveCam, Cam sceneCam, vec2 uv, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad)
{
    vec3 o = sceneCam.O;
    vec3 d = ray(uv,sceneCam);
    
    vec3 cScene = vec3(0);
    
    float t = rayPlaneIntersec(o,d, vec3(0,-1.0,0), vec3(0,1,0));
    if(t<0.0)
    {
        t = 1000.0;
        cScene = apply_atmosphere(t,vec3(1),o+t*d);
    }
    else
    {
		vec3 pFloor = o+t*d;
    	vec3 cFloor = texture(iChannel1,pFloor.xz*0.25).xyz;
    	cScene = apply_atmosphere(t,cFloor,pFloor);
    }
    
    float fZoom = 3.0*iResolution.x/1920.;
    vec2 aDebug = camProj(sceneCam,wsQuad.a);
    vec2 bDebug = camProj(sceneCam,wsQuad.b);
    vec2 cDebug = camProj(sceneCam,wsQuad.c);
    vec2 dDebug = camProj(sceneCam,wsQuad.d);
    vec2 oDebug = camProj(sceneCam,perspectiveCam.O);
    cScene = drawPoint(uv,aDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,bDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,cDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,dDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,oDebug,cScene,vec3(0,0,1),0.005, fZoom);
    cScene = drawLine(uv,aDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,bDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,cDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,dDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,aDebug,bDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,bDebug,cDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,cDebug,dDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,dDebug,aDebug,cScene,vec3(0),0.0025, fZoom);
    
    //Projection Plane (camera near plane)
    float tImage = rayPlaneIntersec(o,d, perspectiveCam.O+normalize(perspectiveCam.D), perspectiveCam.D);
    if(tImage>0.0) //tImage < 0 when the ray never intersects the floor plane (intersection happens behind camera)
    {
        vec3 pImage = o+tImage*d;
        vec2 uv = camProj(perspectiveCam,pImage);
        
        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)
        {
            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);
            cScene = alphaBlend(cScene,cPersp,0.5);
        }
    }
    
    //
    vec3 nQuad = cross((wsQuad.b-wsQuad.a),(wsQuad.d-wsQuad.a));
    float tQuad = rayPlaneIntersec(o,d, wsQuad.a, nQuad);
    if(tQuad>0.0) //tQuad < 0 when the ray never intersects the floor plane (intersection happens behind camera)
    {
        vec2 uv = findParallelogramUV(o,d,wsQuad);
        if(uv.x>0.0 && uv.x<1.0 &&
           uv.y>0.0 && uv.y<1.0 )
        {
            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);
        	vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);
            cScene = alphaBlend(cScene,cTest,0.5);
        }
    }
    
    return cScene;
}

// Function 50
void TestCircle (in vec2 coordinate, in SCircle circle, inout SBestHit bestHit)
{
	float dist = length(circle.m_center - coordinate) - circle.m_radius;
	if (dist < bestHit.m_dist)
	{
		bestHit.m_dist = dist;
		bestHit.m_color = circle.m_color;
	}
}

// Function 51
float Rectangle(vec2 point, vec2 size, vec2 uv)
{
    return smoothstep(size.x + AA_SIZE, size.x - AA_SIZE, length(uv.x - point.x))
        * smoothstep(size.y + AA_SIZE, size.y - AA_SIZE, length(uv.y - point.y));
}

// Function 52
float sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)
{
    // flatten the line to be axis-aligned.
    vec2 rectDimensions = b - a;
    float angle = atan(rectDimensions.x, rectDimensions.y);
    mat2 rotMat = rot2D(-angle);
    a *= rotMat;
    b *= rotMat;
    float halfLineWidth = lineWidth / 2.;

    uv *= rotMat;
    vec2 tl = vec2(a.x - halfLineWidth, a.y);
    vec2 br = vec2(b.x + halfLineWidth, b.y);

    return min(min(sdAxisAlignedRect(uv, tl, br),
                   sdCircle(uv, a, halfLineWidth)),
                   sdCircle(uv, b, halfLineWidth));
}

// Function 53
float dist_circle(vec2 p, float r)
{
    //
    // Calculates the (signed) distance to a circle
    //
	return length(p) - r;
}

// Function 54
vec2 invBilinear( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )
{
    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = ccross( g, f );
    float k1 = ccross( e, f ) + ccross( h, g );
    float k0 = ccross( h, e );
    
    float w = k1*k1 - 4.0*k0*k2;
    
    if( w<0.0 ) return vec2(-1.0);

    w = sqrt( w );
    
    float v1 = (-k1 - w)/(2.0*k2);
    float v2 = (-k1 + w)/(2.0*k2);
    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);
    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);
    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;
    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;
    
    vec2 res = vec2(-1.0);

    if(  b1 && !b2 ) res = vec2( u1, v1 );
    if( !b1 &&  b2 ) res = vec2( u2, v2 );
    
    return res;
}

// Function 55
float sdLine(vec3 p, vec3 a, vec3  b, float r)
{
    vec3 ab = b-a;
    float t = clamp(dot(p-a,ab)/dot(ab,ab),0.,1.);
    return length(p-a-ab*t)-r;
}

// Function 56
bool RectContains(Rect rect, vec2 pos)
{
    return (rect.x <= pos.x && pos.x < rect.x + rect.w &&
            rect.y <= pos.y && pos.y < rect.y + rect.h);
}

// Function 57
float fLineSegment(pab){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}

// Function 58
float SplineValue(in float t)
{
    return
        P0 * N_i_3(t, 0.0) +
        P1 * N_i_3(t, 1.0) +
        P2 * N_i_3(t, 2.0) +
        P3 * N_i_3(t, 3.0) +
        P4 * N_i_3(t, 4.0) +
        P5 * N_i_3(t, 5.0) +
        P6 * N_i_3(t, 6.0) +
        P7 * N_i_3(t, 7.0);      
}

// Function 59
float drawShape(in vec2 p){
    
    // Wrappable circle distance. The squared distance, to be more precise.
    p = fract(p) - .5;    
    return dot(p, p);
    
    // Other distance metrics.
    
    //p = abs(fract(p) - .5);
    //p = pow(p, vec2(8));
    //return pow(p.x+p.y, .125)*.25;
    
    //p = abs(fract(p) - .5);
    //p *= p;
    //return max(p.x, p.y);
    
    //p = fract(p) - .5;
    //float n = max(abs(p.x)*.866 + p.y*.5, -p.y);
    //return n*n;
    
}

// Function 60
float DrLine (vec2 p, vec2 a, vec2 b, float w)
{
  vec2 v;
  float s;
  v = a - b;
  s = 0.5 * length (v);
  v = Rot2D (p - b, atan (v.y, - v.x)) + vec2 (s, 0.);
  return smoothstep (0., 0.02, PrRoundBox2Df (v, vec2 (s, 0.001 * w), 0.0001 * w));
}

// Function 61
vec4 SPLINE_PointArray(int i, SPLINE_CtrlPts ctrlPts)
{
    //Just a way to get around the fact global arrays do not support random index access.
    //(only texture/resources)
    if(i==0 || i==SPLINE_POINT_COUNT  ) return ctrlPts.p[0];
    if(i==1 || i==SPLINE_POINT_COUNT+1) return ctrlPts.p[1];
    if(i==2 || i==SPLINE_POINT_COUNT+2) return ctrlPts.p[2];
    if(i==3) return ctrlPts.p[3];
    if(i==4) return ctrlPts.p[4];
    if(i==5) return ctrlPts.p[5];
    if(i==6) return ctrlPts.p[6];
    if(i==7) return ctrlPts.p[7];
    return vec4(0);
}

// Function 62
vec4 DrawKeys( vec2 uv, float keyID, vec2 size, float state)
{
    vec4 ret = vec4(0.);
    if (state > 0.5)
        size.y *=1.8;

    vec2 pos = vec2(keyID*0.2+size.x/2., size.y/2.);
    
    if ( abs(uv - pos).x < size.x/2. && abs(uv-pos).y < size.y/2. )
    {
        
        if ( state > 0.5 )
        {
            ret.a = 1.;
            ret.xyz = keyColors[int(keyID)];
            }
       	else
        {
            ret.a = 0.7;
            ret.xyz = keyColors[int(keyID)];
        }
           
    }
    return ret;
}

// Function 63
float QCirclePattern(in vec2 p)
{
  vec2 p2 = mod(p*8.0, 4.0)-2.0;
  return sin(lengthN(p2, 4.0)*16.0);
}

// Function 64
vec3 draw_fog(vec3 p, float d, bool is_edge)
{
    if(is_edge)return vec3(0);
    d /= FAR;
    float z = 1.-min(max(p.z-.03, 0.)*5., 1.);
    z *= d;
    return vec3(.7, .7, .9)*z*.7;
}

// Function 65
void drawCloud(int x, int y)
{
	if (y < 0 || y > 6 || x < 0 || x > 15) {
		return;
	}
	
	float col = 0.0; // 0 = transparent

	if (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  5) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);
	if (y ==  4) col = SPRROW(x,0.,0.,1.,1.,2.,2.,2.,2., 2.,2.,2.,2.,1.,1.,0.,0.);
	if (y ==  3) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);
	if (y ==  2) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);
	if (y ==  1) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);
	if (y ==  0) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);
		
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(218,246,216);
	}
	else if (col == 2.0) {
		fragColor = RGB(233,251,218);
	}
}

// Function 66
void Draw1( inout vec3 color, float x, float y )
{    
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if (    ( y <= 1.0 )
             || ( x >= 5.0 && x <= 8.0 )
             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )
           )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 67
float drawBlob(
    in vec2 st,
    in vec2 center,
    in float radius,
    in float edgeSmoothing
) {
    float dist = length((st - center) / radius);
    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 5.1))), dist);
}

// Function 68
float circle(vec2 pt, float r, vec2 center, float lw) {
  vec2 p = pt - center;
  float len = length(p);
  float hlw = lw / 2.;
  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);
}

// Function 69
vec3 linear_to_gamma(vec3 c)
{
    return vec3(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b));
}

// Function 70
vec3 DirectDiskR2(uint index) {
    return MapDisk(DirectR2(index));
}

// Function 71
float drawInt(int value)               {return drawInt(value,1);}

// Function 72
vec4 draw(vec4 sceneColor, vec4 objectColor, float dist)
{
    vec4 c = mix(sceneColor, objectColor, fill(dist));
    c = mix(c, vec4(0.0), outline(dist, 2.5));
    return c;
}

// Function 73
vec3 linearLight (vec3 target, vec3 blend){
    vec3 temp;
    temp.x = (blend.x > 0.5) ? (target.x)+(2.0*(blend.x-0.5)) : (target.x +(2.0*blend.x-1.0));
    temp.y = (blend.y > 0.5) ? (target.y)+(2.0*(blend.y-0.5)) : (target.y +(2.0*blend.y-1.0));
    temp.z = (blend.z > 0.5) ? (target.z)+(2.0*(blend.z-0.5)) : (target.z +(2.0*blend.z-1.0));
    return temp;
}

// Function 74
vec2 RayDirection(in vec2 pixel, out bool pip)
{
    // Pixel coordinates
    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;
   if (pip==true)
   {    
    const float fraction=1.0/4.0;
    // Picture in picture
    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))
    {
        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);
        pip=true;
    }
       else
       {
           pip=false;
       }
   }
   return p;
}

// Function 75
vec3 draw(vec2 uv) {
    return vec3(texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb);
}

// Function 76
float drawN(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float val = float(isIn(length(uv), cMin, cMax) && uv.y > 0.0);
  float valB = float(isIn(uv.y, -cMax, 0.0) && (isIn(uv.x, -cMax, -cMin) || isIn(uv.x, cMin, cMax)));
  return val+valB;
}

// Function 77
float DrawExplosion(int id, inout vec4 color, vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float enableFlare)
{
  id *= 100; 
  float dist =-10000.;
  float life = read(ivec2(122+id, 0));

  // check if explosion has been spawned
  if (life>0. )
  {     
    vec3 pos = normalize(readRGB(ivec2(120+id, 0))-planePos); 
    float eDist = pow(max(0., dot(pos, rayDir)), 2.0); 
    float intensity =GetExplosionIntensity(life);
    dist = eDist*intensity*1.4;
    color.rgb += CalculateExplosionFlare(rayDir, rayOrigin, screenSpace, 1.0-intensity, pos, enableFlare);
    color.rgb = mix(color.rgb, color.rgb+vec3(1.0, 0.4, 0)*0.5, eDist*intensity);
  }   
  return dist;
}

// Function 78
float sdCircleCircle( in vec3 p, in int n, float zeichen){
float a0 = float(n) / radians(360.); 
float a = round(atan(p.z, p.x) * a0) / a0;
vec3 sp = p - vec3(cos(a), 0.0, sin(a));
  
float cs = cos(a), si = sin(a);//erste versuch!!!!
sp.xz*=mat2(cs, si, -si, cs);
  
cs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!
sp.xy*=mat2(cs, si, -si, cs);
    
sp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);
return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.02;  

    
    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; 
}

// Function 79
bool UIDrawContext_ScreenPosInView( UIDrawContext drawContext, vec2 vScreenPos )
{
    return Inside( vScreenPos, drawContext.clip );
}

// Function 80
float fCircle(vec3 p,float r){return length(vec2(p.y,length(p.xz)-r));}

// Function 81
void drawBox(inout vec3 color, vec3 fill, vec3 stroke, vec2 fragCoord, vec2 position, vec2 size)
{
    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&
        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {        
        color = fill;
        
        if (fragCoord.x - 0.5 == position.x ||
            fragCoord.x - 0.5 == position.x + size.x - 1.0 ||
            fragCoord.y - 0.5 == position.y ||
            fragCoord.y - 0.5 == position.y + size.y - 1.0) {
            color = stroke;
        }        
    }
}

// Function 82
void DrawTemperateForest(out vec4 c){
	c = vec4(0.0, 0.5, 0.3, 1.0);
}

// Function 83
vec3 circle(vec2 coord, float bias)
{
    float repeat = sin(iTime * 0.4) * 10.0 + 30.0;

    float interval = iResolution.x / repeat;
    vec2 center = iResolution.xy * 0.5;

    float dist1 = distance(coord, center);
    float num = max(floor(dist1 / interval + 0.5) + bias, 1.0);
    float radius = num * interval;

    float phase1 = iTime * 3.0 + radius * 0.04;
    float phase2 = phase1 * 1.3426;
    vec2 offs = vec2(sin(phase1), cos(phase2)) * interval * 0.5;
    float dist2 = distance(coord, center + offs);

    float width = interval * 0.33;
    float c = clamp(width * 0.5 - abs(radius - dist2), 0.0, 1.0);

#if MONOCHROME
    return vec3(1, 1, 1) * c;
#else
    float c_r = 0.7 + 0.2 * sin(phase1 * 0.12);
    float c_g = 0.5 + 0.2 * sin(phase1 * 0.34);
    float c_b = 0.3 + 0.2 * sin(phase1 * 0.176);
    return vec3(c_r, c_g, c_b) * c;
#endif
}

// Function 84
void drawCurve(inout vec4 baseCol, vec4 curveCol, float value)
{
  // Using y distance to curve, modifying distance threshold with approximated slope
  // Derivative breaks with drastic changes of value and discontinuities, but so be it
  float yDist = abs(value - uv.y);
  float dValue = abs(dFdx(value));
  float c = 1.0 - smoothstep(0.0, (dxy.y + dValue) * 2.0, yDist);
  mixColor(baseCol, curveCol, c);
}

// Function 85
float circleNE(vec2 q, vec2 pos ) {
    vec2 p = q - pos;
    
    if(p.x > 0.0 && p.y > 0.0) {
        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;
    } else {
        return 10.0;
    }
}

// Function 86
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float offset=1.5*snoise(uv+sin(iTime));
    float noise=.5*gnoise(uv);
    float theta = offset*(atan(d.y,d.x)/M_PI);
    return smoothstep(4.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}

// Function 87
float directional(vec3 origin, vec3 normal, float focus) {
	return pow(max(0.0, dot(normalize(origin), normal)), focus);
}

// Function 88
float drawFloat(float v,int p,int m){float c=0.,
 tpx=tp.x-FONT_SPACE*float(m);
 if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write "-"
 c+=drawInt(int(v),1);    //write floor()
 c+=char(46); SPACE;      //write "."
 c+=drawFract(p,fract(v));//write fract() 
 tp.x = min(tp.x, tpx); 
 return c;}

// Function 89
void drawSegment(vec2 uv, inout vec3 color, Line s){
    float alpha = s.color.a;
    #if DARKMODE
    alpha = pow(alpha, 1.5);
    #else
    alpha = pow(alpha, 0.75);
    #endif
    color = mix(s.color.rgb, color, (1.0-alpha) + alpha*segmentShape(uv, s));
}

// Function 90
float PatternCircles(vec2 p,float m//giraffe bubbles of
){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz
 ;p=mod(p,m)-m*.5
 ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}

// Function 91
vec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }

// Function 92
float sdLine( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h );
}

// Function 93
void beginDraw()
{
    fontBuffer = vec4(.0,.0,.0,1.);
    fontCol = vec4(.0);
    fontCaret.x += fontSpacing*fontSize/2.;
}

// Function 94
vec1 circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}

// Function 95
vec2 rectToPolar(vec2 v) {
	//result = vec2(length(v), atan(v.y / v.x));
	return vec2(length(v), atan(v.y / v.x) + isNegative(v.x) * PI);
}

// Function 96
vec3 PointInCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)
{
    vec3 d = pos - circlePos;
    vec3 q = d - dot(circleNorm, d) * circleNorm + circlePos;
    
    return (length(q - circlePos) <= circleRadius) ? q : (circlePos + circleRadius * normalize(q - circlePos));
}

// Function 97
vec2 circle_inversion(vec2 p, vec2 c, float r){
    return r*r*comp_inv(conj(p-c)) + c;
}

// Function 98
Lab linear_srgb_to_oklab(RGB c)
{
	float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
	float m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
	float s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;

	float l_ = cbrtf(l);
	float m_ = cbrtf(m);
	float s_ = cbrtf(s);

	return Lab(
		0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
		1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
		0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
	);
}

// Function 99
conic_t line() {
    return newconic(0.0, 0.0, 0.0, 1.0, -1.0, 0.0);
}

// Function 100
float drawLight(vec3 lp, vec3 rd, vec3 ro, float td, float pulse)
{
    float res = 0.0;
    if(td > distance(lp,ro))
    {
		float dlp = length(cross(lp-ro, lp-(ro+rd)))/length((ro+rd)-ro);
		res=max(exp(-dlp*64.0*((1.0-pulse)+0.5)),0.0);
    }
    return res;
}

// Function 101
vec2 iUnitCircle(in vec2 ro, in vec2 rd) {
	float b = 2.0*dot(ro, rd);
	float c = dot(ro, ro) - 1.0;
    return solve_quadratic0(vec3(1.0, b, c));
}

// Function 102
F1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}

// Function 103
float sdCircle(vec2 uv, vec2 origin, float radius)
{
    return length(uv - origin) - radius;
}

// Function 104
vec2 CatmullRomSpline (vec2 A, vec2 B, vec2 C, vec2 D, float t)
{
    vec2 a = -A/2. + (3.*B)/2. - (3.*C)/2. + D/2.;
    vec2 b = A - (5.*B)/2. + 2.*C - D / 2.;
    vec2 c = -A/2. + C/2.;
    vec2 d = B;

    return a*t*t*t + b*t*t + c*t + d;
}

// Function 105
vec3 ContourLines(vec2 p) 
{
	float h = fbm(p*1.5)*10.0;
    float t = fract(h);
    float b = 1.0 - fract(h + 1.0);
    return ColorPalette(h*0.1,
                        vec3(1.0), vec3(0.7), vec3(1.0), vec3(0.0, 0.333, 0.666)) * 
               (pow(t, 16.0) + pow(b, 4.0));
        
}

// Function 106
vec2 DirectOwen(uint index) {
	uvec2 result = uvec2(index,0);
    for(int i=0; i < OwenNumber.length() && index > 0u; ++i, index >>= 1u)
        result.y ^= (index & 1u) * OwenNumber[i];
    result = bitfieldReverse(Owen(result, OwenSeed));
    
    return vec2(result>>8u) / vec2(0x1000000);
}

// Function 107
vec4 meteorShowerLinear(vec2 fragCoord){
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;
    
    float y = spark(uv.x-0.5-iTime + rand(uv.y)*100.0);

    return vec4(y);
}

// Function 108
float drawE(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  bool onCir = isIn(length(uv), cMin, cMax);
  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||
    uv.x <= 0.0 && onCir);
  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&
    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));
  return valA+valB;
}

// Function 109
vec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )
{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
return colOut;
}

// Function 110
vec3 circleNormal(vec2 circlePos, vec2 pixelPos, float radius)
{
    float deltaX = circlePos.x-pixelPos.x;
    float deltaY = circlePos.y-pixelPos.y;
    float dist = sqrt((deltaX*deltaX)+(deltaY*deltaY));
    float dist2 = (((1.0*(radius*2.0))-dist)*(1.0/(radius*2.0)));
    vec2 dir = vec2(deltaX,deltaY);
    
    float normalY = (-deltaY*4.0);
    float normalX = (-deltaX*4.0);
    return vec3(normalX,normalY,dist2); 
}

// Function 111
void NewLine()
{
	s_cursor.x = s_margin;
	s_cursor.y -= s_textScale*14.0;
}

// Function 112
float csg_or_inlined (float a, float b, float r) {
    float d = abs(a - b);
    float q = max(r - d, 0.0);    
    return 0.5*(a + b - (d + q*q/r));
}

// Function 113
void debug_draw() {
    //exidx is bord id, you can debug draw anything to any board for debug
    //set map[index]=0 or 1;
    int exidx = index_idx();
    //debug draw, anim bits
    //frame
    int imid = int(mod(float(iFrame) / 3. + float(exidx), float(msize.x * msize.y)));
    //time
    //int imid=int(mod(iTime*10.+mod(float(exidx),float(msize.x*msize.y)),float(msize.x*msize.y)));
    map[imid] = 1;
    imid = imid - 3 >= 0 ? imid - 3 : msize.x * msize.y + (imid - 3);
    map[imid] = 0;
    // look save_map() function also
}

// Function 114
vec3 NormalBlend_Linear(vec3 n1, vec3 n2)
{
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;
    
	return normalize(n1 + n2);    
}

// Function 115
void waveRect(float x, float y, float w, float h, float p, float u, vec4 clr) {
	vec2 c = fragCoord.xy;
	if (c.x >= x && c.x < x + w) {
		if (c.y > y + sinLerp(c.x - x, p) * u && c.y < y + h + sinLerp(c.x - x, p) * u) {
			fragColor = clr;
		}
	}
}

// Function 116
bool rect_contains_point(vec2 p1, vec2 p2, vec2 p) {
    return p1.x <= p.x && p.x <= p2.x &&
           p1.y <= p.y && p.y <= p2.y;
}

// Function 117
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = dot(p, b) / dot(b, b),                  // proj coord on line
          c = clamp(h, 0., 1.);
    p -= b * h; return h==c ? dot(p,p): 1e5;          // dist² to segment
}

// Function 118
vec4 Circle( vec2 position , float radius , vec4 color){

  float d = distance( position , Coord ); 
    
    if( d < radius ) {
      return color;
    }else{
      return vec4(0,0,0,1);
    }
         
}

// Function 119
float rect(vec2 p, vec2 center, vec2 size) {
	vec2 hs = size / 2.;
    p -= center;
    p = abs(p);
    return max(p.x - hs.x, p.y - hs.y);
}

// Function 120
vec3 drawLine(vec3 col, float width, vec2 pos, vec2 nml, float h) {
    #define lineCol lineColor
    
    float weight = onLine(width, pos, nml, h);	// re here
    
    return mix(col, lineCol, weight);
}

// Function 121
float circle_l2 (vec2 p, vec2 r) {
    return(length(p / r) - 1.000000) * min(r . x, r . y);
}

// Function 122
vec4 draw_font8x8_number_0k( int k, int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    int off = 0 ;
    if( n < 0 ) {
        v += draw_font8x8_char( _DASH, col, pos, o, iu ) ;
        n = 0 - n ; //freaking workaround for mac os bug!!!
        off = 8 ;
    }
    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(off,0), ivec2(k*8,8) ) ) {
        int p = ( ( k*8 - 1 ) - iu2.x ) / 8, c ;
        //for( int i = 0 ; i < p ; ++ i ) n /= 10 ;
        //c = n % 10 ;
        int d = int( floor( pow( 10., float(p) ) ) ) ;
        c = ( n / d ) % 10 ;
        v += draw_font8x8_char( c + 1, col, pos + ivec2( (k-1-p) * 8, 0 ), o, iu ) ;
    }
    return( v ) ;
}

// Function 123
bool UIDrawContext_ScreenPosInCanvasRect( UIDrawContext drawContext, vec2 vScreenPos, Rect canvasRect )
{
	vec2 vCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, vScreenPos );    
    return Inside( vCanvasPos, canvasRect );
}

// Function 124
float drawCircle(vec2 pos, float radius, float edgeFade, vec2 fragCoord) {
    // Get distance from pixel to circle radius
    float dis = distance(fragCoord, pos.xy * iResolution.xy);
    
    // Return 1.0 if inside circle
    return 1.0 - smoothstep(edgeFade * radius, radius, dis);
}

// Function 125
vec2 smoothLine2(float value, float target, float width){
    return vec2(step(0.0, value - target), width / abs(value - target));
}

// Function 126
void drawFunc(float y, float r, vec4 col)
{
    drawFunc(y, dFdx(y) / px, r, col);
}

// Function 127
float implicit_circle(vec2 uv){
	return uv.x*uv.x+uv.y*uv.y-1.;
}

// Function 128
vec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)
{
    vec3 finalColor = GetEnvMap(rayDir, sunDir);

    // Make a skyscraper skyline reflection.
    float radial = atan(rayDir.z, rayDir.x)*4.0;
    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);
    radial *= 4.0;
    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;
    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);
    float vert = sign(sin(radial*32.0))*0.5+0.5;
    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;
    mask = saturate(mask + (1.0-hor*vert)*0.05);
    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);

	return finalColor;
}

// Function 129
vec3 ToLinear( in vec3 col )
{
	// simulate a monitor, converting colour values into light values
	return pow( col, vec3(GAMMA) );
}

// Function 130
float ssdRectangle(vec3 p, vec3 o, vec3 c, vec3 i) {
    vec3 j = normalize(cross(o, i));
    i = cross(j, o);
    vec3 k = cross(i, j);
    p += step(0., dot(cross(p, o), j)) * (reflect(p, i) - p);
    p += step(0., dot(cross(o, p), i)) * (reflect(p, j) - p);
    vec3 ic = normalize(cross(j, c));
    vec3 jc = normalize(cross(c, i));
    vec3 kc = cross(ic, jc);
    vec3 px = normalize(p - ic * dot(p, ic));
    vec3 py = normalize(p - jc * dot(p, jc));
    float dx = acos(dot(p, px)) * sign(dot(cross(p, px), k));
    float dy = acos(dot(p, py)) * sign(dot(cross(py, p), k));
    float zone = min(dot(cross(p, jc), kc), dot(cross(ic, p), kc));
    return zone > 0. ? acos(dot(c, p)) : max(dx, dy);
}

// Function 131
float line(vec2 p, vec2 a, vec2 b) {
  vec2 pa = p-a;
  vec2 ba = b-a;
  float h = dot(pa,ba)/dot(ba,ba);
  return length(pa - ba * h);
}

// Function 132
float addCircle(vec2 uv, float scale)
{
    return 0.0;
}

// Function 133
float linePattern(vec2 p, vec2 a, vec2 b){
  
    // Determine the angle between the vertical 12 o'clock vector and the edge
    // we wish to decorate (put lines on), then rotate "p" by that angle prior
    // to decorating. Simple.
    vec2 v1 = vec2(0, 1);
    vec2 v2 = (b - a); 
 
    // Angle between vectors.
    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.
    float ang = acos(v2.y/length(v2)); // Trimed down.
    p = rot2(ang)*p; // Putting the angle slightly past 90 degrees is optional.

    float ln = doHatch(p);//clamp(cos(p.x*96.*6.2831)*.35 + .95, 0., 1.);

    return ln;// *clamp(sin(p.y*96.*6.2831)*.35 + .95, 0., 1.); // Ridges.
 
}

// Function 134
vec3 drawBg(vec2 p, float px)
{
    vec3 col = vec3(0.3 + 0.04*mod(floor(p.x)+floor(p.y),2.0));
    col *= smoothstep( 0.5*px, 1.5*px, abs(p.x) );
    col *= smoothstep( 0.5*px, 1.5*px, abs(p.y) );
    return col;
}

// Function 135
float drawFloat(inout vec2 p,v0 v,int q){return drawFloat(p,v,q,2);}

// Function 136
float circle(vec2 p, float r) {
	return smoothstep(0.1, 0.0, abs(length(p)-r)); // try changing the 0.1 to 0.3
}

// Function 137
vec3 innercircle(vec2 fragCoord, float fadein)
{
    vec2 p=(fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);
	float dist = distance(p , vec2(0));  
    float shading = pow( min(max(dist*2., 0.),1.) , (1.-texture(iChannel2 , vec2(0.5), 0.0).x)*10.);
    vec2 U = (fragCoord * 2. - iResolution.xy) / iResolution.y;
    float star = dot(U*2.-1.,vec2(sin(iTime),cos(iTime)));
    return hsv2rgb(vec3(star*0.05+iTime*0.2, (1.-shading*20.)*fadein, 1.+sin(star+iTime*0.9))) * shading * 90. ;
}

// Function 138
vec4 draw_ladyfrog( int frame, int dir, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), dim_player ) ) {
        frame &= 0x3 ;
        dir   &= 0x3 ;
             if( dir == 1 )  iu = iu.yx ;                    //right
        else if( dir == 2 )  iu = 15 - iu ;                  //down
        else if( dir == 3 )  iu = ivec2( iu.y, 15 - iu.x ) ; //left
        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = 2 * iu.x ;
        uint bits = 0x3U << sh,
             col_ind = ( get_player_br( row_group, component ) & bits ) >> sh ;
        v = get_col( pal_ladyfrog, col_ind ) ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 139
vec2 lit_line(vec2 uv, vec2 a, vec2 b, float thickness)
{
    const vec2 LIGHT_DIR = vec2(0, 1);
    uv -= closest_point_on_segment(uv, a, b);
    float len = length(uv);
    return vec2(len > 0. ? dot(uv/len, LIGHT_DIR) : 1., len + -.5*thickness);
}

// Function 140
vec4 drawSelectionBox(vec2 c) {
	vec4 o = vec4(0.);
    float d = max(abs(c.x), abs(c.y));
    if (d > 6. && d < 9.) {
        o.a = 1.;
        o.rgb = vec3(0.9);
        if (d < 7.) o.rgb -= 0.3;
        if (d > 8.) o.rgb -= 0.1;
    }
    return o;
}

// Function 141
float distIsoLine(vec3 p, vec3 n, vec3 grad, float iso, float val)
{
	return abs(val-iso)/length(grad);
}

// Function 142
float torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)
{
    //|d| = 1
    
    //a^2 = c^2 - b^2
    //a^2 = c^2 - (b/c * c)^2
    //a^2 = c^2 - (cos() * c)^2
    
    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));
}

// Function 143
float circle(vec2 uv, vec2 aspect, float scale){
    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
}

// Function 144
float DERect(in vec2 z, vec2 r){return max(abs(z.x)-r.x,abs(z.y)-r.y);}

// Function 145
vec3 draw_line(float d, float thickness) {
  const float aa = 3.0;
  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));
}

// Function 146
float NumFont_Circle( vec2 vTexCoord )
{
    float fResult = 0.0;
    
    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 2), vec2(10,12) ));
    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(8,13) ));
    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 4), vec2(11,10) ));
    
    return fResult;
}

// Function 147
void draw_point(uint p, uint level) {
    float l = float(1u << MAX_LEVEL);
	float x = float(p) / (l * l);
    x = x*2.0 - 1.0;
    circle(x, -0.9 + float(level)*0.01, 0.003);
}

// Function 148
float circle(vec2 p, float r)
{
    return smoothstep(1.,.975,length(p/r));
}

// Function 149
float circle(vec2 p, vec2 c, float r) {
    float ret = 1.0 - length(p-c) + r;
    return clamp(smoothstep(1.0-EPSILON_SMOOTH,1.0,ret),0.0,1.0);
}

// Function 150
vec3 LightingIndirect(vec3 n, vec3 albedo, vec3 sky, vec3 ground)
{
    float a = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);
    return albedo * mix(ground, sky, a);
}

// Function 151
float rect(vec2 st, vec4 r){
    //vec2 bl = floor(st+vec2(1.)-r.xy);
    vec2 bl = step(r.xy,st);
    float pct = bl.x * bl.y;

    // top-right
    // vec2 tr = step(r.zw,1.0-st);
    vec2 tr = floor(st-r.zw);
     pct *= tr.x * tr.y;
    
    return pct;
}

// Function 152
float sdf_line(vec2 uv, vec2 a, vec2 b, float thickness)
{
    vec2 ab = b-a;
    vec2 ap = uv-a;
    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);
    return length(uv - (ab*t + a)) - thickness*.5;
}

// Function 153
vec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )
{
    vec2 vEdgeDir = sideDef.vB - sideDef.vA;
    vec2 vOA = sideDef.vA - vRayPos;
    float fDenom = Cross2d( vRayDir, vEdgeDir );
    float fRcpDenom = 1.0 / fDenom;
    
    vec3 vHitTUD;
    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;
    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;
    vHitTUD.z = fDenom;
    
    return vHitTUD;    
}

// Function 154
float sdCircle( vec2 p, float r )
{ return length(p) - r;}

// Function 155
float drawFract(int d, float f){float c=0.; 
 f=fract(f)*10.; 
 for(int i=1;i<60;i++){
  c+=char(48+int(f));tpm; 
  d--;f=fract(f)*10.;
  if(d<=0||f==0.) break;
 }tpp*float(d); 
 return c;}

// Function 156
vec3 linearDodgeMode  (vec3 colorA, vec3 colorB)
{
    vec3 rgb = colorB + colorA;
    return rgb;
}

// Function 157
void DrawWithOutline(inout vec3 col, vec3 paintCol, vec3 outlineCol, float threshold, float value, float thickness)
{
       vec3 maskCol = mix(outlineCol, paintCol, aaStep(thickness, threshold - value));
       col = mix(maskCol, col, aaStep(threshold, value));
}

// Function 158
vec2 line_segment(vec2 point, vec2 segment_start, vec2 segment_end) {
    // Returns a vector pointing to the line segment.
    vec2 line_direction = segment_start - segment_end;
    vec2 point_on_line = segment_end;
    float segment_length = length(line_direction);


    float projected_distance = dot(normalize(line_direction), point - point_on_line);
    vec2 closest_point = point_on_line + projected_distance * line_direction / segment_length;

    float distance_from_end = -projected_distance;
    float distance_from_start = projected_distance - segment_length;

    // Rounded caps on segment
    if (distance_from_start > 0.0) {
        closest_point = segment_start;
    }
    if (distance_from_end > 0.0) {
        closest_point = segment_end;
    }

    return point - closest_point;
}

// Function 159
v3 linearGraph(v1 u,v0 h,v0 g
){d0 d=getd(u.x)
 ;//float div=sqrt(1.+p.y*p.y)
 ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick
 ;d=getd(u.x)
 ;//no analytical 2nd derivative, so this one sucks a bit
 ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick
 ;//this does not work for scaled p, is far from being user friendly
 ;v0 blur=20./max(iResolution.y,1.)
 ;v3 yellow =v3(v2(1,1,0),ssb(r))
 ;v3 cyan   =v3(v2(0,1,1),ssb(g))
 ;v3 magenta=v3(v2(1,0,1),ssb(b))
 ;return aOverB(aOverB(yellow,magenta),cyan);}

// Function 160
float drawing(vec2 uv, float time) {
    time = fract(time*.6);
    uv = rotate((-time*(PI/2.))+(PI/2.),uv);
    uv /= pow(3.,fract(time)); //Zoom in to middle square
    uv *= 5.; //Zoom out
    float a = 0.;
    float s = fract(time); //Seperation time
    for (float i = 0.; i < 9.; i++) { //3x3
        vec2 p = vec2(mod(i,3.),floor(i/3.))-1.;
        p += p*pow(max((s*8.)-(9.-ulam_spiral(-p)),0.),2.); //Move squares
    	a += lthan(chess_dist(uv-p),.5); //Draw square
    }
    return clamps(a);
}

// Function 161
float directionalLightDiffuse(vec3 nor, vec3 ldir) {
    return clamp01(dot(nor, -ldir));
}

// Function 162
float rune_line(vec2 p, vec2 a, vec2 b) {   // from https://www.shadertoy.com/view/4dcfW8
    p -= a, b -= a;
	float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line
	return length(p - b * h);                         // dist to segment
}

// Function 163
float sdCircle(vec2 uv, vec2 origin, float radius)
{
    float d = length(uv - origin) - radius;
    return d;
}

// Function 164
float GetPositionAlongLineSegmentNearestToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)
{
	vec2 p = point			- line_segment_a;
	vec2 l = line_segment_b	- line_segment_a;

	float dprod = dot(p,l);
	float len2  = dot(l,l);

	return clamp(dprod / len2, 0.0, 1.0);
}

// Function 165
float GetColourForCubicSpline(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3, vec2 uv, float pixel_uv_size)
{
	float	t				= GetNearestPointAlongCubicSpline(cp0.xy,cp1.xy,cp2.xy,cp3.xy, uv);
    vec3	best_point		= GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t);
    float	best_dist 		= length(uv - best_point.xy);
    float	best_surface	= best_point.z - best_dist;
    
    float aa = smoothstep(0.0, pixel_uv_size, best_surface);
    
    return aa;
}

// Function 166
float SCALE_size_non_linear(float val){
    //return val; //linear
    return min(smoothstep(0.,5.,val)+smoothstep(0.5,1.6,val)+smoothstep(0.7,1.3,val),1.);
}

// Function 167
float OUTcircle(vec2 p, float r, float th)
{
   float ss = 0.009;
   float c = length(p);
    //I flipped the - and + in both ss and th parts to avoid having to 
    //do a 1.0-... later on.
   return smoothstep(r+ss, r-ss, c) - smoothstep(th+ss, th-ss, c);  
}

// Function 168
void drawSDF(inout vec3 col, vec3 pcol, float d, float r){

    float psize = 1.0/iResolution.y;

    d = ((d-r/zoom*psize*1024.0)*zoom);

    col = mix(pcol,col,smoothstep(-psize,psize,d));
}

// Function 169
vec4 drawOperation(in vec2 uv, in float _operation)
{
    float lsize = 0.015;
    vec2 start = vec2(0.016, 0.09);
    vec4 tcol;
    
    tcol += drawTextHorizontal(uv, start + vec2(0., 0.024), lsize, vec2[10](_C, _o, _l, _o, _r, _X, _X, _X, _X, _X), 5);
    tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_O, _p, _e, _r, _a, _t, _i, _o, _n, _COLON), 10);
    int operEnum = getIValue(_operation, BLEND_OPER_NUM);
    
    start += 6.*vec2(lsize, 0.);
    
    switch (operEnum)
    {
        case BLEND_OPER_FIRST:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_A, _PLUS, _B, _EQ, _A, _p, _t, _y, _X, _X), 5);
        	break;
        case BLEND_OPER_SECOND:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_A, _PLUS, _B, _EQ, _B, _p, _t, _y, _X, _X), 5);
        	break;
        case BLEND_OPER_MIX:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _I, _X, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);
        	break;
        case BLEND_OPER_MAX:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _A, _X, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);
        	break;
        case BLEND_OPER_MIN:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _I, _N, _CS, _A, _COMMA, _B, _CE, _X, _X), 8);
        	break;
        case BLEND_OPER_BIN:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_B, _EQ, _N, _O, _T, _CS, _A, _CE, _X, _X), 8);
        	break;
        case BLEND_OPER_SMOOTH:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_S, _m, _o, _o, _t, _h, _B, _CE, _X, _X), 6);
        	break;
        case BLEND_OPER_COL_PICK:
        	tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_C, _o, _l, _o, _r, _, _p, _i, _c, _k), 10);
        	break;
    }
    return tcol;
}

// Function 170
float line(vec2 a, vec2 b, vec2 c)
{
    vec2 abn = normalize(b-a);
    float t = dot(abn, c-a);
    vec2 d = t * abn;
    float l = length((c-a)-d);
    
    float n = 0.0;
    if (t > 0.0 && t < length(b - a))
    	n = -log(l);
    return n;
}

// Function 171
vec4 gamma_to_linear(vec4 c)
{
    return vec4(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b), c.a);
}

// Function 172
float distToLineRound(vec2 p1, vec2 p2, vec2 p, float thickness)
{
	float d = length(p-p2);
	p -= p1;
	vec2 lineVector = p2-p1;
		
	float angle = -atan(lineVector.y,lineVector.x);
	p = rotate(p,angle);

	if(p.x<0.0)
		d = length(p);
	else if(p.x<length(lineVector))
		d = abs(p.y);
		
	return thickness/d;
}

// Function 173
float line(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
    return length(pa - ba * h);
}

// Function 174
bool drawCircle(vec2 circlePos, vec2 pixelPos, float radius)
{
    float deltaX = circlePos.x-pixelPos.x;
    float deltaY = circlePos.y-pixelPos.y;
    return(sqrt((deltaX*deltaX)+(deltaY*deltaY))<radius);
}

// Function 175
vec4 draw_map(vec4 col, vec2 p)
{
    float h = map(p);
    
    col = blend(col, vec4(vec3(.7), smoothstep(0.01, 0., h)));
    col = blend(col, vec4(vec3(.0), smoothstep(0.01, 0., abs(h))));
    
	return col;
}

// Function 176
vec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )
{
    // score
    vec2 p = fragCoord/iResolution.y;
    // lives
    float eps = 1.0 / iResolution.y;
    for( int i=0; i<3; i++ )
    {
        float h = float(i);
        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );
        if( h + 0.5 < lives )
        {
            float c = max(0.0,sdCircle(q, 0.023));

            col += 0.17*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);
        }
    }

    return col;
}

// Function 177
void line_to(vec2 p) {
    vec4 pa = _stack.position - _stack.last_pt.xyxy;
    vec2 ba = p - _stack.last_pt;
    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);
    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);
    vec2 d = length2(pa - ba.xyxy*h.xxyy);
    add_field(d);
    add_clip(d * s);
    _stack.last_pt = p;
}

// Function 178
vec3 draw_distance(float d, vec2 p) {
    float t = clamp(d * 0.85, 0.0, 1.0);
    vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);
    float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);
    float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);
    float d2 = abs(1.0 - draw_line(d).x);
    vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));
    grad -= rim * clamp(1.25 - d, 0.0, 1.0);
    grad -= 1.0 - clamp(1.25 - d * 0.25, 0.0, 1.0);
    grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));
    return grad;
}

// Function 179
v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}

// Function 180
vec3 directLight(vec3 p, vec3 n)
{
    // Sampled light color
    vec3 lightSample = vec3(0.0);
    
    // Diffuse light path
    vec3 vDiff = normalize(R3D(p + iTime) * 2.0 - 1.0);

    // Loop through each object
    for (int i = 0; i < OBJ_COUNT; i++)
    {
        // If it's emissive, try cast a ray toward it
        if (surface(i, p).emission != vec3(0.0))
        {
            // Temporary p and n
            vec3 p_, n_ = vec3(0.0);

            // Setup a ray towards the object
            vec3 ld = objects[i].pos - p;

            // Direction to cast ray in
            vec3 dir = normalize(vDiff + ld);

            // Cast a ray. If we hit the object, add onto the light sample
            if (castRay(p, dir, n_, p_) == i)
                lightSample += surface(i, p_).emission * diffuseBRDF(dir, n);
        }
    }
    
    // Return it
    return lightSample;
}

// Function 181
define DRAW_OBB(_x,_y,_w,_h,_r,_color) {vec2 rel = vec2(pos.x-(_x), pos.y-(_y)); rel = vec2(cos(_r)*rel.x-sin(_r)*rel.y,sin(_r)*rel.x+cos(_r)*rel.y); if ((abs(rel.x) < _w/2.0)&&(abs(rel.y-_y) < _h/2.0)) return _color;}

// Function 182
void DrawScore (vec2 fragCoord, float score, inout vec3 pixelColor)
{
    // keep score between 0000 and 9999
    score = clamp(score, 0.0, 9999.0);
    
    // digits numbered from right to left
    int digit0 = int(mod(score, 10.0));
    int digit1 = int(mod(score / 10.0, 10.0));
    int digit2 = int(mod(score / 100.0, 10.0));
    int digit3 = int(mod(score / 1000.0, 10.0));
    
    // digit index is from left to right though
    DrawDigit(fragCoord, digit0, 3, pixelColor);
    DrawDigit(fragCoord, digit1, 2, pixelColor);
    DrawDigit(fragCoord, digit2, 1, pixelColor);
    DrawDigit(fragCoord, digit3, 0, pixelColor);
}

// Function 183
float drawline (vec2 uv)
{
	return smoothstep(-0.01,0.0,uv.y)-smoothstep(0.0,0.01,uv.y);
}

// Function 184
float pointRectDist(vec2 p, vec2 rectTL, vec2 rectBR)
{
  float dx = max(max(rectTL.x - p.x, 0.), p.x - rectBR.x);
  float dy = max(max(rectTL.y - p.y, 0.), p.y - rectBR.y);
  return max(dx, dy);
}

// Function 185
vec3 LightingDirect(vec3 l, vec3 v, vec3 p, vec3 n, vec3 albedo, float specular, float shininess)
{  
    vec3 h = normalize(l + v);
    float LdotN = max(0.0, dot(l, n));
	float HdotN	= max(0.0, dot(h, n));
    float shadow = LightingShadow(p + n * kBias, l, 0.02, 8.0);
    return shadow * LdotN * (albedo + vec3(specular) * pow(HdotN, shininess));
}

// Function 186
type project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) / dot(d, d ); }

// Function 187
float vline_d(vec2 uv, float lineposx, float lineWidth)
{
	return distance(uv.x, lineposx) - (lineWidth / 2.0);
}

// Function 188
vec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );
}

// Function 189
float Circle(vec2 p, float r)
{
	return length(p) - r;
}

// Function 190
void drawLight1(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 l1Norm;
    float light1T = traceSphere(ray.pos - LIGHT1_POS, ray.dir, 
                                        LIGHT1_RADIUS, l1Norm);
    
    if(light1T < cur_ctxt.t)
    {
        cur_ctxt.t=light1T;

        cur_ctxt.materialType = EMISSION;
        cur_ctxt.color=LIGHT1_COLOR;
        cur_ctxt.n = l1Norm;
        cur_ctxt.alpha = 0.0;
    }

}

// Function 191
float rectSDF( vec2 st, vec2 s){
    st = st*2.-1.;
    return max(abs(st.x/s.x), abs(st.y/s.y));
}

// Function 192
float drawLine( vec2 p1, vec2 p2, vec2 uv, float thickness ) 
{
	float a = abs( distance( p1, uv ) ),
	      b = abs( distance( p2, uv ) ),
	      c = abs( distance( p1, p2 ) );
	
	if ( a >= c || b >=  c ) return 0.0;
	
	float p = (a + b + c) * 0.5;
	
	// median to ( p1, p2 ) vector
	float h = 2.0 / c * sqrt( p * ( p - a ) * ( p - b ) * ( p - c ) );
	
	return mix( 1.0, 0.0, smoothstep( 0.5 * thickness, 1.5 * thickness, h ) );
}

// Function 193
vec3 rect(vec2 coordSpace, vec2 dim, vec2 offset)
{      
    vec3 color = vec3(0.0);
    
    float l = offset.x;
    float r = offset.x + dim.x;
    float b = offset.y;
    float t = offset.y + dim.y;
    
    vec2 tmp = step( vec2(l, 0.0), coordSpace );
    float pct = tmp.x * tmp.y;
    color += vec3(pct);
    
    tmp = step( vec2(r, 0.0), coordSpace);
    pct = tmp.x * tmp.y;
    color -= vec3(pct);
    
    tmp = step( vec2(0.0, b), coordSpace);
    pct = tmp.x * tmp.y;
    color -= 1.0 - vec3(pct);
    
    tmp = step( vec2(0.0, t), coordSpace);
    pct = tmp.x * tmp.y;
    color -= vec3(pct);

    return color;
}

// Function 194
float circleSliceArea(float frac)
{
	float half_pi=3.14159265358979/2.0;
	return (
		half_pi-
		frac*sqrt((1.0-frac)*(1.0+frac))-
		asin(frac)
		);
}

// Function 195
ivec2 getDirection(inout int dirIndex, int turn)
{
    dirIndex = modint((dirIndex + turn), 4);
    return DIRS[dirIndex];
}

// Function 196
void TestLineMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in float width, in SMaterial material)
{   
    vec3 normal;
    float dist = LineDistance(A, B, width, rayPos, normal);
    if (dist < info.dist)
    {
        info.rayMarchedObject = true;
        info.dist = dist;        
        info.normal = normal;
        info.material = material;
    }    
}

// Function 197
float circle(vec2 uv,float r)
{
    return length(uv) - r;
}

// Function 198
vec4 texture_Bspline( sampler2D tex, vec2 t )
{
    vec2 res = iChannelResolution[0].xy;
    vec2 p = res*t - 0.5;
    
    //half pixel offset for quadratic to make it line up with others
    if(ScreenH == 1.f){
     	p -= .5;   
    }
    vec2 f = fract(p);
    vec2 i = floor(p);

    return spline( f.y, spline( f.x, SAM(-1,-1), SAM( 0,-1), SAM( 1,-1), SAM( 2,-1)),
                        spline( f.x, SAM(-1, 0), SAM( 0, 0), SAM( 1, 0), SAM( 2, 0)),
                        spline( f.x, SAM(-1, 1), SAM( 0, 1), SAM( 1, 1), SAM( 2, 1)),
                        spline( f.x, SAM(-1, 2), SAM( 0, 2), SAM( 1, 2), SAM( 2, 2)));
}

// Function 199
float sdCircle(vec2 p, float r) {
    return length(p) - r;
}

// Function 200
float sdLineSegmentRounded(vec2 uv, vec2 a, vec2 b, float lineWidth)
{
    vec2 pa = uv-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - lineWidth*0.5;
}

// Function 201
vec3 DrawTriangle(Triangle tr, vec3 color) {
    float N1 = (tr.b.y-tr.a.y)*(uv.x-tr.a.x) - (tr.b.x-tr.a.x)*(uv.y-tr.a.y); 
	float N2 = (tr.c.y-tr.b.y)*(uv.x-tr.b.x) - (tr.c.x-tr.b.x)*(uv.y-tr.b.y); 
	float N3 = (tr.a.y-tr.c.y)*(uv.x-tr.c.x) - (tr.a.x-tr.c.x)*(uv.y-tr.c.y);
    float result = abs(sign(N1) + sign(N2) + sign(N3));
    
    if (result == 3.) result = 1.;			// Inside. All N's have same sign;
    //else if (result < 3.) result = 0.; 	// On edge. One or more N's == 0. *Meanless in my case*;
    else result = 0.;						// Outside. Any other case;
    return (result*color);
}

// Function 202
float circle(vec2 pos, float radius)
{
    return smoothstep(30./iResolution.y, -30./iResolution.y, length(pos)- radius);
}

// Function 203
float aaline(float x)
{
	return smoothstep(0.0, 0.1, x) * smoothstep(0.5, 0.6, 1.0-x);
}

// Function 204
vec3 drawParticles(vec2 uv, float timedelta)
{   
    // Here the time is "stetched" with the time factor, so that you can make a slow motion effect for example
    time2 = time_factor*(iTime + timedelta);
    vec3 pcol = vec3(0.);
    // Main particles loop
    for (int i=1; i<nb_particles; i++)
    {
        pst = getParticleStartTime(i); // Particle start time
        plt = mix(part_life_time_min, part_life_time_max, random(float(i*2-35))); // Particle life time
        time4 = mod(time2 - pst, plt);
        time3 = time4 + pst;
       // if (time2>pst) // Doesn't draw the paricle at the start
        //{    
           runnr = floor((time2 - pst)/plt);  // Number of the "life" of a particle
           vec2 ppos = getParticlePosition(i);
           float dist = distance(uv, ppos);
           //if (dist<0.05) // When the current point is further than a certain distance, its impact is neglectable
           //{
              // Draws the eight-branched star
              // Horizontal and vertical branches
              vec2 uvppos = uv - ppos;
              float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);
              float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);
              // Diagonal branches
              vec2 uvpposd = 0.707*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));
              float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);
              float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);
              // Initial intensity (random)
              float pint0 = mix(part_int_factor_min, part_int_factor_max, random(runnr*4. + float(i-55)));
              // Middle point intensity star inensity
              float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);
              // One neglects the intentity smaller than a certain threshold
              //if (pint0*pint1>16.)
              //{
                 // Intensity curve and fading over time
                 float pint = pint0*(pow(pint1, ppow)/part_int_div)*(-time4/plt + 1.);
                
                 // Initial growing of the paricle's intensity
                 pint*= smoothstep(0., grow_time_factor*plt, time4);
                 // "Sparkling" of the particles
                 float sparkfreq = clamp(part_spark_time_freq_fact*time4, 0., 1.)*part_spark_min_freq + random(float(i*5 + 72) - runnr*1.8)*(part_spark_max_freq - part_spark_min_freq);
                 pint*= mix(part_spark_min_int, part_spark_max_int, random(float(i*7 - 621) - runnr*12.))*sin(sparkfreq*twopi*time2)/2. + 1.;

                 // Adds the current intensity to the global intensity
                 pcol+= getParticleColor(i, pint);
              //}
           //}
        //}
    }
    
    // Main particle
    vec2 ppos = getParticlePosition_mp();
    float dist = distance(uv, ppos);

        // Draws the eight-branched star
        // Horizontal and vertical branches
        vec2 uvppos = uv - ppos;
        float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);
        float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);
        // Diagonal branches
        vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));
        float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);
        float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);
        // Middle point intensity star inensity
        float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);
        
        if (part_int_factor_max*pint1>6.)
        {
            float pint = part_int_factor_max*(pow(pint1, ppow)/part_int_div)*mp_int;
            pcol+= getParticleColor_mp(pint);
        }

    return pcol;
}

// Function 205
float calc_circle(float n, vec2 xy, vec2 offset)
{
	vec2 ixy = floor(xy) - offset;
	vec2 centre = ixy + 0.5;
	
	float r = MIN_SIZE + MAX_SIZE*rand(ixy+100.0);
	centre += 0.25 + 0.5*rand(ixy);
	
	float angle = rand(ixy+50.0)+iTime*(rand(ixy+150.0)-0.5);
	centre.x += 0.25*sin(angle);
	centre.y += 0.25*cos(angle);
	
	vec2 d = xy - centre;
	float hsq = d.x*d.x + d.y*d.y;
	
	return n + 1.0 - smoothstep(r, r + 0.001, hsq);
}

// Function 206
void DrawDryGrass(out vec4 c){
	c = vec4(0.6, 0.6, 0.0, 1.0);
}

// Function 207
float EvilLine(vec2 pos, vec2 start, vec2 finish)
{
    vec2 delta = finish - start;
    vec2 n = normalize(delta);
    float l = length(delta);
    float d = sign(n.x);
    
    float angle = atan(n.y / n.x);
    vec2 t = rot(-pos - start, angle);
    
    float s = d < 0.0 ? 0.0: d*l;
    float f = d < 0.0 ? d*l : 0.0;
    if(t.x > s || t.x < f)return 0.0;

    return clamp(((1.0 - abs(t.y))-0.99)*100.0, 0.0, 1.0);
}

// Function 208
vec3 drawBands(vec2 uv)
{
  	uv = 2.0*uv-1.0;
    uv.x*=iResolution.x/iResolution.y;
    uv = vec2(length(uv), atan(uv.y,uv.x));
    
    uv.x-=0.01;
    uv.x = max(0.0,uv.x);
    
    uv.y -= PI*0.5;
    vec2 uv2 = vec2(uv.x, uv.y*-1.0);
    uv.y = mod(uv.y,PI*2.0);
    uv2.y = mod(uv2.y,PI*2.0);
    
    vec3 col = vec3(0.0);
    vec3 col2 = vec3(0.0);
    
    float nBands = float(NUM_BANDS);
    float i = floor(uv.x*nBands);
    float f = fract(uv.x*nBands);
    float band = i/nBands;
   	float s;
   	
    #ifdef REVERSED
    band = 5.0-band;
    #endif 
    
    //cubic easing
    band *= band*band; 
    
    band = band*0.099;
    band += 0.001;
    
    s = texture( iChannel0, vec2(band,.3) ).x;  
    
    if(band<0.0||band>=1.0){
        s = 0.0;
    }
    
    /* Gradient colors and amount here */
    const int nColors = 5;
    vec3 colors[nColors];  
    colors[0] = vec3(0.251,0.000,0.502);
    colors[1] = vec3(1.000,1.000,1.000);
    colors[2] = vec3(1.000,1.000,1.000);
    colors[3] = vec3(0.000,0.000,0.000);
 
    vec3 gradCol = colors[0];
    float n = float(nColors)-1.25;
    for(int i = 2; i < nColors; i++)
    {
		gradCol = mixc(gradCol,colors[i],(s-float(i-1)/n)*n);
    }
    
    float h = PI*1.5;
    
    col += vec3(1.0-smoothstep(-2.0,1.5,uv.y-s*h));
    col *= gradCol;

    col2 += vec3(1.0-smoothstep(-2.0,1.5,uv2.y-s*h));
    col2*= gradCol;
    
    col = mix(col,col2,step(0.0,uv.y-PI));

    col *= smoothstep(0.00001,.00009,f);
    col *= smoothstep(0.000000001,0.000000009,f); 
    
    col = clamp(col,0.0,1.0);
    
    return col;
}

// Function 209
void DrawTrailBallSprite(vec2 screenCoord, vec2 pos, vec4 tint, inout vec4 pixel)
{
  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+20.0 && screenCoord.y >=pos.y && screenCoord.y <=pos.y+20.0)
  {
    vec2 dist = (screenCoord-pos)/iResolution.xy;
    vec2 loc = ballTexture_Adress/iResolution.xy;    
    vec4 c =texture(iChannel3, loc+dist);

    pixel=mix(pixel, c*tint, c.w*tint.w);
  }
}

// Function 210
void drawPendulum(in vec2 fragCoord, inout vec4 outColor) {
  float totalMass = 0.0;
  for (int i = 0; i < rods; i++) {
    totalMass += masses[i];
  }

  float scale = iResolution.y / 20.0;
  vec2 anchor = iResolution.xy / 2.0 + center * scale;

  vec2 previous = anchor;
  for (int i = 0; i <= rods; i++) {
    vec2 position;
    if (i < rods) {
      position = anchor + ballData(STORAGE, i).xy * scale;
      drawSpring(
          fragCoord, previous, position,
          vec2(0.8 * scale, clamp(0.05 * stiffnesses[i], 0.05, 0.12) * scale), 9,
          vec4(vec3(0.0), 1.0), outColor);
    }

    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);
    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];

    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),
             outColor);
    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);

    previous = position;
  }
}

// Function 211
vec3 cpLine(vec3 q0, vec3 q1, vec3 p) {
    vec3 vEdge = q1 - q0;
    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);
    return q0 + t*vEdge;
}

// Function 212
float sdCircle( vec2 p, float r, float r2 )
{
    return abs(length(p) - r) -r2;
}

// Function 213
float scircle(vec2 p, vec2 o, float r) {
    return length(p-o)-r;
}

// Function 214
void drawLine(in vec3 l, in vec3 p) {
    inkDist = min(inkDist, (abs(geodesicDist(l, p.xy))-lineWidth)/p.z);
}

// Function 215
vec4 drawSplitCircle(vec2 loc, vec2 center , float radius, vec4 currentCol, vec4 desiredColOne, vec4 desiredColTwo)
{
//efficient drawing of circle instead of using float dist = length(loc - center);
// if(dist <= radius)  
    vec2 diff = loc - center;

    if (dot(diff,diff) <= radius * radius)
       {
       //if left side of the screen
           if(splitScreen(loc.x, center.x, 1.0))
                {
                    //if bottom left of the screen
                    if(splitScreen(loc.y, center.y, 1.0))
                        return desiredColOne;
                    //if top left
                    else
                        return desiredColOne * (vec4(1.0,0.0,1.0,1.0) * vec4(loc.y, 0.0, loc.x,1.0));
                }
                //if right side
           if(!splitScreen(loc.x, center.x, 1.0))
               {
                   //if top right
                   if(!splitScreen(loc.y, center.y, 1.0))
                   {
                       return desiredColTwo;
                   }
                   else
                   //if bottom right
                   return desiredColTwo * vec4(0.0,1.0,0.0,1.0);
               }
        }
    return currentCol * vec4(0.92,0.92,0.92,1.0);
}

// Function 216
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 rv2 = hash2(seed);
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = normalize( cross( uu, n ) );
	
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831*rv2.x); 
	float ry = ra*sin(6.2831*rv2.x);
	float rz = sqrt( 1.0-rv2.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 217
float drawMinus( vec2 center, vec2 pixel_coords )
{
	return drawDig( center, pixel_coords, 448. );
}

// Function 218
float lineintegralB(vec3 a, vec3 b) 
{
    const float s = .8;
    a *= s; b *= s;
    return rebend(B(a, b) / s)
    //    / 8.
        ;
}

// Function 219
vec3 drawA(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)
{
    // A: top.
    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);
    
    // A: left side.
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.2), sz);
    
    // A: right side.
    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .0), sz);
    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);
    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.2), sz);
    
    // A: center.
    res += square(color, uv, vec2(pos.x +  0., pos.y +  0.), sz);
    
    return res;
}

// Function 220
float circle(vec2 uv, vec2 aspect, float scale){
	return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
}

// Function 221
float spline(float x, float c0, float c1, float c2, float c3 ) {
    return c0*dot( BS_B, powers(x + 1.)) + c1*dot( BS_A, powers(x      )) +
           c2*dot( BS_A, powers(1. - x)) + c3*dot( BS_B, powers(2. - x));
}

// Function 222
void drawPlaying(inout vec4 c, vec2 p)
{
	p *= 2.;
    float t = -fract(iTime)*PI2;
    float s = .06;
    for (float i = 1.; i < 4.; i++) {  
        c = mix(c, vec4(0.5), 1.-smoothstep(-0.,0.003, abs(s/2.-smoothstep(0.,1.,length(p)))));
        t+=i;
        s = s/(2.);  
        p += s*vec2(cos(t),sin(t));
    }
}

// Function 223
float PointLineDistance(vec2 p, vec2 p0, vec2 p1)
{
    return sqrt(PointLineDistance2(p, p0, p1));
}

// Function 224
float line(vec2 p, vec2 a, vec2 b, float size)
{
  vec2 pa = -p - a;
  vec2 ba = b - a;
  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );
  float d = length( pa - ba*h );

  return clamp((((1.0+size) - d)-0.99)*100.0, 0.0, 1.0);
}

// Function 225
vec3 Linear_from_ACEScc(vec3 cc) 
{
    return vec3(Linear_from_ACEScc(cc.r),
                Linear_from_ACEScc(cc.g),
                Linear_from_ACEScc(cc.b));
}

// Function 226
float smoothcircle(vec2 uv, vec2 center, vec2 aspect, float radius, float sharpness){
	return 0.5 - sigmoid( ( length( (uv - center) * aspect) - radius) * sharpness) * 0.5;
}

// Function 227
int drawFixed( in float val, in int places, in vec2 pos, in vec2 size, in vec2 uv )
{
    float fval, ival;
    fval = modf(val, ival);
    
    vec2 p = vec2(pos);
    
    // Draw the floating point part.
    int res = drawIntCarriage( int( fval*pow(10.0,float(places)) ), p, size, uv, places );
    // The decimal is tiny, so we back things up a bit before drawing it.
    p.x += size.x*.4;
    res |= drawChar(CH_FSTP,p,size,uv); p.x-=size.x*1.2;
    // And after as well.
    p.x += size.x *.1;
    // Draw the integer part.
    res |= drawIntCarriage(int(ival),p,size,uv,1);
	return res;
}

// Function 228
vec4 PackRect(inout vec2 p, vec2 dims, float atlasWidth, inout float heightMax, float padding, float inset)
{
    if (p.x + dims.x + padding > atlasWidth) {
        p.y += heightMax + padding;
        p.x = padding;
        heightMax = 0.0;
    } else
		heightMax = max(dims.y, heightMax);
    vec4 rect = vec4(p, p + dims) + vec4(1,1,-1,-1)*inset;
    p.x += dims.x + padding;
    return rect;
}

// Function 229
float pirateLinesB(vec2 u,float t,vec4 m//paints sheet lines
){float c=0.,sy=(m.y-.02)*2.
 ;t=t*6.94+35.*(u.x-.5)
 ;c+=banj4(t,vec2(0,u.y),vec4( 0, 1, 2, 3)*sy,D02 ,F02,G02 ,A02)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4( 4, 5, 6, 7)*sy,as02,C12,D12 ,F12)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4( 8, 9,10,11)*sy,G12 ,A12,As12,A31)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4(12,13,14,15)*sy,As31,C41,Cs41,C22)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4(20,20,21,21)*sy,D22 ,D22,F22 ,F22)*.5//vec4 is position.y
 ;//last one doubled and then halved, cause i am too lazy to define a fun that takes only 2...
  //oh shit the key-labels are off by one, shit a semitone, but off by one label.
 ;return c;}

// Function 230
vec3 Draw(vec2 p, float rnd)
{
	State state;
	vec2 R = iResolution.xy;
	ivec2 i = ivec2(p);
	LoadState(state, BufA, ivec2(R));
    SetupTime(iTime);
	vec2 q = (p + p - R) / R.y;
	mat3 view = Camera(state.eyeaim);
	float hfovy = tau/12. //radians(30.) //
	//, blur = 2. // pixels ??!
	, foclen = 1.
	, focus = .99998 //cos(hfovy * blur/iResolution.y) //
	;
	int ss = SSAA + IZERO;
    ss = max(1, int(float(ss) * min(1., 720. / R.y) + .5));
	ss = max(ss, 1);
	//if (iTimeDelta >= .034) ss = 1;
	return RenderSS(state.eyepos, state.eyevel, q, view
	  , hfovy, ss, focus, foclen, rnd);
}

// Function 231
vec3 cosineDirection( in vec2 st, in vec3 nor)
{
    float u = hash( 78.233 + st.yx);
    float v = hash( 10.873 + st.xy);
    
    // method by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf
	float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0
    float ka = 1.0 / (1.0 + abs(nor.z));
    float kb = -ks * nor.x * nor.y * ka;
    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);
    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);
    
    float a = 6.2831853 * v;
    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;
}

// Function 232
vec3 uv_to_direction(void)
{
    return(vec3(0.0));
}

// Function 233
vec3 redline2(vec2 u,vec3 r,vec4 m,vec3 c,float yo
){return c=strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),0.52),
                           vec4(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}

// Function 234
vec3 drawBubbles(vec2 uv)
{
    int bCnt = 27;
    float fCnt = float(bCnt);
    float speed = .2;
    vec3 col = vec3(153., 255., 153.)/255.;
    vec3 acc;

    
    for (int i = 0; i < bCnt; ++i)
    {
        float fi = float(i);
        float yPos =mod(speed*iTime+fi*.1015, 2.)-0.5;
        vec2 pos = vec2(mod(fi/fCnt, 0.12)*4.-0.3+yPos*0.2*sin(iTime*3.14), yPos);
        
        float d = distance(uv, pos);
        if (isIn(d, 0.008, 0.01))
            acc -= vec3(2.)*sat(uv.y+0.2);
    }
    return acc;
}

// Function 235
float Line2D(vec2 uv, ivec2 pos, ivec2 dir)  
{  
	float c = 0.0;
	ivec2 s, a, b;
	
	if (dir.x > 0)
		{s.x =  1; a.x =  dir.x;}
	else
		{s.x = -1; a.x = -dir.x;}
	if (dir.y > 0)
		{s.y =  1; a.y =  dir.y;}
	else
		{s.y = -1; a.y = -dir.y;}
			
	b = a + a;
	int e   = a.y - a.x;
    int len = a.x + a.y;
	// This is the traversal...
    for (int i = 0; i < 30; i++)
	{
		if (i > len) break;
		
		c += PlotPos(uv, pos);
		if (e < 0)
		{  
			pos.x += s.x;  
			e += b.y;
		}  
		else
		{  
			pos.y += s.y;  
			e -= b.x;
		}  
    } 
	return c;
}

// Function 236
vec3 LinearSample0(vec2 uv, out float coeff, out vec2 Moments, vec3 CN) {
    vec4 Attr=texture(iChannel2,uv+0.5);
    if (Attr.w>99990. || BoxC2(uv-0.25,vec2(0.25))>0.) {coeff=0.; Moments=vec2(0.); return vec3(0.); }
    coeff=max(0.0001,pow(dot(CN,Read(Attr.y).xyz*2.-1.),Coeff_N));
    vec4 ALS=texture(iChannel1,uv);
    Moments=Read(ALS.w).yz*coeff;
    return ALS.xyz*coeff;
}

// Function 237
float line(vec2 p, vec2 a, vec2 b)
{
  vec2 pa = p - a;
  vec2 ba = b - a;
  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
  return length(pa - ba * h);
}

// Function 238
bool isFaceRasterLine(in vec2 uv) {
    return mod(uv.y, 0.02) > 0.0075;
}

// Function 239
float circle2(vec2 pos, float radius, float halo)
{
  return clamp(((1.0-(length(uv-pos)-radius))-0.99)*100.0, 0.0, 1.0);   
}

// Function 240
vec3 brushCircle(vec2 u,vec3 r,vec4 m,vec3 c
){return enso(u*vec2(1),r,m,c, vec4(0,0,0,.9)
                            ,vec2(0,0),// origin
                                .6,// radius
                                .2,// angle of brush start
                                .5,// sweep amt 0-1
                                .3)// width
;}

// Function 241
float drawLCD(in vec2 fc, in float num) {
	
	float v=1.;
	for(float i=1. ; i<11. ; i++) {
	    int dig = int(mod(num/pow(10.,i),1.)*10.);
	    vec2 uv=fc*.1+vec2(i*1.5,0.);
		
	    bool u=(uv.y>=min(0.,abs(uv.x)-0.5));
	    uv.y=abs(uv.y)-0.5;
	    bool c=false;
	    if(abs(uv.x)<abs(uv.y)){ uv=uv.yx; c=!c; }
	    bool l=(uv.x<0.);
	    uv.y=abs(uv.y)-0.4;
	    uv.x=abs(abs(uv.x)-0.5);
	
            dig-=(dig/10)*10;
	
	    float val;
	    if(((dig==0) && (c&&l)) ||
	       ((dig==1) && (c||l)) ||
	       ((dig==2) && ((u&&l||!(u||l))&&!c)) ||
	       ((dig==3) && (l&&!c)) ||
	       ((dig==4) && (c&&!l||l&&!u)) ||
	       ((dig==5) && (!c &&(!l&&u || l&&!u))) ||
	       ((dig==6) && (u&&!c&&!l)) ||
	       ((dig==7) && (l||c&&!u)) ||
	       ((dig==9) && (!u&&l))) val= 1.;
	    else val= uv.x+max(0.,uv.y);
		
	    v=min(v,val);
	}
	
	return smoothstep(0.06,0.05,v);
}

// Function 242
void sampleDirectLight( vec3 pos,
                       	vec3 normal,
                        float Xi1,
                        float Xi2, 
                       	out vec3 dir,
                       	out float pdf ) {
    float height = objects[0].params_[2] - objects[0].params_[1];
    float r = objects[0].params_[0];
    float pdfA;
    float d2;
    float aCosThere;
    float theta;
    float thetaPdf;
    float h;
    float hPdf;
    
    //convert position to object space
    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );
    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );
    
    vec3 v1 = vec3(objects[0].params_[0], objects[0].params_[1], 0.0);
    vec3 v2 = vec3(objects[0].params_[2], objects[0].params_[3], 0.0);
    vec3 v3 = vec3(objects[0].params_[4], objects[0].params_[5], 0.0);
    vec3 n = vec3(0.0, 0.0, 1.0);
    
    if(samplingTechnique == SAMPLE_TOTAL_AREA){
        vec3 p = uniformPointWitinTriangle( v1, v2, v3, Xi1, Xi2 );
        float triangleArea = length(cross(v1-v2,v3-v2)) * 0.5;
        pdfA = 1.0/triangleArea;
        
        dir = p - pos;
        d2 = dot(dir,dir);
        dir /= sqrt(d2);
        aCosThere = max(0.0,dot(-dir,n));
        pdf = PdfAtoW( pdfA, d2, aCosThere );
    } else {
        vec3 A = normalize(v1 - pos);
        vec3 B = normalize(v2 - pos);
        vec3 C = normalize(v3 - pos);
        sampleSphericalTriangle(A, B, C, Xi1, Xi2, dir, pdf);
        if(dot(-dir,n) < 0.0){
            pdf = 0.0;
        }
    }
    
    //convert dir to world space
    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );
}

// Function 243
vec3 drawMainTitle(vec3 col, vec2 fragCoord)
{    
    vec2 uv = fragCoord.xy /iResolution.xy;
    vec2 p = -1. + 2.*uv;
    p.x *= iResolution.x / iResolution.y;
    
    p *= 120.;
    
    // green lines
    float f = abs((p.x)-32.);
    f = min(f, abs((p.y)-48.));
    col += vec3(0.,0.8,0.3)*exp(-1.5*f);
    
    p += vec2(130, -80);

    // T
    float d = sdBox(p + vec2(-32, 8), vec2(32, 8));
    d = merge(d,  sdBox(p + vec2(-32, 32), vec2(16, 32)));
    
    // R
    p.x -= 65.;
    d = merge(d,  sdBox(p + vec2(-8, 16+32), vec2(8, 16)));
    float r = sdBox(p + vec2(-26-16, 16+32), vec2(26, 16));
    r = intersect(r, sdBox(rot(p + vec2(-30-12, 12+36), PI/3.7), vec2(30, 8)));
	d = merge(d, r);
    
    d = merge(d, sdBox(p + vec2(-12 -8, 8),     vec2(12, 8)));
    d = merge(d, sdCircle(p + vec2(-12. -19., 8),     8.));
    d = merge(d, sdCircle(p + vec2(-12. -21., 8),     8.));
        
    r = sdDonut(p + vec2(-32, 32), 24., 8.);
    r = intersect(r, sdBox(p + vec2(-32 - 16, 16),         vec2(16, 16)));
        
    d = merge(d, r);
    
    // O
    p.x -= 65.;
    d = merge(d, sdDonut(p - vec2(32, -32), 24., 8.));
    
    // N
    p.x -= 65.;
    float nc = sdBox(rot(p + vec2(-32-13, 0), PI/4.), vec2(64, 32));
    float nd = sdBox(p + vec2(-32 , 32),         vec2(32, 32));
    r = substract(sdBox(p + vec2(-32-16 , 32+18), vec2(32, 18)), substract(nc, nd));
    d = merge(d, r);
    r = substract(sdBox(p, vec2(32+16, 32)), intersect(nc, nd));
    d = merge(d, r);
    
    
    vec3 fontColor = mix(vec3(0., 0., 0.02), vec3(0., 0.5, 0.7), smoothstep(-32., -48., p.y));
    fontColor = mix(fontColor, vec3(1.), smoothstep(-40., -56., p.y));
	col = mix(col, fontColor, fillMask(d));
	col = mix(col, vec3(.9,0,0), innerBorderMask(d, 2.));
    
    return col;
}

// Function 244
bool debugDrawGbuffer(GBuffer gbuf, out vec4 fragColor) {
  switch (DEBUG_MODE) {
  case 1: // albedo
    fragColor = vec4(gbuf.albedo, 1.0);
    break;
  case 2: // normals
    fragColor = vec4(vec3(gbuf.normal * 0.5 + 0.5), 1.0);
    break;
  case 3: // depth
    fragColor = vec4(vec3(gbuf.depth * 0.01), 1.0);
    break;
  case 4: // radiance
    fragColor = vec4(vec3(pow(gbuf.radiance, 1.0 / 2.2)), 1.0);
    break;
  case 5: // variance
    fragColor = vec4(vec3(gbuf.variance), 1.0);
    break;
  case 6: // age
    fragColor = vec4(vec3(gbuf.age), 1.0);
    break;
  }

  return DEBUG_MODE != 0;
}

// Function 245
float drawG(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  bool onCir = isIn(length(uv), cMin, cMax);
  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||
    uv.x <= 0.0 && onCir);
  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&
    isIn(uv.x, -cMin + cthick*2., cMin));
  float valC = float(isIn(uv.x, -cMin + cthick*2., cthick*.5) &&
                    isIn(uv.y, -cMin, cthick*.5));
  return valA+valB+valC;
}

// Function 246
vec4 draw(vec2 pos, float brushSize, vec3 brushColor, vec2 A) {
    float d = distance(pos, A);
	float f = smoothstep(brushSize * brushSmooth, brushSize, d);
    return vec4(brushColor, 1.0 - f);
}

// Function 247
bool InRect( vec2 vPos, vec2 vA, vec2 vB )
{
    return (vPos.x >= vA.x) && (vPos.y >= vA.y) && (vPos.x < vB.x) && (vPos.y < vB.y);
}

// Function 248
bvec2 GetDustDirectionBottom(in ivec2 u) {
    Voxel[2] leftVoxels = GetVoxels(u+ivec2(-1,0));
    Voxel[2] rightVoxels = GetVoxels(u+ivec2(1,0));
    Voxel[2] downVoxels = GetVoxels(u+ivec2(0,-1));
    Voxel[2] upVoxels = GetVoxels(u+ivec2(0,1));
    
    bvec4 isConnectedBottom = bvec4(IsVoxelDustConnectable(leftVoxels[0]),
                 					IsVoxelDustConnectable(rightVoxels[0]),
                 					IsVoxelDustConnectable(downVoxels[0]),
                 					IsVoxelDustConnectable(upVoxels[0])
                 					);
    bvec4 isConnectedTop = bvec4(leftVoxels[1].type == VOXEL_TYPE_DUST,
                                 rightVoxels[1].type == VOXEL_TYPE_DUST,
                                 downVoxels[1].type == VOXEL_TYPE_DUST,
                                 upVoxels[1].type == VOXEL_TYPE_DUST
                                );
	
    return bvec2( (any(isConnectedBottom.xy) || any(isConnectedTop.xy))
                 && !any(isConnectedBottom.zw) && !any(isConnectedTop.zw),
                   (any(isConnectedBottom.zw) || any(isConnectedTop.zw))
                 && !any(isConnectedBottom.xy) && !any(isConnectedTop.xy)
                );
}

// Function 249
vec2 Line(vec2 a, vec2 b, vec2 p, vec2 identity, float sa, float sb)
{
    vec2 pa = p - a;
    vec2 pb = p - b;
	vec2 ba = b - a;
	float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);    
    vec2 pp = a + ba * t;
    vec2 y = vec2(-identity.y, identity.x);
    float cutoff = max(dot(pb, identity), dot(pa, -identity));
    float s = mix(sa, sb, t);
    return vec2(max(cutoff - .005, abs(dot(y, p - pp)) - s), t);
}

// Function 250
vec4 linear2gamma_premultalpha( vec4 c )
{
    return vec4( pow(c.xyz/c.w,vec3(1.0/kGamma) ), 1.0 );
}

// Function 251
void InitSpline()
{
#if 0	
	vec3 endpoint0 = vec3(0.79762733,0.45774102,-2.0626645);
	vec3 endpoint1 = vec3(0.23499674,0.73739231,-2.4975600);
	
	vec3 tangent0 = vec3(0.64538366,5.9951859,-1.0051248);
	vec3 tangent1 = vec3(-0.77649212,-3.6806760,-4.8185802);
#else
	//wiggly control points to test a bunch of different shapes
	float t = iTime*0.01;
	vec3 endpoint0 = S(t,0.);
	vec3 endpoint1 = S(t,1.);
	vec3 tangent0 = S(t,2.)*20.*sin(iTime);
	vec3 tangent1 = S(t,3.)*10.;
	
#endif

	vec3 ave = 0.5 * (endpoint1+endpoint0);
	endpoint0 -= ave;
	endpoint1 -= ave;
		
	geometrymatrix[0] = vec4(endpoint0,0.);
	geometrymatrix[1] = vec4(endpoint1,0.);
	geometrymatrix[2] = vec4(tangent0,0.);
	geometrymatrix[3] = vec4(tangent1,0.);	
	
	Initialize(spline, geometrymatrix);
}

// Function 252
float sdCircle(vec2 p, float r) { return length(p) - r; }

// Function 253
maybe_vec2 get_distances_along_line_to_negation(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    return maybe_vec2(
        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),
             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),
        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)
    );
}

// Function 254
float profileLine(vec2 p, vec2 dim) {
    return distance(p, vec2(clamp(p.x, -dim.x/2.0, dim.x/2.0), 0.0))-dim.y;
}

// Function 255
float line( vec3 p, vec3 pa, vec3 pb, float r )
{
    vec3 a = p - pa, b = pb - pa;
    float h = clamp( dot(a,b)/dot(b,b), 0.0, 1.0 );
    return length( a - b*h ) - r;
}

// Function 256
vec2 intersectLines(Line a, Line b){
    // Returns the cartesian intersection point between two lines.
    float divisor = (a.a.x - a.b.x)*(b.a.y - b.b.y)-(a.a.y - a.b.y)*(b.a.x - b.b.x);
    float tm1 = a.a.x*a.b.y - a.a.y*a.b.x;
    float tm2 = b.a.x*b.b.y - b.a.y*b.b.x;
    return vec2( (tm1*(b.a - b.b) - tm2*(a.a - a.b))/divisor );
}

// Function 257
float SINcircle(vec2 p, float r, float gr)
{
   float c = sin(length(p)*gr);//sin waves
    c = clamp(c, 0.0, 1.0);
   return c*SOLcircle(p, r);  
}

// Function 258
float circleFill(float dist, float radius, float thickness)
{
    if (dist <= thickness) { return 1.0; }
    return 0.0;
}

// Function 259
float UDCircle( in vec2 coords, in vec2 circle, float radius)
{    
    return max(length(coords - circle.xy) - radius, 0.0);
}

// Function 260
float drawFract(inout vec2 p,int d,v0 f){float c=0.; 
 f=fract(f)*10.;for(int i=1;i<60;i++){
  c+=char(p,48+int(f));p.x+1.;d--;f=fract(f)*10.;if(d<=0||f==0.)break;
 }p.x+float(d);return c;}

// Function 261
float rect(in float u, in float v)
{
    float l_u = line(u);
    float l_v = line(v);
    return l_u*l_v;
}

// Function 262
void DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){
    
    
    vec2 vector = end - origin;
          uv  -= origin;
    float len  = length(vector);
       vector /= len;
    float v2   = dot(vector, vector);
    float vUv  = dot(vector, uv);
    vec2  p    = vector * clamp(vUv, 0.,len) /v2;
    float d    = distance(p, uv);

    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); 
}

// Function 263
vec3 rayDirection(vec3 cameraDir, vec2 uv){
    
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;
	return normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 264
float drawFract(float value, int digits)
{ 
  float c = 0.0;
  value = fract(value) * 10.0;
  for (int ni = 1; ni < 60; ni++) 
  {
    c += char(48 + int(value)); // add 0..9
    tp.x -= FONT_SPACE;
    digits -= 1;
    value = fract(value) * 10.0;
    if (digits <= 0 || value == 0.0) break;
  } 
  tp.x -= FONT_SPACE*float(digits);
  return c;
}

// Function 265
void DrawBorderIndent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )
{    
    vec2 vThickness = vec2(1.0);
    
	if ( Inside( vCanvasPos, rect ) )
    {        
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )
        {
            vOutColor.rgb = vec3(0.0);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )
        {
            vOutColor.rgb = vec3(0.85);
        }
        else
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(0.4);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(1.0);
        }
    }
}

// Function 266
vec4 trilinear(sampler2D ch, vec3 p3d)
{
    return mix(voxel(ch, vec3(p3d.xy, floor(p3d.z))),voxel(ch, vec3(p3d.xy, ceil(p3d.z))), fract(p3d.z));
}

// Function 267
float sdfCircle(vec2 center, float radius, vec2 coord )
{
    vec2 offset = coord - center;
    
    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;
}

// Function 268
void DrawShrub(out vec4 c){
	c = vec4(0.0, 0.5, 0.0, 1.0);
}

// Function 269
float circle( vec2 uv, vec2 pos, float scale )
{
	return length(pos - uv) * scale;
}

// Function 270
float line( in vec2 p, in vec2 a, in vec2 b ){
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 271
void draw(inout vec4 c, vec2 fragCoord, int mode) 
{   
	vec2 uv = floor(fragCoord.xy / 2.0);
    print_pos = vec2(75, 2.0);
    c += vec4(0.3) * (char(ch_c, uv) + char(ch_h, uv) + char(ch_a, uv) + char(ch_n, uv) +
         char(ch_g, uv) + char(ch_e, uv) + char(ch_sp, uv) + char(ch_m, uv)+
         char(ch_o, uv) + char(ch_d, uv) + char(ch_e, uv) + char(ch_sp, uv)+ 
         char(ch_k, uv) + char(ch_e, uv) + char(ch_y, uv) + char(ch_s, uv) + 
         char(ch_sp, uv)+ char(ch_a, uv) + char(ch_dsh, uv) + char(ch_z, uv));
    
    uv = floor(fragCoord.xy / 2.0);
    print_pos = vec2(2.0, 2.0);
    c += char(ch_m,  uv) + char(ch_o,  uv) + char(ch_d,  uv) + char(ch_e,  uv) + char(ch_sp, uv);
    
    //if(mode==0){
    //    c += char(ch_s,  uv) + char(ch_r,  uv) + char(ch_c,  uv);        
    //} else if(mode==1) {
    //    c += char(ch_d,  uv) + char(ch_s,  uv) + char(ch_t,  uv);
    //} else 
    if(mode==0) {             // SCREEN
        c += char(ch_s,  uv) + char(ch_c,  uv) + char(ch_r,  uv) + 
             char(ch_e,  uv) + char(ch_e,  uv) + char(ch_n,  uv);
    }
    if(mode==1) {       // MULTIPLY
        c += char(ch_m,  uv) + char(ch_u,  uv) + char(ch_l,  uv) + 
             char(ch_t,  uv);
    }
    if(mode==2) {       // OVERLAY
        c += char(ch_o,  uv) + char(ch_v,  uv) + char(ch_e,  uv) +
             char(ch_r,  uv) + char(ch_l,  uv) + char(ch_a,  uv) +
             char(ch_y,  uv);
    }
    if(mode==3) {       // HARDLIGHT
        c += char(ch_h,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_d,  uv) + char(ch_l,  uv) + char(ch_i,  uv) + 
             char(ch_g,  uv) + char(ch_h,  uv) + char(ch_t,  uv);
    }
    if(mode==4) {       // SOFTLIGHT
        c += char(ch_s,  uv) + char(ch_o,  uv) + char(ch_f,  uv) + 
             char(ch_t,  uv) + char(ch_l,  uv) + char(ch_i,  uv) + 
             char(ch_g,  uv) + char(ch_h,  uv) + char(ch_t,  uv);
    }
    if(mode==5) {       // COLORDODGE
        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + 
             char(ch_o,  uv) + char(ch_r,  uv) + char(ch_d,  uv) + 
             char(ch_o,  uv) + char(ch_d,  uv) + char(ch_g,  uv) +
             char(ch_e,  uv);        
    } 
    if(mode==6) {       // COLORBURN
        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + 
             char(ch_o,  uv) + char(ch_r,  uv) + char(ch_b,  uv) + 
             char(ch_u,  uv) + char(ch_r,  uv) + char(ch_n,  uv);
    } 
    if(mode==7) {       // LINEARDODGE
        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + 
             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_d,  uv) + char(ch_o,  uv) + char(ch_d,  uv) + 
             char(ch_g,  uv) + char(ch_e,  uv);        
    } 
    if(mode==8) {       // LINEARBURN
        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + 
             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_b,  uv) + char(ch_u,  uv) + char(ch_t,  uv) + 
             char(ch_n,  uv); 
    } 
    if(mode==9) {       // VIVIDLIGHT
        c += char(ch_v,  uv) + char(ch_i,  uv) + char(ch_v,  uv) + 
             char(ch_i,  uv) + char(ch_d,  uv) + char(ch_l,  uv) + 
             char(ch_i,  uv) + char(ch_g,  uv) + char(ch_h,  uv) + 
             char(ch_t,  uv); 
    } 
    if(mode==10) {      // LINEARLIGHT
        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_n,  uv) + 
             char(ch_e,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) + 
             char(ch_h,  uv) + char(ch_t,  uv);        
    } 
    if(mode==11) {      // PINLIGHT
        c += char(ch_p,  uv) + char(ch_i,  uv) + char(ch_n,  uv) +
             char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) +
             char(ch_h,  uv) + char(ch_t,  uv);  
    } 
    if(mode==12) {      // HARDMIX
        c += char(ch_h,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_d,  uv) + char(ch_m,  uv) + char(ch_i,  uv) + 
             char(ch_x,  uv);        
    } 
    if(mode==13) {      // SUBTRACT
        c += char(ch_s,  uv) + char(ch_u,  uv) + char(ch_b,  uv) +
             char(ch_t,  uv) + char(ch_r,  uv) + char(ch_a,  uv) +
             char(ch_c,  uv) + char(ch_t,  uv);
    } 
    if(mode==14) {     // DIVIDE
        c += char(ch_d,  uv) + char(ch_i,  uv) + char(ch_v,  uv) + 
             char(ch_i,  uv) + char(ch_d,  uv) + char(ch_e,  uv);
    } 
    if(mode==15) {     // ADDITION
        c += char(ch_a,  uv) + char(ch_d,  uv) + char(ch_d,  uv);
    } 
    if(mode==16) {     // DIFFERENCE
        c += char(ch_d,  uv) + char(ch_i,  uv) + char(ch_f,  uv) +
             char(ch_f,  uv);
    } 
    if(mode==17) {     // DARKEN
        c += char(ch_d,  uv) + char(ch_a,  uv) + char(ch_r,  uv) + 
             char(ch_k,  uv) + char(ch_e,  uv) + char(ch_n,  uv);
    } 
    if(mode==18) {     // LIGHTEN
        c += char(ch_l,  uv) + char(ch_i,  uv) + char(ch_g,  uv) + 
             char(ch_h,  uv) + char(ch_t,  uv) + char(ch_e,  uv) + 
             char(ch_n,  uv);
    } 
    if(mode==19) {     // INVERT
        c += char(ch_i,  uv) + char(ch_n,  uv) + char(ch_v,  uv) + 
             char(ch_e,  uv) + char(ch_r,  uv) + char(ch_t,  uv);
    } 
    if(mode==20) {     // INVERTRGB
        c += char(ch_i,  uv) + char(ch_n,  uv) + char(ch_v,  uv) + 
             char(ch_e,  uv) + char(ch_r,  uv) + char(ch_t,  uv) + 
             char(ch_r,  uv) + char(ch_g,  uv) + char(ch_b,  uv);
    } 
    if(mode==21) {     // HUE
        c += char(ch_h,  uv) + char(ch_u,  uv) + char(ch_e,  uv);
    } 
    if(mode==22) {     // SATURATION
        c += char(ch_s,  uv) + char(ch_a,  uv) + char(ch_t,  uv) + 
             char(ch_u,  uv) + char(ch_r,  uv) + char(ch_a,  uv) + 
             char(ch_t,  uv) + char(ch_i,  uv) + char(ch_o,  uv) + 
             char(ch_n,  uv);
    } 
    if(mode==23) {     // COLOR
        c += char(ch_c,  uv) + char(ch_o,  uv) + char(ch_l,  uv) + 
             char(ch_o,  uv) + char(ch_r,  uv);
    } 
    if(mode==24) {     // LUMINOSITY
        c += char(ch_l,  uv) + char(ch_u,  uv) + char(ch_m,  uv) + 
             char(ch_i,  uv) + char(ch_n,  uv) + char(ch_o,  uv) + 
             char(ch_s,  uv) + char(ch_i,  uv) + char(ch_t,  uv) +
             char(ch_y,  uv);
    }
    if(mode==25) {     // EXCLUSION
        c += char(ch_e,  uv) + char(ch_x,  uv) + char(ch_c,  uv) + 
             char(ch_l,  uv) + char(ch_u,  uv) + char(ch_s,  uv) + 
             char(ch_i,  uv) + char(ch_o,  uv) + char(ch_n,  uv);
    }
}

// Function 272
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    //!!!!!!!!!!!!!!!!!!!!!!!!
    /*fix from page https://www.shadertoy.com/view/lsBSDm
		Hackerham, 2017-08-07
		Made a fix: https://gist.github.com/ivanpopelyshev/2a75479075286deb8ee5dc1fb2e07f09
	*/
    //!!!!!!!!!!!!!!!!!!!!!!!!
    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    float k2u = cross2d( e, g );
    float k1u = cross2d( e, f ) + cross2d( g, h );
    float k0u = cross2d( h, f);    
   
    float v1, u1, v2, u2;
    
    if (abs(k2) < 1e-5) 
    {
        v1 = -k0 / k1;
        u1 = (h.x - f.x*v1)/(e.x + g.x*v1);
    } 
    else if (abs(k2u) < 1e-5) 
    {
        u1 = k0u / k1u;
        v1 = (h.y - e.y*u1)/(f.y + g.y*u1);
    } 
    else 
    {
        float w = k1*k1 - 4.0*k0*k2;

        if( w<0.0 ) return vec2(-1.0);

        w = sqrt( w );

        v1 = (-k1 - w)/(2.0*k2);
        v2 = (-k1 + w)/(2.0*k2);
        u1 = (-k1u - w)/(2.0*k2u);
        u2 = (-k1u + w)/(2.0*k2u);
    }
    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;
    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;
    
    vec2 res = vec2(-1.0);

    if(  b1/* && !b2 */) res = vec2( u1, v1 );
    if( /*!b1 &&  */b2 ) res = vec2( u2, v2 );
    
    return res;
}

// Function 273
void DrawHills (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)
{
    float snowLine = sin(uv.x*2.35) * 0.1 + sin(uv.x*3.14) * 0.01;
    float grassStoneMix = smoothstep(snowLine-0.3, snowLine+0.3, uv.y);    
    
    float dist = EstimatedDistanceFromPointToGround(uv, scale) * -1.0;
    float green = clamp(dist * -3.0, 0.0, 1.0);
    green = smoothstep(0.0, 1.0, green) * 0.25;
    vec3 grassPixel = mix(pixelColor, vec3(0.35, (0.85 - green), 0.15) * tint, 1.0 - smoothstep(0.0, AA_AMOUNT, dist)); 
    
    vec3 stonePixel = mix(pixelColor, vec3((0.85 - green), (0.85 - green), (0.85 - green)) * tint, 1.0 - smoothstep(0.0, AA_AMOUNT, dist)); 
    
    pixelColor = mix(grassPixel,stonePixel,grassStoneMix);  
    
    DrawGrass(uv, pixelColor, tint, scale);
    DrawTrees(uv, pixelColor, tint, scale);
}

// Function 274
float drawPoint(in vec3 ro, in vec3 rd, in vec3 p)
{
    float d = distanceLine(ro, rd, p);
    d = step(d, 0.05);
    
    return d;
}

// Function 275
vec2 sdLineOri(in vec3 p, in vec3 b) {
	float h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);

	return vec2(length(p - h*b), h);
}

// Function 276
float linearstep(float edge0, float edge1, float x) {
	float t = (x - edge0)/(edge1 - edge0);
	return clamp(t, 0.0, 1.0);
}

// Function 277
void drawStr4(uint str)
{
    if( str < 0x100U )
        str = str * 0x100U + SPACE_CHAR;
    
    if( str < 0x10000U )
        str = str * 0x100U + SPACE_CHAR;
    
    if( str < 0x1000000U )
        str = str * 0x100U + SPACE_CHAR;
    
    for( int i = 0; i < 4; i++)
    {
      uint xy = (str >> 8*(3 - i)) % 256U;
      if( xy != SPACE_CHAR )
      {
          vec2 K = (fontUV-fontCaret)/fontSize;
          if( length(K) < .6 ) /* lookup skipping : avoid useless font texture lookup */
          {
              vec4 Q = fontTextureLookup(
                     ( K
                      + vec2(float(xy/16U) + .5  ,  16. - float(xy%16U) - .5)
                     )/16.)
                 /* * ( step(length(K),.5)) */
              ;
              fontBuffer.rgb += Q.rgb * smoothstep(.6,.4,length(K));

              if( max(abs(K.x),abs(K.y)) < .5 )
              {
                fontBuffer.a = min(Q.a,fontBuffer.a);
              }
          }
      }
      
        if( xy != STOP_CHAR ) fontCaret.x += fontSpacing*fontSize;
    }
}

// Function 278
vec3 draw_edge(vec2 uv, vec2 a, vec2 b, mat4 iT)
{
    
  	vec4 t1 = iT * vec4(vec3(a, map(a)).xzy, 1.0);
  	vec4 t2 = iT * vec4(vec3(b, map(b)).xzy, 1.0);
    
  	t1.xy /= t1.z;
  	t2.xy /= t2.z;
    
    vec3 col = color(vec2(0.4, map(a) * 0.0000002) );
    
    vec3 r = vec3(0.0);
    
   	r += segment(uv, t1.xy, t2.xy) * col;
    r += segment(uv, t2.xy, t1.xy) * col;
    
    return r;
}

// Function 279
float SDFCircle( in vec2 coords, in vec2 offset )
{
    coords -= offset;
    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return v / length(g); 
}

// Function 280
vec3 getLimitCircle(int i)
{
    float theta = pi / float(numCircles - 1);
    float r0 = tan(theta);
    float r1 = 1. / cos(theta);
    float r = (r1 - r0) * tan(theta);
    float r2 = (r1 - r0) / cos(theta);
    if(i == (numCircles - 1))
        return vec3(0., 0., 1.);
    return vec3(-cos((float(i)) * theta * 2.) * r2, sin((float(i)) * theta * 2.) * r2, r);
}

// Function 281
float drawInt(in vec2 where, in int what)
{
    int i=int((where*=RESOLUTION).y), j=int(where.x), k=1;
    if (i>0 && i<6)
      for (int n=10; n>0;n--)
        if ((j+=4)<3 && j>=0) {
            	int l=what/k;
                i = (i>4? 972980223: i>3? 690407533: i>2? 704642687: i>1? 696556137:972881535)/
            	    int(exp2(float(29-j-(l-(l/10)*10)*3)));
                return float(i-i/2*2);
        }
    	else k*=10;
    return 0.;
}

// Function 282
float Scanline( float y, float fBlur )
{   
    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;
    return mix( fResult, 1.0f, min( 1.0, fBlur ) );
}

// Function 283
float drawFract(int digits, float fn)
{
  float c = 0.0;
  fn = fract(fn) * 10.0;
  for (int i = 1; i < 60; i++)
  {
    c += char(48 + int(fn)); // add 0..9
    tp.x -= FONT_SPACE;
    digits -= 1;
    fn = fract(fn) * 10.0;
    if (digits <= 0 || fn == 0.0) break;
  }
  tp.x -= FONT_SPACE*float(digits);
  return c;
}

// Function 284
float drawA(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  bool onCir = isIn(length(uv), cMin, cMax);
  float valA = float((onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||
    uv.x <= 0.0 && onCir) && uv.y > 0.0);
  float valB = float(isIn(uv.y, -cthick*0.5, cthick*0.5) &&
    isIn(uv.x, -cMin + cthick*0.5, cMin - cthick*0.5));
  float valC = float(isIn(uv.x, -cMax, -cMin) && isIn(uv.y, -cMax, 0.0));
  float valD = float(isIn(uv.x, cMin, cMax) && isIn(uv.y, -cMax, -cthick));
  return valA+valB+valC+valD;
}

// Function 285
float getlinewidth(int i) {
    // WebGL 1.0 compliant line width function
    if (i == 0) return 0.01;
    if (i == 1) return 0.025;
    if (i == 2) return 0.05;
    return 0.1;
}

// Function 286
float fillRectangle( in vec2 p, in float x, in float y, in float dirx, in float diry, in float radx, in float rady )
{
	float d = box(p,x,y,dirx,diry,radx,rady);
    float w = fwidth(d)*4.0;
	return 1.0 - smoothstep(-w, w, d);
}

// Function 287
void drawGreenStripes(vec2 co)
{
	int f = int(mod(iTime * 60.0, 6.0));
	
	drawHorzRect(co.y, 32.0, 33.0, RGB(86, 126, 41)); // shadow blow
	
	const float MIN_Y = 33.0;
	const float HEIGHT = 6.0;
	
	vec4 darkGreen  = RGB(117, 189, 58);
	vec4 lightGreen = RGB(158, 228, 97);
	
	// draw diagonal stripes, and animate them
	if ((co.y >= MIN_Y) && (co.y < MIN_Y+HEIGHT)) {
		float yPos = co.y - MIN_Y - float(f);
		float xPos = mod((co.x - yPos), HEIGHT);
		
		if (xPos >= HEIGHT / 2.0) {
			fragColor = darkGreen;
		}
		else {
			fragColor = lightGreen;
		}
	}
	
	drawHorzRect(co.y, 37.0, 38.0, RGB(228, 250, 145)); // shadow highlight above
	drawHorzRect(co.y, 38.0, 39.0, RGB(84, 56, 71)); // black separator	
}

// Function 288
float DrawLine( vec2 vPos, vec2 vA, vec2 vB, float fThickness )
{    
    vec2 vOffset = vPos- vA;
    vec2 vAB = vB - vA;
    vec2 vDir = normalize( vAB );
    float fLength = length( vAB );
    
    float fProj = clamp( dot( vOffset, vDir ) / fLength, 0.0, 1.0 );
    
    vec2 vClosest = vA + vDir * fProj * fLength;
    
    float fLine = clamp( 1.0 - length( vClosest - vPos ) / fThickness, 0.0, 1.0 );
    return fLine;
}

// Function 289
vec4 DrawKeyGlow( vec2 uv, float keyID, vec2 size, float lifeTime)
{
    float lifeSpan = 0.3;
    float h = 0.3;
    lifeTime = clamp(lifeTime,0.,lifeSpan)/lifeSpan;
    lifeTime=lifeTime*lifeTime;
    size.y = (1.-lifeTime)*h;
    vec4 ret = vec4(0.);
    vec2 pos = vec2(keyID*0.2+0.1, 0.);
    vec2 p = (uv - pos);
    float t = 0.;
    if ( abs(p).x < size.x/2. && abs(p).y < size.y )
    {
        ret.a = 1.;
        vec3 col =  vec3(0.4,0.5,0.7);
        float a = (1.0-(p.y/h));
        ret.xyz =col*a*a*a;
        //ret.xyz = vec3(0.4,0.5,0.7);//*pow((1.-lifeTime),20.);
           
    }
    
    return abs(ret);
}

// Function 290
vec4 draw_character( int n, ivec2 pos, ivec2 iu ) {
    vec3 v = vec3( 0 ) ;
    iu -= pos + ivec2(1,0) ;
    if( n > 0 && n <= NUM_FONT_CHARS && iINSIDE( iu, ivec2(0), ch_gfx_dim ) ) {
        int x = iu.x, y = iu.y ;
        n -- ;
        x += 5 * ( n & 3 ) ;
        float fx2 = exp2(-float(x+1)) ;

        n >>= 2 ;
        int part = y < 4 ? n * 2 + 1 : n * 2 ;
        y = 3 - (y&3) ;
        v = vec3( fract( get_bit_row( part, y ) * fx2 ) >= .5 ) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 291
void PrintBeginNextLine( inout PrintState state, const LayoutStyle style )
{
    // move Y position to baseline based on current font size
    float fFontAscent = 0.65f;
	state.vPos.y -= style.vSize.y * (fFontAscent + style.fLineGap);
}

// Function 292
float sdCircle2 (vec2 p, float radius)
{
    return length(p) - radius;
}

// Function 293
float SplineValue(in float t)
{
    return
        P0 * N_i_4(t, 0.0) +
        P1 * N_i_4(t, 1.0) +
        P2 * N_i_4(t, 2.0) +
        P3 * N_i_4(t, 3.0) +
        P4 * N_i_4(t, 4.0) +
        P5 * N_i_4(t, 5.0) +
        P6 * N_i_4(t, 6.0) +
        P7 * N_i_4(t, 7.0);   
}

// Function 294
vec4 draw_number_0k( int k, int n, ivec2 pos, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    int off = 0 ;
    if( n < 0 ) {
        v += draw_character( _DASH, pos, iu ) ;
        n = 0 - n ; //freaking workaround for mac os bug!!!
        off = 8 ;
    }
    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(off,0), ivec2(k*8,8) ) ) {
        int p = ( ( k*8 - 1 ) - iu2.x ) / 8, c ;
        //for( int i = 0 ; i < p ; ++ i ) n /= 10 ;
        //c = n % 10 ;
        int d = int( pow( 10., float(p) ) ) ;
        c = ( n / d ) % 10 ;
        v += draw_character( c + 1, pos + ivec2( (k-1-p) * 8, 0 ), iu ) ;
    }
    return( v ) ;
}

// Function 295
vec3 digitRect(in vec2 uv, in int digit)
{
    uv = (uv / 8. - 1.02) * 0.6;
	return printDigi(digit, uv);
}

// Function 296
void DrawPaving()
{
	if ( abs(pixel.x) < 180.0 && abs(pixel.y) < 180.0 )
	{
//		fragColor.rgb = mix( vec3(.0), vec3(.2), pow(texture( iChannel0, pixel/120.0+.5 ).r,.5) );
		fragColor.rgb = mix( vec3(.0), vec3(.3,.25,.2), pow(texture( iChannel1, pixel/60.0+.5 ).r,.5) );
	}
}

// Function 297
float fLine(vec2 p, vec2 a, vec2 b) {
	return dot(p - a, normalize(b - a) * mat2(0,-1,1,0));
}

// Function 298
vec3 gammaCorrect(vec3 rgb) {
  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),
              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),
              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));
}

// Function 299
void DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )
{
	float t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );
    t = 1.0 - abs( 2.0 * t - 1.0 );

    questionY -= floor( t * 8.0 );
    if ( questionX >= 0.0 && questionX <= 15.0 )
    {            
    	if ( time >= questionHitTime )
        {                
        	SpriteQuestion( color, questionX, questionY, 1.0 );
            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )
            {
                color = RGB( 231, 90, 16 );
            }
        }
        else
        {
         	SpriteQuestion( color, questionX, questionY, questionT );
        }
    }
}

// Function 300
vec4 sampleOneMovingCircle(int i, vec2 fragPos)
{
    vec2 n = noise(i, iTime) * CIRCLE_DISTANCE;
    float x = iResolution.x / 2.0 + n.x;
    float y = iResolution.y / 2.0 + n.y;
    vec2 n2 = noise(i * 3, iTime / 10.0);
    vec3 col = CIRCLE_COLOUR_A + n2.x * (CIRCLE_COLOUR_B - CIRCLE_COLOUR_A);
    return sampleOneCircle(vec2(x, y), fragPos, col);
}

// Function 301
void DrawPoint(inout vec3 color_out, in vec3 color_in, in vec2 pixel, in vec2 center, in float radius){
    vec2 point = pixel-center;
    if( dot(point, point) <= radius*radius){
        color_out = color_in;
    }
}

// Function 302
vec2 circle(float angle)
{
    angle *= TWOPI;
    return vec2(cos(angle), sin(angle));
}

// Function 303
float stripesCircle(vec2 uv, StripesCircleOpt opt, StripesOpt sopt) {
    uv = vec2(atan(uv.y, uv.x)/PI*opt.kappa+iTime*opt.omega+opt.phi, fit01(opt.minRadius, opt.maxRadius, length(uv))*2.-1.);
    return stripes(uv, sopt);
}

// Function 304
float GetColourForLineSegment(vec3 cp0, vec3 cp1, vec2 uv, float pixel_uv_size)
{
	float t = GetPositionAlongLineSegmentNearestToPoint(cp0.xy,cp1.xy, uv);

	vec2	best_point		= mix(cp0.xy,cp1.xy,t);
	float	best_thickness	= mix(cp0.z, cp1.z, t*t);	// Non-linear for thickness...
    float	best_dist 		= length(uv - best_point.xy);
    float	best_surface	= best_thickness - best_dist;
    
    float aa = smoothstep(0.0, pixel_uv_size, best_surface);
    
    return aa;
}

// Function 305
void Circle( inout vec3 o, vec2 c, float r, vec3 i, vec2 uv )
{
    o = mix( i, o, smoothstep( r-1.4, r, length(uv-c) ) );
}

// Function 306
void draw_01x32(in vec2 p, in vec2 uv, inout vec4 fragColor)
{
    vec2 o = vec2(2., floor(z - 2.));
	p -= o;
    vec2 c = uv * z - o;

    { // Cell frame        
	    float w = 0.25;
		float l = sharpen(df_line(c, vec2( 0,1), vec2(32,1)), w)
	            + sharpen(df_line(c, vec2( 0,0), vec2(32,0)), w)
	        	+ sharpen(df_line(c, vec2( 0,1), vec2( 0,0)), w)
	        	+ sharpen(df_line(c, vec2(32,1), vec2(32,0)), w);
    
	    if (l > 0.) fragColor = vec4(CL, 1);
    }
    
    { // Cells        
    	if (p.x >= 0. && p.y == 0. &&  p.x <= 31.) {
    		float bit = 0.;
        	bit = mod(val / pow(2., 31. - p.x), 2.);
            float mut = 31. - p.x > 23. ? .4 : 1.;
    		fragColor = vec4((floor(bit) > 0. ? C1 : C0) * mut, 1);
		}
    }
    
    { // Cell lines
    
    	float l = 0.;
    	float w = 0.06;
	    
	    for (int i = 0; i < 32; ++i) {
	        l += sharpen(df_line(c, vec2(i,1), vec2(i,0)), w);
	    }
    
	    if (l > 0.) fragColor = vec4(CL, 1);
    }
}

// Function 307
void drawCircle(vec2 pos, float r, vec4 col)
{
    float d = length(pos - xy);
    mixColor(col, lerpstep(r + aa, r - aa, d));
}

// Function 308
vec2 circleMusicMap(vec2 circlePos, vec2 pixelPos, float radius){
	vec2 musicMap;
    // create music map red (angle center)
    float deltaX = pixelPos.x-circlePos.x;
    float deltaY = pixelPos.y-circlePos.y;
    float angleFromCenter = atan2(deltaX,deltaY);  
    musicMap.r = 1.0-(angleFromCenter+PI)/(PI*2.0);
    
    // create music map blue (dist center)
    float distFromCenter = sqrt((deltaY*deltaY)+(deltaX*deltaX));
    float circleFromCenter = (distFromCenter*3.0);
    circleFromCenter = circleFromCenter-radius;
    musicMap.g = circleFromCenter;   
    return musicMap;
}

// Function 309
float rectangle(vec2 p,vec2 dim,vec2 center,float a)
{
	p.x -= center.x;
	p.y -= center.y;
	float x =  p.x *cos(a) - p.y* sin( a) ;
	float y = p.y *cos(a) + p.x *sin(a) ;
	return step(-dim.x/2.,x)*step(x,dim.x/2.)*step(-dim.y/2.,y)*step(y,dim.y/2.);
}

// Function 310
void DrawFuelBar(vec2 fragCoord, float fuelPercent, inout vec3 pixelColor)
{
    fuelPercent = min(fuelPercent, 1.0);
    float aspectRatio = iResolution.x / iResolution.y;
    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);
    uv.x *= aspectRatio;    
    
    const float c_width = 0.2;
    const float c_height = 0.05;
    
    vec2 boxPosLeft = vec2(-0.5 * aspectRatio + 0.01, 0.5 - (c_height + SCORE_SIZE / iResolution.y));
    vec2 boxPosRight = vec2(-0.5 * aspectRatio + 0.01 + c_width, 0.5 - (c_height + SCORE_SIZE / iResolution.y));
    
    // black outer box
    float boxDistance = UDFatLineSegment(uv, boxPosLeft, boxPosRight, c_height);
    boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);
    pixelColor = mix(pixelColor, vec3(0.0,0.0,0.0), boxDistance);
    
    // red fuel amount
    if (fuelPercent > 0.0)
    {
        boxPosRight.x = boxPosLeft.x + (boxPosRight.x - boxPosLeft.x) * fuelPercent;
        boxDistance = UDFatLineSegment(uv, boxPosLeft, boxPosRight, c_height);
        boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);
        pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), boxDistance);   
    }
}

// Function 311
float interpolateLinear(float a, float b, float t){
  return mix(a, b, clamp(t, 0.0, 1.0));
}

// Function 312
vec4 draw_a_cell (Element cell, Element left, Element top, Element right, Element bottom, vec2 p, vec4 visual) {

    // p spans from 0.01 to 7.99. There's a small gap of 0.5 a cell lacks at the right and bottom,
    // it's placed slightly asymmetric to provide a good resolution even at 8x8 pixels per cell.


/*
----
\  |
 \ |
  \|
*/

    /*
    
        We combine the DFF ring with all output wires because they reflect the same physical entity.
    
        We draw an output if the adjacent cell has one of its inputs pointing to this cell.
        Outputs are canonical: all cells no matter their type have 4 outputs.
        
        We ALWAYS draw all input wires. In advanced vis, the wires might contain signal color inside.
            GND and PWR: 0 inputs
            MUX: 3 inputs
            Crossbar: 4 inputs (not clear if we should draw those lines when no consumers)
            Wire: 1 input.

        We draw diagonal lines for the active MUX input and a short one looking like --/
        showing the selector input.
    */

    float show_in_left = consumes_from_the_left(cell);
    float show_out_right = consumes_from_the_left(right);

    float show_in_right = consumes_from_the_right(cell);
    float show_out_left = consumes_from_the_right(left);

    float show_in_top = consumes_from_the_top(cell);
    float show_out_bottom = consumes_from_the_top(bottom);

    float show_in_bottom = consumes_from_the_bottom(cell);
    float show_out_top = consumes_from_the_bottom(top);
    
    float no_connections = show_in_left+show_out_right+show_in_right
      +show_out_left+show_in_top+show_out_bottom+show_in_bottom+show_out_top;


    // Outputs

    if (show_out_right > 0.5) {
        float out_right = solid_rect(vec4(
            2.5, CENTER - HALF_SPACING - HALF_WIRE_THICK,
            8.0, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);
        visual = vec4(compose(out_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }

    if (show_out_left > 0.5) {
        float out_left = solid_rect(vec4(
            0.0, CENTER + HALF_SPACING - HALF_WIRE_THICK,
            6.5, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);
        visual = vec4(compose(out_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }

    if (show_out_bottom > 0.5) {
        float out_bottom = solid_rect(vec4(
            CENTER + HALF_SPACING - HALF_WIRE_THICK, 2.5,
            CENTER + HALF_SPACING + HALF_WIRE_THICK, 8.0), p);
        visual = vec4(compose(out_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }

    if (show_out_top > 0.5) {
        float out_top = solid_rect(vec4(
            CENTER - HALF_SPACING - HALF_WIRE_THICK, 0.0,
            CENTER - HALF_SPACING + HALF_WIRE_THICK, 6.5), p);
        visual = vec4(compose(out_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }

    // ---------------------------------------
    // Crossbar D flip-flop state bubbles
    if (cell.mode < 0.5 && cell.orientation > 0.5 && cell.orientation < 1.5) {
    
        vec2 signal_bubble_center = vec2(1.9, 3.5);
    
        if (show_in_left * show_out_right > 0.5) {
            visual = draw_crossbar_signal(signal_bubble_center, cell.right, left.right, visual, p);
        }
        if (show_in_top * show_out_bottom > 0.5) {
            visual = draw_crossbar_signal(signal_bubble_center, cell.bottom, top.bottom, visual,
                rotate(p, sin(radians(-90.0)), cos(radians(-90.0)), vec2(CENTER)));
        }
        if (show_in_right * show_out_left > 0.5) {
            visual = draw_crossbar_signal(signal_bubble_center, cell.left, right.left, visual,
                rotate(p, sin(radians(-180.0)), cos(radians(-180.0)), vec2(CENTER)));
        }
        if (show_in_bottom * show_out_top > 0.5) {
            visual = draw_crossbar_signal(signal_bubble_center, cell.top, bottom.top, visual,
                rotate(p, sin(radians(-270.0)), cos(radians(-270.0)), vec2(CENTER)));
        }
    }

    // Draw inputs on top of crossbar DFF state bubbles
    if (show_in_left > 0.5) {
        float in_left = solid_rect(vec4(
            0.0, CENTER - HALF_SPACING - HALF_WIRE_THICK,
            1.56, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);
        visual = vec4(compose(in_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }
    
    if (show_in_right > 0.5) {
        float in_right = solid_rect(vec4(
            7.35, CENTER + HALF_SPACING - HALF_WIRE_THICK,
            8.0, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);
        visual = vec4(compose(in_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }
    
    if (show_in_top > 0.5) {
        float in_top = solid_rect(vec4(
            CENTER + HALF_SPACING - HALF_WIRE_THICK, 0.0,
            CENTER + HALF_SPACING + HALF_WIRE_THICK, 1.56), p);
        visual = vec4(compose(in_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }
    
    if (show_in_bottom > 0.5) {
        float in_bottom = solid_rect(vec4(
            CENTER - HALF_SPACING - HALF_WIRE_THICK, 7.35,
            CENTER - HALF_SPACING + HALF_WIRE_THICK, 8.0), p);
        visual = vec4(compose(in_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    }
    
    if (cell.mode > 0.5 || cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {
    
        float next_value = 0.0;
        float l = 0.0;
        if (cell.mode > 1.5) {

            if (cell.orientation > 2.5) {
                next_value = mux_action(cell.mode, left.right, right.left, bottom.top, top.bottom);
                l = left.right;
            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {
                next_value = mux_action(cell.mode, top.bottom, bottom.top, left.right, right.left);
                l = top.bottom;
            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {
                next_value = mux_action(cell.mode, right.left, left.right, top.bottom, bottom.top);
                l = right.left;
            } else if (cell.orientation < 0.5) {
                next_value = mux_action(cell.mode, bottom.top, top.bottom, right.left, left.right);
                l = bottom.top;
            }
        } else if (cell.mode < 1.5 && cell.mode > 0.5) {
            // wire
            if (cell.orientation > 2.5) {
                next_value = right.left;
            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {
                next_value = bottom.top;
            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {
                next_value = top.bottom;
            } else if (cell.orientation < 0.5) {
                next_value = left.right;
            }
        } else if (cell.mode < 0.5) {
            if (cell.orientation > 2.5) {
                next_value = 1.0;
            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {
                next_value = 0.0;
            } else if (is_reconf_port(cell) > 0.5) {
                //l = cell.parent;
                
                if (cell.parent > 2.5) {
                    l = left.right;
                } else if (cell.parent < 2.5 && cell.parent > 1.5) { 
                    l = bottom.top;
                } else if (cell.parent < 1.5 && cell.parent > 0.5) {
                    l = right.left;
                } else if (cell.parent < 0.5) {
                    l = top.bottom;
                }
            }
        }
    
        // Not a crossbar or reconf port

        // MUX, GND, PWR, WIRE D flip-flop state (current and next)
        // There are 4 discs on top of each other
        float inner_disc = 0.0;
        float bigger_inner_disc = 0.0;
        float outer_disc = 0.0;
        float smaller_outer_disc = 0.0;
        
        float outer_disc_diameter = 5.0;
        
        if (cell.mode > 0.5 && cell.mode < 1.5) {
            // If it's wire, make shapes smaller please!
            inner_disc = 100.0; //disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);
            bigger_inner_disc = disc(vec2(4.5, 4.5), 4.1 * WIRE_THICK, p);
            outer_disc_diameter = 4.1;
        } else {
            inner_disc = disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);
            bigger_inner_disc = disc(vec2(4.5, 4.5), 5.0 * WIRE_THICK, p);
        }
        
        outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter, p);
        smaller_outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter - 2.0 * WIRE_THICK, p);
        

        visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
        
        
        if (cell.mode > 0.5 || cell.mode < 0.5 && cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {

            if (cell.right < 0.5) {
                visual = vec4(compose_antialias(smaller_outer_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);

                // Don't draw if 0->1
                //if (next_value < 0.5 || cell.right > 0.5) {
                //    visual = vec4(compose(bigger_inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
                //}
            } else {
                visual = vec4(compose_antialias(bigger_inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);
            }
        }
        
      
        // MUX currently switched input (s ? a : b => s = 1 -> a : s = 0 -> b)
        float rotate_sel = (3.0 - cell.orientation) * -90.0;
        float rotate_curr = rotate_sel;
        
        float rotate_alt = 0.0;
        float mux_mode = 7.0 - cell.mode;
     
        // Switch over 6 modes
        if (mux_mode < 0.5) {
            // rotate_curr = l > 0.5 ? b : t;
            rotate_curr += l > 0.5 ? 90.0 : -90.0;
        } else if (mux_mode > 0.5 && mux_mode < 1.5) {
            //result = l > 0.5 ? t : b;
            rotate_curr += l > 0.5 ? -90.0 : 90.0;
        } else if (mux_mode > 1.5 && mux_mode < 2.5) {
            //result = l > 0.5 ? r : t;
            rotate_curr += l > 0.5 ? 180.0 : 270.0;
        } else if (mux_mode > 2.5 && mux_mode < 3.5) {
            //result = l > 0.5 ? t : r;
            rotate_curr += l > 0.5 ? 270.0 : 180.0;
        } else if (mux_mode > 3.5 && mux_mode < 4.5) {
            //result = l > 0.5 ? r : b;
            rotate_curr += l > 0.5 ? 180.0 : 90.0;
        } else if (mux_mode > 4.5 && mux_mode < 5.5) {
            //result = l > 0.5 ? b : r;
            rotate_curr += l > 0.5 ? 90.0 : 180.0;
        }
        
        if (cell.mode > 0.5 && cell.mode < 1.5) {
            // WIRE
            if (cell.orientation > 2.5) {
                rotate_curr = 180.0;
            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {
                rotate_curr = 90.0;
            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {
                rotate_curr = -90.0;
            } else if (cell.orientation < 0.5) {
                rotate_curr = 0.0;
            }
            
            // visual = transparent_compose(-1.0, vec4(1.0, 0.0, 0.0, 0.5), visual);
        } else if (is_reconf_port(cell) > 0.5) {
            rotate_curr = (4.0 - cell.parent) * 90.0;
        }
        
        //---------------------------------------------
        // Currently selected input (A or B) for MUX or THE input for wires
        vec2 input_vertex = vec2(1.5, CENTER - HALF_SPACING);
        float mux_current_input_halo = solid_rect(vec4(
            input_vertex.x, input_vertex.y - 2.0 * WIRE_THICK,
            CENTER, CENTER - HALF_SPACING + 2.25 * WIRE_THICK),
            
            rotate(
                rotate(p,
                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),
                    vec2(CENTER)
                ),
                sin(radians(-18.0)), cos(radians(-18.0)),
                input_vertex + vec2(0.0, HALF_WIRE_THICK)
            )
        );
        if (cell.mode > 0.5 && cell.mode < 1.5) {
            ;
        } else if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {
            visual = vec4(compose(mux_current_input_halo, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);
        }
        
        float mux_current_input = solid_rect(vec4(
            input_vertex.x - 0.1, input_vertex.y - HALF_WIRE_THICK,
            CENTER, CENTER - HALF_SPACING + HALF_WIRE_THICK),
            rotate(
                rotate(p,
                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),
                    vec2(CENTER)
                ),
                sin(radians(-18.0)), cos(radians(-18.0)),
                input_vertex + vec2(0.0, HALF_WIRE_THICK)
            )
        );

        
        // If 1 -> 0, don't draw this

        /* if (cell.right < 0.5 && next_value < 0.5) {
            // If 0 -> 0
            visual = vec4(compose(inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);
        } else if (next_value > 0.5) {
            // If 1->1 or 0->1
            visual = vec4(compose(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
        } */
        
        if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {
            visual = vec4(compose_antialias(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
            visual = vec4(compose(mux_current_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
        }
        
        
        // ------- MUX Selector Input --------------
        
        vec2 selector_input_vertex = vec2(1.5, CENTER - HALF_SPACING);
        
        if (cell.mode < 0.5) {
            // l = 0.0; // reconf port clock source
            rotate_sel = (3.0 - cell.parent) * 90.0;
        }
        
        float engaged_selector_offset = l > 0.5 ? -0.05 : 0.55;
        
        float mux_selector_input = solid_rect(vec4(
            selector_input_vertex.x,
            selector_input_vertex.y - 2.0,
            selector_input_vertex.x + 0.1 + WIRE_THICK,
            selector_input_vertex.y + 0.2),
            translate(
                rotate(
                    rotate(p,
                        sin(radians(rotate_sel)), cos(radians(rotate_sel)),
                        vec2(CENTER)
                    ),
                    sin(radians(-18.0)), cos(radians(-18.0)),
                    selector_input_vertex + vec2(0.0, HALF_WIRE_THICK)
                ),
                engaged_selector_offset, // 0.4: not engaged; -0.1: engaged
                -1.0
            )
        );
        
        if (cell.mode > 1.5 || is_reconf_port(cell) > 0.5) {
            visual = vec4(compose(mux_selector_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
        }
        
        if (cell.mode > 1.5) {
            visual = vec4(compose(-0.15 * (24.0 / zoom_factor), 1.0 * visual.rgb, 1.0 * vec3(1.0, 0.69, 0.1)), 1.0);
        }
    }
    
    //if (cell.write_pointer_counter > 0.5) {
        visual = vec4(compose(0.0, vec3(1.0 - 2.0 * cell.write_pointer_counter * (1.0/14.0), 1.0, 1.0), visual.rgb), 1.0);
    //}
    
    // Debug config signals:
    /*
    vec3 dat_clr = vec3(1.0, 0.0, 0.0);
    visual = cfg_dbg(cell.LDO, 1.5, 2.5, p, visual, dat_clr);
    visual = cfg_dbg(cell.TDO, 6.5, 1.5, p, visual, dat_clr);
    visual = cfg_dbg(cell.RDO, 7.0, 6.5, p, visual, dat_clr);
    visual = cfg_dbg(cell.BDO, 2.5, 7.0, p, visual, dat_clr);
    
    vec3 clk_clr = vec3(0.0, 0.0, 1.0);
    visual = cfg_dbg(cell.LCO, 1.5, 2.5 - 1.0, p, visual, clk_clr);
    visual = cfg_dbg(cell.TCO, 6.5 + 1.0, 1.5, p, visual, clk_clr);
    visual = cfg_dbg(cell.RCO, 7.0, 6.5 + 1.0, p, visual, clk_clr);
    visual = cfg_dbg(cell.BCO, 2.5 - 1.0, 7.0, p, visual, clk_clr);

    visual = cfg_dbg(cell.PREV_CLK, 4.5, 4.0, p, visual, clk_clr);
    visual = cfg_dbg(cell.WE_ARE_FULL_DFF, 4.5, 5.0, p, visual, dat_clr);
    */
    if (is_reconf_port(cell) > 0.5) {
        visual = vec4(compose(0.01 * (24.0 / zoom_factor), vec3(0.2, 0.0, 1.0), visual.rgb), 0.8);
    } else if (no_connections < 0.5 && cell.mode < 0.5 && cell.orientation > 1.5 && cell.orientation < 2.5) {
        // skip drawing the GND cells
        
        return vec4(1.0);
    }


    

    return visual;
}

// Function 313
float circleShape(vec2 uv, Circle c){
    float t = c.thickness;
    if(c.filled)
        return clamp((distance(uv, c.c) - c.r)*Dx, 0.0, 1.0);
	else
        return clamp((abs((sqrt(pow(uv.x - c.c.x, 2.0) + pow(uv.y - c.c.y, 2.0))-c.r))-t)*Dx, 0.0, 1.0);
}

// Function 314
vec2 PointLineProj(vec2 p, vec2 p0, vec2 p1)
{
    vec2 d = p1 - p0;

    float t = dot(p - p0, d) / dot(d, d);
    
    vec2 proj = (1.0-t)*p0 + t*p1;
    
    return proj;
}

// Function 315
mat4 GetDirectionalLightMatrixInverse ()
{
	mat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, directionalLightRotationAxisAngle.w );
	mat4 tra = translate( directionalLightSourcePosition.x, directionalLightSourcePosition.y, directionalLightSourcePosition.z );
	return tra * rot; 
}

// Function 316
void circle(
    in vec2		center,
    in float	radius,
    in vec2		uv,
    in float	smoothness,
    in vec4		color,
    inout vec4	colorOut)
{
    colorOut = mix( color, colorOut,
	((
        clamp
        (
            length( uv - center ),
            radius,
            radius + smoothness ) - radius
        
    	) / smoothness
    ));
}

// Function 317
float lineDistance(vec2 start, vec2 end, vec2 p) {
	float a = abs((end.y - start.y) * p.x - (end.x - start.x) * p.y + end.y * start.y - end.y * start.x);
  	float b = sqrt( pow((end.y - start.y), 2.0) + pow((end.x - start.x), 2.0) );
	return a / b;        
}

// Function 318
void drawBirdF1(int x, int y)
{
	if (y < 0 || y > 11 || x < 0 || x > 15) {
		return;
	}
	
	// pass 0 - draw black, white and yellow
	float col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  7) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  6) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  5) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,3.,1.,1.,1.,1.,1.,1.);
	if (y ==  4) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,1.,2.,2.,2.,2.,2.,1.);
	if (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);
	if (y ==  2) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
		
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(82,56,70); // outline color (black)
	}
	else if (col == 2.0) {
		fragColor = RGB(250,250,250); // eye color (white)
	}
	else if (col == 3.0) {
		fragColor = RGB(247, 182, 67); // normal yellow color
	}
	
	// pass 1 - draw red, light yellow and dark yellow
	col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,0.,0.,3.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  5) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  4) col = SPRROW(x,0.,3.,0.,0.,0.,3.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);
	if (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  2) col = SPRROW(x,0.,0.,0.,2.,2.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);	
	
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(249, 58, 28); // mouth color (red)	
	}
	else if (col == 2.0) {
		fragColor = RGB(222, 128, 55); // brown
	}
	else if (col == 3.0) {
		fragColor = RGB(249, 214, 145); // light yellow			
	}		
}

// Function 319
vec4 draw_crossbar_signal(vec2 center, float current, float next, vec4 visual, vec2 p) {

    // TODO: I do too many computations based on black for "1" and white for "0".
    // It will make it hard to adjust for bright and dark green palette, for example!
    vec3 next_color = vec3(1.0 - next);
    vec3 curr_color = vec3(1.0 - current);

    float outer_disc = disc(center, 3.8 * WIRE_THICK, p); // TODO: replace the diameter with spacing param
    visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);
    
    float middle_disc = disc(center, 2.5 * WIRE_THICK, p); // TODO: replace the diameter with spacing param
    visual = vec4(compose_antialias(middle_disc, curr_color, visual.rgb), 1.0);
    
    //float inner_disc = disc(center, 2.0 * WIRE_THICK, p); // TODO: replace the diameter with spacing param
    //visual = vec4(compose(inner_disc, next_color, visual.rgb), 1.0);

    return visual;
}

// Function 320
float line( vec2 p, vec2 a, vec2 b ) 
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 321
float crossline (vec2 p) {
    p = abs(p);
    float minp;
    minp = min(p . x, p . y);
    float maxp;
    maxp = (p . x + p . y) - minp;
    return max(maxp - 1.000000, minp);
}

// Function 322
float sdCircle(float r, vec2 uv)
{
	return length(uv) - r;    
}

// Function 323
vec3 backgroundDirectLight(vec3 dir) {
	if(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}
	float sphericalCapArea = sin(LightRadius)*sin(LightRadius);
	float lightStrength = LightIntensity/(sphericalCapArea);
	return lightStrength*LightColor.rgb;
}

// Function 324
void DrawClouds (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale, in float alpha)
{
    // draw clusters of tinted white circles?
    vec2 cloudOrigin = vec2(0.0);
    cloudOrigin.x = floor(uv.x / c_cloudDistance) * c_cloudDistance + c_cloudDistance * 0.5;
    cloudOrigin.y = (RandomFloat(cloudOrigin + vec2(0.453, 0.748) * 2.0 - 1.0) * c_cloudMaxDepth);
    
    vec2 uvRelative = uv - cloudOrigin;
    uvRelative /= scale;    
    
    float dist = 1.0;
    for (int i = 0; i < 10; ++i)
    {
       	vec3 circle;
        circle.x = 0.5 * (RandomFloat(cloudOrigin + vec2(0.453, 0.923) * float(i)) * 2.0 - 1.0);
        circle.y = 0.08 + 0.2 * RandomFloat(cloudOrigin + vec2(0.543, 0.132) * float(i));
        circle.z = 0.1 + 0.1 * RandomFloat(cloudOrigin + vec2(0.132, 0.645) * float(i));
    	dist = min(dist, UDCircle(uvRelative, circle.xy, circle.z));  
    }    
    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*40.0, dist);
    pixelColor = mix(pixelColor, tint, dist * alpha);       
}

// Function 325
vec3 lineLightMode (vec3 colorA, vec3 colorB)
{
    return colorB + 2.0 * colorA -1.0;
}

// Function 326
float line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}

// Function 327
void DrawMultiplier(vec2 p, float score, float multiplier, inout vec3 icolor)
{
    multiplier += 1.;
    
    vec3 color = icolor;
    
    vec2 q = p - vec2(-1., 0.85);
    q.x -= q.y*0.35;
    float d = uRoundBox(q, vec2(0.5, 0.068), 0.01);
    vec3 bgColor = color*0.8 + blueColor*0.2;
    bgColor = mix(bgColor, blueColor, smoothstep(-0.1, 0.2, q.y));
    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));
    color = mix(blueColor, color, smoothstep(0.0, 0.01, abs(d)-0.001));
    
    // Paint the inner colors
    q = p - vec2(-1.01, 0.85); q.x -= q.y*0.35;
    d = uRoundBox(q, vec2(0.42, 0.02), 0.01);
    float barD = smoothstep(-0.42, 0.42, q.x);
    bgColor = mix(vec3(0.352, 0.886, 0.854), pinkColor, pow(barD, 0.6));
    bgColor = mix(bgColor, color, step(score, barD));
    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));
    
    // Paint the inner windows
    q = p - vec2(-1.28, 0.85); q.x -= q.y*0.35;
    d = uRoundBox(q, vec2(0.18, 0.04), 0.01);
    color = mix(vec3(0.), color, smoothstep(-0.0, 0.001, abs(d)-0.004));
    
    q = p - vec2(-1.09, 0.85); 
    q.x -= q.y*0.35;
    vec2 q2 = q; q2.x = mod(q2.x, 0.18) - 0.09;
    d = uRoundBox(q2, vec2(0.08, 0.040), 0.01);
    d = max(max(d, -q.x), q.x-0.54);
    color = mix(vec3(0.), color, smoothstep(-0.0, 0.001, abs(d)-0.004));
    
    // Draw Multiplier number
    q = p - vec2(-0.5, 0.78); 
    float scale = 1.0;
    scale += 0.25 * (0.7+0.3*(sin(gT*8.) * step(7.0, multiplier)));
    d = -PrintInt(q*6.*scale, multiplier);
        vec3 lettersColor = vec3(1.);
    lettersColor = mix(lettersColor, pinkColor, 1.-smoothstep(-0.1, 0.15, q.y));
    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));
    color = mix(lettersColor, color, step(0., d));
    
    d = dX((q-vec2(0.085, 0.04))*12.*scale);
    color = mix(lettersColor, color, step(0., d));
    
    float deadT = max(0., gT - kFinishTime);
    icolor = mix(color, icolor, min(deadT*0.25, 1.));
}

// Function 328
void drawLandedParatroopers( ivec2 uv, vec4 d, inout vec3 col ) {
	drawLandedParatrooper(uv, d.x, 0., col);
	drawLandedParatrooper(uv, d.y, d.y==d.x?8.:0., col);
	drawLandedParatrooper(uv, d.z, (d.z==d.x?8.:0.) + (d.z==d.y?8.:0.), col);
	drawLandedParatrooper(uv, d.w, (d.w==d.x?8.:0.) + (d.w==d.y?8.:0.) + (d.w==d.z?8.:0.), col);
}

// Function 329
vec4 linear(float d){
    vec4 color;
    
    /*if(d <= (OUTSIDE_DIAMETER - INSIDE_DIAMETER) * 0.5 + INSIDE_DIAMETER){
        color = clamp((d - INSIDE_DIAMETER + GLOW_DISTANCE) / GLOW_DISTANCE, 0.0, 1.0) * GLOW_COLOR;
    }else{
        color = clamp((OUTSIDE_DIAMETER + GLOW_DISTANCE - d) / GLOW_DISTANCE, 0.0, 1.0) * GLOW_COLOR;
    }*/
    
    //optimize:y = k * |x + a| + b;
    
    float k = -1.0 / GLOW_DISTANCE;
    
    float a = -(OUTSIDE_DIAMETER + INSIDE_DIAMETER) * 0.5;
    
    float b = -k * (OUTSIDE_DIAMETER + GLOW_DISTANCE + a);
    
    color = clamp(k * abs(d + a) + b, 0.0, 1.0) * GLOW_COLOR;
    
    return color;
}

// Function 330
float subrectSize() {
    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);
    float valDefault = 0.25;
    float valPressed = mix(0.04, 0.6, iMouse.x/iResolution.x);
    return mix(valDefault, valPressed, isMousePressed);
}

// Function 331
float lineShape(vec2 uv, Line l){
    vec2 d  = l.b - l.a;
    vec2 nd = normalize(d);
    float len = dot(uv - l.a, nd);
    return clamp((distance(uv, l.a + len * nd) - l.thickness)*Dx, 0.0, 1.0);
}

// Function 332
void DrawScene(inout vec3 color, AppState s, vec2 p)
{
    vec2 mo = iMouse.xy/iResolution.xy;    
	   
    gBoxPos = vec3(8.0 * (s.playerCell + fract(2.0 * s.timeAccumulated)), 0.0, 0.0);
    
    float arm = mix(4.0, 8.0, s.paceScale );
    
	vec3 gOrig = gBoxPos;
   
#ifdef DEBUG
    gOrig += vec3(
        arm*cos(6.0*mo.x),
        0.0 + 4.0*mo.y,
        arm*sin(6.0*mo.x)
    );
#else
	vec3 gameOffset = vec3(
        arm*cos(1.0*3.14 + 0.1 * sin(0.5*iTime)),
        1.5 + 0.5 * s.paceScale,
        arm*sin(1.0*3.14 + 0.1 * sin(0.5*iTime))
    );
    vec3 failOffset = vec3(
        4.0*cos(0.1*iTime),
        1.5,
        4.0*sin(0.1*iTime)
    );
    
    gOrig += mix(
        gameOffset,
        mix(
            gameOffset,
            failOffset,
            smoothstep(0.0, 2.0, iTime - s.timeFailed)
        ),
        step(s.stateID, GS_SPLASH - 0.1)
    );

#endif
    
    gOrig.y += fbm3(100.0*gOrig) * 0.1 * s.paceScale;
    
    vec3 gLookat = gBoxPos + vec3( 0.0, 0.1, 0.0 );	
     
    mat3 ca = setCamera( gOrig, gLookat, 0.0);
    float fov = mix(2.2, 4.0, s.paceScale );
    vec3 dir = ca * normalize( vec3(vec2(p.x, p.y), fov) );
        
    MC hit = MR(gOrig, dir);
    
    vec3 shade = Shade(hit, dir, gOrig );
    vec3 bloom = SceneBloom();                
    color = 2.5 * shade + bloom;
    
    //particles
    float angle = atan(dir.z, dir.y)/(atan(iTime)-1.*1.*PI);
    angle -= floor(angle);
    float rad = length(vec2(dir.x * 0.02, dir.z));
 
    if (s.isFailed < 0.5)
    {
        float timeScale = mix(20.0, 50.0, s.paceScale);
        float dist3Scale = mix(100.0, 25.0, s.paceScale);
        float opacityScale = mix(0.2, 1.0, s.paceScale);

        float angleFract = fract(angle*10.5);
        float angleRnd = floor(angle*180.);
        float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);
        float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);
        float t = iTime*timeScale+angleRnd1*1000.;
        float radDist = sqrt(angleRnd2+.1);
        float adist = radDist/rad*.2;
        float dist = (t*.2+adist);
        dist = abs(fract(dist/20.)-.5);

        color += opacityScale * max(0.0,.7-dist*dist3Scale/adist)*(0.5-abs(angleFract-.5))*1./adist/radDist;        
    }
    
    // score counter text    
    if (s.isFailed < 0.5)
    {
        vec2 p1 = p;
        p1 *= 7.0;
        p1 -= vec2(-1.0, 5.5);
        p1 -= vec2(-0.5 * ceil(log2(s.score)/log2(10.0)), 0.0);
        p1 *= mix( 0.9, 1.0, abs(sin(2.0 * 3.14 * iTime)) * step(s.isFailed, 0.5) );
        color += PrintInt(p1, s.score);
    }
}

// Function 333
bool draw_debug(out vec4 fragColor, vec2 fragCoord)
{
    if (iMouse.z > 0.)
        fragCoord = (fragCoord - iMouse.xy) / DEBUG_CLICK_ZOOM + iMouse.xy;
    ivec2 addr = ivec2(fragCoord);

#if defined(DEBUG_TEXTURE) && (DEBUG_TEXTURE >= 0) && (DEBUG_TEXTURE < NUM_MATERIALS)
    vec4 atlas_info = load(ADDR_ATLAS_INFO);
    float atlas_lod = atlas_info.y;
    float atlas_scale = exp2(-atlas_lod);
    vec4 tile = get_tile(DEBUG_TEXTURE);
    vec2 uv = fragCoord / min_component(iResolution.xy/tile.zw) + tile.xy;
    fragColor = is_inside(uv, tile) < 0. ? vec4(0) :
    	texelFetch(SETTINGS_CHANNEL, ivec2(ATLAS_OFFSET + uv * atlas_scale), 0);
    return true;
#endif

#if DEBUG_ATLAS
    fragColor = texelFetch(SETTINGS_CHANNEL, addr, 0);
    return true;
#endif

#if DEBUG_LIGHTMAP >= 2
    int channel = addr.x & 3;
    addr.x >>= 2;
    if (uint(addr.y) < LIGHTMAP_SIZE.x && uint(addr.x) < LIGHTMAP_SIZE.y/4u)
    {
        LightmapSample s = decode_lightmap_sample(texelFetch(LIGHTMAP_CHANNEL, addr.yx, 0));
        float l = s.values[channel], w = s.weights[channel];
#if DEBUG_LIGHTMAP >= 3
    	fragColor = vec4(w <= 0. ? vec3(1,0,0) : l == 0. ? vec3(0,0,1) : vec3(l), 1);
#else
        fragColor = vec4(vec3(clamp(l, 0., 1.)), 1);
#endif
    }
    else
    {
        fragColor = vec4(0,0,0,1);
    }
    return true;
#elif DEBUG_LIGHTMAP
    vec4 texel = texelFetch(LIGHTMAP_CHANNEL, addr, 0);
    fragColor =
        uint(addr.x) < LIGHTMAP_SIZE.x && uint(addr.y) < LIGHTMAP_SIZE.y/4u ?
        	decode_lightmap_sample(texel).values :
    		texel;
    return true;
#endif

    return false;
}

// Function 334
float circle(vec2 p) {
    float r = length(p);
    float radius = 0.4;
    float height = 1.; 
    float width = 150.;
    
	return height - pow(r - radius, 2.) *width ;
}

// Function 335
float textLines(vec2 uvG)
{
    float wt = 5. * (iTime + 0.5*sin(iTime*1.4) + 0.2*sin(iTime*2.9)); // wobbly time
    vec2 uvGt = uvG + vec2(0., floor(wt));
    float ll = rand(vec2(uvGt.y, - 1.)) * ROWCOLS.x; // line length
    
    if (uvG.y > ROWCOLS.y - 2.){
        if (ceil(uvG.x) == floor(min(ll, fract(wt)*ROWCOLS.x)))
        	return 2.;
        if (ceil(uvG.x) > floor(min(ll, fract(wt)*ROWCOLS.x)))
        	return 0.;
    }
    if (uvGt.x > 5. && rand(uvGt) < .075)
        return 0.;
    if (max(5., uvGt.x) > ll)
        return 0.;
       
    return rand(uvGt)*15. + 2.;
}

// Function 336
v0 dLine (v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}

// Function 337
float rect(vec3 p, vec3 b)
{
  	vec3 d = abs(p) - b;
  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 338
float sSemiCircle(vec2 p, float radius){
  return sm(0.0,p.y) * sCircle(p,radius);
}

// Function 339
void line_to(float x, float y) { line_to(vec2(x,y)); }

// Function 340
vec3 drawFunction(vec2 p
){vec3 r
  ;float x = (p.x * numElf)
  ;float y = (p.y * numElf)
  ;float f=0.
  ;int ass =int((x)*numElf)
  ;int hole=int((y)*numElf)
  ;f-=float(funcInt(ass,hole)) //optional rasterized      //fast
  ;//f-=      (funcReal   (floor(x),floor(y)))//optional rasterized real //slow
  ;//f-=      (funcReal   (     (x),     (y)))//optional            real 
  ;//f+=((funcRealNorm(     (x),     (y))))//optional NAN creator (nonsense?)
  ;//f=abs((fract(f)))
  ;float diff = float(f) / numElf
  ;r=.5+.5*cos(iTime*vec3(1,.61,1.61))//aperiodic golden rainbow
  ;//ass= smoothstep(256.,0.,float(f))
  ;if(RENDER_MODE==0)
   r= mix(vec3(mix(1.-diff    ,smoothstep(256.,0. ,float(f)     ),r.y))
          ,    mix(color(diff),vec3(mix(0.,1.,step(float(f),0.))),r.x)
                                                                 ,r.z)//trilinear by [golden rainbow]
  ;else{
   ;if      (RENDER_MODE==1)r=color(diff)
   ;else if (RENDER_MODE==3)r=vec3(mix(0.,1.,step(float(f),0.)))
   ;else if (RENDER_MODE==2)r=vec3(diff)
   ;else if (RENDER_MODE==4)r=vec3(ass)  //vec3(mix(0.,1.,ass))
  ;}
  ;return r;
}

// Function 341
bool circle(vec2 uv, vec2 origin, float radius) {
 	return (length(uv-origin) < radius);
}

// Function 342
vec3 directIllumination(Camera c,vec3 pos, float dist, float index,float D){
	vec3 color = vec3(0.,0.,0.);
    Light l;
    Ray shadowRay;
    MarchingPack rmpl;
    for(int i=1; i<= LIGHT_NB;i++){
        l = Light(getObject(float(OBJ_NB+i)).xyz);
		shadowRay = Ray(pos,normalize(l.p-pos));
    	rmpl = rayCL(shadowRay,l,index);
        if(!rmpl.hit){
			color += directIllum(c,l, pos, dist,  index, D).xyz;
        }
    }
	return color/float(LIGHT_NB);
}

// Function 343
uint direct_16( in vec3 nor )
{
    nor /= max(max(abs(nor.x),abs(nor.y)),abs(nor.z)); // optional step (thanks Adam Cichocki), improves quality a bit

    vec3 v = 0.5 + 0.5*nor;
    uvec3 d = uvec3(round(v*vec3(63.0,31.0,31.0)));
    return d.x|(d.y<<6u)|(d.z<<11u);
}

// Function 344
void drawPipes(vec2 co)
{
	// calculate the starting position of the pipes according to the current frame
	float animationCycleLength = HORZ_PIPE_DISTANCE * PIPE_PER_CYCLE; // the number of frames after which the animation should repeat itself
	int f = int(mod(iTime * 60.0, animationCycleLength));
	float xPos = -float(f);
	
	float center = (PIPE_MAX + PIPE_MIN) / 2.0; 
	float halfTop = (center + PIPE_MAX) / 2.0;
	float halfBottom = (center + PIPE_MIN) / 2.0;	
	
	for (int i = 0; i < 12; i++)
	{	
		float yPos = center;
		int cycle = int(mod(float(i),8.0));
		
		if ((cycle == 1) || (cycle == 3)){
			yPos = halfTop;
		}
		else if (cycle == 2) {
			yPos = PIPE_MAX;	
		}
		else if ((cycle == 5) || (cycle == 7)) {
			yPos = halfBottom;
		}
		else if (cycle == 6){
			yPos = PIPE_MIN;
		}
			
		drawPipePair(co, xPos, yPos);
		xPos += HORZ_PIPE_DISTANCE;
	}
}

// Function 345
void drawHorzGradientRect(vec2 co, vec2 bottomLeft, vec2 topRight, vec4 leftColor, vec4 rightColor)
{
	if ((co.x < bottomLeft.x) || (co.y < bottomLeft.y) ||
		(co.x > topRight.x) || (co.y > topRight.y))
	{
		return;	
	}
	
	float distanceRatio = (co.x - bottomLeft.x) / (topRight.x - bottomLeft.x); 
	
	fragColor = (1.0 - distanceRatio) * leftColor + distanceRatio * rightColor;
}

// Function 346
void draw_screen_line(float d) {
    move_to(d, -2.0);
    line_to(d, 2.0);
}

// Function 347
void drawSprite_64x32( inout vec3 col, int spr[256], vec3 pal[16], vec2 p, vec2 s ) {
    ivec2 i = ivec2( floor(p-s) );
    if( i.x>=0 && i.x<64 && i.y>=0 && i.y<32 ) {
        int pi = spr[ i.x/8 + i.y*8 ] >> ((7-i.x)*4) & 0xF;
        if (pal[pi].r>-0.5) col = pal[pi];
    }
}

// Function 348
bool whiteRectangle(vec2 u){
 bvec2 a=lessThan(vec2(-1.),-abs(u));//bvec2 a=greaterThan(vec2(.1), uv); 
 return (a.x&&a.y);}

// Function 349
vec3 sRGBtoLinear(vec3 c)
{
    float a = 0.055;
    return mix(c / 12.92, pow((c + a) / (1.0 + a), vec3(2.4)), step(0.04045, c));
}

// Function 350
vec3 savedRect(in vec2 uv, in int digit)
{
    uv+=smear(uv/8.-1.0)*8.;
    uv.x+=float(digit+2)*16.;
	return texture(iChannel0, uv/iResolution.xy).rgb;
}

// Function 351
void drawVertLine(vec2 co, float xPos, float yStart, float yEnd, vec4 color)
{
	if ((co.x >= xPos) && (co.x < (xPos + 1.0)) && (co.y >= yStart) && (co.y < yEnd)) {
		fragColor = color;
	}
}

// Function 352
vec2 DrawSimpleUVQuad(vec2 a, vec2 b, vec2 c, vec2 d,vec2 uva, vec2 uvb, vec2 uvc, vec2 uvd,float t, vec2 co){
    vec3 baria = toBari(a,b,c,co);
    vec3 barib = toBari(a,d,c,co);
    vec3 baric = toBari(b,c,d,co);
    vec3 barid = toBari(b,a,d,co);
    float i = DrawQuad(a,b,c,d,t,co);
    vec2 coord = vec2(0.);
    float j = 0.;
    if (baric.x>0. && baric.x<1. && baric.y>0. && baric.y<1. && baric.z>0. && baric.z<1.){
        coord+= toCartesian(uvb,uvc,uvd,baric);
        j++;
    }
    if (barid.x>0. && barid.x<1. && barid.y>0. && barid.y<1. && barid.z>0. && barid.z<1.){
        coord+= toCartesian(uvb,uva,uvd,barid);
        j++;
    }
    if (baria.x >0. && baria.x<1. && baria.y >0. && baria.y<1. && baria.z >0. && baria.z<1.){
        coord+= toCartesian(uva,uvb,uvc,baria);
        j++;
    }
    if (barib.x>0. && barib.x<1. && barib.y>0. && barib.y<1. && barib.z>0. && barib.z<1.){
        coord+= toCartesian(uva,uvd,uvc,barib);
        j++;
    }
    return coord/j;
}

// Function 353
float lineSeg(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 354
float line0(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = dot(p, b) / dot(b, b),                  // proj coord on line
          c = clamp(h, 0., 1.);
    return h==c ? length(p - b * h) : 1e5;            // dist to strict segment
}

// Function 355
void DrawLengthedVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){
    
          uv  -= origin;
    float len  = length(vector);
       vector /= len;
    float v2   = dot(vector, vector);
    float vUv  = dot(vector, uv);
    vec2  p    = vector * clamp(vUv, 0.,len) /v2;
    float d    = distance(p, uv);

    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); 
}

// Function 356
void draw_game_info(inout vec4 fragColor, vec2 fragCoord)
{
    GameState game_state;
    LOAD(game_state);
    if (game_state.level == 0.)
        return;

    const int NUM_LINES = GAME_HUD_STATS.data[0];
    const int PREFIX_LENGTH = GAME_HUD_STATS.data[2] - GAME_HUD_STATS.data[1];
    const int NUM_DIGITS = 4;
    const int LINE_LENGTH = PREFIX_LENGTH + NUM_DIGITS;
    
    const float MARGIN = 16.;
    vec2 anchor = vec2(MARGIN, iResolution.y - MARGIN - float((CHAR_SIZE*NUM_LINES) << g_text_scale_shift));
    
    ivec2 uv = text_uv(fragCoord - anchor);
    int line = NUM_LINES - 1 - line_index(uv.y);
    
    // ignore last 2 lines (time/targets left) if game is over
    int actual_num_lines = NUM_LINES - (int(game_state.level < 0.) << 1);
    
    vec4 box = vec4(MARGIN, iResolution.y-MARGIN, ivec2(LINE_LENGTH, (actual_num_lines<<1)-1)<<g_text_scale_shift);
    box.zw *= vec2(CHAR_SIZE);
    box.y -= box.w;
    draw_shadow_box(fragColor, fragCoord, box);
    
    // line spacing
    if ((line & 1) != 0)
        return;
    line >>= 1;
    
    if (uint(line) >= uint(actual_num_lines))
        return;
       
    int start = GAME_HUD_STATS.data[1+line];
    int num_chars = GAME_HUD_STATS.data[2+line] - start;
    int glyph = glyph_index(uv.x);
    if (uint(glyph) < uint(num_chars))
    {
        glyph += start;
        glyph = get_byte(glyph & 3, GAME_HUD_STATS.data[GAME_HUD_STATS.data[0] + 2 + (glyph>>2)]);
    }
    else
    {
        glyph -= num_chars;
        if (uint(glyph) >= uint(NUM_DIGITS))
            return;
        
        int stat;
        switch (line)
        {
            case 0: stat = int(abs(game_state.level)); break;
            case 1: stat = int(game_state.targets_left); break;
            case 2: stat = int(game_state.time_left); break;
            default: stat = 0; break;
        }
		glyph = NUM_DIGITS - 1 - glyph;
        glyph = int_glyph(stat, glyph);
    }

    const vec3 HIGHLIGHT_COLOR = vec3(.60, .30, .23);
    vec4 color = vec4(vec3(.75), 1.);
    if ((line == 0 && fract(game_state.level) > 0.) ||
        (line == 1 && fract(game_state.targets_left) > 0.))
    {
		color.rgb = HIGHLIGHT_COLOR;
    }
    else if (line == 2 && game_state.time_left < 10.)
    {
        float blink_rate = game_state.time_left < 5. ? 2. : 1.;
        if (fract(game_state.time_left * blink_rate) > .75)
            color.rgb = HIGHLIGHT_COLOR;
    }

    print_glyph(fragColor, uv, glyph, color);
}

// Function 357
vec3 cosWeightedRandomHemisphereDirection2(const vec3 n) {
	
    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));
	vec3  vv = cross(uu, n);	
    
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831 * rv2.x); 
	float ry = ra*sin(6.2831 * rv2.x);
	float rz = sqrt(1.0 - rv2.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);

    return normalize(rr);
}

// Function 358
float distanceToLine(vec2 s0, vec2 s1, vec2 p)
{
	vec2 a = p-s0;
	vec2 b = normalize(s1-s0);
	return length(a - dot(a,b) * b);
}

// Function 359
vec2 BSpline(vec2 v)
{
    return vec2(BSpline(v.x), BSpline(v.y));
}

// Function 360
float drawParticles(vec2 uv, float speed)
{
	vec2 particleUV = (uv * 7.0 + vec2(0.0, iTime * speed));
    particleUV = vec2(particleUV.x, fract(particleUV.y + iTime) - 0.5);
    
    float particle = smoothstep(0.2, 0.0, length(particleUV));
    
    return particle;
}

// Function 361
float CanonLog_to_linear ( float clog)
{
float Out = 0.0;
if(clog < 0.12512248)
Out = -( pow( 10.0, ( 0.12512248 - clog ) / 0.45310179 ) - 1.0 ) / 10.1596;
else
Out = ( pow( 10.0, ( clog - 0.12512248 ) / 0.45310179 ) - 1.0 ) / 10.1596;
return Out;
}

// Function 362
vec4 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float colorVariation, float seed)
{
    vec2 l = randomLines(pos, scale, count, width, jitter, smoothness, phase, seed);
    vec3 r = hash3D(l.yy + seed);
    return vec4(l.x * (r.x < colorVariation ? r : r.xxx), l.x);
}

// Function 363
int line_index(int pixels_y)				{ return pixels_y >> 3; }

// Function 364
float circle(vec2 p, float r)
{
    return length(p) - r;
}

// Function 365
vec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){
    
    p -= off;
    
    float eps = 1./min(iResolution.x,iResolution.y);
    
    float circle = 1.-smoothstep(-eps, eps, 
    abs(radius - length(p))-thickness);
    
    col = mix(col, ringCol, circle);
    
    return col;
}

// Function 366
float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
}

// Function 367
vec2 GetPointOnCubicSpline(vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, float t)
{
	float p = t;
	float n = 1.0 - t;
        
	vec2 ans;
       
	ans  = cp0 * (n*n*n);
	ans += cp1 * (n*n*p*3.0);
	ans += cp2 * (n*p*p*3.0);
	ans += cp3 * (p*p*p);
    
    return ans;
}

// Function 368
vec4 outline(float distance, float linewidth, float antialias, vec4 stroke, vec4 fill)
{
    vec4 frag_color;
    float t = linewidth/2.0 - antialias;
    float signed_distance = distance;
    float border_distance = abs(signed_distance) - t;
    float alpha = border_distance/antialias;
    alpha = exp(-alpha*alpha);

    // Within linestroke
    if( border_distance < 0.0 )
        frag_color = stroke;
    else if( signed_distance < 0.0 )
        // Inside shape
        if( border_distance > (linewidth/2.0 + antialias) )
            frag_color = fill;
        else // Line stroke interior border
            frag_color = mix(fill, stroke, alpha);
    else
        // Outide shape
        if( border_distance > (linewidth/2.0 + antialias) )
            discard;
        else // Line stroke exterior border
            frag_color = vec4(stroke.rgb*alpha, 1.0);

    return frag_color;
}

// Function 369
vec4 DrawParticle(float id, vec2 p, float size, float t, vec3 color, float powFactor, float duration, float prevDuration, float distort)
{
    p.y *= 1. + sin(id*99.5+ dot(gUV,gUV)*40.+ gT*4.)*0.18 * distort;
    p.x *= 1. + cos(id*189.1+ dot(gUV,gUV)*76.+ gT*3.5)*0.13 * distort;
    
    float dist = dot(p, p)/size;
    float distNorm = smoothstep( 0., 1., pow(dist, powFactor) );
    
    duration = max(duration * (1.- smoothstep(0., 1., pow(dist, 0.1)) ), prevDuration);
    
    vec4 res = mix( vec4(color.rgb, duration), vec4(0., 0., 0., prevDuration), distNorm );
    return mix(mix(vec4(0., 0., 0., max(res.a, prevDuration)), res, smoothstep(0.0, 0.15, t)), vec4(0., 0., 0., max(res.a, prevDuration)), smoothstep(0.5, 1., t));
}

// Function 370
vec3 calculateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material, out vec3 wi, out vec3 f, out float scatteringPdf) {
    
        
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., visibility = 1.;

    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed, material);
    Li *= visibility;

    f = bsdfEvaluate(wi, wo, interaction.tangent, interaction.binormal, interaction, material) * abs(dot(wi, interaction.normal));        
    Ld += Li * f;

    return Ld;
}

// Function 371
vec3 ScanlinesRGB(float y)
{
	y += Interlacing() + 0.25;  
    
    // Real CRT images show differences in scattering and alignment
    // between the RGB beams.
    return vec3
    (
 	    Scanline(y + SCANLINE_ROFFSET, -SCANLINE_RGAPWIDTH, SCANLINE_RHARDNESS)   
        ,
 	    Scanline(y + SCANLINE_GOFFSET, -SCANLINE_GGAPWIDTH, SCANLINE_GHARDNESS)   
        ,
 	    Scanline(y + SCANLINE_BOFFSET, -SCANLINE_BGAPWIDTH, SCANLINE_BHARDNESS)   
    );
}

// Function 372
float dist_vertical_line( vec3 p)
{
  return length(vec2(length(p.xz)-1.0,p.y));
}

// Function 373
vec4 gettrilinear() {
  float t = 0.5*iTime;
  int i = int(t);
  doinvert = doinvert != (i/30%2 == 1);
  doclip = doclip != (i/60%2 == 1);
  float k = 0.0;
  if (domorph) k = fract(t);
  return mix(gettrilinear(i/2),gettrilinear((i+1)/2),k);
}

// Function 374
float sdf_circle(vec2 pos, vec2 circle_pos, float circle_r) {
	return length(pos - circle_pos) - circle_r;
}

// Function 375
vec3 draw_rect(in vec2 bottom_left, in vec2 top_right, in float line_width, in bool fill_inside, in vec2 texCoord)
{
    vec2 top_right_ = vec2(1.0) - top_right;
    
    vec2 left_bottom = smoothstep(bottom_left, bottom_left + vec2(line_width), texCoord);
    vec2 right_top = smoothstep(top_right_, top_right_ + vec2(line_width), 1.0 - texCoord);
    
    vec2 left_bottom_inside = vec2(0.);
    vec2 right_top_inside = vec2(0.0);
    
    if(fill_inside)
    {
    	left_bottom_inside = smoothstep(bottom_left - vec2(line_width), bottom_left, texCoord);
    	right_top_inside = smoothstep(top_right_ - vec2(line_width), top_right_, 1.0 - texCoord);    
    }
    
    float pctOuter = left_bottom.x * right_top.x * left_bottom.y * right_top.y; 
    float pctInside = left_bottom_inside.x * right_top_inside.x * left_bottom_inside.y * right_top_inside.y; 
 
    float pct = pctInside - pctOuter;
    vec3 inside_color = vec3(1., 0., 0.);
    vec3 color = vec3(1., 1., 0.0);
    vec3 final_color = (1.0 - pct) * color + pct * inside_color;
    return final_color;
}

// Function 376
float lineSegDist(vec2 uv, vec2 lineDir, vec2 linePoint, float r) {
    vec2 ba = -lineDir * r;
    vec2 pa = uv - linePoint + ba;
    ba *= 2.0;
    return length(pa - ba*clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0));
}

// Function 377
float onCircleLine( const vec2 c, const vec2 centre, const float radius ) {
	return clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );
}

// Function 378
vec3 draw_pillar(vec2 pos, vec2 p1, vec2 p3, vec3 current) {
    float WIDTH = iResolution.x;
	float HEIGHT = iResolution.y;
    vec3 building_colour = paper_colour*0.95;
    vec3 shadow_colour = building_colour*0.9;
    vec3 sky_colour = vec3(0.83, 0.83, 0.85);
    vec3 ground_colour = vec3(0.8, 0.8, 0.65);
    
    vec3 colour = current;
    colour = draw_box(pos, p1, p3, colour, true);
    colour = fill_box(pos, p1, p3, colour, building_colour);
    colour = fill_box(pos, vec2(p1.x+WIDTH*0.015, p1.y), p3, colour, shadow_colour);
    return colour;
}

// Function 379
float line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {
    float determinant = dot(direction, plane_normal);
    float zero = 0.0;
    if(determinant == 0.0)
        return zero/zero;
    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;
    return parallel_distance;
}

// Function 380
void outlineCheck(in vec2 uv, in float weight, in float aBase, inout float n) {
    n += weight * (1.0 - isInInterval(aBase-0.004, aBase+0.004, DEPTH(uv)));
}

// Function 381
vec3 inner_circle(vec2 uvmtp) {
    // Rotate
    vec2 rotated = rotate(uvmtp, PI * 2.0 * (1.0 - smoothstep(0.0, 1.0, cut_lower(fract(iTime * 0.06), 0.8))));
    
    // Gradient
    vec3 color = mix(vec3(0.0), vec3(0.15), rotated.y * 0.5 + 0.5) + 0.1;
    
    // Lines
    color = mix(color, vec3(0.0), (sin(length(rotated) * 80.0))*0.05);
    
    // From: https://thndl.com/square-shaped-shaders.html
    // Draw the triangle
    float a = atan(rotated.x, rotated.y) + PI * 0.5;
    float b = TWO_PI / 3.0;
    color = mix(color, vec3(rotated.y * 0.5 + 0.8)*0.5 + ((sin(iTime * 2.0) + 1.0) * 0.5)*0.2, 1.0 - smoothstep(0.5, 0.52, cos(floor(0.5 + a/b) * b - a) * length(rotated)));
    
    return color;
}

// Function 382
float distanceLine(in vec3 ro, in vec3 rd, in vec3 p)
{
    
    return length(cross(p-ro, rd)) / length(rd);
}

// Function 383
float Rect(vec2 uv, float left, float right, float bottom, float top, float blur){
    float band1 = Band(uv.x, left, right, blur); // Vertical band (x coord)
    float band2 = Band(uv.y, bottom, top, blur); // Horizontal band (y coord)
    return band1*band2; 
}

// Function 384
vec3 drawBezierDerivative(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){
    vec2 g1,g2,gEnd, prev = p1;
    float dt = 1./numSegments;  
    
    //this could be wrong
    float t = 0.;
    //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);
    //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);
    //prev = g2-g1;
    
    prev = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);
    prev*=3.;
    for(float t = dt; t <= 1.+dt; t+=dt){   
    
        //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);
        //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);

        gEnd = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);
        //(g2-g1);
        gEnd*=3.;
        col = drawLine(prev,gEnd,p,col,segCol*vec3(t, .7, .9),gradLineThickness);
        col = drawRing(gradRingRadius, .003, p, gEnd, col, segCircleCol);
        
        prev = gEnd;
    }
    
    return col;
}

// Function 385
float lineInf(vec2 p,vec2 a,vec2 b){vec2 d=b-a;return(dot(normalize(vec2(d.y,-d.x)),p-a));}

// Function 386
vec2 rndcircle(vec2 seed) {
    float a = seed.x * 2. * PI;
    float r = sqrt(seed.y);
    return vec2(r * cos(a), r * sin(a));
}

// Function 387
float line(float a, float d, float blur){
 float l = smoothstep(length(a), length(a)-d, blur);
 return l;
 }

// Function 388
vec3 get_view_direction(vec2 uv)
{
    const float fov_factor = 0.75;
    
    //vec3 n_direction = vec3(uv * 2.0 - 1.0, 2.0);
    vec3 n_direction = vec3(uv * fov_factor * 2.0 - fov_factor, 1.0);
    
    
#ifdef ANIMATE_CAMERA
    n_direction.y += sin(iTime * 0.75) * 0.25;	// Look up and down
#endif
    
    // Correct the aspect ration:
    n_direction.x *= iResolution.x / iResolution.y;
    
    n_direction = normalize(n_direction);
    
#ifndef ANIMATE_CAMERA
    return(n_direction);
#endif
    
    float angle = iTime * 0.25;
    vec3 n_rotated_direction = n_direction;
    n_rotated_direction.x = n_direction.x * cos(-angle) - n_direction.z * sin(-angle);
    n_rotated_direction.z = n_direction.x * sin(-angle) + n_direction.z * cos(-angle);
    
    return(normalize(n_rotated_direction));
}

// Function 389
vec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {
  vec2 xy = fragCoord - size * 0.5;
  float z = size.y / tan(radians(fov) * 0.5);
  return normalize(vec3(xy, -z));
}

// Function 390
void line_rgb (
    inout vec4 fragColorR, 
    in float lat180,  
    in float lat180target, 
    in float lat180radius,

	vec3 rgb)
{
    if (lat180 < (lat180target + lat180radius))
        if (lat180 >( lat180target - lat180radius))
            
 		//if (lat180 < 108.)
     //   if (lat180 > 72.)            
        {

            
            //float a = 0.3;

            

            fragColorR.rgb = rgb;
            //fragColorR.b = a;
            //fragColorR.g = a;

        }
}

// Function 391
float distanceToRect(vec3 rectExtents,vec3 rectCenter,vec3 point) {
	vec3 tPoint = point-rectCenter;
	return(length(max(abs(tPoint)-rectExtents,0.0)));
}

// Function 392
vec3 rayDirection(float fieldOfView, vec2 fragCoord) {
    vec2 xy = fragCoord - iResolution.xy / 2.0;
    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 393
float line_distance(vec2 p, vec2 p1, vec2 p2) {
    vec2 center = (p1 + p2) * 0.5;
    float len = length(p2 - p1);
    vec2 dir = (p2 - p1) / len;
    vec2 rel_p = p - center;
    return dot(rel_p, vec2(dir.y, -dir.x));
}

// Function 394
vec3 linearToScreen(vec3 linearRGB) {
    return gamma(linearRGB, 1.0 / GAMMA);
}

// Function 395
float line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}

// Function 396
float LineToPointDistance2D( vec2 a, vec2 b, vec2 p)
{
    vec2 pa = p - a;
    vec2 ba = b - a;

    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);

    return length( pa - ba*h );
}

// Function 397
float circle(vec2 coord, float spd)
{
    float reso = 12.0;
    float cw = iResolution.x / reso;

    vec2 p = mod(coord, cw);
    float d = distance(p, vec2(cw / 2.0));

    float rnd = dot(floor(coord / cw), vec2(1323.443, 1412.312));
    float t = iTime * 2.0 + fract(sin(rnd)) * 6.2;

    float l = cw * (sin(t * spd) * 0.25 + 0.25);
    return clamp(l - d, 0.0, 1.0);
}

// Function 398
vec4 pulseDraw(in vec2 coord, vec2 pixel, float time){
    time = mod(time, PULSE_TIMES);
    
    // Interface monitor
    if((mod(coord.x - .5, 1. / PULSE_STEP / SCALE_X / 5.) <= pixel.x
       || mod(coord.x - .5, 1. / PULSE_STEP / SCALE_X) <= pixel.x * 4.
       || mod(coord.x - .5, .5) <= pixel.x * 8.)
      &&
       (mod(coord.y - .5, 1. / PULSE_STEP / SCALE_Y / 5.) <= pixel.y
       || mod(coord.y - .5, 1. / PULSE_STEP / SCALE_Y) <= pixel.y * 4.
       || mod(coord.y - .5, .5) <= pixel.y * 8.
      )
	) return vec4(1, 1, 0, 1.0);
    
    float lx = time / PULSE_TIMES / SCALE_X;
    //if(abs(lx - coord.x + (coord.x * SCALE_X - .5) / 2.) < pixel.x)
    if(abs(lx - coord.x + .5 - .5 / SCALE_X) < pixel.x)
        return vec4(1, 1, 1, 1.0);
    
    // Draw pulse
    vec4 r = vec4(0, 0, 0, 1.0);
    
    // Pulse variables
    float x = time / PULSE_TIMES, y;// = PULSE_FUNC(x * PI * PULSE_STEP);
    float px = coord.x, py; // = PULSE_FUNC(coord.x * PI * PULSE_STEP);
    vec2 pv, sx, sy;
    
#ifdef PULSE_CALL_GREEN
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_GREEN);
        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_GREEN);
    }
#endif
    
#ifdef PULSE_CALL_BLUE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_BLUE);
        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_BLUE);
    }
#endif  

#ifdef PULSE_CALL_RED
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_RED);
        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_RED);
    }
#endif 
    
#ifdef PULSE_CALL_ORANGE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_ORANGE);
        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_ORANGE);
    }
#endif   
    
#ifdef PULSE_CALL_PURPLE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_PURPLE);
        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_PURPLE);
    }
#endif
   
    // Use shadow buffer
#ifdef PULSE_BUFFER
    if(r == vec4(0, 0, 0, 1.0)){
        // Get pixel color in buffer
    	vec3 buf = texture(iChannel0, vec2(getArrayPos(coord.x, coord.y), 0)).rgb; 
        return vec4(buf, 1);
    }
#endif
    
    return r;
}

// Function 399
vec4 closestPointsLines(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {
    vec2 ba = b - a, ca = c - a, dc = d - c;

    // Closest points are an intersection (this case can be ignored in 3D)
    float v = (ba.y * ca.x - ba.x * ca.y) / (dc.y * ba.x - dc.x * ba.y); // 2D cross products
    float u = (ca.x + dc.x * v) / ba.x;
    if (u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) return (a + ba * u).xyxy;

    // Closest points are caps and projections of the caps
    float baba = dot(ba, ba), dcdc = dot(dc, dc);

    vec4 pair = vec4(a, c + dc * clamp(dot(-ca, dc) / dcdc, 0.0, 1.0));
    vec2 diff = pair.zw - pair.xy;
    float comp = dot(diff, diff);

    update(b, c + dc * clamp(dot(b - c, dc) / dcdc, 0.0, 1.0), pair, comp);
    update(c, a + ba * clamp(dot(   ca, ba) / baba, 0.0, 1.0), pair, comp);
    update(d, a + ba * clamp(dot(d - a, ba) / baba, 0.0, 1.0), pair, comp);

    return pair;
}

// Function 400
float rect(vec2 uv,vec2 p, float w, float h, float b){
    
    uv += p;
    float rv = S(h, h + b, length(uv.x));
    float rh = S(w, w + b, length(uv.y));
    return rv + rh;
}

// Function 401
float thick_line_d(vec2 p, vec2 a, vec2 b, float r)
{
    vec2 pa = p - a, ba = b - a;
    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);
    return length(pa - i*ba)-r;
}

// Function 402
float aaa_hline( mat2 K, vec2 uv, vec2 x0, float w, float width )
{
    uv = uv - vec2( w / 2., 0 );
    return aaa_box( K, uv - x0, vec2( w, width ), vec2(0) );
}

// Function 403
vec2 gradient_circle(vec2 uv){
	return vec2(2.*uv.x,2.*uv.y);
}

// Function 404
vec3 getRectangleNormal(Ray r,Rectangle rec){
    vec3 normal=normalize(rec.plane.normal);
    if (dot(r.direction,rec.plane.normal)>T_MIN)
    {
    	return  -normal;
    }else
		return normal;
}

// Function 405
float line(vec2 p, vec2 a,vec2 b) { // draw line. https://www.shadertoy.com/view/llySRh
    p -= a, b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line
    return length(p - b * h);                         // dist to segment
}

// Function 406
float addCircles(vec2 uv)
{
    float diff = length(uv);
	float scale = 5.0;
    float func = exp(-abs(sin(scale * pi * diff)));
    return smoothstep(0.9, 0.95, func);
}

// Function 407
float smooth_circle_polar(float len, float r, float smoothness) {
    float dist = len - r;
    float s = smoothness / 2.0;
    return 1.0 - smoothstep(r - s, r + s, dist);
}

// Function 408
float dLine(float px, float py, float ax, float ay, float bx, float by){
    float bax = bx-ax;
    float bay = by-ay;
    float pax = px-ax;
    float pay = py-ay;
    float h = clamp((pax*bax + pay*bay)/(bax*bax + bay*bay), 0.0, 1.0);
    pax = pax - h*bax;
    pay = pay - h*bay;
    return sqrt(pax*pax + pay*pay);
}

// Function 409
float INcircle(vec2 p, float r)
{
    
    
 return 0.0;   
}

// Function 410
vec3 draw_distance(float d, vec2 p) {
  float t = clamp(d * 0.85, 0.0, 1.0);
  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);

  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);
  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);
  float d2 = abs(1.0 - draw_line(d).x);
  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));

  grad -= rim;
  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));

  return grad;
}

// Function 411
vec4 circle( in vec4 background, 
            in vec4 circleColor,
            in vec2 position,
            in float radius,
           in float thickness) {
  vec2 relative = vUV-position;
  float distance = length(relative);
  distance = smoothstep(distance-thickness/2., distance+thickness/2.,radius);
  
  vec4 outColor = mix( circleColor,background,distance);
  return outColor;
}

// Function 412
vec3 line4D(in vec3 p, vec4 p1, vec4 dp) {
    p1+=mv4D;
    //dp+=mv4D;
 	vec3 pa = p-p1.xyz, ba = dp.xyz;
    float k = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);
    return vec3(length(pa - ba*k) - RAYON ,k, p1.w +k*dp.w);
}

// Function 413
float dfLine(vec2 start, vec2 end, vec2 uv)
{   
	vec2 line = end - start;
	float frac = dot(uv - start,line) / dot(line,line);
	return distance(start + line * clamp(frac, 0.0, 1.0), uv);
}

// Function 414
void DrawTrees (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)
{
    // draw periodic trees
    vec2 treeOrigin;
    treeOrigin.x = floor(uv.x / c_treeDistance) * c_treeDistance + c_treeDistance * 0.5;
    treeOrigin.y = GroundHeightAtX(treeOrigin.x, scale);    
    
    float forceTop = 1.0;//RandomFloat(treeOrigin + vec2(0.342, 0.856)) > 0.75 ? 1.0 : 0.0;
    treeOrigin.y -= forceTop * (RandomFloat(treeOrigin + vec2(0.756, 0.564)) * c_treeMaxDepth);
    
    vec2 treeYAxis = -GroundFunctionGradiant(treeOrigin, scale);
    vec2 treeXAxis = vec2(treeYAxis.y, -treeYAxis.x);
    
    vec2 uvRelative = uv - treeOrigin;
    vec2 uvLocal;
    uvLocal.x = dot(uvRelative, treeXAxis);
    uvLocal.y = dot(uvRelative, treeYAxis);
    uvLocal /= scale;
    
    // draw a brown trunk
   	float dist = UDFatLineSegment(uvLocal, vec2(0.0, 0.0), vec2(0.0,0.15), 0.035);
   	dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
	pixelColor = mix(pixelColor, vec3(0.6, 0.3, 0.1) * tint, dist);
    
    // draw some green circles
    dist = 1.0;
    for (int i = 0; i < 5; ++i)
    {
       	vec3 circle;
        circle.x = 0.05 * (RandomFloat(treeOrigin + vec2(0.453, 0.923) * float(i)) * 2.0 - 1.0);
        circle.y = 0.08 + 0.2 * RandomFloat(treeOrigin + vec2(0.543, 0.132) * float(i));
        circle.z = 0.05 + 0.02 * RandomFloat(treeOrigin + vec2(0.132, 0.645) * float(i));
    	dist = min(dist, UDCircle(uvLocal, circle.xy, circle.z));  
    }    
    dist = 1.0 - smoothstep(0.0, AA_AMOUNT * 3.0, dist);
    pixelColor = mix(pixelColor, vec3(0.0,0.4,0.0) * tint, dist);       
}

// Function 415
vec4 drawYumetarou(in float x, in float y)
{
    if(x < YUMETAROU_X || x > YUMETAROU_X + 15.0) return TRANS;
    else if(y < YUMETAROU_Y || y > YUMETAROU_Y + 18.0) return TRANS;
    else
    {
        x -= YUMETAROU_X;
        y -= YUMETAROU_Y;

        // Yummy yummy frame counting.
        float t = mod(iTime, 3.67);
        if( t > .066 && (t < .533 || t >.600) )
            return yumetarouPalette(yumetarouEyesOpen(x,y));
        else
            return yumetarouPalette(yumetarouEyesClosed(x,y));
	}
}

// Function 416
vec2 onCircle() {
 	float r = float(rand())/float(0xffff) * 3.14195 * 2.;
    return vec2(sin(r), cos(r));
}

// Function 417
float line(vec2 P, vec2 A, vec2 B, float r)
{
  vec2 g = B - A;
  float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));
  return smoothstep(r, 0.5*r, d);
}

// Function 418
void DrawFireworks(vec2 p, float deadTime, float life, float id, vec3 ballColor, inout vec4 color)
{
    p += (hash(id*deadTime)*2.-1.)*0.15;
    float kind = hash(deadTime + id)*5.;
    if(kind < 1.0)
    {
    	DrawHeart(id, p, life, vec2(0.3, 1.75), ballColor, color);
    }
    else if(kind < 2.)
    {
    	DrawFountain(id, p, life, vec2(0.3, 1.75), ballColor, color);
    }
    else if(kind < 3.)
    {
    	DrawBigBall(id, p, life, vec2(0.3, 1.75), ballColor, color);
    }
    else if(kind < 4.)
    {
    	DrawPalmTree(id, p, life, vec2(0.3, 1.75), ballColor, color);
    }
    else
    {
    	DrawBigParts(id, p, life, vec2(0.3, 1.75), ballColor, color);
    }
}

// Function 419
vec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )
{
  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));
  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.01,0.0));
  
  return colOut;
}

// Function 420
void DrawWindow(inout vec4 ioFragColor, in vec2 inFragCoord, in vec2 inResolution, in int inID) 
{
	vec2 uv = inFragCoord / inResolution;
	if (inID == 0)
	{
		ioFragColor = vec4(uv, 0.5 + 0.5 * sin(iTime), 1.0);
	}
	else if (inID == 1)
	{
        ivec2 size = textureSize(iChannel0, 0);
		float lod = sqrt(float(size.x * size.y) / (inResolution.x * inResolution.y)) - 1.0;
		ioFragColor = textureLod(iChannel1, uv, lod);
	}
	else if (inID == 2)
	{
        ivec2 size = textureSize(iChannel1, 0);
		float lod = sqrt(float(size.x * size.y) / (inResolution.x * inResolution.y)) - 1.0;
		ioFragColor = textureLod(iChannel2, uv, lod);
	}
	else
	{
        ivec2 size = textureSize(iChannel1, 0);
		float lod = sqrt(float(size.x * size.y) / (inResolution.x * inResolution.y)) - 1.0;
		ioFragColor = textureLod(iChannel0, uv, lod);
	}
}

// Function 421
float sdCircle(vec2 p, float r, float t) {
    return abs(length(p) - r) - t;
}

// Function 422
bool PixelInsideCircle( vec2 fragCoord, vec3 circle, float distFromCenter )
{
    distFromCenter = distance(fragCoord.xy, circle.xy) - circle.z;
    return distFromCenter < 0.0;
}

// Function 423
vec3 getRayDirection(vec2 uv)
{
    vec2 mouseUV = getMouseUV();
    rayOrigin.yz *= rotation2d(mix(-PI/2.0, PI/2.0, mouseUV.y));
    rayOrigin.xz *= rotation2d(mix(-PI, PI, mouseUV.x));
    
    vec3 cameraForward = normalize(cameraTarget - rayOrigin);
    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));
    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));
    
    vec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraForward);
    return rayDirection;    
}

// Function 424
float sdTorusMedianCircle(const vec3 p, vec2 r, float inner_circle_scale) {
	vec2 q = vec2(MedianTriTorus_norm(vec2(p.x, p.z), r.x,inner_circle_scale), p.y);
	return MedianTriTorus_norm(q, r.y,inner_circle_scale);
}

// Function 425
vec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {
    // return current_colour;
    p += sin(iTime/1.2)*4.0*vec2(get_noise(p.xy), get_noise(p.yx));
    p1 += 5.0*vec2(get_noise(p.xy), get_noise(p.yx));
    p2 -= 5.0*vec2(get_noise(p.xy), get_noise(p.yx));
    float d = distance_to_line(p, p1, p2);
    float noise;
    // TODO (01 May 2020 sam): Figure out how to to better line check
    if (p1.y<p.y) noise = get_noise(p.yx);
    else noise = get_noise(p);
    d += noise*line_variation;
    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);
    return mix(pencil_colour, current_colour, pencil);
}

// Function 426
vec3 LinearSample(vec2 uv, vec3 CN, out vec3 Moments) {
    //*
    float c0,c1,c2,c3; vec3 m0,m1,m2,m3;
    vec2 fuv=floor(uv*HRES-0.499)+0.5;
    vec3 C0=LinearSample0(fuv*IRES,c0,m0,CN);
    vec3 C1=LinearSample0((fuv+vec2(1.,0.))*IRES,c1,m1,CN);
    vec3 C2=LinearSample0((fuv+vec2(0.,1.))*IRES,c2,m2,CN);
    vec3 C3=LinearSample0((fuv+vec2(1.))*IRES,c3,m3,CN);
    vec2 fruv=fract(uv*HRES-0.499);
    float mc=mix(mix(c0,c1,fruv.x),mix(c2,c3,fruv.x),fruv.y)+0.02;
    Moments=mix(mix(m0,m1,fruv.x),mix(m2,m3,fruv.x),fruv.y)/mc;
    return mix(mix(C0,C1,fruv.x),mix(C2,C3,fruv.x),fruv.y)/mc;
    //*/
    /*
    vec2 fuv=floor(uv*HRES-0.499)+0.5; float c0;
    vec3 C0=LinearSample0(fuv*IRES,c0,Moments,CN);
    return C0/c0; //*/
}

// Function 427
float NewtonSpline(Spline s, FactorsOfP fp, vec3 p, float t )
{
	//iterate newton's method:
	for (int n=0; n<2; n++)
	{
		t -= DistanceSqFirstDeriv(s,fp,p,t) / DistanceSqSecondDeriv(s,fp,p,t);
	}

	return t;
}

// Function 428
float circleMask(vec2 uv,float y, float i1, float i2)
{
    float r1=.45;
    float r2=.45;
    r1*=i1;
    r2*=i2;
    return circle(uv+vec2(0,y-1.),r1)+circle(uv+vec2(0,y),r2);
}

// Function 429
conic_t circle() {
    return newconic(1.0, 1.0, 0.0, 0.0, 0.0, -1.0);
}

// Function 430
void UI_DrawColorPickerH( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))
        return;
    
    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;
    vec3 vHSVCurr = vHSV;
    vHSVCurr.x = vCurrPixelPos.y;
    vHSVCurr.yz = vec2(1.0, 1.0);
    
    float fSelectedPos = vHSV.x * pickerRect.vSize.y + pickerRect.vPos.y;

	uiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );
        
    float l = length( fSelectedPos - uiContext.vPixelCanvasPos.y );
    float d = l - 1.0;
    d = min(d, 5.0 - l);
    if ( bActive )
    {
        float d2 = l - 4.0;
    	d2 = min(d2, 6.0 - l);
	    d = max(d, d2);
    }
    
    float fBlend = clamp(d, 0.0, 1.0);
    
    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(0.5), fBlend);    
}

// Function 431
float circleLine(vec2 uv, vec2 center, float radius, float width) {
    float r = length(uv - center);
    return smoothFloat(r-width/2.0,radius) - smoothFloat(r+width/2.0,radius);
}

// Function 432
float line(in int lineWidth, in vec2 pos, in vec2 point, in vec3 iResolution) {
    float normalizedLineRadius = (float(lineWidth) / iResolution.y) / 2.;
    float edgeWidth = 1. / iResolution.y;
    if(normalizedLineRadius<1./iResolution.x)
        return 0.;
	return smoothstep(pos.y-normalizedLineRadius,pos.y-edgeWidth,point.y-normalizedLineRadius+edgeWidth) * 
        (1.-smoothstep(pos.y+normalizedLineRadius-edgeWidth, pos.y+normalizedLineRadius+edgeWidth, point.y));
}

// Function 433
float Linear_from_ACEScct(float cct)
{
    if(cct > 0.155251141552511)
        return exp2(cct * 17.52 - 9.72);
    
	return cct / 10.5402377416545 - (0.0729055341958355/10.5402377416545);
}

// Function 434
vec4 draw_sprite(vec2 frag_coord, ivec2 tile_id, mat3 trans_mat) {
    vec2 uv = (inverse(trans_mat) * vec3(frag_coord, 1.0)).xy;
    return fetch_sprite(tile_id, uv);
}

// Function 435
float pulseCircle(vec2 p, float r)
{
    float l = length(p) - r;
    return smoothstep(2.5,3.0,2.*sin(3.5/l + 6.*iTime) + 0.2/l);
}

// Function 436
vec4 SampleBilinear (in vec2 adjustedFragCoord)
{
    adjustedFragCoord-= 0.5;
    vec2 fragFract = fract(adjustedFragCoord);
    
    // get the four data points
    vec2 uvMin = adjustedFragCoord / iResolution.xy;
    vec2 uvMax = (adjustedFragCoord + vec2(1.0)) / iResolution.xy;
    vec4 data00 = texture(iChannel0, uvMin);
    vec4 data10 = texture(iChannel0, vec2(uvMax.x, uvMin.y));
    vec4 data01 = texture(iChannel0, vec2(uvMin.x, uvMax.y));
    vec4 data11 = texture(iChannel0, uvMax);
    
    // bilinear interpolate
    vec4 datax0 = mix(data00, data10, fragFract.x);
    vec4 datax1 = mix(data01, data11, fragFract.x);
    return mix(datax0, datax1, fragFract.y);
}

// Function 437
float line_segment_sdf(vec2 a, vec2 b, vec2 p)
{
    vec2 ab = b-a;
    vec2 ap = p-a;
    float l = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);
    return distance(a + l * ab, p);
}

// Function 438
int drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )
{
    // Create a place to store the current values.
    int res = 0;
    // Surely it won't be more than 10 chars long, will it?
    // (MAX_INT is 10 characters)
    for( int i = 0; i < 10; ++i )
    {
        // If we've run out of film, cut!
        if(val == 0 && i >= places) break;
        // The current lsd is the difference between the current
        // value and the value rounded down one place.
        int digit = val % 10;
        // Draw the character. Since there are no overlaps, we don't
        // need max().
        res |= drawChar(CH_0+digit,pos,size,uv);
        // Move the carriage.
        pos.x -= size.x*1.2;
        // Truncate away this most recent digit.
        val /= 10;
    }
    return res;
}

// Function 439
vec2 VoronoiCircles (in vec2 coord, float freq, float time, float radiusScale)
{
    const int radius = 1;
    
    vec2 point = coord * freq;
    vec2 ipoint = floor( point );
    vec2 fpoint = fract( point );
    
    vec2 center = fpoint;
    vec2 icenter = vec2(0);
    
    float md = 2147483647.0;
	float mr = 2147483647.0;
    
	// find nearest circle
	for (int y = -radius; y <= radius; ++y)
	for (int x = -radius; x <= radius; ++x)
	{
        vec2 cur = vec2(x, y);
		vec2 c = CenterOfVoronoiCell( vec2(cur), ipoint, time );
		float d = dot( c - fpoint, c - fpoint );

		if ( d < md )
		{
			md = d;
			center = c;
			icenter = cur;
		}
	}
    
	// calc circle radius
	for (int y = -radius; y <= radius; ++y)
	for (int x = -radius; x <= radius; ++x)
	{
        if ( x == 0 && y == 0 )
            continue;
        
        vec2 cur = icenter + vec2(x, y);
		vec2 c = CenterOfVoronoiCell( vec2(cur), ipoint, time );
		float d = dot( c - fpoint, c - fpoint );
		
		if ( d < mr )
			mr = d;
	}
    
    md = sqrt( md );
	mr = sqrt( mr ) * 0.5 * radiusScale;
    
	if ( md < mr )
		return vec2( md / mr, ValueOfVoronoiCell( icenter + ipoint ) );

	return vec2( 0.0, -2.0 );
}

// Function 440
vec2 FindNearestPointOnLine(vec2 origin, vec2 end, vec2 point)
{
    //Get heading
    vec2 heading = (end - origin);
    float magnitudeMax = length(heading);
    heading = normalize(heading);

    //Do projection from the point but clamp it
    vec2 lhs = point - origin;
    float dotP = dot(lhs, heading);
    dotP = clamp(dotP, 0.0f, magnitudeMax);
    return origin + heading * dotP;
}

// Function 441
bool drawCircle(inout vec3 v,vec2 uv, vec2 pt, vec2 ofs, float r, float R, float a, int mode)
{
	vec2 newUV = pt - uv;
		
	float d = (mod2(mode)==0) ? length(newUV)/R 
		                : max(abs(newUV.x),abs(newUV.y))/R ;
	if ((d<1.)&&(d>r/R)) {
		vec3 noiseT = hashRGB(rot(a)*(newUV-ofs));
#if 1
		v = noiseT;
#else
		mode /= 2;
	    if (mode==0) v.rg = noiseT.rg; 
	    if (mode==1) v.gb = noiseT.gb; 
	    if (mode==2) v.br = noiseT.br; 
#endif
	    return true;
	}
	return false;
}

// Function 442
bool circle(vec2 uv) {
    return length(uv - 0.5) <= 0.5;
}

// Function 443
float circle(vec2 origin,float radius){
        return(smoothstep(radius,0.0,length(origin)));
}

// Function 444
float dXLine(float px, float py, float l){
    px -= min(l, max(-l, px));
    return sqrt(px*px + py*py);
}

// Function 445
void RLineTo(float2 p)
{
    p=CP+TS(p)-Pp0;
    l=min(l,Draw(CP,p,uv));
    CP=p;
}

// Function 446
vec3 colorCorrect( in vec3 rgb, in vec2 px )
{
    // grade
    rgb = clamp( (rgb-0.1)*vec3(1.5,1.7,1.5)*1.1, 0.0, 1.0 );

	// vigneting
    float v = px.x/iResolution.x;
	rgb *= 0.5 + 2.0*v*(1.0-v);
    
    return rgb;
}

// Function 447
float draw_trail(vec2 world_coords, ship_t ship) {
    if (!ship.flame) {
        return 1.0;
    }
    vec2 ship_world_coords = ship.position.xy;
    
    float point_direction = ship.position.z;
    float c = cos(point_direction);
    float s = sin(point_direction);
    
    vec2 flame_position = ship_world_coords + vec2(s*0.1, -c*0.1);
    
    float dist = length(world_coords - flame_position);
    return dist * 0.1;
}

// Function 448
float Rectangle( vec2 p, vec2 b )
{
    vec2 d = abs( p ) - b;
    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );
}

// Function 449
float segmented_spline_c9_fwd( float x )
{
	// ODT_48nits
	SegmentedSplineParams_c9 C;
    C.coefsLow[0] = -1.6989700043; C.coefsLow[1] = -1.6989700043; C.coefsLow[2] = -1.4779000000;
    C.coefsLow[3] = -1.2291000000; C.coefsLow[4] = -0.8648000000; C.coefsLow[5] = -0.4480000000;
    C.coefsLow[6] = 0.0051800000; C.coefsLow[7] = 0.4511080334; C.coefsLow[8] = 0.9113744414;
    C.coefsLow[9] = 0.9113744414;
    
    C.coefsHigh[0] = 0.5154386965; C.coefsHigh[1] = 0.8470437783; C.coefsHigh[2] = 1.1358000000;
    C.coefsHigh[3] = 1.3802000000; C.coefsHigh[4] = 1.5197000000; C.coefsHigh[5] = 1.5985000000;
    C.coefsHigh[6] = 1.6467000000; C.coefsHigh[7] = 1.6746091357; C.coefsHigh[8] = 1.6878733390;
    C.coefsHigh[9] = 1.6878733390;
    
    C.minPoint = vec2(segmented_spline_c5_fwd( 0.18*exp2(-6.5) ),  0.02);
	C.midPoint = vec2(segmented_spline_c5_fwd( 0.18 ),             4.8);
	C.maxPoint = vec2(segmented_spline_c5_fwd( 0.18*exp2(6.5) ),   48.0);
	C.slopeLow = 0.0;
	C.slopeHigh = 0.04;


	const int N_KNOTS_LOW = 8;
	const int N_KNOTS_HIGH = 8;

	// Check for negatives or zero before taking the log. If negative or zero,
	// set to OCESMIN.
	float xCheck = x <= 0.0 ? 1e-4 : x;

	float logx = log10(xCheck);

	float logy;

	if ( logx <= log10(C.minPoint.x) )
	{
		logy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );
	}
	else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) ))
	{
		float knot_coord = float(N_KNOTS_LOW-1) * (logx-log10(C.minPoint.x))/(log10(C.midPoint.x)-log10(C.minPoint.x));
		int j = int(knot_coord);
		float t = knot_coord - float(j);

        // can't index on non-const value...
		//vec3 cf = vec3(C.coefsLow[j], C.coefsLow[j + 1], C.coefsLow[j + 2]);
        vec3 cf = vec3(C.coefsLow[0], C.coefsLow[1], C.coefsLow[2]);
        if (j == 1)
            cf = vec3(C.coefsLow[1], C.coefsLow[2], C.coefsLow[3]);
        else if (j == 2)
            cf = vec3(C.coefsLow[2], C.coefsLow[3], C.coefsLow[4]);
        else if (j == 3)
            cf = vec3(C.coefsLow[3], C.coefsLow[4], C.coefsLow[5]);    
        else if (j == 4)
            cf = vec3(C.coefsLow[4], C.coefsLow[5], C.coefsLow[6]);    
        else if (j == 5)
            cf = vec3(C.coefsLow[5], C.coefsLow[6], C.coefsLow[7]);    
        else if (j == 6)
            cf = vec3(C.coefsLow[6], C.coefsLow[7], C.coefsLow[8]);    
        else if (j == 7)
            cf = vec3(C.coefsLow[7], C.coefsLow[8], C.coefsLow[9]);    
            
		vec3 monomials = vec3(t * t, t, 1.);
		logy = dot( monomials, (M * cf) );
	}
	else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) ))
	{
		float knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x)-log10(C.midPoint.x));
		int j = int(knot_coord);
		float t = knot_coord - float(j);

        // can't index on non-const value...
		//vec3 cf = vec3(C.coefsHigh[ j], C.coefsHigh[ j + 1], C.coefsHigh[ j + 2]); 
        vec3 cf = vec3(C.coefsHigh[0], C.coefsHigh[1], C.coefsHigh[2]);
        if (j == 1)
            cf = vec3(C.coefsHigh[1], C.coefsHigh[2], C.coefsHigh[3]);
        else if (j == 2)
            cf = vec3(C.coefsHigh[2], C.coefsHigh[3], C.coefsHigh[4]);
        else if (j == 3)
            cf = vec3(C.coefsHigh[3], C.coefsHigh[4], C.coefsHigh[5]);    
        else if (j == 4)
            cf = vec3(C.coefsHigh[4], C.coefsHigh[5], C.coefsHigh[6]);    
        else if (j == 5)
            cf = vec3(C.coefsHigh[5], C.coefsHigh[6], C.coefsHigh[7]);    
        else if (j == 6)
            cf = vec3(C.coefsHigh[6], C.coefsHigh[7], C.coefsHigh[8]);    
        else if (j == 7)
            cf = vec3(C.coefsHigh[7], C.coefsHigh[8], C.coefsHigh[9]);    
            
		vec3 monomials = vec3(t * t, t, 1.);
		logy = dot( monomials, (M * cf) );
	}
	else //if ( logIn >= log10(C.maxPoint.x) )
	{ 
		logy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );
	}

	return pow(10.0, logy);  
}

// Function 450
float drawFloat(inout vec2 p,v0 v)      {return drawFloat(p,v,2,5);}

// Function 451
float OLcircle(vec2 p, float r, float th)
{
   float ss = 0.009;
   float spc = 0.1;
   float c = length(p);
    //I flipped the - and + in both ss and th parts to avoid having to 
    //do a 1.0-... later on.
   return smoothstep(spc+ss, spc-ss, c) 
       + (smoothstep(r+ss, r-ss, c) 
          - smoothstep(th+ss, th-ss, c));  
}

// Function 452
vec4 drawLock( vec2 uv, int color ) {
    uv = floor(fract(uv)*64.) - 32.;
    if( abs(uv.x) < 6. && abs(uv.y) < 8. ) {
        float l = 1.;
        l -= smoothstep( 3., 2., length(uv+vec2(0,2.5)));
        l = min( l, 1.-step(abs(uv.x),.5)*step(abs(uv.y), 5.));
	    vec3 col = vec3(0);
    	col[color-3] = 1.;
        return vec4( l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, 1 );
    } else {
        return vec4(0);
    }
}

// Function 453
float drawElders(vec2 uv) {
    float n = 3.;
    float a = TAU/n;
    float color=0.;
    for (float i = 0.;i<n*2.;i++) {
    	vec2 xy = rotate(uv,a*i);
        xy.y -= 0.2;
        float vsc = vesicaSDF(xy,.6);
        color = mix(
            color+stroke(vsc,.5,.1),
            mix(color, bridge(color,vsc,.5,.1),step(xy.x,0.0)-step(xy.y,.0)),
            step(3.,i)
            );
    }
    return color;
}

// Function 454
float distToLine(vec2 A, vec2 B, vec2 p){
    
    vec2 PA = p - A;
    vec2 BA = B - A;
    float d = dot(PA,BA);
    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt
    vec2 normal = PA - BA*t;
    return length(normal);
}

// Function 455
float RayCircleIntersect( vec2 vRayOrigin, vec2 vRayDir, vec2 vCircleOrigin, float fRadius2 )
{
    vec2 vRayOriginToCircleOrigin = vCircleOrigin - vRayOrigin;
    float fProjection = dot( vRayOriginToCircleOrigin, vRayDir );        
    vec2 vClosestPos = vRayOrigin + vRayDir * fProjection;
    vec2 vClosestToCircle = vCircleOrigin - vClosestPos;
    float fClosestDist2 = dot( vClosestToCircle, vClosestToCircle );
    if ( fClosestDist2 < fRadius2 )
    {
        float fHalfChordLength = sqrt( fRadius2 - fClosestDist2 );
        float fHitT = fProjection - fHalfChordLength;

        return fHitT;
	}

    return -1.0;
}

// Function 456
float IsGridLine(vec2 fragCoord)
{
	// Define the size we want each grid square in pixels
	vec2 vPixelsPerGridSquare = vec2(16.0, 16.0);
	
	// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel
	vec2 vScreenPixelCoordinate = fragCoord.xy;
	
	// Get a value in the range 0->1 based on where we are in each grid square
	// fract() returns the fractional part of the value and throws away the whole number part
	// This helpfully wraps numbers around in the 0->1 range
	vec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);
	
	// Convert the 0->1 co-ordinates of where we are within the grid square
	// back into pixel co-ordinates within the grid square 
	vec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;

	// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise
	// so we get 1.0 if we are on a grid line, 0.0 otherwise
	vec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));
	
	// Combine the x and y gridlines by taking the maximum of the two values
	float fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);

	// return the result
	return fIsGridLine;
}

// Function 457
vec4 draw_gun_explosion( int frame, ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), gun_exp_dim ) ) {
        int x = iu.x, y = iu.y ;
        frame &= 1 ;
        PREPARE_TEST_BIT ;
        if( frame == 0 ) {
            BR16(7,   _,_,_,w,_,_,_,_,_,_,_,_,_,w,_,_  ) ;
            BR16(6,   w,_,_,_,_,_,w,_,_,_,_,w,w,_,_,w  ) ;
            BR16(5,   _,_,_,w,_,_,_,_,w,w,_,_,_,_,_,_  ) ;
            BR16(4,   _,_,_,_,_,_,w,_,_,_,_,_,_,_,w,_  ) ;
            BR16(3,   _,w,_,_,w,_,w,w,_,_,w,w,_,_,_,w  ) ;
            BR16(2,   _,_,w,_,_,_,_,w,w,w,_,_,_,w,_,_  ) ;
            BR16(1,   _,_,_,w,w,w,w,w,w,w,w,w,_,_,_,_  ) ;
            BR16(0,   _,_,w,w,_,w,w,w,w,w,w,w,_,_,w,_  ) ;
        } else if( frame == 1 ) {
            BR16(7,   _,_,_,_,_,_,w,_,_,_,_,_,_,_,_,_  ) ;
            BR16(6,   _,_,_,_,_,_,_,_,_,_,_,w,_,_,_,_  ) ;
            BR16(5,   _,_,_,_,_,_,_,_,_,_,w,_,_,_,_,_  ) ;
            BR16(4,   _,_,_,w,_,_,_,_,_,_,_,_,_,_,_,_  ) ;
            BR16(3,   _,_,_,_,_,_,_,_,w,_,w,w,_,_,_,_  ) ;
            BR16(2,   _,w,_,_,_,_,_,_,_,_,w,_,w,_,_,_  ) ;
            BR16(1,   _,_,_,_,w,_,_,_,w,w,w,_,_,w,_,_  ) ;
            BR16(0,   _,_,w,w,_,w,_,w,_,w,w,w,_,w,_,w  ) ;
        }
    }
    return( vec4( v, 1 ) ) ;
}

// Function 458
float circleOpacity(vec2 uv, float pixelSize, float innerRadius, vec2 angleUnit){
	vec2 relToCenter = (uv - vec2(0.5,0.5))*2.0;
	float distSquared = dot(relToCenter,relToCenter);
	float fringeSpan = 2.8*pixelSize;
	float halfFringeSpan = fringeSpan/2.0;
	float outerInnerEdge = sq(1.0 - halfFringeSpan); 
    float innerFade = (max(distSquared, sq(fringeSpan)) - sq(innerRadius - halfFringeSpan))/(sq(innerRadius + halfFringeSpan) - sq(innerRadius - halfFringeSpan));
    float outerFade =  1.0 - (distSquared - outerInnerEdge)/((1.0 + halfFringeSpan) - outerInnerEdge);
    float angleFade;
    float distFromAngleUnit = 1.0 - dot(orthoCloc(relToCenter),angleUnit)/fringeSpan;
    float distFromXAxis = (relToCenter.y + fringeSpan)/fringeSpan;
    if(angleUnit.y > 0.0){
        angleFade = min(distFromAngleUnit, distFromXAxis);
    }else{
        angleFade = max(distFromAngleUnit, distFromXAxis);
    }
	return clampUnit(min(min(innerFade, outerFade), angleFade));
}

// Function 459
float drawSphere(in vec3 p){
    
    p = fract(p)-.5;    
    return dot(p, p);
    
    p = abs(fract(p)-.5);
    return dot(p, vec3(.166));
    
}

// Function 460
vec3 rect(vec3 color, vec2 uv, vec2 bl, vec2 tr)
{
    float res = 1.;
    
    // Bottom left.
    bl = step(bl, uv);  // if arg2 > arg1 then 1 else 0
    res = bl.x * bl.y;  // similar to logic AND
    
    // Top right.
    tr = step(SHIFT - tr, SHIFT - uv);
    res *= tr.x * tr.y;
    
    return res * color;
}

// Function 461
vec2 Support_Line (vec2 a, vec2 b, vec2 dir)
{
    return Operation_Max(a,b,dir);
}

// Function 462
uint direct_24( in vec3 nor )
{
    nor /= max(max(abs(nor.x),abs(nor.y)),abs(nor.z));

    vec3 v = 0.5 + 0.5*nor;
    uvec3 d = uvec3(round(v*255.0));
    return d.x|(d.y<<8u)|(d.z<<16u);
}

// Function 463
float SOLcircle(vec2 p, float r)
{
// returns white when length is = or less than r  
 return  step(length(p), r);  
}

// Function 464
void DrawRadial(inout vec3 color, vec2 p, in AppState s)
{
    p -= vec2(-164, 73);
    
	// radial
    float c2 = Capsule(p - vec2(0., 1.), 3., 8.5);
    float c1 = Circle(p + vec2(0., 7. - 8. * (2. - s.menuId)), 2.5);
    
    color = mix(color, vec3(0.9), Smooth(-c2 * 2.));
	color = mix(color, vec3(0.3), Smooth(-c1 * 2.));    
}

// Function 465
vec3 SRGBToLinear(vec3 rgb)
{   
    rgb = clamp(rgb, 0.0f, 1.0f);
    
    return mix(
        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),
        rgb / 12.92f,
        LessThan(rgb, 0.04045f)
	);
}

// Function 466
vec2 randCircleSpline(vec2 p, float t) {

    // standard catmull-rom spline implementation
    float t1 = floor(t);
    t -= t1;
    
    vec2 pa = randCircle(vec3(p, t1-1.0));
    vec2 p0 = randCircle(vec3(p, t1));
    vec2 p1 = randCircle(vec3(p, t1+1.0));
    vec2 pb = randCircle(vec3(p, t1+2.0));
    
    vec2 m0 = 0.5*(p1 - pa);
    vec2 m1 = 0.5*(pb - p0);
    
    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;
    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;
    vec2 c1 = m0;
    vec2 c0 = p0;
    
    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;
    
}

// Function 467
vec3 RectLight_shade(in RectLight light, in Material material, in vec3 P, in vec3 N, in vec3 R, float NoR)
{
    // Schlick Fresnel.
    float Fr = material.F0 + (1.0-material.F0) * pow(1.0 - NoR, 5.0);
    
    // Approximate specular/glossy.
    float theta = mix(PI*0.003, PI/2.0/3.0, material.roughness);
    float Cs = RectLight_calcWeight(P, R, light, theta);
    // Specular glossy tail. Using other than Gaussian could help. 
    float Cst = RectLight_calcWeight(P, R, light, material.tailtheta);
    
    // Crude hack for diffuse.
    // Average normal and inversed emitter direction to create
    // a vector W that points towards the light.
    vec3 W = normalize(N - light.basis[2]);
    float Cd = RectLight_calcWeight(P, W, light, PI/4.0);
	
    return light.intensity * mix(
        (Cd * max(dot(N, W), 0.0)) * material.basecolor,
        (mix(Cs, Cst, material.tailamount) * NoR) * material.specularcolor,
        Fr);
}

// Function 468
vec3 gamma_to_linear(vec3 c)
{
	return pow(clamp(c, 0.0, 1.0), vGammaPowerInverse);
}

// Function 469
vec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )
{colOut = mix(colOut,pColObj ,S2( distObj,0.0));
  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));
  return colOut;
}

// Function 470
float draw_int(vec2 p, int number){
    return draw_uint_with_sign(p, number, number < 0);
}

// Function 471
float Rectangle (vec2 uv, float blur, float left, float right, float bottom, float top) {
    float r;
    r = Band(uv.x, left, right, blur);
    r *= Band(uv.y, bottom, top, blur);
    return r;
}

// Function 472
vec3 GammaCorrect(vec3 color)
{
    vec3 corrected = pow(color, vec3(1.0 / 2.2));
    return TimeLerp(color, corrected, TIME_3DExtrude, TIME_Lighting);   // Dont apply gamma correct to 2D view
}

// Function 473
void drawUI(inout vec3 color, vec2 p, AppState s)
{
    p *= R.y / R.x; // ratio and resolution indepenent scaling
    p *= 1.75;
    
    // splash screen   
    if ( s.stateID == GS_SPLASH )
    {
        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg
		vec2 p2 = p;
		p2 *= 50.;
		p2 -= vec2( -45, 27. );
        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide
        
        float maskTitle = titleText( p2 ); // Moonset Drive Unlimited
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );
        
		vec2 p1 = p;
		p1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );
		p1 -= vec2( -47., -42. );
        float maskSpace = spaceText( p1 ); // press [space] to start
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );

		vec2 p3 = p;
		p3 *= 60.;
		p3 -= vec2( -30, 25. );
        float maskHs = highscoreText( p3 ); // Highscore
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );

		vec2 pScore = p;
        pScore *= 12.0;
        pScore -= vec2( 1.3, 5.3 );
        float sScore = printInt( pScore, s.highscore );
        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );
    }
    else
    {
        vec2 pScore = p;
        pScore *= 6.0;
        pScore -= vec2( -0.9, 3.4 );
        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );
        pScore.x += 0.5 * maxDigits;
        float sScore = printInt( pScore, s.score );
        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );
    }

	// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide
    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide
}

// Function 474
float gasketRect(vec2 p, vec2 center, vec2 size){
    vec2 hs = size / 2.;
    p -= center;
    vec2 z = (p / hs) * 1.;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
	vec2 a1 = vec2(0,1);
	vec2 a2 = vec2(-1,-1);
	vec2 a3 = vec2(1,-1);
	vec2 c;
	float dist, d;
    float Scale = 2.;
    const int maxN = 8;
	for (int n = 0 ; n < maxN ; n++) {
		 c = a1; dist = length(z-a1);
	     d = length(z-a2); if (d < dist) { c = a2; dist=d; }
		 d = length(z-a3); if (d < dist) { c = a3; dist=d; }
		z = Scale*z-c*(Scale-1.0);
	}

	return length(z) * pow(Scale, -float(maxN)) - 0.01;
}

// Function 475
vec3 drawPoint(vec3 bgcol, vec3 drawCol, float r, vec2 p, vec2 c) {
    //#define pointCol vec3(1,0,0)
    
    r /= 1.*iResolution.y;	// pixels to screen
    
    #ifdef filledLines
    	float amount = lsqr(p - c) <= r*r ? 1. : 0. ;
    #else
    	float amount = smoothstep(r*r, 0., lsqr(p - c));//max(0., r - length(p - c)) / r;
    #endif
    
    return mix(bgcol, drawCol, amount);
}

// Function 476
float drawInt(int value) {return drawInt(value,1);}

// Function 477
void DrawVoxel(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in ivec2 c, in vec2 R) {
    if(voxel.type == VOXEL_TYPE_DUST) {
    	DrawVoxelDust(O,voxel,z,p,c,R);
    } else {
    	DrawVoxelNotDust(O,voxel,z,p,R);
    }
}

// Function 478
float drawInt(int value, int minDigits)
{
  float c = 0.;
  if (value < 0) 
  { value = -value;
    if (minDigits < 1) minDigits = 1;
    else minDigits--;
    _sub                   // add minus char
  } 
  int fn = value, digits = 1; // get number of digits 
  for (int ni=0; ni<10; ni++)
  {
    fn /= 10;
    if (fn == 0) break;
    digits++;
  } 
  digits = max2(minDigits, digits);
  tp.x -= FONT_SPACE * float(digits);
  for (int ni=1; ni < 11; ni++) 
  { 
    tp.x += FONT_SPACE; // space
    c += char(48 + (value-((value/=10)*10))); // add 0..9 
    if (ni >= digits) break;
  } 
  tp.x -= FONT_SPACE * float(digits);
  return c;
}

// Function 479
void drawLowBush(int x, int y)
{
	if (y < 0 || y > 3 || x < 0 || x > 15) {
		return;
	}
	
	float col = 0.0; // 0 = transparent

	if (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  2) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,2.,2.,2., 2.,2.,2.,1.,1.,0.,0.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,1.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,1.,0.,0.);
	
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(87,201,111);
	}
	else if (col == 2.0) {
		fragColor = RGB(100,224,117);
	}
}

// Function 480
float DrawCircle(in vec2 uv, float radius){
    return abs(length(uv)-radius) < 0.01 ? 1. : 0.;
}

// Function 481
float lineGroundIntersection(Line line)
{
    float t = -line.point.y / line.direction.y;
    return t;
}

// Function 482
vec4 drawCellExplosionVoid(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteExplosionVoid(state.y);
    return sampleSprite(sprite, colors, coord);
}

// Function 483
float pointDistanceToLine(vec2 point, vec2 vert1, vec2 vert2){
    float top = abs((vert2.y-vert1.y)*point.x-(vert2.x-vert1.x)*point.y+vert2.x*vert1.y-vert2.y*vert1.x);
    float bottom = distance(vert1,vert2);
    return top/bottom;
}

// Function 484
float circle_d(vec2 uv, vec2 center, float radius)
{
	return length(uv - center) - radius;
}

// Function 485
float circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }

// Function 486
float circle(vec2 p, vec3 c) {
    float d = abs(length(p-c.xy)-c.z);
    return smoothstep(0.0,0.01,d);
}

// Function 487
vec3 drawCircle(vec2 c, float r, vec2 p, in vec3 bg, in vec3 fg) {
    float dist = length(p - c) - r;
    return edgeToMix(dist, bg, fg);
}

// Function 488
void UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))
        return;
    
    uiContext.vWindowOutColor = vec4(1.0);
    
    if ( bActive && bMouseOver )
    {
        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);
    }

    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );

    Rect smallerRect = checkBoxRect;
    RectShrink( smallerRect, vec2(6.0));

    if ( bChecked )
    {
        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );
    }
}

// Function 489
vec3 directLight(vec3 pos, vec3 normal){
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 490
vec3 randomSphereDirection () {
    vec2 r = vec2 (rand () * 6.2831, rand() * 6.2831);
	vec3 dr = vec3 (sin (r.x) * vec2 (sin (r.y), cos (r.y)), cos (r.x));
	return dr;
}

// Function 491
void color_correction(inout vec4 fragColor, vec2 fragCoord, bool is_thumbnail)
{
    if (g_demo_stage != DEMO_STAGE_NORMALS)
    {
        Options options;
        LOAD(options);
    	
        float gamma = is_thumbnail ? .8 : 1. - options.brightness * .05;
#if GAMMA_MODE
    	fragColor.rgb = gamma_to_linear(fragColor.rgb);
    	float luma = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));
    	if (luma > 0.)
	    	fragColor.rgb *= pow(luma, gamma) / luma;
	    fragColor.rgb = linear_to_gamma(fragColor.rgb);
#else
	    fragColor.rgb = pow(fragColor.rgb, vec3(gamma));
#endif
    }
    
    // dithering, for smooth depth/lighting visualisation (when not quantized!)
    fragColor.rgb += (BLUE_NOISE(fragCoord).rgb - .5) * (1./127.5);
}

// Function 492
vec4 rectangle(vec2 uv, vec2 pos, float width, float height, vec3 color) {
	float t = 0.0;
    if ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)
		&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {
		t = 1.0;
	}
	return vec4(color, t);
}

// Function 493
vec3 UVToEquirectCoord(float U, float V, float MinCos)
{
    float Phi = kPi - V * kPi;
    float Theta = U * 2.0 * kPi;
    vec3 Dir = vec3(cos(Theta), 0.0, sin(Theta));
	Dir.y   = clamp(cos(Phi), MinCos, 1.0);
	Dir.xz *= Sqrt(1.0 - Dir.y * Dir.y);
    return Dir;
}

// Function 494
float drawSegment(v1 A,v1 B, float r){vec2 g=B-A,h=uv-A;
// float d=length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));
// return smoothstep(r, 0.5*r, d);}

// Function 495
vec3 drawPlayer( vec3 col, in vec2 fragCoord, float player, in vec4 playerPosDir, bool dead )
{
    vec2 off = dir2dis(playerPosDir.w);    
    vec2 mPlayerPos = playerPosDir.xy + off*playerPosDir.z;

    vec2 uv = fragCoord.xy /iResolution.xy;
    float xCells = txCells.w*(iResolution.x / iResolution.y);
    vec2 p = uv-vec2(0.5-txCells.z/(xCells*2.), 0.); // center
    p.x *= iResolution.x / iResolution.y;
    
    vec2 q = p - cell2ndc( mPlayerPos );

    float c = sdCircle(q, 0.023);

    vec3 color = mix(p1Color, p2Color, player - 1.);
    
    float phase = 0.5+0.5*sin(2.0*6.2831*iTime);
    if (dead) color = mix(color, vec3(1., 0., 0.), phase);
    col += 0.1*color*exp((-100.0 - (dead ? 50.*phase : 0.))*c);

    return col;
}

// Function 496
vec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )
{
    // score
    vec2 p = fragCoord/iResolution.y;
    col += float( PrintInt( (p - vec2(0.05,0.9))*20.0, int(score.x) ));
    col += float( PrintInt( (p - vec2(0.05,0.8))*20.0, int(242.0-score.y) ));
    
    // lives
    float eps = 1.0 / iResolution.y;
    for( int i=0; i<3; i++ )
    {
        float h = float(i);
        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );
        if( h + 0.5 < lives )
        {
            float c = sdCircle(q, 0.023);
            float f = c;

            {
                vec2 w = normalize( q - vec2(0.005,0.0) );
                w = vec2( w.x, abs( w.y ) );
                float an = 0.5;
                float m = dot( w, vec2(sin(an),cos(an)));
                f = max( f, -m );
            }
            f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );
            col = mix( col, vec3(1.0,0.8,0.1), f );

            // glow
            //col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);
        }
    }

    return col;
}

// Function 497
vec2 sdLine( vec3 p, vec3 a, vec3 b )
{
	vec3 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return vec2( length( pa - ba*h ), h );
}

// Function 498
void set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {
    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);
}

// Function 499
float line(vec2 p1, vec2 p2, vec2 uv, float thick) {

  float vA= abs(distance(p1, uv));
  float vB= abs(distance(p2, uv));
  float vC= abs(distance(p1, p2));

  if ( vA>= vC|| vB>=  vC) return 0.0;

  float p = (vA+ vB+ vC) * 0.5;
  float h = (2.0 / vC) * sqrt( p * ( p - vA) * ( p - vB) * ( p - vC));
  return mix(1.0, 0.0, smoothstep(0.5 * thick, 1.5 * thick, h));
}

// Function 500
float drawO(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  bool onCir = isIn(length(uv), cMin, cMax);
    return float(onCir);
}

// Function 501
vec2 circle2(in vec2 rd, in vec3 sph )
{
    vec2 oc = sph.xy;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.z*sph.z;
    float h = b*b - c;
    if( h<0.0 ) return vec2(1000.0);
    h = sqrt( h );
    return -b + vec2(-h,h);
}

// Function 502
float line(vec2 p, vec2 v1, vec2 v2) {
    p  -= v1;
    vec2 v = v2-v1;
    float t = dot(p, normalize(v));
    if (t<0.0) {
        return length(p);
    } else if (t>length(v)) {
        return length(p-v);
    } else {
        return abs(crs(p, normalize(v)));
    }
}

// Function 503
void DrawM( inout vec3 color, float x, float y )
{    
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if ( y >= 4.0 && y <= 7.0 )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 504
void DrawBorderOutdent( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )
{    
    vec2 vThickness = vec2(1.0);
    
	if ( Inside( vCanvasPos, rect ) )
    {
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )
        {
            vOutColor.rgb = vec3(0.85);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )
        {
            vOutColor.rgb = vec3(0.0);
        }
        else
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(1.0);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(0.4);
        }
    }
}

// Function 505
float sdLine( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 506
float lineDist(vec2 a,vec2 b,vec2 p)
{
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 507
vec4 blend_Circle()
{
    vec2 texVec;
    texVec.x = (uv.x - 0.5) * 2.0;
    texVec.y = (uv.y - 0.5 / aspectRatio) * 2.0;

    float phaseLim = phase * 1.5;
    float texVecLength = length(texVec);

    return interpolateColor(phaseLim, 0.02, texVecLength);
}

// Function 508
vec3 DrawCandy(vec2 p, vec3 bgColor, vec4 candyIdData)
{
    p *= 1.2;
    vec3 candyColor;
    if(candyIdData.z < 0.5) { candyColor = DrawCandy0(p, bgColor);}
    else if(candyIdData.z < 1.5) { candyColor = DrawCandy1(p, bgColor);}
    else if(candyIdData.z < 2.5) { candyColor = DrawCandy2(p, bgColor);}
    else if(candyIdData.z < 3.5) { candyColor = DrawCandy3(p, bgColor);}
    else /*if(candyIdData.z < 4.5)*/ { candyColor = DrawCandy4(p, bgColor);}
    //else { candyColor  = DrawCandy5(p, bgColor); }
    
    candyColor = DrawCandyExplosion(p, candyColor, bgColor, candyIdData);
    
    return candyColor;
}

// Function 509
vec3 redline1(vec2 u,vec3 r,vec4 m,vec3 c,float yo
){return c=strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),.4),vec4(1.3,yo,-2.9,yo),.03);}

// Function 510
vec3 ThickLine(vec2 uv, vec2 posA, vec2 posB, float radiusInv)
{
	vec2 dir = posA - posB;
	float dirLen = length(dir);
	vec2 dirN = normalize(dir);
	float dotTemp = clamp(dot(uv - posB, dirN), 0.0, dirLen);
	vec2 proj = dotTemp * dirN + posB;
	float d1 = distance(uv, proj);
	vec2 derivative = (uv - proj);

	float finalGray = saturate(1.0 - d1 * radiusInv);
	// multiply derivative by gray so it smoothly fades out at the edges.
	return vec3(finalGray, derivative * finalGray);
}

// Function 511
float draw_point(vec2 uv, float e, vec3 p, mat4 T)
{
    vec4 a = T * vec4(p, 1.0);
    
    a.xy /= a.z;
    
    return point(uv, e, a.xy);
}

// Function 512
float DrawCharacter(inout vec2 p, in int c)
{
    float fC = float(c);
    float color = 0.0;
	if(p.x >= 0.0 && p.x <= 1.0 && p.y >= 0.0 && p.y <= 1.0)
    {
        color = step(texture(iChannel1, p / 16.0 + fract(floor(vec2(fC, 15.99 - fC / 16.0)) / 16.0)).a, 0.5);
    }
    p.x -= 0.5;
    return color;
}

// Function 513
void UI_DrawWindowTitleBar( inout UIContext uiContext, bool bActive, Rect titleBarRect, inout UIWindowState window )
{   
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, titleBarRect ))
        return;
    
    vec4 colorA = vec4(0.0, 0.0, 0.5, 1.0);
    vec4 colorB = vec4(0.03, 0.5, 0.8, 1.0);
    if ( bActive )
    {
        colorA.rgb += 0.1;
        colorB.rgb += 0.1;
    }

    float t = (uiContext.vPixelCanvasPos.x - titleBarRect.vPos.x) / 512.0;
    t = clamp( t, 0.0f, 1.0f );
    uiContext.vWindowOutColor = mix( colorA, colorB, t );
    
    {
        LayoutStyle style;
        RenderStyle renderStyle;
        UIStyle_GetFontStyleTitle( style, renderStyle );

        vec2 vTextOrigin = vec2(0);
        if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )
        {
        	vTextOrigin.x += titleBarRect.vSize.y;
        }
        
        PrintState state = UI_PrintState_Init( uiContext, style, vTextOrigin );    
        PrintWindowTitle( state, style, window.iControlId );    
        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );
    }
}

// Function 514
vec3 drawLogoBottom(ivec2 coord)
{
    ivec2 cellIdx = coord / CEH_RES;

    if (coord.x < 0 || coord.x > (LOG_RES.x - 1) || coord.y < 0 || coord.y > (LOG_RES.y - 1))
    {
        return vec3(0.0);
    }

    int idx = cellIdx.y * LOG_SIZ.x + cellIdx.x;
    ivec4 sprite = logoHS[logoPattern[idx]];
    return sampleHalfSprite(sprite, logoColors, coord).rgb;
}

// Function 515
float line(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float h = clamp( dot(pa, ba)/dot(ba, ba), 0., 1.);
    return length(pa - ba * h);
}

// Function 516
float sdfRect(vec2 uv, vec2 s) {vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }

// Function 517
float dsqSegmentLine(vec3 a, vec3 b, vec3 p, vec3 nv) {
    float tMinA = minPointLine(p, nv, a);
    float tMinB = minPointLine(p, nv, b);
    float dsqMin = min(
        dsq( a, p + tMinA*nv ),
        dsq( b, p + tMinB*nv )
    );

    float lenSeg = length(a - b);
    vec3 nvSeg = (a - b) / lenSeg;

    vec2 minInterior = minLineLine(b, nvSeg, p, nv);
    if (minInterior.s > 0.0 && minInterior.s < lenSeg) {
        vec3 cpSeg = b + minInterior.s*nvSeg;
        vec3 cpLine = p + minInterior.t*nv;
        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );
    }

    return dsqMin;
}

// Function 518
void Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)
{
	float fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);
	float kSpreadPower = 2.0;
	vFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;
}

// Function 519
float drawSphere(vec3 p,vec3 o,float r)
{
    return length(p-o) - r;
}

// Function 520
float Rectangle(vec2 uv,float h,float b,float l,float r,float blur){
	float x = band(uv.x,l,r,blur);
    float y = band(uv.y,h,b,blur);
    return x*y;
}

// Function 521
float line(vec2 uv, float t, float scroll)
{
    
    float ax = abs(uv.x);
    uv.y *= 0.5 + ax * ax * 0.3; 
    
        
    uv.x += iTime * scroll;
    
    float n1 = LineNoise(uv.x, t);
    
    
    float n2 = LineNoise(uv.x + 0.5, t + 10.0) * 2.0;
    
    float ay = abs(uv.y - n1);
    float lum = S(0.02, 0.00, ay) * 1.5;
    lum += S(1.5, 0.00, ay) * 0.1;
    
   
    float r = (uv.y - n1) / (n2 - n1);
    float h = sat(1.0 - r);
    if (r > 0.0) lum = max(lum, h * h * 0.7);
    
    return lum;
}

// Function 522
float shoreLine(vec3 rp)
{
    return abs(getCurve(rp) + rp.x);
}

// Function 523
float sdLine(in vec2 p, in vec2 a, in vec2 b)
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp(dot(pa, ba)/dot(ba,ba), 0.0, 1.0);
    return length(pa-ba*h);
}

// Function 524
vec3 linearToGamma(const in vec3 linearColor) {
   return pow(linearColor, vec3(0.4545));
}

// Function 525
void drawBirdF2(int x, int y)
{
	if (y < 0 || y > 11 || x < 0 || x > 15) {
		return;
	}
	
	// pass 0 - draw black, white and yellow
	float col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,1.,1.,1.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  7) col = SPRROW(x,1.,2.,2.,2.,1.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  6) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  5) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 3.,3.,1.,1.,1.,1.,1.,1.);
	if (y ==  4) col = SPRROW(x,0.,1.,2.,2.,2.,1.,3.,3., 3.,1.,2.,2.,2.,2.,2.,1.);
	if (y ==  3) col = SPRROW(x,0.,1.,1.,1.,1.,3.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);
	if (y ==  2) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
		
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(82,56,70); // outline color (black)
	}
	else if (col == 2.0) {
		fragColor = RGB(250,250,250); // eye color (white)
	}
	else if (col == 3.0) {
		fragColor = RGB(247, 182, 67); // normal yellow color
	}
	
	// pass 1 - draw red, light yellow and dark yellow
	col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  5) col = SPRROW(x,0.,3.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  4) col = SPRROW(x,0.,0.,3.,3.,3.,0.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);
	if (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  2) col = SPRROW(x,0.,0.,0.,2.,2.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);	
	
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(249, 58, 28); // mouth color (red)	
	}
	else if (col == 2.0) {
		fragColor = RGB(222, 128, 55); // brown
	}
	else if (col == 3.0) {
		fragColor = RGB(249, 214, 145); // light yellow			
	}		
}

// Function 526
vec4 drawCellExplosionDiamond(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteExplosionDiamond(state.y);
    return sampleSprite(sprite, colors, coord);
}

// Function 527
vec3 draw(vec2 p, vec2 seed) {
    float d = 1.;
    bool simpleForm = rand(seed-1.) > 0.8;
    bool global = !simpleForm;
    vec3 col = vec3(1);
    vec2 size = vec2(1);
    float mu = sqrt(2.);
    float blank = 0.11;
	bool flipped = false;
    for(int i=0;i<2;i++) {
        bool refuse = false;
        if(global) {
            bool dir = rand(seed) < 0.5;
            if(dir) {
                p = p.yx;
                size = size.yx;
                flipped = !flipped;
            }
            float ratio = rand(seed+1.);
            ratio = ratio < 0.3 ? 0.3
                  : ratio < 0.5 ? 0.5
                                : 0.65;
            if(size.x < 0.7) ratio = 0.4;
            if(i!=0 &&  dir && size.x < 0.7) refuse = true;            
            if(i!=0 && !dir && size.x < 0.7) refuse = true;
            if(!refuse) {
                if(p.x < ratio) {
                    float w = ratio * size.x - blank / 2.;
                    p.x /= w / size.x;
                    size.x *= w / size.x;
                    seed += 0.2;
                } else {
                    float pad = ratio * size.x + blank / 2.;
                    float w = (1.-ratio) * size.x - blank / 2.;
                    p.x -= pad / size.x;
                    p.x /= w / size.x;
                    size.x *= w / size.x;
                }
            }
            seed.xy += ratio * mu * seed.yx;
            if(p.x < 0. || p.x > 1.) {
                col = vec3(0.);
                break;
            }
        }
        mu /= sqrt(3.0);
    }
    if(flipped) {
    	p = p.yx;
        size = size.yx;
    }
    col *= pieces(p, size, seed, simpleForm);
    //col.rg *= size;
    float w = 0.1;
    //vec3 col = vec3(1) * smoothstep(w*0.5+0.01,w*0.5-0.01,d);
    return col;
}

// Function 528
float vLine(vec2 st, vec2 a, vec2 b, float w)
{
    a += jitter(st, iTime) * 0.001;
    b += jitter(st, iTime * 2.) * 0.00;
    vec2 ab = b - a;
    vec2 toSt = st - a;
    float t = clamp(dot(toSt, ab) / dot(ab, ab),0., 1.);
    return max(length((a + ab * t) - st) - w * 0.5, 0.);
}

// Function 529
bool line(float pos, float width)
{
    if (abs(pos) < width) return true;
    return false;
}

// Function 530
void DrawGear(inout vec3 color, vec2 uv, Gear g, float eps)
{
	float d = smoothstep(eps, -eps, GearDe(uv, g));
    float s = 1.0 - 0.7*GearShadow(uv, g);
    color = mix(s*color, g.color, d);
}

// Function 531
vec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {
    float d;
    float l_sq = pow(distance(p1, p2), 2.0);
    if (l_sq == 0.0)
        d = distance(p, p1);
    else {
        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));
        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment
        d = distance(p, projection);
    }
    float noise;
    // TODO (01 May 2020 sam): Figure out how to to better line check
    if (p1.y<p.y) noise = get_noise(p.yx);
    else noise = get_noise(p);
    d += noise*line_variation;
    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);
    return mix(pencil_colour, current_colour, pencil);
}

// Function 532
vec4 drawRadius(in vec2 uv, in float mode, in float radius, vec3 fill, in float brush, in float grad_func)
{
    vec4 tcol = vec4(0.);
    if (in_zone(mode, APPL_UI))
    {
        float draw_rad = radius*RADIUS_COEFF;
        float ratio = iResolution.x / iResolution.y;
        vec2 draw_center = vec2(.2*ratio, (SELECTION_MODE_MAX.y + SELECTION_MODE_MIN.y)*0.5);
        float rad = 10.*length(vec2(uv.x*ratio, uv.y) - draw_center);
        float bound = step(rad, radius);
        bound *= step(sqrt(brush), hash12(3096.314*uv));
        vec2 gradFn = getGradFunction(clamp((radius-rad)/radius, 0., 1.), getIValue(grad_func, INTERP_FUNC_NUM));
        bound *= gradFn.x;
        float ring = smoothstep(rad - 0.03, rad, radius) - smoothstep(rad, rad + 0.03, radius);
        tcol.xyz = fill*bound;
        tcol.x += ring;
        tcol.w = clamp(bound + ring, 0., 1.);
    }
    
    return tcol;
}

// Function 533
float circle(vec2 uv, float diameter, float speed)
{
	speed *= sin(iTime*0.3-0.9);
	//speed *= 1.0+0.4*length(uv)*sin(iTime*0.03);
	float angle = iTime*speed-3.4*length(uv)*sin(iTime*0.3);
	uv*= mat2(  sin(angle), cos(angle),
				cos(angle),-sin(angle));
	
	float pixelate = 0.07-sin(iTime*0.1)*0.045;
	//pixelate -= mod(pixelate,0.001);
	uv -= mod(uv,pixelate)-pixelate*0.5;
	return 1.0-smoothstep(0.0002,0.0001+pixelate,(abs(mod(length(uv),0.05)-diameter)));
}

// Function 534
float Line(vec2 p)
{
	float m = (2.0 / 1.0);
	float b = 0.0;
	
	float y = m*p.x + b;
	
	return p.y - y;
}

// Function 535
vec3 Spline_EvaluateBinormal(mat4 MG, float t )
{
	vec4 tvec = vec4(6.*t, 2., 0., 0.);	
	vec3 p = (MG*tvec).xyz;
	return p;
}

// Function 536
float line(in vec2 from, in vec2 to, float w)
{
    float l2 = dot(to-from, to-from);
    float t = max(0., min(1.0, dot(g_uv-from, to-from) / l2));
    vec2 projection = from + t * (to - from);
    w *= dFdx(g_uv.x);
    return smoothstep(0.0025, 0.0025 - w * 4., length(g_uv - projection));
}

// Function 537
vec3 DrawStrongCircle(vec2 uv){
	float val = clamp((1.0-length(uv)*2.),0.,1.);
	val = pow(val,0.5);
	return vec3(val,val,val);
}

// Function 538
float drawEq() {
	float x = texture(iChannel0, vec2(UNIT_VECTOR.x, 0.0)).x;
	float y = UNIT_VECTOR.y - 1.337;
	
	float intensity = cos(x) + y;
	intensity /= 0.001;
	
	intensity = 1.0 - intensity;
	return clamp(intensity, 0.0, 1.0);
}

// Function 539
bool IsPointInRectXY(in vec4 poly_coords, in vec2 world_xy_of_point)
{
    // return true if world_xy_of_point is within the poly defined by
    // poly_coords in the Z=0 plane.
    // I can test in 2D rather than 3D because all the geometry
    // has z=0 and all the quads are planar.

    float x_test, y_test;
    x_test = step(poly_coords.x, world_xy_of_point.x) *
            (1.0 - step(poly_coords.z, world_xy_of_point.x));
        // step() is 1.0 if world.x >= poly_coords.x
        // 1-step() is 1.0 if world.x < poly_coords.z
    y_test = step(poly_coords.y, world_xy_of_point.y) *
            (1.0 - step(poly_coords.w, world_xy_of_point.y));

    return ( (x_test>=0.9) && (y_test >= 0.9) );
        // Not ==1.0 because these are floats!

}

// Function 540
vec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {
    float x = p.x, y = p.y, z = p.z;

    float ba = b - a, ca = c - a;
    float q = ba + c - d + e - f - g + h, qx = q * x;
    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;

    float dx = ba + dbac * y + (fbae + q * y) * z;
    float dy = ca + dbac * x + (gcae + qx) * z;
    float dz = e - a + fbae * x + (gcae + qx) * y;

    return normalize(vec3(dx, dy, dz));
}

// Function 541
vec3 GetPosOnSpline(float t)
{
	return Spline_Evaluate(spline.MG,t);
}

// Function 542
v3 linearGraph(v1 u,v0 h,v0 g){
  d d=getd(u.x);
  //float div=sqrt(1.+p.y*p.y);
  v0 r=abs(d.x-u.y)/(sqrt(1.+d.d*d.d))-thick;    
  d=getd(u.x);
  //no analytical 2nd derivative, so this one sucks a bit
  v0 b=abs(d.d-u.y)/(sqrt(1.+d.d*d.d))-thick;
  //this does not work for scaled p, is far from being user friendly
  v0 blur=20./max(iResolution.y,1.);
  v3 yellow =v3(v2(1,1,0),ssb(r));
  v3 cyan   =v3(v2(0,1,1),ssb(g));
  v3 magenta=v3(v2(1,0,1),ssb(b));
  return aOverB(aOverB(yellow,magenta),cyan);}

// Function 543
void SetSceneInDirectionless( inout SceneIn scenein, int trace_flags )
{
	scenein.v = vec3( 0.0 );
	scenein.v_rcp = vec3( 0.0 );
//	scenein.o = vec3( 0.0 );
	scenein.trace_flags = trace_flags;
	scenein.t0 = 0.0;
}

// Function 544
void draw(float func, inout vec3 origColor, vec3 funcColor, vec2 p)
{
    float e = 1.0/iResolution.x;
    float m = 0.5*iResolution.y/iResolution.x;
    
    float y = m + m*func;
    float d = abs(p.y-y);
    
    origColor = mix( origColor, funcColor, 1.0 - smoothstep( 0.0, 2.0*e, d ) );
}

// Function 545
vec3 vLine(vec2 uv, vec2 pos, float border, float width)
{
    float vl = smoothstep(pos.x-border/2., pos.x, uv.x) - smoothstep(pos.x, pos.x+border/2., uv.x);
    float hl = step(pos.y-width/2.,uv.y) - step(pos.y+width/2., uv.y);
    return vec3(1.-vl*hl);
}

// Function 546
vec3 linearDodge (vec3 target, vec3 blend){
    return target + blend;
}

// Function 547
vec2 sdLine(in vec3 pos, in vec3 a, in vec3 b) {
	vec3 pa = pos - a;
	vec3 ba = b - a;

	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);

	return vec2(length(pa - h*ba), h);
}

// Function 548
float distanceToCircle(vec2 p, vec2 center, float r)
{
    return length(p - center) - r;
}

// Function 549
float Circle(vec2 p, float r)
{
	return (length(p / r) - 1.) * r;
}

// Function 550
float stripesCircle4(vec2 uv, float distorsion) {
    return stripesCircle(uv, StripesCircleOpt(.4, .95, 6.5, -.03, 32.7), StripesOpt(distorsion, 0., 1.));
}

// Function 551
vec4 iTrilinearIsoSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {
    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);
    vec3 v = vec3(b, c, e) - a;

    vec3 xxyyzz = ro.xxy * ro.yzz;
    vec3 uuvvww = rd.xxy * rd.yzz;

    float t3 = u.x * rd.x * rd.y * rd.z;
    float t2 = dot(ro.zyx, uuvvww) * u.x + dot(u.yzw, uuvvww);
    float t1 = dot(u, vec4(dot(xxyyzz, rd.zyx), dot(ro.xy, rd.yx), dot(ro.xz, rd.zx), dot(ro.yz, rd.zy))) + dot(v, rd);
    float t0 = u.x * ro.x * ro.y * ro.z + dot(u.yzw, xxyyzz) + dot(v, ro) + a;

    return solveCubic2(t3, t2, t1, t0);
}

// Function 552
float redraw(vec2 U, int r) {                           // --- treat a node position change 
    int i = int( texelFetch(iChannel0,ivec2(r), 0).z ), // ivec2(r).z contains node id
        p = (i-1+N) % N, n = (i+1) % N;                 // prev, next to i
	if (i<0) return 0.;                                 // no change request
    float ap = node(p).x, an = node(n).x,               // pos of prev and next nodes
          ai = node(i).x, ao = node(i).y;               // new and old pos of node
    return    draw( ap, ai ) + draw( ai, an )           // draw new 2 connection to i
            - draw( ap, ao ) - draw( ao, an );          // undraw prev 2 connection to i
}

// Function 553
float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br//rounded rectangle
){vec2 d = max(tl-uv, uv-br)
 ;return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));}

// Function 554
vec2 RayDirection(in vec2 pixel, out bool pip)
{
    pip=false;
    // Pixel coordinates
    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;
   if (pip==true)
   {    
    const float fraction=1.0/4.0;
    // Picture in picture
    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))
    {
        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);
        pip=true;
    }
       else
       {
           pip=false;
       }
   }
   return p;
}

// Function 555
vec4 spline(float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 ) {
    return c0*dot( BS_B, powers(x + 1.)) + c1*dot( BS_A, powers(x      )) +
           c2*dot( BS_A, powers(1. - x)) + c3*dot( BS_B, powers(2. - x));
}

// Function 556
float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 36.0 * iTime;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
                            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 2.0) );
    	d = normalize(d);
        //compute gradient based on angle difference to theta0
   	 	float theta = mod(360.0*atan(d.y,d.x)/M_PI/theta0,150.0);
        float gradient = clamp(1.0-theta/90.0,0.0,1.0);
        return SMOOTH(l,10.0)+0.5*gradient;
    }
    else return 0.0;
}

// Function 557
float sdCircle( in vec2 p, in float r )
{
    return length( p ) - r;
}

// Function 558
vec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}

// Function 559
int uvToLinearCoord(vec2 uv) 
{
	return int(((uv.y-0.5) * iResolution.x) + uv.x-0.5);
}

// Function 560
vec3 draw_day(vec2 uv) 
{
    float dayCenter = iDate.z / 31.;
	float f = abs(uv.x - dayCenter);
    
    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.05, .0, pow(uv.y, 1.4)));
    float beamSpread = .01 + .1 * max(0., pow((1. - uv.y), 3.));
    lightBeam *= smoothstep( DAY_WIDTH + beamSpread, DAY_WIDTH - beamSpread, f);
    
    float lightIntensity = lightBeam * .6;
    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.13, .0, f);
    
    lightIntensity *= atmos( 3.5 * (uv + vec2(20., 20.)) ); // scale and shift fog to fake depth
    
    return vec3(1., 0.7, 0.5) * lightIntensity;
    
}

// Function 561
void drawCircle( vec2 coords, vec2 center, float radius )
{
    float sD = distance(coords, center);
	float a = 1.0 - clamp(sD - radius / 2.0 + .5, 0.0, 1.0);
    
        outputColor = mix(outputColor, color, a * color.a);
}

// Function 562
void drawCircle(vec2 uv, inout vec3 color, Circle c){
    float alpha = c.color.a;
    #if DARKMODE
    alpha = pow(alpha, 1.5);
    #else
    alpha = pow(alpha, 0.75);
    #endif
    color = mix(c.color.rgb, color, (1.0-alpha) + alpha*circleShape(uv, c));
}

// Function 563
float IsWithinCircle(vec2 point, vec2 circleCenter, float circleRadius)
{
    circleCenter = vec2(circleCenter.x * iResolution.x, circleCenter.y * iResolution.y);
    circleRadius = circleRadius * iResolution.x;

    float len = length(point-circleCenter);
    
    return smoothstep( circleRadius*0.5, circleRadius*1.5, len);
}

// Function 564
vec2 linesegments(vec2 u,vec3 q,float f,float p,vec4 m
){//q=quadratic coefficients f=focalLength, x=segment.x,m.xy=Vertex,m.zw=focus
 ;vec2 r=vec2(1)
  //remove wrongly implemented line below, and see that all other code is fine.
 ;f=arclength(f,p) //this line is contextually false. everything up to this point is correct.
 //f anf p are both contextually correct values.
 ;if(u.x-m.x>0.&&u.x-m.x<p)r.x=parabola(u.x,q)-u.y//show parabola from 0 till p
 ;if(u.x-m.x>0.&&u.x-m.x<f)r.y=m.y            -u.y//show flattened arclength
 ;return abs(r);
 ;}

// Function 565
void drawTrials(in vec2 fragCoord, inout vec4 outColor) {
  float scale = iResolution.y / 20.0;
  vec2 anchor = iResolution.xy / 2.0 + center * scale;

  for (int i = 0; i < rods; i++) {
    vec2 position = anchor + ballData(STORAGE, i).xy * scale;
    vec3 color = black ? vec3(0.0) : palette[i % colors];
    if (continuous) {
      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;
      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),
                  vec4(color, 1.0), outColor);
    } else {
      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),
               outColor);
    }
  }
}

// Function 566
vec3 drawlights( Ray ray )
{   
    vec3 delta = g_light.pos - ray.pos;
    vec3 closest = ray.pos + ray.dir*dot(delta, ray.dir);
    float len = length(g_light.pos-closest);

    vec3 colour = 0.5*g_light.colour/(len*300.0);
    return colour;
}

// Function 567
vec3 yLine(vec2 uv,float y, float thickness){
    float colwave = thickness /  abs(uv.y+y);
    return vec3(colwave);
}

// Function 568
float Draw3DLine( vec3 vRayOrigin, vec3 vRayDir, vec3 vStart, vec3 vEnd, float fSize )
{    
    vec3 vRayEnd = vRayOrigin + vRayDir * 1000.0;
    
    float fD = dist3D_Segment_to_Segment(vRayOrigin, vRayEnd, vStart, vEnd );
    
    float fFeather = 1.0;
    return clamp ( 1.0 - (fD - fSize) / fFeather, 0.0, 1.0 );
    
    //return fD;
}

// Function 569
float line(vec2 a, vec2 b, vec2 uv) {
    float r1 = .04;
    float r2 = .01;
    
    float d = df_line(a, b, uv);
    float d2 = length(a-b);
    float fade = S(1.5, .5, d2);
    
    fade += S(.05, .02, abs(d2-.75));
    return S(r1, r2, d)*fade;
}

// Function 570
float line(vec2 p, vec2 a,vec2 b) { // https://www.shadertoy.com/view/llySRh
    p -= a, b -= a;
    p -= b * clamp(dot(p, b) / dot(b, b), 0., 1.);
    return dot(p,p);
}

// Function 571
vec3 PointOnCircle(in vec3 pos, in vec3 circlePos, in vec3 circleNorm, in float circleRadius)
{
 	vec3 d = pos - circlePos;
    vec3 qc = d - dot(circleNorm, d) * circleNorm;
    
    return (circlePos + circleRadius * normalize(qc));
}

// Function 572
float fOpSubstractionLinear (float a, float b, float r)
{
    return fOpIntersectionLinear(b, -a, r);
}

// Function 573
void draw_sphere_inset(in vec2 p, inout vec3 color) {    
    
    float px = inset_scl;
    
    float dot_size = max(3.0*px, 0.03);
    float line_width = max(.25*px, 0.003);

    float lp = length((p - inset_ctr)*px);
        
    vec3 sp = sphere_from_gui(p);
    
    if (lp < 1.) {
        
        color = vec3(1);        
      
        float d_tri = 1e5;
        
        
        float d_circ = 1e5;
        
        for (int i=0; i<3; ++i) {

            d_circ = min(d_circ, length(sp - tri_verts[i]));
            d_circ = min(d_circ, length(sp - tri_spoints[i]));
            
            d_tri = min(d_tri, dot(sp, tri_edges[i]));
        }
        
        d_circ = min(d_circ, length(sp - tri_spoints[3]));
                   
        float d_V = length(sp - poly_vertex);
                
        vec3 sp2 = sp;
        tile_sphere(sp2); 
        

        float d_gray = 1e5;
        
        for (int i=0; i<3; ++i) {
            d_gray = min(d_gray, abs(dot(sp2, tri_edges[i])));
        }
        
        
        float d_pink = length(sp2 - poly_vertex);
        
        color = mix(color, vec3(0.85), smoothstep(px, 0.0, d_gray-2.*line_width));

        color = mix(color, vec3(0.9, 0.5, 0.5), smoothstep(px, 0.0, d_pink-0.7*dot_size));

        color = mix(color, vec3(0.6), smoothstep(px, 0.0, -d_tri));
        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_tri)-line_width));

        color = mix(color, vec3(1), step(d_circ, dot_size));
        color = mix(color, vec3(0.7, 0, 0), smoothstep(px, 0.0, d_V-dot_size));
        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_circ - dot_size)-line_width));

    
    }    
    
    color = mix(color, vec3(0), smoothstep(px, 0.0, abs(lp - 1.)-line_width));                                                 
    
}

// Function 574
vec3 to_linear_space(vec3 color)
{
	return(pow(color, vec3(gamma)));  
}

// Function 575
float dfCircle(vec2 origin, float radius, vec3 p)
{
	origin *= scale;
	radius *= scale;
	
	float d =  abs(length(p.xy - origin) - radius);
	
	float dd = length(vec2(d,p.z))-0.01;
	return dd;
}

// Function 576
void drawHorzLine(vec2 co, float yPos, float xStart, float xEnd, vec4 color)
{
	if ((co.y >= yPos) && (co.y < (yPos + 1.0)) && (co.x >= xStart) && (co.x < xEnd)) {
		fragColor = color;
	}
}

// Function 577
float sdf_line6(vec2 p,vec2 a){a.x=-a.x;return dot(a.yx,p);}

// Function 578
vec3 DrawSub(vec3 col, vec3 sub){
    return min(col,sub);
}

// Function 579
vec3 nearestpointonline(vec3 l0, vec3 l1, vec3 p)
{
    vec3 ld = l1-l0;
    vec3 ldn = normalize(ld);
    float d = dot(p-l0, ldn);
    vec3 r = l0+d*ldn;
    //return r - normalize(p-r)*mist(p,1);
    
    if (d<0.0) 
        return l0;
    else if (d>length(ld))
        return l1;
    else
        return r;
}

// Function 580
float abs_circle_inv(vec2 p) {
    float circle = abs(length(p) - 0.1);
    return 1./circle;
}

// Function 581
vec2 DirectR2(uint index) {
    return fract(r2consts * float(index));
}

// Function 582
float rect(vec2 p, float w, float h)
{
 	p=abs(p/vec2(w,h));
    return smoothstep(1.,.975,max(p.x,p.y));
}

// Function 583
float smoothCircle(vec2 position,float relativeSize){
    float d = distance(cc,position)*2./relativeSize;
    if (d > 1.0){
    	return 0.0;
    }
    else{
    	return clamp(smoothness/d-smoothness,-1.0,1.0);
    }
}

// Function 584
float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    float offset=1.5*snoise(uv+sin(iTime));
    float noise=.5*gnoise(uv);
    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);
}

// Function 585
void rect(in vec4 _p, in vec3 _c, in vec2 fragCoord, inout vec4 fragColor)
{
	vec2 p = fragCoord.xy;
    if((_p.x<p.x&&p.x<_p.x+_p.z&&_p.y<p.y&&p.y<_p.y+_p.w))fragColor=vec4(_c,0.);
}

// Function 586
float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
	    return SMOOTH(r-width*3.0,radius)-SMOOTH(r+width/6.0,radius);
    else
        return 0.0;
}

// Function 587
void DrawTrees( vec2 pos )
{
	vec2 p = pixel-pos;
	vec2 ap = abs(p);
	vec4 t = texture( iChannel0, pixel*vec2(2,1)/80.0 );
	if ( max(ap.x,ap.y) < 60.0+10.0*pow(t.b,.5) )
	{
		fragColor.rgb = mix( vec3(.0,.0,.0), vec3(.0,.3,.0), t.g);
	}
}

// Function 588
bool isDrawing() {  
#ifdef ALTERNATE_MODE    
	return (.2*time) < 16. && sin(time)>0.;
#else
    return (.16*time) < 16.;
#endif    
}

// Function 589
vec3 foXZCircle(vec3 p, float l, float r){
  return vec3(atan(p.z,p.x)*l/P2,p.y,length(p.xz)-r);
}

// Function 590
float line( vec2 p, vec3 d ) 
{
	return abs(dot(p,normalize(d.xy)))-d.z;    
}

// Function 591
int drawInt( in int val, in vec2 pos, in vec2 size, in vec2 uv )
{
    vec2 p = vec2(pos);
    float s = sign(float(val));
    val *= int(s);
    
    int c = drawIntCarriage(val,p,size,uv,1);
    if( s<0.0 ) c |= drawChar(CH_HYPH,p,size,uv);
    return c;
}

// Function 592
float circle(vec2 uv, float rad, vec2 pos){

    return 1.0-smoothstep(distance(pos, uv),0.1, 0.095);
}

// Function 593
float CharRect(vec2 p, float minX, float minY, float maxX, float maxY)
{
	vec2 minCoord = vec2(minX, minY);
	vec2 maxCoord = vec2(maxX, maxY);
	vec2 b = 0.5 * (maxCoord - minCoord);
    vec2 c = 0.5 * (maxCoord + minCoord);
    return CharRect(p - c, b);
}

// Function 594
float line(vec2 p, vec2 a, vec2 b) { vec2 pa = p - a; vec2 ba = b - a; float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0); return length(pa - ba * h); }

// Function 595
vec4 lineCol(vec2 uv)
{
    vec4 col=vec4(0);
    col+=clamp(1.*(1.-textureLod(iChannel3,uv,0.))*11.-1.9,0.,4.);
    col+=clamp(1.*(1.-textureLod(iChannel3,uv,3.5))*9.-.7,0.,4.);
    return col;
}

// Function 596
float line(vec2 p, vec2 a, vec2 b) { // draw a line
  b -= a; p -= a;
  return length(p - b*clamp(dot(b,p)/dot(b,b),0.0,1.0));
}

// Function 597
int drawChar( in int char, in vec2 pos, in vec2 size, in vec2 uv )
{
    
    // Subtract our position from the current uv so that we can
    // know if we're inside the bounding box or not.
    uv-=pos;
    
    // Divide the screen space by the size, so our bounding box is 1x1.
    uv /= size;    
    
    // Multiply the UV by the bitmap size so we can work in
    // bitmap space coordinates.
    uv *= vec2(MAP_SIZE);

    // Compute bitmap texel coordinates
    ivec2 iuv = ivec2(round(uv));
    
	// Bounding box check. With branches, so we avoid the maths and lookups    
    if( iuv.x<0 || iuv.x>MAP_SIZE.x-1 ||
        iuv.y<0 || iuv.y>MAP_SIZE.y-1 ) return 0;

    // Compute bit index
    int index = MAP_SIZE.x*iuv.y + iuv.x;
    
    // Get the appropriate bit and return it.
    return (font[char]>>index)&1;

}

// Function 598
vec3 sampleIndirectLight(vec3 pos, vec3 normal){
    vec3 dir;
    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;
    for(int i = 0; i < Bounces; i++){
        dir = getCosineWeightedSample(normal);
        if(!trace(pos, dir, normal)) return light + abso*background(dir);
        sdf(pos, dc, ec);
        light += abso * (ec + dc*directLight(pos, normal));
        abso *= dc;
    }
    return light;
}

// Function 599
float FillLinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {
    float scale = abs(dFdy(uv).y);
    thick = (thick * 0.5 - 0.5) * scale;
    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);
    return saturate(df / scale);
}

// Function 600
float lineN(vec2 u,vec2 m){return line(u,normalize(m));}

// Function 601
float draw_cell(vec2 uv, float e, float w, vec3 c, float s, mat4 T) 
{
    vec4 b1 = T * vec4(c + vec3(-0.5, -0.5, -0.5)*s, 1.0);
    vec4 b2 = T * vec4(c + vec3(-0.5, -0.5, 0.5)*s, 1.0);
    vec4 b3 = T * vec4(c + vec3(0.5, -0.5, 0.5)*s, 1.0);
    vec4 b4 = T * vec4(c + vec3(0.5, -0.5, -0.5)*s, 1.0);
   
    vec4 t1 = T * vec4(c + vec3(-0.5, 0.5, -0.5)*s, 1.0);
    vec4 t2 = T * vec4(c + vec3(-0.5, 0.5, 0.5)*s, 1.0);
    vec4 t3 = T * vec4(c + vec3(0.5, 0.5, 0.5)*s, 1.0);
    vec4 t4 = T * vec4(c + vec3(0.5, 0.5, -0.5)*s, 1.0);
    
    b1.xy /= b1.z;
    b2.xy /= b2.z;
    b3.xy /= b3.z;
    b4.xy /= b4.z;
    
    t1.xy /= t1.z;
    t2.xy /= t2.z;
    t3.xy /= t3.z;
    t4.xy /= t4.z;
    
    float v = 1.0;
    v *= segment(uv, e, w, b1.xy, b2.xy);
    v *= segment(uv, e, w, b2.xy, b3.xy);
    v *= segment(uv, e, w, b3.xy, b4.xy);
    v *= segment(uv, e, w, b4.xy, b1.xy);
    
    v *= segment(uv, e, w, t1.xy, t2.xy);
    v *= segment(uv, e, w, t2.xy, t3.xy);
    v *= segment(uv, e, w, t3.xy, t4.xy);
    v *= segment(uv, e, w, t4.xy, t1.xy);
    
    v *= segment(uv, e, w, b1.xy, t1.xy);
    v *= segment(uv, e, w, b2.xy, t2.xy);
    v *= segment(uv, e, w, b3.xy, t3.xy);
    v *= segment(uv, e, w, b4.xy, t4.xy);
    
	return v;
}

// Function 602
float double_cubic_seat_linear_blend(vec2 uv, float a, float b)
{
    if (uv.x <= a) {
        return b * uv.x + (1.0 - b) * a * (1.0 - pow(1.0 - uv.x / a, 3.0));

    } else {
        return b * uv.x + (1.0 - b) * (a + (1.0 - a) * pow((uv.x - a) / (1.0 - a), 3.0));
    }
}

// Function 603
float smoothstepLine(float lower, float upper, float value, float width){
    width *= 0.5;
    return smoothstep(lower - width, lower, value) * (1.0 - smoothstep(upper, upper + width, value));
}

// Function 604
vec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)
{
    int sections = 3*int(max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);
    const int maxIterations = 100;//50
    
    float minDist;
    float bestT;
    bool found = false;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        bool failed = false;
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);
            
            if(abs(dt) < 0.1)break;
            
            t -= lerningRate*dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                failed = true;
                break;
            }
        }
        if(failed)continue;
        
        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);
        
        if(lineSqDist <= sq(tkp.r3))
        {
            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);

            if(!found || distAlongD < minDist)
            {
                minDist = distAlongD;
                bestT = t;
            }
            
            found = true;
        }
    }
    
    return vec3(bestT, minDist, found ? 1. : 0.);
}

// Function 605
float sqLineDist(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    return dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));
}

// Function 606
vec3 drawTiles( vec2 p ) {
	// get coords for 8x8 tile
    p.x = mod( p.x + lineScroll(p.y), IRES.x );
    ivec2 i = ivec2( floor(p/8.0) );
    vec2 t = fract(p/8.0)*8.0;
    int ti = map[ i.x + 32*i.y ]*8 + int(t.y);
    int pi = ( atlas[ ti ] >> (int(8.0-t.x)*4) ) & 0xF;		//palette index of pixel in atlas
    return palette_t[pi];
}

// Function 607
void draw( inout vec4 O, vec2 U, float c ) {
    float v = 1. -3.5 * (dot(U,U));      // attention to not cover neighor cells
    if ( v > .2 ) {            
        U = 4.*(U+.12); 
        if ( c < 0. ) O =  vec4(0);                              // erase
        else O.rgb = v * col(c) + .8* max( 0., 1.-3.*dot(U,U) ); // draw
          // O.w = step(.9,v);                                   // mark active
    }
}

// Function 608
float DERRect(in vec3 z, vec4 radii){return length(max(abs(z)-radii.xyz,0.0))-radii.w;}

// Function 609
Rect CreateRect(float x, float y, float w, float h, float z)
{
    Rect rect;
    rect.x = x;
    rect.y = y;
    rect.w = w;
    rect.h = h;
    rect.z = z;
    return rect;
}

// Function 610
vec2 getScreenspaceUvFromRayDirectionWS(
    vec3 rayDirectionWS,
	vec3 cameraForwardWS,
	vec3 cameraUpWS,
	vec3 cameraRightWS,
	float aspectRatio)
{
    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;
    // project rayDirectionWs onto camera forward
    float projDist                 = dot(rayDirectionWS, cameraForwardWS);
    vec3  eyeToPosOnCameraPlaneWS = rayDirectionWS / projDist * kCameraPlaneDist;
    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;

    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);
    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);

    xDist /= aspectRatio;
    xDist = xDist * 0.5 + 0.5;
    yDist = yDist * 0.5 + 0.5;

    return vec2(xDist, yDist);
}

// Function 611
float DistLine( vec2 p , vec2 a , vec2 b ) {

    // Line ba에 Pa를 직교 투영한다.
    
    vec2 pa = p - a;
    vec2 ba = b - a;
    
    float t = clamp( dot( pa , ba ) / dot ( ba , ba ) , 0.0 , 1.0 );
    
    return length( pa - ba * t );
        
}

// Function 612
v0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle
){v1 d = max(tl-uv, uv-br)
 ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}

// Function 613
float cubeCircle(vec3 point, float radius, int count, vec3 cubeSize)
{
	float c = pModPolar(point.xz, float(count));
	float index = floor(c + float(count)/2. -1.);

	return fBox( point-vec3(radius,0,0), cubeSize + vec3(0, 0.3 + 0.7*afFrequencies[int(mod(index,float(afFrequencies.length())))] , 0));
}

// Function 614
bool traceBilinearPatch(vec3 ro, vec3 rd, vec3 pa, vec3 pb, vec3 pc, vec3 pd,
                        inout vec3 outs, inout vec3 outt, inout vec3 outuvi)
{
    vec3 va = pc - pa;
    vec3 vb = (pd - pc) - (pb - pa);
    vec3 vd = ro - pa;
    vec3 vc = pa - pb;

    // Note that the coefficients are in reverse order here. Solving this
    // equation gives 1 / x and avoids a divide-by-zero case for coplanar controlpoints
    // by switching that case to c = 0 instead of a = 0, thus putting the denominator
    // in the solution as -b instead of 0.
    // Thanks to IQ for this trick!
    
    float c = dot(cross(vb, vc), rd);
    float b = dot(cross(va, vc) + cross(vb, vd), rd);
    float a = dot(cross(va, vd), rd);

    float desc = b * b - 4. * a * c;

    if(desc < 0.0)
        return false;

    // Put PA at the origin of the coordinate system

    ro -=pa;

    pc = va;

    pd -= pa;
    pb -= pa;
    pa -= pa;

    float i;
    float u, v;

    // Solve for U at each intersection point, which are two quadratics

    float u0 = (2. * a) / (-b - sqrt(desc));
    float u1 = (2. * a) / (-b + sqrt(desc));

    vec3 pu0 = pb * u0;
    vec3 pu1 = pb * u1;

    // Solve for V at each intersection point, geometrically

    vec3 vv0 = mix(pc, pd, u0) - pu0;
    vec3 m20 = ro - pu0 - vv0 * dot(vv0, ro - pu0) / dot(vv0, vv0);

    vec3 vv1 = mix(pc, pd, u1) - pu1;
    vec3 m21 = ro - pu1 - vv1 * dot(vv1, ro - pu1) / dot(vv1, vv1);


    float v0, v1;

    {
        vec3 n = cross(va + vb * u0, vd + vc * u0);
        vec3 m = cross(n, rd);

        float da = dot(pu0 - ro, m);
        float db = dot(pc + (pd - pc) * u0 - ro, m);

        v0 = da / (da - db);
    }

    {
        vec3 n = cross(va + vb * u1, vd + vc * u1);
        vec3 m = cross(n, rd);

        float da = dot(pu1 - ro, m);
        float db = dot(pc + (pd - pc) * u1 - ro, m);

        v1 = da / (da - db);
    }

    // Solve for the ray intersection distance at each intersection point

    float da20 = dot(ro - pu0, m20);
    float db20 = dot((ro + rd) - pu0, m20);
    float i0 = da20 / (da20 - db20);

    float da21 = dot(ro - pu1, m21);
    float db21 = dot((ro + rd) - pu1, m21);
    float i1 = da21 / (da21 - db21);

    // Resolve which valid intersection point is nearest to ray origin

    if(u0 < 0. || u0 > 1. || i0 < 0. || v0 < 0. || v0 > 1.)
    {
        u = u1;
        v = v1;
        i = i1;
    }
    else if(u1 < 0. || u1 > 1. || i1 < 0. || v1 < 0. || v1 > 1.)
    {
        u = u0;
        v = v0;
        i = i0;
    }
    else
    {
        u = mix(u0, u1, step(i1, i0));
        v = mix(v0, v1, step(i1, i0));
        i = min(i0, i1);
    }

    if(u < 0. || u > 1. || i < 0. || v < 0. || v > 1.)
        return false;

    outuvi = vec3(u, v, i);

    // Surface differentials in worldspace
    outs = pb * u - mix(pc, pd, u);
    outt = pc * v - mix(pb, pd, v);

    return true;
}

// Function 615
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
    
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( abs(1.0-r.y) );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize(rr);
}

// Function 616
float ThirdOrderSpline(float x, float a,float b, float c,float d){
 float cb=c-b; //c=cb+b
 float ad=a-d;
 return (b+.5*x*(cb+b-a+x*(a-b+cb+x*3.*(cb*3.+ad+x*5./3.*(-cb*3.-ad+x*.4*(cb*3.+ad))))));
}

// Function 617
vec4 drawscore(vec2 p, float score)
{
    vec4 c = vec4(0.0);
    for (int i = 0; i < 6; ++i)
    {
        float dig = score;
        float dd = pow(10.0, float(5 - i));
        dig = mod(floor(dig / dd), 10.0);
		c += vec4(digit(dig, (p - vec2(125.0 + float(i) * 20.0, 110.0)) * 0.05));
    }
    
    return c;
}

// Function 618
float rectangle (vec2 uv, float blur, float left, float right, float bottom, float top) {
    float r;
    r = Band (uv.x, left, right, blur);
    r *= Band (uv.y, bottom, top, blur);
    return r;
}

// Function 619
float GetPositionAlongLineNearestToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)
{
	vec2 p = point			- line_segment_a;
	vec2 l = line_segment_b	- line_segment_a;

	float dprod = dot(p,l);
	float len2  = dot(l,l);

	return dprod / len2;
}

// Function 620
float get_distance_along_3d_line_nearest_to_point(
    in vec3 A0,
    in vec3 A,
    in vec3 B0
){
    return dot(B0 - A0, A);
}

// Function 621
void UI_DrawButton( inout UIContext uiContext, bool bActive, bool bMouseOver, Rect buttonRect )
{
	if (!uiContext.bPixelInView)
        return;
    
    if ( bActive && bMouseOver )
    {
    	DrawBorderIndent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );
    }
    else
    {
    	DrawBorder( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );
    }
}

// Function 622
void drawHighBush(int x, int y)
{
	if (y < 0 || y > 6 || x < 0 || x > 15) {
		return;
	}
	
	float col = 0.0; // 0 = transparent

	if (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  5) col = SPRROW(x,0.,0.,0.,0.,1.,1.,2.,2., 2.,2.,1.,1.,0.,0.,0.,0.);
	if (y ==  4) col = SPRROW(x,0.,0.,1.,1.,2.,2.,2.,2., 2.,2.,2.,2.,1.,1.,0.,0.);
	if (y ==  3) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);
	if (y ==  2) col = SPRROW(x,0.,1.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,1.,0.);
	if (y ==  1) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);
	if (y ==  0) col = SPRROW(x,1.,2.,2.,2.,2.,2.,2.,2., 2.,2.,2.,2.,2.,2.,2.,1.);
		
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(87,201,111);
	}
	else if (col == 2.0) {
		fragColor = RGB(100,224,117);
	}
}

// Function 623
vec3 DrawFrame(vec2 p, vec3 bgColor)
{
    vec3 flatN = vec3(0., 0., -1.);
    vec3 color = bgColor;
    float d;
    
    vec3 colorCenter = texture(iChannel1, p.yx*vec2(1., 0.8)).rgb;
    vec3 n = normalize(flatN + GetNormal(colorCenter));
    color = Shade(color, n, v, l, 0.02);
    
    vec3 colorLeft = texture(iChannel1, p.yx).rgb;
    n = normalize(flatN + GetNormal(colorLeft));
    colorLeft = Shade(colorLeft, n, v, l, 1.);
    d = dsBox(p-vec2(-1.65, 0.), vec2(0.095, 0.97), 0.025);
    color = mix(colorLeft, color, smoothstep(0., 0.001, d));
    
    vec3 colorRight = texture(iChannel1, p.yx).rgb;
    n = normalize(flatN + GetNormal(colorRight));
    colorRight = Shade(colorRight, n, v, l, 1.);
    d = dsBox(p-vec2(+1.65, 0.), vec2(0.095, 0.97), 0.025);
    color = mix(colorRight, color, smoothstep(0., 0.001, d));
    
    vec3 colorTop = texture(iChannel1, p.xy).rgb;
    n = normalize(flatN + GetNormal(colorTop));
    colorTop = Shade(colorTop, n, v, l, 1.);
    d = dsBox(p-vec2(+0., 0.87), vec2(1.5, 0.095), 0.025);
    color = mix(colorTop, color, smoothstep(0., 0.001, d));
    
    vec3 colorBottom = texture(iChannel1, p.xy).rgb;
    n = normalize(flatN + GetNormal(colorBottom));
    colorBottom = Shade(colorBottom, n, v, l, 1.);
    d = dsBox(p-vec2(+0., -0.87), vec2(1.5, 0.095), 0.025);
    color = mix(colorBottom, color, smoothstep(0., 0.001, d));
    
    d = length(p-vec2(0., 0.88)+vec2(sin(p.y*50.)*0.0025))-0.05;
    color = mix(vec3(0.), color, smoothstep(0., 0.01, d));
    
    return color;
}

// Function 624
vec3 Outline(vec2 uv)
{
  	vec4 lines= vec4(0.30, 0.59, 0.11, 1.0);

	lines.rgb = lines.rgb * LINES;
	if(iResolution.x < 300.)
	{
		lines /= 4.0;	// improves thumbnail look
	}
	else if(iResolution.x > 1000.)
	{
		lines *= 1.5;
	}
	
 
  	float s11 = dot(texture(iChannel0, uv + vec2(-1.0 / iResolution.x, -1.0 / iResolution.y)), lines);   // LEFT
  	float s12 = dot(texture(iChannel0, uv + vec2(0, -1.0 / iResolution.y)), lines);             // MIDDLE
  	float s13 = dot(texture(iChannel0, uv + vec2(1.0 / iResolution.x, -1.0 / iResolution.y)), lines);    // RIGHT
 

  	float s21 = dot(texture(iChannel0, uv + vec2(-1.0 / iResolution.x, 0.0)), lines);                // LEFT
  	// Omit center
  	float s23 = dot(texture(iChannel0, uv + vec2(-1.0 / iResolution.x, 0.0)), lines);                // RIGHT
 
  	float s31 = dot(texture(iChannel0, uv + vec2(-1.0 / iResolution.x, 1.0 / iResolution.y)), lines);    // LEFT
  	float s32 = dot(texture(iChannel0, uv + vec2(0, 1.0 / iResolution.y)), lines);              // MIDDLE
  	float s33 = dot(texture(iChannel0, uv + vec2(1.0 / iResolution.x, 1.0 / iResolution.y)), lines); // RIGHT
 
  	float t1 = s13 + s33 + (2.0 * s23) - s11 - (2.0 * s21) - s31;
  	float t2 = s31 + (2.0 * s32) + s33 - s11 - (2.0 * s12) - s13;
 
  	vec3 col;
 
	if (((t1 * t1) + (t2* t2)) > 0.04) 
	{
  		col = vec3(-1.,-1.,-1.);
  	}
	else
	{
    	col = vec3(0.,0.,0.);
  	}
 
  	return col;
}

// Function 625
vec2 lineEQ(vec3 p,float t){
	vec2 fx = vec2(0.01);
	float r = 1.0;
	vec3 offset=vec3(0.0);
	p+=offset;
	float cx = clamp(p.x,-r,r);
	fx.x = p.y;
	fx.x *= fx.x;
	fx.x /= min(fx.y,abs(abs(cx)-r));
	
	return fx;
}

// Function 626
float Circle(vec2 uv, vec2 p, float r, float blur) {
    
    float d = length(uv - p); //distance, -p remaps that to be origin
    float c = smoothstep(r, r-blur, d); //blurs the edges
    
    return c;
}

// Function 627
float poscircle (vec2 p , float r, vec2 pos)
{
 //subtracts positive or negative to the starting position at 0.0, 0.0
 //substraction so that positive vec means positive movement from origin
 p-=pos;
 return length(p) - r;
}

// Function 628
ivec2 fromLinear(in int index, in vec2 resolution) {
    //index -= 1;
    return ivec2(index % int(resolution.x), index / int(resolution.x));
}

// Function 629
float sdRoundRect( vec2 p, vec2 b, float r )
{
  vec2 q = abs(p) - (b-r);
  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;
}

// Function 630
float DrawPoint(vec2 origin, vec2 uv, float size){
  float d = distance(uv, origin);
  return clamp(smoothstep(size, size + 0.001, d), 0. ,1.); 
}

// Function 631
vec3 getDirection(float fov, vec2 fragCoord, vec2 screenSize) {
    vec2 xy = fragCoord - screenSize / 2.;
    float z = screenSize.y / 2. / tan(radians(fov / 2.));
    return normalize(vec3(xy, -z));
}

// Function 632
type project_on_line1( type P, type O, type d ) { return O + d * dot( P - O, d ); }

// Function 633
vec3 LinearToSRGB(vec3 color )
{
	vec3 sRGBLo = color * 12.92;
    const float powExp = 1.0/2.4;
	vec3 sRGBHi = ( pow( abs ( color ), vec3(powExp, powExp, powExp)) * 1.055) - 0.055;
	vec3 sRGB;
    sRGB.x = ( color.x <= 0.0031308) ? sRGBLo.x : sRGBHi.x;
    sRGB.y = ( color.y <= 0.0031308) ? sRGBLo.y : sRGBHi.y;
    sRGB.z = ( color.z <= 0.0031308) ? sRGBLo.z : sRGBHi.z;
	return sRGB;
}

// Function 634
vec4 drawMouse(in vec2 fragCoord)
{
    vec4 color = vec4(0.0);
    
    vec2 uv = fragCoord / iResolution.xy;
    vec3 lastMouseClick = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;
    
    float clickCircle = Sharpen(distance(uv, lastMouseClick.xy), 0.01, 1.0);
    color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), clickCircle);
    
    if(lastMouseClick.z > 0.5)
    {
        vec2 totalDelta   = (iMouse.xy / iResolution.xy) - lastMouseClick.xy;
        vec4 lastDelta    = texelFetch(iChannel0, ivec2(0, 3), 0);
        vec2 currentDelta = totalDelta - lastDelta.zw;
        
    	float lastDeltaLine = Line(uv, lastMouseClick.xy, lastMouseClick.xy + lastDelta.zw, 0.005);
        color = mix(color, vec4(0.0, 1.0, 0.0, 1.0), lastDeltaLine);
        
        float currentDeltaLine = Line(uv, lastMouseClick.xy + lastDelta.zw, lastMouseClick.xy + lastDelta.zw + currentDelta, 0.005);
    	color = mix(color, vec4(1.0, 0.0, 0.0, 1.0), currentDeltaLine);
    }
    
    return color;
}

// Function 635
float draw_uint_with_sign(vec2 p, int number, bool negative){
    // draw sign
    float color = draw_char(p, negative ? MINUS_SIGN : PLUS_SIGN);
    p.x += DIGIT_WIDTH;
    
    // draw uint
    color += draw_uint(p, number);
    
    return color;
}

// Function 636
void drawSidewalk(in vec2 uvCoords, inout vec4 canvas)
{
    float s = step(0.85 * (0.015 - uvCoords.y), abs(uvCoords.x) / getAspectRatio()) * step(0.0, -uvCoords.y);
    vec4 sidewalk = vec4(0.8 * (0.5 + uvCoords.y),
                 		 0.6 * (0.5 + uvCoords.y),
                 		 1.3 * (0.5 + uvCoords.y),
                 		 1.0);
    
    canvas = mix(canvas, sidewalk, s);
}

// Function 637
vec3 drawSidebar(vec2 p
){p.x-=1.
 ;p.x*=iResolution.y / iResolution.x
 ;float t=texture(iChannel0,p).x
 ;vec3 r=vec3(0.85)
 ;r=mix(color(1.),r,pow(smoothstep(0.,.004,absCircular(p.x - t)),3.))//lines red
 ;r=mix(color(.4),r,pow(smoothstep(0.,.04 ,absCircular(p.y*6.0)),3.))//lines blue
 ;return r;}

// Function 638
float Line(vec2 p, vec2 a, vec2 b) {
    
    float d = DistLine(p, a, b);
    float m = S(.03, .01, d);
    float d2 = length(a-b);
    m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2 - .75));
    return m;
}

// Function 639
vec3 LinearToSRGB ( vec3 col )
{
    return mix( col*12.92, 1.055*pow(col,vec3(1./2.4))-.055, step(.0031308,col) );
}

// Function 640
float outline(in vec2 uv, in float aBase) {
    vec2 uvPixel = 1.0/iResolution.xy;
    float n = 0.0;

    outlineCheck(uv + vec2( 1.0, 0.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2( 0.0, 1.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2( 0.0,-1.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2(-1.0, 0.0)*uvPixel, 0.125, aBase, n);

    outlineCheck(uv + vec2( 1.0, 1.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2( 1.0,-1.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2(-1.0, 1.0)*uvPixel, 0.125, aBase, n);
    outlineCheck(uv + vec2(-1.0,-1.0)*uvPixel, 0.125, aBase, n);

    return n;
}

// Function 641
float sdCircle(in vec2 pos, in float radius, in float halo)
{
  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);
}

// Function 642
float draw_tiles2(vec2 uv,float seed) {
    float random_tile = floor(rand(floor(uv)+(seed/0.12))*4.);
    if (random_tile == 0.) {
        return tile_3(fract(uv));
    }
    if (random_tile == 1.) {
        return tile_4(fract(uv));
    }
    if (random_tile == 2.) {
        return 1.-tile_3(fract(uv));
    }
    if (random_tile == 3.) {
        return 1.-tile_4(fract(uv));
    }
    return 0.;
}

// Function 643
float gamma_to_linear(float f)
{
#if USE_GAMMA_CORRECTION == 2
    return f * f;
#elif USE_GAMMA_CORRECTION == 1
    return f <= 0.04045 ? f * (1./12.92) : pow((f + 0.055) * (1./1.055), 2.4);
#else
    return f;
#endif
}

// Function 644
light directionLight(vec3 direction, vec3 color, float intensity) {
    return light(
        DIRECTION_LIGHT, // type
        vec3(0.0), // position (N/A)
        color, // color
        intensity, // intensity
        direction, //direction
        0.0, // falloff (N/A)
        0.0, // spread (N/A)
        0.0 // taper (N/A)
    );
}

// Function 645
vec3 draw(vec3 buffer, float dist, float radius, vec3 color)
{
    float up = min(iResolution.x, iResolution.y);
    dist *= up;
    const float scale =  1.0 / 360.0;
    radius *= up * scale;
  	float aa = 0.5 * fwidth(dist);
    vec3 mixed = mix(buffer, color, smoothstep(radius + aa, radius - aa, dist));
   	
    return mixed;
}

// Function 646
vec3 lineInt(vec3 a1, vec3 a2, vec3 b1, vec3 b2) {
    vec3 ad = normalize(a2 - a1);
    vec3 bd = normalize(b2 - b1);
    vec3 ap = rejectUAfromUB(ad, bd);
    // solve (b1 + t(b2-b1) - a1) . ap = 0;
    // b1.ap + t(b2-b1).ap - a1.ap = 0
    // t(b2-b1).ap = a1.ap - b1.ap
    // t = (a1-b1).ap / (b2-b1).ap
    float t = dot(a1 - b1, ap) / dot(b2 - b1, ap);
    return b1 + t * (b2 - b1);
}

// Function 647
void drawLine(inout vec3 color, in vec3 lineColor, in vec2 p, in vec2 a, in vec2 b) {
     float unit = 2.0 / iResolution.y;
 
     vec2 pa = p - a, ba = b - a;
     float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
     float d = length(pa - ba * h);
 
     color = mix(color, lineColor, smoothstep(unit, 0.0, d));
}

// Function 648
vec3 Linear_from_ACEScct(vec3 cct) 
{
    return vec3(Linear_from_ACEScct(cct.r),
                Linear_from_ACEScct(cct.g),
                Linear_from_ACEScct(cct.b));
}

// Function 649
float circleSDF(vec2 st) {
    return length(st-.5)*2.;
}

// Function 650
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 res = vec2(-1.0);

    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    // if edges are parallel, this is a linear equation. Do not this test here though, do
    // it in the user code
    //if( abs(k2)<0.001 )
    //{
	//	  float v = -k0/k1;
	//    float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);
    //    
    //    if( v>0.0 && v<1.0 && u>0.0 && u<1.0 )  res = vec2( u, v );
    //}
	//else
    {
        // otherwise, it's a quadratic
        float w = k1*k1 - 4.0*k0*k2;
        if( w<0.0 ) return vec2(-1.0);
        w = sqrt( w );

        #if 1
            float ik2 = 0.5/k2;
            float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;
            float u = (h.x - f.x*v)/(e.x + g.x*v);
            if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);
            res = vec2( u, v );
		#else
            float v1 = (-k1 - w)/(2.0*k2);
            float v2 = (-k1 + w)/(2.0*k2);
            float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);
            float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);
            bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;
            bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;

            if(  b1 && !b2 ) res = vec2( u1, v1 );
            if( !b1 &&  b2 ) res = vec2( u2, v2 );
		#endif
    }
    
    return res;
}

// Function 651
vec3 drawTree(vec2 position, vec3 treePosition)
{
    vec3 color = BRIGHT_LEAVES;
    
    // luminosity factor is the same for all the tree (it doesn't depend on pixel's y coordinate)
    float dayTime = DayTimeOf(0.25);
    float luminosityFactor = 1. - mapCos(cos(dayTime / 12. * M_PI + treePosition.z * 2. - 0.35), 0., 0.9);
    
    // draw leaves
    // draws bright leaves
    vec2 leavesCenter = vec2(treePosition.x, 1. - treePosition.z);
    float treeLeavesRadius = LEAVES_RADIUS * mapCos(cos(time / 3. + treePosition.z * 23.), 0.7, 1.3);
    float maxLeaveDist =
        mapCos(
            cos(50. * ((treePosition.z + 0.1) * 10. +
                       (RandomSign(treePosition.z, treePosition.y) * position.x + position.y) * 2.6 +
                       (RandomSign(treePosition.y, treePosition.z) * time / 5.)))
            , 0., treeLeavesRadius);
    maxLeaveDist *= mapCos(cos(time / 5. + treePosition.z * 13.), 0.6, 1.);
    color *= smoothstep(maxLeaveDist + 0.05, maxLeaveDist, length(leavesCenter - position));
    // draws dark leaves
    if (color == BLACK)
        color = DARK_LEAVES * smoothstep(treeLeavesRadius + 0.05, treeLeavesRadius, length(leavesCenter - position));
    // changes luminosity
    color *= luminosityFactor;
    
    if (color != BLACK)
    	return color;
    
    // draw trunc
    // defines left and right bounds for trunc
    float treeTruncWidth = TRUNC_WIDTH + mapCos(cos(treePosition.z * 10. + iTime / 10.), -TRUNC_WIDTH * 0.2, TRUNC_WIDTH * 0.4);
    float lowerTruncBound = treePosition.x + treeTruncWidth * (cos(cos((treePosition.x + treePosition.z) * 10.) * 5. * (position.y)) / 5. - 1.);
    float upperTruncBound = treePosition.x - treeTruncWidth * (cos(cos((treePosition.x + treePosition.z) * 10.) * 5. * (position.y) + M_PI / 2.) / 5. - 1.);
    // generates ground
    float groundExpantion = exp(-40. * (position.y - treePosition.z * 0.25)) * 10.;
    lowerTruncBound -= groundExpantion;
    upperTruncBound += groundExpantion;
    // generates intern trunc pattern
    float truncSmoothstep = smoothstep(lowerTruncBound, upperTruncBound, position.x);
    color = truncSmoothstep * (1. - truncSmoothstep) * TRUNC *
			cos(position.y * position.x * (1.01 - treePosition.z) * TRUNC_PATTERN_REPET * 5000. *
                cos(position.x + position.y + treePosition.z * 1000. + time / 25.));
    // changes luminosity
    color *= luminosityFactor * 22.5;
    // adds smooth to bottom of ground
    color *= smoothstep(0., 0. + GROUND_HEIGHT, position.y);
    // limits trunc height
    color *= smoothstep(1. - treePosition.z + GROUND_HEIGHT, 1. - treePosition.z, position.y);
    
    return color;
}

// Function 652
vec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )
{
    // We could expand the powers and build a matrix instead (twice as many coefficients
    // would need to be stored, but it could be faster.
    return c0 * dot( cb, powers(x + 1.0)) + 
           c1 * dot( ca, powers(x      )) +
           c2 * dot( ca, powers(1.0 - x)) +
           c3 * dot( cb, powers(2.0 - x));
}

// Function 653
vec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){

    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +
            (p0*2. - p1*5. + p2*4. - p3)*t*t +
            (-p0 + p2)*t + p1*2.)*.5;
}

// Function 654
float sdf_line1(vec2 uv, vec2 vert_A, vec2 vert_B){
    float slope = (vert_B.y - vert_A.y) / (vert_B.x - vert_A.y);
    float standard_form = slope * uv.x - uv.y + vert_A.y - slope * vert_A.x;
    float norm = sqrt(slope * slope + 1.);
    return standard_form / norm;
}

// Function 655
float smooth_circle(vec2 p, float r, float smoothness) {
    float dist = length(p) - r;
    float s = smoothness / 2.0;
    return 1.0 - smoothstep(r - s, r + s, dist);
}

// Function 656
vec3 linearDodge( vec3 s, vec3 d )
{
	return s + d;
}

// Function 657
void drawPentagon(Ray ray, inout TraceResult cur_ctxt, Pentagon Pent1)
{
    drawTriangle(ray, cur_ctxt, Pent1.Triangle1);
    drawTriangle(ray, cur_ctxt, Pent1.Triangle2);
    drawTriangle(ray, cur_ctxt, Pent1.Triangle3);
}

// Function 658
void drawSprite_32x32( inout vec3 col, int spr[128], vec3 pal[16], vec2 p, vec2 s ) {
    ivec2 i = ivec2( floor(p-s) );
    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<32 ) {
        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;
        if (pal[pi].r>-0.5) col = pal[pi];
    }
}

// Function 659
float linearDodge (float target, float blend){
    return target + blend;
}

// Function 660
ColorArray Bilinear_insert(vec2 index2D,DataBlock Blocks[4]){
    ColorArray tmp;
    vec4 biliner = vec4(0.);
    for(int y = 0;y<4;y++)
        for(int x = 0;x<4;x++)
        	if(float(y) == index2D.y && float(x) == index2D.x)
                biliner = BiLiner[y][x];
    tmp.A = (matMaker(Blocks[0].A,Blocks[1].A,Blocks[2].A,Blocks[3].A)*biliner).rgb;
    tmp.B = (matMaker(Blocks[0].B,Blocks[1].B,Blocks[2].B,Blocks[3].B)*biliner).rgb;
    return tmp;
}

// Function 661
float circle(vec2 p, float r) {
    float c = length(p) - r;
    return smoothstep(r + 0.01, r, c);
}

// Function 662
void DrawBallEffect(vec2 p, vec3 ballColor, inout vec4 color)
{
    vec4 sceneColor = color;
    
    p *= vec2(1.+noise(ballColor.xx), 1.+noise(ballColor.yy));
    p *= vec2(1., 0.75);
    
    p.x *= 1. + max(-p.y*28., 0.)*0.2;
    
    p.y += 0.25;
    float noise = fbm(p*12.+gT*2.);
    float d = max(abs(p.x)-noise*0.06, abs(p.y)-noise*0.20);
    vec4 colorTemp = mix(vec4(ballColor*0.4+color.rgb*0.6, hash(gT*0.1) * 3.0), color, smoothstep(0., noise*0.15, d));
    color.rgb = colorTemp.rgb; color.a = max(color.a, colorTemp.a);
    
    p.y += -0.05;
    noise = fbm(p*34.-gT*4.);
    d = max(abs(p.x)-noise*0.035, abs(p.y)-noise*0.25);
    colorTemp = mix(vec4(ballColor, hash(gT*0.1) * 3.0), color, smoothstep(0., noise*0.15, d));
    color.rgb = colorTemp.rgb; color.a = max(color.a, colorTemp.a);
    
    // fade by height
    color = mix(sceneColor, color, smoothstep(-0.3, 0.3+sin(p.y*20. + color.r*10. + gT*4.)*0.25, p.y));
}

// Function 663
void DrawExplosion(int id, RayHit marchResult, inout vec3 color, vec3 rayDir, vec3 rayOrigin)
{
  Explosion explosion;
  id *= 100;
  explosion.life = read(ivec2(122+id, 0));

  // check if explosion has been spawned
  if (explosion.life>0.)
  {  
    explosion.pos = readRGB(ivec2(120+id, 0)); 

    vec3 testPoint = explosion.pos-planePos;
    // ensure the explosions starts on ground
    // explosion.pos.y=GetTerrainHeight(testPoint);

    // explosion light flash    
    if (marchResult.hit)
    {
      float intensity = GetExplosionIntensity(explosion);

      vec3 testCol = color.rgb+vec3(1.0, 0.59, 0.28)*2.5;
      color.rgb=mix(color.rgb, mix(testCol, color.rgb, smoothstep(0., 40.0*intensity, distance(testPoint.xz, marchResult.hitPos.xz))), intensity);
    }

    // trace explosion  
    RayHit exploTest = TraceExplosion(rayOrigin, rayDir, 68, explosion);   
    if (exploTest.hit)
    {
      color.rgb = GetExplosionColor(clamp(0.5+((fbm((exploTest.hitPos + vec3(1, -2, -1)*iTime)*0.5))), 0.0, 0.99));
      color.rgb = mix(color.rgb, color.rgb*0.45, smoothstep(0., 12., distance(exploTest.hitPos.y, GetTerrainHeight(testPoint))));
    }

    color.rgb = mix(color.rgb*3.0, color.rgb, smoothstep(0., 12.4, exploTest.dist));
  }
  ////////////////////////////////////////////////////////////
}

// Function 664
float  dTrampoline(in vec3 pos, in float r, in float d)
{
  vec3 p = pos;
  float d1 = 1.;  
  float t = fract(speedJump * time);
  float push = -ballSize * sinc(42. * t); // Ð’Ð¸Ð±Ñ€Ð°Ñ†Ð¸Ñ Ð¿Ð¾ÑÐ»Ðµ Ð¿Ñ€Ñ‹Ð¶ÐºÐ°
 
   float y = getY(p.xz, push, heightJump); 
   p.y -= y ;
   d1=  yCylinder(p, vec2(r*7., 0.02));      // Ð¡Ð°Ð¼ Ð±Ð°Ñ‚ÑƒÑ‚
   d =  distMat(d,  d1   ,  7.0, false );    
   d1 = dTorus(p, vec2(r*7., r*0.4));         // ÐšÑ€Ð°Ð¹ Ð±Ð°Ñ‚ÑƒÑ‚Ð°
   d =  distMat(d,  d1   ,  4.0, false ); 
   //----------
   p = pos + vec3(0.,r*2., 0.);

   p.xz = rotsim( p.xz, 6.);
   p.xz = abs(p.xz); 
   p.z -= r*7.;
   p.xy = rot(p.xy, 0.5);    
   d1 = capsuleY(p, r*0.4, r*2.5);       // ÐÐ¾Ð¶ÐºÐ¸
   d =  distMat(d,  d1   ,  1.0, false);     
   //----------  
  return d;
}

// Function 665
vec3 draw_second(vec2 uv) 
{
    float secondCenter = fract(floor(iDate.w) / 60.);
    float f = abs(uv.x - secondCenter);
    
    float lightBeam = max(smoothstep(0., 1., uv.y), 4. * smoothstep(.001, .0, pow(uv.y, 1.5)));    
    float beamSpread = .001;    
    lightBeam *= smoothstep( SECOND_WIDTH + beamSpread, SECOND_WIDTH - beamSpread, f);
    
    float lightIntensity = lightBeam * 6.2;
    lightIntensity += .8 * smoothstep(.1, .0, uv.y) * smoothstep(.05, .0, abs(uv.x - secondCenter)); 
    
    lightIntensity *= atmos( 5.5 * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth
    
    return vec3(1., .12, .1) * lightIntensity;
}

// Function 666
vec4 draw_sprite_flame(vec2 uv){
    // Engine flame. Note, normaldata invalid and SDF does not have unit gradient.
    uv = (uv - 0.5);

    uv.y -= 0.25;
    
    if (uv.y < 0.0) {
        // Stretch and taper the coordinate system
    	uv.y /= (1.0 - uv.y) * 4.0;
        uv.x /= (1.0 + 10.0 * uv.y);
    }
    
    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);
    outp = n_union(outp, line_segment(uv, vec2(-0.025, 0.0), vec2(0.025, 0.0)));
    
    outp.b = sqrt(outp.b);

    return outp;
}

// Function 667
float line( vec3 p, vec3 a, vec3 b, float radius, inout vec4 mate)
{
	vec3 ba = b - a;
	vec3 pa = p - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h ) - radius;
}

// Function 668
float drawFract(v1 p,int d){return drawFract(p,d,0.);}

// Function 669
float LinearToSRGB(float value)
{
	if (value <= 0.0031308)
		return value*12.92;
	else
		return 1.055*pow(value, 1.0/2.4) - 0.055;
}

// Function 670
vec4 drawElements(in float x, in float y)
{
    // Reuse some variables.
    vec4 result = drawFarClouds(x,y);
    vec4 element = drawNearClouds(x,y);
    
    result = mix(result, element, element.a);
    element = drawSmallCloud(x,y);
    result = mix(result, element, element.a);
    element = drawBirds(x,y);
    result = mix(result, element, element.a);
    element = drawBoat(x,y);
    result = mix(result, element, element.a);
    element = drawShore(x,y);
    result = mix(result, element, element.a);
    element = drawYumetarou(x,y);
    result = mix(result, element, element.a);
    #ifdef DRAW_WAVES
    element = drawWaves(x,y);
    result = mix(result, element, element.a);
    #endif
    return result;
}

// Function 671
vec3 LinearToSRGB(vec3 x) 
{
    vec3 t = step(x,vec3(0.0031308));
    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);
}

// Function 672
float get_airliner( Ray view_ray, float alt, float cruising_speed_fraction, float d, vec2 mv // normalized please
     , float tan_half_fovy, float time_offset, float direction, float trail_fade, float time )
{
//	cruising_speed_fraction *= 5.; // DEBUG
 float airliner_cruising_speed = cruising_speed_fraction * ( 950000. / ( 60. * 60. ) ); // m/s
 float R1 = 5. * alt * tan_half_fovy; // make all trajectory disks roughly same radius from ground
 float R2 = R1 * 1.4;
 float fade_time = 1.;
 float h1 = sqrt( R1 * R1 - d * d );
 float h2 = sqrt( R2 * R2 - d * d );
 vec2 O = vec2( 0., 0 );
 vec2 c = O + mv * d;
 vec2 travel_direction = perp( mv ) * direction;
 float looptime = 2. * h2 / airliner_cruising_speed;
 float rt = mod( time + time_offset, looptime );
 float u = rt * airliner_cruising_speed;
 vec3 plane_pos = vec3( c + travel_direction * ( u - h2 ), alt );
 float t = plane_trace_z( view_ray, alt, 0. ); // epsilon zero, we don't care it's in the sky
 vec3 it = view_ray.o + view_ray.d * t;
 float dd = length( it.xy );
 float x = dot( it.xy - plane_pos.xy, -travel_direction ) - 47.;
 float y = abs( dot( it.xy - plane_pos.xy, perp( travel_direction ) ) );
 float fade = smoothstep( h2, h1, abs( u - h2 ) );
 float trail_disk_fade = smoothstep( R2, R1, dd );
 // note: y is already symmetrized
 float trail_half_spacing = 9.;
 float dc = exp_decay( x * 0.02 );
 float engine_trail = ( x < 0. ? 0. : smoothstep( 2., -1., abs( y - trail_half_spacing ) - dc * 4. ) )
 // trail distance decay
  * exp( -x * 0.00175 );
 float trail = engine_trail * fade * trail_disk_fade * trail_fade;
 float debug = 0.;
 vec2 uv = ( it - plane_pos ).xy * ( 20. / 64. ); // plane outline sdf to scale
 if ( length( uv ) > 12. ) return debug + trail + 0.; // outside plane sdf's disk
 return debug + trail + fade * smoothstep( 0.1, -0.1, sd_airliner_a350( rotate_with_unit_vector( uv, vec2( travel_direction.x, -travel_direction.y ) ) ) ); // plane
}

// Function 673
float sdCircle( in vec2 p, in vec2 c, in float r )
{
    return distance(p,c) - r;
}

// Function 674
vec3 drawZoom ( vec2 fragCoord, vec3 color ) 
{
    // "Z=x" text, where x = the zoom factor
    gvPrintCharXY = vec2( 1.0, iResolution.y - gvFontSize.y - 1.);
    
    //color = drawStatus( color, fragCoord, nameLit, equalsLit );
    color = Char( color, COLOR_ZOOM  , fragCoord, 90.0); // Z
    color = Char( color, COLOR_EQUALS, fragCoord, 61.0); // =

    // show Zoom factor in upper-left
    color = Char( color, COLOR_ZOOMFACTOR, fragCoord, ZOOM);
    return color;
}

// Function 675
float sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {
    vec2 pa = p - a, ba = b - a;
    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;
}

// Function 676
vec3 getInnerLimitCircle()
{
    float theta = pi / float(numCircles - 1);
    float r0 = tan(theta);
    float r1 = 1. / cos(theta);
    float r = (r1 - r0) * tan(theta);
    float r2 = (r1 - r0) / cos(theta);
    return vec3(0., 0., r2 - r);
}

// Function 677
float IsGridLine(vec2 fragCoord)
{
	vec2 vPixelsPerGridSquare = vec2(32.0, 32.0);
	
	vec2 vScreenPixelCoordinate = fragCoord.xy;
	
	vec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);

	vec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;

	vec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(2.3));
	
	float fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);

	return fIsGridLine;
}

// Function 678
void draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {
	vec3 D = normalize(M*vec3(1.,pos));		// ray
	
	vec3 P,N; 
	if (! intersect_ellipsoid(O,D, P,N,l)) return;
	
	vec3 Pm = P+.5*l*D,                		// .5: deepest point inside cloud. 
		 Nm = normalize(Pm/(R*R)),     		// it's normal
	     Nn = normalize(P/R);
	float nl = clamp( dot(N,L),0.,1.), 		// ratio of light-facing (for lighting)
		  nd = clamp(-dot(Nn,D),0.,1.); 	// ratio of camera-facing (for silhouette)


	float ns = fbm(P), ni = fbm(Pm+10.);
	float A, l0 = 3.;
	//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette
	l = clamp(l-6.*ni,0.,1e10);
	float As = pow(ks*nd, ps), 			 	 // silhouette
		  Ai = 1.-pow(.7,pi*l);              // interior


	As =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);
	if (mode==2) 
		A = 1.- (1.-As)*(1.-Ai);  			// mul Ti and Ts
	else
		A = (mode==0) ? Ai : As; 
	A = clamp(A,0.,1.); 
	nl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));

	#if 0 // noise bump
	N = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); 
	nl = clamp( dot(N,L),0.,1.);
#endif
	
	vec4 col = vec4(mix(nl,1.,AMBIENT));
	FragColor = mix(FragColor,col,A);
}

// Function 679
float lineSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return 1.0-smoothstep(0.0, 2.0 / iResolution.x, length(pa - ba*h));
}

// Function 680
vec3 gamma_correction(vec3 RGB) {
    float gamma = 2.2;
    return pow(RGB, vec3(1./gamma));
}

// Function 681
vec4 put_text_drawmap(vec4 col, vec2 uv, vec2 pos, float scale)
{
	float unit = asp * scale * 0.1;
    float h = 0.;
    vec2 sc = vec2(unit, unit*0.8);
    
    // S
    h = max(h, word_map(uv, pos, 83, sc));
    // h
    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 104, sc));
    // o
    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 111, sc));
    // w
    h = max(h, word_map(uv, pos+vec2(unit*1.2, 0.), 119, sc));
    // M
    h = max(h, word_map(uv, pos+vec2(unit*2.0, 0.), 77, sc));
    // a
    h = max(h, word_map(uv, pos+vec2(unit*2.4, 0.), 97, sc));
    // p
    h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 112, sc));
    
    
    col = mix(col, vec4(1.-vec3(h), 1.), h);
    
    return col;
}

// Function 682
void lineCircleInt3(vec3 C, float r, vec3 p1, vec3 p2, out vec3 a1, out vec3 a2) {
    // solve length(p1 + t(p2-p1) - C) = r for t
    // d = p2 - p1
    // q = p1 - C
    // length(td+q) = r
    // (td + q).(td + q) = r*r
    // tt*d.d + t*2d.q + q.q - r*r = 0
    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r
    vec3 d = p2 - p1;
    vec3 q = p1 - C;
    float a = dot(d, d); // cannot be negative
    float b = 2. * dot(d, q); // can be negative
    float c = dot(q, q) - r*r;
    // x = (-b +- sqrt(b*b - 4ac)) / 2a
    // since line intersects circle, discrim must be >= 0
    float discrim = max(0., b * b - 4. * a * c);
    discrim = sqrt(discrim);
    float t1 = ( -b - discrim ) / (2. * a);
    float t2 = ( -b + discrim ) / (2. * a);
    a1 = p1 + t1 * d;
    a2 = p1 + t2 * d;
}

// Function 683
vec4 ScanlinePincushion(vec2 UV)
{
	vec4 InTexel = Deconverge(UV);
	
	vec2 PinUnitCoord = UV * Two.xy - One.xy;
	float PincushionR2 = pow(length(PinUnitCoord), 2.0);
	vec2 PincushionCurve = PinUnitCoord * PincushionAmount * PincushionR2;
	vec2 BaseCoord = UV;
	vec2 ScanCoord = UV;
	
	BaseCoord *= One.xy - PincushionAmount * 0.2; // Warning: Magic constant
	BaseCoord += PincushionAmount * 0.1;
	BaseCoord += PincushionCurve;
	
	ScanCoord *= One.xy - PincushionAmount * 0.2; // Warning: Magic constant
	ScanCoord += PincushionAmount * 0.1;
	ScanCoord += PincushionCurve;
	
	vec2 CurveClipUnitCoord = UV * Two.xy - One.xy;
	float CurvatureClipR2 = pow(length(CurveClipUnitCoord), 2.0);
	vec2 CurvatureClipCurve = CurveClipUnitCoord * CurvatureAmount * CurvatureClipR2;
	vec2 ScreenClipCoord = UV;
	ScreenClipCoord -= Half.xy;
	ScreenClipCoord *= One.xy - CurvatureAmount * 0.2; // Warning: Magic constant
	ScreenClipCoord += Half.xy;
	ScreenClipCoord += CurvatureClipCurve;
	
	// -- Alpha Clipping --
	if (BaseCoord.x < 0.0) return vec4(0.0, 0.0, 0.0, 1.0);
	if (BaseCoord.y < 0.0) return vec4(0.0, 0.0, 0.0, 1.0);
	if (BaseCoord.x > 1.0) return vec4(0.0, 0.0, 0.0, 1.0);
	if (BaseCoord.y > 1.0) return vec4(0.0, 0.0, 0.0, 1.0);
	
	// -- Scanline Simulation --
	float InnerSine = ScanCoord.y * iChannelResolution[0].y * ScanlineScale;
	float ScanBrightMod = sin(InnerSine * Pi + ScanlineOffset * iChannelResolution[0].y);
	float ScanBrightness = mix(1.0, (pow(ScanBrightMod * ScanBrightMod, ScanlineHeight) * ScanlineBrightScale + 1.0) * 0.5, ScanlineAmount);
	vec3 ScanlineTexel = InTexel.rgb * ScanBrightness;
	
	// -- Color Compression (increasing the floor of the signal without affecting the ceiling) --
	ScanlineTexel = Floor + (One.xyz - Floor) * ScanlineTexel;
	
	return vec4(ScanlineTexel, 1.0);
}

// Function 684
float circle (vec2 p, float r, float g)
{

    float d = length(p / r);

    float ss = S(.32,.32 - g,d);
    
    ss = max(0.,ss);
    return ss;

}

// Function 685
void drawHLine(ivec2 uv, const int y, const int height, vec3 color, inout vec3 f) {
	if (uv.y >= y && uv.y < y + height) f = color;
}

// Function 686
vec3 closestPtLine(vec3 p, vec3 pLine, vec3 nLine) {
	return pLine + nLine * dot(p - pLine, nLine);
}

// Function 687
ivec2 circle4(int i)
{
    i = (i%4 + 4) % 4;
    return ivec2((1 - i) * ((i+1) % 2), (2 - i) * (i % 2));
}

// Function 688
void drawTitle(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)
{
    // Draw title bar box
    drawBox(color, TITLE_FILL, BORDER_STROKE, fragCoord, position, size);
    
    // Draw system buttons
    drawSystemButton(color, fragCoord, position, vec2(size.y, size.y), SYSTEM_BUTTON_MENU);
    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y - size.y + 1.0, position.y),
                                       vec2(size.y, size.y), SYSTEM_BUTTON_MINIMIZE);
    drawSystemButton(color, fragCoord, vec2(position.x + size.x - size.y, position.y),
                                       vec2(size.y, size.y), SYSTEM_BUTTON_MAXIMIZE);
}

// Function 689
vec3 drawFractal( in float k, in vec2 fragCoord )
{
    vec3 col = vec3(0.0);
    
#if AA>1
    for( int m=0; m<AA; m++ )
    for( int n=0; n<AA; n++ )
    {
        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;
#else    
        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;
#endif

        vec2 c = p * 1.25;

        #if 0
        if( k==2.0 )
        {
        float c2 = dot(c, c);
        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm
    	if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) continue;
    	// skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm
    	if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) continue;
        }
        #endif
        
        const float threshold = 64.0;
        vec2 z = vec2( 0.0 );
        float it = 0.0;
        for( int i=0; i<100; i++ )
        {
            z = cpow(z, k) + c;
            if( dot(z,z)>threshold ) break;
            it++;
        }

        vec3 tmp = vec3(0.0);
        if( it<99.5 )
        {
            float sit = it - log2(log2(dot(z,z))/(log2(threshold)))/log2(k); // http://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm
            tmp = 0.5 + 0.5*cos( 3.0 + sit*0.075*k + vec3(0.0,0.6,1.0));
        }
        
        col += tmp;
#if AA>1
    }
    col /= float(AA*AA);
#endif

	return col;
}

// Function 690
float drawObject(in vec3 p){
  
    p = fract(p)-.5;
    return dot(p, p);
    
}

// Function 691
vec4 drawSword( vec2 uv, int level ) {
    uv = floor(fract(uv)*32.) - 16.;
        float l = step(abs(uv.y), .5); 
        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   
        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));
                        
	    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));
        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );
        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );
        col = mix( scol, col, step(uv.x, -8.));        
        
        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );
}

// Function 692
vec3 direction(ray r) {return r.B; }

// Function 693
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 res = vec2(-1.0);

    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    // if edges are parallel, this is a linear equation. Do not this test here though, do
    // it in the user code
    if( abs(k2)<0.001 )
    {
        float v = -k0/k1;
        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);
        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) 
            res = vec2( u, v );
    }
	else
    {
        // otherwise, it's a quadratic
        float w = k1*k1 - 4.0*k0*k2;
        //if( w<0.0 ) return vec2(-1.0);
        w = sqrt( w );

        float ik2 = 0.5/k2;
        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;
        float u = (h.x - f.x*v)/(e.x + g.x*v);
        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);
        res = vec2( u, v );
    }
    return (res);
}

// Function 694
void drawGradientRect(vec2 pos, vec2 size, float t, vec4 startCol, vec4 endCol)
{
	vec2 inside = step(pos, xy) * step(xy, pos + size);
	mixColor(mix(startCol, endCol, t), inside.x * inside.y);
}

// Function 695
vec3 DrawBg(vec2 p)
{
    vec3 color = mix(vec3(0.850, 0.882, 0.905), vec3(0.050, 0.439, 0.772), pow(abs(p.y-3.)*0.15, 1.8));
    
    // Rainbow
    vec2 q = p + vec2(0., -10.)*(1.-smoothstep(0., 1., gT-0.8));
    q -= vec2(2., 5.);
    q = Rot(q, 0.5);
    q.x *= 0.8;
    
    float d = abs(length(q+vec2(sin(atan(q.y,q.x)*7.)*0.03))-3.1)-1.30;
    color = mix(vec3(0.803, 0.807, 0.631), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-4.)-0.15;
    color = mix(vec3(0.854, 0.603, 0.525), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-3.65)-0.15;
    color = mix(vec3(0.854, 0.847, 0.525), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-3.30)-0.15;
    color = mix(vec3(0.678, 0.854, 0.525), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-2.95)-0.15;
    color = mix(vec3(0.525, 0.854, 0.819), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-2.55)-0.15;
    color = mix(vec3(0.764, 0.525, 0.854), color, smoothstep(0., 0.1, d));
    d = abs(length(q)-2.16)-0.15;
    color = mix(vec3(0.443, 0.415, 0.941), color, smoothstep(0., 0.1, d));
    
    // Mountains
    q = p + vec2(0., 10.)*(1.-smoothstep(0., 1.5, gT));
    vec3 mountainCol = mix(vec3(0.678, 0.768, 0.270), vec3(0.4, 0.592, 0.266), smoothstep(4., 16., q.x));
    color = mix(mountainCol, color, smoothstep(0., 0.1, (q.y-3.5)+sin(-3.25+q.x*0.5)*3.6*sin(.0+q.x*0.08)*1.+sin(q.x*1.5)*0.15));
    mountainCol = mix(vec3(0.286, 0.470, 0.231), vec3(0.529, 0.662, 0.376), smoothstep(0., 6., p.x));
    color = mix(mountainCol, color, smoothstep(0., 0.1, (q.y-1.5)+sin(-1.+q.x*0.17)*3.6+sin(q.x*1.5)*0.1));
    
    color = DrawClouds(p-vec2(9.5, 5.5+cos(gT*0.25)*1.) + vec2(0., -10.)*(1.-smoothstep(0., 1.5, gT-1.4)), color);
    color = DrawClouds(p-vec2(3.0, 6.0+sin(-1.4+gT*0.25)) + vec2(0., -10.)*(1.-smoothstep(0., 1.5, gT-1.9)), color);
    
    return color;
}

// Function 696
float lineGrid(vec2 uv, in vec2 gridSpaces, float lineWidth)
{
    uv = mod(uv, gridSpaces) - gridSpaces * 0.5;
    float verticalLines = smoothstep(lineWidth, lineWidth * 0.5, abs(uv.x - lineWidth));
    float horizontalLines = smoothstep(lineWidth, lineWidth * 0.5, abs(uv.y - lineWidth));
    return verticalLines + horizontalLines;
}

// Function 697
vec4 line (vec2 p, vec2 a, vec2 b, vec4 c, float thickness)
{
    vec2 pa = -p - a;
    vec2 ba = b - a;
    float h = clamp (dot (pa, ba) / dot (ba, ba), 0.0, 1.0);
    float d = length (pa - ba * h);
    
    return c * clamp (((1.0 - d) - (1.0 - thickness)) * 100.0, 0.0, 1.0);
}

// Function 698
vec4 draw_turtle_dive( int frame, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( frame < 2 && iINSIDE( iu, ivec2(0), ivec2( 16 ) ) ) { //hack, frame 2 is empty
        
        //hack for simpler collision with diving turtles (same color, different alpha!)
        o = iINSIDE( iu, ivec2( 3 ), ivec2( 3 ) + ivec2( 10 ) ) ? col_water_hack : o ;
        
        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = 2 * iu.x ;
        uint bits = 0x3U << sh,
             col_ind = ( get_turtle_dive_br( row_group, component ) & bits ) >> sh ;
        v = get_col( pal_turtle, col_ind ) ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 699
vec3 linearLight( vec3 s, vec3 d )
{
	return 2.0 * s + d - 1.0;
}

// Function 700
float drawLogo(in vec2 fragCoord)
{
    float val = 0.0;
    float res = max(iResolution.x, iResolution.y) * 0.75;
    vec2  pos = vec2(floor((fragCoord.xy / res) * 128.0));

    // AND'16 bitmap
    val = pos.y == 2.0 ? 4873775.5 : val;
    val = pos.y == 3.0 ? 8049193.5 : val;
    val = pos.y == 4.0 ? 2839727.5 : val;
    val = pos.y == 5.0 ? 1726632.5 : val;
    val = pos.x >168.0 ? 0.0 : val;

    float bit = floor(val * exp2(pos.x - 168.0));

    return bit != floor(bit / 2.0) * 2.0 ? 1.0 : 0.0;
}

// Function 701
void lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){
    float d = dot(z-mix(a, b, 0.5), b-a);
    
    if(abs(d) < dot(a-b, a-b)/2.0){
    	d = length(cross( normalize(vec3(a-b, 0.0)), vec3(z-b, 0.0)));
    } else {
        d = min(length(z-b), length(z-a));
    }
    fragColor.xyz = mix(fragColor.xyz, c.xyz, c.w * clamp(w-d, 0.0, 1.0));
}

// Function 702
vec3 GetDirectionalLight(vec3 normal)
{
    return directionalLightColor * Banding(max(0.0, dot(lightDirection, normal)) * .75, lightBanding);
}

// Function 703
vec3 directBackground(vec3 dir){
    return LightColor * Density * 1.;
}

// Function 704
void drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,
                 in float thickness, in vec4 color, inout vec4 outputColor) {
  float d = sdSegment(fragmentCoordinates, p0, p1);
  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);

  outputColor = mix(outputColor, color, a * color.a);
}

// Function 705
void drawBirdF0(int x, int y)
{
	if (y < 0 || y > 11 || x < 0 || x > 15) {
		return;
	}
	
	// pass 0 - draw black, white and yellow
	float col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,1.,1., 1.,1.,1.,1.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,1.,1.,3.,3., 3.,1.,2.,2.,1.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,1.,3.,3.,3.,3., 1.,2.,2.,2.,2.,1.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,0.,1.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  7) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 1.,2.,2.,2.,1.,2.,1.,0.);
	if (y ==  6) col = SPRROW(x,0.,1.,3.,3.,3.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  5) col = SPRROW(x,0.,1.,1.,1.,1.,1.,3.,3., 3.,3.,1.,1.,1.,1.,1.,1.);
	if (y ==  4) col = SPRROW(x,1.,2.,2.,2.,2.,2.,1.,3., 3.,1.,2.,2.,2.,2.,2.,1.);
	if (y ==  3) col = SPRROW(x,1.,2.,2.,2.,2.,1.,3.,3., 1.,2.,1.,1.,1.,1.,1.,1.);
	if (y ==  2) col = SPRROW(x,1.,2.,2.,2.,1.,3.,3.,3., 3.,1.,2.,2.,2.,2.,1.,0.);
	if (y ==  1) col = SPRROW(x,0.,1.,1.,1.,1.,3.,3.,3., 3.,3.,1.,1.,1.,1.,1.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,1.,1.,1., 1.,1.,0.,0.,0.,0.,0.,0.);
		
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(82,56,70); // outline color (black)
	}
	else if (col == 2.0) {
		fragColor = RGB(250,250,250); // eye color (white)
	}
	else if (col == 3.0) {
		fragColor = RGB(247, 182, 67); // normal yellow color
	}
	
	// pass 1 - draw red, light yellow and dark yellow
	col = 0.0; // 0 = transparent
	if (y == 11) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y == 10) col = SPRROW(x,0.,0.,0.,0.,0.,0.,3.,3., 3.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  9) col = SPRROW(x,0.,0.,0.,0.,3.,3.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  8) col = SPRROW(x,0.,0.,0.,3.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  7) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  6) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  5) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);
	if (y ==  4) col = SPRROW(x,0.,3.,0.,0.,0.,3.,0.,0., 0.,0.,1.,1.,1.,1.,1.,0.);
	if (y ==  3) col = SPRROW(x,0.,0.,0.,0.,0.,0.,2.,2., 0.,1.,0.,0.,0.,0.,0.,0.);
	if (y ==  2) col = SPRROW(x,0.,0.,0.,3.,0.,2.,2.,2., 2.,0.,1.,1.,1.,1.,0.,0.);
	if (y ==  1) col = SPRROW(x,0.,0.,0.,0.,0.,2.,2.,2., 2.,2.,0.,0.,0.,0.,0.,0.);
	if (y ==  0) col = SPRROW(x,0.,0.,0.,0.,0.,0.,0.,0., 0.,0.,0.,0.,0.,0.,0.,0.);	
	
	col = SELECT(mod(float(x),8.0),col);
	if (col == 1.0) {
		fragColor = RGB(249, 58, 28); // mouth color (red)	
	}
	else if (col == 2.0) {
		fragColor = RGB(222, 128, 55); // brown
	}
	else if (col == 3.0) {
		fragColor = RGB(249, 214, 145); // light yellow			
	}		
}

// Function 706
bool isOnCircle(in vec3 c, in vec2 uv, in float width) {
    uv -= c.xy;    
    return abs(length(uv) - c.z) < width;
}

// Function 707
float line_d(vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p - a, ba = b - a;
    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);
    return length(pa - i*ba);
}

// Function 708
void DrawOutlinePoint( inout DrawContext drawContext, vec3 vOutlineColor, vec3 vColor, vec2 vPos, float fStrokeThickness, float fOutlineThickness )
{
    float fDist = length( drawContext.vUV - vPos );
    
    DrawBlend( drawContext, vOutlineColor, LineSmooth( drawContext, fDist, fStrokeThickness + fOutlineThickness) );
    DrawBlend( drawContext, vColor, LineSmooth( drawContext, fDist, fStrokeThickness ) );  
}

// Function 709
vec4 circle(vec2 p, vec2 pos, float radius, vec4 currColor, vec4 newColor, bool mixColors)
{
    // x^2 + y^2 < radius
    
    float x2 = (p.x - pos.x) * (p.x - pos.x);
    float y2 = (p.y - pos.y) * (p.y - pos.y);
        
    if(x2 + y2 < radius) {
        if(mixColors)
        {
        	return currColor + newColor;
        }
    	return newColor;
    
    }
    return currColor;
}

// Function 710
vec4 colorCorrect(vec3 color)
{
    vec3 x = max(vec3(.0), color*aperture-.004);
    vec3 retColor = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);
    return vec4(min(retColor, 1.0), 1.0);
}

// Function 711
void UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))
        return;
    
    uiContext.vWindowOutColor = vec4(1.0);
    
    if ( bActive && bMouseOver )
    {
        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);
    }

#ifdef NEW_THEME
    DrawBorderRect( uiContext.vPixelCanvasPos, checkBoxRect, cCheckboxOutline, uiContext.vWindowOutColor );
#else    
    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );
#endif    

    Rect smallerRect = checkBoxRect;
    RectShrink( smallerRect, vec2(6.0));

    if ( bChecked )
    {
        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );
    }
}

// Function 712
vec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )
{
    vec2 off = dir2dis(dir);

    vec2 gpos = pos.xy;

    
    vec2 p = fragCoord/iResolution.y;
    float eps = 1.0 / iResolution.y;

    vec2 q = p - cell2ndc( gpos );

    float c = sdCircle(q, 0.023);
    float f = c;
	f = max(f,-q.y);
    float on = 0.0025*sin(1.0*6.28318*q.x/0.025 + 6.2831*iTime);
    f = min( f, sdBox(q-vec2(0.0,-0.0065+on), vec2(0.023,0.012) ) );
   
    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );
    float g = mode.x;
    if( mode.z>0.75 )
    {
        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iTime-mode.y)));
    }
    gco = mix( gco, vec3(0.1,0.5,1.0), g );
    
    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );
    col = mix( col, gco, f );

    f = sdCircle( vec2(abs(q.x-off.x*0.006)-0.011,q.y-off.y*0.006-0.008), 0.008);
    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );
    col = mix( col, vec3(1.0), f );

    f = sdCircle( vec2(abs(q.x-off.x*0.01)-0.011,q.y-off.y*0.01-0.008), 0.004);
    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );
    col = mix( col, vec3(0.0), f );

    // glow
    //col += 0.2*gco*exp(-300.0*c*c);

    return col;
}

// Function 713
void drawFrame(inout vec4 c, vec2 p, vec2 aspectRatio){
    float box = sdBox(p,vec2(0.),vec2(0.5)*aspectRatio);
    float cbox = smoothstep(0.,.01, 0.05-abs(box));
    c = mix(c, vec4(0.,0.,0.,0.), cbox);
    c = mix(c, vec4(0.,0.,0.,0.), -.1+length(p)*.5);
    c = mix(c, vec4(0.,0.,0.,0.), .3+.5*sdBox(p,vec2(0.),vec2(0.5)*aspectRatio));
    c = mix(c, vec4(1.,1.,1.2,0.), clamp(.15-.05*(cos(60.*smoothstep(-0.,.1, .05-abs(box)))),0.,1.));
    float box2 = sdBox(p,vec2(0.),vec2(0.455, 0.42)*aspectRatio) ;
    c = mix(c, vec4(0.,0.,0.,0.), smoothstep(0.,.0025, 0.0025-abs(box2)));
    float vf1 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.1));
 	float vf2 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.2));
 	float vf3 = max(1.-pow(cbox,4.), 1.-veronoib(p*40.,.3));
    float vf = vf1; 
    c = mix(c, vf1*c,1.00);
    c = mix(c, (vf2*.5+0.5)*c,1.00);
    c = mix(c, (vf3*.2+0.8)*c,1.00);
}

// Function 714
vec4 draw_frog_wink( ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), ivec2( 16 ) ) ) {
        int row_group = 0 * 4 + 3 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = 2 * iu.x ;
        uint bits = 0x3U << sh,
             col_ind = ( get_frog_wink_br( row_group, component ) & bits ) >> sh ;
        v = get_col( pal_grass, col_ind ) ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 715
vec3 RandomDirectionAroundRange(in float seed, in float range, in vec3 startingDirection)
{
    vec3 direction = RandomDirection(seed, startingDirection);
    direction = (dot(direction, startingDirection) < range) ? startingDirection : direction;
    return direction;
}

// Function 716
vec3 LinearToSRGB(vec3 rgb)
{
    rgb = clamp(rgb, 0.0f, 1.0f);
    
    return mix(
        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,
        rgb * 12.92f,
        LessThan(rgb, 0.0031308f)
    );
}

// Function 717
float shape_circle(vec2 p) {
  return length(p) - 0.5;
}

// Function 718
float IsGridLine(vec2 fragCoord)
{
	vec2 vGridSquareCoords = fract(fragCoord.xy / vec2(size));
	vec2 vGridSquarePixelCoords = vGridSquareCoords * vec2(size);
	vec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));
	float fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);

	return fIsGridLine;
}

// Function 719
float sCircle(vec2 p, float radius){
  return sm(0.0,radius*radius-(p.x*p.x+p.y*p.y));
}

// Function 720
float distline(float x,float o)
{
	float i = floor(x);
	float f = fract(x);
    f = f*f*(3.0-2.0*f);
	float m = .91456789+o*0.345678;
	float a = fract(i*m+0.5678);//rnd(vec2(i,o));
	float b = fract((i+1.)*m+0.5678);//rnd(vec2(i+1.,o));
	return mix(a,b,f);
}

// Function 721
vec3 draw_star(vec2 pos, vec3 star_col) {
	pos -= FragCoord.xy / iResolution.x; 
	float d = length(pos) * 50.0;
	vec3 col, spectrum = star_col;
	col = spectrum / (d * d * d);
	
	// produce spikes
	d = length(pos * vec2(10., .2)) * 50.0;
	col += spectrum / (d * d * d);
	d = length(pos * vec2(.2, 10.)) * 50.0;
	col += spectrum / (d * d * d);

	return col;
}

// Function 722
maybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r
){
    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center
    // see closest-approach-between-line-and-cylinder-visualized.scad
    // implementation shamelessly copied from Inigo: 
    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    vec3 D = A0 - B0;
    float BA = dot(B, A);
    float BD = dot(B, D);
    float a = 1.0 - BA * BA;
    float b = dot(D, A) - BD * BA;
    float c = dot(D, D) - BD * BD - r * r;
    float h = sqrt(max(b * b - a * c, 0.f));
    return maybe_vec2(
        vec2((-b + h) / a, (-b - h) / a), 
        h > 0.0
    );
}

// Function 723
float roundLine(vec2 p, vec2 a, vec2 b) 
{
	b -= a + vec2(1.0,0.);
	p -= a;
    float f = length(p-clamp(dot(p,b)/dot(b,b),0.0,1.0)*b);
	if (iResolution.y < 320.) // attempt to get rid of aliasing on small resolution
		return smoothstep(1.0, 0.9, f);    
    else if (iResolution.y < 720.)
		return smoothstep(0.75, 0.5, f);    
	else
		return smoothstep(1., 0., f);    
}

// Function 724
vec4 drawParticles(in vec3 ro, in vec3 rd)
{
    vec4 rez = vec4(0);
    vec2 w = 1./iResolution.xy;
    
    for (int i = 0; i < numParticles; i++)
    {
        vec3 pos = texture(iChannel0, vec2(i,100.0)*w).rgb;
        vec3 vel = texture(iChannel0, vec2(i,0.0)*w).rgb;
        for(int j = 0; j < stepsPerFrame; j++)
        {
            float d = mag((ro + rd*dot(pos.xyz - ro, rd)) - pos.xyz);
            d *= 1000.;
            d = .14/(pow(d,1.1)+.03);
            
            rez.rgb += d*abs(sin(vec3(2.,3.4,1.2)*(time*.06 + float(i)*.003 + 2.) + vec3(0.8,0.,1.2))*0.7+0.3)*0.04;
            //rez.rgb += d*abs(sin(vec3(2.,3.4,1.2)*(time*.06 + float(i)*.003 + 2.75) + vec3(0.8,0.,1.2))*0.7+0.3)*0.04;
            pos.xyz += vel*0.002*0.2;
        }
    }
    rez /= float(stepsPerFrame);
    
    return rez;
}

// Function 725
float segmented_spline_c9_rev( float y, SegmentedSplineParams_c9 C) {  
//SegmentedSplineParams_c9 C = ODT_48nits();
const int N_KNOTS_LOW = 8;
const int N_KNOTS_HIGH = 8;
float KNOT_INC_LOW = (log10(C.midPoint.x) - log10(C.minPoint.x)) / float(N_KNOTS_LOW - 1);
float KNOT_INC_HIGH = (log10(C.maxPoint.x) - log10(C.midPoint.x)) / float(N_KNOTS_HIGH - 1);
float coefsLow[10];
coefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;coefsLow[3] = C.coefsLow.d;
coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;coefsLow[6] = C.coefsLow.g;
coefsLow[7] = C.coefsLow.h;coefsLow[8] = C.coefsLow.i;coefsLow[9] = C.coefsLow.j;
float coefsHigh[10];
coefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;coefsHigh[3] = C.coefsHigh.d;
coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;coefsHigh[6] = C.coefsHigh.g;
coefsHigh[7] = C.coefsHigh.h;coefsHigh[8] = C.coefsHigh.i;coefsHigh[9] = C.coefsHigh.j;   
float KNOT_Y_LOW[ N_KNOTS_LOW];
for (int i = 0; i < N_KNOTS_LOW; i += 1) {
KNOT_Y_LOW[ i] = ( coefsLow[i] + coefsLow[i+1]) / 2.0;
};
float KNOT_Y_HIGH[ N_KNOTS_HIGH];
for (int i = 0; i < N_KNOTS_HIGH; i += 1) {
KNOT_Y_HIGH[ i] = ( coefsHigh[i] + coefsHigh[i+1]) / 2.0;
};
float logy = log10( max( y, TINY));
float logx;
if (logy <= log10(C.minPoint.y)) {
logx = log10(C.minPoint.x);
} else if ( (logy > log10(C.minPoint.y)) && (logy <= log10(C.midPoint.y)) ) {
int j;
vec3 cf;
if ( logy > KNOT_Y_LOW[ 0] && logy <= KNOT_Y_LOW[ 1]) {
cf.x = coefsLow[0];  cf.y = coefsLow[1];  cf.z = coefsLow[2];  j = 0;
} else if ( logy > KNOT_Y_LOW[ 1] && logy <= KNOT_Y_LOW[ 2]) {
cf.x = coefsLow[1];  cf.y = coefsLow[2];  cf.z = coefsLow[3];  j = 1;
} else if ( logy > KNOT_Y_LOW[ 2] && logy <= KNOT_Y_LOW[ 3]) {
cf.x = coefsLow[2];  cf.y = coefsLow[3];  cf.z = coefsLow[4];  j = 2;
} else if ( logy > KNOT_Y_LOW[ 3] && logy <= KNOT_Y_LOW[ 4]) {
cf.x = coefsLow[3];  cf.y = coefsLow[4];  cf.z = coefsLow[5];  j = 3;
} else if ( logy > KNOT_Y_LOW[ 4] && logy <= KNOT_Y_LOW[ 5]) {
cf.x = coefsLow[4];  cf.y = coefsLow[5];  cf.z = coefsLow[6];  j = 4;
} else if ( logy > KNOT_Y_LOW[ 5] && logy <= KNOT_Y_LOW[ 6]) {
cf.x = coefsLow[5];  cf.y = coefsLow[6];  cf.z = coefsLow[7];  j = 5;
} else if ( logy > KNOT_Y_LOW[ 6] && logy <= KNOT_Y_LOW[ 7]) {
cf.x = coefsLow[6];  cf.y = coefsLow[7];  cf.z = coefsLow[8];  j = 6;
}
vec3 tmp = MM * cf;
float a = tmp.x;
float b = tmp.y;
float c = tmp.z;
c = c - logy;
float d = sqrt( b * b - 4.0 * a * c);
float t = ( 2.0 * c) / ( -d - b);
logx = log10(C.minPoint.x) + ( t + float(j)) * KNOT_INC_LOW;
} else if ( (logy > log10(C.midPoint.y)) && (logy < log10(C.maxPoint.y)) ) {
int j;
vec3 cf;
if ( logy > KNOT_Y_HIGH[ 0] && logy <= KNOT_Y_HIGH[ 1]) {
cf.x = coefsHigh[0];  cf.y = coefsHigh[1];  cf.z = coefsHigh[2];  j = 0;
} else if ( logy > KNOT_Y_HIGH[ 1] && logy <= KNOT_Y_HIGH[ 2]) {
cf.x = coefsHigh[1];  cf.y = coefsHigh[2];  cf.z = coefsHigh[3];  j = 1;
} else if ( logy > KNOT_Y_HIGH[ 2] && logy <= KNOT_Y_HIGH[ 3]) {
cf.x = coefsHigh[2];  cf.y = coefsHigh[3];  cf.z = coefsHigh[4];  j = 2;
} else if ( logy > KNOT_Y_HIGH[ 3] && logy <= KNOT_Y_HIGH[ 4]) {
cf.x = coefsHigh[3];  cf.y = coefsHigh[4];  cf.z = coefsHigh[5];  j = 3;
} else if ( logy > KNOT_Y_HIGH[ 4] && logy <= KNOT_Y_HIGH[ 5]) {
cf.x = coefsHigh[4];  cf.y = coefsHigh[5];  cf.z = coefsHigh[6];  j = 4;
} else if ( logy > KNOT_Y_HIGH[ 5] && logy <= KNOT_Y_HIGH[ 6]) {
cf.x = coefsHigh[5];  cf.y = coefsHigh[6];  cf.z = coefsHigh[7];  j = 5;
} else if ( logy > KNOT_Y_HIGH[ 6] && logy <= KNOT_Y_HIGH[ 7]) {
cf.x = coefsHigh[6];  cf.y = coefsHigh[7];  cf.z = coefsHigh[8];  j = 6;
}
vec3 tmp = MM * cf;
float a = tmp.x;
float b = tmp.y;
float c = tmp.z;
c = c - logy;
float d = sqrt( b * b - 4.0 * a * c);
float t = ( 2.0 * c) / ( -d - b);
logx = log10(C.midPoint.x) + ( t + float(j)) * KNOT_INC_HIGH;
} else {
logx = log10(C.maxPoint.x);
}
return pow(10.0, logx);
}

// Function 726
void draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)
{
    float antialiasing = 1.;
    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering
    vec3 p = cam+dir*antialiasing;
    int s = 0;
    
    vec3 h_col = vec3(1., .1, .8);
    
    float t = 1.;
    float dist_acc = 0.;
    
    float r_t = transp(uniform_step, .1);
    float g_t = transp(uniform_step, .9);
    float b_t = transp(uniform_step, .1);
    
    vec3 rgb_t = vec3(r_t, g_t, b_t);
    
    float r_t2 = transp(uniform_step, .9);
    float g_t2 = transp(uniform_step, .1);
    float b_t2 = transp(uniform_step, .1);
    
    vec3 rgb_t2 = vec3(r_t2, g_t2, b_t2);

    vec3 t_acc = vec3(1.);	// accumulated transparency
    vec3 t_acc2 = vec3(1.); //accumulated transparency
    
    for(s; s < 150; s++)
    {               
        
        float k_step = uniform_step;
        
        float dist_dist = dot(p-cam, p-cam);
        float dist_center = length(center-cam);
        
        //if too far, then big step        
        if(sqrt(dist_dist)-(dist_center-radius) < 0.)
        {
        	k_step = dist_center-(radius);
        }

        //if in the shape, draw
        if( sdf_sphere(p-center, RADIUS) <= 0.)
        {
            
           	//blending
        	c += t_acc*vec3(1.)*(1.-rgb_t);
			t_acc *= rgb_t;  
        }   
        
        if( sdf_sphere(p-vec3(2., -3., -2.), RADIUS-1.) <= 0.)
        {
            c += t_acc*vec3(1., 1., 0.)*(1.-rgb_t2);
			t_acc *= rgb_t2;
        }   
        
        //if it will never be in the shape anymore, return;
        if(length(p-cam) > max((dist_center+radius), (length(vec3(2., -3., -2.)-cam)+(radius-1.))))
        {
         	break;
        }
        
        p += dir*k_step;       
    }
}

// Function 727
vec2 lineIntersection(vec2 a1, vec2 a2, vec2 b1, vec2 b2){
  vec2 ret=vec2(100000.);
  vec2 ob1=b1;
  vec2 ob2=b2;
  if ((a1==a2) || (b1==b2)) return ret;
  a2+=-a1;
  b1+=-a1;
  b2+=-a1;
  float distAB=length(a2);
  vec2 rot=a2/distAB;
  
  float newX=b1.x*rot.x+b1.y*rot.y;
  b1.y  =b1.y*rot.x-b1.x*rot.y; b1.x=newX;
  newX=b2.x*rot.x+b2.y*rot.y;
  b2.y  =b2.y*rot.x-b2.x*rot.y; b2.x=newX;
  
  //when lines paralel return far point in line2 direction
  if (b1.y==b2.y) return 100000.*(ob2-ob1);

  float ABpos=b2.x+(b1.x-b2.x)*b2.y/(b2.y-b1.y);
  ret=a1+ABpos*rot;
  return ret; 
}

// Function 728
float spherical_direction(in vec2 uv, out vec3 rd)
{
  float theta = (uv.t) * PI,
        phi = (uv.s - 0.5)* 2.0 * PI;
  rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));
  return 1.0;
}

// Function 729
bool drawArrow( in vec2 p1, in vec2 p2, in vec2 p3, inout vec4 col)
{
  vec4 fill =  vec4(0.3, 0.2, 0.6, 1.0);
  vec4 frame = vec4(0.8, 0.8, 0.4, 1.0);
  bool inside = sdTriangle(p1,p2,p3, mp) < 0.0;
  if (inside)
  {  
    // fill = vec4(0, 1.1, 0.4, 1.0); 
    // frame = vec4(1.0);  // last input
    if (mousePressed)     
      fill = vec4(1, 0.1, 0.4, 1.0);
  }
  col += drawTriangle (p1,p2,p3, uv, col, fill, frame, 0.02);
  return inside;
}

// Function 730
void DrawDoor( vec2 pos, vec3 keyCol )
{
	vec2 p = pixel-pos;
	vec2 ap = abs(p);
	vec4 t = texture( iChannel1, pixel.yx/40.0 );
	if ( max(ap.x,ap.y+20.0) < 60.0+4.0*pow((1.0-t.g),2.0) )
	{
		fragColor.rgb = mix( vec3(.2,.1,.03), vec3(0), t.r);
		
		fragColor.rgb *= 1.0+1.0*step(10.0,p.y); // lighting on top
		
		fragColor.rgb = mix( fragColor.rgb, vec3(0), step(-1.0,-ap.x) );
		
		// keyhole
		vec2 lp = p-vec2(0,-15);
		if ( abs(lp.x) < 6.0 && abs(lp.y) < 4.0 )
		{
			fragColor.rgb = keyCol;
			
			fragColor.rgb *= smoothstep(1.0,2.0, length(lp));
		}
	}
}

// Function 731
float rrect(vec2 p, vec2 sz) {return length(max(abs(p) - sz, vec2(0.0)));}

// Function 732
vec4 draw_char() {
    int c = char_id; vec2 p = char_pos;
    return c < 0 
        ? vec4(0,0,0,1e5)
        : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), 
                       dFdx(p/16.),dFdy(p/16.) );
}

// Function 733
vec3 get_sun_direction(float aTime)
{
	float sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); // careful with z, long shadows make the tracing slower
	return zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )
											 , _1 ? V45 : unit_vector2( 2.0 * PI * aTime / 3.0 ) );
}

// Function 734
void drawMineCraftNotBlur(Ray ray, inout TraceResult cur_ctxt)
{
    TraceResult tr_res;
    float mineT;
    tr_res = TraceMineCraft(ray.pos, ray.dir);

    mineT = sqrt(dot(tr_res.p - ray.pos, tr_res.p - ray.pos)); 
    if (mineT < cur_ctxt.t && tr_res.hit == true)
    {
        cur_ctxt.color = vec3(compute_minecraft_light(tr_res, 
                                    tr_res.sphereIntersect, ray.dir));
        cur_ctxt.n = tr_res.n;
        
        cur_ctxt.t = mineT;
        //cur_ctxt.alpha = max(0.75, 
        //                    sqrt(sqrt(dot(tr_res.p, tr_res.p))));
        cur_ctxt.alpha = GLOBAL_ALPHA;
        cur_ctxt.materialType = EMISSION;
    }
}

// Function 735
vec4 line_quad_intersect(vec3 p0, vec3 s1, vec3 s2, vec3 r0, vec3 rd) {
	/*
	p0: corner of quadrilateral
	s1, s2: sides of quadrilateral, origin at p0
	r0: origin of line
	rd: direction of line

	return value: 
		xyz: point of intersection (only valid if a is 1)
		a: 1 if intersection, 0 if no intersection
	*/
    
    // normal to surface of quadrilateral
    vec3 N = cross(s1, s2);
    
	float a = dot(N, rd);
    float b = dot(N, p0 - r0);
    
    if (a == 0.0) {
        // line and quadrilateral are parallel
		return vec4(0);  
    } else {
        // line and quadrilateral are not parallel
        
        // distance from origin of line to point where line intersects the quadrilateral's plane
        float t = b / a;
        
        // point where line intersects the quadrilateral's plane
        vec3 p = r0 + t*rd;
        
        // scalar projection of p - p0 on s1
        float q1 = dot(p - p0, normalize(s1));
        float l1 = length(s1);
        if (q1 < 0.0 || q1 > l1) 
            return vec4(0); // p is outside of quadrilateral
        
        // scalar projection of p - p0 on s2
        float q2 = dot(p - p0, normalize(s2));
        float l2 = length(s2);
        if (q2 < 0.0 || q2 > l2) 
            return vec4(0); // p is outside of quadrilateral
        
        return vec4(p, 1);
    }    
}

// Function 736
void drawTriangle(vec2 uv, inout vec3 color, Triangle t){
    float alpha = t.color.a;
    #if DARKMODE
    alpha = pow(alpha, 1.5);
    #else
    alpha = pow(alpha, 0.75);
    #endif
    color = mix(t.color.rgb, color, (1.0-alpha) + alpha*triangleShape(uv, t));
}

// Function 737
float outline(sampler2D buffer, ivec2 uv) {
  float dpos = 0.0;
  
  const ivec2[] v = ivec2[](
      ivec2(0, 1),
      ivec2(1, 1),
      ivec2(1, 0),
      ivec2(1,-1)
  );
  
  for(int i = 0;i<4;i++)
  {
      vec4 s0 = texelFetch(buffer, uv + v[i],0);
      vec4 s1 = texelFetch(buffer, uv - v[i],0);
      dpos += 0.15*abs(s0.a - s1.a);
      dpos += 4.*max(0.0, 1.0 - dot(s0.rgb, s1.rgb));
  }
  
  dpos = pow(max(dpos - 0.5, 0.0), 6.0);
    
  return abs(dpos);
}

// Function 738
float lineseg(vec2 x, vec2 p1, vec2 p2)
{
    vec2 d = p2-p1;
    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));
}

// Function 739
vec2 square2circle( in vec2 v )
{
    #if IMPROVED==0
    return maxcomp(abs(v))*normalize(v);
    #else
    return maxcomp(abs(v))*normalize(v*(2.0+abs(v)));
    #endif
}

// Function 740
void set_line_width_px(float w) {
    _stack.line_width = w*min_uniform_scale() * AAINV;
}

// Function 741
float circleSDF(vec2 st) {
	return length(st -.5)*2.;
}

// Function 742
float drawBlob(
    in vec2 st,
    in vec2 center,
    in float radius,
    in float edgeSmoothing
) {
    float dist = length((st - center) / radius);
    return dist * smoothstep(1., 1. - (iBlobEdgeSmoothing - (0.05 * sin(iTime / 3.1))), dist);
}

// Function 743
float getCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {
    float distance = distance(st, center);
    return smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);
}

// Function 744
float rectangle(vec2 uv, float up, float down, float left, float right, float blur){
    float band1 = Band(uv.x, left, right, blur);
    float band2 = Band(uv.y, up, down, blur);
    
    return band1*band2;
    
    
}

// Function 745
vec4 draw(vec4 canvas, vec4 drawable, int blendMode) {

    switch(blendMode) {
        case BLEND_NORMAL :
        
        canvas.r = (canvas.r * (1.0 - drawable.a) + drawable.r * drawable.a);
        canvas.g = (canvas.g * (1.0 - drawable.a) + drawable.g * drawable.a);
        canvas.b = (canvas.b * (1.0 - drawable.a) + drawable.b * drawable.a);
        canvas.a = 1.0;
        
        break;
        
        default: 
        break;
    }
    
    return canvas;
}

// Function 746
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 747
void drawGameFlat( inout vec4 color, vec2 p, AppState s )
{
    // game
	vec2 p0 = p;    
    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );
    float cameraAnim = 0.0;
	p0 *= mix( 5.0, 10.0, cameraAnim );		// scale field of view
    p0.x += 0.25;							// fix track centering
    p0.y += mix( 2.0, 8.0, cameraAnim );	// move camera pos
    p0.y += s.playerPos.y;
    
    float playerCellID = floor( s.playerPos.y );
    float sPlayer = length( p0 - s.playerPos ) - 0.25;
           
    vec2 p1 = p0;
    p1.y += 2.0 * s.playerPos.y;
    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );
    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );
       
	// COIN start
    float cellID = floor( p0.y );
    float cellCoinRND = hash11( cellID + g_S.seed );					// skip rnd obstacle every second cell to make room for driving    
    cellCoinRND *= mix( 2.0, -2.0, step( mod( cellID, 5.0 ), 2.5 ) );	// gaps in coin placing: 2 gaps, 2 coins
    cellCoinRND = mix( cellCoinRND, -2.0, step (cellID, 6.0 ) );		// head start
    float cellCoinCol = floor( 4.0 * cellCoinRND );
       
    if ( cellCoinRND >= 0.0 )
    {
        if ( cellID > playerCellID )
           	drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID && s.coin0Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
       
        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
    }    
// COIN end

// OBSTACLE start
    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );		// skip rnd obstacle every second cell to make room for driving
    cellObsRND *= mix( 2.0, -2.0, step( mod( cellID, 4.0 ), 2.5 ) );
    cellObsRND = mix( cellObsRND, -2.0, step( cellID, 8.0) );	// head start
    float cellObsCol = floor( 4.0 * cellObsRND );
    
	if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )
    {        
    	float sObstacle = length(
            p0
            -vec2( 0.0, cellID )		// cell pos
            +vec2( 0.5, -0.5 )			// move to cell center
            -vec2( cellObsCol, 0.0 )	// move to column
        ) - 0.25;						// radius of coin
        
    	color.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );
        
        vec2 obstaclePos = -vec2( 0.0, cellID )			// cell pos
            				+vec2( 0.5, -0.5 )			// move to cell center
            				-vec2( cellObsCol, 0.0 );	// move to column

        float distObstaclePlayer = length( obstaclePos + s.playerPos );
        
        if ( distObstaclePlayer < 0.5 ) 
        {
            color.rgb += vec3( 0.5 );
        }
    }
    
    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );

// OBSTACLE end        

}

// Function 748
float circle(vec2 p,float r)
{
    return length(p)-r;
}

// Function 749
vec3 toLinear(vec3 c) {
	return vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));
}

// Function 750
bool linearSrgbInGamut(vec3 c) {
    vec3 clamped = clamp(c, 0.0, 1.0);
    return c == clamped;
}

// Function 751
float sdLine2( vec2 p,vec2 a,vec2 b){vec2 c=p-a,d=b-a;
 float h=c01d(c,d);return dd(c-d*h );}

// Function 752
void rect(out vec4 fragColor, ivec2 frag, int x, int y, int w, int h) {
    frag -= ivec2(x, y);
    if(!bound(frag, w, h))
        return;
    
    
    if(frag.x == w - 1)
        fragColor = BLACK;
    else
    if(frag.y == 0)
        fragColor = BLACK;
        
    else
    if(frag.y == h - 1)
        fragColor = WHITE;
    else
    if(frag.x == 0)
        fragColor = WHITE;
        
	else
    if(frag.y == 1)
        fragColor = DGRAY;
    else
    if(frag.x == w - 2)
        fragColor = DGRAY;
        
    else
    if(frag.y == h - 2)
        fragColor = LGRAY;
    else
    if(frag.x == 1)
        fragColor = LGRAY;
	else 
        fragColor = LGRAY;
}

// Function 753
float circleMask(float angle, float dist, int mask, float maskCount)
{
    float value = mod(angle + PI, PI2);
    int pos = int(value / (PI2 / maskCount));
    return float((mask & (1 << pos)) != 0);
}

// Function 754
int isoLine(vec3 n3, vec2 ip0, vec2 ip1, vec2 ip2, float isovalue, float i, 
          inout vec2 p0, inout vec2 p1){
    
    
    // Points where the lines cut the edges.
    p0 = vec2(1e5), p1 = vec2(1e5);
    
    // Marching triangles.. Is that a thing? Either way, it's similar to marching
    // squares, but with triangles. In other words, obtain the underlying function
    // value at all three vertices of the triangle cell, compare them to the 
    // isovalue (over or under), then render a line between the corresponding edges.
    //
    // The line cuts each edge in accordance with the isovalues at each edge, which
    // means interpolating between the two.
    
    // Bitwise accumulation to produce a unique index number upon which to make 
    // decisions. It's a pretty standard technique.
    //
    // Minumum threshold value... It's an ID, of sorts.
    int iTh = 0;
    //
    // If the first vertex is over the isovalue threshold, add four, etc.
    if(n3.x>isovalue) iTh += 4;
    if(n3.y>isovalue) iTh += 2;
    if(n3.z>isovalue) iTh += 1;
    
    
    // A value of 1 or 6 means constructing a line between the
    // second and third edges, and so forth.
    if(iTh == 1 || iTh == 6){ // 12-20         
        
        p0 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.
        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.
     
    }
    else if(iTh == 2 || iTh == 5){ // 01-12 
        
        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.
        p1 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.
        
    }
    else if(iTh == 3 || iTh == 4){ // 01-20 
        
        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.
        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.       
        
    }
     
    
    // For the last three cases, we're after the other side of
    // the line, and this is a quick way to do that. Uncomment
    // to see why it's necessary.
    if(iTh>=4 && iTh<=6){ vec2 tmp = p0; p0 = p1; p1 = tmp; }
    
    // Just to make things more confusing, it's necessary to flip coordinates on 
    // alternate triangles, due to the simplex grid triangle configuration. This 
    // line basically represents an hour of my life that I won't get back. :D
    if(i == 0.){ vec2 tmp = p0; p0 = p1; p1 = tmp; }
    
    
    // Return the ID, which will be used for rendering purposes.
    return iTh;
 
    
}

// Function 755
float singleCircleResult(vec2 pixel, vec2 direction, out float brightness)
{
    vec2 center_scaled = floor(pixel / spacing);
    vec2 center = (center_scaled + vec2(0.5, 0.5))*spacing;
    
    vec2 image_center = iResolution.xy / 2.;
    vec2 from_image_center = (center - image_center);
    float prop_from_image_center = length(from_image_center) / (0.7*min(iResolution.x, iResolution.y));
    float size_prop = abs(mod(1.5 * prop_from_image_center - 0.5*iTime, 2.)-1.);
    float size = mix(min_size, max_size, size_prop * size_prop);
    
    int result = 0;
    const int comparisons = 5;
    for (int i = 0; i < comparisons; ++i)
    {
    	vec2 point = pixel + (0.5 * offsets[i]);
        float this_brightness = 0.;
     	if (singleTest(point, center, size, this_brightness))
        {
            result += 1;
            brightness += this_brightness;
        }
    }
    brightness = brightness / float(result);
    return float(result) / float(comparisons);
}

// Function 756
float fCircle(vec2 uv, Circle c)
{
   return length(uv - c.c) - c.r;
}

// Function 757
float Draw(float2 p0, float2 p1, float2 uv)
{
    float2 dp=normalize(p1-p0);
    float2 dpp=float2(dp.y, -dp.x);
    float l=abs(dot(dpp,uv-p0));
    if((dot(dp,uv-p0)<0.0))
        l=length(uv-p0);
    if((dot(-dp,uv-p1)<0.0))
        l=length(uv-p1);
    return l;
}

// Function 758
float Circle(vec2 pix, vec3 C)
{
    float r = length(C.xy - pix);
    float d = abs(r - C.z);  
    return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.00, r - C.z);
}

// Function 759
float RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)
{
	float bL = length(lE-lS);
	vec3 bD = (lE-lS)/bL;
	vec3 tD = lS-rP;
	float aDb = dot(rD,bD);
	float aDt = dot(rD,tD);
	float bDt = dot(bD,tD);
	float u = (aDt-bDt*aDb)/(1.-aDb*aDb);
	float v = max(min(u*aDb-bDt,bL),0.);
	u = max(min(v*aDb+aDt,1e6),0.);
	return length((rP+rD*u)-(lS+bD*v));
}

// Function 760
void drawGrid(float stepSize, float r, vec4 col)
{
	vec2 grid = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) / stepSize));
    float d = min(grid.x, grid.y) * stepSize;
    mixColor(col, lerpstep(r + aa, r - aa, d));
}

// Function 761
vec3 print_line(int line, float scale, vec2 offset, vec2 uv) {
  vec3 col = vec3(0.);

  float r = i_resolution.x / i_resolution.y;
  vec2 txt_uv = (uv - offset) * scale;
  float lh = 1.0/10.0; // line height

  if (txt_uv.x < (1.0/r) && txt_uv.x > 0.0 &&
      txt_uv.y < (1.0 - float(line)*lh) && txt_uv.y > (1.0 - float(line+1)*lh)) {

    txt_uv.x *= r;
    vec3 txt = texture(tex_text, txt_uv).rgb;

    vec2 eps = vec2(0.001);
    txt += texture(tex_text, txt_uv + eps).rgb;
    txt += texture(tex_text, txt_uv - eps).rgb;
    txt /= 3.0;
    col += vec3(1.0) - txt;
  }

  return col;
}

// Function 762
vec3 colorCorrect( vec3 rgb, in vec2 xy )
{
	rgb *= max( 4.0-(rgb.x+rgb.y+rgb.z), 1.0 );
	
    rgb = clamp( rgb-0.1, 0.0, 1.0 );

    // vigneting
	rgb *= 0.75 + xy.x*(1.0-xy.x);
    
    return rgb;
}

// Function 763
float distCircleOff(vec3 p, float r, vec3 v0, float s, float f)
{
    float ang = atan(p.y,p.x)-atan(v0.y,v0.x);
    vec3 poffs=-vec3(0,0,r*3.*sin(ang*f)*s);
    float d=distCircle(p+poffs,r);
    
    #ifdef SHOW_FLOW
    d+=.03*sin(ang*sign(s)*3.*floor(r*4.7)+iTime*3.);
    #endif
    
    return d;
}

// Function 764
float scanline(float factor, float contrast)
{
	vec4 v = base();
	float lum = .2 * v.x + .5 * v.y + .3  * v.z;
	lum *= noise(0.3);
	float tri = triangle(pos.y * linecount);
	tri = pow(tri, contrast * (1.0 - lum) + .5);
	return tri * lum;
}

// Function 765
vec3 LinearTosRGB(const vec3 linear)
{
    return pow(linear, vec3(1.0 / 2.2));
}

// Function 766
void DrawVoxelNotDust(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in vec2 R) {
    
    if(voxel.type == VOXEL_TYPE_BLOCK) {
        O.rgb = (z == 0) ? YELLOW : .5*YELLOW;
        return;
    }
    
    if(IsVoxelTorch(voxel)) {
        float t = 1000.;
        vec3 color = mix(DARK_RED, RED, voxel.power/MAX_REDSTONE_POWER);

        t = min(t,length(p.xy)-torchRadius);
        float tHandle = 1000.;

        bvec4 isConnected = bvec4(voxel.type == VOXEL_TYPE_TORCH_POSITIVE_X,
                                  voxel.type == VOXEL_TYPE_TORCH_NEGATIVE_X,
                                  voxel.type == VOXEL_TYPE_TORCH_POSITIVE_Y,
                                  voxel.type == VOXEL_TYPE_TORCH_NEGATIVE_Y
                                 );

        if(any(isConnected)) {
            if(isConnected.x) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(-1,0)));
            if(isConnected.y) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(1,0)));
            if(isConnected.z) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(0,-1)));
            if(isConnected.w) tHandle = min(tHandle,udLine(p.xy,vec2(0),vec2(0,1)));
            tHandle -= torchHandleSize;
            
            // Cut from sides of 1.
            //tHandle = max(tHandle, sdBox(p.xy,vec2(1)));
            
            O.rgb = mix(O.rgb, vec3(.3), smoothstep(3./R.y, 0., tHandle/p.z));
        }

        O.rgb = mix(O.rgb, color, smoothstep(3./R.y, 0., t/p.z));
    }
    
    if(voxel.type == VOXEL_TYPE_LEVER) {
        // Draw lever base
        O.rgb = mix(O.rgb, vec3(.25), SS(udBox(p.xy,vec2(.35,.45))/p.z));
        
        if(voxel.power <= 0.) p.y = -p.y;
        // Draw Handle
        O.rgb = mix(O.rgb, vec3(.65,.5,0), SS( (udLine(p.xy,vec2(0), vec2(0,.7))-.1) /p.z));
    
        // Draw Handle head
    	O.rgb = mix(O.rgb, vec3(.65), SS( (length(p.xy-vec2(0,.7))-.25) /p.z));
    }
}

// Function 767
vec3 drawTiledBackground(in vec2 uv)
{	
	const float invNumTiles = 1./20.; //max(20.*gSound.f,15.);
	vec2 tile = vec2(AR,1.)*invNumTiles;
	
	// calculate the column and row indices the pixel is in
	vec2 idx = floor(uv / tile);
	vec2 m = mod(idx,vec2(2.));
	float delta = m.x - m.y;
	float pixelOn = delta*delta; // m.x == m.y ? 0. : 1.;
	
	// draw tile
	vec2 centre = idx*tile + vec2(tile.x*.5, tile.y*0.5);
	float dist2Centre = length(uv-centre);
	float d = tile.y*clamp(gSound.fPow,0.1,0.3);
	pixelOn *= step(dist2Centre, d);
	
	return vec3(pixelOn);
}

// Function 768
float linesTextureGradBox( in float p, in float ddx, in float ddy, int id )
{
    float N = 12.0;//float( 2 + 7*((id>>1)&3) );

    float w = max(abs(ddx), abs(ddy)) + 0.01;
    float a = p + 0.5*w;                        
    float b = p - 0.5*w;           
    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-
                  floor(b)-min(fract(b)*N,1.0))/(N*w);
}

// Function 769
void set_line_width(float w) {
    _stack.line_width = w;
}

// Function 770
vec2 LineISect(vec2 a,vec2 b,vec2 u,vec2 d
){b=vec2(b.y-a.y,a.x-b.x);d=vec2(d.y-u.y,u.x-d.x);u=vec2(dot(d,u),det2d(b,d))
 ;if(u.y==0.)return vec2(0);a.x=dot(b,a);b*=u.x;d*=a.x;return vec2(d.y-b.y,b.x-d.x)/u.y;}

// Function 771
vec2 closestPointOnRepeatedLine(vec2 line, vec2 point){

    // Angle of the line
    float a = atan(line.x, line.y);

    // Rotate space so we can easily repeat along
    // one dimension
    pR(point, -a);

    // Repeat to create parallel lines at the corners
    // of the vec2(lead, radius) polar bounding area
    float repeatSize = sin(a) * line.y;
    float cell = pMod1(point.x, repeatSize);

    // Rotate space back to where it was
    pR(point, a);

    // Closest point on a line
    line = normalize(line);
    float d = dot(point, line);
    vec2 closest = line * d;

    // Part 2 of the repeat, move the line along it's
    // tangent by the repeat cell
    vec2 tangent = vec2(line.y, -line.x);
    closest += cell * repeatSize * tangent;

    return closest;
}

// Function 772
float lineintegral(vec3 a, vec3 b) {
    float len = distance(a, b);
    vec3 dir = (b-a)/len;
    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);
}

// Function 773
float drawL(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float val = float(isIn(length(uv), cMin, cMax) && uv.y < 0.0 && uv.x < (cMax-cMin)*0.5);
  float valB = float(isIn(uv.y, 0.,cMax) && (isIn(uv.x, -cMax, -cMin)));
  return val+valB;
}

// Function 774
float udRoundRect( vec2 p, vec2 b, float r )
{
  return length(max(abs(p)-b,0.0))-r;
}

// Function 775
float draw_background(vec2 world_coordinates) {
    vec2 sections = mod(world_coordinates, 1.0);
    vec2 lines = abs(0.5 - sections) + 0.04;
    
    return min(lines.x, lines.y);
}

// Function 776
vec3 DrawCircle(vec2 uv){
	float val = clamp((1.0-length(uv)*2.),0.,1.);
	return vec3(val,val,val);
}

// Function 777
vec2 DirectSobol(uint index) {
	uvec2 result = uvec2(bitfieldReverse(index),0);
    for(int i=0; i < SobolNumber.length() && index > 0u; ++i, index >>= 1u)
        result.y ^= (index & 1u) * SobolNumber[i];
    return vec2(result>>8u) / vec2(0x1000000);
}

// Function 778
float UDAARectangle (in vec2 coords, in vec2 pos, in vec2 halfSize)
{        
	// make coords relative to pos
    coords -= pos;

    // calculate closest point
    vec2 closestPoint;
    closestPoint.x = clamp(coords.x, -halfSize.x, halfSize.x);
    closestPoint.y = clamp(coords.y, -halfSize.y, halfSize.y);
    
    // return length to closest point
    return length(coords - closestPoint);
}

// Function 779
float csg_sub_inlined (float a, float b, float r) {
    float d = abs(a + b);
    float q = max(r - d, 0.0);    
    return 0.5*(a - b - (d + q*q/r));
}

// Function 780
vec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)
{
    return mix(
        currentCol , 
        colLine ,
        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))
    );
}

// Function 781
float circle(vec2 uv, vec2 pos, float radius)
{
    return smoothstep(radius, radius - (2.0/iResolution.y), length(uv - pos));
}

// Function 782
vec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){
    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;
    float fish = 1.0 - dot(uv, uv) * FISHEYE;
	return normalize(cameraDir*fish + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 783
vec4 drawModes(in vec2 uv, in float mode, in float n)
{
    vec4 tcol = vec4(0.);
    
    if (in_zone(mode, APPL_UI))
    {
        float y_range = SELECTION_MODE_MAX.y - SELECTION_MODE_MIN.y;
        //float _x = SELECTION_MODE_MAX.x + 0.03;
        float lsize = 0.01;
    }
    
    return tcol;
}

// Function 784
void line_rgb (
    //inout vec4 fragColorR,
	inout vec3 rgb1,

    in float lat180,  
    in float lat180target, 
    in float lat180radius,

	vec3 rgb)
{
    if (lat180 < (lat180target + lat180radius))
        if (lat180 >( lat180target - lat180radius))
            
 		//if (lat180 < 108.)
     //   if (lat180 > 72.)            
        {

            
            //float a = 0.3;

            

            rgb1.rgb = rgb;

            //fragColorR.b = a;
            //fragColorR.g = a;

        }
}

// Function 785
float distCircle(vec2 p, float R, float r) { return abs(length(p) - R) - r; }

// Function 786
void rectangle(float ox, float oy, float sx, float sy) {
    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);
}

// Function 787
vec4 draw_ray(vec4 col, vec2 p, vec2 a, vec2 b)
{
	float h = line(p, a, b);
    col = blend(col, vec4(0., 0.435, 1., smoothstep(0.01, 0., abs(h))));
    return col;
}

// Function 788
vec3 get_rect(uint c, uint level) {
    uvec2 v = unpack_morton2x16(c);
    float r = 1.0 / float(1u << level);
    vec2 center = (vec2(v) / float(1u << MAX_LEVEL)) * 2.0 - 1.0 + r;
    return vec3(center, r);
}

// Function 789
vec2 polarToRect(vec2 v) {
	return v.x * vec2(cos(v.y), sin(v.y));
}

// Function 790
vec2 UIDrawContext_CanvasPosToScreenPos( UIDrawContext drawContext, vec2 vCanvasPos )
{
    return vCanvasPos - drawContext.vOffset + drawContext.viewport.vPos;
}

// Function 791
float Circle(vec2 uv, float r, float blur, float d) 
{
    return smoothstep(r+blur, r-blur, length( vec2(uv.x + uv.y * d, uv.y)));
}

// Function 792
float line(vec3 p, vec3 a, vec3 b)
{
    float d= lineDist(p, a, b);
    float m = smoothstep(.3, .01, d);
    return m;
}

// Function 793
void Line(vec2 screenCoord, vec2 p1, vec2 p2, float thickness, vec4 color, inout vec4 pixel)
{

  float a = distance(p1, screenCoord);
  float b = distance(p2, screenCoord);
  float c = distance(p1, p2);

  if ( a >= c || b >=  c ) return;

  float p = (a + b + c) * 0.5;

  float dist = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));

  if (dist<thickness)
  {
    pixel = mix(pixel, color, 1.0/max(1.0, dist*3.0));
  }
}

// Function 794
float rect(vec2 p, vec2 b, float inc) {
    p.x+=p.y*inc;
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 795
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line
    return length(p - b * h);                         // dist to segment
    // You might directly return smoothstep( 3./R.y, 0., dist),
    //     but more efficient to factor all lines.
    // Indeed we can even return dot(,) and take sqrt at the end of polyline:
    // p -= b*h; return dot(p,p);
}

// Function 796
void PrintBeginNextLine( inout PrintState state, const LayoutStyle style )
{
    // move Y position to baseline based on current font size
	state.vCursorPos.y += style.vSize.y * (g_fFontAscent + style.fLineGap);
}

// Function 797
float clampToLine (vec2 p1, vec2 p2, vec2 point, float line)
{
   vec2 mp = midpoint(p1,p2);
   float maxDistance = distance(mp,p1);
   if (distance(mp,point) > maxDistance)
   {
       return 0.;
   }
   else
   {
       return line;
   }
       
}

// Function 798
float distLine(vec2 p, vec2 a, vec2 b){
	vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba*t);
}

// Function 799
float drawAlpha(Ray r, vec2 p, float width)
{
    float d = dist(r, p);
    return mix(1.,0.,clamp(d*iResolution.y/2. - width, -1., 1.)*.5+.5);
}

// Function 800
vec2 Support_Rectangle (vec2 size, vec2 dir)
{
    return vec2(sign(dir.x)*size.x, sign(dir.y)*size.y);
}

// Function 801
bool line(float2 p, float2 p0, float2 p1)
{
	float2 dp=p1-p0;
    p-=p0;
    float2 n=p/dp;
    if(abs(dp.x)<abs(dp.y))
    {
        if((n.y<0.0)||(n.y>1.0))
            return false;
        float l=p.x-p.y*dp.x/dp.y;
        if(abs(l)<0.5)
            return true;
    }
    else
    {
        if((n.x<0.0)||(n.x>1.0))
            return false;
        float l=p.y-p.x*dp.y/dp.x;
        if(abs(l)<0.5)
            return true;
    }
    return false;
}

// Function 802
vec4 drawNumber(vec2 fragCoord, int number, vec2 localCoord, float size) {
    float n = float(number);
    vec2 Vec = localCoord;
    vec4 gd = vec4(0.0);
    while (true) {
        float frx = floor(fract(n/10.0)*10.0);
        vec4 g = glyph(fragCoord, Vec, vec2(-size,size), number0+int(frx));
        blend(gd,g);
        Vec.x -= size/2.0;
        float mdex = floor(n/10.0);
        if (mdex == 0.) break;
        n = n/10.0;
    }
    return gd;
}

// Function 803
float circle(vec2 pt, float r, vec2 center) {
  vec2 p = pt - center;
  return 1.-smoothstep(r-edge,r+edge, length(p));
}

// Function 804
float fOpIntersectionLinear(float a, float b, float r)
{
    return max(max(a, b), (a + r + b)*sqrt(0.5));
}

// Function 805
float line(vec2 uv, vec2 origin, vec2 destiny, float radius){
    destiny -= origin;
	float color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );
    return smoothstep(color-0.0005,color+0.0005, radius);    
}

// Function 806
vec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )
{  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
    return colOut;
}

// Function 807
vec3 sdgCircle( in vec2 p, in float r ) 
{
    float l = length(p);
    return vec3( l-r, p/l );
}

// Function 808
vec3 cosineDirection( in float seed, in vec3 nor)
{
    vec2 uv = hash2( seed);
    float a = 6.2831853 * uv.y;
    float u = 2.0*uv.x - 1.0;
    return /*normalize*/( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
}

// Function 809
void drawParatrooper(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {
    if (paratrooperData.x > 0. ) {
        ivec2 pos = ivec2(paratrooperData.xy);
        drawSprite(uv, pos - ivec2(2,8), pos + ivec2(2,0), ivec2(12,39), d, false, f);
        if (paratrooperData.z > 0. && paratrooperData.z < time) {
        	drawSprite(uv, pos - ivec2(6,22), pos + ivec2(6,-8), ivec2(0,34), d, false, f);            
        }
    }
}

// Function 810
void UI_SetDrawContext( inout UIContext uiContext, UIDrawContext drawContext )
{
    uiContext.drawContext = drawContext;
    
    uiContext.vPixelCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vPixelPos );
    uiContext.bPixelInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vPixelPos );

    uiContext.vMouseCanvasPos = UIDrawContext_ScreenPosToCanvasPos( drawContext, uiContext.vMousePos );
    uiContext.bMouseInView = UIDrawContext_ScreenPosInView( drawContext, uiContext.vMousePos );
}

// Function 811
vec2 ML_GetRect4(vec4 coord, vec4 rect){
    return vec2((coord.x - rect.x) / (rect.z / coord.z), (coord.y - rect.y) / (rect.w / coord.w));
}

// Function 812
bool DRAW(int i, int sx, int sy, ivec2 p){

    //ivec2 p = ivec2(fragCoord)/DS;
    
    if (i==0) return//Num 0
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)
    ;

    if (i==1) return//Num 1
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+2,p)||
    DOT(sx+2,sy+3,p)||
    DOT(sx+2,sy+4,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+4,p)
    ;
    
    if (i==2) return//Num 2
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+2,sy+3,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)
    ;
    
    if (i==3) return//Num 3
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;
    
    if (i==4) return//Num 4
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;   

    if (i==5) return//Num 5
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+1,sy+1,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+2,sy+3,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+2,sy+5,p)
    ;

    if (i==6) return//Num 6
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+1,sy+1,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+2,sy+3,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+2,p)
    ;
    
    if (i==7) return//Num 7
    DOT(sx+3,sy+1,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+5,p)
    ;

    if (i==8) return//Num 8
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;

    if (i==9) return//Num 9
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;
    
    if (i==10) return//Num A
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+3,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)
    ;
    
    
    if (i==11) return//Num B
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;
    
    if (i==12) return//Num C
    DOT(sx+2,sy+1,p)||
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)
    ;
    
    if (i==13) return//Num D
    DOT(sx+1,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+3,sy+2,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+3,sy+4,p)
    ;
    
    if (i==14) return//Num E
    DOT(sx+3,sy+1,p)||
    DOT(sx+2,sy+1,p)||
    DOT(sx+1,sy+1,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;
    
    if (i==15) return//Num F
    DOT(sx+1,sy+1,p)||
    DOT(sx+3,sy+5,p)||
    DOT(sx+2,sy+5,p)||
    DOT(sx+1,sy+5,p)||
    DOT(sx+3,sy+3,p)||
    DOT(sx+1,sy+2,p)||
    DOT(sx+1,sy+3,p)||
    DOT(sx+1,sy+4,p)||
    DOT(sx+2,sy+3,p)
    ;
    return false;
}

// Function 813
float hmd_waterline( vec2 coord )
{
    float result = 0.;
    vec3 v = g_vehicle.localB[0] * g_game.camframe;
	if( g_vrmode )
    	v *= g_vrframe;
    if( dot( v, v ) > .25e-6 )
    {
        float sz = hmd_symbol_border( v, HMD_BORDER_SYM );
		mat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );
    	vec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;
       	if( Linfinity( p ) < 10. )
        {
            vec2 a = sz * vec2( -3, -6 );
            vec2 b = sz * vec2( +3, -6 );
            vec2 c = sz * vec2( +6,  0 );
            vec2 d = sz * vec2( +9,  0 );
            float shape = 0.;
            shape = max( shape, aaa_line( I, p, a, vec2(0), 1. ) );
            shape = max( shape, aaa_line( I, p, b, vec2(0), 1. ) );
            shape = max( shape, aaa_line( I, p, a, -c, 1. ) );
            shape = max( shape, aaa_line( I, p, b, +c, 1. ) );
            shape = max( shape, aaa_hline( I, p, -d, sz * 3., 1. ) );
            shape = max( shape, aaa_hline( I, p, +c, sz * 3., 1. ) );
        	result += shape * sz;
        }
    }
    return result;
}

// Function 814
vec4 AntiAliasPointSampleTexture_Linear(vec2 uv, vec2 texsize) {	
	vec2 w=fwidth(uv);
	return texture(iChannel0, (floor(uv)+0.5+clamp((fract(uv)-0.5+w)/w,0.,1.)) / texsize, -99999.0);	
}

// Function 815
vec4 drawHole(vec4 inpColor, vec2 uv, vec2 pos)
{
    vec4 circleWhiteColor = vec4(vec3(0.95), 1.);
	float d = circle_d(uv, pos, 0.055);
    return vec4(mix(inpColor.rgb, circleWhiteColor.rgb, circleWhiteColor.a * dtoa(d)), 1.);
}

// Function 816
float sdf_circle(vec2 p, vec2 o, float r) {
    return length(p - o) - r;
}

// Function 817
float rectangle(float pre, vec2 p, vec2 half1, vec2 half2, float power) {
    p = abs(p);
    if ((half1.x<p.x || half1.y<p.y) && (p.x<half2.x && p.y<half2.y)) {
        pre = max(0.01, pre);
    }
    float dx1 = (p.y < half1.y) ? abs(half1.x-p.x) : length(p-half1);
    float dx2 = (p.y < half2.y) ? abs(half2.x-p.x) : length(p-half2);
    float dy1 = (p.x < half1.x) ? abs(half1.y-p.y) : length(p-half1);
    float dy2 = (p.x < half2.x) ? abs(half2.y-p.y) : length(p-half2);
    float d = min(min(dx1, dx2), min(dy1, dy2));
    float res = power / d;
    return clamp(pre + res, 0.0, 1.0);
}

// Function 818
vec3 BilinearTextureSample (vec2 P)
{
    vec2 pixel = P * c_textureSize + 0.5;
    
    vec2 frac = fract(pixel);
    pixel = (floor(pixel) / c_textureSize) - vec2(c_onePixel/2.0);

    vec3 C11 = texture(iChannel0, pixel + vec2( 0.0        , 0.0)).rgb;
    vec3 C21 = texture(iChannel0, pixel + vec2( c_onePixel , 0.0)).rgb;
    vec3 C12 = texture(iChannel0, pixel + vec2( 0.0        , c_onePixel)).rgb;
    vec3 C22 = texture(iChannel0, pixel + vec2( c_onePixel , c_onePixel)).rgb;

    vec3 x1 = mix(C11, C21, frac.x);
    vec3 x2 = mix(C12, C22, frac.x);
    return mix(x1, x2, frac.y);
}

// Function 819
vec3 directLightingBRDF(Material param, BRDFDesc desc)
{
    vec3 halfDir = normalize(desc.lightDir + desc.viewDir);
    float dotNV = dot(desc.normal, desc.viewDir);
    float dotNH = abs(dot(desc.normal, halfDir));
    float dotNL = abs(dot(desc.normal, desc.lightDir));
    float dotLH = abs(dot(desc.lightDir, halfDir));

    // Normal Distribution Function
    float dTerm = distribution(dotNH, param.roughness);
    
    // Fresnel
  	vec3 f0 = mix(vec3(0.04), param.diffuseColor.rgb, param.metallic);
    vec3 fTerm = fresnel(f0, dotLH);
    
    // Masking And Shadowing(Geometry Term)
    float gTerm = maskingAndShadowing(dotNL, dotNV, param.roughness);
    
    // Diffuse BRDF
	vec3 kd = mix(vec3(1.0) - fTerm, vec3(0.0), param.metallic);
    vec3 diffuse = param.diffuseColor;
    diffuse = (diffuse / PI) * kd * mix(dotNL, 1.0, param.metallic);
    
    // Specular BRDF
    vec3 specular = param.specularColor;
    specular *= dTerm * fTerm * gTerm;
    
    // Fr = Fd + Fs
    return (diffuse + specular) * desc.shadowAttenuation;
}

// Function 820
vec3 drawCircle2(vec2 c, float r, vec2 p, in vec3 bg, in vec3 fg) {
    float dist = length(p - c) - r;
    return edgeToMix2(dist, bg, fg);
}

// Function 821
float circle ( vec2 point, float radius ) 
{
    //vec2 origin = vec2( sin( iTime ), .0 );
   	vec2 origin = vec2( .0, .0 );
    return length(point - origin) - radius;
}

// Function 822
float Line(vec3 p, vec3 a, vec3 b) {
    vec3 ba=b-a;
    float k=dot(p-a,ba)/dot(ba,ba);
    return length((a+clamp(k,0.,1.)*(b-a))-p);
}

// Function 823
float d2line(vec2 p, vec2 a, vec2 b){//distance to line (a,b)
	vec2 v=b-a;
	p-=a;
	p=p-v*clamp(dot(p,v)/(dot(v,v)),0.,1.);//Fortunately it still work well when a==b => division by 0
	return min(0.5*scl,length(p));
}

// Function 824
vec4 directIllum(Camera c,Light l,vec3 pos,float dist, float index,float D){
	//compute the normal
	vec3 n = getNormal2(c,pos,index);
	//compute intensity
    float intensity = getIntensity(pos,l.p,n,index);
    if(intensity <=0.){
        intensity = 0.*PI;
    }else{
        intensity = PI*intensity;
    }
    
	float t ;
	vec4 obj;
	vec3 color;
    if(mod(iTime,9.) <3.){
    	//color map
		 color = getColor(index).xyz;
    }else if(mod(iTime,9.) <6. ){
    	//height map
        float h = (dist/(D));
     	color = vec3(h,h,h);
    }else{
    	//normal map
        color = n;
    }
    vec3 newColor = intensity * brdf(normalize(l.p-pos),normalize(c.e-pos), n, color,index);
    return vec4(newColor,1.);
}

// Function 825
vec3 hLine(vec2 uv, vec2 pos, float border, float width)
{
    float vl = smoothstep(pos.y-border/2., pos.y, uv.y) - smoothstep(pos.y, pos.y+border/2., uv.y);
    float hl = step(pos.x-width/2.,uv.x) - step(pos.x+width/2., uv.x);
    return vec3(1.-vl*hl);
}

// Function 826
void Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)
{	
	float fAttenuation = 1.0;
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.005, 10.0 );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fAttenuation, fShadowFactor);
}

// Function 827
float Linearize(float v) {return v * rsqrt(SqrLen(dFdxy(v)));}

// Function 828
float circle(vec2 st, float radius){
    vec2 pos = vec2(0.5)-st;
    radius *= 0.75;
    return 1.-smoothstep(radius-(radius*0.05),radius+(radius*0.05),dot(pos,pos)*3.14);
}

// Function 829
float circle(vec2 uv, float r, float b){
 	return st(r + b, r - b, length(uv));   
}

// Function 830
vec3 getLineColor(ivec2 n, vec2 f, int level) {
    float fx = abs(f.x - 0.5);
    float fy = abs(f.y - 0.5);

    if (fx < halfLineWidth || fy < halfLineWidth)  {
        float p = float(getPath(n, level)) - iTime * impulseSpeed ;
        if (mod(p, impulsePeriodLen) > impulseLength && mod(p + 1., impulsePeriodLen) > impulseLength)  return lineColor;

        ivec2 dir = getHomeNodeDir(n, level);
        float subPath = 1.;
        if (fx < halfLineWidth)  {
            float path;
            if (dir.y==-1)  path = f.y;
            else if (dir.y==1)  path = 1. - f.y;
            else  path = 0.5 + fy;
            subPath = path;
        }
        if (fy < halfLineWidth)  {
            float path;
            if (dir.x==-1)  path = f.x;
            else if (dir.x==1)  path = 1. - f.x;
            else  path = 0.5 + fx;
            if (path < subPath)  subPath = path;
        }

        p += subPath;
        float t = mod(p, impulsePeriodLen) / impulseLength;
        float v = (t > 1. ? 0. : sin(t*3.1415926535897932384626433832795));
        return mix(lineColor, impulseColor, v);
    }

    return backColor;
}

// Function 831
float drawDecPt( vec2 center, vec2 pixel_coords )
{
	return drawDig( center, pixel_coords, 1. );
}

// Function 832
bool whiteRectangle(vec2 uv)
	{
          // creating buttom left rectangle point
        
		bvec2 bl = lessThan(vec2 (-.1),uv);

        // creating top right rectangle point
        bvec2 tr = lessThan(vec2(-.1),-uv);

        // multiplie step layers
        return ( (bl.x && tr.x) && (bl.y && tr.y) ) ;
	}

// Function 833
float lineAOx2(vec2 pos, vec2 line0, vec2 line1, vec2 line2) {
	return lineAOv2(pos,line0,line1)* lineAOv2(pos,line1,line2);
}

// Function 834
vec2 rect_to_polar(vec2 rect) {
    float r = length(rect);
    float theta = atan(rect.y, rect.x);
    
    //Fix the coordinates so they go from 0 to 2PI
    //instead of -PI to PI. These two lines are optional
    if (theta < 0.0)
        theta += TAU;
    
    return vec2(r, theta);
}

// Function 835
float Circle(vec2 uv, float r, float blur) 
{
    float c = smoothstep(r+blur, r-blur, length(uv));
    return  c;
}

// Function 836
float circle(in vec2 p, in float r){
    return length(p) - r;
}

// Function 837
void DrawFinalWindow(in vec2 p, inout vec3 color)
{
    float deadt = max(0., gT - kFinishTime);
    vec3 frameColor = mix(color, blueColor, 0.6+0.4*sin(gT*2.));
    float d = uRoundBox(p, vec2(1.43, 0.63), 0.2);
    frameColor = mix(color, frameColor, smoothstep(0., 0.4, d ));
    color = mix(color, frameColor, min(deadt*0.25, 1.));
}

// Function 838
float draw_solid(float d) {
  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));
}

// Function 839
float aaa_vline( mat2 K, vec2 uv, vec2 x0, float h, float width )
{
    uv = uv - vec2( 0, h / 2. );
    return aaa_box( mat2( perp( K[0] ), perp( K[1] ) ), uv - x0, vec2( width, h ), vec2(0) );
}

// Function 840
void DrawFountain(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    DrawGlow(p, t, fireColor, color);
    
    float texpNormPow = pow(t, 0.5);
    vec2 gravity = gGravity * 0.15;
    
    for(float i=0.; i < 14.5; ++i)
    {   
        // Main Properties
        float hashP = hash(id+i*1492.8561);
        float pSpeed = (0.75+hashP*0.25);
        vec2 pVel = vec2(sin((i/14.)*PI*0.5)*2.-1., 0.6);
        
        pVel = normalize(pVel);
        
        vec3 pColor = clamp(mix(fireColor, vec3(abs(pVel.x), pVel.y, pSpeed), hashP*1.0), 0., 1.);

        // Visibility Properties
        float sizeScale = (0.8+0.2*hashP);
        float size = sizeScale*expSize*(0.05+sin(texpNormPow*PI*0.5)*0.1);

        // Position
        vec2 deltaPos = pVel*pSpeed* texpNormPow + (0.5*hashP+0.5)*gravity*t*t;
        float flicker = smoothstep(0.5, 0.6, texpNormPow);
        deltaPos += mix(vec2(0.), vec2( hash(i+t), noise(421.454+i*2.+t*flicker) )*0.08*flicker , flicker);
        vec2 q = p - deltaPos;

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.6, 9.0*hash(i+t*10.), color.a, 1.);
        color.rgb += pFinalColor.rgb; color.a = pFinalColor.a;
    }
    
    DrawFlicker(id, p, (t-0.3)/0.7, vel, fireColor, color);
}

// Function 841
float drawInt(int val, int minDigits)
{
  float c = 0.;
  if (val < 0)
  { val = -val;
    if (minDigits < 1) minDigits = 1;
    else minDigits--;
    _sub                   // add minus char
  }
  int fn = val, digits = 1; // get number of digits
  for (int n=0; n<10; n++)
  {
    fn /= 10;
    if (fn == 0) break;
    digits++;
  }
  digits = max(minDigits, digits);
  tp.x -= FONT_SPACE * float(digits);
  for (int n=1; n < 11; n++)
  {
    tp.x += FONT_SPACE; // space
    c += char(48 + (val-((val/=10)*10))); // add 0..9
    if (n >= digits) break;
  }
  tp.x -= FONT_SPACE * float(digits);
  return c;
}

// Function 842
float UDFatLineSegment (in vec2 coords, in vec2 A, in vec2 B, in float height)
{    
    // calculate x and y axis of box
    vec2 xAxis = normalize(B-A);
    vec2 yAxis = vec2(xAxis.y, -xAxis.x);
    float width = length(B-A);
    
	// make coords relative to A
    coords -= A;
    
    vec2 relCoords;
    relCoords.x = dot(coords, xAxis);
    relCoords.y = dot(coords, yAxis);
    
    // calculate closest point
    vec2 closestPoint;
    closestPoint.x = clamp(relCoords.x, 0.0, width);
    closestPoint.y = clamp(relCoords.y, -height * 0.5, height * 0.5);
    
    return length(relCoords - closestPoint);
}

// Function 843
vec3 rectDistance(vec3 pos, vec3 center, vec3 normal, float size) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    if (abs(dot(up, normal)) > 0.9) {
        up = vec3(0.0, 0.0, 1.0);
    }
    vec3 left = normalize(cross(up, normal));
    up = normalize(cross(normal, left));
    
    vec3 localPos = pos - center;
    
	float u = clamp(dot(localPos, up), -size, size);
    float v = clamp(dot(localPos, left), -size, size);
    
    vec3 clampPos = center + up * u + left * v;
    
    return vec3(length(clampPos - pos), v/size, u/size);
}

// Function 844
vec3 paintCircle (vec2 uv, vec2 center, float rad, float width, float index) {
    vec2 diff = center-uv;
    float len = length(diff);
    float scale = rad;
	float mult = mod(index, 2.) == 0. ? 1. : -1.; 
    len += variation(diff, vec2(rad*mult, 1.0), 7.0*scale, 2.0);
    len -= variation(diff, vec2(1.0, rad*mult), 7.0*scale, 2.0);
    float circle = smoothstep((rad-width)*scale, (rad)*scale, len) - smoothstep((rad)*scale, (rad+width)*scale, len);
    return vec3(circle);
}

// Function 845
vec4 line(vec2 p,vec2 start,vec2 end, vec4 currColor, vec4 newColor, bool mixColors )
{
    vec2 pa = -p - start;
    vec2 ba = end - start;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    float d = length( pa - ba*h );
    
    if(mixColors) {
		return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0) * (currColor + newColor) ;    
    }
    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0) * newColor;
}

// Function 846
void drawGrid(inout vec4 baseCol, float stepSize, vec4 gridCol)
{
  float mul = 1.0 / stepSize;
  vec2 g = abs(vec2(-0.5) + fract((uv + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals
  g = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);
  mixColor(baseCol, gridCol, max(g.x, g.y));
}

// Function 847
void raytraceHillTreeline(vec3 u,vec3 d,vec2 o,vec3 a,inout vec3 color,
                          inout float nearestD){a.x*=sign(d.x);
 float t=floor((u.z+d.z*(a.x-u.x)/d.x-o.x)/a.y)*a.y+a.y*.5+o.x;
 if(t>40.||t<-70.) return;//clipping planes
 if(t>.0)o.y+=t*a.z;//catches trees that otherwise float in the air
 raytraceTree(u,d,vec3(a.x,o.y,t),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,
              sin(t*.85+a.x),color,nearestD);}

// Function 848
float drawLineY( vec2 p1, vec2 p2)
{
    return distance(p1.y, p2.y);
}

// Function 849
RectSubdivResult rectSubdiv( vec3 p, vec3 scale ) {
    float t = iTime;

    // several constants
    const int ITERS = 12;
    const int MIN_ITERS = 1;
    const float MIN_SIZE = 0.15;
    const float BREAK_CHANCE = 0.0;
    const float PAD_FACTOR = 1.01;

    // the domain of the fractal being generated
    // will be modified in the iteration part
    vec3 domainMin = vec3( -0.5 ) * scale;
    vec3 domainMax = vec3( 0.5 ) * scale;

    // id of the individual cube in the fractal
    float id = 0.0;
    
    // random seed of cut positions
    float seed = floor( t / 6.0 ) + 0.1;

    // size of the current box determined by domainMin / domainMax
    vec3 dimension = domainMax - domainMin;
    
    for ( int i = 0; i < ITERS; i ++ ) {
        float fi = float( i );

        // divide the box into eight
        vec3 divideHash = vec3(
            fs( dot( vec2( fi + id, seed ), vec2( 1.26, 2.72 ) ) ),
            fs( dot( vec2( fi + id, seed ), vec2( 1.78, 0.47 ) ) ),
            fs( dot( vec2( fi + id, seed ), vec2( 0.78, 2.25 ) ) )
        );
        vec3 divide = divideHash * dimension + domainMin;

        // let the division line cut the box not too thin
        divide = clamp( divide, domainMin + MIN_SIZE * PAD_FACTOR, domainMax - MIN_SIZE * PAD_FACTOR );
        
        // does this cut the box to the minimum preferrable size?
        vec3 minSizeOfAxis = min( abs( domainMin - divide ), abs( domainMax - divide ) );
        float minSize = min( minSizeOfAxis.x, min( minSizeOfAxis.y, minSizeOfAxis.z ) );
        bool isSmallEnough = minSize < MIN_SIZE;

        bool willBreak = false;
        if ( i - 1 > MIN_ITERS && fs( id ) < BREAK_CHANCE ) { willBreak = true; }
        if ( isSmallEnough && i - 1 > MIN_ITERS || i == ITERS - 1 ) { willBreak = true; }
        if( willBreak ) {
            // id = i * 0.1 * seed;
            break;
        }

        // update the box domain
        domainMax = mix( domainMax, divide, step( p, divide ) );
        domainMin = mix( divide, domainMin, step( p, divide ) );

        // id will be used for coloring and hash seeding
        vec3 diff = mix( -divide, divide, step( p, divide ) );
        id = length( diff + 10.0 );
    
        // recalculate the dimension
        dimension = domainMax - domainMin;
    }
    
    // calculate volume and center of the box
    float volume = dimension.x * dimension.y * dimension.z;
    vec3 center = ( domainMin + domainMax ) / 2.0;
    
    // prepare the result
    RectSubdivResult result;
    result.volume = volume;
    result.center = center;
    result.dimension = dimension;
    result.domainMin = domainMin;
    result.domainMax = domainMax;
    result.id = id;
    
    return result;
}

// Function 850
vec2 toLinear(vec2 c) { return pow(c,vec2(GAMMA)); }

// Function 851
void SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )
{
    #define NO  1.0        // for perfect overal brigthness match
  //#define NO (16.0/17.0) // for normalizing to maximum = 1.0;
    sh[0] += col * (NO*PI*1.000) * (0.50*sqrt( 1.0/PI));
    sh[1] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.x;
    sh[2] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.y;
    sh[3] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.z;
    sh[4] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.x*v.z;
    sh[5] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.z*v.y;
    sh[6] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.y*v.x;
    sh[7] += col * (NO*PI*0.250) * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0);
    sh[8] += col * (NO*PI*0.250) * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);
}

// Function 852
void drawCylinder(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 cylNorm;
    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);
    
    if(cylT < cur_ctxt.t)
    {
        cur_ctxt.t = cylT;
        
        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;
    
        cur_ctxt.materialType = DIFFUSE; 
        cur_ctxt.color = 0.3*texture(iChannel0, worldPos.xz * worldPos.y).rgb 
                                        + 0.7*texture(iChannel2, ray.dir).rgb;
        //cur_ctxt.color = vec3(1, 0, 0);
        cur_ctxt.n = cylNorm;
        
        cur_ctxt.alpha = 0.0;
    }
}

// Function 853
float circle(in vec2 pos, in float radius, in float halo)
{
  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);
}

// Function 854
float DrawLine(vec2 a, vec2 b, float t, vec2 co){
    float dst = minimum_distance(a,b,co);
    return 1.0-smoothstep( t, t+1.0, dst );
}

// Function 855
vec4 draw_sprite_ship(vec2 uv){
    // Ship
    const float SCALE = 1.5;
    uv = (uv - 0.5);
    
    uv.y += 0.175;
    uv *= SCALE;
    
    vec2 unmirror = uv;
    uv.x = abs(uv.x); // Mirror
    
    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);
    
    // Wings
    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.75), vec2(0.5, 0.0)));
    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.35), vec2(0.5, 0.0)));
    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.35), vec2(0.15, 0.25)));
    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.5), vec2(0.15, 0.25)));
    
    // Engine
    outp = n_union(outp, line_segment(uv, vec2(0.15, -0.2), vec2(0.0, -0.25)));
    outp = n_union(outp, line_segment(uv, vec2(0.11, -0.22), vec2(0.06, -0.35)));
    outp = n_union(outp, line_segment(uv, vec2(0.0, -0.35), vec2(0.06, -0.35)));
    
    // Cockpit
    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.2), vec2(0.0, 0.35)));
    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.2), vec2(0.1, 0.1)));
    outp = n_union(outp, line_segment(uv, vec2(0.0, 0.15), vec2(0.1, 0.1)));
    
    outp.b = sqrt(outp.b) / SCALE;
    if (unmirror.x < 0.0) {
        outp.x *= -1.0;
    }
    return outp;
}

// Function 856
vec4 pulseDrawShadows(vec2 coord, float time){
    time = mod(time, PULSE_TIMES);
    
    vec4 r = vec4(0, 0, 0, 1.0);
    
    // Pulse variables
    float x = time / PULSE_TIMES, y;// = PULSE_FUNC(x * PI * PULSE_STEP);
    float px = coord.x, py; // = PULSE_FUNC(coord.x * PI * PULSE_STEP);
    vec2 pv, sx, sy;
    
#ifdef PULSE_CALL_GREEN
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_GREEN);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_GREEN);
    }
#endif
    
#ifdef PULSE_CALL_GREEN
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_GREEN);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_GREEN);
    }
#endif
    
#ifdef PULSE_CALL_BLUE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_BLUE);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_BLUE);
    }
#endif  

#ifdef PULSE_CALL_RED
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_RED);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_RED);
    }
#endif 
    
#ifdef PULSE_CALL_ORANGE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_ORANGE);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_ORANGE);
    }
#endif   
    
#ifdef PULSE_CALL_PURPLE
    if(r == vec4(0, 0, 0, 1.0)){
    	PULSE_FUNC_CALL(PULSE_CALL_PURPLE);
        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_PURPLE);
    }
#endif
    
    return r;
}

// Function 857
void draw_turtle_anim_diving( ivec2 frames, ivec2 pos, inout vec4 o, ivec2 iu ) {
    if( frames.y == 0 ) {
        draw_turtle( frames.x, pos, o, iu ) ;
    } else if( frames.y == 1 || frames.y == 5 ) {
        draw_turtle_dive( 0, pos, o, iu ) ;
    } else if( frames.y == 2 || frames.y == 4 ) {
        draw_turtle_dive( 1, pos, o, iu ) ;
    } else { //frames.y == 3
        draw_turtle_dive( 2, pos, o, iu ) ;
    }
}

// Function 858
float PointLineSegDist2d(vec2 a, vec2 b, vec2 p)
{
    if (a==b) return length(p-a);
    p -= a; b -= a;                        // go to A referential
    float q = dot(p, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate
    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P 
    return length( p - b);                 // distance to P
}

// Function 859
float draw_tiles(vec2 uv,float seed) {
    if (floor(rand(floor(uv)+(seed/0.12))+0.5) == 0.) {
        return tile_1(fract(uv));
    } else {
        return tile_2(fract(uv));
    }
}

// Function 860
v0 rect(v1 u,v3 m){return mav(abs(u*2.-m.xy)-m.xy)*.5;}

// Function 861
float SignedDistanceToLineSegment (in vec2 coordinate, in vec2 pointA, in vec2 pointB)
{
	vec2 AB = pointB - pointA;
	float ABlen = length(AB);
	AB = normalize(AB);
	vec2 AtoCoord = coordinate - pointA;
	
	float proj = dot(AtoCoord, AB);
	proj = max(proj, 0.0);
	proj = min(proj, ABlen);
	vec2 closestPoint = pointA + AB * proj;
	
	float sign = Signed2DTriArea(coordinate, pointA, pointB);
	if (sign > 0.0)
		return length(closestPoint - coordinate);
	else
		return -length(closestPoint - coordinate);
}

// Function 862
void DrawUI (in vec2 fragCoord, inout vec3 pixelColor, int sizeMode, int interpolationMode, bool upsizeImage)
{
    float aspectRatio = iResolution.x / iResolution.y;
    vec2 uv = (fragCoord / iResolution.xy);
    uv.x *= aspectRatio;
    uv.y = 1.0 - uv.y;
    
    vec2 buttonClickRelative = mod(uv, c_buttonSize+c_buttonPadding);
    vec2 buttonIndex = floor(uv / (c_buttonSize+c_buttonPadding));
    
    const float c_darkTint = 1.0 / 10.0;
    
    // draw the size mode buttons
    
    // full size
    {
        float tint = (sizeMode == 0) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(0.0, 0.0) * (c_buttonSize+c_buttonPadding);
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(tint), dist); 
    }
    
    // half size horizontally
    {
        float tint = (sizeMode == 1) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(1.0, 0.0) * (c_buttonSize+c_buttonPadding);;
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(0.0), dist); 
        
        center.x -= c_buttonSize * 0.25;
		dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.25, c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(tint), dist);
    }
    
    // half size vertically
    {
        float tint = (sizeMode == 2) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(2.0, 0.0) * (c_buttonSize+c_buttonPadding);;
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(0.0), dist); 
        
        center.y += c_buttonSize * 0.25;
        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5, c_buttonSize*0.25));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(tint), dist);         
    }      
    
    // quarter size
    {
        float tint = (sizeMode == 3) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(3.0, 0.0) * (c_buttonSize+c_buttonPadding);;
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(0.0), dist);
        
        center -= vec2(c_buttonSize * 0.25, -c_buttonSize * 0.25);
        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.25, c_buttonSize*0.25));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(tint), dist);          
    }     
    
    // eighth size
    {
        float tint = (sizeMode == 4) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(4.0, 0.0) * (c_buttonSize+c_buttonPadding);
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(0.0), dist);
        
        center -= vec2(c_buttonSize * 0.375, -c_buttonSize * 0.375);
        dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.125, c_buttonSize*0.125));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, vec3(tint), dist);
    }    
    
    // draw the blend mode icons
    
    // nearest neighbor
    {
        float tint = (interpolationMode == 0) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(0.0, 1.0) * (c_buttonSize+c_buttonPadding);  
        
        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;
        vec3 buttonColor = vec3(
            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),
            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),
			0.0);
        
        buttonColor = SampleInterpolationTextureNearest(percent);
        
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, buttonColor * tint, dist);        
    }

    // bilinear
    {
        float tint = (interpolationMode == 1) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(1.0, 1.0) * (c_buttonSize+c_buttonPadding);  
        
        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;
        vec3 buttonColor = vec3(
            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),
            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),
			0.0);
        
        buttonColor = SampleInterpolationTextureBilinear(percent);
        
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, buttonColor * tint, dist);       
    }  
    
    // bicubic
    {
        float tint = (interpolationMode == 2) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(2.0, 1.0) * (c_buttonSize+c_buttonPadding);  
        
        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;
        vec3 buttonColor = vec3(
            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),
            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),
			0.0);
        
        buttonColor = SampleInterpolationTextureBicubic(percent);
        
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, buttonColor * tint, dist);       
    }   
    
    // draw the image resample toggle
    
    // data
    {
        float tint = (!upsizeImage) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(0.0, 2.0) * (c_buttonSize+c_buttonPadding);  
        
        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;
        vec3 buttonColor = vec3(
            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),
            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),
			0.0);
        
        buttonColor = vec3(1.0);
        
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, buttonColor * tint, dist);        
    }    
    
    // image
    {
        float tint = (upsizeImage) ? 1.0 : c_darkTint;
        vec2 center = vec2(c_buttonSize*0.5 + c_buttonPadding);
        center += vec2(1.0, 2.0) * (c_buttonSize+c_buttonPadding);  
        
        vec2 percent = (uv - (center - vec2(c_buttonSize*0.5))) / c_buttonSize;
        vec3 buttonColor = vec3(
            clamp(floor(percent.x * 4.0) / 3.0, 0.0, 1.0),
            clamp(floor(percent.y * 4.0) / 3.0, 0.0, 1.0),
			0.0);
        
        buttonColor = vec3(1.0);
        
        float dist = UDAARectangle(uv, center, vec2(c_buttonSize*0.5));
        dist = 1.0 - smoothstep(0.0, AA_AMOUNT, dist);
        pixelColor = mix(pixelColor, buttonColor * tint, dist);        
    }        
}

// Function 863
float Circle(vec2 uv, vec2 p, float r, float blur){ // Function creates a circle of radius r, with blur 
    float d = length(uv-p); // Distance formula 
    float c = smoothstep(r, r-blur, d); // Blurs the edges 
    return c; // Returns the circle
}

// Function 864
float drawCapsule(vec3 p,vec3 a,vec3 b,float r)
{
    vec3 ap = p - a;
    vec3 ab = b - a;
    
    vec3 c = a + ab * clamp(dot(ap,ab) / dot(ab,ab),0.0,1.0);
    return length(c - p) - r;
}

// Function 865
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = xross( g, f );
    float k1 = xross( e, f ) + xross( h, g );
    float k0 = xross( h, e );
    
    float w = k1*k1 - 4.0*k0*k2;
    
    if( w<0.0 ) return vec2(-1.0);

    w = sqrt( w );
    
    float v1 = (-k1 - w)/(2.0*k2);
    float v2 = (-k1 + w)/(2.0*k2);
    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);
    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);
    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;
    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;
    
    vec2 res = vec2(-1.0);

    if(  b1 && !b2 ) res = vec2( u1, v1 );
    if( !b1 &&  b2 ) res = vec2( u2, v2 );
    
    return res;
}

// Function 866
float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)
{
    vec2 d = max(tl - uv, uv - br);
    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));
}

// Function 867
vec4 drawTriangle( in vec2 p1, in vec2 p2, in vec2 p3, in vec2 pos
                 , in vec4 col, in vec4 fillColor, in vec4 frameColor
                 , in float frameSize )
{
  float d = sdTriangle(p1, p2, p3, pos);
  if (d > frameSize)   // outside ?
    return col;
  float s = 1.0 - smoothstep(0.0,frameSize,abs(d));
  if (d <= 0.0)
    return mix( fillColor, frameColor, s*col.w); // inside
  else 
    return mix( col, frameColor, s);   // outside
}

// Function 868
float IsWithinCircle(vec2 vPos, vec2 fragCoord)
{
	// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel
	vec2 vScreenPixelCoordinate = fragCoord.xy;

	// We calculate how far in pixels we are from the mouse pointer
	float fPixelsToPosition = length(vScreenPixelCoordinate - vPos);
	
	// return 1.0 if the distance to the mouse pointer is less than 8.0 pixels, 0.0 otherwise
	return step(fPixelsToPosition, 8.0);
}

// Function 869
vec4 draw( vec2 uv ) {
    vec2 dirVec = VERT ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 );
    float wid = VERT ? iResolution.y : iResolution.x;
    float pos = VERT ? floor( uv.y * iResolution.y ) : floor( uv.x * iResolution.x );
    
    float val = gray( texture( iChannel0, uv ).xyz );
    
    if ( !thr( val ) ) {
        float post = pos;
        float rank = 0.0;
        float head = 0.0;
        float tail = 0.0;
        
        for ( int i = 0; i < int( wid ); i ++ ) {
            post -= 1.0;
            if ( post == -1.0 ) { head = post + 1.0; break; }
            vec2 p = dirVec * ( post + 0.5 ) / wid + dirVec.yx * uv;
            float v = gray( texture( iChannel0, p ).xyz );
            if ( thr( v ) ) { head = post + 1.0; break; }
            if ( v <= val ) { rank += 1.0; }
        }
        
        post = pos;
        for ( int i = 0; i < int( wid ); i ++ ) {
            post += 1.0;
            if ( wid == post ) { tail = post - 1.0; break; }
            vec2 p = dirVec * ( post + 0.5 ) / wid + dirVec.yx * uv;
            float v = gray( texture( iChannel0, p ).xyz );
            if ( thr( v ) ) { tail = post - 1.0; break; }
            if ( v < val ) { rank += 1.0; }
        }
        
        pos = REVERSE ? ( tail - rank ) : ( head + rank );
    }
    
    return vec4( toRgb( pos ), 1.0 );
}

// Function 870
vec4 DrawMap( vec2 vTexCoord )
{
    if ( vTexCoord.y < 0.0 )
    {
        return vec4(0,0,0,1);
    }    
        
    float fScale = 10.0;
        
    vec2 vPixelWorldPos = vTexCoord;    
    vPixelWorldPos -= vec2(200, 150); 
    vPixelWorldPos *= fScale;
    vPixelWorldPos += vec2(1056, -3616);
    
    fScale *= 1.1;
    
    //for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)
    for(int iSectorIndex=0; iSectorIndex < g_mapInfo.iSectorCount; iSectorIndex++)
    {
        //if ( iSectorIndex > g_mapInfo.iSectorCount )
          //  break;

        Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );

        /*if ( Map_PointInSector( vPixelWorldPos, sector ) )
{
vResult = vec3(1,0,0);
}*/


        for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)
        {
            SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        

            vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );

            float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );
            fProj = clamp( fProj, 0.0, sideDef.fLength );

            vec2 vClosest = sideDef.vA + vSideDir * fProj;
            float fDist = length( vClosest - vPixelWorldPos );

            if (fDist < fScale * .5 )
            {
                if ( sideDef.iNextSector != SECTOR_NONE )
                {
                    return vec4(1,1,0,1);
                }
                else
                {
                    return vec4(1,0,0,1);
                }
            }
        }			
    }
        
    return vec4(0.0);
    
}

// Function 871
float fLineSegment(vec3 p, vec3 a, vec3 b)
{
    vec3  ab = b - a;
    float t  = saturate(dot(p - a, ab) / dot(ab, ab));
    return length((ab * t + a) - p);
}

// Function 872
vec4 draw_font8x8_char( int ch, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( ch > 0 && iINSIDE( iu, ivec2(0), ivec2(8) ) ) {
        if( col.a == 0. ) {
            col.a = 1. ;
        } else {
            v = vec4( 0,0,0,1 ) ;
        }
            
        ch -- ;
        int row_group = ( ch >> 2 ) * 2 + 1 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = iu.x ;
        uint bit = 0x1U << sh,
             col_ind = ( get_font8x8_br( row_group, component, ch & 0x3 ) & bit ) >> sh ;
        v = col_ind == 1U ? col : v ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 873
void DrawText( inout vec3 color, vec2 edge, vec2 center, vec2 world, in GameState s )
{
    // xp
    if ( s.logPos[ 0 ].x > 0. )
    {
        float t = 1e4;
        
        vec2 p = world;
        p -= s.logPos[ 0 ] * 16.;
        p.x += 8.;
        p.y -= s.logLife[ 0 ] * 16.;
        PrintChar( t, p, 43. );
        PrintVal( t, p, s.logVal[ 0 ] );
        PrintChar( t, p, 69. );
        PrintChar( t, p, 88. );
        PrintChar( t, p, 80. );
        
		if ( s.logId[ 0 ] > 0. )
        {
            p = world;
            p -= s.logPos[ 0 ] * 16.;
            p.x += 16.;
            p.y -= s.logLife[ 0 ] * 16. - 8.;
           	PrintChar( t, p, 76. );
            PrintChar( t, p, 69. );
            PrintChar( t, p, 86. );
            PrintChar( t, p, 69. );
            PrintChar( t, p, 76. );
            PrintChar( t, p, 32. );
            PrintChar( t, p, 85. );
            PrintChar( t, p, 80. );
            PrintChar( t, p, 33. );
        }
        
        RastText( color, t, s.logLife[ 0 ], vec3( 1., 1., 0. ) );
    }    
    
    // heal
    if ( s.logPos[ 1 ].x > 0. )
    {
        float t = 1e4; 
        vec2 p = world;
        p -= s.logPos[ 1 ] * 16.;
        p.x += 8.;
        p.y -= s.logLife[ 1 ] * 16.;      
        PrintChar( t, p, 43. );
        PrintVal( t, p, s.logVal[ 1 ] );
        PrintChar( t, p, 72. );
        PrintChar( t, p, 80. );
        RastText( color, t, s.logLife[ 1 ], vec3( 0., 1., 0. ) ); 
    }
    
    // dmg
    for ( int i = 2; i < LOG_NUM; ++i )
    {
		float t = 1e4;        
        
        if ( s.logPos[ i ].x > 0. )
        {
            vec2 p = world;
            p -= s.logPos[ i ] * 16.;
            p.y -= s.logLife[ i ] * 16.;        
            PrintVal( t, p, s.logVal[ i ] );
        }
        
        RastText( color, t, s.logLife[ i ], vec3( 1., 0., 0. ) );     
    }
    
    // game over
    if ( s.state == STATE_GAME_OVER )
    {      
        float alpha = Smooth( ( s.stateTime - 0.33 ) * 4. );
        
        color = mix( color, color.yyy * .5, alpha );
        
        float t = 1e4; 
        
        vec2 p = .25 * center;
        p.x += 24.;
        p.y += 6.;
        PrintChar( t, p, 89. );
        PrintChar( t, p, 79. );
        PrintChar( t, p, 85. );
        p.x -= 4.;
        PrintChar( t, p, 68. );
        PrintChar( t, p, 73. );
        PrintChar( t, p, 69. );
        PrintChar( t, p, 68. );
        
        RastText( color, t, 1. - alpha, vec3( 1., 0., 0. ) );     
    }
    
    // level
    vec2 p = edge + vec2( 2.2, 20.8 );
    float t = 1e4;
    PrintChar( t, p, 48. + s.level + 1. );
    color = mix( color, vec3( 1. ), Smooth( -t * 100. ) ); 
}

// Function 874
float rect(vec2 r, vec2 bottomLeft, vec2 topRight) {
	float ret;
	float d = 0.005;
	ret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);
	ret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);
	ret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);
	ret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);
	return ret;
}

// Function 875
vec3 srgb_linear(vec3 x) {
#ifdef GAMMA_CORRECT
    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));
#else
    return x;
#endif
}

// Function 876
float linearstep0( const float e, float v ) {
    return min( v*(1./e), 1. );
}

// Function 877
bool testLinesIntersect(const in Line ray, const in Line edge, out float dist){
    float s1_x = ray.p1.x - ray.p0.x,
          s1_y = ray.p1.y - ray.p0.y,
    	  s2_x = edge.p1.x - edge.p0.x,
          s2_y = edge.p1.y - edge.p0.y,
    	  s = (-s1_y * (ray.p0.x - edge.p0.x) + s1_x * (ray.p0.y - edge.p0.y))
        		/ (-s2_x * s1_y + s1_x * s2_y);
    	  dist = ( s2_x * (ray.p0.y - edge.p0.y) - s2_y * (ray.p0.x - edge.p0.x))
        		/ (-s2_x * s1_y + s1_x * s2_y);
	return (s >= 0. && s <= 1. && dist >= 0. && dist <= 1.);
}

// Function 878
float sdCircle(vec2 uv, vec2 center, float r)
{
    vec2 c = (uv - center);
    return 1.0-clamp(dot(c,c)/r,0.0,1.0);
}

// Function 879
vec4 circle(vec2 uv,vec2 pos,float rad,vec3 color)
{
 	float cha = length(uv-pos) - rad;
    return vec4(color,1.0 - cha);
}

// Function 880
float aaa_rect( mat2 K, vec2 uv, vec2 size, vec2 d )
{
    return aaa_box( K, uv, size + d, vec2(0) ) * ( 1. - aaa_box( K, uv, size - d, vec2(0) ) );
}

// Function 881
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross( g, f );
    float k1 = cross( e, f ) + cross( h, g );
    float k0 = cross( h, e );
    
    float w = k1*k1 - 4.0*k0*k2;

    w = sqrt(abs( w ));
    
    float v1 = ((-k1 - w)/(2.0*k2));
    float v2 = ((-k1 + w)/(2.0*k2));
    float u1 = ((h.x - f.x*v1)/(e.x + g.x*v1));
    float u2 = ((h.x - f.x*v2)/(e.x + g.x*v2));
    bool  b1a = v1>0.0 && v1<1.0;
    bool  b1b = u1>0.0 && u1<1.0;
    bool  b2a = v2>0.0 && v2<1.0;
    bool  b2b = u2>0.0 && u2<1.0;
    

    vec2 res = vec2(min(abs(u1), abs(u2)), min(abs(v1), abs(v2)));
    
    return saw(res);
}

// Function 882
float outline(float dist, float width)
{
    float a = clamp(dist + width, 0.0, 1.0);
    float a2 = clamp(dist, 0.0, 1.0);
    return a - a2;
}

// Function 883
float circle(vec2 uv, float r)
{
    float l=length(uv-.5);
    return 1.-smoothstep(r-.05,r+.05,l);
}

// Function 884
vec3 randomHemisphereDirection( const vec3 n, inout float seed ) {
	vec3 dr = randomSphereDirection(seed);
	return dot(dr,n) * dr;
}

// Function 885
vec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {
	vec2 d0mM, d3mM;
	for (int i=0; i<SUBDIV; i++) { // iterative subdivision
		if (i >= n) continue;
		
		// construct the 2 sub- control polygons
		vec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),
			 P012  = .5*(P01+P12),  P123 = .5*(P12+P23),
			 P0123 = .5*(P012+P123); // is on the spline

		
		d0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1
		d3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2
		
		bool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);
		d0mM = abs(d0mM); d3mM=  abs(d3mM);
			
		if (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )
			return vec2(0.,float(i));    // draw skeleton
		float s;


		// inside one of the sub quadri
		if      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;
		else 
#if 1
		if (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer
		else if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer
			else // ambiguous
			  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method
#else
			if (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)
#endif
		
		if (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1
		else      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2
   	}
	
	if (n<0) // ambiguity found: switch to costly method
		return dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); 
	
  	return dist2quadri(pos, P0,P1,P2,P3);
}

// Function 886
void drawTree(vec2 uv, vec2 basePoint, int branches, int iterations, float size, vec3 branchColour, vec3 leafColour, inout vec3 value)
{
    //Draw the Trunk
    drawBranch(uv, basePoint, vec2(basePoint.x, basePoint.y + size), 0.003, 0.001, branchColour, value);
    
    //Draw the Branches
    for (int i = 0; i < branches; i ++)
    {
        //Set Branch Properties
        float randomFactor = map(randomValue(vec2(basePoint.y) * float(i)), 0., 1., 0.3, 1.);
        float branchLength = size;
        float branchAngle = 50.;
        float branchThickness = 0.0015;
        
        //Set Previous && Current Branch Position
        vec2 currentBranch;
        vec2 previousBranch = lengthdir(basePoint, radians(90.), 
                                        distance(basePoint, vec2(basePoint.x, basePoint.y + size)) * randomFactor);
        for (int j = 0; j < iterations; j ++)
        {
            //Change the Branch Properties
            randomFactor = map(randomValue(vec2(previousBranch.y)), 0., 1., 0.5, 1.);
            branchLength *= 0.8 * randomFactor;
            branchAngle -= 15. * randomFactor;
            branchThickness -= 0.00025;
            
            float angleSign = sign(float(mod(float(j) + float(i), 2.) == 0.) - 0.5);
            float currentAngle = radians(90. + branchAngle * angleSign);
            float currentLength = branchLength * randomFactor;
            
            //Set Current Branch Position for Draw
			currentBranch = lengthdir(previousBranch, currentAngle, branchLength);
            drawBranch(uv, previousBranch, currentBranch, branchThickness, 0.001, branchColour, value);
            drawDisk(uv, currentBranch, 1. / (currentBranch.y - basePoint.y) * size * 0.03, 0.0001, leafColour, value);
            //drawDisk(uv, currentBranch, (currentBranch.y - basePoint.y) * 0.15, 0.0001, leafColour, value);
            
            //Set Current Branch Position for the Next Iteration
            currentBranch = lengthdir(previousBranch, currentAngle, currentLength);
            previousBranch = currentBranch;
        }
    }
}

// Function 887
vec4 moveRectangle(vec4 try,vec2 uv){

    vec2 translate = vec2(cos(iTime),sin(iTime));
    uv += translate*0.35;
    float rectangle = polygon(uv, vec2(0.0,0.0), 0.1, 0.001, 4);
    
    vec3 giveColor = vec3(1.0,1.0,0.0) * rectangle;
    try = vec4(giveColor,1.0);
    
    return try;
    
}

// Function 888
float line(vec2 P,vec2 A,vec2 B){vec2 g=B-A;return abs(dot(normalize(vec2(g.y,-g.x)),P-A));}

// Function 889
void init_rect_points(out vec3 points[4])
{
    // get the orthogonal basis of polygon light
    vec3 right=normalize(cross(light_normal, vec3(0.0, 1.0, 0.0)));
    vec3 up=normalize(cross(right, light_normal));
    
    vec3 ex = light_width * right;
    vec3 ey = light_height * up;

    points[0] = light_pos - ex - ey;
    points[1] = light_pos + ex - ey;
    points[2] = light_pos + ex + ey;
    points[3] = light_pos - ex + ey;
}

// Function 890
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float theta = 180.0*(atan(d.y,d.x)/M_PI);
    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *
        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *
        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));
}

// Function 891
vec3 getScanline( vec2 pos, float off ) {
	// 3-tap gaussian filter to get colour at arbitrary point along scanline
    vec2 ir = IRES * TILES;
    float d = 0.5-fract(pos.x*ir.x);
	vec3 ca = getSample( pos, vec2(-1.0, off ) );
	vec3 cb = getSample( pos, vec2( 0.0, off ) );
	vec3 cc = getSample( pos, vec2( 1.0, off ) );
	float wa = gaussian( d-1.0, PIXEL_SHARPNESS );
	float wb = gaussian( d,     PIXEL_SHARPNESS );
	float wc = gaussian( d+1.0, PIXEL_SHARPNESS );
	return ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);
}

// Function 892
vec3 gammaToLinear(const in vec3 gammaColor) {
   return pow(gammaColor, vec3(2.2));
}

// Function 893
vec3 GetLightDirection()
{
    return normalize(vec3(-.1, 1.0, 1.0));
}

// Function 894
float ucircle(vec2 p, vec2 o, float r) {
    return abs(length(p-o)-r);
}

// Function 895
float circle(vec2 p, float r) {
	return length(p) - r;
}

// Function 896
vec3 draw_star(vec2 pos, float I) {
	// star out of screen
    const float margin = .2;
	if (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);
	
	pos -= FragCoord.xy/iResolution.y; 
	
// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1
// pixels >> fringes -> smoothed Airy ~ 1/x^3
	float d = length(pos)*SCALE;
	
	vec3 col, spectrum = I*star_color;
#if 1
	col = spectrum/(d*d*d);
#else
	col = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);
#endif
	
// 2ndary mirror handles signature (assuming handles are long ellipses)
	d = length(pos*vec2(50.,.5))*SCALE;
	col += spectrum/(d*d*d);
	d = length(pos*vec2(.5,50.))*SCALE;
	col += spectrum/(d*d*d);

	return col;
}

// Function 897
vec4 NOISE_trilinearWithDerivative(vec3 p)
{
    //Trilinear extension over noise derivative from (Elevated), & using the noise stacking trick from (Clouds).
	//Inspiration & Idea from :
    //https://www.shadertoy.com/view/MdX3Rr (Elevated)
    //https://www.shadertoy.com/view/XslGRr (Clouds)
    
    //For more information, see also:
    //NoiseVolumeExplained : https://www.shadertoy.com/view/XsyGWz
	//2DSignalDerivativeViewer : https://www.shadertoy.com/view/ldGGDR
    
    const float TEXTURE_RES = 256.0; //Noise texture resolution
    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]
    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)
    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.
	//Note : shift is different from g to b layer (but it also works)
    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; 
    
    vec2 c1 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;
    vec2 c2 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x
    vec2 c3 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z
    vec2 c4 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z
    
    vec3 x = p-pixCoord; //Pixel interpolation position, linear range [0-1] (fractional part)
    
    vec3 x2 = x*x;
    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Quintic ease-in/ease-out function.
    vec3 d_xyz = (30.*x2-60.*x+30.)*x2; //dt/dx : Ease-in ease-out derivative.
    
    //Lower quad corners
    float a = c1.x; //(x+0,y+0,z+0)
    float b = c2.x; //(x+1,y+0,z+0)
    float c = c3.x; //(x+0,y+1,z+0)
    float d = c4.x; //(x+1,y+1,z+0)
    
    //Upper quad corners
    float e = c1.y; //(x+0,y+0,z+1)
    float f = c2.y; //(x+1,y+0,z+1)
    float g = c3.y; //(x+0,y+1,z+1)
    float h = c4.y; //(x+1,y+1,z+1)
    
    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.
    float za = ((a+(b-a)*t.x)*(1.-t.y)
               +(c+(d-c)*t.x)*(   t.y));
    float zb = ((e+(f-e)*t.x)*(1.-t.y)
               +(g+(h-g)*t.x)*(   t.y));
    float value = (1.-t.z)*za+t.z*zb;
    
    //Derivative scaling (texture lookup slope, along interpolation cross sections).
    //This could be factorized/optimized but I fear it would make it cryptic.
    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)
               +((f-e)+t.y*(e-f-g+h))*(   t.z);
    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)
               +((g-e)+t.x*(e-f-g+h))*(   t.z);
    float sz =  zb-za;
    
    return vec4(value,d_xyz*vec3(sx,sy,sz));
}

// Function 898
float lineDist( vec3 p, vec3 a, vec3 b )
{
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 899
float GetScanline( vec2 vUV )
{
#if 1
    vUV.y *= 0.25;
    vec2 dx = dFdx( vUV );
    vec2 dy = dFdy( vUV );
    float dV = length( vec2( dx.y, dy.y ) );
    if (dV <= 0.0 ) return 1.0;
    return Scanline( vUV.y, dV * 1.3 );
#else
    return 1.0;
#endif
}

// Function 900
float maskRect(vec2 p, float dx, float dy)
{
    return (step(-dx, p.x) - step(dx, p.x))*(step(-dy, p.y) - step(dy, p.y));
}

// Function 901
float dashedCircle(vec2 uv, in float radius, in float width, in float density)
{
 	float angle = atan(uv.y, uv.x) + PI;
    angle /= TWO_PI;
    angle = fract(angle * density);
    float circ = circle(uv, radius, width);
    return circ * smoothstep(0.1, 0.11, abs(angle - 0.5));
}

// Function 902
vec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )
{
    vec2 off = dir2dis(pacmanMovDirNex.x);
    
    vec2 mPacmanPos = pacmanPos.xy;
    //vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;

    vec2 p = fragCoord/iResolution.y;
    float eps = 1.0 / iResolution.y;

    vec2 q = p - cell2ndc( mPacmanPos );

    float c = max(0.0,sdCircle(q, 0.023));

    // glow
    col += 0.25*vec3(1.0,0.8,0.0)*exp(-400.0*c*c);

    return col;
}

// Function 903
vec3 circle(vec2 pos,float r,float time,vec3 col)
{
    vec2 center = vec2 (mod(time*0.1,3.)-1.5,sin(time)*0.1);
    vec2 p = pos - center;
    float th = atan(p.x,p.y)+0.1*sin(time);
    float n1 = 7.,n2 = 3.;
    float grade = 0.5;
    float shape = r*abs(sin(n1/2.*th+3.14/2.))*(1.+1.*abs(cos(n1/2.*n2*th)))+r/3.;
    shape = shape * (abs(cos(0.5*th))*grade+1.-grade);
    return max(col,(1.+sign(length(p)-shape))/2.);
}

// Function 904
float circle(vec2 pos, float radius)
{
    float d = length(uv-pos);
    return smoothstep(d,d+0.01,radius);
}

// Function 905
vec4 NOISE_trilinearWithDerivative(vec3 p)
{
    //Trilinear extension over noise derivative from (Elevated), & using the noise stacking trick from (Clouds).
	//Inspiration & Idea from :
    //https://www.shadertoy.com/view/MdX3Rr (Elevated)
    //https://www.shadertoy.com/view/XslGRr (Clouds)
    
    //For more information, see also:
    //NoiseVolumeExplained : https://www.shadertoy.com/view/XsyGWz
	//2DSignalDerivativeViewer : https://www.shadertoy.com/view/ldGGDR
    
    const float TEXTURE_RES = 256.0; //Noise texture resolution
    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]
    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)
    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.
	//Note : shift is different from g to b layer (but it also works)
    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; 
    
    vec2 c1 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;
    vec2 c2 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x
    vec2 c3 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z
    vec2 c4 = texture(iChannel0,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z
    
    vec3 x = p-pixCoord; //Pixel interpolation position, linear range [0-1] (fractional part)
    
    vec3 x2 = x*x;
    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Quintic ease-in/ease-out function.
    vec3 d_xyz = (30.*x2-60.*x+30.)*x2; //dt/dx : Ease-in ease-out derivative.
    
    //Lower quad corners
    float a = c1.x; //(x+0,y+0,z+0)
    float b = c2.x; //(x+1,y+0,z+0)
    float c = c3.x; //(x+0,y+1,z+0)
    float d = c4.x; //(x+1,y+1,z+0)
    
    //Upper quad corners
    float e = c1.y; //(x+0,y+0,z+1)
    float f = c2.y; //(x+1,y+0,z+1)
    float g = c3.y; //(x+0,y+1,z+1)
    float h = c4.y; //(x+1,y+1,z+1)
    
    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.
    float za = ((a+(b-a)*t.x)*(1.-t.y)
               +(c+(d-c)*t.x)*(   t.y));
    float zb = ((e+(f-e)*t.x)*(1.-t.y)
               +(g+(h-g)*t.x)*(   t.y));
    float value = (1.-t.z)*za+t.z*zb;
    
    //Derivative scaling (texture lookup slope, along interpolation cross sections).
    //This could be factorized/optimized but I fear it would make it cryptic.
    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)
               +((f-e)+t.y*(e-f-g+h))*(   t.z);
    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)
               +((g-e)+t.x*(e-f-g+h))*(   t.z);
    float sz =  zb-za;
    
    return vec4(value,d_xyz*vec3(sx,sy,sz));
}

// Function 906
vec4 draw_char() {
    int c = char_id; vec2 p = char_pos;
    return c < 0 
        ? vec4(0,0,0,1e5)
        : textureGrad( TEXTCHANNEL, p/16. + fract( vec2(c, 15-c/16) / 16. ), 
                       dfdx, dfdy );
}

// Function 907
vec3 isolines(in vec3 position, float offset) {
    float l = mod(offset * 08.0, 1.0);
    vec3 color = vec3(1.0, 1.0, 1.0);
    vec3 border_color = vec3(0.0, 0.0, 1.);
    float bands = clamp(-100.0 * l * (l - 0.2), 0.0, 1.0);
    color *= bands;
    color = mix(color * 0.05, border_color, 1.0-smoothstep(0.00, 0.015, abs(offset)));
    return color;
}

// Function 908
vec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb)
{
	float buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);
	vec2 intersection = float2(buffer, sa*(buffer - A.x) + A.y);
	return intersection;
}

// Function 909
void DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){
    
    
    vec2 vector = end - origin;
          uv  -= origin;
    float len  = length(vector);
       vector /= len;
    float v2   = dot(vector, vector);
    float vUv  = dot(vector, uv);
    vec2  p    = vector * clamp(vUv, 0.,len) /v2;
    float d    = distance(p, uv);

    sceneColor = mix(lineColor, sceneColor, clamp(aaStep(size, d), 0. ,1.)); 
}

// Function 910
void drawSlider(inout vec3 color, in vec2 p, in vec2 pos, in float len, in float rmin, in float rmax, in float val) {
    p -= pos;

    float hlen = 0.5 * len;
    float unit = 2.0 / iResolution.y;

    float d = length(vec2(max(0.0, abs(p.x) - hlen), p.y)) - 0.01;
    color = mix(color, vec3(0.5), smoothstep(unit, 0.0, d));

    d = length(p - vec2(mix(-hlen, hlen, (val - rmin) / (rmax - rmin)), 0.0)) - 0.02;
    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, d));
}

// Function 911
float bgLines(vec2 p){
   
  p = abs(fract(p) - .5);
  #ifdef SHOW_SINGLE_TILES
  return min(p.x, p.y);  
  #else
  return p.x;
  #endif
    
}

// Function 912
vec3 ExposureCorrect(vec3 col, float linfac, float logfac){
	return linfac*(1.0 - exp(col*logfac));
}

// Function 913
void drawRoad(in vec2 uvCoords, inout vec4 canvas)
{
    float s = step(0.0, uvCoords.y);
    float t = mod(iTime, 60.0); //needed hack for long-running scenes
    vec4 road = vec4(vec3(sign(sin(70.0 * pow(-uvCoords.y, 0.3) - 25.0 * t))), 1.0);
    
    road = clamp(road, 0.0, 1.0); //needed due to sqrt() of negative values
    road *= vec4(2.0 * (0.5 + uvCoords.y),
                 1.6 * (0.5 + uvCoords.y),
                 1.8 * (0.5 + uvCoords.y),
                 1.0);
    canvas = mix(road, canvas, s);
}

// Function 914
vec3 drawVertLine(vec3 inColor, vec3 lineColor, float x, vec2 p)
{
    float e = 1.0/iResolution.x;
    float d = abs(p.x - x);
    return mix(inColor, lineColor, 1.0 - step(e, d));
}

// Function 915
void drawTriangle(Ray ray, inout TraceResult cur_ctxt, Triangle Triangle1)
{
    //float t = INF;
    vec3 t_normal;
    float t_trgl0 = intersectTriangle(ray.pos, ray.dir,
                                  Triangle1.V0, Triangle1.V1, Triangle1.V2,
                                  t_normal);
    if (t_trgl0 < cur_ctxt.t) 
    {
        cur_ctxt.t = t_trgl0;
        //cur_ctxt.color = Triangle1.color;
        ///cur_ctxt.color = 0.5 * t_normal + 0.5;
        cur_ctxt.n = t_normal;
        
        if (randVals.x <  GLASS_R * 8.0) 
        {
            cur_ctxt.materialType = REFLECTION;
        } 
        else 
        { 
            cur_ctxt.materialType = REFRACTION;
            if (cur_ctxt.cur_n == AIR_N) 
            {
                cur_ctxt.prev_n = GLASS_N;
            } 
            else 
            {
                cur_ctxt.prev_n = AIR_N;
            }
        }   
        cur_ctxt.alpha = 0.0;
        cur_ctxt.materialType = REFRACTION;
    }
}

// Function 916
vec3 drawMainEye(vec3 col, vec2 uv, vec2 mouse, out float dist) {
    float outerCircle = shape1(uv*.99, 8., 1., .1);
    float blueCircle = -(length(uv) - 0.392);
    float blueCircle2 = -(length(uv) - mix(0.355, 0.36, noise(uv*15.)));
    float ring1 = stripesCircle1(uv, .5);
    float ring2 = stripesCircle2(uv, .5);
    float upperEyelidRing = stripesCircle3(uv-vec2(0.,-.5), .5);
    float lowerEyelidRing = stripesCircle4(uv+vec2(0.,-.5), .5);
    vec2 innerCircleNoise = (noise2(uv*2.+iTime)-.5)*.05;
    float innerCircle = shape1((uv+innerCircleNoise)*1.4, 9., .25, -.07);
    
    float open = fit01(.0, .005, sin(iTime*2.)*.5+.5);
    
    float upperEyeAperture = mix(.15, .23, max(0., mouse.y)*2.);
    float lowerEyeAperture = mix(.1, .23, clamp(max(0., -mouse.y+.3)*3., 0., 1.));
    
    float c = .28; // eye radius
    float b = mix(.001, upperEyeAperture, open);
    float a, r;
    solveCircle(c, b, r, a);
    float upperEye = -(length(uv+innerCircleNoise - vec2(0.,.01-a)) - r);
    float upperEyelid = -(length(uv+innerCircleNoise) - mix(0.27, 0.28, noise(uv*15.+3.4)));
    upperEyelid = min(upperEyelid, -upperEye);
    
    b = mix(.001, lowerEyeAperture, open);
    solveCircle(c, b, r, a);
    float lowerEye = -(length(uv+innerCircleNoise + vec2(0.,-.01-a)) - r);
    float lowerEyelid = -(length(uv+innerCircleNoise) - mix(0.27, 0.275, noise(uv*15.+3.464)));
    lowerEyelid = min(lowerEyelid, -lowerEye);
    
    b = lowerEyeAperture;
    solveCircle(c, b, r, a);
    vec2 eyeCenter = -vec2(0.,-.025-a);
    float eye = 1.;
    eye = min(eye, upperEye-.01);
    eye = min(eye, lowerEye-.01);
    
    ring1 = smin(ring1, -innerCircle-mix(.0, .03, noise(uv*12.+iTime*.5)), 0.02);
    
    upperEyelidRing = smin(upperEyelidRing, upperEyelid-.01, 0.01);
    lowerEyelidRing = min(lowerEyelidRing, lowerEyelid);
    
    vec2 eyeOffset = mouse*vec2(.2,.5)+vec2(.0,-.1);
    eyeOffset.y = min(eyeOffset.y, 0.03);
    float eyeRing = stripesCircle(uv-eyeCenter-eyeOffset, StripesCircleOpt(.05, .36, 2.5, -.05, 0.), StripesOpt(.5, 0., 0.));
    float pupille = -(length(uv-eyeCenter-eyeOffset) - .09);
    
    eyeRing = min(eyeRing, -.03-upperEyelid) * .2;
    
    float eyeRingFade = clamp((-upperEyelid*7.)*(-lowerEyelid*7.) + .2, 0., .9);
    float eyeWhite = length(uv+innerCircleNoise-eyeCenter)-mix(.325, .31, noise(uv*8.+45.1+iTime*.5))*3.4*pow(r,1.1);
    
    vec3 eyeLayer = vec3(.0, .3, .6);
    eyeLayer = mix(eyeLayer, vec3(1., .292, .173), fill(eyeRing)*eyeRingFade);
    eyeLayer = mix(eyeLayer, vec3(1.), fill(pupille));
    eyeLayer = mix(eyeLayer, vec3(1.), fill(eyeWhite));
    
    col = mix(col, vec3(.14, .21, .3), fill(outerCircle));
    col = mix(col, vec3(.1, .3, .5), fill(blueCircle));
    col = mix(col, vec3(.7, .8, .85), fill(blueCircle2));
    col = mix(col, vec3(0.65, 0.3, 0.6), fill(ring1*.3));
    col = mix(col, vec3(0.9, 0.8, 0.2), fill(ring2*.25));
    col = mix(col, vec3(.14, .21, .3), fill(innerCircle));
    col = mix(col, eyeLayer, fill(eye));
    col = mix(col, vec3(1., .292, .173), fill(upperEyelid));
    col = mix(col, vec3(.75, .102, .073), fill(upperEyelidRing));
    col = mix(col, vec3(.292, .85, .653), fill(lowerEyelid));
    col = mix(col, vec3(.75), fill(lowerEyelidRing));
    
    dist = outerCircle;
        
    return col;
}

// Function 917
vec3 circleSampleColor(vec2 dist1, vec2 center1, vec2 dist2, vec2 center2)
{
    vec2 curRadius1 = vec2(0.0);
    vec2 curRadius2 = vec2(0.0);
	vec3 returnValue = vec3(0.0);
    
    for (int c = 0; c < CIRCLE_NUMBER; ++c)
    {
    	float normalizedAngle = 0.0;
        curRadius1 += dist1;
        curRadius2 += dist2;
        for (int s = 0; s < SAMPLE_PER_CIRCLE; ++s)
        {
            float angle = normalizedAngle * 3.1415 * 2.0;
            vec2 uvToSample1 = center1 + vec2(cos(angle), sin(angle)) * curRadius1;
            vec2 uvToSample2 = center2 + vec2(cos(angle), sin(angle)) * curRadius2;
            vec3 sampledColor1 = texture(iChannel0, uvToSample1).rgb;
            vec3 sampledColor2 = texture(iChannel1, uvToSample2).rgb;
            if (passTest(sampledColor1))
				returnValue += sampledColor2 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);
            else
                returnValue += sampledColor1 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);
            normalizedAngle += 1.0 / float(SAMPLE_PER_CIRCLE);
        }
    }
    return (returnValue);
}

// Function 918
vec3 drawTitleScreen(ivec2 coord, GameData gd)
{
    vec3 col = drawScrollingTitle(coord, gd.gFrames.x);

    if (gd.gGameState == GAME_STATE_LOGO_SCREEN)
    {
        col += drawLogoBottom(coord);
    }
    else
    {
        col += drawStartBottom(coord, gd.gCave, gd.gHighScore, gd.gLevel, gd.gScore);
    }

    return col;
}

// Function 919
vec3 cosineDirection (in vec3 n) {
	float u = rand();
    float v = rand();

    float a = 6.2831853 * v;
    u = 2. * u - 1.;
    return normalize( n + vec3(sqrt(1.-u*u) * vec2(cos(a), sin(a)), u) );
}

// Function 920
maybe_float get_distance_along_3d_line_to_infinite_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float cosb
){
    vec3 D = A0 - B0;
    float a = dot(A, B) * dot(A, B) - cosb * cosb;
    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);
    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;
    float det = b * b - 4. * a * c;
    if (det < 0.)
    {
        return maybe_float(0.f, false);
    }

    det = sqrt(det);
    float t1 = (-b - det) / (2. * a);
    float t2 = (-b + det) / (2. * a);
    // This is a bit messy; there ought to be a more elegant solution.
    float t = t1;
    if (t < 0. || t2 > 0. && t2 < t)
    {
        t = t2;
    }
    else {
        t = t1;
    }

    vec3 cp = A0 + t * A - B0;
    float h = dot(cp, B);
    return maybe_float(t, t > 0. && h > 0.);
}

// Function 921
vec2 dLine(vec2 a,vec2 b){return a*dot(a,b)/dd(b);}

// Function 922
float sdCircle( in vec2 p, in vec2 c, in float r )
{
    return length(p-c) - r;
}

// Function 923
vec4 drawSquare(float r0, float r1, vec4 fillColor, vec2 pixelPos,
                vec4 fragmentColor)
{
        if (step(pixelPos, r0*vec2(1.0)) == vec2(0.0)
            && step(pixelPos, r1*vec2(1.0)) == vec2(1.0)) {
                return fillColor;
        }
        return fragmentColor;
}

// Function 924
vec3 circleTest(vec2 coord, vec2 center, float radius, float width, float pixelWidth) {
    float delta = distance(coord, center)-radius;
    
    // From shadertoy default shader
    vec3 inside = .5 + .5*cos(iTime+coord.xyx+vec3(0,2,4));
    
    float blend = smoothstep(0., pixelWidth, abs(delta) - width);
    
    if (delta  < 0.)
        return mix(white, inside, blend); // rgb -> white (inside  edge)
    else if (delta  > 0.)
        return mix(white, black, blend);  // white -> black (outside edge)
    else
        return white;					  // can't decide
        
}

// Function 925
vec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)
{
	// distance to light
	float ld = length(p - pos);
	
	// out of range ?
	if (ld > range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, pos, radius);
	float fall = (range - ld)/range;
	fall *= fall;
	float source = fillMask(sdCircle(p - pos, radius));
	return (shad * fall + source) * color;
}

// Function 926
bool Rect(vec2 p, vec2 topLeft, vec2 bottomRight)
{
	return 
		(p.x >= topLeft.x && p.y >= topLeft.y) &&
		(p.x <= bottomRight.x && p.y <= bottomRight.y);
		
}

// Function 927
float HALFOLcircle(vec2 p, float r, float th)
{
    
    float c = OLcircle(p, r, th);//can have other functions for half circles of
    							// other types
    float hf = smoothstep(0.0, 0.009, p.x);
 return c*hf;   
}

// Function 928
void drawBranch(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, vec3 colour, inout vec3 value)
{
    //Get Sides of a Triangle
    float a = distance(uv, point2);
    float b = distance(uv, point1);
    float c = distance(point1, point2);
    
    //Calculate Point's Distance from the Line
    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));
    
	//Get Pixel's Value
    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);
    pixelValue *= float(a + b < c + thickness + blur);
    value = mix(value, colour, pixelValue);
}

// Function 929
float drawRect(float i, float valLen, float val, vec2 uv) {
    // draw the rectangle at appropriate place
	float rect = 0.;
    
    if ( uv.x > i/valLen && uv.x < (i+1.)/valLen ) {
        // draw the height of rect according to val
        if ( val / (samples * samples *.25) < uv.y ) {
        	rect = 1.;
        }
    }
	return rect;
}

// Function 930
void DrawSoldier( inout vec3 color, vec4 soldier, vec4 soldierState, float worldX, float worldY )
{
    float soldierX = worldX - soldier.x + SOLDIER_SIZE.x * 0.5;
    float soldierY = worldY - soldier.y;
    soldierX = soldier.z < 0.0 ? SOLDIER_SIZE.x - soldierX : soldierX;
    SpriteSoldier( color, soldierX, soldierY, soldierState.y );        
}

// Function 931
vec4 circle(vec2 uv, vec2 center, float radius, vec4 color)
{    
    vec4 colorToReturn = vec4(0);
    
    if(length(uv - center) < radius)    
    {
		colorToReturn= color;   
    }
    
    return colorToReturn;
}

// Function 932
bool segmentCutsLine(vec2 nml, float h, vec2 a, vec2 b) {
    return sign((dot(a, nml) - h)) != sign((dot(b, nml) - h));	// are points on diffrent sides of line?
}

// Function 933
float udLine(vec2 p, vec2 a, vec2 b) {
	vec2 pa = p- a, ba = b- a;
	return length(pa- ba* dot(pa, ba)/ dot(ba, ba));
}

// Function 934
vec4 drawCellButterfly(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    Sprite sprite = getSpriteButterfly(animFrame);
    return sampleSprite(sprite, colors, coord);
}

// Function 935
vec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )
{
    vec2 off = dir2dis(pacmanMovDirNex.x);
    
    vec2 mPacmanPos = pacmanPos.xy;
    //vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;

    vec2 p = fragCoord/iResolution.y;
    float eps = 1.0 / iResolution.y;

    vec2 q = p - cell2ndc( mPacmanPos );

         if( pacmanMovDirNex.y<1.5 ) { q = q.xy*vec2(-1.0,1.0); }
    else if( pacmanMovDirNex.y<2.5 ) { q = q.xy; }
    else if( pacmanMovDirNex.y<3.5 ) { q = q.yx*vec2(-1.0,1.0); }
    else                             { q = q.yx; }

    float c = sdCircle(q, 0.023);
    float f = c;

    if( pacmanMovDirNex.y>0.5 )
    {
        float an = (0.5 + 0.5*sin(4.0*iTime*6.2831)) * 0.9;
        vec2 w = normalize( q - vec2(0.005,0.0) );

        w = vec2( w.x, abs( w.y ) );
        float m = dot( w, vec2(sin(an),cos(an)));
        f = max( f, -m );
    }
    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );
    col = mix( col, vec3(1.0,0.8,0.1), f );

    // glow
    //col += 0.25*vec3(1.0,0.8,0.0)*exp(-300.0*c*c);

    return col;
}

// Function 936
vec4 DrawShapes (in vec2 fragCoord)
{
    vec4 ret = vec4(0.0);
    
    float aspectRatio = iResolution.x / iResolution.y;
    vec2 uv = (fragCoord / iResolution.xy);
    uv.x *= aspectRatio;    
    
    // draw circles
    for (int i = 0; i < c_numCircles; ++i)
    {
        vec2 posuv = hash22(vec2(i, iDate.w));
        posuv.x *= aspectRatio;
        
        vec3 color = hash32(vec2(i, iDate.w));
        float radius = mix(c_circleRadius.x, c_circleRadius.y, hash12(vec2(i, iDate.w)));
		float dist = length(uv-posuv);
       
        if (dist <= radius)
            ret = EncodeData(fragCoord, color);        
    }
    
    // draw lines
    for (int i = 0; i < c_numLines; ++i)
    {
        vec2 startuv = hash23(vec3(i, iDate.w, 0.453));
        startuv.x *= aspectRatio;
        
        vec2 lineDir = normalize(hash23(vec3(i, iDate.w, 0.627)));
        
        vec3 color = hash33(vec3(i, iDate.w, 2.564));
        float width = mix(c_lineSize.x, c_lineSize.z, hash13(vec3(i, iDate.w, 1.453)));
        float height = mix(c_lineSize.y, c_lineSize.w, hash13(vec3(i, iDate.w, 0.894)));
		vec2 enduv = startuv + lineDir * width;
        
        float dist = UDFatLineSegment(uv, startuv, enduv, height);
        
        if (dist <= 0.0)
            ret = EncodeData(fragCoord, color);        
    }    
    
    // draw squiggle lines
    for (int i = 0; i < c_numSquiggles; ++i)
    {
        vec2 startuv = hash23(vec3(i, iDate.w, 2.635));
        startuv.x *= aspectRatio;
        
        vec2 squiggleDir = normalize(hash23(vec3(i, iDate.w, 0.912)));
        
        vec3 color = hash33(vec3(i, iDate.w, 0.123));
        float width = mix(c_squiggleSize.x, c_squiggleSize.z, hash13(vec3(i, iDate.w, 0.342)));
        float height = mix(c_squiggleSize.y, c_squiggleSize.w, hash13(vec3(i, iDate.w, 1.847)));
		vec2 enduv = startuv + squiggleDir * width;
        
        vec2 uvOffset = vec2(0.0);
        float uvdp = dot(uv - startuv, squiggleDir);
        vec2 normal = vec2(squiggleDir.y, -squiggleDir.x);
        if (uvdp >= 0.0 && uvdp <= width)
            uv += normal * sin(uvdp * 100.0) * 0.01;
        
        float dist = UDFatLineSegment(uv, startuv, enduv, height);
        
        if (dist <= 0.0)
            ret = EncodeData(fragCoord, color);        
    }        

    return ret;
}

// Function 937
vec4 shadeOutline(vec3 pos, float t) {
    float alpha = smoothstep(0., OUTLINE_BOUNDRY, t);
    alpha -= smoothstep(OUTLINE_BOUNDRY, 1., t);
    alpha *= .5;
	vec3 color = vec3(0);
    applyFog(color, pos);
    return vec4(color, alpha);
}

// Function 938
vec4 circle(vec2 uv){
	float inCircle = length(uv - vec2(0.333,0.666))+0.4; 
    inCircle = smoothstep(0.5 - AA,0.5 + AA,1.0-inCircle);
    return vec4(RIBBONCOLOR.rgb,inCircle*0.9);
}

// Function 939
vec3 redline0(vec2 u,vec3 r,vec4 m,vec3 c,float yo
){return strokeLine(u,r,m,c,vec4(vec3(.8,.1,0),.9),vec4(-1.4,yo-.4,2.6,yo-.4),.3);}

// Function 940
void direction_sort(vec3 dir, in object o)
{
    vec3 pdir = normalize(cross(dir, vec3(0,0,1)));
    vec3 tdir = normalize(cross(dir, pdir));
    vec2 angle=vec2(0,1./sqrt(float(dpd)));
    float rad=1.;
	for (int j=0;j<dpd;j++)
    {  
        if(any(equal(ivec2(o.id),idb[j]))) continue;
        rad += 1./rad;
	    angle*=rot;
        vec3 cdir = normalize(dir + dangle*(angle.x*pdir + angle.y*tdir));
        float t = dirBisectDist(cdir, obj.X, o.X);
        if(t < db[j].x)
        {
            db[j] = vec2(t,db[j].x);
            idb[j] = vec2(o.id,idb[j].x);
        } 
        else if(t < db[j].y)
        {
            db[j].y = t;
            idb[j].y = o.id;
        }    
    }
}

// Function 941
float line_sphere_intersection(vec3 origin, vec3 direction, vec3 center, float radius, out vec3 intersections[2]) {
    vec3 diagonal = origin-center;
	vec3 parallel = dot(diagonal, direction)*direction;
    vec3 orthogonal = diagonal-parallel;
    float orthogonal_distance = length(orthogonal);
    if(orthogonal_distance > radius)
        return 0.0;
   	float parallel_distance = sin(acos(orthogonal_distance/radius))*radius;
    intersections[0] = origin-parallel-direction*parallel_distance;
    intersections[1] = origin-parallel+direction*parallel_distance;
    return parallel_distance*2.0;
}

// Function 942
bool drawBoid(vec2 uv, vec4 boid)
{
   	vec2 forward = boid.zw / length(boid.zw);
    vec2 p1 = boid.xy + forward * 2.0;
    vec2 p2 = boid.xy + vec2(forward.y, - forward.x) - forward;
    vec2 p3 = boid.xy + vec2(-forward.y, forward.x) - forward;
    
    return isPointInTriangle(uv, p1, p2, p3); 
}

// Function 943
vec4 circleBox( in vec4 background, 
            in vec4 circleColor,
            in vec2 position,
            in float radius,
           in float thickness,
            in vec2 sideLength  
              ) {

  vec2 relative = vUV-position;
  float distance = length(max(vec2(0.), abs(relative)-sideLength));

  
  
   distance = smoothstep(distance-thickness/2., distance+thickness/2.,radius);
  vec4 outColor = mix( circleColor,background,distance);
  return outColor;
}

// Function 944
float rect(vec2 p, vec2 size) {  
  vec2 d = abs(p) - size;
  return min(max(d.x, d.y), 0.0) + length(max(d,0.0)*8.);
}

// Function 945
bool LineInGridCell( vec2 vA, vec2 vB, vec2 vGridCellMin, vec2 vGridCellMax )
{
    vec2 vAB = vB - vA;
    
    // Check if box crosses line

    float fCross0 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMin.y) - vA );
    float fCross1 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMin.y) - vA );
    float fCross2 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMax.y) - vA );
    float fCross3 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMax.y) - vA );
       
    if ( fCross0 < 0.0 && fCross1 < 0.0 && fCross2 < 0.0 && fCross3 < 0.0 )
        return false;

    if ( fCross0 > 0.0 && fCross1 > 0.0 && fCross2 > 0.0 && fCross3 > 0.0 )
        return false;
           
    // Check if line projection crosses box

    vec2 vLineMin = min( vA, vB );
    vec2 vLineMax = max( vA, vB );

    if ( vLineMin.x > vGridCellMax.x ) return false;
    if ( vLineMin.y > vGridCellMax.y ) return false;
    if ( vLineMax.x < vGridCellMin.x ) return false;
    if ( vLineMax.y < vGridCellMin.y ) return false;
    
    return true;
}

// Function 946
float sdRect(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d)
{
    vec3 ba = b - a; vec3 pa = p - a;
    vec3 cb = c - b; vec3 pb = p - b;
    vec3 dc = d - c; vec3 pc = p - c;
    vec3 ad = a - d; vec3 pd = p - d;
    vec3 nor = cross(ba, ad);

    return sqrt(
        (sign(dot(cross(ba, nor), pa)) +
         sign(dot(cross(cb, nor), pb)) +
         sign(dot(cross(dc, nor), pc)) +
         sign(dot(cross(ad, nor), pd)) < 3.)

        ?

        min(min(min(
		dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0., 1.) - pa),
		dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0., 1.) - pb)),
		dot2(dc * clamp(dot(dc, pc) / dot2(dc), 0., 1.) - pc)),
		dot2(ad * clamp(dot(ad, pd) / dot2(ad), 0., 1.) - pd))
        
        :
        
        dot(nor, pa) * dot(nor, pa) / dot2(nor) 
    );
}

// Function 947
float SAMPLER_trilinear(vec3 p)
{
    //Noise layering trick from Inigo Quilez.
    //See this for more explanation: https://www.shadertoy.com/view/Ms3SRr
    const float TEXTURE_RES = 256.0; //Noise texture resolution
    p *= TEXTURE_RES;   //Computation in pixel space (1 unit = 1 pixel)
    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]
    vec3 t = p-pixCoord;     //Pixel interpolation position, linear range [0-1] (fractional part)
    t = (3.0 - 2.0 * t) * t * t; //interpolant easing function : linear->cubic
    vec2 layer_translation = -pixCoord.y*vec2(37.0,17.0)/TEXTURE_RES; //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels -> this is no keypad smashing, but the actual translation embedded in the noise texture).
    vec2 layer1_layer2 = texture(iChannel0,layer_translation+(pixCoord.xz+t.xz+0.5)/TEXTURE_RES,-100.0).xy; //Note : +0.5 to fall right on pixel center
    return mix( layer1_layer2.x, layer1_layer2.y, t.y ); //Layer interpolation (trilinear/volumetric)
}

// Function 948
float atm_airmass_correction( float x, float coschi, float a )
{
    coschi = abs( coschi );
    float c = SQRTPILN2HALF * sqrt(x);
	return a * ( ( c - 1. ) * coschi + a ) / ( ( a * c - 1. ) * coschi + a );
}

// Function 949
float circle(vec2 uv2,vec2 center,float radius)
{
	return step(distance(uv2, center ), radius);
}

// Function 950
float lineDistance(in vec2 M, vec2 P1, vec2 P2) {
    float x1 = P1.x, y1 = P1.y;
    float x2 = P2.x, y2 = P2.y;
    float x0 = M.x, y0 = M.y;
    float numer = abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1);
    float denom = length(P2 - P1);
    return numer / denom;
}

// Function 951
vec3 B2_spline(vec3 x) 
{ 
    vec3 t = 3.0 * x;
    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);
	vec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);
	vec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);
	return 0.5 * (
    	b0 * pow(t, vec3(2.0)) +
    	b1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + 
    	b2 * pow(3.0-t,vec3(2.0))
    );
}

// Function 952
vec3 circle(vec2 uv, float radius, float offset, float subdiv, float width, float stre, float eStre){        
    vec2 center = vec2(0.);
    
    vec2 p = uv-center;
    p = vec2(cos(offset)*p.x-sin(offset)*p.y,
             sin(offset)*p.x+cos(offset)*p.y);
    vec2 n = normalize(p);
    
    float a = acos(n.x);
    if(n.y<0.) a = 2.0*M_PI-a;
    a /= 2.0*M_PI;
    
//    int tx = int(a*512.0);
    int tx = int(a*512.0/subdiv)*int(subdiv);
    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;
  	float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; 

    radius += stre*fft;
    float d = abs(radius-length(p));
    
    float edge0 = (a*512.0/subdiv-float(int(a*512.0/subdiv)));
    float edge1 = 1.0-edge0;
    float e = (1.-eStre*(1.0-smoothstep(0.05, 0.1, edge0*edge1)));
    return e*(1.0-vec3(smoothstep(0.7, 0.80, smoothstep(0.0, width, d))));    
}

// Function 953
void DrawNumberPart(float part,float fontSize, vec2 position,inout float characters,inout vec3 currentColor, in vec2 uv){
	while(part>=0.9)
    {
        int digit = int(mod(part,10.));
        vec2 textUV =position * fontSize + uv*fontSize;
        textUV.x*=-1.;
        textUV.y*=-1.;
        textUV-= vec2(characters,0.) ;
        currentColor+= vec3(1.) * Character(GetDigit(digit),textUV);
        part /= 10.;
        characters++;
    }

}

// Function 954
float drawDistortedRing(float radius0, float sharpness) {

	const float RING_THICKNESS = 0.015;
	float radius1 = radius0 - RING_THICKNESS;
	
	float a = atan(UNIT_VECTOR_ASPECT.x - 0.5, UNIT_VECTOR_ASPECT.y - 0.5);
	a = sin(a);
	
	float d = distance(UNIT_VECTOR_ASPECT, vec2(0.5));
	vec4 tv = texture(iChannel0, vec2(a*a, 0.0));
	float at = (sin(tv.x) + cos(tv.y)) / 2.0;
	return smoothstep(radius0 + sharpness, radius0, d * at)
		 * smoothstep(radius1 - sharpness, radius1, d * at);
}

// Function 955
vec3 LinearSample(vec2 uv, vec3 CN, out vec3 Moments) {
    float c0,c1,c2,c3; vec3 m0,m1,m2,m3;
    vec2 fuv=floor(uv*HRES-0.499)+0.5;
    vec3 C0=LinearSample0(fuv,c0,m0,CN);
    vec3 C1=LinearSample0(fuv+vec2(1.,0.),c1,m1,CN);
    vec3 C2=LinearSample0(fuv+vec2(0.,1.),c2,m2,CN);
    vec3 C3=LinearSample0(fuv+vec2(1.),c3,m3,CN);
    vec2 fruv=fract(uv*HRES-0.499);
    float mc=mix(mix(c0,c1,fruv.x),mix(c2,c3,fruv.x),fruv.y)+0.01;
    Moments=mix(mix(m0,m1,fruv.x),mix(m2,m3,fruv.x),fruv.y)/mc;
    return mix(mix(C0,C1,fruv.x),mix(C2,C3,fruv.x),fruv.y)/mc;
}

// Function 956
float linedist(vec2 p, vec2 a, vec2 b) {
  float k = dot(p-a,b-a)/dot(b-a,b-a);
  return distance(p, mix(a,b,clamp(k,0.,1.)));
}

// Function 957
Model drawFinalBloom(vec3 p, float t) {
    float bt = smoothstep(0., 2., t);
    bt = easeOutCirc(bt);
    pR(p.xz, .7 * PI * 2.);
    Model bloom = drawBloom(
        p,
        bt,
        BloomSpec(
        	vec2(.15, 2), //density
            .05, //thickness
            .4, //width
            1., //pointy
            1.4, //size
            true //hideInside
        )
   	);
    bloom.id = 5;
    return bloom;
}

// Function 958
float linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }

// Function 959
vec2 Support_HorizLine (float size, vec2 dir)
{
    return vec2(sign_(dir.x)*size, 0.0);
}

// Function 960
float sdLine(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 961
float drawPoint(vec2 x, vec2 p, float pointSize) {
    return (length(p - x)-pointSize);
}

// Function 962
void drawGrid(vec4 grid, inout vec4 fragColor) {
    float selectedGrid = load(idGrid).x;
    vec2 gridCenter = vec2(0.0, gridSize * grid.y) + vec2(gridSize / 2.0);
    vec2 uv = (grid.xy + grid.zw) * gridSize;
    fragColor = vec4(0.92, 0.92, 0.92, 1.0);
    if (grid.y > 1.0 / gridSize - 1.5) {
        fragColor = vec4(getColor(grid.zw), 1.0);
    } else if (grid.y > 1.0 / gridSize - 2.5) {
        vec4 view = load(idView);
        if (view.x > 0.5) {
            float dist = abs(distance(uv, gridCenter) / gridSize - 0.3);
            vec3 col = clamp(vec3(pow(dist, 0.3) * 1.3), 0.0, 1.0);
            fragColor = vec4(mix(fragColor.xyz, vec3(col), 1.0 - col), 1.0);
        } else {
            float dist = length(max(abs(uv - gridCenter) / gridSize - vec2(0.27, 0.21), 0.0));
            vec3 col = vec3(pow(1.0 - dist, 50.0));
            fragColor = vec4(mix(fragColor.xyz, vec3(col), col), 1.0);
        }
    } else {
        if (abs(selectedGrid - grid.y) < 0.5) {
            fragColor = vec4(0.8, 0.8, 0.9, 1.0);
        }
        vec3 brushColor = getColor(load(idBrushColor).xy);
        vec4 col = draw(uv, pow(brushScale, grid.y) * initBrushSize, brushColor, gridCenter);
        fragColor = vec4(mix(fragColor.xyz, col.xyz, col.w), 1.0);
    }
}

// Function 963
float circle(vec2 coord, float radius, float aa)
{
    return smoothstep(radius-aa, radius+aa, sqrt(dot(coord,coord)));
}

// Function 964
void lineFlyIntersection(vec2 la,vec2 lb)
{
    float k = (lb.y - la.y) / (lb.x - la.x); // line tangent
    float topT = -ballvel.y/gravity;
    float topX = ballpos.x + ballvel.x*topT;
    float topY = ballpos.y - 0.5*gravity*topT*topT;
    float topLineY = k*(topX-la.x)+la.y;
    
    float b = -(topY-topLineY);
    float a = -k*ballvel.x;
    float t0 = -a/gravity+topT;
    if (2.0*b*gravity + a*a<=0.0) return;
    float td = -sqrt(2.0*b*gravity + a*a)/gravity;
    
    
    float t = t0-td;
    if (t<0.001 || ballpos.x+ballvel.x*t<la.x || ballpos.x+ballvel.x*t>lb.x) t = t0+td;
    
    if (bounceTime>t && t>0.001 && ballpos.x+ballvel.x*t>=la.x && ballpos.x+ballvel.x*t<=lb.x) 
    {
//	    drawdisk(getBallPosFly(t),ballsize); // mark bounces
        bounceTime = t;
        bounceTan = k;
        bounceLineAX = la.x;
        bounceLineBX = lb.x;
        if (lb.y<0.1) solution = 1.0;
    }
}

// Function 965
void Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)
{	
	float fAttenuation = 1.0;
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);
}

// Function 966
float drawText( inout vec4 c, vec2 p, vec2 tp, float s, ivec4 text, vec4 color) { 
    vec4 m = mapText( p, tp, 10./s, text);
    c = mix(c, color,  clamp(m.x, 0.,1.));
    return m.w;
}

// Function 967
vec4 blobDrawer(vec2 uv, float resolution, float rate)
{
    vec3 gen = vec3(1.0,1.0,1.0);
   	
    float textureSize = iResolution.x*iResolution.y;    
    float onePixel = 1.0/textureSize;
    
    float sum = 0.0;
    for(float i = 0.0; i < resolution; i++)
    {
      sum += texture(iChannel0,(uv + rate*vec2(cos(i*PI*2.0/resolution)/iResolution.x, sin(i*PI*2.0/resolution)/iResolution.y))).r;
    }
	gen *= pow(smoothstep(0.0,1.0,(sum/resolution)),1.0);
    
    return vec4(gen,1.0);
}

// Function 968
float lineBox(in vec2 d_u)
{
    float u = d_u.x;
    float du = d_u.y;
    // analytical integral (box filter)
    return (saturate(u+0.5*du) - saturate(u-0.5*du))/du;
}

// Function 969
vec3 DrawPath(in vec2 p)
{
	vec3 pathLayer = vec3(0.);
	
	float stepGlow = gPathEffect.speed*mod(iTime,1.);
	gPathDynRadius *= gPathEffect.radius_k;
	vec2 point = gEntities.pos[ENTITY_SRC_IDX]+DELTA_POS_PATH*normalize(gEntities.pos[ENTITY_TGT_IDX]-gEntities.pos[ENTITY_SRC_IDX]);
	for (int i=0; i < SIM_STEPS; ++i)
	{
		// glow effect
		float showGlow = 1.-step(stepGlow,float(i));
		float ptRadiusDelta = showGlow * gPathDynRadius * smoothstep(0.6,1.,float(i)/stepGlow);
		
		// draw path
		vec3 gradInfo = calculateGradPF(point);
		vec3 path = drawElement(p, point, PATH_COL, PATH_RADIUS + ptRadiusDelta, PATH_RADIUS*0.5);
		pathLayer = max(pathLayer,path);
		point += DELTA_POS_PATH*(gradInfo.yz);
		
		// early exit (is it better a continue or a break here?)
		if (length(point - gEntities.pos[ENTITY_TGT_IDX]) < 0.01) continue;
	}
	
	return pathLayer;
}

// Function 970
vec3 srgb_linear(vec3 x) 
{
    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));
}

// Function 971
vec3 linearBurn( vec3 s, vec3 d )
{
	return s + d - 1.0;
}

// Function 972
vec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout int seed ) {
  	vec2 r = vec2(nextFloat(seed), nextFloat(seed));
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 973
vec4 draw_hpmp(vec2 p) {
    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 3., abs(p.y - 0.01) - 0.125 - zv / 2.);
    vec3 col = vec3(0.);
    bool bv = (p.y - 0.02 < 0.);
    float d = 1.;
    float dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.015));
    if (dz < 1.) {
        d = hp_s(pt);
        float nx = 1.;
        if (d < 1.)
            nx = card_fbg(p * 18.);
        float ddx = hp_s3(pt + vec2(.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));
        float ddx2 = hp_s3(pt + vec2(-.022, 0.)+(bv ? 1. : -1.) * vec2(0., -0.02));
        float vx = (bv ? allData.player_hpmp.x / 98. : allData.en_hpmp.x / 98.)*0.12 - 0.12 / 2.;
        float nxx = step(vx, pt.x);
        col = mix((bv ? green : redw) / (nx * 3.), col, max(d, nxx));
        float dx = 1. - text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, 0.), bv ? allData.player_hpmp.x : allData.en_hpmp.x);
        col = mix(white, col, dx);
        d = min(d, dx);
        vec3 tccx = vec3(0.);
        int crr = (int(load_card(int(allData.last_selected_card)).w));
        if (allData.player_turn)
            if (bv) {
                if (((c_mn == crr) || (c_he2 == crr))&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {
                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));
                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);
                    tccx = clamp((c_mn == crr ? blue : green) / (100. * td), vec3(0.), vec3(4.));
                    tccx = tccx*anim_tx;
                }
            } else {
                if ((c_at2 == crr)&&(allData.last_selected_card >= 0.) &&(dz < 1.)) {
                    float anim_tx = 1. - get_animstate(clamp(1. - (g_time - allData.card_select_anim)*2.5, 0., 1.));
                    float td = abs(sdBox(pt + (bv ? 1. : -1.) * vec2(0., 0.015), vec2(0.045, 0.015)) - 0.03);
                    tccx = clamp(redw / (100. * td), vec3(0.), vec3(4.));
                    tccx = tccx*anim_tx;
                }
            }
        col = mix(tccx, col, max(dz + 0.35, 1. - d));
        d = min(d, dz + 0.35);
        float anim_t2 = 1. - get_animstate(clamp((g_time - allData.card_put_anim - 0.5)*3., 0., 1.));
        if (allData.flag1 == 1.)anim_t2 = 0.;
        bool bvx = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 0.;
        bool bvy = ((bv) ? allData.player_hpmp.y : allData.en_hpmp.y) > 1.;
        if ((!allData.player_turn)&&(!allData.en_etf)) {

            float anim_t2x = 1. - get_animstate(clamp((g_time - allData.ett - 4.5 - (2. - 2. * allData.en_hpmp.y))*2., 0., 1.));
            anim_t2 = anim_t2x;
        }
        anim_t2 = allData.player_turn ? (bv ? anim_t2 : 0.) : (!bv ? anim_t2 : 0.);
        col = mix(col, clamp((bvx ? blue : blue * anim_t2) / ddx, vec3(0.), vec3(4.)), 1. - ddx);
        col = mix(col, clamp((bvy ? blue : (bvx ? blue * anim_t2 : vec3(0.))) / ddx2, vec3(0.), vec3(4.)), 1. - ddx2);
        d = min(d, ddx * ddx2);
    }
    if (allData.en_etf || allData.player_etf) {
        float anim_t2zb = 1. - min(get_animstate(clamp((g_time - allData.ett - 0.1)*3., 0., 1.)),
                1. - get_animstate(clamp((g_time - allData.ett - 2.8)*4., 0., 1.)));
        dz = hp_s2(pt + (bv ? 1. : -1.) * vec2(0., 0.07));
        if (dz < 1.) {
            float dxz = 1.;
            if (floor(allData.egt) > 0.)
                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7), allData.egt));
            else
                dxz = (allData.player_etf ? !bv : bv) ? 1. : 1. - max(text_mi(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.6, -0.76)), text_n0(vec2(pt.x, bv ? -pt.y : pt.y)*15. + vec2(01.25, -0.7)));
            dxz = max(anim_t2zb, dxz);
            col = mix(redw, col, dxz);
            d = min(d, dxz);
        }
    }
    return vec4(col, min(1., d + 0.35));
}

// Function 974
vec3 draw_polarity(float d, vec2 p) {
  p += iTime * -0.1 * sign(d) * vec2(0, 1);
  p = mod(p + 0.06125, 0.125) - 0.06125;
  float s = sign(d) * 0.5 + 0.5;
  float base = draw_solid(d);
  float neg = shape_box2d(p, vec2(0.045, 0.0085) * 0.5);
  float pos = shape_box2d(p, vec2(0.0085, 0.045) * 0.5);
  pos = min(pos, neg);
  float pol = mix(neg, pos, s);

  float amp = abs(base - draw_solid(pol)) - 0.9 * s;

  return vec3(1.0 - amp);
}

// Function 975
float rectangleCollide(vec2 p1, vec2 p2, vec2 s) {
    return float(all(lessThan(abs(p1 - p2), s)));   
}

// Function 976
float minPointLine(vec3 a, vec3 nv, vec3 p) {
    return dot(p - a, nv);
}

// Function 977
float CanonLog2_to_linear ( float clog2)
{
float Out = 0.0;
if(clog2 < 0.092864125)
Out = -( pow( 10.0, ( 0.092864125 - clog2 ) / 0.24136077 ) - 1.0 ) / 87.099375;
else
Out = ( pow( 10.0, ( clog2 - 0.092864125 ) / 0.24136077 ) - 1.0 ) / 87.099375;
return Out;
}

// Function 978
float circle(vec2 p) {
	return length(p) - 0.5;
}

// Function 979
float sdLine( vec2 p, vec2 a, vec2 b, float r )
{
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

// Function 980
bool inRect(v1 u, v3 b
){b.xyzw-=u.xyxy
 ;return mi(b.zy-b.xw)<mi(b)
 ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}

// Function 981
float circle(vec2 uv, vec2 pos, float rad) {
	return 1.0 - smoothstep(rad,rad+0.005,length(uv-pos));
}

// Function 982
vec2 sdLineOri( in vec3 p, in vec3 b )
{
    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );
    
    return vec2( length(p-h*b), h );
}

// Function 983
vec4 drawWater(vec4 water_color, sampler2D color, sampler2D background, float transparency, float height, float angle, float wave_strength, float wave_frequency, vec2 uv)
{
    angle *= uv.y/height+angle/1.5; //3D effect
    wave_strength /= 1000.0;
    float wave = sin(10.0*uv.y+10.0*uv.x+wave_frequency*iTime)*wave_strength;
    wave += sin(20.0*-uv.y+20.0*uv.x+wave_frequency*1.0*iTime)*wave_strength*0.5;
    wave += sin(15.0*-uv.y+15.0*-uv.x+wave_frequency*0.6*iTime)*wave_strength*1.3;
    wave += sin(3.0*-uv.y+3.0*-uv.x+wave_frequency*0.3*iTime)*wave_strength*10.0;
    
    if(uv.y - wave <= height)
        return mix(
                    mix(
                        texture(background, vec2(uv.x, ((1.0 + angle)*(height + wave) - angle*uv.y + wave))), water_color,
                        0.6-(0.3-(0.3*uv.y/height))
                    ),
        		texture(color, vec2(uv.x + wave, uv.y - wave)),
        		transparency-(transparency*uv.y/height)
        );
    else
        return texture(background, uv);
}

// Function 984
float Rect(in vec2 p, in vec2 s)
{
    return length(max(abs(p) - s, 0.0));
}

// Function 985
float get_draw_radius(float x, float r, int fft_y) {
    // Get FFT value
    float fft = texelFetch(iChannel0, ivec2(x * iResolution.x, fft_y), 0).r;
    
    // Calculate radius
    float radius = CIRCLE_RADIUS + r + fft * 0.07;
    
    // Clamp to the circle radius
    radius = clamp(radius, CIRCLE_RADIUS + r, 1.0);
    
    return radius;
}

// Function 986
maybe_float get_distance_along_3d_line_to_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r,
    in float h
){
    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));
    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;
    cone = get_distance_along_line_to_union(end, cone);
    return cone;
}

// Function 987
void drawBox(const ivec2 uv, const ivec2 lt, const ivec2 rb, const vec3 color, inout vec3 f) {
	if (inBox(uv, lt, rb)) f = color;    
}

// Function 988
vec3 draw_segment3d(vec3 ro, vec3 rd, vec4 segment_nor){
    vec3 segment = vec3(.0);
	if(segment_nor.x > .0){
		vec3 nor = segment_nor.yzw;  // Normal?
		float dif = clamp(dot(nor, vec3(0.57703)), .0, 1. );  // Diffuse?
		float amb = .5 + .5 * dot(nor, vec3(1.));  // Ambient?
		segment = vec3(.2, .3, .4) * amb + vec3(.8, .7, .5) * dif;
	}
    return segment;
}

// Function 989
maybe_vec2 get_distances_along_3d_line_to_capsule(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r
){
    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);
    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);
    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);
    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);
    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);
    return capsule;
}

// Function 990
float solid_rect (vec4 dim, vec2 xy) {
    return max(right_of(dim.x, xy),
        max(top_of(dim.w, xy),
            max(bottom_of(dim.y, xy),
                left_of(dim.z, xy)
            )
        )
    );
}

// Function 991
vec3 LinearToGamma(vec3 linRGB){
    linRGB = max(linRGB, vec3(0.));
    return max(1.055 * pow(linRGB, vec3(0.416666667)) - 0.055, vec3(0.));
}

// Function 992
float gridLine2(vec2 coordSpace, vec2 rectSize, vec2 rectOffset, float rotAngle)
{
    
    coordSpace 	= rotate(rotAngle) * coordSpace;
    rect2(coordSpace, rectSize, rectOffset);
    
    return rect2(coordSpace, rectSize, rectOffset);     
}

// Function 993
float drawminutes(vec2 uv){
    float t;
    t=floor(mod((uv.x-0.0035)/.01,12.)/2.)*10.+10.;
    uv.y+=0.0652;
    uv.y/=0.25;
    uv.x+=0.0573;
    uv/=2.25;
    uv.x=-uv.x;
    return showNum(vec2(-mod(uv.x/.01,2./2.25)/0.15,uv.y*80.),t);
}

// Function 994
bool drawLine( vec2 coords, vec2 p0, vec2 p1, float thickness )
{
    float sD = segmentDistance(coords, p0, p1);
	
    if (sD < 0.01) {
        return true;
    } else {
    	return false;
    }
}

// Function 995
float SDFCircle( in vec2 coords, in vec2 offset )
{
    coords -= offset;
    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return v/length(g); 
}

// Function 996
vec4 spline( float x, vec4 c0, vec4 c1, vec4 c2, vec4 c3 )
{
    if(ScreenH == 0.f){
        vec2 w = BSplineLinearWeights(x);
        return w.x * c1 + w.y * c2;      
    }else if(ScreenH == 1.f){       
         vec3 w = BSplineQuadraticWeights(x);
    	 return  w.x *c1 + w.y *c2 + w.z*c3;      
    }else{       
     	vec4 w = BSplineCubicWeights(x);
   		return w.x*c0 + w.y *c1 + w.z *c2 + w.w*c3;
    }
}

// Function 997
define draw_label2(P,l) {                         \
       vec2 U0 = U-(P);                            \
        V = U0 * 12. +vec2(.8,.5); O.ba += C(l);   \
        V = U0 * 20. +vec2(.5, 0); O.ba += N(2); }

// Function 998
void circleFest(inout vec3 col,in vec2 uv, in float time)
{
	float len = length(uv);
    float ang = atan(uv.y,uv.x);
    
    vec3 circleCol = vec3(0.);
    
    float f = (_Circle(len,.45,.003,.013)) * .15;
    col = mix(col,circleCol,f);
    
    time = -1.485 + time*2.;// * 2. + 1.4;
    
    float a = (ang + time) / TPI;
    a = (a - floor(a));
    
    f = (_Circle(len,.45,.006,.013)) *.05;
    
    float startTime = max(mod(time + HPI,TPI),PI) + HPI;
    
    float start = sin(startTime) * .5 + .5;
    
    float endTime = min(mod(time + HPI,TPI),PI) + HPI;
    
    float end = sin(endTime)*.5+.5;
    
    f *= step(a,1.-start) - step(a,end);
    col = mix(col,circleCol,f*3.5);
    
    f = (_Circle(len,.45,.003,.013)) ;
    f *= step(a,.04 + sin(time) * .01) - step(a,0.);
   
    col = mix(col,circleCol,f);
   
    f = (_Circle(len,.62,.003,.013)) ;
    col = mix(col,circleCol,f*.25);
    
    f = (_Circle(len,.62,.003,.013)) ;
    
    time += 1.;
    time = GetGain(fract(time/TPI),.25) * TPI;
    a = (ang - time - 1.5) / TPI;
    a += sin(time) * .15;
    a = (a - floor(a)) ;
    //a = GetBias(a,.65);
    f *= step(a,.03 ) - step(a,0.);
    col = mix(col,circleCol,f);
    
}

// Function 999
int toLinear(in vec2 fragCoord, in vec2 resolution) {
    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);
    //index += 1;
    return index;
}

// Function 1000
float Rectangle(vec2 p, vec2 b)
{
	vec2 d = abs(p) - b;
	return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 1001
float drawObject(in vec3 p){
    
    // Wrap conditions:
    // Anything that wraps the domain will work.
    //p = cos(p*6.2831853)*.25 + .25; 
    //p = abs(cos(p*3.14159)*.5);
    //p = fract(p) - .5; 
    //p = abs(fract(p) - .5); 
    
    // Distance metrics:
    // Here are just a few variations. There are way too many to list them all,
    // but you can try combinations with "min," and so forth, to create some
    // interesting combinations.
    
    // Spherical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5;    
    //return dot(p, p)/1.5;
    
    // Octahedral... kind of.
    //p = abs(fract(p)-.5);
    //return dot(p, vec3(.333));
    
    // Triangular.
    //p = fract(p) - .5;
    //p = max(abs(p)*.866025 + p.yzx*.5, -p);
    //return max(max(p.x, p.y), p.z);    
    
    // Cubic.
    //p = abs(fract(p) - .5); 
    //return max(max(p.x, p.y), p.z);
    
    // Cylindrical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5; 
    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));
    
    // Octahedral.
    //p = abs(fract(p) - .5); 
    //p += p.yzx;
    //return max(max(p.x, p.y), p.z)*.5;

    // Hexagonal tube.
    p = abs(fract(p) - .5); 
    p = max(p*.866025 + p.yzx*.5, p.yzx);
    return max(max(p.x, p.y), p.z);
    
    
}

// Function 1002
vec3 DrawRandomColor(vec2 uv){
	uv+=0.5;
	uv*=4.;
	return Hash32(floor(uv));
}

// Function 1003
void rectangle(vec2 o, vec2 s) {
    s*=0.5;
    o += s;
    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;
    vec4 dmin = min(d,0.0);
    vec4 dmax = max(d,0.0);
    add_field(max(dmin.xz, dmin.yw) + length2(dmax));
}

// Function 1004
float line(vec2 p, vec2 a, vec2 b) {
  vec2 pa = p - a;
  vec2 ba = b - a;
  float h = dot(pa, ba) / dot(ba, ba);
  float d = length(pa - ba * h);
  return d;
}

// Function 1005
void lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){
    
    z -= a; b -= a;                        // go to A referential
    float q = dot(z, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate
    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P 

    
    fragColor += vec4(c.xyz,1) * c.w*clamp(w-length( z - b),0.,1.);
}

// Function 1006
float sdfCircle(vec2 uv, float r) { return length(uv)-r; }

// Function 1007
float circleGrid(vec2 position, float spacing, float dotSize){
    
    // idx => which dot we are showing in the grid.
    
    // check x and y index to see if we should draw it or not.
    float idx = floor(1./spacing * position.x);
    float yIdx = floor(1./spacing * position.y);

    // much higher than .06 causes the grid to be obvious
    if (rand2d(idx,yIdx,0.06)){
    	return 0.0;
    }
    
    // modify the size of the flake a bit
    float relativeSize = (0.5 + 0.5*randF(yIdx))*dotSize / spacing;
    
    return smoothCircle(vec2(
        fract(1./spacing*position.x),
        fract(1./spacing*position.y + yIdx)
    ),relativeSize);
}

// Function 1008
float line(vec2 p, vec2 p0, vec2 p1, float w) {
    vec2 d = p1 - p0;
    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);
    vec2 proj = p0 + d * t;
    float dist = length(p - proj);
    dist = 1.0/dist*WEIGHT*w;
    return min(dist*dist,1.0);
}

// Function 1009
float sdFatLine2(vec2 p, vec3 a, vec3 b)
{
    float dummy_dc;
    vec2 dummy_uv;
    return sdFatLine2All(p, a, b, dummy_dc, dummy_uv);
}

// Function 1010
vec4 drawCellExit(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteEntrance((state.y == 0) ? 1 : gameFrame);
    return sampleSprite(sprite, colors, coord);
}

// Function 1011
ComplexMatrix2 M_getIdealLine(Complex i0, Complex i1)
{
 	Circle c = M_getCircleBetweenDiskPoints(i0, i1);
    vec2 d = normalize(c.center);
    
    float t;
    intersectHypersphere(vec2(0), d, c.center, c.radius, t);
    
    return M_mapRealsToLine(i0, t * d, i1);
}

// Function 1012
float pdf_direction_uniform () {
    return 1.0f / two_pi;
}

// Function 1013
float drawCircle(in vec2 _st, in float _radius){
    vec2 dist = _st-vec2(0.5);
	return 1.-smoothstep(_radius-(_radius*0.01),_radius+(_radius*0.01),dot(dist,dist)*4.0);
}

// Function 1014
vec4 drawInventory(vec2 c) {
	float scale = floor(iResolution.y / 128.);
    c /= scale;
    vec2 r = iResolution.xy / scale;
    vec4 o = vec4(0);
    float xStart = (r.x - 16. * numItems) / 2.;
    c.x -= xStart;
    float selected = load(_selectedInventory).r;
    vec2 p = (fract(c / 16.) - .5) * 3.;
    vec2 u = vec2(sqrt(3.)/2.,.5);
    vec2 v = vec2(-sqrt(3.)/2.,.5);
    vec2 w = vec2(0,-1);
    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {
        float slot = floor(c.x / 16.);
    	o = getTexture(48., fract(c / 16.));
        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));
        vec2 texCoord;
        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);
        float top = 0.;
        float right = 0.;
        if (b.z < b.x && b.z < b.y) {
        	texCoord = inv2(mat2(u,v)) * p.xy;
            top = 1.;
        }
        else if(b.x < b.y) {
        	texCoord = 1. - inv2(mat2(v,w)) * p.xy;
            right = 1.;
        }
        else {
        	texCoord = inv2(mat2(u,w)) * p.xy;
            texCoord.y = 1. - texCoord.y;
        }
        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {
            float id = getInventory(slot);
            if (id == 3.) id += top;
            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);
            o.a = 1.;
        }
    }
    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));
    o = mix(o, selection, selection.a);
    return o;
}

// Function 1015
float sd_airliner_a350( vec2 p )
{
 p.y = abs( p.y ); // vertical symmetry
 float db1 = p.y - 0.98 * rcp_decay( max( -0.666, -( p.x - 10. ) ) ); // fuselage front
 float db2 = p.y - 0.98 * rcp_decay( max( -0.666, p.x - -7.8 ) ); // fuselage back
 float db = opI( db1, db2 ); // fuselage
 float dw1 = -( curved_max_vfunc_weld_quadric( p.x + 3.85, 0.85 ) * 2.3 - ( 9.7 - p.y ) ); // back wing curve
 float dw2 = curved_max_vfunc_weld_quadric( p.x + 3.45, 0.85 ) * 1.26 - ( 9.2 - p.y ); // front wing curve
 float d3 = -( p.x - ( -0.8 ) ); // back wing curve flat bit
 dw1 = opU( dw1, d3 );
 float dw = opI( opI( dw1, dw2 ), -( p.x + 4. ) ); // wing
 float ds = -( ( smoothstep( -6.5, -9.8, p.x ) ) * 2.55 - p.y ); // stabilizer
 ds = opI( ds, ( p.x + 6.5 ) );
 ds = opS( ds, ( p.x + 8.94 + p.y * 0.4 ) ); // final tail bit
 float dt = opI( p.x + 8., p.y - 0.45 * rcp_decay( max( -0.666, ( p.x - -9.75 ) * 1. ) ) );
 ds = opU( dt, ds ); // cut garbage
 vec2 pe = p - vec2( 1.5, 2.77 ); // engine pos
 float de = abs( pe.y ) - 0.8 * min( powerful_scurve( pe.x, 0.5, 4. ), powerful_scurve( 1. - ( pe.x - 1. ), 0.1, 4. ) ) + 0.3; // engine
 return opU( de, opU( ds, opU( dw, db ) ) );
}

// Function 1016
float drawsource (vec3 ro, vec3 rd, vec3 cp)
{
    float shape = 1. - saturate(distline(ro, rd, cp) * 25.  );
    return (pow(shape,8.) * 40. + shape) * 2.;
}

// Function 1017
float linearDensityTransmittance(float NDotL,float NDotO,float LDotO)
{
    if (FragCoord.y/iResolution.y>.42)
		return sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1
	else
     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2
		return .15*DENS*NDotL/(NDotL+NDotO);                            // test3
}

// Function 1018
float distLine(vec2 p, float x, float y, float z) {
    return abs(x*p.x + y*p.y + z)/sqrt(x*x + y*y);
}

// Function 1019
float linearstep(float start, float end, float x)
{
    float range = end - start;
    return saturate((x - start) / range);
}

// Function 1020
float draw(const in vec2 p, const in int num, const in float zoom)
{
    float rz = dist(p, num);
	rz *= (1./thickness)/sqrt(zoom/iResolution.y);
	rz = 1.-clamp(rz, 0., 1.);
	return rz;
}

// Function 1021
vec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    
	vec3 w = normalize(d);
    vec3 u = normalize(cross(w.yzx, w));
    vec3 v = cross(w, u);
	return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;
}

// Function 1022
vec3 project_on_line1( vec3 P, vec3 O, vec3 d ) { return O + d * dot( P - O, d ); }

// Function 1023
float DrawGrid(vec2 coord)
{
    vec2 gridDist = abs(coord - round(coord)) * 2.0;
    vec2 gridActive = smoothstep(vec2(0.1), vec2(0.0), gridDist);
    return min(gridActive.x + gridActive.y, 1.0);
}

// Function 1024
void Print_Newline( inout PrintState printState )
{
    printState.vPos.x = printState.vOrigin.x;
    printState.vPos.y -= 8.0;
}

// Function 1025
float WavelengthToLuminosityLinear( float fWavelength )
{
    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);
    float fIndex = fPos * float(standardObserver1931_length);
    float fFloorIndex = floor(fIndex);
    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );
    int iIndex0 = int(fFloorIndex);
    int iIndex1 = iIndex0 + 1;
    iIndex0 = min( iIndex0, standardObserver1931_length - 1);
    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    
    return mix( luminousEfficiency[iIndex0], luminousEfficiency[iIndex1], fBlend );
}

// Function 1026
vec4 drawLine(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[32], in int _tsize)
{
    vec4 tcol;
    
    for (int i_letter = 0; i_letter < _tsize; i_letter++)
    {
        tcol += drawLetter(uv, start + float(i_letter)*vec2(0.02, 0.), lsize, _text[i_letter]);
    }
    
    return clamp(tcol, 0., 1.);
}

// Function 1027
vec2 pulseFuncCircle(float val){ // return (sin, cos); Circle;
    return vec2(sin(val), cos(val));
}

// Function 1028
void drawGround(vec2 co)
{
	drawHorzRect(co.y, 0.0, 31.0, RGB(221, 216, 148));
	drawHorzRect(co.y, 31.0, 32.0, RGB(208, 167, 84)); // shadow below the green sprites
}

// Function 1029
vec3 circles(in vec2 point, int nr) {
    vec3 circles = vec3(0.0);
    int j = 0;
    for(int i = 0; i < nr; i++) {
        float innerR = (rand(vec2(i+j++)) + 0.05) / 5.0;
        float outerR = innerR + rand(vec2(i+j++) + 0.05) / 25.0;
        float speedX = rand(vec2(i+j++));
        float speedY = (rand(vec2(i+j++)) + 0.2) / 1.2;
    	circles+=circle(circlePos(speedX, speedY), outerR, innerR, point);
    }
    return circles * vec3(0.9, 0.9, 1.0);
}

// Function 1030
void drawSwordIconLarge( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {
    coord = (coord-lt) / size;
    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    
		vec4 col = drawSword(coord.yx, level);
        color = mix( color, col, col.a );
    }
}

// Function 1031
vec4 drawShore(in float x, in float y)
{
    // Bounds checking.
    if(x > SHORE_END) return TRANS;
    else if(y < SHORE_Y || y > SHORE_Y + 31.) return TRANS;
    else
    {
        // Transform to be relative to the shore tiles.
        y -= SHORE_Y;

        // Draw the interior of the shore.
        if(x < 64.) return shorePalette(shoreInterior(x,y));
        // Draw the endcap exterior.
        else
        {
            x -= 64.;
            return shorePalette(shoreExterior(x,y));
        }
    }
}

// Function 1032
void draw_bg(in vec2 p, inout vec4 fragColor)
{
    fragColor = vec4(mod(p.x + p.y, 2.) * .05 + BG, 1);
}

// Function 1033
void drawMap(inout vec4 c, vec2 fragCoord)
{
    if (iResolution.x < 420.)
        return;
    
    // show map memory.
    ivec2 ifc = ivec2(fragCoord/4.);
    if (ifc.x > 0 && ifc.x < SX && ifc.y > 0 &&ifc.y < SY)  
        c = mix(c, textureBase ( iChannel0, ifc), .5 );
    
}

// Function 1034
float circles(vec2 coord)
{
    float reso = 5.0;
    float width = iResolution.x / reso;

    vec2 center = floor(coord / width + 0.5) * width;
    float dist = distance(coord, center);

    float time = iTime * 0.9;
    float phase = dot(center, vec2(1.647346, 7.323874));
    float radius = width * (0.3 + sin(time + phase) * 0.16);

    return dist - radius;
}

// Function 1035
vec2 LineOffset(vec2 p, vec2 a, vec2 b, float w)
{
    vec2 perp = PerpToLine(p, a, b); // returns vector offset from line segment a->b to p

    float d = length(perp);
    float m = S(w, w*0.7, d); // mask line to width

    float d2 = length(a-b);

    return 160.0 * abs(perp) * perp * m;
}

// Function 1036
vec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)
{
    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)
    {
        return clamp(dot(n, l.d), 0., 1.) * l.c;
    }
    return vec3(0.);
}

// Function 1037
vec3 draw_hour(vec2 uv) 
{
    float hourCenter = fract(iDate.w / 86400.);  
    float f = abs(uv.x - hourCenter);
    
    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.03, .0, pow(uv.y, 1.5)));    
    float beamSpread = .008 + .05 * max(0., pow((1. - uv.y), 3.));
    lightBeam *= smoothstep( HOUR_WIDTH + beamSpread, HOUR_WIDTH - beamSpread, f);
        
    float lightIntensity = lightBeam * .8;    
    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.05, .0, f);     
    
    lightIntensity *= atmos( 4. * (uv + vec2(30., 30.)) ); // scale and shift fog to fake depth
    
    return vec3(1., .6, .3) * lightIntensity;
    
}

// Function 1038
float sdCircle( vec2 p, float r )
{
    return length(p) - r;
}

// Function 1039
float DFLine(vec3 p, vec3 a, vec3 b) {
    vec3 ba=b-a;
    float k=dot(p-a,ba)/dot(ba,ba);
    return length((a+clamp(k,0.,1.)*(b-a))-p);
}

// Function 1040
vec4 drawline(vec2 p, vec2 p0, vec2 p1, float width) {   		
    float d = line(p, p0, p1, width);
    d += noise2d(p * vec2(0.2)) * 0.005;
    float w = fwidth(d) * 1.0;
    
    return vec4(EdgeColor.rgb, 1.-smoothstep(-w, w, d));
}

// Function 1041
vec2 PerpToLine(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p-a; // vector from a to p
    vec2 ba = b-a; // vector from a to b
    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0); // clamping t makes ba a line Segment
    vec2 c = ba*t;
    return pa - c;
}

// Function 1042
float CircleOuterTangents(vec2 pix, vec3 C1, vec3 C2)
{
    vec3 dx = (C1 - C2) / distance(C1.xy, C2.xy);   
    float ro = sqrt(1.0 - dx.z*dx.z);
    
    float X = dx.z*dx.x;
    float Y = dx.z*dx.y;
    float Z = dx.y*ro;
    float W = dx.x*ro;
    
    float a = X - Z;
    float b = Y + W;
    float c = C1.z - (a*C1.x + b*C1.y);
 
    float d = X + Z;
    float e = Y - W;
    float f = C1.z - (d*C1.x + e*C1.y);
    
    return Plane(pix, vec3(a,b,c)) + Plane(pix, vec3(d,e,f));
}

// Function 1043
vec3 scanline(vec2 coord, vec3 screen)
{
	screen.rgb -= sin((coord.y + (iTime * 29.0))) * 0.02;
	return screen;
}

// Function 1044
vec3 randomDirection( in float Xi1, in float Xi2,out float pdf ) {
    pdf = 1.0 / (4.0 * PI);
    float theta = acos(1.0 - 2.0*Xi1);
    float phi = TWO_PI * Xi2;
    
    return sphericalToCartesian( 1.0, phi, theta );
}

// Function 1045
void drawTriangle(inout vec3 color, vec3 fill, vec2 fragCoord, vec2 position, vec2 size, int direction) {
    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&
        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {
        // Get coordinates relative from the center.
        vec2 xy = fragCoord - vec2(0.5, 0.5) - position - floor(size / 2.0);
        if (xy.x + xy.y >= 0.0 &&
            xy.y - xy.x >= 0.0 && direction == TRIANGLE_DOWN) {
            color = fill;
        }
        if (xy.x + xy.y >= 0.0 &&
            xy.x - xy.y >= 0.0 && direction == TRIANGLE_LEFT) {
            color = fill;
        }
        if (xy.x + xy.y <= 0.0 &&
            xy.y - xy.x <= 0.0 && direction == TRIANGLE_UP) {
            color = fill;
        }
        if (xy.x + xy.y <= 0.0 &&
            xy.x - xy.y <= 0.0 && direction == TRIANGLE_RIGHT) {
            color = fill;
        }       
    }
}

// Function 1046
float greatCircleDist(vec2 p, vec2 lp)
{
    float phi_1 = p.y;
    float phi_2 = lp.y;
    float delta_lambda = p.x-lp.x;
    return acos(sin(phi_1)*sin(phi_2) + cos(phi_1)*cos(phi_2)*cos(delta_lambda));
}

// Function 1047
vec4 drawBoulderDash(ivec2 coord, mat4x3 colors)
{
    ivec2 cellIdx = coord / CEH_RES;
    cellIdx += ivec2(-1, -8);

    if (coord.x < 16 || coord.x > 303 || coord.y < 64 || coord.y > 183)
    {
        return vec4(0.0);
    }

    int idx = cellIdx.y * BOU_SIZ.x + cellIdx.x;
    ivec4 sprite = bdHS[bdPattern[idx]];
    return sampleHalfSprite(sprite, bdColors, coord);
}

// Function 1048
vec3 linearLight( vec3 s, vec3 d )
{
	return 2.0 * s + d * 2.0 - 1.0;
}

// Function 1049
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);                    // proj coord on line
    return smoothstep(zoom*3./R.y,0.,length(p - b * h));               // dist to segment
}

// Function 1050
void drawHill(vec2 uv, vec3 colour, float blur, float speed, float flatness, float xOffset, float yOffset, bool drawTrees, inout vec3 value, float frequency, int octaves, float lacunarity, float persistence)
{
    float noiseValue = perlinNoise(vec2(uv.x + xOffset + iTime * speed, 0.5), frequency, octaves, lacunarity, persistence) * flatness;
    float pixelValue = smoothstep(noiseValue, noiseValue - blur, uv.y - yOffset);
    value = mix(value, colour, pixelValue);
    
    if (drawTrees && uv.y < 0.8)
    {
        float treeX = floor(uv.x + xOffset + iTime * speed);
        treeX += map(randomValue(vec2(treeX)), 0., 1., 0.12, 0.88);
        float treeY = perlinNoise(vec2(treeX, 0.5), frequency, octaves, lacunarity, persistence) * flatness;
        drawTree(uv, vec2(treeX - xOffset - iTime * speed, treeY + yOffset - randomValue(vec2(treeX)) * 0.02), 4, 4, 0.17, branchColour, leafColour, value);
    }
}

// Function 1051
float equirectangular_direction(out vec3 rd)
{
  vec2 uv = gl_FragCoord.xy / iResolution.xy;
  
  // Calculate azimuthal and polar angles from screen coordinates
  float theta =  uv.t * PI,
        phi =  uv.s * 2.0 * PI;
        
  // Calculate ray directions from polar and azimuthal angle
  rd = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  
  // formulas are on wikipedia:
  // https://en.wikipedia.org/wiki/Spherical_coordinate_system	
  return 1.0;
}

// Function 1052
void drawBullet(float t, out vec4 fragColor){
    // the center of the two circles.
    vec2 o = vec2(START_X + MOVING_SPEED * t, START_Y);
    float d = distance(uv, o);
    
    // draw smaller circle.
    if(d <= BULLET_RADIUS){
		fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
	// draw bigger circle.
    else if(d <= BULLET_RADIUS2){
    	float R, G, B;
        float W = smoothstep(BULLET_RADIUS, BULLET_RADIUS2, d);
        R = 1.0 - (1.0 - BULLET_COLOR.x) * W;
        G = 1.0 - (1.0 - BULLET_COLOR.y) * W;
        B = 1.0 - (1.0 - BULLET_COLOR.z) * W;
		fragColor = vec4(R, G, B, 1.0);
    }
}

// Function 1053
float circleDist(vec2 p, float radius)
{
	return length(p) - radius;
}

// Function 1054
float SDF_line(vec2 P,vec2 O,vec2 D)
{
    vec2 OP=P-O;
    vec2 OH=dot(OP,D)*D;
    vec2 HP=OP-OH;
    return length(HP);
}

// Function 1055
float distanceToLine(vec2 p, vec2 nml, float h) {
    return dot(nml, p) - h;	// Rounding error here if nml is not normalized 100%
}

// Function 1056
void DrawBigParts(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    DrawGlow(p, t, fireColor, color);
    
    float texpNormPow = pow(t, 0.5);
    vec2 gravity = gGravity * 0.15;
    
    vec2 scaleDirection = normalize(vec2(hash(id+5.228), hash(id+9.8921)));
    for(float i=0.; i < 10.5; ++i)
    {   
        // Main Properties
        float iNorm = i/10.;
        float hashP = hash(i*42.856+98.5984);
        float pSpeed = 0.85;
        vec2 pVel = normalize(vec2(cos(iNorm*PI2), sin(iNorm*PI2)));
        pVel *= 0.60+0.4*pow(abs(dot(scaleDirection, pVel)), 0.70);
        
        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.25), 0., 1.);

        // Visibility Properties
        float sizeScale = (0.6+0.4*hashP);
        float flicker = (0.2+0.8*noise(i + t*0.2));
        float size = sizeScale*expSize*0.20;

        // Position
        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.5*hashP+0.5)*gravity*t*t;
        vec2 q = p - deltaPos;

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.7, 9.0*hash(i+t*10.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
    
    DrawLittleParts(id, p, (t-0.05)/0.95, vec2(0., 0.0), fireColor, color);
}

// Function 1057
float drawFloat(float fn, int prec, int maxDigits)
{ 
  float tpx = tp.x-FONT_SPACE*float(maxDigits);
  float c = 0.; 
  if (fn < 0.0) 
  { 
    c = char(45); // write minus sign
    fn = -fn; 
  }
  tp.x -= FONT_SPACE; 
  c += drawInt(int(fn),1); 
  c += char(46); SPACE; // add dot 
  c += drawFract(prec, fract(fn)); 
  tp.x = min(tp.x, tpx); 
  return c; 
}

// Function 1058
float linearRand(vec3 uv)
{
	vec3 iuv = floor(uv);
	vec3 fuv = fract(uv);
	
	float v1 = rand(iuv + vec3(0,0,0));
	float v2 = rand(iuv + vec3(1,0,0));
	float v3 = rand(iuv + vec3(0,1,0));
	float v4 = rand(iuv + vec3(1,1,0));
	
	float d1 = rand(iuv + vec3(0,0,1));
	float d2 = rand(iuv + vec3(1,0,1));
	float d3 = rand(iuv + vec3(0,1,1));
	float d4 = rand(iuv + vec3(1,1,1));
	
	return mix(mix(mix(v1,v2,fuv.x),mix(v3,v4,fuv.x),fuv.y),
		       mix(mix(d1,d2,fuv.x),mix(d3,d4,fuv.x),fuv.y),
			   fuv.z);
}

// Function 1059
vec4 circle(vec2 xy, vec2 pos, float r, vec4 c) {
	float p = abs(distance(xy*iResolution.xy, pos*iResolution.xy));
    
    return vec4(step(p, r)) * c;
}

// Function 1060
void drawTextNumber( inout vec4 c, vec2 p, vec2 tp, float s, float textNumber, vec4 color) { 
    c = mix(c, color,  clamp(mapNumber(p, tp, 10./s, textNumber).x, 0.,1.));
}

// Function 1061
vec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)
{
 	 
    
    //l is used for making rings.I get the length and pass it through a sinwave
    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least
    //if you return the max of that and 0.0.
    
    float l = length(p + mouse*(dist*4.))+size/2.;
    
    //l2 is used in the rings as well...somehow...
    float l2 = length(p + mouse*(dist*4.))+size/3.;
    
    ///these are circles, big, rings, and  tiny respectively
    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;
    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;
    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;
    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;
    
   	color = 0.5+0.5*sin(color);
    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;
 	vec3 f = c*color ;
    f += c1*color;
    
    f += c2*color;  
    f +=  s*color;
    return f-0.01;
}

// Function 1062
float arrow_draw(vec2 uv, Arrow arrow){
    vec2 arrow_uv = uv - arrow.pos;
    arrow_uv *= rot2D(arrow.angle);

    vec2 head_end = vec2(arrow.norm, .0);
    float norm_sign = sign(arrow.norm);

    float stem = df_segment(arrow_uv, vec2(.0, .0), head_end, ARROW_THICKNESS);

    float head_len = min(ARROW_HEAD_LEN, norm_sign * arrow.norm);
    float head_left  = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, +norm_sign * head_len), ARROW_THICKNESS);
    float head_right = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, -norm_sign * head_len), ARROW_THICKNESS);
    float head = op_join(head_left, head_right);

    float arrow_full = op_join(stem, head);
    return smoothstep(FSAA, .0, arrow_full);
}

// Function 1063
float DrawOutline(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {
    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);
    return saturate((abs(df + outlineThick) - outlineThick) / abs(dFdy(uv).y));
}

// Function 1064
vec3 Lighting_Circle(
    in vec3  toView,
    in vec3  pos,
    in vec3  norm,
    in vec3  albedo,
    in float intensity,
    in float roughness)
{
    Light_Ring light;
    light.position    = LightPos;
    light.attenuation = LightAttenuation;
    light.normal      = Rotate(LightNormal, LightYaw, LightPitch);
    light.radius      = LightRadius;
    
    // Get the closest point on or in the circle on the plane defined by
    // the light's position and normal. This point is then used
    // for the standard lighting calculations.
    
    vec3 pointOnLight = PointInCircle(pos, light.position, light.normal, light.radius);
    vec3 toLight      = pointOnLight - pos;
    vec3 toLightN     = normalize(toLight);
    
    float lightCos    = dot(-toLightN, light.normal);
          lightCos    = (LightDirection == LightDirectionBi) ? abs(lightCos) : max(0.0, lightCos);
    
    float lightDist   = length(toLight);
    float attenuation = Attenuation(lightDist, light.attenuation.x, light.attenuation.y, light.attenuation.z);
    
    vec3 reflVector = reflect(-toView, norm);
    
    vec3 dirLight = vec3(intensity) * lightCos * attenuation;
    vec3 spcLight = vec3(0.2) * pow(max(0.0, dot(reflVector, toLightN)), roughness) * lightCos;
    
    return (albedo * dirLight) + spcLight;
}

// Function 1065
void drawColorIcon(vec2 p, float sz, int i, bool enable, inout vec3 color) {
    
    const float k = 0.8660254037844387;
    
    mat2 R = mat2(-0.5, k, -k, -0.5);
    
    vec2 p1 = vec2(k*sz, 0);
    vec2 p2 = vec2(0, 0.5*sz);
    
    mat3 colors;
    
    if (i == 0) {
        colors = mat3(vec3(1, 0, 0),
                      vec3(1, 1, 0),
                      vec3(0, 0, 1));
    } else {
        colors = mat3(vec3(0.6, 0, 0.6),
                      vec3(0.7, 0.4, 0.7),
                      vec3(0.1, 0.5, 0.5));
    }
    
    float ue = enable ? 1. : 0.3;
    float ds = 1e5;
    
    for (int j=0; j<3; ++j) {
        
        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));
        
        vec2 dls = lineSegDist2D(p2, p1, ap);
        
        p = R*p;
        
        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);
        ds = min(ds, dls.y);
    
    }

    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);
    
}

// Function 1066
bool LineSide (vec2 linePoint1, vec2 linePoint2, vec2 point)
{
	return (
        (linePoint2.x - linePoint1.x)*(point.y - linePoint1.y) -
        (linePoint2.y - linePoint1.y)*(point.x - linePoint1.x)
    ) > 0.0;
}

// Function 1067
float circle(vec2 pos, float radius, float halo)
{
  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);
}

// Function 1068
void drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  
    
    float gap = 5.;
    vec4 data = readPixel(vec2(id,1)); 
    
    //if first frame write default value
    if(data.g < 0.1){ 
        data = vec4(val,.4,0,1);
        setPixel(vec2(id,1), data);
    }    
    
    //draw bg
    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); 
    
    //if mouse over slider write new value
    if(dfBox(iMouse.xy,b)<=gap){
        float distanceFromLeftEdege = clamp(iMouse.x, b.x, b.x+b.z)-b.x;
        data.r = distanceFromLeftEdege/ b.z;        
        //data.a=1.0;
        setPixel(vec2(id,1), data);
        
        b.w=35.0;
    }
    
    //draw sliding bar   
    if(ui >=0.6){
    	b.z *= data.r;
        ui = mix(ui, .8, fillMask(dfBox(p,b)));
    }
    
    //draw number    
    vec4 tmp = text;
    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));
    text = tmp;
    
}

// Function 1069
vec4 drawSprite(vec2 uv) {
    // ?
    
    vec4 t = texture(iChannel0, vec2(uv.x / 6.6, uv.y));;
    vec2 mask = smoothstep(.04, .0, abs(uv - .5) - vec2(.5));
    t *= mask.x * mask.y;
    
    return t;
}

// Function 1070
void raytraceTreeline(vec3 rayPt, vec3 rayDir, float treelineZ, float treeGapX, float offX, float groundY){
    
    float rayGapStepsZ = (treelineZ-rayPt.z)/rayDir.z;
    float rayX = rayPt.x + rayDir.x*rayGapStepsZ;
    float treeX = floor((rayX-offX)/treeGapX)*treeGapX + treeGapX*0.5 + offX;
    
    if (abs(treeX) > 240.0) return;
    
    raytraceTree(rayPt,rayDir,vec3(treeX,groundY,treelineZ),
    	sin(treeX+treelineZ)*1.5,//yOff
        sin(treeX*0.7+treelineZ)*4.0,//heightOff
        sin(treeX*0.85+treelineZ)*1.0//widthOff
    );
    
    #ifdef DRAW_CLIP_RAYTRACES
    //color.r += sin(treeX*0.1)*0.01+0.5;
    #endif
    
}

// Function 1071
vec3 DrawMovements(vec2 p, vec3 color)
{
    vec2 q = p - vec2(1.5, 3.0) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.3));
    color = DrawUIBox(q, color);
    
    float d = PrintInt(q*3.0-vec2(-4.0, -1.0), gState.y);
    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;
    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));
    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));
    
    q -= vec2(-1.0, 0.35); q*=0.25;
    caret.x = count = 0.;
    d = M(r(q)); add(); d += O(r(q));  add(); d += V(r(q));  add(); d += E(r(q));  add(); d += S(r(q)); 
    color = mix(color, lettersColor*0.1, smoothstep(0.4, 1.0, d));
    color *= smoothstep(0., 0.005, length(q-vec2(0.27, 0.))-0.008);
    color *= smoothstep(0., 0.005, length(q-vec2(0.27, -0.035))-0.008);
    
    return color;
}

// Function 1072
void drawAxes(float x, float y) {
    float axesThickness = 0.02;
    if (
        eq(x, 0.0, axesThickness) ||
        eq(y, 0.0, axesThickness) ||
        eq(x * x + y * y, 0.0, axesThickness) ||
        (eq(mod(x, 1.0), 0.0, axesThickness) && eq(y, 0.0, 6.0 * axesThickness)) ||
        (eq(mod(y, 1.0), 0.0, axesThickness) && eq(x, 0.0, 6.0 * axesThickness))
    ) {
    	brightness = 1.0;
        saturation = 0.0;
    }
}

// Function 1073
float circle(const in vec2 U, const in float t, const in float aa){
	float s = -(mod(floor(t/PI), 2.) * 2. - 1.),
	p = mod(t, PI),
	lr = 1. - step(threshold, p);
	float size = sin(t * 2.) * .075 + .09;
	return smoothstep(size + aa, size, distance(mix(P, L, lr), U));
}

// Function 1074
float drawFloat(float value, int prec, int maxDigits)
{ 
  float tpx = tp.x-FONT_SPACE*float(maxDigits);
  float c = 0.;
  if (value < 0.0) 
  { 
    c = char(45); // write minus sign
    value = -value;
  }
  tp.x -= FONT_SPACE;
  c += drawInt(int(value),1);
  c += char(46); SPACE; // add dot 
  c += drawFract(fract(value), prec);
  tp.x = min(tp.x, tpx);
  return c;
}

// Function 1075
float Line( vec2 vCoord, vec2 vA, vec2 vB )
{
    vec2 vDelta = vB - vA;
    vec2 vDir = normalize(vDelta);
    vec2 vOffset = vCoord - vA;
    
    float fProj = dot( vOffset, vDir );
    
     fProj = clamp( fProj, 0.0, length(vDelta) );
    vec2 vClosest = vA + vDir * fProj;
    
    float d = max(0.0, 1.0 - length( vClosest - vCoord ) * 0.25);
    return d * d * d;
    //return 0.0;
}

// Function 1076
vec2 linePointDist(vec2 lb, vec2 le, vec2 p) {
    float len = length(lb-le);
    if (len==0.0) {
        return (lb-p);
    }
    vec2 dir = normalize(le-lb);
    float t = max(0.0, min(len, dot(p - lb, dir)));
    vec2 proj = lb+t*dir;
    return proj-p;
}

// Function 1077
float line(vec2 p, vec3 line)
{
	vec2 normal = line.xy; // line.xy must be normalized
	float dist = line.z;
	return dot(p, normal) - dist;
}

// Function 1078
vec3 DrawScore(vec2 p, vec3 color)
{
    vec2 q = p - vec2(1.8, 1.5) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.45));
    color = DrawUIBox(q*vec2(0.8, 1.), color);
    
    float d = PrintInt(q*3.0-vec2(-4.5, -1.0), gState.z*25.);
    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;
    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));
    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));
    
    q -= vec2(-1.2, 0.35); q*=0.25;
    caret.x = count = 0.;
    d = S(r(q)); add(); d += C(r(q)); add(); d += O(r(q));  add(); d += R(r(q));  add(); d += E(r(q)); 
    color = mix(color, lettersColor*0.1, smoothstep(0.4, 1.0, d));
    color *= smoothstep(0., 0.005, length(q-vec2(0.27, 0.))-0.008);
    color *= smoothstep(0., 0.005, length(q-vec2(0.27, -0.035))-0.008);
    
    return color;
}

// Function 1079
vec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {
    float r = radius*sqrt(Xi1);
    float theta = Xi2;
	return vec2( r*cos(theta), r*sin(theta) );
}

// Function 1080
float dfLine(vec2 start, vec2 end, vec2 uv)
{
	start *= scale;
	end *= scale;
    
	vec2 line = end - start;
	float frac = dot(uv - start,line) / dot(line,line);
	return distance(start + line * clamp(frac, 0.0, 1.0), uv);
}

// Function 1081
float Outline_OffsetDifference(in vec2 uv, float depth)
{
    // 0.003 is the offset size, and thus outline thickness, in uv
    vec2 offset = vec2(UVOffset, 0.0);              
    
    vec4 marchA = RayMarch(Ray_LookAt(uv + offset.xy, CamOrigin, CamLookAt));
    vec4 marchB = RayMarch(Ray_LookAt(uv - offset.yx, CamOrigin, CamLookAt));
    
    // 0.07 is the depth threshold is world units, and thus is dependent on scene geometry for a proper value.
    float diff = clamp(max(abs(depth - marchA.x), abs(depth - marchB.x)) / 0.07, 0.0, 1.0);
    
    // 0.6 is a control value for outline stroke thickness, and 8.0 is stroke strength.
    return 1.0 - smoothstep(0.6, -0.001, pow(diff, 8.0));
}

// Function 1082
vec2 circles (vec2 p) {
    float r = 0.6;
    return vec2(
        square(p - vec2(-r*0.7, 0.0), r), 
        circle(p - vec2(r*0.4, 0.0), r*0.7));
}

// Function 1083
void mixColorLine(vec2 uv,inout vec3 col,vec2 lineA,vec2 lineB,float scale)
{
    col = mix(
        col , 
        hash3point(lineA+lineB) ,
        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))
    );
}

// Function 1084
float b2_linear(vec3 a, vec3 b, float x) {
    vec3 c = b2_coeffs(a,b);
    c = vec3(1.0, c.yz / c.x);
    float a0 = integrate_sqrt_poly2_fast(c.y, c.z, 0.0).x;
    float a1 = integrate_sqrt_poly2_fast(c.y, c.z, 1.0).x;    
    return inv_integrate_sqrt_poly2_fast(c.y, c.z, x*(a1 - a0) + a0);
}

// Function 1085
vec4 draw_data(vec2 uv,int id){
    vec4 fragColor;
 	Body body = bodys[id];
    fragColor.xy += body.pos * step(0.,uv.x) * step(1. / 3. * 2.,1.-uv.x);
    fragColor.xy += body.acc * step(1. / 3.,uv.x) * step(1. / 3.,1.-uv.x);
    fragColor += body.mass   * step(1. / 3. * 2.,uv.x) * step(0.,1.-uv.x);   
    return fragColor;
}

// Function 1086
float aaa_line( mat2 K, vec2 uv, vec2 dx, float width )
{
    vec3 dxn = length_normalize( dx );
    mat2 M = mat2( dxn.xy, perp( dxn.xy ) );
    uv = ( uv - dx / 2. ) * M;
    return aaa_box( K * M, uv, vec2( dxn.z, width ), vec2(0) );
}

// Function 1087
float Outline_NearMiss(in vec4 march)
{
    float a = step(FarClip, march.x);                        // a == 1.0 if the depth >= FarClip, aka a miss
    float b = clamp(march.y / NearMissThreshold, 0.0, 1.0);  // denominator is the border width in world units
    
    return (1.0 - pow(b, 8.0)) * a;                          // pow value controls edge darkness and smooth fade
}

// Function 1088
float draw_segment(vec2 uv, float e, float w, vec3 p0, vec3 p1, mat4 T) 
{
    vec4 a = T * vec4(p0, 1.0);
    vec4 b = T * vec4(p1, 1.0);
    
    a.xy /= a.z;
    b.xy /= b.z;
    
    return segment(uv, e, w, a.xy, b.xy) * point(uv, e, b.xy);
}

// Function 1089
vec4 demoLineIntersection(float t,vec2 u,vec3 r,vec4 m
){vec4 c=vec4(1)
 ;u   =viewzoom*(u   -r.xy*.5)/r.y
 ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y
 ;vec2 l0=vec2(-.4)
 ;vec2 l1=vec2( .7)
 ;vec2 r0=vec2(.5,-.5)
 ;vec2 r1=vec2(.5,-.1)
 ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y
 ;if(pointCount >0.
 ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.
 ;}
 ;if(pointCount >1.//point4 sets one point of the red/yellow arc
 ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.
 ;}  
 ;if(pointCount >2.//point4 sets one point of the red/yellow arc
 ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.
 ;} 
 ;if(pointCount >3.//point4 sets one point of the red/yellow arc
 ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.
 ;}
 ;c.x=segment(u,l0,l1)
 ;c.y=segment(u,r0,r1)
 ;c.z=length(u-mix(l0,l1,.5))
 ;c.w=length(InterWall(r0,r1,l0,l1)-u)
 ;c.xy-=.02
 ;c.z=abs(c.z-.05)-.02
 ;c.w=abs(c.w-.1)-.03
 ;c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)
 ;c.xy+=c.w*.2//fold w as yellow
 ;return c
 ;}

// Function 1090
float df_line( in vec2 a, in vec2 b, in vec2 p)
{
    vec2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);	
	return length(pa - ba * h);
}

// Function 1091
vec3 xyzToLinearSrgb(vec3 c) {
    return M_XYZ_TO_SRGB * c;
}

// Function 1092
vec3 BSpline( const in vec3 a, const in vec3 b, const in vec3 c, const in vec3 d, const in float t)
{
	const mat4 mSplineBasis = mat4( -1.0,  3.0, -3.0, 1.0,
							         3.0, -6.0,  0.0, 4.0,
							        -3.0,  3.0,  3.0, 1.0,
							         1.0,  0.0,  0.0, 0.0) / 6.0;	
	
	float t2 = t * t;
	vec4 T = vec4(t2 * t, t2, t, 1.0);
		
	vec4 vWeights = T * mSplineBasis;
	
	vec3 vResult;

	vec4 vCoeffsX = vec4(a.x, b.x, c.x, d.x);
	vec4 vCoeffsY = vec4(a.y, b.y, c.y, d.y);
	vec4 vCoeffsZ = vec4(a.z, b.z, c.z, d.z);
	
	vResult.x = dot(vWeights, vCoeffsX);
	vResult.y = dot(vWeights, vCoeffsY);
	vResult.z = dot(vWeights, vCoeffsZ);
	
	return vResult;
}

// Function 1093
float circle(lowp vec2 p, lowp float r)
{
 	return step(length((p - uv)*ar),r*.5);
}

// Function 1094
Hit rect(Ray r, vec3 p, vec3 n, vec2 s)
{
    vec3 nu = normalize(cross(vec3(1,0,0),n));
    vec3 nr = normalize(cross(n,nu));
    
    float t = (dot(n,p)-dot(n,r.o))/dot(n,r.d);
    vec3 q = r.o+r.d*t;
    
    float x = dot(q-p,nr);
    float y = dot(q-p,nu);
    
    float d = length(r.o-q);
    if (abs(x)>s.x || abs(y)>s.y || t < 0.) { d = -1e10; }

    return Hit(q, n, d,0);
}

// Function 1095
vec4 DrawAxis(vec2 uv,float thickness){
    //hao much times is a dot's radius to thickness
    float times=2.0;
    //Draw scale on X Axis
    if(fract(uv.x+times*thickness)<=times*2.*thickness && distance(uv,vec2(floor(uv.x+times*thickness),.0))<=times*thickness){
        return vec4(1,0,0,1);
    }
    //Draw scale on Y Axis
    if(fract(uv.y+times*thickness)<=times*2.*thickness && distance(uv,vec2(0,floor(uv.y+times*thickness)))<=times*thickness){
        return vec4(1,0,0,1);
    }
    //Draw X and Y Axis
    if(abs(uv.x)-thickness<=0.||abs(uv.y)-thickness<=0.){
        return vec4(0,0,0,1);
    }else{
        return vec4(1,1,1,1);
    }
}

// Function 1096
void draw_04x08(in vec2 p, in vec2 uv, inout vec4 fragColor)
{
    vec2 o = vec2(2., floor(z - 15.));
    p -= o;
    vec2 c = uv * z - o;

    { // Cell frame
	    float w = 0.25;
		float l = sharpen(df_line(c, vec2( 0, 0), vec2( 4, 0)), w)
	            + sharpen(df_line(c, vec2( 0, 8), vec2( 0, 0)), w)
            	+ sharpen(df_line(c, vec2( 4, 8), vec2( 4, 0)), w)
            	+ sharpen(df_line(c, vec2( 0, 8), vec2( 4, 8)), w);
    
	    if (l > 0.) fragColor = vec4(CL, 1);
    }
    
    { // Cells
    	if (   p.x >= 0. && p.y >= 0.
	        && p.x <= 3. && p.y <= 7.) {
	    	float bit = 0.;
	        float idx = p.y * 4. + 3. - p.x;
	        bit = mod(val / pow(2., idx), 2.);
            float mut = idx > 23. ? .4 : 1.;
	    	fragColor = vec4((floor(bit) > 0. ? C1 : C0) * mut, 1);
		}
    }
}

// Function 1097
float polar_grid_lines(vec2 polar, 
                       GridCoords grid, 
                       float circle_weight, 
                       float radial_weight) {
    vec2 lines;
    //Draw concentric circles
    lines.x = smoothstep(1.0 - circle_weight, 1.0, grid.cell_uv.x);
    
    //To get radials to be a constant width, we need to scale using
    //the radius from the center of the screen.
    float scaled_line_width = radial_weight / polar.x;
    lines.y = smoothstep(1.0 - scaled_line_width, 1.0, grid.cell_uv.y);
    
    //convert to greyscale
    return max_vec2(lines);
}

// Function 1098
float circle(in vec2 _p, in vec2 _center, in float _radius) {
  vec2 dist = _p - _center;
  return step(distance(_p, _center), _radius);
}

// Function 1099
vec3 screenToLinear(vec3 screenRGB)
{
    return (iMouse.z < 0.5) ? decodeSRGB(screenRGB) : gamma(screenRGB, GAMMA);
}

// Function 1100
float fLineSegment(vec3 p,vec3 a,vec3 b){vec3 c=b-a;float t=clamp(dot(p-a,c)/dot(c,c),0.,1.);return length(c*t+a-p);}

// Function 1101
vec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){

    //line 1
    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));
    col = mix(col, vec3(1.,.2,.5), f);//0.5
    //segment end points line 1
    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);
    col = mix(col, line1Col, f);
    //segment end points line 1
    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);
    col = mix(col, line1Col, f);
    return col;
}

// Function 1102
vec3 drawMap( vec3 col, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy /iResolution.xy;
    float xCells = txCells.w*(iResolution.x / iResolution.y);
    vec2 p = uv-vec2(0.5-txCells.z/(xCells*2.), 0.); // center
    p.x *= iResolution.x / iResolution.y;
    
    vec2 q = floor(p*txCells.w);
    vec2 r = fract(p*txCells.w);

    vec2 l = vec2((15.*fragCoord-iResolution.xy)/iResolution.y);
    l.x -= 0.55; l.y -= 0.5;
    l = abs(fract(l) - 0.5) - 0.25;
    l = step(0.0, l)*l*4.0;
    l *= l; l *= l; l *= l;
    l = 1. - l;
    float val = 1.0 - l.x*l.y;
    
    vec3 bg = mix(vec3(0., 0.1, 0.15), vec3(1.), val);
    col += bg*step(0., p.x)*step(p.x, txCells.z/txCells.w);
    if( q.x>=0.0 && q.x<=txCells.z )
    {
        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;
        if( c>0.5 )
        {            
            float d = sdBox(r-0.5, vec2(1.));
            float f = 1.0 - smoothstep( -0.01, 0.01, d );
            
            vec3 wco = c > 2.5 ? p2Color :
            		   c > 1.5 ? p1Color : vec3(0.25);
            col = mix( col, wco, f );
            //col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*d*d);
        }
    }
    return col;
}

// Function 1103
float line_d(vec2 p, vec2 v, vec2 w)
{
  // Return minimum distance between line segment vw and point p
  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt
  if (l2 == 0.0) return distance(p, v);   // v == w case
  // Consider the line extending the segment, parameterized as v + t (w - v).
  // We find projection of point p onto the line. 
  // It falls where t = [(p-v) . (w-v)] / |w-v|^2
  float t = dot(p - v, w - v) / l2;
  if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment
  else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment
  vec2 projection = v + t * (w - v);  // Projection falls on the segment
  return distance(p, projection);
}

// Function 1104
vec4 drawCellEntrance(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteEntrance(gameFrame);
    return sampleSprite(sprite, colors, coord);
}

// Function 1105
RGB oklab_to_linear_srgb(Lab c)
{
    float l_ = c.L + 0.3963377774f * c.a + 0.2158037573f * c.b;
    float m_ = c.L - 0.1055613458f * c.a - 0.0638541728f * c.b;
    float s_ = c.L - 0.0894841775f * c.a - 1.2914855480f * c.b;

    float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;

    return RGB(
        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
    );
}

// Function 1106
float lineseg( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    float d = length( pa - ba*h );

    return  (1.0 - d);
}

// Function 1107
vec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){


    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));
    col = mix(col, vec3(1.,0.7,0.), f);
    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);
    col = mix(col, vec3(1.,0.7,0.), f);
    return col;
}

// Function 1108
vec3 random_sphere_direction(vec2 random_value)
{
	float s = random_value.x * MPI * 2.0;
	float t = random_value.y * 2.0 - 1.0;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 1109
float drawone(vec2 z, vec2 t0, float d) {
  d = min(d,segment(z,t0,vec2(0)));
  d = min(d,segment(z,t0,vec2(X,0)));
  d = min(d,segment(z,t0,vec2(0,1)));

  d = min(d,segment(-z,t0,vec2(0)));
  d = min(d,segment(-z,t0,vec2(X,0)));
  d = min(d,segment(-z,t0,vec2(0,1)));
  return d;
}

// Function 1110
float directionalLight(vec4 light, vec3 normal) {
	vec3 lightDir = normalize(light.xyz);
	return light.w * dot(lightDir, normal);
}

// Function 1111
float InRect(const in vec2 vUV, const in vec4 vRect)
{
	vec2 vTestMin = step(vRect.xy, vUV.xy);
	vec2 vTestMax = step(vUV.xy, vRect.zw);	
	vec2 vTest = vTestMin * vTestMax;
	return vTest.x * vTest.y;
}

// Function 1112
void UI_DrawSliderY( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))
        return;
    
    Rect horizLineRect;
    
    horizLineRect = sliderRect;
    if (!scrollbarStyle)
    {
	    float fMid = sliderRect.vPos.x + sliderRect.vSize.x * 0.5;
    	horizLineRect.vPos.x = fMid - 2.0;
    	horizLineRect.vSize.x = 4.0;
    }

#ifdef NEW_THEME    
    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );
#else    
    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );
#endif    

    float fSlideMin = sliderRect.vPos.y + fHandleSize * 0.5f;
    float fSlideMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;

    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);

    Rect handleRect;

    handleRect = sliderRect;
    handleRect.vPos.y = fDistSlider - fHandleSize * 0.5f;
    handleRect.vSize.y = fHandleSize;

    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);
    if ( bActive )
    {
        handleColor.rgb += 0.1;
    }
    
    // highlight
#ifdef NEW_THEME     
    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )
    {
        handleColor.rgb += 0.05;
    }
#endif    

    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );
#ifdef NEW_THEME   
    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );
#else     
    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );
#endif    
}

// Function 1113
vec3 drawSegment(vec2 p, vec4 vertex1, vec4 vertex2){
    float d = distance(vertex1.xy, vertex2.xy);
    float d1 = distance(p, vertex1.xy);
    float d2 = distance(p, vertex2.xy);
    
    if(abs(d - d1 - d2) < 0.0001)
        return mix(0.5 + vertex1.xyz*inversesqrt(2.0 - 2.0*vertex1.w), 0.5 + vertex2.xyz*inversesqrt(2.0 - 2.0*vertex2.w), d1/d);
    else return vec3(0);
}

// Function 1114
float circle(vec2 uv, vec2 position, float radius) {
    
    return length(uv - position) - radius;
}

// Function 1115
float fHexagonCircumcircle(vec3 p,vec2 h){vec3 q=abs(p);return max(q.y-h.y,max(q.x*0.866+q.z*.5,q.z)-h.x);}

// Function 1116
vec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {
	if (SHOW_COSTLY) return vec2(8.);
	float d = 1e5;
	for (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision
		
		// construct the 2 sub- control polygons
		vec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),
			 P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),
			 P0123 = mix(P012,P123,x); // is on the spline
		vec2 D = P0123-pos;
		d = min(d, dot(D,D));
	}
	d = sqrt(d);
	return vec2(d);
}

// Function 1117
float circleDist(vec2 p, float radius) {
    return length(p) - radius;
}

// Function 1118
vec3 drawStartBottom(ivec2 coord, int gCave, int gHighScore, int gLevel, int gScore)

{
    const vec3 backColor = COLOR01(ivec3(0, 0, 0));
    const vec3 blueColor = COLOR01(ivec3(33, 110, 189));
    const vec3 greyColor = COLOR01(ivec3(192, 192, 192));

    vec3 res = backColor;

    for (int i=3; i<40; i+=9)
    {

        res = lerp(res, blueColor, coordMask(coord, ivec4(0, i, TIT_RES.x - 1, i)));
    }

    int y = 4;
    res = lerp(res, greyColor, printWord8(coord - ivec2(0, y), int[8](_, C, A, V, E, L_COLON, _, _)));
    #ifdef UNLOCK_CAVES
        res = lerp(res, (gCave % 5) == 0 ? vec3(0.8, 0.0, 0.4) : blueColor, printLetter(coord - ivec2(CEH_RES.x * 7, y), gCave - gCave / 5));
    #else
        res = lerp(res, blueColor, printLetter(coord - ivec2(CEH_RES.x * 7, y), gCave - gCave / 5));
    #endif
    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](L, E, V, E, L, L_COLON, _, _)));
    res = lerp(res, blueColor, printInt(coord - ivec2(CEH_RES.x * 17, y), gLevel, 1));
    y += 9;
    res = lerp(res, blueColor, printInt(coord - ivec2(0, y), 1, 1));
    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](P, L, A, Y, E, R, _, _)));
    res = lerp(res, blueColor, printInt(coord - ivec2(CEH_RES.x * 10, y), 1, 1));
    res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 12, y), int[8](J, O, Y, S, T, I, C, K)));
    y += 9;

    if ((gScore == 0) && (gHighScore == 0))
    {
        res = lerp(res, greyColor, printWord8(coord - ivec2(0, y), int[8](P, R, E, S, S, _, B, U)));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](T, T, O, N, _, T, O, _)));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 16, y), int[8](P, L, A, Y, _, _, _, _)));
        y += 9;
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](W, I, T, H, _, C, H, R)));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](I, S, _, G, R, A, Y, _)));
        y += 9;
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 2, y), int[8](B, Y, _, P, E, T, E, R)));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](_, L, I, E, P, A, _, _)));
    }
    else
    {
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x, y), gHighScore, 6));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](H, I, G, H, _, _, _, _)));
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 13, y), 0, 6));
        y += 9;
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x, y), gScore, 6));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 8, y), int[8](L, A, S, T, _, _, _, _)));
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 13, y), 0, 6));
        y += 9;
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x, y), int[8](P, L, Y, R, _, _, _, _)));
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 6, y), 1, 1));
        res = lerp(res, greyColor, printWord8(coord - ivec2(CEH_RES.x * 13, y), int[8](P, L, Y, R, _, _, _, _)));
        res = lerp(res, greyColor, printInt(coord - ivec2(CEH_RES.x * 18, y), 2, 1));
    }
    return res;
}

// Function 1119
vec3 drawLineSeg(vec2 lpt, vec2 lvec, vec2 p, in vec3 bg, in vec3 fg) {
    float dist = lineDist(p, lpt, lvec);
    return edgeToMix(dist, bg, fg);
}

// Function 1120
float circle(vec2 center, vec2 p, float radius, float thickness) {
    float d = circleDistance(center, p, radius);
    if(d < thickness) {
       return shade(d, thickness);    
    } else {
		return 0.0;
    }
}

// Function 1121
float sdLine(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

// Function 1122
void DrawDirt()
{
	if ( abs(pixel.x) < 180.0 && abs(pixel.y) < 180.0 )
	{
		fragColor.rgb = mix( vec3(.2,.1,.05), vec3(.35,.2,.13), texture( iChannel0, pixel/40.0 ).r);
	}
}

// Function 1123
float ndfTrowbridgeReitzRect(float NdotH, float alpha, float alphaPrime)
{
    float alpha2 = alpha * alpha;
    float alpha4 = alpha2 * alpha2;
    float alphaPrime3 = alphaPrime * alphaPrime * alphaPrime;
    float NdotH2 = NdotH * NdotH;
    
    return 
        			 	(alpha2 * alphaPrime3)
    	/ /*-------------------------------------------------*/
        	  	(pow(NdotH2 * (alpha2 - 1.) + 1., 2.));      
}

// Function 1124
float drawLine(vec3 l, vec2 p, float lineWidth) {
    return (abs(geodesicDist(l, p.xy))-lineWidth);
}

// Function 1125
float RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)
{
	// vPixel is the centre of the pixel to be rasterized
	
	vec2 vAB = vB - vA;	
	vec2 vAbsAB = abs(vAB);
	float fGradientSelect = step(vAbsAB.y, vAbsAB.x);

	vec2 vAP = vPixel - vA;

	float fAB = mix(vAB.y, vAB.x, fGradientSelect);
	float fAP = mix(vAP.y, vAP.x, fGradientSelect);
	
	// figure out the co-ordinates we intersect the vPixelCentre x or y axis
	float t = fAP / fAB;	
	vec2 vIntersection = vA + (vB - vA) * t;
	vec2 vIntersectionDist = abs(vIntersection - vPixel);
	
	vec2 vResult = step(vIntersectionDist, vec2(0.5));

	// mask out parts of the line beyond the beginning or end
	float fClipSpan = step(t, 1.0) * step(0.0, t);	
	
	// select the x or y axis result based on the gradient of the line
	return mix(vResult.x, vResult.y, fGradientSelect) * fClipSpan;
}

// Function 1126
vec3 toLinear(vec3 c)
{
    return pow(c, vec3(2.2));
}

// Function 1127
float line (in vec2 a, in vec2 b)
{
    vec2 ba = b - a;
    float h = clamp (dot (-a, ba)/dot (ba, ba), .0, 1.);
    return length (-a - ba*h);
}

// Function 1128
vec3 DrawEntities(in vec2 p)
{
	vec3 entityLayer = vec3(0.);
	for (int i = 0; i < NUM_ENTITIES; ++i)
	{
		entityLayer = max(entityLayer, drawElement(p, gEntities.pos[i], gEntities.col[i], ENTITY_RADIUS, 0.03));
	}
	
	return entityLayer;
}

// Function 1129
float lineSegDistance(vec2 a, vec2 b, vec2 c) {
    vec2 ab = a-b;
    vec2 ac = a-c;
    
    if (length(ab) == 0.0) {
        return length(ac);
    }
    
    float dist = abs((ab.x * ac.y - ab.y * ac.x) / length(ab));
    
    if (dot(ab, ac) < 0.0) {
        return length(ac);
    } else if (dot(b-a, b-c) < 0.0) {
        return length(b-c);
    }
    
    return dist;
}

// Function 1130
vec4 lineToPointDistance( vec3 a, 
                          vec3 b, 
                          vec3 p)
{
    
    vec3 ba = b - a;    
    float t = dot(ba, (p - a)) / dot(ba, ba);
    vec4 result = vec4(ba * t + a - p, t);
    return result;
}

// Function 1131
UIDrawContext UIDrawContext_SetupFromRect( Rect rect )
{
    UIDrawContext drawContext;
    drawContext.viewport = rect;
    drawContext.vOffset = vec2(0);
    drawContext.vCanvasSize = rect.vSize;
	return drawContext;
}

// Function 1132
vec4 drawFade(ivec2 coordWS, mat4x3 colors, int animFrame, float gFade, bool isFadingOut)
{
    vec4 res = vec4(0.0);

    ivec2 coordScroll = ivec2(coordWS.x, coordWS.y - animFrame * SCROLL_SPEED);
    ivec2 coordCellScroll = modint(coordScroll, CEL_RES);
    res.rgb = drawCellTitaniumWall(ivec4(0), colors, coordCellScroll).rgb;

    vec2 cellIndex = vec2(((isFadingOut) ? coordWS * ivec2(2) : coordWS) / CEL_RES);
    float r = rand21(cellIndex + vec2(17.0, 17.0));
    res.a = step(r, gFade);

    return res;
}

// Function 1133
float stripesCircle1(vec2 uv, float distorsion) {
    return stripesCircle(uv, StripesCircleOpt(.25, .385, 3., -.05, 0.), StripesOpt(distorsion, 0., 1.));
}

// Function 1134
float Circle(vec2 p, float r, float i)
{
    
    //SS is used as smoothstep range
    //there is a much better way that fabrice told me about.
    //It's in another shader. (Applause)
 	float ss = 0.009;
    
    //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/
    float a  =atan( p.y,p.x);
    float shape = sin(a*i+i/1.)/10.;
    //creating the smoothstepped circle
    float k = smoothstep(r-ss, r+ss, length(p/1.5)+shape); 
    //adding the rim circle here even though I do it in main. 
    //I dont' know why I did this but it seems to help! (APPLAUSE)
    return k+rimCircle(p,r-0.001, i);
}

// Function 1135
void UI_DrawColorPickerSV( inout UIContext uiContext, bool bActive, vec3 vHSV, Rect pickerRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, pickerRect ))
        return;
    
    vec2 vCurrPixelPos = (uiContext.vPixelCanvasPos - pickerRect.vPos) / pickerRect.vSize;
    vCurrPixelPos.y = 1.0f - vCurrPixelPos.y;
    vec3 vHSVCurr = vHSV;
    vHSVCurr.yz = vCurrPixelPos;

    uiContext.vWindowOutColor = vec4( hsv2rgb( vHSVCurr ), 1.0 );
    
    vec2 vSelectedPos = vHSV.yz;
    vSelectedPos.y = 1.0f - vSelectedPos.y;
    vSelectedPos = vSelectedPos * pickerRect.vSize + pickerRect.vPos;
        
    float l = length( vSelectedPos - uiContext.vPixelCanvasPos );
    float d = l - 3.0;
    d = min(d, 5.0 - l);
    if ( bActive )
    {
        float d2 = l - 5.0;
    	d2 = min(d2, 7.0 - l);
	    d = max(d, d2);
    }
    
    float fBlend = clamp(d, 0.0, 1.0);
    
    uiContext.vWindowOutColor.rgb = mix(uiContext.vWindowOutColor.rgb, vec3(1.0) - uiContext.vWindowOutColor.rgb, fBlend);
}

// Function 1136
maybe_vec2 get_distances_along_line_to_union(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    return maybe_vec2(
        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),
             !shape1.exists ? shape2.value.y  : !shape2.exists ? shape1.value.y  : max(shape1.value.y,  shape2.value.y )),
        shape1.exists || shape2.exists
    );
}

// Function 1137
float rectangle(vec2 uv, vec2 pos, float width, float height, float blur) {
    
    pos = (vec2(width, height) + .01)/2. - abs(uv - pos);
    pos = smoothstep(0., blur , pos);
    return pos.x * pos.y; 
   
}

// Function 1138
float onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {
	return onLine( c.y, b )*onBand( c.x, mi, ma );
}

// Function 1139
mat4 GetDirectionalLightMatrixInverse ()
{
    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();
    vec3 trans = GetDirectionalLightSourcePosition();
	mat4 rot = rotationAxisAngle(rotAxisAngle.xyz, rotAxisAngle.w );
	mat4 tra = translate( trans.x, trans.y, trans.z );
	return tra * rot; 
}

// Function 1140
vec3 linearSrgbToXyz(vec3 c) {
    return M_SRGB_TO_XYZ * c;
}

// Function 1141
float fillLine( in vec2 p, float x1, float y1, float x2, float y2, float th1, float th2 )
{ 
	vec2 li = sdSegment( vec2(x1,y1), vec2(x2,y2), p );
    float d = li.x - mix(th1,th2,li.y);
	
    float w = fwidth(d)*4.0;
	return 1.0 - smoothstep(-w, w, d);
}

// Function 1142
bool ML_OnRect4(vec4 coord, vec4 rect, out vec2 ret){
    if(ML_InRect(coord.xy, rect, 1.)){
        ret = ML_GetRect4(coord, rect);
        return 1 == 1;
    }
    return 0 != 0;
}

// Function 1143
void
drawRedstoneTorch (inout vec4 color,
                   in vec2 pos,
                   in ivec3 coord, in float alphaScale, in float invScale)
{
    Voxel voxel = readVoxel(coord);
    
    float tHandle, handleAlpha, tHead = length(pos) - REDSTONE_TORCH_RADIUS, headAlpha;
    
    
    if (voxel.facing != VOXEL_FACING_PLUS_Z)
    {
    
        if      (voxel.facing == VOXEL_FACING_MINUS_X)
            tHandle = max(abs(pos.y), pos.x);
        else if (voxel.facing == VOXEL_FACING_PLUS_X)
            tHandle = max(abs(pos.y), -pos.x);
        else if (voxel.facing == VOXEL_FACING_MINUS_Y)
            tHandle = max(abs(pos.x), pos.y);
        else if (voxel.facing == VOXEL_FACING_PLUS_Y)
            tHandle = max(abs(pos.x), -pos.y);
    
    	tHandle -= REDSTONE_TORCH_HANDLE_WIDTH * .5;
    
        handleAlpha = smoothstep(3., 0., tHandle * invScale);
        vec4 handleColor = vec4(REDSTONE_TORCH_HANDLE_COLOR, handleAlpha * alphaScale);
        //handleColor.rgb *= handleColor.a;
        //blendOver(color, color.rgb, handleColor.rgb, color.a, handleColor.a);
        color = mix(color, handleColor, handleColor.a /** (1.0 - color.a)*/);
        //color.a = (1.0 - color.a) * handleColor.a;
    }

    headAlpha = smoothstep(3., 0., tHead * invScale);
    //color.rgb = mix(color.rgb, getRedstoneColor(voxel.power), alphaScale * headAlpha);
    
    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS, headAlpha * alphaScale);
    //voxelColor.rgb *= voxelColor.a;
    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);
    
    
    color = mix(color, voxelColor, voxelColor.a);
    //color.a = voxelColor.a;
    //color.rgb *= 1. - .1 * exp(-10. * t) * (1.-alpha);
    /*
    uint uniqueIndex = uint(getWorldVirtualToIndex(getWorld(), getImage(), coord));
    
    for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)
    {
    	float seed = float(uniqueIndex * REDSTONE_PARTICLE_COUNT + i * 4u);

        float angle = hash11(seed++) * TAU;
        float speed = .1 + hash11(seed++) * .4;
        vec2 dir = vec2(sin(angle), cos(angle));
        vec2 vel = dir * speed;
        float lifeTime = .4 + .6  * hash11(seed++);
        float initialTime = hash11(seed++) * lifeTime;

        float radius = (.03 + pow(hash11(seed++), 2.) * .22) * REDSTONE_TORCH_RADIUS;

        vec2 initialPos = dir * REDSTONE_TORCH_RADIUS;

        vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);
        float particleAlpha = .7 * getParticleAlpha(initialTime, lifeTime, iTime, 2.5);

        float t = length(pos - particlePos) - radius;
        float alpha = smoothstep(3., 0., t * invScale) * particleAlpha * alphaScale;
        color.rgb = mix(color.rgb, getRedstoneColor(MAX_REDSTONE_POWER), alpha);
    }
	*/
}

// Function 1144
void DrawLine( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB, float fThickness )
{
    DrawBlend( drawContext, vColor, LineSmooth( drawContext, abs(LineInfo( drawContext.vUV, vA, vB )), fThickness ) );
}

// Function 1145
float PointLineAlong2d(vec2 a, vec2 n, vec2 p)
{
    return dot(p - a, n) / dot(n, n);
}

// Function 1146
float BSpline(float x)
{
    bool s = x < 0.0;
    
    x = abs(x);

    bool c = x < 1.0;
    
    if(!c) x = 2.0 - x;
    
    float x2 = x  * x;
    float x3 = x2 * x;
	
    float r = x3 * (1.0/6.0);
    
    if(c) r = r * 3.0 - x2 + 2.0/3.0;
    
    return r;
}

// Function 1147
vec4 drawShape(vec2 uv, vec2 position, int sides,float size, vec3 color) {
	// Angle from current pixel
    uv = rotate2d((iTime*-.2)*3.14)*uv;
  	float a = atan(uv.x,uv.y)+PI;
    // radius from current pixel
 	float r = 2.0*PI/float(sides);
  	// modulate the distance
    
  	float d = cos(floor(.5+a/r)*r-a)*length(uv);
	//define the edges, and make smooth
  	vec4 shape = vec4(1.0-smoothstep(size,size+.08,d));
  	//color the shape
    shape.rgb*=color;
	return shape;
}

// Function 1148
void SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )
{
     #define DI 64.0  // for perfect overal brigthness match
   //#define DI 68.0  // for normalizing to maximum = 1.0;
	
	sh[0] += col * (21.0/DI);
	sh[0] -= col * (15.0/DI) * v.z*v.z;
	sh[1] += col * (32.0/DI) * v.x;
	sh[2] += col * (32.0/DI) * v.y;
	sh[3] += col * (32.0/DI) * v.z;
	sh[4] += col * (60.0/DI) * v.x*v.z;
	sh[5] += col * (60.0/DI) * v.z*v.y;
	sh[6] += col * (60.0/DI) * v.y*v.x;
	sh[7] += col * (15.0/DI) * (3.0*v.z*v.z-1.0);
	sh[8] += col * (15.0/DI) * (v.x*v.x-v.y*v.y);
}

// Function 1149
vec2 sh_draw_ellipse(vec2 u, vec2 position, float radius, float yFactor, float a)
{
    u -= position;
    u.y /= ASPECT_RATIO;
    u = lib_rotate(u, a);
    u /= vec2(1.0, yFactor);

    float l=length(u) / radius;
    return vec2(l < 1.0 ? 1.0 : 0.0 ,max(0.0, 1.0 - l));
}

// Function 1150
float lineSegDist( vec2 uv, vec2 ba, vec2 a, float r )
{
    vec2 pa = uv - a - ba*r; ba = -ba*r*2.0;
    return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) );
}

// Function 1151
vec4 DrawTracks(vec2 uv, int lane, float size,vec3 color)
{
    float center = float(lane)*0.2+0.1;
    float d = abs(uv.x - center)/0.1;
    vec4 ret=vec4(0.,1.,0.,1.);
    float mask = 1.-clamp(d,0.,1.); 
    float playTime = (iTime)*bpm/60./4.;
	ret.xyz = color*pow(d,fract(playTime*3.1415)*4.+6.)*ceil(mask);
    return vec4(ret.xyz,0.);//color.xyzx;
    
}

// Function 1152
vec4 drawLetter(in vec2 uv, in vec2 start, in float size, vec2 letter)
{
    vec4 col;
    vec2 pos;
    
    vec2 inbound = step(start, uv) - step(start + vec2(size), uv);
    
    if (inbound.x*inbound.y > 0.5)
    {
    	_CHAR(start, size, uv, letter);
    	col.g = col.b = col.r;
    	col.w = col.r*0.7;
    }
    return col;
}

// Function 1153
float lineintegral(vec3 a, vec3 b) 
{
    // find a scale where I can perceive it
    const float s = .8; //1.; //2.; //.5; //200.; //1./200.; //
    a *= s; b *= s; //
    return rebend(A(a, b) / s)
    //    / 8. // really dim too, brighten up
        ;
}

// Function 1154
void addBilinearPatch(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {
    vec2 m = rd.yz / rd.x;
    vec3 p = a - b + c - d, q = d - a, r = b - a;
    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;
    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;

    // Quadratic coefficients (reversed as a trick to deal with edge cases)
    float qa = cross2D(c4, c2);
    float qb = cross2D(c4, c1) + cross2D(c3, c2);
    float qc = cross2D(c3, c1);

    float discr = qb * qb - 4.0 * qa * qc;
    if (discr > 0.0) {
        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve quadratic in v
        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x);
        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x;

        // Get closest intersection in view and add it to the scene
        for (int n=0; n < 2; n++) {
            if (t[n] > 0.0 && (scene.hit ? t[n] < scene.dist : true) && abs(u[n] - 0.5) < 0.5 && abs(v[n] - 0.5) < 0.5) {
                scene.hit = true;
                scene.dist = t[n];
                scene.pos = ro + rd * t[n];
                scene.nor = normalize(cross(p * v[n] + q, p * u[n] + r));
                scene.uv = vec2(u[n], v[n]);
                scene.id = id;
            }
        }
    }
}

// Function 1155
float isoline(float val, vec3 p, vec3 n, float pas, float tickness) {
    vec3 grad = gradAt(p);
    grad -= n*dot(grad,n);
    float v = abs(mod((val)+pas*.5, pas)-pas*.5)*(resolution.x*ep2.x)/(100.*length(grad)*tickness);
    float v1 = abs(val-MinVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);
    float v2 = abs(val-MaxVal)*(resolution.x*ep2.x)/(200.*length(grad)*tickness);
    return smoothstep(.1,.9, v)*smoothstep(.3,.7, v1)*smoothstep(.3,.7, v2);
}

// Function 1156
vec3 randomHemisphereDirection( const vec3 n ) {
	lowp vec3 dr = randomSphereDirection();
	return dot(dr,n) * dr;
}

// Function 1157
vec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, bool fill_paper) {
    vec3 colour = current_colour;
    vec2 p2 = vec2(p1.x, p3.y);
    vec2 p4 = vec2(p3.x, p1.y);
    vec2 box_center = (p1 + p3)/2.0;
    float bd = rectangle(p-box_center, (p3-p1)/2.0);
    float noise = get_noise(p);
    noise *= 5.0;
    if (bd-noise<0.0 && fill_paper)
        colour = paper_colour;
    colour = draw_line(p, p1, p2, colour);
    colour = draw_line(p, p2, p3, colour);
    colour = draw_line(p, p3, p4, colour);
    colour = draw_line(p, p4, p1, colour);
    return colour;
}

// Function 1158
vec4 Circle(vec2 uv, vec2 p, float r, float blur, vec4 color)
{    
	float d = length(uv-p);
    float c = smoothstep(r, r-blur, d);    
    return c * color;
}

// Function 1159
void drawCheckbox( inout vec4 c, vec2 p, vec2 t, float selected){
    p-=t;
    c = mix(c, vec4(0.,1.,0.,1.), selected*smoothstep(0.,.01, .03 - sdBox(p,vec2(.012))));
    c = mix(c, vec4(0.,0.,0.,1.), smoothstep(0.,.01, .01-abs(.03 - sdBox(p,vec2(.010)))));
    c = mix(c, vec4(1. ), selected*(1.-smoothstep(-0.011,0.0, -.015+mapX(p,  0.03)))) ; // icon
}

// Function 1160
float line( in vec2 a, in vec2 b, in vec2 p )
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h );
}

// Function 1161
vec3 drawStars(vec2 uv, float t) {
    vec3 col = vec3(0.0);
        
    float ang = 360.0 * (atan(uv.y, uv.x)+_2PI) / _2PI;
    
    for (int j=0; j<5; j++) {
    	for (int i=0; i<30; i++) {
            float x = float(i);
            float y = mod(floor(ang)+float(j)-2.+360.0, 360.0);
        	vec4 s = texture(iChannel0, vec2(x+0.5, y+0.5)/iResolution.xy);
            float a = _2PI * (y + s.r) / 360.0;
            float dist = s.g;
            float speed = s.b;
            vec2 ca_offset = vec2(0.001, 0.0) * (1.0 + g_speed*2.0);
        	col.r += drawStar(t, uv-ca_offset, a, dist, speed).r;
            col.g += drawStar(t, uv, a, dist, speed).g;
            col.b += drawStar(t, uv+ca_offset, a, dist, speed).b;
    	}
    }
    
    return col;
}

// Function 1162
float sdLine(vec2 p, vec2 a, vec2 b, float r)
{
    vec2 ab = b-a;
    vec2 ap = p-a;
    return length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-r;
}

// Function 1163
int toLinear2(in vec2 fragCoord, in vec2 resolution, int mode) {
    if (mode == 0) {
    	return int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);
    } else {
        return int(fragCoord.x) * int(resolution.y) + int(fragCoord.y);
    }
}

// Function 1164
vec3 toLinear(vec3 v) {
  	return pow(v, vec3(2.2));
}

// Function 1165
float PointLineSegDist2d(vec2 a, vec2 n, vec2 p)
{
    float q = PointLineAlong2d(a, n, p);
    return length(p - (a + n * clamp(q, 0., 1.)));
}

// Function 1166
vec4 drawCellDiamond(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    Sprite sprite = getSpriteDiamond(animFrame);
    return sampleSprite(sprite, colors, coord);
}

// Function 1167
float drawInt(int v,int m){
 float c=0.; 
 if(v<0){v=-v; 
  if(m<1)m=1;else m--;
  _sub}//write "-" 
 int f=v,d=1; // get number of digits 
 for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;} 
 d=max(m,d);
 tpm*float(d);
 for(int n=1;n<11;n++){tpp;
  c += char(48+(v-((v/=10)*10)));
  if(n>=d)break;} 
 tpm*float(d); 
 return c;}

// Function 1168
float drawGrid(vec2 uv, float sz, float thick)
{
    return float(mod((uv.x), sz) < thick) * float(mod((uv.y), sz) < thick);;
}

// Function 1169
framebuffer drawcall(framebuffer f, pipeline_state state, vs_output_data vs_output, vec4 fs_output)
{
    //pipeline is in invalid state or object does not draw in this "fragment"
    if(vs_output.valid < 0.5 || f.valid < 0.5)
        return f;
    
    framebuffer final = f;

    //stencil test
    if(state.stencil_func != STENCIL_FUNC_NONE)
    {
        final.stencil = evaluate_stencil_operation(state.sfunc_sfail,f.stencil,state.stencil_ref_value);
        
        if(state.stencil_func == STENCIL_FUNC_NEVER)
        {
            return final;
        }
        else if(state.stencil_func == STENCIL_FUNC_LESS)
        {
            if(!(state.stencil_ref_value < f.stencil))
            	return final;
        }
        else if(state.stencil_func == STENCIL_FUNC_EQUAL)
        {
            if(!(state.stencil_ref_value == f.stencil))
                return final;
        }
        else if(state.stencil_func == STENCIL_FUNC_ALWAYS)
        {
            //no stencil fail
        }
        else
        {
            final.valid = 0.0;
        }
        final.stencil = f.stencil; //passed stencil, revert to value from framebuffer
    }
    
    
    //depth test
    if (state.depth_test != DEPTH_TEST_DISABLED)
    {

        //actual depth testing
        if(state.stencil_func != STENCIL_FUNC_NONE)
        {
            //in case depth fails, write stencil value
        	final.stencil = evaluate_stencil_operation(state.sfunc_dpfail,f.stencil,state.stencil_ref_value);
        }
        
        if(state.depth_func == DEPTH_FUNC_LESS)
        {
            if(vs_output.depth > f.depth)
                return final;//depth test failed, return original framebuffer
        }
        else if(state.depth_func == DEPTH_FUNC_EQUAL)
        {
            if(abs(vs_output.depth - f.depth) > 0.001)
                return final;//depth test failed, return original framebuffer
        }
        else
        {
            final.valid = 0.0;//invalid state
        }
        
        //depth test passed, write stencil value
        if(state.stencil_func != STENCIL_FUNC_NONE)
        	final.stencil = evaluate_stencil_operation(state.sfunc_dppass,f.stencil,state.stencil_ref_value);
        
        //write depth 
        if(state.depth_test == DEPTH_TEST_ENABLED_NO_WRITE)
        {
            //no need wo rite it again
            //final.depth = f.depth;
        }
        else if(state.depth_test == DEPTH_TEST_ENABLED)
        {
            final.depth = vs_output.depth;
        }
        else
        {
            final.valid = 0.0;//invalid state
        }
    }
    
    //move on to blending
    if(state.blend_func == BLEND_FUNC_OFF)
    {
        final.color = mix(f.color,fs_output,state.color_mask);
    }
    else if(state.blend_func == BLEND_FUNC_ADD)
    {
        vec4 src_base = evaluate_blend_operation(state.src_blend,fs_output,fs_output,f.color);
        vec4 dst_base = evaluate_blend_operation(state.dst_blend,f.color,fs_output,f.color);
        
        final.color = mix(f.color,dst_base + src_base,state.color_mask);
    }
    else
    {
         final.valid = 0.0;//invalid state
    }
        
    return final;
}

// Function 1170
bool isInRect(vec2 pos) {
    return	pos.x > -hw * 3.0 && pos.x < hw * 3.0 &&
    		pos.y > hh - 40.0 && pos.y < hh + 40.0;
}

// Function 1171
float Lines(vec2 uv,float t){
    vec2 a,b,g,f;
    float d;
    for (float i=0.;i<1.;i+=0.09){
        float y1,y2;
        vec2 nowPos1= vec2(i,-0.7);
        y1=N21(nowPos1)-0.5;
        vec2 nowPos2= vec2(i,0.7);
        y2=N21(nowPos2)-0.5;
        a=vec2(-0.5+floor(i*3.)*0.1,fract((y1-i*t)/2.)-0.5);
        b=vec2(0.5-floor(i*3.)*0.1,fract((y2-i*t)/2.)-0.5);
        g=vec2(-1.,3.*(fract((y1-i*t)/2.)-0.5));
        f=vec2(1.,(fract((y2-i*t)/2.)-0.5)*3.);
        d+=i*S(0.02*(abs(uv.x)+0.2),0.00,LineDistance(a,b,uv));
        d+=i*S(0.07*(abs(uv.x)),0.00,LineDistance(a,g,uv));
        //d+=i*S(0.08*(abs(uv.x)+0.2),0.01,LineDistance(a-0.2,a-0.1,uv));
        d+=i*S(0.07*(abs(uv.x)),0.00,LineDistance(b,f,uv));
        }
    
    d+=S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(0.3+0.04*sin(8.*t),1.0),vec2(0.25+0.01*cos(2.*t),-1.),uv));
    d+=0.7*S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(0.35+0.04*sin(5.*t),1.0),vec2(0.4+0.04*cos(1.*t),-1.),uv));
    d+=0.8*S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(0.4+0.04*sin(1.*t),1.0),vec2(0.45+0.04*cos(8.*t),-1.),uv));
    d+=0.7*S(0.06*(abs(uv.x)),0.00,LineDistance(vec2(0.4,1.0),vec2(0.45,-1.),uv));
    d+=0.7*S(0.06*(abs(uv.x)),0.00,LineDistance(vec2(-0.4,1.0),vec2(-0.45,-1.),uv));
    
    
    d+=.9*S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(-0.3-0.01*sin(8.*t),1.0),vec2(-0.4-0.04*cos(2.*t),-1.),uv));
    d+=.8*S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(-0.35-0.04*sin(5.*t),1.0),vec2(-0.4-0.01*cos(1.*t),-1.),uv));
    d+=S(0.001*(abs(uv.x)),0.00,LineDistance(vec2(-0.4-0.01*sin(1.*t),1.0),vec2(-0.45-0.04*cos(8.*t),-1.),uv));
	return d;
    
}

// Function 1172
float line(vec3 p, vec3 q) {
  return abs(dot(p,q)/(p.z*length(q.xy)));
}

// Function 1173
float drawMagician(vec2 uv) {
	float color = .0;
    uv.x *= -sign(uv.y); 
    vec2 offset = vec2(.3,0);
    float left = circleSDF(uv+offset);
    float right = circleSDF(uv-offset);
    color += stroke(left,.4,.05);
    return bridge(color, right,.4,0.05);
}

// Function 1174
float inRect(vec2 pos, vec2 topLeft, vec2 rightBottom) {
	return step(topLeft.x, pos.x) * step(rightBottom.y, pos.y) * step(-rightBottom.x, -pos.x) * step(-topLeft.y, -pos.y);
}

// Function 1175
maybe_float get_distance_along_3d_line_nearest_to_line(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B
){
    vec3 D = B0 - A0;
    // offset
    vec3 C = normalize(cross(B, A));
    // cross
    vec3 R = D - dot(D, A) * A - dot(D, C) * C;
    // rejection
    return maybe_float(
        length(R) / -dot(B, normalize(R)), 
        abs(abs(dot(A, B)) - 1.f) > 0.f
    );
}

// Function 1176
vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {
    
    vec2 diff = center-uv;
    float len = length(diff);

    len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);
    len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);
    
    float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);
    return vec3(circle);
}

// Function 1177
vec4 scanLine(float uv, float resolution, float opacity) {
     float intensity = sin(uv * resolution * PI * 2.);
     intensity = ((.5 * intensity) + .5) * .9 + .1;
     return vec4(vec3(pow(intensity, opacity)), 1.);
}

// Function 1178
void set_line_width_px(float w) {
    _stack.line_width = w*_stack.scale/AA;
}

// Function 1179
float draw_char(vec2 p, vec2 char_position){
    vec2 uv = (gl_FragCoord.xy - p)/vec2(DIGIT_WIDTH, DIGIT_HEIGHT);
    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0){
        return texture(iChannel3, (uv + char_position)/16.0).r;
    }
    return 0.0;
}

// Function 1180
float mixLine(float light, vec2 p, vec2 a, vec2 b, float d0) {
    vec2 pa = p - a;
    float lineMask = smoothstep(
         0.02, 0.0,
         line(p, a, b)
     );
    return light + lineMask * 0.03;
    
}

// Function 1181
vec2 rectvoronoi(in vec3 x, RSet3 r1, RSet3 r2, RSet3 r3) {
    ivec3 p = ivec3(floor( x ));
    vec3 f = fract( x );

    ivec3 mb;
    vec3 mr;
    float id = 1.0e20;
    const int range = 3;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = ivec3( i, j, k );
        vec3 B = vec3(p + b);
        //vec3 rv = rand3(B, d, s );
        vec3 rv = rvec3(B, r1, r2, r3);
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = length( r );

        if(dis < id) {
            mb = b;
            mr = r;
            id = dis;
        }
    }
    float bd = 1.0e20;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = mb + ivec3( i, j, k );
        vec3 B = vec3(p + b);
        //vec3 rv = rand3(B, d, s );
        vec3 rv = rvec3(B, r1, r2, r3);
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = dot( 0.5*(mr+r), normalize(r-mr) );

        bd = min(bd, dis);
    }
    return vec2(id, bd);
}

// Function 1182
float isGridLine(vec2 p, vec2 v) {
    vec2 k = smoothstep(.1,.9,abs(mod(p+v*.5, v)-v*.5)/.08);
    return k.x * k.y;
}

// Function 1183
float rectangle(vec2 pos, vec2 size)
{
  size *= 0.5;
  vec2 r = abs(uv - pos - size) - size;
  return step( max(r.x,r.y),0.0);
}

// Function 1184
vec2 rectvoronoi(in vec3 x, RTriplet3 trip) {
    ivec3 p = ivec3(floor( x ));
    vec3 f = fract( x );

    ivec3 mb;
    vec3 mr;
    float id = 1.0e20;
    const int range = 3;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = ivec3( i, j, k );
        vec3 B = vec3(p + b);
        //vec3 rv = rand3(B, d, s );
        vec3 rv = rvec3(B, trip);
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = length( r );

        if(dis < id) {
            mb = b;
            mr = r;
            id = dis;
        }
    }
    float bd = 1.0e20;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = mb + ivec3( i, j, k );
        vec3 B = vec3(p + b);
        //vec3 rv = rand3(B, d, s );
        vec3 rv = rvec3(B, trip);
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = dot( 0.5*(mr+r), normalize(r-mr) );

        bd = min(bd, dis);
    }
    return vec2(id, bd);
}

// Function 1185
vec3 Spline_Evaluate(mat4 MG, float t )
{
	vec4 tvec = vec4(t*t*t, t*t, t, 1.);	
	vec3 p = (MG*tvec).xyz;
	return p;
}

// Function 1186
vec3 indirectDiffuseCast(in Ray ray, inout int seed)
{
    vec3 pos;
    vec3 norm;
    Material mat;
    
    //return vec3(nextFloat(seed));
    
    vec3 color = vec3(1.0);
    vec3 emitted = vec3(0);
    Ray traceRay = ray;
    for (int i = 0; i < depth; i++)
    {
        bool intersected = raytraceScene(traceRay, pos, norm, mat);
    
    	if (!intersected) return vec3(0);
    	if (mat.emissive) return emitted;// + mat.albedo * dot(norm, traceRay.direction);
    
    	mat3 coordSys = createCoordinateSystem(norm);
        int s = seed;
    	vec3 smpl = randomSample(coordSys, seed);
    	color *= mat.albedo ;
        
        vec3 pointInSource = vec3(nextFloat(seed), 0.0, nextFloat(seed)) * vec3(2.0*WIDTH,0,2.0*WIDTH) + vec3(-WIDTH,HEIGHT,-WIDTH);
        vec3 L = pointInSource - pos;
        float rr = dot(L, L);
        L = normalize(L);

        Ray shadowRay = Ray(pos + L * BIAS, L);
        if (L.y > BIAS && dot(norm, L) > 0. && !shadowHit(shadowRay)) {
	        const float area = (WIDTH*WIDTH*4.0);
            float weight = area * L.y * dot(norm, L) / (3.14 * rr);
            emitted += color * materials[0].albedo * weight;
        }
        
        traceRay = Ray(pos + smpl * BIAS, smpl);
    }
    
    return emitted;
}

// Function 1187
MarchingResult LineSegment(vec3 p, vec3 a, vec3 b, int index)
{
    MarchingResult o;
	vec3 ab = b - a;
	float t = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);
	o.distance = length((ab*t + a) - p);
    o.index = index;
    return o;
}

// Function 1188
vec4 circle(vec2 pos) {
    if (length(pos) < 0.08) {
        return vec4(0, 0, 1, 0.5); // semitransparent
    } else {
        return vec4(0,0,0,0);
    }
}

// Function 1189
float sdLine( vec2 pos, vec2 p1, vec2 p2, float crop )
{
    float l=length(p2-p1);
  	if(l<.001) return 100000.;
    vec2 t=(p2-p1)/l;
    // crop a little from the ends, so subsequent segments will blend together well
    l-=crop;
    p2-=t*crop*.5;
    p1+=t*crop*.5;
  	float pp = dot(pos-p1,t);
  	float pn = dot(pos-p1,t.yx*vec2(1,-1));
  	return max(max(pp-l,-pp),abs(pn));
}

// Function 1190
float circlesegment(vec2 x, float r, float p0, float p1)
{
    float p = atan(x.y, x.x);
    vec2 philo = vec2(max(p0, p1), min(p0, p1));
    if((p < philo.x && p > philo.y) || (p+2.*pi < philo.x && p+2.*pi > philo.y) || (p-2.*pi < philo.x && p-2.*pi > philo.y))
    	return abs(length(x)-r);
    return min(
        length(x-r*vec2(cos(p0), sin(p0))),
        length(x-r*vec2(cos(p1), sin(p1)))
        );
}

// Function 1191
SceneResult Scene_PipelineSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    
    SceneResult resultFloor;
    
    resultFloor.fDist = vPos.y;
    resultFloor.vUVW = vec3(vPos.zxy * 0.1);
    resultFloor.iObjectId = MAT_GRASS;

    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );
    
    
    float fRepeat = 5.0;
    float fOffset = fRepeat / 2.0;
    vec3 vPosRepeat = vPos;
    vPosRepeat.x = fract((vPosRepeat.x + fOffset) / fRepeat) * fRepeat - fOffset;
    
    
    vec3 vSphDomain = vPosRepeat;
    
    SceneResult pipeResult;
    
    vec3 vPipePos =  vSphDomain - vec3(0,1,0);
    
    float fAng = atan( vPipePos.x, vPipePos.y );
    
    pipeResult.fDist = length(vPipePos.xy) - 1.0;
    pipeResult.vUVW = vec3(vPos);
    pipeResult.vUVW.x = fAng;
    pipeResult.vUVW.y = vPos.z * 0.1;
    pipeResult.iObjectId = MAT_PIPE;
    
	SceneResult_Combine( resultInside, resultOutside, pipeResult, insideObjId );        
    
    
    {
        vec3 vPosRepeat2 = vPosRepeat;
        
    
    	float fRepeat = 4.0;
    	float fOffset = fRepeat / 2.0;
    	vec3 vPosRepeat = vPos;
    	vPosRepeat2.z = fract((vPosRepeat2.z + fOffset) / fRepeat) * fRepeat - fOffset;        
        
        
        vec3 vDiskPos =  vPosRepeat2 - vec3(0,1,0);
    	SceneResult diskResult;
        
        diskResult.fDist = length(vDiskPos.xy) - 1.2;
        diskResult.fDist = max( diskResult.fDist, vDiskPos.z - 0.1);
        diskResult.fDist = max( diskResult.fDist, -vDiskPos.z - 0.1);
        //pipeResult.fDist = min( pipeResult.fDist, -(vPosRepeat2.z -0.1) );
        //pipeResult.fDist = min( pipeResult.fDist, -0.1 );
        diskResult.vUVW = vec3(vPos);
    	//diskResult.vUVW.x = fAng * 0.01 + 0.3;
        diskResult.vUVW.x = fAng * 0.5 + 0.3;
    	diskResult.vUVW.y = vDiskPos.z + 0.9 + length( vDiskPos.xy); 
        
        diskResult.iObjectId = MAT_PIPE;

        SceneResult_Combine( resultInside, resultOutside, diskResult, insideObjId );        
         
    }
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 1192
vec3 ACEScc_from_Linear(vec3 lin) 
{
    return vec3(ACEScc_from_Linear(lin.r),
                ACEScc_from_Linear(lin.g),
                ACEScc_from_Linear(lin.b));
}

// Function 1193
float disttoline(vec2 a, vec2 b, vec2 p) {
 	return abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) 
        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   
}

// Function 1194
float dRoundline(vec3 p,vec3 a,vec3 b,float r){p-=a;b-=a;
 float h=sat(dot(p,b)/dd(b));return length(p-b*h)-r;}

// Function 1195
bool drawWave(in float amplitude, in float frequency, in float phase, in float height, in vec2 pixCoords)
{
    // Does some simple math
    float wavePos = amplitude * sin((pixCoords.x + phase * iTime) * frequency) + height;
    
    return (pixCoords.y < wavePos);
}

// Function 1196
void drawCoin( inout vec3 color, vec2 p, vec2 coinPos )
{  
    float sCoin = length(
        p
        -vec2( 0.0, coinPos.y )	// cell pos
        +vec2( 0.5, -0.5 )		// move to cell center
        -vec2( coinPos.x, 0.0 ) // move to column
    ) - 0.25; 					// radius of coin

    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );
}

// Function 1197
vec2 toRectCoords(vec2 polar)
{
    float x = polar.x * cos(polar.y);
    float y = polar.x * sin(polar.y);
    
    return vec2(x,y);
}

// Function 1198
DrawContext DrawContext_Init( vec2 vUV, vec3 vClearColor )
{
    vec2 vWidth = fwidth( vUV );
    
    float fEdgeFade = 1.0 / max(abs(vWidth.x), abs(vWidth.y));
    return DrawContext( vUV, vClearColor, fEdgeFade );
}

// Function 1199
float Line(vec2 uv, vec2 a, vec2 b) 
{
    float t = clamp(dot(uv-a, b-a) / dot(b-a, b-a), 0.0, 1.0);
    return length(uv - a - (b-a) * t);
}

// Function 1200
float sdf_line3(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AB = vert_A - vert_B;
    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.
    uv = rotate_2D(angle) * uv;  //  Rotate vertex `uv` by `angle`
    return -uv.y;  // Signed distance!
    // return abs(uv.y);  // Unsigned distance!
}

// Function 1201
vec2 ML_GetRect(vec2 coord, vec4 rect){
    return vec2((coord.x - rect.x) / rect.z, (coord.y - rect.y) / rect.w);
}

// Function 1202
circleOverlap_t circleOverlap(float r1,float r2,float d)
{
	circleOverlap_t r;
	if (r1+r2<=d) //Circles do not overlap at all
		{r.f1=0.0; r.f2=0.0;}
	else if (d+r2<=r1) //Circle 2 entirely in circle 1
		{r.f1=r2*r2/(r1*r1); r.f2=1.0;}
	else if (d+r1<=r2) //Circle 1 entirely in circle 2
		{r.f1=1.0; r.f2=r1*r1/(r2*r2);}
	else {
	//Circles partially overlap, creating a crescent shape
	//Compute the area of the circles
		float pi=3.14159265358979;
		float area1=r1*r1*pi;
		float area2=r2*r2*pi;
	//Compute area of overlap region
		float alpha=(r1*r1+d*d-r2*r2)/(2.0*d);
		float beta=d-alpha;
		float area_overlap=r1*r1*circleSliceArea(alpha/r1)+
		                  r2*r2*circleSliceArea(beta/r2);
		r.f1=area_overlap/area1;
		r.f2=area_overlap/area2;
	}
	return r;
}

// Function 1203
float sdfCircle(vec2 p) {
    return length(p) - 1.0;
}

// Function 1204
void
camera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,
                       out vec3 camera_pos )
{
    const int obj_count = 3;

    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );

    //u = 1.0;

    float pu = 1.0 / float(obj_count-1);
    float pt = 0.0;
    vec3 p = vec3(0.0);
    for ( int i = 0; i!=obj_count; ++i )
    {
        float s = pu * ( -0.5 + float(i) );
        p +=
           ( start + obj_dist * float(i) ) *
           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );
    }
    camera_pos.xyz = p;
}

// Function 1205
float drawC(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  bool onCir = isIn(length(uv), cMin, cMax);
  float valA = float(onCir && uv.x > 0.0 && !isIn(uv.y, -cthick, cthick) ||
    uv.x <= 0.0 && onCir);

  return valA;
}

// Function 1206
float dLine(vec3 p, vec3 p1, vec3 p2) { return dDirLine(p,p1,normalize(p2-p1),length(p2-p1)); }

// Function 1207
float drawLine (vec2 p1, vec2 p2, vec2 uv, float a)
{
    float r = 0.;
    float one_px = 1. / iResolution.x; //not really one px
    
    // get dist between points
    float d = distance(p1, p2);
    
    // get dist between current pixel and p1
    float duv = distance(p1, uv);

    //if point is on line, according to dist, it should match current uv 
    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));
        
    return r;
}

// Function 1208
float gridlines(vec3 p) {
    float Z = p.z;
    float th = 0.3;
    p /= p.z;
    
    vec2 l = mod( p.xy, th );
    
    l = vec2(l.x > 0.5*th ? th - l.x : l.x,
             l.y > 0.5*th ? th - l.y : l.y);

    float z = 1.0-smoothstep(0.0, 0.08*th, l.x);
    float w = 1.0-smoothstep(0.0, 0.08*th, l.y);
    
    return pow(min(max(z,w), clamp(Z, 0.0, 1.0)), 2.0);
}

// Function 1209
vec4 line(vec2 uv, float angle, float d3, float margin) {
    vec2 diag = rot(PI-angle)*uv;
    float mdiag = (diag.y+margin*d3)*3.;
    vec4 w;
    w.rgb = vec3(.8,.6,.2);
    w.a = gate(margin*d3,margin*d3*2.,-uv.y)*5.;
    w.a = max(w.a, mdiag*2.)*1.5;
    return w;
}

// Function 1210
float growingCircle( in float offset, in float thickness, in vec2 pos, in float speed, in float repeatAtTime, in float cellSize) {
    float circle_size = mod(iTime * speed, repeatAtTime) - offset;
    float radius = length(floor((pos + cellSize / 2.) / cellSize) * cellSize);
    
    return smoothstep(circle_size + thickness / 2., circle_size, radius) -
           smoothstep(circle_size, circle_size - thickness / 2., radius);
}

// Function 1211
float boxLine( vec3 point, float z ) {
    
    float bsize = 0.9;
    
    vec3 box = vec3(0., bsize, z);
    
    float dist = sdBox(box, point, vec3(bsize));
    
    for( float i = 1.; i < 3.; i++ ) {
        vec3 npos = vec3(box.x + i*2.*(bsize+0.35), box.y, box.z);
        float newBox = sdBox(npos, point, vec3(bsize));
        dist = min(dist, newBox);
    }
    
    return dist;
}

// Function 1212
float RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)
{
	// AA version based on distance to line
	
	// vPixel is the co-ordinate within the pixel to be rasterized
	
	vec2 vAB = vB - vA;	
	vec2 vAP = vPixel - vA;
	
	vec2 vDir = normalize(vAB);
	float fLength = length(vAB);
	
	float t = clamp(dot(vDir, vAP), 0.0, fLength);
	vec2 vClosest = vA + t * vDir;
	
	float fDistToClosest = 1.0 - (length(vClosest - vPixel) / kAALineWidth);

	float i =  clamp(fDistToClosest, 0.0, 1.0);
	
	return sqrt(i);
}

// Function 1213
vec4 drawGrassQuad(vec2 uv) {
	// swayUnsync and sway could be computed in vertex shader.
    float swayUnsync = 0.;
    float sway = uv.y * uv.y * sin(swayFrequency * iTime + swayUnsync) * swayAmplitude;
        
    float transformedX = clamp(uv.x + sway, 0., 1.); // clamp is for using with texture atlas

    vec4 col = texture(iChannel0, vec2(transformedX, uv.y));

    if (col.a < 0.1) discard; // could be attenuated with vViewPosition.z 
 	
    return vec4(col.rgb, 1.);
}

// Function 1214
float lineMask(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float r, float maxt)
{
    vec3 t = closestPointsOnLines(ro, rd, pa, pb - pa);

    vec3 lp = mix(pa, pb, clamp(t.y, 0., 1.));

    return step(distance(ro + rd * t.x, lp), r) * step(t.x, maxt);
}

// Function 1215
bool circle(in float r, in vec2 o, in vec2 v)
{
    return (length(o - v) <= r) ? true : false;
}

// Function 1216
vec3 draw(vec3 p, float d, vec3 rd){
    //the color to return
    vec3 col = vec3(0.);
    
    //light
    float b = bii;
    
    //rays to hit/draw
    vec3 ray, cubeRay;
    
    //if d < max distance...so if we want to draw it.
	if (d<maxd)
	{  
		vec2 e = vec2(-1., 1.)*0.005; 
		vec3 n = calcNormal(p, 0.1);

        //light
		b=li;
		
        //reflection
		ray = reflect(rd, n);
        cubeRay = texture(iChannel0, ray).rgb  * refl_i ;
        
		//refraction
		ray = refract(ray, n, refr_a);
		cubeRay += texture(iChannel0, ray).rgb * refr_i;

		col = cubeRay+pow(b,15.); 
            
        // lighting        
		float occ = calcAO( p, n );
		vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );
		float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );
		float dif = clamp( dot( n, lig ), 0.0, 1.0 );
		float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);
		float dom = smoothstep( -0.1, 0.1, cubeRay.y );
		float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );
		float spe = pow(clamp( dot( cubeRay, lig ), 0.0, 1.0 ),16.0);

		vec3 brdf = vec3(1.0);
		brdf += 4.20 * dif*vec3(1.00,0.90,0.60);
		brdf += .1 * spe*vec3(1.00,0.90,0.60)*dif;
		brdf += 0.30 * amb*vec3(0.50,0.70,1.00)*occ;
		brdf += 0.40 * dom*vec3(0.50,0.70,1.00)*occ;
		brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
		brdf += 0.1*fre*vec3(1.00,1.00,1.00)*occ;
		brdf += 0.02;
		col = col*brdf;

		//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*d*d ) );

		//col = mix(col, vec3(map(p)), 0.5) + tintPulse(tint);

	}
    //background
	else
	{
		//col = texture(iChannel0, rd).rgb * 1.00;
	}
    return col;
}

// Function 1217
vec2 lineOnCircleInt(vec2 C, float r, vec2 p1_on_C, vec2 p2) {
    // solve length(p1 + t(p2-p1) - C) = r for t
    // d = p2 - p1
    // q = p1 - C
    // length(td+q) = r
    // (td + q).(td + q) = r*r
    // tt*d.d + t*2d.q + q.q - r*r = 0
    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r
    vec2 d = p2 - p1_on_C;
    vec2 q = p1_on_C - C;
    float a = dot(d, d); // cannot be negative
    float b = 2. * dot(d, q); // can be negative
    float c = dot(q, q) - r*r; // probably zero. always zero?
    // x = (-b +- sqrt(b*b - 4ac)) / 2a
    // since one point is on line, discrim must be >= 0
    float discrim = max(0., b * b - 4. * a * c);
    //discrim = sqrt(discrim);
    discrim = b;
    float t1 = ( -b - discrim ) / (2. * a);
    float t2 = ( -b + discrim ) / (2. * a);
    //vec2 a1 = p1_on_C + t1 * d;
    //vec2 a2 = p1_on_C + t2 * d;
    //float d1 = dot(a1-p2, a1-p2);
    //float d2 = dot(a2-p2, a2-p2);
    //if (d1 > d2) return a1;
    //return a2;
    float t = t1;
    //if (t2 > t1) t = t2; // answer should be the one closest to p2
    return p1_on_C + t * d;
}

// Function 1218
bool lineCheck( float bound, float bound2, float lineW )
{   
    return (bound > (bound2-(lineW*0.75)) && bound < (bound2+(lineW*0.75))) ? true : false;
}

// Function 1219
float ACEScct_from_Linear(float lin)
{
    if(lin > 0.0078125)
        return log2(lin) / 17.52 + (9.72/17.52);
    
	return lin * 10.5402377416545 + 0.0729055341958355;
}

// Function 1220
vec3 GetDirectionalLightSourcePosition ()
{
    // mode >= 5.0 starts moving and rotating light source
    float time = GetMode() - 5.0;
    time = max(time, 0.0);
    float canMove = step(5.0, GetMode());

    vec3 ret = directionalLightSourcePosition;
    
    ret += vec3(sin(time * 0.83) + 1.0 * canMove, sin(time * 1.1), sin(time * 0.1));
    
    return ret;
}

// Function 1221
vec4 draw_ui(vec2 fc){
    vec2 uv=fc/iResolution.y-res;
    vec3 col=vec3(0.);
    bool is_nuion=loadval(ivec2(1,0)).x<=0.;
    float a=0.;
    if(is_nuion){
    if(is_scrolly(uv)){
        float scp=loadval(ivec2(0,0)).w;
        if((uv.y+res.y<scp+0.05)&&(uv.y+res.y>scp-0.05))
            col=whitel*0.5;
        else
            col=whitel;
        a=0.68;
    }
    else
    if(is_scrollx(uv)){
        float scp=loadval(ivec2(0,0)).z;
        if((uv.x+res.x<scp+0.05)&&(uv.x+res.x>scp-0.05))
            col=whitel*0.5;
        else
            col=whitel;
        a=0.68;
    }}
    
    if(is_nuion)
    if(uv.y>0.3){
        float d=text_z((uv+vec2(0.47817*(res.x/0.5),-0.40))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_s((uv+vec2(0.19689*(res.x/0.5),-0.40))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_g((uv+vec2(-0.28127*(res.x/0.5),-0.40))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_t((uv+vec2(0.11251*(res.x/0.5),-0.30))*13.);
        col+=whitel*d;
        a=max(a,d);
        if((uv.x>0.0562*(res.x/0.5))&&(uv.x<0.28127*(res.x/0.5))&&(uv.y<0.4))
        {
            float max_pos=abs(loadval(ivec2(1,0)).x);
            float max_posy=abs(loadval(ivec2(1,0)).y);
            d=print_int((uv+vec2(-0.19689*(res.x/0.5),-0.30))*13.,int(max_pos/SSIZE)*int(max_posy*H/2.)/2);
            col+=whitel*d;
            a=max(a,d);
        }
    }
    
    if(is_nuion)
    if((uv.x>0.0562*(res.x/0.5))&&(uv.y>-0.1)){
        float d=text_m((uv+vec2(-0.28127*(res.x/0.5),-0.10))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_n((uv+vec2(-0.3094*(res.x/0.5),-0.03))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_f((uv+vec2(-0.3094*(res.x/0.5),0.03))*13.);
        col+=whitel*d;
        a=max(a,d);
        d=text_ms((uv+vec2(-0.3094*(res.x/0.5),0.09))*13.);
        col+=whitel*d;
        a=max(a,d);
        int sid=int(loadval(ivec2(1,1)).w);
        if(sid==0)
            if(is_n(uv)){
                d=.8;
                col+=green;
                a=max(a,d);
            }
        if(sid==1)
            if(is_f(uv)){
                d=.8;
                col+=green;
                a=max(a,d);
            }
        if(sid==2)
            if(is_s(uv)){
                d=.8;
                col+=green;
                a=max(a,d);
            }
    }
    
    if(is_reset(uv)&&is_nuion)
    {
        float d=1.;
        col+=redd*d;
        a=max(a,d*0.75);
        d=text_r((uv+vec2(-0.3094*(res.x/0.5),0.34))*13.);
        col+=whitel*d;
        a=max(a,d);
    }
    
    if(is_clean(uv)&&is_nuion)
    {
        float d=1.;
        col+=darkb*d;
        a=max(a,d*0.75);
        d=text_c((uv+vec2(-0.3094*(res.x/0.5),0.24))*13.);
        col+=whitel*d;
        a=max(a,d);
    }
    
    if(is_grav(uv))
    {
        vec2 gravity=loadval(ivec2(0,1)).xy;
        float d=1.;
        col=vec3(0.);
        a=max(a,d*(0.6-(is_nuion?0.:0.3)));
        d=draw_grav_w((uv-vec2(0.3937*(res.x/0.5),0.28))*7.5,gravity);
        col=whitel*d;
        a=max(a,d);
    }
    
    if(is_zoom(uv))
    {
        float state=loadval(ivec2(0,0)).x*0.15*2.;
        float d=1.-(is_nuion?0.:0.3);
        col=vec3(0.);
        if(abs(uv.x+0.26994*(res.x/0.5)-state+0.15-0.007)>0.015)
            col=whitel*d;
        else
            col=whitel*0.5;
        a=max(a,d*0.68);
    }
    
    if(is_speed(uv))
    {
        float state=loadval(ivec2(0,0)).y*0.15*2.;
        float d=1.-(is_nuion?0.:0.3);
        col=vec3(0.);
        if(abs(uv.x-0.16994*(res.x/0.5)-state+0.15-0.007)>0.015)
            col=whitel*d;
        else
            col=whitel*0.5;
        a=max(a,d*0.68);
    }
    
    if(is_nui(uv))
    {
        float d=1.-(is_nuion?0.:0.3);
        col+=darkb*d;
        a=max(a,d*0.75);
        d=text_nui((uv+vec2(-0.3094*(res.x/0.5),0.44))*13.);
        col+=whitel*d;
        a=max(a,d);
    }
    
    if(is_floor(uv)&&is_nuion)
    {
        float d=1.;
        if(loadval(ivec2(0,1)).w>=0.)col+=green*d;
        a=max(a,d*0.75);
        d=text_floor((uv+vec2(-0.324*(res.x/0.5),0.13))*18.);
        col+=whitel*d;
        a=max(a,d);
    }
    if(is_floor2(uv)&&is_nuion)
    {
        float d=1.;
        if(loadval(ivec2(0,1)).w<0.)col+=green*d;
        a=max(a,d*0.75);
        d=text_floor2((uv+vec2(-0.324*(res.x/0.5),0.168))*18.);
        col+=whitel*d;
        a=max(a,d);
    }
    
    
    col=clamp(col,0.,1.);
    //a=dot(col,vec3(1.))/3.;
    return vec4(col,a);
}

// Function 1222
vec2 calcLineDist(vec3 pos, vec3 v)
{
    vec2 rval;
    rval.x = dot(pos,v)/dot(v,v);
    rval.y = length(pos-rval.x*v);
    return rval;
}

// Function 1223
vec4 drawParticules(inout vec4 c, sampler2D iChannel0,  vec2 fragCoord, vec2 iResolution, vec4 iMouse){
	vec2 ar = vec2( iResolution.x/ iResolution.y, 1.);
  
    vec2 r = iResolution.xy;
    vec2 uv = fragCoord / iResolution.xy;
    vec2 a = vec2( iResolution.x/ iResolution.y, 1.);
    vec2 p = (uv-.5);
	
    vec2 pmed = components[ 8].value.zw;
    vec2 pmin = components[ 9].value.zw;
    vec2 pmax = components[10].value.zw;
    
    float s = clamp(sqrt(sqrt(components[8].value.x- components[10].value.x)), 1.,6.); 
    p *= s;
    
    p = p * a;
    for (int j = 0; j < SY; j++)
        for (int i = 0; i < SX; i++)
        {
            vec4 pos = textureBase( iChannel0, ivec2(i,j));
            c = mix(c, vec4(s/20.), smoothstep(0.,0.001,.01-length(p-pos.xy)));
        }
    return c;
}

// Function 1224
vec3 Draw(vec2 p, float rnd)
{
	State state;
	vec2 R = iResolution.xy;
	ivec2 i = ivec2(p);
	LoadState(state, BufA, ivec2(R));
    SetupTime(iTime);
//	if (abs(distance(p, abs(state.mouse)) - 5.) < 2.) return vec3(0,1,0); // DEBUG state.mouse
    // to signed aspect correct uv given screen pixel and resolution - aka StoQ
	vec2 q = (p + p - R) / R.y;
	mat3 view = Camera(state.eyeaim);
	float hfovy = radians(30.) //tau/12. //
	//, blur = 2. // pixels ??!
	, foclen = 1.
	, focus = .99998 //cos(hfovy * blur/iResolution.y) //
	;
	int ss = SSAA + IZERO;
    ss = max(1, int(float(ss) * min(1., 720. / R.y) + .5));
    //ss /= int(log2(R.y)/log2(512.)) + 2;
	//ss -= int(R.y/240.); // scale with resolution
	ss = max(ss, 1);
    //return vec3(state.eyeaim * .5 + .5,0);
    //return vec3(state.aimbase * .5 + .0,0);
    //return vec3(state.mbdown ? 1. : 0.);
	//if (iTimeDelta >= .034) ss = 1;
	return RenderSS(state.eyepos, q, view
	  , hfovy, ss, focus, foclen, rnd);
}

// Function 1225
vec2 Support_VertLine (float size, vec2 dir)
{
    return vec2(0.0,sign_(dir.y)*size);
}

// Function 1226
float line(vec4 ray, vec3 u, float size
){maxGISize = max(maxGISize,size*ray.w)
 ;ray.xyz = abs(ray.xyz-u) - size
 ;return ray.w*max(ray.z,ray.y);}

// Function 1227
vec3 DrawSmoothstep(vec2 uv){
	uv+=0.5;
	float val = smoothstep(0.0,1.0,uv.x);
	val = step(abs(val-uv.y),0.01); 
	return vec3(val,val,val);
}

// Function 1228
vec3 direct_blur(sampler2D tex, vec2 uv, vec2 d, int k)
{
    vec2 s = 1.0 / vec2(textureSize(tex, 0));
    d *= s;
    vec2 b = -0.5 * d * float(k - 1);
    vec3 avg = vec3(0.0);
    for(int x = 0; x < k; x++)
        avg += texture(tex, uv + b + d * float(x) * 2.0).rgb;
    return avg / float(k);
}

// Function 1229
void drawExplosion(float t, out vec4 fragColor){
    // draw circle.
    float r = t * EXPLOSION_RADIUS / (TIME_PHASE2 - TIME_PHASE1); 
    vec2 o = vec2(explosionX, explosionY);
    float d = distance(uv, o);
    if(d <= EXPLOSION_RADIUS && d > r){
    	fragColor = EXPLOSION_COLOR;
    }
    
    // draw squares.
    int i;
    for(i = 0; i < SQUARE_COUNT; ++i){
    	if(abs(uv.x - square[i].x) <= square[i].z && 
           abs(uv.y - square[i].y) <= square[i].z){
    		fragColor = EXPLOSION_SQUARE_COLOR;
        }
    }
}

// Function 1230
float stripesCircle3(vec2 uv, float distorsion) {
    return stripesCircle(uv, StripesCircleOpt(.45, .9, 7.5, -.03, 57.3), StripesOpt(distorsion, 0., 1.));
}

// Function 1231
float mandelRect(vec2 p, vec2 center, vec2 size) {
    vec2 hs = size / 2.;
    p -= center;
    vec2 c = (p / hs - vec2(0.5, 0)) * 1.2;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
    vec2 z = vec2(0);
    for(int i = 0 ; i < 256; i++){
    	z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
        if( dot(z, z) > 4.0 ){
        	return 1000.;
        }
    }
    return -1.;
    
}

// Function 1232
vec2 line(vec3 pos, vec3 a, vec3 b) {
	vec3 pa = pos - a;
	vec3 ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
	return vec2(length(pa - h * ba), h);
}

// Function 1233
vec3 desiredDirection() 
{
    return loadValue(BufferC, slotDesiredForward).xyz;
}

// Function 1234
float circleTriangle(vec2 pos){
    float circle = length(pos * 0.5);
    float triangle = triangleLength(pos * 0.3);    
    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);
}

// Function 1235
float toLinear1(float c) {
	return (c <= 0.04045) ?
		(c / 12.92) :
		pow((c + 0.055) / 1.055, 2.4);
}

// Function 1236
void drawFlames()
{
    float 
        x = abs(0.5 - gFrag.uv.x) * FX_FLAME_DAMP,
        y = abs(GROUND_HEIGHT - gFrag.uv.y),
        fft = GetSndVal(x, FFT_FTCH) * FFT_AMP;
    
    fft -= y;
#ifdef PROACTIVE
    fft *= (exp((fft - FFT_THRESHOLD) * (fft * 20.)) / FFT_DAMP) - (exp(0.) / FFT_DAMP);
#else
    fft *= (exp((fft - FFT_THRESHOLD) * 9.5) / FFT_DAMP) - (exp(0.) / FFT_DAMP);
#endif
    
    fft *= 1. - x * 1.5;

    vec3 baseColor, auxColor;
    getColor(baseColor, auxColor);
    
    gFrag.c.rgb = baseColor * fft;
    y *= 2. * (gFrag.uv.y > GROUND_HEIGHT ? 1. : GROUND_REFLECTION);
    gFrag.c.rgb *= (y / (2.-(x * 1.)));
    gFrag.c.rgb *= mix(gFrag.c.rgb, auxColor, y);
}

// Function 1237
float RectLight_calcWeight(in vec3 P, in vec3 R, in RectLight light, float theta)
{
    // Intersect ray and light plane.
    float RoPlN = dot(R, light.basis[2]);
    float d = dot(light.basis[2], light.position - P) / RoPlN;
    if (d < 0.0 || RoPlN > 0.0) {
        // Intersection behind ray, or direction is away from plane.
    	return 0.0;
    }
    // PlC: Point on plane.
    vec3 PlC = P + d*R - light.position;
    // uvPl: UV coordinate on plane.
    vec2 PlUV = vec2(dot(PlC, light.basis[0]), dot(PlC, light.basis[1]));
    // r: Radius of cone at distance d.
    float r = d * tan(theta);
    // s: Rect size shifted by radius. This for weigth 1 inside the rect.
    vec2 s = max(light.size - 0.5*r, 0.0);
    // h: Distance from rect on plane.
    float h = length(max(abs(PlUV) - s, 0.0));
    // sr: Steradians from the sphere cap equation: sr = 2pi * (1-cos(a))
    float sr = 2.0*PI * (1.0 - cos(theta));
    // This distribution f(x) has variance v^2 = 1/2, hence
    // v = (1/2)^(1/2) = 2^(-1/2) = INVSQRT2. Using this we can
    // linearly map h = [0,2r] -> x = [0,3v]. Why 3v is to cover
    // approximately 100% of the distribution. 
    return exp(-sqr((3.0*INVSQRT2/2.0) * (h/r))) / (light.attenuation + sqr(d)*sr);
}

// Function 1238
float dDirLine(vec3 p, vec3 c, vec3 dir, float l)
{
    p-=c;
    dir=normalize(dir);
    float dp=dot(p,dir);
    //return length(p-dp*dir);
    return max(max(length(p-dp*dir),-dp),dp-l);
}

// Function 1239
float Outline_SurfaceIDDifference(in vec2 uv, float id)
{
    vec2 offset = vec2(0.004, 0.0);
    
    float idA = RayMarch(Ray_LookAt(uv + offset.xy, CamOrigin, CamLookAt)).w;
    float idB = RayMarch(Ray_LookAt(uv - offset.yx, CamOrigin, CamLookAt)).w;
    
    float e = clamp(max(abs(id - idA), abs(id - idB)), 0.0, 1.0);
                    
    return e;
}

// Function 1240
void DrawScore(vec2 p, float score, inout vec3 color)
{
    vec3 pinkColor = vec3(0.650, 0.117, 0.745);
    vec3 blueColor = vec3(0.117, 0.352, 0.745);
    
    float deadt = max(0., gT - kFinishTime);
    
    vec2 startPos = vec2(0.);
    vec2 endPos = vec2(-1.2, -1. + sin(gT)*0.05);
    vec2 pos = mix(startPos, endPos, pow(min(deadt*0.45, 1.), 10.) );
    
    float scale = mix(1., 0.8, pow(min(deadt*0.45, 1.), 10.) );
    p = (p-pos)*scale;
    
    vec2 q = p - vec2(1., 0.85);
    q.x += q.y*0.35;
    float d = uRoundBox(q, vec2(0.5, 0.068), 0.01);
    vec3 bgColor = color*0.8 + blueColor*0.2;
    bgColor = mix(bgColor, blueColor, smoothstep(-0.1, 0.2, q.y));
    color = mix(bgColor, color, smoothstep(-0.0, 0.001, d));
    color = mix(blueColor, color, smoothstep(0.0, 0.01, abs(d)-0.001));
    
    q = p - vec2(0.6, 0.80);
	d = PrintInt(q*10., score);
    vec3 lettersColor = vec3(1.);
    lettersColor = mix(lettersColor, pinkColor, 1.-smoothstep(-0.1, 0.13, q.y));
    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));
}

// Function 1241
void DrawSky (in vec2 uv, in vec2 cameraOffset, inout vec3 pixelColor)
{
    float alpha = clamp(0.0,1.0,uv.y + cameraOffset.y * -0.9);
    alpha = smoothstep(0.0, 1.0, alpha);
    pixelColor = mix(vec3(0.25,0.6,1.0), vec3(0.25,0.1,0.3), alpha);
}

// Function 1242
vec3 OPcircle(vec2 p, float r, vec3 col, float op)
{
	float c = 1.0-SScircle(p, r);   
    return vec3(c*col* op);
    //[thought process]
    //do I need to do vec4 anyways? because a simple mult
    //would do the same thing woudln't it?...no becauase what if the circles color is
    //like 2 or something, so bright that *0.5would still be 1...
}

// Function 1243
float sdLines(float p, float spacing) {
  float pl = floor(p / spacing) * spacing;

  float pr = ceil(p / spacing) * spacing;

  return min(abs(p - pl), abs(p - pr));
}

// Function 1244
vec4 drawWater(vec4 water_color, sampler2D color, float transparency, float height, float angle, float wave_strength, float wave_frequency, vec2 uv)
{
    angle *= uv.y/height+angle/1.5; //3D effect
    wave_strength /= 1000.0;
    float wave = sin(10.0*uv.y+10.0*uv.x+wave_frequency*iTime)*wave_strength;
    wave += sin(20.0*-uv.y+20.0*uv.x+wave_frequency*1.0*iTime)*wave_strength*0.5;
    wave += sin(15.0*-uv.y+15.0*-uv.x+wave_frequency*0.6*iTime)*wave_strength*1.3;
    wave += sin(3.0*-uv.y+3.0*-uv.x+wave_frequency*0.3*iTime)*wave_strength*10.0;
    
    if(uv.y - wave <= height)
        return mix(
        mix(
            texture(color, vec2(uv.x, ((1.0 + angle)*(height + wave) - angle*uv.y + wave))),
            water_color,
            0.6-(0.3-(0.3*uv.y/height))),
        texture(color, vec2(uv.x + wave, uv.y - wave)),
        transparency-(transparency*uv.y/height));
    else
        return texture(color, vec2(uv.x, uv.y));
}

// Function 1245
vec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)
{
    return mix(
        currentCol , 
        colLine ,
        1.0 - smoothstep(0.0,1.0,(sqrt( segment(uv,lineA,lineB).x * scale )))
    );
}

// Function 1246
float dfRect(vec2 size, vec2 uv)
{
	return max(max(-uv.x,uv.x - size.x),max(-uv.y,uv.y - size.y));
}

// Function 1247
void CircleTest(in vec2 p, in vec3 centerRadius, in vec3 color, inout vec4 distanceAndColor)
{
    p -= centerRadius.xy;
    float dist = length(p) - centerRadius.z;
    if (dist < distanceAndColor.x)
    {
        distanceAndColor.x = dist;
        distanceAndColor.yzw = color;
    }
}

// Function 1248
float bilinearQuad(vec2 texcoord, float sample0, float sample1, float sample2, float sample3)
{
    float x1 = texcoord.x;
    float x2 = 1.0 - texcoord.x;
    float y1 = texcoord.y;
    float y2 = 1.0 - texcoord.y;
    
    float fsample = 0.0;
    
    fsample += sample3*x1*y1;
    fsample += sample2*x2*y1;
    fsample += sample0*x2*y2;
    fsample += sample1*x1*y2;
    
    return fsample;
}

// Function 1249
float DrawQuad(vec2 a, vec2 b, vec2 c, vec2 d, float t, vec2 co){
    float f = 0.;
    f= max(f,DrawLine(a,b,t,co));
    f= max(f,DrawLine(a,c,t,co));
    f= max(f,DrawLine(a,d,t,co));
    f= max(f,DrawLine(b,c,t,co));
    f= max(f,DrawLine(b,d,t,co));
    f= max(f,DrawLine(c,d,t,co));
    return f;
}

// Function 1250
vec2 BokehShapeCircle( float fRand )
{
    fRand *= PI * 2.0;
    return vec2( sin( fRand ), cos( fRand ) );
}

// Function 1251
void rounded_rectangle(float ox, float oy, float sx, float sy, float r) {
    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);
}

// Function 1252
vec3 drawStar(float t, vec2 uv, float angle, float dist, float speed) {
    float c = cos(angle);
    float s = sin(angle);
    float speed2 = 2.0*t*0.5*(speed*0.075+0.025)*0.5;
    float d = pow(fract(dist+speed2+g_speed*0.5), 4.0);
    vec2 star = mat2(c,s,-s,c) * vec2(d,0.0);
    float l = length(uv-star);
    
    float dim = 0.3 + speed*0.7*dist;
    float blink_factor = fract(angle*6.142)*0.6;
    float blink = mix(1.0, abs(sin(t*(15.0+dist+angle)+fract(angle*3.5)+dist)), blink_factor);
    float power = 2.0*mix(1.0, 2.0, g_speed);
    float att = smoothstep(0.00, pow(1.0-speed,0.75)*0.75, length(uv));
    float sz = smoothstep(0.0005+(1.0+g_speed*5.0)*d/300., 0.0, l);
    return power * sz * vec3(0.8, 0.9, 1.0) * att * dim * blink;
}

// Function 1253
bool drawControls(vec4 brushSettings, vec4 currentColor, out vec4 fragColor, in vec2 fragCoord) {
    float radius = 1.0 + pow(brushSettings.x, 2.0) * 100.0;
    float hardness = brushSettings.y;
    float opacity = 1.0-brushSettings.z;

    if (fragCoord.x < 100.0 && fragCoord.y < 120.0 && fragCoord.y > 100.0) {
        vec3 hsv = vec3(fragCoord.x/100.0, 1.0, 1.0);
        fragColor = vec4(hsv2rgb(hsv), 1.0);
        if (length(hsv.x - currentColor.x) < 2.0/200.0) {
            fragColor = vec4(0.0);
        }
        return true;
    }
    if (fragCoord.x < 100.0 && fragCoord.y < 100.0) {
        vec3 hsv = vec3(currentColor.x, fragCoord.x/100.0, fragCoord.y/100.0);
        fragColor = vec4(hsv2rgb(hsv), 1.0);
        if (abs(length(hsv.yz - currentColor.yz) - 0.03) < 1.0/200.0) {
            fragColor = vec4(1.0);
        }
        return true;
    }
    if (fragCoord.x < 150.0 && fragCoord.y < 20.0) {
        fragColor = vec4(hsv2rgb(currentColor.xyz), 1.0);
        return true;
    }
    if (fragCoord.x < 300.0 && fragCoord.y < 20.0) {
        float v = (fragCoord.x - 200.0) / 100.0;
        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;
        fragColor = vec4(c,c,c, 1.0);
        if (abs(brushSettings.x - v) < 0.01) {
            fragColor.rgb = vec3(1.0, 0.0, 0.0);
        }
        return true;
    }
    if (fragCoord.x < 340.0 && fragCoord.y < 20.0) {
        float v = (fragCoord.x - 300.0) / 40.0;
        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;
        fragColor = vec4(c,c,c, 1.0);
        if (abs(brushSettings.y - v) < 0.02) {
            fragColor.rgb = vec3(1.0, 0.0, 0.0);
        }
        return true;
    }
    if (fragCoord.x < 380.0 && fragCoord.y < 20.0) {
        float v = (fragCoord.x - 340.0) / 40.0;
        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;
        fragColor = vec4(c,c,c, 1.0);
        fragColor.rgb = vec3((1.0-v) * c + 1.0 * v);
        if (abs(brushSettings.z - v) < 0.02) {
            fragColor.rgb = vec3(1.0, 0.0, 0.0);
        }
        return true;
    }
    return false;
}

// Function 1254
vec3 ACEScct_from_Linear(vec3 lin) 
{
    return vec3(ACEScct_from_Linear(lin.r),
                ACEScct_from_Linear(lin.g),
                ACEScct_from_Linear(lin.b));
}

// Function 1255
float draw0(vec2 uv, float a, float d, float time){
    float col = 0.;
    float sTime = time*6.28;
    
    // The Emperor
    vec2 st = vec2(sin(a), cos(a))*(d*(1.1+sin(sTime+a)*.1))+.5;
    float sdf = rectSDF(st, vec2(1.));
    col += stroke(sdf, .6, .125);
    col += fill(sdf, min(mod(time, 2.),1.)*.5375);    
    col += fill(sdf, min(mod(time, 2.)-1.,1.)*.5375);    
    col += fill(sdf, .1);

    // Merge
    st = uv;
    vec2 offset = vec2(sin(sTime), cos(sTime))*(pow(cos(sTime)*.5+.5, 1.5)*.2);
    float left = circleSDF(st+offset);
    float right = circleSDF(st-offset);
    col += flip(stroke(left, .5, .05), fill(right, .52));
    
    // Bundle
    st = uv.yx;
    col += stroke(hexSDF(st), .5+cos(sTime)*.2, .1);
    //st = vec2(sin(a-sTime), cos(a-sTime))*d+.5;
    float amp = sin(sTime);
    amp = pow(abs(amp), .6)*sign(amp);
    amp*=1.5;
    col += fill(hexSDF(st-vec2(-.06, -.1)*amp), .15);
    col += fill(hexSDF(st-vec2(-.06, .1)*amp), .15);
    col += fill(hexSDF(st-vec2(.11, 0.)*amp), .15);
    
    col = abs(mod(col+1., 2.)-1.);
    return col;
}

// Function 1256
vec2 RandomDirection2D(vec2 hexCoord)
{
	float azimuth = rand(hexCoord) * 2.0 * M_PI;
	return vec2(cos(azimuth), sin(azimuth));
}

// Function 1257
float DistanceToLineSegment(vec2 point, vec2 start, vec2 end) {
    float A = point.x - start.x;
    float B = point.y - start.y;
    float C = end.x - start.x;
    float D = end.y - start.y;

    float dot1 = A * C + B * D;
    float len_sq = C * C + D * D;
    float param = -1.0;
    if (len_sq != 0.0) {  param = dot1 / len_sq; }
       
    float xx, yy;

    if (param < 0.0) {
        xx = start.x;
        yy = start.y;
    }

    else if (param > 1.0) {
        xx = end.x;
        yy = end.y;
    }

    else {
        xx = start.x + param * C;
        yy = start.y + param * D;
    }

    float dx = point.x - xx;
    float dy = point.y - yy;
    return sqrt(dx * dx + dy * dy);
}

// Function 1258
float InRect(const in vec2 vUV, const in vec4 vRect) {
	vec2 vTestMin = step(vRect.xy, vUV.xy);
	vec2 vTestMax = step(vUV.xy, vRect.zw);	
	vec2 vTest = vTestMin * vTestMax;
	return vTest.x * vTest.y;
}

// Function 1259
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    float w = k1*k1 - 4.0*k0*k2;
    if( w<0.0 ) return vec2(-1.0);
    w = sqrt( w );

    // will fail for k0=0, which is only on the ba edge 
    float v = 2.0*k0/(-k1 - w); 
    if( v<0.0 || v>1.0 ) v = 2.0*k0/(-k1 + w);

    float u = (h.x - f.x*v)/(e.x + g.x*v);
    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);
    return vec2( u, v );
}

// Function 1260
float linearBurn (float target, float blend){
    return target + blend - 1.0;
}

// Function 1261
float hyperbolic_line_dist(vec2 p, vec2 a, vec2 b){
    if(a == vec2(0.0)){
        return euclidean_line_dist(p,b,vec2(0.0,0.0));
    }
    vec2 p2 = map_to_origin(a, p);
    vec2 b2 = map_to_origin(a, b);
    return euclidean_line_dist(p2,vec2(0.0,0.0),b2);
}

// Function 1262
vec3 drawCircleFill(vec2 resolution, vec2 st, vec2 center, float radius, float blur)
{
    vec2 aspect = resolution / min(resolution.x, resolution.y);
    return vec3(smoothstep(radius - blur, radius, length((st - center) * aspect)));
}

// Function 1263
float distToLineSquare(vec2 p1, vec2 p2, vec2 p, float thickness)
{
	p -= p1;
	vec2 lineVector = p2-p1;
		
	float angle = -atan(lineVector.y,lineVector.x);
	p = rotate(p,angle);
	
	float dx = 0.0;
	if(p.x<0.0)
		dx = abs(p.x);
	else if(p.x>length(lineVector))
		dx = abs(p.x) - length(lineVector);
		
	return thickness/(dx+abs(p.y));
}

// Function 1264
vec4 draw_font8x8_string20_ivec4( int num_ch, ivec4 s, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    if( num_ch < 0 ) {
        return( v ) ;
    }
    num_ch = num_ch == 0 ? 20 : min( num_ch, 20 ) ;

    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(0), ivec2(num_ch*8,8) ) ) {
        int i = iu2.x >> 3,
            j = i / 5,
            sh = 6*(i % 5),
            s5 =  j<2?j<1?  s[0] : s[1]
                 :j<3?      s[2] : s[3],
            m = 0x3f << sh,
            c = (s5 & m) >> sh ;
        pos.x += i * 8 ;
        v += draw_font8x8_char( c, col, pos, o, iu ) ;
    }
    return( v ) ;
}

// Function 1265
type project_on_liney( type P, type O ) { O.y += ( P - O ).y; return O; }

// Function 1266
float line(vec2 origin, vec2 destiny, float radius, float angle, float lineWidth)
{
    vec2 d = origin - destiny;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        vec2 p = vec2(sin(angle+M_PI/2.0),
                            -cos(angle+M_PI/2.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );
    	return 1.0-smoothstep(0.0,lineWidth, l);//return SMOOTH(l/1000.0,lineWidth/100.0);
    }
    else return 0.0;
}

// Function 1267
vec3 rayDirection(float fov, vec2 size, vec2 fragCoords) {
    // Center coordinate system 
    // Define x and y coordinates 
    vec2 xy = fragCoords - size / 2.0;
    // Find z
    float z = size.y / tan(radians(fov) / 2.0);
    // Return normalized direction to march 
    return normalize(vec3(xy, -z));
}

// Function 1268
vec3 drawlights( Ray ray )
{   
    float castdistance=13.0;
    float caststep=0.1;    
    float castscale=castdistance/caststep;

    vec3 colour = vec3(0.0, 0.0, 0.0);            
    
    for (int i=0; i<numlights; i++)
    {        
        float lightdistance = length(g_lights[i].pos-ray.pos);
        float maindistance = length(g_result.pos - ray.pos);
        if (maindistance < lightdistance)
            return vec3(0.0);
        castdistance = min(castdistance, maindistance);

        for (float t=0.0; t<castdistance; t+=caststep)
        {
            vec3 pos = ray.pos + ray.dir*t;        
            vec3 deltapos = g_lights[i].pos-pos;
            float d2=dot(deltapos, deltapos);

            if (d2<8.0)
            {
                colour.xyz += g_lights[i].colour/(d2*castscale*0.9);
            }                    
        }
    }
    
    return colour;
}

// Function 1269
vec4 drawWave(vec4 pixel, vec2 uv, float speed, float height, float vOffset) {
    float c = covered(uv, speed, height, vOffset);
    if (c == 1.) {
		pixel += BASE_COLOR * MULTIPLIER;
        
        if (SHOW_TEXTURES) {
            vec2 nUv = uv;
            nUv.x += iTime * sqrt(speed) * 0.1;
            nUv.y -= heightAt(uv, speed, height, vOffset);
            pixel += .015 * noise(nUv * 20.);
    	}
    } else if (c > 0.) {
		pixel *= vec4(vec3(sqrt(1.-c)) ,1.0);
    }
    
	return pixel;
}

// Function 1270
float drawClick(vec2 point, vec2 uv, float rad0)
{
    float rad1 = rad0 +0.05;
    float fade = 0.01;
    vec2 d = uv-point;
    float l = length(d);
    float a = atan(d.y,d.x);
	float v = smoothstep(rad0-fade,rad0,l)-smoothstep(rad1,rad1+fade, l);
    float slice = (2.0*3.14159)/10.;
    a = mod(a+0.5*slice,slice)-0.5*slice;
    float rad = 0.005/l;
   	v *=  smoothstep(-0.1-rad,-rad,a)-smoothstep(rad,rad+0.1, a);

    return v;
}

// Function 1271
void drawPlane(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 planeNorm;
    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    
    
    if(planeT < cur_ctxt.t)
    {
        cur_ctxt.t = planeT;

        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; 
        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;
        cur_ctxt.n = planeNorm;

        cur_ctxt.materialType = DIFFUSE;
        /*if(randVals.y < 0.5)
        {
            cur_ctxt.materialType = REFLECTION;
        }*/
    }
}

// Function 1272
void rectangle(float ox, float oy, float sx, float sy) {
    rectangle(vec2(ox,oy), vec2(sx,sy));
}

// Function 1273
v0 line(v3 ray, v2 u, v0 size
){maxGISize = max(maxGISize,size*ray.w)
 ;ray.xyz = abs(ray.xyz-u) - size
 ;return ray.w*max(ray.z,ray.y);}

// Function 1274
float drawLine(vec2 uv, vec2 p1, vec2 p2) {
  float a = abs(distance(p1, uv));
  float b = abs(distance(p2, uv));
  float c = abs(distance(p1, p2));

  if ( a >= c || b >=  c ) return 0.0;

  float p = (a + b + c) * 0.5;

  // median to (p1, p2) vector
  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));

  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));
}

// Function 1275
vec3 DrawCandy4(vec2 p, vec3 bgColor)
{
    vec2 q = p-vec2(-0.0, +0.0);
    q.x *= 1./(1.+abs(q.y)*0.25);
    float d = dsBox(q, vec2(0.20, 0.30), 0.25);
    vec3 color = vec3(0.345, 0.882, 0.254)*0.6;
    color = mix(color*0.4, color, smoothstep(-0.7, 0.3, p.y));
    
    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;
    color *= 1.+cubeTex.r*0.30;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.15, 0.15))*vec2(0.5, 1.2))), 0.12) ))*2.5;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.25, -0.1))*vec2(0.9, 1.2))), 0.11) ))*2.5;
    
    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));
    
    return mix(color, bgColor, smoothstep(0., 2e-2, d));
}

// Function 1276
vec4 drawMode(in vec2 uv, in float mode)
{
    
    float lsize = 0.03;
    vec2 start = vec2(0.01, 0.05);
    vec4 tcol;
    
    tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _O, _D, _E, _COLON, _X, _X, _X, _X, _X), 5);
    start += 3.*vec2(lsize, 0.);
    
    if (in_zone(mode, APPL_DRAW))
    {
         tcol += drawTextHorizontal(uv, start, lsize, _DRAW, 4);
    }
    else if (in_zone(mode, APPL_ERASE))
    {
         tcol += drawTextHorizontal(uv, start, lsize, _ERASE, 5);
    }else if (in_zone(mode, APPL_UI))
    {
         tcol += drawTextHorizontal(uv, start, lsize, _GUI, 3);
    }
    else if (in_zone(mode, APPL_3D))
    {
         tcol += drawTextHorizontal(uv, start, lsize, _3D_TEXT, 2);
    }
    else if (in_zone(mode, APPL_TEXTURES))
    {
         tcol += drawTextHorizontal(uv, start, lsize, _TEXTURES, 8);
    }
    return tcol;
}

// Function 1277
float recta(vec3 p, vec3 F, vec3 o) {
	const float R = 0.0001;
	p += o;
	return length(max(abs(p)-F,0.0)) - R;	
}

// Function 1278
vec4 drawSprite(vec2 uv) {
    vec4 tex = vec4(0);
    if(all(greaterThan(step(abs(uv - .5), vec2(.5)), vec2(.5))))
    	tex = texture(iChannel0, vec2(uv.x / 6.6, uv.y));
    return tex;
}

// Function 1279
vec3 skyDirectLight(vec3 pos, int i) {
    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}
    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;
    float alt, dist, ds;
    for(; i < SkySamples; i++){
        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));
    	dist = alt/dot(LightDirection, SkyUp);
        ds = exp(-dot(pos, SkyUp));
        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);
        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));
        volAbs *= stepAbsMie*stepAbsRay;
        pos += LightDirection*dist;
    }
    return LightColor.rgb*LightColor*volAbs;
}

// Function 1280
float circle(in vec2 _st, in float _radius){
    vec2 dist = _st-vec2(0.5);
	return 1.-smoothstep(_radius-(_radius*0.05),
                         _radius+(_radius*0.1),
                         dot(dist,dist)*3.7);
}

// Function 1281
float circle(vec2 uv2,vec2 center,float radius)
{
return step(distance(uv2, center ), radius);
}

// Function 1282
vec3 segmentToLineDistance( vec3 u1, 
                            vec3 u2, 
                            vec3 v1, 
                            vec3 v2 )
{
    vec3 u = u2 - u1;
    vec3 v = v2 - v1;
    vec3 w = u1 - v1;
    
    // For the maths:
    // http://geomalgorithms.com/a07-_distance.html#dist3D_Segment_to_Segment
    float a = dot(  u, u );
    float b = dot(  u, v ); 
    float c = dot(  v, v );   
    float d = dot(  u, w );
    float e = dot(  v, w ); 
    
    // just a way of calculating two equations with one operation.
    // th.x is the value of t along ba
    // th.y is the value of t along wv 

    // when a*c - b*b is near 0 (the lines are parallel), we will just assume
    // a close line is the distance between u1 and v1
    float denom = (a * c - b * b);

    // DEBRANCHED
    // Equivalent to:
    // vec2 th = (abs(denom) < EPSILON ? vec2(0.) : 
    //                                  vec2( b*e - c*d, a*e - b*d ) / denom);

    float clampedDenom = sign(denom) * max(EPSILON, abs(denom));
    vec2 th = mix( vec2( b*e - c*d, a*e - b*d ) / clampedDenom, 
                   vec2(0.),
                   step(abs(denom), EPSILON));

    // In the case where the line to line comparison has p be a point that lives
    // off of the bounded segment u2<-u1, just fine the closest path between u1
    // and u2 and pick the shortest

    float ifthxltZero = step(th.x, 0.);
    float ifthxgt1 = step(1., th.x);

    // DEBRANCHED
    // Equivalent to:
    // if (th.x < 0.) {
    //     th.x = 0.;
    //     th.y = dot(v, u1-v1) / c; // v . (u1<-v1) / v . v
    // } else if (th.x > 1.) {
    //     th.x = 1.;
    //     th.y = dot(v, u2-v1) / c; // v . (u2<-v1) / v . v
    // }
    
    th.x = clamp(th.x, 0., 1.);
    th.y = mix(th.y, dot(v, u1-v1) / c, ifthxltZero);
    th.y = mix(th.y, dot(v, u2-v1) / c, ifthxgt1);
    
    // p is the nearest clamped point on the line segment u1->u2
    vec3 p = u1     + u  * th.x;
    // q is the nearest unbounded point on the line segment v1->v2
    vec3 q = v1     + v  * th.y;
    
    return vec3(length(p-q), th.x, th.y);
}

// Function 1283
float circle(in vec2 _st, in vec2 pos, in float _radius){
    
    float circEdge  =  20.0 / iResolution.x;
    
    vec2 dist = _st - pos;    
	return 1. - smoothstep(_radius-(_radius*circEdge),
                         _radius+(_radius*circEdge),
                         dot(dist,dist)*4.0);
}

// Function 1284
void sdLine(inout vec4 dis_col, in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv)
{
    vec2 pa = p-a;
    vec2 ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);
    float d = length(pa-h*ba);
    if( d<dis_col.x )
    {
        float s = pa.x*ba.y-pa.y*ba.x;
        dis_col = vec4(d,(s<0.0)?cu:cv);
    }
}

// Function 1285
float ACEScc_from_Linear(float lin) 
{    
    if (lin <= 0.0) 
        return -0.3584474886;
    
    if (lin < exp2(-15.0))
    	return log2(exp2(-16.0) + lin * 0.5) / 17.52 + (9.72/17.52);
    
    return log2(lin) / 17.52 + (9.72/17.52);
}

// Function 1286
bool isColinear(vec2 a,vec2 b,vec2 c){return length(normalize(a-b)-normalize(a-c))<.001;}

// Function 1287
float circle(in vec2 pos, float r)
{
    return length(g_uv - pos) - r;
}

// Function 1288
vec4 draw_mothership_explosion( ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), mothership_exp_dim ) ) {
        int x = iu.x, y = iu.y ;
        PREPARE_TEST_BIT ;
        BR24(7,   _,_,w,_,_,w,_,w,_,_,_,_,_,_,w,_,w,_,_,w,_   ,_,_,_  ) ;
        BR24(6,   _,_,_,w,_,_,_,_,_,_,_,_,w,w,_,_,_,_,w,_,_   ,_,_,_  ) ;
        BR24(5,   w,_,w,_,_,_,w,w,w,w,_,_,_,w,w,_,_,_,_,_,_   ,_,_,_  ) ;
        BR24(4,   _,_,_,_,_,w,w,w,w,w,w,w,_,_,w,w,w,_,_,w,_   ,_,_,_  ) ;
        BR24(3,   _,_,_,_,w,w,w,_,w,_,w,_,w,_,_,w,w,w,_,_,w   ,_,_,_  ) ;
        BR24(2,   _,_,w,_,_,_,w,w,w,w,w,_,_,_,w,w,_,_,_,_,_   ,_,_,_  ) ;
        BR24(1,   w,_,_,_,_,_,_,w,_,w,_,_,_,w,w,_,_,_,w,_,_   ,_,_,_  ) ;
        BR24(0,   _,_,w,_,_,_,w,_,_,_,w,_,_,_,_,w,_,_,_,_,_   ,_,_,_  ) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 1289
vec4 drawBoat(vec3 color, vec2 pos, vec2 uv, float width, float height){

    vec4 boat = vec4(0.0, 0.0, 0.0, 0.0);
    if(uv.x < pos.x + width*1.0/(4.0*size) && uv.y < pos.y + height*1.0/(2.0*size) && uv.x > pos.x - width*1.0/(4.0*size) && uv.y > pos.y - height*1.0/(2.0*size)) {
        boat = vec4(color*0.5, 1.0);
            
    }
	
    if(uv.x < pos.x + width*1.0/(2.0*size) && uv.y < pos.y + height*1.0/(4.0*size) && uv.x > pos.x - width*1.0/(2.0*size) && uv.y > pos.y - height*1.0/(4.0*size)) {
        boat = vec4(color*0.5, 1.0);      
    }
    
    if(uv.x < pos.x + width*1.0/(3.0*size) && uv.y < pos.y + height*1.0/(3.0*size) && uv.x > pos.x - width*1.0/(3.0*size) && uv.y > pos.y - height*1.0/(3.0*size)) {
        boat = vec4(color*0.5, 1.0);    
    }
    
    if(uv.x < pos.x + width*1.0/(4.0*size) && uv.y < pos.y + height*1.0/(4.0*size) && uv.x > pos.x - width*1.0/(4.0*size) && uv.y > pos.y - height*1.0/(4.0*size)) {
        boat = vec4(color, 1.0);      
    }
    return boat;
}

// Function 1290
vec3 draw_cloud(float f)
{
    f = f * 0.5 + 0.5;
    return mix(	vec3(8.0/255.0, 65.0/255.0, 82.0/255.0),
              	vec3(178.0/255.0, 161.0/255.0, 205.0/255.0),
               	f*f);
}

// Function 1291
vec2 closestPointOnRepeatedLine(vec2 line, vec2 point){

    // Angle of the line
    float a = atan(line.x, line.y);

    // Rotate space so we can easily repeat along
    // one dimension
    pR(point, -a);

    // Repeat to create parallel lines at the corners
    // of the vec2(lead, radius) polar bounding area
    float repeatSize = sin(a) * line.y;
    float cell = pMod1(point.x, repeatSize);

    // Rotate space back to where it was
    pR(point, a);

    // Closest point on a line
    line = normalize(line);
    float d = dot(point, line);
    vec2 closest = line * d;

    // Part 2 of the repeat, move the line along it's
    // perpendicular by the repeat cell
    vec2 perpendicular = vec2(line.y, -line.x);
    closest += cell * repeatSize * perpendicular;

    return closest;
}

// Function 1292
void drawNumber(float val, float fractPrecision){  
    if(sign(val)==-1.0) MINUS //draw minus sign if needed
    val = abs(val);    
    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length
    // log10(val) = log(val)/2.302585    
    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point 
    val = floor(val); // strip the fractional part   
    float count = intCount + fractPrecision; //totla number of digits to print    
    if(count > 8.){ E R R O R return;} //show error if count > 8 
    float pw = pow(10., count-1.);
    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number
        if(count<i){ continue;} //skip unnecessary loops
        if(i-fractPrecision == 0.){STP} //draw decimal point        
        float d = floor(val/pw); //get one digit
        digit( d ); //draw digit
        val -= d*pw; pw /= 10.; //prepare for next iteration
    }
}

// Function 1293
float sdLine(vec3 q0, vec3 q1, vec3 p) {
    vec3 x = cpLine(q0, q1, p);
    return distance(x, p);
}

// Function 1294
float line(vec2 start, vec2 end, vec2 p, float thickness) {
    float d = lineDistance(start, end, p);
    if(d < thickness) {
       return shade(d, thickness);    
    } else {
		return 0.0;
    }
}

// Function 1295
vec3 getCircle() {
    float r = .3 * pow(iTime + .001, -.8);
    float t = iTime * .5;
    vec2 pos = vec2(sin(t), cos(t)) / 2. + vec2(.5); // let's play a game
    return vec3(pos, r * r);
}

// Function 1296
vec3 getLine(vec2 p1, vec2 p2){
    float xDiff = p2.x - p1.x;
    float yDiff = p2.y - p1.y;
    if(abs(xDiff) < LINE_THRESHOLD){
        //x = c
        return vec3(1, 0, p1.x);
    }else if(abs(yDiff) < LINE_THRESHOLD){
        //y = c
        return vec3(0, 1, p1.y);
    }else{
        //y = ax + b
        return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);
    }
}

// Function 1297
float line(vec2 p, vec2 a, vec2 b){
     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));
}

// Function 1298
void init_light_view_directions_ts(vec3 pos_ndc, int time_base, out vec3 to_light_ts, out vec3 to_view_ts)
{
    float x = cos(float(time_base) * 0.02);
    float y = sin(float(time_base) * 0.01);
    vec3 direction_to_light_ndc = normalize(vec3(x, y, 1.0));
    
    // compose matrix ndc -> ts.
    vec3 t = normalize(dFdx(pos_ndc));
    vec3 b = normalize(dFdy(pos_ndc));
    vec3 n = normalize(cross(t, b));
    mat3 ndc_to_ts_matrix = transpose(mat3(t, b, n));
    
    to_light_ts = ndc_to_ts_matrix * direction_to_light_ndc;
    to_view_ts 	= ndc_to_ts_matrix * normalize(vec3(0, 0, 1) - pos_ndc);
}

// Function 1299
float circle(in vec2 uv, in vec2 c, in float r)
{
    return r - length(uv - c);
}

// Function 1300
float heightLines(vec3 x) {
    float c = 0.0; // color to be returned (black or white)
    float hmin = dh*fract(iTime*0.5);
    for (float i=hmin-dh; i<hmin+1.0+dh; i+=dh) {
    	c += band(i, i+0.005,height(x));
    }
    return c;
}

// Function 1301
vec3 cosineDirection( in float seed, in vec3 nor)
{
    float u = hash( 78.233 + seed);
    float v = hash( 10.873 + seed);

    
    // Method 1 and 2 first generate a frame of reference to use with an arbitrary
    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes 
    // the whole math to the cosine distribution and simplfies the result to a more 
    // compact version that does not depend on a full frame of reference.

    #if 0
        // method 1 by http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content
        vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);
        vec3 uu = vec3( tc.x, tc.z, -nor.x );
        vec3 vv = vec3( tc.z, tc.y, -nor.y );

        float a = 6.2831853 * v;
        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;
    #endif
	#if 0
    	// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf
    	float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0
        float ka = 1.0 / (1.0 + abs(nor.z));
        float kb = -ks * nor.x * nor.y * ka;
        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);
        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);
    
        float a = 6.2831853 * v;
        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;
    #endif
    #if 1
    	// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html
        float a = 6.2831853 * v;
        u = 2.0*u - 1.0;
        return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
    #endif
}

// Function 1302
float circle(vec2 pos, float radius)
{
    return clamp(((1.0-abs(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);
    
}

// Function 1303
vec3 linearBurn (vec3 target, vec3 blend){
    return target + blend - 1.0;
}

// Function 1304
float drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){
    float r =drawFloat(val.y,fractPrecision, p, location, zoom);
    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);
    return r;
}

// Function 1305
float lineDistance(vec2 start, vec2 end, vec2 p) {
  float l2 = pow(distance(start, end), 2.0);
  if (l2 == 0.0) return distance(p, start);
  float t = max(0., min(1., dot(p - start, end - start) / l2));
  vec2 projection = start + t * (end - start);
  return distance(p, projection);
}

// Function 1306
vec4 rasterline(in vec2 xy, in int axis, in vec4 line_color, in float raster_size, in float line_pos, in float line_offset)
{
    float line_pos_final = line_pos + (line_offset);
    float line_pos_max = line_pos_final + raster_size;
    float line_pos_min = line_pos_final - raster_size;
    
    if (axis == 0 && xy.x < line_pos_max && xy.x > line_pos_min)
    {
        return line_color;
    }
    
    if (axis == 1 && xy.y < line_pos_max && xy.y > line_pos_min)
    {
        return line_color;
    }
    
    return vec4(0.0);
}

// Function 1307
float circle(in vec2 p)
{
    float r = length(p);
    float angle = atan(p.y, p.x);
    if (1.-r < 0.)
        return 0.;
    return step(r, 1.) * pow(1.-r, .5);
}

// Function 1308
vec3 GridLines(vec2 uv, vec3 col) 
{
    uv*=4.0;

    float gra, grb, grc, grd,                               // vertical lines
          gre, grf, grg, grh, gri, grj, grk, grl, grm, grn, // small lines
          gpa, gpb, gpc, gpd,                               // horizontal lines
          gga, ggb, ggc, ggd,                               // small rings
          group, group1, group2, group3, group4;
   
    gra = Line( Ruv(uv, 0.125, 4.0), vec2(0.0, 0.3),  vec2(0.0,-1.32) ); // (uv, rot, count), p1, p2
    grb = Line( Ruv(uv, 0.000, 4.0), vec2(0.0,-0.12), vec2(0.0,-1.31) );
    grc = Line( Ruv(uv, 0.000, 8.0), vec2(0.0,-1.08), vec2(0.0,-1.31) );
    grd = Line( Ruv(uv, 0.000, 8.0), vec2(0.0,-0.0),  vec2(0.0,-0.17) );
    
    gre = Line( Ruv(uv, 0.193, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );
    grf = Line( Ruv(uv,-0.193, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );
    grg = Line( Ruv(uv, 0.004, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );
    grh = Line( Ruv(uv,-0.004, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );
    gri = Line( Ruv(uv, 0.185, 4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );
    grj = Line( Ruv(uv,-0.185, 4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );
    grk = Line( Ruv(uv,-0.1225,4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );
    grl = Line( Ruv(uv, 0.1225,4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );
    grm = Line( Ruv(uv,-0.1225,4.0), vec2(0.0,-1.24), vec2(0.0,-1.28) );
    grn = Line( Ruv(uv, 0.1225,4.0), vec2(0.0,-1.24), vec2(0.0,-1.28) );
    
    gpa = Line( Puv(uv, 0.000, 1.0), vec2(0.5, 1.0),  vec2(-0.5, 1.0) );
    gpb = Line( Puv(uv, 0.000, 1.0), vec2(0.5, 2.2),  vec2(-0.5, 2.2) );
    gpc = Line( Puv(uv, 0.000, 4.0), vec2(0.24,1.12), vec2(-0.24,1.12) );
    gpd = Line( Puv(uv, 0.125, 4.0), vec2(0.24,2.08), vec2(-0.24,2.08) );
    
    gga = Line( Puv(abs(uv) - vec2(0.0, 0.7), 0.0, 1.0), vec2(0.5, 0.04), vec2(-0.5, 0.04) );
    ggb = Line( Puv(abs(uv) - vec2(0.7, 0.0), 0.0, 1.0), vec2(0.5, 0.04), vec2(-0.5, 0.04) );
    ggc = Line( Ruv(uv, 0.110, 4.0), vec2(0.0, 0.30), vec2(-0.01,0.3) );
    ggd = Line( Ruv(uv,-0.110, 4.0), vec2(0.0, 0.30), vec2(0.01, 0.3) );

    group1 = min(gra, min(grb, min(grc, min(grd, 1.0) )));
    group2 = min(gre, min(grf, min(grg, min(grh, min(gri, min(grj, min(grk, min(grl, min(grm, min(grn, 1.0) )))))))));
    group3 = min(gpa, min(gpb, min(gpc, min(gpd, 1.0) )));
    group4 = min(gga, min(ggb, min(ggc, min(ggd, 1.0) )));

    group = min(group1, min(group2, min(group3, group4) ));

    float w = 0.012;
    float blur = 0.01;

    col = mix(blue, col, smoothstep(w-blur, w+blur,  group) );

    col = CompassChars(uv / 4.0, col);

    return col;
}

// Function 1309
vec3 DrawUIBox(vec2 q, vec3 color)
{
    vec3 scoreCol = vec3(0.890, 0.588, 0.839);
    scoreCol = mix(scoreCol, scoreCol*1.5, smoothstep(-2., 2., q.x));
    float d = dsBox(q, vec2(1.0, 0.35), 0.2);
    color = mix(mix(scoreCol, color, 0.4), color, smoothstep(0., 0.01, d));
    vec3 frameColor = mix(vec3(0.917, 0.062, 0.768), vec3(0.917, 0.062, 0.768)*0.8, step(0.5, fract(Rot(q*2., -0.7).x)));
    frameColor += vec3(1.)*pow(max((1.-abs(q.x)), 0.), 2.5)*0.4;
    frameColor *= exp(-2.8*max(d+0.1, 0.));
    return mix(frameColor, color, smoothstep(0., 0.01, abs(d)-0.06 ));
}

// Function 1310
void DrawMenuControls(inout vec3 color, vec2 p, in AppState s)
{
	p -= vec2(-110, 74);

	// radial
	float c2 = Capsule(p - vec2(0., -3.5), 3., 4.);
	float c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);

	// roughness slider
	p.y += 15.;
	c1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));
	c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));

	p.y += 8.;
	c1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));
	color = mix(color, vec3(0.9), Smooth(-c2 * 2.));
	color = mix(color, vec3(0.3), Smooth(-c1 * 2.));

	for (int i = 0; i < 6; ++i)
	{
		vec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);
		color = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));
	}
}

// Function 1311
vec4 circles(vec2 uv, float time, float r, const float dx) 
{
    vec4 color = vec4(0.);
    float phase = -0.;
    float r2 = mod(3.*time - phase, 3.);
    float r1 = r2 - .5;
    if (r >= r1 && r <= r2) {
        float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing
        color = premult(vec4(pink*.6, S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r)));

        r2 -= .1;
        r1 = r2 - .3;
        if (r >= r1 && r <= r2) {
            float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing
            color = comp(color, premult(vec4(pink*.8, S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r))));

            r2 -= .1;
            r1 = r2 - .1;
            if (r >= r1 && r <= r2) {
                float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing
                color = comp(color, premult(vec4(.5*(pink+white), S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r))));
            }
        }
    }

        
    return color;
}

// Function 1312
vec4 pulseDrawShadowsFunc(in vec2 coord, float time, vec2 pv, vec2 sx, vec2 sy, vec4 color){
    // Draw point
    vec2 pixel = vec2(1., 1.);
    
    if(sqrt(pow(abs(pv.y - coord.y * 2. * SCALE_Y + SCALE_Y) / pixel.y * 1., 2.)
       + pow(abs(pv.x - coord.x * 2. * SCALE_X + SCALE_X) / pixel.x * 1., 2.)) < .1
      )
        return color * .7;
    
    return vec4(0, 0, 0, 1.0);
}

// Function 1313
float drawFlare(float intensity) {
	return smoothstep(0.3, 1.0, (1.0 - distance(UNIT_VECTOR_ASPECT, vec2(0.5, 0.5))) * intensity);	
}

// Function 1314
float drawDigit(int n, vec2 p){ p=floor(p);
    int i = n==0?0x69996:n==1?0x62227:n==2?0xE168F:n==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:
    n==6?0x68E96:n==7?0xF1244:n==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;
    return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);
}

// Function 1315
void line(float x, float y, float x0, float y0, float dxdy) {
	float f = y0 + dxdy * (x - x0) - y;   
    float dxy =  f / sqrt(1.0 + dxdy * dxdy);

    if (eq(dxy, 0.0, thickness)) {
    	hue = map(x + iTime, -scale / 2.0, scale / 2.0, 0.0, 1.0);
    	brightness = coverage(dxy, thickness) - 0.2;
    	saturation = 1.0;        
    } 
}

// Function 1316
vec4 DrawNote( vec2 uv, float playPos, int track )
{   
    float viewScale = GetGameData(iChannel1,SPEED,iResolution).x;
    
   
    vec4 pos = UvToNoteUv(playPos,viewScale, uv,track);
    
    vec2 mm = ceil(0.5-clamp(abs(pos.wz-0.5),0.,1.));
    float mask = mm.x*mm.y;
           
    vec4 noteState = GetNoteState(iChannel1, track, int(pos.x), iResolution);    
    
    float noteV = ceil(abs(pos.z/viewScale-0.5)-0.3);
    
    vec4 ret = vec4(0.);
    vec3 col1 = keyColors[track];
    vec3 col2 = keyColors[track]+ 0.3;
    
    ret.xyz = mix(col1, col2, 1.- pow(abs(pos.w*2.-1.),1.4)); //abs(sin(iTime*11.14)+1.)
    ret.xyz = mix(ret.xyz, col1, step(pos.z,0.1));
    ret.xyz = mix(col2,ret.xyz,  step(pos.z,0.8));
    ret.a = mask*noteState.x;
    
    return ret;    
}

// Function 1317
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box)
{
    draw_shadow_box(fragColor, fragCoord, box, DEFAULT_SHADOW_BOX_BORDER);
}

// Function 1318
float rectangle(vec2 uv, float up, float down, float left, float right, float blur){
    float band1 = Band(uv.x, left, right, blur);
    float band2 = Band(uv.y, up, down, blur);
    
    return band1*band2;
    
    }

// Function 1319
void drawMineCraftBlur(Ray ray, inout TraceResult cur_ctxt)
{
    TraceResult tr_res;
    float mineT;
    tr_res = TraceMineCraft(ray.pos, ray.dir);

    mineT = sqrt(dot(tr_res.p - ray.pos, tr_res.p - ray.pos)); 
    if (mineT < cur_ctxt.t && tr_res.hit == true)
    {
        cur_ctxt.color = vec3(compute_minecraft_light(tr_res, 
                                    tr_res.sphereIntersect, ray.dir));
        cur_ctxt.n = tr_res.n;
        
        cur_ctxt.t = mineT;
        //cur_ctxt.alpha = max(0.75, 
        //                   sqrt(sqrt(dot(tr_res.p, tr_res.p))));
        cur_ctxt.alpha = GLOBAL_ALPHA;
        /* blur_effect */
        float ro = abs(dot(tr_res.p, tr_res.p) - RADIUS_MINECRAFT);
        vec3 blur_color = cur_ctxt.color;
        
        blur_color = make_another_blur(cur_ctxt.fragCoord,
                                    abs(8.0*(RADIUS_MINECRAFT - ro))).rgb;
        cur_ctxt.color = blur_color;
        
        cur_ctxt.materialType = EMISSION;
        /* end blur_effect */
    }
}

// Function 1320
void drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,
              in vec4 color, inout vec4 outputColor) {
  float d = distance(fragmentCoordinates, center);
  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);

  outputColor = mix(outputColor, color, a * color.a);
}

// Function 1321
void drawSpring(in vec2 fragCoord, in vec2 p0, in vec2 p1, in vec2 thickness,
                in int loops, in vec4 color, inout vec4 outputColor) {

    vec2 n = p1 - p0;
    float l = length(n), hl = l * 0.5;

    fragCoord -= p0;
    fragCoord *= mat2(n, n.y, -n.x) / l;

    float d = max(udTriangleWave(fragCoord, float(loops) / l, thickness.x) - thickness.y, abs(fragCoord.x - hl) - hl);
    outputColor = mix(outputColor, color, smoothstep(1.0, 0.0, d));
}

// Function 1322
vec3 GammaCorrect(in vec3 color)
{
    return pow(color, vec3(2.2));
}

// Function 1323
float circle (vec2 p, float d)
{
    float f = length(p)-d;
    return f;
}

// Function 1324
vec4 drawBackground(ivec2 position, ivec2 offset)
{
    if ((any(lessThan(position, offset))) || (any(greaterThanEqual(position, offset + backgroundSize))))
    {
        return vec4(0.0, 0.0, 0.0, 1.0);
    }

    ivec2 pixelPosition = (position - offset) / 2;
    vec2 pixelScaled = vec2(pixelPosition) / vec2(backgroundSize / 2) * iChannelResolution[1].xy;
    
    return texelFetch(iChannel1, ivec2(pixelScaled), 0) * vec4(vec3(0.7), 1.0);
}

// Function 1325
float WaveDirectional(vec2 p, float wavelength, float speed, vec2 direction, float amplitude)
{
    float freq = 2.0 * kPI / wavelength;
    float phase = speed * freq;
    float theta = dot(direction, p);

    return amplitude * pow(sin(theta * freq + gAnimTime * phase), 3.0);
}

// Function 1326
vec3 ray_direction(float fov, vec2 size, vec2 coord) {
    // from https://www.shadertoy.com/view/Xtd3z7
    vec2 xy = coord - size / 2.0;
    float z = size.y / tan(radians(fov) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 1327
vec2 parametric_circle(float t){
	float x=cos(mod(t,2.*pi));
	float y=sin(mod(t,2.*pi));

	return vec2(x,y);
}

// Function 1328
vec4 drawCellUndefined(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteUindefined();
    return sampleSprite(sprite, colors, coord);
}

// Function 1329
float sdLine( in vec2 p, vec2 a, vec2 b )
{
    vec2 pa = p-a;
    vec2 ba = b-a;
    
    float s = (ba.x*ba.y>0.0)?1.0:-1.0;
    float h = clamp( (pa.y+s*pa.x)/(ba.y+s*ba.x), 0.0, 1.0 );
    
    vec2 q = abs(pa-h*ba);
    return max(q.x,q.y);
}

// Function 1330
vec3 directIlluminationMIS(in Scene scene, in Intersection inter, int technique){
	
    vec3 light_contribution = vec3(0);
    vec3 surface_contribution = vec3(0);
    float wl = 0.0f;
    float ws = 0.0f;
    
    // Light sampling
    {
        float random = rand1();
        uint index = uint(random * float(scene.nbLightSpheres));
        SurfaceLightSample sls;
       	uint ptr = scene.light_spheres[index];
        
        
        //sampleSphereUniform(inter.point, scene.spheres[ptr], sls);
        //sampleSphereHemisphereUniform(inter.point, scene.spheres[ptr], sls);
        //sampleSphereHemisphereCosinus(inter.point, scene.spheres[ptr], sls);
        sampleSphereSA(inter.point, scene.spheres[ptr], sls);


        float pdf = sls.pdf / float(scene.nbLightSpheres);
        vec3 pointToSample = sls.point - inter.point;
        float dist = length(pointToSample);
        pointToSample /= dist;
        vec3 bsdf = BSDF(inter, -inter.ray.direction, pointToSample);
        float cosi = abs(dot(inter.normal, pointToSample));
        vec3 prod = bsdf * cosi;

        if( isOk(prod) && !isBlack(prod)){

            Ray ray_light = Ray(inter.point + pointToSample * epsilon, pointToSample);

            vec3 color = scene.spheres[index].material.emissive;
            float cosl = dot(sls.normal, -pointToSample);
            float SA_to_area = cosl/(dist*dist);
            float V = float(visibility(ray_light, scene, sls.point));
            //pdf /= SA_to_area;
            light_contribution = (V * color * prod / pdf);
			
            float pdf_surface = PDF(inter, pointToSample);
            wl = pdf / (pdf + pdf_surface);
            wl = clamp(wl, 0.0f, 1.0f);
        }
    }

    // Surface sampling
    {
        DirectionSample ds;
        sample_BSDF(inter, ds);
       	float cosi = dot(inter.normal, ds.direction);
        vec3 prod = ds.bsdf * cosi;
        
       	if(!isBlack(prod)){
        	Ray ray_surface = Ray(inter.point + inter.normal * epsilon, ds.direction);
            Intersection inter_surface = nope(ray_surface);
            bool touched = raySceneIntersection(ray_surface, scene, inter_surface);
            if(touched && isEmissive(inter_surface.material)){
                vec3 color = inter_surface.material.emissive;
                float cosl = dot(inter_surface.normal, -ds.direction);
                float SA_to_area = cosl / (inter_surface.t * inter_surface.t);
                surface_contribution = prod * color / ds.pdf;
                
                float pdf_light = (PDF_SA_sampling_point(scene, inter_surface) / float(scene.nbLightSpheres));

                ws = ds.pdf / (pdf_light + ds.pdf);
                ws = clamp(ws, 0.0f, 1.0f);
            }
            
        }

    }
    vec3 MIS_contribution = wl * light_contribution +  ws * surface_contribution;
	//return MIS_contribution;
	return float(technique == MIS) * MIS_contribution +
       	   float(technique == LIGHT_SAMPLING) * light_contribution +
       	   float(technique == BSDF_SAMPLING) * surface_contribution + 
    	   float(technique == WEIGHTS_VISUALIZATION) * vec3(ws, wl, 0);
}

// Function 1331
float drawRect(vec2 uv, float sz, float thick)
{
   	float hth = thick * .5;
    return float((isIn(abs(uv.x) - sz, -hth, hth) && isIn(abs(uv.y), 0., sz + hth)) ||
                 (isIn(abs(uv.y) - sz, -hth, hth) && isIn(abs(uv.x), 0., sz + hth))
                );
}

// Function 1332
vec3 doLine(vec2 fragment, float radius, float x) {
	vec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));
	
	float freq = abs(fragment.x * 0.5);
	
	col *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);	
	col = col * smoothstep(radius, radius * 1.8, abs(fragment.x));
	
	return col;
}

// Function 1333
float getDottedCircle(vec2 st, vec2 center, float radius, float thickness, float sm) {
    float distance = distance(st, center);
    float circle = smoothstep(radius, radius + sm, distance) - smoothstep(radius + thickness, radius + thickness + sm, distance);
    
    vec2 vector = center - st;
    float angle = atan(vector.y, vector.x);
    angle = ((angle * 0.6) + (4.14 * 0.6)) / 4.14;
    circle *= step(9., mod(floor(angle / 0.002), 20.0));
    
    return circle;
}

// Function 1334
v2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo
){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),
                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}

// Function 1335
float xxxDrawFish(float id, fishType fish, float time) 
{
  float angle = atan(fish.velocity.y, fish.velocity.x);
  float ca = cos(angle);
  float sa = sin(angle);                      // rotate and rescale
  vec2 pos = vec2(fish.position)*FISH_SIZE * mat2(ca, sa, -sa, ca);

  // swimming ondulation (+rotate in Z axes)  
  pos.x *= 0.97 + (0.1+.2*pos.y)*cos(id+9.*time); 
  float l1 = length(pos - vec2( 0.80,0)) -0.45;  // fin 
  float l2 = length(pos - vec2(-0.14,0)) -0.12;  // eye
  float ds = min(l1, l2);                 // distance to fish
  pos.y = abs(pos.y) + 0.13;              // fish height
  l1 = length(pos - vec2(0.56,0));        // fin move
  return max(min(length(pos),l1)-0.3,-ds)*0.05; // mix colors
}

// Function 1336
float circle(vec2 center, float radius, vec2 uv) {
    return distance(center, uv) - radius;
}

// Function 1337
vec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )
{
    vec2 res = vec2(-1.0);

    vec2 e = b-a;
    vec2 f = d-a;
    vec2 g = a-b+c-d;
    vec2 h = p-a;
        
    float k2 = cross2d( g, f );
    float k1 = cross2d( e, f ) + cross2d( h, g );
    float k0 = cross2d( h, e );
    
    // if edges are parallel, this is a linear equation. Do not this test here though, do
    // it in the user code
    if( abs(k2)<0.001 )
    {
        float v = -k0/k1;
        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);
        if( v>0.0 && v<1.0 && u>0.0 && u<1.0 )  res = vec2( u, v );
    }
	else
    {
        // otherwise, it's a quadratic
        float w = k1*k1 - 4.0*k0*k2;
        if( w<0.0 ) return vec2(-1.0);
        w = sqrt( w );

        float ik2 = 0.5/k2;
        float v = (-k1 - w)*ik2; if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;
        float u = (h.x - f.x*v)/(e.x + g.x*v);
        if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);
        res = vec2( u, v );
    }
    
    return res;
}

// Function 1338
float line(vec2 p, vec2 a, vec2 b)
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba * h);
}

// Function 1339
vec4 sample3DLinear(sampler2D tex, vec3 uvw, vec3 vres)
{
    vec3 blend = fract(uvw*vres);
    vec4 off = vec4(1.0/vres, 0.0);
    
    //2x2x2 sample blending
    vec4 b000 = sample3D(tex, uvw + off.www, vres);
    vec4 b100 = sample3D(tex, uvw + off.xww, vres);
    
    vec4 b010 = sample3D(tex, uvw + off.wyw, vres);
    vec4 b110 = sample3D(tex, uvw + off.xyw, vres);
    
    vec4 b001 = sample3D(tex, uvw + off.wwz, vres);
    vec4 b101 = sample3D(tex, uvw + off.xwz, vres);
    
    vec4 b011 = sample3D(tex, uvw + off.wyz, vres);
    vec4 b111 = sample3D(tex, uvw + off.xyz, vres);
    
    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), 
               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),
               blend.z);
}

// Function 1340
void drawClouds(vec2 co)
{
	for (int i = 0; i < 20; i++) {
		float xOffset = float(i) * 40.0;
		drawTile(2, vec2(xOffset, 95.0), co);
		drawTile(2, vec2(xOffset+14.0, 91.0), co);
		drawTile(2, vec2(xOffset+28.0, 93.0), co);
	}

	drawHorzRect(co.y, 70.0, 95.0, RGB(233,251,218));
}

// Function 1341
float circle (vec2 p , float r)
{
 return length(p);
}

// Function 1342
void updateTimeline() {
	V.xy = iResolution.xy;
    float t = V.z = T = iTime;
    	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(63.500000,63.500000,63.500000), vec3(40.000000,1.500000,-1.000000), k);
		A = mix(vec3(63.500000,63.500000,63.500000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,1.440000,4.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 18.260317) {
		 float k = t / 18.260317;
		C = mix(vec3(40.000000,1.500000,-1.000000), vec3(19.000000,1.500000,1.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(0.000000,1.440000,4.000000), vec3(0.000000,1.440000,6.000000), k);
		return;
	}
	t -= 18.260317;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(19.000000,1.500000,1.000000), vec3(17.000000,1.500000,1.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,6.000000,-10.000000), k);
		D = mix(vec3(0.000000,1.440000,6.000000), vec3(0.000000,1.440000,20.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 1.304308) {
		 float k = t / 1.304308;
		C = mix(vec3(17.000000,1.500000,1.000000), vec3(16.000000,1.500000,1.000000), k);
		A = mix(vec3(0.000000,6.000000,-10.000000), vec3(0.000000,5.000000,-8.000000), k);
		D = mix(vec3(0.000000,1.440000,20.000000), vec3(0.000000,1.440000,20.000000), k);
		return;
	}
	t -= 1.304308;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(16.000000,1.500000,1.000000), vec3(14.000000,1.500000,2.000000), k);
		A = mix(vec3(0.000000,5.000000,-8.000000), vec3(0.000000,8.000000,10.000000), k);
		D = mix(vec3(0.000000,1.440000,20.000000), vec3(0.000000,1.440000,20.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 1.304308) {
		 float k = t / 1.304308;
		C = mix(vec3(14.000000,1.500000,2.000000), vec3(13.000000,1.500000,3.000000), k);
		A = mix(vec3(0.000000,8.000000,10.000000), vec3(0.000000,7.000000,11.000000), k);
		D = mix(vec3(0.000000,1.440000,20.000000), vec3(0.000000,1.440000,10.000000), k);
		return;
	}
	t -= 1.304308;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(13.000000,1.500000,3.000000), vec3(12.000000,1.500000,5.000000), k);
		A = mix(vec3(0.000000,7.000000,11.000000), vec3(0.000000,2.000000,10.000000), k);
		D = mix(vec3(0.000000,1.440000,10.000000), vec3(0.000000,1.440000,4.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(12.000000,1.500000,5.000000), vec3(11.000000,1.500000,6.000000), k);
		A = mix(vec3(0.000000,2.000000,10.000000), vec3(0.000000,2.000000,4.000000), k);
		D = mix(vec3(0.000000,1.440000,4.000000), vec3(0.000000,1.440000,16.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(11.000000,1.500000,6.000000), vec3(9.000000,1.500000,8.000000), k);
		A = mix(vec3(0.000000,2.000000,4.000000), vec3(0.000000,-3.000000,0.000000), k);
		D = mix(vec3(0.000000,1.440000,16.000000), vec3(0.000000,1.440000,16.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(9.000000,1.500000,8.000000), vec3(8.000000,1.500000,9.000000), k);
		A = mix(vec3(0.000000,-3.000000,0.000000), vec3(-2.000000,3.000000,-2.000000), k);
		D = mix(vec3(0.000000,1.440000,16.000000), vec3(0.000000,1.440000,16.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(8.000000,1.500000,9.000000), vec3(7.000000,1.500000,10.000000), k);
		A = mix(vec3(-2.000000,3.000000,-2.000000), vec3(3.000000,3.000000,-1.000000), k);
		D = mix(vec3(0.000000,1.440000,16.000000), vec3(0.000000,1.440000,16.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(7.000000,1.500000,10.000000), vec3(6.000000,1.500000,11.000000), k);
		A = mix(vec3(3.000000,3.000000,-1.000000), vec3(2.000000,3.000000,0.000000), k);
		D = mix(vec3(0.000000,1.440000,16.000000), vec3(0.000000,1.440000,4.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 0.652154) {
		 float k = t / 0.652154;
		C = mix(vec3(6.000000,1.500000,11.000000), vec3(6.000000,1.500000,11.000000), k);
		A = mix(vec3(2.000000,3.000000,0.000000), vec3(2.000000,3.000000,0.000000), k);
		D = mix(vec3(0.000000,1.440000,4.000000), vec3(1.000000,1.440000,4.000000), k);
		return;
	}
	t -= 0.652154;
	if (t < 1.956463) {
		 float k = t / 1.956463;
		C = mix(vec3(6.000000,1.500000,11.000000), vec3(5.000000,1.500000,12.000000), k);
		A = mix(vec3(2.000000,3.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(1.000000,1.440000,4.000000), vec3(2.000000,3.000000,12.000000), k);
		return;
	}
	t -= 1.956463;
	if (t < 2.608617) {
		 float k = t / 2.608617;
		C = mix(vec3(5.000000,1.500000,12.000000), vec3(7.000000,1.500000,13.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(2.000000,3.000000,12.000000), vec3(3.000000,3.000000,12.000000), k);
		return;
	}
	t -= 2.608617;
	if (t < 5.217234) {
		 float k = t / 5.217234;
		C = mix(vec3(7.000000,1.500000,13.000000), vec3(8.000000,1.500000,13.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,4.000000,0.000000), k);
		D = mix(vec3(3.000000,3.000000,12.000000), vec3(4.000000,2.000000,12.000000), k);
		return;
	}
	t -= 5.217234;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(8.000000,1.500000,13.000000), vec3(10.000000,10.000000,10.000000), k);
		A = mix(vec3(0.000000,4.000000,0.000000), vec3(7.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,2.000000,12.000000), vec3(4.000000,1.440000,12.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(10.000000,10.000000,10.000000), vec3(-10.000000,-10.000000,10.000000), k);
		A = mix(vec3(7.000000,0.000000,0.000000), vec3(0.000000,2.000000,0.000000), k);
		D = mix(vec3(4.000000,1.440000,12.000000), vec3(4.000000,0.800000,2.000000), k);
		return;
	}
	t -= 10.434467;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(-10.000000,-10.000000,10.000000), vec3(10.000000,10.000000,10.000000), k);
		A = mix(vec3(0.000000,2.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,0.800000,2.000000), vec3(4.000000,1.000000,1.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(10.000000,10.000000,10.000000), vec3(-10.000000,-10.000000,10.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,1.000000,1.000000), vec3(4.000000,1.440000,20.000000), k);
		return;
	}
	t -= 10.434467;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(-10.000000,-10.000000,10.000000), vec3(4.000000,2.000000,4.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(1.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,1.440000,20.000000), vec3(4.000000,1.440000,3.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(4.000000,2.000000,4.000000), vec3(5.000000,2.000000,4.000000), k);
		A = mix(vec3(1.000000,0.000000,0.000000), vec3(2.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,1.440000,3.000000), vec3(4.000000,1.440000,8.000000), k);
		return;
	}
	t -= 10.434467;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(5.000000,2.000000,4.000000), vec3(3.000000,-8.000000,2.000000), k);
		A = mix(vec3(2.000000,0.000000,0.000000), vec3(0.000000,-5.000000,3.000000), k);
		D = mix(vec3(4.000000,1.440000,8.000000), vec3(4.000000,1.440000,4.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(3.000000,-8.000000,2.000000), vec3(3.000000,8.000000,4.000000), k);
		A = mix(vec3(0.000000,-5.000000,3.000000), vec3(0.000000,5.000000,2.000000), k);
		D = mix(vec3(4.000000,1.440000,4.000000), vec3(4.000000,1.440000,7.000000), k);
		return;
	}
	t -= 10.434467;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(3.000000,8.000000,4.000000), vec3(2.000000,2.000000,2.000000), k);
		A = mix(vec3(0.000000,5.000000,2.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,1.440000,7.000000), vec3(4.000000,1.440000,8.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(2.000000,2.000000,2.000000), vec3(2.000000,2.000000,2.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(0.000000,0.000000,0.000000), k);
		D = mix(vec3(4.000000,1.440000,8.000000), vec3(4.000000,1.440000,1.000000), k);
		return;
	}
	t -= 10.434467;
	if (t < 0.000000) {
		 float k = t / 0.000000;
		C = mix(vec3(2.000000,2.000000,2.000000), vec3(0.000000,1.000000,0.000000), k);
		A = mix(vec3(0.000000,0.000000,0.000000), vec3(-5.000000,1.000000,10.000000), k);
		D = mix(vec3(4.000000,1.440000,1.000000), vec3(4.000000,1.440000,2.000000), k);
		return;
	}
	t -= 0.000000;
	if (t < 10.434467) {
		 float k = t / 10.434467;
		C = mix(vec3(0.000000,1.000000,0.000000), vec3(0.000000,1.000000,0.000000), k);
		A = mix(vec3(-5.000000,1.000000,10.000000), vec3(5.000000,5.000000,10.000000), k);
		D = mix(vec3(4.000000,1.440000,2.000000), vec3(4.000000,2.000000,2.000000), k);
		return;
	}
	t -= 10.434467;
		 float k = t / 15.651701;
		C = mix(vec3(0.000000,1.000000,0.000000), vec3(0.000000,1.000000,0.000000), k);
		A = mix(vec3(5.000000,5.000000,10.000000), vec3(5.000000,7.000000,10.000000), k);
		D = mix(vec3(4.000000,2.000000,2.000000), vec3(4.000000,16.000000,1.000000), k);
}

// Function 1343
vec3 drawHorizLine(vec3 inColor, vec3 lineColor, float y, vec2 p)
{
    float e = 1.0/iResolution.x;
    float d = abs(p.y - y);
    return mix(inColor, lineColor, 1.0 - step(e, d));
}

// Function 1344
void drawUI(inout vec3 color, vec2 p, AppState s)
{
    p *= R.y / R.x; // ratio and resolution indepenent scaling
    p *= 1.75;
    
    // splash screen   
    if ( s.stateID == GS_SPLASH )
    {
        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); // dark text bg
		vec2 p2 = p;
		p2 *= 50.;
		p2 -= vec2( -45, 27. );
        // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); // horiz guide
        
        float maskTitle = titleText( p2 ); // Sunset Drive Unlimited
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );
        
		vec2 p1 = p;
		p1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );
		p1 -= vec2( -47., -42. );
        float maskSpace = spaceText( p1 ); // press [space] to start
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );

		vec2 p3 = p;
		p3 *= 60.;
		p3 -= vec2( -30, 25. );
        float maskHs = highscoreText( p3 ); // Highscore
        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );

		vec2 pScore = p;
        pScore *= 12.0;
        pScore -= vec2( 1.3, 5.3 );
        float sScore = printInt( pScore, s.highscore );
        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );
    }
    else
    {
        vec2 pScore = p;
        pScore *= 6.0;
        pScore -= vec2( -0.9, 3.4 );
        float maxDigits = ceil( log2( s.score ) / log2( 10.0 ) );
        pScore.x += 0.5 * maxDigits;
        float sScore = printInt( pScore, s.score );
        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );
    }

	// color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); // center guide
    // color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); // horiz guide
}

// Function 1345
float sdAirlinerWindow( vec2 p, float window_radius_scale )
{
	p = abs( p );

	vec2 r = vec2( 525.0, 625.0 ) / 525.0;
	p *= r.x / ( windows_radius.x * window_radius_scale );

	return smin_pol( smin_pol( -p.y + r.y, -p.x + r.x, 0.95 )
					 , -dot( V45, p - project_on_line1( p, r + V45 * 1.05, perp( V45 ) ) ), 2.1 );
}

// Function 1346
float b2_linear(vec3 a, vec3 b, float x) {
    vec4 c = b2_coeffs(a,b);
    float a0 = integrate_L1(c.x, c.y, c.z, c.w, 0.0);
    float a1 = integrate_L1(c.x, c.y, c.z, c.w, 1.0);    
    return inv_integrate_L1(c.x, c.y, c.z, c.w, x*(a1 - a0) + a0);
}

// Function 1347
maybe_float get_distance_along_3d_line_to_tetrahedron(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in vec3 B3,
    in vec3 B4
){
    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);
    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);
    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);
    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);
    maybe_float hit;
    hit = get_distance_along_line_to_union(hit1, hit2);
    hit = get_distance_along_line_to_union(hit,  hit3);
    hit = get_distance_along_line_to_union(hit,  hit4);
    return hit;
}

// Function 1348
vec4 colorRect(vec2 uv, vec2 center, vec2 size, vec4 firstColor, vec4 secondColor)
{
    float rect = 1.0 - step(0.0, boxSDF(uv - center, size));
    float noise = texture(iChannel0, uv).r;
    vec4 color = mix(firstColor, secondColor, noise);
    color.a = rect;
    return color;
}

// Function 1349
vec3 drawGradLine(in vec2 p, in vec2 point)
{
	vec3 col = vec3(0.);
	for (int i=0; i < NUM_GRAD_LINE_POINTS; ++i)
	{
		vec3 gradInfo = calculateGradPF(point);	
		vec3 path = drawElement(p, point, GRAD_COL, GRAD_LINE_RADIUS, GRAD_LINE_RADIUS*0.8);
		col = max(col,path);
		point += DELTA_POS_GRAD_LINES*(gradInfo.yz);
	}	
	return col;
	
}

// Function 1350
float circle(vec2 p, float s )
{
    return length(p)-s;
}

// Function 1351
vec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)
{
    // flatten the line to be axis-aligned.
    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);
    mat2 rotMat = rot2D(lineAngle);

    float lineLength = distance(p2_, p1_);
    // make an axis-aligned line from this line.
    vec2 tl = (p1_ * rotMat);// top left
    vec2 br = tl + vec2(0,lineLength);// bottom right
    vec2 uvLine = uv * rotMat;

    // make line slightly narrower at end.
    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));
    
    // wobble it around, humanize
    float res = min(iResolution.y,iResolution.x);
    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;
    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave
    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around
//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific

    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.
    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;
    uvLine = tl - uvLine;
    
    vec2 lineSize = vec2(lineWidth, lineLength);
    
    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,
                                d, inpColor, brushColor);
    return ret;
}

// Function 1352
float Circle(vec2 uv, float r, vec2 offset) {
float x = uv.x - offset.x;
float y = uv.y - offset.y;

return length(vec2(x, y)) - r;

}

// Function 1353
float drawInt(int val, int minDigits)
{
  float c = 0.; 
  if (val < 0) 
  { val = -val; 
    if (minDigits < 1) minDigits = 1;
    else minDigits--;
    _sub                   // add minus char
  } 
  int fn = val, digits = 1; // get number of digits 
  for (int n=0; n<10; n++)
  {
    fn /= 10; 
    if (fn == 0) break; 
    digits++;
  } 
  digits = max(minDigits, digits); 
  tp.x -= FONT_SPACE * float(digits); 
  for (int n=1; n < 11; n++) 
  { 
    tp.x += FONT_SPACE; // space
    c += char(48 + (val-((val/=10)*10))); // add 0..9 
    if (n >= digits) break;
  } 
  tp.x -= FONT_SPACE * float(digits); 
  return c;
}

// Function 1354
maybe_float get_distance_along_line_to_union(
    in maybe_float shape1,
    in maybe_float shape2
) {
    return maybe_float(
        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),
        shape1.exists || shape2.exists
    );
}

// Function 1355
float line(vec2 p1, vec2 p2, vec2 p, float thickness)
{
	p -= p1;
	vec2 lineVector = p2-p1;
		
	float angle = -atan(lineVector.y,lineVector.x);
	p = rotate(p,angle);
	
	float dx = 0.0;
	if(p.x<0.0)
		dx = abs(p.x);
	else if(p.x>length(lineVector))
		dx = abs(p.x) - length(lineVector);
		
	return ( thickness/(dx+abs(p.y)) );
}

// Function 1356
void draw(Ray r, vec2 p, float width, vec3 fgCol, inout vec3 bgCol)
{
    bgCol = mix(bgCol, fgCol, drawAlpha(r, p, width));
}

// Function 1357
v3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m
){v3 c=v3(1)
 ;u   =viewzoom*(u   -r.xy*.5)/r.y
 ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y
 ;v1 l0=v1(-.4)
 ;v1 l1=v1( .7)
 ;v1 r0=v1(.5,-.5)
 ;v1 r1=v1(.5,-.1)
 ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y
 ;if(pointCount >0.
 ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.
 ;}
 ;if(pointCount >1.//point4 sets one point of the red/yellow arc
 ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.
 ;}  
 ;if(pointCount >2.//point4 sets one point of the red/yellow arc
 ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.
 ;} 
 ;if(pointCount >3.//point4 sets one point of the red/yellow arc
 ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.
 ;}
 ;c.x=segment(u,l0,l1)
 ;c.y=segment(u,r0,r1)
 ;c.z=length(u-mix(l0,l1,.5))
 ;c.w=length(InterWall(r0,r1,l0,l1)-u)
 ;c.xy-=.02
 ;//c.z=abs(c.z-.05)-.02
 ;//c.w=abs(c.w-.1)-.03
 ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)
 ;c*=1.
 ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)
          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))
 ;return c;}

// Function 1358
vec3 DrawAdd(vec3 col, vec3 add){
    return max(col,add);
}

// Function 1359
float distLine(vec2 p0,vec2 p1,vec2 uv)
{
	vec2 dir = normalize(p1 - p0);
	uv = (uv - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);
	return distance(uv, clamp(uv, vec2(0), vec2(distance(p0, p1), 0)));   
}

// Function 1360
vec3 draw2D(vec2 uv, vec3 cScreen, float gamma, float xstart, float xend, float sx) {
    if (gamma > 100.) { 
        return cScreen;
    } else {
        
        float xdist = 9.5*abs(xend-xstart)/gamma;
        xstart = 9.5*abs(xstart/gamma);
        
        vec2 p = uv*150.;
        float s = 300.;
        vec3 cFill, cBack = cScreen; 
        float d,d2, a0,a1;
        d = sdCircle(p-vec2(-70.,-65) ,6.);
        cFill = .1+cScreen*.5;
        d = min(d,sdCircle(p-vec2(-45.,-65) ,6.));
        a1 = clamp(max(d-.35, 0.0)*iResolution.x/s, 0.0, 1.0);
        a0 = clamp(max(abs(d-.35)-.25, 0.0)*iResolution.x/s, 0.0, 1.0);
        cBack = clamp(mix(cBack, a0*cFill, (1.0-a1)),0.,1.);
        d = clock(p-vec2(-70,-65), 6., globalTime);
        d2 = clock(p-vec2(-45,-65), 6., globalTime*gamma);
        
        p += vec2(-50,70);
        d = min(d, udRoundBox(p+vec2(xstart-xdist*.5,-11.5), vec2(xdist*.5,0.), .2));
        d = min(d, spaceshipIcon(p+vec2(mix(xstart, xstart+xdist, sx),-14.5)));   
        d2 = min(d2, sunIcon(p, 9.5,1./gamma));
        cFill = (d2<d ? vec3(1.,.8,.1) : vec3(0,1.,0));
        d = min(d, d2);
        a1 = clamp(max(d-.35, 0.0)*iResolution.x/s, 0.0, 1.0);
        a0 = clamp(max(abs(d-.35)-.25, 0.0)*iResolution.x/s, 0.0, 1.0); 
        return mix(cBack, a0*cFill, (1.0-a1));
    }
}

// Function 1361
vec3 randomSphereDirection(inout float seed) {
    vec2 r = hash2(seed)*6.2831;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dr;
}

// Function 1362
float line_segment(in vec2 p, in vec2 a, in vec2 b) {
	vec2 ba = b - a;
	vec2 pa = p - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
	return length(pa - h * ba);
}

// Function 1363
vec3 draw(vec2 uv) {
    return texture(iChannel0,vec2(uv.x,1.-uv.y)).rgb;   
    //return texture(iChannel0,uv).rgb;  
}

// Function 1364
vec3 setupRayDirection(float camFov)
{
	vec2 coord = vec2(gl_FragCoord.xy);
    vec2 v = vec2(coord / iResolution.xy) * 2.0 - 1.0;
    float camAspect = iResolution.x/iResolution.y;
    float fov_y_scale = tan(camFov/2.0);
    vec3 raydir = vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0);
    return normalize(raydir);
}

// Function 1365
vec3 bilinearNoise( in vec2 p, float fTime ) 
{
    const float PI = 3.14159;
    p.xy += fTime;
    vec2 x = fract( p );	
    vec2 i = p-x;
#if(EASE_FUNC==CUBIC)
    //Option 1 : Cubic ease function
    vec2 t = x*x*(3.0-2.0*x); //ease function
    vec2 d_xy = 6.0*x*(1.0-x);//derivative
#elif(EASE_FUNC==QUINTIC)
    //Option 1 : Quintic ease function
    vec2 t = (6.*x*x-15.0*x+10.)*x*x*x; //ease function
    vec2 d_xy = (30.*x*x-60.*x+30.)*x*x;  //derivative
#elif(EASE_FUNC==SINE)
    //Option 3 : Trigonometric ease function
    vec2 t = 0.5+0.5*sin(-PI/2.0+x*PI);   //ease function
    vec2 d_xy = 0.5*PI*cos(-PI/2.0+x*PI); //derivative
#endif
    
    //bilinear interpolation (abcd = 4 corners)
	float a = genRdm( i + vec2(0.0,0.0) );
	float b = genRdm( i + vec2(1.0,0.0) );
	float c = genRdm( i + vec2(0.0,1.0) );
	float d = genRdm( i + vec2(1.0,1.0) );
    
    //Note : g and h could be factorized out.
    float e = a+(b-a)*t.x; //Horizontal interpolation 1 (e)
    float f = c+(d-c)*t.x; //Horizontal interpolation 2 (f)
	float v = e*(1.-t.y)+f*(t.y); //Vertical interpolation (v)
    
    //All this could be factorized and be made more compact.
    //Step by step is much easier to understand, however.
    float g = a+(c-a)*t.y; //Vertical interpolation (g)
	float h = b+(d-b)*t.y; //Vertical interpolation (h)
    
    //Noise delta scaling (the lookup value slope along x/y axis).
    float sx = h-g; //dv/dx scaling
    float sy = f-e; //dv/dy scaling
    
    return vec3(v,
	            d_xy.x*sx,
                d_xy.y*sy);
    
    //return [h,dh/dx,dh/dy]
}

// Function 1366
float LineDistance(vec2 a, vec2 b, vec2 p){
	vec2 ap = p-a;
    vec2 ab = b-a;
    float t = clamp(dot (ap,ab)/dot(ab,ab),0.0,1.0);
    vec2 at = t*ab;
    vec2 pt = at-ap;
    float off=texture(iChannel0,p/30.).r;
    return length(pt)-0.01*off;
}

// Function 1367
float drawInt(int value, int minDigits)
{
  float c = 0.;
  if (value < 0) 
  { value = -value;
    if (minDigits < 1) minDigits = 1;
    else minDigits--;
    _sub                   // add minus char
  } 
  int fn = value, digits = 1; // get number of digits 
  for (int ni=0; ni<10; ni++)
  {
    fn /= 10;
    if (fn == 0) break;
    digits++;
  } 
  digits = max(minDigits, digits);
  tp.x -= FONT_SPACE * float(digits);
  for (int ni=1; ni < 11; ni++) 
  { 
    tp.x += FONT_SPACE; // space
    c += char(48 + (value-((value/=10)*10))); // add 0..9 
    if (ni >= digits) break;
  } 
  tp.x -= FONT_SPACE * float(digits);
  return c;
}

// Function 1368
float hatline(vec2 p, float ta, float tb, float rb)
{
    return SS(arc(p,vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb));
}

// Function 1369
float rimCircle(vec2 p, float r, float i)
{
    //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/
    float a  =atan( p.y,p.x);
    float shape = sin(a*i+i/1.)/10.;
    
    //SS is used as smoothstep range
    //there is a much better way that fabrice told me about.
    //It's in another shader. (Applause)
 	float ss = 0.0042; 
        
    //a rim range 
    float rim = 0.003;
    //rim is a bigger circle subtracted by a smaller circle to leave just an edge
    float k = smoothstep(r-ss, r+ss, length(p/1.5)+shape);
    //k2 uses "rim" as the thickness of that edge
    float k2 = smoothstep(r-ss+rim, r+ss+rim, length(p/1.5)+shape);
    //here is the subtraction
    k =k-k2;
    //I return it clamped for some reason (applause)
    return clamp(k/2., 0.0, 1.);
}

// Function 1370
float distanceFromLineSegment(vec2 p, vec2 start, vec2 end) {
    float len = length(start - end);
	float l2 = len * len; 
	if (l2 == 0.0f) return length(p - start);   
	float t = max(0.0f, min(1.0f, dot(p - start, end - start) / l2));
	vec2 projection = start + t * (end - start);
	return length(p - projection);
}

// Function 1371
void draw_perf(inout vec4 fragColor, vec2 fragCoord)
{
    Options options;
    LOAD(options);

    if (uint(g_demo_stage - DEMO_STAGE_FPS) < 2u)
        options.flags |= OPTION_FLAG_SHOW_FPS;
    
    if (!test_flag(options.flags, OPTION_FLAG_SHOW_FPS|OPTION_FLAG_SHOW_FPS_GRAPH))
        return;

    float margin = 16. * min(iResolution.x * (1./400.), 1.);
    vec2 anchor = iResolution.xy  - margin;
    
    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS_GRAPH))
    {
        const vec2 SIZE = vec2(ADDR_RANGE_PERF_HISTORY.z, 32.);
        vec4 box = vec4(anchor - SIZE, SIZE);
        draw_shadow_box(fragColor, fragCoord, box);

        if (is_inside(fragCoord, box) > 0.)
        {
            vec2 address = ADDR_RANGE_PERF_HISTORY.xy + vec2(ADDR_RANGE_PERF_HISTORY.z-(fragCoord.x-box.x),0.);
            vec4 perf_sample = load(address);
            if (perf_sample.x > 0.)
            {
                float sample_fps = 1000.0/perf_sample.x;
                float fraction = sample_fps * (1./float(FPS_GRAPH_MAX));
                //fraction = 1./sqr(perf_sample.y/MIN_DOWNSCALE);
                if ((fragCoord.y-box.y) / box.w <= fraction)
                    fragColor.rgb = fps_color(sample_fps);
            }
            return;
        }
        
        anchor.y -= SIZE.y + DEFAULT_SHADOW_BOX_BORDER * 2.;
    }

    int fps = int(round(iFrameRate));
    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS) && uint(fps - 1) < 9999u)
    {
        const int FPS_TEXT_LENGTH = 8; // 1234 FPS
        const int FPS_SUFFIX_GLYPHS = (_SPACE_<<24) | (_F_<<16) | (_P_<<8) | (_S_<<0);
    
    	vec2 text_pos = anchor - vec2((CHAR_SIZE << g_text_scale_shift) * ivec2(FPS_TEXT_LENGTH,1));
    
        ivec2 uv = text_uv(fragCoord - text_pos);
        if (line_index(uv.y) == 0)
        {
            int glyph = FPS_TEXT_LENGTH - 1 - glyph_index(uv.x);
            if (uint(glyph) < 4u)
                glyph = get_byte(glyph, FPS_SUFFIX_GLYPHS);
            else if (uint(glyph) < uint(FPS_TEXT_LENGTH))
                glyph = int_glyph(fps, glyph-4);
            else
                glyph = _SPACE_;

			if (glyph != _SPACE_)
            {
                vec4 color = vec4(vec3(.875), 1.);
                print_glyph(fragColor, uv, glyph, color);
            }
        }
    }
}

// Function 1372
vec4 drawPortal(vec2 uv)
{
    uv.y *= 4.0;
    
    vec4 noise = texture(iChannel0, uv * 0.1 + iTime * 0.01) - 0.5;
   
    uv.y -= smoothstep(1.0, 0.0, length(uv)) * 0.6;
    
    float angle = atan(uv.y, uv.x);
    angle += pow(length(uv), 1.4);
    
    uv.xy += (noise.xy) * 0.5;
    
    float arms = sin((angle * 7.0) + iTime * 0.5) * 0.5 + 0.5;
    arms *= sin((angle * 18.0) + iTime * 2.0) * 0.2 + 0.8;
    float bloom = smoothstep(1.0, 0.0, length(uv));
    float mask = smoothstep(2.0, 1.0, length(uv));
    float outline = smoothstep(0.2, 0.0, abs(length(uv) - 1.6));
   	
    vec4 portal = (vec4(arms) + bloom * 2.0) * mask + outline;
    portal -= mod(portal, vec4(1.0 / 8.0));
    
    return portal;
}

// Function 1373
vec4 drawSmallCloud(in float x, in float y)
{
    // smallCloudA actually appears twice.
	vec4 result = smallCloudPalette(smallCloudA(x,y,S_CLOUD_A_X,S_CLOUD_A_Y));
	result += smallCloudPalette(smallCloudB(x,y));
	result += smallCloudPalette(smallCloudA(x,y,S_CLOUD_C_X,S_CLOUD_C_Y));
	return result;
}

// Function 1374
float distCircleN(vec3 p, vec3 n, float r)
{
    return length(p-normalize(p-n*dot(n,p)/dot(n,n))*r);
}

// Function 1375
float drawCircle(vec2 p, float d, vec2 uv)
{
    return (distance(p, uv) <= d) ? 1. : 0.;
}

// Function 1376
float lineSegDist( vec2 uv, vec2 ba, vec2 a, float r ) {
    vec2 pa = uv - a - ba*r; ba = -ba*r;
    return length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) );
}

// Function 1377
vec3 random_cos_weighted_hemisphere_direction(const vec3 n, inout seed_t seed ) {
  	vec2 r = get_next_rnd(seed).xy;
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 1378
vec3 gettrilinear(float t) {
  int i = int(floor(t))%nsteps;
  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));
}

// Function 1379
vec3 randomSphereDirection(inout float seed) {
    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);
    float phi = h.y;
	return vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// Function 1380
bool drawText(int textNumber, ivec2 completeOffset, ivec2 uv, bool rightJustified)
{
    ivec4 offsets = unpack(textOffsets[textNumber]);

    print_pos = LINE_0_OFFSET(offsets.y);
    bool hit = drawLine(offsets.x, uv);

    if ((!hit) && (offsets.z > -1))
    {
        print_pos = LINE_1_OFFSET(offsets.w);
        hit = drawLine(offsets.z, uv);
    }

    return hit;
}

// Function 1381
maybe_float get_distance_along_2d_line_to_ray(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in vec2 B
){
    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0
    vec2 D = B0 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 1382
vec3 DoOutline(float d, vec3 color)
{
    float o = d + OUTLINE_OFFSET;
    if (o < 0.)
    {
        float t = -o / OUTLINE_THICKNESS;
        t = t * t;
        color = mix(OUTLINE_COLOR, color, step(OUTLINE_THRESHOLD, t));
    }
    return color;
}

// Function 1383
void drawCylinder(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 cylNorm;
    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);
    
    if(cylT < cur_ctxt.t)
    {
        cur_ctxt.t = cylT;
        
        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;
    
        cur_ctxt.materialType = DIFFUSE; 
        cur_ctxt.color = 0.3*texture(iChannel2, worldPos.xz * worldPos.y).rgb 
                                        + 0.7*texture(iChannel3, ray.dir).rgb;
        //cur_ctxt.color = vec3(1, 0, 0);
        cur_ctxt.n = cylNorm;
    }
}

// Function 1384
void circle(float x, float y, float r) { circle(vec2(x,y),r); }

// Function 1385
vec3 DrawWinLose(vec2 p, vec3 color)
{
    if(gState.x < 6.5) { return color; }
    color *= 0.65;
    
    vec2 hGridSize = vec2(xCells, yCells)*1.2;
    vec2 q = p - gridPos-hGridSize*0.5+0.6;
    color = DrawUIBox(q*vec2(0.05, 0.7), color);
    
    vec3 lettersColor = mix(vec3(0.203, 0.372, 0.917)*0.8, vec3(0.203, 0.372, 0.917), smoothstep(-0.6, 0.4, q.y));
    lettersColor = mix(lettersColor, mix(vec3(0.788, 0.133, 0.278)*0.8, vec3(0.788, 0.133, 0.278), smoothstep(-0.6, 0.4, q.y)), step(gState.z+0.5, gState.w));
    
    caret.x = count = 0.;
    q *= 1.+sin(gT*4.)*0.1;
    q -= vec2(-3., 0.);
    q*= 0.1;
    
    caret.x = count = 0.;
    float d = M(r(q)); add(); d += A(r(q));  add(); d += R(r(q));  add(); d += V(r(q));  add(); d += E(r(q));  add(); d += L(r(q));  add(); d += O(r(q));  add(); d += U(r(q));  add(); d += S(r(q));
    float dWin = d;
    caret.x = count = 0.;
    d = T(r(q)); add(); d += R(r(q));  add(); d += Y(r(q));  space(); d += A(r(q));  add(); d += G(r(q));  add(); d += A(r(q));  add(); d += I(r(q));  add(); d += N(r(q)); // add(); d += S(r(q));
    float dLose = d;
    d = mix(dWin, dLose, step(gState.z+0.5, gState.w));
    color = mix(color, lettersColor, smoothstep(0.5, 1.0, d));
    
    return color;
}

// Function 1386
bool rayIntersectsLineSegment(vec3 rayOrigin, vec3 rayDirection, vec3 point1, vec3 point2) {
    vec3 v1 = rayOrigin - point1;
    vec3 v2 = point2 - point1;
    vec3 v3 = vec3(-rayDirection.y, rayDirection.x, 0.0);

    float d = dot(v2, v3);
    if (abs(d) < 0.000001)
        return false;

    float t1 = cross2d(v2, v1) / d;
    float t2 = dot(v1, v3) / d;

    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0))
        return true;

    return false;
}

// Function 1387
void DrawPoint(vec2 origin, vec2 uv, float size, vec3 pointColor, inout vec3 sceneColor){
  float d = distance(uv, origin);
  sceneColor = mix(pointColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); 
}

// Function 1388
vec4 draw( vec2 uv ) {
    //return texture( iChannel0, uv );
    
    vec2 dirVec = VERT ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 );
    float wid = VERT ? iResolution.y : iResolution.x;
    float pos = VERT ? floor( uv.y * iResolution.y ) : floor( uv.x * iResolution.x );
    
    for ( int i = 0; i < int( wid ); i ++ ) {
        vec2 p = uv + dirVec * float( i ) / wid;
        if ( p.x < 1.0 && p.y < 1.0 ) {
            float v = fromRgb( texture( iChannel0, p ).xyz );
            if ( abs( v - pos ) < 0.5 ) {
                return texture( iChannel1, p );
                break;
            }
        }
        
        p = uv - dirVec * float( i ) / wid;
        if ( 0.0 < p.x && 0.0 < p.y ) {
            float v = fromRgb( texture( iChannel0, p ).xyz );
            if ( abs( v - pos ) < 0.5 ) {
                return texture( iChannel1, p );
                break;
            }
        }
    }
    
    return vec4( 1.0, 0.0, 1.0, 1.0 );
}

// Function 1389
maybe_vec2 get_distances_along_line_to_intersection(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.f;
    float y  = shape1.exists && shape2.exists ? min(shape1.value.y,  shape2.value.y ) : 0.f;
    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);
}

// Function 1390
bool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }

// Function 1391
void drawSeg(vec2 p, vec2 q, vec3 cpq, vec3 uv) {
    
    float d = abs(geodesicDist(cpq, uv.xy))-lineWidth;
    
    vec2 diff = normalize(q - p);
    
    d = max(d, dot(p - uv.xy, diff)-lineWidth);
    d = max(d, dot(uv.xy - q, diff)-lineWidth);
    d = max(d, length(uv.xy)-1.);
    
    inkDist = min(inkDist, d/uv.z);

}

// Function 1392
void drawBorder(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)
{   
    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&
        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {
        
        if (fragCoord.x >= position.x + BORDER_WIDTH &&
            fragCoord.x < (position.x + size.x - BORDER_WIDTH) &&
            fragCoord.y >= position.y + BORDER_WIDTH &&
            fragCoord.y < (position.y + size.y - BORDER_WIDTH)) {
            // Interior
        }
        else if (fragCoord.x >= position.x + BORDER_WIDTH - 1.0 &&
                 fragCoord.x < (position.x + size.x - BORDER_WIDTH + 1.0) &&
                 fragCoord.y >= position.y + BORDER_WIDTH - 1.0 &&
                 fragCoord.y < (position.y + size.y - BORDER_WIDTH + 1.0)) {
            color = vec3(0.0, 0.0, 0.0);
        }
        else {        
            color = vec3(193.0/255.0, 193.0/255.0, 193.0/255.0);
        
            // Overall border
            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, size);
            
            // Bottom-left
            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, position, vec2(23.0, 23.0));
            
            // Top-left
            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x, position.y + size.y - 23.0), vec2(23.0, 23.0));
            
            // Bottom-left
            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y), vec2(23.0, 23.0));
            
            // Top-left
            drawBox(color, vec3(193.0/255.0, 193.0/255.0, 193.0/255.0), vec3(0.0, 0.0, 0.0), fragCoord, vec2(position.x + size.x - 23.0, position.y + size.y - 23.0), vec2(23.0, 23.0));
        }        
    }
}

// Function 1393
float dline(vec2 p, vec2 lp, vec2 ld) {
    return dot(p-lp, ld);
}

// Function 1394
vec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)
{
    return mix(
        currentCol , 
        colLine ,
        1.0 - smoothstep(0.0,1.0,(( segment(uv,lineA,lineB).x * scale )))
    );
}

// Function 1395
vec3 COLcircle(vec2 p, float r, vec3 col)
{   
    float c = 1.0-SScircle(p, r);
    return c*col;   
}

// Function 1396
float rect(vec2 p,float a)
{
    return rect(p,a,a);
}

// Function 1397
float rectBox(in vec2 d_u, in vec2 d_v)
{
    float l_u = lineBox(d_u);
    float l_v = lineBox(d_v);
    return l_u*l_v;
}

// Function 1398
float sdLineSq( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return dot2( pa - ba*h );
}

// Function 1399
float circleSE(vec2 q, vec2 pos ) {
    vec2 p = q - pos;
    
    if(p.x > 0.0 && p.y < 0.0) {
        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;
    } else {
        return 10.0;
    }
}

// Function 1400
v3 linearGraph(v1 u,v0 h,v0 g
){d0 d=getd(u.x)
 ;//v0 div=sqrt(1.+p.y*p.y)
 ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick
 ;d=getd(u.x)
 ;//no analytical 2nd derivative, so this one sucks a bit
 ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick
 ;//this does not work for scaled p, is far from being user friendly
 ;v0 blur=20./max(iResolution.y,1.)
 ;v3 yellow =v3(v2(1,1,0),ssb(r))
 ;v3 cyan   =v3(v2(0,1,1),ssb(g))
 ;v3 magenta=v3(v2(1,0,1),ssb(b))
 ;return aOverB(aOverB(yellow,magenta),cyan);}

// Function 1401
void rounded_rectangle(vec2 o, vec2 s, float r) {
    s = (s * 0.5);
    r = min(r, min(s.x, s.y));
    o += s;
    s -= r;
    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;
    vec4 dmin = min(d,0.0);
    vec4 dmax = max(d,0.0);
    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);
    add_field(df - r);
}

// Function 1402
vec4 radialLines(vec2 fragCoord, vec2 center, float density, vec3 baseColor)
{
    const float lineWidth = 0.20;
    float spacing = 2.0 * PI / density;
    
    vec2 ray = fragCoord - center;
    float angle = atan(ray.y, ray.x);
    
    float intensity = step(mod(angle, spacing), lineWidth / length(ray));
    
	return vec4(baseColor * intensity, 1.0);
}

// Function 1403
float drawGoal(vec2 p){
	 return boxDist(translate(p, vec2(5.0, 225.0)), vec2(20.0, 20.0), 0.0);
    
}

// Function 1404
vec3 drawParticles(vec2 uv)
{  
    // Here the time is "stetched" with the time factor, so that you can make a slow motion effect for example
    time2 = time_factor*iTime;
    vec3 pcol = vec3(0.);
    // Main particles loop
    for (int i=1; i<nb_particles; i++)
    {
        pst = getParticleStartTime(i); // Particle start time
        plt = mix(part_life_time_min, part_life_time_max, random(float(i*2-35))); // Particle life time
        time4 = mod(time2 - pst, plt);
        time3 = time4 + pst;

        runnr = floor((time2 - pst)/plt);  // Number of the "life" of a particle
        vec2 ppos = getParticlePosition(i);
        float dist = distance(uv, ppos);
        if (dist<0.05) // When the current point is further than a certain distance, its impact is neglectable
        {
            // Draws the eight-branched star
            // Horizontal and vertical branches
            vec2 uvppos = uv - ppos;
            float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);
            float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);
            // Diagonal branches
            vec2 uvpposd = 0.707*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));
            float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);
            float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);
            // Initial intensity (random)
            float pint0 = mix(part_int_factor_min, part_int_factor_max, random(runnr*4. + float(i-55)));
            // Middle point intensity star inensity
            float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);


            // Intensity curve and fading over time
            float pint = pint0*(pow(pint1, ppow)/part_int_div)*(-time4/plt + 1.);

            // Initial growing of the paricle's intensity
            pint*= smoothstep(0., grow_time_factor*plt, time4);
            // "Sparkling" of the particles
            float sparkfreq = clamp(part_spark_time_freq_fact*time4, 0., 1.)*part_spark_min_freq + random(float(i*5 + 72) - runnr*1.8)*(part_spark_max_freq - part_spark_min_freq);
            pint*= mix(part_spark_min_int, part_spark_max_int, random(float(i*7 - 621) - runnr*12.))*sin(sparkfreq*twopi*time2)/2. + 1.;

            // Adds the current intensity to the global intensity
            pcol+= getParticleColor(i, pint);
        }
    }
    // Main particle
    vec2 ppos = getParticlePosition_mp();
    float dist = distance(uv, ppos);
    //if (dist<0.25)
    //{
        // Draws the eight-branched star
        // Horizontal and vertical branches
        vec2 uvppos = uv - ppos;
        float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);
        float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);
        // Diagonal branches
        vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));
        float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);
        float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);
        // Middle point intensity star inensity
        float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);
        
        if (part_int_factor_max*pint1>6.)
        {
            float pint = part_int_factor_max*(pow(pint1, ppow)/part_int_div)*mp_int;
            pcol+= getParticleColor_mp(pint);
        }
    //}
    return pcol;
}

// Function 1405
float circle(vec3 p, vec3 c, vec3 n, float r, float e, float R)
{
	vec3 rad = c + r * normalize(p - dot(p, n) * n);
	return e * falloff(distance(p, rad), R);
}

// Function 1406
float lineDistInf( vec3 p, vec3 a, vec3 b )
{
    return length( p-a - dot(p-a,b-a)*(b-a)/dot(b-a,b-a) );
}

// Function 1407
float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 46.0 * iTime;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/280.0),
                            -sin(theta0*M_PI/280.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 3.0) );
    	d = normalize(d);
        //compute gradient based on angle difference to theta0
   	 	float theta = mod(460.0*atan(d.y,d.x)/M_PI/theta0,250.0);
        float gradient = clamp(2.0-theta/100.0,0.0,2.0);
        return SMOOTH(l,20.0)+0.6*gradient;
    }
    else return 0.0;
}

// Function 1408
maybe_float get_distance_along_3d_line_to_capped_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r1,
    in float r2
){
    float dh = length(B2 - B1);
    float dr = r2 - r1;
    float rmax = max(r2, r1);
    float rmin = min(r2, r1);
    float hmax = rmax * dr / dh;
    float hmin = rmin * dr / dh;
    vec3 B = sign(dr) * normalize(B2 - B1);
    vec3 Bmax = (r2 > r1? B2 : B1);
    vec3 B0 = Bmax - B * hmax;
    vec3 Bmin = Bmax - B * hmin;
    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);
    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));
    float c_h = dot(A0 + cone.value * A - B0, B);
    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;
    cone = get_distance_along_line_to_union(cone, end1);
    cone = get_distance_along_line_to_union(cone, end2);
    return cone;
}

// Function 1409
void
drawRedstoneDust (inout vec4 color,
                  in vec2 pos,
                  in ivec3 coord, in float alphaScale, in float invScale)
{
    float t = 1000.;
    
    Voxel voxel = readVoxel(coord);
    
    bool magicBool = isVoxelAtCoordOpaque(coord + ivec3(0, 0, 1));
    int dummyZOffset;
	
    bool connectableLeft = isVoxelAtCoordDustConnectable(coord + ivec3(-1, 0, 0), dummyZOffset, magicBool);
    bool connectableRight = isVoxelAtCoordDustConnectable(coord + ivec3(1, 0, 0), dummyZOffset, magicBool);
	bool connectableBottom = isVoxelAtCoordDustConnectable(coord + ivec3(0, -1, 0), dummyZOffset, magicBool);
    bool connectableTop = isVoxelAtCoordDustConnectable(coord + ivec3(0, 1, 0), dummyZOffset, magicBool);
    
    bvec4 voxelsAroundConnectable = bvec4(connectableLeft, connectableRight, connectableBottom, connectableTop);  
    
    if (!any(voxelsAroundConnectable))
    {
        t = min(abs(pos.x), abs(pos.y));
    }
    else if (any(voxelsAroundConnectable.xy) && !any(voxelsAroundConnectable.zw))
    {
    	t = abs(pos.y);
    }
    else if (!any(voxelsAroundConnectable.xy) && any(voxelsAroundConnectable.zw))
    {
    	t = abs(pos.x);
    }
    else
    {
        if (voxelsAroundConnectable[0])
        {
        	t = min(t, max(abs(pos.y), pos.x) );
        }
        if (voxelsAroundConnectable[1])
        {
        	t = min(t, max(abs(pos.y), -pos.x) );
        }
        if (voxelsAroundConnectable[2])
        {
        	t = min(t, max(abs(pos.x), pos.y) );
        }
        if (voxelsAroundConnectable[3])
        {
        	t = min(t, max(abs(pos.x), -pos.y) );
        }
    }
    
    t -= REDSTONE_DUST_WIDTH*.5;
    
    float alpha = smoothstep(3., 0., t * invScale);
    
    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS,
                    alpha * alphaScale);
    
    //voxelColor.rgb *= voxelColor.a;
    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);
    color = mix(color, voxelColor, voxelColor.a /** (1.0 - color.a)*/);
}

// Function 1410
float lineAOv2(vec2 pos, vec2 line0, vec2 line1) {
	vec2 dir = normalize(line1- line0);
	vec2 rt = vec2(-dir.y,dir.x);
	float tp0 = dot(rt,line0);
	float tpx = dot(rt,pos);
	float bidp = dot(normalize(line0- pos),normalize(line1- pos))* bidpScale+ bidpAdd;
	float distf = clamp(abs(tp0- tpx)/ falloffDist,0.0,1.0);
	return 1.0- (1.0- bidp)* (1.0- pow(distf,falloffCurve));
}

// Function 1411
void DrawVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){
    
          uv  -= origin;
    float v2   = dot(vector, vector);
    float vUv  = dot(vector, uv);
    vec2  p    = vector * vUv/v2;
    float d    = distance(p, uv);
    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + 0.001, d));
    
}

// Function 1412
vec3 drawGame(ivec2 coord)
{
    GameData gd;
    loadGameData(gd);

    vec3 col;

    if (gd.gGameState == GAME_STATE_CAVE)
    {
        col = drawCave(coord, gd);
    }
    else
    {
        col = drawTitleScreen(coord, gd);
    }

    return col;
}

// Function 1413
float line( vec2 p, vec2 start, vec2 end, float wp )
{
    float d = line_d( p, start, end );
    float w = wp/iResolution.x;
    return smoothstep(w+5./iResolution.x,w,d);
}

// Function 1414
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	lowp vec2 r = hash2();
    
	lowp vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	lowp vec3  vv = cross( uu, n );
	
	lowp float ra = sqrt(r.y);
	lowp float rx = ra*cos(6.2831*r.x); 
	lowp float ry = ra*sin(6.2831*r.x);
	lowp float rz = sqrt( 1.0-r.y );
	lowp vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 1415
void draw(vec3 dir, vec3 center, vec3 normal, float radius, inout vec3 c)
{
    float antialiasing = 1.;
    //antialiasing = fract(1e4*sin(1e4*dot(dir, vec3(1., 7.1, 13.3)))); //Comment to see it without antialiasing/jittering
    vec3 p = cam+dir*antialiasing;
    int s = 0;
    
    vec3 h_col = vec3(1., .1, .8);
    
    float t = 1.;
    float dist_acc = 0.;
    
    float r_t = transp(p, uniform_step, .1);
    float g_t = transp(p, uniform_step, .9);
    float b_t = transp(p, uniform_step, .1);
    
    vec3 rgb_t = vec3(r_t, g_t, b_t);
    
    float r_t2 = transp(p, uniform_step, .9);
    float g_t2 = transp(p, uniform_step, .1);
    float b_t2 = transp(p, uniform_step, .1);
    
    vec3 rgb_t2 = vec3(r_t2, g_t2, b_t2);

    vec3 t_acc = vec3(1.);	// accumulated transparency
    vec3 t_acc2 = vec3(1.); //accumulated transparency
    
    for(s; s < 150; s++)
    {               
        
        float k_step = uniform_step;
        
        float dist_dist = dot(p-cam, p-cam);
        float dist_center = length(center-cam);
        
        //if too far, then big step        
        if(sqrt(dist_dist)-(dist_center-radius) < 0.)
        {
        	k_step = dist_center-(radius);
        }

        //if in the shape, draw
        if( sdf_sphere(p-center, RADIUS) <= 0.)
        {
            
           	//blending
        	c += t_acc*vec3(1.)*(1.-rgb_t);
			t_acc *= rgb_t;  
        }   
        
        if( sdf_sphere(p-vec3(2., -3., -2.), RADIUS-1.) <= 0.)
        {
            c += t_acc*vec3(1., 1., 0.)*(1.-rgb_t2);
			t_acc *= rgb_t2;
        }   
        
        //if it will never be in the shape anymore, return;
        if(length(p-cam) > max((dist_center+radius), (length(vec3(2., -3., -2.)-cam)+(radius-1.))))
        {
         	break;
        }
        
        p += dir*k_step;       
    }
}

// Function 1416
void DrawRect( inout DrawContext drawContext, vec3 vColor, vec2 vA, vec2 vB )
{
    vec2 vUV = drawContext.vUV;
    
    if ( InRect( vUV, vA, vB ) )
    {    
    	drawContext.vResult = vColor;
    }
}

// Function 1417
void drawSystemButton(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size, int type)
{
    drawBox(color, BORDER_FILL, BORDER_STROKE, fragCoord, position, size);
    
    if (type != SYSTEM_BUTTON_MENU) {
        // Draw Bevel
        drawBevel(color, BUTTON_HIGHLIGHT, BUTTON_SHADOW, fragCoord, position + vec2(1.0, 1.0), size - vec2(2.0, 2.0));
        drawBevel(color, BORDER_FILL, BUTTON_SHADOW, fragCoord, position + vec2(2.0, 2.0), size - vec2(4.0, 4.0));
    }
    
    if (type == SYSTEM_BUTTON_MENU) {
        // Draw wacky minus sign thingy
        drawBox(color, vec3(1.0, 1.0, 1.0), BUTTON_SHADOW, fragCoord, position + vec2(4.0, 8.0), vec2(13.0, 3.0));
        drawBox(color, vec3(1.0, 1.0, 1.0), BORDER_STROKE, fragCoord, position + vec2(3.0, 9.0), vec2(13.0, 3.0));
    }
    else if (type == SYSTEM_BUTTON_MINIMIZE) {
        // Draw Downward Facing Triangle... which is somehow not a yoga position
        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 15.0), vec2(7.0, 7.0), TRIANGLE_DOWN);
    }
    else if (type == SYSTEM_BUTTON_MAXIMIZE) {
        // Draw Upward Facing Triangle... which is somehow not a yoga position
        drawTriangle(color, BORDER_STROKE, fragCoord, position + vec2(6.0, size.y - 11.0), vec2(7.0, 7.0), TRIANGLE_UP);
    }
}

// Function 1418
float draw_scene(vec3 p)
	{
	float tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);
	float tunnel1_p=2.0;
	float tunnel1_w=tunnel1_p*0.225;
	float tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;	// tunnel1
	float tunnel2_p=2.0;
	float tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);
	float tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;	// tunnel2
	float hole1_p=1.0;
	float hole1_w=hole1_p*0.5;
	float hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;	// hole1
	float hole2_p=0.25;
	float hole2_w=hole2_p*0.375;
	float hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;	// hole2
	float hole3_p=0.5;
	float hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);
	float hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;	// hole3
	float tube_m=0.075*sin(PI*p.z*1.0);
	float tube_p=0.5+tube_m;
	float tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);
	float tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;			// tube
	float bubble_p=0.05;
	float bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);
	float bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;	// bubble
	return max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);
	}

// Function 1419
float circle(vec2 _st, float _radius){
    vec2 pos = 0.5 - _st;
    return smoothstep(_radius,_radius+0.01,length(pos));
}

// Function 1420
float circleDist( vec2 p){
  return length(p) - 1.0;
}

// Function 1421
float circleY(vec2 u){return u.y-sqrt(1.-(u.x*u.x));}

// Function 1422
float sdfCircle(vec2 pnt, vec2 center, float radius) {
  return length(pnt - center) - radius;
}

// Function 1423
float fisheye_direction(out vec3 rd)
{
  // Move screen coordinates to the center, so
  // it is bound to [-0.5,-0.5] and [0.5,0.5]
  vec2 uv = gl_FragCoord.xy / iResolution.xy - vec2(0.5);
  
  // Calculate polar coordinates (angle phi and length)
  float phi = atan(uv.x,uv.y);
  float l = length(uv);

  if (l > 0.5)
  {
  	// Return -1.0 because the calculated polar coordinates are 
  	// outside the half sphere
    return -1.0;
  }
  
  // Calculate ray direction
  float theta  = l * PI;
  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));
  
  // Formulas are on wikipedia:
  // https://en.wikipedia.org/wiki/Polar_coordinate_system
  return 1.0;
}

// Function 1424
vec4 draw_arrow(vec4 col, vec2 p, vec2 a, vec2 b)
{
    vec2 l = (a-b);
    
    float ang = 3.1415926/6.;
    
    vec2 r1 = vec2(cos(ang), sin(ang));
    vec2 r2 = vec2(cos(-ang), sin(-ang));
    vec2 p1 = b+l*mat2(r1.x, -r1.y, r1.y, r1.x)*0.2;
    vec2 p2 = b+l*mat2(r2.x, -r2.y, r2.y, r1.x)*0.2;
    
    
    float h = line(p, a, b);
    h = min(h, line(p, b, p1));
    h = min(h, line(p, b, p2));
    
    col = blend(col, vec4(0., 0.435, 1., smoothstep(0.01, 0., abs(h))));
 	return col;
}

// Function 1425
float dist_to_line(vec2 pt1, vec2 pt2, vec2 testPt)
{
  vec2 lineDir = pt2 - pt1;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = pt1 - testPt;
  return abs(dot(normalize(perpDir), dirToPt1));
}

// Function 1426
void DrawCar (in vec2 uv, inout vec3 pixelColor, vec4 backWheel, vec4 frontWheel, vec4 state, vec4 state2)
{
    // Draw the bike.  Note that we interpolate between last and
    // current simulation state, which makes the simulation look
    // smoother than it actually is!
   
    vec2 backWheelPos = AsyncPointPos(backWheel, VAR_FRAME_PERCENT);
    vec2 frontWheelPos = AsyncPointPos(frontWheel, VAR_FRAME_PERCENT);    
    
    // draw the wheels.
    DrawWheel(uv, backWheelPos, pixelColor, VAR_BACKWHEEL_ONGROUND == 1.0);
    DrawWheel(uv, frontWheelPos, pixelColor, VAR_FRONTWHEEL_ONGROUND == 1.0);       
    
    // draw the frame
    vec2 carOrigin = backWheelPos;
    vec2 xAxis = normalize(frontWheelPos - backWheelPos);
    vec2 yAxis = vec2(-xAxis.y, xAxis.x);
        
    vec2 uvRelative = uv - carOrigin;
    vec2 uvLocal;
    uvLocal.x = dot(uvRelative, xAxis);
    uvLocal.y = dot(uvRelative, yAxis);
    
#if 1
    float carDistance = UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.04), vec2(c_wheelDistance*1.6, 0.03), 0.035);
    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(-0.06,0.04), vec2(0.04,0.09), 0.01));
    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(0.04,0.09), vec2(0.08,0.09), 0.01));
    carDistance = min(carDistance, UDFatLineSegment(uvLocal, vec2(0.08,0.09), vec2(0.12,0.04), 0.01));
    carDistance -= 0.0025;    
	carDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, carDistance);
    pixelColor = mix(pixelColor, vec3(0.1, 0.0, 0.0), carDistance);

#else
    float carDistance = UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.04), vec2(c_wheelDistance*2.0, 0.04), 0.05);
    carDistance = min (carDistance, UDFatLineSegment(uvLocal, vec2(-c_wheelDistance*0.5, 0.09), vec2(c_wheelDistance, 0.09), 0.05));
    carDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, carDistance);
    pixelColor = mix(pixelColor, vec3(0.3,0.3,0.3), carDistance); 
#endif
    
}

// Function 1427
float rectAppSurface(vec3 view, vec3 normal, vec2 widths, bool isSingleFaced){
	return flatAppSurface(view, normal, widths.x*widths.y, isSingleFaced);
}

// Function 1428
float dfCircle(vec2 p, float radius){	
    return length(p) - radius;
}

// Function 1429
float circle(vec2 r, vec2 center, float radius) 
{
	return (1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center))) - (1.0 - smoothstep( radius * 0.99 -0.5, radius * 0.99 +0.5, length(r-center)));
}

// Function 1430
float sdCircle( vec2 p, float r ) { return length(p) - r; }

// Function 1431
vec3 drawTxt(vec2 uv, vec2 pos)
{
  float scale =0.2;
  float res;
  float offX = -0.05;
  float sp =.9;

  uv.y += 0.175;
  uv.y *= (sin(10.0*uv.x+iTime)+1.5)*0.5;

  res += drawL(uv, pos+vec2(sp*-0.1+offX,0.0), scale);
  res += drawO(uv, pos+vec2(sp*-0.07+offX,0.0), scale);
  res += drawA(uv, pos+vec2(sp*-0.03+offX,0.0), scale);
  res += drawD(uv, pos+vec2(offX,0.0), scale);
  res += drawI(uv, pos+vec2(sp*0.022+offX,0.0), scale);
  res += drawN(uv, pos+vec2(sp*0.045+offX,0.0), scale);
  res += drawG(uv, pos+vec2(sp*0.08+offX,0.0), scale);
  /*res += drawA(uv, pos+vec2(sp*0.15+offX,0.0), scale);
  res += drawN(uv, pos+vec2(sp*0.195+offX,0.0), scale);
  res += drawC(uv, pos+vec2(sp*0.235+offX,0.0), scale);
  res += drawY(uv, pos+vec2(sp*0.275+offX,0.0), scale);*/

  return vec3(max(1.-clamp(res,0.0,1.0), 0.4));
}

// Function 1432
vec3 DrawMap( vec2 vPixelCoord, vec2 vResolution )
{
    vec3 vResult = vec3(0.0);
    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 31.0);
    
    float fScale = 5.0;
    
    vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;

    MapInfo mapInfo = ReadMapInfo( MAP_CHANNEL );
    
    //if ( Key_IsToggled( KEY_TAB ) )
    {
        for(int iSectorIndex=0; iSectorIndex<mapInfo.iSectorCount; iSectorIndex++)
        {
            Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );
            
            /*if ( Map_PointInSector( vPixelWorldPos, sector ) )
            {
                vResult = vec3(1,0,0);
            }*/
            

            for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)
            {
                SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        

                vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );

                float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );
                fProj = clamp( fProj, 0.0, sideDef.fLength );
                
                vec2 vClosest = sideDef.vA + vSideDir * fProj;
                float fDist = length( vClosest - vPixelWorldPos );
                
                if (fDist < fScale * .5 )
                {
                    if ( sideDef.iNextSector != SECTOR_NONE )
                    {
	                    vResult = vec3(1,1,0);
                    }
                    else
                    {
	                    vResult = vec3(1,0,0);
                    }
                }
            }			
        }
    }    
    
    return vResult;
}

// Function 1433
float draw_float(vec2 p, float f){
    float color = draw_uint_with_sign(p, int(f), f < 0.0);
    p.x += float(MAX_DIGITS + 1)*DIGIT_WIDTH;
    
    // draw dot
    color += draw_char(p, DOT);
    p.x += DIGIT_WIDTH;
    
    // remove integer part
    f -= float(int(f));
    // shift fractional part into integer part
    f *= pow(float(BASE), float(MAX_DIGITS));
    
    // draw fractional part
    color += draw_uint(p, int(f));
    
    return color;
}

// Function 1434
float sdCircle(vec2 p, float r)
{
	return length(p)-r;
}

// Function 1435
vec3 drawScene(in vec3 origin, in vec3 direction)
{
    vec3 finalColor = vec3(1.0, 1.0, 1.0);
    vec3 directLight = vec3(0.0, 0.0, 0.0);
    float albedo = 0.9;
    float firstRayDistance;
    vec3 firstRayDirection;
    int object = 0;

    vec3 rayOrigin = origin;
    vec3 rayDirection = direction;
    firstRayDirection = rayDirection;

    seed = direction.xy * (float(iFrame) + 1.0);

    for (int i = 0; i < MAX_REFLECTIONS; i++)
    {
        float rayDistance = castRay(rayOrigin, rayDirection, object);
        if (i == 0)
        {
            firstRayDistance = rayDistance;
        }
        if (object != 0)
        {
            vec3 rayPosition = rayOrigin + rayDistance * rayDirection;

            vec3 surfaceColor = getColor(rayPosition, rayDirection, object);
            finalColor *= surfaceColor * albedo;

            vec3 rayNormal = getNormal(rayPosition);
            vec3 rayNewDirection = normalize(getSample(rayNormal));

            rayOrigin = rayPosition + rayNormal * MIN_DELTA * 2.0;
            rayDirection = rayNewDirection;

            vec3 sunDirection = lightvec;
            vec3 sunSampleDirection = getConeSample(sunDirection, 0.001);
            float sunLight = dot(rayNormal, sunSampleDirection);
            if (sunLight > 0.0)
            {
                castRay(rayOrigin, sunSampleDirection, object);
                if (object == 0)
                {
                    directLight += finalColor * sunLight * SUN_INTENSITY * SUN_COLOR;
                }
            }
        }
        else
        {
            finalColor = directLight + finalColor * getBackground(rayDirection);
            float fogVal = pow(clamp(firstRayDistance / MAX_DISTANCE, 0.0, 1.0), 4.0);
            finalColor = mix(finalColor, getBackground(firstRayDirection), fogVal);
            return finalColor;
        }
    }

    float fogVal = pow(clamp(firstRayDistance / MAX_DISTANCE, 0.0, 1.0), 4.0);
    finalColor = mix(vec3(0.0, 0.0, 0.0), getBackground(firstRayDirection), fogVal);
    return finalColor;
}

// Function 1436
vec4 drawModeRadius(in vec2 uv, in float mode, in float radius)
{
    vec4 tcol;
    if ((in_zone(mode, APPL_DRAW) || in_zone(mode, APPL_ERASE)) && iMouse.z > 0.5)
    {
        float ratio = iResolution.x / iResolution.y;
        float eps = 2. / iResolution.y;
        vec2 muv = iMouse.xy / iResolution.xy;
        vec2 diff = abs(muv - uv);
        diff.x *= ratio;
        diff = min((diff), (ratio - diff));
        float draw_rad = radius * RADIUS_COEFF;
        float rad = length(diff);
        
        float f = smoothstep(draw_rad - eps, draw_rad, rad) - smoothstep(draw_rad, draw_rad + eps, rad);
        float f2 = smoothstep(draw_rad - eps*2., draw_rad - eps, rad) - smoothstep(draw_rad - eps, draw_rad, rad);
        float f3 = smoothstep(draw_rad - eps*1.5, draw_rad - eps*.5, rad) - smoothstep(draw_rad - eps*.5, draw_rad + eps*.5, rad);
        
        
        tcol.x = f;
        tcol.y = .6 * f2;
        tcol.z = .7*f3;
    }
    
    return tcol;
}

// Function 1437
vec3 draw_line(float d) {
  return draw_line(d, 0.0025);
}

// Function 1438
float line_to(inout vec2 p, vec2 to, vec2 uv, float e)
{
	float d = segment_line(uv, e, p, to) * point(uv, e, to);
    p = to;
    return d;
}

// Function 1439
float segmented_spline_c5_rev( float y) {  
SegmentedSplineParams_c5 C = RRT_PARAMS();
const int N_KNOTS_LOW = 4;
const int N_KNOTS_HIGH = 4;
float coefsLow[6];
coefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;
coefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;
float coefsHigh[6];
coefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;
coefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;
float KNOT_INC_LOW = (log10(C.midPoint.x) - log10(C.minPoint.x)) / float(N_KNOTS_LOW - 1);
float KNOT_INC_HIGH = (log10(C.maxPoint.x) - log10(C.midPoint.x)) / float(N_KNOTS_HIGH - 1);
float KNOT_Y_LOW[ N_KNOTS_LOW];
for (int i = 0; i < N_KNOTS_LOW; i += 1) {
KNOT_Y_LOW[ i] = ( coefsLow[i] + coefsLow[i+1]) / 2.0;};
float KNOT_Y_HIGH[ N_KNOTS_HIGH];
for (int i = 0; i < N_KNOTS_HIGH; i += 1) {
KNOT_Y_HIGH[ i] = ( coefsHigh[i] + coefsHigh[i+1]) / 2.0;};
float logy = log10( max(y,TINY));
float logx;
if (logy <= log10(C.minPoint.y)) {
logx = log10(C.minPoint.x);
} else if ( (logy > log10(C.minPoint.y)) && (logy <= log10(C.midPoint.y)) ) {
int j;
vec3 cf;
if ( logy > KNOT_Y_LOW[ 0] && logy <= KNOT_Y_LOW[ 1]) {
cf.x = coefsLow[0];  cf.y = coefsLow[1];  cf.z = coefsLow[2];  j = 0;
} else if ( logy > KNOT_Y_LOW[ 1] && logy <= KNOT_Y_LOW[ 2]) {
cf.x = coefsLow[1];  cf[ 1] = coefsLow[2];  cf.z = coefsLow[3];  j = 1;
} else if ( logy > KNOT_Y_LOW[ 2] && logy <= KNOT_Y_LOW[ 3]) {
cf.x = coefsLow[2];  cf.y = coefsLow[3];  cf.z = coefsLow[4];  j = 2;
} 
vec3 tmp = MM * cf;
float a = tmp.x;
float b = tmp.y;
float c = tmp.z;
c = c - logy;
float d = sqrt( b * b - 4.0 * a * c);
float t = ( 2.0 * c) / ( -d - b);
logx = log10(C.minPoint.x) + ( t + float(j)) * KNOT_INC_LOW;
} else if ( (logy > log10(C.midPoint.y)) && (logy < log10(C.maxPoint.y)) ) {
int j;
vec3 cf;
if ( logy > KNOT_Y_HIGH[ 0] && logy <= KNOT_Y_HIGH[ 1]) {
cf.x = coefsHigh[0];  cf.y = coefsHigh[1];  cf.z = coefsHigh[2];  j = 0;
} else if ( logy > KNOT_Y_HIGH[ 1] && logy <= KNOT_Y_HIGH[ 2]) {
cf.x = coefsHigh[1];  cf.y = coefsHigh[2];  cf.z = coefsHigh[3];  j = 1;
} else if ( logy > KNOT_Y_HIGH[ 2] && logy <= KNOT_Y_HIGH[ 3]) {
cf.x = coefsHigh[2];  cf.y = coefsHigh[3];  cf.z = coefsHigh[4];  j = 2;
} 
vec3 tmp = MM * cf;
float a = tmp.x;
float b = tmp.y;
float c = tmp.z;
c = c - logy;
float d = sqrt( b * b - 4.0 * a * c);
float t = ( 2.0 * c) / ( -d - b);
logx = log10(C.midPoint.x) + ( t + float(j)) * KNOT_INC_HIGH;
} else {
logx = log10(C.maxPoint.x);
}
return pow(10.0, logx);
}

// Function 1440
uint direct_32( in vec3 nor )
{
    nor /= max(max(abs(nor.x),abs(nor.y)),abs(nor.z));

    vec3 v = 0.5 + 0.5*nor;
    uvec3 d = uvec3(round(v*vec3(2047.0,1023.0,2047.0)));
    return d.x|(d.y<<11u)|(d.z<<21u);
}

// Function 1441
ivec2 fromLinear2(in int index, in vec2 resolution, int mode) {
    if (mode == 0) {
    	return ivec2(index % int(resolution.x), index / int(resolution.x));
    } else {
        return ivec2(index / int(resolution.y), index % int(resolution.y));
    }
}

// Function 1442
float DrawChar(int char, vec2 pos, float fkd)
{
    float results = 0.;
    char *= 4;
    vec2 lastPoint = mix(vec2(Xs[char],Ys[char]),vec2(Xs[char+1],Ys[char+1]),.1);
    
    for (float i=0.; i<50.; i++)
    {
        float smoothv = 0.25;
        float progress = 3.*i/50.0+0.5;
        float lineProgress = fract(progress);
        int a=char+max(0,int(progress)-1),
            b=char+int(progress),
            c=char+min(3,int(progress)+1);
        
        vec2 iStart = mix(vec2(Xs[a],Ys[a]),vec2(Xs[b],Ys[b]),0.5*lineProgress+0.5+fkd);
        vec2 iEnd =   mix(vec2(Xs[b],Ys[b]),vec2(Xs[c],Ys[c]),lineProgress*0.5+fkd);
        vec2 charPos = mix(iStart,iEnd,lineProgress+fkd);
        
        //float thick = textThick * min(length(charPos-lastPoint),0.01);
        //float thick = 0.01+0.01*textThick * abs(dot(normalize(charPos-lastPoint),vec2(0.7,0.7))); caligraphy
        float val = length(pos-charPos)*25.0;
        if (val<1.)
        {
        	results += val*10.-2.;
        }
        //results *= clamp(val*10.-9.,0.,1.);
        //results += ((sin(20.*(length(pos-charPos)))));
        
        //if (results > 1.0)
        //    return results;
    //float pixelSize = uv.y/iResolution.y;
        //if (length(pos-charPos) < thick+0.01)
        //if (length(pos-charPos) < textThick * 0.02)
        //{
        	//if (abs((float(i)/90.0)-iTime*0.1) < 0.1)
            	//return 1.0;
        //}
        
        //float thickness = min(1.0,progress*3.0) * textThick * length(charPos-lastPoint) * 0.1;
        
        //results += max(0.0,(1.0 - length(pos-charPos) / thickness));
        
        lastPoint = charPos;
    }
    
    return results;
}

// Function 1443
float DrawWindow(vec2 uv, vec4 st, vec4 windowOffset)
{
    float window;
    float rows = windowOffset.w;
    float cols = windowOffset.z;

    for (float i = 0.; i < rows; i++)
    {
        for (float n = 0.; n < cols; n++)
        {
            vec2 offset = vec2(
                windowOffset.x * n, windowOffset.y * i) + st.zw;
            float wD = sdBox(uv + offset, st.xy);
            if (n == 0. && i == 0.) window = wD;
            else window = min(window, wD);
        }
    }
    return window;
}

// Function 1444
void newline()
{
	caret.x = caret_origin.x;
	caret.y -= .18;
}

// Function 1445
void DrawGlow(vec2 p, float t, vec3 fireColor, inout vec4 color)
{
    vec4 pFinalColor = DrawParticle(0., p, 20., min(t/0.15, 1.), fireColor, 0.1, 0.01, color.a, 0.);
    color.rgb += pFinalColor.rgb; color.a = pFinalColor.a;
}

// Function 1446
float linear_to_gamma(float f)
{
#if USE_GAMMA_CORRECTION == 2
    return sqrt(f);
#elif USE_GAMMA_CORRECTION == 1
    return f <= 0.0031308 ? f * 12.92 : (1.055 * pow(f, (1./2.4)) - 0.055);
#else
    return f;
#endif
}

// Function 1447
maybe_float get_distance_along_3d_line_to_ellipsoid(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 R
){
    // NOTE: shamelessly copy pasted, all credit goes to Inigo: 
    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    vec3 Or = (A0 - B0) / R;
    vec3 Ar = A / R;
    float ArAr = dot(Ar, Ar);
    float OrAr = dot(Or, Ar);
    float OrOr = dot(Or, Or);
    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);
    return maybe_float(
        (-OrAr - sqrt(h)) / ArAr, 
        h >= 0.0
    );
}

// Function 1448
void rect(float x, float y, float w, float h) {
	if (fragCoord.x >= x) {
		if (fragCoord.y > y) {
			if (fragCoord.x - x <= w) {
				if (fragCoord.y - y <= h) {
					fragColor = vec4(0.5, 0.5, 0.5, 1.0);
				}
			}
		}
	}
}

// Function 1449
maybe_float get_distance_along_3d_line_nearest_to_line_segment(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B1
){
    vec3 B = normalize(B1 - B0);
    vec3 D = B0 - A0;
    // offset
    vec3 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B1 - B0));
}

// Function 1450
float circle(vec2 p, float r, float t, vec2 uv) {
 
    float dst = length(p-uv)-r;
    float ax  = asin(p.x-uv.x);
    dst = max(dst,-(length(p-uv)-r*.5+.1*sin(ax*25.+t*5.)));
    return dst;
    
}

// Function 1451
float drawASCIIChar(vec2 uv, vec2 pos, vec2 sz, int id)
{
    id = id - 32; // ascii correction (first 32 chars is invisible!!)
    // 5x5 bitmaps
    const int[] glyphs = int[95]
    ( 
     0, 4329476, 10813440, 11512810, 31636111, 18092113, 6339118, 4325376, 4261956, 
     4464900, 12582912, 145536, 130, 14336, 4, 17043521, 33080895, 4396164, 33061951, 
     33062431, 18415120, 32570911, 32570943, 33038468, 33095231, 33095199, 131200, 131202,
     17173904, 1016800, 1269953, 15216644, 15246428, 4540401, 16301615, 15238702, 16303663, 
     32570431, 32570401, 31520302, 18415153, 14815374, 14950662, 18128177, 1082431, 
     11195953, 18470705, 15255086, 16301089, 15255000, 16301617, 31504911, 32641156,
     18400814, 18400580, 18405034, 18157905, 18157700, 32772191, 6359110, 1118480,
     12853516, 4521984, 31, 2097152, 207306, 1088807, 459822, 17330780, 13203548,
     8534148, 4534534, 2169162, 4198532, 467206, 75978, 135300, 513717, 477778, 412236, 
     477634, 412560, 921732, 12652806, 4657288, 608860, 574788, 579242, 331914, 602242,
     991390, 4264004, 4329604, 4460804, 87296 
    );
    vec2 pt = (uv - pos) * (vec2(1.0) / sz) - vec2(0.1, 0.1);
    ivec2 xy = ivec2(round(pt * vec2(4.5, 5.0)));
    float gv = float((glyphs[id] >> int(xy.y * 5 + xy.x)) & 1);
    
	return gv * float(pt.x < 1.0 && pt.y < 1.0 &&
                      uv.x > pos.x && uv.y > pos.y);
}

// Function 1452
float linedist(vec3 p, vec3 a, vec3 b) {
  float k = dot(p-a,b-a)/dot(b-a,b-a);
  return distance(p, mix(a,b,clamp(k,0.,1.)));
}

// Function 1453
vec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {
    
    vec3 c2 = -0.5 * p0	+  0.5 * p2;
	vec3 c3 =        p0	+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;
    vec3 c4 = -0.5 * p0	+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;
	
    return(((c4 * t + c3) * t + c2) * t + p1);
}

// Function 1454
vec4 scanlines(in vec2 pos, in vec4 col)
{
    float scanline = clamp(0.94 + 0.08 * cos(3.141593 * (pos.y + 0.0034 * iTime) * PAL_LINES), 0., 1.);
	float grid = 0.8 + clamp(1.5 * cos(3.141593 * pos.x * PAL_WIDTH), 0., 1.);
    return vec4(col.rgb * scanline * grid *1.2, 1.);
}

// Function 1455
bool isInRect(vec2 coord,vec4 pos)
{
	return pos.x<=coord.x && coord.x<=pos.x+pos.z && pos.y<=coord.y && coord.y<=pos.y+pos.w;
}

// Function 1456
float lineDist(vec2 p, vec2 a, vec2 v)
{
    vec2 pa = p - a;
    float h = clamp(dot(pa,v)/dot(v,v), 0.0, 1.0);
    return length(pa - v*h);
}

// Function 1457
vec3 line4D(in vec3 p, vec4 p1, vec4 dp) {
    p1+=mv4D;
    //dp+=mv4D;
 	vec3 pa = p-p1.xyz, ba = dp.xyz;
    float k = clamp(dot(pa,ba)/dot(ba,ba),0., 1.);
    return vec3(length(pa - ba*k) - RAYON ,k, p1.w +k*dp.w);}

// Function 1458
float sdf_line4(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AB = vert_A - vert_B;
    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.
    vec2 some_vector = vec2(sin(angle), sin(angle - asin(1.)));
    return -dot(uv, some_vector);  // Signed distance!
    //return abs(dot(uv, some_vector));  // Unsigned distance!
}

// Function 1459
bool inRect(vec2 compA, vec2 compB, vec2 rectSize)
{
    vec2 delta = abs(compA - compB);
    delta += delta - 1.0;
    delta = step(rectSize, delta);
    return delta.x + delta.y < 0.5;
}

// Function 1460
vec2 circle( in float t )
{
    #if REPARAMETRIZE==1
    float i = floor(4.0*t);
    float s = fract(4.0*t);

    // pick some other smoothstep-like polynomial
    s = s*s*s*(5.0+s*(6.0+s*(-15.0+s*(-21.0+s*(+54.0+s*(-36.0+s*8.0))))));
    
    t = (i+s)/4.0;
    #endif
  
    const float pi = 3.1415926535;
    vec2 p = vec2( cos(2.0*pi*t), sin(2.0*pi*t));
    return sign(p)*pow(abs(p),vec2(1.0/3.0)); // cubic root
}

// Function 1461
float onCircleAA( const vec2 c, const vec2 centre, const float radius, const float aa ) {
	return sat( aa*(radius - distance(c,centre)) );
}

// Function 1462
float circleFill(vec2 uv, vec2 center, float radius) {
    float r = length(uv - center);
    return smoothFloat(r, radius);
}

// Function 1463
vec4 outlineBlur(sampler2D sampler, vec2 uv, float outlineSize)
{
 	vec4 blur = blurTexture(sampler, uv, 4.0, 7.0);
    vec4 col = 1.0 - smoothstep(0.0, 0.5, abs(blur - 0.5));
    
    return col;
}

// Function 1464
float DistLine(vec3 ro, vec3 rd, vec3 p)
{
    return length(cross(p-ro,rd))/length(rd);
}

// Function 1465
vec4 tileCircle(vec2 tileCoord, vec2 windowCoord, float lum)
{
    // First, get center of circle for this tile
    vec2 tileSize = getTileSize();
    
    vec2 tileStart = tileCoord * tileSize;
    
    vec2 circleCenter = tileStart + 0.5 * tileSize;
    
    //float circleRadius = length(tileSize) * (iResolution.y / iResolution.x) * 0.5;
    float circleRadius = length(tileSize) * 0.5;
    
    circleRadius *= lum;
    
    float d = length(windowCoord - circleCenter);
    
    if (d < circleRadius)
    {
        return vec4(vec3(1), 1.0);
    }
    else
    {
        return vec4(0);
    }
}

// Function 1466
float Linear(float x, float a, float b){return  a*(x*(b/a-1.)+1.);}

// Function 1467
float drawPoint(vec2 point, vec2 uv, float rad, float fade)
{
	return 1.-smoothstep(rad,rad+fade, length(uv-point));
}

// Function 1468
vec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {
    vec2 r = vec2(Xi1,Xi2)*TWO_PI;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dot(dr,n) * dr;
}

// Function 1469
void process_text_message_line( int i, inout int N,
                            	inout vec4 params, inout uvec4 phrase, inout vec4 argv )
{
    float x = ( 1. + 2. * ( 1. - fract( 1. - memload( iChannel0, ADDR_MESSAGES, 0 ).x ) ) ) * g_textres.x / 2.;
    float y = g_textres.y / 4. + 16.;
    switch( i - N )
    {
    case 0:
        params = vec4( x - g_textres.x, y, 1, 15 );
        phrase = unpack_uvec4( memload( iChannel0, ADDR_MESSAGES, 1 ) );
        phrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;
        argv = memload( iChannel0, ADDR_MESSAGES, 1 + TXT_MSG_MAX_PHRASES );
        break;
    case 1:
        params = vec4( x, y, 1, 15 );
        phrase = unpack_uvec4( memload( iChannel0, ADDR_MESSAGES, 2 ) );
        phrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;
        argv = memload( iChannel0, ADDR_MESSAGES, 2 + TXT_MSG_MAX_PHRASES );
        break;
    }
    N += 2;
}

// Function 1470
vec4 circle_mask_color(Circle circle, vec2 position)
{
	float d = distance(circle.center, position);
	if(d > circle.radius)
	{
        //Mask color (Black)
		return vec4(0.0, 0.0, 0.0, 1.0);
	}
	
	float distanceFromCircle = circle.radius - d;
	float intencity = smoothstep(
								    0.0, 1.0, 
								    clamp(
                                        //Size of Circles for Goggles (0.0, 1.0, 0.0, 1.0)
									    remap(distanceFromCircle, 0.1, 0.3, 0.0, 1.0),
									    0.0,
									    1.0
								    )
								);
	return vec4(intencity, intencity, intencity, 1.0);
}

// Function 1471
float PointLineSegDist2d(vec2 a, vec2 b, vec2 p)
{
    p -= a; b -= a;                        // go to A referential
    float q = dot(p, b) / dot(b, b) ;      // projection of P on line AB: normalized ordinate
    b *= clamp(q, 0., 1.);                 // point on segment AB closest to P 
    return length( p - b);                 // distance to P
}

// Function 1472
float line(vec2 p, vec2 a,vec2 b, out float s) {
    p -= a, b -= a;
    s = clamp(dot(p, b) / dot(b, b), 0., 1.);  // proj coord on line
    p -= b * s;                                // s = ordinate on segment;
    return length(p);                          // dist to segment
}

// Function 1473
vec2 outlineCurve(vec2 uv) {
	//Set the position of the outline diagonal 
	uv = (uv - 0.5) * 2.0;
	uv *= 1.1;
	
	//Warps(for lack of a better term) the image on the x and y axis	
	uv.x *= 1.0 + pow((abs(uv.y) / 4.0), 2.5);
	uv.y *= 1.0 + pow((abs(uv.x) / 3.5), 2.5);
	
	uv = (uv / 2.0) + 0.5;
	uv = uv * 0.92 + 0.04;
	
	return uv;
}

// Function 1474
void drawFunc(float y, float dy, float r, vec4 col)
{
    float d = abs(y - xy.y);
    float yspan = sqrt(1.0 + dy * dy); // accurate, decent approximate: abs(dy) + 1.0 / (abs(dy) + 1.0)
	mixColor(col, lerpstep(yspan * (r + aa), yspan * (r - aa), d));
}

// Function 1475
vec3 GammaCorrect(vec3 color)
{
    return pow(color, vec3(1.0 / 2.2));
}

// Function 1476
vec4 drawCircle(vec4 pixel, vec2 uv, vec2 position, float size, vec4 color) {
    if (dist(uv, position) < size) {
    	pixel = color;   
    }
    return pixel;    
}

// Function 1477
vec4 draw_mothership( ivec2 pos, ivec2 iu ) {
    vec3 v ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), mothership_dim ) ) {
        int x = iu.x, y = iu.y ;
        PREPARE_TEST_BIT ;
        BR16(6,   _,_,_,_,_,w,w,w,w,w,w,_,_,_,_,_  ) ;
        BR16(5,   _,_,_,w,w,w,w,w,w,w,w,w,w,_,_,_  ) ;
        BR16(4,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,_,_  ) ;
        BR16(3,   _,w,w,_,w,w,_,w,w,_,w,w,_,w,w,_  ) ;
        BR16(2,   w,w,w,w,w,w,w,w,w,w,w,w,w,w,w,w  ) ;
        BR16(1,   _,_,w,w,w,_,_,w,w,_,_,w,w,w,_,_  ) ;
        BR16(0,   _,_,_,w,_,_,_,_,_,_,_,_,w,_,_,_  ) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 1478
vec4 DirectionalBlur(in vec2 UV, in vec2 Direction, in float Intensity, in sampler2D Texture)
{
    vec4 Color = vec4(0.0);  
    float Noise = texture(iChannel1,UV*NoiseScale).x-0.485;
    
    if (UseNoise==false)
    for (int i=1; i<=Samples/2; i++)
    {
    Color += texture(Texture,UV+float(i)*Intensity/float(Samples/2)*Direction);
    Color += texture(Texture,UV-float(i)*Intensity/float(Samples/2)*Direction);
    }
	else      
    for (int i=1; i<=Samples/2; i++)
    {
    Color += texture(Texture,UV+float(i)*Intensity/float(Samples/2)*(Direction+NoiseStrength*Noise));
    Color += texture(Texture,UV-float(i)*Intensity/float(Samples/2)*(Direction+NoiseStrength*Noise));  
    }    
    return Color/float(Samples);    
}

// Function 1479
float SakeobaCircle(vec2 pos){
    vec2 pp = polar(rotate(pos, -iTime) * 0.75);
    vec2 md = mod(rotate(pp * vec2(2.0, 32.0), M_PI05), vec2(16.0, 4.0));
    return Saketoba(md - vec2(3.5, 1.5), 0.05) * smoothstepLine(6.5, 7.5, pp.x, 1.5) * min(min(1.0, md.x), 16.0 - md.x);
}

// Function 1480
bool Rect_ContainsPoint( Rect rect, vec2 vPos )
{
    if (   vPos.x >= rect.m_min.x && vPos.x < rect.m_max.x 
        && vPos.y >= rect.m_min.y && vPos.y < rect.m_max.y ) return true;
    
    return false;
}

// Function 1481
float line(in vec2 p, in vec2 a, in vec2 b, float r)
{
    vec2 ba = b - a;
    vec2 pa = p - a;
    
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
    
    return length(pa - ba * t) - r;
}

// Function 1482
float round_line( in vec2 p, in vec2 a, in vec2 b, in float r )
{
  return line(p,a,b) - r;
}

// Function 1483
float UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab
    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)
    //The clamp provides the line seg limits. e is therefore the "capped orthogogal projection".
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 1484
float aaa_line( mat2 K, vec2 uv, vec2 x0, vec2 x1, float width )
	{ return aaa_line( K, uv - x0, x1 - x0, width ); }

// Function 1485
float SparkCircle(vec2 uv, vec2 center, float rad)
{
    float d = length(uv - center);
    return smoothstep(rad, 0.0, d);
}

// Function 1486
float draw_char(sampler2D tex) {
    int c = char_id; vec2 p = char_pos;
    if (c < 0) return 0.;
    return textureGrad(tex, p/16. + fract( vec2(c, 15-c/16) / 16. ), 
                       dFdx(p/16.),dFdy(p/16.) ).x;
}

// Function 1487
vec3 SampleInterpolationTextureBilinear (vec2 uv)
{
    vec2 pixel = uv * 2.0 - 0.5;
    vec2 pixelFract = fract(pixel);
    
    vec3 pixel00 = SampleInterpolationTexturePixel(floor(pixel) + vec2(0.0, 0.0));
    vec3 pixel10 = SampleInterpolationTexturePixel(floor(pixel) + vec2(1.0, 0.0));
    vec3 pixel01 = SampleInterpolationTexturePixel(floor(pixel) + vec2(0.0, 1.0));
    vec3 pixel11 = SampleInterpolationTexturePixel(floor(pixel) + vec2(1.0, 1.0));
    
    vec3 row0 = mix(pixel00, pixel10, pixelFract.x);
    vec3 row1 = mix(pixel01, pixel11, pixelFract.x);
    
    return mix(row0, row1, pixelFract.y);
}

// Function 1488
vec3 gammaToLinear(vec3 col) {
    return pow(col, vec3(GAMMA));
}

// Function 1489
void sdLine(inout vec4 dis_col,in vec2 p, vec2 a, vec2 b,vec3 cu0,vec3 cv0,vec3 cu1,vec3 cv1)
{
    vec2 pa = p-a;
    vec2 ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);
    float d = length(pa-h*ba);
    if( d<dis_col.x )
    {
        float s = pa.x*ba.y-pa.y*ba.x;
        h = 1.0-h;
        dis_col = vec4(d,(s<0.0)?mix(cu0,cu1,h):mix(cv0,cv1,h));
    }
}

// Function 1490
vec3 WorldSpaceToDirectionalLightSpace (vec3 worldPosition)
{
	vec3 localPosition = (GetDirectionalLightMatrix() * vec4(worldPosition, 1.0)).xyz; 
    localPosition.xz /= directionalLightExtents;
    return localPosition;
}

// Function 1491
vec3 draw_bg_and_tick(vec2 uv)
{ 
    float tickCenter = (1. + 2. * TICK_WIDTH) * fract(iTime * .1) - TICK_WIDTH;
    float f = abs(uv.x - tickCenter);

    float beamSpread = .1;
    float lightBeam = smoothstep( TICK_WIDTH + beamSpread, TICK_WIDTH - beamSpread, f);
            
    vec3 lightColor = mix(vec3(1., 0., 0.),  vec3(1.4, .4, .3), lightBeam);
    
    lightColor *= atmos( 6. * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth

    return .3 * mix( lightColor, vec3(.1,.1,.1), uv.y);
}

// Function 1492
vec4 ct_circle(
    in vec2 c,
    in vec2 z,
    in float radius
){
    float d = length(c - z);
    
    if (d < radius) 
    {
        d = d / radius;
        float b = -(.25 + abs(sin(iTime)));
        return exp(b*dot(d,d) ) * vec4(1,.7,.4,0)*2.;
    }
    
    return vec4(0.0, 0.0, 0.0, 0.0);
}

// Function 1493
float sdLine(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    return length(pa - ba * dot(pa, ba) / dot(ba, ba)); // No clamp needed here, the cells do it
}

// Function 1494
bool RayRectIntersect(Ray ray, Rect rect, out float t)
{
    bool intersect = RayPlaneIntersect(ray, rect.plane, t);
    if (intersect)
    {
        vec3 pos  = ray.origin + ray.dir*t;
        vec3 lpos = pos - rect.center;
        
        float x = dot(lpos, rect.dirx);
        float y = dot(lpos, rect.diry);    

        if (abs(x) > rect.halfx || abs(y) > rect.halfy)
            intersect = false;
    }

    return intersect;
}

// Function 1495
float sdLine(vec2 a, vec2 b, vec2 p)
{
    a -= p;
    b -= p;
    vec2 ba = b-a;
    return length(a + ba * clamp( -dot(a,ba)/dot(ba,ba),0.0,1.0));
}

// Function 1496
float nearestline(vec2 p, vec2 centre, vec3 mobius, out float index) {
  float A = mobius.x, B = mobius.y, C = mobius.z;
  p -= centre;
  float t = p.y/p.x;
  // Look out for infinities here
  if (p.x == 0.0) sign(p.y)*1e4;
  //t = atan(A*tan(t+B)+C);
  t = A*(t+B)/(1.0-t*B)+C;
  t = atan(t);
  // Add time offset and round to nearest line
  t = t/PI+0.05*iTime;
  t *= N;
  t = mod(round(t),N);
  index = t;
  t /= N;
  return t;
}

// Function 1497
bool line (vec2 a, vec2 b, vec2 p)
{
    vec2 c = b - a;
    c = normalize(vec2(c.y, -c.x));
    return abs(dot(c, a - p)) < 0.002;
}

// Function 1498
vec4 drawFarClouds(in float x, in float y)
{
    // Above? Nada.
    if(y < FAR_CLOUD_Y) return TRANS;
    // Below? Fill'er'in.
    else if(y > FAR_CLOUD_Y+5.0) return L_BLUE;
    // Within the narrow band designated for the clouds?
    else return farCloudsPalette(farClouds(x,y-FAR_CLOUD_Y));
}

// Function 1499
float Linear_from_ACEScc(float cc) 
{
    if (cc < -0.3013698630)
    	return exp2(cc * 17.52 - 9.72)*2.0 - exp2(-16.0)*2.0;
    
    return exp2(cc * 17.52 - 9.72);
}

// Function 1500
vec3 drawFire(vec2 p) {
  return mix(vec3(1.,1.,1.), burn(p), 0.7);
}

// Function 1501
vec4 overlaySpline(inout vec4 rgba, vec2 uv, vec4 strokeCol, vec2 p1, vec2 p2, vec2 p3, vec3 iResolution){
	float d = approx_distance((1. - uv)*iResolution.xy, p1*iResolution.xy, p2*iResolution.xy, p3*iResolution.xy);
	float thickness = 1.0;
	float a;
	if(d < thickness) {
	  a = 1.;
	} else {
	  a = 1. - smoothstep(d, thickness, thickness+0.5);
	}
    rgba = mix(rgba, strokeCol, a * strokeCol.a); 
    return rgba;
}

// Function 1502
float line_sqdist(vec2 uv, vec2 a, vec2 b)
{
    vec2 ab = b-a, ap = uv-a;
    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);
    return length_squared(uv - (ab*t + a));
}

// Function 1503
float udLine(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);
    return length(pa - ba*h);
}

// Function 1504
vec3 drawPathAndNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec3 pathColor, in float normLength )
{
    vec3 d = vec3(1000.0);
    for( int i=0; i<kNumPoints; i++ )
    {
        vec2 a = path[(i-1+kNumPoints)%kNumPoints];
        vec2 b = path[(i+0+kNumPoints)%kNumPoints];
        vec2 c = path[(i+1+kNumPoints)%kNumPoints];

        vec2 n = computeTangent( a, b, c );
        
        n = normLength*normalize(vec2(n.y, -n.x ));

        d = min( d, vec3(sdSegmentSq(p,b,c), 
                         sdPointSq(p,b),
                         sdSegmentSq(p,b,b+n)) );
    }
    d = sqrt(d);

    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.x) );
    col = mix( col, pathColor, 1.0-smoothstep(5.0*e,6.0*e,d.y) );
    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.z) );
    
    return col;
}

// Function 1505
vec4 pulseDrawFunc(in vec2 coord, vec2 pixel, float time, vec2 pv, vec2 sx, vec2 sy, vec4 color){
    // Draw shadow
    
    // Vertical
    if(abs(sx.y - coord.y * 2. * SCALE_Y + SCALE_Y) < pixel.y * 5.)
        return color;
    
	// Horizontal
    if(abs(sy.x - coord.x * 2. * SCALE_X + SCALE_X) < pixel.x * 5.)
		return color;    
    
    // Draw point
    if(sqrt(pow(abs(pv.y - coord.y * 2. * SCALE_Y + SCALE_Y) / pixel.y * 1., 2.)
       + pow(abs(pv.x - coord.x * 2. * SCALE_X + SCALE_X) / pixel.x * 1., 2.)) < 30.
      )
        return color;
    
    return vec4(0, 0, 0, 1.0);  
}

// Function 1506
vec4 texture3DLinear(sampler2D tex, vec3 uvw, vec3 vres)
{
    vec3 blend = fract(uvw*vres);
    vec4 off = vec4(1.0/vres, 0.0);
    
    vec4 b000 = texture3D(tex, uvw + off.www, vres);
    vec4 b100 = texture3D(tex, uvw + off.xww, vres);
    
    vec4 b010 = texture3D(tex, uvw + off.wyw, vres);
    vec4 b110 = texture3D(tex, uvw + off.xyw, vres);
    
    vec4 b001 = texture3D(tex, uvw + off.wwz, vres);
    vec4 b101 = texture3D(tex, uvw + off.xwz, vres);
    
    vec4 b011 = texture3D(tex, uvw + off.wyz, vres);
    vec4 b111 = texture3D(tex, uvw + off.xyz, vres);
    
    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), 
               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),
               blend.z);
}

// Function 1507
maybe_vec2 get_distances_along_2d_line_to_triangle(
    in vec2 A0,
    in vec2 A,
    in vec2 B1,
    in vec2 B2,
    in vec2 B3
){
    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);
    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);
    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);
    return maybe_vec2(
        vec2(min(line1.value, min(line2.value, line3.value)), 
             max(line1.value, max(line2.value, line3.value))), 
        line1.exists || line2.exists || line3.exists
    );
}

// Function 1508
float onRect( const vec2 c, const vec2 lt, const vec2 rb ) {
	return onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );
}

// Function 1509
vec3 drawTitle( in vec2 fragCoord, 
               // TODO --- these are equidistant, so why not pass in START and DELTA_X?
               float mx0, 
               float mx1, 
               float mx2, 
               float mx3, 
               float mx4,
               float mx5)
{
    vec3 color = BG_COLOR;
    
    float scale  = iResolution.x;
    float center = (mx1 - mx0) * 0.5 * scale;

    gvPrintCharXY.y = iResolution.y - gvFontSize.y - 1.;
    
    gvPrintCharXY.x = mx0*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord, 45.); // -

    gvPrintCharXY.x = mx1*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord, 81.); // Q
    color = Char( color, COLOR_TITLE, fragCoord, 67.); // C

    gvPrintCharXY.x = mx2*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord,  2.); // 2
    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *

    gvPrintCharXY.x = mx3*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord,  3.); // 3
    color = Char( color, COLOR_TITLE, fragCoord, 68.); // D

    gvPrintCharXY.x = mx4*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord, 78.); // N
    color = Char( color, COLOR_TITLE, fragCoord, 42.); // *

    gvPrintCharXY.x = mx5*scale - center;
    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R
    color = Char( color, COLOR_TITLE, fragCoord, 1. ); // 1

    gvPrintCharXY.x = mx5*scale + center;
    //                          ^-- positive, to show on the other side of the line

    color = Char( color, COLOR_TITLE, fragCoord, 82.); // R
    color = Char( color, COLOR_TITLE, fragCoord, 2. ); // 2

    return color;
}

// Function 1510
vec3 drawNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec2 norm[kNumPoints], in vec3 pathColor, in float normLength )
{
    float d = 1000.0;
    for( int i=0; i<kNumPoints; i++ )
    {
        vec2 b = path[i];
        vec2 n = normLength*normalize(norm[i]);

        d = min( d, sdSegmentSq(p,b,b+n) );
    }
    d = sqrt(d);

    return mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d) );
}

// Function 1511
float draw_string (sampler2D sampler,                    \
                   in vec2 uv, const uint[1+N] string) { \
  int i = int(uv.x);                                     \
  int strlen = min(int(string[0]),N*4);                  \
  if (uv.x<0.||i>=strlen) return 0.;                     \
  int code = int( (string[i/4+1]>>((i%4)*8)) &0xFFu);    \
  if (uv.y<0.||uv.y>1.) return 0.;                       \
  uv.x=fract(uv.x)/2.+.25; uv.y=1.-uv.y;                 \
  uv+=vec2(code%16,15-code/16);                          \
  return texture(sampler, uv/16.).r;                   }

// Function 1512
void DrawR( inout vec3 color, float x, float y )
{
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if (    ( x <= 3.0 )
			 || ( y >= 12.0 && x <= 11.0 )
             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )
             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )
             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )
             || ( x >= 8.0  && y <= 1.0 )
             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )
           )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 1513
float BisectSpline(Spline s, FactorsOfP fp, vec3 Q, float a, float b, float fa )
{
//	float fa = DistanceSqFirstDeriv(s,Q,a);

	float p = a+(b-a)*0.5;

	for (int n=0; n<4; n++)
	{
		float fp = DistanceSqFirstDeriv(s,fp,Q,p);
		if (fa*fp > 0.)
		{
			a=p;
			fa = fp;
		}
		else
		{
			b = p;
		}

		p = a+(b-a)*0.5;
	}

	return p;
}

// Function 1514
float drawMerge(vec2 uv) {
	vec2 offset = vec2(.3,0);
    float left = circleSDF(uv+offset);
    float right = circleSDF(uv-offset);
    return flip(stroke(left,.5,.05), fill(right,.5));
}

// Function 1515
void drawDodecahedron(Ray ray, inout TraceResult cur_ctxt)
{
    drawPentagon(ray, cur_ctxt, Pent1);
    drawPentagon(ray, cur_ctxt, Pent2);
    drawPentagon(ray, cur_ctxt, Pent3);
    drawPentagon(ray, cur_ctxt, Pent4);
    drawPentagon(ray, cur_ctxt, Pent5);
    drawPentagon(ray, cur_ctxt, Pent6);
    drawPentagon(ray, cur_ctxt, Pent7);
    drawPentagon(ray, cur_ctxt, Pent8);
    drawPentagon(ray, cur_ctxt, Pent9);
    drawPentagon(ray, cur_ctxt, Pent10);
    drawPentagon(ray, cur_ctxt, Pent11);
    drawPentagon(ray, cur_ctxt, Pent12);
}

// Function 1516
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
	float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line
	return length(p - b * h);                         // dist to segment
}

// Function 1517
void Line( inout vec3 o, vec2 a, vec2 b, float h, vec3 i, vec2 uv )
{
    if ( length(a-b) <= .0001 ) return;
    
    float t = dot(uv-a,b-a)/dot(b-a,b-a);
    t = clamp( t, .0, 1. );
    vec2 p = mix( a, b, t ); // this should be the closest point on the line
    o = mix( i, o, smoothstep( h-.7, h+.7, length(uv-p) ) );
}

// Function 1518
float circle(float radius, vec2 pos){
	return radius - pos.x;
}

// Function 1519
Model drawBloom(
    vec3 p,
    float t,
    vec2 density,
    float thickness,
    float pointy,
    float width,
    bool hideInside
) {
    pR(p.xz, .7);

    Model model = newModel();

    t = rangec(-.1, 1., t);

    p.y -= mix(0., .25, t);

    vec2 move = vec2(0, t);
    float stretchStart = density.x;
    float stretchEnd = density.y;
    float stretch = mix(stretchStart, stretchEnd, t);
    float maxBloomOffset = PI / 5.;

    vec2 cell = vec2(
        atan(p.x, p.z),
        atan(p.y, length(p.xz)) + maxBloomOffset
    );

    mat2 mStretch = mat2(1,0,0,stretch);
    mat2 transform = phyllotaxis * mStretch;
    mat2 transformI = inverse(transform);
    bool shrinkOuter = hideInside;

    // compile speed optim from IQ
    for( int m=ZERO; m<3; m++ )
    for( int n=ZERO; n<3; n++ )
    {
        model = opU(model, leaf(
            p,
            calcCellData(cell, vec2(m,n)-1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t, hideInside),
            thickness,
            pointy,
            width,
            shrinkOuter
        ));
    }

    return model;
}

// Function 1520
float lineDist(vec2 pos, vec2 p1, vec2 p2)
{
	// Ray representing the line segment
	vec2 ray = p2 - p1;

	// Length of the ray squared (to avoid sqrt)
	float lenSq = dot(ray*ray, vec2(1));

	// Distance from the start of the segment, where a line going through it and
	// position will be perpendicular to the ray
	float perp = dot(pos - p1, ray)/lenSq;

	// Intersection of perpendicular line and the original line segment,
	// projecting position onto the line segment
	vec2 proj = p1 + perp*ray;

	return distance(pos, proj);
}

// Function 1521
float sdLine(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));
}

// Function 1522
ComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)
{
    return M_mapTripleToTriple(
        Complex(-1, 0), Complex(0, 0), Complex(1, 0),
        L, c, R);
}

// Function 1523
v2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo
){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}

// Function 1524
vec4 drawGuybrush(int frame, ivec2 position, ivec2 offset)
{
    if ((any(lessThan(position, offset))) || (any(greaterThanEqual(position, offset + guybrushFrameSize))))
    {
     	return vec4(0.0);
    }
    
    ivec2 pixel = position - offset;
    int i = pixel.y * guybrushFrameSize.x + pixel.x;

#if (ANIMATION_FRAMES > FRAMES_NONE)
	if (frame == 0)
	{
        if ((i < 306) || (i > 5829))
        {
            return vec4(0.0);
        }
        
        const int frame[] = int[](306,307,308,309,310,311,322,323,324,325,326,327,328,329,434,16777651,33554868,33554869,33554870,33554871,450,451,452,16777669,33554886,33554887,33554888,33554889,562,563,33554996,33554997,566,578,579,580,50332229,67109446,583,33555016,691,33555124,33555125,694,83886786,100664003,117441220,134218437,150995654,117441331,167772980,67109685,184550210,201327427,218104644,234881861,218104755,134218676,150995893,184550326,184550338,201327555,218104772,218104773,234882100,201327669,184550454,184550455,184550466,201327683,218104900,218104901,218105012,201327797,201327798,184550583,184550584,184550594,201327811,218105028,218105029,218105030,218105141,201327926,201327927,184550712,184550713,184550722,201327939,218105156,218105157,218105158,218105269,218105270,201328055,201328056,184550841,184550842,184550850,184550851,201328068,201328069,201328070,201328182,1591,1592,1593,1594,1595,1602,1603,1604,1605,1606,1717,1718,1719,1720,16778937,33556154,1723,1724,1730,1731,1732,1733,1734,1735,1845,1846,16779063,251660088,251660089,33556282,1851,1852,1857,1858,1859,16779076,33556293,1862,1863,1974,1975,33556408,251660217,251660218,33556411,1980,1981,1984,1985,1986,16779203,251660228,33556421,1990,2103,2104,33556537,251660346,251660347,2108,2109,2110,2111,2112,2113,16779330,33556547,251660356,2117,2118,2232,2233,33556666,251660475,33556668,2237,2238,2239,2240,16779457,33556674,251660483,33556676,2245,2360,2361,33556794,251660603,251660604,33556797,2366,2367,16779584,33556801,251660610,251660611,2372,2373,2489,33556922,33556923,251660732,33556925,33556926,33556927,33556928,251660737,251660738,33556931,2500,2617,2618,33557051,251660860,251660861,251660862,251660863,251660864,251660865,33557058,2627,2628,2745,2746,33557179,251660988,251660989,251660990,67111615,268438208,67111617,2754,2755,2874,33557307,33557308,251661117,251661118,268438335,251661120,285215553,2882,2883,3002,3003,33557436,251661245,251661246,67111871,268438464,67111873,3010,184552505,201329722,201329723,184552508,218106941,201329726,201329727,184552512,201329729,184552514,184552633,201329850,218107067,218107068,218107069,218107070,218107071,184552640,218107073,218107074,301993268,301993269,301993270,201329977,218107194,218107195,218107196,218107197,218107198,218107199,201329984,184552769,218107202,184552771,301993395,318770612,318770613,301993398,301993399,201330106,218107323,218107324,218107325,218107326,218107327,335547840,352325057,369102274,201330115,184552904,184552905,318770739,385879604,318770741,318770742,318770743,301993528,301993529,184553018,184553019,218107452,218107453,218107454,218107455,369102400,369102401,402656834,218107459,184553028,201330245,201330246,184553031,184553032,201330249,419434058,301993547,318770764,318770765,318770766,318770767,318770768,301993558,318770775,150998616,318770868,385879733,385879734,318770871,318770872,318770873,318770874,184553147,201330364,201330365,201330366,218107583,218107584,436211393,352325314,369102531,201330372,184553157,218107590,184553159,201330376,184553161,452988618,419434187,385879756,385879757,385879758,385879759,385879760,385879761,385879762,318770899,301993684,301993685,469765846,301993687,150998744,184553268,201330485,201330486,385879863,318771000,385879865,385879866,318771003,201330492,218107709,218107710,218107711,218107712,369102657,486543170,218107715,218107716,184553285,218107718,201330503,218107720,201330505,218107722,318771019,385879884,385879885,385879886,385879887,385879888,385879889,385879890,301993811,67112788,301993813,301993814,318771031,150998872,201330613,184553398,234885047,134221752,385879993,385879994,385879995,234885052,201330621,218107838,218107839,218107840,218107841,335548354,352325571,369102788,184553413,201330630,201330631,218107848,201330633,218107850,201330635,385880020,385880021,385880022,385880023,385880024,150999001,150999002,201330651,201330652,201330653,201330654,201330655,201330656,201330742,218107959,134221880,385880121,318771258,234885179,218107964,218107965,218107966,218107967,218107968,218107969,486543426,369102915,218107972,201330757,201330758,201330759,218107976,150999127,201330785,201330786,218108003,218108004,218108005,218108006,218108007,218108008,201330872,385880249,234885306,218108091,218108092,218108093,218108094,218108095,218108096,201330881,201330882,201330883,218108100,201330885,150999255,218108137,218108138,218108139,201330924,201330925,201330926,201330927,201331001,201331002,201331003,201331004,201331005,201331006,218108223,218108224,201331009,201331010,385880387,318771524,201331013,201331133,201331134,201331135,201331136,134222273,385880514,318771651,301994436,419434949,301994557,301994558,503321151,503321152,301994561,385880642,318771779,385880644,385880645,385880646,301994685,301994686,520098495,536875712,301994689,385880770,385880771,385880772,318771909,318771910,520098623,301994816,318772033,385880898,385880899,385880900,385880901,385880902,301994823,520098751,301994944,318772161,385881026,318772163,385881028,385881029,385881030,385881031,301995071,301995072,301995073,318772290,301995075,385881156,5189,553653318,301995199,301995200,301995201,301995202,520099011,385881284,570430661,385881286,301995327,301995328,301995329,301995330,301995331,587208004,385881413,603985222,301995335,520099144,301995456,301995457,301995458,301995459,301995460,301995461,301995462,301995463,301995464,301995584,520099393,301995586,301995587,301995588,301995589,520099398,301995591,520099522,301995715,301995716,520099525);

		for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return guybrushColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
	
#if (ANIMATION_FRAMES >= FRAMES_FIGHT)
	if (frame == 1)
	{
        if ((i < 306) || (i > 5829))
        {
            return vec4(0.0);
        }
        
        const int frame[] = int[](306,307,308,309,310,311,322,323,324,325,326,327,328,329,434,16777651,33554868,33554869,33554870,33554871,450,451,452,16777669,33554886,33554887,33554888,33554889,562,563,33554996,33554997,566,578,579,580,50332229,67109446,583,33555016,691,33555124,33555125,694,83886786,100664003,117441220,134218437,150995654,117441331,167772980,67109685,184550210,201327427,218104644,234881861,218104755,134218676,150995893,184550326,184550338,201327555,218104772,218104773,234882100,201327669,184550454,184550455,184550466,201327683,218104900,218104901,218105012,201327797,201327798,184550583,184550584,184550594,201327811,218105028,218105029,218105030,218105141,201327926,201327927,184550712,184550713,184550722,201327939,218105156,218105157,218105158,218105269,218105270,201328055,201328056,184550841,184550842,184550850,184550851,201328068,201328069,201328070,201328182,1591,1592,1593,1594,1595,1602,1603,1604,1605,1606,1717,1718,1719,1720,16778937,33556154,1723,1724,1730,1731,1732,1733,1734,1735,1845,1846,16779063,251660088,251660089,33556282,1851,1852,1857,1858,1859,16779076,33556293,1862,1863,1974,1975,33556408,251660217,251660218,33556411,1980,1981,1984,1985,1986,16779203,251660228,33556421,1990,2103,2104,33556537,251660346,251660347,2108,2109,2110,2111,2112,2113,16779330,33556547,251660356,2117,2118,2232,2233,33556666,251660475,33556668,2237,2238,2239,2240,16779457,33556674,251660483,33556676,2245,201328873,201328874,201328875,201328876,2360,2361,33556794,251660603,251660604,33556797,2366,2367,16779584,33556801,251660610,251660611,2372,2373,201328997,201328998,201328999,201329000,2489,33556922,33556923,251660732,33556925,33556926,33556927,33556928,251660737,251660738,33556931,2500,201329121,201329122,201329123,201329124,2617,2618,33557051,251660860,251660861,251660862,251660863,251660864,251660865,33557058,2627,2628,150997587,218106462,218106463,218106464,218106465,2745,2746,33557179,251660988,251660989,251660990,67111615,268438208,67111617,2754,2755,385878739,150997716,218106586,218106587,218106588,218106589,2874,33557307,33557308,251661117,251661118,268438335,251661120,285215553,2882,2883,318770002,301992787,150997844,150997846,201329495,201329496,201329497,3002,3003,33557436,251661245,251661246,67111871,268438464,67111873,3010,301992912,318770129,385878994,301992915,318770132,150997973,184552505,201329722,201329723,184552508,218106941,201329726,201329727,184552512,201329729,184552514,318770255,385879120,385879121,385879122,385879123,385879124,150998101,184552633,201329850,218107067,218107068,218107069,218107070,218107071,184552640,218107073,218107074,201329865,318770381,318770382,385879247,385879248,385879249,318770386,318770387,150998229,301993268,301993269,301993270,201329977,218107194,218107195,218107196,218107197,218107198,218107199,201329984,184552769,218107202,184552771,184552776,218107209,620760394,318770507,318770508,385879373,385879374,385879375,150998357,301993395,318770612,318770613,301993398,301993399,201330106,218107323,218107324,218107325,218107326,218107327,335547840,352325057,369102274,201330115,184552903,201330120,218107337,620760522,385879499,385879500,385879501,318770638,318770739,385879604,318770741,318770742,318770743,301993528,301993529,184553018,184553019,218107452,218107453,218107454,218107455,369102400,369102401,402656834,218107459,184553028,201330245,201330246,117444167,201330248,218107465,620760650,318770763,385879628,318770868,385879733,385879734,318770871,318770872,318770873,318770874,184553147,201330364,201330365,201330366,218107583,218107584,436211393,352325314,369102531,201330372,184553157,218107590,218107591,201330376,218107593,234884810,201330379,201330380,184553268,201330485,201330486,385879863,318771000,385879865,385879866,318771003,201330492,218107709,218107710,218107711,218107712,369102657,486543170,218107715,218107716,184553285,218107718,218107719,218107720,201330505,218107722,201330507,201330613,184553398,234885047,134221752,385879993,385879994,385879995,234885052,201330621,218107838,218107839,218107840,218107841,335548354,352325571,369102788,184553413,201330630,201330631,218107848,201330742,218107959,134221880,385880121,318771258,234885179,218107964,218107965,218107966,218107967,218107968,218107969,486543426,369102915,218107972,201330757,201330758,218107975,201330872,385880249,234885306,218108091,218108092,218108093,218108094,218108095,218108096,201330881,201330882,201330883,218108100,201330885,218108102,201331001,201331002,201331003,201331004,201331005,201331006,218108223,218108224,201331009,201331010,385880387,318771524,201331013,201331133,201331134,201331135,201331136,134222273,385880514,318771651,301994436,419434949,301994557,301994558,503321151,503321152,301994561,385880642,318771779,385880644,385880645,385880646,301994685,301994686,520098495,536875712,301994689,385880770,385880771,385880772,318771909,318771910,520098623,301994816,318772033,385880898,385880899,385880900,385880901,385880902,301994823,520098751,301994944,318772161,385881026,318772163,385881028,385881029,385881030,385881031,301995071,301995072,301995073,318772290,301995075,385881156,5189,553653318,301995199,301995200,301995201,301995202,520099011,385881284,570430661,385881286,301995327,301995328,301995329,301995330,301995331,587208004,385881413,603985222,301995335,520099144,301995456,301995457,301995458,301995459,301995460,301995461,301995462,301995463,301995464,301995584,520099393,301995586,301995587,301995588,301995589,520099398,301995591,520099522,301995715,301995716,520099525);
        
        for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return guybrushColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}

#if (ANIMATION_FRAMES >= FRAMES_ALL)
	if (frame == 2)
	{
        if ((i < 308) || (i > 5326))
        {
            return vec4(0.0);
        }

		const int frame[] = int[](308,309,310,311,312,313,322,323,324,325,326,327,328,329,436,16777653,33554870,33554871,33554872,33554873,450,451,16777668,33554885,33554886,33554887,33554888,33554889,564,565,33554998,33554999,568,578,579,580,50332229,67109446,583,33555016,693,33555126,33555127,696,117441219,100664004,318767813,150995654,117441334,167772983,67109688,218104644,201327429,184550214,184550215,218104758,134218679,150995896,184550329,218104773,201327558,184550343,184550344,234882103,201327672,184550457,184550458,218104901,218104902,201327687,184550472,184550473,218105015,201327800,201327801,184550586,184550587,218105030,218105031,201327816,1225,1226,218105144,201327929,201327930,184550715,1340,201327942,201327943,1352,1353,1354,1355,218105272,218105273,184550842,184550843,1468,1469,1470,1479,1480,1481,16778698,1483,1484,1485,201328185,1594,1595,1596,16778813,1598,1599,1608,16778825,251659850,251659851,33556044,1613,1614,1721,1722,16778939,33556156,251659965,33556158,1727,1728,1729,1736,1737,33556170,251659979,33556172,33556173,1742,1743,1850,1851,33556284,251660093,251660094,251660095,33556288,1857,1858,1863,1864,1865,1866,33556299,251660108,251660109,1870,1871,1979,1980,1981,33556414,251660223,251660224,33556417,1986,1987,1990,1991,16779208,33556425,33556426,251660235,251660236,1997,1998,2109,33556542,251660351,251660352,33556545,33556546,2115,2116,2117,2118,16779335,33556552,251660361,251660362,33556555,2124,2125,2237,2238,33556671,251660480,251660481,33556674,33556675,2244,2245,2246,33556679,33556680,251660489,33556682,2251,2252,2366,2367,33556800,251660609,251660610,33556803,33556804,33556805,33556806,251660615,33556808,2377,2378,2379,2495,33556928,33556929,251660738,251660739,67111364,268437957,67111366,268437959,33556936,2505,2506,2623,2624,2625,33557058,251660867,268438084,251660869,268438086,251660871,33557064,2633,2752,2753,33557186,251660995,251660996,67111621,268438214,67111623,637536968,2761,184552255,184552256,184552257,184552258,201329475,201329476,201329477,184552262,201329479,184552264,150997862,184552383,184552384,201329601,201329602,201329603,218106820,201329605,201329606,184552391,201329608,184552393,184552405,184552406,184552407,201329624,318770148,385879013,150997990,184552512,201329729,201329730,218106947,218106948,218106949,218106950,352324679,352324680,654314569,184552522,184552528,201329745,184552530,201329747,201329748,184552533,201329750,218106967,201329752,419433561,318770266,318770267,318770268,318770269,318770270,301993058,301993059,385879140,318770277,150998118,184552640,184552641,201329858,218107075,218107076,218107077,218107078,369102023,369102024,402656457,117443786,201329867,184552652,184552653,184552654,201329871,218107088,201329873,184552658,218107091,218107092,218107093,201329878,218107095,201329880,419433689,385879258,385879259,385879260,385879261,385879262,385879263,318770400,301993185,67112162,671091939,520096996,469765349,385879270,150998247,150998248,201329897,201329898,201329899,201329900,201329901,201329902,201329903,201329904,201329905,218107122,218107123,218107124,218107125,218107126,218107127,218107128,218107129,218107130,201329915,201329916,201329917,201329918,201329919,301993275,301993276,301993277,184552769,201329986,201329987,201329988,201329989,218107206,218107207,436211016,352324937,352324938,369102155,201329996,201329997,218107214,218107215,218107216,218107217,218107218,218107219,218107220,402656597,201330006,218107223,218107224,385879385,385879386,385879387,385879388,385879389,385879390,385879391,385879392,318770529,385879394,385879395,385879396,385879397,150998374,301993402,301993403,318770620,318770621,301993406,687869375,201330112,184552897,184552898,201330115,218107332,218107333,218107334,218107335,369102280,369102281,486542794,218107339,218107340,218107341,201330126,218107343,218107344,218107345,201330130,201330131,201330132,201330134,201330135,150998502,301993530,318770747,385879612,385879613,318770750,234884671,218107456,184553025,201330242,201330243,218107460,201330245,218107462,218107463,218107464,218107465,335547978,352325195,369102412,218107469,201330254,218107471,201330256,201330257,201330258,150998630,301993657,318770874,385879739,385879740,318770877,234884798,218107583,201330368,201330369,218107586,218107587,218107588,218107589,218107590,218107591,218107592,218107593,486543050,369102539,218107596,218107597,218107598,201330383,301993785,301993786,385879867,318771004,218107710,201330495,218107712,218107713,218107714,218107715,218107716,218107717,218107718,201330503,218107720,218107721,201330506,201330507,385879884,318771021,201330510,318771128,318771129,318771130,301993915,184553408,201330625,201330626,201330627,201330628,201330629,218107846,218107847,201330632,201330633,134221770,385880011,318771148,301993933,419434446,318771256,385880121,385880122,318771259,301994054,301994055,503320648,503320649,301994058,385880139,318771276,385880141,385880142,385880143,318771385,385880250,301994171,385880252,301994182,301994183,520097992,536875209,301994186,385880267,385880268,385880269,318771406,318771407,385880377,385880378,385880379,520098120,301994313,318771530,385880395,385880396,385880397,385880398,385880399,301994320,520098248,301994441,318771658,385880523,318771660,385880525,385880526,385880527,385880528,301994568,301994569,301994570,318771787,301994572,385880653,4686,553652815,301994696,301994697,301994698,301994699,520098508,385880781,570430158,385880783,301994824,301994825,301994826,301994827,301994828,587207501,385880910,603984719,301994832,520098641,301994953,301994954,301994955,301994956,301994957,301994958,301994959,301994960,301994961,301995081,520098890,301995083,301995084,301995085,301995086,520098895,301995088,520099019,301995212,301995213,520099022);
        
		for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return guybrushColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
	
	if (frame == 3)
	{
        if ((i < 300) || (i > 5685))
        {
            return vec4(0.0);
        }

		const int frame[] = int[](300,301,302,303,304,305,322,323,324,325,326,327,328,329,428,16777645,33554862,33554863,33554864,433,450,451,16777668,33554885,33554886,33554887,33554888,33554889,557,33554990,33554991,33554992,561,578,579,580,50332229,67109446,583,33555016,685,33555118,33555119,688,83886786,83886787,100664004,318767813,150995654,117441325,704643886,553648943,520094512,184550210,201327427,201327428,234881861,218104749,721421230,201327535,184550320,184550321,184550337,184550338,201327555,218104772,218104878,201327663,201327664,184550449,184550450,184550464,184550465,201327682,218104899,218104900,218105006,218105007,201327792,201327793,184550578,184550591,184550592,201327809,201327810,218105027,218105135,201327920,201327921,184550706,1331,1332,1342,1343,100664640,201327937,218105154,218105155,1456,1457,1458,1459,1460,1461,1469,1470,1471,1472,1473,100664770,1584,16778801,33556018,33556019,1588,1589,1597,1598,16778815,33556032,1601,1602,1712,1713,251659954,251659955,33556148,1717,1718,1724,1725,16778942,251659967,251659968,1729,1730,1841,33556274,251660083,251660084,33556277,1846,1847,1851,1852,16779069,251660094,251660095,33556288,1857,1969,1970,33556403,251660212,33556405,33556406,1975,1978,1979,16779196,33556413,251660222,251660223,1984,1985,2098,33556531,251660340,251660341,33556534,2103,2104,2105,2106,2107,33556540,251660349,33556542,2111,2112,2226,33556659,251660468,251660469,33556662,33556663,2232,2233,2234,16779451,251660476,33556669,2238,2239,2354,33556787,251660596,251660597,33556790,33556791,33556792,33556793,33556794,33556795,33556796,33556797,2366,2482,2483,33556916,251660725,251660726,251660727,251660728,251660729,251660730,251660731,2492,2493,2494,2611,33557044,251660853,251660854,251660855,67111480,268438073,67111482,285215291,2620,2621,2739,33557172,33557173,251660982,251660983,268438200,251660985,285215418,33557179,2748,184552243,184552244,184552245,201329462,201329463,184552248,184552249,184552250,2875,2876,318770099,385878964,234884021,218106806,218106807,218106808,184552377,201329594,184552379,3004,301993009,318770226,385879091,419433524,620760117,620760118,234884151,218106936,201329721,184552506,184552507,301993020,301993132,301993133,301993134,318770351,318770352,385879217,385879218,419433651,301993140,301993141,738200758,218107063,218107064,184552633,201329850,201329851,687869116,419433661,318770366,318770367,318770368,318770369,150998218,301993257,301993258,318770475,318770476,318770477,385879342,385879343,385879344,318770481,385879346,385879347,385879348,301993269,620760374,184552759,184552760,117443897,218107194,184552763,218107196,620760381,385879358,385879359,385879360,385879361,385879362,318770499,318770500,301993285,318770502,318770503,318770504,385879369,150998346,184552872,318770601,318770602,385879467,385879468,385879469,385879470,385879471,754978224,771755441,201330098,234884531,385879476,385879477,218107318,184552887,117444024,218107321,218107322,201330107,218107324,201330109,788532670,385879487,385879488,385879489,385879490,385879491,301993412,67112389,301993414,301993415,385879496,318770633,150998474,184553000,419434025,385879594,385879595,385879596,385879597,419434030,452988463,100666928,184553009,201330226,201330227,234884660,385879605,218107446,201330231,218107448,218107449,218107450,201330235,218107452,201330237,385879621,385879622,385879623,385879624,318770761,150998602,201330344,687869609,620760746,318770859,318770860,301993645,452988590,218107567,218107568,201330353,218107570,218107571,218107572,218107573,218107574,218107575,402656952,201330361,201330362,318770887,385879752,805310153,150998731,201330380,201330381,201330382,687869738,201330475,201330476,687869741,201330478,218107695,218107696,184553265,201330482,218107699,218107700,218107701,218107702,218107703,201330488,150998857,201330511,201330512,201330513,201330514,218107820,218107821,218107822,218107823,218107824,201330609,201330610,218107827,218107828,436211637,352325558,369102775,201330616,150998984,201330643,201330644,218107861,218107862,201330734,201330735,201330736,201330737,218107954,218107955,201330740,369102901,369102902,201330743,218107990,218107991,218107992,218107993,201330862,218108079,218108080,201330865,201330866,385880243,318771380,201330869,201330870,218108122,218108123,218108124,201330909,201330991,201330992,134222129,385880370,318771507,301994292,419434805,201331038,201331039,201331040,301994413,301994414,503321007,503321008,301994417,385880498,318771635,385880500,385880501,385880502,301994541,301994542,520098351,536875568,301994545,385880626,385880627,385880628,4661,520098479,301994672,318771889,385880754,385880755,385880756,570430133,385880758,301994679,301994799,301994800,318772017,385880882,318772019,385880884,385880885,385880886,385880887,301994927,301994928,301994929,318772146,301994931,385881012,5045,553653174,301995055,301995056,301995057,301995058,520098867,385881140,570430517,385881142,301995183,301995184,301995185,301995186,301995187,587207860,385881269,603985078,301995191,520099000,301995312,301995313,301995314,301995315,301995316,301995317,301995318,301995319,301995320,301995440,520099249,301995442,301995443,301995444,301995445,520099254,301995447,520099378,301995571,301995572,520099381);
        
		for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return guybrushColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
#endif
#endif
#endif

    return vec4(0.0);
}

// Function 1525
float circle(vec2 uv, float r) {
    return -(length(uv) - r);
}

// Function 1526
vec4 drawCellAmoeba(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    Sprite sprite = getSpriteAmoeba(animFrame);
    colors[1] = COLOR01(ivec3(75, 88, 0));
    return sampleSprite(sprite, colors, coord);
}

// Function 1527
maybe_float get_distance_along_3d_line_to_plane(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 N
){
    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);
}

// Function 1528
float LongLine( vec2 a, vec2 b, vec2 p )
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba)/dot(ba,ba), gSegmentGap, 1.0 - gSegmentGap);
    return smoothstep(gSegmentWidth, gSegmentWidth * 0.9, Manhattan(pa - ba*t));
}

// Function 1529
bool circle_contains_point(vec2 c, float r, vec2 p) {
    return length(c - p) <= r;
}

// Function 1530
float drawObject(in vec3 p){
    
    // Anything that wraps the domain will work. The following looks pretty intereting.
    //p = cos(p*3.14159 + iTime)*0.5; 
    //p = abs(cos(p*3.14159)*0.5);
    
    // Try this one for a regular, beveled Voronoi looking pattern. It's faster to
    // hone in on too, which is a bonus.
    p = fract(p)-.5;  
    return dot(p, p);
    
    //p = abs(fract(p)-.5);
    //p = abs(p - (p.x+p.y+p.z)/3.);
    //return dot(p, vec3(.5));
    
    //p = abs(fract(p)-.5);
    //return max(max(p.x, p.y), p.z);

    
}

// Function 1531
vec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)
{
    const vec3  ITEM_COLOR = vec3(1);
    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);
    const float RAD = 0.05;  //Cursor radius, in local space
    const float LW  = 0.030; //Line width
    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)
    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;
    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));
    vec2 bottomCenter = vec2(0.5,0.0);
	vec2 topCenter    = vec2(0.5,1.0);
    vec2 cursorPos    = vec2(0.5,t);
    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);
    float distCur = length((uv-cursorPos)*ar)-RAD;
    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);
    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);
    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);
    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);
    return mix(colorBar,colorCur,colorCur.a);
}

// Function 1532
void draw_circle(inout vec4 color, vec2 uv, Circle c) {
    uv = scale(uv, vec2(iResolution.x / iResolution.y, 1.0), vec2(0.5));
    c.pos = scale(c.pos, vec2(iResolution.x / iResolution.y, 1.0), vec2(0.5));
    float visible = step(distance(uv, c.pos), c.size);
    color.rgb += pow(c.color, vec3(2.2)) * visible;
    color.a = max(color.a, visible);
}

// Function 1533
vec3 toLinear(vec3 c)
{
    return vec3(toLinear1(c.r), toLinear1(c.g), toLinear1(c.b));
}

// Function 1534
vec3 redCircle(in vec3 _color, in vec2 _st, in float _radius, in float x, in float y ){
    vec2 dist = _st-vec2(x,1.-y);
	vec3 red = vec3(1.0,0.0,0.0);
    return mix( _color, red, 
               1.-smoothstep(_radius-(_radius*0.01),
                             _radius+(_radius*0.01),
                             dot(dist,dist) )
                );
}

// Function 1535
vec2 circle(float a){return vec2(cos(a),sin(a));}

// Function 1536
float linearstep( const float s, const float e, float v ) {
    return clamp( (v-s)*(1./(e-s)), 0., 1. );
}

// Function 1537
vec4 DrawShapes (in vec2 fragCoord)
{
    #if DIST_OUTSIDE == 1
    	vec4 ret = vec4(0.0);
    #else
    	vec4 ret = EncodeData(fragCoord, vec3(0.0, 1.0, 0.0));
    #endif
    
    float aspectRatio = iResolution.x / iResolution.y;
    vec2 uv = (fragCoord / iResolution.xy);
    uv.x *= aspectRatio;    
    
    // draw circles
    for (int i = 0; i < c_numCircles; ++i)
    {
        vec2 posuv = hash22(vec2(i, iDate.w));
        posuv.x *= aspectRatio;
        
        vec3 color = hash32(vec2(i, iDate.w));
        float radius = mix(c_circleRadius.x, c_circleRadius.y, hash12(vec2(i, iDate.w)));
		float dist = length(uv-posuv);
       
        if (dist <= radius) {
            #if DIST_OUTSIDE == 1
            	ret = EncodeData(fragCoord, color);      
            #else
            	ret = vec4(0.0);
            #endif
        }
    }
    
    // draw lines
    for (int i = 0; i < c_numLines; ++i)
    {
        vec2 startuv = hash23(vec3(i, iDate.w, 0.453));
        startuv.x *= aspectRatio;
        
        vec2 lineDir = normalize(hash23(vec3(i, iDate.w, 0.627)));
        
        vec3 color = hash33(vec3(i, iDate.w, 2.564));
        float width = mix(c_lineSize.x, c_lineSize.z, hash13(vec3(i, iDate.w, 1.453)));
        float height = mix(c_lineSize.y, c_lineSize.w, hash13(vec3(i, iDate.w, 0.894)));
		vec2 enduv = startuv + lineDir * width;
        
        float dist = UDFatLineSegment(uv, startuv, enduv, height);
        
        if (dist <= 0.0) {
            #if DIST_OUTSIDE == 1
            	ret = EncodeData(fragCoord, color);      
            #else
            	ret = vec4(0.0);
            #endif            
        }
    }    
    
    // draw squiggle lines
    for (int i = 0; i < c_numSquiggles; ++i)
    {
        vec2 startuv = hash23(vec3(i, iDate.w, 2.635));
        startuv.x *= aspectRatio;
        
        vec2 squiggleDir = normalize(hash23(vec3(i, iDate.w, 0.912)));
        
        vec3 color = hash33(vec3(i, iDate.w, 0.123));
        float width = mix(c_squiggleSize.x, c_squiggleSize.z, hash13(vec3(i, iDate.w, 0.342)));
        float height = mix(c_squiggleSize.y, c_squiggleSize.w, hash13(vec3(i, iDate.w, 1.847)));
		vec2 enduv = startuv + squiggleDir * width;
        
        vec2 uvOffset = vec2(0.0);
        float uvdp = dot(uv - startuv, squiggleDir);
        vec2 normal = vec2(squiggleDir.y, -squiggleDir.x);
        if (uvdp >= 0.0 && uvdp <= width)
            uv += normal * sin(uvdp * 100.0) * 0.01;
        
        float dist = UDFatLineSegment(uv, startuv, enduv, height);
        
        if (dist <= 0.0) {
            #if DIST_OUTSIDE == 1
            	ret = EncodeData(fragCoord, color);      
            #else
            	ret = vec4(0.0);
            #endif
        }
    }        

    return ret;
}

// Function 1538
vec2 UIDrawContext_ScreenPosToCanvasPos( UIDrawContext drawContext, vec2 vScreenPos )
{
    vec2 vViewPos = vScreenPos - drawContext.viewport.vPos;
    return vViewPos + drawContext.vOffset;
}

// Function 1539
void drawKeyIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int keyColor ) {
    coord = (coord-lt) / size;
    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    
		vec4 col = drawKey(-coord, keyColor);
        color = mix( color, col, col.a );
    }
}

// Function 1540
vec3 hsluv_toLinear(vec3 c) {
    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );
}

// Function 1541
void drawHelicopter(ivec2 uv, ivec2 heliPos, int si, const in sampler2D d, inout vec3 f) {
    if (heliPos.y > 0) {
        drawSprite(uv, heliPos - ivec2(12,5), heliPos + ivec2(12,5), ivec2(24 * si, 24), d, heliPos.y < 8, f);
    }
}

// Function 1542
float drawFloat(float value, int prec, int maxDigits)
{ 
  float tpx = tp.x-FONT_SPACE*float(maxDigits);
  float c = 0.;
  if (value < 0.0) 
  { 
    c = char(45); // write minus sign
    value = -value;
  }
  tp.x -= FONT_SPACE;
  c += drawInt(int(value),1);
  c += char(46); BLANK; // add dot 
  c += drawFract(fract(value), prec);
  tp.x = min(tp.x, tpx);
  return c;
}

// Function 1543
float SakeobaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){
    vec2 pp = polar(rotate(pos, r) * scale);
    return Saketoba(mod(rotate(pp * vec2(x, y), M_PI05), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);
}

// Function 1544
float line( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 1545
vec4 closestPointsBezierLine(in vec2 ba, in vec2 bb, in vec2 bc, in vec2 la, in vec2 lb) {
    vec2 p = ba - 2.0 * bb + bc, q = 2.0 * (bb - ba), r = la - lb, s = ba - la;
    float c1 = dot(p, p), c2 = 2.0 * dot(p, q), c3 = 2.0 * dot(p, s) + dot(q, q), c4 = dot(r, r),
          c5 = 2.0 * dot(p, r), c6 = 2.0 * dot(r, q), c7 = 2.0 * dot(q, s), c8 = 2.0 * dot(r, s);

    // Cubic coefficients
    float a = 4.0 * c1 - c5 * c5 / c4;
    float b = (3.0 * c2 - 1.5 * c5 * c6 / c4) / a;
    float c = (2.0 * c3 - (c5 * c8 + 0.5 * c6 * c6) / c4) / a;
    float d = (c7 - 0.5 * c6 * c8 / c4) / a;

    // Solve for the x coordinate of the minima (cubic solving based on https://en.wikipedia.org/wiki/Cubic_equation)
    float inflect = b / 3.0, denom = 2.0 * c4, bSq = b * b;
    vec2 pq = vec2(c - bSq / 3.0, bSq * b / 13.5 - b * c / 3.0 + d);
    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;

    float p2 = abs(pq.x);
    float v1 = 1.5 / pq.x * pq.y;

    vec4 pair; float comp; bool init;
    if (qq * 0.25 + ppp / 27.0 > 0.0) {
        float v2 = v1 * sqrt(3.0 / p2), x, y;
        if (pq.x < 0.0) x = sign(pq.y) * cosh(acosh(v2 * -sign(pq.y)) / 3.0);
        else x = sinh(asinh(v2) / 3.0);
        x = -2.0 * sqrt(p2 / 3.0) * x - inflect, y = -((c5 * x + c6) * x + c8) / denom;
        if (x >= 0.0 && x <= 1.0 && y >= 0.0 && y <= 1.0) update(posBezier(ba, bb, bc, x), la - r * y, pair, comp, init);
    }

    else {
        float ac = acos(v1 * sqrt(-3.0 / pq.x)) / 3.0, m = 2.0 * sqrt(-pq.x / 3.0);
        float x1 = m * cos(ac                ) - inflect, y1 = -((c5 * x1 + c6) * x1 + c8) / denom;
        if (x1 >= 0.0 && x1 <= 1.0 && y1 >= 0.0 && y1 <= 1.0) update(posBezier(ba, bb, bc, x1), la - r * y1, pair, comp, init);
        float x2 = m * cos(ac - 2.09439510239) - inflect, y2 = -((c5 * x2 + c6) * x2 + c8) / denom;
        if (x2 >= 0.0 && x2 <= 1.0 && y2 >= 0.0 && y2 <= 1.0) update(posBezier(ba, bb, bc, x2), la - r * y2, pair, comp, init);
        float x3 = m * cos(ac - 4.18879020479) - inflect, y3 = -((c5 * x3 + c6) * x3 + c8) / denom;
        if (x3 >= 0.0 && x3 <= 1.0 && y3 >= 0.0 && y3 <= 1.0) update(posBezier(ba, bb, bc, x3), la - r * y3, pair, comp, init);
    }

    // Minimize along the boundary (0, 0) --> (1, 0) --> (1, 1) --> (0, 1)
    update(ba, la - r * clamp(dot(la - ba, r) / c4, 0.0, 1.0), pair, comp, init);
    update(bc, la - r * clamp(dot(la - bc, r) / c4, 0.0, 1.0), pair, comp, init);
    update(la, closestOnBezier(la, ba, bb, bc), pair, comp, init);
    update(lb, closestOnBezier(lb, ba, bb, bc), pair, comp, init);

    return pair;
}

// Function 1546
vec3 drawPoint(vec2 uv, vec2 point, vec3 cBack, vec3 cPoint, float radius, float fZoom)
{
    radius /= fZoom;
    float distPt = length(uv-point);
    float alphaPt = 1.0-smoothstep(radius-.003/fZoom,radius,distPt);
    return alphaBlend(cBack,cPoint,alphaPt);
}

// Function 1547
float segmented_spline_c9_fwd( float x, SegmentedSplineParams_c9 C) {    
const int N_KNOTS_LOW = 8;
const int N_KNOTS_HIGH = 8;
float logx = log10( max(x, 0.0 ));
float coefsLow[10];
coefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;coefsLow[3] = C.coefsLow.d;
coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;coefsLow[6] = C.coefsLow.g;
coefsLow[7] = C.coefsLow.h;coefsLow[8] = C.coefsLow.i;coefsLow[9] = C.coefsLow.j;
float coefsHigh[10];
coefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;coefsHigh[3] = C.coefsHigh.d;
coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;coefsHigh[6] = C.coefsHigh.g;
coefsHigh[7] = C.coefsHigh.h;coefsHigh[8] = C.coefsHigh.i;coefsHigh[9] = C.coefsHigh.j;
float logy;
if ( logx <= log10(C.minPoint.x) ) { 
logy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );
} else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) )) {
float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(C.minPoint.x)) / (log10(C.midPoint.x) - log10(C.minPoint.x));
int j = int(knot_coord);
float t = knot_coord - float(j);
vec3 cf;
data10[0] = coefsLow[0];data10[1] = coefsLow[1];data10[2] = coefsLow[2];data10[3] = coefsLow[3];
data10[4] = coefsLow[4];data10[5] = coefsLow[5];data10[6] = coefsLow[6];
data10[7] = coefsLow[7];data10[8] = coefsLow[8];data10[9] = coefsLow[9];
cf.x = getData10(j); cf.y = getData10(j + 1); cf.z = getData10(j + 2);
vec3 monomials = vec3( t * t, t, 1.0 );
logy = dot( monomials, MM * cf);
} else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) )) {
float knot_coord = float(N_KNOTS_HIGH - 1) * (logx - log10(C.midPoint.x)) / (log10(C.maxPoint.x) - log10(C.midPoint.x));
int j = int(knot_coord);
float t = knot_coord - float(j);
vec3 cf;
data10[0] = coefsHigh[0];data10[1] = coefsHigh[1];data10[2] = coefsHigh[2];data10[3] = coefsHigh[3];
data10[4] = coefsHigh[4];data10[5] = coefsHigh[5];data10[6] = coefsHigh[6];
data10[7] = coefsHigh[7];data10[8] = coefsHigh[8];data10[9] = coefsHigh[9];
cf.x = getData10(j); cf.y = getData10(j + 1); cf.z = getData10(j + 2); 
vec3 monomials = vec3( t * t, t, 1.0 );
logy = dot( monomials, MM * cf);
} else {
logy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );
}
return pow(10.0, logy);
}

// Function 1548
void UI_DrawButton( inout UIContext uiContext, bool bActive, bool bMouseOver, Rect buttonRect )
{
	if (!uiContext.bPixelInView)
        return;
    
    if ( bActive && bMouseOver )
    {
#ifdef NEW_THEME
    	DrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonActive, uiContext.vWindowOutColor );
#else
    	DrawBorderIndent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );
#endif        
    }
    else
    {
#ifdef NEW_THEME
    	DrawBorderRect( uiContext.vPixelCanvasPos, buttonRect, cButtonInactive, uiContext.vWindowOutColor );
#else
    	DrawBorderOutdent( uiContext.vPixelCanvasPos, buttonRect, uiContext.vWindowOutColor );
#endif        
    }
}

// Function 1549
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.;
    float z = size.y / tan(radians(fieldOfView) / 2.);
    return normalize(vec3(xy, -z));
}

// Function 1550
vec2 Support_Rectangle (vec2 size, vec2 dir)
{
    return vec2(sign_(dir.x)*size.x, sign_(dir.y)*size.y);
}

// Function 1551
vec3 DrawBounceBall(vec2 uv){
	uv*=4.;
	uv.y+=sin(ftime*PI);
	float val = clamp((1.0-length(uv)),0.,1.);
	val = smoothstep(0.,0.05,val);
	return vec3(val,val,val);
}

// Function 1552
vec3 DrawCell(vec2 p, vec2 cellId, vec3 bgColor)
{
    vec4 cellIdData = Load(mCellId.xy+cellId, iChannel0, iChannelResolution[0].xy);
    vec4 cellIdPosData = Load(mCellPos.xy+cellId, iChannel0, iChannelResolution[0].xy);
    
    vec2 q = p-cellIdData.xy;
    return DrawCandy(q, bgColor, cellIdData);
}

// Function 1553
void DrawSpeedometer (vec2 fragCoord, float speedPercent, inout vec3 pixelColor)
{
    float aspectRatio = iResolution.x / iResolution.y;
    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5);
    uv.x *= aspectRatio;
    
    const float size = 0.15;
    vec2 center = vec2(0.5 * aspectRatio - (size+AA_AMOUNT), -0.5 + (size+AA_AMOUNT));
    
    // early out if outside spedometer
    if (UDCircle(uv, center, size) > AA_AMOUNT)
        return;
    
    // yellow outer ring
	float zoomCircleDist = UDCircle(uv, center, size);  
	zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);
    pixelColor = mix(pixelColor, vec3(0.8,0.6,0.0), zoomCircleDist);  
    
    // grey interior
	zoomCircleDist = UDCircle(uv, center, size - AA_AMOUNT);          
	zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);
    pixelColor = mix(pixelColor, vec3(0.1), zoomCircleDist);
    
    // Tick marks
    vec2 relativePoint = uv - center;
    float relativePointAngle = atan(relativePoint.y, relativePoint.x);
    relativePointAngle += PI * 0.25;
    relativePointAngle = mod(relativePointAngle, TWOPI);
    if (relativePointAngle < PI * 1.5)
    {
    	vec2 fakePoint = vec2(length(relativePoint) / size, relativePointAngle);
    	fakePoint.y = mod(fakePoint.y, 0.4) - 0.2;
        float tickDistance = UDFatLineSegment(fakePoint, vec2(0.85, 0.0), vec2(0.95, 0.0), 0.05);
        tickDistance = 1.0 - smoothstep(0.0, AA_AMOUNT*5.0, tickDistance);
        pixelColor = mix(pixelColor, vec3(1.0,1.0,0.0), tickDistance);
    }
    
    // speed bar
    float targetAngle = (1.0 - clamp(speedPercent, 0.0, 1.0)) * PI * 1.5 - PI * 0.25;
    vec2 targetPoint = center + size * 0.9 * vec2(cos(targetAngle), sin(targetAngle));
        
    float boxDistance = UDFatLineSegment(uv, center, targetPoint , 0.003);
    boxDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, boxDistance);
    pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), boxDistance);
    
    // red ring in the middle, attached to the bar
	zoomCircleDist = UDCircle(uv, center, AA_AMOUNT);          
	zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);
    pixelColor = mix(pixelColor, vec3(1.0,0.0,0.0), zoomCircleDist);        
}

// Function 1554
bool DrawContext_OnCanvas( DrawContext drawContext )
{
    vec2 vUV = drawContext.vUV;
    if ( (vUV.x >= 0.0f) && (vUV.y >= 0.0f) && (vUV.x < 1.0f) && (vUV.y < 1.0f) ) 
    {    
    	return true;
    }
    return false;
}

// Function 1555
vec2 circle( in float t )
{
    float s = fract(t*4.0);
    
    #if REPARAMETRIZE==1
    s = s*s*(3.0-2.0*s);  // pick something better
    s = s*s*(3.0-2.0*s);
    s = s*s*(3.0-2.0*s);
    #endif
    
    vec2 p = pow( vec2(1.0-s,s), vec2(1.0/8.0) );
  //vec2 p = sqrt(sqrt(sqrt(vec2(1.0-s,s))));
    
    return (t<0.25) ? vec2(-p.y, p.x) :
           (t<0.50) ? vec2(-p.x,-p.y) :
           (t<0.75) ? vec2( p.y,-p.x) : p;
}

// Function 1556
void line_to(vec2 p) {
    vec4 pa = _stack.position - _stack.last_pt.xyxy;
    vec2 ba = p - _stack.last_pt;
    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);
    add_field(length2(pa - ba.xyxy*h.xxyy));
    
    _stack.last_pt = p;
}

// Function 1557
void compute_spline(in vec3 p0, in vec3 l0,
                    in vec3 p1, in vec3 l1,
                    out arc_spline S) {
                  
    // fill in data members of spline that copy inputs
    S.p0 = p0;
    S.l0 = l0;
    
    S.p1 = p1;
    S.l1 = l1;
    
    // compute the line connecting p0 & p1
    vec3 tmp = normalize(cross(p0, p1));
    
    // special case: p0 and p1 are connected by a segment of a great circle
    // the line from p0 to p1 hits them at the correct tangents 
    if (max(abs(dot(tmp, l0)), abs(dot(tmp, l1))) < EPS) {
        // in this case we set S.r = 0 and set S.w to be the line
        S.w = tmp;
        S.r = 0.0;
        return;
    }
    
    // compute the points orthogonal to (l0, p0) and (l1, p1), respectively
    vec3 a0 = cross(l0, p0);
    vec3 a1 = cross(l1, p1);
    
    // we will construct arc centers 
    //
    //   c0 = cos(r) * p0 + sin(r) * a0
    //   c1 = cos(r) * p1 + sin(r) * a1
    //
    // which are a distance r away from p0 & p1 respectively
    // by construction, dot(c0, l0) = dot(c1, l1) = 0
    //
    // now we want to solve for r such that dot(c0, c1) = cos(2*r)
    //
    // start by observing that 
    //
    //   (cos(r)²       * a +
    //    cos(r)*sin(r) * b
    //    sin(r)²       * c) = cos(2r)
    //
    // where a = dot(p0, p1), b = dot(p0, a1) + dot(p1, a0), and 
    // c = dot(a0, a1).
    //
    // applying the half angle identities and setting θ = 2r, we find
    //
    //   a*(1 + cos(θ))/2 + b*sin(θ)/2 + c*(1 - cos(θ))/2 = cos(θ)
    //   a*(1 + cos(θ)) + b*sin(θ)+ c*(1 - cos(θ)) = 2*cos(θ)
    //   (a - c - 2)*cos(θ) + b*sin(θ) = -(a + c)
    //
    // we can rewrite that as
    //
    //   d*cos(θ) + b*sin(θ) = e
    //
    // where d = a - c - 2 and e = -(a + c).
    //
    // finally, we can rewrite that as
    //
    //   α*cos(θ - φ) = e
    //
    // where α = sqrt(d² + b²) and φ = atan(b, d).
    // the solution is given by
    //
    //   θ = φ ± acos(e / α)
    //
    // and r = 0.5 * θ.
    
    float a = dot(p0, p1);
    float b = dot(p0, a1) + dot(p1, a0);
    float c = dot(a0, a1);
    
    float d = (a - c - 2.);
    float e = -(a + c);
    
    float alpha = length(vec2(d, b));
    float phi = atan(b, d); // in [-pi, pi]
    float tau = acos(e/alpha); // in [0, pi]

    // we want the r with the least magnitude so choose tau with the 
    // opposite sign as phi
    float r = 0.5 * (phi > 0. ? phi - tau : phi + tau);

    // now get c0 & c1
    float cr = cos(r);
    float sr = sin(r);

    S.c0 = normalize(cr*p0 + sr*a0);
    S.c1 = normalize(cr*p1 + sr*a1);
    
    // m is the midpoint of c0 & c1, the point
    // of mutual tangency of the two arcs
    S.m = normalize(S.c0 + S.c1);
    
    // get the line connecting c0 & c1
    S.w = normalize(cross(S.c0, S.c1));
    
    // no longer need the sign of r, want it positive to compute distances later
    S.r = abs(r);
    
    // choose w to point towards p0
    if (dot(S.w, p0) < 0.) { S.w = -S.w; }
                  
}

// Function 1558
vec2 BSplineLinearWeights(float f){//this is identical to lerp
 	float w0 = 1.f - f;
    float w1 = f;
    return vec2(w0,w1);
}

// Function 1559
vec4 drawCh(in float character, in float x, in float y)
{
    vec2 coord = floor(vec2(CHAR_SIZE.x*mod(character,32.0) + x, iResolution.y - CHAR_SIZE.y*floor(1.0+character/32.0) + y));
    return texture(iChannel0, (coord+vec2(0.5,0.5)) / iResolution.xy);
}

// Function 1560
void drawFx()
{
    gFrag.c = gFrag.fx;
}

// Function 1561
float distanceToRoundRect(vec4 rectExtents,vec3 rectCenter,vec3 point) {
	vec3 tPoint = point-rectCenter;
	return(length(max(abs(tPoint)-rectExtents.xyz,0.0)) - rectExtents.w);
}

// Function 1562
v2 brushCircle(v1 u,v2 r,v3 m,v2 c
){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)
                           ,v1(0,0),// origin
                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width
;}

// Function 1563
vec4 line (in vec2 p, in vec2 a, in vec2 b, in vec4 c, in float thickness)
{
    vec2 pa = -p - a;
    vec2 ba = b - a;
    float h = clamp (dot (pa, ba) / dot (ba, ba), 0.0, 1.0);
    float d = length (pa - ba * h);
    
    return c * clamp (((1.0 - d) - (1.0 - thickness)) * 100.0, 0.0, 1.0);
}

// Function 1564
void UpdateLightDirection()
{
	vec3 normalLight = normalize(vec3(0.2, 0.9, 0.2));
	float radTheta = 2.0 * g_gPi * g_t / 60.0;
	float gSin = sin(radTheta);
	float gCos = cos(radTheta);
	mat2 matRot = mat2(gCos, -gSin, gSin, gCos);
	normalLight.xy = matRot * normalLight.xy;
	g_normalLight = normalLight;
}

// Function 1565
vec3 drawSegment(vec3 col, vec3 drawCol, float width, vec2 pos, vec2 o, vec2 dir, float l) {
    float d = closestPointOnLineScalar(o, dir, pos);	// re not here
    
    if (0. <= d && d <= l) {
        vec2 nml = vec2(dir.y, -dir.x);
        return drawLine(col, width, pos, nml, dot(nml, o));	// re at nml
    }
    
    #ifdef filledLines
        else if(lsqr(pos - (o + l*dir)) <= width*width) {	// draw round end
            return drawPoint(col, lineCol, width, pos, o + l*dir);
        }
    #endif
    
    return col;
}

// Function 1566
vec3 LinearToSRGB(vec3 rgb)
{
	return vec3(LinearToSRGB(rgb.r), LinearToSRGB(rgb.g), LinearToSRGB(rgb.b));
}

// Function 1567
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 1568
vec4 drawBird(in float x, in float y, in float atx, in float aty, bool flip)
{
    // Bounds checking.
    if(x < atx || x > atx + 7.) return TRANS;
    if(y < aty || y > aty + 4.) return TRANS;
    
    // Transform coordinates to bird space.
    x -= atx;
    y -= aty;
    
    // Flip the bird if necessary.
    if(flip) x = 7.-x;
    
    // This animation is less framecounting and more dividing an amount
    // of time by four.
    float t = mod(iTime, .533);
    if(t < .133)	return birdPalette(birdWingsLevel(x,y));
    else if(t < .266)	return birdPalette(birdWingsUp(x,y));
    else if(t < .400)	return birdPalette(birdWingsLevel(x,y));
    else return birdPalette(birdWingsDown(x,y));
}

// Function 1569
float line(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p - a, ba = b - a;
    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));
}

// Function 1570
float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)
{
  	vec2 d = max(tl - uv, uv - br);
    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));
}

// Function 1571
vec3 DrawFlower(vec2 uv){
	float deg = atan(uv.y,uv.x) + iTime * -0.1;
	float len = length(uv)*3.0;
	float offs = abs(sin(deg*3.))*0.35;
    float val = smoothstep(1.+offs,1.+offs-0.05,len);
	return vec3(val);
}

// Function 1572
float stripesCircle2(vec2 uv, float distorsion) {
    return stripesCircle(uv, StripesCircleOpt(.354, .395, 3.5, -.01, 112.2), StripesOpt(distorsion, .5, 1.));
}

// Function 1573
float ssdCircle(vec3 p, vec3 o, float r) {
    return acos(dot(p, o)) - r;
}

// Function 1574
vec3 StyleScanline( float f, in vec2 fragCoord )
{
	float fShade = f * 0.8 + 0.2;
	
    // disable
	//fShade *= mod(fragCoord.y, 2.0);
	
	return mix(vec3(0.01, 0.2, 0.01), vec3(0.01, 1.0, 0.02), fShade);
}

// Function 1575
float RandRect (vec2 p)
{
  vec4 hm, hc;
  vec3 e;
  vec2 pMid[4], pEdge[4], ip;
  float dMin, d, hp, eFac;
  ip = floor (p) + 0.5;
  e = vec3 (-1., 0., 1.);
  hp = H(0.);
  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));
  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));
  if (mod (ip.x + ip.y, 2.) < 0.5) {
    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);
    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);
    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);
    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);
    pMid[0] = vec2 (hm.z, hp);
    pMid[1] = pMid[0];
    pMid[2] = vec2 (hm.w, hp);
    pMid[3] = pMid[2];
  } else {
    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);
    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);
    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);
    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);
    pMid[0] = vec2 (hp, hm.y);
    pMid[1] = vec2 (hp, hm.x);
    pMid[2] = pMid[1];
    pMid[3] = pMid[0];
  }
  eFac = 0.375;
  for (int k = 0; k < 4; k ++) {
    pEdge[k] = eFac * pEdge[k] + 0.5;
    pMid[k] = 2. * eFac * (pMid[k] - 0.5);
  }
  pMid[0] += pEdge[0] * e.xz;
  pMid[1] += pEdge[1] * e.zz;
  pMid[2] += pEdge[2] * e.zx;
  pMid[3] += pEdge[3] * e.xx;
  dMin = dstFar;
  for (int k = 0; k < 4; k ++)
     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.225, 0.05));
  return dMin;
}

// Function 1576
void drawFog(vec2 uv, vec2 yBorders, float speed, float density, float contrast, float frequency, int octaves, float lacunarity, float persistence, inout vec3 value)
{
    //Get the Noise Value
    float noiseValue = perlinNoise(vec2(uv.x * 0.8 + iTime * speed, uv.y), frequency, octaves, lacunarity, persistence);
    
    //Create Gradient Masks
    float densityGradient = smoothstep(yBorders.y + 0.6, yBorders.y, uv.y);
    float whiteGradient = smoothstep(yBorders.x + 0.3, yBorders.x - 0.2, uv.y) * 0.3 * density;
    
    //Adjust the Value
    noiseValue = smoothstep(0.2, 0.7, noiseValue) * densityGradient * 0.75 * density + whiteGradient;
    noiseValue = clamp(map(noiseValue, 0., 1., 0. - contrast, 1.1) * densityGradient, 0., 1.);
    value = mix(value, vec3(noiseValue + 0.2), noiseValue);
    //value = vec3(noiseValue);
}

// Function 1577
vec3 circle(in float ti, in vec3 obj){
    return vec3(80.*cos(ti*TwoPI) + obj.x, 0., 80.*sin(ti*TwoPI) + obj.z);
}

// Function 1578
bool drawBody(vec2 pt, float id) {
    
    vec4 bodyPosVel = getBodyPosVel(id);
    vec4 bodyMassRad = getBodyMassRad(id);
    
    vec2 pos = bodyPosVel.xy;
    float r = bodyMassRad.y;

    return isPointInBody(pt, r, pos);
}

// Function 1579
float sdCircle(vec2 p, float r)
{
    return length(p) - r;
}

// Function 1580
float circle(vec2 uv, vec2 center, float radius, float width)
{
    float r = length(uv - center);
    float offset=2.5*snoise(uv+sin(iTime));
    float noise=.6*gnoise(uv);
    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);
}

// Function 1581
vec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831*rv2.x); 
	float ry = ra*sin(6.2831*rv2.x);
	float rz = sqrt( 1.0-rv2.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );

    return normalize( rr );
}

// Function 1582
vec2 circle_intersections(vec2 ro, vec2 rd){

    float min_t = 100.;
    float t;
    float idf = -1.;
    
    for(int i = 0; i < 1; i++){
        
        t = iSphere(ro, rd, CircleList[i].pos, CircleList[i].r);
        
        if(t < min_t){
        
            min_t = t;
            idf = float(i);
            
        } 
    }
    
    return vec2(t, idf);
}

// Function 1583
vec2 uv_aa_linear( vec2 uv, vec2 res, float width )
{
    uv = uv * res;
    vec2 uv_floor = floor(uv + 0.5);
    uv = uv_floor + clamp( (uv - uv_floor) / fwidth(uv) / width, -0.5, 0.5);
    return uv / res;
}

// Function 1584
float line(vec2 uv, vec2 p1, vec2 p2)
{
    mat2 mat = mat2(uv-p1, p2-p1);
    float fx = determinant(mat);
    float dist = abs(fx)/length(p2-p1);
    return clamp(thickness-dist*sharpness, 0.0, 1.0);
}

// Function 1585
float linearStep(float a, float b, float x)
{
    float t = clamp((x - a) / (b - a), 0.0, 1.0);
    return t;
}

// Function 1586
float Lines(float u, float b) { return Graph(sin(u * Pi), b); }

// Function 1587
void DrawPoint(vec2 uv, vec2 p, inout vec3 col) {
    col = mix(col, vec3(1.0, 0.25, 0.25), saturate(abs(dFdy(uv).y)*8.0/distance(uv, p)-4.0));
}

// Function 1588
float fRect(vec2 p,vec2 b){vec2 q=(abs(sCoord-p)-b);return 1.0-clamp(max(q.x,q.y), 0.0, 1.0);}

// Function 1589
vec3 GetLightDirection(vec3 pos)
{
    return normalize(pos - lightPos);
}

// Function 1590
void DrawSnow(out vec4 c){
	c = vec4(1.0, 1.0, 1.0, 1.0);
}

// Function 1591
float circle(vec2 uv, vec2 center, float radius) { return distance(uv, center) <= radius ? 1. : 0.;}

// Function 1592
vec3 GetPointOnCubicSpline(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3, float t)
{
	float p = t;
	float n = 1.0 - t;
        
	vec3 ans;
       
	ans  = cp0 * (n*n*n);
	ans += cp1 * (n*n*p*3.0);
	ans += cp2 * (n*p*p*3.0);
	ans += cp3 * (p*p*p);
    
    return ans;
}

// Function 1593
float Circle(vec2 p, float r)
{
    return (length(p / r) - 1.) * r;
}

// Function 1594
void DrawKey( vec2 pos, vec3 keyCol )
{
	vec2 p = pixel-pos;
	vec2 c = p-vec2(5,0);
	
	bool draw = false;
	if ( abs(p.x) < 10.0 && abs(p.y) < 5.0 )
	{
		if ( p.x > 1.0 )
		{
			if ( length(c) < 5.0 && length(c-vec2(1,0)) > 2.0 )
				draw = true;
		}
		else
		{
			if ( p.y < 2.0 &&
				p.y > 10.0-20.0*texture( iChannel1, vec2(0,pixel.x/5.0) ).r )
				draw = true;
		}
	}
	
	if ( draw )
		fragColor.rgb = keyCol;
}

// Function 1595
vec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)
{
   vec3 color = vec3(0.0);
   int id = -1;
   i = false;
   //vec3 toLight = (lightf-hit);
   //float sqdist = dot(toLight,toLight);
   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);
   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;
 
   if(diffuse>0.0)
   {
      float ldist =distance(lightf,hit);// sqrt(sqdist);
      float sh = 1000.0;//distance(lightf,hit);
      intersectscene(hit + normal * 0.0001, L, sh, id, false);           
      if(sh>ldist)
         {color += cl * (diffuse/(ldist))*0.32; i = true;}
   }
   return color;
}

// Function 1596
float drawP(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));
  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);

  return val + val2;
}

// Function 1597
void DrawBigBall(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    DrawGlow(p, t, fireColor, color);
    
    float texpNormPow = pow(t, 0.5);
    vec2 gravity = gGravity * 0.15;
    
    vec3 pColor;
    for(float i=0.; i < 20.5; ++i)
    {   
        // Main Properties
        float hashP = hash(id+i*1492.8561);
        float hashP2 = hash(id+(hashP*6915.8954)*1658.579);
        float pSpeed = (0.7+hashP*0.05);
        vec2 pVel = normalize( vec2(hash(i)*2.-1., hashP2*2.-1.) );
        
        pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.4), 0., 1.);

        // Visibility Properties
        float sizeScale = (0.8+0.2*hashP);
        float flicker = 1.;
        float size = sizeScale*expSize*0.2;

        // Position
        vec2 deltaPos = pVel*pSpeed* (0.1+texpNormPow) + (0.5*hashP+0.5)*gravity*t*t;
        vec2 q = p - deltaPos;

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size*0.3, t, pColor, 0.8, 9.0*hash(i+t*10.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
    
    vec4 pFinalColor = DrawParticle(0., p, expSize*0.3, t, mix(pColor, fireColor, dot(p, p)*90.), 0.5, 1.5*hash(t*10.), color.a, 1.);
    color.rgb += hash(id + t) * pFinalColor.rgb; color.a = pFinalColor.a;
}

// Function 1598
float line(in float x)
{
    return ((x>0.0) && (x<1.0)) ? 1.0 : 0.0;
}

// Function 1599
float shape_line(vec2 p, vec2 a, vec2 b) {
  vec2 dir = b - a;
  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));
}

// Function 1600
vec4 BSplineCubicWeights(float f){
    float f2 = 1.f - f;

	float w0 = (1.f / 6.f)*(f2*f2*f2);
	float w1 = (2.f / 3.f) - 0.5f*f*f*(2.f - f);
	float w2 = (2.f / 3.f) - 0.5f*f2*f2 * (1.f + f);
	float w3 = (1.f / 6.f) * f*f*f;
    return vec4(w0,w1,w2,w3);
}

// Function 1601
float Circle (vec2 uv, vec2 position, float radius, float blur)
{
 	uv -= position;
    return S(radius, radius -blur,length(uv));
}

// Function 1602
void delete_line_at(int el_pos) {
    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;
    int gidx = 96 * imidx;
    for (int i = el_pos + alp; i < gidx+96; i++) {
        if(i>=msize.x*msize.y)break; //OpenGL bug, without this rule score(el_sc) of board ruined
        map[i] = (i+10<msize.x*msize.y)?map[i+10]:0;
    }
}

// Function 1603
float circle(vec2 p, float r){
vec2 d = vec2(0.001,0);
vec2 a = (vec2(circleeq(p,r) - circleeq(p + d,r), circleeq(p,r) - circleeq(p + d.yx,r)) / d.xx);
float c = smoothstep(0.0, thickness / iResolution.y, abs(circleeq(p,r) / length(a)));
if(c < 1.0) return 1.0;
else return 0.0;

}

// Function 1604
float lineDist(vec2 p, vec2 start, vec2 end, float width)
{
  vec2 dir = start - end;
  float lngth = length(dir);
  dir /= lngth;
  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;
  return length( (start - p) - proj ) - (width / 2.0);
}

// Function 1605
vec3 modifyDirectionWithRoughness( const vec3 n, const float roughness, inout float seed ) {
  	vec2 r = hash2(seed);
    
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	
    float a = roughness*roughness;
    a *= a; a *= a; // I want to have a really shiny watch.
	float rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));
	float ra = sqrt(abs(1.-rz*rz));
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize(rr);
}

// Function 1606
float Line(vec2 p, vec2 a, vec2 b) {
    vec2 ba=b-a;
    float k=dot(p-a,ba)/dot(ba,ba);
    return length((a+clamp(k,0.,1.)*(b-a))-p);
}

// Function 1607
float dist_circle(vec2 p, float r)
{
	return length(p) - r;
}

// Function 1608
void DrawBubbles(vec2 p, vec4 player, inout vec4 color)
{
    float angles [4];
    angles[0] = 0.; angles[1] = PI*0.5; angles[2] = PI; angles[3] = -PI*0.5;
    
    if(player.x > 1.5) return;
    
    for(int i = 0; i < NUM_BUBBLES; ++i)
    {
        vec4 bubble = LoadMem0(txBubble.xy + vec2(float(i), 0.));
        vec4 bubbleState = LoadMem0(txBubbleState.xy + vec2(float(i), 0.));
        
		float life = bubbleState.x > 0. ? 1. : 1.-min((iTime - bubbleState.z)/BUBBLE_FADE_OUT_TIME, 1.);
        vec3 ballExternalColor = vec3(hash(vec2(225.*float(bubbleState.y))),hash(vec2(157.5*float(bubbleState.y)+4.)), hash( vec2(34.*float(bubbleState.y)+102.)));
        if(life < 1.)
        {
            if(life > 0.)
            {
        		DrawFireworks(p - bubble.xy, bubbleState.z, 1.-life, float(i), ballExternalColor, color);
            }
        }
        else
        { 
            vec2 pParticle = p- bubble.xy;
            vec2 q = pParticle/0.7;

            for(int aidx = 0; aidx < 4; aidx++)
            {
                if(bubbleState.y < float(aidx)+0.5)
                {
                    q = Rotate2D(q, angles[aidx]);
                    break;
                }
            }

            DrawBallEffect(pParticle, ballExternalColor, color);
            
            float d = dArrow(q*1.6);
            vec4 ballColor = mix(vec4(0., 0., 0., 0.001), vec4(ballExternalColor, 0.001), smoothstep(-0.08, 0.0, d));
            color = mix(ballColor, color, smoothstep(0., 0.01, d));
        }
    }
}

// Function 1609
vec3 RenderCenterLine(in vec2 pos, in float limitsDistToCenter, in vec3 col)
{
    float t = abs(pos.x) - 0.003;
    float dashT = step(0.0, sin(pos.y * 200.0));
    float limitsT = (abs(pos.y) - limitsDistToCenter);
    
    col = mix(vec3(1.0, 1.0, 1.0), col, smoothstep(0.0, Thickness, max(t, limitsT) + dashT));
    return col;
}

// Function 1610
vec3 drawC(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)
{
    // C: top.
    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);
    
    // C: left side.
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);
    
    // C: right side.
    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);
    
    // C: bottom.
    res += square(color, uv, vec2(pos.x +  0., pos.y + -.2), sz);
    
    return res;
}

// Function 1611
vec4 drawCellExplosionRockford(ivec4 state, mat4x3 colors, ivec2 coord, int gameFrame)
{
    Sprite sprite = getSpriteExplosionRockford(state.y);
    return sampleSprite(sprite, colors, coord);
}

// Function 1612
float rectangle(vec2 samplePosition, vec2 halfSize){
    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;
    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));
    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);
    return outsideDistance + insideDistance;
}

// Function 1613
vec3 drawLine(vec2 uv, vec2 pa, vec2 pb, vec3 cBack, vec3 cLine, float radius, float fZoom)
{
    radius /= fZoom;
    float distLine = distanceToLineSeg(uv,pa,pb);
    float alphaLine = 1.0-smoothstep(radius-.003/fZoom,radius,distLine);
    return alphaBlend(cBack,cLine,alphaLine);
}

// Function 1614
float getSideLine(vec2 st, float left, float top, float lineThickness) {
    float lineEdgeLength = 0.009;
    float sideLine = getBox(st, left, top, lineThickness, 0.336);
    sideLine += getBox(st, left + lineThickness, top + 0.334, lineEdgeLength, lineThickness);
    sideLine += getBox(st, left + lineThickness, top, lineEdgeLength, lineThickness);
    sideLine += getBox(st, left + lineThickness + 0.007, 0.0, lineThickness, lineThickness);
    
    return sideLine;
}

// Function 1615
float distLine(vec2 a, vec2 b){
    
	b = a - b;
	float h = clamp(dot(a, b) / dot(b, b), 0., 1.);
    return length(a - b*h);
}

// Function 1616
float sdfCircle(vec2 uv, vec2 c, float r) { return length(uv-c)-r; }

// Function 1617
float circle(in vec2 _st, in vec2 center, in float _radius)
{
    vec2 dist = _st - center;
    float borderSize = _radius * 0.01;
    return 1.0 - smoothstep(_radius - borderSize, _radius + borderSize, 4.0 * dot(dist, dist));
}

// Function 1618
float circle(in vec2 _st, in float _radius){
    vec2 dist = _st;
	return 1.-smoothstep(_radius-(_radius*0.01),
                         _radius+(_radius*0.01),
                         dot(dist,dist)*4.0);
}

// Function 1619
float sdCircle( vec2 p, float s )
{
  return length(p)-s;
}

// Function 1620
vec4 drawTextVertical(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[10], in int _tsize)
{
    vec4 tcol;
    
    for (int i_letter = 0; i_letter < _tsize; i_letter++)
    {
        tcol += drawLetter(uv, start - float(i_letter)*vec2(0., lsize), lsize, _text[i_letter]);
    }
    
    return clamp(tcol, 0., 1.);
}

// Function 1621
float SScircle(vec2 p, float r)
{
   float ss =  0.009;
   float c = length(p);
    
 return smoothstep(r-ss, r+ss, c);
}

// Function 1622
float sdCircle(vec2 p, float radius) {
    return length(p) - radius;
}

// Function 1623
vec3 WavelengthToConeLinear( float fWavelength )
{
    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);
    float fIndex = fPos * float(standardObserver1931_length);
    float fFloorIndex = floor(fIndex);
    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );
    int iIndex0 = int(fFloorIndex);
    int iIndex1 = iIndex0 + 1;
    iIndex0 = min( iIndex0, standardObserver1931_length - 1);
    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    
    return mix( coneFundamentals[iIndex0], coneFundamentals[iIndex1], fBlend );
}

// Function 1624
float circle(vec3 p, vec3 pos, vec3 n, float d, float rad)
{
    return max(sphere(p, pos, rad), plane(p, n, d));
}

// Function 1625
void drawDot(in vec2 x, in vec3 p) {
    float d = (length(x-p.xy)-pointSize)/p.z;
    colorOut = mix(colorOut, WHITE, smoothstep(1.0, 0.0, d));
	inkDist = min(inkDist, abs(d)-0.5);
}

// Function 1626
float gridline(vec3 p, int id) {
  // Solve a cubic to get ellipsoid coordinates.
  float x2 = p.x*p.x;
  float y2 = p.y*p.y;
  float z2 = p.z*p.z;
  float a2 = a2b2c2.x;
  float b2 = a2b2c2.y;
  float c2 = a2b2c2.z;
  float A = 1.0;
  float B = (a2+b2+c2) - (x2+y2+z2);
  float C = (a2*b2 + b2*c2 + c2*a2) - (x2*(b2+c2) + y2*(c2+a2) + z2*(a2+b2));
  float D = a2*b2*c2-(x2*b2*c2 + a2*y2*c2 + a2*b2*z2);
  vec3 res;
  int nroots = cubic(A,B,C,D,res);
  assert(nroots == 3);
  // Put in descending, lmn, order.
  if (res.x < res.y) res.xy = res.yx;
  if (res.y < res.z) res.yz = res.zy;
  if (res.x < res.y) res.xy = res.yx;
  //assert(res.x >= -1.0);
  //assert(res.y >= -2.0);
  //assert(res.z >= -3.0);
  res += vec3(2,2,3);
  res.x = log(res.x);
  // Draw some gridlines on surface
  vec3 t = fract(res*8.0+0.5);
  t = min(t,1.0-t);
  t[id] = 10.0; // Bodge to avoid entire surface being in grid.
  float d = min(t.x,min(t.y,t.z));
  return smoothstep(0.08,0.1,d);
}

// Function 1627
float line(vec2 p, vec2 a, vec2 b) 
{
	vec2 pa = p - a, ba = b - a;
	float l = dot(ba, ba),
         h0 = dot(pa, ba) / l,                     // parameterization of proj on line
          h = clamp(h0 , 0., 1.);                  // parameterization of proj on segment
    //if (l<1e-6) return 1e38;                     // degenerated line
    dh2 = dh1, dh1 = abs(h-h0)*length(ba);         // how much beyond (for sign desambiguation)
	vec2 d = pa - ba * h;                          // distance vector to segment
    float s = pa.y*ba.x > pa.x*ba.y  ? 1. : -1.;   // sign: -1 on the left
	return dir*s*dot(d,d); //length(d);            // optimization by deferring sqrt
}

// Function 1628
vec2 sdLine( vec3 p, in float l, 
             out vec3 uvw, out vec3 qos, inout float ioV )
{
    qos = p + vec3(0,-l,0);
	uvw = p + vec3(0,ioV,0);
    ioV += l;
    float h = clamp( p.y/l, 0.0, 1.0 );
	p.y -= h*l;
    return vec2( length( p ), h );
}

// Function 1629
float DirectrixofParabola(vec3 a){return DirectrixofParabola(a.x,a.y,a.z);}

// Function 1630
vec4 drawTextHorizontal(in vec2 uv, in vec2 start, in float lsize, in vec2 _text[10], in int _tsize)
{
    vec4 tcol;
    
    for (int i_letter = 0; i_letter < _tsize; i_letter++)
    {
        tcol += drawLetter(uv, start + float(i_letter)*vec2(lsize*.5, 0.), lsize, _text[i_letter]);
    }
    
    return clamp(tcol, 0., 1.);
}

// Function 1631
vec3 cosineDirection(in vec3 nor, vec2 fragCoord, float seed)
{
    vec2 randomSeed = (fragCoord * .152 + seed * 1500. + 50.0);
    vec2 random = hash22(randomSeed);
    float u = random.x;
    float v = random.y;
    
    // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf
    float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0
    float ka = 1.0 / (1.0 + abs(nor.z));
    float kb = -ks * nor.x * nor.y * ka;
    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);
    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);

    float a = 6.2831853 * v;
    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;
}

// Function 1632
vec2 mapCircleInvert(vec2 uv)
{
    float len = length(uv);
    float at = atan(uv.x, uv.y);
    //at = at / PI;
    //return uv;
    len = 1.0 / len;
    return vec2(sin(at)*len, cos(at)*len);
}

// Function 1633
float circle(vec2 p, float s)
{
	return length(p) - s;
}

// Function 1634
float draw_vignette(vec2 uv){
    return 0.5 + 1.5 * pow(uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .3);
}

// Function 1635
float circle( vec2 p, float r )
{
    return ( length( p / r ) - 1. ) * r;
}

// Function 1636
vec3 LinearSample0(vec2 uv, out float coeff, out vec3 Moments, vec3 CN) {
    vec4 Attr=texture(iChannel0,(uv+vec2(0.,HRES.y))*IRES);
    if (Attr.w>9999. || Box2(uv,HRES)>0.) {coeff=0.001; Moments=vec3(0.); return vec3(0.); }
    coeff=max(0.001,dot(CN,(Read3(Attr.y)*2.-1.)*I09));
    vec4 Light=texture(iChannel1,(uv+vec2(0.,HRES.y))*IRES);
    Moments=Read3(Light.w)*coeff;
    return Light.xyz*coeff;
}

// Function 1637
float circle(vec2 uv, float radius)
{
	vec2 dist = uv - vec2(0.5, 0.5);
	return 1. - smoothstep(radius - (radius * 0.01),
		radius + (radius * 0.01),
		dot(dist, dist) * 4.0);
}

// Function 1638
vec3 blendLinearSrgb(vec2 uv, vec3 lhsRgb, vec3 rhsRgb) {
    vec3 lhs = srgbTransferInv(lhsRgb);
    vec3 rhs = srgbTransferInv(rhsRgb);

    return srgbTransfer(mix(lhs, rhs, uv.x));
}

// Function 1639
float line( vec3 p, vec3 a, vec3 b ) 
{
    vec3 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 1640
vec4 draw_string16_ivec4( int num_ch, ivec4 s, ivec2 pos, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    if( num_ch < 0 ) {
        return( v ) ;
    }
    num_ch = num_ch == 0 ? 20 : min( num_ch, 20 ) ;

    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(0), ivec2(16*8,8) ) ) {
        bool work = true ;
        for( int j = 0 ; work && j < 4 ; ++ j ) {
            int s4 = s[j] ;
            for( int i = 0 ; i < 5 ; ++ i ) { //5 letters per component (5*6 bits)
                int c = s4 & 0x3f ;
                if( -- num_ch >= 0 && c > 0 ) {
                    v += draw_character( c, pos, iu ) ;
                } else {
                    work = false ;
                    break ;
                }
                pos.x += 8 ;
                s4 >>= 6 ;
            }
        }
    }
    return( v ) ;
}

// Function 1641
vec2 circlePos(in float speedX, in float speedY) {
    float x = rand(vec2(speedX/speedY+floor((iTime * speedY)/2.5)));
    x = x*2.0-1.0;
    x += rand(vec2(speedX)) < 0.5 ? sin(iTime * speedX) : -sin(iTime * speedX);
    float y = mod(iTime * speedY, 2.5) - 1.0;
    return vec2(x,y);
}

// Function 1642
void DrawScene(inout vec3 color, vec2 p, in AppState s)
{
    vec3 lightColor    = vec3(1.);
    vec3 lightDir      = normalize(vec3(-0.3, 0.5, 1.));
	vec3 baseColor     = 0.25 * pow(vec3(0.87, 0.53, 0.66), vec3(2.2));
    vec3 diffuseColor  = 0.25 * baseColor;
    vec3 specularColor = sqrt(baseColor);
    float roughness    = max(.001, s.roughness);  
    
    p -= vec2(0., 10.);
    p *= .011;
    
    float yaw = 2.7 - s.objRot.x;
    mat3 rotZ = mat3(
        vec3(cos(yaw), 0.0, -sin(yaw)),
		vec3(0.0, 1.0, 0.0),        
        vec3(sin(yaw), 0.0, cos(yaw))
       );
    
    float phi = -0.1 + s.objRot.y;
    mat3 rotY = mat3(
        vec3(1.0, 0.0, 0.0),
        vec3(0.0, cos(phi), sin(phi)),
        vec3(0.0, -sin(phi), cos(phi))
       );
    
    mat3 localToWorld = rotY * rotZ;  
    
    lightDir = localToWorld * lightDir;
    
	vec3 rayOrigin 	= vec3(0.0, .3, -3.5);
    vec3 rayDir 	= normalize(vec3(p.x, p.y, 2.0));    
	float t = CastRay(rayOrigin, rayDir, localToWorld);
    if (t > 0.0)
    {
        vec3 pos = rayOrigin + t * rayDir;
        vec3 normal = SceneNormal(pos, localToWorld);        
        vec3 viewDir = -rayDir;
        vec3 refl = reflect(rayDir, normal);

        vec3 halfVec = normalize(viewDir + lightDir);
        float vdoth = saturate(dot(viewDir, halfVec));
        float ndoth	= saturate(dot(normal, halfVec));
        float ndotv = saturate(dot(normal, viewDir));
        float ndotl = saturate(dot(normal, lightDir));
        

		vec3 diffuse = lightColor * diffuseColor * saturate(dot(normal, lightDir));
        
        vec3 f = FresnelTerm(specularColor, vdoth);

        float d = AshikhminD(roughness, ndoth);
        float v = AshikhminV(ndotv, ndotl);
        
		if (s.menuId == 1.)
        {
            d = CharlieD(roughness, ndoth);
        	v = AshikhminV(ndotv, ndotl);
        }
        else if (s.menuId == 2.)
        {
            d = CharlieD(roughness, ndoth);
        	v = CharlieV(roughness, ndotv, ndotl);
        }        
        
        vec3 specular = lightColor * f * (d * v * PI * ndotl);
        
        color = diffuse + specular;
        color = pow(color, vec3(1. / 2.2));
    }
    else
    {
        // shadow
        float planeT = -(rayOrigin.y + 1.2) / rayDir.y;
        if (planeT > 0.0)
        {
            vec3 p = rayOrigin + planeT * rayDir;
            
            float radius = .7;
            color *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));
        }		
    }
}

// Function 1643
float isoline(float val, float lg, float ref, float pas, float tickness) {
    float v = abs(mod(val-ref+pas*.5, pas)-pas*.5)/lg - .1*tickness;
    return smoothstep(.2,.8, v);
}

// Function 1644
vec3 drawBg (vec2 uv)
{
    vec3 bg = mix(vec3(1.,.4,.2),vec3(.3,.4,1.), step(0.,uv.y));
    bg *= pow(min(1.,abs(uv.y)/0.2), 0.075);
	return bg;
}

// Function 1645
float drawObject2(in vec3 p){
    
    // Wrap conditions:
    // Anything that wraps the domain will work.
    //p = cos(p*6.2831853)*.25 + .25; 
    //p = abs(cos(p*3.14159)*.5);
    //p = fract(p) - .5; 
    //p = abs(fract(p) - .5); 
    
    // Cubic.
    p = abs(fract(p) - .5); 
    return max(max(p.x, p.y), p.z);


    // Hexagonal tube.
    p = abs(fract(p) - .5); 
    p = max(p*.866025 + p.yzx*.5, p.yzx);
    return max(max(p.x, p.y), p.z);
    
    
}

// Function 1646
vec3 digitRect(in vec2 uv, in int digit)
{
    uv = ((uv / 16.) * 2. - 1.02) * 0.6;
	return printDigi(digit, uv);
}

// Function 1647
vec4 draw_gun( ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(2,0), ivec2(15,8) ) ) {
        int x = iu.x, y = iu.y ;
        PREPARE_TEST_BIT ;
        BR16(7,   _,_,_,_,_,_,_,_,w,_,_,_,_,_,_,_  ) ;
        BR16(6,   _,_,_,_,_,_,_,w,w,w,_,_,_,_,_,_  ) ;
        BR16(5,   _,_,_,_,_,_,_,w,w,w,_,_,_,_,_,_  ) ;
        BR16(4,   _,_,_,w,w,w,w,w,w,w,w,w,w,w,_,_  ) ;
        BR16(3,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;
        BR16(2,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;
        BR16(1,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;
        BR16(0,   _,_,w,w,w,w,w,w,w,w,w,w,w,w,w,_  ) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 1648
void sceneDualCircles(vec2 uv, out vec3 params)
{
	uv *= .1+fract(iBeat*.0625*.5)*3.5;
	vec3 p=stereographic(uv);
	
	params = vec3(fract(p.x*2.+iBeat),rangeMoon);
}

// Function 1649
vec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {
    float r = radius*sqrt(Xi1);
    float theta = Xi2*TWO_PI;
	return vec2( r*cos(theta), r*sin(theta) );
}

// Function 1650
void DrawVoxelDust(inout vec4 O, in Voxel voxel, in int z, in vec3 p, in ivec2 c, in vec2 R) {
	float t = 1000.;
    vec3 color = mix(DARK_RED, RED, voxel.power/MAX_REDSTONE_POWER);

    bvec4 isConnected = z == 0 ? GetBottomDustConnections(c) : GetTopDustConnections(c);

    if(any(isConnected)) {
        if(any(isConnected.xy) && !any(isConnected.zw)) t = min(t,abs(p.y));
        else if(any(isConnected.zw) && !any(isConnected.xy)) t = min(t,abs(p.x));
            else {
                if(isConnected.x) t = min(t,udLine(p.xy,vec2(0),vec2(-1,0)));
                if(isConnected.y) t = min(t,udLine(p.xy,vec2(0),vec2(1,0)));
                if(isConnected.z) t = min(t,udLine(p.xy,vec2(0),vec2(0,-1)));
                if(isConnected.w) t = min(t,udLine(p.xy,vec2(0),vec2(0,1)));
            }
    } else {
        t = length(p.xy);
    }

    t -= wireRadius;

    O.rgb = mix(O.rgb, color, smoothstep(3./R.y, 0., t/p.z));
}

// Function 1651
bool isPointInLine(vec2 point, vec2 vert1, vec2 vert2){
    vec2 line = normalize(vert2-vert1);
    vec2 a = normalize(point-vert1);
    vec2 b = normalize(point-vert2);
    return dot(line,a)>0.0 && dot(line,b)<0.0;
}

// Function 1652
void centeredRect(float x, float y, float w, float h) {
	rect(x - w / 2.0, y - h / 2.0, w, h);
}

// Function 1653
vec3 draw_marble(float f)
{
    f = f * 0.5 + 0.5;
    return mix(	vec3(31.0/255.0, 14.0/255.0, 4.0/255.0),
              	vec3(172.0/255.0, 153.0/255.0, 138.0/255.0),
               	1.0 - pow(f, 5.));
}

// Function 1654
vec4 circle(vec2 uv, vec2 center, float radius, vec3 color, bool isSolid) 
{
	float d = (length(uv - center) - radius) * FADE_SCALE;
    d = isSolid ? d : abs(d);
	return vec4(color, 1. - clamp(d, 0., 1.));
}

// Function 1655
void drawPoint(vec2 uv, vec2 c, float radius, vec4 color, inout vec4 fragColor)
{
    c.x *= iResolution.x / iResolution.y;
    
    float a = 1.0 - smoothstep(0.0, 0.005, distance(uv, c) - radius);
    
    a = color.a * a;
    
    fragColor = mix(fragColor, color, a);
}

// Function 1656
float DistLine(vec3 ro, vec3 rd, vec3 p) {
	return length(cross(p-ro, rd));
}

// Function 1657
float circle (vec2 uv, float radius, float blur, vec2 offset){
    float dist = distance(uv, offset); 
    return smoothstep(radius, radius - blur, dist); 
}

// Function 1658
float drawASCIIRange(vec2 uv, vec2 pos, vec2 sz, ivec2 rng)
{
    float res = 0.0;
    float s = sz.x * 0.93; // step between glyphs
    for(int x = rng.x; x < rng.y; x++)
    {
        res += drawASCIIChar(uv, pos, sz, x);
        pos.x += sz.x + s;
    }
    return res;
}

// Function 1659
maybe_float get_distance_along_3d_line_to_circle(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 N,
    in float r
){
    // intersection(plane, sphere)
    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);
    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));
}

// Function 1660
vec2 randCircle(vec3 p) {
    
    vec2 rt = hash23(p);
    
    float r = sqrt(rt.x);
    float theta = 6.283185307179586 * rt.y;
    
    return r*vec2(cos(theta), sin(theta));
    
}

// Function 1661
float mapcircle(vec2 pos,float sp){
    float t = fract(-SPEED * iTime*sp);
    float dl = LENGTH / INTENSITY;
    vec2 p1 = circle(t * M_2_PI);
    vec2 p2 = circle((dl + t) * M_2_PI);
    vec2 c = (p1 + p2) / 2.0;
    float d = 1e9;
    
    for(float i = 2.0; i < INTENSITY; i++){
        p1 = p2;
        p2 = circle((i * dl + t) * M_2_PI);
        vec2 c_prev = c;
        c = (p1 + p2) / 2.;
        vec2 f = sdBezier(pos, c_prev, p1, c);
        d = min(d, f.x + FADING * (f.y + i) / INTENSITY);
    }
    return d;
}

// Function 1662
vec3 DrawNoise(vec2 uv){
	uv*=4.;
	float val =(PNoise(uv)+1.0)*0.5;
	return vec3(val,val,val);
}

// Function 1663
float wrapDirection(
    float unboundedDirectionIndex)
{
    return mod(unboundedDirectionIndex, 8.0);
}

// Function 1664
void directionOfAnisotropicity(vec3 normal, out vec3 tangent, out vec3 binormal){
    tangent = cross(normal, vec3(1.,0.,1.));
    binormal = normalize(cross(normal, tangent));
    tangent = normalize(cross(normal,binormal));
}

// Function 1665
float rectFrame(vec2 p, vec2 center, vec2 size, float thickness) {
    float outer = rect(p, center, size);
    float inner = rect(p, center, size - vec2(thickness));
    return max(outer, -inner);
}

// Function 1666
vec4 sampleOneCircle(vec2 circlePos, vec2 fragPos, vec3 colour)
{
    float circle = distance(fragPos, circlePos);
    circle = circle / CIRCLE_RADIUS;
    circle *= circle;
    circle = max(0.0, min(1.0, 1.0 - circle));
    circle *= circle;
    return vec4(colour, circle);
}

// Function 1667
vec4 drawShape(vec2 uv, vec2 position, int sides,float size, vec3 color) {
	uv -= vec2(position.x,position.y);
    // Angle from current pixel
  	float a = atan(uv.x,uv.y)+PI;
    // radius from current pixel
 	float r = 2.0*PI/float(sides);
  	// modulate the distance
  	float d = cos(floor(.5+a/r)*r-a)*length(uv);
	//define the edges, and make smooth
  	vec4 shape = vec4(smoothstep(size+.01,size,d));
  	//color the shape
    shape.rgb*=color;
	return shape;
}

// Function 1668
vec3 oklabToLinearSrgb(vec3 c) {
    return xyzToLinearSrgb(oklabToXyz(c));
}

// Function 1669
float drawBlob(
    in vec2 st,
    in vec2 center,
    in float radius,
    in float edgeSmoothing
) {
    float dist = length((st - center) / radius);
    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);
}

// Function 1670
void drawWindow(inout vec3 color, vec2 fragCoord, vec2 position, vec2 size)
{
    // Normalize to screen coords
    position.y = iResolution.y - size.y - position.y;
    
    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&
        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {
                
        color += (BAYER_MATRIX(fragCoord - position, ResolutionDivisor) - 0.5) * (0.99);

        vec3 quantizationPeriod = vec3(1.0 / PaletteRGBSize);

        color = vec3(
            quantize(color.r, quantizationPeriod.r),
            quantize(color.g, quantizationPeriod.g),
            quantize(color.b, quantizationPeriod.b)
        );

        vec2 titleSize = vec2(size.x - (BORDER_WIDTH * 2.0) + 2.0, 20.0);
        vec2 titlePos = vec2(position.x + BORDER_WIDTH - 1.0, position.y + size.y - titleSize.y - BORDER_WIDTH + 1.0);
        drawTitle(color, fragCoord, titlePos, titleSize);
        
        drawBorder(color, fragCoord, position, size);
    }
}

// Function 1671
vec4 drawKey( vec2 uv, int color ) {
    uv = floor(fract(uv)*64.) - 32.;
    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {
        float l = step(abs(uv.y), 1.);
        l = max(l, step(length(uv+vec2(8,0)), 7.5));
        l -= step(length(uv+vec2(8,0)), 4.5);
        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));
        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));
        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));
        
	    vec3 col = vec3(0);
    	col[color-7] = 1.;
        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );
    } else {
        return vec4(0);
    }
}

// Function 1672
vec3 getRandomDirection(vec2 seed){
    vec2 param = random2(seed);
    float theta = TWO_PI * param.x;
    float phi = acos(1.0 - 2.0 * param.y);
	return sphericalToCartesian(theta, phi);
}

// Function 1673
float drawLineSegment(vec2 A, vec2 B, float r)
{
    vec2 g = B - A;
    vec2 h = uv - A;
    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));
	return smoothstep(r, 0.5*r, d);
}

// Function 1674
float lineDist2D(vec3 l, vec2 p) {
    float s = length(l.xy);
    return (dot(l.xy, p) + l.z)/s;
}

// Function 1675
void drawBird(vec2 co)
{
	float animationCycleLength = HORZ_PIPE_DISTANCE * PIPE_PER_CYCLE; // the number of frames after which the animation should repeat itself
	int cycleFrame = int(mod(iTime * 60.0, animationCycleLength));
	float fCycleFrame = float(cycleFrame);	
	
	const float START_POS = 110.0;
	const float SPEED = 2.88;
	const float UPDOWN_DELTA = 0.16;
	const float ACCELERATION = -0.0975;
	float jumpFrame = float(int(mod(iTime * 60.0, 30.0)));
	int horzDist = int(HORZ_PIPE_DISTANCE);
	
	// calculate the "jumping" effect on the Y axis.
	// Using equations of motion, const acceleration: x = x0 + v0*t + 1/2at^2  
	float yPos = START_POS + SPEED * jumpFrame + ACCELERATION * pow(jumpFrame, 2.0);
	
	float speedDelta = UPDOWN_DELTA * mod(fCycleFrame, HORZ_PIPE_DISTANCE);
	int prevUpCycles = 0;
	int prevDownCycles = 0;
	
	// count the number of pipes we've already passed. 
	// for each such pipe, we deduce if we went "up" or "down" in Y
	int cycleCount = int(fCycleFrame / HORZ_PIPE_DISTANCE);
	
	for (int i = 0; i < 10; i++) {
		if (i <= cycleCount) {
			if (i == 1) {
				prevUpCycles++;
			}
			
			if ((i >= 2) && (i < 6)) {
				prevDownCycles++;	
			}
			if (i >= 6) {
				prevUpCycles++;
			}		
		}
	}
	
	// add up/down delta from all the previous pipes
	yPos += ((float(prevUpCycles - prevDownCycles)) * HORZ_PIPE_DISTANCE * UPDOWN_DELTA);
	
	// calculate the up/down delta for the current two pipes, and add it to the previous result
	if (((cycleFrame >= 0) && (cycleFrame < horzDist)) ||
		((cycleFrame >= 5*horzDist) && (cycleFrame < 9*horzDist))) {
		yPos += speedDelta;
	}
	else {
		yPos -= speedDelta;	
	}	
	
	int animFrame = int(mod(iTime * 7.0, 3.0));
	if (animFrame == 0) drawTile(3, vec2(105, int(yPos)), co);
	if (animFrame == 1) drawTile(4, vec2(105, int(yPos)), co);
	if (animFrame == 2) drawTile(5, vec2(105, int(yPos)), co);
}

// Function 1676
float circleTile(vec2 st, float tileSize, float radius) {
    vec2 tilePos = vec2(fract(st.x/tileSize), fract(st.y/tileSize));
    return circle(tilePos, vec2(0.5), radius);
}

// Function 1677
void lineCircleInt(vec2 C, float r, vec2 p1, vec2 p2, out vec2 a1, out vec2 a2) {
    // solve length(p1 + t(p2-p1) - C) = r for t
    // d = p2 - p1
    // q = p1 - C
    // length(td+q) = r
    // (td + q).(td + q) = r*r
    // tt*d.d + t*2d.q + q.q - r*r = 0
    // solve quadratic where a=d.d, b=2d.q, c=q.q-r*r
    vec2 d = p2 - p1;
    vec2 q = p1 - C;
    float a = dot(d, d); // cannot be negative
    float b = 2. * dot(d, q); // can be negative
    float c = dot(q, q) - r*r;
    // x = (-b +- sqrt(b*b - 4ac)) / 2a
    // since line intersects circle, discrim must be >= 0
    float discrim = max(0., b * b - 4. * a * c);
    discrim = sqrt(discrim);
    float t1 = ( -b - discrim ) / (2. * a);
    float t2 = ( -b + discrim ) / (2. * a);
    a1 = p1 + t1 * d;
    a2 = p1 + t2 * d;
}

// Function 1678
float draw_num(vec2 pos, float R, int num){
    float line = 0.;
    if(num==0 || num==2 || num==6 || num==8)              // bottom left
        line += d_seg(pos, vec2(-1,-2), vec2(-1, 0), R);
    if(num!=1 && num!=2 && num!=3 && num!=7)              // top left
        line += d_seg(pos, vec2(-1, 0), vec2(-1, 2), R);
    if(num!=1 && num!=4)                                  // top
        line += d_seg(pos, vec2(-1, 2), vec2( 1, 2), R);
    if(num!=5 && num!=6)                                  // top right
        line += d_seg(pos, vec2( 1, 2), vec2( 1, 0), R);
    if(num!=2)                                            // bottom right
        line += d_seg(pos, vec2( 1, 0), vec2( 1,-2), R);
    if(num!=1 && num!=4 &&num!=7)                         // bottom
        line += d_seg(pos, vec2( 1,-2), vec2(-1,-2), R);
    if(num!=0 && num!=1 && num!=7)                        // center
        line += d_seg(pos, vec2(-1, 0), vec2( 1, 0), R);
    return line;
}

// Function 1679
float drawFloat(in vec2 charCoord, float value,
		float digits, float decimals) {
	charCoord *= RESOLUTION*RESOLUTION;
	float bits = 0.;
	if(charCoord.y < 0. || charCoord.y >= 1.5 || charCoord.x < step(-value,0.)) return bits;
	float digitIndex = digits - floor(charCoord.x)+ 1.;
	if(- digitIndex <= decimals) {
		float pow1 = pow(10., digitIndex);
		float absValue = abs(value);
		float pivot = max(absValue, 1.5) * 10.;
		if(pivot < pow1) bits = 1792.*float(value < 0. && pivot >= pow1 * .1);
		else if(digitIndex == 0.) bits = 2.*float(decimals > 0.);
		else {
        	value = digitIndex < 0. ? fract(absValue) : absValue * 10.;
            int x=int (mod(value / pow1, 10.));
			bits = x==0?480599.:x==1?139810.:x==2?476951.:x==3?476999.:x==4?350020.:x==5?464711.:x==6?464727.:x==7?476228.:x==8?481111.:x==9?481095.:0.;
		}
	}
	return floor(mod(bits / pow(2., floor(fract(charCoord.x) * 4.) + floor(charCoord.y * 4.) * 4.), 2.));
}

// Function 1680
float sdLineBox(vec3 p, vec3 b, float r)
{
    p = abs(p);
    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);
    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);
    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);
    return min(min(cx, cy),cz);
}

// Function 1681
vec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd) {
  vec3 col = vec3(0);
  vec3 line = vec3(1, 1, 1);
  vec2 _ro = ro;

  for (int i = 0; i < TRACE_STEPS; i++) {
    float t = SAMPLER(ro);
    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));
    col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));
    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));
    ro += rd * t;
    if (t < 0.01) break;
  }

  #ifdef TRACE_RAY
    col += 1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.);
  #endif

  return col;
}

// Function 1682
vec3 circle( vec3 bcol, vec3 col, in vec2 a, in vec2 b )
{
	float rr = 0.04;
	
	vec3 res = mix( bcol, col, 1.0 - smoothstep( rr-0.01, rr, length(a-b) ) );
	
	float f = smoothstep( rr-0.01, rr, length(a-b) ) - smoothstep( rr, rr+0.01, length(a-b) );
		
	return mix( res, vec3(0.0), f );
}

// Function 1683
v1 LineISect(v1 a,v1 b,v1 u,v1 d
){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)
 ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))
 ;if(u.y==0.)return v1(0)//parralel lines do not intersect.
 ;c*=v3(u.xx,vec2(dot(c.xy,a)))
 ;return (c.wx-c.yz)/u.y;}

// Function 1684
vec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)
{
    float width = cMax.x-cMin.x;
    float height = cMax.y-cMin.y;
    vec2 ar = vec2(0.30,1.0);
    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization
    muv = (muv-cMin)/vec2(width,height); //mouse Normalization
    if( withinUnitRect(uv))
    {
        float t = SLIDER_getValue(uv.x);
		bool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;
		uv.x = fract(uv.x*4.0); //repeat 4x
		uv.y = uv.y/0.75-0.125; //25% margins
        return SLIDER_drawSingle(vec2(uv.x*2.-.5, uv.y),t,ar,bHighlight);
    }
    return vec4(0);
}

// Function 1685
bool circle(float2 p, float r)
{
    p=abs(p);
    if((p.x>r+.5)||(p.y>r+.5))
        return false;
    if(p.x<p.y)
        p.xy=p.yx;
    if(abs(p.x-sqrt(r*r-p.y*p.y))<0.5)
       return true;
    return false;
}

// Function 1686
vec2 circle(in vec2 rd, in vec3 sph )
{
    vec2 oc = sph.xy;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.z*sph.z;
    float h = b*b - c;
    if( h<0.0 || dot(sph.xy,sph.xy) > sph.z*sph.z) return vec2(0.0);
    h = sqrt( h );
    return -b + vec2(-h,h);
}

// Function 1687
void DrawWheel (in vec2 uv, in vec2 wheelPos, inout vec3 pixelColor, bool touchingGround)
{
    vec3 wheelColor = vec3(0.0);
    
    #if DEBUG_WHEELSTOUCHING
    if (touchingGround)
    	wheelColor = vec3(0.5,1.0,0.5);    
    #endif
        
	float zoomCircleDist = UDCircle(uv, wheelPos, c_wheelRadius);
    zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);
    pixelColor = mix(pixelColor, wheelColor, zoomCircleDist);    
    
	zoomCircleDist = UDCircle(uv, wheelPos, c_wheelRadius*0.5);
    zoomCircleDist = 1.0 - smoothstep(0.0, AA_AMOUNT, zoomCircleDist);
    pixelColor = mix(pixelColor, vec3(0.75), zoomCircleDist);      
}

// Function 1688
float distToLine(vec2 A, vec2 B, vec2 p){
    
    vec2 PA = p - A;
    vec2 BA = B - A;
    float d = dot(PA,BA);
    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt
    vec2 normal = PA - BA*t;
    return length(normal);

}

// Function 1689
float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
	    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);
    else
        return 0.0;
}

// Function 1690
vec3 StyleScanline( float f, in vec2 fragCoord )
{
	float fShade = f * 0.8 + 0.2;
	
	fShade *= mod(fragCoord.y, 2.0);
	
	return mix(vec3(0.01, 0.2, 0.01), vec3(0.01, 1.0, 0.02), fShade);
}

// Function 1691
float circleSDF(vec2 st) { // 08
    return length(st - 0.5) * 2.;
}

// Function 1692
vec3 drawMaths( vec3 col, in ProjectionResult res, in vec2 p )
{
	float showMaths = 1.0;//smoothstep( -0.5, 0.5, cos(0.5*6.2831*lTime) );

	float impl = res.a*p.x*p.x + res.b*p.y*p.y + res.c*p.x*p.y + res.d*p.x + res.e*p.y + res.f;
	
	col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.00,0.10, abs(impl))));
	col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisA, res.center+res.axisA, p  )) ));
	col = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisB, res.center+res.axisB, p  )) ));
	col = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.03,0.04, length(p-res.center))));
    vec2 pp  = res.center + 0.5*max( max( res.axisA, -res.axisA ), max( res.axisB, -res.axisB ) );
	col = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))/0.07, floor(res.area) ) );

	return col;
}

// Function 1693
vec3 WavelengthToRGBLinear( float fWavelength )
{
     mat3 m = mat3( 2.3706743, -0.9000405, -0.4706338,
	-0.5138850,  1.4253036,  0.0885814,
 	0.0052982, -0.0146949,  1.0093968 );
    return WavelengthToXYZLinear( fWavelength ) * m;
}

// Function 1694
void InitRectPoints(Rect rect, out vec3 points[4])
{
    vec3 ex = rect.halfx*rect.dirx;
    vec3 ey = rect.halfy*rect.diry;

    points[0] = rect.center - ex - ey;
    points[1] = rect.center + ex - ey;
    points[2] = rect.center + ex + ey;
    points[3] = rect.center - ex + ey;
}

// Function 1695
C_DirectionalLight GetDirectionalLight()
{
    C_DirectionalLight result;

    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));
    result.cColour = vec3(8.0, 7.5, 7.0);

    return result;
}

// Function 1696
vec3 gamma_to_linear(vec3 c)
{
    return vec3(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b));
}

// Function 1697
float lines(vec2 p, vec2 bpp, float bsz, float z, int idx, bool xx) {
    float d = 0.;
    vec2 bszx = bsz * vec2(msize);
    p += bpp - bszx / 2.;
    d = max(d, SS(zv*z, -zv*z, abs(sdBox(p, bszx / 2.) - 0.01) - 0.002));
    if (xx)if (idx == int(lgs2().x) + 1) d = max(d, 0.25 * SS(zv * z, -zv * z, (sdBox(p, bszx / 2.) - 0.01) - 0.002));
    if (p.y > 0.35)d = max(d, float(PrintInt((p + vec2(0.197, -0.36)) * vec2(25., 12.), idx, 6)));
    if (p.y > 0.35) {
        loadlogic(idx);
        d = max(d, 0.5 * float(PrintInt((p + vec2(-0.046, -0.385)) * vec2(25., 20.),
                (logicw.y << 8) + logicw.z, 4)));
    }
    return d;
}

// Function 1698
vec4 drawKernelUI(vec2 uv, const Kernel kernel, float radiusStrength, float mipLevel)
{
    vec4 uiCol = vec4(0.0, 0.2, 0.9, 0.6);
    
    // Mip bar
    const float mipBarScale = 0.1;
    vec4 mipBarRect = vec4(0.35, mipLevel / (MIPMAP_MAX_LEVEL + epsilon) * mipBarScale, 0.365, 0.03);
    float mipBar = float(uv.x > mipBarRect.x && uv.x < mipBarRect.z && uv.y > mipBarRect.w && uv.y < (mipBarRect.y + mipBarRect.w));
    mipBar *= float(fract((uv.y - mipBarRect.w) * MIPMAP_MAX_LEVEL / mipBarScale) < 0.9);
    
    // Function graph
    const float vRange = 0.25;
    const float graphBottom = 0.03;
    const float graphMax = 0.25;
    const vec2 graphScale = vec2(0.25, 0.4);
    const float fMaxRadiusRec = 1.0 / (float(KERNEL_MAX_RADIUS) - 0.5);
    float xCenter = (uv.x - 0.5) * 2.0;
    
    float fX = (xCenter / graphScale.x) / ((float(kernel.radius) - 0.5) * fMaxRadiusRec);
    float f = 0.0;
    f += float(kernel.filterType == FILTER_TYPE_GAUSSIAN) * gaussian2d(vec2(fX, 0.0), FILTER_SIGMA);
    f += float(kernel.filterType == FILTER_TYPE_TENT) * tent2d(vec2(fX, 0.0));
    f += float(kernel.filterType == FILTER_TYPE_BOX) * float(abs(fX) <= 1.0);
    f -= float(kernel.filterType >= FILTER_TYPE_LAPLACIAN);
    f *= graphScale.y;
    
    float funcLine = float(abs(xCenter) < graphMax && uv.y > (f * vRange + graphBottom) && uv.y < (f * vRange + graphBottom + 0.005));
    
    // Kernel graph (unnormalized)
    int i = int(abs(xCenter / graphScale.x * (float(KERNEL_MAX_RADIUS) - 0.5)) + 0.5);
    float k = float(i < kernel.radius) * kernel.data[i] * kernel.sum * graphScale.y;
    
    float kernelBars = float(uv.y > graphBottom && uv.y < (k * vRange + graphBottom));
    
    float kernelColFade = 1.0 - (float(i) / float(KERNEL_MAX_RADIUS)) * 0.5;
    vec4 kernelCol = vec4(0.0, kernelColFade, kernelColFade, 0.7) * kernelBars;
    
    // Radius bar
    float radiusStrengthBar = float(uv.y < 0.02 && abs(xCenter) < (floor(radiusStrength) - 0.5) * fMaxRadiusRec * graphScale.x);
    
    // Combine UI elements
    return mix(uiCol * (mipBar + radiusStrengthBar + funcLine), kernelCol, kernelCol.a);
}

// Function 1699
vec4 drawBoat(vec4 pixel, vec2 uv, vec2 position, float size) {


    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .015, HEAD_COLOR);
    pixel = drawCircle(pixel, uv, vec2(position.x + 0.007, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .002, EYE_COLOR);

    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);
    pixel = drawCircle(pixel, uv, vec2(position.x+0.02, heightAt(vec2(position.x+0.02, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);
    pixel = drawCircle(pixel, uv, vec2(position.x+0.04, heightAt(vec2(position.x+0.04, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);
    pixel = drawCircle(pixel, uv, vec2(position.x+0.06, heightAt(vec2(position.x+0.06, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);

    return pixel;
}

// Function 1700
void DrawLittleParts(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    float texpNormPow = pow(t, 0.5);
    vec2 gravity = gGravity * 0.15;
    
    vec2 scaleDirection = normalize(vec2(hash(id+5.228), hash(id+9.8921)));
    for(float i=0.; i < 20.5; ++i)
    {   
        // Main Properties
        float iNorm = i*0.0334;
        float hashP = hash(i*42.856+198.5984);
        float pSpeed = ceil(hashP*5.)/5. * 0.60;
        vec2 pVel = normalize(vec2(cos(iNorm*PI2), sin(iNorm*PI2)));
        pVel *= 0.60+0.4*pow(abs(dot(scaleDirection, pVel)), 0.70);
        
        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.5), 0., 1.);

        // Visibility Properties
        float sizeScale = (0.6+0.4*hashP);
        float flicker = max(sign(hash(i + t)*2.-1. - 0.90), 0.);
        flicker = mix(1., flicker, step(0.25, t + hashP*0.1));
        float size = sizeScale*expSize*0.030;

        // Position
        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.5*hashP+0.5)*gravity*t*t;
        vec2 q = p - deltaPos;

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, q, size, t, pColor, 10., 5.*hash(i+t*10.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
}

// Function 1701
void draw_console(inout vec4 fragColor, vec2 fragCoord, Lighting lighting)
{
    fragColor.rgb *= linear_step(1., .5, g_console.expanded);

   	vec2 uv = fragCoord.xy / iResolution.xy;
	if (uv.y < 1. - g_console.expanded)
        return;
    
    float loaded = lighting.progress;
    float xfade = clamp(g_time / CONSOLE_XFADE_DURATION, 0., 1.);
    
    uv.y -= 1. - g_console.expanded;
    float vignette = 1. - clamp(length(uv - .5)*2., 0., 1.);
  
    float aspect_ratio = iResolution.x/iResolution.y;
    uv.x = (uv.x - 0.5) * aspect_ratio + 0.5;

    float base = turb(uv * vec2(31.7,27.9)/aspect_ratio, .7, 2.5);
    
    // loading screen (modern style) //
    
    vec3 modern = vec3(linear_step(.45, .7, base) * 0.1);
    if (xfade < 1.)
    {
        modern *= sqr(vignette);

        const float MODERN_LOGO_SCALE = .75;

        vec2 logo_uv = (uv - .5) * (1./MODERN_LOGO_SCALE) + .5;
        vec4 modern_logo = embossed_modern_Q(logo_uv, loaded, .006, vec2(.7, .3)).xxxy;

        float flame_flicker = mix(.875, 1., smooth_noise(2.+iTime*7.3));
        float scratches = linear_step(.35, .6, turb(vec2(480.,8.)*rotate(uv, 22.5), .5, 2.) * base);
        scratches += linear_step(.25, .9, turb(vec2(480.,16.)*rotate(uv, -22.5), .5, 2.) * base);

        modern_logo.rgb *= vec3(.32,.24,.24);
        modern_logo.rgb *= smoothstep(.75, .0, abs(uv.x-.5));
        modern_logo.rgb *= 1.8 - 0.8 * linear_step(.55, mix(.15, .35, loaded), base);
        modern_logo.rgb *= 1. - scratches * .4;
        modern_logo.rgb *= 1. + 4. * sqr(clamp(1. - length(uv - vec2(.76, .37))*2.3, 0., 1.));
        modern_logo.rgb *= 1. + flame_flicker*2.5*vec3(1.,0.,0.) * sqr(clamp(1. - length(uv - vec2(.20, .40))*3., 0., 1.));

        modern = mix(modern, modern_logo.rgb, modern_logo.a);

        float flame_vignette = length((uv - vec2(.5,0.))*vec2(.5, 1.3));
        float flame_intensity = flame_vignette;
        flame_intensity = sqr(sqr(clamp(1.-flame_intensity, 0., 1.)) * flame_flicker);
        flame_intensity *=
            turb(uv * vec2(41.3,13.6)/aspect_ratio + vec2(0.,-iTime), .5, 2.5) +
            turb(uv * vec2(11.3,7.6)/aspect_ratio + vec2(0.,-iTime*.9), .5, 2.5);
        modern += vec3(.25,.125,0.) * flame_intensity;

        vec2 spark_uv = vec2(uv + vec2(turb(uv*1.3, .5, 2.)*.6, -iTime*.53));
        float spark_intensity =
            sparks(vec2(11.51, 3.13) * spark_uv,				vec2(.06,.05)) * 2. +
            sparks(vec2(4.19, 1.37) * spark_uv + vec2(1.3,3.7),	vec2(.06,.05)) * 1.;
        spark_intensity *= flame_intensity;

        spark_uv = vec2(uv*.73 + vec2(turb(uv*1.25, .7, 1.9)*.4, -iTime*.31));
        float spark_intensity2 = turb(vec2(25.1, 11.5) * spark_uv, .5, 2.);
        spark_intensity2 = 0.*linear_step(.43, .95, spark_intensity2) * flame_intensity*.2;
        modern += vec3(1.,1.,.3) * (spark_intensity + spark_intensity2);

        modern += loading_spinner(fragCoord);
    }
    
    // console (classic style) //

    const float CLASSIC_LOGO_SCALE = 1.1;
    const vec2 CLASSIC_LOGO_CENTER = vec2(.5, .45);
    const vec2 CLASSIC_LIGHT_DIR = vec2(0, 1.5);
    float classic_shadow_size = mix(.01, .05, base);
    vec2 CLASSIC_SHADOW_OFFSET = CLASSIC_LIGHT_DIR * classic_shadow_size;
    float classic_logo_distortion = base * .015 - .01;
    float classic_logo = sdf_Q((uv-CLASSIC_LOGO_CENTER) / CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;
    
    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);
    vec2 box_size = vec2(.5) * aspect - mix(.005, .03, sqr(base));
    float classic_console_box = sdf_centered_box(uv, vec2(.5), box_size);
    
    const vec2 CLASSIC_ID_LOGO_MARGIN = vec2(24./450., 48./450.);
    const float CLASSIC_ID_LOGO_SIZE = 64./450.;
    const float CLASSIC_ID_LOGO_BOX_JAGGEDNESS = 0.; //0.02;
    
    vec2 logo_mins = vec2((.5+.5*aspect.x)-CLASSIC_ID_LOGO_MARGIN.x-CLASSIC_ID_LOGO_SIZE, CLASSIC_ID_LOGO_MARGIN.y);
    
    classic_console_box = sdf_exclude(classic_console_box,
                                      4.*sdf_box(uv, logo_mins, logo_mins + CLASSIC_ID_LOGO_SIZE) +
                                      (base*2.-1.) * CLASSIC_ID_LOGO_BOX_JAGGEDNESS);
   
    float noise2 = turb(uv*43.7, .5, 2.0)-.15;
    classic_console_box = sdf_exclude(classic_console_box, noise2*.1);
    
    float bevel_size = mix(.001, .07, sqr(base));
    float classic_sdf = sdf_exclude(classic_console_box, classic_logo+.01);
    float classic_base = sdf_emboss(classic_sdf, bevel_size, CLASSIC_LIGHT_DIR).x;

#if 1
    // slightly odd, gradient-based automatic shadow
    float classic_shadow = sdf_shadow(classic_sdf, classic_shadow_size, CLASSIC_LIGHT_DIR);
#else
    // smooth version with secondary SDF sample
    // only sampling the Q logo SDF, not the composite one!
    float classic_shadow_sample = sdf_Q((uv+CLASSIC_SHADOW_OFFSET-CLASSIC_LOGO_CENTER) / CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;
    float classic_shadow = sdf_mask(classic_logo) * clamp(classic_shadow_sample/classic_shadow_size+.3, 0., 1.);
#endif

    vec4 classic = vec4(mix(vec3(.07,.03,.02)*(1.+base*2.)*(1.-classic_shadow), vec3(.24,.12,.06), classic_base), 1.);
    classic.rgb *= 1. - .05*linear_step(.35, .3, base);
    classic.rgb *= 1. + .05*linear_step(.6, .65, base);
    
    print_console_logo(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE), base);
	print_console_version(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE));
    print_console_text(classic, fragCoord);
    
    classic.rgb = floor(classic.rgb * 64. + random(floor(uv*128.))) * (1./64.);

	float burn_fraction = xfade * (2.-clamp(length(uv-vec2(.5,0.)), 0., 1.));
    fragColor.rgb = burn_xfade(modern, classic.rgb, base, burn_fraction);
}

// Function 1702
void DrawBuilding( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 buildingTile, float h )
{
    float depth = buildingTile.x + buildingTile.y;
    if ( depth > zbuffer )
    {
        return;
    }    
    
    buildingTile.x += h;
    buildingTile.y += h;    
    
    pixel.y -= ISO_TILE * 0.25;
    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );
    tile = floor( iso );
    vec2 off = iso - tile;
    
	// roof
    if ( tile.x == buildingTile.x && tile.y == buildingTile.y && off.x > 0.2 && off.y > 0.2 && off.x < 0.98 && off.y < 0.98 )
    {
        zbuffer = depth;
        color = RGB_BUILDING;

        if ( off.x < 0.28 || off.y < 0.28 || off.x > 1.0 - 0.08 || off.y > 1.0 - 0.08 )
        {
            color *= 1.2;
        }
    }
    
    float px = ( buildingTile.x - buildingTile.y ) * ISO_TILE * 0.5;
    
    // right wall
    if ( pixel.x >= px && pixel.x < px + 0.39 * ISO_TILE && iso.y < buildingTile.y + 0.20 && iso.y > buildingTile.y - h - 0.4 )
    {
		zbuffer = depth;
		color = RGB_RIGHT_WALL;
        
		if ( mod( iso.y + 0.2, 0.5 ) < 0.25 )
		{
			color *= RGB_WINDOWS;
			color *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;
		}
    }
    
    // left wall
    if ( pixel.x >= px - 0.39 * ISO_TILE && pixel.x < px && iso.x < buildingTile.x + 0.20 && iso.x > buildingTile.x - h - 0.4 )
    {
        zbuffer = depth;        
		color = RGB_LEFT_WALL;        
        
		if ( mod( iso.x + 0.2, 0.5 ) < 0.25 )
		{
			color *= RGB_WINDOWS;
			color *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;
		}
    }
}

// Function 1703
vec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)
{
    vec4 sample_color = texture(tex, uv, 0.0);
#ifdef PACK_SIGNED_TO_UNSIGNED
    sample_color = 2.0 * sample_color - 1.0;
#endif // PACK_SIGNED_TO_UNSIGNED
    return sample_color;
}

// Function 1704
void drawScore( ivec2 uv, ivec2 rt, float score, inout vec3 col ) {
    for (int i=0; i<6; i++) {
        if (score > 0. || i == 0) {
            float s = mod(score, 10.);
            drawSprite(uv, rt, rt+ivec2(8,7), ivec2(72,73) + ivec2(s*8.,0), iChannel1, false, col);
            rt.x -= 8;
            score = floor(score * .1);
        }
    }
}

// Function 1705
float chirp_linear(float t)
{
    return sin(2.0 * pi * (t + 0.5 * t * t));
}

// Function 1706
void RectExpand( inout Rect region, vec2 vPadding )
{
    // Padding
    region.vPos -= vPadding;
    region.vSize += vPadding * 2.0;        
}

// Function 1707
vec3 TrilinearSamplerIBL(vec3 dir,float roughness){
    vec3 axis = getAxis(dir);
   	vec3 uvw = GetUVW(axis,dir);
    float roughness_ID = roughness * ID_Range.x;
    float pre_ID  = floor(30.-roughness_ID);
    float next_ID = pre_ID - 1.;
    vec3 pre_dir  = GetReadMipMapUVW_Dir2(uvw,axis,pre_ID);
	vec3 next_dir = GetReadMipMapUVW_Dir2(uvw,axis,next_ID);
    vec3 preCol   = IBL(pre_dir);
    vec3 nextCol  = IBL(next_dir);
    return mix(preCol,nextCol,fract(roughness * ID_Range.x));
}

// Function 1708
float sdf_line6(vec2 st, vec2 vert_a, vec2 vert_b){
    vec2 dvec_ap = st - vert_a;      // Displacement vector from vert_a to our current pixel!
    vec2 dvec_ab = vert_b - vert_a;  // Displacement vector from vert_a to vert_b
	vec2 direction = normalize(dvec_ab);  // We find a direction vector, which has unit norm by definition!
    return crossnorm_product(dvec_ap, direction);  // Ah, the mighty cross-norm product!
    //return crossnorm_product(dvec_ap, direction) / dot_product(dvec_ab, dvec_ab);  // I thought this would work, but it doesn't: AA is all messed up!
}

// Function 1709
vec3 color_spline(float t, bool wrap)
{
    t = clamp(t, 0.0, 1.0);
    
    const int s = 7;
    
    vec3 p[s];
    p[0] = vec3(238, 64, 53) / 255.0;
    p[1] = vec3(243, 119, 54) / 255.0;
    p[2] = vec3(253, 244, 152) / 255.0;
    p[3] = vec3(123, 192, 67) / 255.0;
    p[4] = vec3(3, 146, 207) / 255.0;
    
    p[s-2] = p[0];
    p[s-1] = p[1];
    
    float m = wrap ? float(s - 2) : float(s - 3);
    float d = m * t;
    
    int b = int(d);
    float dt = d - floor(d);
    
    return catmul_rom(p[((b-1)+s)%s], p[b], p[b+1], p[(b+2)%s], dt);
}

// Function 1710
vec4 Line4NoRepeat(const vec4 y, const vec4 offset, const vec4 thickness, const vec4 smoothness)
{
    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(offset - y));
}

// Function 1711
vec2 EquiRectToCubeMap(vec2 uv)
{
    vec2 gridSize = vec2(4,3); // 4 faces on x, and 3 on y
	vec2 faceSize = 1.0 / gridSize; // 1.0 because normalized coords
    vec2 faceIdXY = floor(uv * gridSize); // face id XY x:0->2 y:0->3
    
    // define the y limit for draw faces
    vec2 limY = vec2(0, uv.y);
    if (faceIdXY.x > 1.5 && faceIdXY.x < 2.5) // top & bottom faces
    	limY = vec2(0,faceSize.y*3.);
    else // all others
        limY = vec2(faceSize.y,faceSize.y*2.);

    // limit display inside the cube faces
    if ( uv.y >= limY.x && uv.y <= limY.y
#ifdef FACE_QUAD_SIZE
        && uv.x <= 1.0 
	#ifdef FACE_QUAD_SIZE_WITH_CENTERING
        && uv.x >= 0.0         
	#endif    
#endif
)
	{
        // get face id
        float faceId = 0.;
        if (faceIdXY.y<0.5) 	faceId = 4.;		 // top
        else if(faceIdXY.y>1.5) faceId = 5.;		 // bottom
        else 				    faceId = faceIdXY.x; // all others

        // face coord uvw
        vec3 p = getFaceUVW(uv,faceId,faceSize);
        
        // spheric to surface
        float theta = atan(p.y,p.x);
        float r = length(p);
        
        // correct spheric distortion for top and bottom faces
        // instead of just atan(p.z,r)
        float phi =  asin(p.z/r);
        
        return 0.5 + vec2(theta / _2pi, -phi / _pi);
    }
    return vec2(0); // outside faces => uv(0,0)
}

// Function 1712
float drawSquare( vec2 p1, vec2 p2 )
{
    return distance(distance(p1.x, p2.x),distance(p1.y,p2.y));
}

// Function 1713
vec4 toLinear(vec4 color, const transfer trc)
{
	bvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));
	bvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));
	vec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));
	vec4 lower = color/trc.slope;
	vec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));

	vec4 result = mix(higher, lower, cutoff);
	return mix(result, neg, negCutoff);
}

// Function 1714
float rect(vec2 p, vec2 r)
{
    float v = max(p.x - r.x, -p.x - r.x);
    float h = max(p.y - r.y, -p.y - r.y);
    return max(v, h);
}

// Function 1715
float starline(vec2 relpos,float confradius,float filmsize)
{
	if(abs(relpos.y)>confradius) return 0.0;
	float y=relpos.y/confradius;
	float d=abs(relpos.x/filmsize);
	return sqrt(1.0-y*y)/(0.0001+d*d)*0.00001;
}

// Function 1716
float rect (in vec2 pixel_n, in float x1, in float y1, in float x2, in float y2) {
    // float blur = 0.05;
    vec2 bl_borders = step(vec2(x1, y1), pixel_n);
    vec2 tr_borders = vec2(1.0) - step(vec2(x2, y2), pixel_n);
    float brightness = bl_borders.x * bl_borders.y * tr_borders.x * tr_borders.y;
    return brightness;
}

// Function 1717
vec3 cosineDirection( in float seed, in vec3 nor)
{
    vec2 uv = hash2( seed);

    // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html
    float a = 6.2831853 * uv.y;
    float u = 2.0*uv.x - 1.0;
    return /*normalize*/( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
}

// Function 1718
vec4 hardRect(vec4 inpColor, vec4 rectColor, vec2 uv, vec2 tl, vec2 br)
{
    if(uv.x < tl.x)
        return inpColor;
    if(uv.x > br.x)
        return inpColor;
    if(uv.y < tl.y)
        return inpColor;
    if(uv.y > br.y)
        return inpColor;
    return rectColor;
}

// Function 1719
void DrawLeaves(inout vec3 col, vec4 branchCoord, float segmentLength, float treeShouldExist, float seed, vec2 uv)
{
     float randLeaveSpace;

   branchCoord.x += sin(branchCoord.z*5. + rand(seed) * 6.12)*0.05;

   float leaveShape = GetLeaveShapes(branchCoord, segmentLength, treeShouldExist, seed , randLeaveSpace);
   
   float noiseMask = pow(texture(iChannel0,uv*3.).x,5.);
   vec3 leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);
 leaveColor = mix(leaveColor, paper_color ,  noiseMask);
   
   float leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);
   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));
   branchCoord.x += /*sin(branchCoord.z*5. + rand(seed+62.721) * 6.12 )*0.05 + */
                    sin(branchCoord.x*5. + rand(seed+62.721) * 6.12 )*0.05  ;
   leaveShape = GetLeaveShapes(branchCoord + vec4(0.15,0.,0.,0.), segmentLength, treeShouldExist, seed +62.213, randLeaveSpace);
   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);
  
  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);
 leaveColor = mix(leaveColor, paper_color ,  noiseMask);
  
  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));
   
    leaveShape = GetLeaveShapes(branchCoord + vec4(-0.1521,0.,0.,0.), segmentLength, treeShouldExist, seed +9.213, randLeaveSpace);
   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);
   
   leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);
 leaveColor = mix(leaveColor, paper_color ,  noiseMask);
   
   DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));
   
     leaveShape = GetLeaveShapes(branchCoord + vec4(0.1,0.,0.,0.), segmentLength, treeShouldExist, seed -24.173, randLeaveSpace);
   leaveOutlineThickness = sin(branchCoord.x*20.+randLeaveSpace);
  
  leaveColor = mix(tree_leaves, tree_leaves2,randLeaveSpace);
 leaveColor = mix(leaveColor, paper_color ,  noiseMask);
  
  
  DrawWithOutline(col, leaveColor, leaves_outline, -0.03, leaveShape, 0.05 + abs(leaveOutlineThickness*0.06));

 
}

// Function 1720
Model drawSkull(vec3 p, float t) {
    float scale = 2.5 * skullRadius;
    p /= scale;
    globalScale *= scale;
    Model model = sdSkull((p.xyz * vec3(1,-1,-1)));
    model.d *= scale;
    globalScale /= scale;
    return model;
}

// Function 1721
float drawPattern(in vec3 p, in vec3 obj){
    float a = 4.*atan(p.z-obj.z,p.x-obj.x);
    vec2 i = floor(vec2(a,p.y));  
    vec2 f = fract(vec2(a,p.y));  
	float tile = pattern(f, rand2(i, u_time*.04));
    return 1.5*(smoothstep(-.1,.0,-abs(tile-.05)));
}

// Function 1722
vec4 drawArrow(bool up, bool highlight, ivec2 position, ivec2 offset)
{
    if ((any(lessThan(position, offset))) || (any(greaterThanEqual(position, offset + arrowSize))))
    {
        return vec4(0.0);
    }
    
    int index = ((up) ? (position.y - offset.y) : (13 - position.y + offset.y)) * 12 + (position.x - offset.x);
    
    A(2) A(9) A(14) A(21) A(26) A(33) A(38) A(45) A(50) A(57)
    A(62) A(69) A(74) A(81) A(86) A(93) A(96) A(97) A(98) A(105)
    A(106) A(107) A(109) A(118) A(122) A(129) A(135) A(140) A(148) A(151)
    A(161) A(162)
        
    return vec4(0.0);
}

// Function 1723
float dLine(vec2 p, vec2 p1, vec2 p2) { return dLine(vec3(p,0),vec3(p1,0),vec3(p2,0)); }

// Function 1724
float circleS(vec2 uv){
	return abs(length(uv)-size.x*.5);   
}

// Function 1725
float drawInt(int value, int minDigits)
{
  float c = 0.;
  if (value < 0) 
  { value = -value;
    if (minDigits < 1) minDigits = 1;
    else minDigits--;
    _sub                   // add minus char
  } 
  int fn = value, digits = 1; // get number of digits 
  for (int ni=0; ni<10; ni++)
  {
    fn /= 10;
    if (fn == 0) break;
    digits++;
  } 
  digits = maxInt(minDigits, digits);   // WebGL
//digits = max(minDigits, digits);      // WebGL2
  tp.x -= FONT_SPACE * float(digits);
  for (int ni=1; ni < 11; ni++) 
  { 
    tp.x += FONT_SPACE; // space
    c += char(48 + value%10);
    value /= 10; // add 0..9 
    if (ni >= digits) break;
  } 
  tp.x -= FONT_SPACE * float(digits);
  return c;
}

// Function 1726
float linedist(vec2 p, vec2 a, vec2 b) {
  float k = dot(p-a,b-a)/dot(b-a,b-a);
  return length(p-mix(a,b,clamp(k,0.,1.)));
}

// Function 1727
vec3 clipZcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {
    vec3 initialResult = zcamJchToLinearSrgb(jch, cond);
    if (linearSrgbInGamut(initialResult)) {
        return initialResult;
    }

    float lightness = jch.r;
    float chroma = jch.g;
    float hue = jch.b;
    if (lightness <= ZCAM_CHROMA_EPSILON) {
        return vec3(0.0);
    } else if (lightness >= 100.0 - ZCAM_CHROMA_EPSILON) {
        return vec3(1.0);
    }

    float lo = 0.0;
    float hi = chroma;

    vec3 newLinearSrgb = initialResult;
    while (abs(hi - lo) > ZCAM_CHROMA_EPSILON) {
        float mid = (lo + hi) / 2.0;

        newLinearSrgb = zcamJchToLinearSrgb(vec3(lightness, mid, hue), cond);
        if (!linearSrgbInGamut(newLinearSrgb)) {
            hi = mid;
        } else {
            float mid2 = mid + ZCAM_CHROMA_EPSILON;

            vec3 newLinearSrgb2 = zcamJchToLinearSrgb(vec3(lightness, mid2, hue), cond);
            if (linearSrgbInGamut(newLinearSrgb2)) {
                lo = mid;
            } else {
                break;
            }
        }
    }

    return newLinearSrgb;
}

// Function 1728
float rect_sdf(in vec3 pt, in vec2 size, in float radius) {
    vec2 xy = abs(pt.xy) - size;
    xy = xy + curve_rad;
    xy = max(vec2(0.0), xy);
    float xy_dist = abs(length(xy) - curve_rad);
    return length(vec2(pt.z, xy_dist)) - radius;
}

// Function 1729
float sdf_line2(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!
    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B
    // The vector-projection of vector X to vector Y is a scalar multiple of vector Y.
    vec2 vector_projection_AP_AB = dvec_AB * (dot(dvec_AP, dvec_AB) / dot(dvec_AB, dvec_AB));
    vec2 dvec_uv_vproj_AP_AB = uv - vector_projection_AP_AB;
    return sign(dvec_uv_vproj_AP_AB.x * dvec_AB.y) * length(dvec_uv_vproj_AP_AB);  // This is the (signed) distance!
}

// Function 1730
vec3 random_hemisphere_direction(vec3 dir,vec2 random_value)
{
	vec3 v = random_sphere_direction(random_value);
	return v * sign(dot(v, dir));
}

// Function 1731
vec4 circle(vec2 uv, vec2 pos){
    // draw a circle at mouse coordinates
    float s = 4.0+4.0*pow(noise(vec2(iTime*2.8)),2.0);
    uv += pos+vec2(1.0/s);
    float val = clamp(1.0-length(s*uv-1.0), 0.0, 1.0);
    val = pow(5.0*val, 5.0);
	return vec4(clamp(val, 0.0, 1.0));
}

// Function 1732
vec3 DrawFields(in vec2 p)
{
	float onViewPink = 1.-texture( iChannel0, vec2(KEY_VIEW_1,0.75) ).x;
	float onViewVanilla = texture( iChannel0, vec2(KEY_VIEW_VANILLA,0.25) ).x;

	vec3 col = vec3(0.);
	vec3 data = vec3(0.);
	if (onViewVanilla > 0.5)
	{
		col = vec3(0.1);
		data.x = calcualtePfAtPoint(p);
		const int NUM_CURVE_LINES = 20;
		const float CURVE_WIDTH = 0.005;		
		for (int i = 0; i < NUM_CURVE_LINES; ++i)
		{
			float lc = float(i)/float(NUM_CURVE_LINES);
			float d = abs(sign(data.x)*data.x-lc);
			float t = smoothstep(0.,CURVE_WIDTH,d);
			float c1 = step(0.0001,data.x);
			
			vec3 colLine = c1* vec3((1.-t),0., t*(1.-t));
			colLine += (1.-c1)* vec3((1.-t),(1.-t),0.);
			
			col = mix(colLine, col, t);
		}
	}
	else if (onViewPink > 0.5)
	{
		// Default: Pink Psycodelia
		float pf = calcualtePfAtPoint(p);
		data.x = 10.0*pf;
		col = vec3(smoothstep(-10.,10.,pow(data.x,-0.4) ),0.,0.8);
		if (data.x < -0.8) col.x = col.x*0.9;
		col += clamp(gSound.f*drawTiledBackground(p), 0.,0.02);		
		col -= clamp(gSound.freqs[2]*drawTiledBackground(p+0.1*vec2(sin(iTime))), 0.,0.04);
	}
	else
	{
		// Blue Psycodelia
		data.x = calcualtePfAtPoint(p);
		
#if USE_BRANCHING_FOR_FIELD_EFFECTS	
		// with branching... runs faster in my machine
		if (data.x > 0.2) 
			col = vec3(smoothstep(0.,10.,pow(data.x,-0.4)),0.,0.8);
		else if (data.x < -0.1)
			col = vec3(0.,smoothstep(-10.,0.,1./data.x),0.8);
		else
			col = vec3(0.,smoothstep(-0.2,0.2,data.x),0.8);
	
#else			
		// without branching ... should this tun faster???
		float c1 = step(0.2, data.x);
		float c2 = 1.-step(-0.1, data.x);
			
		col = (c1)*vec3(smoothstep(0.,10.,pow(data.x,-0.4)),0.,0.8);
		col += (1.-c1)*c2*vec3(0.,smoothstep(-10.,0.,1./data.x),0.8);
		col += (1.-c1)*(1.-c2)*vec3(0.,smoothstep(-0.2,0.2,data.x),0.8);
#endif		
		
		col -= clamp(gSound.freqs[2]*drawTiledBackground(p+0.1*vec2(cos(iTime),sin(iTime))), 0.,0.05);
	}
	
	// draw samples of gradient at uniform distances
	const float invNumPoints = 1.0/float(NUM_GRAD_POINTS_PER_ROW);
	float deltaX = AR*invNumPoints;
	for (int i = 0; i < NUM_GRAD_POINTS_PER_ROW; ++i)
	{
		float i_float = float(i);
		for (int j = 0; j < NUM_GRAD_POINTS_PER_ROW; ++j)
		{
			vec2 point = vec2((i_float+0.5)*deltaX, (float(j)+0.5)*invNumPoints);
			vec3 colGradLine = drawGradLine(p, point);
			col = mix(col, colGradLine, dot(colGradLine,colGradLine));
		}
	}

	return col;
}

// Function 1733
vec3 RandomDirection(in float seed, in vec3 startingDirection)
{
    startingDirection = normalize(startingDirection);
    
    vec3 direction = normalize(vec3(Hash(78.233 + seed), Hash(10.873 + seed), Hash(27.873 + seed)));
    direction = (dot(direction, startingDirection) < 0.0) ? -direction : direction;
    return direction;
}

// Function 1734
float drawDig( vec2 pos, vec2 pixel_coords, float bitfield )
{
	// offset relative to 
	vec2 ic = pixel_coords - pos ;
	ic = floor(ic*iResolution.xy);
	// test if overlap letter
	if( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )
	{
		// compute 1d bitindex from 2d pos
		float bitIndex = ic.y*3.+ic.x;
		// isolate the bit
		return floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );
	}
	return 0.;
}

// Function 1735
void draw_blur(in Ray ray, float radius, inout TraceResult cur_ctxt)
{
    float accum = 10.0;
    /*vec4 color;
    vec3 normal1;
    float t1 = traceSphere(ray.pos, ray.dir, radius/1.0, normal1);
    vec3 normal2;
    float t2 = traceSphere(ray.pos, ray.dir, radius/2.0, normal2);
    vec3 normal3;
    float t3 = traceSphere(ray.pos, ray.dir, radius/3.0, normal3);
    vec3 normal4;
    float t4 = traceSphere(ray.pos, ray.dir, radius/4.0, normal4);
    vec3 normal5;
    float t5 = traceSphere(ray.pos, ray.dir, radius + 0.04, normal5);
    
    bool b5 = (t5 != INF);
    bool b4 = (t4 != INF);
    bool b3 = (t3 != INF);
    bool b2 = (t2 != INF);
    bool b1 = (t1 != INF);
    
    accum = to_float(b5);*/
    float d = get_dist_ray_point(ray, vec3(0, 0, 0));
    
    vec3 normal5;
    float t5 = traceSphere(ray.pos, ray.dir, radius, normal5);
    
    if (t5 != INF)
    {           
        
        cur_ctxt.color = make_another_blur(cur_ctxt.fragCoord,
                                    max(26.0*d,0.0)).rgb;
        //cur_ctxt.color = vec3(1, 1, 1);
        cur_ctxt.materialType = EMISSION;
        cur_ctxt.alpha = min(1.0 - d/(radius) + 0.1, 0.7);
    }
    vec3 normal6;
    float t6 = traceSphere(ray.pos, ray.dir, radius + 0.04, normal6);
    if (t5 == INF && t6 != INF)
    {
        float dif = d - radius - 0.04;
        
        cur_ctxt.color = make_another_blur(cur_ctxt.fragCoord,
                                    max(16.0 * (1.0 - 25.0*dif),0.0)).rgb;
        
        cur_ctxt.materialType = EMISSION;
        //cur_ctxt.alpha = min(-(0.6/0.04) * dif , 0.7);
    }
    
    //cur_ctxt.alpha = GLOBAL_ALPHA;
    //cur_ctxt.materialType = EMISSION;
     /*//vec3 curPos = ray.pos + t * ray.dir;
*/
}

// Function 1736
vec3 DrawWeakCircle(vec2 uv){
	float val = clamp((1.0-length(uv)*2.),0.,1.);
	val = pow(val,2.0);
	return vec3(val,val,val);
}

// Function 1737
void DrawGround (in vec2 uv, in vec2 cameraOffset, inout vec3 pixelColor, vec4 backWheel, vec4 frontWheel, vec4 state, vec4 state2, vec4 state3)
{
    // draw background layers
    DrawHills (uv + vec2(1000.0, -0.3) + cameraOffset *-0.9 , pixelColor, vec3(0.25), 0.7 );
    DrawClouds(uv + vec2(1000.0, -0.3) + iTime * vec2(0.05,0.0) + cameraOffset *-0.85, pixelColor, vec3(0.3) , 0.75, 0.75);
    DrawHills (uv + vec2(300.0 , -0.1) + cameraOffset  *-0.8 , pixelColor, vec3(0.5) , 0.8 );
    DrawClouds(uv + vec2(300.0 , -0.1) + iTime * vec2(0.15,0.0) + cameraOffset  *-0.7 , pixelColor, vec3(0.6) , 0.75, 0.75);
    
    // draw the car before the ridable layer so that trees and grass appear in front
    DrawCar(uv, pixelColor, backWheel, frontWheel, state, state2);

    // draw the ridable layer
 	DrawHills(uv, pixelColor, vec3(1.0), 1.0);
    
    // draw the periodic fuel orbs
    if (uv.x > VAR_LASTFUELORB)
    {
    	float uvFuelX = mod(uv.x, c_fuelCanDistance) - c_fuelCanDistance * 0.5;
    	float uvFuelY = GroundHeightAtX(floor(uv.x / c_fuelCanDistance) * c_fuelCanDistance + c_fuelCanDistance * 0.5, 1.0);
    	uvFuelY += c_fuelCanRadius*1.1;
		float fuelDist = UDCircle(uv, vec2(uvFuelX+uv.x, uvFuelY), c_fuelCanRadius*0.5);          
		fuelDist = 1.0 - smoothstep(0.0, AA_AMOUNT*10.0, fuelDist);
    	pixelColor = mix(pixelColor, vec3(1.0, 0.0, 0.0), fuelDist);
    }
    
    // draw some small foreground clouds
    DrawClouds(uv + vec2(700.0 , -1.25) + iTime * vec2(0.25,0.0) + cameraOffset * 0.5 , pixelColor, vec3(1.0) , 1.0, 0.5);
}

// Function 1738
float distCircleTaxi(vec2 p, float R, float r) { return abs(abs(p.x) + abs(p.y) - R) - r; }

// Function 1739
void draw_rect(uint c, uint level) {
    vec3 rc = get_rect(c, level);
    //rc.z -= 0.002;// * float(level);
    rectangle(rc.xy - rc.z, vec2(rc.z) * 2.0);
}

// Function 1740
vec3 DrawPointLight(vec3 ro, vec3 rd, float d, vec3 lp, float len, vec3 lc)
{
	vec3 res = vec3(0);
	if (d>=len)
	{
		vec3 k = rd - normalize(lp-ro);
		res += lc * (len / 1000.) /dot(k, k);
	}
	return res;
}

// Function 1741
vec3 GetRayDirection(float fov, vec2 res, vec2 fragCoord) {
    vec2 xy = fragCoord - res/2.;
    float z = res.y / tan(radians(fov/2.));
    return normalize(vec3(xy, -z));
}

// Function 1742
float linear(float edge0, float edge1, float x)
{
  return clamp((x - edge0)/(edge1 - edge0), 0., 1.);
}

// Function 1743
void drawButtons()
{
  vec2 buttonSize = vec2 (0.15, 1.4 / maxSelection);
  for (float n=0.0; n < maxButtons; n++)
  {
    if (rectangle(pPos(n), buttonSize) > 0.5) color = gray;
  }
  if (rectangle(pPos(selection), buttonSize) > 0.0) color = yellow;
}

// Function 1744
float SLog3_to_linear( float SLog )
{
float Out = 0.0;
if (SLog >= 171.2102946929 / 1023.0){
Out = pow(10.0, (SLog * 1023.0 - 420.0) / 261.5) * (0.18 + 0.01) - 0.01;
} else {
Out = (SLog * 1023.0 - 95.0) * 0.01125000 / (171.2102946929 - 95.0);}
return Out;
}

// Function 1745
void drawFunctionInfo(inout vec3 color, const in int num)  
{
  SetTextPosition(1.0, 1.0);
    
  c = drawInt(functionGroup+1);  SPACE
      
  if (functionGroup == 0) { _c _o _m _m _o _n _ddot _ _
      addText(colorF);   _a _b _s _ 
      addText(color1);   _s _i _g _n _ 
      addText(color2);   _f _r _a _c _t _ 
      addText(color3);   _r _o _u _n _d _
      addText(color4);   _f _l _o _o _r _
      addText(color5);   _c _e _i _l _
      addText(color6);   _m _o _d _
      addText(color7);
    }
  else if (functionGroup == 1) { _l _i _m _i _t _a _t _i _o _n _ddot _ _
      addText(colorF);   _m _i _n _ 
      addText(color1);   _m _a _x _ 
      addText(color2);   _c _l _a _m _p _ 
      addText(color3);   _ _ _ _ _3 _ _star _ _s _m _o _o _t _h _s _t _e _p _
      addText(color4);   
    }
  else if (functionGroup == 2) { _t _r _i _g _o _n _o _m _e _t _r _i _c  _ddot _ _  
      addText(colorF);   _c _o _s _ 
      addText(color1);   _s _i _n _ 
      addText(color2);   _t _a _n _ 
      addText(color3);   _a _s _i _n _
      addText(color4);   _a _c _o _s _
      addText(color5);   _a _t _a _n _
      addText(color6);
    }
  else if (functionGroup == 3) { _h _y _p _e _r _b _o _l _i _c _ddot _ _
      addText(colorF);   _s _i _n _h _ 
      addText(color1);   _c _o _s _h _ 
      addText(color2);   _t _a _n _h _ 
      addText(color3);   _a _s _i _n _h _
      addText(color4);   _a _c _o _s _h _
      addText(color5);   _a _t _a _n _h _
      addText(color6);
    }
  else if (functionGroup == 4) { _c _o _l _o _r _s _ddot
      addText(colorF);   _1 _ 
      addText(color1);   _2 _ 
      addText(color2);   _3 _ 
      addText(color3);   _4 _
      addText(color4);   _5 _
      addText(color5);   _6 _
      addText(color6);   _7 _
      addText(color7);
  }
}

// Function 1746
void DrawTaiga(out vec4 c){
	c = vec4(0.0, 0.4, 0.3, 1.0);
}

// Function 1747
void drawFuncWithInverse(float y, float x, float r, vec4 col)
{
    vec2 d = abs(vec2(xy.x - x, xy.y - y));
    mixColor(col, lerpstep(r + aa, r - aa, max(d.x, d.y) / length(d) * min(d.x, d.y)));
}

// Function 1748
vec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){
    
    float det = d2.x*d1.y - d1.x*d2.y;
    if(det == 0.0){
        return vec2(0.0);
    }
    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;
    float l1 = det1 / det;
    return P1 + l1*d1;
}

// Function 1749
float df_line(vec2 uv, vec2 vec_a, vec2 vec_b, float thickness){
    vec2 vec_ap = uv    - vec_a;
    vec2 vec_ab = vec_b - vec_a;
    return distance(vec_ap, vproj(vec_ap, vec_ab)) - thickness;
}

// Function 1750
float Circle(vec2 pix, vec3 C){
    float r = length(C.xy - pix);
    float d = abs(r - C.z);  
    return smoothstep(0.03, 0.015, d) + 0.5*smoothstep(0.1, 0.0, r - C.z);
}

// Function 1751
float Line(vec2 a, vec2 b, vec2 uv)
{
        return Sharpen(DistToLine(uv.xy, a, b), LineWidth, 1.0);
}

// Function 1752
vec3 toLinear(vec3 color, transfer trc)
{
	bvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));
	bvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));
	vec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));
	vec3 lower = color/trc.slope;
	vec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));

	color = mix(higher, lower, cutoff);
	color = mix(color, neg, negCutoff);

	return color;
}

// Function 1753
vec3 drawCaveBackground(float gFlashAlpha)
{
    return (gFlashAlpha > 0.0) ? FLASH_COLOR : vec3(0.0);
}

// Function 1754
float FindClosestPointOnSplineToPoint( vec3 p )
{
	return FindClosestPointOnSplineToPoint( spline, p);
}

// Function 1755
float CharRect(vec2 p, vec2 b)
{
	vec2 d = abs(p) - b;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 1756
float distLineSeg(vec2 a, vec2 b, vec2 pos)
{
    float proj = dot(pos - a, b - a) / dot(b - a, b - a);
    vec2 posNearest = mix(a, b, clamp(proj, 0.0, 1.0));
    return length(pos - posNearest);
}

// Function 1757
void drawRect(ivec2 c, ivec2 cCurr, int o, inout int v, int width, int height, int oFill)
{
    for (int i=0; i<width; i++)
    {
        for (int j=0; j<height; j++)
        {
            ivec2 c2 = ivec2(c.x + i, c.y + j);
            if ((i == 0) || (j == 0) || (i == (width - 1)) || (j == (height - 1)))
            {
                storeObject(c2, cCurr, o, v);
            }
            else if (oFill >= 0)
            {
                storeObject(c2, cCurr, oFill, v);
            }
        }
    }
}

// Function 1758
vec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )
{
    vec3 pa = pos - a;
    vec3 ba = b - a;
   
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    
    return vec2( length(pa-h*ba), h );
}

// Function 1759
maybe_vec2 get_distances_along_3d_line_to_ring(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float ro,
    in float ri
){
    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);
    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);
    maybe_vec2 ring  = get_distances_along_line_to_negation(outer, inner);
    return ring;
}

// Function 1760
vec3 drawQuad(vec3 col, vec2 coord, vec2 p1, vec2 p2, vec2 p3, vec2 p4, float thickness, vec3 oldColor)
{
    float sideA = sign(cross2D(coord - p1, p2 - p1));
    float sideB = sign(cross2D(coord - p2, p3 - p2));
    float sideC = sign(cross2D(coord - p3, p4 - p3));
    float sideD = sign(cross2D(coord - p4, p1 - p4));
    float dst = abs(sideA - sideB) + abs(sideB - sideC) + abs(sideC - sideD) + abs(sideD - sideA);
    dst = clamp(dst, 0.0, 1.0);

    vec3 res = mix(col, oldColor, dst);
    res = drawLine(col, coord, p1, p2, thickness, res);
    res = drawLine(col, coord, p2, p3, thickness, res);
    res = drawLine(col, coord, p3, p4, thickness, res);
    res = drawLine(col, coord, p4, p1, thickness, res);
    return res;
}

// Function 1761
float DrawCircle( vec2 vPos, vec2 vOrigin, float fRadius, float fThickness )
{    
    float fCircleDist = length( vOrigin - vPos ) - fRadius;
    float fCircle = clamp( 1.0 - abs(fCircleDist) / fThickness, 0.0, 1.0 );    
    return fCircle;
}

// Function 1762
float df_line(in vec2 p, in vec2 a, in vec2 b)
{
    vec2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);	
	return length(pa - ba * h);
}

// Function 1763
bool whiteRectangle2(vec2 i){bvec2 a=lt(-i),b=lt(i);//symmetry--:
// return (a.x&&a.y)&&(b.x&&b.y);}

// Function 1764
vec3 linearBurn(in vec3 src, in vec3 dst)
{
    return clamp(src.xyz + dst.xyz - 1.0, 0.0, 1.0);
}

// Function 1765
float distCircleNn(vec3 p, vec3 n, float r)
{
    return length(p-normalize(p-n*dot(n,p))*r);
}

// Function 1766
vec4 drawCellBoulder(ivec4 state, mat4x3 colors, ivec2 coord)
{
    Sprite sprite = getSpriteBoulder();
    return sampleSprite(sprite, colors, coord);
}

// Function 1767
float df_line(vec2 uv, vec2 vec_a, vec2 vec_b){
    vec2 dvec_ap =    uv - vec_a;  // Displacement vector from vec_a to current pixel
    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b
    vec2 vproj_ap_ab = dvec_ab * vector_projection_scalar(dvec_ap, dvec_ab);  // Standard linear algebra vector projection!
    float line = distance(dvec_ap, vproj_ap_ab) - LINE_THICKNESS;
    return smoothstep(0., 5. / iResolution.y, line);
}

// Function 1768
bool ML_OnRect(vec2 coord, vec4 rect, out vec2 ret){
    if(ML_InRect(coord, rect, 1.)){
        ret = ML_GetRect(coord, rect);
        return 1 == 1;
    }
    return 0 != 0;
}

// Function 1769
vec4 draw_number_6( int n, ivec2 pos, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(0), ivec2(8*8,8) ) ) {
        int k, i, d ;
        if( n < 0 ) {
            n = - n ;
            v += draw_character( _DASH, pos, iu ) ;
            pos.x += 8 ;
            k = 100000 ;
        } else {
            k = 1000000 ;
        }
        do {
            n %= k ;
            k /= 10 ;
            d = n / k ;
        } while( d == 0 && k > 1 ) ;

        if( n == 0 ) {
            v += draw_character( _0, pos, iu ) ;
        } else {
            v += draw_character( d + 1, pos, iu ) ;
            pos.x += 8 ;
        }
        while( k > 1 ) {
            n %= k ;
            k /= 10 ;
            v += draw_character( n / k + 1, pos, iu ) ;
            pos.x += 8 ;
        }
    }
    return( v );
}

// Function 1770
vec4
drawVoxelTypeIcon (in vec2 pos, in float invScale, in uint type)
{
    vec4 color;
	if ( (VOXEL_TYPE_MONOCHROME & type) != 0U )
    {
        if (type == VOXEL_TYPE_STONE)
        {
        	color = vec4(VOXEL_TYPE_STONE_COLOR, 1);
        }
        else if (type == VOXEL_TYPE_REDSTONE_DUST)
        {
            float t = min(abs(pos.x), abs(pos.y)) - REDSTONE_DUST_WIDTH * .5;
        	color.rgb = getEnergyColor(0U);
            color.a = smoothstep(3., 0., t * invScale);
        }
    }
    else if ( (VOXEL_TYPE_POLYCHROME & type) != 0U )
    {
        if (type == VOXEL_TYPE_REDSTONE_TORCH)
        {
        	color.rgb = getEnergyColor(MAX_REDSTONE_POWER);
            float t = length(pos) - REDSTONE_TORCH_RADIUS;
            color.a = smoothstep(3., 0., t * invScale);
        }
    }
    
    return color;
}

// Function 1771
float rect(vec2 o, vec2 b) {
	vec2 d = abs(o) - b;
 	return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1772
void drawBushGroup(vec2 bottomCorner, vec2 co)
{
	drawTile(0, bottomCorner, co);
	bottomCorner.x += 13.0;
	
	drawTile(1, bottomCorner, co);
	bottomCorner.x += 13.0;
	
	drawTile(0, bottomCorner, co);	
}

// Function 1773
float Log3G10_to_linear_2016 ( float log3g10)
{
float a, b, c, mirror, linear;
a = 0.224282;
b = 155.975327;
c = 0.01;
mirror = 1.0;
if (log3g10 < 0.0){
mirror = -1.0;
log3g10 = -log3g10;}
linear = (pow(10.0, log3g10 / a) - 1.0) / b;
linear = linear * mirror - c;
return linear;
}

// Function 1774
vec2 circle2square( vec2 v )
{
    #if IMPROVED==0
    return v*length(v)/maxcomp(abs(v));
    #else
    return vec2(0.0);
    #endif
}

// Function 1775
float rectangleCollide(vec2 p1, vec2 p2, vec2 s) {
	return float(all(lessThan(abs(p1 - p2), s)));   
}

// Function 1776
vec3 drawTangentLine(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t, vec3 col){
    vec2 g1,g2,beforeT, afterT;
    float EPS = 0.001;
    
    float t0 = max(t-EPS,0.);
    float t1 = min(t+EPS,1.);
    
    
    g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);
    g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);


    //get the direction so I can extend the line
    vec2 dir = normalize(g2-g1);
    
    //extend the line in both directions past the end of screen
    g1 += dir*10.;
    g2 += dir*(-10.);
    
    //draw that line
    col = drawLine(g1,g2,p,col,segCol*vec3(t, .7, .9),lineThickness);
    return col;
}

// Function 1777
float circle(vec2 p, float r) {
  return length(p) - r;
}

// Function 1778
v2 colorBrushStrokeLine(v1 uv, v2 inpColor, v3 brushColor, v1 p1_, v1 p2_, v0 lineWidth
){v0 lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y)//axis-align
 ;mat2 rotMat = rot2D(lineAngle)
 ;v0 lineLength = distance(p2_, p1_)    // make an axis-aligned line from this line.
 ;v1 tl = (p1_ * rotMat)// top left
 ;v1 br = tl + v1(0,lineLength)// bottom right
 ;v1 uvLine = uv * rotMat
 ;uvLine.x+=(noise01(uvLine*1.)-.5)*.02
 ;uvLine.x+=cos(uvLine.y*3.)*.009// smooth lp wave
 ;uvLine.x+=(noise01(uvLine*5.)-.5)*.005;// a sort of random waviness like individual strands are moving around
 ;uvLine.x+=(noise01(uvLine*min(iResolution.y,iResolution.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific
 ;v0 d = sdAxisAlignedRect(uvLine, tl, br)-lineWidth/2.
 ;uvLine=tl-uvLine
 ;v1 lineSize = v1(lineWidth, lineLength)
 ;v2 ret = colorBrushStroke(v1(uvLine.x, -uvLine.y), uv, lineSize,d, inpColor, brushColor)
 ;return ret;}

// Function 1779
void drawStars(inout vec4 fragColor, in vec4 color, in vec2 uv, in float grid, in float size, in vec2 speed, in float seed)
{
    uv += iTime * speed;
    
    // Split UV into local grid
    vec2 local = mod(uv,grid)/grid;
    
    // Random vector for each grid cell
    vec2 randv = randVector(floor(uv/grid), seed)-0.5;
    float len = length(randv);
    
    // If center + random vector lies inside cell
    // Draw circle
    if (len < 0.5) {
        // Draw circle on local grid
        float radius = 1.0-distance(local, vec2(0.5,0.5)+randv)/(size*(0.5-len));
        if (radius > 0.0) fragColor += color*radius;
    }
}

// Function 1780
void drawBushes(vec2 co)
{
	drawHorzRect(co.y, 39.0, 70.0, RGB(100, 224, 117));
	
	for (int i = 0; i < 20; i++) {
		float xOffset = float(i) * 45.0;
		drawBushGroup(vec2(xOffset, 70.0), co);
		drawBushGroup(vec2(xOffset+7.0, 68.0), co);
		drawBushGroup(vec2(xOffset-16.0, 65.0), co);
	}
}

// Function 1781
v2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w
){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align
 ;mat2 rotMat =rot2D(lineAngle)
 ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.
 ;v1 T=m.xy*rotMat// top left
 ;v1 B=T+v1(0,W)// bottom right
 ;v1 l=u*rotMat
 ;l.x+=(noise01(l*1.)-.5)*.02
 ;l.x+=cos(l.y*3.)*.009//lp wave
 ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around
 ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific
 ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.
 ;return colorBrushStroke((T-l)*vec2(1,-1),r,M,u,W,d,c,b);}

// Function 1782
float LineInfo( vec2 vUV, vec2 vA, vec2 vB, out vec2 vClosest )
{
    vec2 vDir = vB - vA;

    float fLen = length(vDir);

    float fDist = 10000.0;
    float fSide = -1.0;
    
    float fEpsilon = 0.002f;
    
    if ( fLen < fEpsilon )
    {
        vClosest = vA;
    }
    else
    {
        vDir /= fLen;            
        vec2 vOffset = vUV - vA.xy;            

        float cp = vDir.x * vOffset.y - vDir.y * vOffset.x;
        if ( cp > 0.0f )
        {
            fSide = 1.0;
        }

        float d = dot( vDir, vOffset );
        d = clamp( d, 0.0, fLen );
        vClosest = vA + vDir * d;
    }  
    fDist = length( vClosest - vUV );
    
    return fDist * fSide;
}

// Function 1783
float distance_to_line(vec2 p, vec2 p1, vec2 p2) {
    float d;
    float l_sq = pow(distance(p1, p2), 2.0);
    if (l_sq == 0.0)
        d = distance(p, p1);
    else {
        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));
        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment
        d = distance(p, projection);
    }
    return d;
}

// Function 1784
vec2 gcircle(vec2 sp, float ib, float d)
{
    float cosd = cos(d);
    float sind = sin(d);
    float sinTheta1 = -sp.y;
    float cosTheta1 = sqrt(1.0 - sp.y * sp.y);
    float sinTheta2 = sinTheta1 * cosd + cosTheta1 * sind * cos(ib);
    float theta2 = asin(sinTheta2);
    float phi2 = sp.x + atan(sin(ib) * sind * cosTheta1, cosd - sinTheta1 * sinTheta2);
    return vec2(mod(phi2, twoPi), cos(theta2 + halfPi));
}

// Function 1785
vec4 drawSliderText(in vec2 uv, float mode, in int submenu, int _mainTex)
{
    vec4 tcol = vec4(0.);
    if (in_zone(mode, APPL_UI))
    {
        float lsize = 0.02;
        float y_offset = lsize*2.;
        float x_offset = 0.5*(SELECTION_RADIUS_MAX.x + SELECTION_RADIUS_MIN.x) - lsize*0.5 - SELECTION_RADIUS_MIN.x;
        
        //vec2 sstart = vec2(SELECTION_SHAPE_MIN.x + 4.*x_offset, SELECTION_SHAPE_MIN.y - y_offset);
        //vec2 ovstart = vec2(SELECTION_OVERRIDE_MIN.x + 4.*x_offset, SELECTION_SHAPE_MIN.y - y_offset);
    
        if (submenu == MENU_OPT_TOOLS)
        {
            vec2 rstart = vec2(SELECTION_RADIUS_MIN.x + x_offset, SELECTION_RADIUS_MAX.y - y_offset);
            vec2 brushstart = vec2(SELECTION_BRUSH_MIN.x + x_offset, SELECTION_BRUSH_MAX.y - y_offset);
            vec2 blendstart = vec2(SELECTION_BLEND_FACTOR_MIN.x + x_offset, SELECTION_BLEND_FACTOR_MAX.y - y_offset);
            tcol += drawTextVertical(uv, rstart, lsize, vec2[10](_R, _a, _d, _i, _u, _s, _X, _X, _X, _X), 6);
            tcol += drawTextVertical(uv, blendstart, lsize, vec2[10](_B, _l, _e, _n, _d, _ , _F, _a, _c, _t), 5);
            tcol += drawTextVertical(uv, brushstart, lsize, vec2[10](_B, _r, _u, _s, _h, _X, _X, _X, _X, _X), 5);
        }
        else if (submenu == MENU_OPT_COLOR)
        {
            
            vec2 castart = vec2(SELECTION_COLOR_A_MIN.x + x_offset, SELECTION_COLOR_A_MIN.y + y_offset);
            vec2 cbstart = vec2(SELECTION_COLOR_B_MIN.x + x_offset, SELECTION_COLOR_B_MIN.y + y_offset);
            vec2 ccstart = vec2(SELECTION_COLOR_C_MIN.x + x_offset, SELECTION_COLOR_C_MIN.y + y_offset);
            vec2 heightstart = vec2(SELECTION_COLOR_A_MIN.x + x_offset, SELECTION_COLOR_A_MAX.y - y_offset);
            vec2 specstart = vec2(SELECTION_COLOR_A_MIN.x + 0.002, SELECTION_COLOR_A_MAX.y - .6*y_offset);
            //vec2 shinestart = vec2(SELECTION_COLOR_B_MIN.x + 0.0022, SELECTION_COLOR_B_MAX.y - .5*y_offset);
            
            if (_mainTex == DIFFUSE_MAP)
            {
                tcol += drawLetter(uv, castart, lsize, _R);
            	tcol += drawLetter(uv, cbstart, lsize, _G);
            	tcol += drawLetter(uv, ccstart, lsize, _B);
            }
            else if (_mainTex == HEIGHT_MAP)
            {
                tcol += drawTextVertical(uv, heightstart, lsize, vec2[10](_H, _e, _i, _g, _h, _t, _X, _X, _X, _X), 6);
            }
            else if (_mainTex == SPECULAR_MAP)
            {
                tcol += drawTextVertical(uv, specstart, lsize*.8, vec2[10](_S, _p, _e, _c, _u, _l, _a, _r, _X, _X), 8);
                //tcol += drawTextVertical(uv, shinestart, lsize*.76, vec2[10](_S, _h, _i, _n, _i, _n, _e, _s, _s, _X), 9);
            }
        }
        else if (submenu == MENU_OPT_TEXTURE)
        {
            vec2 mainTexStart = vec2(SELECTION_TEXTURE_MIN.x + x_offset, SELECTION_TEXTURE_MIN.y - y_offset);
			vec2 secTexStart = vec2(SELECTION_SECONDARY_TEXTURE_MIN.x + x_offset, SELECTION_SECONDARY_TEXTURE_MIN.y - y_offset);
            vec2 loadTexStart = vec2(SELECTION_LOAD_TEXTURE_MIN.x + x_offset, SELECTION_LOAD_TEXTURE_MIN.y + .5*y_offset);
            vec2 blendTexStart = vec2(SELECTION_TEXTURE_ALPHA_MIN.x + x_offset, SELECTION_TEXTURE_ALPHA_MAX.y - y_offset);
            
            tcol += drawTextVertical(uv, mainTexStart, lsize, vec2[10](_M, _a, _i, _n, _X, _X, _X, _X, _X, _X), 4);
            tcol += drawTextVertical(uv, secTexStart, lsize, vec2[10](_S, _e, _c, _o, _n, _d, _a, _r, _y, _X), 9);
            tcol += drawTextHorizontal(uv, loadTexStart, lsize, vec2[10](_L, _o, _a, _d, _X, _X, _X, _X, _X, _X), 4);
            tcol += drawTextVertical(uv, blendTexStart, lsize, vec2[10](_B, _l, _e, _n, _d, _ , _F, _a, _c, _t), 5);
        }
		else if (submenu == MENU_OPT_3D)
        {
            vec2 starsStart = vec2(SELECTION_STARS_MAX.x + x_offset, SELECTION_STARS_MIN.y);
            tcol += drawTextHorizontal(uv, starsStart, lsize, vec2[10](_S, _t, _a, _r, _s, _X, _X, _X, _X, _X), 5);
        }
        
    }
    if (in_zone(mode, APPL_TEXTURES))
    {
        float lsize = 0.02;
        float y_offset = lsize*2.;
        float x_offset = .001;
        vec2 hideUiStart = vec2(SELECTION_HIDE_UI_MIN.x + x_offset, SELECTION_HIDE_UI_MIN.y + .5*y_offset);
        
        tcol += drawTextHorizontal(uv, hideUiStart, lsize, vec2[10](_1, _0, _s, _, _h, _i, _d, _e, _X, _X), 8);
    }
    return tcol;
}

// Function 1786
vec2 directionalWaveNormal(vec2 p, float amp, vec2 dir, float freq, float speed, float time, float k)
{	
	float a = dot(p, dir) * freq + time * speed;
	float b = 0.5 * k * freq * amp * pow((sin(a) + 1.0) * 0.5, k) * cos(a);
	return vec2(dir.x * b, dir.y * b);
}

// Function 1787
void drawJet(ivec2 uv, ivec2 jetPos, int si, const in sampler2D d, inout vec3 f) {
    if (jetPos.y > 0) {
        drawSprite(uv, jetPos - ivec2(12,5), jetPos + ivec2(12,5), ivec2(24 * si, 63), d, jetPos.y < 8, f);
    }
}

// Function 1788
vec3 get_ray_direction(Camera cam, vec2 uv) {
  // Get the direction the camera is facing, based on what
  // it's supposed to be looking at
  vec3 cam_direction = normalize(-cam.position - cam.look_at);
  vec3 cam_side = cross(cam_direction, cam.up);
  // Get the normalized ray direction
  return normalize(
      vec3(cam_side * uv.x + cam.up * uv.y + cam_direction * cam.focus));
}

// Function 1789
vec2 DrawUVQuad(vec2 a, vec2 b, vec2 c, vec2 d,vec2 uva, vec2 uvb, vec2 uvc, vec2 uvd, float t, vec2 co){
    float i = DrawQuad(a,b,c,d,t,co);
    if (i<=0.) return vec2(0);
    vec3 baria = toBari(a,b,c,co);
    vec3 barib = toBari(a,d,c,co);
    vec3 baric = toBari(b,c,d,co);
    vec3 barid = toBari(b,a,d,co);
    vec2 coord = vec2(0);
    coord+= toCartesian(uvb,uvc,uvd,baric);
    coord+= toCartesian(uvb,uva,uvd,barid);
    coord+= toCartesian(uva,uvb,uvc,baria);
    coord+= toCartesian(uva,uvd,uvc,barib);
    
    return (coord/4.)*i;
}

// Function 1790
float lineDist(vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p-a;
    vec3 ba = b-a;
    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);
    return length(pa-ba*t);
}

// Function 1791
float circle(vec2 st, vec2 p, float r){
    float d = length(st-p)*r;
    return 1.0/dot(d,d);
    return smoothstep(r, r-2./R.y, length(st-p));//length(st-p)<r?1.0:0.0;
}

// Function 1792
float drawInt(v1 p,int v){return drawInt(p,v,1);}

// Function 1793
vec3 getDirection(vec3 ro, vec3 target, vec2 uv, float fov)
{
    vec3 ww = normalize(target - ro); //front
    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right
	vec3 vv = normalize(cross(uu,ww)); //up
    
    return normalize(uv.x * uu + uv.y*vv + fov*ww);
}

// Function 1794
vec3 rayDirection(float fieldOfView, vec2 size, vec2 uv) 
{
    vec2 xy = uv - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 1795
bool drawSpring( vec2 coords, vec2 p0, vec2 p1, float thickness, int loops )
{
    vec2 d = p1 - p0;
    if (length(d) < 0.001)
        return false;
    
    vec2 dir = normalize(d);
    vec2 per = vec2(dir.y, -dir.x);
    
    vec2 st = d / float(loops * 2);
    vec2 last = p0 + per * thickness / 2.0 + st / 2.0;
    vec2 sw = -thickness * per;
    float th = 1.0;
    
    bool draw = drawLine(coords, p0, last, th);
    
    for (int i=0; i<loops*2-1; i++)
    {
        vec2 next = last + st + sw;
        sw = -sw;
        draw = draw || drawLine(coords, last, next, th);
        last = next;
    }
    
    draw = draw || drawLine(coords, last, p1, th);
    return draw;
}

// Function 1796
float sdCircle( vec2 p, float r ) {
  return length(p) - r;
}

// Function 1797
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	vec2 r = hash2();
    //vec2 r = Halton();
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 1798
float dfCircle(vec2 origin, float radius, vec2 uv)
{
	origin *= scale;
	radius *= scale;
    
	return abs(length(uv - origin) - radius);
}

// Function 1799
void PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )
{
    // Apply CR
    state.vPos.x = state.vStart.x;
    
    // advance Y position to bottom of descender based on current font size.
    float fFontDescent = 0.15f;
	state.vPos.y -= style.vSize.y * fFontDescent;    
}

// Function 1800
float sDistLine(vec2 a, vec2 b) {
       
    b -= a; return dot(a, vec2(-b.y, b.x)/length(b)); //return dot(a, normalize(vec2(-b.y, b.x)));
}

// Function 1801
float get_default_draw_color(in sampler2D s)
{
    return texelFetch(s, CTRL_DEF_COLOR, 0).w;
}

// Function 1802
vec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float th){

    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));
    float dist = distToLine(A, B, p);
    dist = 1.0-smoothstep(0., fwidth(dist), dist - th);
    return mix(col, lineColor, dist);
}

// Function 1803
float distance_to_line_segment(vec2 p, vec2 a, vec2 b){
    vec2 ba = b - a;
    float u = clamp(dot(p - a, ba)/dot(ba, ba), 0.0, 1.0);
    vec2 q = a + u*ba;
    return distance(p, q);
}

// Function 1804
vec3 generateCosineDirection(vec3 normal)
{
    vec3 n = normalize(normal);
    vec2 r = rnd2();

    vec3 uu = normalize(cross(n, vec3(0.0, 1.0, 1.0)));
    vec3 vv = cross(uu, n);

    float ra = sqrt(r.y);
    float rx = ra * cos(6.2831 * r.x);
    float ry = ra * sin(6.2831 * r.x);
    float rz = sqrt(1.0 - r.y);
    vec3 rr = vec3(rx * uu + ry * vv + rz * n);

    return normalize(rr);
}

// Function 1805
vec3 DrawCandy3(vec2 p, vec3 bgColor)
{
    vec2 q = p-vec2(-0.15, +0.35);
    q = Rot(q, q.y*0.6);
    vec2 seg = dsSegment(q, vec2(0., 0.0), vec2(0.0, -0.65));
    float d = seg.x - 0.25 -seg.y*0.06;
    vec3 color = vec3(0.752, 0.047, 0.047)*0.8;
    
    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;
    color *= 1.+cubeTex.r*0.30;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.20, 0.35))*vec2(1.8, 1.2))), 0.1) ))*2.9;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.20, -0.3))*vec2(1.7, 1.2))), 0.11) ))*2.5;
    
    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.2, 0.))));
    
    return mix(color, bgColor, smoothstep(0., 2e-2, d));
}

// Function 1806
vec3 line(vec2 from, float dx, float dy, vec3 color, float th, float zoom, vec2 pos, vec3 mix_into) {
    return mix(color, mix_into, step(0.0, udSegment(pos, zoom, th, from, from + vec2(dx, dy))));
}

// Function 1807
float circle(vec2 st, float innerRadius, float width, float edge)
{
    float outerRadius = innerRadius + width;
    float ir2 = innerRadius * innerRadius;
    float or2 = outerRadius * outerRadius;
    float x = st.x - 0.5;
    float y = st.y - 0.5;
    return smoothstep(ir2 - edge, ir2, x * x + y * y) - smoothstep(or2, or2 + edge, x * x + y * y);
}

// Function 1808
void drawButton( inout vec4 c, vec2 p, vec4 t, float pressed){
    p-=t.xy;
    float area = .03 - sdBox(p,vec2(.020)+t.zw);
    float arean = smoothstep(0.,.01, area);

    c = mix(c, vec4(0.5,.5,0.5,1.), arean);
    c = mix(c, vec4(0.9,.9,0.9,1.), min(arean, (smoothstep(0.,.04, area))));
    c = mix(c, vec4(0.0,1.,0.8,1.), pressed*min(arean, (smoothstep(0.,.04, area))));
    c = mix(c, vec4(0.,0.,0.,1.), smoothstep(0.,.01, .01-abs(.03 - sdBox(p,vec2(.015)+t.zw))));
}

// Function 1809
float drawInt(inout vec2 p,int v,int m){float c=0.;if(v<0){v=-v; 
  if(m<1)m=1;else m--;_sub;}
 int f=v,d=1;for(int n=0;n<10;n++){f/=10;if(f==0)break;d++;}// get number of digits
 d=max(m,d);p.x-=float(d);
 for(int n=1;n<11;n++){p.x+=1.;c += char(p,48+(v-((v/=10)*10)));if(n>=d)break;} 
 p.x-=float(d);return c;}

// Function 1810
float draw(vec2 uv)
{
    return 1.0-abs(abs(saw(uv.x*(1.5+sin(iTime*.654321))*PI+iTime*.7654321)*2.0-1.0)-abs(uv.y));
}

// Function 1811
float sdLine(in vec2 p, in vec2 a, in vec2 b){

	p -= a, b -= a;
	return length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));
}

// Function 1812
vec4 drawCellFirefly(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    Sprite sprite = getSpriteFirefly(animFrame);
    return sampleSprite(sprite, colors, coord);
}

// Function 1813
void DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)
{
	vec2 vScreenCoord = vTexCoord - vPos;
	col *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);

	if((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))
	{
		col = vCol;
	}
}

// Function 1814
UIDrawContext UIDrawContext_TransformChild( UIDrawContext parentContext, UIDrawContext childContext )
{
    UIDrawContext result;
    
    // The child canvas size is unmodified
    result.vCanvasSize = childContext.vCanvasSize;

    // Child viewport positions are in the parent's canvas
    // Transform them to screen co-ordinates    
    result.viewport.vPos = UIDrawContext_CanvasPosToScreenPos( parentContext, childContext.viewport.vPos );
    vec2 vMax = childContext.viewport.vPos + childContext.viewport.vSize;
    vec2 vScreenMax = UIDrawContext_CanvasPosToScreenPos( parentContext, vMax );
    result.viewport.vSize = vScreenMax - result.viewport.vPos;
    result.vOffset = childContext.vOffset;
    
    // Now clip the view so that it is within the parent view
    vec2 vViewMin = max( result.viewport.vPos, parentContext.clip.vPos );
    vec2 vViewMax = min( result.viewport.vPos + result.viewport.vSize, parentContext.clip.vPos + parentContext.clip.vSize );

    // Clip view to current canvas
    vec2 vCanvasViewMin = result.viewport.vPos - result.vOffset;
    vec2 vCanvasViewMax = vCanvasViewMin + result.vCanvasSize;
    
    vViewMin = max( vViewMin, vCanvasViewMin );
	vViewMax = min( vViewMax, vCanvasViewMax );
    
    result.clip = Rect( vViewMin, vViewMax - vViewMin );
    
    return result;
}

// Function 1815
float drawFloat(float v)      {return drawFloat(v,2,5);}

// Function 1816
bool LineLineIntersect(out vec2 P, in vec2 P0, in vec2 d0, in vec2 P1, in vec2 d1)
{
    vec2 d0c = d0 / dot(d0, d0);
    vec2 X = d1 - d0 * dot(d1, d0c);
    vec2 Y = P1 - P0 - d0*dot(P1, d0c);

    float t1 = -dot(Y, X) / dot(X, X);

    vec2 Pd1 = P1 + t1 * d1;

    float t0 = dot((Pd1 - P0), d0) / dot(d0, d0);
    P = P0 + t0 * d0;
    
    return true;
}

// Function 1817
float spline2(vec2 p0, vec2 p1, vec2 p2, vec2 x)
{
    //coefficients for 0 = t^3 + a * t^2 + b * t + c
    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;
    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);

	//discriminant and helpers
    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;
    
    //triple real root
    if(dis > 0.) 
    {
        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);
        return dist(p0,p1,p2,x,ui.x+ui.y-tau);
    }
    
    //three distinct real roots
    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;
    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;
    return min(
        dist(p0,p1,p2,x, t.x),
        min(
            dist(p0,p1,p2,x,t.y),
            dist(p0,p1,p2,x,t.z)
        )
    );
}

// Function 1818
float drawdot(vec2 uv, float r){
    return smoothstep(0.0, 0.01, length(uv) - r);
}

// Function 1819
float circle(float pre, vec2 p, float r1, float r2, float power) {
    float leng = length(p);
    float d = min(abs(leng-r1), abs(leng-r2));
    if (r1<leng && leng<r2) pre /= exp(d)/r2;
    float res = power / d;
    return clamp(pre + res, 0.0, 1.0);
}

// Function 1820
float rectImpact(in vec3 pos, in vec3 recO, in vec3 recD, in vec3 N_ray, inout vec3 norm){
    
    float t_impact = INFINI;
    float t1,t2,t3;
    float d1,d2,d3;

    
    	if(recO.z+recD.z-pos.z<0.){
        	t1 = (recO.z+recD.z-pos.z)/N_ray.z;
        	d1 = 1.;
    	}
    	else if(recO.z-pos.z>0.000){
    		t1 = (recO.z-pos.z)/N_ray.z;
    		d1 = -1.;
		}
    	else{t1=-1.;}
    
    	if(recO.y+recD.y-pos.y<0.){
        	t2 = (recO.y+recD.y-pos.y)/N_ray.y;
        	d2 = 1.;
    	}
    	else if(recO.y-pos.y>0.){
        	t2 = (recO.y-pos.y)/N_ray.y;
        	d2 = -1.;
    	}
    	else{t2=-1.;}

    	if(recO.x+recD.x-pos.x<0.){
        	t3 = (recO.x+recD.x-pos.x)/N_ray.x;
        	d3 = 1.;
    	}
    	else if(recO.x-pos.x>0.){
        	t3 = (recO.x-pos.x)/N_ray.x;
        	d3 = -1.;
    	}
    	else{t3=-1.;}


    	vec3 pos1 = pos + N_ray*t1;
    	vec3 pos2 = pos + N_ray*t2;
    	vec3 pos3 = pos + N_ray*t3;
    
    	if(t1>0.001 && all(bvec2 (step(recO.xy,pos1.xy)*(1.-step(recO.xy+recD.xy,pos1.xy))))){
        	t_impact = t1;
        	norm = vec3 (0.,0.,d1);
    	}
		else
    	if(t2>0.001 && all(bvec2 (step(recO.xz,pos2.xz)*(1.-step(recO.xz+recD.xz,pos2.xz))))){
        	t_impact = t2;
        	norm = vec3 (0.,d2,0.);
    	}
    	else
    	if(t3>0.001 && all(bvec2 (step(recO.yz,pos3.yz)*(1.-step(recO.yz+recD.yz,pos3.yz))))){
        	t_impact = t3;
        	norm = vec3 (d3,0.,0.);
    	}
    
    return t_impact;
}

// Function 1821
float circle(vec2 uv, vec2 center, float max, float min)
{
    return smoothstep(max, min, length(uv - center));
}

// Function 1822
vec2 LineInt (vec2 a, vec2 u, vec2 b, vec2 v)
{
  return b + (Cross2 (a - b, u) / Cross2 (v, u)) * v;
}

// Function 1823
void drawSprite_16x16( inout vec3 col, int spr[32], vec3 pal[16], vec2 p, vec2 s ) {
    ivec2 i = ivec2( floor(p-s) );
    if( i.x>=0 && i.x<16 && i.y>=0 && i.y<16 ) {
        int pi = spr[ i.x/8 + i.y*2 ] >> ((7-i.x)*4) & 0xF;
        if (pal[pi].r>-0.5) col = pal[pi];
    }
}

// Function 1824
vec3 getDiffuseDirection(){
    return getRandomDirection(randomSeed);
}

// Function 1825
float ComputeCircle(vec2 pos, vec2 center, float radius, float feather)
{
    // Determine the distance to the center of the circle.
	float dist = length(center - pos);
    
    // Use the distance and the specified feather factor to determine where the distance lies
    // relative to the circle border.
    float start = radius - feather;
    float end   = radius + feather;
    return smoothstep(start, end, dist);
}

// Function 1826
float addCircle(in vec2 uv, in vec2 p,float r,float a,float b) {

    float t = 0.;
	 vec2 rel = uv-mix(p,vec2(0.25,0.4), t);
        float r1 = r;//mix(r, 0.2, t);
    if(length(rel)<r1) {
      
        float angle = atan(rel.y,rel.x);
        if(angle>3.141*0.95) { 
       //     angle-=2.*3.141;
        }
        if(angle>a && angle<b) {
			return 1.;
        } else {
      //   outColor.g+=0.015;   
        }
    }
    
	return 0.;
}

// Function 1827
float DistToLine(vec2 p, vec2 a, vec2 b)
{
 	vec2 pa = p - a;
    vec2 ba = b - a;
    
    float frac = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    
    return length(pa - (ba * frac));
}

// Function 1828
vec3 toLinear(vec3 c) { return pow(c,vec3(GAMMA)); }

// Function 1829
float line(vec2 coord)
{
    float reso = 24.0;
    float cw = iResolution.x / reso;

    vec2 pc = floor(coord / cw) * cw;
    vec2 pd = fract(coord / cw) * cw;
    
    float pt = potential(pc);
    float lw = pt + 0.5;
    float grad = 1.0 - pt * 2.0;

    return saturate(lw - abs(grad * pd.y - pd.x + cw * pt));
}

// Function 1830
float diffuse_directional(vec3 n,vec3 l, float strength)
{
      return (dot(n,normalize(l))*.5+.5)*strength;
}

// Function 1831
vec3 draw_iPoint(vec3 col, vec2 pointOnLine, vec2 uv){

    float f = 1.-smoothstep(0.02,0.04,abs(length(uv-pointOnLine)-0.15));
    col = mix(col, vec3(1.,0.7,0.), f);
    f = 1.-smoothstep(0.03,0.08,length(uv-pointOnLine)-0.015);
    col = mix(col, vec3(1.,0.7,0.), f);
    return col;
}

// Function 1832
vec2 lineTDist(vec2 pm, vec2 p0, vec2 p1)
{
	vec2 a = pm - p0;
	vec2 b = p1 - p0;
	float bLen = length(b);
	vec2 bNorm = normalize(b);
	float a1Len = dot(a, bNorm);
	vec2 a1 = a1Len * bNorm;
	vec2 a2 = a - a1;
	
	if (a1Len < 0.0) {
		return vec2(0.0,sqrlen(p0 - pm));
	} else if (a1Len > bLen) {
		return vec2(1.0,sqrlen(p1 - pm));
	} else {
		return vec2(a1Len / bLen,sqrlen(a2));
	}
}

// Function 1833
vec4 draw_half_tile( int type, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), ivec2( 16, 8 ) ) ) {
        type &= 0x3 ;
        int row_group = type * 2 + 1 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = 2 * iu.x ;
        uint bits = 0x3U << sh,
             col_ind = ( get_half_tile_br( row_group, component ) & bits ) >> sh ;
        v = get_col( pal_grass, col_ind ) ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 1834
float vline(vec3 p, float h, float r)
{
    p.y-=clamp(p.y, 0.0, h);
    return length(p)-r;
}

// Function 1835
vec3 Linear2sRGB(vec3 color){
    vec3 x = color * 12.92;
    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;
    vec3 clr = color;
    clr.r = (color.r < 0.0031308) ? x.r : y.r;
    clr.g = (color.g < 0.0031308) ? x.g : y.g;
    clr.b = (color.b < 0.0031308) ? x.b : y.b;
    return clr;
}

// Function 1836
float line(vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 1837
void DrawRainForest(out vec4 c){
	c = vec4(0.0, 0.6, 0.4, 1.0);
}

// Function 1838
float lineSegment(vec2 uv, vec2 start, vec2 end, float width) {
    
    vec2 stoe = end - start;
    vec2 nstoe = normalize(stoe);
    vec2 near = start + nstoe * clamp(dot(nstoe, uv - start), 0.0, length(stoe));
    return length(uv - near) - width;
}

// Function 1839
float drawFloat(float value, int prec) {return drawFloat(value,prec,2);}

// Function 1840
float linearstep(float edge0, float edge1, float x)
{
    return  clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}

// Function 1841
vec3 circleGlow( vec2 pos ){ //, float size, float focus

    //c = pow(c, focus);
    //vec3 col = vec3(c );    
    
    //float c = 20. / length(pos*size_c);
    //vec3 col = vec3(
    //	pow(c, focus_c - .5),
    //    pow(c, focus_c ),
    //    pow(c, focus_c + .5)
    //);

    //float c = 20. / length(pos*size_c);

    vec3 col = vec3(
    	pow(20. / length((pos+vec2(cshift,0.))*size), focus - .5),
        pow(20. / length(pos*size), focus ),
        pow(20. / length((pos-vec2(cshift,0.))*size), focus + .5)
    );
    
	return col;
}

// Function 1842
float ZPOS_circle
 (int number,  float angle,   vec2 fragCoord, bool red){
  int y = number/12;
    int x = number%12;
    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);
 float px =
        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) 
        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))
        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));
       float py = 
       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) 
      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )
      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));
     float pz = 
       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) 
      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) 
      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));
    
    /// here recalc radius
    
  float  radius2 =  radius + (pz)*s_ratio;
    
    
  
    
    
    ///get X Y and if lenght() < radius
     
    if(
        length (fragCoord - vec2(px ,py) - 
                (red? center2.xy: center.xy)*iResolution.xy  ) < radius2
        )
    return pz + center.z;
        else return noat;
}

// Function 1843
float line( in vec2 p, in vec2 a, in vec2 b, float w )
{
    return 1.0 - smoothstep( -e, e, distanceToSegment( p, a, b ) - w );
}

// Function 1844
void GammaCorrection(inout vec3 colorResult)
    {
        colorResult = pow(colorResult, abs(vec3(GAMMA)));
    }

// Function 1845
void DrawBare(out vec4 c){
	c = vec4(0.7, 0.7, 0.5, 1.0);
}

// Function 1846
vec3 draw_glyphs(vec2 fragCoord, float scale, float a, inout vec3 col) {
    vec3 total = vec3(0.);
    float total_alpha = 0.;
    for(int i = 0; i < MAX_GLYPHS; i++) {
        float i_float = float(i);
        vec4 glyphcol = glyph(glyphs[i], i_float, scale, fragCoord);
        float alpha = step(line_appear_time + .05 * i_float, time_remapped);
        alpha *= glyphcol.a;
        alpha *= step(i_float, glyph_count - 1.);
        total = mix(total, glyphcol.rgb, alpha);
        total_alpha = max(total_alpha, alpha);
    }
    // col = mix(col, total, total_alpha * a);
    return total*total_alpha;
    // return (1.-total)*total_alpha;
}

// Function 1847
float softCircle(in vec2 uv, in float radius, in float width)
{
    return smoothstep(width, 0.0, abs(radius - length(uv)));
}

// Function 1848
float Circle(in vec2 p, in float r)
{
    return length(p) - r;
}

// Function 1849
void circle ( float r , vec3 col , vec2 offset , vec2 vel ) {
	vec2 pos = coord.xy / iResolution.y;
	float aspect = iResolution.x / iResolution.y;
	vec2 c = center ( vec2 ( r / aspect , r ) , offset , vel );
	c.x *= aspect;
	float d = distance ( pos , c );
	field += ( k * r ) / ( d*d );
}

// Function 1850
vec3 getRayDirection(vec2 pos, vec2 res, float fov)
{
	float fx = tan(radians(fov) * 0.5) / res.x;
	vec2 d = (2.0 * pos - res) * fx;
	return normalize(vec3(d, 1.0));
}

// Function 1851
vec4 OutlineBox2D(vec2 uv, vec4 st, vec3 color)
{
    float d = sdBox(uv + st.zw, st.xy);
    color = DoOutline(d, color);
    return vec4(color, d);
}

// Function 1852
float draw_digit(vec2 p, int digit){
    return draw_char(p, vec2(float(digit), 12.0));
}

// Function 1853
vec4 Draw(vec2 fragCoord)
{   
    vec3   col = vec3(0.);
  	vec3   ray = EyeRay(fragCoord, -EYE);
  	RMInfo rmi = Raymarch(EYE, ray);

    if (rmi.objId == RING_ID)
    {
        vec2 uv;
        float fade = max(0., sin(iTime * .3));
        col = mix(col, Gold(rmi.pos, fade) * texture(iChannel0, reflect(ray, rmi.normal)).rgb, .99);            
        rmi = Raymarch(rmi.pos, reflect(ray, rmi.normal));

        // render the inscription!
        uv.x = atan( rmi.pos.z, rmi.pos.x ) / 3.14159;
        uv.y = 2.0 * rmi.pos.y;

        if ( uv.y > vMin && uv.y < vMax )
        {
            uv.x = ( uv.x + 1.0 ) * 0.5;
            uv.y = 1.0 - ( uv.y - vMin ) / ( vMax - vMin );
            float s = texScriptF( uv * vec2( 12500.0, -800.0 ) + vec2( 0.0, 450.0 ));

            // text is flickering depending on current audio value
            col += vec3( 0.9, 0.9, 0.5 ) * 1.5 * fade * vec3(1., .3, 0.) * (1. + 10. * texture(iChannel1, vec2(50., 0.)).r) * s;
        }
    }
    else if(rmi.objId == BACKGROUND_ID)
    {
        col += Background(ray);
    }

  	return vec4(col, 1.0);
}

// Function 1854
vec3 get_direction( float angle){
    
    float px =
        o_dir.x* ( cos(angle) + pow(rot_angle.x,2.)*(1. - cos(angle) ) ) 
        +o_dir.y*( rot_angle.y*rot_angle.x* (1. - cos(angle)) + rot_angle.z* sin(angle) ) 
        +o_dir.z*(rot_angle.z*rot_angle.x*(1. - cos(angle)) - rot_angle.y* sin(angle) ) ;
     float py = 
       o_dir.x*(rot_angle.x*rot_angle.y*(1. - cos(angle)) - rot_angle.z* sin(angle)) 
      +o_dir.y*(cos(angle) +pow(rot_angle.y,2.)*(1. - cos(angle)) )
      +o_dir.z*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.x* sin(angle));
     float pz = 
       o_dir.x*(rot_angle.z*rot_angle.y*(1. - cos(angle)) + rot_angle.y* sin(angle)) 
      +o_dir.y*(rot_angle.z*rot_angle.z*(1. - cos(angle)) - rot_angle.x* sin(angle)) 
      +o_dir.z*(cos(angle) +pow(rot_angle.z,2.)*(1. - cos(angle)));
    
    return normalize(vec3(px,py,pz));
    
}

// Function 1855
vec3 drawElement(in vec2 p, in vec2 objPos, in vec3 col, in float r, in float minR)
{
	float d = length(p - objPos);
	return mix(col, vec3(0.), smoothstep(0.0, max(r*gSound.f, minR), d));
}

// Function 1856
float line(vec2 p1, vec2 p2, vec2 uv, float t) {
  float a = abs(distance(p1, uv));
  float b = abs(distance(p2, uv));
  float c = abs(distance(p1, p2));
  if ( a >= c || b >=  c ) return 0.0;
  float p = (a + b + c) * 0.5;
  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));
  return mix(1.0, 0.0, smoothstep(0.5 * t, 1.5 * t, h));
}

// Function 1857
vec4 draw_buf(vec2 fragCoord){
    vec2 res=iResolution.xy/iResolution.y;
    vec2 uv=fragCoord/iResolution.y -res*0.5;
    vec2 ouv=fragCoord/iResolution.xy;
    float size=0.2;
    vec4 retc=vec4(0.);
    
    // BufB in quadUV(bufD)
    if((abs(uv.x-res.x*0.5+size)<size)&&(abs(uv.y-res.y*0.5+size)<size)){
        uv=uv-.5*res+size*2.;
        vec2 tuv=texture(iChannel3,uv*.5/size).rg;
        retc.rgb=vec3(texture(iChannel1,tuv).a*vec3(0.5,0.8,1.)*2.);
        retc.a=1.;
        //return retc;
    }
    
    if((abs(ouv.x-1.+size*2.*(1./res.x)+size*0.5)<size*0.5)&&(abs(ouv.y-1.+size*0.5)<size*0.5)){
        ouv=ouv-1.+vec2(size*2.*(1./res.x)+size*0.5,size*0.5);
        retc.rgb=vec3(texture(iChannel1,ouv*1./size+0.5).a*vec3(0.45,1.,.45)*2.);
        retc.a=1.;
        return retc;
    }
    
    return retc;
}

// Function 1858
vec4 renderVSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceX) {
    if (abs(screenSpaceUV.x - splitScreenSpaceX) < SPLIT_LINE_THICKNESS) {
        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));
	}

    return fragColor;
}

// Function 1859
void DrawWalls( vec2 pos )
{
	vec2 p = pixel-pos;
	vec2 ap = abs(p);
	vec4 t = texture( iChannel0, pixel*vec2(1,1)/60.0 );
	if ( max(ap.x,ap.y-20.0) < 60.0+4.0*pow((1.0-t.g),2.0) )
	{
		fragColor.rgb = mix( vec3(.4,.5,.6)*.2, vec3(.4,.5,.6), pow(1.0-t.r,5.0));
		
		fragColor.rgb *= mix( .3, 1.5, smoothstep( -40.0, -35.0, p.y ) );
	}
}

// Function 1860
float circle(vec2 uv, float r, vec2 pixuv)
{
    return .25 * smoothstep(0.005, 0., abs(length(pixuv - uv) - r));
}

// Function 1861
float direction(float roll, float pitch, float yaw, out vec3 rd)
{
  if (direction(rd) < 0.0)
  {
    return -1.0;
  }
  // Rotate the ray direction to have camera rotation with
  // pitch, yaw and roll angles
  rd *= rotateAroundZ(yaw)*rotateAroundY(pitch)*rotateAroundX(roll);
  return 1.0;
}

// Function 1862
vec3 linear_srgb(vec3 x) 
{
    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));
}

// Function 1863
float drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )
{
    // Subtract our position from the current uv so that we can
    // know if we're inside the bounding box or not.
    uv-=pos;
    
    // Divide the screen space by the size, so our bounding box is 1x1.
    uv /= size;    
    
    // Create a place to store the result.
    float res;
    
    // Branchless bounding box check.
    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));
    
    // Go ahead and multiply the UV by the bitmap size so we can work in
    // bitmap space coordinates.
    uv *= MAP_SIZE;
    
    // Get the appropriate bit and return it.
    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );
    return clamp(res,0.0,1.0);
}

// Function 1864
float euclidean_line_dist(vec2 p, vec2 a, vec2 b){
    vec2 n = vec2(-(b-a).y, (b-a).x);
    return dot(n,p-a);
}

// Function 1865
void calculateEnergyDirectX9(inout Voxel voxel, in ivec3 worldCoord)
{
    if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)
    {
        uint maxTorchEnergy = 0U;
        uint maxDustEnergy = 0U;
        
        // Voxels on the same level
        Voxel levelVoxels[4] = Voxel[4](
            readVoxel(worldCoord + ivec3(-1, 0, 0)),
            readVoxel(worldCoord + ivec3(1,  0, 0)),
            readVoxel(worldCoord + ivec3(0,  1, 0)),
            readVoxel(worldCoord + ivec3(0, -1, 0))
        );

        for (int i = 0; i < levelVoxels.length(); ++i)
        {
            if (levelVoxels[i].energy > 0U)
            {
                switch (levelVoxels[i].type)
                {
                    case VOXEL_TYPE_REDSTONE_DUST:
                    maxDustEnergy = max(maxDustEnergy, levelVoxels[i].energy - 1U);
                    break;

                    case VOXEL_TYPE_REDSTONE_TORCH:
                    maxTorchEnergy = max(maxTorchEnergy, levelVoxels[i].energy);
                    break;
                }
            }
        }
        
        Voxel aboveVoxel = readVoxel(worldCoord + ivec3(0,0,1));
        
        if (worldCoord.z > 0)
        {
        	// Voxels below
            Voxel voxels[4] = Voxel[4](
            	readVoxel(worldCoord + ivec3(-1, 0, -1)),
                readVoxel(worldCoord + ivec3(1,  0, -1)),
                readVoxel(worldCoord + ivec3(0,  1, -1)),
                readVoxel(worldCoord + ivec3(0, -1, -1))
            );
            
            
            for (int i = 0; i < voxels.length(); ++i)
            {
                if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST
                    && voxels[i].energy > maxDustEnergy
                    && levelVoxels[i].type != VOXEL_TYPE_STONE)
                {
                	maxDustEnergy = voxels[i].energy - 1U;
                }
            }
        }
        
        if (worldCoord.z <= globalWorld.virtualDim.z && aboveVoxel.type != VOXEL_TYPE_STONE)
        {
            // Voxels above
            Voxel voxels[4] = Voxel[4](
            	readVoxel(worldCoord + ivec3(-1, 0, 1)),
                readVoxel(worldCoord + ivec3(1,  0, 1)),
                readVoxel(worldCoord + ivec3(0,  1, 1)),
                readVoxel(worldCoord + ivec3(0, -1, 1))
            );
            
            
            for (int i = 0; i < voxels.length(); ++i)
            {
                if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST
                    && voxels[i].energy > maxDustEnergy)
                {
                	maxDustEnergy = voxels[i].energy - 1U;
                }
            }
        }
        
        
        if (maxTorchEnergy > 0U)
        	voxel.energy = max(voxel.energy, maxTorchEnergy);
        else
            voxel.energy = maxDustEnergy;
    }
}

// Function 1866
bool inRect(vec2 u, vec4 b
){b.xyzw-=u.xyxy
 ;return mi(b.zy-b.xw)<mi(b)
 ;return min(b.z-b.x,b.y-b.w)<mi(b) ;}

// Function 1867
float obj_roundline( vec3 p, vec3 a, vec3 b, float r ){
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

// Function 1868
vec2 CircleRand( vec2 rand )
{
    return vec2(cos(rand.x*tau),sin(rand.x*tau)) * sqrt(rand.y+.5);
}

// Function 1869
float sdcircle(vec2 p, float r) {
    return length(p) - r;
}

// Function 1870
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 1871
void LineToNoTS(float2 p)
{
    l=min(l,Draw(CP,p,uv));
    CP=p;
}

// Function 1872
float outline (float d) {
    return 1.0 - smoothstep(0.0, 3.0 / iResolution.y, abs(d));
}

// Function 1873
vec3 DirectLightOnVolume(in Ray ray, in float len) {
    const float strata = 1.0/float(VOLUME_DIRECT_LIGHT_SAMPLES);
    vec3 volumeDirectLight = vec3(0.);
    for(int i=0; i<VOLUME_DIRECT_LIGHT_SAMPLES; i++) {
        float particleDist;
        float particlePdf;
        //avoid sampling other side of the light
        float maxt = -(ray.origin.y - light.pos.y) / ray.dir.y;//doesn't work :(
        len = (ray.dir.y > 0.0) ? min(maxt, len) : len;
        float xi = strata*(float(i)+rnd());
        
        sampleEquiAngular( ray, len, xi, light.pos, particleDist, particlePdf );
        vec3 particlePos = ray.origin + particleDist*ray.dir;
        volumeDirectLight += salmpleLightForParticle(particlePos, ray.time) / particlePdf;
        //volumeDirectLight += samplePhaseForParticle(particlePos, ray.time) / particlePdf;
    }
    return volumeDirectLight / float(VOLUME_DIRECT_LIGHT_SAMPLES);
}

// Function 1874
vec3 randomDirectionHemisphere(vec3 main_direction, float n){
	vec2 perturbation = randomPolar(n);
    vec3 direction = polarToCartesian(perturbation);
    if(abs(main_direction.z) > 0.99999f) return sign(main_direction.z) * direction;
    
    vec3 axis = normalize(cross(UP, main_direction));
    float angle = acos(main_direction.z);
   	
    return rotate(axis, angle, direction);
}

// Function 1875
void DrawTurret( inout vec3 color, vec4 turret, float worldX, float worldY )
{
    SpriteTurretBase( color, worldX - turret.x + TURRET_SIZE.x * 0.5, worldY - turret.y + TURRET_SIZE.y * 0.5 );
    
    // left 
    float frame     = 0.0;
    float turretX   = worldX - turret.x;
    float turretY   = worldY - turret.y;

    if ( turret.z == 0.0 )
    {
        frame = 0.0;
        turretX += 14.0;
        turretY += 7.0;
    }
    else if ( turret.z == 1.0 )
    {
        frame = 1.0;
        turretX += 13.0;
        turretY += 7.0;
    }
    else if ( turret.z == 2.0 )
    {
        frame = 2.0;
        turretX += 8.0;
        turretY += 3.0;
        Swap( turretX, turretY );
        turretX = 15.0 - turretX;
    }     
    else if ( turret.z == 3.0 )
    {
        frame = 0.0;
        turretX += 15.0;
        turretY += 2.0;
        Swap( turretX, turretY );
        turretX = 15.0 - turretX;
        turretY = 21.0 - turretY;
    }
    else if ( turret.z == 4.0 )
    {
        frame = 2.0;
        turretX += 14.0;
        turretY += 3.0;
        Swap( turretX, turretY );
        turretX = 15.0 - turretX;
        turretY = 21.0 - turretY;
    }
    else if ( turret.z == 5.0 )
    {
        frame = 1.0;
        turretX += 4.0;
        turretY += 7.0;
        turretX = 15.0 - turretX;        
    }    
    else if ( turret.z == 6.0 )
    {
        frame = 0.0;
        turretX += 9.0;
        turretY += 7.0;
        turretX = 21.0 - turretX;       
    }     
    else if ( turret.z == 7.0 )
    {
        frame = 2.0;
        turretX += 10.0;
        turretY += 7.0;
        turretX = 21.0 - turretX;       
    }    
    else if ( turret.z == 8.0 )
    {
        frame = 1.0;
        turretX += 8.0;
        turretY += 12.0;
        Swap( turretX, turretY );       
    }  
    else if ( turret.z == 9.0 )
    {
        frame = 0.0;
        turretX += 15.0;
        turretY += 13.0;
        Swap( turretX, turretY );
        turretY = 21.0 - turretY;        
    }          
    else if ( turret.z == 10.0 )
    {
        frame = 1.0;
        turretX += 15.0;
        turretY += 12.0;
        Swap( turretX, turretY );
        turretY = 21.0 - turretY;        
    }
    else
    {
        frame = 2.0;
        turretX += 13.0;
        turretY += 8.0;        
    }      

    SpriteTurret( color, turretX, turretY, frame );
}

// Function 1876
vec3 linearToSrgb(const vec3 x){
    return 1.14374*(-0.126893*x+sqrt(x));
}

// Function 1877
float sdLineSegment(vec2 uv, vec2 a, vec2 b, float lineWidth)
{
    vec2 rectDimensions = b - a;
    float angle = atan(rectDimensions.x, rectDimensions.y);
    mat2 rotMat = rot2D(-angle);
    a *= rotMat;
    b *= rotMat;
    float halfLineWidth = lineWidth / 2.;
    a -= halfLineWidth;
    b += halfLineWidth;
    return sdAxisAlignedRect(uv * rotMat, a, b);
}

// Function 1878
void DrawTopLine(vec2 p, inout vec3 color)
{
    vec2 q = p-vec2(0., 0.3);
    float d = length(q*vec2(0.03, 1.))-0.001;
        
    vec3 barColor = mix(vec3(0.682, 0.184, 0.854), color, smoothstep(0., 0.05, d));
    barColor = mix(vec3(1.), barColor, smoothstep(-0.01, 0.03, d));
    
    float deadT = max(0., gT - kFinishTime);
    color = mix(barColor, color, min(deadT*0.25, 1.));
}

// Function 1879
vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {
	float d = length(pos - uv) - rad;
	float t = clamp(d, 0.0, 1.0);
	return vec4(color, 1.0 - t);
}

// Function 1880
float semiCircleDist(vec2 p, float radius, float angle, float width)
{
	width /= 2.0;
	radius -= width;
	return substract(pie(p, angle), 
					 abs(circleDist(p, radius)) - width);
}

// Function 1881
float Rectangle(vec2 pos, float width, float height)
{
  	return Band(pos.x, width) * Band(pos.y, height);
}

// Function 1882
vec3 DrawCandyExplosion(vec2 p, vec3 candyColor, vec3 bgColor, vec4 candyIdData)
{
    float t = (1.-candyIdData.w);

    if(candyIdData.w > 0.99){return candyColor;}
    for(float i=0.; i<12.;++i)
    {
        float size = max(hash(10.-i)*1.5, 0.1);
        vec2 vel = normalize(vec2(hash(i), hash(5.+6.*i)))*(hash((i+4.)*6.)*2.-1.)*1.5;
        vec2 pos = vel*pow(t, 0.3);
        
        vec2 q = p-pos;
        candyColor += step(1e-3, t)*candyColor*(1.-smoothstep(0., 1., length(q)/size ));
    }
    
    candyColor = mix(bgColor, candyColor, candyIdData.w);
    
    float size = 1.*t;
    float d = length(p)-size;
    candyColor += step(1e-3, t)*sin(PI*pow(t, 0.5))*candyColor* (1.-smoothstep(0.2, 1., abs(d)/0.4));
    return candyColor;
}

// Function 1883
void circle(vec2 p, float r) {
    vec4 c = _stack.position - p.xyxy;
    add_field(vec2(length(c.xy),length(c.zw)) - r);
}

// Function 1884
vec2 correct_aspect(vec2 uv, vec2 source_res, vec2 dest_res) {
    float ar_source = source_res.x / source_res.y;
    float ar_dest = dest_res.x / dest_res.y;
    float ar = ar_dest / ar_source;
    
    // Choose to adjust either the horizontal or vertical scale
    // depending on whether the source ratio is vertical to the dest.
    vec2 scale = mix(vec2(ar, 1.0), vec2(1.0, ar), step(ar, 1.0)); 
    return scale_uv(uv, scale, vec2(0.5));
}

// Function 1885
void SpriteWaterCircle( inout vec3 color, float x, float y )
{
    float idx = 0.0;
    
    idx = y == 6.0 ? ( x <= 7.0 ? 14336.0 : 44.0 ) : idx;
    idx = y == 5.0 ? ( x <= 7.0 ? 49360.0 : 1795.0 ) : idx;
    idx = y == 4.0 ? ( x <= 7.0 ? 31874.0 : 33341.0 ) : idx;
    idx = y == 3.0 ? ( x <= 7.0 ? 819.0 : 52416.0 ) : idx;
    idx = y == 2.0 ? ( x <= 7.0 ? 47112.0 : 8238.0 ) : idx;
    idx = y == 1.0 ? ( x <= 7.0 ? 4144.0 : 3076.0 ) : idx;
    idx = y == 0.0 ? ( x <= 7.0 ? 36352.0 : 178.0 ) : idx;

    idx = SPRITE_DEC_4( x, idx );
    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;
    
    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;
    color = idx == 2.0 ? RGB( 248,  56,  0   ) : color;
    color = idx == 3.0 ? RGB( 240,  208, 176 ) : color;
}

// Function 1886
float sdCircle (vec2 p, float radius)
{
  return length(p) - radius;
}

// Function 1887
float distanceToLine(vec2 p1, vec2 p2, vec2 point) {
    float a = p1.y-p2.y;
    float b = p2.x-p1.x;
    return abs(a*point.x+b*point.y+p1.x*p2.y-p2.x*p1.y) / sqrt(a*a+b*b);
}

// Function 1888
vec3 directionalLight(vec3 normalizedNormal, vec3 position, vec3 lightPos, vec3 viewPosition, vec3 color, float shadow)
{
    vec3 lightColor = vec3(1.);
    // ambient
    vec3 ambient = lightColor * 0.15 * color;
    
    vec3 lightDirection = normalize(lightPos-position);
    vec3 viewDirection = normalize(viewPosition-position);
	vec3 halfwayDirection = normalize(lightDirection + viewDirection);
    
    // diffuse
    float diffuseIntensity = max(dot(normalizedNormal, lightDirection),0.0);
    vec3 diffuse = diffuseIntensity * lightColor * color;
    
    // specular
    float specularStrength = .85;
    float specularIntensity = pow(max(dot(normalizedNormal, halfwayDirection),0.0),32.);
    //// going glossy on the specular (no color multiplication)
    vec3 specular = specularStrength * specularIntensity * lightColor;						
    return (ambient + (diffuse + specular)*(1. - shadow));

    
}

// Function 1889
float sdf_line5(vec2 uv, vec2 vert_A, vec2 vert_B) {
    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!
    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B
    vec2 dvec_AB_rotated = dvec_AB.yx;  // Rotate by pi/2 radians, by "hand"
    dvec_AB_rotated.y *= -1.;           // Rotate by pi/2 radians, by "hand"
    float vector_projection_AP_ABr_snorm = dot(dvec_AP, normalize(dvec_AB_rotated));  // This is the signed-norm of the vector-projection of dvec_AP to dvec_AB_rotated
    return vector_projection_AP_ABr_snorm;  // And such signed-norm ends up being the signed distance we're after!
}

// Function 1890
float Line(float u, float b) { return Graph(u, b); }

// Function 1891
vec3 drawJauge(vec2 uv, float level)
{
    float waveLvl = 0.05;
    float sz = 0.21;
    level += waveLvl*sin(iTime+uv.x*10.) - waveLvl;
    level = sat(level);
    
    bool inWidth = abs(uv.x) < sz;
    bool inHeight = uv.y > -sz && uv.y < mix(-sz, sz+waveLvl, level) && uv.y < sz;
    
	float coef = float(inWidth && inHeight);
    
    vec3 col;
    
    float cGrad = pow(max(uv.x+uv.y+0.5,0.),.5);
    
    float power = 2.2;
    vec3 light = vec3(204, 255, 204)/255.0;
    light.x = pow(light.x, power);
    light.y = pow(light.x, power);
    light.z = pow(light.x, power);
    
    col = mix(vec3(204, 51, 153)/255.0*0.6, light, cGrad) * (2.*uv.y+0.9);

	//col += mix(vec3(0, 0, 102)/255.0*0.6, light, cGrad);
    //col += mix(-sz, sz+waveLvl, level) * vec3(255, 102, 255)/255.0 * sat(uv.y);
    vec3 greenish =vec3(153, 244, 26)/255.;
    vec3 bluish = vec3(26, 182, 244)/255.;
    return col+bluish*coef+drawBubbles(uv)*coef;
}

// Function 1892
float lineScroll (float y) {
    float s = 0.0;
    if (y>8.0*8.0) s = 10.0;
    if (y>8.0*20.0) s = 40.0;
    if (y>8.0*21.0) s = 60.0;
	return floor(s*iTime);
}

// Function 1893
vec3 drawHeart(vec2 coord, vec2 pos, float invScale, vec2 stretch, vec3 oldColor)
{
  // credits go to @iq - https://www.shadertoy.com/view/XsfGRn
  vec2 coordinate = stretch * (coord - pos) * invScale;
  float a = atan(coordinate.x,coordinate.y)/3.141593;
  float r = length(coordinate);
  float h = abs(a);
  float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);
  vec3 hcol = vec3(1.0,0.5*r,0.3);

  float heartMask = smoothstep(0.0, fwidth(d-r), d-r);

  return mix(oldColor, hcol, heartMask);
}

// Function 1894
float circle(vec2 p, float r, float zoom)
{
    float d = distance(r, 0.45 * zoom);
    return d2y(1000.0 * d);
}

// Function 1895
vec2 randomPointInCircle(vec2 rand) {
	float a = rand.x * 2.0 * PI;
	float r = sqrt(rand.y);
	float x = r * cos(a);
	float y = r * sin(a);
    return vec2(x,y);
    
    
}

// Function 1896
vec4 draw_character( int n, ivec2 pos, ivec2 iu ) {
    vec4 v = vec4( 0, 0, 0, 1 ) ;
    iu -= pos + ivec2(1,0) ;
    if( n > 0 && n <= NUM_FONT_CHARS && iINSIDE( iu, ivec2(0), ivec2(5,7) ) ) {
        iu = ivec2( iu.x + ( n - 1 ) * 5, 128 + iu.y ) ;
        v = vec4( texelFetch( iChannel0, iu, 0 ).xxx, 1 ) ;
    }
    return( v ) ;
}

// Function 1897
float linearstep(float begin, float end, float t) {
    return clamp((t - begin) / (end - begin), 0.0, 1.0);
}

// Function 1898
float HALFcircle(vec2 p, float r)
{
    
    float c = 1.0-SScircle(p, r);//can have other functions for half circles of
    							// other types
    float hf = smoothstep(-0.1, 0.09, p.x);
 return c*hf;   
}

// Function 1899
bool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}

// Function 1900
vec3 desiredDirection() 
{
    return loadValue(CamState, slotDesiredForward).xyz;
}

// Function 1901
float drawR(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));
  float val2 = float(isIn(length(uv+vec2(0.0, -0.02)), cMin - cthick, cMin) && uv.x > 0.0);
  uv -= vec2(0.0, -0.02);
  float  val3 = float(isIn(-uv.y-uv.x, -cthick*0.5,cthick*0.5) &&
    isIn(uv.y, -0.05, -0.02));
  return val + val2 + val3;
}

// Function 1902
void sceneDualCircles2(vec2 uv, out vec3 params)
{
	vec3 p=stereographic(uv*3.);

	p.xz=mod(rotate(p.xz,iBeat*.5),1.)-.5;

	params= vec3(
		sign(p.x*p.y*p.z),
		vec2(29,31)
	);
}

// Function 1903
vec4 drawCell(ivec4 state, mat4x3 colors, ivec2 coordCell, int animFrame, int gameFrame, float stripesAlpha)
{
    int cellType = int(state.x);

    vec4 col = vec4(0.0);

         if (cellType == CELL_VOID)          col = drawCellVoid(stripesAlpha, colors, coordCell, animFrame);
    else if (cellType == CELL_ROCKFORD)      col = drawCellRockford(state, colors, coordCell, animFrame);
    else if (cellType == CELL_DIRT)          col = drawCellDirt(state, colors, coordCell);
    else if (cellType == CELL_BOULDER)       col = drawCellBoulder(state, colors, coordCell);
    else if (cellType == CELL_DIAMOND)       col = drawCellDiamond(state, colors, coordCell, animFrame);
    else if (cellType == CELL_WALL)          col = drawCellWall(state, colors, coordCell);
    else if (cellType == CELL_TITAN_WALL)    col = drawCellTitaniumWall(state, colors, coordCell);
    else if (cellType == CELL_MAGIC_WALL)    col = drawCellMagicWall(state, colors, coordCell, animFrame);
    else if (cellType == CELL_FIREFLY)       col = drawCellFirefly(state, colors, coordCell, animFrame);
    else if (cellType == CELL_BUTTERFLY)     col = drawCellButterfly(state, colors, coordCell, animFrame);
    else if (cellType == CELL_AMOEBA)        col = drawCellAmoeba(state, colors, coordCell, animFrame);
    else if (cellType == CELL_ENTRANCE)      col = drawCellEntrance(state, colors, coordCell, gameFrame);
    else if (cellType == CELL_EXIT)          col = drawCellExit(state, colors, coordCell, gameFrame);
    else if (cellType == CELL_EXPL_VOID)     col = drawCellExplosionVoid(state, colors, coordCell, gameFrame);
    else if (cellType == CELL_EXPL_DIAMOND)  col = drawCellExplosionDiamond(state, colors, coordCell, gameFrame);
    else if (cellType == CELL_EXPL_ROCKFORD) col = drawCellExplosionRockford(state, colors, coordCell, gameFrame);
    else                                     col = drawCellUndefined(state, colors, coordCell, gameFrame);

    return col;
}

// Function 1904
bool iBilinear(in vec2 xy, in vec2 a, in vec2 b, in vec2 c, in vec2 d, out vec4 uv) {
    vec2 p = a - b + c - d;
    vec2 q = b - a, r = d - a;

    float c1 = cross2D(r, p);
    float c2 = cross2D(r, q) + cross2D(a, p) + cross2D(p, xy);
    float c3 = cross2D(a, q) + cross2D(q, xy);

    float discr = c2 * c2 - 4.0 * c1 * c3;
    if (discr > 0.0) {
        uv.yw = (vec2(-1.0, 1.0) * sqrt(discr) - c2) / c1 * 0.5;
        uv.xz = (xy.x - a.x - r.x * uv.yw) / (p.x * uv.yw + q.x);
        return true;
    }

    return false;
}

// Function 1905
float circleFill(vec2 pos, float radius)
{
    return clamp(((1.0-(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);   
}

// Function 1906
void drawLine(vec2 uv, inout vec3 color, Line l){
    float alpha = l.color.a;
    #if DARKMODE
    alpha = pow(alpha, 1.5);
    #else
    alpha = pow(alpha, 0.75);
    #endif
    color = mix(l.color.rgb, color, (1.0-alpha) + alpha*lineShape(uv, l));
}

// Function 1907
void drawGround()
{
    if (gFrag.uv.y >= GROUND_HEIGHT * 0.99)
        return;
    
    gFrag.c *= 0.25;
    
    gFrag.c += vec4(0.5 / (40. * (GROUND_HEIGHT - gFrag.uv.y) + 1.6));
    
    const float 
        GSHW = (1. - GROUND_SPLIT_WIDTH) * 100.;
    
    float d = (GROUND_SPLIT_PREC - gFrag.uv.y * GROUND_SPLIT_CAM_COEF) / GSHW,
        x = gFrag.uv.x - 0.5,
        y = GROUND_HEIGHT * 1.1 - gFrag.uv.y;
    
    // I've got to get rid of this loop
    for (float n = 1.5; n > 0.1; n /= (n > 1.) ? 4. : 2.)
        if (abs(abs(n * x) - y) < d) {
            gFrag.c += GROUND_SPLIT_COLOR;
            return;
        }
    
    if (sin(gFrag.uv.y * (GSHW * (1.2 - GROUND_HEIGHT)) * -log(0.6 - gFrag.uv.y) ) > 0.98 + gFrag.uv.y / 15.) 
        gFrag.c += GROUND_SPLIT_COLOR;
}

// Function 1908
vec4 drawBoat(in float x, in float y)
{
	// Oh look the boat looks just like elementary inequality graphs...
    x = -x; // save time, negate x.
    // Most common case is the first checked.
	if (y > 2.*x + 71. || y > x + 40.) return TRANS;
	else if(y > 2.*x + 24.) return BLACK;
    else return BROWN;
	
}

// Function 1909
vec4 drawHealth( vec2 uv ) {
    uv = floor(fract(uv)*64.) - 32.;
    if( abs(uv.x) < 12. && abs(uv.y) < 12. ) {
        vec4 col = vec4( 1,1,1, smoothstep( 10., 9., length(uv)) );
        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 1.)*step(abs(uv.x),7.) );
        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 7.)*step(abs(uv.x),1.) );
        return vec4( 2.*col.rgb * (.5 + .5 * texture(iChannel1, uv/64.).x), col.a );
    } else {
        return vec4(0);
    }
}

// Function 1910
float sdRect(vec2 p, vec2 r) {
    p = abs(p) - r;
	return min(max(p.x, p.y), 0.) + length(max(p, 0.));
}

// Function 1911
float line(vec2 p, vec2 p0, vec2 p1, float width) {
    vec2 dir0 = p1 - p0;
    vec2 dir1 = p - p0;
    float h = clamp(dot(dir1, dir0)/dot(dir0, dir0), 0.0, 1.0);
    float d = (length(dir1 - dir0 * h) - width * 0.5);
    return d;
}

// Function 1912
bool drawLetter(out vec4 fragColor, in vec2 uv, in Character c) {
    vec2 st = (uv - c.origin) / c.size;
    if (st.x < 0.0 || 1.0 < st.x || st.y < 0.0 || 1.0 < st.y) return false;
    
    int a = c.code / 16 + 1;
    int b = c.code % 16;
    vec2 base = vec2(float(b), 16.0 - float(a)) / 16.0;

    vec4 color = texture(iChannel0, st / 16.0 + base);
    if (color.x < 0.5) return false;
    
    fragColor = c.color;
    return true;
}

// Function 1913
vec4 draw_enemy_bullet( int type, int frame, ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), en_bull_dim ) ) {
        int x = iu.x, y = iu.y ;
        x += 3 * (frame & 3) ;
        PREPARE_TEST_BIT ;
        if( type == 0 ) {
            BR12(6, _,w,_ , _,w,_ , w,w,w , _,w,_ ) ;
            BR12(5, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(4, _,w,_ , w,w,w , _,w,_ , _,w,_ ) ;
            BR12(3, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(2, w,w,w , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(1, _,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(0, _,w,_ , _,w,_ , _,w,_ , w,w,w ) ;
        } else if( type == 1 ) {
            BR12(6, _,w,_ , _,w,_ , _,w,w , _,w,_ ) ;
            BR12(5, _,w,_ , _,w,_ , w,w,_ , _,w,_ ) ;
            BR12(4, w,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(3, _,w,w , _,w,_ , _,w,w , _,w,_ ) ;
            BR12(2, _,w,_ , _,w,_ , w,w,_ , _,w,_ ) ;
            BR12(1, w,w,_ , _,w,_ , _,w,_ , _,w,_ ) ;
            BR12(0, _,w,w , _,w,_ , _,w,_ , _,w,_ ) ;
        } else if( type == 2 ) {
            BR12(6, w,_,_ , _,w,_ , _,_,w , _,w,_ ) ;
            BR12(5, _,w,_ , _,_,w , _,w,_ , w,_,_ ) ;
            BR12(4, _,_,w , _,w,_ , w,_,_ , _,w,_ ) ;
            BR12(3, _,w,_ , w,_,_ , _,w,_ , _,_,w ) ;
            BR12(2, w,_,_ , _,w,_ , _,_,w , _,w,_ ) ;
            BR12(1, _,w,_ , _,_,w , _,w,_ , w,_,_ ) ;
            BR12(0, _,_,w , _,w,_ , w,_,_ , _,w,_ ) ;
        }
    }
    return( vec4( v, 1 ) ) ;
}

// Function 1914
vec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)
{
   vec3 color = vec3(0.0);
   int id = -1;
   i = false;
   //vec3 toLight = (lightf-hit);
   //float sqdist = dot(toLight,toLight);
   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);
   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;
 
   if(diffuse>0.0)
   {
      float ldist =distance(lightf,hit);// sqrt(sqdist);
      float sh = 1000.0;//distance(lightf,hit);
      shadow(hit + normal * 0.0001, L, sh, id, true);           
      if(sh>ldist)
         {color += cl * (diffuse/(ldist))*0.32; i = true;}
   }
   return color;
}

// Function 1915
float SRGBtoLinear(float value)
{
	if (value <= 0.04045)
		return value/12.92;
	else
		return pow((value + 0.055)/1.055, 2.4);
}

// Function 1916
vec3 closestPointsOnLines(vec3 p0, vec3 v0, vec3 p1, vec3 v1)
{
    return inverse(mat3(v0, -v1, cross(v1, v0))) * (p1 - p0);
}

// Function 1917
float drawDigit(int d, vec2 pos){
    vec4 sv = vec4(1.0, 0.0, 1.0, 0.0);
    vec3 sh = vec3(1.0);
    float c = 0.0;
    
    vec2 v = digitSegments(d);
    
    for (int i = 0; i < 4; i++)
        c += segmentV(pos + pixel.x * pV[i]) * nextDigit(v.x);

    for (int i = 0; i < 3; i++)
        c += segmentH(pos + pixel.x * pH[i]) * nextDigit(v.y);
    
	return c;
	}

// Function 1918
Rect UI_GetFontRect( PrintState state, LayoutStyle style )
{
    Rect rect;
    rect = GetFontRect( state, style, true );
    vec2 vExpand = UIStyle_FontPadding();
    vExpand.y += style.vSize.y * style.fLineGap;
    RectExpand( rect, vExpand );
	return rect;
}

// Function 1919
float DrawOutlinePix(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float outlineThick) {
    float scale = abs(dFdy(uv).y);
    thick = (thick * 0.5 - 0.5) * scale;
    rounded = (rounded * 0.5 - 0.5) * scale;
    outlineThick = (outlineThick * 0.5 - 0.5) * scale;
    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);
    return saturate((abs(df + outlineThick) - outlineThick) / scale);
}

// Function 1920
float LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)
{
	vec3 AP = point - A;
    vec3 AB = B - A;
    
    // from https://www.youtube.com/watch?v=PMltMdi1Wzg
    // added normal calculation though
    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));
    vec3 closestPoint = A + h * AB;
    normal = normalize(point - closestPoint);
    return length(point - closestPoint) - width;
}

// Function 1921
float sdRectangle(in vec2 p, in vec4 r)
{
    r.pq /= 2.;
    vec2 d = abs(p - r.xy - r.pq) - r.pq;
    d.y *= RATIO;
  	//return min(max(d.x, d.y), 0.) + length(max(d, 0.));
    // I prefer the Chebyshev distance in this case
    return min(max(d.x, d.y), 0.) + max(max(d.x, d.y), 0.);
}

// Function 1922
vec3 circle(vec3 color, vec2 uv, float pos, float r, float blur)
{    
    vec3 res = white;
    
    // Change the bounds of 't' to draw a part of a circle.
    // (Not parameterized because it requires additional smoothing.)
    for (float t = 0.; t < 2. * pi; t += .01) {
        // Bounds.
        vec2 c1 = pCircle(pos,     t);
        vec2 c2 = pCircle(pos - r, t);
        
        // Find if a point belongs to a section using the triangle
        // inequality (comparing to 'eps' due to floating-point).
        float d1 = distance(c2, uv);
        float d2 = distance(uv, c1);
        float d3 = distance(c2, c1);
               
    	// Decreasing this value produces an interesting effect.
    	float eps = .001;
        
		if (abs(d1 + d2 - d3) < eps) {
            // XXX: This blurs inward, reducing the size of the circle.
            // XXX: When 'blur' == 1, the circle disappears.
            res = color;
            res *= smoothstep(d3, d3 * blur, d1);            
            res *= smoothstep(d3, d3 * blur, d2);
            break;
        }
        else res -= color;
    }
    
    return res;
}

// Function 1923
vec3 drawCirc(vec3 col, vec2 coord, vec2 pos, float rad, vec3 oldColor)
{
    float dst = distance(coord, pos);
    return mix(oldColor, col, 1.0 - smoothstep(rad - fwidth(dst), rad, dst));
}

// Function 1924
float Circle(vec2 uv, float r, float blur) {
    // uv is the (x,y) position
    
    // d is the distance from the center to the given (x,y) uv coordinate
    // this affects the radius of the circle, larger d is a smaller circle    
    float d = length(uv);
   
	// c is the color of the pixels in the image, per (x,y) uv coordinate
    // 0.0 is black, 1.0 is white
    // r is the radius of the circle
    float c = smoothstep(r, r-blur, d);
    
    return c;
}

// Function 1925
float LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {
    // Don't let it get more round than circular.
    rounded = min(thick.y, rounded);
    // midpoint
    vec2 mid = (pB + pA) * 0.5;
    // vector from point A to B
    vec2 delta = pB - pA;
    // Distance between endpoints
    float lenD = length(delta);
    // unit vector pointing in the line's direction
    vec2 unit = delta / lenD;
    // Check for when line endpoints are the same
    if (lenD < 0.0001) unit = vec2(1.0, 0.0);	// if pA and pB are same
    // Perpendicular vector to unit - also length 1.0
    vec2 perp = unit.yx * vec2(-1.0, 1.0);
    // position along line from midpoint
    float dpx = dot(unit, uv - mid);
    // distance away from line at a right angle
    float dpy = dot(perp, uv - mid);
    // Make a distance function that is 0 at the transition from black to white
    float disty = abs(dpy) - thick.y + rounded;
    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;

    // Too tired to remember what this does. Something like rounded endpoints for distance function.
    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;
    dist = min(dist, max(distx, disty));

    // This is for animated dashed lines. Delete if you don't like dashes.
    float dashScale = 2.0*thick.y;
    // Make a distance function for the dashes
    float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;
    // Combine this distance function with the line's.
    dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);

    return dist;
}

// Function 1926
Intersect BezierLineIntersect(in vec2 ca, in vec2 cb, in vec2 cc, in vec2 cd, in vec2 la, in vec2 lb) {
    vec2 ba = lb - la;
    float baba = dot(ba, ba);
    vec2 ld = normalize(ba);

    mat2 invRot = mat2(ld, -ld.y, ld.x);
    mat2 rot = transpose(invRot);

    ca = (ca - la) * invRot;
    cb = (cb - la) * invRot;
    cc = (cc - la) * invRot;
    cd = (cd - la) * invRot;

    float coeff1 = 3.0 * cb.y - 3.0 * cc.y - ca.y + cd.y;
    float coeff2 = 3.0 * ca.y - 6.0 * cb.y + 3.0 * cc.y;
    float coeff3 = 3.0 * cb.y - 3.0 * ca.y;
    float coeff4 = ca.y;

    vec3 t;
    int nroots = solveCubic(coeff1, coeff2, coeff3, coeff4, t);

    vec2[3] intersects;
    int count = 0;
    for (int n=0; n < nroots; n++) {
        if (abs(t[n] - 0.5) <= 0.5) {
            vec2 p = BezierCurvePoint(ca, cb, cc, cd, t[n]) * rot;
            if (abs(dot(p, ba) / baba - 0.5) <= 0.5) {
                intersects[count] = p + la;
                count++;
            }
        }
    }

    return Intersect(count, intersects);
}

// Function 1927
vec3 drawLine(vec2 p1, vec2 p2, vec2 pos, vec3 color, float w)
{
    float v = dot(p1-pos, (p1.yx-p2.yx)*vec2(1., -1.));
    v = dot(p1 - pos, p2 - p1)<0.?v:2.*w;
    v = dot(p2 - pos, p2 - p1)>0.?v:2.*w;
    float w2 = w*distance(p1, p2);
    return mix(color, vec3(0), smoothstep(w2, w2+0.0005, abs(v)));
}

// Function 1928
float DistToLine(vec2 p, vec2 a, vec2 b)
{
        vec2 pa = p - a;
        vec2 ba = b - a;
        
        float frac = saturate(dot(pa, ba) / dot(ba, ba));
        
        return length(pa - (ba * frac));
}

// Function 1929
void draw(float d, inout vec4 O) 
{
    float s = sign(d);
    d = min(sqrt(abs(d*contrast)),1.);             // optimization by deferring sqrt here
    if (fill>0.) { if (s<0.) O = mix(O, COL, d); } // paint inside only
        else                 O = mix(COL, O, d);
}

// Function 1930
vec3 GetSunLightDirection()
{
    return normalize(vec3(0.3, 1.0, 1.65));
}

// Function 1931
float SDFLine( in vec2 coords )
{
    float v = coords.x * 2.0 - coords.y;
    vec2  g = vec2(2.0,-1.0);
    return abs(v)/length(g);
}

// Function 1932
float dfLine(vec2 p0, vec2 p1, vec2 p)
{  
	vec2 line = p1 - p0;
	float frac = dot(p - p0,line) / dot(line,line);
	return distance(p0 + line * clamp(frac, 0.0, 1.0), p);
}

// Function 1933
vec4 GetDirectionalLightRotationAxisAngle ()
{
    // mode >= 5.0 starts moving and rotating light source
    float time = GetMode() - 5.0;
    time = max(time, 0.0);
    
    vec4 ret = directionalLightRotationAxisAngle;
    ret.xyz += vec3(sin(time * 0.1), sin(time * 0.7), sin(time * 0.3));
    ret.xyz = normalize(ret.xyz);
    ret.w += time * 0.66;
        
    return ret;
}

// Function 1934
float line(vec2 p, vec2 a, vec2 b, float thickness )
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
	return 1.0 - smoothstep(thickness * 0.8, thickness * 1.2, length(pa - ba * h));
}

// Function 1935
vec3 linear_2_cineon_log(in vec3 color)
{
	return ((log10(color.xyz * (1.0 - 0.0108) + 0.0108) * 300.0) + 685.0) / 1023.0;
}

// Function 1936
float UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab
    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)
    //The clamp provides the line seg limits. e is therefore the "capped orthogogal projection", and length(p-e) is dist.
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 1937
void drawPoint(in vec2 x, in vec3 p) {
	inkDist = min(inkDist, (length(x-p.xy)-pointSize)/p.z);
}

// Function 1938
vec2 rectvoronoi(in vec3 x, mat3 d, vec4 s) {
    ivec3 p = ivec3(floor( x ));
    vec3 f = fract( x );

    ivec3 mb;
    vec3 mr;
    float id = 1.0e20;
    const int range = 3;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = ivec3( i, j, k );
        vec3 B = vec3(p + b);
        vec3 rv = rand3(B, d, s );
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = length( r );

        if(dis < id) {
            mb = b;
            mr = r;
            id = dis;
        }
    }
    float bd = 1.0e20;
    for( int k=-VORORANGE; k<=VORORANGE; k++ )
    for( int j=-VORORANGE; j<=VORORANGE; j++ )
    for( int i=-VORORANGE; i<=VORORANGE; i++ )
    {
        ivec3 b = mb + ivec3( i, j, k );
        vec3 B = vec3(p + b);
        vec3 rv = rand3(B, d, s );
        //vec3 rv = RAND(B, 0.0, 1.0, s);
        vec3 r = vec3(b) - f + rv;
        float dis = dot( 0.5*(mr+r), normalize(r-mr) );

        bd = min(bd, dis);
    }
    return vec2(id, bd);
}

// Function 1939
vec3 linearTosRGB(vec3 c)
{
    float a = 0.055;
    return mix(12.92 * c, (1.0 + a) * pow(c, vec3(1.0 / 2.4)) - a, step(0.00313008, c));
}

// Function 1940
void drawGame3D( inout vec4 color, vec2 uv, AppState s )
{   
    vec2 mo = iMouse.xy / iResolution.xy;
   
    vec2 bent = getBent();

    float fbm = fbm3( vec3( 1000.0 * iTime ) );
    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );
    // camera	    
    float roll = -0.1 * bent.x;
    float arm = 3.5 + 0.2 * s.paceScale;
    float angleH = -0.5 * PI + 0.1 * bent.x;
    float height = 1.2 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;
    float fov = 2.0 - 0.5 * s.paceScale;
    
    vec3 ro = vec3( 0.0 );
    
    if ( s.timeFailed > 0.0 )
    {
        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );
        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );
        angleH += iTime - s.timeFailed;
    }
    
    if ( s.stateID == GS_SPLASH )
    {
        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;
        roll = -0.1 * ( mo.x - 0.5 );
        angleH += 0.5 * ( mo.x - 0.5 );
        height += 0.5 * (mo.y - 0.5 );                
    }
    
    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );
    
#ifdef DEBUG_CAMERA    
    roll = 0.0;
    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );
#endif        
    
    vec3 ta = vec3(
        0.0, 
        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),
        0.0
    );

#ifdef CAM_STICKED    
    ro.x += s.playerPos.x;
    ta.x += s.playerPos.x;
#endif    
    
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, roll );
   
    // ray direction
    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );
    
    // render	
    vec4 col = render( ro, rd );
       
    color = col;
}

// Function 1941
vec3 linearLight(in vec3 src, in vec3 dst)
{
    return clamp(2.0 * src + dst - 1.0, 0.0, 1.0);;
}

// Function 1942
v3 linearGraph(v1 u,v0 h,v0 g){
  d d=getd(u.x);
  //float div=sqrt(1.+p.y*p.y);
  v0 r=abs(d.x-u.y)/(sqrt(1.+d.d*d.d))-thick;    
  d=getd(u.x);
  //no analytical 2nd derivative, so this one sucks a bit
  v0 b=abs(d.d-u.y)/(sqrt(1.+d.d*d.d))-thick;
  //this does not work for scaled p, is far from being user friendly
  v0 blur=20./max(iResolution.y,1.);
  v3 yellow =v3(v2(1,1,0),ssb(r));
  v3 cyan   =v3(v2(0,1,1),ssb(g));
  v3 magenta=v3(v2(1,0,1),ssb(b));
  return aOverB(aOverB(yellow,magenta),cyan);
 }

// Function 1943
float FindClosestPointOnSplineToPoint( Spline sp, vec3 p)
{
	//start by finding roots of 2nd derivative of degree 6 Distance function ... solve quartic!

	FactorsOfP fp;
	InitFactorsOfP(fp, sp, p);
	
	vec4 abcd = GetNormalizedQuarticConstants(sp, fp, p);
	vec4 roots = vec4(1.);
	int root_count = quartic_descartes(abcd.x, abcd.y, abcd.z, abcd.w, roots);
	
	//apparently returns stilly stuff in spaces >= root count so reset to something that will sort to the end!
	for (int i=0; i<4; i++)
		roots[i] = (i<root_count)?roots[i] : 1.;

	vec4 sorted_roots = Sort(roots);

	//start with distance to the first endpoint, then try and do better
	float t = 0.;
	float end0_dist = LengthSquared(sp.endpoint0-p);
	float best_dist = end0_dist;	
	float prev_root = 0.0;
	float prev_first_deriv = DistanceSqFirstDeriv(sp, fp, p, prev_root);
	float prev_dist = end0_dist;
//	for (int root=0; root<root_count+1; root++)
	for (int root=0; root<5; root++)
	{
		if (root >= root_count+1) break;
		
//		float next_root = (root < root_count) ? min(sorted_roots[root],1.0) : 1.0;
		float next_root = (root < root_count) ? sorted_roots[root] : 1.0;
		if (next_root > 0.0)
		{
			//may as well test this point seeing as we went to the trouble of evaluating it... 
			//also handles the case of the end of the parameter range
			float next_dist = DistSq(sp.MG, next_root, p );
			if (next_dist < best_dist)
			{
				best_dist = next_dist;
				t = next_root; 
			}

			//if there was a sign change in this bracket, it might be worth testing
			float next_first_deriv = DistanceSqFirstDeriv(sp, fp, p, next_root);
			if (prev_first_deriv*next_first_deriv < 0.)
			{
				float bisect_parameter = BisectSpline(sp, fp, p, prev_root, next_root, prev_first_deriv );
				float newton_parameter = NewtonSpline(sp, fp, p, bisect_parameter );

				//might be a decent root!
		//		if (prev_root < newton_parameter && newton_parameter < next_root)
				{
					float newton_dist = DistSq(sp.MG, newton_parameter, p );
					if (newton_dist < best_dist)
					{
						best_dist = newton_dist;
						t = newton_parameter;
					}
				}
		/*		else //if (prev_root < bisect_parameter && bisect_parameter < next_root)
				{
					//fall back to bisected one if newton exploded or something.
					float minimized_dist = DistSq(sp.MG, bisect_parameter, p );
					if (minimized_dist < best_dist)
					{
						best_dist = minimized_dist;
						t = bisect_parameter;
					}
				} */				
			}

			prev_first_deriv = next_first_deriv;
			prev_dist = next_dist;
			prev_root = next_root;
		}
	}
			
	return t;
}

// Function 1944
float direction(vec2 uv) {
	float a = atan(uv.x,uv.y)/radians(360.0);
	a += 0.5;
	return a*360.0;
}

// Function 1945
bool RectShiftLeftContains(Rect rect, vec2 pos, float eyeWidth)
{
    float shift = (eyeWidth - rect.z) / iResolution.x;
    return (rect.x - shift <= pos.x && pos.x < rect.x + rect.w &&
            rect.y <= pos.y && pos.y < rect.y + rect.h);
}

// Function 1946
void drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)
{
    // samples the function around x neighborhood to get distance to curve
    float hlw = CURVE_WIDTH * pp * 0.5;
    
    // cover line width and aa
    float left = xy.x - hlw - pp * AA_FALLOFF;
    float right = xy.x + hlw + pp * AA_FALLOFF;
    float closest = 100000.0;
    for (float x = left; x <= right; x+= pp * FUNC_SAMPLE_STEP)
    {
        vec2 diff = vec2(x, func(x)) - xy;
        float dSqr = dot(diff, diff);
        closest = min(dSqr, closest);
    }
    
	float c = 1.0 - aaStep(0.0, hlw + pp * AA_FALLOFF, sqrt(closest));
	blend(baseCol, curveCol, c * c * c);
}

// Function 1947
vec3 BSplineQuadraticWeights(float f){
    float ff = f*f;
	float w0 = 0.5f*(ff - 2.f*f + 1.f);			//starts at 0.5, and decreases
	float w1 = 0.5f*(-2.f*ff + 2.f*f + 1.f);	//starts at 0.5, increase until midpoint, then decreases
	float w2 = ff * 0.5f;						//starts at 0, grows as f increase 
    return vec3(w0,w1,w2);
}

// Function 1948
void DrawKoopa( inout vec3 color, float x, float y, float frame )
{
    if ( x >= 0.0 && x <= 15.0 )
    {
        SpriteKoopa( color, x, y, frame );
    }
}

// Function 1949
float LineDist(vec3 a, vec3 b, vec3 p) {
	return length(cross(b-a, p-a))/length(p-a);
}

// Function 1950
void draw(vec2 uv, vec2 distAndMaterial, inout vec4 fragColor)
{
    float dist = distAndMaterial.x;
    int material = int(distAndMaterial.y);
    float distanceChange = fwidth(dist) * 0.5;
    
    const float[27] distanceChangeStops = float[27](0.004, 0.0, 0.004, 0.015, 0.015, 0.004, 0.0, 0.0015, 0.001, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.0, 0.004, 0.0, 0.004, 0.004, 0.0, 0.006, 0.0, 0.0, 0.0, 1.);
	float uWotM8 = distanceChangeStops[material];
    if(material == 26) {
        fragColor = mix(fragColor, mixColors[material], blurMask(distanceChange, dist, uWotM8));
    } else if(uWotM8!=0.0)
    {
        uWotM8 = outerMask(distanceChange, dist, uWotM8);
        if(material == 3 || material == 4) {
	    	fragColor = mix(fragColor, vec4(1,0,0,1), uWotM8);
        } else {
	    	fragColor = mix(fragColor, vec4(0,0,0,1), uWotM8);
        }
    }
    fragColor = mix(fragColor, mixColors[material], fillMask(distanceChange, dist));
}

// Function 1951
v0 circleY(v1 u){return u.y-sqrt(1.-(u.x*u.x));}

// Function 1952
vec3 drawCircle(in vec2 xy){
    float l=length(xy);
    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);
}

// Function 1953
float line(vec2 uv, vec2 p1, vec2 p2){
    vec2 dir = normalize(p2-p1);
    mat2 inv = mat2(dir.x,-dir.y,dir.y,dir.x);
    uv=inv*(uv-p1);
	p2=inv*(p2-p1);
    return float(abs(uv.y)<0.004&&0.<uv.x&&uv.x<p2.x);
}

// Function 1954
float drawScene(vec3 p)
{	int id;
    return drawScene(p,id);
}

// Function 1955
float sdCircle(vec2 p, float r) {
	return length(p) - r;
}

// Function 1956
float Circle(vec2 p)
{
	float z = sqrt(p.x*p.x + p.y*p.y) - 6.0;
	
	return z;
}

// Function 1957
float drawFloat(inout vec2 p,v0 v,int q,int m){float c=0.;
 p.x-=float(m);
 if (v<0.){c=char(p,45);v=-v;}p.x-=1.; //write "-"
 c+=drawInt(p,int(v),1);    //write floor()                                           
 c+=char(p,46);p.x-=1.;      //write "."
 c+=drawFract(p,0,fract(v));//write fract() 
 return c;}

// Function 1958
vec3 drawLine(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, vec3 oldColor)
{
    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);
    d /= length(p2 - p1);
    d = clamp(step(0.0, d) * d, 0.0, 1.0);
    d = distance(p1 + d * (p2 - p1), coord);
    
    float dst = smoothstep(thickness - length(fwidth(coord)), thickness, d);

    return mix(col, oldColor, dst);
}

// Function 1959
vec4 draw_enemy( int t, int frame, ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), enemy_dim ) ) {
        int x = iu.x, y = iu.y ;
        x += 12 * (frame & 1) ;
        PREPARE_TEST_BIT ;
        if( t == 2 ) {
            BR24(7,   _,_,_,_,_,w,w,_,_,_,_,_  ,  _,_,_,_,_,w,w,_,_,_,_,_  ) ;
            BR24(6,   _,_,_,_,w,w,w,w,_,_,_,_  ,  _,_,_,_,w,w,w,w,_,_,_,_  ) ;
            BR24(5,   _,_,_,w,w,w,w,w,w,_,_,_  ,  _,_,_,w,w,w,w,w,w,_,_,_  ) ;
            BR24(4,   _,_,w,w,_,w,w,_,w,w,_,_  ,  _,_,w,w,_,w,w,_,w,w,_,_  ) ;
            BR24(3,   _,_,w,w,w,w,w,w,w,w,_,_  ,  _,_,w,w,w,w,w,w,w,w,_,_  ) ;
            BR24(2,   _,_,_,w,_,w,w,_,w,_,_,_  ,  _,_,_,_,w,_,_,w,_,_,_,_  ) ;
            BR24(1,   _,_,w,_,_,_,_,_,_,w,_,_  ,  _,_,_,w,_,w,w,_,w,_,_,_  ) ;
            BR24(0,   _,_,_,w,_,_,_,_,w,_,_,_  ,  _,_,w,_,w,_,_,w,_,w,_,_  ) ;
        } else if( t == 1 ) {
            BR24(7,   _,_,_,w,_,_,_,_,_,w,_,_  ,  _,_,_,w,_,_,_,_,_,w,_,_  ) ;
            BR24(6,   _,_,_,_,w,_,_,_,w,_,_,_  ,  _,w,_,_,w,_,_,_,w,_,_,w  ) ;
            BR24(5,   _,_,_,w,w,w,w,w,w,w,_,_  ,  _,w,_,w,w,w,w,w,w,w,_,w  ) ;
            BR24(4,   _,_,w,w,_,w,w,w,_,w,w,_  ,  _,w,w,w,_,w,w,w,_,w,w,w  ) ;
            BR24(3,   _,w,w,w,w,w,w,w,w,w,w,w  ,  _,w,w,w,w,w,w,w,w,w,w,w  ) ;
            BR24(2,   _,w,_,w,w,w,w,w,w,w,_,w  ,  _,_,w,w,w,w,w,w,w,w,w,_  ) ;
            BR24(1,   _,w,_,w,_,_,_,_,_,w,_,w  ,  _,_,_,w,_,_,_,_,_,w,_,_  ) ;
            BR24(0,   _,_,_,_,w,w,_,w,w,_,_,_  ,  _,_,w,_,_,_,_,_,_,_,w,_  ) ;
        } else if( t == 0 ) {
            BR24(7,   _,_,_,_,w,w,w,w,_,_,_,_  ,  _,_,_,_,w,w,w,w,_,_,_,_  ) ;
            BR24(6,   _,w,w,w,w,w,w,w,w,w,w,_  ,  _,w,w,w,w,w,w,w,w,w,w,_  ) ;
            BR24(5,   w,w,w,w,w,w,w,w,w,w,w,w  ,  w,w,w,w,w,w,w,w,w,w,w,w  ) ;
            BR24(4,   w,w,w,_,_,w,w,_,_,w,w,w  ,  w,w,w,_,_,w,w,_,_,w,w,w  ) ;
            BR24(3,   w,w,w,w,w,w,w,w,w,w,w,w  ,  w,w,w,w,w,w,w,w,w,w,w,w  ) ;
            BR24(2,   _,_,w,w,w,_,_,w,w,w,_,_  ,  _,_,_,w,w,_,_,w,w,_,_,_  ) ;
            BR24(1,   _,w,w,_,_,w,w,_,_,w,w,_  ,  _,_,w,w,_,w,w,_,w,w,_,_  ) ;
            BR24(0,   _,_,w,w,_,_,_,_,w,w,_,_  ,  w,w,_,_,_,_,_,_,_,_,w,w  ) ;
        }
    }
    return( vec4( v, 1 ) ) ;
}

// Function 1960
float drawFract(int digits, float fn) 
{ 
  float c = 0.0; 
  fn = fract(fn) * 10.0; 
  for (int i = 1; i < 60; i++) 
  {
    c += char(48 + int(fn)); // add 0..9
    tp.x -= FONT_SPACE; 
    digits -= 1; 
    fn = fract(fn) * 10.0; 
    if (digits <= 0 || fn == 0.0) break; 
  } 
  tp.x -= FONT_SPACE*float(digits); 
  return c; 
}

// Function 1961
void set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {
    vec2 pa = _stack.position.xy - p0;
    vec2 ba = p1 - p0;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    set_source_rgba(mix(color0, color1, h));
}

// Function 1962
float sdRect(vec2 s, vec2 uv)
{
    uv = abs(uv) - s;
	return max(uv.x, uv.y);
}

// Function 1963
float line(vec2 st, vec2 a, vec2 b, float w)
{
    vec2 ab = b - a;
    vec2 toSt = st - a;
    float t = clamp(dot(ab, toSt) / dot(ab, ab), 0., 1.);
    float d = length(st - a - ab * t);
    return step(d, w);
}

// Function 1964
float Line(const float y, const float repeat, const float thickness, const float smoothness)
{
    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(repeat * 0.5 - mod(y, repeat)));
}

// Function 1965
float sdRect(vec2 uv, vec2 a, vec2 b, float angle)
{
    // flatten the line to be axis-aligned.
    vec2 rectDimensions = b - a;
    mat2 rotMat = rot2D(-angle);
    a *= rotMat;
    b *= rotMat;
	return sdAxisAlignedRect(uv * rotMat, a, b);
}

// Function 1966
float pirateLines(vec2 u,float t,vec4 m//paints sheet lines
){float c=0.,sy=(m.y-.02)*2.
 ;t=t*6.94+35.*(u.x-.5)
 ;c+=banj4(t,vec2(0,u.y),vec4( 0, 1, 2, 3)*sy,F21 ,G21,A21 ,As21)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4( 4, 5, 6, 7)*sy,B21 ,C31,Cs31,D31)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4( 8, 9,10,11)*sy,E31 ,F31,G31 ,A31)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4(12,13,14,15)*sy,As31,C41,Cs41,D41)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4(16,17,18,19)*sy,E41 ,F41,G41 ,A41)//vec4 is position.y
 ;c+=banj4(t,vec2(0,u.y),vec4(20,20,21,21)*sy,As41,As41,C51,C51)*.5//vec4 is position.y
 ;//last one doubled and then halved, cause i am too lazy to define a fun that takes only 2...
  //oh shit the key-labels are off by one, shit a semitone, but off by one label.
 ;return c;}

// Function 1967
float drawLine3D (int vert1, int vert2, float inv, vec3 camRay)
{
    vec3 i = vec3(1, 1., inv);
    float line = 0.;
    
    float d = 0.007 * distance(mesh[vert1], mesh[vert2]); // modulate by dist
    float a = 1. + dot ( cross(CamLoc-mesh[vert1]*i, CamLoc-mesh[vert2]*i), camRay );
    line += floor( d + a ) - floor ( a - d );
    
    float circle = floor( 1.- 0.01 * dot( cross(CamLoc-mesh[vert1]*i, camRay), cross(CamLoc-mesh[vert2]*i, camRay) ));
    line *= circle;
    
    return line;
}

// Function 1968
float DrawFish(float id, fishType fish, float time) 
{
  float angle = atan(fish.velocity.y, fish.velocity.x);
  float ca = cos(angle);
  float sa = sin(angle);
  vec2 pos = vec2(fish.position)*20.0 * mat2(ca, sa, -sa, ca); // rotate and rescale

  // swiming ondulation (+rotate in Z axes)  
  pos.x *= 0.97 + (0.1+.2*pos.y)*cos(id+9.*time); 
  float l1 = length(pos - vec2( 0.80,0)) -0.45;  // fin 
  float l2 = length(pos - vec2(-0.14,0)) -0.12;  // eye
  float ds = min(l1, l2);           // distance to fish
  pos.y = abs(pos.y) + 0.13;        // fish height
  l1 = length(pos - vec2(0.56,0));  // fin move
  return max(min(length(pos),l1)-0.3,-ds)*0.05; // mix colors
}

// Function 1969
vec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)
{
    float q = length(p2-p1);
    vec2 m = (p1+p2)/2.0;
    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,
                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);
    return  vec4(m+d, m-d);
}

// Function 1970
vec2 Circle(float Start, float Points, float Point) 
{
	float Rad = (3.141592 * 2.0 * (1.0 / Points)) * (Point + Start);
	return vec2(sin(Rad), cos(Rad));
}

// Function 1971
bool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)
{
    vec2 n = lineB - lineA;
    n = vec2(n.y,-n.x);
    return  dot(pointA-lineA,n)
          * dot(pointB-lineA,n)
    > 0.0;
}

// Function 1972
float scanLines(vec2 uv){
  float dy = uv.y * FAKE_RES.y;
  dy = fract(dy) - 0.5;
  return exp2(-dy*dy*scanIntensity);
}

// Function 1973
vec3 gamma_adjust_linear( vec3 rgbIn, float GAMMA, float PIVOT)
{
float SCALAR = PIVOT / pow( PIVOT, GAMMA);
vec3 rgbOut = rgbIn;
if (rgbIn.x > 0.0) rgbOut.x = pow( rgbIn.x, GAMMA) * SCALAR;
if (rgbIn.y > 0.0) rgbOut.y = pow( rgbIn.y, GAMMA) * SCALAR;
if (rgbIn.z > 0.0) rgbOut.z = pow( rgbIn.z, GAMMA) * SCALAR;
return rgbOut;
}

// Function 1974
float onCircle( const vec2 c, const vec2 centre, const float radius ) {
	return clamp( 4.*(radius - distance(c,centre)), 0., 1. );
}

// Function 1975
float circleSW(vec2 q, vec2 pos ) {
    vec2 p = q - pos;
    
    if(p.x < 0.0 && p.y < 0.0) {
        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;
    } else {
        return 10.0;
    }
}

// Function 1976
float drawFract(int d,float f){float c=0.;f=fract(f)*10.; 
 for(int i=1;i<60;i++){c+=char(48+int(f));tpm; 
  d--;f=fract(f)*10.;if(d<=0||f==0.) break;
 }tpp*float(d);return c;}

// Function 1977
void closestLineLine(vec3 p00, vec3 p01, vec3 p10, vec3 p11, out vec3 out0, out vec3 out1) {
    vec3   u = p01 - p00, v = p11 - p10, w = p00 - p10;
    float  a = dot(u,u), b = dot(u,v), c = dot(v,v),
           k0, k1, k = a*c - b*b;
    if (k < 1e-5) { // the lines are almost parallel return centers
        k0 = k1 = .5; // Not good 
    } else {
        float e = dot(v,w), d = dot(u,w); 
        k1 = (a*e - b*d)/k;
        k0 = (b*e - c*d)/k;
    }
    out0 = p00 + u * k0;
    out1 = p10 + v * k1;
}

// Function 1978
bool insideCircle(vec2 P, vec3 center, float rad) 
{
    float d1 = (P.x - center.x) * (P.x - center.x);
    float d2 = (P.y - center.y) * (P.y - center.y);
    return d1 + d2 < rad*rad;
}

// Function 1979
vec4 drawDot(vec2 pos,float r, vec2 fragCoord)
{
    return vec4(clamp(r-length(pos-fragCoord),0.,1.)/r*3.);
}

// Function 1980
vec3 LinearSample0(vec2 uv, out float coeff, out vec3 Moments, vec3 CN) {
    vec4 Attr=texture(iChannel2,uv+vec2(0.5,0.));
    if (Attr.w>9999. || BoxC2(uv-0.25,vec2(0.25))>0.) {coeff=0.001; Moments=vec3(0.); return vec3(0.); }
    coeff=max(0.001,dot(CN,Read(Attr.z).xyz*2.-1.));
    Moments=Read(Attr.y).xyz*coeff;
    return Read3(Attr.x)*coeff;
}

// Function 1981
float circles(vec2 uv, float r){
    // Position of point assuming center is (.5,.5)
    vec2 pos = vec2(0.5)-fract(uv);
    
    // Find squared distance from origin
    float lineLength = distance(pos, vec2(0.));
    return 1.-step(r, lineLength);
}

// Function 1982
float Circle(vec2 p, float r)
{
    float ret = length(p)-r;    return ret;
}

// Function 1983
void drawUI( inout vec4 c, sampler2D iChannelFont, sampler2D iChannel0, vec2 fragCoord, vec2 iResolution, vec4 iMouse){
    vec2 uv = fragCoord / iResolution.xy;
    vec2 a = vec2( iResolution.x/ iResolution.y, 1.);
    vec2 p = (uv-.5)*a;
    for (int i = 0 ; i < componentsLength; i++)
    {
        Component comp = components[i];
        // switch(comp.type)  // removed to compatibility but losing performance
        {
            //case TYPE_CHECKBOX:
            if (comp.type == TYPE_CHECKBOX)
            {
                drawCheckbox(c, p, comp.positionSize.xy, float(comp.value));
            	drawText(c, p, comp.positionSize.xy+vec2(0.08,0.), .8, comp.textHexStr, vec4(0.)); 
            }
            if (comp.type == TYPE_BUTTON)
            {
                drawButton(c, p, comp.positionSize, float(comp.value));
                drawText( c, p, comp.positionSize.xy+vec2(0.01,0.)-comp.positionSize.zw, 1., comp.textHexStr, vec4(0.)); 
            }
            if (comp.type == TYPE_LABEL)
            {
            	drawText( c, p, comp.positionSize.xy+vec2(0.01,0.), comp.positionSize.z, comp.textHexStr, comp.color); 
            }
            if (comp.type == TYPE_LABEL_NUMBER)
            {
                float len = drawText(c, p, 1.*comp.positionSize.xy+vec2(0.01,0.), comp.positionSize.z, comp.textHexStr, comp.color); 
                drawTextNumber( c, p, 1.*comp.positionSize.xy+vec2(0.01+len*.04*comp.positionSize.z,0.), comp.positionSize.z, comp.value.x, comp.color);
            }
        }
    }
}

// Function 1984
vec3 DrawFBM(vec2 uv){
	uv*=4.;
	float val = (FBM(uv)+1.0)*0.5;
	return vec3(val,val,val);
}

// Function 1985
float segmented_spline_c5_fwd( float x) {
SegmentedSplineParams_c5 C = RRT_PARAMS();
const int N_KNOTS_LOW = 4;
const int N_KNOTS_HIGH = 4;
float X = max(x, 0.0);
float logx = log10(X);
float coefsLow[6];
coefsLow[0] = C.coefsLow.a;coefsLow[1] = C.coefsLow.b;coefsLow[2] = C.coefsLow.c;
coefsLow[3] = C.coefsLow.d;coefsLow[4] = C.coefsLow.e;coefsLow[5] = C.coefsLow.f;
float coefsHigh[6];
coefsHigh[0] = C.coefsHigh.a;coefsHigh[1] = C.coefsHigh.b;coefsHigh[2] = C.coefsHigh.c;
coefsHigh[3] = C.coefsHigh.d;coefsHigh[4] = C.coefsHigh.e;coefsHigh[5] = C.coefsHigh.f;
float logy;
if ( logx <= log10(C.minPoint.x) ) { 
logy = logx * C.slopeLow + (log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );
} else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) )) {
float knot_coord = float(N_KNOTS_LOW - 1) * (logx - log10(C.minPoint.x))/(log10(C.midPoint.x) - log10(C.minPoint.x));
int j = int(knot_coord);
float t = knot_coord - float(j);
vec3 cf;
data6[0] = coefsLow[0];data6[1] = coefsLow[1];data6[2] = coefsLow[2];
data6[3] = coefsLow[3];data6[4] = coefsLow[4];data6[5] = coefsLow[5];
cf.x = getData6(j); cf.y = getData6(j + 1); cf.z = getData6(j + 2);
vec3 monomials = vec3( t * t, t, 1.0 );
logy = dot( monomials, cf * transpose(MM));
} else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) )) {
float knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x) - log10(C.midPoint.x));
int j = int(knot_coord);
float t = knot_coord - float(j);
vec3 cf;
data6[0] = coefsHigh[0];data6[1] = coefsHigh[1];data6[2] = coefsHigh[2];
data6[3] = coefsHigh[3];data6[4] = coefsHigh[4];data6[5] = coefsHigh[5];
cf.x = getData6(j); cf.y = getData6(j + 1); cf.z = getData6(j + 2); 
vec3 monomials = vec3(t * t, t, 1.0);
logy = dot( monomials, cf * transpose(MM));
} else {
logy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );
}
return pow(10.0, logy);
}

// Function 1986
float sd_line(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 1987
float drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )
{
    uv-=pos;
    uv /= size;
    float res;
    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));
    uv *= MAP_SIZE;
    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );
    return clamp(res,0.0,1.0);
}

// Function 1988
bool drawCircle(vec2 uv, vec2 pos) {
    vec2 diff = uv - pos;
    if (length(diff) < 0.2f) {
    	return true;
    }
    return false;
}

// Function 1989
vec3 segmented_spline_c9_rev_f3( vec3 rgbPre) {
SegmentedSplineParams_c9 C = ODT_48nits();
vec3 rgbPost;
rgbPost.x = segmented_spline_c9_rev( rgbPre.x, C);
rgbPost.y = segmented_spline_c9_rev( rgbPre.y, C);
rgbPost.z = segmented_spline_c9_rev( rgbPre.z, C);
return rgbPost;
}

// Function 1990
vec3 linear_srgb(vec3 x) {
    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));
}

// Function 1991
vec4 drawCellWall(ivec4 state, mat4x3 colors, ivec2 coord)
{
    Sprite sprite = getSpriteWall();
    return sampleSprite(sprite, colors, coord);
}

// Function 1992
void drawLine(ivec2 c, ivec2 cCurr, int o, inout int v, int length, int dir)
{
    for (int i=1; i<=length; i++) {
        storeObject(c, cCurr, o, v);
        c += LINE_DIRS[dir];
    }
}

// Function 1993
vec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )
{
  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
  
  return colOut;
}

// Function 1994
void drawLight2(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 l2Norm;
    float light2T = traceSphere(ray.pos - LIGHT2_POS, ray.dir, 
                                        LIGHT2_RADIUS, l2Norm);
    
    if(light2T < cur_ctxt.t)
    {
        cur_ctxt.t=light2T;

        cur_ctxt.materialType = EMISSION;
        cur_ctxt.color=LIGHT2_COLOR;
        cur_ctxt.n = l2Norm;
        cur_ctxt.alpha = 0.0;
    }
}

// Function 1995
vec4 DrawtexturedUVQuad(vec2 a, vec2 b, vec2 c, vec2 d,vec2 uva, vec2 uvb, vec2 uvc, vec2 uvd, float t, vec2 co, sampler2D s){
    float i = DrawQuad(a,b,c,d,t,co);
    if (i<=0.) return vec4(0.);
    vec3 baria = toBari(a,b,c,co);
    vec3 barib = toBari(a,d,c,co);
    vec3 baric = toBari(b,c,d,co);
    vec3 barid = toBari(b,a,d,co);
    vec2 coord = vec2(0.);
    coord+= toCartesian(uvb,uvc,uvd,baric);
    coord+= toCartesian(uvb,uva,uvd,barid);
    coord+= toCartesian(uva,uvb,uvc,baria);
    coord+= toCartesian(uva,uvd,uvc,barib);
    
    return texture(s,coord/4.)*i;
}

// Function 1996
vec3 EvaluateRandomSpline(vec2 origin, vec2 vel, vec2 p, int curveIndex, float time)
{
    float t = time * .75;
    
    vec3 dir = vec3(vel, 0.0) * 2.;
    vec3 up = vec3(-vel.y, vel.x, 0.0) * 2.;
    
    vec2 rand = R2seq(curveIndex*123) * 2.0 - 1.0;
    vec2 rand2 = R2seq(curveIndex*23) * 2.0 - 1.0;
    
    rand *= sin(float(curveIndex) * 1.41234);
    rand2 *= cos(float(curveIndex) * 5.41234);
    
    float offset = float(curveIndex) * (.1 + cos(time+float(curveIndex))*.1+.1);
    float tt = time * .1 + offset;
    vec3 target = vec3(cos(tt), sin(tt), 0.0);
        
    vec3 A = vec3(origin, 0.0);
    vec3 B = A + dir * rand.x * .85 * cos(t + p.r) + up * rand2.x * .5 * sin(t);
    vec3 C = A - dir * rand.y * .5 * cos(t) + up * rand2.y * .5;
    C *= 3.0 * target + cos(t + rand.x) * .25 + .5;
    
    B += A * .7 * rand2.y;
    C += A * .5 * rand2.x;    
    
	CurveSDFSample result = sdBezier(A, B, C, vec3(p, 0.0));
    float sdf = result.d;

    float distToOrigin = length(p - origin);
    
    float thickness = smoothstep(.5, .0, distToOrigin);
    thickness *= thickness;
    
    float hueOffset = float(curveIndex) * .2;
    
    float mask = smoothstep(.05 + cos(result.t) * 1.5 * sdf, .0, sdf);
    mask *= mask * mask * mask;    
    
    vec3 color = hsv2rgb_p(vec3(hueOffset + distToOrigin * .8 - t * .9 + rand.x * 2.1235, .2 + cos(result.t) * .5, mask * .7));
    
    float glow = smoothstep(.9, -.1, result.d*result.d) * .05;
    color += .45 * hsv2rgb_p(vec3(distToOrigin * .4 - t * .4 + rand.x * 2.1235, 1.0, glow));    
    return color;
}

// Function 1997
float line(in vec2 p, in vec2 p1, in vec2 p2, float width) {
  vec2 d0 = p2 - p1;
  vec2 d1 = p - p1;
  return length(d1 - d0 * clamp(dot(d0, d1) / dot(d0, d0), 0., 1.)) * (1./width*8.);
}

// Function 1998
float udf_line1(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel/point!
    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B
    // The vector-projection of vector X to vector Y is a scalar multiple of vector Y.
    vec2 vector_projection_AP_AB = dvec_AB * (dot(dvec_AP, dvec_AB) / dot(dvec_AB, dvec_AB));  // So, this is a scalar multiple of dvec_AB
    return distance(uv, vector_projection_AP_AB);  // This is the (unsigned) distance!
}

// Function 1999
vec3 linearBurnMode  (vec3 colorA, vec3 colorB)
{
    vec3 rgb = colorB + colorA -1.0;
    return rgb;
}

// Function 2000
void draw_color_icon(vec2 p, float sz, int i, bool enable, inout vec3 color) {
    
    const float k = 0.8660254037844387;
    
    mat2 R = mat2(-0.5, k, -k, -0.5);
    
    vec2 p1 = vec2(k*sz, 0);
    vec2 p2 = vec2(0, 0.5*sz);
    
    mat3 colors;
    
    if (i == 0) {
        colors = mat3(vec3(1, 0, 0),
                      vec3(1, 1, 0),
                      vec3(0, 0, 1));
    } else {
        colors = mat3(vec3(0.6, 0, 0.6),
                      vec3(0.7, 0.4, 0.7),
                      vec3(0.1, 0.5, 0.5));
    }
    
    float ue = enable ? 1. : 0.3;
    float ds = 1e5;
    
    for (int j=0; j<3; ++j) {
        
        vec2 ap = vec2(abs(p.x), abs(p.y-0.5*sz));
        
        vec2 dls = dline_seg(ap, p2, p1);
        
        p = R*p;
        
        color = mix(color, colors[j], smoothstep(1.0, 0.0, -dls.x+0.5) * ue);
        ds = min(ds, dls.y);
    
    }

    color = mix(color, vec3(0), smoothstep(1.0, 0.0, ds-0.05*sz) * ue);
    
}

// Function 2001
vec3 samplerectBG (vec2 absuv, vec2 rectUV, float time)
{
    vec2 uvsize = (iResolution.xy / iResolution.x);
    vec2 uvsizeHalf = uvsize * 0.5;
    vec3 colourRect;
    
    // Prepare rect properties
    const float rectScrollPower = 3.0;
    vec2 rectUVOffset = vec2(pow(sin(time * 0.5), rectScrollPower) * 1.0, pow(cos(time * 0.25), rectScrollPower) * 4.0);
    rectUV += rectUVOffset; // / (rectHalfSize * 2.0);

    // Foreground : 10PRINT
    float naejangSDF = samplenaejang(vec3(rectUV, 0.0), time);
    vec3 naejangNormal = getnaejangnormal(rectUV, time); // vec3(clamp(getnaejangnormal(rectUV, time), -1.0, 1.0), 0.5);
	float naejangCenterMix = pow(1.0 - pow(1.0 - naejangSDF, 1.0), 4.0);//smoothstep(0.0, 0.75, naejangSDF - 0.1);
    naejangNormal.xy = mix(naejangNormal.xy, vec2(0.0), naejangCenterMix);
    naejangNormal.z = 1.0;//mix(0.0, 1.0, naejangCenterMix);
    
    // Calculate light
    vec3 viewVector = vec3(0.0, 0.0, 1.0);
    float lightTime = mod(time * 2.0, 6.254);
    vec3 lightPos = vec3(uvsizeHalf + vec2(cos(lightTime), sin(lightTime)) * (uvsizeHalf * 0.75), 1.0);
    vec3 lightDelta = lightPos - vec3(absuv, 0.05 + naejangSDF * 0.35);
    vec3 lightDir = normalize(lightDelta);
    float lightDist = length(lightDelta);
    
    // 1] albedo
    vec3 plasmacolour1 = hsv2rgb(vec3(fract(time * 0.2), 0.5, 1.0));
    vec3 plasmacolour2 = hsv2rgb(vec3(fract(1.0 - time * 0.2), 1.0, 0.5));
    
    vec3 diffuse = mix(plasmacolour2, plasmacolour1, naejangCenterMix);
    //colourRect = diffuse;
    
    // 2] lambert
    float lightAmbient = 0.5;
    float lightDot = dot(naejangNormal, lightDir);
    float lightDistRange = smoothstep(0.3, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));
    float lightLit = clamp((lightDot * lightDistRange + lightAmbient), 0.0, 1.0);
    colourRect = diffuse * lightLit;
    
    // 3] Blinn-phong specular reflection
    vec3 phongH = normalize(lightDelta + viewVector);
    float phongDistRange = naejangCenterMix * smoothstep(0.5, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));
    float phongDot = dot(naejangNormal, phongH);
    float phongClamped = clamp(phongDot, 0.0, 1.0);
    float phong = pow(phongClamped, 800.0);
    
    colourRect += vec3(phong * phongDistRange);
    
    return colourRect;
}

// Function 2002
vec3 GammaCorrect(vec3 color) 
{
    return pow(color, vec3(1.0/2.2));
}

// Function 2003
vec3 getInversionCircle(int i)
{
    float theta = pi / float(numCircles - 1);
    float r0 = tan(theta);
    float r1 = 1. / cos(theta);
    if(i == (numCircles - 1))
        return vec3(0., 0., r1 - r0);
    return vec3(cos(float(i) * theta * 2.) * r1, sin(float(i) * theta * 2.) * r1, r0);
}

// Function 2004
v0 dLine(v1 a,v1 b,v1 p){a=a-p;b-=p;p=b-a;return dd(a+p*sat(-dot(a,p)/dd(p)));}

// Function 2005
vec2 circle_intersections(vec2 ro, vec2 rd){

    float min_t = 1000.;
    float t;
    float idf = -1.;
    
    for(int i = 0; i < 1; i++){
        
        t = iSphere(ro, rd, CircleList[i].pos, CircleList[i].r);
        
        if(t < min_t){
        
            min_t = t;
            idf = float(i);
            
        } 
    }
    
    return vec2(t, idf);
}

// Function 2006
float line(vec2 p,vec2 a,vec2 b){p-=a,b-=a;float h=sat(dot(p,b)/dd(b))
    ;return length(p-b*h);}

// Function 2007
float brushLine(vec2 uv, vec2 p1, vec2 p2, float lineWidth)
{
    // Find our position in the line as a vec2 in (0,0) to (1, 1) or beyond if out of line
    vec2 uvLine = lineGeometry(uv, p1, p2, lineWidth);

    // inStroke is in (0, 1] if the pixel is in, 0 if not
    float inStroke = zeroToOne(uvLine);
	
    // Source a coordinate we can use in all noise functions as a sampling point
    vec2 source = uvLine + vec2(0, iTime);

    // We'll add texture that looks like bristles by squishing and stretching our simplex noise in nice ways.
	float tex = 0.;
    
    
    /* 	Little Thin Bristles */
    float strokeFade =  smoothstep(0., .5, uvLine.y) - smoothstep(.9, 1., uvLine.y);
    float lilBristlesTexture = clamp(
      	simplexNoise(source * vec2(10., .1))	// Simplex noise being squished vertically and stretch horizontally
     	+ simplexNoise(source * vec2(15., 1.))  // Simplex noise being squished a bit more, and moving faster horizontally
    , 0., 1.);
    tex += inStroke * strokeFade * lilBristlesTexture;

    
    /* Spackle */
    /*
    float spackleFade = smoothstep(.2, .4, uvLine.y) - smoothstep(.95, 1., uvLine.y);    
	spackleFade *= (smoothstep(-.2, 0., uvLine.x) - smoothstep(1., 1.2, uvLine.x));
    float spackleTexture = clamp(
        smoothstep(43., 45., magicBox(source))
	,0.,1.);
  	tex +=  spackleFade * spackleTexture;   
	*/    
    
    
    /* Thick Bristles */
    float thickBristlesTexture = clamp(
      	1.3*smoothstep(.3, 1., uvLine.y) // This creates a full stroke between 30% and 100% through the line
        - 0.3 * positiveSimplexNoise(source * vec2(10., .2)) // Partially scrape away a few streaks. 
    , 0., 1.);    
    float thickBristleFade = smoothstep(0., 1., uvLine.y) - smoothstep(.97, 1., uvLine.y);
    tex += inStroke * thickBristleFade * thickBristlesTexture;

    
    tex = clamp(tex, 0., 1.);
    return tex;
}

// Function 2008
float rectangle2(vec2 pos, vec2 size)
{
  return (step(pos.x, uv.x)         - step(pos.x + size.x,uv.x))
       * (step(pos.y - size.y,uv.y) - step(pos.y, uv.y));
}

// Function 2009
float smooth_line(float d, float w, float g) {
	return exp(-5.0*pow(d/w, g));
}

// Function 2010
vec4 rect(vec2 uv) {
    uv = abs(uv);
    return vec4(vec3(.5), uv.x < 1. && uv.y < 1.);
}

// Function 2011
float circleDistance(vec2 center, vec2 p, float radius) {
    vec2 n = center + radius * normalize(p - center);
	return distance(p, n);
}

// Function 2012
void DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){
    
          uv  -= origin;
    float v2   = dot(vector, vector);
    float vUv  = dot(vector, uv);
    vec2  p    = vector * clamp(vUv, 0.,len) /v2;
    float d    = distance(p, uv);

    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); 
}

// Function 2013
vec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )
{
  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
  //colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));
  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));
  return colOut;
}

// Function 2014
void DrawO( inout vec3 color, float x, float y )
{
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )
             || ( x >= 2.0 && x <= 4.0 )
             || ( x >= 9.0 && x <= 11.0 )
             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )
           )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 2015
float directionalLightDiffuse(vec3 nor, vec3 ldir) {
    return clamp(dot(nor, -ldir), 0.0, 1.0);
}

// Function 2016
float sampleConcreteLine(vec3 position) {
    float line = abs(fract(position.y)-0.5);
    line = 1.0-clamp(line*10.0,0.0,1.0);
    line*=line*line*3.0;
    return 1.0-line;
}

// Function 2017
float onLineX( const vec2 c, const float x ) {
	return step(x,c.x)*step(c.x,x);
}

// Function 2018
vec3 DrawZero(vec2 point, vec2 uv)
{
    vec3 result = vec3(0.0);
    for (int i = 0; i < 50; ++i)
    {
        float start = Rand_GetFloat01();
        float t = GetTime();
        float r1 = Rand_GetFloat01();
        float r2 = Rand_GetFloat01();
        float r3 = Rand_GetFloat01();
        float r4 = Rand_GetFloat01();
        float x = cos(t * r1 + start) * r3;
        float y = sin(t * r2 + start) * r4;
        vec3 color = vec3(Sin01(Rand_GetFloat01() * GetTime() + Rand_GetFloat01()), Cos01(Rand_GetFloat01() * GetTime()),Sin01(Rand_GetFloat01() * GetTime())) * Rand_Range(0.25, 0.5);
        float radius = Rand_GetFloat01() * 0.2 + 0.01;
        float slope = Rand_Range(0.001, 0.5) * radius;
        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);
    }
    
    for (int i = 0; i < 10; ++i)
    {
        float start = Rand_GetFloat01();
        float t = GetTime();
        float r1 = Rand_GetFloat01();
        float r2 = Rand_GetFloat01();
        float r3 = Rand_GetFloat01() * 1.5;
        float r4 = Rand_GetFloat01() * 1.5;
        float x = cos(t * r1 + start) * r3;
        float y = sin(t * r2 + start) * r4;
        vec3 color = Rand_Sample3D() * Rand_Range(0.1, 0.25);
        float radius = 0.3;//Rand_GetFloat01() * 0.2 + 0.01;
        float slope = Rand_Range(0.001, 0.5);
        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);
    }
    
    for (int i = 0; i < 10; ++i)
    {
        float start = Rand_GetFloat01();
        float t = GetTime();
        float r1 = Rand_GetFloat01();
        float r2 = Rand_GetFloat01();
        float r3 = Rand_GetFloat01() * 1.5;
        float r4 = Rand_GetFloat01() * 1.5;
        float x = cos(t * r1 + start) * r3;
        float y = sin(t * r2 + start) * r4;
        vec3 color = Rand_Sample3D() * Rand_Range(0.1, 0.25);
        float radius = 0.7;//Rand_GetFloat01() * 0.2 + 0.01;
        float slope = Rand_Range(0.001, 0.5);
        result += max(color * Circle(Rand_Sample2D() * 2.0 - 1.0 + vec2(x, y), radius, slope, uv), 0.0);
    }
    
    return max(result, 0.0);
}

// Function 2019
vec3 CircleWithoutSqrt(vec2 u,vec2 m,vec2 n//rasterization to hide low precision of trig-estimates.
){vec3 c=vec3(0)
 ;vec4 raster=vec4(2)
 ;m.x=m.y;n.x=n.y//debug cheap enforcing squares
 ;m=n-viewZoom/4.
 ;vec2 v=pmodfm(u,n,m,raster.x,planckT)//rasterized fold
 ;v=abs(v)-planckT
 ;c.x=v.x*v.y/(m.x-n.x)+(hl*.5)//squared rounded corners, with frointloaded sqrt
 ;//that is, -sqrt(viewZoom) depends on the screen resolution and can be a global const.
 ;return c;}

// Function 2020
void rectangle(vec2 o, vec2 s) {
    rounded_rectangle(o, s, 0.0);
}

// Function 2021
bool inRect(vec2 pos, vec4 rect) {
    return pos.x >= rect.x && pos.y >= rect.y && pos.x < rect.z && pos.y < rect.w;
}

// Function 2022
float drawS(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
//  float ref = float(isIn(length(uv), cMin, cMax));
  float valA = float(isIn(length(uv), cMin, cMax) && !isIn(uv.y, -cthick, cthick));
  float valB = float(isIn(-uv.y - uv.x*0.4, -cthick*0.5, cthick*0.5) &&
    length(uv) < cMax);
  return valA + valB;
}

// Function 2023
float directionalShadow(vec3 cameraTarget, vec3 modelPosition, vec3 p, vec3 dirLightPos)
{
    float shadow = 0.;
    mat3 dirLightView = getView(dirLightPos, cameraTarget);
    vec3 dirLightRayDirection = dirLightView * modelPosition;

    float dt = 0., d = 0.;
    // shadow depth
    float shadowDepth = length((dirLightPos-p));
    dirLightRayDirection = normalize(-dirLightPos+p);
    vec3 shadowPos;
    for( int i = 0; i < maxSteps; ++i )
    {
        vec3 p = dirLightPos + dirLightRayDirection*d;
        int id;	// id of object that is being drawn
        dt = drawScene(p,id);
        if( dt < EPSILON )
        {
            float currentShadowDepth = length((dirLightPos-p));
            // 
            if( currentShadowDepth/shadowDepth < 1.-EPSILON)
                shadow = 1.;	
            break;
        }
        d += dt;
    }
    return shadow;
}

// Function 2024
vec4 drawKey( vec2 uv, int color ) {
    uv = floor(fract(uv)*32.) - 16.;
        float l = step(abs(uv.y), 1.);
        l = max(l, step(length(uv+vec2(8,0)), 7.5));
        l -= step(length(uv+vec2(8,0)), 4.5);
        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));
        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));
        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));
        
	    vec3 col = vec3(0);
    	col[color] = 1.;
        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );

}

// Function 2025
float drawhours(vec2 uv){
    float t;
    uv.y-=0.12852;
    uv.y/=0.221;
    uv.x+=0.0313024;
    uv/=2.;
    t=(floor(mod((uv.x-0.0035)/.01,144.)/6.)*10.)/10.;
    uv/=2.85;
    uv.x=-uv.x;
    return showNum(vec2(-mod((uv.x)/(.01),2./2.85)/(0.15),uv.y*80.),t);
}

// Function 2026
float drawNumber( float num, vec2 pos, vec2 pixel_coords )
{
	float result = 0.;
	bool on = false;
	float d;
	/*
	// minus sign
	if( num < 0. )
	{
		result += drawMinus( pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		num = -num;
	}*/
	// tens of thousands
	d = floor(mod(num/10000.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// thousands
	d = floor(mod(num/1000.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// hundreds
	d = floor(mod(num/100.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// tens
	d = floor(mod(num/10.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// ones
	d = floor(mod(num,10.));
	result += drawDigit( d, pos, pixel_coords );
	pos.x += 4. / iResolution.x;
	/*
    // dec pt
	result += drawDecPt( pos, pixel_coords );
	pos.x += 2. / iResolution.x;
	// tenths
	d = floor(mod(num/.1,10.));
	if( true )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
	}
	// hundredths
	d = floor(.5+mod(num/.01,10.));
	if( d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
	}
	*/
	return clamp(result,0.,1.);
}

// Function 2027
void DrawBorderRect( vec2 vCanvasPos, Rect rect, vec3 vOutlineColor, inout vec4 vOutColor )
{ 
    vec2 vThickness = vec2(1.0);
    
	if ( Inside( vCanvasPos, rect ) )
    {        
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )
        {
            vOutColor.rgb = vOutlineColor;
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )
        {
            vOutColor.rgb = vOutlineColor;
        }
        else
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )
        {
            vOutColor.rgb = vOutlineColor;
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )
        {
            vOutColor.rgb = vOutlineColor;
        }
    }    
}

// Function 2028
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box, float border)
{
    fragColor.rgb *= mix(1.-shadow_box(fragCoord, box, border), 1., .5);
}

// Function 2029
vec4 blobDrawer(vec2 uv)
{
    vec3 gen = vec3(1.0,1.0,1.0);
   	
    float textureSize = iResolution.x*iResolution.y;    
    float onePixel = 1.0/textureSize;
    
    //
    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;
    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;
    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;
    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;
    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;
    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;
    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;
    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;
    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;
    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;
	gen *= smoothstep(0.0,1.0,sum/9.0);
    
    return vec4(gen,1.0);
}

// Function 2030
void UILayout_SetControlRectFromText( inout UILayout uiLayout, PrintState state, LayoutStyle style )
{
    UILayout_SetControlRect( uiLayout, UI_GetFontRect( state, style ) );
}

// Function 2031
float rect(float t){if (fract(t/pi/2.)<.5)return 1.;return 0.;}

// Function 2032
float getEmptyDirectionID(int cellID, int loops)
{
    vec3 cellID3D = getBufferCellID3D(cellID);
    
    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    int choisesCount = 0;
    
    for(float i = -1.0; i <= 1.0; i += 2.0)
    {
        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);
        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);
        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);

        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID3D, iResolution.xy)).x);
        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID3D, iResolution.xy)).x);
        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID3D, iResolution.xy)).x);

        bool xIsExist = 1.0f <= xNeighborCellExist;
        bool yIsExist = 1.0f <= yNeighborCellExist;
        bool zIsExist = 1.0f <= zNeighborCellExist;
        
        // dont enter from outer Cube
        xIsExist = xIsExist && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;
        yIsExist = yIsExist && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;
        zIsExist = zIsExist && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;
        
        choises[choisesCount] = round(1.5 + (i * 0.5)) * float(xIsExist); choisesCount+= 1 * int(xIsExist);
        choises[choisesCount] = round(3.5 + (i * 0.5)) * float(yIsExist); choisesCount+= 1 * int(yIsExist);
        choises[choisesCount] = round(5.5 + (i * 0.5)) * float(zIsExist); choisesCount+= 1 * int(zIsExist);
    }

    int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));
    return choises[index];
}

// Function 2033
vec3 drawline(vec2 z, vec3 col, vec3 ccol, vec2 line) {
  float d = abs(dot(z,line));
  return draw(d,col,ccol,fwidth(z.x));
}

// Function 2034
void drawScene( vec2 fragCoord )
{
    float scale = iResolution.y / 20.0;
    vec2 middle = iResolution.xy / 2.0 + vec2(0, 5.0) * scale;
    
    vec2 last = middle;
    for (int i=0; i<n; i++)
    {
        vec2 body = getBody(i, iChannel0).xy * scale + middle;
        drawSpring(fragCoord, last, body, 1.0 * scale, 5); 
        last = body;
    }
    
    drawCircle(fragCoord, middle, scale / 3.0);
    for (int i=0; i<n; i++)
    {
        vec2 body = getBody(i, iChannel0).xy * scale + middle;
#ifdef COLOR
        color = colors[i];
#endif
        drawCircle(fragCoord, body, scale * .6);
        last = body;
    }
}

// Function 2035
float distRect(vec2 p, vec2 rect)
{
  vec2 d = abs(p) - rect;
  return smoothstep(rect.y, 0.0, min(max(d.x, d.y),0.0) + length(max(d, 0.0)));
}

// Function 2036
vec3 ocircle(float t) {
    
    // h is a small step size
    const float h = 1e-1;
    
    // circle is centered at intersection of perpendicular bisectors of segments ab, bc
    vec2 a = map(t-h);
    vec2 b = map(t);
    vec2 c = map(t+h);  
    

    // normals of perpendicular bisector of segment ab, bc
	vec2 nab = b-a;
	vec2 nbc = c-b;
	
    // homogeneous line equations of of perpendicular bisectors
	vec3 l1 = vec3(nab, -dot(nab, 0.5*(a+b)));
	vec3 l2 = vec3(nbc, -dot(nbc, 0.5*(b+c)));
	
    // cross product of homogeneous lines gives point of intersection
	vec3 p = cross(l1, l2);
    
    // project to cartesian coords by perspective division
	vec2 ctr = p.xy/p.z;
		
	return vec3(ctr, length(a-ctr));

}

// Function 2037
float semiCircleDist(vec2 p, float radius, float angle, float width)
{
  width /= 2.0;
  radius -= width;
  return substract(pie(p, angle + sin(iTime)*55.), 
                       abs(length(p) - radius) - width);
}

// Function 2038
float splineTexture(float t, int y)
{
    int x = int(t);
    t = fract(t);
    float p0  =  getTexFloat(x-1, y);
    float p1  =  getTexFloat(x, y);
    float p2  =  getTexFloat(x+1, y);
    float p3  =  getTexFloat(x+2, y);
    p0 = spline(p0,p1,p2,p3,t);

    return p0;
}

// Function 2039
vec4 draw_ship(vec2 world_coords, ship_t ship, vec4 color) {
    mat3 ship_trans = get_trans_mat(
        ship.position.z, // angle
        ship.position.xy, // position
        vec2(SHIP_SCALE) // scale
    );
    
    mat3 flame_trans = ship_trans * mat3(
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, -1.45, 1.0
    );
    
    vec4 final_sdf = draw_sprite(
        world_coords,
        SPRITE_SHIP,
        ship_trans
    );
    
    
    if (ship.flame) {
        final_sdf = min(
            final_sdf,
            draw_sprite(
            	world_coords,
        		SPRITE_FLAME,
            	flame_trans
        	)
    	);
    }
    
    
    return neon(final_sdf.z, color, 0.1);
}

// Function 2040
float sdLine(vec2 p, vec2 a, vec2 b, float r)
{
    vec2 ab = b-a;
    float t = dot(p-a,ab)/dot(ab,ab);
    return length(p-a-ab*clamp(t,0.,1.))-r;
}

// Function 2041
float atm_delta_eddington_Fminus_direct( float g, float tau50, float mu )
{
    // Simplified Eddington downwelling flux component
    // for direct light input at the top interface,
    // assuming conservative scattering (omega0 = 1),
    // and no bottom reflection.
    float f = g * g;
    g = g / ( g + 1. );
    tau50 = ( 1. - f ) * tau50;
    return ( 2. + 3. * mu + ( 2. - 3. * mu ) * exp2pp( -tau50 ) ) / ( 4. + 3. * LN2 * tau50 * mu * ( 1. - g ) );
}

// Function 2042
float SparkRect(vec2 uv, vec2 center, vec2 size, float ang)
{
    vec2 cs = vec2(cos(ang), sin(ang));
    uv -= center;
    uv = vec2(dot(uv, cs), dot(uv.yx * vec2(-1.0, 1.0), cs));
    
    vec2 x = smoothstep(size*0.5, vec2(0.0, 0.0), abs(uv));
    return pow(x.x * x.y, 3.0);
}

// Function 2043
float drawGridLines(float axis)   
{
    return   drawCrispLine(0.0, axisWidth, axis)
           + drawPeriodicLine(majorLineFrequency, majorLineWidth, axis)
           + drawPeriodicLine(minorLineFrequency, minorLineWidth, axis);
}

// Function 2044
void drawLine(vec2 uv, vec2 point1, vec2 point2, float thickness, float blur, inout float value)
{
    //Get Sides of a Triangle
    float a = distance(uv, point2);
    float b = distance(uv, point1);
    float c = distance(point1, point2);
    
    //Calculate Point's Distance from the Line
    float distanceFromLine = sqrt(abs(pow(a, 2.) - pow((pow(a, 2.) - pow(b, 2.) + pow(c, 2.)) / (2. * c), 2.)));
    
	//Get Pixel's Value
    float pixelValue = smoothstep(thickness + blur, thickness, distanceFromLine);
    pixelValue *= smoothstep(thickness + blur, thickness, a + b - c);
    value = mix(value, 1., pixelValue);
}

// Function 2045
vec3 circle_blur(sampler2D sp, vec2 uv, vec2 scale) {
    vec2 ps = (1.0 / iResolution.xy) * scale;
    vec3 col = vec3(0.0);
    float accum = 0.0;
    
    for (int a = 0; a < 360; a += 360 / ANGLE_SAMPLES) {
        for (int o = 0; o < OFFSET_SAMPLES; ++o) {
			col += texture(sp, uv + ps * rot2D(float(o), float(a))).rgb * float(o * o);
            accum += float(o * o);
        }
    }
    
    return col / accum;
}

// Function 2046
void DrawDigit (vec2 fragCoord, int digitValue, int digitIndex, inout vec3 pixelColor)
{
    if (digitValue < 0)
        digitValue = 0;
    
    int indexX = int(fragCoord.x / SCORE_SIZE);
    int indexY = int((iResolution.y - fragCoord.y) / SCORE_SIZE);
    
    if (indexY > 0 || indexX != digitIndex)
        return;
    
    vec2 percent = fract(vec2(fragCoord.x,iResolution.y-fragCoord.y) / SCORE_SIZE);
    
    int x = int(percent.x * SCORE_SIZE / 2.0);
    int y = int(percent.y * SCORE_SIZE / 2.0);
    
    if (number(x,y,digitValue))
        pixelColor = vec3(1.0);    
}

// Function 2047
float diffuse_directional(vec3 n,vec3 l){
   float a = dot(n,normalize(l))*.5+.5 ;
    return a;

}

// Function 2048
C_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;

    const float kShadowRayLength = 10.0;      
    vec3 vLightDir = -light.vDir;
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );
    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}

// Function 2049
vec2 circle( in float t )
{
    float s = fract(t*4.0);
	
    #if REPARAMETRIZE==1
    s = s*s*s*(6.0*s*s-15.0*s+10.0); // pick something better
    s = s*s*(3.0-2.0*s);
    #endif

    vec2 p = pow( vec2(1.0-s,s), vec2(1.0/6.0) );
    
    return (t<0.25) ? vec2(-p.y, p.x) :
           (t<0.50) ? vec2(-p.x,-p.y) :
           (t<0.75) ? vec2( p.y,-p.x) : p;
}

// Function 2050
float DistLine(vec2 p, vec2 a, vec2 b){
	vec2 pa = p-a;
    vec2 ba = b-a;
    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);
    return length(pa-ba*t);
}

// Function 2051
float circleStretch(vec2 u, vec4 m){return length(mStretch(u,m.xy))-2.;}

// Function 2052
vec3 labelDraw(Label label,vec2 p){
    
    return vec3(.2);
}

// Function 2053
float sdLine( vec3 p, vec3 a, vec3 b)
{
  vec3 pa = p - a, ba = b - a;
  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
  return length( pa - ba*h );
}

// Function 2054
float onLine( const float c, const float b ) {
	return clamp( 1.-abs(b-c), 0., 1. );
}

// Function 2055
float pseudoCircle(vec2 p,float r, float alpha){
  float f = pow(abs(p.x),alpha)+pow(abs(p.y),alpha);
  return r-pow(abs(f),1./alpha);
}

// Function 2056
vec4 drawCellDirt(ivec4 state, mat4x3 colors, ivec2 coord)
{
    Sprite sprite = getSpriteDirt();
    return sampleSprite(sprite, colors, coord);
}

// Function 2057
float sdistLine(vec2 a, vec2 b, vec2 pos)
{
    return dot(pos - a, normalize(ortho(b - a)));
}

// Function 2058
void draw_text(in vec2 p, in vec2 fragCoord, inout vec4 fragColor)
{
    print(val, vec2(1), vec2(iResolution.x - 50.,10.), vec3(0), fragCoord, fragColor);
}

// Function 2059
vec3 WavelengthToXYZLinear( float fWavelength )
{
    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);
    float fIndex = fPos * float(standardObserver1931_length);
    float fFloorIndex = floor(fIndex);
    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );
    int iIndex0 = int(fFloorIndex);
    int iIndex1 = iIndex0 + 1;
    iIndex1 = min( iIndex1, standardObserver1931_length - 1);

    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );
}

// Function 2060
float NumFont_Rect( vec2 vPos, vec2 bl, vec2 tr )
{
	if ( all( greaterThanEqual( vPos, bl ) ) &&
        all( lessThanEqual( vPos, tr ) ) )
    {
        return 1.0;
    }
        
    return 0.0;
}

// Function 2061
float dottedCircle(in vec2 uv, in float circleRadius, in float dotRadius, float dotsCount)
{
 	float angle = atan(uv.y, uv.x);
    angle /= TWO_PI;
    angle += 0.5;
    angle = round(angle * dotsCount) / dotsCount;
    angle *= TWO_PI;
    //angle *= round(angle / TWO_PI * dotsCount) * TWO_PI;
    vec2 dotPoint = vec2(circleRadius, 0.0) * rotationMatrix(angle);
    return smoothstep(dotRadius, dotRadius * 0.5, distance(dotPoint, uv));
    
    return angle;
}

// Function 2062
void drawPlane(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 planeNorm;
    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    
    
    if(planeT < cur_ctxt.t)
    {
        cur_ctxt.t = planeT;

        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; 
        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;
        cur_ctxt.n = planeNorm;
        
        cur_ctxt.alpha = 0.0;
        cur_ctxt.materialType = DIFFUSE;
        /*if(randVals.y < 0.5)
        {
            cur_ctxt.materialType = REFLECTION;
        }*/
    }
}

// Function 2063
float sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }

// Function 2064
vec4 rectangle(vec2 uv, vec2 pos, vec2 mins, vec2 maxs, vec4 c){
	if(uv.x>(pos.x+mins.x) && 
	   uv.y>(pos.y+mins.y) && 
	   uv.x<(pos.x+maxs.x) && 
	   uv.y<(pos.y+maxs.y))
		return c;
	return vec4(-1.0);
}

// Function 2065
void drawDisk(vec2 uv, vec2 position, float radius, float blur, vec3 colour, inout vec3 value)
{
    float pixelValue = smoothstep(radius + blur, radius, distance(position, uv));
    value = mix(value, colour, pixelValue);
}

// Function 2066
vec2 pCircle(float r, float t)
{
    return vec2(r * sin(t), r * cos(t));
}

// Function 2067
vec4 draw(vec2 fragCoord) {

    vec2 seed = hash22(fragCoord + (float(iFrame)) * sqrt3);

    invert = 1.;
    
    envOrientation = sphericalMatrix(((vec2(81.5, 119) / vec2(187)) * 2. - 1.) * 2.);

    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;
    
    // jitter for antialiasing
    p += 2. * (seed - .5) / iResolution.xy;

    float focalLength = 3.;
    vec3 camPos = vec3(0, 0, 1.5) * focalLength;
    vec3 camTar = vec3(0, 0, 0);
    
    // DOF
    camPos.xy += rndcircle(seed) * .05;
    seed = hash22(seed);
    
    vec3 ww = normalize(camTar - camPos);
    vec3 uu = normalize(cross(vec3(0,1,0),ww));
    vec3 vv = normalize(cross(ww,uu));
    mat3 camMat = mat3(-uu, vv, ww);

    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));
    vec3 origin = camPos;
    
    Hit hit = march(origin, rayDir, 4. * focalLength);

    float firstHitLen = hit.len;
    bool isFloor = hit.model.id == 2;
    
    vec3 nor, ref, raf; 
    float ior, offset;
    
    float wavelength = seed.y;
    vec3 col = vec3(0);    

    for (int bounce = 0; bounce < 10; bounce++) {
   
        if (bounce > 0) {
           seed = hash22(seed);
           hit = march(origin, rayDir, 6.);
        }
        
        if (hit.model.id == 0) {
            break;
        }

        nor = calcNormal(hit.pos);
        
        if (hit.model.id == 1) {
            
            // Reflective bounce
            
            ref = reflect(rayDir, nor);
            
            // shade
            col += light(hit.pos, ref) * .5;
            col += pow(max(1. - abs(dot(rayDir, nor)), 0.), 5.) * .1;
            col *= vec3(.85,.85,.98);

            // refract
            ior = mix(1.2, 1.8, wavelength);
            ior = invert < 0. ? ior : 1. / ior;
            raf = refract(rayDir, nor, ior);
            bool tif = raf == vec3(0); // total internal reflection
            rayDir = tif ? ref : raf;
            invert *= -1.; // not correct but gives more interesting results
            //invert = tif ? 1. : -1.; // 'correct' refraction
            
        } else {
            
            // Diffuse bounce
            
            seed = hash22(seed);
            rayDir = getSampleBiased(nor, 1., seed);            
 
        }
        
        offset = .01 / abs(dot(rayDir, nor));
        origin = hit.pos + offset * rayDir;
    }    
    
    if (isFloor) {
        col *= 2.;
    }

    vec3 fogcol = vec3(.0);
    col = mix(col, fogcol, saturate(1.0 - exp2(-.0006 * pow(firstHitLen - length(camPos*.666), 5.))));

    // Dispersion
    col *= spectrum(-wavelength+.30);

    return vec4(col, 1);
}

// Function 2068
vec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour) {
    vec3 colour = current_colour;
    vec2 p2 = vec2(p1.x, p3.y);
    vec2 p4 = vec2(p3.x, p1.y);
    vec2 box_center = (p1 + p3)/2.0;
    float bd = rectangle(p-box_center, (p3-p1)/2.0);
    float noise = get_noise(p);
    noise *= 5.0;
    if (bd-noise<0.0)
        colour = paper_colour;
    colour = draw_line(p, p1, p2, colour);
    colour = draw_line(p, p2, p3, colour);
    colour = draw_line(p, p3, p4, colour);
    colour = draw_line(p, p4, p1, colour);
    return colour;
}

// Function 2069
vec4 interpolate_bilinear(vec2 p, vec4 q[16])
{
    vec4 r1 = (1.0-p.x)*q[5]+p.x*q[9];
    vec4 r2 = (1.0-p.x)*q[6]+p.x*q[10];
    return (1.0-p.y)*r1+p.y*r2;
}

// Function 2070
vec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius){

    float distanceLight = length(p - pos);
    
    if(distanceLight > range) return vec4(0.0);
    
    float shadow = castShadow(p, pos, radius);
    float fall = (range - distanceLight)/range;
    fall *= fall;
    float source = fillMask(circleDist(p - pos, radius));
    return (shadow * fall + source) * color;
    
}

// Function 2071
vec3 randomDirection(in vec3 base, in vec3 u, in vec3 v, in float r2, in vec3 seed)
{
	float phi = 2.0 * PI * randomFloat(seed);
	float Xi = randomFloat(seed * phi + phi);
    
	float cosTheta = sqrt((1.0 - Xi) / ((r2 - 1.0) * Xi + 1.0));
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
	return normalize((u * cos(phi) + v * sin(phi)) * sinTheta + base * cosTheta);
}

// Function 2072
float circle(vec2 uv, vec2 pos, float r, float softness) {
    float d = r - length(pos - uv); 
    d = d/(r*clamp(softness, .001, 1.));
	float t = clamp(d, 0., 1.);
	return t;
}

// Function 2073
bool PixelOnCircleContour( vec2 fragCoord, vec3 circle, float distFromContour )
{
    float distFromCenterLarge = 0.0;
    float distFromCenterSmall = 0.0;
    bool ret =  
        PixelInsideCircle( fragCoord, circle, distFromCenterLarge ) && 
        !PixelInsideCircle( fragCoord, vec3(circle.xy,circle.z-c_LINE_WIDTH), distFromCenterSmall );
    
    distFromContour = distFromCenterLarge-circle.z;
    
    return ret;
}

// Function 2074
void drawTitle(ivec2 uv, const in sampler2D d, inout vec3 f) {
    if (inBox(uv, ivec2(51,40), ivec2(51+218,64))) {
	    int i = (uv.x-51)/20;
        if (i * 16 < iFrame) {
            int o = int[](0,1,2,1,3,2,4,4,0,5,2)[i] * 20;                    
            drawSprite(uv, ivec2(51+i*20,40), ivec2(51+i*20+20,64), ivec2(o,0), iChannel1, false, f);
        }
    }
}

// Function 2075
void draw_map(out vec4 fragColor, in vec2 fragCoord) {
    vec2 map_uv = mod(fragCoord, MAP_SIZE) / MAP_SIZE;
    
    vec2 coords = (map_uv - 0.5) * 2.0;
    coords.x *= MAP_SIZE.x / MAP_SIZE.y;
    
    
    vec2 line = line_segment(coords, vec2(-0.5, 0.0), vec2(0.5, 0.0));
    
    
    
    float angle = atan(coords.x, coords.y);
    
    float track_radius = 0.7;
    
    // Distort
    track_radius += cos(angle * 3.0 - 1.0) * 0.10;
    track_radius += cos(angle * 5.0 + 1.0) * 0.10;
    
    float track_width = 0.05;
    
    float center_sdf = abs(track_radius - length(line));
    float border_sdf = center_sdf - track_width;
    float boundary_sdf = abs(track_width - center_sdf);
    
    vec2 border_norm = normalize(vec2(
        dFdx(border_sdf),
        dFdy(border_sdf)
    ));
    
    fragColor = vec4(border_norm + 0.5, border_sdf + 0.5, 0.0);
}

// Function 2076
vec4 demoLineIntersection(float t,vec2 u,vec3 r,vec4 m
){vec4 c=vec4(1)
 ;u   =viewzoom*(u   -r.xy*.5)/r.y
 ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y
 ;vec2 l0=vec2(-.4)
 ;vec2 l1=vec2( .7)
 ;vec2 r0=vec2(.5,-.5)
 ;vec2 r1=vec2(.5,-.1)
 ;float pointCount=texture(iDiegeticUI,(vec2(maxCount, 0.)+.5)/iResolution.xy).y
 ;if(pointCount >0.
 ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.
 ;}
 ;if(pointCount >1.//point4 sets one point of the red/yellow arc
 ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.
 ;}  
 ;if(pointCount >2.//point4 sets one point of the red/yellow arc
 ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.
 ;} 
 ;if(pointCount >3.//point4 sets one point of the red/yellow arc
 ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.
 ;}
 ;c.x=segment(u,l0,l1)
 ;c.y=segment(u,r0,r1)
 ;c.z=length(u-mix(l0,l1,.5))
 ;c.w=length(InterWall(r0,r1,l0,l1)-u)
 ;c.xy-=.02
 ;//c.z=abs(c.z-.05)-.02
 ;//c.w=abs(c.w-.1)-.03
 ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)
 ;c*=1.
 ;c=pdOver(pdOver(vec4(1,0,0,1)*c.x,vec4(0,1,0,1)*c.y)
          ,pdOver(vec4(0,0,1,1)*c.z,vec4(1,1,0,1)*c.w))
 ;return c;}

// Function 2077
Rect UILayout_GetStackedControlRect( inout UILayout uiLayout, vec2 vSize )
{
    return Rect( uiLayout.vCursor, vSize );
}

// Function 2078
vec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){
    vec2 g, prev = p4;
    float dt = 1./numSegments;  
    
    for(float t = dt; t <= 1.+dt; t+=dt){   
    
    
        //Matrix Representation
        vec4 T = vec4(1, t, t*t, t*t*t);
        
        //nice looking upper triangular matrix there. 
        
        mat4 M = mat4(1,0,0,0, 
                     -3,3,0,0, 
                      3,-6,3,0, 
                     -1,3,-3,1);
                     
        //I wonder what's gonna happen...             
        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);
        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);
        
        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot
        //when the time comes! After the initial M*T (or P*M apparently?)
        g.x = dot(M*T,Px); // is the same as dot(P*M,T)
        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference
        
        
        //or
        //Mix functions, much smaller
        //g = mix(p3,p2,t);
        //g = mix(mix(mix(p4,p3,t), g, t), 
        //            mix(g, mix(p2,p1,t), t), t);
        
        
        //or 
        //Binomial
        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);
        
        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9),lineThickness);
        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);
        prev = g;
    }
    return col;
}

// Function 2079
void drawPoint (vec2 pos, in float radius, in vec4 pointColor)
{
  float intensity = sdCircle(mp, radius, 100.0);
  paintColor = mix(paintColor, pointColor, intensity);
}

// Function 2080
vec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)
{
	// distance to light
	float ld = length(p - pos);
	
	// out of range
	if (ld > range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, pos, radius);
	float fall = (range - ld)/range;
	fall *= fall;
	float source = fillMask(circleDist(p - pos, radius));
	return (shad * fall + source) * color;
}

// Function 2081
float sdCircle( vec2 p, float r )
{
  return length(p) - r;
}

// Function 2082
float dist_to_line(vec2 p1, vec2 p2, vec2 uv)
{
	float a = abs(distance(p1, uv));
	float b = abs(distance(p2, uv));
	float c = abs(distance(p1, p2));

	float d = sqrt(c*c + RADIUS*RADIUS);

	if (a >= d || b >= d)	{
        float dist1 = distance(p1, uv);
        float dist2 = distance(p2, uv);
        return min(dist1,dist2);
	}

	float p = (a + b + c) * 0.5;

	float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));
    return h;
}

// Function 2083
float LineDist(vec2 a, vec2 b, vec2 p) {
	vec2 ab=b-a, ap=p-a;
    float h = dot(ab, ap)/dot(ab, ab);
    float d = length(ap - ab * h);
    float s = sign(ab.x * ap.y - ab.y * ap.x);
    return d*s;
}

// Function 2084
void renderCircle(vec2 center, float radius, vec2 pos, inout vec3 fragColor)
{
    float dist = length(pos - center) - radius;
    stroke(dist, vec3(0, 0, 1), fragColor, 0.005, length(fwidth(pos)));
}

// Function 2085
void drawPipePair(vec2 co, float xPos, float bottomPipeHeight)
{
	vec2 bounds = getLevelBounds();
	float topPipeHeight = bounds.y - (VERT_PIPE_DISTANCE + PIPE_BOTTOM + bottomPipeHeight);
	
	drawBottomPipe(co, xPos, bottomPipeHeight);
	drawTopPipe(co, xPos, topPipeHeight);	
}

// Function 2086
vec2 randomLines(vec2 pos, vec2 scale, float count, float width, float jitter, vec2 smoothness, float phase, float seed)
{
    float strength = jitter * 1.25;

    // compute gradient
    // TODO: compute the gradient analytically
    vec2 grad;
    vec3 offsets = vec3(1.0, 0.0, -1.0) / 1024.0;
    vec4 p = pos.xyxy + offsets.xyzy;
    vec2 nv = count * (strength * multiNoise(p, scale.xyxy, phase, seed) + p.yw);
    grad.x = nv.x - nv.y;
    p = pos.xyxy + offsets.yxyz;
    nv = count * (strength * multiNoise(p, scale.xyxy, phase, seed) + p.yw);
    grad.y = nv.x - nv.y;
    
    float v =  count * (strength * noise(pos, scale, phase, seed) + pos.y);
    float w = fract(v) / length(grad / (2.0 * offsets.x));
    width *= 0.1;
    smoothness *= width;
    smoothness += max(abs(grad.x), abs(grad.y)) * 0.02;
    
    float d = smoothstep(0.0, smoothness.x, w) - smoothstep(max(width - smoothness.y, 0.0), width, w);
    return vec2(d, mod(floor(v), count));
}

// Function 2087
vec2 PointSegDirection(vec2 p, vec2 p0, vec2 p1)
{
    vec2 proj = PointSegProj(p, p0, p1);
    
    return proj-p;
}

// Function 2088
void DrawNumber(float number,float fontSize, vec2 position,inout vec3 currentColor, in vec2 uv){
    fontSize = 100./fontSize;
    float intPart = floor(number);
    float decimalPart = floor(fract(number)*PRECISION);
    float characters = 0.;
    
	DrawNumberPart(decimalPart,fontSize,position,characters,currentColor,uv + vec2(-0.01,.0));
    vec2 textUV =position * fontSize + uv*fontSize;
    textUV.x*=-1.;
    textUV.y*=-1.;
    textUV-= vec2(characters - .7  ,0.) ;
    currentColor+= Character(4.,textUV);
	DrawNumberPart(intPart,fontSize,position,characters,currentColor,uv);


    
}

// Function 2089
void drawFunction(float x, float y) {
	float dxy = dxy(x, y);
    if (eq(dxy, 0.0, thickness)) {
    	hue = map(x + iTime, -scale / 2.0, scale / 2.0, 0.0, 1.0);
    	brightness = coverage(dxy, thickness) - 0.2;
    	saturation = 1.0;        
        /*if (eq(x,sin(iTime) * scale / 2.2,1.0)) {
            brightness += 0.2;   
        }*/
    } 
}

// Function 2090
vec2 lineIntersectSphere(in vec3 o, in vec3 t, float r)
{float b=dot(o,t),d=b*b+r*r-dot(o,o)
;if(d<.0)return vec2(MAX,-MAX)//code for no intersection?
;return vec2(-1,1)*sqrt(d)-b;}

// Function 2091
void drawSDF(inout vec3 col, vec3 pcol, float d, float r)
{
    float psize = 1.0/iResolution.y;

    d = (d - r/zoom*psize*vRes.y) * zoom;

    col = mix(pcol, col, smoothstep(-psize,psize,d));
}

// Function 2092
float line(vec2 p, vec2 a, vec2 b) {
	vec2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
	vec2 d = pa - ba * h;
	return dot(d,d); //length(d); // optimization by deferring sqrt
}

// Function 2093
void UILayout_SetControlRect( inout UILayout uiLayout, Rect rect )
{
    uiLayout.controlRect = rect;
    
    uiLayout.vControlMax = max( uiLayout.vControlMax, rect.vPos + rect.vSize );
    uiLayout.vControlMin = max( uiLayout.vControlMin, rect.vPos );    
}

// Function 2094
bool inRect(v1 u, v3 b
){b.xyzw-=u.xyxy
 ;return mi(b.zy-b.xw)<mi(b)
 ;return min(b.z-b.x,b.y-b.w)<mi(b) ;}

// Function 2095
vec3 calcDirectLight( vec3 pos, out vec3 wi, Sphere lightSphere, vec3 lightColor ) {
    vec3 Li = lightColor;
    vec3 Lo = vec3( 0.0 );
    
    vec3 dirToLightCenter = lightSphere.pos - pos;
    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);
    float cos_a_max = sqrt( 1.0 - clamp( lightSphere.radiusSq / distToLightCenter2, 0.0, 1.0 ) );
    float omega = TWO_PI * (1.0 - cos_a_max);	//solid angle
    float cosa = mix(cos_a_max, 1.0, rnd());
    float sina = sqrt(1.0 - cosa*cosa);

    wi = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );
    float pWi = (1.0/omega);

    Ray shadowRay = Ray( pos, wi );
    float dist;
    raySphereIntersection( shadowRay, lightSphere, dist );

    float tmpDist;
    RayHit tmpHit;
    int tmpObjId;
    raySceneIntersection( shadowRay, EPSILON, tmpHit, tmpObjId, tmpDist );
    float eps = tmpDist*0.0001;

    if( EQUAL_FLT( tmpDist, dist, eps ) ) {
        Lo += ( Li ) / pWi;
    }

    return Lo;
}

// Function 2096
float sdFatLine2(vec2 p, vec3 a, vec3 b)
{
    vec2 d = b.xy - a.xy;
    vec2 pd = p - a.xy;
    float t = dot(pd, d) / dot(d, d);
    t = min(1.0, max(0.0, t));
    vec2 cp = a.xy + t * d;
    
    vec2 n = p - cp;
    float distToCurve = length(n);
    
    // remember a.z & b.z are radius
    float cr = mix(a.z, b.z, t);
    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;
//    uv = vec2(t, v);

    float distToBoundary = distToCurve - cr;
    
    return distToBoundary;
}

// Function 2097
float linesdf(vec2 p, vec2 start, vec2 dir) {
    vec2 p2 = p - start;
    float h = clamp(dot(p2, dir) / dot(dir, dir), 0., 1.);
    return length(p2 - h*dir);
}

// Function 2098
void drawTile(vec2 m, int i, int r) {
    vec2 a = vec2(T[i  ],T[i+1]),
         b = vec2(T[i+2],T[i+3]) - a;
    L(m-a, 4*r);
}

// Function 2099
void drawBevel(inout vec3 color, vec3 highlight, vec3 shadow, vec2 fragCoord, vec2 position, vec2 size)
{
    if (fragCoord.x >= position.x && fragCoord.x < (position.x + size.x) &&
        fragCoord.y >= position.y && fragCoord.y < (position.y + size.y)) {
        if (fragCoord.x - 0.5 == position.x + size.x - 1.0 ||
                 fragCoord.y - 0.5 == position.y) {
            color = shadow;
        }  
        else if (fragCoord.x - 0.5 == position.x ||
            fragCoord.y - 0.5 == position.y + size.y - 1.0) {
            color = highlight;
        }
    }
}

// Function 2100
float linear_interp(float x) {
    float c = clamp(x, 0., 1.);
	
    return c;
}

// Function 2101
vec3 cosineDirection( in uint seed, in vec3 nor)
{
    vec2 r = hash2( seed*7U+11U );

    // by fizzer: http://www.amietia.com/lambertnotangent.html
    float a = 6.2831853 * r.y;
    float u = 2.0*r.x - 1.0;
    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
}

// Function 2102
bool isLinearValid(in int index, vec2 iResolution) {
    vec2 res = iResolution.xy;
    //return true;
	return index < maxLinear(iResolution);
}

// Function 2103
float getClosestLinePoint(vec3 ro, vec3 rd, vec3 x)
{
    return dot(rd, x - ro);
}

// Function 2104
vec2 getScreenspaceUvFromRayDirectionWS(
    vec3 rayDirectionWS,
	vec3 cameraForwardWS,
	vec3 cameraUpWS,
	vec3 cameraRightWS,
	float aspectRatio)
{
    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;
    // project rayDirectionWs onto camera forward
    float projDist                 = dot(rayDirectionWS, cameraForwardWS);
    vec3  eyeToPosOnCameraPlaneWS = (rayDirectionWS / projDist) * kCameraPlaneDist;
    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;

    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);
    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);
    
    xDist /= aspectRatio;
    xDist = xDist * 0.5 + 0.5;
    yDist = yDist * 0.5 + 0.5;

    return vec2(xDist, yDist);
}

// Function 2105
float circle(vec2 p, float r) {
    return length(p) - r;
}

// Function 2106
float sdLineSq( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
	return dot2(pa-ba*h);
}

// Function 2107
float drawInt(int v)          {return drawInt(v,1);}

// Function 2108
BRDFOutput ApplyDirectionalLight(in DirectionalLight light, in Material material, in vec3 point, in vec3 normal, in vec3 eye, in bool castShadow)
{
    vec3 lightDirection = normalize(-light.mDirection);
    BRDFOutput returnValue = GetBRDFOutput(point, normal, eye, lightDirection, light.mColor, 1.0, material);
                 
    // Cast a ray to check for shadows
    float shadow = 1.0;
#if SHADOWS_ENABLED
    if(castShadow)
    {
    	vec3 shadowRayDirection = (gSceneInfo.x == MONTE_CARLO_MODE) ? RandomDirectionAroundRange(float(iFrame), 0.7, lightDirection) : lightDirection;
    	Ray shadowRay = Ray(point + (EPSILON * normal), shadowRayDirection);
    	IntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);
    	shadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region 
    }
#endif // SHADOWS_ENABLED
    returnValue.mLighting *= shadow;
    
	return returnValue;
}

// Function 2109
vec3 hsluv_fromLinear(vec3 c) {
    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );
}

// Function 2110
float rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {
	float ret;
	float d = 0.005;
	ret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);
	ret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);
	ret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);
	ret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);
	return ret;
}

// Function 2111
vec4 circle(vec2 uv, vec2 pos, float sz){
    // draw a circle at mouse coordinates
    float s = (3.0+0.0*pow(noise(vec2(iTime*0.5)),2.0))/sz;
    uv += pos+vec2(1.0/s);
    float val = clamp(1.0-length(s*uv-1.0), 0.0, 1.0);
    val = pow(5.0*val, 1.0);
	return vec4(clamp(val, 0.0, 1.0));
}

// Function 2112
float circleSDF(vec2 uv) {
	return length(uv);
}

// Function 2113
float line( vec3 p, vec3 a, vec3 b, float r )
{
    vec3 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

// Function 2114
float iisRect(vec2 p, vec2 center, vec2 size){
    vec2 hs = size / 2.;
    p -= center;
    vec2 pos = (p / hs) * 240.;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
    float invNum = 0.;
    bool inFund = true;
    for (int i = 0; i < MAX_ITERATIONS; i++) {
        inFund = true;
        if (distance(pos, g_c1.xy) < g_c1.z) {
            pos = circleInvert(pos, g_c1);
            inFund = false;
            invNum++;
        } else if (distance(pos, g_c2.xy) < g_c2.z) {
            pos = circleInvert(pos, g_c2);
            inFund = false;
            invNum++;
        } else if (distance(pos, g_c3.xy) < g_c3.z) {
            pos = circleInvert(pos, g_c3);
            inFund = false;
            invNum++;
        } else if (distance(pos, g_c4.xy) < g_c4.z) {
            pos = circleInvert(pos, g_c4);
            inFund = false;
            invNum++;
        }
        if (inFund) break;
    }

    if(mod(invNum, 2.) == 0.) return 100.;
    return -1.;
}

// Function 2115
float onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {
	return onLine( c.x, b )*onBand( c.y, mi, ma );
}

// Function 2116
vec4 drawRelativeToSecondary(in vec2 uv, in bool rel)
{
    float lsize = 0.015;
    vec2 start = vec2(0.016, 0.35);
    vec4 tcol;
    
    if (rel)
    {
        tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_R, _e, _l, _a, _t, _i, _v, _e, _X, _X), 8);
        tcol += drawTextHorizontal(uv, start + vec2(lsize * 4.5, 0.), lsize, vec2[10](_T, _o, _X, _X, _X, _X, _X, _X, _X, _X), 2);
        tcol += drawTextHorizontal(uv, start + vec2(lsize * 6., 0.), lsize, _SECONDARY, 9);
    }
    
    return tcol;
}

// Function 2117
float sdline(v1 p,v1 a,v1 b){vec2 c=b-a;
 vec2 m=vec2(sin(atan(c.x,c.y)+vas));return dot(p,m)-dot(a,m);}

// Function 2118
float hardCircle(in vec2 uv, in float radius, in float width)
{
 	return smoothstep(width, width * 0.99, abs(radius - length(uv)));   
}

// Function 2119
bool UI_DrawWindowCloseBox( inout UIContext uiContext, Rect closeBoxRect )
{
	if (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, closeBoxRect ))
        return false;
    
    vec2 vCrossPos = closeBoxRect.vPos + closeBoxRect.vSize * 0.5;        
    vec2 vCrossSize = closeBoxRect.vSize * 0.5 * 0.4;
    vec4 crossColor = vec4(0.0, 0.0, 0.0, 1.0);

    vec2 vCrossSizeFlip = vCrossSize * vec2(1.0, -1.0);
    
    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSize, vCrossPos + vCrossSize, 2.0f, crossColor, uiContext.vWindowOutColor );
    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSizeFlip, vCrossPos + vCrossSizeFlip, 2.0f, crossColor, uiContext.vWindowOutColor );
    
    return true;
}

// Function 2120
float line( vec2 a, vec2 b, vec2 p ) {
    vec2 aTob = b - a;
    vec2 aTop = p - a;

    float t = dot( aTop, aTob ) / dot( aTob, aTob);

    t = clamp( t, 0.0, 1.0);

    float d = length( p - (a + aTob * t) );
    d = 0.001 / d;

    d = pow(d, 10.0);
    return clamp( d, 0.0, 0.6 );
}

// Function 2121
float circleRing(vec2 uv, float steps, float minr, float maxr, float angleJitter, float angularSpeed, float rotation) {
    float iter;
    float a = atan(uv.y, uv.x);
    a += rotation + iTime * angularSpeed;
    uv = length(uv) * vec2(cos(a), sin(a));
    uv = moda(uv, steps, iter);
    vec2 r = rand2(vec2(floor(iter)*.0354, 0.21));
    float d = length(uv - vec2(.3+mix(maxr, minr, r.x),mix(-1.,1.,r.y)*.08*angleJitter)) - mix(minr, maxr, r.x);
    return -d;
}

// Function 2122
void solveCircle(in float width, in float aperture, out float radius, out float offset) {
    offset = (width*width/aperture-aperture)/2.;
    radius = offset + aperture;
}

// Function 2123
void draw_menu(inout vec4 fragColor, vec2 fragCoord, Timing timing)
{
    MenuState menu;
    LOAD(menu);

    if (menu.open <= 0)
        return;

    vec4 options = load(ADDR_OPTIONS);

    if (!test_flag(int(options[get_option_field(OPTION_DEF_SHOW_LIGHTMAP)]), OPTION_FLAG_SHOW_LIGHTMAP))
    {
        // vanilla
        fragColor.rgb *= vec3(.57, .47, .23);
        fragColor.rgb = ceil(fragColor.rgb * 24. + .01) / 24.;
    }
    else
    {
        // GLQuake
       	fragColor.rgb *= .2;
    }

    //g_text_scale_shift = 1;
    int text_scale = 1 << g_text_scale_shift;
    float image_scale = float(text_scale);
    vec2 header_size = ADDR2_RANGE_TEX_OPTIONS.zw * image_scale;
    vec2 left_image_size = ADDR2_RANGE_TEX_QUAKE.wz * image_scale;
    float left_image_offset = 120. * image_scale;

    vec2 ref = iResolution.xy * vec2(.5, 1.);
    ref.y -= min(float(CHAR_SIZE.y) * 4. * image_scale, iResolution.y / 16.);

    ref.x += left_image_size.x * .5;
    if (fragCoord.x < ref.x - left_image_offset)
    {
        fragCoord.y -= ref.y - left_image_size.y;
        fragCoord.x -= ref.x - left_image_offset - left_image_size.x;
        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;
        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_QUAKE.w) && uint(addr.y) < uint(ADDR2_RANGE_TEX_QUAKE.z))
	        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr.yx + ivec2(ADDR2_RANGE_TEX_QUAKE.xy), 0).rgb;
        return;
    }

    ref.y -= header_size.y;
    if (fragCoord.y >= ref.y)
    {
        fragCoord.y -= ref.y;
        fragCoord.x -= ref.x - header_size.x * .5;
        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;
        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_OPTIONS.z) && uint(addr.y) < uint(ADDR2_RANGE_TEX_OPTIONS.w))
	        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr + ivec2(ADDR2_RANGE_TEX_OPTIONS.xy), 0).rgb;
        return;
    }

    ref.y -= float(CHAR_SIZE.y) * 1. * image_scale;

    const int
        BASE_OFFSET		= CHAR_SIZE.x * 0,
        ARROW_OFFSET	= CHAR_SIZE.x,
        VALUE_OFFSET	= CHAR_SIZE.x * 3,
        MARGIN			= 0,
        LINE_HEIGHT		= MARGIN + CHAR_SIZE.y;

    ivec2 uv = text_uv(fragCoord - ref);
    uv.x -= BASE_OFFSET;
    int line = -uv.y / LINE_HEIGHT;
    if (uint(line) >= uint(NUM_OPTIONS))
        return;
    
    uv.y = uv.y + (line + 1) * LINE_HEIGHT;
    if (uint(uv.y - MARGIN) >= uint(CHAR_SIZE.y))
        return;
    uv.y -= MARGIN;
    
    int glyph = 0;
    if (uv.x < 0)
    {
        int begin = OPTIONS.data[1 + line];
        int end = OPTIONS.data[2 + line];
        int num_chars = end - begin;
        uv.x += num_chars * CHAR_SIZE.x;
    	glyph = glyph_index(uv.x);
        if (uint(glyph) >= uint(num_chars))
            return;
        glyph += begin;
        glyph = get_byte(glyph & 3, OPTIONS.data[OPTIONS.data[0] + 2 + (glyph>>2)]);
    }
    else if (uint(uv.x - ARROW_OFFSET) < uint(CHAR_SIZE.x))
    {
        const float BLINK_SPEED = 2.;
        uv.x -= ARROW_OFFSET;
        if (menu.selected == line && (fract(iTime * BLINK_SPEED) < .5 || test_flag(timing.flags, TIMING_FLAG_PAUSED)))
            glyph = _RIGHT_ARROW_;
    }
    else if (uv.x >= VALUE_OFFSET)
    {
        uv.x -= VALUE_OFFSET;

        int item_height = CHAR_SIZE.y << g_text_scale_shift;

        MenuOption option = get_option(line);
        int option_type = get_option_type(option);
        int option_field = get_option_field(option);
        if (option_type == OPTION_TYPE_SLIDER)
        {
            const float RAIL_HEIGHT = 7.;
            vec2 p = vec2(uv.x, uv.y & 7) + .5;
            vec2 line = lit_line(p, vec2(8, 4), vec2(8 + 11*CHAR_SIZE.x, 4), RAIL_HEIGHT);
            float alpha = linear_step(-.5, .5, -line.y);
            line.y /= RAIL_HEIGHT;
            float intensity = 1. + line.x * step(-.25, line.y);
            intensity = mix(intensity, 1. - line.x * .5, line.y < -.375);
            fragColor.rgb = mix(fragColor.rgb, vec3(.25, .23, .19) * intensity, alpha);

            float value = options[option_field] * .1;
            float thumb_pos = 8. + value * float(CHAR_SIZE.x * 10);
            p.x -= thumb_pos;
            p -= vec2(4);
            float r = length(p);
            alpha = linear_step(.5, -.5, r - 4.);
            intensity = normalize(p).y * .25 + .75;
            p *= vec2(3., 1.5);
            r = length(p);
            intensity += linear_step(.5, -.5, r - 4.) * (safe_normalize(p).y * .125 + .875);

            fragColor.rgb = mix(fragColor.rgb, vec3(.36, .25, .16) * intensity, alpha);
            return;
        }
        else if (option_type == OPTION_TYPE_TOGGLE)
        {
            glyph = glyph_index(uv.x);
            if (uint(glyph) >= 4u)
                return;
    		const int
                OFF = (_O_<<8) | (_F_<<16) | (_F_<<24),
    			ON  = (_O_<<8) | (_N_<<16);
            int value = test_flag(int(options[option_field]), get_option_range(option)) ? ON : OFF;
            glyph = get_byte(glyph & 3, value);
        }
    }
    else
    {
        return;
    }
    
    vec4 color = vec4(.66, .36, .25, 1);
    print_glyph(fragColor, uv, glyph, color);
}

// Function 2124
maybe_vec2 get_distances_along_2d_line_to_circle(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in float r
){
    vec2 D = B0 - A0;
    float xz = dot(D, A);
    float z2 = dot(D, D) - xz * xz;
    float y2 = r * r - z2;
    float dxr = sqrt(max(y2, 1e-10));
    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);
}

// Function 2125
Rect CreateRect(float x, float y, float w, float h, vec2 dims, float z)
{
    Rect rect;
    rect.x = x/dims.x;
    rect.y = y/dims.y;
    rect.w = w/dims.x;
    rect.h = h/dims.y;
    rect.z = z;
    return rect;
}

// Function 2126
vec3 cosWeightedHemisphereDirection( const vec3 n, in vec2 r) {
	vec3  uu = normalize(cross(n, vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( abs(1.0-r.y) );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    return normalize(rr);
}

// Function 2127
float draw_solid(float d) {
    return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));
}

// Function 2128
vec3 drawGrid(vec3 col, float scroll, vec2 p)
{
    float e = 1.0/iResolution.x;
    float m = 0.5*iResolution.y/iResolution.x;
    
    col = drawHorizLine(col, gridColor, m, p);
    
    col = drawVertLine(col, gridColor, 0.5, p + vec2(scroll, 0.0));
    
    return col;
}

// Function 2129
float linearLight (float target, float blend){
    return (blend > 0.5) ? (target)+(2.0*(blend-0.5)) : (target +(2.0*blend-1.0));
}

// Function 2130
vec4 toLinear(vec4 color, transfer trc)
{
	bvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));
	bvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));
	vec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));
	vec4 lower = color/trc.slope;
	vec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));

	color = mix(higher, lower, cutoff);
	color = mix(color, neg, negCutoff);

	return color;
}

// Function 2131
void drawSelmi(inout vec3 ret, TileSpace t, Neighbors n, float aaSize) {
	vec2 p = t.p*4.-vec2(2., 0.);
	p *= vec2(0.5, 0.578);
	p += vec2(3., 1.3);
	if (n.BL) {
		square(ret, yRange(isoR(p)+vec2(0., 0.), -3., -2.), lightHSV, aaSize);
	}
	if (n.BR) {
		square(ret, isoM(p)+vec2(2., 4.), mediumHSV, aaSize);
	}
	drawPenrose(ret, p, aaSize);
	if (n.L) {
		square(ret, isoL(p)+vec2(1., 0.), darkHSV, aaSize);
		square(ret, isoL(p)+vec2(2., 1.), darkHSV, aaSize);
		square(ret, isoR(p), lightHSV, aaSize);
	}
	if (n.BL) {
		square(ret, isoR(p)+vec2(1., 1.), lightHSV, aaSize);
		square(ret, isoM(p)+vec2(1., 0.), mediumHSV, aaSize);
	}
	if (n.BR) {
		square(ret, isoR(p)+vec2(-3., 5.), lightHSV, aaSize);
		square(ret, isoR(p)-vec2(4., -6.), lightHSV, aaSize);
		square(ret, isoM(p)+vec2(1., 4.), mediumHSV, aaSize);
	}
}

// Function 2132
void DrawVignette( inout vec3 color, vec2 uv )
{    
    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );
    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );
    color *= vignette;
}

// Function 2133
vec3 cameraDirection(sampler2D BufC) 
{
    return loadValue(BufC, slotCameraForward).xyz;
}

// Function 2134
float DistLine(vec2 p, vec2 a, vec2 b) {

    vec2 pa = p-a;
    vec2 ba = b-a;
    
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
    
    return length(pa - ba * t);
}

// Function 2135
float sdCircle(vec2 p, float r) 
{
    return length(p) - r;
}

// Function 2136
float lineforcorner(vec2 p, float rot, float size) {
    return length(max(abs(p)-vec2(size*2.0-rot,rot),vec2(0.0)));
}

// Function 2137
vec3 i_direct_32( uint data )
{
    uvec3 d = uvec3( data, data>>11, data>>21 ) & uvec3(2047u,1023u,2047u);
    vec3 v = vec3(d)*2.0/vec3(2047.0,1023.0,2047.0) - 1.0;
    return normalize(v);
}

// Function 2138
float linear_step(float low, float high, float value)
{
    return clamp((value-low)*(1./(high-low)), 0., 1.);
}

// Function 2139
vec3 circle(in vec2 p, in float tp, in float tc)
{
    float v0 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.5 + 1.2), sin(tp * 0.7 + 3.2))), 0.01));
    float v1 = distFilter(triangleSignal(length(p - vec2(sin(tp * 0.6 + 0.3), sin(tp * 0.83 + 2.7))), 0.01));
    vec3 cb = vec3(sin(tc * 0.41 + 1.3),sin(tc * 0.52 + 2.4), sin(tc * 0.57 + 1.25)) / 2. + 0.5;
    vec3 c0 = vec3(sin(tc * 0.37 + 2.7),sin(tc * 0.39 + 3.9), sin(tc * 0.29 + 5.36)) / 2. + 0.5;;
    vec3 c1 = vec3(sin(tc * 0.39 + 1.6),sin(tc * 0.43 + 4.5), sin(tc * 0.47 + 6.23)) / 2. + 0.5;;
    return mix(mix(cb, c0, v0), c1, v1);
}

// Function 2140
void calcContactCircles(const vec3 commonCircle,
                        out vec3 c1, out vec3 c2, out vec3 c3, out vec3 c4){
    vec2 p = commonCircle.xy + vec2(0, commonCircle.z);
	vec2 q = commonCircle.xy + vec2(-commonCircle.z, 0);
	vec2 r = commonCircle.xy + vec2(0, -commonCircle.z);
	vec2 s = commonCircle.xy + vec2(commonCircle.z, 0);
    vec2 pqMid = (p + q)/2.;
    vec2 u = (pqMid - commonCircle.xy)/distance(commonCircle.xy, pqMid);
    vec2 a = u * commonCircle.z * (sin(4.3) * 6. + 6.72) + commonCircle.xy;
    c1.xy = a;
    c1.z = distance(a, p);

    vec3 aq = getLine(a, q);
    vec3 qrMidPer = getLine(commonCircle.xy, (q + r) / 2.);
    vec2 b = calcIntersection(aq, qrMidPer);
    c2.xy = b;
    c2.z = distance(b, q);

    vec3 br = getLine(b, r);
    vec3 rsMidPer = getLine(commonCircle.xy, (r + s) / 2.);
    vec2 c = calcIntersection(br, rsMidPer);
    c3.xy = c;
    c3.z = distance(c, r);

    vec3 cs = getLine(c, s);
    vec3 spMidPer = getLine(commonCircle.xy, (s + p) / 2.);
    vec2 d = calcIntersection(cs, spMidPer);
    c4.xy = d;
    c4.z = distance(d, s);
}

// Function 2141
float sdPolyspline(in vec2 p, in vec2[N] cp) {
    // Complete the first segment of the polyspline
    vec2 v1 = cp[0], v2 = vec2(0.0), v3 = 0.5 * (cp[1] + v1);
    vec2 pa = p - v1, ba = v3 - v1;
    float d = dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));

    // Combine distances to quadratic beziers spanning each corner (vertex)
    for (int n=1; n < N - 1; n++) {
        v1 = 0.5 * (cp[n - 1] + cp[n]), v2 = cp[n], v3 = 0.5 * (cp[n] + cp[n + 1]);

        vec2 c1 = p - v1;
        vec2 c2 = 2.0 * v2 - v3 - v1;
        vec2 c3 = v1 - v2;

        // Solve a cubic to minimize the distance for the parameter
        float t3 = dot(c2, c2);
        float t2 = dot(c3, c2) * 3.0 / t3;
        float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;
        float t0 = dot(c1, c3) / t3;

        float t22 = t2 * t2;
        vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);
        float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;

        float p2 = abs(pq.x);
        float r1 = 1.5 / pq.x * pq.y;

        if (qq * 0.25 + ppp / 27.0 > 0.0) {
            float r2 = r1 * sqrt(3.0 / p2), root;
            if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);
            else root = sinh(asinh(r2) / 3.0);
            root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);
            d = min(d, dot2(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)));
        }

        else {
            float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;
            vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);
            d = min(d, dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x)));
            d = min(d, dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y)));
        }
    }

    // Complete the last segment of the polyspline
    v1 = cp[N - 1], v2 = vec2(0.0), v3 = 0.5 * (cp[N - 2] + v1);
    pa = p - v1, ba = v3 - v1;
    d = min(d, dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));

    return sqrt(d);
}

// Function 2142
void waveRect(float sx, float x, float y, float w, float h, float p, float u, vec4 clr) {
	vec2 c = fragCoord.xy;
	if (c.x >= x && c.x < x + w) {
		if (c.y > y + sinLerp(c.x - sx, p) * u && c.y < y + h + sinLerp(c.x - sx, p) * u) {
			fragColor = clr;
		}
	}
}

// Function 2143
float drawFloat(float v,int p,int m){float c=0.,tpx=tp.x-FONT_SPACE*float(m);
 if (v<0.){c=char(45);v=-v;}tp.x-=FONT_SPACE; //write "-"
 c+=drawInt(int(v),1);c+=char(46);SPACE;//write floor()+"."+fract()    
 c+=drawFract(p,fract(v));tp.x=min(tp.x,tpx);return c;}

// Function 2144
float drawWall(in vec2 p, vec2 dr) {
    p = fract(rotateTo(p, dr)) - .5;
    p.y = max(0., -p.y);
    return length(p)-0.1;
}

// Function 2145
void draw_block_at(int el_pos, int el_ID) {
    block_byid(el_ID);
    int gid = el_pos;
    for (int i = 0 + alp; i < b_sizes[el_ID][1]; i++) {
        for (int j = 0 + alp; j < b_sizes[el_ID][0]; j++) {
            if ((gid >= msize.x * msize.y) || (gid < 0))break;
            if (block_it[i * bsize + j] == 1)map[gid] = 1;
            gid++;
        }
        gid += 10 - b_sizes[el_ID][0];
    }
}

// Function 2146
float drawObject(in vec3 p){
    
    // Wrap conditions:
    // Anything that wraps the domain will work.
    //p = cos(p*6.2831853)*.25 + .25; 
    //p = abs(cos(p*3.14159)*.5);
    //p = fract(p) - .5; 
    //p = abs(fract(p) - .5); 
  
    // Distance metrics:
    // Here are just a few variations. There are way too many to list them all,
    // but you can try combinations with "min," and so forth, to create some
    // interesting combinations.
    
    // Spherical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5;    
    //return dot(p, p)/1.5;
    
    // Octahedral... kind of.
    //p = abs(fract(p)-.5);
    //return dot(p, vec3(.333));
    
    // Triangular tube - Doesn't wrap, but it's here for completeness.
    //p = fract(p) - .5;
    //p = max(abs(p)*.866025 + p.yzx*.5, -p.yzx);
    //return max(max(p.x, p.y), p.z);    
    
    // Cubic.
    //p = abs(fract(p) - .5); 
    //return max(max(p.x, p.y), p.z);
    
    // Cylindrical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5; 
    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));
    
    // Octahedral.
    //p = abs(fract(p) - .5); 
    //p += p.yzx;
    //return max(max(p.x, p.y), p.z)*.5;

    // Hexagonal tube.
    p = abs(fract(p) - .5); 
    p = max(p*.866025 + p.yzx*.5, p.yzx);
    return max(max(p.x, p.y), p.z);
    
    
}

// Function 2147
float distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //e = capped [0,1] orthogonal projection of ap on ab
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 2148
vec3 cameraDirection() 
{
    return loadValue(slotCameraForward).xyz;
}

// Function 2149
void GetDataBilinear (in vec2 adjustedFragCoord, out vec3 normal, out vec3 materialDiffuse, out int materialIndex, out float hitDepth, out vec2 uv)
{   
    adjustedFragCoord-= 0.5;
    vec2 fragFract = fract(adjustedFragCoord);    
    
    // get the four data points from each texture
    vec2 uvMin = adjustedFragCoord / iResolution.xy;
    vec2 uvMax = (adjustedFragCoord + vec2(1.0)) / iResolution.xy;
    
    vec4 dataA00 = texture(iChannel0, uvMin);
    vec4 dataA10 = texture(iChannel0, vec2(uvMax.x, uvMin.y));
    vec4 dataA01 = texture(iChannel0, vec2(uvMin.x, uvMax.y));
    vec4 dataA11 = texture(iChannel0, uvMax);
    vec4 dataB00 = texture(iChannel1, uvMin);
    vec4 dataB10 = texture(iChannel1, vec2(uvMax.x, uvMin.y));
    vec4 dataB01 = texture(iChannel1, vec2(uvMin.x, uvMax.y));
    vec4 dataB11 = texture(iChannel1, uvMax);    
    
    // decode the data
    vec3 normal00, normal10, normal01, normal11;
    vec3 materialDiffuse00, materialDiffuse10, materialDiffuse01, materialDiffuse11;
    float materialIndex00, materialIndex10, materialIndex01, materialIndex11;
    float hitDepth00, hitDepth01, hitDepth10, hitDepth11;
    vec2 uv00, uv01, uv10, uv11;
    DecodeData(dataA00, dataB00, normal00, materialDiffuse00, materialIndex, hitDepth00, uv00); materialIndex00 = float(materialIndex);
    DecodeData(dataA10, dataB10, normal10, materialDiffuse10, materialIndex, hitDepth10, uv10); materialIndex10 = float(materialIndex);
    DecodeData(dataA01, dataB01, normal01, materialDiffuse01, materialIndex, hitDepth01, uv01); materialIndex01 = float(materialIndex);
    DecodeData(dataA11, dataB11, normal11, materialDiffuse11, materialIndex, hitDepth11, uv11); materialIndex11 = float(materialIndex);
    
    // bilinear interpolate the data
    
    // use nlerp on the normal
    vec3 normalx0 = mix(normal00, normal10, fragFract.x);
    vec3 normalx1 = mix(normal01, normal11, fragFract.x);
    normal = normalize(mix(normalx0, normalx1, fragFract.y));
    
    vec3 materialDiffusex0 = mix(materialDiffuse00, materialDiffuse10, fragFract.x);
    vec3 materialDiffusex1 = mix(materialDiffuse01, materialDiffuse11, fragFract.x);
    materialDiffuse = mix(materialDiffusex0, materialDiffusex1, fragFract.y);

    /*
    float materialIndexx0 = mix(materialIndex00, materialIndex10, fragFract.x);
    float materialIndexx1 = mix(materialIndex01, materialIndex11, fragFract.x);
    materialIndex = int(mix(materialIndexx0, materialIndexx1, fragFract.y) + 0.5);    
	*/
    
    // use nearest neighbor for material index.
    if (fragFract.x >= 0.5)
    {
        // it's between 10 and 11
        
        if (fragFract.y >= 0.5)
            materialIndex = int(materialIndex11);
        else
    		materialIndex = int(materialIndex10);
    }
    else
    {
        // it's between 00 and 01
        
        if (fragFract.y >= 0.5)
            materialIndex = int(materialIndex01);
        else
    		materialIndex = int(materialIndex00);        
    }
    
    float hitDepthx0 = mix(hitDepth00, hitDepth10, fragFract.x);
    float hitDepthx1 = mix(hitDepth01, hitDepth11, fragFract.x);
    hitDepth = mix(hitDepthx0, hitDepthx1, fragFract.y);
    
    vec2 uvx0 = mix(uv00, uv10, fragFract.x);
    vec2 uvx1 = mix(uv01, uv11, fragFract.x);
    uv = mix(uvx0, uvx1, fragFract.y);    
}

// Function 2150
float lineArrow(vec2 p, vec2 p1, vec2 p2, float a) {
	vec2 v = p2 - p1;
	vec2 w = p - p1;
	float d = clamp(dot(w,v) / dot(v,v), 0., 1.);
	float l = length(w-v*d);
	a = max(a*d-3., l-a*d);
	return min(l, a)-.5;
}

// Function 2151
float sdHexagonCircumcircle(vec3 p, vec2 h) {
	vec3 q = abs(p);
	return max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);
	//this is mathematically equivalent to this line, but less efficient:
	//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);
}

// Function 2152
float linearstep2( float x, vec2 p0, float s0 ) { return p0.y + s0 * ( x - p0.x ); }

// Function 2153
vec2 linePosition(in vec2 numLines)
{
  return vec2(
    mod(pos.x*numLines.x + 0.25,1.0),
    mod(pos.y*numLines.y + 0.5,1.0)); 
}

// Function 2154
v0 sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br//rounded rectangle
){vec2 d = max(tl-uv, uv-br)
 ;return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));}

// Function 2155
vec3 paisajeLineas(vec2 p, vec3 col)
{   vec2 uv=p;
    p.y=opRep1D(p.y, 0.025 );
    float d1= sdBox(p, vec2(16.0,0.0032) );
    vec4 col4= construccion(uv,col);   
    float dt=intersectSDF(d1,col4.w);
    col= DrawFig(vec3(1.0), col, dt);
    return col;
}

// Function 2156
float CanonLog3_to_linear ( float clog3)
{
float Out = 0.0;
if(clog3 < 0.097465473)
Out = -( pow( 10.0, ( 0.12783901 - clog3 ) / 0.36726845 ) - 1.0 ) / 14.98325;
else if(clog3 <= 0.15277891)
Out = ( clog3 - 0.12512219 ) / 1.9754798;
else
Out = ( pow( 10.0, ( clog3 - 0.12240537 ) / 0.36726845 ) - 1.0 ) / 14.98325;
return Out;
}

// Function 2157
float fLineSegment(vec2 p, vec2 a, vec2 b) {
	vec2 ab = b- a;
	float t = saturate(dot(p- a,ab)/ dot(ab,ab));
	return length((ab* t+ a)- p);
}

// Function 2158
bool line (vec2 p, vec2 a, vec2 b)
{
    // Direction from a to b.
    vec2 ab = normalize(b - a);
    
    // Direction from a to the pixel.
    vec2 ap = p - a;
    
    // Find the intersection of the pixel on to vector
    // from a to b, calculate the distance between the 
    // pixel and the intersection point, then compare
    // that distance to the line width.
    return length((a + ab * dot(ab, ap)) - p) < 0.0025;
}

// Function 2159
vec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)
{
    vec2 d1 = (p1b-p1a); //Direction Line 1
    vec2 d2 = (p2b-p2a); //Direction Line 2
    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere
    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance
    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)
    float t = 10000000.0 ; //INFINITY! (rare parallel case)
    if(rate != 0.0)
		t = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.
    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.
}

// Function 2160
vec4 DrawText( sampler2D sampler,float textSize, vec2 uv, vec2 pos, int idx, vec4 color, float flatText)
{
    float halfTextSize = textSize/2.0;
    vec3 mask = BoxMask(uv, pos, vec2(halfTextSize/16.,halfTextSize/16.));
    int x = idx % 16;
    int y = idx / 16;

    vec4 txtValue = texture(sampler,mask.xy/32.+vec2(float(x),float(y))/16.);
    float d = txtValue.w;
    d = smoothstep(0.49,0.5,1.-d);
    
    return vec4(d*color);
}

// Function 2161
void drawArrows(inout vec4 col)
{
  // draw triangle arrows and check input
  vec2 p1,p2,p3;

  getTriangleVertices (0,p1,p2,p3);
  bool inside1 = drawArrow (p1,p2,p3, col);
    
  getTriangleVertices (1,p1,p2,p3);
  drawArrow (p1,p2,p3, col);
}

// Function 2162
void DrawPalmTree(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    float t2 = min(t/0.8, 1.);
    float texpNormPow = pow(t2, 0.5);

    DrawGlow(p, t, fireColor, color);

    for(float i=0.; i < 20.5; ++i)
    {   
        // Main Properties
        float hashP = hash(i*642.856+198.5984);
        float pSpeed = (0.5 + 1.0*hashP);
        vec2 pVel = normalize( vec2(0., 1.25) + vec2(hash(i*98.985), hash(45.6924*hash(i))) * 2. -1.).xy;

        vec3 pColor = clamp(mix(fireColor, vec3(pVel.x, pVel.y, pSpeed), hashP*0.6), 0., 1.);

        // Visibility Properties
        float sizeScale = 0.1+0.90* max(sin(pow(t, 0.8)*PI) + (hashP*2.-1.)*0.5 , 0.);
        
        float flickerFactor = smoothstep(0.8, 1.0, texpNormPow);
        float flicker = mix(1.0, max(sign(hash(i*958.15 + t) - 0.95), 0.), flickerFactor);
        pColor = mix(pColor, vec3(1.), flickerFactor);
        float size = sizeScale*expSize*0.4;

        // Position
        vec2 deltaPos = pVel*pSpeed*texpNormPow + (0.35*hashP+0.5)*gGravity*t2*t2;
        vec2 q = p - deltaPos;

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, (q + flickerFactor * 0.08*vec2(hash(i*99.592+t*100.1), hash(i*125.151+t*185.458))), size, 0.5, pColor, 0.1, 9.*hash(i+t*10.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
}

// Function 2163
float PointLineDist2d(vec2 a, vec2 n, vec2 p)
{
    //return length(p - (a + n * dot(p - a, n) / dot(n, n)));
    return length(p - (a + n * PointLineAlong2d(a, n, p)));
}

// Function 2164
bool isLinearValid(in int index, vec2 iResolution) {
    vec2 res = iResolution.xy;
	return index < int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));
}

// Function 2165
void drawBottomPipe(vec2 co, float xPos, float height)
{	
	if ((co.x < xPos) || (co.x > (xPos + PIPE_WIDTH)) ||
		(co.y < PIPE_BOTTOM) || (co.y > (PIPE_BOTTOM + height)))
	{
		return;
	}
	
	// draw the bottom part of the pipe
	// outlines
	float bottomPartEnd = PIPE_BOTTOM - PIPE_HOLE_HEIGHT + height;
	drawVertLine(co, xPos+1.0, PIPE_BOTTOM, bottomPartEnd, PIPE_OUTLINE_COLOR);
	drawVertLine(co, xPos+PIPE_WIDTH-2.0, PIPE_WIDTH, bottomPartEnd, PIPE_OUTLINE_COLOR);
	
	// gradient fills
	drawHorzGradientRect(co, vec2(xPos+2.0, PIPE_BOTTOM), vec2(xPos + 10.0, bottomPartEnd), RGB(133, 168, 75), RGB(228, 250, 145)); 
	drawHorzGradientRect(co, vec2(xPos+10.0, PIPE_BOTTOM), vec2(xPos + 20.0, bottomPartEnd), RGB(228, 250, 145), RGB(86, 126, 41)); 
	drawHorzGradientRect(co, vec2(xPos+20.0, PIPE_BOTTOM), vec2(xPos + 24.0, bottomPartEnd), RGB(86, 126, 41), RGB(86, 126, 41));
	
	// shadows
	drawHorzLine(co, bottomPartEnd - 1.0, xPos + 2.0, xPos+PIPE_WIDTH-2.0, RGB(86, 126, 41));
	
	// draw the pipe opening
	// outlines
	drawVertLine(co, xPos, bottomPartEnd, bottomPartEnd + PIPE_HOLE_HEIGHT, PIPE_OUTLINE_COLOR);
	drawVertLine(co, xPos+PIPE_WIDTH-1.0, bottomPartEnd, bottomPartEnd + PIPE_HOLE_HEIGHT, PIPE_OUTLINE_COLOR);	
	drawHorzLine(co, bottomPartEnd, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);
	drawHorzLine(co, bottomPartEnd + PIPE_HOLE_HEIGHT-1.0, xPos, xPos+PIPE_WIDTH-1.0, PIPE_OUTLINE_COLOR);

	// gradient fills
	float gradientBottom = bottomPartEnd + 1.0;
	float gradientTop = bottomPartEnd + PIPE_HOLE_HEIGHT - 1.0;
	drawHorzGradientRect(co, vec2(xPos+1.0, gradientBottom), vec2(xPos + 5.0, gradientTop), RGB(221, 234, 131), RGB(228, 250, 145)); 
	drawHorzGradientRect(co, vec2(xPos+5.0, gradientBottom), vec2(xPos + 22.0, gradientTop), RGB(228, 250, 145), RGB(86, 126, 41)); 
	drawHorzGradientRect(co, vec2(xPos+22.0, gradientBottom), vec2(xPos + 25.0, gradientTop), RGB(86, 126, 41), RGB(86, 126, 41));
	
	// shadows
	drawHorzLine(co, gradientBottom, xPos+1.0, xPos+25.0, RGB(86, 126, 41));
	drawHorzLine(co, gradientTop-1.0, xPos+1.0, xPos+25.0, RGB(122, 158, 67));
}

// Function 2166
float circleSample(vec2 dist, vec2 center)
{
    vec2 curRadius = vec2(0.0);
	float returnValue = 0.0;
    
    for (int c = 0; c < CIRCLE_NUMBER; ++c)
    {
    	float normalizedAngle = 0.0;
        curRadius += dist;
        for (int s = 0; s < SAMPLE_PER_CIRCLE; ++s)
        {
            float angle = normalizedAngle * 3.1415 * 2.0;
            vec2 uvToSample = center + vec2(cos(angle), sin(angle)) * curRadius;
            vec3 sampledColor = texture(iChannel0, uvToSample).rgb;
            if (passTest(sampledColor) == false)
                returnValue += 1.0 / float(CIRCLE_NUMBER * SAMPLE_PER_CIRCLE);
            normalizedAngle += 1.0 / float(SAMPLE_PER_CIRCLE);
        }
    }
    return (returnValue);
}

// Function 2167
void drawDragDots(inout v3 s,v1 u,inout v1 e//loop trough all dots and accumulate colors.
){v0 f=0.
 ;for(v0 i=0.;i<maxCount;++i
 ){if(i>=s.y)break//bound by number of instantiated UIDots
  ;f=dd(u-bufDrag(i).xy)
  ;e=v1(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}
 ;}

// Function 2168
vec2 toRect (in vec2 p)
{
  float x = p.x*cos (p.y);
  float y = p.x*sin (p.y);
  return vec2 (x, y); 
}

// Function 2169
vec4 iTrilinearIsoSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {
    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);
    vec3 v = vec3(b, c, e) - a;

    vec3 xxyyzz = ro.xxy * ro.yzz;
    vec3 uuvvww = rd.xxy * rd.yzz;

    float t3 = u.x * rd.x * rd.y * rd.z;
    float t2 = dot(ro.zyx, uuvvww) * u.x + dot(u.yzw, uuvvww);
    float t1 = dot(u, vec4(dot(xxyyzz, rd.zyx), dot(ro.xy, rd.yx), dot(ro.xz, rd.zx), dot(ro.yz, rd.zy))) + dot(v, rd);
    float t0 = u.x * ro.x * ro.y * ro.z + dot(u.yzw, xxyyzz) + dot(v, ro) + a;

    t3 += 0.000001; // To deal with precision issues that seem to arise with this surface

    vec4 hits;
    hits.w = float(solveCubic(t3, t2, t1, t0, hits.xyz));

    return hits;
}

// Function 2170
float drawtriangle(vec2 uv){
    uv+=0.5;
    uv.y-=0.18;
    uv = uv *2.-1.;
    uv.x/=1.7;
    uv*=20.;
    int N = 3;
    float a = atan(uv.x,uv.y);
    float r = TWO_PI/float(N);
    return 1.0-smoothstep(.4,.541,cos(floor(.5+a/r)*r-a)*length(uv));
}

// Function 2171
float circle(vec2 center , float radius,float thickness,float la,float ha)
{
	float f = length(center);
	
	float a = atan(center.y,center.x) ;
	return(smoothstep(f,f+0.01,radius) * smoothstep(radius - thickness,radius - thickness+0.01,f) * step(la,a)*step(a,ha));
}

// Function 2172
float line( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = -p - a;
    vec2 ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    float d = length( pa - ba*h );
    
    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0);
}

// Function 2173
void DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )
{
    color = RGB( 0, 0, 0 );
        
    float offset 	= 18.0;     
    float textX 	= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );
    float textY 	= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );
    float marioX	= textX - offset * 4.0;
    float marioY	= textY + 16.0 * 3.0;
	
    DrawW( color, textX - offset * 0.0, textY );
    DrawO( color, textX - offset * 1.0, textY );
    DrawR( color, textX - offset * 2.0, textY );
    DrawL( color, textX - offset * 3.0, textY );
    DrawD( color, textX - offset * 4.0, textY );
    Draw1( color, textX - offset * 6.0, textY );
    DrawM( color, textX - offset * 7.0, textY );
    Draw1( color, textX - offset * 8.0, textY );
    
    if ( marioX >= 0.0 && marioX <= 15.0 )
    {
    	SpriteMario( color, marioX, marioY, 4.0 );
    }
}

// Function 2174
float circle (vec2 p, vec2 o, float r) {
	return abs (length (p - o) - r);
}

// Function 2175
vec3 calcDirectLight( vec3 pos, out vec3 wi, Sphere lightSphere, vec3 lightColor ) {
    vec3 Li = lightColor;
    vec3 Lo = vec3( 0.0 );
    
    vec3 dirToLightCenter = lightSphere.pos - pos;
    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);
    float cos_a_max = sqrt( 1.0 - clamp( lightSphere.radiusSq / distToLightCenter2, 0.0, 1.0 ) );
    float omega = TWO_PI * (1.0 - cos_a_max);	//solid angle
    float cosa = mix(cos_a_max, 1.0, rnd());
    float sina = sqrt(1.0 - cosa*cosa);

    wi = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );
    float pWi = (1.0/omega);

    Ray shadowRay = Ray( pos, wi );
    float dist;
    raySphereIntersection( shadowRay, lightSphere, dist );

    float tmpDist;
    RayHit tmpHit;
    int tmpObjId;
    raySceneIntersection( shadowRay, EPSILON, tmpHit, tmpObjId, tmpDist );
    float eps = tmpDist*0.0001;

    if( EQUAL_FLT( tmpDist, dist, eps ) ) {
        float throughput = exp(-VOLUME_EXTINCTION * dist);
        Lo += throughput * Li / pWi;
    }

    return Lo;
}

// Function 2176
float ShortLine( vec2 a, vec2 b, vec2 p )
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba)/dot(ba,ba), gSegmentGap * 2.0, 1.0 - (gSegmentGap * 2.0));
    return smoothstep(gSegmentWidth, gSegmentWidth * 0.9, Manhattan(pa - ba*t));
}

// Function 2177
float specular_directional(vec3 n, vec3 l, vec3 v, float strength)
{
      vec3 r=reflect(normalize(l),n);
      return pow(max(dot(v,r),.0),128.)*strength;
}

// Function 2178
float drawScene(vec3 p, out int id)
{
    vec3 position = p + vec3(-1.5,-1.,-3.+2.*sin(iTime));
    float dt = 	sdSphere(position,.5);
    id = 0;
    float d;
    
    position = p + vec3(2.5*sin(iTime),-2.5,0.);
    vec3 ppp = (rotate(PI*.25+.25*sin(iTime),vec3(1.,0.,0.)) * vec4(position,1.)).xyz;
    d = sdTorus( ppp, vec2(1.,.2) );
    if( d < dt )
    {
        dt = d; 
        id = 1;
    }

    position = p + vec3(3.*cos(iTime),-1.0,0.);
    d = udBox( position,vec3(.5) );
    if( d < dt )
    {
        dt = d; 
        id = 2;
    }

    position = p + vec3(2.,-.7,-2.5);
    d = sdEllipsoid( position, vec3(.3,1.5,1.) );
    if( d < dt )
    {
        dt = d; 
        id = 3;
    }

    // floor
    position = p + vec3(0.,1,0.);
    d = udBox( position,vec3(10.,.0,10.5) );
	//    d = sdPlane(position);
    if( d < dt )
    {
        dt = d; 
        id = 4;
    }
    
    // wall
    position = p + vec3(0.,0.,1.7);
    d = udBox( position,vec3(10.,10.0,0.5) );
	//    d = sdPlane(position);
    if( d < dt )
    {
        dt = d; 
        id = 4;
    }


    
	return dt;
}

// Function 2179
float Circle(vec2 point, float radius, float slope, vec2 uv)
{
    return smoothstep(radius + slope, radius - slope, length(uv - point));
}

// Function 2180
void DrawGrass (in vec2 uv, inout vec3 pixelColor, in vec3 tint, in float scale)
{
    // draws periodic grass tufts
    vec2 grassOrigin;
    grassOrigin.x = floor(uv.x / c_grassDistance) * c_grassDistance + c_grassDistance * 0.5;
    grassOrigin.y = GroundHeightAtX(grassOrigin.x, scale);    
    
    float forceTop = RandomFloat(grassOrigin + vec2(0.342, 0.856)) > 0.25 ? 1.0 : 0.0;
    grassOrigin.y -= forceTop * (RandomFloat(grassOrigin + vec2(0.756, 0.564)) * c_grassMaxDepth);
    
    vec2 grassYAxis = -GroundFunctionGradiant(grassOrigin, scale);
    vec2 grassXAxis = vec2(grassYAxis.y, -grassYAxis.x);
    
    vec2 uvRelative = uv - grassOrigin;
    vec2 uvLocal;
    uvLocal.x = dot(uvRelative, grassXAxis);
    uvLocal.y = dot(uvRelative, grassYAxis);
    uvLocal /= scale;
    
    float snowLine = sin(uv.x*2.35) * 0.1 + sin(uv.x*3.14) * 0.01;
    float grassStoneMix = smoothstep(snowLine-0.3, snowLine+0.3, uv.y);        
    vec3 grassColor = mix(vec3(0.3,0.4,0.1),vec3(0.7,0.8,0.5),grassStoneMix * 0.5);
    
    // draw a few random tufts
    for (int i = 0; i < 5; ++i)
    {
    	vec2 endPoint;
        endPoint.x = (RandomFloat(grassOrigin + vec2(0.254, 0.873) * float(i)) * 2.0 - 1.0) * 0.1;
        endPoint.y = RandomFloat(grassOrigin + vec2(0.254, 0.873) * float(i)) * 0.03 + 0.02;
        
        vec2 startingOffset;
        startingOffset.x = endPoint.x  * 0.6;
        startingOffset.y = 0.0;
        
    	float tuftDistance = UDFatLineSegment(uvLocal, startingOffset, endPoint, 0.01);
    	tuftDistance = 1.0 - smoothstep(0.0, AA_AMOUNT, tuftDistance);
		pixelColor = mix(pixelColor, grassColor * tint, tuftDistance);
    }
}

// Function 2181
float point_distance_line(vec2 a, vec2 b, vec2 point) {
	return length((point) - (closest_point_line(a, b, point)));
}

// Function 2182
float lines( vec2 p )
{
    float l = 0.;
    
    l = max( l, line( p, vec2(1.,0.), true ) );
    
    if( bool( 10 ) )
    {
        l = max( l, line( p, vec2(1.,1.)/sqrt(2.), true ) );
        l = max( l, line( p, vec2(1.,-1.)/sqrt(2.), true ) );
        l = max( l, line( p, vec2(0.,1.), true ) );
    }
    
    return l;
}

// Function 2183
vec2 DirectHalton(uint index) {
    uvec2 base = uvec2(2,3);	// base to use for each dimension
    uvec2 value = uvec2(index); // digits not processed yet
    uvec2 result = uvec2(0);    // digits processed so far
    uvec2 scale = uvec2(1);     // scale for all digits processed

    // loop as long as there are digits left
    while (value != uvec2(0)) {
        uvec2 next = value/base; // next value without least significant digit
        result = result*base + (value-next*base); // add digit to result
        scale *= base;          // record that we had another digit
        value = next;           // update current value
    }

    // rescale to final position
    return vec2(result)/vec2(scale);
}

// Function 2184
vec3 circleClone( vec3 p, float num, out float id ) {
    vec3 pp = p;
    float angleArea = PI * 2.0 / num;
    float originangle = atan( pp.x, pp.z );
    float angle = mod( originangle, angleArea ) - angleArea * 0.5;
    id = floor(originangle / angleArea);
    
    float shake = cos( pp.y * 2.0 + time * 2.0 + id) * 0.2;
    pp.xz += normalize( pp.xz ) * shake * smoothstep( -0.3, -1.0, pp.y );
    float len = length( pp.xz );
    
    vec3 modPos = vec3( cos( angle ) * len, p.y, sin( angle ) * len );
    return modPos;
}

// Function 2185
float dofLine(vec3 c0, vec3 c1, float ra, vec3 p0, vec3 p1)
{
    float dlen = length(p1 - p0);
    vec3 dir = (p1 - p0) / dlen;
    
    // Test for intersection of the line segment with the cone of defocused rays.
    
    vec2 res = iCappedCone2(p0, dir, c0, c1, ra, 0.);
    
    if(res.y < 0. || res.x > dlen)
    {
        // To avoid rendering subpixel-sized lines which would end up being heavily under-sampled,
        // the center of the defocus cone is modelled as a thick cylinder.
        
        vec2 res2 = iCylinder2(p0, dir, c0, c1, 2e-3);

        if(res2.y > res2.x && res2.y > 0. && res2.x < dlen)
        {
            res.x = min(res.x, res2.x);
            res.y = max(res.y, res2.y);
        }
        
        if(res.y < 0. || res.x > dlen)
            return 0.;
    }
    
    vec3 q0 = p0 + dir * res.x;
    vec3 q1 = p0 + dir * res.y;

    // Contribution is modelled somewhat on the usual monte carlo raytracing.
    // This amounts to integrating coverage of a varying disc by a small point.
    // Function to integrate is: 1 / (pi * ((a * x + b) ^ 2))
    // Integral is: -1 / (pi * a * a * x + pi * a * b)
    
    vec3 cd = c1 - c0;
    float cl2 = ra / dot(cd, cd);

    float z0 = dot(q0 - c1, cd);
    float z1 = dot(q1 - c1, cd);

    float a = cl2 * (z1 - z0);
    float b = cl2 * z0;

    float i0 = pi * a * b;
    float i1 = pi * a * (a + b);
    
    i0 = 1e-4 / max(1e-10, abs(i0)) * sign(i0);
	i1 = 1e-4 / max(1e-10, abs(i1)) * sign(i1);
    
    return min(1., abs(i1 - i0));
}

// Function 2186
vec4 LineSegCoord(vec2 p1, vec2 p2, vec2 uv, out float segmentLength){
    

    vec2 vector = p2 - p1;                         // Find the vector between the two lines
          uv   -= p1;                              // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point
    float len   = max(length(vector), 0.01);                  // Find the ditance between the two points
       vector  /= len;                             // normalize the vector 
    float vUv   = dot(vector, uv);                 // Find out how far the projection of the current pixel on the line goes along the line using dot product
    vec2  p     = vector * clamp(vUv, 0.,len) ;    // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line
    vec2 ToLine = p - uv;                       
    float d     = length(ToLine);                  // the actual distance between the current pixel and its projection on the line
    
    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something
    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative
    segmentLength = len;
    
                                                   // fourth component is used for drawing the branch thickness, is a noramlized value stating how far the pixel is between p1 nad p2
    return vec4(vUv, d, signedD, clamp(vUv, 0.,len)/ len); 
}

// Function 2187
float lineDist(vec2 p, vec2 start, vec2 end, float width)
{
	vec2 dir = start - end;
	float lngth = length(dir);
	dir /= lngth;
	vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;
	return length( (start - p) - proj ) - (width / 2.0);
}

// Function 2188
Model drawBloom(vec3 p, float t, BloomSpec spec) {
    p /= spec.size;
    globalScale *= spec.size;
    Model model;
    float bound = length(p) - mix(.7, mix(.8, 2.4, spec.width), t);
    if ( ! lightingPass && bound > boundEps / globalScale) {
		model = newModel();
        model.d = bound;
        model.neg = bound;
        model.isBound = true;
    } else {
        model = drawBloom(
            p,
            t,
            spec.density,
            spec.thickness,
            spec.pointy,
            spec.width,
            spec.hideInside
        );
    }
    model.d *= spec.size;
    model.neg *= spec.size;
    globalScale /= spec.size;
	return model;
}

// Function 2189
float intersect_plane_line(vec4 plane, vec3 ro, vec3 rd) {    
    vec3 p0 = -dot(vec4(ro,1.0), plane)*plane.xyz;
    return dot(p0, plane.xyz) / dot(rd, plane.xyz);
}

// Function 2190
vec4 SPLINE_catmullRom(float fTime, SPLINE_CtrlPts ctrlPts)
{
    float t = fract(fTime);
    const float n = float(SPLINE_POINT_COUNT);
    
    int idxOffset = int(t*n);
    vec4 p1 = SPLINE_PointArray(idxOffset,ctrlPts);
    vec4 p2 = SPLINE_PointArray(idxOffset+1,ctrlPts);
    vec4 p3 = SPLINE_PointArray(idxOffset+2,ctrlPts);
    vec4 p4 = SPLINE_PointArray(idxOffset+3,ctrlPts);
    
    //For some reason, fract(t) returns garbage on my machine with small values of t.
    //return fract(n*t);
    //Using this below yields the same results, minus the glitches.
    t *= n;
    t = (t-float(int(t)));
    
    //A classic catmull-rom
    //e.g.
    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html
    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/
    vec4 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t
               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t
               + (-p1+p3)*t
               + 2.*p2);
    return val;
}

// Function 2191
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	vec2 r = rand2();
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 2192
float drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){
    p-=location; p/= float(zoom);
    float n = floor(p.x / 5.0); //current char index 
    p.x -= n*5.; //move origin
    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds
    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign 
    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length
    float count = intCount + fractPrecision; //totla number of digits to print 
    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point 
    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  
    if(count <= n)  return 0.0; //no need to draw more
    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   
}

// Function 2193
float sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)
{
    vec2 d = max(tl-uv, uv-br);
    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));
}

// Function 2194
void draw(inout vec4 color, sampler2D sp, vec2 uv, float lod, vec2 center) {
    uv = scale_uv(uv, vec2(pow(2.0, lod)), center);
    
    if (uv.x >= -0.1 && uv.x <= 1.1 && uv.y >= -0.1 && uv.y <= 1.1)
        color += textureLod(sp, uv, lod);
}

// Function 2195
float sd2circle(vec2 d,float R) {
    return dot(d,d)-R*R;
}

// Function 2196
vec2 Circle(vec2 circle_origin, float circle_radius, float thickness, vec2 uv, float pixel_uv_size)
{
	float d = distance(uv, circle_origin);

	float surface	= abs(d - circle_radius) - thickness * 0.5;
	float colour	= smoothstep(pixel_uv_size, 0.0, surface);
	float alpha		= (d < circle_radius) ? 1.0 : colour;

	return vec2(colour, alpha);
}

// Function 2197
vec4 drawPage(int pageNumber, ivec2 position, ivec2 offset)
{
    const ivec4 textNumbersPerPage[8] = ivec4[](
        ivec4(0, 2, 4, 6), ivec4(8, 10, 12, 14), ivec4(16, 18, 20, 22), ivec4(24, 26, 28, 30),
        ivec4(19, 1, 9, 27), ivec4(15, 23, 17, 25), ivec4(11, 29, 31, 5), ivec4(13, 21, 3, 7));
    
    ivec4 textNumbers = textNumbersPerPage[pageNumber];
    
    int highlight = read(HIGHLIGHT);

    return ((drawText(textNumbers.x, menuLineOffsets[0] + offset, position, false)) ?
            ((highlight == HIGHLIGHT_LINE_0) ? highlightColor : fontColor) :
            vec4(0.0)) +
        ((drawText(textNumbers.y, menuLineOffsets[1] + offset, position, false)) ?
            ((highlight == HIGHLIGHT_LINE_1) ? highlightColor : fontColor) :
            vec4(0.0)) +
        ((drawText(textNumbers.z, menuLineOffsets[2] + offset, position, false)) ?
            ((highlight == HIGHLIGHT_LINE_2) ? highlightColor : fontColor) :
            vec4(0.0)) +
        ((drawText(textNumbers.w, menuLineOffsets[3] + offset, position, false)) ?
            ((highlight == HIGHLIGHT_LINE_3) ? highlightColor : fontColor) :
            vec4(0.0)) +
        float((pageNumber & 3) > 0) * drawArrow(true, (highlight == HIGHLIGHT_ARROW_UP), position, arrowUpOffset) +
        float((pageNumber & 3) < 3) * drawArrow(false, (highlight == HIGHLIGHT_ARROW_DOWN), position, arrowDownOffset);
}

// Function 2198
maybe_float get_distance_along_3d_line_to_triangle(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in vec3 B3
){
    // intersection(face plane, edge plane, edge plane, edge plane)
    vec3 B0 = (B1 + B2 + B3) / 3.;
    vec3 N = normalize(cross(B1 - B2, B2 - B3));
    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);
    vec3 At = A0 + A * t.value;
    vec3 B2B1hat = normalize(B2 - B1);
    vec3 B3B2hat = normalize(B3 - B2);
    vec3 B1B3hat = normalize(B1 - B3);
    return maybe_float(t.value, 
        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) && 
        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) && 
        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)
    );
}

// Function 2199
float lineDist2D(vec2 a, vec2 b, vec2 p) {
    return lineDist2D(line2D(a, b), p);
}

// Function 2200
float line(vec2 p, vec2 a, vec2 b, float w) {
    vec2 ab = normalize(b - a);
    vec2 ap = p - a;
    vec2 bp = p - b;
    float d0 = dot(ap, ab);// / length(ab);
    float d1 = dot(bp, -ab);// / length(ab);
    
    

    if (d0 < 0. || d1 < 0.) {
        return 0.;
    }
    
    return AA(w - distance(ab * d0, ap));
}

// Function 2201
vec3 randomSphereDirection() {
    lowp vec2 r = hash2()*6.2831;
	lowp vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dr;
}

// Function 2202
vec2 polar2Rect(in vec2 uv)
{
    vec2 _uv = uv;
    uv.x = cos(_uv.x)*_uv.y;
    uv.y = sin(_uv.x)*_uv.y;
    return uv;
}

// Function 2203
float line(vec3 ray, vec3 pos, float size)
{
    ray = abs(ray-pos) - size;
    return max(ray.z,ray.y);
}

// Function 2204
float rectSDF(vec2 st, vec2 s)
{
    return max(abs(st.x/s.x),abs(st.y/s.y));
}

// Function 2205
vec4 draw_start_box(vec2 world_coords) {
    mat3 offset = get_trans_mat(
        MAP_START_LINE.z, // angle
        MAP_START_LINE.xy, // position
        vec2(0.5) // scale
    );
    
    float sdf = draw_sprite(
        world_coords,
        SPRITE_START_BOX,
        offset
    ).b;
    return neon(sdf, vec4(1.0, 1.0, 1.0, 1.0), 0.05) * 0.2;
}

// Function 2206
vec3 drawcircle(vec2 z, vec3 col, vec3 ccol, vec3 circle) {
  float d = abs(length(z-circle.xy) - sqrt(abs(circle.z)));
  return draw(d,col,ccol,fwidth(z.x));
}

// Function 2207
void drawSprite_32x16( inout vec3 col, int spr[64], vec3 pal[16], vec2 p, vec2 s ) {
    ivec2 i = ivec2( floor(p-s) );
    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<16 ) {
        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;
        if (pal[pi].r>-0.5) col = pal[pi];
    }
}

// Function 2208
void drawR(vec2 uv, inout vec4 col)
{
    uv += vec2(.08,.05);
    backBar(uv-vec2(.4,.2), col);
    lserif(uv-vec2(.4,.2), col);
    userif(uv*vec2(1.,-1) + vec2(-0.4, 0.9), col);
    roundThing(uv-vec2(.5,.717), col);
    diagBar(uv-vec2(0.22,.36), col);
}

// Function 2209
void raytraceTreeline(vec3 u,vec3 d,vec4 a,inout vec3 color,inout float nearestD){ 
 float t=floor((u.x+d.x*(a.x-u.z)/d.z-a.z)/a.y)*a.y+a.y*.5+a.z;
 if(abs(t)>240.)return;
 raytraceTree(u,d,vec3(t,a.w,a.x),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,
              sin(t*.85+a.x),color,nearestD);}

// Function 2210
float shipRect(vec2 p, vec2 center, vec2 size) {
    vec2 hs = size / 2.;
    p -= center;
    vec2 c = (p / hs) * 1.5;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
    vec2 z = vec2(0.);
    for(int i = 0 ; i < 1024; i++){
        z = abs(z);
    	z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;

        if( dot(z, z) > 4.0){
        	return 1000.;
        }
    }
    return -1.;
}

// Function 2211
float RandRect (vec2 p)
{
  vec4 hm, hc;
  vec3 e;
  vec2 pMid[4], pEdge[4], ip;
  float dMin, hp, eFac;
  ip = floor (p) + 0.5;
  e = vec3 (-1., 0., 1.);
  hp = H(0.);
  hm = vec4 (H(e.zy), H(e.xy), H(e.yz), H(e.yx));
  hc = vec4 (H(e.zz), H(e.xx), H(e.xz), H(e.zx));
  if (mod (ip.x + ip.y, 2.) < 0.5) {
    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);
    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);
    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);
    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);
    pMid[0] = vec2 (hm.z, hp);
    pMid[1] = pMid[0];
    pMid[2] = vec2 (hm.w, hp);
    pMid[3] = pMid[2];
  } else {
    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);
    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);
    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);
    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);
    pMid[0] = vec2 (hp, hm.y);
    pMid[1] = vec2 (hp, hm.x);
    pMid[2] = pMid[1];
    pMid[3] = pMid[0];
  }
  eFac = 0.3;
  for (int k = 0; k < 4; k ++) {
    pEdge[k] = eFac * pEdge[k] + 0.5;
    pMid[k] = 2. * eFac * (pMid[k] - 0.5);
  }
  pMid[0] += pEdge[0] * e.xz;
  pMid[1] += pEdge[1] * e.zz;
  pMid[2] += pEdge[2] * e.zx;
  pMid[3] += pEdge[3] * e.xx;
  dMin = dstFar;
  for (int k = 0; k < 4; k ++)
     dMin = min (dMin, PrRoundBox2Df (p - ip - pMid[k], pEdge[k] - eFac + 0.05, 0.1));
  return dMin;
}

// Function 2212
float directionalOcclusionCapsule(in vec3 pos, in vec3 capsuleA, in vec3 capsuleB, in float capsuleRadius, in vec4 cone) {
    vec3 Ld = capsuleB - capsuleA;
    vec3 L0 = capsuleA - pos;
    float a = dot(cone.xyz, Ld);
    float t = saturate(dot(L0, a * cone.xyz - Ld) / (dot(Ld, Ld) - a * a));
    vec3 posToRay = capsuleA + t * Ld;

    return directionalOcclusionSphere(pos, vec4(posToRay, capsuleRadius), cone);
}

// Function 2213
vec3 calcPixelDirect(vec2 fc, vec3 ro) {
    vec2 p = (-iResolution.xy + 2.0*(fc))/iResolution.y;
    vec3 rd = normalize(cameraMatrix()*vec3(p, 1.97));
    
    return render(ro, rd);
}

// Function 2214
float draw_uint(vec2 p, int number){
    number = abs(number);
    
    // we draw numbers from right to left because we get digits in that order
    p.x += float(MAX_DIGITS - 1)*DIGIT_WIDTH;
    
    float color = 0.0;
    
    // decompose number into digits
    for (int i = 0; i < MAX_DIGITS; i++){
        int digit = imod(number, BASE);
        number = idiv(number, BASE);
        
        color += draw_digit(p, digit);
        
        p.x -= DIGIT_WIDTH;
    }
    
    return color;
}

// Function 2215
float distline(vec3 ro, vec3 rd, vec3 p) {
	return length(cross(p-ro, rd));
}

// Function 2216
float fLine(vec2 p, vec2 a, vec2 b) {
	vec2 ab = b - a;
	float t = clamp(dot(p - a, ab) / dot(ab, ab),0.0,1.0);
	return length((ab*t + a) - p);
}

// Function 2217
vec3 drawDisc(vec3 col, vec2 coord, vec2 pos, float radIn, float radOut, vec3 oldColor)
{
    float dst = distance(coord, pos);
    float aaf = fwidth(dst);
    return mix(oldColor, col, (smoothstep(radIn - aaf, radIn, dst) * (1.0 - smoothstep(radOut - aaf, radOut, dst))));
}

// Function 2218
bool CorrectFragment(vec2 fragCoord, vec2 position)
{
    return length(fragCoord - position) < 1.0;
}

// Function 2219
void drawCircle(inout vec4 baseCol, vec2 xy, vec2 center, float radius, vec4 color)
{
    float r = length(xy - center);
    float c = 1.0 - aaStep(0.0, radius + pp * AA_FALLOFF, r);
    blend(baseCol, color, c * c);
}

// Function 2220
float Line(vec2 p, vec2 a, vec2 b, float w)
{
    float d = DistLine(p, a, b);
    float m = S(w, w*0.333, d);
    float d2 = length(a-b);
    m *= S(1.2, 0.8, d2)*0.5 + S(0.05, 0.03, abs(d2-0.75));
    return m * 2.8;
}

// Function 2221
vec2 randomInCircle( void )
{
    float an = 6.283185*float(rand())/32767.0;
    return vec2(cos(an),sin(an));
}

// Function 2222
float drawRing(float radius0, float sharpness) {

	const float RING_THICKNESS = 0.010;
	float radius1 = radius0 - RING_THICKNESS;
	
	float d = distance(UNIT_VECTOR_ASPECT, vec2(0.5));
	return smoothstep(radius0 + sharpness, radius0, d)
		 * smoothstep(radius1 - sharpness, radius1, d);
}

// Function 2223
float srgb_linear(float x) {
    return mix(pow((x + 0.055)/1.055,2.4), x / 12.92, step(x,0.04045));
}

// Function 2224
bool RectInsideRect(vec4 rect1, vec4 rect2)
{
  if (rect1.z>rect2.x && rect1.x<rect2.z)
  {
    return (rect1.w>rect2.y && rect1.y<rect2.w);
  }
  return false;
}

// Function 2225
vec3 hyp_line_circle(vec2 a, vec2 b){
    vec2 a1 = comp_inv(conj(a));
    vec2 b1 = comp_inv(conj(b));
    
    vec2 p1 = 0.5*(a+a1);
    vec2 p2 = 0.5*(b+b1);
    
    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));
    float r = length(a - c);
    return vec3(c,r);
}

// Function 2226
void DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )
{
    float mushroomPauseStart 	= 16.25;    
    float mushroomPauseLength 	= 2.0;    
    float flagPauseStart		= 38.95;
    float flagPauseLength		= 1.5;

    float cameraP1		= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );
    float cameraP2		= clamp( time - flagPauseStart,     0.0, flagPauseLength );
    float cameraX 		= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );
    float worldX 		= pixelX + cameraX;
    float worldY  		= pixelY - 8.0;
    float tileX			= floor( worldX / 16.0 );
    float tileY			= floor( worldY / 16.0 );
    float tile2X		= floor( worldX / 32.0 );
    float tile2Y		= floor( worldY / 32.0 );    
    float worldXMod16	= mod( worldX, 16.0 );
    float worldYMod16 	= mod( worldY, 16.0 );


    // default background color
    color = RGB( 92, 148, 252 );

    
    // draw hills
    float bigHillX 	 = mod( worldX, 768.0 );
    float smallHillX = mod( worldX - 240.0, 768.0 );
    float hillX 	 = min( bigHillX, smallHillX );
    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );
    SpriteHill( color, hillX, hillY );


    // draw clouds and bushes
	float sc1CloudX = mod( worldX - 296.0, 768.0 );
    float sc2CloudX = mod( worldX - 904.0, 768.0 );
    float mcCloudX  = mod( worldX - 584.0, 768.0 );
    float lcCloudX  = mod( worldX - 440.0, 768.0 );    
    float scCloudX  = min( sc1CloudX, sc2CloudX );
    float sbCloudX 	= mod( worldX - 376.0, 768.0 );
    float mbCloudX  = mod( worldX - 664.0, 768.0 );  
	float lbCloudX  = mod( worldX - 184.0, 768.0 );
    float cCloudX	= min( min( scCloudX, mcCloudX ), lcCloudX );
    float bCloudX	= min( min( sbCloudX, mbCloudX ), lbCloudX );
    float sCloudX	= min( scCloudX, sbCloudX );
    float mCloudX	= min( mcCloudX, mbCloudX );
    float lCloudX	= min( lcCloudX, lbCloudX );
    float cloudX	= min( cCloudX, bCloudX );
    float isBush	= bCloudX < cCloudX ? 1.0 : 0.0;
    float cloudSeg	= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );
    float cloudY	= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );
	if ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )
    {
        if ( cloudSeg == 1.0 )
        {
        	cloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;
        }
        if ( cloudSeg == 2.0 )
        {
        	cloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );
        }
        
    	SpriteCloud( color, cloudX, cloudY, isBush );
    }

    
    
    // draw flag pole
    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        
    {
        color = RGB( 189, 255, 24 );
    }
    
    // draw flag
    float flagX = worldX - 3160.0;
    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );
    if ( flagX >= 0.0 && flagX <= 15.0 )
    {
    	SpriteFlag( color, flagX, flagY );
    }     
    
    // draw flagpole end
    float flagpoleEndX = worldX - 3172.0;
    float flagpoleEndY = worldY - 176.0;
    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )
    {
    	SpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );
    }
    
    

    // draw blocks
   	if (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )
         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )
         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )
         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) 
         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )
         || ( tileX == 198.0 && tileY == 1.0 )
       )
    {
        SpriteBlock( color, worldXMod16, worldYMod16 );
    }
    
    
    // draw pipes
    float pipeY = worldY - 16.0;  
    float pipeH	= 0.0;    
    float pipeX = worldX - 179.0 * 16.0;
    if ( pipeX < 0.0 )
    {
        pipeX = worldX - 163.0 * 16.0;
        pipeH = 0.0;
    }
    if ( pipeX < 0.0 )
    {
        pipeX = worldX - 57.0 * 16.0;
        pipeH = 2.0;
    }
    if ( pipeX < 0.0 )
    {
        pipeX = worldX - 46.0 * 16.0;
        pipeH = 2.0;
    } 
    if ( pipeX < 0.0 )
    {
        pipeX = worldX - 38.0 * 16.0;
        pipeH = 1.0;
    }         
    if ( pipeX < 0.0 )
    {
        pipeX = worldX - 28.0 * 16.0;
        pipeH = 0.0;
    }
    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )
	{
		SpritePipe( color, pipeX, pipeY, pipeH );
	}
    
    
    // draw mushroom
    float mushroomStart = 15.7;    
    if ( time >= mushroomStart && time <= 17.0 )
    {
        float jumpTime = 0.5;
        
        float mushroomX = worldX - 1248.0;
        float mushroomY = worldY - 4.0 * 16.0;
        if ( time >= mushroomStart )
        {
            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );
        }
        if ( time >= mushroomStart + 0.5 )
        {
            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );
        }
        if ( time >= mushroomStart + 0.5 + 0.4 )
        {
            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );
        }
        
        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )
        {
        	SpriteMushroom( color, mushroomX, mushroomY );
        }
    }

    
    // draw coins
    float coinFrame = floor( mod( time * 12.0, 4.0 ) );
    float coinX 	= worldX - 2720.0;
    float coinTime 	= 33.9;    
    float coinY 	= CoinAnimY( worldY, time, coinTime );
    if ( coinX < 0.0 )
    {
    	coinX 		= worldX - 1696.0;
    	coinTime 	= 22.4;    
    	coinY 		= CoinAnimY( worldY, time, coinTime );        
    }
    if ( coinX < 0.0 )
    {
    	coinX 		= worldX - 352.0;
    	coinTime 	= 5.4;    
    	coinY 		= CoinAnimY( worldY, time, coinTime );
    } 
    
    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )
    {   
        SpriteCoin( color, coinX, coinY, coinFrame );
    }

    
    // draw questions
	float questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    
    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )
         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )
         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )
       )
    {
        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );
    }
    
    
    // draw hitted questions
    float questionHitTime 	= 33.9;
    float questionX 		= worldX - 2720.0;
    if ( questionX < 0.0 )
    {
        questionHitTime = 22.4;
        questionX		= worldX - 1696.0;
    }
    if ( questionX < 0.0 )
    {
        questionHitTime = 15.4;
        questionX		= worldX - 1248.0;
    }
    if ( questionX < 0.0 )
    {
        questionHitTime = 5.3;
        questionX		= worldX - 352.0;
    }    
    questionT		= time >= questionHitTime ? 1.0 : questionT;    
    float questionY = QuestionAnimY( worldY, time, questionHitTime );
    if ( questionX >= 0.0 && questionX <= 15.0 )
    {
    	SpriteQuestion( color, questionX, questionY, questionT );
    }
    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )
    {
        color = RGB( 231, 90, 16 );
    }    

    
    // draw bricks
   	if (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )
         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )
         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )
         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )
         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )
         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )
         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )
       )
    {
        SpriteBrick( color, worldXMod16, worldYMod16 );
    }   
    
    
    // draw castle flag
    float castleFlagX = worldX - 3264.0;
    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );
    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )
    {
    	SpriteCastleFlag( color, castleFlagX, castleFlagY );
	}
    
    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );

    // draw ground
    if ( tileY <= 0.0
         && !( tileX >= 69.0  && tileX < 71.0 )
         && !( tileX >= 86.0  && tileX < 89.0 ) 
         && !( tileX >= 153.0 && tileX < 155.0 ) 
       )
    {
        SpriteGround( color, worldXMod16, worldYMod16 );
    }    
    

    // draw Koopa
    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );
    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );
    
    
    // draw stomped walking Goombas
    float goombaY 			= worldY - 16.0;        
    float goombaLifeTime 	= 26.3;
    float goombaX 			= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );
    if ( goombaX < 0.0 )
    {
        goombaLifeTime 	= 25.3;
        goombaX 		= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );
    }
    if ( goombaX < 0.0 ) 
    {
		goombaLifeTime 	= 23.5;
        goombaX 		= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );
    }
    if ( goombaX < 0.0 ) 
    {
        goombaLifeTime 	= 20.29;
        goombaX 		= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );
    }
    if ( goombaX < 0.0 )
    {
        goombaLifeTime 	= 10.3;
		goombaX 		= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );
    }
	goombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;
    if ( goombaX >= 0.0 && goombaX <= 15.0 )
    {
        SpriteGoomba( color, goombaX, goombaY, goombaFrame );
    }    
    
    // draw walking Goombas
    goombaFrame 		= floor( mod( time * 5.0, 2.0 ) );
    float goombaWalkX 	= worldX + floor( time * GOOMBA_SPEED );
    goombaX 			= goombaWalkX - 3850.0 - 24.0;
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;
    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );
    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );
    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;
    if ( goombaX >= 0.0 && goombaX <= 15.0 )
    {
        SpriteGoomba( color, goombaX, goombaY, goombaFrame );
    }
    

    
    // Mario jump
    float marioBigJump1 	= 27.1;
    float marioBigJump2 	= 29.75;
    float marioBigJump3 	= 35.05;    
    float marioJumpTime 	= 0.0;
    float marioJumpScale	= 0.0;
    
    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }
    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }
    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }
    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }
    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }
    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }
    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }
    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }
    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }
    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }
    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }
    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }
    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }
    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }
    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }
    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }
    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }
    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }
    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }
    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }
    if ( time >= marioBigJump1 ) 		{ marioJumpTime = marioBigJump1; 		marioJumpScale = 1.0; }
    if ( time >= marioBigJump1 + 1.0 ) 	{ marioJumpTime = marioBigJump1 + 1.0; 	marioJumpScale = 0.6; }
    if ( time >= marioBigJump2 ) 		{ marioJumpTime = marioBigJump2; 		marioJumpScale = 1.0; }
    if ( time >= marioBigJump2 + 1.0 ) 	{ marioJumpTime = marioBigJump2 + 1.0;	marioJumpScale = 0.6; }    
    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }
    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }
    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }
    if ( time >= marioBigJump3 ) 				{ marioJumpTime = marioBigJump3; 				marioJumpScale = 1.0; }
    if ( time >= marioBigJump3 + 1.2 ) 			{ marioJumpTime = marioBigJump3 + 1.2; 			marioJumpScale = 0.89; }
    if ( time >= marioBigJump3 + 1.2 + 0.75 ) 	{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; 	marioJumpScale = 0.5; }
    
    float marioJumpOffset 		= 0.0;
    float marioJumpLength 		= 1.5  * marioJumpScale;
    float marioJumpAmplitude	= 76.0 * marioJumpScale;
    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )
    {
        float t = ( time - marioJumpTime ) / marioJumpLength;
        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );
    }
    
    
    // Mario land
    float marioLandTime 	= 0.0;
    float marioLandAplitude = 0.0;
    if ( time >= marioBigJump1 + 1.0 + 0.45 ) 			{ marioLandTime = marioBigJump1 + 1.0 + 0.45; 			marioLandAplitude = 109.0; }
    if ( time >= marioBigJump2 + 1.0 + 0.45 ) 			{ marioLandTime = marioBigJump2 + 1.0 + 0.45; 			marioLandAplitude = 109.0; }
	if ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) 	{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; 	marioLandAplitude = 150.0; }
    
    float marioLandLength = marioLandAplitude / 120.0;
	if ( time >= marioLandTime && time <= marioLandTime + marioLandLength )
    {
        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;
       	marioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );
    }
    
    
    // Mario flag jump
    marioJumpTime 		= flagPauseStart - 0.3;
    marioJumpLength 	= 1.5  * 0.45;
    marioJumpAmplitude	= 76.0 * 0.45;
    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) 
    {
        float time2 = time;
        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) 
        {
            time2 = flagPauseStart;
        }
        else if ( time >= flagPauseStart )
        {
            time2 = time - flagPauseLength;
        }
		float t = ( time2 - marioJumpTime ) / marioJumpLength;
        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );
    }
    

    // Mario base (ground offset)
    float marioBase = 0.0;
    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )
    {
        marioBase = 16.0 * 4.0;
    }
    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )
    {
        marioBase = 16.0 * 4.0;
    }    
    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )
    {
        marioBase = 16.0 * 3.0;
    }    
    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )
    {
        marioBase = 16.0 * 7.0;
    }

    float marioX		= pixelX - 112.0;
    float marioY		= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    
    float marioFrame 	= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;
    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )
    {
    	marioFrame = 1.0;
    }    
    if ( time > mushroomPauseStart + 0.7 )
    {
        float t = time - mushroomPauseStart - 0.7;
    	if ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )
        {
            // super mario offset
            marioFrame += 4.0;
        }
    }    
    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )
    {
        SpriteMario( color, marioX, marioY, marioFrame );
    }
}

// Function 2227
float drawCircle(vec2 position, float radius)
{
    float smaller = min(iResolution.x, iResolution.y);
    float edge = 1.0/smaller;
    return smoothstep(edge, -edge, length(position) - radius);
}

// Function 2228
float PatternCircles(vec2 p, float m){
  p.x-=m/2.0*step(0.0,sin(PI*p.y/m));
  p = mod(p,m)-m/2.0;
  return 1.0-sm(0.0,(p.x*p.x+p.y*p.y)-1.0);
}

// Function 2229
vec3 ToLinear(vec3 v) { return PowVec3(v,     gamma); }

// Function 2230
vec3 cineon_log_2_linear(in vec3 color)
{
	return (pow(vec3(10.0), (1023.0 * color - 685.0) / 300.0) - 0.0108) / (1.0 - 0.0108);
}

// Function 2231
vec2 closest_point_line(vec2 a, vec2 b, vec2 point) {
	float h = clamp((dot((point) - (a), (b) - (a))) / (dot((b) - (a), (b) - (a))), 0.0, 1.0);
	return (((b) - (a)) * (h)) + (a);
}

// Function 2232
void setupTriangleDrawing(vec3 gbary) {
    
    if (gbary.z >= 0.) {
        generator = verts[int(gbary.z)];  
    } else {
        generator = diskFromBary(gbary.xy);
    }
    
    bool regionValid[3] = bool[3](true, true, true);
    bool perpValid[3];
    bool perpDrawable[3];
    
    for (int i=0; i<3; ++i) {
        
        perps[i] = geodesicPerpThruPoint(edges[i], generator.xy);
        perpValid[i] = abs(geodesicDist(edges[i], generator.xy)) > TOL;
        perpDrawable[i] = perpValid[i];
        
        int j = (i + 1) % 3;
        int k = (i + 2) % 3;
                
        if (abs(geodesicDist(perps[i], verts[j])) < TOL) { 
            regionValid[j] = false; 
            perpValid[i] = false;
        }
        
        if (abs(geodesicDist(perps[i], verts[k])) < TOL) { 
            regionValid[k] = false;
            perpValid[i] = false;
        }
        
    }
    
    drawCodes = ivec3(intFromBool3(regionValid),
                      intFromBool3(perpValid),
                      intFromBool3(perpDrawable));
    
    
}

// Function 2233
float sdFatLine2All(vec2 p, vec3 a, vec3 b, out float distToCurve, out vec2 uv) {
    vec2 d = b.xy - a.xy;
    vec2 pd = p - a.xy;
    float t = dot(pd, d) / dot(d, d);
    t = min(1.0, max(0.0, t));
    vec2 cp = a.xy + t * d;
    
    vec2 n = p - cp;
    distToCurve = length(n);
    
    // remember a.z & b.z are radius
    float cr = mix(a.z, b.z, t);
    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;
    uv = vec2(t, v);

    float distToBoundary = distToCurve - cr;
    
    return distToBoundary;
}

// Function 2234
vec4 texture_bilinear( const in sampler2D t, in vec2 uv )
{
  uv -= 0.5 * texelSize.xx;
  // Calculate pixels to sample and interpolating factor
  vec2 f = fract( uv * TEXTURE_SIZE );
  vec2 uvSnapped = uv - texelSize.xx * f + 0.5 * texelSize.xx;

  // As we are sampling snapped pixels need to override
  // the mip-map selection by selecting a large negative
  // bias. Otherwise at boundaries the gradient of
  // uvSnapped is large and an incorrect mip-level is used
  // leading to artifacts  
  float bias = -10.0;
  vec4 tl = texture(t, uvSnapped, bias);
  vec4 tr = texture(t, uvSnapped + texelSize, bias);
  vec4 bl = texture(t, uvSnapped + texelSize.yx, bias);
  vec4 br = texture(t, uvSnapped + texelSize.xx, bias);
    
  vec4 tA = mix( tl, tr, f.x );
  vec4 tB = mix( bl, br, f.x );
  return mix( tA, tB, f.y );
}

// Function 2235
vec3 DirectLight(vec3 P, vec3 N, vec3 LD) {
    float SunDot=dot(LD,N); Hit Shad;
    return ((SunDot<0.)?vec3(0.):SunColor*(SunDot*(1.-float(SRay(P+N*0.01,LD,Shad)))));
}

// Function 2236
float rectFrameCorner(vec2 p, vec2 center, vec2 size,
                      float thickness, float cornerLen){
	float frame = rectFrame(p, center, size, thickness);
    float vRect = rect(p, center, vec2(size.x - 2. * cornerLen, size.y * 2.));
    float hRect = rect(p, center, vec2(size.x * 2., size.y - 2. * cornerLen));
    return max(max(frame, -vRect), -hRect);
}

// Function 2237
vec3 segmented_spline_c5_rev_f3( vec3 rgbPre) {
vec3 rgbPost;
rgbPost.x = segmented_spline_c5_rev( rgbPre.x);
rgbPost.y = segmented_spline_c5_rev( rgbPre.y);
rgbPost.z = segmented_spline_c5_rev( rgbPre.z);
return rgbPost;
}

// Function 2238
float circle(in vec2 uv, in float radius, in float width)
{
    return smoothstep(width, width * 0.5, abs(radius - length(uv)));
}

// Function 2239
vec3 DrawCandy0(vec2 p, vec3 bgColor)
{
    float d = length(p)-0.5;
    float d2 = d;
    
    vec3 color = vec3(0.078, 0.2, 0.882);
    color = mix(color*0.9, color*1.1, smoothstep(-0.2, 0.4, p.x));
    vec2 q = p; q.y -= -0.1+ cos(1.+p.x*1.)*0.15;
    d = dsBox(q, vec2(0.45, 0.05), 0.05);
    d2 = min(d2, d);
    color = mix(color*1.5, color, smoothstep(0., 2e-2, d)); 
    
    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(1.8) ).rgb;
    color *= 1.+cubeTex.r;
    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.1, 0.2))*vec2(1.2, 2.2))), 0.35) );
    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.1, -0.2))*vec2(1.2, 2.2))), 0.28) );
    color = mix(color, vec3(0.), smoothstep(0.0, 1., 1.-exp(-2.5*max(d2+0.2, 0.)) ));
    return mix(color, bgColor, smoothstep(0., 0.1, d2));
}

// Function 2240
vec2 calcEquirectangularFromGnomonicProjection(in vec2 sph, in vec2 centralPoint) {
    vec2 cp = (centralPoint * 2.0 - 1.0) * vec2(PI, PI_2);
	float cos_c = sin(cp.y) * sin(sph.y) + cos(cp.y) * cos(sph.y) * cos(sph.y - cp.y);
    float x = cos(sph.y) * sin(sph.y - cp.y) / cos_c;
    float y = ( cos(cp.y) * sin(sph.y) - sin(cp.y) * cos(sph.y) * cos(sph.y - cp.y) ) / cos_c; 
    return vec2(x, y) + vec2(PI, PI_2); 
}

// Function 2241
vec3 draw_grid(vec2 uv) 
{
    float gridLine = fract(60. * uv.x);
    float mask = smoothstep(0., .1, uv.y) * smoothstep(1., .9, uv.y) ;
    
    mask *= smoothstep( .05, .0, abs(gridLine - .5));
    return mask * 0.05 * vec3(1., 1., 1.);
}

// Function 2242
float drawFloat(float fn, int prec, int maxDigits)
{
  float tpx = tp.x-FONT_SPACE*float(maxDigits);
  float c = 0.;
  if (fn < 0.0)
  {
    c = char(45); // write minus sign
    fn = -fn;
  }
  tp.x -= FONT_SPACE;
  c += drawInt(int(fn),1);
  c += char(46); SPACE; // add dot
  c += drawFract(prec, fract(fn));
  tp.x = min(tp.x, tpx);
  return c;
}

// Function 2243
vec2 sample_direction_uniform() {
    float theta = two_pi * sample_uniform();
	return vec2(cos(theta), sin(theta));
}

// Function 2244
v2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w
){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align
 ;m1 rotMat =rot2D(lineAngle)
 ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.
 ;v1 T=m.xy*rotMat// top left
 ;v1 B=T+v1(0,W)// bottom right
 ;v1 l=u*rotMat
 ;l.x+=(noise01(l*1.)-.5)*.02
 ;l.x+=cos(l.y*3.)*.009//lp wave
 ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around
 ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific
 ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.
 ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}

// Function 2245
maybe_float get_distance_along_2d_line_to_line(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in vec2 B
){
    vec2 D = B0 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    return maybe_float(
        length(R) / dot(B, normalize(-R)), 
        abs(abs(dot(A, B)) - 1.f) > 0.f
    );
}

// Function 2246
float GetNearestPointAlongCubicSpline(vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, vec2 uv)
{
	float t = GetPositionAlongLineSegmentNearestToPoint(cp0,cp3, uv);

	// Now refine once.
	{
		float t0 = max(0.0, t - 0.1);
		float t1 = min(1.0, t + 0.1);

		vec2 p0 = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t0);
		vec2 p1 = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t1);

		t = clamp(mix(t0,t1,GetPositionAlongLineNearestToPoint(p0,p1, uv)), 0.0, 1.0);
	}

	return t;
}

// Function 2247
vec3 depthDirectionalBlur(sampler2D tex, float z, float coc, vec2 uv, vec2 blurvec)  
{  
    // z: z at UV  
    // coc: blur radius at UV  
    // uv: initial coordinate  
    // blurvec: smudge direction  
    // numSamples: blur taps  
    vec3 sumcol = vec3(0.);  
  
    for (int i = 0; i < NUM_SAMPLES; ++i)  
    {  
        float r =  (float(i) + hash1(uv + float(i) + 1.) - 0.5)  / (float(NUM_SAMPLES) - 1.) - 0.5;  
        vec2 p = uv + r * coc * blurvec;  
        vec4 smpl = texture(tex, p);  
        if(smpl.w < z) // if sample is closer consider it's CoC  
        {  
            p = uv + r * min(coc, CoC(smpl.w)) * blurvec;  
            p = uv + r * CoC(smpl.w) * blurvec;  
            smpl = texture(tex, p);  
        }  
        sumcol += smpl.xyz;  
    }  
  
    sumcol /= float(NUM_SAMPLES);  
    sumcol = max(sumcol, 0.0);  
  
    return sumcol;  
}

// Function 2248
vec2 get_rect_uv(vec2 uv, vec2 origin){
    
    float width = XRADIUS*2.0;
    float height = YRADIUS*2.0;
    
    vec2 rect_uv = uv-origin;
    rect_uv.x+=XRADIUS;
    rect_uv.y+=YRADIUS;
    rect_uv.x/=width;
    rect_uv.y/=height;
    //rect_uv.y = 1.0-rect_uv.y;
    
    return rect_uv;
}

// Function 2249
bool inRect(vec2 pos, vec4 rect
){rect.xyzw-=pos.xyxy
 ;return min(rect.z-rect.x,rect.y-rect.w)<mi(rect) ;}

// Function 2250
vec4 drawFilter(vec2 fragCoord) {
    fragCoord = abs(3.0*fragCoord);
    if (fragCoord.x > 1.5 || fragCoord.y > 1.5) {
        return vec4(0.0);
    }
    
    vec2 c = DQCenter(fragCoord);
    vec2 l = DQLobe(fragCoord);
    vec2 f = mix(c, l, greaterThan(fragCoord, vec2(0.5)));
    float o = f.x * f.y;
    return vec4(-20.0*o, o, 0.0, 1.0);
}

// Function 2251
vec2 dline_seg(vec2 p, vec2 a, vec2 b) {

    vec2 ba = b-a;
    vec2 n = normalize(vec2(-ba.y, ba.x));

    vec2 pa = p-a;
    
    float u = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);
    
    return vec2(dot(a, n) - dot(p, n), length(p-mix(a,b,u)));
    
}

// Function 2252
float circle(vec2 uv, vec3 c)
{
  float r = length(c.xy - uv);
  float d = abs(r - c.z);  
  return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.01, r-c.z);
}

// Function 2253
float drawRectangle(vec2 uv, vec2 bottomLeft, vec2 widthHeight)
{
    vec2 widthHeightHalf = widthHeight / 2.0;
    vec2 s = step(abs(uv - bottomLeft - widthHeightHalf), widthHeightHalf);
    return s.x * s.y;
}

// Function 2254
vec4 drawSprite(vec2 uv) {
    float t = mod(.5 * iTime, 1.2) - .1;
    float offset = smoothstep(t, t + .15, 1. - uv.y) - 1.;
    uv.x += .4 * -pow(offset, 5.);
    
    vec4 tex = vec4(0);
    if(all(greaterThan(step(abs(uv - .5), vec2(.5)), vec2(.5))))
    	tex = texture(iChannel0, vec2(uv.x / 6.6, uv.y));
    
    tex.a *= smoothstep(t - .01, t + .1, 1. - uv.y);
    return tex;
}

// Function 2255
float distLine(vec2 a, vec2 b){
    
     
	b = a - b;
	float h = clamp(dot(a, b)/dot(b, b), 0., 1.);
    return length(a - b*h);
}

// Function 2256
float circle(vec2 xy, vec2 c, float r, bool fill){
    float dist = length(xy-c)-r;
    return 1.-smoothstep(-3./iResolution.y,2./iResolution.y,fill?dist:abs(dist));
}

// Function 2257
vec3 drawMap( vec3 col, in vec2 fragCoord )
{
    vec2 p = fragCoord/iResolution.y;
    p.x += 0.5*(1.0-iResolution.x/iResolution.y); // center
    float wp = 1.0/iResolution.y;

    p *= 31.0;
    vec2 q = floor(p);
    vec2 r = fract(p);
    float wr = 31.0*wp;

    if( q.x>=0.0 && q.x<=27.0 )
    {
        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;

        // points
        if( abs(c-2.0)<0.5 )
        {
            float d = sdCircle(r-0.5, 0.15);
            col += 0.3*vec3(1.0,0.7,0.4)*exp(-22.0*d*d); // glow
        }
    }
    
	// balls
    
    vec2 bp[4];
    
    bp[0] = vec2( 1.0, 7.0) + 0.5;
    bp[1] = vec2(25.0, 7.0) + 0.5;
    bp[2] = vec2( 1.0,27.0) + 0.5;
    bp[3] = vec2(25.0,27.0) + 0.5;
    
    for( int i=0; i<4; i++ )
    {
        float c = texture( iChannel0, (bp[i]+0.5)/iResolution.xy, -100.0 ).x;
        if( abs(c-3.0)<0.5 )
        {
        float d = length(p - bp[i]);
        col += 0.35*vec3(1.0,0.7,0.4)*exp(-1.0*d*d)*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iTime) );
        }
    }
    
    return col;
}

// Function 2258
vec3 lightDirection()
{
    return -normalize(lightPosition());
}

// Function 2259
float circle(vec2 _uv, float _radius)
{
    return step(_radius, length(_uv));
}

// Function 2260
float csg_and_inlined (float a, float b, float r) {
    float d = abs(a - b);
    float q = max(r - d, 0.0);    
    return 0.5*(a + b + (d + q*q/r));
}

// Function 2261
vec3 linearSrgbToOklab(vec3 c) {
    return xyzToOklab(linearSrgbToXyz(c));
}

// Function 2262
float drawY(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float valA = float(isIn(length(uv+vec2(0.0, -cMax)), cMin, cMax) && uv.y < cMax && !isIn(uv.x, -cthick, cthick));
  float valB = float(isIn(uv.x, -cthick*0.5,cthick*0.5) && isIn(uv.y, -cMax, 0.0));
  return valA +valB;
}

// Function 2263
vec3 linearToGamma(vec3 col) {
    return pow(col, vec3(1.0 / GAMMA));
}

// Function 2264
float drawGrid(vec2 space)
{
    return min(1., drawGridLines(space.x)
                  +drawGridLines(space.y));
}

// Function 2265
float linedist(vec2 p, vec2 a, vec2 b) {
    float k = dot(p-a, b-a)/dot(b-a,b-a);
    return distance(p, mix(a, b, clamp(k, 0., 1.)));
}

// Function 2266
mat4 sampleCircle(vec2 fragCoord)
{
    float circle = 0.0;
    vec4 circleColour = vec4(0.0, 0.0, 0.0, 0.0);
    
    for (int i = 0; i < 10; i++) {
        vec4 c = sampleOneMovingCircle(i, fragCoord);
        circle = circle * (1.0 - c.a) + c.a;
        circleColour += vec4(c.rgb * c.a, c.a);
    }
    circleColour /= circleColour.a;
    
    circle -= CIRCLE_FALL;
    circle /= (1.0 - CIRCLE_FALL);
    circle = sqrt(circle + 0.3) - 0.25;
    circle = clamp(circle, 0.0, 1.0);
    
    mat4 retn;
    retn[0] = vec4(circleColour.rgb, circle);
    retn[1] = vec4(fragCoord, circle * CIRCLE_HEIGHT, 0.0);
    return retn;
}

// Function 2267
float drawTriangle(vec2 p1, vec2 p2, vec2 p3) 
{
	return drawLine(p1, p2, 1.) 
        + drawLine(p2, p3, 1.)
        + drawLine(p3, p1, 1.);   
}

// Function 2268
vec2 circleInverse(vec2 pos, vec2 center, float rad){
    vec2 d = pos - center;
	return d * rad * rad/dot(d, d) + center;
}

// Function 2269
vec3 DrawSphere(vec2 uv, vec2 cood, float r){
    vec3 col=(length(cood-uv)<=r)?vec3(1.):vec3(0.);
    return col;
}

// Function 2270
vec4 drawSword( vec2 uv, int level ) {
    uv = floor(fract(uv)*64.) - 32.;
    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {
        float l = step(abs(uv.y), .5); 
        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   
        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));
                        
	    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));
        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );
        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );
        col = mix( scol, col, step(uv.x, -8.));        
        
        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );
    } else {
        return vec4(0);
    }
}

// Function 2271
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);      // proj coord on line
 // return smoothstep(zoom*3./R.y,0.,length(p - b * h)); // dist to segment
 // return max(0., 1. -  length(p - b * h) / (zoom*3./R.y) );
    p -= b*h; h = zoom*3./R.y; return max(0., 1. -  dot(p,p)/(h*h) );  // optim
}

// Function 2272
bool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,
                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)
{
    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);
    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);
    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);
    vec3 vd = vec3(ps.xy, ph.x);
    t = -1.;
    tsi = -1.;
    si = false;
    fade = 1.;
    fadesi = 1.;
    norm=vec3(0.,1.,0.);normsi=vec3(0.,1.,0.);

    float tmp = 1.0 / (vb.y * vc.x);
    float a = 0.0;
    float b = 0.0;
    float c = 0.0;
    float d = va.z * tmp;
    float e = 0.0;
    float f = 0.0;
    float g = (vc.z * vb.y - vd.y * va.z) * tmp;
    float h = (vb.z * vc.x - va.z * vd.x) * tmp;
    float i = -1.0;
    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;

    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);
    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +
              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);
    float r =
        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;

    if (abs(p) < 0.000001)
    {
        float tt = -r / q;
        if (tt <= 0.)
            return false;
        t = tt;
        // normal

        vec3 pos = ro + t * rd;
        if(length(pos)>sz)return false;
        vec3 grad =
            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);
        norm = -normalize(grad);
        return true;
    }
    else
    {
        float sq = q * q - 4.0 * p * r;
        if (sq < 0.0)
        {
            return false;
        }
        else
        {
            float s = sqrt(sq);
            float t0 = (-q + s) / (2.0 * p);
            float t1 = (-q - s) / (2.0 * p);
            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);
            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);
            float tt0 = tt1;
            if (tt0 <= 0.)
                return false;
            vec3 pos = ro + tt0 * rd;
            // black border on end of circle and self intersection with alpha come because dFd
            // uncomment this to see or rename fcos2 to fcos
            //sz+=0.3; 
            bool ru = step(sz, length(pos)) > 0.5;
            if (ru)
            {
                tt0 = tt2;
                pos = ro + tt0 * rd;
            }
            if (tt0 <= 0.)
                return false;
            bool ru2 = step(sz, length(pos)) > 0.5;
            if (ru2)
                return false;

            // self intersect
            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))
            {
                si = true;
                fadesi=s;
                tsi = tt2;
                vec3 tpos = ro + tsi * rd;
                // normal
                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +
                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);
                normsi = -normalize(tgrad);
            }
            
            fade=s;
            t = tt0;
            // normal
            vec3 grad =
                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);
            norm = -normalize(grad);

            return true;
        }
    }
}

// Function 2273
bool drawLine(int textBufferOffset, ivec2 uv)
{
    for (int i = 0; i < 8; i++)
    {
        int indices = textBuffer(8 * textBufferOffset + i);
        
        if (indices == 0)
        {
            return false;
        }
        else
        {
            ivec4 v = unpack(indices);
            
            if (((v.x > 0) && (char(C[v.x - 1], uv))) || ((v.y > 0) && (char(C[v.y - 1], uv))) ||
                ((v.z > 0) && (char(C[v.z - 1], uv))) || ((v.w > 0) && (char(C[v.w - 1], uv))))
            {
                return true;
            }
        }
    }

    return false;   
}

// Function 2274
vec3 i_direct_24( uint data )
{
    uvec3 d = uvec3( data, data>>8, data>>16 ) & 255u;
    vec3 v = vec3(d)/127.5 - 1.0;
    
    return normalize( v );
}

// Function 2275
float lineDist(vec2 pm, vec2 p0, vec2 p1)
{
	vec2 a = pm - p0;
	vec2 b = p1 - p0;
	float bLen = length(b);
	vec2 bNorm = normalize(b);
	float a1Len = dot(a, bNorm);
	vec2 a1 = a1Len * bNorm;
	vec2 a2 = a - a1;
	
	if (a1Len < 0.0) {
		return sqrlen(p0 - pm);
	} else if (a1Len > bLen) {
		return sqrlen(p1 - pm);
	} else {
		return sqrlen(a2);
	}
}

// Function 2276
float closestPointOnLineScalar(vec2 o, vec2 d, vec2 p) {
    return dot(p - o, d);	// rounding error not here
}

// Function 2277
float drawParticle(vec3 particlePosVel)
{
    vec2 toParticle = (particlePosVel.xy - uv) * iResolution.xy;
    vec2 toParticleAbs = abs(toParticle);
    
    bvec2 particleSquare = lessThan(toParticleAbs, vec2(PIXEL_SCALE_HALF));
    
    float particleness = float(all(particleSquare));
    if(particleSquare.x && toParticle.y < 0.0)
    {
		float trail = 700.* particlePosVel.z / (-toParticle.y);
        particleness += min(trail, 1.0) * 0.8f;
    }
    
    return particleness;
}

// Function 2278
vec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {
    vec2 r = hash2(seed);
    
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	
    float a = roughness*roughness;
    
	float rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));
	float ra = sqrt(abs(1.-rz*rz));
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    
    vec3 ret = normalize(rr);
    return dot(ret,normal) > 0. ? ret : n;
}

// Function 2279
vec2 RayLineDist(vec3 ro, vec3 rd, vec3 a, vec3 b) {
    
    b -= a;
    vec3 rdb = cross(rd,b);
    vec3 rop2 = a-ro;
    
	float t1 = dot( cross(rop2, b), rdb ); 
    float t2 = dot( cross(rop2, rd), rdb );
    
    return vec2(t1, t2) / dot(rdb, rdb);
}

// Function 2280
float circle(vec2 uv, vec2 aspect, float scale){
	return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);
}

// Function 2281
vec4 sdLine( in vec2 p, in vec2 a, in vec2 b, in vec3 ca, in vec3 cb)
{
    vec2 pa = p-a;
    vec2 ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);
    float dist = length(pa-h*ba);
    // step to determine what side of the line p is on
    float s = step(0.0,pa.x*ba.y-pa.y*ba.x);
    // mix returns colour ca for one side and cb for the other
    return vec4(dist, mix(ca,cb,s));
}

// Function 2282
float Outline_EdgeDetection(in vec4 march)
{
    return march.z;
}

// Function 2283
float fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*p322,h.y));}

// Function 2284
float distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {
    vec3 a = point - origin;
    vec3 h = a - dot(a, direction) * direction;
    return dot(h, h);
}

// Function 2285
void drawCircle(vec2 uv, vec3 color, float radiusCircle, float blur, vec2 pos, inout vec3 image) {
    float d = length(uv-pos);
    if(d <= radiusCircle) {
		image.r = color.r*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));
        image.g = color.g*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));
        image.b = color.b*(1.0-smoothstep(radiusCircle-blur, radiusCircle, d));
    }
}

// Function 2286
vec3 DrawCandy5(vec2 p, vec3 bgColor)
{
    vec2 q = p-vec2(-0.0, +0.0);
    q.x *= 1./(1.+abs(q.y)*0.25);
    float d = length(q*vec2(1., 0.7)*0.60)- 0.25;
    vec3 color = vec3(0.968, 0.698, 0.031);
    color = mix(color, vec3(0.968, 0.698, 0.031)*0.4, texture(iChannel1, p.xy*vec2(3.0, 1.)).r );
    
    float d2 = length(q*vec2(1., 0.7)*0.60)- 0.15;
    color = mix(vec3(0.811, 0.650, 0.247), color, smoothstep(0.0, 1.0, pow(18.*abs(d2), 1.0)));
    
    
    color = mix(color*0.4, color, smoothstep(-1.0, 0.3, p.y));
    
    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;
    color *= 1.+cubeTex.r*0.30;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.24, 0.15))*vec2(1.5, 1.0))), 0.12) ))*2.5;
    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.15, -0.15))*vec2(0.9, 1.2))), 0.11) ))*2.5;
    
    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));
    
    return mix(color, bgColor, smoothstep(0., 2e-2, d));
}

// Function 2287
vec4 drawAxis(in vec2 xy)
{
    // Draw the right-handed coordinate axis
    vec4 axis = vec4(0.0);
    
    if(xy.x < 200.0 && xy.y < 200.0)
    {
        vec3 forward = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;
        vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
        vec3 up      = normalize(cross(right, forward));
        
        float lf = Line(xy, -forward.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);
        float lr = Line(xy, right.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);
        float lu = Line(xy, up.xy * vec2(50.0) + 50.0, vec2(50.0), 1.0);

        vec4 r = vec4(1.0, 0.0, 0.0, 1.0) * lr;
        vec4 g = vec4(0.0, 1.0, 0.0, 1.0) * lu;        
        vec4 b = vec4(0.0, 0.0, 1.0, 1.0) * lf;
        
        axis = mix(axis, g, g.a);
        axis = mix(axis, r, r.a);
        axis = mix(axis, b, b.a);
    }
    
    return axis;
}

// Function 2288
void mixColorLine(vec2 uv,inout vec3 col,vec2 lineA,vec2 lineB,float scale)
{
    col = mix(
        col , 
        vec3(0.0),//hash3point(lineA+lineB) ,
        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))
    );
}

// Function 2289
float line(vec2 p, vec2 a, vec2 b){
	float d = distLine(p, a, b);
    float m = S(0.03, 0.01, d);
    float d2 =  length(a - b);
    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));
    return m;
}

// Function 2290
vec2 Support_HorizLine (float size, vec2 dir)
{
    return vec2(sign(dir.x)*size, 0.0);
}

// Function 2291
float fHexagonIncircle(v2 p,v1 h){return fHexagonCircumcircle(p,vec2(h.x*p322,h.y));}

// Function 2292
vec2 sdLineOriY( in vec3 p, in float b )
{
    float h = clamp( p.y/b, 0.0, 1.0 );
    
    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );
}

// Function 2293
float outline(sampler2D sampler, vec2 uv, float outlineSize)
{
	float blur = blurTexture(sampler, uv, 2.0, 3.0).a;
    float alpha = step(0.5 - outlineSize * 0.5, blur);
    
    return alpha;
}

// Function 2294
float bilinearTriangle(vec2 texcoord, float sample0, float sample1, float sample2, float sample3)
{
    float x1 = texcoord.x;
    float x2 = 1.0 - texcoord.x;
    float y1 = texcoord.y;
    float y2 = 1.0 - texcoord.y;
    
    float fsample = 0.0;
    float side = step(1.0, texcoord.x+texcoord.y);
    float side1 = 1.0-side;
    
    fsample += sample2*x2*y1*(side1);
    fsample += sample0*x2*y2*(side1);
    fsample += sample1*x1*y2*(side1);
    
    fsample += sample3*x1*y1*(side);
    fsample += sample2*x2*y1*(side);
    fsample += sample1*x1*y2*(side);
    return fsample;
}

// Function 2295
void RectShrink( inout Rect region, vec2 vPadding )
{
    RectExpand( region, -vPadding);
}

// Function 2296
float intersectRectangle(Ray r, Rectangle rec){
    float d=intersectPlane(r,rec.plane);
    vec3 hitPoint=r.origin+d*r.direction;
    float size=rec.size;
    //XZ_PLANE
    if (rec.plane.normal==vec3(0.0,1.0,0.0)){
    	vec3 tmin=rec.plane.p-vec3(size,0.0,size);
        vec3 tmax=rec.plane.p+vec3(size,0.0,size);
        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)
            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)
                return d;
     //YZ_PLANE
    }else if (rec.plane.normal==vec3(1.0,0.0,0.0)){
    	vec3 tmin=rec.plane.p-vec3(0.0,size,size);
        vec3 tmax=rec.plane.p+vec3(0.0,size,size);
        if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)
            if (hitPoint.z>tmin.z&&hitPoint.z<tmax.z)
                return d;
    }//XY_PLANE
    else if (rec.plane.normal==vec3(0.0,0.0,1.0)){
    	vec3 tmin=rec.plane.p-vec3(size,size,0.0);
        vec3 tmax=rec.plane.p+vec3(size,size,0.0);
        if (hitPoint.x>tmin.x&&hitPoint.x<tmax.x)
            if (hitPoint.y>tmin.y&&hitPoint.y<tmax.y)
                return d;
    }
    
    return -1.0;
    
}

// Function 2297
float rect(in vec2 uv, in float r, in vec2 offset){
    uv += offset;
    float b = .01;
    return smoothstep(uv.x - r - b, uv.x - r + b, uv.y) * smoothstep(uv.x + r + b, uv.x + r - b, uv.y)
    	 			   * smoothstep(-uv.x - r - b, -uv.x - r + b, uv.y) * smoothstep(-uv.x + r + b, -uv.x + r - b, uv.y);
}

// Function 2298
vec4 drawCaveCells(ivec2 coord, mat4x3 colors, int animFrame, int gameFrame, float stripesAlpha, float gFade,
                   int gCaveState, vec2 camPosWS)
{
    vec4 outCaveColor = vec4(0.0);

    if ((coord.x < 0) || (coord.y < 0) || (coord.x >= GAM_RES.x) || (coord.y >= GAM_RES.y))
    {
        return outCaveColor;
    }

    ivec2 coordWS = ivec2(camPosWS * CEL_RES_F) - GAM_RES / 2 + coord;
    ivec2 cellIndex = coordWS / CEL_RES;
    ivec2 coordCell = coordWS % CEL_RES;

    bool isFadingOut = isState(gCaveState, CAVE_STATE_FADE_OUT);

    // for safety if we sample state outside of cave data
    if (cellIndex.x >= 0 && cellIndex.x < CAV_SIZ.x && cellIndex.y >= 0 && cellIndex.y < CAV_SIZ.y)
    {
        ivec4 cellState = ivec4(texelFetch(iChannel0, cellIndex, 0));
        outCaveColor = drawCell(cellState, colors, coordCell, animFrame, gameFrame, stripesAlpha);
    }

    vec4 fadeTitanium = drawFade(coordWS, colors, animFrame, gFade, isFadingOut);
    outCaveColor = lerp(outCaveColor, fadeTitanium, fadeTitanium.a);

    return outCaveColor;
}

// Function 2299
vec3 nBilinearPatch(in vec4 ps, in vec4 ph, in vec3 pos)
{
    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);
    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);
    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);
    vec3 vd = vec3(ps.xy, ph.x);

    float tmp = 1.0 / (vb.y * vc.x);
    float a = 0.0;
    float b = 0.0;
    float c = 0.0;
    float d = va.z * tmp;
    float e = 0.0;
    float f = 0.0;
    float g = (vc.z * vb.y - vd.y * va.z) * tmp;
    float h = (vb.z * vc.x - va.z * vd.x) * tmp;
    float i = -1.0;
    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp
            - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;

    vec3 grad = vec3(2.0) * pos.xzy * vec3(a, b, c)
      + pos.zxz * vec3(d, d, e)
      + pos.yyx * vec3(f, e, f)
      + vec3(g, h, i);
    return -normalize(grad);
}

// Function 2300
vec4 draw_shield( ivec2 pos, ivec2 iu ) {
    iu -= pos ;
    int x = iu.x, y = iu.y ;
    if( x < 0 || y < 0 || x >= 22 || y >= 16 ) return( vec4( 0,0,0,1 ) ) ;
    if( y >= 4 && y < 12 ) return( vec4( 1 ) ) ;
    if( y < 2 && x >= 5 && x < 16 ) return( vec4( 0,0,0,1 ) ) ;
    if( y < 4 && x >= 7 && x < 14 ) return( vec4( 0,0,0,1 ) ) ;
    if( y == 2 && ( x == 6 || x == 14 ) ) return( vec4( 0,0,0,1 ) ) ;
    if( y == 13 && ( x == 2 || x == 19 ) ) return( vec4( 1 ) ) ;
    if( y >= 13 && ( x < 3 || x >= 19 ) ) return( vec4( 0,0,0,1 ) ) ;
    if( y == 12 && ( x == 0 || x == 21 ) ) return( vec4( 0,0,0,1 ) ) ;
    if( y == 15 && ( x == 3 || x == 18 ) ) return( vec4( 0,0,0,1 ) ) ;
    return( vec4( 1 ) ) ;
}

// Function 2301
float DrawCircle (vec2 uv, vec2 pos, float r, out vec2 fDstr, out vec2 sDstr)
{
    float aspectRatio = iResolution.x/iResolution.y;
    uv.x *= aspectRatio;
    pos.x *= aspectRatio;
    
    float noise = DistortDomain (uv, fDstr, sDstr);
    
    pos += vec2 (cos(iTime) * .75, sin(iTime) * .3);
    r += sin (noise * r * 1.2);
    float d = distance (uv, pos);
    
    //Apply a smoothstep
    float circle = smoothstep (r * noise - 0.15, r * noise, d);
    return circle * noise;
}

// Function 2302
vec2 lineSegDist2D(vec2 a, vec2 b, vec2 p) {

    p -= a;
    b -= a;
    
    vec2 n = normalize(perp(b));
    
    float u = clamp(dot(p, b)/dot(b, b), 0., 1.);
    
    return vec2(dot(b, n) - dot(p, n), length(p-u*b));
    
}

// Function 2303
vec3 DrawClouds(vec2 p, vec3 color)
{
    // Clouds
    p = Rot(p, 3.14159);
    vec2 q = p;
    vec2 q2 = q;
    q2.x *= 0.2; q2 *= 2.;
    q2.y -= 1.2*pow(abs( sin(q2.x*6.)), 0.5)*1.*step(0., q2.y);
    q2.y += cos(q2.x*4.)*0.2;
    float d = length(max(abs(q2)-vec2(1., 1.0), 0.))-0.1;
    d = max(d, -q.y+0.5);
    
    q -= vec2(0., 1.0);
    q2 = q;
    q2.x *= 0.2; q2 *= 2.;
    q2.y += 1.3*pow(abs( cos(q2.x*5.5)), 0.5)*1.*step(q2.y, 0.);
    q2.y -= cos(q2.x*4.)*0.2;
    float d2 = length(max(abs(q2)-vec2(1., 1.0), 0.))-0.1;
    d2 = max(d2, q.y+0.5);
    d = min(d, d2);
    
    q2 = q-vec2(1.60, -0.4);
    d = max(d, min(q2.x,(length(q2)-1.0))  );
    q2 = q-vec2(-1.60, -0.4);
    d = max(d, min(-q2.x,(length(q2)-1.0))  );
    
    vec3 texColor = texture(iChannel1, vec2(q2.xy)*vec2(0.2, 0.1)).rgb;
    vec3 cloudColor = mix(vec3(0.866, 0.866, 0.811), vec3(0.607, 0.607, 0.372), smoothstep(0.3, 1.,texColor.r));
    color = mix(cloudColor, color, smoothstep(0., 0.05, d));
    
    // String Hole
    q2 = q-vec2(0., -1.35);
    q2.y *= 0.9;
    d = length(q2)-0.3;
    d2 = length(q2)-0.15;
    d = max(d, -d2);
    color = mix(cloudColor, color, smoothstep(0., 0.05, d));
    
    // Hole
    q2 -= vec2(0., -3.6);
    vec3 stringColor = mix(vec3(0.505, 0.376, 0.031), vec3(0.807, 0.596, 0.035), abs(q2.x)*20.);
    d = length(max(abs(q2)-vec2(0.01, 3.5), 0.))-0.03;
    color = mix(stringColor, color, smoothstep(0., 0.05, d));
    
    return color;
}

// Function 2304
vec3 DrawScene(vec3 vForwards, vec2 vUV )
{
    
    vec4 vHitInfo;
    float fClosestT;
	float fNoFog = 0.0;

	
    MapIntersect( fClosestT, vHitInfo );


    #ifdef ENABLE_SPRITES
	vec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));
    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565);
    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565);
    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878);
    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878);
    #endif	
	
	vHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);

    // sky
    #ifdef DRAW_SKY
    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);
    
    fNoFog = max(fNoFog, fDoSky);
    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 / radians(180.0)) + vUV.x * 320.0;
    float fSkyV = vUV.y * 240.0;
    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);
    #endif
    
    // fade in effect
	#ifdef INTRO_EFFECT
    float fEffectOffset = max(iTime - 1.0, 0.0) - hash(vUV.x);
    vec2 vEffectUV = vUV;
    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);
    
    float fDoEffect = step(vEffectUV.y, 1.0);       
    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);
    fNoFog = max(fNoFog, fDoEffect);
    #endif    

	#ifdef DISCARD_BACKGROUND    
    if(vHitInfo.w == 0.0) discard;
	#endif
    
    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );
    float fDepth = dot(g_vRayDir, vForwards) * fClosestT;
    float fDepthFade = fDepth * kDepthFadeScale;
    float fApplyFog = 1.0 - fNoFog;
    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );
    
    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;
    
    vResult = clamp(vResult * 1.2, 0.0, 1.0);
    
    #ifdef QUANTIZE_FINAL_IMAGE
    vResult = Quantize(vResult);
    #endif    
    
    return vResult;
}

// Function 2305
vec4 drawParticles(in vec2 p)
{
    vec4 rez = vec4(0);
    vec2 w = 1./iResolution.xy;
    
    for (int i = 0; i < numParticles; i++)
    {
        vec2 pos = texture(iChannel0, vec2(i,50.0)*w).rg;
        vec2 vel = texture(iChannel0, vec2(i,0.0)*w).rg;
        float d = mag(p - pos);
        d *= 500.;
        d = .01/(pow(d,1.0)+.001);

        //rez.rgb += d*abs(sin(vec3(2.,3.4,1.2)*(time*.01 + float(i)*.0017 + 2.5) + vec3(0.8,0.,1.2))*0.7+0.3)*0.04;
        rez.rgb += d*abs(sin(vec3(2.,3.4,1.2)*(time*.07 + float(i)*.0017 + 2.5) + vec3(0.8,0.,1.2))*0.7+0.3)*0.04;
        pos.xy += vel*0.002*0.2;
    }
    
    return rez;
}

// Function 2306
float circle(vec2 st, vec2 position, float radius) {
    return 1.-step(radius, length(position-st));
}

// Function 2307
float line_dist(vec2 uv, const vec2 p0, vec2 p1){
	vec2 tang=p1-p0;
	vec2 nor=normalize(vec2(tang.y,-tang.x));

	if(dot(tang,uv)<dot(tang,p0)){
		return distance(p0,uv);
	}
	else if(dot(tang,uv)>dot(tang,p1)){
		return distance(p1,uv);
	}
	else{
		return dot(nor,uv)-dot(nor,p0);
	}
}

// Function 2308
float FillLineDash(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {
    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 1.0);
    return saturate(df / abs(dFdy(uv).y));
}

// Function 2309
bool draw_line(vec2 p, vec2 a, vec2 b){
    vec2 ab = normalize(b - a);
    vec2 ap = p - a;
    return length((a + ab * dot(ab, ap)) - p) < .01;
}

// Function 2310
vec3 drawMap( vec3 col, in vec2 fragCoord )
{
    vec2 p = fragCoord/iResolution.y;
    p.x += 0.5*(1.0-iResolution.x/iResolution.y); // center
    float wp = 1.0/iResolution.y;

    vec2 q = floor(p*31.0);
    vec2 r = fract(p*31.0);
    float wr = 31.0*wp;

    if( q.x>=0.0 && q.x<=27.0 )
    {
        float c = texture( iChannel0, (q+0.5)/iResolution.xy, -100.0 ).x;

        // empty
        if( c<0.5 )
        {
        }
        // walls
        else if( c<1.5 )
        {
            vec2 wmi = vec2( texture( iChannel0, (q-vec2(1.0,0.0)+0.5)/iResolution.xy ).x,
                             texture( iChannel0, (q-vec2(0.0,1.0)+0.5)/iResolution.xy ).x );
            vec2 wma = vec2( texture( iChannel0, (q+vec2(1.0,0.0)+0.5)/iResolution.xy ).x,
                             texture( iChannel0, (q+vec2(0.0,1.0)+0.5)/iResolution.xy ).x );
			
            wmi = step( abs(wmi-1.0), vec2(0.25) );
            wma = step( abs(wma-1.0), vec2(0.25) );
            vec2 ba = -(0.16+0.35*wmi);
            vec2 bb =  (0.16+0.35*wma);

            //bb = vec2(0.51); ba = -bb;

            float d = sdBox(r-0.5, ba, bb);
            float f = 1.0 - smoothstep( -0.01, 0.01, d );
            
            vec3 wco = 0.5 + 0.5*cos( 3.9 - 0.2*(wmi.x+wmi.y+wma.x+wma.y) + vec3(0.0,1.0,1.5) );
            wco += 0.1*sin(40.0*d);
            col = mix( col, wco, f );
        }
        // points
        else if( c<2.5 )
        {
            float d = sdCircle(r-0.5, 0.15);
            float f = 1.0 - smoothstep( -wr, wr, d );
            col = mix( col, vec3(1.0,0.8,0.7), f );
            //col += 0.3*vec3(1.0,0.7,0.4)*exp(-12.0*d*d); // glow
        }
        // big alls
        else
        {
            float d = sdCircle( r-0.5 ,0.40*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iTime) ));
            float f = 1.0 - smoothstep( -wr, wr, d );
            col = mix( col, vec3(1.0,0.9,0.5), f );
        }
    }
    
    return col;
}

// Function 2311
void drawSwordIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {
    coord = (coord-lt) / size;
    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    
		vec4 col = drawSword(coord, level);
        color = mix( color, col, col.a );
    }
}

// Function 2312
void drawSun(in vec2 uvCoords, inout vec4 canvas)
{
    vec2 origin = vec2(0.0, 0.0);
    float radius = 0.25;
    float blurAmount = 0.4;
    vec3 color = vec3(1.0, 1.0, 0.2);
    origin.x *= getAspectRatio();
    float color_amount = 1.0 - smoothstep(radius - blurAmount, radius + blurAmount, distance(origin, uvCoords));
    canvas += vec4(color_amount * color, 0.0);
}

// Function 2313
vec4 linear_to_gamma(vec4 c)
{
    return vec4(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b), c.a);
}

// Function 2314
float draw_grid(vec2 uv){
    vec2 grid_2D = smoothstep(length(fwidth(uv)) * 2., .0, abs(sin(PI * uv)));
    return max(grid_2D.x, grid_2D.y);
}

// Function 2315
float smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){
    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;
}

// Function 2316
float sdCircle (vec2 p, vec2 pos, float r) {
	return length(p - pos) - r;
}

// Function 2317
float rect(vec2 p, vec2 s) {
    vec2 a = abs(p) - s;
    return a.x < 0. || a.y < 0. ? max(a.x, a.y) : length(a);
}

// Function 2318
float sdLineCreneaux(vec3 p) {
    float d =  max(abs(p.z)-.025, abs(p.y+.13)-.26); // mur du creneau
    d = min(d, max(abs(p.z+.15)-.15, abs(p.y+.11)-.05)); // chemin de ronde
    p.x = mod(p.x+.1, .2)-.1;
    d = min(d, length(p.zy-vec2(.025,-.11))-.01); // petit cylindre decoratif
    vec3 p1 = p.zyx;
    pR45(p.yz);
	d = max(d, p.z-.18); // champfrein	
	return max(d, 
        -min(fBoxCheap(p1.yz-vec2(-.25,0.), vec2(.05,.07)), // fentes du bas
        	 fBoxCheap(p1.yz-vec2(.08,0.), vec2(.1,.03)))); // fente dans les meurtrieres
}

// Function 2319
float sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)
{
    vec2 dir0 = p1 - p0;
	vec2 dir1 = coord - p0;
	float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);
	return (length(dir1 - dir0 * h) - width * 0.5);
}

// Function 2320
float rectangleSharp(vec2 r, vec2 topLeft, vec2 bottomRight) {
	float ret;
	ret = step(topLeft.x, r.x);
	ret *= step(topLeft.y, r.y);
	ret *= 1.0 - step(bottomRight.y, r.y);
	ret *= 1.0 - step(bottomRight.x, r.x);
	return ret;
}

// Function 2321
vec3 drawPerspectiveScene(Cam perspectiveCam, vec2 uv, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, vec3 cBackground, float fZoom)
{
    vec3 cScene = cBackground;
    cScene = texture(iChannel0,uv+0.5).xyz;
    
	float fLineWidth = 0.0025;
    cScene = drawLine(uv, ssQuad.a, ssQuad.b, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.b, ssQuad.c, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.c, ssQuad.d, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.d, ssQuad.a, cScene, vec3(0), fLineWidth, fZoom);
    
    float fPointRad = 0.006;
    cScene = drawPoint(uv, ssQuad.a, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.b, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.c, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.d, cScene, vec3(0,1,0), fPointRad, fZoom);
    
    //Show results
    fPointRad = 0.004;
    vec2 aDebug = camProj(perspectiveCam,wsQuad.a);
    vec2 bDebug = camProj(perspectiveCam,wsQuad.b);
    vec2 cDebug = camProj(perspectiveCam,wsQuad.c);
    vec2 dDebug = camProj(perspectiveCam,wsQuad.d);
    cScene = drawPoint(uv, aDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, bDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, cDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, dDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    
    return cScene;
}

// Function 2322
vec3 parabola2circle(in vec3 p) {
    vec3 q;
    
    q.y = p.z - p.y;
    q.z = p.z + p.y;
    q.x = p.x;
    
    return q; 
}

// Function 2323
vec3 draw_fire(float f)
{
    f = f * 0.5 + 0.5;
    return mix(	vec3(131.0/255.0, 8.0/255.0, 0.0/255.0),
              	vec3(204.0/255.0, 194.0/255.0, 56.0/255.0),
               	pow(f, 3.));
}

// Function 2324
float distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {
    return sqrt(distance2_point_line(point, origin, direction));
}

// Function 2325
float sdHexagonCircumcircle ( float3 p, float2 h ) {
  float3 q = abs(p);
  return max(q.y - h.y, max(q.x*sqrt(3.0)*0.5 + q.z*0.5, q.z) - h.x);
}

// Function 2326
vec3 drawCircles(vec2 uv)
{
    // Tiles and shifts the coordinate system
    uv = (fract(uv * nf) - 0.5) / nf;
    
    float t  = iTime,
    // Outer Radius
      rtime  = abs(cos(t * rotSpeed)) * rSqr,
        
    // Inner Radius
      rtime2 = abs(cos(t * rotSpeed)) * rSqr2,
        
    // Short for uv.x * uv.x + uv.y * uv.y
      circle = dot(uv,uv);
    
    // Rotates the coordinate system so the lines rotate
    uv *= mat2(cos(t),-sin(t),sin(t),cos(t));

    // First step gives 1.0 for every coord outside of the 
    // circle minus border thickness
    
    // Second step gives 1.0 for every coord inside the circle
    
    // Multiplied together they give 1.0 only for coords
    // on the border of the circle
#define CircleStep(v) step(rtime2, abs(v)) * step(abs(v), rtime) 
    
    // I don't fully understand why this works
#define LineStep(v) step(abs(v), lineBorder)
    
    float lines = LineStep(uv.x)
        	    + LineStep(uv.y)
                + LineStep((uv.x+uv.y)*.707)
                + LineStep((uv.x-uv.y)*.707);
    
    // Clamping prevents lines from drawing over each other
    lines = clamp(lines, 0.0, 1.0);
    
    // Returns 1.0 only if the current coord is inside radius
#define isInsideCircle(r) step(0.0, r - circle)

    return backCol
         + circCol * CircleStep(circle)
         + lineCol * isInsideCircle(rtime2)
                   * lines;
}

// Function 2327
void drawdisk(vec2 center,vec2 vel,float radius) 
{
    if (showSolution!=0) return;

    if (MotionBlur!=0)
    {
    	color = diskWithMotionBlur(color,sp,vec3(center,radius),vel/24.0,vec3(1.0,1.0,1.0),1.0);
    }
    else
    {   // antialiased disk
	    float val = clamp( -(length(center-sp)-radius)/pixelsize,-0.5,0.5 )+0.5;
	    color = max(color, vec3(1.0,1.0,1.0)*val);
    }
}

// Function 2328
void drawSeigaiha(inout vec3 color, in vec2 p, float r, int n){
  float d = length(p);
  if(d > r){ return; }
  float s = mod(floor(d * 2.0 * float(n) / r), 2.0);
  color = getRGB(0.65, s * 0.4, 1.0);
}

// Function 2329
float Line( vec2 p , vec2 a , vec2 b ) {
	float d = DistLine( p , a, b );			// distance (a - b ) from p.
   	float m = S( 0.03, 0.01 , d );
    
    // 이게 오묘한 식이다, p와의 거리가 아니라, ( a - b )의 거리를 말한다.
    float d2 = length( a - b );
    m *= S( 1.2, 0.8 , d2 ) * 0.5 + S( 0.05, 0.03, abs( d2 -0.75 ) );
    
    return m;
}

// Function 2330
vec3 draw_line(float d) {
    const float aa = 1.0;
    const float thickness = 0.0025;
    return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));
}

// Function 2331
float rectangle(vec2 p, float w, float h,float dx,float dy,float a)
{
	p.x -= dx;
	p.y -= dy;
	float x =  p.x *cos(a) - p.y* sin( a) ;
	float y = p.y *cos(a) + p.x *sin(a) ;
	float s = 0.01;
	return smoothstep(-w/2.,-w/2.+s,x)*smoothstep(x,x+s,w/2.)*smoothstep(-h/2.,-h/2.+s,y)*smoothstep(y,y+s,h/2.);
}

// Function 2332
void drawPenrose(inout vec3 ret, vec2 p, float aaSize) {
	// L to T
	square(ret, xRange(isoR(p)+vec2(0., 1.), 1., 2.), lightHSV, aaSize);
	// R to L
	square(ret, yRange(isoM(p), -3., 0.), mediumHSV, aaSize);
	square(ret, xRange(isoL(p)+vec2(0., 1.), -1., 2.), darkHSV, aaSize);
	// R to T
	square(ret, yRange(isoL(p)-vec2(3., 0.), -1., 2.), darkHSV, aaSize);
	square(ret, yRange(isoR(p)-vec2(4., 0.), -5., -1.), lightHSV, aaSize);
	// L to T cover
	square(ret, isoR(p)+vec2(-3., 1.), lightHSV, aaSize);
	square(ret, xRange(isoM(p), 1., 4.), mediumHSV, aaSize);
}

// Function 2333
vec3 linear_srgb(vec3 x) {
#ifdef GAMMA_CORRECT
    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x,vec3(0.0031308)));
#else
    return x;
#endif
}

// Function 2334
vec4 draw_player( int frame, int dir, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( -1 ) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), dim_player ) ) {
        frame &= 0x3 ;
        dir   &= 0x3 ;
             if( dir == 1 )  iu = iu.yx ;                    //right
        else if( dir == 2 )  iu = 15 - iu ;                  //down
        else if( dir == 3 )  iu = ivec2( iu.y, 15 - iu.x ) ; //left
        int row_group = frame * 4 + 3 - ( iu.y >> 2 ),
            component = 3 - ( iu.y & 0x3 ),
            sh = 2 * iu.x ;
        uint bits = 0x3U << sh,
             col_ind = ( get_player_br( row_group, component ) & bits ) >> sh ;
        v = get_col( pal_player, col_ind ) ;
    }
    o = v.a > 0. ? v : o ;
    return( v ) ;
}

// Function 2335
bool onRect(vec2 p, vec2 center, vec2 size) {
  return !(p.x > center.x + size.x*0.5 ||
             p.x < center.x - size.x*0.5 ||
             p.y > center.y + size.y*0.5 ||
             p.y < center.y - size.y*0.5 );

}

// Function 2336
SHitInfo TestCircle (in vec2 coordinate, in SCircle circle)
{
	float dist = length(circle.m_center - coordinate) - circle.m_radius;
	
	if (dist <= 0.0)
	{
		return SHitInfo
			(
				0.0,
				circle.m_color
			);
	}
	else
	{
		return SHitInfo
			(
				dist,
				circle.m_color * 0.25
			);		
	}
}

// Function 2337
float drawDigit( float dig, vec2 pos, vec2 pixel_coords )
{
	if( dig == 1. )
		return drawDig( pos, pixel_coords, 18724. );
	if( dig == 2. )
		return drawDig( pos, pixel_coords, 31183. );
	if( dig == 3. )
		return drawDig( pos, pixel_coords, 31207. );
	if( dig == 4. )
		return drawDig( pos, pixel_coords, 23524. );
	if( dig == 5. )
		return drawDig( pos, pixel_coords, 29671. );
	if( dig == 6. )
		return drawDig( pos, pixel_coords, 29679. );
	if( dig == 7. )
		return drawDig( pos, pixel_coords, 31012. );
	if( dig == 8. )
		return drawDig( pos, pixel_coords, 31727. );
	if( dig == 9. )
		return drawDig( pos, pixel_coords, 31719. );
	// 0
	return drawDig( pos, pixel_coords, 31599. );
}

// Function 2338
PatchIsect iBilinearPatch(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {
    vec2 m = rd.yz / rd.x;
    vec3 p = a - b + c - d, q = d - a, r = b - a;
    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;
    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;

    // Quadratic coefficients (reversed as a trick to deal with edge cases)
    float qa = cross2D(c4, c2);
    float qb = cross2D(c4, c1) + cross2D(c3, c2);
    float qc = cross2D(c3, c1);

    float discr = qb * qb - 4.0 * qa * qc;
    if (discr > 0.0) {
        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve for v parameter
        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x); // Substitute v and solve for u parameter
        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x; // Substitute u and v and solve for t parameter

        // Compute normals (cross products of partial derivatives)
        vec3 n1 = normalize(cross(p * v.x + q, p * u.x + r));
        vec3 n2 = normalize(cross(p * v.y + q, p * u.y + r));

        return PatchIsect(true, t, vec2[2](vec2(u.x, v.x), vec2(u.y, v.y)), vec3[2](n1, n2));
    }

    return PatchIsect(false, vec2(-1.0), vec2[2](vec2(0.0), vec2(0.0)), vec3[2](vec3(0.0), vec3(0.0)));
}

// Function 2339
float drawWall(in vec2 p, vec2 dr) {
    p = fract(rotateTo(p, dr)) - .5;
    p.y = max(0., -p.y);
    return length(p) - 0.15;
}

// Function 2340
vec3 draw(in vec3 buffer, in float dist, in float radius, in vec3 color)
{
    float up = min(iResolution.x, iResolution.y);
    dist *= up;
    const float scale =  1.0 / 360.0;
    radius *= up * scale;
  	float aa = 0.5 * fwidth(dist);
    vec3 mixed = mix(buffer, color, 1.0 - smoothstep(radius - aa, radius + aa, dist));
   	return mixed;
}

// Function 2341
vec3 rayDirection(vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(CAMERA_FOV) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 2342
float line (vec2 p, vec2 a, vec2 b) {
	p -= a;
	b -= a;
	a = p - b * dot (p, b) / dot (b , b);
	b *= 0.5;
	p = abs (p - b) - abs (b);
	return max (length (a), max (p.x, p.y));
}

// Function 2343
float circleNW(vec2 q, vec2 pos ) {
    vec2 p = q - pos;
    
    if(p.x < 0.0 && p.y > 0.0) {
        return pow(R - sqrt(p.x*p.x + p.y*p.y ), 2.0) - r;
    } else {
        return 10.0;
    }
}

// Function 2344
float getCircle(vec2 p, vec2 rp){
	p *= vec2(iResolution.x, iResolution.y);
    p /= max(iResolution.x, iResolution.y);
    
    return step(distance(p, rp), 0.1);
}

// Function 2345
float sdRect(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return max(d.x, d.y) + min(max(d.x, d.y), 0.0);
}

// Function 2346
vec3 getDirection(float number)
{
    vec3 dir = vec3(0);
    dir.x = step(1.0, number) * step(number, 2.0 - 1e-3) - step(2.0, number) * step(number, 3.0 - 1e-3);
    dir.y = step(3.0, number) * step(number, 4.0 - 1e-3) - step(4.0, number) * step(number, 5.0 - 1e-3);
    dir.z = step(5.0, number) * step(number, 6.0 - 1e-3) - step(6.0, number) * step(number, 7.0);
    return dir;
}

// Function 2347
vec3 DrawCandy1(vec2 p, vec3 bgColor)
{
    vec2 pos[7];
    pos[0]=vec2(0., 0.); 
    pos[1]=vec2(-0.23, 0.34); pos[2]=vec2(0.23, 0.34); pos[3]=vec2(0.42, 0.0);
    pos[4]=vec2(0.23, -0.34); pos[5]=vec2(-0.23, -0.34); pos[6]=vec2(-0.42, 0.0);
    
    
    vec3 color = vec3(0.572, 0.047, 0.752);
    float d2 = 1.;
    for(int i=0; i<7;++i)
    {
        vec2 q = p-pos[i];
        float d = length(q)-0.22;
        
        vec3 baseColor = vec3(0.572, 0.047, 0.752);
        vec3 cubeTex = texture(iChannel2, normalize(vec3(q.xy,1.)) *RotZ(1.8) ).rgb;
        baseColor *= 1.+cubeTex.r*0.25;
        baseColor += (1.-smoothstep(0., 1., pow(abs(length((q-vec2(-0.05, 0.05))*vec2(1.2, 2.2))), 0.2) ))*1.5;
        color = mix(baseColor, color, smoothstep(0., 1e-2, d));
        d2 = smin(d, d2, 0.2);
    }
    color = mix(color, vec3(0.), smoothstep(0.0, 1., 1.-exp(-4.5*max(d2+0.1, 0.)) ));
    return mix(color, bgColor, smoothstep(0., 2e-2, d2));
}

// Function 2348
float sdf_line6n(vec2 p,vec2 a){return sdf_line6(p,normalize(a));}

// Function 2349
float circle(vec2 uv, vec2 c, vec2 p)
{
    vec2 a = uv-c, r = p-c;
    float fx = 1.0-dot(a,a)/dot(r,r);
    return clamp(fx*sharpness, 0.0, 1.0);
}

// Function 2350
vec2 Support_VertLine (float size, vec2 dir)
{
    return vec2(0.0,sign(dir.y)*size);
}

// Function 2351
float drawFloat(float v,int p){return drawFloat(v,p,2);}

// Function 2352
vec4 drawUI()
{   
  	SETUP_UI;
    
    vec2 centerPt = vec2(floor(RES_X*0.5), floor(RES_Y*0.5));
    
    // Show controls
    if(time_scale == 0.0 && iFrame > 0)
    {
        PLOT(fRect(centerPt, vec2(50, 25)));
        COLOR(BLACK);
        DRAW;    
        PLOT(fRect(centerPt-vec2(0,26), vec2(51, 0)));
        COLOR(GRAY);
        DRAW;
        PLOT(fRect(centerPt+vec2(0,26), vec2(51, 0)));
        COLOR(WHITE);
        DRAW;
        PLOT(fRect(centerPt-vec2(51,0), vec2(0, 25)));
        COLOR(WHITE);
        DRAW;
        PLOT(fRect(centerPt+vec2(51,0), vec2(0, 25)));
        COLOR(GRAY);
        DRAW;
        
        // CONTROLS
        PLOT(fRect(centerPt+vec2(0,16), vec2(16, 0)));
        COLOR(WHITE);
        DRAW;
        STR(44,54) C(_C)C(_O)C(_N)C(_T)C(_R)C(_O)C(_L)C(_S)
        
        // WSAD/ARROWS PITCH+ROLL
        STR(11,43) C(_W)C(_S)C(_A)C(_D)S(_SLASH)C(_A)C(_R)C(_R)C(_O)C(_W)C(_S)
        STR(69,43) C(_P)C(_I)C(_T)C(_C)C(_H)S(_PLUS)C(_R)C(_O)C(_L)C(_L)
        
        // Q+E YAW
        STR(11,36) C(_Q)S(_PLUS)C(_E)
        STR(69,36) C(_Y)C(_A)C(_W)
        
        // J+K THROTTLE
        STR(11,29) C(_J)S(_PLUS)C(_K)
        STR(69,29) C(_T)C(_H)C(_R)C(_O)C(_T)C(_T)C(_L)C(_E)
        
        // H FANTASTIC!
        STR(11,22) C(_H)
        STR(69,22) C(_F)C(_A)C(_N)C(_T)C(_A)C(_S)C(_T)C(_I)C(_C)S(_EXCLAM)
        
        // P UNPAUSE
        STR(11,15) C(_P)
        STR(69,15) C(_U)C(_N)C(_P)C(_A)C(_U)C(_S)C(_E)
        
        // DIVIDERS
        STR(59,43) S(_HYPHEN)
        STR(59,36) S(_HYPHEN)
        STR(59,29) S(_HYPHEN)
        STR(59,22) S(_HYPHEN)
        STR(59,15) S(_HYPHEN)
        COLOR(WHITE);
        DRAW;
    } else
    {
        // Logo
        if(gtime < 16.0)
        {
            int logoX = int(RES_X)-18;
            PLOT(fRect(vec2(logoX,4), vec2(10, 3)));
            COLOR(BLACK);
            FADE_IN(2.0, 3.0);
            FADE_OUT(8.0, 10.0);
            DRAW;

            // LAIKA
            STR(logoX-7,6) C(_L)C(_A)C(_I)C(_K)C(_A)
            COLOR(WHITE);
            FADE_IN(2.0, 3.0);
            FADE_OUT(8.0, 10.0);
            DRAW;
            
            PLOT(fRect(vec2(37,4), vec2(32, 3)));
            COLOR(BLACK);
            FADE_IN(10.0, 11.0);
            FADE_OUT(14.0, 16.0);
            DRAW;
            
			// PRESS P FOR HELP
            STR(8,6) C(_P)C(_R)C(_E)C(_S)C(_S) SPACE C(_P) SPACE C(_F)C(_O)C(_R) SPACE C(_H)C(_E)C(_L)C(_P)
            COLOR(WHITE);
            FADE_IN(10.0, 11.0);
            FADE_OUT(14.0, 16.0);
            DRAW;
        }
        
    	// Crosshairs
    	PLOT(PlotPoint(centerPt.x, centerPt.y+2.) + PlotPoint(centerPt.x, centerPt.y-2.) +
        	 PlotPoint(centerPt.x+2., centerPt.y) + PlotPoint(centerPt.x-2., centerPt.y));
    	COLOR(WHITE);
    	DRAW;
    }
    
    return vec4(drawColor, inPix);
}

// Function 2353
float sdRect(vec2 p, vec2 r)
{
    p=abs(p)-r;
    return max(p.x,p.y);
}

// Function 2354
float sdLine(vec2 pos, float r)
{
    return length(pos)-r;
}

// Function 2355
float sdCircle( vec2 p, float s) {
  return length(p)-s;
}

// Function 2356
float sdTorusDualMedianCircle(const vec3 p, vec2 r, float inner_circle_scale) {
  return min(   sdTorusMedianCircle(p, r,inner_circle_scale),
             sdTorusMedianCircle(-p, r,inner_circle_scale));
    
}

// Function 2357
float dline(vec2 p, vec2 a, vec2 b, float dash) {
    
    p -= a;
    b -= a;
    
    float l2 = dot(b,b);
    float l = sqrt(l2);
    
    float u = clamp(dot(p, b) / l2, 0., 1.);
    
    float d = length(p - u*b);
    
    if (dash != 0.) {
        float p = dash/6.28;
        d = max(d, -sin(u*l/p)*p);
    }
    
    return d;
    
}

// Function 2358
float Circle( vec2 p, float r )
{
    return ( length( p / r ) - 1.0 ) * r;
}

// Function 2359
float distLine(vec2 a, vec2 b){
     
	b = a - b;
	float h = clamp(dot(a, b)/dot(b, b), 0., 1.);
    return length(a - b*h);
}

// Function 2360
vec4 drawCellRockford(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    int localFrame = animFrame - state.z;
    int cycle = max(localFrame / ROCKFORD_ANIM_LENGTH - ROCKFORD_IDLE_COOLDOWN, 0);
    bool isBlinking = onOffNoise(cycle + 46, vec4(0.77, 1.0, 1.79, 3.38), -0.48);
    bool isTapping = onOffNoise(cycle + 113, vec4(1.0, 1.81, 3.41, 0.21), 0.0);

    bool isIdle = (state.y & ROCKFORD_STATE_IDLE) > 0;
    bool isRight = (state.y & ROCKFORD_STATE_RT) > 0;

    Sprite sprite;

    if (isIdle)
    {
        if ((cycle == 0) || (!isBlinking && !isTapping))
        {
            sprite = getSpriteRockfordIdle();
        }
        else if (isBlinking && !isTapping)
        {
            sprite = getSpriteRockfordIdleBlink(localFrame);
        }
        else if (!isBlinking && isTapping)
        {
            sprite = getSpriteRockfordIdleTap(localFrame);
        }
        else
        {
            sprite = getSpriteRockfordIdleTapBlink(localFrame);
        }
    }
    else
    {
        sprite = getSpriteRockfordWalkLeft(animFrame);
    }

    coord.x = (!isIdle && isRight) ? CEL_RES.x - 1 - coord.x : coord.x;
    return sampleSprite(sprite, colors, coord);
}

// Function 2361
float Line(vec2 uv, vec2 a, vec2 b, float t)
{
    return Sharpen(DistToLine(uv, a, b), t, 1.0);
}

// Function 2362
float fLineSegment(vec3 p, vec3 a, vec3 b) {
    vec3 ab = b - a;
    float t = saturate(dot(p - a, ab) / dot(ab, ab));
    return length((ab*t + a) - p);
}

// Function 2363
float drawFloat(float value)           {return drawFloat(value,2,5);}

// Function 2364
vec3 srgb_linear(vec3 x) {
    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x,vec3(0.04045)));
}

// Function 2365
vec3 linear2srgb(vec3 c) {
    return mix(
        12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055,
        step(vec3(0.0031308), c));
}

// Function 2366
void endDraw()
{
    float a = smoothstep(1.,.0, smoothstep(.51,.53,fontBuffer.a));
    float b = smoothstep(.0,1.,smoothstep(.48,.51,fontBuffer.a));
    
    fontCol.rgb = mix( fontColFill , fontColBorder , b );
    fontCol.a = a;
}

// Function 2367
int drawArrows(inout vec4 col)
{
  // draw triangle arrows and check input
  float s= 0.1, s2 = 0.05;
  float x= iResolution.x / iResolution.y * 0.91;  // arrow x middle position  
  float y= -0.75;
  bool inside1 = arrow(vec2(x,y-2.*s),vec2(x-s,y-s2), vec2(x+s,y-s2), col);
  bool inside2 = arrow(vec2(x-s,y+s2),vec2(x,y+2.*s), vec2(x+s,y+s2), col);

  int command = 0;  
  if (inside1) command = 1;
  if (inside2) command = 2;
  return command;
}

// Function 2368
vec4 paCircle( in vec2 p, float r, float band ) 
{
    float d = length(p) - r;
    
    float ra = band*round(d/band);
    
    // show local and global parametrization
    ra = (fract((iTime+0.1)/5.0)<0.5)?ra:0.0;
    
    float l = (r+ra)*(atan(p.x,p.y)+3.1415927);
    
    return vec4( d-ra, l, 6.283185*(r+ra), d );
}

// Function 2369
float drawSpike(in vec2 st){
    float a=1.0;
    st.y -= .5;
    if (abs(st.y)-pow((st.x-0.5)*4.+0.036,3.)*0.01 < 0.017 && st.x < 0.936){
        a = 0.;
    }
    
    return 1.-a;
}

// Function 2370
vec4 draw_char() {
    int c = char_id; vec2 p = char_pos;
    return c < 0 
        ? vec4(0,0,0,1e5)
        : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), 
                       dfdx, dfdy );
}

// Function 2371
void UI_DrawSliderX( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))
        return;
    
    Rect horizLineRect;
    
    horizLineRect = sliderRect;
    if (!scrollbarStyle)
    {
	    float fMid = sliderRect.vPos.y + sliderRect.vSize.y * 0.5;
    	horizLineRect.vPos.y = fMid - 2.0;
    	horizLineRect.vSize.y = 4.0;
    }

#ifdef NEW_THEME    
    DrawBorderRect( uiContext.vPixelCanvasPos, horizLineRect, cSliderLineCol, uiContext.vWindowOutColor );
#else    
    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );
#endif

    float fSlideMin = sliderRect.vPos.x + fHandleSize * 0.5f;
    float fSlideMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;

    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);

    Rect handleRect;

    handleRect = sliderRect;
    handleRect.vPos.x = fDistSlider - fHandleSize * 0.5f;
    handleRect.vSize.x = fHandleSize;

    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);
    if ( bActive )
    {
        handleColor.rgb += 0.1;
    }       
    
    // highlight
#ifdef NEW_THEME     
    if ( (uiContext.vPixelCanvasPos.y - handleRect.vPos.y) < handleRect.vSize.y * 0.3 )
    {
        handleColor.rgb += 0.05;
    }
#endif    

    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );

#ifdef NEW_THEME   
    DrawBorderRect( uiContext.vPixelCanvasPos, handleRect, cSliderHandleOutlineCol, uiContext.vWindowOutColor );
#else    
    DrawBorderOutdent( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );
#endif    
}

// Function 2372
vec3 LinearToSRGB(vec3 rgb)
{
    rgb = clamp(rgb, 0.0, 1.0);
    
    return mix(
        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,
        rgb * 12.92,
        lessThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308))
    );
}

// Function 2373
float circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}

// Function 2374
vec4 scanLine( in vec4 c, in float y ) 
{
	float scanLines = 256.0;
    float intensity = 0.8 + 0.2 * sin(y * scanLines * 2.0*PI);
    vec4 result = vec4(intensity * c.rgb, 1.0);
    return result;
}

// Function 2375
float circle(vec2 uv){
	return abs(length(uv)-size.x);   
}

// Function 2376
float CirclesTangents(vec2 pix, vec3 C1, vec3 C2)
{          
    float outer = CircleOuterTangents(pix, C1, C2);
    // The inner tangent lines are given by negating one of the circles' radii
    C1.z *= -1.0;
    float inner = CircleOuterTangents(pix, C1, C2);
    
    float signal = smoothstep(-0.15, 0.15, sin(iTime));    
    return mix(inner, outer, signal);
}

// Function 2377
vec4 draw_number_04( int n, ivec2 pos, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(0), ivec2(5*8,8) ) ) {
        int k ;
        if( n < 0 ) {
            n = - n ;
            v += draw_character( _DASH, pos, iu ) ;
            pos.x += 8 ;
            k = 1000 ;
        } else {
            k = 10000 ;
        }
        while( k > 1 ) {
            n %= k ;
            k /= 10 ;
            v += draw_character( n / k + 1, pos, iu ) ;
            pos.x += 8 ;
        }
    }
    return( v );
}

// Function 2378
mat4 GetDirectionalLightMatrix ()
{
	mat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, -directionalLightRotationAxisAngle.w );
	mat4 tra = translate( -directionalLightSourcePosition.x, -directionalLightSourcePosition.y, -directionalLightSourcePosition.z );
	return rot * tra;     
}

// Function 2379
vec3 nTrilinearIsoSurf(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {
    vec4 u = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);
    return normalize(u.x * p.yxx * p.zzy + u.yyz * p.yxx + u.zww * p.zzy + vec3(b, c, e) - a);
}

// Function 2380
float dline(vec2 p, vec2 a, vec2 b) {
    
    vec2 ba = b-a;
    vec2 n = normalize(vec2(-ba.y, ba.x));
    
    return dot(p, n) - dot(a, n);
    
}

// Function 2381
float Circle(vec2 uv, float r, float blur)
	{
    	float d = length(uv);
        float c = smoothstep(r, r-blur, d);
        
        return c;
    
    }

// Function 2382
vec3 sampleIndirectLight(vec3 pos, vec3 normal){
    vec3 dir = getCosineWeightedSample(normal);
    vec3 light = vec3(0.);
    for(int i = 0; i < Bounces; i++){
        if(!trace(pos, dir, normal)) return light+background(dir);
        else light += directLight(pos, normal);
    }
    return light;
}

// Function 2383
float rectangle(vec2 r, vec2 topLeft, vec2 bottomRight, float d) {
	float ret;
	ret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);
	ret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);
	ret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);
	ret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);
	return ret;
}

// Function 2384
void DrawScanline( inout vec3 color, vec2 uv )
{
    float scanline 	= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );
    float grille 	= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    
    color *= scanline * grille * 1.2;
}

// Function 2385
float circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }

// Function 2386
vec3 makelinecoords(float t, vec2 centre, vec3 mobius) {
  float A = mobius.x, B = mobius.y, C = mobius.z;
  t -= 0.05*iTime;
  t = (tan(t*PI)-C)/A;
  // Infinities!
  if (abs(t) > 1e4) t = sign(t)*1e4;
  t = (t-B)/(1.0+t*B);
  return join(vec3(centre,1),vec3(centre+vec2(1,t),1));
}

// Function 2387
float circle(vec2 uv, vec2 C, float r, bool fill)
{
    vec2 p = uv-C;
    float fx = length(p)-r;
    float dist = fill? fx:abs(fx);
    return smoothout(dist);
}

// Function 2388
define DRAW_POLYGON(vs,p,rotation,isIn,c,t,col) {IN_POLYGON(vs,p,rotation,isIn);if(isIn){col=mix(col,c,t);}}

// Function 2389
Hit line(Ray r, vec3 pa, vec3 pb, float sr, int id)
{
    vec3 ab = pb-pa;
    vec3 oa = pa-r.o;
    
    float dabrd = dot(ab,r.d);
    float drdrd = dot(r.d,r.d);
    
    float det = dot(ab,ab)*drdrd-dot(ab,r.d)*dabrd;
    if (det == 0.) { return _miss; }

	vec3 sp = pa+ab*clamp((dot(oa,r.d)*dabrd-dot(oa,ab)*drdrd)/det,0.,1.);

    r.o -= sp;

    float a = drdrd;
    float b = 2.0*dot(r.o,r.d);
    float c = dot(r.o,r.o)-sr*sr;
    float d = pow(b,2.0)-4.0*a*c;

    if (d < 0.0) { return _miss; }
    
    float s = sqrt(d);
    float t = min(-b+s,-b-s)/(2.*a);
    
    return Hit(vec3(0), vec3(0), t, id);

    // vec3 p = r.o+sp+r.d*t;
	// vec3 n = normalize(p-sp);
    
    // return Hit(p, n, t, id);
}

// Function 2390
vec3 getScanline( vec2 pos, float off ) {
	// 3-tap gaussian filter to get colour at arbitrary point along scanline
    float d = 0.5-fract(pos.x*IRES.x);
	vec3 ca = getSample( pos, vec2(-1.0, off ) );
	vec3 cb = getSample( pos, vec2( 0.0, off ) );
	vec3 cc = getSample( pos, vec2( 1.0, off ) );
	float wa = gaussian( d-1.0, PIXEL_SHARPNESS );
	float wb = gaussian( d,     PIXEL_SHARPNESS );
	float wc = gaussian( d+1.0, PIXEL_SHARPNESS );
	return ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);
}

// Function 2391
void DrawFlicker(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    DrawGlow(p, t, fireColor, color);
    
    vec2 gravity = gGravity * 0.15;
    for(float i=0.; i < 16.5; ++i)
    {   
        // Main Properties
        float hashP = hash(id+i*1492.8561);
        float r = hashP*0.65;
        vec2 pDir = vec2(hash(t+i*99.8954)*2.-1., hash(t*t+i*9.8954))*0.5;
        
        pDir += cos(atan(pDir.y, pDir.x) * 6.)*0.15;
        
        vec3 pColor = mix(vec3(1.), fireColor, hashP);

        // Visibility Properties
        float sizeScale = (0.8+0.2*hashP);
        float size = sizeScale*expSize*0.1;

        // Position
        vec2 deltaPos = pDir + (0.5*hashP+0.5)*gravity*t*t;
        vec2 q = p - deltaPos;
        
        float flicker = max(sign(hash(i+t) - 0.95), 0.);

        // Draw Particle
        vec4 pFinalColor = DrawParticle(i, (q+0.*vec2(hash(i+t*0.1)*0.02, 0.)), size, t, pColor, 0.5, 9.*hash(i+t*20.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
}

// Function 2392
float circleMask(vec2 uv, float radius)
{
    float vL = length(uv);
    float circle = smoothstep(radius, radius - 0.04, vL);
    return circle;
}

// Function 2393
float sh_draw_shape(float q, vec2 s, int id)
{
	int ptSize = indices[id+1] - indices[id];
	for(int i = indices[id]; i < indices[id] + 2 * (ptSize / 2) - 2; i+=2)
		if(sh_point_in_quad(s, shapes[i], shapes[i + 1], shapes[i + 2], shapes[i + 3])) 
			return 1.0;
	return q;
}

// Function 2394
float rect(vec2 uv, vec2 pos, vec2 size) 
{
	return 1.0 - clamp(length(max(abs(uv - pos)-size, 0.0))*150.0, 0.0, 1.0);
}

// Function 2395
void DrawTree( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 treeTile )
{        
    float depth = treeTile.x + treeTile.y;
    if ( depth > zbuffer )
    {
        return;
    }
    
    pixel.y -= ISO_TILE * 0.25;
    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) / ISO_TILE, ( pixel.x - 2.0 * pixel.y ) / -ISO_TILE );
    tile = floor( iso );
    vec2 off = iso - tile;
    
    float px = ( treeTile.x - treeTile.y ) * ISO_TILE * 0.5;
    
    // top leaves
    if ( iso.x > treeTile.x + 0.2 && iso.y > treeTile.y + 0.2 && iso.x < treeTile.x + 0.45 && iso.y < treeTile.y + 0.45 )
    {
		zbuffer = depth;
		color = RGB_TREE_LEAVES * 1.0;
    }
    
	// left leaves
    if ( pixel.x >= px - 0.125 * ISO_TILE && pixel.x < px && iso.x > treeTile.x - 0.1 && iso.x < treeTile.x + 0.2 && iso.x > treeTile.x - 0.1 )
    {
		zbuffer = depth;
		color = RGB_TREE_LEAVES * 0.8;
    }
    
	// right leaves
    if ( pixel.x >= px && pixel.x < px + 0.125 * ISO_TILE && iso.y < treeTile.y + 0.2 && iso.y > treeTile.y - 0.1 )
    {
		zbuffer = depth;
		color = RGB_TREE_LEAVES * 1.2;
    }    
    
    // left trunk
    if ( pixel.x >= px - 0.039 * ISO_TILE && pixel.x < px && iso.x <= treeTile.x - 0.1 && iso.x > treeTile.x - 0.4 )
    {
        zbuffer = depth;        
		color = RGB_TREE_TRUNK * 0.8;
    }    
    
    // right trunk
    if ( pixel.x >= px && pixel.x < px + 0.039 * ISO_TILE && iso.y <= treeTile.y - 0.1 && iso.y > treeTile.y - 0.4 )
    {
		zbuffer = depth;
		color = RGB_TREE_TRUNK * 1.1;
    }
}

// Function 2396
vec2 Support_Circle (float radius, vec2 dir)
{
    return dir * radius;
}

// Function 2397
float circle(vec2 pt, vec2 center, float r, float lw) {
  float len = length(pt - center),
        hlw = lw / 2.,
        edge = .01;
  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);
}

// Function 2398
vec3 Circle(vec2 center, float radius,vec3 color,float blur,vec2 uv){
    float dist= length(uv - center );
	return smoothstep(radius,radius-blur,dist) * color;
}

// Function 2399
vec3 draw_minute(vec2 uv) 
{
    float minuteCenter = fract(iDate.w / 3600.); 
    float f = abs(uv.x - minuteCenter);
    
    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.02, .0, pow(uv.y, 1.6)));
    float beamSpread = .005 + .05 * max(0., pow((.9 - uv.y), 3.));
    lightBeam *= smoothstep( MINUTE_WIDTH + beamSpread, MINUTE_WIDTH - beamSpread, abs(uv.x - minuteCenter));
    
    float lightIntensity = lightBeam;
    lightIntensity += .8 * smoothstep(.03, .0, uv.y) * smoothstep(.03, .0, abs(uv.x - minuteCenter)); 
    
    lightIntensity *= atmos( 4.5 * (uv + vec2(40., 40.)) ); // scale and shift fog to fake depth
    
    return vec3(1., .41, .18) * lightIntensity;
}

// Function 2400
float sdLine( vec2 pos, vec2 p1, vec2 p2, float crop, inout float f)
{
    pos-=p1; p2-=p1;
    float l=length(p2);
    vec2 t=p2/l;
  	float pp = dot(pos,t);
  	float pn = dot(pos,t.yx*vec2(1,-1));
    f=(l<.001)?0.:pp/l;
  	return (l<.001)?100000.:max(max(pp-l+crop,-pp+crop),abs(pn));
}

// Function 2401
vec3 cosineDirection(int seed, in vec3 nor
){seed=seed*7+11
 ;int n=int(seed)    
 ;float f=float(n)*pow(2.,13.)
 ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.
 ;n=n*(n*n*15731+789221)+1376312589
 ;int nx=n*n
 ;int ny=n*n*16807
 ;nx=abs(nx)
 ;ny=abs(nx)
 ;vec2 r=vec2(nx,ny)
  ;r=r/float(0x7fffffff)
    //;vec2 r = hash2( seed);
    // by fizzer: http://www.amietia.com/lambertnotangent.html
    ;float a = 6.2831853 * r.y;
    float u = 2.0*r.x - 1.0;
    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
}

// Function 2402
float drawLine(vec2 a, vec2 b, vec2 p) {
    return 1.0 - SqDistancePtSegment(a,b,p);
}

// Function 2403
void DrawW( inout vec3 color, float x, float y )
{
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if (    ( x <= 3.0 || x >= 10.0 ) 
             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )
             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )
             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )
           )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 2404
void raytraceHillTreeline(vec3 rayPt, vec3 rayDir, float treelineX, float treeGapZ, float offZ, float offY, float slopeY){
    
    if (rayDir.x < 0.0) treelineX *= -1.0;
    
    float groundY = 0.0;
    
    float rayGapStepsX = (treelineX-rayPt.x)/rayDir.x;
    float rayZ = rayPt.z + rayDir.z*rayGapStepsX;
    float treeZ = floor((rayZ-offZ)/treeGapZ)*treeGapZ + treeGapZ*0.5 + offZ;
    
    if (treeZ > 40.0) return;
    if (treeZ < -70.0) return;
    
    const float hillNearZ = 0.0;
    if (treeZ > hillNearZ) groundY = (treeZ-hillNearZ)*slopeY;
    
    groundY += offY;
    
    raytraceTree(rayPt,rayDir,vec3(treelineX,groundY,treeZ),
    	sin(treeZ+treelineX)*1.5,//yOff
        sin(treeZ*0.7+treelineX)*4.0,//heightOff
        sin(treeZ*0.85+treelineX)*1.0//widthOff
    );
    
    //#ifdef DRAW_CLIP_RAYTRACES
    //color.g += sin(treeZ*0.2)*0.1+0.5;
    //#endif
    
}

// Function 2405
vec4 draw_font8x8_number_05( int n, vec4 col, ivec2 pos, inout vec4 o, ivec2 iu ) {
    vec4 v = vec4( 0 ) ;
    ivec2 iu2 = iu - pos ;
    if( iINSIDE( iu2, ivec2(0), ivec2(5*8,8) ) ) {
        int p = ( ( 5*8 - 1 ) - iu2.x ) / 8,
            d = int( round( pow( 10., float(p) ) ) ),
            c = ( n / d ) % 10 ;
        v += draw_font8x8_char( c + 1, col, pos + ivec2( (4-p) * 8, 0 ), o, iu ) ;
    }
    return( v ) ;
}

// Function 2406
vec3 drawSubEyes(vec3 col, vec2 uv, vec2 mouse, out float dist) {
    uv -= vec2(-.7,-.065);
    mouse -= vec2(-.7,-.065);
    uv.x *= 1.+uv.y*uv.y*1.5;
    float mask = capsule(uv, .17, .11);
    
    float topEyeDist, bottomEyeDist;
    vec3 topEyeLayer =    smallEye(uv-vec2(.0,.085), mouse-vec2(.0,.085), vec2(.12,.7896), vec3(.7, .2, .5), topEyeDist);
    vec3 bottomEyeLayer = smallEye(uv-vec2(.0,-.11), mouse-vec2(.0,-.11), vec2(8.1,54.16), vec3(1., .15, .14), bottomEyeDist);
    float eyesMask = max(topEyeDist, bottomEyeDist);
    
    // Inter eyes
    float h1Stripes = stripes(uv*vec2(3.5,1.)+vec2(iTime*.08,.0), StripesOpt(0.,0.,0.));
    float h1InnerMask = min(mask, -eyesMask)-.01;
    h1InnerMask = min(h1InnerMask, -max(abs(uv.x)-.2, abs(uv.y)-.1));
    float h1StripesMask = h1InnerMask-.005;
    h1Stripes = smin(h1Stripes, h1StripesMask, .01);
    
    // Top of eyes
    float h2Stripes = stripes(uv*vec2(3.5,1.)+vec2(iTime*.08,.0), StripesOpt(0.,0.,0.));
    float h2InnerMask = min(mask, -eyesMask)-.01;
    h2InnerMask = min(h2InnerMask, uv.y-.1);
    float h2StripesMask = h2InnerMask-.005;
    h2Stripes = smin(h2Stripes, h2StripesMask, .01);
    
    // Bottom of eyes
    float h3Stripes = stripesCircle(uv-vec2(.0,.3), StripesCircleOpt(.3, .7, 4.5, -.03, 32.7), StripesOpt(0.,0.,0.));
    float h3InnerMask = min(mask, -eyesMask)-.01;
    h3InnerMask = min(h3InnerMask, -uv.y-.1);
    float h3StripesMask = h3InnerMask-.005;
    h3Stripes = smin(h3Stripes, h3StripesMask, .01);
    
    for (float i = 0. ; i < 1. ; i += .15) {
        vec2 r = rand2(vec2(i,.167));
        vec2 cc = anim1(iTime*.05+i+.01*(r.x-.5));
        mask = max(mask, circle(uv-cc, mix(.045, .05, r.y)));
    }
    
    col = mix(col, vec3(.14, .21, .3), fill(mask));
    col = mix(col, vec3(1., .32, .17), fill(h1InnerMask));
    col = mix(col, vec3(.75, .8, .84), fill(h1Stripes));
    col = mix(col, vec3(.83, .88, .7), fill(h2InnerMask));
    col = mix(col, vec3(.75, .8, .84), fill(h2Stripes));
    col = mix(col, vec3(.83, .88, .7), fill(h3InnerMask));
    col = mix(col, vec3(0.6, 0.3, 0.6), fill(h3Stripes*.5));
    
    col = mix(col, topEyeLayer, fill(topEyeDist));
    col = mix(col, bottomEyeLayer, fill(bottomEyeDist));
    
    dist = mask;
    return col;
}

// Function 2407
float movingLine(vec2 uv, vec2 center, float radius)
{
    //angle of the line
    float theta0 = 90.0 * iTime;
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    if(r<radius)
    {
        //compute the distance to the line theta=theta0
        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),
                            -sin(theta0*M_PI/180.0));
        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );
    	d = normalize(d);
        //compute gradient based on angle difference to theta0
   	 	float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);
        float gradient = clamp(1.0-theta/90.0,0.0,1.0);
        return SMOOTH(l,1.0)+0.5*gradient;
    }
    else return 0.0;
}

// Function 2408
vec2 direction(vec3 v)
{
	return vec2(
		direction(v.xz)+180.0,
		direction(vec2(
			length(v.xz),
			v.y
		))+90.0
	);
}

// Function 2409
float draw(vec2 uv) {
    return stroke(smoothmodulo(polygonSDF(uv,3.)*10.+ .3*iTime),1.,.2);
}

// Function 2410
vec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )
{
  vec4 q = abs(p) - (b-r.xxyy);
  vec4 qp=max(q,0.0);
  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;
}

// Function 2411
float drawNumber( float num, vec2 pos, vec2 pixel_coords )
{
	float result = 0.;
	bool on = false;
	float d;
	
	// minus sign
	if( num < 0. )
	{
		result += drawMinus( pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		num = -num;
	}
	// hundreds
	d = floor(mod(num/100.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// tens
	d = floor(mod(num/10.,10.));
	if( on || d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
		on = true;
	}
	// ones
	d = floor(mod(num,10.));
	result += drawDigit( d, pos, pixel_coords );
	pos.x += 4. / iResolution.x;
	// dec pt
	result += drawDecPt( pos, pixel_coords );
	pos.x += 2. / iResolution.x;
	// tenths
	d = floor(mod(num/.1,10.));
	if( true )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
	}
	// hundredths
	d = floor(.5+mod(num/.01,10.));
	if( d > 0. )
	{
		result += drawDigit( d, pos, pixel_coords );
		pos.x += 4. / iResolution.x;
	}
	
	return clamp(result,0.,1.);
}

// Function 2412
void DrawLine( vec2 vCanvasPos, vec2 vA, vec2 vB, float fThickness, vec4 vColor, inout vec4 vOutColor )
{
    vec2 vDir = vB - vA;
    float l = length( vDir );
    vDir = normalize( vDir );

    vec2 vOffset = vCanvasPos - vA;
    float fDot = dot( vOffset, vDir );
    float fT = clamp( fDot, 0.0, l );

    vec2 vClosest = vA + vDir * fT;
    float fDist = length(vClosest - vCanvasPos) - fThickness;

    if ( fDist < 0.0 )
    {
        vOutColor = vColor;
    }    
}

// Function 2413
void drawDeadParatrooper( ivec2 uv, vec2 d, float time, inout vec3 col ) {
    if (d.y > time) {
        drawSprite(uv, ivec2(d.x-6.,170), ivec2(d.x+6.,185), ivec2(0,48), iChannel1, false, col);
    }
}

// Function 2414
vec4 drawGui(vec2 c) {
	float scale = floor(iResolution.y / 128.);
    c /= scale;
    vec2 r = iResolution.xy / scale;
    vec4 o = vec4(0);
    float xStart = (r.x - 16. * numItems) / 2.;
    c.x -= xStart;
    float selected = load(_selectedInventory).r;
    vec2 p = (fract(c / 16.) - .5) * 3.;
    vec2 u = vec2(sqrt(3.)/2.,.5);
    vec2 v = vec2(-sqrt(3.)/2.,.5);
    vec2 w = vec2(0,-1);
    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {
        float slot = floor(c.x / 16.);
    	o = getTexture(48., fract(c / 16.));
        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));
        vec2 texCoord;
        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);
        float top = 0.;
        float right = 0.;
        if (b.z < b.x && b.z < b.y) {
        	texCoord = inv2(mat2(u,v)) * p.xy;
            top = 1.;
        }
        else if(b.x < b.y) {
        	texCoord = 1. - inv2(mat2(v,w)) * p.xy;
            right = 1.;
        }
        else {
        	texCoord = inv2(mat2(u,w)) * p.xy;
            texCoord.y = 1. - texCoord.y;
        }
        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {
            float id = getInventory(slot);
            if (id == 3.) id += top;
            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);
            o.a = 1.;
        }
    }
    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));
    o = mix(o, selection, selection.a);
    return o;
}

// Function 2415
float spline(float p0, float p1, float p2, float p3, float t)
{

    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +
            (p0*2. - p1*5. + p2*4. - p3)*t*t +
            (-p0 + p2)*t + p1*2.)*.5;
}

// Function 2416
float sdCircle(in vec2 p, in float r)
{
    return length(p) - r;
}

// Function 2417
bool drawNoiseChar(vec2 uv, out vec4 debugColor)
{
    debugColor = vec4(0.0);
    uint ti = uint(iTime*0.5);
    float tf = fract(iTime*0.5);
    uvec4 timeRand = philox4x32_7(uvec4(ti), uvec2(3u, 111u));
    int len = int(timeRand.x % 4u + 2u);
    vec2 textpos = vec2(0.0, -0.75);
    vec2 localpos = (uv- textpos)/charsize;
    ivec2 charposi = ivec2(floor(localpos));
    vec2 charUV = fract(localpos)*(vec2(1.0)+charspace) - vec2(charspace*0.5);

    float str = 0.0, strbg = 0.0;
    if(charposi.y == 0 && abs(charposi.x) <= len && charUV.x > 0.0 && charUV.x < 1.0 && charUV.y > 0.0 && charUV.y < 1.0 && iTime > 3. && tf < 0.9)
    {
        uvec4 charRand = philox4x32_7(uvec4(uint(charposi.x), ti, 0u, 0u), uvec2(7u, 121u));

        vec2 deriv, deriv2;

        const float ew = 0.2;
        vec2 edge = max(abs(charUV - vec2(0.5)) - (0.5-ew), 0.0)/ew;
        float e = max(edge.x, edge.y);
        for(int i=0; i<abs(int(charRand.x))%4+3; ++i)
        {
            vec4 randRect = uintToFloat(philox4x32_7(charRand, uvec2(i, 0xabcd)));
            //x: min x, y: min y, z: size, w: area
            const float minsize = 0.4;
            const float minarea = 0.3*0.8;
            vec2 minSA = vec2(minsize, minarea);
            randRect.zw = randRect.zw*(1.0 - minSA) + minSA;
            randRect.w = randRect.w / randRect.z;
            randRect.xy = randRect.xy*(1.0 - minsize);
            vec4 rect = vec4(randRect.xy, randRect.xy + randRect.zw);//vec4(min_x, min_y, max_x, max_y);
            if(rect.z > 1.0)
            {
                float delta = rect.z - 1.0;
                rect.x -= delta;
                rect.z -= delta;
            }
            if(rect.w > 1.0)
            {
                float delta = rect.w - 1.0;
                rect.y -= delta;
                rect.w -= delta;
            }
            vec2 rectUV = (charUV - rect.xy)/(rect.zw - rect.xy);
            if(charUV.x < rect.x || charUV.x > rect.z || charUV.y < rect.y || charUV.y > rect.w)
                continue;
            else
                debugColor = vec4(rectUV, 0.0, 0.0);

            vec2 randp = uintToFloat(philox4x32_7(charRand, uvec2(i, 0xabc))).xy;

            float c = smplxNoise2D(charUV*0.5+randp, deriv, deriv2, uvec2(0xdeadbefu+charRand.y+uint(i), 0xfeedfadeu));
            float cn = c*54.0 + 0.5;
            float dd = dot(deriv, deriv);

            float e = 1.0/(1.0+c*c*2200./dd);
            str += step(0.7, e);
        }
        str = step(0.9, str);
        return str > 0.9;
    //    fragColor = vec4(charUV, 0.0, 1.0);
    }else
    {
        return false;
    }
}

// Function 2418
void DrawRect( vec2 vCanvasPos, Rect rect, vec4 vColor, inout vec4 vOutColor )
{
	if ( Inside( vCanvasPos, rect ) )
    {
        vOutColor = vColor;
    }
}

// Function 2419
float line(vec2 p, vec2 a,vec2 b) { 
    p -= a, b -= a;
    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line
    return length(p - b * h);                         // dist to segment
}

// Function 2420
float dsqPointLine(vec3 a, vec3 p, vec3 nv) {
    float tMinA = minPointLine(p, nv, a);
    return dsq( a, p + tMinA*nv );
}

// Function 2421
float shadowCircle(vec2 p, float r, float i)
    {
        //hacked: moving the shadow for light direction
        p +=vec2(0.02, 0.02)*rot(iTime/10.);
        
        //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/
        float a  =atan( p.y,p.x);
        float shape = sin(a*i+i/1.)/10.;
 	
        //SS is used as smoothstep range
    	//there is a much better way that fabrice told me about.
        //It's in another shader. (Applause)
        float ss = 0.05;
        //shadow created with shape and 1.0-shadow so it returns as black where it should
    	float k = 1.0-smoothstep(r-ss, r+ss, length(p/1.5)+shape);
    	return pow(k,1.2);
}

// Function 2422
float circle( vec2 uv, vec2 pos, float r, float blur )
{
	float d = length( pos - uv );
    float cm = smoothstep( r, r-blur, d );
    return cm;
}

// Function 2423
vec4 drawCellTitaniumWall(ivec4 state, mat4x3 colors, ivec2 coord)
{
    Sprite sprite = getSpriteTitaniumWall();
    return sampleSprite(sprite, colors, coord);
}

// Function 2424
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	lowp vec2 r = hash2();
	lowp vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	lowp vec3  vv = cross( uu, n );
	lowp float ra = sqrt(r.y);
	lowp float rx = ra*cos(6.2831*r.x); 
	lowp float ry = ra*sin(6.2831*r.x);
	lowp float rz = sqrt( 1.0-r.y );
	lowp vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    return normalize( rr );
}

// Function 2425
vec4 drawWaves(in float x, in float y)
{
    // Bounds checking.
    if(y < WAVES_Y) return TRANS;
    else if(y > WAVES_Y+7.) return L_BLUE;
    else
    {
        // Modulo the time and cast it to an int so the value returned
        // can be used as an index for which frame of animation to use.
        float t = mod(iTime*6.0,4.0);

        // We need to do the usual transform here as well.
        y -= WAVES_Y;
        
		// If we are under the shoreline, we need to use the palette
        // that reflects the shore.
        if(x > SHORE_END)
        {
            // The prior comparison required x to be pristine, so
            // we have to perform this modulo in here.
            x = mod(float(x),64.);
            return ARR4(t,
                        wavesSunnyPalette(wavesC(x,y)),
                        wavesSunnyPalette(wavesA(x,y)),
                        wavesSunnyPalette(wavesB(x,y)),
                        wavesSunnyPalette(wavesD(x,y)));
        }
        // otherwise we use the palette that reflects the clouds.
        else
        {
            x = mod(float(x),64.);
            return ARR4(t,
                        wavesShadowPalette(wavesC(x,y)),
                        wavesShadowPalette(wavesA(x,y)),
                        wavesShadowPalette(wavesB(x,y)),
                        wavesShadowPalette(wavesD(x,y)));
        }
    }
}

// Function 2426
float LineNoise(float x, float t)
{
    float n = Noise2(vec2(x * 0.6, t * 0.2));
    //n += Noise2(vec2(x * 0.8, t * 0.2 + 34.8)) * 0.5;
    //n += Noise2(vec2(x * 1.2, t * 0.3 + 56.8)) * 0.25;
    
    return n - (1.0) * 0.5;
}

// Function 2427
vec2 lineGeometry(vec2 uv, vec2 p1, vec2 p2, float lineWidth) 
{
    // We'll grab the angle & length of the line
    float lineAngle = atan(p1.x-p2.x, p1.y-p2.y);
    float lineLength = distance(p1, p2);

    // And find the rotation matrix which flattens it to the y-axis 
    mat2 rotMat = rotate2d(pi-lineAngle);

    // Next, we'll describe a new line which lives on the y-axis & has the same length
    vec2 pa = vec2(0);				// Point A
    vec2 pb = vec2(0, lineLength);	// Point B

    // Transform our uv the same as we have transformed the line
	uv -= p1;
    uv = rotMat * uv;
    
    // Check if the point is in the line (rectangle)
  	float inWidthRange = abs(uv.x) < lineWidth/2. ? 1. : 0.;
    float inHeightRange = (1.-step(max(pa.y, pb.y), uv.y)) * (step(min(pa.y, pb.y), uv.y));

    vec2 bl = vec2(-lineWidth/2., 0);
    vec2 tr = vec2(lineWidth/2., lineLength);
	vec2 uvLinePosition = vec2(uv/(tr-bl));
        
    return uvLinePosition;
}

// Function 2428
float sdRoundedLine( in vec2 p, in vec2 a, in vec2 b, in float r)
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - r;
}

// Function 2429
void drawBomb(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {
    if (paratrooperData.x > 0. ) {
        ivec2 pos = ivec2(paratrooperData.xy);
    	drawBox(uv - pos, ivec2(-1,-2), ivec2(1,2), COL_WHITE, f);
    	drawBox(uv - pos, ivec2(-2,-1), ivec2(2,1), COL_WHITE, f);
    }
}

// Function 2430
float smoothLine(float value, float target, float width){
    return width / abs(value - target);
}

// Function 2431
vec4 p6mm_SimmetryLines( vec2 p_ndc )
{

    vec2 pf = p6mm_ToFundamental( p_ndc );
    
    float d1 = abs(pf.y),
          d2 = abs(pf.x-0.5),
          d3 = abs( SignedDistance( pf, tri_cen, vec2(0.0,0.0) ) );
     
    vec4 res = vec4( 0.0, 0.0, 0.0, 1.0 ) ;
        
    res.r = DistanceFunc(d2);
    res.g = DistanceFunc(d1);
    res.b = DistanceFunc(d3);
    
    return res ;    
}

// Function 2432
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {

   vec2 xy = fragCoord - size / 2.0;

   float z = size.y / tan(radians(fieldOfView) / 2.0);

   return normalize(vec3(xy, -z));

}

// Function 2433
maybe_vec2 get_distances_along_3d_line_to_sphere(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in float r
){
    float xz = dot(B0 - A0, A);
    float z = length(A0 + A * xz - B0);
    float y2 = r * r - z * z;
    float dxr = sqrt(max(y2, 1e-10));
    return maybe_vec2(
        vec2(xz - dxr, xz + dxr), 
        y2 > 0.
    );
}

// Function 2434
vec3 scanline(vec2 uv, float angle, vec3 color, float size, float strength) {
    uv[1] -= 0.5 + 0.5 * cos(mod(angle,3.14*2.0) / 2.0);
    uv[1] *= 1000.0 * size;
    float col = pow(uv[1],-1.0);
   	float damp = clamp(pow(abs(uv[0]), 10.0)+pow(abs(1.0-uv[0]), 10.0), 0.0, 1.0);
	col-= damp * 0.2;
    col = clamp(col, 0.0, strength);
    return color * col;
}

// Function 2435
float circle(vec2 p, vec2 c, float r)
{
	return length(p-c) - r;
}

// Function 2436
float roundLine(vec2 p, vec2 a, vec2 b) {
  b -=a+vec2(1.0,0.); p -= a;
  return smoothstep(1.1, 0.0,length(p-clamp(dot(p,b)/dot(b,b),0.0,1.0)*b));
}

// Function 2437
void SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags )
{
	scenein.v = v;
	scenein.v_rcp = vec3( 1.0 ) / v;
//	scenein.o = o;
	scenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;
	scenein.t0 = 0.0;
}

// Function 2438
vec2 closestPointFromLine(vec2 p,vec2 a,vec2 b){
    a -= p; b -= p;
  	vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );
  	float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );
    return (a+p)*(1.-t) + (b+p)*t;
}

// Function 2439
void UI_DrawSliderX( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))
        return;
    
    Rect horizLineRect;
    
    horizLineRect = sliderRect;
    if (!scrollbarStyle)
    {
	    float fMid = sliderRect.vPos.y + sliderRect.vSize.y * 0.5;
    	horizLineRect.vPos.y = fMid - 2.0;
    	horizLineRect.vSize.y = 4.0;
    }

    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );

    float fSlideMin = sliderRect.vPos.x + fHandleSize * 0.5f;
    float fSlideMax = sliderRect.vPos.x + sliderRect.vSize.x - fHandleSize * 0.5f;

    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);

    Rect handleRect;

    handleRect = sliderRect;
    handleRect.vPos.x = fDistSlider - fHandleSize * 0.5f;
    handleRect.vSize.x = fHandleSize;

    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);
    if ( bActive )
    {
        handleColor.rgb += 0.1;
    }

    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );
    DrawBorder( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );
}

// Function 2440
void DrawPaddleSprite(vec2 screenCoord, vec2 pos, inout vec4 pixel)
{
  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+80.0 && screenCoord.y >=pos.y && screenCoord.y <=pos.y+15.0)
  {
    vec2 dist = (screenCoord-pos)/iResolution.xy;
    vec2 loc = paddleTexture_Adress/iResolution.xy;    
    vec4 c =texture(iChannel0, loc+dist);

    pixel=mix(pixel, c, c.w);
  }
}

// Function 2441
vec3 noisyCircle(in vec2 p, in float t)
{
    float h = hash13(vec3(floor(p * 100.),floor(t * 10.))); 
    vec3 cb = vec3(sin(t * 0.28 + 5.3),sin(t * 0.48 + 2.4), sin(t * 0.43 + 2.25)) / 2. + 0.5;
    vec3 c0 = vec3(sin(t * 0.31 + 2.7),sin(t * 0.58 + 3.9), sin(t * 0.47 + 4.36)) / 2. + 0.5;
    float v = distFilter(triangleSignal(length(p) - iTime, 0.1) - 0.05);
    return vec3(h * v > 0.5?  cb : c0);
}

// Function 2442
void camCirclePath( inout vec3 p, inout vec3 d, 
                    in vec3 p0, in vec3 d0,
                    in vec3 c,in float r,
                    in float t0, in float t1,
                    in float t )
{
    // Don't modify p and d if it's not our turn.
    if(t < t0 || t > t1) return;
    
    // Scale those radians by pi.
	r *= 3.14;
    
    // Get fractional time.
    t = (t-t0)/(t1-t0);

    // Translate center to origin.
    p0 -= c;
    
    // Rotate.
    if( length(p0) > .1 ) p0 = rodRot(p0,vec3(0,1,0),r*t)*.5;
    
    // Translate back.
    p0 += c;
    p = p0;
    
    // Also take care of the direction.
    d = rodRot(d0,vec3(0,1,0),r*t);
    
}

// Function 2443
float spline(float x, float x1, float x2, float y1, float dy1, float y2, float dy2)
{
	float t = (x -x1) / (x2 -x1);	
    float a = 2.0*y1 -2.0*y2 +dy1 +dy2;
	float b = -3.0*y1 +3.0*y2 -2.0*dy1 -dy2;
	float c = dy1;
	float d = y1;
	float t2 = t*t;
	float t3 = t2*t;
	return a * t3 +b*t2 +c*t +d;
}

// Function 2444
vec3 WavelengthToXYZLinear( float fWavelength )
{
    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);
    float fIndex = fPos * float(standardObserver1931_length);
    float fFloorIndex = floor(fIndex);
    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );
    int iIndex0 = int(fFloorIndex);
    int iIndex1 = iIndex0 + 1;
    iIndex0 = min( iIndex0, standardObserver1931_length - 1);
    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    
    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );
}

// Function 2445
float SDFLine( in vec2 coords, in vec3 offsetSlope )
{
    coords -= offsetSlope.xy;
    float v = coords.x * offsetSlope.z - coords.y;
    vec2  g = vec2(offsetSlope.z,-1.0);
    return abs(v)/length(g);
}

// Function 2446
float roundedRectangle (vec2 pos, vec2 size, float radius, float thickness)
{
  float d = length(max(abs(uv - pos),size) - size) - radius;
  return smoothstep(0.66, 0.33, d / thickness * 5.0);
}

// Function 2447
float rectSDF(vec2 st, vec2 s) { // 10
    st = st * 2. - 1.;
    return max(abs(st.x / s.x), abs(st.y / s.y));
}

// Function 2448
vec4 drawCellMagicWall(ivec4 state, mat4x3 colors, ivec2 coord, int animFrame)
{
    Sprite sprite = getSpriteMagicWall((state.y == 1) ? (animFrame % 4) : 4);
    return sampleSprite(sprite, colors, coord);
}

// Function 2449
float outline (float d) {
    return 1.000000 - smoothstep(0.000000, 3.000000 / u_resolution . y, abs(d));
}

// Function 2450
vec3 DrawGoal(vec2 p, vec3 color)
{
    vec2 q = p - vec2(1.8, 9.0) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.0));
    color = DrawUIBox(q*vec2(0.8, 0.8), color);
    
    float d = PrintInt(q*3.0-vec2(-4.0, -1.5), gState.w*25.);
    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;
    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));
    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));
    
    q -= vec2(-1.0, 0.35); q*=vec2(0.2, 0.25);
    caret.x = count = 0.;
    d = G(r(q)); add(); d += O(r(q));  add(); d += A(r(q));  add(); d += L(r(q));
    color = mix(color, lettersColor*0.1, smoothstep(0.5, 1.0, d));
    color *= smoothstep(0., 0.005, length(q-vec2(0.20, 0.))-0.008);
    color *= smoothstep(0., 0.005, length(q-vec2(0.20, -0.035))-0.008);
    
    return color;
}

// Function 2451
vec4 scanline(vec4 c, vec2 px)
{
    vec2 uv = px / iResolution.xy;
	
    float y = mod(-iTime / 10.0,1.1);
    
    float d = sqrt(abs(uv.y - y));
    
    float a = 1.0 - smoothstep(0.001,0.2,d);
    
    c = noise(noise(noise(white,px),px),px) * (a*0.5) + (c * (1.0-a));
    
    return c;
    
}

// Function 2452
vec3 draw_month(vec2 uv) 
{
    float monthCenter = iDate.y / 12.;
    
    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.15, .0, pow(uv.y, 1.3)));        
    float f = .03 + .1 * max(0., pow((1.2 - uv.y), 3.));    
    lightBeam *= smoothstep( MONTH_WIDTH + f, MONTH_WIDTH - f, abs(uv.x - monthCenter));
    
    float lightIntensity = lightBeam * .4;
    lightIntensity += .5 * smoothstep(.012, .0, uv.y) * smoothstep(.18, .0, abs(uv.x - monthCenter)); 
    
    lightIntensity *= atmos( 3. * (uv + vec2(10., 10.)) ); // scale and shift fog to fake depth

    return vec3(1., 0.8, 0.7) * lightIntensity;
}

// Function 2453
vec4 draw_bullet_explosion( int type, ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), bull_exp_dim ) ) {
        int x = iu.x, y = iu.y ;
        x += type * 8 ;
        PREPARE_TEST_BIT ;
        BR16(7,  w,_,_,_,w,_,_,w  ,  _,_,_,w,_,_,_,_  ) ;
        BR16(6,  _,_,w,_,_,_,w,_  ,  _,w,_,_,_,w,_,_  ) ;
        BR16(5,  _,w,w,w,w,w,w,_  ,  _,_,_,w,w,_,w,_  ) ;
        BR16(4,  w,w,w,w,w,w,w,w  ,  _,_,w,w,w,w,_,_  ) ;
        BR16(3,  w,w,w,w,w,w,w,w  ,  _,w,_,w,w,w,_,_  ) ;
        BR16(2,  _,w,w,w,w,w,w,_  ,  _,_,w,w,w,w,w,_  ) ;
        BR16(1,  _,_,w,_,_,w,_,_  ,  _,w,_,w,w,w,_,_  ) ;
        BR16(0,  w,_,_,w,_,_,_,w  ,  _,_,w,_,w,_,w,_  ) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 2454
float Line (vec2 p1, vec2 p2, vec2 uv, float a)
{
    vec2 p1uv =  (p1.xy + 0.5) / vec2(iResolution.xy);
    vec2 p2uv =  (p2.xy + 0.5) / vec2(iResolution.xy);
    
    float r = 0.;
    float one_px = 1. / iResolution.x; //not really one px
    
    // get dist between points
    float d = distance(p1uv, p2uv);
    
    // get dist between current pixel and p1
    float duv = distance(p1uv, uv);

    //if point is on line, according to dist, it should match current uv 
    r = 1.-floor(1.-(a*one_px)+distance (mix(p1uv, p2uv, clamp(duv/d, 0., 1.)),  uv));
        
    return r;
}

// Function 2455
void draw(in vec2 p, inout vec4 c, object o, float t/*hickness*/)
{
    float P = 1. / ASPECT.x;
    t = P / t;
    float a = 1. - smoothstep(P + t, P + t + P, o.sd);
    float b = 1. - smoothstep(0., P, o.sd);
    vec3 color2 = o.color / 2.;
    c.rgb = mix(c.rgb, color2, a);
    c.rgb = mix(c.rgb, o.color, b);
    c.a = max(c.a, a);
}

// Function 2456
float sdf_line0(vec2 uv, vec2 vert_A, vec2 vert_B){
    float delta_y = vert_B.y - vert_A.y;
    float delta_x = vert_B.x - vert_A.x;
    float slope = delta_y / delta_x;  // Slope of the line given 2 vertices on the line
    float y_intersect = vert_A.y - slope * vert_A.x;  // This is the y-coordinate of the point (0,y) in R2 that is also in the line

    // There's many representations for a line. This is just one of them:  ax + by + c = 0.
    // Namely, a line on the plane R2 is the set of all points (x,y) in R2 that satisfy
    // the equation  ax + by + c = 0.
    // The letters `a`, `b`, and `c` are real numbers, and they encode information
    // about the slope of the line and the points it passes through!
    float coeff_a = slope;
    float coeff_b = -1.;
    float coeff_c = y_intersect;
    float norm = sqrt(coeff_a * coeff_a + coeff_b * coeff_b);
    float standard_form = coeff_a * uv.x + coeff_b * uv.y + coeff_c;

    // Why does this end up being the signed distance to our line? I'm not sure, yet!
    // But I stole the idea from Chapter 1 of
    // https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub
    return standard_form / norm;
}

// Function 2457
void drawExplosion(ivec2 uv, vec4 d, float time, const sampler2D tex, inout vec3 f) {
    if (time < d.z + EXPLOSION_DURATION && uv.y < 190) {
    	float t = (d.z - time) * (1. / EXPLOSION_DURATION);
        vec2 p = vec2(uv)-d.xy;
        float h = hash12(p*.3);
        if (h*h*h > t) {
            vec2 r = normalize(2. * hash22(p) - 1.) * hash12(p);
            vec2 delta = r * vec2(-t, 1.-t) + vec2(0., t*6.);

            float speed = .5 * (d.x-160.);
            if (d.w > 3.5) {
                speed = d.y > 8. ? AIRCRAFT_SPEED : -AIRCRAFT_SPEED;
                speed *= (1. / EXPLOSION_DURATION);
            } else if (d.w > 2.5) {
                speed = 0.;
                delta *= 10.;
                p.y -= t * 500.;
            }
            p.x += speed * t;
            p -= 20.*delta*t;
            
            uv = ivec2(d.xy + p);

            if (d.w < 1.5) {
                drawSprite(uv, ivec2(d.xy) - ivec2(6,22), ivec2(d.xy) + ivec2(6,-8), ivec2(0,34), tex, false, f); 
            } else if (d.w < 2.5) {
                drawBomb(uv, vec3(d.xyz), time, tex, f);
            } else if (d.w < 3.5) {
            	drawCanon(uv, f);
            } else if (d.w < 4.5) { 
                if (gMode > GAME_HELICOPTER + .5) {
                    drawJet(uv, ivec2(d.xy), 0, tex, f);
                } else {
                    drawHelicopter(uv, ivec2(d.xy), 0, tex, f);
                }
            }
        }
    }
}

// Function 2458
vec3 zcamJchToLinearSrgb(vec3 jch, ZcamViewingConditions cond) {
    vec3 xyzAbs = zcamToXyz(jch, cond);
    vec3 xyzRel = xyzAbs / cond.whiteLuminance;
    return xyzToLinearSrgb(xyzRel);
}

// Function 2459
vec4 drawTextureValues(in vec2 uv, in float mode, in int menu, in vec2 tvals)
{
    vec4 tcol;
    float lsize = 0.015;
    vec2 start = vec2(0.016, 0.18);
    
    int mval = getIValue(tvals.x, TEXTURES_NUM);
    int sval = getIValue(tvals.y, TEXTURES_NUM);
    
    if (in_zone(mode, APPL_UI) && menu == MENU_OPT_TEXTURE)
    {
        tcol += drawTextHorizontal(uv, start, lsize, vec2[10](_M, _a, _i, _n, _COLON, _X, _X, _X, _X, _X), 5);
        tcol += drawTextHorizontal(uv, start - vec2(0., 0.03), lsize, _SECONDARY, 10);
        
        vec2 mstart = start + 6.*vec2(lsize, 0.);
        vec2 ststart = start + 6.*vec2(lsize, 0.) - vec2(0., 0.03);
        
        if (mval == DIFFUSE_MAP)
        {
            tcol += drawTextHorizontal(uv, mstart, lsize, _DIFFUSEMAP, 9);
        }
        else if (mval == HEIGHT_MAP)
        {
            tcol += drawTextHorizontal(uv, mstart, lsize, _HEIGHTMAP, 10);
        }
        else if (mval == SPECULAR_MAP)
        {
            tcol += drawTextHorizontal(uv, mstart, lsize, _SPECULAR, 8);
        }
        
        if (sval == DIFFUSE_MAP)
        {
            tcol += drawTextHorizontal(uv, ststart, lsize, _DIFFUSEMAP, 9);
        }
        else if (sval == HEIGHT_MAP)
        {
            tcol += drawTextHorizontal(uv, ststart, lsize, _HEIGHTMAP, 10);
        }
        else if (sval == SPECULAR_MAP)
        {
            tcol += drawTextHorizontal(uv, ststart, lsize, _SPECULAR, 8);
        }
    }
    
    return tcol;
}

// Function 2460
bool lineItersection(vec2 v1, vec2 v2, vec2 v3, vec2 v4) 
{    
  float bx = v2.x - v1.x;
  float by = v2.y - v1.y;
  float dx = v4.x - v3.x;
  float dy = v4.y - v3.y;

  float b_dot_d_perp = bx * dy - by * dx;

  if (b_dot_d_perp == 0.0) return false;

  float cx = v3.x - v1.x;
  float cy = v3.y - v1.y;

  float t = (cx * dy - cy * dx) / b_dot_d_perp;
  if (t < 0.0 || t > 1.0)  return false;

  float u = (cx * by - cy * bx) / b_dot_d_perp;
  if (u < 0.0 || u > 1.0)  return false;

  return true;
}

// Function 2461
vec4 drawUI(ivec2 coord, vec3 color0, vec3 color1, int gDiamondsRequired, int cDiamondValue, int cDiamondBonusValue,
            int gDiamondsHarvested, int gCaveState, float gTimeLeft, int gScore, int gLives, int gCave, int gLevel,
            int animFrame, int gAuxFrame)
{
    vec4 res = vec4(0.0);
    vec4 col0 = vec4(color0, 1.0);
    vec4 col1 = vec4(color1, 1.0);
    const int y = TIT_RES.y - 8;

    bool isSpawning = isState(gCaveState, CAVE_STATE_SPAWNING);
    bool isFadingIn = isState(gCaveState, CAVE_STATE_FADE_IN);
    bool isFadingOut = isState(gCaveState, CAVE_STATE_FADE_OUT);
    bool isExitOpened = isState(gCaveState, CAVE_STATE_EXIT_OPENED);
    bool isExited = isState(gCaveState, CAVE_STATE_EXITED);
    bool isTimeOut = isState(gCaveState, CAVE_STATE_TIME_OUT);
    bool isPaused = isState(gCaveState, CAVE_STATE_PAUSED);
    bool isGameOver = isState(gCaveState, CAVE_STATE_GAME_OVER);
    bool isIntermission = ((gCave % 5) == 0);
    bool isTopInfoVisible = ((animFrame - gAuxFrame) % 135) < 35;
    bool isMovingToNextLevel = isFadingOut && (isIntermission || isExited);

    if (isMovingToNextLevel)
    {
        gCave += 1;
        if (gCave > 20)
        {
            gCave = 1;
            gLevel = max(((gLevel + 1) % 6), 1);
        }
    }

    if (isGameOver)
    {
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](G, _, A, _, M, _, E, _)));
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 11, y), int[8](O, _, V, _, E, _, R, _)));
    }
    else if (isPaused && isTopInfoVisible && !(isFadingIn || isFadingOut))
    {
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](S, P, A, C, E, B, A, R)));
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 10, y), int[8](T, O, _, R, E, S, U, M)));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 18, y), E));
    }
    else if (isSpawning && isIntermission)
    {
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x, y), int[8](B, _, O, _, N, _, U, _)));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 9, y), S));
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 12, y), int[8](L, _, I, _, F, _, E, _)));
    }
    else if (isSpawning || isFadingOut)
    {
        res = lerp(res, col0, printWord8(coord - ivec2(0, y), int[8](P, L, A, Y, E, R, _, _)));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 7, y), 1, 1));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 8, y), L_COMMA));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 10, y), gLives, 1));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 12, y), M));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 13, y), (gLives > 1) ? E : A));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 14, y), N));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 16, y), gCave - gCave / 5));
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 17, y), L_SLASH));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 18, y), gLevel, 1));
    }
    else if (isTimeOut && isTopInfoVisible)
    {
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 4, y), int[8](O, U, T, _, O, F, _, _)));
        res = lerp(res, col0, printWord8(coord - ivec2(CEH_RES.x * 11, y), int[8](T, I, M, E, _, _, _, _)));
    }
    else
    {
        if (isExitOpened)
        {
            res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x, y), L_DIAMOND));
            res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 2, y), L_DIAMOND));
        }
        else
        {
            res = lerp(res, col1, printInt(coord - ivec2(CEH_RES.x, y), gDiamondsRequired, 2));
        }
        res = lerp(res, col0, printLetter(coord - ivec2(CEH_RES.x * 3, y), L_DIAMOND));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 4, y), cDiamondValue, 2));
        res = lerp(res, col1, printInt(coord - ivec2(CEH_RES.x * 7, y), gDiamondsHarvested, 2));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 10, y), int(ceil(gTimeLeft)), 3));
        res = lerp(res, col0, printInt(coord - ivec2(CEH_RES.x * 14, y), gScore, 6));
    }
    return res;
}

// Function 2462
vec3 rotatedRect(vec2 pos, vec2 center, float side, float t, float angle)
{
    mat2 rot = rotationMatrix(angle);
    return rectangle(rot * pos, rot * center, side, t);
}

// Function 2463
vec4 draw_explosion( ivec2 pos, ivec2 iu ) {
    vec3 v = vec3(0) ;
    iu -= pos ;
    if( iINSIDE( iu, ivec2(0), en_exp_dim ) ) {
        int x = iu.x, y = iu.y ;
        PREPARE_TEST_BIT ;
        BR16(7,   _,_,_,_,w,_,_,_,w,_,_,_,_   ,_,_,_) ;
        BR16(6,   _,w,_,_,_,w,_,w,_,_,_,w,_   ,_,_,_) ;
        BR16(5,   _,_,w,_,_,_,_,_,_,_,w,_,_   ,_,_,_) ;
        BR16(4,   _,_,_,w,_,_,_,_,_,w,_,_,_   ,_,_,_) ;
        BR16(3,   w,w,_,_,_,_,_,_,_,_,_,w,w   ,_,_,_) ;
        BR16(2,   _,_,_,w,_,_,_,_,_,w,_,_,_   ,_,_,_) ;
        BR16(1,   _,_,w,_,_,w,_,w,_,_,w,_,_   ,_,_,_) ;
        BR16(0,   _,w,_,_,w,_,_,_,w,_,_,w,_   ,_,_,_) ;
    }
    return( vec4( v, 1 ) ) ;
}

// Function 2464
float df_line(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);	
    float edge = 1.0/min(iResolution.x, iResolution.y);
    return smoothstep(edge, -edge, length(pa - ba * h) - LINE_THICKNESS);
}

// Function 2465
float draw_arrow(vec2 uv, float e, vec3 p, vec3 d, mat4 T)
{
	vec4 a = T * vec4(p, 1.0);
    vec4 b = T * vec4(p - d, 1.0);
    
    a.xy /= a.z;
    b.xy /= b.z;
    
    vec2 pd = normalize(b.xy - a.xy);
    vec2 ppd = vec2(-pd.y, pd.x);
    
    return point(uv, e, a.xy)
        * segment(uv, e, 0.0005, a.xy, a.xy + pd*0.005 + ppd*0.003) 
        * segment(uv, e, 0.0005, a.xy, a.xy + pd*0.005 - ppd*0.003)
        * segment(uv, e, 0.0005, a.xy, a.xy + pd*0.02);
    
}

// Function 2466
vec4 gamma2linear_premultalpha( vec4 c )
{
    return vec4( pow( c.xyz, vec3(kGamma) )*c.w, c.w);
}

// Function 2467
vec4 circles(vec2 t, out float rad, out float idx)
{
    vec2 p = floor(t);
    float nd = 1e10;
    vec2 nc;
    vec2 nq;

    for(int y = -1; y < 2; y += 1)
        for(int x = -1; x < 2; x += 1)
        {
            vec2 b = vec2(float(x), float(y));
            vec2 q = b + p;
            vec2 c = q + cellPoint(q);
            vec2 r = c - t;

            float d = dot(r, r);

            if(d < nd)
            {
                nd = d;
                nc = c;
                nq = q;
            }
        }

    rad = 1.0;
    idx = nq.x + nq.y * 119.0;

    for(int y = -1; y < 2; y += 1)
        for(int x = -1; x < 2; x += 1)
        {
            if(x==0 && y==0)
                continue;

            vec2 b = vec2(float(x), float(y));
            vec2 q = b + nq;
            vec2 c = q + cellPoint(q);

            rad = min(rad, distance(nc, c) * 0.5);
        }

    return vec4((t - nc) / rad, nc);
}

// Function 2468
void DrawL( inout vec3 color, float x, float y )
{
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
        if ( x <= 3.0 || y <= 1.0 )
        {
            color = RGB( 255, 255, 255 );
        }
    }
}

// Function 2469
float circle( vec2 pos, float r, vec2 uv )
{
    return distance(uv, pos) < r ? 1. : 0.;
}

// Function 2470
vec3 drawAllText(vec2 p){
    vec3 buffer = vec3(0);
    
    // Bounding box test.
    if(p.x < 80.0 && iResolution.y - p.y < 130.0){
        
        // Align and scale the text positioning accordingly;
        p.y -= iResolution.y-17.0;
        p /= 15.0;

        // Null-terminated strings.
        // They all have to be the same length due to GLSL limitations.
        const int Len = 13;
        const int Incenter[Len] = int[](73, 110, 99, 101, 110, 116, 101, 114, 0, 0, 0, 0, 0);
        const int Centroid[Len] = int[](67, 101, 110, 116, 114, 111, 105, 100, 0, 0, 0, 0, 0);
        const int Circumcenter[Len] = int[](67, 105, 114, 99, 117, 109, 99, 101, 110, 116, 101, 114, 0);
        const int Orthocenter[Len] = int[](79, 114, 116, 104, 111, 99, 101, 110, 116, 101, 114, 0, 0);
        const int Ninepoint[Len] = int[](78, 105, 110, 101, 112, 111, 105, 110, 116, 0, 0, 0, 0);
        const int Symmedian[Len] = int[](83, 121, 109, 109, 101, 100, 105, 97, 110, 0, 0, 0, 0);
        const int Gergonne[Len] = int[](71, 101, 114, 103, 111, 110, 110, 101, 0, 0, 0, 0, 0);
        const int Nagelpoint[Len] = int[](78, 97, 103, 101, 108, 112, 111, 105, 110, 116, 0, 0, 0);
        const int Mittenpunkt[Len] = int[](77, 105, 116, 116, 101, 110, 112, 117, 110, 107, 116, 0, 0);
        const int Spieker[Len] = int[](83, 112, 105, 101, 107, 101, 114, 0, 0, 0, 0, 0, 0);
        printf(p, buffer, Incenter, Colors[0]);
        printf(p, buffer, Centroid, Colors[1]);
        printf(p, buffer, Circumcenter, Colors[2]);
        printf(p, buffer, Orthocenter, Colors[3]);
        printf(p, buffer, Ninepoint, Colors[4]);
        printf(p, buffer, Symmedian, Colors[5]);
        printf(p, buffer, Gergonne, Colors[6]);
        printf(p, buffer, Nagelpoint, Colors[7]);
        printf(p, buffer, Mittenpunkt, Colors[8]);
        printf(p, buffer, Spieker, Colors[9]);
    }
    return buffer;
}

// Function 2471
float drawLineX( vec2 p1, vec2 p2)
{
    return distance(p1.x, p2.x);
}

// Function 2472
vec3 i_direct_16( uint data )
{
    uvec3 d = uvec3( data, data>>6, data>>11 ) & uvec3(63u,31u,31u);
    vec3 v = vec3(d)*2.0/vec3(63.0,31.0,31.0) - 1.0;
    return normalize(v);
}

// Function 2473
float line(vec2 coord, float seed)
{
    vec2 dir = vec2(-1.0, 1.0);
    float bound = dot(iResolution.xy, abs(dir));

    float speed = fract(seed * 4785.9433) * 0.3 + 0.3;
    float time = fract(iTime * speed);

    float phase = iTime * (fract(seed * 438.454) * 3.3 + 3.3);
    float width = bound * 0.02 * (sin(phase) + 1.0);

    float dist = dot(coord, dir) + (time - 0.5) * bound;
    return abs(dist) - width;
}

// Function 2474
void UI_DrawWindowTitleBar( inout UIContext uiContext, bool bActive, Rect titleBarRect, inout UIWindowState window )
{   
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, titleBarRect ))
        return;
    
    vec4 colorA = vec4(cTitleBarA, 1.0);
    vec4 colorB = vec4(cTitleBarB, 1.0);
       
    if ( bActive )
    {
        colorA.rgb = cTitleBarAActive;
        colorB.rgb = cTitleBarBActive;
    }

    float t = (uiContext.vPixelCanvasPos.x - titleBarRect.vPos.x) / 512.0;
    t = clamp( t, 0.0f, 1.0f );
    uiContext.vWindowOutColor = mix( colorA, colorB, t );
    
    {
        LayoutStyle style;
        RenderStyle renderStyle;
        UIStyle_GetFontStyleTitle( style, renderStyle );

        vec2 vTextOrigin = vec2(0);
        if ( FLAG_SET(window.uControlFlags, WINDOW_CONTROL_FLAG_MINIMIZE_BOX) )
        {
        	vTextOrigin.x += titleBarRect.vSize.y;
        }
        
        PrintState state = UI_PrintState_Init( uiContext, style, vTextOrigin );    
        PrintWindowTitle( state, style, window.iControlId );    
        RenderFont( state, style, renderStyle, uiContext.vWindowOutColor.rgb );
    }
}

// Function 2475
Rect UILayout_StackControlRect( inout UILayout uiLayout, vec2 vSize )
{
    Rect rect = UILayout_GetStackedControlRect( uiLayout, vSize );
    UILayout_SetControlRect( uiLayout, rect );
    return rect;
}

// Function 2476
vec4 drawCharacter(vec4 inpColor, vec4 glyphColor, vec2 uv, vec2 pos, vec2 charSize, float stringIndex, int glyphIndex)
{
    vec2 element = floor(((uv - pos) / (charSize / 8.)));// convert uv to pixel indices
    element.x -= stringIndex * 8.0;
    element.x = floor(7.0 - element.x);// flip X. maybe my encoding method is wrong?
    // bounds check; most of the time uv will not land on the character so important to optimize this.
    if(element.y < 0. || element.y > 7.) return inpColor;
    if(element.x < 0. || element.x > 7.) return inpColor;

    vec4 scan0123;
    vec4 scan4567;
    getGlyphAtIndex(glyphIndex, scan0123, scan4567);
    
    int scanLineI = int(element.y);
    float scanLine;
    
    if(scanLineI == 0) scanLine = scan0123[0];
    else if(scanLineI == 1) scanLine = scan0123[1];
    else if(scanLineI == 2) scanLine = scan0123[2];
    else if(scanLineI == 3) scanLine = scan0123[3];
    else if(scanLineI == 4) scanLine = scan4567[0];
    else if(scanLineI == 5) scanLine = scan4567[1];
    else if(scanLineI == 6) scanLine = scan4567[2];
    else if(scanLineI == 7) scanLine = scan4567[3];

    float a = extractBit(scanLine, element.x);
    return vec4(mix(inpColor.rgb, glyphColor.rgb, a * glyphColor.a), inpColor.a);
}

// Function 2477
vec3 drawFractal(vec2 z) {
    for (int iterations = 0; iterations < MAX_ITERATIONS; ++iterations) {
    	z = f(z);
        
        for (int root = 0; root < roots.length(); ++root) {
            vec2 difference = z - roots[root];
            float distance = dot(difference, difference);
            if (distance < THRESHOLD) {
    			return palette[root] * (0.75 + 0.25 * cos(0.25 * (float(iterations) - log2(log(distance) / log(THRESHOLD)))));
            }
        }
    }
}

// Function 2478
vec3 drawNova(vec3 col, vec2 uv) {
    float scale = .3;
    uv *= -1.;
    uv /= scale;
    uv.y -= .5;
    uv.x /= 1.4;
    uv.x += 1.2;

    vec2 uv2 = uv;
    pR(uv2, PI * .25);
    vec2 warp = sin((uv2 + .25 + time) * 5.) * .1;
    uv += warp;

    float d = fNova(uv, .133);
    float dOffset = fNova(uv - vec2(.05,-.1), .133);

    d *= scale;
    dOffset *= scale;

    col = mix(col, vec3(.3), smoothstep(.005, .0, d - .02));
    col = mix(col, vec3(.0), smoothstep(.005, .0, dOffset + .01));

    // Outline
    d = max(d - .04, -d + .01);
    col = mix(col, TRAIN_WHITE, smoothstep(.005, .0, d));

    return col;
}

// Function 2479
float dCircle(vec2 p, vec3 params) {
    return length(p - params.xy) - params.z;
}

// Function 2480
float smoothcircle(vec2 uv, vec2 center, vec2 aspect, float radius, float sharpness){
	return 0.5 - sigmoid( ( length( (uv - center) * aspect) - radius) * sharpness) * 0.5;
}

// Function 2481
float rectMask(float b, float w, vec2 uv)
{
	vec4 e=smoothstep(vec4(-b-.5*w),vec4(-b+.5*w),vec4(uv,vec2(1)-uv));
    return e.x*e.y*e.z*e.w;
}

// Function 2482
vec3 cMobiusOnCircle(mat4x2 T, vec3 C)
{
    vec3 D;
    vec2 z;

    // There is a +1e9 here to handle a divide-by-zero when T is the identity.
    z = C.xy - cDiv(vec2(C.z * C.z, 0), cConj(cDiv(T[3], T[2] + 1e-9) + C.xy));
    D.xy = cMobius(z, T).xy;
    D.z = length(D.xy - cMobius(C.xy + vec2(C.z, 0), T));
    return D;
}

// Function 2483
float distCircleNnAng(vec3 p, vec3 n, float r, inout float ang)
{
    vec3 pr=p-normalize(p-n*dot(n,p))*r;
    float lpr=length(pr);
    ang=acos(dot(pr,n)/lpr);
    return lpr;
}

// Function 2484
float sdCircle(in vec2 p, in vec2 center, in float radius)
{
    return length(p - center) - radius; 
}

// Function 2485
float circle( vec2 uv, float thick, float delay ) {
	vec2 p = vec2(uv-0.5);
	//p *= mod(p*20.0, 10.0);
	
	float t = sin(time*1.0 + delay)/2.+0.5;
	float ease = elasticInOut(t);
	float anim = 30.0 + ease * 40.0;
	
	
	float size = 0.0 + anim;
	p.x *= resolution.x/resolution.y;
	
	float res = min(resolution.x, resolution.y);
    	float dist = length(p);
	float c = smoothstep(size/res, size/res + 2.0/res, dist);
	
	float s2 = size-thick;
	float c2 = smoothstep(s2/res, s2/res + 2.0/res, dist);
	
	vec2 norm = 2.0 * uv - 1.0;
	float phi = atan(norm.y, norm.x)/PI + time*0.15;
	float a = fract(phi);
	
	float rotation = smoothstep(1.5, 0.5, a);
	
	return mix(0.0, c2-c, rotation);
}

// Function 2486
float rectOutline(vec2 st, vec4 r, float w){
    return rect(st,r)-rect(st,vec4(r.x+w, r.y+w, r.z-w, r.w-w));
}

// Function 2487
maybe_float get_distance_along_2d_line_to_line_segment(
    in vec2 A0,
    in vec2 A,
    in vec2 B1,
    in vec2 B2
){
    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|
    vec2 B = normalize(B2 - B1);
    vec2 D = B1 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B2 - B1));
}

// Function 2488
vec3 DrawCellBg(vec2 p, vec2 cellId, vec3 bgColor)
{
    vec4 selected0 = Load(mSelected0, iChannel0, iChannelResolution[0].xy);
    vec4 selected1 = Load(mSelected1, iChannel0, iChannelResolution[0].xy);
    
    vec3 color = vec3(0.160, 0.333, 0.498);
    color = mix(color, vec3(0.172, 0.729, 0.188), step(0.5, IsSameCell(selected0.xy, cellId.xy)));
    color = mix(color, vec3(0.729, 0.325, 0.172), step(0.5, IsSameCell(selected1.xy, cellId.xy)));
    
    vec2 q = p-GetCellPos(cellId.xy);
    float d = dsCell(q);
    color = mix(color, bgColor, min(0.5+step(0., d), 1.));
   
    return color;
}

// Function 2489
vec3 cardDraw(Card card,vec2 p){
    if(cardIntersect(Card(card.center,card.size*0.96,vec3(0.)),p)){
        vec3 o = card.colour * noiseSS(p/50.);
        Label label = Label(
            vec2(card.center.x-0.005,card.center.y+card.size.y*0.41),
            vec2(card.size.x*0.92,card.size.y*0.08)
        );
    	if(labelIntersect(label,p))
            o*= .7 - labelDraw(label,p);
        
        Label label2 = Label(
            vec2(card.center.x-0.005,card.center.y+card.size.y*0.05),
            vec2(card.size.x*0.92,card.size.y*0.6)
        );
    	if(labelIntersect(label2,p))
            o *=(1.4-labelDraw(label2,p));
        
        Label label3 = Label(
            vec2(card.center.x-0.005,card.center.y-card.size.y*0.37),
            vec2(card.size.x*0.92,card.size.y*0.2)
        );
    	if(labelIntersect(label3,p))
            o *=1.-labelDraw(label3,p);
        
        return o*1.4;
    }
    return vec3(.1);
}

// Function 2490
float outline(in vec2 coord, in float id)
{
    float depth;
    vec3 normal;
    Material material;

    
	float shouldOutline = 0.0;
    
    // Check circular neighbourhood
    for (float i = 0.0; i < TAU; i += TAU / 10.0)
    {
        vec2 offset = vec2(cos(i), sin(i) * iResolution.x / iResolution.y) * 0.002;
	    unpackGbuffer(texture(G_BUFFER, coord + offset), depth, normal, material);
        
        if (id != material.id)
        {
            shouldOutline = 1.0;
        }
    }
    
    return shouldOutline;
}

// Function 2491
float shape_circles_smin(vec2 p, float t) {
  return smin(shape_circle(p - vec2(cos(t))), shape_circle(p + vec2(sin(t), 0)), 0.8);
}

// Function 2492
vec3 DrawCandy2(vec2 p, vec3 bgColor)
{
    vec2 q = p-vec2(0., +0.4);
    vec2 seg = dsSegment(q, vec2(0., 0.0), vec2(0.0, -0.5));
    float d = seg.x - (0.1+2.0*pow(seg.y*0.1, 0.8)) + (length(p)-0.5)*0.5;
    vec3 color = vec3(0.733, 0.752, 0.047)*0.8;
    
    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(1.8) ).rgb;
    color *= 1.+cubeTex.r*0.20;
    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.05, 0.11))*vec2(1.8, 1.2))), 0.2) );
    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.05, -0.1))*vec2(1.7, 1.2))), 0.21) );
    
    vec3 tmpColor = mix(mix(color*0.5, color, smoothstep(-0.5, 0.4, p.y)), color, smoothstep(0., 1., 2.*pow(abs(d+0.15), 0.4)));
    color = mix(tmpColor, color, 1.-exp((-5.0*max(d+0.25, 0.))));
    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));
    
    return mix(color, bgColor, smoothstep(0., 2e-2, d));
}

// Function 2493
float line(vec2 p, vec2 a, vec2 b)  {                   // --- draw line
	vec2 pa = p - a, ba = b - a;
    float u = dot(pa, ba)/dot(ba, ba);
 	return length(pa - ba * clamp(u,0.,1.));
}

// Function 2494
float drawD(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  float val = float(isIn(uv.y, -cMax, cMax) && isIn(uv.x,-cthick*2.0, -cthick));
  float val2 = float(isIn(length(uv), cMin, cMax) && uv.x > 0.0);
  return val + val2;
}

// Function 2495
float DistLine(vec2 p, vec2 a, vec2 b)
{
    return length(PerpToLine(p, a, b));
}

// Function 2496
vec4 put_text_drawstart(vec4 col, vec2 uv, vec2 pos, float scale)
{
	float unit = asp * scale * 0.1;
    float h = 0.;
    vec2 sc = vec2(unit, unit*0.8);
    
    // M
    h = max(h, word_map(uv, pos, 77, sc));
    // a
    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 97, sc));
    // r
    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 114, sc));
    // c
    h = max(h, word_map(uv, pos+vec2(unit*1.15, 0.), 99, sc));
    // h
    h = max(h, word_map(uv, pos+vec2(unit*1.5, 0.), 104, sc));
    
    col = mix(col, vec4(1.-vec3(h), 1.), h);
    
    return col;
}

// Function 2497
void drawSky(in vec2 uvCoords, inout vec4 canvas)
{
    vec4 sky = vec4(1.0 - 1.4 * sqrt(uvCoords.y),
                  	0.5 - 3.7 * uvCoords.y,
                  	0.5 - 0.8 * uvCoords.y,
                  	1.0);
    
    canvas = clamp(sky, 0.0, 1.0); //needed due to sqrt() of negative values
}

// Function 2498
Box LineBoundingBox( vec3 vStart, vec3 vEnd )
{
    Box box;
    box.m_min = min( vStart, vEnd );
    box.m_max = max( vStart, vEnd );
    
    return box;
}

// Function 2499
float distLine(vec2 a, vec2 b){
    
	b = a - b;
	float h = clamp(dot(a, b)/dot(b, b), 0., 1.);
    return length(a - b*h);
}

// Function 2500
float DrawText( vec2 fragCoord, int pageNo )
{
    vec2 vFontUV = fragCoord / iResolution.xy;
    vFontUV.y = 1.0 - vFontUV.y;
    vFontUV *= 15.0;
    vFontUV.x *= 3.0;
    
    vFontUV -= vec2(2.0, 1.0);
    
    vec2 vCharUV = vec2(0);
    
    int headingPage = pageNo * 2;
    int bodyPage = headingPage + 1;
        
    if ( pageNo < 9 )
    {
        PrintPage( vCharUV, vFontUV, headingPage );
        vFontUV *= 1.5;
        vFontUV.y -= 1.0;
        if ( pageNo == 8 )
        {
        	vFontUV.x -= 8.0;
        	vFontUV.y -= 13.0;
        }
        
        PrintPage( vCharUV, vFontUV, bodyPage );        
    }

    float fFont = textureLod( iChannelFont, vCharUV, 0.0 ).w;
	
	return fFont;
}

// Function 2501
void DrawBorder( vec2 vCanvasPos, Rect rect, inout vec4 vOutColor )
{    
    vec2 vThickness = vec2(1.0);
    
	if ( Inside( vCanvasPos, rect ) )
    {
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness) ) )
        {
            vOutColor.rgb = vec3(0.85);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness) ) )
        {
            vOutColor.rgb = vec3(0.0);
        }
        else
        if ( any( lessThanEqual( vCanvasPos, rect.vPos + vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(1.0);
        }
        else
        if ( any( greaterThan( vCanvasPos, rect.vPos + rect.vSize - vThickness * 2.0) ) )
        {
            vOutColor.rgb = vec3(0.4);
        }
    }
}

// Function 2502
float distancePointLine(vec2 linePoint, vec2 lineVector, vec2 point)
{
	vec2 linePointToPoint = point-linePoint;
	float projectionDistance = dot(lineVector,linePointToPoint);
	return length(lineVector*projectionDistance-linePointToPoint);
}

// Function 2503
vec4 draw(vec3 pos, float brushSize, vec3 brushColor, vec3 A) {
    float d = distance(pos, A);
	float f = smoothstep(brushSize * brushSmooth, brushSize, d);
    return vec4(brushColor, 1.0 - f);
}

// Function 2504
void LineTo(float2 p)
{
    l=min(l,Draw(CP,p,uv));
    s+=Fill(CP,p,uv);
    CP=p;
}

// Function 2505
float LineSmooth( DrawContext drawContext, float fDist, float fThickness )
{
    return clamp( (fThickness - fDist) * drawContext.fEdgeFade, 0.0, 1.0 );
}

// Function 2506
vec4 drawOutline(vec2 uv) {
    vec4 tex = clampedTex(uv);
    vec3 color = vec3(0.);
    float dist = 10. / Size.x;
    
    if(tex.a < .3) {
    	int N = 8;
        vec4 outline = vec4(0);
        for(int i = 0; i < N; ++i) {
            vec2 dir = rot(float(i) * 2. * Pi / float(N)) * vec2(dist, 0);
            vec4 t = clampedTex(uv + dir);
            outline.rgb += color * t.a;
            outline.a += t.a;
        }
        tex = outline;
    }
    
    return tex;
}

// Function 2507
vec4 bilinearFilter0(vec2 coords) {
    float size = 1024.0;
    vec2 trTexCoords = coords * size;
    vec2 texf = floor(trTexCoords);
    vec2 ratio = trTexCoords - texf;
    vec2 opposite = 1.0 - ratio;
    vec4 result = (texture(iChannel0, texf / size) * opposite.x  + texture(iChannel0, (texf + vec2(1, 0)) / size)   * ratio.x) * opposite.y + 
                  (texture(iChannel0, (texf + vec2(0, 1)) / size) * opposite.x + texture(iChannel0, (texf + vec2(1, 1)) / size) * ratio.x) * ratio.y;
    return result;
}

// Function 2508
void DrawHeart(float id, vec2 p, float t, vec2 vel, vec3 fireColor, inout vec4 color)
{
    if(t < 0. || t > 1.) return;

    float texpNormPow = pow(t, 0.45);
    float gravityScale = max(t-0.55, 0.)/0.55;
    
    DrawGlow(p, t, fireColor, color);
    
    for(float i=0.; i < 20.5; ++i)
    {
        vec2 pDir = normalize( vec2(hash(i*198.9885), hash(45.6924*hash(i))) * 2. -1. );
        float at = atan(pDir.y, pDir.x);
        float r = (  2. -2.*sin(at) + sin(at)*sqrt(abs(cos(at)))/(sin(at)+1.4)  ) * 0.30;
        vec2 q = p - (pDir*r * texpNormPow + 0.05*gGravity*gravityScale*gravityScale);

        vec3 pColor = clamp(mix(fireColor, vec3(pDir.x, pDir.y, r), hash(i)*0.5), 0., 1.);

        float flicker = GetFlicker(i + t*0.3);

        float size = expSize * sin(texpNormPow*PI)*0.1;

        vec4 pFinalColor = DrawParticle(i, q+0.*vec2(hash(i+t*0.1)*0.02, 0.), size + 0.5*size*(noise(i+t*0.05)*2.-1.), t, pColor, 0.5, 9.0*hash(i+t*10.), color.a, 1.);
        color.rgb += flicker * pFinalColor.rgb; color.a = pFinalColor.a;
    }
}

// Function 2509
float LineInfo( vec2 vUV, vec2 vA, vec2 vB )
{
    vec2 vClosestUnused;
    return LineInfo( vUV, vA, vB, vClosestUnused );
}

// Function 2510
float lineSegment(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a, ba = b - a;
    float l = length( pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0) );
    l = smoothstep(cirleWidth,cirleWidth-0.005,l);
    return l;

}

// Function 2511
float drawRect(vec2 p1, vec2 p2, vec2 uv) 
{
  vec4 rect = vec4(p1, p2);
  vec2 hv = step(rect.xy, uv) * step(uv, rect.zw);
  return hv.x * hv.y;
}

// Function 2512
float DistanceYtoLine(vec2 u,vec2 m,vec2 n
){;m=m-n;;return (u.x-n.x)*m.y/m.x-u.y+n.y;}

// Function 2513
vec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {
    float r = radius*sqrt(1.0 - Xi1);
    float theta = Xi2*TWO_PI;
	return vec2( r*cos(theta), r*sin(theta) );
}

// Function 2514
float linearstep(float begin, float end, float t) {  return clamp((t - begin) / (end - begin), 0.0, 1.0);  }

// Function 2515
float Line(vec2 p, vec2 a, vec2 b){
	float d = DistLine(p,a,b);
    float m = 0.5*S(.04,.02,d);
    
    return m;
}

// Function 2516
bool onGridline(int distFrom, int spacing)
{
	return mod(float(distFrom), float(spacing)) == 0.0;
}

// Function 2517
float circle(in vec2 p, float r)
{
    return abs(length(p) - r);
}

// Function 2518
float drawRectangle(vec2 st,vec2 pos,vec2 size){
    
    float result=1.;
    vec2 border=(1.-size)/2.200;
    st=st-pos+vec2(.5);
    result=step(border.x,st.x);
    result*=step(border.x,1.-st.x);
    result*=step(border.y,st.y);
    result*=step(border.y,1.-st.y);
    
    return result;
}

// Function 2519
float dfLine(vec2 start, vec2 end, vec3 p){
	start *= scale;
	end *= scale;
	vec2 line = end - start;
	float frac = dot(p.xy - start,line) / dot(line,line);
	
	float d = distance(start + line * clamp(frac, 0.0, 1.0), p.xy);
	
	float dd = length(vec2(d-0.,p.z-0.))-0.01;
	return dd;
}

// Function 2520
vec4 draw_sprite_start_box(vec2 uv) {
    // Start line and places for ships. Normaldata invalid
    uv.x -= 0.5;

    
    vec4 outp = vec4(0.0, 0.0, 9999.0, 0.0);
    
    // Start/finish line
    outp = n_union(outp, line_segment(uv, vec2(-0.4, 0.9), vec2(0.4, 0.9)));
    outp = n_union(outp, line_segment(uv, vec2(-0.4, 0.95), vec2(0.4, 0.95)));
    
    // Duplicate start boxes early
    uv.x = abs(uv.x);
    uv.y = mod(uv.y, 0.3);
    
    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.18), vec2(0.2, 0.18)));
    outp = n_union(outp, line_segment(uv, vec2(0.2, 0.15), vec2(0.2, 0.18)));
    outp = n_union(outp, line_segment(uv, vec2(0.1, 0.15), vec2(0.1, 0.18)));
    
    outp.b = sqrt(outp.b);

    return outp;
}

// Function 2521
float interectCloudSphere( vec3 rd, float r ) {
    float b = EARTH_RADIUS * rd.y;
    float d = b * b + r * r + 2. * EARTH_RADIUS * r;
    return -b + sqrt( d );
}

// Function 2522
float Rect(vec2 uv, float left, float right, float bottom, float top, float blur){
    float band1 = Band(uv.x, left, right, blur); //defines left and right
    float band2 = Band(uv.y, bottom, top, blur); //defines top and bottom
    
    return band1*band2;
}

// Function 2523
float line( vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 2524
vec4 DrawScoreGlow( vec2 uv, float keyID, vec2 size, float lifeTime)
{

    float lifeSpan = 0.5;
    
    lifeTime = clamp(lifeTime,0.,lifeSpan)/lifeSpan;
    size.y +=cos((lifeTime)*3.1415*2.)*0.04;
    
    size.x *=cos(lifeTime*3.1415);
    vec4 ret = vec4(0.);
    vec2 pos = vec2(keyID*0.2+0.1, size.y/2.);
    if ( abs(uv - pos).x < size.x/2. && abs(uv-pos).y < size.y/2. )
    {
        ret.a = 1.;
        ret.xyz = keyColors[int(keyID)]*pow((1.-lifeTime),20.);
           
    }
    return ret;
}

// Function 2525
vec4 circle(vec2 p, vec2 center, float radius)
{
	return mix(vec4(1,1,1,0), vec4(1,0,0,1), smoothstep(radius + 0.005, radius - 0.005, length(p - center)));
}

// Function 2526
float draw_arrows(in vec2 p){
  vec2 ip = floor(p * arrow_density) / arrow_density + .5 / arrow_density;   
  vec2 field_image = field(ip);
  float norm = length(field_image) * (arrow_length / arrow_density);

  vec2 b = normalize(field_image) * norm;
  vec2 prp = vec2(-b.y, b.x);

  float rz = segm(p, ip, ip+b);
  rz = min(rz, segm(p, ip + b, ip + b * arrow_head + prp * arrow_openness));
  rz = min(rz, segm(p, ip + b, ip + b * arrow_head - prp * arrow_openness));
  return rz;
}

// Function 2527
float line( vec2 p, vec2 a, vec2 b, float r) { // draw line a-b width r
    p -= a; b -= a;
    float d = length( p - b * clamp(dot(p,b)/dot(b,b), 0., 1. ));
    return  1.- S(  d/r);
}

// Function 2528
float circle(vec2 p, vec2 c, float r, float w) {
    float dist = abs(length(p - c)) + r;
    dist = 1.0/dist*WEIGHT*w;
    return min(dist*dist,1.0);
}

// Function 2529
void DrawCastle( inout vec3 color, float x, float y )
{
	if ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )
	{
		float ymod4    = mod( y, 4.0 );
		float xmod8    = mod( x, 8.0 );
		float xmod16_4 = mod( x + 4.0, 16.0 );
		float xmod16_3 = mod( x + 5.0, 16.0 );
		float ymod8    = mod( y, 8.0 );

		// dark orange
		float idx = 2.0;

		// black
		idx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;
		idx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;
		idx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;
		idx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;
		idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  

		// white
		idx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;
		idx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;
		idx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;
		idx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;

		// transparent
		idx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;
		idx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;
		idx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             
		idx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;

		color = idx == 1.0 ? RGB(   0,   0,   0 ) : color;
		color = idx == 2.0 ? RGB( 231,  90,  16 ) : color;
		color = idx == 3.0 ? RGB( 247, 214, 181 ) : color;
	}
}

// Function 2530
void DrawDesert(out vec4 c){
	c = vec4(0.8, 0.8, 0.4, 1.0);
}

// Function 2531
float RandRect (vec2 p)
{
  vec4 hm, hc;
  vec3 e;
  vec2 pMid[4], pEdge[4], ip;
  float dMin, hp, eFac;
  ip = floor (p) + 0.5;
  e = vec3 (-1., 0., 1.);
  hp = Hashfv2 (ip);
  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));
  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));
  if (mod (ip.x + ip.y, 2.) < 0.5) {
    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);
    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);
    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);
    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);
    pMid[0] = vec2 (hm.z, hp);
    pMid[1] = pMid[0];
    pMid[2] = vec2 (hm.w, hp);
    pMid[3] = pMid[2];
  } else {
    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);
    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);
    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);
    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);
    pMid[0] = vec2 (hp, hm.y);
    pMid[1] = vec2 (hp, hm.x);
    pMid[2] = pMid[1];
    pMid[3] = pMid[0];
  }
  eFac = 0.3;
  for (int k = 0; k < 4; k ++) {
    pEdge[k] = eFac * pEdge[k] + 0.5;
    pMid[k] = 2. * eFac * (pMid[k] - 0.5);
  }
  pMid[0] += pEdge[0] * e.xz;
  pMid[1] += pEdge[1] * e.zz;
  pMid[2] += pEdge[2] * e.zx;
  pMid[3] += pEdge[3] * e.xx;
  dMin = 1e6;
  for (int k = 0; k < 4; k ++) 
     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);
  return dMin;
}

// Function 2532
float line( vec2 p, vec2 n, bool repeat )
{
    //n /= dot(n,n);
    
    float d = abs(dot(p, n));
    
    if( !repeat )
    {
	    d = d / PERIOD;
	    return smoothstep( 1.5/PERIOD, 0., abs(d) );
    }
    
    float res = 0.;
    for( int i = 0; i < RESOLUTIONS; i++ )
    {
        float period = PERIOD*pow(2.,float(RESOLUTIONS-i-1));
        
        float fr = abs(fract(d/period));
        // fix fract boundary
        fr = min( fr, 1.-fr );
        float col = mix( 0., .3, pow(GRID_CONTRAST,-float(i)) );
        res = max( res, smoothstep( 2./period, 0., fr ) * col );
    }
    return res;
}

// Function 2533
float dist_horizontal_line( vec3 p)
{
  return length(vec2(length(p.xy)-1.0,p.z));
}

// Function 2534
vec4 DrawBar(float playTime, vec2 uv, float size)
{
float viewScale = GetGameData(iChannel1,SPEED,iResolution).x;
    float measurePos = (playTime+uv.y*viewScale);
    float mask = step(uv.x,1.0)-step(uv.x, 0.0);
    float b = abs(sin(playTime*4.*3.1415));
    b = b *b*b*b;
    b = mix(0.8,0.4,b );
    return (vec4(pow(fract(measurePos),400.)))*b*mask;
}

// Function 2535
void DrawSlider(inout vec3 color, vec2 p, in AppState s)
{
    p -= vec2(110, 94.5);
    
    p.y += 15.;
    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);
    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));

	color = mix(color, vec3(0.3), Smooth(-c1 * 2.));
}

// Function 2536
void UI_DrawSliderY( inout UIContext uiContext, bool bActive, bool bMouseOver, float fPosition, Rect sliderRect, float fHandleSize, bool scrollbarStyle )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, sliderRect ))
        return;
    
    Rect horizLineRect;
    
    horizLineRect = sliderRect;
    if (!scrollbarStyle)
    {
	    float fMid = sliderRect.vPos.x + sliderRect.vSize.x * 0.5;
    	horizLineRect.vPos.x = fMid - 2.0;
    	horizLineRect.vSize.x = 4.0;
    }

    DrawBorderIndent( uiContext.vPixelCanvasPos, horizLineRect, uiContext.vWindowOutColor );

    float fSlideMin = sliderRect.vPos.y + fHandleSize * 0.5f;
    float fSlideMax = sliderRect.vPos.y + sliderRect.vSize.y - fHandleSize * 0.5f;

    float fDistSlider = (fSlideMin + (fSlideMax-fSlideMin) * fPosition);

    Rect handleRect;

    handleRect = sliderRect;
    handleRect.vPos.y = fDistSlider - fHandleSize * 0.5f;
    handleRect.vSize.y = fHandleSize;

    vec4 handleColor = vec4(0.75, 0.75, 0.75, 1.0);
    if ( bActive )
    {
        handleColor.rgb += 0.1;
    }

    DrawRect( uiContext.vPixelCanvasPos, handleRect, handleColor, uiContext.vWindowOutColor );
    DrawBorder( uiContext.vPixelCanvasPos, handleRect, uiContext.vWindowOutColor );
}

// Function 2537
float segment_line(vec2 uv, float e, vec2 a, vec2 b) 
{
    b -= a;
    uv -= a;
    vec2 d = normalize(b);
    
    float sd1 = smoothstep(e*0.1, 2.0*e, abs(dot(vec2(-d.y, d.x), uv)));
    float sd2 = smoothstep(e*0.1, e, abs(dot(vec2(-d.y, d.x), uv)));
    float t = min(step(0.0, dot(d, uv)), step(0.0, dot(d, b - uv)));
    
    float fo = clamp(0.0, 1.0, pow(length(uv - b*0.5)/(length(b)*4.0), 4.0));
    
 	return mix(mix(0.8 + 0.2*sd2,1.0, fo) , sd1, t); 
}

// Function 2538
vec3 SRGBToLinear ( vec3 col )
{
    return mix( col/12.92, pow((col+.055)/1.055,vec3(2.4)), step(.04045,col) );
}

// Function 2539
void drawTile(int type, vec2 tileCorner, vec2 co)
{
	if ((co.x < tileCorner.x) || (co.x > (tileCorner.x + 16.0)) ||
		(co.y < tileCorner.y) || (co.y > (tileCorner.y + 16.0)))
	{
		return;	
	}
	
	int modX = int(mod(co.x - tileCorner.x, 16.0));
	int modY = int(mod(co.y - tileCorner.y, 16.0));
				
	if (type == 0){
		drawLowBush(modX, modY);
	}
	else if (type == 1) {
		drawHighBush(modX, modY);
	}
	else if (type == 2) {
		drawCloud(modX, modY);
	}
	else if (type == 3) {
		drawBirdF0(modX, modY);
	}
	else if (type == 4) {
		drawBirdF1(modX, modY);
	}
	else if (type == 5) {
		drawBirdF2(modX, modY);
	}
}

// Function 2540
void drawLifeBar(  vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {
     coord = (coord-lt) / size;
    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    
		vec4 col = mix(vec4(.5,0,0,1), vec4(.5,1,0,1), float(level)/60.);  
		col = mix(col, vec4(0,1,0,1), float(level-60)/60.);
        col = mix( vec4(0,0,0,.6), col, step( 120. * coord.x,  float(level) ));
        col.rgb *= (.75 + .5 * texture(iChannel1, coord/vec2(8.,64.)).x);
        color = mix( color, col, col.a );
    }   
}

// Function 2541
vec3 drawText3( in vec4 fragColor, in vec2 fragCoord ) {
    float display_width = 1010.;
    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line
    
    vec2 uv = (fragCoord.xy) / iResolution.xx;
    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   
    uv *= display_width;

    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));

    uv = mod_uv(uv);
    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner
    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   
    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);
    
    float tx = 10000.;
    int idx = 0;
    
    NL 
    NL 
    NL 
    NL 
    NL 
    NL 
    SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP SP Y O U SP W I N 
    NL
        
    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);
    
    vec3 terminal_color = tcol;
    
    return terminal_color;
}

// Function 2542
float onRectAA( const vec2 c, const vec2 lt, const vec2 rb ) {
	return onBandAA( c.x, lt.x, rb.x )*onBandAA( c.y, lt.y, rb.y );
}

// Function 2543
vec4 drawlight(vec2 pos,float radius, vec2 uv) { 
  float dist=length(pos-uv);
  float maxDistance=pow(radius,0.10);
  float quadDistance=pow(dist,0.21);
  float quadIntensity=1.0-min(quadDistance,maxDistance)/maxDistance;      
      
  vec4 lght=vec4(quadIntensity);
  return lght;
  }

// Function 2544
float GRcircle(vec2 p, float r, float gr)
{
   //basic gradient, clamped for high powers!!
   float c = clamp(pow(length(p), gr), 0.0, 1.0); 
   return c*clamp(1.0-SScircle(p, r), 0.0, 1.0)*2.;  
}

// Function 2545
float rect2(vec2 coordSpace, vec2 dim, vec2 offset)
{          
    vec2 tmp = smoothstep( dim, dim + .02, coordSpace - offset);
    float pct = tmp.x * tmp.y;
    
    tmp = smoothstep( dim, dim + .02, 1. - coordSpace + offset);
    pct *= tmp.x * tmp.y;

    return pct;
}

// Function 2546
vec3 line2D(vec2 a, vec2 b) {
    vec2 n = perp(b - a);
    return vec3(n, -dot(n, a));
}

// Function 2547
float directionalOcclusionSphere(in vec3 pos, in vec4 sphere, in vec4 cone) {
    vec3 occluder = sphere.xyz - pos;
    float occluderLength2 = dot(occluder, occluder);
    vec3 occluderDir = occluder * inversesqrt(occluderLength2);

    float cosPhi = dot(occluderDir, cone.xyz);
    // sq(sphere.w) should be a uniform --> capsuleRadius^2
    float cosTheta = sqrt(occluderLength2 / (sq(sphere.w) + occluderLength2));
    float cosCone = cos(cone.w);

    return 1.0 - sphericalCapsIntersection(cosTheta, cosCone, cone.w, cosPhi) / (1.0 - cosCone);
}

// Function 2548
vec4 circle (float dis,float radius)
{
    

    return vec4( step(dis,radius ) );

}

// Function 2549
float distanceLine(vec2 l0, vec2 l1, vec2 p)
{
    vec2 v01 = (l1 - l0);
    vec2 v0p = ( p - l0);
    vec2 vh = v0p - v01 * clamp(dot(v01, v0p) / dot(v01, v01), 0.0, 1.0);
    return length(vh);
}

// Function 2550
float getCellDirectionID(int cellID, int loops)
{
    vec3 cellID3D = getBufferCellID3D(cellID);
    
    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    int choisesCount = 0;
    
    for(float i = -1.0; i <= 1.0; i += 2.0)
    {
        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);
        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);
        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);

        int  xNeighborCellID = getBufferCellID(xNeighborCellID3D);
        int  yNeighborCellID = getBufferCellID(yNeighborCellID3D);
        int  zNeighborCellID = getBufferCellID(zNeighborCellID3D);

        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID, iResolution.xy)).x);
        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID, iResolution.xy)).x);
        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID, iResolution.xy)).x);

        bool xIsEmpty = xNeighborCellExist <= 0.0;
        bool yIsEmpty = yNeighborCellExist <= 0.0;
        bool zIsEmpty = zNeighborCellExist <= 0.0;
        
        // dont enter from outer Cube
        xIsEmpty = xIsEmpty && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;
        yIsEmpty = yIsEmpty && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;
        zIsEmpty = zIsEmpty && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;
        
        // cell's direction matching
        xIsEmpty = xIsEmpty && getEmptyDirectionID(xNeighborCellID, loops) == round(1.5 + (-i * 0.5));
        yIsEmpty = yIsEmpty && getEmptyDirectionID(yNeighborCellID, loops) == round(3.5 + (-i * 0.5));
        zIsEmpty = zIsEmpty && getEmptyDirectionID(zNeighborCellID, loops) == round(5.5 + (-i * 0.5));
        
        choises[choisesCount] = round(1.5 + (-i * 0.5)) * float(xIsEmpty); choisesCount+= 1 * int(xIsEmpty);
        choises[choisesCount] = round(3.5 + (-i * 0.5)) * float(yIsEmpty); choisesCount+= 1 * int(yIsEmpty);
        choises[choisesCount] = round(5.5 + (-i * 0.5)) * float(zIsEmpty); choisesCount+= 1 * int(zIsEmpty);
    }

    int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));
    return choises[index];
}

// Function 2551
vec3 draw(vec3 p) {

    //////////////////////////////////////////////////
    // figure out some sample points and tangents
    
    vec3 p0 = vec3(0, 0, 1);
    vec3 l0 = vec3(0, 1, 0);
    
    float u = 2.*PI*fract(iTime/PERIOD);

    vec3 p1 = normalize(vec3(0.25, 0.4, 1.0) + vec3(0.3*sin(PFREQ*u), 0.3*cos(PFREQ*u), 0));    
    vec3 q = normalize(vec3(1, 0, 0.5) + vec3(0.2*sin(QFREQ*u + 0.3), 0.2*cos(QFREQ*u + 0.1), 0));
    vec3 l1 = normalize(cross(q, p1));
    
    //////////////////////////////////////////////////
    // compute and draw the spline
    
    arc_spline S;    
    compute_spline(p0, l0, p1, l1, S);
    
    float bblue = 1e5;
    float blue = min(abs(dot(p, l0)), abs(dot(p, l1)));
    float black = min(sdist(p0, p), sdist(p1, p));
    float green = min(darrow(p, p0, l0), darrow(p, p1, l1));  
    float maroon = 1e5;
    float orange = dspline(p, S);
         
    if (draw_extras && S.r != 0.0) {
  
        blue = min(blue, max(abs(dot(p, S.w)), -min(dot(p, l0), dot(p, l1))));
        
        maroon = min(maroon, sdist(p, S.c0));
        maroon = min(maroon, sdist(p, S.c1));
        black = min(black, sdist(p, S.m));
                
    }
    
    vec3 color = vec3(1);
    
    if (!draw_extras) {
        green = 1e5;
    }
    
    color = min(color, mix(vec3(1), vec3(0, 0.5, 1), 0.4*smoothstep(aa, 0.0, blue - 0.002)));
    color = min(color, mix(vec3(1), vec3(0.1, 0.6, 0), smoothstep(aa, 0.0, green - 0.002)));
    color = min(color, mix(vec3(1), vec3(1.0, 0.4, 0), smoothstep(aa, 0.0, orange - 0.008)));
    color = min(color, mix(vec3(1), vec3(0.7, 0, 0.4), smoothstep(aa, 0.0, maroon - 0.015)));
    color *= smoothstep(0., aa, black - 0.015);
    
    return color;
    
}

// Function 2552
void drawGame3D( inout vec4 color, vec2 uv, AppState s )
{   
    vec2 mo = iMouse.xy / iResolution.xy;
   
    vec2 bent = getBent();

    float fbm = fbm3( vec3( 1000.0 * iTime ) );
    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );
    // camera	    
    float roll = -0.1 * bent.x;
    float arm = 3.5 + 0.2 * s.paceScale;
    float angleH = -0.5 * PI + 0.1 * bent.x;
    float height = 1.3 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;
    float fov = 1.5 - 0.5 * s.paceScale;
    
    vec3 ro = vec3( 0.0 );
    
    if ( s.timeFailed > 0.0 )
    {
        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );
        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );
        angleH += iTime - s.timeFailed;
    }
    
    if ( s.stateID == GS_SPLASH )
    {
        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;
        roll = -0.1 * ( mo.x - 0.5 );
        angleH += 0.5 * ( mo.x - 0.5 );
        height += 0.5 * (mo.y - 0.5 );                
    }
    
    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );
    
#ifdef DEBUG_CAMERA    
    roll = 0.0;
    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );
#endif        
    
    vec3 ta = vec3(
        0.0, 
        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),
        0.0
    );

#ifdef CAM_STICKED    
    ro.x += s.playerPos.x;
    ta.x += s.playerPos.x;
#endif    
    
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, roll );
   
    // ray direction
    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );
    
    // render	
    vec4 col = render( ro, rd );
       
    color = col;
}

// Function 2553
float linesTextureGradBox( in float p, in float ddx, in float ddy, int id )
{
    float N = float( 2 + 7*((id>>1)&3) );

    float w = max(abs(ddx), abs(ddy)) + 0.01;
    float a = p + 0.5*w;                        
    float b = p - 0.5*w;           
    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-
                  floor(b)-min(fract(b)*N,1.0))/(N*w);
}

// Function 2554
float cubic_spline_approx(float x) {
    float m[2];
    m[0] = p[1] + (p[2] - p[0]) / 8.0;
    m[1] = p[2] - (p[3] - p[1]) / 8.0;
    float c = (m[0] + m[1]) / 2.0;
    x = x*2.0 - 1.0;
    bool left = (x < 0.0);
    vec3 q = left?vec3(p[1],m[0],c):vec3(c, m[1], p[2]);
    x += float(left);
    float t0 = (1.0 - x); t0 *= t0;
    float t1 = 2.0*(1.0 - x)*x;
    float t2 = x*x;
    return t0*q[0] + t1*q[1] + t2*q[2];
}

// Function 2555
float hsluv_toLinear(float c) {
    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;
}

// Function 2556
float rectSDF(vec2 st, vec2 s) {
	vec2 a = abs ( (st*2.-1.) / s);
    return max(a.x,a.y);
}

// Function 2557
vec2 minLineLine(vec3 a, vec3 nv, vec3 b, vec3 nw) {
    vec3 d = a - b;
    float vw = dot(nv, nw);
    float dv = dot(d, nv);
    float dw = dot(d, nw);
    return vec2(dv - dw*vw, -dw + dv*vw) / (vw*vw - 1.0);
}

// Function 2558
void DrawTundra(out vec4 c){
	c = vec4(0.1, 0.4, 0.2, 1.0);
}

// Function 2559
vec3 drawScrollingTitle(ivec2 coord, int animFrame)
{
    float mask = coordMask(coord, scrollingFrame);
    vec3 res = sampleHalfSprite(scrollSprite, scrollColors, coord - ivec2(0, animFrame)).rgb * mask;

    float frameMask = saturate(coordMask(coord, ivec4(0, 48, 319, 199)) - coordMask(coord, ivec4(8, 56, 311, 191)));
    res = lerp(res, titleLightGray, frameMask);

    vec4 boulderDash = drawBoulderDash(coord, bdColors);
    res = lerp(res, boulderDash.rgb, boulderDash.a);
    return res;
}

// Function 2560
float line(vec2 p, vec2 a, vec2 b)
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	
	return length( pa - ba*h );
}

// Function 2561
void drawDragDots(inout vec4 s,vec2 U,inout vec2 e
){for(float i=0.;i<maxCount;++i
 ){if(i>=s.y)break//bound by number of instantiated UIDots
  ;float f=length(U-bufDrag(i).xy)
  ;e=vec2(mix(e.x,i,step(f,e.y)),mi(f,e.y))
 ;}}

// Function 2562
vec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth
){float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y)//axis-align
 ;mat2 rotMat = rot2D(lineAngle)
 ;float lineLength = distance(p2_, p1_)    // make an axis-aligned line from this line.
 ;vec2 tl = (p1_ * rotMat)// top left
 ;vec2 br = tl + vec2(0,lineLength)// bottom right
 ;vec2 uvLine = uv * rotMat
 ;uvLine.x+=(noise01(uvLine*1.)-.5)*.02
 ;uvLine.x+=cos(uvLine.y*3.)*.009// smooth lp wave
 ;uvLine.x+=(noise01(uvLine*5.)-.5)*.005;// a sort of random waviness like individual strands are moving around
 ;uvLine.x+=(noise01(uvLine*min(iResolution.y,iResolution.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific
 ;float d = sdAxisAlignedRect(uvLine, tl, br)-lineWidth/2.
 ;uvLine=tl-uvLine
 ;vec2 lineSize = vec2(lineWidth, lineLength)
 ;vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,d, inpColor, brushColor)
 ;return ret;}

// Function 2563
float getOutline(vec2 fragCoord)
{
    vec2 coord = fragCoord;
    vec3 offset = vec3(1, -1, 0) * .5;
    float edge = 1.0;
    edge *= calcEdge(readNormal(coord+offset.xx), readNormal(coord+offset.yy));
    edge *= calcEdge(readNormal(coord+offset.xy), readNormal(coord+offset.yx));
    edge *= calcEdge(readNormal(coord+offset.zy), readNormal(coord+offset.zx));
    edge *= calcEdge(readNormal(coord+offset.yz), readNormal(coord+offset.xz));
    return edge;
}

// Function 2564
vec3 drawLineFade(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, vec3 oldColor)
{
    // this didn't work for some reason on my my Macbook, but on my iMac...
    if (AltFakeAO == 0)
    {
    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);
    d /= length(p2 - p1);
    d = clamp(step(0.0, d) * d, 0.0, 1.0);
    d = distance(p1 + d * (p2 - p1), coord);
    
    return mix(col, oldColor, clamp(0.0, 1.0, d / thickness));
    }
    else
    {
    float aaf = length(fwidth(coord));
    vec3 blendedCol = mix(col, oldColor, 0.66);
    float blendedLen = aaf * 3.0;
    vec3 color = drawLine(blendedCol, coord, p1, p2, blendedLen, oldColor);

    blendedCol = mix(col, oldColor, 0.33);
    blendedLen = aaf * 2.0;
    color = drawLine(blendedCol, coord, p1, p2, blendedLen, color);

    blendedCol = col;//mix(col, oldColor, 0.0);
    blendedLen = aaf;// * 1.0;
    color = drawLine(blendedCol, coord, p1, p2, blendedLen, color);

    return color;
    }
}

// Function 2565
float line(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a, ba = b - a; 
    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    float dist = length(pa - ba * h);
    return smoothout(dist);
}

// Function 2566
void DrawD( inout vec3 color, float x, float y )
{    
    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )
    {
    	color = RGB( 255, 255, 255 );        
        
        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) 
           	 || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) 
             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )
             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )
           )
        {
            color = RGB( 0, 0, 0 );
        }
    }
}

// Function 2567
bool in_rect(vec2 uv, vec2 origin){
    return abs(origin.x-uv.x) < XRADIUS &&
        abs(origin.y-uv.y) < YRADIUS;
}

// Function 2568
bool onSplitline(int distFrom, int spacing, int interval)
{
	int newSpacing = spacing * interval;
	
	return mod(float(distFrom), float(newSpacing)) == 0.0;
}

// Function 2569
vec2 lineInt(
    vec2 n1, float c1,
    vec2 n2, float c2
) {
    float
        a1 = n1.x, b1 = n1.y,
    	a2 = n2.x, b2 = n2.y;
    
    // solve equation system for x
    float x = 
        cross2(vec2(n1.y, c1), vec2(n2.y, c2)) /	//(b1*c2 - b2*c1) /
        cross2(n2, n1);	//(b1*a2 - b2*a1);
    float y = (c2 - a2*x) / b2;	// solve line 2 for y
    
    return vec2(x, y);
}

// Function 2570
vec4 drawPirate(int frame, ivec2 position, ivec2 offset)
{
    if ((any(lessThan(position, offset))) || (any(greaterThanEqual(position, offset + pirateFrameSize))))
    {
     	return vec4(0.0);
    }
    
    ivec2 pixel = position - offset;
    int i = pixel.y * pirateFrameSize.x + pixel.x;

#if (ANIMATION_FRAMES > FRAMES_NONE)
	if (frame == 0)
	{
        if ((i < 228) || (i > 4283))
        {
            return vec4(0.0);
        }
        
        const int frame[] = int[](228,229,230,16777447,16777448,16777449,16777450,235,16777463,33554680,249,16777466,16777467,318,319,320,50331969,322,323,33554767,336,337,338,339,33554840,16777625,16777626,16777627,16777640,425,426,16777643,67109360,33554929,33554930,67109363,67109375,33554944,16777729,33554946,67109447,67109448,33555017,67109450,83886667,67109452,67109462,67109463,67109464,50332249,67109466,67109467,67109535,83886752,67109537,83886754,83886755,67109540,67109550,83886767,67109552,67109553,83886770,67109555,67109623,83886840,83886841,83886842,83886843,67109628,67109637,67109638,83886855,83886856,67109641,83886858,67109643,67109711,67109712,83886929,83886930,83886931,67109716,67109725,83886942,83886943,83886944,83886945,67109730,67109798,67109799,67109800,83887017,83887018,83887019,67109804,67109812,67109813,67109814,83887031,83887032,83887033,67109818,67109886,67109887,83887104,83887105,83887106,67109891,67109900,67109901,67109902,67109903,83887120,83887121,67109974,67109975,67109976,67109977,83887194,67109979,67109980,67109987,83887204,67109989,83887206,83887207,67109992,67109993,67110062,67110063,83887280,83887281,83887282,67110067,67110068,67110074,67110075,83887292,83887293,83887294,83887295,67110080,67110150,83887367,83887368,83887369,83887370,83887371,67110156,67110157,67110161,67110162,83887379,83887380,83887381,83887382,83887383,67110168,67110238,83887455,83887456,83887457,83887458,83887459,83887460,67110245,67110246,50333031,67110249,83887466,83887467,83887468,83887469,83887470,67110255,67110327,83887544,83887545,83887546,83887547,83887548,83887549,67110334,50333119,67110336,67110337,83887554,83887555,83887556,83887557,83887558,67110343,67110416,83887633,83887634,83887635,67110420,83887637,33555990,67110423,83887640,67110425,83887642,83887643,83887644,83887645,67110430,67110504,67110505,83887722,83887723,33556076,67110509,33556078,83887727,83887728,67110513,83887730,83887731,83887732,83887733,67110518,67110593,67110594,83887811,33556164,67110597,33556166,67110599,83887816,33556169,83887818,83887819,83887820,83887821,67110606,67110682,67110683,33556252,67110685,33556254,67110687,67110688,33556257,83887906,83887907,83887908,67110693,67110768,1905,16779122,50333555,16779124,50333557,16779126,50333559,50333560,67110777,83887994,83887995,83887996,67110781,1992,100665289,117442506,100665291,117442508,100665293,117442510,117442511,117442512,50333649,67110866,83888083,67110868,134219808,150997025,167774242,167774243,167774244,167774245,167774246,117442599,117442600,117442601,50333738,150997112,100665465,117442682,117442683,117442684,100665469,117442686,167774335,184551552,184551553,67111042,134219984,150997201,167774418,167774419,167774420,167774421,167774422,117442775,117442776,184551641,117442778,150997288,100665641,117442858,117442859,117442860,100665645,117442862,167774511,184551728,33556785,33556786,50334003,33556788,16779573,16779574,16779575,16779576,184551788,100665716,50334069,50334070,50334071,50334072,50334073,50334074,50334075,117442943,117442944,150997377,167774594,167774595,167774596,167774597,117442950,50334087,16779656,16779657,16779658,2443,2444,2445,2446,2447,16779664,16779665,184551876,2501,33556934,33556935,33556936,33556937,50334154,100665803,16779724,16779725,16779726,16779727,16779728,16779729,50334162,50334163,117443028,150997462,150997463,167774680,167774681,117443034,184551899,117443036,167774685,167774686,16779743,2528,2529,2530,2531,50334180,50334181,16779750,2535,2536,117443099,184551964,33557021,2590,184551967,184551968,117443105,16779810,100665891,2596,2597,2598,2599,2600,2601,16779818,50334251,134220332,100665901,100665902,100665903,100665904,117443121,184551986,50334259,100665908,134220341,134220342,117443127,50334264,2617,184551994,50334267,50334268,16779837,2622,2623,117443184,117443185,117443186,117443187,184552052,2677,2678,16779895,2680,2681,100665980,2689,2690,16779907,150997636,150997637,150997638,150997639,167774856,167774857,184552074,50334347,100665996,167774861,150997646,150997647,150997648,167774865,117443218,184552083,16779924,2709,2710,117443267,117443269,117443270,117443271,100666056,100666057,100666058,100666059,100666060,184552141,2766,2767,134220508,134220509,100666078,100666079,100666080,117443297,184552162,50334435,100666084,134220517,134220518,134220519,100666088,117443305,117443306,117443307,184552172,33557229,134220569,117443355,117443356,100666141,100666142,100666143,184552229,150997813,150997814,167775031,167775032,117443385,50334522,16780091,50334524,167775037,150997822,150997823,150997824,150997825,167775042,117443395,100666180,184552261,134220655,117443441,134220658,100666227,100666228,184552318,134220686,150997903,100666256,33557393,16780178,16780179,50334612,100666261,134220694,134220695,100666264,117443481,117443482,167775131,134220742,201329607,134220744,134220745,100666343,50334696,16780265,33557482,16780267,3052,33557485,117443566,150997999,150998000,167775217,117443570,134220829,134220830,134220831,100666400,3133,3134,16780351,16780352,50334785,50334786,33557571,33557572,16780357,33557574,100666439,117443656,134220916,134220917,134220918,3221,3222,3223,16780440,16780441,50334874,50334875,33557660,134221003,134221004,100666573,218107118,3311,16780528,16780529,16780530,50334963,33557748,134221090,134221091,218107205,3398,3399,3400,16780617,16780618,3403,50335052,218107213,134221177,3484,16780701,3486,3487,16780704,16780705,33557922,3491,218107300,218107301,234884518,234884519,234884520,234884521,234884522,3572,16780789,234884598,16780791,33558008,218107385,50335226,50335227,234884604,234884605,234884606,184552959,184552960,184552961,184552962,234884611,33558094,50335311,50335312,234884689,234884690,234884691,234884692,184553045,184553046,184553051,234884773,234884774,234884775,234884776,234884777,234884778,234884779,150998700,167775917,234884782,234884860,234884861,234884862,184553215,234884864,234884865,234884866,234884867,234884868,150998789,167776006,234884947,234884948,184553301,184553302,234884952,234884953,234884954,234884955,234884956,234884957,150998878,167776095,167776096,167776098,234885035,184553388,234885041,234885042,234885043,234885044,234885045,234885046,150998967,167776184,167776185,167776188,184553475,234885130,234885131,234885132,234885133,184553486,150999057,167776274,167776275,167776279,234885218,234885219,184553572,184553573,150999148,167776365,150999150,234885306,184553659);
        
        for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return pirateColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
	
#if (ANIMATION_FRAMES >= FRAMES_FIGHT)
	if (frame == 1)
	{
        if ((i < 228) || (i > 4206))
        {
            return vec4(0.0);
        }
        
        const int frame[] = int[](228,229,230,16777447,16777448,16777449,16777450,235,16777463,33554680,249,16777466,16777467,318,319,320,50331969,322,323,33554767,336,337,338,339,33554840,16777625,16777626,16777627,16777640,425,426,16777643,67109360,33554929,33554930,67109363,67109375,33554944,16777729,33554946,67109447,67109448,33555017,67109450,83886667,67109452,67109462,67109463,67109464,50332249,67109466,67109467,67109535,83886752,67109537,83886754,83886755,67109540,67109550,83886767,67109552,67109553,83886770,67109555,67109623,83886840,83886841,83886842,83886843,67109628,67109637,67109638,83886855,83886856,67109641,83886858,67109643,67109711,67109712,83886929,83886930,83886931,67109716,67109725,83886942,83886943,83886944,83886945,67109730,67109798,67109799,67109800,83887017,83887018,83887019,67109804,67109812,67109813,67109814,83887031,83887032,83887033,67109818,67109886,67109887,83887104,83887105,83887106,67109891,67109900,67109901,67109902,67109903,83887120,83887121,67109974,67109975,67109976,67109977,83887194,67109979,67109980,67109987,83887204,67109989,83887206,83887207,67109992,67109993,67110062,67110063,83887280,83887281,83887282,67110067,67110068,67110074,67110075,83887292,83887293,83887294,83887295,67110080,67110150,83887367,83887368,83887369,83887370,83887371,67110156,67110157,67110161,67110162,83887379,83887380,83887381,83887382,83887383,67110168,134219064,134219066,134219068,117441854,67110238,83887455,83887456,83887457,83887458,83887459,83887460,67110245,67110246,50333031,67110249,83887466,83887467,83887468,83887469,83887470,67110255,100664719,134219153,134219154,134219155,134219156,134219157,134219158,134219159,117441945,117441947,67110327,83887544,83887545,83887546,83887547,83887548,83887549,67110334,50333119,67110336,67110337,83887554,83887555,83887556,83887557,83887558,67110343,134219246,134219247,134219248,134219249,134219250,117442035,117442036,117442038,67110416,83887633,83887634,83887635,67110420,83887637,33555990,67110423,83887640,67110425,83887642,83887643,83887644,83887645,67110430,134219338,134219339,134219340,117442125,117442126,117442127,117442128,67110504,67110505,83887722,83887723,33556076,67110509,33556078,83887727,83887728,67110513,83887730,83887731,83887732,83887733,67110518,100664997,100664998,117442215,117442216,117442217,117442218,67110593,67110594,83887811,33556164,67110597,33556166,67110599,83887816,33556169,83887818,83887819,83887820,83887821,67110606,100665087,100665088,117442305,117442306,117442307,67110682,67110683,33556252,67110685,33556254,67110687,67110688,33556257,83887906,83887907,83887908,67110693,100665177,100665178,117442395,117442396,117442397,117442398,184551266,67110768,1905,16779122,50333555,16779124,50333557,16779126,50333559,50333560,67110777,83887994,83887995,83887996,67110781,100665267,100665268,100665269,117442486,117442487,117442488,184551353,16779194,16779195,1992,100665289,117442506,100665291,117442508,100665293,117442510,117442511,117442512,50333649,67110866,83888083,67110868,100665358,100665359,117442576,184551441,184551442,16779283,16779284,134219808,150997025,167774242,167774243,167774244,167774245,167774246,117442599,117442600,117442601,50333738,184551528,184551529,184551530,16779371,16779372,50333805,117442671,150997112,100665465,117442682,117442683,117442684,100665469,117442686,167774335,184551552,184551553,67111042,184551616,16779457,16779458,16779459,2244,16779461,100665542,117442759,134219984,150997201,167774418,167774419,167774420,167774421,167774422,117442775,117442776,184551641,117442778,184551704,2330,2331,2332,16779549,100665630,16779551,16779552,50333985,150997288,100665641,117442858,117442859,117442860,100665645,117442862,167774511,184551728,33556785,33556786,50334003,33556788,16779573,16779574,16779575,16779576,117442928,134220149,2422,2423,2424,16779641,50334074,117442943,117442944,150997377,167774594,167774595,167774596,167774597,117442950,50334087,16779656,16779657,16779658,2443,2444,2445,2446,2447,16779664,16779665,2512,2513,16779730,50334163,150997462,150997463,167774680,167774681,117443034,184551899,117443036,167774685,167774686,16779743,2528,2529,2530,2531,50334180,50334181,16779750,2535,2536,2601,2602,16779819,134220332,100665901,100665902,100665903,100665904,117443121,184551986,50334259,100665908,134220341,134220342,117443127,50334264,2617,184551994,50334267,50334268,16779837,2622,2623,2690,2691,150997636,150997637,150997638,150997639,167774856,167774857,184552074,50334347,100665996,167774861,150997646,150997647,150997648,167774865,117443218,184552083,16779924,2709,2710,2779,134220508,134220509,100666078,100666079,100666080,117443297,184552162,50334435,100666084,134220517,134220518,134220519,100666088,117443305,117443306,117443307,184552172,33557229,2868,150997813,150997814,167775031,167775032,117443385,50334522,16780091,50334524,167775037,150997822,150997823,150997824,150997825,167775042,117443395,100666180,184552261,134220686,150997903,100666256,33557393,16780178,16780179,50334612,100666261,134220694,134220695,100666264,117443481,117443482,167775131,100666343,50334696,16780265,33557482,16780267,3052,33557485,117443566,150997999,150998000,167775217,117443570,3133,3134,16780351,16780352,50334785,50334786,33557571,33557572,16780357,33557574,100666439,117443656,3221,3222,3223,16780440,16780441,50334874,50334875,33557660,218107118,3311,16780528,16780529,16780530,50334963,33557748,218107205,3398,3399,3400,16780617,16780618,3403,50335052,218107213,3484,16780701,3486,3487,16780704,16780705,33557922,3491,218107300,218107301,234884518,234884519,234884520,234884521,234884522,3572,16780789,234884598,16780791,33558008,218107385,50335226,50335227,234884604,234884605,234884606,184552959,184552960,184552961,184552962,234884611,33558094,50335311,50335312,234884689,234884690,234884691,234884692,184553045,184553046,184553051,234884773,234884774,234884775,234884776,234884777,234884778,234884779,150998700,167775917,234884782,234884860,234884861,234884862,184553215,234884864,234884865,234884866,234884867,234884868,150998789,167776006,234884947,234884948,184553301,184553302,234884952,234884953,234884954,234884955,234884956,234884957,150998878,167776095,167776096,167776098,234885035,184553388,234885041,234885042,234885043,234885044,234885045,234885046,150998967,167776184,167776185,167776188,184553475,234885130,234885131,234885132,234885133,184553486,150999057,167776274,167776275,167776279,234885218,234885219,184553572,184553573,150999148,167776365,150999150,234885306,184553659);
        
        for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return pirateColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
	
#if (ANIMATION_FRAMES >= FRAMES_ALL)
	if (frame == 2)
	{
        if ((i < 228) || (i > 4167))
        {
            return vec4(0.0);
        }

		const int frame[] = int[](228,229,230,16777447,16777448,16777449,234,235,253,33554686,255,16777472,16777473,318,319,320,50331969,322,16777539,33554773,342,343,344,345,16777624,16777625,16777626,50332059,16777646,431,432,16777649,16777713,50332146,67109363,67109364,67109365,67109380,67109381,50332166,50332167,33554952,201327113,67109448,67109449,50332234,67109451,83886668,67109453,67109454,67109467,67109468,67109469,67109470,50332255,67109472,67109473,67109536,67109537,67109538,83886755,83886756,83886757,67109542,67109555,67109556,83886773,83886774,83886775,67109560,67109624,67109625,83886842,83886843,83886844,83886845,67109630,67109631,67109642,67109643,67109644,83886861,83886862,83886863,67109648,67109713,67109714,83886931,83886932,83886933,83886934,67109719,67109730,67109731,83886948,83886949,83886950,67109735,67109802,83887019,67109804,83887021,83887022,67109807,67109808,67109817,67109818,67109819,83887036,83887037,67109822,67109823,67109890,67109891,67109892,67109893,67109894,67109895,67109896,67109897,67109905,67109906,67109907,67109908,83887125,67109910,67109911,67109979,67109980,83887197,83887198,83887199,83887200,67109985,67109992,67109993,67109994,83887211,67109996,67109997,67109998,67110068,83887285,83887286,83887287,83887288,67110073,67110074,67110079,67110080,83887297,83887298,83887299,67110084,67110085,67110086,67110156,83887373,83887374,83887375,83887376,83887377,67110162,67110163,67110167,33555736,83887385,83887386,83887387,67110172,67110173,67110245,83887462,83887463,83887464,83887465,67110250,67110251,67110252,67110253,67110254,67110255,33555824,83887473,83887474,83887475,67110260,67110261,67110333,83887550,83887551,83887552,83887553,67110338,67110339,67110340,67110341,67110342,33555911,83887560,83887561,83887562,67110347,67110348,67110422,83887639,83887640,83887641,67110426,67110427,83887644,33555997,83887646,33555999,83887648,83887649,83887650,67110435,67110436,67110510,83887727,83887728,83887729,67110514,83887731,83887732,33556085,67110518,33556087,83887736,83887737,83887738,67110523,67110599,83887816,67110601,83887818,67110603,67110604,33556173,67110606,33556175,67110608,67110609,67110610,67110611,67110687,83887904,67110689,50333474,50333475,50333476,33556261,50333478,33556263,50333480,50333481,67110698,67110775,67110776,50333561,134219642,100665211,100665212,100665213,100665214,100665215,100665216,50333569,50333570,67110787,67110863,67110864,100665297,100665298,167774163,167774164,167774165,167774166,167774167,167774168,117442521,50333658,50333659,67110951,50333736,134219817,167774250,134219819,100665388,100665389,100665390,100665391,100665392,167774257,117442610,50333747,150997121,134219906,167774339,167774340,167774341,167774342,167774343,100665480,117442697,167774346,167774347,50333838,50333839,50333910,50333911,50333912,150997209,150997210,134219995,134219996,100665565,100665566,100665567,167774432,167774433,117442786,117442787,2276,50333925,33556710,16779495,16779496,50333996,50333997,50333998,50333999,50334000,150997297,134220082,134220083,150997300,167774517,167774518,167774519,100665656,100665657,167774522,167774523,117442876,33556797,33556798,16779583,50334016,2369,50334018,50334019,117442943,117442944,50334082,50334083,50334084,16779653,16779654,16779655,50334088,50334089,150997386,150997387,134220172,100665741,100665742,100665743,167774608,167774609,167774610,167774611,2452,16779669,33556886,16779671,2456,50334105,16779674,50334107,50334108,50334109,100665814,50334167,50334168,100665817,16779738,2523,2524,2525,2526,2527,2528,16779745,134220258,134220259,134220260,150997477,150997478,150997479,100665832,100665833,100665834,117443051,2540,117443053,16779758,2543,50334192,50334193,2546,2547,16779764,50334197,184551977,50334250,33557035,33557037,33557038,16779823,50334256,100665905,2610,2611,150997563,150997564,134220349,134220350,134220351,167774784,167774785,167774786,167774787,134220356,100665925,184552006,50334279,2632,16779849,16779850,2635,16779852,184552066,33557123,2692,184552069,117443206,33557127,134220424,134220436,134220437,134220438,150997655,33557144,100666009,134220442,134220443,134220444,100666013,117443230,184552095,2720,2721,2722,117443288,184552153,16779994,2779,184552156,16779997,2782,150997741,150997742,134220527,100666096,16780017,100666098,150997747,150997748,150997749,134220534,134220535,117443320,100666105,117443322,117443375,117443376,184552241,184552242,16780083,2868,2884,2885,16780102,16780103,50334536,50334537,33557322,33557323,16780108,134220621,150997838,150997839,134220624,117443461,117443462,117443463,100666248,184552331,2972,2973,2974,16780191,16780192,50334625,50334626,33557411,33557412,100666277,100666278,117443545,117443547,117443548,117443549,117443550,100666335,184552419,218106869,3062,16780279,16780280,16780281,50334714,33557499,117443634,117443635,117443636,100666421,218106956,3149,3150,3151,16780368,16780369,3154,50334803,218106964,134220935,117443720,134220937,117443722,117443723,100666508,3235,16780452,3237,3238,16780455,16780456,33557673,3242,218107051,218107052,234884269,234884270,234884271,234884272,234884273,134221024,117443809,134221026,3323,16780540,234884349,16780542,33557759,218107136,50334977,50334978,234884355,234884356,234884357,184552710,184552711,184552712,184552713,234884362,134221109,134221110,134221111,134221112,100666681,33557845,50335062,50335063,234884440,234884441,234884442,234884443,184552796,184552797,184552802,134221197,134221198,134221199,234884524,234884525,234884526,234884527,234884528,234884529,234884530,150998451,167775668,234884533,134221283,134221284,134221285,100666854,234884611,234884612,234884613,184552966,234884615,234884616,234884617,234884618,234884619,150998540,167775757,134221372,234884698,234884699,184553052,184553053,234884703,234884704,234884705,234884706,234884707,234884708,150998629,167775846,167775847,167775849,134221458,134221459,234884786,184553139,234884792,234884793,234884794,234884795,234884796,234884797,150998718,167775935,167775936,167775939,117444329,100667114,184553226,234884881,234884882,234884883,234884884,184553237,150998808,167776025,167776026,167776030,117444417,234884969,234884970,184553323,184553324,150998899,167776116,150998901,117444504,100667289,234885057,184553410,100667376,100667463);
        
		for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return pirateColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
	
	if (frame == 3)
	{
        if ((i < 228) || (i > 3924))
        {
            return vec4(0.0);
        }

		const int frame[] = int[](16777444,229,16777446,16777447,16777448,16777449,234,235,245,33554678,247,16777464,16777465,318,319,16777536,50331969,322,323,16777549,334,335,336,337,50332056,16777625,410,16777627,50332070,16777639,424,16777641,67109358,67109359,50332144,50332145,16777714,67109372,67109373,50332158,16777727,512,67109445,67109446,67109447,50332232,50332233,50332234,67109459,83886676,67109461,50332246,50332247,16777816,67109532,67109533,83886750,67109535,67109536,67109537,67109538,67109539,67109546,67109547,67109548,83886765,67109550,50332335,67109552,67109619,67109620,67109621,83886838,83886839,83886840,67109625,67109626,67109633,67109634,67109635,83886852,83886853,83886854,83886855,67109640,67109706,67109707,83886924,83886925,83886926,83886927,67109712,67109713,67109721,67109722,83886939,83886940,83886941,83886942,83886943,67109793,67109794,67109795,83887012,83887013,83887014,83887015,67109800,67109808,67109809,83887026,83887027,83887028,83887029,83887030,67109815,67109880,67109881,67109882,67109883,67109884,83887101,83887102,67109887,67109894,67109895,67109896,67109897,67109898,83887115,67109900,67109901,67109902,67109967,67109968,83887185,67109970,67109971,67109972,67109973,67109974,67109981,67109982,67109983,83887200,83887201,67109986,67109987,67109988,67109989,67110055,67110056,67110057,83887274,83887275,83887276,67110061,67110062,67110063,50332850,67110068,67110069,83887286,83887287,83887288,83887289,67110074,67110075,67110076,67110143,67110144,83887361,83887362,83887363,83887364,83887365,67110150,67110151,67110152,50332938,67110155,67110156,83887373,83887374,83887375,83887376,83887377,67110162,67110163,67110232,67110233,83887450,83887451,83887452,83887453,83887454,67110239,67110240,67110241,50333026,67110243,83887460,83887461,83887462,83887463,83887464,67110249,67110250,67110321,83887538,83887539,83887540,83887541,83887542,67110327,67110328,33555897,67110330,83887547,83887548,83887549,83887550,83887551,83887552,67110337,67110338,67110409,67110410,83887627,83887628,67110413,67110414,33555983,67110416,33555985,67110418,83887635,83887636,83887637,83887638,83887639,67110424,67110425,67110498,83887715,83887716,83887717,67110502,33556071,67110504,33556073,67110506,83887723,83887724,83887725,83887726,67110511,67110512,67110586,67110587,67110588,33556157,50333374,33556159,50333376,33556161,50333378,67110595,67110596,67110597,67110598,67110599,67110675,33556244,100665109,117442326,117442327,117442328,117442329,117442330,50333467,50333468,67110685,67110686,33556331,167774060,167774061,167774062,167774063,167774064,150996849,117442418,117442419,50333556,50333557,100665283,117442500,117442501,117442502,117442503,117442504,117442505,150996938,117442507,117442508,50333645,16779224,16779225,184551428,150997018,167774235,167774236,167774237,167774238,167774239,150997024,100665377,117442594,167774243,117442596,50333743,50333744,33556529,16779314,184551516,50333789,33556574,50333798,50333799,50333800,50333801,50333802,50333803,117442673,117442674,100665459,117442676,117442677,117442678,117442679,117442680,150997113,117442682,117442683,50333830,16779399,2184,2185,2186,184551604,33556661,33556662,33556663,33556664,117442746,16779451,16779452,16779453,16779454,16779455,16779456,16779457,16779458,50333891,50333892,117442757,184551622,184551623,167774408,167774409,150997194,150997195,100665548,50333901,100665550,150997199,150997200,117442769,167774418,167774419,50333911,50333912,50333913,50333914,50333915,50333916,16779485,16779486,2271,2272,2273,2274,117442818,117442820,117442821,117442822,117442823,117442824,117442825,117442826,184551691,16779532,2317,184551694,184551695,117442832,33556753,117442834,2323,2324,2325,2326,2327,2328,2329,2330,16779547,100665628,117442845,117442846,184551711,117442848,117442849,100665634,117442851,50333988,134220069,100665638,134220071,134220072,117442857,117442858,184551723,184551724,50333997,50333998,50333999,50334000,16779569,16779570,2355,2356,2357,2358,2359,2360,134220114,134220116,117442902,117442904,117442906,117442907,100665692,100665693,100665694,100665695,100665696,100665697,100665698,184551779,184551780,16779621,2406,2407,2408,33556841,100665706,33556850,2419,150997364,150997365,150997366,150997367,167774584,167774585,167774586,117442939,50334076,134220157,167774590,150997375,150997376,117442945,117442946,184551811,167774596,100665733,50334086,50334087,16779656,2441,2442,2443,134220198,134220200,134220201,134220202,134220203,100665772,100665773,134220206,100665775,100665776,100665777,100665778,100665779,117443005,134220226,100665804,134220237,134220238,100665807,100665808,117443025,117443026,50334163,50334164,33556949,100665814,117443031,134220248,150997465,83888602,117443035,134220252,150997469,100665822,33556959,2528,134220284,134220285,134220286,134220287,134220288,134220289,100665877,100665893,134220326,150997543,150997544,100665897,50334250,33557035,33557036,33557037,100665902,150997551,134220336,117443121,117443122,150997555,134220340,100665909,150997558,134220372,100665983,134220416,33557121,33557122,33557123,33557124,2693,33557126,100665991,150997640,150997641,134220426,100665995,150997644,100665997,50334423,50334424,33557209,33557210,33557211,33557212,16779997,33557214,100666079,134220512,134220513,150997730,100666083,100666084,16780077,16780078,16780079,16780080,50334513,50334514,33557299,33557300,234883894,100666167,100666168,100666169,100666170,2949,2950,2951,2952,16780169,16780170,50334603,218106764,234883985,234883986,218106847,3040,3041,16780258,16780259,16780260,218106853,234884071,234884072,234884073,184552426,184552427,234884076,218106933,218106934,3127,3128,16780345,33557562,16780347,218106940,234884157,234884158,234884159,184552512,184552513,184552516,3212,3213,16780430,3215,3216,50334865,218107026,33557651,234884244,234884245,234884246,234884247,3300,3301,16780518,234884327,50334952,234884329,234884330,234884331,234884332,234884333,234884334,234884335,50335038,234884415,234884416,234884417,234884418,234884419,150998340,167775557,234884422,234884423,234884424,234884502,234884503,234884504,234884505,234884506,234884507,234884508,150998429,167775646,234884511,234884512,234884513,234884589,234884590,234884591,234884592,234884593,234884594,234884595,234884596,234884597,150998518,167775735,167775736,234884601,167775738,234884676,234884677,234884678,234884682,234884683,234884684,234884685,234884686,150998607,167775824,167775825,167775828,234884764,234884765,184553123,234884772,234884773,234884774,150998697,150998698,167775915,167775919,184553204,184553205,234884860,184553213,150998788,167776005,167776006,184553300);
        
		for (int j = 0; j < frame.length(); j++)
        {
            int data = frame[j];
            int index = data & 0xFFFFFF;
            
            if (index == i)
            {
                return pirateColorPalette[data >> 24];
            }
        }

		return vec4(0.0);
	}
#endif
#endif
#endif
    
    return vec4(0.0);
}

// Function 2571
vec3 Spline_EvaluateTangent(mat4 MG, float t )
{
	vec4 tvec = vec4(3.*t*t, 2.*t, 1, 0.);	
	vec3 p = (MG*tvec).xyz;
	return p;
}

// Function 2572
void PrintEndCurrentLine( inout PrintState state, const LayoutStyle style )
{
    // Apply CR
    state.vCursorPos.x = state.vLayoutStart.x;
    
    // advance Y position to bottom of descender based on current font size.
	state.vCursorPos.y += style.vSize.y * g_fFontDescent;    
}

// Function 2573
void drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {
    p = (p - pos) / size + 0.5;
    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {
        float val = textureGrad(iChannel1, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;
        color = mix(color, charColor, val);
    }
}

// Function 2574
vec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {
    vec2 xy = fragCoord - resolution.xy / 2.0;
    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 2575
float PointLineDistance2(vec2 p, vec2 p0, vec2 p1)
{
    vec2 proj = PointLineProj(p, p0, p1);
    
    return dot(proj-p, proj-p);
}

// Function 2576
float fLineSegment(vec3 p, vec3 a, vec3 b) {
	vec3 ab = b - a;
	float t = saturate(dot(p - a, ab) / dot(ab, ab));
	return length((ab*t + a) - p);
}

// Function 2577
float mengerRect(vec2 p, vec2 center, vec2 size){
    vec2 hs = size / 2.;
    p -= center;
    vec2 z = (p / hs) * 1.;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
	vec2 a1 = vec2(-1.,1);
	vec2 a2 = vec2(-1,-1);
	vec2 a3 = vec2(1,-1);
    vec2 a4 = vec2(1, 1);
	vec2 c;
	float dist, d;
    float Scale = 2.;
    const int maxN = 8;
	for (int n = 0 ; n < maxN ; n++) {
		 c = a1; dist = length(z-a1);
	     d = length(z-a2); if (d < dist) { c = a2; dist=d; }
		 d = length(z-a3); if (d < dist) { c = a3; dist=d; }
		 d = length(z-a4); if (d < dist) { c = a4; dist=d; }

        z = Scale*z-c*(Scale-1.0);
	}

	return length(z) * pow(Scale, -float(maxN)) - 0.01;
}

// Function 2578
float draw_map(vec2 world_coords, float line_width) {
    vec4 raw = sample_map(CHANNEL_SPRITES, CHANNEL_SPRITES_RESOLUTION, world_coords);
    
    float edge_sdf = abs(raw.z) / line_width;
    
    if (raw.z > 0.0) {
        edge_sdf = min(edge_sdf, draw_background(world_coords));
    }
    
    return edge_sdf;
}

// Function 2579
bool RectShiftRightContains(Rect rect, vec2 pos, float eyeWidth)
{
    float shift = (eyeWidth - rect.z) / iResolution.x;
    return (rect.x + shift * 0.5f <= pos.x && pos.x < rect.x + rect.w - shift * 1.5 &&
            rect.y <= pos.y && pos.y < rect.y + rect.h);
}

// Function 2580
bool lineIntersection(vec2 L1A, vec2 L1B, vec2 L2A, vec2 L2B, out vec2 p)
{
    //Line 1 Vector
    vec2 v1 = L1B - L1A;
    
    //Line 2 Vector
    vec2 v2 = L2B - L2A;
    
    //Cross of vectors
    float d = cross2D(v1,v2);
    
    //Difference between start points
    vec2 LA_delta = L1A - L2A;
    
    //Percentage v1 x LA_delta is along v1 x v2
    float s = cross2D(v1,LA_delta) / d;
    
    //Percentage v2 x LA_delta is along v1 x v2
    float t = cross2D(v2,LA_delta) / d;
    
    //Do segments intersect?
    //Bounds test
    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)
    {
        //Projection
        p = vec2(L1A.x + (t * v1.x), L1A.y + (t * v1.y)); 
        return true;
    }
    return false;
}

// Function 2581
float segmented_spline_c5_fwd( float x )
{
	// RRT_PARAMS
	SegmentedSplineParams_c5 C;
    C.coefsLow[0] = -4.0; C.coefsLow[1] = -4.0; C.coefsLow[2] = -3.1573765773;
    C.coefsLow[3] = -0.4852499958; C.coefsLow[4] = 1.8477324706; C.coefsLow[5] = 1.8477324706;
   	C.coefsHigh[0] = -0.7185482425; C.coefsHigh[1] = 2.0810307172; C.coefsHigh[2] = 3.6681241237;
    C.coefsHigh[3] = 4.0; C.coefsHigh[4] = 4.0; C.coefsHigh[5] = 4.0;
	C.minPoint = vec2(0.18 * exp2(-15.0), 0.0001);
	C.midPoint = vec2(0.18,                4.8);
	C.maxPoint = vec2(0.18 * exp2(18.0), 10000.0);
	C.slopeLow = 0.0;
    C.slopeHigh = 0.0;

	const int N_KNOTS_LOW = 4;
	const int N_KNOTS_HIGH = 4;

	// Check for negatives or zero before taking the log. If negative or zero,
	// set to ACESMIN.
	float xCheck = x <= 0.0 ? exp2(-14.0) : x;

	float logx = log10(xCheck);

	float logy;

	if ( logx <= log10(C.minPoint.x) )
	{
		logy = logx * C.slopeLow + ( log10(C.minPoint.y) - C.slopeLow * log10(C.minPoint.x) );
	}
	else if (( logx > log10(C.minPoint.x) ) && ( logx < log10(C.midPoint.x) ))
	{
		float knot_coord = float(N_KNOTS_LOW-1) * (logx-log10(C.minPoint.x))/(log10(C.midPoint.x)-log10(C.minPoint.x));
		int j = int(knot_coord);
		float t = knot_coord - float(j);

        // can't index on non-const value...
		//vec3 cf = vec3(C.coefsLow[j], C.coefsLow[j + 1], C.coefsLow[j + 2]);
        vec3 cf = vec3(C.coefsLow[0], C.coefsLow[1], C.coefsLow[2]);
        if (j == 1)
            cf = vec3(C.coefsLow[1], C.coefsLow[2], C.coefsLow[3]);
        else if (j == 2)
            cf = vec3(C.coefsLow[2], C.coefsLow[3], C.coefsLow[4]);
         else if (j == 3)
            cf = vec3(C.coefsLow[3], C.coefsLow[4], C.coefsLow[5]);       
    
		vec3 monomials = vec3(t * t, t, 1.0);
		logy = dot( monomials, (M * cf) );
	}
	else if (( logx >= log10(C.midPoint.x) ) && ( logx < log10(C.maxPoint.x) ))
	{
		float knot_coord = float(N_KNOTS_HIGH-1) * (logx-log10(C.midPoint.x))/(log10(C.maxPoint.x)-log10(C.midPoint.x));
		int j = int(knot_coord);
		float t = knot_coord - float(j);

        // can't index on non-const value...
		//vec3 cf = vec3(C.coefsHigh[j], C.coefsHigh[j + 1], C.coefsHigh[j + 2]); 
 		vec3 cf = vec3(C.coefsHigh[0], C.coefsHigh[1], C.coefsHigh[2]);
        if (j == 1)
            cf = vec3(C.coefsHigh[1], C.coefsHigh[2], C.coefsHigh[3]);
        else if (j == 2)
            cf = vec3(C.coefsHigh[2], C.coefsHigh[3], C.coefsHigh[4]);
         else if (j == 3)
            cf = vec3(C.coefsHigh[3], C.coefsHigh[4], C.coefsHigh[5]); 
             
		vec3 monomials = vec3(t * t, t, 1.0);
		logy = dot( monomials, (M * cf) );
	}
	else //if ( logIn >= log10(C.maxPoint.x) )
	{
		logy = logx * C.slopeHigh + ( log10(C.maxPoint.y) - C.slopeHigh * log10(C.maxPoint.x) );
	}

	return pow(10.0, logy);
}

// Function 2582
float circle(vec2 p, vec2 c, float w) {
    float dist = length(p - c) - w;
    return smoothstep(PIX,0.0,dist);
}

// Function 2583
vec4 bilinearFilter2(vec2 coords) {
    float size = 512.0;
    vec2 trTexCoords = coords * size;
    vec2 texf = floor(trTexCoords);
    vec2 ratio = trTexCoords - texf;
    vec2 opposite = 1.0 - ratio;
    vec4 result = (texture(iChannel2, texf / size) * opposite.x  + texture(iChannel2, (texf + vec2(1, 0)) / size)   * ratio.x) * opposite.y + 
                  (texture(iChannel2, (texf + vec2(0, 1)) / size) * opposite.x + texture(iChannel2, (texf + vec2(1, 1)) / size) * ratio.x) * ratio.y;
    return result;
}

// Function 2584
void DrawWetGrass(out vec4 c){
	c = vec4(0.0, 0.7, 0.0, 1.0);
}

// Function 2585
float SDFCircle( in vec2 coords )
{
    float v = coords.x * coords.x + coords.y * coords.y - 5.0;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return abs(v)/length(g); 
}

// Function 2586
float circle3(vec2 uv, vec2 center, float radius, float width)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    float offset=2.5*snoise(uv+sin(iTime));
    float noise=.6*gnoise(uv);
    float theta = offset*(atan(d.y,d.x)/M_PI);
    return smoothstep(5.0, 3.1, abs(mod(theta+3.0,55.0)-3.0)) *
        mix( 0.6, 2.0, step(55.0, abs(mod(theta, 280.0)-100.0)) ) *
        (SMOOTH(r-width/3.0,radius)-SMOOTH(r+width/3.0,radius));
}

// Function 2587
float randomLine(float seed)
{
	float b = 0.01 * rand(seed);
	float a = rand(seed+1.0);
	float c = rand(seed+2.0) - 0.5;
	float mu = rand(seed+3.0);
	
	float l = 1.0;
	
	if ( mu > 0.2)
		l = pow(  abs(a * uv.x + b * uv.y + c ), 1.0/8.0 );
	else
		l = 2.0 - pow( abs(a * uv.x + b * uv.y + c), 1.0/8.0 );				
	
	return mix(0.5, 1.0, l);
}

// Function 2588
vec3 rectToSpher(vec3 v) {
	const float pi = 3.14159265359;
	vec3 res;
	res.x = length(v);
	res.y = atan(v.z, v.x); //longditude
	res.y += 2.0 * pi * step(0.0, res.y);
	res.z = atan(v.y, length(v.xz)); //latitude
	return res;
}

// Function 2589
float coverageLine(float d, float lineWidth, float pixsize){
	d=d*1./pixsize;
	float v1=(d-0.5*lineWidth)/DRadius;
	float v2=(d+0.5*lineWidth)/DRadius;
	return coverageFunction(v1)-coverageFunction(v2);
}

// Function 2590
vec4 texture3DLinear(sampler2D tex, vec3 uvw, vec3 vres)
{
    vec3 blend = fract(uvw*vres);
    vec4 off = vec4(1.0/vres, 0.0);
    
    //2x2x2 sample blending
    vec4 b000 = texture3D(tex, uvw + off.www, vres);
    vec4 b100 = texture3D(tex, uvw + off.xww, vres);
    
    vec4 b010 = texture3D(tex, uvw + off.wyw, vres);
    vec4 b110 = texture3D(tex, uvw + off.xyw, vres);
    
    vec4 b001 = texture3D(tex, uvw + off.wwz, vres);
    vec4 b101 = texture3D(tex, uvw + off.xwz, vres);
    
    vec4 b011 = texture3D(tex, uvw + off.wyz, vres);
    vec4 b111 = texture3D(tex, uvw + off.xyz, vres);
    
    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), 
               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),
               blend.z);
}

// Function 2591
vec4 getParticlePositionAndDirection( int index )
{
    return texelFetch(iChannel0, indexToCoords(index, iChannelResolution[0].x), 0);
}

// Function 2592
float line(vec2 P, vec2 A, vec2 B, float r)
{
	vec2 g = B - A;
    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));
	return smoothstep(r, 0.5*r, d);
}

// Function 2593
float
cline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )
{
    vec3 ap = p - a, ab = b - a;
    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );
    return length( ap - ab * t ) - r;
}

// Function 2594
float Linear(float s,float e,float t)
{
    t = clamp((t - s) / (e - s),0.0,1.0);
    return t;
}

// Function 2595
float juliaRect(vec2 p, vec2 center, vec2 size) {
    vec2 hs = size / 2.;
    p -= center;
    vec2 z = (p / hs) * 1.5;
    vec2 pabs = abs(p);
    if(0. < max(pabs.x - hs.x, pabs.y - hs.y)) return 1000.;
    
    vec2 c = vec2(-0.618, 0.);
    for(int i = 0 ; i < 1024; i++){
    	z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;

        if( dot(z, z) > 4.0){
        	return 1000.;
        }
    }
    return -1.;
}

// Function 2596
void drawGrid(inout vec4 baseCol, vec2 xy, float stepSize, vec4 gridCol)
{
	float hlw = GRID_WIDTH * pp * 0.5;
    float mul = 1.0 / stepSize;
	vec2 gf = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul));
	float g = 1.0 - aaStep(hlw * mul, (hlw + pp * AA_FALLOFF) * mul, min(gf.x, gf.y));
    blend(baseCol, gridCol, g);
}

// Function 2597
float draw(vec2 st, vec2 tileXY, vec2 count) {
    // y is bottom to top, but we want to show things from top to bottom. Convert
    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);
    float color = 0.;
    
    switch (cardNumber) {
    case 0: { // void
        color = 0.;
        break;
    }
    case 1: { // justice
        color = sstep(0.5 * S, st.x);
        break;
    }
    case 2: { // strength
        color = sstep(0.5 + cos(st.y * PI + iTime/2.) * 0.25, st.x);
        break;
    }
    case 3: { // death
        color = sstep(0.5, (st.x * S + st.y * C) * 0.5);
        break;
    }
    case 4: { // wall
        color = stroke(st.x, 0.5, 0.15*S);  
        break;
    }
    case 5: { // temperance
        float offset = cos(st.y * PI + iTime) * 0.15;
        color = stroke(st.x, .28 + offset, 0.1);
        color += stroke(st.x, .5 + offset, 0.1);
        color += stroke(st.x, .72 + offset, 0.1);
        break;
    }
    case 6: { // branch
        float offset = 0.5 + (st.x - st.y) * 0.5;
        color = stroke(offset, 0.5, 0.1 * S);
        break;
    }
    case 7: { // the hanged man
        float sdf = 0.5 + (st.x - st.y) * 0.5;
        color = stroke(sdf, 0.5, 0.1 * C);
        float sdf_inv = (st.x + st.y) * 0.5;
        color += stroke(sdf_inv, 0.5, 0.1 * C);
        break;
    }
    case 8: { // the high priestess
        color = stroke(circleSDF(st), 0.5 * S, 0.05 * C);
        break;
    }
    case 9: { // the moon
        color = fill(circleSDF(st), 0.65);
        vec2 offset = vec2(0.1, 0.05);
        color -= fill(circleSDF(st - offset * S), 0.5);
        break;
    }
    case 10: { // the emperor
        float sdf = rectSDF(st, vec2(1.));
        color = stroke(sdf, .5 * C, .125);
        color += fill(sdf, .1 * S);
        break;
    }
    case 11: { // the hierophant
        float rect = rectSDF(st, vec2(1));
        color = fill(rect, .5);
        float cross = crossSDF(st, 1.);
        color *= sstep(.5, fract(cross * 3. + iTime));
        color *= sstep(1., cross);
        color += fill(cross, .5);
        color += stroke(rect, .65, .05);
        color += stroke(rect, .75, .025);
        break;
    }
    case 12: { // the tower
        float rect = rectSDF(st, vec2(.5, 1.));
        float diag = (st.x * C + st.y * S) * .5;
        color = flip(fill(rect, .6), stroke(diag, .5, .01));
        break;
    }
    case 13: { // merge
        vec2 offset = vec2(.15 * S, 0);
        float left = circleSDF(st + offset);
        float right = circleSDF(st - offset);
        color = flip(stroke(left, .5, .05), fill(right, 0.525));
        break;
    }
    case 14: { // hope
        float sdf = vesicaSDF(st, .2 * S);
        color = flip(fill(sdf, .5), sstep((st.x + st.y) * .5, .5));
        break;
    }
    case 15: { // the temple
        st.y = 1. - st.y;
        vec2 ts = vec2(st.x, .82 - st.y);
        color = fill(triSDF(st), .7);
        color -= fill(triSDF(ts), .36);
        break;
    }
    case 16: { // the summit
        float circle = circleSDF(st - vec2(.0, .1));
        float triangle = triSDF(st + vec2(.0, .1));
        color = stroke(circle, .5 * C, .1);
        color *= sstep(.55, triangle);
        color += fill(triangle, .45);
        break;
    }
    case 17: { // the diamond
        float sdf = rhombSDF(st);
        color = fill(sdf, .425 * S);
        color += stroke(sdf, .5 * S, .05);
        color += stroke(sdf, .6 * C, .03);
        break;
    }
    case 18: { // the hermit
        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    
        break;
    }
    case 19: { // intuition
        st = rotate(st, radians(-25.) * S);
        float sdf = triSDF(st);
        sdf /= triSDF(st + vec2(0., .2 * C));
        color = fill(abs(sdf), .56);
        break;
    }
    case 20: { // the stone
        st = rotate(st, radians(45.));
        color = fill(rectSDF(st, vec2(1.)), .4);
        color *= 1. - stroke(st.x, .5 * S, .02);
        color *= 1. - stroke(st.y, .5 * C, .02);
        break;
    }
    case 21: { // the mountain
        st = rotate(st, radians(-45.));
        float off = .12 * S;
        vec2 s = vec2(1.);
        color = fill(rectSDF(st + off, s), .2 * C);
        color += fill(rectSDF(st - off, s), .2 * C);
        float r = rectSDF(st, s);
        color *= sstep(.33, r);
        color += fill(r, .3);
        break;
    }
    case 22: { // the shadow
        st = rotate(vec2(st.x, 1. - st.y), radians(45.));
        vec2 s = vec2(1.);
        color += fill(rectSDF(st - .025 * S, s), .4);
        color += fill(rectSDF(st + .025, s), .4);
        color *= sstep(0.38, rectSDF(st + .025, s));
        break;
    }
    case 23: { // opposite
        st = rotate(st, radians(-45.));
        vec2 s = vec2(1.);
        float o = .05 * S * 1.5;
        color += flip(
            fill(rectSDF(st - o, s), .4), 
            fill(rectSDF(st + o, s), .4)
        );
        break;
    }
    case 24: { // the oak
        st = rotate(st, radians(45.));
        float r1 = rectSDF(st, vec2(1.) * S);
        float r2 = rectSDF(st + .15 * S, vec2(1.));
        color += stroke(r1, .5, .05);
        color *= sstep(.325, r2);
        color += stroke(r2, .325, .05) * fill(r1, .525);
        color += stroke(r2, .2, .05);
        break;
    }
    case 25: { // ripples
        st = rotate(st, radians(-45.)) - .08;
        for (int i = 0; i < 4; i++) {
            float r = rectSDF(st, vec2(1.) * S);
            color += stroke(r, .19, .04);
            st += .05;
        }
        break;
    }
    case 26: { // the empress
        float d1 = polySDF(st, 5);
        vec2 ts = vec2(st.x, 1. - st.y);
        float d2 = polySDF(ts, 5);
        color = fill(d1, .75) * fill(fract(d1 * 5. - iTime/2.), .5);
        color -= fill(d1, .6) * fill(fract(d2 * 4.9 - iTime/2.), .45);
        break;
    }
    case 27: { // bundle
        st = st.yx;
        color = stroke(hexSDF(st), .6 * C, .1);
        color += fill(hexSDF(st - vec2(-.06, -.1) * S), .15);
        color += fill(hexSDF(st - vec2(-.06, .1) * S), .15);
        color += fill(hexSDF(st - vec2(.11, 0.) * S), .15);
        break;
    }
    case 28: { // the devil
        color += stroke(circleSDF(st), .8 * C, .05);
        st.y = 1. - st.y;
        float s = starSDF(st.yx, 5, .1);
        color *= sstep(.7 * C, s);
        color += stroke(s, .4 * S, .1);
        break;
    }
    case 29: { // the sun
        float bg = starSDF(st, 16, .1 * S);
        color += fill(bg, 1.3);
        float l = 0.;
        for (float i = 0.; i < 8.; i++) {
            vec2 xy = rotate(st, QTR_PI * i+iTime/4.);
            xy.y -= .3;
            float tri = polySDF(xy, 3);
            color += fill(tri, .3);
            l += stroke(tri, .3 * S, .03);
        }
        color *= 1. - l;
        float c = polySDF(st, 8);
        color -= stroke(c, .15, .04);
        break;
    }
    case 30: { // the star
        color = stroke(raysSDF(st, 8), .5, .15 * C * 2.);
        float inner = starSDF(st.xy, 6, .09 * S);
        float outer = starSDF(st.yx, 6, .09 * S);
        color *= sstep(.7, outer);
        color += fill(outer, .5);
        color -= stroke(inner, .25, .06);
        color += stroke(outer, .6, .05);
        break;
    }
    case 31: { // judgement
        color = flip(
            stroke(raysSDF(rotate(st, -iTime/8.), 28), .5, .2), 
            fill(st.y, .5)
        );
        float rect = rectSDF(st, vec2(1) * S);
        color *= sstep(.25, rect);
        color += fill(rect, .2);
        break;
    }
    case 32: { // wheel of fortune
        float sdf = polySDF(rotate(st.yx, C), 8);
        color = fill(sdf, .5);
        color *= stroke(raysSDF(rotate(st, C), 8), .5, .2);
        color *= sstep(.27, sdf);
        color += stroke(sdf, .2, .05);
        color += stroke(sdf, .6, .1);
        break;
    }
    case 33: { // vision
        float v1 = vesicaSDF(st, .5);
        vec2 st2 = st.yx + vec2(.04, .0);
        float v2 = vesicaSDF(st2, .7);
        color = stroke(v2, 1., .05);
        st = rotate(st, iTime/2.);
        color += fill(v2, 1.) * stroke(circleSDF(st - vec2(.05)), .3 , .05);
        color += fill(raysSDF(st, 50), .2) *
            fill(v1, 1.25) *
            sstep(1., v2);
        break;
    }
    case 34: { // the lovers
        color = fill(heartSDF(st), .5 * C * 1.2);
        color -= stroke(polySDF(st, 3), .15 * S * 1.1, .05);
        break;
    }
    case 35: { // the magician
        st.x = flip(st.x, step(.5, st.y));
        vec2 offset = vec2(.15 * S, .0);
        float left = circleSDF(st + offset);
        float right = circleSDF(st - offset);
        color = stroke(left, .4 * S, .075);
        color = bridge(color, right, .4 * S, .075);
        break;
    }
    case 36: { // the link
        st = st.yx;
        st.x = mix(1. - st.x, st.x, step(.5, st.y));
        vec2 o = vec2(.1, .0);
        vec2 s = vec2(1.) * C;
        float a = radians(45.) + iTime/2.;
        float l = rectSDF(rotate(st + o, a), s);
        float r = rectSDF(rotate(st - o, -a), s);
        color = stroke(l, .3, .1);
        color = bridge(color, r, .3, .1);
        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);
        break;
    }
    case 37: { // holding together
        st.x = mix(1. - st.x, st.x, step(.5, st.y));
        vec2 o = vec2(.05, .0);
        vec2 s = vec2(1.);
        float a = radians(45.);
        float l = rectSDF(rotate(st + o, a * S), s);
        float r = rectSDF(rotate(st - o, -a * S), s);
        color = stroke(l, .145, .098);
        color = bridge(color, r, .145, .098);
        break;
    }
    case 38: { // the chariot
        float r1 = rectSDF(st, vec2(1.));
        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));
        float inv = step(.5, (st.x + st.y) * .5);
        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));
        float w = .075 * S * 1.2;
        color = stroke(r1, .5, w) + stroke(r2, .5, w);
        float bridges = mix(r1, r2, inv);
        color = bridge(color, bridges, .5, w);
        break;
    }
    case 39: { // the loop
        float inv = sstep(.5, st.y);
        st = rotate(st, radians(-45.)) - .2;
        st = mix(st, .6 - st, sstep(.5, inv));
        for (int i = 0; i < 5; i++) {
            float r = rectSDF(st, vec2(1.));
            float s = .25;
            s -= abs(float(i) * .1 - .2);
            color = bridge(color, r, s, .05 * S);
            st += .1;
        }
        break;
    }
    case 40: { // turning point
        st = rotate(st, radians(-60.) + iTime/4.);
        st.y = flip(st.y, step(.5, st.x));
        st.y += .25;
        float down = polySDF(st, 3);
        st.y = 1.5 - st.y;
        float top = polySDF(st, 3);
        color = stroke(top, .4, .15 * S);
        color = bridge(color, down, .4, .15 * S);
        break;
    }
    case 41: { // trinity
        st.y = 1. - st.y;
        float s = .25 * C*1.3;
        float t1 = polySDF(st + vec2(.0, .175), 3);
        float t2 = polySDF(st + vec2(.1, .0), 3);
        float t3 = polySDF(st - vec2(.1, .0), 3);
        color = stroke(t1, s, .08) +
                stroke(t2, s, .08) +
                stroke(t3, s, .08);
        float bridges = mix(
            mix(t1, t2, step(.5, st.y)),
            mix(t3, t2, step(.5, st.y)),
            step(.5, st.x)
        );
        color = bridge(color, bridges, s, .08);
        break;
    }
    case 42: { // the cauldron
        float n = 12.;
        float a = TAU / n;
        for (float i = 0.; i < n; i++) {
            vec2 xy = rotate(st, a * i);
            xy.y -= .189;
            float vsc = vesicaSDF(xy, .3);
            color *= 1. - stroke(vsc, .45 * S, .1) * sstep(.5, xy.y);
            color += stroke(vsc, .45 * S, .05);
        }
        break;
    }
    case 43: { // the elders
        float n = 3.;
        float a = TAU / n;
        for (float i = 0.; i < n * 2.; i++) {
            vec2 xy = rotate(st, a * i);
            xy.y -= .09;
            float vsc = vesicaSDF(xy, .3);
            color = mix(
                color + stroke(vsc, .5, .1*S),
                mix(color, bridge(color, vsc, .5, .1*S), step(xy.x, .5) - step(xy.y, .4)),
                step(3., i)
            );
            
        }
        break;
    }
    case 44: { // the core
        float star = starSDF(st, 8, .063);
        color += fill(star, 1.22);
        float n = 8.;
        float a = TAU / n;
        for (float i = 0.; i < n; i++) {
            vec2 xy = rotate(st, 0.39 + a * i);
            xy = scale(xy, vec2(1., .72) * S);
            xy.y -= .125;
            color *= sstep(.235, rhombSDF(xy));
        }
        break;
    }
    case 45: { // inner truth
        st -= .5;
        float r = dot(st, st);
        float a = atan(st.y, st.x) / PI;
        vec2 uv = vec2(a, r);
        vec2 grid = vec2(5., log(r) * 20. * S);
        vec2 uv_i = floor(uv * grid);
        uv.x += .5 * mod(uv_i.y, 2.);
        vec2 uv_f = fract(uv * grid);
        float shape = rhombSDF(uv_f);
        color += fill(shape, .9) * sstep(.75, 1. - r);
        break;
    }
    case 46: { // the world
        color = fill(flowerSDF(rotate(st, -iTime/4.), 5), .25*C);
        color -= sstep(.95, starSDF(rotate(st, 0.628 - iTime/4.), 5, .1*S));
        color = clamp(color, 0., 1.);
        float circle = circleSDF(st);
        color -= stroke(circle, .1, .05);
        color += stroke(circle, .8, .07);
        break;
    }
    case 47: { // the fool
        color = sstep(.5, spiralSDF(rotate(st, iTime/2.), .13 * S));
        break;
    }
    case 48: { // enlightenment
        color = 1.;
        break;
    }
    case 49: { // elements. Added by me. Approximated
        st = rotate(st, -iTime/4.);
        float d = .15;
        float r = .3 * S;
        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), r);
        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), r);
        color += fill(circleSDF(st - vec2(d, 0.)), r);
        st = st.yx;
        st.y = 1. - st.y;
        color *= 1. - fill(triSDF(st-vec2(0, .02)), .13);
        color += stroke(circleSDF(st), .8, .08);
        break;
    }
    }
    return color;
}

// Function 2598
float linePattern(vec2 p, vec2 a, vec2 b){
  
    // Determine the angle between the vertical 12 o'clock vector and the edge
    // we wish to decorate (put lines on), then rotate "p" by that angle prior
    // to decorating. Simple.
    vec2 v1 = vec2(0, 1);
    vec2 v2 = (b - a);

    if(a.x>b.x) v2.y = -v2.y;

    // Angle between vectors.
    //float ang = acos(dot(v1, v2)/(length(v1)*length(v2))); // In general.
    float ang = acos(v2.y/length(v2)); // Trimed down.
    p = rot2(ang - .2)*p; // Putting the angle slightly past 90 degrees is optional.

    float ln = clamp(cos(p.y*64.*2.)*1. - .5, 0., 1.);

    return ln*.25 + clamp(sin(p.y*64.)*3. + 2.95, 0., 1.)*.75 + .15; // Ridges.
 
}

// Function 2599
float drawcone (vec3 ro, vec3 rd, vec3 cp, vec3 cd, float cl, float ca, float dither)
{
    float radialshapes;
    float increment = 1. / float(iterations);
    float spacing = cl * increment;
    
    for(int x = 0; x < iterations - 1; x++) //radialshapes
    {
        float iter = max( float(x) + (dither * 2. - 1.0) * 1.0, 0.001); // add dithering (hide iteration)
        float localpos = iter * spacing; //distance along forward vector of cone
        vec3 spos = localpos * cd + cp;
        float ssize = ( max((2. * localpos), iter) / tan(ca) ) ; // isosceles base length
    	float shape = 1. - saturate( distline(ro, rd, spos) / ssize );
        shape *= shape;
        shape *= (1. / iter) * (1. / iter);
        radialshapes += shape;
    }
    return radialshapes;
}

// Function 2600
vec2 circleInverse(vec2 pos, vec2 circlePos, float circleR)
{
	return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;
}

// Function 2601
float draweye (vec3 ro, vec3 rd, vec3 cp)
{
    float shape = 1. - saturate(distline(ro, rd, cp) * 125.  );
    return shape * 10.;
}

// Function 2602
vec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }

// Function 2603
float onLineY( const vec2 c, const float y ) {
	return step(y,c.y)*step(c.y,y);
}

// Function 2604
float circle( vec2 p, float r){
 return smoothstep(SS,-SS,length(p)-r);
 return step(length(p)-r,.0);
    return length(p) < r ? 1. : 0.;//why would you do that?
}

// Function 2605
vec3 directLight(vec3 pos, vec3 normal){
    //return vec3(0.);
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 2.5;	//goes 2.5 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 2606
vec3 draw(float d, vec3 col, vec3 ccol, float pwidth) {
  pwidth *= 0.1; //0.25;
  col = mix(ccol,col,mix(1.0,smoothstep(0.5*lwidth,max(pwidth,lwidth),d),kfact));
  //col = mix(ccol,col,mix(1.0,smoothstep(-pwidth,pwidth,d-lwidth),kfact));
  return col;

}

// Function 2607
float line_segment(vec2 p, vec2 a, vec2 b) {
	vec2 ab = b - a, ap = p - a;
    return length(ap - ab * clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0));
}

// Function 2608
float circledistance(vec3 p, vec3 c, vec3 n, float r) {
  p -= c;                            // Move to circle frame
  float d0 = dot(p,n);               // Distance to plane
  float d1 = sqrt(dot(p,p) - d0*d0); // Distance from origin in plane
  d1 -= r;
  return sqrt(d0*d0+d1*d1);
}

// Function 2609
float drawCircle(vec2 center, float radius)
{
    return 1.0 - smoothstep(0.0, radius, length(uv - center));
}

// Function 2610
void drawLandedParatrooper( ivec2 uv, float x, float y, inout vec3 col ) {
    if (x > 0.) {
        drawSprite(uv, ivec2(x-2.,182.-y), ivec2(x+2.,190.-y), ivec2(12,39), iChannel1, false, col);
    }
}

// Function 2611
vec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)
{
    return mix(
        currentCol , 
        colLine ,
        1.0 - smoothstep(0.0,1.0,(sqrt(       max(segment(uv,lineA,lineB).x * scale , .0)     )))
    );
}

// Function 2612
vec4 blur_linear(sampler2D tex, vec2 texel, vec2 uv, vec2 line)
{
    vec4 total = vec4(0);
    
    float dist = 1.0/SAMPLES;
    for(float i = -0.5; i<=0.5; i+=dist)
    {
        vec2 coord = uv+i*line*texel;
        total += texture(tex,coord);
    }
    
    return total * dist;
}

// Function 2613
float fHexagonCircumcircle(vec3 p, vec2 h) {
  vec3 q = abs(p);
  return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);
}

// Function 2614
vec2 iCircle(vec2 o_ro, vec2 rd, vec3 params) {
	vec2 ro = o_ro - params.xy / params.z;
	float k = dot(ro, rd);
    float q = sqrt(k*k - dot(ro, ro) + 1.0);
    vec2 d = (vec2(-q,q) - k) * params.z;
    return (d.x != d.x)?empty_interval:d;
}

// Function 2615
vec3 randomHemisphereDirection(vec3 n,  float seed) {
    vec2 r = 2.*PI*hash22(seed);
    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
    float k = dot(dr,n);
    return k == 0. ? n : normalize(k*dr);
}

// Function 2616
int maxLinear(vec2 res) {
    return int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));
}

// Function 2617
vec2 clipLineB(vec2 a, vec2 b, vec2 size) {
    vec2 d = b - a;

    if (b.x < 0.0)
        b = vec2(0, a.y - a.x * (d.y / d.x));
    else if (b.x > size.x)
        b = vec2(size.x, a.y + (size.x - a.x) * (d.y / d.x));

    if (b.y < 0.0)
        b = vec2(a.x - a.y * (d.x / d.y), 0);
    else if (b.y > size.y)
        b = vec2(a.x + (size.y - a.y) * (d.x / d.y) , size.y);

    return b;
}

// Function 2618
bool ML_InRect(vec2 coord, vec4 rect){
    return rect.x <= coord.x && rect.y <= coord.y 
        && rect.x + rect.z > coord.x && rect.y + rect.w > coord.y;
}

// Function 2619
void drawBackground(out vec4 fragColor){
    fragColor = vec4(vec3(texture(iChannel0, uv/iResolution.xy)), 1.0);
}

// Function 2620
float FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {
    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);
    return saturate(df / abs(dFdy(uv).y));
}

// Function 2621
vec3 draw_circle(vec2 p, float radius, vec3 col, vec3 back)
{
    p = 2.0 * p - vec2(iResolution.x/iResolution.y, 1.0);
    return 	mix(col, back, smoothstep(0.0, 0.01, length(p) - radius)) *
        	smoothstep(0.0, 0.02, abs(length(p) - radius));
        	
}

// Function 2622
vec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )
{
    vec2 off = dir2dis(dir);

    vec2 gpos = pos.xy;

    vec2 p = fragCoord/iResolution.y;
    float eps = 1.0 / iResolution.y;

    vec2 q = p - cell2ndc( gpos );

    float c = max(0.0,sdCircle(q, 0.023));
   
    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );
    float g = mode.x;
    if( mode.z>0.75 )
    {
        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iTime-mode.y)));
    }
    gco = mix( gco, vec3(0.1,0.5,1.0), g );

    // glow
    col += 0.2*gco*exp(-300.0*c*c);

    return col;
}

// Function 2623
vec3 rectangle(vec2 pos, vec2 center, float side, float t)
{
    vec2 p = abs(center - pos);
    vec3 col1 = vec3(ss(-side,(p.x + p.y), side));
    vec3 col2 = vec3(ss(-side, p.x, side) * ss(-side, p.y, side));
    return clamp(mix(col1, col2, t), 0., 1.0);
}

// Function 2624
float Scanline(float x, float offset, float multiplier)
{
	return tanh(sin(x * SINE_SCALE) * multiplier + offset) * 0.5 + 0.5;    
}

// Function 2625
mat4x2 makeMobiusForInversionInCircle(vec3 ic)
{
    mat4x2 ma = mat4x2(vec2(1. / ic.z, 0),
                       vec2(-ic.x / ic.z, ic.y / ic.z),
                       vec2(0, 0),
                       vec2(1, 0));

    mat4x2 mb = mat4x2(vec2(ic.z, 0),
                       vec2(ic.x, ic.y),
                       vec2(0, 0),
                       vec2(1, 0));

    return cMobiusConcat(cMobiusConcat(mb, minv), ma);
}

// Function 2626
vec4 rect(vec2 p, vec2 start, vec2 end, vec4 currColor, vec4 newColor, bool mixColors)
{
	vec2 minPoint, maxPoint;
    
    minPoint.x = min(start.x, end.x);
    minPoint.y = min(start.y, end.y);
    maxPoint.x = max(start.x, end.x);
    maxPoint.y = max(start.y, end.y);
   
    if(p.x > minPoint.x && p.x < maxPoint.x && p.y > minPoint.y && p.y < maxPoint.y) {
        if(mixColors)
        {
        	return currColor + newColor;
        }
    	return newColor;
    }
    return currColor;
}

// Function 2627
float linearRandFBM(vec3 uv)
{
	float c = (linearRand(uv * 1.0) * 32.0 +
			   linearRand(uv * 2.0) * 16.0 + 
			   linearRand(uv * 4.0) * 8.0 + 
			   linearRand(uv * 8.0) * 4.0) / 32.0;
	return c * 0.5 + 0.5;
}

// Function 2628
void DrawBallSprite(vec2 screenCoord, vec2 pos, inout vec4 pixel)
{
  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+20.0 && screenCoord.y >=pos.y && screenCoord.y <=pos.y+20.0)
  {
    vec2 dist = (screenCoord-pos)/iResolution.xy;
    vec2 loc = ballTexture_Adress/iResolution.xy;    
    vec4 c =texture(iChannel3, loc+dist);

    pixel=mix(pixel, c, c.w);
  }
}

// Function 2629
vec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )
{
  colOut = mix(colOut,pColObj ,S2( distObj,0.0));
  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));
  return colOut;
}

// Function 2630
vec3 drawCave(ivec2 coord, GameData gd)
{
    CaveData cd;
    loadCaveData(cd, ivec2(0, 0));

    mat4x3 colors = mat4x3(
        COLOR01(ivec3(-255)),
        cd.cColor0,
        cd.cColor1,
        cd.cColor2
    );

    vec3 backColor = drawCaveBackground(cd.gFlashAlpha);
    vec4 caveColor = drawCaveCells(coord, colors, gd.gFrames.x, gd.gFrames.y, cd.gStripesAlpha, cd.gFade, cd.gCaveState, cd.gCamPos.xy);
    vec4 uiColor = drawUI(coord, colors[3], colors[2], cd.gDiamondsRequired, cd.cDiamondValue, cd.cDiamondBonusValue,
                          cd.gDiamondsHarvested, cd.gCaveState, cd.gTimeLeft, gd.gScore, gd.gLives, gd.gCave, gd.gLevel,
                          gd.gFrames.x, cd.gAuxFrame);

    vec3 col;
    col = lerp(backColor, caveColor.rgb, caveColor.a);
    col = lerp(col, uiColor.rgb, uiColor.a);

    return col;
}

// Function 2631
void draw_sprites(out vec4 fragColor, in vec2 fragCoord) {
    vec2 tile_uv = mod(fragCoord, SPRITE_SIZE) / SPRITE_SIZE;
    ivec2 tile_id = ivec2(fragCoord / SPRITE_SIZE);
    
    vec4 outp = vec4(0.0);
    
    if (tile_id == SPRITE_SHIP) {
        outp = draw_sprite_ship(tile_uv);
    } else if (tile_id == SPRITE_FLAME) {
        outp = draw_sprite_flame(tile_uv);
    } else if (tile_id == SPRITE_START_BOX) {
        outp = draw_sprite_start_box(tile_uv);
    }
    
    fragColor = outp;
}

// Function 2632
vec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)
{
    float width = cMax.x-cMin.x;
    float height = cMax.y-cMin.y;
    vec2 ar = vec2(0.30,1.0);
    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization
    muv = (muv-cMin)/vec2(width,height); //mouse Normalization
    if( withinUnitRect(uv) )
    {
        float t = SLIDER_getValue(uv.x);
		bool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;
		uv.x = fract(uv.x*4.0); //repeat 4x
		uv.y = uv.y/0.75-0.125; //25% margins
        return SLIDER_drawSingle(uv,t,ar,bHighlight);
    }
    return vec4(0);
}

// Function 2633
vec4 squareDraw(vec2 uv)
{
    vec3 gen = vec3(1.0,1.0,1.0);
   	
    float textureSize = iResolution.x*iResolution.y;    
    float onePixel = 1.0/textureSize;
    
    //
    float tl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,-1.0/iResolution.y)).r;
    float tm = NearestTextureSample(uv + vec2(0.0,-1.0/iResolution.y)).r;
    float tr = NearestTextureSample(uv + vec2(1.0/iResolution.x,-1.0/iResolution.y)).r;
    float ml = NearestTextureSample(uv + vec2(-1.0/iResolution.x,0.0)).r;
    float mm = NearestTextureSample(uv + vec2(0.0,0.0)).r;
    float mr = NearestTextureSample(uv + vec2(1.0/iResolution.x,0.0)).r;
    float bl = NearestTextureSample(uv + vec2(-1.0/iResolution.x,1.0/iResolution.y)).r;
    float bm = NearestTextureSample(uv + vec2(0.0,1.0/iResolution.y)).r;
    float br = NearestTextureSample(uv + vec2(1.0/iResolution.x,1.0/iResolution.y)).r;
    float sum = tl + tm + tr + ml + mm + mr + bl + bm + br;
	gen *= clamp(sum,0.0,1.0);
    
    return vec4(gen,1.0);
}

// Function 2634
vec2 circle(float t){
    float x = SCALE * sin(t);
    float y = SCALE * cos(t);
    return vec2(x, y);
}

// Function 2635
bool isInCircle(in vec3 c, in vec2 uv) {
    uv -= c.xy;    
    return length(uv) < c.z;
}

// Function 2636
float DrawArrowhead( vec2 vPos, vec2 vStart, vec2 vDir, float fSize, float fThickness )
{    
    vDir = normalize( vDir );    
    vec2 vPerp = vec2( vDir.y, -vDir.x );
    
    vec2 vEndA = vStart + vDir * fSize + vPerp * fSize * .5;
    vec2 vEndB = vStart + vDir * fSize - vPerp * fSize * .5;
    
    float fArrow = DrawLine( vPos, vStart, vEndA, fThickness );
    fArrow = max( fArrow, DrawLine( vPos, vStart, vEndB, fThickness ) );
    
    return fArrow;
}

// Function 2637
vec3 calculateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material, out vec3 wi, out vec3 f, out float scatteringPdf) {
	
    // Light MIS
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., visibility = 1.;
    scatteringPdf = 0.;
    bool isBlack = false;
    
    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;
    
    isBlack = dot(Li, Li) == 0.;
    
    if (lightPdf > EPSILON && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction.tangent, interaction.binormal, interaction, material) * abs(dot(wi, interaction.normal));
        float weight = 1.;
        
        #ifdef USE_MIS
        	scatteringPdf = bsdfPdf(wi, wo,interaction.tangent, interaction.binormal, interaction, material);
            weight = powerHeuristic(1., lightPdf, 1., scatteringPdf);
        #endif
        
        if( light.type == LIGHT_TYPE_SUN )
            weight = 1.;
            
		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           Ld += Li * f * weight/ lightPdf;
        }
    }
    
    // BSDF MIS
    f = bsdfSample( wi, wo, interaction.tangent, interaction.binormal, scatteringPdf, interaction, material);
    f *= abs(dot(wi, interaction.normal));
	
    #ifdef USE_MIS
        isBlack = dot(f, f) == 0.;
        Li = light.L;

        if (!isBlack && scatteringPdf > EPSILON && light.type != LIGHT_TYPE_SUN) {
            float weight = 1.;

            lightPdf = light_pdf(light, interaction);
            if (lightPdf < EPSILON) return Ld;
            weight = powerHeuristic(1., scatteringPdf, 1., lightPdf);

            Li *= visibilityTest(interaction.point + wi * .01, wi);
            isBlack = dot(Li, Li) == 0.;
        	if (!isBlack) {
            	Ld +=  Li * f * weight / scatteringPdf;
            }
        }
    #endif
    return Ld;
}

// Function 2638
float DirectrixofParabola(float a,float b,float c){return c-((b*b)+1.)*4.*a;}

// Function 2639
vec4 IntersectCircles(vec3 c1, vec3 c2)
{
    // set c1 to the origin
    c2.xy -= c1.xy; 
    float z = dot(c2.xy, c2.xy);
    
    vec3 l = vec3(c1.z*c1.z, c2.z*c2.z, z);
    float a = l.x - l.y + l.z;
    float b = sqrt(dot(l, 2.0*l.zxy-l));
    
    vec2 j1 = a*c2.xy + b*vec2(-c2.y, c2.x);
    vec2 j2 = a*c2.xy - b*vec2(-c2.y, c2.x);
          
    return vec4(c1.xy, c1.xy) + vec4(j1,j2)/(2.0*z);
}

// Function 2640
vec4 DrawData(vec2 p, int data, vec2 origin, vec2 pixelSize, float mirror)
{
	vec4 pixelValue = vec4(0.0);
	int dataCopy = data;
	int cutOff = 0;
	float x = origin.x;
	for (int cutOff = 0; cutOff < 10; cutOff++)
	{
		int color = ExtractBit(dataCopy);
		
		pixelValue += 
			float(Rect(p, vec2(x, origin.y), vec2(x, origin.y) + pixelSize)) *
			DecodePalette(color);
		
		x += mirror * pixelSize.x;
		
		if (dataCopy <= 0)
		{
			return pixelValue;
		}
				  
	}
	return pixelValue;
}

// Function 2641
vec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )
{
   float f = sdLine( p, a, b );
   float g = fwidth(f)*w.y;
   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );
}

// Function 2642
vec2 circleInvert(vec2 pos, vec3 circle){
	return ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;
}

// Function 2643
vec2 bez_linear(vec2 p0, vec2 p1, vec2 p2, float x) {
    vec3 q0 = vec3(p0.x,p1.x,p2.x);
    vec3 q1 = vec3(p0.y,p1.y,p2.y);
    x = b2_linear(q0, q1, x);
    return vec2(b2(q0, x), b2(q1, x));
}

// Function 2644
float sdLine2( vec2 p, vec2 a, vec2 b )
{
	vec2 pa = p-a, ba = b-a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length2( pa - ba*h );
}

// Function 2645
bool LineBoxIntersect( Box box, vec3 vStart, vec3 vEnd )
{
    Box box2 = LineBoundingBox( vStart, vEnd );
    return BoxBoxIntersect( box, box2 );
    
    return false;
}

// Function 2646
float circle2(vec2 uv, vec2 center, float radius, float width, float opening)
{
    vec2 d = uv - center;
    float r = sqrt( dot( d, d ) );
    d = normalize(d);
    if( abs(d.y) > opening )
	    return SMOOTH(r-width*2.0,radius)-SMOOTH(r+width/5.0,radius);
    else
        return 0.0;
}

// Function 2647
float circle(vec2 p, float r) {
	
	if (keyToggle(71)) { p = p/r - 1.; r = p.x*p.y;	} 
	else			     r = length(p)/r - 1.;

	return step(0.,r);
	// return smoothstep(-.03,.03,r);
}

// Function 2648
float draw(vec2 st, vec2 tileXY, vec2 count) {
    // y is bottom to top, but we want to show things from top to bottom. Convert
    int showID = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);
    float color = 0.;
    
    switch (showID) {
    case 0: { // void
        color = 0.;
        break;
    }
    case 1: { // justice
        color = step(0.5, st.x);
        break;
    }
    case 2: { // strength
        color = step(0.5 + cos(st.y * PI) * 0.25, st.x);
        break;
    }
    case 3: { // death
        color = step(0.5, (st.x + st.y) * 0.5);
        break;
    }
    case 4: { // wall
        color = stroke(st.x, 0.5, 0.15);  
        break;
    }
    case 5: { // temperance
        float offset = cos(st.y * PI) * 0.15;
        color = stroke(st.x, .28 + offset, 0.1);
        color += stroke(st.x, .5 + offset, 0.1);
        color += stroke(st.x, .72 + offset, 0.1);
        break;
    }
    case 6: { // branch
        float offset = 0.5 + (st.x - st.y) * 0.5;
        color = stroke(offset, 0.5, 0.1);
        break;
    }
    case 7: { // the hanged man
        float sdf = 0.5 + (st.x - st.y) * 0.5;
        color = stroke(sdf, 0.5, 0.1);
        float sdf_inv = (st.x + st.y) * 0.5;
        color += stroke(sdf_inv, 0.5, 0.1);
        break;
    }
    case 8: { // the high priestess
        color = stroke(circleSDF(st), 0.5, 0.05);
        break;
    }
    case 9: { // the moon
        color = fill(circleSDF(st), 0.65);
        vec2 offset = vec2(0.1, 0.05);
        color -= fill(circleSDF(st - offset), 0.5);
        break;
    }
    case 10: { // the emperor
        float sdf = rectSDF(st, vec2(1.));
        color = stroke(sdf, .5, .125);
        color += fill(sdf, .1);
        break;
    }
    case 11: { // the hierophant
        float rect = rectSDF(st, vec2(1));
        color = fill(rect, .5);
        float cross = crossSDF(st, 1.);
        color *= step(.5, fract(cross * 4.));
        color *= step(1., cross);
        color += fill(cross, .5);
        color += stroke(rect, .65, .05);
        color += stroke(rect, .75, .025);
        break;
    }
    case 12: { // the tower
        float rect = rectSDF(st, vec2(.5, 1.));
        float diag = (st.x + st.y) * .5;
        color = flip(fill(rect, .6), stroke(diag, .5, .01));
        break;
    }
    case 13: { // merge
        vec2 offset = vec2(.15, 0);
        float left = circleSDF(st + offset);
        float right = circleSDF(st - offset);
        color = flip(stroke(left, .5, .05), fill(right, 0.525));
        break;
    }
    case 14: { // hope
        float sdf = vesicaSDF(st, .2);
        color = flip(fill(sdf, .5), step((st.x + st.y) * .5, .5));
        break;
    }
    case 15: { // the temple
        st.y = 1. - st.y;
        vec2 ts = vec2(st.x, .82 - st.y);
        color = fill(triSDF(st), .7);
        color -= fill(triSDF(ts), .36);
        break;
    }
    case 16: { // the summit
        float circle = circleSDF(st - vec2(.0, .1));
        float triangle = triSDF(st + vec2(.0, .1));
        color = stroke(circle, .5, .1);
        color *= step(.55, triangle);
        color += fill(triangle, .45);
        break;
    }
    case 17: { // the diamond
        float sdf = rhombSDF(st);
        color = fill(sdf, .425);
        color += stroke(sdf, .5, .05);
        color += stroke(sdf, .6, .03);
        break;
    }
    case 18: { // the hermit
        color = flip(fill(triSDF(st), .5), fill(rhombSDF(st), .4));    
        break;
    }
    case 19: { // intuition
        st = rotate(st, radians(-25.));
        float sdf = triSDF(st);
        sdf /= triSDF(st + vec2(0., .2));
        color = fill(abs(sdf), .56);
        break;
    }
    case 20: { // the stone
        st = rotate(st, radians(45.));
        color = fill(rectSDF(st, vec2(1.)), .4);
        color *= 1. - stroke(st.x, .5, .02);
        color *= 1. - stroke(st.y, .5, .02);
        break;
    }
    case 21: { // the mountain
        st = rotate(st, radians(-45.));
        float off = .12;
        vec2 s = vec2(1.);
        color = fill(rectSDF(st + off, s), .2);
        color += fill(rectSDF(st - off, s), .2);
        float r = rectSDF(st, s);
        color *= step(.33, r);
        color += fill(r, .3);
        break;
    }
    case 22: { // the shadow
        st = rotate(vec2(st.x, 1. - st.y), radians(45.));
        vec2 s = vec2(1.);
        color += fill(rectSDF(st - .025, s), .4);
        color += fill(rectSDF(st + .025, s), .4);
        color *= step(0.38, rectSDF(st + .025, s));
        break;
    }
    case 23: { // opposite
        st = rotate(st, radians(-45.));
        vec2 s = vec2(1.);
        float o = .05;
        color += flip(
            fill(rectSDF(st - o, s), .4), 
            fill(rectSDF(st + o, s), .4)
        );
        break;
    }
    case 24: { // the oak
        st = rotate(st, radians(45.));
        float r1 = rectSDF(st, vec2(1.));
        float r2 = rectSDF(st + .15, vec2(1.));
        color += stroke(r1, .5, .05);
        color *= step(.325, r2);
        color += stroke(r2, .325, .05) * fill(r1, .525);
        color += stroke(r2, .2, .05);
        break;
    }
    case 25: { // ripples
        st = rotate(st, radians(-45.)) - .08;
        for (int i = 0; i < 4; i++) {
            float r = rectSDF(st, vec2(1.));
            color += stroke(r, .19, .04);
            st += .05;
        }
        break;
    }
    case 26: { // the empress
        float d1 = polySDF(st, 5);
        vec2 ts = vec2(st.x, 1. - st.y);
        float d2 = polySDF(ts, 5);
        color = fill(d1, .75) * fill(fract(d1 * 5.), .5);
        color -= fill(d1, .6) * fill(fract(d2 * 4.9), .45);
        break;
    }
    case 27: { // bundle
        st = st.yx;
        color = stroke(hexSDF(st), .6, .1);
        color += fill(hexSDF(st - vec2(-.06, -.1)), .15);
        color += fill(hexSDF(st - vec2(-.06, .1)), .15);
        color += fill(hexSDF(st - vec2(.11, 0.)), .15);
        break;
    }
    case 28: { // the devil
        color += stroke(circleSDF(st), .8, .05);
        st.y = 1. - st.y;
        float s = starSDF(st.yx, 5, .1);
        color *= step(.7, s);
        color += stroke(s, .4, .1);
        break;
    }
    case 29: { // the sun
        float bg = starSDF(st, 16, .1);
        color += fill(bg, 1.3);
        float l = 0.;
        for (float i = 0.; i < 8.; i++) {
            vec2 xy = rotate(st, QTR_PI * i);
            xy.y -= .3;
            float tri = polySDF(xy, 3);
            color += fill(tri, .3);
            l += stroke(tri, .3, .03);
        }
        color *= 1. - l;
        float c = polySDF(st, 8);
        color -= stroke(c, .15, .04);
        break;
    }
    case 30: { // the star
        color = stroke(raysSDF(st, 8), .5, .15);
        float inner = starSDF(st.xy, 6, .09);
        float outer = starSDF(st.yx, 6, .09);
        color *= step(.7, outer);
        color += fill(outer, .5);
        color -= stroke(inner, .25, .06);
        color += stroke(outer, .6, .05);
        break;
    }
    case 31: { // judgement
        color = flip(
            stroke(raysSDF(st, 28), .5, .2), 
            fill(st.y, .5)
        );
        float rect = rectSDF(st, vec2(1));
        color *= step(.25, rect);
        color += fill(rect, .2);
        break;
    }
    case 32: { // wheel of fortune
        float sdf = polySDF(st.yx, 8);
        color = fill(sdf, .5);
        color *= stroke(raysSDF(st, 8), .5, .2);
        color *= step(.27, sdf);
        color += stroke(sdf, .2, .05);
        color += stroke(sdf, .6, .1);
        break;
    }
    case 33: { // vision
        float v1 = vesicaSDF(st, .5);
        vec2 st2 = st.yx + vec2(.04, .0);
        float v2 = vesicaSDF(st2, .7);
        color = stroke(v2, 1., .05);
        color += fill(v2, 1.) * stroke(circleSDF(st), .3, .05);
        color += fill(raysSDF(st, 50), .2) *
            fill(v1, 1.25) *
            step(1., v2);
        break;
    }
    case 34: { // the lovers
        color = fill(heartSDF(st), .5);
        color -= stroke(polySDF(st, 3), .15, .05);
        break;
    }
    case 35: { // the magician
        st.x = flip(st.x, step(.5, st.y));
        vec2 offset = vec2(.15, .0);
        float left = circleSDF(st + offset);
        float right = circleSDF(st - offset);
        color = stroke(left, .4, .075);
        color = bridge(color, right, .4, .075);
        break;
    }
    case 36: { // the link
        st = st.yx;
        st.x = mix(1. - st.x, st.x, step(.5, st.y));
        vec2 o = vec2(.1, .0);
        vec2 s = vec2(1.);
        float a = radians(45.);
        float l = rectSDF(rotate(st + o, a), s);
        float r = rectSDF(rotate(st - o, -a), s);
        color = stroke(l, .3, .1);
        color = bridge(color, r, .3, .1);
        color += fill(rhombSDF(abs(st.yx - vec2(.0, .5))), .1);
        break;
    }
    case 37: { // holding together
        st.x = mix(1. - st.x, st.x, step(.5, st.y));
        vec2 o = vec2(.05, .0);
        vec2 s = vec2(1.);
        float a = radians(45.);
        float l = rectSDF(rotate(st + o, a), s);
        float r = rectSDF(rotate(st - o, -a), s);
        color = stroke(l, .145, .098);
        color = bridge(color, r, .145, .098);
        break;
    }
    case 38: { // the chariot
        float r1 = rectSDF(st, vec2(1.));
        float r2 = rectSDF(rotate(st, radians(45.)), vec2(1.));
        float inv = step(.5, (st.x + st.y) * .5);
        inv = flip(inv, step(.5, .5 + (st.x - st.y) * .5));
        float w = .075;
        color = stroke(r1, .5, w) + stroke(r2, .5, w);
        float bridges = mix(r1, r2, inv);
        color = bridge(color, bridges, .5, w);
        break;
    }
    case 39: { // the loop
        float inv = step(.5, st.y);
        st = rotate(st, radians(-45.)) - .2;
        st = mix(st, .6 - st, step(.5, inv));
        for (int i = 0; i < 5; i++) {
            float r = rectSDF(st, vec2(1.));
            float s = .25;
            s -= abs(float(i) * .1 - .2);
            color = bridge(color, r, s, .05);
            st += .1;
        }
        break;
    }
    case 40: { // turning point
        st = rotate(st, radians(-60.));
        st.y = flip(st.y, step(.5, st.x));
        st.y += .25;
        float down = polySDF(st, 3);
        st.y = 1.5 - st.y;
        float top = polySDF(st, 3);
        color = stroke(top, .4, .15);
        color = bridge(color, down, .4, .15);
        break;
    }
    case 41: { // trinity
        st.y = 1. - st.y;
        float s = .25;
        float t1 = polySDF(st + vec2(.0, .175), 3);
        float t2 = polySDF(st + vec2(.1, .0), 3);
        float t3 = polySDF(st - vec2(.1, .0), 3);
        color = stroke(t1, s, .08) +
                stroke(t2, s, .08) +
                stroke(t3, s, .08);
        float bridges = mix(
            mix(t1, t2, step(.5, st.y)),
            mix(t3, t2, step(.5, st.y)),
            step(.5, st.x)
        );
        color = bridge(color, bridges, s, .08);
        break;
    }
    case 42: { // the cauldron
        float n = 12.;
        float a = TAU / n;
        for (float i = 0.; i < n; i++) {
            vec2 xy = rotate(st, a * i);
            xy.y -= .189;
            float vsc = vesicaSDF(xy, .3);
            color *= 1. - stroke(vsc, .45, .1) * step(.5, xy.y);
            color += stroke(vsc, .45, .05);
        }
        break;
    }
    case 43: { // the elders
        float n = 3.;
        float a = TAU / n;
        for (float i = 0.; i < n * 2.; i++) {
            vec2 xy = rotate(st, a * i);
            xy.y -= .09;
            float vsc = vesicaSDF(xy, .3);
            color = mix(
                color + stroke(vsc, .5, .1),
                mix(color, bridge(color, vsc, .5, .1), step(xy.x, .5) - step(xy.y, .4)),
                step(3., i)
            );
            
        }
        break;
    }
    case 44: { // the core
        float star = starSDF(st, 8, .063);
        color += fill(star, 1.22);
        float n = 8.;
        float a = TAU / n;
        for (float i = 0.; i < n; i++) {
            vec2 xy = rotate(st, 0.39 + a * i);
            xy = scale(xy, vec2(1., .72));
            xy.y -= .125;
            color *= step(.235, rhombSDF(xy));
        }
        break;
    }
    case 45: { // inner truth
        st -= .5;
        float r = dot(st, st);
        float a = atan(st.y, st.x) / PI;
        vec2 uv = vec2(a, r);
        vec2 grid = vec2(5., log(r) * 20.);
        vec2 uv_i = floor(uv * grid);
        uv.x += .5 * mod(uv_i.y, 2.);
        vec2 uv_f = fract(uv * grid);
        float shape = rhombSDF(uv_f);
        color += fill(shape, .9) * step(.75, 1. - r);
        break;
    }
    case 46: { // the world
        color = fill(flowerSDF(st, 5), .25);
        color -= step(.95, starSDF(rotate(st, 0.628), 5, .1));
        color = clamp(color, 0., 1.);
        float circle = circleSDF(st);
        color -= stroke(circle, .1, .05);
        color += stroke(circle, .8, .07);
        break;
    }
    case 47: { // the fool
        color = step(.5, spiralSDF(st, .13));
        break;
    }
    case 48: { // enlightenment
        color = 1.;
        break;
    }
    case 49: { // elements. Added by me. Approximated
        st = st.yx;
        float d = .15;
        color = fill(circleSDF(st - vec2(cos(TAU / 3.), sin(TAU / 3.)) * d), .3);
        color += fill(circleSDF(st - vec2(cos(TAU / 3. * 2.), sin(TAU / 3. * 2.)) * d), .3);
        color += fill(circleSDF(st - vec2(d, 0.)), .3);
        st = st.yx;
        st.y = 1. - st.y;
        color = flip(color, fill(triSDF(st-vec2(0, .03)), .13));
        color += stroke(circleSDF(st), .8, .08);
        break;
    }
    }
    return color;
}

// Function 2649
void renderLineSeg(vec2 a, vec2 b, vec3 color, float thickness, vec2 pos, inout vec3 fragColor)
{
    stroke(distLineSeg(a, b, pos), color, fragColor, thickness, length(fwidth(pos)));
}

// Function 2650
float line_d(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a, ba = b - a;
    float i = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);
    return length(pa - i*ba);
}

// Function 2651
float onLine(float width, vec2 pos, vec2 nml, float h) {	// for drawline
    width /= 1.*iResolution.y;	// pixels to screen
    
    #ifdef filledLines
    	return abs(distanceToLine(pos, nml, h)) <= width ? 1. : 0.;
    #endif
    
    return max(0., width - abs(distanceToLine(pos, nml, h))) / width;	// re here
}

// Function 2652
float distCircle(vec3 p, float r)
{
    return length(p-normalize(p*vec3(1,1,0))*r);
}

// Function 2653
void LineTo(float2 p)
{
    p=TS(p);
    l=min(l,Draw(CP,p,uv));
    CP=p;
}

// Function 2654
void drawGameFlat( inout vec4 color, vec2 p, AppState s )
{
    // game
	vec2 p0 = p;    
    // float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );
    float cameraAnim = 0.0;
	p0 *= mix( 5.0, 10.0, cameraAnim );		// scale field of view
    p0.x += 0.25;							// fix track centering
    p0.y += mix( 2.0, 8.0, cameraAnim );	// move camera pos
    p0.y += s.playerPos.y;
    
    float playerCellID = floor( s.playerPos.y );
    float sPlayer = length( p0 - s.playerPos ) - 0.25;
           
    vec2 p1 = p0;
    p1.y += 2.0 * s.playerPos.y;
    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );
    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );
       
	// COIN start
    float cellID = floor( p0.y );
    float cellCoinRND = hash11( cellID + g_S.seed );					// skip rnd obstacle every second cell to make room for driving    
    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) );	// gaps in coin placing: 2 gaps, 2 coins
    cellCoinRND = mix( cellCoinRND, -1.0, step (cellID, 5.0 ) );		// head start
    float cellCoinCol = floor( 3.0 * cellCoinRND );
       
    if ( cellCoinRND >= 0.0 )
    {
        if ( cellID > playerCellID )
           	drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID && s.coin0Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
        
        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
       
        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )
            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );
    }    
// COIN end

// OBSTACLE start
    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );		// skip rnd obstacle every second cell to make room for driving
    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );
    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0) );	// head start
    float cellObsCol = floor( 3.0 * cellObsRND );
    
	if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )
    {        
    	float sObstacle = length(
            p0
            -vec2( 0.0, cellID )		// cell pos
            +vec2( 0.5, -0.5 )			// move to cell center
            -vec2( cellObsCol, 0.0 )	// move to column
        ) - 0.25;						// radius of coin
        
    	color.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );
        
        vec2 obstaclePos = -vec2( 0.0, cellID )			// cell pos
            				+vec2( 0.5, -0.5 )			// move to cell center
            				-vec2( cellObsCol, 0.0 );	// move to column

        float distObstaclePlayer = length( obstaclePos + s.playerPos );
        
        if ( distObstaclePlayer < 0.5 ) 
        {
            color.rgb += vec3( 0.5 );
        }
    }
    
    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );

// OBSTACLE end        

}

// Function 2655
float udf_line0(vec2 uv, vec2 vert_A, vec2 vert_B){
    float slope = (vert_B.y - vert_A.y) / (vert_B.x - vert_A.y);
    float standard_form = slope * uv.x - uv.y + vert_A.y - slope * vert_A.x;
    float norm = sqrt(slope * slope + 1.);
    return abs(standard_form / norm);  // This is the (unsigned) distance!
}

// Function 2656
vec4 draw_turnctrl(vec2 p) {
    vec3 col = vec3(0.);
    vec2 pt = vec2(p.x - 0.18 / 2. - 0.18 * 4., (p.y - 0.02));
    float d = SS(0., zv, sdRhombus(pt, vec2(0.06, 0.12)));
    float bxx = sdBox(pt, vec2(0.04, 0.008)) - 0.02;
    float dy = SS(0., zv, bxx);
    float dx = 1.;
    if (dy < 1.)
        dx = 1. - text_end(vec2(pt.x, pt.y)*15. + vec2(01.5, 0.5));
    bool bv = (p.y - 0.02 < 0.);
    float dz = SS(-0.01, 0.02, abs(bxx));
    float anim_t = get_animstate(clamp((g_time - allData.card_select_anim)*2., 0., 1.));
    float anim_t2z = 1. - get_animstate(clamp((g_time - allData.ett)*1.5, 0., 1.));
    float anim_t2za = 1. - get_animstate(clamp((g_time - allData.ett), 0., 1.));
    col = mix(bv ? (allData.player_turn ? green * (1. - anim_t2z) : green * anim_t2z) : (allData.player_turn ? green * anim_t2z : green * (1. - anim_t2z)), vec3(0.), d);
    col = mix(cw2, col, dy);
    col = mix(vec3(0.), col, dx);
    if (allData.player_turn) {
        col = mix(0.5 * (allData.player_hpmp.y > 0. ? cef4a : mix(redw, green, anim_t)) / dz, col, dz);
    } else {
        col = mix(0.5 * (green * anim_t2za) / dz, col, dz);
    }
    d = min(min(min(d + 0.65, dy + 0.4), dz), dx);
    return vec4(clamp(col, vec3(0.), vec3(4.)), min(1., d));
}

// Function 2657
float dfLine(in vec2 p, in vec2 a, in vec2 b){
    vec2 pa = p - a, ba = b - a;
	float h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);	
	return length(pa - ba * h);
}

// Function 2658
vec3 draw(float d, vec3 col, vec3 ccol, float pwidth) {
  col = mix(ccol,col,mix(1.0,smoothstep(-pwidth,pwidth,d-lwidth),kfact));
  return col;
}

// Function 2659
vec4 draw(vec2 pos, float brushSize, vec3 brushColor, vec2 A, vec2 B) {
    float d = dist(pos, A, B);
	float f = smoothstep(brushSize * brushSmooth, brushSize, d);
    if (d > brushSize) {
        return vec4(brushColor, 0.0);
    }
    return vec4(brushColor, 1.0 - f);
}

// Function 2660
vec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){
    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;
	return normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 2661
void circle(float x, float y, float x0, float y0, float r) {
    if (eq((x - x0) * (x - x0) + (y - y0) * (y - y0), 0.0, r)) {
    	brightness = 1.0;
    	saturation = 0.0;        
    } 
}

// Function 2662
vec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 2663
float circle(vec2 uv, vec2 p, float r, float blur){
     float d = length(uv-p);
     float c = smoothstep(r, r-blur, d);
     
     return c;
     
}

// Function 2664
vec3 SplineOrtho(float t)
{
//	return normalize( Spline_EvaluateBinormal(spline.MG,t));
	return normalize(cross(Spline_EvaluateTangent(spline.MG,t),Spline_EvaluateBinormal(spline.MG,t)));
}

// Function 2665
void drawCanon(ivec2 uv, inout vec3 f) {
    vec3 col = spriteCanon(uv - CANON_CENTER);
    if (col.x > 0.) f = col;
}

// Function 2666
vec3 SphericalToCartesianDirection( vec2 spherical )
{
	float theta = spherical.x;
	float phi = spherical.y;
	float sinTheta = sin( theta );

	return vec3( cos( phi ) * sinTheta, sin( phi ) * sinTheta, cos( theta ) );
}

// Function 2667
float Circle(vec2 pos, vec2 uv, float radius) {
	return smoothstep(radius, radius*0.9, length(uv-pos));
}

// Function 2668
float drawI(vec2 uv, vec2 pos, float scale)
{
  uv = (uv - pos)*(1.0/scale);
  return float(isIn(uv.y, -cMax, cMax) && isIn(uv.x, -cthick*0.5,cthick*0.5));
}

// Function 2669
void DrawBlockSprite(vec2 screenCoord, float health, vec2 pos, vec4 tint, inout vec4 pixel)
{
  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+50.0 && screenCoord.y >=pos.y && screenCoord.y <=pos.y+15.0)
  {
    vec2 dist = (screenCoord-pos)/iResolution.xy;

    vec2 loc;
    if (health>2.0)
    {
      loc = blockTexture_Adress/iResolution.xy;
    } else  if (health>1.0)
    {
      loc = blockTexture2_Adress/iResolution.xy;
    } else
    {
      loc = blockTexture3_Adress/iResolution.xy;
    }
    pixel=texture(iChannel3, loc+dist)*tint;
  }
}

// Function 2670
float lineintegralB(vec3 a, vec3 b) 
{
    float len = distance(a, b);
    vec3 dir = (b-a)/len;
    vec3 r = antiderivatives(len,a,dir) - antiderivatives(0.,a,dir);
    return dot(r, vec3(1,.1,.1)); //1,0,0)); //
}

// Function 2671
float drawObject(in vec3 p){
    
    // Wrap conditions:
    // Anything that wraps the domain will work.
    //p = cos(p*6.2831853)*.25 + .25; 
    //p = abs(cos(p*3.14159)*.5);
    //p = fract(p) - .5; 
    //p = abs(fract(p) - .5); 
    
    // Distance metrics:
    // Here are just a few variations. There are way too many to list them all,
    // but you can try combinations with "min," and so forth, to create some
    // interesting combinations.
    
    // Spherical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5;    
    //return dot(p, p)/1.5;
    
    // Octahedral... kind of.
    //p = abs(fract(p)-.5);
    //return dot(p, vec3(.333));
    
    // Triangular.
    //p = fract(p) - .5;
    //p = max(abs(p)*.866025 + p.yzx*.5, -p);
    //return max(max(p.x, p.y), p.z);  

    
    // Cubic.
    p = abs(fract(p) - .5); 
    return max(max(p.x, p.y), p.z);
    
    // Cylindrical. (Square root needs to be factored to "d" in the cellTile function.)
    //p = fract(p) - .5; 
    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));
    
    // Octahedral.
    //p = abs(fract(p) - .5); 
    //p += p.yzx;
    //return max(max(p.x, p.y), p.z)*.5;

    // Hexagonal tube.
    //p = abs(fract(p) - .5); 
    //p = max(p*.866025 + p.yzx*.5, p.yzx);
    //return max(max(p.x, p.y), p.z);
    
    
}

// Function 2672
float rect(vec2 _uv, vec4 _bxy)
{
    vec2 f2 = step(_bxy.xy, _uv) - step(_bxy.zw, _uv);
    
    return f2.x*f2.y;
}

// Function 2673
vec2 circleTriangle2(vec2 pos){
    float circle2 = length(pos * 0.35);
    vec2 ret = smoothLine2(circle2, 1.0, 0.025);
    ret.y += circleTriangle(pos);
    return ret;
}

// Function 2674
bool ML_InRect(vec2 coord, vec4 rect, float len){
    return rect.x <= coord.x && rect.y <= coord.y 
        && rect.x + rect.z * len > coord.x && rect.y + rect.w > coord.y;
}

// Function 2675
vec3 drawB(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)
{
    // B: top.
    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .2), sz);
    
    // B: left side.
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);
    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.2), sz);
    
    // B: right side.
    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);
    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);
    
    // B: center.
    res += square(color, uv, vec2(pos.x +  0., pos.y + 0.), sz);
    
    // B: bottom.
    res += square(color, uv, vec2(pos.x +  0., pos.y + -.2), sz);
    
    return res;
}

// Function 2676
void drawTriangle(Ray ray, inout TraceResult cur_ctxt, Triangle Triangle1)
{
    //float t = INF;
    vec3 t_normal;
    float t_trgl0 = intersectTriangle(ray.pos, ray.dir,
                                  Triangle1.V0, Triangle1.V1, Triangle1.V2,
                                  t_normal);
    if (t_trgl0 < cur_ctxt.t) 
    {
        cur_ctxt.t = t_trgl0;
        //cur_ctxt.color = Triangle1.color;
        ///cur_ctxt.color = 0.5 * t_normal + 0.5;
        cur_ctxt.n = t_normal;
        
        if (randVals.x <  GLASS_R * 8.0) 
        {
            cur_ctxt.materialType = REFLECTION;
        } 
        else 
        { 
            cur_ctxt.materialType = REFRACTION;
            if (cur_ctxt.cur_n == AIR_N) 
            {
                cur_ctxt.prev_n = GLASS_N;
            } 
            else 
            {
                cur_ctxt.prev_n = AIR_N;
            }
        }   
        
        cur_ctxt.materialType = REFRACTION;
    }
}

// Function 2677
float GetDistSqFromLineSegmentToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)
{
	float t = GetPositionAlongLineSegmentNearestToPoint(line_segment_a, line_segment_b, point);

	vec2 to_nearest = point - mix(line_segment_a, line_segment_b, t);

	return dot(to_nearest, to_nearest);
}

// Function 2678
float drawSegment(vec2 A, vec2 B, float r){vec2 g=B-A,h=uv-A;
 float d=length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));
 return smoothstep(r, 0.5*r, d);}

// Function 2679
bool isOnLine(in vec3 l, in vec2 uv, in float width) {
    float c = cos(l.z);
    float s = sin(l.z);

    uv += l.xy;

    vec2 localLine = 
        vec2(
            c * uv.x + s * uv.y,
            -s * uv.x + c * uv.y);

    float d = localLine.x - (l.x);

    return abs(d) < width;
}

// Function 2680
float circle(vec2 coord, vec2 offs)
{
    float reso = 16.0;
    float cw = iResolution.x / reso;

    vec2 p = mod(coord, cw) - cw * 0.5 + offs * cw;

    vec2 p2 = floor(coord / cw) - offs;
    vec2 gr = vec2(0.193, 0.272);
    float tr = iTime * 2.0;
    float ts = tr + dot(p2, gr);

    float sn = sin(tr), cs = cos(tr);
    p = mat2(cs, -sn, sn, cs) * p;

    float s = cw * (0.3 + 0.3 * sin(ts));
    float d = 0;//max(abs(p.x), abs(p.y));

    return max(0.0, 1.0 - abs(s - d));
}

// Function 2681
vec3 draw(vec2 q)
{
    campos = texelFetch(CamState, ivec2(0,0), 0).xyz;
    camdir = texelFetch(CamState, ivec2(1,0), 0).xyz;
    camdir = normalize(camdir);
    mat3 m = cameraMatrix(camdir);
    vec3 rp = campos;
    vec3 rd = normalize(m * vec3(q, 2.));
    float r = raymarch(rp, rd, 256);
    float vl = max(dot(rd, L), 0.);
   if (!(r >= 0.))
        return (
     //   textureLod(Enviro, rd, 0.).rgb
      //  + 
            vec3(mix(.5,1.,pow(vl, 4.))))//exp2(-8. * max(0.,1.-vl))))
       * 1.2*vec3(.85,.9,.95);
    vec3 phit = rp + rd * r;
    return lighting(phit, -rd, r);
}

// Function 2682
float drawASCIILine(vec2 uv, vec2 pos, vec2 sz, istr str)
{
    float res = 0.0;
    float s = sz.x * 0.4; // step between glyphs
    for(int x = 0; x < str.sz; x++)
    {
        res += drawASCIIChar(uv, pos, sz, str.data[x]);
        pos.x += sz.x + s;
    }
    return res;
}

// Function 2683
float circle (vec2 p, float r) {
    return length(p) - r;
}

// Function 2684
float cubic_spline(float x) {
	float m[2];    
    // compute control points
    m[0] = p[1] + (p[2] - p[0]) / 6.0;
    m[1] = p[2] - (p[3] - p[1]) / 6.0;
    
    float rx = (1.0 - x);
    float rxx = rx*rx;
    float xx = x*x;
    
    float t0 = rxx*rx;
    float t1 = 3.0*x*rxx;
    float t2 = 3.0*xx*rx;
    float t3 = xx*x;
    
    return t0 * p[1] + t1 * m[0] + t2 * m[1] + t3 * p[2];
}

// Function 2685
float sdCircle( highp vec2 p, float r )
{
  return length(p) - r;
}

// Function 2686
float sdLine(vec3 p, vec3 a, vec3 b, float r)
{
    vec3 ab = b-a;
    float t = dot(p-a,ab)/dot(ab,ab);
    return length(p-a-ab*clamp(t,0.,1.))-r;
}

// Function 2687
void DrawGame(inout vec3 color, AppState s, vec2 p)
{
    {              
#ifdef DEBUG
        // game
        vec2 p2 = p;
        p2 += vec2(1.5, 0.7);
        p2 *= vec2(7.0, 4.5);
        p2.y += s.playerCell;

        float cellID = floor(p2.y);
        float rndState = step( 0.5, hash11(cellID) );
        if (cellID < CELLS_HEADSTART)
        {
            rndState = CS_EMPTY_LANE;
        }

        float cellState = CS_EMPTY_LANE;
        cellState = mix( cellState, rndState, step(0.5, mod(cellID, 2.0)) );

        // draw obstacles
        if (cellState == CS_RIGHT_LANE)
        {
            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));
            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));
        }

        if (cellState == CS_LEFT_LANE)
        {
            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));
            p3.x += 1.0;
            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));
        }

        // draw player
        if (cellID == s.playerCell)
        {
            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));
            if (s.isLeftLine == CS_LEFT_LANE)
            {
                p3.x += 1.0;
            }
            color = mix(mix(color, vec3(0.0, 1.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.45) ));
        }
#endif
    }
}

// Function 2688
float dspline(vec3 p, arc_spline S) {

    if (S.r == 0.0) {
    
        // spline is the great circle segment connecting p0 & p1
        return max(abs(dot(p, S.w)), -min(dot(p, S.l0), dot(p, S.l1)));
    
    } else {
    
        // spline is one or two arcs 
        
        // ignore either arc segment if the midpoint lies at the corresponding endpoint 
        float d = 1e5;

        if (dot(S.m, S.p0) < 1.0 - EPS) { d = min(d, darc(p, S.c0, S.r, S.l0,  S.w)); }
        if (dot(S.m, S.p1) < 1.0 - EPS) { d = min(d, darc(p, S.c1, S.r, S.l1, -S.w)); }
        
        return d;
                    
    }
    
}

// Function 2689
vec3 DrawGridLine(vec2 uv){
	vec2 _uv = uv-floor(uv);
	float val = 0.;
	const float eps = 0.01;
	if(_uv.x<eps||_uv.y<eps){
		val = 1.;
	}
	return vec3(val,val,val);
}

// Function 2690
float line(vec2 u,vec2 m){
 //return determinant(mat2(u,m));//determinant()==openGL_1.5, bad compatibility.
 return dot(m,perp(u));}

// Function 2691
void calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {
    light.position = normalize(light.position);
    light.attenuation = 1.;
    
    // diffuse
  	float diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));
  	vec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;
  	// specular
  	float specularCoef = getSpecular(
        //light,
        surface,
        light.position,
        diffuseCoef,
        cameraPos
    );
  	vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  

  	light.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);
    light.specular = specular;
}

// Function 2692
vec2 arrow_polar2rect(Arrow arrow){
    return arrow.norm * vec2(cos(arrow.angle), sin(arrow.angle));
}

// Function 2693
void drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.
){v0 f=0.
 ;for(v0 i=0.;i<maxCount;++i
 ){if(i>=s.y)break//bound by number of instantiated UIDots
  ;f=dd(u-bufDrag(i).xy)
  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}
 ;}

// Function 2694
float direction(out vec3 rd)
{
  // Select mapping mode based on input parameter
#ifdef MAP_EQUIRECTANGULAR
  if (map_mode() == MAP_EQUIRECTANGULAR)
  {
    return equirectangular_direction(rd);
  }
#endif
#ifdef MAP_FISHEYE
  if (map_mode() == MAP_FISHEYE)
  {
    return fisheye_direction(rd);
  }
#endif
  return -1.0;
}

// Function 2695
vec3 directLight(vec3 pos, vec3 normal){
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = distanceEstimation(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 2696
vec4 gettrilinear(int n) {
  n = mymod(n,15)+1;
  return vec4(float((n>>0)&1),float((n>>1)&1),float((n>>2)&1),float((n>>3)&1));
}

// Function 2697
void InitRect(out Rect rect)
{
    rect.dirx = rotation_yz(vec3(1, 0, 0), roty*2.0*pi, rotz*2.0*pi);
    rect.diry = rotation_yz(vec3(0, 1, 0), roty*2.0*pi, rotz*2.0*pi);

    rect.center = vec3(0, 6, 32);
    rect.halfx  = 0.5*width;
    rect.halfy  = 0.5*height;

    vec3 rectNormal = cross(rect.dirx, rect.diry);
    rect.plane = vec4(rectNormal, -dot(rectNormal, rect.center));
}

// Function 2698
vec3 SRGBtoLinear(vec3 rgb)
{
	return vec3(SRGBtoLinear(rgb.r), SRGBtoLinear(rgb.g), SRGBtoLinear(rgb.b));
}

// Function 2699
vec4 texture_Bilinear( sampler2D tex, vec2 t )
{
    vec2 res = iChannelResolution[0].xy;
    vec2 p = res*t - 0.5;
    vec2 f = fract(p);
    vec2 i = floor(p);

    return lerp( f.y, lerp( f.x, SAM(0,0), SAM(1,0)),
                      lerp( f.x, SAM(0,1), SAM(1,1)) );
}

// Function 2700
vec4 sampleWithBilinearInterpolation(sampler2D sampler, vec2 samplerSize,
                                     vec2 uv)
{
        vec2 texel = 1.0 / samplerSize;
        vec2 texelPos = samplerSize * uv;

        // we get the position of the texel. Watch out that
        // texels start at the center of a position (hence the 0.5)
        vec2 bottomLeftTexelPos = floor(texelPos - vec2(0.5)) + vec2(0.5);

        vec4 bl = texture(sampler, (bottomLeftTexelPos + vec2(0.0, 0.0)) * texel);
        vec4 br = texture(sampler, (bottomLeftTexelPos + vec2(1.0, 0.0)) * texel);
        vec4 tl = texture(sampler, (bottomLeftTexelPos + vec2(0.0, 1.0)) * texel);
        vec4 tr = texture(sampler, (bottomLeftTexelPos + vec2(1.0, 1.0)) * texel);

        vec2 fractFromBottomLeftTexelPos = texelPos - bottomLeftTexelPos;
        if (fractFromBottomLeftTexelPos.x > 1.0) {
                return vec4(1.0, 0.0, 0.0, 0.0);
        }
        if (fractFromBottomLeftTexelPos.y > 1.0) {
                return vec4(1.0, 0.0, 0.0, 0.0);
        }

        vec4 tA = mix(bl, br, fractFromBottomLeftTexelPos.x);
        vec4 tB = mix(tl, tr, fractFromBottomLeftTexelPos.x);
        return mix(tA, tB, fractFromBottomLeftTexelPos.y);
}

// Function 2701
vec3 OutlineWhyCantIPassASampler(vec2 fragCoord)
{
	vec2 uv = fragCoord.xy / iResolution.xy;
	uv.y = 1.-uv.y;
  	vec4 lines= vec4(0.30, 0.59, 0.11, 1.0);

	lines.rgb = lines.rgb * LINES*1.5;
 
  	float s11 = dot(texture(iChannel1, uv + vec2(-1.0 / iResolution.x, -1.0 / iResolution.y)), lines);   // LEFT
  	float s12 = dot(texture(iChannel1, uv + vec2(0, -1.0 / iResolution.y)), lines);             // MIDDLE
  	float s13 = dot(texture(iChannel1, uv + vec2(1.0 / iResolution.x, -1.0 / iResolution.y)), lines);    // RIGHT
 

  	float s21 = dot(texture(iChannel1, uv + vec2(-1.0 / iResolution.x, 0.0)), lines);                // LEFT
  	// Omit center
  	float s23 = dot(texture(iChannel1, uv + vec2(-1.0 / iResolution.x, 0.0)), lines);                // RIGHT
 
  	float s31 = dot(texture(iChannel1, uv + vec2(-1.0 / iResolution.x, 1.0 / iResolution.y)), lines);    // LEFT
  	float s32 = dot(texture(iChannel1, uv + vec2(0, 1.0 / iResolution.y)), lines);              // MIDDLE
  	float s33 = dot(texture(iChannel1, uv + vec2(1.0 / iResolution.x, 1.0 / iResolution.y)), lines); // RIGHT
 
  	float t1 = s13 + s33 + (2.0 * s23) - s11 - (2.0 * s21) - s31;
  	float t2 = s31 + (2.0 * s32) + s33 - s11 - (2.0 * s12) - s13;
 
  	vec3 col;
 
	if (((t1 * t1) + (t2* t2)) > 0.04) 
	{
  		col = vec3(-1.,-1.,-1.);
  	}
	else
	{
    		col = vec3(0.,0.,0.);
  	}
 
  	return col;
}

// Function 2702
Circle M_getCircleBetweenDiskPoints(Complex p, Complex q)
{
    Real dp = H_sqnorm(p) + 1.0;
    Real dq = H_sqnorm(q) + 1.0;
    Real dpq = 2.0 * (p[0] * q[1] - p[1] * q[0]);
    Complex center = Complex(q[1] * dp - p[1] * dq, -q[0] * dp + p[0] * dq) / dpq;

    return Circle(center, sqrt(H_sqnorm(center) - 1.0));
}

// Function 2703
float line(vec2 p, vec2 p1, vec2 p2) {
	vec2 center = (p1 + p2) * 0.5;
	float len = length(p2 - p1);
	vec2 dir = (p2 - p1) / len;
	vec2 rel_p = p - center;
	float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));
	float dist2 = abs(dot(rel_p, dir)) - 0.5*len;
	return max(dist1, dist2);
}

// Function 2704
float circlePattern(vec2 st, float radius) {
    return  circle(st+vec2(0.,-.5), radius)+
            circle(st+vec2(0.,.5), radius)+
            circle(st+vec2(-.5,0.), radius)+
            circle(st+vec2(.5,0.), radius);
}

// Function 2705
void drawParticles()
{
    // Update
    if (gFrag.pc.w > 0.) {
        gFrag.c.w = gFrag.pc.w * PARTICLE_DECAY;
        gFrag.c.rgb += gFrag.pc.rgb * gFrag.c.w;
    } else {
        // Creation
        float pMapVal;
        if (gFrag.c.w == 0. 
            && length(gFrag.c.rgb) > 1. 
            && (pMapVal = GetSome(gFrag.xy)) > 1.7
        )
            gFrag.c.w = clamp(0., 1., pMapVal);
    }
}

// Function 2706
vec2 circle_ia (vec2 x, vec2 y, vec2 r) {
    return _44(ia_sqrt(_29(ia_pow2(x), ia_pow2(y))), r . x);
}

// Function 2707
vec4 rotateLine(vec4 line, vec2 pivot, float angle)
{
	line -= vec4(pivot,pivot);
    line.zw *= rot(angle);
    line.xy *= rot(angle);
	line += vec4(pivot,pivot);
    return line;
}

// Function 2708
vec3 draw_simple(float f)
{
    f = f * 0.5 + 0.5;
    return f * vec3(25.0/255.0, 161.0/255.0, 245.0/255.0);
}

// Function 2709
float get_distance_along_2d_line_nearest_to_point(
    in vec2 A0,
    in vec2 A,
    in vec2 B0
){
    return dot(B0 - A0, A);
}

// Function 2710
float circle(vec2 coord, vec2 offs)
{
    float reso = 16.0;
    float cw = iResolution.x / reso;

    vec2 p = mod(coord, cw) + offs * cw;
    float d = distance(p, vec2(cw / 2.0));

    vec2 p2 = floor(coord / cw) - offs;
    vec2 gr = vec2(0.443, 0.312);
    float t = iTime * 2.0 + dot(p2, gr);

    float l = cw * (sin(t) + 1.2) * 0.4;
    float lw = 1.5;
    return max(0.0, 1.0 - abs(l - d) / lw);
}

// Function 2711
vec3 linear_to_gamma(vec3 c)
{
	return pow(clamp(c, 0.0, 1.0), vGammaPower);
}

// Function 2712
float d2hline(vec2 p)
{
   float t=max(-1.,min(1.,p.x));
   p.x-=t;
   return length(p);
}

// Function 2713
float fHexagonIncircle(vec3 p,vec2 h){return fHexagonCircumcircle(p,vec2(h.x*0.866,h.y));}

// Function 2714
vec3 drawText2( in vec4 fragColor, in vec2 fragCoord ) {
    float display_width = 1010.;
    float cc = floor(display_width / (g_cw * (1. + g_cwb))); // character count per line
    
    vec2 uv = (fragCoord.xy) / iResolution.xx;
    uv.y = iResolution.y/iResolution.x - uv.y;  // type from top to bottom, left to right   
    uv *= display_width;

    int cs = int(floor(uv.x / (g_cw * (1. + g_cwb))) + cc * floor(uv.y/(g_ch * (1. + g_chb))));

    uv = mod_uv(uv);
    uv.y = g_ch * (1. + g_chb) - uv.y; // paint the character from the bottom left corner
    vec3 ccol = .35 * vec3(.1, .3, .2) * max(smoothstep(3., 0., uv.x), smoothstep(5., 0., uv.y));   
    uv -= vec2(g_cw * g_cwb * .5, g_ch * g_chb * .5);
    
    float tx = 10000.;
    int idx = 0;
    
    NL 
    NL 
    NL 
    NL 
    NL 
    NL 
    SP SP SP SP SP SP SP SP SP SP SP P R E S S SP E N T E R SP T O SP S T A R T
    NL
    vec3 tcol = vec3(1.0, 0.7, 0.0) * smoothstep(.2, .0, tx);
    
    vec3 terminal_color = tcol;
    
    return terminal_color;
}

// Function 2715
void CircleInversion(inout vec2 z)
{
	z.x = -z.x;
	z /= dot(z,z);
}

// Function 2716
vec4 drawNearClouds(in float x, in float y)
{
    if(y > WAVES_Y) return TRANS;
    else if(y < FAR_CLOUD_Y) return TRANS;
    else if(x < CLOUD_A_X) return TRANS;
    else
    {
        // The usual broken-apart additive blending.
        vec4 result = nearCloudsPalette(cloudA(x,y));
        result += nearCloudsPalette(cloudB(x,y));
        result += nearCloudsPalette(cloudC(x,y));
        result += nearCloudsPalette(cloudD(x,y));
        result += nearCloudsPalette(cloudE(x,y));
        result += nearCloudsPalette(cloudF(x,y));
        result += nearCloudsPalette(cloudG(x,y));
        result += nearCloudsPalette(cloudH(x,y));
        result += nearCloudsPalette(cloudI(x,y));
        result += nearCloudsPalette(cloudJ(x,y));
        result += nearCloudsPalette(cloudK(x,y));
        result += nearCloudsPalette(cloudL(x,y));
        result += nearCloudsPalette(cloudM(x,y));
        result += nearCloudsPalette(cloudN(x,y));
		return result;
    }
}

// Function 2717
vec4 drawCellVoid(float stripesAlpha, mat4x3 colors, ivec2 coord, int animFrame)
{
    vec4 res = vec4(0.0);

    if (stripesAlpha > 0.0)
    {
        coord /= PIX_ASP;
        if (((coord.y + 1) % 4) == 0)
        {
            animFrame = animFrame % 100;
            float r = rand21(vec2(coord + ivec2(animFrame, -animFrame)));
            int colorIndex = int(r * 4.0);
            vec3 color = colors[min(colorIndex, 3)];
            return vec4(saturate(color), step(-0.5, color.r));
        }
    }

    return res;
}

// Function 2718
float circle_sdf(vec2 xy, float radius)
{
    return length(xy) - radius;
}

// Function 2719
void drawThumbnail(out vec4 fragColor, in vec2 fragCoord)
{
    // 3rd order 2D polynomial.

    vec3 c0  = vec3(  0.94,  0.70,  0.43);
    vec3 c1  = vec3(  0.41,  0.52, -0.06);
    vec3 c2  = vec3( -1.39, -0.94,  2.21);
    vec3 c3  = vec3(  0.78,  0.51, -1.62);
    vec3 c4  = vec3( -0.75, -0.96, -0.79);
    vec3 c5  = vec3(  6.46, 10.74,  1.49);
    vec3 c6  = vec3(-11.55,-21.27, -0.07);
    vec3 c7  = vec3(  5.77, 11.48, -0.64);
    vec3 c8  = vec3(  1.14,  1.16,  3.35);
    vec3 c9  = vec3(-11.94,-22.10,-14.41);
    vec3 c10 = vec3( 23.46, 48.26, 21.20);
    vec3 c11 = vec3(-12.36,-27.09,-10.25);
    vec3 c12 = vec3( -0.70, -0.62, -2.90);
    vec3 c13 = vec3(  5.93, 12.16, 14.62);
    vec3 c14 = vec3(-11.05,-26.58,-24.21);
    vec3 c15 = vec3(  5.60, 14.77, 12.52);

    vec2  t = floor(fragCoord / 12.0) * 12.0 / iResolution.xy;
    float x = t.x;
    float y = 1.0 - t.y;

    vec3 f = vec3(
           ( c0 + ( c1 + ( c2 +  c3*x)*x)*x) +
        y*(( c4 + ( c5 + ( c6 +  c7*x)*x)*x) +
        y*(( c8 + ( c9 + (c10 + c11*x)*x)*x) +
        y*( c12 + (c13 + (c14 + c15*x)*x)*x))));

    vec3 clr = smoothstep(0.0, 1.0, f*f*f*f);

    // Playback triangle.

    vec2 tc = fragCoord / iResolution.xy;
    vec2 p = 1.5 * (tc - 0.5) * vec2(1.0, iResolution.y / iResolution.x);
    float d = length( p );

    clr = mix(clr, vec3(0), 0.6 * clamp(23.0 - 128.0 * d, 0.0, 1.0));
    clr = mix(clr, vec3(1), clamp(3.0 - 128.0 * abs(0.5 - d * 3.0), 0.0, 1.0));

    p *= 1.5;
    p += vec2(0.06, 0);

    float m = dot(p, vec2(2.0, 0.0));
    m = min(m, dot(p + vec2(0.0, 0.15), vec2(-0.8, 1.0)));
    m = min(m, dot(p + vec2(0.0,-0.15), vec2(-0.8,-1.0)));
    m = max(m, 0.0);

    fragColor.rgb = mix(clr, vec3(1.0), vec3(m * 200.0));
}

// Function 2720
maybe_float get_distance_along_3d_line_nearest_to_ray(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B
){
    vec3 D = B0 - A0;
    // offset
    vec3 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 2721
float line(vec2 a, vec2 b, vec2 p) {
    vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);
    vec2 v =  pa - ba*h ;
    return length(v);
}

// Function 2722
vec3 rect(vec2 st) {
    vec2 f = max(abs(st) - .1, 0.);
	float c = length(f);
	c = smoothstep(.1, .101, c);
    
    return vec3(1.0 - c);
}

// Function 2723
void drawLine( vec2 coords, vec2 p0, vec2 p1, float thickness )
{
    float sD = segmentDistance(coords, p0, p1);
	float a = 1.0 - clamp(sD - thickness / 2.0 + .5, 0.0, 1.0);
    
    outputColor = mix(outputColor, color, a * color.a);
}

// Function 2724
vec3 isolines(in vec3 ro, in vec3 rd, in int k, in vec3 baseColor) {

    // f(x,y,z) is represented as a coefficient matrix and is formed by the
    // difference between two functions (two parameter vectors, the SVM weights)
    // The solutions to f(x,y,z) == 0 form a plane (the decision boundary)
    // that we want to draw. This plane can be parameterized by solving for z
    // and forming the coefficent matrix for a funtion h(x,y). We perform
    // this process of finding the null set twice, for some f0(x,y,z) and
    // f1(x,y,z), to obtain h0(x,y) and h1(x,y). The space of solutions to
    // h0(x,y) - h1(x,y) == 0 forms a line which can be parameterized by
    // solving for y and forming the function g(x). Given this function g(x)
    // we can perform antialiasing on the seams where two planes intersect.

    // AntiAlias the seams where two planes intersect, i.e where two decision boundaries meet.
    // The goal is to find two points on this seam. A line is constructed from these points.
    // The minimum distance between the primary rays intersecting point Q and
    // the line is found and used for color mixing.
    float dist_to_seam = 1e10;
    vec4 f0;
    vec4 f1;
    vec3 g;
    vec3 z0;
    vec3 z1;
    int idOfPlane;
    float s;
    float t;
    vec3 Q;
    vec2 line;
    vec3 lineP0;
    vec3 lineP1;
    vec3 lineDir;
    // We've already found the max class decision boundary during ray tracing.
    Q = ro+rd*intersections[k].t;
    f0 = Weights[intersections[k].ids.x]-Weights[intersections[k].ids.y];
    // A point on the z0 plane is then vec3(s, t, dot(z0, vec3(s,t,1.)))
    z0 = -vec3(f0.x,f0.y,f0.w)/f0.z;
    for (int i = 0; i < numberOfClasses; ++i) {
        //TODO project into screen plane and then take distances in order to smooth out the pixel mixing gradients?

        if (i == intersections[k].ids.y)
            continue;

        f1 = Weights[intersections[k].ids.x] - Weights[i];

        // Coefficients for equation of plane
        z1 = -vec3(f1.x,f1.y,f1.w)/f1.z;

        g = z0-z1;

        // A point on the line is vec2(s, dot(line, vec2(s, 1.)))
        line = -vec2(g.x,g.z)/g.y;

        s = 0.;
        t = dot(line, vec2(s, 1.));
        lineP0 = vec3(s, t, dot(z0, vec3(s, t, 1.)));

        s = 1.;
        t = dot(line, vec2(s, 1.));
        lineP1 = vec3(s, t, dot(z0, vec3(s, t, 1.)));

        lineDir = normalize(lineP1-lineP0);

        // Point on line such that point-Q is orthogonal to line
        lineP1 = lineP0+lineDir*dot(lineDir, Q-lineP0);
        float D = length(Q-lineP1);
        if (D < dist_to_seam) {
            dist_to_seam = D;
            idOfPlane = i;
        }
    }

    vec3 colToLerp = getPlaneColor(ro, rd, intersections[k].t, intersections[k].ids.x, idOfPlane);
    #ifdef COLORFUL_ISOLINES
    // return mix(baseColor, colToLerp, .5-.5*smoothstep(0., 20./resolution.x, dist_to_seam));
    return mix(baseColor, colToLerp, .5-.5*smoothstep(0., .022, dist_to_seam));
    #else
    // return mix(baseColor, vec3(0.), .5-.5*smoothstep(0., 20./resolution.x, dist_to_seam));
    return mix(baseColor, .2*colToLerp, .5-.5*smoothstep(0., .027, dist_to_seam));
    #endif
}

// Function 2725
float CircleOfConfusion(float t)
{
	return max(t * .04, (2.0 / iResolution.y) * (1.0+t));
}

// Function 2726
bool drawCircle(inout float v,vec2 uv, vec2 pt, vec2 ofs, float r, int mode)
{
	// vec2 newUV = vec2(.8,.5)+.5*pt - uv;
	vec2 newUV = .5*pt - uv;
		
	float d = length(newUV)/r;
	if (FLOW) 
		if (d<1.) { v = hash2(newUV-ofs); return true; }
	    else        return false;

    if (mode==1)
	  {  if (d<1.) { v = 1.-v; return true; } }
	else
	  {  if (d<1.) { v = fract(v+sin(4.*d*2.*Pi)); return true; } }
	return false;
}

// Function 2727
float halftoneLines(vec2 uv, float rows, float curThickness, float curRotation, float invert) {
    // get original coordinate, translate & rotate
    uv = rotateCoord(uv, curRotation);
    // create grid coords
    vec2 uvRepeat = fract(uv * rows);		
    // adaptive antialiasing, draw, invert
    float aa = iResolution.y * 0.0003; 	
    float col = smoothstep(curThickness - aa, curThickness + aa, length(uvRepeat.y - 0.5));
    if(invert == 1.) col = 1. - col;			
   	return col;
}

// Function 2728
vec3 randomHemisphereDirection(vec3 n,  float seed) {
    vec2 r = 2.*PI*hash2(seed);
    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
    float k = dot(dr,n);
    return k == 0. ? n : normalize(k*dr);
}

// Function 2729
vec3 DrawScene(vec2 fragCoord)
{
    float y = dot(fragCoord.y / iResolution.y, 1.);
    vec2 uv = (fragCoord - 1. * iResolution.xy) / iResolution.y;
    float bgBlend = smoothstep(0.4, 0.8, y);
    vec2 bgUV = uv * vec2(3.9, 1.15) + vec2(0.5, 0) * iTime * 0.25;
    bgBlend *= Voronoi(bgUV);
    vec3 col = mix(BGLOWER, BGUPPER, saturate(bgBlend));
    
    float stars = Stars(uv, iTime, 75.0);
    LerpWhiteTo(col, STAR_COLOR * 6., saturate(stars));
    
    float moon = Moon(uv);
    moon = 1. - aastep(0.001, moon);
    LerpWhiteTo(col, MOON_COLOR, moon);
    
    vec3 bColor;
    float bd = Buildings(uv, bColor);
    LerpWhiteTo(col, bColor, saturate(1. - sign(bd)));
    
    float overlay = smoothstep(.6, -0.1, y);
    LerpWhiteTo(col, OVERLAY_COLOR, overlay);
    
    vec3 wColor;
    float waterDist = Water(uv, wColor);
    LerpWhiteTo(col, wColor, saturate(1. - sign(waterDist)));
    
    vec4 bubbles = Bubbles(uv);
    LerpWhiteTo(col, bubbles.rgb * 4., saturate(bubbles.a));
    return col;
}

// Function 2730
float DiagLine( vec2 a, vec2 b, vec2 p )
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp((pa.x * ba.x) / (ba.x * ba.x), gSegmentGap * 2.0, 1.0 - (gSegmentGap * 2.0));
    vec2 intersectP = abs(pa - ba * t);
    return smoothstep(gSegmentWidth * 2.0, gSegmentWidth * 1.25, intersectP.y) * smoothstep(0.001, 0.0, intersectP.x);
}

// Function 2731
v2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo
){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}

// Function 2732
float drawObject(in vec3 p){
  
    p = fract(p)-.2;
    return dot(p, p);
    
}

// Function 2733
float line(vec3 p, vec3 l) {
  return abs(dot(p,l)/(p.z*length(l.xy)));
}

// Function 2734
float hline_d(vec2 uv, float lineposy, float lineWidth)
{
	return distance(uv.y, lineposy) - (lineWidth / 2.0);
}

// Function 2735
float LineDist(float ax,float ay, float bx,float by, vec2 p) {
    return LineDist(vec2(ax, ay), vec2(bx, by), p);
}

// Function 2736
float sdLine( in vec2 p, in vec2 a, in vec2 b, in float ring )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h ) - ring;
}

// Function 2737
float draw_grav_w(vec2 uv, vec2 im){
    vec2  arrow_uv = uv;
    float arrow_norm =clamp(length(im),0.05,1.); 
    float arrow_angle = angle2d(vec2(0.),im);
    float arrow_head_height = .1;  
    float arrow_stem_width = .04; 
    float arrow_aa = (4. * 1. / iResolution.y)*7.5;
    float arrow=0.;
    arrow = sdf_arrow(arrow_uv, arrow_norm, arrow_angle, arrow_head_height, arrow_stem_width);
    arrow = smoothstep(arrow_aa, 0., arrow);

    return arrow;
}

// Function 2738
vec4 renderHSplitLine(vec4 fragColor, vec2 screenSpaceUV, float splitScreenSpaceY) {
    if (abs(screenSpaceUV.y - splitScreenSpaceY) < SPLIT_LINE_THICKNESS) {
        return floatToColor(getShaderToyBackgroundGray(screenSpaceUV));
	}

    return fragColor;
}

// Function 2739
void drawHorzRect(float yCoord, float minY, float maxY, vec4 color)
{
	if ((yCoord >= minY) && (yCoord < maxY)) {
		fragColor = color;		
	}
}

// Function 2740
void DrawScene(inout vec3 color, vec2 p, in AppState s)
{
	vec3 lightColor = vec3(2.);
	vec3 lightDir = normalize(vec3(.7, .9, -.2));

	vec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));
	vec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;
	vec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);
	float roughnessE = s.roughness * s.roughness;
	float roughnessL = max(.01, roughnessE);

	float a = -iTime * .5;
	mat3 rot = mat3(
		vec3(cos(a), 0., -sin(a)),
		vec3(0., 1., 0.),
		vec3(sin(a), 0., cos(a))
	);

	p -= vec2(-20., 10.);
	p *= .011;

	float yaw = 2.7 - s.objRot;
	mat3 rotZ = mat3(
		vec3(cos(yaw), 0.0, -sin(yaw)),
		vec3(0.0, 1.0, 0.0),
		vec3(sin(yaw), 0.0, cos(yaw))
	);

	float phi = -0.1;
	mat3 rotY = mat3(
		vec3(1.0, 0.0, 0.0),
		vec3(0.0, cos(phi), sin(phi)),
		vec3(0.0, -sin(phi), cos(phi))
	);

	mat3 localToWorld = rotY * rotZ;

	vec3 rayOrigin = vec3(0.0, .5, -3.5);
	vec3 rayDir = normalize(vec3(p.x, p.y, 2.0));
	float t = CastRay(rayOrigin, rayDir, localToWorld);
	if (t > 0.0)
	{
		vec3 pos = rayOrigin + t * rayDir;
		vec3 normal = SceneNormal(pos, localToWorld);
		vec3 viewDir = -rayDir;
		vec3 refl = reflect(rayDir, normal);

		vec3 diffuse = vec3(0.);
		vec3 specular = vec3(0.);

		vec3 halfVec = normalize(viewDir + lightDir);
		float vdoth = saturate(dot(viewDir, halfVec));
		float ndoth = saturate(dot(normal, halfVec));
		float ndotv = saturate(dot(normal, viewDir));
		float ndotl = saturate(dot(normal, lightDir));
		vec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);

		vec3 env1 = EnvRemap(texture(iChannel2, refl).xyz);
		vec3 env2 = EnvRemap(texture(iChannel1, refl).xyz);
		vec3 env3 = EnvRemap(SHIrradiance(refl));
		vec3 env = mix(env1, env2, saturate(roughnessE * 4.));
		env = mix(env, env3, saturate((roughnessE - 0.25) / 0.75));

		diffuse += diffuseColor * EnvRemap(SHIrradiance(normal));
		specular += envSpecularColor * env;

		diffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));

		vec3 lightF = FresnelTerm(specularColor, vdoth);
		float lightD = DistributionTerm(roughnessL, ndoth);
		float lightV = VisibilityTerm(roughnessL, ndotv, ndotl);
		specular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);

		float ao = SceneAO(pos, normal, localToWorld);
		diffuse *= ao;
		specular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);

		color = diffuse + specular;
		if (s.menuId == MENU_DIFFUSE)
		{
			color = diffuse;
		}
		if (s.menuId == MENU_SPECULAR)
		{
			color = specular;
		}
		if (s.menuId == MENU_DISTR)
		{
			color = vec3(lightD);
		}
		if (s.menuId == MENU_FRESNEL)
		{
			color = envSpecularColor;
		}
		if (s.menuId == MENU_GEOMETRY)
		{
			color = vec3(lightV) * (4.0f * ndotv * ndotl);
		}
		color = pow(color * .4, vec3(1. / 2.2));
	}
	else
	{
		// shadow
		float planeT = -(rayOrigin.y + 1.2) / rayDir.y;
		if (planeT > 0.0)
		{
			vec3 p = rayOrigin + planeT * rayDir;

			float radius = .7;
			color *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));
		}
	}
}

// Function 2741
bool UI_DrawWindowMinimizeWidget( inout UIContext uiContext, bool bMinimized, Rect minimizeBoxRect )
{
	if (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, minimizeBoxRect ))
        return false;
    
    vec2 vArrowPos = minimizeBoxRect.vPos + minimizeBoxRect.vSize * 0.5;        
    vec2 vArrowSize = minimizeBoxRect.vSize * 0.25;
    vec4 arrowColor = vec4(0.0, 0.0, 0.0, 1.0);
    if ( !bMinimized )
    {
        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2(-1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 1.0, -0.5) * vArrowSize, vArrowPos + vec2(0.0, 0.5) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );
    }
    else
    {
        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5, -1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, vArrowPos + vec2( 0.5, 0.0 )* vArrowSize, vArrowPos + vec2(-0.5,  1.0) * vArrowSize, 2.0f, arrowColor, uiContext.vWindowOutColor );
    }    
    
    return true;
}

// Function 2742
vec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {
    return (line1y - line2y) / (line2x - line1x);
}

// Function 2743
void drawSprite(const ivec2 uv, const ivec2 lt, const ivec2 rb, const ivec2 offset, const in sampler2D d, const bool flip, inout vec3 f) {
    if (inBox(uv, lt, rb)) {
        ivec2 c = uv - lt;
    	c.x = flip ? (rb.x-lt.x)-c.x-1 : c.x;
    
        vec3 col = texelFetch(d, offset + c, 0).rgb;    
        f = col.r > 0. ? col : f;
    }
}

// Function 2744
vec3 draw_quad(vec2 uv, vec2 c, mat4 iT)
{
    vec2 v1 = c + vec2(-0.5, -0.5);
    vec2 v2 = c + vec2(0.5, -0.5);
    vec2 v3 = c + vec2(-0.5, 0.5);
    vec2 v4 = c + vec2(0.5, 0.5);
    
    vec4 t1 = iT * vec4(vec3(v1, map(v1)).xzy, 1.0);
    vec4 t2 = iT * vec4(vec3(v2, map(v2)).xzy, 1.0);
    vec4 t3 = iT * vec4(vec3(v3, map(v3)).xzy, 1.0);
    vec4 t4 = iT * vec4(vec3(v4, map(v4)).xzy, 1.0);
    
    t1.xy /= t1.z;
    t2.xy /= t2.z;
    t3.xy /= t3.z;
    t4.xy /= t4.z;

    vec3 col = color(vec2(0.4, map(v1) * 0.0000002));

    vec3 r = vec3(0.0);

    r += segment(uv, t1.xy, t2.xy) * col;
    r += segment(uv, t1.xy, t3.xy) * col;
    r += segment(uv, t1.xy, t4.xy) * col;
    r += segment(uv, t3.xy, t4.xy) * col;
    r += segment(uv, t2.xy, t4.xy) * col;
    
	return r;
}

// Function 2745
vec4 drawBirds(in float x, in float y)
{
    // Since birds never cross we can use additive blending.
    // And as we've learned from the sound let's divvy up addition.
	
	// Getting the positioning and timing accurate to the actual game
	// was not fun. Frame-counting and screen-shooting dominated an
	// evening of mine. Should have bit the bullet and looked at a
	// disassembly.
	// Each bird's flight path lasts 128 frames each way. However
	// those path start times differ, as well as the length of the path.
    
    bool f; // For directional awareness.
	
	// Bird 1.
    float a = anim(110., iTime, 32.0, f);
    vec4 result = drawBird(x,y,a,BIRD_A_Y,f);
	
    #ifdef DRAW_ALL_BIRDS
	// Bird 2.
    a = anim(140., iTime+3.267, 24.0, f);
    result += drawBird(x,y,a,BIRD_B_Y,f);
	
	// Bird 3.
    a = anim(77., iTime+1.533, 40.0, f);
    result += drawBird(x,y,a,BIRD_C_Y,f);
	
	// Bird 4.
    a = anim(198., iTime+.1667, 32.0, f);
    result += drawBird(x,y,a,BIRD_D_Y,f);
	
	// Bird 5.
    a = anim(141., iTime+.5667, 32.0, f);
    result += drawBird(x,y,a,BIRD_E_Y,f);
	
	// Bird 6.
    a = anim(85., iTime+1.067, 24.0, f);
    result += drawBird(x,y,a,BIRD_F_Y,f);
	#endif
    
	// Bird 7.
    a = anim(165., iTime+1.167, 24.0, f);
    result += drawBird(x,y,a,BIRD_G_Y,f);
    return result;
    
}

// Function 2746
F3 Linear3(F3 c){return vec3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}

// Function 2747
float line(vec4 ray, vec3 pos, float size)
{
    maxGISize = max(maxGISize,size*ray.w);
    
    ray.xyz = abs(ray.xyz-pos) - size;
    return ray.w*max(ray.z,ray.y);
}

// Function 2748
float lineintegral(vec3 a, vec3 b) 
{
    float len = distance(a, b);
    vec3 dir = (b-a)/len;
    vec3 r = antiderivatives(len,a,dir) - antiderivatives(0.,a,dir);
    return dot(r, vec3(1));
}

// Function 2749
vec2 LineISect(vec2 a,vec2 b,vec2 u,vec2 d  //rayOrigin,RayTarget
){b=vec2(b.y-a.y,a.x-b.x);a.x=dot(b,a);d=vec2(d.y-u.y,u.x-d.x);u=vec2(dot(d,u),det2d(b,d))
 ;if(u.y==0.)return vec2(0);b*=u.x;d*=a.x;return vec2(d.y-b.y,b.x-d.x)/u.y;}

// Function 2750
vec3 drawFlare(vec2 uv, float radius, vec3 rgb)
{
    float coef = 1.-sat(length(uv) / radius);
    vec3 col = vec3(coef);
    return col * rgb;
}

// Function 2751
float line(vec2 uv,vec2 ori,vec2 dir)
{
    vec2 sp=uv-ori;
    return SL(length(uv-dot(sp,dir)*dir+ori));
}

// Function 2752
float scene_obj_runway_centerline( mat2 K, vec2 uv, vec2 size )
{
    float l = floor( size.x / 60. - 1.5 ) * 60.;
    return aaa_stipple( Linfinity( K[0] ), uv.x, 60., .5 ) *
        aaa_box( K, uv, vec2( l, .7 ), vec2( 0 ) );
}

// Function 2753
vec4 drawTiledSprite(vec2 uv) {
    float time = mod(iTime, 3.);
    vec4 tex = vec4(0);
    float nbTiles = 6.;
    float tileOffset = .3 * smoothstep(.5, .0 , abs(time - 1.5) - .5);
    float tileCoef  = 1. + tileOffset;
    
    uv -= .5;
    uv *= nbTiles;
    uv /= tileCoef;
    vec2 fuv = fract(uv) * tileCoef;
    fuv -= tileOffset / 2. + .5;
    fuv *= rot(2. * Pi * smoothstep(.7, 2.3, time));
    fuv += tileOffset + .5;;
    vec2 p = floor(uv) + fuv - tileOffset;
    p /= nbTiles;
    p += .5;
    
    // clamp the texture to interval [0, 1]
    if(all(greaterThan(step(abs(p - .5), vec2(.5)), vec2(.5))))
    	tex = texture(iChannel0, vec2(p.x / 6.6, p.y));
    
    // tile mask with antialiasing
    vec2 mask = smoothstep(.0, .005 * nbTiles, fuv - tileOffset);
    mask *= smoothstep(.0, .005 * nbTiles, tileCoef - fuv);
    tex *= mask.x * mask.y;

    return tex;
}

// Function 2754
float iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph)
{
    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);
    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);
    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);
    vec3 vd = vec3(ps.xy, ph.x);

    float tmp = 1.0 / (vb.y * vc.x);
    float a = 0.0;
    float b = 0.0;
    float c = 0.0;
    float d = va.z * tmp;
    float e = 0.0;
    float f = 0.0;
    float g = (vc.z * vb.y - vd.y * va.z) * tmp;
    float h = (vb.z * vc.x - va.z * vd.x) * tmp;
    float i = -1.0;
    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp
            - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;

    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy)
            + dot(vec3(d, e, f), rd.xzy * rd.zyx);
    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c))
            + dot(ro.xzz * rd.zxy, vec3(d, d, e))
            + dot(ro.yyx * rd.zxy, vec3(e, f, f))
            + dot(vec3(g, h, i), rd.xzy);
    float r = dot(vec3(a, b, c), ro.xzy * ro.xzy)
            + dot(vec3(d, e, f), ro.xzy * ro.zyx)
            + dot(vec3(g, h, i), ro.xzy) + j;
    if (abs(p) < 0.000001) {
      return -r / q;
    } else {
      float sq = q * q - 4.0 * p * r;
      if (sq < 0.0) {
        return 0.0;
      } else {
        float s = sqrt(sq);
        float t0 = (-q + s) / (2.0 * p);
        float t1 = (-q - s) / (2.0 * p);
        return min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);
      }
    }
}

// Function 2755
float hsluv_fromLinear(float c) {
    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;
}

// Function 2756
float toLinear1(float c)
{
    return (c <= 0.04045) ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);
}

// Function 2757
float srgb_to_linear(float channel) {
    if (channel <= 0.04045)
        return channel / 12.92;
    else
        return pow((channel + SRGB_ALPHA) / (1.0 + SRGB_ALPHA), 2.4);
}

// Function 2758
vec4 Line4(const vec4 y, const vec4 repeat, const vec4 thickness, const vec4 smoothness)
{
    return smoothstep(thickness * (1.0 - smoothness), thickness, abs(repeat * 0.5 - mod(y, repeat)));
}

// Function 2759
float SDFCircle( in vec2 coords, in vec3 offsetRadius )
{
    coords -= offsetRadius.xy;
    float v = coords.x * coords.x + coords.y * coords.y - offsetRadius.z;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return abs(v)/length(g); 
}

// Function 2760
vec3 linearDodge(in vec3 src, in vec3 dst)
{
    return clamp(src.xyz + dst.xyz, 0.0, 1.0);
}

// Function 2761
float getrectmix (vec2 uv, vec2 sz)
{
    float val = 0.0;
    vec2 rectsz = (vec2(0.5) - sz * 0.5);
    vec2 rect = step(rectsz, uv);
    val = rect.x * rect.y;
    
    rect = step(rectsz, vec2(1.0) - uv);
    val *= rect.x * rect.y;
    return val;
}

// Function 2762
vec3 linearToneMapping(vec3 color)
{
	float exposure = 1.;
	color = clamp(exposure * color, 0., 1.);
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 2763
vec3 linearToScreen(vec3 linearRGB)
{
    return (iMouse.z < 0.5) ? encodeSRGB(linearRGB) : gamma(linearRGB, 1.0 / GAMMA);
}

// Function 2764
vec4 Circle(in vec2 c,in float r, in vec2 uv)
{
  float L=length(uv-c);
 
  // Dans le cercle si distance < rayon
  if (L<r)
  {  
      //chaque couleur varie en fonction de la distance au centre L
      //et en fonction du temps, avec desynchronisation
      
       float red = 0.5*sin((-iTime*1.0+10.0*L)+1.0);
       float green = 0.5*sin((-iTime*2.0+20.0*L)+1.0);
       float blue = 0.5*sin((-iTime*3.0+30.0*L)+1.0);
     
    return Falloff(L,r,1.0)*vec4(red, green, blue, 1.0);
  }
  // Else ancienne couleur
  else
  {
    return vec4(0.0);
  }
}

// Function 2765
float drawCh(in vec4 character, in float x, in float y)
{
    y = floor(11.5 - y);
    float word = 0.0;
    if (y>5.9)
    {
        if (y>8.9) word = character.x;
        else       word = character.y;
    }
    else
    {
        if (y>2.9) word = character.z;
        else       word = character.a;
    }
    float n = floor(7.0-x + 8.0*mod(y,3.0));
    return mod(floor(word/pow(2.0,n)), 2.0);
}

// Function 2766
vec4 toLinear(vec4 color, const transfer trc)
{
	bvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));
	bvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));
	vec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));
	vec4 lower = color/trc.slope;
	vec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));

	color = mix(higher, lower, cutoff);
	color = mix(color, neg, negCutoff);

	return color;
}

// Function 2767
float line(vec2 p, vec2 s, vec2 e) {s*=scale;e*=scale;float l=length(s-e);vec2 d=vec2(e-s)/l;p-=vec2(s.x,-s.y);p=vec2(p.x*d.x+p.y*-d.y,p.x*d.y+p.y*d.x);return length(max(abs(p-vec2(l/2.0,0))-vec2(l/2.0,lineWidth/2.0),0.0))-border;}

// Function 2768
float line( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    float d = length( pa - ba*h );

    return (1.0 - d);
}

// Function 2769
void
camera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,
                       out vec3 camera_pos )
{
    const int obj_count = 7;

    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );

    u = 1.0;

    float pu = 1.0 / float(obj_count-1);
    float pt = 0.0;
    vec3 p = vec3(0.0);
    for ( int i = 0; i!=obj_count; ++i )
    {
        float s = pu * ( -0.5 + float(i) );
        p +=
           ( start + obj_dist * float(i) ) *
           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );
    }
    camera_pos.xyz = p;
}

// Function 2770
float circle(in vec2 center, in float outerRadius, in float innerRadius, in vec2 point) {
    float width = outerRadius - innerRadius;
    return 1.0 - (
        	smoothstep( outerRadius-width, outerRadius+width, length(point-center))
        	- smoothstep( innerRadius-width, innerRadius+width, length(point-center))
        ) - 1.0;
}

// Function 2771
vec3 toLinear(vec3 color, const transfer trc)
{
	bvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));
	bvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));
	vec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));
	vec3 lower = color/trc.slope;
	vec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));

	color = mix(higher, lower, cutoff);
	return mix(color, neg, negCutoff);
}

// Function 2772
vec3 sdBilinearPatch( in vec3 p,
                      in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )
{    
    vec3 A = p1-p0;
    vec3 B = p3-p0;
    vec3 C = p2-p3-p1+p0;
    vec3 D = p0-p;

    // initial guess

#if INITIAL==0
    vec2 uv = vec2(0.5,0.5);
#endif
#if INITIAL==1
    vec2 uv = vec2(0.0,0.0);
    float d = dot2(p-p0);
    for( int i=0; i<16; i++ )
    {
        float u = float(i)/15.0;
        vec3 ba = mix( B,p2-p1,u);
        vec3 pa = mix(-D,p -p1,u);
		float v = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
		float t = dot2(pa-ba*v);
        if( t<d ) { d=t; uv=vec2(u,v); }
    }
    //return vec3(sqrt(d),uv);
#endif
    
    // find roots
    
#if METHOD==0
    vec2  k2 = vec2(dot(A,C),dot(B,C));
    vec2  k0 = vec2(dot(B,D),dot(A,D));
    float k1 = dot(A,B)+dot(C,D);
    for( int i=0; i<16; i++ )
    {
      uv.yx = clamp( -(uv*uv*k2 + uv*k1 + k0 ) /
                     vec2( dot2(B+uv.x*C), dot2(A+uv.y*C) ),
                     0.0, 1.0);
    }
    vec3 pq = D+uv.x*A+uv.y*B+uv.x*uv.y*C;
    vec3 nor = cross(A+uv.y*C,B+uv.x*C); // normal
	return vec3( length(pq), uv );
#endif
    
#if METHOD==1
    float AA = dot(A,A);
    float BB = dot(B,B);
    float CC = dot(C,C);
    float BC = dot(B,C);
    float AC = dot(A,C);
    float ABCD = dot(A,B)+dot(C,D);
    float AD = dot(A,D);
    float BD = dot(B,D);
    for( int i=0; i<6; i++ )
    {
        vec2 gra = vec2(
         uv.x*AA + uv.x*uv.y*uv.y*CC + uv.y*ABCD + 2.0*uv.x*uv.y*AC +     uv.y*uv.y*BC + AD,
         uv.y*BB + uv.x*uv.x*uv.y*CC + uv.x*ABCD +     uv.x*uv.x*AC + 2.0*uv.x*uv.y*BC + BD);

        float k1 = 2.0*uv.x*uv.y*CC + ABCD + 2.0*uv.x*AC + 2.0*uv.y*BC;
        mat2x2 hes = mat2x2(
         AA + uv.y*uv.y*CC + 2.0*uv.y*AC,
         k1, k1, 
         BB + uv.x*uv.x*CC + 2.0*uv.x*BC );
        
        uv -= inverse(hes)*gra;
        
        uv = clamp(uv,0.0,1.0);
    }
    vec3 nor = cross(A+uv.y*C,B+uv.x*C); // normal
	return vec3( length(D+uv.x*A+uv.y*B+uv.x*uv.y*C), uv );
#endif    
}

// Function 2773
void DrawBlend( inout DrawContext drawContext, vec3 vColor, float fBlend )
{
    drawContext.vResult = mix( drawContext.vResult, vColor, clamp( fBlend, 0.0, 1.0 ) );
}

// Function 2774
float line(vec2 p1, vec2 p2, vec2 p, float t){
	vec2 a = p - p1, b = p2 - p1;
	a = rotate(a, -atan(b.y, b.x));
	return pow(clamp(t / ((a.x < 0.0) ? length(a) : ((a.x < length(b)) ? abs(a.y) : length(p - p2))), 0.0, 1.0), t2);
}

// Function 2775
vec3 circle(vec2 uv,float a,vec2 pos,vec3 color,vec2 size,float bl){
    pos.x *= a;
 	float dist = length(uv - pos);
    float circle = smoothstep(size.x,size.y,dist);
    float flare = smoothstep(size.x,0.01,dist) * (0.3 + bl);
    vec3 c_circle = circle * color + flare;   
    return c_circle;
}

// Function 2776
float distLine(vec2 a, vec2 b){
    
	vec2 pa = a;
	vec2 ba = a - b;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
	//return smoothstep(-thickness*.5, thickness, length(pa - ba * h));
    return length(a - ba*h);
}

// Function 2777
vec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }

// Function 2778
void drawSpring( vec2 coords, vec2 p0, vec2 p1, float thickness, int loops )
{
    vec2 d = p1 - p0;
    if (length(d) < 0.001)
        return;
    
    vec2 dir = normalize(d);
    vec2 per = vec2(dir.y, -dir.x);
    
    vec2 st = d / float(loops * 2);
    vec2 last = p0 + per * thickness / 2.0 + st / 2.0;
    vec2 sw = -thickness * per;
    float th = 1.0;
    
    drawLine(coords, p0, last, th);
    
    for (int i=0; i<loops*2-1; i++)
    {
        vec2 next = last + st + sw;
        sw = -sw;
        drawLine(coords, last, next, th);
        last = next;
    }
    
    drawLine(coords, last, p1, th);
}

// Function 2779
float sdCircle( in vec2 p, in float r ) 
{
    return length(p)-r;
}

// Function 2780
vec3 LinearSample(vec2 uv, vec3 CN, out vec2 Moments) {
    float c0,c1,c2,c3; vec2 m0,m1,m2,m3;
    vec2 fuv=floor(uv*HRES-0.499)+0.5;
    vec3 C0=LinearSample0(fuv*IRES,c0,m0,CN);
    vec3 C1=LinearSample0((fuv+vec2(1.,0.))*IRES,c1,m1,CN);
    vec3 C2=LinearSample0((fuv+vec2(0.,1.))*IRES,c2,m2,CN);
    vec3 C3=LinearSample0((fuv+vec2(1.))*IRES,c3,m3,CN);
    vec2 fruv=fract(uv*HRES-0.499);
    float mc=max(0.0001,mix(mix(c0,c1,fruv.x),mix(c2,c3,fruv.x),fruv.y));
    Moments=mix(mix(m0,m1,fruv.x),mix(m2,m3,fruv.x),fruv.y)/mc;
    return mix(mix(C0,C1,fruv.x),mix(C2,C3,fruv.x),fruv.y)/mc;
}

// Function 2781
vec3 cosineDirection( in float seed, in vec3 nor)
{
    // compute basis from normal
    // see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content
    // (link provided by nimitz)
    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);
    vec3 uu = vec3( tc.x, tc.z, -nor.x );
    vec3 vv = vec3( tc.z, tc.y, -nor.y );
    
    float u = hash( 78.233 + seed);
    float v = hash( 10.873 + seed);
    float a = 6.283185 * v;

    return  sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;
}

// Function 2782
mat4 GetDirectionalLightMatrix ()
{
    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();
    vec3 trans = GetDirectionalLightSourcePosition();
	mat4 rot = rotationAxisAngle(rotAxisAngle.xyz, -rotAxisAngle.w );
	mat4 tra = translate( -trans.x, -trans.y, -trans.z );
	return rot * tra;     
}

// Function 2783
bool line(vec2 uv, vec2 from, vec2 to)
{
    return uv.x >= from.x && uv.x <= to.x && 
	   uv.y >= from.y && uv.y <= to.y;
}

// Function 2784
float Log3G10_to_linear ( float log3g10)
{
float a, b, c, g, linear;
a = 0.224282; b = 155.975327; c = 0.01; g = 15.1927;
linear = log3g10 < 0.0 ? (log3g10 / g) : (pow(10.0, log3g10 / a) - 1.0) / b;
linear = linear - c;
return linear;
}

