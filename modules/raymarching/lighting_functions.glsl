// Reusable Lighting Raymarching Functions
// Automatically extracted from raymarching/raytracing-related shaders

// Function 1
float doShadows(in vec3 rp)
{
    float s = 1.0;
    rp+=lightDir*.01;
    
    for (int i = 0; i < 4; ++i)
    {
    	float dist=map(rp);
        rp+=max(dist, 0.001)*lightDir;
        s=min(s,dist);
    }
    return mix(1.0, clamp(s/0.01, 0.0, 1.0), 0.8);
}

// Function 2
float ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }

// Function 3
OrbLightDescription GetLight(int lightIndex)
{
    const float lightMultiplier = 17.0f;
#if UNIFORM_LIGHT_SPEED
    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHT_COLORS);
    float radius = 18.5f;
#else
    float theta = iTime * 0.4 * (float(lightIndex) + 1.0f);
    float radius = 19.0f + float(lightIndex) * 2.0;
#endif
    
    OrbLightDescription orbLight;
    orbLight.Position = vec3(radius * cos(theta), 6.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));
    orbLight.LightColor = GetLightColor(lightIndex) * lightMultiplier;
    orbLight.Radius = 0.8f;

    return orbLight;
}

// Function 4
vec3 GetAmbientLight(const in vec3 vNormal)
{
	return GetSkyGradient(vNormal);
}

// Function 5
float light_pdf( const in LightInfo light, const in SurfaceInteraction interaction ) { 
    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(EPSILON, 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax)); 
}

// Function 6
float softshadow(const vec3 origin, in vec3 dir, in float mint, in float tmax, float k)
{
	float res = 1.0;
	float t = mint;
	for( int i=0; i<16; i++ )
	{
		float h = distFunc( origin + dir*t );
		res = min( res, k*h/t );
		t += clamp( h, 0.02, 0.10 );
		if( h<0.001 || t>tmax ) break;
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 7
vec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, float matID, in vec3 uvw, in float info, in vec3 sunDirection )
{

 
        vec3 rgb = vec3(0.0);

     rgb = vec3(0.35,0.1,0.0);
rgb = mix( rgb*0.15, vec3(0.2,0.12,0.03), smoothstep( 0.0, 1.0, uvw.y ) );
float tt = texturize( iChannel1, 1.5*pos*vec3(1.0,0.5,1.0), nor ).x;
rgb *= 0.2+1.5*tt;
tt = texturize( iChannel1, 0.03*pos, nor ).x;
float ff = texturize( iChannel1, 1.5*pos, nor ).x;
float green = (1.0-smoothstep(0.0, 0.5, uvw.x*4.0 - tt + 0.1));
rgb = mix( rgb, 2.4*vec3(0.045,0.05,0.00)*ff, 0.8*green );
// bump
vec2 cuv = vec2( uvw.x*3.0, info );
float bu = 0.0;
bu = 0.5 + 0.25*green;
nor = normalize( nor + bu * (-1.0 + 2.0*texture( iChannel0, cuv ).xyz) );
   
    
    // lighting terms
float occ = uvw.z;
     vec3 lig = sunDirection;//lpos[i]/SC - pos;
     float llig = dot( lig, lig);
 
   //float sha = softshadow( pos, sunDirection, 64.0, 0.0 );
    float sha = softshadow( pos, sunDirection, 0.02*15., sqrt(llig)*15., 32.0 ); 
    

    float sun = clamp( dot( nor, sunDirection ), 0.0, 1.0 );
    float sky = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );
    float ind = clamp( dot( nor, normalize(sunDirection*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );
float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0 ), 5.0 );
float spe = pow( clamp( dot( reflect( rd, nor ), sunDirection ), 0.0, 1.0 ), 16.0 );

     // compute lighting
    vec3 lin  = 3.5*sun*vec3(1.75,1.30,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));
         lin += 2.5*sky*vec3(0.82,0.75,0.50)*occ;
         lin += 1.1*ind*vec3(0.30,0.35,0.25)*occ;
         lin += 6.0*spe*sha*(0.5+0.5*fre);
         lin *= 1.0 + 1.0*fre*occ*vec3(1.5,1.0,0.5);
    for( int i=0; i<7; i++ )
    {
        vec3 lig = lpos[i].xyz - pos;
        float llig = dot(lig,lig);
        float im = inversesqrt( llig );
        lig = lig * im;
        lin += vec3(1.0,0.5,0.2)*1.5*lpos[i].w * clamp(dot(lig,nor),0.0,1.0)*im*im*occ;
    }
    
    
return rgb * lin * 1.3;
}

// Function 8
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 N, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 9
vec3 shade(vec3 i, vec3 dr) {
    vec2 d = map(i);
    vec3 c = vec3(1);
    vec3 n = normal(i);
    if (d.y==0.) {
        vec3 r = reflect(dr,n);
        float fres = dot(n,-dr);
        c=mix((sky(r)/7.+1.)*vec3(1,1.2,4),vec3(0,.5,8),fres/2.);
    }
   
    return c;
}

// Function 10
float calcAO(vec3 pos, vec3 nor)
{
	float occ = 0.0;
    float sca = 0.4;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        
    	float dd = map(aopos);
        
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 2.5*occ, 0.0, 1.0 );    
}

// Function 11
float lightPdf(const in vec4 light, const in SurfaceInteraction interaction) {
	float sinThetaMax2 = light.w * light.w / distanceSq(light.xyz, interaction.point);
    float cosThetaMax = sqrt(max(EPSILON, 1. - sinThetaMax2));
    return 1. / (TWO_PI * (1. - cosThetaMax));
}

// Function 12
float calcAO( in vec3 ro, in vec3 rd ) {
	float occ = 0.0;
    float sca = 1.0;
    
    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );
    rd1 = rotateY( rd1, CLOCK_ROT_Y );
    
	float secs = mod( floor(iDate.w),        60.0 );
	float mins = mod( floor(iDate.w/60.0),   60.0 );
	float hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;
    
    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );
    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );
    
    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );
    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );
    
    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );
    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );
    
    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));
    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));
    
    
    for( int i=0; i<6; i++ ) {
        float h = 0.001 + 0.25*float(i)/5.0;
        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, 
                       watchIntersect, pencilIntersect ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    
}

// Function 13
vec4 shadow(ray r){
	float s=1.0;
	float t=MIN_DIST_SHADOW;
	for(int i=0;i<MAX_ITER_SHADOW;i++){
		ray tmp=r;
		tmp.p+=r.d*t;
		float h=dist(tmp);
		if(h<MIN_DIST)return vec4(0.0);
		s=min(s,PENUMBRA*h/t);
		t+=h;
		if(t>MAX_DIST_SHADOW)break;
	}
	return vec4(1.0)*s;
}

// Function 14
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<14; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, 8.*h/t );
        t += clamp( h, 0.08, 0.25 );
        if( res<0.001 || t>tmax ) break;
    }
    return max(0.0, res);
}

// Function 15
float calculateAO(vec3 p, vec3 n){

    const float AO_SAMPLES = 5.0;
    float r = 0.0, w = 1.0, d;
    
    for (float i=1.0; i<AO_SAMPLES+1.1; i++){
        d = i/AO_SAMPLES;
        r += w*(d - map(p + n*d));
        w *= 0.5;
    }
    
    return 1.0-clamp(r,0.0,1.0);
}

// Function 16
float calculateAO(vec3 pos, vec3 n)
{
	float occ = 0.0;

	for( int i=0; i<5; i++ )
	{
		float hr = 0.1*float(i);
		vec3 aopos = pos + n*hr;
		float dd = distfunc(aopos);
		occ += dd;
	}
	return mix(1.0, clamp(0.0, 1.0, occ), 1.0);   
}

// Function 17
float CalculateShadow(vec3 surfPos, vec3 lightOrigin)
{
    RayHit hit;
    
    float result   = 1.0;
    vec3  lightRay = normalize(surfPos - lightOrigin);
    int   steps    = 0;
    
    for(float depth = NearClip; (depth < (FarClip - Epsilon)) && (steps < ShadowSteps); ++steps)
    {
    	vec3  point = (lightOrigin + (lightRay * depth));
        float sdf   = Scene_SDF(point, hit);
        
        if(sdf < Epsilon)
        {
            return 0.0;
        }
        
        result = min(result, (SoftShadowFactor * sdf) / depth);
        
        depth += sdf;
    }
    
    return result;
}

// Function 18
float TraceLights(in vec3 origin, in vec3 direction)
{
  float maxDist = 150.0;
  float t = 0.0;
  vec3 rayPos;
  float dist=10000.;

  for ( int i=0; i<10; i++ )
  {
    rayPos =origin+direction*t;
    dist = min(dist, MapLights( rayPos));
    t += dist;
  }

  return dist;
}

// Function 19
float Shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = 0.05;
	float h;
	
    for (int i = 0; i < 8; i++)
	{
		h = Map( ro + rd*t );
		res = min(6.0*h / t, res);
		t += h;
	}
    return max(res, 0.0);
}

// Function 20
float shadow(in vec3 rp)
{
    
    mat3 trn;
    vec3 ld = lightDir;
    float s = 1.0;
    const float dst = 0.04;
    rp = rp + ld * dst * 1.04;
    
    for (int i = 0; i < 15; ++i)
    {
    	float d = map(rp);
        s = min(s, d / dst);
        rp += max(d * 0.75, 0.01) * ld;
    }
    return s;
}

// Function 21
float calcAO( const vec3 pos, const vec3 nor ) {
	float totao = 0.0;
    float sca = 1.0;
    for( int aoi=0; aoi<5; aoi++ ) {
        float hr = 0.01 + 0.05*float(aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = mapTerrain( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.75;
    }
    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
}

// Function 22
vec3 lighting(in vec3 ro, in vec3 rd, in float dist) {
    const float SHININESS = 90.0;
    float diffuse = 0.0;
    float spec = 0.0;
    float shade = 0.0;
    for (int i = 0; i < 2; i++) {
        vec3 lightPos = getLightPos(i);
    	vec3 L = normalize(lightPos - ro);
    	vec3 N = normalAt(ro);
    	vec3 V = normalize(-dist * rd);
	    vec3 R = normalize(reflect(-L, N));
        
        
	    diffuse += max(0.0, dot(N, L));
		spec += pow(max(0.0, dot(R, V)), 0.3 * SHININESS);
        
        shade = max(shade, shadow(ro, lightPos, -L));
    }
    diffuse = clamp(diffuse, 0.0, 1.0);
    spec = clamp(spec, 0.0, 1.0);
    shade = clamp(shade, 0.0, 1.0);
    
    vec3 light = shade * vec3(diffuse + spec);
    
    return GLOBAL_AMBIENT + light * colorAt(ro);
}

// Function 23
vec3 diffuseLighting(vec3 pos,vec3 lightPos,vec3 Color, float power) {
    vec3 light = normalize(lightPos - pos);
    vec3 normal = getNormal(pos);
    
    float diffuse = clamp(dot(normal, light),0.0,1.0);
    return diffuse * Color * power;
}

// Function 24
vec4 shadePlane(const Ray ray, const RaycastHit hit, vec4 clearColor) {
 
    if(hit.type == 1) {
     
        float scale = 1.;
        float u = hit.point.x;
        float v = hit.point.z;
        
        //vec2 uv = rot2D(vec2(u,v),45. * sin(iTime));
        //u = uv.x;
        //v = uv.y;
        
        u = mod(u * scale, 1.);
        v = mod(v * scale, 1.);
        
        vec3 diffuse = texture(iChannel1,vec2(u,v)).xyz;
        
        if((u > .5 || v > .5) && !(u > .5 && v > .5)) {
         
            diffuse /= 2.;
            
        }
        
   	 	diffuse *= lighting(ray, hit);
        
        //vec3 spec = vec3(1.);
        //spec *= specular(ray, hit, 40.);
		//diffuse += spec;
        
    	return vec4(diffuse.xyz,1.);
        
    }
    
    return clearColor;
    
}

// Function 25
float calcAO(vec3 pos, vec3 nor) {
	float occ = 0.0;
	float sca = 1.0;

	for (int i = 0; i < 5; i++) {
		float hr = 0.01 + 0.12 * float(i) / 4.0;
		vec3 aopos = nor * hr + pos;
		float dd = map(aopos).x;

		occ += -(dd - hr) * sca;
		sca *= 0.95;
	}
	return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// Function 26
vec3 directLight(vec3 pos, vec3 normal){
    //return vec3(0.);
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 27
vec3 shadePBR (in vec3 ro, in vec3 rd, in float d, in int id)
{
    vec3 p = ro + d * rd;
    vec3 nor = normal (p, d*EPSILON);

    // "material" hard-coded for the moment
    vec3 albedo =     (id == 1) ? vec3(.7,.55,.45) : (id == 2) ? vec3 (.9) : (id == 3) ? vec3 (.2, .4, .9) : vec3 (.9, .4, .1);
    float metallic =  (id == 1) ? .9 : (id == 2) ? 0.0 : (id == 3) ? .0 : .0; 
    float roughness = (id == 1) ? .125 : (id == 2) ? .5 : (id == 3) ? .5 : .2;
    float ao = 1.;

    // lights hard-coded as well atm
    vec3 lightColors[4];
    lightColors[0] = vec3 (.9, .9, .9) * 120.;
    lightColors[1] = vec3 (.9, .25, .9) * 275.;
    lightColors[2] = vec3 (.25, .9, .9) * 275.;
    lightColors[3] = vec3 (.25, .9, .25) * 275.;

    vec3 lightPositions[4];
    lightPositions[0] = vec3 (.0, .0, .0);
    lightPositions[1] = vec3 (-1.1, 1.5, -2.);
    lightPositions[2] = vec3 (-1., .75, -2.2);
    lightPositions[3] = vec3 (.0, 2.75, -2.2);

	vec3 N = normalize (nor);
    vec3 V = normalize (ro - p);

    vec3 F0 = vec3 (0.04); 
    F0 = mix (F0, albedo, metallic);
    vec3 kD = vec3(.0);
	           
    // reflectance equation - cutting down on the light boost preformance of course
    vec3 Lo = vec3 (.0);
    for(int i = 0; i < 4; ++i) 
    {
        // calculate per-light radiance
        vec3 L = normalize(lightPositions[i] - p);
        vec3 H = normalize(V + L);
        float distance    = length(lightPositions[i] - p);
        float attenuation = 2.5 / (distance * distance);
        vec3 radiance     = lightColors[i] * attenuation;        
        
        // cook-torrance brdf
        float aDirect = .125 * pow (roughness + 1., 2.);
        float aIBL = .5 * roughness * roughness;
        float NDF = DistributionGGX(N, H, roughness);        
        float G   = GeometrySmith(N, V, L, roughness);      
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       
        
        vec3 kS = F;
        kD = vec3(1.) - kS;
        kD *= 1. - metallic;	  
        
        vec3 nominator    = NDF * G * F;
        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
        vec3 specular     = nominator / max(denominator, .001);  

        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / PI + specular) * radiance * NdotL;

        if (DO_SHADOWS) {
	    	Lo *= shadow (p, L);
        }
    }

    vec3 irradiance = texture (iChannel0, N).rgb;
    vec3 diffuse    = irradiance * albedo;
    vec3 ambient    = (kD * diffuse) * ao;

    return ambient + Lo;
}

// Function 28
void shadeBoat(inout Ray ray) {
	//this code is super spaghetti and I'm so fucking sorry
	vec3 normal = -sceneGrad(ray.m_point);
	float frensel = abs(dot(ray.m_direction, normal));
	float nearness = abs(ray.m_point.z);
	nearness = sqrt(min(nearness*6.0+.1,1.0));
	vec3 reflected_sun = reflect(sundir, normal);
	vec3 reflected_sky = reflect(vec3(0.0,0.0,1.0), normal);
	float specular_sun = pow(max(dot(ray.m_direction, reflected_sun),0.0), 20.0) * (1.0-frensel*0.98);
	float specular_sky = pow(max(dot(ray.m_direction, reflected_sky)+0.75,0.0)/1.75, 2.0) * (1.0-frensel*0.98);

	float ao = mix(1.0,scene(ray.m_point + normal*0.1)/0.1,0.3);

	float shitty_shadow_approximation = scene(ray.m_point + sundir*0.1) < scene(ray.m_point + sundir*0.2) ? 1.0 : 0.0;

#ifdef FINLANDSFARJAN
    vec2 crds = vec2(-abs(ray.m_point.x), ray.m_point.z);
	bool mst = sin(dot(crds,vec2(.5,2))*20.+.5) > 0.;
	vec3 diffusecol = mst ? vec3(0.9) : vec3(0.9, 0.05, 0.01);
#else
    vec3 diffusecol = vec3(.8,.3,.1);
#endif
	float sundot = dot(normal, sundir);
	sundot = max(sundot, 0.0) + frensel*0.0;
	ray.m_color += ao * (sundot*suncol*diffusecol + (1.0+normal.z)/2.0 * mix(suncol,skycol,0.6) * diffusecol ) * nearness + shitty_shadow_approximation*specular_sun*suncol + specular_sky * skycol * nearness + skycol*0.02;
}

// Function 29
vec3 CalculateLightingAnalytical(in vec3 n, in vec3 l, in vec3 v, in vec3 a, in float r, in float m)
{
    vec3 f0 = mix(vec3(0.04), a, m);
    vec3 ks = vec3(0.0);
    vec3 d  = CalcDiffuse(a);
    vec3 s  = CalcSpecularAnalytical(n, l, v, f0, ks, r);
    vec3 kd = (1.0 - ks);
    
    return ((kd * d) + s) * clamp(dot(n, l), 0.0, 1.0);
}

// Function 30
vec3 shade(vec3 eye, vec3 dir, float t, vec3 col)
{
    vec3 lightDir = normalize(vec3(0.0, -0.5, 1.0));
    
    vec3 pos = eye + dir*t;
    vec3 nrm = calcNormal(pos);
    vec3 ref = reflect( dir, nrm );
    
    float diff = clamp(dot(nrm, lightDir), 0.0, 1.0);
    float spec = pow(clamp( dot( ref, lightDir ), 0.0, 1.0 ), 32.0);
    float fre = pow( clamp(1.0+dot(nrm,dir),0.0,1.0), 2.0 );
    
    vec3 ret = vec3(0.3);
   	ret += 1.4 * vec3(0.9) * diff;
    ret += 1.2 * vec3(0.8) * spec;
    ret += 0.4 * vec3(1.0) * fre;
    ret = ret * col;

    vec3 back = mix(vec3(0.4), 1.5 * vec3(0.7, 0.8, 0.9), clamp((dir.y*1.5+1.0)/2.0, 0.0, 1.0));
    
    ret = mix( ret, back, 1.0-exp( -0.002*t*t ) );
        
    return clamp(ret, 0.0, 1.0);
}

// Function 31
void constructLightPath(inout float seed) {
    vec3 ro = normalize( hash3(seed)-vec3(0.5) );
    vec3 rd = randomHemisphereDirection( ro, seed );
    ro = lightSphere.xyz + ro*0.5;
    vec3 color = LIGHTCOLOR;
    
    lpNodes[0].position = ro;
    lpNodes[0].color = color;
    lpNodes[0].normal = rd;
    
    for( int i=1; i<LIGHTPATHLENGTH; ++i ) {
        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);
    }
    
    for( int i=1; i<LIGHTPATHLENGTH; i++ ) {
		vec3 normal;
        vec2 res = intersect( ro, rd, normal );
        if( res.y > -0.5 && res.y < 4. ) {
            ro = ro + rd*res.x;
            color *= calcColor( res.y );
            lpNodes[i].position = ro;
            lpNodes[i].color = color;
            lpNodes[i].normal = normal;

            rd = cosWeightedRandomHemisphereDirection( normal, seed );
        } else break;
    }
}

// Function 32
vec3 salmpleLightForParticle(in vec3 x, in float time) {
    vec3 Lo = vec3(0.0);	//outgoing radiance

    LightSamplingRecord rec;
    vec3 Li = sampleLightSource( x, vec3(0.0), rnd(), rnd(), rec );

    float dotNWo = rec.w.y;
    if (dotNWo > 0.02 && rec.pdf > EPSILON) {
        float fr = VOLUME_SCAATTERING / (4.0 * PI);
        float phasePdf = 1.0 / (2.0 * PI);
        
        bool v = true;
#ifdef VOLUMETRIC_SHADOWS
        Ray shadowRay = Ray(x, rec.w, time);
        v = isLightVisible( shadowRay );
#endif
        Lo += ((Li * fr * float(v)) / rec.pdf) * misWeight(rec.pdf, phasePdf);
    }

    return Lo;
}

// Function 33
vec4 FxaaPixelShader( vec4 uv, vec2 rcpFrame) {
    
    vec4 rgbNW = SampleScene(uv.zw);
    vec4 rgbNE = SampleScene(uv.zw + vec2(1,0)*rcpFrame.xy);
    vec4 rgbSW = SampleScene(uv.zw + vec2(0,1)*rcpFrame.xy);
    vec4 rgbSE = SampleScene(uv.zw + vec2(1,1)*rcpFrame.xy);
    vec4 rgbM  = SampleScene(uv.xy);

    vec4 luma = vec4(0.299, 0.587, 0.114, 0.0);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max(
        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
        FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
    
    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
          dir * rcpDirMin)) * rcpFrame.xy;

    vec4 rgbA = (1.0/2.0) * (
        SampleScene(uv.xy + dir * (1.0/3.0 - 0.5)) +
        SampleScene(uv.xy + dir * (2.0/3.0 - 0.5)));
    vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
        SampleScene(uv.xy + dir * (0.0/3.0 - 0.5)) +
        SampleScene(uv.xy + dir * (3.0/3.0 - 0.5)));
    
    float lumaB = dot(rgbB, luma);

    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;
    
    return rgbB; 
}

// Function 34
float calculateAO(in vec3 p, in vec3 n){
	
    float sca = 1., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(2.0 - occ, 0., 1.);    
}

// Function 35
void shade( in vec3 pos, in vec3 nor, in vec3 rd, in float matID, 
		    out vec3 bnor, out vec4 mate, out vec2 mate2 )
{
    bnor = vec3(0.0);
	mate = vec4(0.0);
	mate2 = vec2(0.0);
		
	if( matID<0.5 )
    {
        mate.xyz = vec3(0.1,0.2,0.0)*0.5;
        mate.w = 0.0;
    }
    else if( matID<1.5 )
    {
        mate.xyz = 0.3*pow( texturize( iChannel0, 0.45*pos, nor ).xyz, vec3(2.0) );
        mate.w = 0.0;
    }
    else if( matID<2.5 )
    {
        mate.w = 1.0;
        float h = clamp( (pos.y - terrain(pos.xz))/10.0, 0.0, 1.0 );
			
        mate.xyz = 0.3*mix( vec3(0.1,0.4,0.2), vec3(0.1,0.2,0.3), h );
			
		bnor = vec3(0.0,1.0,0.0);
	    bnor.xz  = 0.20*(-1.0 + 2.0*texture( iChannel2, 0.05*pos.xz*vec2(1.0,0.3) ).xz);
	    bnor.xz += 0.15*(-1.0 + 2.0*texture( iChannel2, 0.10*pos.xz*vec2(1.0,0.3) ).xz);
	    bnor.xz += 0.10*(-1.0 + 2.0*texture( iChannel2, 0.20*pos.xz*vec2(1.0,0.3) ).xz);
		bnor = 10.0*normalize(bnor);
    }
	else //if( matID<3.5 )
    {
		mate = vec4(0.0);
	}
	
	if( matID<2.5 )
	{
	float iss = smoothstep( 0.5, 0.9, nor.y );
    iss = mix( iss, 0.9, 0.75*smoothstep( 0.1, 1.0, texturize( iChannel1, 0.1*pos, nor ).x ) );
	
	vec3 scol = vec3( 0.8 );
	
	vec3 cnor = normalize( -1.0 + 2.0*texture( iChannel2, 0.15*pos.xz ).xyz );
	cnor.y = abs( cnor.y );
	float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,cnor)), 0.0, 1.0), 16.0 ) );
    mate2.y = spe*iss;
	
    mate.xyz = mix( mate.xyz, scol, iss );
	}
}

// Function 36
vec3 oceanLighting(vec3 ro, vec3 rd, vec3 Lo, vec3 P, vec3 N, vec3 tx, vec3 ty)
{
    vec3 V = -rd;
    vec3 L = normalize(Lo-P);
    vec3 H = normalize(rd+L);
    float VoL = dot(-V, L);
    float ox = hash3D(tx), oy = hash3D(ty);
    vec3 mieColor;
    vec3 rrd = reflect(rd, vec3(0., 1., 0.));
    vec3 skycolor = getSkyLight(P, rrd, Lo, SKY_BETA_RAY, SKY_BETA_MIE, mieColor, SKY_MIE_HEIGHT);
    vec3 suncolor = getSun(-rrd, L, vec3(1.), mieColor);
    //skycolor += suncolor;
    float phiV = atan(dot(V, ty), dot(V, tx));
    float phiL = atan(dot(L, ty), dot(L, tx));
    float cosPhiV = cos(phiV);
    float sinPhiV = sin(phiV);
    float cosPhiL = cos(phiL);
    float sinPhiL = sin(phiL);
    float micro_v = pow(ox*ox*cosPhiV*cosPhiV+oy*oy*sinPhiV*sinPhiV,0.5);
    float F = //Fresnel_Schlick(1.033, 1., dot(V, N));
        0.03+0.967*pow(1.-dot(V, N), 5.*exp(-2.69*micro_v))/(1.+22.6*pow(micro_v, 1.5));
    
    vec3 IrradianceSun = mieColor*VoL*oceanLightingSun(V, L, N, tx, ty, ox, oy);//mieColor*F/(4.*pow(dot(H, N), 4.));
    vec3 IrradianceSky = F*skycolor;
    vec3 IrradianceSea = (1.-F)*.33*vec3(0.02, 0.25, 0.45);
    
    return VoL>0.?IrradianceSun:0.+
        IrradianceSky +
        IrradianceSea;
}

// Function 37
float shadowTrace(in vec3 pos, in vec3 ray){
    
    vec3 norm = vec3(0.);
    vec2 i;
    float shadow = 0., t = INFINI;
    
    // i.y is the depth reach by the ray.
	// Depth is used to smooth the shadow.
    // From all encountered object, the deeper (biggest i.y) value is kept.

    i = boxImpact(pos, ray, boxO, boxD, norm);
	if(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}
    
    i = coneImpact(pos, ray, conO, conH, conR, norm);
	if(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}
	
    i = sphereImpact(pos,ray,spO,spR, norm);
	if(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}
    
    i = cylinderImpact(pos.yz, ray.yz, cyO, cyR, norm.yz);
	if(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}
    
    i = cylinderImpact(pos.xy, ray.xy, cyO, cyR, norm.xy);
	if(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}
    
    
    #ifdef SPLIT
    if(gl_FragCoord.x < iResolution.x/2.)
    #endif
    
    shadow /= max(20.,t*SH*iResolution.x);	// expanding same way as anti-aliasing
    
    return min(1.,shadow);
}

// Function 38
float lightPointDiffuse(vec3 pos, vec3 lightPos) {
	float lightDist = length(lightPos - pos);
	float color = 3.0 / (lightDist * lightDist);
	return max(0.0, color);
}

// Function 39
float lighting(vec3 origin, vec3 dir, vec3 normal) {
    vec3 lightPos = vec3(12,12,1);//vec3(cos(time) +12., sin(time), 12.);
    vec3 light = normalize(lightPos - origin);

    float diffuse = max(0., dot(light, normal));
    vec3 reflectedRay = 1.0 * dot(light, normal) * normal - light;

    float specular = max(0., (pow(dot(reflectedRay, light),5.))) * sin(iTime* 3.)* 0.3;

    float ambient = 0.03;

    return ambient + diffuse + specular;

}

// Function 40
float shadow(vec3 pos, vec3 lPos)
{
    //lPos.xyz += (vec3(N2(pos.xy), N2(pos.yz), N2(pos.zx)) - 0.5)* 0.03; //jitters the banding away
    
    vec3 dir = lPos - pos;  // Light direction & disantce
    
    float len = length(dir);
    dir /= len;				// It's normalized now
    
    pos += dir * MIN_DST * 10.0;  // Get out of the surface
    
    float dst = SDF(pos); // Get the SDF
    
    // Start casting the ray
    float t = 0.0;
    float obscurance = 1.0;
    
    while (t < len)
    {
        if (dst < MIN_DST) return 0.0; 
        
        obscurance = min(obscurance, (20.0 * dst / t)); 
        
        t += dst;
        pos += dst * dir;
        dst = SDF(pos);
    }
    
    return obscurance;     
}

// Function 41
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 42
float ao(vec3 eye, vec3 norma, float scale) {
    float depth = scale;
    float accum = 0.0;
    for (int i = 0; i < 5; i++) {
        float dist = sceneDist(eye + depth * norma);
        accum = max(accum, (depth - dist) / depth);
        depth += scale;
    }
    return clamp(1.0 - accum, 0.0, 1.0);
}

// Function 43
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 3., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
}

// Function 44
float calcShadow(Ray ray, float maxT, float k)
{
    float res = 1.0;
    float ph = 1e20;
    int i = 0;
    for (float t = hitThreshold * 50.; t < maxT; )
    {
        float h = map(rayToPos(ray, t)).t;
        if (h < hitThreshold)
        {
            return 0.;
        }
        float hsqr = pow(h, 2.);
        float y = hsqr/(2. * ph);
        float d = sqrt(hsqr - pow(y, 2.));
        res = min(res, k * d / max(0., t - y));
        ph += h;
        t += h;
        i += 3;
        if (i > maxSteps)
        {
            break;
        }
    }
    return res;
}

// Function 45
vec3 furShade(vec3 pos, vec3 color, vec3 light, vec3 eye, float density) {
		
		vec3 v = normalize(light - pos);
		vec3 n = furNormal(pos, density);
		vec3 ev = normalize(pos - eye);
		vec3 h = reflect(ev, n);
		
		float diff = max(0.0, dot(v, n)) + 0.4;
		float spec = pow(max(0.0, dot(v, h)), 64.);

		float r = length(pos);
		float t = (r - (1.0 - furDepth)) / furDepth;
		t = clamp(t, 0.3, 1.);
		
		diff = mix(diff, 1., 0.5);
		
		return color * t * (diff + 1.9 * spec);
	}

// Function 46
vec3 shader2(){
	vec2 p = vec2(fragCoord2.xy / iResolution.xy);
	vec2 p2 = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	vec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;
	float t = iTime;
	r = r * 8.0;
	vec3 ret;
	//pintamos el cielo
	ret = texture(iChannel0, p).xyz*vec3(0.5,0.5,0.7);
	if(p.y < 1./3.){
	// Plasma de color rosa. 
	//Simula amor(Fragmento de codigo extraido de los tutoriales)
		vec3 colorCielo=ret;
		float v1 = sin(r.x +t);
		float v2 = sin(r.y +t);
		float v3 = sin(r.x+r.y +t);
		float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);
		float v = v1+v2+v3+v4;
		v *= 1.0;
		ret = vec3(1.0, clamp(sin(v+0.5*PI),0.0,0.7), 1.0);
		ret = 0.3+ 0.7*ret;
		float m = smoothstep(0.15, 0.3, p.y);
		ret = mix(ret, colorCielo, m);
	}
	vec3 pixel = ret;
	//pintamos la luna
	luna(r,t,pixel);
	float intervaloTiempo=2.0;
	//evaluamos si hay que pintar rombos
	int mostrar=1;
	if(mod(floor(t),intervaloTiempo)==0.0){
		mostrar=int(abs(float(mostrar-1)));
	}
	//pintamos 2 rombos(+18 anios) parpadeantes
	if(mostrar==1){
		rombo(r, vec2(8.0,6),0.5,0.5,pixel);
		rombo(r, vec2(9.0,6),0.5,0.5,pixel);
	}
	float escala=0.2;
	float y=mod(t,2.0)-1.0;
	vec2 pos1=vec2(sin(y*8.0)*0.2-0.8,y);
	pixel=mix(corazon3(pos1,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));
	
	y=mod(t,1.5)-1.0;
	vec2 pos2=vec2(sin(y*8.0)*0.3-0.6,y);
	pixel=mix(corazon3(pos2,p2,escala,pixel),pixel,smoothstep(-1.0,1.0,y));
	
	y=mod(t,4.0)-1.0;
	vec2 pos3=vec2(sin(y*8.0)*0.1-0.5,y);
	pixel=mix(corazon3(pos3,p2,escala,pixel),pixel,smoothstep(-1.0,3.0,y));
	
	y=mod(t,2.0*PI)-1.0;
	vec2 pos4=vec2(sin(y*8.0)*0.2-0.3,y);
	pixel=mix(corazon3(pos4,p2,escala,pixel),pixel,smoothstep(-1.0,2.0*PI-1.0,y));
	
	y=mod(t,2.5)-1.0;
	vec2 pos5=vec2(sin(y*8.0)*0.2+0.1,y);
	pixel=mix(corazon3(pos5,p2,escala,pixel),pixel,smoothstep(-1.0,1.5,y));
	
	y=mod(t,PI)-1.0;
	vec2 pos6=vec2(sin(y*8.0)*0.2+0.5,y);
	pixel=mix(corazon3(pos6,p2,escala,pixel),pixel,smoothstep(-1.0,PI-1.0,y));
	
	y=mod(t,3.0)-1.0;
	vec2 pos7=vec2(sin(y*8.0)*0.2+0.7,y);
	pixel=mix(corazon3(pos7,p2,escala,pixel),pixel,smoothstep(-1.0,2.0,y));
	
	return pixel;
}

// Function 47
vec3 ShadeWater( ShadeData s )
{
	const float albedoScale = 4.0;
	float rad = (SSradius+1.0)/albedoScale;
	rad = floor( rad*tau+.5 )/tau; // round it so we get a whole number of texture repeats
	vec2 uv = vec2(s.pos.z/albedoScale,atan(s.pos.x,s.pos.y)*rad);
	
	vec3 base = vec3(.05,.1,.2)*DiffuseLight(s);
	
	// normal map
	vec2 noise = (Noise( s.pos*2.0+iTime*vec3(-4,4,0) )*2.0-1.0)*.1;
	vec3 tangent = normalize(vec3(s.pos.y,-s.pos.x,0));
	vec3 binormal = vec3(0,0,1);
	vec3 normal = s.normal + tangent*noise.x + binormal*noise.y;
	
	float fresnel = dot(normal,s.ray);
	vec3 reflection = s.ray-2.0*fresnel*normal;
	fresnel = pow( 1.0-abs(fresnel), 5.0 );
	
	float up = dot( reflection, normal );
	float across = dot( reflection, binormal );
	
	return mix( base, vec3(.4,.7,1)*1.0*pow(1.0-abs(across),10.0), fresnel );
}

// Function 48
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<64; i++ )
    {
        float h = mapTerrain(ro + rd*t);
		h = max( h, 0.0 );
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.5 );
		if( res<0.001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 49
vec3 GetLighting(Intersection i, vec3 origin)
{
	vec3 color = vec3(0,0,0);
	Light light;
	
	light.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);
	light.color = vec3(1,1,1);
	light.radius = 20.0;
	color += CalcLighting(light, i, origin);
	
	/*
	light.p = vec3(cos(time*0.2)*2.0,5,sin(time*0.2)*2.0+8.0);
	light.color = vec3(1,1,1);
	light.radius = 20.0;
	color += CalcLighting(light, i, origin);
*/
	
	return color;
}

// Function 50
vec3 LightPixel (vec3 diffuse, vec3 rayDir, vec3 normal, float specPower)
{
    vec3 lightAmbient				= vec3(0.01);
    vec3 directionalLightReverseDir = normalize(vec3(1.0,2.0,1.0));
    vec3 directionalLightColor = vec3(1.0);
    
    vec3 pixelColor = diffuse * lightAmbient;
    float dp = clamp(dot(normal, directionalLightReverseDir), 0.0, 1.0);
    pixelColor += diffuse * dp * directionalLightColor;
    vec3 reflection = reflect(directionalLightReverseDir, normal);
    dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
	pixelColor += directionalLightColor * pow(dp, specPower);    
    return pixelColor;
}

// Function 51
float shadowSphere(vec3 ro, vec3 rd, vec3 p, float radius)
{
    vec3 d = p-ro;
    float b = dot(d, rd);
    if(b<0.)
        return 1.0;
   	vec3 c = ro+rd*b;
    float s = length(c-p)/radius;
    return max(0.,(min(1.,s)-.7)/.3);
}

// Function 52
float shadow(vec3 pos, vec3 lPos)
{
    lPos.xyz += (vec3(N2(pos.xy), N2(pos.yz), N2(pos.zx)) - 0.5)* 0.03; //jitters the banding away
    
    vec3 dir = lPos - pos;  // Light direction & disantce
    
    float len = length(dir);
    dir /= len;				// It's normalized now
    
    pos += dir * MIN_DST * 10.0;  // Get out of the surface
    
    vec2 dst = SDF(pos); // Get the SDF
    
    // Start casting the ray
    float t = 0.0;
    float obscurance = 1.0;
    
    while (t < len)
    {
        if (dst.x < MIN_DST) return 0.0; 
        
        obscurance = min(obscurance, (20.0 * dst.x / t)); 
        
        t += dst.x;
        pos += dst.x * dir;
        dst = SDF(pos);
    }
    
    return obscurance;     
}

// Function 53
void packShadow(out vec4 packed, in float depth)
{
    packed = vec4(map(depth, MIN_DIST_SHADOW, MAX_DIST_SHADOW, 0.0, 1.0));
}

// Function 54
vec3 calcLights(light data, vec3 p, vec3 eye) {
  vec3 ambientColor = data.ambientIntencity * data.amibnetColor;
  vec3 phongColor = diffuseLight(data.directLightColor, p, eye, data.lightPosition, data.directLightIntencity);

  return ambientColor + phongColor;
}

// Function 55
vec4 ShadowInfoForRay( vec3 seed, vec3 start, vec3 dir, float depth )
{
    if ( depth >= NO_HIT_DEPTH )
	    return ShadowInfoForBackground( seed, start, dir CACHE );

    vec3 hitPos = start + dir * depth;
    
    vec4 res = vec4( 0.0 );
    
    vec3 normal = GetNormal( hitPos CACHE );
    
    const vec3 DirectLightingSampleScale = vec3( 2.0 * BG_BOX_SCALE.x / float( BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT ), 0.0, 2.0 * BG_BOX_SCALE.z / float( BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT ) );
    for ( int z = 0; z < BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT; z++ )
    {
        for ( int x = 0; x < BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT; x++ )
        {
            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            vec3 ceilingPos = vec3( BG_BOX_CENTER.x - BG_BOX_SCALE.x, CEILING_HEIGHT, BG_BOX_CENTER.z - BG_BOX_SCALE.z );
            ceilingPos += vec3( float( x ) + r2.x, 0.0, float( z ) + r2.y ) * DirectLightingSampleScale;
            ceilingPos.x *= GetBrightnessForTime( blobTime );
            vec3 lightDir = normalize( ceilingPos - hitPos );

            float lightDot = dot( lightDir, normal );
            vec3 ignoreHitPos;
            if ( lightDot > 0.0 && !MarchShadowRay( hitPos, lightDir, ignoreHitPos CACHE ) )
                res.x += 1.0;
        }
    }
    res.x /= float( BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT * BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT );
    
    const float RadiusScale = 1.0 / float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT );
    const float AngleScale = TWOPI / float( BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    for ( int r = 0; r < BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT; r++ )
    {
        for ( int a = 0; a < BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT; a++ )
        {
            // get a weighted point on the hemisphere oriented toward normal.
            // start with random point on unit disc.

            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            float angle = (float( a ) + r2.x) * AngleScale;
            float radius = sqrt( (float( r ) + r2.y) * RadiusScale );

            vec2 discPoint = vec2( cos( angle ), sin( angle ) ) * radius;

            vec3 ambientTestDir = GetHemisphereDirForDiscPoint( normal, discPoint );

            vec3 shadowApproxHitPos;
            if ( MarchShadowRay( hitPos, ambientTestDir, shadowApproxHitPos CACHE ) )
                res.z += BlobEmissionAmountAtPos( shadowApproxHitPos );
            else
                res.y += 1.0;
        }
    }
    res.yz /= float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT * BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    res.y = MIN_AMBIENT + res.y * (1.0 - MIN_AMBIENT);
    
    res.xy *= GetBrightnessForTime( blobTime );
    
    return res;
}

// Function 56
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {
    float res = 1.0, h, t = mint+.1*hash(ro+rd);
    for( int i=0; i<48; i++ ) {
        //  if (t < maxt) {
        h = DE( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += .1;
        //  }
    }
    return clamp(res, 0., 1.);
}

// Function 57
vec3 shade (in vec3 ro, in vec3 rd, in float d) {
    vec3 p = ro + d * rd;
    vec3 nor = normal (p);

    // "material" hard-coded for the moment 
    float mask = smoothstep (1., .05, 30.*cos (50.*p.y)+sin (50.*p.x)+ cos (50.*p.z));
    vec3 albedo = mix (vec3 (.5), vec3 (.2), mask);
    float metallic = .5;
    float roughness = mix (.45, .175, mask);
    float ao = 1.;

    // lights hard-coded as well atm
    vec3 lightColors[2];
    lightColors[0] = vec3 (.7, .8, .9)*2.;
    lightColors[1] = vec3 (.9, .8, .7)*2.;

    vec3 lightPositions[2];
    lightPositions[0] = vec3 (-1.5, 1.0, -3.);
    lightPositions[1] = vec3 (2., -.5, 3.);

	vec3 N = normalize (nor);
    vec3 V = normalize (ro - p);

    vec3 F0 = vec3 (0.04); 
    F0 = mix (F0, albedo, metallic);
    vec3 kD = vec3(.0);
	           
    // reflectance equation
    vec3 Lo = vec3 (.0);
    for(int i = 0; i < 2; ++i) 
    {
        // calculate per-light radiance
        vec3 L = normalize(lightPositions[i] - p);
        vec3 H = normalize(V + L);
        float distance    = length(lightPositions[i] - p);
        float attenuation = 20. / (distance * distance);
        vec3 radiance     = lightColors[i] * attenuation;
        
        // cook-torrance brdf
        float aDirect = pow (roughness + 1., 2.);
        float aIBL =  roughness * roughness;
        float NDF = distriGGX(N, H, roughness);        
        float G   = geomSmith(N, V, L, roughness);      
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       
        
        vec3 kS = F;
        kD = vec3(1.) - kS;
        kD *= 1. - metallic;	  
        
        vec3 nominator    = NDF * G * F;
        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
        vec3 specular     = nominator / max(denominator, .001);  

        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / PI + specular) * radiance * NdotL; 
	    Lo *= shadow (p+.01*N, L);
    }

    vec3 irradiance = vec3 (1.);
    vec3 diffuse    = irradiance * albedo;
    vec3 ambient    = (kD * diffuse) * ao;

    return ambient + Lo;
}

// Function 58
float slight(vec3 p, vec3 ro, vec3 n) {
    vec3 lightPos = vec3(g_time * 4., 2., 4.);
    vec3 l = normalize(lightPos-p);
    
    float lDist = max(length(l), 0.001);
    float atten = 1./(1.0 + lDist*lDist*0.5);	
    vec3 reflection = reflect(-l, n);
    float spec = pow(max( dot(reflection, -normalize(ro)), 0.), 9.); 
        
    return spec*3. *atten;;
}

// Function 59
float MapStreeLight(  vec3 p)
{
  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);
  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   
  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        
  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  
  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  
  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        
  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); 

  return d;
}

// Function 60
vec3 CalcLighting(RayHit hit)
{
    float shadow = hit.shadow;
    
    vec3  sunColor = SunColor * 4.5;
    float sunContr = clamp(dot(hit.surfNorm, SunDir), 0.0, 1.0);
    vec3  sunLight = sunColor * sunContr * shadow;
    
    vec3  skyColor = SkyColor;
    float skyContr = clamp(0.5 + (0.5 * hit.surfNorm.y), 0.0, 1.0);
    vec3  skyLight = skyColor * skyContr;
    
    vec3  ambColor = AmbColor;
    float ambContr = clamp(dot(hit.surfNorm, normalize(SunDir * vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);
    vec3  ambLight = ambColor * ambContr;
    
    return sunLight + skyLight + ambLight;
}

// Function 61
float shadow (in vec3 ro, in vec3 rd)
{
    float result = 1.;
    float t = .1;
    for (int i = 0; i < MAX_ITER; i++) {
        float h = scene (ro + t * rd).d;
        if (h < .00001) return .0;
        result = min (result, 8. * h/t);
        t += h;
    }

    return result;
}

// Function 62
vec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)
{
    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)
    {
        return clamp(dot(n, l.d), 0., 1.) * l.c;
    }
	return vec3(0.);
}

// Function 63
float shadow(vec3 ro, vec3 rd)
{
    float res = 1.0;
    float t = PRECIS * 30.0;
    for( int i=0; i < 30; i++ )
    {
		float distToSurf = map( ro + rd*t );
        res = min(res, 8.0 * distToSurf / t);
        t += distToSurf;
        if(distToSurf < PRECIS || t > DMAX) break;
    }
    
    return clamp(res, 0.0, 1.0);
}

// Function 64
float shadow(in vec3 p, in vec3 l, float ma)
{
    float t = 0.03;
    float t_max = ma;
    
    float res = 1.0;
    for (int i = 0; i < 48; ++i)
    {
        if (t > t_max) break;
        
        float d = map(p + t*l).x;
        if (d < 0.001)
        {
            return 0.0;
        }
        t += d*1.0;
        res = min(res, 20.0 * d / t);
    }
    
    return res;
}

// Function 65
float genShadow(vec3 ro, vec3 rd)
{
    // = distance filed result
    float h = 0.0;

    // current ray position
    float c = 0.001;

    // most nearest distance of scene objects
    float r = 1.0;

    // shadow coef
    float shadowCoef = 0.5;

    // ray marching for shadow
    for (float t = 0.0; t < 50.0; t++)
    {
        h = distFunc(ro + rd * c);

        if (h < EPS)
        {
            return shadowCoef;
        }

        // 現時点の距離関数の結果と係数を掛けたものを
        // レイの現時点での位置で割ったものを利用する
        // 計算結果のうち、もっとも小さいものを採用する
        r = min(r, h * softShadow / c);

        c += h;
    }

    return 1.0 - shadowCoef + (r * shadowCoef);
}

// Function 66
float sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph )
{
    float s = 1.0;
    vec2 r = sphDistances( ro, rd, sph );
    if( r.y>0.0 )
        s = max(r.x,0.0)/r.y;
    return s;
}

// Function 67
vec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )
{
	vec3 norm = OceanNormal(pos);
	float ndotr = dot(ray,norm);

	float fresnel = pow(1.0-abs(ndotr),5.0);
	
	vec3 reflectedRay = ray-2.0*norm*ndotr;
	vec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;	
	refractedRay = normalize(refractedRay);

	const float crackFudge = .0;
	
	// reflection
	vec3 reflection = Sky(reflectedRay);
	float t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );
	
	if ( t > 0.0 )
	{
		reflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );
	}

	
	// refraction
	t=TraceBoat( pos-crackFudge*refractedRay, refractedRay );
	
	vec3 col = vec3(0,.04,.04); // under-sea colour
	if ( t > 0.0 )
	{
		col = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );
	}
	
	col = mix( col, reflection, fresnel );
	
	// foam
	col = mix( col, vec3(1), WaveCrests(pos,fragCoord) );
	
	return col;
}

// Function 68
float calcShadow(vec3 ro, vec3 rd) {
    float sh = 1.;
    float t = 0.1;
    for (int i = int(ZERO); i<20; i++){
        float h = mapDist(ro + rd*t);
        sh = min(sh, smoothstep(0., 1., 4.0*h/t));
        t += clamp(h, 0.1, 0.3);
        if (h<0. || t>8.0) break; 
    }
    return max(sh, 0.);
}

// Function 69
vec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos, vec4 lightParams) {
	float fresnelBias = lightParams.x;
	float fresnelPower = lightParams.y;
	float fresnelScale = lightParams.z;
	float constAttenuation = 9000000.0;
	float linearAttenuation = 0.22;
	float quadraticAttenuation = 0.2;
	float dist = length(lightPos-objPoint);
	float attenuation = constAttenuation / ((1.0+linearAttenuation*dist)*(1.0+quadraticAttenuation*dist*dist));
	float shininess = lightParams.w;
	vec3 I = normalize(objPoint - eyePoint);
	vec3 lightDirection = normalize(lightPos-objPoint);
	vec3 viewDirection = normalize(eyePoint-objPoint);
	vec3 halfVector = normalize(lightDirection + viewDirection);
	float dif = clamp(dot(normalAtPoint, lightDirection), 0.0, 1.0);
	float spec = max(0.0, pow(dot(normalAtPoint, halfVector), shininess));
	float fresnel = clamp(fresnelBias + fresnelScale * pow(1.0 + dot(I, normalAtPoint), fresnelPower), 0.0, 1.0);
	return attenuation * vec4(vec3(mix(spec, dif, fresnel)), 1.0);
}

// Function 70
vec3 shadeBackground(vec3 rayPos, vec3 normal)
{
    return vec3(0.2, 0.2, 0.2);
}

// Function 71
vec2 ShaderBall(vec3 pos)
{
    vec3 spos = pos - vec3(0.0, 1.5, 0.0);
    
    vec2 ts   = vec2(max(Sphere(spos, 1.0), -Sphere(spos, 0.8)), 9.0);                // Hollow top sphere
    vec2 tsi  = vec2(Sphere(spos, 0.725), 2.0);                                       // Inner sphere core
    vec2 tsc  = vec2(Sphere(spos - vec3(0.0, 0.4, 0.8), 0.55), 3.0);                  // Cut into side of top sphere
    vec2 rc   = vec2(Box(RotX(spos, PI * 0.15), vec3(2.0, 0.05, 2.0)), 4.0);          // Ring cut into top sphere
    
    vec2 st   = vec2(Cylinder(pos - vec3(0.0, 0.1, 0.0), vec2(mix(0.8, 0.3, clamp(pos.y - 0.125, 0.0, 1.0)), 0.2)), 5.0);  // Stand wide base      
    vec2 stc  = vec2(Cylinder(Repeat(pos, vec3(0.5, 0.0, 0.5)), vec2(0.125, 1.0)), 6.0);                                   // Stand ridge cuts
    vec2 stm  = vec2(Cylinder(pos - vec3(0.0, 0.35, 0.0), vec2(0.5, 0.35)), 5.0); // Thinner stand middle
    
    st   = S(st, stc);
    st.x = smin(st.x, stm.x, 0.2);                         
    
    vec2 b    = vec2(Cylinder(pos - vec3(0.0, 0.025, 0.0), vec2(1.0, 0.025)), 8.0);    // Base
       
    vec2 result = S(ts, tsc);
         result = S(result, rc);
         result = U(result, tsi);
         result = U(result, st);
         result = U(result, b);
    
    return result;
}

// Function 72
vec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {
    vec3 sd = rp+normal2(rp-rd*EPSILON*40.)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;
    
    //lighting
    vec3 dlc = vec3(0.);
    
   
    vec3 slc = vec3(0.);
    vec3 reflDir = reflect(rd,norm);
    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);
    tReflDir *= sign(dot(tReflDir,reflDir));
    
    #ifdef REFLECTIONS
    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);
    if (rtd < 0.) {
        slc = background(tReflDir);
    } else {
        vec3 rhp = sd+tReflDir*rtd;
        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));
    }
    #endif
    
    vec3 lightDif,lightSpec;
    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);
    dlc += lightDif;
    slc += lightSpec;
    
    float fres = 1.-max(0., dot(-rd,norm));
    
    return (1.-m.metallic)*dlc*m.diffuse +
        	slc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +
        	m.emissive ;
}

// Function 73
void getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {
#if __VERSION__ >= 300
    sphere = lights[index];
#else
    if(index == 0) { sphere = lights[0]; } else
    if(index == 1) { sphere = lights[1]; } else
    if(index == 2) { sphere = lights[2]; } else
    			   { sphere = lights[3]; }
#endif
    intensity = getMaterialFromLibrary(4+index).color;
}

// Function 74
float lightSize () {
    float t = iMouse.z > .0 ? iTime : texture (iChannel1, vec2 (.5)).g;
	return .4 + .1 * cos (t);
}

// Function 75
float calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )
{
	float res = 1.0;
    float t = tmin;
    for( int i=0; i<100; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 76
vec3 directLight(vec3 pos){
    
    vec3 absorption = vec3(1.0);
    vec3 volumeColor, emissionColor;
    
    for(int i = 0; i < MaxSteps; i++){
        float dist = distanceEstimation(pos, volumeColor, emissionColor);
        pos -= LightDir * max(dist, StepSize);
        if(dist < StepSize) {
            float abStep = StepSize * RANDOM;
            pos -= LightDir * (abStep-StepSize);
            if(dist < 0.0){
                float absorbance = exp(-Density*abStep);
                absorption *= absorbance;
                if(maxV(absorption) < 1.0-MaxShadowAbso) break;
            }
        }
        
        if(length(pos) > SceneRadius) break;
    }
    return LightColor * max((absorption+MaxShadowAbso-1.0) / MaxShadowAbso, vec3(0));
}

// Function 77
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        vec2 mapp = map( aopos );
        float dd = mapp.x;
        occ += -(dd-hr)*sca * (isReflection(mapp.y) ? 1.0 : 0.5);
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 78
float treesShadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.02;
#ifdef LOWQUALITY
    for( int i=ZERO; i<50; i++ )
    {
        float kk1, kk2, kk3;
        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );
        res = min( res, 32.0*h/t );
        t += h;
        if( res<0.001 || t>20.0 ) break;
    }
#else
    for( int i=ZERO; i<150; i++ )
    {
        float kk1, kk2, kk3;
        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );
        res = min( res, 32.0*h/t );
        t += h;
        if( res<0.001 || t>120.0 ) break;
    }
#endif
    return clamp( res, 0.0, 1.0 );
}

// Function 79
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    for( float t=mint; t<maxt; )
    {
        float h = map(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        res = min( res, k*h/t );
        t += h;
    }
    return res;
}

// Function 80
vec3 shadeBg(vec3 nml, vec2 fragCoord)
{
	vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);
	vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;
    float t = 16.0;
	vec3 bgLight = normalize(vec3(
		cos(t*0.2/0.954929658551372)*4.0, 
		sin(t/1.1936620731892151)*3.0 - 4.0, 
		sin(t*0.2/0.954929658551372)*8.0
	));
	vec3 sun = vec3(2.0, 1.5, 1.0)*0.75;
	float bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));
	float sunPow = dot(nml, bgLight);
	float sp = max(sunPow, 0.0);
	vec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 0.65);
	bgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.9);
	bgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));
	bgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));
	bgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));
    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);
	return pow(max(vec3(0.0), bgCol), vec3(1.9));
}

// Function 81
id compute_ao_t0()
{
    ao_t0 = AO_DIST / pow(1.0 + AO_DT_FACTOR, float(AO_RAY_ITER-1));
}

// Function 82
vec3 ShadeOcean( vec3 pos, vec3 ray )
{
	vec3 norm = OceanNormal(pos);
	float ndotr = dot(ray,norm);

	float fresnel = pow(1.0-abs(ndotr),5.0);
	
	vec3 reflectedRay = ray-2.0*norm*ndotr;
	vec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;	
	refractedRay = normalize(refractedRay);

	const float crackFudge = .0;
	
	// reflection
	vec3 reflection = Sky(reflectedRay);
	
	// refraction
	
	//vec3 col = vec3(.04,.04,.0); // under-sea colour
	vec3 col = texture( iChannel1, pos.xz/25.0, -100.0 ).xyz * vec3(0.1);
	
	col = mix( col, reflection, fresnel );
	
	// foam
	col = mix( col, vec3(1), WaveCrests(pos) );
	
	return col;
}

// Function 83
void calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {
  	float d = distance(light.position, surface.position);
  	vec3 k = vec3(.06, .08, .09);
  	light.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));

  	// point light
  	vec3 lightDir = normalize(light.position - surface.position);
  	// diffuse
  	float diffuseCoef = max(0., dot(surface.normal, lightDir));
  	vec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;
  	// specular
  	float specularCoef = getSpecular(
        surface,
        lightDir,
        diffuseCoef,
        cameraPos
    );
  	vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); 
    
  	light.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);
  	light.specular = specular;
}

// Function 84
float shadowMarch(vec3 ro, vec3 rd, vec3 lightPos)
{
    float dist = 0.0;
    
    
    float res = 1.0;
    
    float power = 2.0;
    
    for(int i=0; i<MAX_STEPS; i++)
    {
        vec3 pos = ro + dist * rd;
        float d = getDist(pos).x;
        if (d < 0.01)
            return 0.0;
        
		dist += d;
        
        res = min(res, power * d / dist);
        
		if (dist<MIN_DIST || dist>MAX_DIST)
            break;
    }

    return res;
}

// Function 85
vec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )
{
	vec3 halfVec = normalize( viewDir + lightDir );

	float vdoth = saturate( dot( viewDir,	halfVec	 ) );
	float ndoth	= saturate( dot( normal,	halfVec	 ) );
	float ndotv = saturate( dot( normal,	viewDir  ) );
	float ndotl = saturate( dot( normal,	lightDir ) );
    
   	vec3	f = FresnelTerm( specularColor, vdoth );
	float	d = DistributionTerm( roughness, ndoth );
	float	v = VisibilityTerm( roughness, ndotv, ndotl );
    
    vec3 specular;
	specular = lightColor * f * ( d * v * MATH_PI * ndotl );
	return specular;
}

// Function 86
vec3 lighting(Surface surface, vec3 cameraPos, vec3 cameraDir) {
  	vec3 position = surface.position;

  	vec3 color = vec3(0.);
  	vec3 normal = surface.normal;

  	Light directionalLight;
  	directionalLight.position = vec3(.5, 1., .5);
  	directionalLight.intensity = .7;
  	directionalLight.color = vec3(1., 1., 1.);
  	calcDirectionalLight(directionalLight, surface, cameraPos);
    
  	Light pointLight;
  	pointLight.position = vec3(sin(iTime) * 2., 2., 1.);
  	pointLight.intensity = .3;
  	pointLight.color = vec3(1., 1., 1.);
  	calcPointLight(pointLight, surface, cameraPos);
    
  	vec3 diffuse = directionalLight.diffuse + pointLight.diffuse;
  	vec3 specular = directionalLight.specular + pointLight.specular;
    
    // calc ambient
	float occ = ambientOcculusion(surface.position, surface.normal);
  	float amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);
  	vec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);  
    
  	color =
        surface.emissiveColor +
        surface.baseColor * diffuse +
        surface.specularColor * specular +
        ambient;  
  
  	return color;
}

// Function 87
vec4 GetLight(vec3 p) {
    vec3 lightPos[3];
    lightPos[0] = vec3(5, 6, 0);
    lightPos[1] = vec3(-2, 5, 1);
    lightPos[2] = vec3(-4, 10, 10);
    
    vec3 lightCol[3];
    lightCol[0] = vec3(0.5, 0.5, 0.5);
    lightCol[1] = vec3(0.2, 0.2, 0.2);
    lightCol[2] = vec3(0.1, 0.1, 0.1);
    
    vec4 col = vec4(0.0);
    
    for(int i; i<3; i++) {
        vec3 l = normalize(lightPos[i]-p);
        vec3 n = GetNormal(p);
        
        float dif = clamp(dot(n, l), 0.0, 1.0);
        float d = RayMarch(p+n*SURF_DIST*2.0, l);
        if(d<length(lightPos[i]-p)) dif *= 0.1;
        
        col += dif * vec4(lightCol[i], 1.0);
    }
    
    return col;
}

// Function 88
bool in_earth_shadow( vec3 p )
{
	return ( dot( p, sun_direction ) < 0.0 )
		   && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius );
}

// Function 89
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<SHADOW_SAMPLES; i++ )
    {
		float h = dstScene( ro + rd*t ).x;
        res = min( res, 16.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 90
vec3 lightDiffuse(vec3 normal, vec3 light)
{
    float intensity = 0.5 + 0.5 * dot(normal, light);
    // cache useful cividis values for performance
	const int cividisCount = cividis.length() - 1;
	const float cividisScale = float(cividisCount);
    // approximately cividis scale sampling
    intensity *= cividisScale;
    int index = int(round(intensity));
    vec3 color = cividis[index];
    return color;
}

// Function 91
vec2 ssao(vec2 fragCoord) {
    vec2 texCoord = fragCoord / iResolution.xy;
    vec2 texColorSize = iResolution.xy;

    float d = DEPTH(texCoord);
    float scaleBase = 0.25/d;

    vec2 offset[16];
    float rand = hash12(fragCoord);
    vec2 invRes = 1.0 / iResolution.xy;
    
    mat2 m = mat2(INV_SQRT2, INV_SQRT2, -INV_SQRT2, INV_SQRT2);

    float dSample = 2.0*scaleBase;
    float ra = rand*PI_OVER_2;
    vec2 r = vec2(cos(ra), sin(ra));
    offset[ 0] = dSample*vec2( r.x, r.y)*invRes;
    offset[ 1] = dSample*vec2(-r.y, r.x)*invRes;
    offset[ 2] = dSample*vec2(-r.x,-r.y)*invRes;
    offset[ 3] = dSample*vec2( r.y,-r.x)*invRes;

    dSample = 4.0*scaleBase;
    r = m*r;
    offset[ 4] = dSample*vec2( r.x, r.y)*invRes;
    offset[ 5] = dSample*vec2(-r.y, r.x)*invRes;
    offset[ 6] = dSample*vec2(-r.x,-r.y)*invRes;
    offset[ 7] = dSample*vec2( r.y,-r.x)*invRes;

    dSample = 6.0*scaleBase;
    r = m*r;
    offset[ 8] = dSample*vec2( r.x, r.y)*invRes;
    offset[ 9] = dSample*vec2(-r.y, r.x)*invRes;
    offset[10] = dSample*vec2(-r.x,-r.y)*invRes;
    offset[11] = dSample*vec2( r.y,-r.x)*invRes;

    dSample = 8.0*scaleBase;
    r = m*r;
    offset[12] = dSample*vec2( r.x, r.y)*invRes;
    offset[13] = dSample*vec2(-r.y, r.x)*invRes;
    offset[14] = dSample*vec2(-r.x,-r.y)*invRes;
    offset[15] = dSample*vec2( r.y,-r.x)*invRes;

    float deeperCount = 0.0;
    float nearerCount = 0.0;
    for(int i=0; i<16; ++i){
        vec2 texSamplePos = texCoord + offset[i];
        float dsamp = DEPTH(texSamplePos);

        deeperCount += step(d, dsamp);
        nearerCount += step(dsamp, d);
    }

    float shadowIntensity = clamp(1.0 - deeperCount/8.0, 0.0, 1.0);
    float highlightIntensity = clamp(1.0 - nearerCount/8.0, 0.0, 1.0);

    return vec2(shadowIntensity, highlightIntensity);
}

// Function 92
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float cuttingPlane) {
    // bounding volume
    float tp = (maxHei - ro.y) / rd.y;
    if (tp > 0.0) tmax = min(tmax, tp);

    float res = 1.0;
    float t = mint;
    for (int i=0; i < 16; i++) {
		float h = map(ro + rd * t, cuttingPlane).x;
        float s = clamp(4.0 * h / t, 0.0, 1.0);
        res = min(res, s * s * (3.0 - 2.0 * s));
        t += clamp( h, 0.02, 0.10 );
        if (res < 0.005 || t > tmax) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 93
void sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 sph, in float ra, inout float result )
{
    vec3	oc	= ro - sph;
    float	b	= dot( oc, rd );
    float	c	= dot( oc, oc ) - ra * ra;
    float	h	= b*b - c;

    float	res	= (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );

    result	= min( result, res );
}

// Function 94
vec3 sampleIndirectLight(vec3 pos, vec3 normal){
    vec3 dir = getCosineWeightedSample(normal);
    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;
    for(int i = 0; i < Bounces; i++){
        if(!trace(pos, dir, normal)) return light + abso*background(dir);
        sdf(pos, dc, ec);
        light += abso * (ec + dc*directLight(pos, normal));
        abso *= dc;
        dir = getCosineWeightedSample(normal);
    }
    return light;
}

// Function 95
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map( pos + h*nor ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
        if( occ>0.35 ) break;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 96
vec3 TailLights(ray r, float t, float roadWith){
    
	t *= .25;
    float w1 = .25;//light width
    float w2 = w1*1.2;
    const float s = 1./ 10.;
    float m = 0.;
    for(float i = 0.;i< 1.;i += s){
        float n =N(i);
        
        if(n > .5) continue;//jump to top,cut % light
         
        float lane = step(.25,n);//n = 0~ .5
        
        float ti = fract(t + i);
        float z =  100.- ti*100.;
        //fract(t + i), if i=.9,fract's value will rise to 1 in short time
        float fade = ti*ti*ti*ti;
        float focus = S(.8, 1., ti);
        float size = mix(.05, .03, focus);
        
        float laneShift = S(.99, .95, ti);
        float x = 1.5 - lane*laneShift;//control rightside car'lan
        roadWith *= .3;
        
        float blink = step(0. ,sin(t*500.))*7.*lane*step(.96,ti);//return 0 | 7 lane control witch car blink
        //step(.96,ti), car at far point ti = 0, instead close poing ti = 1,
        m += Bokeh(r, vec3(roadWith + x - w1, .15 ,z ), size, .1)*fade;
        m += Bokeh(r, vec3(roadWith + x + w1, .15 ,z ), size, .1)*fade;
        
        m += Bokeh(r, vec3(roadWith + x - w2, .15 ,z ), size, .1)*fade;//extra light effect
        m += Bokeh(r, vec3(roadWith + x + w2, .15 ,z ), size, .1)*fade*(1. + blink);//1|8 right taillight
        
        float ref = 0.;
        ref += Bokeh(r, vec3(roadWith + x - w2, -.15 ,z ), size*3., 1.)*fade;
        ref += Bokeh(r, vec3(roadWith + x + w2, -.15 ,z ), size*3., 1.)*fade*(1. + blink*.1);
        
        m += ref*focus;
        
    }
    
    
    return  vec3(1., .1, .03) *m;
}

// Function 97
vec3 shadePBR (in vec3 ro, in vec3 rd, in float d, in int id)
{
    vec3 p = ro + d * rd;
    vec3 nor = normal (p);

    // "material" hard-coded for the moment
    vec3 albedo1 = vec3 (.975);
    vec3 albedo2 = vec3 (.75, .4, .25);
    vec3 albedo = (id == 1) ? albedo1 : albedo2;
    float metallic  = (id == 1) ? .1 : .9;
    float roughness = (id == 1) ? .9 : .1;
    float ao = 1.;

    // lights hard-coded as well atm
    vec3 lightColors[2];
    lightColors[0] = vec3 (.8, .8, .9) * 20.;
    lightColors[1] = vec3 (.9, .8, .8) * 20.;

    vec3 lightPositions[2];
    lightPositions[0] = p + vec3 (.5, .75, -1.5);
    lightPositions[1] = p + vec3 (-.3, .25, -.5);

	vec3 N = normalize (nor);
    vec3 V = normalize (ro - p);

    vec3 F0 = vec3 (0.04); 
    F0 = mix (F0, albedo, metallic);
    vec3 kD = vec3(.0);
		           
    // reflectance equation
    vec3 Lo = vec3 (.0);
    for(int i = 0; i < 2; ++i) 
    {
        // calculate per-light radiance
        vec3 L = normalize(lightPositions[i] - p);
        vec3 H = normalize(V + L);
        float distance    = length(lightPositions[i] - p);
        float attenuation = 1. / (distance * distance);
        vec3 radiance     = lightColors[i] * attenuation;
	        
        // cook-torrance brdf
        float aDirect = .125 * pow (roughness + 1., 2.);
        float aIBL = .5 * roughness * roughness;
        float NDF = DistributionGGX(N, H, roughness);        
        float G   = GeometrySmith(N, V, L, roughness);      
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);
	        
        vec3 kS = F;
        kD = vec3(1.) - kS;
        kD *= 1. - metallic;	  
	        
        vec3 nominator    = NDF * G * F;
        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
        vec3 specular     = nominator / max(denominator, .001);  

        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / PI + specular) * radiance * NdotL; 
	    Lo *= shadow (p, L);
    }

    vec3 ambient = (kD * albedo) * ao;

    return ambient + Lo;
}

// Function 98
float directionalLightDiffuse(vec3 nor, vec3 ldir) {
    return clamp(dot(nor, -ldir), 0.0, 1.0);
}

// Function 99
float shadow(vec3 lig, vec3 cam){ 
    float l = distance(cam,lig);
    vec3 dir = normalize(lig-cam);
    for(float i = 0.3; i < l;){ //i = length of ray
        vec3 p = cam + i * dir;
    	float h = map(p).Md; //smallest distance from all objects to point
    	if(h < MinDist){
			return(0.0); //successfully hit something at point "point", make dark
        }
        i += h;
    }
    return(1.0); //no collision, make light
}

// Function 100
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m )
{
    float eps = 0.0015;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps, t );
    float kk;

    vec3 mateD = vec3(0.2,0.16,0.11);
    vec3 mateS = vec3(0.2,0.12,0.07);
    float mateK = 0.0;


    vec3 dpdx = t*drddx;
    vec3 dpdy = t*drddy;
    
    if( m<0.5 )
    {
        vec3 onor = nor;
        vec3 d = pos - vec3(0.0,1.0,0.0);
        
        mateD = vec3(0.15,0.15,0.15)*1.1;
        mateK = 0.2;
        
        mateS = vec3(0.4,0.1,0.1)*1.0;
        mateD *= 0.05 + 2.0*pow(1.0-texcube( iChannel3, pos*0.25, nor, 1.0, dpdx*0.25, dpdy*0.25 ).xyz, vec3(6.0));

        float h = clamp( pos.y, 0.0, 1.0 );
        vec3 o = 0.12 * sin( h*3.0 + vec3(0.0,2.0,4.0) );
        o = o*4.0*h*(1.0-h) * h;
        d = pos - o*vec3(1.0,0.0,1.0);
        float an = atan(d.x,d.z);
        vec2 uv1 = vec2( an*8.0, length(d.xz)*2.0  );
        vec2 uv2 = vec2( an*1.0, d.y*1.0  );
  
        // bump
        float bt = smoothstep( 0.7, 0.9, pos.y );
        vec3 bn1 = 0.1*(-1.0+2.0*texture( iChannel1, 0.05*uv1 ).xyz);
        vec3 bn2 = 0.4*(-1.0+2.0*texture( iChannel1, 0.05*uv2 ).xyz);
        vec3 onn = 0.1*(-1.0+2.0*texcube( iChannel1, pos, nor, 1.0, dpdx, dpdy ).xyz );
        nor = normalize( nor + mix(bn2,bn1,bt) + onn );

            
        float isd = smoothstep( 0.5, 0.6, -onor.y );
        mateD = mix( mateD, vec3(0.25,0.16,0.11), isd );

        mateD = mix( mateD, vec3(0.08,0.08,0.05)*0.2, 0.92*(1.0-smoothstep(0.1,0.5,pos.y)) );
    }
	else if( m<1.5 )
    {
        mateD = vec3(0.08,0.08,0.06)*0.55;
        mateS = vec3(0.0);
        mateK = 1.0;
        
        mateD *= 0.7 + 2.0*texture( iChannel2, pos.xz*0.008, -8.0 ).xyz;

        float ll = smoothstep( 0.2, 0.3, textureGrad(iChannel3,pos.xz*.1, dpdx.xz*0.1, dpdy.xz*0.1).x );
        ll *= smoothstep(0.5,1.0,nor.y);
        mateD = mix( mateD, vec3(0.4,0.15,0.15)*0.07, ll);
    }
	else if( m<2.5 )
    {
        mateK = 1.0;
        mateD = vec3(0.11,0.11,0.11);
        mateS = vec3(0.7,0.3,0.1)*2.0;
    }
	else //if( m<3.5 )
    {
        mateS = vec3(0.0,0.0,0.0);
        mateK = 0.2;
        
        mateD = vec3(0.65,0.6,0.45);
        mateD *= 0.2 + 0.8*texcube( iChannel2, pos*0.07, nor, 1.0, dpdx*0.7, dpdy*0.7 ).x;
        mateD *= .14;
    }
    
    
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor, t );
    float sss = calcSSS( pos, nor, t );

    
        
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float sha = softshadow( pos, sunDir, 32.0 ); 
    dif1 *= sha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );

    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );

    vec3 col = 6.0*vec3(1.6,1.0,0.5)*dif1;//*(0.5+0.5*occ);
    col += 6.0*pow( spe1, 16.0 )*dif1*mateK;
    col += 2.0*fre*(0.1+0.9*dif1);//*occ;
    col += sss*mateS*4.0;
    col += 4.0*vec3(0.2,0.6,1.3)*occ*(0.5+0.5*nor.y);
    col += 3.0*vec3(0.2,0.6,1.3)*occ*smoothstep( 0.0, 0.5, reflect( rd, nor ).y )*occ;
    col += 1.0*vec3(0.2,0.2,0.2)*bou*(0.5+0.5*occ);
    
    col *= mateD;
    
    t *= 0.5;
    col = mix( col, vec3(0.3,0.3,.3)*0.4, 1.0-exp( -0.1*t ) );
    col = mix( col, vec3(0.4,0.5,.6)*0.4, 1.0-exp( -0.001*t*t ) );

    col *= 0.9;

    return col;        
}

// Function 101
float voronoi_column_ao( vec2 x, vec4 mc )
{
    vec2 n = floor(x);
    vec2 f = fract(x);

    vec2 mr = mc.xy - x;
    vec2 mg = mc.zw - n;
    
    float mh = hash12( n + mg );
    
    // Set center of search based on which half of the cell we are in,
    // since 4x4 is not centered around "n".
    mg = step(.5,f) - 1.;

    float mao = 0.;
    for( int j=-1; j<=2; j++ )
    for( int i=-1; i<=2; i++ )
    {
        vec2 g = mg + vec2(float(i),float(j));
        vec2 o = hash22( n + g );
        vec2 r = g + o - f;

        if( dot(mr-r,mr-r)>eps ) // skip the same cell
        {
            float d = dot( 0.5*(mr+r), normalize(r-mr) );
            // Get height of the column
            float h = hash12( n + g );
            float ao = clamp((h - mh)*2.,0.,.5)*max(0., 1. - d*4.);
            mao = max(mao, ao);
        }
    }

    return mao;
}

// Function 102
vec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, float matID, in vec3 uvw, in float info, in vec3 sunDirection )
{
	
    vec3 rgb = vec3(0.0);
	
    // ground
    if( matID<0.5 )
    {
		float f = grassDistr( pos.xz ).x;
			
		float rs = 1.5;
		vec3 stones = texture(iChannel3,rs*pos.xz).xyz;
		vec3 nnoise = texture( iChannel1, pos.xz*0.5 ).xyz;

        // dirt
 		vec3 ground = vec3(0.04,0.03,0.01);
		ground *= 0.33 + 1.25*nnoise.x;
		ground = mix( ground, ground+0.02, smoothstep( 0.2, 0.5, stones.x ) );

		// frass
		vec3 grass = vec3(0.1,0.1,0.0);
        // color variation		
		grass += 0.015*sin( nnoise.x*10.0 + vec3(0.0,1.0,2.0) );
        // flowers		
		float fl = smoothstep( 0.5, 0.6, texture(iChannel3,10.0*pos.xz).z ) ;
		fl *= smoothstep( 0.3, 0.35, nnoise.z );
		grass = mix( grass, vec3(0.4,0.3,0.1), fl );
		
		rgb = mix( ground, grass, f );
		
		rgb *= 0.3 + 0.7*texture( iChannel2, pos.xz*2.0 ).x;
		
        //bump		
		nor.x -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz+vec2(0.05,0.0)).x) - smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz-vec2(0.05,0.0)).x));
		nor.z -= (1.0-f)*1.0*(smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz+vec2(0.0,0.05)).x) - smoothstep( 0.2, 0.5, texture(iChannel3,rs*pos.xz-vec2(0.0,0.05)).x));
		nor = normalize( nor );
    }
	// trees
    else if( matID<1.5 )
    {
        rgb = vec3(0.35,0.1,0.0);
		
		rgb = mix( rgb*0.15, vec3(0.2,0.12,0.03), smoothstep( 0.0, 1.0, uvw.y ) );
		
		float tt = texturize( iChannel1, 1.5*pos*vec3(1.0,0.5,1.0), nor ).x;
		rgb *= 0.2+1.5*tt;
		
		tt = texturize( iChannel1, 0.03*pos, nor ).x;
		
		float ff = texturize( iChannel1, 1.5*pos, nor ).x;
		float green = (1.0-smoothstep(0.0, 0.5, uvw.x*4.0 - tt + 0.1));
		rgb = mix( rgb, 2.4*vec3(0.045,0.05,0.00)*ff, 0.8*green );
		
		// bump
		vec2 cuv = vec2( uvw.x*3.0, info );
		float bu = 0.0;
		bu = 0.5 + 0.25*green;
		nor = normalize( nor + bu * (-1.0 + 2.0*texture( iChannel0, cuv ).xyz) );
	}   
    // mushrooms
    else if( matID<2.5 )
    {
        // base color		
		vec3 tcol = mix( vec3(0.1,0.01,0.00), vec3(0.14,0.04,0.0), pow( clamp(1.0+dot(rd,nor),0.0,1.0), 2.0 ) );
		
        // color variation		
		tcol += 0.03*sin( uvw.x*10.0 + vec3(0.0,1.0,2.0) );
		
		// white
        vec2 uv = vec2(uvw.y,info);
		vec2 iuv = floor(uv*9.0);
		vec2 fuv = fract(uv*9.0 );
		uv = fuv - 0.5 + 0.25*(-1.0+2.0*hash2( iuv ));
		uv *= 0.5 + 0.5*hash( iuv );
		float f = 1.0 - smoothstep( 0.1, 0.3, length( uv ) );
		f *= smoothstep( 0.3, 0.31, hash( iuv.yx*1.3 ) );
		f *= smoothstep( 0.4, 0.5, nor.y );
		rgb = mix( tcol, vec3(0.23,0.21,0.19), f );


		//float an = clamp(0.5 + 0.5*(mushroomAnim( iTime*(1.0+uvw.x) + 6.28*uvw.x )-1.0)/0.1,0.0,1.0);
        //rgb *= 0.25 + 2.5*an*vec3(1.0,0.7,0.5);
		
		rgb *= 0.9;
	}
	
	// lighting terms
	float occ = uvw.z;
	float sha = softshadow( pos, sunDirection, 64.0, 0.0 );
    float sun = clamp( dot( nor, sunDirection ), 0.0, 1.0 );
    float sky = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );
    float ind = clamp( dot( nor, normalize(sunDirection*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );
	float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0 ), 5.0 );
	
	float spe = pow( clamp( dot( reflect( rd, nor ), sunDirection ), 0.0, 1.0 ), 16.0 );
	
    // compute lighting
    vec3 lin  = 3.5*sun*vec3(1.75,1.30,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));
         lin += 2.5*sky*vec3(0.82,0.75,0.50)*occ;
         lin += 1.1*ind*vec3(0.30,0.35,0.25)*occ;
         lin += 6.0*spe*sha*(0.5+0.5*fre);
         lin *= 1.0 + 1.0*fre*occ*vec3(1.5,1.0,0.5);
    for( int i=0; i<7; i++ )
    {
        vec3 lig = lpos[i].xyz - pos;
        float llig = dot(lig,lig);
        float im = inversesqrt( llig );
        lig = lig * im;
		lin += vec3(1.0,0.5,0.2)*1.5*lpos[i].w * clamp(dot(lig,nor),0.0,1.0)*im*im*occ;
	}
			
	return rgb * lin * 1.3;
}

// Function 103
float shadow(vec3 l) {
    float shad=1.0;
    vec3 p=s+n*0.1+l*0.1;
    float dd=0.;
    for(int i=0;i<50; ++i) {
        float d=map(p);
        //shad=min(shad,(abs(d)-.1)*10.);
        if(d<0.1) {
            shad=0.0;
            break;
        }
        if(dd>20.) break;
        p+=l*d;
        dd+=d;
    }
    return shad;
}

// Function 104
vec4 analyticLight(vec3 pos, vec3 norm, LineLight light)
{
    vec3 lineVec = light.stop - light.start;
    vec3 startToPos = light.start - pos;
    
    float a = dot(lineVec, lineVec);
    float b = 2.0 * dot(lineVec, startToPos);
    float c = dot(startToPos, startToPos);
    
    float delt = b*b-4.0*a*c;
    
    float I0 = (-(4.0*a+2.0*b)/sqrt(a+b+c) + 2.0*b / sqrt(c))/delt;
    float Ix = ((2.0*b+4.0*c)/sqrt(a+b+c) - 4.0*c / sqrt(c))/delt;
    
    float diffuse = dot(norm, lineVec) * Ix + dot(norm, startToPos) *I0;
    
    return light.color * diffuse;
}

// Function 105
vec3 getPointLightVector(vec3 p) {
	
    float a = iTime * 2.5;
    vec3 lp = vec3(cos(a),sin(a),.015)*4.5;
    
    return lp - p;
   
}

// Function 106
void doShadowColor(in ray primaryRay, inout vec4 col) {
	vec4 returnColor = vec4(0.0);
	vec2 shadowUV;
	vec2 shadowT;
	int shadowId;
	float shadowCheckDelta = light.w;
	ray shadowRay;
	shadowRay.lightColor = primaryRay.lightColor;
	shadowRay.transmittance = primaryRay.transmittance;
	vec3 pos = primaryRay.origin + primaryRay.rayLength*primaryRay.direction;
	shadowRay.origin = pos - 0.001*primaryRay.direction;
	for (int i = 0; i < 7; i++) {
		//soft shadows
		if (i == 0) {
			vec4 tempLight = light;
			tempLight.x += shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else if (i == 1) {
			vec4 tempLight = light;
			tempLight.x -= shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else if (i == 2) {
			vec4 tempLight = light;
			tempLight.y += shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else if (i == 3) {
			vec4 tempLight = light;
			tempLight.y -= shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else if (i == 4) {
			vec4 tempLight = light;
			tempLight.z += shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else if (i == 5) {
			vec4 tempLight = light;
			tempLight.z -= shadowCheckDelta;
			shadowRay.direction = normalize(tempLight.xyz-pos);
		}
		else
			shadowRay.direction = normalize(light.xyz-pos);
		shadowId = intersect(shadowRay, shadowT, shadowUV);
		vec3 shadowHit = shadowRay.origin + shadowT.x * shadowRay.direction;
		
		//if we have a non-negative id, we've hit something
		if (shadowId >= 0 && primaryRay.lastHitObject >= 0) {
			vec4 tempColor;
			if (light.y > 0.0) {
				if (primaryRay.lastHitObject != 1
					&& shadowId == 1
					&& length(light.xyz-shadowRay.origin) > length(shadowHit-shadowRay.origin)) {
					//shade objects that are shadowed by the window
					vec3 nor = sceneWindow.xyz;
					shadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);
					shadowRay.lightColor *= 1.0 - vec4(Voronoi(shadowUV),1.0);
					shadowRay.transmittance = primaryRay.transmittance * glassTransmission;
					tempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);
				}
				else if (primaryRay.lastHitObject == 1) {
					//shade the back side of the window
					vec3 nor = -sceneWindow.xyz;
					shadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);
					shadowRay.lightColor *= vec4(Voronoi(shadowUV),1.0);
					shadowRay.transmittance = primaryRay.transmittance * glassTransmission;
					tempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);
				}
				if (primaryRay.lastHitObject != 1 && shadowId != 1) {
					//shadows for everything else in the scene
					shadowRay.lightColor = shadowRay.lightColor;
					shadowRay.transmittance = 0.5*primaryRay.transmittance;
					tempColor = mix(shadowRay.lightColor, col, 1.0-shadowRay.transmittance);
				}
			}
			else if (primaryRay.lastHitObject >= 0) {
				//before "sunrise"
				shadowRay.lightColor = shadowRay.lightColor;
				shadowRay.transmittance = 0.5*primaryRay.transmittance;
				tempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);
			}
			returnColor += tempColor;
		}
	}
	//if we use a number slightly higher than our iteration count,
	//then we get dark, but not black, shadows.  This also washes
	//out the color of the color of the glass, so it's kind of a
	//trade-off.
	col -= returnColor*(1.0/8.5);
}

// Function 107
float AO(vec3 p, vec3 n)
{
	float dlt = 0.1;
	float oc = 0.0, d = 1.0;
	for(int i = 0; i<6; i++)
	{
		oc += (float(i) * dlt - scene(p + n * float(i) * dlt)) / d;
		d *= 2.0;
	}
	return clamp(1.0 - oc, 0.0, 1.0);
}

// Function 108
float skyshade(vec3 norm) {
  float d = pow(norm.z+0.3,2.)*pow(norm.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;
  return sqrt(sqrt(d))*0.8+0.2;
}

// Function 109
bool shadowRaySceneIntersection( in Ray ray, in float distMin ) {
    
}

// Function 110
vec3 getLight(vec2 uv)
{
    float idw=iDate.w+(CLOCK_OFFSET*3600.);
    float dayn=mod((((idw)/((86400.)))),1.);

    vec2 res=astro(
        vec4(iDate.x,(ANIM_YEAR==1?mod(iTime,12.):iDate.y)+1.,iDate.z,(86400.*dayn)+86400.),
        vec2(remap(uv.x,0.,1.,-180.,180.,true),remap(uv.y,0.,1.,-90.,90.,true)) );

    return vec3(res,dayn);

}

// Function 111
vec3 shadeTerrain( in vec3 ro, in vec3 rd, in float t, float m )
{
    vec3 pos = ro + rd * t;
    vec3 nor = calcNormalTerrain( pos, 0.01 );
    vec3 hal = normalize( sundir - rd );
    
    vec3 col = texture( iChannel0, 0.01*pos.xz ).xyz*0.14 * vec3(1.1,1.0,0.9);
    

    float dif = clamp( dot(sundir,nor), 0.0, 1.0 );
    float spe = clamp( dot(nor,hal), 0.0, 1.0 );
    float amb = clamp( 0.3 + 0.7*nor.y, 0.0, 1.0 );
    //dif *= calcSoftshadowTerrain( pos+nor*0.1, sundir, 32.0 );
    vec3 lig = dif*vec3(3.0,2.0,1.5)*2.0 + pow(spe,8.0)*3.0*dif*4.0 + vec3(0.5,0.6,1.0)*amb;
        
    col *= lig;

    return col;
}

// Function 112
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 32; 
    
    ro += n*.002;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), .0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .035, .35); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 113
vec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in vec4 sph )
{
    vec3 ref = reflect(rd,nor);
    float occ = occlusion( pos, nor );
    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);
    
    occ = occ*0.5 + 0.5*occ*occ;
    vec3 lig = vec3(occ)*vec3(0.9,0.95,1.0);
    lig *= 0.7 + 0.3*nor.y;
    lig += 0.7*vec3(0.3,0.2,0.1)*fre*occ;
    lig *= 0.9;

    
    lig += 0.7*smoothstep(-0.05,0.05,ref.y )*occ*shadow( pos, ref ) * (0.03+0.97*pow(fre,3.0));

    return lig;
}

// Function 114
float shadow( in vec3 ro, in vec3 rd )
{
    float res = 0.0;
    float tmax = 20.0;
    
    float t = 0.001;
    for(int i=0; i<40; i++ )
    {
        float h = f(ro+rd*t).x;
        if(t>tmax) break;
        t += h;
    }

    if( t>tmax ) res = 1.0;
    
    return res;
}

// Function 115
vec3 LightColor(int id)
{
	return texture(iChannel0,vec2(1, float(id))/iResolution.xy + hpo).yzw;   
}

// Function 116
float shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)
{
	float light_visibility = 1.;
	float ph = 1e5;
    float td = dir.w;
	pos.w = map(pos.xyz, co);
	for (int i = min(0, iFrame); i < 32; i++) 
    {
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = map(pos.xyz, co);
		float y = pos.w*pos.w/(2.0*ph);
        float d = (pos.w+ph)*0.5;
		float angle = d/(max(0.00001,dir.w-y-td)*light_angle);
        light_visibility = min(light_visibility, angle);
		ph = pos.w;
		if(dir.w >= distance2light) break;
		if(dir.w > maxd || pos.w < mind*dir.w) return 0.;
    }
	return 0.5 - 0.5*cos(PI*light_visibility);
}

// Function 117
vec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir)
{
	float h = dot(sunLight,normal);
	mat = mat * sunColour*(max(h, 0.0));
	mat += vec3(0.04, .02,.02) * max(normal.y, 0.0);
	return mat;
}

// Function 118
float calc_soft_shadows(in vec3 ro, in vec3 rd, in float tmin, in float tmax, const float k) {
    float res = 1.0;
    float t = tmin;
    for (int i = 0; i < 50; i++) {
        float h = sdf(ro + rd * t);
        res = min(res, k * h / t);
        t += clamp(h, 0.02, 0.20);
        if (res < 0.005 || t > tmax) {
            break;
        }
    }
    return clamp(res, 0.0, 1.0);
}

// Function 119
vec3 getLightColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {
    vec3 difColor = vec3(18.4, 15.6, 8.0);

    // main light
    vec3 lightDir = normalize(vec3(-lightPos.x, -125.0, -lightPos.z) - pos);
    float lightDist = length(vec3(-lightPos.x, -125.0, -lightPos.z) - pos);
    float dif = max(0.0, dot(nor, lightDir));
    vec3 h = normalize(-rd + lightDir);
    float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 4.0);
    vec3 lightColor = dif * difColor * (1.0 / lightDist);
    lightColor += 0.25 * dif * spe * difColor;

    lightDir = normalize(vec3(-lightPos.x, 350.0, -lightPos.z) - pos);
    float sha = clamp(raymarchShadows(pos, lightDir, 0.5, 500.0), 0.0, 1.0);
    float id = obj.x;
    if (id != ID_LIGHT && id != ID_CEILING) lightColor *= sha;

    // light bounce on back wall
    lightDir = normalize(vec3(-278.0, -274.4, -55.0) + pos);
    lightDist = length(vec3(-278.0, -274.4, -55.0) + pos);
    dif = max(0.0, dot(nor, lightDir));
    h = normalize(-rd + lightDir);
    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);
    lightColor += dif * vec3(0.25, 0.175, 0.1) * (1.0 / lightDist);
    lightColor += 0.5 * dif * spe * vec3(0.25, 0.175, 0.1);

    // light bounce on right wall
    lightDir = normalize(vec3(-556.0, -274.4, -279.6) - pos);
    lightDist = length(vec3(-556.0, -274.4, -279.6) - pos);
    dif = max(0.0, dot(nor, lightDir));
    h = normalize(-rd + lightDir);
    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);
    lightColor += dif * vec3(0.0, 0.5, 0.0) * (1.0 / lightDist);
    lightColor += 0.5 * dif * spe * vec3(0.0, 0.5, 0.0);

    // light bounce on left wall
    lightDir = normalize(vec3(0.0, -274.4, -279.6) - pos);
    lightDist = length(vec3(0.0, -274.4, -279.6) - pos);
    dif = max(0.0, dot(nor, lightDir));
    h = normalize(-rd + lightDir);
    spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);
    lightColor += dif * vec3(1.5, 0.0, 0.0) * (1.0 / lightDist);
    lightColor += 0.5 * dif * spe * vec3(1.5, 0.0, 0.0);

    float amb = clamp(0.75 + 0.25 * nor.y, 0.0, 1.0);
    lightColor += 0.015 * amb * difColor;

    return lightColor;
}

// Function 120
float softshadow( in vec4 ro, in vec4 rd, in float mint) {
        	float res = 1.0;
            float h,t = mint;
             for( int i=0; i<15; i++ ) {
                 h = map( ro + rd*t ).x;
                  res = min( res, 7.*h/t );
                   t += 0.028;
             }
              return clamp( res-.6, 0.0, 1.0 );
        }

// Function 121
float SSAO_(vec2 coord)
{
    float cd = depth(coord);
    float screenRadius = 0.5 * (AOradius / cd) / 0.53135;
        
    float li = 0.0;    
    float count = 0.0;
    for(float i=0.0; i<Samples; i++)
    {
    
        vec2 xi = (Hammersley(uint(i), uint(Samples)) *vec2(2.,1.) -vec2(1.,.5)  )* 3.14;            
        vec3 p = vec3(sin(xi.x)*cos(xi.y),cos(xi.x)*cos(xi.y),sin(xi.y));
        
        //vec3 p =sphereVolumeRandPoint();
        vec2 sp = vec2(coord.x + p.x * screenRadius, coord.y + p.y * screenRadius);
         
        float d = depth(sp);
        float at = pow(length(p)-1.0, 2.0);
        li += step(cd + p.z * AOradius, d) * at;
        count += at;
    }
    li/= count;
    

    
    //object border highlight
    float li3 =0.,w=0.;
    for(float lod =1. ;lod<=4.;lod++){
        float acd = avgdepth(coord,lod);
        w+=pow(.5, lod);
        li3 += step(cd ,acd)  *pow(.5, lod);
    }   
    li3/=w;
     return 1.*(li*1. +li3 *.5);
}

// Function 122
vec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos) {
    vec3 dir = lightPos - p;
    vec3 eyeDir = eye - p;
    vec3 I = normalize(dir);
    const vec3 color0 = vec3(0.0470588, 0.1921569, 0.2980392);
    const vec3 color1 = vec3(0.0470588, 0.3450980, 0.4078431);
    const vec3 color2 = vec3(0.1294117, 0.5137254, 0.6901961);
    const vec3 color3 = vec3(0.1686274, 0.7176471, 0.8156863);

    vec3 diffuse = vec3(max(dot(normal, I), 0.));

    vec3 diffuse0 = clamp(diffuse * color0.rgb, 0., 1.);
    vec3 diffuse1 = clamp(diffuse * color1.rgb, 0., 1.);
    vec3 diffuse2 = clamp(diffuse * color2.rgb, 0., 1.);
    vec3 diffuse3 = clamp(diffuse * color3.rgb, 0., 1.);

    vec3 refl = normalize(-reflect(I, normal));
    float spec = max(dot(refl, normalize(eyeDir)), 0.);

    const vec3 spec_clr = vec3(.8, .9, 1.);
    float dst = clamp(length(eyeDir),1. , 500.);
    spec = pow(spec, 0.3 * 300.)* pow(.85, dst);

    spec = clamp(spec, 0., 1.);
    
    vec3 Ispec = spec * spec_clr;
    
    float dist = length(eyeDir);
    float atten = pow(0.93, dist * 7. );
    float deep = occlusion(p, normal) * atten;
    const float one_of_third = 1./3.;
    
    // Some logic workaround, hard to say what is better from performance reason
    float third1 = max(0., sign(one_of_third - deep));
    float third2 = (1. - third1) * max(0., sign(2. * one_of_third - deep));
    float third3 = (1. - third1) * (1. - third2);
        
    return Ispec + third1 * mix(diffuse0, diffuse1, deep * 3.) + 
        third2 * mix(diffuse1, diffuse2, (deep - one_of_third) * 3.) +
        third3 * mix(diffuse2, diffuse3, (deep - 2. * one_of_third) * 3.)
        ;
}

// Function 123
ShadeData SetShadeData( vec3 pos, vec3 ray, vec3 normal, float shadow, float t )
{
	ShadeData s;
	s.pos = pos;
	s.ray = ray;
	s.normal = normal;
	s.shadow = shadow;
	s.t = t;
	return s;
}

// Function 124
vec3 Sample_PointLight(vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    vec3 pl = LightPos;
    vec3 vecl = pl - p;
    vec3 L = normalize(vecl);
    float d2 = dot(vecl, vecl);

    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;
    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);

    if(hit && t2*t2 < d2) return vec3(0.0);
        
    float att = 1.0 / d2;

    return Frostbite_R(V, N, L, albedo, roughness, F0) * att * Intensity;
}

// Function 125
vec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,
               in float occ,
               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,
               in vec3 matGamma )
{
    vec3 col = vec3(0.0);

    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );
    
    float sfre = 0.04 + 0.96*pow( fre, 5.0 );
    
    float pn = exp2( 10.0*(1.0-matRough) );
    

    // sun light
    {
        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;
        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));
        float dif = clamp( dot(sun,nor), 0.0, 1.0 );
        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );
        vec3 hal = normalize( sun - rd );
        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );
        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);
        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;
    }

    // sky light
    {
        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;
        float dif = 0.5 + 0.5*nor.y;
        col += matColor * skyColor * dif * occ;
        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;
    }

    // bounce light
    {
        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;
        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);
        col += matColor * bouColor * dif * occ;
    }

    col += fre*matColor*occ*matSSS;
    col = pow( max(col,0.0), matGamma );

    return col;
}

// Function 126
float cShadow( in vec3 start, in vec3 ldir, in float md, in float p )
{    
	float t = EPSILON*4.0;
	float res = 1.0;
    for ( int i = 0; i < S_STEPS; ++i )
    {        
        float d = csDist( start + ldir * t );
        if ( d < EPSILON )
            return 0.0;
		
		res = min( res, p * d / t );
        t += d*.25;
		
		if ( t > md)
			break;
    }
    return res;
}

// Function 127
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

	float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 128
float calcAO(in vec3 p, in vec3 n){

	float sca = 5., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.1/5.; 
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);
}

// Function 129
vec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)
{
    vec3 color = vec3(1.0);
    
    vec2 gridRep = mod(position.xy, vec2(QUAD_SIZE)) / float(QUAD_SIZE) - 0.5;
    
    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));
    grid = min(grid,abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));
        
    float lineSize = 0.8 * length(fwidth(position)) / float(QUAD_SIZE);
    
    color *= smoothstep(lineSize,0.0,grid);
    color = color * 0.75 + 0.25;
    
    float ambient = 0.1;
    float diffuse = 0.5 * -dot(normal,direction);
    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction,normal)));
    
    color *= vec3(ambient + diffuse + pow(specular,5.0));

    color *= smoothstep(12.0,6.0,length(position));
    
    return color;
}

// Function 130
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )
{
    vec3 lin = vec3(0.0);

    vec3  lig = normalize(vec3(1.0,0.7,0.9));
	float cos_Ol = max(0.0, dot(nor, lig));
    vec3 h = normalize(lig - rd);
    float cos_Oh = max(0.0,dot(nor, h));
    float dif = cos_Ol;
    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(0.8,0.7,0.6)*sha;
    
    lin += vec3(0.20,0.30,0.30);

    
    vec3 col = mal.rgb*lin;

    // specular
    col += cos_Ol * pow(cos_Oh,40.0);
    
    // envmap
    col += mal.w*texture(iChannel0, reflect(rd,nor)).rgb;
    
    // fog    
    //-----------------------------
	col *= exp(-0.01*dis*dis);

    return col;
}

// Function 131
float ObjAO (vec3 ro, vec3 rd)
{
  float ao, d;
  ao = 0.;
  for (int j = VAR_ZERO; j < 8; j ++) {
    d = float (j + 1) / 16.;
    ao += max (0., d - 3. * ObjDf (ro + d * rd));
  }
  return 0.6 + 0.4 * clamp (1. - 0.2 * ao, 0., 1.);
}

// Function 132
float calcAO(in vec3 p, in vec3 n)
{
	float ao = 0.0, l;
    const float maxDist = 3.;
	const float nbIte = 5.;
	//const float falloff = .9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + .0)*.5/nbIte*maxDist;        
        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 133
void shaderNuSan( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)
{
  vec2 uv = vec2(fragCoord.x / resolution.x, fragCoord.y / resolution.y);
  uv -= 0.5;
  uv /= vec2(resolution.y / resolution.x, 1);

  float rand=rnd(uv);
  float dither = 0.8+0.1*rand;

  vec3 s=vec3(0,-1,0);
  vec3 t=vec3(0,-0.3,3);
  vec3 tar=vec3(0,-0.7,3);

  float motion = curve2(time*1.5, 0.8)*3.0;
  s.z += motion;
  t.z += motion;
  //tar.z += time*1.5*3.0;// + pow(curve(time, 0.7),2)*5.0;
  float offset = 15.0;
  tar.z += (curve2(time*1.5-offset, 1.1)+offset)*3.0 + pow(curve(time, 0.9),3.0)*5.0;

  s-=tunnel(s);
  vec3 offt = tunnel(t);
  t-=offt;
  tar-=tunnel(tar);

  vec3 cz=normalize(t-s);
  vec3 cx=normalize(cross(cz, vec3(0,1,0) - offt*0.2));
  vec3 cy=normalize(cross(cz,cx));

  vec3 r = normalize(cx*uv.x + cy*uv.y + cz*(0.7+sin(time*2.0)*0.4));
  
  vec3 col = vec3(0);
  vec3 l = normalize(vec3(-0.7,-1.0,-0.5));

  vec3 back = mix(vec3(0.1,0.3,1.0)*0.1, vec3(1.0,0.3,0.5)*0.5, pow(r.y*0.5+0.5,2.0));

  vec3 p = s;
  float dd=0.0;
  int i=0;
  float at=0.0;
  float at2 = 0.0;
  for(i=0; i<MARCH_STEPS; ++i) {
    float d=map(p) * dither;
    if(d<0.001) {
      vec3 n=norm(p);
      float fog = clamp(1.0-dd*0.018, 0.0, 1.0);
      float bot = pow(clamp(-(p.y-10.0)*.1,0.0,1.0),2.0)*fog;

      float aodist = 0.3;
      float ao = clamp(map(p+n*aodist)/aodist,0.0,1.0);
      ao = mix(ao,1.0,0.3);
      
      float f = pow(1.0-dot(n,-r), 2.0);
      col += vec3(0.3,0.4,0.7)*max(0.0, dot(n,l)) * bot * ao;
      col += 4.0*f * back*2.0 * (-n.y*0.5+0.5) * bot*ao;

      dd = mix(100.0, d, bot);
      
      break;
    }
    if(dd>100.0) {
      dd=100.0;
      break;
    }
    p+=d*r;
    dd+=d;

    at += exp(-length(tar-p)*7.0);
    at2 += exp(-d*0.1)*0.05;
  }
  if(i>99) dd=100.0;

  col += vec3(1,0.3,0.5) * at * 3.3;
  col += vec3(1,0.3,0.5) * at2 * 0.2;
  col += back*0.05 * exp(dd*0.05);


  fragColor = vec4(col, 1);
}

// Function 134
vec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){
    p += n * eps;
    vec3 ld=mode?lp:lp-p;
    float l = length(ld);ld/=l;
    float diff = dot(ld,n);
    float h, c=eps, r=1.;
    for (float t = 0.0; t < 50.0; t++){
        h = map(p + ld * c).w;
        if (h < eps){
            return vec3(0.);
        }
        r = min(r, h * softShadow / c);
        c += h;
        if(c>l)break;
    }
    return lc*po*r*diff/(l*l);
}

// Function 135
vec3 sampleLight (in vec3 ro) {
    vec3 n = randomSphereDirection() * lightSize();
    return lightPos() + n;
}

// Function 136
void getOffsetLight2(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, bool xAligned, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {
    float distance;

    if(xAligned) {
        distance = sdXAlignedCylinder(lightOffset, 0.4, 0.1 );
    } else {
        distance = sdZAlignedCylinder(lightOffset, 0.4, 0.1 );
    }

    if (distance > maxDistance) {
        diffuseBrightness=0.0;
        specularBrightness=0.0;
        return;
    }
    vec3 lightDirection = normalize(lightOffset);
    float dotProd = dot(lightDirection,normal);

    if (dotProd <= 0.0) {
        diffuseBrightness=0.0;
        specularBrightness=0.0;
        return;
    }

    //fake the light falloff to limit distance
    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));
    fallOff*=fallOff;

    //dotProd = pow(dotProd,shine);
    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;

    vec3 specDirection = reflect(lightDirection, normal);
    dotProd = dot(specDirection, rayDirection);
    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);
    //dotProd *= diffuseBrightness;
    dotProd *= fallOff;
    specularBrightness = dotProd;
}

// Function 137
vec3 shade2(vec3 origin, vec3 dir, float dist, int matId) {
    vec3 pos = origin + dist*dir;
    vec3 normal = calcNormal(pos);
    Material mat = getMaterial(matId);
    float ambient = .12*(1.0 + .6*normal.y);

    vec3 light1 = normalize(vec3(1, 1, .75));
    float diffuse = clamp01(dot(normal, light1));
    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess);

    vec3 light2 = normalize(vec3(1, .5, -2));
    diffuse += .8 * clamp01(dot(normal, light2));
    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);

    vec3 col = clamp01(diffuse + ambient)*mat.diff_color;
    col += clamp01(specular)*mat.spec_color;

    return clamp01(col);
}

// Function 138
bool isLightVisible( Ray shadowRay ) {
    float distToHit;
    SurfaceHitInfo tmpHit;
    
    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );
    
    return ( tmpHit.material_id_ == MTL_LIGHT );
}

// Function 139
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    //lightPos = eye;
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 140
void MarchLight(inout RayInfo r, float startTime, float maxDist)
{
    float totalDist = 0.0;
    vec3 origin = r.pos;
    
    for (r.iter=0;r.iter<maxStepRayMarching;r.iter++){
        r.time = startTime; 
    	SetTime(r.time);
        r.dist = map(r.pos,-1);
        totalDist += r.dist;
        
        
        r.pos+= r.dir*(r.dist);
        if (abs(r.dist)<rayEps || totalDist > maxDist)
        {
            break;
        }
    }
}

// Function 141
vec3 evaluateLight(vec3 pos, inout float dis)
{
	vec4 sun = sunLight(pos);
	vec4 rl = roofLight(pos);
	dis = min(sun.w, rl.w);
	return sun.xyz + rl.xyz;
}

// Function 142
float calcAO( in vec3 pos, in vec3 nor, float scale )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.01 + scale*0.12*float(i)/4.0;
        float d = map( pos + h*nor );
        occ += (h-d)/scale*sca;
        sca *= 0.95;
        if( occ>0.5 ) break;
    }
    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);
}

// Function 143
float point_light (vec3 p, vec3 n, vec3 lpos)
{
    vec3 ldir = normalize(lpos-p);
    float att = length(lpos-p);
    float dotNL = dot(n, ldir)*0.5+0.5;
    return dotNL / ((0.1*att*att));
}

// Function 144
float softShadow(vec3 pos, vec3 rayDir){
    float res = 1.0;
    float t = 1.0;
    //float ph = 1e10;
    //Start some small distance away from the surface to avoid artifacts
    pos += rayDir * 5.0 * t;
	for(int i = 0; i < SHADOW_STEPS; i++){
	    vec3 p = pos + t * rayDir;
        if(p.y > 2.0*HEIGHT){
        	break;
        }
        float h = p.y - getHeight(p, terrainLimit);
		res = min(res, SHADOW_SHARPNESS * h / t );
        /*
		//An improved shadow approach that didn't quite work
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, SHADOW_SHARPNESS*d/max(0.0,t-y) );
        ph = h;
		*/
		t += h;
        if(res < EPSILON){
            break;
        }
	}
	return clamp(res, 0.0, 1.0);
}

// Function 145
float calcAOFactor(in vec3 p, in vec3 n) {
    const float sampleDist = 0.03;
    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist).x);
    return mix(AOFactorMin, AOFactorMax, (dist));
}

// Function 146
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<64; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += clamp(h,0.01,0.5);
		if( res<0.001 || t>maxt ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 147
vec3 lighting(vec3 ro, vec3 rd, vec3 n, vec3 p)
{
    vec3 l1d=normalize(-p);
    vec3 l1c=lightcolor(rd.x)*10.;
        
    float ao=get_ao(p,n);
    
    float dif=max(dot(n,l1d),0.)*ao;
    float bac=max(dot(n,-l1d),0.)*ao;
    float amb=clamp(0.3+0.7*n.y,0.0,1.0);
    float spe=pow(max(dot(reflect(-l1d,n),normalize(-l1d-rd)),0.), 32.);
   
    map(p);

    vec3 mate;
    if(obj==0)mate=lightcolor(rd.x);
    else mate=vec3(0.1,0.2,0.3)*0.5;
    
   	vec3 lin=(l1c*(4.*dif+1.*bac)+amb*vec3(1.))*mate.xyz+4.*spe*vec3(1.);
    
    return lin*0.2;
}

// Function 148
vec4 GetLight(vec3 p, vec3 n) {
    vec3 lightPos = vec3(3.0, 5, 4);
    vec3 l = normalize(lightPos-p);
    
    float dif = dot(n, l)*.5+.5;

    return vec4(n,dif); // #
}

// Function 149
vec3 sampleLightBRDF( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )
{
    vec3 brdf = vec3( 0 );
    vec3 s = vec3( 0 );

    Light light;
    light.id = 3.0;
    light.emission = LIGHT1_EM;

    vec3 l0 = vec3( 2, 2, 4 ) - hitOrigin;

    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    float cosa = mix(cos_a_max, 1., random());
    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );
#endif
    {
        float roughness = 1.0 - material.smoothness * material.smoothness;
        float metallic = material.metallic;

        float omega = 2. * PI * (1. - cos_a_max);
        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);
    }

    light.id = 4.0;

    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;

    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    cosa = mix(cos_a_max, 1., random());
    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );
#endif
    {
        float roughness = 1.0 - material.smoothness * material.smoothness;
        float metallic = material.metallic;

        float omega = 2. * PI * (1. - cos_a_max);
        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);
    }

#if (PATH == 0)
    brdf *= clamp( s, 0., 1. );
#endif

    return brdf;
}

// Function 150
vec3 LightPosition(bit3d_Ray r) {
	return path(time+2.0,0)+vec3(0.0,0.2,0.0);
}

// Function 151
vec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)
{
   // if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);
    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);
    vec3 N = normalize(normal);
    vec3 L = normalize(LightDir);
    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);
    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;
    vec3 Intensity = Ambient + Diffuse;
    vec3 FinalColor = inpColor.rgb * Intensity;
    return vec4(FinalColor, inpColor.a);
}

// Function 152
float shadow( vec3 origin, float min_t) {
    vec3 dir = normalize(lightPos - origin);
    // #define HARD_SHADOW
    #ifdef HARD_SHADOW
    return hardShadow(dir, origin, min_t);
    #else
    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);
    #endif
}

// Function 153
vec3 shadeHit( in vec3 ray, in vec3 hitNormal, in vec3 surfaceColor, in float ao )
{
    vec3 lightDir = (lightPos - (vec3(ptr) + fraction));
    float lightDist = length(lightDir);
    lightDir = normalize(lightDir);
    float lightDot = clamp(dot(lightDir, hitNormal), 0.0, 1.0);

    float spec = 0.0;
	float lightI = 0.0;
    if(lightDot >= 0.0 && lightDist < LIGHT_RANGE)
    {
	    if( computeRayHit(lightDir, lightDist) == false)
        {
	        lightI = lightDot * pow(1.0 - (lightDist / LIGHT_RANGE), 2.0) * 1.6;
		    spec = clamp(dot(ray, normalize(lightDir - hitNormal)), 0.0, 1.0);
		    spec = pow(spec, 40.0) * 0.8;
        }
    }

    return( (surfaceColor * 0.05 * ao) + (surfaceColor * lightI) + spec );
}

// Function 154
float UI_ButtonAO(in float t)
{
	return 1.0 - .7 * exp(-.5 * max(t,0.));
}

// Function 155
float mapSeedNoLight(vec2 f)
{
    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);
    return length((floor(seedCoord)-floor(f)))-seedColor.z*circSizeMult*iResolution.x;
}

// Function 156
float getAO(vec3 p, vec3 n, in vec2 c) { 
    vec2 cell_coord = fract(p.xz);
    
    float dhc = cellHeight(c);
    vec4 dh = vec4(cellHeight(c-vec2(1.0,0.0)),
                   cellHeight(c+vec2(1.0,0.0)),
                   cellHeight(c-vec2(0.0,1.0)),
                   cellHeight(c+vec2(0.0,1.0))) - p.y;
    vec4 side = max(-dh,0.0) / (dhc - min(dh,0.0) - p.y) * 0.75;
    dh = max(dh, 1e-5);    
    
    vec4 aot = min(smix(0.5,1.0,vec4(cell_coord,1.0-cell_coord).xzyw/dh), vec4(1.0));
    vec4 aos = min(mix(vec4(0.5),vec4(1.0), 1.0-(1.0-side)*max(n.xxzz*vec4(-1.,1.,-1.,1.),0.0)), 1.0);
    float hao = 1.0 - (dhc - p.y) * 0.4;
    //aot = 1.0 - (1.0 - aot) * n.y;        
    
    float ao = aot.x * aot.y * aot.z * aot.w * 
        	   aos.x * aos.y * aos.z * aos.w * hao;
    return ao;//clamp(ao,0.0,1.0);
}

// Function 157
vec4 rectLight(vec3 p, vec3 n, vec3 v, vec3 r, float NdotV, float roughness,
              vec3 f0, out vec3 fresnel, out vec3 diffCol, out vec3 specCol)
{
  
    vec4 result = vec4(0.);
    // ensure the points are wound counter-clockwise (only debug)
    float windingCheck = dot(cross(rect.right, rect.up), rect.center - p);
    if (windingCheck > 0.)
		return result;
    
    float solidAngle = rectSolidAngle(p, rect.a, rect.b, rect.c, rect.d);
    
    // diffuse
    result.w = solidAngle * .2 * (
        saturate(dot(normalize(rect.a - p), n)) +
        saturate(dot(normalize(rect.b - p), n)) +
        saturate(dot(normalize(rect.c - p), n)) +
        saturate(dot(normalize(rect.d - p), n)) +
        saturate(dot(normalize(rect.center - p), n)));   
    
    Ray rectRay = Ray(p, r);
    
    // calculate point on the rectangle surface/edge based on the ray originating from the shaded point
    vec3 planePointCenter = rayPlaneIntersect(rectRay) - rect.center;
    vec2 planePointProj = vec2(dot(planePointCenter, rect.right), 
                               dot(planePointCenter, rect.up));
    //vec2 c = min(abs(planePointProj), rect.halfSize) * sign(planePointProj);
    vec2 c = clamp(planePointProj, -rect.halfSize, rect.halfSize);
    vec3 L = rect.center + rect.right * c.x + rect.up * c.y;
#ifdef LIGHT_TEXTURE
    // calculate light uv
    vec3 L0 = L - rect.c;
    vec2 luv = vec2(dot(rect.right, L0), dot(rect.up, L0)) / (rect.halfSize * 2.);
#endif
    L -= p;
    
    vec3 l = normalize(L);
    vec3 h = normalize(l + v);
    float lightDist = length(L);
    
    float NdotH = max(0., dot(n, h));
    float VdotH = dot(v, h);
    
    float alpha = roughness * roughness;
    float alphaPrime = saturate(alpha + (RECT_LIGHT_RADIUS / (2. * lightDist)));
    
#ifdef LIGHT_TEXTURE
    // calculate approx light diffuse and specular colors (super experimental :p) 
    diffCol = pow(textureLod(iChannel1, luv, pow(exp(lightDist + .5), 2.)).rgb, vec3(2.2));
    specCol = pow(textureLod(iChannel1, luv, exp(lightDist * alpha + .5) + 1.).rgb, vec3(2.2));
#endif
    
    result.xyz += geometrySmith(NdotV, result.w, roughness) 
        * ndfTrowbridgeReitzRect(NdotH, alpha, alphaPrime)
        * fresnelSchlick(f0, VdotH);
    
    return result;
}

// Function 158
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( vec4(aopos,iTime) ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 159
float getShadow(const in vec3 l, const in vec3 p) {
    float dist = length(p - l);

    Ray ray;
    ray.dir = (p - l) / dist;
    ray.eye = l;

    HitInfo hit = raymarch(ray, MIN_DIST, MAX_DIST);
    if (hit.object == NO_HITS) {
        return 0.;
    }

    return mix(.2, 1., step(dist - 0.01, hit.dist));
}

// Function 160
float shadow(in ray ray, int maxSteps)
{
    float res = 0.0;

    float t = 0.001;
    
    float k = 8.0;
    
    float h = 0.1;
    
    for(int i=1; i<maxSteps+1; i++ )
    {
        vec3 samplePoint = ray.origin+ray.direction*t;
        if (samplePoint.y >= 1.0 || samplePoint.y <= -1.0 )//|| max(abs(samplePoint.x),abs(samplePoint.z)) >= 6.0)
        {
            return 1.0;
        }
        h = sceneDistanceFunction(ray.origin+ray.direction*t, orbitTrap);
        res = min( res, (k*h)/t );
        //if( h<0.0015*pow(distance(ray.origin, samplePoint), 1.0) || t>tmax) break;
        if(h < 0.00009 || t > maxDepth) 
        {
            break;
        }
        t += h;
    }

    if(t > maxDepth)
    {
        res = 1.0;
    }
    
    return res;
}

// Function 161
vec3 DiffuseLight( ShadeData s )
{
	// sunlight
	vec3 sun = vec3(1)*2.0*max(.0,dot(s.normal,SunDir))*s.shadow;
	
	// local soft light sources
	// Actually sample the lights!!
	vec4 sl = SampleLights( s.pos );
	float fade = 1.0/sl.w; // point lights should be 1/(w*w), line lights are 1/w, infinite area lights are 1
	vec3 local = vec3(.4,.7,1)*5.0*(dot(sl.xyz,s.normal)*.5+.5)*fade;

/*	// like ambient occlusion, but towards the light
	It's not quite right
	float lRange = s.t/20.0;
	float lOcclusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + sl.xyz*lRange )/(lRange*max(.1,dot(sl.xyz,s.normal))) );
	local *= exp2( -2.0*pow(lOcclusion,2.0) ); // tweak the curve*/
	
	// ambient
	vec3 ambient = vec3(0) + local;
	// this ambient occlusion trick works ridiculously well
	// sample the distance field at a point in front of the surface
	// if there's a nearby concave surface the value will be less than the distance to the sample point
	float aoRange = s.t/20.0;
	float occlusion = max( 0.0, 1.0 - DistanceFieldNoLights( s.pos + s.normal*aoRange )/aoRange ); // can be > 1.0
	ambient *= exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve
	
	return ambient+sun;
}

// Function 162
vec3 shade(in vec3 p,in vec3 n)
{
    // Point light
    const vec3 lightPos = vec3(1.0, 1.0,-5.0);
    const vec3 lightColor = vec3(0.95, 0.95,0.95);
  
    vec3 l = normalize(lightPos - p);

    // Not even Phong shading, use weighted cosine instead for smooth transitions
    float diff = 0.5*(1.0+dot(n, l));

    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish
    vec3 c = 0.2*background(n)+0.8*checker(p,n);//*diff*lightColor;

    return c;
}

// Function 163
vec3 LightSource(vec3 spotLight, vec3 dir, float dis)
{
    float g = 0.0;
    if (length(spotLight) < dis)
    {
		g = pow(max(dot(normalize(spotLight), dir), 0.0), 500.0);
    }
   
    return vec3(.6) * g;
}

// Function 164
float CalculateShadow(in RayHit hit)
{
    vec3 lightOrigin = hit.surfPos + (vec3(-SunDir.x, SunDir.y, -SunDir.z) * (ShadowDistance + SoftShadowOffset));
    vec3 lightRay    = normalize(hit.surfPos - lightOrigin);
    vec3 point       = vec3(0.0);
    
    vec2  sdf    = vec2(FarClip, 0.0);
    float depth  = 0.1;
    float result = 1.0;
        
    for(int steps = 0; (depth < ShadowDistance) && (steps < 8); ++steps)
    {
    	point  = (hit.surfPos + (-lightRay * depth));
        sdf    = Scene_SDF(point, hit);
        result = min(result, (SoftShadowFactor * sdf.x) / depth);
        depth += sdf.x;
    }
    
    return clamp((sdf.x < Epsilon ? 0.0 : result), 0.3, 1.0);
}

// Function 165
float calculateAO(in vec3 p, in vec3 n){
	
    float sca = 1., occ = 0.5;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.61 - occ, 0., 1.); // lower base shadow   
}

// Function 166
vec3 computeAllShadows(in vec3 iPoint) {
    
    vec3 shadow = computeShadow(iPoint, lightPosition0);
    shadow *= computeShadow(iPoint, lightPosition1);
    return shadow;
    
}

// Function 167
float getLightFactor(vec3 p,vec3 normal)
{
    vec3 lightPos = vec3(0,-2.0,iTime);
    vec3 lp = p - lightPos;
    float power = 3.0;
    float intensity = max(1.0-length(lp)/power,0.0);
    float dist = 1.0-dot(normalize(lp),normal);
    
    float factor = intensity*dist;
        
    return factor;
}

// Function 168
float calcAO( in vec3 pos, in vec3 nor )
{
	float ao = 0.0;
    for( int i=0; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
        float h = hash(float(i));
		ap *= sign( dot(ap,nor) ) * h*0.25;
        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );
    }
    return clamp( ao * 5.0 / 32.0, 0.0, 1.0 );
}

// Function 169
vec3 ambientLight(vec3 pos){
    vec3 pos0 = pos;
    float dist0 = distanceEstimation(pos);
    vec3 normal = normalEstimation(pos).xyz, gi, al = vec3(0.0);
    float ao = 1., dist = dist0;
    for(int i = 0; i < AmbientLightSteps; i++){
        float expectedDist = dist * (1. + .8);
        dist = distanceEstimation(pos);
        float weight = AOStrength*(1.-float(i)/float(AmbientLightSteps));	//more weight to first samples
        ao *= pow(clamp(dist/expectedDist, 0., 1.0), weight);
        normal = normalize(normalEstimation(pos, dist)+1.5*normal); //"smoothed" normal to avoid artifacts
        pos += normal * .8*dist; //slightly shorter to avoid artifacts
        al += backgroundColorHemi(normal);
        if(i == 6 || i == 13) gi += ao*directLight(pos, normal); // two GI samples
    }
    gi *= GIStrength/2.0;
    return gi + al/float(AmbientLightSteps) * ao;
}

// Function 170
float calcAO(in vec3 p, in vec3 n){

	float sca = 2., occ = 0.;
    for( int i = min(iFrame, 0); i<5; i++ ){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
        
        // Deliberately redundant line that may or may not stop the 
        // compiler from unrolling.
        if(sca>1e5) break;
    }
    
    return clamp(1. - occ, 0., 1.);
}

// Function 171
vec3 calculateLight (vec3 ro, vec3 rd, float rl, vec3 originalColor) {

    vec3 inScatterPoint = ro.xyz;

    float stepSize = rl / (numInScatteringPoints - 1.0);

    vec3 inScatteredLight = vec3(0, 0, 0);

    float viewRayOpticalDepth = 0.0;

    float ii = 0.0;
    for (float i = 0.0; i < numInScatteringPoints; i += 1.0) {

        float sunRayLength = raySphere(
            planetCenter, atmosphereRadius, inScatterPoint, dirToSun).y;

        float sunRayOpticalDepth = opticalDepth(
            inScatterPoint, dirToSun, sunRayLength);

        viewRayOpticalDepth = opticalDepth(
            inScatterPoint, -rd, stepSize * ii);

        vec3 transmittance = exp(
            (-sunRayOpticalDepth-viewRayOpticalDepth) * scatterCoefs);

        float localDensity = densityAtPoint(inScatterPoint);


        inScatteredLight += 
            localDensity * transmittance * 
            scatterCoefs * stepSize;
        inScatterPoint += 
            rd * stepSize;

        ii += 1.0;
    }

    float originalTransmittance = exp(-2.0*viewRayOpticalDepth);
    return originalTransmittance * originalColor + inScatteredLight;
}

// Function 172
float raymarchAO(in vec3 ro, in vec3 rd, float tmin) {
    float ao = 0.0;
    for (float i = 0.0; i < 5.0; i++) {
        float t = tmin + pow(i / 5.0, 2.0);
        vec3 p = ro + rd * t;
        float d = intersect(p).y;
        ao += max(0.0, t - 0.5 * d - 0.05);
    }
    return 1.0 - 0.00125 * ao;
}

// Function 173
float GetLight_Diffuse_WithShadows(vec4 p) {
    
    vec4 lightPos = vec4(0, 3, 1, 1);
    
    lightPos.xz += vec2(0., cos(2.0*iTime));
    
    //Ray from the found scene position to the light position, normalized to [0,1]
    vec4 lightRay = normalize(lightPos-p);
    vec4 normalRay = GetNormal_Generic(p);
    
    //Dot product returns [-1:1], so.. "clamp" it
    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);
    
    //Let's say we are rendering a point on the plane in the shadow of the sphere.
    //Ray march from this point in the direction of the light to see if we collide
    //with more scenery. If we do, reduce the diffuse lighting.
    //
    //Because 'p' was an output to RayMarch already, p already collides with the scene.
    //So move p a little bit away using the normal we already found.
    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);
    if(d < length(lightPos-p)) dif*= max(abs(d)/(length(lightPos-p)*2.),0.1);
    
    return dif;
}

// Function 174
vec3 shadeSphere2(vec3 rayPos, vec3 normal)
{
    return vec3(0.0, 1.0, 0.0);
}

// Function 175
float 	compute_ao(intersection_info i,vec2 uv)
{
    float ao = 0.0;
    const float count = SAMPLE_COUNT;

    ray r;
    r.point = i.pos_ws - i.normal_ws * 0.02;

    for(float x = 0.0; x < count; x += 1.0)
    {
        r.dir = random_hemisphere_direction(i.normal_ws,vec2_n1rand(uv,x));
        intersection_info j = scene(r, i.dist_id.y,0.5);
        if(abs(j.dist_id.y - i.dist_id.y) > 0.5)
        {
            ao += 1.0;
        }
    }

    ao /= count;

    return (1.0 - ao);
}

// Function 176
vec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )
{
	vec3 ambient = envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient
//		ambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient
	// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3
	float aoRange = distance/20.0;
	
	float occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0
	occlusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve
	if ( Toggle(kAmbientOcclusion) )
		ambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering

	float ndotl1 = max(.0,dot(normal,lightDir1));
	float ndotl2 = max(.0,dot(normal,lightDir2));
	float lightCut1 = smoothstep(.0,.1,ndotl1);//pow(ndotl,2.0);
	float lightCut2 = smoothstep(.0,.1,ndotl2);//pow(ndotl,2.0);

	vec3 light = vec3(0);
//	if ( Toggle(kDirectLight,3) )
	light += lightCol1*shadowMask1*ndotl1;
	light += lightCol2*shadowMask2*ndotl2;


	// And sub surface scattering too! Because, why not?
	float transmissionRange = distance/10.0; // this really should be constant... right?
	float transmission1 = DistanceField( pos + lightDir1*transmissionRange )/transmissionRange;
	float transmission2 = DistanceField( pos + lightDir2*transmissionRange )/transmissionRange;
	vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);
	vec3 subsurface = vec3(1,.8,.5) * sslight;


	float specularity = Noise(pos/vec3(.05,.2,.05)).x;
	
	vec3 h1 = normalize(lightDir1-ray);
	vec3 h2 = normalize(lightDir2-ray);
	float specPower = exp2(3.0+5.0*specularity);
	vec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;
	vec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;
	
	vec3 rray = reflect(ray,normal);
	vec3 reflection = Sky( rray );
	
	
	// specular occlusion, adjust the divisor for the gradient we expect
	float specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0
	specOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve
	
	// prevent sparkles in heavily occluded areas
	specOcclusion *= occlusion;

	if ( Toggle(kReflectionOcclusion) )
		reflection *= specOcclusion; // could fire an additional ray for more accurate results
	
	float fresnel = pow( 1.0+dot(normal,ray), 5.0 );
	fresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );
	

//	vec3 albedo = vec3(1,.95,.9);
	vec3 albedo = vec3(.7,.5,1);
//	vec3 albedo = vec3(.5,.3,.13);
	
	vec3 result = vec3(0);

	// comment these out to toggle various parts of the effect
	light += ambient;

	if ( Toggle(kSubsurface) )
		light += subsurface;
	
	result = light*albedo;

	result = mix( result, reflection, fresnel );
	
	result += specular1 + specular2;

	return result;
}

// Function 177
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )
{
    vec3 lin = vec3(0.0);

    vec3  lig = normalize(vec3(1.0,0.7,0.9));
	float cos_Ol = max(0.0, dot(nor, lig));
    vec3 h = normalize(lig - rd);
    float cos_Oh = max(0.0,dot(nor, h));
    float dif = cos_Ol;
    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(0.8, 0.7, 0.6)*sha;
    
    lin += vec3(0.20,0.30,0.30);

    
    vec3 col = mal.rgb*lin;

    // specular
    col += cos_Ol * pow(cos_Oh,40.0);
    
    // envmap
    col += mal.w*texture(iChannel0, reflect(rd,nor)).rgb;
    
    // fog    
    //-----------------------------
	col *= exp(-0.01*dis*dis);

    return col;
}

// Function 178
float evaluateBeckmannGeometryShadowing(float nlDot, float nvDot, float roughness)
{
    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html
    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);
    float vct = .5 / (roughness * sqrt(1. - nvDot * nvDot) + 0.00001);
    float lc = lct * nlDot, vc = vct * nvDot;
    float a = 3.353 * lc + 2.181 * lc * lc; // not typo
    a *= 3.353 * vct + 2.181 * vct * vc;
    float b = 1. + 2.276 * lc + 2.577 * lc * lc;
    b *= 1. + 2.276 * vc + 2.577 * vc * vc;
    return a / b;
}

// Function 179
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 4., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
    
}

// Function 180
vec3 processLighting(vec3 baseColor, vec3 dir, vec3 surfacePoint) {
  vec3 normal = calcNormal(surfacePoint);
  if (keypress(CHAR_N) && dot(normal,dir) > 0.0) normal = -normal; // Not a good idea
  vec3 color = baseColor*ambient;
  if (dot(light,normal) > 1e-4) {
    if (!keypress(CHAR_D)) color += baseColor*diffuse*dot(light,normal);
    if (!keypress(CHAR_S)) {
      float s = pow(max(0.0,dot(reflect(light,normal),vec3(dir))),specularpow);
      color += specular*s*specularcolor;
    }
  }
  return color;
}

// Function 181
vec4 shade( in vec3 ro, in vec3 rd ){

    vec2 tm = castRay(ro, rd);        

    vec3 c;

    if (tm.y < 0.0) {

        tm.x = dmax;
        c = vec3(bg_value);

    } else {        

        vec3 pos = ro + tm.x*rd;
               
        vec3 n = calcNormal(pos);
        
        vec3 color = poly_color(pos, tm.y);
        
        vec3 diffamb = (0.9*clamp(dot(n,L), 0.0, 1.0)+0.1) * color;
        
        vec3 p = normalize(pos);
        
        vec3 refl = 2.0*n*dot(n,L)-L;
        float spec = 0.4*pow(clamp(-dot(refl, rd), 0.0, 1.0), 20.0);
        c = diffamb + spec;
        
        c *= 0.4*dot(p, n) + 0.6;
        

    }

    return vec4(c, tm.x);

}

// Function 182
vec3 shade(vec3 p, int id)
{
    if(id == 3) return vec3(1);
    vec3 rd = normalize(p-lp);
    float f;
    f = inter(lp+rd, rd, f) != id ? .2 : 1.;
    vec3 n = normal(p,id);
    f *= max(.1,dot(n,-rd));
    return f * col(p,id);
}

// Function 183
float allLight(vec4 light, vec3 hitPos, vec3 normal) {
	return 1.0 * positionalLight(light, hitPos) + 0.0 * directionalLight(light, normal);
}

// Function 184
vec3 shadeGun(vec2 scn, vec3 p, vec3 n, vec3 r) {
    float mt = tex3D(rotateGun(p), n, iChannel1).z;
    vec3 col = vec3(.35) + mt*.1;
    col = calcLighting(col, p, n, r, 10.+80.*mt);
    
    return col;
}

// Function 185
vec3 shadeSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in float l )
{
    // Compute the texture of the sand.
    vec3 tex = texSand(p,l);
    
    // Figure out how wet the sand is. This is just some quasi-good value
    // that is vaguely related to the height of the water, but higher.
  float wetness = clamp(smoothstep(OCEAN_HEIGHT, 0.075, p.y),
                          0.0,1.0);
    
    // Get the appearance of reflective wet sand.
    vec3 wet = shadeWetSandR(p,d,e,n,i,ld,tex);
    // Get the appearance of the dry sand.
    vec3 dry = shadeDrySand(i,tex);

    // Return a mix of wet and dry sand based on the wetness of the sand.
  return mix(wet,dry,wetness);
}

// Function 186
float softshadow(vec3 pos, vec3 ldir, vec3 playerPos) {
#if USE_SHADOWS
    float res = 1.0;
    float t = 0.01;
    for(int i = 0; i < 16; i++) {
        float h = map(pos - ldir*t, junkMatID, playerPos, true, true);
        res = min(res, 7.0*h/t);
        t += clamp(h, 0.05, 5.0);
        if (h < EPS) break;
    }
    return clamp(res, 0.0, 1.0);
#else
    return 1.0;
#endif
}

// Function 187
float CalcAO(in vec3 pos, in vec3 nor) {
    float dd, hr=.01, totao=.0, sca=1.;
    for(int aoi=0; aoi<4; aoi++ ) {
        dd = map(nor * hr + pos);
        totao += -(dd-hr)*sca;
        sca *= .8;
        hr += .03;
    }
    return clamp(1.-4.*totao, 0., 1.);
}

// Function 188
vec3 shade(vec3 p, vec3 n, vec3 e) {
   
    #if USE_TEXTURE == 1
     	 vec3 tx = tex3D(iChannel0,p,n);
    #else
    	vec3 tx = vec3(1,1,1);
    #endif
    
    vec3 spec = tx*2.;
   	vec3 ambient = 0.9*tx;
    
    vec3 eye = normalize(e-p);
    vec3 light = normalize(vec3(0,1,-1)-p);
    
    vec3 diffuse = tx*max(0.0,dot(light,n));
    vec3 specular = spec*max(0.0,pow(dot(reflect(-light,n),eye),3.));
    
    return ambient+(diffuse*specular);
}

// Function 189
float spiralAO(vec2 uv, vec3 p, vec3 n, float rad)
{
    float goldenAngle = 2.4;
    float ao = 0.;
    float inv = 1. / float(SAMPLES);
    float radius = 0.;

    float rotatePhase = hash12( uv*100. ) * 6.28;
    float rStep = inv * rad;
    vec2 spiralUV;

    for (int i = 0; i < SAMPLES; i++) {
        spiralUV.x = sin(rotatePhase);
        spiralUV.y = cos(rotatePhase);
        radius += rStep;
        ao += doAmbientOcclusion(uv, spiralUV * radius, p, n);
        rotatePhase += goldenAngle;
    }
    ao *= inv;
    return ao;
}

// Function 190
vec3 highlights(vec3 pixel, float thres)
{
	float val = (pixel.x + pixel.y + pixel.z) / 3.0;
	return pixel * smoothstep(thres - 0.1, thres + 0.1, val);
}

// Function 191
void getLight(vec3 position, vec3 normal, vec3 rayDirection, float shininess, vec3 cameraOrigin, out vec3 diffuseLight, out vec3 specularLight, bool isReflection, float time) {
    diffuseLight = vec3(0.0);
    specularLight = vec3(0.0);

    vec3 lightOrigin;
    float diffuseBrightness;
    float specularBrightness;
    
    // -- Camera Light
    if(!isReflection) {
        lightOrigin = cameraOrigin;

        diffuseBrightness;// = 0.0;
        specularBrightness;// = 0.0;

        getOffsetLight(position, normal, rayDirection,lightOrigin-position, 9.0, shininess, diffuseBrightness, specularBrightness);
        diffuseLight = vec3(0.5 * diffuseBrightness);
        specularLight = vec3(0.5 * specularBrightness);
    }
    // -- Road Lights

    //get the closest road light
    vec3 pBlockCenter = position+(0.5*blockSize);

    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0
    vec3 pBlockI = floor(pBlockCenter/blockSize);
    // fraction of distance withinteh grid, -0.5 to + 0.5
    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;
    //wold position of the center of the grid, positionGI*blockSize
    //vec3 pBlockWI = pBlockI*blockSize;
    // -0.5*blockSize to +0.5*blockSize
    vec3 pBlockWF = pBlockF*blockSize;
    // Cell
    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;

    //sample just past the cross over point, has some artifacts but enlarges the light area.
    float maxDistance = gridSize*0.75;

    float lightStrobe;
    vec3 lightPositionOffset;

    if(abs(pBlockWF.y) -1.0 < gridSize) {

        if(pBlockWF.y>0.0) {
            lightPositionOffset.y = 1.0-pBlockWF.y;
        } else {
            lightPositionOffset.y = -1.0-pBlockWF.y;
        }

        // North/South
        if(abs(pBlockWF.x) < gridSize) {
            if(pBlockWF.z > gridSize*-0.5 && pBlockWF.z < 0.0) {
                lightPositionOffset.z = -pCellWF.z - gridSize;
            } else if(pBlockWF.z < gridSize*0.5 && pBlockWF.z > 0.0) {
                lightPositionOffset.z = -pCellWF.z + gridSize;
            } else {
                lightPositionOffset.z = -pCellWF.z;
            }
            if(pBlockWF.x>0.0) {
                lightPositionOffset.x = 2.0-pBlockWF.x;
            } else {
                lightPositionOffset.x = -2.0-pBlockWF.x;
            }

            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);
            if(lightStrobe>0.0) {
                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, true, maxDistance, shininess, diffuseBrightness, specularBrightness);
                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);
                specularLight += roadLightColour * (specularBrightness*lightStrobe);
            }
        }

        // East/West
        if(abs(pBlockWF.z) < gridSize) {

            if(pBlockWF.x > gridSize*-0.5 && pBlockWF.x < 0.0) {
                lightPositionOffset.x = -pCellWF.x - gridSize;
            } else if(pBlockWF.x < gridSize*0.5 && pBlockWF.x > 0.0) {
                lightPositionOffset.x = -pCellWF.x + gridSize;
            } else {
                lightPositionOffset.x = -pCellWF.x;
            }
            if(pBlockWF.z>0.0) {
                lightPositionOffset.z = 2.0-pBlockWF.z;
            } else {
                lightPositionOffset.z = -2.0-pBlockWF.z;
            }
            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);
            if(lightStrobe>0.0) {
                getOffsetLight2(position, normal, rayDirection, lightPositionOffset, false, maxDistance, shininess, diffuseBrightness, specularBrightness);
                diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);
                specularLight += roadLightColour * (specularBrightness*lightStrobe);
            }
        }
    } 

    // Up/Down
    maxDistance = gridSize*1.4;
    if (abs(pBlockWF.x)-2.0 < maxDistance && abs(pBlockWF.z)-2.0 < maxDistance) {
        if(pBlockWF.x>0.0) {
            lightPositionOffset.x = 2.0-pBlockWF.x;
        } else {
            lightPositionOffset.x = -2.0-pBlockWF.x;
        }

        if(pBlockWF.z>0.0) {
            lightPositionOffset.z = 2.0-pBlockWF.z;
        } else {
            lightPositionOffset.z = -2.0-pBlockWF.z;
        }

        lightPositionOffset.y = 0.0-pCellWF.y;

        lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);
        getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);
        diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);
        specularLight += roadLightColour * (specularBrightness*lightStrobe);

        //apply lights from above and below to get smooth transitions
        if (pCellWF.y>0.0) {
            lightPositionOffset.y = gridSize-pCellWF.y;
            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);
            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);
            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);
            specularLight += roadLightColour * (specularBrightness*lightStrobe);
        } else {
            lightPositionOffset.y = -gridSize-pCellWF.y;
            lightStrobe = getRoadLightStrobe(length(cameraOrigin-(lightPositionOffset+position)), time);
            getOffsetLight(position, normal, rayDirection, lightPositionOffset, maxDistance, shininess, diffuseBrightness, specularBrightness);
            diffuseLight += roadLightColour * (diffuseBrightness*lightStrobe*roadLightBrightness);
            specularLight += roadLightColour * (specularBrightness*lightStrobe);
        }
    }
}

// Function 192
vec3 diffuseLight(vec3 k_d, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {
  vec3 N = normal(p, 0.01);
  vec3 L = normalize(lightPos - p);

  float dotLN = dot(L, N);

  if (dotLN < 0.0) {
    return vec3(0.0, 0.0, 0.0);
  }

  return lightIntensity * (k_d * dotLN);
}

// Function 193
vec4 wavesShadowPalette(in float x)
{
    if(x<4.)
    {
        return ARR4(x,  D_BLUE,
			   			WHITE,
			   			L_BLUE,
			   			WHITE);
    }
    else return ARR2(x-4., D_BLUE, L_BLUE);
}

// Function 194
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 2., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.25/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
    
}

// Function 195
float lightDefault(float z){
	if(z>WATER_LEVEL) return 15.;
    else  return 14.; 

}

// Function 196
float FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){
	float  t=rCoC*2.0,s=1.0;
	for(int i=0;i<9;i++)
	{
		if(s<0.1)continue;
		float r=rCoC+t*coneGrad+0.05;
		float d=map(ro+rd*t)+r*0.6;
		s*=linstep(-r,r,d);
		t+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));
	}
	return clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);
}

// Function 197
float shadows(in vec3 ro, in vec3 rd, in float tmin)
{
    //return 1.0;
    const float tmax = 20.0;
    float res = 1.0;
    float k = 20.0;
    
    float t = tmin;
    for( int i=0; i<50; i++)
    {
        SDFRes h = map(ro + rd*t);
        if( h.d<0.0001 )
            return 0.0;
        if (t > tmax)
            return res;
        
        res = min( res, k*h.d/t );
        t += h.d;
    }
    return res;
}

// Function 198
bool isInShadow(vec3 p, Sphere sphere, Light light)
{  
  float lightDistance = distance(light.position, p);
  vec3 shadowDir = normalize(light.position - p);
  Ray shadowRay = Ray(p + 0.1 * shadowDir, shadowDir);    
  float tShadow = intersect(shadowRay, sphere);
  if(!isinf(tShadow) && tShadow < lightDistance)
	return true;
  
  return false;
}

// Function 199
vec3 light(vec3 p, vec3 n)
{
	float s = 1.0;
	
	#ifdef SHADOWS
	s = shadow(p-sunDir*0.01, -sunDir);
	#endif
	
	vec3 col = sunCol * min(max(dot(n, sunDir), 0.0), s);
	col += skyCol * (-n.y * 0.5 + 0.5) * 0.3;
	return col;
}

// Function 200
float positionalLight(vec4 light, vec3 hitPos) {
	return light.w * inversesqrt (0.001 + length(light.xyz - hitPos));
}

// Function 201
void MarchLight(float sscoc,inout Ray r, float startTime, float f//relkativistic raymarcher
){float acc = 0.
 ;float eps=getEpsToFps(sscoc)
 ;float lip=getReLipschitzToFps(sscoc)
 ;vec3 origin = r.b
 ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++
 ){r.time = startTime
  ;SetTime(r.time)
  ;r.dist=map(r.b,-1)
  ;acc+=r.dist*lip
  ;r.b+=r.dir*(r.dist)
  ;if(abs(r.dist)<eps||acc>f)break;}}

// Function 202
vec3 salmpleLight(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                  	in vec3 wi,
                  	in Material mtl,
                  	in bool useMIS,
                  	in int strataCount,
                  	in int strataIndex ) {
    vec3 Lo = vec3(0.0);	//outgoing radiance

    for(int i=0; i<DL_SAMPLES; i++) {
        float lightPickingPdf;
        Light light = pickOneLight(lightPickingPdf);

        vec3 wo;
        float lightPdfW, lightDist;

        LightSamplingRecord rec;
        float Xi1 = rnd();
        float Xi2 = rnd();
        float strataSize = 1.0 / float(strataCount);
        Xi2 = strataSize * (float(strataIndex) + Xi2);

        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );
        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );
        wo = rec.w;
        lightPdfW = rec.pdf;
        lightDist = rec.d;
        lightPdfW *= lightPickingPdf;

        float dotNWo = dot(wo, ns);

        if ((dot(wo, ng) > 0.0) && (dotNWo > 0.0) && (lightPdfW > EPSILON)) {
            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);
            if(dot(fr,fr)>0.0) {
                Ray shadowRay = Ray(x, wo);
                if (isLightVisible( shadowRay )) {
                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;

                    if (useMIS /*&& !(light->isSingular())*/) {
                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);
                        contribution *= misWeight(lightPdfW, brdfPdfW);
                    }

                    Lo += contribution;
                }
            }
        }
    }

    return Lo*(1.0/float(DL_SAMPLES));
}

// Function 203
float calcSoftshadow( in vec3 ro, in vec3 rd, float time )
{
    float res = 1.0;

    float tmax = 12.0;
    #if 1
    float tp = (3.5-ro.y)/rd.y; // raytrace bounding plane
    if( tp>0.0 ) tmax = min( tmax, tp );
	#endif    
    
    float t = 0.02;
    for( int i=0; i<50; i++ )
    {
		float h = map( ro + rd*t, time ).x;
        res = min( res, mix(1.0,16.0*h/t, hsha) );
        t += clamp( h, 0.05, 0.40 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 204
vec3 shade_grass(in xs_t xs) {
    
	vec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);
	float typemask1 = fnoise(2.5*typepos);
	float typemask2 = pow(fnoise(.4*typepos), 3.);
	float typemask3 = step(.71,fnoise(.8*typepos));
	vec3 col1 =  vec3(.7, .7, .2)*.7; //leaf
	vec3 col2 = vec3(.2, .2, .1)*.3;
	vec3 col3 =  vec3(.0, .0, .0); //vec3(.5, .5, .1);
	vec3 col4 = vec3(.6, .1, 1.); //flower
	vec3 color = mix(mix(mix(col1, col2, typemask1),
			col3, typemask2), col4, typemask3) *.8;
	color *= xs.occlusion;
	return color;
}

// Function 205
vec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)
{
 	vec3 dir = normalize(l.pos - pos);  
    vec3 viewDir = normalize(camPos - pos);
    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;
    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);
    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;
      
    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));
}

// Function 206
float hard_shadow(vec3 rayfrom, vec3 raydir, float tmin, float tmax) {
    float t = tmin;
    for(int i=0; i<MAX_STEPS; i++) {
        vec3 p = rayfrom + raydir*t;
        float h = map(p).d;
        if(h < SURF_DIST)
            return 0.0;
        t += h;
        if(t > tmax)
            break;
    }
    return 1.0;
}

// Function 207
vec3 calculateLighting(vec3 position, vec3 normal, vec2 uv, light lights[LIGHTS], vec3 camera)
{
    //convert from tangent space to world space
    {
        mat3 conversion;
        conversion[0] = normalize(cross(vec3(0, 0, 1), normal));
        conversion[1] = normalize(cross(normal, conversion[0]));
        conversion[2] = normal;
        {
            vec3 normmap = texture(iChannel0, uv).rgb * 2.0 - 1.0;
            normmap = normalize(normmap);
            normal = normmap * conversion;
        }
    }
    vec3 total = vec3(0.0);
    for(int i = 0; i < LIGHTS; ++i)
    {
        
        vec3 to_light = lights[i].position - position;
        vec3 incoming = normalize(position - camera);
        total +=
            (
                max(dot(normal, normalize(to_light)), 0.0) + 
                pow(max(dot(normal, normalize((to_light + incoming) * 0.5)), 0.0), EXPONENT)
            ) * lights[i].color.a / length(to_light) * lights[i].color.rgb;
    }
    #if TEXTURED == 1
    return total * texture(iChannel0, uv).rgb * 0.5;
    #else
    return total * 0.5;
    #endif
}

// Function 208
vec3 evaluatePointLight(vec3 pos, vec3 normal, vec3 lightDir, vec3 albedo)
{
    vec3 viewDir = normalize(cameraPos - pos);
 	vec3 halfVec = normalize(viewDir + lightDir);
    float nlDot = dot(normal, lightDir);
    if (nlDot <= 0.) return vec3(0.);
    float hlDot = dot(halfVec, lightDir);
    float nhDot = dot(normal, halfVec);
    float nvDot = dot(normal, viewDir);
    
    float fresnel = evaluateSchlickFresnel(nvDot);
    float refl = mix(0.03, 1., fresnel);
    float roughness = 0.2;
    float spec = evaluateGGXSpecularDistribution(nhDot, roughness)
        * evaluateBeckmannGeometryShadowing(nlDot, nvDot, roughness);
    return mix(albedo, vec3(spec), refl) * nlDot;
}

// Function 209
float Shadow(vec3 p, vec3 n, vec3 l, float hd, float d, float rnd, int ssteps)
{
    float nl = max(0., dot(n, l))
    , ao = /*sqrt*/(clamp((Scene(p + n * aod).d - hd) / aod, 0., 1.));
    if (nl > 1e-4) {
    	vec3 sht = sunDir * shd
    	, hp = p + n * .002; // self-shadow bias hit position
        int iters = max(1, int(rnd + float(ssteps) / (1.+.002*d)));
        float sh = 1.; // min shadow factor found so far
        for (int i = iters; i-- > 0; ) {
    		float f = (float(i) + 1.) / float(iters)
    		// must distribute the samples nonlinearly
			// to support long shadow trace distances.
			// need more samples close to the receiver.
			, ff = f * f
			, v = max((Scene(p + sht * ff).d - hd + sfuzz * f) * sc / shd / nl / ff, 0.);
			sh = min(sh, v); //sh = min(sh, v * (2.-f)); //sh *= mix(v, 1., f); //sh *= v; //
        }
        // hoisted sqrt and part of clamp out of loop
        sh = /*sqrt*/(min(sh, 1.));
        sh = pow(sh, shfalloff);
	    nl *= sh; // fake soft shadow attenuates direct lighting
    }
    //nl = max(nl, ao);
    //nl *= max(0., mix(ao, 1., .2));  // fake AO
    //nl = mix(nl, 1., ambient);  // HACK ambient floor
    //float af = min(mix(ao, 1., ambient), 1.);
    //nl = mix(nl, 1., af);
    // FIXME I still don't like how I've mixed the factors, really.
    // FIXME ambient light should have a color from the surrounding environment bounces,
    // so should be based on albedo of nearby surfaces
    // as a major HACK can use our *own* albedo since it does contribute somewhat due to interreflections
    float ah = mix(n.y, 1., .5) * ambient; // hemisphere ambient
    nl *= (1.-ambient); // leave room for ambient factor
    nl += ah * ao; // hemi ambient only where not occluded
    //nl /= (1. + ambient); // I like this mixing better
    nl = clamp(nl, 0., 1.);
    // must have some minimum lighting floor to prevent harsh black ao in shadows
    nl = mix(nl, 1., lfloor); // after clamping
//    nl = 1.; // HACK disable lighting
    return nl;
}

// Function 210
float lightMarch(vec3 ro, vec3 lightPos)
{
    vec3 rd = lightPos-ro;
    float d = length (rd);
    rd = rd/d;
    float t = 0.;
    float stepLength = d/ float(nStepLight);
    float densitySum = 0.;
    float sampleNoise;
    int i = 0;
    for (; i < nStepLight; i++)
    {
    	sampleNoise = map ( ro + t * rd);
       
        densitySum += sampleNoise;
        
        t += stepLength;
    }
    
    return exp(- d * (densitySum / float(i)));
}

// Function 211
vec3 shade(vec3 pos, vec3 dir, float t) {
    //return vec3(length(normal(pos)));
    //return length(normal(pos));
	//return vec3(dot3(normal(pos), LIGHT_DIR));
    vec3 normal_vec = normal(pos);
    float shade = dot3(normal_vec, LIGHT_DIR);
    vec3 dir_to_sphere_center = normalize(pos - sphereCenter(t));
    float mat_blend = dot3(normal_vec, dir_to_sphere_center);
    return shade * vec3(sin(mat_blend)*cos(mat_blend), sin(mat_blend), cos(mat_blend));
    //return vec3(shade, shade, 1.-fract(iTime));
}

// Function 212
void shaderLnae( out vec4 fragColor, in vec2 fragCoord, vec2 resolution )
{
    vec2 uv = (fragCoord - 0.5 * resolution.xy) / resolution.x;
    uv.x = abs(uv.x);
    uv.x -= .12;
    uv *= 3.;
    vec3 col = render(uv);
    fragColor = vec4(col,1.0);
}

// Function 213
vec3 calcDiffuseLight(Object o, Light l, vec3 pos)
{
    vec3 dir = normalize(l.pos - pos);
    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   
}

// Function 214
vec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)
{
    vec3 sunLight  = normalize( vec3(  0.5, 0.2,  0.3 ) );
	float sh = Shadow(pos,  sunLight);
    // Light surface with 'sun'...
	vec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;
    //col += mat * vec3(0.1, .0, .0)*(max(dot(-sunLight,normal), 0.0));
    
    normal = reflect(eyeDir, normal); // Specular...
    col += pow(max(dot(sunLight, normal), 0.0), 25.0)  * SUN_COLOUR * 1.5 *sh;
    // Abmient..
    col += mat * .2 * max(normal.z, 0.0);
    col = mix(FOG_COLOUR,col, min(exp(-d*d*.05), 1.0));
    
	return col;
}

// Function 215
bool is_shadow(Ray ry)
{
    if (int_sphere(ry, lg_sphere) > 0.0)
       	return true;
    return false;
}

// Function 216
float calcAO_o354278( in vec3 pos, in vec3 nor ){
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ ){
        float h = 0.001 + 0.15*float(i)/4.0;
        float d = input_o354278( pos + h*nor ).x;
        occ += (h-d)*sca;
        sca *= 0.98;
    }
    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    
}

// Function 217
vec3 light(in vec3 pos, in vec3 nor)
{
	vec3 ro = pos + 0.001 * nor;
	vec3 ret = vec3(0.0);

	for (int i = 0; i < ld.length(); i++)
	{
		if (isLightVisible(ro, i))
		{
			float att = attenuation(pos, ld[i].pos, ld[i].r);
			ret = ret + ld[i].col * att;
		}
	}

	return ret;
}

// Function 218
vec3 shade(in vec3 pos, in vec3 normal, in int obj_id)
{
	vec3 light_dir = light_pos - pos;
	float ldist = length(light_dir);
	light_dir = normalize(light_dir);

	float ndotl = max(dot(light_dir, normal), 0.0);

	float s = calc_shadow(pos, light_dir, ldist);

	float fog = calc_fog(length(pos - eye_pos), 0.056);

	vec3 color = s * ndotl * obj_color(pos, normal, obj_id);
    vec3 fog_color = bg_color(vec2(0.0, 0.0));
	return mix(fog_color, color, fog);
}

// Function 219
float calcAO( in vec3 pos, in vec3 nor )
{
	float sca = 10.2;
    float hr = 0.05;  
    float dd = map( nor * 0.15 + pos ); 
    return clamp( 1.0 + (dd-hr)*sca, 0.0, 1.0 );     
}

// Function 220
float	SphereFlakeShadowStack( in vec3 ro, in vec3 rd )
{
    float	result	= 1.0;

    int	idx	= 1;
// Get current element on the stack.
#define	SFEL g_stack[ idx ] 
// Get parent element on the stack
#define	SFPEL g_stack[ idx - 1 ]
// Get parent's parent element on the stack
#define	SFPPEL g_stack[ idx - 2 ]
// Do sphere intersect call on the current element on the stack.
#define SFShadow sphSoftShadow( ro, rd, SFEL.center, SFEL.radius, result )
// Do sphere intersect test call on the current element on the stack.
#define SFIntersectTest sphIntersectTest( ro, rd, SFEL.center, SFEL.radius )
// Check if current element on the stack has a small radius.
#define SFIsRadTooSmall isRadTooSmall( ro, SFEL.center, SFEL.radius )

    if( ! SFIntersectTest )
        return	result;

    SFShadow;

    idx = 2;
    while( idx > 1 )
    {
        if( SFEL.sphereIndex == TOTAL_SPHERES_COUNT )
        {
            SFEL.sphereIndex	= 0;
            idx--;
            continue;
        }

        vec3	perp1	= normalize( cross( SFPEL.direction, SFPPEL.direction ) );
        vec3	perp2	= normalize( cross( SFPEL.direction, perp1 ) );

        vec3	rot		= perp1 * PERP1MOD( SFEL.sphereIndex ) 
            			+ perp2 * PERP2MOD( SFEL.sphereIndex );

        vec3	dirNN	= SFPEL.direction * YAXIS_COS( SFEL.sphereIndex )
            			+ rot;
        
        SFEL.direction	= normalize( dirNN );
        SFEL.center		= SFEL.direction * ( SFEL.radius + SFPEL.radius ) 
            			+ SFPEL.center;

        SFEL.sphereIndex++;
        
        if( SFIsRadTooSmall || ! SFIntersectTest )
            continue;

        SFShadow;

        if( idx == STACK_MAX_SIZE )
            continue;

		idx++;
    }
    
    return	result;
}

// Function 221
vec3 mapShadow( in vec3 pos )
{
    float h = terrain( pos.xz );
    float d = pos.y - h;
    vec3 res = vec3( d, MAT_GROUND, 0.0 );
    
    res = mapGrass(pos,h,res);
    res = mapMoss(pos,h,res);

    vec3 m1 =  pos - mushroomPos1;
    vec3 m2 = (pos - mushroomPos2).zyx;
    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;
	res = mapMushroom(m1, res);


    vec3 q = worldToLadyBug(pos);
    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;
    if( d3.x<res.x ) res = d3;

    return res;
}

// Function 222
float shadow(in vec3 light, in vec3 eye, in vec3 ray, in vec3 m, in vec3 normal) {
    
    const float wallDist = 42.0;
    vec3 wallPoint = ray / ray.z * wallDist;

    vec3 lightdir = normalize(wallPoint - light);

    const float e = 0.2;
    float nbColl = 1.0;
    
    float i = getFieldIntensity(light, lightdir, m, normal);
    
    
    return 1.0 - smoothstep(7.5,17.5, i);
    
    
    /*
    if(rayMarching(light, lightdir, m, normal)) {
        
        float shadow = max(dot(-lightdir,normal), 0.0);
        
        return 1.0 - shadow;
    }
    else {
	 	return 1.0;   
    }
	*/
}

// Function 223
float pointLightDiffuse(vec3 nor, vec3 pos, vec3 lightPos, vec3 f){
    vec3 toLight = normalize(lightPos - pos);
    float dist = length(lightPos - pos);
    float atten = min(1.0, 1.0/(dot(f, vec3(1.0, dist, dist * dist))));
    return clamp(dot(nor, toLight), 0.0, 1.0) * atten;
}

// Function 224
float ao(vec3 p, vec3 n) {
    float dist = aoDist;
    float occ = 1.0;
    for (int i = 0; i < aoIter; ++i) {
        occ = min(occ, scene(p + dist * n) / dist);
        dist *= aoPower;
    }
    occ = max(occ, 0.0);
    return occ;
}

// Function 225
void shade(float3 rp0, float3 rd, out float t, out float3 col, out float3 n)
{
    trace(rp0,rd,t,col,n);
//	col=n*0.5+0.5;
    float3 tolight=normalize(light-(rp0+rd*t));
    float diffuse=clamp(dot(tolight,n),0.0,1.0);
    
    float3 halfNormal=normalize(tolight-rd);

    float3 nr=n*dot(n,-rd);
    float3 refl=normalize(-rd+(nr+rd)*2.0);
    
    float fresnel=(1.0-dot(-rd,n));
    float RF=0.2;
    fresnel=RF+(1.0-RF)*pow(1.0-dot(-rd,n),5.0);
    diffuse*=1.0-fresnel;
    
    float spec1=clamp(dot(n,halfNormal),0.0,1.0);
    float spec2=clamp(dot(tolight,refl),0.0,1.0);
    
    spec1=pow(spec1,20.0);
    spec2=pow(spec2,120.0)*2.0;
    float spec=spec1+spec2;
//	spec=spec*1.2;
    float3 pos;
//    pos=n;col=fract(pos*0.5+0.5);
//    pos=rp0+rd*t;col=fract(pos*4.0);
//    return;
    
	float shadow=1.0;
//    if(false)
    {
	    float t1=MAX_RAY_LENGTH;
    	float3 col1;
    	float3 n1;
        float3 pos=rp0+t*rd+n*0.001;
        trace(pos,normalize(light-pos), t1, col1, n1);
        if(t1<MAX_RAY_LENGTH)
        {
            shadow=0.0;
            spec=0.0;
        }
    }
    spec1*=shadow;
    spec2*=shadow;
    diffuse=pow(diffuse,1.5);
    diffuse*=shadow;
    col*=(0.2+diffuse*0.8);
//	return;
//    if(false)
    {
        
	    float t1=MAX_RAY_LENGTH;
    	float3 col1;
    	float3 n1;
        float3 pos=rp0+t*rd+n*0.001;
        trace(pos,refl, t1, col1, n1);
        float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-refl.y)*(1.0-refl.y));
        float fogf=clamp(1.8/(exp(t1*0.25)),0.0,1.0);
        float3 col2=col1;
        lit(pos+refl*t1, refl, n1, col2, col1);
    	col1=mix(fogcol,col1,fogf);
	    
        
//        if(t1<MAX_RAY_LENGTH)
        {
//            col+=(col*0.5+0.5)*col1/exp(t1*0.05)*clamp(dot(tolight,n1),0.0,1.0)*fresnel;
            col+=col1*(0.3+fresnel*0.7);
        }
    }

    col=clamp(col+(0.5+col*0.5)*spec1*(0.2+fresnel),0.0,10.0);
    col+=float3(1.0,1.0,1.0)*clamp(spec2*diffuse*(1.0+fresnel),0.0,10.0);

    float3 fogcol=mix(float3(0.87,0.8,0.83),float3(0.3,0.6,1.0),1.0-(1.0-rd.y)*(1.0-rd.y));
    float sun=clamp(dot(normalize(light-rp0),rd),0.0,1.0);
    fogcol+=
        pow(sun,1200.0)*float3(1.0,0.7,0.3)*0.5
        +pow(sun,5.0)*float3(1.0,0.7,0.5)*0.15;
    col=mix(fogcol,col,clamp(1.8/(exp(t*0.025)),0.0,1.0));
    
    
//    col*=(0.5+shadow*0.5);
}

// Function 226
void Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)
{
	float fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);
	float kSpreadPower = 2.0;
	vFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;
}

// Function 227
v0 shadow(v2 o,v2 i
){const v0 a=32.//shadow hardnes
 ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance
 ;const v0 it=clamp(IterSh,0.,64.)
 ;for(v0 j=0.;j<it;j++
 ){h=dm(o+i*t).x
  ;r=min(r,h*a/t)
  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances
 ;return clamp(r,0.,1.);}

// Function 228
float calcSoftShadowCoeff( in vec3 ro, in vec3 rd, float k )
{
    // k = factor that controls penumbra intensity
    float shadowIntensity = 1.0;
    for( float t=MIN_T_SHADOWS; t < MAX_T_SHADOWS; )
    {
        //h = hit distance from test point which is the ray origin that was passed in
        float h = sceneSDF(ro + t*rd).t;
        if( h<EPSILON )
        {
            //point is too close to the test point and so this is likely just floating point error
            return 0.0;
        }
            
        shadowIntensity = min( shadowIntensity, k*h/t );
        t += h;
    }
    return shadowIntensity;
}

// Function 229
float getFireShadow(vec3 posWS)
{
    float fireLife = max(0.0, s_globalFireLife);
    vec3 fireLightPosWS = vec3(0.0, 0.05 + fireLife*0.35, 0.0);
    
    float lightAnim = s_time * 15.0;
    float lightAnimAmpl = 0.02;
    fireLightPosWS.x += lightAnimAmpl * sin(lightAnim);
    fireLightPosWS.z += lightAnimAmpl * cos(lightAnim);
    
    float fireLightRadius = 0.7 - fireLife * 0.25;
    
    vec3 posToFireWS = fireLightPosWS - posWS;
    float posToFireLength = length(fireLightPosWS - posWS);
    vec3 posToFireDirWS = posToFireWS / max(0.0001, posToFireLength);
    
    float distToLight = posToFireLength-fireLightRadius;
    
    if(distToLight < 0.0)
    {
        return 1.0;
    }
    
    float lightTanAngularRadius = fireLightRadius / max(0.0001, posToFireLength);
    
    return marchShadow(posWS, posToFireDirWS, 0.001, 
                       max(0.0, posToFireLength-fireLightRadius), lightTanAngularRadius);
}

// Function 230
float shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )
{
	float t = mint;
	float res = 1.0;
    for ( int i = 0; i < 64; ++i )
    {
        vec2 h = distance_to_obj( ro + rd * t );
        if ( h.x < 0.001 )
            return 0.1;
		
		res = min( res, k * h.x / t );
        t += h.x;
		
		if ( t > maxt )
			break;
    }
    return res;
}

// Function 231
float spotLight(vec3 p, vec3 n) {
    vec3 spotDir = normalize(vec3(0.0, -1.0, 0.0));
    vec3 spotPos = vec3(0.0, 1.0, 0.0);
    float coneAngle = 20.0;
    float coneDelta = 30.0;
    
	vec3 lray = normalize(spotPos - p);
    float falloff = (dot(lray, -spotDir) - cos(radians(coneDelta))) / (cos(radians(coneAngle)) - cos(radians(coneDelta)));
    float diffuse = max(0.0, dot(lray, n));
    float sh = softShadow(p, lray, 0.01, 32.0);
    return diffuse * falloff * sh;
}

// Function 232
float terrainShadow( in vec3 ro, in vec3 rd, in float mint )
{
    float res = 1.0;
    float t = mint;
#ifdef LOWQUALITY
    for( int i=ZERO; i<32; i++ )
    {
        vec3  pos = ro + t*rd;
        vec2  env = terrainMap( pos.xz );
        float hei = pos.y - env.x;
        res = min( res, 32.0*hei/t );
        if( res<0.0001 ) break;
        t += clamp( hei, 1.0+t*0.1, 50.0 );
    }
#else
    for( int i=ZERO; i<128; i++ )
    {
        vec3  pos = ro + t*rd;
        vec2  env = terrainMap( pos.xz );
        float hei = pos.y - env.x;
        res = min( res, 32.0*hei/t );
        if( res<0.0001 ) break;
        t += clamp( hei, 0.5+t*0.05, 25.0 );
    }
#endif
    return clamp( res, 0.0, 1.0 );
}

// Function 233
float getLight(vec3 p) {
	vec3 lightPos = vec3(-2, 5, 8);
    
    //move the light in a circle
    lightPos.xz += vec2(cos(iTime), sin(iTime)) * 10.;
    
 	vec3 normal = getNormal(p);
    vec3 toLight = normalize(lightPos - p);
    
    float angle = dot(normal, toLight);
    angle = clamp(angle, 0., 1.);
    
    vec3 rayOrig = p+normal*.02;
    vec3 rayDir = toLight;
    float dist = 0.;
    float maxDist = length(p-lightPos)+0.1;
    
    // contains last 3 distances
	vec3 history = vec3(0.);
    
    const float maxDistToObject = 0.3;
    
    // minimal distance to object for penumbra calculation
	float md = 1.0e+10;
    
    //add shadows
    for (int i = 0; i < MAX_STEPS; ++i) {
		vec3 p = rayOrig + dist * rayDir;
        
        history.yz = history.xy;
		history.x = sceneDist(p);
        dist += history.x;
     
        // detect V pattern
        if (history.y < maxDistToObject && history.x >= history.y && history.z > history.y)
            md = min(md, history.y);
        
        if (dist < 0.0 || dist > maxDist) {
        	break;
        }
        
        if (history.x < SURF_DIST) {
            md = 0.0;
            break;
        }
	}
    
    angle = angle * smoothstep(0.0, maxDistToObject, md);
    return angle;
}

// Function 234
vec3 shadeloop(vec3 co, vec3 nray, float seed) {
    vec3 co2;
    vec3 color;
    float seed2 = seed*5.0;
    
    for (int i=0; i<BOUNCES; i++) {
        seed2 += 1.32423;
        float found, f;
        Sample s = trace(co, nray, co2, found, seed2);
        float l = s.d;
		
        //sample ambient?
        if (found == 0.0) {
            color += vec3(0.4, 0.5, 0.9)*AMBIENT;
            break;
        }

        vec3 n = s.no;
		
        //planar area light instead of sun,
        //because it makes prettier shading :)
        vec3 light = vec3(3.0, 0.6, 3.0) + SUN_SIZE*randvec(seed2+1.0)*1.0*vec3(1.0,1.0,0.0); //nray[0], nray[1], nray[2]-2.5);
        vec3 ln = normalize(light-co2);
        
        f = max(dot(n, ln), 0.0)*SUN_ENERGY;
        
        vec3 co3;
        trace(co2 + -nray*0.004, ln, co3, found, seed2+2.0);

        f *= float(found < 0.1);
        
        color = color*s.color + s.color*f;
        color += s.emission;
        
        co = co2 - nray*0.004;
        nray = randvec(seed2+3.0);
        if (dot(nray, n) < 0.0) {
            nray = -nray;
        }
    }
    
    return color;
}

// Function 235
float shadow(vec3 ro, vec3 rd, float id)
{
    float v = 1.;
    for(float i=0.; i<sphereNum;i++)
    {
        if(blinkID[int(i)])
            continue;
        if(i!=id)
        {    
            float tt = mt+i*2.;
            float ds = shadowSphere(ro, rd, spherePos[int(i)], sRadius);
            v*=ds;
            if(ds==0.)
                return 0.;
        }
    }
    return v*v*(3.-2.*v);
}

// Function 236
vec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )
{
    float eps = 0.002;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormalOpaque( pos, eps );

    vec3 mateD = vec3(0.0);
    vec3 mateS = vec3(0.0);
    vec2 mateK = vec2(0.0);
    vec3 mateE = vec3(0.0);

    float focc = 1.0;
    float fsha = 1.0;

    if( m<1.5 ) // snail body
    {
        float dis = texture( iChannel1, 5.0*pos.xy ).x;

        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );
        be = 1.0-smoothstep( -0.01, 0.01, be );        
        
        float ff = abs(matInfo.x-0.20);
        
        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );
        mateS += 2.0*dis;
        mateS *= 1.5;
        mateS *= 1.0 + 0.5*ff*ff;
        mateS *= 1.0-0.5*be;
        
        mateD = vec3(1.0,0.8,0.4);
        mateD *= dis;
        mateD *= 0.015;
        mateD += vec3(0.8,0.4,0.3)*0.15*be;
        
        mateK = vec2( 60.0, 0.7 + 2.0*dis );
        
        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );
        f = 1.0-pow( f, 8.0 );
        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);
        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);
        
        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));
        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );
    }
	else if( m<2.5 ) // shell
    {
        mateK = vec2(0.0);
        
        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );
        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );
        
        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );
        
        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;
        mateD *= 0.25 + 0.75*ral;
        
        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );
        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));
        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );
        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;
        
        mateK = vec2( 64.0, 0.2 );
        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;
    }
    else if( m<3.5 ) // plant
    {
        mateD = vec3(0.05,0.1,0.0)*0.2;
        mateS = vec3(0.1,0.2,0.02)*25.0;
        mateK = vec2(5.0,1.0);
        
        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
        mateD += 0.2*fre*vec3(1.0,0.5,0.1);
        
        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;
        mateS *= 0.5 + 1.5*te;
        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);
    }
    else //if( m<4.5 ) // leave
    {
        vec3 p = pos - vec3(-1.8,0.6,-0.75);
        vec3 s = p;
        p = mat3(0.671212, 0.366685, -0.644218,
                -0.479426, 0.877583,  0.000000,
                 0.565354, 0.308854,  0.764842)*p;

        vec3 q = p;
        p.y += 0.2*exp(-abs(2.0*p.z) );

        float v = smoothstep( 0.01, 0.02, abs(p.z));
        
        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );

        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;

        float r = clamp((p.x+2.0)/4.0,0.0,1.0);
        r = r*(1.0-r)*(1.0-r)*6.0;
        float ff = length(p.xz/vec2(2.0,r));

        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );
        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );
        mateD *= 1.0 + 0.25*te;
        mateD *= 0.8;
        
        mateS = vec3(0.15,0.2,0.02)*0.8;
        mateS *= 1.0 + 0.2*rr;
        mateS *= 0.8;

        mateK = vec2(64.0,0.25);
        
        //---------------------
        
        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);
        nor = normalize( nor );

        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );
        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );
        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );
        float dd = min(d1,min(d2,d4));
        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);
        
        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));
        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));
        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));
        dd = min(d1,min(d2,d4));
        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);
        
        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );
        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );
        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;
        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    
    }
    
  
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor )*focc;
    float sss = calcSSS( pos, nor );
    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;
    
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float sha = calcSoftShadow( pos, sunDir, 20.0 ); 
    dif1 *= sha*fsha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );

    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );

    // illumination
    
    vec3 col = vec3(0.0);
    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;           // sun
    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    // sky
    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                // bounce

    col *= mateD;

    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; // sss
    col = pow(col,vec3(0.6,0.8,1.0));
    
    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   // sun lobe1
    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; // sun lobe2
	col += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); // sky

    col += mateE;

    return col;        
}

// Function 237
float shadow(in vec3 origin, in vec3 direction) {
    float hit = 1.0;
    float t = 0.02;
    
    for (int i = 0; i < 1000; i++) {
        vec2 h = scene(origin + direction * t);
        if (h.x < 0.001) return 0.0;
        t += h.x;
        hit = min(hit, 15.0 * h.x / t);
        if (t >= 4.0) break;
    }

    return clamp(hit, 0.0, 1.0);
}

// Function 238
vec3 computeIncidentLight(const in vec3 orig, const in vec3 dir, in float tmin, in float tmax, const in vec3 sunDirection) {
    float t0, t1;
    if (!raySphereIntersect(orig, dir, Ra, t0, t1) || t1 < 0.0) return vec3(0.0);
    if (t0 > tmin && t0 > 0.0) tmin = t0;
    if (t1 < tmax) tmax = t1;
    float segmentLength = (tmax - tmin) / float(SAMPLES);
    float tCurrent = tmin;
    vec3 sumR = vec3(0.0); // rayleigh contribution
    float opticalDepthR = 0.0;
    float mu = dot(dir, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction
    float phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu);
    #ifdef MIE
    vec3 sumM = vec3(0.0); // mie contribution
    float opticalDepthM = 0.0;
    float phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * mu, 1.5));
    #endif
    for (uint i = 0u; i < SAMPLES; ++i) {
        vec3 samplePosition = orig + (tCurrent + segmentLength * 0.5) * dir;
        float height = length(samplePosition) - Re;
        // compute optical depth for light
        float hr = exp(-height / Hr) * segmentLength;
        opticalDepthR += hr;
        #ifdef MIE
        float hm = exp(-height / Hm) * segmentLength;
        opticalDepthM += hm;
        #endif
        // light optical depth
        float t0Light, t1Light;
        raySphereIntersect(samplePosition, sunDirection, Ra, t0Light, t1Light);
        float segmentLengthLight = t1Light / float(SAMPLES_LIGHT), tCurrentLight = 0.0;
        float opticalDepthLightR = 0.0;
        #ifdef MIE
        float opticalDepthLightM = 0.0;
        #endif
        uint j;
        for (j = 0u; j < SAMPLES_LIGHT; ++j) {
            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;
            float heightLight = length(samplePositionLight) - Re;
            if (heightLight < 0.0) break;
            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;
            #ifdef MIE
            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;
            #endif
            tCurrentLight += segmentLengthLight;
        }
        if (j == SAMPLES_LIGHT) {
            #ifdef MIE
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * MIE_EXTINCTION_MUL * (opticalDepthM + opticalDepthLightM);
            #else
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR);
            #endif
            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));
            sumR += attenuation * hr;
            #ifdef MIE
            sumM += attenuation * hm;
            #endif
        }
        tCurrent += segmentLength;
    }

    #ifdef MIE
    return (sumR * betaR * phaseR + sumM * betaM * phaseM) * SUN_INTENSITY;
    #else
    return (sumR * betaR * phaseR) * SUN_INTENSITY;
    #endif
}

// Function 239
void AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )
{
    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );
    vDiffuse += g_skyColour * skyIntensity;       
}

// Function 240
float calcAO( in vec4 pos, in vec4 nor ){
        	float dd, hr, totao = 0.0;
            float sca = 1.0;
            vec4 aopos; 
             for( int aoi=0; aoi<5; aoi++ ) {
                 hr = 0.01 + 0.05*float(aoi);
                  aopos =  nor * hr + pos;
                   totao += -(map( aopos ).x-hr)*sca;
                   
                    sca *= 0.75;
            }
             return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
        }

// Function 241
vec3 calcLighting(Hit scn, vec3 n) {
 
    float d = max(dot(LIGHT_DIR,n), 0.);
    d *= softshadow(scn.p + LIGHT_DIR * .001, LIGHT_DIR, 0.2, 16.);
    
    return LIGHT_COL * d;
    
}

// Function 242
float plight(vec3 n,vec3 rpos,vec3 eye,float nl)
{
    vec4 ld = getlight(nl);
	return light(n,rpos,eye,ld.xyz)*ld.w;
}

// Function 243
float cao( in vec3 p, in vec3 n, float maxDist )
{
	float ao = 0.0, l;
	const float nbIte = 6.0;
	const float falloff = 1.5;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + hash(i))*.5/nbIte*maxDist;
        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);
    }
	
    return clamp( 1.-ao/nbIte, 0., 1.);
}

// Function 244
float AO(in vec3 o,in vec3 d,float s){//origin, direction, scatterHash
 ;float t=.0,a=1.,f,n=.01+.04*s
 ;for(float i=.0;i<iterAO;i++ 
 ){f=max(gd(o+d*t)*1.5,n)
  ;a=min(a,f/t+t*0.5)
  ;t+=f;
 }return a;}

// Function 245
float shadow(vec3 p) {
	float sh=1.,td=.1;
    for (int i=0; i<50; i++) {
		p+=ldir*td;
        float d=de(p);
		td+=d;
        sh=min(sh,10.*d/td);
        if (sh<.05) break;
    }
    return clamp(sh,0.,1.);
}

// Function 246
LightPath lightPath() {
    return LightPath(
        point(),
        elight,
        // normal
        O3,
        // distance from light
        o1,
        // direction to light (incident ray)
        O3,
        // direction to camera (view ray)
        O3,
        // direction reflected light (reflected ray)
        O3,
        // direction to light in spherical coordinates (incident ray)
        O2,
        // direction to camera in spherical coordinates (view ray)
        O2,
        // direction reflected light in spherical coordinates (reflected ray)
        O2,
        // energy
        o1
    );
}

// Function 247
float SampleShadow(int id, vec2 uv)
{
    float a = atan(uv.y, uv.x)/tau + 0.5;
    float r = length(uv);
    
    float idn = float(id)/iResolution.y;
    
    float s = texture(iChannel0, vec2(a, idn) + hpo).x;
    
    return 1.0-smoothstep(s, s+0.02, length(uv));    
}

// Function 248
bool traceShadow(in vec2 origin, in vec2 toLight) {
    float maxDist = length(toLight);
    vec2 direction = toLight / maxDist;
    float totalDist = 0.0;
    for(int i = 0; i < STEPS; i++) {
        float dist = lookup(origin).x;
        if(dist < EPSILON) {
            return true;
        }
        origin += direction * dist;
        totalDist += dist;
        if(totalDist >= maxDist) {
            return false;
        }
        /*if(dot(origin, origin) > 10.0) {
            return false;
        }*/
    }
    return true;
}

// Function 249
vec3 lighting(vec3 pos, vec3 rayDir)
{
    vec3 n = calculateNormals(pos);
    
    vec3 ambientColor = vec3(0.0,0.0,0.0);
    vec3 diffuseColor = vec3(0.5,0.5,0.5);
    vec3 specColor = vec3(1.0,1.0,1.0);
    vec3 lightColor = vec3(1.0,1.0,0.8);
    vec3 ssColor = vec3(0.1,0.1,0.3);
    
	vec3 light = vec3(0.0, 2.0, 5.0);


	float s = softshadow(pos + n*0.15, light, 0.01, 20.0);
	float ao = calculateAO(pos, n);
	float diff = max(0.0, dot(normalize(light), n))*s;
	float fresnel = (1.0 - dot(n, -rayDir));
	vec3 r = reflect(normalize(rayDir), n);
    float refl = softshadow(pos + n*0.15, r, 0.01, 20.0);
	float spec = pow(max (0.0, dot (r, rayDir)), 20.0);

	vec3 sky = skyBox(r,0.1);
	vec3 res = diffuseColor;
	res *= ambientColor*ao;
	res += diff*lightColor*0.5;
    res += spec*lightColor*specColor*fresnel*ao;
    res += sky*fresnel*0.25;
    res += sky*0.2;
    res	+= (1.0 - refl)*0.5*diffuseColor;
    res += (1.0 - diff)*ssColor;
	return res;
}

// Function 250
float shadow(in vec3 origin, in vec3 direction) {
    float hit = 1.0;
    float t = 0.02;
    
    for (int i = 0; i < 1000; i++) {
        float h = scene(origin + direction * t).x;
        if (h < 0.001) return 0.0;
        t += h;
        hit = min(hit, 10.0 * h / t);
        if (t >= 2.5) break;
    }

    return clamp(hit, 0.0, 1.0);
}

// Function 251
float dShadow(vec3 wp, Light l)
{
    vec3 rd = normalize(l.pos-wp);
    /* last param for march(): make it smaller for better performance but less shadows */
    float d = march(wp+(sdist+.02)*rd, rd, 0., 5.).x;
    return clamp(mix(0., .2, d), 0., 1.);
}

// Function 252
vec3 texLight(vec3 v)
{
    return vec3(abs(nrm(v).z));
}

// Function 253
float shadow (vec3 o) {
    vec3 dir = lightSource-o;
    vec3 lightDirection = -normalize(dir);
    float t = iTime;
    float shadow = 1.0;
    for (int i = 0; i < 16; ++i) {
        float ar = float(i)/16.0 * 2.0 - 1.0;
        vec3 sample_ = vec3(ar,1.0-ar,1.0-ar);
        vec3 lightDir = -lightDirection+sample_*0.05;
        // ray to the light source
        vec3 or = o;
        if (o.y < -RADIUS + 0.0001)
            or += lightDir*0.01;
        else
            or -= lightDir*0.01;
        float lightInter = scene(or, lightDir);
        if (lightInter > 0.0 && lightInter < length(dir))
        shadow *= 0.95;
	}
    return shadow;
}

// Function 254
vec3 shader3(){
	vec3 color=(parteB()+parteC()+parteD())/1.5;
	return color;
}

// Function 255
float castShadow( in vec3 ro, vec3 rd, float time )
{
    float res = 1.0;
    float t = 0.00;
    for( int i=0; i< 100; i++ )
    {
        vec3 pos = ro + t*rd;
        float h = map( pos, time ).x;
        res = min( res, 16.0*h/t );
        if ( res<0.001 ) break;
        t += h;
        if( t > 10.0 ) break;
    }

    return clamp(res,0.0,1.0);
}

// Function 256
vec3 lights(vec3 p, vec3 rd, float d, Hit h) {
	float am, ldt, l, spe,
	      sped = 4.;
	vec3 c, n, lig,
	     ld = normalize(vec3(30, 50, -40) - p);
	if (h.id == 4) {
		// Snow
		c = vec3(1.2 + SSS(1.) * .44);
		n = normalize(calcTN(p, d) + n31(h.uv) * .1);
		am = mix(.3, .9, sdTerrain(p + n).d);
		sped = .4;
	}
	else {
		n = calcN(p, d);
		am = mix(ao(p, n, .5), ao(p, n, 1.2), .75);
		if (h.id == 1 || h.id == 6) {
			// Metal
			c = vec3(.3 - n31(h.uv * 18.7) * .1);
			sped = .5;
			if (h.id == 6) c *= 1. - .8 * step(abs(atan(h.uv.y, h.uv.z) - .8), .01); // Cockpit.
		}
		else if (h.id == 2) {
			// Black wing area.
			if (h.uv.x < h.uv.y * .7) h.uv.y = 0.;
			c = vec3(.005 + .045 * pow(abs(sin((h.uv.x - h.uv.y) * 12.)), 20.));
			sped = .2;
		}
		else if (h.id == 7) {
			// Gunz.
			c = vec3(.02);
			sped = .2;
		}
		else if (h.id == 3) c = vec3(.05); // Cockpit glass.
		else if (h.id == 5) c = vec3(.1); // Glass surround.
		else c = vec3(.3, 1, .3); // Fire!
	}

	// Primary light.
	ldt = dot(ld, n);
	l = max(0., .2 + .8 * ldt) + max(0., .2 - .8 * ldt) * .3;
	spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 50.)) * sped;

	// Combine.
	lig = l * am * mix(.4, 1., calcShadow(p, ld)) * vec3(2, 1.8, 1.7) + clamp(n.y, .05, 1.) * vec3(.9, .95, 1); // Sky light.
	return c * lig + spe;
}

// Function 257
void getOffsetLight(vec3 position, vec3 normal, vec3 rayDirection, vec3 lightOffset, float maxDistance, float shininess, out float diffuseBrightness, out float specularBrightness) {
    float distance = length(lightOffset);
    if (distance > maxDistance) {
        diffuseBrightness=0.0;
        specularBrightness=0.0;
        return;
    }
    vec3 lightDirection = normalize(lightOffset);
    float dotProd = dot(lightDirection,normal);

    if (dotProd <= 0.0) {
        diffuseBrightness=0.0;
        specularBrightness=0.0;
        return;
    }

    //fake the light falloff to limit distance
    float fallOff = (1.0-clamp((distance/maxDistance),0.0,1.0));
    fallOff*=fallOff;

    //dotProd = pow(dotProd,shine);
    diffuseBrightness = clamp(dotProd,0.0,1.0) * fallOff;

    vec3 specDirection = reflect(lightDirection, normal);
    dotProd = dot(specDirection, rayDirection);
    dotProd = pow(clamp(dotProd,0.0,1.0),shininess);
    //dotProd *= diffuseBrightness;
    dotProd *= fallOff;
    specularBrightness = dotProd;
}

// Function 258
vec3 shade( in vec3 ro, in vec3 pos, in bool shadow, in float m, in float r ) {
    vec3 light, col = vec3(0.);
    vec3 nor = calcNormal(pos);
    
	vec2 id = getSectorId(pos.z);

    float occ = calcOcc( pos, nor );
    float dist, sh = 1., xo = xoffset(pos.z);

    float rc = hash(id.x+43.);
    float gc = hash(id.x+153.);
    vec3 lc = normalize(vec3( max(rc,gc), min(rc,gc), 0.1 ) );
    
    if( id.y > 0.75 ) {
    	light = vec3( -xo, 6.5, id*12. );
        light.xz += vec2( hash(id.x+56423.), hash(id.x+124.) ) - 0.5;
        sh =  8.;
        dist = 8.;
    } else {
	    light = vec3( -xo, 3.9, id*12. );
        sh = 3.;
        dist = 5.3;
        if( hash(id.x+234.) < 0.15 ) lc *= 1.-clamp( 10.*(fbm( vec2(time*10., id.x) )-2.5*id.y), 0., 1.);
        if( pos.y > 4. ) sh*=0.5;
    }
    
    sh *=  calcLightning( pos, light, nor, dist, shadow );
    
       
    if( m < 6.5 ) col = texcube( iChannel0, pos*0.5, nor ).xyz;
    if( m == 1. ) col *= 0.05;
    if( m == 4. && pos.y > 2. ) col *= vec3(0.1,0.,0.);
    if( m == 4. && pos.y < 2. ) col *= vec3(0.1,0.4,1.2);
    
    if( m == 5. ) col *= (1.+0.5*fbm(pos.yz*2.))*vec3(0.2,0.1,0.05);
    if( m == 2. ) col *= vec3(0.8,0.6,0.4);
    
    col *= lc * occ * sh;  
    
    if( m == 6. ) col = mix( 0.1*col, col*fbm(pos.xz*10.) + 0.8*lc, 
                           (1.-smoothstep( 4.15, 4.2,pos.y)) *
                           smoothstep( 0.01, 0.04,abs(mod(pos.z+0.15,0.3)-0.15)) *
                           smoothstep( 0.01, 0.02,abs(pos.x+xo)));

    col *= clamp(1.-2.*r, 0.65, 1.);
    
	col = mix(  0.05*backgroundColor, col, exp( -0.04*distance(pos, ro) ) );
  

    return col;
}

// Function 259
vec3 sampleLightE( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )
{
    vec3 e = vec3( 0 );
    vec3 s = vec3( 0 );

    Light light;
    light.id = 3.0;
    light.emission = LIGHT1_EM;

    vec3 l0 = LIGHT1_POS - hitOrigin;

    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    float cosa = mix(cos_a_max, 1., random());
    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );
#endif
    {
        float omega = 2. * PI * (1. - cos_a_max);
        vec3 n = normalize(hitOrigin - LIGHT1_POS);
        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);
    }

    light.id = 4.0;

    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;

    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    cosa = mix(cos_a_max, 1., random());
    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );
#endif
    {
        float omega = 2. * PI * (1. - cos_a_max);
        vec3 n = normalize(hitOrigin - vec3( -4, 1.5, 4 ));
        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);
    }

#if (PATH == 0)
    e *= clamp( s, 0., 1. );
#endif

    return e;
}

// Function 260
vec3 shade(in vec3 ro, in vec3 rd) {
    	
    // the color we will return
    vec3 color = fog_color;

    // find nearest hex center to ray origin
    vec2 cur_cell = nearestHexCell(ro.xy);

    // get the three candidate wall normals for this ray (i.e. the
    // three hex side normals with positive dot product to the ray
    // direction)

    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);
    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);
    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);

    // initial cell height at ray origin
    float cell_height = height_for_pos(CART_FROM_HEX(cur_cell));
    
    // reflection coefficient
    float alpha = 1.0;

    // march along ray, one iteration per cell
    for (int i=0; i<80; ++i) {
        
        // we will set these when the ray intersects
        bool hit = false;
        vec4 hit_nt;
        float bdist = 1e5;

        // after three tests, ht.xy holds the hex grid direction,
        // ht.z holds the ray distance parameter
        vec2 cur_center = CART_FROM_HEX(cur_cell);
        vec2 rdelta = ro.xy-cur_center;
        
        vec3 ht = rayHexIntersect(rdelta, rd.xy, h0);
        ht = rayMin(ht, rayHexIntersect(rdelta, rd.xy, h1));
        ht = rayMin(ht, rayHexIntersect(rdelta, rd.xy, h2));

        // try to intersect with top of cell
        float tz = (cell_height - ro.z) / rd.z;

        // if ray sloped down and ray intersects top of cell before escaping cell
        if (ro.z > cell_height && rd.z < 0.0 && tz < ht.z) {

            // set up intersection info
            hit = true;
            hit_nt = vec4(0, 0, 1.0, tz);   
            vec2 pinter = ro.xy + rd.xy * tz;

            // distance to hex border
            bdist = hexDist(pinter - cur_center);

        } else { // we hit a cell wall before hitting top.

            // update the cell center by twice the grid direction
            cur_cell += 2.0 * ht.xy;
            
            vec2 n = CART_FROM_HEX(ht.xy);
            cur_center = CART_FROM_HEX(cur_cell);

            float prev_cell_height = cell_height;
            cell_height = height_for_pos(cur_center);

            // get the ray intersection point with cell wall
            vec3 p_intersect = ro + rd*ht.z;

            // if we intersected below the height, it's a hit
            if (p_intersect.z < cell_height) {

                // set up intersection info
                hit_nt = vec4(n, 0.0, ht.z);
                hit = true;

                // distance to wall top
                bdist = cell_height - p_intersect.z;

                // distance to wall bottom
                bdist = min(bdist, p_intersect.z - prev_cell_height);

                // distance to wall outer side corner
                vec2 p = p_intersect.xy - cur_center;
                p -= n * dot(p, n);
                bdist = min(bdist, abs(length(p) - 0.5/hex_factor));

            }

        }                      
        
        if (hit) {
            
            // shade surface
            vec4 hit_color = surface(rd, cur_cell, hit_nt, bdist);
            
            // mix in reflection
            color = mix(color, hit_color.xyz, alpha);
            
            // decrease blending coefficient for next bounce
            alpha *= 0.17 * hit_color.w;
            
            // re-iniitialize ray position & direction for reflection ray
            ro = ro + rd*hit_nt.w;
            rd = reflect(rd, hit_nt.xyz);
            ro += 1e-3*hit_nt.xyz;
                        
            // re-initialize candidate ray directions
            h0 = alignNormal(vec2(0.0, 1.0), rd.xy);
            h1 = alignNormal(vec2(1.0, 0.5), rd.xy);
            h2 = alignNormal(vec2(1.0, -0.5), rd.xy);

        }

    }
    
    // use leftover ray energy to show sky
    color = mix(color, fog_color, alpha);
    
    return color;
	
}

// Function 261
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    lowp float t;
	
	t = iSphere( ro, rd, vec4( 1.5 + sway(),0.5 + bounce(), 2.7,1.0) );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,0.5 + bounce2(), 4.0,1.0) );  if( t>eps && t<dist ) { return true; }

    return false; // optimisation: planes don't cast shadows in this scene
}

// Function 262
bool isInOtherSphereShadow(vec3 p, Sphere thisSphere, Light light)
{
	for(int i=0; i<numberOfSpheres; i++)
	{
		if(isInShadow(p, spheres[i], light))
			return true;
	}
	return false;
}

// Function 263
vec3
sample_light(vec2 rng)
{
	return light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;
}

// Function 264
vec3 BRDFLightSample(in Intersection intersecNow,out Intersection intersecNext,out vec3 wi,out float pdf){
	vec3 Li = vec3(0.);
    float x1 = GetRandom(),x2 = GetRandom();
    wi = sample_uniform_hemisphere(intersecNow.normal,x1,x2,pdf);
    Ray shadowRay = Ray(intersecNow.surface,wi);
    SceneIntersect(shadowRay, intersecNext);
    return Li;
}

// Function 265
vec3 shade(vec3 p){
    
    vec3 n = normals(p);
    vec3 col = vec3(0.6, 0.4, 0.64);
    col *= ambientOcclusion(p, n, 4.0, 1.0);
    col *= ambientOcclusion(p+vec3(EPSILON, 0.0, 0.0), n, 8.0, 1.0);
    
    return col;
}

// Function 266
vec3 Light(vec3 X, vec3 n, vec3 V)
{
	vec3 lightDir = normalize(vec3(-3,8,-5));

	vec3 c = vec3( max(dot(lightDir, n), 0.) );

	c = pow(texture(iChannel0,n).xyz,vec3(2.2));
	
		
#ifdef SHADOWS	
	float sha = shadow(X,n,lightDir);
	c *= sha;
#endif

	c += 0.3;
	
#ifdef AO	
	float ao = Ao(X, normalize(n) );
//	return vec3(ao);
	c *= ao;
#endif	
	
#ifdef COLORS	
	vec2 aX = abs(X.xz+vec2(1.*brick_w,23.*brick_w));
	float mX = max(aX.x,aX.y);
	
	const float mat_test = 0.08;
	if (AddStuds(BrickSDFY(X),X) < mat_test)
		c *= pow(vec3(245./255.,205./255.,47./255.),vec3(2.2));  //yellow
	else if (AddStuds(RedBrickSDFY(X),X) < mat_test)
		c *= pow(vec3(196./255.,40./255.,27./255.),vec3(2.2)); //red
	else if (mX < 30.*brick_w)
		c *= pow(vec3(161./255.,165./255.,162./255.),vec3(2.2)); //gray
	else if (mX < 44.*brick_w)		
		c *= pow(vec3(13./255.,105./255.,171./255.),vec3(2.2));  //blue
	else
		c *= pow(vec3(40./255.,127./255.,70./255.),vec3(2.2));  //green
#endif	
		
	//vec3 h = normalize(V+lightDir);
	//c += ao * sha *pow(max(dot(n,h),0.),80.0); //*2.5;

	return c;
}

// Function 267
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float ph = 1e20; //
    for( float t=mint; t<maxt; )
    {
        float h = sdf(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        float y = h*h/(2.5*ph); //
        float d = sqrt(h*h-y*y);
        res = min( res, k*d/max(0.001,t-y) );
        ph = h;
        t += h;
    }
    return res;
}

// Function 268
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 16; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.05;    
    float end = max(length(rd), 0.001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.
        dist += clamp(h, 0.02, 0.25);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.
    return min(max(shade, 0.) + 0.5, 1.0); 
}

// Function 269
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<1; i++ )
    {
		float h = df( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += h*.25;
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0., 1. );
}

// Function 270
vec3 DirectLightSample(in Intersection intersecNow,out vec3 wi,out float pdf){
	vec3 Li = vec3(0.);
    float x1 = GetRandom(),x2 = GetRandom();
    float dist = INFINITY;
    vec3 AssumeLi = LightSample(intersecNow.surface,x1,x2,wi,dist,pdf);
    Ray shadowRay = Ray(intersecNow.surface,wi);
    Intersection intersecNext;
    SceneIntersect(shadowRay, intersecNext);
    if(intersecNext.type == LIGHT){
    	Li = AssumeLi;
    }
    return Li;
}

// Function 271
void Construct_Light ( int idx, float3 ori, float3 N, float3 emi,
                       float2 radius ) {
  lights[idx] = Light(ori, N, emi, radius);
}

// Function 272
int TraceShadow(vec3 ro, vec3 rd)
{
	int hit;
	vec3 pos;
	float dist2 = DistanceFields(ro, rd, hit, pos);
	return hit;
}

// Function 273
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test 
    // machine, anyway.
    const int maxIterationsShad = 24; 
    
    ro += n*.0015;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the 
    // lowest number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<maxIterationsShad; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        // Subtle difference. Thanks to IQ for this tidbit.
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); 
        // So many options here, and none are perfect: dist += min(h, .2), 
        // dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .25); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 274
vec3 lightPosition()
{
    vec3 dir = vec3(0.0, 2.0, 0.0);
    
    dir = rotX(dir, -0.15 * TAU);
    dir = rotY(dir, time * 0.1 * TAU);
    
    return dir;
}

// Function 275
bool shadowRayIntersect(Ray r, Sphere s[SN], float tmin, float tmax)
{
    for(int i=0;i<SN;++i)
    {
        float t = intersect(r, s[i]);
        if(t>tmin && t<tmax)
        {
            return true;
        }
    }
    return false;
}

// Function 276
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7),0.5);
}

// Function 277
vec3 Shade(vec3 p, vec3 n, vec3 r, DirectionalLight sun, DirectionalLight moon)
{
     // Point light
    const vec3 lp = vec3(-20.0, -20.0, 10.0);
    
    // Light direction to point light
    vec3 l = normalize(lp - p);

    // Ambient color
    vec3 ambient = SkyAmbient(sun) * 0.3;

    // Ambient occlusion
    ambient *= AmbientOcclusion(p, n);

    vec3 surface = vec3(1);

    // Lambert diffuse
    vec3 diffuse = vec3(0);
    vec3 specular = vec3(0);

    // Compute all points lights
    for (int i=0; i<num_lights; ++i) {

        PointLight light = lights[i];

        diffuse += ComputePointLight(p, n, r, light, specular);
    }

    // Compute sun and moon lighting
    if (sun.direction.z > 0.0)
        diffuse += ComputeDirectionalLight(p, n, r, sun, specular);

    if (moon.direction.z > 0.0)
        diffuse += ComputeDirectionalLight(p, n, r, moon, specular);

    return (ambient + diffuse)*surface + specular;
}

// Function 278
float shadow (in vec3 ro, in vec3 rd) 
{
    float mint = .0001;
    float tmax = 3.; 
    float res = 1.; 
    float t = mint;
    float ph = 1e10;
        
    for (int i = 0; i < MAX_ITER; i++)
    {   
        float h = scene (ro + rd*t).d;
        float y = (i == 0) ? .0 : h*h/(2.*ph);
        float d = sqrt (h*h - y*y);
        res = min (res, 10.*d/max (.0, t -y));
        ph = h;
     
        t += h;
            
        if (res < .0001 || t>tmax) break;
    }   

    return clamp (res, .0, 1.);
}

// Function 279
void light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){
   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; 
   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));
   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))
   ;float sunDif =  max(0.0, dot(ssundir, nor))
   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)
   ;iColor += sunCol * sunDif * sunSha
   ;vec3 h = normalize( sunDir - rd )
   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )
   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )
   ;iColor += spe * shl * sunCol * sunSha * sunDif
   ;}

// Function 280
void sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {
#ifdef SAMPLE_LIGHT_AREA
    vec3 n = randomDirection( Xi1, Xi2 );
    vec3 p = sphere.pos + n*sphere.radius;
    float pdfA = 1.0/sphere.area;
    
    vec3 Wi = p - x;
    
    float d2 = dot(Wi,Wi);
    sampleRec.d = sqrt(d2);
    sampleRec.w = Wi/sampleRec.d; 
    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );
    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );
#else
    vec3 w = sphere.pos - x;	//direction to light center
	float dc_2 = dot(w, w);		//squared distance to light center
    float dc = sqrt(dc_2);		//distance to light center
    
    if( dc_2 > sphere.radiusSq ) {
    	float sin_theta_max_2 = sphere.radiusSq / dc_2;
		float cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );
    	float cos_theta = mix( cos_theta_max, 1.0, Xi1 );
        float sin_theta_2 = 1.0 - cos_theta*cos_theta;
    	float sin_theta = sqrt(sin_theta_2);
        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );
    	sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );
        
        //Calculate intersection distance
		//http://ompf2.com/viewtopic.php?f=3&t=1914
        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);
    } else {
        sampleRec.w = randomDirection( Xi1, Xi2 );
        sampleRec.pdf = 1.0/FOUR_PI;
    	raySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );
    }
#endif
}

// Function 281
vec3 lighting(in vec3 position, in vec3 normal, in vec3 viewDir, in Material material, in float shadow)
{
    vec3 lightDir = lightDirection();
    vec3 lightCol = lightColor();
    
    // Specular
    float ndoth = dot(normal, normalize(-viewDir - lightDir));
    float specularBlinnPhong = pow(max(ndoth, 0.0), material.roughness);
    
    // Diffuse
    float ndotl = dot(normal, -lightDir);
    float diffuseLambert = max(0.0, ndotl);
    
    // Final terms
    float ambient = 0.4;
    float diffuse = diffuseLambert * shadow;
    float specular = specularBlinnPhong * material.shininess * diffuse;
    
    return (ambient * material.albedo + (diffuse * material.albedo + specular))* lightCol;
}

// Function 282
vec3 sampleIndirectLight(vec3 pos, vec3 normal){
    vec3 dir = getCosineWeightedSample(normal);
    vec3 light = vec3(0.);
    for(int i = 0; i < Bounces; i++){
        if(!trace(pos, dir, normal)) return light+background(dir);
        else light += directLight(pos, normal);
    }
    return light;
}

// Function 283
vec3 shade ( vec3 v, float t ) {
	vec3 f = vec3(.8);
    vec2 m = map(v);
    float mat = m.y;
    if (mat==1.) {
    	float val = texture(iChannel0, v.xz/10.).r;
        f=mix(vec3(.8),vec3(val), 1.-t/150.);
    } else if (mat==0.) {
        vec3 n = normal(v);
         vec2 u=uv(n);
        vec3 val = texture(iChannel1, u).rgb;
        f=val;
    }
    f=mix(vec3(.8),f,clamp(1.5-t/40.,0.,1.));
    f*=1.-ao(v)/8.;
    return f;
}

// Function 284
vec3 lighting(const Ray ray, const RaycastHit hit) {
 
    float diffuse = ambientLight;
    vec3 l1 = light1 - hit.point;
        
    diffuse += max(dot(normalize(hit.normal),normalize(l1)),0.);
    return vec3(diffuse);
    
}

// Function 285
float calculateAO(in vec3 pos, in vec3 nor)
{
	float sca = 1.5, occ = 0.0;
    for( int i=0; i<5; i++ ){
    
        float hr = 0.01 + float(i)*0.5/4.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 286
vec3 Shade(MarchResult hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(1.0);
    
    //Triangle grid pattern
    vec2 gridRep = mod(hit.position.xy, vec2(QUAD_SIZE)) / float(QUAD_SIZE) - 0.5;
    
    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));
    grid = min(grid, abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));
    
    float lineSize = GRID_LINE_RADIUS * hit.dist / iResolution.y / float(QUAD_SIZE);
    
    color *= 1.0-smoothstep(lineSize, lineSize * 0.25, grid);
    color = color * 0.75 + 0.25;
    
    //Lighting
    float ambient = 0.1;
    float diffuse = 0.5 * -dot(hit.normal, direction);
    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));
    
    color *= vec3(ambient + diffuse + pow(specular, 5.0));
	
    //Fog / haze
    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));
    float haze = 1.0 - (hit.steps / float(MAX_STEPS));
    
    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));
    
    color = mix(skycol, color, sky * haze);
    
    return color;
}

// Function 287
vec3 GetLighting(Intersection i, vec3 origin)
{
	vec3 color = vec3(0);
	Light light;
	
    // or just set X to -2.0 to stop animation
	light.p = normalize(vec3(2.0*sin(iTime*0.5),2.0,-2.0));
	light.color = vec3(2.5);
	color += CalcLighting(light, i, origin);

	return color;
}

// Function 288
vec3 CalcLightingForPointOnBlob( vec3 seed, vec3 pos, vec3 normal CACHEARG )
{
    vec3 light = vec3( 0.0 );
    vec3 ceilingPos = RandomPointOnCeiling( seed );
    vec3 lightDir = normalize( ceilingPos - pos );

    float lightDot = dot( lightDir, normal );
    vec3 ignoreHitPos;
    if ( lightDot > 0.0 && !MarchShadowRay( pos, lightDir, ignoreHitPos CACHE ) )
        light += LIGHT_COLOR * lightDot;

    vec3 ambientTestDir = GetRandomWeightedHemisphereDir( seed, normal );
    vec3 ambientColor = mix( AMBIENT_LIGHT_FROM_BELOW, AMBIENT_LIGHT_FROM_ABOVE, ambientTestDir.y * 0.5 + 0.5 );
    vec3 shadowApproxHitPos;
    if ( MarchShadowRay( pos, ambientTestDir, shadowApproxHitPos CACHE ) )
        light += MIN_AMBIENT * ambientColor + BLOB_EMISSION_LIGHT * BlobEmissionAmountAtPos( shadowApproxHitPos );
    else
        light += ambientColor;
    
    light *= GetBrightnessForTime( blobTime );
    
    return light;
}

// Function 289
vec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }

// Function 290
float softShadow(in vec3 ro, in vec3 rd, float t, in float end, in float k){

    float shade = 1.0;
    // Increase this and the shadows will be more accurate, but more iterations slow things down.
    const int maxIterationsShad = 24; 

    // The "start" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with 
    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.
    // If adding shadows seems to make everything look dark, that tends to be the problem.
    float dist = .001*(1. + t*.05);
    float stepDist = end/float(maxIterationsShad);

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<maxIterationsShad; i++){
        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that
        // you may hit a surface not between the surface and the light.
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));
        
        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find 
        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.
        // Anyway, here's some posibilities. Which one you use, depends on the situation:
        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.
        
        dist += clamp(h, 0.01, 0.25);
        
        // There's some accuracy loss involved, but early exits from accumulative distance functions can help.
        if (h<0.0001 || dist > end) break; 
    }

    // Return the shadow value. Note that I'm not using clamp. The shadow value should be capped to zero
    // prior to adding a constant... Unless you're not adding a constant. :)
    return min(max(shade, 0.) + .1, 1.); 
}

// Function 291
float marchToLight(vec3 p, vec3 sunDir, float sunDot, float scatterHeight)
{
    float lightRayStepSize = 11.;
	vec3 lightRayDir = sunDir * lightRayStepSize;
    vec3 lightRayDist = lightRayDir * .5;
    float coneSpread = length(lightRayDir);
    float totalDensity = 0.;
    for(int i = 0; i < CLOUD_LIGHT_STEPS; ++i)
    {
        // cone sampling as explained in GPU Pro 7 article
     	vec3 cp = p + lightRayDist + coneSpread * noiseKernel[i] * float(i);
        float y = cloudHeightFract(length(p));
        if (y > .95 || totalDensity > .95) break; // early exit
        totalDensity += getCloudDensity(cp, y, false) * lightRayStepSize;
        lightRayDist += lightRayDir;
    }
    
    return 32. * exp(-totalDensity * mix(CLOUD_ABSORPTION_BOTTOM,
				CLOUD_ABSORPTION_TOP, scatterHeight)) * (1. - exp(-totalDensity * 2.));
}

// Function 292
void UpdateLightDirection()
{
	vec3 normalLight = normalize(vec3(0.2, 0.9, 0.2));
	float radTheta = 2.0 * g_gPi * g_t / 60.0;
	float gSin = sin(radTheta);
	float gCos = cos(radTheta);
	mat2 matRot = mat2(gCos, -gSin, gSin, gCos);
	normalLight.xy = matRot * normalLight.xy;
	g_normalLight = normalLight;
}

// Function 293
vec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, out vec3 miecolor)
{
    vec3 light = vec3(0.0);
    float tmin = 0.0;
    float tmax = 0.0;
    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);
    vec3 Pa = ro+rd*tmax;
    /*if(d>0.0)
        Pa = ro+rd*(tmax-tmin);*/
    float RdotL = dot(rd, L);
    float tCurrent = 0.0;
    float segL = tmax/16.0;
    /*if(d>0.0)
        segL = (tmax-tmin)/16.0;*/
    float g = 0.76; // 0.76
    float g2 = g*g;
    float hr = 7994.0; // 7994
    float hm = 300.0; // 1200
    // Rayleigh
    vec3 sumR = vec3(0.0);
    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);
    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);
    float opticalDepthR = 0.0;
    // Mie
    vec3 sumM = vec3(0.0);
    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));
    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html
    // my implementation has an error with the first terms in the equation
    float phaseM = (
        			(3.0*(1.0-g2))/
        			(2.0*(2.0+g2))
        			)*
        			(
                        (1.0+RdotL*RdotL)/
                        pow(1.0+g2-2.0*g*RdotL, 1.5)
                    );
    //vec3 betaM = vec3(21e-6);
    float opticalDepthM = 0.0;
    for (int i = 0; i < 16; ++i)
    {
        vec3 X = ro+rd*(tCurrent+0.5*segL);
        float h = length(X) - EARTHRADIUS;
        float _hr = exp(-h/hr)*segL;
        float _hm = exp(-h/hm)*segL;
        opticalDepthR += _hr;
        opticalDepthM += _hm;
        vec3 lRay = L;//normalize((SUNDIST*L)-X);
        float tlmin = 0.0;
        float tlmax = 0.0;
        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);
        float segLLight = tlmax/8.0;
        float tCurrentLight = 0.0;
        float opticalDepthLightR = 0.0;
        float opticalDepthLightM = 0.0;
        bool ended = true;
        for (int j = 0; j < 8; ++j)
        {
            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);
            float hLight = length(samplePositionLight) - EARTHRADIUS;
            if (hLight < 0.0)
            {
                ended = false;
                break;
            }
            opticalDepthLightR += exp(-hLight / hr) * segLLight;
            opticalDepthLightM += exp(-hLight / hm) * segLLight;
            tCurrentLight += segLLight;
        }
        if (ended)
        {
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);
            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));
            sumR += _hr * attenuation;
            sumM += _hm * attenuation;
        }
        tCurrent += segL;
    }
    miecolor = SUNINTENSITY * sumM * phaseM;
    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);
}

// Function 294
float softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k){

    float shade = 1.0;
    // Increase this and the shadows will be more accurate, but the wispy light trails in the caves will disappear.
    // Plus more iterations slow things down, so it works out, in this case.
    const int maxIterationsShad = 10; 

    // The "start" value, or minimum, should be set to something more than the stop-threshold, so as to avoid a collision with 
    // the surface the ray is setting out from. It doesn't matter how many times I write shadow code, I always seem to forget this.
    // If adding shadows seems to make everything look dark, that tends to be the problem.
    float dist = start;
    float stepDist = end/float(maxIterationsShad);

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){
        // End, or maximum, should be set to the distance from the light to surface point. If you go beyond that
        // you may hit a surface not between the surface and the light.
        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0., 1., k*h/dist));
        
        // What h combination you add to the distance depends on speed, accuracy, etc. To be honest, I find it impossible to find 
        // the perfect balance. Faster GPUs give you more options, because more shadow iterations always produce better results.
        // Anyway, here's some posibilities. Which one you use, depends on the situation:
        // +=max(h, 0.001), +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.
        
        // In this particular instance the light source is a long way away. However, we're only taking a few small steps
        // toward the light and checking whether anything "locally" gets in the way. If a part of the scene a long distance away
        // is between our hit point and the light source, it won't be accounted for. Technically that's not correct, but the local
        // shadows give that illusion... kind of.
        dist += clamp(h, .2, stepDist); // For this example only. Not to be trusted. :)
        
        // There's some accuracy loss involved, but early exits from accumulative distance function can help.
        if (abs(h)<0.001 || dist > end) break; 
    }

    // I usually add a bit to the final shade value, which lightens the shadow a bit. It's a preference thing. Really dark shadows 
    // look too brutal to me.
    return min(max(shade, 0.) + .1, 1.); 
}

// Function 295
vec3 sfMissShader(Ray r) {
    if (iMouse.z > 0.1) return sfShadeSkyShirley(r);
    return sfShadeSkyDawn(r);
}

// Function 296
function SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}

// Function 297
float evaluateShadows(vec3 origin, vec3 toLight)
{
    float res = 1.0;
    
    for( float t = .05; t < 2.0; )
    {
        float h = sdf_simple(origin + toLight*t);
        if( h < 0.001 )
            return 0.0;
        
        res = min( res, 12.0*h/t );
        t += h * .5 + .001;
    }
    return res;
}

// Function 298
vec3 sunlight_revealed(in vec2 p) {
    p /= 6.;
    p.x += 2.;
    float a = length(vec2(3.-p.x,p.y)) + abs(p.y) + abs(1.-p.x);
    float f = atan(p.y,p.x-1.);
    float c = atan(p.y,p.x-3.);
    float R = sq(p.x-1.) + sq(p.y);
    vec3 col = vec3(0);
    bool mix = false;
    if(5. < a && a < 7. && mod(f,PI/7.) < PI/14.) {
        col += vec3(0.,82./256.,173./256.);
        if(mix) col /= 2.;
        mix = true;
    }
    if(5. < a && a < 7. && mod(c,PI/9.) < PI/18.) {
        col += vec3(1,0,0);
        if(mix) col /= 2.;
        mix = true;
    }
    if(5. < a && a < 7. && mod(f,PI/8.) < PI/16.) {
        col += vec3(1,1,0);
        if(mix) col /= 2.;
        mix = true;
    }
    if((45.-3.*p.x)*PI/180. < f && f < (47.-p.x)*PI/180. && p.y > 0.1*p.x
       && mod(log(R)/log(f),2.) < 1.) {
        col += vec3(1);
        if(mix) col /= 2.;
    }
    return col;
}

// Function 299
vec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, 
                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {
	vec3 sunDirection =  terrainTransform(SUN_DIRECTION);
    float dif = diffuse( n, sunDirection );
    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );
    float sha = terrainCalcShadow( pos, sunDirection );
    float amb = clamp( n.y,0.0,1.0);
        
    vec3 lin  = vec3(0.0);
    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );
    lin += 0.2*amb*upc;
    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));
    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );
}

// Function 300
vec3 shade(vec3 V, vec3 P, vec3 N, float material)
{
    vec3 R = reflect(V, N);
    
    vec3 diffuseLighting = vec3(0.0);
    vec3 specularLighting = vec3(0.0);
    
    // Material parameters
    vec3 albedo = mix( ColourWhite, ColourBlack, smoothstep(MaterialOuterEye, MaterialInnerEye, material));
    albedo = mix( albedo, ColourSkin, smoothstep(MaterialInnerEye, MaterialSkin, material));
    albedo = mix( albedo, ColourLips, smoothstep(MaterialSkin, MaterialLips, material)); 
    float roughness = 0.5*clamp((smoothstep(0.0, MaterialSkin, material))+0.1, 0.0, 1.0);
    
    // Lighting
    float NoV = clamp(-dot(N, V),0.0,1.0);
    float fresnel = 0.04+0.8*pow(1.0-NoV, 5.0);    
    
    {
        vec3 lightDirection = normalize(vec3(-0.3,1.0,0.1));
        vec3 L = lightDirection;
        float NoL = clamp(dot(L,N),0.0,1.0);
        float shadow = 3.0*NoL*calcSoftShadow(P+N*0.05, lightDirection, 3.0);
        diffuseLighting += LightColour*shadow;
        specularLighting += LightColour*shade_specular(N,V,L, roughness, 0.04);
        
    }
        
    diffuseLighting += 0.1*mix( vec3(1.0,0.71,0.51 )*0.5, LightColour*2.0, N.y*0.5+0.5 ); // ambient light
    
    // Outlines
    float outerEdge = pow(smoothstep(0.0,0.2, NoV), 4.0);
    float materialEdge = abs(fract(material)-0.5)*2.0;
    float edge = (outerEdge*materialEdge)*0.8+0.2;    
    
    return (albedo*diffuseLighting + specularLighting)*edge;
}

// Function 301
float cAO(in vec3 pos, in vec3 nor)
{
	float sca = 2.5, occ = 0.0;
    for( int i=0; i<5; i++ ){
    
        float hr = 0.01 + float(i)*0.35/4.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 302
v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}

// Function 303
float segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )
{
    float dm = dot(rd.yz,rd.yz); // dm = 1.0 - rd.x*rd.x
    float k1 = (ro.x-pa.x)*dm;
    float k2 = (ro.x+pa.x)*dm;
    vec2  k5 = (ro.yz+pa.yz)*dm;
    float k3 = dot(ro.yz+pa.yz,rd.yz);
    vec2  k4 = (pa.yz+pa.yz)*rd.yz;
    vec2  k6 = (pa.yz+pa.yz)*dm;
    
    for( int i=0; i<4; i++ )
    {
        vec2  s = vec2(i&1,i>>1);
        float t = dot(s,k4) - k3;
        
        if( t>0.0 )
        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));
    }
    return sh;
}

// Function 304
vec3 shade( in vec4 p, in vec3 n, in vec3 ro, in vec3 rd )
{		
	vec3 ldir = normalize(vec3(-0.8,2.,0.95));
	vec3 albedo, amb, dif, sky, col;
    
    //Sky
    float d = exp( -length(p.xyz-ro)*0.1 );
    if( d < .3 )
    {
        return skyColor(rd);
    }
    
    //Albedo
	float r = rock(p.xyz);
	if(r>.003)
		albedo = vec3(0.65,1.,0.05)*(1.-exp(-(p.y+r*.5)*120.));
	else
	{	
		n = bumpMap(iChannel0,p.xyz*8.,n,.1);
		albedo = triPlanarProj(iChannel0,p.xyz*8.,n);
	}

    //Lighting
    float occ = ambientOcclusion(p.xyz,n, .05, -108.5) * ambientOcclusion(p.xyz,n, .2, -17.);
    float shad = softshadow(p.xyz,ldir);

	dif = vec3(1.,.7,.3) * orenNayar(n,ldir,rd,1.) * shad;
    sky = vec3(.8,.95,1.) * orenNayar(n,vec3(0.,1.,0.),rd,1.) * occ;
	amb = vec3(.9,.95,1.) * occ;
   
    col = albedo * ( dif*2.5 + sky*.1 + amb*.2 );

    //Fog
	col += vec3(1.,.8,.6)*pow(p.w,2.)*.025;
	col = mix(col, vec3(.8,1.,1.), min(length(p.xyz-ro)*.001, 1.));

	return col;
}

// Function 305
vec3 Shade(vec3 u,vec3 ray,vec3 n
,vec3 ld1,vec3 ld2,vec3 lc1,vec3 lc2
,float sm1,float sm2,float d){  
;vec3 light=vec3(0);
;vec3 a=envBright*mix(vec3(.2,.27,.4),vec3(.4),(-n.y*.5+.5));// ambient
//;a=mix( vec3(.03,.05,.08), vec3(.1),(-n.y+1.0) );
//;vec3 a = envBright*mix(vec3(.2,.27,.4),vec3(.4),(-n.y*.5+.5)); 
//		a = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); 
;light+=a
//ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3
;float specular=Noise(u/vec3(.05,.2,.05)).x
;vec3 rray = reflect(ray,n)
;vec3 reflection=cSky(rray)
;float aoRange=d/20.
#ifdef doOcclusion
 ;float occlusion=max(0.,1.-dg(u+n*aoRange)/aoRange)// can be > 1.0
 ;occlusion=weakc(occlusion)//used multiple times
 #ifdef doOccludeAmbient
 // reduce occlusion to imply indirect sub surface scattering:
 ;if(Toggle(kAmbientOcclusion))a*=occlusion*.8+.2
 #endif
 ;float p=exp2(3.0+5.0*specular)//specular power
 ;vec3 MC=vec3(.9,.5,.5)
 ;light+=Shades(u,ray,n,ld1,lc1,MC,sm1,d,a,p)
 ;light+=Shades(u,ray,n,ld2,lc2,MC,sm2,d,a,p)
 #ifdef doAlbedo
 ;vec3 albedo=vec3(.7,.5,1)
 ;light*=albedo;
 #endif  
 #ifdef doOccludeReflection
 ;if(Toggle(kReflectionOcclusion)){
  // specular occlusion, adjust the divisor for the gradient we expect // can be > 1.0
  ;float specOcclusion = max( 0.0, 1.0 - dg( u + rray*aoRange )/(aoRange*max(.01,dot(rray,n))))
  ;specOcclusion=weakc(specOcclusion)// tweak the curve
  ;specOcclusion*=occlusion;// prevent heavily occluded sparkles
  ;reflection*=specOcclusion
 ;}
 #endif
 #ifdef doOccludeFrensel
 // could fire an additional ray for more accurate reflection|frensel;
 ;float fresnel=pow(1.+dot(n,ray),5.)
 ;fresnel=mix(mix(.0,.01,specular),
              mix(.4, 1.,specular),fresnel)
 ;light=mix(light,reflection,fresnel)
 #endif
#endif
;return light;}

// Function 306
float shadow( Ray r ) {
    float dist = 2.*MinimumDistance;
    float sh = 1.0;
	for( int i = 0; i < MaximumRaySteps; i++ ) {
        vec3 newLocation = r.origin + dist * r.direction;
		float h = DistanceEstimator(newLocation);
        if( h < MinimumDistance || dist > 10.)
            return sh;
        sh = min( sh, 32.*h/dist );
        dist += h;
    }
    return sh;
}

// Function 307
vec3  drawLight(vec3 color, Ray ray, Light light){
    vec3 v = ray.origin - light.position;
	vec3 v_proj = dot(v, ray.direction) * ray.direction;
    float d = length(v - v_proj);
    if (d < light.radius){
       	float a = 1.0 - d/light.radius;
       	color =  mix(color, light.color, pow(a, 4.0));
    }
    return color;
}

// Function 308
float shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){

    float shade = 1.0;
    const int shadIter = 24; 

    float dist = start;
    //float stepDist = end/float(shadIter);

    for (int i=0; i<shadIter; i++){
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.

        dist += clamp(h, 0.02, 0.2);
        
        // There's some accuracy loss involved, but early exits from accumulative distance function can help.
        if ((h)<0.001 || dist > end) break; 
    }
    
    return min(max(shade, 0.) + 0.2, 1.0); 
}

// Function 309
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<50; i++)
    {
    	float h = map(ro + rd*t).x;
        res = min(res, 10.0*h/t + 0.02*float(i));
        t += 0.8*clamp(h, 0.01, 0.35);
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 310
float compute_dynamic_light_atten(vec4 light, vec3 surface_point)
{
    vec3 light_dir = light.xyz - surface_point;
    float dist = length(light_dir);
    float radius = light.w;
    return clamp(1.-dist/abs(radius), 0., 1.) * sign(radius);
}

// Function 311
float getRoadLightStrobe(float distanceFromCamera, float time) {
    return smoothstep(0.0,1.0,clamp(sin(time*5.0 - (distanceFromCamera/RAY_MAX_DISTANCE)*PI*5.0)*0.5,0.0,1.0));
}

// Function 312
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    float t;
	
	t = iSphere( ro, rd, movingSphere            );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }
#ifdef FULLBOX    
    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<dist && ro.z+rd.z*t < 5.5 ) { return true; }
#endif
    return false; // optimisation: other planes don't cast shadows in this scene
}

// Function 313
sShade setDirLight( sLight l, vec3 p, vec3 d, vec3 nor, sMat m ) {
    sShade s;
    vec3 lrd = -l.rd;
    float sf = getShadow( p, nor, lrd, 8.0 );
    vec3 il = l.col * sf * max(0.0, dot(lrd, nor));
    s.dfs = il;
    s.spc = getPhong( d, lrd, nor, m.smt ) * il;
    return s;
}

// Function 314
vec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 ld )
{
    // Get an ambient occlusion value.

    float amb = 1.0;
    
    // Get light colors and radiance for the three lights.
    // (Or just specral radiance if that's your thing.)
    vec3 skc = .6*orenNayar(n,-d,UP)*sky(n,ld);
    vec3 sun = orenNayar(n,-d,ld)*sunColor(ld);
    vec3 gnd = .2*GROUND_COLOR*max(orenNayar(n,-d,-UP),0.25);
    
    // Modulate those by ambient occlussion and shadowing.
    skc *= amb;
    gnd *= amb;
    sun *= shadow(p,n,ld,PENUMBRA_FACTOR);
    
    // Return the sum.
    return skc+gnd+sun; 
}

// Function 315
float lightChoosingPdf(in vec3 x, in int lightId) {
#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE
    float cdf[LIGHT_COUNT];
    
    for(int i=0; i<LIGHT_COUNT; i++) {
        float len = length(lights[i].pos - x);
        cdf[i] = 1.0 / (len * len);
    }
    
    for(int i=1; i<LIGHT_COUNT; i++) {
        cdf[i] += cdf[i - 1];
    }
    
    for(int i=0; i<LIGHT_COUNT; i++) {
        cdf[i] /= cdf[LIGHT_COUNT-1];
    }
    
    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);
#else
   	return 1.0/float(LIGHT_COUNT);
#endif
}

// Function 316
bool ShouldSampleLight(vec3 P, vec3 N, Object light, inout vec3 dbg)
{
	if (IsLight(light)) {
		if (direct_light_dist_enabled && direct_light_dist_max <= 0.0)
			return true;
		else {
			float dmax = direct_light_dist_max;
			float dmin = min(dmax - 0.0001, direct_light_dist_min);
			float ds = 1.0/(dmin - dmax);
			float d0 = -ds*dmax;
			float q = clamp(DistanceToObject(P, light)*ds + d0, 0.0, 1.0); // q=1 @ min dist, q=0 @ max dist
			if (direct_light_dist_dbg) {
				dbg += vec3(q*q);
				return true;
			} else if (q < rand(seed))
				return true;
		}
	}
	return false;
}

// Function 317
float sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )
{
    vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    
#if 0
    // physically plausible shadow
    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;
    float t = -b - sqrt( max(h,0.0) );
    return (t<0.0) ? 1.0 : smoothstep(0.0, 1.0, 2.5*k*d/t );
#else
    // cheap but not plausible alternative
    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );
#endif    
}

// Function 318
void unpackShadow(in vec4 packed, out float depth)
{
    depth = map(packed.r, 0.0, 1.0, MIN_DIST_SHADOW, MAX_DIST_SHADOW);
}

// Function 319
vec4 basicShade( in vec3 inter, in vec4 obj, 
                 in vec4 col, in vec3 rd, 
                 in vec4 luz, 
                 out vec4 ref )
{
    vec2 uv;

    vec3 nor = calcnor( obj, col, inter, uv );

    ref.xyz = reflect( rd, nor );
    float spe = dot( ref.xyz, luz.xyz );
    spe = max( spe, 0.0 );
    spe = spe*spe;
    spe = spe*spe;

    float dif = clamp( dot( nor, luz.xyz ), 0.0, 1.0 );
	bool sh = intersectShadow( inter, luz.xyz, luz.w );
    if( sh )
    {
        dif = 0.0;
		spe = 0.0;
    }

    col *= texture( iChannel0, uv );

    // amb + dif + spec

    float dif2 = clamp( dot( nor, luz.xyz*normalize(vec3(-1.0,0.1,-1.0)) ), 0.0, 1.0 );

	col = col*( 0.2*vec4(0.4,0.50,0.6,1.0)*(0.8+0.2*nor.y) + 
                0.6*vec4(1.0,1.00,1.0,1.0)*dif2 +  
                1.3*vec4(1.0,0.95,0.8,1.0)*dif ) + .5*spe;

    // fresnel
    dif = clamp( dot( nor, -rd ), 0.0, 1.0 );
    ref.w = dif;
    dif = 1.0 - dif*dif;
	dif = pow( dif, 4.0 );
    col += 1.0*vec4( dif )*col*(sh?0.5:1.0);

    return col;
}

// Function 320
vec3 CalculateLightingIBL(          // Ambient lighting
    in vec3 surfNorm,
    in vec3 surfPos,
    in vec3 toView,
    in Material mat)
{
    float ao = 0.0;
    
    vec3 fresnel0 = mix(vec3(0.04), mat.albedo, mat.metallic);
    vec3 ks       = vec3(0.0);
    vec3 diffuse  = CalculateDiffuse(mat.albedo);
    vec3 specular = CalculateSpecularIBL(surfNorm, surfPos, toView, fresnel0, ks, ao, mat.roughness);
    vec3 kd       = (1.0 - ks);
    
    return ((kd * diffuse) + specular) * ao;
}

// Function 321
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );

  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y/20.0, 0.0, 1.0);
  ;
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  float shadow=1.; 
  #ifdef SHADOWS
    shadow = SoftShadow(origin+((rayDir*rayHit.depth)*0.988), sunPos);
  #endif

    lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85)*shadow;
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);
  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00)*shadow;

  return clamp(lightTot, 0., 10.)*sunColor;
}

// Function 322
float shadow(vec3 dir, vec3 origin, float min_t) {
    return softShadow(dir, origin, min_t, 6.0);
}

// Function 323
float SoftShadow(const in vec3 rayOrigin)
    {
        float res = 1.0;
        float t = 0.1;
        float sceneSample_F = float(SHADOW_SAMPLE);

        for(int i=0; i < SHADOW_SAMPLE; ++i)
        {
            vec3  p = rayOrigin + sunDirection * t;
            float h = SceneDistance(p).x;
            res = min(res, sceneSample_F * h / t);

            if(res < 0.1)
                return 0.1;
            
            t += h;
        }

        return res;
    }

// Function 324
vec3 shade (in vec3 ro, in vec3 rd, in float d) {
    vec3 p = ro + d * rd;
    vec3 nor = normal (p);

    // "material" hard-coded for the moment
    float mask = smoothstep (1., .05, 30.*cos (40.*p.y)+sin (40.*p.x)+ cos (40.*p.z));
    vec3 albedo = mix (vec3 (.5), vec3 (.2), mask);
    float metallic = .5;
    float roughness = mix (.9, .1, mask);
    float ao = 1.;

    // lights hard-coded as well atm
    vec3 lightColors[2];
    lightColors[0] = vec3 (.7, .8, .9)*4.;
    lightColors[1] = vec3 (.9, .8, .7)*4.;

    vec3 lightPositions[2];
    lightPositions[0] = vec3 (-1.5, 1.0, -3.);
    lightPositions[1] = vec3 (2., -.5, 3.);

	vec3 N = normalize (nor);
    vec3 V = -rd;

    vec3 F0 = vec3 (0.04); 
    F0 = mix (F0, albedo, metallic);
    vec3 kD = vec3(.0);
	           
    // reflectance equation
    vec3 Lo = vec3 (.0);
    for(int i = 0; i < 2; ++i) 
    {
        // calculate per-light radiance
        vec3 L = normalize(lightPositions[i] - p);
        vec3 H = normalize(V + L);
        float distance    = length(lightPositions[i] - p);
        float attenuation = 20. / (distance * distance);
        vec3 radiance     = lightColors[i] * attenuation;
        
        // cook-torrance brdf
        float aDirect = pow (roughness + 1., 2.);
        float aIBL =  roughness * roughness;
        float NDF = distriGGX(N, H, roughness);        
        float G   = geomSmith(N, V, L, roughness);      
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0, roughness);       
        
        vec3 kS = F;
        kD = vec3(1.) - kS;
        kD *= 1. - metallic;	  
        
        vec3 nominator    = NDF * G * F;
        float denominator = 4. * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
        vec3 specular     = nominator / max(denominator, .001);  

        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / PI + specular) * radiance * NdotL; 
	    Lo *= shadow (p + .02*N, L);
    }

    vec3 irradiance = texture (iChannel1, N).rgb;
    vec3 diffuse    = irradiance * albedo;
    vec3 ambient    = (kD * diffuse) * ao;

    return 3.*ambient + Lo;
}

// Function 325
vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh) {
    // Primary directional light
    vec3 lv = LIGHT_DIR;
    vec3 ld = normalize(lv);
    float d = max(dot(ld,n),0.);
    float s = 0.;
    float a = doShadow(ld,p,n);
    if(sh > 0.) {
    	s = pow(max(dot(ld,r), 0.), sh);   
    }
    vec3 ds = vec3(LIGHT_AMB);
    vec3 ss = vec3(0.);
    ds += LIGHT_COL*d*a;
    ss += LIGHT_COL*s*a;
    // Secondary point light
    lv = LIGHT2_POS - p;
    ld = normalize(lv);
    a = (1.-clamp(length(lv)/20.,0.,1.))*doShadow(ld,p,n);
    d = max(dot(ld,n),0.);
    s = 0.;
    if(sh > 0.) {
    	s = pow(max(dot(ld,r), 0.), sh);   
    }
    ds += LIGHT2_COL*d*a;
    ss += LIGHT2_COL*s*a;
    // Another secondary point light
    lv = LIGHT3_POS - p;
    ld = normalize(lv);
    a = (1.-clamp(length(lv)/5.,0.,1.))*doShadow(ld,p,n);
    d = max(dot(ld,n),0.);
    s = 0.;
    if(sh > 0.) {
    	s = pow(max(dot(ld,r), 0.), sh);   
    }
    ds += LIGHT3_COL*d*a;
    ss += LIGHT3_COL*s*a;
    return (col*ds)+ss;
}

// Function 326
vec3 earthShader( Ray view_ray, mat4 camera, LameTweaks lame_tweaks, float exposure )
{
	AtmOut atm_out;

	vec3 ret = calc_Iv( view_ray, atm_out, camera, lame_tweaks );

	vec3 sun_color = atm_out.vod_attn * vec3( 1.0, 0.85, 0.71 );
	float sun_intensity = 0.0;

	float sd = dot( normalize( view_ray.d ), sun_direction ); // assumes sun very far... view_ray.d needs renormalize for some obscure reason

	bool long_sun_flare = true;
	bool thin_flares = true;
	bool sun_glare = true;
	bool earth_clamped_sun_glare = true;

	if ( !atm_out.earth_surface )
	{
		vec2 tm = sphere_trace( view_ray, moon_radius, moon_center );
		if ( tm.x != FLT_MAX && tm.x > 0.0 )
		{
			vec3 moon_P = view_ray.o + view_ray.d * tm.x;
			float moon_sun_shadow = warp_nl( dot( normalize( moon_P - moon_center ), sun_direction ), -0.01 );
			float earth_sun_shadow = in_earth_shadow( moon_P ) ? 0.0 : 1.0; // fixme: don't want sharp... precalc or fit something

			ret += vec3( 0.04 );
			ret += min( pow( moon_sun_shadow, 0.57 ), earth_sun_shadow ) * atm_out.vod_attn * 2.0;
		}
		else
		{
			if ( earth_clamped_sun_glare )
			{
				float gs = calcFallOff( sd, 0.01, 1.4, 0.05 );
				sun_intensity += 16.0 * gs;
			}
		}
	}

	float theta = acos( clamp( sd, -1., 1. ) );
	float phi = calc_angle( view_ray.d.zx );
	vec2 phi_vec = unit_vector2( phi );

	float sun_visibility = 0.0;
	vec3 ep_sv = view_ray.o + sun_direction * dot( earth_center - view_ray.o, sun_direction );
	{
		float sh = sunh( length( ep_sv - view_ray.o ) );
		float h = length( ep_sv - earth_center );
		sun_visibility = saturate( smoothstep( -sh, sh, h - earth_radius ) );
//		float darkness = saturate( smoothstep( 0, earth_radius - sh, h ) );
//		if ( sun_visibility != 0.0 ) ret += RED;
	}

	float xsum = 0.0;

	if ( long_sun_flare )
	{
		float gs = calcFallOff( sd, 1e-3 * 12., 1.2, 0.07 );

		float spacing = 2.0 * PI / 6.0;
		for ( int i = 0; i < 6; ++i )
		{
			vec2 v = unit_vector2( float( i ) * spacing + 0.4 );
			float vv = abs( dot( phi_vec * theta, v ) );
			vv /= PI;
			vv *= 0.4;
			xsum += exp( -vv * 1500.0 ) * gs * 0.8;
		}
	}

	if ( thin_flares )
	{
		float gs = calcFallOff( sd, 1e-5 * 4.0, 1.4, 0.3 );

		// thin flares
		for ( int i = 0; i < 5; ++i )
		{
			float fi = float( i );
			float x = noise1s( phi * 3.5 + fi * 3.0 + 0.5 * sin( GLOBALTIME + fi ) );
			x = pow4( x );
			x = max( 0.0, contrast( x, 1.1 ) );
			x = gs * mix( 0.0, 1.0, x );
			xsum += x * 2.0 * gs;
		}
	}

	ret += xsum * ( atm_out.earth_surface ? 0.0 : 1.0 ) * pow( sun_visibility, 0.15 );

	if ( sun_glare )
	{
		// diffuse fall off
		sun_intensity += exp( -theta / PI * ( atm_out.earth_surface ? 70.0 : 27.0 ) ) * pow( sun_visibility, 0.20 );
	}

	ret += sun_intensity * sun_color;

//	float scene_luminance = 0.0;
//	scene_luminance = max( 0.0, dot( view_ray.d, sun_direction ) );

#ifndef NO_EXPOSE
//	ret = 1.0 - exp( -mix( 0.85, 0.05, scene_luminance/**sun_visibility*/ ) * ret );
	ret = 1.0 - exp( -exposure * ret );
#endif
	return ret;
}

// Function 327
float light(vec3 norm){
	vec3 light=vec3(cos(iTime),sin(iTime),0.5);
light=normalize(light);
	float lum=dot(norm,light);
	return lum*0.5+0.5;
}

// Function 328
float cloudShadow( in vec3 pos )
{
	vec2 cuv = pos.xz + lig.xz*(100.0-pos.y)/lig.y;
	float cc = 0.1 + 0.9*smoothstep( 0.1, 0.35, texture( iChannel1, 0.0003*cuv + 0.1+0.013*iTime ).x );
	
	return cc;
}

// Function 329
vec3 getLightnessOklrab(float rawLightness, float rawChroma, float hue) {
    vec3 lch = vec3(rawChroma, 0.0, hue);
    vec3 oklrab = lchToLab(lch);
    return oklrabToLinearSrgb(oklrab);
}

// Function 330
vec3 Lighting(in vec3 albedo, in vec3 norm, in vec3 rd)
{
	float shadow = 1.0;
    float direct = max(0.1, dot(norm, SunDir));
    
    vec3 sunLight  = SunColor * direct * 1.5 * shadow;
    vec3 skyLight  = SkyColor * clamp(0.5 + (0.5 * norm.y), 0.0, 1.0) * 0.1;
    vec3 ambLight  = AmbColor * clamp(dot(norm, AmbDir), 0.0, 1.0) * 0.3;
  	vec3 diffLight = (sunLight + skyLight + ambLight) * albedo;
    
    vec3 reflVec   = reflect(-SunDir, norm);
    float specIntens = pow(max(0.0, dot(rd, -reflVec)), 16.0);
    vec3 specLight = specIntens * vec3(0.35) * shadow;
    
    return (diffLight + specLight);
}

// Function 331
vec3 worldDirectLighting( vec3 pos, vec3 nor, float fre )
{
    //return vec3(0.);
    
    pos += T_MIN * nor;
    vec3 l1pos = normalize(vec3(0.5,0.6,0.8)); // sun
    vec3 l1col = vec3(0.9, 0.8, 0.7);
    float l1 = clamp(dot(nor, l1pos), 0.0, 1.0) * worldShadow( pos, l1pos, T_MAX);
    vec3 l2pos = vec3(-2.0,-2.0,1.0); // light in scene
    vec3 l2dir = normalize(l2pos - pos);
    float l2dist = length(l2pos - pos);
    float l2 = clamp(dot(nor, l2dir), 0.0, 1.0) * worldShadow( pos, l2dir, l2dist );
    vec3 l2col = 6.0*vec3(0.8,0.7,0.9) / (l2dist*l2dist);
    //vec3 l3pos = vec3(-0.8,0.0,-0.6);
    //float l3 = clamp(dot(nor, l3pos), 0.0, 1.0) * worldShadow( pos, l3pos );
    //vec3 l3col = vec3(0.7,0.8,0.9);
    vec3 diff = l1*l1col + l2*l2col/* + l3*l3col*/;
    
    return diff * (1.-fre);
}

// Function 332
float obscurePartsOfLight(vec2 p)
{
    float a = 0.0, z;
    float e = .03;
    float d = length(sunPos - camera);
    vec2 asp = vec2(iResolution.y/iResolution.x,1.0);
   	vec2 texUV = .5+.5*p*asp;
   	z = texture(iChannel0, texUV).w;
    if (z > d) a +=.5;
    
    texUV = .5+.5*(p+vec2(e, e))*asp;
   	z = texture(iChannel0, texUV).w;
    if (z > d) a +=.125;

    texUV = .5+.5*(p+vec2(e, -e))*asp;
   	z = texture(iChannel0, texUV).w;
    if (z > d) a +=.125;

    texUV = .5+.5*(p+vec2(-e, -e))*asp;
   	z = texture(iChannel0, texUV).w;
    if (z > d) a +=.125;
    
    texUV = .5+.5*(p+vec2(-e, e))*asp;
   	z = texture(iChannel0, texUV).w;
    if (z > d) a +=.125;

    return a;
}

// Function 333
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = mapScene( aopos ).d;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 334
void Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)
{
	float fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);
	
	lighting.vDiffuse += vLightColour * fNDotL;
    
	vec3 vH = normalize( -vViewDir + vLightDir );
	float fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);
	float fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);
    
	float alpha = 1.0 - surface.fSmoothness;
	// D

	float alphaSqr = alpha * alpha;
	float denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;
	float d = alphaSqr / (PI * denom * denom);

	float k = alpha / 2.0;
	float vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);

	float fSpecularIntensity = d * vis * fNDotL;    
	lighting.vSpecular += vLightColour * fSpecularIntensity;    
}

// Function 335
vec3 lighting(Ray ray, Light light, Material material) {
	vec3 lightDirection = normalize(light.position - ray.position);
	vec3 lightDirection_ref = reflect(lightDirection, ray.normal);
	float diffuse = max(dot(ray.normal, lightDirection), 0.0);
	float specular = pow(max(dot(ray.direction, lightDirection_ref), 0.0), material.shininess);
	
	vec3 col = vec3(0);
	col += diffuse * material.diffuse + material.ambient;
	col *= material.color;
	col += specular * material.specular;
	col *= light.color;
	col += material.colorEmissive;
	return col;
}

// Function 336
float calcAO(in vec3 p, in vec3 n){
    float sca = 2., occ = 0.;
    for( int i = 0; i<4; i++ ){
        float hr = float(i + 1)*.25/5.; 
        float d = map(p + n*hr, 0.).x;
        occ += (hr - d)*sca;
        sca *= .9;
        if(sca>1e5) break;
    }
    return clamp(1. - occ, 0., 1.);
}

// Function 337
float TerrainSoftShadow( in vec3 origin, in vec3 direction )
{
  float res = 2.0;
  float t = 0.0;
  float hardness = 6.0;
  for ( int i=0; i<8; i++ )
  {
    float h = TerrainDistance(origin+direction*t);
    res = min( res, hardness*h/t );
    t += clamp( h, 0.02, 0.10 );
    if ( h<0.002 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 338
float cloudShadow( in vec3 pos )
{
	vec2 cuv = pos.xz + lig.xz*(100.0-pos.y)/lig.y;
	float cc = 0.1 + 0.9*smoothstep( 0.1, 0.35, texture( iChannel1, 0.0003*cuv + 0.1+0.005*iTime ).x );
	
	return cc;
}

// Function 339
float shade(vec2 uv, float t) {
    uv.x += uv.y < .5 ? 23.0 + t * .035 : -11.0 + t * .03;    
    uv.y = abs(uv.y - .5);
    uv.x *= 35.0;
    
    float q = fire(uv - t * .013) / 2.0;
    vec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));
    
    return pow((r.y + r.y) * max(.0, uv.y) + .1, 4.0);
}

// Function 340
float getShadow (vec3 pos, vec3 at, float k) {
    vec3 dir = normalize(at - pos);
    float maxt = length(at - pos);
    float f = 01.;
    float t = VOLUME*50.;
    for (float i = 0.; i <= 1.; i += 1./15.) {
        float dist = map(pos + dir * t);
        if (dist < VOLUME) return 0.;
        f = min(f, k * dist / t);
        t += dist;
        if (t >= maxt) break;
    }
    return f;
}

// Function 341
vec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}

// Function 342
float ObjSShadow (vec3 ro, vec3 rd)
{
  vec3 p, cIdP;
  float sh, d, h;
  sh = 1.;
  cIdP = vec3 (-99.);
  d = 0.1;
  for (int j = 0; j < 16; j ++) {
    p = ro + d * rd;
    cId = floor (p / bSize);
    if (cId.x != cIdP.x || cId.y != cIdP.y || cId.z != cIdP.z) {
      SetEngConf ();
      cIdP = cId;
    }
    h = ObjDf (p - bSize * (cId + 0.5));
    sh = min (sh, smoothstep (0., 0.1 * d, h));
    d += 0.3;
    if (sh < 0.05) break;
  }
  return sh;
}

// Function 343
float aoray(in vec3 ro, in vec3 rd)
{
    
    float maxt = AO_DIST;
    
    float t = AO_SMALL_PREC;
    vec3 d = rd; // cur highest dir

    for(int i = 0; i<AO_RAY_ITER; i++)
    {
        vec3 p = ro + rd*t;
        p.y = map( p.xz ); // p design the map point
        float t_d = t/dot(rd, d); // compute dist between vertical at p and ro alog dir
        vec3 p2 = ro+d * t_d; // and deduce point along d
        if( p2.y < p.y )
        {
            d = normalize(p-ro);
        } 
        t +=  ao_factor * t;       
    }

    return acos(d.y)/3.141593;
    
}

// Function 344
float ObjAO (vec3 ro, vec3 rd)
{
  float ao = 0.;
  for (int i = 0; i < 8; i ++) {
    float d = 0.1 + float (i) / 8.;
    ao += max (0., d - 3. * ObjDf (ro + rd * d));
  }
  return clamp (1. - 0.1 * ao, 0., 1.);
}

// Function 345
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.0005;                 // selfintersection avoidance distance
	float h = 1.0;
    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps
    {
        h = doModel(ro + rd*t).x;
        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows
		t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances
    }
    return clamp(res,0.0,1.0);
}

// Function 346
vec2 lightMap( vec3 pos ){

    
   float dist =length( pos - lightPos ) - .3;
    
    return vec2( dist , 4. );
    
}

// Function 347
vec3 shade(in vec3 pos, vec3 nor, in vec3 rd, float ao, float matID)
{
    //mtl m;
    
    vec3 ip = (floor(pos/scl) + 0.5)*scl;
    
    float rn = clamp(valueNoise(ip.xz*4.)-0.5,0.,1.);
    //vec3 alb = sin(vec3(.2,.25,.4) + pos.y*pos.y*5. + rn*3.)*0.12+0.2;
    vec3 alb = sin(vec3(.25,.35,.4) + pos.y*pos.y*5. + rn*3.)*0.13+0.2;
    
    //landing dust
    vec2 pl = vec2(atan(pos.z, pos.x), length(pos.xz));
    float nzpl = valueNoise(pl*vec2(8.5,5));
    alb *= mix(1.,nzpl*1.2+.1, smoothstep(1.9,-.5,pl.y)*smoothstep(-0.05,.23,pl.y));
    
    //overly complex tank tracks
    vec2 trCoords = pos.xz;
    trCoords.y += 0.15;
    trCoords *= rot(-trCoords.y*0.2 + .925);
    trCoords.x = abs(trCoords.x) -0.05;
    alb *= (smoothstep(0.0,1.,sin(mix(trCoords.y,pos.z,0.0 - pos.x*0.25)*130.))-.5)*smoothstep(0.05,0.00, abs(trCoords.x))*
        smoothstep(.8,0.6, abs(trCoords.y-1.2)) + 1.;    
    
    alb += (hash33(ip).x*2.0-1.0)*0.06 + 0.04;
    
    ip.y -= 0.21;
    //shade rocket
    if (matID == 2.)
    {
        //polar
        vec2 ppol = vec2(atan(ip.z,ip.x)*0.95, ip.y*8.3);
        float f = mod(floor(ppol.x - 0.1) + floor(ppol.y + .8), 2.);
        f *= step(abs(ip.y+0.16)-.3, 0.);
        alb = mix(vec3(.6,0.03,0.03), vec3(0.75,0.75,0.7), f);
    }
    else if (matID == 3.)
    {
        alb = mix(vec3(0.04,0.17,.5)*1.1, vec3(0.07), step(ip.y,-.915));
    }
    else if (matID == 5.)
    {
        alb = vec3(0.55,0.32,0.1);
        alb *= smoothstep(-1.5,-0.5,sin(ip.y*400. + 0.5));
    }
    
    alb *= curv(pos, 0.05)*0.07+.7;
    if (matID == 1.) alb *= smoothstep(-1.,-.1,pos.y) + 1.;
    
    const float numcol = 18.;
    alb = floor(alb*numcol)/numcol;
    
    
	float nl = clamp(dot(nor,lgt), 0., 1.);
	vec3 col = vec3(0.);
    
    if (nl > 0.)
    {
        float shd2 = 0.;
        vec3 tm1, tm2;
        if(nl>0.01)
        {
            shd2 = marchVxl(pos + nor*0.0001, lgt, 0., 3., tm1, tm2).x;
            shd2 = step(3., shd2);
        }
        nl *= shd2*0.75+0.25;
        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
        col = lcol*nl*alb + fre*nl*0.05;
    }
    col += 0.01*alb;
    col *= ao;
    return col;
}

// Function 348
vec3 sampleIndirectLight(vec3 pos,vec3 normal
){vec3 dir
 ;vec3 abso=vec3(1.),light=vec3(0.),dc,ec
 ;for(int i=0;i<Bounces;i++
 ){dir=getCosineWeightedSample(normal)
  ;if(!trace(pos,dir,normal))return light+abso*background(dir)
  ;sdf(pos,dc,ec)
  ;light+=abso*(ec+dc*directLight(pos,normal))
  ;abso*=dc;}
 ;return light;}

// Function 349
vec4 shade(vec2 fragCoord) {
    vec2 mouse = (iMouse.xy*vec2(2,2) - iResolution.xy) / min(iResolution.x, iResolution.y);

    // the positions of the three masses
    vec2 A = mouse;
    vec2 B =     vec2(-1.0, 0.0)*sin(iTime);
    vec2 C = B + vec2( 0.5, 0.5)*sin(iTime*1.5);

    // Fit a square from (-1,-1)-(1,1), maintaining aspect ratio
    vec2 uv = (fragCoord*vec2(2,2) - iResolution.xy) / min(iResolution.x, iResolution.y);
 
    // general form is the sum of M/r
    float potential = 50.0/length(uv-A) + 10.0/length(uv-B) + 1.0/length(uv-C);
    
    float P = 750.0/potential+iTime;
    float r = sin(P*10.0)+sin(P*5.0) + potential*0.01;
    float g = potential*0.001;
    float b = 0.25;
    return vec4(r,g,b,1);
}

// Function 350
float shadow(vec3 ro, vec3 rd){
    float t = 0.5;
    float d = 0.0;
    float shadow = 1.0;
    for(int iter = 0; iter < 1000; iter++){
        d = map(ro + rd * t);
        if(d < 0.0001){
            return 0.0;
        }
        if(t > length(ro - lightPos) - 0.5){
            break;
        }
        shadow = min(shadow, 128.0 * d / t);
        t += d;
    }
    return shadow;
}

// Function 351
vec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in int id, in float dis ) {    
    // Color
    vec3 col;
    float kspe = 2.;
    if (id<0) {
         col = pow(2.*woodColor(.1*pos),vec3(.5));
         nor = doBumpMap(iChannel1, vec3(.3,.3,.3)*pos, nor, .003);
    } else {
        Body body = loadBody(iChannel0, id);
        vec3 uvw  = worldPtToBody(body, pos);
        float zstart = uvw.z + body.h_2;
        float zend = uvw.z - body.h_2-.08;
        vec3 col0 = rainbow(mod(float(id)*.101,1.));
        col = col0;
        if (uvw.y > 0.) {
            float dTxt = sdMessage(uvw.zx+vec2(body.h_2-.28,.02), txt, 0, .14, 0., -.3);
            col = mix(col, vec3(0), .8*smoothstep(.005,.0, abs(dTxt-.008)-.0025)); 
        }
        col = mix(col, sqrt(.43+2.*woodColor(.5*uvw)), smoothstep(.0,.02, zend+.2));        
        col *= .4 + .6* smoothstep(.10,.11, abs(zstart-.07));    
        col *= .2+.8*smoothstep(.0,.01, abs(zstart-.2)-.005);    
        col *= .2+.8*smoothstep(.0,.01, zstart+.05);    
        col *= .9+.1*(wood(.5*uvw.yz) + wood(.5*uvw.xz));

        // mine
        float end = mix(.055,.095, hash(float(id)))-.03;
        col = mix(col, pow(col0,vec3(1.2)), smoothstep(.0,.01, zend + end ));    
        col = mix(col, vec3(0),.2*smoothstep(.02,.0, abs(zend + end)+.005 ));    
        // todo specularity
        if (zend < -.2) {
            nor = doBumpMap(iChannel2, .3*uvw, nor, .0005);
            kspe = 2.;
        } else {
            kspe = .5;
        }
    }
    
#ifdef WITH_AO
    float occ = occlusion( pos, nor );
    occ = occ*.5 + .5*occ*occ;
#else
    float occ = 1.f;
#endif
    vec3  ref = reflect(rd,nor);
    float dif = max( dot( light, nor ), 0.), // Diffuse term.
    	  spe = pow(max(dot( reflect(-light, nor), -rd ), 0.), 29.), // Specular term.
    	  fre = clamp(1. + dot(rd, nor), 0., 1.); 
    float Schlick = pow( 1. - max(dot(rd, normalize(rd + light)), 0.), 5.);
    float fre2 = mix(.2, 1., Schlick);
    // Overal global ambience.
    float amb = .6*fre*fre2 + .2*occ;
    float h = dot(pos,vec3(127.1,311.7,758.5453123));	
    return (col*(dif + .1) + fre2*spe*kspe)*occ + amb*col;
}

// Function 352
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 353
vec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    vec3 lig = normalize(vec3(1.5, 0.7, 0.9));
    float dif = max(dot(nor, lig), 0.0);
    float sha = 0.0;
    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);
    lin += dif * vec3(2.) * sha;

    // ambient light
    //-----------------------------
    lin += vec3(0.1);

    // surface-light interacion
    //-----------------------------
    vec3 col = mal * lin;

    // fog
    //-----------------------------
    col *= exp(-0.0005 * dis * dis);

    return col;
}

// Function 354
vec4 shadebrick(vec3 ro, vec3 rd, ivec4 piece) {
    vec4 fragColor = vec4(1);
    vec3 normal = normal(ro, piece);
    
    vec3 color = vec3(0);
    if (piece.y == 1) {
        color = color+black.xyz;
    } else {
        color = color+white.xyz;
    }
    //color = fract(ro);
    fragColor = lighting(vec4(color,1),ro,rd,normal,1.0);
    return (fragColor);
}

// Function 355
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res = 2.0;
  float t = 0.0;
  float hardness = 6.50;
  for ( int i=0; i<10; i++ )
  {
    float h = Map(origin+direction*t);
    res = min( res, hardness*h/t );
    t += clamp( h, 0.02, 0.075 );
    if ( h<0.002 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 356
Intersection DirectLighting(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = normalize(computeNormal(isect));
    vec3 lightDir = normalize(lightPos - isect);
    
    //compute the direct lighting for that surface
    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));
    
    return Intersection(t, surfaceColor, isect, hitObj);
}

// Function 357
float shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS
	float sh=1.0;
	float totdist =2.0*det;
	float dist=10.;
	float t1=Sphere((pos-.005*sdir)-pth1,-sdir,0.015);
	if (t1>0. && t1<.5) {
		vec3 sphglowNorm=normalize(pos-t1*sdir-pth1);
		sh=1.-pow(max(.0,dot(sphglowNorm,sdir))*1.2,3.);
	} 
		for (int steps=0; steps<SHADOW_STEPS; steps++) {
			if (totdist<.6 && dist>detail) {
				vec3 p = pos - totdist * sdir;
				dist = de(p).x;
				sh = min( sh, max(50.*dist/totdist,0.0) );
				totdist += max(.01,dist);
			}
		}
	
    return clamp(sh,0.1,1.0);
}

// Function 358
vec3 genLightCoords()
{
	vec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), 
				lightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),
				lightPathCenter.z);
	return lightCoords;
}

// Function 359
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    float t;
	
	t = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }

    return false; // optimisation: planes don't cast shadows in this scene
}

// Function 360
vec3 sampleLight( 	in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {
    vec3 Lo = vec3( 0.0 );	//outgoing radiance
    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);
   
    for( int i=0; i<LIGHT_SAMPLES; i++ ) {
        //select light uniformly
        float Xi = rnd();
        float strataSize = 1.0 / float(LIGHT_SAMPLES);
        Xi = strataSize * (float(i) + Xi);
        float lightPickPdf;
        int lightId = chooseOneLight(x, Xi, lightPickPdf);

        //Read light info
        vec3 Li;				//incomming radiance
        Sphere lightSphere;
        getLightInfo( lightId, lightSphere, Li );
        
        float Xi1 = rnd();
        float Xi2 = rnd();
        LightSamplingRecord sampleRec;
        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );
        
        float lightPdfW = lightPickPdf*sampleRec.pdf;
        vec3 Wi = sampleRec.w;
        
        float dotNWi = dot(Wi,hit.N);

        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {
            Ray shadowRay = Ray( x, Wi );
            RaySurfaceHit newHit;
            bool visible = true;
#ifdef SHADOWS
            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );
#endif
            if(visible) {
                float brdf;
    			float brdfPdfW;			//pdf of choosing Wi with 'bsdf sampling' technique
                
                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {
                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );
                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );	//sampling Pdf matches brdf
                } else {
                    brdf = evaluateLambertian( hit.N, Wi );
                    brdfPdfW = pdfLambertian( hit.N, Wi );	//sampling Pdf matches brdf
                }

                float weight = 1.0;
                if( useMIS ) {
                    weight = misWeight( lightPdfW, brdfPdfW );
                }
                
                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;
            }
        }
    }
    
    return Lo*lightSamplingPdf;
}

// Function 361
vec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )
{       
    vec2 bent = getBent();
    // repeat car rotation with fixes
    float rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;
    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;

    vec3 albedo = vec3( 0.6 );
    float met = 2.0;
    vec4 color = vec4( albedo, met );
    vec3 emissive = vec3( 0.1 );
        
    if ( m == 0.0 )
    {
        vec2 p0 = lPos.xz;
        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );
        vec2 uv = abs( mod( lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );
        uv /= fwidth( lPos.xz );
        float gln = min( min( uv.x, uv.y ), 1.) / GRID_SIZE;
        
    	albedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE / GRID_SIZE, gln ) );
        
        float pSideLine = lPos.x;
		pSideLine = abs( pSideLine );
        pSideLine -= 1.45;
        pSideLine = abs( pSideLine );
        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );
        
        float pCenterLine = lPos.x;
		pCenterLine = abs( pCenterLine );
        pCenterLine -= 0.55;
        pCenterLine = abs( pCenterLine );
        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );
        
        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;
        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );
        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );
        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );
               
        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.6, lPos.z - 3.0 * g_S.playerPos.y );
        pTrail.x += 5.0 * rotY; // move the cos
        pTrail.x -= 5.0 * rotY * ( cos( 0.85 * pTrail.y - 0.2 * PI ) * 0.6 + 0.6 ); // fake car turns
        pTrail.x = abs( pTrail.x );
        pTrail.x -= 0.38;
        pTrail.x = abs( pTrail.x );
               
        float trailMask = exp( -40.0 * pTrail.x );
        trailMask += 0.2 * saturate( exp( -5.0 * pTrail.x ) );
        trailMask *= saturate( -pTrail.y + 0.6 );		// clamp on Y
        trailMask *= saturate(  pTrail.y * 0.6 + 2.5 );	// clamp on Y
        emissive += vec3( 2.5, 0.3, 0.0 ) * trailMask;       
    }
    
    if ( m == 1.0 )
    {
        vec2 p0 = 2.6 * lPos.xz;
        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );
        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );
        uv /= fwidth( lPos.xz );
        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;
        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );
        
        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );
        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );
        
        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );
        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );
    }
    
    if ( m == 1.5 )
    {
        emissive = albedo = vec3( 1.5, 0.5, 0.5 );
    }
    
    if ( m == 1.6 )
    {
        emissive = albedo = vec3( 0.5, 0.5, 1.5 );
    }
    
    if ( m == 2.0 )
    {
        albedo = vec3( 1.0, 1.0, 0.5 );
        emissive = 10.0 * albedo;
    }
    
    if ( m == 3.0 )
    {
       vec2 p0 = 2.6 * lPos.xz;
        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );
        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE / 2.0, GRID_SIZE ) - GRID_SIZE / 2.0 );         
        uv /= fwidth( lPos.xz );
        float gln = min( min( uv.x, uv.y ), 1. ) / GRID_SIZE;
        
        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE / GRID_CAR_SIZE, gln ) );
    }
    
    if ( m == 3.5 )
    {
        emissive = albedo = vec3( 1.0, 0.5, 0.5 );
    }
    
    if ( m == 3.6 )
    {
        emissive = albedo = vec3( 0.5, 0.5, 1.0 );
    }

    if ( m == 4.0 )
    {
        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );
    }
            
	// spotlight, paramteres-
    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );
    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );
    pSpot -= perSpotOffset;
    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );
    vec3 spotColor  = 20.0 * vec3( 0.2 );
    
    pSpot.yz *= rot( -0.2  * bent.y );
    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );
    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );
    spotDir.yz *= rot( 0.2 * bent.y );
    spotDir.xz *= rot(-0.2 * rotY );
    spotDir.yz *= rot(-0.2 * rotX );
    
    // spotlight, color
    float maskDist = fract( ( length( pSpot ) - 2.0 ) );
    float spotAtt = 0.2 / pow( 2.0 * length( pSpot ), 3.0 );
    spotAtt *= smoothstep( 0.2, 1.1, dot( normalize( pSpot ), spotDir ) );
    spotAtt *= saturate( dot( -nor, spotDir ) );
    emissive += albedo * spotColor * spotAtt;    
        
    float fre = pow( 0.4 * ( 0.9 + dot( nor, rd ) ), 3.0 );
    float amb = clamp( 0.6 + 0.6 * nor.y, 0.0, 2.0 );
    float occ = calcAO( wPos, nor );    
    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.3, 0.0 ) );
    float dif = clamp( dot( nor, lig ), 0.0, 2.0 );
	vec3  hal = normalize( lig - rd );
    float spe = pow( clamp( dot( nor, hal ), 0.0, 2.0 ), 74.0 )
        * dif
        * ( 0.05 + 1.06 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 2.0 ), 6.0 ) );
   
    color.rgb = albedo * ( 0.6 + 0.6 * occ ) * ( 0.8 + 0.4 * dif ) + spe * vec3( 2.0, 0.6, 0.2 );
	color.rgb += emissive;
	color.a = fre;
    
    return color;
    // return vec4(vec3(0.4) * m, 0.5); // debug material ID
    // return vec4(vec3(fre), 0.0);
}

// Function 362
void shadowSoft(inout float s,inout vec3 x,inout float j,float t,vec4 m,mat4 B
){float h
 ;for(int i=0;i<64;i++
 ){h=map(x+lightDir*j).x
  ;j+=clamp(h, .032, 1.);
               	s = min(s, h/j);
             	if(j>7.|| h<.001) break;
            } 
}

// Function 363
float voronoi_ao(in float h, inout vec2 n, inout vec2 f, inout vec2 mg) {
    float a = 0.0;
    
    for (int j = -1; j <= 1; ++j)
    for (int i = -1; i <= 1; ++i) 
    {
    	vec2 g = mg + vec2(float(i), float(j));
        a += max(0.0, map(n + g) - h);
    }
    
    return exp(-a*0.5) + 0.2;
    //return max(0.0, 1.0 - a*0.2) + 0.2;
}

// Function 364
float softShadow(vec3 ro, vec3 lp, float k) {
    const int maxIterationsShad = 8;
    vec3 rd = (lp - ro); // Unnormalized direction ray.

    float shade = 4.;
    float dist = 4.5;
    float end = max(length(rd), 0.01);
    float stepDist = end / float(maxIterationsShad);

    rd /= end;
    for (int i = 0; i < maxIterationsShad; i++) {
        float h = map(ro + rd * dist).dist;
        shade = min(shade, k*h/dist);
        dist += min(h, stepDist * 2.); 
        if (h < 0.001 || dist > end) break;
    }
    return min(max(shade, 0.0), 1.0);
}

// Function 365
vec3 sampleLight( 	in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi, float sl ) {
    vec3 Lo = vec3( 0.0 );	//outgoing radiance
    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);
   
    for( int i=0; i<LIGHT_SAMPLES; i++ ) {
        //select light uniformly
        
        float Xi = xi.x;
        float strataSize = 1.0 / float(LIGHT_SAMPLES);
        Xi = strataSize * (float(i) + Xi);
        float lightPickPdf;
        int lightId = chooseOneLight(x, sl, lightPickPdf);

        //Read light info
        vec3 Li;				//incomming radiance
        Sphere lightSphere;
        getLightInfo( lightId, lightSphere, Li );
        
        float Xi1 = xi.x;//rnd();
        float Xi2 = xi.y;//rnd();
        LightSamplingRecord sampleRec;
        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );
        
        float lightPdfW = lightPickPdf*sampleRec.pdf;
        vec3 Wi = sampleRec.w;
        
        float dotNWi = dot(Wi,hit.N);

        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {
            Ray shadowRay = Ray( x, Wi );
            RaySurfaceHit newHit;
            bool visible = true;
#ifdef SHADOWS
            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );
#endif
            if(visible) {
                float brdf;
    			float brdfPdfW;			//pdf of choosing Wi with 'bsdf sampling' technique
                
                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {
                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );
                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );	//sampling Pdf matches brdf
                } else {
                    brdf = evaluateLambertian( hit.N, Wi );
                    brdfPdfW = pdfLambertian( hit.N, Wi );	//sampling Pdf matches brdf
                }

                float weight = 1.0;
                if( useMIS ) {
                    weight = misWeight( lightPdfW, brdfPdfW );
                }
                
                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;
            }
        }
    }
    
    return Lo*lightSamplingPdf;
}

// Function 366
float getShadowIlluminance(in float sunHeight) {
    return mix(MOON_ILLUMINANCE, SUN_ILLUMINANCE, getDayFactor(sunHeight - 0.2));
}

// Function 367
vec3 ComputeLighting(vec3 point, vec3 lightDir, vec3 lightColor)
{
    vec3 color = vec3(AMBIENT);
    float intensity = dot(EstimateNormal(point), normalize(lightDir));
    intensity = ceil(intensity * SHADES) / SHADES;
    intensity = max(intensity, AMBIENT);
    color = lightColor * intensity;
    return color;
}

// Function 368
vec4 shade(vec3 pos, vec3 dir, vec3 eye)
{
	float dist = length(eye-pos);
	return addFog(dist, calcLighting(pos, eye), eye, dir);
}

// Function 369
function SetShaderConstant1F(u,x){m.uniform1f(m.getUniformLocation(sB.mProgram,u),x);}

// Function 370
vec3 dLight(vec3 wp, vec3 n, Light l)
{
    vec3 ld = normalize(l.pos-wp);
    float ni = clamp(dot(n, ld), 0., 1.);
    float dist = 1.-clamp(mix(0., .01, distance(wp, l.pos)), 0., 1.);
    float d = min(ni, dShadow(wp, l))*dist;
    return d*l.intensity*l.col;
}

// Function 371
float softShadow(in vec3 ro, in vec3 rd ){
    float res = 1.0;
    float t = 0.001;
	for( int i=0; i<80; i++ )
	{
	    vec3  p = ro + t*rd;
        float h = p.y - terrainM( p.xz );
		res = min( res, 16.0*h/t );
		t += h;
		if( res<0.001 ||p.y>(SC*200.0) ) break;
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 372
vec3 light(vec3 p, vec3 norm, vec3 diffuse) {
    
    const vec3 afxPos = vec3(0, 0, 3);
    
    // add a spotlight pointing toward the logo
    vec3 spotPos = vec3( (bestNoteFrac-0.5)*16.0, -1.5, 8);
    spotPos.z -= spotPos.x*spotPos.x*0.07;
    
    vec3 spotDir = normalize(afxPos - spotPos);

    vec3 pms = p - spotPos;
    float pmsSq = dot(pms, pms);
    vec3 dirToLight = pms / sqrt(pmsSq);
    float l = 15000.0 / pmsSq;
    l *= max(0.0, dot(norm, -dirToLight));
    float spot = max(0.0, dot(dirToLight, spotDir));
    spot = pow(spot, 32.0);
    l *= spot;
    
    // add ao
    float ao = 0.5 + 0.5 * (1.0 - pow(2.0, -length(p.yz)));
    
    return diffuse*l + diffuse*ao;
}

// Function 373
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)
{         
  const vec3 sunColor = vec3(1.1, 0.53, 0.27); 
  vec3 reflectDir = reflect( rayDir, normal );

  float occ = 1.;
  #ifdef PERFORM_AO_PASS
    occ = calcAO( rayHit.hitPos, normal );
  #endif

    vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 );

  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  float shadow=1.; 
  #ifdef SHADOWS
    shadow = SoftShadow(rayHit.hitPos+normal*0.001, sunPos);
  #endif
    dif*=shadow;

  lightTot += 1.6*dif*sunColor;

  lightTot += 0.75*amb*vec3(0.35, 0.45, 0.6)*occ;  
  lightTot += 0.270*skylight*GetSkyColor(reflectDir)*occ;
  lightTot += 1.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 2.0)*occ;
  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );
  lightTot = mix( lightTot, lightTot+ vec3(3.)*vec3(0.9, 0.6, 0.57), fre );

  return clamp(lightTot, 0., 10.);
}

// Function 374
vec4 getlight(float n)
{
    float sund = mod(iTime*30.+60.,120.) - 60. + 120.*n;
    float fall = smoothstep(0.,1.,(sund+30.)/20.);
    fall *= clamp((180.-sund)/20.,0.,1.);
	return vec4(sund,-sin(sund/10.)*3.,0.,fall);
}

// Function 375
float lightDefault(float z){
	if(z>2.) return 15.;
    else return 1.;
}

// Function 376
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = 0; j < 25; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 1., 20. * h / d));
    d += min (0.1, 3. * h);
    if (h < 0.001) break;
  }
  return sh;
}

// Function 377
float softshadow( in vec4 ro, in vec4 rd, in float mint) {
	float res = 1.0;
    float h,t = mint;
    for( int i=0; i<15; i++ ) {
        h = map( ro + rd*t ).x;
        res = min( res, 7.*h/t );
        t += 0.028;
    }
    return clamp( res-.6, 0.0, 1.0 );
}

// Function 378
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo )
{
    float eps = 0.001;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps*t );
    float kk;

    vec3 mateD = vec3(0.2,0.16,0.11);
    vec3 mateS = vec3(0.2,0.12,0.07);
    vec3 mateK = vec3(0.0,1.0,0.0); // amount, power, metalic
    float focc = 1.0;
    
    if( m<3.5 ) // ground
    {
        mateD = vec3(0.1,0.09,0.07)*0.27;
        mateS = vec3(0.0,0.0,0.0);
        mateD *= 2.0*texture( iChannel1, 0.1*pos.xz ).xyz;
        
        float gr = smoothstep( 0.3,0.4,texture(iChannel2,0.01*pos.zx).x );
        vec3 grcol = vec3(0.3,0.28,0.05)*0.07;
        grcol *= 0.5 + texture( iChannel2, 4.0*pos.xz ).x;
        mateD = mix( mateD, grcol, smoothstep( 0.9,1.0,nor.y)*gr );
        mateD *= 1.2;
        mateK = vec3(1.0,8.0,1.0);
    }
    else if( m<4.5) // bushes
    {
        mateD = vec3(0.2,0.32,0.07)*0.1;
        mateD.x += matInfo.x*0.02;
        mateS = vec3(0.8,0.9,0.1);
        focc = 1.0-matInfo.y;
        mateK = vec3(0.07,16.0,0.0);
    }
    else if( m<5.5 ) // trees
    {
        mateD = vec3(0.2,0.3,0.07)*0.07;
        mateS = vec3(0.0,0.0,0.0);
        mateK = vec3(0.2,16.0,0.0);
    }
    else // leaves
    {
        mateD = vec3(0.2,0.35,0.07)*0.2;
        mateS = vec3(0.8,1.0,0.1)*0.25;
        mateK = vec3(0.07,16.0,0.0);
        float te = texture( iChannel2, 0.35*matInfo.yz ).x;
        mateD *= 1.0 + 0.6*te;
        mateS *= 1.0 + 0.6*te;
        mateD += vec3(0.035) * (1.0-smoothstep(0.005,0.01,abs(matInfo.y)+matInfo.z*0.05) );
    }
    
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor )*focc;
        
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );
    float sha = calcSoftShadow( pos, sunDir, 16.0 );
	sha = min( sha, dapples(pos,sunDir) );
              
    dif1 *= sha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );
    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );

    // sun
    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;
    // sky
    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);
    // ground
    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;
    // back
    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ;
    // sss
    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS;

    // sun
    vec3 hdir = normalize(sunDir - rd);
    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );
    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));
    col += mateK.z*15.0*5.0*spp; 

    
    col *= mateD;

    col += (1.0-mateK.z)*15.0*5.0*spp; 
    
    return col;        
}

// Function 379
vec3 shadeGround(Ray ray, Hit scn) {
 
    bool s = inShadow(scn.p);
        
    vec2 uv = mod(scn.p.xz, 1.);
    vec3  n = calcNormal(scn.p);
    vec3  l = calcLighting(scn, n, s);
        
    vec3 tx = texture(iChannel0, uv).xyz * vec3(0.,1.,0.);
    if(scn.p.x > -1. && scn.p.x < 1.) tx = texture(iChannel0, uv).xyz * vec3(.34,.23,.05);
        
    tx *= l;
    tx += calcSpecular(reflect(ray.dir,n), 5., s);
    
    return tx;
    
}

// Function 380
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 32; 
    
    ro += n*.0015;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){

        float d = map(ro + rd*t)*.7;
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .2); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 381
float shadow(vec3 ro, vec3 rd)
{
    float res = 0.0;
    float tmax = 1.0;
    float t = 0.001;
    for(int i=0; i<30; i++ )
    {
        float h = f(ro+rd*t);
        if( h<0.0001 || t>tmax) break;
        t += h;
    }
    if( t>tmax ) res = 1.0;
    return res;
}

// Function 382
void CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, bool shootShadowRays, inout vec3 diffuseColor, inout vec3 specularColor)
{
    vec3 lightDirection = (CabinLamp.Position - position);
    float lightDistance = length(lightDirection);
    lightDirection /= lightDistance;

    // Manually tuned light falloff for what looked best
    vec3 lightColor = CabinLampMultiplier() * CabinLamp.LightColor / pow(lightDistance, 0.7); 

    float shadowFactor = 1.0;
    if(shootShadowRays && IsColorSignificant(lightColor))
    {
       shadowFactor = SoftShadowIntersect(position, lightDirection, 0.1, 200.0, 50, 64.0);
    }

    if(SupportsSpecularLight(material))
    {
        specularColor += shadowFactor * 0.25 * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);
    }
    diffuseColor += shadowFactor * lightColor * Diffuse(normal, lightDirection, material.albedo);
    diffuseColor += material.emissive;
    
    for(int i = 0; i < NUM_POINT_LIGHTS; i++)
    {
        vec3 pointLightDirection = (Cabin.PointLights[i].Position - position);
        float pointLightDistance = length(pointLightDirection);
        pointLightDirection /= pointLightDistance;

        vec3 pointLightColor = Cabin.PointLights[i].LightColor / (pointLightDistance * pointLightDistance);

        if(SupportsSpecularLight(material))
        {
            specularColor += 0.25 * pointLightColor * pow(max(dot(reflectionDirection, pointLightDirection), 0.0), 4.0);
        }
        diffuseColor += pointLightColor * Diffuse(normal, pointLightDirection, material.albedo);
    }
    
    diffuseColor += GetGlobalIllumination(position);

    {
        float skyNDotL = normal.y;
        // Alter where the sky light is coming from just for snow to give the snow
        // a little more texture
        if(IsSnow(material))
        {
            skyNDotL = dot(normal, normalize(vec3(1, 1, 0.2)));
            diffuseColor += 
                mix(vec3(0.1, 0.2, 0.3), SKY_LIGHT_COLOR * material.albedo, pow(skyNDotL, 4.0));
        }
        else
        {
			diffuseColor += SKY_LIGHT_COLOR * skyNDotL * material.albedo;
        }
    }

    specularColor = clamp(specularColor, 0.0, 1.0);
    diffuseColor = clamp(diffuseColor, 0.0, 1.0);
}

// Function 383
float light(vec3 p)
{
    vec3 LP = vec3(0.2,0.5,0.5);
    vec3 lp = normalize(LP - p);
    vec3 n = normal(p);
    
    float l = clamp(dot(n,lp),0.25,1.);
    float s = pow(max(dot(n,lp),0.),80.)*3.0;
    
    return pow(l + s,0.25);
}

// Function 384
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.1, 1.0 );    
}

// Function 385
float calcAO( in vec3 pos, in vec3 nor )
{
    float ao = 0.0;
    float sca = 15.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = SC*(0.01 + 0.015*float(i*i));
        float dd = map( pos + hr*nor ).x;
        ao += (hr-dd)*sca/SC;
        sca *= 0.5;
    }
    return 1.0 - clamp( ao, 0.0, 1.0 );
}

// Function 386
float softShadow(vec3 dir, vec3 origin, float min_t, float k) {
    float res = 1.0;
    float t = min_t;
    for(int i = 0; i < RAY_STEPS; ++i) {
        float m = sceneMap3D(origin + t * dir, LIGHT_POS);
        if(m < 0.0001) {
            return 0.0;
        }
        res = min(res, k * m / t);
        t += m;
    }
    return res;
}

// Function 387
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 20; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.05;    
    float end = max(length(rd), 0.001);
    //float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.
        dist += clamp(h, 0.01, 0.5);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.
    return min(max(shade, 0.) + 0.2, 1.0); 
}

// Function 388
vec3 shade(
    inout vec3 origin,
    inout vec3 direction)
{
    vec3 shaded = vec3(0.0);
    vec3 throughput = vec3(1.0);
    for (int bounce = 0; bounce < 3; ++bounce)
    {
        float t = 1.0e30;
        vec3 hit = vec3(0.0);
        vec3 normal = vec3(0.0);
        vec3 diffuse = vec3(0.0);
        vec3 specular = vec3(0.0);
        vec3 emissive = vec3(0.0);
        trace(origin, direction, t, hit, normal, diffuse, specular, emissive);

        // Add in emissive contribution.

        shaded += throughput * emissive;

        // Add in direct lighting via next event estimation.

        vec3 xi_1 = rng(hit);
        vec3 light = vec3((xi_1.x - 0.5) * 0.1, 0.99, (xi_1.z - 0.5) * 0.1);
        vec3 light_direction = light - hit;
        if (dot(normal, light_direction) > 0.0)
        {
            float light_distance = length(light_direction);
            light_direction /= light_distance;
            vec3 shadow_hit = vec3(0.0);
            vec3 shadow_normal = vec3(0.0);
            vec3 shadow_diffuse = vec3(0.0);
            vec3 shadow_specular = vec3(0.0);
            vec3 shadow_emissive = vec3(0.0);
            int intersected = trace(hit, light_direction, light_distance,
                                    shadow_hit, shadow_normal,
                                    shadow_diffuse, shadow_specular, shadow_emissive);
            if (intersected == 0)
            {
                vec3 halfway = normalize(light_direction + normalize(origin - hit));
                float lambert = max(0.0, dot(normal, light_direction));
                float blinn_phong = 3.0 * pow(max(0.0, dot(halfway, normal)), 64.0);
                shaded += throughput * (diffuse * lambert + specular * blinn_phong);
            }
        }

        // Update for indirect lighting: adjust path throughput
        // and choose new ray for next path segment.

        float diffuse_weight = dot(diffuse, vec3(1.0));
        float specular_weight = dot(specular, vec3(1.0));
        if (xi_1.y * (diffuse_weight + specular_weight) <= diffuse_weight)
        {
            vec3 xi_2 = rng(hit + vec3(239.0, 491.0, 128.0));
            float phi = 6.28318531 * xi_2.x;
            float cos_theta_sq = xi_2.y;
            float sin_theta = sqrt(1.0 - cos_theta_sq);
            float sgn = normal.z < 0.0 ? -1.0 : 1.0;
            float a = -1.0 / (sgn + normal.z);
            float b = normal.x * normal.y * a;
            direction =
                (vec3(b, sgn + normal.y * normal.y * a, -normal.y) * (cos(phi) * sin_theta) +
                 vec3(1.0 + sgn * normal.x * normal.x * a, sgn * b, -sgn * normal.x) * (sin(phi) * sin_theta) +
                 normal * sqrt(cos_theta_sq));
            throughput *= diffuse;
        }
        else
        {
            direction = reflect(direction, normal);
            throughput *= specular;
        }

        origin = hit + direction * 0.001;
    }
    return shaded;
}

// Function 389
float shadow( vec3 pos, vec3 l )
{
    float tmin = 0.2;
    float tmax = 6.0;
    
    float t = tmin;
    for( int i=0; i<64; i++ )
    {
        vec2 dm = scene( pos + t*l );
        if( dm.x < 0.001 ) return 0.0;
        t += dm.x;
    }
    
    return 1.0;
}

// Function 390
vec3 shade(vec3 rpos, vec3 rdir, float t, vec3 pos) {
	float watert = ((rpos.y - waterHeight-10.0) / rdir.y);
	
	// Calculate fog
	float b = 0.01;
	float fogt = min(watert, t);
	float fog = 1.0 - FOG_BASE * exp(-rpos.y*b) * (1.0-exp(-fogt*rdir.y*b)) / rdir.y;
	vec3 fogColor = calculateFogColor(rpos, rdir);

	vec4 ns = texture(iChannel0, pos.xz * 0.0001);
	
	if (fog < 0.01) return fogColor;
	
	vec3 nl = normal(pos);
	vec3 n = normalHigh(pos);
	float h = pos.y;
	
	float slope = n.y;
	vec3 albedo = vec3(0.36, 0.25, 0.15);
	
	// Apply texture above water
	if (watert > t) {
		float snowThresh = 1.0 - smoothstep(-50.0, -40.0, h) * 0.4 + 0.1;
		float grassThresh = smoothstep(-70.0, -50.0, h) * 0.3 + 0.75;
		
		if (nl.y < 0.65)
			albedo = mix(albedo, vec3(0.65, 0.6, 0.5), smoothstep(0.65,0.55,nl.y));
		if (slope > grassThresh - 0.05)
			albedo = mix(albedo, vec3(0.4, 0.6, 0.2), smoothstep(grassThresh-0.05,grassThresh+0.05,slope));
		if (slope > snowThresh - 0.05)
			albedo = mix(albedo, vec3(1.0, 1.0, 1.0), smoothstep(snowThresh-0.05,snowThresh+0.05,slope));
	}
	
	// Fade in 'beach' and add a bit of noise
	albedo = mix(albedo, vec3(0.6, 0.5, 0.2), smoothstep(-waterHeight+4.0,-waterHeight+0.5,h));

	// Lighting
	float diffuse = clamp(dot(n, lightDir), 0.0, 1.0);
	#ifdef SHADOWS
	if (diffuse > 0.005) diffuse *= shadow(pos, vec3(lightDir.xy, -lightDir.z));
	#endif
	vec3 col = vec3(0.0);
	col += albedo * vec3(1.0, 0.9, 0.8) * diffuse;
	col += albedo * fogColor * max(n.y * 0.5 + 0.5, 0.0) * 0.5;
	
	// Shade water
	if (t >= watert) {
		float dist = t - watert;
		vec3 wpos = rpos+rdir*watert;
		col *= exp(-vec3(0.3, 0.15, 0.08)*dist);
		
		float f = 1.0 - pow(1.0 - clamp(-rdir.y, 0.0, 1.0), 5.0);
		vec3 refldir = rdir * vec2(-1.0, 1.0).yxy;
		refldir = normalize(refldir + ns.xyz * 0.1);
		#ifdef REFLECTIONS
		vec3 refl = traceRefl(wpos, refldir);
		#else
		vec3 refl = calculateFogColor(wpos, refldir);
		#endif
		col = mix(refl, col, f);
	}
	
	return mix(fogColor, col, fog);
}

// Function 391
float light_specular(vec3 normal, vec3 light_dir, vec3 sight_dir, float shininess, float scattering) {
    vec3 reflected = reflect(light_dir, normal);
    float result = max(dot(-sight_dir, reflected), 0.0);
    result *= max(sign(dot(normal, -light_dir)), 0.0);
    result = max(result * (1.0 - scattering) + scattering, 0.0);
    result = pow(result, shininess);
    return result;
}

// Function 392
float realSoftShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, float w )
{
    vec3 uu = normalize(cross(rd,vec3(0,1,0)));
    vec3 vv = normalize(cross(rd,uu));
    
    float tot = 0.0;
    const int num = 32; // cast 32 rays
	for( int j=0; j<num; j++ )
    {
        // uniform distribution on an disk
        float ra = sqrt(rand());
        float an = 6.283185*rand();
        vec3 jrd = rd + w*ra*(uu*cos(an)+vv*sin(an));
        
        // raycast
        float res = 1.0;
        
        for( int i=0; i<7; i++ ) // 7 objects
        {
            int k = i % 3;
            bool sha = false;
                 if(k==0) sha = shadowBox( ro, jrd, vec3(-4.0 + float(i),0.25,0.0), vec3(0.2,0.5,0.2), tmax);
            else if(k==1) sha = shadowSphere(ro, jrd, vec3(-4.0 + float(i),0.3,0.0), 0.4, tmax);
            else          sha = shadowCylinder( ro - vec3(-4.0 + float(i),0.0,0.0), jrd, 0.8, 0.3, tmax);
            
            if( sha ) { res=0.0; break; }
        }
        
        
        tot += res;
    }
    return tot/float(num);
}

// Function 393
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos, nor ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 394
float sh_shade(vec4 vL, vec4 vN) {
    return sh_flux(sh_dot(vL, vN)) * M_DIVPI;
}

// Function 395
float computeAO(highp vec3 p, highp vec3 normal)
{
    highp float ao = 0.0;
    highp vec3 k = p;
    const int numSamps = 20;
    const highp float h = 1.0 / float(numSamps);
    const highp float d = 0.15;
    
    for(int i = 0; i < numSamps; ++i)
    {
        ao += h * exp(scene(k).d);
        k += normal * d;
    }
    return clamp(ao*0.125,0.0,1.0);
}

// Function 396
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo, in int sampleID )
{
	vec3 pos = ro + t*rd;
	vec3 nor = calcNormalmap( pos, 0.0002 );
	

	vec3 mateD = vec3(0.0);
	vec2 mateK = vec2(0.0);
	float mateS = 0.0;
	vec3 mateSG = vec3(1.0);

	if( m<1.5 )
	{
		mateD = vec3(0.132,0.06,0.06);
		
		vec3 p = pos;
		float no = texture(iChannel0,p.xy).x;
		mateSG = vec3(0.75,0.97,1.0);
		mateK = vec2(0.08,0.5);
		mateS = 1.0;    
		mateK *= 0.5 + no;
	}
	else if( m<6.5 )
	{
        mateD = vec3(0.22,0.24,0.26);
		
		vec3 bp = pos - vec3(-0.695,-1.6,0.1 );

		mateD = mix( mateD, vec3(0.15,0.08,0.05), 1.0-smoothstep(0.003,0.01,abs(bp.x)) );
		
		float h = bp.y - 0.15*sin( 6.0*bp.x );
		h = min( abs(h-1.15)-0.04, abs(h-1.05)-0.01 );
		
		mateD = mix( mateD, vec3(0.004), 1.0-smoothstep( 0.01, 0.02, h ) );
		
		mateD *= 0.9 + 0.1*texture(iChannel0, 1.0*pos.xy ).x;
		mateS = 3.0;
		mateK = vec2(1.0,16.0);
		
		vec2 uv = pos.xy*0.1;
		float te = 0.0;
		float s = 0.5;
		for( int i=0; i<9; i++ )
		{
			te += s*texture(iChannel0,uv).x;
			uv *= 2.11;
			s *= 0.6;
		}
		mateD = mix( mateD, vec3(0.16,0.08,0.0)*0.27, 			0.15*smoothstep(0.6,0.9,te) );
		mateK.x *= 1.0-te;
		
		
	}
	else if( m<9.5 )
	{
		mateD = vec3(0.134,0.07,0.07);
		
		vec3 hp = pos - vec3(-0.945,-0.30,0.12);
		
		float r = length(hp.xy);
		r = min( r, length(hp.xy-vec2(0.0,-0.05)) );
		r = min( r, length(hp.xy-vec2(-0.02,-0.095)) );
		r = min( r, length(hp.xy-vec2(-0.048,-0.14)) );
		
		mateD += 0.023*(1.0 - smoothstep( 0.014,0.018,r));
		
		mateK = vec2(0.2,2.0);
		mateS = 1.0;
		
	}
	
	float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
	float occ = calcAO( pos, nor, sampleID );
	
	vec3 col = vec3(0.0);
	
    {
		// key
		float dif1 = dot(nor,sunDir);
		vec3 hal = normalize( sunDir-rd );
		float spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);

		float sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); 
        
        sha *= 0.15+0.85*smoothstep(0.1,0.3,length((pos-vec3(-0.45,0.16,0.1))*vec3(1.4,0.4,1.0)));
        
		float ssha = 1.0;
		if( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05; }
		if( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }
		
		dif1 = clamp(dif1,0.0,1.0);

		vec3 sha3 = vec3(sha,sha*0.4+0.6*sha*sha,sha*sha);
		
		col += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;
		col += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;
    }
	{
		// fill
		
		col += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;

		float dif1 = 0.5 + 0.5*nor.y;
		float sha = 1.0;
		float spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );
		col += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;
	}
	{
		// bounce
		vec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));
		float dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);
		col += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;
	}
	{
		col += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;
		col += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;
	}

	col = pow( col, mateSG );

    return col;        
}

// Function 397
float calcAO(vec3 p, vec3 n){
	float sca = 1.5;
    float occ = 0.;
    for(float i=ZERO+1.; i<=5.; i+=1.){
        float t = 0.07*i;
        float d = mapDist(p+n*t);
        occ += (t-d)*sca;
        sca *= .5;
    }
    return 1.0 - clamp(occ, 0., 1.);
}

// Function 398
vec3 shadeplanet(vec3 pos, vec3 k) { 

	vec3 n=normalize(planetpos+pos+.2); // tweaked sphere normal
	float c=max(0.,dot(LIGHTDIR,normalize(k-n))); // surface value
	vec3 col=PLANET_COLOR+vec3(c,c*c,c*c*c)*.7; // surface coloring
	// add some noise
	float noi=max(0.,texture(iChannel1,n.yz*.5).x-.6);
	noi+=max(0.,texture(iChannel1,n.yz).x-.6);
	noi+=max(0.,texture(iChannel1,n.yz*2.).x-.6);
	col+=noi*(1.5-c)*.7;
	return col*max(0.,dot(LIGHTDIR,-n)); // diff light
}

// Function 399
v2 light(v2 p,v2 n,v2 i,v0 d,v3 m
){v2 l=normalize(v2(1.,.7,.9))//light direction
 ;v0 o=max(0.,dot(n,l))
 ,c=max(0.,dot(n,normalize(l-i)))
 ,s;if(c>.01)s=shadow(p+.01*n,l)
 ;const v2 LigCol=v2(1.)//light color
 ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))
 ;r+=s*c*pow(o,40.)//specular
 ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map
 ;r*=exp(-.01*d*d)//fog  
 ;return r;}

// Function 400
vec3 shade2(vec3 p, vec3 p2, vec3 n, vec3 n2, vec3 eyePos)
{
	vec3 c;
    vec3 v = normalize(eyePos - p);

	// exponential absorption
	float dist = length(p2 - p)*2.0;
	vec3 absorp = exp(-dist*vec3(1.0, 0.2, 0.5));
	
	// reflection
	vec3 R = reflect(-v, n);
	vec3 Rcol = texture(iChannel1, R).xyz;	
    float f = fresnel(n, v, 0.2);

	// 2nd hit
	v = normalize(eyePos - p2);

	// refraction
	const float eta = 1.0 / 1.1;	// air-glass	
	//vec3 T = normalize(-v + n*0.1);
#if 0
	vec3 T = refract(-v, -n2, eta);
	vec3 Tcol = texture(iChannel1, T).xyz;
#else
	// dispersion
	vec3 T = refract(-v, -n2, eta);
	vec3 Tcol;
	Tcol.r = texture(iChannel1, T).r;
	T = refract(-v, -n2, eta + 0.01);
	Tcol.g = texture(iChannel1, T).g;	
	T = refract(-v, -n2, eta + 0.02);
	Tcol.b = texture(iChannel1, T).b;	
#endif

	Tcol *= absorp;
	c = mix(Tcol, Rcol, f);
	
	//c = Tcol;	
	//c = Rcol;
	//c = vec3(dist);
	//c = vec3(absorp);
	//c = vec3(f);	
	return c;
}

// Function 401
vec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit
){float ray_len
 ;vec3 dir=hit.xyz-ray_start
 ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))
 ;if(hit.w==0.)return c
 ;vec4 p=Phong(dir,lir,hit)
 ;return vec4(mix(p.xyz,c.xyz,.5),1.)
 ;}

// Function 402
vec3 BlinnPhongLighting(
    vec3 point,
    vec3 eye,
    vec3 N,
    vec3 ambient,
    vec3 diffuse,
    vec3 specular,
    float specularAlpha
){
    vec3 L = normalize(N);
    vec3 V = normalize(eye - point);
    vec3 H = normalize(L + V);

    float dotNH = clamp(dot(N, H), 0., 1.);
    float dotNL = clamp(dot(N, L), 0., 1.);

    vec3 ambientColor = diffuse * AmbientLight;
    vec3 diffColor = dotNL * diffuse;
    
    //vec3 R = refract(L, normalize(N), ReflectionRatio);
    //vec3 refl = texture(iChannel1, R).rgb;
    
    /*
    
    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));  
    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));
    FragColor = vec4(ambient + diffuse + specular, 1.0);   
    
    */
    
    
    vec4 ref = texture(iChannel1, N);
    float refIntense = length(ref);
   
    vec3 specColor = pow(dotNH, specularAlpha) * specular;
    
    return ambientColor + (ref.xyz * (diffColor + specColor));
}

// Function 403
vec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)
{
   vec3 fog_color = sky_color(ray_dir, light_dir);
   
   float ray_len;
   vec3 color;
   if (hit.w == 0.0) {
      ray_len = 1e16;
      color = fog_color;
   } else {
      vec3 dir = hit.xyz - ray_start;
      vec3 norm = dNormal(hit.xyz);
      float diffuse = max(0.0, dot(norm, light_dir));
      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));
      spec = pow(spec, 16.0)*.5;
       
      ray_len = length(dir);
   
      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;
      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +
         spec*vec3(1.,1.,.9);

      float fog_dist = ray_len;
      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);
      color = mix(color, fog_color, fog);
   }
   
   
    
   float cut_plane0 = sin(iTime)*.15 - .8;
   for(int k=0; k<4; ++k) {
      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);
      //if (dpcol.w == 0.) continue;
      float fog_dist = ray_len;
      dpcol.w *= 1.0/exp(fog_dist*.05);
      color = mix(color,dpcol.xyz,dpcol.w);
   }

   return color;
}

// Function 404
vec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {

    // lighitng        
    float occ = calcAO( pos, nor );
    vec3  lig = normalize( vec3(-0.6, 0.7, 0.5) );
    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );
    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
    //float dom = smoothstep( -0.1, 0.1, ref.y );
    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
    //float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);
    
    dif *= softshadow( pos, lig, 0.02, 2.5 );
    //dom *= softshadow( pos, ref, 0.02, 2.5 );

    vec3 lin = vec3(0.0);
    lin += 1.20*dif*vec3(.95,0.80,0.60);
    //lin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;
    lin += 0.80*amb*vec3(0.50,0.70,.80)*occ;
    //lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;
    lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;
    lin += 0.20*fre*vec3(1.00,1.00,1.00)*occ;
    col = col*lin;

    return col;
}

// Function 405
vec3 shade(in vec3 pos, in vec3 rd, in float dst)
{
    vec3 nor = normal(pos,rd);
  	float nl = clamp(dot(nor,lgt), 0., 1.);
    float ripe = smoothstep(0.2,2.2,(mous.y + noise(pos*1.5)))*0.22;
    vec3 albhsv = vec3(0.003+ripe, .99-ripe*0.5,.5);
    float nz = (noise(pos*150.)-0.5)*0.035; //Skin imperfections
    albhsv.z += nz;
    albhsv.y -= nz;
    vec3 f0hsv = vec3(0.01,.5,.15);
    float soft = 2.;
    float rough = 0.5;
	float mtid = matid;
    if (matid == 0.) //floor/walls
    {
        albhsv = vec3(1.,.0,1.);
        soft = 8.;
    } 
    else if (matid == 2.) //Leaves/Tail
    {
        float nz2 = noise(pos*17.)*0.8;
        nz2 += noise(pos*70.)*0.8;
        
        nor = bump(pos,nor,dst);
        nl = clamp(dot(nor,lgt), 0., 1.);
        albhsv = vec3(.25 + nz2*0.07 - (1.-mous.y)*0.05, .9,.35- nz2*0.15 - (1.-mous.y)*0.08);
        rough = 0.7;
    }
    
    //Artistic shading
    float stp = step(mous.x,pxx);
    albhsv.x += ((nl-.7)*0.08)* stp; //Hue variation
    float vari = sin(nl*6.28*0.5-1.5708);
    albhsv.y += vari*0.1*stp; //Saturation variation
    albhsv.z += vari*0.12*stp; //Value variation
    //albhsv.z += sin(nl*6.28*1.+3.14159)*0.13*stp; //Can be higher freqency
    
    vec3 alb = hsv2rgb(albhsv);
    vec3 f0 = hsv2rgb(f0hsv);
    
	vec4 col = vec4(0.);
    
    if (nl > 0.)
    {
        nl *= shadow(pos, lgt, 0.01,2.5, soft)*0.9+0.1;
        vec3 haf = normalize(lgt - rd);
        float nh = clamp(dot(nor, haf), 0., 1.); 
        float nv = clamp(dot(nor, -rd), 0., 1.);
        float lh = clamp(dot(lgt, haf), 0., 1.);
        float a = rough*rough;
        float a2 = a*a;
        float dnm = nh*nh*(a2 - 1.) + 1.;
        float D = a2/(3.14159*dnm*dnm);
        float k = pow(rough + 1., 2.)/8.; //hotness reducing
		float G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));
        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh); //exp2 "optimization"
        vec3 spec = nl*D*F*G;
        col.rgb = lcol*nl*(spec + alb*(1. - f0));
        col.a = nl;
    }
    
    float h = clamp(pos.y*2.+.85,0.01,1.);
    
    //Hemispherical bounce lights (GI fakery)
    float bnc = clamp(dot(nor, normalize(vec3(lgt.x,0.0,lgt.z)))*.5+0.28,0. , 1.);
    col.rgb += lcol*alb*bnc*0.25 *h* (1.-col.a);
    float bnc2 = clamp(dot(nor, vec3(-lgt.x,lgt.y,-lgt.z))*.5+0.28,0. , 1.);
    col.rgb += lcol*alb*bnc2*0.1 *h* (1.-col.a);
    
    col.rgb += 0.02*alb;
   	col *= getAO(pos,nor);
    return col.rgb;
}

// Function 406
float SoftShadowIntersect(in vec3 rayOrigin, in vec3 rayDirection, in float tmin, in float tmax, in int iterations, in float width)
{
    int rayIntersectFlags = CalculateOptimizedIntersectFlags(rayOrigin, rayDirection);
	float precis = 0.01;
    float t = tmin;
    float shadowFactor = 1.0;
    float ph = 1e20;
    int i;
    for( i=(min(iFrame,0)); i<iterations; i++ )
    {
	    vec2 res = QueryDistanceField( rayOrigin+rayDirection*t, SHADOW_INTERSECT_FLAG | rayIntersectFlags );
        if( res.x < precis || t>tmax )
        {
            int materialID = int(res.y);
            if(materialID == int(INVALID_MATERIAL_ID) || materialID == int(CABIN_LAMP_MATERIAL_ID))
            {
                break;
            }
            else
            {
                shadowFactor = 0.0;
            }
        }
        float y = res.x*res.x/(2.0*ph);
        float d = sqrt(res.x*res.x-y*y);
        shadowFactor = min( shadowFactor, width*d/max(0.0,t-y) );

        ph = res.x;
        t += res.x;
    }
    return shadowFactor;
}

// Function 407
float GrndSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = VAR_ZERO; j < 30; j ++) {
    p = ro + d * rd;
    h = p.y - GrndHt (p.xz);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += clamp (h, 0.01, 1.);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 408
vec3 shade( in vec3 p, in vec3 n, in vec3 org, in vec3 dir, vec2 v )
{		
    vec3 col = vec3(1.);
	
    float a = ambientOcclusion(p,n, 4., 2.);
    float b = classicAmbientOcclusion(p,n, 4., 1.2);
    
    if( iMouse.z > .5 ) 
    {
        if( v.x-iMouse.x/iResolution.x >0. )
			col *= a;
        else
            col *= b;
    }
    else
    {
        if( v.x > 0.5 )
			col *= a;
        else
            col *= b;
    }
        
	return col;
}

// Function 409
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {
	float res = 1.0;
	float t = mint;
	for (int i = 0; i < 32; i++) {
		float h = map(ro + rd * t).x;
		res = min(res, 8.0 * h / t);
		t += clamp(h, 0.02, 0.10);
		if (res < 0.005 || t > tmax) break;
	}
	return clamp(res, 0.0, 1.0);
}

// Function 410
void lightPos(float t, out vec3 lPos) {
    lPos = RotYV3(lPos, t);
}

// Function 411
vec3 getShadedColor( vec3 hitPosition, vec3 normal, vec3 cameraPosition )
{
	//	light relative to camera position
	vec3 lightPosition = vec3(sin(iTime), 3.0, cos(iTime));

	//	Specular highlight factor
	float materialShininess = 64.0;
	vec3 materialSpecularColor = vec3( 1.0 );

	//	Output color
	vec3 outputColor = vec3( 0.0 );

	//	Calculate eye vector and its reflection
	vec3 surfaceToLight = normalize(lightPosition - hitPosition);
	vec3 surfaceToCamera = normalize(cameraPosition - hitPosition);

	//	surface color
	vec3 surfaceColor = getMaterialColor(hitPosition);

	//	ambient component
    vec3 lightColor = vec3(abs(sin(iTime*0.84)), abs(cos(iTime)), abs(sin(iTime*1.337)))*smoothstep(-0.3, 1.0, afFrequencies[0]);
	vec3 ambientColor = surfaceColor * lightColor * 0.0; // ambient factor

	//	diffuse component
	float diffuseCoefficient = max(0.0, dot(normal, surfaceToLight));
	vec3 diffuseColor = diffuseCoefficient * surfaceColor * lightColor;

	//	specular component
	float specularCoefficient = 0.0;
	if(diffuseCoefficient > 0.0) {
		//specularCoefficient = pow(max(0.0, dot(surfaceToCamera, reflect(-surfaceToLight, normal))), materialShininess);
	}
	vec3 specularColor = specularCoefficient * materialSpecularColor * lightColor;

	//	light attenuation (falloff based on distance, fog)
	float distanceToLight = length(lightPosition - hitPosition);
	float attenuation = 1.0 / (1.0 + lightAttenuation * pow(distanceToLight, 2.0));

	//	soft shadows (optional)
	float shadow = 1.0;
	#ifdef ENABLE_SHADOWS
	shadow = max(0.2, softshadow(hitPosition, surfaceToLight, 0.01, 5.0, 8.0));
	#endif

	//	ambient occlusion (optional)
	float occlusionCoefficient = 1.0;
	#ifdef ENABLE_OCCLUSION
	occlusionCoefficient = ambientOcclusion(hitPosition, 0.01, 10);
	#endif

	//	calculate final color
	outputColor = ambientColor + occlusionCoefficient * shadow * attenuation*(diffuseColor + specularColor);

	//	gamma correction
	//vec3 gamma = vec3(1.0/2.2);
	//outputColor = vec3(pow(outputColor, gamma));

	//	return shading result
	return outputColor;
}

// Function 412
float checkShadow(Ray ray) {
    float h = INFINITY;
    for (int i = 0; i < 2; i++) {
        float t = hitSphere(spheres[i], ray);

        if (t > 1.0 && t < h) {
            return 0.3;
        }

    }
    return 1.0;
}

// Function 413
float softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {
  float res = 1.;
  float t = mint;
  float ph = 1e10;
  for(int i = 0; i < maxShadowIterations; i++) {
    float h = scene(ro + rd * t).x;

    // pattern 1
    // res = min(res, power * h / t);

    // pattern 2
    float y = h * h / (2. * ph);
    float d = sqrt(h * h - y * y);
    res = min(res, power * d / max(0., t - y));
    ph = h;

    t += h;

    float e = EPS;
    if(res < e || t > tmax) break;
  }
  return clamp(res, 0., 1.);
}

// Function 414
float GetLight(vec3 p, vec3 n, float height, float waterMask) 
{
    vec3 lightPos = LIGHTPOS;
    vec3 l = normalize(lightPos-p);

    // Tricky way to compute the normal ... seems acceptable on screen, only one extra height sample to compute
    vec3 pBis =normalize(p+l*0.01 - PLANETCENTER)*0.5*PLANETRADIUS;
    pBis = RotateY(pBis, iTime*0.05);
    float heightBis = GetFBM(pBis) * 0.6;
    float deltaH = heightBis-height;
    
   	n = normalize(n-deltaH*l*40.0*(1.0-waterMask));
    
    float dif = dot(n, l); // can go - (used for night lights)
    float d = GetSceneDistance(p+n*SURF_DIST*2., l);
    if(d<length(lightPos-p)) dif *= .1;
    
    return dif;
}

// Function 415
bool TestLightInRange(const in float lightDistance, const in float cutoffDistance){
    return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));
}

// Function 416
vec3 light(vec3 p, vec3 n)
{
    vec3 col = vec3(0.01);
    
    for(int i=0;i<2;i++){
        vec3 ld = (i==0) ? lDir0 : lDir1;
        float diff = max(dot(n, (ld)),0.);
        diff *= getShadow(p, n, ld);
        col += diff * (i==0 ? lCol0 : lCol1);
    }
    return col * .7;
}

// Function 417
vec3 shade(vec3 pos, vec3 n, vec3 eyePos, float m, float edge, float t)
{
    //const vec3 lightPos = vec3(5.0, 10.0, 5.0);
    //vec3 color = vec3(0.1, 0.3, 1.0);	// blue
	vec3 color = vec3(1.0, 0.7, 0.1);	// yellow
	const float ka = 0.2;
	vec3 specColor = vec3(0.75);
    const float shininess = 20.0;

    if (m==1.0) {
		color = vec3(0.05);		
    } else if (m==2.0) {
		color = vec3(1.0);
	} else if (m==3.0) {
		// floor
	    color = vec3(0.08, 0.12, 0.23);
		specColor = vec3(0.0);
		vec2 uv = pos.xz * 0.3;
		if (t > 14.0) uv.x += (t - 14.0)*10.0;
		vec2 g = fract(uv);
		//vec2 width = fwidth(uv); float w = max(width.x, width.y);
		const float w = 0.02;
		//color = ((g.x < 0.04) || (g.y < 0.04)) ? vec3(1.0): color;
		float l = smoothpulse(0.0, 0.05, w, g.x) + smoothpulse(0.0, 0.05, w, g.y);
		color = mix(color, vec3(1.0), min(l, 1.0));
		//color = vec3(w);
	} else if (m==4.0) {
		// jet wall
		float x = -(pos.x+2.0)*0.3;
		x = floor(x*15.0)/15.0;
		color = mix(vec3(1.2), color, clamp(x, 0.0, 1.0));
	}
	
    //vec3 l = normalize(lightPos - pos);
	const vec3 l = vec3(0.577, 0.577, -0.577);
	//const vec3 l = vec3(0, 1, 0);
    vec3 v = normalize(eyePos - pos);
    vec3 h = normalize(v + l);
    float diff = dot(n, l);
    float spec = pow(max(0.0, dot(n, h)), shininess) * float(diff > 0.0);
    diff = max(0.0, diff);
    //diff = 0.5+0.5*diff;

	bool shadowHit;
	pos += n*eps;
	vec3 shadowPos = trace(pos, l, shadowHit, m, t);
	diff *= shadowHit ? 0.25 : 1.0;
	spec *= shadowHit ? 0.0 : 1.0;

	// add edges:
	//color = mix(color, vec3(1.0), edge);
	
    //float fresnel = pow(1.0 - dot(n, v), 5.0);
    //float ao = ambientOcclusion(pos, n);

    return (ka + diff)*color + spec*specColor;
//    return vec3(diff*ao) * color + vec3(spec);
//    return vec3(diff*ao) * color + vec3(spec);
//    return vec3(ao);
//    return vec3(fresnel);
//    return n*0.5+0.5;
//	return vec3(edge);
}

// Function 418
float castShadowRay( in vec3 ro, in vec3 rd )
{
    for( uint i=0U; i<NUMBOXES; i++ )
    {
        mat4 ma; vec3 si; getLocation(i, ma, si);

        if( iBox( ro, rd, ma, si )>0.0 )
            return 0.0;
    }
	return 1.0;
}

// Function 419
float calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )
{
	float ao = 0.0;
	const int nbIte = 5;
	for( int i=0; i<nbIte; i++ )
	{
		float l = hash(float(i))*maxDist;
		vec3 rd = n*l;
		ao += (l - map(p + rd.x, false).x) / pow(1.+l, falloff);
	}
	return clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);
}

// Function 420
vec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){
    vec3 light = vec3(0.);
    float li = max(dot(lightdir,rd),0.);
    light+=pow(lightCol,vec3(2))*pow(li,2.);
    light+=lightCol*pow(li,200.9);
    return light;

}

// Function 421
vec3 getLighting(vec3 color, float nDotL, vec3 lPos, vec3 rV){
    
    float reflection = pow(clamp(dot(lPos, rV), 0.0, 1.0), 10.0);
    
    return color * (sunlight * nDotL + (ambientLight + sunlight * 0.015)
           + (doSpecular ? reflection * sunlight : vec3(0.0)));
}

// Function 422
float RLightCone()
{
	// tan of one half of subtended angle of sun disc in sky

	return 0.02;
}

// Function 423
float calcAO(vec3 p, vec3 n, float radius) {
    float s = radius/3.0;
    float ao = 0.0;
    for (int i = 1; i <= 3; ++i) {
        float dist = s * float(i);
    float t = map(p + n*dist);
        ao += max(0.0, (dist - t) / dist);
    }
    return 1.0 - (ao/3.0);
}

// Function 424
vec3 LightShading(vec3 Normal,vec3 toLight,vec3 toEye,vec3 color)
{
    vec3 toReflectedLight=reflect(-toLight, Normal);
    vec3 diffuse = max(0.,dot(Normal,-toLight))*color;
    //vec3 specular = pow(max(0.,dot(Normal,normalize(-toLight-V))),100.)*vec3(1.,1.,1.); 
    float specularf=max(dot(toReflectedLight, toEye),0.0);
    specularf=pow(specularf, 100.0);
    vec3 specular =specularf*vec3(1.0);
    
    return diffuse + specular;
}

// Function 425
float ao(vec3 p, vec3 n) {
    float o = 0.0, s = 0.005;
    for(int i = 0; i< 15; i++) {
        float d = map(p + n*s);
        o += (s - d);
        s += s/float(i + 1);
    }
    
    return 1.0 - clamp(o, 0.0, 1.0);
}

// Function 426
vec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL
	#ifdef ENABLE_HARD_SHADOWS
		float sh=shadow(p, lightdir);
	#else
		float sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS
	#endif
	float ao=calcAO(p,n);
	float diff=max(0.,dot(lightdir,-n))*sh*.95;
	float y=3.16-p.y;
	vec3 amb=max(.6,dot(dir,-n))*.7*AMBIENT_COLOR;
	vec3 r = reflect(lightdir,n);
	float spec=pow(max(0.,dot(dir,-r))*sh,15.)*.5;
	vec3 col;
	float energysource=pow(max(0.,.1-abs(y))/.1,3.)*1.5;
		float k=texture2(p); 
		col=mix(vec3(k,k*k,k*k*k)*.9+.1,vec3(k)*1.5,.4);
		if (abs(hid-1.)<.001) col=FLOOR_COLOR;
	col=col*(amb*ao+diff*(.3+ao*.5)*LIGHT_COLOR)+spec*LIGHT_COLOR;	
	return col;
}

// Function 427
vec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col, float id) {
	ldir = normalize(ldir);
    float amb = .05;
    float sh = shadow(p);
    float dif = max(0., dot(ldir, n)) * .7 * sh;
    vec3 ref = reflect(ldir, n) * sh;
    float spe = pow(max(0., dot(ref, dir)), 10.) * .5 * (.3+step(abs(id - 1.), .1));
    return (amb + dif) * col + spe;
}

// Function 428
vec3 ShadeRay( vec3 pos, vec3 ray, float time )
{
    // animate moving objects
    float r = -(time+sin(time))*50.;
//    vec4 s0 = vec4(-.7071,-1.+.7071,0,1), s1 = vec4(.7071,-1.+3.*.7071,0,0);
    vec4 s0 = vec4(-1.5,0,0,1), s1 = vec4(1.5,1,0,0);
    Scene[0] = s0;
    Scene[1] = s1;
    Scene[0].xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;
    Scene[1].xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;
    Scene[0].w = .1;//.5+.5*pow(1.-fract(time*2.),2.);
    
    vec3 normal = vec3(0);
    int material = -1;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;
        
        vec3 sun = normalize(vec3(-.5,2,3));
        vec3 testn = vec3(0);
        int ignore;
        Trace(testn,ignore,pos,sun);
        
        vec3 light = vec3(.05,.065,.09)*(normal.y*.3+1.); // ambient
        if ( length(testn) == 0. )
        {
        	light += max(0.,dot(normal,sun)) * vec3(1,.95,.92);
        }
        
        vec3 albedo = smoothstep(.01,.02,abs(fract( pos+.001 )-.5));
        
        if ( material == 0 ) { albedo = vec3(1,0,0); }//light += vec3(1.); }
        
        col = light*albedo;
    }

// Function 429
vec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)
{
    vec3 cScene;
    
    C_Shading shading;

    shading.cDiffuse = vec3(0.0);
    shading.cSpecular = vec3(0.0);
    
    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);
    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;
    
    shading.cDiffuse += vAmbientLight;
    shading.cSpecular += surface.cReflection;
              
    #ifdef ENABLE_POINT_LIGHT
    C_PointLight pointLight = GetPointLight(); 
    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);
    shading.cDiffuse += pointLighting.cDiffuse;
    shading.cSpecular += pointLighting.cSpecular;
    #endif

    #ifdef ENABLE_DIRECTIONAL_LIGHT
	C_DirectionalLight directionalLight = GetDirectionalLight();
    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);
    shading.cDiffuse += directionLighting.cDiffuse;
    shading.cSpecular += directionLighting.cSpecular;
    #endif

    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;              

    // swap diffuse for transmission
    vDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);    

    #ifdef ENABLE_SPECULAR
    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);
    #else
    cScene = vDiffuseReflection;
    #endif
    
    return cScene;
}

// Function 430
vec3 salmpleLight(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                  	in vec3 wi,
                  	in Material mtl,
                  	in bool useMIS,
                  	in int strataCount,
                  	in int strataIndex ) {
    vec3 Lo = vec3(0.0);	//outgoing radiance

    for(int i=0; i<DL_SAMPLES; i++) {
        float lightPickingPdf;
        Light light = pickOneLight(lightPickingPdf);

        vec3 wo;
        float lightPdfW, lightDist;

        LightSamplingRecord rec;
        float Xi1 = rnd();
        float Xi2 = rnd();
        float strataSize = 1.0 / float(strataCount);
        Xi2 = strataSize * (float(strataIndex) + Xi2);

        vec3 Li = sampleLightSource( x, Xi1, Xi2, rec );
        //vec3 Li = sampleSphericalLight( x, Xi1, Xi2, rec );
        wo = rec.w;
        lightPdfW = rec.pdf;
        lightDist = rec.d;
        lightPdfW *= lightPickingPdf;

        float dotNWo = dot(wo, ns);

        if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {
            vec3 fr = mtlEval(mtl, ng, ns, wi, wo);
            if(dot(fr,fr)>0.0) {
                Ray shadowRay = Ray(x, wo);
                if (isLightVisible( shadowRay )) {
                    vec3 contribution = (Li * fr * dotNWo) / lightPdfW;

                    if (useMIS /*&& !(light->isSingular())*/) {
                        float brdfPdfW = mtlPdf(mtl, ng, ns, wi, wo);
                        contribution *= misWeight(lightPdfW, brdfPdfW);
                    }

                    Lo += contribution;
                }
            }
        }
    }

    return Lo*(1.0/float(DL_SAMPLES));
}

// Function 431
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float dt = 0.1;
    float t = mint;
    for( int i=0; i<30; i++ )
    {
        float h = map(ro + rd*t).x;
        h = max(h,0.0);
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += dt;
		if( h<0.001 ) break;
    }
    return res;
}

// Function 432
float softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {
    vec3 p = rp;
    float sh = 0.;
    float d,s = 0.;
    for (int i = 0; i < SHADOW_ITERATIONS; i++) {
        d = df(rp+rd*s);
        sh += max(0., penumbraSize-d)*float(s>penumbraSize*4.);
        s += d;
        if (d < EPSILON || s > maxDist) break;
    }
    
    if (d < EPSILON) return 0.;
    
    return max(0.,1.-sh/penumbraIntensity);
}

// Function 433
C_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;

    const float kShadowRayLength = 10.0;      
    vec3 vLightDir = -light.vDir;
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );
    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}

// Function 434
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 435
vec3 sampleLightE( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )
{
    vec3 e = vec3( 0 );
    vec3 s = vec3( 0 );

    Light light;
    light.id = 3.0;
    light.emission = LIGHT1_EM;

    vec3 l0 = LIGHT1_POS - hitOrigin;

    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    float cosa = mix(cos_a_max, 1., random());
    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );        
#endif        
    {
        float omega = 2. * PI * (1. - cos_a_max);
        vec3 n = normalize(hitOrigin - LIGHT1_POS);
        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);
    }

    light.id = 4.0;

    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;
    
    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    cosa = mix(cos_a_max, 1., random());
    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );        
#endif  
    {
        float omega = 2. * PI * (1. - cos_a_max);
        vec3 n = normalize(hitOrigin - vec3( -4, 1.5, 4 ));
        e += ((light.emission * clamp(dot(l, n),0.,1.) * omega) / PI);
    }
    
#if (PATH == 0)
    e *= clamp( s, 0., 1. );
#endif    

    return e;
}

// Function 436
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<50; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.02, 2.0/50.0 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 437
void ProcessLightValue(float time)
{
    time *= 1.;
    
    o_lights[0].pos = vec3(6.,1.,sin(time));
    o_lights[0].colorIntensity = 3.*vec4(0.2,1.,.2,1);
    o_lights[1].pos = vec3(-3,-2.2,sin(time*.3)*8.);
    o_lights[1].colorIntensity = 2.*vec4(1,1,0.5,1);
    o_lights[2].pos = vec3(9.5,1.8,9.5);
    o_lights[2].colorIntensity = 3.*max(0.,abs(sin(PI*time)))*vec4(1,0.2,1,1);
}

// Function 438
vec4 voronoi_column_trace_shadow(
         vec4 mc,
         vec3 ray_pos,
         vec3 ray_dir,
         float max_h,
         out vec4 hit_pos,
         out vec3 hit_norm )
{
   const int iter = 8;

   vec2 p = ray_pos.xy;
   float s = 1./length(ray_dir.xy);
   vec2 dir = ray_dir.xy*s;
   vec2 n = floor(p);
   vec2 f = fract(p);
   
   mc -= vec4(p, n);
   
   float md;
   
   vec2 mdr = vec2(0,1);
   float dh = 0.;
   float h = 0.;
   
   md = eps;

   for( int k=0; k<iter; ++k )
   {
      // Scan through all Voronoi neighbours in direction of ray.
      
      vec4 kc;
      vec2 kdr;
      float kd = find_neighbour(n, f, dir, mc, kc, kdr)*s;
      
      mc = kc;
      md = kd;
      mdr = kdr;
      
      // Get height of the column
      h = hash12( mc.zw + n )*max_h;
      dh = ray_pos.z + ray_dir.z*md;
      if (dh > max_h || dh < h) break;
   }
   
   if (dh >= h) {
      hit_pos = vec4(ray_pos + ray_dir*max_dist,max_dist);
      hit_norm = vec3(0,0,1);
      return vec4(0);
   }
   
   float d = md;
   hit_norm = vec3(-normalize(mdr),0);
   hit_pos = vec4(ray_pos + ray_dir*d, d);
   return mc + vec4(p, n);
}

// Function 439
float calcAO( in vec3 pos, in vec3 nor ) {
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ ) {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 440
float Shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = 0.05;
	float h;
	
    for (int i = 0; i < 6; i++)
	{
		h = Map( ro + rd*t );
		res = min(7.0*h / t, res);
		t += h+.01;
	}
    return max(res, 0.0);
}

// Function 441
float calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )
{
    float res = 1.0;
    
    // bounding sphere
    vec2 b = iSphere( ro, rd, 0.535 );
	if( b.y>0.0 )
    {
        // raymarch
        float tmax = b.y;
        float t    = max(b.x,0.001);
        for( int i=0; i<64; i++ )
        {
            float h = map( ro + rd*t, time ).x;
            res = min( res, k*h/t );
            t += clamp( h, 0.012, 0.2 );
            if( res<0.001 || t>tmax ) break;
        }
    }
    
    return clamp( res, 0.0, 1.0 );
}

// Function 442
vec3 generateShadeZcam(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {
    ZcamViewingConditions cond = getZcamCond();

    float cielabL = CIELAB_LIGHTNESS_MAP[shade];
    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0)) * cond.whiteLuminance;
    float lightness = xyzToZcam(cielabXyz, cond).lightness;

    // Calculate accent1 chroma given the viewing conditions
    float chromaAcc = 0.0;
    for (int i = 0; i < REF_ACCENT1_COLOR_COUNT; i++) {
        vec3 srgb = rgb8ToFloat(REF_ACCENT1_COLORS[i]);
        vec3 xyzAbs = linearSrgbToXyz(srgbTransferInv(srgb)) * cond.whiteLuminance;
        Zcam zcam = xyzToZcam(xyzAbs, cond);
        chromaAcc += zcam.chroma;
    }
    float avgChroma = 1.2 * chromaAcc / float(REF_ACCENT1_COLOR_COUNT);

    // For constant values
    //lightness = ZCAM_LIGHTNESS_MAP[shade];
    //avgChroma = ZCAM_ACCENT1_CHROMA;
    // For linear shade lightness in ZCAM
    //lightness = ZCAM_LINEAR_LIGHTNESS_MAP[shade];

    vec3 jch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, avgChroma);

    if (CLIP_ZCAM) {
        return clipZcamJchToLinearSrgb(jch, cond);
    } else {
        return zcamJchToLinearSrgb(jch, cond);
    }
}

// Function 443
float softShadow( in vec3 ro, in vec3 rd, float mint, float k )
{
	vec4 dummy;
    float res = 1.0;
    float t = mint;
    for( int i=0; i<45; i++ )
    {
        float h = map(ro + rd*t,dummy).x;
        res = min( res, k*h/t );
        t += h*STEP_REDUCTION;
    }
    return clamp(res,0.0,1.0);
}

// Function 444
bool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity
){dist = 0.0 + 10.1*hash1(gl_FragCoord.xy + time)
 ;float minStep = 0.01
 ;light_intensity = 1.
 ;float mapDist
 ;for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++
 ){p = ray_start + ray_dir * dist
  ;mapDist = mapBlocks(p, ray_dir).y
  ;if (mapDist < MIN_RAYMARCH_DELTA
  ){iterations = i
   ;return true;}
  ;light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist)
  ;dist += max(mapDist, minStep)
  ;if(dist>=maxDist||p.y>maxY)break
 ;}
 ;return false;}

// Function 445
vec4 sampleLight(int i)
{
    AreaLight light = LIGHTS[i];
    float pdf = 1.0 / (4.0 * light.size.x * light.size.y);
    mat4 S = mat4(light.size.x,            0, 0, 0,
                            0, light.size.y, 0, 0,
                            0,            0, 1, 0,
                            0,            0, 0, 1);
    mat4 M = light.toWorld * S;
    return vec4((M * vec4(vec2(rnd(), rnd()) * 2.0 - 1.0, 0, 1)).xyz, pdf);
}

// Function 446
void shaderLsdLive(out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)
{
    vec3 ro = vec3(cos(iTime)*.2, sin(iTime)*.05, -3. + .3 * sin(iTime));
	vec3 col = vec3(0);

	for (int j = 0; j < ANTIALIAS; j++) {
		for (int i = 0; i < ANTIALIAS; i++) {
			vec2 off = vec2(float(i), float(j)) / float(ANTIALIAS);

			vec2 uv = (fragCoord.xy + off) / resolution.xy - .5;
			uv.x *= resolution.x / resolution.y;

			// it was faster to move the frame like this for the composition
			uv -= vec2(.4, .08);

            vec3 rd = normalize(vec3(uv, .6 - length(uv)));// cheap lens distortion
            vec3 p;
            
			float t = 0., tmax = 25.;
			for (float i = 0.; i < 1.; i += .01) {
				p = ro + rd * t;
				float d = de(p);
				if (d < .001 || t > tmax)
                    break;
				t += d;
			}

			vec3 c = vec3(.4, .1, .1);
			if (t <= tmax) {
				vec3 n = normal(p);
                vec3 ld = normalize(vec3(1, 1, -3));
				float dotNL = max(0., dot(n, ld));
				float ao = calculate_ao(p, n);

				apply_transform(p);
				apply_transform(n);

				float dither_pattern = tex3D(p, n);

				vec3 albedo = vec3(smoothstep(-.5, 1., n.y),
					smoothstep(-1., 1., n.y),
					smoothstep(-.2, 1., n.y));

				c = albedo * ao * (.5 * dotNL + .5);
				c = step(dither_pattern, c);
				c = palette(luma(c));
			}

			col += c;

		}
	}
	col /= float(ANTIALIAS * ANTIALIAS);

	// gamma
	col = pow(col, vec3(.4545));;
	// vignetting
	vec2 q = fragCoord / resolution.xy;
	col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);

	fragColor = vec4(col, 1.0);
}

// Function 447
vec3 light(vec3 pos, vec3 inColor)
{
    vec3 norm = normalize(pos);
    vec3 lightDir = normalize(lightPos - pos);
    
    float cosIncidence = dot(lightDir, norm);
    float diffuse = clamp(cosIncidence, 0., 1.);
    
    vec3 refl = reflect(lightDir, norm);
    vec3 viewDir = normalize(pos - viewerPos);

    float specularTerm = clamp(dot(viewDir, refl), 0., 1.);
    float specular = pow(specularTerm, 4.);
    
    return vec3(ambientCol * inColor.xyz + lightCol * (diffuse + specular));
}

// Function 448
float orbShadow(float rad, vec3 coord)
{
	return 1.0 - smoothstep(0.4, 1.1, distance(coord.xy, frag_coord) / rad) *
		mix(1.0,0.99,orb(rad,coord));
}

// Function 449
float GetLight(vec3 p)
{
    vec3 lightPos = vec3(0,5,6);
    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.0;
    vec3 l = normalize(lightPos-p);
    vec3 n = GetNormal(p);
    
    float dif = clamp(dot(n,l),0.,1.);
    
    float d = RayMarch(p + n*Surf_Dist*2.0,l);
    if(d<length(lightPos-p))dif*=0.1;
    return dif;
}

// Function 450
float calcAO( in vec3 pos, in vec3 nor) {
	float occ = 0.0;
	float sca = 1.0;
	for (int i = 0; i < 5; i++) {
		float hr = 0.01 + 0.12 * float(i) / 4.0;
		vec3 aopos = nor * hr + pos;
		float dd = map(aopos).x;
		occ += -(dd - hr) * sca;
		sca *= 0.95;
	}
	return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// Function 451
float GeometrySchlickGGX_LIGHT(float NdotV, float roughness){
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;
    
    float nom   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    return nom / denom;
}

// Function 452
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
	float res = 1.0;
	float t = mint;
	for( int i=0; i<48; i++ )
	{
		float h = mapTerrain(ro + rd*t).w;
		h = max( h*0.08, 0.0 );
		res = min( res, k*h/t );
		t += clamp( h, 0.02, 0.5 );
		if( h<0.0001 ) break;
	}
	return clamp(res,0.0,1.0);
}

// Function 453
vec3 shade(vec3 ro, vec3 rd) {
    vec3 col = getSky(rd);
    
    // emulate refraction through the visor
    float tHelmet = .005;
    vec3 hp = ro + rd * tHelmet;
    vec3 hn = normalize(ro - hp);
    vec3 hr = normalize(refract(rd, hn, 1.25));
    
    vec2 t = raymarch(hp, hr, 0.);
    if(t.x < MAX_DIST && t.y > -1.) {
        vec3 p = ro+rd*t.x;
        vec3 n = calcNormal(p,t.x);
        vec3 r = normalize(reflect(rd,n));
        
        float ndotl = max(dot(n,sunDir),0.);
        float rdotl = max(dot(r,sunDir),0.);
        float shdw  = 1.;
        
        if(t.x < 500.) { // only draw shadows at short distance to save performance
            shdw = softshadow(p,sunDir,1000.);
        }
        
        Material mat;
        material(mat, p, n, rd, ndotl, t);
        col = ambLight +
            mat.albedo * ndotl * shdw +
            mat.specular * pow(rdotl, mat.shine) * shdw +
            max(vec3(0.),mat.emission);
    }
    
    // add visor artefacts
    hr = normalize(reflect(rd,hn));
    float shdw = softshadow(hp,sunDir,100.);
    // visor specular
    col += pow(max(dot(hr,sunDir),0.),70.) * shdw;
    // visor dust/dirt
    col += pow(fbm(hn*1.),3.) * (.2 + .3 * shdw);
    
    //col = sqrt(col);
    return col;
}

// Function 454
float softShadow(vec3 ro, vec3 rd )
{
    float res = 1.0;
    float t = 0.001;
	
	for(int i = 0; i < 80; i++)
	{
	    vec3  p = ro + t * rd;
        float h = p.y - terrainHeight( p.xz );
		
		res = min( res, 16.0 * h / t );
		t += h;
		
		if( res<0.001 || p.y > (SC * 200.0) ) break;
	}
	
	return clamp( res, 0.0, 1.0 );
}

// Function 455
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )
{
    vec3 lin = vec3(0.0);

    vec3  lig = normalize(vec3(1.0,0.7,0.9));
	float cos_Ol = max(0.0, dot(nor, lig));
    vec3 h = normalize(lig - rd);
    float cos_Oh = max(0.0,dot(nor, h));
    float dif = cos_Ol;
    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(0.8, 0.7, 0.6)*sha;
    
    lin += vec3(0.20,0.30,0.30);

    
    vec3 col = mal.rgb*lin;

    // specular
    col += cos_Ol * pow(cos_Oh,40.0);
    
    // envmap
  //  col += mal.w*texture(iChannel0, reflect(rd,nor)).rgb;
    
    // fog    
    //-----------------------------
	col *= exp(-0.01*dis*dis);

    return col;
}

// Function 456
float softshadow( in vec3 ro, in vec3 rd, float k, float l )
{
    float res = 1.0;
    float t = 0.1;
	vec4 kk;
	float kk2;
	float h = 1.0;

	for( int i=0; i<38; i++ )
    {
		h = map2( ro + rd*t );
		h = max( h, 0.0 );
        res = min( res, k*h/t );
		t += clamp( h, 0.001, 0.3 );
		if( h<0.0001 ) break;
    }
	
#ifdef GODRAYS
    // fake leaves shadow	
	vec3 pp = ro - rd*dot(rd,ro);
	res *= mix( 1.0, smoothstep( 0.3, 0.5, texture(iChannel2,2.0*pp.zx).x ), 0.5+0.5*l );
#endif	
    return clamp(res,0.0,1.0);
}

// Function 457
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    lightPos = eye;
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 458
float calcShadow(vec3 p, vec3 lightPos) {
	// Thanks iq.
	vec3 rd = normalize(lightPos - p);
	float res = 1.,
	      t = .1;
	for (float i = 0.; i < 30.; i++) {
		float h = map(p + rd * t).d;
		res = min(res, 12. * h / t);
		t += h;
		if (res < .001 || t > 25.) break;
	}

	return clamp(res, 0., 1.);
}

// Function 459
float fiveTapAO(vec3 p, vec3 n, float k) {
    float aoSum = 0.0;
    for(float i = 0.0; i < 5.0; ++i) {
        float coeff = 1.0 / pow(2.0, i);
        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));
    }
    return 1.0 - k * aoSum;
}

// Function 460
vec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, float Li, float dwi, float kdiffuse, float kspecular )
{
	float F0 = 0.08;
	float roughness = 0.25;
	float alpha = roughness * roughness;
	vec3 h = normalize( l + v );
	float eps = 1e-4; // else divides by zero
	float n_dot_l = max( eps, dot( n, l ) );
	float n_dot_v = max( eps, dot( n, v ) );
	float n_dot_h = max( eps, dot( n, h ) );
	float v_dot_h = max( eps, dot( h, v ) );
	float l_dot_h = max( eps, dot( l, h ) );

//	float D = D_blinn_phong( n_dot_h, alpha ); // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model
//	float D = D_beckmann( n_dot_h, alpha );
	float D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0

//	float G = G_implicit( n_dot_l, n_dot_v );
	float G = G_neumann( n_dot_l, n_dot_v );
//	float G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );

//	float F = F_none( n_dot_v, F0 );
	float F = F_schlick( n_dot_v, F0 );

	return  ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;
}

// Function 461
float lightPath(in vec2 uv){    
    return step(.965,Hsh(floor(uv.x*10.)))+step(.965,Hsh(floor(uv.y*10.)));
}

// Function 462
float castShadow(vec3 ro, vec3 rd){
	float res = 1.0;
    float t = 0.001;
    for(int i = 0;i < 100;i++){
    	vec3 pos = ro+rd*t;
        float h = map(pos).x;
        res = min(16.*h/t,res);
        if(res<0.001) break;
        t+=h;
        if(t>20.0) break;
    
    }
    return clamp(res,0.0,1.);

	}

// Function 463
vec3 ShadePoint (vec3 cameraPos, vec3 rayDir, vec3 shadePoint, vec3 normal, vec3 emissive, vec3 diffuse, float specularPower, vec3 directionalLightReverseDir)
{
    // start with emissive and ambient light
    vec3 pixelColor = emissive + diffuse * lightAmbient;
    
    // add in the directional light box light
    vec3 lightDiff, lightSpec;
    LightBoxLight(cameraPos, shadePoint, normal, directionalLightReverseDir, rayDir, specularPower, lightDiff, lightSpec);
    pixelColor += lightDiff * diffuse + lightSpec;
    
    // add in a camera local flickering yellow point light
    if (GetMode() >= 6.0)
    {
    	TorchLight(cameraPos, shadePoint, normal, rayDir, specularPower, lightDiff, lightSpec);
    	pixelColor += lightDiff * diffuse + lightSpec;
    }
    
    return clamp(pixelColor, 0.0, 1.0);    
}

// Function 464
float shadowTrace(vec2 o, vec2 r){
    
    // Raymarching.
    float d, t = 0.;
    
    
    // 96 iterations here: If speed and complilation time is a concern, choose the smallest 
    // number you can get away with. Apparently, swapping the zero for min(0, frame) can
    // force the compliler to not unroll the loop, so that can help sometimes too.
    for(int i=0; i<16;i++){
        
        // Surface distance.
        d = map(o + r*t);
        
        // In most cases, the "abs" call can reduce artifacts by forcing the ray to
        // close in on the surface by the set distance from either side.
        if(d<0. || t>FAR) break;
        
        
        // No ray shortening is needed here, and in an ideal world, you'd never need it, but 
        // sometimes, something like "t += d*.7" will be the only easy way to reduce artifacts.
        t += d*RSF_SHAD;
    }
    
    t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.
    
    return t;
    
}

// Function 465
float lightfield(vec2 uv, vec3 dir) {
    float ft_0 = uv.x, ft_1 = -uv.y, ft_2 = -dir.y, ft_3 = dir.x, ft_4 = dir.z;
//16x16 model, loss ~= .005
vec4 f0_0=sin(ft_0*vec4(-.55,-1.20,.05,-.09)+ft_1*vec4(.92,.04,.75,.37)+ft_2*vec4(-.36,-.25,-.32,.44)+ft_3*vec4(-.07,-.03,-.40,.18)+ft_4*vec4(-.27,-.51,.71,.33)+vec4(.91,.64,-.60,.57));
vec4 f0_1=sin(ft_0*vec4(-.12,-.47,.65,.80)+ft_1*vec4(-1.25,-.54,-.77,.48)+ft_2*vec4(-1.73,-.91,.50,-.55)+ft_3*vec4(.06,-1.21,.21,-.17)+ft_4*vec4(-.37,.46,-.99,-1.21)+vec4(.03,-.11,1.09,-1.36));
vec4 f0_2=sin(ft_0*vec4(-.98,-1.18,-.32,-.67)+ft_1*vec4(-.69,.14,.67,-.42)+ft_2*vec4(.22,.06,.98,-.65)+ft_3*vec4(.36,-.85,-.59,-.84)+ft_4*vec4(-1.09,.96,-1.54,-1.69)+vec4(1.09,-.32,.06,-2.58));
vec4 f0_3=sin(ft_0*vec4(.15,.20,-.82,-.55)+ft_1*vec4(.36,.12,.34,.43)+ft_2*vec4(.44,-.12,.37,.35)+ft_3*vec4(.04,.17,-1.23,-.31)+ft_4*vec4(-.43,-.19,.01,-.53)+vec4(.79,.04,-.67,.01));
vec4 f1_0=sin(mat4(-.36,.52,.16,.12,.48,.70,.29,-.10,-.09,.31,.07,.24,-.22,.04,-.25,.03)*f0_0+
    mat4(.25,-.58,.12,.17,-.49,-.17,-.80,.42,-.30,-.80,-.68,.36,.18,.41,-.13,-.02)*f0_1+
    mat4(.29,.05,.11,-.16,-.03,.68,-.19,.68,.33,.95,.24,-.68,-.21,-.03,-.09,-.11)*f0_2+
    mat4(-.12,-.17,-.30,.13,-.03,-.05,-.06,.40,-.19,.65,-.27,-.44,.12,.17,.45,.16)*f0_3+
    vec4(-.04,-.15,-.35,.60))/1.0+f0_0;
vec4 f1_1=sin(mat4(-.02,-.08,.11,.68,.36,.29,.24,-.64,-.19,-.53,.53,-.52,.47,.01,-.22,.38)*f0_0+
    mat4(-.39,.72,-.97,-.55,-.06,.97,-.80,-.15,.21,.41,-.80,.17,-.55,.51,-.20,-.67)*f0_1+
    mat4(.19,.82,-.29,-.18,-.07,.11,-.01,.04,-.11,-.08,.73,-.23,-.03,-.45,.44,-.13)*f0_2+
    mat4(.67,.08,-.35,.44,-.44,.09,-.29,-.28,-.70,.25,.40,.13,-.31,-.25,.37,.05)*f0_3+
    vec4(1.00,.33,-.58,.23))/1.0+f0_1;
vec4 f1_2=sin(mat4(-.07,.11,.45,-.06,.35,.37,.09,.09,.08,-.01,.19,.22,-.21,-.26,.13,-.11)*f0_0+
    mat4(-.06,-.18,-.61,-.40,.57,-.28,.02,-.17,-.10,-.12,-.24,.21,.52,.44,-.20,-.05)*f0_1+
    mat4(.70,.17,-.22,.22,.66,.31,.09,.52,.36,-.28,.68,-1.35,-.23,.34,-.38,.76)*f0_2+
    mat4(-.08,-.38,.33,.04,-.02,-.06,-.37,-.30,.40,.09,.39,-.05,.15,-.04,-.15,-.09)*f0_3+
    vec4(-.01,-.57,.15,.39))/1.0+f0_2;
vec4 f1_3=sin(mat4(.30,.37,.25,.00,.16,-.04,-.19,.18,-.59,.42,-.17,.39,.28,.49,-.03,-.43)*f0_0+
    mat4(.65,-.59,-.46,.38,.03,-.78,.93,.21,.24,-.50,.23,.33,.23,-.84,-.27,.16)*f0_1+
    mat4(.16,-.69,.19,-.09,.26,.09,.40,-.42,-.51,-.18,-.07,.05,.06,.57,.41,-.29)*f0_2+
    mat4(.18,.42,.01,-.36,-.53,.27,-.38,.50,-.06,-.23,.10,.07,.00,-.11,-.77,.50)*f0_3+
    vec4(.41,.33,.17,-.66))/1.0+f0_3;
vec4 f2_0=sin(mat4(.15,.43,-.90,-.14,.23,-.67,.10,-.06,.13,-.03,.32,.22,-.05,-.31,-.18,-.26)*f1_0+
    mat4(-.46,.06,-.12,.25,-.55,-.17,.06,.19,-.41,.37,.02,-.14,-.91,-.11,-.33,.30)*f1_1+
    mat4(-.81,.30,-.87,-.30,-.03,-.00,-.55,-.04,-.03,.65,-.57,.09,-.01,-.44,.45,-.19)*f1_2+
    mat4(-.18,-.46,-.15,.05,.41,-.13,.11,.33,-.05,-.06,-.21,.53,.08,-.08,.31,-.19)*f1_3+
    vec4(-.08,.04,-.35,-.36))/1.4+f1_0;
vec4 f2_1=sin(mat4(-.01,.06,-.51,.08,.05,.54,-.34,-.29,.17,.31,-.03,-.02,-.29,-.13,.07,-.23)*f1_0+
    mat4(.07,.46,.41,-.41,.04,-.57,-.27,-.11,-.37,-.13,.62,.20,-.23,-.02,-.10,.03)*f1_1+
    mat4(-.38,-.03,.46,-.36,-.22,-.23,-.01,-.35,.21,.40,-.32,.05,-.30,-.30,.16,.34)*f1_2+
    mat4(-.34,-.37,.17,.09,.43,.34,-.20,-.33,-.46,-.45,-1.02,-.27,.37,.27,-.06,-.01)*f1_3+
    vec4(-.16,-.11,.14,.03))/1.4+f1_1;
vec4 f2_2=sin(mat4(.19,.32,-.06,.39,-.35,.42,.52,-.54,.40,.50,-.41,-.10,-.62,-.83,-.35,.30)*f1_0+
    mat4(.07,.02,-.35,-.07,-.16,-.13,-.31,.08,.32,-.23,-.30,.05,-.11,.01,.11,.27)*f1_1+
    mat4(-.25,-.16,-.35,.09,-.17,.60,-.11,-.06,.67,.71,.67,-.18,-.83,-.54,-.77,.84)*f1_2+
    mat4(.07,-.74,-.15,.07,.11,.02,-.72,.07,-.34,.84,-.21,-.61,.29,.57,-.39,-.01)*f1_3+
    vec4(-.23,-.47,-.05,.17))/1.4+f1_2;
vec4 f2_3=sin(mat4(.29,.66,.68,-.76,-.38,-.18,-.45,.67,.34,-.06,-.20,.24,-.62,.08,.46,-.38)*f1_0+
    mat4(-.47,.70,.10,.28,.15,.04,-.02,.02,.43,-.09,-.22,-.24,.10,-.02,-.07,.47)*f1_1+
    mat4(.25,.47,.47,-.17,.31,-.70,-.13,.49,-.56,.01,-.25,-.04,.21,-.68,.03,.52)*f1_2+
    mat4(-.79,.10,.45,-.42,-.32,.26,.46,.25,-.34,-.86,-.28,.57,.64,.10,-.41,.38)*f1_3+
    vec4(-.73,.12,.50,-.41))/1.4+f1_3;
vec4 f3_0=sin(mat4(-.36,.23,-.01,-.71,-1.10,.31,.39,-.11,.10,-.34,.01,.02,.08,.07,-.38,.06)*f2_0+
    mat4(-.65,-.41,.58,-.07,.55,-.62,.22,.35,.19,-.59,.28,.15,.07,-.42,.19,.09)*f2_1+
    mat4(-.42,.27,.61,-.29,-.11,.45,-.23,-.09,-.34,.56,.00,-.70,.24,-.44,-.52,.64)*f2_2+
    mat4(.42,-.19,-.66,-.38,.17,.40,-.39,-.24,-.44,.75,-.36,-.13,-.27,-.06,.34,-.29)*f2_3+
    vec4(.56,.04,-.10,-.09))/1.7+f2_0;
vec4 f3_1=sin(mat4(-.19,-.16,.29,-.25,-.35,-.88,-.36,.17,-.36,.12,.08,-.08,-.08,-.00,.34,-.38)*f2_0+
    mat4(.40,-.35,-.07,.04,-.06,.65,-.11,.01,-.05,.17,-.27,.20,-.31,.42,-.42,.86)*f2_1+
    mat4(.50,.17,.02,.83,-.45,.19,.08,.17,-.65,.01,-.55,.27,-.53,-.44,.78,-1.16)*f2_2+
    mat4(-.32,-.05,-.33,.34,.10,-.07,.81,-.30,-.68,-.16,.84,-.17,.12,-.08,-.62,-.19)*f2_3+
    vec4(-.28,-.01,-.09,-.19))/1.7+f2_1;
vec4 f3_2=sin(mat4(-.30,-.17,.08,.22,-.17,-.06,.43,.48,-.73,-.07,.65,-.13,.22,.31,-.35,-.09)*f2_0+
    mat4(.35,-.14,-.01,.20,.38,.05,-.55,-.19,-.33,-.03,-.38,-.23,-.16,-.27,-.12,-.33)*f2_1+
    mat4(.72,.56,-.09,.46,.04,.59,-.09,.41,-.20,-.13,.43,.38,-.50,-.35,-.51,-.50)*f2_2+
    mat4(-.12,.01,-.24,.01,-.07,.57,.10,.24,.02,.59,-.36,-.35,-.07,-.32,.78,.38)*f2_3+
    vec4(-.18,.09,-.44,-.10))/1.7+f2_2;
vec4 f3_3=sin(mat4(.70,-.25,.21,-.81,-.04,.11,-.42,-.06,.08,-.38,-.47,-.11,-.18,.71,.19,-.34)*f2_0+
    mat4(.02,.54,-.11,.35,.33,.75,.19,.34,.44,.51,-.12,.65,.40,-.05,.40,-.01)*f2_1+
    mat4(.25,.19,-.34,.23,-.31,-.45,.24,-.42,-.66,-.58,-.34,.30,.15,-.30,.47,-.30)*f2_2+
    mat4(.20,-.21,.34,-.36,-.78,-.24,.04,-.58,-.22,.42,.16,.07,-.23,-.27,-.62,.13)*f2_3+
    vec4(.13,-.05,.36,-.12))/1.7+f2_3;
vec4 f4_0=sin(mat4(.11,-.54,.35,.44,.16,-.15,.23,-.39,.33,.33,-.30,-.03,-.18,-.32,.09,-.01)*f3_0+
    mat4(-.52,-.36,.55,.32,-.18,.09,-.44,.10,-.19,.01,-.18,.10,.55,-.33,.54,-.33)*f3_1+
    mat4(-.76,-.32,.54,-.57,-.79,-.69,.62,.57,.26,-.13,.26,-.47,.84,.23,-.54,.00)*f3_2+
    mat4(.06,-.25,-.14,-.05,-.08,.32,.12,.09,-.50,.40,.97,-.08,.02,.23,.33,.01)*f3_3+
    vec4(-.49,-.19,-.26,-.09))/2.0+f3_0;
vec4 f4_1=sin(mat4(-.08,-.07,-.01,-.51,.05,-.28,-.15,-.23,-.28,.23,.02,.58,.07,.05,.09,-.24)*f3_0+
    mat4(.95,.56,.01,.12,.15,.43,.12,-.33,-.05,.97,.64,-.48,-.38,-.60,.08,.11)*f3_1+
    mat4(.02,.08,.36,-.43,.03,.00,-.20,-.37,-.36,-.76,-.10,-.04,-.16,-.38,-.44,.25)*f3_2+
    mat4(-.45,.11,.64,-.23,-.31,.20,-.67,-.20,.39,-.07,-.23,-.76,-.15,-.06,-.34,.32)*f3_3+
    vec4(-.32,.00,.33,-.12))/2.0+f3_1;
vec4 f4_2=sin(mat4(.21,.49,.81,.23,-.10,-.06,-.60,-.45,.34,-.06,-.45,-.53,-.32,.19,.08,.34)*f3_0+
    mat4(-.30,.45,.41,-.16,.04,-.02,-.30,.47,-.54,.54,.54,-.22,-.13,-.19,-.17,.18)*f3_1+
    mat4(.21,-.26,-.39,.44,-.04,-.34,.09,.57,.55,-.98,.06,.18,-.24,.54,.12,-.54)*f3_2+
    mat4(-.26,.08,.53,-.03,.33,-.30,.08,.71,.67,.18,-.40,.17,.08,-.11,.00,-.60)*f3_3+
    vec4(-.05,.25,.29,.40))/2.0+f3_2;
vec4 f4_3=sin(mat4(.06,-.01,.07,-.02,-.48,.33,.65,.38,-.40,-.02,-.05,.15,.82,.16,.32,-.20)*f3_0+
    mat4(.23,.08,.10,.10,.06,.06,.30,-.25,-.09,-.36,-.11,.40,-.02,-.35,.27,.28)*f3_1+
    mat4(.05,.95,.35,.03,.31,.03,.22,-.70,-.56,.54,-.03,.26,.23,-.69,-.01,-.18)*f3_2+
    mat4(.23,.09,-.36,.06,.29,-.01,-.42,-.06,-.40,.19,-.15,.15,-.21,.01,-.07,.07)*f3_3+
    vec4(.41,-.21,.05,-.09))/2.0+f3_3;
vec4 f5_0=sin(mat4(1.11,-.61,.22,.34,-.33,-.13,.67,.73,.29,-.56,.00,.10,-.15,-.20,-.70,.13)*f4_0+
    mat4(-.47,.19,-.06,.05,.33,-.21,-.61,-.58,-.09,.06,-.80,-.86,-.51,.12,-.47,-.45)*f4_1+
    mat4(-.70,.08,-.31,-.05,.32,.33,.03,-.15,.14,-.40,.72,.35,-.27,.17,-.55,.06)*f4_2+
    mat4(.20,.20,-.03,.03,.19,.79,.28,-.47,-.08,1.10,-.23,-.89,.05,.23,.07,.20)*f4_3+
    vec4(.23,-.13,-.09,-.34))/2.2+f4_0;
vec4 f5_1=sin(mat4(-.10,-.42,.15,1.20,-.66,.38,-.25,-.02,-.13,.24,-.37,-.27,.04,.28,.10,-.32)*f4_0+
    mat4(.20,.18,.51,.38,.54,.21,-.79,.77,-.16,.14,-.11,-.03,.20,-.35,.40,.16)*f4_1+
    mat4(.63,.64,.46,-.13,.80,.13,.69,.13,.26,-.29,.25,.09,-.53,.21,-.62,.21)*f4_2+
    mat4(.09,.08,.55,.17,.09,-.72,-.68,.14,.02,-.03,.30,-.23,.17,-.20,-.38,.51)*f4_3+
    vec4(-.32,.18,.30,-.94))/2.2+f4_1;
vec4 f5_2=sin(mat4(.26,-.12,-.35,-.22,-.79,-.83,.27,.52,-.28,-.41,-.27,-.06,.18,.19,.24,.17)*f4_0+
    mat4(.15,-.03,.30,.55,.31,-.27,.20,-.03,-.05,-.52,.09,.21,-.37,-.55,.20,-.06)*f4_1+
    mat4(-.91,-.14,-.29,.11,.07,.05,-.24,-.45,-.36,-.01,-.06,-.73,.49,.44,.63,.02)*f4_2+
    mat4(-.08,-.01,.24,-.23,-.01,.03,-.38,.27,.48,-.27,-.20,.02,-.66,.09,-.14,-.28)*f4_3+
    vec4(-.02,-.17,.30,.31))/2.2+f4_2;
vec4 f5_3=sin(mat4(.12,-.50,.09,-.11,.46,.14,-.01,.09,.20,-.19,.32,.23,.17,-.02,-.33,.40)*f4_0+
    mat4(.18,-.17,.48,.91,.29,.45,-.01,.04,-.25,.08,-.40,.37,.18,-.74,-.15,-.31)*f4_1+
    mat4(.27,-.11,-.26,1.06,-.16,-.15,.72,-.29,.32,-.39,-.12,-.60,.30,.64,.23,-.10)*f4_2+
    mat4(-.39,-.31,-.56,-.39,-.15,-.51,-.51,-.12,.02,-.03,-.38,.17,.04,-.41,-.13,-.37)*f4_3+
    vec4(.55,-.40,-.04,.41))/2.2+f4_3;
vec4 f6_0=sin(mat4(.91,.19,.22,.24,-.06,.13,-.64,.02,.41,.26,-.54,-.05,.43,-.28,.50,.38)*f5_0+
    mat4(-.50,.31,-.26,.03,.49,.20,.69,.13,-.54,.14,.35,.14,.93,.29,.06,.38)*f5_1+
    mat4(.18,.11,-.36,-.22,-.47,-.34,-.13,-.49,-.30,.70,-.05,-.48,.14,-.28,-.29,.66)*f5_2+
    mat4(-.13,-.46,.02,-.14,.23,.19,-.21,-.20,-.28,-.42,.43,-.82,-.01,-.04,-.95,-.51)*f5_3+
    vec4(-.43,-.08,.95,.38))/2.4+f5_0;
vec4 f6_1=sin(mat4(-.48,.46,.22,.61,.65,.47,.02,-.03,.05,.23,-.03,-.08,.12,-.34,-.18,-.22)*f5_0+
    mat4(-.74,.02,.21,.04,-.28,-1.07,-.08,.44,.29,-.46,.51,.45,-1.18,.26,-.15,-.71)*f5_1+
    mat4(-.14,.16,.26,.48,-.55,-.10,-.88,-.01,-.86,.33,.03,-.67,.14,-.06,-.41,-.11)*f5_2+
    mat4(.55,-.21,-.02,-.10,.01,-.20,-.22,-.46,-.12,.50,-.23,-.39,-.04,.58,.23,.41)*f5_3+
    vec4(-.31,.05,.22,-.39))/2.4+f5_1;
vec4 f6_2=sin(mat4(-.43,.66,-.67,.27,.83,-.03,.70,-.09,-.53,-.08,.17,.06,.06,-.02,-.23,.03)*f5_0+
    mat4(-.36,.04,-.02,.08,.00,.28,-.02,-.13,-.04,-.33,.31,-.31,-.52,-.18,.27,-.10)*f5_1+
    mat4(.24,-.28,-.04,-.42,-.27,.59,-.42,-.05,.28,-.00,-.27,-1.04,-.50,.23,-.17,-.16)*f5_2+
    mat4(-.36,.07,-.67,.51,.31,.05,-.45,.75,-.15,-.62,.22,-.10,.19,-.17,.19,-.18)*f5_3+
    vec4(-.28,.12,-.56,-.02))/2.4+f5_2;
vec4 f6_3=sin(mat4(.06,.08,-.84,.31,.68,.59,-.66,.23,-.07,.24,.17,.61,-.02,.02,-.13,-.12)*f5_0+
    mat4(-.12,.64,-.67,.64,-.02,.43,-.47,.57,.25,.29,.04,-.15,1.01,.07,-.02,.02)*f5_1+
    mat4(.21,.50,-.59,-.06,-.42,-.25,-.17,1.24,.20,.05,.01,.30,-.00,-.24,.79,-.68)*f5_2+
    mat4(.26,.06,.50,.18,-.13,.66,.03,.21,-.32,-.33,.13,-.40,-.09,-.08,.02,.22)*f5_3+
    vec4(.00,.31,.33,-.23))/2.4+f5_3;
vec4 f7_0=sin(mat4(-.37,-.66,-.51,-.45,-.48,-.69,-.89,.39,-.37,.00,1.10,.10,-.50,.50,-.44,-.28)*f6_0+
    mat4(-.59,-.05,-.58,-.13,.41,.45,.10,-.07,.51,.33,-.28,.27,.34,-.61,-.48,.30)*f6_1+
    mat4(.17,.43,-.07,.41,-.05,.28,.69,-1.12,-.33,-.06,-.68,-.11,.30,-.18,-.04,.20)*f6_2+
    mat4(-.09,-.15,-.17,-.50,-.51,.07,.72,-.17,.01,.38,-.37,-.57,.05,.06,.09,.10)*f6_3+
    vec4(-.09,.15,-1.10,-.63))/2.6+f6_0;
vec4 f7_1=sin(mat4(-.43,.49,.13,-.26,-.76,-.10,-.16,.08,-.07,.19,.30,-.12,.17,-.13,-.04,.49)*f6_0+
    mat4(-.53,-.25,.55,-.32,.42,.78,.37,-.42,-.22,.09,.80,.08,-.19,-.05,-.13,-.62)*f6_1+
    mat4(-.54,-.00,-.06,-.04,.61,-.16,.02,.12,.31,.11,.14,-.42,.38,.25,-.19,.72)*f6_2+
    mat4(.24,-.08,.27,.16,.40,.52,-.61,.48,.29,-.68,.43,-.63,-.88,.10,-.03,.17)*f6_3+
    vec4(-.05,-.16,.06,.14))/2.6+f6_1;
vec4 f7_2=sin(mat4(-.02,.53,.23,-.22,.66,-.55,-.42,.20,.25,-.08,.24,.11,.36,.11,-.22,-.20)*f6_0+
    mat4(.44,.37,.08,.06,-.31,.16,.67,-.93,.42,1.11,.25,.54,-.42,-.21,-.13,1.55)*f6_1+
    mat4(.77,-.30,.35,-.21,.14,-.76,.78,-.62,-.38,-.64,-.25,.74,-.52,.52,-.29,.77)*f6_2+
    mat4(.02,.42,-.06,-.33,.19,-.56,.20,-.71,.42,.27,-.59,-.21,-.05,-.27,.60,.06)*f6_3+
    vec4(.22,.17,-.03,.22))/2.6+f6_2;
vec4 f7_3=sin(mat4(.28,-.37,.43,-.07,.22,.38,.24,.06,-.90,-.22,-.30,.51,.22,-.16,-.33,.11)*f6_0+
    mat4(-.18,.48,-.04,.62,.43,.25,.20,.07,-.22,-.44,.08,-.20,.02,.31,-.50,-1.33)*f6_1+
    mat4(-.09,.42,.16,.29,.51,.17,.24,-.54,-.11,-.25,.17,-.63,-.47,-.13,-.50,-.68)*f6_2+
    mat4(.70,-.23,.10,-.02,-.27,.19,-.67,-.47,.31,.36,1.01,-.52,-.30,-.17,.31,.18)*f6_3+
    vec4(.34,.18,.43,.51))/2.6+f6_3;
vec4 f8_0=sin(mat4(.26,-.68,-.25,.00,-.60,.40,-.74,.33,.04,.58,.54,.44,-.36,-.74,-.09,.25)*f7_0+
    mat4(.48,.41,.64,-.73,-.17,.00,-.07,.76,-.04,.75,.11,-.13,-.06,.36,-.23,-.14)*f7_1+
    mat4(-.43,.52,.12,-.32,.24,-.91,-.38,.41,.52,-.85,-1.03,.25,-.41,-.14,.10,.25)*f7_2+
    mat4(.05,-.70,-.04,-.30,.38,-.57,.22,.41,.87,.19,.19,-.11,-.29,.14,-.18,-.88)*f7_3+
    vec4(.11,-.88,-.62,-.02))/2.8+f7_0;
vec4 f8_1=sin(mat4(.47,-.56,.04,-.72,-.03,1.04,-.29,.08,.11,.70,.34,-.34,.14,-.03,-.30,-.29)*f7_0+
    mat4(.45,.59,.68,-.56,.21,.19,-.21,.52,.51,-.51,.50,-.43,.79,-.14,-.14,-.44)*f7_1+
    mat4(.79,.50,.09,.09,-.28,.12,-.24,.58,.21,-.01,.38,-.29,.02,-.55,.01,.06)*f7_2+
    mat4(.27,-.66,-.10,.27,-.04,.14,-.10,-.24,.88,-.07,-.68,.31,-.07,.50,-.02,-.25)*f7_3+
    vec4(-.45,-.24,-.51,.55))/2.8+f7_1;
vec4 f8_2=sin(mat4(-.06,-.31,-.13,1.04,.29,-.15,-.42,-.21,-.20,-.10,-.42,.59,-.16,-.22,-.34,.09)*f7_0+
    mat4(.66,.35,-.08,-.77,-.21,.33,.12,-.40,-.02,-.42,.07,-.30,-.34,-.23,.08,-.69)*f7_1+
    mat4(.59,-.09,-.34,-.40,-.80,.86,.68,-.06,.21,.72,-.05,.59,.31,-.18,-.18,.74)*f7_2+
    mat4(-.12,-.41,.02,.01,.22,.07,.00,-.22,-.14,-.53,-.14,-.12,-.11,.36,-.12,-.02)*f7_3+
    vec4(.27,.43,.06,.28))/2.8+f7_2;
vec4 f8_3=sin(mat4(-.12,.49,-.26,-.37,.01,-.04,.52,.41,-.62,.41,-.76,.59,.35,.22,-.29,.26)*f7_0+
    mat4(.86,-.81,.45,-.15,.89,1.27,-.32,-.01,.46,.19,.18,-.10,.36,.05,-.35,-.02)*f7_1+
    mat4(.40,-.37,.38,.47,-.12,.69,-.11,.51,-.58,-.17,.17,-.01,-.52,.33,-.15,-.25)*f7_2+
    mat4(-.64,.05,.01,-.15,-.28,.19,.05,-.08,-.46,.12,.10,-.52,.00,-.11,.11,.75)*f7_3+
    vec4(-.86,.11,-.12,-.15))/2.8+f7_3;
vec4 f9_0=sin(mat4(.36,.39,.02,.45,-.12,.28,.32,-.18,.20,.39,-.39,-.28,.04,.16,1.02,.28)*f8_0+
    mat4(.11,-.51,.59,.15,-.13,-.83,.64,.26,-.07,.15,.77,-.30,-.24,-.29,-.35,.29)*f8_1+
    mat4(.84,-.30,-.20,-.58,.76,-1.26,-.06,.45,-.16,-.82,-.45,.10,-.40,-.05,.19,.19)*f8_2+
    mat4(1.14,.95,.28,.10,.17,-.11,-.23,-.01,.27,-.14,-.57,-.66,.46,-.39,.10,-.12)*f8_3+
    vec4(-.74,.14,-.35,-.08))/3.0+f8_0;
vec4 f9_1=sin(mat4(-.01,-1.18,-.30,-.56,.12,.76,-.23,-.82,.01,.57,-.28,-.38,.90,-.23,-.57,.14)*f8_0+
    mat4(-.99,.12,.22,.01,-.17,.09,-.63,.10,-.08,-.26,.65,.04,-.14,-.29,-.17,-.31)*f8_1+
    mat4(.13,.55,.57,-.64,-.22,.28,-.45,-.40,-.86,-.17,-.59,-.08,-.07,-.42,-.34,.24)*f8_2+
    mat4(.66,-1.20,-.27,-.14,-.39,.54,.12,-.39,-.33,.76,-.18,.92,-.06,.66,-.10,-.73)*f8_3+
    vec4(-.41,.22,.74,-.20))/3.0+f8_1;
vec4 f9_2=sin(mat4(.04,.05,-.19,-.19,.95,.41,.33,-.40,.49,.09,-.12,-.25,.43,.50,.61,-.50)*f8_0+
    mat4(-.38,-.09,-.21,-.17,-.34,.27,-.35,-.37,-.31,-.29,-.43,.46,-.58,.04,-.01,.52)*f8_1+
    mat4(.52,.08,-.47,-.50,-.82,-.06,.30,-.02,.12,.69,-.08,.36,-.01,.09,.01,.17)*f8_2+
    mat4(.38,.10,-.22,.08,-.21,-.96,.15,.31,-.97,-.18,.00,-.50,.49,-.16,.11,-.03)*f8_3+
    vec4(.11,-.64,.07,.36))/3.0+f8_2;
vec4 f9_3=sin(mat4(-.10,.08,-.12,.23,-.28,-.54,.77,.45,-.69,-.08,-.33,-.10,.58,.09,-.09,.57)*f8_0+
    mat4(-.51,.10,.58,-.21,-.01,-.00,-.65,-.66,.47,.07,-.08,.08,-.06,.54,-.06,-.11)*f8_1+
    mat4(-.10,.05,.23,.08,-.00,-.33,.04,-.27,-1.06,.12,.50,.67,.13,-.63,.21,-.48)*f8_2+
    mat4(.29,-.01,.08,.51,.28,-.04,.08,.19,.54,1.03,1.11,.53,-.47,.12,-.20,-.01)*f8_3+
    vec4(-.14,.31,-.03,.71))/3.0+f8_3;
vec4 f10_0=sin(mat4(.69,-.20,.39,-.09,.31,-.12,-.68,.09,-.20,.67,.25,-.27,.35,-.91,-.54,.41)*f9_0+
    mat4(.39,.30,-.67,.01,-.42,-.35,.23,.32,.53,.36,.68,-.26,.69,.59,-.21,.71)*f9_1+
    mat4(.08,.56,.11,-.16,-.25,.13,.28,.21,1.14,-.37,-.92,.59,.13,-.61,-.29,.50)*f9_2+
    mat4(.69,-.24,.16,-.59,-.07,.06,.65,-.49,-.28,.13,.50,-.07,.39,.34,-.29,.01)*f9_3+
    vec4(1.01,-.37,-.40,.04))/3.2+f9_0;
vec4 f10_1=sin(mat4(.38,-.63,-.21,-.71,-.32,.25,.52,-.64,.06,.06,-.52,-.38,-.56,.27,.62,.08)*f9_0+
    mat4(-1.38,-.34,-.77,-.21,-.36,.72,.11,-.05,-.19,-.29,-.91,-.61,-.81,.65,.21,1.33)*f9_1+
    mat4(-.41,-.03,-.18,.48,-.55,.72,.55,.65,-.56,-.01,.26,.56,-.28,.57,.17,.28)*f9_2+
    mat4(-.27,-.20,.36,.06,-.35,.06,.29,-.07,-.21,-.08,-.03,.38,-.01,.16,-.20,.29)*f9_3+
    vec4(-.68,.13,.33,.07))/3.2+f9_1;
vec4 f10_2=sin(mat4(.45,-.22,-.75,-.32,.19,-.68,-.52,-.18,-.21,-.27,-.16,-.08,.08,.33,-.25,.79)*f9_0+
    mat4(-.41,-.09,-.30,-.38,.68,.34,.87,.55,.18,-.01,-.12,.02,.21,-.75,.08,-.16)*f9_1+
    mat4(.28,-.63,-.61,.67,-.01,-.03,.29,.42,-.60,.07,-.07,.96,.02,.22,.54,.50)*f9_2+
    mat4(.21,.23,-.44,-.70,.08,.25,-.09,-.16,-.95,-.52,.08,-.19,-.63,-.23,-.27,.15)*f9_3+
    vec4(-.63,.30,.08,.30))/3.2+f9_2;
vec4 f10_3=sin(mat4(-.50,.43,-.03,.02,.09,.88,.24,-.14,.10,.15,-.55,-.95,.34,.47,.40,-.65)*f9_0+
    mat4(-.39,.00,-.23,-.59,.51,.36,.50,-.28,.29,.09,.77,-.20,.09,.32,.10,.35)*f9_1+
    mat4(.96,-.00,.19,-.15,.18,-.07,.07,.26,-.08,.39,-.25,-1.21,.15,.20,.20,-.24)*f9_2+
    mat4(.44,.02,-.13,.33,-.66,.13,-.17,.07,.02,-.00,-.85,-.39,-.22,-.30,-.35,-.31)*f9_3+
    vec4(.63,.23,-.01,-.14))/3.2+f9_3;
vec4 f11_0=sin(mat4(-.44,-.11,.65,.49,.12,.11,-.99,-.40,-.36,.24,.10,-.02,.24,.39,-.28,.48)*f10_0+
    mat4(-.78,-.86,-.48,.71,.55,.17,.18,-.27,-1.12,.02,.02,.47,.03,.23,-.40,.42)*f10_1+
    mat4(.22,-.57,-.35,-.01,.77,-.15,-.53,-.03,.27,.47,-1.41,.19,.26,.78,-.06,.31)*f10_2+
    mat4(-.55,-.51,-.21,.17,.14,-.23,.42,-.21,-1.14,.56,.68,-.30,.57,-.25,-.07,.00)*f10_3+
    vec4(.81,-.67,-.64,.64))/3.3+f10_0;
vec4 f11_1=sin(mat4(-.28,-.10,-.28,.64,-.21,.30,-.76,-.79,.64,.17,-.21,-.85,.62,-.12,-.34,-.21)*f10_0+
    mat4(.96,.09,-.41,-.58,-.44,.54,-.20,.57,.44,-.03,.74,-.78,.72,.35,-.81,.01)*f10_1+
    mat4(.68,-.01,-.04,-.29,-.31,.57,-.48,-.16,-.25,-.32,-.67,-.41,.31,.29,-.04,.16)*f10_2+
    mat4(.10,-.42,.54,-.39,.02,.14,-.25,.29,.57,.66,.73,.37,-.14,-.54,.39,.11)*f10_3+
    vec4(.40,-.39,.13,.72))/3.3+f10_1;
vec4 f11_2=sin(mat4(.07,.82,.58,-.12,.23,.61,-.49,-.62,.80,-.37,-.16,.36,-.12,-.15,-.58,-.35)*f10_0+
    mat4(-.25,-.45,.82,-.63,-.14,.01,.23,.63,.38,.03,1.44,-.38,-.40,-.26,-.03,-.60)*f10_1+
    mat4(-.37,.55,.40,.14,-.26,.09,.12,.08,.45,.45,-.31,-.35,-.16,-.07,-.48,-.18)*f10_2+
    mat4(.19,-.02,.19,-.28,-.80,-.13,-.01,.06,.10,-.68,.77,-.26,-.52,.04,-.47,-.92)*f10_3+
    vec4(-.12,.05,.52,-.18))/3.3+f10_2;
vec4 f11_3=sin(mat4(-.04,-.14,-.29,1.05,1.14,.17,-.90,-.37,.08,.14,.00,-1.12,.39,-.03,.18,-.59)*f10_0+
    mat4(-.18,.09,-.17,.14,.01,-.50,-.26,.02,-.28,-.22,-.19,-.32,-.49,.13,-.33,-.35)*f10_1+
    mat4(-.84,.10,.52,-.45,-1.20,-.99,.12,.64,.35,-.39,-.72,1.21,.21,.87,-.00,.10)*f10_2+
    mat4(-.13,-.48,-.29,.42,-.13,-.35,.61,.01,-.42,.80,.71,-.34,-.55,-.12,-.16,-.19)*f10_3+
    vec4(-.57,-.54,.29,-1.00))/3.3+f10_3;
vec4 f12_0=sin(mat4(-.14,.04,-.44,.37,.50,.79,-.53,1.42,-.60,-.79,-.65,-.91,.45,.34,-.48,.41)*f11_0+
    mat4(-.04,-1.42,-.45,.16,-.15,.40,.34,.52,-1.07,-1.24,-.10,-.06,.40,-.14,-.48,-.03)*f11_1+
    mat4(-.01,-.78,-.45,.21,.42,.36,-.22,.27,.61,-.07,-1.83,.62,.10,.03,-.57,-.30)*f11_2+
    mat4(-.39,.09,-.72,.32,-1.16,.01,.28,-.79,-1.18,-.68,.02,-1.33,.13,.62,-.28,-.35)*f11_3+
    vec4(.47,-.01,-.52,-.52))/3.5+f11_0;
vec4 f12_1=sin(mat4(-.36,-.81,.18,-.40,.26,-.55,.34,.39,-1.08,.26,.47,-.66,-.11,-.89,.03,.30)*f11_0+
    mat4(.49,.24,.03,-.08,-.49,-.85,-.51,.74,-.41,-.01,.87,-.76,.64,.50,-1.40,1.03)*f11_1+
    mat4(-.71,-.13,-.30,-.03,.32,-.29,-.19,-.21,.94,.38,-1.06,.04,.30,.19,-.44,-.14)*f11_2+
    mat4(.09,.21,.19,-.55,.53,-.08,.05,.79,-.01,.23,.56,-.14,.15,.31,-.07,-.20)*f11_3+
    vec4(-.48,.37,-.13,-.56))/3.5+f11_1;
vec4 f12_2=sin(mat4(-.44,-.69,.19,-.04,-.89,-.31,.42,-.09,-.26,1.37,.29,-.14,-.04,-.03,.14,.44)*f11_0+
    mat4(.33,-.58,-.86,-.60,-.20,1.14,-.38,.53,-.39,.25,-.00,-.40,.25,-.03,-1.02,.48)*f11_1+
    mat4(-.26,-.15,-.05,.54,.28,-.43,-.36,.01,-.58,-.42,.11,.38,-.47,.17,.19,.82)*f11_2+
    mat4(.85,-1.45,.88,-.69,.50,-.21,.40,-.29,-.24,.24,-1.26,-.27,-.21,-.96,-.08,-.22)*f11_3+
    vec4(-.67,-.51,1.08,.16))/3.5+f11_2;
vec4 f12_3=sin(mat4(.33,.00,-.24,.45,.56,-.07,-1.15,-.03,-.53,.09,.03,.21,.62,.21,.22,.81)*f11_0+
    mat4(-.21,.87,-.04,.07,.60,-.08,-.12,.01,-1.16,.38,-.33,.65,.52,.08,.46,.28)*f11_1+
    mat4(.17,.24,.47,.11,.12,.53,-.43,.16,.10,.10,-.33,.40,-.35,-.11,-.18,.37)*f11_2+
    mat4(-.39,-.08,.36,-.35,-.25,.04,-.12,-.44,.18,.94,.61,-.23,-.02,.43,.20,.85)*f11_3+
    vec4(.20,-.18,1.27,-.00))/3.5+f11_3;
vec4 f13_0=sin(mat4(.25,-.39,-.23,-.27,-1.42,.60,-.04,-.18,-.55,.76,.69,.19,-.64,.56,.45,-.82)*f12_0+
    mat4(-.14,-.20,.24,.06,.16,.29,.60,-.39,.02,.04,.00,.79,.03,.01,.13,-.74)*f12_1+
    mat4(.07,.62,-.19,.06,.71,-.38,-.50,.59,-.58,.91,-1.26,-.25,.54,.23,-.10,-.56)*f12_2+
    mat4(.90,-1.18,.01,.24,.26,-.44,-.63,.09,1.20,-.09,-.10,-.34,.12,.26,.01,.37)*f12_3+
    vec4(.20,-.66,-.02,.10))/3.6+f12_0;
vec4 f13_1=sin(mat4(-.84,-.04,.55,.12,-1.54,1.22,.46,.03,.27,-.29,.23,-.79,-1.33,.39,.00,.29)*f12_0+
    mat4(.32,-.51,.69,.44,-.34,.32,1.07,.04,-.03,-.63,.92,.16,-.11,.38,-.28,.76)*f12_1+
    mat4(.18,-.21,-.23,.08,.88,.36,-.89,.86,-.13,.70,-.59,-.14,-.03,.82,-.12,.35)*f12_2+
    mat4(.07,-.49,-.29,.95,1.75,-.47,-1.01,.74,.30,-.82,-.95,1.58,.03,-.29,.24,-.06)*f12_3+
    vec4(1.44,1.21,1.07,-1.80))/3.6+f12_1;
vec4 f13_2=sin(mat4(.68,.48,.84,-.29,-.46,-.91,.36,1.30,.12,-.16,-.79,.18,-.24,-.25,.47,-.61)*f12_0+
    mat4(-.64,-.16,-.39,-.39,.83,-.99,.52,-.09,.08,-.36,-.88,-.05,-.46,.01,-.07,-.36)*f12_1+
    mat4(-.48,.67,-.01,-.06,.59,.17,.21,.18,-.28,-.17,.62,.43,-.07,-.35,-.19,.42)*f12_2+
    mat4(.03,.45,-.18,-.43,.58,.02,-.22,-.26,-.07,-.05,-1.08,-.19,-.53,-.24,-.25,-.04)*f12_3+
    vec4(.12,.14,-.38,-.20))/3.6+f12_2;
vec4 f13_3=sin(mat4(-.10,.41,-.46,-.19,.09,.04,-.26,-.27,-.10,-.47,-.22,.55,.28,.85,-.53,.01)*f12_0+
    mat4(.58,-.51,.73,-.19,.98,.31,.52,-.26,-.87,-.08,-.15,1.02,1.07,.33,-.02,-.49)*f12_1+
    mat4(.01,-.24,-.43,-.20,.46,-.55,-.04,-.21,-.18,.33,-.43,.44,-.15,.29,-.95,.16)*f12_2+
    mat4(-.45,-.47,.67,.49,-.17,-.27,-.14,.06,.23,.41,-.73,-.34,-.61,-.58,.36,.24)*f12_3+
    vec4(-.99,-.07,.42,-.62))/3.6+f12_3;
vec4 f14_0=sin(mat4(-2.19,.92,-.72,-.04,.40,-.38,.25,.49,-.52,-.78,.62,.21,.51,.18,-.27,.46)*f13_0+
    mat4(.32,.13,-.63,.15,-.13,.03,-.19,.21,.19,-1.15,-.04,-.32,-1.58,.30,.71,-.10)*f13_1+
    mat4(.48,-.26,-.11,.50,-.04,.43,-.24,-.90,.22,.28,.51,1.18,-.54,.14,.12,.38)*f13_2+
    mat4(-.09,-.01,-.84,-.75,-.22,.56,.67,-.65,.14,-.10,-.29,-.34,.57,.11,.54,.53)*f13_3+
    vec4(.32,.54,.90,-.19))/3.7+f13_0;
vec4 f14_1=sin(mat4(.47,-.66,1.02,.48,-.75,.61,-.94,1.21,-.92,.09,-.44,-.88,-1.06,.69,-.55,1.00)*f13_0+
    mat4(.50,.85,.65,-.60,.19,.08,.47,.35,.99,.81,-.31,-.27,.90,-.30,-.82,1.41)*f13_1+
    mat4(-.84,.12,-.54,.19,1.09,.31,1.01,-.54,-.96,.32,-.37,.03,-.28,.24,.11,-.02)*f13_2+
    mat4(.42,-.53,-.10,-.23,1.01,.01,1.17,.18,.10,-.93,.01,-.84,.09,-.18,-.14,-.60)*f13_3+
    vec4(.39,.11,-.86,-1.14))/3.7+f13_1;
vec4 f14_2=sin(mat4(.98,-.09,-.13,.14,-.86,-1.45,.46,1.24,-.47,.08,.35,1.01,-.53,-.82,.51,.28)*f13_0+
    mat4(-.83,-.32,.32,-.22,-.06,.20,.63,-.09,.07,.35,.15,-.09,-.58,.44,-.27,.08)*f13_1+
    mat4(-.61,.09,.16,.02,.17,.26,-.62,.38,-.42,-.85,.52,.11,.06,-.67,.48,.74)*f13_2+
    mat4(.43,1.00,-.65,-.06,.30,.83,-.24,-.70,-.88,.27,.01,-.46,-.76,-.02,-.10,.20)*f13_3+
    vec4(.29,-.01,-.82,-.61))/3.7+f13_2;
vec4 f14_3=sin(mat4(.34,-.07,.38,-.12,-.71,-.41,-.88,-.24,-.29,-.24,-.68,-.08,-.72,-.06,-.82,.34)*f13_0+
    mat4(-.19,.49,-.12,.06,-.71,-.45,-.35,-.04,.09,.18,.16,.14,-.52,.08,.54,-.15)*f13_1+
    mat4(-.01,-.22,-.46,.13,.47,.23,-.52,.19,-.81,-.93,-.89,.92,-.16,-.16,-.31,-.61)*f13_2+
    mat4(.68,.75,.65,.33,.46,.45,.37,.11,.66,.30,.92,.76,.47,-.13,-.00,.01)*f13_3+
    vec4(.28,.32,-.55,-1.13))/3.7+f13_3;
vec4 f15_0=sin(mat4(1.11,.20,-.67,-.22,-1.15,-.92,.45,.42,.05,.12,.17,.54,-1.34,-1.11,.75,.60)*f14_0+
    mat4(.05,.22,-.36,.02,.19,.08,-.24,.24,.46,.53,-.50,-.41,-.35,-.78,.31,-.49)*f14_1+
    mat4(-.84,-.25,.52,.93,-.06,.58,.62,-.47,-2.00,-.86,.41,1.00,-1.15,-.64,-.97,.11)*f14_2+
    mat4(.80,.02,-.77,-.67,-.20,.82,-.52,-.47,1.68,.13,-.48,-.74,-.39,.26,-.08,.01)*f14_3+
    vec4(1.16,-.51,.39,-.00))/3.9+f14_0;
vec4 f15_1=sin(mat4(.40,-.60,.34,-.55,-2.65,1.28,-.79,-.34,.28,.50,.08,-.07,-1.38,.65,.13,.23)*f14_0+
    mat4(-.99,.47,.21,-1.39,-1.19,.39,-.16,-.06,.29,-.15,.51,-.39,-.28,-.39,1.36,.33)*f14_1+
    mat4(.03,.09,.02,-.34,.91,-.20,.36,.86,-1.74,.60,.48,-1.79,-1.14,-.10,-1.02,-1.26)*f14_2+
    mat4(.76,-.18,.87,.71,1.29,-.83,1.36,.41,.34,-.90,.77,.17,-.21,-.14,-.41,-.00)*f14_3+
    vec4(.35,-.09,-.52,-.78))/3.9+f14_1;
vec4 f15_2=sin(mat4(-.33,-.20,.05,-.81,1.37,.88,-.72,.65,.35,-.11,-.15,.38,.52,1.32,-1.01,.55)*f14_0+
    mat4(.69,.34,-.13,-.30,.37,.71,-.11,-.87,-.69,.10,-.11,-.08,.16,.43,-.02,-.62)*f14_1+
    mat4(.15,-.00,-.42,.47,-.65,-1.44,.90,-.08,2.03,.54,-1.11,1.30,.36,.41,-.70,-.16)*f14_2+
    mat4(-.16,.06,.22,.52,-1.33,-1.21,.77,.61,-.85,-.86,-.22,.35,.05,-.23,.23,.14)*f14_3+
    vec4(-.46,.30,-.30,.06))/3.9+f14_2;
vec4 f15_3=sin(mat4(.15,-.29,1.10,.05,-.51,.92,-1.15,1.66,-.35,.09,-.88,.61,-.86,.94,-.82,1.71)*f14_0+
    mat4(.98,.80,-.61,.29,-.53,.22,-.67,.01,.38,-.14,.23,.38,.40,.32,.09,-.83)*f14_1+
    mat4(-.16,.56,-.38,.73,.60,-.66,.67,-.98,-.24,1.46,-.77,1.81,-.17,.72,-.24,.63)*f14_2+
    mat4(.40,-.42,.37,-.53,.90,-.48,.06,-.53,.46,-.35,.30,-1.16,-.21,-.52,-.19,-.17)*f14_3+
    vec4(-.17,1.10,-.15,1.08))/3.9+f14_3;
vec4 f16_0=sin(mat4(-.41,.17,-.20,-.07,-.74,-.77,.75,.81,-.21,-.28,.62,.25,-.13,-.67,.75,.72)*f15_0+
    mat4(.44,.09,-.13,-.34,-.07,-.33,.48,.55,.41,.27,-.02,-.12,-.05,.09,.10,-.22)*f15_1+
    mat4(-.04,-.37,.33,.48,.62,.33,-.85,-.70,-.43,-1.03,1.06,.93,-.35,-.23,.16,.26)*f15_2+
    mat4(.66,.70,-.62,-.40,.12,.66,-.84,-.84,.01,.36,-.46,-.57,.34,-.47,.09,.45)*f15_3+
    vec4(-1.03,1.68,.07,-.61))/4.0+f15_0;
vec4 f16_1=sin(mat4(.27,-.29,.24,.24,-.68,1.60,.18,-.02,-.39,.73,-.33,-.01,-.75,1.32,.28,-.21)*f15_0+
    mat4(.06,-.58,-.03,-.41,-.48,.94,-.05,-.57,-.07,-.26,-.25,.88,.03,-.18,-.32,-.21)*f15_1+
    mat4(-.85,.83,.35,.35,.44,-1.03,.23,.06,-.71,1.85,.11,-1.95,-.30,.25,.21,.28)*f15_2+
    mat4(.74,-.96,-.03,.68,.75,-1.54,.05,1.36,.48,-.99,.02,.59,.06,.55,.53,.45)*f15_3+
    vec4(-.38,-.52,.42,-.69))/4.0+f15_1;
vec4 f16_2=sin(mat4(.03,-.02,.37,.26,.95,-1.04,-.88,.41,.38,-.20,-.44,-.07,.61,-.80,-.78,.61)*f15_0+
    mat4(-.37,.19,.03,-.30,.49,-.43,-.38,.45,-.37,.32,.27,-.10,-.20,-.03,-.08,-.42)*f15_1+
    mat4(.28,-.30,-.40,.39,-.59,.98,.31,-.86,1.12,-1.16,-1.17,.57,.10,-.62,-.21,.24)*f15_2+
    mat4(-.49,.83,.83,-.04,-.77,.69,.71,-.52,-.37,.29,.54,-.10,.22,.11,-.61,.44)*f15_3+
    vec4(-.07,.42,1.74,.30))/4.0+f15_2;
vec4 f16_3=sin(mat4(.15,-.04,.22,-.08,-.83,-.60,-.77,.82,-.39,-.08,-.48,.25,-.82,-1.11,-.59,.91)*f15_0+
    mat4(.28,.28,.26,-.52,-.55,-.43,-.31,.42,.06,.18,.08,-.23,.04,.24,.03,.09)*f15_1+
    mat4(-.55,-.43,-.46,.54,.50,.63,.23,-.49,-.91,-.71,-1.04,.99,-.21,-.33,-.30,.12)*f15_2+
    mat4(.69,.49,.56,-.56,.89,.72,.80,-1.15,.48,.22,.56,-.33,.20,-.27,.17,.14)*f15_3+
    vec4(.82,.93,.30,.22))/4.0+f15_3;
float f_0=dot(f16_0,vec4(-.02,.13,.05,.13))+
    dot(f16_1,vec4(-.03,.07,-.03,-.01))+
    dot(f16_2,vec4(.07,-.08,.16,.04))+
    dot(f16_3,vec4(-.10,-.12,-.07,.04))+
    0.527;

return f_0;
}

// Function 466
vec3 light(vec3 origin, vec3 ray){
	vec3 ro = origin;
    vec3 rd = ray;
    vec3 col = vec3(0.);
    float totalDistance = 0.;
    float r = 1.;
    float g = 1.;
    float b = 1.;
    for(float i=0.;i<MAX_REFLECTIONS;i++){
        // march
        vec2 result = march(ro,rd);
        totalDistance += result.x;
    	// lighting conditionals
        float matType = floor(result.y);
        float matVal = fract(result.y);
        // --- //
        float diff = fract(floor(matVal*10.)*.1);
        r *= fract(floor(matVal*100.)*.1)+.1;
        g *= fract(floor(matVal*1000.)*.1)+.1;
        b *= fract(floor(matVal*10000.)*.1)+.1;
        // --- //
        if(matType==MAT_BG){col+=vec3(scalesin((ro+rd*result.x).y*.1,0.35,0.45),0.4,0.4)*125.;break;}
        if(matType==MAT_LT){col+=vec3(1.,1.,1.)*220.;break;}
        // new origin and direction
        ro=ro+rd*(result.x-0.02); // we have to sub some length so we don't hit immediately after re-casting
        rd=gradient(ro);
        // randomize gradient
        vec3 up = normalize(cross(rd,vec3(0.,1.,0.)));
        vec3 right = normalize(cross(rd,up));
        up = normalize(cross(rd,right));
        vec2 rand = rand32(ro)*2.-1.;
        rand *= diff;
        rd = normalize(rd + up*rand.y + right*rand.x);
    }
    return col*vec3(r,g,b)/pow(totalDistance,1.1);
}

// Function 467
vec3 lighting(const Ray ray, const RaycastHit hit) {
 
    float diffuse = ambientLight;
    vec3 l1 = light1 - hit.point;
    
    const int n = 30;
    int h = 0;
    
    for(int s = 0; s < n; s++) {
    
        vec3 s1 = (light1 + noise(vec4(hit.point.xyz,iTime + float(s)))) - hit.point;
    
    	Ray shadow;
    	shadow.origin = hit.point + (s1 * 0.0001);
    	shadow.direction = s1;
    
    	RaycastHit scene = raycastScene(shadow);
        
    	if(scene.type < 0) {
     
        	h++;
      
    	}
        
    }
        
    diffuse += max(dot(normalize(hit.normal),normalize(l1)),0.) * float(h) / float(n);
    return vec3(diffuse);
    //return vec3(scene.type + 1);
    
}

// Function 468
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<16; i++)
    {
    	float h = map(ro + rd*t);
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 469
float GDotLightCone()
{
	return cos(atan(RLightCone()));
}

// Function 470
float GetLight(vec3 p)
{
    vec3 pos = vec3(5.*sin(iTime),5,-6.*cos(iTime)+6.);
    vec3 l=vec3(1.,2.,-1.);
    l = normalize(l);
    vec3 n = GetNormal(p);
    float dif = clamp(dot(n,l),0.,1.);
    float d=RayLight(p+n*SURF_DIST*1.2,l);
    if(d<MAX_DIST)
    dif=0.0;
    //dif=1.;
    return dif;
}

// Function 471
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    for( float t=mint; t<tmax; )
    {
        float h = map(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        res = min( res, 4.*h/t );
        t += h;
    }
    return res;
}

// Function 472
bool shadowed(Ray R, float minDist, float maxDist) {
    const int maxIterations = 30;    
    const float closeEnough = 0.0011 * 4.0;
    const float minStep = closeEnough;
    float t = 0.0;
    
    for (int i = 0; i < maxIterations; ++i) {
        float dt = inf;
        scene(R.direction * t + R.origin, dt);        
        t += max(dt, minStep);
        if (dt < closeEnough) {
            return true;
        } else if (t > maxDist) {
            return false;
        }
    }
    
    return false;
}

// Function 473
float soft_shadow(vec3 ro, vec3 rd) {
    float res = 1.;
    float t = .0001;                     
	float h = 1.;
    for(int i = 0; i < shadow_steps_; i++) {         
        h = eval_scene(ro + rd*t).d;
        res = min(res, 4.*h/t);          
		t += clamp(h, .02, 1.);          
    }
    return clamp(res, 0., 1.);
}

// Function 474
float worldShadow( vec3 ro, vec3 rd, float dist )
{
    vec3 n, c;
    vec2 tres = worldIntersect(ro, rd, n, c);
    return (tres.y < 0.0 || tres.x > dist) ? 1.0 : 0.0;
}

// Function 475
float shadow(vec2 p, vec2 pos, float radius)
{
	vec2 dir = normalize(pos - p);
	float dl = length(p - pos);
	
	// fraction of light visible, starts at one radius (second half added in the end);
	float lf = radius * dl;
	
	// distance traveled
	float dt = 0.01;

	for (int i = 0; i < 64; ++i)
	{				
		// distance to scene at current position
		float sd = sceneDistance(p + dir * dt);

        // early out when this ray is guaranteed to be full shadow
        if (sd < -radius) 
          return 0.0;
        
		// width of cone-overlap at light
		// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage
		// should be '(sd / dt) * dl', but '*dl' outside of loop
		lf = min(lf, sd / dt);
		
		// move ahead
		dt += max(1.0, abs(sd));
		if (dt > dl) break;
	}
	// multiply by dl to get the real projected overlap (moved out of loop)
	// add one radius, before between -radius and + radius
	// normalize to 1 ( / 2*radius)
	lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);
	lf = smoothstep(0.0, 1.0, lf);
	return lf;
}

// Function 476
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    // fake soft shadow
    if( tF<0.0) return 1.0;
    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);
    return sh*sh*(3.0-2.0*sh);
}

// Function 477
float SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){
    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;
    for(int s=0;s<20;++s){if(t > maxt) break;
        float nextDist = min(
            BuildingsDistance(landPoint + lightVector * t )
            , RedDistance(landPoint + lightVector * t ));
        if( nextDist < 0.001 ){return 0.0;}
        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );
        t += nextDist;}return penumbraFactor;}

// Function 478
vec3 sampleLightSource( 	in vec3 x,
                          	float Xi1, float Xi2,
                          	out LightSamplingRecord sampleRec ) {
    float sph_r2 = objects[0].params_[1];
    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );
    
    vec3 w = sph_p - x;			//direction to light center
	float dc_2 = dot(w, w);		//squared distance to light center
    float dc = sqrt(dc_2);		//distance to light center
    
    
    float sin_theta_max_2 = sph_r2 / dc_2;
	float cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );
    float cos_theta = mix( cos_theta_max, 1.0, Xi1 );
    float sin_theta_2 = 1.0 - cos_theta*cos_theta;
    float sin_theta = sqrt(sin_theta_2);
    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );
    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );
        
    //Calculate intersection distance
	//http://ompf2.com/viewtopic.php?f=3&t=1914
    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);
    
    return lights[0].color_*lights[0].intensity_;
}

// Function 479
int addPointLight(vec3 position, vec3 color, float energy, float radius, float shadow_dist)
{ 
    lights[num_lights] = PointLight(position, color, energy, radius, shadow_dist);
    ++num_lights;

    return num_lights;
}

// Function 480
vec3 shade(vec3 p,vec3 dir,float h,float td) {
    ldir=normalize(ldir);
	col=vec3(0.);
    vec3 n=normal(p.xz,td);
	col*=.25;
    float dif=max(0.,dot(ldir,-n));
    vec3 ref=reflect(ldir,dir);
    float spe=pow(max(0.,dot(ref,-n)),8.);
    return col+(dif*.5+.2+spe*vec3(1.,.8,.5))*.2;
}

// Function 481
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {
    
	float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
		float h = dstScene(ro+rd*t).dst;
        if(h <= 0.) continue;
        res = min( res, 32.0*h/t );
        t += clamp( h, 0.0002, 10.5 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 482
float shadow( in vec3 ro, in vec3 rd, float mint, float maxt )
{
    for( float t=mint; t<maxt; )
    {
        float h = map(ro + rd*t);
        if( h<EPSILON )
            return 0.0;
        t += h;
    }
    return 1.0;
}

// Function 483
float compute_light_atten(vec4 light, vec3 surface_point, vec3 surface_normal)
{
    vec3 light_dir = light.xyz - surface_point;
	float
        dist = length(light_dir) * LIGHTMAP_SCALEDIST,
    	angle = mix(1., dot(surface_normal, normalize(light_dir)), LIGHTMAP_SCALECOS);
    return max(0., (light.w - dist) * angle * (LIGHTMAP_RANGESCALE / 255.));
}

// Function 484
float pp_dirLight(vec3 worldPosition, vec3 normal, vec3 sunNormal, float sunBrightness, Sphere[numSpheres] spheres, Box[numBoxes] boxes){
    
    float brightness = dot(sunNormal, normal) * sunBrightness;
    if(brightness > 0.0){
    	Ray ray;
   		ray.origin = worldPosition;
   		ray.direction = sunNormal * -1.0;
   		for(int i = 0; i < spheres.length(); i++){
            	if(spheres[i].castShadow){
   	     	
    	    	RayHit rayHit = traceSphere(ray, spheres[i]);
    	    	   
    	    	if(rayHit.hit && rayHit.depth > 0.0){
    	    	    brightness = 0.0;
    				return brightness;
    	    	}
            }
    	}
        for(int i = 0; i < boxes.length(); i++){
            if(boxes[i].castShadow){
            	RayHit rayHit = traceBox(ray, boxes[i]);
            	
            	if(rayHit.hit && rayHit.depth > 0.0){
            	    brightness = 0.0;
            	    return brightness;
            	}
            }
        }
        RayHit rayHit = traceManySpheres(spheresX, spheresY, ray);
        if(rayHit.hit && rayHit.depth > 0.0){
            brightness = 0.0;
            return brightness;
        }
    }
    
    return clamp(brightness, 0.0, abs(brightness));
}

// Function 485
vec3 lighting(vec2 coord, float delta)
{
	vec3 lightPos = genLightCoords();
	float cosine = incidenceCosine(lightPos - vec3(coord, 0.), surfaceNormal(coord, delta));
	
	float dist = distance(lightPos, vec3(coord, 0.0));
	float att = exp(-dist);
    
	vec3 ambient = vec3(0.75);
	vec3 diffuse = vec3(1.0);
	diffuse *= att*lightStrength*cosine*lightColor;
	
	vec3 specular = vec3(1.0);
	specular *= pow(abs(cosine), specularFactor*specularRatio);
	specular *= att*lightStrength*lightColor;
	specular *= specularMapRatio;
	
	return ambient+diffuse+specular;
}

// Function 486
float calcShadow( vec3 ro, vec3 rd, float mint, float maxt )
{
	float t = mint;
	float res = 1.0;
	for ( int i = 0; i < 32; i++ )
	{
		float h = sdf( ro + rd * t );
		res = min( res, 7.0 * h / t );
		t += h;
		if ( ( h < 0.01 ) || ( t > maxt ) )
		{
			break;
		}
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 487
vec4 lightPos(float q,int k,vec4 d
){if(iFrame<1)return d
 ;vec4 c=tf(q)
 ;if(key(k))c.xyz=tf(camP0).xyz+vec3(LIGHT_RADIUS*1.3);
 ;return c;}

// Function 488
vec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {
	float diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian
	
	float diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian
	
	return
	(diffuse*Diffuse)*(LightColor*color) +
	(diffuse2*Diffuse)*(LightColor2*color);
}

// Function 489
float shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)
{
	float lambda = dot(-(ro - sphere.xyz),rd);
	float dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;
	return mix(9999.0,dist,step(0.0,lambda)); 
}

// Function 490
float rayMarchToAreaLight(in vec3 ro, in vec3 rd)
{
    const float numStep = 4.0;
    float shadow = 1.0;
  	float stepDist = length(rd - ro) / numStep;
    vec3 dir = normalize(rd - ro);
    for(float i = 0.5; i < numStep; i += 1.0)
    {
        vec3 pos = ro + dir * (i / (numStep));
        shadow *= exp(-densityVoumetricFog(pos * 253.0) * stepDist);
    }
    return shadow;
}

// Function 491
vec3 Light(int m, vec3 p, vec3 v, float d, float rnd)
{
    float h = 3e-4 * (d + 1.) //2e-3 * clamp(d, .01, 100.) //
    , hd;
    vec3 n = SceneNormal(p, h, hd, IZERO)
    , albedo = Material(m, p, n, d)
    , c = albedo;
    float nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO)
    , fogscale = fogdensity // / dmax * 8.5e4; // TODO scale by dmax somehow?
    , fexp = exp2(-fogscale * d);
    // TODO replace with custom illumination
    c *= nl * mix(sunDir.y, 1., .5+.5*nitebrite);
    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color
        + (1.-fexp) * .7 * pow(clamp(1.-abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog
        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)
        + .87*pow(max(0., dot(-v, sunDir) * .5 + .5), 16.); // fake mie, sun halo
    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)
    c = clamp(c, 0., 1.);
    return c;
}

// Function 492
bool traceSceneShadow(vec3 ro, vec3 rd)
{
    vec3 p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);
    vec2 b = box(ro, rd, p,q);

    if(b.x > 0. && b.x < b.y)
    {
        return false;
    }

    float a = 3.9;
    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));   

    ro.xz *= m;
    rd.xz *= m;

    ro.xy *= m;
    rd.xy *= m;

    ro.yz *= m;
    rd.yz *= m;

    p = vec3(-.26), q = vec3(.26);
    b = box(ro, rd, p, q);

    if(b.x > 0. && b.x < b.y)
    {
        return false;
    }

    return true;
}

// Function 493
float raymarchShadows(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    for(int i = 0; i < 50; i++) {
        vec3 p = ro + rd * t;
        float d = intersectSpheres(p, true).y;
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            break;
    }
    return sh;
}

// Function 494
vec3 skyDirectLight(vec3 pos, int i) {
    if(dot(LightDirection, SkyUp) < 0.0){return vec3(0.0);}
    vec3 volAbs = vec3(1.0), stepAbsRay, stepAbsMie;
    float alt, dist, ds;
    for(; i < SkySamples; i++){
        alt = -log(1.0-sign(dot(LightDirection, SkyUp))*float(i)/float(SkySamples));
    	dist = alt/dot(LightDirection, SkyUp);
        ds = exp(-dot(pos, SkyUp));
        stepAbsRay = exp(-ds*dist*SkyColor*SkyIntensity);
        stepAbsMie = exp(-ds*dist*MieIntensity*vec3(1.0));
        volAbs *= stepAbsMie*stepAbsRay;
        pos += LightDirection*dist;
    }
    return LightColor.rgb*LightColor*volAbs;
}

// Function 495
vec3 shade(vec3 ro, vec3 rd, vec4 hit_nt, float bdist, float ndist, float diffuse) {
    
    // Surface point.
    vec3 p = ro + rd*hit_nt.w;
    
    // get the normal
    vec3 n = hit_nt.xyz;
    
    // Light direction vector.
    vec3 ld = normalize(lp - p);
    

    // gotta deal with borders

    // need to antialias more far away
    float border_scale = 3.0/iResolution.y;
    float border_size = 0.01;
    float border = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);
    
    border_scale = 4.0/iResolution.y;
    border_size = 0.01*3.;
    float border2 = smoothstep(0.0, border_scale*hit_nt.w, abs(bdist)-border_size);



    // diffuse + ambient term
    diffuse = min(diffuse, clamp(dot(ld, n), 0.0, 1.0));
    float spec = pow(max( dot( reflect(-ld, n), -rd ), 0.0 ), 32.0);
    
    //float atten = 3./(1. + hit_nt.w*.1);
    
    //float fres = clamp(1. + dot(rd, n), 0., 1.);
    
    float ao = 1.0 - ao_strength*exp(-ao_falloff*ndist); // Ambient occlusion.

    // Surface color.
    vec3 color = (tex3D(iChannel0, p/4., n)*.66+tex3D(iChannel0, p/2., n)*.34);
    color *= vec3(1, .8, .6)*1.5;
    
    float gr = dot(color, vec3(.299, .587, .114));
   
    // Color the path and the surrounds slightly different colors.
    if(svObjID == 0.) { // Path.
        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .35)*1.5;//*vec3(1, .7, .4); // Terrain.
        color *= vec3(1.5, 1.25, 1); 
        //color = color.xxx;
    }
    else { // Surrounds.
         
        color = mix(color*vec3(1, 1.5, 1), vec3(1)*gr, .5);
        color *= vec3(1.5, 1.25, 1); 
        //color = color.xxx;
    }
  
    // Fake reflection. Doesn't really work well here.    
    //vec3 ref = tex3D(iChannel1, (p + reflect(rd, n)*2.)/64., n).xyz;//*vec3(.5, .7, 1)*.2;
    //color += ref*.25;      
    
    // add in border color
    color = mix((color*2.5 + gr*.75), color, border2);
    color *= border*.97 + .03;
 
    
    // multiply by diffuse/ambient
    color = color*(diffuse + 0.25*ao + vec3(.5, .7, 1)*spec*2.);// + color*fres*fres*ao*.125;


    // consider AO
    color *= ao;
    

	return color;
    
}

// Function 496
float shadow(in vec3 p){
    p += .00001*moonRefl;
    if(shadTrace(p,moonRefl)) return .2;
    else return 1.;
}

// Function 497
vec4 computeLightShadow(in Intersection isect)
{
    int i, j;
    int ntheta = 16;
    int nphi   = 16;
    float eps  = 0.001;

    // Slightly move ray org towards ray dir to avoid numerical problem.
    vec3 p = vec3(isect.p.x + eps * isect.n.x,
                  isect.p.y + eps * isect.n.y,
                  isect.p.z + eps * isect.n.z);
    vec4 result;

    Ray ray;
    ray.org = p;
    ray.dir = normalize(light - p);

    Intersection lisect;
    lisect.hit = 0;
    lisect.t = 1e30;
    lisect.n = lisect.p = vec3(0);
    lisect.col = vec4(0);
    Intersect(ray, lisect);
    if (lisect.hit != 0)
    {
        result = vec4(0.1, 0.1, 0.1, 10.0);
    }
    else
    {
        float shade = max(0.0, dot(isect.n, ray.dir));
        shade = pow(shade,2.0) + shade * 0.5;
        result = vec4(shade, shade, shade, 0);
    }

#if 0
	// Second light
    ray.dir = normalize(light2 - p);
    lisect.hit = 0;
    lisect.t = 1e30;
    lisect.n = lisect.p = vec3(0);
    lisect.col = vec4(0);
    Intersect(ray, lisect);
    if (lisect.hit != 0)
    {
        result += vec4(0.1, 0.1, 0.1, 10.0);
    }
    else
    {
        float shade = max(0.0, dot(isect.n, ray.dir));
        shade = pow(shade,2.0) + shade * 0.5;
        result += vec4(shade, shade, shade, 0);
    }
#endif

    return result;
}

// Function 498
float calcAO( in vec3 pos, in vec3 nor )
{
	float ao = 0.0;
    for( int i=ZERO; i<8; i++ )
    {
        vec3 ap = forwardSF( float(i), 8.0 );
        float h = hash1(float(i));
        float dk = dot(ap,nor); if( dk<0.0 ) ap -= 2.0*nor*dk;
        ap *= h*0.3;
        ao += clamp( mapWithElephants( pos + nor*0.01 + ap )*2.4, 0.0, 1.0 );
    }
	ao /= 8.0;
	
    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );
}

// Function 499
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<8; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 500
float punctualLightIntensityToIrradianceFactor(const in float lightDistance,
                                               const in float cutoffDistance,
                                               const in float decayExponent){
    if(decayExponent > 0.0){
     	return pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);   
    }
    
    return 1.0;
}

// Function 501
vec4 shade(Ray ray) {

    RaycastHit scene = intersectScene(ray);
    
    if(scene.id == 0) {
     
        return mix(calcGI(scene), shadeSphere(ray, scene), GI_FACTOR);
        
    } else if(scene.id == 1) {
     
        return mix(calcGI(scene), shadePlane(ray, scene), GI_FACTOR);
        
    }
    
    return texture(iChannel0, ray.dir);

}

// Function 502
float calcAO( in vec3 pos, in vec3 nor )
{
    float ao = 0.0;
    float sca = 15.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 15.*(0.01 + 0.015*float(i*i));
        float dd = map( pos + hr*nor ).x;
        ao += (hr-dd)*sca/15.;
        sca *= 0.5;
    }
    return 1.0 - clamp( ao, 0.0, 1.0 );
}

// Function 503
float shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )
{
	float t = mint;
	float res = 1.0;
    for ( int i = 0; i < 128; ++i )
    {
        float h = scene( ro + rd * t );
        if ( h < 0.001 )
            return 0.0;
		
		res = min( res, k * h / t );
        t += h;
		
		if ( t > maxt )
			break;
    }
    return res;
}

// Function 504
vec3 shade( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l
			, float traced_shadow, float sun_shadow, float first_bounce
			, TraceOutput to, float ao, float exposure, vec2 uv )
{
	vec3 col = vec3( 0. );
	bool sky = to.t > TMAX;

//	return sky ? BLACK : ( vec3( 1.0 ) + n ) * 0.5; // normal debug color
//	return vec3( 1.0 - exp( -to.t * 0.15 ) ); // distance to hit point
//	return viridis_quintic( to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) ) ); // visualize the number of iterations
//	return viridis_quintic( to.dist / ( DBREAK * to.t ) );
//	return viridis_quintic( to.dist );
//	return viridis_quintic( ao );

	vec3 sun_color = black_body( 19000.0, 0.8 );
	vec3 sun_color_c = chrominance( sun_color );
	vec3 albedo = vec3( 0.85, 0.85, 1 );
#ifdef COLOR_TILES
	albedo = mix( vec3( 0.2 ), vec3( 1.0 ), hash32( floor( p.xy ) ) );
#endif

	if ( !sky )
	{
		float iter = to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) );
		float fog_start = 30.0;
		float fog = exp2( -max( to.t - fog_start, 0.0 ) * 0.02 ); // this is mostly to fade the horizon
		float ao_z = 1.0 - saturate( abs( p.z * ( 1.0 / TRENCH_DEPTH ) ) ); // vertical occlusion
		float kdiffuse = 0.75;
		float kspecular = 1.0;
		float sunI = 2.2;
		float kambient = 0.005;
		float shadow = min( traced_shadow, sun_shadow );

//		return vec3( shadow );
//		n = normalize( n + 0.07 * l ); // soften a bit
#if 1
 // main sun light
		col += add_light_contrib( albedo, l, n, -v
								  , sunI * mix( 0.0, 1., ao_z ) * mix( 0., 1., shadow )
								  , 1.
								  , kdiffuse
								  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles
#endif
#if 1
// dummy secondary source
		vec3 l2 = normalize( vec3( 5, -5.5, 10 ) );
		col += add_light_contrib( albedo, l2, n, -v
								  , 0.34 * mix( 0.08, 1., ao_z ) * ao
								  , 1.
								  , kdiffuse
								  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles
#endif
#if 1
// first bounce
		col += add_light_contrib( albedo, reflect( l, vec3( -1., 0., 0. ) ), n, -v
								  , first_bounce
								  , 0.05
								  , kdiffuse
								  , kspecular * shadow * ao_z );
#endif
#if 1
// ambient
		col += PI * vec3( kambient * ao_z * ao );
#endif
#if 1
// random crap
		col *= fog * ao * ao * ( 1. - iter * 0.7 );
#endif
	}
	else
	{
		col = vec3( 0. );

#ifdef SUN
		vec3 sx, sy;
		build_onb( l, cam[0].xyz, sx, sy ); // we want the flares to be viewspaceish
		col += sunval( dot( l, v ), vec2( dot( v, sx ), dot( v, sy ) ), sun_color, sun_color_c );
#endif

#ifdef STARFIELD
		col += starfield( v );
#endif
	}

	col = exposure * tonemap_reinhard( col );
//	col = max( vec3( 0. ), contrast( col, vec3( 1.015 ) ) );

	float vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); 
	col *= vignette;

	col = gamma_correction_itu( col );
//	col = gamma_correction( col );

	return col;
}

// Function 505
float shadow( in vec3 ro, in vec3 rd )
{
#if 0
	vec2 res = vec2( 1e20, 1.0 );
	
    float t = 0.0;
	t = iSphere( ro, rd, sphere[0] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );
    t = iSphere( ro, rd, sphere[1] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );
    t = iSphere( ro, rd, sphere[2] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );
    t = iSphere( ro, rd, sphere[3] ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );
    t = iPlane(  ro, rd, vec4(0.0,1.0,0.0,1.0)  ); if( t>eps && t<res.x ) res = vec2( t, 0.0 );
	
    return res.y;					  
#else

	float res = 1.0;
	
    float t = 0.0;
	t = sSphere( ro, rd, sphere[0] ); res = min( t, res );
    t = sSphere( ro, rd, sphere[1] ); res = min( t, res );
    t = sSphere( ro, rd, sphere[2] ); res = min( t, res );
    t = sSphere( ro, rd, sphere[3] ); res = min( t, res );
    t = sPlane(  ro, rd, vec4(0.0,1.0,0.0,1.0) ); res = min( t, res );
	
    return res;					  


#endif	
}

// Function 506
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.5;                 // selfintersection avoidance distance
	float h = 1.0;
    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps
    {
        h = doModel(ro + rd*t);
        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows
		t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances
    }
    return clamp(res,0.0,1.0);
}

// Function 507
float shade_probe(vec4 sh, vec4 shn) {
    return sh_shade(sh_irradiance_probe(sh), shn);
}

// Function 508
bool checkShadow(vec3 P){
	vec3 rayDir = (L1.pos - P)/length(L1.pos - P);
    vec3 Collision = checkCollide(P,rayDir);
    
    if(Collision.y==2.0){
        return false;
    }
    return true;
}

// Function 509
float sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h/b );
}

// Function 510
SpotLight new_light(vec3 position, vec3 direction, float angle) {
    SpotLight light;
    light.position = position;
    light.direction = direction;
    light.angle = angle;
    return light;
}

// Function 511
float shadow(in vec3 eye, in vec3 dir) {
    float res = 1.0;
    float t = EPSILON;
    float ph = 1e10;
        
    for( int i=0; i<MAX_SHADOW_STEPS && t < MAX_DIST; i++ )
    {
     	vec3 p = eye + dir * t;
        float h = scene(p).z;
        if (h < 0.0){ return 0.0; }
        
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, 10.0*d/max(0.0,t-y) );
        
        t += h;
    }

    return res;
}

// Function 512
float AO_Falloff (in float x)
{
	return exp(-8.0 * (1.0-x));
}

// Function 513
float pp_pointLight(vec3 worldPosition, vec3 normal, vec3 lightLocation, float lightBrightness, Sphere[numSpheres] spheres, Box[numBoxes] boxes){
    vec3 diff = worldPosition - lightLocation;
    
    vec3 lightNormal = normalize(diff);
    
    float dist = length(diff);
    
    float brightness = dot(lightNormal, normal) * lightBrightness / (pow(dist, 2.0));
    
    if(brightness > 0.0){
    	Ray ray;
   		ray.origin = worldPosition;
   		ray.direction = lightNormal * -1.0;
   		for(int i = 0; i < spheres.length(); i++){
            if(spheres[i].castShadow){
   	    	 
    		    RayHit rayHit = traceSphere(ray, spheres[i]);
    		       
    		    if(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){
    		        brightness = 0.0;
    				return brightness;
	    	    }
            }
    	}
        for(int i = 0; i < boxes.length(); i++){
            if(boxes[i].castShadow){
            	RayHit rayHit = traceBox(ray, boxes[i]);
            	
            	if(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){
            	    brightness = 0.0;
            	    return brightness;
            	}
            }
        }
        RayHit rayHit = traceManySpheres(spheresX, spheresY, ray);
        if(rayHit.hit && rayHit.depth > 0.0 && rayHit.depth < dist){
            brightness = 0.0;
            return brightness;
        }
    }
    
    return clamp(brightness, 0.0, abs(brightness));
}

// Function 514
vec3 SampleLightColor(vec3 P, Object light)
{
	vec3 color = light.emissive*light_intensity;
#if LIGHT_TEXTURED
	if (light.quadLightTexture != 0U) {
		vec3 V = P - light.pos;
		float vx = dot(V, light.quadBasisX); // note quadBasis is divided by extent
		float vy = dot(V, light.quadBasisY);
		vec2 uv = vec2(vx, -vy)*0.5 + vec2(0.5); // [0..1]
		color *= textureLod(sampler2D(light.quadLightTexture), uv, light_texture_LOD).rgb;
	}
#endif // LIGHT_TEXTURED
	//if (IsSphere(light)) {
	//	vec3 V = normalize(P - light.pos);
	//	vec3 A = abs(V);
	//	color *= mix(vec3(0.1), V*0.5 + vec3(0.5), pow(max(max(A.x, A.y), A.z), 8.0));
	//}
	return color;
}

// Function 515
float getShadowTerm(vec3 r)
{
	float light_amount = 1.0;
    
    if( curr_iteration == 0 )
    { 
        for( int i=0; i < 64; ++i )
        {
            vec3 light_pos = g_light.xyz;
			float ofsx = fmod(float(i), SRO);
        	float ofsy = (float(i)*SRO)/SRO;
    		float ofsz = fmod(float(i)*SRO*SRO, SRO);
    		vec3 offset = 1.0 * vec3(ofsx, ofsy, ofsz);
    		light_pos += offset;
        
        	if( shadowRayCast(r, light_pos) ) 
        	{
				light_amount -= 1.0 / 64.0;
        	}
  	  	}
    }
    else
    {
        // LOLHAX!!!!
        light_amount = 0.33;
        if( shadowRayCast(r, g_light.xyz) )
        {
			light_amount = 0.0;
        }
    }
   
    return light_amount;
}

// Function 516
vec3 lightingAndShadow(vec3 ro, vec3 rd, Hit hit, vec3 lightPos) {
    
    vec3 p = ro + rd * hit.dist;
    
    vec3 L = normalize(lightPos - p);
    vec3 N = normal(p);
    vec3 V = normalize(ro - p);
    vec3 H = normalize(L + V);
    
    float diffuse = max(0.0, dot(L, N));
    float specular = pow(max(0.0, dot(N, H)), 50.0);
    
    vec3 light = LIGHT_INTEN * (diffuse * hit.color + specular);
    
    /*float d = rayMarch(p + N * EPSILON * 2.0, L).dist;
    if(d < distance(L, p))
        light *= 0.3;*/
    
    light *= envMap(rd, N);
    
    return light;
}

// Function 517
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.0005;                 // selfintersection avoidance distance
	float h = 1.0;
    for( int i=0; i<80; i++ )         // 40 is the max numnber of raymarching steps
    {
        h = doModel(ro + rd*t).x;
        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows
        if(h <= 0.0){
            break;
        }
        t +=abs(h);
        if(t > 20.0){
            break;
        }
      //  t += max(h, 0.;
	//	t += clamp( h, 0.001, 2.0 );   // limit the max and min stepping distances
    }
    return clamp(res,0.0,1.0);
}

// Function 518
float calcAO( in vec3 pos, in vec3 nor )
{
    #ifndef ENABLE_AO
    return 1.;
    #endif

    float occ = 0.20;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos = nor * hr + pos;
        float dd = mapScene( aopos,-1,false ).d;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ); 
}

// Function 519
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 24; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        dist += clamp(h, .01, .5); 
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0. || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 520
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res = 2.0, t = 0.0, h;
  for ( int i=0; i<16; i++ )
  {
    h = MapTerrain(origin+direction*t);
    res = min( res, 3.5*h/t );
    t += clamp( h, 0.02, 0.8);
    if ( h<0.002 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 521
vec3 calcDiffuseLight(Object o, Light l, vec3 pos)
{
    vec3 dir = normalize(l.pos - pos);
    float val = clamp(dot(o.normal, dir), 0.0, 30.0);
    float oVal = val;

    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   
    return col;
}

// Function 522
float castShadowRay(vec3 ro,vec3 rd
){for( int i=0; i<NUMBOXES; i++ //es100 safe
 ){mat4 ma; vec3 si; getLocation(i, ma, si)
  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}
 ;return 1.;}

// Function 523
vec4 innerLightPositionAndIntensity() {
    float scaledTime = iTime * 6.1;
    float hashInput = floor(scaledTime) * 0.1;
    
    if (hash11(hashInput) < 0.75) return vec4(0.); // mask out most of the flashes
        
    vec3 hash = hash31(hashInput);
    float theta = hash.x * 6.283;
    float z = hash.y * 2. - 1.;
    float sinPhi = sin(acos(z));
    vec3 position = vec3(sinPhi * cos(theta), sinPhi * sin(theta), z) * (0.6 + hash.z * 0.2);
    
    float intensity = sin(fract(scaledTime) * 3.142);
    
    return vec4(position, intensity);
}

// Function 524
float MapLights( vec3 p)
{
  vec3 pOriginal = p;
  // rotate position 
  p=TranslatePos(p, pitch, roll);   
  // mirror position at x=0.0. Both sides of the plane are equal.
  pMirror(p.x, 0.0);

  return max(sdEllipsoid( p- vec3(0.4, -0.1, -9.5), vec3(0.03, 0.03, 0.03+max(0., (speed*0.07)))), -sdBox(p- vec3(0.4, -0.1, -9.6+2.0), vec3(2.0, 2.0, 2.0)));
}

// Function 525
float getao(vec3 p, vec3 n, float d) {
    return clamp(map(p+n*d)/d,0.0,1.0);
}

// Function 526
float Shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = 0.05;
	float h;
	
    for (int i = 0; i < 12; i++)
	{
		h = Map( ro + rd*t );
		res = min(6.0*h / t, res);
		t += h+.02;
	}
    return max(res, 0.0);
}

// Function 527
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res =1., t = 0.0, h;
  vec3 rayPos = vec3(origin+direction*t);

  for ( int i=0; i<NO_UNROLL(20); i++ )
  {
    h = MapTerrain(rayPos).x;

    res = min( res, 8.5*h/t );
    t += clamp( h, 0.01, 0.25);
    if ( h<0.005 ) break;
    rayPos = vec3(origin+direction*t);
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 528
float calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    for( float t=mint; t<maxt; )
    {
        float h = map(ro + rd*t).x;
        if( h<0.001 )
            return 0.0;
        res = min( res, k*h/t );
        t += h;
    }
    return res;
}

// Function 529
vec3 LightingBRDFSample(Material mat,vec3 p,vec3 nDir,vec3 vDir,inout float _pathWeight,inout Intersection _intersec,inout Ray ray,out float pdf){
	vec3 L = vec3(0.);
    float x1 = GetRandom(),x2 = GetRandom();
    mat3 nDirSpace = CoordBase(nDir);
    //light dir
    vec3 L_local;
    //eye dir
    vec3 E_local = ToOtherSpaceCoord(nDirSpace,vDir);
    float alpha = mat.roughness;
    if(E_local.z <= 0.)
        return ZERO;
    vec3 N_local = sampleGGXVNDF(E_local,alpha,alpha,x1,x2);
    N_local *= sign(E_local.z * N_local.z);

    float part_pdf = 0.5;
    float path_pdf = 0.;
    if(GetRandom() < part_pdf){
        //diffuse ray
        L_local = DiffuseUnitSpehreRay(x1,x2);
        path_pdf = Diffuse_PDF(L_local);
    }
    else{
        //specular ray
        L_local = reflect(-E_local, N_local);
        path_pdf = Specular_PDF(E_local,N_local,alpha,alpha);
    }
    
    vec3 wo = RotVector(nDirSpace,L_local); //to world coord base
    vec3 Lr = MicroFactEvalution(mat,nDir,wo,vDir);
    Ray shadowRay = Ray(p,wo);
    float d = SceneIntersect(shadowRay,_intersec);
    ray = Ray(p,wo);
    if(path_pdf > 0.0001){
        if(_intersec.type == LIGHT && cosTheta(L_local)>0.){
            L = GetLightIntensity()/(d*d)*Lr*dot(wo,nDir)/part_pdf;
        }
        L /=path_pdf;
    }
    pdf = path_pdf;
	//我们要简单得考虑物体对 能量 得损失(we should simple think about energy absorption)
    _pathWeight *= EnergyAbsorptionTerm(alpha,L_local);
    return L;
}

// Function 530
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<50; i++ )
    {
        float h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.5, 1.0 );
		if( h<0.001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 531
vec3 ambientLight(vec3 pos){
    vec3 oldPos = pos;
    float expectedDist = distanceEstimation(pos) * pow(2.0, float(AoSteps));
    vec3 n, ambientColor = vec3(0.0), gi = vec3(0.0);
    for(int i = 0; i < AoSteps; i++){
        n = normalEstimation(pos);
        pos += distanceEstimation(pos) * n;
        ambientColor += background(n);
        if(i != 0 && fract(float(i)/float(GiSkipSteps)) == 0.0) gi += directLight(pos, n);
    }
    float ao = pow(length(pos-oldPos)/expectedDist, AoStrength);
    return ao * ambientColor/float(AoSteps) + gi / float(AoSteps/GiSkipSteps);
}

// Function 532
vec3 computeLighting(in vec3 iLightPosition, in vec3 iLightColor, in vec3 iDiffuseColor, in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in bool iAttenuated) {
	
    vec3 pointToLight = iLightPosition - iPoint;
    float distanceToLight = length(pointToLight);
    vec3 pointToLight_n = normalize(pointToLight);
    vec3 reflected = reflect(-pointToLight_n, iNormal);
    vec3 pointToOrigin_n = normalize(iOrigin - iPoint);
    float lambertian = max(dot(pointToLight_n, iNormal), 0.0);        
        
	float specular = 0.0;
  
	if(lambertian > 0.0) {
    	float angle = max(dot(reflected, pointToOrigin_n), 0.0);
    	specular = pow(angle, 16.0);
	}
  	
    // We soften the lighting if it's too harsh
    if (iAttenuated) 
		return 20.0*iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(1.0, 1.0, 1.0))/(1.0 + distanceToLight*distanceToLight);          
	else
  		return iLightColor*vec3(lambertian*iDiffuseColor + specular*vec3(0.0, 1.0, 1.0));          

}

// Function 533
vec4 shade(vec3 pos, vec3 eye, Light light, Material material)
{
	if(length(pos-eye) > MAX_DEPTH-EPSILON) return vec4(0.0);
	else return calcLighting(pos, eye, light, material);
}

// Function 534
float Ao(vec3 p, vec3 n) {
	float vis = 0.0;
	p += n*0.035;
	float t = 0.;//0.035;
	for (int i=0; i<9; i++)
	{
		float d = sdf(p);

	//	h^2 = d^2+L^2
		float h = inversesqrt( d*d + t*t );
		vis += abs(d) * h;	//cos angle of clear area?

		p += n * d * 0.9;
		t += d * 0.9;
	}
	vis *= 0.1;
	vis = bias(vis,0.125)*4.;
	return vis; 
}

// Function 535
float Shadertoy(in vec2 uv)
{
    float fResult = 1.0;
    
    fResult = min(fResult, Glyph0(uv)); // S

    vec2 vUVOffset = vec2(0.001, 0.0); // tail of h
    vec2 vTailOffset = vec2(0.0, 0.0);  
    float fUVScale = 1.0;

    if(uv.x < 0.3)
    {
        if(uv.y < 0.12)
        {
            // top of h
            fUVScale = -1.0;
            vUVOffset = vec2(0.448, 0.25);  
            vTailOffset = vec2(0.0, 0.0);   
        }
    }
    else if(uv.x < 0.4)    
    {
        // tail of a
        vUVOffset = vec2(-0.124, 0.0);  
        vTailOffset = vec2(0.01, -0.04);    
    }
    else if(uv.x < 0.6)
    {
        // tail of d
        vUVOffset = vec2(-0.248, 0.0);  
        vTailOffset = vec2(0.02, -0.1); 
    }
    else if(uv.x < 0.83)
    {
        // stalk of t
        vUVOffset = vec2(-0.48, 0.0);   
        vTailOffset = vec2(0.02, -0.1); 
    }
    else
    {
        // start of y
        vUVOffset = vec2(-0.645, 0.0);  
        vTailOffset = vec2(0.005, -0.042);  
    }
    
    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); // tails h, a, d, t, start of y and top of h


    vec2 vUVOffset3 = vec2(0.0, 0.0);   // vertical of h
    vec2 vTailOffset3 = vec2(0.0, 0.0);
    
    if(uv.x > 0.5)
    {
        // vertical of r
        vUVOffset3 = vec2(-0.45, 0.0);  
        vTailOffset3 = vec2(-0.01, 0.04);   
    }
    
    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); // vertical of h, r

    vec2 vUVOffset2 = vec2(0.0, 0.0); // curve of a
    if(uv.x > 0.365)
    {
        vUVOffset2 = vec2(-0.125, 0.0); // curve of d
    }

    fResult = min(fResult, Glyph4(uv + vUVOffset2)); // curve of a, d
    
    fResult = min(fResult, Glyph5(uv)); // e

    vec2 vUVOffset4 = vec2(0.001, 0.0); // top of r
    vec2 vUVScale4 = vec2(1.0, 1.0);        
    
    if(uv.x > 0.7)
    {
        // o loop
        vUVOffset4.x = 1.499;
        vUVOffset4.y = 0.19;
        
        vUVScale4.x = -1.0;
        vUVScale4.y = -1.0;
    }
    
    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); // top of r and o loop

    fResult = min(fResult, Glyph7(uv)); // cross t    
    
    fResult = min(fResult, Glyph8(uv)); // o1
    
    fResult = min(fResult, Glyph11(uv)); // y2        

    return fResult; 
}

// Function 536
float calcSoftshadow( in vec3 ro, in vec3 rd, float k )
{
    vec4 kk;    
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<32; i++ )
    {
        float h = mapOpaque(ro + rd*t, kk ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
        if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 537
vec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )
{
    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),
				              softShadowSphere( pos, vec3(0.57703), sc1 )),
				              softShadowSphere( pos, vec3(0.57703), sc2 )),
                              softShadowSphere( pos, vec3(0.57703), sc3 ));
	float dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);
	float bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);
    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;
	     lin += occ*vec3(0.15,0.20,0.30);
	     lin += bac*vec3(0.20,0.20,0.20);
	     lin += sh*0.8*pow(clamp(dot(reflect(rd,nor),vec3(0.57703)),0.0,1.0),12.0);

    return lin;
}

// Function 538
float lightIntensity(vec3 point, Light light) {
	float dist = distance(point, light.pos);

	return light.inten / (dist*dist);
}

// Function 539
float softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {
    float res = 1.0;
    float t = tmin;
    for (int i = 0; i < 20; i++) {
        float h = map(ro + rd * t).x;
        res = min(res, k * h / t);
        t += clamp(h, 0.001, 0.1);
        if (h < 0.0001 || t > tmax)
            break;
    }
    return clamp(res, 0., 1.0);
}

// Function 540
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 32; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

         
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        //h = clamp(h, .1, 1.); // max(h, .02);//
        h = max(h, .1);
        dist += h;

        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (shade<0.001 || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 541
float shadow(vec3 desde) {
    ldir=normalize(ldir);
    float td=.1,sh=1.,d;
    for (int i=0; i<10; i++) {
		vec3 p=desde+ldir*td;
        d=de(p);
        td+=d;
		sh=min(sh,20.*d/td);
		if (sh<.001) break;
    }
    return clamp(sh,0.,1.);
}

// Function 542
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax , float io )
{
float res = 1.0;
    float t = mint;
    for( int i=0; i<10; i++ )
    {
float h = map( ro + rd*t , io).x;
        res = min( res, 20.*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 543
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo )
{
	float eps = (abs(m-3.0)<0.2) ? 0.002: 0.0002;
	
	vec3 pos = ro + t*rd;
	vec3 nor = calcNormalmap( pos, eps );
	

	vec3 mateD = vec3(0.0);
	vec2 mateK = vec2(0.0);
	float mateS = 0.0;
	vec3 mateSG = vec3(1.0);

	if( m<1.5 )
	{
		mateD = vec3(0.132,0.06,0.06);
		
		vec3 p = transformHead( pos );
		vec3 headp = p;
		vec3 q = vec3( abs(p.x), p.yz );

		float m = 1.0 - smoothstep( 0.04, 0.14, length(q-vec3(0.16,-0.11,0.23)) );
		float no = texture(iChannel0,p.xy).x;
		m = clamp( m + 0.25*(-1.0+2.0*no), 0.0, 1.0 );
		mateD = mix( mateD, vec3(0.13,0.03,0.03), m );
		

		mateSG = vec3(0.75,0.97,1.0);

					
		m = 1.0 - smoothstep( 0.04, 0.17, length(q-vec3(0.45,-0.01,0.0)) );
		mateD += vec3(1.0,0.01,0.0)*m*0.3*(1.0+0.4*sign(p.x));
		mateSG = mix( mateSG, vec3(0.3-0.1*sign(p.x),0.9,1.0), m );;

		m = 1.0 - smoothstep( 0.05, 0.1, length(vec3(0.5,1.0,1.0)*(q-vec3(0.0,-0.06,0.23))) );

		vec2 uv = pos.xy*22.0;
		vec2 iuv = floor(uv);
		vec2 fuv = fract(uv);
		vec4 ran = texelFetch( iChannel0, (ivec2(iuv)+6)&255, 0 );
		vec2 off = ran.xy;
		float sss = pow(ran.z,5.0);
		float size = max(0.0,(0.5+0.5*m)*(0.3+0.7*sss)*0.12);
		float fr = 1.0 - smoothstep( size*0.5, size*2.0, length(fuv-off) );
		mateD = mix(mateD,vec3(0.25,0.05,0.0)*0.2, 0.6*(1.0-0.4*sss)*fr );
					
		mateK = vec2(0.08,0.5);
		mateS = 1.0;    

		
		vec3 bocap = headp-vec3(-0.006,-0.025,0.22);
		bocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;
		bocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;
		
		{
		vec4 b = sdBezier( corner1, center, corner2, bocap );
		float d1 = b.x - 0.01*4.0*b.y*(1.0-b.y);
		float isLip = 1.0-smoothstep( 0.0005, 0.0050, d1 );
		mateD = mix( mateD, vec3(0.14,0.04,0.05), 0.7*isLip );
		mateK = mix( mateK, vec2(0.4,1.5), isLip );
		}
		
		mateK *= 0.5 + no;
	}
	else if( m<2.5 )
	{
		mateD = vec3(0.18,0.18,0.225)*0.85;
		mateK = vec2(0.5,10.0);
		mateSG = vec3(1.0,1.0,0.9);
		
        
		vec3 p = transformHead( pos );
		vec3 q = vec3( abs(p.x), p.yz );
        q.x -= eyeOff;
        
		
		vec2 r = q.xy-vec2(0.102+0.004*sign(p.x),0.03+0.004);
		
		float m = length(r) - 0.042;
		if( m<0.0 )
		{
			m = abs(m);
			mateD = mix( mateD, vec3(0.0), smoothstep(0.0,0.003,m));
			mateD = mix( mateD, vec3(0.06,0.02,0.0), smoothstep(0.003,0.006,m));
			
			r.x *= -sign(p.x);
			float an = atan(r.y,r.x) + 1.5;
			float ca = 1.0-smoothstep(0.0,1.0,abs(an-1.0));
			ca *= 1.0-smoothstep(0.0,0.008,abs(m-0.011));

			float te = texture(iChannel0, vec2(an*0.1,m)).x;
			mateD = mix( mateD, (1.8*te*vec3(0.06,0.02,0.0)+(0.5+0.5*te)*ca*1.3*vec3(0.1,0.07,0.05)), smoothstep(0.003,0.006,m));

			mateD = mix( mateD, vec3(0.0), smoothstep(0.017,0.018,m-0.001));
			mateK = vec2(0.05,8.0);
		}

		r = q.xy-vec2(0.105+0.03*sign(p.x),0.058);
		mateD += (1.0-smoothstep(0.00,0.012,length(r)))*1.0;
	}
	else if( m<3.5 )
	{
		float focc = smoothstep(0.0,1.0,matInfo);

		mateD = vec3(0.025,0.015,0.01)*0.6*focc;
		mateK = vec2(0.1*focc,1.0);
	}
	else if( m<4.5 )
	{
		vec3 hatp = pos;
		hatp = transformHat(hatp);
		hatp.y += 0.1;
		float f = abs(hatp.x)-hatp.z;
		f = smoothstep(0.19,0.2,f );
		
		vec3 blue = vec3(0.01,0.04,0.08);
		vec3 te = 
		texture( iChannel0, 0.15*pos.yz ).xyz+
		texture( iChannel0, 1.0*pos.yz ).xyz;
		blue *= 0.5+0.5*te.z;
		mateD = mix( vec3(0.18), blue, f );
		mateS = 0.05;
		
			
		vec2 si = (hatp.xy-vec2(0.0,-0.18)) * 3.5;
		float h = si.y - 0.1*sin( 8.0*si.x );
		h = min( abs(h-1.15)-0.06, abs(h-1.0)-0.015 );
		h += clamp( (abs(hatp.x)-0.25)/0.1, 0.0, 1.0 );
		mateD = mix( mateD, vec3(0.004,0.008,0.014), 1.0-smoothstep( 0.01, 0.02, h ) );
		
	}
	else if( m<5.5 )
	{
		mateD = 0.5*vec3(0.01,0.04,0.08);
		mateD *= 0.7+0.6*texture( iChannel0, 2.0*pos.xz ).x;
		mateS = 0.05;
	}
	else if( m<8.5 )
	{
		mateD = vec3(0.30,0.30,0.40)*0.5;
		mateK = vec2(0.5,1.0);
		mateS = 0.2;
		
	}
	
	float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
	float occ = calcAO( pos, nor );
	
	vec3 col = vec3(0.0);
	
    {
		// key
		float dif1 = dot(nor,sunDir);
		vec3 hal = normalize( sunDir-rd );
		float spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);
		float sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); 
		float ssha = 1.0;
		if( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05;  }
		if( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }
		
		dif1 = clamp(dif1,0.0,1.0);

        float sks = (abs(m-1.0)<0.2)?0.5:0.0;
		vec3 sha3 = vec3((1.0-sks)*sha+sks*sqrt(sha),sha*0.4+0.6*sha*sha,sha*sha);
		
		col += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;
		col += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;
    }
	{
		// fill
		col += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;
		float dif1 = 0.5 + 0.5*nor.y;
		float sha = 1.0;
		float spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );
		col += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;
	}
	{
		// bounce
		vec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));
		float dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);
		col += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;
	}
	{
		col += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;
		col += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;
	}

	col = pow( col, mateSG );

    return col;
}

// Function 544
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    lightPos = eye;
    vec3 N = estimateNormal(p),
    L = normalize(lightPos - p),
    V = normalize(eye - p),
    R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 545
float calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )
{
	float ao = 0.0;
	const int nbIte = 5;
	for( int i=0; i<nbIte; i++ )
	{
		float l = hash(float(i))*maxDist;
		vec3 rd = n*l;
		ao += (l - map(p + rd.x).x) / pow(1.+l, falloff);
	}
	return clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);
}

// Function 546
float calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w)
{
    // bounding volume    
    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;
    if( dis.y<0.0 ) return 1.0;
    
    tmin = max(tmin,dis.x);
	tmax = min(tmax,dis.y);
    
    float t = tmin;
    float res = 1.0;
    for( int i=0; i<128; i++ )
    {
     	float h = map(ro + t*rd).x;
        res = min( res, h/(w*t) );
    	t += clamp(h, 0.005, 0.50);
        if( res<-1.0 || t>tmax ) break;
    }
    res = max(res,-1.0); // clamp to [-1,1]

    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep
}

// Function 547
vec3 shadeSupport(in vec3 pos, in vec3 ray) {
    vec3 col = vec3(1.0);
    vec3 norm = getNormal(shapeSupport, pos);
   
    float sha = calcSoftshadow(pos + norm*0.1, 8.0);
    float occ = calcOcclusion(pos, norm);
   
    vec3 color3D = triPlanar(iChannel1, pos, norm);

    float spec = phong(lig, ray, norm, 1.0);
    float atten = dot(norm, lig);
   
    float f = 1.0 - smoothstep(0.3, 0.31, pos.y + 0.95);
   
    col = mix(vec3(0.2, 0.7, 0.7), vec3(1.0), f);
    col *= atten * 0.5 + 0.5;
    col *= sha * 0.5 + 0.5;
    col *= occ;
   
    col += max(spec * sha * color3D * 2.0, 0.0);
    col *= 0.8 + color3D * 0.5;
   
    return col;
}

// Function 548
vec4 calcLighting(vec3 samplePos, vec3 eye)
{
	float lightDist = length(light.position-samplePos);
	vec3 lightDir = normalize(light.position-samplePos);
	vec3 eyeDir = normalize(samplePos-eye);
	vec3 surfaceNormal = getNormal(samplePos);
	vec3 reflection = normalize(reflect(eyeDir, surfaceNormal));
	
	float specular, diffuse, ambient = AMBIENT_LIGHT;
	float attenuation, shadow, occlusion;
	
	float spotCos = dot(-lightDir, light.direction);
	float spotCoefficient = smoothstep( 1.0-light.spread, 1.0, spotCos );
	
	// If it's outside of the light's cone we don't need to calculate any terms.
	if(spotCos < 1.0-light.spread)
	{
		specular = 0.0;
		diffuse = 0.0;
		attenuation = 0.0;
		shadow = 0.0;
	}
	else
	{
		specular = pow(max( 0.0, dot(lightDir, reflection)*spotCoefficient), 80.0);
		diffuse = max( 0.0, dot(lightDir, surfaceNormal)*spotCoefficient);
		attenuation = min(1.0, (1.0/(lightDist/light.brightness)));
		shadow = calcShadow(samplePos, lightDir, light);
	}
	occlusion = calcOcclusion(samplePos, surfaceNormal);
	vec4 objectColor = getColor(samplePos);
	return light.color*objectColor*clamp(((specular+diffuse)*shadow*attenuation), 0.0, 1.0)+(ambient*occlusion*AMBIENT_COLOR*objectColor);
}

// Function 549
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<40; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 550
vec3 groundLight(in vec3 pos, in vec3 ray, in float t){
    vec3 col = vec3(0.);
   	float ty = (.00001-pos.y)/ray.y;
    ty += step(ty,0.)*INFINI;
    pos += ty*ray;
    if(ty<t) col += (.05/length(pos.xz*20. - vec2(floor(pos.xz*20.)+.5))-.08)
        			* lightPath(pos.xz);
    return col;
}

// Function 551
C_DirectionalLight GetDirectionalLight()
{
    C_DirectionalLight result;

    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));
    result.cColour = vec3(8.0, 7.5, 7.0);

    return result;
}

// Function 552
float ao(vec3 p, vec3 n, float h) {
	p += n * h;
	return clamp(min(glass(p).d, map(p).d) / h, 0., 1.);
}

// Function 553
vec3 calculateVolumetricLight(vec3 p, vec3 o, vec3 od)
{
	
	vec3 light = getLight(p, o) * selfShadow(p, o);
	vec3 sphere = smoothstep(0.8, 0.81, sphere(p, o)) * lightColor*10.0;
	
	return (light * od + sphere);
}

// Function 554
bool shadowRayCast(vec3 r, vec3 light_pos)
{
    vec3 d = light_pos - r;
    
    float lowest_t = length( d );

    d = normalize(d);
    
    bool hit = false;
    
    for( int j = 0; j < NUM_SPHERES - 1; ++j )
    {
		float t;
        if( isect_sphere( r, d, g_spheres[j].xyz, g_spheres[j].w, t ) )
        {
			if( t < lowest_t )
            {
                lowest_t = t; hit = true;
            }
        }
    }
    
    for( int j = 0; j < NUM_PLANES; ++j )
    {
		vec3 np = g_planes[j].xyz;
        float np_dot_d = dot(np, d);
        if( abs(np_dot_d) > 0.001 )
        {
            float t = (g_planes[j].w - dot(np, r)) / np_dot_d;
            if( t > 0.0 && t < lowest_t )
            {
				lowest_t = t; hit = true;
            }
        }
    }
    
    return hit;
}

// Function 555
void CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, inout vec3 color)
{
    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)
    {
        vec3 lightDirection = (GetLight(lightIndex).Position - position);
        float lightDistance = length(lightDirection);
        lightDirection /= lightDistance;

        vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); 

        float lightVisiblity = 1.0;
        #if CAST_VOLUME_SHADOW_ON_OPAQUES
        if(!IsColorInsignificant(lightColor))
        {
            const float shadowMarchSize = 0.65f * MARCH_MULTIPLIER;
            lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_OPAQUE_SHADOW_MARCH_STEPS, shadowMarchSize); 
        }
        #endif
        
        color += lightVisiblity * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);
        color += lightVisiblity * lightColor * Diffuse(normal, lightDirection, material.albedo);
    
    }
    color += GetAmbientLight() * material.albedo;
}

// Function 556
float calcAO( in vec3 pos, in vec3 nor, in vec2 pix )
{
	float ao = 0.0;
    for( int i=0; i<64; i++ )
    {
        vec3 ap = forwardSF( float(i), 64.0 );
		ap *= sign( dot(ap,nor) ) * hash1(float(i));
        ao += clamp( map( pos + nor*0.05 + ap*1.0 )*32.0, 0.0, 1.0 );
    }
	ao /= 64.0;
	
    return clamp( ao*ao, 0.0, 1.0 );
}

// Function 557
vec4 roofLight(vec3 p) {
	float music = drum; 
	float s = 15.0;
	p.y += 10.0*TIME;
	vec3 q = mod(p, s) - s * 0.5;
	q.z = p.z;
	q *= rot(0.0,0.0,TIME * 5.0 + p.x*0.1 + p.z*0.1);
	vec3 lightCol = vec3(0.5 + 0.5 * sin(p.x), 0.5 + 0.5 * sin(p.y), 0.1);
	float dis = sdCappedCylinder(q.zxy - vec3(-10, 0, 0), vec2(0.05, 5.0));
	float distanceToL = max(0.0001, dis);
	vec3 point = lightCol * 5.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);

	return vec4(point, distanceToL);
}

// Function 558
void compute_ao_factor()
{
    ao_factor = pow(AO_DIST / AO_SMALL_PREC , 1.0/float(AO_RAY_ITER-1))-1.0;
}

// Function 559
vec3 lightning(vec2 p, float offset) {
    float time = iTime;
    vec2 f = vec2(0, -time*.50);
    
    vec3 col = vec3(0);
    int i = 0;
    for(i=0;i<4;i++){
        float n = abs(offset*0.02/(1.+offset-fbm((p+f)*2., time+float(i))));
        float n2 = abs(offset*0.02/(1.+offset-fbm((p+f)*3., time+float(i)*10.)));
        float n3 = abs(offset*0.02/(1.+offset-fbm((p+f)*3., time+float(i)*20.)));
        col += n*vec3(1, 0.0, .0);    
        col += n2*vec3(1);
        col += n3*vec3(0, 0, 1);
    }
    
    return col;
}

// Function 560
float sphLight( vec3 P, vec3 N, vec4 L)
{
  vec3 oc = L.xyz  - P;
  float dst = sqrt( dot( oc, oc ));
  vec3 dir = oc / dst;
  
  float c = dot( N, dir );
  float s = L.w  / dst;
    
  return max(0., c * s);
}

// Function 561
Material makeLight(vec3 color) { Material m; m.color = vec3(1.0); m.emissive = color; m.cls = MATERIAL_LIGHT; return m; }

// Function 562
float shadow_march( in vec3 ro, in vec3 rd)
{
    float t=0.01,d;
    
    for(int i=0;i<STEPS;i++)
    {
        d = map(ro + rd*t).d;
        if( d < 0.0001 )
            return 0.0;
        t += d;
    }
    return 1.0;
}

// Function 563
vec3 SampleLightsInScene(
	vec3 P,
	vec3 N,
	bool haltonEnabled,
	vec2 offset,
	int objId,
	int frameIndex, // iFrame
	int numLightSamples,
	inout uint wasSampled)
{
	bool sphericalLightIsTextured = false; // enable this if SampleLightColor needs position for spherical lights
	vec3 e = vec3(0);
	for (int lightId = 0; lightId < NO_UNROLL_(NUM_OBJECTS, objId); lightId++) {
		Object light = objects[lightId];
		if (IsQuad(light) && dot(light.pos - P, light.quadNormal) >= 0.0) { // facing away?
			wasSampled |= (1U << lightId); // might as well mark this light as sampled, we won't hit it in the next bounce
			continue;
		}
		if (ShouldSampleLight(P, N, light, e)) {
			vec3 l = vec3(0);
			if (MIS_enabled) {
				float q = MIS_ratio_default; // controls ratio N_h / N_d (hemisphere samples to direct light samples)
				if (MIS_light_dist_enabled && MIS_light_dist_max > 0.0) {
					float dmax = MIS_light_dist_max;
					float dmin = min(dmax - 0.0001, MIS_light_dist_min);
					float ds = 1.0/(dmin - dmax);
					float d0 = -ds*dmax;
					q = clamp(DistanceToObject(P, light)*ds + d0, 0.0, 1.0);
				}
				if (MIS_light_dist_dbg)
					e += vec3(q*q);
				int N_h = int(floor(0.5 + float(numLightSamples)*q)); // [0..numLightSamples]
				int N_d = numLightSamples - N_h; // [0..numLightSamples]
				for (int i = 0; i < N_d; i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_d)) : rand2(seed);
					l += SampleLightMIS_d(light, lightId, objId, P, N, s, float(N_d), float(N_h), sphericalLightIsTextured);
				}
				for (int i = 0; i < N_h; i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_h)) : rand2(seed);
					l += SampleLightMIS_h(light, lightId, objId, P, N, s, float(N_d), float(N_h));
				}
			} else {
				for (int i = 0; i < NO_UNROLL_(numLightSamples, objId); i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*numLightSamples)) : rand2(seed);
					l += SampleLight(light, lightId, objId, P, N, s, sphericalLightIsTextured);
				}
				l /= float(numLightSamples);
			}
			e += l;
			wasSampled |= (1U << lightId);
		}
	}
	return e;
}

// Function 564
float calcSoftshadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.01;
#ifdef HIGH_QUALITY
    for( int i=0; i<64; i++ )
#else
    for( int i=0; i<16; i++ )
#endif    
    {
        float h = map(ro + rd*t ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
#ifdef HIGH_QUALITY
        t += clamp( h, 0.01, 0.025 );
#else        
        t += clamp( h, 0.04, 0.1 );
#endif        
		if( res<0.01 ) break;
    }
    
    return clamp(res,0.0,1.0);
}

// Function 565
vec3 light(in vec3 at, in vec3 from, in light_dir_t l) {
	vec3 n = normal(at), h = normalize(from + l.dir);
	//if (trace(ray_t(at+n*1., l.dir), 3000.) < 3000.) return vec3(0.);
	return l.color * (
		cmat.diffuse * max(0., dot(n, l.dir))
		+ pow(max(0., dot(n, h)), cmat.specular) * (cmat.specular + 8.) / (8. * c_pi));
}

// Function 566
vec3 LightingDirectSample(Material mat,vec3 p,vec3 nDir,vec3 vDir,out float pdf){
	vec3 L = vec3(0.,0.,0.);
    float x1 = GetRandom(),x2 = GetRandom();
    vec3 wo;
    float dist;
    vec3 Li = LightSample(p,x1,x2,wo,dist,pdf);
    float WoDotN = dot(wo,nDir);
    if(WoDotN >= 0. && pdf > 0.0001){
        vec3 Lr = MicroFactEvalution(mat,nDir,wo,vDir);
        Ray shadowRay = Ray(p,wo);
        Intersection shadow_intersc;
        float d = SceneIntersect(shadowRay,shadow_intersc);
        if(shadow_intersc.type == LIGHT){
            L = Lr*Li/pdf;
        }
    }
    return L;
}

// Function 567
float softShadow( in vec3 ro, in vec3 rd )
{
	float scene = GetShadows(ro,rd);
	float alpha = 1.0 - 0.8*clamp(length(GetTransparency(ro,rd,9999.0)),0.0,1.0);
    return min(alpha,scene);
	
}

// Function 568
float softShadow(vec3 pos, vec3 rayDir, float start, float end, float k ){
    float res = 1.0;
    float depth = start;
    int id;
    for(int counter = ZERO; counter < MAX_STEPS; counter++){
        float dist = getSDF(pos + rayDir * depth, id);
        if( abs(dist) < EPSILON){ return 0.0; }       
        if( depth > end){ break; }
        res = min(res, k*dist/depth);
        depth += dist;
    }
    return res;
}

// Function 569
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int iter = 24; 
    
    ro += n*.0015; // Bumping the shadow off the hit point.
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float t = 0.; 
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;
    
    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);
    

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<iter; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .25); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        //if (d<0. || t>end) break; 
        // Bounding plane optimization, specific to this example. Thanks to IQ. 
        if (d<0. || t>end || (ro.z + rd.z*t)<-0.11) break;
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 570
float softShadow(vec3 ro, vec3 lp, float k) {
    const int maxIterationsShad = 8;
    vec3 rd = (lp - ro); // Unnormalized direction ray.

    float shade = 4.;
    float dist = 4.5;
    float end = max(length(rd), 0.01);
    float stepDist = end / float(maxIterationsShad);

    rd /= end;
    for (int i = 0; i < maxIterationsShad; i++) {
        float h = map(ro + rd * dist).dist;
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); 
        dist += min(h, stepDist * 2.); 
        if (h < 0.001 || dist > end) break;
    }
    return min(max(shade, 0.0), 1.0);
}

// Function 571
float calcShadow(vec3 p, vec3 ld) {
	// Thanks iq.
	float s = 1.,
	      t = 1.;
	for (float i = 0.; i < 30.; i++) {
		float h = sdTies(p + ld * t).d;
		s = min(s, 30. * h / t);
		t += h;
		if (s < .001 || t > 1e2) break;
	}

	return clamp(s, 0., 1.);
}

// Function 572
vec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos) {
	float fresnelBias = 0.25;
	float fresnelPower = 5.0;
	float fresnelScale = 1.0;
	float shininess = 20.0;
	vec4 lightParams = vec4(fresnelBias, fresnelPower, fresnelScale, shininess);
	return doLighting(eyePoint, objPoint, normalAtPoint, lightPos, lightParams); 
}

// Function 573
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 2.0;
    for( int i = ZERO; i < 5; i++ )
    {
        float hr = 0.02 + 0.22 * float( i ) / 5.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).t;
        occ += -( dd - hr ) * sca;
        sca *= 1.05;
    }
    return clamp( 2.0 - 4.0 * occ, 0.0, 2.0 ) * (0.6 + 0.6 * nor.y );
}

// Function 574
float getLight(vec3 p,vec3 lp)
{
    return dot(getNorm(p),normalize(lp - p));
}

// Function 575
vec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd, vec2 v )
{
    //Get the slider here!
    float roughness = uiSlider(0);
    float metallic = uiSlider(1);
    
    
    float d = length(ro-p);
    
    vec3 col = vec3(0.);
    if(d>30.)
        return sampleEnvMap(-rd,.9)*2.;
    
    n = doBumpMap(iChannel1, p*.25, n, .05);
    
    float ao = clamp( pow( ambientOcclusion(p,n,.5,1.), 20.)*5., 0., 1.);
    float fre = clamp(1.0+dot(n,rd), 0.0, 1.0 );
        
    vec3 diff = mix(sampleEnvMap(-n,roughness).rgb, vec3(1.), roughness);
    vec3 spec = sampleEnvMap(-reflect(rd,n),roughness).rgb;
    
    //Get the color here!
    col = (uiColor(0)*.3+.7) * mix(diff*ao,spec, min(1., metallic+fre) );
	return col;
}

// Function 576
vec3 
neighbor_light( vec3 hp, vec3 n, vec3 neighbor_cell_coord)
{
   vec3 neighbor_color = tower_lightcolor(neighbor_cell_coord.xz);
   vec3 light_pos = tower_lightpos(neighbor_cell_coord.xz, neighbor_color);
   light_pos += g_cellsize * vec3(neighbor_cell_coord.x + .5, 0., neighbor_cell_coord.z + .5);
   vec3 l = hp - light_pos;        
   float llen = length(l);
   return neighbor_color * max(0., dot(-normalize(l), n)) * pow(1./llen, .3);
}

// Function 577
vec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )
{
    vec3 oriCol = col;
    
    float dz = depth - t;
    float ao = clamp(dz*50.0,0.0,1.0);
    vec3  pos = ro + t*rd;
    vec3  nor = calcNormalTransparent( pos, 0.002 );
    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );
    vec3  hal = normalize( sunDir-rd );
    vec3  ref = reflect( -rd, nor );
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );
    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );


    float ds = 1.6 - col.y;
    
    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );

    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );
    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);
    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    
    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );
    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );
    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);
    
    // hide aliasing a bit
    col = mix( col, oriCol, smoothstep(0.6,1.0,fre) ); 
    
    return col;
}

// Function 578
vec2 ComputeLightmapUV(Object obj, vec3 V, sampler2D lightmapSampler)
{
    vec2 lightmapUV = vec2(-1);
    vec2 lightmapResInv = 1.0/vec2(textureSize(lightmapSampler, 0)); // we could pass this in ..
    if (IsQuad(obj)) {
        vec2 st;
        st.x = dot(V, obj.quadBasisX);
        st.y = dot(V, obj.quadBasisY);
        vec2 uv = st*0.5 + vec2(0.5); // [0..1]
        vec4 atlasBounds = obj.lightmapBounds;
        atlasBounds.zw -= atlasBounds.xy; // width, height
        if (float(LIGHTMAP_QUAD_INSET) < 0.5) { // don't sample outside the lightmap bounds (if we are filtering)
            vec2 uvmin = vec2(0.5)/atlasBounds.zw;
            vec2 uvmax = vec2(1) - uvmin;
            uv = clamp(uv, uvmin, uvmax);
        }
        atlasBounds *= lightmapResInv.xyxy;
        lightmapUV = atlasBounds.xy + atlasBounds.zw*uv;
    } else {
        int faceRow;
        int faceCol;
        vec2 facePos;
        vec3 Va = abs(V);
        float Vamax = max(max(Va.x, Va.y), Va.z);
        if (Vamax == Va.x) {
            faceCol = 0;
            faceRow = V.x < 0.0 ? 1 : 0;
            facePos = V.yz/Va.x;
        } else if (Vamax == Va.y) {
            faceCol = 1;
            faceRow = V.y < 0.0 ? 1 : 0;
            facePos = V.zx/Va.y;
        } else { // Vamax == Va.z
            faceCol = 2;
            faceRow = V.z < 0.0 ? 1 : 0;
            facePos = V.xy/Va.z;
        }
        vec2 faceUV = facePos*0.5 + vec2(0.5); // [0..1]
        float faceRes = GetLightmapSphereFaceRes(obj);
        vec2 faceBoundsMin = vec2(faceCol + 0, faceRow + 0)*faceRes + vec2(LIGHTMAP_SPHERE_FACE_INSET);
        vec2 faceBoundsMax = vec2(faceCol + 1, faceRow + 1)*faceRes - vec2(LIGHTMAP_SPHERE_FACE_INSET);
        vec2 uv = obj.lightmapBounds.xy + faceBoundsMin + (faceBoundsMax - faceBoundsMin)*faceUV;
        lightmapUV = uv*lightmapResInv;
    }
    return lightmapUV;
}

// Function 579
float spec_light (vec3 l, vec3 rd, vec3 n, float spec_power)
{
    vec3 h = normalize(l - rd);
    float spe = pow(max(dot(h,n),0.),spec_power);
    return spe;
}

// Function 580
vec3 light2(vec3 N, vec3 rd, vec3 color){
  float time = 10.;

    float t=3.14*0.3;
    t=time*0.3;
    t=mod(t, 3.14);
    vec3 L=vec3(cos(t), -0.5,1.*sin(t));
    L = normalize(vec3(1));
  return 4.*color*phong(normalize(-L), N, rd, 0.2, 0.15) +
         4.*color*vec3(1)*phong(vec3(1,0,0), N, rd, 0.2, 0.) + 
         4.*color*vec3(1)*phong(vec3(0,1,0), N, rd, 0.2, 0.);
}

// Function 581
float sampleLightSourcePdf( in vec3 x,
                               in vec3 wi,
                             	float d,
                              	float cosAtLight
                             ) {
    float min_x = objects[0].params_[0];			//min x
    float min_y = objects[0].params_[1];			//min y
    float max_x = objects[0].params_[2];			//max x
    float max_y = objects[0].params_[3];			//max y
    float dim_x = max_x - min_x;
    float dim_y = max_y - min_y;
    float pdfA = 1.0 / (dim_x*dim_y);
    return PdfAtoW(pdfA, d*d, cosAtLight);
}

// Function 582
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh = 1.;
  float d = 0.02;
  for (int i = 0; i < 30; i++) {
    float h = ObjDf (ro + rd * d);
    sh = min (sh, 20. * h / d);
    d += 0.02 + 0.01 * d;
    if (h < 0.001) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 583
vec4 calcLighting(vec3 samplePos, vec3 eye, Light light, Material material)
{
	float lightDist = length(light.position-samplePos);
	vec3 lightDir = normalize(light.position-samplePos);
	vec3 eyeDir = normalize(samplePos-eye);
	vec3 surfaceNormal = getNormal(samplePos);
	vec3 reflection = normalize(reflect(eyeDir, surfaceNormal));
	
	float specular = pow(max( 0.0, dot(lightDir, reflection)), 72.0);
	float diffuse = max( 0.0, dot(lightDir, surfaceNormal));
	float ambient = .05;
	
	float attenuation = min(1.0, 1.0/(lightDist/light.brightness));
	float shadow = calcShadow(samplePos, lightDir, light);
	float occlusion = calcOcclusion(samplePos, surfaceNormal);
	
	return light.color*material.color*clamp(((specular+diffuse)*shadow*attenuation)+(ambient*occlusion), 0.0, 1.0);
}

// Function 584
float GearShadow(vec2 uv, Gear g)
{
    float r = length(uv+vec2(0.1));
    float de = r - g.diskR + 0.0*(g.diskR - g.gearR);
    float eps = 0.4*g.diskR;
    return smoothstep(eps, 0., abs(de));
}

// Function 585
vec3 calculateStarlightVisibility(vec3 ray, const vec4 nebula, float startingOpticalDepth, float distFromCenter
){const int samples  = 15
 ;float stepSize = (nebula.a * 2.0) / float(samples)
 ;float dirSwitch = -1.0
 ;if (ray.y > nebula.y) dirSwitch = 1.0
 ;vec3 centralRay   = ray - nebula.xyz //centralize ray on star
 ;vec3 rayDirection = -normalize(centralRay) * stepSize
 ;        ray         += rayDirection * 0.5
 ;float opticalDepth = -startingOpticalDepth
 ;//ray.xy =(ray.xy - vec2(0.0, 1.0)) * rotate(iTime * 0.1) + vec2(0.0, 1.0)
 ;for (int i = 0; i < samples; i++, ray += rayDirection
 ){opticalDepth -= nebulaFBM(ray)*smoothstep(1.,0.,distFromCenter/Nebula_Radius);;}
 ;return exp(nebulaCoeff * stepSize * opticalDepth);}

// Function 586
vec3 getDiffuseLightColor( vec3 N ) {
    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.
    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;
}

// Function 587
vec3 lightPos() {
    float t = iMouse.z > .0 ? iTime : texture (iChannel1, vec2 (.5)).g;
	return vec3 (-1.75 + cos (t), 1.25, .0 + sin (t));
}

// Function 588
lightpath Lightpath(point p, light l, vec3 n) {
    vec3 i = vec3(0.0);
    float il = 0.0;
    if(l.type == DIRECTION_LIGHT) {
        i = -l.direction;
        il = 0.0;
    }
    else {
        i = l.position - p.position;
        il = length(i);
        i = normalize(i);
    }
    vec3 v = -p.direction;
    vec3 r = 2.0 * dot(i, n) * n - i;
    vec3 t = normalize(cross(cross(n, i), n));
    vec3 tv = normalize(cross(cross(n, v), n));
    vec3 tr = normalize(cross(cross(n, r), n));
    float energy;
    if(l.type != DIRECTION_LIGHT) {
        energy = l.intensity / pow(il, l.falloff);
        if(l.type == CONE_LIGHT)
            energy *= pow((l.spread - acos(dot(-i, l.direction))) / l.spread, l.taper);
    }
    else
        energy = l.intensity;
    return lightpath(
        p,
        l,
        n,
        il,
        i,
        v,
        r,
        vec2(dot(n, i), 0.0), // incident
        vec2(dot(n, v), dot(t, tv)), // view
        vec2(dot(n, r), dot(t, tr)), // reflected
        energy
    );
}

// Function 589
vec3 shade_cube(vec3 v, vec3 n, vec3 ntx, vec3 eye) {
	vec3 ev = normalize(v - eye);
	vec3 final = vec3(0.);
    vec3 light_pos = vec3(-10.,20.,40.);
    vec3 vl = normalize(light_pos - v);
    float diffuse = max(0.0, dot( vl, n ));
    final += 1.3 * diffuse; 
	// transform normals with the cube to find flat faces/edges
	float px = abs(dot(ntx,vec3(1.,0.,0.)));
	float py = abs(dot(ntx,vec3(0.,1.,0.)));
	float pz = abs(dot(ntx,vec3(0.,0.,1.)));
    float p = max(px,max(py,pz));
    final *= smoothstep(0.9,1.,length(p));
    return final;
}

// Function 590
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh = 1.;
  float d = 0.07 * szFac;
  for (int i = 0; i < 40; i++) {
    float h = ObjDf (ro + rd * d);
    sh = min (sh, 20. * h / d);
    d += 0.07 * szFac;
    if (h < 0.001) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 591
float shadow(vec3 ro, vec3 rd)
{
    float d = rayIntersect(ro, rd, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);
    return (d>0.) ? smoothstep(0., MAX_DIST_SHADOW, d) : 1.;
}

// Function 592
vec3 shade(vec3 color, vec3 point, vec3 normal, vec3 rd)
{
	
	vec3 dtl       = normalize(light_1 - point);
	float diffuse  = dot(dtl, normal); //diffuse
	float specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular
	vec3 c = (diffuse + specular) * color * 0.85;
	
	dtl      =  normalize(light_2 - point);
	diffuse  = dot(dtl, normal); //more diffuse
	specular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular
	return clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);
}

// Function 593
float capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k ) {
    vec3 ba =  b - a, oa = ro - a;
    // closest distance between ray and segment
	float oad  = dot( oa, rd ), dba  = dot( rd, ba ),
		  baba = dot( ba, ba ), oaba = dot( oa, ba );
	vec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);
	th.x = max(   th.x, .0001 );
	th.y = clamp( th.y, .0, 1. );
	vec3  p =  a + ba*th.y, q = ro + rd*th.x;
    float d = length( p-q )-r;
    // fake shadow
    float s = clamp( k*d/th.x, 0., 1. );
    return s*s*(3.-2.*s);
}

// Function 594
float shadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {
    float t = tmin;
    for( int i=0; i<10; ++i )
    {
		float h = map( ro + rd*t ).x;
        if( h<tmin || t>tmax) break;
        t+=h;//float(i)/30.0;
    }
    return clamp(1.0-(tmax-t)/(tmax-tmin), 0.0, 1.0);
}

// Function 595
void MarchLight(inout RayInfo r, float startTime, float maxDist
){float totalDist = 0.0
 ;vec3 origin = r.b
 ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++
 ){r.time = startTime
  ;SetTime(r.time)
  ;r.dist = map(r.b,-1)
  ;totalDist += r.dist
  ;r.b+= r.dir*(r.dist)
  ;if(abs(r.dist)<rayEps||totalDist>maxDist)break;}}

// Function 596
vec2 sampleLight() {
    if(iMouse.xy == vec2(0.0)) {
        float angle = iTime * 2.0;
        return (0.15 * vec2(sin(angle), cos(angle)) + 0.5) * iResolution.xy / iResolution.y;
    }
    return iMouse.xy / iResolution.y;
}

// Function 597
vec3 shadeTable(in vec3 pos, in vec3 ray) {
    vec3 nor = getNormal(shapeTable, pos);
   
    float sha = calcSoftshadow( pos + nor*0.01, 8.0 );
    float occ = calcOcclusion(pos, nor);
    float atten = clamp(dot(nor, lig), 0.0, 1.0) * 0.7 + 0.3;
    float spec = phong(lig, ray, nor, 16.0) * sha;
               
    vec3 tex = triPlanar(iChannel1, pos, nor);
    vec3 col = tex;
   
    if (pos.y > -0.55)
        col = vec3(0.1, 0.3, 1.0) * atten;
   
    if (pos.y <= -0.599)
        spec = spec * tex.r * tex.r;
    else {
        float n = perlinNoise(pos * 200.0);
        spec = spec * n + n * 0.01;
       
        col = triPlanar(iChannel1, pos, nor);
       
        col.r = 0.8;
    }
   
    col *= 0.5 + sha * atten * 0.5;
    col *= occ;
   
    col += spec;
   
    return col;
}

// Function 598
float shadow(vec3 pos, vec3 sdir) {
	float sh=1.0;
	float totdist = DETAIL*10.;
	float dist=1000.;
		for (int steps=0; steps<SHADOW_STEPS; steps++) {
			if (totdist<MAX_DIST && dist>DETAIL) {
				vec3 p = pos - totdist * sdir;
				dist = de(p);
				sh = min(sh, 10.*max(0.0,dist)/totdist);
				sh*= sign(max(0.,dist-DETAIL));
				totdist += max(0.02,dist);
			}
#ifdef LOOP_BREAKS		
		else break;
#endif
		}
	
	return clamp(sh,0.,1.0);
}

// Function 599
void initDynamicLights(vec3 p) {
    #if nLights != 0
 #endif
}

// Function 600
float calcShadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<100; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = mapShadow( pos ).x;
        res = min( res, 16.0*max(h,0.0)/t );
        if( h<0.0001 || pos.y>3.0 ) break;
        
        t += clamp(h,0.01,0.2);
    }
    
    return clamp(res,0.0,1.0);
}

// Function 601
vec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL
	#ifdef ENABLE_HARD_SHADOWS
		float sh=shadow(p, lightdir);
	#else
		float sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS
	#endif
	float ao=calcAO(p,n);
	float diff=max(0.,dot(lightdir,-n))*sh;
	float y=3.35-p.y;
	vec3 amb=max(.5,dot(dir,-n))*.5*AMBIENT_COLOR;
	if (hid<.5) {
		amb+=max(0.2,dot(vec3(0.,1.,0.),-n))*FLOOR_COLOR*pow(max(0.,.2-abs(3.-p.y))/.2,1.5)*2.;
		amb+=energy*pow(max(0.,.4-abs(y))/.4,2.)*max(0.2,dot(vec3(0.,-sign(y),0.),-n))*2.;
	}
	vec3 r = reflect(lightdir,n);
	float spec=pow(max(0.,dot(dir,-r))*sh,10.);
	vec3 col;
	float energysource=pow(max(0.,.04-abs(y))/.04,4.)*2.;
	if (hid>1.5) {col=vec3(1.); spec=spec*spec;}
	else{
		float k=_texture(p)*.23+.2; 
		k=min(k,1.5-energysource);
		col=mix(vec3(k,k*k,k*k*k),vec3(k),.3);
		if (abs(hid-1.)<.001) col*=FLOOR_COLOR*1.3;
	}
	col=col*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;	
	if (hid<.5) { 
		col=max(col,energy*2.*energysource);
	}
	col*=min(1.,ao+length(energy)*.5*max(0.,.1-abs(y))/.1);
	return col;
}

// Function 602
vec3 shade(vec3 pos, float mat, vec3 rd) {
    vec3 col;
    if (mat < 0.5) return mix(vec3(0.8, 0.9, 1.), vec3(0.2, 0.2, 0.3), pow(abs(rd.y), 3.5));
    else if (mat < 1.5) col = vec3(0.6, 0.3, 0.8);
    else col = vec3(0.4, 1., 0.4);
    vec4 n = getnormal(pos);
    float fac = dot(n.xyz, lightdir);
    fac = min(fac, shadowtrace(pos + lightdir * shadoweps, lightdir));
    fac = max(0.8, fac);

    return fac * col;
}

// Function 603
float lightPhotonStartTime( vec3 finalPos, float finalTime )
{
    float startTime = finalTime;
    
    // my old friend FPI
    for( int i = 0; i < 3; i++ )
    {
        startTime = finalTime - light_time_per_m() * length( light( startTime ) - finalPos );
    }
    
    return startTime;
}

// Function 604
vec3 computeLight(vec3 position, vec3 color, vec3 normal, vec3 viewVec, vec3 lp1, vec3 lp2) {
    vec3 lightPos = lp1 + randDir * LIGHT1_RADIUS;
    vec3 toLight = lightPos - position;
    bool occl = isOccluded(position + normalize(toLight) * EPS, lightPos);
    float lightAtten = 20.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);

    vec3 light2Pos = lp2 + randDir * LIGHT2_RADIUS;
    vec3 toLight2 = light2Pos - position;
    bool occl2 = isOccluded(position + normalize(toLight2) * 1e-3, light2Pos);
    float light2Atten = 10.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);

    return color * (
        max(0.0f, dot(normal, normalize(toLight))) * lightAtten * LIGHT1_COLOR
        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * LIGHT2_COLOR
        + textureLod(iChannel1, viewVec, 10.0) * 0.3).rgb;
}

// Function 605
float shadow(vec3 from, vec3 increment)
{
	const float minDist = 1.0;
	
	float res = 1.0;
	float t = 0.25;
	for(int i = 0; i < 10; i++)
    {
        float h = distanceField(from + increment * t);
        
		res = min(res, 4.0 * h / t);
        t += 0.25;
    }
    return res;
}

// Function 606
float softshadow(vec3 ro,vec3 rd) 
{
    float sh=1.;
    float t=.02;
    float h=.0;
    for(int i=0;i<22;i++)  
	{
        if(t>20.)continue;
        h=map(ro+rd*t);
        sh=min(sh,4.*h/t);
        t+=h;
    }
    return sh;
}

// Function 607
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )
{
    float res = 1.0;
    float t = mint;
    
    // first things first - let's do a bounding volume test
    float tm = (480.0-ro.y)/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);
    
    // raymarch and track penumbra
    for( int i=ZERO; i<128; i++ )
    {
        float kk; vec3 kk2;
		float h = map( ro + rd*t, time, kk, kk2 ).x;
        res = min( res, k*h/t );
        t += clamp( h, 0.05, 25.0 );
        if( res<0.002 || t>tmax ) break;
    }
    return max( res, 0.0 );
}

// Function 608
void shaderLeon( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)
{
  vec2 uv = (fragCoord.xy-0.5*resolution.xy)/resolution.y;
  vec3 eye = vec3(.1,.1,-iTime*.1-4.);
  vec3 at = vec3(0,0,eye.z-2.0);
  vec3 ray = look(eye, at, uv);
  vec3 pos = eye;
  float dither = random(uv+fract(iTime));
  float total = dither * .2;
  float shade = 0.0;
  const float count = 60.0;
  for (float index = count; index > 0.0; --index) {
    pos = eye + ray * total;
    float dist = map(pos);
    if (dist < 0.001 + total * .003) {
      shade = index / count;
      break;
    }
    dist *= 0.5 + 0.1 * dither;
    total += dist;
  }
  vec3 normal = getNormal(pos);
  vec3 color = vec3(0);
  color += smoothstep(.3, .6, fbm(pos*100.)) * .2;
  color += vec3(0.839, 1, 1) * pow(clamp(dot(normal, normalize(vec3(0,2,1))), 0.0, 1.0), 4.);
  color += vec3(1, 0.725, 0.580) * pow(clamp(dot(normal, -normalize(pos-at)), 0.0, 1.0), 4.);
  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(4,0,1))), 0.0, 1.0), 4.);
  color += vec3(0.972, 1, 0.839) * pow(clamp(dot(normal, normalize(vec3(-5,0,1)))*.5+.5, 0.0, 1.0), 4.);
  color = mix(vec3(0), color, clamp(dot(normal, -ray), 0.0, 1.0));
  color *= pow(shade, 1.0/1.2);
  fragColor = vec4(color, 1);
}

// Function 609
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 4., occ = 0.0;
    for( int i=1; i<6; i++ ){
    
        float hr = float(i)*.125/5.;        
        float dd = map(p + hr*n);
        occ += (hr - dd)*sca;
        sca *= .75;
    }
    return clamp(1. - occ, 0., 1.);   
    
}

// Function 610
float My_milk_shadow(vec3 surface, vec3 lig_p,float mintd, float maxdd, float k0,float k1,float k3) {
	float start_d = mintd;
	float d = 0.0;
	float mind = 1.0;
	for(int i = 0; i < 20; i++) {		
		d = obj(surface + start_d*lig_p).x;
		mind = min(mind, abs(log(d*k0+k3))/k1 );
		start_d += d;
		if(start_d > maxdd) break;
	}
	return mind;
}

// Function 611
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 612
float shadow( in vec3 X, in vec3 n, in vec3 L )
{
	float mint = 0.001;
	float maxt = 20.0;
	
	X += n*.01;
	
	float h=0.4;
	float sharpness = 25.;
	float soft=1.0;
	float t = mint;
	for (int i=0; i<32; i++)
    {
        float d = sdf(X + L*t, bvec4(1,1,1,1));
        if( d<-0.1 )
            return h; //t*h;
		
		soft = min( soft, (sharpness*d)*(1./t));
		
		if (t > maxt) break;
        t += d * 0.9;
    }
    return clamp(soft,h,1.0);
}

// Function 613
float softshadow(in vec3 ro, in vec3 rd, in float maxt)
{
    float res = 1.0;
    float t = 0.001;
	for( int i=0; i<80; i++ )
	{
	    vec3  p = ro + t*rd;
        float h = dstScene(p).x;
		res = min( res, 16.0*h/t );
		t += h;
		if( res<0.001 ||p.y > maxt) break;
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 614
float shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<15; i++ )
    {
		float h = map(ro + rd*t);
        res = min( res, 4.*h/t );
        t += clamp( h, 0.01, .1 );
        if(h<0.001 || t>tmax) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 615
vec3 shade(vec3 ro, vec3 rd) {
    vec3 col = mix(FOG_COLOR,vec3(.4,.6,.9),clamp(pow(rd.y+.5,.7)-.25,0.,1.));
    vec2 scn = raymarch(ro, rd, MAX_ITERATIONS);
    if(scn.y == 0.) {
        vec3 p = ro+rd*scn.x;
        vec3 n = calcNormal(p,scn.x);
        vec3 r = normalize(reflect(rd, n));
        
        col = shadeCoaster(p,n,r);
        
        vec3 rc = vec3(.4,.6,.9);
        vec2 rs = raymarch(p+r*SHADOW_BIAS,r,128);
        if(rs.y >= 0.) {
            vec3 rp = p+r*rs.x;
            vec3 rn = calcNormal(p,rs.x);
            vec3 rr = normalize(reflect(r,rn));
            if(rs.y == 0.) {
                rc = shadeCoaster(rp,rn,rr);
            } else if(rs.y == 1.) {
                rc = shadeGround(rp,rn,rr);
            }
        }
        
        float f = 1.-clamp(pow(-dot(rd,n),.2),0.,1.);
        col = mix(col, rc, f);
    } else if(scn.y == 1.) {
        vec3 p = ro+rd*scn.x;
        vec3 n = vec3(0.,1.,0.);
        vec3 r = normalize(reflect(rd,n));
        
        col = shadeGround(p,n,r);
    }
    if(scn.y >= 0.) {
        float f = 1.-(1./(pow(E,pow(scn.x*FOG_DENSITY,2.))));
        col = mix(col, FOG_COLOR, f);
    }
    return col;
}

// Function 616
vec3 Sample_SphLight_ClmpCos(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    vec3 L;
    {
        float h0 = Hash11(h);
        float h1 = Hash01(h);

        L = Sample_ClampedCosineLobe(h0, h1, N);
    }

    float t2; vec3 n2; vec3 a2; bool isLight2 = true;
    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);

    if(!isLight2) return vec3(0.0);
    
    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * pi;
}

// Function 617
vec3 Light(int m, vec3 p, vec3 v, float d, float rnd)
{
    float h = 3e-4 * (d + 1.) //2e-3 * clamp(d, .01, 100.) //
    , hd;
    vec3 n = SceneNormal(p, h, hd, IZERO)
    , albedo = Material(m, p, n, d)
    , c = albedo;
    float nl = Shadow(p, n, sunDir, hd, d, rnd, shadowsteps + IZERO)
    , fogscale = fogdensity // / dmax * 8.5e4; // TODO scale by dmax somehow?
    , fexp = exp2(-fogscale * d);
    // TODO replace with custom illumination
    c *= nl * mix(sunDir.y, 1., .5+.5*nitebrite);
    vec3 cfog = (csky // fake optical depth for atmo, fake sky coloration, inscatter color
        + (1.-fexp) * .7 * pow(clamp(1.-abs(v.y), 0., 1.), 8.) // fake all the things!  distant horizon fog
        ) * mix(sunDir.y, 1., .5 + .25 * nitebrite)
        + .87*pow(max(0., dot(-v, sunDir) * .5 + .5), 16.); // fake mie, sun halo
    c = mix(cfog, c, fexp)*csun; // simple fog Beer's law (not spectral, extinction&inscatter fused)
    c = clamp(c, 0., 1.);
//    if (hd <-2e-3*d) c = vec3(20,1,0); // DEBUG orange where march penetrated surface - usually only happens in the far distance where rays hit at very shallow angles, presumably due to numerical inaccuracy
//    if (hd > 2e-3*d) c = vec3(10,0,9); // DEBUG violet where march missed surface
    //c *= n * .5 + .5; // DEBUG hit normal
    return c;
}

// Function 618
float shadow( in vec3 ro, in vec3 rd )
{
	float res = 1.0;
	for( int i=0; i<NUMSPHEREES; i++ )
	{
		float id = float(i);
	    float t = sSphere( ro, rd, sphere[i] ); 
		res = min( t, res );
	}
    return res;					  
}

// Function 619
float soft_shadow(vec3 ro, vec3 rd) {
    float res = 1.;
    float t = .0001;                     
	float h = 1.;
    for(int i = 0; i <20; i++) {         
        h = eval_scene(ro + rd*t).d;
        res = min(res, 4.*h/t);          
		t += clamp(h, .02, 1.);          
    }
    return clamp(res, 0., 1.);
}

// Function 620
float softShadow(in vec3 ro, in vec3 rd, float k)
{
    float t = 0.0 + 100.0 * EPSILON;
    float res = 1.0;
    for(int i = 0; i < MAXSTEPS; ++i) {
        float d = map(ro + rd * t);
        if(d < EPSILON) {
            return 0.0;
        }
        res = min( res, k*d/t );
        t += d;
    }
    return res;
    
}

// Function 621
float vxlAO(vec3 vp, vec3 sp, vec3 nor, vec3 alig) 
{
    sp = fract(sp/scl);
    vec2 uv = sp.yz*alig.x + sp.zx*alig.y + sp.xy*alig.z;
    vec3 p = vp + nor*scl;
    alig *= scl;
    vec4 side = step(vec4(map(p + alig.zxy).x, map(p + alig.yzx).x, map(p - alig.zxy).x, map(p - alig.yzx).x), vec4(0));
    vec4 cornr = vec4(map(p + alig.zxy + alig.yzx).x, map(p - alig.zxy + alig.yzx).x,
                      map(p - alig.zxy - alig.yzx).x, map(p + alig.zxy - alig.yzx).x);
    vec4 faceOcc = 1.0 - (side + side.yzwx + max(step(cornr, vec4(0)), side*side.yzwx))/3.;
    return mix(mix(faceOcc.z, faceOcc.w, uv.x), mix(faceOcc.y, faceOcc.x, uv.x), uv.y);
}

// Function 622
vec3 shadeWall( vec3 p, 
                vec3 n,
                vec3 rdir )
{

    float kd = .3;
    float ks = .9;

    vec3 diffcol = vec3(0.0);
    vec3 speccol = vec3(0.0);
    vec3 ambcol = vec3(0.018, 0.013, 0.013);

    // DIFFUSE

    // jittered samples of the 8 corners of the heat box to get a
    // diffuse response.  Consider a box of dimension 2x2x2 centered
    // at the origin.  In the corner  around the normalized
    // coordinates (-.75, -.75, -.75), I jitter within  the range
    // [(-1, -1., -1.), (-.5, -.5, -.5)].  This is a hack that  gives
    // us bias coverage towards the outside of the heatbox, but since
    // we distance attenuate, one can argue the outer portions of the
    // box are more important in a hackish importance sampled scheme.

    // Here's a cross section of one side of the heat box.  The small
    // dots  in each corner represent the area in which the jittering
    // can happen and the x represents an example spot in which there
    // could be a color  lookup to drive the diffuse response on the
    // wall.

    // * --------------- *
    // | x  .   |   .x . |
    // | .  .   |   .  . |
    // |        |        |
    // |-----------------|
    // |        |        |
    // | . x.   |   .  . |
    // | .  .   |   .x . |
    // * --------------- *
    
#if BOXWALL_DIFFUSE
    
    vec3 lightp = vec3(0.);
    float halfBoxSize = .5 * NUM_CELLBOXES * CELLBOX_SIZE;
    for (float x = 0.; x < 2.; x++ ) {
        lightp.x = (-.75 + (1.5 * x)) * halfBoxSize;
    for (float y = 0.; y < 2.; y++ ) {
        lightp.y = (-.75 + (1.5 * y)) * halfBoxSize;
    for (float z = 0.; z < 2.; z++ ) {
        lightp.z = (-.75 + (1.5 * z)) * halfBoxSize;

        float noiseseed = x + 2. * y + 4. * z + 10. * g_time;
        vec3 noiseoffset = halfBoxSize * (noise1v( noiseseed ) - .5);

        vec3 ldir = (lightp + noiseoffset) - p;
        vec3 nldir = normalize(ldir);
        
        vec3 cellCoords = ceil(lightp / CELLBOX_SIZE);
        vec3 dfresult = spheredf( lightp, cellCoords );
                
        if (dfresult.y < 1.5)
        {
            float lenldir = length(ldir);
            float diffuse = clamp( dot( n, nldir ), 0., 1.);
            // attenuate falloff by a distance metric.
            float distatten = max(0., 1. - (lenldir/80.));
            // have the light falloff by a square factor
            distatten *= distatten;
            diffcol += diffuse * distatten * sphereColor(dfresult.z);
        }

    } } }

    diffcol /= 8.;
    diffcol *= 5. * vec3(0.4, .4, .5);
    
#endif

    // SPECULAR

    // Reflect the scene but have it fall off dramatically to give
    // a kind of deep onyx look.

#if BOXWALL_REFLECTIONS
    vec3 reflmarch = distmarch( p, rdir, 21. );

    if (reflmarch.y > 0.5 && reflmarch.y < 1.5) 
    {
        float distatten = max(0., 1. - reflmarch.x/30.);
        distatten *= distatten;
        speccol = distatten * sphereColor(reflmarch.z);
    }
#endif
    return ambcol + kd * diffcol + ks * speccol;
}

// Function 623
light ambientLight(vec3 color, float intensity) {
    return  light(
        AMBIENT_LIGHT, // type
        vec3(0.0), // position (N/A)
        color, // color
        intensity, // intensity
        vec3(0.0), //direction (N/A)
        0.0, // falloff (N/A)
        0.0, // spread (N/A)
        0.0 // taper (N/A)
    );
}

// Function 624
vec3 lighting(
    float depth,
    vec3 ro,
    vec3 rd,
    vec3 n,
    vec3 _light,
    float type,
    vec4 shield,
    mat3 M,
    vec2 _screenpos)
{
    vec3 roWorld = ro+vec3(0.0, EARTHRADIUS, 0.0);
    float dnz = NORMALIZEDEPTH(depth);
    mat2 R2D = mat2(0.6, -0.4, 0.4, 0.6);
    mat3 R3D = mat3(0.6, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.6);
	vec3 color = vec3(0.0);

    float ground = float(depth>RAYMARCH_NEAR && depth<RAYMARCH_FAR);
 
    
    vec3 colorGround = vec3(0.0);
    
    vec3 Pground = (roWorld+depth*rd);
    float depthS = 1.0-abs(rd.y-0.5)*2.0;
    vec3 Psky = vec3(rd.x*depthS, 1000.0, rd.z*depthS);
    vec3 Nground = mix(
                n,
                detailsNormalTrees(n, n*1000.0),
        	type-TYPE_GRASS);
    vec3 L = -normalize(_light);
    
    vec3 rdmie = -normalize(vec3(L.x, L.y, SUNDIST));
    rdmie = normalize(vec3(0.0, 1.2, 1.0));
    vec3 mieColor = getMieColor(roWorld, rdmie, L);
    
    colorGround = lightingGrass(depth, Pground, Nground, L, type, _screenpos);
    
    // adding dirt
    float dirtA = hash1(Pground.x);
    
    float RoL = dot(-rd, L);
    
    // SKY
    vec2 C = clouds(Psky.xz*0.1+TIME*0.005, 100., RoL);
    float Cc = C.x * (1.0-C.x)*max(0.0, dot(-L, vec3(C.x)));
    vec3 colorSky = getSkyColor(roWorld, rd, L, false);
    colorSky = C.x*colorSky+(1.-C.x)*C.y*tonemapping(mieColor);
        //clamp(mix(C.x, Cc, C.x), 0.0, 1.0);
    
    // fog
    // wtf...
    vec3 fogColor = tonemapping(mieColor);

    color = mix(
        		colorSky,
        		colorGround,
        		ground);
    float fogContrib = max(rd.y*4., exp(-4.*dnz));
    color = applyFog(color, fogColor, RoL, clamp(3.*rd.y, 0., 1.)+exp(-4.*dnz), 0.);
    //return vec3(clamp(4.*rd.y, 0., 1.));

    // shield
        
    float tmin = 0.0;
    float tmax = 0.0;
    float radius = 1.0;
    
    vec3 Pshield = ro+rd*shield.x;
    
    vec3 Nshield = normalize(Pshield-gTarget);
    vec2 tilesUV = Pshield.xz;
    tilesUV.y += sin((Pshield.x)*10.0)*0.01;
    float a;
    Nshield += hex(tilesUV*1.5, a, a).xyz;
    Nshield = normalize(Nshield);
    
    float Lfact = max(0.0, dot(Nshield, L));
    
    float F = Fresnel_Schlick(1.0, 1.9, max(0.0, dot(Nshield, -rd)));
    
    vec4 gbuffer = texture(iChannel0, _screenpos+F);
    float depthr = gbuffer.x;
    float typer = gbuffer.w;
    vec3 ror = Pground;
    vec3 nr = normal_decode(gbuffer.yz);
    vec3 NR = mix(
                n,
                detailsNormalTrees(nr, nr*1000.0),
        	type-TYPE_GRASS);
    float dnzr = NORMALIZEDEPTH(depthr);
    
    vec3 rdr = rd*F;
    vec3 colorRefrGround = lightingGrass(
        			depthr,
        			Pshield+rdr*max(0., shield.y-shield.x),
        			Nground,
        			L,
        			typer,
        			_screenpos);
    vec3 rdReflect = reflect(rd, Nshield);
    vec3 colorReflSky = getSkyColor(
        Pshield+vec3(0.0, EARTHRADIUS, 0.0), rdReflect, L, false);
    colorReflSky = applyFog(colorReflSky, fogColor, RoL, rdReflect.y, 0.012);

    vec3 colorShield = vec3(1.0, 1.0, 1.0)*mix(
    	                depthr<RAYMARCH_FAR?colorRefrGround:color,
       				 	colorReflSky,
        				F);
    if(shield.w>0.0 && shield.x<depth)
    {
    	color = colorShield*max(0., (1.-.05*(shield.y-shield.x)));
    }
    /*if(shield.w>0.0 && shield.x<depth)
    {
        float F4 = (1.0-F)*(1.0-F)*(1.0-F)*(1.0-F);
        colorShield = mix(
            	colorShield,
            	vec3(0.2, 0.4, 0.6),
            	F4*F4*F4);
        color = colorShield+Lfact*F;
        color = mix(color,
                    clamp(color, 0.0, 1.0),
                    clamp(
                        max(1.0-abs(shield.y-depth),
                        1.0-abs(shield.x-depth)),
                        0.0, 1.0)
                    );
    }*/
	//return fogColor;
    return tonemapping(color);
}

// Function 625
vec3 GetLightIntensity(){
	return AreaLightIntersity*LIGHTCOLOR;
}

// Function 626
vec3 phongContribForLight(Ray ray, Intersect intersection, Light light) {
    vec3 N = intersection.normal; //object normal
    vec3 L = normalize(light.position - intersection.position); //light direction
    vec3 V = normalize(ray.origin - intersection.position); // ray direction
    vec3 R = normalize(reflect(-L, intersection.normal)); // reflect direction

    float dotLN = dot(L, N);
    float dotRV = dot(R, V);

    //check if we face light
    if (dotLN < 0.0) {
        return vec3(0);
    } 

    //attenuate light strength with distance from source
    float Ldist = length(light.position - intersection.position); //light dist
    float attenuation = 1.0 / (light.constant + light.linear * Ldist + 
                               light.quadratic * (pow(Ldist,2.0)));

    //compute diffuse contribution
    vec3 diffuse = light.diffuse*intersection.material.diffuse * dotLN;

    //check if is in shadow of light source
    if (isInSpheresShadow(intersection, light)){
        return 0.5*diffuse;
    }

    //check if light specular reflection point to us
    if (dotRV < 0.0) {
        return diffuse*attenuation;
    }

    //compute specular contribution
    vec3 specular = light.specular*intersection.material.specular * pow(dotRV, intersection.material.shininess * 128.0);

    return (diffuse+specular)*attenuation;

}

// Function 627
vec3 bgShadedColor() {
	vec2 off = vec2(0.01 * iTime, 0);
	vec2 pos = 0.5 * fragCoord.xy / iResolution.xy;
    vec3 rgb = texture(iChannel1, off + pos).xyz;
	float b = (rgb.x + rgb.y + rgb.z) * 0.33;
	b = 0.1 + 1.0 * b;
	return b * bgColor;
}

// Function 628
vec4 GetLight(vec3 p) {
    vec3 lightPos[3];
    lightPos[0] = vec3(5, 6, 0);
    lightPos[1] = vec3(-2, 5, 1);
    lightPos[2] = vec3(-4, 10, 10);
    
    vec3 lightCol[3];
    lightCol[0] = vec3(0.1, 0.3, 0.05);
    lightCol[1] = vec3(0.4, 0.2, 0.2);
    lightCol[2] = vec3(0.1, 0.1, 0.3);
    
    vec4 col = vec4(0.0);
    
    for(int i; i<3; i++) {
        vec3 l = normalize(lightPos[i]-p);
        vec3 n = GetNormal(p);
        
        float dif = clamp(dot(n, l), 0.0, 1.0);
        float d = RayMarch(p+n*SURF_DIST*2.0, l);
        if(d<length(lightPos[i]-p)) dif *= 0.1;
        
        col += dif * vec4(lightCol[i], 1.0);
    }
    
    return col;
}

// Function 629
float sampleLightY(sampler2D channel, vec2 fragCoord)
{
    float light = 0.0;
#   define S(DX, DY, WEIGHT) light += texture(channel, (fragCoord+vec2(DX, DY))/iResolution.xy).y*WEIGHT;
    S( 0,  1, -0.2)
    S( 0, -1,  0.2)
    S( 1,  0,  0.2)
    S(-1,  0, -0.2)
#   undef S
    return light;
}

// Function 630
vec4 computeVolumetricLighting(vec4 material, float mediumD, float stepD, vec4 insTrans)
{
    vec3 emissiveColour = blackBodyToRGB(2500.0 + material.y * 2500.0, 3000.0);
    float stepTransmittance = computeVolumetricTransmittance(material, mediumD, stepD);
    insTrans.rgb += insTrans.a *
        (1.0 - stepTransmittance) * emissiveColour;
    insTrans.a *= stepTransmittance;
    
    return insTrans;
}

// Function 631
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<40; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
		t += clamp( h, 0.05, 0.5 );
		if( h<0.0001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 632
float cao(in vec3 p, in vec3 n){
	
    float sca = 2., occ = 0.;
    for(float i=0.; i<6.; i++){
    
        float hr = .01 + i*.75/5.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.8;
    }
    
    return clamp(1.0 - occ, 0., 1.);    
    
    
}

// Function 633
vec3 computeLighting( in vec3 surfaceAlbedo,
                      in vec3 surfaceNormal,
                      in float surfaceGloss,
                      in vec3 lightCol,
                      in vec3 lightDir,
                      in float lightSpec,
                      in float lightAmb )
{
    float dot_n  = clamp(dot(surfaceNormal, lightDir), 0.0, 1.0);
    
    vec3 diffuse  = lightCol * surfaceAlbedo * clamp(dot_n, lightAmb, 1.0);
    vec3 specular = lightCol * float(dot_n > 0.0) * pow(clamp(dot(reflect(-lightDir, surfaceNormal), vec3(0.0, 0.0, 1.0)), 0.0, 1.0), surfaceGloss);
    
    return diffuse + specular * lightSpec;
}

// Function 634
vec3 ComputePointLight(vec3 p,vec3 n, vec3 r, PointLight light, inout vec3 specular) {

    vec3 l = light.position - p;
    float distance = length(l);
    vec3 l_nor = l/distance;

    float lambertian = max(dot(n, l_nor),0.0);

    if (lambertian == 0.0)
        return vec3(0);

    float attenuation =  1.0/(distance*distance + 1.0);
    float s = 1.0;

    if (distance < light.shadow_dist)
        s = Shadow(p, n ,l_nor, distance);

    vec3 c = s * light.energy * light.color * attenuation;

    specular += Specular(l_nor, n, -r, 100.0) * c;

    return lambertian * c;

}

// Function 635
vec3 shade( vec3 pos, vec3 nrm, vec4 light )
{
	vec3 toLight = light.xyz - pos;
	
	float toLightLen = length( toLight );
	toLight = normalize( toLight );
	
	float comb = 0.1;
	float vis = softshadow( pos, toLight, 0.02, 2.5 );
	//float vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );
	
	if ( vis > 0.0 )
	{
		float diff = 2.0 * max( 0.0, dot( nrm, toLight ) );
		float attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );
		comb += diff * attn * vis;
	}
	
	return vec3( comb, comb, comb );
}

// Function 636
float calcShadowArlo( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    
    // check bounding volume first
    vec2 bv = sphIntersect( ro, rd, vec4(-0.5,0.5,0.0,3.4) );
    if( bv.y>0.0 )
    {
        float t = 0.01;
        for( int i=0; i<32; i++ )
        {
            float h = mapArloSimple(ro + rd*t );
            res = min( res, smoothstep(0.0,1.0,k*h/t) );
            t += clamp( h, 0.04, 0.5 );
		    if( res<0.01 ) break;
        }
    }
    return clamp(res,0.0,1.0);
}

// Function 637
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<60; i++ )
    {
		if( t<maxt )
		{
        	float h = map( ro + rd*t ).x;
        	res = min( res, k*h/t );
        	t += 0.02;
		}
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 638
vec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol )
{
	vec3 light = lightCol*max(.0,dot(normal,lightDir));
	light += mix( vec3(.01,.04,.08), vec3(.1), (-normal.y+1.0) ); // ambient
	
	
	vec3 h = normalize(lightDir-ray);
	vec3 specular = lightCol*pow(max(.0,dot(normal,h)), 1000.0)*1000.0/32.0;
	
	vec3 reflection = Sky( reflect(ray,normal) );
	float fresnel = pow( 1.0+dot(normal,ray), 5.0 );
	fresnel = mix( .0, .2, fresnel );
	
	vec3 albedo = vec3(.8,.02,0);
	
	return mix( light*albedo, reflection, fresnel ) + specular;
}

// Function 639
float RectLight_calcWeight(in vec3 P, in vec3 R, in RectLight light, float theta)
{
    // Intersect ray and light plane.
    float RoPlN = dot(R, light.basis[2]);
    float d = dot(light.basis[2], light.position - P) / RoPlN;
    if (d < 0.0 || RoPlN > 0.0) {
        // Intersection behind ray, or direction is away from plane.
    	return 0.0;
    }
    // PlC: Point on plane.
    vec3 PlC = P + d*R - light.position;
    // uvPl: UV coordinate on plane.
    vec2 PlUV = vec2(dot(PlC, light.basis[0]), dot(PlC, light.basis[1]));
    // r: Radius of cone at distance d.
    float r = d * tan(theta);
    // s: Rect size shifted by radius. This for weigth 1 inside the rect.
    vec2 s = max(light.size - 0.5*r, 0.0);
    // h: Distance from rect on plane.
    float h = length(max(abs(PlUV) - s, 0.0));
    // sr: Steradians from the sphere cap equation: sr = 2pi * (1-cos(a))
    float sr = 2.0*PI * (1.0 - cos(theta));
    // This distribution f(x) has variance v^2 = 1/2, hence
    // v = (1/2)^(1/2) = 2^(-1/2) = INVSQRT2. Using this we can
    // linearly map h = [0,2r] -> x = [0,3v]. Why 3v is to cover
    // approximately 100% of the distribution. 
    return exp(-sqr((3.0*INVSQRT2/2.0) * (h/r))) / (light.attenuation + sqr(d)*sr);
}

// Function 640
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += h;
		if( t>maxt ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 641
float GetLight(vec3 p){
    //position of the light source
    vec3 lightPos = vec3(0,5,6);
    
    lightPos.xz *= Rot(sin(iTime));
    //light vector
    vec3 l = normalize(lightPos-p+vec3(4,0,0));
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);
    if(d < length(lightPos-p)){
        diff *= 0.1;
    }
    return diff;
}

// Function 642
float softshadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.0;
	float h = 1.0;
    for( int i=0; i<60; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.02, 1.0 );
		if( h<0.001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 643
vec4 shade(Ray ray) {
 
    Hit scene = raymarch(ray);
    
    if(scene.dist.id == 0) {

        vec3 n  = normal(scene.p);
        vec3 rd = reflect(ray.dir, n);
        
        return texture(iChannel0, rd);
        
    }
    
    return texture(iChannel0, ray.dir);
    
}

// Function 644
vec3 shadeObjectFlat(Ray ray, Hit scn, vec3 n) {
    
    vec3 l = calcLighting(scn, n);
    vec3 s = vec3(max(pow(dot(reflect(ray.dir,n),LIGHT_DIR), 60.), 0.));
    s *= l;
    
    return l + s;
    
}

// Function 645
vec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, out vec3 miecolor)
{
    vec3 light = vec3(0.0);
    float tmin = 0.0;
    float tmax = 0.0;
    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);
    vec3 Pa = ro+rd*tmax;
    /*if(d>0.0)
        Pa = ro+rd*(tmax-tmin);*/
    float RdotL = dot(rd, L);
    float tCurrent = 0.0;
    float segL = tmax/16.0;
    /*if(d>0.0)
        segL = (tmax-tmin)/16.0;*/
    float g = 0.76; // 0.76
    float g2 = g*g;
    float hr = 7994.0; // 7994
    float hm = 300.0; // 1200
    // Rayleigh
    vec3 sumR = vec3(0.0);
    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);
    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);
    float opticalDepthR = 0.0;
    // Mie
    vec3 sumM = vec3(0.0);
    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));
    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html
    // my implementation has an error with the first terms in the equation
    float phaseM = (
        			(3.0*(1.0-g2))/
        			(2.0*(2.0+g2))
        			)*
        			(
                        (1.0+RdotL*RdotL)/
                        pow(1.0+g2-2.0*g*RdotL, 1.5)
                    );
    //vec3 betaM = vec3(21e-6);
    float opticalDepthM = 0.0;
    float cloudScat = 0.0;
    for (int i = 0; i < 16; ++i)
    {
        vec3 X = ro+rd*(tCurrent+0.5*segL);
        float h = length(X) - EARTHRADIUS;
        float _hr = exp(-h/hr)*segL;
        float _hm = exp(-h/hm)*segL;
        opticalDepthR += _hr;
        opticalDepthM += _hm;
        vec3 lRay = L;//normalize((SUNDIST*L)-X);
        float tlmin = 0.0;
        float tlmax = 0.0;
        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);
        float segLLight = tlmax/8.0;
        float tCurrentLight = 0.0;
        float opticalDepthLightR = 0.0;
        float opticalDepthLightM = 0.0;
        bool ended = true;
        float cloudDensity = 0.0;
        for (int j = 0; j < 8; ++j)
        {
            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);
            float hLight = length(samplePositionLight) - EARTHRADIUS;
            if (hLight < 0.0)
            {
                ended = false;
                break;
            }
            opticalDepthLightR += exp(-hLight / hr) * segLLight;
            opticalDepthLightM += exp(-hLight / hm) * segLLight;
            cloudDensity += mix(0.0, cloud_mask(1e-4*samplePositionLight.xz*exp(normalize(samplePositionLight).y), 0.0), rd.y);
            tCurrentLight += segLLight;
        }
        if (ended)
        {
            cloudDensity = clamp(cloudDensity, 0.0, 1.0);
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);
            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));
            attenuation = mix(attenuation, vec3(tau*cloudDensity), cloudDensity);
            sumR += _hr * attenuation;
            sumM += _hm * attenuation;
        }
        tCurrent += segL;
    }
    miecolor = SUNINTENSITY * sumM * phaseM;
    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);
}

// Function 646
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    return ( Scene_Trace( vRayOrigin, vRayDir, 0.001, fLightDist ).fDist < fLightDist ? 0.0 : 1.0);
    /*
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    */
}

// Function 647
vec3 shadeCoaster(vec3 p, vec3 n, vec3 r) {
    return calcLighting(vec3(.2,.2,.9), p, n, r, 3.);
}

// Function 648
float cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }

// Function 649
vec3 shade(in vec3 ray_start, in vec3 ray_dir,
   in vec3 light_dir, in vec3 fog_color, in vec4 hit)
{   
   vec3 dir = hit.xyz - ray_start;
   vec3 norm = dNormal(hit.xyz, .015);//*hit.w);
   float diffuse = max(0.0, dot(norm, light_dir));
   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));
   spec = pow(spec, 32.0)*.7;

   vec2 tile = dTile(hit.xz);
   float sh = tile.x;
#if USE_COLORS == 2
   sh = (mod(sh,6.)+3.)*(1./9.);
#else
   sh *= (1./12.);
#endif
   float sd = min(tile.y,.05)*20.;
#if USE_COLORS == 0
   vec3 base_color = vec3(.5);
#else
   vec3 base_color =
    vec3(exp(pow(sh-.75,2.)*-10.),
         exp(pow(sh-.50,2.)*-20.),
         exp(pow(sh-.25,2.)*-10.));
#endif
   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +
      spec*vec3(1.,1.,.9);
   color *= sd;
   
   float fog_dist = max(0.,length(dir) - fog_start);
   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);
   color = mix(color, fog_color, fog);

   return color;
}

// Function 650
vec3 sampleLight( const in vec3 ro ) {
    lowp vec3 n = randomSphereDirection() * lightSphere.w;
    return lightSphere.xyz + n;
}

// Function 651
float
intersect_light(Ray ray)
{
	float t = intersect_plane(ray, light_position, light_normal);

	vec3 p = ray_at(ray, t);
	if(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5)))) {
		return t;
	}

	return INFINITY;
}

// Function 652
vec3 Sample_DirLight(vec3 V, vec3 p, vec3 N, vec3 L, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    float t2; vec3 n2; vec3 a2; bool hitLight2 = false;
    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, hitLight2);

    if(hit) return vec3(0.0);

    return Frostbite_R(V, N, L, albedo, roughness, F0) * (Intensity * Pow2(0.125));// just set brightness heuristically here based on point light intensity
}

// Function 653
vec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)
{
    if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);
    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);
    float D = length(LightDir);// distance for attenuation
    vec3 N = normalize(normal);
    vec3 L = normalize(LightDir);
    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);
    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;
    vec3 Intensity = Ambient + Diffuse;
    vec3 FinalColor = inpColor.rgb * Intensity;
    return vec4(FinalColor, inpColor.a);
}

// Function 654
vec3 ray_shade(in vec3 ro, in vec3 rd) {
    
    // handle resolution scaling
    ro *= resolution;

    // hit_nt will hold normal and distance
    vec4 hit_nt;
    
    // prev_cell and hit_cell store cell before and after intersection
    vec3 prev_cell, hit_cell;
    
    // do raytrace
    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);
    
    svObjID = objID;
    
    // output color
    vec3 color = vec3(0);
    
    //vec3 light_dir = normalize(lp - ro);
    vec3 sk = sky(ro, rd);
    color = sk;
    
    // if ray hit
    if (hit_nt.w >= 0.0) {
        
        // get the cell center where it hit
        vec3 cell_center = hit_cell * cell_size;
        
        // get the intersection point
        vec3 pintersect = ro + rd * hit_nt.w;
        
        // store distance to border, to neighbor cell
        float bdist, ndist;
        
        // see if we hit top/bottom or side
        if (abs(hit_nt.z) > 0.0) {
            
            // was top/bottom
            bdist = hexDist(pintersect.xy - cell_center.xy);
            ndist = neighborDist(prev_cell, hit_cell, pintersect); 
            
        } else {
            
            // was side
            vec2 n = hit_nt.xy;
            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;
                    
            vec2 p = pintersect.xy - cell_center.xy;
            p -= n * dot(p, n);
            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));
            
            ndist = neighborDist(prev_cell, hit_cell, pintersect);
            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));

        }
        
        // default case: assume shadow - note for "realism" we would set 0.0 here
        float diffuse = 0.05;
        
        // A distant point light, so it's almost directional, but it still has a
        // slight point light feel... if that makes any sense. :)
        vec3 light_dir = normalize(lp - pintersect);
        
        // see if on lit side
        if (dot(hit_nt.xyz, light_dir) > 0.0) {
            
            // shadow ray
            vec4 shadow_nt;
            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, 
                     shadow_nt, prev_cell, hit_cell);
            
            // full light if shadow ray missed
            if (shadow_nt.w < 0.0) { diffuse = 1.0; }

            
        }
        
        // shade the hit point
        color = shade(ro, rd, hit_nt, bdist, ndist, diffuse);

        
    } 
    
    color = mix(color, sk, smoothstep(0., .95, hit_nt.w*.6/100.));
    
	return color;
	
}

// Function 655
vec4 lighting(Object obj, vec3 pos,vec3 p, Light light, vec3 rayDirection)
{
  
  
  float intensity=light.intensity;
  if(light.direction==vec3(0.0,0.0,0.0))
  {
    light.direction=normalize(vec3(p-light.position));
    float d=distance(light.position,p);
    if(light.attenuation!=vec3(0.0,0.0,0.0))
       intensity*=1.0/(light.attenuation.x*d*d+light.attenuation.y*d+light.attenuation.z);
  }

  // Gamma correction:
  intensity=pow(intensity,0.45);
  Material mat=getMaterial(obj);
  vec3 ambientColor=mat.ambient*light.color;
  vec3 emissiveColor=vec3(0.0,0.0,0.0);
  vec3 N=computeNormal(p);
  vec3 diffuseColor = intensity*light.color*mat.diffuse*max(dot(light.direction, N),0.0);
 
  vec3 R=reflect(light.direction,N);
  vec3 specularColor =vec3(0.0,0.0,0.0);

  vec4 materialColor=getTexture(mat,obj.orientation);
  return vec4(materialColor.xyz*(diffuseColor+specularColor+ambientColor+emissiveColor),materialColor.w);
 }

// Function 656
float shadow(vec3 pi, vec3 l,float k)
{
    float t = 1.0;
    float tmax = 30.0;
    float res = 1.0;
    for(int i=0; i<256; ++i)
    {
        vec3 p = pi + t * l;
        float idx;
        float d = map(p,idx);
        
        res = min(res, k * d/t);
        if(d < 0.0001 || t > tmax) break;
        
        t+=d;
    }
    return clamp(res,0.0,1.0);
}

// Function 657
vec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,
                      out float visibility)
{
    vec3 posToSphereWS = lightSphere.xyz - posWS;
    float distToSphereCenter = length(posToSphereWS);
    float sqDistToSphere = distToSphereCenter * distToSphereCenter;
    float sqSphereRadius = lightSphere.a * lightSphere.a;
    
    float distToDisk = (1.0/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);
    float diskRadius = (lightSphere.a/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));
    
    float cosSphereAngularRadius = clamp(distToDisk/sqrt(distToDisk*distToDisk + 
                                        diskRadius*diskRadius), -1.0, 1.0);
    vec3 posToSphereDirWS = posToSphereWS/distToSphereCenter;
    
    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, 
                                     cosSphereAngularRadius, roughness);
    
    //The point to light can be inside the sphere, blend to 1.0 at the center
    if(distToSphereCenter < lightSphere.a)
    {
        sphereLighting = mix(1.0, sphereLighting, distToSphereCenter/lightSphere.a);
    }
    
	visibility = sphereLighting;
    
    return colour * sphereLighting;
}

// Function 658
float calcHardshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    for( float t=mint; t < tmax; )
    {
        float h = map(ro + rd*t).x;
        if( h<0.001 )
            return 0.0;
        t += h;
    }
    return 1.0;
}

// Function 659
float ObjSShadow (vec3 ro, vec3 rd, float dMax)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += clamp (3. * h, 0.04, 0.3);
    if (sh < 0.05 || d > dMax) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 660
void initDynamicLights(vec3 p) {
    #if nLights != 0
    lights[1] = light(vec3( (floor(min(abs(p.xz/140.),1.))*140.*sign(p.xz)+70.*sign(p.xz)), 0.).xzy-vec3(0.,16.,20.), vec3(1.2,.9,.99), 50.);
    
    lights[2] = light(vec3( (floor(min(abs(p.xz/300.),0.))*300.*sign(p.xz)+150.*sign(p.xz)), 0.).xzy-vec3(0.,20.,0.) , vec3(1.2,.9,.99), 190.);
    #endif
}

// Function 661
float shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){

    float shade = 1.0;
    const int shadIter = 24; 

    float dist = start;
    //float stepDist = end/float(shadIter);

    for (int i=0; i<shadIter; i++){
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.

        dist += clamp(h, 0.02, 0.2);
        
        // There's some accuracy loss involved, but early exits from accumulative distance function can help.
        if ((h)<0.001 || dist > end) break; 
    }
    
    return min(max(shade, 0.) + 0.0, 1.0); 
}

// Function 662
float cloudShadow( in vec3 pos ) {
	return 0.45 + 0.55*smoothstep( 0.1, 0.35, texture( iChannel1, 0.0003*(pos.xz + lig.xz*(100.0-pos.y)/lig.y) + 0.1+0.0023*iTime ).x );
}

// Function 663
float doShadow( vec3 ro,  vec3 rd,  float dMax) {
    vec3 n;
    float val, dMin = dd*.1;
    vec2 res = rayGround(ro, rd, dMin, dMax, n, val);
    return res.x>dMin && res.x <= dMax ? 1. - clamp((dMax-res.x)/dMax,0.,1.) : 1.;
}

// Function 664
vec3 calcLighting(Hit scn, vec3 n, bool s) {
 
    float d = max(dot(MOON_DIR,n), 0.);
    if(s) d = 0.;
    
    return MOON_COLOR * d;
    
}

// Function 665
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    float ph = 1e10;
    
    for( int i=0; i<32; i++ )
    {
        float h = map( ro + rd*t ).dist;
        res = min( res, 10.0*h/t );
        t += h;
        if( res<0.0001 || t>tmax ) break;
        
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 666
vec3 shade (in vec3 ro, in vec3 rd, in float d) {
	vec3 p = ro + d*rd;
	vec3 balls = p;
	balls.xz *= r2d (-95.*iTime);
	balls.zy *= r2d (63.*iTime);


	float floorPhase = cos (45.*p.x);
	float ballsPhase = cos (75.*balls.z);
	float floorMask = smoothstep (.01*d, .0025*d, (.5 + .5*floorPhase));
	float ballsMask = smoothstep (.01*d, .0025*d, (.5 + .5*ballsPhase));
	vec3 floorColor = mix (vec3 (.3, .3, 1.), vec3 (.0), 1. - floorMask);
	vec3 ballsColor = mix (vec3 (1., .3, .3), vec3 (.0), 1. - ballsMask);

    // don't do material assignment like this, it's a hack and I'm lazy
	bool isMetaBalls = (p.y > -.75 && p.y < 1.);

	float brightness = 5. / pow (.25*d*d, 1.75);
	ballsColor += vec3 (1., .2, .1)*brightness;
	floorColor += vec3 (.1, .2, 1.)*brightness;

	return isMetaBalls ? ballsColor : floorColor;
}

// Function 667
vec3 sampleLightSource(in vec3 x, vec3 ns, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {
    vec3 p_global = light.pos + vec3(1., 0., 0.) * light.size.x * (Xi1 - 0.5) +
        						vec3(0., 0., 1.) * light.size.y * (Xi2 - 0.5);
    vec3 n_global = vec3(0.0, -1.0, 0.0);
    sampleRec.w = p_global - x;
    sampleRec.d = length(sampleRec.w);
    sampleRec.w = normalize(sampleRec.w);
    float cosAtLight = dot(n_global, -sampleRec.w);
    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);
    sampleRec.pdf = PdfAtoW(1.0 / (light.size.x*light.size.y), sampleRec.d*sampleRec.d, cosAtLight);
    
	return L;
}

// Function 668
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 669
vec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, float kdiffuse, float kspecular, float roughness )
{
	float F0 = 0.08;
	float alpha = roughness * roughness;
	vec3 h = normalize( l + v );
	float n_dot_l_raw = dot( n, l );
	float n_dot_v_raw = dot( n, v );
	float n_dot_h_raw = dot( n, h );
	float eps = 1e-4; // else divides by zero
	float n_dot_l = max( eps, n_dot_l_raw );
	float n_dot_v = max( eps, n_dot_v_raw );
	float n_dot_h = max( eps, n_dot_h_raw );
	float D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0
	float G = G_neumann( n_dot_l, n_dot_v );
	float F = F_schlick( n_dot_v, F0 );
	return ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;
}

// Function 670
float light (vec3 o) {
    vec3 lightDirection = -normalize(lightSource-o);
    vec3 n = normal(o);
    float light = max(0.0, dot(-lightDirection, n));
    
    /* specular */
    float spec = pow(light,128.0) + pow(light,32.0);
    
    return mix(0.5, 1.0, light)+spec;
}

// Function 671
float ExObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.01;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ExObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 672
float softShadow(vec3 a, vec3 u, float k)
{
    float r = 1.0;
	vec3 p = a;
	float lambda = object_lipschitz();
	float depth = 0.0;
	float step = 0.0;
	for(int i = 0; i < Steps; i++)
	{
		float v = SphereTracedObject(p);
		if (v > 0.0)
			return 0.0;
        r = min(r, k * (v / AmbiantEnergy) / depth);
		
		step = max(abs(v) / lambda, Epsilon);
		depth += step;
		
		if(depth > RayMaxLength)
			return r;
		
		p += step * u;
	}
	return r;
}

// Function 673
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.02 * d, h));
    d += clamp (3. * h, 0.02, 0.3);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 674
void shade( in vec3 pos, in vec3 nor, in vec3 rd, in float matID, out vec3 mate){
// TODO: use an Array
    if( matID<0.5)        { mate = vec3(.8,.8,.8); }
    else if( matID>12.5 ) { mate = vec3(4.,.2,.2); }
    else if( matID>11.5 ) { mate = vec3(.1); }
    else if( matID>9.5 )  { mate = mix(vec3(0,.5,.6),vec3(.3,.8,.9), matID-10.); }
    else if( matID>7.5 )  { mate = mix(vec3(.6,0.2,.5),vec3(.9,.6,.8), matID-8.); }
 	else/*if( matID>.5)*/ { mate = vec3(0.05,0.1,0); }   
}

// Function 675
vec3 computeLight(vec3 pos, vec3 color, vec3 normal) {
    vec3 toLight1 = LIGHT1_POS - pos;
    float distSq1 = dot(toLight1, toLight1);
    vec3 att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) * 30.0 / distSq1;
    vec3 toLight2 = LIGHT2_POS - pos;
    float distSq2 = dot(toLight2, toLight2);
    vec3 att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) * 5.0f / distSq2;
    return color * (
        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR
        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR
        + texture(iChannel1, normal).rgb * 0.1
    );
}

// Function 676
float softshadow(vec3 pos, vec3 rayDir, float mint, float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = distfunc( pos + rayDir*t );
        res = min( res, 2.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 677
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );
    
	float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 678
float calcAO(vec3 pos, vec3 nor)
{
	float occ = 0.0;
    float sca = 0.8;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        
    	float dd = map(aopos);
        
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 2.5*occ, 0.0, 1.0 );    
}

// Function 679
float compute_light1_factor(vec3 pos, vec3 normal)
{
    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));
    vec3 randDir = normalize(randVals - 0.5);
    vec3 toLight1 = LIGHT1_POS-pos;
    float distSq1 = dot(toLight1,toLight1);
    float att1 = 40.0f/distSq1;
    
    for (int i = 0; i < 1; i++)
    {
        randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));
        randDir = normalize(randVals - 0.5);
        if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))
        {    
            att1 = 0.0;
            break;
        }
    }
    
    return (max(0.0,dot(normal,normalize(toLight1)))*att1
 );
}

// Function 680
vec3 lighting( in Intersection I, in vec3 LightPos) {
   vec3 L = LightPos - I.P;
   float diffuse = max(dot(I.N, L)/length(L),0.0);
   return diffuse * I.material.Kd;
}

// Function 681
vec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)
{
	// distance to light
	float ld = length(p - pos);
	
	// out of range ?
	if (ld > range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, pos, radius);
	float fall = (range - ld)/range;
	fall *= fall;
	float source = fillMask(sdCircle(p - pos, radius));
	return (shad * fall + source) * color;
}

// Function 682
bool inShadow(vec3 p) {
 
    Ray sr = Ray(p + MOON_DIR * .005, MOON_DIR);
    Hit sh = raymarch(sr, true);
    return sh.id != -1;
    
}

// Function 683
vec3 LightCharacters(vec3 pos, vec3 norm, vec3 dir, int m)
{
	float specular = 0.0;
	vec3 ballColour;
	float specSize = 8.0;
	vec3 specColour = vec3(1.0, 1.0, 1.0);
	if (m == 7)
	{
		ballColour = vec3(1.0, 1.0, 1.0);
		specColour = vec3(0.0, 0.0, 0.0);
		specSize = 2.0;
	}
	
	if (m == 6)
	{
		norm += (noise((pos-QbertPos)*42.0)*.5)-.5;
		ballColour = vec3(1.2, 0.42, 0.);
	}
	else 
	{
		vec3 reflect = ((-2.0*(dot(dir, norm))*norm)+dir);
		specular = pow(max(dot(reflect, lightDir), 0.0), specSize);
		
		if (m == 2)
		{
			ballColour = vec3(1.0, 0.0, 1.0);
		}else
		if (m == 3)
		{
			ballColour = vec3(1.0, 0.0, 0.0);
		}else
		if (m == 4)
		{
			ballColour = vec3(0.0, 1.0, 0.0);
		}
	}

	float diff = dot(norm, lightDir);
    diff = max(diff, 0.3);

	return mix(diff * ballColour, specColour, specular);	
}

// Function 684
vec3 shadeSand( in vec3 p, in vec3 i, in float l )
{
    // Get the texture of the sand.
    vec3 tex = texSand(p,l);
    // Pass it into the the shading function.
    return shadeDrySand(i,tex);
}

// Function 685
vec3 shade(vec3 pos, vec3 v)
{
	const float spec_power = 4.0;
	const float normalization = (spec_power + 2.0) / 8.0;
	const vec3 f0 = vec3(0.057,0.057,0.037);
	
	vec3 n = calc_normal(pos);
	
	float g = clamp(1.0 - exp(-pos.y*1.0), 0.0, 1.0);
	vec3 albedo = mix(vec3(0.2,0.4,0.03),vec3(0.65,1.0,0.15),g);
	
	float ao = calc_ao(pos,n);
	
	vec3 h = normalize(v+ldir);
	vec3 fresnel = schlick(f0,h,v);
	
	float ndl = dot(n,ldir) * 0.5 + 0.5;
	float ndh = max(dot(n,h),0.0);
	float ndv = max(dot(n,v),0.0);
	
	float alpha = 1.0 / sqrt((PI/4.0) * spec_power + (PI/2.0));
	float vis = (ndl * (1.0 - alpha) + alpha) * (ndv * (1.0 - alpha) + alpha); 
	vis = 1.0 / vis;
	
	vec3 spec = vec3(pow(ndh, spec_power)) * normalization * vis * ndl;
	return albedo * (spec * fresnel + ndl * (1.0 - fresnel) + 
					 ao * skycolour(reflect(-v,n)) * 1.5);
}

// Function 686
vec3 Shade(MC hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(0.0);
    vec3 rd = color;
    vec3 skydomeColor = color;
    
    if(hit.id == SKYDOME)
    {
    	color = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, hit.position.y/9.0);
       
        vec3 sunDir = normalize(SUN_DIRECTION);       
		float sun = smoothstep(0.987, 0.99, dot(direction, sunDir));
        sun -= smoothstep(0.1, 0.9, 0.5);			        
		float sunStripesPos = 2.0*pow(0.6*hit.position.y-0.1, 1.5);
        float stripes = clamp( smoothstep(0.5, 0.51, abs(-1.0+2.0*fract(sunStripesPos))), 0.0, 1.0);		        
		vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, -hit.position.y/2.5);        
        color = mix(color, sunCol, min(sun, stripes)) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;		        
    }      

    if(hit.id == FLOOR)
    {
        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); 
        
        uv /= fwidth(hit.position.xz);
                                                       
        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;
    	color = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
        
		vec3 normal = vec3(0.,0.0,-0.5);
        vec3 rfld = reflect( direction, normal );
        float reflectstrength = 1.-abs(dot( direction, normal ));
        color *= reflectstrength;
        
        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;
        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);
        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );
        float spotAtt = 1.0 / pow( length( spotPos - hit.position ), 2.0 );
        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );
        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );  	

        // red trail      
        float trailX = hit.position.x - gBoxPos.x -2.0;
        color += 0.9 * vec3( 1.0, 0.0, 0.0 ) 
            * saturate( exp( -5.2 * abs( hit.position.z -(gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5)) ) )
            * saturate(  1.0 + trailX * 0.02 )
            * saturate( -0.6 - trailX * 0.3 );
    } 
    
	if(hit.id == CAR)
    {
        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); 
        
        uv /= fwidth(hit.position.xz);
                                                       
        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;
    	color = mix((0.5*CAR_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
        
		vec3 normal = vec3(0.,0.0,-0.5);
        vec3 rfld = reflect( direction, normal );
        float reflectstrength = 2.-abs(dot( direction, normal ));
        color *= reflectstrength;
        
        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;
        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);
        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );
        float spotAtt = 1.0 / pow( length( spotPos - hit.position ), 2.0 );
        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );
        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );         
    } 

	if(hit.id == CAR2)
    {
        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0);         
        uv /= fwidth(hit.position.xz);                                                       
        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;
    	color = mix((0.5*CAR2_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
    } 
    
    //Distance fog
    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )/70.;
    
    return color;
}

// Function 687
float nightLight(vec3 pos, float h, vec2 th){
    float l= perlin_noise3(pos*vec3(128.0,128.0,128.0))*3.0;
    
    float p = perlin_noise3(pos*vec3(32.0,32.0,32.0))*2.0;
    p += perlin_noise3(pos*vec3(8.0,8.0,8.0));
    p += perlin_noise3(pos*vec3(16.0,16.0,16.0));
    p -= perlin_noise3(pos*vec3(4.0,4.0,4.0))*4.0;
    
    l*=clamp(p,0.0,1.0)*max(th.x - 0.2, 0.0) * th.y * 2.0;
    
    return l*(h>0.0?1.0:0.0);
}

// Function 688
float CaveAO (vec3 ro, vec3 rd)
{
  float ao, d;
  ao = 0.;
  for (int j = VAR_ZERO; j < 8; j ++) {
    d = float (j + 1) / 8.;
    ao += max (0., d - 3. * CaveDf (ro + d * rd));
  }
  return clamp (1. - 0.2 * ao, 0., 1.);
}

// Function 689
float shadow( in vec3 start, in vec3 n, in vec3 ldir, in float p)
{    
    // Do some quick "is the sun even shining on here" tests.
    // We wait until the sun is just below the horizon before considering
    // it gone.
    if( dot(n,ldir) <= 0.0 || dot(ldir,UP) <= -.25) return 0.0;
    
	float t = EPSILON*128.0;
	float res = 1.0;
    for ( int i = 0; i < S_STEPS; ++i )
    {	//vec3 s=start + ldir * t ;
    //    float d = min(distR(s),sceneDist(s,sd));
        float d = dist(start + ldir * t,false);
        if ( d < EPSILON*.1 )
            return 0.0;
		
		res = min( res, p * d / t );
        t += d;
		
		if ( t > MAX_DEPTH )
			break;
    }
    return res;
}

// Function 690
vec3 Lighting(in vec3 norm, in vec3 dir, float depth, float shadow, float ao, float roughness)
{
    vec3 sunLight    = max(0.0, dot(norm, SunLightDir)) * SunLightCol * shadow * 1.5;
    vec3 ambLight    = max(0.0, dot(norm, AmbLightDir)) * AmbLightCol * ao;
    vec3 skyLight    = clamp(0.5 + (0.5 * norm.y), 0.0, 1.0) * SkyLightCol * ao;
    vec3 directLight = sunLight + (ambLight * 0.25) + (skyLight * 0.25);
    
    vec3 reflVec   = reflect(-SunLightDir, norm);
    vec3 specLight = pow(max(0.0, dot(dir, -reflVec)), roughness) * vec3(1.0) * shadow;
    
    return (directLight + specLight);
}

// Function 691
vec3 shade (in vec3 ro, in vec3 rd, in float d)
{
    vec3 p = ro + d * rd;
    vec3 ambient = vec3 (.05);
    vec3 diffuseColor = vec3 (.9, .3, .3);
    vec3 specularColor = vec3 (.9, .8, .7);
    float shininess = 40.;
    float diffuseStrength = .25;
    float t = 3.*iTime;

    vec3 n = normal (p, d*d*EPSILON);
    vec3 lPos = 1.5 * vec3 (cos (t), 1., sin (t));
    float lDist = distance (lPos, p);
    vec3 lDir = normalize (lPos - p);
    vec3 hDir = normalize (ro + lDir);
    float diffuse = max (dot (n, lDir), .0)*(1. / lDist)*diffuseStrength;
    float specular = pow (max (dot (hDir, n), .0), shininess);

	vec3 diffuseColor2 = vec3 (.3, .9, .3);
    vec3 specularColor2 = vec3 (.7, .8, .9);
    vec3 lPos2 = -1.5 * vec3 (.0, sin(t), .75*cos(t));
    float lDist2 = distance (lPos2, p);
    vec3 lDir2 = normalize (lPos2 - p);
    vec3 hDir2 = normalize (ro + lDir2);
    float diffuse2 = max (dot (n, lDir2), .0)*(1. / lDist2)*diffuseStrength;
    float specular2 = pow (max (dot (hDir2, n), .0), shininess);

	vec3 diffuseColor3 = vec3 (.3, .3, .9);
    vec3 specularColor3 = vec3 (.8, .9, .7);
    vec3 lPos3 = 1.5 * vec3 (sin (t), .5*cos(t), -1.);
    float lDist3 = distance (lPos3, p);
    vec3 lDir3 = normalize (lPos3 - p);
    vec3 hDir3 = normalize (ro + lDir3);
    float diffuse3 = max (dot (n, lDir3), .0)*(1. / lDist3)*diffuseStrength;
    float specular3 = pow (max (dot (hDir3, n), .0), shininess);

    vec3 col = ambient +
			   diffuse * diffuseColor + specular * specularColor +
			   diffuse2 * diffuseColor2 + specular2 * specularColor2 +
			   diffuse3 * diffuseColor3 + specular3 * specularColor3;
    return col;
}

// Function 692
vec3 shade_end(vec3 hp, float reflect_depth)
{

    float sr = .02 * mod(reflect_depth - 160. * g_time, 50.);

    float sm = texture(iChannel0, vec2(.0, .5)).r;
    
    //vec3 c = mix(vec3(1.2, .8, .1), vec3(1., .0, .0), sr);
    //vec3 c = mix(vec3(.8), vec3(0.05), sr);
    vec3 c = mix(vec3(1.2, .8, .1), vec3(1., -.1, .0), sr);
    
    c += .5 * pow((1. - sr), 4.);
    float sp = BIG_NUMBER;
    
    vec2 p1 = vec2(0., sin(10. * g_time));
    vec2 p2 = vec2(-.866, -.5 * sin(5. * g_time));
    vec2 p3 = vec2(.866, -.5 * sin(10. * g_time + 3.14));
    
    sp = min(dist_to_line(hp.xz, p1, p2), sp);
    sp = min(dist_to_line(hp.xz, p2, p3), sp);
    sp = min(dist_to_line(hp.xz, p3, p1), sp);    

    c = (.4 + .6 * smoothstep(0., .6, sp)) * (.5 + .5 * smoothstep(0., .08, sp)) * c;

    float sb = BIG_NUMBER;
    vec2 b1 = vec2(0., 1.732);
    vec2 b2 = vec2(-1.6, -1.);
    vec2 b3 = vec2(1.732, -1.);
    
    sb = min(dist_to_line(hp.xz, b1, b2), sb);
    sb = min(dist_to_line(hp.xz, b2, b3), sb);
    sb = min(dist_to_line(hp.xz, b3, b1), sb);    

    
    c = (.8 + .2 * smoothstep(0., .5, sb)) * (.2 + .8 * smoothstep(0., .08, sb)) * c;
    
    return c;
}

// Function 693
float computeSoftShadow(const vec3 ro, const vec3 rd, const float tmin, const float tmax, float k)
{
	float res  = 1.0;
    float t    = tmin;
    float ph   = 1e10; // Big, such that y = 0 on the first iteration.
    
    for (int i = 0; i < 32; ++i)
    {
		float h = mapScene(ro + rd * t).x;
        {
            float y = h * h / (2.0 *  ph);
            float d = sqrt(h * h - y * y);
            res = min(res, 10. * d / max(0., t - y));
            ph  = h;
        }
        t += h;
        if ((res < kEpsilon) || (t > tmax)) 
            break;
    }
    return clamp(res, 0., 1.);
}

// Function 694
float shadow(vec3 ro, vec3 rd, vec3 l_pos)
{
    float res = 1.;
    float d = march(ro+100.*normal*SURF_DIST, rd);
    vec3 p = ro + d*rd;
    float dl = length(l_pos - p );
    if (d < dl)
        res = 0.;
    float r = 10.;
 	res = clamp((res*d*(d - dl)/(d + dl) + r) / (2. * r), 0., 1.);
	res = smoothstep(0., .8, res);

    return res;
}

// Function 695
float lightCalculate(vec3 lightPos, vec3 point){
	vec3 lightDirection = normalize(lightPos - point);
    vec3 normal = getNormal(point);
    float brightness = clamp(dot(normal, lightDirection), 0.0, 1.0);
    
    float shadowCatch = march(point + normal * 0.10, lightDirection);
    if(shadowCatch < length(lightPos - point)) brightness *= 0.1;
      
    return brightness;
}

// Function 696
vec3 getLightColor() {
	return LightColor * 21.61 * 1.3 * LightIntensity;
}

// Function 697
vec3 generateShadeOklab(int swatch, int shade, float seedChroma, float seedHue, float chromaFactor) {
    float cielabL = CIELAB_LIGHTNESS_MAP[shade];
    vec3 cielabXyz = cielabToXyz(vec3(cielabL, 0.0, 0.0));
    float lightness = xyzToOklab(cielabXyz).x;

    vec3 lch = calcShadeParams(swatch, lightness, seedChroma, seedHue, chromaFactor, OKLAB_ACCENT1_CHROMA);
    vec3 oklab = lchToLab(lch);
    return oklabToLinearSrgb(oklab);
}

// Function 698
void AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )
{
    vec3 vSunDir = GetSunDir();

	vec3 vH = normalize( vViewDir + vSunDir );
	float fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);
	float fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);
	float fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);
    
    float diffuseIntensity = fNdotL;
    
    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;
	//vDiffuse = fShadowFactor * vec3(100.0);
	
	float alpha = 1.0 - surf.m_gloss;
	// D

	float alphaSqr = alpha * alpha;
	float pi = 3.14159;
	float denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;
	float d = alphaSqr / (pi * denom * denom);

	float k = alpha / 2.0;
	float vis = GIV(fNdotL, k) * GIV(fNdotV, k);

	float fSpecularIntensity = d * vis * fNdotL;
	vSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;
}

// Function 699
vec3 lightball(vec3 lpos, vec3 lcolor, vec3 O, vec3 D, float L) {
    vec3 ldir = lpos-O;
    float ldist = length(ldir);
    if (ldist > L) return vec3(0.);
    float pw = pow(max(0.,dot(normalize(ldir),D)), 20000.);
    return (normalize(lcolor)+vec3(1.)) * pw;
}

// Function 700
vec3 calcLightingFancy(vec3 r, vec3 s, vec3 t, vec2 uv) {
	voxel v1, v2, v3, v4, v5, v6, v7, v8, v9;
    //uv = (floor(uv * 16.) + .5) / 16.;
    v1 = getVoxel(r - s + t);
    v2 = getVoxel(r + t);
    v3 = getVoxel(r + s + t);
    v4 = getVoxel(r - s);
    v5 = getVoxel(r);
    v6 = getVoxel(r + s);
    v7 = getVoxel(r - s - t);
    v8 = getVoxel(r - t);
    v9 = getVoxel(r + s - t);
    
    //return vec3(uv, 0.) - .5 * opaque(v6.id);
    
    vec2 light1, light2, light3, light4, light;
    light1 = max24(v1.light, v2.light, v4.light, v5.light);
    light2 = max24(v2.light, v3.light, v5.light, v6.light);
    light3 = max24(v4.light, v5.light, v7.light, v8.light);
    light4 = max24(v5.light, v6.light, v8.light, v9.light);
    
    float ao1, ao2, ao3, ao4, ao;
    ao1 = vertexAo(opaque(v2.id), opaque(v4.id), opaque(v1.id));
    ao2 = vertexAo(opaque(v2.id), opaque(v6.id), opaque(v3.id));
    ao3 = vertexAo(opaque(v8.id), opaque(v4.id), opaque(v7.id));
    ao4 = vertexAo(opaque(v8.id), opaque(v6.id), opaque(v9.id));
    
    light = mix(mix(light3, light4, uv.x), mix(light1, light2, uv.x), uv.y);
    ao = mix(mix(ao3, ao4, uv.x), mix(ao1, ao2, uv.x), uv.y);
    
    return lightmap(light) * pow(ao, 1. / 1.);
}

// Function 701
bool intersectShadowMesh( in vec3 ro, in vec3 rd )
{
    ro.z += 0.5;
    if( !boxIntersect( ro, rd, vec3(0.0), vec3(0.18,0.3,0.52) ) )
        return false;

    bool res = false;
    for( int i=ZERO; i<numFaces; i++ )
    {
		// get the triangle
        vec3 v0 = getVertex(i,0);
        vec3 v1 = getVertex(i,1);
        vec3 v2 = getVertex(i,2);

        vec3 h = triIntersect( ro, rd, v0, v1, v2 );
        if( h.x>0.0 )
        {
            res = true;
            break;
        }
    }
    
    return res;
}

// Function 702
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += max (0.02, h);
    if (sh < 0.05) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 703
vec3 addLight(in vec3 lpos, inout vec3 col, in vec3 pos, in vec3 nor, in vec3 rd, in float thi){
	vec3 ldir = normalize(lpos-pos);
	float latt = pow( length(lpos-pos)*.03, .5 );
    float trans =  pow( clamp( max(0.,dot(-rd, -ldir+nor)), 0., 1.), 1.) + 1.;
	//col = vec3(.2,.1,.1) * (max(dot(nor,ldir),0.) ) / latt;
	col += vec3(.3,.3,.1) * (trans/latt)*thi;
    return col;
   
}

// Function 704
float shadow(vec3 from, vec3 increment)
{
	const float minDist = 1.0;
	
	float res = 1.0;
	float t = 1.0;
	for(int i = 0; i < SHADOW_ITERATIONS; i++) {
		float m = 0.0;
        float h = distf(from + increment * t, m);
        if(h < minDist)
            return 0.0;
		
		res = min(res, SHADOW_SMOOTHNESS * h / t);
        t += SHADOW_STEP;
    }
    return res;
}

// Function 705
float calcAO(vec3 pos, vec3 normal)
{
	float occ = 0.0;
    float sca = 1.0;
    
    for(int i = 0; i < 15; i++)
    {
        float r = 0.01 + 0.1*float(i);
        vec3 aopos =  normal * r + pos;
        
        Obj intersection = getDist(aopos);
             
        if (intersection.type != BOX && intersection.type != BOX3) 
        {
            float d = getDist( aopos ).dist;
            occ += (r - d)*sca;
            
            sca *= 0.85;
        }
    }
    return clamp( 1.0 - occ /3.14, 0.0, 1.0 );    
}

// Function 706
float ao(vec3 p, vec3 n, float h) {
    return map(p + h * n).d / h;
}

// Function 707
vec3 shade(vec3 ori, vec3 dir) {
	vec2 scn = raymarch(ori, dir, MAX_ITERATIONS);
    vec3 col = vec3(0.);
    if(scn.y == 0.) {
        vec3 p = ori+dir*scn.x;
    	vec3 n = calcNormal(p,scn.x);
    	vec3 r = normalize(reflect(dir,n));
        col = shadeGun(scn,p,n,r);
        
        vec2 rs = raymarch(p+r*SHADOW_BIAS,r,REFL_ITERATIONS);
        vec3 rc = texture(iChannel3,r).xyz;
        if(rs.y == 0.) {
        	vec3 rp = p+r*(SHADOW_BIAS+rs.x);
            vec3 rn = calcNormal(rp,rs.x);
            vec3 rr = normalize(reflect(dir,rn));
            rc = shadeGun(rs,rp,rn,rr)+doEmission(rp,rn);
        }
        float f = 1.-pow(max(-dot(dir,n),0.),.45);
        col = mix(col, rc, f*.4);
        col += doEmission(p,n);
    } else {
    	col = texture(iChannel3, dir).xyz;   
    }
    return col;
}

// Function 708
bool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity) {
    dist = 0.; 
    float minStep = 1.0;
    light_intensity = 1.0;
	float mapDist;
    for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++) {
        p = ray_start + ray_dir * dist;
        mapDist = mapBlocks(p, ray_dir).y;
        if (mapDist < MIN_RAYMARCH_DELTA) {
            iterations = i;
            return true;
        }
		light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist);
		dist += max(mapDist, minStep);
        if (dist >= maxDist || p.y > maxY) { break; }
    }
    return false;
}

// Function 709
float compute_light2_factor(vec3 pos, vec3 normal)
{
     vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));
     vec3 randDir = normalize(randVals - 0.5);
     vec3 toLight2 = LIGHT2_POS-pos;
     float distSq2 = dot(toLight2,toLight2);
     float att2 = 20.0f/distSq2; 
    
     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))
        att2 = 0.0;
     return (
         max(0.0, max(0.0,dot(normal,normalize(toLight2)))*att2
 ));
}

// Function 710
vec3 sampleLightType( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, out float visibility, float seed) {
    if( !light.enabled )
        return vec3(0.);
    
    if( light.type == LIGHT_TYPE_SPHERE ) {
        vec3 L = lightSample(light, interaction, wi, lightPdf, seed);
        visibility = visibilityTest(interaction.point + wi * .01, wi);
        return L;
    }
    else if( light.type == LIGHT_TYPE_SUN ) {
        vec3 L = sampleSun(light, interaction, wi, lightPdf, seed);
        visibility = visibilityTestSun(interaction.point + wi * .01, wi);
        return L;
    }
    else {
        return vec3(0.);
    }
}

// Function 711
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = SDFCageScene( pos + h*nor,0 ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
        if( occ>0.35 ) break;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 712
vec3 shade(vec2 uv, vec3 ro, vec3 rd) {
    vec3  sp = vec3(((iMouse.xy/iResolution.xy)*2.-1.)*.25,0.);
    vec2 scn = intSphere(ro,rd,sp,1.);
    vec3 col = texture(iChannel0, uv).xyz;
    if(scn.y == 0.) {
        vec3 p = ro+rd*scn.x;
        vec3 n = normalize(p-sp);
        vec3 rl = normalize(reflect(rd,n));
        vec3 rf = normalize(refract(rd,n,.6));
        
        col = texture(iChannel0, (rf.xy/rf.z)/2.+.5).xyz;
        
        float d = max(dot(LIGHT_DIR,n),0.);
        float s = pow(max(dot(LIGHT_DIR,rl),0.),60.);
        col = (col*d)+s;
        
        vec3 rc = texture(iChannel0, (rl.xy/rl.z)/2.+.5).xyz;
        float f = 1.-pow(max(-dot(rd,n),0.),.5);
        col = mix(col, rc, f);
    }
    return col;
}

// Function 713
vec3 Env_GetDirectionalLightFlare(const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)
{
	float fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);
	//float kSpreadPower = 5.0;
	//return vLightColour * pow(fDirDot, kSpreadPower) * 0.25;
    
    return exp2( vLightColour * fDirDot * 0.1);
}

// Function 714
float calcAo(vec3 p, vec3 n)
{
    //I get the general idea of ao, but I do not understand
    //why we are subtraction d by the distance.
    
   //I also can't really picture this algorithm as a whole, 
    //like what kind of values are being accumulated and what ...
 	
const float ao_samples = 5.;
    float r = 0.0, w = 1.0, d;
    for(float i = 0.01 ; i<ao_samples ; i+=1.1)
    {
    d = i/ao_samples;//1/5, 2/5, 3/5, 4/5, 1
    r += w*(d - map(p + n*d));
     //r is accumulating the weighted results
        
        //map(p + n*d) means move a ray from the sp out in direction of normal.
        //n is normalized so it's length is 1.
        //d is from 0.20 to 1, so ray will only move out by max 1.
        //d - map(p+n*d) then means (0.20 to 1) - distance to closest object as ray moves away from
        //initial surface in direction of normal.
        //so you would expect map(p + n*d) to be either the distance to sp, in the case that
        //there is no real occlusion.
        //in the case that there is occlusion you would expect map(p+n*d) to get smaller again 
        //as it gets closer to another surface.
        
        //I'm pretty sure w means the further you get from the initial surface, the less you take 
        //into consideration the distance to the next object?
       
        
        //ok I figured out a way to look at this.
        //take a sphere who's closest face is distance 2. away from camera. 
        //from that surface, add n*d... so you move directed away from the 
        //the surface towards the camera again.
        //first step is by 0.2 because d will be 0.20 and so the distnace 
        //returned will be 0.20
        //0.20 - 0.20 will be 0, and w *0 will be zero.
        //each step will happen the same way, for all points if there is just a sphere.
        
        //so no occulution.
        
        //if we use a cube on a plane instead, a point on a face of the cube
        //that is close to the plane, means as the ray travels out from that point
        //along the normal, it will retain the same distance to the plane.
        //let's say that distance is 0.2.
        //then for each step, the map will return 0.2, 
        //and d - 0.2 will be 0, 0.2, 0.4, 0.6, and 0.8(wait know d starts at 0.01,so its ~-0.2, 0.0, 0.2..
        //if we didn't subtract by d we would always just have ~-0.2.
        //w* is an acculumation weight, and if...ok I'll come back to this.
       
       
    w*=0.5;
    }

    return 1.0 - clamp(r,0.0, 1.0);
}

// Function 715
float shadow(vec3 p, vec3 n, vec3 lPos)
{
    return shadow(p + n * MIN_DST * 4.0, lPos);
}

// Function 716
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 717
vec3 StreetLights(ray r, float t, float roadWith){

    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;
    r.d.x = abs(r.d.x);
    const float s = 1./ 10.;//s has to be a constant, represent a quantity
    float m = 0.;
    for(float i = 0.;i< 1.;i += s){
        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;
        vec3 p = vec3(roadWith , 3.5 , 100.- ti*100.);
        m += Bokeh(r, p, .05, .1)*ti*ti*ti;//x^n can make curve flatter;
    }
    
    
    return  vec3(1., .7, .3) *m;
}

// Function 718
vec4 ShadowInfoForBackground( vec3 seed, vec3 start, vec3 dir CACHEARG )
{
    if ( dir.y >= 0.0 )
        return vec4( 0.0 );
    
    // intersect with ground plane
    float t = (GROUND_PLANE_HEIGHT - start.y) / dir.y;
    vec3 bgPos = start + dir * t;
    
    // I'm having trouble with artifacts near the bottom of the sculpture because the shadow turns dark
    // very abruptly there and so the low resolution of the shadow buffer becomes obvious.
    // By artificially lowering the shadow sampling point a tad, the shadow gets softer and the artifacts
    // are less noticeable.
    #if SHADOW_Y_HACK
    bgPos.y -= 0.75;
    #endif
    
    float spotlightBrightness = GetFloorSpotlightBrightness( bgPos );
    if ( spotlightBrightness == 0.0 )
        return vec4( 0.0 );
    
    vec4 res = vec4( 0.0 );
    
    const vec3 DirectLightingSampleScale = vec3( 2.0 * BG_BOX_SCALE.x / float( GROUND_SHADOW_TEST_X_COUNT ), 0.0, 2.0 * BG_BOX_SCALE.z / float( GROUND_SHADOW_TEST_Z_COUNT ) );
    for ( int z = ZERO_NO_LOOP_UNROLL; z < GROUND_SHADOW_TEST_Z_COUNT; z++ )
    {
        for ( int x = ZERO_NO_LOOP_UNROLL; x < GROUND_SHADOW_TEST_X_COUNT; x++ )
        {
            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            vec3 ceilingPos = vec3( BG_BOX_CENTER.x - BG_BOX_SCALE.x, CEILING_HEIGHT, BG_BOX_CENTER.z - BG_BOX_SCALE.z );
            ceilingPos += vec3( float( x ) + r2.x, 0.0, float( z ) + r2.y ) * DirectLightingSampleScale;
			ceilingPos.x *= GetBrightnessForTime( blobTime );
            vec3 lightDir = normalize( ceilingPos - bgPos );

            // have to check bounds because the floor isn't always inside them
            vec3 boundsStart;
            vec3 ignoreHitPos;
            if ( !RayHitsBlobBounds( bgPos, lightDir, boundsStart ) || !MarchShadowRay( boundsStart, lightDir, ignoreHitPos CACHE ) )
                res.x += 1.0;
        }
    }
    res.x /= float( GROUND_SHADOW_TEST_X_COUNT * GROUND_SHADOW_TEST_Z_COUNT );

    const float RadiusScale = 1.0 / float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT );
    const float AngleScale = TWOPI / float( BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    for ( int r = ZERO_NO_LOOP_UNROLL; r < BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT; r++ )
    {
        for ( int a = ZERO_NO_LOOP_UNROLL; a < BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT; a++ )
        {
            // get a weighted point on the hemisphere oriented toward normal.
            // start with random point on unit disc.

            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            float angle = (float( a ) + r2.x) * AngleScale;
            float radius = sqrt( (float( r ) + r2.y) * RadiusScale );

            vec2 discPoint = vec2( cos( angle ), sin( angle ) ) * radius;

            vec3 ambientTestDir = GetHemisphereDirForDiscPoint( vec3( 0.0, 1.0, 0.0 ), discPoint );

            // have to check bounds because the floor isn't always inside them
            vec3 boundsStart;
            vec3 shadowApproxHitPos;
            if ( RayHitsBlobBounds( bgPos, ambientTestDir, boundsStart ) && MarchShadowRay( boundsStart, ambientTestDir, shadowApproxHitPos CACHE ) )
                res.z += BlobEmissionAmountAtPos( shadowApproxHitPos );
            else
	            res.y += 1.0;
        }
    }
    res.yz /= float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT * BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    res.y = MIN_AMBIENT + res.y * (1.0 - MIN_AMBIENT);

    res.xy *= GetBrightnessForTime( blobTime );
    
    // we don't include spotlight brightness here because we do include it in GetBackgroundColorForRayGivenLightingData.
    // we include it there because it's good for reflections, which don't sample from this texture.
    //res *= spotlightBrightness;
    
    return res;
}

// Function 719
vec3 directionalLight(vec3 normalizedNormal, vec3 position, vec3 lightPos, vec3 viewPosition, vec3 color, float shadow)
{
    vec3 lightColor = vec3(1.);
    // ambient
    vec3 ambient = lightColor * 0.15 * color;
    
    vec3 lightDirection = normalize(lightPos-position);
    vec3 viewDirection = normalize(viewPosition-position);
	vec3 halfwayDirection = normalize(lightDirection + viewDirection);
    
    // diffuse
    float diffuseIntensity = max(dot(normalizedNormal, lightDirection),0.0);
    vec3 diffuse = diffuseIntensity * lightColor * color;
    
    // specular
    float specularStrength = .85;
    float specularIntensity = pow(max(dot(normalizedNormal, halfwayDirection),0.0),32.);
    //// going glossy on the specular (no color multiplication)
    vec3 specular = specularStrength * specularIntensity * lightColor;						
    return (ambient + (diffuse + specular)*(1. - shadow));

    
}

// Function 720
float calcSoftshadow(in vec3 ro, in vec3 rd)
{
    float res = 1.0;
    float tmax = 12.0;  
    
    float t = 0.02;
    for( int i=0; i<30; i++ )
    {
		float h = map(ro + rd*t, false).x;
        res = min( res, 27.0*h/t );
        t += clamp( h, 0., 0.80 );
        if( res<0.0005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 721
vec3 directLight(vec3 pos, vec3 n){
	vec3 totLights = vec3(0.0);
    //yellow light
	totLights += nee(pos, n, normalize(vec3(-.5, -1, -1)), vec3(.7, .5, .3) * 6.0, .1);
    //purple light
	//totLights += nee(pos, n, normalize(vec3(.5, 1, -1)), vec3(.7, .3, .5) * 4.0, .1);
	return totLights * 1.0;
}

// Function 722
float calcAO( const vec3 pos, const vec3 nor ) {
	float aodet=detail*40.;
	float totao = 0.0;
    float sca = 14.0;
    for( int aoi=0; aoi<5; aoi++ ) {
        float hr = aodet*float(aoi*aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = de( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - 5.0*totao, 0., 1.0 );
}

// Function 723
vec4 get_light(int index)
{
    ivec2 addr = ivec2(ADDR_RANGE_LIGHTS.xy);
    addr.x += index;
    return texelFetch(SETTINGS_CHANNEL, addr, 0);
}

// Function 724
vec3 shade(in vec3 pos, in vec3 rd, in vec3 n, in vec3 alb)
{
    const float rough = 0.57;
    float nl = dot(n, lgt);
    float nv = dot(n, -rd);
    vec3 col = vec3(0.);
    float ao = calcAO(pos, n);
    vec3 f0 = vec3(0.1);
    if (nl > 0.)
    {
        vec3 haf = normalize(lgt - rd);
        float nh = clamp(dot(n, haf), 0., 1.); 
        float nv = clamp(dot(n, -rd), 0., 1.);
        float lh = clamp(dot(lgt, haf), 0., 1.);
        float a = rough*rough;
        float a2 = a*a;
        float dnm = nh*nh*(a2 - 1.) + 1.;
        float D = a2/(3.14159*dnm*dnm);
        float k = pow(rough + 1., 2.)/8.; //hotness reducing
		float G = (1./(nl*(1. - k) + k))*(1./(nv*(1. - k) + k));
        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh);
        vec3 spec = nl*D*F*G;
        col.rgb = lcol*nl*(spec + alb*(1. - f0));
    }
    col *= shadow(pos, lgt, 0.1,2.)*0.8+0.2;
    
    #if 1
    float bnc = clamp(dot(n, normalize(vec3(-lgt.x,5.0,-lgt.z)))*.5+0.28,0. , 1.);
    col.rgb += lcol*alb*bnc*0.1;
    #endif
    
    col += 0.05*alb;
    col *= ao;
    return col;
}

// Function 725
float octreeshadow(vec3 ro, vec3 rd, float lightdist) {
    vec3 dummy1;
    float dummy2;
    float proxim;
    float len = octreeray(ro,rd,lightdist,dummy1,dummy1,dummy2,proxim).x;
    if (len >= lightdist) {
        return proxim;
    } else {
        return 0.0;
    }
}

// Function 726
vec3 shade(vec3 ori, vec3 dir) {
 
    float  t = raymarch(ori, dir);
    vec3 col = vec3(0.);
    
    if(t < MAX_DISTANCE) {

        vec3  p = ori + dir * t;
        vec3  n = calcNormal(p);
        vec3  r = normalize(reflect(dir, n));
        col = shadeObjects(p,n,r);
        
        vec3  rc = vec3(0.);
        float rt = raymarch(p+r*SHADOW_BIAS,r);
        if(rt < MAX_DISTANCE) {
            vec3 rp = p + r * rt;
            vec3 rn = calcNormal(rp);
            vec3 rr = normalize(reflect(r,rn));
            rc = shadeObjects(rp,rn,rr);
        }
        
        float f = 1. - pow(max(-dot(dir, n), 0.), .25);
        col = mix(col, rc, f);
        
    }
    
    vec3 lv = getPointLightVector(ori);
    vec3 ld = normalize(lv);
    float f = pow(max(dot(dir,ld), 0.), 30.);
    f   *= softshadow(ori, ld, 0., length(lv), 64.);
    col += POINT_COL * f;
    
    return col;
    
}

// Function 727
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<10; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
		t += clamp( h, 0.02, 2.0 );
		if( res<0.01 || t>10.0 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 728
float SoftShadowTower( in vec3 origin, in vec3 direction, float res)
{
  float t = 0.0, h;
  vec3 rayPos = vec3(origin+direction*t);

  for ( int i=0; i<NO_UNROLL(11); i++ )
  {

    h = sdConeSection(rayPos-vec3(-143, 0., 292)-vec3(0., 12., 0.), 10.45, 2.40, 1.40);

    res = min( res, 6.5*h/t );
    t += clamp( h, 0.4, 1.5);
    if ( h<0.005 ) break;
    rayPos = vec3(origin+direction*t);
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 729
vec3 traceLight( in vec3 from, in vec3 norm, in uvec3 seed ) {
    vec3 pos = vec3(0);
    vec3 diff = vec3(0);
    vec3 dummyNorm = vec3(0);
    
    // create a random dir in a hemisphere
    vec3 rand = hash(seed);
    float dirTemp1 = 2.0*PI*rand.x;
    float dirTemp2 = sqrt(1.0-rand.y*rand.y);
    vec3 dir = vec3(
        cos(dirTemp1)*dirTemp2,
        sin(dirTemp1)*dirTemp2,
        rand.y);
    dir.z = abs(dir.z);
    
    // pick the sun more often (importance sampling)
    const float sunContrib = colorSun.a*2.0*PI*(1.0 - sunCosAngle);
    const float ambientContrib = colorAmbient.a*2.0*PI;
    const float sumContrib = sunContrib+ambientContrib;
    
    float a = sunContrib / sumContrib;
    float b = a + ambientContrib / sumContrib;
    
    if (rand.z < a) {
        const vec3 sunDirTan = normalize(cross(sunDir, vec3(0, 0, 1)));
        const vec3 sunDirCoTan = cross(sunDir, sunDirTan);
        float rot = 2.0*PI*rand.x;
        float the = acos(1.0 - rand.y*(1.0 - cos(sunAngle)));
        float sinThe = sin(the);
        dir = sunDirTan*sinThe*cos(rot) +
            sunDirCoTan*sinThe*sin(rot) - sunDir*cos(the);
    }
    
    if (trace(from, dir, false, pos, dummyNorm, diff)) {
        vec3 back = getBackground(dir);
        float l = max(0.0, dot(dir, norm));
        return back*l*sumContrib;
    } else {
        return vec3(0);
    }
}

// Function 730
void update_light_position(void)
{
    float sn = sin(iTime * 3.0);
    float cs = cos(iTime * 3.0);
    light_position = vec3(sn * 0.2,
                          0.9 + cs * cs * 0.2,
                          cs * 0.1);
}

// Function 731
vec3 shade(vec3 o, vec3 r, vec3 w, inout vec3 sn, float t)
{
    mat3 texb = basis(sn);
    vec3 wq = fract(w) * 2.0 - 1.0;
    vec2 texl = texcoords(wq * texb);
    vec3 tex = textureGamma(iChannel0, texl);
    sn = texb * bump(iChannel0, texl, 0.5);
    
    vec3 lp = vec3(0.0, 0.0, 0.0 + iTime);
    vec3 lv = w - lp;
    float ld = length(lv);
    lv /= ld;
    float lt = 0.0;//trace(lp + sn * 0.01, lv);
    float lm = 1.0;
    if (lt < ld) {
        lm = 1.0;
    }
    float lb = max(dot(sn, -lv), 0.0);
    float la = 1.0 / (1.0 + ld * ld * 0.1);
    vec3 light = lb * la * lm * vec3(1.0, 1.0, 0.8);
    
    light += mix(vec3(0.0), vec3(1.0), 0.5+0.5*sn.y);

    return light * tex * 1.0 / (1.0 + t * t);
}

// Function 732
float calcAO( in vec3 pos, in vec3 nor ){
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<6; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 733
vec3 LightCubes(vec3 pos, vec3 n)
{
	vec3 qpos = QbertStart;
	float dir;
	ivec3 ipos = ivec3(floor(pos+.5));
	float foundHit = 0.0;
	int end = int(mod(time*.8, 18.0));
	
	vec3 areaColour = vec3(.53, .7, .85);
	for (int t = 0; t < 18; t++)
	{
		qpos = MoveQbert(DirTable[t], qpos, dir);
		ivec3 ip = ivec3(floor(qpos+.5));
		if (ip == ipos && n.y >= .8)
		{
			if (t >= end) 
			foundHit = .5;	
			else
			foundHit = 1.5;
		}
	}
	if (foundHit > 0.0) areaColour = HueGradient((floor((time*.8/18.0))+foundHit)/4.23);
	
    float diff = dot(n, lightDir);
    diff = max(diff, 0.0);
    return diff * areaColour;	
}

// Function 734
float Shadows(vec3 Pos, vec3 Dir, float MaxDist, float ConeRatio) {
    Info t; float Dist=0.; float Occ=1.; float sD,Dif;
    while (Dist<MaxDist) {
        t=DF(Pos+Dir*Dist,iTime);
        if (t.d<0.001) return 0.;
        sD=Dist*ConeRatio;
        Dif=t.d-sD;
        Occ=Occ*((Dif<0.)?(sD*2.+Dif)/(sD*2.):1.);
        Dist=Dist+t.d;
    }
    return Occ;
}

// Function 735
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 rdx, in vec3 rdy )
{
    float eps = 0.001;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps*t );
    float kk;

    vec3 mateD = vec3(0.2,0.16,0.11);
    vec3 mateS = vec3(0.2,0.12,0.07);
    float mateK = 0.0;
    float focc = 1.0;
    
    // derivatives
    vec3 dposdx = t*drddx;
    vec3 dposdy = t*drddy;
    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );

    
    if( m<0.5 ) // arlo
    {
        mateD = vec3(0.05,0.2,0.04)*0.7;
        mateS = vec3(2.0,1.0,1.0)*0.5;
    
        // back
        float pz = smoothstep(0.0,1.0,max(0.0,pos.y-0.0));
        float pp = smoothstep( 0.6, 1.6, sin(pos.x*18.0) + pz*1.5 );
        pp *= 1.0-smoothstep(0.1,1.5,length(pos-vec3(0.0,1.0,0.0)));
        mateD = mix( mateD, vec3(0.05,0.2,0.08)*0.54, pp );         
    
        // nose
        mateD = mix( mateD, vec3(0.13,0.21,0.04)*0.7,1.0-smoothstep(0.0,0.5,length(pos-vec3(-3.45,2.15,0.0))));

        // belly
        mateD = mix( mateD, vec3(0.16,0.22,0.10)*0.55,smoothstep(0.5,1.0,-nor.y)*(1.0-smoothstep(0.9,1.2,length(pos))));

        // neck
        vec2 b = sdSegment( pos, vec3(-0.9,-0.3,0.0), vec3(-2.6,1.7,0.0) );
        float tr = 0.3;// - 0.25*b.y;
        float d3 = b.x - tr;
        float bn = 1.0-smoothstep(0.05,0.15,d3);
        bn *= smoothstep(0.0,0.5,-nor.y);
        bn *= 1.0-smoothstep(0.7,1.0,b.y);
        mateD = mix( mateD, vec3(0.1,0.23,0.07)*0.7,bn);

        
        vec3 tc = texcube( iChannel1, 0.2*pos, nor, 4.0, 0.2*dposdx, 0.2*dposdy ).xyz;
        mateD *= 0.7+0.6*tc*tc;

        float te = texcube( iChannel0, 2.0*pos, nor, 4.0, 2.0*dposdx, 2.0*dposdy ).x;
        mateD *= 0.9 + 0.1*te;    
    
        mateK = 0.75*(0.5+0.5*tc.x*te);
        
        mateD.z += 0.05*(texcube( iChannel1, 0.025*pos, nor, 4.0, 0.025*dposdx, 0.025*dposdy ).x-0.5);
    }
	else if( m<1.5 ) // eyes
    {
        mateD = vec3(0.2,0.2,0.2)*0.7;
        mateK = 2.0;
        mateS = vec3(0.4);
        
        vec3 cen = vec3(-2.755,2.36,0.1*sign(pos.z));
        vec3 dir = normalize(pos-cen);
        vec3 view = vec3(-1.0,-0.1,0.1);//normalize( ro-(cen) );
        float d = dot( dir, view ); 
        
        float p = 1.0-smoothstep( 0.82, 0.83, d );
        mateD *= p;
        mateS *= p;
        float r  = pow(clamp( (d-0.83)/(1.0-0.83),0.0,1.0),2.0);
        
        float br = 3.5*pow(clamp(dot( nor, view ),0.0,1.0),32.0);
        mateD = mix( mateD, vec3(0.03,0.015,0.0)*2.5*(1.0+br), smoothstep(0.0,0.05,r) );
        mateD = mix( mateD, vec3(0.00,0.000,0.0), smoothstep(0.5,0.60,r) );
        
        float ff = smoothstep( 0.0, 0.1, -pos.x-2.75 );
        mateD *= ff;
        mateS *= ff;
        mateK *= ff;
    }
	else if( m<2.5 ) // terrain
    {
        mateD = vec3(0.1,0.05,0.02);
        mateD = pow( textureGrad( iChannel1, 0.3*pos.xz, 0.3*dposdx.xz, 0.3*dposdy.xz ).xyz, vec3(1.5))*0.3*vec3(1.1,1.0,0.9);
        mateK = 1.0;
        mateS = vec3(0.0,0.0,0.0);
        focc = textureGrad( iChannel0, 0.5*pos.xz, 0.5*dposdx.xz, 0.5*dposdy.xz ).x;
        
        // grass        
        float gr = textureGrad( iChannel2, 0.004*pos.xz, 0.004*dposdx.xz, 0.004*dposdy.xz ).x;
        float pi = textureGrad( iChannel0, 0.400*pos.xz, 0.400*dposdx.xz, 0.400*dposdy.xz ).x;
        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );
        float hi = smoothstep( 0.85, 1.0, nor.y )*gr;//iq
        mateD = mix( mateD, vec3(0.25,0.14,0.0)*0.4*(0.75+0.5*pi), hi );
        focc = mix( focc, 1.0, hi );
        mateK *= 1.0-hi;
        
        mateD *= 0.9;
    }
	else //if( m<3.5 ) // nails
    {
        mateD = vec3(0.12,0.12,0.05)*1.3;
        mateK = 0.0;
        mateS = vec3(0.0,0.0,0.0);
        float gr = texcube( iChannel2, 0.8*pos*vec3(1.0,0.2,1.0), nor, 4.0, 0.8*dposdx*vec3(1.0,0.2,1.0), 0.8*dposdy*vec3(1.0,0.2,1.0) ).x;
        mateD *= 0.6 + 0.8*gr;
    }    
    
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = min(calcOcclusionArlo(pos,nor),
                    calcOcclusionTerrain(pos,nor,t) )*focc;
        
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );
    float sha = min( calcShadowArlo( pos, sunDir, 32.0 ),
                     calcShadowTerrain( pos, sunDir, 32.0 ) );
    dif1 *= sha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );
    float bou = clamp( 0.5-0.5*nor.y, 0.0, 1.0 );

    // sun
    vec3 col = 4.0*vec3(1.1,0.7,0.3)*dif1;//*(0.5+0.5*occ);
    // sky
    col +=1.35*4.0*vec3(0.2,0.6,1.3)*occ*(0.5+0.5*nor.y);
    // ground
    col += 2.5*vec3(0.4,0.1,0.1)*bou*(0.5+0.5*occ);
    // back
    col += 1.0*vec3(0.8,0.5,0.4)*bak*occ;
    // sss
    col += 10.0*fre*(0.2+0.8*dif1*occ)*mateS;

    col *= mateD;

    // sun
    col += 0.5*vec3(1.0,0.9,0.8)*pow( spe1, 16.0 )*dif1*mateK;
    // sky
    col += 0.3*vec3(0.2,0.3,1.0)*occ*mateK*smoothstep( -0.3, 0.5, reflect( rd, nor ).y )*occ;

    // fog
    col = mix( col, vec3(0.4,0.5,0.8), 1.0-exp(-.0007*t));
    
    return col;        
}

// Function 736
float calculate_ao(vec3 p, vec3 n) {
	const float AO_SAMPLES = 5.;
	float r = 0., w = 1., d;

	for (float i = 1.; i < AO_SAMPLES + 1.1; i++) {
		d = i / AO_SAMPLES;
		r += w * (d - de(p + n * d));
		w *= .5;
	}

	return 1. - clamp(r, 0., 1.);
}

// Function 737
float fancyLight(ray primaryRay, vec4 light) {
	float luminance = 0.0;
	//vector from origin to light center
	vec3 originToLight = light.xyz - primaryRay.origin;
	
	//check to see if the light is behind us
	if(dot(primaryRay.direction, originToLight) >= 0.0) {
		//see if our ray is within the light boundary
		vec3 nearest = -(originToLight
						 + primaryRay.direction * dot(-originToLight, primaryRay.direction));
		float dist = length(nearest);
		if(dist <= light.w) {
			float lightness = (light.w - dist) / light.w;
			luminance = pow(lightness, 22.0);
		}
	}
	return luminance;
}

// Function 738
float cAO(in vec3 p, in vec3 n)
{
	float sca = 3., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = m(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 739
float getShadow(vec3 ro, vec3 rd)
{
   float d = 0.001; 
   
   for(int i = 0; i < MAXSTEP; i++)
   {
       vec3 pos = ro + d*rd;
       
       float eval = map(pos).x;
       
       if(eval < 0.0) return 0.0;
       d += max(eval,0.04);
       
       if(d > 20.0) return 1.0;
   }
    
   return 1.0;
}

// Function 740
float Shadow(vec3 pos, float d)
{
    float shadow = 1.0;
    float depth  = mix(1.0, 0.3, clamp(d / 3.0, 0.0, 1.0));
    
    for(int i = 0; i < 64; ++i)
    {
        vec3 p = pos + (SunLightDir * depth);
        vec2 sdf = Scene(p, 1.0);
        
        shadow = min(shadow, (32.0 * sdf.x) / depth);
        depth += sdf.x;
        
        if(sdf.x < 0.001)
        {
            break;
        }
    }
    
    return clamp(shadow, 0.1, 1.0);
}

// Function 741
float oceanLightingSun(vec3 V, vec3 L, vec3 N, vec3 tx, vec3 ty, float ox, float oy)
{
    // override N
    if (dot(V, N) < 0.0) {
        N = reflect(N, V); // reflects backfacing normals
    }

    vec3 H = normalize(V+L);
    vec3 Ns = vec3(0., 1., 0.);
    vec2 ChiH = -vec2(dot(H, tx), dot(H, ty))/dot(H, N);
    float VoN = dot(V, N);
    float LoN = dot(L, N);
    float HoN = dot(H, N);
    float cosTetaV = dot(V, Ns);
    float cosTetaL = dot(L, Ns);
    float tetaV = acos(cosTetaV);
    float tetaL = acos(cosTetaL);
    float phiV = atan(dot(V, ty), dot(V, tx));
    float phiL = atan(dot(L, ty), dot(L, tx));
    float cosPhiV = cos(phiV);
    float sinPhiV = sin(phiV);
    float cosPhiL = cos(phiL);
    float sinPhiL = sin(phiL);
    
    // paper interpretation
    // float mu_v = pow(2.*(ox*ox*cosPhiV*cosPhiV+oy*oy*sinPhiV*sinPhiV)*tan(tetaV),-0.5);
    // float mu_l = pow(2.*(ox*ox*cosPhiL*cosPhiL+oy*oy*sinPhiL*sinPhiL)*tan(tetaL),-0.5);
    // paper source
    float mu_v = cosPhiV/sqrt((1.-cosPhiV*cosPhiV)*(2.*ox*ox));
    float mu_l = cosPhiL/sqrt((1.-cosPhiL*cosPhiL)*(2.*oy*oy));
    
    float F = 0.033+0.967*pow(1.-dot(V,H), 5.);//Fresnel_Schlick(1.033, 1., dot(V, H));
    
    float P = exp(-.5*((ChiH.x*ChiH.x/ox*ox)+(ChiH.y*ChiH.y/oy*oy)))/(2.*PI*sqrt(ox*oy));
    
    // paper interpretation
    //float res = 4.*pow(dot(H,N), 4.)*max(0., cosTetaV)
    //    *(1.+max(0., alpha(mu_v))+max(0., alpha(mu_l)));
    // res = (P*F)/res;
    // paper source
    float res = F * P / (
        (1.0 + max(0., alpha(mu_l)) + max(0., alpha(mu_v)))
                              * max(0., VoN) * HoN*HoN * HoN*HoN * 4.0);
    return res;
}

// Function 742
C_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )
{
    C_Shading shading;
    
    vec3 vToLight = light.vPos - vSurfacePos;
    vec3 vLightDir = normalize(vToLight);
    float fLightDistance = length(vToLight);
    
    float fAttenuation = 1.0 / (fLightDistance * fLightDistance);
    
    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );
    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));
    
    shading.cDiffuse = vIncidentLight;                                  
    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;
    
    return shading;
}

// Function 743
bool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )
{
    float he2 = he*he;
    
    float k2 = 1.0        - rd.y*rd.y;
    float k1 = dot(ro,rd) - ro.y*rd.y;
    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return false;
    h = sqrt(h);
    float t = (-k1-h)/k2;

    // body
    float y = ro.y + t*rd.y;
    if( y>0.0 && y<he )
    {
        return t>0.0 && t<tmax;
    }
    
    // caps
    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;
    if( abs(k1+k2*t)<h )
    {
        return t>0.0 && t<tmax;
    }

    return false;
}

// Function 744
vec3 doLighting( in vec3 n, in vec3 c, in vec3 rd, in vec3 rdc )
{
    vec3  l   = normalize( pos_star + 2.0 * ( pos_star - dot( pos_star, rdc ) * rdc ) );
    float ndl = dot( n, l );
    float ndr = dot( n, -rd );
    float ldr = dot( l, rd );
    float f   = max( ndl, 0.0 ) + 0.002;
    float g   = ldr * smoothstep( 0.0, 0.1, ndr ) * pow( 1.0 - ndr, 10.0 );
    return clamp( f * c + g * col_star, 0.0, 1.0 );
}

// Function 745
float getLightSDF(vec3 p){
    float d = MAX_DIST;
    d = min(MAX_DIST, sphereSDF(p-getLightPosition(0), 0.2));
    d = min(d, sphereSDF(p-getLightPosition(1), 0.2));
    return d;
}

// Function 746
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<24; i++ )
    {
		float h = GetDist( ro + rd*t );
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.2 );
        if( res<0.004 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 747
float calcSoftShadow( vec3 ro, vec3 rd, bool showSurface )
{
    float res = 1.0;
    const float tmax = 2.0;
    float t = 0.001;
    for( int i=0; i<64; i++ )
    {
     	float h = map(ro + t*rd, showSurface).x;
        res = min( res, 64.0*h/t );
    	t += clamp(h, 0.01,0.5);
        if( res<-1.0 || t>tmax ) break;
        
    }
    res = max(res,-1.0);
    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]
}

// Function 748
float shadows( vec3 ro, vec3 rd, float tMax, float k, int octaves ) {
    float res = 1.0;
	float t = 0.001;
	for(int i=0; i<5; i++) {
        if (t<tMax) {
			float h = map(ro + rd*t, octaves).x;
        	res = min( res, k*h/t );
        	t += h;
		}
		else break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 749
float calcAO( const vec3 pos, const vec3 nor ) {
	float aodet=detail*75.;
	float totao = 0.0;
    float sca = 8.0;
    for( int aoi=0; aoi<6; aoi++ ) {
        float hr = aodet*float(aoi*aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = de( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - 5.0*totao, 0., 1. );
}

// Function 750
float dChaosArrow( vec3 p)
{
  vec3 b = vec3(0.4,2.0,0.2);
  p.y +=0.2;
  
  /*float diffy = -0.3 - p.y;
  b.x += (step(0.3, p.y) * (1.3 - p.y) *0.5) +
  		  step(0.0, diffy)  * (diffy) * 0.5;*/
  if (p.y > 0.3)	  
	  b.x  *= (2.0 - p.y) *1.5;
  else if (p.y <-0.3)  
	  b.x *= 1.1+ (-0.3-p.y)  * 1.14;
  
  
  //p.y += 2.0;
 
  vec3 d = abs(p) - b;

  //return length(max(abs(p)-b,0.0))-0.1;

  
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d ,0.0));
}

// Function 751
vec3 directLight(vec3 pos, vec3 dir, float headStart){
    vec3 lightDir = vec3(0., 0., 1.) * rotationMatrix(LightRot);
    vec3 pos0 = pos, oldPos, volAbs = vec3(1.);
    float stepDist;
    for(int i = 0; i < ShadowSteps; i++){
        oldPos = pos;
        pos = pos0 - lightDir * pow((float(i)+headStart) / float(ShadowSteps), ShadowSampleBias) * ShadowRange;
        volAbs *= vec3(exp(-density(pos)*length(pos-oldPos)*VolumeColor));
    }
    return LightCol * volAbs * henyeyGreenstein(-lightDir, dir);
}

// Function 752
vec3 shade(Ray ray) {
 
    Hit scn  = raymarch(ray);
    vec3 col = texture(iChannel0, ray.dir).xyz;

    if(scn.h) {
        
        vec3 n  = calcNormal(scn.p);
        vec3 r  = normalize(reflect(ray.dir, n));
        
        Ray rr  = Ray(scn.p + r * .01, r);
        Hit rh  = raymarch(rr);
        vec3 rc = texture(iChannel0,r).xyz;
        if(rh.h) rc = shadeObjectFlat(rr,rh,calcNormal(rh.p));
        
        float fresnel = 1. - mix(.1, .9, max(pow(-dot(ray.dir,n), .4),0.));
        col = mix(shadeObjectFlat(ray,scn,n), rc, fresnel);
        
    }
    
    return col;
    
}

// Function 753
float softshadow(vec3 ro,vec3 rd) 
{
    float sh = 1.0;
    float t = 0.02;
    float h = 0.0;
    for(int i = 0; i < 22; i++)  
	{
        if(t > 20.) continue;
        h = map(ro + rd * t);
        sh = min(sh, 4.0 * h / t);
        t += h;
    }
    return sh;
}

// Function 754
vec3 lighting(in Hit h) {
  if (h.ray.len > MAX_TRACE_DIST) return pow(textureLod(iChannel0, -h.ray.dir, 0.).rgb,vec3(0.4));
  vec4 fgi = gi(h.pos, h.nml);    // Fake Global Illumination
  vec4 fcs = cs(h.pos, dif.dir);  // Fake Caustic Shadow
  //   lin = ([Ambient]        + [Diffuse]        * [SS] + [CAUSTICS]) * [AO] + [GI]
  vec3 lin = (_lit(h.nml, amb) + _lit(h.nml, dif) * fcs.w + fcs.rgb) * fgi.w + fgi.rgb;
  return  h.srf.kd * lin;
}

// Function 755
vec3 computeLightGlow(in vec3 position, in vec3 lightCol, in vec3 lightPos, in float lightRadius)
{
    vec3 glare = spotlightsGlare * lightCol * smoothstep(lightRadius * 10.0, 0.0, length((lightPos.xy - position.xy) * vec2(1.0, 16.0)));
    vec3 innerGlow = vec3(0.8) * smoothstep(lightRadius, lightRadius * 0.5, distance(lightPos.xy, position.xy));
    vec3 outerGlow = 0.25 * lightCol * smoothstep(lightRadius * 2.5, 0.0, distance(lightPos.xy, position.xy));
  
    return innerGlow + outerGlow + glare;
}

// Function 756
float getLightSphere(vec3 p, Sphere sphere) {
    vec3 lightPos = vec3(-sin(iTime), 20.0 * sin(cos(iTime)), -cos(iTime));
    
    vec3 l = normalize(lightPos - p);
    vec3 n = getNormalSphere(p, sphere);
    
    float dif = dot(n, l);
    float d = rayMarch(Ray(p + n*SURFACE_DIST*2., l), sphere);
    
    if (d < length(lightPos - p)) {
        dif *= .1;
    }
    
    return dif;
}

// Function 757
float softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
	
    float res = 1.0;
    if( b>0.0 )
    {
        float h = dot(oc,oc) - b*b - sph.w*sph.w;
        res = clamp( 2.0 * h / b, 0.0, 1.0 );
    }
    return res;
}

// Function 758
float light_diffuse(vec3 normal, vec3 light_dir, float scattering) {
    float result = clamp(dot(-light_dir, normal) * (1.0 - scattering) + scattering, 0.0, 1.0);
    return result;
}

// Function 759
float getLightFactor(in vec4 lightPos, in vec4 worldPos, in vec4 worldNormal, in Scene scene){
    vec4 diff = lightPos - worldPos;
    float lightDist = length(diff);
    vec4 lightDir = normalize(diff);
    float lightDot = clamp(dot(lightDir, worldNormal), 0.0, 1.0);
    
    //shadow
    Ray lightRay = Ray(scene.sunPos, -lightDir);
    RayHit lightHit = rayCastBase(lightRay, scene);    
    
    const float shadowBias = 0.01;
    
    return lightDot * float((lightHit.dist + shadowBias) > lightDist);
}

// Function 760
float ShadowMarch(in vec3 origin, in vec3 rayDirection)
{
	float result = 1.0;
    float t = 0.01;
    for (int i = 0; i < 64; ++i)
    {
        float hit = SdScene(origin + rayDirection * t).x;
        if (hit < 0.001)
            return 0.0;
        result = min(result, 5.0 * hit / t);
        t += hit;
        if (t >= 1.5)
            break;
    }
    
    return clamp(result, 0.0, 1.0);
}

// Function 761
vec3 directionalLighting(Trace trace, DirectionalLight light){

    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);
    
    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);
    
    float shadow = castShadow(Ray(trace.p,light.direction),3.0);
    color *= shadow;
    return  color;
}

// Function 762
vec3 computeLight(vec3 pos, vec3 color, vec3 normal) {
    vec3 res = texture(iChannel1, normal).rgb * 0.8;
    int size = 2;
    for (int i = 0; i <  size; i++) {
        vec3 toLight = LIGHTS[i].center - pos;
        float distSq = dot(toLight, toLight);
        float att1 =  isOccluded(pos, LIGHTS[i].center + randDir * LIGHTS[i].radius) ? 0.0 : 20.0f / distSq;
        res += max(0.0, dot(normal, normalize(toLight))) * att1 * LIGHTS[i].color;
     }
    return color * res;
}

// Function 763
float shadow (in vec3 p, in vec3 lPos) {
    float lDist = distance (p, lPos);
    vec3 lDir = normalize (lPos - p);
    float dist = march (p, lDir);
    return dist < lDist ? .1 : 1.;
}

// Function 764
float LightIntensity(in vec3 world_pos)
{
	float temp = length(get_light_pos() - world_pos);
	return 1.0 / (pow(temp, 1.5)*0.0002);
}

// Function 765
vec3 computeAllLighting(in vec3 iPoint, in vec3 iNormal, in vec3 iOrigin, in vec3 iDiffuseColor) {

    vec3 yellow = vec3(1.0, 1.0, 0.0);
    
    vec3 col = computeLighting(orbPosition0, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)
        + computeLighting(orbPosition1, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)
        + computeLighting(orbPosition2, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)
        + computeLighting(orbPosition3, yellow, iDiffuseColor, iPoint, iNormal, iOrigin, true)
        + computeLighting(lightPosition0, lightColor0, iDiffuseColor, iPoint, iNormal, iOrigin, false)
        + computeLighting(lightPosition1, lightColor1, iDiffuseColor, iPoint, iNormal, iOrigin, false);

    return col;
    
}

// Function 766
int InShadow(vec3 p, vec3 L, out float t)
{
    int shadowHit = NO_HIT;
    Ray sr;
    sr.Direction = L;
    sr.Orgin = p + vec3(0.05);     
    t =  Trace(sr,shadowHit);
    
    return shadowHit;
}

// Function 767
vec3 shade (in Ray ray, in Result res) {
    vec3 amb = vec3 (.0);
    vec3 diffC[4];

	float pattern1 = saturate (pow (abs(15. * cos(res.point.x+iTime) * sin (res.point.z+iTime)), .3));
    float pattern2 = saturate (pow (abs(2. * cos(res.point.x+iTime) * sin (res.point.z+iTime) * .5 + .5), .3));
    float pattern3 = saturate (pow (length (4.*sin(mod((res.point.y*res.point.x), .3))), .125));
    float pattern4 = saturate (mod (length(res.point*sin(.1*iTime)), .5));

    diffC[0] = mix (vec3 (.3, .6, .9), vec3 (.8), 1. - pattern1);
    diffC[1] = mix (vec3 (.9, .3, .6), vec3 (.9), 1. - pattern2);
    diffC[2] = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern4);
    diffC[3] = vec3 (.0);
    vec3 specC = vec3 (.0);
    vec3 specC2 = vec3 (.0);
    float shininess = 20.;
    float shininess2 = 20.;

    vec3 lCol = vec3 (.95, .95, .75);
    vec3 lPos = vec3 (cos (2. * -iTime) * 3., .5, 1. + sin (1.5 *iTime) * .75);
    vec3 lDir = normalize (lPos - res.point);
    float diff = max (dot (res.normal, lDir), .0);
    vec3 ref = normalize (reflect (ray.rd, res.normal));
    float spec = pow (clamp (dot (ref, lDir), .0, 1.), shininess);
    Result shaRes = trace (Ray (res.point, lDir));
    float lDist = length (lPos - res.point);
    float attenuation = 2. / (lDist * lDist);
    lCol *= attenuation;
    specC *= attenuation;
    float sha = shaRes.dist < lDist ? .5 : 1.;

    vec3 lCol2 = vec3 (.75, .95, .95);
    vec3 lPos2 = vec3 (sin (iTime) * 4., -.25, 1. - cos (iTime) * .5);
    vec3 lDir2 = normalize (lPos2 - res.point);
    float diff2 = clamp (dot (res.normal, lDir2), .0, 1.);
    vec3 ref2 = normalize (reflect (ray.rd, res.normal));
    float spec2 = pow (clamp (dot (ref2, lDir2), .0, 1.), shininess2);
    Result shaRes2 = trace (Ray (res.point, lDir2));
    float lDist2 = length (lPos2 - res.point);
    float attenuation2 = 3. / (lDist2 * lDist2);
    lCol2 *= attenuation2;
    specC2 *= attenuation2;
    float sha2 = shaRes2.dist < lDist2 ? .5 : 1.;

    vec3 col = amb +
        	   sha * (diff * diffC[res.id] * lCol) +
			   (sha >= .5 ? .0 : spec) * specC +
			   sha2 * (diff2 * diffC[res.id] * lCol2) +
               (sha2 >= .5 ? .0 : spec2) * specC;

    return col;
}

// Function 768
float getAO(vec3 endPoint, vec3 normal)
{
	float stepLen = 0.12;
	float AO = 0.0;
    float att = 1.0;

    float offset = 0.02;
   
    for( int i=0; i<5; i++ )
    {
        float dist = offset + stepLen*float(i)/4.0;
        vec3 newEndpoint =  normal * dist + endPoint;
        vec2 VAL = SDF( newEndpoint, endPoint, normal );

        float gap = (dist - VAL.x);
        AO += gap*att;        

        att *= 0.95;
    }

	return 1.0 - clamp(3.5 * AO, 0.0, 1.0);
}

// Function 769
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k ) {
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ ) {
		if( t>maxt ) break;
        float h = map( ro + rd*t );
        res = min( res, k*h/t );
        t += 0.03 + h;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 770
vec3 DirectLightOnVolume(in Ray ray, in float len) {
    const float strata = 1.0/float(VOLUME_DIRECT_LIGHT_SAMPLES);
    vec3 volumeDirectLight = vec3(0.);
    for(int i=0; i<VOLUME_DIRECT_LIGHT_SAMPLES; i++) {
        float particleDist;
        float particlePdf;
        //avoid sampling other side of the light
        float maxt = -(ray.origin.y - light.pos.y) / ray.dir.y;//doesn't work :(
        len = (ray.dir.y > 0.0) ? min(maxt, len) : len;
        float xi = strata*(float(i)+rnd());
        
        sampleEquiAngular( ray, len, xi, light.pos, particleDist, particlePdf );
        vec3 particlePos = ray.origin + particleDist*ray.dir;
        volumeDirectLight += salmpleLightForParticle(particlePos, ray.time) / particlePdf;
        //volumeDirectLight += samplePhaseForParticle(particlePos, ray.time) / particlePdf;
    }
    return volumeDirectLight / float(VOLUME_DIRECT_LIGHT_SAMPLES);
}

// Function 771
vec3 shade(float d) {
  float str = cos(d*200.+3.1415)*0.2+0.8 * pow((exp(0.)-exp(-abs(d))), 0.3);
  return d > 0. ? vec3(1,0.5,0)*str : vec3(0,0.5,1)*str;
}

// Function 772
vec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {
    vec3 lightPos = normalize(vec3(.5,.5,-1.));
    vec3 backLightPos = normalize(vec3(-.5,-.3,1));
    vec3 ambientPos = vec3(0,1,0);
    
    vec3  lig = lightPos;
    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);
    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);
    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
    
    vec3 lin = vec3(0.0);
    lin += 1.20 * dif * vec3(.9);
    lin += 0.80 * amb * vec3(.5, .7, .8);
    lin += 0.30 * bac * vec3(.25);
    lin += 0.20 * fre * vec3(1);
    
    vec3 albedo = model.albedo;
    vec3 col = mix(albedo * lin, albedo, model.glow);    

    return col;
}

// Function 773
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.07 * d, h));
    d += max (0.04, 0.08 * d);
    if (sh < 0.05) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 774
vec3 computeLight(vec3 pos,vec3 color,vec3 normal)
{
     vec3 toLight1 = LIGHT1_POS-pos;
     float distSq1 = dot(toLight1,toLight1);
     float att1 = 20.0f/distSq1;
     if (isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS))
        att1 = 0.0;
     vec3 toLight2 = LIGHT2_POS-pos;
     float distSq2 = dot(toLight2,toLight2);
     float att2 = 10.0f/distSq2;
     if (isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS))
        att2 = 0.0;
     return color*(
         max(0.0,dot(normal,normalize(toLight1)))*att1*LIGHT1_COLOR+
         max(0.0,dot(normal,normalize(toLight2)))*att2*LIGHT2_COLOR+
         texture(iChannel1,normal).rgb*0.6
 );
}

// Function 775
float DisplayShadowMap(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)
{
    // Determine our camera info
    Ray cameraRay = Ray(cameraPosition, cameraDirection); 
    return Intersect(cameraRay);
}

// Function 776
vec4 getLightCol( in int i )
{
    float li = sqrt(0.5 + 0.5*sin(2.0*iTime+ 23.1*float(i)));
    float h = float(i)/8.0;
    vec3 c = mix( vec3(1.0,0.8,0.6), vec3(1.0,0.3,0.05), 0.5+0.5*sin(40.0*h) );
    return vec4( c, li );
}

// Function 777
void GetPointDirectLightIrradiance( const in PointLight pointLight,
                                    const in vec3 geometryPosition,
                                    out IncidentLight directLight){
    vec3 L = pointLight.position - geometryPosition;
    directLight.direction = normalize(L);
    
    float lightDistance = length(L);
    if(TestLightInRange(lightDistance, pointLight.visibleDistance)){
        directLight.color = pointLight.color;
        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visibleDistance, pointLight.decay);
        directLight.visible = true;
    }else{
        directLight.color = vec3(0.0);
        directLight.visible = false;
    }
}

// Function 778
vec3 ringShadowColor( const in vec3 ro ) {
    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {
        return vec3(0.);
    }
    return vec3(1.);
}

// Function 779
float ao(vec3 p, vec3 n, float sc) {
  float d1 = 0.001;
  float d2 = scene(p+n*sc);
  return sqrt(((d2-d1)/sc)*0.5+0.5);
}

// Function 780
void renderWithShadow(inout Ray primaryRay, out vec4 fragColor){
    const vec3 lightDir = normalize(vec3(1, 1, 1));
    const int max_depth = 10;
    
    HitRecord hitRecord;    
    Ray ray = primaryRay;

    if(intersectScene(ray, fragColor, hitRecord) == false) return;
    vec3 p = hitRecord.hitPoint;
        
    Ray shadowRay;
    shadowRay.origin = p;
    shadowRay.dir = lightDir;
    shadowRay.t_min = 0.2;
    shadowRay.t_max = 10000.0;
        
    HitRecord shadowRayHitRecord;
    vec4 ShadowRayFragColor;
    if(intersectScene(shadowRay, ShadowRayFragColor, shadowRayHitRecord) == true){
       //fragColor = vec4(1, 1, 1, 1);
       fragColor = vec4(0, 0, 0, 1);
    }
}

// Function 781
vec4 shadeFragment(vec3 pos, vec3 nor, vec3 rd, mat4 mat)
{
    vec3  col    = vec3(1), diffuse;
    vec4  amb    = vec4(0), res;
    float weight = 0.;

    mat4 lit = getLightInfo(0, pos);
    diffuse  = mix(mat[0].xyz * clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.) * (1. - mat[1].z), mat[0].xyz, mat[0].w);

    //  Calculates the Cook-Torrance BRDF terms for a particular point in the 3D space within the given material setup  
    //  and  light direction.
    //  BRDF function terms used are:
    //          * D term (isotropic  ) - GGX.
    //          * F term (reflectance) - Schlick.
    //          * G term (geometric  ) - Schlick approximation of Smith solved with GGX.
 	vec3  h         = normalize   (-rd + lit[3].xyz);
   	float rsq       = max  (.001, sq(mat[1].x));
    vec3  terms     = vec3
    (
        /* D Term    */ (rsq * rsq / (i_kPi * sq((sq(rsq) - 1.) * sq(clamp(dot(mat[3].xyz, h), 0., 1.)) + 1. ))),   // Isotropic GGX NDF. 
        /* F Term    */ (mat[1].y + (1. - mat[1].y  ) * (pow(1. -    clamp(dot(mat[3].xyz, lit[3].xyz), 0., 1.),  5.))),
        /* G Term    */ sq(1. / (dot(h , lit[3].xyz) * (1. - rsq * .5) + rsq * .5))
    );
	col = diffuse * col * terms.y + mix(lit[1].xyz, vec3(1), mat[0].w) * diffuse;
                                       
    //  Integrates result with ambient light.
    col    += mat[0].xyz * i_kAmbientColor * i_kAmbientLevel;
    return  vec4(col, terms.y);
}

// Function 782
vec3 calcLighting(vec3 col, vec3 ro, vec3 p, vec3 n, vec3 r, float sp) {
 
    vec3 lv = ro - p;
    vec3 ld = normalize(lv);
    
    float d = max(dot(ld,n),0.);
    float s = 0.;
    
    float atten = 1.-smoothstep(3., 25., length(lv));
    d *= atten;
    
    if(raymarch(p+ld*.1,ld) < length(lv))
        d = 0.;
    
    if(d > 0. && sp > 0.)
        s = pow(max(dot(ld,r),0.),sp) * atten;
    
    return col*d+s;
    
}

// Function 783
float SampleShadowMap(in vec3 point, in float shadowMapBias)
{
	const float shadowMapMaxDistance = 23.0;
    
    float shadow = 1.0;
    
    vec3 pointToLight = point - gLightPosition;
    float distanceToLight = length(pointToLight);
    
    vec2 shadowCoords = CalculateShadowMapUV(gLightViewMatrix, point, (iResolution.x / iResolution.y));
    
    if((shadowCoords.x > EPSILON && shadowCoords.y > EPSILON) && (shadowCoords.x < (1.0 - EPSILON) && shadowCoords.y < (1.0 - EPSILON)))
    {
#if POISSON_SAMPLING        
        for(int i = 0; i < 4; ++i)
        {
            const float poissonDiskSpread = 0.00125;
            float shadowMap = SampleShadowMap(shadowCoords + (SamplePoissonDisk(i) * poissonDiskSpread));
            
            float shadowMapDistance = (shadowMap * shadowMapMaxDistance);

            if(shadowMapDistance < (distanceToLight - shadowMapBias))
            {
                shadow -= 0.25;
            }   
        }
#else
        float shadowMap = SampleShadowMap(shadowCoords);
        float shadowMapDistance = (shadowMap * shadowMapMaxDistance);

        if(shadowMapDistance < (distanceToLight - shadowMapBias))
        {
            shadow = 0.0;
        }     
#endif
    }
    return shadow;
}

// Function 784
float shadowsoft( vec3 ro, vec3 rd, float k )
{
	float t=.1;
	float res=1.;
    for (int i=0;i<25;++i)
    {
        float h=map(ro+rd*t);
        if (h<0.001) return 0.;
		res=min(res,k*h/t);
        t+=h;
		if (t>0.23) break;
    }
    return res;
}

// Function 785
float
shadow( in vec3 start, in vec3 dir )
{
    float ret = 1.0;
    float c = 1.0;//step( mod( iTime, 4.0 ), 2.0 );
    float t = 0.02, t_max = 16.0;
    MPt mp;
    
    #if DRAW_ITERATIONS_GRADIENT
    int it_;
    #endif
    for ( int it=0; it!=SHADOW_MAX_ITERS; ++it )
    {
	    #if DRAW_ITERATIONS_GRADIENT
	    it_ = it;
    	#endif
        vec3 here = start + dir * t;
        mp = map( here );
        ret = min( ret, 8.0*mp.distance/t);
        if ( mp.distance < ( T_EPS * t ) || t > t_max )
        {
        	break;
        }
        
        float inc;
        // NOTE(theGiallo): this is to sample nicely the twisted things
        inc = c * mp.distance * 0.4;
		inc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );
        t += inc;
    }
    #if DRAW_ITERATIONS_GRADIENT
    return float(it_);
    #endif
    if ( t > t_max )
    {
        t = -1.0;
    }
    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );

    if ( t < 0.0 )
    {
        return 0.0;
    }
    //return 1.0;
    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );
    float th = 0.1;
    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );
}

// Function 786
void ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in float reflectionAmount, in vec3 rayDir)
{
	if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))
	{
		// diffuse
		vec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);
		float dp = dot(collisionInfo.m_surfaceNormal, hitToLight);
		if(dp > 0.0)
			pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;
				
		// specular
		vec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;
	}
}

// Function 787
vec3 lighting(vec3 p, vec3 n) {
    //AMBIENT (currently 0) Should be multiplied by diffuse color.
    vec3 retval = vec3(0., 0.2, 0.3); 
    float dprod = dot(n, ortho_light_dir);
    if(dprod >= 0.0) {
        retval += ortho_light_color * (
            //DIFFUSE
            vec3(0.85, 0.9, 1.0) * dprod +
            //SPECULAR
            //pow(dprod, 40.0)
            0.0
        );
    }
    return retval;
}

// Function 788
float ObjSShadow (vec3 ro, vec3 rd)
{
  vec3 p, cIdP;
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  if (repObj) cIdP = vec3 (-99.);
  for (int j = VAR_ZERO; j < 16; j ++) {
    p = ro + d * rd;
    if (repObj) {
      cId = floor (p / gSize);
      if (cId != cIdP) {
        SetEngConf ();
        cIdP = cId;
      }
      h = ObjDf (p - gSize * (cId + 0.5));
    } else {
      SetEngConf ();
      h = ObjDf (p);
    }
    sh = min (sh, smoothstep (0., 0.1 * d, h));
    d += 0.3;
    if (sh < 0.05) break;
  }
  return sh;
}

// Function 789
vec3 shade(vec3 p, float d, vec3 n)
{
    // Let's get the appropriate texel.
    vec3 tex = tex(p, n); 
    // Smooth out the transition between geometry and emptiness.
	return abs(tex);
}

// Function 790
vec3 lightDirection()
{
    return -normalize(lightPosition());
}

// Function 791
vec3 shade(vec3 ro, vec3 p, vec3 normal, float mat, float bgAnimSpeed, vec3 fogColor, float dist)
{
    vec3 col = vec3(0.0);

	// material parameters
	vec3 colAmbient 	= vec3(0.2, 0.2, 0.2);
	vec3 colDiffuse 	= 0.6 * vec3(1.0, 0.85, 0.8);
	vec3 colSpecular 	= vec3(1.0, 1.0, 1.0);
	float shininess 	= 100.0;
	float rimStrength 	= 0.4;
	float rimWidth 		= 0.8;
	vec3 rimColor 		= vec3 ((0.7 + 0.2 * sin(0.3 + 1.86 * iTime * bgAnimSpeed)), 
								(0.8 + 0.2 * sin(0.6 + 1.92 * iTime * bgAnimSpeed)), 
								(1.0 + 0.2 * sin(0.2 + 1.64 * iTime * bgAnimSpeed)));
	
	// floor
	if ( abs(mat - MAT_FLOOR) < 0.1)
	{
		colDiffuse = 0.5 * vec3(1.0, 0.85, 0.8);
		//float param = clamp(pow(sin(3.0*p.x + 3.0*p.z), 6.0), 0.0, 1.0);
		//float param = clamp(pow(sin(0.07*dot(p, p + sin(10.0 * iTime) * vec3(1.0, 2.3, 0.3))), 6.0), 0.0, 1.0);
		//colDiffuse = vec3(0.6, 0.5, 0.1 + 0.4 * param);
		
		rimStrength = 0.5;
	}
	// body 1
	else if ( abs(mat - MAT_BODY_1) < 0.1)
	{
		vec3 pos = p;
		pos.xz -= g_posVel1.xy;
		pos.y -= 0.8 * (1.0 - g_special1.x);
		float colorVal = 3.0 * sin(15.0*pos.y + 10.0*pos.x);
		//float colorVal = 3.0 * sin(15.0*cos(pos.y) + 30.0*sin(pos.x));
		colDiffuse = vec3(0.8, 0.5 * clamp(0.1 + colorVal, 0.0, 1.0), 0.4);
		
		//shininess = 2.0;
		//colSpecular *= 0.12;
	}
	// body 2
	else if ( abs(mat - MAT_BODY_2) < 0.1)
	{
		vec3 pos = p;
		pos.xz -= g_posVel2.xy;
		pos.y -= 0.8 * (1.0 - g_special2.x);
		
		float colorVal = 3.0 * sin(15.0*pos.y + 10.0*pos.x);
		//float colorVal = 3.0 * sin(15.0*cos(pos.y) + 30.0*sin(pos.x));
		colDiffuse = vec3(clamp(0.5 + colorVal, 0.0, 1.0), 0.5, 0.3);
		
		//shininess = 2.0;
		//colSpecular *= 0.12;
	}
	// eyes 1
	else if( abs(mat - MAT_EYES_1) < 0.1)
	{
		colDiffuse = vec3(1.0, 0.9, 0.8);
		rimStrength = 0.1;
	}
	// eyes 2
	else if( abs(mat - MAT_EYES_2) < 0.1)
	{
		colDiffuse = vec3(0.9, 1.0, 0.6);
		rimStrength = 0.1;
	}
	// eyes pupils
	else if( abs(mat - MAT_EYES_DOTS) < 0.1)
	{
		colDiffuse = vec3(0.0, 0.0, 0.0);
		rimStrength = 0.0;
	}
	// eyes sockets 1
	else if ( abs(mat - MAT_EYES_SOCKETS_1) < 0.1)
	{
		colAmbient = vec3(0.0, 0.0, 0.0);
		colDiffuse = vec3(0.0, 0.0, 0.0);
		colSpecular = vec3(0.0, 0.0, 0.0);
		
		rimColor = 0.7 * vec3(0.9, 0.1, 0.5);
		rimWidth = 0.7;
		rimStrength = 1.4;
	}
	// eyes sockets 2
	else if ( abs(mat - MAT_EYES_SOCKETS_2) < 0.1)
	{
		colAmbient = vec3(0.0, 0.0, 0.0);
		colDiffuse = vec3(0.0, 0.0, 0.0);
		colSpecular = vec3(0.0, 0.0, 0.0);
		
		rimColor = 0.7 * vec3(0.1, 0.7, 0.4);
		rimWidth = 0.7;
		rimStrength = 0.8;
	}
	
	// lighting
	col = phongIllumination(normal, colAmbient, colDiffuse, colSpecular, shininess, p, ro);
	
	// rim light
#if USE_RIM_LIGHT
	vec3 viewDir = normalize( ro - p);
	float vDotN = dot(normal, viewDir);
	float rim = smoothstep(1.0 - rimWidth, 1.0, 1.0 - vDotN);
	col += 0.6 * rim * rimStrength * rimColor;
#endif
    
    // fog
    col = mix(col, fogColor, 1.0 - exp2(-0.0001 * dist * dist * dist));

	// debug - materials
    //col = 0.1 * vec3(mat);
        
    // debug - rim
    //col = vec3(rim);
        
    // debug - normals
    //col = normal;
    
    return col;
    
}

// Function 792
vec3 IDT_Sony_SLog2_SGamut_Daylight_10( vec3 In)
{
mat3 SGAMUT_DAYLIGHT_TO_ACES_MTX = mat3( vec3( 0.8764457030, 0.0774075345, 0.0573564351), vec3( 0.0145411681, 0.9529571767, -0.1151066335), vec3( 0.1090131290, -0.0303647111, 1.0577501984) );

float B = 64.0;
float AB = 90.0;
float W = 940.0;

vec3 SLog;
SLog.x = In.x * 1023.0;
SLog.y = In.y * 1023.0;
SLog.z = In.z * 1023.0;

vec3 lin;
lin.x = SLog2_to_lin( SLog.x, B, AB, W);
lin.y = SLog2_to_lin( SLog.y, B, AB, W);
lin.z = SLog2_to_lin( SLog.z, B, AB, W);

vec3 aces = SGAMUT_DAYLIGHT_TO_ACES_MTX * lin;

return aces;
}

// Function 793
Ray computeLightRay(HitRecord hit)
{
    Ray r;
    r.origin = hit.P;
    
    vec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;
        
    r.direction = normalize(distToLight);
    r.mint = 0.0;
    r.maxt = length(distToLight);
    return r;
}

// Function 794
float getAO(vec3 hitp, vec3 normal, float dist) {
    vec3 spos = hitp + normal * dist;
    float sdist = map(spos).dist;
    return clamp(sdist / dist, .0, 1.0);
}

// Function 795
float seaOctave( in vec2 uv, const in float choppy) {
    uv += noise(uv);        
    vec2 wv = 1.0-abs(sin(uv));
    vec2 swv = abs(cos(uv));    
    wv = mix(wv,swv,wv);
    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);
}

// Function 796
float calcShadow( vec3 ro, vec3 rd, float mint, float maxt )
{
    float t = mint;
    float res = 1.0;
    for ( int i = 0; i < 20; i++ )
    {
        float h = map( ro + rd * t ).x;
        res = min( res, 22.0 * h / t );
        t += h;
        if ( ( h < 0.001 ) || ( t > maxt ) )
        {
            break;
        }
    }
    return clamp( res + 0.7, 0.0, 1.0 );
}

// Function 797
vec3 sample_light(vec3 x, vec3 n, vec3 rd)
{
    vec3 Lo = vec3(0.);
    
    for(int i = 0; i < LIGHT_SAMPLES; ++i)
    {
        vec3 Li, wi;
        light_pick(n, Li, wi);
        
        float cos_theta = max(0., dot(n, wi));
        
        if(cos_theta > 0.00001)
        {
        	float sha = shadow(x, wi);
        	Lo += Li * brdf(wi, -rd, n, x) * cos_theta * sha;
        }
    }
    
    Lo /= float(LIGHT_SAMPLES);
    
    return Lo;
}

// Function 798
float deLight(vec3 pos){
    return length(pos-LightPos)-LightRadius;
}

// Function 799
float shadow( in vec3 ro, in vec3 rd )
{
	float res = 1.0;
	for( int i=0; i<NUMSPHEREES; i++ )
        res = min( res, 8.0*sphSoftShadow(ro,rd,sphere[i]) );
    return res;					  
}

// Function 800
float GrndSShadow (vec3 ro, vec3 rd)
{
  float sh = 1.;
  float d = 0.01;
  float eps = 0.001;
  for (int i = 0; i < 80; i++) {
    vec3 p = ro + rd * d;
    float h = p.y - GrndHt (p.xz, 0);
    sh = min (sh, 20. * h / d);
    d += 0.5;
    if (h < eps*(1.0+d)) break;
    eps *= 1.02;
  }
  return clamp (sh, 0., 1.);
}

// Function 801
bool traceShadow( vec3 roo, vec3 rd, float maxdist ) { 	

	float u, d = MAXDISTANCE;
	vec3 ro = roo - roomoffset;
	vec2 e, s;
	
	for( int i=0; i<4; i++ ) {
			float angle = float(i)*PI*0.5+pillarAngle;
			s = vec2( cos( angle ), sin( angle ) ) + pillarPosition; 
			e = vec2( cos( angle+PI*0.5 ), sin( angle+PI*0.5 ) ) + pillarPosition;
				
			intersectSegment( ro, rd, s, e, d, u );
			if( d < maxdist ) return true;
		}
	return false;
}

// Function 802
vec3 Light(vec3 position, float depth)
{   
    vec3 colours[4];
    colours[0] = vec3( 1.0, 1.0, 1.0 );
    colours[1] = vec3( 0.839, 0.450, 0.337 );
    colours[2] = vec3( 0.631, 0.839, 0.427 );
    colours[3] = vec3( 0.294, 0.403, 0.839 );
    
    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);
    vec3 offset = position + ((floor(sin(Rand(id.xz) * (iTime * 0.2)) * 80.0) - (40.0)) * REPEAT_DIST);
    offset.y = position.y;
    
    vec3 diffuse = colours[layerID];
    vec3 colour = (diffuse * position.y) * 0.5;
    float glow = Glow(offset.xyx, 50.0, 0.2);

    return colour + (diffuse * glow);
}

// Function 803
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    lowp float t;
	
	t = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }

    return false; // optimisation: planes don't cast shadows in this scene
}

// Function 804
vec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)
{
	// lighting
	const vec3 L = vec3(0, 1, 0);
	vec3 V = normalize(ro - pos);
	vec3 H = normalize(V + L);

	vec3 N = -furNormal(pos, density);
	//float diff = max(0.0, dot(N, L));
	float diff = max(0.0, dot(N, L)*0.5+0.5);
	float spec = pow(max(0.0, dot(N, H)), shininess);
	
	// base color
	vec3 color = textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;

	// darken with depth
	float r = length(pos);
	float t = (r - (1.0 - furDepth)) / furDepth;
	t = clamp(t, 0.0, 1.0);
	float i = t*0.5+0.5;
		
	return color*diff*i + vec3(spec*i);
}

// Function 805
float directLighting( in vec3 pos, in vec3 nor )
{

    vec3 ww = lig;
    vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)) );
    vec3 vv =          ( cross(uu,ww) );


    float shadowIntensity = softshadow( pos+0.001*nor, lig, 10.0 );

    vec3 toLight = rlight - pos;
    float att = smoothstep( 0.985, 0.997, dot(normalize(toLight),lig) );

    vec3 pp = pos - ww*dot(pos,ww);
    vec2 uv = vec2( dot(pp,uu), dot(pp,vv) );
    float pat = smoothstep( -0.5, 0.5, sin(10.0*uv.y) );

    return pat * att * shadowIntensity;
}

// Function 806
float calcAO(float t,in vec3 pos, in vec3 nor,vec4 m,mat4 B) {
    float hr=.01, ao=.0, sca=1.;
    for(int aoi=0; aoi<5; aoi++) {
        ao += -(map(nor*hr+pos).x-hr)*sca;
        sca *= .7;
        hr += .05;
    }
    return clamp(1.-4.*ao, 0., 1.);
}

// Function 807
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = scene( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 808
float calcAO(vec3 p,vec3 n)
{
	float dlt=0.5;
	float oc=0.0, d=1.0;
	for(float i=0.0; i<6.; i++) {
		oc+=(i*dlt-map(p+n*i*dlt))/d;
		d*=2.0;
	}
	
	return 1.0-oc;
}

// Function 809
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float tmin = 0.001;
    float tmax = 8.0;

    float res = 1.0;
    
    // bounding sphere
    vec2 bs = iSphere(ro,rd,vec4(0.0,0.0,0.0,sqrt(3.0)+kRoundness+0.2));
    if( bs.y>0.0 )
    {
        tmin = max(tmin,bs.x); // clip search space
        tmax = min(tmax,bs.y); // clip search space
        
        float t = tmin;
        for( int i=0; i<64; i++ )
        {
            float h = map( ro + rd*t ).x;
            float s = clamp(8.0*h/t,0.0,1.0);
            res = min( res, s*s*(3.0-2.0*s) );
            t += clamp( h, 0.02, 0.5 );
            if( res<0.005 || t>tmax ) break;
        }
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 810
define PRIM_RM_AO(map,nits)    { float occ=0.0,sca=1.0;for(int i=0;i<nits;i++){float hr = 0.01 + AO_STEP*float(i);vec3 aopos =  N * hr + P;float dd = map( aopos );occ += -(dd-hr)*sca;sca *= 0.95;} AO= clamp( 1.0 - 3.0*occ, 0.0, 1.0 );  }

// Function 811
vec3 ambientLight(vec3 pos){
    vec3 oldPos = pos;
    vec3 n, ambientColor = vec3(0.0), gi = vec3(0.0);
    for(int i = 0; i < AoSteps; i++){
        n = normalEstimation(pos);
        pos += distanceEstimation(pos) * n;
        ambientColor += background(n);
        if(i != 0 && mod(float(i), float(GiSkipSteps)) == 0.0) gi += directLight(pos, n);
    }
    ambientColor /= float(AoSteps);
    gi /= ceil(float(AoSteps)/float(GiSkipSteps) - 1.0);
    float expectedDist = distanceEstimation(oldPos) * pow(2.0, float(AoSteps));
    float ao = pow(length(pos-oldPos)/expectedDist, AoStrength);
    return max(ao * ambientColor, vec3(0.0)) + GiStrength * gi;
}

// Function 812
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int iter = 24; 
    
    ro += n*.0015;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<iter; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .25); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 813
vec3 oceanLighting(vec3 V, vec3 rd, vec3 L, vec3 N, vec3 tx, vec3 ty, float ox, float oy)
{
    vec3 H = normalize(V+L);
    vec2 ChiH = -vec2(dot(H, tx), dot(H, ty))/dot(H, N);
    float VoN = dot(rd, N);
    float LoN = dot(L, N);
    float tetaV = atan(dot(V, ty), dot(V, tx));
    float tetaL = atan(dot(L, ty), dot(L, tx));
    float cosTetaV = cos(tetaV);
    float sinTetaV = sin(tetaV);
    float mu_v = pow(ox*ox*cosTetaV*cosTetaV+oy*oy*sinTetaV*sinTetaV,0.5);
    
    float F = Fresnel_Schlick(1.033, 1., cosTetaV);
    //float R = (1.033-1.)/(1.044+1.); R = R*R;
    //float FtetaV = R+(1.-R)*pow((1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV)*(1.-cosTetaV), -2.69*oy)/(1.+22.7*pow(mu_v, 1.5));
    
    vec3 u0 = procU(vec2(0., 0.), -V, tx, ty, N);
    float e = 0.001;
    vec3 dUx = 2.*ox*(procU(vec2(e, 0.), -V, tx, ty, N)-u0)/e;
    vec3 dUy = 2.*oy*(procU(vec2(0., e), -V, tx, ty, N)-u0)/e;
   
    float qvn = max(0., dot(rd, L))/(cosTetaV*(1.+max(0., mu_v)));
    
    vec3 IrradianceSun = vec3(max(0., (qvn*F)/(4.*pow(dot(H,N), 4.))));
    
    return IrradianceSun;
}

// Function 814
float getAO(vec3 ro, vec3 N){
    float ao=1.0;
    float k=1.3;
    float delta=0.135;
    for (float j=1.; j<=6.; j++){
        float diff=max(j*delta-df(ro+N*(j*delta)), 0.);
        ao-=k*diff;
        k=k*0.7;
    }
    return ao;
}

// Function 815
float calcFakeAOAndShadow( in vec3 pos ) { 
    float r = (1.-abs(pos.x)/30.5);
    
    r *= max( min( .35-pos.z / 40., 1.), 0.65);
    r *= .5+.5*smoothstep( -66., -.65, pos.z);
    
    if( pos.y < 25. ) r *= 1.-smoothstep( 18., 25., .5*pos.y+abs(pos.x) ) * (.6+pos.y/25.);
    r *= 1.-smoothstep(5., 8., abs(pos.x) ) * .75 * (smoothstep( 60.,63.,abs(pos.z)));
    
    return clamp(r, 0., 1.);
}

// Function 816
float scene_raycast_object_shadows( Ray ray )
{
    float result = 1.;
    float t = SCN_ZFAR;
    vec3 albedo, N;
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );
        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_PRIMITIVE:
        result *= scene_obj_primitive( obj, localray, t, albedo, N );
        break;
        }
    }
    return max( 0., result );
}

// Function 817
void light_pick(vec3 n, out vec3 Li, out vec3 wi)
{
    if(rnd() > 0.3)
    {
        Li = sun_col;
        wi = sun_dir;
    }
    else
    {
        Li = sky_col;
        
        float Xi1 = rnd();
        float Xi2 = rnd();

        wi = sample_hemisphere_cos_weighted(n, Xi1, Xi2);
    }
}

// Function 818
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<30; i++ )
    {
		if( t<maxt )
		{
        float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += 0.02;
		}
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 819
float godLight(vec3 p, vec3 lightPos) {
    vec3 lightDir = normalize(lightPos - p);
    vec3 sp = p + lightDir * -p.y;

    float f = 1.0 - clamp(sdSurface(sp.xz) * 10.0, 0.0, 1.0);
    f *= 1.0 - length(lightDir.xz);
    return smoothstep(0.2, 1.0, f * 0.7);
}

// Function 820
vec3 sampleLightSource( 	in vec3 x,
                          	in vec2 xi,
                          	out LightSamplingRecord sampleRec ) {
    float sph_r2 = objects[0].params_[1];
    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );
    
    vec3 w = sph_p - x;			//direction to light center
	float dc_2 = dot(w, w);		//squared distance to light center
    float dc = sqrt(dc_2);		//distance to light center
    
    
    float sin_theta_max_2 = sph_r2 / dc_2;
	float cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );
    float cos_theta = mix( cos_theta_max, 1.0, xi.x );
    float sin_theta_2 = 1.0 - cos_theta*cos_theta;
    float sin_theta = sqrt(sin_theta_2);
    sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*xi.y, sin_theta, cos_theta );
    sampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );
        
    //Calculate intersection distance
	//http://ompf2.com/viewtopic.php?f=3&t=1914
    sampleRec.d = dc*cos_theta - sqrt(sph_r2 - dc_2*sin_theta_2);
    
    return lights[0].color_*lights[0].intensity_;
}

// Function 821
vec3 lighting(in Hit h) {
  if (h.ray.len > MAX_TRACE_DIST) return textureLod(iChannel0, -h.ray.dir, 0.).rgb;
  vec4 fgi = gi(h.pos, h.nml);    // Fake Global Illumination
  vec4 fcs = cs(h.pos, dif.dir);  // Fake Caustic Shadow
  //   lin = ([Ambient]        + [Diffuse]        * [SS]  + [CAUSTICS])  * [AO]  + [GI]
  vec3 lin = (_lit(h.nml, amb) + _lit(h.nml, dif) * fcs.w + fcs.rgb) * fgi.w + fgi.rgb;
  return  h.srf.kd * lin;
}

// Function 822
vec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )
{
	vec3 norm = OceanNormal(pos);
	float ndotr = dot(ray,norm);

	float fresnel = pow(1.0-abs(ndotr),5.0);
	
	vec3 reflectedRay = ray-2.0*norm*ndotr;
	vec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;	
	refractedRay = normalize(refractedRay);

	const float crackFudge = .0;
	
	// reflection
	vec3 reflection = Sky(reflectedRay);
	float t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );
	
	if ( t > 0.0 )
	{
		reflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );
	}

	
	// refraction
	t=TraceBoat( pos-crackFudge*refractedRay, refractedRay );
	
	vec3 col = vec3(0,.04,.04); // under-sea colour
	if ( t > 0.0 )
	{
		col = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );
	}
	
	col = mix( col, reflection, fresnel );
	col = mix( col, texture(iChannel1, reflectedRay).xyz, fresnel );
    
	// foam
	col = mix( col, vec3(1), WaveCrests(pos,fragCoord) );
	
	return col;
}

// Function 823
float volumetric_player_shadow(vec3 p, vec3 rel_cam_pos)
{
#if VOLUMETRIC_PLAYER_SHADOW
    vec3 occluder_p0 = rel_cam_pos;
    vec3 occluder_p1 = occluder_p0 - vec3(0, 0, 48);
#if VOLUMETRIC_PLAYER_SHADOW >= 2
    occluder_p0.z -= 20.;
#endif // VOLUMETRIC_PLAYER_SHADOW >= 2

    float window_dist = p.x * (1. / VOL_SUN_DIR.x);
    float occluder_dist = occluder_p0.x * (1. / VOL_SUN_DIR.x);
    p -= VOL_SUN_DIR * max(0., window_dist - occluder_dist);
    vec3 occluder_point = closest_point_on_segment(p, occluder_p0, occluder_p1);
    float vis = linear_step(sqr(16.), sqr(24.), length_squared(p - occluder_point));

#if VOLUMETRIC_PLAYER_SHADOW >= 2
    vis = min(vis, linear_step(sqr(8.), sqr(12.), length_squared(p - rel_cam_pos)));
#endif // VOLUMETRIC_PLAYER_SHADOW >= 2

    return vis;
#else
    return 1.;
#endif // VOLUMETRIC_PLAYER_SHADOW
}

// Function 824
float test_shadow(vec2 xy, float height)
{
    vec3 r0 = vec3(xy, height);
    vec3 rd = normalize( light - r0 );
    
    float hit = 1.0;
    float t   = 0.001;
	
    for (int j=1; j<25; j++)
    {
        vec3 p = r0 + t*rd;
        float h = height_map( p.xy );
        float height_diff = p.z - h;
		
        if (height_diff<0.0)
        {
            return 0.0;
        }
		
        t += 0.01+height_diff*.02;
        hit = min(hit, 2.*height_diff/t); // soft shaddow   
    }
	
    return hit;
}

// Function 825
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .1 );
}

// Function 826
bool isLightVisible( Ray shadowRay ) {
    float distToHit;
    SurfaceHitInfo tmpHit;
    
    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );
    
    return ( tmpHit.mtl_id_ >= LIGHT_ID_BASE );
}

// Function 827
vec3 light(vec3 p, vec3 l_pos, vec3 color, bool nrf) {
    vec3 ptol = l_pos - p;
    vec3 ptol_n = normalize(ptol);
    float d = length(ptol);
    float difuse = max(dot(ptol_n, normal), 0.1);
    vec3 difuse_col = pow(difuse/(d*d) , .5) * color;
    float shadow = shadow(p, ptol_n, l_pos);
    vec3 col = difuse_col  ;
    if (nrf) col *= shadow;


    return   col;



}

// Function 828
vec3 ShadeSteps(int n)
{
    const vec3 a = vec3(97, 130, 234) / vec3(255.0);
    const vec3 b = vec3(220, 94, 75) / vec3(255.0);
    const vec3 c = vec3(221, 220, 219) / vec3(255.0);
    float t = float(n) / float(StepsMax);   
    if (t < 0.5)
        return mix(a, c, 2.0 * t);
    else
        return mix(c, b, 2.0 * t - 1.0);
}

// Function 829
vec4 vertexShader(in vec3 vertex, in mat4 transform) {
    // converts position into NDC
    return transform * vec4(vertex, 1.);
}

// Function 830
float shadowPCF(vec3 px)
{
    // texture delta
    vec2 delta = 1./iChannelResolution[0].xy;
    
    float factor = 0.;
    // filter size
    const int r = 3;
    for(int y = -r; y <= r; y++)
    {
     	for(int x = -r; x <= r; x++)
        {
         	vec2 offset = delta * vec2(x,y);
            // count the number of shadow hits
			factor += float(texture(iChannel0,px.xy + offset).x > px.z - 0.002);
            
        }
    }
    int size = 2*r +1;
    
    int elements = size*size;
    
    // average of shadow hits
    return factor/float(elements);
}

// Function 831
void CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, 
                    out vec3 ro, out vec3 rd, out mat3 t) 
{
    float a = 1.0/max(iResolution.x, iResolution.y);
    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));
 
    ro = vec3(0.0, 0.0, -d);
    
    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));
    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * TAU);
    m.y = -m.y;
    
    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));
    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));
    
    t = rotY * rotX;
    
    ro = t * ro;
    ro = c + ro;

    rd = t * rd;
    
    rd = normalize(rd);
}

// Function 832
vec3 Sample_SphLight_MIS(vec2 s0, vec2 s1, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    float ct; vec3 Lc, L0; float sang;
    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);
    float pdf00 = 1.0/sang;

    vec3 L1; vec3 f1; float pdf11;
    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);

    bool couldL1HitLight = dot(L1, Lc) > ct;
    
    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);
         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);

    float pdf01 = couldL1HitLight ? pdf00 : 0.0;
    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);

    float w0, w1;
    #if 1
    w0 = (pdf00) / (Pow2(pdf00) + Pow2(pdf10));
    w1 = (pdf11) / (Pow2(pdf11) + Pow2(pdf01));        
    #else
    w0 = 1.0 / (pdf00 + pdf23);
    w1 = 1.0 / (pdf11 + pdf32);
    #endif

    float t2; vec3 n2; vec3 a2; bool isLight2 = true;
    bool hit2 = Intersect_Scene(p, L0, false, /*out*/ t2, n2, a2, isLight2);

    float t3; vec3 n3; vec3 a3; bool isLight3 = true;
    bool hit3 = Intersect_Scene(p, L1, false, /*out*/ t3, n3, a3, isLight3);

    if((isLight2 == false && t2 < dot(LightPos-p, Lc)) || dot(N, L0) <= 0.0) f0 = vec3(0.0);
    if(couldL1HitLight == false || isLight3 == false) f1 = vec3(0.0);

    vec3 res  = pdf00 == 0.0 ? vec3(0.0) : f0 * w0;
         res += pdf11 == 0.0 ? vec3(0.0) : f1 * w1;

    return res * Radiance;       
}

// Function 833
vec3 shade( vec3 pos, vec3 nrm, vec4 light )
{
	vec3 toLight = light.xyz - pos;
	
	float toLightLen = length( toLight );
	toLight = normalize( toLight );
	
	float comb = 0.1;
	//float vis = shadow( pos, toLight, 0.01, toLightLen );
	float vis = shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );
	
	if ( vis > 0.0 )
	{
		float diff = 2.0 * max( 0.0, dot( nrm, toLight ) );
		float attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );
		comb += diff * attn * vis;
	}
	
	return vec3( comb, comb, comb );
}

// Function 834
vec3 worldPointToLightPoint(vec3 worldPoint, out float lightDist)
{
    vec3 lightDir = lightDirection();
    vec3 lightPos = lightPosition();
    
    // Plane SDF allows easy distance calculation to ortographic plane.
    // -lightPos = lightDir * length(lightPos)
    lightDist = planeSDF(worldPoint, -lightPos);

    mat4 worldToLight = inverse(lightToWorldMatrix());
    
    // Quick maths
    vec3 lightPoint = worldPoint + lightDist * lightDir;
	lightPoint = (worldToLight * vec4(lightPoint, 0.0)).xyz;
    lightPoint = (lightPoint + LIGHT_CAMERA_SIZE) / (2.0 * LIGHT_CAMERA_SIZE);
    
    return lightPoint;
}

// Function 835
float calcSoftShadow( vec3 ro, vec3 rd, float mint, float tmax, int samples ) {
	float res=1.0, t=mint, stepDist=(tmax - mint)/float(samples);
    for(int i = 0; i < 64; i++) {
		float h = map(ro + rd*t);
        res = min(res, 8.0*h / t);
        t += clamp(h, stepDist, 1e10);
        if(h < 0.001 || t > tmax) break;
    }
    return clamp(res, 0., 1.);
}

// Function 836
mat4 GetDirectionalLightMatrixInverse ()
{
	mat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, directionalLightRotationAxisAngle.w );
	mat4 tra = translate( directionalLightSourcePosition.x, directionalLightSourcePosition.y, directionalLightSourcePosition.z );
	return tra * rot; 
}

// Function 837
vec3 lightmap(vec2 light) {
    light = 15. - light;
    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   
}

// Function 838
float ao(vec3 p, vec3 n) {
    float o = 0.0, s = 0.005, w = 1.0;
    for(int i = 0; i < 15; i++) {
        float d = de(p + n*s).x;
        o += (s - d)*w;
        w *= 0.98;
        s += s/float(i + 1);
    }
    return 1.0 - sat(o);
}

// Function 839
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).dist;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 840
Light getLight(int i){
    
  float a = iTime /2.;
    if(i == 0)
        return Light(
      		vec3(5.0*cos(a),5.0,5.0*sin(a)),
      		vec3(1.),
      		vec3(.5,1.,1.),
      		1.0);
    a += PI;
    if(i == 1)
        return Light(
      		vec3(5.0*cos(a),5.0,5.0*sin(a)),
      		vec3(1.),
      		vec3(.5,1.,1.),
      		1.0);
}

// Function 841
vec3 ShadeFoliage( ShadeData s )
{
	vec3 albedo = mix( vec3(.05,.02,.01), vec3(.1,.5,.0), Noise(s.pos*20.0).x*.3+.7 );
	
	return albedo*DiffuseLight(s);
}

// Function 842
vec3 intersection_shade( intersection_t hit )
{
	vec3 endCol = vec3(0);

    // Ambient
    endCol += hit.mat.ka * ambLight;
    
    for( int i = 0; i < NUM_LIGHTS; i++ )
    {
        // Diffuse
        vec3 l = normalize( lights[ i ].pos - hit.hitpt );
        vec3 n = hit.normal;
    	endCol += hit.mat.kd * max( dot( n, l ), 0.0 ) * lights[ i ].col;
        
        // Specular
        vec3 r = reflect( -l, n);
    	vec3 v = -hit.iray;
    	float s =  pow( max( dot( r, v ), 0.0) , hit.mat.ns );
    	endCol += hit.mat.ks * s * lights[ i ].col;
    }
    
    return endCol;
}

// Function 843
float lighting(in vec3 p,in vec3 n){
    vec3 l = vec3(3,4,-5);
    vec3 ld = l - p;
    vec3 ldn = normalize(ld);
    
    //Shadows
    
    if(march(p + n * 0.02, ldn).w < length(ld))
        return 0.1;
    
    float d = max(dot(n, ldn),0.0);
    return d;
}

// Function 844
float ObjSShadow (vec3 ro, vec3 rd)
{
  float d, h, sh;
  sh = 1.;
  d = 0.02;
  for (int i = 0; i < 40; i++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, 20. * h / d);
    d += 0.02;
    if (h < 0.001) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 845
float shadowMarch( vec3 ro, vec3 rd ) {
	float dO = 0.01;
    float res = 1.0;
    
    for (int i = 0; i < 64; i++) {
		float h = getDist( ro + rd * dO );

        res = min( res, 10.0 * h / dO );  
        dO += h;
        
        if( res < 0.0001 || dO > RAYMARCH_MAX_DIST ) break;
    }
    
    return res;//clamp( res, 0.0, 1.0 );
}

// Function 846
vec4 shadeSphere(Ray ray, RaycastHit hit) {
    
    float diffuse = lighting(hit);
    float specular = pow(max(dot(normalize(sun), hit.normal), 0.), 45.);
    
    return (vec4(1., 0., 0., 1.) * diffuse) + specular;
    
}

// Function 847
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    

    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
        
    vec3 vSpotPos, vSpotTarget, vSpotCol, vSpotCaseCol;

    for ( int lightIndex=0; lightIndex< iLampCount; lightIndex++ )
    {
		GetLampInfo( lightIndex, vSpotPos, vSpotTarget, vSpotCol, vSpotCaseCol );
        
        vec3 vSpotDir = normalize( vSpotTarget - vSpotPos );    

        Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos + vSpotDir * 0.15, vSpotDir, radians(10.0), radians(20.0), vSpotCol );
        Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vSpotPos + vSpotDir * 0.24, vSpotCol * 0.05);
    }    
    
    #if OUTDOOR_LIGHTS
    // Sun & sky
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor * g_fOutdoorLightScale );    
    surfaceLighting.vDiffuse += fAO  * g_vAmbientColor * g_fOutdoorLightScale;
    #endif 
    
    surfaceLighting.vDiffuse += fAO * fAmbient;
    
    return surfaceLighting;
}

// Function 848
Light getLight(int i) {
    return light;
}

// Function 849
vec3 LightBoxShadow (in vec3 position) {
    
    float shade = 1.0;

    // calculate whether or not the position is inside of the light box
    vec2 uv;
	vec3 localPos;    
    if (GetMode() >= 1.0)
    {
        // get position in light space and get uv
        localPos = WorldSpaceToDirectionalLightSpace(position);
    	uv = localPos.xz;
        uv.x *= -1.0;
        
        // apply scaling of uv over distance to fake projection
        uv /= (1.0 + localPos.y * directionalLightUVDistanceScale);
        
        // set shade to 1 if it's inside, 0 if it's outside        
    	shade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);
        
        // if it is behind the light source, don't light it!
        shade *= step(0.0, localPos.y);
        
        // apply distance attenuation
        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);        
    }
    
    // soften shadows over a distance
	if (GetMode() >= 2.0)
    {
        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.01, 0.99);
    	float softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));
    	float softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));
    	shade = shade * softenX * softenY;
    }
    
    // apply texture to light if we should!
    if (GetMode() >= 3.0)
    {
        uv = uv*0.5+0.5;
        return clamp((texture(iChannel0, uv).rgb * directionalLightTextureMADD.x + directionalLightTextureMADD.y) * shade, 0.0, 1.0);
    }
    
    return vec3(shade);
}

// Function 850
vec3 directLight(vec3 pos, vec3 normal){
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos, iTime);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 851
bool matIsLight( const in float mat ) {
    return mat < 0.5;
}

// Function 852
vec3 LightSample(vec3 p,float x1,float x2,out vec3 wo,out float dist,out float pdf){
	vec3 v0v1 = quads[0].v1 - quads[0].v0;
    vec3 v0v3 = quads[0].v3 - quads[0].v0;
    float width  = length(v0v1);
    float height = length(v0v3);
    vec3 O = quads[0].v0 + v0v1*x1 + v0v3*x2;
    wo = O - p;
    dist = length(wo);
    wo = normalize(wo);
    float costhe = dot(-wo,quads[0].normal);
    pdf = PDF_Area2Angle(1./(width*height),dist,clamp(costhe,0.0001,1.));
    return costhe>0. ? GetLightIntensity(): vec3(0.);
}

// Function 853
void MarchLight(float sscoc,inout Ray r, float startTime, float maxDist//relkativistic raymarcher
){float totalDist = 0.0
 ;vec3 origin = r.b
 ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++
 ){r.time = startTime
  ;SetTime(r.time)
  ;r.dist = map(r.b,-1)
  ;totalDist += r.dist*getReLipschitzToFps(sscoc)
  ;r.b+=r.dir*(r.dist)
  ;if(abs(r.dist)<getEpsToFps(sscoc)||totalDist>maxDist)break;}}

// Function 854
void Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)
{
    vec3 vToLight = vLightPos - vRayOrigin;
    float fPointDot = dot(vToLight, vRayDir);
    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);

    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;
    float fDist = length(vClosestPoint - vLightPos);
	vEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));
}

// Function 855
float shadow(vec3 rayPos, vec3 rayDir)
{	
	float s = 1.0;
	
	// Intersect sand
	//vec4 resSand = intersectSand(rayPos, rayDir);
	//if (resSand.w > 0.0) return 0.0;
	
	// Intersect trunk
	s = min(s, trunkShadow(rayPos, rayDir));
	if (s < 0.0001) return 0.0;
	
	// Intersect leaves
	vec4 resLeaves = leaves(rayPos, rayDir);
	if (resLeaves.w > 0.0 && resLeaves.w < 1e7) return 0.0;
	
	return s;
}

// Function 856
float shadow( vec3 ro, vec3 rd, float mint, float tmax )
{
	float res = 1.0;
    float t = mint;
    
    for( int i=0; i<64; i++ )
    {
		float h = worldSafe( ro + rd*t );
		res = min( res, 80.0*h/t );
        t += h;
        
        if( res<0.0001 || t>tmax ) break;
        
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 857
float sphLight( vec3 P, vec3 N, vec4 L) {
  vec3 oc = L.xyz  - P;
  float dst = sqrt( dot( oc, oc ));
  vec3 dir = oc / dst;
  
  float c = dot( N, dir );
  float s = L.w  / dst;
    
  return max(0., c * s);
}

// Function 858
bool TraceShadow(vec3 ro, vec3 rd)
{
	bool hit;
	vec3 pos;
	vec3 hitNormal;
	int mat;
	float dist2 = VoxelTrace(ro+rd*0.6, rd, hit, hitNormal, pos, mat);
	return hit;
}

// Function 859
float SoftShadowMissile( in vec3 origin, in vec3 direction, Missile missile )
{
  float res = 2.0, t = 0.02, h;
  for ( int i=0; i<8; i++ )
  {
    h = MapMissile(origin+direction*t, missile);
    res = min( res, 7.5*h/t );
    t += clamp( h, 0.05, 0.2 );
    if ( h<0.001 || t>2.5 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 860
float softShadow(vec3 dir, vec3 origin, float min_t, float k) {
    float res = 1.0;
    float t = min_t;
    for(int i = 0; i < RAY_STEPS; ++i) {
        vec3 obj = origin + t * dir;
        float m = sceneMap3D(obj);
        if(dot(obj - lightPos, origin - lightPos) < 0.) 
            return res;
        if(m < 0.0001) {
            return 0.0;
        }
        res = min(res, k * m / t);
        t += m;
    }
    return res;
}

// Function 861
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5 );
}

// Function 862
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
    traceFlame = false;
    float res = 1.0;
    float t = mint;
    for(int i=0; i<14; i++)
    {
    	float h = map(ro + rd*t, false).x;
        res = min(res, 7.0*h/t + 0.01*float(i));
        t += 0.3*clamp(h, 0.01, 0.25);
        if( h<0.001 || t>tmax ) break;
    }
    traceFlame = true;
    return clamp( res, 0.0, 1.0 );
}

// Function 863
vec3 shadeSurface(vec3 pos, Ray ray) {

    if (ray.len > MAX_TRACE_DISTANCE) {
        return background;
    }

    vec3 normal = calcNormal(pos);

    vec3 color = doLighting(
        pos,
        normal,
        ray.direction
    );

    applyFog(color, pos);
    
    return color;
}

// Function 864
float intersect_shadow(vec3 p)
{   
    vec3 qq = p;
    qq.xz = mod(qq.xz, 5.0) - 2.5;
    qq.y -= 2.0;
    
    const int mi = 3;
    float sf = 3.0;
    float dcc = 0.0;
    float db = sdf_sbox(qq, vec3(0.5));
    vec3 pp = qq;
    for (int i = 0; i < mi; ++i)
    {
        pp.xy = pp.xy * mat2(0.5, -0.866, 0.866, 0.5);
        vec3 ppm = pp;
       	ppm = mod(ppm, 0.2) - 0.1;
        dcc = sdf_cbox(ppm * sf, 0.1) / sf;
        db = max(db, -dcc);
        sf *= 1.5;      
    }
    
    float d2 = max(db, length(qq) - 0.5);
    return d2;
}

// Function 865
vec3 shade(vec3 p) {
    vec3 lightColor = vec3(0.9, 0.99, 0.99);

    vec3 lightDir = normalize(vec3(sin(iTime/1.0), 0.6, -0.3));

    
    vec3 normal = getNormal(p);
    vec3 light = lightColor * dot(normal, lightDir);
   
    return light* shadow(Ray(p, normalize(lightDir)));
}

// Function 866
vec3 lighting(vec3 p, vec3 lp, vec3 rd) {
    vec3 l = lp - p;
    float dist = max(length(l), 0.01);
    float atten = min(1./(1. + dist*0.5), 0.2);
    l /= dist;
    
    vec3 n = normal(p);
   	vec3 r = reflect(-l, n);
    
    float dif = clamp(dot(l, n), 0.0, 1.0);
    float spe = pow(clamp(dot(r, -rd), 0.0, 1.0), 8.0);
    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);
    float dom = smoothstep(-1.0, 1.0, r.y);
    
    vec3 lin = vec3(0.2);
    lin += 1.0*dif*vec3(1, .97, .85);
    lin += 2.5*spe*vec3(1, .97, .85)*dif;
    lin += 2.5*fre*vec3(1);
    lin += 0.5*dom*vec3(1);
    
    return lin*atten*ao(p, n);
}

// Function 867
void moveLights( void )
{

    for( int i=0; i<7; i++ )
	{
		vec3 pos;
	    pos.x = 3.2*cos(0.0+0.08*iTime*2.0 + 17.0*float(i) );
	    pos.z = 3.2*cos(1.65+0.07*iTime*2.0 + 13.0*float(i) );
	    pos.y = terrain( pos.xz ) + 0.4;
		
		// make the lights avoid the trees
	    vec2 chos = 2.5 + 5.0*floor( pos.xz/5.0);
	    float r = length( pos.xz - chos);
	    pos.xz = chos + max( r, 1.5 )*normalize(pos.xz-chos);
		
		lpos[i].xyz = pos;
		lpos[i].w = smoothstep(5.0,10.0,iTime)*(0.85 + 0.15*sin(25.0*iTime+ 23.1*float(i)));
	}
}

// Function 868
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    lowp float t;
	
	t = iSphere( ro, rd, vec4( 1.5,0.5 + bounce, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,0.5 + bounce2, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }

    return false; // optimisation: planes don't cast shadows in this scene
}

// Function 869
vec3 shadeSphere( vec3 normal, vec3 vertPos, vec3 v, float time )
{		
	vec3 reflColor;
	vec3 newNormal = normal;
	vec3 dir = normalize(reflect(v, newNormal));
	vec3 pos = vertPos;
	int sphere = 0;
    
	for( int i = 0; i < REFLECTIONS; ++i )
	{
		if( pos.x < CAST_DISTANCE )
		{
			pos = castScene(pos, dir, newNormal, time);
			dir = normalize(reflect(dir, newNormal));
            sphere = 1;
		}
		else
		{
			break;
		}
	}
	
    // color
	vec3 col = sampleCube(dir);
    
    if(sphere == 1)
    {
        col = ApplyMaterial(col, dir, newNormal);
    }
    
    return col;
}

// Function 870
vec3 IDT_Sony_SLog2_SGamut_Daylight_12( vec3 In)
{
mat3 SGAMUT_DAYLIGHT_TO_ACES_MTX = mat3(vec3(0.8764457030, 0.0774075345, 0.0573564351), vec3(0.0145411681, 0.9529571767, -0.1151066335), vec3(0.1090131290, -0.0303647111, 1.0577501984));

float B = 256.0;
float AB = 360.0;
float W = 3760.0;

vec3 SLog;
SLog.x = In.x * 4095.0;
SLog.y = In.y * 4095.0;
SLog.z = In.z * 4095.0;

vec3 lin;
lin.x = SLog2_to_lin( SLog.x, B, AB, W);
lin.y = SLog2_to_lin( SLog.y, B, AB, W);
lin.z = SLog2_to_lin( SLog.z, B, AB, W);

vec3 aces = SGAMUT_DAYLIGHT_TO_ACES_MTX * lin;

return aces;
}

// Function 871
vec3 sampleLightSource(		in vec3 x,
                          	float Xi1, float Xi2,
                       out LightSamplingRecord sampleRec) {
    float min_x = objects[0].params_[0];			//min x
    float min_y = objects[0].params_[1];			//min y
    float max_x = objects[0].params_[2];			//max x
    float max_y = objects[0].params_[3];			//max y
    float dim_x = max_x - min_x;
    float dim_y = max_y - min_y;
    vec3 p_local = vec3(min_x + dim_x*Xi1, min_y + dim_y*Xi2, 0.0);
    vec3 n_local = vec3(0.0, 0.0, 1.0);
    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );
    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );
    
    float pdfA = 1.0 / (dim_x*dim_y);
    sampleRec.w = p_global - x;
    sampleRec.d = length(sampleRec.w);
    sampleRec.w = normalize(sampleRec.w);
    float cosAtLight = dot(n_global, -sampleRec.w);
    vec3 L = cosAtLight>0.0?getRadiance(vec2(Xi1,Xi2)):vec3(0.0);
    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);
    
	return L;
}

// Function 872
mat4 GetDirectionalLightMatrix ()
{
	mat4 rot = rotationAxisAngle(directionalLightRotationAxisAngle.xyz, -directionalLightRotationAxisAngle.w );
	mat4 tra = translate( -directionalLightSourcePosition.x, -directionalLightSourcePosition.y, -directionalLightSourcePosition.z );
	return rot * tra;     
}

// Function 873
vec3 WorldSpaceToDirectionalLightSpace (vec3 worldPosition)
{
	vec3 localPosition = (GetDirectionalLightMatrix() * vec4(worldPosition, 1.0)).xyz; 
    localPosition.xz /= directionalLightExtents;
    return localPosition;
}

// Function 874
vec3 directLight(vec3 pos,vec3 normal
){//return vec3(0.)
 ;float dotLight=-dot(normal,LightDir)
 ;if(dotLight<0.0)return vec3(0)
 ;vec3 pos0=pos
 ;float minAngle=LightRadius
 ;for(int i=0;i < MaxShadowSteps;i++
 ){float dist=sdf(pos)
  ;if(dist>MaxDist)break
  ;if(dist<MinDist)return vec3(0)
  ;pos-=LightDir*dist*2.5//goes 2.5 times faster since we don't need details
  ;minAngle=min(asin(dist/length(pos-pos0)),minAngle);}
 ;return LightColor*dotLight*sat(minAngle/LightRadius);}

// Function 875
float softshadow(const in vec3 ro, const in vec3 rd) {
  float t = 0.02;
  float tmax = 2.5;
  float precis = 0.001;
  float res = 1.0;
  for(int i = 0; i < 16; i++) {
    float h = mapDistance(ro + rd * t);
    res = min(res, 20.0 * h / t);
    t += clamp( h, 0.02, 0.10 );
    if(h < 0.001 || t > tmax) break;
  }
  return clamp(res, 0.0, 1.0);
}

// Function 876
float softshadow(in vec3 ro, in vec3 rd){
    float res = 1.0, t = 0.15; // t=0.15 -> no banding on my stock x.org drivers
    for(int s = 0; s < 16; ++s){
        float h = scene(ro + rd*t);
        if(h < 0.01) return 0.0;
        res = min( res, 2.0*h/t );
        t += h*0.9;
    }
    return res;
}

// Function 877
float seaOctave(vec2 uv, float choppy) 
{	
    #if WATER_TYPE == WAVES_WATER 
    uv += noise(uv);
    vec2 wv = 1.0 - abs(sin(uv));   
    wv = mix(wv, abs(cos(uv)), wv);
    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
    #elif WATER_TYPE == CALM_WATER
    //Author: Angelo Logahd 
    //2019-06-29
    float noise = noise(uv);
    float x = cos(noise);
    float y = sin(noise);
    return pow(pow(abs(x * y), 0.65), choppy);
    #endif
}

// Function 878
void lightsCameraAction(vec2 point, out Line viewLine, out vec3 light, float time)
{
    vec3 viewPoint, viewDirection;
    float angle;
    vec3 axis;
    // rotate 1/8th turn around the x-axis and 1/8th turn around the y-axis
    angle = 1.09606;
    axis = vec3(0.678598, 0.678598, -0.281086);
    viewPoint = vec3(point, -100.0);
    viewPoint = rotationRodrigues(viewPoint, axis, angle);
    viewDirection = vec3(0.5, -0.707108, 0.499998);
    light = vec3(-0.406773, 0.814675, 0.41333);
    // animate rotation
    angle = time;
    axis = vec3(0.57735, 0.57735, 0.57735);
    viewPoint = rotationRodrigues(viewPoint, axis, angle);
    viewDirection = rotationRodrigues(viewDirection, axis, angle);
    light = rotationRodrigues(light, axis, angle);
    // construct view line
    viewLine.point = viewPoint;
    viewLine.direction = viewDirection;
}

// Function 879
bool isShadowed(vec3 ro, vec3 rd, vec3 point) {
	vec3 pos;
	vec3 nor;
	float m;

	if (!intersect(ro, rd, pos, nor, m)) {
		return false;
	}
	return distanceSqr(point, ro) > distanceSqr(pos, ro);
}

// Function 880
float lighting(vec3 pos){
    vec3 light=vec3(2.1*sin(iTime)+0.5,2.1*cos(iTime)+0.5,1.75);
    float diffuse=clamp(dot(normalize(light-pos),texNormal(pos.xy)),0.,1.);
    vec3 lightdir=normalize(pos-light);
    vec3 start=light-(light.z/lightdir.z)*lightdir;
    vec3 steps=(pos-start)/float(iteration);
    for(int i=0;i<iteration;i++){
        vec3 current=steps*float(i)+start;
        if(current.z+texDepth(current.xy)<0.){
        	return diffuse*.25+.5;
        }
    }
	return diffuse*.5+.5;
}

// Function 881
float shadow2 (in vec3 ro, in vec3 rd)
{
    float result = 1.;
    float t = .1;
    for (int i = 0; i < MAX_ITER; i++) {
        float h = scene (ro + t * rd).d;
        if (h < 0.00001) return .0;
        result = min (result, 8. * h/t);
        t += h;
    }

    return result;
}

// Function 882
vec3 shadeSphere1(vec3 rayPos, vec3 normal)
{
    return vec3(1.0, 0.0, 0.0);
}

// Function 883
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<50; i++)
    {
    	float h = map(ro + rd*t);
        res = min(res, 10.0*h/t + 0.02*float(i));
        t += 0.8*clamp(h, 0.01, 0.35);
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 884
float LightGlow(vec3 light, vec3 ray, float t)
{
	float ret = 0.0;
	if (length(light) < t)
	{
		light = normalize(light);
		ret = pow(max(dot(light, ray), 0.0), 3000.0)*1.5;
	}
		
	return ret;
}

// Function 885
void createLight(vec3 color, float intensity, out Light light) {
    light.color_ = color;
    light.intensity_ = intensity;
}

// Function 886
vec3 treesShade( in vec3 pos, in vec3 tnor, in vec3 enor, in float hei, in float mid, in float dis, in float rt, in vec3 rd, float terrainShadow )
{
    vec3 nor = normalize( tnor + 2.5*enor );

    // --- lighting ---
    float sha = terrainShadow;
    vec3  ref = reflect(rd,nor);
    float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*dis,3.0);
    float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); 
    if( dif>0.0001 && terrainShadow>0.001 )
    {
        //sha *= clamp( 10.0*dot(tnor,kSunDir), 0.0, 1.0 ) * pow(clamp(1.0-13.0*dis,0.0,1.0),4.0);//treesShadow( pos+nor*0.1, kSunDir ); // only cast in non-terrain-occluded areas
        sha *= treesShadow( pos+nor*0.1, kSunDir ); // only cast in non-terrain-occluded areas
    }
    float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );
    float fre = clamp(1.0+dot(nor,rd),0.0,1.0);
    float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*sha*(0.2+0.8*pow(fre,5.0))*occ;

    // --- lights ---
    vec3 lin  = 1.0*0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);
		 #ifdef SOFTTREES
         lin += 1.0*15.0*vec3(1.0,0.9,0.8)*dif*occ*sha;
		 #else
         lin += 1.0*10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;
		 #endif
         lin += 1.0*0.5*vec3(0.9,1.0,0.8)*pow(fre,3.0)*occ;
         lin += 1.0*0.05*vec3(0.15,0.4,0.1)*occ;
   
    // --- material ---
    float brownAreas = fbm_4( pos.zx*0.03 );
    vec3 col = vec3(0.08,0.09,0.02);
    	 col = mix( col, vec3(0.09,0.07,0.02), smoothstep(0.2,1.0,mid) );
         col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,enor.y) );
         col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,enor.y) );
         col *= 1.6;

    // --- brdf * material ---
    col *= lin;
    col += spe*1.2*vec3(1.0,1.1,2.5);

    // --- fog ---
    col = fog( col, rt );

    return col;
}

// Function 887
float moonShadow(vec3 pos, vec4 moon, vec3 dir) {
    vec3 p = pos - moon.xyz;
	float m = dot(p, dir);
    float n = dot(p, p);
    return step(step(m, 0.0) * moon.w * moon.w, n - m * m);
}

// Function 888
vec3 ComputeDirectionalLight(vec3 p, vec3 n, vec3 r, DirectionalLight light, inout vec3 specular) {

    float s = Shadow(p, n, light.direction, light.shadow_dist);

    vec3 c = light.color*s;

    specular += Specular(light.direction, n, -r, 100.0) * c;
    
    return c*max(dot(n , light.direction), 0.0);
}

// Function 889
vec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)
{
    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)
    {
        return clamp(dot(n, l.d), 0., 1.) * l.c;
    }
    return vec3(0.);
}

// Function 890
float softshadow(in vec3 ro, in vec3 rd, in float k)
{
    float res = 1.0;
    float t = 0.0;
    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)
    {
		vec3 pos = ro + rd * t;
        float h = map(pos).y;
        res = min(res, k * h / t);
        if(res < 0.0001)
		{
	    	break;
    	}
        t += clamp(h, 0.0, 0.2);
    }
    return saturate(res);
}

// Function 891
vec3 lighting(vec3 p, vec3 n, vec3 c){
 
  vec3 color = vec3(0.0);
    
  for(int i = 0;i < LIGTHS;i++)
  	color += applyLight(p,n,c,getLight(i));
    
  return color;
}

// Function 892
float shadow(in vec3 rp)
{
	float d = 0.05;
	AA aa;
    float h = map(rp + normalize(vec3(0.0, .0, 1.0)) * d, aa, false);
    return clamp(h / d, 0.0, 1.0);
}

// Function 893
float calcAO( in vec3 pos, in vec3 nor, in int sampleID )
{
	float ao = 0.0;

	vec3 v = normalize(vec3(0.7,0.5,0.2));
	for( int i=ZERO; i<12; i++ )
	{
		float h = abs(sin(float(i+12*sampleID)));
		
		vec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));
		ao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );
        
		v = v.yzx; if( (i&2)==2) v.yz *= -1.0;
	}
	ao /= 12.0;
	ao = ao + 2.0*ao*ao;
	return clamp( ao*5.0, 0.0, 1.0 );
}

// Function 894
float sample_lighting(vec3 camera_pos, vec3 dir, Options options, Intersection result)
{
#if !BAKE_LIGHTMAP
    return 1.;
#endif

    Transitions transitions;
    LOAD(transitions);
    
    float lightmap = sample_lightmap(camera_pos, dir, options, result);
    
    float dynamic_lighting = 0.;
    vec3 surface_point = camera_pos + dir * result.t;
    surface_point = simulate_lightmap_distortion(surface_point);
    
    vec3 fireball_offset = get_fireball_offset(g_animTime);
    vec4 fireball_light = vec4(fireball_offset + FIREBALL_ORIGIN, 150);
    if (fireball_offset.z > 8.)
    	dynamic_lighting += compute_dynamic_light_atten(fireball_light, surface_point);
    if (transitions.attack > .875)
        dynamic_lighting += compute_dynamic_light_atten(vec4(camera_pos, 200), surface_point);
    
#ifdef QUANTIZE_DYNAMIC_LIGHTS
    const float LEVELS = float(QUANTIZE_DYNAMIC_LIGHTS);
    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))
    	dynamic_lighting = floor(dynamic_lighting * LEVELS + .5) * (1./LEVELS);
#endif
    
    return lightmap + dynamic_lighting;
}

// Function 895
float getShadowCoeff(in vec3 p, in vec3 nv) {
    float tHit = 0.0;
    vec3 curPos = p;
    float shadowCoeff = 0.0;

    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {
        float sdStep;
        sdGeometry(curPos, sdStep);

        float curLightPercent = abs(sdStep)/(0.1*tHit);
        shadowCoeff = max(shadowCoeff, 1.0-curLightPercent);

        if (abs(sdStep) < MIN_DIST) {
            shadowCoeff = 1.0;
            break;
        }

        curPos += sdStep * nv;
        tHit += sdStep;
        if (tHit > MAX_DIST) {
            break;
        }
    }

    return clamp(shadowCoeff, 0.0, 1.0);
}

// Function 896
vec3 scene_object_lighting( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,
                            vec3 skyZ, vec3 skyL, vec3 skyR, vec3 ground )
{
    float mu_0 = mu_stretch( dot( N, L ), .01 );
    float mu = mu_stretch( dot( N, V ), .01 );
    float cosi = dot( N, Z );
    float cosp = dot( L, V );
    float cost = dot( normalize( reject( N, Z ) ), normalize( reject( L, Z ) ) );
    vec3 kd = lunar_lambert( albedo, mu, mu_0 );
    float kl = phase_curve( cosp );
    vec3 E = F * mu_0;
    //*
    vec3 sky = mix( mix( skyR, skyL, .5 + .5 * cost ), skyZ, cosi * .3333 + .6667 );
    return E * kd * kl + albedo * mix( ground, sky, cosi * .5 + .5 );
    /*/
    float cosi2 = cosi * cosi;
    vec3 skyH = ( skyL + skyR ) / 2.;
    vec3 skyJ = ( skyL - skyR ) / 2.;
    vec3 sky = skyZ / 8. * ( 2.6667 + cosi * ( 3.5 + cosi2 * ( -0.3333 + cosi2 * ( -0.5 + cosi2 ) ) ) ) +
               skyH / 8. * ( 1.3333 + cosi * ( 0.5 + cosi2 * ( +0.3333 + cosi2 * ( +0.5 + cosi2 ) ) ) ) +
               skyJ * cost / ( 105. * PI ) * ( 30. - cosi2 * ( 6. + cosi2 * ( 8. + cosi2 * 16. ) ) );
    return E * kd * kl + albedo * ( sky + ground * ( 1. - cosi ) / 2. );
    //*/
}

// Function 897
vec3 shade(in vec3 pos, in vec3 obs)
{
    // normal
    vec2 eps = vec2(0.001, 0.0);
    vec3 n = normalize(vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,
                            map(pos + eps.yxy).x - map(pos - eps.yxy).x,
                            map(pos + eps.yyx).x - map(pos - eps.yyx).x));
 
    // material color
    vec3 col = vec3(1.0, 1.0, 1.0);
    
    // ambient light using the computed SH coefficients
    vec3 lightColor = vec3(0.0);
    
    // calc amount of light coming from the normal direction
    #if PERFORMANCE==1
    
    lightColor += SHCoefs[0] * y00 (n.xzy);
    lightColor += SHCoefs[1] * y11_(n.xzy);
    lightColor += SHCoefs[2] * y10 (n.xzy);
    lightColor += SHCoefs[3] * y11 (n.xzy);
    lightColor += SHCoefs[4] * y22_(n.xzy);
    lightColor += SHCoefs[5] * y21_(n.xzy);
    lightColor += SHCoefs[6] * y20 (n.xzy);
    lightColor += SHCoefs[7] * y21 (n.xzy);
    lightColor += SHCoefs[8] * y22 (n.xzy);
    
    #else
    
    for (int l = 0; l < 3; ++l) {
        for (int m = -l; m <= l; ++m) {
            int index = l*(l+1)+m;
            lightColor += SHCoefs[index] * SH(n.xzy, l, m);
        }
    }
    
    #endif
    
    return col * lightColor;
}

// Function 898
float calcAO( in vec3 pos, in vec3 nor ) {
	float occ = 0.0, sca = 1.0;
    for(int i = 0; i < 4; i++) {
        float hr = 0.01 + 0.03*float(i);
        vec3 aopos = nor*hr + pos;
        float dd = map(aopos);
        occ += -(dd - hr)*sca;
        sca *= 0.97;
    }
    return clamp(1. - 3.*occ, 0., 1.);    
}

// Function 899
float Shadow( in vec3 ro, in vec3 rd, float dist)
{
	float res = 1.0;
    float t = 0.01;
	float h = 0.0;
    
	for (int i = 0; i < 12; i++)
	{
		if(t < dist)
		{
			h = de(ro + rd * t);
			res = min(4.0*h / t, res);
			t += h + 0.002;
		}
	}
	
    return clamp(res, 0.0, 1.0);
}

// Function 900
float ShadowFactor(in vec3 ro, in vec3 rd) {
	vec3 p0 = vec3(0.0);
    vec3 p1 = vec3(0.0);
    
    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);
    p0 = ro + rd*0.02;
    
    vec2 dir = normalize(rd.xz);
    float sf = rd.y / length(rd.xz);

    float m = -1e5;
    
    const int max_steps = 32;
    for (int i = max_steps; i > 0; --i) {
        if (p0.y < m) break;
        
        if (dot((p1 - p0), rd) < 0.0) return 1.0;
  
        vec4 v = map(p0.xz, dir);
        
        m = v.w;
        if (p0.y < m) return 0.0;
        
        p0 += rd*(length(vec2(v.x, v.x*sf)) + 0.02);
    }
    
    p0 += rd * (m - p0.y)/rd.y;
    if (dot((p1 - p0), rd) < 0.0) return 1.0;   
    
    return 0.0;
}

// Function 901
float ShadowFactor(in vec3 sd, in vec3 ld, in vec3 c, in float r, in float br) {
    float w = noise(sd);
    vec3 ro = c + (normalize(sd) * (w+r));
    
    vec3 bp0 = vec3(0.0);
    vec3 bp1 = vec3(0.0);
    bool bres = RaySphereIntersection(ro, -ld, c, br, bp0, bp1);
    
    vec3 p0 = vec3(0.0);
    vec3 p1 = vec3(0.0);
    bool res = RaySphereIntersection(ro, -ld, c, r, p0, p1);
    
    float dist = min(length(ro - bp0)+ float(!bres) * 10000.0, 
                     length(ro - p0) + float(!res) * 10000.0);
    
    const float sc = 128.0;
    const float invsc = 1.0 / sc;
    float s = dist * invsc;
    
    float dmin = 1.0;
    
    for (float d = 0.0; d < sc; ++d) {
    	vec3 pn = (ro + d*s*-ld) - c;
		
        sd = normalize(pn) * r;
        float h = length(pn) - r + s;
        
        float h0 = noise(sd);
        if (h0 > h) {
            dmin = 0.0;
            break;
        }
        
        dmin = min(dmin, 4.0*(h-h0)/(d*s));
    }
    
    return clamp(dmin, 0.0, 1.0);
    
}

// Function 902
vec3 tower_lightpos(vec2 cell_coords, vec3 tower_color)
{
    // no movement in center column
    float mask = step(REALLY_SMALL_NUMBER, abs(dot(cell_coords, vec2(1.))));
    vec3 light_color = mask * tower_color;
    return vec3(0., mod(5. * g_time + 200. * tower_color.r, 110.) - 100., 0.);

    // return vec3(0., mod(5. * g_time + 10. * (cell_coords.x + 4. * cell_coords.y), 110.) - 100., 0.);
    // return vec3(0., mod(10. * g_time + 2. * cell_coords.x, 200.) - 100., 0.);
}

// Function 903
vec3 getLightPos()
{
    float r = 5.0;
    float t = iTime / 3.0;
    float x = width/2.0 + 1.5*r*cos(t) / 2.0;
    float y = height/2.0 + r*sin(t)/2.0;
    float z = -r;
    return vec3(x, y, z);
}

// Function 904
float ao(Hit hit){
	float sum = 0.0;
	for(float i=1.0; i<=ao_samples; i++){
		float d = i*ao_spacing;
		sum += (d - dist(hit.p + hit.n*d))/pow(2.0, i);
	}
	
	return 1.0 - ao_strength*sum;
}

// Function 905
bool shadow_hit(const in ray r, const in float t_min, const in float t_max) {
    hit_record rec;
    rec.t = t_max;
   
    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);  
    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec)) 
        return true;
    
	r_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);  
    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec)) 
        return true;
  
    return false;
}

// Function 906
float shade1(float d)
{
	float v = 1.0 - smoothstep(0.0, mix(0.012, 0.2, 0.0), d);
	float g = exp(d * -20.0);
	return v + g * 0.5;
}

// Function 907
vec3 light_dir(vec3 at, vec3 normal, vec3 l_eye, material_t m, vec3 l_color, vec3 l_dir) {
	vec3 color = m.diffuse * l_color * max(0.,dot(normal,l_dir));
	
	if (m.specular_power > 0.) {
		vec3 h = normalize(l_dir + l_eye);
		color += l_color * m.specular * pow(max(0.,dot(normal,h)), m.specular_power) * (m.specular_power + 8.) / 25.;
	}
	return color;
}

// Function 908
vec3 directLight(vec3 pos, vec3 normal){
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 909
C_PointLight GetPointLight()
{
    C_PointLight result;

    result.vPos = vec3(0.5, 1.0, -2.0);
    result.cColour = vec3(32.0, 6.0, 1.0) * 10.0;

    return result;
}

// Function 910
float getLightIntensity( const vec3 pos, const vec3 normal, const vec3 light, const float intensity) {
    vec3 rd = pos - light;
    float i = max(0., dot(normal, -normalize(rd)) / dot(rd,rd));
    i = i > 0.0001 ? i * intensity * shadowhit(light, normalize(rd), length(rd)) : 0.;
    return max(0., i-0.0001);              
}

// Function 911
float AO(vec3 p, vec3 n) 
{
    float ra = 0., w = 1., d = 0.;
    for (int i=ZERO; i<5; i++){
        d = float(i) / 5.;
        ra += w * (d - map(p + n*d).x);
        if (ra>1.) break;
        w *= .5;
    }
    return 1. - clamp(ra,0.,1.);
}

// Function 912
vec3 getLightPos(float t)
{
	return vec3(-2.0*sin(t), 0.3+sin(t*4.0)*0.2, 5.0 + 2.0 * cos(t));
}

// Function 913
float sampleLightSourcePdf( in vec3 x,
                            in vec3 wi,
                           	in float d,
                            in float cosAtLight ) {
    float sph_r2 = objects[0].params_[1];
    vec3 sph_p = toVec3( objects[0].transform_*vec4(vec3(0.0,0.0,0.0), 1.0) );
    float solidangle;
    vec3 w = sph_p - x;			//direction to light center
	float dc_2 = dot(w, w);		//squared distance to light center
    float dc = sqrt(dc_2);		//distance to light center
    
    if( dc_2 > sph_r2 ) {
    	float sin_theta_max_2 = clamp( sph_r2 / dc_2, 0.0, 1.0);
		float cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );
    	solidangle = TWO_PI * (1.0 - cos_theta_max);
    } else { 
    	solidangle = FOUR_PI;
    }
    
    return 1.0/solidangle;
}

// Function 914
void ProcessLightValue(v0 t
){oliPos[0]=v2(6.,1.,sin(t))
 ;oliCol[0]=3.*v3(0.2,1.,.2,1)
 ;oliPos[1]=v2(-3,-2.2,sin(t*.3)*8.)
 ;oliCol[1]=2.*v3(1,1,0.5,1)
 ;oliPos[2]=v2(9.5,1.8,9.5)
 ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*v3(1,.2,1,1);}

// Function 915
vec3 doLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir)
{
	float h = dot(sunLight,normal);
	mat = mat * sunColour*(max(h, 0.0));
    mat += vec3(.05, .07,.07) * max(normal.y*.5, 0.0);

    vec3 ref = reflect(eyeDir, normal);
    mat += specular * pow(max(dot(ref, sunLight),0.0), 10.0)*.7;
	return mat;
}

// Function 916
vec3 calcShadeParams(int swatch, float lightness, float seedChroma, float seedHue, float chromaFactor, float accent1Chroma) {
    float refChroma = accent1Chroma * SWATCH_CHROMA_SCALES[0];
    float targetChroma = accent1Chroma * SWATCH_CHROMA_SCALES[swatch];
    float scaleC = (refChroma == 0.0) ? 0.0 : (clamp(seedChroma, 0.0, refChroma) / refChroma);
    float chroma = targetChroma * scaleC * chromaFactor;
    float hue = (swatch == 2) ? seedHue + 60.0 : seedHue;

    return vec3(lightness, chroma, hue);
}

// Function 917
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
	float sca = 1.0;
	for( int i=0; i<5; i++ )
    
	{
		float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
	return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 918
vec3 sfShadeSkyDawn(Ray r)
{
	float t = 0.5 * (r.direction.y + 1.0);
	return (1.0 - t) * Orange + t * ArneSkyBlue;
}

// Function 919
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 24; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = 0.001*(t*.125 + 1.);  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

         
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        h = clamp(h, .1, .5); // max(h, .02);//
        dist += h;

        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (shade<0.001 || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 920
vec3 light( in vec3 lightdir, in vec3 lightcol, in vec3 tex, in vec3 norm, in vec3 camdir )
{    
    float cosa = pow(0.5 + 0.5*dot(norm, -lightdir),2.0);
    float cosr = max(dot(-camdir, reflect(lightdir, norm)), -0.0);
    
    float diffuse = cosa;
    float phong = pow(cosr, 8.0);
    
    return lightcol * (tex * diffuse + phong);
}

// Function 921
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.0001;                 // selfintersection avoidance distance
	float h = 1.0;
    for( int i=0; i<5; i++ )         // 40 is the max numnber of raymarching steps
    {
        h = doModel(ro + rd*t);
        res = min( res, 4.0*h/t );   // 64 is the hardness of the shadows
		t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances
    }
    return clamp(res,0.0,1.0);
}

// Function 922
vec3 shade(vec3 pos, bool isWater)
{
    vec3 normal = gradient(pos);
    vec3 lightDir = normalize(light - pos);
    vec3 ambient = vec3(.2, 0., 0.);
    
    float diffuse = max(0., dot(normal, lightDir));
    float len = length(pos);
    
    vec3 biomeWeights = mapBiome(pos * 1.);
    vec3 col = vec3(.8, .8, .1) * biomeWeights.x
        + vec3(0., 1., 0.) * biomeWeights.y
        + vec3(.2, .2, .2) * biomeWeights.z;
    
    if (biomeWeights.z > .75 && len > .8)
    {
        col = vec3(1., 1., 1.);
    }
    
    if (isWater)
    {
    	col = vec3(0., 0.62, 1.);
    }
    
    // start off just doing plain old blinn phong
	return diffuse * col + ambient;
}

// Function 923
float shadow(in vec3 eye, vec3 marchingDirection, vec3 normal, float end) {
    eye += normal * SHADOW_EPSILON * 2.0;
    float depth = 0.0;

    float shad = 1.0;
    float ph = 1e10;

    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {
        DistMat distMat = sceneSDF(eye + depth * marchingDirection);
        float dist = distMat.dist;

        if (dist < SHADOW_EPSILON) {
	        shad = 0.0;
	        break;
        }

        if (depth > end) {
            break;
        }

        float y = dist * dist / (2.0 * ph);
        float d = sqrt(dist * dist - y*y);
        shad = min(shad, 4.0 * d / max(0.0, depth - y));
        ph = dist;

        depth += dist;
    }

    return clamp(shad, 0.0, 1.0);
}

// Function 924
float light_ambient(vec2 uv, vec3 normal, vec3 sight_dir) {
    float ao_original = sample_noise(iChannel1, uv).x;
    float ao_decay = pow(get_occlusion_factor(normal, sight_dir), 2.0);
    return mix(1.0, ao_original, ao_decay);
}

// Function 925
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<24; i++ )
    {
        float h = mapWithElephants(ro + rd*t );
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.05, 0.5 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 926
vec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )
{
    // Get ambient occlusion and shadow values.
    float amb = occlusion(p,n);
    
    // Get light colors and irradiance for the sun light.
    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;
    // Shadow the sunlight.
    float sdw = shadow(p,SUN_DIR,MAX_DEPTH,PENUMBRA_FACTOR);
    
    
    // Do our distance based sky and secondary lighting.
    float skyd = sketchySkyEmitter(p);
    vec3 sky = clamp(1.0-skyd*.33,.0,1.0)*SKY_COLOR*.25;
    float secd = sketchySecEmitter(p);
    vec3 sec = clamp(1.0/secd,.0,1.0)*SUN_COLOR*.133;
    
    // We're not gonna use P anymore, so let's just reuse it.
    
    //-------------------------------------------------------
    // IT'S CANDLE TIME.
    //-------------------------------------------------------
    #ifdef TURN_THE_LIGHTS_ON_IN_HERE
        // First we make some animation constants.
        float t = iTime * 6.0;
        // Animate the position.
        vec3 pAnim = vec3(noise(p+t),noise(p+1.0-t),noise(p+1.5+t))*.01;
        // Animate the brightness based on time, as well as
        // the 15 unit section in which the candle resides.
        float bAnim = noise(vec3(t+floor((p-vec3(0,0,7.5))*.06667)));

        // Use the same modulo as the candles.
        vec3 q = p+vec3(2.4,-8.0,7.5);
        q.z = mod(q.z,15.0)-7.5;

        // Move it around like it's a candle flame.
        q += pAnim;

        // Get the direction to the *nearest* candle.
        vec3 cDir = -normalize(q); 

        // Do lighting on that point, and work in the
    	// brightness animation.
        vec3 can = orenNayar(n,-d,cDir)*vec3(.5,.45,.4)*bAnim;

        // Calc shadows from the cauldron.
        float cSdw = cShadow(p,cDir,length(q),PENUMBRA_FACTOR*.5)*.25;
    #else
        vec3 can = vec3(0);
        float cSdw = 0.0;
    #endif
    
    // Modulate all the lighting results by 
    sec *= amb;
    sky *= amb;
    sun *= sdw;
    can *= cSdw;
    
    // Return the sum.
    return sec+sky+sun+can;
}

// Function 927
vec3 satellite_light(vec3 ro, vec3 rd, float falloff, float volume)
{
    vec3 res = vec3(0);
    for(int obj = 0; obj < SATELLITES; obj++)
    {
        vec4 note = Notes[obj];
        vec3 color = CALC_COLOR;
        float light_distance = pow(abs(Positions[obj].x),1.5);
        float neon = falloff/pow(light_distance,.42);
        float trapez = 1.-trapezoid(note.x, TRAPEZOID);
        float turn_on = pow(trapez+0.01,0.5);
        neon =pow(neon*turn_on,5.4545)*(1.-note.x);
        res += neon*color;
    }
    return pow(res, vec3(0.64545));
}

// Function 928
float ExObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = 0; j < 30; j ++) {
    h = ExObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.01 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 929
vec3 SampleLights(const RayIntersection ri)
{ // WIP
    if (ri.shape.isEmissive) return ri.shape.color.rgb;
    
    float shadow = 0.1;
    vec4  c = ri.shape.color;
    c *= (ri.shape.ID==FLOOR) ? CheckersGradBox(ri.pos.xz) : 1.;

    // Main light bounce
    Ray ray;
    ray.o = ri.pos + ri.shape.normal.xyz * SHADOW_BIAS;
    // TODO: Real sampling
    ray.d = normalize(scene.objects[SURFACE_LIGHT].pos - ray.o);
    ray.n = 1.;
    
    float d2l = distance(scene.objects[SURFACE_LIGHT].pos, ray.o);
    RayIntersection lightRI = CastRay(ray, d2l);
    if (lightRI.shape.type != NO_SHAPE && lightRI.shape.isEmissive)
    {
        c *= lightRI.shape.color * ((7.5-lightRI.dist) / 7.5);
        //shadow = lightRI.shadow; // FIXME: Soft shadows
        shadow = 1.;
    }
    
    // TODO: More realistic AO
    c *= ComputeAO(ri.pos, ri.shape.normal.xyz) * shadow;

    // Specular highlight
    if (ri.shape.glossy > 0.)
    {
        float NoL 		= dot(ri.shape.normal.xyz, ray.d);
        vec3  H   		= normalize(ray.d - ri.ray.d);
        float specAngle = clamp(dot(ri.shape.normal.xyz, H), .0, 1.0);
        
        c += pow(specAngle, ri.shape.glossy*100.);
    }
    
    return c.rgb;
}

// Function 930
float calcAO(in vec3 p, in vec3 n){
    float sca = 2., occ = 0.;
    for( int i = 0; i<5; i++ ){
        float hr = float(i + 1)*.16/8.; 
        float d = map(p + n* hr).x;
        occ += (hr - d)*sca;
        sca *= .9;
        if(sca>1e5) break;
    }
    return clamp(1. - occ, 0., 1.);
}

// Function 931
float map_light(vec3 ro) {
    return distance(ro, light.xyz) - light.w;
}

// Function 932
float calcShadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;

    float t = 0.1;
    for( int i=0; i<32; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = DistanceField(pos, length(pos));
        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );
        t += clamp( h, 0.05, 10.0 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 933
float calculateAO( in vec3 p, in vec3 n )
{
	float ao = 0.0, l;
    const float maxDist = 4.;
	const float nbIte = 6.0;
	//const float falloff = 0.9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + hash(i))*.5/nbIte*maxDist;
        
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 934
float dirLightDiffuse(vec3 nor, vec3 lightDir){
    return clamp(dot(nor, lightDir), 0.2, 1.0);
}

// Function 935
float GetLightPar(vec3 p, vec3 plig) {
    vec3 lightPos = plig;
    //Determine movement of light ex. shadow and light direction and diffusion
    //lightPos.xz += vec2(1, 2);
    vec3 l = normalize(lightPos-p);
    vec3 n = GetNormal(p);
    
    float dif = clamp(dot(n, l), 0., 1.);
    float d = RayMarch(p+n*SURF_DIST*2., l );
    if(d<length(lightPos-p)) dif *= .1;
    
    return dif;
}

// Function 936
void shadeSurface(inout Hit hit){

    vec3 background = vec3(.95, .95, 1.);

    if (hit.isBackground) {
        hit.color = background;
        return;
    }

    float glow = 1. - dot(normalize(camPos), hit.normal);
    glow += .5 * (1. - dot(hit.normal, normalize(hit.pos)));
    glow *= .5;
    glow = gainStep(glow, 2.);
    
    float level = hit.model.level;
    vec3 diffuse = spectrum(level / MODEL_STEPS + .1 - 1./3.);
    diffuse = mix(diffuse * 1., diffuse * 1.5, glow);

    float fog = smoothstep(camDist *.1, camDist, length(camTar - hit.pos)) * .5;
    fog = mix(fog, 1., smoothstep(0., camDist * 2.5, length(camTar - hit.pos)));

    diffuse = mix(diffuse, background, fog);
    hit.color = diffuse;
}

// Function 937
void Initialize_Lights ( ) {
  float3 O; float3 P;
  float time = GTIME*2.5;
  O = float3(cos(time)*5.0, 2.0, sin(time)*5.0);
  P = normalize(float3(cos(time), 1.5+sin(time)*2.5,
                sin(time)+sin(time)*2.5));
  Construct_Light(0, O, P, float3(1.0), float2(0.5, 0.5));
  O.xz *= -1.0;
  // P.xz = P.zx;
  P.xz *= -1.0;
  P.x += cos(time)*0.2;
  P.y = sin(time)*0.2;
  float tint = 0.5 + sin(time*2.0)*0.5;
  Construct_Light(1, O, normalize(P),
                  tint*float3(10.0, 1.0, 10.0+sin(time*5.0)*5.0),
                  float2(0.5, 1.5));
}

// Function 938
float lighting(RaycastHit hit) {
 
    const float eps = .001;
    float sum = .2;
    
    // sun
    Ray shadowRay = Ray(hit.point + (sun * eps), sun);
    RaycastHit shadow = intersectScene(shadowRay);
    if(shadow.id == -1) sum += max(dot(normalize(sun), hit.normal), 0.);
    
    // po1
    vec3 l = hit.point - po1;
    shadowRay = Ray(hit.point + (l * eps), l);
    shadow = intersectScene(shadowRay);
    //if(shadow.id == -1) sum += dot(normalize(l), hit.normal);
    
    return sum;
    
}

// Function 939
float specularLight (vec3 p, vec3 n, vec3 r){
    vec3 nr = reflect(r, n);
    return pow(dot(nr, -r), 2.);
}

// Function 940
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{  
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<32; i++ )
    {
        float h = Scene(ro + rd*t ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.004, 0.1 );
		if( res<0.001 ) break;
    }
    return clamp(res*res,0.0,1.0);
}

// Function 941
vec3 lightSample( const in LightInfo light, const in SurfaceInteraction interaction, out vec3 wi, out float lightPdf, float seed ) {
    vec2 u = vec2(random(), random());
    
    vec3 tangent = vec3(0.), binormal = vec3(0.);
    vec3 lightDir = normalize(light.position - interaction.point);
    createBasis(lightDir, tangent, binormal);
    
    float sinThetaMax2 = light.radius * light.radius / distanceSq(light.position, interaction.point);
    float cosThetaMax = sqrt(max(EPSILON, 1. - sinThetaMax2));
    wi = uniformSampleCone(u, cosThetaMax, tangent, binormal, lightDir);
    
    if (dot(wi, interaction.normal) > 0.) {
        lightPdf = 1. / (TWO_PI * (1. - cosThetaMax));
    }
    
	return light.L;
}

// Function 942
float calculateAO(vec3 p, vec3 n)
{
   const float AO_SAMPLES = 5.0;
   float r = 1.0, w = 1.0;
   for (float i=1.0; i<=AO_SAMPLES; i++)
   {
      float d0 = i/AO_SAMPLES;
      r += w * (map(p + n * d0) - d0);
      w *= 0.5;
   }
   return clamp(r, 0.0, 1.0);
}

// Function 943
vec3 GetLightDirection()
{
    return normalize(vec3(-.1, 1.0, 1.0));
}

// Function 944
float getShadow(Ray ray) {
    
    return softshadow(ray.ori, ray.dir, 0., 128.);
    
}

// Function 945
LightmapSample empty_lightmap_sample()
{
    return LightmapSample(vec4(0), vec4(0));
}

// Function 946
vec3 shade(in vec3 ray_start, in vec3 ray_dir, vec4 norm_h, vec4 mc,
   vec2 shadow_ao, in vec3 light_dir, in vec3 fog_color, in vec4 hit)
{   
   vec3 norm = norm_h.xyz;
   float diffuse = pow(max(0.05, dot(norm, light_dir)*(1.-shadow_ao.x*.9)),.3);
   diffuse *= 1. - shadow_ao.y*.7*(1.-shadow_ao.x*.6);
   float spec = max(0.0,dot(reflect(light_dir,norm),normalize(ray_dir)));
   spec = pow(spec, 32.0)*.5*(1.-shadow_ao.x);

#if USE_COLORS == 0
   vec3 base_color = vec3(.6);
#else
  #if USE_COLORS == 3
   #if WAVING == 1
     float sh = sqrt(max(0.,norm_h.w))*.8+.2;
   #else
     float sh = norm_h.w*.8+.2;
   #endif
   vec3 base_color =
    vec3(exp(pow(sh-.75,2.)*-10.),
         exp(pow(sh-.50,2.)*-20.),
         exp(pow(sh-.25,2.)*-10.));
  #elif USE_COLORS == 1
   float sh = mc.z; // + mc.w*17.;
   sh = (abs(mod(sh+6.,12.)-6.)+2.5)*(1./9.);
   // Ken Silverman's EvalDraw colors ;)
   vec3 base_color =
    vec3(exp(pow(sh-.75,2.)*-10.),
         exp(pow(sh-.50,2.)*-20.),
         exp(pow(sh-.25,2.)*-10.));
  #else
   vec3 base_color = texture(iChannel1, mc.zw*.1, -100.).xyz;
  #endif
   vec3 an = abs(norm);
   base_color = mix(base_color, texture(iChannel1,
       ((an.y>an.x&&an.y>an.z)?hit.xz:(an.x>an.z)?hit.yz:hit.xy)*.25).xyz, .2);
#endif

   if (hit.w < max_dist-1.) {
      base_color *= 1.-dot(mc.xy-hit.xz,mc.xy-hit.xz)*.25;
   }
   vec3 color = mix(vec3(0.),vec3(1.),diffuse)*base_color +
      spec*vec3(1.,1.,.9);
  
   
   float fog_dist = max(0.,hit.w - fog_start);
   float fog = 1.0 - 1.0/exp(fog_dist*fog_density);
   color = mix(color, fog_color, fog);

   return color;
}

// Function 947
float dirLightSpec(vec3 nor, vec3 lightDir, vec3 rd, float shiny){
	return clamp(pow(clamp(dot(reflect(rd, nor), lightDir), 0.0, 1.0), shiny), 0.0, 1.0);    
}

// Function 948
vec3 LightPixelGlint (vec3 spec, vec3 rayDir, vec3 normal, float specPower)
{
    vec3 light0 = normalize(vec3(1.0,2.0,1.0));
    vec3 light1 = normalize(cross(light0, vec3(0.0, 1.0, 0.0)));
    vec3 light2 = normalize(cross(light0, light1));

    vec3 reflection = reflect(light0, normal);
    float dp = abs(dot(rayDir, reflection));
	vec3 pixelColor = pow(dp, specPower) * spec;
    
    reflection = reflect(light1, normal);
    dp = abs(dot(rayDir, reflection));
	pixelColor += pow(dp, specPower) * spec;    
    
    reflection = reflect(light2, normal);
    dp = abs(dot(rayDir, reflection));
	pixelColor += pow(dp, specPower) * spec;     
    
    return pixelColor;
}

// Function 949
vec4 getLighting(sampler2D heightTex, sampler2D specTex, vec2 coord)
{
	// Get the current light position.
	vec3 lightPos = genLightCoords();
	
	// Get the vector of incidence the light has with the curren texel.
	vec3 lightIncidence = getIncidence(lightPos, coord);
	
	// Also get the surface normal of the current texel.
	vec3 surfaceNormal = getSurfaceNormal(heightTex, coord);
	
	// Determine the cosine of the angle between the incident and normal vectors.
	float cosine = getAngle(lightIncidence, surfaceNormal);
	
	// Also get the distance from the light to the current texel, for
	// distance falloff.
	float dist = getDist(lightPos, coord);
	
	// Here's where a bit of wiki comes in. Now we create the three elements of the
	// Phong rendering equation: The ambient term, the diffuse term, and the 
	// specular term.
	
	// Create the base ambient light term.
	vec4 ambient = ambientColor;
	
	// Create a linear-falloff diffuse light term.
	vec4 diffuse = vec4(1.0);
	diffuse *= lightStrength;
	diffuse *=  (1.0-dist);
	diffuse *= cosine;
	diffuse *= lightColor;
	
	// Get the local specularity (shininess of the material.
	float spec = getSpecularity(specTex, coord);
	
	// Create a powered-falloff specular term.
	vec4 specular = vec4(1.0);
	specular *= lightStrength;
	specular *=  pow((1.0-dist), specularFactor);
	specular *= pow(cosine, specularFactor*specularRatio);
	specular *= lightColor;
	specular *= spec*specularMapRatio;
	
	return ambient+diffuse+specular;
}

// Function 950
vec3 lighting(vec3 pos, vec3 rayDir, float c, vec3 lightPos)
{
    vec3 n = calculateNormals(pos, lightPos);
    
    vec3 diffuseColor = mix(color1, color2, c);
    
    float atten = 1.0 - clamp(length(lightPos*lightAtten),0.0, 1.0);

	float diff = max(0.0, dot(normalize(lightPos), n))*atten;
	float fresnel = smoothstep(0.0, reflFresnel, 1.0 - dot(n, -rayDir));
	vec3 r = reflect(normalize(rayDir), n);
    float refl = calcReflexion(pos + n*0.15, r, 0.01, 20.0, lightPos);
    vec3 reflColor = mix(color1, color2, refl);
	float spec = pow(max (0.0, dot (r, normalize(lightPos))), specPow);

	vec3 res = diffuseColor*diffuseMul;
	res += diff*lightColor*lightMul*diffuseColor;
    res += spec*lightColor*diff*fresnel*specAmount;
    res	+= reflColor*fresnel*reflAmount;
    res += diffuseColor*selfIllum;
 
	return res;
}

// Function 951
float shadow (in Ray ray, in vec3 lPos)
{
    float distToLight = distance (lPos, ray.ro);
    float dist = .0;

    for (int i = 0; i < MAX_ITER; ++i) {
        float tmp = map (ray.ro + dist * ray.rd);
        if (tmp < EPSILON) {
            if (dist < distToLight)
                return .125;
            else
                return 1.;
        }
        dist += tmp * STEP_SIZE;
    }

    return 1.;
}

// Function 952
float calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){
	float ao = 0.0;
	const int nbIte = 6;
	for( int i=0; i<nbIte; i++ )
	{
		float l = hash(float(i))*maxDist;
		vec3 rd = n*l;
		ao += (l - map( p + rd )) / pow(1.+l, falloff);
	}
	return clamp( 1.-ao/float(nbIte), 0., 1.);
}

// Function 953
vec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {//PASSING IN THE NORMAL
	#ifdef ENABLE_HARD_SHADOWS
		float sh=shadow(p, lightdir);
	#else
		float sh=calcAO(p,-2.5*lightdir);//USING AO TO MAKE VERY SOFT SHADOWS
	#endif
	float ao=calcAO(p,n);
	float diff=max(0.,dot(lightdir,-n))*sh*.95;
	float y=3.16-p.y;
	vec3 amb=max(.6,dot(dir,-n))*.7*AMBIENT_COLOR;
	vec3 r = reflect(lightdir,n);
	float spec=pow(max(0.,dot(dir,-r))*sh,15.)*.5;
	vec3 col;
		col=texture(iChannel0,p.xz*7.).xyz; 
		if (abs(hid-1.)<.001) col=texture(iChannel0,p.xz).xyz;
	col=col*(amb*ao*.8+diff*.8*LIGHT_COLOR)+spec*.7*LIGHT_COLOR;	
	return col;
}

// Function 954
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp(occ*-2.+1., 0.0, 1.0 );    
}

// Function 955
vec3 doLighting(vec3 pos, vec3 nor, vec3 rd) {

    vec3 col;
    vec3 up = normalize(vec3(1));

    // lighitng        
    float occ = mix(calcAO( pos, nor ), 1., .8);
    vec3  lig = normalize(vec3(0,.2,1));
    float amb = clamp(dot(nor, up) * .5 + .5, 0., 1.);
    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );
    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
    vec3  hal = normalize( lig-rd );
    float spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);

    vec3 cA = vec3(.7,.3,.9);
    vec3 cB = vec3(.4,.9,.8);
    vec3 cC = vec3(.7,0,.7);

    col = mix(cA, cB, rangec(.0, 1., dot(-rd, nor))); // need better ramp
    col = mix(col, vec3(.8,.5,1), rangec(.5, 1., dif) * .5);
    col += cC * rangec(.5, 1., dif) * .1;

    dif *= softshadow( pos, lig, 0.02, 2.5 ) * .9;

    vec3 lin = vec3(0);
    lin += .5 * dif;
    lin += .1 * spe * dif;
    lin += .2 * fre * occ;
    lin += .5 * amb * occ;
    lin += .4 * occ;
    col = col*lin;

    return col;
}

// Function 956
float eliSoftShadow( in vec3 ro, in vec3 rd, in vec3 sphcen, in vec3 sphrad, in float k )
{
    vec3 oc = ro - sphcen;
    
    vec3 ocn = oc / sphrad;
    vec3 rdn = rd / sphrad;
    
    float a = dot( rdn, rdn );
	float b = dot( ocn, rdn );
	float c = dot( ocn, ocn );
	float h = b*b - a*(c-1.0);

    float t = (-b - sqrt( max(h,0.0) ))/a;

    return (h>0.0) ? step(t,0.0) : smoothstep(0.0, 1.0, -k*h/max(t,0.0) );
}

// Function 957
vec3 addLighting(vec3 view, vec3 normal, Light[lightCount] lights)
{
    vec3 color;
    float diffuse;
    float subSurface;
    // ambient light
    // no-see-um green
	// see: http://disneylandguru.tumblr.com/post/24656470253
	const vec3 green = vec3(139.0 / 255.0, 153.0 / 255.0, 153.0 / 255.0);
    color += 0.125 * green;
    // for each light
    for(int n = 0; n < lightCount; n++)
    {
        Light light = lights[n];
        // diffuse
        float on = orenNayar(normal, light, view);
        diffuse += on;
        // specular
        color += 1.5 * cookTorrance(view, normal, light);
        // subsurface scattering
        subSurface += sss(light, on);
    }
    // stylized diffuse shading
    color += 0.5 * cividisGooch(diffuse);
    // red ochre is one of the oldest used pigments in art
    // see: https://en.wikipedia.org/wiki/Ochre#Historical_use_in_art_and_culture
    // adapted from: https://www.pantone.com/color-finder/18-1442-TCX
    const vec3 redOchre = vec3(145.0 / 255.0, 56.0 / 255.0, 50.0 / 255.0);
    color += 0.125 * subSurface * redOchre;
        
    return color;
}

// Function 958
float shadow(vec2 p, vec2 pos, float radius)
{
	vec2 dir = normalize(pos - p);
	float dl = length(p - pos);
	
	// fraction of light visible, starts at one radius (second half added in the end);
	float lf = radius * dl;
	
	// distance traveled
	float dt = 0.01;

	for (int i = 0; i < 64; ++i)
	{				
		// distance to scene at current position
		float sd = sceneDist(p + dir * dt);

        // early out when this ray is guaranteed to be full shadow
        if (sd < -radius) 
            return 0.0;
        
		// width of cone-overlap at light
		// 0 in center, so 50% overlap: add one radius outside of loop to get total coverage
		// should be '(sd / dt) * dl', but '*dl' outside of loop
		lf = min(lf, sd / dt);
		
		// move ahead
		dt += max(1.0, abs(sd));
		if (dt > dl) break;
	}

	// multiply by dl to get the real projected overlap (moved out of loop)
	// add one radius, before between -radius and + radius
	// normalize to 1 ( / 2*radius)
	lf = clamp((lf*dl + radius) / (2.0 * radius), 0.0, 1.0);
	lf = smoothstep(0.0, 1.0, lf);
	return lf;
}

// Function 959
vec3 Trilight ( vec3 l, vec3 n, vec3 col0, vec3 col1, vec3 col2 )
{
    float ndotl = dot(n,l);
    if ( ndotl > 0.0 )
    {
        //return col0 * ndotl + col1 * (1.0-ndotl);
        vec3 col01 = col0 - col1;  // this could be precalculated
        return col1 + col01 * ndotl;
    }
    else
    {
        //return col1 * (1+ndotl) - col2 * ndotl;
        vec3 col12 = col1 - col2;  // this could be precalculated
        return col1 + col12 * ndotl;
    }
}

// Function 960
float shadow(vec3 rayOrigin, vec3 rayDirection) {
    int stepCount = 64;
    float t = 0.03;
    float maximumDistance = 20.0;
    for (int i = 0; i < stepCount; i++) {
        if (t > maximumDistance) {
            break;
        }
        vec3 currentPosition = rayOrigin + rayDirection * t;
        float d = sdf(currentPosition).x;
        if (d < 0.001) {
            return 0.0;
        }
        t += d;
    }
    return 1.0;
}

// Function 961
float ao( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 962
vec3 GetDirectionalLightSourcePosition ()
{
    // mode >= 5.0 starts moving and rotating light source
    float time = GetMode() - 5.0;
    time = max(time, 0.0);
    float canMove = step(5.0, GetMode());

    vec3 ret = directionalLightSourcePosition;
    
    ret += vec3(sin(time * 0.83) + 1.0 * canMove, sin(time * 1.1), sin(time * 0.1));
    
    return ret;
}

// Function 963
float getLight (vec3 pos, vec3 eye) {
  vec3 light = vec3(-.5,7.,1.);
  vec3 normal = getNormal(pos);
  vec3 view = normalize(eye-pos);
  float shade = dot(normal, view);
  shade *= hardShadow(pos, light);
  return shade;
}

// Function 964
vec3 pointLight (vec3 o, vec3 d, float limit) {
    float light = 0.0;
    for (int i = 0; i < LIMIT_IT; ++i) {
        float fi = float(i);
        if (fi > limit) break;
     	vec3 sam = o+d*fi*0.5;
        light += exp(-length(sam-lightSource)*4.0);
        if (light >= 1.0)
            break;
    }
    
    return vec3(clamp(pow(light, 8.0) + light,0.0,1.0));
}

// Function 965
float GetFloorSpotlightBrightness( vec3 bgPos )
{
    vec2 spotlightPos = bgPos.xz / vec2( 100.0, 60.0 );
    return mix( 0.0, 1.0, smoothstep( 1.0, 0.0, length( spotlightPos ) ) );
}

// Function 966
vec2 shadowMarch(vec3 startPoint, vec3 direction, int iterations, float maxStepDist)
{
    vec3 point = startPoint;
    direction = normalize(direction);
    float dist = 10.0;
    float distSum = 0.0;
    float shadowData = 0.0;
    float shadow = 0.0;
    
    int i;
    for (i = 0; i < SHADOW_RAYS_COUNT && distSum < MAX_SHADOW_DISTANCE && abs(dist) > EPSILON * 0.5; i++)
    {
     	dist = terrainDist(point, direction.xy);
        
        shadow = dot(normalize((point - vec3(0.0, 0.0, dist)) - startPoint), direction);
        if(shadow > shadowData) shadowData = shadow;
        
        dist = min(dist, 1.0);
        distSum += dist;
        point += direction * dist;     
    }
    
    return vec2(smoothstep(MAX_SHADOW_DISTANCE - EPSILON, MAX_SHADOW_DISTANCE, distSum), shadowData);
}

// Function 967
vec2 CalculateShadowMapUV(in mat4 shadowMapMatrix, in vec3 position, in float aspectRatio)
{
    vec3 lightPosition = vec3(shadowMapMatrix[3][0], shadowMapMatrix[3][1], shadowMapMatrix[3][2]); 
    
    vec3 lightWorldDirection = normalize(position.xyz - lightPosition);
    vec3 shadowMapCameraRayDirection = (vec4(lightWorldDirection.xyz, 1.0) * shadowMapMatrix).xyz;
    shadowMapCameraRayDirection /= shadowMapCameraRayDirection.z;
    
    vec2 textureCoords = shadowMapCameraRayDirection.xy / vec2(aspectRatio, 1.0);
    textureCoords = textureCoords * 0.5 + 0.5;
    
    return textureCoords;
}

// Function 968
vec3 map_light_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return rd;
}

// Function 969
float shadow (vec3 ro, vec3 rd){
    float k = 8.0;
    float res = 1.0;
    
    for(float t = 1.0; t<16.0; t += 0.2){
     	float h = map(ro + rd*t);
        if (h < 0.001)
            return 0.0;
        res = min (res, k*h/t);
    }
    
    return res;
}

// Function 970
vec4 lighting(vec3 ro, vec3 rd, vec3 pos, vec4 res) {
    res.rgb *= max(dot(normal(ro + rd*res.w), light) * shadow(pos,light,.1,0.,1.), .1);
    return res = mix(res, vec4(.9,.9,1,1), pow(res.w/tmax,2.));
}

// Function 971
vec3 SampleLightMIS_h(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, float N_d, float N_h)
{
	vec3 L = SampleHemisphereCosineWeighted(N, s);
	float t;
	Object unused;
	if (IntersectScene(Ray(P, L), ignoreObjId, t, unused) == lightId) {
		vec3 V = L*t;
		float inversePDF_d;
		if (IsQuad(light)) {
			float distSqr = t*t; // same as dot(V, V)
			inversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;
		} else {
			vec3 pointToLight = light.pos - P;
			float radiusSqr = light.radius*light.radius;
			float sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);
			float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);
			inversePDF_d = 2.0*PI*(1.0 - cosThetaMax);
		}
		inversePDF_d *= max(0.0, dot(N, L))/PI;
		if (inversePDF_d > 0.0) {
			float PDF_d = 1.0/inversePDF_d;
			float PDF_h = 1.0;
		#if MIS_USE_POWER
			float b = MIS_power_b;
			return SampleLightColor(P + V, light)*pow(N_h*PDF_h, b - 1.0)/(pow(N_d*PDF_d, b) + pow(N_h*PDF_h, b));
		#else
			return SampleLightColor(P + V, light)/(N_d*PDF_d + N_h*PDF_h);
		#endif
		}
	}
	return vec3(0);
}

// Function 972
vec3 shade( in vec3 pos, in vec3 nor,
			in vec3 ro,  in vec3 rd,
			float matID, float dis, in vec3 uvw )
{
	vec3 xnor = nor;
    vec3 rgb = vec3(0.0);

	// materials
	float fakeao = 1.0;

    // piedras suelo
    if( matID<0.5 )
    {
		vec2 res = celular( vec3(96.0*pos[0], 12.0*pos[1], 96.0*pos[2]) );
		float ce = 5.0*(res[1]-res[0]);
        rgb = vec3( sqrt(ce) );
		float fb = fbm( 8.0*pos );
        vec3 cosa2 = vec3( 0.60, 0.50, 0.40 );
        rgb = mix( rgb, cosa2, 0.5 + 0.5*fb );

        rgb *= 0.21 + 0.14*fbm( 256.0*pos );

		xnor = addbumpchampy( xnor, -3.0*4.0, pos );
    }
    // champis
    else if( matID<1.5 )
    {
        float fb = fbm( 8.0*pos );
	
		vec2 res = celular( vec3(768.0*pos.x, 12.0*pos.y, 768.0*pos.z) );
		float am = 1.0-smoothstep(0.02,0.15,res.x);
		float cc = smoothstep(-0.75,-0.10,nor.y);
		am *= cc;
		am = 1.0-am;


        vec3 arriba = mix( vec3( 0.50, 0.50, 0.50 ), vec3( 0.34, 0.26, 0.18 ), am );

		cc = 1.0-smoothstep(0.40,1.20,uvw.y);

		rgb = vec3(0.45,0.40,0.30);

		rgb *= 1.0 + 0.75*fbm(192.0*pos);

		xnor = addbumpchampy( xnor, 2.0*clamp(1.75-0.40*uvw[1],0.0,1.0), vec3(0.25*uvw.z, 1.0*pos.y, 0.0) );

		rgb = mix( rgb, arriba, cc );
		float spe = clamp(-dot(rd,xnor ),0.0,1.0);
		spe = 1.0 - spe;
		spe = spe*spe;
		rgb += vec3(spe*0.50);

		fakeao = 1.0-clamp((uvw.y-5.25)*0.75,0.0,1.0);
		
		fakeao *= 1.0 - 0.25*(1.0-sin(11.0*uvw.z))*smoothstep(3.0,4.5,uvw.y);
		float ath = 0.5 + 0.05*sin(3.0*uvw.z);
		float by = (uvw.y-3.0)*ath;
		if( by>1.0 ) 
		fakeao *= 0.20 + 0.80*clamp((by-1.0)*4.0,0.0,1.0);
    }
    // ramas
    else if( matID<2.5 )
    {
		vec2 res = celular( vec3(96.0*pos.x,256.0*pos.y, 96.0*pos.z) );
		float ce = 0.20 + 52.0*res.y*res.y*res.y;

        rgb = vec3(0.80, 0.75, 0.65 ) * ce;

		float spe = clamp( 1.0+dot( rd, nor ), 0.0, 1.0 );
		rgb += vec3(0.30, 0.15, 0.10) * spe;

        xnor = addbumpchampy( xnor, -0.80*-3.0, vec3(1.0*pos.x, 1.0*pos.y, 0.5*pos.z) );
        xnor = addbumpchampy( xnor,  0.60*-3.0, pos*0.5 );

        rgb += vec3(0.07, 0.15,0.00) * (1.0-res.x*4.0);
        rgb += vec3(0.25, 0.22,0.19);

		// verdin
        float fb = smoothstep(-0.20,0.20, 0.30+fbm( vec3(158.0*pos.x, 158.0*pos.y, 1.0*pos.z) ));
		float var = 0.40*noise3f( vec3(4.0*pos.xy,64.0*pos.z));
		fb *= smoothstep(-0.10,0.10,xnor.y+var);
		rgb *= vec3(1.0-0.70*fb,1.0-0.60*fb,1.0-0.70*fb);
	}   
    // aliens
    else if( matID<3.5 )
    {
		float ks = 0.25;
		float ce = 0.00;
		float ss = 0.50;
		for( int i=ZERO; i<8; i++ )
		{
		    vec2 res = celular( 74.0*pos*ks );
		    ce+=ss*res.x;
		    ss*=0.60;
		    ks*=2.0;
		}
		ce = clamp(3.5*ce-0.30, 0.0, 1.0);
        
        rgb = vec3(0.20, 0.10, 0.0 ) + vec3(0.80*ce);

		xnor = addbumpbolas( xnor, -6.0, pos );
        
        float fb = 0.15*clamp( fbm( 8.0*pos ), 0.0, 1.0 );
		rgb.x -= fb;
		rgb.z -= fb;

        fb = fbm( vec3(128.0*pos.x, 4.0*pos.y, 128.0*pos.z) );
		rgb *= 0.75+0.25*fb;

        float ni = smoothstep( -0.10, 0.20, nor.y );

        rgb = mix( rgb, vec3(0.09, 0.05, 0.04), ni );

        // fres
		float spe = clamp( -dot( rd, xnor ), 0.0, 1.0 );
		spe = 1.0 - spe;
		rgb += vec3(spe*spe*0.78);
    }   
    // suelo y arboles
    else if( matID<4.5)
    {
        vec2 res = celular( vec3(96.0*pos.x, 12.0*pos.y, 96.0*pos.z) );
		float ce = 20.0*(res.y-res.x);
        rgb = vec3(0.50, 0.45, 0.40 ) * sqrt(ce);

        rgb = mix( rgb, vec3(0.60, 0.50, 0.40), 0.5 + 0.5*fbm( 8.0*pos ) );
        rgb *= (0.60 + 0.40*fbm( 256.0*pos ));

		ce = fbm( vec3(1024.0*pos.x, 512.0*pos.y, 1024.0*pos.z) );
        float ni = smoothstep( 0.0, 0.30, nor.y );
		vec3 verde2 = vec3( 0.06, 0.05, 0.04 );
        vec3 verde1 = vec3( 0.10, 0.09, 0.04 );
        vec3 verde = mix( verde1, verde2, ce );

		ce = fbm( vec3(1024.0*pos.x+123.789, 512.0*pos.y+71.71, 1024.0*pos.z) );
		float ce2 = smoothstep(-0.05,0.0, fbm( vec3(32.0*pos.x+123.789, 32.0*pos.y+71.71, 32.0*pos.z)) );
        rgb = mix( rgb, verde, ce2*ni*smoothstep(-0.10,0.0,ce) );

		rgb *= 0.60;
		float spe = clamp(-dot(rd,xnor),0.0,1.0);
		spe = 1.0-spe;
		spe = spe*spe;
		spe *= 0.20;

	    //--------------

	    float ks = tan(0.75*pos.z);
	    float kkHier = 0.5 + 0.5*fbm( vec3(4096.0*pos.x, 128.0*pos.y, 4096.0*pos.z*ks) );
	    float hh = 0.75*clamp(-rd.y,0.0,1.0);
	    kkHier = smoothstep( hh, 1.0, kkHier );

        vec3 cesped = vec3(0.10,0.05,0.00);
        cesped += vec3(0.22,0.24,0.25)*(0.5 + 0.5*fbm(64.0*pos));
		cesped += vec3(0.05,0.08,0.10)*(0.5 + 0.5*fbm(vec3(1024.0*pos.x,1024.0*pos.y,1024.0*pos.z)));
		cesped *= kkHier;
		cesped *= vec3(1.10,1.20,1.00);

	    float ce3 = smoothstep(-0.20,-0.10, fbm(32.0*pos+vec3(0.0,11.71,0.0)) );
	    rgb = mix( rgb, cesped, ce3*ni );

        rgb += vec3(spe*(1.0-ni) );
    }
	else
	{
		rgb = vec3( 0.0 );
	}

	float  ao = xnor.y*0.5 + 0.5;
    ao +=  0.25*(1.0 - 1.0/(1.0+pos.y));
	ao += xnor.x*0.20;
	ao *= (uvw.x*0.90+0.10);
	ao *= fakeao;

    vec3 lig = vec3( 0.80, 0.50, 0.10 );

	float ffs = smoothstep( -0.10, 0.10, fbm( vec3(32.0*pos.x,32.0*pos.z,1.70) ) );
	ffs *= clamp( 4.0*dot(xnor,lig), 0.0, 1.0 );
	ffs *= clamp( 4.0*dis-0.10, 0.0, 1.0  );

    vec3 aoc = vec3( 0.67, 0.71, 0.75 );

    aoc = aoc * ao;
    aoc += vec3(1.30, 1.25, 1.20) * ffs*ao;
	
    // lighting
    rgb *= aoc;

    // fog
	rgb *= 1.0/(1.0+0.85*dis);
	rgb += vec3(0.0496, 0.0528, 0.0544) * dis;

    // sun
	float sun = clamp(dot(rd,lig),0.0,1.0);
	sun = sun*sun;
	sun = sun*sun;
	float tsun = sun*0.08;
	sun = sun*sun;
	sun = sun*sun;
	tsun += sun*0.70;
    rgb += vec3(1.30, 1.20, 1.0) * tsun;

    return rgb;
}

// Function 973
float shadowtrace(vec3 ro, vec3 rd) {
    int i;
    float t = shadoweps;
    float dist = map(ro+t*rd).x;
    float fac = 1.0;
    for (i=0; i<shadowiters; i++) {
        t += shadowstep;
        dist = map(ro + t*rd).x;
        fac = min(fac, dist * sharpness / t);
    }
    return fac > 0. ? mix(0.5, 1., fac) : mix(0.5, 0., -fac);
}

// Function 974
void Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const vec3 vLightColour)
{    
    vec3 vPos = surface.vPos;
	vec3 vToLight = vLightPos - vPos;	
    
	vec3 vLightDir = normalize(vToLight);
	float fDistance2 = dot(vToLight, vToLight);
	float fAttenuation = 100.0 / (fDistance2);
	
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);
}

// Function 975
vec3 lighting(vec3 p, vec3 nor, vec3 rd, vec3 mat)
{
    sunLight = normalize(sunPos - p);
    float sh = shadow(p+sunLight*0.2,  sunLight);
    float c = max(dot(nor, sunLight), 0.0)+abs(nor.y)*sh*.5;
    vec3 ref = reflect(rd, nor);

    vec3 spec = texture(iChannel0, ref).xyz;
    vec3 col = ((mat * c)+ pow(spec, vec3(3.0))*.2)*sh;
     #ifndef OFF_LINE
    col+= mist *vec3(0, .0, 0.1)  * 2.0 * sh;
    #else
    col+= mist *vec3(.0, .0, 0.1) * .3 * sh;
    #endif
    return col;
    
}

// Function 976
float calcShadow(vec3 p, vec3 ld) {
	// Thanks iq.
	float s = 1., t = .1;
	for (float i = Z0; i < 30.; i++)
	{
		float h = tubez(t * ld + p).d;
		s = min(s, 20. * h / t);
		t += h;
		if (s < .01 || t > 25.) break;
	}

	return clamp(s, 0., 1.);
}

// Function 977
vec3 GetVolumetricLighting(Ray ray, float maxDist, vec2 fragCoord)
{
	vec3 color = vec3(0,0,0);
	Light light;
	light.p = vec3(sin(iTime*0.3)*2.0,5,cos(iTime*0.3)*2.0+4.0);
	light.color = vec3(1,1,1);
	light.radius = 20.0;
	
	float inscattering = maxDist/200.0;
	float volRayStep = maxDist/float(VOLUMETRIC_SAMPLES-1);
	float randomStep = rand(fragCoord.xy)*volRayStep;
	Ray volRay;
	volRay.o = ray.o + ray.dir*randomStep;
	for(int v = 0; v < VOLUMETRIC_SAMPLES; v++)
	{
		vec3 lightVec = light.p-volRay.o;
		float lightDist = length(lightVec);
		volRay.dir = lightVec/lightDist;
		Intersection i = SceneIntersection(volRay);
		if(i.dist > lightDist)
		{
			color += CalcIrradiance(light, volRay.o)*inscattering;
		}
		volRay.o += ray.dir * volRayStep;
	}
	
	return color;
}

// Function 978
vec3 lighting(in Hit h) {
  if (h.ray.len > MAX_TRACE_DIST) return _back(h.ray);
  vec4 fgi = _gi(h.pos, h.nml);    // Fake Global Illumination
  vec4 fcs = _cs(h.pos, dif.dir);  // Fake Caustic Shadow
  //   lin = ([Ambient]        + [Diffuse]        * [SS]  + [CS])    * [AO]  + [GI]
  vec3 lin = (_diff(h.nml, amb) + _diff(h.nml, dif) * fcs.w + fcs.rgb) * fgi.w + fgi.rgb;
  return  h.srf.kd * lin;
}

// Function 979
vec3 shade(in vec3 p, in vec3 dir, in vec3 n) {

	float savehitcar=hitcar;

	vec3 trackoffset=-vec3(path(p.z).xy,0.);
	vec3 pos=p;
	vec3 col=vec3(.5); // main color
	vec3 carp=pos-carpos; //scaled coordinates for the car
	carp=carrot*carp; // rotate car
	pos+=trackoffset; // apply track transformation to the coordinates
	// track lines
	if (pos.y<.5) col+=pow(max(0.,.2-abs(pos.x))/.2*abs(sin(pos.z*2.)),8.)*TUBE_COLOR*2.;
	pos.x=abs(pos.x);
	// fake AO for the tunnel's upper corners
	if(tunnel(pos.z)<0.)
		col*=1.-pow(max(0.5,1.-length(pos.xy+vec2(-FOLD*1.5,-.85))),5.)*max(0.,1.+pos.y);
	if (tubes(pos)<det) col=TUBE_COLOR; // hit tubes
	if (carcarDE(carp)<det) col=carcarCE(carp); // hit car, get coloring

	float ao=calcAO(p,n); // calc AO
	float camlight=max(0.,dot(dir,-n)); // camlight used for ambient

	// --- Tube lights ---

	vec3 tpos1=vec3((tubepos+vec2(FOLD,0.)),0.)+trackoffset; // get tube positions
	vec3 tpos2=tpos1-vec3((tubepos.x+FOLD)*2.,0.,0.);
	// light direction
	vec3 tube1lightdir=normalize(vec3(p.xy,0.)+vec3(tpos1.xy,0.)); 
	vec3 tube2lightdir=normalize(vec3(p.xy,0.)+vec3(tpos2.xy,0.));
	// light falloffs
	float falloff1,falloff2;	
	if (savehitcar>0.) {
		falloff1=pow(max(0.,1.-.15*distance(vec3(p.xy,0.),vec3(-tpos1.xy,0.))),4.);
		falloff2=pow(max(0.,1.-.15*distance(vec3(p.xy,0.),vec3(-tpos2.xy,0.))),4.);
	} else {
		falloff1=pow(max(0.,1.-.2*distance(vec3(p.xy,0.),vec3(-tpos1.xy,0.))),4.);
		falloff2=pow(max(0.,1.-.2*distance(vec3(p.xy,0.),vec3(-tpos2.xy,0.))),4.);
	}
	
	float diff, spec;
	
	vec3 r=reflect(LIGHTDIR,n);
	
	// tube1 calcs
	diff=max(0.,dot(tube1lightdir,-n)); 
	diff+=max(0.,dot(normalize(tube1lightdir+vec3(0.,0.,.2)),-n))*.5; // add 2 more 
	diff+=max(0.,dot(normalize(tube1lightdir-vec3(0.,0.,.2)),-n))*.5; // with Z shifted
	spec=pow(max(0.,dot(tube1lightdir+vec3(0.,0.,.4),r)),15.)*.7;
	spec+=pow(max(0.,dot(tube1lightdir-vec3(0.,0.,.4),r)),15.)*.7;
	float tl1=(falloff1*ao+diff+spec)*falloff1;

	// tube2 calcs
	diff=max(0.,dot(tube2lightdir,-n));
	diff+=max(0.,dot(normalize(tube2lightdir+vec3(0.,0.,.2)),-n))*.5;
	diff+=max(0.,dot(normalize(tube2lightdir-vec3(0.,0.,.2)),-n))*.5;
	spec=pow(max(0.,dot(tube2lightdir+vec3(0.,0.,.4),r)),15.)*.7;
	spec+=pow(max(0.,dot(tube2lightdir-vec3(0.,0.,.4),r)),15.)*.7;
	float tl2=(falloff2*ao+diff+spec)*falloff2;

	// sum tube lights - add ambient - apply tube intervall
	vec3 tl=((tl1+tl2)*(.5+tubeinterval*.5))*TUBE_COLOR;//*(1.+tun*.5);


	// --- Car lights ---

	// get the car turbines direction (aproximate)
	vec3 carlightdir1=normalize(p-carpos+vec3(.2,0.06,.15));
	vec3 carlightdir2=normalize(p-carpos+vec3(-.2,0.06,.15));
	vec3 carlightdir3=normalize(p-carpos+vec3(.2,0.06,-.35));
	vec3 carlightdir4=normalize(p-carpos+vec3(-.2,0.06,-.35));

	float cfalloff=pow(max(0.,1.-.1*distance(p,carpos)),13.); // car light falloff

	// accumulate diffuse
	diff=max(0.,dot(carlightdir1,-n))*.5;
	diff+=max(0.,dot(carlightdir2,-n))*.5;
	diff+=max(0.,dot(carlightdir3,-n))*.5;
	diff+=max(0.,dot(carlightdir4,-n))*.5;

	if (savehitcar<1.) diff*=clamp(1.-carlightdir1.y,0.,1.);
	
	// add ambient and save car lighting
	vec3 cl=TURBINES_COLOR*((diff+spec*.0)*cfalloff+cfalloff*.3)*1.2;
 	
	// --- Main light ---
	
#ifdef LOW_QUALITY
	float sh=ao;
#else
	float sh=shadow(p, LIGHTDIR); // get shadow
#endif

	diff=max(0.,dot(LIGHTDIR,-n))*sh*1.3; // diffuse
	float amb=(.4+.6*camlight)*.6; // ambient+camlight
	spec=pow(max(0.,dot(dir,-r))*sh,20.)*SPECULAR; //specular
	if (savehitcar>0.) {diff*=.8;amb*=.3;}
	vec3 l=(amb*ao*AMBIENT_COLOR+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;	

	if (col==TUBE_COLOR) l=.3+vec3(camlight)*.7; // special lighting for tubes

	return col*(l+cl+tl); // apply all lights to the color
}

// Function 980
bool SupportsSpecularLight(in Material m)
{
    return (m.flags & MATERIAL_SUPPORTS_SPECULAR_LIGHT) != 0;
}

// Function 981
vec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)
{
    vec3 pc=carTrafo(pos);
    vec3 glasspos=vec3(1000.);
    vec3 glassn=vec3(0.);
    float mat=distM(pos).y;
    if(mat==GLASS)
    {
        glasspos=pos;
        glassn=normalize(getGrad(pos,.001));
        enable_glass=false;
        march(pos,dir);
    }
    mat=distM(pos).y;
    
    vec3 light=getLightDir();
    float sh=1.;
#ifdef SHADOW
    vec3 posS=pos+.017*light;
    enable_car=true;
    sh=march(posS,light);
#endif
    enable_car=true;
    vec3 n=getGrad(pos,.001);
    if (length(n)<.001) n=vec3(0,0,1);
    n=normalize(n);
    if(mat==BG) n=vec3(0,0,1);

    float ao=1.;
    ao=getAO(pos,n);
    ao=sqrt(ao);
    ao=ao*.7+.3;

    //vec3 light = normalize(vec3(-.5,.5,2));
    float diff=clamp(dot(n,light),0.,1.);

    diff=min(diff,sh);
    
    // no ao in lighted areas
    ao=mix(ao,1.,diff);
    ao=clamp(ao,0.,1.);
    //return vec3((diff*.6+.4)*(ao));
    

    Material mtrl=getMaterial(mat);

    // evironmental reflection
    n=normalize(n);
    if(mat==CARBODY) // brushed metal surface
    {
        vec4 r1=rand3d(pc*.1);
        vec4 r2=rand3d(pc*.05);
        // scramble normals randomly
        n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;
        // darken randomly
        n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;
    }
    vec3 R=reflect(dir,n);
    vec3 refl=myenv(pos,R.xyz,1.).xyz;
    //refl=refl*1.2+.3;
    float fres=abs(dot(R,n));
    fres=1.-fres;
    fres*=fres*fres;
    fres=fres*.9+.1;
    float fres0=fres;
    #ifdef SCRATCHES
    vec3 n0=n;
    int numscr=7;
    float dang=1.57*2./float(numscr);
    float ang=.5;
    refl*=1.;
    vec3 drefl=vec3(0);
    float sum=0.;
    vec3 pi=pc;
    vec3 heading=vec3(0,0,1);
    vec3 tan1=vec3(1,0,0);
    vec3 tan2=vec3(0,1,0);
    // ...trying to implement some micro scratches
    for(int i=0;i<numscr*3;i++)
    {
        n=n0;
        vec2 cs=cos(ang+vec2(0,-1.57));
        mat2 m=mat2(cs,cs.yx*vec2(-1,1));
        //dFdx()
        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;
        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);
        dn2d=dn2d*m;
        //dn2d=dn2d.yx*vec2(1,-1);
        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);
        n=normalize(n);
        R=reflect(dir,n);
        float fres=abs(dot(R,n));
        fres=1.-fres;
        fres*=fres*fres;
        fres=fres*.4+.6;
        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;
        //fact=.2;
        drefl+=fact*myenv(pos,R.xyz,1.).xyz;
        sum+=fact;
        ang+=dang;
        pi=pi.zxy;
        heading=heading.yzx;
        tan1=tan1.yzx;
        tan2=tan2.yzx;
    }
    drefl/=float(numscr);
    refl=mix(refl,drefl,mtrl.scratchy);
    #endif
    
    #ifdef RENDER_GLASS
    vec3 Rg=reflect(dir,glassn);
    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;
    //glassrefl=glassrefl*1.2+.3;
    float glassfres=abs(dot(Rg,glassn));
    glassfres=1.-glassfres;
    glassfres*=glassfres*glassfres;
    glassfres=glassfres*.85+.15;
    if(glassn==vec3(0)) glassfres=0.;
    #endif

    vec3 rcol=vec3(1);
    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;
    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;
    vec3 col=mtrl.col;
    if(mat==FLOOR) {
        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;
        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;
        #ifdef WET_ASPHALT
        col*=.35+.65*step(-.66,pos.z);
        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));
        #endif
    }

    float zr=length(pos-pos0)/300.;
    //diff=sqrt(diff);

    outfres=fres;
    if(glassfres!=0.) outfres=glassfres;
    fres*=reflections;
    glassfres*=reflections;

    outao=ao;
    
	vec3 bg=myenv(pos0,dir,1.).xyz;
	// diff, ao, refl
	vec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;
	//finalcol=col;
	// fog
	//finalcol = mix(finalcol,bg,1.-exp(-zr));
	finalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));
	#ifdef RENDER_GLASS
	finalcol=mix(finalcol,glassrefl,glassfres);
	#endif
	return finalcol;
}

// Function 982
vec4 shade(vec4 p, vec4 d, vec4 objnorm, float depth) {
    vec4 sun = normalize(vec4(-1.0));
    vec4 reflectnorm = reflect(d,objnorm);
    vec4 color = objnorm*0.5+0.5;
    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,sun)));
    fragColor /= depth*depth*0.01+1.0;
    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*3.0/depth/depth);
    return clamp(fragColor,0.0,1.0);
}

// Function 983
vec3 GetLightMountains(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);
  const vec3 sunColor = vec3(1.1, 0.53, 0.27); 
    
  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );


  lightTot += 3.*dif*sunColor;

  lightTot += .65*amb*vec3(0.35, 0.45, 0.6);  
  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.);
  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);
  lightTot = mix( lightTot, lightTot*2., fre );

  return clamp(lightTot, 0.22, 10.);
}

// Function 984
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 16; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.05;    
    float end = max(length(rd), 0.001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.
        dist += clamp(h, 0.02, 0.25);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.
    return min(max(shade, 0.) + 0.25, 1.0); 
}

// Function 985
vec3 enlight(vec3 p, vec3 v, vec3 n, mat_t m, vec3 lpos, vec3 lcolor) {
    vec3 ldir = lpos - p; // direction from the point to the light source
    float ldist2 = dot(ldir, ldir); // square distance to the light source
    float ldist = sqrt(ldist2); // distance
    ldir /= ldist; // ldir is now normalized
    float shadow = shadowtrace(p, ldir, ldist-.2); // whether the point is in shadow
    return shadow * lcolor * (
        // Diffuse term (simple Lambert)
	  m.diffuse * max(0., dot(n,ldir))
        // Specular term (Phong-ish)
	+ m.specular.rgb * pow(max(0.,dot(normalize(ldir-v), n)), m.specular.w)
        // Specular energy conservation? (or something, it was 3 years ago :D)
        * (m.specular.w + 2.) * (m.specular.w + 4.) / (24. * (m.specular.w + pow(2., -m.specular.w/2.)))
	) / ldist2;
}

// Function 986
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for(int i=0; i<12; i++){
        float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 987
float compute_shadows(in vec3 ro, in vec3 rd)
{
    float res = 1.0;
    float t = 0.01;
    for(int i = 0; i < 16; i++)
    {
        vec3 p = ro + rd * t;
        float d = intersect_shadow(p);
        res = min(res, max(d, 0.0) * 16.0 / t);
        if (res < 0.001)
            break;
        t += d * 0.5;
    }
    
    return res;
}

// Function 988
float softshadow(in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = 0.05;
    for(int i = 0; i < 32; i++)
    {
		float h = map(ro + rd * t);
        res = min(res, 8.0 * h / t);
        t += clamp(h, 0.02, 0.1);
        if(h < 0.001 || t > 5.0) break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 989
float light(vec3 lp, vec3 rp, vec3 n, float pulse)
{
    return (1.5*(pulse+0.05)/pow(distance(lp,rp),2.0))*max(dot(normalize(lp-rp), n), 0.0)*0.25;
}

// Function 990
float directionalLight(vec4 light, vec3 normal) {
	vec3 lightDir = normalize(light.xyz);
	return light.w * dot(lightDir, normal);
}

// Function 991
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float ph = 1e20;
    for( float t=mint; t<maxt; )
    {
        float h = sdf(ro + rd*t, false);
        if( h<0.001 )
            return 0.0;
        float y = h*h/(2.5*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, k*d/max(0.001,t-y) );
        ph = h;
        t += h;
    }
    return res;
}

// Function 992
float lightPointDiffuseShadow(vec3 pos, vec3 lightPos, vec3 normal) {
	vec3 lightDir = normalize(lightPos - pos);
	float lightDist = length(lightPos - pos);
	float color = square(dot(normal, lightDir)) / square(lightDist);
	if (color > 0.00) color *= castShadowRay(pos, lightPos, 0.05);
	return max(0.0, color);
}

// Function 993
vec3 lighting(vec3 normal)
{
	return vec3(dot(normal,normalize(vec3(0.5,1.0,0.0)))*0.5+0.5);    
}

// Function 994
float shadow( vec3 ro, vec3 rd, float mint, float maxt )
{
	float t = mint;
    for ( int i = 0; i < 128; ++i )
    {
        float h = scene( ro + rd * t );
        if ( h < 0.001 )
            return 0.0;
        t += h;
		
		if ( t > maxt )
			break;
    }
    return 1.0;
}

// Function 995
light directionLight(vec3 direction, vec3 color, float intensity) {
    return light(
        DIRECTION_LIGHT, // type
        vec3(0.0), // position (N/A)
        color, // color
        intensity, // intensity
        direction, //direction
        0.0, // falloff (N/A)
        0.0, // spread (N/A)
        0.0 // taper (N/A)
    );
}

// Function 996
float shadow(vec3 from, vec3 increment)
{
	const float minDist = 10.0;
	
	float res = 1.0;
	float t = 0.1;
	for(int i = 0; i < 80; i++) {
		float m;
        float h = distanceField(from + increment * t,m);
        if(h < minDist)
            return 0.0;
		
		res = min(res, 2.0 * h / t);
        t += h * 0.5;
		//if (t >= 20.0) break;
    }
    return res;
}

// Function 997
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 998
vec3 shade(Ray ray) {
    
    Hit scn  = raymarch(ray, false);
    vec3 col = vec3(0.);
    
    float fog = getFog(ray,scn.p);
    if(fog == 1.) return MOON_COLOR;
    
    if(scn.id == 0) {
    
        bool s = inShadow(scn.p);
        
        vec3 n = calcNormal(scn.p);
        vec3 l = calcLighting(scn, n, s);
        vec3 r = reflect(ray.dir, n);
        
        col = vec3(.5) * l;
        
        Ray rr  = Ray(scn.p + r * .01, r);
        Hit rh  = raymarch(rr, true);
        vec3 rc = rh.id == 1 ? shadeGround(rr,rh) : mix(col,MOON_COLOR,getFog(rr,rh.p));
        
        float fresnel = mix(.2,.9, max(dot(ray.dir,n), 0.));
        col = mix(col, rc, fresnel);
        
        col += calcSpecular(r, 90., s);
        
	} else if(scn.id == 1) {
     
        col = shadeGround(ray, scn);
        
    }
    
    col = mix(col, MOON_COLOR, fog);
    return col;
    
}

// Function 999
float calcAO( in vec3 p, in vec3 n )
{
    
	float ao = 0.0, l;
	const float nbIte = 12.0;
	const float falloff = 1.;
    
    const float maxDist = 1.;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + fract(cos(i)*45758.5453))*.5/nbIte*maxDist;
        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);
    }
	
    return clamp( 1. - ao*2./nbIte, 0., 1.);
}

// Function 1000
function SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}

// Function 1001
void shade( in vec3 pos, in vec3 nor, in vec3 rd, in float matID, out vec4 mate, out vec2 mate2 )
{
	mate = vec4(0.0);
	mate2 = vec2(0.0);
	
    if( matID<3.5 )			ShadeMonolith(nor, rd, 4.0, vec3(1.0,1.0,1.0), mate);
    else if( matID<4.0 )	ShadeMonolith(nor, rd, 3.0, vec3(1.0,1.0,0.0), mate);
    else if( matID<4.5 )    ShadeMonolith(nor, rd, 2.0, vec3(0.9,0.5,0.1), mate);
    else if( matID<5.0 )	ShadeMonolith(nor, rd, 1.0, vec3(1.0,0.0,0.0), mate);
    else if( matID<5.5)		ShadeMonolith(nor, rd, 0.0, vec3(1.0,0.0,1.0), mate);

	if( matID<2.5 )
	{
        float iss = smoothstep( 0.5, 0.9, nor.y );
        iss = mix( iss, 0.9, 0.75*smoothstep( 0.1, 1.0, texturize( iChannel1, 0.1*pos, nor ).x ) );

        vec3 scol = vec3( 0.8, 0.5, 0.2 );

        vec3 cnor = normalize( -1.0 + 2.0*texture( iChannel2, 0.15*pos.xz ).xyz );
        cnor.y = abs( cnor.y );
        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,cnor)), 0.0, 1.0), 64.0 ) );
        mate2.y = spe*iss;

        mate.xyz = mix( mate.xyz, scol, iss );
	}    

}

// Function 1002
float keyShade(float a){a=mod(a,12.);return (mod(a+step(5.,a),2.));}

// Function 1003
vec3 doLighting(vec3 pos, vec3 dir, bool ignoreSpecs)
{
    // Light the model...
    vec3 col;
    vec3 norm = doNormal(pos, ignoreSpecs);
    float sh = shadow(pos+norm*.5, lightDir);
    float b = max(dot(norm, lightDir),0.0);
    float bl = max(dot(norm, backDir),0.0);
    vec3 ref = reflect(dir, norm);
    vec3 diff = CF(pos);
    float s = pow(max(dot(ref, lightDir),0.0), specular)*specAmp;
    col = (diff*b+ s*vec3(.6,.55, .5))*sh;
    col += diff*illum+ diff*bl*vec3(0.05,0.05,.4)+.01;
    return col;
}

// Function 1004
vec3 shade (in Result res)
{    
    vec3 amb = vec3 (.1);
    vec3 diffM = vec3 (.9, .25, .2);
    vec3 diffL = vec3 (.95, .9, .3)*3.;
    vec3 diffL2 = vec3 (.5, .7, .85)*2.;
    vec3 specM = vec3 (1.);
    vec3 specL = vec3 (1.);
    vec3 lPos = vec3 (.4, 1., -1.25);
    vec3 lPos2 = vec3 (-.25, .5, 1.);
	vec3 lDir = normalize (lPos - res.point);
	vec3 lDir2 = normalize (lPos2 - res.point);

    float diff = clamp (dot (res.normal, lDir), .0, 1.);
    float diff2 = clamp (dot (res.normal, lDir2), .0, 1.);
    vec3 h = normalize (lDir + res.point);
    vec3 h2 = normalize (lDir2 + res.point);
    float shininess = 60.;
    float spec = pow (clamp (dot (res.normal, h), .0, 1.), shininess);
    float spec2 = pow (clamp (dot (res.normal, h2), .0, 1.), shininess);
    float sha = shadow (Ray (res.point + .001 * res.normal, lDir), lPos);
    float sha2 = shadow (Ray (res.point + .001 * res.normal, lDir2), lPos2);

    return amb + sha * (diff * diffM * diffL + spec * specM * specL) + 
        sha2 * (diff2 * diffM * diffL2 + spec2 * specM * specL);
}

// Function 1005
void initLights() {
    #if nLights != 0
#endif
}

// Function 1006
vec3 GetAmbientLight()
{
	return 1.2 * vec3(0.03, 0.018, 0.018);
}

// Function 1007
vec3 genLightCoords()
{
	// Use simple trig to rotate the light position around a point.
	vec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), 
				lightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),
				lightPathCenter.z);
	return lightCoords;
}

// Function 1008
vec3 lightColor()
{
    return vec3(1.0, 0.9, 0.75) * 3.9;
}

// Function 1009
float get_ao(vec3 p, vec3 n)
{
    float r=0.0, w=1.0, d;
    for(float i=1.; i<5.0+1.1; i++)
    {
        d=i/5.0;
        r+=w*(d-map(p+n*d));
        w*=0.5;
    }
    return 1.0-clamp(r,0.0,1.0);
}

// Function 1010
float ts_shadow_sample( TrnSampler ts, sampler2D ch, vec3 x )
{
#if WITH_TRN_SHADOW
    return ts_shadow_eval( ts_shadow_lookup( ts, ch, x ).xy, length(x) );
#else
    return 1.;
#endif
}

// Function 1011
vec3 light(vec3 N, vec3 rd){
  float time = 10.;

    float t=3.14*0.3;
    t=time*0.3;
    t=mod(t, 3.14);
    vec3 L=vec3(cos(t), -0.5,1.*sin(t));
    L = normalize(vec3(1));
        return vec3(0.25)+
        vec3(1.64, 1.27, 0.99)*7.*vec3(0.2)*phong(normalize(-L),
                            N, rd, 0.2, 0.7)
                            +vec3(1)*phong(vec3(1,0,0), N, rd, 0.2, 0.)
                                +vec3(1)*phong(vec3(0,1,0), N, rd, 0.2, 0.);
}

// Function 1012
float shadowRay(vec3 startP, vec3 lightDir){ // iq soft shadows 
    
    float t = 0.0;
    float shadowHardness = 10.;
    float minD = 1.; // close-by distance 
    
    for (int r = 0; r < 8; ++r){
        
        vec3 p = startP + vec3(t*lightDir.x,t*lightDir.y,t*lightDir.z) + normalize(startP)/shadowHardness; // safe offset
        
        vec3 pp = normalize(p) * sphereBaseRadius;                 
        float sp = sphereBaseRadius + map(pp) * dispValue;
        float d = length(p) - sp;
        
        minD = min(minD,d);        
        if ( d < 0.0){  
       		break;   
        }        
        t += 0.08;
    }    
    return smoothstep(0.,1.0,minD*shadowHardness);
}

// Function 1013
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<50; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, usmoothstep(k*h/t) );
        t += clamp( h, 0.05, 0.2 );
        if( res<0.001 || t>maxt ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1014
vec3 computeShadow(in vec3 iPoint, in vec3 iLightPosition) {
    
    vec3 ray = normalize(iLightPosition - iPoint);
    float d = rayMarchMushrooms(iPoint, ray);
    return vec3(1.0 - 1.0/(1.0 + 0.03*d*d));
    
}

// Function 1015
vec3 getLighting(vec3 color, float nDotL){
	vec3 sunlight = vec3(1.0, 0.6, 0.4);
    vec3 ambientLight = vec3(0.3, 0.5, 1.0);
    
    return color * (sunlight * nDotL + ambientLight);
}

// Function 1016
vec3 accumulateLights(vec2 uv)
{
    int steps = 32;
    vec2 radius = max(vec2(.01), 13.0/iResolution.xy);
    const float goldenAngle = 2.4;    
    
    float depth = UDEPTH(uv*iResolution.xy)*depthScale;
    vec3 baseColor = UBASE_COLOR(uv*iResolution.xy)/hdrScale;
    vec3 camHitNormal = reCalcNormalSlow(uv);
    vec3 camHitPosition = reCalcWorldPosition(uv);
    
    vec2 offsetUv = uv;
    vec3 sum = vec3(0);
    float totalBlur = 0.0;
    float weight = 1.0; 
    float dotProduct = 1.0;
    float brdfRef = 1.0;
    // Counterproductive to apply pixel jitter to low-discrepency points...
    //float seed = nrand(uv*iResolution.xy + vec2(mod(iTime*131.5,4096.0), mod(iTime*535.1,4096.0)));
    float seed = hash11(mod(iTime*33.1, 1024.0));
    mat2 rot = ROT(mod(seed, 2.0*PI));
    
    #ifdef ROUGHNESS_MAP
    	float roughness = saturate(pow(triPlanarMapCatRom(iChannel2, 5.0, camHitNormal, camHitPosition*7.0, iChannelResolution[2].xy), vec3(2.0)).r*2.0);
    #else
    	const float roughness = 0.4;
    #endif
    
    // Start with "correct" GI contribution (i.e. the path that was actually sent for this pixel)
    sum += getVirtualLightContribution(uv+0.0, uv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);
    sum *= brdfRef;
    totalBlur += 1.0;
  
    for(float i = 0.0; i < float(steps); i++)
    {       
        // Rotated Hammersley disc kernel
        //offsetUv = uv + ((hammersleyDisk(int(i), steps)))*radius*rot;	
        // Spiral kernel
        offsetUv = uv + (radius*pow(((i+1.0)/float(steps)), 0.5))*vec2(sin(mod((i+1.0)*goldenAngle+seed, 2.0*PI)), cos(mod((i+1.0)*goldenAngle+seed, 2.0*PI)));

        dotProduct = 1.0;
        vec3 sampledIndirect = getVirtualLightContribution(uv, offsetUv, baseColor, roughness, camHitNormal, camHitPosition, dotProduct, brdfRef);
        float sampledDepth = UDEPTH(floor(offsetUv*iResolution.xy))*depthScale;

        // TODO magic numbers
        weight = 1.0;
        
        // Add hoc occlusion part 1
        #ifdef INDIRECT_GATHER_CHECK_DIRECTION
        	if((dotProduct < 0.7) || distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)
        #else
            if(distance(depth, sampledDepth) > 0.06 || saturate(sampledDepth-depth) > 0.01)
        #endif
        {
            weight = 0.0;
        }
        
        // Ad hoc occlusion part 2
        float curOcclusion = saturate(200000.0*(depth-sampledDepth-0.03));
        weight *= saturate(1.0-curOcclusion);

        sum += brdfRef*sampledIndirect*weight;
        totalBlur += weight;
    }
    
    // Fade into shadow when we don't have good sample coverage
    sum *= smoothstep(1.0, 2.0, totalBlur);
    
    return hdrScale*(baseColor*sum)/totalBlur;
}

// Function 1017
vec3 light(vec3 p, vec3 n){
    vec3 col = vec3(0.01);
    for(int i=0;i<2;i++){
        vec3 ld = (i==0) ? lDir0 : lDir1;
        float diff = max(dot(n, (ld)),0.);
        diff *= getShadow(p, n, ld);
        col += diff * (i==0 ? lCol0 : lCol1);
    }
    return col * .7;
}

// Function 1018
float lightMarch(vec3 sun_dir, vec3 start)
{
    // find dst to edge of sphere
    float lp;
    float dst;
    vec3 p = start;
    float dstThroughCloud = 0.;
    // stepping through the cloud using ray marching to find the distance through the sphere in the direction of the sun
    for (int s = 0; s < 25; s++)
    {
        lp = length(p);
        dst = -(lp - 6.);
        dstThroughCloud += dst;
        p += sun_dir * dst;
    }
    dstThroughCloud = min(dstThroughCloud, 1.25);
    // find total density along ray
    float density;
    p = start;
    float total_density = 0.;
    float step_size = dstThroughCloud / 21.;
    vec3 step_size_v3 = sun_dir * step_size;
    // stepping through the cloud and adding up the density
    for (int s = 0; s < 20; s++)
    {
        p += step_size_v3;
        density = max(SampleNoise(p), 0.) * step_size * 4. * HeightScale(p);
        total_density += density;
    }
    // returning the total desnsity acumulated on the rays journey
    return total_density;
}

// Function 1019
vec3 shade( in float t, in float m, in float v, in vec3 ro, in vec3 rd )
{
    float px = 0.0001;//(2.0/iResolution.y)*(1.0/3.0);
    float eps = px*t;

    vec3  pos = ro + t*rd;
    vec3  nor = calcNormal( pos, eps );
    float occ = calcOcc( pos, nor );

    vec3 col = 0.5 + 0.5*cos( m*vec3(1.4,1.2,1.0) + vec3(0.0,1.0,2.0) );
    col += 0.05*nor;
    col = clamp( col, 0.0, 1.0 );
    col *= 1.0 + 0.5*nor.x;
    col += 0.2*clamp(1.0+dot(rd,nor),0.0,1.0);
    col *= 1.4;
    col *= occ;
    col *= exp( -0.15*t );
    col *= 1.0 - smoothstep( 15.0, 35.0, t );
    
    return col;
}

// Function 1020
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 32; 
    
    ro += n*.002;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), .0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .025, .35); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 1021
LightmapSample decode_lightmap_sample(vec4 encoded)
{
    return LightmapSample(floor(encoded), fract(encoded) * LIGHTMAP_OVERBRIGHT);
}

// Function 1022
float getAO(vec3 rs,vec3 rd)
{
    // move away along the normal
    float d = .3;
    float k = 1.0;
    float ret = 1.0;
    for (int i = 1;i<5;++i) {
        float fi = float(i);
        k *= .5;
        float distBack = scene(rs + rd*(d*fi));
        ret -= k*(fi*d - distBack);
    }
    return ret;
    //return 1.0;
    //return distBack/k;
    //return k/distBack;
}

// Function 1023
float calcAO(in vec3 pos, in vec3 nor) {
    float dd, hr=.01, totao=.0, sca=1.;
    for(int aoi=0; aoi<5; aoi++ ) {
        dd = DE(nor * hr + pos).x;
        totao += -(dd-hr)*sca;
        sca *= .7;
        hr += .05;
    }
    return clamp(1.-4.*totao, 0., 1.);
}

// Function 1024
vec3 shader5(){
	float t=iTime;
	vec2 r =  2.0*vec2(gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;
	vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	vec3 colorFondo = vec3(1.050*p.y,0.8-0.2*p.y*0.5,0.7-0.57*p.y)*(1.05-0.25*length(p)); //cambiar valores vec3 //primer valor de vec3 //segundo valor
	vec3 color1 = vec3(0.78, 0.8, 0.7); // 0.7 mas rosita
	float t2=mod(t,14.0);
 //cambiando el num de radios hace una especie de superposicion, en este caso de 6 parece que salen rayos y vienen hacia tÃ­
	float incrementoAngulo=(2.0/float(7))*PI; //cambiando el angulo salen cosas
	for(int i=0;i<numRadios;i++){
		if(i<(int(clamp(t2,0.0,7.0))-int(t2/7.0)*int(mod(t2,7.0)))){
			float angle=float(i)*incrementoAngulo;
			vec2 q=vec2(0.0,0.0);
			q.x =   cos(angle)*r.x + sin(angle)*r.y;
			q.y = - sin(angle)*r.x + cos(angle)*r.y;
			q=-q;
			colorFondo = mix(colorFondo, color1, lineas2(q) );
		}
	}
	
	float tamanioMax=3.5; //
	float tamanioMin=0.082; //mas pequeÃ±o el corazon
	float escalaHilo=0.15;
	float anchura=(tamanioMax-tamanioMin)/float(numCapas2);
	float grosorHilo=anchura*escalaHilo;
	vec2 posicion=vec2(0.0,0.01);//ajustar el corazon al centro
	for(int i=0;i<numCapas2;i++){
		float tamanioCorazon=tamanioMax-(float(i)*anchura);
		vec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);
		colorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);
	}
	vec2 pos=(2.0*iMouse.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	float escalaMax=1.2;
	corazon(posicion,p,escalaMax-clamp(length(pos),0.0,escalaMax),colorFondo);
	return colorFondo;
}

// Function 1025
vec4 light( in vec3 pos )
{
    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);
    return   (e.zwwz*light_map( pos + e.xyy , iTime) + 
  			  e.wwzz*light_map( pos + e.yyx , iTime) + 
			  e.wzwz*light_map( pos + e.yxy , iTime) + 
              e.zzzz*light_map( pos + e.xxx , iTime) )/vec4(e.xxx, 1.);
}

// Function 1026
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = scene( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 1027
float GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )
{
    #ifdef ENABLE_SHADOWS
		C_Ray shadowRay;
		shadowRay.vDir = vLightDir;
		shadowRay.vOrigin = vPos;
		const float fShadowBias = 0.05;
		shadowRay.fStartDistance = fShadowBias / abs(dot(vLightDir, vNormal));
		shadowRay.fLength = fLightDistance - shadowRay.fStartDistance;
	
		C_HitInfo shadowIntersect;
		Raymarch(shadowRay, shadowIntersect, 32, kNoTransparency);
		
		float fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );
		
		return fShadow;          
    #else
    	return 1.0;
    #endif
}

// Function 1028
float calculateAO( in vec3 p, in vec3 n, float maxDist )
{
	float ao = 0.0, l;
	const float nbIte = 6.0;
	//const float falloff = 0.9;
    for( float i=1.; i< nbIte + .5; i++ ){
    
        l = (i + hash(i))*.5/nbIte*maxDist;
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp( 1.-ao/nbIte, 0., 1.);
}

// Function 1029
vec3 traceLight(ray r, vec3 nml, ray light) {
    vec3 dir = normalize(light.p - r.p);
    vec3 col = vec3(0.0);
    for (int i=0; i<30; i++) {
		float dist = scene(r.p);
		r.p += dist * dir;
		if (length(r.p - light.p) < THRESHOLD*4.0) {
            col = max(0.0, dot(nml, dir)) * max(0.0, dot(-dir, light.d)) * light.light;
            break;
		} else if (dist < THRESHOLD || dist > MAX_DISTANCE) {
            break;
    	}
    }
	return col;
}

// Function 1030
float calcSoftshadow( in vec3 ro, in vec3 rd, float tmax, const float k )
{
    vec2 bound = sphIntersect( ro, rd, 2.15 );
    tmax = min(tmax,bound.y);
    
	float res = 1.0;
    float t = 0.0;
    //float t = max(0.0,bound.x);
    for( int i=0; i<45; i++ )
    {
    	vec4 kk;
		float h = map( ro + rd*t, kk, false );
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1031
float shadow(vec3 ro, vec3 rd,float n)
{
    float res = .5;
    float f=0.1;
    for(int i = 0; i <200; i++)
    {
        float h = map(ro+f*rd).x;
            if(h<0.01)
                return 0.;
               	if(f > n)
           break;
        res = min(res,8.*h/f);
            f+=.25*h;
    }
    return res;
}

// Function 1032
vec3 shade( vec3 pos, vec3 rd, uint matID, uint subMatID, float dis )
{
    if( matID==666u ) return vec3(0.0,0.0,0.0);

    vec3 col = vec3(0.1*dis);

    // calc normal
    vec3 nor = calcNormal( pos );

    // bump mapping
    #if 1
    const float kke = 0.0001;
    float bumpa = 0.0075;
	if( matID!=5u ) bumpa *= 0.75;
    if( matID==4u ) bumpa *= 0.50;
    bumpa /= kke;
    float kk = fbm( 32.0*pos );
    nor.x += bumpa*(fbm( 32.0*vec3(pos.x+kke, pos.y, pos.z) )-kk);
    nor.y += bumpa*(fbm( 32.0*vec3(pos.x, pos.y+kke, pos.z) )-kk);
    nor.z += bumpa*(fbm( 32.0*vec3(pos.x, pos.y, pos.z+kke) )-kk);
    nor = normalize(nor);
    #endif


    // light
	float spe = 0.0;
    vec3 lig = vec3( 0.5, 0.8, 1.5 ) - pos;
    float llig = dot2(lig);
    float im = 1.0/sqrt(llig);
    lig *= im;
    float dif = dot( nor, lig ); 
    if( matID==4u )
        dif = 0.5+0.5*dif;
    else
        dif = 0.10+0.90*dif;
    dif = max( dif, 0.0 );
	dif *= 2.5*exp2( -1.75*llig );
	float dif2 = (nor.x+nor.y)*0.075;

    // materials
    if( matID==0u )
    {
        float xoff = 13.1 * float(subMatID&255u);
        float fb = fbm( 16.0*vec3(pos.x+xoff, pos.y, pos.z) );

        col = 0.7 + vec3(0.20,0.22,0.25)*fb;

        float baldscale = float((subMatID>>9)&15u)/14.0;
        baldscale = 0.51 + 0.34*baldscale;
        col *= baldscale;
        float fx = 1.0;
        if( (subMatID&256u)!=0u ) fx = -1.0;
        float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );
        m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );

        col += m*0.15;
    }
    else if( matID==2u )
    {
        col = vec3(0.0,0.0,0.0);
    }
    else if( matID==1u )
    {
        float fb = fbm( 16.0*pos );
        float m = sin( 64.0*pos.z +  64.0*pos.x + 4.0*fb );
        m = smoothstep( 0.3, 0.5, m ) - smoothstep( 0.5, 0.7, m );
        col = 0.59 + fb*vec3(0.17,0.18,0.21) + m*0.15 + dif2;
    }   
    else if( matID==4u )
    {
        float ft = fbm( 16.0*pos );
        col = vec3(0.82,0.73,0.65) + ft*vec3(0.10,0.10,0.15);
        float fs = 0.90+0.10*fbm( 32.0*pos );
        col *= fs;

        float fre = -dot( nor, rd );
        if( fre<0.0 ) fre=0.0;
        fre = fre*fre*0.45;
        col -= fre;

		spe = (nor.y-nor.z)*0.707;
        spe = spe*spe;
        spe = spe*spe;
        spe = spe*spe;
        spe = spe*spe;
        spe = spe*spe;
        spe *= 0.20;
     }   
    // techo
    else //if( matID==5 )
    {
        float fb = fbm( 16.0*pos );
        col = vec3(0.64,0.61,0.59) + fb*vec3(0.21,0.19,0.19) + dif2;
    }   

    // AO
    float ao;
    #if 1
    float totao = 0.0;
    float sca = 10.0;
    for( int aoi=ZERO; aoi<5; aoi++ )
    {
        float hr = 0.01 + 0.015*float(aoi*aoi);
        vec3 aopos = pos + hr*nor;
        uint kk, kk2;
        float dd = map( aopos, kk, kk2 );
        ao = -(dd-hr);
        totao += ao*sca;
        sca *= 0.5;
        //if( totao>1000.0+sin(iTime) ) break;
    }
    ao = 1.0 - clamp( totao, 0.0, 1.0 );
    #else
    ao = 1.0;
    #endif

    // shadow
    #if 1
    float so = 0.0;
	for( int i=ZERO; i<6; i++ )
    {
		float h = float(i)/6.0;
        float hr = 0.01 + 1.0*h;
        vec3 aopos = pos + hr*lig;
        uint kk, kk2;
        float dd = map( aopos, kk, kk2 );
        so += (1.0-h)*dd*20.0/6.0;
        //if( so>1000.0+iTime ) break;
    }
    dif *= clamp( (so-0.40)*1.5, 0.0, 1.0 );
    #endif

    // shade
	float ao2 = 0.05 + 0.95*ao;
    col *= vec3(0.25,0.30,0.35)*ao + dif*ao2*vec3(1.95,1.65,1.05);
    col += spe;
    col *= exp2( -0.40*pos.z );

    return col;
}

// Function 1033
float DistanceFieldNoLights( vec3 pos )
{
	return min( min(
			Foliage( pos ),
			Water( pos ) ),
			Solid( pos )
		);
}

// Function 1034
float calculateShadow(in vec3 pos)
{
    vec3 n = normalize(lightPosition.xyz - pos * lightPosition.w);
    vec3 u = perpendicularVector(n);
	vec3 v = cross(u, n);
    vec3 dir = n;
    
    float result = 0.0;
    for (int s = 0; s < SHADOW_SAMPLES; ++s)
    {
        dir = randomDirection(n, u, v, 0.02, dir + pos + result);
	    for (int i = 0; i < NumSpheres; ++i)
        {
    	    result += float(calculateSphereIntersection(pos, dir, spheres[i]) > 0.0);
        }
    }
    
    return 1.0 - result / float(SHADOW_SAMPLES);
}

// Function 1035
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{
	float res = 1.0;
	float t = 0.001;
	for( int i=ZERO; i<50; i++ )
	{
		float h = map(ro + rd*t ).x;
		res = min( res, smoothstep(0.0,1.0,1.4*k*(h+0.0015)/sqrt(t)) );
		t += clamp( h, 0.003, 0.1 );
		if( res<0.001 || t>0.8) break;
	}
	return clamp(res,0.0,1.0);
}

// Function 1036
float aoDist(vec3 o, vec3 center, vec3 norm)
{
    vec3 trash;
    o += norm / 5.;
    
    float best = 0.;
    vec3 r;
    
    for (int i = 0; i < 3; ++i)
    {
        // these two lines are equivalent to:
        //   vec3 p = Fv(i)
        //   vec3 q = p;
        // for cubes. This form is for truncated octohedrons.
        // I'm not sure if this generalizes to any other space-filling
        // polyhedra or not.
        //
        // Either way, it looks horrible. Don't do this.
        vec3 p = normalize(Fv(i));
        vec3 q = p - norm * dot(norm, p);
        
        if (dot(o - center, q) > best && dot(norm, p) < 0.95)
        {
            r = q;
            best = dot(o - center, q);
        }
        
        q = -q;
        if (dot(o - center, q) > best && dot(norm, p) < 0.95)
        {
            r = q;
            best = dot(o - center, q);
        }
    }
    
    return traceTruncOct(o, normalize(r), trash, trash, 1);
}

// Function 1037
vec4 sunLight(vec3 pos) {
	vec3 lightCol = vec3(1.0,0.8, 0.5*(cos(TIME) + 1.0));

	float music = drum;
	float mdis = sdSphere(pos - vec3(0.0,0.0,0.5*sin(10.0*TIME)), 0.8 + 0.8 * music);


	float distanceToL = max(0.0001, mdis);
	vec3 point = lightCol * (80.0 + 80.0 * music)/(distanceToL*distanceToL);

	return vec4(point, distanceToL);
}

// Function 1038
float calcAO_o349467( in vec3 pos, in vec3 nor ){
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ ){
        float h = 0.001 + 0.25*float(i)/4.0;
        float d = input_o349467( pos + h*nor ).x;
        occ += (h-d)*sca;
        sca *= 0.98;
    }
    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    
}

// Function 1039
vec2 ShaderBall(vec3 p)
{
    vec3 spos = p - vec3(0.0, 1.5, 0.0);
    
    vec2 ts   = vec2(max(Sphere(spos, 1.0), -Sphere(spos, 0.8)), 9.0);                // Hollow top sphere
    vec2 tsi  = vec2(Sphere(spos, 0.725), 2.0);                                       // Inner sphere core
    vec2 tsc  = vec2(Sphere(spos - vec3(0.0, 0.4, 0.8), 0.55), 3.0);                  // Cut into side of top sphere
    vec2 rc   = vec2(Box(RotX(spos, PI * 0.15), vec3(2.0, 0.05, 2.0)), 4.0);          // Ring cut into top sphere
    
    vec2 st   = vec2(Cylinder(p - vec3(0.0, 0.1, 0.0), vec2(mix(0.8, 0.3, clamp(p.y - 0.125, 0.0, 1.0)), 0.2)), 5.0);    // Stand wide base      
    vec2 stc  = vec2(Cylinder(Repeat(p, vec3(0.5, 0.0, 0.5)), vec2(0.125, 1.0)), 6.0);                                   // Stand ridge cuts
    vec2 stm  = vec2(Cylinder(p - vec3(0.0, 0.35, 0.0), vec2(0.5, 0.35)), 5.0);       // Thinner stand middle
    
    st   = S(st, stc);
    st.x = smin(st.x, stm.x, 0.2);                         
    
    vec2 b    = vec2(Cylinder(p - vec3(0.0, 0.025, 0.0), vec2(1.0, 0.05)), 8.0);      // Base
       
    vec2 result = S(ts, tsc);
         result = S(result, rc);
         result = U(result, tsi);
         result = U(result, st);
         result = U(result, b);
    
    return result;
}

// Function 1040
vec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {
    vec3 sd = rp+normal2(rp-rd*EPSILON*5.)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;
    
    //lighting
    vec3 dlc = vec3(0.);
    
    vec3 slc = vec3(0.);
    vec3 reflDir = reflect(rd,norm);
    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);
    tReflDir *= sign(dot(tReflDir,reflDir));
    
    #ifdef REFLECTIONS
    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);
    if (rtd < 0.) {
        slc = background(tReflDir);
    } else {
        vec3 rhp = sd+tReflDir*rtd;
        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));
    }
    #endif
    
    vec3 lightDif,lightSpec;
    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);
    dlc += lightDif;
    slc += lightSpec;
    
    float fres = 1.-max(0., dot(-rd,norm));
    
    return (1.-m.metallic)*dlc*m.diffuse +
        	slc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +
        	m.emissive ;
}

// Function 1041
vec3 shadeDistance(float d) {
    float dist = d*150.0;
    float banding = max(sin(dist), 0.0);
    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));
    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);
    
    vec3 color = vec3(pattern);
    
    if (d > 0.0) {
        //red tint
        color *= vec3(1.0,0.56,0.4);
    } else {
        //blue tint
        color *= vec3(0.4,0.9,1.0);
        
    }
    return color;
}

// Function 1042
float calcAO( in vec3 pos, in vec3 nor )
{
	float totao = 0.0;
    float sca = 1.0;
    for( int aoi=0; aoi<5; aoi++ )
    {
        float hr = 0.01 + 0.05*float(aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.75;
    }
    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
}

// Function 1043
vec3 shade(vec3 albedo, vec3 n, vec3 pos, vec3 dir, float ks, bool shadows) {
    float shadow = shadows ? shadowray(pos) : 1.0;
    float light_diffuse = clamp(dot(n, -LIGHT_DIR), 0.0, 1.0);
    vec3 light_half = normalize(-LIGHT_DIR - dir);
    float sky = sqrt(clamp(0.5 + 0.5 * n.y, 0.0, 1.0));
    vec3 ref = reflect(dir, n);
    float frenel = clamp(1.0 + dot(n, dir), 0.0, 1.0);
    float indirect = clamp(dot(n, INDIRECT_DIR), 0.0, 1.0);
    
    vec3 light = vec3(0.0);
    light += light_diffuse * LIGHT * shadow;
    light += sky * SKY;
    light += indirect * INDIRECT;
    vec3 col = light * albedo;
    col += ks * smoothstep(0.0, 0.5, ref.y) * (0.04 + 0.96 * pow(frenel, 4.0)) * SKY;
	col += shadow * ks * pow(clamp(dot(n, light_half), 0.0, 1.0), 8.0) * light_diffuse * (0.04 + 0.96 * pow(clamp(1.0 + dot(light_half, dir), 0.0, 1.0), 3.0)) * LIGHT * 5.0;
	return col;
}

// Function 1044
float softshadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.001;
	float h = 1.0;
	vec4 kk;
    for( int i=0; i<25; i++ )
    {
        h = map(ro + rd*t,kk);
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        if( res<0.001 ) break;
		t += clamp( h, 0.02, 2.0 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1045
bool inShadow(vec3 ro,vec3 rd,float d)
{
	float t;
	bool ret = false;

	if(intersectSphere(ro,rd,spheres[2],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[3],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[4],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[5],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[6],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[7],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[8],d,t)){ ret = true; }

	return ret;
}

// Function 1046
float terrainCalcShadow(in vec3 ro, in vec3 rd ) {
	vec2  eps = vec2(150.0,0.0);
    float h1 = terrainMed( ro.xz );
    float h2 = terrainLow( ro.xz );
    
    float d1 = 10.0;
    float d2 = 80.0;
    float d3 = 200.0;
    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );
    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );
    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );

    return min(min(s1,s2),s3);
}

// Function 1047
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res =1., t = 0.0, h=0.;
  vec3 rayPos = vec3(origin+direction*t);    
  #ifdef HIGH_QUALITY
    for ( int i=0; i<30+min(0, iFrame); i++ )
  {
    h = MapPlanet(rayPos).x;
    #ifdef HIGH_QUALITY_BELT
    h = min(h, MapRocks(rayPos));
    #endif
      
    res = min( res, 3.5*h/t );
    t += clamp( h, 0.01, 250.1);
    if ( h<0.005 ) break;
    rayPos = vec3(origin+direction*t);
  }
  #else
    for ( int i=0; i<10+min(0, iFrame); i++ )
    {
      h = MapPlanet(rayPos).x;
      res = min( res, 8.5*h/t );
      t += clamp( h, 0.01, 100.1);
      if ( h<0.005 ) break;
      rayPos = vec3(origin+direction*t);
    }
  #endif


    return clamp( res, 0.0, 1.0 );
}

// Function 1048
float shadowMap (vec3 ro, vec3 nor, Celestial o) {
	
	// Light data
	float lRad = sun.radius;
	vec3 lDir = sun.origin - ro;
	float lDis = length(lDir);
	lDir = normalize(lDir);
	
	// Occluder data
	float oRad = o.radius;
	vec3 oDir = o.origin - ro;
	float oDis = length(oDir);
	oDir = normalize(oDir);
	
	// Determine light visible "around" the occluder
	float l = lDis * ( length(cross(lDir, oDir)) - (oRad / oDis) );
	l = smoothstep(-1.0, 1.0, -l / lRad);
    l *= smoothstep(0.0, 0.2, dot(lDir, oDir));
	l *= smoothstep(0.0, oRad, lDis - oDis);
	
	// Return a multiplier representing our softshadow
	return 1.0-l;
}

// Function 1049
void MarchLight(inout Ray r, float startTime, float maxDist
){float totalDist = 0.0
 ;vec3 origin = r.b
 ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++
 ){r.time = startTime
  ;SetTime(r.time)
  ;r.dist = map(r.b,-1)
  ;totalDist += r.dist
  ;r.b+= r.dir*(r.dist)
  ;if(abs(r.dist)<rayEps||totalDist>maxDist)break;}}

// Function 1050
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<48; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
		t += clamp( h, 0.025, 1.0 );
		if( h<0.001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1051
float shadow(vec3 o, vec3 d){
    o += norm(o) * 0.001;
	float len = 0.0, lev = 1.0;
	for(float t = 0.0; t < 32.0; t++){
		float di = dist(o + d * len);
		if (di < 0.001){ return 0.5;}
		lev = min(lev, di  * 24.0 / min(len, 1.0));
		len += di;
	}
	return max(0.5, lev) ;
}

// Function 1052
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = VAR_ZERO; j < 50; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.4 + 0.6 * sh;
}

// Function 1053
float CalcShadow(in vec3 ro, in vec3 rd, in float maxT){
    float res = 1.0;
    float t = 0.01;
    float ph = 1e10;
    
    for(int i = 0; i < NUM_SHADOW_STEPS; ++i){
        float h = GetDist(rd * t + ro).d;
        
        if(h < SURFACE_DIST)return 0.;
        
        float y = h*h/(2.*ph);
        float d = sqrt(h*h-y*y);
        res = min(res, 5.*d/max(0.,t-y));
        ph = h;
        
        t += h*0.95;
        
        if(res < SURFACE_DIST || t >= maxT) break;
    }
    
    return saturate(res);
}

// Function 1054
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 20; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.05;    
    float end = max(length(rd), 0.001);
    //float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.
        dist += clamp(h, 0.01, 0.2);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.
    return min(max(shade, 0.) + 0.2, 1.0); 
}

// Function 1055
float shadow( in vec3 start, in vec3 ldir, in float md, in float p )
{    
	float t = EPSILON*4.0;
	float res = 1.0;
    for ( int i = 0; i < S_STEPS; ++i )
    {        
        float d = sDist( start + ldir * t );
        if ( d < EPSILON )
            return 0.0;
		
		res = min( res, p * d / t );
        t += d*.25;
		
		if ( t > md)
			break;
    }
    return res;
}

// Function 1056
float sphShadow( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    return step( min( -b, min( c, b*b - c ) ), 0.0 );
}

// Function 1057
vec3 sampleLight(vec3 v)
{
    return texture (iChannel1, v).rgb;
}

// Function 1058
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map2( ro + rd*t ).d;
        res = min( res, 5.0*h/t );
        t += clamp( h, 0.02, 0.2 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.2, 1.0 );
}

// Function 1059
vec3 getLightPosition(int i){

    #ifdef ANIMATE_LIGHTS
        float offset = 2.8+0.45*iTime;
    #else
        float offset = 2.8;
    #endif

    if(i == 0){
        return vec3(30.0*cos(offset), 4.0, 30.0*sin(offset)); 
    }
    return vec3(-2.0*cos(2.0*offset), 12.0,  -2.0*sin(2.0*offset));
}

// Function 1060
vec3 addLighting(vec3 view, vec3 normal, Light[lightCount] lights, float depth)
{
    vec3 color;
    float diffuse;
    float subSurface;
    // for each light
    for(int n = 0; n < lightCount; n++)
    {
        Light light = lights[n];
        // diffuse
        float on = 1.0 * orenNayar(normal, light, view);
        diffuse += on;
        // specular
        color += 10.5 * cookTorrance(view, normal, light);
        // subsurface scattering
        subSurface += sss(light, on);
    }
    // stylized diffuse shading
    color = mix(cividisGooch(diffuse), color, 0.25);
    // ochre is one of the oldest used pigments in art
    // see: https://en.wikipedia.org/wiki/Ochre#Historical_use_in_art_and_culture
    const vec3 ochre = vec3(204.0 / 255.0, 119.0 / 255.0, 34.0 / 255.0);
    color = mix(5.5 * subSurface * ochre, color, depth);
        
    return color;
}

// Function 1061
vec3 lighting(in Trace trace){
    vec3 color = vec3(0.01,0.01,0.2);//ambient color     
	color += pointLighting(trace, light1);
	color += pointLighting(trace, light2) ;

    return color;
}

// Function 1062
float ObjSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  vec2 gIdP;
  float sh, d, h;
  sh = 1.;
  d = 0.03;
  gIdP = vec2 (-99.);
  for (int j = 0; j < 30; j ++) {
    p = ro + d * rd;
    gId = PixToHex (p.xz / hgSize);
    if (gId.x != gIdP.x || gId.y != gIdP.y) {
      gIdP = gId;
      SetObjConf ();
    }
    h = ObjDf (p);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += clamp (h, 0.05, 0.5);
    if (sh < 0.05) break;
  }
  return 0.7 + 0.3 * sh;
}

// Function 1063
vec4 light(int index, in float luma){
	float x = mod(float(index),COL)-(HCOL);
	float y = floor(float(index)/COL);
    x*=LED_SZ * 2.0f;;
    y*=LED_SZ * 2.0f;
    y+=LED_SZ;
    
    float led = 2.0f * tullynoise(vec2(x + SEED,y) / vec2(COL,ROW)) * (LED_SZ + luma * LED_SZ);
    
    return vec4(x-led,x+led,y+led,y-led);
}

// Function 1064
void sampleAreaLight(in vec2 uv, out vec3 lightPosition, out vec3 lightIntensity)
{
    vec3 normal = transpose(getRotation()) * AreaLightNormal;
    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    vec3 bitangent = normalize(cross(normal, tangent));
    float u = (0.5 - uv.x) * AreaLightSize.x * 2.0;
    float v = (uv.y - 0.5) * AreaLightSize.y * 2.0;
    lightPosition = AreaLightPosition + u * tangent + v * bitangent;
    lightIntensity = getLightIntensity(lightPosition);  
}

// Function 1065
float shadow(vec3 ro, vec3 rd){
    float t = 0.01;
    float d = 0.0;
    float shadow = 1.0;
    for(int iter = 0; iter < 256; iter++){
        d = map(ro + rd * t);
        if(d < 0.0001){
            return 0.0;
        }
        if(t > length(ro - lightPos) - 0.5){
            break;
        }
        shadow = min(shadow, 128.0 * d / t);
        t += d;
    }
    return shadow;
}

// Function 1066
float pointLightDiffuse(vec3 pos, vec3 nor, vec3 lpos, vec3 func) {
    vec3 ldir = normalize(pos - lpos);
    float dist = length(pos - lpos);
    float atten = min(1.0/dot(func, vec3(1, dist, dist*dist)), 1.0);
    return atten * clamp(dot(nor, -ldir), 0.0, 1.0);
}

// Function 1067
float sphAreaShadow( vec3 P, in vec4 L, vec4 sph )
{
  vec3 ld = L.xyz - P;
  vec3 oc = sph.xyz - P;
  float r = sph.w - BIAS;
  
  float d1 = sqrt(dot(ld, ld));
  float d2 = sqrt(dot(oc, oc));
  
  if (d1 - L.w / 2. < d2 - r) return 1.;
  
  float ls1 = L.w / d1;
  float ls2 = r / d2;

  float in1 = sqrt(1.0 - ls1 * ls1);
  float in2 = sqrt(1.0 - ls2 * ls2);
  
  if (in1 * d1 < in2 * d2) return 1.;
  
  vec3 v1 = ld / d1;
  vec3 v2 = oc / d2;
  float ilm = dot(v1, v2);
  
  if (ilm < in1 * in2 - ls1 * ls2) return 1.0;
  
  float g = length( cross(v1, v2) );
  
  float th = clamp((in2 - in1 * ilm) * (d1 / L.w) / g, -1.0, 1.0);
  float ph = clamp((in1 - in2 * ilm) * (d2 / r) / g, -1.0, 1.0);
  
  float sh = acos(th) - th * sqrt(1.0 - th * th) 
           + (acos(ph) - ph * sqrt(1.0 - ph * ph))
           * ilm * ls2 * ls2 / (ls1 * ls1);
  
  return 1.0 - sh / PI;
}

// Function 1068
float calculateAO(in vec3 p, in vec3 n)
{
	float sca = 2., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 1069
vec3 Shade(in vec3 p, in vec3 p0, in vec3 v, in vec3 n, in vec3 l, in vec2 c) {
    vec3 col = color(c);
    vec2 lc = vec2(max(0.0, dot(n,l))*0.9, 1.0);
    
    if (length(p - p0) < 0.01) return 3.0*col*(lc.x + lc.y)*0.5;
    
    vec2 sa = ShadowAndAmbient(p + n*0.02, l);
   	lc *= sa;
    return col*(lc.x + lc.y);
}

// Function 1070
vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sp) {
 
    vec3 d = vec3(0.);
    vec3 s = vec3(0.);
    
    for(int i = 0; i < 2; i++) {

        vec3 lv = i == 0 ? LIGHT_DIR : getPointLightVector(p);
        vec3 ld = normalize(lv);
        
        float diff = max(dot(ld,n),0.);
    	float spec = 0.;
    
    	diff *= softshadow(p, ld, SHADOW_BIAS, MAX_DISTANCE, 128.);
    	if(i == 1)
            diff *= 1.-smoothstep(2.,10.,length(lv));
            
    	if(diff > 0. && sp > 0.)
        	spec = pow(max(dot(ld,r),0.), sp);
    
        vec3 lc = i == 0 ? LIGHT_COL : POINT_COL;
    	d += (col*lc*(LIGHT_AMB+diff));
        s += (lc*spec);
        
    }
    
    return (col*d)+s;
    
}

// Function 1071
vec3 CalculateLightingIBL(in vec3 n, in vec3 v, in vec3 a, in float r, in float m)
{
    vec3 f0 = mix(vec3(0.04), a, m);
    vec3 ks = vec3(0.0);
    vec3 d  = CalcDiffuse(a);
    vec3 s  = CalcSpecularIBL(n, v, f0, ks, r);
    vec3 kd = (1.0 - ks);
    
    return ((kd * d) + s);
}

// Function 1072
void CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, 
                    out vec3 ro, out vec3 rd, out mat3 t) 
{
    float a = 1.0/max(iResolution.x, iResolution.y);
    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));
 
    ro = vec3(0.0, 0.0, -d);
    
    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));
    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));
    m.y = -m.y;
    m.y = sin(m.y*0.5)*0.6 + 0.6;
        
    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));
    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));
    
    t = rotY * rotX;
    
    ro = t * ro;
    ro = c + ro;

    rd = t * rd;
    
    rd = normalize(rd);
}

// Function 1073
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0, dd;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
	    if( SCENE_MODE == 0 ) {
			dd = map_0( aopos ).x;
    	} else if( SCENE_MODE == 1 ) {
			dd = map_1( aopos ).x;
    	} else if( SCENE_MODE == 2 ) {
			dd = map_2( aopos ).x;
   		} else if( SCENE_MODE == 3 ) {
			dd = map_3( aopos ).x;
   		} else if( SCENE_MODE == 4 ) {
			dd = map_4( aopos ).x;
   		} else if( SCENE_MODE == 5 ) {
			dd = map_5( aopos ).x;
   		} else if( SCENE_MODE == 6 ) {
			dd = map_6( aopos ).x;
   		}
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1074
vec3 phongContribForLight(vec3 N, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity)
{
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    float shadow = shadowMarch(p + N * 0.1, L, lightPos);
    dotLN *= shadow;
    
    if (dotLN < 0.0)
    {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0)
    {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    vec3 col =  lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
    
    return col;
}

// Function 1075
vec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, 
                    in Material_t mat, in Light_t light )
{
    if ( inShadow ) {
        return light.I_a * mat.k_a;
    }
    else {
        vec3 R = reflect( -L, N );
        float N_dot_L = max( 0.0, dot( N, L ) );
        float R_dot_V = max( 0.0, dot( R, V ) );
        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );

        return light.I_a * mat.k_a + 
               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);
    }
}

// Function 1076
float shade(vec3 n, vec3 rd)
{
    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);
}

// Function 1077
float calcAO( in vec4 pos, in vec4 nor ){
	float dd, hr, totao = 0.0;
    float sca = 1.0;
    vec4 aopos; 
    for( int aoi=0; aoi<5; aoi++ ) {
        hr = 0.01 + 0.05*float(aoi);
        aopos =  nor * hr + pos;
        totao += -(map( aopos ).x-hr)*sca;
        sca *= 0.75;
    }
    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
}

// Function 1078
float calc_shadow(in vec3 pos, in vec3 rdir, in float max_dist)
{
	vec3 p = pos + rdir * 2.0 * T;
	float d = 0.0;
	float dist = max_dist;
	int oid;

	while(d < max_dist && dist > T) {
		d += STEP;
		p = p + rdir * STEP;
		dist = calc_dist(p, oid);
	}

	return dist <= T ? 0.0 : 1.0;
}

// Function 1079
float shadeTrace (vec3 o, vec3 r, int pen, float maxT){ 

    float exp = 1.;

    vec3 newpoint;
    float t = 0.5;

    float d;

    int i;
    for (t=0.05; t < maxT; i++ ) {                  // <-- trace iterator

        //break;
         newpoint = o + r * t;
        //o = lerpDotSpace(o,iDotSlide);

        //if (t>MAXD) break;
        d = map(newpoint);        
        if (d < 0.00001 ||  i >= SHADN){exp = 0.; break; }
        
        //t += d * 0.2 *iMarchFactor;
        t += d;

        exp = min(exp,d*(float(pen))/t);
    }
return exp;
}

// Function 1080
function SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new Float32Array(x));}

// Function 1081
float shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)
{
	float light_visibility = 1.;
	float ph = 1e5;
	pos.w = map(pos.xyz, co);
	int i = min(0, iFrame);
	for (; i < shadow_steps; i++) {
	
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = map(pos.xyz, co);
		
		float y = pos.w*pos.w/(2.0*ph);
        float d = (pos.w+ph)*0.5;
		float angle = d/(max(0.00001,dir.w-y)*light_angle);
		
        light_visibility = min(light_visibility, angle);
		
		ph = pos.w;
		
		if(dir.w >= distance2light)
		{
			break;
		}
		
		if(dir.w > maxd || pos.w < max(mind*dir.w, 0.0001))
		{
			return 0.;
		}
	}
	
	if(i >= shadow_steps)
	{
		light_visibility=0.;
	}
	//return light_visibility; //bad
	light_visibility = clamp(2.*light_visibility - 1.,-1.,1.);
	return  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)
}

// Function 1082
float softShadow(vec3 dir, vec3 origin, float min_t, float k) {
    float res = 1.0;
    float t = min_t;
    for(int i = 0; i < RAY_STEPS; ++i) {
        float m = shadowMap3D(origin + t * dir);
        if(m < 0.0001) {
            return 0.0;
        }
        res = min(res, k * m / t);
        t += m;
    }
    return res;
}

// Function 1083
vec3 lightWave(vec3 ro, vec3 rd, float d)
{
    vec3 p = ro + rd * d; // hit point on plane
    float sh = wave(p) - .5*waveHeight; //.25; // wave height variation
    p.xz += 2. * sh * rd.xz; // bump offset, parallax mapping - subtle
    sh = wave(p) - .5*waveHeight; //.25; // reeval height after bump offset
	vec3 n = normWave(p) // surface normal
	, l1 = normalize(vec3(1)); // main parallel light ('sun')
	float nv = dot(rd, n)
	, spc = pow(max(0., dot(reflect(l1, n), rd)), 30.) // sun specular
    , eta = 1.003/1.3 // air vs. water
    , waterdepth = 4.; //+ sh
    vec3 rfd = refract(rd, n, eta);  // refract view direction
    float depthest = -waterdepth / rfd.y; // water depth estimate along refracted path
	vec3 ref = texture(iChannel0, reflect(rd, n)).rgb // reflection environment cubemap
    , rfa = texture(iChannel1, (p + rfd*depthest).xz / 6.).rgb; // regular refraction
    // HACK the original just did everything in srgb gamma
    // which is not correct, but it's really hard to match
    // the look without doing basically the same thing.
	// gave up on good gamma correction until I can
    // match the look better somehow.
     //   ref = pow(ref, vec3(2.2));
     //   rfa = pow(rfa, vec3(2.2));
    ref *= .5;
    rfa *= exp2(-.125 * depthest); // extinct by water depth estimate
    vec3 c;
//    c = n * .5 + .5; // DEBUG normal
//    c = vec3(sh * 1.5 + .5); // DEBUG height
//    c = vec3(exp2(-.2*d)); // DEBUG depth
//    c = vec3(spc); // DEBUG spec only
//    c = ref; // DEBUG just envmap reflection
//    c = rfa; // DEBUG just refraction
//    c = spc + rfa; // DEBUG just spec + refraction
//    c = pow(c, vec3(1./2.2)); // HACK fix gamma - temp - for debugging
	c = rfa + ref + spc; // sum all light - in wrong gamma
    return c;
}

// Function 1084
vec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir, in float d,in vec3 sky)
{
	float h = dot(sunLight,normal);
	mat = mat * sunColour*(max(h, 0.0));
	mat += vec3(0.01, .01,.02) * max(normal.y, 0.0);
    normal = reflect(eyeDir, normal);
    mat += pow(max(dot(sunLight, normal), 0.0), 50.0)  * sunColour * .5;
    mat = mix(sky,mat, min(exp(-d*d*.000002), 1.0));
	return mat;
}

// Function 1085
vec3 lightLeaves(vec3 p, vec3 n)
{
	float s = 1.0;
	
	#ifdef SHADOWS
	s = shadow(p-sunDir*0.01, -sunDir);
	#endif
	
	float ao = min(length(p - leavesPos) * 0.1, 1.0);
	
	float ns = dot(n, sunDir);
	float d = sqrt(max(ns, 0.0));
	vec3 col = sunCol * min(d, s);
	col += sunCol * max(-ns, 0.0) * vec3(0.3, 0.3, 0.1) * ao;
	col += skyCol * (-n.y * 0.5 + 0.5) * 0.3 * ao;
	return col;
}

// Function 1086
vec3 calculate_light_transmittance(vec3 position, vec3 light_direction, as_data atmosphere)
{
    // Calculate the step size of the secondary (light) ray.
    float step_size = rsi(position, light_direction, atmosphere.rAtmos).y / float(AS_JSTEPS);

    // Ray increment
    vec3 ray_increment = light_direction * step_size;

    // Initial ray position (we start from the centre)
    vec3 ray_position = position + ray_increment * 0.5;

    // Initialize transmittance accumulators for the secondary (light) ray.
    vec3 transmittance = vec3(1.0);
    
    // Sample the secondary ray.
    for (int i = 0; i < AS_JSTEPS; i++) 
    {
        // Calculate the height of the sample.
        float height = length(ray_position) - atmosphere.rPlanet;

        // Get densities.
        vec3 density = get_densities(height, atmosphere);
        
        // Calculate transmittance.
        transmittance *= exp(-atmosphere.kExtinction * density * step_size);

        // Increment the secondary ray time.
        ray_position += ray_increment;
    }
    return transmittance;
}

// Function 1087
vec3 calculateLight(vec3 samplePos, vec3 lightPos, vec3 lightColor, float lightStr)
{
        float sampleLight = lightMarch (samplePos, lightPos);
        float distToLight = length(lightPos-samplePos)+1.;
        vec3 light = lightColor * lightStr * (1./(distToLight*distToLight)) * sampleLight;

    	return light;
}

// Function 1088
vec3 spotlight(vec3 Lpos, vec3 Lspot, vec3 hitPoint, float spotAngle, vec3 albedo, vec3 N, vec3 V)
{
    Lpos += (floatRand3()-vec3(0.5)) * 0.02;
    const float SMAX_S = 0.6;
    const float SSTEPSIZE = 0.009;
    vec3 Ldelta = Lpos - hitPoint;
    float Llen = length(Ldelta);
    vec3 L = Ldelta/Llen;
    vec3 H = normalize(V + L);
    float VoH = saturate(dot(V, H));
    float NoV = abs(dot(N, V)) + 1e-5;
    float NoH = saturate(dot(N, H));
    float NoL = saturate(dot(N, L));    
    float att = max(0.0, smoothstep(spotAngle, 1.0-0.5*(1.0-spotAngle), dot(L, -Lspot)) / (Llen*Llen));
    float rough = 0.8*albedo.r;
    float F = F_Schlick(0.035, NoV);
    vec3 lightCon = NoL*(albedo*Burley(rough, NoV, NoL, VoH) + SmithJoint(rough, NoV, NoL)*GGX(rough, NoH)*F);
    vec3 subS = vec3(0.0);
    float s = 0.008+floatRand() * SSTEPSIZE;
    for(; s < SMAX_S; s+=SSTEPSIZE)
    {
        vec3 tP = hitPoint + s*L;
        vec3 tPUV = tP / VOL_DIMS;
        vec4 dRead = textureLod(iChannel0, tPUV.xy+ (floatRand2()-vec2(0.5)) * 0.0, 0.0);
        if(dRead.w > tPUV.z && dRead.w > MAX_Z && dRead.z < tPUV.z && tPUV.xy == saturate(tPUV.xy))
        {
            lightCon = vec3(-1.0);
            subS = vec3(0.0);
        }
        else if(lightCon == vec3(-1.0) && subS == vec3(0.0))
        {
            vec3 incNormal = oct_to_float32x3(dRead.xy);
            subS = 0.7*vec3(0.17, 0.03, 0.01) * exp(-650.0*s*s) * saturate(0.5+0.5*dot(incNormal, L)) * exp(-max(0.0, -100.0*tP.z));
        }
    }
    return att * (max(vec3(0.0), lightCon) + subS * albedo);
}

// Function 1089
vec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)
{   
    // ambient
    vec3 pixelColor = diffuse * LIGHT_AMBIENT;
    
    // see if we are in shadow by casting in the light direction and seeing if we hit the object.
    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.
    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)
        return pixelColor;
    
    // diffuse
    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);
    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;
    
    // specular highlight
    if (specPower > 0.0)
    {
    	vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);
    	dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
		pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    
    }
    
    return pixelColor;
}

// Function 1090
float trunkShadow(vec3 rayPos, vec3 rayDir)
{
	// Soft shadow taken from iq
	float k = 6.0;
	float t = 0.0;
	float s = 1.0;	
	for (int i = 0; i < 30; i++)
	{
		vec3 pos = rayPos+rayDir*t;	
		vec2 res = scene(pos);		
		if (res.x < 0.001) return 0.0;
		s = min(s, k*res.x/t); 
		t += max(res.x, 0.01);
	}
	
	return s*s*(3.0 - 2.0*s);
}

// Function 1091
SPointLight lightPoint1()
{
	return SPointLight
	(
		vec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),
		vec3(0.7,0.3,0.7)
	);
}

// Function 1092
float shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<10; i++ )
    {
		float h = map(ro + rd*t);
        res = min( res, 4.*h/t );
        t += clamp( h, 0.05, .5 );
        if(h<0.001 || t>tmax) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1093
float getIncidentSunlight(vec3 startPos, vec3 lightDir) {
    vec3 position = startPos ;
    vec3 stepVector = lightDir * secSmokeSampleSize ;
    float extinction = 1.0 ;
    float dist = 0.0 ;
    for (int i = 0 ; i < secSmokeNumSamples ; ++i) {
        if (!isIntersectingSmokeShape(position,0.005,dist))
            break ;
	    float density = sampleSmoke(position) ;
        extinction *= exp(-extinctionCoeff*density*secSmokeSampleSize) ;
        position += stepVector ;
    }
    return extinction ;
}

// Function 1094
float CalcAO(vec3 ro, vec3 rd){
    float k = 1.0;
    float occ = 0.0;
    for(float i = 0.0; i < NUM_AO_STEPS; ++i){
        float len = 0.15 * i + 0.15;
        float dist = GetDist(rd * len + ro).d;
        occ += k * (len - dist);
        k *= 0.5;
    }
    return saturate(1.0-occ);
}

// Function 1095
float GetLightmapSphereFaceRes(Object obj)
{
    // assume 3x2 grid ..
	return (obj.lightmapBounds.w - obj.lightmapBounds.y)*0.5;
}

// Function 1096
float calcAO4(const vec3 pos, const vec3 nor )
{
    float hr, occ = 0., sca = 1.;
    for(int i=0; i<5; i++ ) {
        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)/4.;
        occ += -(getDistance( nor * hr + pos)-hr)*sca;
        sca *= .95;
    }
    return clamp(1. - 10.*occ, 0., 1.);
}

// Function 1097
vec4 shade(in vec3 hitp, in vec3 normal, in vec3 rd, in vec3 lightPos)
{
    vec3 lightDir = normalize(lightPos - hitp);
    vec3 lightHit = castRay(hitp, lightDir, 0.01, distance(hitp, lightPos));
    
    float ao = getAO(hitp, normal);
    float shadow = pow(distance(hitp, lightHit) / distance(hitp, lightPos), 64.0);
    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);
    float attenuation = 1.0 / pow(distance(hitp, lightPos), 2.0);
    float specular = pow(clamp(dot(normalize(lightDir - rd), normal), 0.0, 1.0), 64.0);
    
    vec4 diffuseColor = vec4(1.0) * diffuse * attenuation;
    vec4 specularColor = vec4(1.0) * specular * diffuse * attenuation;
    
    return (diffuseColor + specularColor) * min(ao, shadow);
}

// Function 1098
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<50; i++ )
    {
        float h = map(ro + rd*t).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
		t += clamp( h, 0.01, 0.25 );
		if( res<0.005 || t>10.0 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1099
float shadow(vec3 p, vec3 ld) {
	float i, h,
	      s = 1.,
	      t = .1;
	for (i = Z0; i < 20.; i++) {
		h = map(t * ld + p, false).d;
		s = min(s, 30. * h / t);
		t += h;
		if (s < .001 || t > 20.) break;
	}

	return sat(s);
}

// Function 1100
vec3 shade(vec3 p, vec3 d, vec3 e)
{
    // Get the position's distance from the camera.
    float l = length(p-e);
    // Also get the surface normal.
    vec3 n = norm(p);
    // And let's get the sky color since we need it.
    vec3 s = sky(d);
    // If the ray didn't hit anything, we shortcut out.
    if(l >= MAX_DEPTH)return s;
    // Otherwise we do texturing and lighting for this point.
    vec3 result = tex(p,e)*light(p,d,e,n);
    // Smooth out the transition between geometry and emptiness.
	return mix(s,result,clamp(MAX_DEPTH-l,0.0,1.0));
}

// Function 1101
void vs_pace_flight_dynamics( inout VehicleState vs, LocalEnvironment env, float dt, inout vec3 dv, inout vec3 dL )
{
    vec3 uvw = 1000. * vs.localv * vs.localB;
    vec3 pqr = vs.localomega * vs.localB;
    vec3 uvwdot = ZERO, pqrdot = ZERO;
    float invtau = 2. * abs( uvw.x ) / ( g_vehicle_data[ USE_VEHICLE_INDEX ].Sbcm.z );

    compute_flight_dynamics(
        g_vehicle_data[ USE_VEHICLE_INDEX ],
        env.atm.z,
        env.atm.w * 1000.,
        uvw,
        pqr,
        vec3( -vs.EAR.x, vs.EAR.yz ),
        vs.FSG,
        vs.wdelay,
        uvwdot,
        pqrdot,
        vs.info.xyz );

    vs.wdelay -= expm1( -dt * invtau ) * ( uvw.z - vs.wdelay );
    dv += dt * vs.localB * ( uvwdot /* - cross( uvw, pqr ) */ ) / 1000.;
    dL += dt * vs.localB * pqrdot;
}

// Function 1102
float calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )
{
    vec2 bound = sphIntersect( ro, rd, 2.1 );
    tmin = max(tmin,bound.x);
    tmax = min(tmax,bound.y);
    
	float res = 1.0;
    float t = tmin;
    for( int i=0; i<50; i++ )
    {
    	vec4 kk;
		float h = map( ro + rd*t, kk, false );
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1103
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<45; i++ )
    {
        float h = map(ro + rd*t).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1104
float Shadow(vec3 pos)
{
    float shadow = 1.0;
    float depth  = 1.0;
    
#ifdef HIGH_QUALITY
    for(int i = 0; i < 32; ++i)
#else
    for(int i = 0; i < 24; ++i)
#endif
    {
        vec2 sdf = Scene(pos + (SunLightDir * depth));
        
        shadow = min(shadow, (8.0 * sdf.x) / depth);
        depth += sdf.x;
        
        if(sdf.x < 0.001)
        {
            shadow = 0.0;
            break;
        }
    }
    
    return clamp(shadow, 0.0, 1.0);
}

// Function 1105
vec3 calcShade(vec3 pt, vec4 ob, vec4 col,vec2 mat,vec3 n)
{

	float dist,diff;
	vec3 lcol,l;

	vec3 color = vec3(0.0);
	vec3 ambcol = amb * (1.0-col.w) * col.rgb;
	vec3 scol = col.w * col.rgb;

	if(col.w > 0.0) //If its not a light
	{
		l = spheres[0].xyz - pt;
		dist = length(l);
		l = normalize(l);
		lcol = colors[0].rgb;
		diff = clamp(dot(n,l),0.0,1.0);
		color += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);
		if(inShadow(pt,l,dist))
			color *= 0.7;

		l = spheres[1].xyz - pt;
		dist = length(l);
		l = normalize(l);
		vec3 lcol = colors[1].rgb;
		diff = clamp(dot(n,l),0.0,1.0);
		color += (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);

		if(inShadow(pt,l,dist))
			color *= 0.7;
	}
	else
		color = col.rgb;

	return color;
}

// Function 1106
void intersectLight(
	vec3 rayOrigin,
	vec3 rayDir,
	vec3 planeNormal,
	inout float rayT,
	inout vec2 uv)
{
	vec3 planeTangent = normalize(cross(planeNormal, vec3(0.0, 1.0, 0.0)));
	vec3 planeBitangent = normalize(cross(planeNormal, planeTangent));
	
	// get coord of plane intersection
	float t = -dot(rayOrigin, planeNormal)/dot(rayDir, planeNormal);
	if (0.0 < t && t < rayT) {
		// check coord on plane is within light quad
		vec3 hitPos = rayOrigin + t*rayDir;
		float x = dot(hitPos, planeTangent);
		float y = dot(hitPos, planeBitangent);
		if (-0.5 < x && x < 0.5 && -0.5 < y && y < 0.5) {
			rayT = t;
			uv = vec2(0.5 - x, y + 0.5);
		}
	}
}

// Function 1107
float SampleAO(in Camera camera, vec3 pos, vec3 norm, vec2 sampleUV)
{
    Ray ray = Camera_GetRay(camera, sampleUV);
    
	float aoSampleDepth = textureLod(iChannel1, sampleUV, 0.0).r;
    
    vec3 aoSamplePos = ray.o + (ray.d * aoSampleDepth);
    vec3 aoToVector  = (aoSamplePos - pos);
     
    float dist = length(aoToVector) * AODistScale;
    float occl = max(0.0, dot(norm, normalize(aoToVector)) - AOBias) * (1.0 / (1.0 + dist)) * AOIntensity;
    
    return clamp(occl, 0.0, 1.0);
}

// Function 1108
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float time )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<128; i++ )
    {
		float h = map( ro + rd*t, time );
        res = min( res, 16.0*h/t );
        t += clamp( h, 0.01, 0.25 );
        if( res<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1109
float directionalShadow(vec3 cameraTarget, vec3 modelPosition, vec3 p, vec3 dirLightPos)
{
    float shadow = 0.;
    mat3 dirLightView = getView(dirLightPos, cameraTarget);
    vec3 dirLightRayDirection = dirLightView * modelPosition;

    float dt = 0., d = 0.;
    // shadow depth
    float shadowDepth = length((dirLightPos-p));
    dirLightRayDirection = normalize(-dirLightPos+p);
    vec3 shadowPos;
    for( int i = 0; i < maxSteps; ++i )
    {
        vec3 p = dirLightPos + dirLightRayDirection*d;
        int id;	// id of object that is being drawn
        dt = drawScene(p,id);
        if( dt < EPSILON )
        {
            float currentShadowDepth = length((dirLightPos-p));
            // 
            if( currentShadowDepth/shadowDepth < 1.-EPSILON)
                shadow = 1.;	
            break;
        }
        d += dt;
    }
    return shadow;
}

// Function 1110
vec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)
{
    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0.r < 0.)
    {
        return clamp(dot(n, l.d), 0., 1.) * l.c;
    }
	return vec3(0.);
}

// Function 1111
float softshadow( in vec3 rayOrigin, in vec3 rayDirection, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    
    for (int i = 0; i < MAX_ITER; i++)
    {
        float h = distfunc( rayOrigin + rayDirection*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    
    return clamp( res, 0.0, 1.0 );
}

// Function 1112
float shadow (in vec3 p, in vec3 lPos) {
    float lDist = distance (p, lPos);
    vec3 lDir = normalize (lPos - p);
    int dummy = 0;
    float dist = march (p, lDir, dummy);
    return dist < lDist ? .1 : 1.;
}

// Function 1113
float softshadow( in vec3 ro, in vec3 rd, float k ) {
    float res=1., t=0.15, h=1.;
    for( int i=0; i<46; i++ ) {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.15, 1.0 );
		if( h<0.012 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1114
vec3 shade( const in float d, in vec3 col, const in float shadow, const in vec3 nor, const in vec3 ref, const in vec3 sky) {
    float amb = max(0., 0.5+0.5*nor.y);
    float dif = max(0., dot( normalize(nor), lig ) );
    float spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);

    dif *= shadow;

    vec3 lin = 1.20*dif*vec3(1.00,0.85,0.55);
    lin += 0.50*amb*vec3(0.50,0.70,1.00);
    col = col*lin;
    col += spe*dif;
    
    // fog
    col = mix( col, sky, smoothstep( MAXDISTANCE * .8, MAXDISTANCE, d ) );
    
	return col;
}

// Function 1115
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
		float h = map( ro + rd*t, rd ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1116
vec3 getlightpos() {
    return vec3(0,5,0);
}

// Function 1117
float shadow(vec3 rayPos, vec3 lightDir, vec3 normal)
{
    float sVal = 1.0; //initial shadow value.sVal gets mutiplied with diffuse lighting
    float sEPS = 0.01;// our shadow epsilon/precision value
    vec3 ro = rayPos + (normal * sEPS); //reduces self-shadow artifacts since we are starting the march slightly above our surface
    vec3 rd = lightDir; // we are now marching from our surface to light source.
    float sDist; //initializing our shadow distance value
    
    
      for(int i = 0; i < 36; i++)
      {
        sDist = scene(ro); //comparing shadow ray position with our scene
        if(sDist < sEPS)
        {
            sVal = 0.0;
            break;
        }
        ro += rd * sDist;
     }
    
    return sVal;
}

// Function 1118
float shadowmarch(vec3 point, vec3 light){
	vec3 delta = light - point;
	float dmax = length(delta);
	vec3 ray = delta/dmax;
	
	float shadow = 1.0;
	float dsum = 0.1;
	for(int i=0; i<shadow_iterations; i++){
		vec3 p = point + ray*dsum;
		float d = dist(p);
		if(d < 1e-6) return 0.0;
		
		dsum += max(min_step, d*step_fraction);
		shadow = min(shadow, 128.0*d/dsum);
		if(dsum > dmax) return shadow;
	}
	
	return shadow;
}

// Function 1119
float calcShadow(vec3 p, vec3 lightPos) {
	// Thanks iq.
	vec3 rd = normalize(lightPos - p);
	float res = 1.,
	      t = .1;
	for (float i = 0.; i < 32.; i++) {
		float h = map(p + rd * t).d;
		res = min(res, 10. * h / t);
		t += h;
		if (res < .001 || t > 3.) break;
	}

	return clamp(res, 0., 1.);
}

// Function 1120
vec3 lightContribution(
    vec3 eyePos,
    vec3 eyeDir,
    vec3 normal,
    vec3 lightPos,
    vec3 lightColor,
    Material material,
    float occlusionTerm)
{
    vec3 l = normalize(lightPos - eyePos);
    vec3 diffuse = max(material.diffuseColor * (max(dot(normal, l), 0.0)) - occlusionTerm, vec3(0.0));
    vec3 refVec = reflect(l, normal);
    vec3 specular = material.specularColor * pow(max(dot(refVec, eyeDir), 0.0), material.specularExponent);
    return (diffuse + specular) * lightColor;
}

// Function 1121
float sampleLightSourcePdf(in vec3 x, vec3 ns, in vec3 wi, float d, float cosAtLight) {
    return PdfAtoW(1.0 / (light.size.x*light.size.y), d*d, cosAtLight);
}

// Function 1122
vec3 CalculateLightingAnalytical(    // Direct lighting
    in vec3 toLight,
    in vec3 toView,
    in Material mat)
{
    vec3 fresnel0 = mix(vec3(0.04), mat.albedo, mat.metallic);
    vec3 ks       = vec3(0.0);
    vec3 diffuse  = CalculateDiffuse(mat.albedo);
    vec3 specular = CalculateSpecularAnalytical(mat.bump, toLight, toView, fresnel0, ks, mat.roughness);
    vec3 kd       = (1.0 - ks);
    
    float angle = max(0.0, dot(mat.bump, toLight));
    
    return ((kd * diffuse) + specular) * angle;
}

// Function 1123
vec3 shadeDrySand( in vec3 i, in vec3 t )
{
    return i*t;
}

// Function 1124
float areaShadow( in vec3 P )
{
  float s = 1.0;
  for( int i=0; i<SPH; i++ )
    s = min( s, sphAreaShadow(P, L, sphere[i] ) );
  return s;           
}

// Function 1125
float shadow_falloff( vec3 pa, vec3 pb )
{
	vec3 d = ( pa - pb );
	return 1.0 / ( 1.0 + lensqr( d ) * 0.00005 );
}

// Function 1126
float vertexAo(float side1, float side2, float corner) {
	return 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;
}

// Function 1127
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
    float r = 1.0;
    float dt = 0.02;
    float t = mint;
    CastRes cr;
    for( float i=0.; i<10.; i++ )
    {
        if( t < maxt )
        {
          cr.pos = ro + rd*t;
          float h = DistFunc(cr).dist;
          r = min( r, k*h/t );
          t += max( 0.02, r);
        }
    }
    return clamp( r, 0.0, 1.0 );

}

// Function 1128
float CaveSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  for (int j = VAR_ZERO; j < 16; j ++) {
    h = CaveDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += max (0.2, 0.1 * d);
    if (sh < 0.05) break;
  }
  return 0.4 + 0.6 * sh;
}

// Function 1129
float lighting(vec3 n, vec3 v)
{
	vec3 L = normalize(vec3(1,3,2));
   	float nl = dot(vec3(n), L);
   	nl = max(0., nl); // lighting
   	nl = mix(nl, 1., .2); // ambient
    return nl;
}

// Function 1130
bool intersectShadow( in vec3 ro, in vec3 rd, in float l )
{
    float t;

    bvec4 sss;

    sss.x = esfera2(   fpar00[0], ro, rd, l );
    sss.y = esfera2(   fpar00[1], ro, rd, l );
    sss.z = cylinder2( fpar00[2], ro, rd, l );
    sss.w = cylinder2( fpar00[3], ro, rd, l );

    return any(sss);
}

// Function 1131
vec3 Shade(vec3 p, vec3 n)
{
    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));
    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));
    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);
    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);
    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);
}

// Function 1132
float calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {
    float res = 1.;
    float t = mint;
    for(int i=0; i<14; i++) {
        float h = map(ro + rd*t).x;
        res = min(res, 8.*h/t);
        t += max(h, .02);
        if(res<.005 || t>tmax) break;
    }
    return clamp(res,0.,1.);
}

// Function 1133
float ao(vec3 v, vec3 n) 
{
    const int ao_iterations = 10;
    const float ao_step = 0.2;
    const float ao_scale = 0.75;
    
	float sum = 0.0;
	float att = 1.0;
	float len = ao_step;
    
	for (int i = 0; i < ao_iterations; i++)
    {
		sum += (len - f(v + n * len).x) * att;		
		len += ao_step;		
		att *= 0.5;
	}
	
	return 1.0 - max(sum * ao_scale, 0.0);
}

// Function 1134
light ambientLight(float color, float intensity) {
    return ambientLight(vec3(color), intensity);
}

// Function 1135
vec3 shadeGround(vec3 p, vec3 n, vec3 r) {
    float  t = texture(iChannel1,p.xz).x;
    // thnx VoidChicken!
    vec3 col = mix(vec3(.3,.7,.2),vec3(.1,.5,.05),t/(1.+t));
    return calcLighting(col, p, n, r, 30.);
}

// Function 1136
float shadowVSM(vec3 px,float linearDepth)
{
    // use linear depth for better precision
   
    vec4 lookup = texture(iChannel2,px.xy);
   
    // after the blurring stages, the z and w fields
    // contain estimates of the expected value of
    // depth and squared depth
    float Ex = lookup.z;
    float Ex2 = lookup.w;
    
    // compute variance
    float variance = Ex2 - Ex*Ex;
    
    // temporary for formula
   	float znorm = linearDepth - Ex;
    float znorm2 = znorm*znorm;
    
    // compute upper bounds of probabilty of shading
    // using Chebyshev's inequality
    float p = variance/(variance + znorm2);
    
    // formula is only valid if depth is less than the expected
    // value. The max formulation is taken from an nvidia presentation
    // just called "Variance Shadow Mapping"
    return max( p, float(linearDepth <= Ex) );
}

// Function 1137
vec3 highlight(in Ray ray, in vec3 n) {
    // sun
	vec3 sunDir = normalize(vec3(1,0.3,1));
	float sunDist = distance(sunDir, ray.dir)-0.00;
	return mix(vec3(10,10,8), vec3(0), smoothstep(0.0, 0.2, sunDist));
}

// Function 1138
float shadow(in vec3 ro, in vec3 rd, in float mint)
{
	float res = 1.0;
    
    float t = mint;
    for( int i=0; i<12; i++ )
    {
		float h = map(ro + rd*t);
        res = min( res, 4.*h/t );
        t += clamp( h, 0.1, 1.5 );
            }
    return clamp( res, 0., 1.0 );
}

// Function 1139
vec3 calcLight( in vec3 pos , in vec3 lightp, in vec3 lightc, in vec3 camdir)
{    
	vec3 normal = calcNormal(pos);
    vec3 lightdir = normalize(pos - lightp);
    float cosa = pow(0.5+0.5*dot(normal, -lightdir), 3.0);
    float cosr = max(dot(-camdir, reflect(lightdir, normal)), 0.0);
    
    vec3 ambiant = vec3(0.02);
    vec3 diffuse = vec3(0.7 * cosa);
    vec3 phong = vec3(0.3 * pow(cosr, 16.0));
    
    return lightc * (ambiant + diffuse + phong);
}

// Function 1140
vec3 getLight(vec3 p, vec3 normal) {
    vec3 light = vec3(0.0, 1.0, -3.0);
    vec3 light2 = vec3(0.0, -1.0, -3.0);
    vec3 dirlight = vec3(0.0, 1.0, 0.0);
    //light = vec3(q.x, 0.0, q.y);

    // Calculate diffuse lighting by taking the dot product of 
    // the light direction (light-p) and the normal.
    float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);
    float dif2 = clamp(dot(normal, normalize(light2 - p)), 0., 1.);
    float dif3 = clamp(dot(normal, normalize(dirlight)), 0., 1.);

    // Multiply by light intensity (5) and divide by the square
    // of the distance to the light.
    dif *= 5. / dot(light - p, light - p);
    dif2 *= 5. / dot(light2 - p, light2 - p);
    // dif3 *= 5. / dot(dirlight, dirlight);

    float dif4 = (dif + dif2 + dif3) / 3.0;

    dif = pow(dif, 0.4545);
    dif2 = pow(dif2, 0.4545);
    dif3 = pow(dif3, 0.4545);

    vec3 color = vec3(dif2 * 0.5, dif * 0.25, dif3);
    return color;
}

// Function 1141
vec3 Lightning(vec3 sp,vec3 sn,vec3 rd,vec3 lp,vec3 color,vec3 lc)
{
    // From a Shane Shader
    vec3 ld = lp - sp;
    float lDist = max(length(ld), 0.001);
    ld /= lDist;
    float atten = 1./(1. + lDist*.2 + lDist*.1); 
    float ambience = 1.;
    float diff = min(0.3,max( dot(sn, ld), 0.0));
    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.); 
    return color*(diff+ambience)+lc*spec/1.5;
}

// Function 1142
float softshadow(in vec3 ro, in vec3 rd){
    float res = 1.0, t = 0.15; 
    for(int s = 0; s < 26; ++s){
        float h = sdScene(ro + rd*t,true).x;
        if(h < 0.001) return 0.0;
        res = min( res, 2.0*h/t );
        t += h*0.339;
    }
    return res;
}

// Function 1143
float ao( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= .95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1144
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN<tF && tF>0.0) return 0.0;
    
    float sh = 1.0;
    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );
    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );
    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );
    sh = clamp(sk*sqrt(sh),0.0,1.0);
    return sh*sh*(3.0-2.0*sh);
}

// Function 1145
float shineLightAtBlobs( in vec3 pos , in vec3 camDir) {
    vec3 normal = calcNormal(pos);
    
    return acos(dot(normal, camDir)) / 3.14159;
    // equation for lighting found here: https://onlinemschool.com/math/library/vector/angl/
}

// Function 1146
vec3 planetPhongLightingModel(in vec3 k_d,in vec3 k_s,in float shininess,in vec3 p,in vec3 eyePos,in vec3 lightPos,in vec3 lightIntensity){
	vec3 N = sphereNormal(p,planetCenter,planetRadius);
    vec3 L = normalize(lightPos-p);
    vec3 V = normalize(eyePos-p);
    vec3 R = normalize(reflect(-L,N));
    
    float dotLN = dot(L,N);
    float dotRV = dot(R,V);
    if(dotLN<0.)
    {
        return vec3(0.,0.,0.);//light not visible from this point on the surface
    }
    if(dotRV<0.)
    {
        return lightIntensity*(k_d*dotLN);//light reflection in opposite direction as viewer,apply only diffuse component
    }
    return (k_d*dotLN+k_s*pow(dotRV,shininess))*lightIntensity;
}

// Function 1147
float calcAO( in vec3 pos, in vec3 nor )
{
    float ao = 0.0;
    for( int i=0; i<8; i++ )
    {
        float h = 0.02 + 0.5*float(i)/7.0;
        float d = map2( pos + h*nor );
        ao += h-d;
    }
    return clamp( 1.5 - ao*0.6, 0.0, 1.0 );
}

// Function 1148
float calculateAO2( in vec3 p, in vec3 n )
{
	float ao = 0.0, l;
    const float maxDist = 2.;
	const float nbIte = 6.0;
	//const float falloff = 0.9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;
        
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 1149
float waterHighlight(vec2 p, float time, float foaminess)
{
    vec2 i = vec2(p);
	float c = 0.0;
    float foaminess_factor = mix(1.0, 6.0, foaminess);
	float inten = .005 * foaminess_factor;

	for (int n = 0; n < MAX_ITER; n++) 
	{
		float t = time * (1.0 - (3.5 / float(n+1)));
		i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
		c += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));
	}
	c = 0.2 + c / (inten * float(MAX_ITER));
	c = 1.17-pow(c, 1.4);
    c = pow(abs(c), 8.0);
	return c / sqrt(foaminess_factor);
}

// Function 1150
vec3 shade(ray r, sphere s[nSpheres], vec3 lightPos, float lightRad)
{
	if (r.s.id == -2) return vec3(8.0);
	
	vec3 P = r.o + r.d * r.t;
	vec3 N = vec3(0.0,1.0,0.0);
	vec3 C = vec3(1.0,1.0,1.0);
	
	float sh = 1.0;
	float ao = 1.0;

	if (r.s.id == -1)
	{
        float x = min(abs(fract(0.2*P.x) - 0.5), abs(fract(0.2*P.z) - 0.5));
        C *= mix(1.0, (0.4+0.5*smoothstep(0.0, 0.5/r.t, x-0.04)), exp(-0.005*r.t));
		for (int i = 0; i < nSpheres; i++)
		{
			sh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);
			ao *= aoFromSphere(s[i].o, s[i].r, P, N);
		}
	}
	else
	{
		N = normalize(P - r.s.o);
		ao *= N.y * 0.5 + 0.5;

		for (int i = 0; i < nSpheres; i++)
		{
			if (i != r.s.id)
			{
				sh *= shadow(P, lightPos, lightRad, s[i].o, s[i].r);
				ao *= aoFromSphere(s[i].o, s[i].r, P, N);
			}
		}

		sh *= max(0.0, diffuse(P, N, lightPos, lightRad));
		
		vec2 uv = hash(123.456 * float(r.s.id) / float(nSpheres));
		C = texture(iChannel0, 1.0 - uv).xyz * 0.5 + 0.25;
	}

	C *= sh * 0.95 + 0.05;
	C *= mix(ao, 1.0, sh);
	
	return C;
}

// Function 1151
vec3 shade( in vec3 ro, in vec3 rd, in float t, float time )
{
    float eps = 0.001;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps, time );
    float kk;
    vec3 qos = deform( pos, time, kk );
    vec3 qor = calcNormal2( qos, eps );

    vec3 tex = texcube( iChannel0, qos*0.5, qor, 1.0 ).xyz;

    vec3 lig = normalize( vec3(2.0,1.0,0.2) );

    float fre = pow( clamp(1.0+dot(nor,rd), 0.0, 1.0 ), 2.0 );
    float occ = calcAO( qos, qor );

    float dif = clamp( dot(nor,lig), 0.0, 1.0 );
    float sha = softshadow( pos, lig, 64.0, time ); 
    dif *= sha;
        
    vec3 col = 2.0*vec3(1.1,0.8,0.6)*dif*(0.5+0.5*occ) + 0.6*vec3(0.1,0.27,0.4)*occ;
    col += 1.0*fre*(0.5+0.5*dif)*occ;
    float sh = 4.0 + tex.x*64.0;
    col += 0.1*sh*pow(clamp(-dot(rd,nor),0.0,1.0),sh)*occ*sha;
    col *= clamp(2.0*dot(pos,pos),0.0,1.0);

    col *= 6.0*tex;
    
    col *= exp( -1.5*t );

    return col;        
}

// Function 1152
vec3 shade(vec3 ori, vec3 dir) {
 
    float  t = raymarch(ori,dir);
    vec3 col = vec3(0.);
    
    if(t < MAX_DISTANCE) {
    	vec3 p = ori+dir*t;
        vec3 n = calcNormal(p,t);
        vec3 r = normalize(reflect(dir, n));
        
        vec2 uv = asin(n.xy)/PI+.5;
        
        col = texture(iChannel0,uv).xyz;
        col = calcLighting(col, p, n, r, 30., ori);
    } else {
    	col = getSky(dir);
    }
    
    float f = pow(max(dot(LIGHT_DIR,dir),0.),60.);
  	if(raymarch(ori,LIGHT_DIR) >= MAX_DISTANCE)
         col += LIGHT_COL * f;
    
    return col;
    
}

// Function 1153
float matOutdoorLight( in vec3 pos, in vec3 nor ) {
    float l = ( smoothstep( 0.03, 0.1, abs( mod( pos.x, 1.8 ) / 1.8 - .5) ))
			* ( smoothstep( 0.03, 0.1, abs( mod( pos.y, 3.6 ) / 3.6 - .5) ));
    return mix( 8.,12., l);
}

// Function 1154
bool shadowDetect(Ray r, Sphere s)
{        
    vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float b = 2.0 * dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float det = b*b - 4.0*a*c;
    if (det < 0.0)
    	return false;
    
    
    float t = (-b - sqrt(det)) / (2.0 * a);
    if (r.mint <= t && t < r.maxt) 
        return true;

    return false;
}

// Function 1155
vec3 Shade(vec3 position, vec3 normal, vec3 rayOrigin,vec3 rayDirection)
{
    vec3 color = vec3(0, 0, 0);
    
    //Face Colors
    vec3 leftColor =  vec3(  3, 130,  75) / 255.0;
    vec3 frontColor = vec3(233, 207,  12) / 255.0;
    vec3 topColor =   vec3(215,  75,   4) / 255.0;
    
    color = mix(color, leftColor,  abs( dot(normal, vec3(1,0,0) ) ) );
    color = mix(color, frontColor, abs( dot(normal, vec3(0,0,1) ) ) );
    color = mix(color, topColor,   abs( dot(normal, vec3(0,1,0) ) ) );
    
    //Background
    color = mix(color, vec3(0.1), step(22.0, length(position)));
    
    return color;
}

// Function 1156
float MapStreeLight(vec3 p)
{
  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);
  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   
  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        
  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  
  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  
  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        
  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); 

  return d;
}

// Function 1157
vec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    //vec3 lig = normalize(vec3(1.1, 0.7, 0.9));
    vec3 lig = normalize(vec3(0.0,1.0,0.8)); 
    float dif = max(dot(nor, lig), 0.0);
    float sha = 0.0;
    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);
    lin += dif * vec3(2.) * sha;

    // ambient light
    //-----------------------------
    //lin += vec3(0.5);

    // surface-light interacion
    //-----------------------------
    vec3 col = mal * lin;

    // fog
    //-----------------------------
    //col *= exp(-0.01 * dis * dis);

    //Specular
    float nrm = (60.0 + 8.0) / (3.1415 * 8.0);
    col += pow(max(dot(reflect(rd,nor),lig),0.0),60.0) * nrm;
 
//////experiment
    
    float fresnel = 1.0 - max(dot(nor,rd),0.0);
    fresnel = pow(fresnel,3.0) * 0.65;
    
    //sky color
	vec3 e = reflect(rd,nor);
    
    e.y = max(e.y,0.0);
    vec3 ret;
    ret.x = pow(1.0-e.y,2.0);
    ret.y = 1.0-e.y;
    ret.z = 0.6+(1.0-e.y)*0.4;
    //Reflected
    vec3 reflected = ret*0.05;

    //Sea color
    vec3 base = vec3(0.03,0.01,0.01);
    vec3 scolor = vec3(0.1,0.04,0.0);

    float diffuse = pow(dot(nor,lig) * 0.4 + 0.6,80.0)*200.0;
  	
    //Refracted
    vec3 refracted = base + diffuse * scolor * 0.32; 
    
	//Experiment - overwrite color
	col = mix(refracted,col,fresnel);    
    
    //
    
    return col;
}

// Function 1158
vec3 getLightVector(vec3 p) {
    float t = iTime * 2.5;
	return vec3(cos(t),0.,sin(t))*4. - p;
}

// Function 1159
vec3 shade(in vec3 p, in vec3 d, in vec3 e, in float id)
{
	float amb, dif;	 // The ambient and diffuse lighting terms.
    vec3 n,			 // The surface normal at the first bounce.
         primary;	 // The primary and secondary colors.
    
    n = norm(p);	// Get the surface normal at the first bounce.
	light(p, d, e, n, id, amb, dif);	// Light the first bounce.
    primary = tex(p, e, n, id)*amb*dif*LCOLOR;	// Texture the first bounce.
	primary += gi(p, n, id);
	
    if((id == ID_GARAGE && abs(n.y) > .8) || id == ID_PIPES)
    {
		// The ID of the object in the reflection image.
		float rID;
		// The reflection's position, normal, direction and color.
		vec3 rp, rn, rd, secondary;
		
		// Create surface features so the reflections aren't pristine.
        n.xz += bumpmap(p, n, id);
		n = normalize(n);
		
		// Reflect the ray direction through the first surface normal.
		rd = reflect(d, n);
		// Get that reflection.
		rID = reflection(p, rd, rp);
		
		// Get the surface normal at the imaged position.
		rn = norm(rp);
		// Get the lighting at that point, using the new normal.
		light(rp, rd, p, rn, rID, amb, dif);
		// Get the texture in the reflection.
		secondary = tex(rp, p, rn, rID)*amb*dif*LCOLOR;
        
        return mix( primary, secondary, reflectivity(p, n, d, id, rID));
    }
	
	// Since we weren't on a reflective material we just return the
	// first color.
    else return primary;
}

// Function 1160
vec3 GetLight(vec3 p)
{

    vec3 rgb = vec3(0.,0.,0.);
    vec3 lightPos = vec3(0,3,6);
    
    
    lightPos.xz += vec2(5.*sin(iTime),5.*cos(iTime));
    vec3 l = normalize(lightPos - p);
    vec3 n = GetNormal(p);
    float dif = clamp(dot(n,l),0.,1.);
    vec2 rm = RayMarch(p+n*MIN_DIST*1.1,l);
    float mindist = rm.y;
    float d = rm.x;
    if(d<length(lightPos-p)) dif*=0.1;
    vec3 lightCol = vec3(0,0,0);
    if(d>=MAX_DIST)
    	lightCol = 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));
    
    rgb = dif+lightCol;
    
    return rgb;
}

// Function 1161
vec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )
{
    float eps = 0.002;
    vec2 britneyOffset = vec2(1.0, -0.5);
    vec2 britneyTexOffset = vec2(0.3, -0.2);
	float britneyRadius = 0.3;
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormalOpaque( pos, eps );
	vec2 britneyScale = vec2(2.0, 2.0);

    vec3 mateD = vec3(0.0);
    vec3 mateS = vec3(0.0);
    vec2 mateK = vec2(0.0);
    vec3 mateE = vec3(0.0);

    float focc = 1.0;
    float fsha = 1.0;
	int check = 0;
	vec3 britney = vec3(0.0);
    if( m<1.5 ) // snail body
    {
		
		vec2 texpos = (pos.xy * 2.0 + britneyOffset);
        if (texpos.x >= 0.6 && texpos.x <= 1.2 && texpos.y >= 0.2 && texpos.y <= 0.9)
			check = 1;
		vec2 d8 = vec2(texpos.x - 0.9, texpos.y - 0.55);
		if (sqrt(d8.x * d8.x + d8.y * d8.y) >= britneyRadius)
            check = 0;
        float dis = texture( iChannel1, 5.0*pos.xy ).x;
		vec4 col0 = texture(iChannel0, (pos.xy + britneyTexOffset) * britneyScale);
		//if (col0.x <= 0.5 && col0.z <= 0.5)
		//	check = 0;
		britney = vec3(col0.xyz);
        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );
        be = 1.0-smoothstep( -0.01, 0.01, be );        
        
        float ff = abs(matInfo.x-0.20);
        
        mateS = 6.0*mix( 0.7*vec3(2.0,1.7,1.0), vec3(2.5,1.8,0.9), ff );
        mateS += 2.0*dis;
        mateS *= 1.5;
        mateS *= 1.0 + 0.5*ff*ff;
        mateS *= 1.0-0.5;
        
        mateD = vec3(1.0,0.8,0.4);
        mateD *= dis;
        mateD *= 0.015;
        mateD += vec3(0.8,0.4,0.3)*0.15*0.01;
        
        mateK = vec2( 60.0, 0.7 + 1.0*dis );
        
        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );
        f = 1.0-pow( f, 8.0 );
        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);
        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);
        
        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));
        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );
    }
    else if( m<2.5 ) // shell
    {
        mateK = vec2(0.0);
        
        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );
        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );
        
        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)/3.1416, 1.5*matInfo.w );
        
        vec3 ral = texture( iChannel1, vec2(2.0*matInfo.w+matInfo.z*0.5,0.5) ).xxx;
        mateD *= 0.25 + 0.75*ral;
        
        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );
        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));
        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );
        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;
        
        mateK = vec2( 64.0, 0.2 );
        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);//*0.5;
    }
    else if( m<3.5 ) // plant
    {
        mateD = vec3(0.05,0.1,0.0)*0.2;
        mateS = vec3(0.1,0.2,0.02)*25.0;
        mateK = vec2(5.0,1.0);
        
        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
        mateD += 0.2*fre*vec3(1.0,0.5,0.1);
        
        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;
        mateS *= 0.5 + 1.5*te;
        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);
    }
    else //if( m<4.5 ) // leave
    {
        vec3 p = pos - vec3(-1.8,0.6,-0.75);
        vec3 s = p;
        p = mat3(0.671212, 0.366685, -0.644218,
                -0.479426, 0.877583,  0.000000,
                 0.565354, 0.308854,  0.764842)*p;

        vec3 q = p;
        p.y += 0.2*exp(-abs(2.0*p.z) );

        float v = smoothstep( 0.01, 0.02, abs(p.z));
        
        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );

        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;

        float r = clamp((p.x+2.0)/4.0,0.0,1.0);
        r = r*(1.0-r)*(1.0-r)*6.0;
        float ff = length(p.xz/vec2(2.0,r));

        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );
        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );
        mateD *= 1.0 + 0.25*te;
        
        mateS = vec3(0.15,0.2,0.02)*0.8;
        mateS *= 1.0 + 0.2*rr;
        
        mateD *= 0.8;
        mateS *= 0.8;

        mateK = vec2(64.0,0.25);
        
        //---------------------
        
        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);
        nor = normalize( nor );

        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );
        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );
        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );
        float dd = min(d1,min(d2,d4));
        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);
        
        d1 = sdEllipsoid( q.xz, vec2( 0.5, 0.20), 1.0*vec2(0.15,0.15) );
        d2 = sdEllipsoid( q.xz, vec2( 0.8,-0.15), 0.5*vec2(0.15,0.15) );
        d4 = sdEllipsoid( q.xz, vec2(-0.5,-0.20), 1.0*vec2(0.04,0.04) );
        d1 = abs(d1);
        d2 = abs(d2);
        d4 = abs(d4);
        dd = min(d1,min(d2,d4));
        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);
        
        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );
        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );
        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;
        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    
    }
    
  
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor )*focc;
    float sss = calcSSS( pos, nor );
    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;
    
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float sha = calcSoftshadow( pos, sunDir, 20.0 ); 
    dif1 *= sha*fsha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );

    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );

    vec3 col = 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;
    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);
    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;

    col *= mateD;

    col += .4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS;
  
    col = pow(col,vec3(0.6,0.8,1.0));
    
    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;
    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y;
    col += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0));        

    col += mateE;
	if (check == 1)
    {
        col = mix(col, britney, 0.5);
    }
    return col;        
}

// Function 1162
float light(vec3 p, vec3 n) {
    vec3 lightPos = vec3(0.5, 1.5, 4.);
    vec3 l = normalize(lightPos-p);
    float dif = clamp(dot(n, l), 0., 1.);     
    return dif*1.5;
}

// Function 1163
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    
    
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );
    
    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );
    
    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
    // AO
    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;
    
    return surfaceLighting;
}

// Function 1164
float marchShadow(vec3 ro, vec3 rd, float t, float mt, float tanSourceRadius)
{
 	float d;
    float minVisibility = 1.0;
    
    vec4 material;
    
    for(int i = NON_CONST_ZERO; i < ITER_SHADOW && t < mt; ++i)
    {
        float coneWidth = max(0.0001, tanSourceRadius * t);
        
        vec3 posWS = ro + rd*t;
        d = fSDF(posWS, false, material) + coneWidth*0.5;
        
        minVisibility = min(minVisibility, (d) / max(0.0001, coneWidth*1.0));
        t += d;
        
        if(i >= ITER_SHADOW - 1)
        {
            t = mt;
        }              
        
        if(minVisibility < 0.01)
        {
            minVisibility = 0.0;
        }
    }
      
    return smoothstep(0.0, 1.0, minVisibility);
}

// Function 1165
float GetLight(vec3 p){
    //position of the light source
    vec3 lightPos = vec3(0,0,0);
    
    lightPos.xz *= Rot(sin(iTime));
    //light vector
    vec3 l = normalize(lightPos-p+vec3(4,0,0));
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);
    if(d < length(lightPos-p)){
        diff *= 0.1;
    }
    return diff;
}

// Function 1166
vec3 shade(vec3 ro, vec3 rd, vec2 t, int iter, vec3 pos) {
    #if MARCH
    
    /*
    // The normal here isn't accurate, the surface is too high-frequency
    float e = 0.0001;
    vec3 eps = vec3(e,0.0,0.0);
	vec3 n = normalize( vec3(
           dist(pos+eps.xyy) - dist(pos-eps.xyy),
           dist(pos+eps.yxy) - dist(pos-eps.yxy),
           dist(pos+eps.yyx) - dist(pos-eps.yyx) ) );
	*/
    
    // This pretends the Mandelbulb is actually a sphere, but it looks okay w/ AO.
    vec3 n = normalize(pos);
    // And this isn't accurate even for a sphere, but it ensures the edges are visible.
    n = faceforward(n,-rd,-n);
    
    #else
    
    // The largest component of the vector from the center to the point on the surface,
    //	is necessarily the normal.
    vec3 n = (ro+rd*t.x - pos);
    n = sign(n) * (abs(n.x) > abs(n.y) ? // Not y
        (abs(n.x) > abs(n.z) ? vec3(1., 0., 0.) : vec3(0., 0., 1.)) :
    	(abs(n.y) > abs(n.z) ? vec3(0., 1., 0.) : vec3(0., 0., 1.)));
    
    #endif
    
    Material mat = Material(vec3(1.,.9,.7), 0.9);

    #if MAT_SAMPLES
    vec3 acc = vec3(0.);
    int j;
    for (j = 0; j < MAT_SAMPLES; j++) {
        vec3 lightDir;
        vec3 lightCol = vec3(0.);
        for (int i = 0; i < SKY_SAMPLES; i++) {
            vec3 d = hash33(0.2*pos+0.5*n+float(i+j*SKY_SAMPLES));
            d = normalize(d);
            vec3 c = sky(d);
            if (length(c) > length(lightCol)) {
                lightCol = c;
                lightDir = d;
            }
        }
        acc +=
            2.*pow(lightCol, vec3(2.2)) * brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));
    }
    return acc / float(j);
	#else
    vec3 lightDir = reflect(rd,n);
    return 2.*brdf(lightDir, -rd, n, mat, (float(iter)/float(MAX_ITER)));
    #endif
}

// Function 1167
float softShadow(in vec3 ro, in vec3 rd, float mint, float k) {
    float res = 1.0;
    float t = mint;
    for(int i = 0; i < 32; i++) {
    	float h = map(ro + rd * t);
        if (h < 0.001) { return 0.0; }
        res = min(res, k*h/t);
       	t += h;
    }
    return res;
}

// Function 1168
float calcShadow(vec3 ro, vec3 rd)
{
    float t = 0.0001;
    for(int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ro + t*rd;
        float res = map(p).x;
        if(res < SURF_DIST || res > MAX_DIST) break;
        t += res;
    }

    return t>MAX_DIST ? 1.0 : 0.0;
}

// Function 1169
vec3 light_distr(vec3 p)
{
    return vec3(1,1,1) * (4.*step(-light_sphere.w, -length(p - light_sphere.xyz)));
}

// Function 1170
float apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)
{
 	float t = mint;
    float res = 1.0;
    for( int i=0; i<256; i++ )
    {
     	float h = map(ro + t*rd);
        res = min( res, h/(w*t) );
    	t += clamp(h, 0.005, 0.50);
        if( res<-1.0 || t>tmax ) break;
    }
    res = max(res,-1.0); // clamp to [-1,1]

    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep
}

// Function 1171
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 24; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = .002;    
    float end = max(length(rd), .001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), 
        // clamp(h, .02, stepDist*2.), etc.
        dist += clamp(h, .02, .25);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0. || dist>end) break; 
        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me.
    return min(max(shade, 0.) + .25, 1.); 
}

// Function 1172
vec3 shade( in vec3 ro, in vec3 rd ){

    vec2 tm = castRay(ro, rd, dmax);        

    vec3 c;


    if (tm.y < 0.0) {

        c = vec3(1.0);

    } else {        

        vec3 pos = ro + tm.x*rd;
        vec3 n = calcNormal(pos);
        
        pos -= n * map(pos).x;

        vec3 color = gcolor(pos);

        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;
        vec3 R = 2.0*n*dot(n,L)-L;
        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);
        c = diffamb + spec;

    }

    return c;

}

// Function 1173
Light getLight(int i) {
    if(i==0) return lights[0]; else
        return lights[1];
    //return lights[i];
}

// Function 1174
float ao(vec3 p, vec3 n, float h) { return clamp(sdTies(p + h * n).d / h, 0., 1.); }

// Function 1175
vec3 getLightnessZcam(float rawLightness, float rawChroma, float hue) {
    ZcamViewingConditions cond = getZcamCond();

    vec3 zcam = vec3(rawChroma * 100.0, 0.0, hue);

    vec3 xyzAbs = zcamToXyz(zcam, cond);
    vec3 xyzRel = xyzAbs / cond.whiteLuminance;
    return xyzToLinearSrgb(xyzRel);
}

// Function 1176
vec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) 
{   vec3 l = lp - p;
    vec3 ldir = normalize(p-rd);
    
    float distA = max(length(l), 0.01);
    float distB = 1.0/(length(p-lp));
    float dist=(distA+distB)/2.0;
    float atten = min(1./(1. + dist*0.5), 0.2);
    l /= (dist);
    
    vec3 n = normal;
   	vec3 r = reflect(-l, n);
    
    vec3 amb=amb(col, 0.5);
    float dif = diff( p, lp, n );
    float diff=max(dot(normalize(p-lp), -n), 0.0);;
    vec3 ln=normalize(lp);
    
    float spe= spec(  p,  lp, rd, n );
    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);
    float dom = smoothstep(-1.0, 1.0, r.y);
     float bac=clamp(dot(n,-l),0.0,1.0);
    float rim=pow(1.0+dot(n,rd),3.0);
    float dn=.15*max(0.,dot(normalize(rd),-n));
    
     vec3  hal = normalize(-rd+l);
     float dif3 = clamp( dot(n,l), 0.0, 1.0 );
     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );
     float occ = 0.5 + 0.5*n.y;
    
    float fshadow;
    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);
    
    if (mObj.blnShadow==true)
        {fshadow=GetShadow(p,lp);}
    else
        {fshadow=0.5;}

    vec3 lin=vec3(1.0);
    lin*= amb*amb2*occ;
    lin += 1.0*(dif+diff+dif3)*sh;
    lin += 2.5*spe*vec3(1.0);
    lin += 2.5*fre*vec3(1.);
    lin += 0.5*dom*vec3(1.);
    lin += 0.35*bac*vec3(1.);
    lin += 0.35*rim*vec3(1.);
    lin += 0.35*rim*dn*vec3(1.);
    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;
      lin *= atten*0.5*col*fshadow;
    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; 
    lin = pow(lin,vec3(0.4545));
    return lin;
    
}

// Function 1177
float calcSoftshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.0005;                 // selfintersection avoidance distance
	float h = 1.0;
    for( int i=0; i<25; i++ )         // 40 is the max numnber of raymarching steps
    {
        h = doModel(ro + rd*t).x;
        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows
		t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances
    }
    return clamp(res,0.0,1.0);
}

// Function 1178
void geometryAndLighting(vec3 ro, vec3 rd, float t, 
                         inout vec3 pos, inout vec3 nor, 
                         inout vec3 lig, inout float dis) {
    pos = ro + rd*t;
    nor = normal(pos);
    
    lig = normalize(key - pos);
	dis = length(key - pos);
}

// Function 1179
bool shadowHit(const in Ray ray) 
{
    float _t;
    vec3 _p, _n;
    for (int i = 0; i < SPHERES_NB; i++) {
        if (intersectsSphere(ray, spheres[i], _t, _p, _n)) return true;
    }
    return false;
}

// Function 1180
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<32; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.005, 0.1 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1181
SG GetLightSG()
{
    float t = iTime * .5;
    float height = .15;
    vec3 p = vec3(cos(t), height, sin(t));
    
	SG light;
	light.Axis = normalize(p);
    light.Sharpness = 10.0;
    light.Amplitude = pow(vec3(2.5, 1.5, 1.05), vec3(2.2)) * .35;
    return light;
}

// Function 1182
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 1183
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box)
{
    draw_shadow_box(fragColor, fragCoord, box, DEFAULT_SHADOW_BOX_BORDER);
}

// Function 1184
void ProcessLightValue(float t
){oliPos[0]=vec3(6.,1.,sin(t))
 ;oliCol[0]=3.*vec4(0.2,1.,.2,1)
 ;oliPos[1]=vec3(-3,-2.2,sin(t*.3)*8.)
 ;oliCol[1]=2.*vec4(1,1,0.5,1)
 ;oliPos[2]=vec3(9.5,1.8,9.5)
 ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*vec4(1,.2,1,1);}

// Function 1185
function SetShaderConstant3F(u,x){m.uniform3fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}

// Function 1186
vec3 GetLightPos()
{
	vec3 vLightPos = vec3(0.0, 12.0, 5.0);
	#ifdef ENABLE_MONTE_CARLO         
	vLightPos += gRandomNormal * 0.2;
	#endif
	return vLightPos;
}

// Function 1187
vec4 MetaShader(vec2 uv,int shader)
{
if(uv.x<0.005 || uv.y<0.005 || uv.x>0.995 || uv.y>0.995) return vec4(0.8,0.8,0.8,1.);   
if(shader==0) return Twirl(uv);
if(shader==1) return Plasma(uv);
if(shader==2) return Room(uv);
if(shader==3) return Voronoi(uv);
if(shader==4) return Ring(uv);
if(shader==5) return Glenz(uv);
return vec4(0);
}

// Function 1188
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 1189
vec4 shade(const Ray ray) {
    
   RaycastHit obj = raycastScene(ray);
    
   if(obj.type == 0) {
     
      Ray refRay;
      refRay.origin = obj.point;
      refRay.direction = reflect(ray.direction, obj.normal);
       
      vec3 diffuse = vec3(1.,0.,0.);
      diffuse *= lighting(ray, obj);      
      
      vec3 spec = vec3(1.,1.,1.);
      spec *= specular(ray, obj, 20.);
      diffuse += spec;
       
	  return vec4(diffuse, 1.);
      
   }
     
   return vec4(0.);
        
}

// Function 1190
vec3 RectLight_shade(in RectLight light, in Material material, in vec3 P, in vec3 N, in vec3 R, float NoR)
{
    // Schlick Fresnel.
    float Fr = material.F0 + (1.0-material.F0) * pow(1.0 - NoR, 5.0);
    
    // Approximate specular/glossy.
    float theta = mix(PI*0.003, PI/2.0/3.0, material.roughness);
    float Cs = RectLight_calcWeight(P, R, light, theta);
    // Specular glossy tail. Using other than Gaussian could help. 
    float Cst = RectLight_calcWeight(P, R, light, material.tailtheta);
    
    // Crude hack for diffuse.
    // Average normal and inversed emitter direction to create
    // a vector W that points towards the light.
    vec3 W = normalize(N - light.basis[2]);
    float Cd = RectLight_calcWeight(P, W, light, PI/4.0);
	
    return light.intensity * mix(
        (Cd * max(dot(N, W), 0.0)) * material.basecolor,
        (mix(Cs, Cst, material.tailamount) * NoR) * material.specularcolor,
        Fr);
}

// Function 1191
vec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)
{
    vec3 pc=carTrafo(pos);
    vec3 glasspos=vec3(1000.);
    vec3 glassn=vec3(0.);
    float mat=distM(pos).y;
    if(mat==GLASS)
    {
        glasspos=pos;
        glassn=normalize(getGrad(pos,.001));
        enable_glass=false;
        march(pos,dir);
    }
    mat=distM(pos).y;
    
    vec3 light=getLightDir();
    float sh=1.;
#ifdef SHADOW
    vec3 posS=pos+.017*light;
    enable_car=true;
    sh=march(posS,light);
#endif
    enable_car=true;
    vec3 n=getGrad(pos,.001);
    if (length(n)<.001) n=vec3(0,0,1);
    n=normalize(n);
    if(mat==BG) n=vec3(0,0,1);

    float ao=1.;
    ao=getAO(pos,n);
    //ao=pow(ao,.5);
    ao=ao*.7+.3;
    //ao=clamp(ao*2.-1.,0.,1.);

    //vec3 light = normalize(vec3(-.5,.5,2));
    float diff=clamp(dot(n,light),0.,1.);

    diff=min(diff,sh);
    
    // no ao in lighted areas
    ao=mix(ao,1.,diff);
    ao=clamp(ao,0.,1.);
    //return vec3((diff*.6+.4)*(ao));
    

    Material mtrl=getMaterial(mat);

    // evironmental reflection
    n=normalize(n);
    if(mat==CARBODY) // brushed metal surface
    {
        vec4 r1=rand3d(pc*.1);
        vec4 r2=rand3d(pc*.05);
        // scramble normals randomly
        //n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;
        // darken randomly
        //n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;
    }
    vec3 R=reflect(dir,n);
    vec3 refl=myenv(pos,R.xyz,1.).xyz;
    //refl=refl*1.2+.3;
    float fres=abs(dot(R,n));
    fres=1.-fres;
    fres*=fres*fres;
    fres=fres*.9+.1;
    float fres0=fres;
    #ifdef SCRATCHES
    vec3 n0=n;
    int numscr=7;
    float dang=1.57*2./float(numscr);
    float ang=.5;
    refl*=1.;
    vec3 drefl=vec3(0);
    float sum=0.;
    vec3 pi=pc;
    vec3 heading=vec3(0,0,1);
    vec3 tan1=vec3(1,0,0);
    vec3 tan2=vec3(0,1,0);
    // ...trying to implement some micro scratches
    for(int i=0;i<numscr*3;i++)
    {
        n=n0;
        vec2 cs=cos(ang+vec2(0,-1.57));
        mat2 m=mat2(cs,cs.yx*vec2(-1,1));
        //dFdx()
        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;
        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);
        dn2d=dn2d*m;
        //dn2d=dn2d.yx*vec2(1,-1);
        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);
        n=normalize(n);
        R=reflect(dir,n);
        float fres=abs(dot(R,n));
        fres=1.-fres;
        fres*=fres*fres;
        fres=fres*.4+.6;
        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;
        //fact=.2;
        drefl+=fact*myenv(pos,R.xyz,1.).xyz;
        sum+=fact;
        ang+=dang;
        pi=pi.zxy;
        heading=heading.yzx;
        tan1=tan1.yzx;
        tan2=tan2.yzx;
    }
    drefl/=float(numscr);
    refl=mix(refl,drefl,mtrl.scratchy);
    #endif
    
    #ifdef RENDER_GLASS
    vec3 Rg=reflect(dir,glassn);
    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;
    //glassrefl=glassrefl*1.2+.3;
    float glassfres=abs(dot(Rg,glassn));
    glassfres=1.-glassfres;
    glassfres*=glassfres*glassfres;
    glassfres=glassfres*.7+.3;
    if(glassn==vec3(0)) glassfres=0.;
    #endif

    vec3 rcol=vec3(1);
    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;
    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;
    vec3 col=mtrl.col;
    if(mat==FLOOR) {
        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;
        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;
        #ifdef WET_ASPHALT
        col*=.35+.65*step(-.66,pos.z);
        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));
        #endif
    }

    float zr=length(pos-pos0)/300.;
    //diff=sqrt(diff);

    outfres=fres;
    if(glassfres!=0.) outfres=glassfres;
    fres*=reflections;
    glassfres*=reflections;

    outao=ao;
    
	vec3 bg=myenv(pos0,dir,1.).xyz;
	// diff, ao, refl
	vec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.35,vec3(1.,1,.9),diff)*ao*1.5;
	//finalcol=col;
	// fog
	//finalcol = mix(finalcol,bg,1.-exp(-zr));
	finalcol = mix(finalcol,vec3(.35),1.-clamp(exp(-(zr-.1)/2.5),0.,1.));
	#ifdef RENDER_GLASS
	finalcol=mix(finalcol*sqrt(1.-glassfres),glassrefl,glassfres);
	#endif
	return finalcol;
}

// Function 1192
float shadow(vec3 dir, vec3 origin, float k, int max_steps) {
    float res = 1.0;
    float t = 0.1;
    for(int i = 0; i < max_steps; ++i) {
        float m = sceneMap3D(origin + t * dir);
        if(m < 0.0001) {
            return 0.0;
        }
        //res = min(1.0, (k * m / t));
        t += m;
    }
    return res;
}

// Function 1193
bool is_point_on_LIGHT( vec2 p ) {
    //Object level culling
    Box bbox = Box( vec2(0.0), vec2(20.0,5.0) );
    if( !pointInBox( p, bbox ) )
        return false;
    
    vec2 offsetVec = vec2( 0.0 );
    
    if( is_point_on_L( p ) ||
      	is_point_on_I( p - (offsetVec += vec2(4.0,0.0)) ) ||
      	is_point_on_G( p - (offsetVec += vec2(2.0,0.0)) ) ||
      	is_point_on_H( p - (offsetVec += vec2(4.0,0.0)) ) ||
      	is_point_on_T( p - (offsetVec += vec2(4.0,0.0)) )) {
        return true;
    }
    
    return false;
}

// Function 1194
float getAO(in vec3 hitp, in vec3 normal)
{
    float dist = .3;
    vec3 spos = hitp + normal * dist;
    float sdist = map(spos).x;
    return clamp(sdist / dist, 0.4, 1.0);
}

// Function 1195
vec3 basicShade(vec3 cameraRayEnter, vec3 surfaceNormal, float distToSurface, float time, vec3 rayDir)
{
    //vec3 lightPos = vec3(-3.784, 5.0, -3.26);
    vec3 ambientColor = vec3(185.0, 110.0, 55.0) / 255.0;
    vec3 lightColor = vec3(254.0, 235.0, 197.0) / 255.0;
    vec3 lightPos = vec3(-3.784, 13.0, 4.26);
    
    float shininess = 10.0;
    vec3 lightDir = normalize(lightPos - cameraRayEnter);
    float lightDist = length(lightPos - cameraRayEnter);
    
    float backgroundMask = smoothstep(MaxDistance, MaxDistance - 20.0, distToSurface);

    float lambertShade = max(0.0, dot(lightDir, surfaceNormal)) * backgroundMask;
    float specular = 0.0;
    float dropShadow = 1.0;
    
    //Only for the side facing the light
    if(lambertShade > 0.0)
    {
        //Blinn-Phong
    	vec3 halfDir = normalize(lightDir - rayDir);
    	float specAngle = max(dot(halfDir, surfaceNormal), 0.0);
    	specular = pow(specAngle, shininess) * LightIntensity / lightDist;
        
        //Slight offset towards light dir to prevent artifacts
        dropShadow = castShadowRay(cameraRayEnter + lightDir * 0.4, lightDir, time, 12.0);
        
		dropShadow *= smoothstep(0.0, 0.2, lambertShade);
    }
    
   	vec3 baseShade = lightColor * lambertShade * dropShadow + ambientColor * AmbientStr;
    
    vec3 color = mix(baseShade, lightColor * specular * dropShadow, 0.5);
    
    if(cameraRayEnter.y <= GroundHeight + 0.001)
    {
        //The chessboard
        
        //This was the old, non-antialiased way
       	//vec2 id = floor(cameraRayEnter.xz / SquareSize + vec2(0.5));
        //float bw = mod((id.x + id.y), 2.0);
        
        vec2 squareCoord = fract(cameraRayEnter.xz / SquareSize + vec2(0.5));
        float bw = checkers(cameraRayEnter.xz / SquareSize + vec2(0.5));
    	color *= texture(iChannel0, squareCoord).rgb * (bw * 0.9 + 0.1);        
    }

    float shadow = 1.0;
    if(piecePresent(cameraRayEnter, time))
    {
    	shadow = aoPawn(worldToPawnCoords(cameraRayEnter, time));
    }
    
    vec3 bgColor = texture(iChannel1, rayDir).xyz;
    return mix(bgColor, color * shadow, backgroundMask);
}

// Function 1196
float light(vec3 n,vec3 pos,vec3 eye,vec3 lpos)
{
    lpos.y += sin(lpos.x/10.)*3.;
    vec3 ldir = normalize(lpos - pos);
    float dd = length(lpos - pos);
    
    pos += n*.02;
    vec3 spos = pos;
    float d,sh=1.;			// stopien zacienienia (1-pelne swiatlo, 0-czarno)
    float dist = 0.001;		// przebyty dystans
    for(int i=0;i<30;i++)
    {
    	vec3 tpos = pos + (lpos-pos)*(float(i)/100.);
        d = fn(tpos);
        dist += d;
        sh=min(sh,d*20.);
    }
    vec3 eyeref = normalize(reflect(pos-eye,n));
    float diff = clamp(dot(n,ldir),0.,1.);
    float spec = pow(clamp(dot(eyeref,ldir),0.,1.),16.)*clamp(diff*20.,0.,1.);
    float spec2 = pow(clamp(dot(eyeref,ldir),0.,1.),64.)*clamp(diff*20.,0.,1.);
    float attn = 1./(dd*dd);
    
    return (diff*.1 + spec*2. + spec2*15./pow(attn,.15))*sh*attn*100.;
}

// Function 1197
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    #ifdef DISABLE_SHADOWS
        return 1.;
    #endif
    float res = 1.0;
    float t = mint;
    float ph = 1e10;
    
    for( int i=ZERO; i<256; i++ )
    {
        float h = map( ro + rd*t ).d;
        res = min( res, 10.0*h/t );
        t += h;
        if( res<0.0001 || t>tmax ) break;
        
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1198
float ObjSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  vec2 gIdP;
  float sh, d, h;
  sh = 1.;
  gIdP = vec2 (-999.);
  d = 0.05;
  for (int j = VAR_ZERO; j < 30; j ++) {
    p = ro + d * rd;
    gId = PixToHex (p.xz / hgSize);
    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {
      if (gId != gIdP) {
        gIdP = gId;
        SetObjConf ();
      }
      h = ObjDf (p);
      sh = min (sh, smoothstep (0., 0.05 * d, h));
    } else h = 0.1;
    d += clamp (h, 0.01, 1.);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1199
vec3 shadeWetSandR( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )
{
    // Get the reflected ray direction.
    vec3 r = reflect(d,n);
    

    vec3 reflection = sky(r,ld);
  //  #endif
    // Create a standard Phong specular term to spice things up in
    // the shiny department.
    vec3 specular = pow(max(dot(r,ld),0.0),350.0)*sunColor(ld);
    // Get the reflectance of the surface given the angle of incidence.
    float reflectance = max(length(cross(n,d)),0.0);
    // Get the diffuse term. (discussed in shadeWetSand().)
    vec3 diffuse = tex*i*.5;
    // Return a blend of the reflection and the sand and the specular highlight.
    return mix(diffuse, reflection, pow(reflectance,128.0))+specular;
}

// Function 1200
vec4 voxelAo(vec3 pos, vec3 d1, vec3 d2) {
	vec4 side = vec4(getVoxel(pos + d1), getVoxel(pos + d2), getVoxel(pos - d1), getVoxel(pos - d2));
	vec4 corner = vec4(getVoxel(pos + d1 + d2), getVoxel(pos - d1 + d2), getVoxel(pos - d1 - d2), getVoxel(pos + d1 - d2));
	vec4 ao;
	ao.x = vertexAo(side.xy, corner.x);
	ao.y = vertexAo(side.yz, corner.y);
	ao.z = vertexAo(side.zw, corner.z);
	ao.w = vertexAo(side.wx, corner.w);
	return 1.0 - ao;
}

// Function 1201
vec3 shade(Ray ray) {
 
    RaycastHit scene = intersectScene(ray);
    
    if(scene.id == 0) {
     
        vec2 uv = scene.n.xy;
        uv = asin(uv) / 3.14159 * .5;
        
        vec3 sun = normalize(vec3(45.,50.,-46.));
        float diff = .2 + max(dot(sun,scene.n), 0.);
        
        vec3 rd = normalize(reflect(ray.dir, scene.n));
        float spec = pow(max(dot(rd,sun), 0.), 15.);
        
        return texture(iChannel0, uv).xyz * diff + spec;
        
    }
    
    return mix(vec3(.2,.2,.8),vec3(.6,.6,.8),pow(ray.dir.y + .5,.7));
    
}

// Function 1202
float calcAO( in vec3 pos, in vec3 nor, float t )
{
	float occ = 0.0;
    for( int i=0; i<8; i++ )
    {
        float h = 0.005 + 0.25*float(i)/7.0;
        vec3 dir = normalize( sin( float(i)*73.4 + vec3(0.0,2.1,4.2) ));//+ gl_FragCoord.x*17.0 + gl_FragCoord.y*13.0 ) );
        dir = normalize( nor + dir );
        occ += (h-map( pos + h*dir, t ).x);
    }
    return clamp( 1.0 - 9.0*occ/8.0, 0.0, 1.0 );    
}

// Function 1203
vec3 calcLightOnSurface( RayHit hit ) {
    vec3 Lo = vec3( 0.0 );
    Material surfMtl = getMaterialFromLibrary( hit.materialId );

    if( surfMtl.bsdf_ == BSDF_R_LIGHT ) {
        Lo = surfMtl.color;
    } else {
        vec3 surfColor = surfMtl.color;
        float specVal = 0.7;
            
        if( hit.materialId == MTL_WALL ) {
            surfColor = texture( iChannel0, hit.uv ).xyz;
        } else if( hit.materialId == MTL_SPHERE ) {
            surfColor = texture( iChannel1, hit.uv ).xyz;
            specVal = 1.0 - BRIGHTNESS(texture( iChannel1, hit.uv ).xyz);
        }
        
        vec3 wi;
        
        for( int i=0; i<LIGHT_COUNT; i++ ) {
            vec3 Li = materialLibrary[i].color;
            vec3 directLight = calcDirectLight( hit.pos, wi, spherelight[i], Li );
            
            if( dot( wi,hit.normal ) > 0.0 ) {
                vec3 cdiff = vec3( specVal );
                vec3 cspec = vec3( 1.0 - specVal );
                vec3 brdf = evalBRDF( hit.normal, wi, hit.E, 0.4, cdiff, cspec );

                Lo += directLight*brdf*surfColor;
            }
        }
        Lo *= 1.0/float(LIGHT_COUNT);
    }
    
    return Lo;
}

// Function 1204
float SoftShadow(in vec3 ro, in vec3 rd) {
    float res = 1.0, h, t = .005+hash13(ro)*.02;
    float dt = .01;
    for( int i=0; i<32; i++ ) {
		h = map( ro + rd*t );
		res = min( res, 10.*h/t );
		t += dt;
        dt+=.0025;
        if (h<PRECISION) break;
    }
    return clamp(res, 0., 1.);
}

// Function 1205
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.612*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.5;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1206
vec3 addLight(vec3 eye, vec3 ray, float res, float time, float height) {
    vec2 q = eye.xy + ((height - eye.z) / ray.z) * ray.xy;

    float row = floor(q.x + 0.5);
    time += hash1(row);
    float col = floor(0.125 * q.y - time);

    float pos = 0.4 + 0.4 * cos(time + tau * hash1(vec2(row, col)));
    vec3 lightPos = vec3(row, 8.0 * (col + time + pos), height);
    vec3 lightDir = vec3(0.0, 1.0, 0.0);

    // http://geomalgorithms.com/a07-_distance.html
    vec3 w = eye - lightPos;
    float a = dot(ray, ray);
    float b = dot(ray, lightDir);
    float c = dot(lightDir, lightDir);
    float d = dot(ray, w);
    float e = dot(lightDir, w);
    float D = a * c - b * b;
    float s = (b*e - c*d) / D;
    float t = (a*e - b*d) / D;

    t = max(t, 0.0);
    float dist = distance(eye + s * ray, lightPos + t * lightDir);

    float mask = smoothstep(res + 0.1, res, s);
    float light = min(0.005 / (dist * dist / t + 0.1 * t * t), 2.0);
    float fog = exp(-fogDensity * max(s - fogOffset, 0.0));
    vec3 color = mix(lightColorA, lightColorB, hash3(vec2(row, col)));
    return mask * light * fog * color;
}

// Function 1207
float hardShadow(vec3 dir, vec3 origin, float min_t) {
    float t = min_t;
    for(int i = 0; i < RAY_STEPS; ++i) {
        float m = sceneMap3D(origin + t * dir, LIGHT_POS);
        if(m < 0.0001) {
            return 0.0;
        }
        t += m;
    }
    return 1.0;
}

// Function 1208
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).dist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1209
mat lights(inout hit h, ray r) {
    vec3 l = h.l*2.4-1.4; //scale and translate lights
    float b = (1.+sin(l.x-cos(l.x))) * (1.+sin(l.z-cos(l.z))), //brightness
          f = step(b, 0.1); //light or mirror
    return mat(
    	vec3(f*.8),
    	vec3(1.,.8,.6)*pow(b, 5.)*.01,
        vec2(1.-f, .1),
        vec2(0.),
        -1., 0., 42
    );
}

// Function 1210
float GrndAO (vec3 p)
{
  vec3 pMin, pMax, s;
  float ao, f;
  ao = 1.;
  pMin = Loadv4 (vec2 (1, nBallE)).xyz;
  pMax = Loadv4 (vec2 (2, nBallE)).xyz;
  s = abs (p - 0.5 * (pMin + pMax)) - 0.5 * (pMax - pMin) - 1.5;
  f = 0.5 * float (nBallE - 1);
  if (s.x < 0. && s.z < 0.) {
    for (int iy = 0; iy < nBallE; iy ++) {
      for (int ix = 0; ix < nBallE; ix ++) {
        if (length (vec2 (ix, iy) - vec2 (f)) < f + 0.5)
           ao = min (ao, smoothstep (0.1, 2., length (GetR (vec2 (ix, iy)) - p) - 0.5));
      }
    }
  }
  return 0.8 + 0.2 * ao;
}

// Function 1211
float calcAO( in vec3 pos, in vec3 nor )
{
	float totao = 0.0;
    float sca = 1.0;
    for( int aoi=0; aoi<5; aoi++ )
    {
        float hr = 0.01 + 0.05*float(aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        totao += -(dd-hr)*sca;
        sca *= 0.75;
    }
    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );
}

// Function 1212
float shadow(vec3 ro, vec3 rd, float k)
{
	float res = 1.0;
    float t = EPSILON;
    for( int i=0; i<1000; i++)
    {
        float h = distanceField(ro + rd*t);
        if( h<EPSILON )
            return AMBIENT;
        res = min( res, k*h/t );
        t += h;
        if(t>=SHADOWDEPTH) break;
    }
    return res;
}

// Function 1213
void  lightDiffusion(out voxel vox, in voxel temp ,vec3 rPos){
    if(vox.id != 6. && vox.id != 26.){
 	   vox.light.s =  max( vox.light.s ,  	temp.light.s  -(rPos.z==1.?0.:1.) - (temp.id==0.?0.: temp.id==11.?5.:15.));       	
 	   vox.light.t =  max( vox.light.t- 1.,   temp.light.t -1.); //- (temp.id==0. || temp.id==26. || temp.id==12. ?0.: 5.));
    }        
}

// Function 1214
void Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)
{
	float fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);
	
	lighting.vDiffuse += vLightColour * fNDotL;
    
	vec3 vH = normalize( -vViewDir + vLightDir );
	float fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);
	float fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);
    
	// D

	float alphaSqr = AlphaSqrFromGloss( surface.fGloss );
    float alpha = sqrt( alphaSqr );
	float denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;
	float d = alphaSqr / (PI * denom * denom);

	float k = alpha / 2.0;
	float vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);

	float fSpecularIntensity = d * vis * fNDotL;    
	lighting.vSpecular += vLightColour * fSpecularIntensity;    
}

// Function 1215
vec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)
{
vec3 color;
    

    sn = bumpMap(iChannel0, sp, sn, 0.0015);
    vec3 lv = lp - sp;
    float ldist = max(length(lv), 0.01);
    vec3 ldir = lv/ldist;
    
    float atte = 1.0/(1.0 + 0.002*ldist*ldist );
    
    float diff = dot(ldir, sn);
    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);
    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);
	float ao = calculateAO(sp, sn);
    
    vec3 refl = reflect(rd, sn);
    vec3 refr = refract(rd, sn, 0.7);
    
   vec3 color2 = vec3(0.2, 0.5, 0.9);
    vec3 color3 = vec3(0.0);

    vec3 coolSpec = vec3(.3, 0.5, 0.9);
    vec3 hotSpec = vec3(0.9,0.5, 0.2);
   color2 = triPlanar(iChannel0, sp, sn);
    
    //apply color options and add refl/refr options
    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;
	
    
    //apply ambient occlusion and return.
 return color*ao;   
}

// Function 1216
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res = 2.0, t = 0.02, h;
  for ( int i=0; i<24; i++ )
  {
    h = MapPlane(origin+direction*t);
    res = min( res, 7.5*h/t );
    t += clamp( h, 0.05, 0.2 );
    if ( h<0.001 || t>2.5 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 1217
vec4 Shade(float distance)
{
	float c1 = saturate(distance*5.0 + 0.5);
	float c2 = saturate(distance*5.0);
	float c3 = saturate(distance*3.4 - 0.5);
	vec4 a = mix(Color1,Color2, c1);
	vec4 b = mix(a,     Color3, c2);
	return 	 mix(b,     Color4, c3);
}

// Function 1218
vec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {
	float sha=shadow(p); 
    float aoc=ao(p,n);
    float amb=.25*aoc; // ambient light with ambient occlusion
    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow
    vec3 ref=reflect(dir,n); // reflection vector
    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    
    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color
}

// Function 1219
float GetShadows( in vec3 ro, in vec3 rd)
{
	float shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));
    
    
	float shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));
	
	return smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));
}

// Function 1220
vec3 shade(vec3 rpos, vec3 rdir, float t, vec3 pos) {
	float watert = ((rpos.y - waterHeight) / rdir.y);
	
	// Calculate fog
	float b = 0.01;
	float fogt = min(watert, t);
	float fog = 1.0 - FOG_BASE * exp(-rpos.y*b) * (1.0-exp(-fogt*rdir.y*b)) / rdir.y;
	vec3 fogColor = calculateFogColor(rpos, rdir);

	vec4 ns = texture(iChannel0, pos.xz * 0.1);
	
	if (fog < 0.01) return fogColor;
	
	vec3 nl = normal(pos);
	vec3 n = normalHigh(pos);
	float h = pos.y;
	
	float slope = n.y;
	vec3 albedo = vec3(0.36, 0.25, 0.15);
	
	// Apply texture above water
	if (watert > t) {
		float snowThresh = 1.0 - smoothstep(-50.0, -40.0, h) * 0.4 + 0.1;
		float grassThresh = smoothstep(-70.0, -50.0, h) * 0.3 + 0.75;
		
		if (nl.y < 0.65)
			albedo = mix(albedo, vec3(0.65, 0.6, 0.5), smoothstep(0.65,0.55,nl.y));
		if (slope > grassThresh - 0.1)
			albedo = mix(albedo, vec3(0.4, 0.6, 0.2), smoothstep(grassThresh-0.1,grassThresh+0.1,slope));
		if (slope > snowThresh - 0.1)
			albedo = mix(albedo, vec3(1.0, 1.0, 1.0), smoothstep(snowThresh-0.1,snowThresh+0.1,slope));
	}
	
	// Fade in 'beach' and add a bit of noise
	albedo = mix(albedo, vec3(0.6, 0.5, 0.2), smoothstep(-waterHeight+4.0,-waterHeight+0.5,h));
	albedo *= ns.rgb * 0.1 + 0.95;
	
	// Lighting
	float diffuse = clamp(dot(n, lightDir), 0.0, 1.0);
	#ifdef SHADOWS
	if (diffuse > 0.005) diffuse *= shadow(pos, vec3(lightDir.xy, -lightDir.z));
	#endif
	vec3 col = vec3(0.0);
	col += albedo * vec3(1.0, 0.9, 0.8) * diffuse;
	col += albedo * fogColor * max(n.y * 0.5 + 0.5, 0.0) * 0.5;
	
	// Shade water
	if (t >= watert) {
		float dist = t - watert;
		vec3 wpos = rpos+rdir*watert;
		col *= exp(-vec3(0.3, 0.15, 0.08)*dist);
		
		float f = 1.0 - pow(1.0 - clamp(-rdir.y, 0.0, 1.0), 5.0);
		vec3 refldir = rdir * vec2(-1.0, 1.0).yxy;
		refldir = normalize(refldir + ns.xyz * 0.1);
		vec3 refl = calculateFogColor(wpos, refldir);
		col = mix(refl, col, f);
	}
	
	return mix(fogColor, col, fog);
}

// Function 1221
vec3 lighting(in vec3 hit, in vec3 rd, in vec3 norm, in vec3 diffuseColor) {
    vec3 ret;

    vec3 lr = normalize(hit-Light0);
    float diff = max(dot(norm, -lr),0.0);
    vec3 refL = reflect(lr, norm);
    float spec = pow(max(dot(refL, -rd),0.0), Shininess);
    vec3 diffComp = diffuseColor * diff;
    vec3 specComp = vec3(spec);
    vec3 ambientComp = diffuseColor*.3;

    // Add a flashlight with the camera
    diffComp = mix(diffComp, abs(dot(rd, norm))*diffuseColor, .5);
    ret = diffComp + .2 * specComp + ambientComp;

    lr = normalize(hit - Light1);
    diff = max(dot(norm, -lr), 0.0);
    refL = reflect(lr, norm);
    spec = pow(max(dot(refL, -rd),0.0), Shininess);
    diffComp = diffuseColor * diff;
    specComp = vec3(spec);

    diffComp = mix(diffComp, abs(dot(rd, norm))*diffuseColor, .5);
    ret = mix(diffComp + .2 * specComp + ambientComp, ret, .5);

    return ret;
}

// Function 1222
float softshadow(in vec4 ro, in vec4 rd, in float mint) {
	float h, t=mint, res=1.;
    for (int i=0; i<16; i++ ) {
        h = map(ro+rd*t);
        if ((h)<.1) break;
        res = min(res, 7.*h/t);
        t += 0.04;
    }
    return clamp(res-.6, 0., 1.);
}

// Function 1223
float shadow(vec3 pos, vec3 sdir) {//THIS ONLY RUNS WHEN WITH HARD SHADOWS
	float sh=1.0;
	float totdist =2.0*det;
	float dist=5.;
		for (int steps=0; steps<SHADOW_STEPS; steps++) {
			if (totdist<4. && dist>detail) {
				vec3 p = pos - totdist * sdir;
				dist = de(p).x;
				sh = min( sh, max(20.*dist/totdist,0.0) );
				totdist += max(.01,dist);
			}
		}
	
    return clamp(sh,0.1,1.0);
}

// Function 1224
vec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, float _hm)
{
    #define ERR vec3(1., 0., 0.)
    float tmin = -1.0;
    float tmax = -1.0;
    float d = IntersectSphere(ro, rd, vec3(0.), ATMOSPHERE_RADIUS, tmin, tmax);
    
    //tmax = max(1., min(max(0., temin), tmax));
  
    float RdotL = dot(rd, L);
    float tCurrent = 0.;
    float segL = (tmax-tCurrent)/16.0;
     
    float g = 0.76; // 0.76
    float g2 = g*g;
    float hr = 7994.0; // 7994
    float hm = _hm;//800.0; // 1200
    // Rayleigh
    vec3 sumR = vec3(0.0);
    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);
    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);
    float opticalDepthR = 0.0;
    // Mie
    vec3 sumM = vec3(0.0);
    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));
    // correction thanks to http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html
    // my implementation had an error with the first terms in the equation
    float phaseM = (
        			(3.0*(1.0-g2))/
        			(2.0*(2.0+g2))
        			)*
        			(
                        (1.0+RdotL*RdotL)/
                        pow(1.0+g2-2.0*g*RdotL, 1.5)
                    );
    //vec3 betaM = vec3(21e-6);
    float opticalDepthM = 0.0;
    for (int i = 0; i < 16; ++i)
    {
        vec3 X = ro+rd*(tCurrent+0.5*segL);
        float h = length(X) - EARTH_RADIUS;
        float _hr = exp(-h/hr)*segL;
        float _hm = exp(-h/hm)*segL;
        opticalDepthR += _hr;
        opticalDepthM += _hm;
        vec3 lRay = L;//normalize((SUNDIST*L)-X);
        float tlmin = 0.0;
        float tlmax = 0.0;
        float tlemin, tlemax;
        //vec3 Ll = normalize(Lpos-X);
        //float dl = IntersectSphere(X, Ll, vec3(0.), ATMOSPHERE_RADIUS, tlmin, tlmax);
        
        float tCurrentLight = 0.;
        float segLLight = (tlmax-tCurrentLight)/8.0;
        tCurrentLight = max(0., tlmin);
        segLLight = (tlmax-tCurrentLight)/8.;
        float opticalDepthLightR = 0.0;
        float opticalDepthLightM = 0.0;
        bool ended = true;
        for (int j = 0; j < 8; ++j)
        {
            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);
            float hLight = length(samplePositionLight) - EARTH_RADIUS;
            if (hLight < 0.0)
            {
                ended = false;
                break;
            }
            opticalDepthLightR += exp(-hLight / hr) * segLLight;
            opticalDepthLightM += exp(-hLight / hm) * segLLight;
            tCurrentLight += segLLight;
        }
        if (ended)
        {
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);
            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));
            sumR += _hr * attenuation;
            sumM += _hm * attenuation;
        }
        tCurrent += segL;
    }
    return LIGHT_MOON_INTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);
}

// Function 1225
vec3 sampleLightSource(in vec3 x, in vec3 n, float Xi1, float Xi2, out LightSamplingRecord sampleRec) {
    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -
        				 vec3(0., 0., 1.) * light.size.y * 0.5;
    vec3 ex = vec3(light.size.x, 0., 0.);
    vec3 ey = vec3(0., 0., light.size.y);
    
    SphQuad squad;
    SphQuadInit(s, ex, ey, x, squad);
    SphQuadSample(x, squad, Xi1, Xi2, sampleRec);
    
    //we don't have normal for volumetric particles
    if(dot(n,n) < EPSILON) {
        SphQuadSample(x, squad, Xi1,Xi2, sampleRec);
    } else {
        LightSamplingRecord w[CDF_SIZE];
        float ww[CDF_SIZE];
        const float strata = 1.0 / float(CDF_SIZE);
        for(int i=0; i<CDF_SIZE; i++) {
            float xi = strata*(float(i)+rnd());
            SphQuadSample(x, squad, xi, rnd(), w[i]);
            ww[i] = (i == 0)? 0.0 : ww[i-1];
            ww[i] += max(0.0, dot(w[i].w, n));
        }

        float a = Xi1 * ww[CDF_SIZE-1];
        for(int i=0; i<CDF_SIZE; i++) {
            if(ww[i] > a) {
                sampleRec = w[i];
                sampleRec.pdf *= (ww[i] - ((i == 0)? 0.0 : ww[i-1])) / ww[CDF_SIZE-1];
                sampleRec.pdf *= float(CDF_SIZE);
                break;
            }
        }
    }
    
	return getRadiance(vec2(Xi1,Xi2));
}

// Function 1226
float card_shadow(vec2 p) {
    float d = 0.;
    d = SS(-0.01, 0.02 + zv, sdBox(p, vec2(0.08, 0.12)));
    return d;
}

// Function 1227
float shadow(i3 o,i3 i){
 const float a=32.;//shadow hardnes
 float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance
 for(int j=0;j<IterSh;j++){
  h=dm(o+i*t).x;
  r=min(r,h*a/t);
  t+=clamp(h,.02,2.);}//limit max and min stepping distances
 return clamp(r,0.,1.);}

// Function 1228
vec3 calcDirectLight( vec3 pos, out vec3 wi, Sphere lightSphere, vec3 lightColor ) {
    vec3 Li = lightColor;
    vec3 Lo = vec3( 0.0 );
    
    vec3 dirToLightCenter = lightSphere.pos - pos;
    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);
    float cos_a_max = sqrt( 1.0 - clamp( lightSphere.radiusSq / distToLightCenter2, 0.0, 1.0 ) );
    float omega = TWO_PI * (1.0 - cos_a_max);	//solid angle
    float cosa = mix(cos_a_max, 1.0, rnd());
    float sina = sqrt(1.0 - cosa*cosa);

    wi = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );
    float pWi = (1.0/omega);

    Ray shadowRay = Ray( pos, wi );
    float dist;
    raySphereIntersection( shadowRay, lightSphere, dist );

    float tmpDist;
    RayHit tmpHit;
    int tmpObjId;
    raySceneIntersection( shadowRay, EPSILON, tmpHit, tmpObjId, tmpDist );
    float eps = tmpDist*0.0001;

    if( EQUAL_FLT( tmpDist, dist, eps ) ) {
        Lo += ( Li ) / pWi;
    }

    return Lo;
}

// Function 1229
float sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )
{
    vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    return (b>0.0) ? step(-0.0001,c) : smoothstep( 0.0, 1.0, h*k/b );
}

// Function 1230
void ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in float reflectionAmount, in vec3 rayDir)
{
	if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))
	{
		// diffuse
		float dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);
		if(dp > 0.0)
			pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;
		
		// specular
		vec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;			
	}
}

// Function 1231
float softShadow(vec3 ro, vec3 lp, float k) {
    const int maxIterationsShad = 38;
    vec3 rd = (lp - ro); // Unnormalized direction ray.

    float shade = 10.0;
    float dist = .05;
    float end = max(length(rd), 0.001);
    float stepDist = end / float(maxIterationsShad);

    rd /= end;
    for (int i = 0; i < maxIterationsShad; i++) {
        float h = map(ro + rd * dist).x;
        shade = min(shade, k*h/dist);
        dist += min(h, stepDist * 2.); 
        if (h < 0.001 || dist > end) break;
    }
    return min(max(shade, 0.4), 2.0);
}

// Function 1232
vec3 directLight(vec3 pos, vec3 n){
	vec3 totLights = vec3(0.0);
    //purple light
	totLights += nee(pos, n, vec3(0, 5, -1), vec3(.7, .5, .3) * 20.0);
    //yellow light
	totLights += nee(pos, n, vec3(0, -5, -1), vec3(.7, .3, .5) * 20.0);
	return totLights * 1.0;
}

// Function 1233
void shadow(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)
{
    float tSphere6 = intersectSphere(ro, rd, sfere[3]);
    if(tSphere6 < t && bl) { t = tSphere6;i=6;}

   	float tSphere = intersectSphere(ro, rd, sfere[2]);
    if(tSphere < t) { t = tSphere;i=2;}
    
    vec2 tRoom = intersectCube(ro, rd, box0);          
   	if(tRoom.x < tRoom.y)   t = tRoom.y; 
    vec3 hit = ro + rd * t;  
    if(hit.y > 0.9999 && hit.x<1.3 && hit.x>-1.3 && hit.z<1.99 && hit.z>1.0) t=10000.0;

}

// Function 1234
float shadow_box(vec2 fragCoord, vec4 box, float border)
{
    vec2 clamped = clamp(fragCoord, box.xy, box.xy + box.zw);
    return clamp(1.25 - length(fragCoord-clamped)*(1./border), 0., 1.);
}

// Function 1235
float calculate_aO(vec3 p, vec3 n) {
	const float AO_SAMPLES = 5.;
	float r = 0., w = 1., d;

	for (float i = 1.; i < AO_SAMPLES + 1.1; i++) {
		d = i / AO_SAMPLES;
		r += w * (d - de(p + n * d));
		w *= .5;
	}

	return 1. - clamp(r, 0., 1.);
}

// Function 1236
SDFResult lightSDF( vec3 p )
{
    float cablelen = g_lightpivot.y - g_lightpos.y;
    vec3 vecY = g_light.pos - g_lightpivot;
    vecY = normalize(vecY);
        
    SDFResult res = vertcapSDF2(VertCap(g_lightpivot, cablelen-0.1, 0.005, WHITE), vecY, p);
    return res;
}

// Function 1237
float cao(in vec3 p, in vec3 n)
{
	float sca = 1., occ = 0.0;
    for( int i=1; i<6; i++ ){
    
        float hr = float(i)*.25/5.;        
        float dd = m(p + hr*n);
        occ += (hr - dd)*sca;
        sca *= .7;
    }
    return clamp(1. - occ, 0., 1.);   
    
}

// Function 1238
vec3 shadeTrunk(vec3 p, vec3 ray) {
    vec3 col = vec3(0.59, 0.286, 0.005);
    
    col += fbm(p*142.857, 1., 3)*0.5;
    
    col *= 0.65;
    return col;
}

// Function 1239
float softProjLight( vec3 o, vec3 L, vec3 N)
{
    float coneWidth   = 0.1;
    float minAperture = 1.0; 
    float t = 0.001;
    for( int i=0; i<8; i++ )
    {
        vec3 p = o+L*t;
        float dist = map( p ).d;
        float curAperture = dist/t;
        minAperture = min(minAperture,curAperture);
        t += 0.05+dist;
    }
    return saturate(minAperture/coneWidth)*dot(L,N);
}

// Function 1240
vec3 getLight(vec3 p, vec3 n, vec3 lp){
    
    vec3 ld = lp - p;
    float lDist = length(ld);
    ld /= lDist;
    float diff = max(dot(ld, n), 0.);
    float atten = 1.5/(1. + lDist*lDist);
    vec3 light = vec3(1)*(diff + .5)*atten;
    
    return light;
}

// Function 1241
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) 
{
    float sh = 1.0;
    float t = mint;
    float h = 0.0;
    for(int i = 0; i < 19; i++)  //23 gut!
	{
        if(t > maxt) continue;
		orbitTrap = vec4(10.0);
        h = map(ro + rd * t);
        sh = min(sh, k * h / t);
        t += h;
    }
    return sh;
}

// Function 1242
TraceLightResult traceLights(Light lights[LIGHTS_NUM], vec3 orig, vec3 dir) 
{
    TraceLightResult res;
    res.dist = INF;
    

    for (int i = 0; i < LIGHTS_NUM; i++) {
        Light light = lights[i];
        TraceResult tLight = traceLight(light, orig, dir);
        if (tLight.hit && tLight.dist < res.dist) {
            res.color = light.color;
            res.n = tLight.n;
            res.dist = tLight.dist;
        }
    }
    
    res.hit = res.dist >= 0.0 && res.dist < INF;
    return res;
}

// Function 1243
void
   
    light( ) {

        vec3
            d = L1P - hit.p;
        
        float
            f = dot( d, d ),
        	b = pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 1. );
        
        d = L2P - hit.p;
        f = dot( d, d );
            b += pow( clamp( dot( d, hit.n ) / f, 0., 1. ), 11. );
        
        b = .252422 + .52441 * b;
        
        col = 
            hit.i == NOO
            	? vec4( b * vec3( .71231, .8521, .913331 ), 1. )
            	: hit.i == SPH 
                    ? vec4( b * getPix( hit.p.xz  / ( 1. - hit.p.y ) ), 1. )
                    : vec4( b * ( vec3( .3, .4, .5 ) + getPix( hit.p.xz ) ), sin( t ) );
    }

// Function 1244
mat4 getLightInfo(int litID, vec3 pos)
{
	mat4 lit = mat4(0);
    if (0 == litID)
    {
		lit[0] = vec4(3,5, 3,0);
        lit[1] = vec4(0);
    }
    lit[3].xyz = mix(normalize(lit[0].xyz - pos), lit[0].xyz, lit[0].w);

	return  lit;
}

// Function 1245
vec3 shade (vec3 p, vec3 n){
    vec3 lFinal = vec3(0.0);
    
    //Light 0
    {
        vec3 col = vec3(0.0);
        vec3 lipos = vec3(cos(iTime)*50.0, 30.0, sin(iTime)*50.0+10.0);
        vec3 licol = vec3(abs(sin(iTime)), abs(cos(iTime)), abs(sin(iTime*0.2)));
        float reflectance = 1.5;

        vec3 lidir = normalize(lipos - p);
        vec3 libir = licol * dot(n, lidir);
        
        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);
        
        col += reflectance * libir;
        col *= 1.0 - (length(p - lipos)*0.01);
        col -= 1.0-sh;
        col = clamp (col, 0.0, 1.0);
        lFinal += col;
    }
    
    //Light 1
        {
        vec3 col = vec3(0.0);
        vec3 lipos = vec3(-cos(iTime)*20.0, 30.0, -sin(iTime)*20.0+10.0);
        vec3 licol = vec3(1.0);
        float reflectance = clamp(sin(iTime/3.0), 0.0, 1.0)*1.5;

        vec3 lidir = normalize(lipos - p);
        vec3 libir = licol * dot(n, lidir);
            
        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);
            
        col += reflectance * libir;
        col *= 1.0 - (length(p - lipos)*0.01);
        col -= 1.0-sh;
        col = clamp (col, 0.0, 1.0);
        lFinal += col;
    }
        //Light 2
        {
        vec3 col = vec3(0.0);
        vec3 lipos = vec3(0.0, 60.0, 0.0);
        vec3 licol = vec3(1.0);
        float reflectance = clamp(1.0, 0.0, 1.0)*1.5;

        vec3 lidir = normalize(lipos - p);
        vec3 libir = licol * dot(n, lidir);
            
        float sh = clamp(shadow(p, normalize(lipos - p)), 0.0, 1.0);
            
        col += reflectance * libir;
        col *= 1.0 - (length(p - lipos)*0.01);
        col -= 1.0-sh;
        col = clamp (col, 0.0, 1.0);
        lFinal += col;
    }

    return clamp(lFinal, vec3(0.0), vec3(1.0));
    
}

// Function 1246
float
shadow( in vec3 start, in vec3 dir )
{
    float ret = 1.0;
    float c = step( mod( iTime, 4.0 ), 2.0 );
    float t = 0.02, t_max = 16.0;
    MPt mp;
    
    for ( int it=0; it!=16; ++it )
    {
        vec3 here = start + dir * t;
        mp = map( here );
        ret = min( ret, 8.0*mp.distance/t);
        if ( mp.distance < ( T_EPS * t ) || t > t_max )
        {
        	break;
        }
        
        float inc;
        // NOTE(theGiallo): this is to sample nicely the twisted things
        inc = c * mp.distance * 0.4;
		inc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );
        t += inc;
    }
    if ( t > t_max )
    {
        t = -1.0;
    }
    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );

    if ( t < 0.0 )
    {
        return 0.0;
    }
    //return 1.0;
    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );
    float th = 0.1;
    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );
}

// Function 1247
void DoTheLighting(RayIntersection ri, out vec4 c)
{
    float attByDst;
    float NoL, specAngle;
    float shadow, ao;
    float d2l = MAX_DISTANCE;
    vec3  diffuse, specular;
    vec3  L, halfVec;
    vec4  ambient;
    
    if (ri.shape.texID != 0)
    {
        ri.shape.color.rgb *= TriplanarTextureMapping(ri.pos,
                                                     ri.shape.normal.xyz,
                                                     ri.shape.texID);
    }
    
	for (int i=0; i<NUM_LIGHTS; i++)
    {
        if (scene.lights[i].type == DIRECTIONAL)
        {
            L 		 = -scene.lights[i].dir;
            attByDst = 1.0;
        }
        else if (scene.lights[i].type == POINT)
        {
            vec3  p2l = scene.lights[i].pos - ri.pos;
            d2l = length(p2l); 
            if (d2l > scene.lights[i].range) continue;
            attByDst = (scene.lights[i].range - d2l) / scene.lights[i].range;
            L = normalize(p2l);
        }

        // BLINN-PHONG
        // Diffuse component
        NoL      = clamp(dot(L, ri.shape.normal.xyz), .0, 1.0);
        diffuse += NoL * attByDst *
            	   scene.lights[i].color * scene.lights[i].intensity;
        
        // Specular component
        if (NoL >= .0 && ri.shape.glossy > .0)
        {
            halfVec    = normalize(-ri.ray.d + L);
            specAngle  = clamp(dot(ri.shape.normal.rgb, halfVec), .0, 1.0);
            specular  += pow(specAngle, ri.shape.glossy*512.) * attByDst *
                		 scene.lights[i].color * scene.lights[i].intensity;
        }

        shadow += ComputeShadow(ri.pos, ri.shape.normal.xyz, L, d2l);
    }
    // Ambient Occlusion
    ao = ComputeAO(ri.pos, ri.shape.normal.xyz);
    
    //ambient = AMBIENT_LIGHT;
    ambient = texture(iChannel0, reflect(ri.ray.d, ri.shape.normal.xyz),
                       1./ri.shape.glossy);

    // Combine all the illumination components
    c  = ri.shape.color * vec4(diffuse, 1);
    c *= shadow * ao;
    c += ri.shape.color * ambient;
	c += vec4(specular, 0);
    
    // DEBUG: Normals
    //c = ri.shape.normal;
    // DEBUG: Ambient Occlusion
    //c = vec4(ao,ao*.5,0,1);
    
    // NOTE: Applying the fog here keeps the sky gradient,
    // but makes the horizon look too sharp
	//ApplyFog(c.rgb, ri.distance);
}

// Function 1248
vec4 Light(vec3 p, vec3 rd) 
{
    vec3 lightPos = vec3(0, 5, 15. + SPEED);
    vec3 l = normalize(lightPos-(p));
    vec3 n = Normal(p);
    
    float dif = saturate(dot(n, l));

    float fog = Fog(lightPos-(p), 50.) * .1;
    dif *= fog;

    vec3 color = vec3(1) * dif;

    vec3 v = -rd;
	vec3 r = normalize(2. * dif * n - l); 
	float spec = pow(saturate(dot(r, v)), 10.0) * dif;
          spec *= 1.2;
          spec = pow(spec, 5.) * 5.;
    
    return vec4(color, spec);
}

// Function 1249
void light_brown_fabric() {
rho_d = vec3(0.0612259, 0.0263619, 0.0187761);
rho_s = vec3(3.65487e-12, 9.7449e-12, 4.13685e-12);
alpha = vec3(0.147778, 0.137639, 0.13071);
p = vec3(0.188292, 0.188374, 0.189026);
F_0 = vec3(1, 1, 1);
F_1 = vec3(0, 0, 0);
K_ap = vec3(7.46192, 7.90085, 8.23842);
sh_lambda = vec3(3.59765, 3.74493, 3.85476);
sh_c = vec3(0.00660661, 0.0049581, 0.00395337);
sh_k = vec3(12.0657, 12.6487, 13.0977);
sh_theta0 = vec3(0.221546, 0.213332, 0.206743);
}

// Function 1250
vec3 CityLights(vec2 coord, vec2 coord2, vec3 color, float planet){
    
    float noise = clamp(texture(iChannel0, coord.st).x,0.0,1.0);
    noise *= clamp(pow(getNoise(coord),2.0),0.0,1.0);
    
    noise = pow(noise, 8.0);
    
    float alpha = clamp(coord2.x,0.0,1.0);
    vec3 lightCol = vec3(1.0,1.0,0.25);
	
    return mix(color, lightCol, noise * alpha * planet);
}

// Function 1251
bool in_moon_shadow( vec3 p )
{
	return ( dot( p - moon_center, sun_direction ) < 0.0 )
		   && ( lensqr( p - project_on_line1( p, moon_center, sun_direction ) ) < moon_radius * moon_radius );
}

// Function 1252
vec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {
	float diffuse = 0.3*max(0.0,dot(-normal, lightDir)); // Lambertian
	float diffuse2 =0.3* max(0.0,dot(-normal, lightDir2)); // Lambertian
	vec3 r = reflect(normal,dir);
	return
	(diffuse*Diffuse)*(LightColor*color) +
	(diffuse2*Diffuse)*(LightColor2*color) +0.5*bg(r);
}

// Function 1253
float softshadow(float tt, vec3 ro, in vec3 rd, float k ,vec4 m,mat4 B) {
    float res=1., z=0.02, h=1.;
    for(int i=0; i<53; i++){
        h = map(ro + rd*z).x;
        res = min( res, k*h/z );
		z += clamp( h, 0.015, 1.0 );
		if( h<0.012 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1254
void initLights() {
    #if nLights != 0
    lights[0] = light(moonDir,
                      moonLight,
                      100000.);
	#endif
}

// Function 1255
vec3 shade( in vec4 res )
{
    float ra = length(res.yz);
    float an = atan(res.y,res.z) + 8.0*iTime;
    float pa = sin(3.0*an);

    vec3 cola = 0.5 + 0.5*sin( (res.w/64.0)*3.5 + vec3(0.0,1.0,2.0) );
	
	vec3 col = vec3(0.0);
	col += cola*0.4*(1.0-smoothstep( 0.90, 1.00, ra) );
    col += cola*1.0*(1.0-smoothstep( 0.00, 0.03, abs(ra-0.8)))*(0.5+0.5*pa);
    col += cola*1.0*(1.0-smoothstep( 0.00, 0.20, abs(ra-0.8)))*(0.5+0.5*pa);
	col += cola*0.5*(1.0-smoothstep( 0.05, 0.10, abs(ra-0.5)))*(0.5+0.5*pa);
    col += cola*0.7*(1.0-smoothstep( 0.00, 0.30, abs(ra-0.5)))*(0.5+0.5*pa);

	return col*0.3;
}

// Function 1256
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<50; i++)
    {
    	float h = map(ro + rd*t, false).x;
        res = min( res, 10.0*h/t + 0.02*float(i));
        t += 0.8*clamp( h, 0.01, 0.35 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1257
vec3 shadeBg(vec3 nml, float t)
{
    return vec3(0.0);
    
    vec3 lightPos_ = vec3(
        -cos(t)*-8.5, 
        sin(t)*3.0 - 4.0, 
        -(sin(t)*4.0)
    );
    vec3 bgLight = normalize(lightPos_);
    vec3 lightPos = bgLight * 9999.0;
    vec3 sun = vec3(5.0, 3.5, 2.0)*4.0;
	vec3 bgCol = vec3(0.2, 0.15, 0.1);
	float bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));
	float sunPow = dot(nml, bgLight);
	bgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);
	bgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);
	bgCol += bgDiff*vec3(0.25, 0.5, 0.5);
	bgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);
	bgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);
	return max(vec3(0.0), bgCol);
}

// Function 1258
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 16; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.05;    
    float end = max(length(rd), 0.001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.
        dist += clamp(h, 0.02, 0.25);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.
    return min(max(shade, 0.) + 0.3, 1.0); 
}

// Function 1259
vec3 computeLight(vec3 pos, vec3 color, vec3 normal, Pyramid pyramid) {
    // Lambert lightning
    vec3 toLight1 = LIGHT1_POS - pos;
    float distSq1 = dot(toLight1, toLight1);
    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS, pyramid) ? 0.0 : 20.0f / distSq1;
    vec3 toLight2 = LIGHT2_POS - pos;
    float distSq2 = dot(toLight2, toLight2);
    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS, pyramid) ? 0.0 : 10.0f / distSq2;
    vec3 toLight3 = LIGHT3_POS - pos;
    float distSq3 = dot(toLight3, toLight3);
    float att3 = 3.0f / distSq3;
    return color * (
          max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR
        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR 
        + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR 
        + texture(iChannel1, normal).rgb * 0.1
        );
}

// Function 1260
vec3 shade(vec3 pt, vec3 normal, vec3 dir, vec3 eye)
{
    // const float shininess = 16.0;
    
    // vec3 final = vec3(0.0);
    // vec3 ref = reflect(dir, normal);
    
    // vec3 Ks = specularCol;
    vec3 Kd = mix(diffuseCol0, diffuseCol1, colGradStep(pt, normal)); // diffuseCol;
    
    // Light 0 (maybe more later, need to find good way of looping)
    /*
    {
        vec3 vl = normalize(lightPos - pt);
        
        vec3 diffuse = Kd; // Kd * vec3(max(0.0, dot(vl, normal)));
        vec3 specular = vec3(max(0.0, dot(vl, ref)));
        
        vec3 F = fresnel(Ks, normalize(vl - dir), vl);
        specular = pow(specular, vec3(shininess));
        
        final += lightColor * mix(diffuse, specular, F);
    }
    */
    
    // final += texture(iChannel0, ref).rgb * fresnel(Ks, normal, -dir);
    
    return Kd; // final;
}

// Function 1261
void light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){
//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe
 ;for( int i=0;i<2;i++// es100 safe
 ){//if(iFrame>1)break//i see no difference in this es100 save line
  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)
  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)
  ;vec3  skyCol = sphereMap(skyPoint)
  ;iColor += skyCol * skySha / 2.0
  ;vec3 h = normalize( skyPoint - rd )
  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )
  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )
  ;iColor+=spe*shl*skyCol*skySha/2.;};}

// Function 1262
float softShadow(vec3 ro, vec3 lp, float k)
{
    const int maxIterationsShad = 32; 
    
    vec3 rd = (lp-ro); 

    float shade = 1.;
    float dist = .005;    
    float end = max(length(rd), 0.001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
       
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); 
       
        dist += clamp(h, .02, .2);
        
       
        if (h<0.0 || dist > end) break; 
       
    }

   
    return min(max(shade, 0.) + 0.03, 1.0); 
}

// Function 1263
vec3 computeLighting(
    vec3 posWS,
    vec3 rayDirWS,
    vec3 normalWS,
    vec3 albedo,
    vec3 f0Reflectance,
    float roughness,
    vec4 emissive,
    float ambient
)
{
    if(emissive.a > 0.999)
    {
        return emissive.rgb;
    }
    
    float shadow = getFireShadow(posWS + normalWS * 0.02);
    vec3 reflectedRayDirWS = reflect(rayDirWS, normalWS);
    float rDotN = max(0.0001, dot(reflectedRayDirWS, normalWS));
    vec3 fresnelReflectance = roughFresnel(f0Reflectance, rDotN, roughness);

    vec3 diffuse = albedo * computeLighting(posWS, normalWS, normalWS, 1.0, ambient, shadow);
    vec3 specular = computeLighting(posWS, reflectedRayDirWS, normalWS, roughness, ambient, shadow);
    vec3 surfaceLighting = mix(diffuse, specular, fresnelReflectance);
    return surfaceLighting * (1.0 - emissive.a) + emissive.rgb;
}

// Function 1264
float ExObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ExObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.01 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1265
float GetLighting(vec3 p, vec3 s)
{
    float l = MapSH(p)-MapSH(p+s*200.);
    return clamp(-l*2., 0.05, 1.0);
}

// Function 1266
vec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )
{
	vec3 halfVec = normalize( viewDir + lightDir );

	float vdoth = clamp( dot( viewDir,	halfVec	 ), 0.0, 1.0 );
	float ndoth	= clamp( dot( normal,	halfVec	 ), 0.0, 1.0 );
	float ndotv = clamp( dot( normal,	viewDir  ), 0.0, 1.0 );
	float ndotl = clamp( dot( normal,	lightDir ), 0.0, 1.0 );
    
   	vec3	f = FresnelTerm( specularColor, vdoth );
	float	d = DistributionTerm( roughness, ndoth );
	float	v = VisibilityTerm( roughness, ndotv, ndotl );
    
    vec3 specular;
	specular = lightColor * f * ( d * v * MATH_PI * ndotl );
	return specular;
}

// Function 1267
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{        
  vec3 reflectDir = reflect( rayDir, normal );

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);  
  dif *= SoftShadow( shadowPos, sunPos);
  skylight *=SoftShadow(shadowPos, reflectDir);

  vec3 lightTot = vec3(0.0);

    
    
  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);
      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);
  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));
}

// Function 1268
float lightRay(vec3 p, float phaseFunction, float dC, float mu, vec3 sun_direction, float cloudHeight, bool fast)
{
    int nbSampleLight = fast ? 7 : 20;
	float zMaxl         = 600.;
    float stepL         = zMaxl/float(nbSampleLight);
    
    float lighRayDen = 0.0;    
    p += sun_direction*stepL*hash(dot(p, vec3(12.256, 2.646, 6.356)) + iTime);
    for(int j=0; j<nbSampleLight; j++)
    {
        float cloudHeight;
        lighRayDen += clouds( p + sun_direction*float(j)*stepL, cloudHeight, fast);
    }    
    if(fast)
    {
        return (0.5*exp(-0.4*stepL*lighRayDen) + max(0.0, -mu*0.6+0.3)*exp(-0.02*stepL*lighRayDen))*phaseFunction;
    }
    float scatterAmount = mix(0.008, 1.0, smoothstep(0.96, 0.0, mu));
    float beersLaw = exp(-stepL*lighRayDen)+0.5*scatterAmount*exp(-0.1*stepL*lighRayDen)+scatterAmount*0.4*exp(-0.02*stepL*lighRayDen);
    return beersLaw * phaseFunction * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeight), 1.0, clamp(lighRayDen*0.4, 0.0, 1.0));
}

// Function 1269
vec3 shade(vec3 ro, vec3 rd, float d, vec3 lp, vec3 lc, float li)
{
	vec3 p = ro + rd * d;
	vec3 ld = normalize(lp-p);
	vec3 n = nor(p, 0.1);
	vec3 refl = reflect(rd,n);
	float diff = clamp( dot( n, ld ), 0.0, 1.0 );
	float sha = softshadow( p, ld, 0.01, 50. );
	float fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );
	float spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),16.);
	return ((diff * sha + fre + spe) * lc * li + spe) * sha;
}

// Function 1270
vec3 getLightnessCielab(float rawLightness, float rawChroma, float hue) {
    vec3 lch = vec3(rawChroma * 100.0, 0.0, hue);
    vec3 cielab = lchToLab(lch);
    return xyzToLinearSrgb(cielabToXyz(cielab));
}

// Function 1271
vec3 shadeBk( in vec3 ro, in vec3 rd, in float t )
{
    float eps = 0.005;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormalBk( pos, eps*t );
    float kk;

    vec3 mateD = vec3(0.14,0.14,0.12);
    mateD = mix( mateD, vec3(0.03,0.03,0.0), smoothstep(0.85,0.95, nor.y ) );
    mateD *= 0.3;
  
    mateD *= 0.1 + 2.0*texture( iChannel2, pos.xz*0.005 ).x;
    
    vec3 hal = normalize( sunDir-rd );
        
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float sha = calcSoftShadowBk( pos, sunDir, 16.0 );
    dif1 *= sha;

    // sun
    vec3 col = 8.0*vec3(1.8,1.2,0.8)*dif1;
    // sky
    col += 4.0*vec3(0.3,0.7,1.0)*clamp(0.2+0.8*nor.y,0.0,1.0);
    
    col *= mateD;

    return col;        
}

// Function 1272
float GetLight (vec3 p){
    vec3 lightPos = vec3(0,5,6);
    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;
    
    vec3 l = normalize (lightPos-p);
    vec3 n = GetNormal(p);
    
    float dif = clamp(dot(n,l),0.,1.);
    float d = RayMarch(p+n*SURF_DIST*2.,l);
   
    if (d<length(lightPos-p)) dif*=.1;
     
    return dif;
}

// Function 1273
vec4 atm_skylight_sample( TrnSampler ts, sampler2D ch, vec3 x )
{
    vec2 res = vec2( textureSize( ch, 0 ) );
    vec2 aspect = vec2( res.y / res.x, 1 );
    vec2 uv = ts_uv( ts, x ) / 2. * aspect + vec2( 0, .5 );
    return textureLod( ch, uv, 0. );
}

// Function 1274
float shadow(in vec3 position)
{
    float lightDist;
	vec3 lightPoint = worldPointToLightPoint(position, lightDist);
    
    float shadowDist;
    unpackShadow(texture(SHADOW_BUFFER, lightPoint.xy), shadowDist);
    
    // Compare real distance to light with distance captured by the light "camera".
    // If they differ, this means that something is on the way.
    // This means one thing.
    // Shadow.
    float shadow = shadowDist - lightDist;
    shadow = step(0.0, shadow);

    if (clamp(lightPoint.x, 0.0, 1.0) != lightPoint.x
     || clamp(lightPoint.y, 0.0, 1.0) != lightPoint.y
     || shadowDist >= MAX_DIST_SHADOW - 1.0) // _why_
        shadow = 1.0;
    
    return shadow;
}

// Function 1275
vec3 directLight(vec3 pos, vec3 normal){
    //return vec3(0.);
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = sdf(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 2.5;	//goes 2.5 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 1276
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<60; i++ )
    {
		if( t<maxt )
		{
	        float h = map( ro + rd*t ).x;
	        res = min( res, k*h/t );
	        t += 0.02;
		}
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1277
vec3 traceLight( in vec3 from, in vec3 norm, in uvec3 seed ) {
    
    vec3 pos = vec3(0);
    vec4 diff = vec4(0);
    vec3 dummyNorm = vec3(0);
    
    // create a random dir in a hemisphere
    vec3 rand = hash(seed);
    float dirTemp1 = 2.0*PI*rand.x;
    float dirTemp2 = sqrt(1.0-rand.y*rand.y);
    vec3 dir = vec3(
        cos(dirTemp1)*dirTemp2,
        sin(dirTemp1)*dirTemp2,
        rand.y);
    dir.y = abs(dir.y);
    
    // pick the sun more often (priority sampling)
    const float sunContrib = colorSun.a*2.0*PI*(1.0 - sunCosAngle);
    const float ambientContrib = colorAmbient.a*2.0*PI;
    const float groundContrib = colorGround.a*2.0*PI;
    const float sumContrib = sunContrib+ambientContrib+groundContrib;
    
    float a = sunContrib / sumContrib;
    float b = a + ambientContrib / sumContrib;
    
    if (rand.z < a) {
        const vec3 sunDirTan = normalize(cross(sunDir, vec3(0, 0, 1)));
        const vec3 sunDirCoTan = cross(sunDir, sunDirTan);
        float rot = 2.0*PI*rand.x;
        float the = acos(1.0 - rand.y*(1.0 - cos(sunAngle)));
        float sinThe = sin(the);
        dir = sunDirTan*sinThe*cos(rot) + sunDirCoTan*sinThe*sin(rot) - sunDir*cos(the);
    } else if (rand.z < b) {
        dir.z = abs(dir.z);
    } else {
        dir.z = -abs(dir.z);
    }
    
    if (trace(from, dir, false, pos, dummyNorm, diff)) {
        vec3 back = getBackground(dir);
        vec3 color = back.rgb * diff.rgb * (1.0 - diff.a);
        float l = dot(norm, norm) > 0.0 ? max(0.0, dot(dir, norm)) : 1.0;
        return color*l*sumContrib;
    } else {
        return vec3(0);
    }
    
}

// Function 1278
vec3 shade(in vec3 pos, in vec3 obs)
{
    // normal
    vec2 eps = vec2(0.001, 0.0);
    vec3 n = normalize(vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,
                            map(pos + eps.yxy).x - map(pos - eps.yxy).x,
                            map(pos + eps.yyx).x - map(pos - eps.yyx).x));
    // color
	vec3 colAquamarine = vec3(0.239216, 0.858824, 0.976471);
	vec3 colGoldenrod = vec3(0.917647, 0.817647, 0.478431);
    vec2 rmap = map(pos);
    vec3 col1 = colAquamarine * (0.1 + abs(rmap.y));
    vec3 col2 = colGoldenrod * (0.1 + abs(rmap.y));
    vec3 col  = mix(col1, col2, step(0.0, rmap.y));
    
    // light, view, and half vectors
    vec3 l = normalize(vec3(-1.0, 3.0, 2.0));
    vec3 v = normalize(obs - pos);
    vec3 h = normalize(v + l);
    
    // light composition
    vec3 namb = n;
    namb.y = 0.5 * namb.y + 1.0;
    vec3 amb = col * dot(namb, vec3(0.0, 1.0, 0.0));
    vec3 diff = col * max(0.0,  dot(n, l)) * 0.3;
    vec3 spec = vec3(0.2) * pow(max(0.0, dot(n, h)), 8.0) * 0.2;
    return amb + diff + spec;
}

// Function 1279
void lighting(inout vec3 r, inout vec3 a, material m, light l, point p, vec3 n) {
    if(l.type == AMBIENT_LIGHT)
        a = clamp(a + m.ambientalbedo / PI * l.color * l.intensity, 0.0, 1.0);
    else {
        lightpath lp =  Lightpath(p, l, n);
        vec3 L = vec3(0.0);
        if(m.diffusetype == LAMBERT_DIFFUSE)
            L = lambert(m, lp);
        else if(m.diffusetype == ORENNAYAR_DIFFUSE)
            L = orennayar(m, lp);
        vec3 S;
        if(m.speculartype == PHONG_SPECULAR)
            L += phong(m, lp);
        if(false && length(L) > 0.0001) {
            point sp = point(
                p.position + lp.iray * 0.01, // source
                lp.iray, // direction
                vec3(0.0), // position
                vec3(0.0), // normal
                0.0, // marchlength
                0, // iterations
                0.0, // closestlength
                0.0, // closestdistance
                0.0 // penumbra
            );
            trace(sp, 1.0);
            float sf = exm1_ex(sp.penumbra);
            sf = 1.0;
            if(sp.iterations < MaximumRaySteps && sp.marchlength < lp.ilength)
                sf = 0.0;
            L *= sf;
        }
        r = clamp(r + L, 0.0, 1.0);
        r = r + L;
    }
}

// Function 1280
vec3 ShadeBoat( vec3 pos, vec3 ray )
{
	pos -= boatPosition;
	vec3 norm = normalize(pos);
	pos = WorldToBoat(pos);
	
	vec3 lightDir = normalize(vec3(-2,3,1));
	float ndotl = dot(norm,lightDir);
	
	// allow some light bleed, as if it's subsurface scattering through plastic
	vec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);

	// anti-alias the albedo
	float aa = 4.0/iResolution.x;
	
	//vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);
	vec3 albedo = vec3(1,.01,0);
	albedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );
	albedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );
	albedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );
	albedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );
	
	vec3 col = albedo*light;
	
	// specular
	vec3 h = normalize(lightDir-ray);
	float s = pow(max(0.0,dot(norm,h)),100.0)*100.0/32.0;
	
	vec3 specular = s*vec3(1,1,1);

	vec3 rr = reflect(ray,norm);
	specular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );
	
	float ndotr = dot(norm,ray);
	float fresnel = pow(1.0-abs(ndotr),5.0);
	fresnel = mix( .001, 1.0, fresnel );

	col = mix( col, specular, fresnel );
	
	return col;
}

// Function 1281
vec3 getLight(vec3 p, vec3 lp)
{
	float dist = distance(p, lp);
	      dist *= dist;
	
	return (1.0 / dist) * lightColor;	
}

// Function 1282
vec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)
{
vec3 color;

    //get id's for coloring spheres
    vec3 fp = sp/vec3(5.);
    vec3 id = floor(fp);
    
    
    vec3 lv = lp - sp;
    float ldist = max(length(lv), 0.001);
    vec3 ldir = lv/ldist;
    float atte = 1.0/(1.0 + 0.002*ldist*ldist );
    float diff = dot(ldir, sn);
    //I couldn't get specular to work properly on this so it's out
    //float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);
	float ao = calculateAO(sp, sn);
    vec3 refl = reflect(rd, sn);
    float s = id.x*id.y*id.z;
    vec3 colorRand = 0.5 + 0.5*cos(vec3(rnd33(s))+vec3(0,2,4)/5.);
    //getting reflected color from a cubemap
    vec4 reflColor = texture(iChannel0, refl);
     
    //apply color and add refl
    color = (diff*colorRand  + reflColor.xyz*0.2 )*atte;
    //apply ambient occlusion and return.
 return color*ao;   
}

// Function 1283
vec3 lightDir(vec3 point, Light light) {
	vec3 dir = normalize(light.pos - point);

	return dir;
}

// Function 1284
float bevelShade(vec2 pt) {
	return clamp(1.0* dot(gradient(pt, glyph_dist(pt)), light_dir)* 0.5+ 0.5, 0.0,
			1.0);
}

// Function 1285
vec3 get_incident_light(in ray_t ray){
    vec3 sun_dir = normalize(vec3(.0, sin(time),cos(time))); //I need a better positioning method than this
    
    
    if(iMouse.z>0.1){sun_dir = normalize(vec3(.0, sin(iMouse.x*2.*PI/iResolution.x - 1.),cos(iMouse.x*2.*PI/iResolution.x - 1.)));}//Mouse control instead of time
    
    vec3 moon_dir = -sun_dir; //moon is jus opposite of sun, but it doesn't need to be
    
    
    
    float t0,t1;
    if(!intersects_sphere(ray, atmosphere, t0, t1)){return vec3(0.); }
    
    float march_length = t1 / float(num_samples);
    
    float mu = dot(sun_dir, ray.direction);
    float muMoon = dot(moon_dir, ray.direction);
    
    float phaseR = rayleigh_phase_func(mu);
    float phaseM = henyey_greenstein_phase_func(mu);
    float phaseMoonR = rayleigh_phase_func(muMoon);
    float phaseMoonM = henyey_greenstein_phase_func(muMoon);
    
    
    //The accumulated extincion coefficients multiplied by the path length (optical depth = "average density")
    float opticalDepthR = 0.;
    float opticalDepthM = 0.;
    float opticalDepthMoonR = 0.;
    float opticalDepthMoonM = 0.;
    
    vec3 sumR = vec3(0.);
    vec3 sumM = vec3(0.);
    vec3 sumMoonM = vec3(0.);
    vec3 sumMoonR = vec3(0.);
    
    float march_pos = 0.;
    
    for(int i=0; i<num_samples; i++){
        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length); //sample middle of step
        float height = length(s) - earth_radius;
        
        //sample densities
        float hr = exp(-height / hR) * march_length;
        float hm = exp(-height / hM) * march_length;
        //Add to optical depth of primary ray - these variables will work for both the sun and moon
        opticalDepthR += hr;
        opticalDepthM += hm;
        
        //The moon is created by literally doing everything twice with extra "moon" variables
        //I'm too lazy to find a better solution
        ray_t light_ray = ray_t(s, sun_dir);
        ray_t moon_ray = ray_t(s,moon_dir);
        
        float opticalDepthLightR = 0.;
        float opticalDepthLightM = 0.;
        float opticalDepthLightMoonR = 0.;
        float opticalDepthLightMoonM = 0.;
        
        
        bool overground = get_sun_light(light_ray, opticalDepthLightR,  opticalDepthLightM);
        bool overgroundMoon = get_sun_light(moon_ray, opticalDepthLightMoonR, opticalDepthLightMoonM);
        
        if(overground || overgroundMoon){
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) 
                + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);
            
            vec3 tauMoon = betaR * (opticalDepthR + opticalDepthLightMoonR) 
                + betaM * 1.1 * (opticalDepthM + opticalDepthLightMoonM);

            vec3 attenuation = exp(-tau);
            vec3 attenuationMoon = exp(-tauMoon);
            
            sumR += hr * attenuation;
            sumM += hm * attenuation;
            sumMoonR += hr * attenuationMoon;
            sumMoonM += hm * attenuationMoon;
        }
        march_pos += march_length;
    }
    
    
    //Compute the final color by adding sun and moon lighting
    vec3 col = sun_power * (sumR * phaseR * betaR +sumM * phaseM * betaM) 
        + moon_power * (sumMoonR * phaseMoonR * betaR + sumMoonM * phaseMoonM * betaM); 
    
    //Draw circles around the celesteal bodies
    //I know if-statements are bad
    if(dot(ray.direction, sun_dir) > 0.9995)col *= (1.5,1.5,1.5);
    if(dot(ray.direction, moon_dir) > 0.9995)col *= (1.9,1.9,1.9);
    
    
    return col;
}

// Function 1286
float lampLight(vec3 p){
    vec3 lp = p;
    lp += vec3(0, -.65, 0);
	lp.yz *= Rot(1.6);
	float light = sdHexPrism(lp, vec2(.11, .13));
    return light;
}

// Function 1287
float shadow(vec3 ro,vec3 rd,float mint,float maxt,float k)
{
    float res = 1.0;
    float ph = 1e20;
    for( float t=mint; t < maxt; )
    {
        float h = world(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, k*d/max(0.0,t-y) );
        ph = h;
        t += h;
    }
    return res;
}

// Function 1288
float shadow(vec3 o, vec3 r) {
    float t = 0.0;
    float k = 16.0;
    float res = 1.0;
    for (int i = 0; i < 32 ; i++) {
        vec3 p = o + r*t;
        float d = map(p);
        if (d < 0.001*t) {
            return 0.0;
        }
        t += d*0.9;
        res = min(res, k*d/t);
    }
    return res;
}

// Function 1289
float My_edge_shadow(vec3 surface, vec3 lig_p,float mintd, float maxdd, float k0,float k1) {
	float start_d = mintd;
	float d = 0.0;
	float mind = 1.0;
	for(int i = 0; i < 20; i++) {		
		d = obj(surface + start_d*lig_p).x;
		mind = min(mind, exp(d*k0)/k1 );
		start_d += d;
		if(start_d > maxdd) break;
	}
	return mind;
}

// Function 1290
float shadow(vec3 p, vec3 l, float tMax, float k)
{
    float ret = 1.;
    float ph = 1e20;
    for (float t = 0.; t < tMax;) {
        // Fudge around volume artifacts near small objects
        float h = scene(p + l * t) + (rnd() - 0.4) / 10.;
        if (h < .01)
            return .0;
        float y = h * h / (2. * ph);
        float d = sqrt(h * h - y * y);
        ret = min(ret, k * d / max(0., t - y));
        ph = y;
        t += h;
    }
    return ret;
}

// Function 1291
vec3 map_light_norm(vec3 ro) { 
    return normalize(ro - light.xyz);
}

// Function 1292
float SampleShadowMap(in vec2 shadowCoords)
{
    return texture(iChannel0, shadowCoords).r;
}

// Function 1293
vec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)
{
	vec3 cScene ;
	vec3 vSpecularReflection = vec3(0.0);
	vec3 vDiffuseReflection = vec3(0.0);
	
	#ifdef ENABLE_AMBIENT_OCCLUSION
	float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);	
	#else
	const float fAmbientOcclusion = 1.0;
	#endif
	#ifdef ENABLE_AMBIENT_LIGHT
	vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;
	vDiffuseReflection += vAmbientLight;
	#endif
	
	vSpecularReflection += cReflection * fAmbientOcclusion;
		
	#ifdef ENABLE_POINT_LIGHT
	vec3 vLightPos = GetLightPos();
	vec3 vToLight = vLightPos - intersection.vPos;
	vec3 vLightDir = normalize(vToLight);
	float fLightDistance = length(vToLight);
	
	float fAttenuation = 1.0 / (fLightDistance * fLightDistance);
	#endif
	
	#ifdef ENABLE_SHADOW
	float fShadowBias = 0.1;              
	float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, fLightDistance - fShadowBias );
	#else
	float fShadowFactor = 1.0;
	#endif
	#ifdef ENABLE_LIGHTING	
	vec3 vIncidentLight = GetLightCol() * fShadowFactor * fAttenuation;
	
	vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                                  
	vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;

	
	vDiffuseReflection *= material.cAlbedo;
	#else
	vDiffuseReflection = material.cAlbedo;// * fShadowFactor;
	#endif
	
	#ifdef ENABLE_SPECULAR
	float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);
	cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);
	#else
	cScene = vDiffuseReflection;
	#endif
	
	return cScene;
}

// Function 1294
vec3 light(v3 p,v3 n,v3 i,v1 d,v4 m){
 vec3 l=normalize(vec3(1.,.7,.9));//light direction
 float o=max(0.,dot(n,l)),
 c=max(0.,dot(n,normalize(l-i))),
 s;if(c>.01)s=shadow(p+.01*n,l); 
 const vec3 LigCol=vec3(1.);//light color
 vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  
 r+=s*c*pow(o,40.);//specular
 //r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map
 r*=exp(-.01*d*d);//fog  
 return r;}

// Function 1295
vec3 shade( vec3 p, vec3 n, vec3 ro, vec3 rd )
{
    vec2 glowAccCopy = glowAcc; // copy since it will be reset by the reflection raymarch loop
    float d = length(p-ro);
    vec3 sky = skyColor(rd);
    vec3 col = sky;
    
    if (d < 300.)
    {
        vec3 albedo = vec3(.8);
        float metalness = 0.;
        getMaterial(p, n, metalness, albedo);
        
        float ao = ambientOcclusion(p,n, 10., 2.)* ambientOcclusion(p,n, 1., .5);
        float shad = shadow(vec3(p), vec3(sunDir), float(1.), float(80.));
		float fre = saturate(1.+dot(rd,n));
        
        vec3 amb = vec3(.5,.5,.5) * ao;
        vec3 diff = vec3(1.,.7,.5) * max(0., dot(n, sunDir) ) * shad;
        vec3 bnc = vec3(1.,.7,.4) * saturate(-n.y) * ao;
        
        
        col = albedo * ( diff*2. + amb );
        
        vec3 refl;
        {
            vec3 rro = p+n*0.1;
            vec3 rrd = reflect(rd,n);
            vec3 rp = raymarchFast(rro,rrd, vec2(.1,100.), 0.001);
            refl = shadeFast(rp, normal(rp, 0.01), rro, rrd);
            if (ship(p)<level(p)) {
                col = refl;
            } else {
				col += refl * pow(fre,5.)*metalness;
            }
        }
        
        col = mix(col, skyColor(vec3(1.,.2,.1))*.25, 1.-exp(-length(p-ro)*.01));
    }
    computeGlow(col,glowAccCopy);
    
    return col;
}

// Function 1296
vec4 shadeDroid(Ray ray, Hit droid) {
 
    vec3 n = normal(droid.p);
    vec3 rd = reflect(ray.dir, n);
    
    Ray  rr = Ray(droid.p + (rd * .01), rd);
    Hit  rh = raymarch(rr);
    vec4 rc = rh.dist.id == 0 ? shadeDeathStar(rr, rh) : clearColor(rd);
    
    float diffuse  = max(dot(getSunDir(),n), 0.);
    float specular = max(pow(dot(normalize(rd),getSunDir()), 30.), 0.);
    
 	vec4 col = vec4(rgb(227.,156.,25.), 1.) * diffuse;   
    return mix(col, rc, .4) + (vec4(1.) * specular);
    
}

// Function 1297
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<48; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.005, 0.5 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1298
vec3 sample_light(vec3 x, vec3 n, vec3 rd, float t)
{
    vec3 Lo = vec3(0.);
    
    vec3 wi = sun_dir;
    float light_sampling_pdf = 1.;
    
    for(int i = 0; i < LIGHT_SAMPLES; ++i)
    {        
        float n_dot_wi = dot(n, sun_dir);
    	if(n_dot_wi > 0.00001) 
        {
        	float sha = shadow(x, wi);
        
            // monte carlo estimator
            Lo += sun_col * brdf(x, n, -rd, wi) * n_dot_wi * sha / light_sampling_pdf;
        }
        
    }
    Lo /= float(LIGHT_SAMPLES);
    
    Lo = mix(Lo, sky_col, 1.0-exp(-0.01*t*t*t)); 

    return Lo;
}

// Function 1299
void drawLight1(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 l1Norm;
    float light1T = traceSphere(ray.pos - LIGHT1_POS, ray.dir, 
                                        LIGHT1_RADIUS, l1Norm);
    
    if(light1T < cur_ctxt.t)
    {
        cur_ctxt.t=light1T;

        cur_ctxt.materialType = EMISSION;
        cur_ctxt.color=LIGHT1_COLOR;
        cur_ctxt.n = l1Norm;
        cur_ctxt.alpha = 0.0;
    }

}

// Function 1300
vec3 lights(vec3 p, vec3 rd, float d, Hit h) {
	if (h.id == 3) return vec3(1);
	vec3 n, c,
	     ld = normalize(vec3(2, 20, 15) - p);
	if (h.id == 0) {
		n = normalize(h.uv);
		float ns,
		      f = sat(.2 + .8 * dot(ld * vec3(-1, 1, 1), n));
		vec2 k = (n.xy * rot(t * .1) - vec2(.3, .1)) * rot(t * -.3) + vec2(.1, .2);
		for (float i = 0.; i < 2.; i++) {
			float l = length(k + i * .1);
			f += (.4 + .2 * sin(l * 60. - t * 2.)) * (.003 + S(.5, 0., l) * S(0., .5, l));
			t += 32.;
		}

		ns = n31(n * 19. + vec3(0, 0, t * 2.)) * .7 + n31(n * 39. + vec3(0, t * 2., 0)) * .3;
		f *= .5 + .5 * S(.2, .8, ns);
		return vec3(1, 1.1, 1.7) * f;
	}

	n = N(p, d);
	if (h.id == 1) c = vec3(.2);
	else if (h.id == 2) c = vec3(.01);
	else if (h.id == 4) {
		c = vec3(.55);
		n.xz += 4. * (h.uv.z * .5 + n21(p.xz) * .125 - .5 + (n21(p.xz * 2.) + n21(p.zx * 32.1)) * .05);
		n = normalize(n);
	}
	else if (h.id == 5) c = mix(vec3(-.05), vec3(2. * pow(sat(sin(t + p.y * .2)), 10.), 0, 0), step(.8, fract(p.y)) * step(-7., p.y));

	float gg = g,
	      l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p, ld)),
	      l2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3 + pow(sat(dot(rd, reflect(ld, n))), 10.),
	      fre = 1. - S(.7, 1., 1. + dot(rd, n)) * .5;
	g = gg;
	return (l1 + l2) * fre * c * vec3(.4, .32, .3);
}

// Function 1301
vec3 shade(vec3 ro, vec3 rd, float t, float coneR, vec3 ld)
{
    vec3 g = grad(ro+rd*t, coneR);
    vec3 N = normalize(g);
    float ambo = ambientOcclusion(ro+rd*t, N, coneR);
    float ndl = clamp(dot(N, ld), 0.0, 1.0);
    vec3 color = mix(vec3(0.782, 0.569, 0.45), vec3(0.8, 0.678, 0.569), clamp(1.5-length(g), 0.0, 1.0));
    return vec3(mix(ambo*color, ambo*color*ndl, 0.5));
}

// Function 1302
vec4 shade( in vec3 rd, in vec3 pos, in vec3 ddx_pos, in vec3 ddy_pos, 
            in vec3 nor, in int id, in vec4 sph )
{
    // compute UVs and filter shape
    
	float u     = computeU(     pos, sph, id );
    float ddx_u = computeU( ddx_pos, sph, id );
    float ddy_u = computeU( ddy_pos, sph, id );

    // texture
	vec3 col = vec3(0.0, 0.2 + 0.4*clamp(1.0-sph.w*2.0,0.0,2.0),0.8);
    col *= 1.0 - linesTextureGradBox( u, ddx_u-u, ddy_u-u, id );
	col *= sphereF[id];
    
    // lighting
    
    vec3 ref = reflect(rd,normalize(nor-0.2*rd)); //vec3 ref = reflect(rd,nor);

	// compute reflection shadow, ambient occlusion and edge proximty
    float sha = 1.0;
	float occ = 1.0;
	float pro = 1e10;
	for( int i=0; i<NUMSPHERES; i++ )
    {
        if( i!=id )
        {
        sha = min( sha, 10.0*sphSoftShadow(pos+0.005*nor,ref,sphere[i]) );
        pro = min( pro, abs(length(pos-sphere[i].xyz)-sphere[i].w) );
      //occ = min( occ, 1.0 - sphOcclusion( pos, nor, sphere[i] ) );
	    occ *= 1.0 - sphOcclusion( pos, nor, sphere[i] ); 
        }
	}

    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);
    occ = occ*0.5 + 0.5*occ*occ;
    
	// light-surface interaction
    vec3 lig = vec3(occ)*1.4;
    lig *= 0.7 + 0.3*nor.y;
    lig += 0.5*fre*fre*occ;
    lig *= col;
    lig += 1.2*smoothstep(-0.1,0.10,ref.y )*occ*sha * (0.03+0.97*pow(fre,4.0));

    // glow
	float g = clamp(pro/(1.0+15.0*vol),0.0,0.5*sph.w);
    lig += (0.2+0.8*vol)*vec3(0.5*vol,0.4+0.4*vol,1.0)*exp(-15000.0*g*g*20.0);
    lig += (0.1+0.9*vol)*vec3(0.0,0.50,1.0)*exp(-2000.0*g*g*20.0);

    return vec4(lig,1.0);
}

// Function 1303
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = distance_to_obj( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1304
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        vec2 uv;
		float h = map( ro + rd*t ,rd,uv);
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1305
float hardShadow(vec3 dir, vec3 origin, float min_t) {
    float t = min_t;
    for(int i = 0; i < RAY_STEPS; ++i) {
        vec3 obj = origin + t * dir;
        float m = sceneMap3D(obj);
        if(dot(obj - lightPos, origin - lightPos) < 0.) 
            return 1.0;
        if(m < 0.0001) {
            // return 0.0;
            return float(i) * 0.01;
        }
        t += m;
    }
    return 1.0;
}

// Function 1306
vec3 DirLight( in vec3 l, in vec3 ligColor,
			  
			   in vec3 n, in vec3 v,
               in vec3 matColor, in float matR, 
			   
               in float sha )
{
	vec3 h = normalize(v+l);
	vec3 r = reflect( -v, n );

	float nl = clamp(dot(n,l),0.0,1.0);
	float nv = clamp(dot(n,v),0.0,1.0);
	float nh = clamp(dot(n,h),0.0,1.0);
    float hl = clamp(dot(h,l),0.0,1.0);

    vec3 sunDiff = matColor * nl;
	
	//-------------------

	float fresnel = 0.04 + (1.0-0.04)*pow( 1.0-hl, 5.0 );	
	float a = pow( 1024.0, 1.0-matR);
	
	float blinnPhong = ((6.0+a)/8.0) * pow( nh, a );
	a *= 0.2; blinnPhong += ((6.0+a)/8.0) * pow( nh, a );
	float k = 2.0/sqrt(3.1416*(a+2.0));
	float v1 = nl*(1.0-k)+k;
	float v2 = nv*(1.0-k)+k;
	vec3 sunSpec = 10.0*matColor * nl * fresnel * blinnPhong / (v1*v2);
	
	//-------------------
	
    return ligColor * (sunDiff + sunSpec) * sha;
}

// Function 1307
float raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    float breakOut = 0.0;
    int i = 0;
    while (i < 40 && breakOut != 1.0) {
        vec3 p = ro + rd * t;
        float d = p.y - fBm(p.xz);
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            breakOut = 1.0;
        i++;
    }
    return sh;
}

// Function 1308
bool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {
    float t;
	
	t = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }
    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }
	t = iSphere( ro, rd, vec4( 3.3,0.3, 1.3, 0.3) );  if( t>eps && t<dist ) { return true; }
    return false; // optimisation: planes don't cast shadows in this scene
}

// Function 1309
vec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )
{
    // animate moving objects
    float r = -(time+sin(time))*10.;
    float a = time/3.;
    vec4 s0 = vec4(.1*cos(a),.1*sin(a)+.05,0,1), s1 = vec4(-.1*cos(a),-.1*sin(a)+.05,0,2);
    s0.xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;
    s1.xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;
    //s0.w *= .5+.5*pow(1.-fract(time*2.),2.);
    Scene[0] = s0;
    Scene[1] = s1;
    
    vec3 normal = vec3(0);
    int material = 0;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;

        Material mat = GetMaterial(pos,material);
        
        if ( material == 2 ) mat.roughness = ROUGHNESS;

        float specPower = 1./(mat.roughness*mat.roughness);
        float specStrength = (specPower+8.)/(4.*tau);
        

        // sample light
        vec3 sun = normalize(vec3(-.5,2,3));
        
        // soften shadow by sampling radius around sun
        vec3 areaLight = PowRand( rand.zx, -sun, 1. );
        vec3 suntap = normalize( sun + areaLight*.03 );
        
        vec3 testn = vec3(0);
        int ignore;
        Trace(testn,ignore,pos,suntap);
        
        float ndotl = max(0.,dot(normal,sun));
        float ndoth = max(0.,dot(normal,normalize(-ray+sun)));

        vec3 ambientColour = vec3(.05,.065,.09);
        vec3 lightColour = vec3(1,.95,.92);
        vec3 light = ambientColour*(normal.y*.3+1.); // ambient
        vec3 specular = vec3(0);
        if ( length(testn) == 0. )
        {
        	light += ndotl * lightColour;
	        specular += lightColour*ndotl*pow(ndoth,specPower)*specStrength;
        }

        
        // randomize reflection direction with Blinn-Phong probability distribution
        vec3 microfacet = PowRand( rand.zy, normal, specPower );

        // sample reflection
        vec3 reflection = vec3(0);
        
        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera
        {
            vec3 refray = reflect(ray,microfacet);
            vec3 refn = vec3(0);
            int refmati = 0;
            float reft = Trace(refn,refmati,pos,refray);

            reflection = Sky(refray);
            if ( length(refn) > 0. )
            {
                Material refmat = GetMaterial(pos+refray*reft,refmati);
                reflection = refmat.albedo * (max(0.,dot(refn,sun)) * lightColour + ambientColour*(refn.y*.3+1.));
            }
        }
        
        reflection += specular;
        
        col = light*mat.albedo;

        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );
        
        col = mix( col, reflection, fresnel );
    }
    
    return col;
}

// Function 1310
float GetLight(vec3 p){
    //position of the light source
   // vec3 lightPos = vec3(40,100,0);
    
    //lightPos.xz += vec2(sin(iTime),cos(iTime));
    //light vector
    vec3 l = normalize(lightPos-p);
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;
    if(d < length(lightPos-p)){
        diff *= .1;
    }
    
    return diff;
}

// Function 1311
float softShadow(in vec3 ro, in vec3 rd )
{
    // real shadows	
    float res = 1.0;
    float t = 0.001;
	for( int i=0; i<80; i++ )
	{
	    vec3  p = ro + t*rd;
        float h = p.y - textureLod( iChannel0, fract(p.xz), 0.0).w*.15;
		res = min( res, 20.*h/t );
		t += h;
		if( res<0.001) break;
	}
	return clamp( res, 0.1, 1.0 );
}

// Function 1312
vec3 shade(vec3 ori, vec3 dir) {
    float  t = raymarch(ori,dir,MAX_ITERATIONS);
    vec3 col = vec3(0.);
    if(t < MAX_DISTANCE) {
        vec3 p = ori+dir*t;
        vec3 n = calcNormal(p,t);
        vec3 r = normalize(reflect(dir, n));
        
        vec4 tx = texture(iChannel0,mod((p.xz+vec2(.9,.5))*vec2(.5,1.),1.));
        col = calcLighting(tx.xyz, p, n, r, mix(10.,60.,tx.w), mix(.4,1.,tx.w));
    }
    return col;
}

// Function 1313
float shadow(float world, vec3 from, vec3 increment)
{
	const float minDist = 1.0;
	
	float res = 1.0;
	float t = 1.0;
	for(int i = 0; i < SHADOW_ITERATIONS; i++) {
		float m;
        float h = distf2(int(world), from + increment * t,m);
        if(h < minDist)
            return 0.0;
		
		res = min(res, 4.0 * h / t);
        t += SHADOW_STEP;
    }
    return res;
}

// Function 1314
float SoftShadow(in vec3 ro, in vec3 rd )
{
    float res = 2.0;
    float t = 0.002;
    for( int i=1; i<90; i++ )
    {
        vec3  p = ro + t*rd;
        float h = p.y - TerrainH( p.xz );
        res = min( res, 26.0*h/t );
        t += h;
        if( res<0.002 ||p.y>(SC*30.0) ) break;
    }
    return clamp( res, 0.1, 2.0 );
}

// Function 1315
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {
    float sh = 1.0;
    float t = mint;
    float h = 0.0;
    for(int i = 0; i < 15; i++) {
        if(t > maxt) continue;
        h = map(ro + rd * t).w;
        sh = min(sh, k * h / t);
        t += h;
    }
    return sh;
}

// Function 1316
float shade(vec3 p, vec3 rd) {
 	vec3 lp = vec3(-5.,6.,-2.);
    vec3 l = normalize(lp-p);
    vec3 n = norm(p);
    float col = 0.;
    float dif = clamp(dot(n,l)*.5+.5,0.,1.);
   	float fr = pow(1.0+dot(n, rd),4.0);
    float sp = pow(max(dot(reflect(-l, n),-rd),0.0),80.);
   	float ao = (1.0 - fr);
   	float fd = 1.0 - dif;
    col = sp + max(fr, 0.5) + dif * ao;
    return col;
}

// Function 1317
vec3 shade( in vec3 p, in vec3 d, in vec3 t, in float i, in vec3 n, in vec3 e )
{
    // Get the position's distance from the camera.
    float l = length(p-e);
    // And let's get the culled color since we need it.
    vec3 cull = vec3(.06);
    // Shortcut the glass.
    if( i == ID_WINDOW ) return t;
    // Brighten the candles if we need to.
    #ifdef TURN_THE_LIGHTS_ON_IN_HERE
    else if( i == ID_CANDLES ) return t*.75;
    #endif
    // If the ray didn't hit anything, we shortcut out.
    if(l >= MAX_DEPTH)return vec3(.05);
    // Otherwise we do texturing and lighting for this point.
    vec3 result = t*light(p,d,e,n);
    // Smooth out the transition between geometry and emptiness.
    return mix(cull,result,clamp(MAX_DEPTH-l,0.0,1.0));
}

// Function 1318
vec3 doLighting( vec3 ro , vec3 rd ){
    
    
    
}

// Function 1319
vec4 light(in vec4 tex, in vec3 s, in vec3 p, in vec3 d, in vec2 uv, in float fan)
{
    // Since we have two planes, we can just go ahead and estimate the norm.
    vec3 n = vec3(0.0,-s.y,0.0);
    n.xz = -texNorm(uv,TEXTURE).xz;
    n = normalize(n);
    //return texNorm(uv,TEXTURE).rgbb;
    vec3 ld = -normalize(s-p);
    return 1.5*tex*dot(n,ld)*smoothstep(1.0-fan-.1,1.0-fan,clamp(dot(-ld,d),0.0,1.0));
}

// Function 1320
bool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )
{
	vec3 oc = ro - cen;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - rad*rad;
	float h = b*b - c;
	if( h<0.0 ) return false;
	float t = -b - sqrt( h );
    return t>0.0 && t<tmax;
}

// Function 1321
float castShadowRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	float t = -1.0;
	float res = 1.0;
	
    // first step we check noching	
	vec2 mm = step( dis.xy, dis.yx ); 
	dis += mm * ris;
    pos += mm * rs;
	
    // traverse regular grid (2D)	
	for( int i=0; i<16; i++ ) 
	{
		float ma = map(pos);
		
        // test capped cylinder		
		vec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.249;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t = (-b - sqrt( h ))/a;
			if( (ro.y+t*rd.y)<ma )
			{
				res = 0.0;
    			break; 
			}
		}
		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}

	return res;
}

// Function 1322
float atm_planet_shadow( float coschi, float cosbeta )
{
    return clamp( SCN_RAYCAST_SHADOW_UMBRA * ( coschi + cosbeta ) + .5, 0., 1. );
}

// Function 1323
vec3 lightSource(vec3 spotLight, vec3 dir, float dis)
{
    float g = 0.0;
    if (length(spotLight) < dis)
    {
		g = pow(max(dot(normalize(spotLight), dir), 0.0), 2000.0);
    }
   
    return vec3(g, g*.8, g*.7)*.8;
}

// Function 1324
vec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, float shadow) 
{
	vec3 albedo = color.xyz;
	norm.w = dir.w;
    vec3 N = norm.xyz;
	vec4 ambient_color = ambient_occlusion(pos, norm,dir.xyz);
	
	float metallic = pbr.x;
	vec3 F0 = vec3(0.04); 
	F0 = mix(F0, albedo, metallic);
	
	//reflectance equation
	vec3 Lo = vec3(0.0);
	vec3 V = -dir.xyz;
	
	
	{ //ambient occlusion contribution
		float roughness = pbr.y;
		vec3 L = normalize(norm.xyz);
		vec3 H = normalize(V + L);
		vec3 radiance = ambient_color.xyz;        
		
		// cook-torrance brdf
		float NDF = DistributionGGX(N, H, roughness);        
		float G   = GeometrySmith(N, V, L, roughness);      
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       
		
		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
		vec3 specular     = numerator / max(denominator, 0.001);  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(N, L), 0.0);                
		Lo += (kD * albedo / PI + specular) * radiance * NdotL;
	}
	
	vec3 sun_color = sky_color(light);

	{ //light contribution
		float roughness = pbr.y;
		vec3 L = normalize(light);
		vec3 H = normalize(V + L);
		vec3 radiance = sun_color*shadow;        
		
		// cook-torrance brdf
		float NDF = DistributionGGX(N, H, roughness);        
		float G   = GeometrySmith(N, V, L, roughness);      
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       
		
		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
		vec3 specular     = numerator / max(denominator, 0.001);  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(N, L), 0.0);                
		Lo += (kD * albedo / PI + specular) * radiance * NdotL;
	}
	
	return Lo;
}

// Function 1325
vec3 shade(vec3 pos, vec3 n, vec3 eyePos)
{
    //const float shininess = 20.0;
	//const vec3 l = vec3(0.577, 0.577, -0.577);
    vec3 v = normalize(eyePos - pos);
    //vec3 h = normalize(v + l);
	
    //float diff = dot(n, l);
    //float spec = pow(max(0.0, dot(n, h)), shininess) * float(diff > 0.0);
    //diff = max(0.0, diff);
    //diff = 0.5+0.5*diff;
	
	// reflection
	vec3 R = reflect(-v, n);
	vec3 Rcol = texture(iChannel1, R).xyz;
	
	// refraction
	//const float eta = 1.0 / 1.4;	// air-glass
	const float eta = 1.0 / 1.1;	// air-glass
		
#if 0
	vec3 T = normalize(-v + n*0.1);
	//vec3 T = refract(-v, n, eta);
	vec3 Tcol = texture(iChannel1, T).xyz;
#else
	// dispersion
	vec3 T = refract(-v, n, eta);
	vec3 Tcol;
	Tcol.r = texture(iChannel1, T).r;
	T = refract(-v, n, eta + 0.01);
	Tcol.g = texture(iChannel1, T).g;	
	T = refract(-v, n, eta + 0.02);
	Tcol.b = texture(iChannel1, T).b;	
#endif
	
    float f = fresnel(n, v, 0.2);

    //return diff*c + vec3(spec);
	//return c;
	//return Rcol;
	//return Tcol;
    //return vec3(diff*ao)*c + vec3(spec);
    //return n*0.5+0.5;
    //return vec3(f);	
	return Rcol*f;
	//return mix(Tcol, Rcol, f);
}

// Function 1326
vec3 pointLight(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)
{
    vec3 lightVector = L - pos;
    float lightDistance = length(lightVector);
    vec3 lightDir = lightVector / lightDistance;
    
    float shadow = shadow(pos, lightDir, lightDistance);
    return PBR(pos, albedo, metalness, roughness, N, V, lightDir, Lradiance) * shadow / (lightDistance * lightDistance);
}

// Function 1327
vec3 GetLight(vec3 point, vec3 incident, int mat, vec3 col) 
{
    //	Light Accumulator
    vec3 lightTotal = vec3(0);
    
    for (int i=0; i<L.length(); i++) 
    {
        //	Surface Normal
    	vec3 normal = GetNormal(point);
        
        //	Light Vector
    	vec3 light = L[i].position - point;
        float d = length(light);
        light = normalize(light);
    
        //	Base Light
        float lightFalloff = 1.0;//(d * d);
        vec3 lightBase = col * L[i].color * L[i].intensity / lightFalloff;
        
        //	Ambient Component
        lightTotal += lightBase * M[mat].color * M[mat].ambient;

        //	Test for Shadows
        raysample s = RayMarch(point+normal*SURF_DIST*2., light, 0, vec3(0));
        
        //	Not In Shadow?
        if (s.dist > d) 
        {
		    //	Diffuse Component
            lightTotal += lightBase * M[mat].color * M[mat].diffuse * max(dot(normal, light), 0.);

            //	Specular Component
            lightTotal += lightBase * M[mat].specular * pow(max(dot(reflect(incident, normal), light), 0.), M[mat].gloss);
        }
    }
    return lightTotal;
}

// Function 1328
vec3 shade(vec4 n, vec4 pos){
    vec3 iFin = vec3(0.0);
    float amb = 0.5;
    {
        vec3 col = vec3(0.7, 0.3, 0.0);
        vec4 lpos = vec4(1.0);
     	vec4 lidir = normalize(lpos - pos);
     	float libdir = dot(n, lidir);
     	iFin += col * (libdir + amb);
    }
    {
        vec3 col = vec3(0.0, 0.2, 0.7);
        vec4 lpos = vec4(-1.0);
     	vec4 lidir = normalize(lpos - pos);
     	float libdir = dot(n, lidir);
     	iFin += col * (libdir + amb);
    }
    return iFin;
}

// Function 1329
vec3 getLightColor( in vec3 pos ) {
    vec3 lcol = vec3( 1., .7, .5 );
    
	vec3 pd = pos;
    pd.x = abs( pd.x );
    pd.z *= -sign( pos.x );
    
    float ch = hash( floor( (pd.z+18.*time)/40. ) );
    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );

    if( ch > 0.75 ) { // car
        pdc.x += (ch-0.75)*4.;
        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {
            lcol = vec3( 1., 0.05, 0.01 );
        }
    }
    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {
        float fl = floor( pd.z/13. );
        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );
    }
    if(  abs(pd.x) > 10. && pd.y > 5. ) {
        float fl = floor( pd.z/2. );
        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );
    }
   
    return lcol;
}

// Function 1330
bool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return false;
	return tN>0.0 && tN<tmax;
}

// Function 1331
vec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {
    vec3 V = normalize(ro - pos); 
    vec3 R = reflect(-V, N);
    float NdotV = max(0.0, dot(N, V));

    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);

    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);

    vec3 kS = F;

    vec3 prefilteredColor = getSpecularLightColor(R, roughness);
    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;
    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);

    vec3 kD = vec3(1.0) - kS;

    kD *= 1.0 - metallic;

    vec3 irradiance = getDiffuseLightColor(N);

    vec3 diffuse  = albedo * irradiance;

#ifdef P_MALIN_AO
    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);
#else
    vec3 color = (kD * diffuse + specular) * ao;
#endif

    return color;
}

// Function 1332
vec3 map_light_pm(in vec3 ro, in vec3 rd) { 
    vec3 nrm = map_light_norm(ro);
    return lightCol*brightness*max(0.,dot(-rd, nrm));
}

// Function 1333
vec3 areaLights( vec3 pos, vec3 nor, vec3 rd )
{
	float noise		=  texture( iChannel1, pos.xz ).x * 0.5;
	noise			+= texture( iChannel1, pos.xz * 0.5 ).y;
	noise			+= texture( iChannel1, pos.xz * 0.25 ).z * 2.0;
	noise			+= texture( iChannel1, pos.xz * 0.125 ).w * 4.0;
	
	vec3 albedo		= pow( texture( iChannel0, pos.xz ).xyz, vec3( 2.2 ) );
	albedo			= mix( albedo, albedo * 1.3, noise * 0.35 - 1.0 );
	float roughness = 0.7 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );
	float f0		= 0.3;
	
	#ifdef DISABLE_ALBEDO
	albedo			= vec3(0.1);
	#endif
	
	#ifdef DISABLE_ROUGHNESS
	roughness		= 0.05;
	#endif
	
	vec3 v			= -normalize( rd );
	float NoV		= clamp( dot( nor, v ), 0.0, 1.0 );
	vec3 r			= reflect( -v, nor );
	
	float NdotLSphere;
	float specSph	= sphereLight( pos, nor, v, r, f0, roughness, NoV, NdotLSphere );
	
	float NdotLTube;
	float specTube	= tubeLight( pos, nor, v, r, f0, roughness, NoV, NdotLTube );
	
	vec3 color		= albedo * 0.3183 * ( NdotLSphere + NdotLTube ) + specSph + specTube;
	return pow( color, vec3( 1.0 / 2.2 ) );
}

// Function 1334
vec3 GetLightIntensity(in vec3 pos)
{
    Ray ray;
    ray.org = pos;
    ray.dir = normalize(lightPos - ray.org);
    ray.org += ray.dir*epsilon;
    
    RayTraceSceneResult scene = RayTraceScene(ray, true);
    return scene.hit.t > length(lightPos - ray.org) ? ComputeLightAttenuation(ray.org) : vec3(0.);
}

// Function 1335
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.03;
  for (int j = VAR_ZERO; j < 20; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += clamp (3. * h, 0.05, 0.3);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1336
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint, h;
    for( int i=0; i<16; i++ )
    {
        
	    if( SCENE_MODE == 0 ) {
			h = map_0( ro + rd*t ).x;
    	} else if( SCENE_MODE == 1 ) {
			h = map_1( ro + rd*t ).x;
    	} else if( SCENE_MODE == 2 ) {
			h = map_2( ro + rd*t ).x;
   		} else if( SCENE_MODE == 3 ) {
			h = map_3( ro + rd*t ).x;
   		} else if( SCENE_MODE == 4 ) {
			h = map_4( ro + rd*t ).x;
   		} else if( SCENE_MODE == 5 ) {
			h = map_5( ro + rd*t ).x;
   		} else if( SCENE_MODE == 6 ) {
			h = map_6( ro + rd*t ).x;
   		}
        
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1337
float GetLight(vec3 p){
    //position of the light source
    vec3 lightPos = vec3(0,5,-5);
    
    lightPos.xz += vec2(sin(iTime),cos(iTime));
    //light vector
    vec3 l = normalize(lightPos-p);
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;
    if(d < length(lightPos-p)){
        diff *= 0.1;
    }
    return diff;
}

// Function 1338
vec3 Sample_SphLight_SolidAngle(vec2 s, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    float ct; vec3 Lc, L; float sang;
    Sample_SolidAngle(s, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L, /*out*/ sang);

    float NoL = dot(N, L);

    if(NoL <= 0.0) return vec3(0.0);
    
    float t2; vec3 n2; vec3 a2; bool isLight2 = true;
    bool hit = Intersect_Scene(p, L, false, /*out: */ t2, n2, a2, isLight2);

    if(!isLight2 && t2 < dot(LightPos-p, Lc)) return vec3(0.0);
    
    vec3 f = Frostbite_R(V, N, L, albedo, roughness, F0);
    float rpdf = sang;

    return f * rpdf * Radiance;
}

// Function 1339
float softshadow(vec3 ro,vec3 rd) 
{
    float sh = 1.0;
    float t = 0.02;
    float h = 0.0;
    for(int i = 0; i < 23; i++)  
	{
        if(t > 20.) continue;
        h = map(ro + rd * t)+0.003*rand1(gl_FragCoord.xy+iTime);
        sh = min(sh, 4.0 * h / t);
        t += h;
    }
    return sh;
}

// Function 1340
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<25; i++ )
    {
        h = sdDolphinCheap(ro + rd*t);
        res = min( res, k*h/t );
		t += clamp( h, 0.05, 0.5 );
		if( h<0.0001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1341
vec3 CalcLighting(Light light, Intersection i, vec3 origin)
{
	if ( i.dist >= ZMAX ) {
		return backgroundColor;
	}
	vec3 n = i.n;
	vec3 p = i.p;
	vec3 l = light.p;
	vec3 v = normalize(origin-p);
	vec3 h = normalize(l+v);
	float NdotL = saturate(dot(n,l));
	float NdotH = saturate(dot(n,h));
	vec3 diffuse = NdotL*i.diffuse;
	vec3 spec = 0.18 * pow(NdotH,40.0) * i.specular;
	vec3 color;
	color = (diffuse+spec) * light.color;

	Ray shadowRay;
	shadowRay.o = i.p;
	float lightDist = 100.0;
	shadowRay.dir = light.p;
	Intersection shadowI = SceneIntersection(shadowRay);
	if(shadowI.dist < lightDist)
	{
		color *= 0.4;
	}
	
	return color;
}

// Function 1342
float calculateAO(in vec3 p, in vec3 n){
	
    float sca = 1., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 1343
Light pickOneLight(out float lightPickingPdf) {
    lightPickingPdf = 1.0;
    return lights[0];
}

// Function 1344
float ao(vec3 p, vec3 n) {
	float td=0., ao=0.;
    for(int i=0; i<6; i++) {
		td+=.05;
		float d=de(p-n*td);
        ao+=max(0.,(td-d)/td);
    }
	return clamp(1.-ao*.1,0.,1.);
}

// Function 1345
vec3 shader4(){
	float t=iTime;
	vec2 r =  2.0*vec2(fragCoord2.xy - 0.5*iResolution.xy)/iResolution.y;
	vec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	vec3 colorFondo = water();
	r=animatePos(r);
	p=animatePos(p);
	
	vec3 color1 = vec3(0.8, 0.8, 0.8); 
	float incrementoAngulo=(2.0/float(7))*PI;
	for(int i=0;i<numRadios;i++){
		float angle=float(i)*incrementoAngulo;
		vec2 q=vec2(0.0,0.0);
		q.x =   cos(angle)*r.x + sin(angle)*r.y;
		q.y = - sin(angle)*r.x + cos(angle)*r.y;
		q=-q;
		colorFondo = mix(colorFondo, color1, lineas(q) );
	}
	
	float tamanioMax=1.1;
	float tamanioMin=0.4;
	float escalaHilo=0.25;
	float anchura=(tamanioMax-tamanioMin)/float(numCapas);
	float grosorHilo=anchura*escalaHilo;
	vec2 posicion=vec2(0.0,0.15);
	for(int i=0;i<numCapas;i++){
		float tamanioCorazon=tamanioMax-(float(i)*anchura);
		vec3 colorAux=corazon2(posicion,p,tamanioCorazon,colorFondo,color1);
		colorFondo=corazon2(posicion,p,tamanioCorazon-grosorHilo,colorAux,colorFondo);
	}
	corazon4(posicion,p,tamanioMin,colorFondo);
	return colorFondo;
}

// Function 1346
float calcAO(vec3 pos, vec3 nor) {
	float hr,dd,aoi=0.,sca=1.,totao=0.;
	hr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.6;aoi++;
	hr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;
	hr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;
	hr = .075*aoi*aoi;dd = de(nor * hr + pos);totao += (hr-dd)*sca;sca*=.55;aoi++;
	return clamp( 1.0 - 4.*totao, 0., 1.0 );
}

// Function 1347
vec4 GetDistanceChaosTrendLogo(const in vec3 vPos)
{
	//initialize with material '4' and x/y UV plane
	vec4 vResult = vec4(10000.0, 4, vPos.x, vPos.y);
	//work out which cylinder segment vPos is in	
	float r =  SelectSegment(vPos, 8.0);
	//and rotate the arrow domain accordingly
	vec3 vChaosArrowDomain = RotateZ(vPos, r );
	//shift outwards from centre
	vChaosArrowDomain.y -=3.5;		
	float arrowDist = dChaosArrow(vChaosArrowDomain);					
	vResult.x = DistCombineUnion(vResult.x, arrowDist);	
	//remove inner cylinder
	float cyldist = GetDistanceCylinderZ(vPos, 1.4);	
	vResult.x = DistCombineSubtract(vResult.x, cyldist);	
	return vResult;
}

// Function 1348
vec3 Shade(MarchResult hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(0.0);

    if(hit.id == FLOOR)
    {
        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); 
        
        uv /= fwidth(hit.position.xy);
        
        float riverEdge = 1.0; //dfRiver(hit.position, 0.0).x / fwidth(hit.position.xy).x;
                                                       
        float gln = min(min(uv.x, uv.y), riverEdge) / GRID_SIZE;
        
    	color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
    } 
    
    //Distance fog
    color *= 1.0 - smoothstep(0.0, MAX_DIST*0.9, hit.dist);
    
    return color;
}

// Function 1349
vec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo, in vec3 rdx, in vec3 rdy )
{
    float eps = 0.001;
    
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps*t );
    vec3 dposdx, dposdy;
    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );

    float kk;

    vec3 mateD = vec3(0.2,0.16,0.11);
    vec3 mateS = vec3(0.2,0.12,0.07);
    vec3 mateK = vec3(0.0,1.0,0.0); // amount, power, metalic
    float focc = 1.0;
        
    if( m<0.5 ) // body
    {
        mateD = vec3(0.27,0.26,0.25)*0.4;
        mateS = vec3(0.27,0.26,0.25)*0.4;
        mateK = vec3(0.12,20.0,0.0);
        
        float te = texcube( iChannel1, 0.25*pos, nor, 4.0, 0.25*dposdx, 0.25*dposdy ).x;
        mateD *= 0.2+0.6*te;
        mateK *= te;
        
        mateD *= 1.1 - 0.4*smoothstep( 0.3, 0.7, matInfo.x );
        mateD = mix( mateD, mateD*vec3(1.1,0.8,0.7), smoothstep( 0.0, 0.15, matInfo.y ) );

        focc *= 0.5 + 0.5*smoothstep(0.0,3.0,pos.y);
                   
        vec3 q = pos - vec3(-0.5,2.4,0.0);

        //---
        vec2 est = q.xy-vec2(-0.31,-0.02);
        mateD *= mix( vec3(1.0), vec3(0.2,0.15,0.1), exp(-20.0*dot(est,est)) );

        mateD *= 1.2;
        mateS *= 1.2;
        mateK.x *= 1.2;
        
        mateK.xy *= vec2(3.0,2.0);
    }
    else if( m<1.5 ) // teeh
    {
        mateD = vec3(0.3,0.28,0.25)*0.9;
        mateS = vec3(0.3,0.28,0.25)*0.9;
        mateK = vec3(0.2,32.0,0.0);
        mateD *= mix( vec3(0.45,0.4,0.35), vec3(1.0), sqrt(matInfo.x) );
        focc = smoothstep(0.1,0.3,matInfo.x);
        float te = texcube( iChannel1, 0.5*pos, nor, 4.0, 0.5*dposdx, 0.5*dposdy ).x;
        mateD *= te;
        mateK.x *= te;
    }
    else //if( m<2.5 ) //eyeball
    {
        mateD = vec3(0.0);
        mateS = vec3(0.0);
        mateK = vec3(0.4,32.0,0.0);
    }
    
    vec3 hal = normalize( sunDir-rd );
    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor )*focc;
        
    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );
    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );
    float sha = calcSoftShadow( pos, sunDir, 16.0 );
    sha = min( sha, dapples(pos,sunDir) );
    dif1 *= sha;
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );
    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );
    
    float rod1 = 1.0 - (1.0-smoothstep( 0.15,0.2, length(pos.yz-vec2(1.8,0.3))))*(1.0-smoothstep(0.0,0.1,abs(pos.x+0.2)));

    
    // sun
    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;
    // sky
    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);
    // ground
    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;
    // back
    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ*rod1;
    // sss
    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS*rod1;

    // sun
    vec3 hdir = normalize(sunDir - rd);
    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );
    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));

    // sky spec
    float sksp = occ*occ*smoothstep(-0.2,0.2,reflect(rd,nor).y)*(0.5+0.5*nor.y)*mateK.x * (0.04 + 0.96*pow(fre,5.0));

    col += mateK.z*15.0*5.0*spp; 

    col *= mateD;

    col += (1.0-mateK.z)*75.0*spp; 
    col += (1.0-mateK.z)* 3.0*sksp*vec3(0.35,0.7,1.0); 

    return col;        
}

// Function 1350
vec3 getLightnessOklab(float rawLightness, float rawChroma, float hue) {
    vec3 lch = vec3(rawChroma, 0.0, hue);
    vec3 oklab = lchToLab(lch);
    return oklabToLinearSrgb(oklab);
}

// Function 1351
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN>tF || tF<0.0) return 1.0;
	return 0.0;
}

// Function 1352
float lightPointDiffuse(vec3 pos, vec3 lightPos) {
	float lightDist = length(lightPos - pos);
	float color = 3.0 / (lightDist * lightDist);
	return max(0.0, color*10.0);
}

// Function 1353
vec3 lighting(vec3 p,vec3 rd, float ps) {
	
	vec3 l1_dir = normalize(vec3(0.8, 0.8, 0.4)); 
    vec3 l1_col = 0.3*vec3(1.5, 1.69, 0.79);
	vec3 l2_dir = normalize(vec3(-0.8, 0.5, 0.3));
    vec3 l2_col = vec3(0.89, 0.99, 1.3); 
    
    vec3 e=vec3(0.5 * ps,0.0,0.0); 
 	vec3 n = normalize(vec3(f(p+e.xyy)-f(p-e.xyy), 
 						  f(p+e.yxy)-f(p-e.yxy), 
 						  f(p+e.yyx)-f(p-e.yyx)));
	
	float shadow = softshadow(p, l1_dir, 10.0 );

    float dif1 = max(0.0, dot(n, l1_dir));
	float dif2 = max(0.0, dot(n, l2_dir));
	float bac1 = max(0.3 + 0.7 * dot(vec3(-l1_dir.x, -1.0, -l1_dir.z), n), 0.0);
	float bac2 = max(0.2 + 0.8 * dot(vec3(-l2_dir.x, -1.0, -l2_dir.z), n), 0.0);
    float spe = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 10.0)); 

    vec3 col = 5.5 * l1_col * dif1 * shadow;
	col += 1.1 * l2_col * dif2;
	col += 0.3 * bac1 * l1_col;
	col += 0.3 * bac2 * l2_col; 
    col += 1.0 * spe; 
	
    float t=mod(p.y+0.1*texture(iChannel0,p.xz).x-time*150.0, 5.0);
    col = mix(col, vec3(6.0, 6.0, 8.0), 
              pow(smoothstep(0.0, .3, t) * smoothstep(0.6, .3, t), 15.0));;
	return col;
}

// Function 1354
vec3 sampleIndirectLight(vec3 pos, vec3 normal){
    vec3 dir;
    vec3 abso = vec3(1.), light = vec3(0.), dc, ec;
    for(int i = 0; i < Bounces; i++){
        dir = getCosineWeightedSample(normal);
        if(!trace(pos, dir, normal)) return light + abso*background(dir);
        sdf(pos, dc, ec);
        light += abso * (ec + dc*directLight(pos, normal));
        abso *= dc;
    }
    return light;
}

// Function 1355
float light(vec3 p, vec3 dir) {
    vec3 n = normal(p);
    float diffuse = spotLight(p, n);
    return diffuse;
}

// Function 1356
float lights(in vec3 p)
{
	p.xz = mod(p.xz, LIGHTS_REP)-.5*LIGHTS_REP;
    // Fatten up those capsules.
    p.z *= .25;
	return capsule(p, LIGHTS_A, LIGHTS_B, LIGHTS_R);
}

// Function 1357
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1358
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1359
float calcAO(const in vec3 pos, const in vec3 nor) {
  float occ = 0.0;
  float sca = 1.0;
  for(int i = 0; i < 5; i++) {
      float hr = 0.01 + 0.03 * float(i);
      vec3 aopos = nor * hr + pos;
      occ += (hr - mapDistance(aopos)) * sca;
      sca *= 0.95;
  }
  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    
}

// Function 1360
vec3 shade(Ray ray) {
 
    Hit scn  = raymarch(ray);
	vec3 col = getSky(ray.dir);  

    float waterTMax = 256.;
    float waterT = raymarchWater(ray, 0., waterTMax);
    
    if(waterT < waterTMax) {
     
        vec3 waterCol = RGB(57,88,121);
        vec3 p = ray.ori + ray.dir * waterT;
        vec3 n = calcWaterNormal(p, waterT);
        vec3 r = reflect(ray.dir, n);
        
        float shadow = getShadow(Ray(p+LIGHT_DIR*EPSILON,LIGHT_DIR));
        
       	vec3 diffuse = (max(dot(LIGHT_DIR, n), 0.)*shadow) * LIGHT_COL + LIGHT_AMB;
        waterCol *= diffuse;
        
        vec3 rc = getSky(r);
        
        Ray rr = Ray(p + r *.0001, r);
        Hit rh = raymarch(rr);
        if(rh.id == 0) {
            
            rc = shadeBox(rr,rh);
            
        }
        
        float fresnel = mix(.2, .8, pow(1. + min(dot(n,ray.dir),0.), 7.5));
        col = mix(waterCol, rc, fresnel);
        
        float specular = pow(max(dot(LIGHT_DIR, r),0.),20.) * shadow;
        col = col + specular*LIGHT_COL;
        
    }
    
    if(scn.id == 0) {
     
        if(waterT < distance(ray.ori,scn.p)) {
         
            return col;
            
        }
        
        col = shadeBox(ray, scn);
        
    }
    
    return col;
    
}

// Function 1361
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )
{
    vec3 lin = vec3(0.);

    // key light
    //-----------------------------
    vec3  lig = normalize(vec3(-1.0,0.7,-0.9));
    float dif = max(dot(nor,lig),0.0);
    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(4.00,4.00,4.00)*sha;

    // ambient light
    //-----------------------------
    lin += vec3(0.50,0.50,0.50);

    
    // surface-light interacion
    //-----------------------------
    vec3 col = mal*lin;

    
    // fog    
    //-----------------------------
	col *= exp(-0.001*dis);

    return col;
}

// Function 1362
float calcShadow( vec3 origin, vec3 lightDir, Light light)
{
	float dist;
	float result = 1.0;
	float lightDist = length(light.position-origin);
	
	vec3 pos = vec3(origin)+(lightDir*(EPSILON*15.0+BUMP_FACTOR));
	
	for(int i = 0; i < MAX_SHADOW_STEPS; i++)
	{
		dist = getDist(pos);
		if(dist < EPSILON)
		{
			return 0.0;
		}
		if(length(pos-origin) > lightDist || length(pos-origin) > MAX_DEPTH)
		{
			return result;
		}
		pos+=lightDir*dist;
		if( length(pos-origin) < lightDist )
		{
			result = min( result, light.penumbraFactor*dist / length(pos-origin) );
		}
	}
	return result;
}

// Function 1363
vec3 shade( in vec3 ro, in vec3 rd, in float t, float m )
{
    float eps = 0.001;
    vec3 pos = ro + t*rd;
    vec3 nor = calcNormal( pos, eps );
    vec3 ref = reflect( rd, nor );
    
    vec3 mate = vec3(1.0,1.0,1.0);
    
    if( m<0.5 )
    {
        mate = vec3(0.7);
    }
	else
    {
        mate = vec3(0.0,0.0,0.0);
        
        vec2 uv = (mtxHead * vec4(pos,1.0)).xy;

        uv.x = abs(uv.x);
        uv -= vec2(0.11,0.565-0.5);
        vec2 st  = uv;
        uv = mat2(0.9,-0.4,0.4,0.9)*uv;
        vec3 eye = vec3(0.02,0.2,0.9)*1.9;
        eye *= 0.9 + 0.1*sin(512.0*st.x + sin(512.0*st.y));
        
        float eyesN = 1.0-smoothstep( 0.03, 0.06, length(uv * vec2(0.7,1.0)) );
        float eyesB = 1.0-smoothstep( 0.00,0.008,abs(st.y));
        float bl = smoothstep( 0.9,0.91, sin(10.0*iTime)*sin(3.0*iTime) );
        float eyes = mix( eyesN, eyesB, bl );
        mate = mix( mate, eye, eyes );
        
        mate += (0.01+mate)*0.9*smoothstep(-0.1,0.1,sin(st.y*400.0));
    }
    
    vec3 hal = normalize( sundir - rd );
    
    float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );
    float occ = calcAO( pos, nor );

    float bak = clamp( dot(nor,normalize(vec3(-sundir.x,0.0,-sundir.z))), 0.0, 1.0 );
    float dif = clamp( dot(nor,sundir), 0.0, 1.0 );
    float spe = clamp( dot(nor,hal), 0.0, 1.0 );
    float sha = calcSoftshadow( pos, sundir, 8.0 ); 
    dif *= sha;

    vec3 col = 1.4*vec3(1.0,0.9,0.8)*dif +  0.8*vec3(0.2,0.28,0.35)*occ;
    col += vec3(1.2,1.0,0.8)*fre*(0.3+0.7*dif)*occ*3.5;
    col += vec3(0.4,0.3,0.2)*bak*occ;
    
    col *= mate;
    
    col += 3.5*vec3(0.3,0.4,0.5) * smoothstep( -0.1, 0.1, ref.y ) * (0.04 + 0.96*pow( fre, 5.0 )) * occ;
    col += 2.0*vec3(1.0)*pow( spe, 64.0 ) * (0.2 + 0.8*pow( fre, 5.0 )) * (occ*dif);
    
    col = pow( col, vec3(0.8,1.0,0.9) );

    col *= mix( vec3(0.3,0.2,0.1), vec3(1.0), smoothstep(-1.0,0.4,pos.y) );
    return col;        
}

// Function 1364
vec3 shade(vec2 uv){
	
	float v=1.;
	for(float i=0. ; i<4. ; i++){
		float d=mod(iTime/pow(10.,i-0.),1.)*10.;
		//if(d<0.1) break;
		v=min(v,ddig(uv*1.5+vec2(i*1.3-1.95,0.),int(d)));
	}
	
	v=smoothstep(0.07,0.05,v);
	
	return vec3(v);
}

// Function 1365
vec3 tower_lightcolor(vec2 coords)
{
    return mix( texture(iChannel0, (10./iChannelResolution[0].xy) * coords).rgb,
                texture(iChannel1, (10./iChannelResolution[1].xy) * coords).rgb,
                periodicsmoothstep( .05 * g_time - .005 * (coords.x + coords.y) - 1.));
}

// Function 1366
float softshadow( in vec3 ro, in vec3 rd, float mint, float k, vec3 c )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<80; i++ )
    {
        vec4 kk;
        float h = map(ro + rd*t, c, kk);
        res = min( res, k*h/t );
        if( res<0.001 ) break;
        t += clamp( h, 0.002, 0.1 );
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1367
float highlight(float circle, vec2 pos, float radius)
{
    float h = smoothstep(0., radius, length(pos));
    h -= 1.-circle;
    return h*(.4+(sin(iTime)+1.)*.1);
}

// Function 1368
vec4 shade(vec2 shadinginfo, vec3 pos, vec3 eye)
{
	if(shadinginfo.y == 0.0)
    {
     	return phong(pos);	//flat shade   
    }
    else if(shadinginfo.y == 1.0)
    {
     	return phong(pos);	//non-flat shade   
    }
    else if(shadinginfo.y == 2.0)
    {
     	return phong(pos);	//non-non-flat shade   
    }
    else
    {
     	return CORNFLOWERBLUE;   //whatever
    }
}

// Function 1369
bool in_earth_shadow( vec3 p, vec3 sun_direction ) { return ( dot( p, sun_direction ) < 0.0 ) && ( lensqr( p - project_on_line1( p, earth_center, sun_direction ) ) < earth_radius * earth_radius ); }

// Function 1370
vec3 computeLight(vec3 pos, vec3 color, vec3 normal) 
{
    vec3  toLight1 = LIGHT1_POS - pos;
    float distSq1  = dot(toLight1, toLight1);
    float att1     = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) 
                     ? 0.0 : 10.0f / distSq1;
    
    vec3  toLight2 = LIGHT2_POS - pos;
    float distSq2  = dot(toLight2, toLight2);
    float att2     = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) 
                     ? 0.0 : 20.0f / distSq2;
    
    vec3  toLight3 = LIGHT3_POS - pos;
    float distSq3  = dot(toLight3, toLight3);
    float att3     = isOccluded(pos, LIGHT3_POS + randDir * LIGHT3_RADIUS) 
                     ? 0.0 : 15.0f / distSq3;
    
    return color * (max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR
                  + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR
                  + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR
                  + texture(iChannel1, normal).rgb * 0.1);
}

// Function 1371
float calcAO(in vec3 p, in vec3 n){

	float sca = 2., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
        
        // Deliberately redundant line that may or may not stop the 
        // compiler from unrolling.
        //if(sca>1e5) break;
    }
    
    return clamp(1. - occ, 0., 1.);
}

// Function 1372
vec3 shade( in vec4 p, in vec3 n, in vec3 org, in vec3 dir )
{		
	//direct lighting
	vec3 col = vec3(.1);
	col += pow(sky(vec3(1.,0.,0.))*max( dot(n, ldir), 0.)*2., vec3(2.));
	
	//illumination of the tree
	col += mix( vec3(1.,.3,.1), vec3(.1, .7, .1), length(p.xyz)/8.)*ill*p.w*5.;
	
	//ao
	col *= pow( ambiantOcclusion(p.xyz,n,1.) , 1.5 );
	
	//fog/sky
	col = mix(col, sky(dir), vec3(1.)*min( pow( distance(p.xyz,org)/20., 2. ), 1. ) );
	
	return col;
}

// Function 1373
float ts_shadow_eval( vec2 lookup, float test )
    { return lookup.x != lookup.y ? parabolstep( lookup.x, lookup.y, test ) : 1.; }

// Function 1374
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, float glossy, float glossy2, float shadows, in vec3 col, float occ )
{
    vec3 hal = normalize(lig-rd);
	vec3 ref = reflect(rd,nor);
	
    // lighting
    float sky = clamp(nor.y,0.0,1.0);
	float bou = clamp(-nor.y,0.0,1.0);
    float dif = max(dot(nor,lig),0.0);
    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);
    float sha = 1.0-shadows; if( (shadows*dif)>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );
    float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );
    float spe = max( 0.0, pow( clamp( dot(hal,nor), 0.0, 1.0), 0.01+glossy ) );
    float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );

    
    float shr = 1.0;
    //if( shadows>0.0 ) shr=softshadow( pos+0.01*nor, normalize(ref+vec3(0.0,1.0,0.0)), 0.0005, 8.0 );

    
    // lights
    vec3 brdf = vec3(0.0);
    brdf += 20.0*dif*vec3(4.00,2.20,1.40)*vec3(sha,sha*0.5+0.5*sha*sha,sha*sha);
    brdf += 11.0*sky*vec3(0.20,0.40,0.55)*(0.5+0.5*occ);
    brdf += 1.0*bac*vec3(0.40,0.60,0.70);//*occ;
    brdf += 11.0*bou*vec3(0.05,0.30,0.50);
    brdf += 5.0*sss*vec3(0.40,0.40,0.40)*(0.3+0.7*dif*sha)*glossy*occ;
    brdf += 0.8*spe*vec3(1.30,1.00,0.90)*sha*dif*(0.1+0.9*fre)*glossy*glossy;
    brdf += shr*60.0*glossy*vec3(0.9,0.95,1.0)*occ*smoothstep( -0.2+0.2*glossy2, 0.2, ref.y )*(0.5+0.5*smoothstep( -0.2+0.2*glossy2, 1.0, ref.y ))*(0.04+0.96*fre);
    col = col*brdf;
    col += shr*(0.3 + 1.7*fre)*occ*glossy2*glossy2*40.0*vec3(1.0,0.9,0.8)*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));//*smoothstep(-0.1,0.0,dif);
    col += 1.2*glossy*pow(spe,4.0)*vec3(1.4,1.1,0.9)*sha*dif*(0.04+0.96*fre)*occ;
	
	return col;
}

// Function 1375
float tubeLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )
{
	vec3 L0			= tubeStart - pos;
	vec3 L1			= tubeEnd - pos;
	float distL0	= length( L0 );
	float distL1	= length( L1 );
	
	float NoL0		= dot( L0, N ) / ( 2.0 * distL0 );
	float NoL1		= dot( L1, N ) / ( 2.0 * distL1 );
	NoL				= ( 2.0 * clamp( NoL0 + NoL1, 0.0, 1.0 ) ) 
					/ ( distL0 * distL1 + dot( L0, L1 ) + 2.0 );
	
	vec3 Ld			= L1 - L0;
	float RoL0		= dot( r, L0 );
	float RoLd		= dot( r, Ld );
	float L0oLd 	= dot( L0, Ld );
	float distLd	= length( Ld );
	float t			= ( RoL0 * RoLd - L0oLd ) 
					/ ( distLd * distLd - RoLd * RoLd );
	
	vec3 closestPoint	= L0 + Ld * clamp( t, 0.0, 1.0 );
	vec3 centerToRay	= dot( closestPoint, r ) * r - closestPoint;
	closestPoint		= closestPoint + centerToRay * clamp( tubeRad / length( centerToRay ), 0.0, 1.0 );
	vec3 l				= normalize( closestPoint );
	vec3 h				= normalize( V + l );
	
	float HoN		= clamp( dot( h, N ), 0.0, 1.0 );
	float HoV		= dot( h, V );
	
	float distLight	= length( closestPoint );
	float alpha		= roughness * roughness;
	float alphaPrime	= clamp( tubeRad / ( distLight * 2.0 ) + alpha, 0.0, 1.0 );
	
	float specD		= specTrowbridgeReitz( HoN, alpha, alphaPrime );
	float specF		= fresSchlickSmith( HoV, f0 );
	float specV		= visSchlickSmithMod( NoL, NoV, roughness );
	
	return specD * specF * specV * NoL;
}

// Function 1376
float shadow(v3 o,v3 i){
 const float a=32.;//shadow hardnes
 float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance
 for(int j=0;j<IterSh;j++){
  h=dm(o+i*t).x;
  r=min(r,h*a/t);
  t+=clamp(h,.02,2.);}//limit max and min stepping distances
 return clamp(r,0.,1.);}

// Function 1377
void shadeScene(inout vec3 o,bool Refl,float id,in vec3 p,float l,in vec3 n,vec2 uv,in vec3 amb,vec3 sun,in vec3 dir)
{
		
    if(id==ID_BLACK) 
    	o= amb*vec3(.3);
     if(id==ID_WOOD) 
    	o= amb*vec3(.6,.3,.1)*texture(iChannel2,uv*3.).rgb;
	if(id==ID_LAPTOPSCR)
    {
        if ( scene.gameState.w == 0. )
        {
            o-=o;
        } else
        {
        	o= vec3(uv.yx,0.5+0.5*sin(iTime));//*amb*texture(iChannel2,uv*2.).x;
        }
    }
    
    if ( id == ID_SSCREEN )
    {
        o = vec3(1,1,0)*amb;
    }
    
    if(id==ID_BAF_TW)
    {
     float n = noise(vec3(uv,.1*iTime)),
          v = sin(6.28*10.*n);
  	  v = smoothstep(0.,1., .7*abs(v)/fwidth(v));
    n = floor(n*20.)/20.;
	o = v * (.5+.5*cos(12.*n+vec3(0,2.1,-2.1))) * amb;
    } else
    if(id==ID_MPA_TW)
    {	vec2 i= floor(uv*60.);
        o=tan(dot(i,i)*.6+sin(iDate.wwx))*amb;
    }
    if(id==ID_MPAL)
    {
    	// scene.gameState.y ==1. => ho la crema
        
        vec3 r = reflect(dir,n);
    	vec3 specular = pow(max(dot(r,sun),0.0),350.0)*sunColor(sun);
    	o= (amb+specular*scene.gameState.y)*vec3(.6,.4,.4);
    }
    
     if(id==ID_PALM) 
    	o= amb*vec3(0.2,.6,.2);
    
    if(id == ID_OCEAN)
    {
     
        o = water(uv).xyz*amb;
    }
    if ( id == ID_BAFRYCE )
    {
        o = vec3(1.)*amb;
    }
    if(id==ID_COCONUT)
    {
    	o= vec3(.54,0.2,.1)*amb;
    }
}

// Function 1378
bool traceShadowRay(Ray ray) {
    for (int k = 0; k < NUM_SPHERES; k++) {
        HitInfo hitInfoTemp;
        if (intersectSphere(spheres[k], ray, hitInfoTemp)) {
            return true;
        }
    }
    for (int k = 0; k < NUM_PLANES; k++) {
        HitInfo hitInfoTemp;
        if (intersectPlane(planes[k], ray, hitInfoTemp)) {
            return true;
        }
    }
    
    return false;
}

// Function 1379
float calcAO( in vec3 pos, in vec3 nor )
{
  float occ = 0.0;
  float sca = 1.0;
  for ( int i=0; i<5; i++ )
  {
    float hr = 0.01 + 0.12*float(i)/4.0;
    vec3 aopos =  nor * hr + pos;
    float dd = Map( aopos );
    occ += -(dd-hr)*sca;
    sca *= 0.95;
  }
  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1380
float shadow(vec3 ro, vec3 rd)
{
    float res = 0.0;
    float tmax = 1.5;
    float t = 0.001;
    for(int i=0; i<30; i++ )
    {
        float h = f(ro+rd*t);
        if( h<0.0001 || t>tmax) break;
        t += h;
    }
    if( t>tmax ) res = 1.0;
    return res;
}

// Function 1381
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
        float h = map(ro + rd*t).x;
		h = max( h, 0.0 );
        res = min( res, k*h/t );
        t += clamp( h, 0.001, 0.1 );
		if( res<0.01 || t>6.0 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1382
float calcSoftshadow( in vec3 _lo, in float _k ) {
    float _res = 1.0;
    float _t = 0.0;
    float _h = 1.0;
   
    for( int _i=0; _i<16; _i++) {
        _h = map(_lo + lig * _t);
        _res = min( _res, _k *_h / _t );
        _t += clamp( _h, 0.01, 1.0 );
                               
        if( _h<0.001 ) break;
    }
   
    return clamp(_res,0.0,1.0);
}

// Function 1383
vec3 shade(vec3 p, vec3 cam) {
  vec2 localbest = bestid;
  vec3 col = vec3(0.8);
  vec2 colr = vec2(hash(localbest*vec2(0.75,0.19)),hash(localbest*vec2(0.35,0.59)));
  if (mat == 1.) {
    col = mix(vec3(0.8),prettycol(colr),0.6);
  } else {
    col *= 0.9+colr.x*0.2;
  }
  vec3 n = norm(p);
  vec3 i = reflect(cam, n);
  float frensel = 1.-pow(abs(dot(n, cam)),2.)*0.5;
  float s = (samp(p, i, 0.5)+samp(p, i, 2.)+samp(p, i, 4.))/3.;
  return col*frensel*s;
}

// Function 1384
SceneResult Scene_LightBulbSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    SceneResult resultBulb = Scene_GetDistanceBulb( vPos );
    SceneResult_Combine( resultInside, resultOutside, resultBulb, insideObjId );
    
    
    SceneResult resultPendant;
    float yTop = 2.3;
    float yBottom = 1.5;
    float pRad1 = 0.55;
    float pRadTop = 0.5;
    float t = (vPos.y - yBottom) / ( yTop - yBottom );
    resultPendant.fDist = length( vPos.xz ) - mix( pRad1, pRadTop, t );
    resultPendant.fDist = max( resultPendant.fDist, -vPos.y + yBottom );
    resultPendant.fDist = max( resultPendant.fDist, vPos.y - yTop );
    resultPendant.fDist = min( resultPendant.fDist, length( vPos - vec3(0,yTop,0) ) - pRadTop );

    resultPendant.vUVW = vec3(vPos);
    resultPendant.iObjectId = MAT_PENDANT;
    
    float fInnerDist = length( vPos - vec3(0,1.5, 0) ) - 0.4;
    if ( -fInnerDist > resultPendant.fDist )
    {
	    resultPendant.fDist = -fInnerDist;
    	resultPendant.iObjectId = MAT_CHROME;
    }
    
    
    SceneResult_Combine( resultInside, resultOutside, resultPendant, insideObjId );

    
    SceneResult resultFlex;
    resultFlex.fDist = length( vPos.xz ) - 0.05;
    resultFlex.fDist = max( resultFlex.fDist, -vPos.y + 1.5f );
    resultFlex.fDist = max( resultFlex.fDist, vPos.y - 5.0f );
    
    resultFlex.vUVW = vec3(vPos);
    resultFlex.iObjectId = MAT_WHITE_GLOSS;
    
    SceneResult_Combine( resultInside, resultOutside, resultFlex, insideObjId );
    
    
    
    SceneResult resultProngs;
    vec3 vProngDomain = vPos;
    vProngDomain.x = abs( vProngDomain.x );
    resultProngs.fDist = DistanceCapsule( vProngDomain, vec3( 0.4, 1.0, 0), vec3(0.05, 2.0, 0.0), 0.01 );
    resultProngs.vUVW = vec3(vPos);
    resultProngs.iObjectId = MAT_CHROME;
    
    SceneResult_Combine( resultInside, resultOutside, resultProngs, insideObjId );
    
    SceneResult resultFilament;
    //resultFilament.fDist = length( vPos ) - 0.1;
    
    vec3 vFilamentDomain = DomainRotateSymmetry( vPos, 6.0);
	resultFilament.fDist = DistanceCapsule( vFilamentDomain, vec3( 0.0, 0.6, 0.3), vec3(0.0, -0.6, 0.3), 0.02 );

    resultFilament.vUVW = vec3(vPos);
    resultFilament.iObjectId = MAT_FILAMENT;
    
    SceneResult_Combine( resultInside, resultOutside, resultFilament, insideObjId );
    
    SceneResult resultWall;
    
    resultWall.fDist = vPos.z + 2.0;
    resultWall.vUVW = vec3(vPos * 0.2);
    resultWall.iObjectId = MAT_TEXTURED_FLOOR;

    SceneResult_Combine( resultInside, resultOutside, resultWall, insideObjId );
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 1385
float calculateAO( in vec3 p, in vec3 n )
{
	float ao = 0.0, l;
    const float maxDist = 2.;
	const float nbIte = 6.0;
	//const float falloff = 0.9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;
        
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 1386
float calcAO( in vec3 pos, in vec3 nor )
{
    vec4 kk;
	float ao = 0.0;
    for( int i=ZERO; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
        float h = hash1(float(i));
		ap *= sign( dot(ap,nor) ) * h*0.1;
        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );
    }
	ao /= 32.0;
	
    return clamp( ao*6.0, 0.0, 1.0 );
}

// Function 1387
vec3 computeTubeLighting(vec3 posWS, vec3 coneDirWS, float roughness, 
                     vec4 startSphere, vec4 endSphere, vec3 colour,
                     out float visibility)
{
    
    vec3 startToEnd = endSphere.xyz - startSphere.xyz;

    vec3 startToEndDir = normalize(startToEnd);
    //Construct a plane going through the line and perpenticular with coneDirWS
    vec3 planeTangent = normalize(cross(startToEndDir, -coneDirWS));
    vec3 planeNormal = normalize(cross(planeTangent, startToEndDir));
    vec4 plane = vec4(-planeNormal, dot(startSphere.xyz, planeNormal));
    //Intersect the direction with that plane
    float closestPointDistAlongRay = plaIntersect(posWS, coneDirWS, plane);
    vec3 closesPointToTube = posWS + coneDirWS * closestPointDistAlongRay;
    //Project the closest point on the tube to find the progress
    vec3 startToClosest = closesPointToTube - startSphere.xyz;
    
    float closestDirProgress = saturate(dot(startToClosest, startToEnd)/dot(startToEnd, startToEnd));

    //Closest pos on tube to lighting pos
	vec3 startToPos = posWS - startSphere.xyz;
    float closestPointProgress = saturate(dot(startToPos, startToEnd) / dot(startToEnd, startToEnd));
    
    float progress = mix(closestDirProgress, closestPointProgress, roughness*roughness);

    return computeSphereLighting(posWS, coneDirWS, roughness, 
                             mix(startSphere, endSphere, progress), colour, visibility);
}

// Function 1388
vec3 shade(vec3 rd, vec3 p) {
  vec3 normal = normalize(p);
  float ambient_dif = 0.03;
  vec3 dif = vec_tovec3(ambient_dif);
  vec3 sun_dir = vec3(0.0, 0.0, 1.0);
  vec3 sun_col = (vec3(1.0, 0.9, 0.9) * 4.0);
  float sun_dif = clamp(((dot(normal, sun_dir) * 0.9) + 0.1), 0.0, 1.0);
  dif = (dif + (sun_col * sun_dif));
  vec3 mate = (planet_color(p) * 0.4);
  vec3 col = (mate * dif);
  float fres = clamp((1.0 + dot(normal, rd)), 0.0, 1.0);
  float sun_fres = (fres * clamp(dot(rd, sun_dir), 0.0, 1.0));
  col = (col * (1.0 - fres));
  col = (col + ((pow(sun_fres, 8.0) * vec3(0.4, 0.3, 0.1)) * 5.0));
  return col;
}

// Function 1389
float shade_sun(vec3 ro, vec3 rd, vec3 normal, vec3 lightDir)
{
    return max(dot(normal, lightDir), 0.0);
}

// Function 1390
float hardShadow(ray _r, vec3 _light)
{
    ray r = _r;
    r.o = _r.hp;
    r.d = normalize(_light - _r.hp);
    
    float s = 1.;
    float t = 0.02;    
    for(int i=0; i<30; i++)
    {        
        vec3 p = r.o + r.d * t;
        
        float d = map(p).x;
        
        if(d < 0.002)
            return 0.;
        
        t += d;
    }
    
    return 1.;
}

// Function 1391
float softShadow(vec3 ro, vec3 rd, float start, float end, float k){

    float shade = 1.0;
    const int maxIterationsShad = 20;

    float dist = start;
    //float stepDist = end/float(maxIterationsShad);

    // Max shadow iterations - More iterations make nicer shadows, but slow things down.
    for (int i=0; i<maxIterationsShad; i++){
    
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);

        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.
        dist += clamp( h, 0.01, 0.25);//min(h, stepDist);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // Shadow value.
    return min(max(shade, 0.) + 0.5, 1.0); 
}

// Function 1392
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1393
float compAO(vec3 p, vec3 norm)
{
    float cumulDistToMap = 0.0;
    vec3 p_AO = p + norm*0.01;

 	for(int i = 0; i<AO_it; i++)
    {
     	cumulDistToMap +=  (map(p_AO)).d;  
        p_AO += norm*0.01;
    }
    return cumulDistToMap/float(AO_it);
}

// Function 1394
vec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)
{
   vec3 color = vec3(0.0);
   int id = -1;
   i = false;
   //vec3 toLight = (lightf-hit);
   //float sqdist = dot(toLight,toLight);
   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);
   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;
 
   if(diffuse>0.0)
   {
      float ldist =distance(lightf,hit);// sqrt(sqdist);
      float sh = 1000.0;//distance(lightf,hit);
      shadow(hit + normal * 0.0001, L, sh, id, true);           
      if(sh>ldist)
         {color += cl * (diffuse/(ldist))*0.32; i = true;}
   }
   return color;
}

// Function 1395
vec3 SampleLight(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, bool sphericalLightIsTextured)
{
	vec3 V;
    vec3 L;
    float inversePDF_d;
    if (IsQuad(light)) {
        V = QuadLocalToWorld(s*2.0 - vec2(1.0), light) - P;
        L = normalize(V);
		float distSqr = dot(V, V);
        inversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;
    } else {
        // http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html
        vec3 pointToLight = light.pos - P;
		float radiusSqr = light.radius*light.radius;
        float sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);
        float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);
        float cosTheta = cosThetaMax + (1.0 - cosThetaMax)*s.y;
        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
		if (sphericalLightIsTextured) {
			float dc = length(pointToLight);
			float ds = dc*cosTheta - sqrt(max(0.0, radiusSqr - dc*dc*sinTheta*sinTheta));
			float cosAlpha = (radiusSqr + dc*dc - ds*ds)/(2.0*dc*light.radius);
			float sinAlpha = sqrt(max(0.0, 1.0 - cosAlpha*cosAlpha));
			V = light.pos + light.radius*SampleHemisphere(-normalize(pointToLight), sinAlpha, cosAlpha, s.x) - P;
			L = normalize(V);
		} else {
			V = vec3(0);
			L = SampleHemisphere(normalize(pointToLight), sinTheta, cosTheta, s.x);
		}
		inversePDF_d = 2.0*PI*(1.0 - cosThetaMax);
    }
	inversePDF_d *= max(0.0, dot(N, L))/PI;
    if (inversePDF_d > 0.0 && IntersectScene(Ray(P, L), ignoreObjId) == lightId)
		return SampleLightColor(P + V, light)*inversePDF_d;
	else
		return vec3(0);
}

// Function 1396
void initLights() {
    #if (NUM_LIGHTS != 0)
    //lights[0] = light(0., 0.5, normalize(dirLight));
    #endif
}

// Function 1397
vec3 lighting(vec3 n, vec3 rayDir, vec3 pos)
{
    float diff = dot(LIGHT, n);
    float rim = (1.0 - max(0.0, dot(-n, rayDir)));
    float spec = dot(reflect(LIGHT, n), rayDir);
    spec = pow(spec, 30.0);
    
    return smoothstep(vec3(0.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0), vec3(diff, rim, spec)); 
}

// Function 1398
float calcAO( in vec3 pos, in vec3 nor )
{
    vec3 kk;
	float ao = 0.0;
    for( int i=ZERO; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
        ap *= sign( dot(ap,nor) );
        float h = hash1(float(i));
		ap *= h*0.3;
        ao += clamp( mapWithTerrain( pos + nor*0.01 + ap, kk ).x*1.0/h, 0.0, 1.0 );
    }
	ao /= 32.0;
	
    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );
}

// Function 1399
float WallAO (vec3 p)
{
  float ao;
  ao = 1.;
  for (int n = 0; n < nBBall; n ++) {
    ao = SmoothMin (ao, smoothstep (0.1, 2., length (GetRB (n) - p) - (bRad + 0.65)), 0.5);
  }
  for (int iy = 0; iy < nBallEy; iy ++) {
    for (int ix = 0; ix < nBallEx; ix ++) {
      ao = SmoothMin (ao, smoothstep (0.1, 2.5, length (GetR (vec2 (ix, iy)) - p) - 0.5), 0.5);
    }
  }
  return 0.6 + 0.4 * ao;
}

// Function 1400
float calcAO(in vec3 p, in vec3 n)
{
	float ao = 0., l;
    const float maxDist = 2.;
	const float nbIte = 5.;
	//const float falloff = .9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + .0)*.5/nbIte*maxDist;        
        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 1401
vec3 Shade(in vec3 p, in vec3 n, in vec3 ld, in vec2 c) {
    vec3 col = color(c);
	return (col * 0.15 + col * max(0.0, dot(n,ld)) * ShadowFactor(p, ld) * 0.85) * 3.5;
}

// Function 1402
vec3 ShadeSteps(int n)
{
   float t=float(n)/(float(MAX_STEPS-1));
   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);
}

// Function 1403
float RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)
{
    //Variation of DFAO from : https://www.shadertoy.com/view/Xds3zN
    //Interesting reads:
    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?
    //Implementation notes:
    //-Doubling step size at each iteration
    //-Allowing negative distance field values to contribute, making cracks much darker
    //-Not reducing effect with distance (specific to this application)
    float MaxOcclusion = 0.0;
    float TotalOcclusion = 0.0;
    const int nSAMPLES = 4;
    float stepSize = 0.11/float(nSAMPLES);
    for( int i=0; i<nSAMPLES; i++ )
    {
        float t = 0.01 + stepSize;
        //Double distance each iteration (only valid for small sample count, e.g. 4)
        stepSize = stepSize*2.0;
        float dist = DF_composition( o+N*t ).d-isoSurfaceValue;
        //Occlusion factor inferred from the difference between the 
        //distance covered along the ray, and the distance from other surrounding geometry.
        float occlusion = zclamp(t-dist);
        TotalOcclusion += occlusion;//Not reducing contribution on each iteration
        MaxOcclusion += t;
    }
    
    //Here, TotalOcclusion can actually exceed MaxOcclusion, where the rays
    //get inside the shape and grab negative occlusion values. It does look good
    //that way IMHO (much darker in the cracks), therefore the maximum occlusion is bumped
    //25% to allow those cracks to get darker.
    return saturate(1.0-TotalOcclusion/(MaxOcclusion*1.25));
}

// Function 1404
float softshadow(in vec3 ro, in vec3 rd, float mint, float k)
{
	float res = 1.0;
	float t = mint;
	float h = 1.0;
	for (int i = 0; i < 100; i++)
	{
		h = de(ro + rd * t);
		res = min(res, k*h / t);
		t += clamp(h, .005, .1);
	}
	return clamp(res, 0., 1.);
}

// Function 1405
vec3 light(vec3 origin, vec3 rayDir) {

    origin = -origin;
    rayDir = -rayDir;

    origin *= envOrientation;
    rayDir *= envOrientation;

    vec2 uv;
    vec3 pos = vec3(-6);
    float hit = intersectPlane(origin, rayDir, pos, normalize(pos), normalize(vec3(-1,1,0)), uv);
    float l = smoothstep(.75, .0, fBox2(uv, vec2(.5,2)) - 1.);
    l *= smoothstep(6., 0., length(uv));
	return vec3(l) * hit * 2.;
}

// Function 1406
float castShadowRay(vec3 pos, vec3 lightPos, float treshold) {
	vec3 dir = normalize(pos - lightPos);
	float maxDist = length(lightPos - pos);
	vec3 rayPos = lightPos;
	float distAccum = 0.0;
	for (int i = 0; i < MAX_SECONDARY_RAY_STEPS; i++) {
		float dist = distanceField(rayPos);
		rayPos += dist * dir;
		distAccum += dist;
	}
	if (distAccum > maxDist - treshold) return 1.0;
	else return 0.0;
}

// Function 1407
vec3 calcLightOnParticle( vec3 particlePos, Sphere lightSphere, vec3 Li ) {
    vec3 wi;
    return calcDirectLight( particlePos, wi, lightSphere, Li );
}

// Function 1408
vec3 pointLighting(in Trace trace, PointLight light){
    vec3 lightDir = light.position - trace.p;
	float d = length(lightDir);
  	lightDir = normalize(lightDir);
   
  	vec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);

    color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);

    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);
    float shadow = castShadow(Ray(trace.p,lightDir),d);
    color *= attenuation*shadow;
    return  color;
}

// Function 1409
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mat )
{
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    vec3  lig = normalize(vec3(0.7,0.875,0.89));		// dir
    float dif = max(dot(nor,lig),0.0);
    float sha = 0.0;
    if( dif>0.01 )
        sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(1.00,1.00,1.00)*sha;
    float spec = pow(dif, 160.0) *mat.a;
    
    // ambient light
    //-----------------------------
    lin += vec3(0.50,0.50,0.50);
    
    // surface-light interacion
    //-----------------------------
    vec3 col = mat.xyz*lin;
    col+=spec;
    
    // fog    
    //-----------------------------
    col *= exp(-0.0001*dis*dis);
    return col;
}

// Function 1410
float light(vec3 p, vec3 l) {
    vec3 lvec = normalize(l-p);
    if (length(rayMarch(p+0.1 * lvec, lvec)-p) < length(l-p)) { return 0.; }
    vec2 helper = vec2(1e-5,0);
    float d = sceneSDE(p);
    vec3 norm = normalize(vec3(
        sceneSDE(p + helper.xyy) - d,
        sceneSDE(p + helper.yxy) - d,
        sceneSDE(p + helper.yyx) - d
        ));
   return dot(norm, lvec);
}

// Function 1411
vec3 shade(in vec3 p, in vec3 rd, in vec3 lpos, in float d)
{
	vec3 n = normal(p);
    vec3 col = vec3(1);
    if (matid < 0.)
    {
       	col = sin(vec3(1,2,3.)+matid*.002)*0.3+0.4;
        n = bump(maptex(p*0.5),n,d);
    }
    else
    {
        n = bump(maptex2(p*0.25),n,d);
    }
    
    vec3 r = reflect(rd,n);
    vec3 ligt = normalize(lpos-p);
    float atn = distance(lpos,p);
    float refl = pow(dot(rd, r)*.75+0.75,2.);
    float dif = clamp(dot(n, ligt),0.,1.);
    float bac = clamp(dot(n, vec3(-ligt)),0.,1.);
    col = col*bac*0.2 + col*dif*.3 + bg(r)*dif*refl*0.2;
    col *= clamp((1.-exp(atn*.15-5.)),0.,1.);
	
	return col;
}

// Function 1412
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 14; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = .002;    
    float end = max(length(rd), .001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), 
        // clamp(h, .02, stepDist*2.), etc.
        dist += clamp(h, .02, .25);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0. || dist>end) break; 
        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me.
    return min(max(shade, 0.) + .25, 1.); 
}

// Function 1413
vec4 simpleLight(vec3 pos, vec3 norm, LineLight light)
{
    //line 
    vec3 lineVec = light.stop - light.start;
    float lineLength = length(lineVec); 
    vec3 lineDir = lineVec / lineLength;
    
    // Project pos on line
    float proj_t = clamp(dot(lineDir, pos-light.start) / lineLength, 0.0, 1.0);
    vec3 posInLine = lineVec * proj_t + light.start;
    
    // light vector
    vec3 lightVec = posInLine - pos;
    float lightDist = length(lightVec);

    // Get Final Distances for attenuation calculation
    float diffuse = dot(norm, lightVec) / lightDist / lightDist / lightDist;
    
    return light.color * diffuse; 
}

// Function 1414
vec3 shade(vec3 lightPos, vec3 Kd, vec3 P, vec3 N)
{
    vec3 L = normalize(lightPos - P);
    vec3 R = reflect(-L, N);
    vec3 V = normalize(vec3(iResolution.x*0.5, iResolution.y*0.5, CAMERA_HEIGHT) - P);

    vec3 I = vec3(0.0);

    vec3 Id = Kd * max(dot(N, L), 0.0);
    I = I + Id * DIFFUSE_INTENSITY;

    vec3 Is = vec3(pow(max(dot(R,V),0.0), SPECULAR_EXPONENT));
    I = I + Is;

    float fr = fresnel(V, N, 0.2);
    
    #ifdef HAS_REFLECTION
    	vec3 Ir = fr * texture(iChannel0, reflect(-V, N)).rgb;
    	I = I + Ir;
    #endif
    
    #ifdef HAS_REFRACTION
    	vec3 It = (1.0-fr) * texture(iChannel0, refract(-V, N, 0.8)).rgb;
    	I = I + It;
    #endif

    return I;
    //return vec3(fr);
}

// Function 1415
float RSpecularLight(vec3 normalRay, vec3 normal, float gGgxAlpha, out float o_rDiffuse)
{
	float gGgxAlphaSqr = GSqr(gGgxAlpha);

	vec3 normalHalf = normalize(g_normalLight - normalRay);
	float gDotHalf = saturate(dot(normalHalf, normal));

	float uFresnel = UFresnel(gDotHalf);

	float rSpecular = mix(g_rSpecular, 1.0, uFresnel);

	float gNdf = gGgxAlphaSqr / GSqr(GSqr(gDotHalf) * (gGgxAlphaSqr - 1.0) + 1.0);
	float gVis = 1.0 / (GGgxVisRcp(gGgxAlphaSqr, dot(-normalRay, normal)) *
						GGgxVisRcp(gGgxAlphaSqr, dot(g_normalLight, normal)));

	o_rDiffuse = 1.0 - rSpecular;

#if ENABLE_IS
	return 0.0;
#else
	return gNdf * gVis * rSpecular * g_rSunSpecScale;
#endif
}

// Function 1416
float shadowtrace(vec3 p, vec3 d, float lmax) {
    float v = .02;
    // Take a few samples between the point and the light position and chech
    // whether they are "inside" geometry
    for (int i = 1; i < 9; ++i) {
        v = min(v, world(p+d*lmax*float(i)/12.));
    }
    return smoothstep(.0, .02, v);
    
}

// Function 1417
vec3 scene_lighting_terrain( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,
                             vec3 sky, vec2 shadow )
{
#if WITH_ILLUM_TEST
    float mu0 = max( 0., dot( N, L ) );
    return F * mu0 + sky;
#else
    float mu_0 = mu_stretch( dot( N, L ), .01 );
    float mu = mu_stretch( dot( N, V ), .01 );
    float cosi = dot( N, Z );
    float cosp = dot( L, V );
    vec3 kd = lunar_lambert( albedo, mu, mu_0 );
    float kl = phase_curve( cosp );
    float kj = cosi * .5 + .5;
    vec3 E = F * mu_0 * shadow.x;
    vec3 backbounce = .5 * albedo * F * shadow.y * mu_stretch( dot( N, -L ), .125 )
        * mu_stretch( dot( L, Z ), .005 );
    return E * kd * kl + albedo * ( sky * kj + backbounce );
#endif
}

// Function 1418
float soft_shadow( vec3 ro, 
                   vec3 rd, 
                   float mint, 
                   float maxt, 
                   float k )
{
    float shadow = 1.0;
    float t = mint;

    for( int i=0; i < SOFTSHADOW_STEPS; i++ )
    {
        if( t < maxt )
        {
            float h = scenedf( ro + rd * t );
            shadow = min( shadow, k * h / t );
            t += SOFTSHADOW_STEPSIZE;
        }
    }
    return clamp( shadow, 0.0, 1.0 );

}

// Function 1419
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    for( int i=0; i<8; i++ )
    {
        float h = 0.01 + 0.5*float(i)/7.0;
        occ += (h-shape( pos + h*nor ));
    }
    return clamp( 1.0 - 4.0*occ/8.0, 0.0, 1.0 );    
}

// Function 1420
Intersection intersectLight(in Ray ray, in Light light)
{
    Quadric quadric;
    quadric.p = light.p;
    quadric.r = vec3(light.r);
    
    return intersectQuadric(ray, quadric);
}

// Function 1421
vec3 GetMissileLightning(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, Missile missile)
{       
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  vec3 reflectDir = reflect( rayDir, normal );
  specLevel= 3.5*pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0/3.);

  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );
  fre = mix( .03, 1.0, fre );   
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );

  float shadow = SoftShadowMissile(origin+((rayDir*rayHit.depth)*0.998), sunPos, missile);
  dif*=shadow;
  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );

  vec3 lightTot = (vec3(0.7)*amb); 
  lightTot+=vec3(0.85)*dif;
  lightTot += 1.00*specLevel*dif;
  lightTot += 0.80*skyLight*vec3(0.40, 0.60, 1.00);
  lightTot= mix(lightTot*.7, lightTot*1.2, fre );

  return lightTot*sunColor;
}

// Function 1422
vec3 sfShadeSkyShirley(Ray r)
{
	float t = 0.5 * (r.direction.y + 1.0);
	return (1.0 - t) * ArneWhite + t * ArneSkyBlue;
}

// Function 1423
vec3 ShadeBoat( vec3 pos, vec3 ray )
{
	pos -= boatPosition;
	vec3 norm = normalize(pos);
	pos = WorldToBoat(pos);
	
	vec3 lightDir = normalize(vec3(-2,3,1));
	float ndotl = dot(norm,lightDir);
	
	// allow some light bleed, as if it's subsurface scattering through plastic
	vec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);

	// anti-alias the albedo
	float aa = 4.0/iResolution.x;
	
	//vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);
	vec3 albedo = vec3(1,.01,0);
	albedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );
	albedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );
	albedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );
	albedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );
	
	vec3 col = albedo*light;
    
	// specular
	vec3 h = normalize(lightDir-ray);
	float s = pow(max(0.0,dot(norm,h)),100.0)*100.0/32.0;
	
	vec3 specular = s*vec3(1,1,1);

	vec3 rr = reflect(ray,norm);
	specular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );
	
	float ndotr = dot(norm,ray);
	float fresnel = pow(1.0-abs(ndotr),5.0);
	fresnel = mix( .001, 1.0, fresnel );

    col = mix( col, texture(iChannel1, rr).xyz, fresnel );
	col = mix( col, specular, fresnel );
	
	return col;
}

// Function 1424
vec3 getLightPos(float t)
{
	t+=20.;
    vec3 p = vec3(30.0*sin(t*1.3+5.),
                  30.0*sin(t*.5),
                  30.0*sin(t*1.4));
    return p;
}

// Function 1425
vec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {
	vec3 sunDir = normalize(vec3(10, 10, -10) - p),
	     n = calcNormal(p, d);

	// Primary light.
	float primary = max(0., dot(sunDir, n)),
	      bounce = max(0., dot(-sunDir, n)) * .2,
	      spe = pow(max(0., dot(rd, reflect(sunDir, n))), data.specPower) * 2.,
	      fre = smoothstep(.7, 1., 1. + dot(rd, n)),
	      fog = exp(-length(p) * .05);

	// Combine.
	primary *= mix(.2, 1., calcShadow(p, vec3(10, 10, -10)));
	return mix(data.mat * ((primary + bounce) * ao(p, n, .33) + spe) * vec3(2, 1.6, 1.7), vec3(.01), fre) * fog;
}

// Function 1426
vec4 shadePlane(Ray ray, RaycastHit hit) {
 
    float diffuse = lighting(hit);
    vec2 uv = mod(hit.point.xz / 3., vec2(1.));
    
    vec3 rd = reflect(ray.dir, hit.normal);
    Ray rr = Ray(hit.point + (rd * .001), rd);
    RaycastHit rh = intersectScene(rr);
    
    vec4 tex = texture(iChannel1, uv);
    
    vec4 rc = rh.id == 0 ? shadeSphere(rr, rh) : texture(iChannel0, rd);
    vec4 col = tex * diffuse;
    //return col;
    float tf = (tex.x + tex.y + tex.z) / 3.;
    return mix(col, rc, tf);
    
}

// Function 1427
void Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)
{    
    vec3 vPos = surface.vPos;
	vec3 vToLight = vLightPos - vPos;	
    
	vec3 vLightDir = normalize(vToLight);
	float fDistance2 = dot(vToLight, vToLight);
	float fAttenuation = 100.0 / (fDistance2);
	
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);
}

// Function 1428
function SetShaderConstant2F(u,x){m.uniform2fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}

// Function 1429
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1. );    
}

// Function 1430
vec3 sampleLight( const in vec3 ro, inout float seed ) {
    vec3 n = randomSphereDirection( seed ) * lightSphere.w;
    return lightSphere.xyz + n;
}

// Function 1431
vec3 skylight(vec3 dir, vec3 sun_dir) {
    float sun_cos = dotplus(dir, -sun_dir);
    if (sun_cos > 0.99999) {
        return sun_color;
    } else {
        float rayleigh_phase = (1.+sun_cos*sun_cos)/2.;
        float hg_phase = pow((1.-g)*(1.-g) / (1. - 2.*g*sun_cos + g*g), 1.5);
        return mix(sky_base, sun_color, scat_frac * rayleigh_phase * hg_phase);
    }
}

// Function 1432
float shadow(in vec3 p){
    p += .00001*starLight;
    if(shadTrace(p,starLight)) return .1;
    if(shadTraceBis(p,starLight)) return .1;
    return 1.;
}

// Function 1433
void get_cam_and_light(
    in float time,
    out vec3 camera_pos, out vec3 camera_look_at, out vec3 camera_up,
    out float fovy_deg, out vec3 light_pos)
{
    camera_pos = pos_clelies(time, ORBIT_RADIUS);
    camera_look_at = vec3(0.0);
    camera_up = vec3(0.0, 1.0, 0.0);
    fovy_deg = FOVY_DEG;
    light_pos = camera_pos;
}

// Function 1434
float calcSoftShadowBk( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<16; i++ )
    {
        float h = mapBk(ro + rd*t );
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 10.0, 100.0 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1435
float AO(vec2 p, float dist, float radius, float intensity)
{
	float a = clamp(dist / radius, 0.0, 1.0) - 1.0;
	return 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);
	return smoothstep(0.0, 1.0, dist / radius);
}

// Function 1436
float GetShadow(vec3 distances)
{
    distances = clamp((distances+0.5)*5.0,0.0,1.0);
    float shadowAtten = distances.r * 0.33 + distances.g * 0.33 + distances.b * 0.33;
    
    return shadowAtten;
}

// Function 1437
void lightLogic() {

    vec2 uv = iMouse.xy - iResolution.xy / 2.;
    uv /= iResolution.y;
    
    if(iMouse.z > 0.) {

        Ray ray;
        ray.origin = vec3(0.,.35,-3.);
        ray.direction = normalize(vec3(uv.x,uv.y-.3,1.));
        
        RaycastHit scene = raycastScene(ray);
        
        if(scene.type > -1) {
         
            light1 = scene.point;
            return;
            
        }
        
    }
     
    light1 = vec3(-5., 5., -6.);
    
}

// Function 1438
vec4 GetLight(vec3 p) { //This is probably the most important part about Cel shading
    vec3 lightPos[3];
    lightPos[0] = vec3(5, 6, 0);
    lightPos[1] = vec3(-2, 7, 1);
    lightPos[2] = vec3(-4, 10, 10);
    
    vec3 lightCol[3];
    lightCol[0] = vec3(0.3, 0.2, 0.05);
    lightCol[1] = vec3(0.4, 0.2, 0.2);
    lightCol[2] = vec3(0.1, 0.1, 0.2);
    
    vec4 col = vec4(0.0);
    
    for(int i; i<3; i++) {
        vec3 l = normalize(lightPos[i]-p);
        vec3 n = GetNormal(p);
        
        float dif = clamp(dot(n, l), 0.0, 1.0);
        float d = RayMarch(p+n*SURF_DIST*2.0, l);
        if(d<length(lightPos[i]-p)) dif *= 0.1;
        
        col += floor(dif+0.5)*vec4(lightCol[i], 1.0); //This rounds the lighting value, so it really looks flat.
    }
    
    return col;
}

// Function 1439
float getLightInterp(samplerCube cubeSampler, vec3 lmn) {
    vec3 flmn = floor(lmn);

    float d000 = LIGHT( flmn );
    float d001 = LIGHT( flmn + vec3(0.0, 0.0, 1.0) );
    float d010 = LIGHT( flmn + vec3(0.0, 1.0, 0.0) );
    float d011 = LIGHT( flmn + vec3(0.0, 1.0, 1.0) );
    float d100 = LIGHT( flmn + vec3(1.0, 0.0, 0.0) );
    float d101 = LIGHT( flmn + vec3(1.0, 0.0, 1.0) );
    float d110 = LIGHT( flmn + vec3(1.0, 1.0, 0.0) );
    float d111 = LIGHT( flmn + vec3(1.0, 1.0, 1.0) );

    vec3 t = lmn - flmn;
    return mix(
        mix(mix(d000, d100, t.x), mix(d010, d110, t.x), t.y),
        mix(mix(d001, d101, t.x), mix(d011, d111, t.x), t.y),
        t.z
    );
}

// Function 1440
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<32; i++ )
    {
        h = map(ro + rd*t).x;
        res = min( res, k*h/t );
		t += clamp( h, 0.02, 2.0 );
        if( res<0.0001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1441
void DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)
{
	float h = dot(sunLight,normal);
	mat = mat * sunColour*(max(h, 0.0)+.2);
}

// Function 1442
vec3 shade_pixel(vec3 point_of_intersection, vec3 n_direction, vec2 uv)
{
    vec3 linear_color = to_linear_space(texture(iChannel2, uv * albedo_texture_scale).rgb);
    
    // This needs to be read from a mipmapped texture:
    vec3 indirect_light_color = to_linear_space(textureLod(iChannel0, uv * albedo_texture_scale, 7.0).rgb);
    
    // TODO: Attenuate lighting?
    vec3 sample_to_light = light_position - point_of_intersection;
    float sample_to_light_length = length(sample_to_light);
    vec3 n_sample_to_light = sample_to_light / sample_to_light_length;
    //n_sample_to_light = -normalize(point_of_intersection - 0.5 * vec3(sin(iTime), 0.5, cos(iTime)));	// Directional light
    
    vec3 n_normal = calculate_normal(uv, 1.5, 0.002);
    float shadows = compute_shadows(point_of_intersection, n_sample_to_light, light_position);
    float ao = compute_ao(point_of_intersection, n_normal);
      
    float distance_attenuation = 1.0 / (sample_to_light_length * sample_to_light_length);
    float lambert_term = max(0.0, dot(n_normal, n_sample_to_light));
    vec3 diffuse_light = light_color * lambert_term;
    diffuse_light *= distance_attenuation;
    
    vec3 diffuse = linear_color * shadows * diffuse_light;
    vec3 indirect = linear_color * ao * indirect_light_color * (0.75 + 0.25 * lambert_term * shadows);
    
    // Apply wetness-based reflections: ///////////////////////////////////////////
    
    // Calculate a smoother normal because the surface is coated in water:
    vec3 n_normal_smooth = calculate_normal(uv, 2.0, 0.0);
    
    // Make rocks close to the water wet:
    float height_wetness = smoothstep(0.1, 0.0, point_of_intersection.y);
    float height_wetness_diffuse = smoothstep(0.03, 0.08, point_of_intersection.y);

    // Make rocks sticking out more wet:
    float depth_wetness = smoothstep(0.9, 0.7, get_distance(uv));

    float wetness_mask = (depth_wetness * 0.5 + 0.5) * pow(1.0 - mix(0.0, depth_wetness, 1.0 - height_wetness), 3.0) * height_wetness;
    
    // Reflection ray pointing downwards means it's gonna hit the water surface. 
    vec3 n_reflection_vector = reflect(n_direction, n_normal_smooth);
    float blend_factor = smoothstep(0.0, -0.2, n_reflection_vector.y);
    
    // Change specular to fog color if under water:
    float height_blend_factor = smoothstep(-0.05, 0.05, point_of_intersection.y);
    blend_factor *= height_blend_factor;
 
    float fresnel = get_fresnel_term(n_normal_smooth, -n_direction);
    vec3 specular = get_specular(point_of_intersection, n_normal_smooth, n_direction);
    specular = mix(fog_water_color * 0.25, specular * light_color * 0.25, blend_factor);
    specular *= fresnel * wetness_mask;
    
    float diffuse_darkening = (1.0 - height_wetness) * pow(1.0 - mix(0.0, depth_wetness * depth_wetness, 1.0 - height_wetness_diffuse), 5.0);
    diffuse *= diffuse_darkening * 0.9 + 0.1;	// Darken diffuse cuz it's wet.
    indirect *= (diffuse_darkening * 0.25 + 0.75);
    /////////////////////////////////////////////////////////////////////////
    
    vec3 shaded_color = diffuse + indirect + specular; 
    
    
#ifdef DEMO_MODE
    float slice_width = iResolution.x / 5.0;
    float coordinate = gl_FragCoord.x - gl_FragCoord.y * 0.1 + slice_width / 5.0;
    if(coordinate < slice_width)
    {
    	return(vec3(diffuse_light * shadows));
    }
    
    //if(coordinate < slice_width * 2.0 + sin(iTime) * iResolution.x)	// Animated
    if(coordinate < slice_width * 2.0)
    {
    	return(vec3(ao));
    }
    
    //if(coordinate < slice_width * 3.0 + sin(iTime + pi) * iResolution.x)	// Animated
    if(coordinate < slice_width * 3.0)
    {
    	return(n_normal);
    }
    
    if(coordinate < slice_width * 4.0)
    {
    	return(linear_color);
    }
    
    return(indirect_light_color);
#endif
    
#ifdef DEBUG_NORMALS
    {
        float slice_width = iResolution.x / 5.0;
        float coordinate = gl_FragCoord.x - gl_FragCoord.y * 0.1 + slice_width * 0.5;
        if(coordinate < slice_width)
        {
            return(vec3(n_normal.x, 0.0, 0.0));
        }

        if(coordinate < slice_width * 2.0)
        {
            return(vec3(0.0, n_normal.y, 0.0));
        }

        if(coordinate < slice_width * 3.0)
        {
            return(vec3(0.0, 0.0, n_normal.z));
        }

        if(coordinate < slice_width * 4.0)
        {
            return(n_normal);
        }
        
    	return(normalize(cubemap_origin - point_of_intersection));	// Guaranteed to be correct normals!
    }
#endif
    
    return(shaded_color);
}

// Function 1443
float ao(vec3 p)
{
    float illum = 0.0;
    
    float th = 0.0;
    float dth = float(NUM_RAY_AO) *0.1591549430; // 1 / (2pi)
    
    for(int i = 0; i<NUM_RAY_AO; i++)
    {
        illum += aoray(p, vec3(cos(th), 0.0, sin(th)));
        th += dth;
    }                        
    
    return illum / float(NUM_RAY_AO)*2.0-1.0;
}

// Function 1444
float calcAO(in vec3 pos, in vec3 nor)
{
	float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<6; i++)
    {
        float hr = 0.01 + 0.17*float(i)/9.0;
        vec3 aopos =  nor*hr + pos;
        float dd = map(aopos, false).x;
        occ+= -(dd - hr)*sca;
        sca*= 0.81;
    }
    occ = 2.*smoothstep(0.06, 0.5, occ);
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1445
float fetch_lightmap_texel(ivec2 addr)
{
    addr = clamp(addr, ivec2(0), ivec2(LIGHTMAP_SIZE) - 1);
    int channel = addr.y & 3;
    addr.y >>= 2;
    return decode_lightmap_sample(texelFetch(iChannel1, addr, 0)).values[channel];
}

// Function 1446
float calcAO(in vec3 p, in vec3 n)
{
	float ao = 0.0, l;
    const float maxDist = 4.;
	const float nbIte = 5.;
	//const float falloff = .9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + .0)*.5/nbIte*maxDist;        
        ao += (l - map( p + n*l )); // / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 1447
bool isLightVisible(in vec3 ro, in int id)
{
	float dist = length(ld[id].pos - ro);
	vec3 rd = normalize(ld[id].pos - ro);
	float tmin;
	vec3 nor;
	int oid = iScene(ro, rd, tmin, nor);
	if (oid == -1 || tmin > dist)
	{
		return true;
	}
	else
	{
		return false;
	}
}

// Function 1448
float shadowEnv (in vec3 rp, in vec3 g, in vec3 ld)
{
	rp += g * 0.03;
    const int stps = 10;

    float s = 1.0;
    float occ = 0.0;
    for (int i = 1; i < stps; ++i)
    {
        float stp = .015 * float(i * i);
	    rp += ld * stp;
        float d = mapEnv(rp);
        occ += clamp(d/stp, .0, 1.0) * (1./float(i));
        s = min(s, clamp(mapEnv(rp) / stp, 0.0, 1.0));
    }
    occ /= 2.0;
    
    s = smoothstep(0.0, g_shadowSharpness, s);
    s = min(s, occ);
	return min(s, 1.);
}

// Function 1449
float calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )
{
	float res = 1.0;
    float t = tmin;
    for( int i=0; i<50; i++ )
    {
		vec2 h = map( ro + rd*t );
        res = min( res, k*h.x/t );
        t += clamp( h.x, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1450
float softshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    for( float t=0.02; t < 2.; )
    {
        float h = map(ro + rd*t).x;
        if( h<0.001 ) return 0.0;
        res = min( res, 8.0*h/t );
        t += h;
    }
    return res;
}

// Function 1451
float pointLight( vec3 point, vec4 light ) {
    vec3 normal = sceneNormal( point );
    
    vec3 towardLight = light.xyz - point;
    float toLight = length( towardLight );
    towardLight = normalize( light.xyz - point );

    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );
    
    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;
    float d = rayMarch( lightStart, towardLight ).x;
    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );

    float lightStrength = .2 + .8 * light.w / dot( toLight, toLight );  
    return diffuse * lightStrength;
}

// Function 1452
vec2 sampleLight(vec3 rp, vec3 n)
{
    vec2 energy = vec2(0);
    vec3 lightdir = normalize(normalize(vec3(.2, 4., 1.)) +
                              (vec3(rand(), rand(), rand()) * 2. - 1.) * .015);
    vec3 n2, uvw;
    float t = traceScene(rp, lightdir, n2, uvw).x;

    vec3 lrp = rp + lightdir * t;

    // Directional 'sky' lighting.
    if((lrp.y > .999 && abs(lrp.x- -.3) < .6 && abs(lrp.z - .1) < .8))
        energy += vec2(1.5, .8).yx * max(0., dot(n, lightdir)) * 2.;

    vec3 lo = vec3(.7, .8, .1), ls = vec3(1, 0, 0) * .2, lt = vec3(0, 0, 1) * .2;
    vec3 ln = normalize(cross(ls, lt));
    
    int light_sample_count = 2;
    
    // Parallelogram local lightsource.
    for(int j = 0; j < light_sample_count; ++j)
    {
        float lu = rand() * 2. - 1., lv = rand() * 2. - 1.;
        vec3 lp = lo + ls * lu + lt * lv, n2;
        float ld = dot(normalize(lp - rp), n), ld2 = dot(normalize(rp - lp), ln);
        if(ld > 0. && ld2 > 0. && traceSceneShadow(rp + n * 1e-4, lp - rp))
            energy += vec2(1.5, .5) *
            	(1. / dot(rp - lp, rp - lp) * ld * ld2) / float(light_sample_count);
    }

    return energy;
}

// Function 1453
float Shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
	float t = .01;
	
	for (int i = 0; i < 6; i++) 
	{
        float d = Map(ro + rd * t).x;
        res = min(res, 0.1 * d / t);

        t += .05;
    }

    return clamp(res*1.7,.1, 1.0);
}

// Function 1454
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )
{
    vec3 lin = vec3(0.0);

    vec3  lig = normalize(vec3(1.0,0.7,0.9));
	float cos_Ol = max(0.0, dot(nor, lig));
    vec3 h = normalize(lig - rd);
    float cos_Oh = max(0.0,dot(nor, h));
    float dif = cos_Ol;
    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );
    lin += dif*vec3(0.8, 0.7, 0.6)*sha;
    
    lin += vec3(0.20,0.30,0.30);

    
    vec3 col = mal.rgb*lin;

    // specular
    col += cos_Ol * pow(cos_Oh,40.0);
    
    // envmap
    col += mal.w*texture(iChannel0, reflect(rd,nor).xy).xyz;
    
    // fog    
    //-----------------------------
	col *= exp(-0.01*dis*dis);

    return col;
}

// Function 1455
vec4 lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos)
{
    vec3 light = vec3(0.0, 0.0, 2.0 + iTime * speed);
    vec3 lightVec = light - pos;
	vec3 lightDir = normalize(lightVec);
    float atten = clamp(1.0 - length(lightVec)*0.1, 0.0, 1.0);
    float spec = pow(max(0.0, dot(reflectDir, lightDir)), 10.0);
    float rim = (1.0 - max(0.0, dot(-n, rayDir)));

    return vec4(spec*atten*lightColor2 + rim*0.2, rim); 
}

// Function 1456
vec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {

	float alpha = roughness*roughness;
	vec3 L = normalize(light.pos.xyz - position);
	vec3 H = normalize (V + L);

	float dotNL = clamp (dot (N, L), 0.0, 1.0);
	float dotNV = clamp (dot (N, V), 0.0, 1.0);
	float dotNH = clamp (dot (N, H), 0.0, 1.0);
	float dotLH = clamp (dot (L, H), 0.0, 1.0);

	float D, vis;
	vec3 F;

	// NDF : GGX
	float alphaSqr = alpha*alpha;
	float pi = 3.1415926535;
	float denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;
	D = alphaSqr / (pi * denom * denom);

	// Fresnel (Schlick)
	float dotLH5 = pow (1.0 - dotLH, 5.0);
	F = F0 + (1.0 - F0)*(dotLH5);

	// Visibility term (G) : Smith with Schlick's approximation
	float k = alpha / 2.0;
	vis = G1V (dotNL, k) * G1V (dotNV, k);

	vec3 specular = /*dotNL **/ D * F * vis;

	vec3 ambient = vec3(.01);

	float invPi = 0.31830988618;
	vec3 diffuse = (albedo * invPi);


	return ambient + (diffuse + specular) * light.color.xyz * dotNL ;
}

// Function 1457
float GetLightVisiblity(in vec3 rayOrigin, in vec3 rayDirection, in float maxT, in int maxSteps, in float marchSize)
{
    float t = 0.0f;
    float lightVisibility = 1.0f;
    float signedDistance = 0.0;
    for(int i = 0; i < maxSteps; i++)
    {                       
        t += max(marchSize, signedDistance);
        if(t > maxT || lightVisibility < ABSORPTION_CUTOFF) break;

        vec3 position = rayOrigin + t*rayDirection;

        signedDistance = QueryVolumetricDistanceField(position);
        if(signedDistance < 0.0)
        {
            lightVisibility *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);
        }
    }
    return lightVisibility;
}

// Function 1458
vec3 ShadeSteps(int n)
{
   float t=float(n)/(float(Steps-1));
   return vec3(t,0.25+0.75*t,0.5-0.5*t);
}

// Function 1459
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map2( aopos ).d;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1460
float calcAO( in vec3 pos, in vec3 nor )
{
    int mat;
    float occ = 0.0;
    float sca = 1.0, dd;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.09*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        dd = map( aopos, mat );
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    float res = clamp( 1.0 - 1.6*occ, 0.0, 1.0 );
    return res;    
}

// Function 1461
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
	float h = 1.0;
    for( int i=0; i<32; i++ ) {
        h = 0.15*mapTerrain(ro + rd*t);
        res = min( res, k*h/t );
		t += clamp( h, 0.02, 2.0 );
		
		if( h<0.0001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1462
float calcShadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    
    float t = 0.01;
    for( int i=0; i<128; i++ )
    {
        vec3 pos = ro + t*rd;
        float h = map( pos ).x;
        res = min( res, k*max(h,0.0)/t );
        if( res<0.0001 ) break;
        t += clamp(h,0.01,0.5);
    }

    return res;
}

// Function 1463
vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh, vec3 ori) {
	vec3 ds = vec3(0.);
    vec3 ss = vec3(0.);
    float d = max(dot(LIGHT_DIR,n),0.);
    float s = 0.;
    d *= softshadow(p,LIGHT_DIR,SHADOW_BIAS,MAX_DISTANCE,64.);
    if(d > 0. && sh > 0.)
        s = pow(max(dot(LIGHT_DIR,r),0.),sh);
    ds += LIGHT_COL * d;
    ss += LIGHT_COL * s;
    vec3 plv = ori-p;
    vec3 pld = normalize(plv);
    d = max(dot(pld,n),0.);
    s = 0.;
    d *= softshadow(p,pld,SHADOW_BIAS,length(plv),64.);
    if(d > 0. && sh > 0.)
        s = pow(max(dot(pld,r),0.),sh);
    float a = 1.-clamp(length(plv)/3500.,0.,1.);
    ds += vec3(d*a);
    ss += vec3(s*a);
    return (col*(LIGHT_AMB+ds))+ss;
}

// Function 1464
vec3 calcLighting(vec3 n, float s, Hit scn) {
 
    float d = max(dot(LIGHT_DIR,n), 0.);
	d *= s;
    
    return LIGHT_COL * d;
    
}

// Function 1465
bool IsLightSource(in Material m)
{
    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;
}

// Function 1466
vec3 volumetricLight(vec3 p, vec3 ro, vec3 rd, vec2 uv)
{
#ifdef VOLUMETRIC_ACTIVE
    vec3 col = vec3(0.0);
    float val = 0.0;
    
   	p -= rd * noise(9090.0*uv) * 0.6;
    vec3 s = -rd * 2.2 / float(VOLUMETRIC_STEPS);
    
    for (int i = 0; i < VOLUMETRIC_STEPS; i++)
    {
        float v = getVisibility(p, light_pos, 250.0) * .015;
        p += s;
        float t = exp(p.z - 3.0);
        val += v * t;
    }  
    
    return vec3(min(val, .8));
#else
    return vec3(0.0);
#endif
}

// Function 1467
float GetLight(vec3 p, vec3 lightPos) {
    vec3 l = normalize(lightPos-p);
    vec3 n = GetNormal(p);
    
    float dif = clamp(dot(n, l), 0., 1.);
    float d = RayMarch(p+n*SUR_ACC*2., l);
    if(d<length(lightPos-p)) dif *= .1;
    
    return dif;
}

// Function 1468
vec3 drawlights( Ray ray )
{   
    vec3 delta = g_light.pos - ray.pos;
    vec3 closest = ray.pos + ray.dir*dot(delta, ray.dir);
    float len = length(g_light.pos-closest);

    vec3 colour = 0.5*g_light.colour/(len*300.0);
    return colour;
}

// Function 1469
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<50; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 20.*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1470
vec3 shadow(Ray r, float len) {
    for(int i = 0; i < 4; ++i) if(intersect(r, spheres[i]).t < len) return vec3(0);
    return lcolor;
}

// Function 1471
float calculateAO(in vec3 pos, in vec3 nor)
{
	float sca = 2.0, occ = 0.0;
    for( int i=0; i<5; i++ ){
    
        float hr = 0.01 + float(i)*0.5/4.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 1472
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 32; 
    
    ro += n*.0015;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), .0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .05, .5); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 1473
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = VAR_ZERO; j < 24; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05 || d > dstFar) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1474
Radiance3 shade(Surfel surfel, Vector3 w_i, Vector3 w_o, Biradiance3 B_i) {
	Vector3 n   = surfel.normal;
    
    float cos_i = dot(n, w_i);
    if (cos_i < 0.0) {
        // Backface, don't bother shading or shadow casting
        return Radiance3(0.0);
    }
    
    // Cast a shadow ray
    Ray shadowRay = Ray(surfel.position + (surfel.normal + w_o) * 0.003, w_i);
    float shadowDist, ignore;
    // Find the outer bounding sphere on the atmosphere and trace shadows up to it
    intersectSphere(planetCenter, planetMaxRadius, shadowRay, shadowDist, ignore);
    if (shadowed(shadowRay, 0.0, shadowDist)) {
        return Radiance3(0.0);
    }
    
	Color3 p_L, p_G;
	float glossyExponent;
	computeReflectivities(surfel.material, p_L, p_G, glossyExponent);

	// Compute the light contribution from the directional source
	Vector3 w_h = normalize(w_i + w_o);
	return cos_i * B_i * 
		// Lambertian
		(p_L * (1.0 / pi) + 

		// Glossy
        pow(max(0.0, dot(n, w_h)), glossyExponent) * p_G * (glossyExponent + 8.0) / (14.0 * pi));
}

// Function 1475
float traceAO(in vec3 ro, in vec3 rd)
{
    float a = 0., t = 0.01;
    for (int i=0; i<5; ++i)
    {
        float d = DE(ro+t*rd);
       	a += d / t;
        t += abs(d);
    }
    return clamp(a / 8., 0., 1.);
}

// Function 1476
float calcShadow( vec3 samplePos, vec3 lightDir, SpotLight light)
{	
	float dist, originDist;
	float result = 1.0;
	float lightDist = length(light.position-samplePos);
	
	vec3 pos = samplePos+(lightDir*(EPSILON+FEATURE_BUMP_FACTOR));
	
	for(int i = 0; i < MAX_SHADOW_STEPS; i++)
	{
		dist = getDist(pos);
		pos+=lightDir*dist;
		originDist = length(pos-samplePos);
		if(dist < EPSILON)
		{
			return 0.0;
		}
		if(originDist >= lightDist || originDist >= MAX_DEPTH)
		{
			return result;
		}
		if( originDist < lightDist )
		{
			result = min( result, lightDist*light.penumbraFactor*dist / originDist );
		}
	}
	return result;
}

// Function 1477
float ExObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ExObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.7 + 0.3 * sh;
}

// Function 1478
float shadow(vec3 eye, vec3 dir) {
    float res = 1.0;
    float depth = 0.0;
    float ph = 1e10;
    for( float i=0.0; i<32.0 && depth<MAX_DIST; i++ ){
     	vec3 p = eye + dir * depth;
        float h = thing(p).x;
        if (h < 0.0){ return 0.0; }
        
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, 10.0*d/max(0.0,depth-y) );
        depth += h * remap(float(i),0.0,32.0,0.1,1.0);
        depth += 0.05;
    }

    return res;
}

// Function 1479
float Light_SpotFactor( vec3 vLightDir, vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle )   
{
    float fSpotDot = dot( vLightDir, -vSpotDir );
    
    float fTheta = acos(fSpotDot);

    float fAngularAttenuation = clamp( (fTheta - fSpotOuterAngle) / (fSpotInnerAngle - fSpotOuterAngle), 0.0, 1.0 );
    
    float fShapeT = fTheta / fSpotOuterAngle;
    fShapeT = fShapeT * fShapeT * fShapeT;
    float fShape = (sin( (1.0 - fShapeT) * 10.0));
    fShape = fShape * fShape * (fShapeT) + (1.0 - fShapeT);
    
    //return fShape;
    return fAngularAttenuation * fShape;
}

// Function 1480
vec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {
    vec3  col = vec3(0.5);
    
    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );
    if( pos.y < 0.01 ) {
        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );
        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );
    }    
    
    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);
  	col *= (sh * backgroundColor);  
 
    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows
        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );
        if( ha > 0.95) {
            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );
        }
    }
    
	col = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );
  
    return col;
}

// Function 1481
float softShadow(in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.001;
	for( int i=0; i<80; i++ )
	{
	    vec3  p = ro + t*rd;
        float h = p.y - terrainM( p.xz );
		res = min( res, 16.0*h/t );
		t += h;
		if( res<0.001 ||p.y>(SC*200.0) ) break;
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 1482
vec3 shade( in vec3 p, in vec3 d, in vec3 e )
{
    // Get the depth from eye to position.
    float dist = length(p-e);
    
    // Supplant a sample from the environment map
    // if need be.
    vec3 skyColor = calculateSkyLuminanceRGB(SUN_DIR, d, 2.25)*.05;
    if( dist>=MAX_DEPTH ) return skyColor;
    
    // Create a place to store the final result of our pixel.
    vec3 result;
    
    // Get the surface normal for use throughout
    // the process.
    vec3 n = norm(p);
    
    // Light intensities.
    #ifdef CALC_ON_LIGHTS
    float sun_i = orenNayar(n, d, SUN_DIR);
    #else
    float sun_i = gouraud(n, SUN_DIR);
    #endif
    float sky_i = clamp(n.y, 1.0, 1.25);
    #ifdef CALC_OCCLUSION
    float occ_i = occlusion(p,n);
    #else
    float occ_i = 1.0;
    #endif
    #ifdef CALC_BETTER_GI
    float gli_i = .125;
    #else
    float gli_i = 1.0;
    #endif
    
    // Light colors.
    vec3 sun_c = SUN_COLOR;
    vec3 sky_c = skyColor;
    #ifdef CALC_TEXTURES
    vec3 box_c = tex(p);
    #else
    vec3 box_c = color(p);
    #endif
    #ifdef CALC_BETTER_GI
    vec3 gli_c = giColor(p,n);
    #else
    vec3 gli_c = sky_c * .75;
    #endif
    
    // Go ahead and combine all of this stuff.
    result  = sun_c * sun_i;
    result += sky_c * sky_i * occ_i;
    result += gli_c * gli_i * occ_i;
    
    // Clamp the result to the normal range.
    result = clamp(box_c*result,0.0,1.0);
    
    // Apply fog.
    result = fog(result, dist, skyColor*5., d, SUN_DIR, .0075);
    
    // Return the point after distance culling.
    return distCull(result, sky_c, dist);    
}

// Function 1483
vec3 GetLightColor (vec3 uv)
{    
    // let's draw some SDF's into the light color -> add color and also shadows.
    // Use uv.z (the instance index) as a source of variation;
    vec2 textureuv = uv.yx*0.5+0.5;
    
    float circleScale = hash12(vec2(uv.z, 0.645));
    circleScale *= circleScale;
    circleScale *= 0.15;
    
    float slope = hash12(vec2(uv.z, 1.374)) * 2.0 - 1.0;
    slope *= slope * slope;
    slope *= 100.0;
    
    float slope2 = hash12(vec2(uv.z, 3.7163)) * 2.0 - 1.0;
    slope2 *= slope2 * slope2;
    slope2 *= 100.0;    
    
    float shadeDist = SDFCircle(textureuv, vec3(0.5, 0.5, circleScale));
    
    shadeDist = min(shadeDist, SDFLine(textureuv, vec3(0.5, 0.5, slope)));
    shadeDist = min(shadeDist, SDFLine(textureuv, vec3(0.5, 0.5, slope2)));
    
    float shade = smoothstep(0.00, 0.1, shadeDist);
    
    vec3 color = texture(iChannel0, textureuv).rgb;
       
    // draw a randomly colored circle on the canvas too
    vec3 circleColor = hash32(vec2(uv.z, 8.453));
    vec3 circleColorScale = hash32(vec2(uv.z, 7.846));
    circleColorScale.z *= 0.1;
    float circleDist = SDFCircle(textureuv, circleColorScale);
    float colorLerp = 1.0 - smoothstep(0.00, 0.1, circleDist);
    color = mix(color, circleColor, colorLerp);
    
    circleColor = hash32(vec2(uv.z, 3.645));
    circleColorScale = hash32(vec2(uv.z, 2.164));
    circleColorScale.z *= 0.1;
    circleDist = SDFCircle(textureuv, circleColorScale);
    colorLerp = 1.0 - smoothstep(0.00, 0.1, circleDist);
    color = mix(color, circleColor, colorLerp);    
    
    return color * shade;
}

// Function 1484
vec3 shadeObjects(vec3 p, vec3 n, vec3 r) {
    
    vec3 col = vec3(0.);
    vec2  uv = mod(asin(n.xy) / PI + .5, 1.);
        
    if(p.z > .9)
    	uv = mod(p.xy / 3.5, 1.);
        
    col = vec3(1.,0.,0.);
    float sp = 3.;
    vec2 ch = mod(uv * 5., 1.);
    if((ch.x > .5 || ch.y > .5) && !(ch.x > .5 && ch.y > .5)) {
    	col *= .5;
    	sp = 60.;
    }
     
    col = calcLighting(col, p, n, r, sp);
    
    return col;
    
}

// Function 1485
vec3 map_light_rgb(vec3 ro, vec3 rd, vec3 nrm) { 
    return map_light_pm(ro, rd);
}

// Function 1486
float Ao(vec3 p, vec3 n, float d) {
	float vis = 0.0;
	float w= 1.;
	for (int i=0; i<10; i++)
	{
		float d = sdf(p, bvec4(1,1,1,1));
		//this made more sense to me as volume of sphere that is clear of stuff blocking light ??
		vis += d; //* (4.*pi/3.);	
		
	//	vis+=d*w;
	//	w *= 0.5;
		p += n * d * 0.9;
	}
	vis*=.1;
	return pow(clamp(vis,0.,1.),1.0);
}

// Function 1487
Radiance3 shade(Surfel surfel, Vector3 w_i, Vector3 w_o, Biradiance3 B_i) {
	Vector3 w_h = normalize(w_i + w_o);
	Vector3 n   = surfel.normal;
	
	Color3 p_L, p_G;
	float glossyExponent;
	computeReflectivities(surfel.material, p_L, p_G, glossyExponent);

	// Compute the light contribution from the directional source
	return max(0.0, dot(n, w_i)) * B_i * 
		// Lambertian
		(p_L / pi + 

		// Glossy
        pow(max(0.0, dot(n, w_h)), glossyExponent) * p_G * (glossyExponent + 8.0) / (8.0 * pi));
}

// Function 1488
float sample_ao(vec3 vp, vec3 p, vec3 n)
{
    const float s = 0.5;
    const float i = 1.0 - s;
    vec3 b = vp + n;
    vec3 e0 = n.zxy;
    vec3 e1 = n.yzx;
    float a = 1.0;
    if (voxel(b + e0))
        a *= i + s * sqi(fract(dot(-e0, p)));
    if (voxel(b - e0))
        a *= i + s * sqi(fract(dot(e0, p)));
    if (voxel(b + e1))
        a *= i + s * sqi(fract(dot(-e1, p)));
    if (voxel(b - e1))
        a *= i + s * sqi(fract(dot(e1, p)));
    if (voxel(b + e0 + e1))
        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 - e1) * p)))));
    if (voxel(b + e0 - e1))
        a = min(a, i + s * sqi(min(1.0, length(fract((-e0 + e1) * p)))));
    if (voxel(b - e0 + e1))
        a = min(a, i + s * sqi(min(1.0, length(fract((e0 - e1) * p)))));
    if (voxel(b - e0 - e1))
        a = min(a, i + s * sqi(min(1.0, length(fract((e0 + e1) * p)))));
    return a;
}

// Function 1489
float shadow(in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    
    float t = .1;
    for( int i = 0; i < 10; i++ )
    {
		float h = map(ro + rd*t, 1.);

        res = min( res, 4.*h/t );
        t += h + t*.01;
        if (res < .3) break;
    }
    return clamp( res, 0.3, 1.0 );
}

// Function 1490
vec3 Shades(vec3 u,vec3 t,vec3 n,vec3 d,vec3 c,vec3 C,float m,float e,vec3 a,float p){
#ifdef doOccludeSubSurfaceScatter
;if(Toggle(kSubsurface)){
 ;float tr=e*.1;
 ;a+=C*c*subSurface(u,tr,d);}
#endif
;float ndotl1=max(.0,dot(n,d))
#ifdef doOccludeWax
;a+=C*c*m*ndotl1
;a+=c*m*Specular(n,normalize(d-t) ,smoothstep(.0,.1,ndotl1),p)
#endif
;return a;}

// Function 1491
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<64; i++ )
    {
		float h = dstScene( ro + rd*t );
        res = min( res, k*h/t );
        t += clamp( h, 0.07, .5 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1492
float ShadowMarch( vec3 pos, vec3 light )
{
    vec3 ray = normalize(light-pos);
    float e = length(light-pos);
    float t = .02; // step away from the surface
    for ( int i=0; i < 200; i++ )
    {
        float h = Scene(pos+ray*t);
        if ( h < .001 )
        {
            return 0.; // hit something
        }
        if ( t >= e )
        {
            break;
        }
        t += h;
    }
    return 1.; // didn't hit anything
}

// Function 1493
vec3 shade(in vec3 pos, in vec3 rd)
{
    vec3 col = vec3(0);
    vec2 plr = vec2(length(pos.xz), atan(pos.z,pos.x));
    
    vec3 colLch = lch2rgb(vec3(pos.y*50.+50.,plr.x*100. , plr.y));
    vec3 colHsv = hsv2rgb(vec3(plr.y/6.2831853, plr.x, pos.y*0.5+0.5));
    
    col = mix(colLch, colHsv, smoothstep(0.5,0.5, sin(time*0.5+0.1)));
    
    return col;
}

// Function 1494
float light_time_per_m()
{
    return (iMouse.z > 0.) ? (min(1.,max((MOUSEY-0.25)/0.7,0.))*0.06) : (sin(iTime*.25)*.5+.5)*.06 ;
}

// Function 1495
float calcAO( const vec3 pos, const vec3 nor ) {
	float aodet=detail*75.;
	float totao = 0.0;
    float sca = 10.0;
    for( int aoi=0; aoi<5; aoi++ ) {
        float hr = aodet*float(aoi*aoi);
        vec3 aopos =  nor * hr + pos;
        float dd = de( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - 5.0*totao, 0., 1. );
}

// Function 1496
float GetShadows( in vec3 ro, in vec3 rd)
{
	float shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));
	float shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));
	
	return smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));
}

// Function 1497
vec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) 
{   
    vec3 lightPos=lp;
    vec3 hit = ro + rd * t;
    vec3 norm =normal; //GetNormal(hit);
    
    vec3 light = lightPos - hit;
    float lightDist = max(length(light), .001);
    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);
    light /= lightDist;
    
    float occ = occlusion(hit, norm);
    
    float dif = clamp(dot(norm, light), 0.0, 1.0);
    dif = pow(dif, 4.) * 2.;
    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);
    
    float fshadow;
    if (mObj.blnShadow==true)
        {fshadow=GetShadow(p,lp);}
    else
        {fshadow=0.75;}
        
    
     vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;
    
    return color*fshadow;
    
    
}

// Function 1498
float hmd_flight_path_marker( vec2 coord )
{
    float result = 0.;
    vec3 localv = g_vehicle.modes.x == VS_HMD_ORB ?
        g_vehicle.orbitv * g_planet.B * g_game.camframe :
    	g_vehicle.localv * g_game.camframe;
    if( g_vrmode )
        localv *= g_vrframe;
    if( dot( localv, localv ) >= .25e-6 )
    {
        vec3 v = localv;
        float sz = hmd_symbol_border( v, HMD_BORDER_SYM );
        mat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );
    	vec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;
        vec2 a = vec2( +4, 0 );
        vec2 b = vec2( +9, 0 );
        vec2 c = vec2( 0, +4 );
        float shape = 0.;
        if( Linfinity( p ) < 10. )
        {
        	shape = max( shape, aaa_ring( I, p, sz * 8., 1. ) );
            shape = max( shape, aaa_hline( I, p, -sz * b, sz * 5., 1. ) );
            shape = max( shape, aaa_hline( I, p, +sz * a, sz * 5., 1. ) );
            shape = max( shape, aaa_vline( I, p, +sz * c, sz * 4., 1. ) );
        }
		if( localv.x < 0. &&
            abs( localv.y ) < -HMD_BORDER_SYM.x * localv.x &&
            abs( localv.z ) < -HMD_BORDER_SYM.y * localv.x )
		{
        	p = ( coord - project3d( localv, g_game.camzoom ) ) * g_textscale;
            if( Linfinity( p ) < 10. )
            {
            	shape = max( shape, aaa_ring( I, p, 8., 1. ) );
            	shape = max( shape, aaa_hline( I, p, -a, 8., 1. ) );
            	shape = max( shape, aaa_vline( I, p, -c, 8., 1. ) );
            }
        }
        result += shape * sz;
    }
    return result;
}

// Function 1499
float SoftShadowRing( in vec3 origin, in vec3 direction )
{
  float res =1., t = 0.0, h=0.;
  vec3 rayPos = vec3(origin+direction*t);    

    for ( int i=0; i<10+min(0, iFrame); i++ )
    {
      h = MapPlanet(rayPos).x;
      res = min( res, 8.5*h/t );
      t += clamp( h, 0.01, 100.1);
      if ( h<0.005 ) break;
      rayPos = vec3(origin+direction*t);
    }
  return clamp( res, 0.0, 1.0 );
}

// Function 1500
vec3 directLight(vec3 p, vec3 n)
{
    // Sampled light color
    vec3 lightSample = vec3(0.0);
    
    // Diffuse light path
    vec3 vDiff = normalize(R3D(p + iTime) * 2.0 - 1.0);

    // Loop through each object
    for (int i = 0; i < OBJ_COUNT; i++)
    {
        // If it's emissive, try cast a ray toward it
        if (surface(i, p).emission != vec3(0.0))
        {
            // Temporary p and n
            vec3 p_, n_ = vec3(0.0);

            // Setup a ray towards the object
            vec3 ld = objects[i].pos - p;

            // Direction to cast ray in
            vec3 dir = normalize(vDiff + ld);

            // Cast a ray. If we hit the object, add onto the light sample
            if (castRay(p, dir, n_, p_) == i)
                lightSample += surface(i, p_).emission * diffuseBRDF(dir, n);
        }
    }
    
    // Return it
    return lightSample;
}

// Function 1501
vec3 shade_reflect(vec3 p, vec3 rd, vec3 n)
{
	vec3 diffuse = background(reflect(rd, n));
	vec3 l = normalize(LightPos - p);

	// Phong shading
	vec3 color = 0.4 * diffuse; // "Ambiant" Term
	
    float penumbra = 1.0;
	float lambertTerm = dot(n,l);
	if(lambertTerm > 0.0)
	{
		#ifdef SELF_SHADOWING
		bool gotout = false;
		bool hit = false;
		vec3 p2 = p + Epsilon * l;
		for(int i = 0; i < Steps; i++)
		{
			float v = SphereTracedObject(p2);
			if (v < 0.0)
			{
				gotout = true;
				break;
			}

			p2 += Epsilon * l;
		}
        #ifdef SOFT_SHADOW
        if(gotout)
            penumbra = clamp(softShadow(p2, l, 16.0), 0.0, 1.0);
        #else
		if(gotout)
			SphereTrace(p2, l, hit);
		if(hit) // We're in shadows, skip diffuse and specular terms 
			return color;
        #endif
		#endif
		
        vec3 shaded = penumbra * LightColor;
        
		// Diffuse Term
		color += lambertTerm * shaded * diffuse;	

		// Specular Term
		vec3 r = reflect(l, n);
		float specular = pow( max(dot(r, rd), 0.0), 8.0);
		color += specular * shaded;	
	}

	return color;
}

// Function 1502
vec3 getPhysicalLighting(in Material mat, in PointLight light, in vec3 position, in vec3 normal, in Ray camRay, in int seed)
{
    vec3 v = normalize(camRay.origin - position);
    vec3 wi = normalize(light.position - position);
    vec3 h = normalize(wi + v);
    
    float cosTheta = max(dot(normal, wi), 0.0);
    
    float attenuation = calculateAttenuation(light.position, position);
    vec3 radiance = light.color * attenuation;
    
    vec3 F0 = vec3(0.04); 
	F0      = mix(F0, mat.albedo, mat.metalness);
	vec3 F  = fresnelSchlick(max(dot(h, v), 0.0), F0);
    
    float NDF = DistributionGGX(normal, h, mat.roughness);       
	float G   = GeometrySmith(normal, v, wi, mat.roughness);
    
    vec3 numerator    = NDF * G * F;
	float denominator = 4.0 * max(dot(normal, v), 0.0) * max(dot(normal, wi), 0.0);
	vec3 specular     = numerator / max(denominator, 0.001);
    
    vec3 kS = F;
    vec3 kD = vec3(1) - kS;
    kD *= 1.0 - mat.metalness;
    
    vec3 indirectDiffuse = vec3(0); 
    for (int i = 0; i < PASSES; i++) {
        indirectDiffuse += indirectDiffuseCast(camRay, seed);
    }
    indirectDiffuse /= float(PASSES);
    
    return indirectDiffuse * kD + specular * radiance * cosTheta;
}

// Function 1503
float shadow(vec3 rpos, vec3 rdir) {
	float t = 1.0+SHADOW_QUALITY;
	float sh = 1.0;
	for (int i = 0; i < SHADOW_ITERS; i++) {
		vec3 pos = rpos + rdir * t;
		float h = pos.y - terrain(pos.xz);
		if (h < 0.0) return 0.0;
		sh = min(sh, h/t*8.0);
		t += max(h, SHADOW_QUALITY);
	}
	return sh;
}

// Function 1504
vec4 shade(Ray ray) {

    Hit scene = raymarch(ray);
    
    if(scene.dist.id == 0) {

        return shadeDeathStar(ray, scene);
        
    } else if(scene.dist.id == 1) {
     
        return shadeDroid(ray, scene);
        
    }
    
    return clearColor(ray.dir);
    
}

// Function 1505
float calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )
{
	float ao = 0.0;
	const int nbIte = 5;
	for( int i=0; i<nbIte; i++ )
	{
		float l = hash(float(i))*maxDist;
		vec3 rd = n*l;
		ao += (l - map(p + rd.x)) / pow(1.+l, falloff);
	}
	return clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);
}

// Function 1506
vec3 getLightVector(vec3 p) {
	return vec3(10.*cos(iTime),0.,3.)-p;
}

// Function 1507
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.12*float(i)*0.25 + 0.01;
        vec3 aopos =  nor * hr + pos;
        float dd = scene( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return saturate(1.0 - 3.0*occ);    
}

// Function 1508
vec3 shade(vec3 p, vec3 rd, vec3 ld){
  vec3 n = normals(p);
  
  float l = max(dot(n, ld), 0.0);
  float a = max(dot(reflect(ld, n), rd), 0.0);
  float s = pow(a, MATERIAL.shiny);
  
  return l*MATERIAL.l_col*MATERIAL.l_i+s*MATERIAL.s_col*MATERIAL.s_i;
  
}

// Function 1509
vec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal){
    vec3 lin = vec3(0.0);

    vec3  view = normalize(-rd);
    const vec3 lig1 = normalize(vec3(-1., 1., 1.));
    const vec3 lig2 = normalize(vec3(0., 1., 2.));
    
    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);
    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));
    vec3  col2 = vec3(.5);
    lin += col2*spc2+dif2*col2;

    vec3 col = mal*lin;

    return col;
}

// Function 1510
float shadow(vec3 ro, vec3 rd, vec3 div, float rand) {
    float md=1.0;
    int steps=MAX_STEPS_SHADOWS;
    float s=5.0/float(steps);
    float t=0.01;//+rand*s;
    for(int i=0; i<steps; ++i) {
        float d=map2(ro+rd*t, div);
        md=min(md,5.0*d/t);
        if(d<-0.0) {
            //md=0.0;
            break;
        } 
        t+=s;
    }

    return clamp(md,0.0,1.0);
}

// Function 1511
float GetLight(vec3 p){
    //position of the light source
    vec3 lightPos = vec3(0,5,6);
    
    lightPos.xz += vec2(sin(iTime),cos(iTime));
    //light vector
    vec3 l = normalize(lightPos-p);
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l);
    if(d < length(lightPos-p)){
        diff *= 0.1;
    }
    return diff;
}

// Function 1512
vec3 getLightPos(in int idx) {
    if (idx == 0) {
        return vec3(3.0);
    } else {
        return vec3(CAM_DIST * 2.0 * sin(iTime * PI), 
                    CAM_DIST * 2.0 * sin(iTime),
                    CAM_DIST * 2.0 * cos(iTime * PI));
    }
}

// Function 1513
float calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )
{
	float res = 1.0;
    float t = tmin;
    for( int i=0; i<50; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, k*h/t );
        t += clamp( h, 0.02, 0.20 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1514
void light(in vec3 p, in vec3 d, in vec3 e, in vec3 n, in float id,
		   out float amb, out float dif)
{
	if(id == ID_LIGHTS) amb = 1.0;
	else amb = occlusion(p, n);
   
	// Yep! The diffuse term is just the distance to the light.
    dif = clamp(1.0- pow( lights(p)*.1, 1.5 ), 0., 1.);
}

// Function 1515
int card_baord_id(vec2 p) {
    return int(floor((p.x + 0.18 * 3.) / 0.18));
}

// Function 1516
vec3 salmpleLight(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                  	in vec3 wi,
                  in float time,
                  	in Material mtl) {
    vec3 Lo = vec3(0.0);	//outgoing radiance
	const float strata = 1.0 / float(SURFACE_DIRECT_LIGHT_SAMPLES);
    for(int i=0; i<SURFACE_DIRECT_LIGHT_SAMPLES; i++){
        LightSamplingRecord rec;
        float xi = strata*(float(i)+rnd());
        vec3 Li = sampleLightSource( x, ns, xi, rnd(), rec );

        float dotNWo = dot(rec.w, ns);
        if ((dotNWo > 0.0) && (rec.pdf > EPSILON)) {
            vec3 fr = mtlEval(mtl, ng, ns, wi, rec.w);
            if(dot(fr,fr)>0.0) {
                Ray shadowRay = Ray(x + ng*EPSILON, rec.w, time);
                if (isLightVisible( shadowRay )) {
                    Lo += ((Li * fr * dotNWo) / rec.pdf) * misWeight(rec.pdf, mtlPdf(mtl, ng, ns, wi, rec.w));
                }
            }
        }
    }

    return Lo / float(SURFACE_DIRECT_LIGHT_SAMPLES);
}

// Function 1517
float shadow( vec3 ro, vec3 rd )
{
    bool hit = false;
    vec3 p = ro + rd;
    float t = 0.;
    float k = 16.;
    float res = 1.;
    
    for( int i=0;i<32;i++)
    {
       float d = map(p);
        
        t+=d;
        res = min( res, k*d/t );
        
        if(d<EPS)
        {
            hit = true;
            res = 0.;
            break;
        }
        else if(t>15.)
        {
            hit = false;
            break;
        }
      
        p = ro + rd * t * 0.45;
    }
    
    return res;
}

// Function 1518
vec3 lights(vec3 p, vec3 rd, float d, Hit h) {
	vec3 ld = normalize(vec3(6, 3, -10) - p),
		 n = h.id == 4 ? glassN(p, d) : calcN(p, d),
		 c = vec3(0);
	float ss = 0.;

	if (h.id == 1)
		c = BLUE;
	else if (h.id == 2) {
		c = BLUE;

		// Sub-surface scattering.
		ss = smoothstep(0., 1., tubez(3. * ld + p).d / 3.);
	} else if (h.id == 3)
		c = vec3(1);
	else if (h.id == 5)
		c = logo(p);
	else c = vec3(.05, .1, .15);

	// Primary light.
	float l1 = max(0., .1 + .9 * dot(ld, n)),

	// Secondary(/bounce) light.
	l2 = max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)),

	// Specular.
	spe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(ld, n))), 30.)) * 10.;

	// Bubblez/glass.
	if (h.id == 1 || h.id == 4)
		return c + l2 + (spe + l1) * .15;

	// Fresnel.
	float fre = smoothstep(.7, 1., 1. + dot(rd, n)) * .5,
		  _ao = dot(vec2(ao(p, n, .2), ao(p, n, 2.)), vec2(.4, .6));

	if (h.id == 6)
		return c + (l1 + spe) * .02;

	l1 *= (.3 + .7 * calcShadow(p, ld)) // ...with shadow.
		  * (.3 + .7 * _ao); // ...and _some_ AO.

	// Combine into final color.
	float lig = l1 + (l2 * .3 + spe) * _ao + ss;
	return mix(lig * c * vec3(2, 1.8, 1.7), vec3(.1), fre);
}

// Function 1519
float getAO(vec3 pos, vec3 n)
{    
    float ao=1.;
    float sc=.025;
    float amb=.3;
    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)
    for( int i=min(iFrame,0); i<5; i++ )
    {
    	ao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);
    	ao=clamp(ao,0.,1.);
        sc*=2.;
        amb=min(amb+.1,.5);
    }
    return ao;
   	/*
    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;
   	ao=clamp(ao,0.,1.);
    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;
    ao=clamp(ao,0.,1.);
    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;
    ao=clamp(ao,0.,1.);
    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;
    ao=clamp(ao,0.,1.);
    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;
    ao=clamp(ao,0.,1.);*/
}

// Function 1520
vec3 lightImage( vec2 uv )
{


    vec3 vlight=getLight(uv);
    float light=(vlight.x+2.5)*0.3;

    return vec3(light)*0.3;
    vec3 col=vec3(0.);


    if(light>1.) col=render(vec3(0.2),vec3(1.,1.,1.),light);
    else col= 0.8 * col* pow(smoothstep(.089,1.,light),0.2)*light + col*0.2;


    return col;
}

// Function 1521
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1522
float aoFromSphere(vec3 s, float r, vec3 p, vec3 n)
{	// iq's sphere ao - http://www.iquilezles.org/www/articles/sphereao/sphereao.htm
	vec3 dir = s - p;
	float lenSq = dot(dir, dir);
	dir *= inversesqrt(lenSq);
	return 1.0 - max(dot(n, dir) * (r*r / lenSq), 0.0);
}

// Function 1523
void lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {
    float ao = ambientOcclusion(td,norm);
    dif = ambient*ao;
    spec = vec3(0.);
        
    #if nLights != 0
    initDynamicLights(td);
    for (int i = 0; i < nLights; i++) {
        vec3 lightVec = lights[i].position-td;
        float lightAtten = length(lightVec);
        lightVec = normalize(lightVec);
        float shadow = softShadowTrace(sd, lightVec, lightAtten, 0.3, 1.5);
        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;
        
    	dif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;
        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lightAtten*lights[i].color;
    }
	#endif
    
    //dif *= .5+ao*.5;
}

// Function 1524
vec4 drawlight(vec2 pos,float radius, vec2 uv) { 
  float dist=length(pos-uv);
  float maxDistance=pow(radius,0.10);
  float quadDistance=pow(dist,0.21);
  float quadIntensity=1.0-min(quadDistance,maxDistance)/maxDistance;      
      
  vec4 lght=vec4(quadIntensity);
  return lght;
  }

// Function 1525
float calcAO( in vec3 pos, in vec3 nor )
{
	float totao = 0.0;
    for( int aoi=0; aoi<16; aoi++ )
    {
		vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);
		aopos *= sign( dot(aopos,nor) );
		aopos = pos + nor*0.01 + aopos*0.04;
        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );
        totao += dd;
    }
	totao /= 16.0;
	
    return clamp( totao*totao*50.0, 0.0, 1.0 );
}

// Function 1526
vec3 evaluateLight(in vec3 pos)
{
    pos.y -= anims.x;

    pos.z = abs(pos.z)-26.;
    float distanceToL2 = length(L2-pos-ying);


    h2 += +lightCol * 1.0/(distanceToL2*distanceToL2);
    float dh2 = length(L2-pos-yang);
    h2 -= vec3(.82,.73,.75)*1./(dh2*dh2);
    return h2*lightCol;

}

// Function 1527
float diffuseLight (vec3 p, vec3 n, vec3 r){
    return dot(n, -r);
}

// Function 1528
vec3 skylight(vec3 sample_pos, vec3 surface_normal, vec3 light_dir, vec3 background_col) {

    // slightly bend the surface normal towards the light direction
    surface_normal = normalize(mix(surface_normal, light_dir, 0.6));
    
    // and sample the atmosphere
    return calculate_scattering(
    	sample_pos,						// the position of the camera
        surface_normal, 				// the camera vector (ray direction of this pixel)
        3.0 * ATMOS_RADIUS, 			// max dist, since nothing will stop the ray here, just use some arbitrary value
        background_col,					// scene color, just the background color here
        light_dir,						// light direction
        vec3(40.0),						// light intensity, 40 looks nice
        PLANET_POS,						// position of the planet
        PLANET_RADIUS,                  // radius of the planet in meters
        ATMOS_RADIUS,                   // radius of the atmosphere in meters
        RAY_BETA,						// Rayleigh scattering coefficient
        MIE_BETA,                       // Mie scattering coefficient
        ABSORPTION_BETA,                // Absorbtion coefficient
        AMBIENT_BETA,					// ambient scattering, turned off for now. This causes the air to glow a bit when no light reaches it
        G,                          	// Mie preferred scattering direction
        HEIGHT_RAY,                     // Rayleigh scale height
        HEIGHT_MIE,                     // Mie scale height
        HEIGHT_ABSORPTION,				// the height at which the most absorption happens
        ABSORPTION_FALLOFF,				// how fast the absorption falls off from the absorption height
        LIGHT_STEPS, 					// steps in the ray direction
        LIGHT_STEPS 					// steps in the light direction
    );
}

// Function 1529
float cAO(in vec3 p, in vec3 n)
{
	float sca = 1., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = m(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 1530
vec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid )
{
  vec3 base = rand3( id, SEED );
  vec3 wash = mix( vec3(0.9), base, 0.4);
  vec3 hero = rand3( iid, SEED );
  
  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );
  float occ = occlusion( P, N );
  float ocf = 1.-sqrt((0.5 + 0.5*-N.y)/(P.y+1.25))*.5; //floor occusion. 1.25 floor P.
  float fre = clamp( 1. + dot( I, N), 0., 1.); fre = (0.01+0.4*pow(fre,3.5));
  float lgh = sphLight( P, N, L) *  areaShadow( P );
  float inc = ( id == iid ? 1.0 : 0.0 );
   
  // Env light
  vec3 C = wash * occ * ocf * .2;
  
  // Sphere light
  C += ( inc + lgh * 1.3 ) * hero;

  // Reflections
  C = mix( C, ref, fre );
  
  return C;
}

// Function 1531
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<128; i++ )
	{
        float h = map(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        res = min( res, k*h/t );
        t += h;
        if (t >= maxt) {
            break;
        }
	}
    return res;
}

// Function 1532
vec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)
{
    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );
//	sh = Shadow(pos,  sunLight);
    // Light surface with 'sun'...
	vec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;
    //col += mat * vec3(0., .0, .15)*(max(dot(-sunLight,normal), 0.0));
    
    normal = reflect(eyeDir, normal); // Specular...
    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * .5 *sh;
    // Abmient..
    col += mat * .2 * max(normal.y, 0.2);
    col = mix(FOG_COLOUR,col, clamp(exp(-d*.05)+.03,0.0, 1.0));
    
	return col;
}

// Function 1533
float calculateAO(vec3 p, vec3 n){

   const float AO_SAMPLES = 5.0;
   float r = 1.0, w = 1.0, d0;
    
   for (float i=1.0; i<=AO_SAMPLES; i++){
   
      d0 = i/AO_SAMPLES;
      r += w * (map(p + n * d0) - d0);
      w *= 0.5;
   }
   return clamp(r, 0.0, 1.0);
}

// Function 1534
float compute_ao(vec3 origin, vec3 n_normal)
{
    // TODO: PERFORMANCE: Calculate AO in texture space?
    
    // TODO: Improve sample coordinates!
    const vec2 coordinates[24] = vec2[](
        vec2(0.1345339, 0.9776062),
        vec2(0.4509954, 0.711735),
        vec2(0.7675728, 0.5708129),
        vec2(0.7562704, 0.226492),
        vec2(0.797026, -0.1188121),
        vec2(0.5915386, -0.4101292),
        vec2(0.2672587, -0.5891874),
        vec2(0.560896, -0.7683676),
        vec2(0.2602177, -0.9483843),
        vec2(-0.2098463, -0.8336008),
        vec2(-0.09346788, -0.4964156),
        vec2(-0.4253753, -0.312667),
        vec2(-0.1753666, 0.02664107),
        vec2(0.1650871, -0.1864996),
        vec2(0.299685, 0.1578036),
        vec2(0.0109844, 0.3367841),
        vec2(-0.102881, 0.6622637),
        vec2(-0.4101768, 0.848845),
        vec2(-0.6571413, 0.6137035),
        vec2(-0.4172723, 0.3342704),
        vec2(-0.7731495, 0.2193842),
        vec2(-0.7416561, -0.1416828),
        vec2(-0.8618071, -0.4668948),
        vec2(-0.6076193, -0.7025846)
    );
    
    const vec3 coordinates2[24] = vec3[24](
        vec3(0.1, 0.45, -0.62),
        vec3(-0.9, 0.01, 0.5),
        vec3(-0.4, -0.57, 0.64),
        vec3(0.47, 0.756, -0.541),
        vec3(0.1, -0.45, 0.62),
        vec3(0.39, 0.01, 0.5),
        vec3(-0.74, -0.57, -0.64),
        vec3(0.47, -0.756, -0.541),
        vec3(0.1, -0.45, -0.62),
        vec3(-0.79, -0.21, 0.5),
        vec3(0.4, 0.57, -0.464),
        vec3(0.47, -0.1756, -0.541),

        -vec3(0.1, 0.45, -0.62),
        -vec3(-0.9, 0.01, 0.5),
        -vec3(-0.4, -0.57, 0.64),
        -vec3(0.47, 0.756, -0.541),
        -vec3(0.1, -0.45, 0.62),
        -vec3(0.39, 0.01, 0.5),
        -vec3(-0.74, -0.57, -0.64),
        -vec3(0.47, -0.756, -0.541),
        -vec3(0.1, -0.45, -0.62),
        -vec3(-0.79, -0.21, 0.5),
        -vec3(0.4, 0.57, -0.464),
        -vec3(0.47, -0.1756, -0.541)
    );
    
    /*
    float samples = 0.0;
    float sample_weights = 0.0;
    
	// World space version:
    for(int i=0; i<coordinates2.length(); ++i)
    {
        // TODO: Orient to hemisphere?
        vec3 sample_position = origin + n_normal * 0.1;
        sample_position = origin + coordinates2[i] * 0.25 * (float(1 + i) / float(coordinates2.length()));
        
        vec3 cubemap_origin_to_sample_position = sample_position - cubemap_origin;	// TODO: Pre-subtract this?
        
        float cubemap_origin_to_sample_position_length = length(cubemap_origin_to_sample_position);
        vec3 n_cubemap_origin_to_sample_position = cubemap_origin_to_sample_position / cubemap_origin_to_sample_position_length;
        
        vec2 uv = compute_uv(n_cubemap_origin_to_sample_position);
        float sample_depth = get_distance(uv);
        if(cubemap_origin_to_sample_position_length > sample_depth)
        {
   			// TODO: Take normals into account!
            samples += 1.0;
        }        
    }
    float ao = 1.0 - samples / float(coordinates.length());
    //ao = pow(ao, 2.0);
    ao = min(ao + 0.2, 1.0) - 0.0;
    ao = pow(ao, 2.0);
    return(ao);
    */
    
	// Texture space version:
    // This approach is not 100% mathematically correct, but works good enough and is much faster.
    float samples = 0.0;
    //float sample_weights = 0.0;
    
    vec2 center_uv = compute_uv(normalize(origin - cubemap_origin));
    float center_distance = get_distance(center_uv);
    
    for(int i=0; i<coordinates.length(); ++i)
    {
        // TODO: Orient to hemisphere?
        //vec2 sample_coordinate = center_uv + coordinates[i].xy * 0.05 * (float(1 + i) / float(coordinates.length()));
        vec2 sample_coordinate = center_uv + coordinates[i].xy * 0.05;
        float sample_depth = get_distance(sample_coordinate);
        
        // TODO: Take normals into account! I don't think we can do that efficiently in the texture space version.
        bool occluded = (center_distance < sample_depth);
        //float sample_weight = 1.0 / (1.0 + dot(coordinates[i].xy, coordinates[i].xy) * 2.0);	// TODO: Precompute?
        
        //sample_weights += sample_weight;
        //samples += float(occluded) * sample_weight;
        
        samples += float(occluded);
    }
    
    //float ao = samples / sample_weights;
    float ao = samples / float(coordinates.length());
    return(ao);
}

// Function 1535
float SHADOW_MARCH (vec3 p) {
    p = p+sund()*.1;
    float closestDE = 1e3;
    for (float i=0.; i<35.; ++i) {
        float SDFp = SDF(p);
        if (SDFp < 1e-2) {
            return .8;
        }
        p = p+sund()*SDFp*.99;
        closestDE = min(closestDE, SDFp);
        if (SDFp > 7.) {
            break;
        }
    }
    return 1.;
}

// Function 1536
float light_map(vec3 p, float time)
{
    float sd = sdSphere(p - vec3(-10.*cos(0.0*time),-10.*cos(0.0*time), 5.), 1.);
    //sd = min(sd, sdSphere(p - vec3(5.*cos(0.8*iTime+3.14),5.*sin(0.8*iTime+3.14), 2.), 0.5));
    return sd;
}

// Function 1537
float calcAO(in vec3 p, in vec3 nor)
{
    float tot = 1.0;
    float sca = 20.0;
    for(int i=0; i<5; i++)
    {
        float hr = 0.001 + 0.005*float(i*i);
        vec3 pos =  nor * hr + p;
        float d = f(pos)*0.025;
        tot += (d-hr)*sca;
        sca *= .5;
    }
    return clamp( tot, 0.0, 1.0 );
}

// Function 1538
vec3 getLighting( vec3 p, vec3 normal ) {
    vec3 l = vec3(0.);
    
    float i = getSphereLightIntensity(0.);
    if (i > 0.) {
	    l += sphereCol(time) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[0]), .375));
    } else {    
        i = getSphereLightIntensity(1.);
        if (i > 0.) {
            l += sphereCol(time+1.) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[1]), .25));
        }
    }
    
    vec3 robot = mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));
    vec3 lp = rotateY(vec3(joints[2].x, joints[2].y+1.,0), -jointYRot);
    i = getLightIntensity(p, normal, lp, .5);
    i += getLightIntensity(p, normal, vec3(0,2,0), .25);
    l += i * robot;
    
    return l;
}

// Function 1539
float lightTrace(vec2 o, vec2 r, float maxDst){
    
    // Raymarching.
    float d, t = 0.;
    
    
    // 96 iterations here: If speed and complilation time is a concern, choose the smallest 
    // number you can get away with. Apparently, swapping the zero for min(0, frame) can
    // force the compliler to not unroll the loop, so that can help sometimes too.
    for(int i=0; i<16; i++){
        
        // Surface distance.
        d = map(o + r*t);
        
        // In most cases, the "abs" call can reduce artifacts by forcing the ray to
        // close in on the surface by the set distance from either side.
        if(d<0. || t>maxDst) break;
        
        
        // No ray shortening is needed here, and in an ideal world, you'd never need it, but 
        // sometimes, something like "t += d*.7" will be the only easy way to reduce artifacts.
        t += d*RSF_SHAD;
    }
    
    //t = min(t, maxDst); // Clipping to the far distance, which helps avoid artifacts.
    
    return t;
    
}

// Function 1540
int InShadow(vec3 p, vec3 L, out float t)
{
    int shadowHit = NO_HIT;
    Ray sr;
    sr.Direction = L;
    sr.Orgin = p + vec3(0.05);     
    t =  Trace(sr, shadowHit);
    return shadowHit;
}

// Function 1541
float hashShaderToy(const in vec2 n) {
  return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

// Function 1542
float calcAO( in vec3 pos, in vec3 nor )
{
    float ao = .0;
    for( int i=0; i<SAMPLES; i++ )
    {
        float r2 = rand();
        vec3 d = jitter(nor, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));
        
        ao += castRayAO(pos, d);
    }
    ao /= float(SAMPLES);
#if INVERSEAO > 0
    return clamp( ao, 0.0, 1.0 ); 
#else
    return clamp( 1. - ao, 0.0, 1.0 ); 
#endif
}

// Function 1543
float GetCloudShadow(const in vec3 pos)
    {
        float cloudyChange = abs(1.0 - (0.1 + (cloudy - 0.15) * (0.8/0.6)));
        vec2 cuv = pos.xz + sunDirection.xz * (100.0 - pos.y) / sunDirection.y;
        float cc = 0.1 + 0.9 * smoothstep(0.0, cloudyChange, 
                                          texture( iChannel1, 0.0008 * cuv 
                                                    + 0.005 * iTime).x);
	
        return cc;
    }

// Function 1544
float RaycastShadow( const in vec3 vOrigin, const in vec3 vDir, const in float k )
{
	float fShadow = 1.0;
	float t = 0.01;
	float fDelta = 1.0 / float(kShadowIter);
	for(int i=0; i<kShadowIter; i++)
	{
		float d = GetDistanceShadowCasters(vOrigin + vDir * t).x;
		
		fShadow = min( fShadow, k * d / t );
		
		t = t + fDelta;
	}
	
	return clamp(fShadow, 0.0, 1.0);
}

// Function 1545
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<50; i++ )
    {
		float h = scene( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.01 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1546
vec3 shade(vec3 ro, vec3 rd, vec3 vc)
{
    vec3 p = ro;
	vec3 n = getNor(p, vc);
	
    vec3 ld = vec3(-0.25, -1, 0.25);
	
    float diff = dot(n, ld) * .5 + .5;
	float spe = pow(max(dot(-rd, reflect(-ld, n)), 0.0), 8.0);
	float fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );
	    
    vec3 c = (n * 0.5 + 0.5) * diff; // basic coloring :)
    c += fre * 0.25 + spe * 0.5;

	return c;	
}

// Function 1547
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;
    
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t, -1 ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    
}

// Function 1548
mat4 GetDirectionalLightMatrixInverse ()
{
    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();
    vec3 trans = GetDirectionalLightSourcePosition();
	mat4 rot = rotationAxisAngle(rotAxisAngle.xyz, rotAxisAngle.w );
	mat4 tra = translate( trans.x, trans.y, trans.z );
	return tra * rot; 
}

// Function 1549
float shadow(vec3 dir, vec3 origin, float min_t) {
    #if HARD_SHADOW
    return hardShadow(dir, origin, min_t);
    #else
    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);
    #endif
}

// Function 1550
vec3 calculateShadow( vec3 currentPixelColor, vec3 lightDir, HitInfo hitInfo )
{
    Ray shadowRay;
    shadowRay.direction = normalize( lightDir );
    shadowRay.origin = hitInfo.position + (shadowRay.direction * Epsilon);
    HitInfo shadowHitInfo = intersect( shadowRay );
    currentPixelColor *= clamp( shadowHitInfo.shadowCasterIntensity, 0.00, 1.0 );
    
    return currentPixelColor;
}

// Function 1551
float shadow( in vec3 ro, in vec3 rd )
{
    float res = 0.0;
    
    float tmax = 12.0;
    
    float t = 0.001;
    for(int i=0; i<80; i++ )
    {
        float h = sdf(ro+rd*t);
        if( h<0.0001 || t>tmax) break;
        t += h;
    }

    if( t>tmax ) res = 1.0;
    
    return res;
}

// Function 1552
float calcAO( in vec3 pos, in vec3 nor, in float time )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map( pos+h*nor, time ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1553
vec4 get_lightmap_tile(int index)
{
    ivec2 addr = ivec2(ADDR_RANGE_LMAP_TILES.xy);
    addr.x += index & 127;
    addr.y += index >> 7;
    return texelFetch(SETTINGS_CHANNEL, addr, 0);
}

// Function 1554
vec2 AOandFakeAreaLights(vec3 pos, vec3 n)
{
	vec4 res = vec4(0.0);
    
	for( int i=0; i<3; i++ )
	{
		vec3 aopos = pos + n*0.3*float(i);
		vec4 d = distfunc(aopos);
		res += d;
	}
    
    float ao = clamp(res.w, 0.0, 1.0);
    float light = 1.0 - clamp(res.z*0.3, 0.0, 1.0);
    
	return vec2(ao, light * ao);   
}

// Function 1555
float GrndSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  float sh, d, h;
  sh = 1.;
  d = 0.4;
  for (int i = 0; i < 20; i ++) {
    p = ro + rd * d;
    h = p.y - GrndHt (p.xz);
    sh = min (sh, 20. * h / d);
    d += 0.4;
    if (h < 0.001) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 1556
float diskLight(vec3 coneDirWS, vec3 dirToLightWS,
           float cosAngularRadius, float roughness)
{
    float brdfDiskSolidAngle = 2.0*kPI*(1.0 - (cosAngularRadius-roughness*1.0));
    float diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);
    float brightness = (max(0.00001, diskSolidAngle)/max(0.00001, brdfDiskSolidAngle));
    
    float sharpness = 1.0 - roughness;

    float vDotL = dot(coneDirWS, dirToLightWS);

    float brdfPower = 7.0 - 6.0*sqrt(roughness);
    
    //Angle space visibility instead of cosine space
    //Not sure if this is more correct, the nDotL term is lost
    //But would it even apply to area lighting ?
    brdfDiskSolidAngle = 2.0*kPI*(1.0 - cos(acos(cosAngularRadius)+roughness*0.5*kPI));
    diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);
    brightness = (max(0.00001, diskSolidAngle)/max(0.00001, brdfDiskSolidAngle));
    
    float diskVisibility = max(0.0, linearstep(
        acos(cosAngularRadius) + 0.01 + roughness*kPI*0.5, 
        acos(cosAngularRadius) - 0.01 - roughness*kPI*0.5,
    	acos(vDotL)))*2.0;

    brdfPower = 7.0 - 6.0*(roughness);

    diskVisibility = pow(diskVisibility, brdfPower);

    //Integral S = (x^n dx) is F = x^(n+1) * 1/(n+1)
    //Integral over range [A, B] is F(B) - F(A)
    float powIntegral = 1.0/(brdfPower + 1.0);
	float normalisationFactor = powIntegral;
    //Renormalize
    diskVisibility /= max(0.00001, normalisationFactor);
    diskVisibility = min(1.0, diskVisibility * brightness);

    return diskVisibility;
}

// Function 1557
vec3 Shade(MarchResult hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(0.0);

    if(hit.id == FLOOR)
    {
        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); 
        
        uv /= fwidth(hit.position.xy);
        
        float riverEdge = dfRiver(hit.position, 0.0).x / fwidth(hit.position.xy).x;
                                                       
        float gln = min(min(uv.x, uv.y), riverEdge) / GRID_SIZE;
        
    	color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
    } 
    
    if(hit.id == RIVER)
    {
        vec2 uv = vec2(hit.position.z, abs(mod(hit.position.y + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0)); 
        uv /= fwidth(hit.position.xy);
        
        float gln = min(uv.x, uv.y) / GRID_SIZE;
        
    	color = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
    }
    
    //Distance fog
    color *= 1.0 - smoothstep(0.0, MAX_DIST*0.9, hit.dist);
    
    //Water
    float waterMix = smoothstep(WATER_LEVEL - WATER_FOG_SIZE, WATER_LEVEL + WATER_FOG_SIZE, hit.position.z);
    
    color = mix(color, WATER_COLOR, waterMix);  
    
    if(hit.id == SKYDOME)
    {
        //Sky gradient
        //Causes weird position-colored artefacts around the horizon (AMD R9 270)
        //color = mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);
    	color += mix(SKY_COLOR_1, SKY_COLOR_2, -hit.position.z/16.0);
        
        //Sun
        vec3 sunDir = normalize(SUN_DIRECTION);
        
        float sun = smoothstep(0.950, 0.952, dot(direction, sunDir));
        
        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2, -hit.position.z/16.0);

        color = mix(color, sunCol, sun);
        
        //Clouds
        vec2 cloudUV = CLOUD_SCALE * direction.xy / dot(direction, vec3(0, 0,-1));
        cloudUV += CLOUD_SCROLL * iTime;
        
        color *= smoothstep(0.5, 0.3, texture(iChannel1, cloudUV, CLOUD_BLUR).r) * 0.5 + 0.5;
        
        //Mountains
        float a = atan(hit.position.y, hit.position.x)/tau + 0.5;
        a -= 3.28;
        
        float mountains = MOUNTAIN_SCALE * texture(iChannel0, vec2(a, 0.1),-99.0).r - hit.position.z - MOUNTAIN_SHIFT;
        
        color = mix(color, vec3(0.0), 1.0 - smoothstep(0.6, 0.7, mountains));  
    }
    
    return color;
}

// Function 1558
vec3 shadeSnow(in vec3 po, in vec3 ray) {
    vec3 col = vec3(0.9);
    vec3 norm = getNormal(shapeSnow, po);
    float atten = dot(norm, lig);
   
    col *= 0.85 + atten * 0.3;
   
    return col;
}

// Function 1559
vec3 shade( vec3 pos, vec3 nrm, vec4 light )
{
	vec3 toLight = light.xyz - pos;
	float toLightLen = length( toLight );
	toLight = normalize( toLight );
		
	float diff = dot( nrm, toLight );
	float attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );
	float comb = 2.0 * diff * attn;
	
	return vec3( comb, comb, comb );
}

// Function 1560
vec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid ) {
    
  vec3 base = rand3( id, SEED );
  vec3 wash = mix( vec3(0.9), base, 0.4);
  vec3 hero = rand3( iid, SEED );
  
  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );
  float occ = occlusion( P, N );
 // float ocf = 1.-sqrt((0.5 + 0.5*-N.y)/(P.y+1.25))*.5; //floor occusion. 1.25 floor P.
  float fre = clamp( 1. + dot( I, N), 0., 1.); 
        fre = (0.01+0.4*pow(fre,3.5));
    
  float lgh = sphLight( P, N, L) * areaShadow( P );
  float inc = ( id == iid ? 1.0 : 0.0 );
   
  // Env light
  vec3 C = wash * occ*.2; // * ocf * .2;
  
  // Sphere light
  C += ( inc + lgh * 1.3 ) * hero;

  // Reflections
  C = mix( .3*C, ref, fre );
  
  return C;
}

// Function 1561
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<15; i++ )
    {
        float hr = 0.05 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1562
mat4 GetDirectionalLightMatrix ()
{
    vec4 rotAxisAngle = GetDirectionalLightRotationAxisAngle();
    vec3 trans = GetDirectionalLightSourcePosition();
	mat4 rot = rotationAxisAngle(rotAxisAngle.xyz, -rotAxisAngle.w );
	mat4 tra = translate( -trans.x, -trans.y, -trans.z );
	return rot * tra;     
}

// Function 1563
float ObjAO (vec3 ro, vec3 rd)
{
  float ao, d;
  ao = 0.;
  for (int j = VAR_ZERO; j < 4; j ++) {
    d = float (j + 1) / 8.;
    ao += max (0., d - 3. * ObjDf (ro + d * rd));
  }
  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);
}

// Function 1564
vec3 getLightPos(vec3 origin, int i) {
    vec3 p = 1.0 * sin(lightSpeed * vec3(iTime*0.3, iTime*0.1, iTime*0.2) + 500.*vec3(i));
    p.y += 1.;
    return p;
}

// Function 1565
vec4 shadeOutline(vec3 pos, float t) {
    float alpha = smoothstep(0., OUTLINE_BOUNDRY, t);
    alpha -= smoothstep(OUTLINE_BOUNDRY, 1., t);
    alpha *= .5;
	vec3 color = vec3(0);
    applyFog(color, pos);
    return vec4(color, alpha);
}

// Function 1566
float calcShadowTerrain( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;

    float t = 0.1;
    for( int i=0; i<32; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = mapTerrain(pos, length(pos)).x;
        res = min( res, smoothstep(0.0,1.0,8.0*h/t) );
        t += clamp( h, 0.05, 10.0 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1567
vec3 GetLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)
{                
  vec3 reflectDir = reflect( rayDir, normal );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);

  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float dif2 =max(0., dot( normal, normalize(vec3(1.5, 0., -3.5)) ));

  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  float shadow=1.;
  #ifdef SHADOWS
    shadow = SoftShadow(shadowPos, sunPos);
  dif*=shadow;
  #endif

    const vec3 sunColor = vec3(1.1, 1.1, 1.1); 
  lightTot += 2.*dif*sunColor;
  lightTot +=0.5*dif2*vec3(.6, .35, 1.5);
  lightTot += 1.0*amb*vec3(0.2, 0.25, 0.4);  
  lightTot += 0.40*skylight*vec3(0.4, 0.6, 1.0);
  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);
  lightTot = mix( lightTot, lightTot*2.5, fre );

  return clamp(lightTot, 0.1, 10.);
}

// Function 1568
float shadows(vec3 _ro, vec3 _rd, float _near, float _far, float t)
{
    float d = _near;
    for(int i = 0;i < SHADOW_STEPS; ++i)
    {
        vec3 p = _ro+_rd*d;
        // eval scene
        vec2 t = raymarch_main_scene_normals(p, t);
        if(abs(t.x)<_near || d>_far)
            break;
        d += t.x*0.5;
    }
    return d;
}

// Function 1569
float GrndSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  for (int j = 0; j < 16; j ++) {
    p = ro + rd * d;
    h = p.y - GrndHt (p.xz);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += max (0.2, 0.1 * d);
    if (sh < 0.05) break;
  }
  return sh;
}

// Function 1570
float calcShadow(in vec3 ro, in vec3 rd ) {
    vec2 eps = vec2( 150.0, 0.0 );
    float height1 = terrain( ro.xz );
    float height2 = terrain( ro.xz );
    float d1 =  5.0, d2 =  50.0, d3 = 150.0;
    float s1 = clamp( 1.0*(height1 + rd.y*d1 - terrain(ro.xz + d1*rd.xz)), 0.0, 1.0 );
    float s2 = clamp( 0.5*(height1 + rd.y*d2 - terrain(ro.xz + d2*rd.xz)), 0.0, 1.0 );
    float s3 = clamp( 0.2*(height2 + rd.y*d3 - terrain(ro.xz + d3*rd.xz)), 0.0, 1.0 );
    return min( min( s1, s2 ), s3 );
}

// Function 1571
float calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w, in float tre)
{
    // bounding volume    
    #if 1
    float tp = (0.5-ro.y)/rd.y;
    if( tp>0.0 )
    {
        if( ro.y<0.5 ) tmax = min(tmax,tp);
        else tmin = max(tmin,tp);
	}
    #endif
    
    float t = tmin;
    float res = 1.0;
    for( int i=0; i<256; i++ )
    {
     	float h = map(ro + t*rd, 1.0, tre).x;
        res = min( res, h/(w*t) );
    	t += clamp(h, 0.002, 0.50);
        if( res<-1.0 || t>1.0 ) break;
    }
    res = max(res,-1.0);
    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);
}

// Function 1572
float calcAO(in vec3 pos, in vec3 nor)
{
	float sca = 2.0, occ = 0.0;
    for( int i=0; i<5; i++ ){
    
        float hr = 0.01 + float(i)*0.5/4.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 1573
vec3 RgbLight()
{
#if BERNIE_COLORS
	return vec3(1.7, 0.3, 0.1);
#elif HALLOWEEN_COLORS
	return vec3(1.7, 0.15, 0.0);
#else
	return vec3(2.0, 0.1, 0.1);
#endif
}

// Function 1574
float shadows(in vec3 ro, in vec3 rd){
    float t = 0.1;
    float res = 1.0;
    for( int i = 0; i < 32; i++ )
    {
		float h = map(ro + rd * t, false).x;
        res = min(res, 16.0 * h / t);
        t += clamp(h, 0.01, 0.10);
        if(t > 2.5 || h < THRESHOLD) break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 1575
float calcAO( in vec3 pos, in vec3 nor ){
	float ao = 0.0;

	vec3 v = normalize(vec3(0.7,0.5,0.2));
	for( int i=0; i<12; i++ )
	{
		float h = abs(sin(float(i)));
		vec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));
		ao += clamp( ObjDf(pos+nor*0.01+kv*h*0.2)*3.0, 0.0, 1.0 );
		v = v.yzx; if( (i&2)==2) v.yz *= -1.0;
	}
	ao /= 12.0;
	ao = ao + 2.0*ao*ao;
	return clamp( ao*2.5, 0.0, 1.0 );
}

// Function 1576
vec3 shade(vec3 ray_start, vec3 ray_dir)
{
    vec4 hit = trace(ray_start, ray_dir);
    
  	vec3 light_dir1 = normalize(vec3(1., 0.3, 1.));

   float ray_len;
   vec3 color;
   if (hit.w == 0.0) {
      ray_len = 1e16;
      color = vec3(.0);
   } else {
      vec3 dir = hit.xyz - ray_start;
      vec3 norm = dNormal(hit.xyz);
    
      float diffuse = max(0.0, dot(norm, light_dir1));
      diffuse = clamp(diffuse, 0.0, 1.);
      ray_len = distance(hit.xyz,ray_start);
   
      vec3 base_color = vec3(1.);

       color.rgb = max((diffuse)*base_color, vec3(0.))+.3;
   }
   return color;
}

// Function 1577
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.03 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.7 + 0.3 * sh;
}

// Function 1578
float shadow (in vec3 ro, in vec3 rd)
{
    float result = 1.;
    float t = .1;
    float ph = 1e10;
    for (int i = 0; i < 64; i++) {
        float h = map (ro + t * rd).x;
        if (h < .00001) return .0;
        float y = h*h/(2.*ph);
        float d = sqrt (h*h - y*y);
        result = min (result, 10.*d/max (.0, t - y));
        ph = h;
        t += h*.5;
    }

    return result;
}

// Function 1579
vec3 calcLighting(Hit scn, vec3 n) {
 
    float d = max(dot(n,LIGHT_DIR), 0.);
    d *= softshadow(scn.p + LIGHT_DIR * .01, LIGHT_DIR, 0.2, 20.);
    
    return vec3(1.) * d;
    
}

// Function 1580
vec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col, float t) 
{   

    
    vec3 lightPos=lp;
    vec3 hit = ro + rd * t;
    vec3 norm = GetNormal(hit);
    
    vec3 light = lightPos - hit;
    float lightDist = max(length(light), .001);
    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);
    light /= lightDist;
    
    float occ = occlusion(hit, norm);
    
    float dif = clamp(dot(norm, light), 0.0, 1.0);
    dif = pow(dif, 4.) * 2.;
    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);
    vec3 color = col * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;
    return color;
    
    
}

// Function 1581
float light(vec3 pos){
  return -pos.y+2.0;
}

// Function 1582
void lighting(inout vec3 col, vec3 pos, float distanc, vec3 rayDir, vec3 normal)
{
    vec3 light = normalize(vec3(1.0*cos(iTime*6.0),0.8,0.3));
    
    if (distanc < EPSILON)
    {       
        vec3 ObjMaterial = vec3(distfunc(pos).y,distfunc(pos).z,distfunc(pos).a);
        
        vec3 reflection = reflect( rayDir, normal );
        float ambient = (0.5 + 0.5*normal.y)*0.3 ;
        float diffuse = max(0.0, dot(normal,light));
        float specular = pow(clamp( dot( reflection, light ), 0.0, 1.0 ),16.0);
        float shadow = softshadow( pos, light, 0.02, 2.5 );
        
        //--------------------------------------------------------------------
        float back = clamp( dot( normal, normalize(vec3(-light.x,0.0,-light.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);
        float dome = smoothstep( -0.1, 0.1, reflection.y );
        float fre = pow( clamp(1.0+dot(normal,rayDir),0.0,1.0), 2.0 );
		//--------------------------------------------------------------------
        
        vec3 ilum = vec3(0.0);
        ilum += 1.20*diffuse*vec3(1.00,0.85,0.55)*shadow*ObjMaterial;
		ilum += 1.20*specular*vec3(1.00,0.85,0.55)*diffuse;
        ilum += 0.20*ambient*vec3(0.50,0.70,1.00);
        ilum += 0.15*dome*vec3(0.50,0.70,1.00)*softshadow( pos, reflection, 0.02, 2.5 );
        ilum += 0.30*back*vec3(0.25,0.25,0.25);
        ilum += 0.40*fre*vec3(1.00,1.00,1.00);
        

		col =ilum;
    }
    
    
}

// Function 1583
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
    	float h = map(ro + rd*t, false);
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1584
vec3 shade(vec3 origin, vec3 dir, float dist)
{
    vec3 outColor = vec3(1.0, 1.0, 1.0);
    
    vec3 pos = origin + dir*dist; // World position
    vec3 normal = calcNormalTex(pos); // Normal
    //return normal;
    
    vec3 _texSample = texture(iChannel0, pos.xy*TEXTURE_TILE_XY).xyz;
    vec3 diffColor = _texSample;
    //vec3 specColor = vec3(1.0, 1.0, 1.0);
    vec3 specColor = vec3(luminosity(_texSample));
    //vec3 specColor = vec3(dot(vec3(0.30, 0.59, 0.11),_texSample));
    
    float mouseDx = (iMouse.x/iResolution.x*2.0) - 1.0;
    float mouseDy = (iMouse.y/iResolution.y*2.0) - 1.0;
    vec3 lightPos = vec3(mouseDx * MOUSE_SENSITIVITY, mouseDy * MOUSE_SENSITIVITY, 500);
    vec3 diffLightCol = vec3(1.0, 1.0, 0.7);
    vec3 ambientColor = vec3(0.01, 0.01, 0.0);
    
    vec3 lightDir = normalize(lightPos - origin);
    
    vec3 reflectDir = normalize(lightDir + dir);
    
    //vec3 reflectDir = reflect(-lightDir, normal);
    float specAngle = max(dot(reflectDir, normal), 0.0);
    float specular = pow(specAngle, 24.0);
    
    float NdotL = clamp(dot(normal, lightDir), 0.0, 1.0);
    vec3 diffuse = diffLightCol * NdotL;
    
    outColor = ambientColor + (diffuse * diffColor) + (specular * specColor * 0.5);
    return outColor;
}

// Function 1585
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {
	float res = 1.0, h, t = mint;
    for( int i=0; i<20; i++ ) {
		h = DE( ro + rd*t ).x;
		res = min( res, k*h/t );
                if( res<0.0001 ) break;
		t += 0.02;
    }
    return clamp(res, 0., 1.);
}

// Function 1586
vec4 shadeDeathStar(Ray ray, Hit scene) {
 
    vec3 n  = normal(scene.p);
    vec3 ld = getSunDir();
    
    float d = .1 + (.9 * max(dot(ld,n), 0.));
    Ray sr  = Ray(scene.p + (ld * .1), ld);
   	Dist sd = raymarch(sr).dist;
    
    float u = asin(n.x) / PI * .5;
    float v = asin(n.y) / PI * .5;
    vec2 uv = vec2(u,v);
    
    vec4 tex = texture(iChannel1, uv * 4.);
   	float noise = (tex.x+tex.y+tex.z)/3.;
    
    tex = (texture(iChannel2, uv * 7.) + texture(iChannel2, uv * -7.))/2.;
    tex = vec4((tex.x+tex.y+tex.z)/3.);
    
    float bandWidth = .1;
    if(uv.y < (.5+bandWidth) && uv.y > (.5-bandWidth)) tex *= .5;
    
    vec3 sum = tex.xyz * d;
    sum += rgb(117., 111., 69.) * (noise < .85 ? 0. : noise);
 	return vec4(sum,1.);
    
}

// Function 1587
float shadow( in vec3 ro, in vec3 rd )
{
    float res = 0.0;
    
    float tmax = 12.0;
    
    float t = 0.001;
    for(int i=0; i<80; i++ )
    {
        float h = map(ro+rd*t);
        if( h<0.0001 || t>tmax) break;
        t += h;
    }

    if( t>tmax ) res = 1.0;
    
    return res;
}

// Function 1588
float softShadow(vec3 ro, vec3 rd, float tmin, float tmax)
{
	float res = 1.0;
    float t = tmin;
    for(int i = 0; i < 16; i++)
    {
		float h = getDist(ro + rd*t).dist;
        res = min(res, 1.0 * h/t);
        t += clamp(h, 0.02, .50);
        
        if (h < 0.001 || t > tmax)
            break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 1589
vec3 Shade(vec3 p, vec3 n)
{
  // point light
  const vec3 lightPos = vec3(5.0, 5.0, 5.0);
  const vec3 lightColor = vec3(0.3, 0.5, 0.8);

  vec3 c = 0.25*background(n);
  vec3 l = normalize(p-lightPos);

  // Not even Phong shading, use weighted cosine instead for smooth transitions
  float diff = 0.5*(1.0+dot(n, l));

  c += diff*lightColor;

  return c;
}

// Function 1590
float softShadows( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<64; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = map( pos );
        res = min( res, max(h,0.0)*164.0/t );
        if( res<0.001 ) break;
        t += h*0.5;
    }
    
    return res;
}

// Function 1591
float soft_shadow_march( in vec3 ro, in vec3 rd, float k)
{
    float res = 1.0;
    float t=0.01;//.0001*sin(PI*fract(iTime));
    float d;
    
    for(int i=0;i<STEPS;i++)
    {
        d = map(ro + rd*t).d;
        if( d < PRECISION )
            return 0.0;
        res = min( res, k*d/t );
        t += d;
    }
    return res;
}

// Function 1592
void calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {
    light.position = normalize(light.position);
    light.attenuation = 1.;
    
    // diffuse
  	float diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));
  	vec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;
  	// specular
  	float specularCoef = getSpecular(
        //light,
        surface,
        light.position,
        diffuseCoef,
        cameraPos
    );
  	vec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  

  	light.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);
    light.specular = specular;
}

// Function 1593
void sampleDirectLight( vec3 pos,
                       	vec3 normal,
                        float Xi1,
                        float Xi2, 
                       	out vec3 dir,
                       	out float pdf ) {
    float height = objects[0].params_[2] - objects[0].params_[1];
    float r = objects[0].params_[0];
    float pdfA;
    float d2;
    float aCosThere;
    float theta;
    float thetaPdf;
    float h;
    float hPdf;
    
    //convert position to object space
    pos = toVec3( objects[0].transform_inv_*vec4(pos, 1.0) );
    normal = toVec3( objects[0].transform_inv_*vec4(normal, 0.0) );
    
    if(samplingTechnique == SAMPLE_TOTAL_AREA){
        theta = Xi1*TWO_PI;
        thetaPdf = 1.0/TWO_PI;
        h = objects[0].params_[1] + Xi2*height;
        hPdf = 1.0/height;
        
        vec3 n = vec3(cos(theta), sin(theta), 0.0);
        vec3 p = n*r;
        p.z = h;
        dir = p - pos;
        d2 = dot(dir,dir);
        dir /= sqrt(d2);
        aCosThere = max(0.0,dot(-dir,n));

        pdfA = thetaPdf*hPdf*(1.0/r);
        pdf = PdfAtoW( pdfA, d2, aCosThere );
    } else {
        vec3 cylinderPos = vec3(0.0, 0.0, objects[0].params_[1]);
        vec3 cylinderVec = vec3(0.0, 0.0, 1.0);
        
        float dc_2 = dot(pos.xy,pos.xy);
        float dc = sqrt(dc_2);
        vec2 dirToPos = (-pos.xy)/dc;
        float alphaMax = acos(r/dc);
        float thetaMax = 0.5*PI - alphaMax;
        theta = mix(0.0,thetaMax, Xi1);
        float sinTheta = sin(theta);
        float sin2Theta = sinTheta*sinTheta;
        float cosTheta = sqrt(1.0-sin2Theta);
        
    	float ds = dc * cosTheta - sqrt(max(0.0, r*r - dc_2 * sin2Theta));
    	float cosAlpha = (dc * dc + r*r - ds*ds) / (2.0 * dc * r);
        
        float alpha = acos(cosAlpha);
        
        //convert alpha to global angle
        float baseAngle = atan(dirToPos.y,dirToPos.x) + PI;
        float sign;
        if(Xi2<0.5) {
            sign =  1.0;
            //normalize Xi
            Xi2 /= 0.5;
        } else {
            sign = -1.0;
            //normalize Xi
            Xi2 = (Xi2 - 0.5) / 0.5;
        }
        
        float alphaGlobal = baseAngle + alpha*sign;
       
        thetaPdf = 1.0/(2.0*thetaMax);// In angle measure
        thetaPdf = PdfWtoA(thetaPdf, ds, cos(alpha+theta));
        
        vec3 n = vec3(cos(alphaGlobal), sin(alphaGlobal), 0.0);
    	vec3 p = n*r;
        
        //Sampling h
        //We do equiangular sampling from shading point
        {
      		sampleLine( pos, normalize(normal), p, normalize(cylinderVec), height, Xi2, h, hPdf );
        }
        
        p.z = cylinderPos.z + h;
        dir = p - pos;
        d2 = dot(dir,dir);
        dir /= sqrt(d2);
        aCosThere = max(0.0,dot(-dir,n));

        pdfA = thetaPdf*hPdf;
        pdf = PdfAtoW( pdfA, d2, aCosThere );
    }
    
    //convert dir to world space
    dir = toVec3( objects[0].transform_*vec4(dir,0.0) );
}

// Function 1594
void ShadeMonolith(in vec3 nor, in vec3 rd, float delay, vec3 tint, out vec4 mate )
{
	float c = NoteAtt(iTime, delay);
    mate.xyz = c*vec3(tint);
    vec3 scol = vec3(0.9);
    float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0),32.0 ) );

    mate.xyz += spe*scol;
}

// Function 1595
float hardShadow (vec3 pos, vec3 light) {
    vec3 dir = normalize(light - pos);
    float maxt = length(light - pos);
    float t = .02;
    for (float i = 0.; i <= 1.; i += 1./30.) {
        float dist = map(pos + dir * t);
        if (dist < VOLUME) return 0.;
        t += dist;
        if (t >= maxt) break;
    }
    return 1.;
}

// Function 1596
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)
{          
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  vec3 reflectDir = reflect( rayDir, normal );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0/specSize);
  vec3 reflection = vec3(texture(iChannel3, reflectDir ).r*1.5);

  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );
  fre = mix( .03, 1.0, fre );   
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );

  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.998);

  float shadow = SoftShadow(shadowPos, sunPos);
  dif*=shadow;
  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );
  skyLight *= SoftShadow(shadowPos, reflectDir );

  vec3 lightTot = (vec3(0.2)*amb); 
  lightTot+=vec3(0.85)*dif;
  lightTot= mix(lightTot, reflection*max(0.3, shadow), fre );
  lightTot += 1.00*specLevel*dif;
  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);
  lightTot= mix(lightTot*.7, lightTot*1.2, fre );

  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);
  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );
  lightTot = mix( lightTot, lightTot+ vec3(1.6), fre );

  return lightTot*sunColor;
}

// Function 1597
float calcAO( in vec3 pos, in vec3 nor )
{
    AO_PASS = true;
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).dist;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1598
vec2 LightOrigin(int id)
{
	return texture(iChannel0,vec2(0, float(id))/iResolution.xy + hpo).yz;   
}

// Function 1599
float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, bool detail)
{
    float res = 1.0;
    float ph = 1e20;
    for( float t=mint; t<maxt; )
    {
        float h = sdf(ro + rd*t, detail);
        if( h<0.001 )
            return 0.0;
        float y = h*h/(2.5*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, k*d/max(0.001,t-y) );
        ph = h;
        t += h;
    }
    return res;
}

// Function 1600
vec3 GetSceneLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y/20.0, 0.0, 1.0);

  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  float fre = pow( 1.0-abs(dot( normal, rayDir )), 4.0 );
  fre = mix( .03, 1.0, fre );   

  vec3 reflection = vec3(1.0);
  vec3 lightTot = vec3(0.0);

  lightTot += 1.15*dif*vec3(1.00, 0.90, 0.85);
  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;    
  lightTot= mix(lightTot, reflection, fre );
  lightTot += 0.70*skylight*vec3(0.70, 0.70, 0.85);
  lightTot += 1.30*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*amb*vec3(0.80, 0.90, 0.95);  
  return clamp(lightTot, 0., 10.);
}

// Function 1601
vec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {
    n = normal(p,d,1.);
    vec3 lpos = vec3(.1,9,7);
    vec3 l = normalize(lpos-p);
    float diff = clamp(dot(n,l),0.,1.);
    vec3 clr = .5 + .4 *sin(m + vec3(2.5,1.5,.5));
    vec3 h = mix(vec3(0),clr,.45);
    if(m==14.) h=vec3(.416,.420,.506)*clamp((p.y*.1+.5),0.,1.);
    return h*diff;
}

// Function 1602
float shadow( in vec3 ro, in vec3 rd )
{
    float res = 0.0;
    
    float tmax = 10.0;
    
    float t = 0.001;
    for(int i=0; i<200; i++ )
    {
        float h = map(ro+rd*t);
        if( h<0.0001 || t>tmax) break;
        t += h;
    }

    if( t>tmax ) res = 1.0;
    
    return res;
}

// Function 1603
vec3 Shade(in Camera camera, in vec2 uv, in Ray ray, in vec3 norm, float depth, float shadow, float id)
{
    vec3 color = Sky(ray);
    
    if(depth < (FarClip * 0.9))
    {
        vec3 pos = ray.o + (ray.d * depth);
        float ao = 1.0 - AmbientOcclusion(camera, uv, pos, norm);
        
        color  = Texture(pos, norm, id);
        color *= Lighting(norm, ray.d, depth, shadow, pow(ao, 3.0), color.r * 22.0);
        
        color = CalcExpFog(color, pos, ray);
    }
    
    return pow(color, vec3(1.0 / 2.2));
}

// Function 1604
void InitLights(){
    pointLights[0].color = vec3(0.05, 0.1, 1.0)*3.;
    pointLights[0].position = vec3(0.0, 3.7, 3.7);
    pointLights[0].visibleDistance = 6.0;
    pointLights[0].decay = 1.0;
    
    pointLights[1].color = vec3(0.1, 0.2, 1.0)*3.;
    pointLights[1].position = vec3(0., 3.7, 4.9);
    pointLights[1].visibleDistance = 6.0;
    pointLights[1].decay = 1.0;
    
    pointLights[2].color = vec3(1.5, 0.9, 1.2)*50.;
    pointLights[2].position = vec3(0., 3.9, 6.5);
    pointLights[2].visibleDistance = 5.0;
    pointLights[2].decay = 2.0;
    
    pointLights[3].color = vec3(1.0, 1.0, 0.2)*50.;
    pointLights[3].position = vec3(-ROOM_WIDTH/2. - 0.2, DOOR_HANDLE, 3.3);
    pointLights[3].visibleDistance = 1.;
    pointLights[3].decay = 1.0;
    
    pointLights[4].color = vec3(1.2, 0.8, 1.0)*1.;
    pointLights[4].position = vec3(0., 0.6, 3.);
    pointLights[4].visibleDistance = 12.5;
    pointLights[4].decay = 10.0;
}

// Function 1605
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = .0;
    float sca = 8.;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 1.9*float(i)/5.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ -= (dd-hr)*sca;
        sca *= .95;
    }
    return clamp( 1. - 3.0*occ, 0.0, 1.0 );    
}

// Function 1606
vec3 blendSoftLight(vec3 base, vec3 blend) {
    vec3 s = step(0.5,blend);
    return s * (sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend)) + (1.-s)*(2.*base*blend+base*base*(1.0-2.0*blend));
}

// Function 1607
vec3 computeSpotLight( in vec3 surfaceAlbedo,
                       in vec3 surfaceNormal,
                       in float surfaceGloss,
                       in vec3 surfacePos,  
                       in vec3 lightCol,
                       in vec3 lightPos,
                       in float lightRadius )
{
    vec3 lightVec = lightPos - surfacePos;
    float contribution = 1.0 / max(dot(lightVec, lightVec) * 0.08 / (lightRadius * lightRadius), 1.0);
    
    return computeLighting(surfaceAlbedo, surfaceNormal, surfaceGloss, lightCol, normalize(lightVec), 0.066667 * surfaceGloss, 0.0) * contribution;
}

// Function 1608
vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh) {
    float d = max(dot(LIGHT_DIR,n),0.);
    float s = pow(max(dot(LIGHT_DIR,r),0.),sh);
    
    if(raymarch(p+LIGHT_DIR*SHADOW_BIAS,LIGHT_DIR,64).y >= 0.) {
        d = 0.;
        s = 0.;
    }
    
    return (col*d)+s;
}

// Function 1609
float softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )
    {
        float res = 1.0;
        float h = mint;
        for( int i=0; i < 100; i++ )
        {
            ro += rd * h;
            h = map(ro).x;
            if( h<0.01 )
                return 0.0;
            res = min( res, k*h );
            if (h > maxt)
                break;
        }

        return res;
    }

// Function 1610
vec3 shade(vec3 pos, vec3 nor, vec3 sur_col,
           vec3 lig_dir, vec3 lig_col,
           vec3 vie) {
	float ndotl = max(0.0, dot(nor,lig_dir));
    float vdotr = max(0.0, dot(vie,reflect(lig_dir,nor)));
    vec3 dif = sur_col * lig_col;
    vec3 spe = lig_col * vdotr*0.5;
    vec3 amb = sur_col*lig_col*0.03;
    
    float t = trace(pos,lig_dir, 0.1,5.0,50);
    float sdw = t > 0.0 ? 0.0 : 1.0;
    dif *= sdw;
    spe *= sdw;
    return sur_col;
    //return (dif+spe) * ndotl + amb;
    //return (nor+1.0)*0.5;
}

// Function 1611
float calcSoftShadow(vec3 ro, vec3 rd, bool showSphere )
{
    float res = 1.0;
    const float tmax = 2.0;
    float t = 0.001;
    for( int i=0; i<64; i++ )
    {
     	float h = map(ro + t*rd, showSphere).x;
        res = min( res, 64.0*h/t );
    	t += clamp(h, 0.01,0.5);
        if( res<-1.0 || t>tmax ) break;
        
    }
    res = max(res,-1.0);
    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]
}

// Function 1612
vec3 lightsTexture(vec2 uv){
    vec3 col = vec3(0.);
    vec2 auv = abs(uv-vec2(0.5));
    float f = 1.0-smoothstep(0.2,0.35,max(auv.x,auv.y));
    f = pow(f,2.);
    //col = mix(col, vec3(1.2,1.2,0.9), f);
    col = mix(col, vec3(0.95,0.95,1.), f);
    return col;
}

// Function 1613
float shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){

    float shade = 1.0;
    const int shadIter = 14; 

    float dist = start;
    //float stepDist = end/float(shadIter);

    for (int i=0; i<shadIter; i++){
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.

        dist += clamp(h, 2.32, 1.2);
        
        // There's some accuracy loss involved, but early exits from accumulative distance function can help.
        if ((h)<0.001 || dist > end) break; 
    }
    
    return min(max(shade, 0.) + 0.1, 1.0); 
}

// Function 1614
float ao(vec3 ro, vec3 rd, float kk)
{
    float k = 1.0;
    float d = 0.0;
    float occ = 0.0;
    for(int i = 0; i < 32; i++){
        d = mapScene(ro + 0.1 * k * rd).x;
        occ += 1.0 / pow(2.0, k) * (k * 0.1 - d);
        k += 1.0;
    }
    return 1.0 - clamp(kk * occ, 0.0, 1.0);
}

// Function 1615
void DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)
{
	float h = dot(sunLight,normal);
	mat = mat * (max(h, 0.0)+.2);
	// Specular...
	vec3 R = reflect(sunLight, normal);
    float fre = pow(1.0 + dot(normal, eyeDir), 2.0) * 5.0;
	float specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 20.0) * (.5+smoothstep(8.0, 0.0, pos.y)*4.0);
	mat = mix(mat, sunColour, specAmount*fre);
}

// Function 1616
float sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {
#ifdef SAMPLE_LIGHT_SOLIDANGLE
    float solidangle;
    vec3 w = sphere.pos - x;	//direction to light center
	float dc_2 = dot(w, w);		//squared distance to light center
    float dc = sqrt(dc_2);		//distance to light center
    
    if( dc_2 > sphere.radiusSq ) {
    	float sin_theta_max_2 = clamp( sphere.radiusSq / dc_2, 0.0, 1.0);
		float cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );
    	solidangle = TWO_PI * (1.0 - cos_theta_max);
    } else { 
    	solidangle = FOUR_PI;
    }
    
    return 1.0/solidangle;
#else
    float lightPdfA = 1.0/sphere.area;
    float cosTheta1 = max( 0.0, dot( n1, -wi ) );
    return PdfAtoW( lightPdfA, d*d, cosTheta1 );
#endif
}

// Function 1617
float calcAO( in vec3 pos, in vec3 nor )
{
    vec4 kk;
    float ao = 0.0;
    for( int i=0; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
        float h = hash1(float(i));
        ap *= sign( dot(ap,nor) ) * h*0.1;
        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );
    }
    ao /= 32.0;
    
    return clamp( ao*6.0, 0.0, 1.0 );
}

// Function 1618
float traceShadows(in vec3 pos, in mat4 viewMat)
{
    const vec3 lightPos = vec3(-0.8, -0.0, 0.0);
    vec3 p = pos;
    vec3 rd = (viewMat * vec4(normalize(lightPos - pos), 0.0)).xyz;
    float d = map(p);
    float dAcc = d;
    const float eps = epsilon * 10.0;
    bool hit = (d < eps || dAcc >= t_max);
    for(int i = 0; i < 64; i++)
    {
        if(hit)
            break;
        else
        {
            p += d * rd;
            d = map(p);
            dAcc += d;
            hit = (d < eps || dAcc >= t_max);
        }
    }
    return dAcc;
}

// Function 1619
float raymarchShadow(Ray ray)
{
    float shadow = 1.;
	float t = CAMERA_NEAR;
    vec3 p = vec3(0.);
    float h = 0.;
    for(int i = 0; i < 80; ++i)
	{
	    p = ray.origin + t * ray.direction;
        h = p.y - terrainFbm(p.xz, MQ_OCTAVES, iChannel0);
		shadow = min(shadow, 8. * h / t);
		t += h;
		if (shadow < 0.001 || p.z > CAMERA_FAR) break;
	}
	return SAT(shadow);
}

// Function 1620
float calcShadow(in vec3 ro, in vec3 rd )
{
	vec2  eps = vec2(150.0,0.0);
    float h1 = terrainMed( ro.xz );
    float h2 = terrainLow( ro.xz );
    
    float d1 = 10.0;
    float d2 = 80.0;
    float d3 = 200.0;
    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );
    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );
    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );

    return min(min(s1,s2),s3);
}

// Function 1621
vec4 shade_cell(vec3 ray_origin,
                vec3 ray_direction,
                vec3 cell_coords)
{

    vec3 lcol = tower_lightcolor(cell_coords.xz);
    float ang = .5 * g_time + 180. * tower_rotoffset(cell_coords.xz);

    float ca = cos(ang); float sa = sin(ang);
    mat3 rt = mat3(ca, 0., sa, 0., 1., 0.,-sa, 0., ca);
    mat3 rrt = mat3(ca, 0., -sa, 0., 1., 0.,sa, 0., ca);    
    
    vec3 rro = rt * ray_origin;
    vec3 rrd = rt * ray_direction;
    
    float hd = .1;
    vec4 p1r = vec4(0.), p2r = vec4(0.);
    intersect_tower(rro, rrd, hd, p1r, p2r);
    vec4 result = vec4(0.);
    
    shade_tower_side(rro, rrd, rrt, lcol, hd, cell_coords, p1r, result);
    shade_tower_side(rro, rrd, rrt, lcol, hd, cell_coords, p2r, result);
    
    return result;
}

// Function 1622
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.001 + 0.15*float(i)/4.0;
        float d = map( pos + h*nor );
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    
}

// Function 1623
vec3 GetSceneLight(float specLevel, vec3 normal, vec3 pos, vec3 rayDir)
{      
  vec3 light1 = normalize(vec3(-1.0, 2.8, 1.0));
    
  vec3 reflectDir = reflect( rayDir, normal );
  specLevel *= pow(clamp( dot( reflectDir, light1 ), 0.0, 1.0 ), 16.0);

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float diffuse = clamp( dot( normal, light1 ), 0.0, 1.0 );
  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );
  float fill = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 1.0 )*1.0;
  float backLight = clamp( dot( normal, normalize(vec3(-light1.x, 0.0, -light1.z))), 0.0, 1.0 )*5.0;

  diffuse *= SoftShadow( pos, light1);
  skyLight *= SoftShadow( pos, reflectDir);

  vec3 lightTot = 1.30*diffuse*vec3(1.00, 0.80, 0.55);
  lightTot += specLevel*vec3(1.00, 0.90, 0.70)*diffuse;
  lightTot += 0.40*amb*vec3(0.40, 0.60, 1.00);
  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);
  lightTot += 0.50*backLight*vec3(0.25, 0.25, 0.25);

  return lightTot+(0.25*fill*vec3(1.00, 1.00, 1.00));
}

// Function 1624
float lightPointDiffuseSpecularShadow(vec3 pos, vec3 lightPos, vec3 cameraPos, vec3 normal) {
	vec3 lightDir = normalize(lightPos - pos);
	float lightDist = length(lightPos - pos);
	float color = dot(normal, lightDir) / square(lightDist);
	if (color > 0.01) {
		vec3 cameraDir = normalize(cameraPos - pos);
		color += dot(cameraDir, lightDir);
		color *= castShadowRay(pos, lightPos, 0.001);
	}
	return max(0.0, color);
}

// Function 1625
float calculateAO(in vec3 p, in vec3 n)
{
	float sca = 2., occ = 0.0;
    for( int i=0; i<6; i++ ){
    
        float hr = .01 + float(i)*.5/5.;        
        float dd = map(p + hr*n);
        occ += (hr - dd)*sca;
        sca *= .7;
    }
    return clamp(1. - occ, 0., 1.);   
    
}

// Function 1626
vec3 sampleLight(
	vec2 uv,
	vec3 planeNormal,
	out vec3 lightPos,
	out float areaPdf)
{
	vec3 planeTangent = normalize(cross(planeNormal, vec3(0.0, 1.0, 0.0)));
	vec3 planeBitangent = normalize(cross(planeNormal, planeTangent));
	float x = 0.5 - uv.x;
	float y = uv.y - 0.5;
	lightPos = x*planeTangent + y*planeBitangent;
	return evaluateLight(uv, areaPdf);
}

// Function 1627
LightSample sampleLight(in vec3 p, in Light light)
{
    vec3 difference = light.p - p;
    float distance = length(difference);
    vec3 direction = difference / distance;
    
    float sinTheta = light.r / distance;
	float cosTheta = sqrt(1.0 - sinTheta * sinTheta);
    
    LightSample result;
    
    vec3 hemi = squareToUniformSphereCap(rand2(), cosTheta);
    result.pdf = squareToUniformSphereCapPdf(cosTheta);
    
    vec3 s = normalize(cross(direction, vec3(0.433, 0.433, 0.433)));
    vec3 t = cross(direction, s);
    
    result.d = (direction * hemi.z + s * hemi.x + t * hemi.y);
    return result;
}

// Function 1628
vec3 shade(vec3 origin, vec3 ray, float traced) {
   return normalize(grad(origin+traced*ray));
}

// Function 1629
vec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness)
{
    return computeLighting(posWS, rayDirWS, normalWS, roughness, 1.0, 1.0);
}

// Function 1630
vec3 GetLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  const vec3 sunColor = vec3(1.1, 0.53, 0.27); 
  vec3 reflectDir = reflect( rayDir, normal );
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );

  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  float fre = pow( 1.0-abs(dot( normal, rayDir )), 3.0 );
  fre = mix( .03, 1.0, fre );   

  const vec3 reflection = vec3(1.0);
  vec3 lightTot = vec3(0.0);

  lightTot += 3.*dif*sunColor;

  vec3 skyCol = GetSkyColor(reflectDir);

  lightTot += 0.5*amb*vec3(0.35, 0.45, 0.6);  
  lightTot += 0.70*skylight*skyCol;
  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);
  lightTot = mix( lightTot, lightTot+skyCol, fre );

  return clamp(lightTot, 0., 10.);
}

// Function 1631
vec3 skyDomeShade(vec3 angle) {
	return mix(vec3(1.71, 1.31, 0.83),skycol, pow(abs(angle.z), 0.5)) + pow(max(dot(angle, sundir),0.0),1500.0)*suncol*4.0;
}

// Function 1632
float softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) 
{
    float sh = 1.0;
    float t = mint;
    float h = 0.0;
    for(int i = 0; i < 19; i++) 
	{
        if(t > maxt) continue;
		orbitTrap = vec4(10.0);
        h = map(ro + rd * t);
        sh = min(sh, k * h / t);
        t += h;
    }
    return sh;
}

// Function 1633
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box, float border)
{
    fragColor.rgb *= mix(1.-shadow_box(fragCoord, box, border), 1., .5);
}

// Function 1634
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<16; i++)
    {
    	float h = map(ro + rd*t);
        res = min(res, 10.0*h/t + 0.02*float(i));
        t += 0.8*clamp(h, 0.01, 0.35);
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1635
float GetLightAttenuation(float distanceToLight)
{
    return 1.0 / pow(distanceToLight, LIGHT_ATTENUATION_FACTOR);
}

// Function 1636
float softShadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<45; i++ )
    {
        float h = map(ro + rd*t).x;
        res = min( res, k*h/t );
        t += h*STEP_REDUCTION;
    }
    return clamp(res,0.0,1.0);
}

// Function 1637
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<24; i++ )
    {
		float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.2 );
        if( res<0.004 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1638
float GetLight_Diffuse(vec4 p) {
    
    vec4 lightPos = vec4(0, 5, 6, 0);
    
    //Ray from the found scene position to the light position, normalized to [0,1]
    vec4 lightRay = normalize(lightPos-p);
    vec4 normalRay = GetNormal_Generic(p);
    
    //Dot product returns [-1:1], so cap negative numbers to 0
    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);
    return dif;
}

// Function 1639
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 2., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.2/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
    
}

// Function 1640
vec3 lightmap(in vec2 light) {
    light = 15. - light;
	if(load(_torch).r>0.5) light.t=13.;
    
    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   

}

// Function 1641
float shadowFast( vec3 ro, vec3 rd, float mint, float tmax )
{
	float res = 1.0;
    float t = mint;
    
    for( int i=0; i<16; i++ )
    {
		float h = world( ro + rd*t );
		res = min( res, 80.0*h/t );
        t += h;
        
        if( res<0.0001 || t>tmax ) break;
        
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1642
float getShadow(vec3 p, vec3 n, vec3 ld){
    p +=  2. * eps * n;
    float t=0.,d=far;
    for(int i=0;i<50;i++){
        t += (d=DE(p + t*ld));
        if (d<eps || t>3.) break;
    }
    return t<=3. ? 0.1 : 1. ;
}

// Function 1643
float softShadow(vec3 ro, vec3 lp, float k){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 32; 
    
    vec3 rd = (lp-ro); // Unnormalized direction ray.

    float shade = 1.0;
    float dist = 0.01;    
    float end = max(length(rd), 0.001);
    float stepDist = end/float(maxIterationsShad);
    
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        //dist += min(h, stepDist); // So many options here, and none are perfect: dist += min( h, 0.2 ), etc
        dist += clamp(h, .02, .25); // So many options here, and none are perfect: dist += min( h, 0.2 ), etc
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0. || dist > end) break; 
    }

    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me.
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 1644
float calcSoftshadow(vec3 ro, vec3 rd, float mint, float maxt) {
  float k = 32.;
  float res = 1.0;
  float ph = 1e20;
  for (float t=mint; t < maxt; ) {
    float h = scene(ro + rd * t).x;
    if (h < 0.001)
      return 0.0;
    float y = h * h / (2.0 * ph);
    float d = sqrt(h * h - y * y);
    res = min(res, k * d / max(0.0, t-y));
    ph = h;
    t += h;
  }
  return res;
}

// Function 1645
vec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){
    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model
    //https://renderman.pixar.com/view/cook-torrance-shader
    
    
    vec3 V = -trace.ray.direction;

    vec3 H = normalize(L + V);
    
    float NdotH = dot(trace.normal, H);
    float NdotV = dot(trace.normal, V);
    float VdotH = dot(V ,H );
    float NdotL = dot(trace.normal , L);
    
    float lambda  = 0.25;
    float F = pow(1.0 + NdotV, lambda);
    
    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));
    
    
   // Beckmann distribution D
    float alpha = 5.0*acos(NdotH);
    float gaussConstant = 1.0;
	float D = gaussConstant*exp(-(alpha*alpha));
    
    
    float c = 1.0;
    float specular = c *(F*D*G)/(PI*NdotL*NdotV);
    
    
    return specular * trace.material.color.specular * lightColor;
}

// Function 1646
vec3 GetExplosionLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );

  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y/20.0, 0.0, 1.0);

  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85);
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);
  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);

  return clamp(lightTot, 0., 10.);
}

// Function 1647
float evaluateBeckmannGeometryShadowingSingleSide(float nlDot, float roughness)
{
    // http://graphicrants.blogspot.jp/2013/08/specular-brdf-reference.html
    float lct = .5 / (roughness * sqrt(1. - nlDot * nlDot) + 0.00001);
    float lc = lct * nlDot;
    float a = 3.353 * lc + 2.181 * lc * lc; // not typo
    float b = 1. + 2.276 * lc + 2.577 * lc * lc;
    return a / b;
}

// Function 1648
vec3 Shade(vec3 color, vec3 n, vec3 v, vec3 l, float specFactor)
{
    float diff = pow(max(dot(n, l), 0.), 7.);
    vec3 refl = reflect(v, n);
    float spec = pow(max(dot(refl, l), 0.), 55.);
	return color*diff + vec3(1.)*spec*specFactor;
}

// Function 1649
vec2 ts_shadow_sample_ao( TrnSampler ts, sampler2D ch, vec3 x )
{
#if WITH_TRN_SHADOW
    vec4 lookup = ts_shadow_lookup( ts, ch, x );
    return vec2( ts_shadow_eval( lookup.xy, length(x) ), lookup.z );
#else
    return vec2(1);
#endif
}

// Function 1650
float Shadow( in vec3 p, in vec3 toLight )
{
    const float softness = 1.;
    toLight = toLight-p;
    float l = length(toLight);
    vec3 ray = toLight/l;
    float epsilon = .001;
    float t = shadowStartDistance;
    float h = 1.;
    float minh = 1e30;
    for ( int i=0; i < shadowLoopCount; i++ )
    {
        if ( h < epsilon || t > l )
            break;
        h = SDF(p+ray*t);
        minh = min(minh,h/max(t*softness,1.));
        t += h;
    }
    return smoothstep(epsilon,.03,minh);
}

// Function 1651
vec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal){
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    vec3  view = normalize(-rd);
    const vec3 lig1 = normalize(vec3(-5., 5., 5.));
	const vec3 lig2 = normalize(vec3(5., -5., 0.));
    
    float spc1 = gaussianSpecular(lig1, view, nor, 0.95)*0.5;
    float dif1 = max(0., orenNayarDiffuse(lig1, view, nor, -20.1, 1.0));
    vec3  col1 = vec3(2.,4.2,4.) * .75;
    lin += col1*spc1+dif1*col1;
    
    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);
    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));
    vec3  col2 = vec3(2., .05, .15) * 1.;
    lin += col2*spc2+dif2*col2;

    // ambient light
    //-----------------------------
    lin += vec3(0.05);

    
    // surface-light interacion
    //-----------------------------
    vec3 col = mal*lin;

    return col;
}

// Function 1652
float softshadow( in vec3 ro, in vec3 rd, float mint, float k )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<128; i++ )
    {
        float h = map(ro + rd*t).x;
        res = min( res, k*h/t );
        if( res<0.0001 ) break;
        t += clamp( h, 0.01, 0.5 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1653
float shade_specular(vec3 N, vec3 V, vec3 L, float roughness, float F0)
{
    vec3 H = normalize(-V+L);
    float LoH = clamp(dot(L,H),0.0,1.0);
    float NoH = clamp(dot(N,H),0.0,1.0);
    float NoL = clamp(dot(L,N),0.0,1.0);  
    
    float alpha = roughness*roughness;
	float D = ggx_d(NoH, alpha);
    vec2 fv = ggx_fv(LoH, alpha);
    float FV = F0*fv.x + (1.0-F0)*fv.y;
    //return D;
    return NoL*D*FV;
}

// Function 1654
float AO( in vec3 ro, in vec3 rd,bool A ) {
	float occ = 0.0;
    float sca = 1.0;
    
   for( int i=0; i<5; i++ ) {
        float h = 0.001 + 0.25*float(i)/4.0;
        float d = sdScene( ro+rd*h, A ).x;
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 1.2*occ, 0.0, 1.0 );    
}

// Function 1655
float calculateAO(vec3 p, vec3 n) {
    
    float r = 0., w = 1., d;
    
    for (float i = 1.; i <= AO_SAMPLES; i++){
        d = i / AO_SAMPLES / AO_RANGE;
        r += w * (d - map(p + n * d));
        w *= .5;
    }
    
    return 1.-saturate(r * AO_RANGE);
}

// Function 1656
vec3 shade( in vec4 p, in vec3 n, in vec3 org, in vec3 dir )
{		
	//wall color
	vec3 amb = vec3(.5);
	if(p.x<-9.999)
		amb = vec3(1.,0.,0.);
	else if(p.x>9.999)
		amb = vec3(.0,0.,1.);
	else
		amb = vec3(1);
		
	
	//computing GI and ambient occlusion with the surfels
	vec3 gi = vec3(0.);
	vec3 glossy = vec3(0.);
	float ao = 0.;
	for(int i=0; i<NBSURFEL; i++)
	{
		vec3 v = surfel[i].pos - p.xyz; // recever to emitter vector
		float d = length( v );
		v = normalize( v );
		
		float cosE = dot( -v, surfel[i].n );
		float cosR = dot( v, n );
		float cosR2 = dot( v, reflect(dir,n));
		
		gi += surfel[i].col * radiance( cosE, cosR, surfel[i].area, d);
		glossy += surfel[i].col * radiance( cosE, cosR2, surfel[i].area, d);
		
		ao += occ( cosE, cosR, surfel[i].area, d);
	}
    ao = exp(-ao)*ao;
	vec3 col = ( amb*ao + gi + glossy ) ;
	
	return col;
}

// Function 1657
float softshadow(inout Ray ray, float softness) {
    // While we're not past the target, do the stuff
    // Subtract EPSILON * 2 so we don't get close enough to the original object to trigger the shadow
    float penumbra = 1.0;
    while(distance(ray.origin, ray.position) < distance(ray.origin, ray.target) - EPSILON * 2.0) {
        // Get info about our position in relation to the map
        MapInfo mapInfo = map(ray.position);
        // If we hit something, make the color black (shadow)
        if(mapInfo.hit < EPSILON) return 0.0;

        #ifdef SOFT_SHADOWS
            penumbra = min(penumbra, softness * mapInfo.hit / distance(ray.position, ray.target));
        #endif

        if(mapInfo.hit > SHADOW_THRESHOLD) ray.position += ray.direction * mapInfo.hit;
        // Move a bit closer to the target
        else ray.position += ray.direction * SHADOW_THRESHOLD;
    }
    // If we don't hit anything, the point is not in shadow so the shadow multiplier is 1.0
    return penumbra;
}

// Function 1658
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{
    vec3 kk;
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<32; i++ )
    {
        float h = map(ro + rd*t, kk ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.05, 0.5 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1659
float ao(vec3 p, vec3 n)
{
    const float ao_it =4.;
    float d=0.;
    float sm =0.;
    for(float i=1.;i<ao_it;i++)
    {
        d+=.3;
        float h = map(p+d*n).x;
        sm+=(d-h)/pow(2.8,i);
    }
    return max(0.,1.-sm*4.);

}

// Function 1660
void lighting(inout vec3 r, inout vec3 a, Light l, Point p, vec3 n) {
    if(l.t == AMBIENT_LIGHT) {
        a += p.m.a[0] / PI * l.c.rgb * l.c.a;
        a = clamp(a, 0.0, 1.0);
    }
    else {
        LightPath lp =  lightPath(p, l, n);
        vec3 L;
        if(p.m.s[0] == LAMBERT_DIFFUSE)
            L = lambert(p.m, lp);
        else if(p.m.s[0] == ORENNAYAR_DIFFUSE)
            L = orennayar(p.m, lp);
        vec3 S;
        if(p.m.s[1] == PHONG_SPECULAR)
            L += phong(p.m, lp);
        if(length(L) > 0.0001) {
            Point sp = point();
            sp.r.b = p.p + lp.iray * 0.01;
            sp.r.d = lp.iray;
            trace(sp, 1.0);
            float sf = exm1_ex(sp.pu);
            sf = 1.0;
            if(sp.l < lp.ilen)
                sf = 0.0;
            L *= sf;
        }
        r = clamp(r + L, 0.0, 1.0);
    }
}

// Function 1661
float calcShadow(vec3 origin, vec3 lightOrigin) {
    float s = 1.0;
    
    vec3 rayDir = normalize(lightOrigin - origin);
    float d = 0.1;
    while (d < 10.0 && s > 0.0) {
        float distToObj = map(origin + rayDir * d).x;
        s = min(s, distToObj / d);
        d += clamp(distToObj, 0.2, 1.0);
    }
    
    return smoothstep(0.0, 1.0, s);
}

// Function 1662
vec3 computeLight(vec3 pos, vec3 color, vec3 normal, Light light[COUNT_LIGHT], Cube cube) 
{
    
    vec3 summ = vec3(0, 0, 0);
    
    for (int i = 0; i < COUNT_LIGHT; i++)
    {
        vec3 toLight = light[i].pos - pos;
        float distSq = dot(toLight, toLight);
        float att =  isOccluded(pos, light[i].pos + randDir * light[i].radius, cube) ? 0.0 : light[i].brightness / distSq; //isOccluded(pos, light[i].pos + randDir * light[i].radius, cube) ? 0.0 :
        summ = summ + max(0.0, dot(normal, normalize(toLight))) * att * light[i].color;
    }
    
    return color * (summ  + texture(iChannel1, normal).rgb * 0.3);
    
}

// Function 1663
float castShadow(in Ray ray, float dist){
    Trace trace = castRay(ray,dist);
    float maxDist = min(1.0,dist);
    float result = trace.dist/maxDist;
   
    return clamp(result,0.0,1.0);
}

// Function 1664
vec3 shadeTree(vec3 p, vec3 ray) {
    vec3  col = vec3(0.12, 0.7, 0.08)*0.3;
    vec3 n = getNormal(shapeTree, p);
    col += mix(col, vec3(0.9), fbm(p*40., 1., 3));
    
    col *= col;
    return col;
}

// Function 1665
vec3 calculateStarlightVisibility(vec3 ray, const vec4 nebula, float startingOpticalDepth, float distFromCenter) {
    const int   samples  = 15;
          float stepSize = (nebula.a * 2.0) / float(samples);
   	
    float dirSwitch = -1.0;
    if (ray.y > nebula.y) dirSwitch = 1.0;

    vec3 centralRay   = ray - nebula.xyz; //centralize ray on star
    vec3 rayDirection = -normalize(centralRay) * stepSize;
         ray         += rayDirection * 0.5;

    float opticalDepth = -startingOpticalDepth;

    for (int i = 0; i < samples; i++, ray += rayDirection) {
        opticalDepth -= getNebulaVolume(ray, distFromCenter);
    }
    
    return exp(nebulaCoeff * stepSize * opticalDepth);
}

// Function 1666
float castShadowRay( in vec3 ro, in vec3 rd, out vec3 oVos )
{

	vec3 pos = floor(ro);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	vec3 ris = ri*rs;
	
	float res = 1.0;

    // detailed raymarching
    
    for( int i=0; i<DETAIL_INTER; i++ ) 
	{
		if( map(pos)>0.5 && i>0 )
		{
            float id = hash1( pos );
            vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
            float t = max ( mini.x, max ( mini.y, mini.z ) );
            float h = 0.0;
            vec3 ce = pos + 0.5;
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            if( h<0.001 )
            {
                return 0.0;
                res=0.0; 
                break; 
			}
		}
		vec3 mi = step( dis.xyz, dis.yzx ); 
		vec3 mm = mi*(1.0-mi.zxy);
		dis += mm * ris;
        pos += mm * rs;
	}
	

    // coarse raymarching

	for( int i=0; i<(16-DETAIL_INTER); i++ ) 
	{
		if( map(pos)>0.5 && i>0 )
		{
            res=0.0; 
            break; 
		}
		vec3 mi = step( dis.xyz, dis.yzx ); 
		vec3 mm = mi*(1.0-mi.zxy);
		dis += mm * ris;
        pos += mm * rs;
	}
	
	oVos = pos;
	
	return res;
}

// Function 1667
void computeLighting(
    in int matId,
    in vec3 lightColor,
    in vec3 texColor,
    in vec3 nvNormal,
    in vec3 nvFragToLight,
    in vec3 nvFragToCam,
    out vec3 litColor
) {
    float ambientCoefficient = 0.0;
    float diffuseCoefficient = 0.0;
    float specularCoefficient = 0.0;
    float specularExponent = 1.0;
    switch(matId) {
        case MAT_PILLAR: {
            ambientCoefficient = 0.0;
            diffuseCoefficient = 0.9;
            specularCoefficient = 0.9;
            specularExponent = 20.0;
            break;
        }
        case MAT_TERRAIN: {
            ambientCoefficient = 0.0;
            diffuseCoefficient = 0.9;
            specularCoefficient = 0.15;
            specularExponent = 10.0;
            break;
        }
        case MAT_WATER: {
            ambientCoefficient = 0.3;
            diffuseCoefficient = 0.5;
            specularCoefficient = 0.6;
            specularExponent = 50.0;
            break;
        }
    }

    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));
    valDiffuse *= diffuseCoefficient;

    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);
    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);
    valSpecular *= specularCoefficient;

    litColor = clamp((ambientCoefficient+valDiffuse)*texColor*lightColor + valSpecular*lightColor, 0.0, 1.0);
}

// Function 1668
vec3 shade(vec3 color, vec3 point, vec3 normal,vec3 rd)
{
	
	vec3 dtl       = normalize(light_1 - point);
	float diffuse  = dot(dtl, normal); //diffuse
	float specular = 0.75 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 64.0); //specular
	vec3 c = (diffuse + specular) * color * 0.85;
	
	dtl      =  normalize(light_2 - point);
	diffuse  = dot(dtl, normal); //more diffuse
	specular = 0.9 * pow(max(dot(reflect(dtl, normal), rd), 0.0), 128.0); //more specular
	return clamp( c + (diffuse + specular) * 0.25 * color, 0.0, 1.0);
}

// Function 1669
vec3 Shade( ShadeData s )
{
	float foliage = Foliage(s.pos);
	float water = Water(s.pos);
	float solid = Solid(s.pos);
	float lights = Lights(s.pos);
	float dist = min(min(min(foliage, water),solid),lights);
	
	if ( lights == dist )
		return ShadeLights(s);
	
#if (0) // test lighting
	return DiffuseLight(s)*.8;
#else
	else if ( foliage == dist )
		return ShadeFoliage(s);
	else if ( water == dist )
		return ShadeWater(s);
	else
		return ShadeSolid(s);
#endif
}

// Function 1670
vec3 EnvLights(ray r, float t, float roadWith){

    float side = step(r.d.x, 0.);//x<0 return 0,x>0,return 1;
    r.d.x = abs(r.d.x);
    const float s = 1./ 4.5;//s has to be a constant, represent a quantity
    
    vec3 c = vec3(0.);
    
    float m = 0.;
    for(float i = 0.;i< 1.;i += s){
        float ti = fract(t + i + side*s*.5 );//let two side have different velocities;
        vec4 n = N14(i + side*100.);// make different
        
        float fade = ti*ti*ti;
        
        float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;// make the shop light blink
        
        fade = occlusion;
        
        float x = mix(2.5, 10., n.x);
        float y = mix(.1, 1.5, n.y);
        vec3 p = vec3(roadWith + x ,y , 70.- ti*70.);//light start point  is 50
        
        vec3 col = n.wzy;
            
        c += Bokeh(r, p, .05, .1)*fade*col*.5;//x^n can make curve flatter;
    }
    
    
    return  c;
}

// Function 1671
float shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = .1;
	float h;
	
    for (int i = 0; i < 15; i++)
	{
        vec3 p =  ro + rd*t;

		h = de(p).x;
		res = min(6.*h / t, res);
		t += h;
	}
    //res += t*t*.08; // Dim over distance
    return clamp(res, .1, 1.0);
}

// Function 1672
float getAO(in vec3 hitp, in vec3 normal)
{
    float dist = 0.02;
    vec3 spos = hitp + normal * dist;
    float sdist = map(spos);
    return clamp(sdist / dist, 0.0, 1.0);
}

// Function 1673
vec3 calcDiffuseLight(Object o, Light l, vec3 pos)
{
    vec3 dir = normalize(l.pos - pos);
    float val = clamp(dot(o.normal, dir), 0.0, 1.0);
    float oVal = val;
    //val = round(val/0.33);
    //val = smoothRound(val, 0.33, 0.05);
    //val *= 0.33;
    
    vec3 col = (o.color) * l.intensity * l.color * val * o.difVal;   
    //col = colQuant(3.0, col);
    return col;
}

// Function 1674
float ShadAO(in vec3 ro, in vec3 rd){
 float t=0.01*rnd,s=1.0,d,mn=0.01;
 for(int i=0;i<12;i++){
  d=max(DE(ro+rd*t)*1.5,mn);
  s=min(s,d/t+t*0.5);
  t+=d;
 }
 return s;
}

// Function 1675
Sphere GetLightSphere( int lightId ) {
    return spherelight[lightId];
}

// Function 1676
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 58; 
    
    vec3 rd = lp-ro; // Unnormalized direction ray.

    float shade = 2.;
    float dist = .0035*(t*.225 + 2.);  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0002);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.1, 2.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        dist += clamp(h, .08, .6); 
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.1 || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)
    return min(max(shade, 1.) + .25, 2.); 
}

// Function 1677
float GrndSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  float sh, d, h;
  sh = 1.;
  d = 2.;
  for (int i = 0; i < 10; i++) {
    p = ro + rd * d;
    h = p.y - GrndHt (p.xz);
    sh = min (sh, 20. * h / d);
    d += 4.;
    if (h < 0.01) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 1678
vec3 LMT_BlueLightArtifactFix( vec3 aces)
{
mat3 correctionMatrix = mat3(
vec3(0.9404372683, 0.0083786969, 0.0005471261 ),
vec3(-0.0183068787, 0.8286599939, -0.0008833746 ),
vec3( 0.0778696104, 0.1629613092, 1.0003362486 ) );
vec3 acesMod = correctionMatrix * aces;
return acesMod;
}

// Function 1679
float raymarchGateShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    float breakOut = 0.0;
    int i = 0;
    while (i < 80 && breakOut != 1.0) {
        vec3 p = ro + rd * t;
        float d = map(p, false).y;
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            breakOut = 1.0;
        i++;
    }
    return sh;
}

// Function 1680
vec3 lightmap_to_world(vec2 fragCoord, int plane_index)
{
    fragCoord += get_lightmap_offset(plane_index);
    vec4 plane = get_plane(plane_index);
    return uv_unmap(fragCoord * LIGHTMAP_SCALE, plane) + plane.xyz * LIGHTMAP_HEIGHT_OFFSET;
}

// Function 1681
vec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)
{
	vec3 p = ro + rd * d;												// surface point
	float sb = SubDensity(p, 0.001, 0.1);							// deep subdensity (10 iterations)
	vec3 bb = blackbody(100.*sb+100.);								// blackbody color according to the subdensity value
	vec3 ld = normalize(lp-p); 											// light dir
	vec3 n = nor(p, .01);												// normal at surface point
	n = doBumpMap(iChannel0, -p*0.5, n, 0.015);					// use bumpmap fnc of shane here
	vec3 refl = reflect(rd,n);											// reflected ray dir at surf point 
	float amb = 0.08; 													// ambiance factor
	float diff = clamp( dot( n, ld ), 0.0, 1.0 ); 					// diffuse
	float fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); 		// fresnel
	float spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);		// specular
	float sss = 1. - SubDensity(p*0.1, 5.) * 0.5; 					// one step sub density of df
    return vec4(															// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do
        (diff + fre + bb.x * sss) * amb + diff * 0.5, 
        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05	
    );
}

// Function 1682
void shade_tower_side(vec3 rro, 
                      vec3 rrd, 
                      mat3 rrt, 
                      vec3 lcol,
                      float hd,
                      vec3 cell_coords,
                      vec4 pr, 
                      inout vec4 scene_col)
{
    if (pr.x > .05)
    {
    vec3 hp = rro + rrd * pr.y;
    hp.y = -abs(hp.y);

    vec3 lpos = tower_lightpos(cell_coords.xz, lcol);
    float fo = max(0., 1. - .08 * length(lpos - hp)); fo *= fo;
    vec3 n = vec3(pr.z, 0., pr.w); 
    vec3 l = normalize(hp - lpos);
    vec3 r = refract(rrd, n, .5);
    vec3 fr = fresnel(rrd, n, .3);

    // glow
    float glow = 15. * (1. - fr.r) * smoothstep(.1, .0, abs(hp.y - lpos.y)) + .08 * fo;        

    // ambient
    float amb = .05 + .1 * pow(smoothstep(.0, .1, min(abs(hp.x),abs(hp.z))), 4.);        

    // transmissive
    float trans = 20. * fo * (1. - fr.r) * pow(max(0., dot(l, -r)), 2.);

    // diffuse 
    float diff = 10.8 * fo * max(0., abs(dot(l, n)));

    // depth
    vec2 pn = -sign(rrd.xz);
    vec2 ddn = rrd.xz * pn;
    vec2 po = hd * -pn;
    vec2 t = -(pn * (hp.xz - po))/ddn;
    float depth = max(0., min(t.x, t.y));

    // depth glow
    float depth_glow = .5 * min(3., .5 * depth);

    // neighbors bounce 
    vec3 ghp = g_cellsize * vec3(cell_coords.x + .5, 0., cell_coords.z + .5) + rrt * hp;
    vec3 gn  = rrt * n;
    vec3 neighbors = 1.5 * neighbors_diffuse(ghp, gn, cell_coords);

    // darken with depth
    float darken = exp(-.2 * pr.y);
    float alpha = pr.x * mix(.2, 1., .2 * depth);

    // add it all up
    scene_col.rgb += (1. - scene_col.a) * alpha * darken * (neighbors + lcol * (depth_glow + trans + diff + glow + amb));

    // depth attenuated opacity
    scene_col.a += (1. - scene_col.a) * alpha;
    }

}

// Function 1683
vec3 computeEnlighting( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir ) {

	cameraDir += perturb3(cameraDir,.06,1.5);
	// position of I : point at the surface of the sphere
	float a = dot(cameraDir,cameraDir);
	float b = 2.0*dot(cameraDir,cameraPos);
	float c = dot(cameraPos,cameraPos) - rad*rad;
	float delta = b*b-4.0*a*c;
		
	if (delta <= 0.0)
		return skyColor;
		
	float d1 = (-b + sqrt(delta))/(2.0*a);
	float d2 = (-b - sqrt(delta))/(2.0*a);
	
	vec3 posI = cameraPos + d1 * cameraDir;
	vec3 posIprim = cameraPos + d2 * cameraDir;
	float d3 = length(posI-posIprim); // length of the path without scattering
	
	// normal of the plane containing the camera & the light
	vec3 n = cross(-lightDir,-cameraDir);
	n = normalize(n);	
	
	float d = dot(posI,n); // distance plane - center of the sphere
	vec3 C = n*d; // center of the circle
	float r = clamp(length(posI-C),0.001,rad-0.001); // radius of the circle
	
	float theta = acos(clamp(dot(normalize(cameraDir),normalize(C-posI)),-1.,1.));
	float y = r*sin(theta);
	
	// projection of lightDir
	float IPS = acos(clamp(dot(normalize(-cameraDir),normalize(lightDir)),-1.,1.));
	
	vec2 L = vec2(-cos(IPS),sin(IPS));

	// check the orientation
	if (dot(cross(cameraDir,-lightDir),cross(cameraDir,normalize(posI-C))) > 0.0) {
		L.y = -L.y;
	}
	
	// rayleigh diffusion function
	float rayleigh = cos(IPS)*cos(IPS)+1.0; 

	vec3 transmittance = sphericalTransmittanceGradient(L, r, r-y,length(C))*rayleigh;
	transmittance *= sunColor;
	transmittance += exp(-computeMeanDensRay(y, length(C), r))*skyColor; 
	return transmittance;
}

// Function 1684
function SetShaderConstant4F(u,x){m.uniform4fv(m.getUniformLocation(sB.mProgram,u),new int32Array(x));}

// Function 1685
float softShadow(in vec3 pos, in vec3 ld, in float ll, float mint, float k)
{
  const float minShadow = 0.25;
  float res = 1.0;
  float t = mint;
  vec3 col;
  float ref;
  float trans;
  vec3 absorb;
  for (int i=0; i<24; i++)
  {
    float distance = distanceField(pos + ld*t, col, ref, trans, absorb);
    res = min(res, k*distance/t);
    if (ll <= t) break;
    if(res <= minShadow) break;
    t += max(mint*0.2, distance);
  }
  return clamp(res,minShadow,1.0);
}

// Function 1686
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = 0.1;
    float ph = 0.0;
    for( int i=0; i<32; i++ )
    {
		if( t<maxt )
		{
            float h = map( ro + rd*t ).x;			
                        
            float y = h*h/(2.0*ph);
            float d = sqrt(h*h-y*y);
            res = min( res, 10.0*d/max(0.0,t-y) );
            ph = h;
            
            t += 0.005+h;
		} 
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1687
vec3 calcLight(Light lights[LIGHTS_NUM], vec3 pos, vec3 color, vec3 normal) 
{
    vec3 sum = vec3(0.0);
    
    for (int i = 0; i < LIGHTS_NUM; i++) {
        Light light = lights[i];
        vec3 dist = light.pos - pos;
        float distSq = dot(dist, dist);
        float att = light.attBase / distSq;
        sum += max(0.0, dot(normal, normalize(dist))) * light.color * att;
    }
    
    return color * sum;
}

// Function 1688
vec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {
    const vec3 sunPos = vec3(9.0, 9.0, -9.0);
    vec3 sunDir = normalize(sunPos - p), n = calcNormal(p, d);
    // Primary light.
    float primary = max(-0.1, dot(sunDir, n)),
    // Secondary(/bounce) light.
    bounce = max(-0.1, dot(-sunDir, n)) * 0.1,
    // Specular.
    spe = pow(max(-0.1, dot(rd, reflect(sunDir, n))), data.specPower) * 1.0,
	// Fresnel
    fre = smoothstep(0.6, 0.9, 0.9 + dot(rd, n)),
    // Fog
    fog = exp(-length(p) * 0.04);
    // Combine.
    primary *= mix(0.1, 0.9, calcShadow(p, sunPos));
    vec3 lig = ((primary + bounce) * ao(p, n, 0.23) + spe) * vec3(1.0, 0.6, 0.7);
    return mix(data.mat * lig, vec3(0.009), fre) * fog;
}

// Function 1689
Dst dstLightpole(vec3 p, vec3 pos) {
    
    float rep = 4.;
    p.z = mod(p.z, rep) - rep * .5;
    
    vec3 r = pos - p;
    vec2 d = abs(vec2(length(r.xz),r.y)) - vec2(.1,.75);
 	float dst = min(max(d.x,d.y),0.0) + length(max(d,0.0));
    
    vec2 q = vec2( length(r.xz), r.y + .6 );
    vec3 c = vec3(.4,.4,.3);
    vec2 v = vec2( c.z*c.y/c.x, -c.z );
    vec2 w = v - q;
    vec2 vv = vec2( dot(v,v), v.x*v.x );
    vec2 qv = vec2( dot(v,w), v.x*w.x );
    d = max(qv,0.0)*qv/vv;
   	dst = min(sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y)), dst);
    
    return Dst(dst, 0);
    
}

// Function 1690
float getao(vec3 p, vec3 n, float dist) {
  return clamp(map(p+n*dist)/dist, 0.0, 1.0);
}

// Function 1691
float renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {
    // intersect plane
    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );
    
    if( d > 0. ) {
	    vec3 intersection = ro + rd*d;
        float l = length(intersection.xy);
        
        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {
            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));
        } else {
            return 0.;
        }
    } else {
	    return 0.;
    }
}

// Function 1692
float calcAO( in vec3 pos, in vec3 nor )
{
	float off = 0.0;//0.1*dot( fragCoord.xy, vec2(1.2,5.3) );
	float totao = 0.0;
    for( int i=ZERO; i<20; i++ )
    {
		vec4 kk;
		vec3 aopos = -1.0+2.0*hash3(float(i)*213.47 + off);
		aopos = aopos*aopos*aopos;
		aopos *= sign( dot(aopos,nor) );
        totao += clamp( map( pos + nor*0.015 + 0.15*aopos, kk )*48.0, 0.0, 1.0 );
    }
	totao /= 20.0;
	
    return clamp( totao*totao*1.0, 0.0, 1.0 );
}

// Function 1693
vec3 GetLightPos()
{
    return vCandlestickPos + vec3(0.0, fCandleTop + 0.35, 0.0) - GetFlameWander() * 0.01;
}

// Function 1694
float shadow(in vec3 p, in vec3 rd) { return castRay(p+rd*.001, rd, 1000.).y >= 0. ? 0. : 1.; }

// Function 1695
vec3 light(vec2 uv, float BUMP, float SRC_DIST, vec2 dxy, float iTime, inout vec3 avd) {
    vec3 sp = vec3(uv-0.5, 0);
    vec3 light = vec3(cos(iTime/20.0)*01.5, sin(iTime/20.0)*0.5, -SRC_DIST);
    vec3 ld = light - sp;
    float lDist = max(length(ld), 0.01);
    ld /= lDist;
    avd = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));
    return ld;
}

// Function 1696
vec3 cloudLighting(vec3 p, float den) {
	vec3 n = cloudNormal(p),
	     col = vec3(2, 1.6, 1.4) * (1. + flash);
	return min(.75, den) * max(.1, dot(normalize(vec3(6, 10, -4) - p), n)) * cloudAo(p, n, 1.) * col;
}

// Function 1697
float Light_GIV( float dotNV, float k)
{
	return 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);
}

// Function 1698
float calcSoftShadow( vec3 ro, vec3 rd )
{
    float res = 1.0;
    const float tmax = 2.0;
    float t = 0.001;
    for( int i=0; i<64; i++ )
    {
     	float h = map(ro + t*rd).x;
        res = min( res, 64.0*h/t );
    	t += clamp(h, 0.01,0.5);
        if( res<-1.0 || t>tmax ) break;
        
    }
    res = max(res,-1.0);
    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]
}

// Function 1699
vec3 shade(float inLight, float n_h, float n_l, float n_v, float v_h, vec3 dif_tex)
{
  	return  one_pi * inLight * ( n_l * rho_d * dif_tex	
	+ rho_s * D(alpha, p, n_h, K_ap) * G1(n_l) * G1 (n_v) * Fresnel(F_0, F_1, v_h));
}

// Function 1700
float GetLight_PDF(in Intersection intersecNow,in Intersection intersecNext){
	float pdf = 0.;
    if(intersecNext.type == LIGHT){
        vec3 v0v1 = quads[0].v1 - quads[0].v0;
    	vec3 v0v3 = quads[0].v3 - quads[0].v0;
    	float width  = length(v0v1);
    	float height = length(v0v3);
        vec3 lDir = intersecNext.surface - intersecNow.surface;
        float dist = length(lDir);
        float costhe = dot(-lDir,quads[0].normal);
        pdf = PDF_Area2Angle(1./(width*height),dist,costhe);
    }
    return pdf;
}

// Function 1701
vec2 ShadowAndAmbient(in vec3 ro, in vec3 rd) {
    vec3 p0 = vec3(0.0), p1 = vec3(0.0);
    
    IRayAABox(ro, rd, 1.0/rd, scmin, scmax, p0, p1);
    
    if (length(ro - p1) < 0.01) return vec2(1.0);
    
    p0 = ro + rd*0.01;
    vec2 dir = normalize(rd.xz);
    float s = rd.y / length(rd.xz);
    
    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);
    voronoi_s(p0.xz*2.0, n, f, mg, mr);
    
    float h = map(n + mg);
    
    float a = voronoi_ao(ro.y, n, f, mg);
    vec3 dn = voronoi_n(dir, n, f, mg, mr);
    
    float rh = 0.0, prh = p0.y;
    
  	float dmax = length(p0.xz - p1.xz);
	float mh = 1.0;
    
    const int steps = 8;
    for (int i = steps; i > 0; --i) {
        dn.x *= 0.5;
        rh = p0.y + dn.x*s;
       
        if (dn.x > dmax || h > prh || h > rh) break; 
        
        prh = rh;
       
        h = map(n + mg);
        
        mh = min(mh, 14.0*(rh-h)/(dn.x*s));
        
        dn = voronoi_n(dir, n, f, mg, mr);
    }
    
    if (h > prh || h > rh) return vec2(0.0, a);
    
    return vec2(clamp(mh, 0.0, 1.0), a);
}

// Function 1702
float calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {
  float res = 1.0;
  float t = mint;
  for (int i = 0; i < 16; i++) {
    float h = map(ro + rd * t).x;
    res = min(res, 8.0 * h / t);
    t += clamp(h, 0.02, 0.10);
    if (h < 0.001 || t > tmax) break;
  }
  return clamp(res, 0.0, 1.0);
}

// Function 1703
vec4 shade(vec3 ro, vec3 rd) {
    
    // raytrace
    vec4 res = sphere(ro, rd, vec3(0), 1.0);
    
    // if miss sphere, gray background
    if (res.w < 0.) { return vec4(vec3(0.85), 1); }
    
    // get intersection point on sphere
    vec3 p = res.xyz;

    // render on sphere
    vec3 color = draw(p);
    
    // goofy non realistic lighting
    color *= 0.3*dot(p, L) + 0.7;

    return vec4(color, 1);
    
}

// Function 1704
vec3 get_light(vec3 raydir, vec3 p, Hit hit) {
    vec3 diffuse = vec3(0.0);
    vec3 specular = vec3(0.0);
    vec3 normal = get_normal(p);
    float occlusion = get_occlusion(p, normal);

    // sun light
    const float SUN_INTENSITY = 1.0;
    const float SUN_SHINESS = 10.0;
    const vec3 SUN_DIRECTION = normalize(vec3(-1.0,0.1,0.1));
    const vec3 SUN_COLOR = vec3(0.60,0.70,1.00);

    float sun_diffuse = clamp(dot(normal, SUN_DIRECTION), 0.0, 1.0);
    float sun_shadow = hard_shadow(p, SUN_DIRECTION, 0.01, 20.0);
    float sun_specular = pow(clamp(dot(reflect(SUN_DIRECTION, normal), raydir), 0.0, 1.0), SUN_SHINESS);

    diffuse += SUN_COLOR * (sun_diffuse * sun_shadow * SUN_INTENSITY);
    specular += SUN_COLOR * sun_specular;

    // sky light
    const float SKY_INTENSITY = 1.0;
    const float SKY_SHINESS = 30.0;
    const float SKY_BIAS = 0.0;
    const vec3 SKY_COLOR = vec3(0.60,0.70,1.00);
    const vec3 SKY_DIRECTION = normalize(vec3(-1.0,0.1,0.5));

    float sky_diffuse = SKY_BIAS + (1.0 - SKY_BIAS)*clamp(dot(normal, SKY_DIRECTION), 0.0, 1.0);
    float sky_specular = pow(clamp(dot(reflect(SKY_DIRECTION, normal), raydir), 0.0, 1.0), SKY_SHINESS);
    diffuse += SKY_COLOR * (SKY_INTENSITY * sky_diffuse * occlusion);
    specular += SKY_COLOR * (sky_specular * occlusion);

    // apply material
    vec3 col = diffuse * get_material_diffuse(p, hit) +
               specular * get_material_specular(p, hit);

    // gamma correction
    col = pow(col, vec3(0.4545));
    return col;
}

// Function 1705
bool getLightPulse()
{
    return texture(iChannel2, vec2(2.5, 0.5) / iResolution.xy).y < 0.5;
}

// Function 1706
float MarchShadow(vec2 orig, vec2 dir)
{
    float d = 0.0;
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float ds = Scene(dir * d - orig);
        
        d += ds;
        
        if(ds < EPS)
        {
        	break;   
        }
    }
    
    return d;
}

// Function 1707
float calcAO(in vec3 pos, in vec3 nor)
{
	float sca = 30.0, occ = 0.1;
    for( int i=1; i<6; i++ ){
    
        float hr = 0.02 + float(i)*0.6/5.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.8;
    }
    return clamp( 2.0 - occ, 0.1, 2.0 );    
}

// Function 1708
float softShadow(in vec3 ro, in vec3 rd )
{
    // real shadows	
    float res = 1.0;
    float t = 0.001;
	for( int i=0; i<80; i++ )
	{
	    vec3  p = ro + t*rd;
        float h = p.y - terrainM( p.xz );
		res = min( res, 16.0*h/t );
		t += h;
		if( res<0.001 ||p.y>(SC*200.0) ) break;
	}
	return clamp( res, 0.0, 1.0 );
}

// Function 1709
float shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle)
{
	float light_visibility = 1.;
	float ph = 1e5;
	float dDEdt = 0.;
	pos.w = map(pos.xyz);
	int i = 0;
	for (; i < shadow_steps; i++) {
	
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
        vec3 ra =rand3()-0.5;
        
		pos.w = (1. + 0.1*ra.x)*abs(map(pos.xyz));
        dir.xyz = normalize(dir.xyz + 0.01*pos.w*ra/2.5*rayfov*dir.w);
	
		float angle = max((pos.w - 2.5*rayfov*dir.w)/(max(0.0001,dir.w)*light_angle), 0.);
		
        light_visibility = min(light_visibility, angle);
		
		ph = pos.w;
		
        if(dir.w >= distance2light)
		{
			break;
		}
		
		if(dir.w > MAX_DIST || pos.w < max(2.*rayfov*dir.w, MIN_DIST))
		{
			break;
		}
	}
	
	if(i >= shadow_steps)
	{
		light_visibility=0.;
	}
	//return light_visibility; //bad
	light_visibility = clamp(2.*light_visibility - 1.,-1.,1.);
	return  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)
}

// Function 1710
float calc_ao(vec3 p, vec3 n)
{

	float r = 0.0;
	float w = 1.0;
	for (float i=1.0; i<=5.0; i++)
	{
		float d0 = (i / 5.0) * 1.25;
		r += w * (d0 - dist(p + n * d0));
		w *= 0.5;
	}
	float ao = 1.0 - clamp(r,0.0,1.0);
	return ao;
}

// Function 1711
float calcAO( in vec3 pos, in vec3 nor ) {
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<4; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos, nor ).d;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1712
float pointLightSpec(vec3 nor, vec3 pos, vec3 lightPos, vec3 f, vec3 rd, float shiny){
    vec3 toLight = normalize(lightPos - pos);
    float dist = length(lightPos - pos);
    float atten = min(1.0, 1.0/(dot(f, vec3(1.0, dist, dist * dist))));
    return clamp(pow(clamp(dot(reflect(rd, nor), toLight), 0.0, 1.0), shiny), 0.0, 1.0) * atten;
}

// Function 1713
vec3 doLighting( in vec3 col, in float ks,
                 in vec3 pos, in vec3 nor, in vec3 rd )
{
    vec3  ldif = lpos - pos;
    float llen = length( ldif );
    ldif /= llen;
	float con = dot( light1,ldif);
	float occ = mix( clamp( pos.y/4.0, 0.0, 1.0 ), 1.0, 0.2*max(0.0,nor.y) );
    vec2 sminmax = vec2(0.01, 5.0);

    float sha = softshadow( pos, ldif, sminmax.x, sminmax.y, 32.0 );;
		
    float bb = smoothstep( 0.5, 0.8, con );
    float lkey = clamp( dot(nor,ldif), 0.0, 1.0 );
	vec3  lkat = vec3(1.0);
          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;
          lkat /= 1.0+0.25*llen*llen;		
		  lkat *= 30.0;
          //lkat *= sha;
          lkat *= vec3(sha,0.6*sha+0.4*sha*sha,0.3*sha+0.7*sha*sha);
    
    float lbac = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );
          lbac *= smoothstep( 0.0, 0.8, con );
		  lbac /= 1.0+0.2*llen*llen;		
		  lbac *= 7.0;
	float lamb = 1.0 - 0.5*nor.y;
          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );
		  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );
		  lamb *= 0.25;

    vec3 lin  = 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);
         lin += 1.0*vec3(0.20,0.05,0.02)*lamb*occ*occ;
         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ*occ;
         lin *= vec3(1.3,1.1,1.0);
    
    col = col*lin;

    vec3 hal = normalize(ldif-rd);
    vec3 spe = lkey*lkat*(0.5+0.5*occ)*5.0*
               pow( clamp(dot(hal, nor),0.0,1.0), 6.0+6.0*ks ) * 
               (0.04+0.96*pow(clamp(1.0-dot(hal,ldif),0.0,1.0),5.0));

    col += (0.4+0.6*ks)*spe*vec3(0.8,0.9,1.0);

    col = 1.4*col/(1.0+col);
    
    return col;
}

// Function 1714
void ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in vec3 rayDir)
{
	if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))
	{
		// diffuse
		float dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);
		if(dp > 0.0)
			pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;
		
		// specular
		vec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;			
	}
}

// Function 1715
void setLights(){
  	float  time = iTime;
    vec3 specular = vec3(1.0);
  	light1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(1.0),specular));
  	light2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(1.0),specular)); 
}

// Function 1716
vec3 getLightIntensity(in vec3 p)
{
    int counter = int((iTime * 5.0)) & 255;
    int shift = int(p.y * 32.0) & 11 + int(p.x * 32.0) & 7;
    int on = (counter >> shift) & 1;
    return vec3(float(on), float(1 - on), 1.0) * 10.0;
}

// Function 1717
float shadow(vec3 ro, vec3 rd){
    float t = 0.01;
    float d = 0.0;
    float shadow = 1.0;
    for(int iter = 0; iter < 128; iter++){
        d = map(ro + rd * t);
        if(d < 0.0001){
            return 0.0;
        }
        if(t > length(ro - lightPos) - 0.5){
            break;
        }
        shadow = min(shadow, 128.0 * d / t);
        t += d;
    }
    return shadow;
}

// Function 1718
vec3 light(vec2 uv, float BUMP, float SRC_DIST, vec2 dxy, float iTime, inout vec3 avd) {
    vec3 sp = vec3(uv-0.5, 0);
    vec3 light = vec3(cos(iTime/2.0)*0.5, sin(iTime/2.0)*0.5, -SRC_DIST);
    vec3 ld = light - sp;
    float lDist = max(length(ld), 0.001);
    ld /= lDist;
    avd = reflect(normalize(vec3(BUMP*dxy, -1.0)), vec3(0,1,0));
    return ld;
}

// Function 1719
float ComputeAO(const vec3 p, const vec3 n)
{
    float ao = 0.0;
    
    int   i = 0;
    float r,d;
    while (i<AO_NUM_STEPS)
    {
        i++;
        d = AO_STEP_SIZE * float(i);
    	r = GetNearestShape(p + n*d).distance;
   
        ao += max(0.0, (d-r)/d);
    }
    
    return 1.0 - ao*AO_INTENSITY;
}

// Function 1720
vec3 Sample_SphLight_HemiSph(vec3 V, vec3 p, vec3 N, inout uint h, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    vec3 L;
    {
        float h0 = Hash11(h);
        float h1 = Hash01(h);
        	  
        L = Sample_Sphere(h0, h1, N);
    }

    float t2; vec3 n2; vec3 a2; bool isLight2 = true;
    bool hit = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);

    if(!isLight2) return vec3(0.0);
    
    float NoL = clamp01(dot(N, L));
    
    return Frostbite_R(V, N, L, albedo, roughness, F0) * Radiance * NoL * pi2;
}

// Function 1721
vec3 get_light_pos()
{
    return vec3(100.0*sin(iTime),200.0,300.0*cos(iTime));
    //return vec3(100.0,200.0,300.0);
}

// Function 1722
vec3 salmpleLight(	in vec3 x,
                  	in mat3 trans,
                  	in mat3 inv_trans,
                  	in vec3 ng,
                  	in vec3 lwi,
                  	in Material mtl,
                  	in bool useMIS ) {
    vec3 Lo = vec3(0.0);	//outgoing radiance

    float lightPickingPdf = 1.0;
    Light light = lights[0];

    vec3 lwo;
    float lightPdfW, lightDist;

    LightSamplingRecord rec;
    vec3 Li = sampleLightSource( x, rnd2(), rec );
    lwo = inv_trans * rec.w;
    lightPdfW = rec.pdf;
    lightDist = rec.d;
    lightPdfW *= lightPickingPdf;

    float dotNWo = lwo.z;

    if ((dotNWo > 0.0) && (lightPdfW > EPSILON)) {
        vec3 fr = mtlEval(mtl, ng, lwi, lwo);
        if(dot(fr,fr)>0.0) {
            Ray shadowRay = Ray(x, rec.w);
            if (isLightVisible( shadowRay )) {
                vec3 contribution = (Li * fr * dotNWo) / lightPdfW;

                if (useMIS && !(mtl.type_==1)) {
                    float brdfPdfW = mtlPdf(mtl, ng, lwi, lwo);
                    contribution *= misWeight(lightPdfW, brdfPdfW);
                }

                Lo += contribution;
            }
        }
    }

    return Lo;
}

// Function 1723
float cloudsShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )
{
	float sum = 0.0;

    // bounding volume!!
    float tl = ( -10.0-ro.y)/rd.y;
    float th = ( 300.0-ro.y)/rd.y;
    if( tl>0.0 ) tmin = max( tmin, tl );
    if( th>0.0 ) tmax = min( tmax, th );

	float t = tmin;
	for(int i=ZERO; i<64; i++)
    { 
        vec3  pos = ro + t*rd; 
        vec4  denGra = cloudsMap( pos ); 
        float den = denGra.x;
        float dt = max(0.2,0.02*t);
        if( den>0.001 ) 
        { 
            float alp = clamp(den*0.3*min(dt,tmax-t-dt),0.0,1.0);
            sum = sum + alp*(1.0-sum);
        }
        else 
        {
            dt *= 1.0 + 4.0*abs(den);
        }
        t += dt;
        if( sum>0.995 || t>tmax ) break;
    }

    return clamp( 1.0-sum, 0.0, 1.0 );
}

// Function 1724
vec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness, float ambientVis, float shadow)
{
    vec3 coneDirWS = normalize(mix(rayDirWS, normalWS, roughness*roughness*0.75));
    
    vec3 coalsDiskCenter = kCampfireCenterWS - oz.yxy * 0.1;
    
    vec3 coneIntersectedWithGround = posWS + coneDirWS * 
        -(posWS.y - coalsDiskCenter.y)/(coneDirWS.y == 0.0 ? 0.0001 : coneDirWS.y);
    
    float coalsDiskRadiusWS = 0.73;
    
    vec3 campfireToGroundPosWS = coneIntersectedWithGround - coalsDiskCenter;
    vec3 campfireToConeGroundDirWS = normalize(campfireToGroundPosWS);
    vec3 farDiskPointOnGroundWS = coalsDiskCenter + campfireToConeGroundDirWS * coalsDiskRadiusWS;

    vec3 posToCoalsDiskCenterDirWS =  normalize(coalsDiskCenter - posWS);
    float coalsDiskAngularRadius = (dot(normalize(farDiskPointOnGroundWS - posWS), 
                                       posToCoalsDiskCenterDirWS));
    
    vec3 sky = kSkyColour / (1.0 + 0.03*dot(posWS, posWS));

    vec3 ambient = sky;
    //Bounced light from the fire
    vec3 groundAlbedo = vec3(0.2, 0.15, 0.05);
    vec3 groundColour = groundAlbedo * (saturate(s_globalFireLife + 0.05)) * 0.05 *
        ((kFireLightColour)/(roughness + 1.0 + dot(campfireToGroundPosWS, campfireToGroundPosWS)));
    
    ambient = mix(ambient, groundColour, 
                  smoothstep(0.001+roughness*1.5, -0.001-roughness*1.5, coneDirWS.y));
	
    //Glow from the coals
    ambient += shadow * 0.1 * vec3(1.0, 0.075, 0.01) * saturate(10.0 * (s_globalFireLife*0.75 + 0.25)) * 
        diskLight(coneDirWS, posToCoalsDiskCenterDirWS, coalsDiskAngularRadius, roughness);
    
    
    ambient *= ambientVis;
    
    for(uint i = 0u; i < kNumLogs; ++i)
    {
		float logLength = s_campfireLogs[i].logLength;
        float logRadius = s_campfireLogs[i].logLength;
        vec3 logCenterWS = s_campfireLogs[i].centerWS;
        vec3 burnDirWS = s_campfireLogs[i].burnDirWS;
        
        float rand = kGoldenRatio * float(i);
        float fireLife = s_globalFireLife - hash11(rand * 657.9759)*0.2;
        
        vec3 flameCenterWS = logCenterWS + burnDirWS*(saturate(fireLife)*2.0 - 1.0)*logLength;
        
        float sqrtFireLife = sqrt(max(0.0001, fireLife));
        float flameHeight = max(0.15, 0.2 + fireLife*1.2);
        flameHeight *= 0.65;
        float flameRadius = (0.1 + sqrtFireLife)*0.2;
        flameRadius *= 0.75;
        //Prevent the light from going through the ground
        flameCenterWS.y = max(flameCenterWS.y, flameRadius + 0.05);

        vec4 fireBottomLight = vec4(flameCenterWS, max(0.075, flameRadius));
        vec4 fireTopLight = vec4(flameCenterWS + oz.yxy * flameHeight, 0.01);
        
        float lightVisibility;
        vec3 fireLight = computeTubeLighting(posWS, coneDirWS, roughness, fireBottomLight, fireTopLight, 
                                             kFireLightColour, lightVisibility);
        
        float lightIntensity = sqrt(saturate(fireLife + 0.1));
        ambient += shadow * fireLight * lightIntensity
            *(1.0 + sin(rand*2.0 - 10.0*s_time) * 0.35 + sin(rand*4.0 - 15.0*s_time)*0.25);
        
    }
    
    return ambient;
}

// Function 1725
vec3 getlightcolour()
{    
    return getAtmosphericScattering(normalize(-g_light.dir - YAXIS*0.2), g_light.dir);
}

// Function 1726
vec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)
{
    position *= scale;
    vec3 color = vec3(1.0);
    
    color = color * 0.75 + 0.25;
    
    color *= normal * .25 + .75;
    
    float checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);
    
    color *= step(0.0,checker) * 0.25 + 0.75;
    
    float ambient = 0.1;
    float diffuse = 0.5 * -dot(normal,direction);
    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));
    
    color *= vec3(ambient + diffuse + pow(specular,5.0));

    color *= smoothstep(12.0,6.0,length(position));
    
    return color;
}

// Function 1727
float softShadow(in ray ray, int maxSteps/*float mint, float k*/)
{
    float k = 4.0;
    float res = 0.0;
    float t = 0.001;
	float h = 1.0;
    
    for( int i=0; i<int(maxSteps); i++ )
    {
        h = sceneDistanceFunction(ray.origin + ray.direction*t, orbitTrap);

        if(res<0.001)
        {
            break;
        }
        t += h;//clamp( h, 0.01, 0.05 );
    }
    return 1.0-saturate(res);
}

// Function 1728
vec3 shade(Ray ray) {
 
    Hit scn  = raymarch(ray);
    vec3 col = vec3(1.);
    
    if(scn.hit) {
     
        vec3 n = calcNormal(scn.p);
        vec3 l = calcLighting(scn, n);
        
        vec3 rld = reflect(ray.dir, n);
        vec3 rfd = refract(ray.dir, n, .33);
        
        float fresnel = mix(.2, .9, dot(ray.dir,n));;
        col = mix(texture(iChannel1,rld),texture(iChannel1,rfd),fresnel).xyz;
        
    }
    
    return col;
    
}

// Function 1729
vec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )
{
/*  we have to do animation here to get motion blur - which is a bit shit
	would be better if we stored cylinder list in a buffer, with previous frame's list on the next row
	but that would limit us to linear interpolations (of end points - so rotation would shorten cylinders! eek)*/
/*	// animate moving objects
    float r = -(time+sin(time))*10.;
    float a = time/3.;
    vec3 d = vec3(cos(r),0,sin(r))*cos(a)+vec3(0,sin(a),0);
    vec3 cp = vec3(.8,.5,3);
    Scene[0] = vec4(cp+d*.03,.5);
    Scene[1] = vec4(cp-d*.03,5);
    cp = vec3(-1.3,.5,0);
    d.x = -d.x;
    Scene[2] = vec4(cp+d*.3,.3);
    Scene[3] = vec4(cp-d*.3,5);*/
    
    vec3 normal = vec3(0);
    int material = 0;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;

        Material mat = GetMaterial(pos,normal,material);
        
        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );
        if ( length(mat.specularColour) == 0. ) fresnel = vec3(0); // override fresnel if spec colour is 0 - e.g. for emissive shapes

        float specPower = 1./(mat.roughness*mat.roughness);
        float specStrength = (specPower+8.)/(4.*tau);

        
        // sample specular or diffuse bounced light
        float proportionSpecular = Grey(fresnel)/(Grey(mat.albedo) + Grey(fresnel));
        bool tapIsSpecular = ( rand.w+.5 < proportionSpecular );
        
        
        // randomize reflection direction with Blinn-Phong probability distribution
        vec3 microfacet = PowRand( rand.yz, normal, tapIsSpecular ? specPower : 1. );
        
        // sample reflection
        vec3 diffuse = vec3(0);
        vec3 reflection = vec3(0);
        vec3 tapalb = vec3(0);
        vec3 tapn = vec3(0);
        vec3 tappos = pos;
        float tapemi = 0.;
        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera
        {
            vec3 tapray = tapIsSpecular ? reflect(ray,microfacet) : microfacet;
            int tapmati = 0;
            float tapt = Trace(tapn,tapmati,pos,tapray);

            if ( length(tapn) > 0. )
            {
                tappos = pos+tapray*tapt;
                Material tapmat = GetMaterial(tappos,tapn,tapmati);

                // turn metallic surfaces into a sky-tinted diffuse surface, because we're doing no more bounces
                vec3 bounce2 = Sky(reflect(tapray,tapn)); // would be good if I could blur this
                tapalb = mix(tapmat.albedo,bounce2,tapmat.specularColour);
                tapemi = tapmat.emissive;

                vec3 ambient = Sky(tapn);
                //vec3 ambient = mix(vec3(.1),vec3(.5),tapn.y*.5+.5);
                vec3 bounceLight = mix( ambient, vec3(1), tapemi );
                bounceLight = mix(tapmat.albedo*bounceLight,bounce2,tapmat.specularColour);
                if ( tapIsSpecular )
                    reflection += bounceLight / proportionSpecular;
                else
                    diffuse += bounceLight / (1.-proportionSpecular);
            }
            else
            {
                // reflected ray didn't hit an object
                vec3 bounceLight = Sky(tapray);
                if ( tapIsSpecular )
                    reflection += bounceLight / proportionSpecular;
                else
                    diffuse += bounceLight / (1.-proportionSpecular);
            }
        }

/* actually doing bounces now
		// ambient light
        vec3 ambientColour = vec3(0);//.05,.065,.09);
        vec3 diffuse = ambientColour*(normal.y*.3+1.);
        if ( length(tapn) > 0. ) reflection += tapalb * ambientColour*(tapn.y*.3+1.);
*/
        for ( int i=0; i < lights.length(); i++ )
        {
/*
	>vec3 position;
    >vec3 target; distance falloff
    >vec3 colour;
    float innerRadius; // at target
    float outerRadius;
    >float sourceRadius; // area lighting

lights*/
        

            // sample light
            vec3 sun = normalize(lights[i].position-pos);//normalize(lights[i].position-lights[i].target);

            // soften shadow by sampling radius around sun
            vec3 suntap = sun;
            if ( lights[i].sourceRadius > 0. )
            {
                vec3 areaLight = PowRand( rand.zx, -sun, 1. );
                suntap = normalize( lights[i].position + areaLight*lights[i].sourceRadius - pos );
            }

            float ndotl = max(0.,dot(normal,sun));
            float ndoth = max(0.,dot(normal,normalize(-ray+sun)));

            vec3 lightCol = lights[i].colour;
            float lightStrength = 1./dot(pos-lights[i].position,pos-lights[i].position);
            float cosa = dot(sun,normalize(lights[i].position-lights[i].target));
            float angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );
            angleFade = angleFade*angleFade;
            lightStrength *= angleFade;

            if ( cosa > 0. && angleFade > .001 )//&& lightStrength > 0.001 ) this light strength test is ignoring base brightness, which is wrong
            {
                vec3 testn = vec3(0);
                int ignore;
                float st = Trace(testn,ignore,pos,suntap);
                if ( length(testn) == 0. || st > length(lights[i].position-pos) ) // we didn't hit anything before the light
                {
                    vec3 lightC = lightCol*lightStrength;

                    // diffuse
                    diffuse += ndotl * lightC;

                    // specular
                    reflection += lightC * ndotl*pow(ndoth,specPower)*specStrength;
                }
			}
			else
            {
                //if ( cosa > 0. && lightStrength > .0005 ) diffuse += lights[i].colour*.1; // show bounding volumes
        	}

            if ( length(tapn) > 0. )
            {
                //lightCol = lights[i].colour / dot(refpos-lights[i].position,refpos-lights[i].position);
                // just reuse the light on the reflector

                sun = normalize(lights[i].position-tappos);

// disabled this if it doesn't make a difference (e.g. sun-lit scenes)
#if 0 
				// recompute light strength for the reflected position
				// not sure if this looks right
                lightStrength = 1./dot(tappos-lights[i].position,tappos-lights[i].position);
                cosa = dot(sun,normalize(lights[i].position-lights[i].target));
                angleFade = 0.;
                if ( cosa > 0. ) angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );
                lightStrength *= angleFade*angleFade;
#endif
                vec3 lightC = lightCol*lightStrength;

                
                // apply light to reflected object!
                vec3 bounceLight = tapalb * mix( max(0.,dot(tapn,sun)) * lightC, vec3(0), tapemi );
                if ( tapIsSpecular )
	                reflection += bounceLight / proportionSpecular;
                else
	                diffuse += bounceLight / (1.-proportionSpecular);
            }
        }

        col = mat.albedo * diffuse;

        col = mix( col, reflection, fresnel );
        
        col = mix( col, mat.albedo, mat.emissive );
    }
    
    return col;
}

// Function 1730
float softshadow(vec3 ro, vec3 rd, float k ){ 
     float akuma=1.0,h=0.0; 
	 float t = 0.01;
     for(int i=0; i < 50; ++i){ 
         h=f(ro+rd*t); 
         if(h<0.001)return 0.02; 
         akuma=min(akuma, k*h/t); 
 		 t+=clamp(h,0.01,2.0); 
     } 
     return akuma; 
}

// Function 1731
vec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )
{
    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),
				              softShadowSphere( pos, vec3(0.57703), sc1 )),
				              softShadowSphere( pos, vec3(0.57703), sc2 )),
                              softShadowSphere( pos, vec3(0.57703), sc3 ));
	float dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);
	float bac = clamp(dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);
    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;
	     lin += occ*vec3(0.15,0.20,0.30);
	     lin += bac*vec3(0.10,0.10,0.10);

    return lin;
}

// Function 1732
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5);
}

// Function 1733
vec3 scene_shade(vec3 p, vec3 n, L l, M m, C c)
{
	return l.d * m.d * dot(n, normalize(l.p - p))
		+ l.s * m.s * pow(clamp(dot(normalize(reflect(l.p - p, n)), normalize(p - c.p)), 0., 1.), m.e);
}

// Function 1734
float calcLightning( in vec3 pos, in vec3 light, in vec3 nor, in float maxDist, in bool shadow ) {
    float sh = 1.;
    vec3 lig = ( light-pos );
    float im = length( lig );
	lig /= im;
   	if(shadow) sh = softshadow( pos, lig, 1.02, im, 32.0  );
    sh /= im;
    sh *= clamp(dot(nor,lig),0.,1.);
    return sh * (1.-smoothstep(0.,maxDist,im));
}

// Function 1735
float GetLight(vec3 p)
{
    vec3 lightPos = vec3(-0.9, 0.9, 1.9);
    //lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;
    vec3 l = normalize(lightPos - p);	//light vector
    vec3 n = GetNormal(p);				//perpendicular to surface
    
    //the dot product delivers a value between -1..1, we need 0..1, so clamp it
    float dif = clamp(dot(n, l), 0.0, 1.0);
        
    return dif;
}

// Function 1736
vec3 shade(in vec3 p,in vec3 n)
{
    // Point light
    const vec3 lightPos = vec3(1.0, 1.0,-5.0);
    const vec3 lightColor = vec3(0.95, 0.95,0.95);
  
    vec3 l = normalize(lightPos - p);

    // Not even Phong shading, use weighted cosine instead for smooth transitions
    float diff = 0.5*(1.0+dot(n, l));

    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish
    vec3 c = 0.2*background(n)+0.8*marble(p,n);//*diff*lightColor;

    return c;
}

// Function 1737
float softshadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<32; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = map(pos, length(pos) ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1738
float GetSunShadow( const vec3 vPos )
{
    vec3 vSunDir = GetSunDir();

    Intersection shadowInt;
    float k_fShadowDist = 2.0;
    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );
    
    float fShadowFactor = 1.0;
    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )
    {
        fShadowFactor = 0.0;
    }

    return fShadowFactor;
}

// Function 1739
float computeAO(vec3 pos, vec3 nor)
{
	float  occ = 0.0;
    float  sca = 1.0;
    for( int i = 0; i < 5; ++i)
    {
        float hr = 0.01 + 0.12 * float(i) / 4.0;
        vec3  aopos = nor * hr + pos;
        float dd = mapScene(aopos).x;
        occ += -(dd - hr) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0*occ, 0.0, 1.0);    
}

// Function 1740
vec3 Light(in Ray ray, in Material mat, in vec3 norm, in vec3 pos)
{
    vec3 direct = vec3(0.0);
    float sunIntens = max(0.0, dot(norm, SunLightDir));
    
    if(sunIntens > 0.0)
    {
        direct = CalculateLightingAnalytical(SunLightDir, -ray.d, mat);
    	direct *= Shadow(pos);
    }
    
#ifdef HIGH_QUALITY
    vec3 ambient = CalculateLightingIBL(mat.bump, pos, -ray.d, mat);
#else
    vec3 ambient = CalculateLightingIBL(norm, pos, -ray.d, mat);
#endif
    
    return (direct * 2.0 + ambient);
}

// Function 1741
float lighter (vec2 st){
    vec3 lightpos = vec3(1.,1.,0.8);
    float hscale = 0.1;
    float nscale = 2.;
    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);
    vec2 offs = st+vec2(2.,-2.)/iResolution.xy;
	float map0 = buildSDF(st);
    float map1 = buildSDF(vec2(offs.x,st.y))-map0;
    float map2 = buildSDF(vec2(st.x,offs.y))-map0;
	vec3 shape = normalize(cross(vec3(1.,0.,map1),vec3(0.,1.,map2)));
	vec3 light = normalize(lightpos-vec3((st*vec2(2.)-vec2(1.))*vec2(1,aspect),(map0/hscale)*-nscale));
	float greyval = clamp(dot(light,shape),0.,1.);
    return greyval;
}

// Function 1742
vec3 lighting(vec3 rayO, vec3 rayD, float t, vec2 d, float density)
{
    float m = d.y;
    
    if(m < .5)
        return vec3(0.0);
    
    
    vec3 lPos = vec3(4.0, 3.0, 4.0);
    vec3 p = rayO + rayD * t;
    vec3 normal = sdfNormal(p, .05);
    float spotLight = smoothstep(12.0, 0.0, length(p.xz));
    
    if(m > GROUND_MATERIAL - .5 && m < GROUND_MATERIAL + .5)
    {
        normal = mix(normal, normalize(normal + texture(iChannel1, p.xz * .4).xyz * .2), spotLight);
        
        vec3 noise = texture(iChannel3, p.xz * .3).xyz;
        normal = mix(normal, normalize(normal + (noise * 2.0 - vec3(1.0)) * .5), spotLight * smoothstep(.2, .3, noise.y * noise.x * noise.z));
    }
    
    vec3 R = reflect(-rayD, normal);
    
    vec3 toLight = normalize(lPos - p);
    vec3 H = normalize(toLight - rayD);
    
    float curvW = texture(iChannel0, p.xz + p.yy).r;
    float curvature = curv(p, mix(.05, .2, curvW)) * 1.1; // :D
    
    float rim = pow(max(1.0 - dot(normal, -rayD), 0.0), 4.0) * .5;    
   	float diffuse = dot(normal, toLight);
    float bounce = saturate(-diffuse); 
    diffuse = max(0.0, diffuse);
    
    
    vec3 refl = pow(texture(iChannel2, R).rgb, vec3(2.2));
    float tx = smoothstep(.2, .5, triplanar(p * .35, normal).x);
    float specular = pow(saturate(dot(normal, H)), 8.0 + tx * 3.0);
    
    vec3 color = vec3(diffuse);    
    vec3 lightColor = vec3(1.5, 1.5, 1.75);
    vec3 specularColor = vec3(.9, .95, 1.0) * .45 * lightColor;
    
    float ao = evaluateAmbientOcclusion(p, normal);
    ao = smoothstep(.0, .5, ao);
    
    float shadowStrength = .95;
    float shadow = evaluateShadows(p, toLight);
    shadow = mix(shadow, 1.0, 1.0 - shadowStrength);
    
    float r = 2.0 - (smoothstep(.4, .5, abs(p.z)) + smoothstep(.4, .5, abs(p.x)));
    
	float lightTime = mechTime();
    vec3 glowColor = pow(vec3(.4, .75, .15), vec3(2.2)) * lightTime;
        
    if(m < RIBBON_MATERIAL + .5)
    {
        color = vec3(.5, 0.1, 0.075) * (1.0 + curvature * 1.5);
        
        color += color * abs(sdf_simple(p - normal * .3) / .25);
        specular *= specular * specular;
        specularColor *= .25;
        rim *= .25;
    }
    else if(m < BOX_MATERIAL + .5)
    {
        float pattern = smoothstep(-.15, .15, sin((p.x - p.y + p.z) * 2.3 - 1.1));
        color = mix(vec3(.15, .4, .1), vec3(.2, .9, .2), pattern);
        color += vec3(.5, 1.0, .5) * curvature * curvature * 4.0;
        rim *= .2;
        
        color = mix(color, vec3(1.2, 1.0, .5) * 7.0, r);
    }
    else if(m < GOLD_MATERIAL + .5)
    {
		color = (vec3(1.2, .9, .3) + refl * refl) * 1.5;
        specularColor = refl * 2.0;
    }
    else if(m < GROUND_MATERIAL + .5)
    {
		color = vec3(.2, .25, .275) * (1.4 + spotLight * diffuse) * 1.45;
        
        color += glowColor * .5 * saturate(1.0 - max(-fBox2(p.xz, vec2(4.0)), length(p.xz) - 5.25));
        
        specular *= .1;
        rim = 0.0;
        
        normal = normalize(normal + texture(iChannel1, p.xz * .1).xyz); 
    }
    else if(m < METAL_MATERIAL + .5)
    {
		color = (vec3(.6) + refl * refl) * 1.5;
        specularColor = refl * 2.0;
    }
    
    color = pow(color, vec3(2.2)) * spotLight;
    
    vec3 ambientLight = vec3(.65, .5, 1.0);
    
    vec3 outColor = color * diffuse + specularColor * specular + ambientLight * rim;
    outColor *= shadow;
    outColor = mix(outColor * .1 * ambientLight, outColor, ao);
    outColor += vec3(.3, .1, .1) * bounce * bounce * color;
    
    outColor += glowColor * density * .03;
    
    return pow(outColor * lightColor, vec3(.454));
}

// Function 1743
vec4 GetDirectionalLightRotationAxisAngle ()
{
    // mode >= 5.0 starts moving and rotating light source
    float time = GetMode() - 5.0;
    time = max(time, 0.0);
    
    vec4 ret = directionalLightRotationAxisAngle;
    ret.xyz += vec3(sin(time * 0.1), sin(time * 0.7), sin(time * 0.3));
    ret.xyz = normalize(ret.xyz);
    ret.w += time * 0.66;
        
    return ret;
}

// Function 1744
float softshadow( in vec3 ro, in vec3 rd, float mint, float k, in vec4 c )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<64; i++ )
    {
        vec4 kk;
        float h = map(ro + rd*t, kk, c);
        res = min( res, k*h/t );
        if( res<0.001 ) break;
        t += clamp( h, 0.01, 0.5 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1745
void shade(in Intersection its, inout Path path)
{
    if (its.t == path.ray.tMax)
    {
        path.throughput = vec3(0.0);
        return;
    }
    
    // Did we hit an emitter?
    if (its.isLight)
    {
        vec3 incidentRadiance = its.light.radiance;
    	
        vec3 difference = its.light.p - path.ray.o;
        float distance = length(difference);
        vec3 direction = difference / distance;

        float sinTheta = its.light.r / distance;
        float cosTheta = sqrt(1.0 - sinTheta * sinTheta);
        
        float pdfLight = squareToUniformSphereCapPdf(cosTheta);

        if (path.lastBsdfPdf > 0.0) {
            incidentRadiance *= powerHeuristic(path.lastBsdfPdf, pdfLight);
        }
        
        collectRadiance(path, its.t, incidentRadiance);
        
        // Terminate path
        path.throughput = vec3(0.0);
        return;
    }
    
    float timeTravelled = its.t;
    
    // DIFFUSE
    if (its.m.c.x >= 0.0)
    {
        path.throughput *= its.m.c;
    
        // EMITTER SAMPLING
        for (int i = 0; i < AMOUNT_LIGHTS; ++i)
        {
            LightSample lightSample = sampleLight(its.p, lights[i]);

            Ray visRay;
            visRay.o = its.p;
            visRay.d = lightSample.d;
            visRay.tMin = EPSILON;
            visRay.tMax = INFINITY;

            float cosineTerm = max(0.0, dot(its.n, visRay.d));
            float pdfBsdf = cosineTerm / PI;

            Intersection visIts = traceShadow(visRay);
            if (visIts.isLight && visIts.light.idx == i)
            {
                vec3 incidentRadiance = 
                    (1.0 / PI)
                  * powerHeuristic(lightSample.pdf, pdfBsdf)
                  * lights[i].radiance
                  * cosineTerm
                  / lightSample.pdf;
                
                if (incidentRadiance.x > 0.0 && incidentRadiance.y > 0.0 && incidentRadiance.z > 0.0)
                	collectRadiance(path, timeTravelled + visIts.t, incidentRadiance);
            }
        }

        // BSDF SAMPLING
        vec3 hemi = squareToCosineHemisphere(rand2());
        path.lastBsdfPdf = hemi.z / PI;
        
        vec3 s = normalize(cross(its.n, vec3(0.433, 0.433, 0.433)));
        vec3 t = cross(its.n, s);

        path.ray.d = its.n * hemi.z + s * hemi.x + t * hemi.y;
    }
    // MIRROR
    else if (its.m.c.x >= -1.0)
    {
        path.ray.d = reflect(path.ray.d, its.n);
        path.lastBsdfPdf = 0.0;
    }
    // DIELECTRIC
    else
    {
        float IOR = its.m.c.y;
        
        float cosThetaI = -dot(its.n, path.ray.d);
		float F = fresnelDielectricExt(cosThetaI, IOR);
        
        vec3 n = cosThetaI > 0.0 ? its.n : -its.n;
        if (rand1() <= F)
        {
            path.ray.d = reflect(path.ray.d, n);
        }
        else
        {
            path.ray.d = refract(path.ray.d, n, cosThetaI > 0.0 ? (1.0 / IOR) : IOR);
        }
        
        if (cosThetaI < 0.0)
            timeTravelled *= IOR;
        
        path.lastBsdfPdf = 0.0;
    }
    
    path.ray.o = its.p;
    path.time += timeTravelled;
    
    ++path.amountBounces;
}

// Function 1746
float calcSoftshadow_o349467( in vec3 ro, in vec3 rd, in float mint, in float tmax){
	float res = 1.0;
    float t = mint;
    float ph = 1e10; // big, such that y = 0 on the first iteration
    for( int i=0; i<32; i++ ){
		float h = input_o349467( ro + rd*t ).x;
        res = min( res, 10.0*h/t );
        t += h;
        if( res<0.0001 || t>tmax ) break;  
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1747
vec3 calc_Ie_shaderfunc( float cos_alpha )
{
	Ie_ie_params_init();
	float bleed = 0.02; //0.0 means no bleed, sunset cameras need enough bleeding to look interesting
	cos_alpha = 1.0 + ( cos_alpha - 1.0 ) * ( 1.0 - bleed ); // exaggerate Ie bleed a little bit
	cos_alpha = clamp( cos_alpha, ie_cost_min, 1.0 - 0.019 ); // cos alpha=1 has a weird blob, clamp a bit...
	return vec3( ie_approx_S( cos_alpha, ie_params_r ),
				 ie_approx_S( cos_alpha, ie_params_g ),
				 ie_approx_S( cos_alpha, ie_params_b ) );
}

// Function 1748
vec3 shade(in vec3 P, in vec3 N, in vec3 color, in vec3 LPos) {
  vec3 L = normalize(LPos - P);
  // simple two sided diffuse shading
  return color * clamp(abs(dot(L, N)), 0.0, 1.0);
}

// Function 1749
vec3 GetLight(vec3 p,vec3 rd,vec3 lightPos, vec3 lightCol){
	vec3 v = -rd;
    ;
    
    //attenuation
    float atten = 1. - length(lightPos - p)/21.;//float is light Area
    
    float MoveRadius = 0.;
    float MoveSpeed = 0.;
    
    float t = iTime * MoveSpeed;
    lightPos.xz += vec2(sin(t), cos(t)) * MoveRadius;
    vec3 l = normalize(lightPos - p);
    vec3 n = GetNormal(p);
    
    vec3 ref = reflect(n,rd);
    //ambient
    float amb = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));
    //diffuse
    float NdotL = dot(n, l);
    NdotL = NdotL*.5 + .5;
    float dif = clamp(NdotL, 0. , 1.);
    //specular
    vec3 h = normalize(l + v);
    float spe = pow(max(dot(n,h),0.), 128.);
    //fresnel
    //float fs = .4; //fresnel scale
    
    
    
    
    
    float fre =  clamp(  1.+ dot(rd,n)       ,0.,1.);
    fre = pow(fre, 1.4);
    //dom
    float dom = smoothstep( -0.2, 0.2, ref.y );
    
    
    vec3 finCol = vec3(0.); 
    finCol += amb * vec3(1,1,0) * .5;
    finCol += dif * vec3(1,1,1) * .5;
    finCol += spe * vec3(1,1,1) * 2.;
    finCol += fre * vec3(.3,0,1) * 2.;
   	finCol += dom * vec3(0,1,1) * 0.3;
    
    
    finCol *= atten*lightCol;
    finCol *= 1.;
    //finCol = vec3(dom);
    //shadow
    float d = RayMarch(p + n * SURF_DIST *2. , l);// 2. is fixed the center of the sphere sample
    if(p.y< 0.01 && d < length(lightPos - p))
    {
        finCol *= 0.3;
    }
    return finCol;
    
    
}

// Function 1750
float getLight(vec3 p) {
	vec3 lightPos = vec3(-2, 5, 8);
    
    //move the light in a circle
    lightPos.xz += vec2(cos(iTime), sin(iTime)) * 10.;
    
 	vec3 normal = getNormal(p);
    vec3 toLight = normalize(lightPos - p);
    
    //dot product of two normalised 
    //vectors gives the cosine of the angle between them
    float angle = dot(normal, toLight);
    
    //the amount of light depends directly on the angle
    float diffuse = clamp(angle, 0., 1.);
    
    //add shadows by casting a ray from object to light
    //offset the starting position a little so it doesn't hit
    //the object it starts from
    float dist = rayMarch(p+normal*.02, toLight);
    
    //if dist to object less than dist to light,
    //this area is a shadow
    if (dist < length(p-lightPos)) {
    	diffuse *= .2;
    }
    
    return diffuse;
}

// Function 1751
float softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
	
    float res = 1.0;
    if( b>0.0 )
    {
        float h = dot(oc,oc) - b*b - sph.w*sph.w;
        res = smoothstep( 0.0, 1.0, 2.0*h/b );
    }
    return res;
}

// Function 1752
SSphere GetLightPoint1Sphere()
{
	return SSphere
	(
		1,						//id
		lightPoint1.m_pos,		//center
		0.06,					//radius
		SMaterial
		(
			lightPoint1.m_color,//diffuse color
			1.0,				//specular amount
			vec3(0.0,0.0,0.0)	//specular color
		)
	);	
}

// Function 1753
vec3 lightcolor(float t)
{
    return mix(firecolor(0.4), vec3(0.,1.0,0.5)*0.5, pow(abs(t),8.));
}

// Function 1754
vec3 lighting(in vec3 p, in vec3 n)
{
    vec3 c = vec3(0.);
    {
        vec3 pt = cosdir(n) * 1000.;
        vec3 lr = normalize(pt - p);
        c += texture(iChannel1, lr).xyz * shadow(p, lr);
    }
    return c;
}

// Function 1755
float ao(vec3 co, vec3 nray, float max_dist, float seed) {
    int i;
    float tot=0.0;
    float sum=0.0;
    
    vec3 co2;
    
    for (int i=0; i<2; i++) {
        float seed2 = seed + 11.234 + 0.00123*float(i); //co.x*co.y*co.z + float(i)*3.14159;
        
        vec3 nray2 = normalize(randvec(seed2));
        float found;
        
        trace(co + nray2*0.005, nray2, co2, found, seed);
        sum += float(length(co2-co) < max_dist)*found;
        tot += 1.0;
    }
    
    sum = tot != 0.0 ? 1.0-sum / tot : 1.0;
    return sum;
}

// Function 1756
vec4 getLightPos()
{  
  float x = iTime * SPEED * 12.0 + 18.0;
  return vec4(
    x,
    sin(x * (PI / 6.0)) * 2.0 + 3.0,
    sin(x * (PI / 12.0) + PI * 0.5) * 13.0 + 6.0,
    LIGHT_RADIUS * 0.5 + abs(sin(x * (PI / 3.0))) * LIGHT_RADIUS * 0.5);
}

// Function 1757
vec3 lighting(vec3 n, vec3 light)
{
    float lit = dot(n, light);
    float sub = max(0.,0.5+0.5*lit);
    vec3 col = vec3(max(0.,lit))+sub*vec3(0.3,0.46,0.5);
    return col;
}

// Function 1758
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{        
  vec3 reflectDir = reflect( rayDir, normal );

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99);  
  dif *= SoftShadow( shadowPos, sunPos);
  skylight *=SoftShadow(shadowPos, reflectDir);

  vec3 lightTot = vec3(0.0);

    
    
  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);
      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);
  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));
}

// Function 1759
float calculateAO(vec3 p, vec3 n) {
    
    float r = 0., w = 1., d;
    
    for (float i = 1.; i <= AO_SAMPLES; i++){
        d = i / AO_SAMPLES / AO_RANGE;
        r += w * (d - scene(p + n * d));
        w *= .5;
    }
    
    return 1.-saturate(r * AO_RANGE);
}

// Function 1760
vec4 shade(float d)
{	
    if (d >= 0.0 && d < 0.2) return (mix(vec4(3, 3, 3, 1), vec4(1, 1, 0, 1), d / 0.2));
	if (d >= 0.2 && d < 0.4) return (mix(vec4(1, 1, 0, 1), vec4(1, 0, 0, 1), (d - 0.2) / 0.2));
	if (d >= 0.4 && d < 0.6) return (mix(vec4(1, 0, 0, 1), vec4(0, 0, 0, 0), (d - 0.4) / 0.2));    
    if (d >= 0.6 && d < 0.8) return (mix(vec4(0, 0, 0, 0), vec4(0, .5, 1, 0.2), (d - 0.6) / 0.2));
    if (d >= 0.8 && d < 1.0) return (mix(vec4(0, .5, 1, .2), vec4(0, 0, 0, 0), (d - 0.8) / 0.2));            
}

// Function 1761
float calcAO( in vec3 pos, in vec3 nor )
{
  float occ = 0.0;
  float sca = 1.0;
  for ( int i=0; i<NO_UNROLL(3); i++ )
  {
    float hr = 0.01 + 0.1*float(i);
    vec3 aopos =  nor * hr + pos;
    float dd = Map( aopos );
    occ += -(dd-hr)*sca;
    sca *= 0.93;
  }
  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1762
vec4 shade(const Ray ray) {
    
   RaycastHit obj = raycastScene(ray);
   vec4 clearColor = texture(iChannel0, ray.direction);
   vec4 ret = clearColor;
    
   if(obj.type == 0) {
     
      Ray refRay;
      refRay.origin = obj.point;
      refRay.direction = reflect(ray.direction, obj.normal);
       
      vec3 diffuse = vec3(1.,0.,0.);
      diffuse *= lighting(ray, obj);      
      
      vec3 spec = vec3(1.,1.,1.);
      spec *= specular(ray, obj, 20.);
      diffuse += spec;
       
      RaycastHit plane = raycastScene(refRay);
      clearColor = texture(iChannel0, refRay.direction);
       
      vec3 reflection = shadePlane(ray, plane, clearColor).xyz;                 
      ret = vec4(mix(diffuse, reflection,.3).xyz,1.);
      
       
   } else if(obj.type == 1) {
    
       ret = shadePlane(ray, obj, clearColor);
       
   }
     
   return ret;
        
}

// Function 1763
float GetShadows(in vec3 ro, in vec3 rd, float k){
    float res = 1.0;
    float d;
    float t = 0.001;
    
    for(int i = 0; i < MAX_STEPS; i++)
    {
        d = map(ro + rd * t).d;
        if(d < MIN_DIST){
            return 0.0;
        }
        res = min(res, k * d / t);
        t += d;
    }
    return res;
}

// Function 1764
float softShadows( in vec3 ro, in vec3 rd )
{

    float res = 1.0;
    for( float t = 0.1; t < 8.0; ++t )
    {
    
        float h = map( ro + rd * t ).x;
        if( h < EPS ) return 0.0;
        res = max( res, 8.0 * h / t );
        
    }
    
    return res;
    
}

// Function 1765
float shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<20; i++ )
    {
		float h = map( ro + rd*t );
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.1, 0.4 );
        if( h<0.001 || t>5. ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1766
vec3 shade(vec3 origin, vec3 dir, float dist, int matId) {
    vec3 pos = origin + dist*dir;
    vec3 normal = calcNormal(pos);
    Material mat = getMaterial(matId);
    float ambient = .12*(1.0 + .6*normal.y);

    vec3 light1 = normalize(vec3(1, 1, .75));
    float shadow = softshadow(pos, light1);
    float diffuse = clamp01(dot(normal, light1)) * shadow;
    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess) * shadow;

    vec3 light2 = normalize(vec3(1, .5, -2));
    diffuse += .8 * clamp01(dot(normal, light2));
    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);

    vec3 col = clamp01(diffuse + ambient)*mat.diff_color;
    col += clamp01(specular)*mat.spec_color;
    
    if (mat.reflectivity > 0.) {
        col *= mix(vec3(1), render2(pos, reflect(dir, normal)), mat.reflectivity);
    }

    return clamp01(col);
}

// Function 1767
float castShadowRay( in vec3 ro, in vec3 rd, in float time )
{
    float res = 1.0;
    
    ivec2 hid = hexagonID(ro.xz);
    
    const float k3 = 0.866025;
    const vec2 n1 = vec2( 1.0,0.0);
    const vec2 n2 = vec2( 0.5,k3);
    const vec2 n3 = vec2(-0.5,k3);
    
    float d1 = 1.0/dot(rd.xz,n1);
    float d2 = 1.0/dot(rd.xz,n2);
    float d3 = 1.0/dot(rd.xz,n3);
    float d4 = 1.0/rd.y;
    
    float s1 = (d1<0.0)?-1.0:1.0;
    float s2 = (d2<0.0)?-1.0:1.0;
    float s3 = (d3<0.0)?-1.0:1.0;
    float s4 = (d4<0.0)?-1.0:1.0;

    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;
    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;
    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;

    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;
    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;
    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;

    // traverse regular grid (2D)	
	for( int i=0; i<8; i++ ) 
	{
		vec2  ce = hexagonCenFromID( hid );
        float he = 0.5*map(ce, time);
                
        vec2 t1 = c1 + dot(ce,n1)*d1;
        vec2 t2 = c2 + dot(ce,n2)*d2;
        vec2 t3 = c3 + dot(ce,n3)*d3;
        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;
        
        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));
        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));
        if( tN < tF && tF > 0.0)
        {
            res = 0.0;
            break;
		}
        
             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;
        else if( t2.y<t3.y )              hid += i2;
        else                              hid += i3;
	}

	return res;
}

// Function 1768
float calcAO( in vec3 pos, in vec3 nor )
{

    float totao = 0.0;
    for( int aoi=0; aoi<5; aoi++ )
    {
		vec3 aopos = 0.1 * ( nor  + 0.7*(-1.0+2.0*hash3(143.13*float(aoi))) );
        float dd = map( pos + aopos ).x;
		totao += clamp(5.0*dd,0.0,1.0);
    }
    return pow( clamp( 1.5*totao/5.0, 0.0, 1.0 ), 1.0 );
}

// Function 1769
float softShadow(ray _r, vec3 _light)
{
    float tmin = 0.02;
    float tmax = 2.5;
        
    ray lr = _r;
    lr.o = _r.hp;
    lr.d = normalize(_light - _r.hp );
    
    float t = tmin;    
    float ss = 1.;
    for(int i=0; i<30; i++)
    {                
        vec3 p = lr.o + lr.d * t;
        float d = map(p).x;
        
        ss = min(ss, 1. * d / t);
        
        if(d < 0.002 || t > tmax)
            break;        
        
        t += clamp(d, .02, .1);
    }
    
    return clamp(ss,0.,1.);
}

// Function 1770
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = map( pos + h*nor );
        occ += (h-d)*sca;
        sca *= 0.95;
        if( occ>0.35 ) break;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;
}

// Function 1771
void updateLights()
{
	sphereRad		= cos( iTime * 0.3 ) * 0.025 + 0.05;
	spherePos		= vec3( sin( iTime * 0.25 ), abs( cos( iTime ) * 0.25 ) + sphereRad, 0.0 );
	
	tubeRad			= sin( iTime * 0.1 ) * 0.005 + 0.01;
	vec3 tubePos	= vec3( 0.0, sin( iTime * 0.3 ) * 0.1 + 0.2, cos( iTime * 0.25 ) );	

	vec3 tubeVec	= rotPitch(rotYaw(vec3(0,0,0.2), iTime*-1.5 ), cos( iTime*0.5 ) * 0.3 );
	
	tubeStart		= tubePos + tubeVec;
	tubeEnd			= tubePos - tubeVec;
}

// Function 1772
vec3 HeadLights(ray r, float t, float roadWith){

    t *= 2.;//make car faster than street lamp
    float w1 = .25;//light width
    float w2 = w1*1.2;
    const float s = 1./ 10.;
    float m = 0.;
    for(float i = 0.;i< 1.;i += s){
        float n =N(i);
        
        if(n > .345) continue;//jump to top,cut % light
        
        float ti = fract(t + i);
        float z =  100.- ti*100.;
        //fract(t + i), if i=.9,fract's value will rise to 1 in short time
        float fade = ti*ti*ti*ti;
        float focus = S(.8, 1., ti);
        float size = mix(.05, .03, focus);
        roadWith *= -.3;
        
        m += Bokeh(r, vec3(roadWith -1.-w1, .15 ,z ), size, .1)*fade;
        m += Bokeh(r, vec3(roadWith -1.+w1, .15 ,z ), size, .1)*fade;
        
        m += Bokeh(r, vec3(roadWith -1.-w2, .15 ,z ), size, .1)*fade;//extra light effect
        m += Bokeh(r, vec3(roadWith -1.+w2, .15 ,z ), size, .1)*fade;
        
        float ref = 0.;
        ref += Bokeh(r, vec3(roadWith -1.-w2, -.15 ,z ), size*3., 1.)*fade;
        ref += Bokeh(r, vec3(roadWith -1.+w2, -.15 ,z ), size*3., 1.)*fade;
        
        m += ref*focus;
        
    }
    
    
    return  vec3(.9, .9, 1.) *m;
}

// Function 1773
float shadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    float ph = 1e10; // big, such that y = 0 on the first iteration
    
    for(int i=ZERO; i<32; i++)
    {
		float h = map( ro + rd*t ).x;
        // use this if you are getting artifact on the first iteration, or unroll the
        // first iteration out of the loop
        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); 
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, 10.0*d/max(0.0,t-y) );
        ph = h;
        
        t += h;
        
        if( res<0.0001 || t>tmax ) break; 
    }
    return clamp( res, 0.03, 1.0 );
}

// Function 1774
float shadowMap3D(vec3 pos)
{
    float t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));
    t = min(t, sphere(pos, 2.0, greenSpherePos));
    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));
    return t;
}

// Function 1775
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1776
float shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout object co)
{
	float light_visibility = 1.;
	float ph = 1e5;
	pos.w = map(pos.xyz, co);
	for (int i = min(0, iFrame); i < 32; i++) 
    {
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = map(pos.xyz, co);
		float y = pos.w*pos.w/(2.0*ph);
        float d = (pos.w+ph)*0.5;
		float angle = d/(max(0.00001,dir.w-y)*light_angle);
        light_visibility = min(light_visibility, angle);
		ph = pos.w;
        if(i >= 31) return 0.;
		if(dir.w >= distance2light) break;
		if(dir.w > maxd || pos.w < max(mind*dir.w, 0.0001)) return 0.;
    }
	light_visibility = clamp(2.*light_visibility - 1.,-1.,1.);
	return  0.5 + (light_visibility*sqrt(1.-light_visibility*light_visibility) + asin(light_visibility))/3.14159265; //looks better and is more physically accurate(for a circular light source)
}

// Function 1777
float dlight(in vec3 rp) {
    return sdTorus(rp-vec3(0.,-5.,0.), vec2(5.,.3));
}

// Function 1778
vec3 CalculateLightingIBL(in vec3  n, in vec3  v, in vec3  a, in float r, in float m)
{
    vec3 f0 = mix(vec3(0.04), a, m);
    vec3 ks = vec3(0.0);
    vec3 d  = CalcDiffuse(a);
    vec3 s  = CalcSpecularIBL(n, v, f0, ks, r);
    vec3 kd = (1.0 - ks);
    
    return ((kd * d) + s);
}

// Function 1779
bool intersectIncludingLight(vec3 ro, vec3 rd, out vec3 hitPoint, out vec3 hitNormal,
		out float materialID) {
	bool result = intersect(ro, rd, hitPoint, hitNormal, materialID);

	if (!ShowLight) {
		return result;
	}
	float t = iSphere(ro, rd, LightPosition, LightRadius);
	if (t < 0.0) {
		return result;
	}

	if (result && distanceSqr(hitPoint, ro) <= t * t) {
		return result;
	}
	vec3 pos = ro + t * rd;
	hitPoint = pos;
	hitNormal = nSphere(pos, LightPosition, LightRadius);
	materialID = MAT_MAIN_LIGHT;

	return true;
}

// Function 1780
void constructLightPath( inout float seed ) {
    vec3 ro = randomSphereDirection( seed );
    vec3 rd = cosWeightedRandomHemisphereDirection( ro, seed );
    ro = lightSphere.xyz - ro*lightSphere.w;
    vec3 color = LIGHTCOLOR;
 
    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {
        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);
    }
    
    bool specularBounce;
    float w = 0.;
    
    for( int i=0; i<LIGHTPATHLENGTH; i++ ) {
		vec3 normal;
        vec2 res = intersect( ro, rd, normal );
        
        if( res.y > 0.5 && dot( rd, normal ) < 0. ) {
            ro = ro + rd*res.x;            
            color *= matColor( res.y );
            
            lpNodes[i].position = ro;
            if( !matIsSpecular( res.y ) ) lpNodes[i].color = color;// * clamp( dot( normal, -rd ), 0., 1.);
            lpNodes[i].normal = normal;
            
            rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );
        } else break;
    }
}

// Function 1781
vec3 Shade(MarchResult hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(.5);
    
    //Triangle grid pattern
    vec2 gridRep = mod(hit.position.xy, vec2(QUAD_SIZE)) / float(QUAD_SIZE) - 0.5;
    
    float grid = 0.5 - max(abs(gridRep.x), abs(gridRep.y));
    grid = min(grid, abs(dot(gridRep.xy, normalize(vec2(-1, 1)))));
    
    float lineSize = GRID_LINE_RADIUS * hit.dist / iResolution.y / float(QUAD_SIZE);
    
   // color *= 1.0-smoothstep(lineSize, lineSize * 0.25, grid);
    color = color * 0.75 + 0.25;
    color+=getRGB(hit.position.xy);
    //Lighting
    float ambient = 0.0;
    float diffuse = 0.5 * -dot(hit.normal, direction);
    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));
    specular*=.7;
    diffuse*=1.3;
    color *= vec3(ambient + diffuse + pow(specular, 5.0));
	
    //Fog / haze
    float sky = smoothstep(MAX_DIST - 1.0, 0.0, length(hit.position));
    float haze = 1. - (hit.steps / float(MAX_STEPS));
    
    vec3 skycol = mix(HAZE_COLOR, vec3(0), clamp(-hit.position.z * 0.2, 0.0, 1.0));
    
    //color = mix(skycol, color, .4-HAZEAMT+sky * haze);
    
    return color;
}

// Function 1782
vec3 shade (vec3 light, vec3 eye, vec3 pt, vec3 N)
{
	vec3 diffuse = vec3 (1., .45, .25);
	const float specularExponent = 10.;
	const float specularity = .45;
	vec3 L = normalize (light - pt);
    vec3 E = normalize (eye - pt);
	float NdotL = dot (N, L);
	vec3 R = L - 2. * NdotL * N;
	diffuse += abs (N) * .3;

    return diffuse * max (NdotL, .0) + specularity * pow (max (dot (E,R),.0), specularExponent);
}

// Function 1783
vec3 heartShadedColor() {
	vec2 off = vec2(0.01 * iTime, 0);
	vec2 pos = 0.15 * fragCoord.xy / iResolution.xy;
    vec3 rgb = texture(iChannel1, off + pos).xyz;
	float b = (rgb.x + rgb.y + rgb.z) * 0.33;
	b = 0.5 + 2.0 * b;
	return b * heartColor;
}

// Function 1784
vec3 GetLightColAt(int litID)
{
    	if (0 == litID) return vec3(1,.75,.5)*.5;
		if (1 == litID) return vec3(.5,.75, 1)*.5;
		return vec3(0);
}

// Function 1785
vec4 fragmentShader(in vec2 uv) {
    return texture(iChannel0, uv);
}

// Function 1786
float calcAO( in vec3 pos, in vec3 nor )
{
	float totao = 0.0;
    float sca = 1.0;
    for( int aoi=0; aoi<8; aoi++ )
    {
        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        totao += -(dd-hr)*sca;
        sca *= 0.85;
    }
    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );
}

// Function 1787
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;
    
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    
}

// Function 1788
vec3 getSkyLight(vec3 ro, vec3 rd, vec3 Lpos, vec3 betaR, vec3 betaM, out vec3 miecolor, float _hm)
{
    #define ERR vec3(1., 0., 0.)
    vec3 L = normalize(Lpos-ro);
    float tmin = -1.0;
    float tmax = -1.0;
    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);
    float temin = -1., temax = -1.;
    float de = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS, temin, temax);
    
    tmin = max(0., min(temin<0.?tmin:temin, tmin));
    tmax = min(tmax, temin<0.?tmax:temin);
    
    //tmax = max(1., min(max(0., temin), tmax));
  
    float RdotL = dot(rd, L);
    float tCurrent = tmin;
    float segL = (tmax-tCurrent)/16.0;
     
    float g = 0.76; // 0.76
    float g2 = g*g;
    float hr = 7994.0; // 7994
    float hm = _hm;//800.0; // 1200
    // Rayleigh
    vec3 sumR = vec3(0.0);
    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);
    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);
    float opticalDepthR = 0.0;
    // Mie
    vec3 sumM = vec3(0.0);
    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));
    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html
    // my implementation has an error with the first terms in the equation
    float phaseM = (
        			(3.0*(1.0-g2))/
        			(2.0*(2.0+g2))
        			)*
        			(
                        (1.0+RdotL*RdotL)/
                        pow(1.0+g2-2.0*g*RdotL, 1.5)
                    );
    //vec3 betaM = vec3(21e-6);
    float opticalDepthM = 0.0;
    for (int i = 0; i < 16; ++i)
    {
        vec3 X = ro+rd*(tCurrent+0.5*segL);
        float h = length(X) - EARTHRADIUS;
        float _hr = exp(-h/hr)*segL;
        float _hm = exp(-h/hm)*segL;
        opticalDepthR += _hr;
        opticalDepthM += _hm;
        vec3 lRay = L;//normalize((SUNDIST*L)-X);
        float tlmin = 0.0;
        float tlmax = 0.0;
        float tlemin, tlemax;
        vec3 Ll = normalize(Lpos-X);
        float dl = IntersectSphere(X, Ll, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);
    	//float dle = IntersectSphere(ro, rd, EARTHPOS, EARTHRADIUS, tlemin, tlemax);
    
        //tlmax = min(tlmax, tlemin);
        //tlmin = min(tlmin, tlemin);
        
        float tCurrentLight = 0.;//max(0., tlmin);
        float segLLight = (tlmax-tCurrentLight)/8.0;
        tCurrentLight = max(0., tlmin);
        segLLight = (tlmax-tCurrentLight)/8.;
        float opticalDepthLightR = 0.0;
        float opticalDepthLightM = 0.0;
        bool ended = true;
        for (int j = 0; j < 8; ++j)
        {
            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);
            float hLight = length(samplePositionLight) - EARTHRADIUS;
            if (hLight < 0.0)
            {
                ended = false;
                break;
            }
            opticalDepthLightR += exp(-hLight / hr) * segLLight;
            opticalDepthLightM += exp(-hLight / hm) * segLLight;
            tCurrentLight += segLLight;
        }
        if (ended)
        {
            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);
            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));
            sumR += _hr * attenuation;
            sumM += _hm * attenuation;
        }
        tCurrent += segL;
    }
    miecolor = SUNINTENSITY * sumM * phaseM;
    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);
}

// Function 1789
vec3 sampleLightBRDF( in vec3 hitOrigin, in vec3 hitNormal, in vec3 rayDir, in Material material  )
{
    vec3 brdf = vec3( 0 );
    vec3 s = vec3( 0 );

    Light light;
    light.id = 3.0;
    light.emission = LIGHT1_EM;

    vec3 l0 = vec3( 2, 2, 4 ) - hitOrigin;

    float cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    float cosa = mix(cos_a_max, 1., random());
    vec3 l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    vec3 lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );        
#endif
    {
        float roughness = 1.0 - material.smoothness * material.smoothness;
        float metallic = material.metallic;

        float omega = 2. * PI * (1. - cos_a_max);
        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);
    }

    light.id = 4.0;

    l0 = vec3( -4, 1.5, 4 ) - hitOrigin;

    cos_a_max = sqrt(1. - clamp(0.5 * 0.5 / dot(l0, l0), 0., 1.));
    cosa = mix(cos_a_max, 1., random());
    l = jitter(l0, 2.*PI*random(), sqrt(1. - cosa*cosa), cosa);

#if (PATH == 1)
    lightHit = castRay( hitOrigin, l, 0.001, 100.0 );
    if ( lightHit.z == light.id )
#else
    s += softshadow( hitOrigin, normalize(l0) );        
#endif
    {
        float roughness = 1.0 - material.smoothness * material.smoothness;
        float metallic = material.metallic;

        float omega = 2. * PI * (1. - cos_a_max);
        brdf += ((light.emission * clamp(ggx( hitNormal, rayDir, l, roughness, metallic),0.,1.) * omega) / PI);
    }

#if (PATH == 0)
    brdf *= clamp( s, 0., 1. );
#endif
    
    return brdf;
}

// Function 1790
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = 0; j < 16; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += 0.07;
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1791
float shadow(vec3 P, vec3 lightPos, float lightRad, vec3 occluderPos, float occluderRad)
{
	float radA = lightRad;
	float radB = occluderRad;
	
	vec3 vecA = lightPos - P;
	vec3 vecB = occluderPos - P;
	
	float dstA = sqrt(dot(vecA, vecA));
	float dstB = sqrt(dot(vecB, vecB));
	
	if (dstA - radA / 2.0 < dstB - radB) return 1.0;
	
	float sinA = radA / dstA;
	float sinB = radB / dstB;
	
	float cosA = sqrt(1.0 - sinA * sinA);
	float cosB = sqrt(1.0 - sinB * sinB);
	
	if (cosA * dstA < cosB * dstB) return 1.0;
	
	vec3 dirA = vecA / dstA;
	vec3 dirB = vecB / dstB;
	
	float cosG = dot(dirA, dirB);
	
	if (cosG < cosA * cosB - sinA * sinB) return 1.0;
	
	float sinG = length(cross(dirA, dirB));
	
	float cscA = dstA / radA;
	float cscB = dstB / radB;
	
	float cosTheta = clamp((cosB - cosA * cosG) * cscA / sinG, -1.0, 1.0);
	float cosPhi = clamp((cosA - cosB * cosG) * cscB / sinG, -1.0, 1.0);
	
	float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
	float sinPhi = sqrt(1.0 - cosPhi * cosPhi);
	
	float theta = acos(cosTheta);
	float phi = acos(cosPhi);
	
	float unoccluded = theta - cosTheta * sinTheta 
					 + (phi - cosPhi * sinPhi)
					 * cosG * sinB * sinB / (sinA * sinA);
	
	return 1.0 - unoccluded / PI;
}

// Function 1792
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<80; i++ )
    {
		float h = df( ro + rd*t ).x;
        res = min( res, 8.*h/t );
        t += clamp( h, 0.01, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1793
float calcAO( in vec3 pos, in vec3 nor )
{
  float occ = 0.0;
  float sca = 1.0;
  for ( int i=0; i<NO_UNROLL(3); i++ )
  {
    float hr = 0.01 + 0.15*float(i);
    vec3 aopos =  nor * hr + pos;
    float dd = MapTerrain( aopos ).x;
    occ += -(dd-hr)*sca;
    sca *= 0.96;
  }
  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1794
float ao(vec3 p, vec3 n) {
    float r = 0.0;
    float w = 1.0;
    float d;
    
    for(float i = 1.0; i < 6.6; i++) {
        d = i/6.0;
        r += w*(d - map(p + n*d).x);
        w *= .5;
    }
    
    return 1.0 - clamp(r, 0.0, 1.0);
}

// Function 1795
float getShadow(vec3 pt) {
  vec3 lightDir = normalize(lightPos - pt);
  float kd = 1.0;
  int step = 0;
  float t = 0.1;

  for (int step = 0; step < renderDepth; step++) {
    float d = getSdf(pt + t * lightDir);
    if (d < 0.001) {
      kd = 0.0;
    } else {
      kd = min(kd, 16.0 * d / t);
    }
    t += d;
    if (t > length(lightPos - pt) || step >= renderDepth || kd < 0.001) {
      break;
    }
  }
  return kd;
}

// Function 1796
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    
    
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );
    
    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 1.0, 5.8), vec3(1,1,1) );
    
    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
    // AO
    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;
    
    return surfaceLighting;
}

// Function 1797
vec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {
    
    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;
    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;
    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;
    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;
    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;

    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max(
        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
        FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
    
    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
          dir * rcpDirMin)) * rcpFrame.xy;

    vec3 rgbA = (1.0/2.0) * (
        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +
        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);
    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +
        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);
    
    float lumaB = dot(rgbB, luma);

    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;
    
    return rgbB; 
}

// Function 1798
float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );
}

// Function 1799
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )
{
    // first things first - let's do a bounding volume test
    vec2 sph = iCylinderY( ro, rd, 1.5 );
  //vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);
    tmax = min(tmax,sph.y);

    // raymarch and track penumbra    
    float res = 1.0;
    float t = mint;
    for( int i=0; i<128; i++ )
    {
        float kk; vec3 kk2;
		float h = map( ro + rd*t, time, kk, kk2 ).x;
        res = min( res, k*h/t );
        t += clamp( h, 0.005, 0.1 );
        if( res<0.002 || t>tmax ) break;
    }
    return max( res, 0.0 );
}

// Function 1800
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += max (0.05, h);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1801
vec4 shade(vec2 uv) {
    
    if(uv.x < 0.0 || uv.y < 0.0 || uv.x > 1.0 || uv.y > 1.0)
        return vec4(0.0);
    
    vec2 c = uv;
    
    float f = sin(c.x) * sin(c.y);
    
    return vec4(uv.x, uv.y, 1.0, 1.0);
}

// Function 1802
float GetShadow(vec3 p, vec3 plig)
{   vec3 lightPos = plig;
    vec3 l = normalize(lightPos-p);
    vec3 n = GetNormal(p);
    float dif = clamp(dot(n, l), 0., 1.);
    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);
    if(d<length(lightPos-p)) dif *= .1;
    return dif;
}

// Function 1803
vec4 shade(vec3 p, vec3 n) {
    float c = max(0.0,dot(-lightDirection,n));
    //return vec4(c,c,c,1.0);
    return vec4(c,c,c,1.0);
}

// Function 1804
float calcSoftshadow_o354278( in vec3 ro, in vec3 rd, in float mint, in float tmax){
	float res = 1.0;
    float t = mint;
    float ph = 1e10; // big, such that y = 0 on the first iteration
    for( int i=0; i<32; i++ ){
		float h = input_o354278( ro + rd*t ).x;
        res = min( res, 10.0*h/t );
        t += h;
        if( res<0.0001 || t>tmax ) break;  
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1805
float dir_light(vec3 n, vec3 l)
{return dot(n, normalize(l))*0.5 + 0.5;}

// Function 1806
float softShadow(vec3 ro, vec3 rd, float k) {
  float res = 1.0;
    float ph = 1e20;
    for( float t = 0.; t<100.;)
    {
        float h = map(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min( res, k*d/max(0.0,t-y) );
        ph = h;
        t += h;
    }
    return res;
}

// Function 1807
float SoftShadow( in vec3 origin, in vec3 direction )
{
  float res = 1.0, t = 0.0, h;
  for ( int i=0; i<NO_UNROLL(16); i++ )
  {
    h = Map(origin+direction*t);
    res = min( res, 7.5*h/t );
    t += clamp( h, 0.02, 0.15);
    if ( h<0.002 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 1808
Color3 shadowedAtmosphereColor(vec2 fragCoord, vec3 iResolution, float minVal) {
    vec2 rel = 0.65 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;
    const float maxVal = 1.0;
    
    float a = min(1.0,
                  pow(max(0.0, 1.0 - dot(rel, rel) * 6.5), 2.4) + 
                  max(abs(rel.x - rel.y) - 0.35, 0.0) * 12.0 +                   
	              max(0.0, 0.2 + dot(rel, vec2(2.75))) + 
                  0.0
                 );
    
    float planetShadow = mix(minVal, maxVal, a);
    
    return atmosphereColor * planetShadow;

}

// Function 1809
float4 shade(float3 p, float displace)
{	
	// lookup in color gradient
	displace = displace*1.5 - 0.2;
	displace = clamp(displace, 0.0, 0.99);
	float4 c = gradient(displace);
	//c.a *= smoothstep(1.0, 0.8, length(p));
	
	// lighting
	float3 n = dfNormal(p);
	float diffuse = n.z*0.5+0.5;
	//float diffuse = max(0.0, n.z);
	c.rgb = mix(c.rgb, c.rgb*diffuse, clamp((displace-0.5)*2.0, 0.0, 1.0));
	
	//return float4(float3(displace), 1);
	//return float4(dfNormal(p)*float3(0.5)+float3(0.5), 1);
	//return float4(diffuse);
	//return gradient(displace);
	return c;
}

// Function 1810
vec3 doLighting(vec3 pos,vec3 rd,vec3 n,float occ
){ ;v33 rrr=v33(pos,rd)//seems to be a shared light source position
 ;float sh=miv(vec4(sssp(rrr,sc0),sssp(rrr,sc1),sssp(rrr,sc2),sssp(rrr,sc3)))
 ,dif=sat(dot(n,vec3(.57703)));float bac=sat(dot(n,vec3(-.707,.0,-.707)))
 ;vec3 lin=dif*sh*vec3(1.5,1.4,1.3)
 ;lin+=occ*vec3(.15,.2,.3);lin+=bac*vec3(.1);return lin;}

// Function 1811
float softshadow(in vec3 ro, in vec3 rd) {
#ifdef FAST
	return 1.;
#else

	float res = 1.0, h, t = .02;
    for( int i=0; i<16; i++ ) {
	//	if (t < maxt) {
		h = map0(ro + rd*t, true, true);
		res = min( res, 1.*h/t );
		t += 0.3;
	//	}
    }
    return clamp(res, 0., 1.);
#endif	
}

// Function 1812
float dlight(in vec3 rp) {
    return udBox(rp-vec3(0.,-3.,0.),vec3(1.,.1,1.));
    //return sdTorus(rp-vec3(0.,-5.,0.), vec2(5.,.3));
}

// Function 1813
sLight getDirLight() {
    sLight result;
    result.rd  = normalize(vec3(-0.2, -0.3, 0.5));
    result.col = vec3(8.0, 7.5, 7.0);
    return result;
}

// Function 1814
Intersection traceShadow(in Ray ray)
{
    Intersection bestIts;
	bestIts.t = ray.tMax;
    bestIts.isLight = false;
    
    for (int i = 0; i < AMOUNT_LIGHTS; ++i)
    {
        Intersection its = intersectLight(ray, lights[i]);
        if (its.t < bestIts.t)
        {
            bestIts = its;
            bestIts.isLight = true;
            bestIts.light = lights[i];
        }
    }
    
    for (int i = 0; i < AMOUNT_SPHERES; ++i)
    {
        Intersection its = intersectSphere(ray, spheres[i]);
        if (its.t < bestIts.t)
        {
            bestIts = its;
            bestIts.m = spheres[i].m;
            bestIts.isLight = false;
            return bestIts;
        }
    }

    return bestIts;
}

// Function 1815
vec3 GetAmbientLight(const in vec3 vNormal)
{
    return GetSkyGradient(vNormal);
}

// Function 1816
vec3 ShadeSolid( ShadeData s )
{
	return vec3(.8) * DiffuseLight(s);
}

// Function 1817
float softShadow(vec3 pos, vec3 rayDir, float start, float end, float k ){
    float res = 1.0;
    float depth = start;
    for(int counter = ZERO; counter < MAX_STEPS; counter++){
        float dist = getSDF(pos + rayDir * depth);
        if( abs(dist) < EPSILON){ return 0.0; }       
        if( depth > end){ break; }
        res = min(res, k*dist/depth);
        depth += dist;
    }
    return res;
}

// Function 1818
void shade(vec3 pos, out vec3 color)
{
    vec3 surfNormal = computeNormalAt(pos);
    
    float h = pos.x * 0.25;
    vec3 albedo = hsv2rgb(vec3(h, 0.9, 0.8));
    
    // semisphere lighting
    float dtSky = dot(surfNormal, vec3(0., 0., 1.));
    vec3 diff = (dtSky * 0.5 + 0.5) * evaluateAmbient(pos, surfNormal)
        * vec3(0.4, 0.7, 0.4);
    color.xyz = albedo * diff;
    
    // directional lighting
    color.xyz += evaluatePointLight(pos, surfNormal,
        normalize(vec3(0.5, 1., 1.)), albedo);
    
    // environemntal mapping
    color.xyz += evaluateReflection(pos, surfNormal);
}

// Function 1819
vec2 shade( in vec3 pos, in vec3 nor, in float m, in float t, in bool reflection ) {
    float refl = 0.1;
    float mate = 0.;
 	float light = 0.;            
    float col = 0.;
    
    if( m < .5 ) {
   		if( pos.y < .01 ) {
	    	mate = .05 * (.25+.2*texture( iChannel1, pos.xz*.05 ).r);
            float x = abs(pos.x);
            if( (x > 12. && x < 14.8) ||  (x > 3.2 && x < 6.8) || abs(pos.z) > 68.4 ) mate *= 0.25;
        } else if( pos.y > 13.5 && pos.y < 13.99 && abs( pos.x ) > 27.99 ) {
            light = matSideLamp( pos, nor ); 
        } else if( pos.z > 62. && pos.y > 52. ) {
            light = matOutdoorLight( pos, nor );
        } else {
 			mate = matMarble( pos, nor );
            refl = 0.05;
   		}
        if( abs(mapDamageHigh(pos)-map(pos)) > 0.0001 * t ) {
            refl = 0.;
            mate = 0.21;
        }
        if( abs( pos.z ) > 73.1 ) {
            mate = 0.02;
            if( mod( abs( pos.x ), 2.25 ) < .3 ||
            	mod( abs( pos.y ), 2.25 ) < .3 ) mate = 0.0025;
            refl = 0.02;
        }
            
        if( nor.y < -0.8 && pos.y > 13.49 ) {
            col += mate * (0.4 * pow( max( (abs(pos.x*.38)-7.2),0.), 2.));
        }        
    } 
#if RENDERDEBRIS
    else if( m < 1.5 ) {
            refl = 0.;
            mate = 0.1 * noise(pos);
    }
#endif
    
    col += mate * (
        25. * ( 0.02 +
        .2 * min(1., max( -nor.x * sign(pos.x), 0.)) + 
        .5 * min(1., max( nor.y, 0. )) +
        .05 * abs( nor.z ) ) * calcFakeAOAndShadow( pos ) );
    
    col *= calcAO( pos, nor );
    col += light;
    
    return vec2( col, refl );
}

// Function 1820
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
		float h = dstScene( ro + rd*t );
        res = min( res, 32.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1821
float raymarchAO(in vec3 ro, in vec3 rd, float tmin) {
    float ao = 0.0;
    for (float i = 0.0; i < 5.0; i++) {
        float t = tmin + pow(i / 5.0, 2.0);
        vec3 p = ro + rd * t;
        float d = p.y - fBm(p.xz);
        ao += max(0.0, t - 0.5 * d - 0.05);
    }
    return 1.0 - 0.4 * ao;
}

// Function 1822
vec3 shadeP( in vec3 p,in vec3 rd, float idx)
{
    vec3 mat = idx < 0.5 ? vec3(0.6,0.2,0.1) : vec3(0.4,0.7,0.9);
    vec3 l = normalize(vec3(1.0,1.0,1.0));
    vec3 n = norm(p);
    float s = shadow(p,l,8.0);
    float rs = shadow(p,reflect(rd,n),12.0);
    
    vec3 col = vec3(0.1)*mat;
    col += clamp(dot(l,n),0.0,1.0)*mat*s*0.8;
    col += pow(clamp(dot(reflect(rd,n),l),0.0,1.0),150.0)*0.1;
    col += pow(1.0-clamp(dot(-rd,n),0.0,1.0),3.0)*vec3(0.6,0.7,1.0)*0.2;
    col += 0.1*rs*vec3(0.5,0.8,1.0);
    
    return col;
}

// Function 1823
vec3 GetLightDirection(vec3 pos)
{
    return normalize(pos - lightPos);
}

// Function 1824
float shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax, in float sft)
{
	float rz = 1.0;
    float t = mint;
    for( int i=0; i<20; i++ )
    {
		float h = map(ro + rd*t);
        rz = min(rz, sft*h/t);
        t += clamp(h, 0.01, .1);
        if(h<0.0001 || t>tmax) break;
    }
    return clamp(rz, 0.0, 1.0);
}

// Function 1825
float shadow(vec3 ro, vec3 rd, float t, float d, float res) {
    for (int i=0; i<11; i++)
        res = min(res, 8. * (d=map(ro + rd*t).w) / (t += clamp(d,.02,.1)));
    return clamp(res, 0., 1.);
}

// Function 1826
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, 
    //anyway.
    const int maxIterationsShad = 24; 
    
    ro += n*.0015;
    vec3 rd = lp - ro; // Unnormalized direction ray.
    

    float shade = 1.;
    float t = 0.;//.0015; // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .25); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 1827
float getShadow(vec3 origin, vec3 destination, float soft, float time) {
    float currentDistance = OBJECT_MIN_SURFACE_DISTANCE_SHADOW;
    float maxDistance = distance(destination, origin);
    vec3 direction = normalize(destination-origin);
    rayMarchHit rayMarchHit;
    float light = 1.0;

    for(int i=0; i<RAY_MAX_STEPS_SHADOW; i++) {
        vec3 currentPoint = origin + direction*currentDistance;
        rayMarchHit = GetRayMarchHit(currentPoint, time);
        //Soft Shadows!
        light = min(light,soft * rayMarchHit.distance/currentDistance);
        currentDistance += rayMarchHit.distance;
        if(currentDistance > maxDistance) {
            break;
        } else if(rayMarchHit.distance < OBJECT_MIN_SURFACE_DISTANCE_SHADOW) {
            light = 0.0;
            break;
        }
    }

    return light;
}

// Function 1828
float ObjAO (vec3 ro, vec3 rd)
{
  float ao, d;
  ao = 0.;
  for (float j = 1.; j < 4.; j ++) {
    d = 0.02 * j;
    ao += max (0., d - ObjDf (ro + d * rd));
  }
  return 0.5 + 0.5 * clamp (1. - 5. * ao, 0., 1.);
}

// Function 1829
float getLight(vec3 p,vec3 lp,vec3 dir)
{
    return (dot(getNorm(p),normalize(lp - p)) + dot(qrot(getNorm(p),dir,180.),normalize(lp - p)) )/2.;
}

// Function 1830
float shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = .1;
	float h;
	vec3 p;
    for (int i = 0; i < 12; i++)
	{
        p =  ro + rd*t;
 		
		h = DF(p, false);
      	res = min(5.*h / t, res);
        res = max(res, hitSpecs ? .4: .05);

		t += h;
	}
    return res;
}

// Function 1831
int chooseOneLight(in vec3 x, in float Xi, out float pdf) {
#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE
    float cdf[LIGHT_COUNT];
    
    for(int i=0; i<LIGHT_COUNT; i++) {
        float len = length(lights[i].pos - x);
        cdf[i] = 1.0 / (len * len);
    }
    
    for(int i=1; i<LIGHT_COUNT; i++) {
        cdf[i] += cdf[i - 1];
    }
    
    for(int i=0; i<LIGHT_COUNT; i++) {
        cdf[i] /= cdf[LIGHT_COUNT-1];
    }
    
    int id = 0;
    for(int i=0; i<LIGHT_COUNT; i++) {
        if(Xi < cdf[i]) {
        	id = i;
            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);
            break;
        }
    }
    
    return id;
#else
   	pdf = 1.0/float(LIGHT_COUNT);
    return int(Xi*float(LIGHT_COUNT));
#endif
}

// Function 1832
float calcAO( in vec3 pos, in vec3 nor )
{
    float totao = 0.0;
    for( int aoi=0; aoi<16; aoi++ )
    {
        vec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);
        aopos *= sign( dot(aopos,nor) );
        aopos = pos + aopos*0.5;
        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );
        totao += dd;
    }
    totao /= 16.0;
    return clamp( totao*totao*1.5, 0.0, 1.0 );
}

// Function 1833
float gasGiantShade(vec4 gasGiant, vec3 p) {
  vec2 rsi = raySphere(p, innerSunDir, gasGiant);

  // Fake, fake softshadows
  return rsi.x >= 0.0 && rsi.x < miss ? exp(-3.0*(rsi.y - rsi.x)/(rsi.x+0.1)) : 1.0;
}

// Function 1834
vec3 Shade(MC hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(0.0);
    vec3 rd = color;
    vec3 skydomeColor = color;
    
    if(hit.id == SKYDOME)
    {
 
        //vec2 v = fwidth(hit.position.xy);
        //vec4 soundNoise = texture(iChannel3, v);
        
        //Sky gradient
    	color = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, -hit.position.z/7.0);
        //nice
        //color = mix(SKY_COLOR_1, SKY_COLOR_2, hit.position.z/9.0);
        
        //Sun
        vec3 sunDir = normalize(SUN_DIRECTION);
        
        float sun = smoothstep(0.9430, 0.975, dot(direction, sunDir));
        sun -= smoothstep(0.1, 0.9, 0.5);
        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, hit.position.z/2.5);
        
        color = mix(color, sunCol, sun) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;
    }
    
    //if(hit.id == OCTAGON)
    //{
    //    color = texture(iChannel1, hit.position.xy).rgb *0.5;
    //}
    

    if(hit.id == FLOOR)
    {
        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); 
        
        uv /= fwidth(hit.position.xy);
                                                       
        float gln = min(min(uv.x, uv.y), 1.) / GRID_SIZE;
    	color = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));
        
        // darker on the sides
        vec3 normal = vec3(0.,-0.5,0.);
        vec3 rfld = reflect( direction, normal );
        float reflectstrength = 1.-abs(dot( direction, normal ));
        color *= reflectstrength;

    } 
    
    //Distance fog
    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )/70.;
    
    return color;
}

// Function 1835
void initLightSphere( float time ) {
	lightSphere = vec4( 2.5+2.2*sin(time),3.+2.*sin(time*0.7),6.0 + 1.0 * sin(time*1.7), 0.6 + 0.4 * sin(time*.5) );
}

// Function 1836
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.01;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1837
vec3 simulate_lightmap_distortion(vec3 surface_point)
{
    surface_point = floor(surface_point);
    surface_point *= 1./LIGHTMAP_SCALE;
    vec3 f = fract(surface_point + .5);
    return (surface_point + f - smoothen(f)) * LIGHTMAP_SCALE;
}

// Function 1838
vec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)
{       
    return (albedo * Saturate(dot(normal, vec3(0.0, -1.0, 0.25)))) + (albedo * ambient);
}

// Function 1839
float calcAO(in vec3 pos, in vec3 nor) {
#ifdef FAST	
	return 1.;
#else
	float dd, hr=.01, totao=.0, sca=1.;	
    for(int aoi=0; aoi<5; aoi++ ) {
        dd = map(nor * hr + pos, true, true).x;
        totao += -(dd-hr)*sca;
        sca *= .75;
        hr += .05;
    }
    return clamp(1.-4.*totao, 0., 1.);
#endif
}

// Function 1840
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<50; i++)
    {
    	float h = map(ro + rd*t).x;
        res = min( res, 10.0*h/t + 0.02*float(i));
        t += 0.8*clamp( h, 0.01, 0.35 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1841
vec4 shade(vec3 v, float f) {
	float highlight = pow(f*.5+.5,100.);
	return vec4(pow(f*.5+.5,10.)*v*1.5*(1.-highlight)+highlight,1.)/PI;
}

// Function 1842
void ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in vec3 rayDir)
{
	if (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))
	{
		// diffuse
		vec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);
		float dp = dot(collisionInfo.m_surfaceNormal, hitToLight);
		if(dp > 0.0)
			pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color;
				
		// specular
		vec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color;
	}
}

// Function 1843
vec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {
    vec3 sd = rp+normal2(rp)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;
    
    //lighting
    vec3 reflDir = reflect(rd,norm);

    vec3 lightDif,lightSpec;
    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);

    return (1.-m.metallic)*lightDif*m.diffuse +
        	(.5+m.metallic*.5)*lightSpec*m.specular +
        	m.emissive ;
}

// Function 1844
float calcAO( in vec3 p, in vec3 n )
{
	float ao = 0.0, l;
    const float maxDist = 4.;
	const float nbIte = 6.0;
	//const float falloff = 0.9;
    for( float i=1.; i< nbIte+.5; i++ ){
    
        l = (i + hash(i))*.5/nbIte*maxDist;
        
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp(1.- ao/nbIte, 0., 1.);
}

// Function 1845
vec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){
    float lambertian = max(dot(lightDir,trace.normal), 0.0);
  	return  lambertian * trace.material.color.diffuse * lightColor; 
}

// Function 1846
vec3 LightSample(vec3 p,float x1,float x2,out vec3 wo,out float dist,out float pdf){
	vec3 v0v1 = quads[0].v1 - quads[0].v0;
    vec3 v0v3 = quads[0].v3 - quads[0].v0;
    float width  = length(v0v1);
    float height = length(v0v3);
    vec3 O = quads[0].v0 + v0v1*x1 + v0v3*x2;
    wo = O - p;
    dist = length(wo);
    wo = normalize(wo);
    float costhe = dot(-wo,quads[0].normal);
    pdf = PDF_Area2Angle(1./(width*height),dist,clamp(costhe,0.00001,1.));
    return costhe>0. ? GetLightIntensity(): vec3(0.);
}

// Function 1847
vec3 shade_scene( vec3 ip, vec3 ro, vec3 rd )
{
    vec3 lpos = 4. * vec3(0., 1., 0.);
    vec3 n = surface_normal( ip );
    vec3 ldir = normalize(lpos - ip);
    
    float s = soft_shadow( ip, ldir, .02, 10., 10.);
    float ao = ambient_occ( ip, n );
    
    float mody = mod(4. * ip.y, 1.);
    float stripes = step(length(ip.xz), 14.) * (smoothstep(0., .05, mody) - smoothstep(.5, .55, mody));
    vec3 scol =  mix(vec3(.5, .6, 1.), vec3(.2, .2, .4), stripes);

    float falloff = pow(max(0., 1. - length(lpos - ip)/19.), 2.);

    vec3 diff = 5. * scol * max(0., dot(ldir, n));
    vec3 spec = vec3(2.) * pow(max(0., dot(ldir, reflect(rd, n))), 8.);
    vec3 amb = scol * .8 * (1. - ao);
    vec3 bnc = scol * .6 * pow(ip.y + 1.3,2.) * max(0., dot(n, normalize(ro - ip + vec3(0., -8., 0.))));
    
    return falloff * (s * (diff + spec) + 
           		      (amb + bnc));
}

// Function 1848
TraceResult traceLight(Light light, vec3 orig, vec3 dir)
{
    TraceResult res;
    
    vec3 pos = orig - light.pos;
    
    float a = dot(dir, dir);
    float b = dot(pos, dir);
    float c = dot(pos, pos) - sqr(light.radius);
    
    float D = sqr(b) - a * c;   
    if (D < 0.0) {
        return res;
    }
    
    float t1 = -b - sqrt(D);
    if (t1 < 0.0) {
        t1 = INF;
    }
    
    float t2 = -b + sqrt(D);
    if (t1 < 0.0) {
        t1 = INF;
    }
    
    float t = min(t1, t2);
    if (t == INF) {
        return res;
    }
   
    res.n = normalize(pos + t * dir);
    res.dist = t;
    res.hit = true;
    return res;
}

// Function 1849
vec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)
{
	vec3 p = ro + rd * d;												// surface point
	float sb = SubDensity(p, 0.001, 0.1);							// deep subdensity (10 iterations)
	vec3 bb = blackbody(100.*sb+100.);								// blackbody color according to the subdensity value
	vec3 ld = normalize(lp-p); 											// light dir
	vec3 n = nor(p, .01);												// normal at surface point
	n = doBumpMap(iChannel0, -p*0.5, n, 0.015);					// use bumpmap fnc of shane here
	vec3 refl = reflect(rd,n);											// reflected ray dir at surf point 
	float amb = 0.08; 													// ambiance factor
	float diff = clamp( dot( n, ld ), 0.0, 1.0 ); 					// diffuse
	float fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); 		// fresnel
	float spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);		// specular
	float sss = 1. - SubDensity(p*0.1, 5.) * 0.5; 					// one step sub density of df
	return vec4(															// some mix of WTF :) i tried many different things and this i choose :) but maybe there is other things to do
        (diff + fre + bb.x * sss) * amb + diff * 0.5, 
        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05	
    );
}

// Function 1850
vec3 light(Surface surface, vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos, float time)
{
    vec3 lvec = normalize(lpos - pos);
    vec3 hvec = normalize(lvec - ray);
    float llen = length(lpos - pos);
    float sha = (softshadow(pos, lvec, 0.01, length(lpos - pos), 4.0, time) + 0.25) / 1.25;
    vec3 diffuse = surface.diffuse * col  * (1.0 / PI);
    
    float rough = surface.roughness;
    float bpnorm = ( rough + 2.0 ) / ( 2.0 * PI );
	vec3 spec = surface.specular * col * bpnorm * pow( max( 0.0, dot( normal, hvec ) ), rough );
    
    vec3 nor = 19.3602379925 * surface.pattern;
    vec3 emission = surface.emission.rgb;
    if (length(surface.pattern.rgb) > 0.0) {
    	emission *= min(vec3(1.0),  tex(nor.zy, 113.09) + tex(nor.xz, 113.09) + tex(nor.xy, 113.09));
    }
    
    diffuse *= sha;
    spec *= sha;
    return vec3(diffuse + spec) / (llen * llen) + emission * (sin(time) * 0.5 + 0.5 + 0.2);
    //return vec3(sha);
}

// Function 1851
vec3 GetLightCol()
{
	return vec3(482.0, 190.0, 200.0);
}

// Function 1852
float softShadow(vec3 ro, vec3 rd)
{
    float res = 1.0;
    for (float t = 0.1; t < 8.0;)
    {
        float h = map(ro + t * rd).x;
        if (h < 0.001) return 0.0;
        res = min(res, 8.0 * h/t);
        t+= h;
    }
    
    return res;
}

// Function 1853
float ObjSShadow (vec3 ro, vec3 rd)
{
  float dTol = 0.01;
  float sh = 1.;
  float d = 0.07 * szFac;
  for (int i = 0; i < 50; i++) {
    float h = ObjDf (ro + rd * d);
    sh = min (sh, 20. * h / d);
    d += 0.07 * szFac;
    if (h < dTol*(1.0+d)) break;
    dTol *= 1.01;
  }
  return clamp (sh, 0., 1.);
}

// Function 1854
vec3 Light(int m, vec3 p, vec3 n, vec3 v)
{
//    if (m == mSky) return vec3(0);
    return mix(n.y, 1., .5) * vec3(1);
}

// Function 1855
vec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)
{
 	vec3 dir = normalize(l.pos - pos);  
    vec3 viewDir = normalize(camPos - pos);
    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;
    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);

    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));
    //col = colQuant(2.0, col);
    return col;
}

// Function 1856
vec3 light(in Ray ray, in vec3 n) {
    // get the half-angle
    ray.dir = (ray.dir, n) * 0.5;
    return backgroundColour(ray, 0.0) * (n.y + n.z) * 0.5;
}

// Function 1857
vec3 shade(Ray ray) {
 
    Hit scn  = raymarch(ray);
    vec3 col = texture(iChannel0, ray.dir).xyz;
    
    if(scn.id == 0) {
     
        vec3 n = calcNormal(scn.p);
        vec3 r = reflect(ray.dir, n);
        
        Ray rr = Ray(scn.p + r * .001, r);
        Hit rh = raymarch(rr);
        
        float sh = softShadow(scn.p, LIGHT_DIR, .0015, 10.);
        vec3  dc = getPylonDiffuse(n, sh, scn);
        vec3 rc  = 
            rh.id == 0 ? getPylonDiffuse(calcNormal(rh.p),softShadow(scn.p, LIGHT_DIR, .0015, 10.),rh) : 
            rh.id == 1 ? getFloorDiffuse(rh) :
            texture(iChannel0, rr.dir).xyz;
        
        vec3 s = LIGHT_COL * pow(max(dot(LIGHT_DIR,r),0.), 30.) * softShadow(scn.p, LIGHT_DIR, .0015, 10.);
        float f = mix(.1, .9, 1. - max(pow(-dot(ray.dir,n), .1), 0.));
        return mix(dc, rc, f) + s;
        
        
    } else if(scn.id == 1) {
    
        col = getFloorDiffuse(scn);
    
    }
    
    return col;
    
}

// Function 1858
float GetLight(vec3 p){
    //position of the light source
    
    
    //lightPos.xz += vec2(sin(iTime),cos(iTime));
    //light vector
    vec3 l = normalize(lightPos-p);
    
    //normal of object
    vec3 n = GetNormal(p);
    
    // dot product of the light vector and normal of the point
    // will give us the amount of lighting to apply to the point
    // dot() evaluates to values between -1 and 1, so we will clamp it
    float diff = clamp(dot(n, l),0.,1.);
    
    // calculate if point should be a shadow:
    // raymarch from point being calculated towards light source
    // if hits surface of something else before the light,
    // then it must be obstructed and thus is a shadow
    // the slight offset "p+n*SURFACE_DIST*1.1" is needed to ensure the
    // break condistions in the function are not met too early
    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;
    if(d < length(lightPos-p)){
        diff *= .1;
    }
    
    return diff;
}

// Function 1859
vec4 drawLight(vec2 p, vec2 pos, vec4 color, float dist, float range, float radius)
{
	// distance to light
	float ld = length(p - pos);
	
	// out of range
	if (ld > range) return vec4(0.0);
	
	// shadow and falloff
	float shad = shadow(p, pos, radius);
	float fall = (range - ld)/range;
	fall *= fall;
	float source = fillMask(circleDist(p - pos, radius));
	return (shad * fall + source) * color;
}

// Function 1860
float softshadow(vec3 ro, vec3 rd) {
    float res = 1.0;
    for (float t=1.; t<10.;) {
        float h = map(ro + rd*t).dist;
        if (h < 0.001)
            return 0.0;
        res = min(res, 8.*h/t);
        t += h;
    }
    return res;
}

// Function 1861
vec4 SampleLights( vec3 pos )
{
	// like then Normal calc
	vec2 d = vec2(-1,1) * .1;
	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 = Lights(p0);
	float f1 = Lights(p1);
	float f2 = Lights(p2);
	float f3 = Lights(p3);
	
	// this direction is completely  innaccurrate for hard-edged intersections!
	// it gets one or other surface normal, rather than a smoothed result
	// so, build smooth light shapes
	
	return vec4(
				-normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) ),
				(f0+f1+f2+f3)/4.0
			);
}

// Function 1862
vec3 shadeBox(Ray ray, Hit scn) {
 
    vec3 n = calcNormal(scn.p);
    vec3 r = reflect(ray.dir, n);
    
    float sh = getShadow(Ray(scn.p+LIGHT_DIR*EPSILON,LIGHT_DIR));
    vec3 d = (vec3(max(dot(LIGHT_DIR,n), 0.)) * sh) * LIGHT_COL + LIGHT_AMB;
    vec3 s = (max(pow(dot(LIGHT_DIR,r), 30.), 0.)*sh) * LIGHT_COL;
    
    return d + s;
    
}

// Function 1863
float lambertian_shade(in vec3 pixel_pos, in vec3 normal,
                    in vec3 light_pos, in vec3 camera_pos)
{ //Lambertian shading.  Returns the reflectance visible at camera_pos as a
  //result of lighting pixel_pos (having normal) from light_pos.  
  //One-sided object.

    vec3 light_dir = normalize(light_pos - pixel_pos);
    vec3 eye_dir = normalize(camera_pos - pixel_pos);
    if(dot(light_dir, eye_dir) < 0.0) {
        return 0.0;     // Camera behind the object => no reflectance
    } else {
        return max(0.0, dot(light_dir, normal));
            // ^^^^^^^^ light behind the object => no reflectance
    }
}

// Function 1864
vec3 get_light(vec3 p, vec3 color, vec3 mat, vec3 cam_pos){
    vec3 l2_intensity = vec3(1.,.9,.8) * 2.0;
    vec3 l2 = vec3(0, 3, 3.5);
    vec3 l2_dir = normalize(l2 - p);  // Direction vector from the point to light
    l2_dir.x = sin(iTime);
    float decay_l2 = (1. / length(p - l2));
    vec3 l_a = vec3(0.1);
    
    float p_s = 30.;
    
    vec3 norm = normal_at(p);  // Get the normal at the point
    
    // Coefficients for specular/diffuse
    vec3 kd = vec3(color);
    vec3 ks = vec3(mat);
    
    // Set up view direction
    vec3 v = cam_pos - p;
    v = normalize(v);
    
    //vec3 half_vec_l1 = (l1_dir + v) / (length(l1_dir + v));
    vec3 half_vec_l2 = (l2_dir + v) / (length(l2_dir + v));
    half_vec_l2 = normalize(half_vec_l2);

    
    
    float ndotl2 = dot(norm, l2_dir);  // Calculating dot for second light
    ndotl2 = clamp(ndotl2, 0.0, 1.0);
    
    float shadow = ray_march(p + norm * EPSILON * 2., l2_dir).x;  // MUST ADD Epsilon to ensure don't accidently hit the floor
    if(shadow < length(l2 - p) && shadow != -1.){  // Hit something between light and point so we're in a shadow
        l2_intensity *= .1;
    }
    color += kd * (ndotl2 * l2_intensity * decay_l2);
    //vec3 spec = pow(dot(half_vec_l1, norm),p_s) * ks * (l1_intensity * decay_l1);
    vec3 spec = pow(dot(half_vec_l2, norm), p_s) * ks * (l2_intensity * decay_l2);
    return color + l_a + spec;
}

// Function 1865
vec3 CameraOrientationInWorld()
{
	float theta = mod(iTime, PIx2);
	
	return vec3(1.0, 0.0, 0.1 * sin(theta));
}

// Function 1866
vec3 directLight(vec3 pos, vec3 normal){
    float dotLight = -dot(normal, LightDir);
    if(dotLight < 0.0) return vec3(0);
    vec3 pos0 = pos;
    float minAngle = LightRadius;
    for(int i = 0; i < MaxShadowSteps; i++){
        float dist = distanceEstimation(pos);
        if(dist > MaxDist) break;
        if(dist < MinDist) return vec3(0.0);
        pos -= LightDir * dist * 3.0;	//goes 3 times faster since we don't need details
        minAngle = min(asin(dist/length(pos-pos0)), minAngle);
    }
    return LightColor * dotLight * clamp(minAngle/LightRadius, .0, 1.0);
}

// Function 1867
float shadow(in vec3 ro, in vec3 lo, in vec3 ld) {
    float dist = EPSILON;
    float totalDist = 0.0;
    for (int i = 0; i < MAX_RAY_ITERS; i++) {
        if (abs(dist) < EPSILON ||
            totalDist > MAX_RAY_DIST) {
            break;
        }
        
        dist = map(lo);
        totalDist += dist;
        lo += dist * ld;
    }
    
    if (abs(length(ro - lo)) < 0.01) {
        return 1.0;
    } else {
        return 0.25;
    }
}

// Function 1868
vec3 shade(vec3 ori, vec3 dir) {
 
    float  t = raymarch(ori, dir);
    vec3 col = vec3(0.);
    
    if(t < MAX_DIST) {
     
        vec3 p = ori + dir * t;
        vec3 n = calcNormal(p);
        vec3 r = normalize(reflect(dir,n));
        
        vec2 uv = mod(asin(n.xy)/3.14159+.5,1.);
        col = texture(iChannel2, uv).xxx*vec3(1.,.5,0.);
        
        col = calcLighting(col, ori, p, n, r, 20.);
        
    }
    
    float fog = smoothstep(2., 45., t);
    col = mix(col, vec3(.1,.1,.1), fog);
    
    return col;
    
}

// Function 1869
void Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)
{	
	float fAttenuation = 1.0;
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);
}

// Function 1870
float aoPawn(vec3 pos)
{
    //Ambient occlusion around the base
    float shadow = smoothstep(-0.4, 0.4, length(pos * vec3(1.0, 4.0, 1.0)) - 2.6);
    //Ambient occlusion below the collar
    shadow *= smoothstep(-0.5, 0.5, length((pos - vec3(0.0, 3.8, 0.0)) * vec3(1.0, 4.0, 1.0)) - 1.1);
    //Ambient occlusion below the head
    shadow *= smoothstep(-0.8, 0.8, length((pos - vec3(0.0, 5.0, 0.0)) * vec3(1.0, 4.0, 1.0)) - 1.1);
    return shadow;
}

// Function 1871
float calcAO( in vec3 pos, in vec3 nor ) {
	float occ = 0.0;
    for( int i=0; i<6; i++ ) {
        float h = 0.1 + 1.2*float(i);
        occ += (h-map( pos + h*nor ));
    }
    return clamp( 1.0 - occ*0.025, 0.0, 1.0 );    
}

// Function 1872
float castShadowRay(vec3 pos, vec3 dir, float time, float maxDist)
{
    float totalDist = 0.0;
    float distToSurface = distModel(pos + dir * 0.1, time);
    float maxShadow = 0.0;
    
    for(int i = 0; i < 50 ; ++i)
    {
        totalDist += distToSurface;
        vec3 currentPos = pos + dir * totalDist;
        distToSurface = distModel(currentPos, time);
        float shadowSmooth = mix(0.1, 0.7, smoothstep(0.1, 10.0, totalDist));
        float shadow = smoothstep(shadowSmooth, 0.0, distToSurface);
        shadow *= smoothstep(10.0, 8.0, totalDist);
        maxShadow = max(maxShadow, shadow);
        
        if(distToSurface < 0.00 || totalDist > maxDist)
        {
            return 1.0 - maxShadow;
        }
    }
    
    return  1.0 - maxShadow;
}

// Function 1873
vec3 MixLights(vec2 uv)
{
    vec3 b = AMBIENT_LIGHT;
    
	for(int i = 0;i < NUM_LIGHTS;i++)
    {
        vec2 o = LightOrigin(i);
        vec3 c = LightColor(i);
        
        float l = 0.01 / pow(length(vec3(uv - o, 0.1)), 2.0);
        l *= SampleShadow(i, uv-o);
        b += c * l;
    }
    
    return b;
}

// Function 1874
vec3 shade(hit_record rec) {
    bool wu = fract(rec.u*0.5)>0.5;
    bool wv = fract(rec.v*0.5)>0.5;
    if (wu^^wv) {
        return world[rec.objidx].albedo;
    } else {
        return world[rec.objidx].albedo2;
    }
}

// Function 1875
vec3 sampleLight() {
	vec3 n = randomSphereDirection() * LightRadius;
	return LightPosition + n;
}

// Function 1876
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 24; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = 0.0015;  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

         
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        h = clamp(h, .1, .5); // max(h, .02);//
        dist += h;

        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (shade<.001 || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 1877
vec3 GetLightColor(int lightIndex)
{
    switch(lightIndex % NUM_LIGHT_COLORS)
    {
        case 0: return vec3(1, 0.0, 1.0);
        case 1: return vec3(0, 1.0, 0.0);
    }
    return vec3(0, 0.0, 1.0);
}

// Function 1878
float calcAO(in vec3 pos, in vec3 nor) {
    float occ = 0.;
    float sca = 1.;
    for(int i=0; i<5; i++) {
        float hr = .005 + .12*float(i)/4.;
        vec3 aopos =  nor * hr + pos;
        float dd = min(aopos.y, map(aopos).x);
        occ += -(dd -hr)*sca;
        sca *= .95;
    }
    return clamp(1. - 3.*occ, 0., 1.);
}

// Function 1879
float ao( vec3 v, vec3 n, vec2 tc ) {
	vec4 side, corner;
	
	occlusion( v + n, abs( n ), side, corner );
	
	return 1.0 - filterf( side, corner, tc );
}

// Function 1880
vec3 shadeWetSand( in vec3 p, in vec3 d, in vec3 e, in vec3 n, in vec3 i, in vec3 ld, in vec3 tex )
{
	// Specular.
	vec3 r = reflect(d,n);
    vec3 spec = sunColor(ld) * max( pow(dot(ld,r),50.0), 0.0);
    // Diffuse.
    vec3 diff = shadeDrySand(i,tex)*.5;
    // Ambient.
    vec3 ambi = sky(n,ld);
    return spec+diff+ambi;
}

// Function 1881
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{
    vec4 kk;    
    float res = 1.0;
    float t = 0.01;
    for( int i=ZERO; i<32; i++ )
    {
        float h = mapOpaque(ro + rd*t, kk ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1882
vec3 LightVoxelHitPoint(vec3 hp, float depth, out int hitid, vec3 v)
{
    float hitd;
    vec3 n = SceneNormal(hp, 1e-2, hitd);
//    vec2 uv = hitUV(hp, n);
	//vec2 d_dx = dFdx(uv), d_dy = dFdy(uv);
    float fakel = 1.;
    float faa = 1.; //textureAtlas(uv, hitid, fakel);
    float nl = lighting(vec3(n), v);
    nl *= fakel;
    vec3 c = vec3(1);
    c *= nl;
    hitid = ComputeHitId(hp);
    vec3 tint = hue(float(hitid)); // albedo
    c *= tint;
    return c;
    #if 0
    float t = mr.x // trace depth to first hit
        , hd; // distance at hit point
    int m = int(mr.y);
    vec3 n = SceneNormal(hp, .004, hd)
    , albedo = Material(m)
    , light = Light(m, hp, n, v)
    , c = vec3(1);
    c *= albedo;
    c *= light;
    return c;
    #endif
}

// Function 1883
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<10; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = df( aopos ).x;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 1884
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1885
vec3 shadeInv( in vec3 p, in vec3 d, in vec3 e )
{
    // Get the distance for that gentle blend at the horizon.
    float l = length(p-e);
    // Get the sun direction and sky color once, and pass it around.
    vec3 ld = sunDir();
    vec3 s = sky(d,ld);
    
    // Take care of the appearance of culled stuff--they're sky now.
    if(l > 100.) return s;
    
    // Get the ID of the object we're shading, and make a place
    // to store the final result.
    vec4  id = distInvID(p);
    vec3 result;
    
    // Get the normal and create a general Oren Nayar term to be
    // the shade functions' village bicycle, right next to the
    // light direction, which is the village Razor scooter.
    vec3 n = norm(p,false);
    vec3 i = light(p,d,e,n,ld);
  
    shadeScene(result,false,id.t,p,l,n,id.zw,i,ld,d);  
    // Mix this shaded color with the color of the sky at far distances,
    // so we don't have that ugly plane() @ MAX_DEPTH edge.
	return mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));
}

// Function 1886
vec3 GetBackgroundColorForRayGivenLightingData( vec3 seed, vec3 start, vec3 dir, vec3 shadowData CACHEARG )
{
    if ( dir.y >= 0.0 )
        return GetBackgroundColorForSky( start, dir );

    // intersect with ground plane
    float t = (GROUND_PLANE_HEIGHT - start.y) / dir.y;
    vec3 bgPos = start + dir * t;
    
    vec3 bgColor;
    float spotlightBrightness = GetFloorSpotlightBrightness( bgPos );
    if ( spotlightBrightness == 0.0 )
    {
        bgColor = vec3( 0.0 );
    }
    else
    {
        bgColor = GetFloorColor( bgPos.xz );
        bgColor *= spotlightBrightness;

        bgColor *= LIGHT_COLOR * shadowData.x + AMBIENT_LIGHT_FROM_ABOVE * shadowData.y + BLOB_EMISSION_LIGHT * shadowData.z;
    }
    
    bgColor = AddBackgroundFog( bgColor, start, dir, t, GetBrightnessForTime( blobTime ) );
    
    return bgColor;
}

// Function 1887
vec3 GetLightPosAt(int litID)
{
		if (0 == litID) return vec3(4, 5,4);
	    if (1 == litID) return vec3(5, 5, 8);
        return vec3(0);
}

// Function 1888
float shadowray(vec3 pos) {
    if (!RENDER_SHADOWS)
        return 1.0;

    float res = 1.0;
    float t = 0.2;
    for (int i = 0; i < 50; i++) {
		float h = sdf(pos + -LIGHT_DIR * t).x;
        res = min(res, 16.0 * h / t);
        t += clamp(h, 0.05, 0.4);
        if (res < 0.05)
            break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 1889
float calcSoftshadow( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.0;
	float h = 1.0;
    for( int i=0; i<20; i++ )
    {
        h = map(ro + rd*t);
        res = min( res, k*h/t );
		t += clamp( h, 0.01, 1.0 );
		if( h<0.0001 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 1890
vec3 ShadeLights( ShadeData s )
{
	return vec3(.4,.7,1)*8.0*abs(dot(s.ray,s.normal)); // draw the lightbulb
}

// Function 1891
bool isInSpheresShadow(Intersect intersection, Light light) {
    float lightDist = length(light.position - intersection.position); //light dist
    vec3 shadowDir = normalize(light.position - intersection.position);  //light dir

    Ray shadowRay =  Ray(intersection.position + 10.0*EPSILON*shadowDir, shadowDir);
    float shadowDist = shortestDistanceToSpheres(shadowRay);

    // if intersected sphere in light direction then shadow before reaching light
    if(shadowDist != MAX_DIST_SHADOW && shadowDist < lightDist) 
        return true;
    return false;

}

// Function 1892
float planetShade(vec3 p, float ttime) {
  vec4 s_p = planetDim(ttime);
  vec2 rsi = raySphere(p, innerSunDir, s_p);

  // Fake, fake softshadows
  return rsi.x >= 0.0 && rsi.x < miss ? exp(-3.0*(rsi.y - rsi.x)/(rsi.x+0.1)) : 1.0;
}

// Function 1893
float getAO(vec3 p,vec3 n) {    
    const float R = 3.0;
    const float D = 0.8;
    float r = 0.0;
    for(int i = 0; i < AO_SAMPLES; i++) {
        float f = float(i)*INV_AO_SAMPLES;
        float h = 0.1+f*R;
        float d = map(p + n * h);
        r += clamp(h*D-d,0.0,1.0) * (1.0-f);
    }    
    return clamp(1.0-r,0.0,1.0);
}

// Function 1894
float shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, h*54.0 );
        t += clamp( h, 0.001, 0.1 );
        if( h<0.001 || t>tmax ) break;
    }
    return smoothstep(0.05, 0.2, res);
}

// Function 1895
float shadow( in vec3 X, in vec3 n, in vec3 L )
{
	float mint = 0.001;
	float maxt = 20.0;
	
	X += n*.01;
	
	float h=0.4;
	float sharpness = 25.;
	float soft=1.0;
	float t = mint;
	for (int i=0; i<32; i++)
    {
        float d = sdf(X + L*t);
        if( d<-0.1 )
            return h; //t*h;
		
		soft = min( soft, (sharpness*d)*(1./t));
		
		if (t > maxt) break;
        t += d * 0.9;
    }
    return clamp(soft,h,1.0);
}

// Function 1896
LightPath lightPath(Point p, Light l, vec3 n) {
    vec3 i;
    float il;
    if(l.t == DIRECTION_LIGHT) {
        i = -l.r.d;
        il = 0.0;
    }
    else {
        i = l.r.b - p.p;
        il = length(i);
        i = normalize(i);
    }
    vec3 v = -p.r.d;
    vec3 r = 2.0 * dot(i, n) * n - i;
    vec3 t = normalize(cross(cross(n, i), n));
    vec3 tv = normalize(cross(cross(n, v), n));
    vec3 tr = normalize(cross(cross(n, r), n));
    float energy;
    if(l.t != DIRECTION_LIGHT) {
        energy = l.c.a / pow(il, l.p[0]);
        if(l.t == CONE_LIGHT)
            energy *= pow((l.p[1] - acos(dot(-i, l.r.d))) / l.p[1], l.p[2]);
    }
    else
        energy = l.c.a;
    return LightPath(
        p,
        l,
        n,
        il,
        i,
        v,
        r,
        vec2(dot(n, i), 0.0), // incident
        vec2(dot(n, v), dot(t, tv)), // view
        vec2(dot(n, r), dot(t, tr)), // reflected
        energy
    );
}

// Function 1897
vec3 lightfield(vec2 uv, vec3 dir) {
    float ft_0 = uv.x, ft_1 = -uv.y, ft_2 = -dir.y, ft_3 = dir.x, ft_4 = dir.z;
#ifdef MICRO_MODEL
//smallest model, 12x16, loss ~= .007
vec4 f0_0=sin(ft_0*vec4(-.091,.193,-.148,-.104)+ft_1*vec4(.093,.200,-.332,-.185)+ft_2*vec4(.020,.892,-2.834,-.727)+ft_3*vec4(1.110,1.255,-.156,-1.193)+ft_4*vec4(-.702,-2.152,-.331,3.107)+vec4(1.507,-5.089,-2.078,3.469));
vec4 f0_1=sin(ft_0*vec4(.182,.245,.018,-.481)+ft_1*vec4(-.493,.480,-.029,.147)+ft_2*vec4(-1.859,2.050,-.179,-.023)+ft_3*vec4(1.238,1.646,.400,-1.731)+ft_4*vec4(-.832,1.409,.418,-2.309)+vec4(.664,5.429,.786,-.633));
vec4 f0_2=sin(ft_0*vec4(-.323,-.386,-.139,.328)+ft_1*vec4(-.252,.228,.844,.090)+ft_2*vec4(.633,1.033,2.701,2.168)+ft_3*vec4(-.478,-1.668,-.537,.688)+ft_4*vec4(.559,-1.830,1.314,-.305)+vec4(2.779,-3.522,-.004,-1.438));
vec4 f1_0=sin(mat4(-.980,.272,.423,.137,-.682,-.068,-1.099,.171,.043,-.739,-.547,1.321,-.531,-.418,.618,-.085)*f0_0+
    mat4(1.111,-.548,-.113,-.046,.623,-.057,.486,.178,-.771,.726,.140,.499,.975,-.573,-.861,-.698)*f0_1+
    mat4(.996,.002,.116,-.704,-.136,-.495,.095,-.600,-.137,-.087,.020,-.277,-.202,.353,.779,-.832)*f0_2+
    vec4(-2.755,2.322,.236,2.002))/1.0+f0_0;
vec4 f1_1=sin(mat4(-.270,.593,.433,.151,-.065,.469,.410,-.941,-.402,-.678,.349,-.678,-.022,.446,.994,-.544)*f0_0+
    mat4(.581,.361,-.014,-.065,-.031,.051,-.204,.063,.488,.430,-.051,-.082,.151,.720,.090,.602)*f0_1+
    mat4(-.008,.710,.055,-.510,-.813,.088,-.295,-.066,.291,-.164,-.252,.339,-.252,-.100,-.210,-.545)*f0_2+
    vec4(.359,-.395,.811,.943))/1.0+f0_1;
vec4 f1_2=sin(mat4(.088,.090,-.012,-.139,-1.668,.662,-1.032,-.778,-.216,1.063,-.405,-.379,-.316,-.026,-.219,-.260)*f0_0+
    mat4(.234,-.711,.220,-.949,-.486,-.759,-.359,.533,.656,-.205,.736,.233,.606,-.800,.192,.356)*f0_1+
    mat4(-.040,-.398,-.778,-.331,.318,-.965,-.345,.957,.586,-.592,.102,.201,.213,-.796,-.068,-.157)*f0_2+
    vec4(2.425,1.987,.167,.811))/1.0+f0_2;
vec4 f2_0=sin(mat4(.623,-.434,.462,.055,.282,.024,.243,.391,.033,-.226,-.419,.400,-.034,.116,-.128,-.276)*f1_0+
    mat4(.969,.010,1.003,-.131,.342,-.818,.010,.111,1.031,-.151,.670,.938,-.346,-.380,.124,.100)*f1_1+
    mat4(.486,.269,-.221,.023,-.903,-.605,.059,.772,-.257,-.130,.408,-.402,.039,.307,.023,.599)*f1_2+
    vec4(1.675,-.360,1.275,2.145))/1.4+f1_0;
vec4 f2_1=sin(mat4(.377,.740,-.195,.322,-.106,-.925,.285,.428,-.472,.407,-.046,-.169,.213,.060,-.036,-.322)*f1_0+
    mat4(1.535,.101,-.577,-.435,.039,.503,-.679,.567,.081,-.101,-.368,-.153,-.190,1.039,.887,.259)*f1_1+
    mat4(.144,-.848,-1.220,.281,-.260,.586,-.136,-.368,-.267,.420,-.145,-.413,.300,-.448,-.942,.840)*f1_2+
    vec4(-.866,.306,-.832,-.551))/1.4+f1_1;
vec4 f2_2=sin(mat4(.060,-.176,-.119,.643,1.105,.052,-.314,.430,-.133,.627,.467,.720,-.720,-1.016,-.173,.623)*f1_0+
    mat4(-.163,-.273,-.284,.338,.161,-.041,-.173,-.415,-.382,.497,.135,-.048,-.172,-.063,-.188,.676)*f1_1+
    mat4(.141,.214,-.123,-.893,-.555,.944,.189,.084,.368,.033,.899,.168,.062,.290,.918,.330)*f1_2+
    vec4(-.876,2.460,.200,.360))/1.4+f1_2;
vec4 f3_0=sin(mat4(.504,.236,-.924,-.015,.857,-.435,-.083,-.354,.613,.088,-.304,-.514,.466,-.493,-.650,.229)*f2_0+
    mat4(-.000,-.197,-.830,-.619,.207,-.252,-.222,.080,-.909,-.598,-.088,-.354,-.453,.974,-.025,-.069)*f2_1+
    mat4(-.402,-.204,.133,.555,.113,.743,.312,-.535,.544,.263,-.473,.163,-.829,.285,-.806,-.206)*f2_2+
    vec4(-.528,.485,.076,-.149))/1.7+f2_0;
vec4 f3_1=sin(mat4(-.019,.041,.273,-.731,.742,-.056,-.010,.052,-.927,-.431,-.024,.010,.531,-.038,-.503,-.855)*f2_0+
    mat4(-.907,.109,-.129,.259,-.179,.587,.235,.414,.732,-.083,-.144,.210,.846,.310,.473,.122)*f2_1+
    mat4(-.274,.326,.218,.530,-.149,-.548,.450,-.571,1.268,.199,.310,.010,.764,.302,.284,.113)*f2_2+
    vec4(1.345,.238,.573,-.079))/1.7+f2_1;
vec4 f3_2=sin(mat4(-.350,.339,.061,-.151,.026,-.527,.320,-.009,.635,-.051,-.018,-.558,-1.312,-.430,-.560,.889)*f2_0+
    mat4(-.333,-.158,.592,.398,.170,-.157,-.033,.363,-.135,.334,.702,-1.382,.051,.260,-.378,.448)*f2_1+
    mat4(-.164,-.140,.300,-.530,-.088,.121,-.318,.185,-.177,-.313,.109,.087,-.511,-.713,.199,-.806)*f2_2+
    vec4(.012,-.018,.561,-1.215))/1.7+f2_2;
vec4 f4_0=sin(mat4(-.321,-.581,-.463,-.174,-.317,-.153,.314,-.028,-.118,-.574,-.037,.569,-.216,.702,-.838,-.674)*f3_0+
    mat4(-.840,-.248,.722,.405,-.026,.294,.368,-.231,.395,.206,.102,-.619,.265,-.272,-.304,-.226)*f3_1+
    mat4(.007,.240,.861,.418,-.446,.149,.038,-.224,.625,-.401,-.114,-.532,.461,.169,-.756,.158)*f3_2+
    vec4(.358,-.366,.138,-.746))/2.0+f3_0;
vec4 f4_1=sin(mat4(.200,.407,.656,.124,-.828,-.330,-.653,.111,-.070,.293,-.065,-.375,.201,-1.422,.118,1.111)*f3_0+
    mat4(.154,-.452,.213,-.315,.161,.751,-.120,.010,-.239,-.318,.441,-.615,.078,.920,.049,-.526)*f3_1+
    mat4(-.030,-.011,-.308,-.791,.879,.412,.414,.294,.159,.543,.236,-.011,-.397,-.111,.453,-.777)*f3_2+
    vec4(.525,.518,-.186,-1.267))/2.0+f3_1;
vec4 f4_2=sin(mat4(-.218,.269,.070,-.358,.101,.631,.093,1.082,-.194,.053,.042,-.038,-1.325,-.452,1.119,.446)*f3_0+
    mat4(.443,.239,-.487,-.916,.256,.194,.074,-.078,-.132,-.194,.124,-.097,.056,.985,1.074,-.305)*f3_1+
    mat4(.199,-.197,-.312,-.130,.263,-.042,.207,.567,-.290,.789,.586,-.647,.282,.285,.560,.469)*f3_2+
    vec4(.824,.862,-.478,-.735))/2.0+f3_2;
vec4 f5_0=sin(mat4(1.480,-.320,.510,.133,-.093,-.217,.089,.164,-.009,-.200,.461,-.723,.694,-.270,-.548,.308)*f4_0+
    mat4(.835,.237,.201,-.838,.784,-.035,.026,-.239,.618,.023,-.895,-.350,-.132,.169,.319,.263)*f4_1+
    mat4(-.302,-.211,.200,.114,.563,-1.000,-.555,.204,.611,-.104,-.586,.382,-.174,-.256,-.041,.614)*f4_2+
    vec4(.390,-.139,-.749,-.169))/2.2+f4_0;
vec4 f5_1=sin(mat4(.289,.394,.357,-.355,-.572,-.440,.086,-.467,.687,-.297,1.189,-.729,.700,-.260,-.152,.244)*f4_0+
    mat4(1.295,-.883,.514,-.412,.581,.362,.080,-.307,-.285,.524,.147,.490,-.363,.339,.273,.819)*f4_1+
    mat4(.042,.044,.250,.169,.504,.479,.025,.153,.078,.713,-.301,-.360,-.799,.550,-.244,.478)*f4_2+
    vec4(.695,-.674,1.975,.768))/2.2+f4_1;
vec4 f5_2=sin(mat4(-.527,.059,-.246,.015,.742,-.220,.026,1.821,.057,.401,-.236,.281,.023,.819,-.094,.609)*f4_0+
    mat4(.335,-.505,-.025,-.137,-.116,.354,-.862,.143,.060,.460,.421,-.309,-.455,.044,-.416,-.061)*f4_1+
    mat4(-.769,-.423,-.001,-.456,-1.010,.542,-1.136,.641,-.486,.596,-.287,-.291,-.001,.060,.098,.622)*f4_2+
    vec4(.587,.495,-.175,-1.210))/2.2+f4_2;
vec4 f6_0=sin(mat4(-.357,-.293,.393,-.581,-.134,.177,-.193,.196,.430,1.341,-.092,-.576,.702,-.056,.159,-.830)*f5_0+
    mat4(-.815,.237,-.901,-.367,-.394,-1.205,-.364,.211,.214,.288,-.664,-.214,-1.128,-.777,-.719,.419)*f5_1+
    mat4(-.292,-.026,.088,-.326,.559,.401,.101,-.679,.430,-.188,-.501,-.554,1.223,.150,-.128,.456)*f5_2+
    vec4(.323,-.106,-.159,-.030))/2.4+f5_0;
vec4 f6_1=sin(mat4(.225,.020,.040,.533,-.235,-.023,.142,-.109,-.237,.110,.014,.777,.313,.351,-.299,-.114)*f5_0+
    mat4(-.110,-1.171,-.071,.498,.550,.248,-.191,.119,-.185,-.642,.534,-.318,-.437,-.058,.435,.984)*f5_1+
    mat4(.280,.479,.247,-.785,.345,.957,.354,-.262,.011,-.526,.450,-.982,-.984,-.310,.605,.749)*f5_2+
    vec4(-.408,.207,-.083,1.683))/2.4+f5_1;
vec4 f6_2=sin(mat4(1.591,.197,.049,.365,.337,-.291,-.506,.769,-.059,-.011,-.612,.534,.405,-.474,-.165,.722)*f5_0+
    mat4(-.062,.619,.236,.705,.533,-.769,.100,1.098,.106,.064,-.078,-.390,.583,.169,.936,.444)*f5_1+
    mat4(-.119,.606,.160,-.781,.673,-.328,.124,-.239,.614,-.310,.288,-.491,.098,.566,-.127,-.563)*f5_2+
    vec4(1.026,.201,.533,-.142))/2.4+f5_2;
vec4 f7_0=sin(mat4(.639,-.345,-.331,1.360,.710,-.355,.074,-.614,.757,.141,-.424,.154,.236,.353,.457,-.143)*f6_0+
    mat4(.035,.317,.041,.069,-.287,-.602,-.051,.547,.838,-.217,-.520,.722,-.354,.188,.511,.680)*f6_1+
    mat4(-.691,-.649,.783,.237,-.519,.090,.178,.281,-.175,-.907,-1.133,.228,.240,.027,.516,.616)*f6_2+
    vec4(-.773,-.904,-.610,.713))/2.6+f6_0;
vec4 f7_1=sin(mat4(-.565,-.194,-.979,.450,.807,-.384,.888,-.069,-.216,.866,.392,.940,.467,.166,.133,.070)*f6_0+
    mat4(.322,.630,-.796,1.046,.081,-.702,-.109,-.814,-.322,-.443,-.988,-.172,-.190,.319,-.906,-.395)*f6_1+
    mat4(-.496,-.682,-.133,.294,-.182,.218,-.047,.060,-.008,-.604,-.686,-.000,.156,-.707,-.541,-.298)*f6_2+
    vec4(.022,-.357,-.721,-.514))/2.6+f6_1;
vec4 f7_2=sin(mat4(.586,-.068,-.429,.702,-.522,.269,.234,-.504,.538,.852,.823,-.099,-.015,-.063,.348,.237)*f6_0+
    mat4(-.231,-.144,-.400,.029,.047,.017,-.302,-.110,1.159,.459,.116,.814,.700,.128,.337,.427)*f6_1+
    mat4(-.254,.657,-.448,.338,-.588,-.396,.634,-.286,-.078,.172,.376,-.049,-.203,.219,.525,.578)*f6_2+
    vec4(1.095,-.125,-.295,.097))/2.6+f6_2;
vec4 f8_0=sin(mat4(.400,1.143,-.096,.018,-.243,-.094,.655,.064,-.339,.753,1.123,-.603,-.670,.501,-.514,.353)*f7_0+
    mat4(-.259,.575,.462,-.518,.288,-.203,.027,-.305,-1.171,.329,-.225,-.306,.145,.377,.035,-.493)*f7_1+
    mat4(-.010,-.755,-.186,-.162,-.309,-.845,-.123,.444,.494,.388,-.405,.980,-.152,.034,-.716,-.120)*f7_2+
    vec4(-.044,.285,.045,-.547))/2.8+f7_0;
vec4 f8_1=sin(mat4(-.535,.214,.640,.985,-.265,-.434,.298,-.699,-.153,.194,.598,.267,.441,-.241,.278,.134)*f7_0+
    mat4(.333,-.379,.151,.641,-.759,.170,.716,-.237,-1.087,1.044,-.977,-.343,.085,.161,.226,.107)*f7_1+
    mat4(.463,-.709,-.038,-.715,.185,-.498,-.130,-.072,-.212,.255,-.119,1.187,-.713,-.077,-.871,-.005)*f7_2+
    vec4(-1.483,.013,-1.774,-.149))/2.8+f7_1;
vec4 f8_2=sin(mat4(-.475,-.702,-.053,-.010,-.489,-.042,-.430,.544,-.110,-.372,-.381,-.004,.055,-.637,-.100,-.830)*f7_0+
    mat4(.245,-.849,.180,-.618,-.002,.601,1.104,-.833,.021,.726,.187,.112,.619,.320,-.058,.123)*f7_1+
    mat4(.110,-.130,.864,-.506,-.070,.182,-.428,-.632,.036,-.302,.005,.350,-.742,.299,-.601,.560)*f7_2+
    vec4(-.651,-.555,-1.049,2.991))/2.8+f7_2;
vec4 f9_0=sin(mat4(.233,.055,-.144,.693,.417,-.823,-.700,-.704,-.064,-.626,.144,-.512,-.005,.238,.104,-.603)*f8_0+
    mat4(.962,-1.008,.154,-.537,-.485,1.391,.588,.218,-1.113,-.351,.075,.967,.299,-.227,-.981,.634)*f8_1+
    mat4(.302,.598,-.016,.386,-.650,.203,.272,-.046,-.346,.048,1.122,.318,-.101,-.785,-1.227,-.001)*f8_2+
    vec4(-.856,.585,-.518,1.860))/3.0+f8_0;
vec4 f9_1=sin(mat4(.506,-.081,.878,.419,.252,-.293,-.667,-1.053,-.214,-.403,-.994,.528,.599,-.754,-.478,-.706)*f8_0+
    mat4(.318,-1.378,-.529,.629,-.247,.506,.109,-.310,-.572,.720,.286,.473,.978,.175,-.076,.730)*f8_1+
    mat4(.877,-.242,-.313,-.106,-.740,-.102,-.782,-.352,-1.140,1.064,.108,.288,.431,.052,.276,.476)*f8_2+
    vec4(-.607,-.049,.330,-.611))/3.0+f8_1;
vec4 f9_2=sin(mat4(-.901,.291,.300,.245,-.025,-.150,-.109,-.049,.136,-.019,.847,-.410,-.124,-1.395,-.975,.076)*f8_0+
    mat4(-.128,-.517,.163,.220,-.583,-.267,.255,-.349,.758,1.017,.012,-1.023,-.746,.669,.196,.528)*f8_1+
    mat4(-.621,.319,-.412,-.362,-.762,-.811,-1.406,-.528,-.720,.581,.557,-.373,.617,-.119,-.015,.421)*f8_2+
    vec4(-.464,1.022,-.673,-.279))/3.0+f8_2;
vec4 f10_0=sin(mat4(.238,-.578,-.656,-.662,.017,-.387,.089,.254,-1.041,.228,-1.987,-.568,.183,-.293,-.632,.105)*f9_0+
    mat4(-.111,-.122,-.682,.807,.067,-.892,-.472,-1.071,.030,-.480,-.764,-.536,.675,-.013,-.725,-.115)*f9_1+
    mat4(.490,.779,-.183,-.089,-.876,-.384,.074,-.112,-.324,-.787,-.628,-.249,.777,-.288,1.210,-.620)*f9_2+
    vec4(-.497,1.303,.673,-.333))/3.2+f9_0;
vec4 f10_1=sin(mat4(.312,-.984,-1.247,-.833,.489,.549,-.214,1.463,.931,.138,-.782,.689,-.572,-.743,-.721,-.342)*f9_0+
    mat4(.815,-.009,-.278,-.301,-.293,-.273,-.717,.034,.444,.480,1.088,.187,.690,-.198,-.734,-.272)*f9_1+
    mat4(.242,-1.000,.771,.721,.736,-.092,.216,.318,1.064,1.007,-.514,.082,-.127,-.465,.702,-.033)*f9_2+
    vec4(.483,.848,-.779,-1.040))/3.2+f9_1;
vec4 f10_2=sin(mat4(-.038,.768,.325,.024,.366,-.225,1.482,.157,-.119,.176,-.054,-.612,.625,-.525,.363,-.196)*f9_0+
    mat4(.329,.952,.110,-1.184,1.034,-.815,.195,-.125,-.707,1.314,.257,.097,-.977,.586,-.196,-.442)*f9_1+
    mat4(.871,.713,.108,-.216,-.206,-.679,.216,-.595,-.316,.522,1.310,-.430,-.119,.631,.603,1.257)*f9_2+
    vec4(-1.162,1.307,-2.119,.884))/3.2+f9_2;
vec4 f11_0=sin(mat4(-.584,.189,.191,.859,.476,-.203,.417,1.040,.575,-1.267,1.493,1.337,.502,-.299,-.215,.662)*f10_0+
    mat4(1.217,.045,1.106,-.210,.015,-.475,.146,1.139,-.470,.966,.330,-.308,.610,-.840,.027,.741)*f10_1+
    mat4(-.379,-.706,.734,-1.025,-.002,-.273,-.390,.515,.433,-.300,.878,-.483,-.358,.577,-.190,.540)*f10_2+
    vec4(1.788,.737,2.134,-.805))/3.3+f10_0;
vec4 f11_1=sin(mat4(-.727,-.476,-.997,.063,-.814,-.157,-.109,-.622,-.897,-.943,.573,-.598,.297,-.049,-.808,.373)*f10_0+
    mat4(-1.412,-.663,-.693,.604,.049,-.249,.094,-.213,-.559,.031,-.712,.112,-.195,.336,.885,1.244)*f10_1+
    mat4(-.468,-.700,-1.080,.321,.356,.343,-.883,.321,-.872,-.380,-.237,-.780,.406,.321,-.571,-.292)*f10_2+
    vec4(1.565,-.172,.730,1.630))/3.3+f10_1;
vec4 f11_2=sin(mat4(.448,-.431,-.456,-.306,.592,1.098,.111,-.042,1.078,-.672,1.115,.499,.181,-.702,.196,-.197)*f10_0+
    mat4(-.449,-.600,-.538,.128,.146,-.768,.526,.134,.633,.504,.183,-.528,-.158,-.396,.714,.854)*f10_1+
    mat4(-.733,.969,.001,.166,-.384,-.185,.385,-.013,.565,.639,1.000,-.854,.393,.298,-.412,-.742)*f10_2+
    vec4(.635,-.687,.163,.930))/3.3+f10_2;
vec4 f12_0=sin(mat4(-.171,-.092,.426,-.773,.397,.385,.419,-.205,-.725,-.091,1.104,.529,.107,-.502,.159,-.980)*f11_0+
    mat4(-.659,-.180,1.289,.143,.339,-.509,.552,-.287,-.571,-.281,.026,.131,-.365,.366,.041,.376)*f11_1+
    mat4(-.709,-.422,.265,.439,1.421,-.420,-.173,-1.044,.422,-.838,-.323,-.100,-.928,-.643,-.743,-1.159)*f11_2+
    vec4(.212,.033,-1.112,-.695))/3.5+f11_0;
vec4 f12_1=sin(mat4(-.181,-.098,-.168,-.237,1.374,-.223,-.396,-.487,1.172,.332,.525,-1.497,.543,1.116,-1.478,.289)*f11_0+
    mat4(1.489,-1.044,.813,-.731,-.852,1.383,-1.470,-.106,.026,-.027,.873,.158,.157,-.762,1.185,.418)*f11_1+
    mat4(-.115,-.293,.381,-.034,1.001,.690,-1.405,.257,.295,.796,-.411,-1.274,.048,-.396,.088,.368)*f11_2+
    vec4(-.938,-2.093,-.080,-.373))/3.5+f11_1;
vec4 f12_2=sin(mat4(-.314,.533,-.844,-.220,.635,-.317,-1.580,-.104,.486,.770,1.053,-.319,.999,-.148,-.844,.140)*f11_0+
    mat4(-.287,1.006,.148,-.641,-.297,-.671,-.043,-.166,-1.892,.456,.449,.596,.238,.556,.950,-.097)*f11_1+
    mat4(-.801,1.061,1.112,.274,-.222,-.671,-1.048,-.619,-.785,.070,1.047,.782,.211,-.128,.002,-.968)*f11_2+
    vec4(1.031,.459,-.199,.419))/3.5+f11_2;
vec4 f13_0=sin(mat4(.600,.154,.000,.600,.276,-1.391,.125,-.648,-.063,.332,2.032,-.345,.463,-1.425,.271,-.286)*f12_0+
    mat4(.914,.129,.838,-1.162,-.230,.245,.531,.380,-.057,1.564,-.014,1.502,-.565,.823,-.025,-.395)*f12_1+
    mat4(-.007,1.400,.498,1.227,.394,-.747,-.373,-1.244,-1.147,.820,.455,.059,-.510,-.497,-.203,-.294)*f12_2+
    vec4(-2.030,-1.580,-2.235,-1.784))/3.6+f12_0;
vec4 f13_1=sin(mat4(-.464,.701,-.054,.935,.581,-.642,1.342,-.350,.855,1.781,.884,-.034,.925,-.147,.405,-1.777)*f12_0+
    mat4(.745,.279,1.862,-.005,.462,.858,-.903,-1.907,.097,.938,-.439,1.453,.007,.290,-.222,-.099)*f12_1+
    mat4(.081,1.504,-1.048,1.365,.303,-.643,.499,-2.585,.751,.887,-.457,-.350,-.400,-1.068,.981,.304)*f12_2+
    vec4(-1.506,.466,-.138,1.022))/3.6+f12_1;
vec4 f13_2=sin(mat4(-.584,-.707,-.174,1.145,1.001,.729,-1.416,-.918,.662,-.615,.752,1.179,.861,1.373,-.654,.392)*f12_0+
    mat4(1.119,-.222,-.049,.977,-.750,.215,.115,.252,-1.262,-.516,.906,1.291,.379,-.836,.719,.182)*f12_1+
    mat4(-1.111,-.608,1.234,1.097,.806,.883,.343,-.584,-.635,.380,.396,.422,-.077,.008,-.834,.941)*f12_2+
    vec4(1.274,-.821,-1.443,-2.386))/3.6+f12_2;
vec4 f14_0=sin(mat4(.348,-.480,.148,.072,.307,-.226,-.125,-1.116,-.117,.062,-2.283,-.313,.492,-.054,-.021,-1.624)*f13_0+
    mat4(.415,-1.021,-1.335,.806,-.482,.906,-.354,-.606,-1.474,-1.023,-.568,1.702,-.057,-.330,-.537,1.074)*f13_1+
    mat4(-1.103,.208,-.615,1.242,.493,-.438,.429,-1.124,-.886,.043,-1.047,.582,.855,-.741,-.008,.212)*f13_2+
    vec4(-.102,2.245,.984,-.038))/3.7+f13_0;
vec4 f14_1=sin(mat4(.123,-.176,-.393,.764,-.686,-.160,-.164,-1.537,1.107,1.013,-.440,-.460,-.485,-.812,-1.008,-.576)*f13_0+
    mat4(-.419,-.065,-.708,.361,1.298,.138,-1.316,-1.185,.058,.899,.844,1.104,-.074,.374,.909,.867)*f13_1+
    mat4(.518,.240,.741,.692,-.019,-.038,-.803,-.712,1.281,.719,.149,-.251,-1.553,-.130,-1.030,1.053)*f13_2+
    vec4(-.979,-.834,-1.216,-2.141))/3.7+f13_1;
vec4 f14_2=sin(mat4(-.182,-.089,-.009,1.055,-.271,-.774,-.563,.005,-1.096,-1.939,.203,-1.227,.003,-.003,-.288,-.261)*f13_0+
    mat4(-.759,-1.139,.457,.876,.468,.097,-.308,-.921,-.162,.541,.581,.279,.135,-.112,-.546,.565)*f13_1+
    mat4(-.632,.692,.517,-.066,.518,.437,.691,.102,-.772,-.387,1.003,.427,-.460,-.014,-1.725,.433)*f13_2+
    vec4(1.277,-.301,-.579,.570))/3.7+f13_2;
vec4 f15_0=sin(mat4(-.282,-.810,-.343,.319,.401,.140,.242,-.113,-.769,.106,-1.363,-.239,-.550,1.064,-.176,-1.082)*f14_0+
    mat4(-.561,.265,-1.219,-.470,.428,-.001,.493,-.081,.757,-.298,-.457,-.127,-.394,-.780,-.342,.496)*f14_1+
    mat4(-.561,-.784,-.140,.685,.587,1.329,.314,-.503,-.280,.852,-.977,-.005,-1.206,.416,-.109,.516)*f14_2+
    vec4(-1.116,-1.235,-1.281,-.965))/3.9+f14_0;
vec4 f15_1=sin(mat4(.625,1.240,.086,-.219,.127,-.394,-.402,.639,-.560,.134,1.289,-1.224,-.719,-.704,-.413,1.179)*f14_0+
    mat4(-.160,.887,.157,-.570,-.345,-.371,.184,-.078,.787,.926,-.020,-1.452,.035,.497,-.186,-1.104)*f14_1+
    mat4(.498,.494,-.442,-.558,-.131,-1.258,-.079,1.430,-.100,.486,.361,-.663,-.076,.966,.125,-.009)*f14_2+
    vec4(.894,-1.486,.034,1.697))/3.9+f14_1;
vec4 f15_2=sin(mat4(-.391,1.126,.620,-.150,.397,-.432,-1.269,.066,-.195,1.349,-1.162,-.896,-.905,-1.144,-.705,1.259)*f14_0+
    mat4(-.208,1.405,-1.005,-1.432,-1.133,-.791,.048,1.041,-.216,1.710,-.137,-.427,-.149,1.168,.064,-1.071)*f14_1+
    mat4(-.306,1.509,.077,-.855,-.637,-1.670,-.038,.923,.346,.959,.730,-.555,-.178,.199,-.381,-.472)*f14_2+
    vec4(1.840,-1.800,-.196,-.557))/3.9+f14_2;
vec4 f16_0=sin(mat4(-.179,.425,-.465,.811,1.166,-.462,-.155,-.978,-.532,-1.031,.217,-.933,.860,.624,.166,-2.150)*f15_0+
    mat4(-.030,-.532,-.422,-.547,.713,.298,1.147,-1.271,-.731,-.422,-.074,1.399,-.926,-.090,-.263,1.276)*f15_1+
    mat4(-.424,-.491,.021,.082,1.028,.156,.846,-1.475,-.569,-.204,.489,-.105,-.870,-.805,-.651,.872)*f15_2+
    vec4(-1.486,-4.088,.065,1.831))/4.0+f15_0;
vec4 f16_1=sin(mat4(.281,-.967,-.797,1.062,-.801,.236,-.188,-.897,-.353,-.296,-1.599,.508,-.867,.234,.610,-.394)*f15_0+
    mat4(-.477,.557,-1.323,.249,-.552,-.510,.056,.011,.012,-.449,-.871,.172,.665,-.117,-.327,.692)*f15_1+
    mat4(.172,-.670,-.892,.099,-.910,.235,1.129,-1.087,-.228,-.322,-.728,-.016,.587,-.540,.022,1.346)*f15_2+
    vec4(3.914,.133,1.319,-.133))/4.0+f15_1;
vec4 f16_2=sin(mat4(-.213,-1.333,.124,.421,.273,.293,.775,-.142,-1.049,-.996,-1.707,.508,.668,.703,.253,-1.494)*f15_0+
    mat4(-.521,-.833,.144,.670,.001,-.227,-1.476,-1.285,-.169,-.709,-.291,1.294,-.077,-.727,-.193,1.603)*f15_1+
    mat4(-.792,-.449,-1.303,.445,1.434,1.045,.300,-.819,-1.051,.442,-1.298,.172,.568,-.349,1.172,1.071)*f15_2+
    vec4(-1.388,.541,1.943,.871))/4.0+f15_2;
float f_0=dot(f16_0,vec4(-.052,.097,.023,.103))+
    dot(f16_1,vec4(.033,-.005,-.044,-.056))+
    dot(f16_2,vec4(-.065,.103,-.012,-.016))+
    0.531;
float f_1=dot(f16_0,vec4(-.055,.056,.093,.088))+
    dot(f16_1,vec4(.022,.068,-.036,-.054))+
    dot(f16_2,vec4(-.005,.083,.046,-.074))+
    0.473;
float f_2=dot(f16_0,vec4(-.058,.037,-.056,.090))+
    dot(f16_1,vec4(-.066,.054,-.079,-.082))+
    dot(f16_2,vec4(-.060,.120,-.014,-.062))+
    0.558;
#else
#ifdef BIG_MODEL
//big model 32x16 loss = .2
vec4 f0_0=sin(ft_0*vec4(.409,.133,-.050,.123)+ft_1*vec4(-.425,.121,-.463,.732)+ft_2*vec4(-.402,.281,-2.306,-.200)+ft_3*vec4(.084,-.041,-.634,-.825)+ft_4*vec4(-1.275,1.030,-.473,.866)+vec4(-1.851,2.320,-5.279,1.034));
vec4 f0_1=sin(ft_0*vec4(.372,-.232,.129,-.632)+ft_1*vec4(.430,1.136,-.349,-.546)+ft_2*vec4(.587,.557,-.138,-2.463)+ft_3*vec4(.329,-.020,-.051,-1.184)+ft_4*vec4(1.027,.999,1.673,-.097)+vec4(2.182,.584,2.164,-.954));
vec4 f0_2=sin(ft_0*vec4(-.703,-.186,-.007,-.028)+ft_1*vec4(-.225,-.344,-.021,-.651)+ft_2*vec4(.424,1.487,.412,-2.944)+ft_3*vec4(-1.963,.047,.012,-.030)+ft_4*vec4(.524,2.219,.922,2.159)+vec4(-2.854,3.645,2.376,3.604));
vec4 f0_3=sin(ft_0*vec4(.188,.721,-.743,.462)+ft_1*vec4(.268,.072,.429,.088)+ft_2*vec4(-1.390,.815,-.242,2.014)+ft_3*vec4(1.527,2.516,-2.061,.805)+ft_4*vec4(1.437,.458,-1.028,.331)+vec4(.937,.519,1.400,-.996));
vec4 f0_4=sin(ft_0*vec4(.018,-.350,.246,.568)+ft_1*vec4(.434,-.186,-.593,-.171)+ft_2*vec4(.279,-.439,-1.378,-1.606)+ft_3*vec4(.737,-1.913,2.547,2.246)+ft_4*vec4(-2.430,-2.341,.767,-.797)+vec4(-4.471,-4.027,-1.343,1.822));
vec4 f0_5=sin(ft_0*vec4(-.747,.170,-.071,-.294)+ft_1*vec4(.414,.525,.342,.128)+ft_2*vec4(.801,1.726,.479,.076)+ft_3*vec4(.154,.163,.840,.079)+ft_4*vec4(-1.296,2.880,-.597,1.528)+vec4(-.920,4.362,-2.450,2.072));
vec4 f0_6=sin(ft_0*vec4(.459,-.126,.027,-.403)+ft_1*vec4(-.400,.286,.171,.051)+ft_2*vec4(-1.179,.233,-.301,.744)+ft_3*vec4(.527,-.167,.761,.805)+ft_4*vec4(-2.008,.818,-1.454,.977)+vec4(-1.678,2.451,-2.118,1.750));
vec4 f0_7=sin(ft_0*vec4(.029,.085,-.072,.424)+ft_1*vec4(.100,-.699,-.169,-.199)+ft_2*vec4(2.608,-1.039,.403,-1.846)+ft_3*vec4(-.057,1.183,.051,.102)+ft_4*vec4(.434,.753,1.232,.262)+vec4(-.927,2.969,2.210,-2.279));
vec4 f1_0=sin(mat4(-.033,-.159,.160,-.184,.182,-.205,-.299,-.086,-.224,.107,-.423,.730,-.087,-.380,-.291,.333)*f0_0+
    mat4(-.388,-.068,-.075,.130,.158,-.260,-.063,.269,-.349,.311,.215,-.173,-.385,.240,.100,.205)*f0_1+
    mat4(.014,.065,.373,.451,-.129,.266,-.091,-.063,-.101,.044,.125,.190,-.749,-.611,.571,-.614)*f0_2+
    mat4(.005,-.018,-.506,.491,.180,.283,.001,-.444,.226,.151,.283,-.212,-.068,-.342,.349,-.428)*f0_3+
    mat4(.043,-.688,.341,.054,-.164,-.123,-.198,.120,-.212,-.202,.282,.441,.077,.126,-.235,.008)*f0_4+
    mat4(-.177,.028,.196,.110,.629,.564,-.245,-.292,.009,.667,-.039,-.029,-.045,.014,.073,.217)*f0_5+
    mat4(.383,.228,-.233,-.205,.102,-.174,-.205,.272,.051,-.144,-.289,.200,-.153,.016,-.147,.126)*f0_6+
    mat4(-.244,.066,.663,-1.603,-.121,.377,.297,-.422,-.068,.103,.160,-.010,-.147,-.282,.521,-.395)*f0_7+
    vec4(-.221,-.541,-.483,.452))/1.0+f0_0;
vec4 f1_1=sin(mat4(-.317,-.022,.077,-.211,.079,.365,-.119,.207,.131,.130,-.627,-.095,-.115,-.060,-.229,.369)*f0_0+
    mat4(.063,.176,-.378,.267,.134,-.442,-.084,.011,-.141,.295,.244,-.348,-.483,-.025,.075,-.617)*f0_1+
    mat4(1.131,-.122,.546,-.113,-.081,.211,-.174,.160,-.000,.561,-.237,-.140,-.317,-.431,-.165,-1.079)*f0_2+
    mat4(.123,.046,.049,.018,.638,.151,.103,.004,-.275,-.296,-.099,-.069,-.295,.045,.330,-.353)*f0_3+
    mat4(.216,-.686,.354,-.154,-.506,.141,-.653,-.155,.189,.071,.426,.266,.391,-.028,.001,-.333)*f0_4+
    mat4(.032,-.015,.004,.090,.196,-.103,-.000,.211,-.216,.281,-.332,.084,-.283,.109,-.050,-.204)*f0_5+
    mat4(-.475,.037,-.421,.515,.091,.202,.076,.204,-.222,-.094,-.936,.500,.462,-.232,-.265,.134)*f0_6+
    mat4(-.073,-.041,.396,.688,-.594,-.196,-.127,.075,.138,-.133,-.211,-.004,.159,.178,.272,.135)*f0_7+
    vec4(.385,-.393,-.583,.390))/1.0+f0_1;
vec4 f1_2=sin(mat4(.041,.348,-.043,-.028,.261,-.084,.250,-.091,.728,1.026,-.641,-.026,.414,.188,-.126,-.072)*f0_0+
    mat4(.211,.172,.135,.068,.053,-.014,-.279,-.250,.146,-.027,.240,.346,-.316,-.141,-.098,.170)*f0_1+
    mat4(.104,.260,.100,.156,-.127,.102,-.330,-.104,.110,.152,-.164,.133,.007,-.166,.825,2.075)*f0_2+
    mat4(.164,-.451,-.079,.036,-.476,-.941,.055,-.125,.056,.131,.149,.088,-.649,-.613,.361,-.031)*f0_3+
    mat4(.202,-.127,.714,-.018,.063,-.037,-.086,.061,.174,-.008,.083,.100,-.315,-.292,-.098,.374)*f0_4+
    mat4(.074,.034,-.229,-.144,-.570,-.123,-.248,-.679,-.012,.219,-.485,-.048,.058,-.316,.299,-.196)*f0_5+
    mat4(-.437,-.647,-.034,-.373,.262,-.271,.168,-.002,-.235,-.130,-.230,-.231,.070,.083,.028,-.030)*f0_6+
    mat4(-.499,-.795,.771,.072,.011,.323,.041,.269,.100,.104,-.129,.074,.167,-.117,.330,-.039)*f0_7+
    vec4(.186,-.408,.660,.322))/1.0+f0_2;
vec4 f1_3=sin(mat4(.091,-.031,-.182,-.010,-.058,.080,-.120,-.135,-.286,.066,-.427,.527,.084,.085,-.079,.517)*f0_0+
    mat4(-.146,.048,.200,.105,-.050,-.115,.225,-.078,.244,.273,-.826,-.244,.149,.177,.336,-.180)*f0_1+
    mat4(-.060,-.009,.553,-.356,-.030,.060,.110,.198,-.004,-.216,-.254,-.120,.886,-.232,-.531,.119)*f0_2+
    mat4(-.104,-.057,.271,-.362,-.030,-.893,.551,.083,.068,-.117,-.601,.479,.015,-.038,.256,-.068)*f0_3+
    mat4(.375,.016,.107,-.162,-.408,.176,-.445,.918,.744,.327,.450,-.391,-.093,-.602,.749,-1.068)*f0_4+
    mat4(.245,-.056,-.039,-.056,-.644,-.401,.159,.256,.128,.041,-.297,.097,.096,.361,-.160,.151)*f0_5+
    mat4(-.828,-.480,.076,.226,-.126,.028,.190,.095,-.486,-.063,.257,.034,-.099,-.296,.068,.060)*f0_6+
    mat4(-.249,.004,.091,.383,.040,.383,-.422,.787,.324,-.108,-.043,-.089,.286,.221,-.191,-.085)*f0_7+
    vec4(-.414,-.533,.929,.574))/1.0+f0_3;
vec4 f1_4=sin(mat4(-.177,-.061,-.049,-.269,.156,.087,.105,.066,.274,-.879,.296,-.009,-.123,-.231,.179,-.147)*f0_0+
    mat4(-.000,-.294,.175,-.154,.436,-.098,.196,.004,-.078,.266,-.075,.088,.265,.169,-.177,.357)*f0_1+
    mat4(.790,.067,.062,.506,-.055,-.328,-.127,-.200,.200,-.017,-.321,-.060,-1.176,.085,-.129,-.239)*f0_2+
    mat4(.155,.141,-.238,.565,.107,.361,-.356,.154,-.379,.115,.105,-.353,-.218,.717,-.508,-.112)*f0_3+
    mat4(.034,.355,.115,.227,-.291,.600,-.358,-.166,.107,-.068,.647,.627,.519,-.132,.074,.253)*f0_4+
    mat4(-.123,.037,.023,-.131,-.133,.054,-.595,-.335,-.022,-.099,.131,-.244,-.186,.275,.050,.024)*f0_5+
    mat4(-.386,.062,-.283,-.251,.206,-.092,.256,.059,-.423,-.402,.089,-.070,.102,.159,.048,.325)*f0_6+
    mat4(-.827,1.239,-.076,-.494,-.452,.178,-.173,-.305,-.126,.096,.029,-.034,-.190,.091,.105,-.042)*f0_7+
    vec4(-.195,.300,-.198,.498))/1.0+f0_4;
vec4 f1_5=sin(mat4(-.238,.311,-.115,-.020,.005,-.031,.159,.074,.044,-.055,.369,-.453,.175,-.040,.284,.128)*f0_0+
    mat4(.491,.142,.315,-.061,.096,-.078,.200,-.383,.004,.124,-.520,.069,-.269,-.215,-.406,-.146)*f0_1+
    mat4(.257,.218,-.108,-.281,.169,.074,-.258,-.271,-.077,-.365,-.253,-.290,-1.355,.011,-.305,.968)*f0_2+
    mat4(.051,.258,.186,-.255,-.164,-.341,-.540,.582,-.293,.118,.092,.404,.221,.591,-.578,.176)*f0_3+
    mat4(-.045,-.119,.372,.244,.030,.258,-.469,-.318,.382,.231,-.103,-.314,-.711,-.068,.111,-.345)*f0_4+
    mat4(.149,.183,-.231,-.097,-.144,-.369,-.078,.256,.071,.054,-.390,-.267,.169,-.035,-.214,-.107)*f0_5+
    mat4(-.402,-.549,.278,.539,.023,-.144,.333,.028,-.087,-.271,.886,.277,.237,-.349,-.109,.143)*f0_6+
    mat4(.043,-.253,.118,1.049,.300,-.056,-.278,.079,.267,-.413,-.294,-.192,-.010,-.088,-.237,.418)*f0_7+
    vec4(.398,-.530,.779,.696))/1.0+f0_5;
vec4 f1_6=sin(mat4(-.264,-.004,-.229,.023,-.023,.205,-.175,-.187,-.131,-.889,.359,.186,-.014,-.331,-.097,-.270)*f0_0+
    mat4(-.072,.093,.307,-.149,.339,-.165,.009,-.173,.091,.198,-.745,.126,-.060,.345,.029,.748)*f0_1+
    mat4(.348,-.192,-.263,-.107,-.447,-.135,-.024,.033,-.202,-.012,-.177,.595,-.085,.916,.439,.913)*f0_2+
    mat4(.206,.073,.508,.664,.631,.243,-.497,.020,-.595,.119,.141,-.368,.088,.658,.228,.082)*f0_3+
    mat4(.291,.344,.050,-.302,-.398,-.263,-.059,.337,.508,.126,-.191,-.527,.514,.589,.598,.382)*f0_4+
    mat4(.016,-.025,-.383,.043,-.075,.050,.535,.070,-.334,-.200,-.314,.112,.076,.243,-.325,.273)*f0_5+
    mat4(-.135,.231,.645,.351,-.017,-.045,.002,-.201,-.303,-.064,.755,.219,.358,.128,.333,-.135)*f0_6+
    mat4(-.391,.674,.580,-.538,-.567,-.066,-.110,.317,-.024,-.166,-.146,-.122,-.440,.152,-.212,-.217)*f0_7+
    vec4(.769,.056,.713,-.031))/1.0+f0_6;
vec4 f1_7=sin(mat4(-.081,-.002,-.192,-.219,-.078,-.044,.118,.174,-.007,.022,-.542,-.209,.222,.362,-.173,.204)*f0_0+
    mat4(-.154,.336,-.159,.462,-.010,.093,.006,-.092,-.451,.077,.052,-.391,-.397,-.188,.221,.152)*f0_1+
    mat4(-.184,.170,.280,-.360,.113,-.065,-.164,.010,-.109,-.327,.021,-.237,.008,.075,-.849,.756)*f0_2+
    mat4(-.335,.087,-.030,.263,.692,-.317,.736,.055,.113,-.055,-.043,-.068,-.001,-.025,.553,.309)*f0_3+
    mat4(-.183,.206,.186,.209,-.385,.396,-.074,.180,.118,.359,-.315,.242,.122,-.395,.211,.155)*f0_4+
    mat4(.214,.165,-.232,-.200,.664,-.653,.677,-.203,-.116,.039,-.374,-.335,-.662,.157,.174,-.242)*f0_5+
    mat4(.281,-.673,.714,-.058,-.033,.184,-.112,.188,-.068,-.194,.292,.205,.030,-.134,.281,.039)*f0_6+
    mat4(.618,-.024,.159,1.115,-.258,.243,-.280,-.228,-.075,-.152,.055,-.049,-.061,.163,-.291,.106)*f0_7+
    vec4(.196,-.030,.316,.436))/1.0+f0_7;
vec4 f2_0=sin(mat4(-.039,.210,-.168,-.151,-.239,.293,.141,-.203,.456,-.386,.166,.267,-.158,-.557,-.084,.111)*f1_0+
    mat4(-.474,-.068,.215,.074,.235,-.118,-.033,-.180,.173,-.093,-.163,.001,-.325,-.089,-.286,.138)*f1_1+
    mat4(.178,.066,.031,.328,-.111,.246,.157,-.004,-.507,.428,-.184,.235,-.397,.782,.900,-.659)*f1_2+
    mat4(.575,-.402,-.122,.027,-.304,.010,.257,.250,.304,-.142,.226,-.218,-.224,.207,.369,-.371)*f1_3+
    mat4(.050,.210,-.468,.227,.012,.055,.012,-.464,.091,.234,.420,.350,.094,.070,.257,-.050)*f1_4+
    mat4(.082,-.059,-.110,.124,.007,.486,.260,-.242,.253,.154,-.129,.125,.036,.204,.005,-.312)*f1_5+
    mat4(-.232,.131,-.407,.117,-.281,.421,-.014,-.354,-.060,-.173,.020,-.158,-.239,.100,.077,-.347)*f1_6+
    mat4(-.374,.263,-.064,-.117,.304,-.010,.074,-.316,-.244,-.047,.310,-.094,-.413,.372,.215,-.475)*f1_7+
    vec4(-.269,-.195,-.165,.268))/1.4+f1_0;
vec4 f2_1=sin(mat4(.056,.453,.023,-.203,.240,-.109,.201,.044,-.375,.067,-.283,.615,.235,-.673,.076,.313)*f1_0+
    mat4(-.090,-.039,-.004,.124,-.029,-.650,.026,.145,.536,.236,.285,.108,-.038,.365,.124,-.256)*f1_1+
    mat4(.126,.185,.289,.235,-.054,.043,-.079,.044,.311,.291,.027,-.290,.021,.696,.512,-.399)*f1_2+
    mat4(-.315,-.131,.105,.221,-.226,-.426,-.839,-.615,-.097,.023,-.485,.089,-.311,-.121,.026,.124)*f1_3+
    mat4(-.422,-.062,.466,-.486,.456,-.204,.185,-.113,.222,-.144,.354,.401,-.877,-.035,.021,-.068)*f1_4+
    mat4(.652,.136,.249,.528,.319,.040,-.258,.262,.574,.300,-.375,.010,.044,-.347,.441,.027)*f1_5+
    mat4(-.300,-.414,-.439,-.153,.118,.371,.002,-.156,-.138,.029,.396,-.337,-.157,.049,-.255,-.048)*f1_6+
    mat4(-.164,-.052,.158,-.769,.465,.519,-.084,-.033,-.209,.039,.180,-.021,.235,.062,.316,-.142)*f1_7+
    vec4(-.571,-.303,.342,-.603))/1.4+f1_1;
vec4 f2_2=sin(mat4(.200,-.267,-.195,-.116,.245,-.458,.321,-.651,.169,.241,.645,-.424,.197,.222,-.333,.182)*f1_0+
    mat4(.058,.025,.396,-.248,-.104,.452,.230,.059,-.229,-.507,-.197,-.396,-.261,-.532,-.192,-.450)*f1_1+
    mat4(-.103,.266,.500,.184,-.164,-.221,-.112,.044,.246,-.198,.328,-.149,-.503,-.314,.768,-.806)*f1_2+
    mat4(.208,.178,.024,.041,-.191,-.033,-.099,.149,-.156,-.267,.218,.469,-.295,.141,.008,.001)*f1_3+
    mat4(-.084,.524,-.415,-.251,.345,-.155,.312,.102,.081,.151,-.071,.092,-.793,.077,-.138,.286)*f1_4+
    mat4(.404,-.107,.236,-.045,.149,-.407,-.116,-.040,-.092,.354,-.121,.036,-.057,.585,-.157,.224)*f1_5+
    mat4(.120,-.200,-.129,.201,.263,.302,-.464,-.098,-.210,.087,-.289,.397,.081,-.086,.526,.183)*f1_6+
    mat4(-.229,.076,-.275,.409,.394,-.013,.356,-.266,-.257,.233,-.017,.368,.268,-.039,-.128,-.197)*f1_7+
    vec4(-.608,.291,-.473,1.012))/1.4+f1_2;
vec4 f2_3=sin(mat4(.393,-.141,-.357,-.169,-.085,-.154,-.013,-.126,.005,-.341,.460,-.079,-.312,-.031,.298,.222)*f1_0+
    mat4(-.194,-.113,-.071,.011,.066,-.047,-.168,.460,.216,-.551,-.328,-.187,.230,.398,-.099,-.165)*f1_1+
    mat4(.324,.066,-.411,.113,.166,.126,-.045,-.371,.130,.171,-.100,-.172,.172,-.115,-.338,-.367)*f1_2+
    mat4(.256,-.324,.325,.282,-.135,.635,-.044,-.239,-.109,.188,.426,.143,.307,-.140,-.151,.132)*f1_3+
    mat4(.355,-.385,-.564,.104,-.089,-.806,.347,.814,.171,.064,.066,-.010,.058,.316,-.556,-.541)*f1_4+
    mat4(.195,-.010,-.391,.040,-.287,.408,-.265,-.275,-.113,-.162,.056,.280,.020,.318,-.588,.342)*f1_5+
    mat4(-.165,.441,.096,-.515,-.284,-.073,-.543,-.235,-.350,-.069,-.148,.079,-.268,.011,-.109,.217)*f1_6+
    mat4(-.580,.267,-.245,.131,.141,-.267,.104,.045,-.310,.008,.305,.435,-.168,-.221,-.091,-.396)*f1_7+
    vec4(-.496,.022,.468,.253))/1.4+f1_3;
vec4 f2_4=sin(mat4(-.027,-.082,-.328,-.544,.081,.185,.247,.014,-.036,-.514,.454,-.034,-.354,-.174,.283,-.121)*f1_0+
    mat4(.239,.038,.500,-.661,-.213,-.073,.020,-.021,.076,.166,-.122,.252,.257,-.482,.012,.251)*f1_1+
    mat4(.103,-.128,.042,.358,-.291,-.337,-.069,-.009,.250,.034,-.064,.042,1.163,.424,.298,-.188)*f1_2+
    mat4(.141,.474,-.225,-.339,-.244,-.002,-.061,.164,-.428,-.152,.204,.217,-.144,.717,-.122,.047)*f1_3+
    mat4(.451,.158,-.005,-.301,.168,.424,-.067,.465,-.006,-.383,-.124,.004,.177,.349,.241,-.206)*f1_4+
    mat4(-.000,-.166,-.504,-.098,.184,-.221,.076,.321,.056,.099,-.143,-.054,.221,-.104,-.447,-.218)*f1_5+
    mat4(-.128,-.154,-.062,-.111,.292,.715,-.150,.248,-.079,.068,-.001,-.132,-.188,-.085,.219,.179)*f1_6+
    mat4(-.191,.153,-.138,.051,-.209,-.311,.362,.707,-.082,.213,.364,-.144,.325,.230,-.103,.217)*f1_7+
    vec4(-.145,.531,-.336,-.148))/1.4+f1_4;
vec4 f2_5=sin(mat4(-.011,.017,.240,.144,-.284,.140,.430,-.266,-.477,.006,.528,-.478,.065,.150,.189,.109)*f1_0+
    mat4(-.295,.245,-.534,-.047,.077,-.107,.021,-.091,.208,-.126,-.683,.128,-.111,-.364,.041,-.274)*f1_1+
    mat4(.090,.319,-.048,.244,-.319,.372,.413,.001,.060,.518,-.244,.451,-.702,.266,-.422,-.898)*f1_2+
    mat4(.056,-.308,-.036,-.082,.035,.029,.100,.471,.268,-.127,.507,-.082,.178,-.037,-.037,-.251)*f1_3+
    mat4(-.229,-.383,-.126,-.137,.626,.689,.032,.111,-.254,-.078,-.010,.324,-.730,-.356,-.231,.007)*f1_4+
    mat4(.538,.120,.444,-.006,.308,.028,-.315,.119,-.200,.081,-.514,.032,-.174,.429,-.671,.250)*f1_5+
    mat4(-.036,.103,-.240,-.286,.247,-.145,-.197,.071,-.103,.065,.091,-.386,-.324,.300,.189,-.191)*f1_6+
    mat4(.024,.068,-.224,.396,.022,.464,-.004,-.074,.095,-.021,.162,.086,-.047,.433,-.507,-.020)*f1_7+
    vec4(-.024,-.212,-.377,-.069))/1.4+f1_5;
vec4 f2_6=sin(mat4(.433,.151,-.284,-.368,.602,.280,-.215,.409,.146,-.571,.177,-.153,-.011,-.361,.032,-.073)*f1_0+
    mat4(.091,.113,-.076,.248,-.247,-.129,-.037,.523,-.551,.239,-.194,-.041,-.232,.163,-.150,.260)*f1_1+
    mat4(-.192,.537,.002,.099,-.143,-.531,-.137,.227,-.007,.478,.169,.014,.239,.361,.050,1.019)*f1_2+
    mat4(-.216,-.036,.298,-.035,.811,-.356,.331,.084,.237,-.454,.020,-.074,.705,.062,.024,.156)*f1_3+
    mat4(-.005,.459,-.471,-.164,-.343,.097,.066,.133,-.047,.675,.324,.423,.069,.112,.043,-.185)*f1_4+
    mat4(.140,.218,-.495,.041,.224,.247,-.653,.019,-.324,-.078,.012,-.230,-.129,-.355,.077,.111)*f1_5+
    mat4(.736,-.534,-.021,-.196,-.121,.453,.441,.352,.034,-.544,.239,-.269,.040,-.336,.255,-.575)*f1_6+
    mat4(.184,-.423,.454,-.178,-.449,.132,-.086,-.175,-.151,-.111,.256,-.251,-.186,-.118,-.102,.009)*f1_7+
    vec4(-.448,-.296,.761,-.293))/1.4+f1_6;
vec4 f2_7=sin(mat4(-.211,-.044,-.028,.244,-.096,.195,-.042,-.383,-.366,.464,-.316,-.532,.209,.309,-.248,-.162)*f1_0+
    mat4(.107,.253,.171,.108,.027,.038,.317,.426,.254,-.168,.045,-.082,.073,-.619,.158,-.001)*f1_1+
    mat4(.694,.544,-.440,-.389,-.164,-.155,-.006,.044,.029,.305,.004,-.320,-.264,-.218,-.234,.621)*f1_2+
    mat4(-.062,-.280,.166,.281,-.208,.417,.744,.195,-.449,-.046,.089,-.054,-.398,.248,.400,.037)*f1_3+
    mat4(.330,-.282,-.093,.217,.116,-.397,-.327,.592,.354,.726,-.392,-.572,-.308,.101,.299,.036)*f1_4+
    mat4(.225,.124,-.308,-.331,-.092,.399,-.073,-.167,-.147,-.080,.004,.327,.017,.191,.073,.371)*f1_5+
    mat4(-.433,-.349,.333,.144,.090,-.055,.408,.274,-.269,-.568,.011,.523,-.489,-.409,-.021,.265)*f1_6+
    mat4(-.021,-.216,.376,.328,-.005,-.413,-.410,-.171,-.053,-.365,-.064,-.061,-.135,.002,.224,.452)*f1_7+
    vec4(-.241,-.613,.405,.466))/1.4+f1_7;
vec4 f3_0=sin(mat4(.012,-.133,-.022,-.174,-.255,-.392,.175,-.430,.081,-.713,.255,-.481,.108,.414,-.275,.142)*f2_0+
    mat4(.533,.035,.458,.485,.038,-.195,.014,.140,-.369,-.075,.519,-.291,-.270,-.126,.253,.421)*f2_1+
    mat4(-.082,-.421,.027,.150,.160,-.382,-.389,.181,-.209,.033,-.708,.112,-.333,-.228,.393,.012)*f2_2+
    mat4(.128,.505,-.101,.439,.320,-.068,-.238,.396,.121,-.283,.224,.115,-.211,-.081,.335,-.111)*f2_3+
    mat4(-.267,.420,.135,.250,-.160,.427,-.312,.472,-.402,-.331,-.083,-.536,.539,-.020,.053,.162)*f2_4+
    mat4(-.283,-.059,-.283,-.581,.416,-.252,-.035,.435,.139,-.493,-.243,-.059,-.198,.405,-.540,.072)*f2_5+
    mat4(.511,.062,.191,.175,.176,.290,.011,.244,-.052,.533,-.336,.540,.035,-.054,.384,.096)*f2_6+
    mat4(-.326,.545,-.388,.423,-.278,-.086,-.083,.218,-.138,.139,-.043,.052,-.080,.269,-.083,.127)*f2_7+
    vec4(.189,.722,-.300,.631))/1.7+f2_0;
vec4 f3_1=sin(mat4(.194,.325,.366,.174,.628,-.161,.268,.252,-.245,.026,.169,-.181,.216,.141,-.053,-.689)*f2_0+
    mat4(-.349,.357,.044,-.040,.222,.263,-.237,-.358,-.230,-.522,.406,.106,.114,-.371,.322,.407)*f2_1+
    mat4(-.062,-.263,.385,-.158,.024,.364,-.100,-.352,-.332,.216,-.075,.136,.013,-.440,-.109,.209)*f2_2+
    mat4(.524,-.038,-.351,-.257,-.101,.594,-.508,.190,.294,-.275,-.055,.266,.321,-.183,-.106,.183)*f2_3+
    mat4(-.449,-.190,.030,.021,.652,-.503,-.185,.513,-.442,.180,.001,-.316,-.340,.265,.086,-.244)*f2_4+
    mat4(.021,.609,.254,-.180,-.323,.392,-.238,.242,-.089,-.423,.238,.145,-.384,-.025,.195,-.299)*f2_5+
    mat4(.084,.272,.120,.077,.532,-.072,-.066,.269,.308,-.340,.129,-.459,.099,.265,-.320,-.317)*f2_6+
    mat4(-.369,.191,-.362,.171,.091,-.208,-.353,-.011,-.265,-.154,.201,.197,-.348,.088,.020,.175)*f2_7+
    vec4(.568,-.593,-.311,-.308))/1.7+f2_1;
vec4 f3_2=sin(mat4(-.318,-.026,.024,-.183,-.015,-.301,.094,.133,.358,.078,-.177,-.032,.131,-.060,-.023,-.240)*f2_0+
    mat4(.487,-.251,-.339,.053,.042,.392,.043,-.258,.088,-.047,-.368,-.144,-.552,.178,.319,-.071)*f2_1+
    mat4(.528,-.057,.004,-.468,-.295,-.575,-.081,-.001,-.214,-.245,.512,-.040,.208,-.205,-.189,1.385)*f2_2+
    mat4(-.035,-.558,-.448,-.163,.059,-.183,-.085,.089,.087,-.021,-.024,-.163,-.217,-.011,-.015,.160)*f2_3+
    mat4(.000,.071,.144,.525,.323,-.745,.367,-.057,.370,-.076,-.043,.324,.175,.031,-.135,.079)*f2_4+
    mat4(.192,.103,.138,.236,-.133,-.078,.469,.100,-.136,-.238,.104,-.060,.112,.467,.584,-.233)*f2_5+
    mat4(-.060,.683,-.022,-.127,-.109,-.109,.357,.052,.202,.143,-.054,-.201,-.130,-.344,-.401,.232)*f2_6+
    mat4(.245,.163,.526,.052,.228,.063,.303,.034,-.268,.180,-.208,.051,.088,.053,.254,.364)*f2_7+
    vec4(.360,.054,-.362,-.270))/1.7+f2_2;
vec4 f3_3=sin(mat4(.180,-.321,-.052,-.362,.533,-.482,.234,-.092,-.065,.282,-.041,.083,-.137,-.017,.174,-.202)*f2_0+
    mat4(-.180,.270,.127,-.088,.117,-.144,-.101,-.003,.239,-.064,.216,-.017,-.330,.355,-.261,.065)*f2_1+
    mat4(-.531,-.023,.064,.006,.232,.132,-.223,.217,-.379,-.161,-.303,-.148,-.845,-.296,.142,-.013)*f2_2+
    mat4(.403,-.140,-.167,-.224,-.010,.108,-.199,.448,-.046,.011,.209,.500,.140,-.000,.113,.198)*f2_3+
    mat4(-.450,-.337,.399,-.699,-.450,-.528,-.081,-.216,-.109,.149,-.235,-.216,-.175,-.004,-.012,-.120)*f2_4+
    mat4(.259,-.086,.021,-.045,-.042,.059,.041,-.581,.307,.019,-.301,.206,.046,-.446,-.230,-.717)*f2_5+
    mat4(.136,.490,.410,.240,-.077,-.285,-.241,-.166,-.179,-.078,.266,-.199,-.079,.033,-.762,.032)*f2_6+
    mat4(-.351,-.469,-.319,-.044,.302,.487,-.388,-.078,-.180,-.094,.443,-.196,.067,-.191,.002,-.437)*f2_7+
    vec4(.009,.041,.762,.069))/1.7+f2_3;
vec4 f3_4=sin(mat4(-.207,-.072,.003,.002,.068,-.203,.213,-.018,-.083,-.448,-.264,.020,-.095,-.262,-.802,-.136)*f2_0+
    mat4(-.187,-.287,-.112,.009,-.148,-.030,.079,-.253,.276,.204,.285,.217,.485,.147,.119,.113)*f2_1+
    mat4(.135,-.138,.109,-.646,.055,.110,-.386,.153,.154,.410,.340,-.317,.547,-.289,.343,.132)*f2_2+
    mat4(-.328,-.198,.111,-.107,-.685,-.351,-.037,-.207,.032,-.351,-.100,.225,.142,.216,.176,.142)*f2_3+
    mat4(.350,.223,.265,-.220,.392,-.208,-.171,.082,.532,.082,-.142,-.802,-.285,-.224,-.240,.127)*f2_4+
    mat4(.207,.014,.197,-.480,.044,.371,-.089,-.360,-.111,-.021,.290,-.291,-.201,.367,.184,-.345)*f2_5+
    mat4(-.547,-.130,.061,.489,.233,.080,.516,.022,-.287,-.650,-.581,.378,.309,-.257,.215,.168)*f2_6+
    mat4(-.362,-.334,.426,.087,.347,-.310,.133,.006,.401,.017,-.394,-.266,.127,-.034,.328,.177)*f2_7+
    vec4(-.388,-.472,-.506,.460))/1.7+f2_4;
vec4 f3_5=sin(mat4(.014,.051,-.302,.211,.103,.153,.126,.084,.324,-.533,-.233,.169,-.311,.157,-.253,-.301)*f2_0+
    mat4(-.418,.233,-.378,.426,.102,.205,.681,.210,.203,.176,-.181,.002,.339,.245,.155,.157)*f2_1+
    mat4(-.226,-.350,-.438,.473,-.263,-.340,-.029,-.028,.237,.320,.298,-.068,-.088,-.397,.005,.080)*f2_2+
    mat4(.028,.383,.086,.139,-.140,-.174,-.677,.605,-.467,-.290,-.273,-.259,.163,-.047,.467,-.106)*f2_3+
    mat4(.123,.143,.073,.024,-.316,.168,.151,-.088,.258,-.422,-.483,.002,-.013,.021,-.438,.653)*f2_4+
    mat4(.326,-.220,.154,.123,-.051,.057,.210,.401,-.106,-.139,.198,.237,-.669,.077,.058,.629)*f2_5+
    mat4(-.623,-.219,-.282,-.001,-.002,.301,-.084,-.012,-.452,.294,-.468,-.225,.083,-.316,-.031,-.144)*f2_6+
    mat4(-.509,.216,.150,.027,-.053,-.539,.589,-.167,.072,-.428,.278,-.243,.058,-.188,.340,-.062)*f2_7+
    vec4(-.394,.570,-.577,-.111))/1.7+f2_5;
vec4 f3_6=sin(mat4(-.143,.224,-.136,.106,.098,.055,-.178,.197,.109,-.312,-.042,.544,-.060,-.050,.578,-.191)*f2_0+
    mat4(.192,-.433,.620,-.018,.247,.021,-.103,-.013,.160,-.318,.015,.337,.032,-.219,.277,-.162)*f2_1+
    mat4(-.231,.076,.419,-.256,-.036,.200,-.250,.393,.335,-.306,.169,-.442,-.432,-.182,-.105,.122)*f2_2+
    mat4(.075,.143,-.083,.044,.525,-.299,-.063,-.618,-.362,.159,.127,.314,.802,.106,.273,-.049)*f2_3+
    mat4(.166,-.453,-.081,.046,-.235,-.116,.274,-.106,-.181,-.573,-.218,-.121,.049,-.339,.472,.245)*f2_4+
    mat4(-.250,.009,-.740,-.079,.063,.222,-.083,-.067,-.072,.098,-.349,-.096,.249,-.133,-.208,-.254)*f2_5+
    mat4(.513,.476,-.032,-.301,-.023,.119,-.064,-.159,-.072,-.206,.973,-.158,.041,.008,.061,-.091)*f2_6+
    mat4(.570,.028,.623,-.370,-.510,-.235,.317,-.120,.101,-.182,.241,.360,.042,-.112,.120,.320)*f2_7+
    vec4(-.274,-.606,.549,-.168))/1.7+f2_6;
vec4 f3_7=sin(mat4(-.410,.098,.023,-.120,-.193,-.077,.140,-.510,-.142,-.167,-.084,-.049,.134,-.268,.082,.109)*f2_0+
    mat4(-.054,-.180,.447,.020,.210,.057,.454,.038,-.018,.481,.034,-.251,-.045,.415,.091,.177)*f2_1+
    mat4(.589,-.002,-.186,-.175,-.059,-.292,-.063,.058,.408,.214,-.373,.393,-.077,.470,-.013,-.373)*f2_2+
    mat4(-.157,-.203,-.092,.219,-.331,-.236,-.305,.577,-.485,.212,.056,.111,-.714,.768,.484,.068)*f2_3+
    mat4(.285,-.004,-.001,.346,.064,.326,.115,-.183,.473,-.325,-.062,-.014,.037,-.199,-.068,.073)*f2_4+
    mat4(.447,-.153,-.467,-.022,-.206,-.119,.033,-.116,-.033,-.136,-.145,-.264,.146,-.443,-.201,.448)*f2_5+
    mat4(-.733,-.134,.037,.115,-.091,.172,.194,-.267,-.195,-.166,-.122,.399,-.241,.086,-.044,.065)*f2_6+
    mat4(-.273,-.532,.084,.031,.194,.391,-.095,.118,-.013,.727,-.716,-.064,-.191,-.203,-.042,-.151)*f2_7+
    vec4(-.009,.238,.254,.717))/1.7+f2_7;
vec4 f4_0=sin(mat4(-.199,.182,-.171,-.034,.287,-.038,.206,.198,.294,.284,-.725,.118,.348,.272,-.189,-.606)*f3_0+
    mat4(-.058,.798,-.185,-.579,-.148,.216,.051,-.352,.329,.199,.066,-.092,.531,-.023,-.154,.283)*f3_1+
    mat4(-.294,-.023,.016,-.279,.007,.172,.011,-.125,-.463,-.064,.614,.103,-.058,.071,-.070,.582)*f3_2+
    mat4(-.149,-.090,-.030,-.268,.495,-.050,.121,-.317,-.012,-.364,-.234,-.361,.099,-.294,-.087,.120)*f3_3+
    mat4(-.113,-.251,-.173,.063,.089,-.370,.380,.367,-.277,.030,-.069,.051,-.335,.471,-.411,.175)*f3_4+
    mat4(-.201,.026,.451,.271,.005,-.078,.239,-.030,-.236,.534,-.051,.141,-.180,.119,-.078,-.276)*f3_5+
    mat4(.381,.216,-.176,-.106,-.071,.079,.270,.642,-.239,.212,-.400,-.571,.164,.265,-.548,-.043)*f3_6+
    mat4(.096,.132,.123,-.251,.240,-.034,.132,-.066,-.307,-.357,-.458,.345,.153,-.091,.212,.302)*f3_7+
    vec4(-.058,.091,-.847,-.323))/2.0+f3_0;
vec4 f4_1=sin(mat4(-.126,-.059,.111,-.376,.117,-.327,.098,-.059,-.321,-.254,.052,-.377,.261,-.309,-.035,.140)*f3_0+
    mat4(.369,-.245,-.119,-.170,-.340,-.130,-.099,.088,.129,-.281,-.187,.265,-.097,.504,-.353,.640)*f3_1+
    mat4(.450,-.328,-.422,-.093,.162,.297,.015,-.008,.637,-.023,.191,.154,.051,-.474,.099,-.050)*f3_2+
    mat4(-.170,-.268,-.121,-.044,-.233,.204,-.492,-.381,-.120,-.272,.495,-.433,.096,.269,.701,.183)*f3_3+
    mat4(-.257,.228,-.395,-.085,.537,.175,-.057,.202,.307,-.271,-.224,.239,-.001,.293,.211,-.498)*f3_4+
    mat4(-.091,-.195,.134,.339,-.403,-.498,.327,-.140,.018,-.189,.328,-.092,.122,.279,-.172,-.471)*f3_5+
    mat4(.122,.196,.312,-.101,.170,.392,-.029,.195,.198,-.046,.043,-.128,.130,-.373,-.410,-.008)*f3_6+
    mat4(.259,-.027,.176,-.290,-.046,-.292,.136,.211,-.277,.090,-.446,.038,.369,-.298,.252,-.056)*f3_7+
    vec4(-.048,.321,-.036,.284))/2.0+f3_1;
vec4 f4_2=sin(mat4(.256,.104,-.125,-.001,.279,-.346,.366,-.173,.499,-.347,-.135,.321,.267,-.347,.125,-.016)*f3_0+
    mat4(.313,-.233,.197,.261,.032,-.273,.009,.113,.155,.103,.154,-.315,-.036,.365,.344,-.173)*f3_1+
    mat4(.195,-.031,.114,.140,-.203,-.007,.222,-.060,-.233,-.143,.542,.185,.070,-.612,.782,.862)*f3_2+
    mat4(.096,-.097,-.119,-.117,-.354,-.018,-.087,.183,.326,.332,.056,-.040,-.189,-.480,-.056,.017)*f3_3+
    mat4(-.171,-.120,.101,.566,-.228,-.299,.001,-.048,-.064,-.408,-.084,.325,.223,.142,.278,.273)*f3_4+
    mat4(-.444,-.090,-.093,.304,.069,.060,.201,.063,-.139,.075,.162,.041,-.502,-.232,.394,-.024)*f3_5+
    mat4(-.079,.271,.039,-.020,-.382,.349,-.374,.216,.199,.216,.072,.001,.091,.164,-.546,-.088)*f3_6+
    mat4(-.118,-.592,.389,-.697,.152,.120,-.063,.133,.389,.212,.063,.059,-.094,-.211,.342,-.075)*f3_7+
    vec4(.164,.076,-.188,-.326))/2.0+f3_2;
vec4 f4_3=sin(mat4(-.102,-.005,.172,-.158,-.103,.231,.131,.105,-.195,-.297,-.320,.025,.029,.533,-.215,.047)*f3_0+
    mat4(-.077,.007,.020,.313,-.025,.012,.088,-.037,-.076,.220,.001,-.142,.300,-.160,.079,.300)*f3_1+
    mat4(-.410,-.004,-.151,.086,-.199,-.003,.074,-.189,-.377,-.201,-.063,-.151,-.283,.122,-.569,.883)*f3_2+
    mat4(.024,.330,.114,-.147,.290,-.113,.003,.010,.042,.224,.528,-.316,.002,-.256,.081,.008)*f3_3+
    mat4(.033,-.225,-.193,.419,-.212,.307,.170,-.337,-.466,-.475,.002,.223,-.367,-.182,-.204,.135)*f3_4+
    mat4(-.312,.112,.245,-.253,.483,-.219,-.074,-.442,.227,.113,-.399,.245,-.122,-.437,.169,.030)*f3_5+
    mat4(.408,.031,-.248,.215,.525,-.019,-.259,-.159,.169,.467,.210,.381,.259,.152,-.003,.419)*f3_6+
    mat4(-.421,-.174,-.257,-.024,.113,-.161,.007,.051,.294,-.056,.013,.149,.417,.127,-.709,-.109)*f3_7+
    vec4(.026,.230,.123,.030))/2.0+f3_3;
vec4 f4_4=sin(mat4(.388,-.301,-.089,-.186,-.094,-.390,.305,.292,.561,.182,.296,-.194,.187,.188,-.480,.098)*f3_0+
    mat4(.183,-.017,.148,-.090,-.139,-.030,.012,.326,.254,-.078,.436,-.045,-.415,.005,-.192,-.084)*f3_1+
    mat4(.386,.074,-.202,-.014,.248,-.026,.344,-.115,-.337,.013,-.473,-.391,.097,-.570,.221,-.311)*f3_2+
    mat4(.284,.001,.286,.016,.202,-.255,.116,.229,.134,.085,-.219,.106,-.372,.305,.147,-.405)*f3_3+
    mat4(.397,-.244,-.166,.087,-.318,-.409,-.142,.268,.216,.188,.273,.203,.358,.266,.296,.117)*f3_4+
    mat4(.054,-.285,.189,-.366,.018,-.184,-.025,-.127,.204,-.486,-.279,.157,-.260,-.223,-.208,.521)*f3_5+
    mat4(-.023,.162,.149,-.120,-.135,-.075,.453,-.073,-.170,-.037,-.863,.137,.236,-.086,-.074,.489)*f3_6+
    mat4(-.531,.247,-.278,-.262,-.179,-.347,.366,.450,.161,-.282,-.448,.756,.117,-.099,-.020,.103)*f3_7+
    vec4(.536,.191,-1.259,.382))/2.0+f3_4;
vec4 f4_5=sin(mat4(-.302,-.181,-.350,-.052,-.213,.292,.126,-.116,-.281,-.581,.484,.151,-.014,-.129,.394,-.261)*f3_0+
    mat4(.078,-.288,.544,.035,-.218,.395,.249,-.112,-.098,-.301,.435,.176,-.010,.212,-.550,-.033)*f3_1+
    mat4(.099,.279,.454,-.346,-.249,-.117,.505,-.152,.094,.094,-.341,-.036,.349,-.579,-.234,.106)*f3_2+
    mat4(-.117,.335,-.364,.269,-.085,.123,.427,-.721,-.129,-.203,-.364,-.161,.136,-.631,-.170,-.332)*f3_3+
    mat4(.214,-.023,-.134,.606,.193,-.020,-.099,-.069,-.198,-.171,.216,-.304,-.395,-.392,.149,.095)*f3_4+
    mat4(.205,.340,.133,-.018,-.197,.530,.012,.223,.174,-.041,-.404,-.216,-.041,.406,-.132,-.131)*f3_5+
    mat4(-.098,-.113,.393,.105,.231,.098,-.084,.263,.121,.022,-.165,-.055,.315,-.022,.175,-.078)*f3_6+
    mat4(.384,-.016,-.373,-.477,-.210,.068,-.195,-.188,-.235,-.124,-.274,-.112,.954,-.160,-.227,.467)*f3_7+
    vec4(.373,-.441,-.345,-.248))/2.0+f3_5;
vec4 f4_6=sin(mat4(-.036,-.177,-.004,-.218,.260,-.240,-.071,.297,.308,.116,-.116,.335,-.030,-.270,.427,.445)*f3_0+
    mat4(-.158,-.129,.317,.008,.177,-.382,-.249,-.083,-.149,.016,.199,-.232,.267,-.124,-.081,-.433)*f3_1+
    mat4(.173,.260,-.017,.018,.252,-.006,-.101,-.121,.345,.332,.422,-.363,-.727,-.375,.399,.690)*f3_2+
    mat4(-.412,-.238,.366,.292,-.162,-.054,.342,-.422,-.194,.212,.302,.093,-.260,-.349,-.049,.343)*f3_3+
    mat4(-.062,.077,.382,.217,-.227,-.118,-.542,-.096,.051,-.345,-.049,.015,-.130,.399,-.010,.044)*f3_4+
    mat4(.263,-.605,-.029,-.127,.424,-.070,.257,.221,.045,.090,.117,-.263,-.097,.228,.127,-.226)*f3_5+
    mat4(-.380,-.049,-.395,.380,.217,-.658,.274,-.105,-.569,.356,1.060,-.277,-.317,-.666,-.277,-.259)*f3_6+
    mat4(-.686,-.040,.058,.308,.493,-.110,-.259,.128,-.354,.359,.226,.247,.011,-.016,.219,.297)*f3_7+
    vec4(-.362,.536,1.280,.118))/2.0+f3_6;
vec4 f4_7=sin(mat4(-.129,-.152,-.659,.542,-.200,-.194,.178,.111,.201,.036,.174,-.114,-.065,-.637,-.247,-.305)*f3_0+
    mat4(-.328,-.055,-.361,.019,.338,-.214,.165,.180,-.520,.210,.284,.122,-.490,-.037,-.259,-.085)*f3_1+
    mat4(-.278,.155,.513,.128,-.119,.168,.103,.133,-.022,.125,-.391,-.163,-.076,-.296,-.001,-.444)*f3_2+
    mat4(.351,.369,.311,.134,.933,-.501,-.600,.641,-.162,.008,-.154,.026,.518,-.435,.241,.176)*f3_3+
    mat4(-.002,-.087,-.097,-.632,-.438,.818,.324,.196,-.039,.260,-.207,-.307,.327,-.129,-.162,-.485)*f3_4+
    mat4(-.185,.152,.458,.161,-.045,-.134,.097,.315,-.095,-.055,.036,.182,-.265,-.576,-.100,.283)*f3_5+
    mat4(.263,-.377,-.056,.100,.203,-.130,.246,-.237,-.166,-.238,-.091,-.371,.304,.388,-.066,-.542)*f3_6+
    mat4(.186,-.343,.094,-.184,-.497,-.036,.010,-.162,.101,.016,-.043,-.193,.159,.037,.328,-.335)*f3_7+
    vec4(.010,-.133,-.331,-.594))/2.0+f3_7;
vec4 f5_0=sin(mat4(-.320,-.751,.036,.470,-.251,-.622,.054,.025,-.443,.170,-.410,.564,-.191,.230,-.271,-.133)*f4_0+
    mat4(.273,.070,-.165,.361,-.096,-.161,.108,.201,.297,-.251,.390,-.171,.347,-.035,.040,-.333)*f4_1+
    mat4(-.129,.524,-.201,-.013,-.151,-.742,.128,.314,-.177,.029,.624,-.252,.426,.761,.022,-.257)*f4_2+
    mat4(.218,-.551,.260,.282,-.056,-.321,.054,.162,-.367,.440,-.020,.233,-.171,-.045,.082,-.129)*f4_3+
    mat4(-.301,.386,-.184,-.259,.267,.123,.041,-.247,.232,-.273,.008,.361,-.168,.035,-.177,.476)*f4_4+
    mat4(.252,-.203,.488,-.055,.207,-.109,.514,.034,.397,.119,-.030,-.068,-.130,-.128,.102,.245)*f4_5+
    mat4(.421,.202,-.243,-.105,.736,.090,-.120,-.902,-.069,.618,-.078,-.306,.135,-.038,.021,.478)*f4_6+
    mat4(-.210,.354,.408,-.068,.370,-.169,-.228,-.220,-.434,.142,.064,.015,.030,.089,.009,-.380)*f4_7+
    vec4(-.751,1.146,-.492,-.089))/2.2+f4_0;
vec4 f5_1=sin(mat4(-.154,.402,.533,-.075,.500,-.338,.002,-.326,-.298,.290,.406,.031,.329,.566,-.143,-.379)*f4_0+
    mat4(.146,.257,-.360,-.394,.321,.069,-.220,-.204,-.370,-.077,.115,.115,.096,-.257,-.102,.262)*f4_1+
    mat4(.347,.086,-.057,-.254,-.171,-.406,-.180,-.116,.131,-.231,-.410,.619,-.334,.817,-.046,.436)*f4_2+
    mat4(.325,.373,-.257,-.106,-.266,-.022,.390,.127,-.074,.158,.054,-.051,-.343,.029,-.532,.082)*f4_3+
    mat4(.604,.254,-.004,.196,.153,-.065,-.253,-.034,-.290,.282,.406,-.384,-.113,.265,.026,-.156)*f4_4+
    mat4(-.092,-.245,.116,.147,.637,-.515,-.119,.531,.255,.119,.198,.655,.385,-.055,-.296,.240)*f4_5+
    mat4(-.127,-.456,-.111,.056,.407,-.096,-.027,.010,.077,.384,.064,-.527,-.320,.182,.175,-.198)*f4_6+
    mat4(-.397,-.178,-.259,.050,.366,-.130,.134,-.251,-.160,.185,.333,-.041,.107,-.034,-.326,.389)*f4_7+
    vec4(-.784,.504,-.048,-.048))/2.2+f4_1;
vec4 f5_2=sin(mat4(-.029,-.007,-.118,-.094,-.243,.606,.042,.193,-.280,.047,.519,-.500,.234,.581,-.179,.129)*f4_0+
    mat4(-.130,-.188,-.322,.365,-.200,-.160,.346,.085,.365,.578,-.102,-.159,.173,-.435,.209,.276)*f4_1+
    mat4(-.222,.212,-.354,-.213,-.161,.177,-.240,.125,.031,.330,-.476,-.004,-.286,-.074,.331,.333)*f4_2+
    mat4(-.074,.166,.454,.073,.107,-.128,-.041,-.106,.276,-.314,.418,.201,-.273,.214,.366,.338)*f4_3+
    mat4(-.204,.232,.314,-.107,-.061,-.220,-.130,.090,.322,.150,-.254,-.146,-.034,.047,-.459,-.412)*f4_4+
    mat4(.209,-.075,.245,-.519,-.139,-.195,.391,-.117,.121,-.095,.118,.241,.230,.279,-.258,.207)*f4_5+
    mat4(.069,-.066,.262,-.031,.341,-.274,.216,.164,.070,.468,-.453,.189,.091,-.271,.243,.290)*f4_6+
    mat4(.345,.107,-.570,.181,-.238,-.343,.242,-.217,.162,.146,-.154,.014,.204,-.039,-.063,-.082)*f4_7+
    vec4(.859,-.107,-.427,.135))/2.2+f4_2;
vec4 f5_3=sin(mat4(-.233,-.053,-.178,.106,.478,.130,-.019,.138,-.253,.301,-.117,.339,-.026,-.329,-.209,.100)*f4_0+
    mat4(.568,-.211,-.128,-.501,-.011,-.752,.213,-.136,-.281,-.357,.246,.277,-.061,.136,-.267,-.039)*f4_1+
    mat4(.134,.157,.182,.097,.301,-.113,-.196,.330,-.584,.126,-.012,-.092,-.064,.363,-.125,-.470)*f4_2+
    mat4(.025,.011,.031,.244,-.287,.301,.319,.212,-.074,.277,.577,.254,-.011,-.116,-.036,.283)*f4_3+
    mat4(.273,.123,-.683,.013,-.067,-.234,-.093,-.243,-.120,-.117,.309,.394,-.138,.063,-.627,.095)*f4_4+
    mat4(-.013,.182,1.020,-.037,.146,.038,.299,.290,.147,-.050,-.219,-.135,-.031,-.652,-.099,-.059)*f4_5+
    mat4(.110,.600,-.051,-.011,.318,.023,-.161,-.314,-.120,.035,-.014,-.325,.309,.154,-.271,-.054)*f4_6+
    mat4(.071,.058,.166,.043,.265,-.575,.137,-.089,-.399,.220,-.023,-.257,.082,.276,.170,-.701)*f4_7+
    vec4(-.745,-.306,.362,-.948))/2.2+f4_3;
vec4 f5_4=sin(mat4(-.312,-.253,-.214,.129,-.095,-.202,-.309,.572,-.186,-.267,-.719,.209,-.039,-.099,-.063,-.257)*f4_0+
    mat4(-.087,.129,-.222,-.479,.345,-.119,-.161,-.034,-.104,-.111,.152,-.194,-.187,.370,.033,.411)*f4_1+
    mat4(.134,-.395,.220,.035,.315,.039,.204,.203,.338,.080,.423,-.617,-1.139,-.578,-.219,-.897)*f4_2+
    mat4(.102,.031,-.159,.240,.048,.131,-.115,.263,.328,-.117,-.282,-.214,-.406,-.502,-.578,-.118)*f4_3+
    mat4(-.518,.205,.180,.166,.058,.038,.205,.057,-.312,-.604,.203,-.128,-.458,.156,.219,.686)*f4_4+
    mat4(.312,-.610,.546,-.127,.347,.067,.096,-.251,.015,.152,-.350,-.200,.341,.345,-.088,.041)*f4_5+
    mat4(.090,.249,-.325,.017,.010,.374,-.098,-.096,.244,.622,-.153,-.287,-.450,-.329,-.296,-.090)*f4_6+
    mat4(.483,.069,.095,-.308,-.226,-.418,.156,-.270,-.012,.307,-.049,.127,.013,.158,-.026,-.153)*f4_7+
    vec4(.564,.905,.020,-.107))/2.2+f4_4;
vec4 f5_5=sin(mat4(-.018,.118,-.470,.215,-.241,.275,.590,.502,.478,-.001,-.011,.002,.321,.479,-.286,.001)*f4_0+
    mat4(.190,.522,.054,.042,.106,-.012,.088,-.492,-.381,.187,-.073,-.777,-.279,-.183,.500,-.236)*f4_1+
    mat4(.258,.686,.122,-.210,.343,-.036,.061,.289,-.196,-.341,.284,-.155,-.460,.474,.123,.781)*f4_2+
    mat4(.019,.144,.482,-.055,.454,.111,.161,.240,-.115,.140,.195,-.003,.099,.200,-.415,.150)*f4_3+
    mat4(.258,.236,-.034,.499,.060,-.125,.545,-.272,.012,.248,-.693,.449,.341,.497,-.239,.555)*f4_4+
    mat4(-.720,-.148,.423,-.226,-.047,.350,.196,.062,.500,-.219,.040,.112,.181,-.216,-.290,.684)*f4_5+
    mat4(.168,.176,.296,.074,.207,.135,-.006,.078,.292,-.077,-.056,.032,-.157,.225,.435,-.357)*f4_6+
    mat4(.402,-.252,-.041,-.292,-.081,.087,.350,.008,.272,-.007,.320,-.412,-.208,.199,.195,.250)*f4_7+
    vec4(1.036,-.134,-.492,.029))/2.2+f4_5;
vec4 f5_6=sin(mat4(-.029,-.354,-.100,.375,-.136,-.216,.544,.086,-.060,.021,-.096,.293,-.580,-.243,.476,.116)*f4_0+
    mat4(.028,-.170,-.071,.179,-.141,.529,-.542,-.226,.351,-.163,.111,.144,.063,-.699,.339,.394)*f4_1+
    mat4(-.470,-.320,-.137,-.516,-.273,.214,-.114,.172,.218,.137,-.642,.130,.303,-.033,.050,.315)*f4_2+
    mat4(.092,-.192,.180,.179,-.067,.171,-.073,-.238,-.025,-.506,.118,.194,.229,.319,.218,-.133)*f4_3+
    mat4(.558,.034,-.101,.345,.422,-.374,.501,-.131,-.352,.536,.031,.219,-.078,-.025,-.373,.134)*f4_4+
    mat4(-.104,.474,.117,.109,-.255,.007,-.316,.117,.045,.500,.199,.118,.139,-.300,.236,-.572)*f4_5+
    mat4(.510,-.047,.339,-.257,-.131,.464,-.273,.091,.103,-.336,-.187,-.274,.417,.115,-.243,.410)*f4_6+
    mat4(.295,.498,.359,-.549,-.013,-.064,.068,-.006,.228,-.337,.210,.283,.018,-.157,.162,-.428)*f4_7+
    vec4(-.004,-.312,.218,-.162))/2.2+f4_6;
vec4 f5_7=sin(mat4(-.177,-.160,.237,-.852,-.381,.363,.556,-.085,-.094,.428,-.328,.097,.089,.147,.027,.210)*f4_0+
    mat4(-.193,.358,.315,.283,.358,.192,.013,.344,.553,-.028,.185,-.052,.752,-.179,-.435,-.553)*f4_1+
    mat4(-.567,-.146,-.235,-.130,.140,.021,-.216,-.129,-.063,-.406,.247,-.113,-.738,.272,-.093,.465)*f4_2+
    mat4(.377,.152,-.191,.197,.124,.134,.333,-.599,.225,.003,-.190,.433,-.155,.517,-.229,-.029)*f4_3+
    mat4(.008,.135,.233,.068,-.104,-.158,-.034,.537,-.593,.144,.032,-.236,-.210,-.121,-.525,-.188)*f4_4+
    mat4(.177,-.597,-.042,-.224,-.221,-.324,.166,-.101,-.538,.137,-.086,-.313,-.233,-.103,-.143,.366)*f4_5+
    mat4(.244,.446,.169,-.203,-.050,-.040,-.028,-.318,.544,.112,.559,-.319,-.240,.355,-.546,.074)*f4_6+
    mat4(-.269,-.485,.257,-.042,.260,-.102,-.314,.027,.100,-.069,.621,-.007,-.114,-.133,.022,.674)*f4_7+
    vec4(.586,-.230,.184,-.786))/2.2+f4_7;
vec4 f6_0=sin(mat4(.238,.171,.320,.172,.389,-.494,-.227,.931,.505,.344,-.167,.013,.045,.087,.042,.014)*f5_0+
    mat4(-.205,.335,-.094,.243,.591,.018,.064,.069,-.165,-.190,.050,-.005,-.669,-.301,-.318,-.110)*f5_1+
    mat4(.464,.401,.472,.079,.058,-.081,-.054,.571,-.567,-.107,-.365,.245,-.230,.307,.314,.020)*f5_2+
    mat4(-.352,-.523,-.154,-.182,.060,-.304,.089,-.031,.203,.147,.257,.145,.525,.212,-.008,-.391)*f5_3+
    mat4(-.338,.867,-.056,-.314,-.461,.350,-.116,-.021,.701,.233,.398,.250,.426,-.128,.359,-.195)*f5_4+
    mat4(.194,-.176,.312,.218,.005,-.236,.254,.128,.127,.200,.170,.345,-.337,.403,-.058,.236)*f5_5+
    mat4(.243,-.330,-.554,-.207,.217,-.337,-.279,-.734,-.481,.382,-.099,-.219,.072,.095,-.087,-.274)*f5_6+
    mat4(.050,-.124,-.209,-.119,-.152,.093,.022,-.371,-.064,.233,-.434,-.563,-.083,.526,-.285,-.324)*f5_7+
    vec4(-.479,.677,-.415,-.700))/2.4+f5_0;
vec4 f6_1=sin(mat4(.120,.201,-.556,-.349,.367,.507,-.176,-.637,-.474,.156,-.196,.051,-.024,.082,.467,-.014)*f5_0+
    mat4(.672,.521,.014,-.005,-.094,.216,.068,-.335,.183,-.349,.451,.278,.220,-.042,.394,-.154)*f5_1+
    mat4(.448,-.142,-.219,-.129,.036,.509,.618,-.225,-.267,-.516,.472,.283,.155,-.297,-.136,-.326)*f5_2+
    mat4(.014,-.011,-.174,-.073,-.374,.677,-.072,-1.134,-.596,-.295,-.258,-.009,-.483,.189,-.334,-.244)*f5_3+
    mat4(.520,.499,.130,-.295,.080,-.173,-.290,.303,-.156,.294,.157,-.469,.256,.695,.147,-.459)*f5_4+
    mat4(-.843,-.358,-.134,.047,.426,.303,-.501,.057,.385,.293,-.227,.118,.196,.017,-.047,.042)*f5_5+
    mat4(.319,.146,-.200,.222,-.113,-.102,-.042,-.191,.081,-.378,.479,.223,.083,-.192,-.253,-.526)*f5_6+
    mat4(.195,.259,-.276,.116,.006,-.277,.067,.408,.101,.072,.439,.042,.191,-.109,-.048,-.201)*f5_7+
    vec4(-.471,-.395,.634,-.379))/2.4+f5_1;
vec4 f6_2=sin(mat4(-.164,-.255,-.044,.386,-.204,.178,.204,.501,.141,-.213,-.733,.406,.119,-.240,.005,.516)*f5_0+
    mat4(-.522,-.272,.083,.489,-.382,-.067,-.328,-.055,.172,.054,.489,-.026,-.299,.651,-.103,.477)*f5_1+
    mat4(.527,-.055,.479,.333,-.091,-.036,-.380,.494,.194,.090,.366,-.241,-.200,.089,-.396,.238)*f5_2+
    mat4(.124,-.191,-.133,.530,-.063,.116,.067,.101,-.379,-.061,-.045,-.136,-.159,.439,.050,-.241)*f5_3+
    mat4(-.158,.098,-.224,-.239,.145,-.134,-.034,-.199,.456,-.034,.310,.506,.070,.603,.056,-.185)*f5_4+
    mat4(-.037,.032,.349,.355,.163,.090,-.307,.148,-.067,.038,-.018,-.173,-.324,-.030,.044,.221)*f5_5+
    mat4(-.477,.336,.286,.204,.233,-.496,.045,-.009,-.173,.285,-.005,-.176,-.252,-.340,-.507,.207)*f5_6+
    mat4(-.318,-.126,.331,-.066,.138,.521,-.074,-.140,-.388,.251,-.262,-.183,-.272,.095,.242,-.139)*f5_7+
    vec4(-.247,-.342,-.179,-.799))/2.4+f5_2;
vec4 f6_3=sin(mat4(.329,-.183,.032,.063,.187,-.502,-.444,-.041,.225,-.095,.235,.043,.023,-.596,-.300,.038)*f5_0+
    mat4(.412,.308,.019,-.156,.378,-.072,-.001,.508,-.026,-.054,.379,-.315,.283,.254,-.218,.064)*f5_1+
    mat4(.181,.280,.349,-.285,-.015,.228,.361,.129,-.266,-.044,-.058,.007,.137,.825,-.164,.336)*f5_2+
    mat4(.622,-.233,.088,.112,.158,.417,.291,.013,.206,-.307,-.668,-.608,-.009,-.072,.586,.274)*f5_3+
    mat4(-.316,.393,.064,.298,.031,.141,.312,.265,-.306,-.557,.688,.037,-.135,.668,.424,-.333)*f5_4+
    mat4(.088,-.352,-.345,.159,-.009,.074,.215,-.006,.162,.001,-.093,.165,-.295,-.198,.036,.321)*f5_5+
    mat4(.135,.270,.131,-.399,-.054,.223,-.050,.548,.286,-.083,-.191,-.245,.511,.406,-.069,.100)*f5_6+
    mat4(-.512,-.104,-.121,-.076,-.332,-.244,.215,.224,-.218,-.065,-.156,.017,-.116,-.025,.102,.480)*f5_7+
    vec4(.460,.583,-.557,-.438))/2.4+f5_3;
vec4 f6_4=sin(mat4(.055,.032,.101,-.215,-.142,.286,.324,-.065,.187,.228,.221,-.424,.064,-.242,-.366,.444)*f5_0+
    mat4(.096,-.257,-.188,-.221,.339,-.114,.028,-.357,-.180,.365,-.108,-.135,-.121,.145,.430,-.512)*f5_1+
    mat4(-.528,.443,-.596,.420,.236,.125,.158,.432,.340,-.263,-.070,.119,.155,.378,-.027,-.214)*f5_2+
    mat4(.369,.170,-.063,.258,.557,-.013,-.032,-.434,.445,.614,.060,-.119,-.017,.455,.000,.309)*f5_3+
    mat4(-.277,-.496,.337,.364,-.123,-.768,.130,.146,-.339,.132,-.209,-.117,.096,-.101,-.193,-.152)*f5_4+
    mat4(-.021,-.019,-.047,-.083,-.201,.150,.360,-.060,.041,.268,.022,.201,.338,.141,-.501,.475)*f5_5+
    mat4(.365,.152,.483,-.075,.223,.135,.289,-.169,.187,.046,-.123,.286,.079,.372,.310,-.210)*f5_6+
    mat4(.055,.418,-.567,.349,-.137,-.148,.068,.055,-.224,-.217,.017,.137,-.273,.044,.064,.481)*f5_7+
    vec4(.152,-.519,-.578,.358))/2.4+f5_4;
vec4 f6_5=sin(mat4(-.227,.208,.265,.237,-.365,.345,.318,-.015,.141,.605,.621,-.273,.459,-.010,.588,-.011)*f5_0+
    mat4(.031,.656,.330,.244,.138,.073,.402,-.078,-.121,-.024,.214,-.035,.110,-.079,-.576,.051)*f5_1+
    mat4(-.435,.687,.436,-.179,-.052,-.216,.492,.146,.233,-.183,-.284,.229,.367,.247,-.257,.669)*f5_2+
    mat4(-.028,-.164,-.243,-.414,-.437,-.298,.091,-.098,.144,.371,-.156,.286,.005,-.389,.229,-.026)*f5_3+
    mat4(-.390,-.150,-.372,-.110,.478,.250,-.207,.531,.020,-.336,.637,.294,.074,.029,.047,-.097)*f5_4+
    mat4(.014,-.387,.118,-.054,-.222,.257,-.211,-.326,.011,-.096,.192,.251,.284,.193,.259,-.359)*f5_5+
    mat4(.176,.309,-.059,.358,-.032,-.176,-.331,-.224,.135,.027,-.299,.197,-.093,.262,.001,-.079)*f5_6+
    mat4(-.116,-.095,-.051,-.214,.034,.361,-.342,-.177,.355,.269,-.373,-.092,.642,.082,-.007,.031)*f5_7+
    vec4(.691,-.127,-.174,.041))/2.4+f5_5;
vec4 f6_6=sin(mat4(.170,-.036,.008,-.075,.197,.263,-.119,.365,-.076,.079,-.062,.047,-.110,.394,.177,.202)*f5_0+
    mat4(.633,.079,.089,-.155,.182,.266,-.400,-.275,.038,-.648,-.391,.155,-.085,-.465,.387,.311)*f5_1+
    mat4(-.049,-.133,-.112,-.091,.243,.153,-.411,.292,.143,.074,.113,-.204,-.090,-.087,.368,.505)*f5_2+
    mat4(.413,.231,.375,-.211,.288,-.113,-.360,.120,-.160,.621,.102,-.364,-.117,.290,-.153,.097)*f5_3+
    mat4(-.190,-.099,.036,-.016,.035,-.728,-.001,-.304,-.445,-.169,.073,-.342,.254,-.032,.178,.297)*f5_4+
    mat4(.329,.003,-.054,.154,.078,-.055,-.402,-.154,-.259,.370,-.306,.070,-.051,.054,-.343,-.543)*f5_5+
    mat4(-.531,-.163,.148,.218,.282,-.699,-.574,.531,.489,.200,.965,-.437,.098,-.327,-.612,-.117)*f5_6+
    mat4(.080,-.050,.237,-.227,.117,-.500,-.058,-.207,.246,.365,.108,.057,-.158,-.085,-.452,.083)*f5_7+
    vec4(.336,.102,.175,-.189))/2.4+f5_6;
vec4 f6_7=sin(mat4(.452,.035,.212,.106,.199,-.018,-.131,.005,.088,-.421,-.001,.811,-.272,.211,.124,-.277)*f5_0+
    mat4(.327,-.275,.316,-.046,-.158,.154,.609,.372,-.152,.203,-.383,-.297,-.158,.048,-.098,-.764)*f5_1+
    mat4(-.433,.007,.067,.824,.032,.011,.191,.088,.530,-.670,-.348,-.481,-.107,-.067,-.225,-.111)*f5_2+
    mat4(-.353,.028,.668,.053,-.227,.400,.243,.391,.188,-.100,.057,.118,-.118,.660,.017,.143)*f5_3+
    mat4(-.644,.199,-.093,-.323,-.100,-.754,-.087,-.170,-.065,.473,-.223,-.018,-.008,.429,-.078,.008)*f5_4+
    mat4(.019,-.147,-.285,.131,.619,-.063,.107,-.020,.420,-.064,.024,.086,-.896,.083,.137,.083)*f5_5+
    mat4(.130,.090,.065,-.306,-.253,.083,.212,-.047,-.092,-.258,.311,-.167,.059,-.405,.404,-.324)*f5_6+
    mat4(.900,-.077,-.414,-.027,.202,-.039,-.054,.138,.166,-.190,-.520,-.230,.039,-.009,-.348,-.396)*f5_7+
    vec4(-.386,.632,.537,-.371))/2.4+f5_7;
vec4 f7_0=sin(mat4(.466,.078,-.012,.100,-.158,-.079,.112,.263,.050,-.235,.078,-.425,-.347,.287,-.564,.727)*f6_0+
    mat4(.182,.306,.207,.277,-.150,.367,-.002,.542,-.182,-.135,-.021,-.402,.462,.074,-.079,-.061)*f6_1+
    mat4(.012,.297,-.005,-.022,.030,.665,.193,-.260,-.679,-.543,.049,-.154,-.435,-.271,.101,.014)*f6_2+
    mat4(.359,.300,.219,-.102,.216,-.253,-.269,.090,-.006,.103,.043,.354,-.369,.044,-.134,.339)*f6_3+
    mat4(.499,.349,-.444,.070,-.324,.188,.370,-.154,.191,.387,-.059,.500,.095,-.127,.160,-.243)*f6_4+
    mat4(.068,-.228,-.227,.318,-.271,.071,-.078,-.250,.055,-.166,-.055,-.211,-.149,.167,-.029,.099)*f6_5+
    mat4(.348,.381,-.074,-.169,.337,-.164,.060,-.422,.115,-.099,-.021,.057,.366,-.219,-.271,-.690)*f6_6+
    mat4(-.322,-.020,.182,.159,-.385,.189,.231,-.208,-.274,-.703,.479,.103,-.722,-.113,.426,-.380)*f6_7+
    vec4(.654,-.143,-.652,-.491))/2.6+f6_0;
vec4 f7_1=sin(mat4(-.012,.275,.265,-.140,-.382,.649,.089,.001,-.364,.473,.245,-.463,.169,.366,.060,.288)*f6_0+
    mat4(.196,-.647,.307,-.037,.544,.173,-.030,.424,.313,-.306,.171,-.028,-.381,-.276,.858,-.521)*f6_1+
    mat4(-.001,-.165,.290,-.027,-.398,.464,.284,-.086,.165,-.134,-.071,-.245,-.447,-.979,.123,-.645)*f6_2+
    mat4(.042,-.001,-.118,.222,.485,.193,-.016,.400,.323,.318,-.139,-.497,-.673,-.134,-.296,-.501)*f6_3+
    mat4(-.538,-.573,-.050,-.100,.154,-.290,-.131,-.268,.204,.254,-.324,-.236,-.310,-.049,.075,-.239)*f6_4+
    mat4(.686,-.073,.113,.256,-.381,.309,.238,-.066,.132,-.126,-.085,-.188,-.177,-.299,-.650,.003)*f6_5+
    mat4(.303,-.219,-.016,-.161,.100,.064,-.169,-.378,.028,-.271,.256,.233,.236,-.266,-.185,-.468)*f6_6+
    mat4(.148,-.045,.243,.226,.153,-.399,-.038,.438,-.242,-.118,.599,.427,.094,-.540,-.815,-.062)*f6_7+
    vec4(.407,-.477,-.341,.582))/2.6+f6_1;
vec4 f7_2=sin(mat4(-.009,.123,.123,.208,-.062,.313,-.361,.199,.005,.051,-.119,.340,-.742,.177,.411,-.449)*f6_0+
    mat4(.139,-.087,.149,-.116,-.214,-.003,-.110,.047,.279,.452,.404,.114,.285,.281,-.246,.621)*f6_1+
    mat4(-.842,.423,-.287,-.161,.108,.473,.394,-.331,.013,-.041,.508,-.394,.185,-.290,-.020,.511)*f6_2+
    mat4(.363,-.072,.267,.035,.317,-.035,.371,.023,-.090,-.158,.354,-.336,.269,-.569,.228,-.070)*f6_3+
    mat4(.011,-.496,.039,.576,.422,-.213,-.086,.507,-.018,-.029,.187,-.202,.303,.313,.307,.428)*f6_4+
    mat4(-.196,.084,.030,-.421,.376,.338,.218,-.159,-.194,-.474,.343,-.038,.114,.219,.092,-.085)*f6_5+
    mat4(.200,-.432,.099,.203,.218,-.100,.128,.395,-.543,.043,-.185,.181,.373,.246,-.082,.407)*f6_6+
    mat4(.007,-.646,.322,-.094,.290,.060,-.301,-.225,.171,.222,-.346,.398,.365,-.030,-.329,.204)*f6_7+
    vec4(-1.019,.681,.041,-.269))/2.6+f6_2;
vec4 f7_3=sin(mat4(-.121,.306,-.339,-.063,.190,-.148,-.325,.183,.468,.376,.343,.041,.020,-.169,.013,-.632)*f6_0+
    mat4(.359,-.177,-.150,-.062,-.498,.013,-.612,.321,-.108,.353,-.116,.090,-.770,-.299,-.347,-.249)*f6_1+
    mat4(.459,.502,.285,-.131,-.205,-.057,-.170,-.033,.219,-.472,-.463,.278,-.056,.271,-.195,-.128)*f6_2+
    mat4(-.801,-.126,.268,.073,-.072,-.123,-.285,.448,.358,-.082,.564,-.318,-.430,.104,.192,-.567)*f6_3+
    mat4(-.366,.097,-.498,-.149,-.066,-.011,-.372,.019,.291,.072,.325,-.184,.002,.126,.427,.072)*f6_4+
    mat4(-.041,.107,.124,.665,-.021,.029,.594,-.107,-.338,.333,-.222,-.184,-.301,.374,-.327,-.155)*f6_5+
    mat4(.054,.017,-.010,.131,-.600,-.051,-.316,.467,.160,-.111,.102,-.556,.014,.194,.401,-.044)*f6_6+
    mat4(.275,-.636,.374,.184,.223,.567,-.007,.047,-.275,-.200,-.552,-.155,.139,.242,-.050,.499)*f6_7+
    vec4(.311,-.705,.485,-.359))/2.6+f6_3;
vec4 f7_4=sin(mat4(-.140,.192,-.138,.128,-.102,-.395,.325,.420,-.018,.023,-.140,-.052,-.429,.352,.693,-.070)*f6_0+
    mat4(.193,-.396,.256,.404,-.475,-.032,.346,.497,-.274,-.011,-.079,-.394,.539,.213,-.330,-.241)*f6_1+
    mat4(.262,-.308,-.214,.231,-.195,-.003,-.095,.072,-.127,.112,.053,-.517,.161,.212,.338,-.315)*f6_2+
    mat4(-.771,.030,.450,.178,-.191,-.130,-.267,.005,-.036,.179,.146,-.231,.494,.121,.115,.116)*f6_3+
    mat4(.180,.309,-.371,.998,.148,.254,-.144,.121,.167,.046,-.188,.131,.515,-.318,.190,.274)*f6_4+
    mat4(-.321,-.055,.627,.045,.272,-.359,.235,-.170,-.186,.117,-.350,-.143,.274,.276,.096,.273)*f6_5+
    mat4(.028,.001,.370,.082,-.107,.039,-.310,-.110,.053,-.495,.270,-.193,-.407,.450,-.120,-.157)*f6_6+
    mat4(.423,.059,.361,-.289,.349,-.293,-.170,-.523,.329,.191,.283,-.439,.134,.224,.152,-.020)*f6_7+
    vec4(.178,.286,-.108,.365))/2.6+f6_4;
vec4 f7_5=sin(mat4(-.275,.521,-.786,-.225,-.056,.427,-.250,.161,-.261,-.250,-.519,.126,.595,.145,.504,.045)*f6_0+
    mat4(-.212,-.315,.540,-.023,.266,-.133,-.317,-.283,-.397,.121,.499,-.482,-.231,.121,.061,.201)*f6_1+
    mat4(-.206,-.500,.220,.038,-.134,.727,-.443,-.231,-.037,.284,.141,.192,-.292,-.326,.414,.361)*f6_2+
    mat4(-.373,.288,-.284,.122,.110,-.166,-.046,.054,.136,.084,-.154,.163,.531,.180,-.040,.295)*f6_3+
    mat4(.077,-.017,.290,-.306,.044,-.380,.137,.199,.327,-.390,.270,.202,-.229,-.218,.232,.128)*f6_4+
    mat4(-.507,.433,-.094,.023,-.178,-.069,-.044,.182,.311,-.142,-.308,-.293,.011,.444,.020,-.684)*f6_5+
    mat4(-.222,.513,-.676,-.104,-.330,-.062,-.122,-.297,.223,-.023,.347,.125,-.146,-.030,-.431,-.487)*f6_6+
    mat4(.140,-.251,.024,-.126,.115,-.568,.268,-.111,.438,.053,.017,-.281,-.254,-.088,.519,.080)*f6_7+
    vec4(.659,.325,.992,-.310))/2.6+f6_5;
vec4 f7_6=sin(mat4(.279,.281,-.120,-.119,-.008,.391,-.008,.016,-.036,-.308,-.068,.621,-.315,.023,.936,-.113)*f6_0+
    mat4(-.432,.374,.307,.107,-.088,.330,.184,-.375,.385,.322,.284,.291,.521,.378,-.049,.404)*f6_1+
    mat4(-.503,.659,-.011,-.065,-.197,.185,-.151,.343,.089,-.341,.078,-.076,-.373,.047,-.809,.438)*f6_2+
    mat4(.005,-.174,.357,.462,.406,.071,-.049,-.041,-.351,-.749,-.473,.248,-.199,-.132,.133,.168)*f6_3+
    mat4(-.286,.562,.561,-.105,-.324,-.403,.276,-.215,.279,.494,.125,-.101,.354,.596,.012,-.029)*f6_4+
    mat4(-.174,-.305,-.331,-.254,.059,-.042,-.205,-.054,.218,.214,.117,-.024,.287,.061,.062,-.443)*f6_5+
    mat4(.254,-.135,.087,.263,.347,-.395,.273,.189,-.309,.073,.159,.484,.265,.222,-.059,.112)*f6_6+
    mat4(.203,.078,-.207,.569,-.332,.016,-.075,.117,.190,.017,-.158,.221,-.027,-.399,.186,.007)*f6_7+
    vec4(.237,-.058,1.153,-.035))/2.6+f6_6;
vec4 f7_7=sin(mat4(.272,-.513,.175,.510,.468,-.414,.150,.302,-.246,.078,.078,-.442,.273,-.038,-.410,-.195)*f6_0+
    mat4(-.037,-.128,-.114,-.164,-.082,-.164,.167,.368,.263,.327,-.190,-.107,.280,-.553,-.105,-.046)*f6_1+
    mat4(-.269,.072,.292,.395,-.129,-.404,-.322,-.113,.357,.042,-.018,-.121,-.018,.089,.110,-.512)*f6_2+
    mat4(-.072,-.219,.482,.119,.112,.325,-.189,.445,.215,.238,.267,.030,.017,-.368,.313,.018)*f6_3+
    mat4(.071,-.236,-.065,-.499,.339,-.086,-.480,-.406,.228,-.059,-.166,.072,-.228,.033,-.224,-.354)*f6_4+
    mat4(-.536,.203,.504,.036,.387,.377,-.046,.286,.296,-.062,.487,.062,-.225,.265,.417,-.242)*f6_5+
    mat4(.040,.409,-.240,.130,.126,.045,.092,.125,.247,-.287,.047,-.274,-.018,.380,-.371,-.254)*f6_6+
    mat4(.764,.120,-.211,.102,-.003,-.174,-.299,-.007,.145,.209,.260,-.382,.111,.688,-.487,-.955)*f6_7+
    vec4(-.317,-.500,-.796,.091))/2.6+f6_7;
vec4 f8_0=sin(mat4(-.971,.247,-.030,.008,-.802,.939,.352,.607,-.154,-.309,.866,-.196,.637,.322,-.105,.785)*f7_0+
    mat4(-.073,.292,-.075,.104,.021,-.251,-.217,-.170,-.534,-.123,-.004,-.201,-.159,.501,.140,.248)*f7_1+
    mat4(.154,.057,.536,-.084,-.050,-.027,-.363,-.305,.065,-.126,.273,-.150,-.031,-.029,-.190,-.346)*f7_2+
    mat4(.054,-.084,-.252,-.129,-.391,-.147,.316,-.024,.383,-.277,.028,-.016,-.072,.115,.523,-.259)*f7_3+
    mat4(.114,.285,.297,.142,-.245,-.071,-.720,.036,-.311,.236,.066,-.205,-.009,.083,.035,-.149)*f7_4+
    mat4(-.100,-.313,-.310,.210,-.428,.089,.308,.199,.352,.534,-.091,.273,.195,.083,-.203,.051)*f7_5+
    mat4(.110,.198,-.312,-.174,-.596,.051,-.277,-.473,.492,-.332,.058,-.281,-.085,.082,.156,-.469)*f7_6+
    mat4(.062,.357,-.673,-.485,.025,.038,.015,-.725,.142,-.069,-.126,.357,.384,.087,.020,.031)*f7_7+
    vec4(.865,-.242,-.130,-.980))/2.8+f7_0;
vec4 f8_1=sin(mat4(-.014,.310,-.251,-.474,.186,.112,-.204,.064,-.215,-.123,.172,-.190,.355,-.113,.096,.602)*f7_0+
    mat4(.616,.605,-.096,-.453,-.013,.379,-.288,.149,.187,.355,-.431,-.105,.211,-.171,-.146,-.832)*f7_1+
    mat4(.170,-.017,.039,-.001,.220,.026,-.080,-.168,-.385,-.184,-.170,.100,.119,-.287,.444,-.183)*f7_2+
    mat4(.198,.109,-.029,.529,-.116,.128,-.190,.067,-.060,.226,.152,-.039,.123,-.325,-.329,-.094)*f7_3+
    mat4(.329,-.136,-.380,-.378,.317,.084,-.086,-.093,.366,.310,.026,-.648,.389,-.074,.175,-.288)*f7_4+
    mat4(-.575,-.016,.550,-.176,-.424,.594,.470,-.340,-.114,.489,-.361,-.096,.319,-.220,.035,-.342)*f7_5+
    mat4(-.047,.403,.243,-.206,-.672,.133,-.495,-.444,.373,-.396,-.115,.684,.216,-.142,.143,-.653)*f7_6+
    mat4(-.079,.728,-.219,.084,.273,.171,.080,-.078,.061,-.086,-.267,-.065,-.196,-.354,-.022,-.118)*f7_7+
    vec4(.224,-.068,-.159,.330))/2.8+f7_1;
vec4 f8_2=sin(mat4(.277,.067,.117,-.159,.146,-.129,-.387,-.359,-.058,-.252,-.114,-.128,-.320,.057,.374,-.128)*f7_0+
    mat4(.093,.534,.466,-.084,.276,-.080,.027,.197,-.155,-.124,.260,-.322,.451,.726,.052,-.220)*f7_1+
    mat4(-.022,-.410,.013,.004,-.030,.582,-.024,-.567,.009,-.618,.644,-.435,.090,.170,-.314,-.188)*f7_2+
    mat4(-.091,.239,.603,.296,-.286,-.152,.145,-.255,-.317,.505,.156,.576,-.208,-.439,-.131,.197)*f7_3+
    mat4(.467,-.011,.000,-.624,.131,.367,.083,-.478,.080,-.791,.561,-.054,.119,.089,-.275,-.411)*f7_4+
    mat4(-.431,.072,-.288,.016,-.058,-.194,.038,.166,.496,-.160,-.230,.199,.269,-.422,.035,-.153)*f7_5+
    mat4(.064,.017,.153,.112,-.443,-.093,.226,-.160,-.309,.546,.519,.222,-.156,.200,.299,.395)*f7_6+
    mat4(.485,-.307,.935,.143,.031,.011,.129,.699,.070,.197,.077,.010,-.451,.146,.098,-.130)*f7_7+
    vec4(.071,-.163,.120,.095))/2.8+f7_2;
vec4 f8_3=sin(mat4(-.260,.072,.248,.031,.194,-.335,.001,-.135,.438,-.341,.324,.134,-.079,.592,.014,.142)*f7_0+
    mat4(-.047,.328,-.087,.127,.101,.239,.070,-.073,.113,-.435,.086,-.370,-.197,-.377,.294,.840)*f7_1+
    mat4(.245,-.083,.393,.056,-.222,-.359,-.308,-.025,-.363,.023,-.727,-.034,-.302,-.191,-.019,-.212)*f7_2+
    mat4(.820,.553,.185,-.083,.260,-.028,-.249,-.254,.014,.151,.024,.503,.004,-.187,.167,.935)*f7_3+
    mat4(-.009,-.268,.206,-.389,-.174,-.093,-.004,-.360,-.380,.063,-.324,-.210,.145,.376,.253,-.421)*f7_4+
    mat4(-.246,.064,.240,-.221,.622,.050,.276,.007,.162,.202,-.414,-.122,.329,.158,.097,-.380)*f7_5+
    mat4(.096,.473,-.473,.076,-.005,.071,.543,-.043,.099,-.270,.154,-.246,-.234,-.077,-.079,.061)*f7_6+
    mat4(.228,.055,-.074,.292,-.306,-.554,.289,.081,.137,-.360,.091,-.343,-.123,.273,-.326,-.474)*f7_7+
    vec4(-.752,-.414,.076,-.173))/2.8+f7_3;
vec4 f8_4=sin(mat4(.069,.008,-.382,-.506,.110,.103,.075,-.201,.182,.352,-.306,-.389,.459,-.173,.727,.131)*f7_0+
    mat4(-.036,.127,.079,-.333,-.132,.279,.156,-.185,-.013,.090,-.392,-.225,.163,.299,-.084,.277)*f7_1+
    mat4(.411,-.233,-.429,-.102,-.278,.574,-.213,-.046,-.353,.594,-.350,-.173,-.070,.265,-.578,-.035)*f7_2+
    mat4(.339,-.331,.054,.369,-.305,.037,.006,-.305,.035,-.065,.592,.373,-.189,-.146,.312,.443)*f7_3+
    mat4(-.745,.388,.053,.093,-.596,-.563,-.100,.085,.019,.463,-.500,-.259,-.079,-.106,-.156,.039)*f7_4+
    mat4(-.397,.165,-.102,.314,-.179,.309,-.060,-.473,.084,.135,.196,-.178,.051,.393,.239,-.152)*f7_5+
    mat4(-.329,-.457,-.120,-.227,.103,-.616,-.126,.148,.383,-.796,.255,.312,.107,.257,.076,-.485)*f7_6+
    mat4(-.659,-.120,-.342,-.065,.313,-.102,-.565,-.377,.354,-.049,.093,.079,.110,-.161,-.083,-.043)*f7_7+
    vec4(.347,-1.215,.526,.307))/2.8+f7_4;
vec4 f8_5=sin(mat4(-.029,.209,-.265,-.227,.217,.087,-.576,-.445,.079,.064,-.061,-.102,-.256,.193,-.137,-.116)*f7_0+
    mat4(-.177,.069,-.195,.226,-.513,.405,-.036,-.362,.333,.217,-.654,-.194,.076,-.378,.132,.136)*f7_1+
    mat4(-.204,-.036,-.175,.195,.022,.032,-.030,.032,.132,-.122,.312,.548,.048,.449,.417,.354)*f7_2+
    mat4(.140,.024,-.150,.364,.040,.106,.471,-.537,-.013,.095,.568,-.028,.482,-.226,-.214,.042)*f7_3+
    mat4(-.771,.048,-.018,-.004,.224,.146,.234,-.053,-.664,.264,.193,-.243,-.342,-.073,-.231,.195)*f7_4+
    mat4(.260,-.081,.088,.086,.070,1.017,-.180,-.486,.402,.430,.109,.016,-.473,-.201,-.266,-.299)*f7_5+
    mat4(-.065,.064,-.296,-.275,.111,.398,.741,-.381,.145,.071,-.090,-.187,-.090,-.351,.132,-.565)*f7_6+
    mat4(.589,.500,-.082,-.113,-.268,.420,.264,.115,.147,.285,-.061,-.151,.325,-.349,.353,.138)*f7_7+
    vec4(-.584,.190,-.135,-.057))/2.8+f7_5;
vec4 f8_6=sin(mat4(-.219,-.648,-.254,.226,.087,-.649,-.450,.376,-.452,.381,-.136,-.287,.207,.166,.237,.480)*f7_0+
    mat4(.009,-.361,.376,.027,-.037,-.181,-.054,.287,-.065,.338,.022,-.176,-.272,-.034,-.111,-.632)*f7_1+
    mat4(.316,.187,-.170,.455,-.497,-.417,.420,-.084,-.544,-.238,.163,-.654,.864,-.122,.097,-.593)*f7_2+
    mat4(-.184,-.253,-.081,-.295,-.035,.130,-.150,.082,.126,.345,.209,.094,.337,-.079,-.369,-1.016)*f7_3+
    mat4(.232,-.220,.112,-.344,-.180,-.035,.805,.265,-.227,-.322,-.117,-.063,-.147,-.560,.197,-.223)*f7_4+
    mat4(-.139,.487,.307,.521,-.457,.329,-.342,-.280,.066,-.390,-.005,-.060,-.489,.016,-.246,.220)*f7_5+
    mat4(-.385,-.237,.133,-.260,.079,.497,.248,-.344,.767,.076,.642,.060,-.098,-.395,-.160,.002)*f7_6+
    mat4(.007,.120,-.068,-.414,.263,-.014,.199,.033,-.040,.080,-.265,-.123,.253,.238,.166,-.057)*f7_7+
    vec4(.483,-.021,.084,1.050))/2.8+f7_6;
vec4 f8_7=sin(mat4(.274,-.297,-.029,.232,.268,-.319,.103,-.035,.097,-.064,.644,-.566,.094,.166,-.113,-.048)*f7_0+
    mat4(.211,.302,-.053,.644,-.427,.131,-.100,.248,.212,-.277,.135,-.118,.669,-.794,-.379,-.429)*f7_1+
    mat4(-.208,.247,-.144,.683,.198,-.382,-.155,.441,-.004,-.625,.354,-.038,-.435,.121,-.163,-.481)*f7_2+
    mat4(.452,.142,-.261,-.371,-.272,-.070,-.234,.554,.390,-.252,-.194,-.438,.133,-.061,.081,-.099)*f7_3+
    mat4(-.468,.492,-.019,-.210,.320,.359,-.405,-.042,-.113,-.114,.030,.510,-.666,.313,.403,.491)*f7_4+
    mat4(.007,-.125,-.554,-.146,.162,.504,-.366,-.197,.127,-.180,.188,-.251,-.480,-.431,-.070,.489)*f7_5+
    mat4(.394,.157,-.297,-.073,.172,.671,.077,-.309,-.400,.374,-.339,.180,.379,-.388,-.280,-.388)*f7_6+
    mat4(.209,.152,-.044,-.109,.005,.189,.014,-.443,.077,-.178,-.399,-.180,.073,.065,.100,-.342)*f7_7+
    vec4(-.344,-.351,.144,.460))/2.8+f7_7;
vec4 f9_0=sin(mat4(.121,.641,-.562,.145,.391,.978,-.121,.793,.266,-.298,-.394,-.397,.106,-.078,-.133,.789)*f8_0+
    mat4(-.410,.101,-.228,-.409,.345,-.096,-.562,.498,.023,-.063,.336,-.483,.257,-.011,-.280,.000)*f8_1+
    mat4(.126,.329,.144,-.240,-.230,-.023,-.087,-.112,-.408,-.122,-.246,-.401,-.297,-.214,-.103,-.169)*f8_2+
    mat4(-.084,-.041,-.400,-.615,-.443,.804,-.325,-.173,.194,-.236,.128,-.059,.233,.116,.132,.094)*f8_3+
    mat4(.124,-.024,.254,.446,-.197,.176,-.554,.281,.177,-.101,.184,.034,-.545,.399,.080,-.136)*f8_4+
    mat4(-.046,-.549,-.013,-.257,.469,-.136,-.519,-.478,.436,.124,-.099,-.194,-.181,.174,.600,.110)*f8_5+
    mat4(.100,-.437,.015,-.207,-.183,-.490,-.093,-.152,.026,.146,.159,-.181,.292,-.342,-.225,-.048)*f8_6+
    mat4(-.315,.047,.261,-.232,.162,.308,-.405,-.146,-.020,.202,.272,.484,-.506,-.404,.580,.137)*f8_7+
    vec4(.243,-1.217,.136,-.438))/3.0+f8_0;
vec4 f9_1=sin(mat4(-.203,.054,-.005,.057,.401,-.472,.452,-.154,-.615,-.593,.155,-.006,-.016,.156,.381,-.123)*f8_0+
    mat4(.507,.032,.511,-.055,-.199,.035,.462,-.102,.303,-.488,.064,.321,-.008,.122,.441,.364)*f8_1+
    mat4(-.135,-.344,.700,.398,.274,-.387,.285,.338,-.210,.748,-.374,.042,.228,.401,.103,.060)*f8_2+
    mat4(.543,.092,.513,.420,-.396,.066,.248,.432,-.110,-.294,-.474,.263,-.344,.161,.063,1.032)*f8_3+
    mat4(.595,.513,.462,-.207,.354,-.082,.040,.239,-.355,-.047,.558,-.113,.532,.357,.198,-.284)*f8_4+
    mat4(-.152,.120,-.204,-.055,.532,.729,.517,-.311,-.344,.046,.077,.260,.184,-.052,-.277,.200)*f8_5+
    mat4(-.341,.243,-.112,-.033,-.397,.676,-.309,.242,.137,.321,-.445,.100,-.557,-.332,-.089,-.439)*f8_6+
    mat4(-.458,.559,-.198,.036,-.072,-.694,.118,.157,.125,.217,-.547,-.471,.510,.050,-.571,-.280)*f8_7+
    vec4(.324,.489,-.847,-.939))/3.0+f8_1;
vec4 f9_2=sin(mat4(-.036,-.017,.228,.141,.233,-.399,-.283,-.330,-.165,.013,-.088,.413,-.074,-.547,.044,-.110)*f8_0+
    mat4(.199,-.242,-.189,.079,.223,-.285,.359,.378,-.243,-.073,.167,-.074,-.070,.200,-.504,-.132)*f8_1+
    mat4(-.355,-.512,-.264,.453,.297,.211,.332,-.142,-.284,-.168,-.639,.212,.289,-.023,-.237,-.605)*f8_2+
    mat4(.154,.335,-.074,.203,.293,.261,-.043,-.153,.029,.094,-.261,-.270,.193,.114,.006,-.455)*f8_3+
    mat4(.184,-.007,.411,-.076,.346,.031,.304,.004,.439,-.145,.245,.320,.180,.323,.010,-.666)*f8_4+
    mat4(-.127,-.005,-.222,.611,.099,-.690,-.185,.670,.112,-.496,.360,.132,-.224,.206,.383,-.158)*f8_5+
    mat4(-.223,.236,.063,-.129,.182,.378,.201,.590,.237,.027,-.197,-.521,-.236,-.144,.065,-.563)*f8_6+
    mat4(-.039,-.691,.139,-.168,.312,-.030,.354,.204,-.203,.175,-.336,.210,.122,.028,-.281,-.827)*f8_7+
    vec4(.625,.334,.122,-1.340))/3.0+f8_2;
vec4 f9_3=sin(mat4(.411,-.111,-.351,.029,.067,.005,-.028,.072,.664,.375,-.100,.261,-.328,.231,.099,-.236)*f8_0+
    mat4(-.363,-.050,-.027,.035,.264,.866,-.003,-.373,.003,.219,.709,.733,.108,-.290,.170,.686)*f8_1+
    mat4(.111,.245,.136,-.060,-.171,-.100,-.513,.012,-.193,-.269,-.275,-.258,.733,.045,-.329,-.027)*f8_2+
    mat4(-.323,-.304,.167,-.088,.265,-.071,-.340,.550,-.122,-.128,.177,-.042,.529,.592,-.421,.494)*f8_3+
    mat4(-.020,.376,.250,.262,-.722,-.215,.044,-.216,.405,.012,.070,.376,.196,-.395,-.310,.093)*f8_4+
    mat4(-.231,-.073,.708,-.494,.129,.057,-.490,.605,.532,-.142,.901,-.071,-.280,.598,.011,-.463)*f8_5+
    mat4(.469,.223,-.180,.321,.293,-.305,.440,.011,-.877,-.531,-.283,.085,.190,.723,.162,.205)*f8_6+
    mat4(-.048,.080,-.012,.250,.272,-.092,-.447,.084,-.076,.016,-.018,.017,-.069,.275,.170,-.682)*f8_7+
    vec4(-.897,-.324,1.221,.178))/3.0+f8_3;
vec4 f9_4=sin(mat4(-.138,.180,.339,-.013,.217,-.417,.003,.020,.038,-.484,.368,.494,.249,.218,.144,-.809)*f8_0+
    mat4(.280,.603,-.174,.276,.174,-.427,-.532,-.127,-.425,.066,-.091,.129,.217,.082,-.206,.048)*f8_1+
    mat4(.028,-.005,.080,-.303,-.407,.268,-.161,.310,-.678,-.036,.239,-.091,-.145,-.010,.034,.780)*f8_2+
    mat4(.240,-.611,-.196,.284,-.154,-.119,.169,-.133,.070,-.262,.075,.083,.103,-.378,-.033,.236)*f8_3+
    mat4(-.266,.885,-.111,-.007,.237,.832,-.165,.349,-.628,-.057,.356,-.590,.094,.188,-.159,-.242)*f8_4+
    mat4(.079,.081,.302,-.119,-.165,.051,.098,.498,-.530,-.496,.062,.319,.144,-.045,-.042,.193)*f8_5+
    mat4(.060,-.780,.238,.354,-.304,-.266,.723,.357,-.008,.210,.118,.190,.291,-.467,-.065,.701)*f8_6+
    mat4(-.145,-.210,-.146,.383,-.382,-.311,-.078,-.127,.463,.148,.066,.286,-.015,.188,-.313,.258)*f8_7+
    vec4(1.560,.981,-.778,-1.180))/3.0+f8_4;
vec4 f9_5=sin(mat4(-.256,-.570,.432,-.537,-.012,-.421,.651,-.271,.010,-.188,.258,-.167,-.612,.371,.367,.063)*f8_0+
    mat4(-.298,-.029,.558,.545,-.340,-.346,.147,-.243,.260,-.139,.151,.101,-.400,-.114,-.433,-.035)*f8_1+
    mat4(.069,-.488,.668,.596,.165,.146,-.221,.002,-.065,-.526,-.416,.304,.142,-.026,.488,.621)*f8_2+
    mat4(.093,-.032,.128,-.049,.360,-.376,.422,.035,-.189,.096,-.544,-.037,-.146,.164,.106,-.032)*f8_3+
    mat4(.103,.175,-.010,.271,-.210,.038,-.238,-.291,.001,.151,.289,-.132,.167,.120,.532,.473)*f8_4+
    mat4(.378,-.523,-.555,-.292,-.073,-1.125,-.330,.487,-.432,-.592,.382,.244,-.124,-.068,-.123,-.196)*f8_5+
    mat4(.145,-.366,-.078,-.176,.469,-.559,-.384,.203,.045,.562,.318,.067,.153,-.017,-.374,-.159)*f8_6+
    mat4(-.364,-.347,.048,.044,.481,-.241,-.224,-.025,-.288,.050,.485,-.163,-.359,.312,-.275,.225)*f8_7+
    vec4(.695,.954,-.440,-.240))/3.0+f8_5;
vec4 f9_6=sin(mat4(-.177,.140,.290,.369,-.074,-.516,-.091,-.435,.332,-.421,-.514,-.363,-.259,-.311,-.033,.358)*f8_0+
    mat4(-.108,-.547,.521,-.121,.193,.022,.022,.366,.536,.256,.181,-.300,.154,.445,-.119,-.097)*f8_1+
    mat4(-.142,-.662,.181,-.159,-.265,.433,.375,.294,-.029,.026,.283,-.173,.340,-.379,-.230,-.173)*f8_2+
    mat4(.044,-.097,.012,-.234,-.164,.470,-.408,.200,.254,.480,-.354,-.369,.331,-.530,-.766,.430)*f8_3+
    mat4(.214,-.272,-.138,-.045,-.328,.258,.332,.046,-.022,.055,-.218,-.086,-.465,-.006,.205,.532)*f8_4+
    mat4(-.277,.130,.121,.020,.468,.135,-.255,-1.071,.257,.055,-.151,-.090,-.406,-.366,.541,.282)*f8_5+
    mat4(.717,.786,.414,.245,-.068,.999,-.303,-.405,-.282,.283,-.060,.333,.460,.003,-.210,-.538)*f8_6+
    mat4(-.002,.091,.074,-.615,.958,.058,-.699,-.314,-.492,-.119,.384,-.017,.236,-.153,.338,.016)*f8_7+
    vec4(-.559,.481,1.126,.476))/3.0+f8_6;
vec4 f9_7=sin(mat4(.737,-.504,.517,-.338,.256,-.101,-.522,-.190,-.356,-.148,-.134,-.907,.143,.053,.080,-.068)*f8_0+
    mat4(.184,.024,-.353,.460,-.079,-.115,.421,.181,-.148,-.462,-.202,.101,-.064,.015,-.345,.115)*f8_1+
    mat4(.193,.184,.068,-.667,-.105,-.932,.024,-.170,.024,-.212,.201,.245,.430,.247,-.234,.112)*f8_2+
    mat4(-.017,.355,-.561,-.074,.541,-.076,.064,-.208,.183,.002,.091,-.524,.196,.360,-.569,-.159)*f8_3+
    mat4(.245,-.193,-.195,.234,.230,-.359,.309,-.124,.342,-.447,.418,.064,.129,-.075,.008,.386)*f8_4+
    mat4(.362,.196,-.201,-.255,.751,.477,-.254,-.744,-.038,-.410,.154,-.007,-.530,-.359,.082,.377)*f8_5+
    mat4(-.258,-.174,.026,-.235,.504,-.051,-.027,-.218,.034,-.136,-.023,.019,.088,-.404,.182,-.079)*f8_6+
    mat4(.585,-.519,.340,-.392,-.125,-.109,.479,-.546,-.360,-.125,-.305,.043,-.077,-.066,-.255,.888)*f8_7+
    vec4(.457,.650,.302,.156))/3.0+f8_7;
vec4 f10_0=sin(mat4(.572,-.444,-.711,.279,.784,-.580,-.773,.096,-.018,-.174,-.049,.123,-.040,.092,-.248,.261)*f9_0+
    mat4(-.259,-.576,-.387,-.045,.322,.071,-.213,.496,-.275,.159,.093,-.098,-.394,-.144,.227,-.495)*f9_1+
    mat4(-.252,-.252,-.181,.141,.093,-.044,-.047,-.286,-.089,.330,.056,-.287,.264,-.715,.280,.835)*f9_2+
    mat4(-.154,-.272,-.055,-.207,.292,-.088,.866,.027,.420,.096,-.016,-.649,.011,-.543,.146,-.107)*f9_3+
    mat4(.281,.341,.246,.433,.090,.149,-.241,-.274,.082,-.099,.027,-.352,-.330,-.438,-.128,-.040)*f9_4+
    mat4(-.000,.200,.053,.040,.271,.045,-.276,-.003,.407,-.070,-.344,.032,-.200,-.349,.242,.803)*f9_5+
    mat4(.267,.508,.085,.078,.096,.324,.771,-.308,-.012,.347,-.098,-.151,-.139,-.092,-.295,-.208)*f9_6+
    mat4(.510,.564,-.314,-.237,.189,-.085,.347,-.271,-.225,-.020,-.442,.359,-.349,.144,.329,-.406)*f9_7+
    vec4(-.247,.475,1.481,.317))/3.2+f9_0;
vec4 f10_1=sin(mat4(.161,-.655,-.873,-.256,.400,-.416,-.506,.161,.114,.546,-.127,.399,-.260,-.393,-.176,.069)*f9_0+
    mat4(.406,-.347,-.042,.227,.024,-.458,-.374,-.302,-.064,-.052,.049,.051,-.204,-.395,-.309,.721)*f9_1+
    mat4(-.119,-.222,-.126,-.162,.760,-.205,-.414,.308,-.304,-.152,-.203,.262,.158,.266,.128,.001)*f9_2+
    mat4(-.321,-.362,-.394,.490,-.007,.252,-.085,-.093,-.201,-.199,.004,.205,.045,-.054,.144,.526)*f9_3+
    mat4(.445,-.205,-.204,.624,.161,.265,.307,.441,-.131,-.893,-.278,-.276,-.130,-.002,-.405,-.289)*f9_4+
    mat4(-.410,.234,-.123,.378,.156,-.096,-.255,-.178,.444,-.734,-.138,-.320,.248,.089,-.487,-.815)*f9_5+
    mat4(-.107,.085,-.619,-.386,-.594,.015,-.177,-.213,.622,.055,-.111,.551,.014,-.268,.391,-.035)*f9_6+
    mat4(.086,-.895,-.393,.213,.019,.604,.066,-.477,.569,-.426,-.217,-.331,.160,.017,-.186,.144)*f9_7+
    vec4(.776,.143,-.029,-.144))/3.2+f9_1;
vec4 f10_2=sin(mat4(.118,-.220,.239,.121,.241,-.283,.087,-.287,.266,.045,.050,-.362,.122,-.118,.402,.129)*f9_0+
    mat4(-.242,-.123,.190,.398,.339,.178,-.198,.197,-.812,-.228,.367,.176,.232,-.321,.007,-.606)*f9_1+
    mat4(-.030,.305,-.414,.060,-.429,-.972,.254,.329,-.145,-.130,.106,-.549,-.019,.256,-.565,-.417)*f9_2+
    mat4(-.251,.449,-.019,.326,.240,-.107,.240,-.408,.264,.016,-.223,-.205,.309,-.260,.206,-.537)*f9_3+
    mat4(-.128,-.226,.364,-.121,-.117,-.648,.026,.215,-.201,-.508,.513,-.643,.339,-.116,-.453,.364)*f9_4+
    mat4(.104,.119,-.145,.571,.059,.094,-.101,-.384,-.024,.061,-.430,-.596,-.394,.075,.207,-.290)*f9_5+
    mat4(-.693,.280,-.299,.065,-.481,.585,-.039,-.489,-.261,.127,-.300,.830,-.114,.013,-.074,-.514)*f9_6+
    mat4(-.200,-.069,.097,.087,.309,.188,.469,-.122,-.036,-.197,.488,-.266,-.261,-.069,-.072,-.006)*f9_7+
    vec4(.096,-.152,-.221,1.640))/3.2+f9_2;
vec4 f10_3=sin(mat4(-.454,.574,.119,-.516,-.662,.806,.029,-.296,.218,-.037,.067,.209,.598,.029,.352,-.030)*f9_0+
    mat4(.030,-.313,.161,.583,-.450,.062,-.096,.008,.088,.397,.215,.215,.740,-.382,-.378,.100)*f9_1+
    mat4(-.433,.296,-.536,-.360,.294,.145,-.233,-.256,-.486,.059,.065,.171,-.377,-.172,-.145,-.577)*f9_2+
    mat4(.040,-.073,-.144,-.049,-.309,.459,.047,.003,.483,-.266,-.626,.053,.017,-.140,-.509,.010)*f9_3+
    mat4(-.080,-.454,-.322,-.354,.353,-.062,.223,-.205,-.017,.410,.253,-.084,.007,.387,.091,.223)*f9_4+
    mat4(-.241,.255,-.240,-.250,-.599,.478,-.645,.021,.005,.168,.353,-.676,-.112,-.226,.596,-.009)*f9_5+
    mat4(.158,-.069,-.214,.113,-.085,-.354,-.463,-.016,.906,-.191,-.417,.240,-.270,.079,-.182,-.269)*f9_6+
    mat4(.402,.049,-.073,-.050,-.044,-.136,.005,-.645,-.284,.366,.649,.105,.264,-.387,.481,.401)*f9_7+
    vec4(.438,-.546,.335,.400))/3.2+f9_3;
vec4 f10_4=sin(mat4(.124,.114,.262,.010,.656,.256,-.240,.276,.323,.977,-.127,-.080,.037,.142,.146,.238)*f9_0+
    mat4(.407,-.557,-.116,.195,.012,-.010,-.031,-.444,.022,-.202,-.020,.191,-.031,.347,.305,.465)*f9_1+
    mat4(.455,-.059,-.182,-.100,-.389,.658,.055,-.070,-.530,-.079,.165,.359,.192,.052,-.127,.130)*f9_2+
    mat4(.478,-.525,.214,-.278,-.430,.402,.102,.106,-.014,.331,.315,-.410,-.073,.134,-.271,-.116)*f9_3+
    mat4(.014,.409,-.445,.340,-.627,-.639,-.138,-.314,-.083,.233,1.175,-.053,.403,-.007,.013,.191)*f9_4+
    mat4(.256,-.063,.278,.098,.629,-.483,.230,-.396,-.292,.451,.324,-.528,-.326,-.091,-.226,.832)*f9_5+
    mat4(-.179,.222,.500,.176,-.426,.221,.479,-.322,.022,-.192,-.443,.215,-.252,.493,.391,.253)*f9_6+
    mat4(-.436,-.735,.439,-.288,.122,.150,-.131,-.492,.374,-.328,-.579,-.124,-.535,-.022,-.356,.567)*f9_7+
    vec4(-.215,-1.286,.339,1.201))/3.2+f9_4;
vec4 f10_5=sin(mat4(-.058,.010,.391,.115,-.094,.117,-.198,.394,.184,.155,-.380,-.206,.469,.527,-.367,.011)*f9_0+
    mat4(-.397,.245,.268,-.041,-.510,.318,.515,-.028,.364,-.472,.052,-.061,.017,-.129,-.024,.136)*f9_1+
    mat4(.212,.553,.144,.175,.203,-.259,.032,.557,.603,-.593,-.135,.077,-.076,-.160,-.012,.227)*f9_2+
    mat4(-.409,.493,.081,-.515,.202,-.123,.339,.069,-.267,-.052,-.512,-.114,-.407,.164,-.549,.203)*f9_3+
    mat4(.181,.432,.600,.269,.130,-.540,-.516,.303,.615,-.315,-.203,-.128,-.461,.501,-.024,.169)*f9_4+
    mat4(.206,-.190,.091,-.357,.097,-.308,.540,-.356,.451,.225,.465,-.122,-.131,.076,.413,.248)*f9_5+
    mat4(-.070,-.335,.156,-.228,-.003,-.742,.318,-.204,-.408,.040,.144,.322,-.334,-.349,.213,.200)*f9_6+
    mat4(.321,.178,.483,-.201,-.290,.185,.132,.731,.553,.168,.677,-.304,-.111,-.023,-.015,.680)*f9_7+
    vec4(.704,-.432,-.047,.077))/3.2+f9_5;
vec4 f10_6=sin(mat4(.390,.225,-.193,.160,.715,-.504,-.215,.126,.019,-.619,.500,.546,.292,-.201,-1.309,.031)*f9_0+
    mat4(.346,-.017,-.263,-.493,.496,-.148,.219,.307,-.469,-.195,.452,.162,-.642,-.409,-.044,.591)*f9_1+
    mat4(-.303,-.451,-.257,-.189,-.280,.266,.163,.687,-.143,.441,-.045,.319,-.231,-.201,-.649,.102)*f9_2+
    mat4(-.084,-.300,.370,-.250,-.245,-.021,.043,-.104,-.018,-.320,.340,.090,.304,-.076,-.216,.350)*f9_3+
    mat4(.338,.131,-.377,.322,-.406,-.130,.273,-.554,.351,.811,-.144,.420,.037,.150,-.161,.337)*f9_4+
    mat4(-.471,-.106,-.041,-.565,-.530,.238,-.083,-.675,.528,.370,-.557,.129,.126,-.394,-.478,.337)*f9_5+
    mat4(-.559,-.314,.119,.219,-.744,-.053,-.230,-.404,.139,-.287,-.054,.036,.022,-.354,.250,.240)*f9_6+
    mat4(-.159,.714,-.309,-.696,.078,-.300,.497,-.021,-.035,.037,-.092,-.202,-.024,.026,-.290,.055)*f9_7+
    vec4(.623,.197,-1.213,.235))/3.2+f9_6;
vec4 f10_7=sin(mat4(.002,-.434,-.064,-.587,.220,-.494,-.516,.038,.094,.285,-.159,.407,.281,-.524,-.404,-.118)*f9_0+
    mat4(-.094,-.247,-.285,.099,-.467,-.640,.104,-.172,-.101,-.150,-.231,.219,-.249,.145,-.740,-.069)*f9_1+
    mat4(.148,.157,-.295,-.577,-.039,-.119,-.288,-.152,-.305,.040,.563,.159,.103,-.617,.079,-.276)*f9_2+
    mat4(-.144,.405,-.376,-.108,-.102,-.150,.181,.077,-.163,-.205,-.127,.052,.218,-.347,-.178,.125)*f9_3+
    mat4(.567,-.344,-.089,-.051,1.023,-.183,-.037,-.371,.296,-.327,.362,-.797,-.705,.457,-.206,.315)*f9_4+
    mat4(.317,.158,.308,-.411,-.397,.490,.072,-.358,-.171,-.240,.459,.003,-.615,-.190,-.341,-.271)*f9_5+
    mat4(.206,.148,.309,-.434,.356,-.007,.746,-.753,-.383,.166,.215,.170,-.057,-.355,-.378,-.149)*f9_6+
    mat4(.967,-.145,.296,-.036,-.258,.309,-.421,.285,-.234,.000,.253,.153,-.362,-.037,-.126,.899)*f9_7+
    vec4(-.369,-.574,.483,-.112))/3.2+f9_7;
vec4 f11_0=sin(mat4(-.423,.378,.245,-.146,.226,-.022,.084,-.453,-.011,-.111,.972,-.084,-.014,-.292,.250,-.179)*f10_0+
    mat4(-.135,-.081,-.069,.510,-.120,-.172,.192,-.013,-.067,.544,-.067,.073,.024,.368,-.275,-.165)*f10_1+
    mat4(.653,.429,-.054,-.468,-.081,.670,.106,-.081,-.159,.103,-.027,.082,.273,.064,.037,.154)*f10_2+
    mat4(.395,-.475,.045,.004,.078,-.270,.200,-.150,.282,-.095,-.069,.003,-.324,-.163,-.196,.839)*f10_3+
    mat4(-.123,.161,.329,-.511,-.151,.211,-.308,.245,-.176,.286,.127,.490,-.029,-.144,.316,.108)*f10_4+
    mat4(-.425,.403,-.218,-.135,-.064,-.174,.299,-.160,-.071,-.242,.307,.569,-.594,.303,.319,.287)*f10_5+
    mat4(-.093,-.135,.264,-.550,.304,.136,-.090,-.120,.222,-.234,-.104,-.033,.027,.291,.306,-.446)*f10_6+
    mat4(-.440,.088,-.455,.080,-.343,-.116,.418,.148,-.158,-.813,-.133,.466,.004,.290,-.267,.397)*f10_7+
    vec4(-.291,-.303,-.122,-.075))/3.3+f10_0;
vec4 f11_1=sin(mat4(-.213,.068,-.272,.051,.526,.526,-1.082,.016,-.632,-.574,.027,-.139,.520,.231,-.150,-.112)*f10_0+
    mat4(.697,.561,.002,-.305,-.210,.237,-.394,.112,.078,.479,-.027,.678,.125,-.246,-.505,.296)*f10_1+
    mat4(-.042,.300,-.842,-.118,.090,-.240,-.008,.197,-.554,.017,-.033,.087,.429,-.249,-.119,-.152)*f10_2+
    mat4(.297,-.062,-.501,-.388,-.614,.126,.308,.228,-.543,-.200,-.032,.347,.282,.009,.111,-.269)*f10_3+
    mat4(.168,-.037,.660,.458,.387,-.182,-.506,-.329,-.386,.208,-.078,.345,.468,-.241,-.078,-.162)*f10_4+
    mat4(.227,.246,-.939,-.122,-.479,.134,-.394,.006,.214,.393,.008,.642,-.226,-.164,-.025,.783)*f10_5+
    mat4(.101,.134,.176,-.286,-.224,-.169,-.223,.011,.315,-.050,-.020,-.419,-.320,.281,.417,.885)*f10_6+
    mat4(-.114,.685,-.126,.454,.359,-.275,.535,-.338,.487,.088,.396,.305,.535,-.404,.619,.554)*f10_7+
    vec4(.390,-.908,1.836,1.420))/3.3+f10_1;
vec4 f11_2=sin(mat4(-.080,.607,-.011,-.105,-.054,.125,.572,-.354,.288,.037,-.591,-.623,-.162,.448,.216,.065)*f10_0+
    mat4(-.148,.176,.081,-.297,-.060,-.012,-.241,-.554,-.556,-.401,.215,.141,.198,-.230,-.300,.403)*f10_1+
    mat4(.134,-.735,.076,-.106,-.226,.432,.380,-.059,.135,.013,.529,.618,-.188,.753,.155,.409)*f10_2+
    mat4(.480,.076,.061,-.504,-.072,-.337,-.174,.263,.508,.174,-.627,-.280,-.028,.272,-.444,-.012)*f10_3+
    mat4(-.017,-.054,.356,-.221,-.570,.310,-.244,.138,.172,-.018,.246,.192,.480,.033,-.130,-.183)*f10_4+
    mat4(.095,.066,.165,.256,.503,.160,.040,-.555,.391,.834,.302,-.361,-.272,-.108,.329,.176)*f10_5+
    mat4(.352,.458,.151,.143,-.221,-.221,-.206,.690,.124,-.406,.156,.234,-.019,.282,-.111,-.167)*f10_6+
    mat4(.440,.785,.251,.205,-.321,.110,.263,-.585,-.669,-.155,.093,-.206,.132,.195,.029,.010)*f10_7+
    vec4(-.939,-2.065,-.395,-.219))/3.3+f10_2;
vec4 f11_3=sin(mat4(.297,.570,.315,.422,-.323,.729,.242,.806,-.153,-.333,-.102,.212,.161,.478,-.153,-.715)*f10_0+
    mat4(-.270,-.245,.170,.215,.465,-.021,-.477,-.200,-.083,.075,.218,-.086,.129,-.125,.349,.686)*f10_1+
    mat4(-.275,.633,.355,.483,-.100,.111,.235,.229,.293,-.923,.212,.110,-.442,.157,.759,-.525)*f10_2+
    mat4(.083,.338,.422,-.506,.484,-.232,.367,.513,.167,.337,.714,-.101,-.122,-.164,.070,-.198)*f10_3+
    mat4(-.216,-.134,.439,-.152,.533,.066,-.144,-.137,-.099,.700,.233,-.021,-.549,-.025,.349,.042)*f10_4+
    mat4(.318,.436,-.066,-.512,-.131,-.153,.187,.435,.074,.023,.128,-.139,.164,-.110,-.097,.582)*f10_5+
    mat4(.289,.040,-.112,-.069,.591,.077,.184,-.161,-.012,.082,.739,-.268,.272,.062,.141,.107)*f10_6+
    mat4(.087,-.096,.045,-.481,-.251,.444,-.442,-.014,.194,-.329,-.057,-.006,.022,-.462,.165,-.232)*f10_7+
    vec4(-1.293,-.528,.206,-.514))/3.3+f10_3;
vec4 f11_4=sin(mat4(.062,.098,.694,-.401,.098,-.105,.196,-.070,.166,-.216,-.263,-.724,.126,-.113,-.071,.741)*f10_0+
    mat4(.078,.267,-.354,.177,-.143,-.283,.192,.012,.061,-.067,-.085,.411,-.203,.043,-.099,.150)*f10_1+
    mat4(.093,.297,-.762,.095,.077,-.184,.596,.006,-.079,-.211,-.128,-.167,.183,.424,-.005,-.131)*f10_2+
    mat4(.012,-.195,-.705,.404,.102,.153,.405,-.194,-.219,.240,.078,.178,.051,-.375,-.131,-.016)*f10_3+
    mat4(-.301,.223,-.185,-.237,-.142,.622,.873,-.359,-.386,.306,.661,.143,.350,.010,-.204,-.071)*f10_4+
    mat4(-.043,.289,.361,.210,-.091,-.006,.205,-.255,.063,.083,.192,-.339,.364,-.981,-.559,-.071)*f10_5+
    mat4(.182,-.035,-.295,-.581,-.120,.569,.359,-.413,.402,-.016,-.188,.223,-.231,-.254,-.061,-.233)*f10_6+
    mat4(-.892,.200,.009,-.119,-.413,-.306,-.168,-.470,.254,-.210,-.096,.331,.311,-.590,-.388,.344)*f10_7+
    vec4(.269,-.468,-.432,.017))/3.3+f10_4;
vec4 f11_5=sin(mat4(-.048,-.076,-.141,-.060,-.568,.041,-.301,.118,.113,-.344,.227,-.867,-.317,.181,-.072,.269)*f10_0+
    mat4(-.067,.355,.128,.341,.169,.385,.213,-.139,.216,-.216,.202,.104,-.341,-.086,-.062,-.378)*f10_1+
    mat4(-.053,.276,.168,.063,-.350,-.461,-.147,-.184,-.307,-.692,-.019,-.053,.263,-.351,-.368,-.172)*f10_2+
    mat4(.005,.329,.020,-.085,-.617,-.196,.417,-.026,.106,-.209,-.247,-.459,-.104,-.191,-.782,.153)*f10_3+
    mat4(-.388,.531,-.076,.284,.540,-.718,-.220,-.645,-.751,.000,.357,.621,-.295,.621,-.089,-.165)*f10_4+
    mat4(.008,-.553,-.041,-.065,-.003,-.082,.427,.586,.493,.466,.456,-.005,-.385,-.130,-.217,-.535)*f10_5+
    mat4(.154,.244,.433,.084,.547,-.573,.311,.018,.286,-.159,-.158,-.010,.246,.222,-.499,-.466)*f10_6+
    mat4(-.044,-.148,.041,.338,.250,-.199,-.216,-.174,-.464,.478,.445,.195,-.174,-.008,-.796,-.001)*f10_7+
    vec4(.995,-.022,-.773,.489))/3.3+f10_5;
vec4 f11_6=sin(mat4(.113,-.650,-.240,-.250,.174,-.417,.093,.376,.353,-.528,-.392,.240,.056,-.371,.044,.044)*f10_0+
    mat4(.163,-.543,-.288,-.160,.050,-.044,-.233,-.945,.101,.199,.206,.077,-.381,.087,-.351,.373)*f10_1+
    mat4(.199,-.417,-.642,.540,.230,-.300,.892,-.266,-.900,-.280,-.437,.468,-.198,.231,.001,-.389)*f10_2+
    mat4(.037,-.493,-.255,-.140,-.060,.403,.286,.705,.417,-.284,-.670,-.769,.220,.044,-.315,.507)*f10_3+
    mat4(.235,-.086,.179,-.027,.464,.201,.758,.362,-.065,.153,-.159,.659,-.164,-.099,.574,-.182)*f10_4+
    mat4(-.627,.133,-.310,-.064,-.633,-.483,-.922,-.271,-.017,-.291,-.006,-.468,.520,-.166,.414,.464)*f10_5+
    mat4(-.682,-.355,.052,-.025,-.741,.881,.166,.189,-.081,.142,-.006,-.573,.314,-.318,-.356,-.784)*f10_6+
    mat4(-.366,.001,-.168,.101,-.379,.712,-.180,.025,-.008,-.257,.197,-.150,.144,.179,-.125,-.332)*f10_7+
    vec4(.111,.517,.542,.029))/3.3+f10_6;
vec4 f11_7=sin(mat4(-.383,-.717,-.439,.130,-.122,-.325,-.396,-.156,.073,-.073,-.129,.271,-.028,.200,-.039,-.131)*f10_0+
    mat4(.205,.308,.032,.028,.249,-.160,-.252,-.059,-.066,.394,.049,.067,.048,.279,.280,.253)*f10_1+
    mat4(-.008,.484,-.149,-.644,.099,-.275,.588,.632,-.194,-.325,-.559,-.181,-.612,-.214,-.168,-.697)*f10_2+
    mat4(-.220,.639,.207,.450,-.245,-.342,-.197,-.614,.473,-.187,.331,.009,-.457,.471,-.161,.447)*f10_3+
    mat4(.198,-.226,.123,.132,-.018,-.970,-.206,-.177,-.364,-.832,.246,.019,.023,.181,.121,-.031)*f10_4+
    mat4(-.494,-.045,-.376,-.230,-.132,.001,.033,-.338,-.318,-.466,.146,-.226,.115,.016,.115,.467)*f10_5+
    mat4(-.325,.277,.458,-.551,.296,.042,.209,-.647,.285,-.370,-.061,-.291,-.085,-.059,.387,.476)*f10_6+
    mat4(-.405,-.369,.054,-.128,-.344,-.555,-.093,-.171,-.173,-.399,-1.065,-.024,.164,.429,.315,.652)*f10_7+
    vec4(.081,-.059,-1.153,-.223))/3.3+f10_7;
vec4 f12_0=sin(mat4(-.733,.352,-.267,-.158,-.082,.433,.213,.496,.261,.524,-.238,-.959,.015,.390,.014,-.083)*f11_0+
    mat4(.107,.084,-.395,.459,.146,.561,-.445,-.142,.148,-.270,.340,.151,.271,-.161,.353,-.582)*f11_1+
    mat4(.559,-.092,.251,-.359,-.849,-.578,-.190,.484,.073,-.266,.421,-.321,-.295,.108,-.107,.171)*f11_2+
    mat4(.479,.418,-.216,-.099,.209,-.160,.065,.137,-.037,-.156,.137,-.301,.630,.156,.136,-.439)*f11_3+
    mat4(-.165,-.057,.262,.525,-.730,-.161,-.495,.438,-.227,-.992,.266,.361,-.210,-.235,.087,-.027)*f11_4+
    mat4(.022,-.165,.139,-.431,-.071,-.009,.167,-.058,-.087,.437,.297,.085,.339,.127,-.624,-.548)*f11_5+
    mat4(.232,.002,.489,-1.158,-.007,-.061,.300,.070,-.153,.052,-.284,.589,.105,.011,-.252,.205)*f11_6+
    mat4(-.245,-.287,.291,-.119,-.250,.427,-.255,-.290,-.259,.081,-.494,.440,.060,-.463,-.005,.470)*f11_7+
    vec4(-.354,.498,-.625,.578))/3.5+f11_0;
vec4 f12_1=sin(mat4(-.199,.010,-.050,.480,.561,.244,-.011,-.257,.083,-.430,.154,.600,.036,.480,-.144,-.983)*f11_0+
    mat4(.145,.068,-.035,.128,.076,-1.107,-.371,.712,.255,-.332,-.444,-.079,.375,.499,-.306,.311)*f11_1+
    mat4(-.073,-.160,-.182,.836,-.442,.232,.323,-.378,.131,.398,-.297,-.208,-.113,.230,.328,-.874)*f11_2+
    mat4(-.593,-.800,-.056,.544,.565,-.182,-.514,.403,-.692,-.190,.304,-.118,.132,.546,-.146,.120)*f11_3+
    mat4(-.191,.758,.108,.840,-.207,.041,-.003,-.456,-.115,.268,.046,-.370,-.240,-.155,.501,.192)*f11_4+
    mat4(-.317,-.267,-.496,-.272,-.452,-.123,-.747,.275,.077,-.353,-.637,-.483,.138,-.046,.207,.345)*f11_5+
    mat4(-.297,.112,.103,-.350,-.026,-.403,-.680,.297,-.141,.203,.466,-.115,-.110,-.019,-.185,.483)*f11_6+
    mat4(.057,.563,-.533,.063,1.272,-.278,-.145,-.121,.259,.283,.163,-.881,.185,.445,.005,-.001)*f11_7+
    vec4(.100,1.272,.652,.631))/3.5+f11_1;
vec4 f12_2=sin(mat4(-.119,-.381,.110,-.088,.337,.149,.296,.272,.243,.122,.327,-.153,.383,-.035,.139,.278)*f11_0+
    mat4(-.442,.336,-.102,.150,-.068,-.443,.241,-.145,-.134,.204,-.266,-.032,.067,.144,-.189,-.016)*f11_1+
    mat4(1.448,.050,-.631,.223,-.706,.419,.219,-.514,.103,-.102,-.275,-.297,-.510,-.201,-.110,.309)*f11_2+
    mat4(-.413,-.271,-.605,.133,-.183,-.019,.126,.001,-.070,-.313,-.265,.096,-.134,-.687,.187,.270)*f11_3+
    mat4(-.300,.230,-.193,-.187,-.321,-.513,.768,.019,-.008,-.219,-.096,.297,.046,.108,-.161,.152)*f11_4+
    mat4(-.244,-.226,.470,-.546,.240,-.247,-.155,.637,.101,-.669,.176,.561,-.321,.182,.133,-.577)*f11_5+
    mat4(.232,-.702,-.114,.492,.280,-.369,.679,.752,-.242,-.337,-.653,.268,-.183,.202,.030,-.720)*f11_6+
    mat4(-.332,-.411,-.443,.491,-.328,.658,.375,-.158,-.059,-.446,-.431,-.378,-.416,.286,-.027,-.533)*f11_7+
    vec4(.144,.528,.390,.319))/3.5+f11_2;
vec4 f12_3=sin(mat4(-.132,.391,-.021,-.106,.425,.268,-.250,-.073,-.250,.143,-.209,.393,-.333,-.206,.021,.203)*f11_0+
    mat4(.258,.184,-.074,-.126,.164,.125,-.185,.064,-.389,.353,.243,-.043,-.331,-.270,-.433,.232)*f11_1+
    mat4(-.113,-.636,-.561,.180,-.568,.336,-.044,-.779,-.250,-.069,.045,.643,.175,-.441,.119,-.729)*f11_2+
    mat4(.660,-.238,-.354,.664,.237,.741,-.184,.255,-.166,-.165,.438,-.706,-.273,.379,-.282,.647)*f11_3+
    mat4(-.051,.195,-.491,-.203,-.579,.490,-.353,-1.304,-.707,-.002,.280,-.305,.561,-.372,.074,-.741)*f11_4+
    mat4(-.220,-.303,-.278,-.059,.138,.172,-.558,.020,.384,.334,.591,.058,-.300,.726,.428,.015)*f11_5+
    mat4(.313,-.195,-.224,.061,-.196,.336,.062,-.125,-.442,-.422,-.698,-.105,-.294,.292,.152,.056)*f11_6+
    mat4(-.764,.112,-.124,-.047,-.429,.160,.346,-.046,.310,-.120,.895,.846,.404,-.150,.201,-.483)*f11_7+
    vec4(-.554,-.468,.726,.165))/3.5+f11_3;
vec4 f12_4=sin(mat4(-.194,-.078,.122,.071,-.175,.000,-.359,-.470,-.070,.331,.237,-.339,-.273,.212,-.185,-.346)*f11_0+
    mat4(-.045,-.171,-.697,-.157,.517,.535,-.147,-.381,-.178,.169,.267,-.156,-.341,-.078,-.108,-.667)*f11_1+
    mat4(-.150,.380,.214,-.682,-1.036,-.386,.139,.432,-.223,-.031,-.191,.365,.049,.068,-.244,-.172)*f11_2+
    mat4(.023,-.046,.315,-.824,.082,-.261,.459,.319,-.602,.460,-.056,-.164,.070,-.022,-.579,-.742)*f11_3+
    mat4(-.249,-.454,-.072,-.169,-.478,-.817,.450,.192,-.013,.158,.857,.395,-.074,-.093,.181,.350)*f11_4+
    mat4(-.043,-.122,-.343,.327,.012,.685,.491,-.269,.637,.635,.216,.022,.185,-.102,-.566,.040)*f11_5+
    mat4(.708,.036,.081,.251,.294,-.073,.739,.413,-.433,-.356,.192,.009,.020,.353,-.187,-.146)*f11_6+
    mat4(-.114,-.584,-.008,.584,.262,.384,-.555,-.386,.593,-.566,.128,-.157,-.239,-.070,-.469,.682)*f11_7+
    vec4(-.221,-1.027,-.882,1.200))/3.5+f11_4;
vec4 f12_5=sin(mat4(.068,.377,-.005,-.034,-.186,-.172,-.059,-.388,.423,.668,.278,-.072,-.338,.248,-.187,-.124)*f11_0+
    mat4(-.185,-.480,-.423,.192,.152,-.039,-.601,.223,.252,-.559,-.276,.412,.275,.087,.163,-.138)*f11_1+
    mat4(.047,.465,.309,.111,-.242,-.075,-.097,.056,.158,.614,-.059,-.336,-.551,-.056,-.197,-.368)*f11_2+
    mat4(-.156,-.238,.261,-.315,.139,.283,.568,.062,-.592,.243,.417,-.058,-.380,-.228,-.601,-.318)*f11_3+
    mat4(.206,.014,.187,.264,.131,-.241,-.860,-.123,.344,.257,.178,-.325,.040,.306,.188,-.141)*f11_4+
    mat4(.384,.203,.057,-.441,.224,.763,.317,-.928,-.162,.098,.575,-.089,.108,-.055,-.207,.518)*f11_5+
    mat4(-.154,.688,.389,-.433,.412,.280,.664,-.302,-.354,.008,.321,-.626,.763,-.058,.073,.261)*f11_6+
    mat4(.479,.020,.053,-.188,-.229,-.328,-.142,.359,.064,.418,.164,-.513,.130,-.091,-.565,.181)*f11_7+
    vec4(-.078,-1.317,-.323,.319))/3.5+f11_5;
vec4 f12_6=sin(mat4(.034,.373,-.464,-.361,.807,-.336,-.624,-.063,-.055,.506,-.231,-.794,-.114,.240,.374,.452)*f11_0+
    mat4(.421,-.406,-.040,.191,-.095,-.130,.209,-.618,.168,-.181,-.371,-.435,-.045,.063,-.512,-.405)*f11_1+
    mat4(.103,.537,1.051,.782,-.182,-.263,-.660,-.576,.421,.314,.603,.203,-.051,.175,-.030,-.239)*f11_2+
    mat4(-.219,-.235,-.187,-.390,.043,.329,-.506,-.076,-.573,.177,-.319,-.537,.707,-.117,-.353,-.517)*f11_3+
    mat4(-.069,-.183,-.036,-.754,.067,.131,.173,.372,-.301,.483,-.986,.436,-.365,.274,.117,.035)*f11_4+
    mat4(-.015,.005,.478,.109,.074,.272,-.726,-.417,-.438,.517,-.721,-.207,-.007,.096,.427,-.172)*f11_5+
    mat4(-.548,1.004,-.310,-.083,-.547,.864,-.310,.109,.072,-.157,.161,-.224,.413,.014,-.552,-1.221)*f11_6+
    mat4(-.310,.065,-.503,.057,.262,-.100,.301,.216,.741,-.016,.048,-.172,.370,-.255,.213,-.528)*f11_7+
    vec4(.567,-1.002,.742,-.616))/3.5+f11_6;
vec4 f12_7=sin(mat4(-.081,-.809,.129,.504,.023,-.142,-.083,.338,-.429,.382,-.177,.309,.599,-.045,-.246,-.008)*f11_0+
    mat4(-.046,-.048,-.623,-.103,-.457,.344,.424,.506,.318,-.109,-.141,-.328,-.616,.266,-.254,-.253)*f11_1+
    mat4(-.471,.763,-.105,-.187,.475,-.411,-.676,-.447,.015,.397,-.363,.226,.334,.030,.145,-.160)*f11_2+
    mat4(-.702,-.271,.365,-.645,-.261,-.322,-.238,.279,-.063,-.146,-.138,-.459,.263,-.092,.090,.422)*f11_3+
    mat4(-.381,-.329,-.277,-.028,.435,-.725,-.082,.346,.282,-1.040,-.201,-.295,-.287,-.471,-.146,.280)*f11_4+
    mat4(.249,-.324,.280,-.059,-.463,-.084,.070,.042,.651,.292,.250,-.266,.015,.660,-.086,.351)*f11_5+
    mat4(.482,-.429,.350,-.541,.420,-.311,.557,-.679,.051,-.268,-.364,.307,-.238,-.537,-.047,.186)*f11_6+
    mat4(.410,-.979,-.035,-.092,.130,.736,.242,.233,-.969,.569,-.461,.354,.004,.497,.024,-.486)*f11_7+
    vec4(-.114,1.257,-.890,.459))/3.5+f11_7;
vec4 f13_0=sin(mat4(-.988,.415,-.135,.185,.243,1.025,.330,-.031,.122,.669,.883,-.780,.222,-.052,-.062,.167)*f12_0+
    mat4(.079,-.073,-.277,.219,-.112,-.131,.455,.547,.104,-.371,-.090,-.205,-.011,-.433,-.500,.210)*f12_1+
    mat4(.568,-.252,.153,-.994,-.576,-.559,-.757,.395,.077,.552,-.172,-.125,-.002,-.109,.104,.238)*f12_2+
    mat4(.113,.052,-.402,-.333,-.453,.513,-.273,.261,.213,-.278,-.079,-.355,.203,.389,.319,-.512)*f12_3+
    mat4(-.204,-.340,.096,1.081,-.736,-.069,-.861,.778,-.180,-.036,-.277,-.269,-.363,-.264,-.211,.194)*f12_4+
    mat4(-.575,-.066,-.210,.582,.000,.397,.406,.021,.031,.228,.373,-.560,-.325,.176,.113,.546)*f12_5+
    mat4(-.042,-.517,.217,-.103,-.707,-.448,-.297,.427,-.194,-.068,-.114,.057,.081,-.289,.289,.071)*f12_6+
    mat4(-.337,-.202,-.512,-.370,-.039,.265,.345,.398,-.213,1.633,.823,.063,.197,-.512,-.431,.693)*f12_7+
    vec4(-.641,-.613,-.727,1.070))/3.6+f12_0;
vec4 f13_1=sin(mat4(-.228,.425,-.208,-.227,.379,.096,.245,.335,-.527,.154,-.350,.173,.334,.296,.186,.026)*f12_0+
    mat4(.229,-.524,.373,.397,-.350,-.242,.394,-.010,-.148,-.057,.274,-.153,-.420,-.042,.398,-.436)*f12_1+
    mat4(.041,-.491,.603,-.427,.168,.289,-.485,-.118,.112,.206,-.451,-.543,.320,.409,.142,-.735)*f12_2+
    mat4(-.130,.020,-.032,.044,-.337,.214,-.052,.807,.098,.438,.044,-.149,-.371,.280,-.047,.531)*f12_3+
    mat4(.166,-.118,-.426,.191,.337,.312,.532,.060,.138,.673,-.680,.119,.316,-.018,-.062,-.401)*f12_4+
    mat4(-.029,-.175,-.867,.006,.012,.657,-.350,.012,-.518,.587,-.698,-.176,-.515,-.346,.369,.382)*f12_5+
    mat4(-.937,.588,-.237,-.453,-.914,.677,-.650,-.124,.261,.094,.328,-.432,-.133,.176,-.143,-.331)*f12_6+
    mat4(-.048,.243,.029,-.550,-.106,-.399,.288,.160,.342,-.083,.235,-.303,.112,-.121,.079,.305)*f12_7+
    vec4(-.088,-.147,.353,.450))/3.6+f12_1;
vec4 f13_2=sin(mat4(-.075,-.515,.085,-.667,.382,.310,-.397,-.377,.761,.239,.041,-.765,.237,.422,-.710,.423)*f12_0+
    mat4(-.265,-.063,-.630,-.135,.055,.363,-.067,-.675,-.033,.072,.311,-.054,-.030,-.125,-.063,-.383)*f12_1+
    mat4(1.437,.925,-.550,-.044,-.929,-.817,.459,-.098,.077,.391,-.544,-.442,-.144,.437,.286,.900)*f12_2+
    mat4(.198,-.321,-.668,-.842,.149,-.563,-.086,-.548,.488,-.119,.357,.066,-.224,.227,.278,-.626)*f12_3+
    mat4(-.181,-.874,.123,-.640,-.721,-.954,.300,.993,-.569,-.534,.289,.030,.125,-.045,-.012,-.159)*f12_4+
    mat4(-.049,-.210,.158,.191,.408,.099,.238,-.534,.118,.339,.119,-.127,-.097,.101,.078,-.120)*f12_5+
    mat4(.044,.204,-.048,.101,.066,-.370,.426,.437,.028,-.352,-.609,.065,-.394,.059,.057,-.666)*f12_6+
    mat4(-.416,-.429,.142,-.046,-.460,-.040,.360,.388,-.255,-.081,-.596,.211,-.194,.256,.184,.069)*f12_7+
    vec4(-.235,-.064,-.487,-.070))/3.6+f12_2;
vec4 f13_3=sin(mat4(-.282,-.092,-.381,.327,-.065,-.092,-.409,.471,-.631,-.481,-.404,.066,-.036,.138,-.289,-.144)*f12_0+
    mat4(.079,.005,-.027,.073,-.237,.545,-1.098,.548,.165,.351,.175,-.308,-.435,-.156,-.150,-.324)*f12_1+
    mat4(-.187,.402,.260,-.185,-.353,-.990,-.044,.439,.382,.852,.048,-.285,-.081,-.404,.280,-.462)*f12_2+
    mat4(.040,-.083,.270,-.011,.109,-.037,-.406,.849,.312,-.047,.552,-.190,-.491,-.082,-.194,.219)*f12_3+
    mat4(.317,-.226,-.753,-.101,.109,-.762,-.201,-.242,.416,.263,.453,-.270,-.238,-.233,.007,-.307)*f12_4+
    mat4(.245,-.013,-.169,-.054,.520,.544,-.017,.039,-.292,-.562,.124,.044,-.269,-.189,-.253,.199)*f12_5+
    mat4(.146,.082,.511,-.314,.366,.436,.394,.121,.413,.208,.269,.360,-.486,.034,-.061,.579)*f12_6+
    mat4(.670,-.033,.682,.108,-.641,-.118,-.281,-.114,.243,.606,-.153,1.104,.018,-.052,-.290,.014)*f12_7+
    vec4(.277,1.014,-.707,-1.070))/3.6+f12_3;
vec4 f13_4=sin(mat4(-.069,.089,-.497,.380,.587,.172,.081,-.046,.145,.018,-.371,.339,.114,-.108,.408,-.179)*f12_0+
    mat4(-.019,-.187,.473,-.126,-.209,-.327,-.160,-.028,-.482,-.363,-.384,.103,.030,-.026,-.039,-.138)*f12_1+
    mat4(.230,.463,.163,-.048,-.730,-.090,-.527,.208,.415,-.284,.080,.276,.125,.507,.182,-.196)*f12_2+
    mat4(.086,-.093,-.148,-.224,.045,.511,-.280,.595,-.045,-.121,.234,.214,.019,-.261,.173,.243)*f12_3+
    mat4(-.783,.298,-.278,.201,-.408,.124,-.218,-.502,-.784,-.465,-.441,1.020,-.301,.421,-.469,-.608)*f12_4+
    mat4(.016,-.145,.033,.156,-.208,.084,-.075,.219,.198,-.146,-.174,.337,.063,-.285,-.116,-.051)*f12_5+
    mat4(-.085,-.027,-.440,.386,-.420,.281,-.770,.659,.286,.504,.471,-.122,-.486,-.727,-.061,1.025)*f12_6+
    mat4(-.251,-.050,.086,.193,-.164,.206,.087,.264,1.024,-.570,.204,-.351,-.323,-.385,.114,-.335)*f12_7+
    vec4(.721,-.509,1.524,-.748))/3.6+f12_4;
vec4 f13_5=sin(mat4(.311,.066,.033,-.225,.541,-.118,.047,-.062,-.148,.306,.178,-.245,.039,-.378,-.086,-.490)*f12_0+
    mat4(.062,.158,-.149,.133,-.660,-.663,.167,-.468,-.266,.232,.035,-.250,-.581,-.189,-.315,-.027)*f12_1+
    mat4(-.177,.301,-.090,-.139,.741,-.627,-.097,.074,-.182,.514,-.085,.418,-.418,.190,-.342,.647)*f12_2+
    mat4(-.434,.093,.403,.429,.536,.195,.154,-.507,-.496,.201,.378,-.144,.291,.139,-.800,-.506)*f12_3+
    mat4(-.177,-.388,.210,.015,.099,-.876,-.551,-.000,.381,.294,.111,.023,.138,.155,-.123,.461)*f12_4+
    mat4(-.019,.134,-.503,.613,-.007,.902,.792,.625,-.446,-.047,.987,-.096,.430,.144,.007,-.834)*f12_5+
    mat4(.174,.567,.258,.261,-.024,.104,.451,-.171,-.196,.235,.172,-.148,-.029,-.232,-.157,-.527)*f12_6+
    mat4(.507,.659,-.338,.024,.611,-.059,-.449,-.345,-.438,-.258,.057,.336,.015,-.619,.222,-.220)*f12_7+
    vec4(.736,.193,-1.355,-1.590))/3.6+f12_5;
vec4 f13_6=sin(mat4(-.086,.052,-.341,-.585,.631,-.543,-.519,-.324,-.324,.396,.374,.260,.168,-.008,.116,-.344)*f12_0+
    mat4(.211,-.597,.086,-.088,-.123,-.030,.604,-.917,-.117,-.036,.353,-.180,.308,-.356,.396,.009)*f12_1+
    mat4(.409,.319,-.099,.273,-.238,-.248,.081,-.072,-.373,-.396,.267,.583,.551,-.450,-1.329,.221)*f12_2+
    mat4(-.409,-.376,.081,.013,-.001,.381,.137,-.456,.119,.690,.235,-.199,-.320,-.168,-.095,.218)*f12_3+
    mat4(-.026,.010,.578,.292,-.041,.044,-.675,.013,-.674,.615,-.395,-.158,.488,.078,-.201,-.215)*f12_4+
    mat4(-.524,-.304,-.633,-.013,.095,.335,-.289,-.160,.094,.075,.372,-.394,-.069,.178,.036,-.268)*f12_5+
    mat4(-.144,.705,.314,-.288,.089,.849,.217,-.323,.414,-.392,.070,-.115,-.754,-.133,.665,-.340)*f12_6+
    mat4(-.137,.236,.415,-.386,.171,-.222,-.026,.389,-.078,-.606,.328,.640,.490,-.532,.341,.647)*f12_7+
    vec4(1.036,-1.060,.607,-.569))/3.6+f12_6;
vec4 f13_7=sin(mat4(.240,-1.040,-.181,-.302,.181,-.645,-.405,-.362,-.169,.555,.304,.053,-.454,.070,-.154,-.401)*f12_0+
    mat4(-.019,-.325,-.112,-.442,-.429,-.147,.182,-.030,.781,-.350,.286,.366,-.001,-.500,-.075,.430)*f12_1+
    mat4(-.206,.054,-.345,.017,-.371,-.304,-.237,.316,-.011,-.340,-.381,.153,-.307,.211,-.084,-.250)*f12_2+
    mat4(-.495,.233,.484,.259,-.036,.186,-.238,.039,.151,.427,-.186,.121,-.477,-.308,.316,.153)*f12_3+
    mat4(.067,.103,-.301,-.163,.171,-.325,-.123,-.001,.095,-.208,-.538,-.094,-.506,-.384,-.448,-.011)*f12_4+
    mat4(.247,-.584,.001,.307,.291,.276,.419,-.209,-.107,.535,.446,-.233,-.377,.190,.422,-.407)*f12_5+
    mat4(-.018,.450,.713,-.246,.728,-.602,.410,-.409,.326,.091,-.497,.095,.095,-.551,.138,.784)*f12_6+
    mat4(.460,.029,.286,-.201,.318,-.253,.054,-.295,-.237,.000,.017,.371,-.295,.263,-.131,.214)*f12_7+
    vec4(-.159,-.884,-1.233,-.958))/3.6+f12_7;
vec4 f14_0=sin(mat4(.987,-.304,.298,-.596,-.161,1.053,-.279,.169,.321,-.241,.162,-.568,-.066,.134,-.049,.316)*f13_0+
    mat4(-.177,.367,-.362,.693,.423,.351,.642,-.041,-.170,.198,.421,-.393,-.034,.111,.055,.505)*f13_1+
    mat4(-.600,.103,.192,.560,.359,-.273,-.466,.338,-.502,.358,-.009,.147,-.440,-.086,-.597,.085)*f13_2+
    mat4(-.261,-.235,-.261,.112,.406,.022,.396,-.052,-.199,-.411,-.399,-.189,.416,.217,.412,.008)*f13_3+
    mat4(.089,-.495,.187,-.310,.492,-.348,-.604,1.235,.321,-.555,-.105,-.670,-.124,-.078,-.279,.035)*f13_4+
    mat4(.233,-.126,-.480,-.200,.175,-.290,.090,-.063,.096,-.151,.328,-.120,.419,.217,.339,.323)*f13_5+
    mat4(.354,-.528,.376,-.835,.479,-.515,.493,-.507,-.540,-.159,-.105,.475,.346,.077,.520,-.150)*f13_6+
    mat4(.125,-.514,-.349,.232,.275,.154,-.137,.552,.354,.816,-.351,.542,-.325,.217,.198,.624)*f13_7+
    vec4(-.238,2.975,.040,-.768))/3.7+f13_0;
vec4 f14_1=sin(mat4(-.236,-.209,.632,-1.086,.363,-.191,.512,.159,-.399,-.525,-.236,-.538,.500,.559,.015,.561)*f13_0+
    mat4(.092,.360,-.375,.095,-.112,-.743,.446,.231,.346,-.258,-.127,-.132,.161,-.394,-.282,.292)*f13_1+
    mat4(-.241,.123,.521,-.300,.118,-.554,-.204,-.018,-.742,-.316,-.505,.789,-.679,.444,-.447,-.100)*f13_2+
    mat4(-.497,-.567,.500,.479,-.284,-.737,.674,-.565,.019,.257,-.051,-.460,.531,.038,-.074,-.658)*f13_3+
    mat4(-.568,-.074,-.336,-.057,.529,.813,-.036,-1.060,.247,-.249,.561,.315,.093,-.420,-.073,-.134)*f13_4+
    mat4(-.430,-.270,-.187,.506,-.716,-.564,.087,.405,-.698,-.499,.564,-.222,-.112,-.341,-.045,-1.476)*f13_5+
    mat4(-.438,-.035,-.009,-.433,.169,.150,.823,-.328,-.182,1.031,-.432,.356,.040,-.647,-.059,-.392)*f13_6+
    mat4(-.431,.750,-.263,-.134,.086,.333,-.236,-.346,-.457,-.505,.245,.614,.434,.149,-.395,.733)*f13_7+
    vec4(.762,1.872,-.407,.381))/3.7+f13_1;
vec4 f14_2=sin(mat4(-.221,-.146,.066,-.166,-.032,-.141,-.712,-.193,-.505,-.790,-.115,-.514,-.184,-.095,.036,.626)*f13_0+
    mat4(.156,.030,.022,-.286,-.015,-.211,.247,-.682,.263,.235,.273,.083,.355,.081,-.176,-.046)*f13_1+
    mat4(-.925,-.913,-.514,-.890,.577,1.013,.752,.670,-.380,-.357,-.810,.639,-.017,-.151,-.515,-.191)*f13_2+
    mat4(.129,-.037,-.063,-.600,-.176,-.068,-.045,.404,.022,-.066,.132,-.202,.012,-.176,.014,-.204)*f13_3+
    mat4(.365,.773,1.055,-.579,.363,.682,.690,.089,-.207,.509,.740,.333,-.095,-.015,-.339,-.562)*f13_4+
    mat4(.600,.190,.109,.976,-.545,-.276,-.013,-.457,-.065,.008,.100,-.581,.088,-.210,.166,.500)*f13_5+
    mat4(-.306,-.281,.238,.306,-.362,.041,.379,.382,-.089,-.159,-.339,-.153,.076,-.145,.230,-.125)*f13_6+
    mat4(-.090,.509,.363,.599,.014,.048,.142,-.496,.273,-.754,-.924,-.222,.467,.339,-.149,.178)*f13_7+
    vec4(-.883,1.044,-.397,-.711))/3.7+f13_2;
vec4 f14_3=sin(mat4(-.081,.497,-.677,-.473,.137,.596,-.690,.107,-.308,.534,.218,-.036,-.051,-.297,.179,.060)*f13_0+
    mat4(-.111,-.174,-.068,.390,-.318,.107,-.194,-.187,-.595,.635,.296,.388,.173,.450,.000,.558)*f13_1+
    mat4(-.181,.285,.747,.548,.165,.331,-.249,.106,.436,-.163,-.085,-.462,.547,-.670,-.053,-.621)*f13_2+
    mat4(-.445,.041,.213,-.295,-.665,.151,-.734,-.282,.295,.070,.485,.123,.222,.208,-.321,.414)*f13_3+
    mat4(.095,.386,.203,-.050,-.014,.037,-.626,-.234,-.093,.752,-.068,-.274,.349,.012,-.200,-.533)*f13_4+
    mat4(.498,-.206,-.297,-.902,-.430,.345,.193,-.358,.147,.236,.238,-.592,-.924,.247,-.070,.586)*f13_5+
    mat4(-.403,.037,1.181,.042,-.669,.647,.319,.178,.371,-.286,.533,.139,-.301,.675,-.175,.257)*f13_6+
    mat4(.504,-.099,.275,.116,.106,-.034,-.494,.300,-.046,-.177,-.786,-.281,.329,-.148,-.041,.349)*f13_7+
    vec4(.355,-.314,.662,.326))/3.7+f13_3;
vec4 f14_4=sin(mat4(-.236,.198,.576,-.289,.274,.057,-.284,-.336,-.624,.148,.215,.044,.370,-.163,.001,-.276)*f13_0+
    mat4(.489,-.210,-.026,-.257,.002,-.805,.453,-1.217,-.164,-.816,-.088,-.175,-.018,.011,-.525,-.132)*f13_1+
    mat4(-.049,.109,-.678,-.450,-.248,.530,.051,.670,.223,.089,-.525,.596,.460,.493,-.098,.361)*f13_2+
    mat4(.238,.293,.033,-.055,-.247,-.184,-.095,-.147,-.466,-.024,.008,.275,-.331,-.087,-.092,-.333)*f13_3+
    mat4(-.344,.151,.170,.461,.066,.691,.382,-.343,-.258,.154,1.045,-.255,.143,.649,.300,.731)*f13_4+
    mat4(.405,.342,-.203,-.022,-.095,.370,.217,-.434,-.405,-.379,.187,-.754,-.047,-.277,-.037,.283)*f13_5+
    mat4(-.075,-.494,.394,-.652,-.076,-.024,.285,-.653,.475,.305,-.252,.629,-.575,-.792,-.007,.337)*f13_6+
    mat4(-.332,.120,.321,-.421,-.354,.198,-.170,.069,.541,-.177,-.263,-.108,.204,.070,-.218,1.029)*f13_7+
    vec4(.992,-1.303,-1.216,.313))/3.7+f13_4;
vec4 f14_5=sin(mat4(.376,.496,-.588,.219,.277,.234,-.069,-.162,.296,.063,.094,-.371,.125,-.546,.215,.159)*f13_0+
    mat4(.353,-.078,-.321,.110,-.459,.097,-.474,-.326,-.170,.072,.406,-.539,.003,-.014,.538,.072)*f13_1+
    mat4(.208,-.655,-.136,-.171,-.506,.832,-.129,.490,-.073,.683,-.313,-.228,.565,.677,-1.171,.675)*f13_2+
    mat4(-.523,.319,-.661,-.512,-.155,.443,.142,-.264,-.605,.116,.650,.190,.242,.244,-.258,-.030)*f13_3+
    mat4(-.225,-.262,-.560,.523,.692,.053,-.485,.728,-.282,-.287,.079,-.228,-.045,.285,-.821,.536)*f13_4+
    mat4(.073,.007,-.508,.325,.306,.082,.404,-.414,.037,.924,.408,-.224,.121,.041,-.141,-.399)*f13_5+
    mat4(-.382,-.038,1.057,-.667,-.034,-.647,.596,-.659,.223,.532,-.903,.599,-1.137,-1.059,.285,-.298)*f13_6+
    mat4(-.064,-.460,.414,.087,.151,.605,.191,-.205,.481,.370,-.521,-.407,-.395,.112,-.153,.215)*f13_7+
    vec4(-.744,-.000,.264,.830))/3.7+f13_5;
vec4 f14_6=sin(mat4(.416,-.214,.097,-.037,-.007,-.266,.713,-.467,-.050,.530,.091,.273,-.057,.244,-.518,-.272)*f13_0+
    mat4(.270,-.309,.031,-.301,.165,-.046,-.984,-.457,.066,-.092,-.519,-.007,.018,-.143,.214,-.470)*f13_1+
    mat4(.038,.154,-.008,-.036,.310,-.263,-.253,-.687,-.127,.115,-.219,-.438,-.128,-.098,.966,1.198)*f13_2+
    mat4(-.189,.070,.357,-.458,.031,.138,-.383,-.550,.029,.007,-.390,.521,-.149,-.148,.044,.149)*f13_3+
    mat4(.188,-.265,-.166,-.389,-.301,-.101,.432,-.335,-.108,.276,-.129,.568,.033,.226,.677,-.208)*f13_4+
    mat4(.042,-.311,.566,.330,.222,.615,.291,.541,.221,.222,-.232,.369,-.708,-.393,-.584,-.610)*f13_5+
    mat4(.289,.773,.265,1.050,.296,.607,-.391,.568,-.045,-.224,.416,.162,.053,-.352,-1.027,-.266)*f13_6+
    mat4(.207,.144,.147,.586,-.092,.043,-.390,.214,-.503,-.506,.409,-.369,-.662,.027,-.286,-.549)*f13_7+
    vec4(.722,-1.640,-1.309,.379))/3.7+f13_6;
vec4 f14_7=sin(mat4(.061,.537,.027,.296,-.105,.552,-.891,-.490,-.347,.209,.089,.185,-.349,.013,.128,.573)*f13_0+
    mat4(-.051,.387,-.168,-.123,-.463,1.155,-.062,1.134,-.047,.151,.122,.679,-.088,-.019,.058,-.038)*f13_1+
    mat4(.714,.001,.088,.245,.257,-.072,.566,-.015,.335,.260,-.416,.149,.930,-.556,-.144,-1.095)*f13_2+
    mat4(.373,.547,-.013,.253,-.088,.273,.126,-.098,-.274,-.039,.237,.269,-.444,-.053,-.129,.151)*f13_3+
    mat4(.132,-.641,.570,-.131,.584,.959,.258,-.165,.419,-.117,.462,.054,.274,-.566,-.028,-.295)*f13_4+
    mat4(.140,.383,-.005,-.145,.258,.349,-.122,-.245,.051,.115,-.055,.070,-.101,.739,-.053,.292)*f13_5+
    mat4(-.114,-.351,.801,.250,.583,-.063,.861,.743,.034,.295,-.141,-.476,-.407,.116,-.007,.654)*f13_6+
    mat4(.155,-.574,.255,.052,-.079,.100,-.105,.151,.295,.699,-1.500,-.641,.005,-.057,.179,.006)*f13_7+
    vec4(1.522,.717,-.490,.565))/3.7+f13_7;
vec4 f15_0=sin(mat4(-.534,-.178,.213,.465,-.170,-1.440,.228,-.079,-.320,.329,.198,.364,.588,.008,.032,-.234)*f14_0+
    mat4(.607,-.631,.004,-.304,-.296,-.049,.190,-.242,.264,.032,.118,-.141,.151,-.019,-.379,-.581)*f14_1+
    mat4(.044,.303,.348,-.619,.533,.349,-.215,.419,.028,-.424,.331,-.569,.295,-.265,-.259,-.010)*f14_2+
    mat4(.195,.092,-.313,.111,-.439,.020,.408,.470,.111,.506,-.145,-.208,-.297,-.308,.078,-.352)*f14_3+
    mat4(.786,.720,-.352,-.127,.196,.247,-.255,-.179,.400,.559,-.453,.588,.413,.116,-.298,.448)*f14_4+
    mat4(-.016,-.097,-.398,-.060,.094,.217,-.095,.356,-.636,.132,-.046,.276,-.457,-.163,.419,.613)*f14_5+
    mat4(-.627,1.042,.460,.327,-.416,1.048,.658,.312,.547,-.192,-.290,-.337,-.323,-.157,.149,-.280)*f14_6+
    mat4(-.029,.740,-.165,-.055,-.250,-.343,.005,.643,-.100,-1.972,-.662,-.574,.096,-.029,-.509,.379)*f14_7+
    vec4(1.896,-.233,-.586,-.200))/3.9+f14_0;
vec4 f15_1=sin(mat4(.109,-.239,.555,-.582,.422,-.143,-.065,-.748,-.341,.189,.107,-.490,-.036,-.067,-.346,.288)*f14_0+
    mat4(.480,.016,.145,-.029,-.304,.403,-.150,-.306,.068,.416,-.506,-.279,-.203,.055,.304,-.134)*f14_1+
    mat4(.234,.438,-.319,-.494,-.173,.061,-.050,.428,.043,-.155,-.052,.148,.492,-.824,.965,.083)*f14_2+
    mat4(.364,.001,.009,.400,-.252,.328,-.206,-.386,.236,.145,-.043,-.001,.224,.183,.067,-.639)*f14_3+
    mat4(-.065,.419,.101,-.257,-.117,-.300,-.293,-.564,.154,.000,.088,-.144,.167,-.413,.760,.527)*f14_4+
    mat4(.249,-.602,.254,-.099,-.341,-.127,.544,-.595,.179,.115,-.316,.218,.702,.236,-.397,-.075)*f14_5+
    mat4(-.102,.085,-.230,-.269,-.709,.211,-.666,-.904,-.039,-.192,.328,.361,-.022,.746,-.477,-.091)*f14_6+
    mat4(.359,-.263,-.315,.262,.081,.302,-.016,-.642,.203,-.568,-.129,-.216,.194,.243,.165,1.395)*f14_7+
    vec4(.117,.716,-1.742,-1.116))/3.9+f14_1;
vec4 f15_2=sin(mat4(-.130,.022,-.547,.537,.540,-.650,.331,.248,-.342,.185,.044,-.042,-.170,.561,-.155,-.053)*f14_0+
    mat4(.228,.299,.130,-.160,.040,.406,.041,-.661,.027,.193,-.642,-.476,.079,.065,-.149,.020)*f14_1+
    mat4(-.409,-.227,-.460,-.320,-.010,-.102,-.612,-.039,-.252,-.351,.376,-.095,-.184,-.161,.862,.794)*f14_2+
    mat4(-.053,.462,.394,-.290,.036,-.298,-.332,-.113,-.173,.274,.222,-.132,.323,.053,.503,.041)*f14_3+
    mat4(.169,.162,.066,-.017,.255,-.310,-.186,.737,-.116,.275,-.235,.120,-.181,-.227,.057,.359)*f14_4+
    mat4(-.040,.023,.244,.574,-.188,.252,.188,.513,.019,.015,-.282,.162,.110,-.176,.035,-.119)*f14_5+
    mat4(-.307,.551,-.155,.497,-.399,.382,-.616,.292,-.006,-.102,.517,.321,.246,.311,-.401,-.768)*f14_6+
    mat4(-.178,-.217,-.198,.366,.273,.094,.114,-.312,.498,-.909,.271,-.121,.274,.249,.224,-.265)*f14_7+
    vec4(-.494,.459,-.653,-.281))/3.9+f14_2;
vec4 f15_3=sin(mat4(-.366,-.247,.148,.172,.295,.064,-.555,-.076,-.445,.174,-.229,-.181,.144,-.170,-.314,.568)*f14_0+
    mat4(.397,.309,-.157,.549,-.704,.324,.105,.543,-.140,.488,-.002,-.365,-.003,.672,.324,-.624)*f14_1+
    mat4(.157,.177,.155,-.792,-.059,.048,.507,.601,-.092,-.111,-.091,-.144,.747,-.153,-.522,-.087)*f14_2+
    mat4(-.178,.075,.454,-.769,-.190,-.200,-.186,.103,-.024,.129,.202,-.102,-.065,.391,.014,-.009)*f14_3+
    mat4(.282,.393,.034,-.055,.861,-.679,-.189,.878,-.185,.423,.789,-.308,.300,-.043,-.210,-.295)*f14_4+
    mat4(.391,-.393,.604,.009,-.150,.317,.246,-.391,-.763,.017,-.100,.722,-.484,-.690,-.715,.613)*f14_5+
    mat4(-.807,-.091,.669,-.753,-.647,.065,.162,-.003,.396,-.282,-.295,-.138,-.617,.499,-.007,.061)*f14_6+
    mat4(.058,-.012,-.011,-.327,-.059,-.152,-.661,.725,.582,-.119,-.914,.796,.085,.162,-.256,.313)*f14_7+
    vec4(.432,-.703,.195,-.251))/3.9+f14_3;
vec4 f15_4=sin(mat4(-.204,.284,-.570,-.426,-.257,.124,-.303,-.162,-.618,-.105,-.543,.233,-.048,-.302,.115,-.068)*f14_0+
    mat4(.424,-.229,.376,.061,.022,-.507,-.339,.693,.361,.017,.250,.667,.211,-.012,-.101,-.308)*f14_1+
    mat4(-1.548,-.666,.084,.218,1.260,-.139,.722,-.175,-.324,.127,.277,-.267,.020,.402,.254,-.892)*f14_2+
    mat4(.173,-.105,.443,-.300,-.086,-.005,-.057,.590,-.231,-.226,-.017,.125,-.295,-.059,-.129,.042)*f14_3+
    mat4(1.219,.149,.343,-.292,1.218,.731,-.135,-.133,.791,.562,.096,.171,-.021,.428,.441,-.603)*f14_4+
    mat4(.231,.347,.164,-.721,-.091,.362,.096,-.269,-.090,-.292,-.404,.413,-.330,.030,-.409,.557)*f14_5+
    mat4(-.233,-.001,.192,-.031,-.153,-.082,-.103,.285,.096,.286,.145,-.736,.121,-.142,.128,1.040)*f14_6+
    mat4(.451,.067,.701,-.098,.010,-.169,-.391,.425,-.500,.316,-.618,.176,.412,.146,.420,-.100)*f14_7+
    vec4(.843,-1.587,.379,-.127))/3.9+f14_4;
vec4 f15_5=sin(mat4(-.017,-.736,.235,-.668,.406,.408,-.343,-.077,-.244,-.038,-.284,-.950,.008,.182,.002,.355)*f14_0+
    mat4(-.068,.094,.373,.208,-.894,-.131,.518,-.923,-.673,-.627,-.442,-.282,.093,-.064,.094,.253)*f14_1+
    mat4(-.503,1.040,.115,-.047,.304,-.739,-.167,.430,-.262,.687,.254,.137,.991,1.228,.023,.754)*f14_2+
    mat4(.336,-.251,.098,.289,-.465,-.094,-.192,-.727,.174,.218,-.090,.149,-.044,-.293,.208,-.535)*f14_3+
    mat4(-.293,-.465,.311,.354,.305,-.759,-.676,.465,.104,-.404,.118,-.091,.499,.369,.646,.722)*f14_4+
    mat4(.265,-.216,.303,.202,-.004,.869,.631,-.228,-.299,-.248,-.746,-.494,-.553,-.662,-.491,-.794)*f14_5+
    mat4(-.407,.534,.804,-.355,.070,-.125,.099,-.243,-.078,.295,1.015,1.025,-.524,-.842,.397,-1.002)*f14_6+
    mat4(.286,-.425,.211,.487,-.064,-.336,-.038,-.008,.176,1.036,-.867,.119,.329,-.316,-.086,.295)*f14_7+
    vec4(.100,.337,-.061,1.712))/3.9+f14_5;
vec4 f15_6=sin(mat4(-.153,.367,.498,.065,-.642,-.230,.123,.368,.112,.361,.088,-.112,-.108,.256,.165,.194)*f14_0+
    mat4(-.339,-.570,.041,.462,-.191,.046,-.586,.585,-.413,-.208,-.794,.716,.039,.146,-.038,-.047)*f14_1+
    mat4(.592,.393,-.469,-.028,-.188,-.016,-.343,.434,.244,.319,.471,.051,.270,-.428,.980,-.625)*f14_2+
    mat4(.132,-.054,.439,-.170,-.084,.443,-.315,.250,.269,.221,-.002,-.648,-.124,.108,.167,-.102)*f14_3+
    mat4(.030,-.342,-.235,-.008,.059,-.362,.032,-.142,-.077,-.258,.236,-.085,.111,.169,.616,-.041)*f14_4+
    mat4(.172,-.343,.605,-.356,.149,.206,.140,-.784,-.101,.116,-.176,-.183,-.291,.076,-.609,.452)*f14_5+
    mat4(.617,.592,-.284,-1.017,.372,.832,-.245,-.317,.185,-.106,.450,-.322,-.433,.076,-.601,.701)*f14_6+
    mat4(.279,-.014,.118,-.478,-.254,.135,.022,.216,-.458,-.499,.085,.129,-.359,.055,.076,.356)*f14_7+
    vec4(-2.559,-.952,-.216,.412))/3.9+f14_6;
vec4 f15_7=sin(mat4(-.287,.225,-.612,-.066,-.588,.575,-.186,-.422,-.426,.442,-.417,.129,.369,-.165,.129,.061)*f14_0+
    mat4(.230,.499,.336,-.103,-.472,-.008,-.072,.277,-.224,-.363,.233,.194,-.187,-.239,.235,-.171)*f14_1+
    mat4(-.097,.283,-.052,-.198,.765,-.260,.266,-.235,-.373,-.358,-.158,-.738,.116,-1.005,.148,-.877)*f14_2+
    mat4(.024,-.106,.354,.500,-.222,.582,-.681,.251,.032,-.135,-.007,.217,-.499,.976,-.039,.153)*f14_3+
    mat4(.696,-.280,.412,-.511,.323,.332,.008,.069,.500,-.156,-.155,-.481,.393,-.591,.172,-1.149)*f14_4+
    mat4(.127,-.281,.177,-.368,.272,.136,-.235,.027,.047,.422,-.402,.520,-.096,.602,-.136,.041)*f14_5+
    mat4(.405,-.303,-.342,.001,-.124,-.359,-.434,.747,-.098,-.469,.078,-.452,-.538,-.050,.107,.417)*f14_6+
    mat4(.686,.359,.071,-.212,-.052,-.045,.030,.735,-.217,.903,-.239,.056,.025,-.549,.583,-.189)*f14_7+
    vec4(-.549,-.368,1.858,.419))/3.9+f14_7;
vec4 f16_0=sin(mat4(1.224,-.285,.342,.148,.071,-.109,.112,-.312,.589,.173,.513,-.141,-.180,-.204,.170,.178)*f15_0+
    mat4(-.290,.185,-.243,-.290,.362,.156,.264,-.324,-.242,.147,.005,-.267,-.299,.089,-.246,-.188)*f15_1+
    mat4(-.526,.304,.290,-.481,.344,-.273,-.480,.140,-.548,.184,-.189,.075,-.173,.041,-.088,-.124)*f15_2+
    mat4(-.718,-.028,-.373,.285,.716,-.184,.232,-.406,-.078,-.043,-.121,-.053,.467,.147,.087,.552)*f15_3+
    mat4(.612,-.172,-.583,.296,1.005,-.157,.160,.079,.099,-.454,-.019,.813,-.125,-.102,-.118,.302)*f15_4+
    mat4(-.167,-.157,-.338,.282,-.121,-.339,.007,-.108,.193,-.183,.072,.023,.840,.153,.525,-.307)*f15_5+
    mat4(.059,-.266,-.023,-.206,.277,-.224,.222,.422,-.159,.061,-.340,-.256,.259,.099,.088,-.109)*f15_6+
    mat4(.034,-.154,-.291,-.033,.489,.161,-.109,-.063,-.225,.370,-.063,-.520,-.619,.153,-.145,.385)*f15_7+
    vec4(-.008,.538,-1.252,.548))/4.0+f15_0;
vec4 f16_1=sin(mat4(.363,.201,.401,-.766,.828,.399,-.301,.240,-.345,-.406,-.181,.227,.336,-.004,-.212,-.318)*f15_0+
    mat4(.261,.181,.092,.378,-.148,.241,.445,-.249,-.044,.313,.533,-.154,-.061,-.184,-.276,.005)*f15_1+
    mat4(-.553,-.348,-.809,.842,.323,.170,.322,-.839,-.123,-.532,-.307,.674,-.066,-.630,-.376,.562)*f15_2+
    mat4(.025,-.398,-.433,.438,.130,.460,.281,-.776,-.357,-.633,-.156,-.098,.134,-.073,.442,-.684)*f15_3+
    mat4(-.007,.188,.899,-.510,.401,.624,.458,-.787,.376,-.142,.178,.157,-.023,-.684,-.335,.395)*f15_4+
    mat4(.217,-.016,-.065,-.288,.238,-.593,-.448,.413,.109,.121,-.034,.052,-.124,.693,.685,-.969)*f15_5+
    mat4(-.392,-.358,-.863,.266,-.471,-.232,-.448,-.450,-.196,-.244,-.405,.851,.011,.289,.785,-.536)*f15_6+
    mat4(-.273,.251,.191,-.096,-.107,.261,.441,.037,.619,.004,.089,.252,-.178,-.110,.157,-.031)*f15_7+
    vec4(-.412,-.318,.227,.430))/4.0+f15_1;
vec4 f16_2=sin(mat4(.201,-.394,-.736,-.482,.215,-.178,.333,-.063,-.317,-.506,-.466,.197,-.217,.129,.255,.036)*f15_0+
    mat4(.349,.049,.280,-.102,-.086,-.231,-.105,.584,.249,.078,.116,.689,.033,.252,.387,.003)*f15_1+
    mat4(-1.279,-.210,-.096,.052,.726,.439,-.157,.089,-.403,-.093,.128,-.244,-.038,.374,.211,-.760)*f15_2+
    mat4(-.093,-.086,.294,.153,.082,-.465,-.451,.334,-.164,.035,-.074,.055,-.098,-.164,-.026,.016)*f15_3+
    mat4(.649,.337,-.043,-.137,.772,.095,-.516,-.374,.505,.324,-.288,.271,-.077,.160,-.026,-.663)*f15_4+
    mat4(.232,.295,.372,-.527,-.180,.009,-.145,-.347,-.087,-.107,-.086,.460,.045,-.562,-.449,.320)*f15_5+
    mat4(-.556,-.042,-.363,.105,-.258,.026,-.383,.381,.094,.080,.181,-.790,.152,-.276,-.247,.688)*f15_6+
    mat4(.159,.194,-.047,-.287,.081,.052,.201,.317,.543,-.290,.177,-.356,.081,.353,.561,.219)*f15_7+
    vec4(-.553,.087,.291,-.912))/4.0+f15_2;
vec4 f16_3=sin(mat4(-.328,-.244,-.354,-.035,.073,-.305,-.303,.753,-.305,.288,-.030,.089,-.243,.057,-.164,.395)*f15_0+
    mat4(.003,-.290,-.395,.064,-.861,.654,-.293,.131,-.237,.647,-.418,.083,.264,-.102,-.253,-.363)*f15_1+
    mat4(.477,.057,.372,-.217,.202,.135,-.856,-.594,.289,-.557,.410,.020,.776,-1.119,.539,-.159)*f15_2+
    mat4(.495,-.294,.285,-1.005,-.471,.409,-.130,.714,.170,-.304,.316,-.246,-.612,.044,.179,.389)*f15_3+
    mat4(-.026,.183,-.567,-.279,-.067,-.145,-.295,.169,-.090,.238,.016,-.099,.683,-.506,.115,-.352)*f15_4+
    mat4(.357,-.316,.138,-.416,.247,-.538,-.031,-.268,-.112,.342,-.114,.262,-.818,.177,.047,.516)*f15_5+
    mat4(-.027,.207,.705,-.331,-.259,.237,.292,-.392,.094,-.723,.097,-.182,-.574,.602,-.259,.334)*f15_6+
    mat4(-.544,-.004,-.099,-.086,-.364,-.009,-.033,-.167,.197,-.719,-.944,.973,-.024,.107,-.010,-.168)*f15_7+
    vec4(.268,.550,.669,-.606))/4.0+f15_3;
vec4 f16_4=sin(mat4(-.220,-.261,-.490,-.666,.623,.280,.846,.050,.142,.111,.194,.565,.197,.040,.290,.145)*f15_0+
    mat4(.065,-.121,.144,-.004,.047,-.128,.255,.693,-.073,-.124,-.354,.536,-.018,.295,.039,.208)*f15_1+
    mat4(.769,.868,1.411,.202,-.696,-.635,-1.071,-.127,.470,.494,.772,.108,.101,.198,.275,-.859)*f15_2+
    mat4(.087,.227,.072,.411,-.045,.035,-.035,-.125,-.106,.224,-.143,.132,.028,-.092,.094,-.023)*f15_3+
    mat4(-.604,-.593,-1.150,-.414,-.691,-.775,-1.299,-.819,-.708,-.795,-1.242,-.060,-.042,.004,-.039,-.604)*f15_4+
    mat4(-.043,.035,-.078,-.498,-.136,.106,.077,-.280,-.015,-.002,-.020,.438,.282,.080,.090,.039)*f15_5+
    mat4(-.371,.153,-.251,.111,-.243,.039,-.493,.092,-.057,.252,.114,-.680,.013,-.230,-.312,.847)*f15_6+
    mat4(-.432,-.350,-.683,-.711,.137,-.161,.028,.398,.543,.397,.822,.052,.161,.032,.060,.208)*f15_7+
    vec4(.455,.156,.283,-1.422))/4.0+f15_4;
vec4 f16_5=sin(mat4(-.629,-.986,-.716,-.366,.555,-.887,-.465,-.197,-.645,-.025,-.498,.340,-.096,.486,.222,.099)*f15_0+
    mat4(.572,-.085,-.108,-.010,-.226,-.135,-.166,.652,.346,.202,.223,.527,.301,.346,.256,.172)*f15_1+
    mat4(-.270,.837,.236,.576,.158,-.171,.249,.147,.134,.181,-.280,-.247,-.304,.255,.154,-.746)*f15_2+
    mat4(.135,.534,.505,-.225,-.618,-.559,-.612,.234,.428,.450,.383,-.005,.340,-.511,-.659,-.211)*f15_3+
    mat4(.460,-.048,.119,.140,-.102,-.959,-.799,-.490,-.297,.008,-.051,-.314,-.127,.070,.456,-.535)*f15_4+
    mat4(-.091,.048,.133,-.531,-.486,.190,-.004,-.027,-.391,-.030,-.066,.280,-.719,-.317,-.941,.024)*f15_5+
    mat4(-.589,.883,.434,.255,-.680,.683,.322,.226,.379,.354,.247,-.240,-.069,-.205,-.399,.631)*f15_6+
    mat4(.106,.100,.160,-.025,-.141,-.004,-.577,.195,.276,-1.161,-.818,-.508,.527,.414,.463,.171)*f15_7+
    vec4(-.451,-.010,-1.381,.841))/4.0+f15_5;
vec4 f16_6=sin(mat4(.080,.564,-.375,-.390,1.212,.035,-.208,-.155,-.532,.435,.051,-.028,-.009,-.239,.359,.100)*f15_0+
    mat4(.557,-.204,-.038,.094,-.025,.044,-.259,.592,.207,-.146,-.229,.732,.126,-.171,.332,-.006)*f15_1+
    mat4(-.943,.009,.272,-.407,.275,-.323,-.314,.283,.285,.024,.574,-.407,.059,-.213,.308,-1.074)*f15_2+
    mat4(-.220,-.343,-.179,-.256,.075,.267,-.473,.152,-.486,-.001,.426,.054,.206,.361,-.404,.053)*f15_3+
    mat4(.054,-.344,-.130,.524,.374,.161,-.661,-.156,-.301,.133,-.186,.135,-.019,-.175,.379,-.616)*f15_4+
    mat4(-.026,-.063,.282,-.281,-.261,.029,.165,-.487,-.164,.089,-.151,.243,-.044,.204,-.402,.354)*f15_5+
    mat4(-1.155,.369,.034,-.131,-1.079,.260,.162,-.020,.014,-.118,.234,-.560,.169,.211,-.102,.869)*f15_6+
    mat4(-.310,-.079,-.261,-.047,.229,.042,-.240,.244,1.196,-.124,-.059,-.224,.153,-.213,.192,.086)*f15_7+
    vec4(-.808,.164,1.107,1.200))/4.0+f15_6;
vec4 f16_7=sin(mat4(-.516,.600,-.117,-.284,-.718,.788,.752,-.083,-.450,-.469,-.162,-.378,.071,-.346,-.020,-.752)*f15_0+
    mat4(-.165,.343,.449,.439,-.290,.005,-.032,-.227,.095,.012,-.016,.297,.123,-.045,.149,-.541)*f15_1+
    mat4(-.176,-.868,-.249,-.819,.567,.135,-.175,.944,-.343,-.343,.296,-.621,.097,-.494,.057,-.197)*f15_2+
    mat4(.358,-.303,.018,.256,-.150,.493,.021,-.291,.193,-.240,-.222,-.319,-.383,.621,.239,-.351)*f15_3+
    mat4(.488,.130,-.289,.118,.127,.584,-.184,.071,.456,.255,-.367,.589,.182,-.284,-.086,.184)*f15_4+
    mat4(.246,.105,-.007,.299,-.036,-.553,-.188,.245,.104,-.134,-.154,-.480,-.343,.611,-.098,-.413)*f15_5+
    mat4(-.069,-1.227,-.590,-.243,-.153,-.440,-.703,-.541,.104,-.450,.221,-.016,-.296,.298,.021,-.304)*f15_6+
    mat4(.421,.190,-.284,-.159,-.116,.025,.135,.064,-.342,.719,1.067,-.008,.153,-.155,.039,.037)*f15_7+
    vec4(.558,-1.395,2.644,.805))/4.0+f15_7;
float f_0=dot(f16_0,vec4(.024,.011,.043,.002))+
    dot(f16_1,vec4(-.014,.044,.011,-.015))+
    dot(f16_2,vec4(.043,-.039,-.002,-.040))+
    dot(f16_3,vec4(-.024,.042,-.012,.013))+
    dot(f16_4,vec4(-.037,-.024,-.031,-.037))+
    dot(f16_5,vec4(-.030,-.007,.018,.055))+
    dot(f16_6,vec4(.007,.016,-.027,.037))+
    dot(f16_7,vec4(-.023,.014,.001,-.016))+
    0.492;
float f_1=dot(f16_0,vec4(.037,-.028,.032,-.009))+
    dot(f16_1,vec4(-.019,.038,.021,-.019))+
    dot(f16_2,vec4(-.014,.012,-.036,-.048))+
    dot(f16_3,vec4(-.028,.043,-.008,.007))+
    dot(f16_4,vec4(.015,.026,.024,-.034))+
    dot(f16_5,vec4(-.023,-.009,.020,.048))+
    dot(f16_6,vec4(.018,.036,-.035,.044))+
    dot(f16_7,vec4(.006,.013,-.039,-.017))+
    0.490;
float f_2=dot(f16_0,vec4(.030,.038,.008,-.011))+
    dot(f16_1,vec4(.017,.039,.025,-.012))+
    dot(f16_2,vec4(-.046,.011,-.016,-.042))+
    dot(f16_3,vec4(-.027,.042,-.029,.021))+
    dot(f16_4,vec4(.005,.022,.000,-.039))+
    dot(f16_5,vec4(-.018,-.024,.011,.045))+
    dot(f16_6,vec4(-.040,-.022,-.029,.050))+
    dot(f16_7,vec4(-.014,.025,.043,-.008))+
    0.455;
    
#else
//smaller model 20x20 loss ~= .003
vec4 f0_0=sin(ft_0*vec4(-.245,.460,-.026,.081)+ft_1*vec4(-.735,-.205,.014,-.672)+ft_2*vec4(-2.731,-.842,.948,-1.421)+ft_3*vec4(.032,1.867,1.867,1.984)+ft_4*vec4(-.400,-1.653,1.133,.690)+vec4(-3.336,-2.074,1.182,.243));
vec4 f0_1=sin(ft_0*vec4(.031,.498,.181,.069)+ft_1*vec4(.723,-.433,-.316,.553)+ft_2*vec4(2.755,-.477,-.485,-.730)+ft_3*vec4(.297,-.167,-.138,.404)+ft_4*vec4(-1.609,-2.036,-1.087,1.547)+vec4(2.389,-3.663,-2.320,1.435));
vec4 f0_2=sin(ft_0*vec4(-.183,.026,-.071,.483)+ft_1*vec4(-.329,.575,-.254,.317)+ft_2*vec4(1.427,2.353,-2.967,1.402)+ft_3*vec4(-.862,1.058,.255,.472)+ft_4*vec4(-.753,-.645,.760,2.185)+vec4(-.330,3.068,.328,4.043));
vec4 f0_3=sin(ft_0*vec4(-.059,-.688,-.410,-.020)+ft_1*vec4(.082,.301,-.234,.366)+ft_2*vec4(1.342,.982,1.360,-.662)+ft_3*vec4(-.361,-2.354,-1.993,-.221)+ft_4*vec4(1.944,.872,1.873,-2.600)+vec4(4.379,.470,3.367,-4.171));
vec4 f0_4=sin(ft_0*vec4(-.098,.616,.112,-.183)+ft_1*vec4(.205,.034,-.279,-.178)+ft_2*vec4(-.636,-.586,.074,-1.941)+ft_3*vec4(-.297,2.140,-.113,-1.083)+ft_4*vec4(2.459,.695,2.045,-.946)+vec4(2.742,-3.864,2.056,3.527));
vec4 f1_0=sin(mat4(.467,-.243,-.046,-.424,.580,.033,-.151,.182,-.279,-.280,-.326,-.216,-.328,-.287,-.465,-.222)*f0_0+
    mat4(.732,-1.250,-1.248,-1.001,.055,-.261,-.019,-.307,.188,.489,.144,-.328,.126,-.524,-.676,-.372)*f0_1+
    mat4(-.083,.073,.447,.057,-.265,.047,-.146,-.569,.924,-.354,-.987,-.140,.210,-.532,-.011,.318)*f0_2+
    mat4(.234,.129,.277,.300,-.111,.067,.068,.345,.076,-.271,-.446,-.048,.046,.064,.275,-.294)*f0_3+
    mat4(-.564,.053,.711,.304,-.289,.523,-.109,.231,-.706,-.298,.573,.205,.213,-.442,.276,.258)*f0_4+
    vec4(.496,-.480,-.841,-1.592))/1.0+f0_0;
vec4 f1_1=sin(mat4(-.242,.241,.101,-.273,.239,.186,.061,.289,.040,.011,-.729,-.163,-.162,.298,.205,-.617)*f0_0+
    mat4(-1.512,-.085,1.017,-.072,-.186,-.547,-.150,-.107,.030,.060,-.136,-.407,-.628,-.028,-.090,-.485)*f0_1+
    mat4(-.032,.068,.293,.218,.062,.020,.276,.494,.137,.153,.442,-.502,-.369,-.163,-.335,-.496)*f0_2+
    mat4(-.235,.283,-.231,.340,.046,.019,.047,.624,.029,.048,.011,.497,.214,.595,.349,-.242)*f0_3+
    mat4(.856,.293,-.242,-.203,-.231,.033,-.395,-.176,.291,-.140,-.087,.102,.040,-.734,-.466,-.178)*f0_4+
    vec4(-1.282,-.556,-.420,-.908))/1.0+f0_1;
vec4 f1_2=sin(mat4(-.089,-.030,.090,-.198,-.253,-.067,.093,-.284,-.183,.192,-.157,-.545,-.356,-.062,.249,-.500)*f0_0+
    mat4(-.666,.391,.294,-.548,.275,.102,-.026,.138,-.191,-.448,.090,-.571,-.249,-.258,-.094,.054)*f0_1+
    mat4(.212,.246,.219,-.363,.821,-.735,-.109,-.061,.099,.054,.560,.155,-.050,.230,.325,-.227)*f0_2+
    mat4(-.322,.199,.531,.053,-.152,-.818,-.034,-.853,.177,.441,-.224,.672,.443,-.008,-.424,.024)*f0_3+
    mat4(-.385,.587,-.116,.042,-.611,.007,.024,.590,.487,-.178,-.051,.299,-.219,.179,.302,-.749)*f0_4+
    vec4(.115,-1.710,-.580,-1.529))/1.0+f0_2;
vec4 f1_3=sin(mat4(-.323,-.096,-.666,.460,-.668,-.575,-.477,.443,-.234,-.395,-.060,.124,.001,.627,.258,-.325)*f0_0+
    mat4(-.823,-.826,-.209,.227,.160,.008,.337,-.001,.295,-.142,-.803,.099,-.211,.024,-.281,.080)*f0_1+
    mat4(.010,-.238,-.360,.257,-.317,-.199,.011,-.367,-1.297,-.396,.369,-1.121,.135,.705,.446,-.190)*f0_2+
    mat4(-.024,.211,-.076,.299,-.093,.625,-.462,-.420,-.289,.229,-.234,-.443,-.122,-.107,.025,.001)*f0_3+
    mat4(.513,.315,.533,-.389,-.635,.635,-.354,.733,.221,.230,.027,-.500,.407,.431,-.691,.536)*f0_4+
    vec4(-.787,-1.006,-1.054,.408))/1.0+f0_3;
vec4 f1_4=sin(mat4(.616,.312,-.044,-.516,.441,.112,-.230,-.934,-.212,-.263,-.420,.032,-.190,.170,-.220,.835)*f0_0+
    mat4(-.026,-.125,.700,.129,-.014,-.141,.109,.542,-.414,-.063,-.211,.049,.314,.262,.048,-.180)*f0_1+
    mat4(-.464,-.092,-.316,.019,.698,.308,-.005,-.887,.891,-.001,.994,.312,.405,-.777,.098,.485)*f0_2+
    mat4(-.132,-.394,-.135,-.241,-.182,.509,-.691,-.033,.043,-.185,.609,-.157,-.253,.169,-.078,.017)*f0_3+
    mat4(.101,-.130,.298,-.001,.364,.217,-.150,-.603,-.098,.117,.372,-.098,-.836,-.084,-.383,.498)*f0_4+
    vec4(-.776,.816,-.911,1.328))/1.0+f0_4;
vec4 f2_0=sin(mat4(.322,.724,.383,.448,-.026,-.468,-.035,.213,-.353,.247,.530,-.126,.752,.384,-.139,-.440)*f1_0+
    mat4(.681,-.416,.046,.213,.128,-.133,-.469,-.622,.097,-.072,.149,.003,.216,-.218,-.458,-.708)*f1_1+
    mat4(-.176,-.222,-.031,.061,-.313,-.354,.086,-.704,.158,-.238,.101,-.079,.214,.146,-.301,.477)*f1_2+
    mat4(.103,-.278,-.118,-.216,-.304,.265,.188,.129,.162,-.124,.411,.314,-.344,.385,-.075,-.166)*f1_3+
    mat4(-.126,-.712,.156,-.023,-.148,-.566,.106,.403,-.060,-.194,.464,-.296,-.555,.192,-.318,.345)*f1_4+
    vec4(.032,.913,.059,.724))/1.4+f1_0;
vec4 f2_1=sin(mat4(-.099,-.386,.345,-.729,.031,.179,-.325,.342,-.123,.376,-.402,-.244,-.245,-.059,.366,.445)*f1_0+
    mat4(-.311,-.454,.271,-.493,-.074,.242,.205,.011,-.303,.273,.398,.291,.272,-.009,.450,.093)*f1_1+
    mat4(.189,-.451,-.408,-.006,-.774,.026,-.707,-.049,-.707,.305,.064,.527,.008,.422,.072,.142)*f1_2+
    mat4(.252,-.567,.071,.168,-.346,.119,-.097,.002,.274,-.542,-.045,-.162,.152,-.344,.443,.019)*f1_3+
    mat4(-.034,-.556,.262,-.178,.257,.628,-.407,-.179,-.603,-.021,-.166,.175,.263,.513,-.544,.466)*f1_4+
    vec4(.551,.439,.009,-1.130))/1.4+f1_1;
vec4 f2_2=sin(mat4(-.246,-.134,.060,-.052,.057,.257,.345,-.201,-.131,.797,.012,.324,.605,-.141,-.495,.066)*f1_0+
    mat4(.186,-.235,.122,-.205,.083,-.007,-.142,.165,-.123,-.054,.101,.227,-.123,-.742,.044,.362)*f1_1+
    mat4(-.013,-.083,-.270,-.014,.324,.508,-.243,.014,.845,.241,.239,-.326,.465,-.027,.353,-.455)*f1_2+
    mat4(-.014,-.022,.641,-.452,-.091,.177,.155,.058,.139,.082,-.274,-.342,-.309,.042,.532,-.238)*f1_3+
    mat4(-.151,-.120,-.380,.118,.314,.577,.370,.271,.523,.114,-.028,-.398,.544,-.142,.135,.520)*f1_4+
    vec4(-.508,.146,-.250,-.027))/1.4+f1_2;
vec4 f2_3=sin(mat4(.179,.093,-.471,.136,-.562,.171,-.140,.120,.501,.428,.009,.179,.343,-.059,-.837,.470)*f1_0+
    mat4(-.336,.076,-.672,-.148,-.152,.038,.121,-.746,-.275,.585,-.463,-.465,.272,-.277,.461,.063)*f1_1+
    mat4(-.147,.262,-.119,.031,-.015,.401,-.472,.017,.368,-.578,-.710,.378,-.494,.269,.041,-.635)*f1_2+
    mat4(-.393,-.015,-.223,-.207,-.645,.827,-.038,-.567,-.439,-.356,-.313,.256,.050,.360,.138,.169)*f1_3+
    mat4(-.144,-.251,-.393,.263,-.379,-.081,-.034,-.204,-.162,-.245,-.544,.244,-.221,.203,.367,-.801)*f1_4+
    vec4(.463,-.324,.516,-.096))/1.4+f1_3;
vec4 f2_4=sin(mat4(.500,.014,-.158,-.287,-.347,-.133,.018,-.072,.201,1.037,-.084,-.082,.350,.175,-.033,-.027)*f1_0+
    mat4(.106,.430,-.040,-.237,-.282,.022,-.485,.131,.102,.163,-.198,.146,.183,-.690,.066,-.298)*f1_1+
    mat4(-.345,-.219,.027,.196,-.477,.004,-.354,.305,-.532,-.531,.225,-.143,-.048,.656,.377,.033)*f1_2+
    mat4(-1.028,-.067,-.744,-.188,-.387,.592,-.406,.006,.325,-.109,.254,.035,-.064,-.100,-.268,.072)*f1_3+
    mat4(-.648,-.013,.053,.522,.489,-.051,-.054,-.488,-.389,-.103,.490,.195,.146,.652,.423,-.589)*f1_4+
    vec4(1.491,.333,-.119,-.762))/1.4+f1_4;
vec4 f3_0=sin(mat4(-.730,.462,-.020,.261,-.127,.052,-.228,.089,.221,-.015,-.375,.405,.314,.361,.070,.463)*f2_0+
    mat4(-.861,.115,-.037,.293,.078,-.607,-.276,.165,-.401,-.776,-.167,.111,.026,-.457,.244,.025)*f2_1+
    mat4(.292,.788,-.477,.594,.444,.679,-.321,-.182,.345,-.542,-.262,.265,-.137,-.255,.122,.170)*f2_2+
    mat4(.924,.111,-.183,.238,-.081,.088,-.123,.260,-.041,.577,.021,-.699,.199,-.276,.194,.246)*f2_3+
    mat4(.521,-.426,-.194,.079,-.256,-.293,.154,-.656,.406,-.406,-.801,-.220,-.101,-.718,.012,.016)*f2_4+
    vec4(-.834,.661,.560,-.089))/1.7+f2_0;
vec4 f3_1=sin(mat4(.251,-.140,.522,-.096,-.023,-.506,.333,.054,-.588,.147,.702,.136,-.047,-.042,.293,-.215)*f2_0+
    mat4(.757,.419,.794,-.277,-.269,-.102,-.128,-.152,-.197,-.312,.313,.096,.524,-.078,-.344,.220)*f2_1+
    mat4(-.016,.338,.018,1.024,-.139,-.254,.108,-.017,-.390,-.190,.366,.141,-.122,.132,.126,.646)*f2_2+
    mat4(.198,.348,.057,-.369,.036,.451,-.039,.324,.021,-.363,-.027,-.147,.019,.043,.499,-.307)*f2_3+
    mat4(.060,.147,.295,.281,-.175,.035,-.226,-.709,-.205,-.175,.168,-.233,.066,-.347,-.005,.267)*f2_4+
    vec4(-.058,-.139,-.366,-.461))/1.7+f2_1;
vec4 f3_2=sin(mat4(-.439,-.076,-.064,-.285,-.070,.115,-.326,-.410,-.010,-.087,-.716,.168,-.092,.047,-.284,.127)*f2_0+
    mat4(-.085,.200,.097,.045,-.179,-.607,.053,-.122,.198,.194,.232,-.079,-.020,.036,.147,.196)*f2_1+
    mat4(.097,.349,-.069,.050,.058,.174,-.112,.103,-.433,.340,.249,-.491,-.188,-.123,.553,-.257)*f2_2+
    mat4(.441,.143,.475,-.280,-.182,.542,.491,-.555,.196,-.454,.563,.433,.142,.190,-.310,.186)*f2_3+
    mat4(.253,-.011,-.366,-.167,.186,.230,.050,.041,.082,-.092,.726,.456,-.813,.642,.019,-.643)*f2_4+
    vec4(.038,.135,-.535,.020))/1.7+f2_2;
vec4 f3_3=sin(mat4(-.709,-.123,.478,.249,-.217,-.458,.079,-.437,-.260,-.026,.209,-.139,.185,.629,-.156,.522)*f2_0+
    mat4(-.666,-.138,.046,.059,.004,.277,-.005,.205,.037,.434,.130,.199,.034,-.023,-.304,.108)*f2_1+
    mat4(.243,-.169,.068,-.156,.344,-.674,-.436,.380,-.118,-.263,-.599,-.165,-.179,.198,.275,.467)*f2_2+
    mat4(-.089,.162,-.338,.032,-.124,-.105,-.162,.569,.483,-.197,-.163,-.511,-.304,.087,-.292,.140)*f2_3+
    mat4(.022,-.367,-.409,-.306,-.530,-.417,-.212,-.004,.271,.039,-.375,-.397,.205,-.337,-.206,.348)*f2_4+
    vec4(-.693,.290,.172,.223))/1.7+f2_3;
vec4 f3_4=sin(mat4(-.275,.016,-.216,-.230,-.002,.099,.148,-.397,-.282,.236,.049,-.484,-.234,.463,-.211,.056)*f2_0+
    mat4(-.078,-.597,.367,-.085,.459,.179,.562,.170,-.261,.256,-.242,.611,.326,-.041,-.166,-.055)*f2_1+
    mat4(-.033,-.259,-.168,-.453,.333,.376,-.233,-.464,.783,.445,.542,.141,.356,-.077,.174,.188)*f2_2+
    mat4(.083,-.113,-.326,.035,-.022,-.092,-.486,.115,.268,.413,.514,-.263,.213,-.113,-.003,-.039)*f2_3+
    mat4(.057,.113,.135,-.478,.131,-.124,.102,-.060,.088,.252,.691,-.098,-.302,.406,.280,.505)*f2_4+
    vec4(-.537,.563,.064,.210))/1.7+f2_4;
vec4 f4_0=sin(mat4(-.331,-.049,.632,-.059,.328,.749,-.064,.130,.205,.180,.094,-.002,-.176,-.299,-.192,-.355)*f3_0+
    mat4(.706,-.038,.411,.459,.255,-.376,-.418,-.448,.165,-.260,-.620,.194,.117,.036,.190,.548)*f3_1+
    mat4(-.376,-.579,-.078,-.234,-.107,.475,-.333,.049,-.168,-.137,-.584,.319,-.091,.336,.387,.448)*f3_2+
    mat4(-.238,.535,.020,.306,-.213,.392,.121,.411,.286,-.117,-.051,-.091,-.294,.168,.251,.224)*f3_3+
    mat4(.173,.143,-.465,.601,-.113,.648,-.240,-.544,-.122,.158,-.304,.808,-.383,-.029,.111,.163)*f3_4+
    vec4(.567,-.088,.378,-1.460))/2.0+f3_0;
vec4 f4_1=sin(mat4(.797,-.424,-.246,.352,-.263,-.025,.047,.352,.543,.304,.533,.274,.116,-.032,.055,-.189)*f3_0+
    mat4(.059,-.138,.301,.416,.286,-.497,-.233,.029,-.121,.151,-.124,.737,-.331,.271,-.081,.481)*f3_1+
    mat4(-.214,-.130,.383,-.177,-.313,-.518,.275,-.240,-.271,.066,.250,.281,.588,.050,-.265,.012)*f3_2+
    mat4(-.549,-.289,.225,.252,.316,.559,.691,-.418,-.288,-.626,-.513,.136,.120,.388,-.384,.527)*f3_3+
    mat4(-.784,-.206,-.392,.128,.351,.404,.281,-.253,-.460,.653,-.553,.502,.491,.034,-.249,-.575)*f3_4+
    vec4(1.297,.555,.387,-.266))/2.0+f3_1;
vec4 f4_2=sin(mat4(-.548,.132,-.925,.214,-.202,.360,.261,.059,.659,-.381,.157,.315,.137,.114,-.312,-.001)*f3_0+
    mat4(-.956,.403,-.779,.609,.088,.037,.149,-.590,-.187,.277,-.037,-.335,-.220,.019,.112,-.073)*f3_1+
    mat4(-.063,.213,-.351,-.631,-.257,.667,.073,-.132,.052,.637,-.079,-.283,.245,.318,-.076,-.113)*f3_2+
    mat4(-.099,.049,-.219,.244,.112,.592,.015,-.105,-.162,-.090,-.361,.075,-.065,-.107,-.024,.884)*f3_3+
    mat4(.101,-.013,-.015,-.529,.290,-.195,.635,.330,.199,.220,-.035,-.246,.075,-.374,-.328,-.119)*f3_4+
    vec4(-.012,-.059,.617,.166))/2.0+f3_2;
vec4 f4_3=sin(mat4(.126,-.344,-.083,.181,.332,.064,-.151,-.213,-.339,-.097,.394,-.034,.052,-.225,.124,.451)*f3_0+
    mat4(.452,-.056,-.442,.208,.556,-.341,-.328,-.441,.451,.329,-.123,.249,.032,-.544,.031,-.578)*f3_1+
    mat4(-.225,.073,-.353,-.208,.116,.345,.008,-.080,.622,-.080,-.368,.175,.364,.642,-.047,-.058)*f3_2+
    mat4(.825,-.283,-.045,-.081,-.069,.477,.116,.632,.181,-.400,.062,-.319,-.191,-.337,.231,-.286)*f3_3+
    mat4(.185,.288,-.508,.047,.025,.270,.663,-.254,-.082,-.372,-.702,-.225,.069,.974,-.221,.217)*f3_4+
    vec4(-.206,-.244,-.282,.023))/2.0+f3_3;
vec4 f4_4=sin(mat4(.686,-.228,-.124,.179,-.007,-.109,-.026,.250,.149,-.085,-.510,.554,.405,.451,-.410,.229)*f3_0+
    mat4(.688,.305,-.047,-.313,-.532,-.109,.406,-.356,-.814,.241,-.699,.027,-.347,-.025,-.686,.005)*f3_1+
    mat4(-.256,-.115,-.123,-.035,-.398,-.229,.434,.036,-.505,-.525,.058,-.105,-.477,-.273,.188,-.725)*f3_2+
    mat4(-.384,.293,.154,-.474,-.103,-.310,.046,-.181,-.157,-.416,.622,.041,.067,-.267,-.174,.167)*f3_3+
    mat4(-.568,.237,.051,-.448,.451,-.332,.111,.305,-.018,-.230,.095,-.162,.492,-.049,.600,-.172)*f3_4+
    vec4(.402,-.192,-.261,.650))/2.0+f3_4;
vec4 f5_0=sin(mat4(.269,-.283,.248,-.495,.406,.842,-.020,-.033,.452,.363,.209,-.401,-.015,-.482,-.317,-.532)*f4_0+
    mat4(-.270,.079,.139,-.693,.438,.290,.549,-.215,.224,-.083,.126,-.416,-.234,-.247,.265,-.016)*f4_1+
    mat4(.048,-.188,-.820,-.137,.536,.314,.003,-.227,-.681,-.097,.225,.167,.054,.145,.021,-.220)*f4_2+
    mat4(-.017,.096,-.337,.053,-.519,.400,-.307,-.063,.285,-.393,-.365,-.233,.489,-.247,.462,.674)*f4_3+
    mat4(.051,-.072,-.029,.163,.312,.193,-.036,-.790,.061,.266,-.220,-.282,-.653,.599,.063,.189)*f4_4+
    vec4(.125,.164,.725,-.528))/2.2+f4_0;
vec4 f5_1=sin(mat4(.296,-.605,.064,-.005,.508,.018,-.332,-.295,-.265,.046,-.162,-.127,-.205,-.124,.187,.279)*f4_0+
    mat4(-.343,-.385,-.596,-.715,.099,.146,-.051,-.665,.798,-.091,.141,-.172,.291,.631,-.249,-.359)*f4_1+
    mat4(-.081,.386,-.412,-.292,.017,.092,-.341,.346,.135,-.452,.138,-.271,-.251,-.894,.795,.110)*f4_2+
    mat4(.226,.008,-.219,-.406,-.411,-.395,.045,.672,.253,.012,.027,-.024,-.252,-.059,-.497,-.427)*f4_3+
    mat4(.219,.397,-.147,-.789,.063,-.378,-.327,.349,-.310,.403,.285,-.794,-.116,-.308,.686,.461)*f4_4+
    vec4(-.406,-.897,-.222,.596))/2.2+f4_1;
vec4 f5_2=sin(mat4(-.189,-.284,-.311,.685,.326,.255,-.018,.281,.432,.708,-.195,.035,-.079,.208,.255,.034)*f4_0+
    mat4(-.293,-.597,-.451,.115,.504,.358,-.514,.291,.110,.066,-.102,.086,-.530,.080,-.131,.168)*f4_1+
    mat4(.476,.359,.499,-.203,.079,.370,-.050,-.066,-.124,-.335,.007,.019,.486,.055,-.002,.369)*f4_2+
    mat4(.045,.776,.102,-.009,-.624,.135,.126,.087,.165,-.331,-.327,-.262,.022,.161,-.372,-.143)*f4_3+
    mat4(.172,-.129,.441,.033,.028,.092,-.011,.552,-.001,-.075,-.156,.326,.059,.295,-.524,.136)*f4_4+
    vec4(-.306,-.089,-.216,.194))/2.2+f4_2;
vec4 f5_3=sin(mat4(.012,.423,.199,-.040,-.021,-.096,.317,-.277,.145,-.272,.427,-.054,-.712,.378,.283,.341)*f4_0+
    mat4(-.323,.617,.296,-.096,-.110,.259,-.216,.535,.065,.013,-.175,-.015,.100,-.165,-.358,-.356)*f4_1+
    mat4(-.604,-.095,-.180,-.198,.231,-.141,-.185,-.448,.095,.538,.331,.853,.160,.380,.277,.758)*f4_2+
    mat4(-.280,.320,-.014,.501,-.310,.848,.157,-.134,.176,-.226,-.492,-.430,.171,.045,.604,.003)*f4_3+
    mat4(-.476,-.109,-.519,-.232,.646,-.242,-.289,-.379,.077,.076,.105,-.318,-.138,-.087,-.029,.483)*f4_4+
    vec4(.459,.286,.403,.331))/2.2+f4_3;
vec4 f5_4=sin(mat4(-.344,.214,-.033,.035,.050,-.462,-.367,-.499,-.164,.002,-.306,-.070,.026,.467,.234,.624)*f4_0+
    mat4(-.567,-.101,-.579,-.202,-.282,.150,.232,-.067,-.490,.304,.424,.364,-.210,.520,-.098,.001)*f4_1+
    mat4(.220,.018,-.279,-.093,.602,-.305,-.078,-.178,-.016,-.047,.542,.422,-.054,-.540,.382,-.318)*f4_2+
    mat4(.270,.199,-.169,-.414,.045,-.446,.213,.278,-.467,-.192,-.050,.148,.175,.170,.015,-.257)*f4_3+
    mat4(.414,.050,-.470,.013,.347,.057,.242,.210,-.041,-.088,-1.008,-.239,.171,-.719,.361,-.062)*f4_4+
    vec4(-.110,.051,.164,.145))/2.2+f4_4;
vec4 f6_0=sin(mat4(.263,.602,.136,.281,-.202,-.571,.163,.396,-.274,-.180,-.440,.301,-.768,.475,-.526,.557)*f5_0+
    mat4(.380,.255,-.514,-.008,-.299,.443,-.345,-.267,-.062,.118,-.521,.377,-.235,-.187,-.123,.259)*f5_1+
    mat4(-.598,-.050,.254,-.101,-.126,-.579,-.264,.083,-.350,.076,-.329,-.487,.095,-.417,-.395,-.240)*f5_2+
    mat4(-.047,-.103,-.518,.027,.073,-.273,-.636,-.548,.495,-.142,-.286,.251,-.323,.367,.077,-.183)*f5_3+
    mat4(-.054,-.152,.268,.171,.168,.941,.073,.159,.333,-.497,.577,.084,.125,-.312,-.159,.414)*f5_4+
    vec4(-.696,.781,-.696,.306))/2.4+f5_0;
vec4 f6_1=sin(mat4(.145,.333,.319,-.292,.253,.027,.348,-.104,.093,-.657,-.059,-.174,-.007,-.031,-.122,-.001)*f5_0+
    mat4(.496,-.144,.413,-.269,.990,.183,.466,.316,.550,-.542,-.074,-.493,.467,.146,-.696,-.490)*f5_1+
    mat4(-.284,-.346,-.681,.091,.223,-.341,-.212,-.025,.570,-.496,.889,-.430,.105,.191,.417,.101)*f5_2+
    mat4(.319,-.119,.076,-.475,-.377,.204,.091,-.585,.104,.352,-.293,-.057,.534,-.041,.005,.121)*f5_3+
    mat4(-.162,.206,.160,.093,.011,-.555,-.357,-.762,.140,.090,-.057,-.154,-.276,.613,.670,.646)*f5_4+
    vec4(-.104,.576,1.374,.286))/2.4+f5_1;
vec4 f6_2=sin(mat4(.178,.093,.676,-.069,.487,.233,-.058,-.397,-.501,-.235,-.435,-.191,.119,-.435,-.235,.207)*f5_0+
    mat4(.419,-.108,-.039,-.124,.225,.145,.286,.278,-.094,.151,-.535,.326,.615,.228,.089,-.015)*f5_1+
    mat4(-.222,.199,-.091,-.400,.125,-.546,-.552,-.118,-.242,-.099,-.382,.170,-.238,-.315,.312,-.053)*f5_2+
    mat4(.840,-.405,-.502,.280,.148,-.145,-.501,.066,.431,.147,.499,-.501,-.197,-.036,.359,-.329)*f5_3+
    mat4(.033,.341,-.479,.552,.179,-.056,-.479,.038,.225,.277,.362,.172,.126,-.069,.235,.262)*f5_4+
    vec4(.181,-.097,.579,.120))/2.4+f5_2;
vec4 f6_3=sin(mat4(-.385,.127,-.052,.230,-.366,-.357,-.157,.117,-.042,-.339,-.195,.207,.154,.383,-.459,.366)*f5_0+
    mat4(-.148,.143,.657,-.121,.680,-.282,.079,.174,.477,.284,-.353,-.036,.227,-.334,-.481,.216)*f5_1+
    mat4(.405,-.095,-.218,.614,-.339,-.457,-.276,.184,.386,-.237,.001,.132,.087,.109,.308,-.190)*f5_2+
    mat4(.017,-.036,.312,-.130,.150,-.695,.248,-.342,.295,.497,-.171,-.518,.344,-.296,.167,.314)*f5_3+
    mat4(.121,-.378,.171,.270,-.413,.368,-.230,-.056,-.202,-.485,.247,.535,.053,-.031,.469,-.042)*f5_4+
    vec4(-.718,.664,-.746,.308))/2.4+f5_3;
vec4 f6_4=sin(mat4(.614,-.242,-.240,-.253,-.047,-.283,.349,-.658,.442,-.417,-.312,-.448,-.514,-.405,-.525,-.315)*f5_0+
    mat4(.073,.020,-.388,.383,-.458,-.347,-.352,-.461,.587,-.576,-.374,-.150,.448,.204,-.312,.397)*f5_1+
    mat4(-.736,.219,.563,-.145,.027,.090,-.073,-.444,.172,.318,.212,.008,.264,.006,-.028,-.637)*f5_2+
    mat4(-.794,-.150,.208,-.266,-.474,.547,.503,-.201,.249,.343,-.175,.128,.392,.024,.065,-.245)*f5_3+
    mat4(-.572,.365,.117,-.040,.273,.152,.542,.782,.055,.640,-.067,.110,.144,.143,.214,-.595)*f5_4+
    vec4(1.077,.315,-.219,-.288))/2.4+f5_4;
vec4 f7_0=sin(mat4(.191,-.396,-.645,-.591,.272,-.803,-.253,-.530,-.199,-.419,-.902,-.654,-.391,.292,-.265,-.853)*f6_0+
    mat4(.361,-.090,-.539,-.271,-.143,.068,.128,.296,.191,.310,-.127,-.154,.133,.458,.379,-.092)*f6_1+
    mat4(-.096,-.002,-.192,.355,.251,-.148,-.119,.007,-.163,.374,.731,.474,-.458,-1.027,-.369,.140)*f6_2+
    mat4(-.810,.011,.043,.096,-.266,-.443,.005,.396,-.302,-.253,.109,-.080,.255,-.253,.053,.243)*f6_3+
    mat4(-.026,.176,.283,.733,.252,-.206,-.251,.179,-.671,.005,.105,-.114,-.682,-.636,-.109,-.122)*f6_4+
    vec4(.031,-.643,-.045,-.667))/2.6+f6_0;
vec4 f7_1=sin(mat4(-.242,-.040,.057,.098,.261,.634,.190,-.423,.044,.541,.357,.322,.415,-.291,-.161,.581)*f6_0+
    mat4(-.488,.141,.201,.664,-.416,-.437,.072,.051,.040,.410,-.055,.337,.008,.326,-.023,.292)*f6_1+
    mat4(.399,-.037,-.198,.430,.051,.576,-.058,-.050,-.332,-.407,-.538,.314,-.272,.109,.250,.127)*f6_2+
    mat4(.483,-.529,-.407,-.689,-.301,.362,-.068,.167,-.107,.125,-.106,.421,-.104,-.103,.725,.620)*f6_3+
    mat4(.605,-.946,-.293,.108,-.599,.097,-.450,.056,.584,-.080,-.484,.060,.189,.221,.086,-.206)*f6_4+
    vec4(-.755,-.076,1.138,-.201))/2.6+f6_1;
vec4 f7_2=sin(mat4(-.117,-.748,.058,-1.055,.422,.153,-.241,.132,-.107,.118,-.544,-.602,-.096,-.385,.041,-.343)*f6_0+
    mat4(.695,-.083,.360,-.708,.258,-.055,.213,.028,-.713,.325,.375,-.228,.251,.545,.018,.126)*f6_1+
    mat4(-.187,.687,-.466,.038,.201,.299,.058,.018,-.153,.417,-.320,.338,-.123,-.066,.046,-.165)*f6_2+
    mat4(.766,.333,.306,.510,-.452,.036,.417,.141,.288,.816,.441,.441,.116,.142,-.284,-.026)*f6_3+
    mat4(.363,.019,.527,.112,-.413,-.089,.209,.299,.080,.236,.276,.042,.365,-.645,.542,-.083)*f6_4+
    vec4(.005,-.674,-.372,-.329))/2.6+f6_2;
vec4 f7_3=sin(mat4(.147,-.795,.403,.474,.289,-.067,.408,.433,.133,-.064,-.077,.071,.133,-.227,-.230,.479)*f6_0+
    mat4(.641,.090,-.617,.320,-.233,.526,-.491,-.429,-.159,.545,.366,.086,-.435,-.342,.142,-.062)*f6_1+
    mat4(.210,.052,.255,.243,-.088,.440,.419,-.359,-.448,-.043,-.179,.333,-.208,.565,-.284,-.239)*f6_2+
    mat4(-.420,-.137,-.185,.118,.173,.299,.266,.207,-.036,-.264,.289,-.270,.041,-.686,.071,-.246)*f6_3+
    mat4(.111,.284,-.131,.370,.364,.213,.005,-.462,-.199,.020,.327,.378,-.110,-.075,.411,-.080)*f6_4+
    vec4(-.229,-.242,.214,.024))/2.6+f6_3;
vec4 f7_4=sin(mat4(.127,.049,.046,-.277,.434,.166,.398,-.381,-.060,.041,.099,-.047,-.040,.728,.070,.160)*f6_0+
    mat4(.685,-.225,.155,-.094,.303,.194,.690,-.231,.144,-.263,.014,-.281,-.416,.118,.413,-.335)*f6_1+
    mat4(-.034,.139,-.219,.376,.172,-.039,-.291,-.109,.074,.313,.045,-.004,-.488,-.034,.209,.169)*f6_2+
    mat4(-.126,.459,-.315,.504,-.161,-.192,.043,-.004,.026,-.235,-.034,-.267,.297,.075,.153,-.522)*f6_3+
    mat4(.818,-.061,.060,.541,.509,-.228,-.625,-.218,-.232,.235,.487,.162,-.142,-.352,.026,-1.064)*f6_4+
    vec4(-.668,-.022,-.589,-.277))/2.6+f6_4;
vec4 f8_0=sin(mat4(-.002,-.252,.000,-.656,.267,-.046,.291,-.395,.125,-.005,.490,-.437,-.692,.115,.318,-1.205)*f7_0+
    mat4(-.015,.381,-.086,-.253,.360,.057,.211,.049,-.356,.506,.147,.197,-.098,.490,.097,-.034)*f7_1+
    mat4(-.304,.117,-.063,.146,.019,-.062,-.078,.181,.007,.070,-.469,.457,.015,-.646,.019,-.340)*f7_2+
    mat4(-.403,-.045,-.044,-.428,.038,-.058,-.543,.414,-.210,-.808,-.429,-.337,.087,-.166,-.505,.243)*f7_3+
    mat4(-.130,.384,.162,.343,.458,-.521,.241,.090,.130,.146,-.088,.076,.420,.101,-.005,-.404)*f7_4+
    vec4(.146,-.356,-.007,-.647))/2.8+f7_0;
vec4 f8_1=sin(mat4(.765,-.183,-.138,.203,.326,-.182,-.392,-.241,-.621,-.090,-.232,-.058,-.447,.320,.564,.254)*f7_0+
    mat4(.115,-.510,.071,.527,.197,-.445,.026,-.130,.501,.082,.857,-.397,-.263,.410,.461,.244)*f7_1+
    mat4(.129,-.304,-.418,-.541,.182,.003,-.227,-.721,.571,-.389,.474,.030,-.030,-.547,-.314,.151)*f7_2+
    mat4(.454,-.827,.423,-.512,.136,-.193,-.285,-.688,-.078,.098,.022,-.410,-.374,.490,-.337,.377)*f7_3+
    mat4(-.198,-.247,-.045,-.415,.423,.050,.051,.025,.502,.012,.094,.614,.344,.344,-.130,-.508)*f7_4+
    vec4(-.114,.590,.125,.894))/2.8+f7_1;
vec4 f8_2=sin(mat4(.538,-.010,-.202,.607,.110,.440,-.249,.151,.200,.251,.146,.078,.137,-.029,-.453,.028)*f7_0+
    mat4(-.006,.150,-.406,.263,-.718,-.621,.641,-.160,-.426,-.617,.479,-.028,.045,-.871,-.060,.165)*f7_1+
    mat4(-.278,.133,-.582,-.275,-.573,-.002,.424,-.327,.076,-.189,.125,.226,-.050,.171,-.458,-.289)*f7_2+
    mat4(-.587,-.278,-.305,-.081,.459,.261,-.035,.197,-.220,.156,.214,.486,-.475,-.276,.286,.462)*f7_3+
    mat4(-.306,.699,-.167,-.212,-.468,.652,.007,-.061,-.086,.208,-.204,.082,.480,-.250,.125,.621)*f7_4+
    vec4(.729,-.216,.223,.345))/2.8+f7_2;
vec4 f8_3=sin(mat4(.280,.761,.429,-.108,.192,-.405,.531,-.333,-.047,.126,-.173,.177,-.860,-.364,.268,.272)*f7_0+
    mat4(-.064,.303,.101,.256,-.162,.117,-.309,.304,.057,.485,-.497,.782,-.421,-.324,-.467,-.309)*f7_1+
    mat4(-.114,-.806,-.366,.125,.193,-.268,-.467,.530,-.087,.350,-.752,.483,.560,.463,-.374,.149)*f7_2+
    mat4(-.091,-.263,-.265,.144,.346,-.453,-.191,.353,.447,.260,.593,.179,.458,.108,-.235,-.786)*f7_3+
    mat4(-.404,-.227,-.094,.109,.427,.487,-.166,.328,-.166,.214,.248,.057,.346,-.106,-.015,.066)*f7_4+
    vec4(-.214,.353,.443,-.492))/2.8+f7_3;
vec4 f8_4=sin(mat4(.228,.126,.070,-.433,.399,.228,.926,.304,.664,-.138,.373,-.130,.416,-.612,-.071,-.220)*f7_0+
    mat4(-.097,-.226,.195,-.025,-.270,-.220,.635,-.560,-.475,-.424,-.024,.192,-.222,-.631,-.086,-.019)*f7_1+
    mat4(-.654,-.021,-.478,.693,-.489,.051,.194,-.061,-.034,-.028,.113,.071,.224,.835,.313,.082)*f7_2+
    mat4(.053,-.354,-.302,.168,.204,.166,.091,-.297,-.159,.355,.262,.205,-.032,.056,.342,-.234)*f7_3+
    mat4(-.373,-.758,-.054,1.007,.150,.877,-.042,-1.011,-.638,-.322,.679,.428,.215,.990,-.152,.066)*f7_4+
    vec4(.871,-.239,.552,-.451))/2.8+f7_4;
vec4 f9_0=sin(mat4(.284,-.323,-.124,-.034,.404,-.385,.306,-.102,.197,-.657,-.200,-.328,.337,-.678,.436,.217)*f8_0+
    mat4(.141,.045,-.868,.161,-.323,-.059,.048,.174,-.884,-.190,.134,.355,-.003,-.470,.069,-.294)*f8_1+
    mat4(-.460,.288,.117,-.008,.204,-.196,.146,.323,.061,.491,-.091,.128,-.072,-.332,.079,.712)*f8_2+
    mat4(.283,-.325,-.523,.707,.137,.815,-.119,.065,-.559,.035,-.981,-.092,-.464,-.129,-.171,-.522)*f8_3+
    mat4(-.159,.395,.343,.573,-.151,.018,-.417,-.506,.629,-.030,.114,.458,.464,-.399,.106,-.303)*f8_4+
    vec4(-.443,-.539,.596,-.357))/3.0+f8_0;
vec4 f9_1=sin(mat4(-.014,-.125,-.291,-.343,-.329,.026,.590,-.271,-.147,.112,-.173,.821,-.435,-.638,-.152,.751)*f8_0+
    mat4(.172,-.705,.688,.614,.303,.229,.301,.415,.499,-.380,-.598,.334,-.431,.093,-.250,-.328)*f8_1+
    mat4(-.066,-.013,.140,.289,-.012,-.101,-.084,.060,.240,-.765,.282,-.082,.390,-.408,-.527,-.351)*f8_2+
    mat4(-.174,.241,-.330,.527,.690,-.178,.748,.431,-.557,.203,-.077,-.643,-.234,.142,.144,-.083)*f8_3+
    mat4(.366,-.680,.665,.296,.500,-.313,-.272,.044,-.295,-.455,.173,-.284,.071,-.403,.171,-.418)*f8_4+
    vec4(.466,.414,-1.002,-.100))/3.0+f8_1;
vec4 f9_2=sin(mat4(-.208,.614,.092,.387,-.373,.632,.104,-.048,-.024,.077,.225,-.238,-.443,-.452,-.467,-.650)*f8_0+
    mat4(-.410,.491,.514,.434,-.235,-.515,.779,-.389,.235,-.566,.552,-.384,-.083,-.155,-.104,.254)*f8_1+
    mat4(.366,-.065,-.028,-.675,.859,.226,-.175,-.409,.284,.346,.193,-.032,-.289,.278,-.081,.002)*f8_2+
    mat4(.196,.312,-.679,-.246,-.350,.648,.008,-.493,-.520,.027,-.147,-.053,-.254,-.337,.014,.475)*f8_3+
    mat4(.304,-.440,.140,-.225,.142,-.220,-.383,.172,-.285,.312,.054,.530,.275,.534,.240,-.052)*f8_4+
    vec4(.364,.786,.650,.212))/3.0+f8_2;
vec4 f9_3=sin(mat4(-.276,-.053,-.123,.125,-.348,-.517,-.290,.560,-.518,-.676,-.736,.171,-.070,-.623,.080,.611)*f8_0+
    mat4(-.426,.103,.701,-.564,-.000,.653,.316,.045,.648,.289,.189,-.193,.230,.553,.407,.311)*f8_1+
    mat4(.332,.010,.094,.471,-.232,-.293,-.244,-.347,.292,.568,.365,.076,-.325,-.043,.281,.961)*f8_2+
    mat4(-.133,-.055,.118,.202,.393,-.625,-.059,.143,-.145,.120,.758,.233,-.430,.468,.414,.648)*f8_3+
    mat4(.423,.637,-.058,-.120,-.243,.583,-.029,-.151,-.078,.605,.175,.115,-.060,-.311,-.368,.364)*f8_4+
    vec4(-.503,-.571,.011,-.014))/3.0+f8_3;
vec4 f9_4=sin(mat4(-.017,-.361,.213,-.360,.213,.189,-.459,-.005,.391,-.642,.242,.652,.041,-.760,.087,-.023)*f8_0+
    mat4(-.138,.021,-.079,-.028,.118,-.308,-.205,.038,.500,.236,-.269,.067,.449,.031,-.205,-.310)*f8_1+
    mat4(.175,-.400,-.351,-.109,.759,.142,.165,-.043,-.359,.348,.320,-.570,.105,-.503,.165,-.226)*f8_2+
    mat4(.155,-.014,.295,-.306,-.697,.360,-.006,-.028,-.429,.243,.183,.100,-.194,.362,.868,.289)*f8_3+
    mat4(-.245,.230,-.408,-.360,-.380,.291,.164,.346,.240,.251,-.623,.006,.254,.374,.027,.049)*f8_4+
    vec4(-.587,-1.291,1.229,.466))/3.0+f8_4;
vec4 f10_0=sin(mat4(.086,-.079,.414,.215,.051,.148,.215,-.152,.214,.169,-.070,-.514,.231,.567,.487,.192)*f9_0+
    mat4(.087,-.367,-.372,.182,.241,-.213,.590,-.004,-.132,.541,.640,-.260,-.507,.379,.138,-.138)*f9_1+
    mat4(.046,-.377,.036,-.541,.159,.203,.214,-.107,-.564,-.079,-.267,-.042,-.135,.223,-.068,-.526)*f9_2+
    mat4(.186,.138,-.078,.609,-.290,.126,-.372,.606,.579,.326,-.837,-.179,-.140,.515,-.358,-.453)*f9_3+
    mat4(.376,.267,.124,.302,-.660,.202,.715,-.370,-.230,-.362,.013,-.236,.330,.597,-.690,-.842)*f9_4+
    vec4(.756,-.131,-1.287,-.153))/3.2+f9_0;
vec4 f10_1=sin(mat4(.105,-.712,-.318,.352,.076,.329,.639,.130,-.607,.327,.274,.159,.048,-.541,.103,.299)*f9_0+
    mat4(-.911,-.263,-.301,.214,-.197,-.187,.123,-.235,-.217,-.631,-.170,-.860,.229,.286,.113,-.701)*f9_1+
    mat4(.015,.337,.658,-.439,.097,.639,.507,-.129,-.387,.204,-.364,-.122,-.201,.228,.205,.567)*f9_2+
    mat4(.720,-.188,-.191,-.256,-.554,.518,.136,.297,-.162,-.284,-.074,-.078,.414,-.109,-.340,.558)*f9_3+
    mat4(.281,.420,.453,-.500,-.217,.635,.329,-.505,.118,.340,-.462,-.588,.390,.509,-.041,-.062)*f9_4+
    vec4(.300,-.776,-.628,.519))/3.2+f9_1;
vec4 f10_2=sin(mat4(.423,-.763,.063,-.466,-.051,.383,.198,.332,-.344,-.094,-.129,.064,.561,-.145,.458,-.033)*f9_0+
    mat4(.119,.237,.301,.289,.209,.149,-.445,.199,.197,-.274,.188,-.433,-.047,-.377,.117,.561)*f9_1+
    mat4(-.425,.445,-.156,.034,-.183,.684,-.196,.172,-.330,-.072,-.053,-.220,-.243,-.262,.288,-.680)*f9_2+
    mat4(.265,.336,.411,-.441,.705,.633,-.312,.322,-.280,.579,.260,.127,-.159,.102,.427,.275)*f9_3+
    mat4(-.521,.174,-.240,.104,-.548,.653,.103,-.581,.165,-.133,-.987,.394,-.121,-.519,-.242,.076)*f9_4+
    vec4(.933,.012,.742,-.344))/3.2+f9_2;
vec4 f10_3=sin(mat4(.184,-.210,-.021,.016,.113,-.433,-.423,-.556,-.535,-.637,-.037,-.673,.188,-.176,-.331,.052)*f9_0+
    mat4(.147,-.183,.612,.027,-.268,.161,-.545,.160,.123,.509,.103,-.187,.363,.881,-.119,.183)*f9_1+
    mat4(-.288,.182,.701,-.195,-.283,-.741,-.503,-.428,.018,.406,.352,.379,-.069,-.671,-.540,.445)*f9_2+
    mat4(.413,.090,.138,-.525,.151,-.404,.013,.052,.373,-.033,-.520,-.054,.205,-.024,-.552,-.697)*f9_3+
    mat4(-.446,-.333,-.225,-.265,.142,-.200,.804,-.603,.144,-.672,.111,.059,.633,-.193,-.195,.099)*f9_4+
    vec4(-.044,.460,-.186,-.579))/3.2+f9_3;
vec4 f10_4=sin(mat4(.302,-.011,-.237,.158,.064,.122,.108,-.254,.261,-.592,-.135,-.278,.936,-.114,.472,-.129)*f9_0+
    mat4(.670,.527,-.503,.396,.259,.048,.513,.262,.024,.007,-.381,-.030,-.108,.266,.686,.132)*f9_1+
    mat4(-.243,-.324,.052,-.142,.494,-.079,-.506,-.185,-.146,.357,-.232,.186,.133,.552,-.295,.422)*f9_2+
    mat4(-.170,-.590,-.018,-.628,-.148,-.453,-.524,-.493,.068,.016,-.206,.267,.483,.501,.032,.120)*f9_3+
    mat4(-.584,-.229,.562,.058,-.157,.068,-.346,.157,-.131,.820,-.477,-.453,.079,-.008,-.441,.906)*f9_4+
    vec4(-.308,-.846,-.073,.174))/3.2+f9_4;
vec4 f11_0=sin(mat4(.172,-.001,.375,-.293,-.559,-.097,-.780,-.846,-.072,-.928,-.789,.198,-.339,.144,-.522,.804)*f10_0+
    mat4(.014,-.326,.503,.014,.013,.170,-.180,-.342,-.569,.420,-.658,-.008,-.032,-.314,-.772,.047)*f10_1+
    mat4(-.383,.561,.020,.362,-.059,-.601,.078,-.327,-.646,.226,-.243,.167,.262,.447,-.157,-.484)*f10_2+
    mat4(-.621,.069,-.639,.668,.806,-.328,.431,-.244,.625,.259,.051,.419,.134,.289,-.424,-.174)*f10_3+
    mat4(.050,.083,-.163,-.169,.208,.337,.569,-.182,-.370,.325,.422,-.300,.487,-.263,-.018,-.126)*f10_4+
    vec4(.677,-.706,.462,.572))/3.3+f10_0;
vec4 f11_1=sin(mat4(.042,.014,.175,.203,-.565,.169,.050,.326,-.136,.327,.794,.158,-.369,-.614,.636,-.183)*f10_0+
    mat4(-.254,.820,.152,.071,.441,-.234,-.411,.029,.226,.473,-.321,-.579,.712,.623,-.015,-.494)*f10_1+
    mat4(.120,-.393,.556,-.274,-.474,.256,.111,-.234,.201,.066,-.354,.554,.133,-.117,-.365,.338)*f10_2+
    mat4(.069,-.197,.886,-.004,-.501,.097,-.542,.240,.515,.373,-.630,-.574,.686,.321,-.434,.416)*f10_3+
    mat4(-.294,-.092,-.412,.167,-.131,-.672,-.271,.326,-.188,.464,.032,.049,-.362,-.197,-.220,.502)*f10_4+
    vec4(.832,-.951,-.382,.843))/3.3+f10_1;
vec4 f11_2=sin(mat4(-.096,-.224,.151,.571,-.168,.800,.720,-.300,-.064,-.379,-.896,-.114,-.184,-.206,.186,.307)*f10_0+
    mat4(.251,.366,.453,.231,-.182,-.245,-.150,.185,.155,-.064,-.290,.234,-.646,-.203,-.115,-.706)*f10_1+
    mat4(.732,.624,-.312,-.201,.013,-.267,-.654,-.367,-.202,.241,-.007,-.136,-.672,-.004,.339,.171)*f10_2+
    mat4(-.780,-.020,-.512,.378,.110,.402,.020,-.136,.011,-.500,.139,.305,.467,-.657,.185,.218)*f10_3+
    mat4(.293,.831,-.096,.436,.005,-.119,-.188,-.949,-.159,.203,.498,-.209,.535,-.338,.355,.411)*f10_4+
    vec4(.351,-1.906,.118,.702))/3.3+f10_2;
vec4 f11_3=sin(mat4(-.271,.277,.088,-.149,.593,.074,-.288,-.389,-.228,.985,.115,-.045,-.306,.568,.319,.235)*f10_0+
    mat4(-.682,.180,.286,.681,.457,-.402,-.487,.401,-.412,.276,-.066,.039,.194,-.655,.215,.127)*f10_1+
    mat4(.102,-.027,.376,-.289,.269,.132,-.191,-.127,.000,-.351,-.386,.229,-.465,-.055,.125,.391)*f10_2+
    mat4(.338,.509,.302,.226,-.411,.350,.467,.186,.156,-.468,-.108,-.593,.306,-.447,-.161,.162)*f10_3+
    mat4(.107,-.672,-.073,-.253,-.494,.097,-.670,.055,.225,-.701,.378,-.548,-.010,.349,-.329,.517)*f10_4+
    vec4(-.421,1.497,-1.204,1.062))/3.3+f10_3;
vec4 f11_4=sin(mat4(.400,-.197,-.493,.142,-.151,-.915,-.657,.524,-.421,-.151,.184,.127,.094,-.232,-.032,.092)*f10_0+
    mat4(.463,.295,.286,-.248,-.321,.332,-.463,-.685,.158,.160,.597,-.390,-.912,.562,.053,.570)*f10_1+
    mat4(-.085,-.772,.788,-.262,-.508,-.327,.240,-.211,-.024,.460,-.063,-.481,.544,.000,.521,-.348)*f10_2+
    mat4(-.541,-.135,-.166,-.289,.883,.194,-.332,-.008,-.136,.377,.090,-.610,-.452,.484,-.305,.135)*f10_3+
    mat4(-.401,-.321,.220,-.523,.766,.825,.487,-.388,-.509,.211,.522,-.173,-.458,.476,.332,.725)*f10_4+
    vec4(.880,.370,.365,-1.002))/3.3+f10_4;
vec4 f12_0=sin(mat4(.085,.322,.200,.532,-.245,-.513,.810,.582,-.759,.124,.168,.195,-.035,.767,-.004,.713)*f11_0+
    mat4(-.378,.480,.751,-.452,.820,.111,.148,-.108,.806,-.194,-.196,-.005,-.151,-.038,-.314,-.107)*f11_1+
    mat4(-.237,-.178,-.206,-.536,-.009,.188,.373,.351,.683,.220,.298,-.382,.456,.070,.064,-.089)*f11_2+
    mat4(.782,-.226,-.563,.884,-.497,.540,.443,-.003,.326,.357,.003,.249,-.567,-.101,.426,.369)*f11_3+
    mat4(.191,-.606,-.088,-.190,-.004,.319,.499,-.892,.877,.020,.164,-.140,.140,-.815,.646,.137)*f11_4+
    vec4(-1.390,-.447,-.286,-.116))/3.5+f11_0;
vec4 f12_1=sin(mat4(.214,-.088,-.772,-.126,.139,-.156,-.259,.252,-.400,-.417,-.234,.322,-.256,-.334,-.233,-.532)*f11_0+
    mat4(-.233,-.110,-.170,-.887,.335,-.180,-.299,-.435,.512,.291,.144,-.295,.805,-.086,-.141,.299)*f11_1+
    mat4(-.174,-.280,.769,-.198,-.394,-.609,.320,.054,.250,.462,.512,-.046,-.372,-.461,.234,-.242)*f11_2+
    mat4(.071,-.017,-.025,-.339,-.412,.652,.542,-.470,.048,.451,.393,-.530,.020,-.363,-.158,.329)*f11_3+
    mat4(.141,.077,-.033,.259,-.429,.756,1.033,.074,.833,.233,-.336,.152,.416,.632,-.168,-.085)*f11_4+
    vec4(-.784,-.630,.016,.269))/3.5+f11_1;
vec4 f12_2=sin(mat4(.377,-.462,.007,-.305,.491,-.941,.308,.412,-.239,-.425,.185,-.107,-.384,-.351,-.524,-.006)*f11_0+
    mat4(1.390,.640,-.411,.157,.159,.438,.599,-.443,.048,.582,.591,-.189,-.151,.437,.399,.651)*f11_1+
    mat4(.556,.063,-.120,.336,-.265,-.506,.360,-.282,.701,.160,-.119,.090,-.128,.144,.722,-1.191)*f11_2+
    mat4(.802,.058,-.056,-.155,.136,-.151,-.568,.154,-.214,.427,.516,.109,-1.027,.095,.578,.016)*f11_3+
    mat4(-.385,-.175,-.252,.163,.070,.810,-.010,.140,.559,.362,-.184,.495,.512,-.589,.211,-.279)*f11_4+
    vec4(-.060,-1.469,-.775,-.672))/3.5+f11_2;
vec4 f12_3=sin(mat4(.098,-.093,-.320,.579,.007,.071,.108,-.069,-.022,-.039,-.619,.190,-.344,.609,-.428,.397)*f11_0+
    mat4(-.579,.602,-.406,-.154,.763,.174,.223,.363,.327,.230,-.069,-.417,-.968,.505,-.389,-.177)*f11_1+
    mat4(-.236,-.727,-.119,-.876,.302,-.346,-.317,.344,-.218,.511,-.279,-.457,.016,-.252,.050,.097)*f11_2+
    mat4(.476,-.389,-.111,.009,-.368,.387,.052,-.134,.206,-.081,-.513,.131,-.443,-.387,.206,-.245)*f11_3+
    mat4(-.115,-.258,.286,-.724,.396,.059,-.731,-.222,-.058,.072,-.327,-.144,.139,.196,.123,-.009)*f11_4+
    vec4(.511,.986,-.175,.089))/3.5+f11_3;
vec4 f12_4=sin(mat4(-.012,-.198,.534,-.351,-.152,.977,-.293,.123,1.364,.226,-.048,-.232,.300,.748,.280,-.112)*f11_0+
    mat4(-.021,.051,-.283,-.627,.324,.130,.075,-.020,.033,-.445,.003,-1.068,-.519,-.454,.502,-.416)*f11_1+
    mat4(-.102,.188,-.197,.293,1.037,.593,-.252,.042,.037,.309,-.626,.336,.393,.341,-.969,-.289)*f11_2+
    mat4(.813,.949,-.940,.530,.067,.532,-.542,-.207,-.040,.450,-.159,-.461,1.047,-.033,-.136,-.146)*f11_3+
    mat4(-.133,.173,-.429,.027,.451,-.751,.206,-.558,-.762,.169,-.228,.552,-.272,.256,.120,-.653)*f11_4+
    vec4(.439,-1.643,.397,.291))/3.5+f11_4;
vec4 f13_0=sin(mat4(-.227,.539,-.834,.073,-.212,-1.259,-.151,-.309,.520,-.117,1.105,-.019,.093,.572,.403,-1.079)*f12_0+
    mat4(-.428,.002,.298,.522,.417,.241,.718,-.267,.771,.268,.890,-.435,.095,-.195,.100,-.343)*f12_1+
    mat4(-.312,-.206,.035,-.319,-.555,.101,.117,-.014,-.159,-.146,-.007,.473,.626,-.367,-.262,-.846)*f12_2+
    mat4(.745,-.010,.470,-.250,-.232,.060,-.769,.834,.095,.272,.048,.054,-.036,-.526,.216,.476)*f12_3+
    mat4(-.699,.014,.304,.382,-.467,.227,-.739,.957,-.659,.433,.113,-.390,.147,-.819,-.085,-.349)*f12_4+
    vec4(1.346,.117,.955,.716))/3.6+f12_0;
vec4 f13_1=sin(mat4(.525,-1.017,.147,.093,-.579,.694,-.359,.122,-.522,.984,-.156,-.201,.123,-.332,.560,.174)*f12_0+
    mat4(-.494,-.100,.691,-.113,-.297,.697,.131,-.161,-.288,-.818,.364,-.612,.275,-.142,-.095,.342)*f12_1+
    mat4(.077,.068,-.317,.753,-.668,.439,-.082,-.230,-.247,-.098,-.059,.062,.044,-.703,.380,.093)*f12_2+
    mat4(-.348,.717,.053,-.276,-.837,-.038,-.318,-.427,-.029,-.165,-.431,.364,.261,.141,-.681,.373)*f12_3+
    mat4(-.019,.754,.011,.236,.454,-.431,-.187,-.307,-.214,.495,.497,-.105,-.185,.390,-.366,.199)*f12_4+
    vec4(.068,.022,-.178,.630))/3.6+f12_1;
vec4 f13_2=sin(mat4(.249,-.220,-.266,.381,.469,.143,-.477,-.355,.452,-.101,.168,.456,.098,.035,-.714,.371)*f12_0+
    mat4(-.213,-.444,-.119,.394,-.809,-.513,-.508,.472,-.027,-1.158,-.390,.285,.357,.072,-.670,.143)*f12_1+
    mat4(.470,.296,.128,-.188,-.264,-.116,-.294,.362,.153,.416,.058,-.365,-.363,-.602,-.591,.797)*f12_2+
    mat4(-.193,-.183,-.553,.167,.064,.100,.377,.205,-.950,-.715,-.463,.599,-.074,.241,.119,-.560)*f12_3+
    mat4(-.383,.253,-.083,-.379,-.018,-.370,.618,-.431,-.172,.803,-.445,.142,-.166,.538,-.097,-.002)*f12_4+
    vec4(.500,-.266,-1.527,-.983))/3.6+f12_2;
vec4 f13_3=sin(mat4(-.237,-.075,-.416,.256,.146,.021,-.420,.591,.293,.396,.513,.009,-.413,-.856,.408,.269)*f12_0+
    mat4(.373,-.161,-.542,-.733,.699,.135,-.130,-.444,.464,-.037,.252,-.271,.179,.088,.047,.091)*f12_1+
    mat4(-.734,-.469,-.426,-.280,.545,.394,.191,-.613,.210,.125,.009,-.652,.118,.289,.140,-.317)*f12_2+
    mat4(-.056,.049,.402,-.131,-.699,.415,.882,-.835,-.379,-.231,.330,-.004,-.397,.505,-.308,.129)*f12_3+
    mat4(-.105,.405,-.402,-.619,.295,-.156,.575,-.532,.510,-.202,-.810,-.363,-.324,-.119,.287,.518)*f12_4+
    vec4(.016,.215,1.029,.833))/3.6+f12_3;
vec4 f13_4=sin(mat4(.075,.264,.009,-.321,.286,-.167,.375,.420,-.651,-.268,.545,.274,.069,-.237,-.151,.482)*f12_0+
    mat4(-.459,.522,.098,-.762,.279,-.475,-.305,1.140,-.621,.099,.518,.530,-.365,.296,.485,.120)*f12_1+
    mat4(.372,.227,.485,.134,-.510,.187,.598,.115,-.246,.256,-.233,.152,.086,.111,.633,-.320)*f12_2+
    mat4(.264,-.690,-.491,.613,.297,.517,-.104,-.039,.166,-.004,.227,-.309,-.360,.689,.202,-.129)*f12_3+
    mat4(.932,-.158,-.047,.126,-.806,1.462,.228,-.336,.358,.483,.351,-.203,-.032,-.502,-.536,-.062)*f12_4+
    vec4(-.764,-.383,.445,-.950))/3.6+f12_4;
vec4 f14_0=sin(mat4(-.285,-.051,-.674,-.030,.475,.470,-.141,-.144,.760,-.384,1.084,-.180,-.187,.457,.045,.600)*f13_0+
    mat4(.054,-.042,.151,-.302,.391,.226,.257,.026,.444,-.708,-.038,-.162,.298,-.410,-.489,-.019)*f13_1+
    mat4(-.411,-.049,-.020,-.513,-.433,.356,-.402,.050,.062,.711,-.235,-.360,-.162,.386,-.380,-.073)*f13_2+
    mat4(.024,-.070,.262,.463,-.250,.242,-.146,.472,.260,-.189,.193,.299,-.143,-1.134,.003,-1.140)*f13_3+
    mat4(.189,-.130,.014,-.405,-.617,-.364,-.353,-1.137,-.437,.376,.085,-.161,.147,.692,-.153,-.678)*f13_4+
    vec4(.067,-1.689,1.533,.031))/3.7+f13_0;
vec4 f14_1=sin(mat4(.821,.377,.076,-.190,-.148,.226,-.078,.604,.637,.496,.207,.288,.147,-.212,-.147,.052)*f13_0+
    mat4(.199,.243,-.358,.106,.335,.807,.721,.517,-.282,-.005,.698,-.826,-.753,-.176,-.259,-.195)*f13_1+
    mat4(-.370,.244,-.002,.236,.386,.070,.051,.299,.386,.240,-.215,-.231,-.091,.864,.129,.267)*f13_2+
    mat4(.016,.365,-.658,-.983,.791,-.478,-.142,-.411,.246,-.321,-.667,.047,-.523,.366,-.684,.329)*f13_3+
    mat4(-.238,-.561,-.302,-.048,-.754,-.686,.363,-.090,-.660,.230,-.305,.317,-.065,.331,.227,-.349)*f13_4+
    vec4(-.149,-.076,.577,-.415))/3.7+f13_1;
vec4 f14_2=sin(mat4(.182,.315,.197,.187,-.011,-.045,-.529,.247,.606,.764,.066,.056,-.496,.158,.356,-.879)*f13_0+
    mat4(.176,.000,.440,.558,.277,.447,.508,.062,.732,-.458,.592,-.066,-.039,-1.333,.507,-.748)*f13_1+
    mat4(.162,-.237,-.194,-.200,-.072,.554,-.181,.480,.333,-.103,.016,.101,.309,.127,.133,-.200)*f13_2+
    mat4(.636,.538,-.069,-.015,-.798,.619,.430,.001,.235,-.323,.411,.168,-.193,-.508,-.539,-.086)*f13_3+
    mat4(.431,.063,-.795,.607,.137,-.125,.494,-.032,.793,-.239,-.571,.014,-.191,-.092,-.007,-.196)*f13_4+
    vec4(.603,.016,.505,-.269))/3.7+f13_2;
vec4 f14_3=sin(mat4(-.354,.183,.290,-.354,.207,-.162,.116,-.322,.002,.550,-.277,-.104,-1.037,.139,-.246,-.412)*f13_0+
    mat4(.622,.470,.786,-.552,.023,.178,-.104,-.008,-.009,.388,-.296,-.272,-.089,.128,.292,-.589)*f13_1+
    mat4(.014,.060,.507,-.197,-.191,.193,.086,.069,-.058,-.092,.040,-.215,-.005,.283,-.008,-.003)*f13_2+
    mat4(-1.343,.558,.845,.226,.205,-.397,-.466,1.123,-.039,-.439,.069,-.260,.445,-1.089,-.831,-1.140)*f13_3+
    mat4(.020,-.836,.216,.089,.595,-.613,-.095,-.327,-.663,.027,.142,.223,.083,-.768,-.169,-.451)*f13_4+
    vec4(.636,.563,-.232,.327))/3.7+f13_3;
vec4 f14_4=sin(mat4(-.854,-.472,1.051,-.909,.369,-.315,.001,-.248,.526,-.607,.695,.297,.564,-.723,.048,-.280)*f13_0+
    mat4(-.273,.496,-.206,.320,-.380,.076,.810,.053,.576,-.255,-.062,.167,.092,.213,-.870,-.561)*f13_1+
    mat4(.164,-.183,-.585,.423,.478,.314,.618,.207,-.396,.523,-.856,.350,.000,-.003,-.091,.096)*f13_2+
    mat4(-1.140,-.145,.277,1.066,.030,.425,-.865,-.292,.133,-.227,-.187,.298,.338,.232,.374,.346)*f13_3+
    mat4(.199,.401,-.390,.299,-.687,.423,.051,-.184,-.474,-.142,.030,.273,.415,-.305,-.008,-.164)*f13_4+
    vec4(.333,1.117,.043,.521))/3.7+f13_4;
vec4 f15_0=sin(mat4(1.085,.106,-.160,.306,-.069,.146,-.204,-.218,-.345,-.082,.063,.628,-.043,1.153,.143,.695)*f14_0+
    mat4(-.139,-.382,-.245,-.414,-.436,.052,.358,.255,-.019,-.698,.220,.257,.127,-.605,.002,.120)*f14_1+
    mat4(-.369,-.454,-.089,.258,.133,.256,.053,.225,-.111,.116,.526,.271,.852,-.089,-.586,-.088)*f14_2+
    mat4(.752,.291,1.231,.869,-.362,.312,-.305,-.363,-.202,.517,-.171,-.019,-.024,.167,-.272,.140)*f14_3+
    mat4(-.191,-.237,.447,-.765,.319,-.411,-.537,-.838,-.204,.164,.728,-.404,-.359,.530,.727,.203)*f14_4+
    vec4(.178,-2.074,.160,1.043))/3.9+f14_0;
vec4 f15_1=sin(mat4(-.546,-.284,.505,-.238,-.039,.083,.102,-.065,.340,-.486,.598,.733,-.676,.017,.402,.373)*f14_0+
    mat4(1.503,-.079,-.631,-.522,.196,-.749,.024,.525,-.303,-.152,-.372,-.140,-.195,-.317,.017,.652)*f14_1+
    mat4(-.474,.147,-.289,-.471,.124,-.070,.163,-.282,-.241,-.222,-.220,-.853,-.070,-.235,.069,.393)*f14_2+
    mat4(-1.217,-1.045,.360,.194,.121,.914,-.278,-.878,.080,.303,-.099,.275,.645,.138,-.398,.992)*f14_3+
    mat4(.425,.947,-.018,-.646,.332,-.290,-1.163,.071,-.544,.216,-.095,-.106,-.280,.243,-.106,-.296)*f14_4+
    vec4(-1.452,-.193,-.471,-1.056))/3.9+f14_1;
vec4 f15_2=sin(mat4(-.699,.109,.045,.161,.543,-.233,.359,.517,-.160,-.255,1.819,-.168,-.668,.285,.376,.319)*f14_0+
    mat4(-.808,-.044,-.733,-.799,.226,-.377,.402,-.020,-.414,.963,-.190,.659,-.291,-.135,-1.122,-.090)*f14_1+
    mat4(.618,.515,-.647,-.124,.207,-.518,.602,-.349,.262,.468,-.543,-.293,-.113,-.210,.639,.165)*f14_2+
    mat4(.175,-.329,-.443,-.514,-.073,.008,.526,-.242,.366,-.077,-.145,.091,-.168,-1.092,.066,-.413)*f14_3+
    mat4(.870,.286,-.115,-.594,.268,.035,-.064,-.197,.961,.425,-.573,-.418,-.090,-.555,.307,.472)*f14_4+
    vec4(-1.333,-.065,.823,-.669))/3.9+f14_2;
vec4 f15_3=sin(mat4(-.392,-.464,-.454,.155,.356,-.498,-.062,-.065,.278,.043,-.456,.170,-.805,-.294,1.037,-.395)*f14_0+
    mat4(.445,-.650,.218,.723,.098,.366,-.008,.028,.437,-.405,-.436,-.032,.095,-.570,-.305,.432)*f14_1+
    mat4(-.103,-.278,-.767,-.342,-.140,.056,.294,-.116,.068,-.777,-.009,-.074,.416,.128,-.228,-.108)*f14_2+
    mat4(-1.184,-.011,-.158,-.879,-.157,-.653,.061,-.419,.259,.244,1.102,.643,.625,.454,.327,.919)*f14_3+
    mat4(-.243,-.350,-.304,-.028,.564,.480,-.760,-.113,-.211,-.238,-.281,.554,.370,.560,.026,.198)*f14_4+
    vec4(.623,.112,1.211,-.093))/3.9+f14_3;
vec4 f15_4=sin(mat4(.098,.095,-.351,-.752,.381,-.091,.049,.677,.136,.225,.014,-.462,-.652,.788,.739,.246)*f14_0+
    mat4(.277,-.795,-.435,.091,.218,.089,.044,.138,.289,.291,-.061,-.199,-.066,-.001,-.631,.408)*f14_1+
    mat4(.644,.173,-.220,-.133,.606,-.031,.445,-.599,.249,.162,.222,.125,.160,-.479,.456,-.106)*f14_2+
    mat4(-.750,1.168,-.703,-.014,-.299,-.226,.261,.654,-.701,.038,.855,.500,.734,-.835,.650,.284)*f14_3+
    mat4(.358,.095,-.313,-.225,.124,-1.550,.069,.211,.892,.664,-.784,-.036,-.154,.644,.083,.729)*f14_4+
    vec4(-1.518,-.868,2.023,-.054))/3.9+f14_4;
vec4 f16_0=sin(mat4(1.231,1.110,-.378,.308,-.518,-1.066,-.018,.336,-.527,-.678,.920,-.339,.859,.280,.208,-.751)*f15_0+
    mat4(-1.243,-.398,.688,.094,-.024,.211,.323,-.132,-.123,-.011,.619,.284,-.547,-.460,.070,.198)*f15_1+
    mat4(.497,-.237,.036,.289,.232,.942,.133,-.513,-.032,.233,.452,-.108,.029,.306,.063,.191)*f15_2+
    mat4(1.003,.580,.427,-.914,-.189,-.220,-.166,-.228,-.139,-.240,-.386,.061,-.785,-.677,-.416,-.417)*f15_3+
    mat4(-.218,-.014,-.023,.026,-.479,.286,-.620,-.138,.773,.364,.165,.086,.276,-.334,-.188,.236)*f15_4+
    vec4(.691,.098,-1.733,-1.033))/4.0+f15_0;
vec4 f16_1=sin(mat4(-.658,-.058,.476,-.784,.180,-.689,.707,.133,.833,.985,-.149,.224,-.319,-1.530,-.527,-.467)*f15_0+
    mat4(1.223,.101,.396,.226,.096,.218,-.088,.500,.004,.305,-.130,.271,.278,.309,.188,1.108)*f15_1+
    mat4(.241,.196,.172,-.582,-.475,.138,-.251,-.379,.310,.202,.309,-.383,.206,-.134,-.551,-.753)*f15_2+
    mat4(-.461,-.762,-.253,-.029,.030,-.307,-.122,-.542,-.222,-.307,.062,-.098,.193,-.061,.985,.795)*f15_3+
    mat4(.335,-.121,.214,-.236,-.369,.734,.257,.241,-.016,.152,-.547,-.268,-.186,-.311,.258,-.543)*f15_4+
    vec4(-.669,.666,1.145,1.121))/4.0+f15_1;
vec4 f16_2=sin(mat4(.463,-.056,.341,-.972,.506,-.185,-.402,.720,-.030,-.934,-.491,.234,.435,.103,.158,.139)*f15_0+
    mat4(-.276,.107,-.366,-.412,.962,.203,-.868,.116,.348,.112,-.715,-1.059,-.184,.106,.070,.293)*f15_1+
    mat4(-.981,-.510,.266,-.603,.368,.515,-.960,.117,-.463,.041,.561,-.016,.358,-.612,-.494,-.157)*f15_2+
    mat4(-.166,-.262,.876,1.296,-.300,-.366,.280,.077,.547,.330,.078,-.020,.885,.770,-.231,.585)*f15_3+
    mat4(-.586,-.484,.193,-.407,-.113,.255,-.325,-.869,-.453,-.368,-.277,.351,.554,.738,-.478,.299)*f15_4+
    vec4(.244,-.159,.083,.452))/4.0+f15_2;
vec4 f16_3=sin(mat4(-.734,.285,-.568,-.068,.136,.626,-.650,.878,.272,.457,-.378,-.636,-1.211,-.211,.427,-.359)*f15_0+
    mat4(.791,-.105,-.591,.965,-.117,.629,.551,-.551,-.127,.178,-.531,-.405,.021,1.037,-.268,.721)*f15_1+
    mat4(-.066,-.651,-.341,.310,-.227,.329,.639,.243,-.051,-.720,-.079,.557,.479,-.344,.508,-.015)*f15_2+
    mat4(-1.692,-.251,-.171,-.681,.197,-1.111,-.136,.344,.259,.306,.684,.128,.463,1.030,.101,.678)*f15_3+
    mat4(.017,-.167,-.140,.210,.653,-.331,.332,.195,-.773,-.341,.217,1.317,-.085,.165,-.032,.319)*f15_4+
    vec4(.976,-.368,.394,-.583))/4.0+f15_3;
vec4 f16_4=sin(mat4(-.215,-.495,.229,-.118,-.120,.093,-.084,-.280,-.242,.621,-.206,.003,-.900,.526,-.363,-.364)*f15_0+
    mat4(-.085,.499,.000,-.380,.092,.284,-.858,.404,.256,.267,.302,.371,1.354,.231,.238,.254)*f15_1+
    mat4(.651,-.297,.137,-.204,.355,.138,-.814,.061,-.133,.010,.044,-.343,-.100,-.139,.371,.532)*f15_2+
    mat4(.063,.390,.269,-.308,-.298,-.110,-.114,-.777,.455,.347,.000,-.076,.479,-.326,-.019,.293)*f15_3+
    mat4(-.377,-.053,.419,-.374,-.234,-1.005,-.214,.126,.606,-.029,.112,-.887,.127,.130,-.435,1.153)*f15_4+
    vec4(-.109,.840,.340,-.052))/4.0+f15_4;
vec4 f17_0=sin(mat4(.406,-.394,-1.202,.018,-.481,.581,.856,.330,.322,.783,1.446,-.323,.404,.530,-.141,.262)*f16_0+
    mat4(-.336,.297,.737,.351,-.409,-.068,.189,-.391,.287,.732,.464,-.730,-.398,.192,.432,-.359)*f16_1+
    mat4(.423,.326,.092,.299,.182,-.848,-.751,-.371,.634,-.174,-.038,.180,-.540,.644,-.447,-.167)*f16_2+
    mat4(.495,-.161,-.478,-.079,.283,-.007,.135,.741,-.733,-.151,.204,.297,-.633,-.273,.209,-.068)*f16_3+
    mat4(.215,.307,-.168,.411,.171,-1.301,-1.129,-.099,.724,-.376,-.562,.159,-.127,1.130,.454,-.185)*f16_4+
    vec4(.391,.188,-2.843,-.188))/4.1+f16_0;
vec4 f17_1=sin(mat4(-.161,-.263,-.127,.438,-1.154,-.534,-.083,-.624,-.276,-.149,-.562,-.564,.472,-.095,-.579,-.158)*f16_0+
    mat4(-.419,.696,-.270,-.194,-.107,-.813,.585,-.530,-.079,-.170,.662,-.142,-.172,.618,.976,-.043)*f16_1+
    mat4(.162,.952,.260,-.041,.262,.030,.173,-.207,.183,.605,.040,-.307,.004,-.675,-.770,.159)*f16_2+
    mat4(.533,.007,.041,-.127,-.345,.641,-.132,-.175,.135,-.720,-.852,.229,-.877,.024,.042,-.052)*f16_3+
    mat4(-.446,.670,.340,-.399,-.069,.823,.746,-.147,.113,.342,.689,-.267,-.411,-.679,.578,-.399)*f16_4+
    vec4(.498,.314,.491,-.686))/4.1+f16_1;
vec4 f17_2=sin(mat4(.175,-.801,.134,-.486,-.311,.674,-.215,.519,-.138,.106,-.092,.733,1.000,.164,.625,-.492)*f16_0+
    mat4(.268,.469,-.250,.489,-.008,-.712,.301,-.067,-.061,.250,-.652,-.837,.259,.205,-.070,-.013)*f16_1+
    mat4(-.259,.574,-.137,-.214,.196,-.703,.621,.045,.037,.435,-.447,-.263,-.811,-.473,.331,.661)*f16_2+
    mat4(.226,.083,.933,-.615,-.728,.411,-.483,.153,.580,-.300,.656,.095,.347,-.534,.710,.731)*f16_3+
    mat4(-.153,.831,-.240,.332,-.068,-.155,.587,-.254,-.197,.198,-.467,-.499,-.850,-.199,-.155,-.052)*f16_4+
    vec4(-.759,.475,-.465,-.567))/4.1+f16_2;
vec4 f17_3=sin(mat4(.354,.373,-.342,-.282,-.185,.272,-.237,-.075,-.264,.081,-.033,.172,.371,.260,.279,-.901)*f16_0+
    mat4(-.234,-.172,-.389,.338,-.362,-.946,.536,.494,-.143,-.103,.365,.004,-.068,.036,.100,.258)*f16_1+
    mat4(.345,.727,-.369,.130,-.145,-.960,1.055,.464,-.094,.332,-.118,-.598,-.175,-.511,-.135,.275)*f16_2+
    mat4(.944,-.159,.075,-.497,-.520,.484,-.557,-.342,.057,-.705,.971,.001,-.733,-1.118,.670,1.047)*f16_3+
    mat4(-.180,.231,-.250,-.450,-.949,-.571,-.591,.827,.787,.169,.478,-.359,.126,.134,.564,.626)*f16_4+
    vec4(1.392,-.167,.687,-1.502))/4.1+f16_3;
vec4 f17_4=sin(mat4(.507,-.976,-.141,-.055,.429,.456,.763,.255,.668,1.391,.440,.056,-.046,.806,-.200,.039)*f16_0+
    mat4(.644,.391,.571,.098,-1.044,.083,.309,-.780,.038,.377,.572,-.019,.223,.300,.452,-.202)*f16_1+
    mat4(.903,-.060,-.356,-.075,.069,-.428,.189,-.622,.737,-.115,-.034,.257,-.540,-.581,-.142,-.108)*f16_2+
    mat4(.077,.516,-1.531,-.129,.754,-.157,-.221,.707,-.579,.217,.066,-.301,-.632,-.239,.888,-.118)*f16_3+
    mat4(.530,-.287,-.404,.585,-.565,-1.910,-.621,-.322,1.005,-.147,-.569,-.587,-.089,.237,.219,-.010)*f16_4+
    vec4(.570,-.084,-.243,.785))/4.1+f16_4;
vec4 f18_0=sin(mat4(.085,-.084,.039,-.124,-.085,-.626,.159,.390,.229,.122,-.050,.215,-.184,.040,.086,.400)*f17_0+
    mat4(-.156,-.068,.339,-.352,.059,-.290,-.319,-.097,.114,-.194,.187,.362,.007,-.194,.041,.301)*f17_1+
    mat4(.146,.554,-.249,-.017,-.082,-.018,-.635,-.365,-.310,.254,.416,-.364,1.032,-.244,.017,.339)*f17_2+
    mat4(-.474,.042,-.473,.034,-.305,.530,.191,.041,.210,-.113,-.315,-.054,.358,-.249,-.548,.007)*f17_3+
    mat4(-.136,.605,-.286,.012,.472,-.186,.120,-.166,-.328,.380,.065,-.114,.502,-.576,-.332,-.361)*f17_4+
    vec4(-.178,1.287,.973,.971))/4.2+f17_0;
vec4 f18_1=sin(mat4(-.496,-.049,-.165,-.707,.228,-.008,.038,.408,.239,.082,.007,.690,-.544,.391,-.095,-.026)*f17_0+
    mat4(.966,-.219,-.226,-1.123,-.557,-.689,-.428,.662,-.746,-.155,-.183,1.171,-.267,.012,.779,.844)*f17_1+
    mat4(.196,.697,.133,.335,-.406,-.466,-.507,-.173,.516,.303,.043,-.070,.320,-.517,-.709,-.422)*f17_2+
    mat4(-1.108,.594,.660,.381,.759,-.098,-.110,-.550,-.227,-.447,-.257,-.354,-.020,-.855,-.532,.014)*f17_3+
    mat4(.118,.704,-.044,-.617,.119,-.847,-.728,-1.276,-.324,.462,.405,-.532,.064,-.335,-.279,.781)*f17_4+
    vec4(-.441,-.130,-.010,1.047))/4.2+f17_1;
vec4 f18_2=sin(mat4(-.688,-.309,.045,-.245,-.155,.340,.121,-.045,.254,.299,.046,.243,-.070,.054,.111,-.272)*f17_0+
    mat4(.384,.492,-.657,-.516,.180,-.816,.856,-.319,-.154,-.497,.245,-.501,-.399,.154,.144,-.393)*f17_1+
    mat4(-.003,.718,-.726,.211,1.381,-.702,.744,.555,-.631,.247,-.979,-.703,.377,-.455,-.137,.453)*f17_2+
    mat4(.089,-.254,.330,.511,-.702,.862,-.505,-.405,1.405,-.727,.587,.237,.677,-.738,.632,.204)*f17_3+
    mat4(-.221,.568,-.431,-.306,-.140,-.649,-.992,-.237,.308,-.098,.337,-.272,-.387,-.219,.034,.076)*f17_4+
    vec4(-1.466,-.608,-1.043,-1.018))/4.2+f17_2;
vec4 f18_3=sin(mat4(-.291,.296,-.581,.186,.420,.343,.437,-.463,.373,.027,-.093,-.167,-1.063,.006,-.401,.701)*f17_0+
    mat4(.391,-.125,.197,-.254,.240,-.859,-1.140,-.247,-.112,-.258,-.260,-.111,.246,.101,-.020,.018)*f17_1+
    mat4(.070,.615,1.068,-.260,-.276,-1.105,-.689,-.523,-.347,.692,.246,.139,.119,-.404,.075,-.263)*f17_2+
    mat4(-.988,.012,-.928,.650,.038,.675,.616,.215,-.238,-1.119,-.627,.168,.548,-.506,-.170,-.614)*f17_3+
    mat4(-.145,.743,.229,-.329,.445,-.086,.185,.033,-.387,.113,-.470,-.594,.406,.172,-.247,-.222)*f17_4+
    vec4(-.733,.689,-.182,.275))/4.2+f17_3;
vec4 f18_4=sin(mat4(.059,-.357,.456,-.257,-.012,.033,.537,-.394,.108,.308,-.015,-.043,-.581,1.020,.248,-.434)*f17_0+
    mat4(-.700,-.119,-.041,-.432,.971,.285,-.187,.230,.100,.040,-.032,-.352,.537,.440,.119,-.296)*f17_1+
    mat4(-.291,-.263,.381,-.220,.492,-.400,-.364,.318,-.436,-.094,.284,-.374,.336,-1.024,-.632,.370)*f17_2+
    mat4(.102,1.352,.332,-.017,-.735,-.039,-.418,-.552,-.310,.170,-1.096,.150,1.204,-.453,-.492,.885)*f17_3+
    mat4(-1.171,.131,.275,.212,.533,-1.359,-.217,-.184,-.124,.596,-.032,-.678,.692,-.298,-.692,.223)*f17_4+
    vec4(-.098,-.227,1.602,-1.107))/4.2+f17_4;
vec4 f19_0=sin(mat4(-.505,-.807,-.400,-.028,.433,.294,-.023,-.424,.608,-.141,-.286,-.631,.601,.395,-.614,-.421)*f18_0+
    mat4(-.194,.055,.105,-.058,.910,.160,.535,-.430,.673,-.180,.035,-.585,.501,-.379,.095,-.147)*f18_1+
    mat4(-.764,.384,-.601,.148,.450,-.552,-.102,.102,-.553,.028,-.255,.116,.449,.140,.046,.244)*f18_2+
    mat4(.303,-.375,-.405,-.239,-.577,.755,-.046,.172,.707,-.146,.590,.203,.717,-.231,.374,.024)*f18_3+
    mat4(-.531,.389,-.134,.408,-.731,.210,.096,.675,-.304,-.424,-.075,.089,.485,.298,-.008,-.584)*f18_4+
    vec4(.407,.384,-.392,-.283))/4.4+f18_0;
vec4 f19_1=sin(mat4(-.758,-.607,.155,-.556,.040,-.348,-.163,.081,.551,.024,-.181,-.002,-.230,.476,.717,.085)*f18_0+
    mat4(.733,.246,-.368,-.600,-.224,1.045,-.691,.606,-.233,.072,.219,.221,-.392,-.173,.336,.875)*f18_1+
    mat4(-.220,-.933,-.160,-.495,-.270,.990,-.743,-.147,.623,-.550,.224,-.236,.074,-.011,-.253,.490)*f18_2+
    mat4(-.121,.556,.613,-.103,.631,-.533,-.019,-.099,.545,1.133,-.067,.457,-.251,.701,-.910,-.187)*f18_3+
    mat4(.458,-.324,.010,-.712,-.523,-.141,-.389,-.047,.071,.058,.158,-.011,-.075,-.128,-.320,.179)*f18_4+
    vec4(.855,.645,-2.003,.911))/4.4+f18_1;
vec4 f19_2=sin(mat4(-.530,-.349,.714,-.546,.265,-.227,.543,-.650,-.384,-.126,.566,.334,-.299,-.492,-.545,.853)*f18_0+
    mat4(.367,.517,-.327,-.074,.588,.084,.619,-.189,.557,.482,.524,-.058,.503,.913,-.413,-.347)*f18_1+
    mat4(-.213,-.151,-.212,.055,.581,-.411,.962,.206,-.360,-.251,-.576,.324,.139,.289,.902,-1.010)*f18_2+
    mat4(-.317,-.496,-.149,.235,-.546,-.331,-.753,.135,.645,.243,.180,.363,.666,.640,.331,-.603)*f18_3+
    mat4(.038,-.300,.327,-.346,-.154,.184,-.000,-.662,.177,-.354,.380,.174,.050,.024,-.498,-.259)*f18_4+
    vec4(.102,.133,-.031,.859))/4.4+f18_2;
vec4 f19_3=sin(mat4(.217,.634,.202,.112,-.005,-.239,-.678,-.762,-.060,-.418,.195,-.422,.308,.648,-.551,.525)*f18_0+
    mat4(-.509,-.769,.925,.022,.522,.981,.149,-1.034,.026,.100,.330,-.254,.135,-.127,-.557,-.203)*f18_1+
    mat4(-.514,-.904,-.062,.604,.262,1.003,.585,-.468,-.395,-.318,.241,.622,-.033,.785,-.645,-.932)*f18_2+
    mat4(.475,1.001,-.496,.836,-.344,-.854,-.040,.401,.275,1.233,.519,-.558,.324,.502,.192,-1.338)*f18_3+
    mat4(-.532,-.523,-.344,.688,.137,-.464,.347,-.347,.219,.106,.026,.750,.370,.212,.217,-.818)*f18_4+
    vec4(.153,.335,-.322,-.006))/4.4+f18_3;
vec4 f19_4=sin(mat4(-.281,.042,.746,.144,.543,.548,-.792,.364,-.273,.437,-.141,.137,-.730,-.427,-.005,.013)*f18_0+
    mat4(.228,.575,-.156,.069,-.777,.034,-.637,-.124,-.695,.201,-.123,-.132,-.383,.059,.298,.840)*f18_1+
    mat4(.522,-.066,.441,.618,-.925,.157,-.577,-1.002,.518,.204,-.062,.558,.657,.082,-.168,-.298)*f18_2+
    mat4(-.527,-.447,.506,.343,.289,-.041,.045,.551,.194,-.097,.475,-.277,.062,.572,-.374,-.732)*f18_3+
    mat4(.919,.071,-.208,.275,.608,.298,.073,-.800,-.092,-.131,.441,.114,.083,.593,-.112,.150)*f18_4+
    vec4(.263,-1.600,-.531,.701))/4.4+f18_4;
vec4 f20_0=sin(mat4(-.099,.030,-.650,-.550,-.141,.020,.703,.229,.389,-.313,.963,.009,.291,1.052,-.550,-1.327)*f19_0+
    mat4(.138,-.506,.406,.833,.686,.165,.213,.042,.104,-.372,.533,.135,.046,-.119,.549,.135)*f19_1+
    mat4(-.140,.016,-.058,.018,.149,.042,-.871,-.333,-.165,-.340,-.274,-.116,-.029,-.319,.310,.621)*f19_2+
    mat4(-.234,1.155,-.633,-1.798,-.280,-.030,-.188,.114,.299,.346,.039,-.002,.407,-.262,.355,.486)*f19_3+
    mat4(-.728,.170,-.439,.137,-.252,-.381,-.842,1.096,-.637,.670,-.512,-.544,.430,-.026,1.199,.002)*f19_4+
    vec4(-.310,-.152,.234,1.058))/4.5+f19_0;
vec4 f20_1=sin(mat4(-.143,-.355,-.524,-.198,.110,.011,-.035,.176,.019,-.387,.426,.441,-.230,.269,-.126,.692)*f19_0+
    mat4(.500,.833,.718,-.372,-.431,-1.142,.889,.431,-.121,-.584,.073,.570,-.357,-.861,-.020,.742)*f19_1+
    mat4(.376,.982,-.599,.061,-.511,-.511,1.249,.219,.603,1.328,-.443,-.142,-.084,-.083,-.462,-.324)*f19_2+
    mat4(-.433,.189,.096,.489,.533,1.084,-.597,-.444,-.253,-.285,.780,-.005,-.056,-1.237,.932,-.049)*f19_3+
    mat4(.466,1.223,-.495,-.473,-.099,.043,-.440,-.712,-.144,.601,-.288,-.143,-.197,-.596,.011,.057)*f19_4+
    vec4(.091,-1.431,.140,1.007))/4.5+f19_1;
vec4 f20_2=sin(mat4(.728,-.576,.354,-.200,-.006,-.537,.103,.014,-.073,-.020,-.170,.368,-.062,.281,-.366,.692)*f19_0+
    mat4(-.315,.144,-.456,-.177,-1.153,.609,-.463,-.168,.046,-.179,.337,.080,.364,-.156,.182,.206)*f19_1+
    mat4(.841,-.744,.726,.045,-.926,.774,-.684,-.398,.851,-.392,.575,.074,-.362,.044,-.424,-.562)*f19_2+
    mat4(.328,.370,-.138,.545,.597,-.214,.287,.239,-1.443,.835,-1.240,-.322,-.718,.244,-1.032,-.306)*f19_3+
    mat4(.311,-.127,-.142,-.084,.394,.114,.208,-1.116,.184,.131,.358,-.011,-.094,.084,.459,-.289)*f19_4+
    vec4(.337,-.102,-.316,-.485))/4.5+f19_2;
vec4 f20_3=sin(mat4(.151,.352,.165,.254,.051,-.119,.072,-.201,-.407,-.341,.183,-.311,-1.073,-.094,-.351,.001)*f19_0+
    mat4(.188,-1.089,.216,.067,-.022,-.772,.777,-.427,-.051,.255,.537,-.340,-.120,.157,-.342,-.498)*f19_1+
    mat4(.157,1.004,-.950,.302,.013,-.820,.914,-.155,-.209,.438,-.920,.562,.664,-.350,.256,.195)*f19_2+
    mat4(-1.401,.273,-.790,.134,.106,.279,-.433,.329,-.143,-1.063,.848,-.295,.494,-.805,.270,-.292)*f19_3+
    mat4(.005,-.016,.028,.004,1.296,-.200,-.016,.120,-.384,.266,.043,.020,.023,.323,-.009,-.145)*f19_4+
    vec4(-.340,.909,.660,.802))/4.5+f19_3;
vec4 f20_4=sin(mat4(.158,.144,-.398,-.554,.789,.121,.123,.491,-.745,-.231,.093,.769,-.258,-.520,-1.060,-.360)*f19_0+
    mat4(-.515,-.098,.706,-.083,-.059,.000,.208,.514,-.473,-.056,.290,1.086,-.564,.162,-.186,.823)*f19_1+
    mat4(.511,.016,.211,-.179,-.319,-.274,.014,-.187,.413,-.176,-.209,-.673,-.030,.318,.533,-.410)*f19_2+
    mat4(.197,-.769,-.985,-.533,.181,.250,-.072,-.231,-.676,-.276,.099,-.426,-.174,.105,.551,.589)*f19_3+
    mat4(.914,.070,-.044,-.796,.324,.533,.606,.321,.563,-.324,-.319,-.233,.003,-.370,.326,.614)*f19_4+
    vec4(-1.368,2.006,1.245,-.563))/4.5+f19_4;
float f_0=dot(f20_0,vec4(-.019,.017,.040,.005))+
    dot(f20_1,vec4(.042,-.066,-.020,-.017))+
    dot(f20_2,vec4(.042,-.061,.056,-.028))+
    dot(f20_3,vec4(-.020,.051,-.031,-.042))+
    dot(f20_4,vec4(.038,-.040,-.007,-.024))+
    0.475;
float f_1=dot(f20_0,vec4(.016,.000,-.021,-.047))+
    dot(f20_1,vec4(.031,-.067,-.034,-.031))+
    dot(f20_2,vec4(.043,-.043,.048,.011))+
    dot(f20_3,vec4(-.064,.055,-.037,-.028))+
    dot(f20_4,vec4(.046,.052,-.009,-.035))+
    0.482;
float f_2=dot(f20_0,vec4(.036,-.022,-.027,.042))+
    dot(f20_1,vec4(-.012,-.067,-.041,-.035))+
    dot(f20_2,vec4(.037,-.027,.057,-.030))+
    dot(f20_3,vec4(.055,.045,-.032,-.070))+
    dot(f20_4,vec4(.043,-.020,.033,-.040))+
    0.475;

#endif
#endif
    return vec3(f_0, f_1, f_2);
}

// Function 1898
vec3 ComputeLightPattern(vec3 Ln)
{
    Ln =  lightRotate*Ln,
        
    Ln = abs(Ln);
    float a = max(Ln.x, max(Ln.y, Ln.z));
    vec3 c = a == Ln.x ? colorC : a == Ln.y ? colorA : colorB;
    return c * pow(a, lightPatternPower);
}

// Function 1899
vec4 light(int index, in float luma, out float led, out vec4 ledll){
	float x = mod(float(index),COL)-(HCOL);
	float y = floor(float(index)/COL);
    x*=LED_SZ * 2.0f;
    y*=LED_SZ * 2.0f;
    y+=LED_SZ;
    
    led = tullynoise(vec2(x + SEED,y) / vec2(COL,ROW)) * (LED_SZ + luma * LED_SZ);
    float sprite = led * LED_SPRITE;
    ledll = vec4(x-sprite,x+sprite,y+sprite,y-sprite);
    
    return vec4(x-LED_SZ,x+LED_SZ,y+LED_SZ,y-LED_SZ);
}

// Function 1900
float softshadow(vec3 ro, vec3 rd, float mint, float tmax) {
	float res = 1.0;
	float t = mint;

	for (int i = 0; i < 16; i++) {
		float h = map(ro + rd * t).x;

		res = min(res, 8.0 * h / t);
		t += clamp(h, 0.02, 0.10);

		if (h < 0.001 || t > tmax) {
			break;
		}
	}
	return clamp(res, 0.0, 1.0);
}

// Function 1901
vec3 shade(vec3 pos, vec3 n, vec3 eyePos)
{
    const vec3 lightPos = vec3(4.0, 3.0, 5.0);
    const vec3 color = vec3(1.0, 1.0, 0.0);
    const float shininess = 40.0;

    vec3 l = normalize(lightPos - pos);
    vec3 v = normalize(eyePos - pos);
    vec3 h = normalize(v + l);
    float diff = dot(n, l);
    float spec = max(0.0, pow(dot(n, h), shininess)) * float(diff > 0.0);
    diff = max(0.0, diff);
    //diff = 0.5+0.5*diff;

    float fresnel = pow(1.0 - dot(n, v), 5.0);
    float ao = ambientOcclusion(pos, n);

//	return vec3(diff);
//    return vec3(diff*ao)*color + vec3(spec + fresnel*0.5);
    return vec3(diff*ao)*color;	
//    return vec3(diff*ao)*color + vec3(spec);
//    return vec3(ao);
//    return vec3(fresnel);
}

// Function 1902
float Shadow(vec3 p,vec3 n,vec3 l, float d)
{
    // float v;
    // int s;
    // bool h;
    // SphereTrace(p+0.1*n,l,d,h,s);

    // if (!h)
    //  return 1.0;

    // return 0.0;

    const float k = 20.0;

    float res = 1.0;
    float t = 0.1;

    for (int i = 0; i < MAX_STEPS; ++i) {

        if (res < 0.0 || t > d)
            break;
    
        float h = object(p+t*l);

        res = min(res, k * h / t);
        t += h;    
    }    

    return clamp(res, 0.0, 1.0);
}

// Function 1903
vec3 light(ray r,vec3 sunPos,vec3 orig){
    if(distance(r.ro,center)<atm.r){
    }else{
        float d1=sphere(r,atm,1.);
        if(d1==0.)return orig;
        r.ro+=r.rd*d1;
    }
    float d2=sphere(r,earth,1.);
    if(d2==0.)d2=sphere(r,atm,-1.);
    float viewDepth=0.;
    vec3 l=vec3(0.);
    for(int i=0;i<VIEW_SAMPLES;i++){
        vec3 p=r.ro+r.rd*(float(i)+0.5)/float(VIEW_SAMPLES+1)*d2;
        ray k=ray(p,normalize(sunPos-p));
        #ifdef EXPERIMENTAL_PLANET_SHADOW
        if(sphere(k,earth,1.)==0.){
        #endif
            float sunDepth=depth(k.ro,k.ro+k.rd*sphere(k,atm,-1.));
            viewDepth=depth(r.ro,p);
            vec3 transmitance=exp(-(sunDepth+viewDepth)*RGBScatter);
        
        
            l+=transmitance*density(p)*phase(dot(r.rd,normalize(sunPos-p)));
        #ifdef EXPERIMENTAL_PLANET_SHADOW
        }
        #endif
    }
    vec3 origTransmitance=exp(-viewDepth*RGBScatter);
    return orig*origTransmitance+l/float(VIEW_SAMPLES)*d2*sunInt*RGBScatter*scatterStrength;
}

// Function 1904
vec3 GetLight(vec3 p, vec3 rd, float curd, vec4 noise) 
{
	vec3 SScol = vec3(0.8, 0.4, 0.4);

    // Light 1
	vec3 lightCol = vec3(1.0, 0.1, 0.1);
	float d2;
    
    vec3 lightPos = vec3(0, 2, 6);
    vec3 l = normalize(lightPos-p);
    vec3 n = GetNormal(p);
	d2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);
    float dif = dot(n, l);
	float invDif = clamp(-dif, 0., 1.); 
    dif = clamp(dif, 0., 1.);

	vec3 light = (0.5 + dif*0.5)*SScol*d2*lightCol ;
	vec3 v = -rd;
	vec3 reflect = normalize(2.0 * dif * n - l); 
	float specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;
	float specular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;
	light += (vec3(specular) + specular2 * SScol)*lightCol;


    // Light 2
	lightCol = vec3(0.1, 0.1, 1.0);
 	lightPos = vec3(0, -2, -6);
    l = normalize(lightPos-p);
  	d2 = RayMarchOut(p+rd*(SURF_DIST*4. + noise.x*0.05), l);
    dif = dot(n, l);
	invDif = clamp(-dif, 0., 1.); 
    dif = clamp(dif, 0., 1.);
	
	light += (0.5 + dif*0.5)*SScol*d2*lightCol ;
	reflect = normalize(2.0 * dif * n - l); 
	specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 12.0) * dif;
	specular2 = pow(clamp(dot(reflect, v), 0.0, 1.0), 5.0) * dif;
	light += (vec3(specular) + specular2 * SScol)*lightCol;

    return light;
}

// Function 1905
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable.
    const int maxIterationsShad = 24; 
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = .001;  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), .0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;
    
    dist += hash31(ro + rd)*.007;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist); //  map(ro + rd*dist + hash31(ro + rd)*dist*.03);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        dist += clamp(h, .01, .25); 
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0. || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)
    return min(max(shade, 0.) + .05, 1.); 
}

// Function 1906
vec3 getVirtualLightContribution(vec2 uv, vec2 offsetUv, vec3 baseColor, float roughness, vec3 camHitNormal, vec3 camHitPosition, out float dotProduct, out float brdfRef)
{
    // Avoid hotspots from lights nearly touching geometry
    float minDistance = 0.2;
    
    vec3 lightPosition = UBOUNCE_POSITION(offsetUv*iResolution.xy).xyz*depthScale;
    
    // Diffuse
    float diffuse = saturate(dot(normalize(camHitNormal), normalize(lightPosition - camHitPosition)))*0.9;
    float mouseLocation = 0.1;
    #ifdef ANIMATE_CAMERA
    	mouseLocation += iTime/9.0;
    #endif

    #ifdef INTERACTIVE
    	mouseLocation += 0.002*iMouse.x;
    #endif
    vec3 camOrigin = vec3( 2.8*cos(0.1+.33*mouseLocation), 0.5 + 0.15*cos(0.37*mouseLocation), 2.8*cos(0.5+0.35*mouseLocation) );
    float specular = GGX(normalize(camHitNormal), -normalize(camHitPosition - camOrigin), normalize(lightPosition - camHitPosition), roughness, 0.1);
    
    
    float lightDistance = max(distance(lightPosition, camHitPosition), minDistance);
    float lightDistance2 = lightDistance*lightDistance;
    dotProduct = dot(reCalcNormalFast(uv), reCalcNormalFast(offsetUv));
    
    brdfRef = diffuse + specular;
    
    return ((UBOUNCE_COLOR(offsetUv*iResolution.xy).rgb))/lightDistance2;
}

// Function 1907
float shadow_march(vec4 pos, vec4 dir, float distance2light, float light_angle, inout vtx co)
{
	float light_visibility = 1.;
	float ph = 1e5;
    float td = dir.w;
	pos.w = map(pos.xyz, dir.xyz, co);
	for (int i = min(0, iFrame); i < 20; i++) 
    {
		dir.w += pos.w;
		pos.xyz += pos.w*dir.xyz;
		pos.w = map(pos.xyz, dir.xyz, co);
		float y = pos.w*pos.w/(2.0*ph);
        float d = (pos.w+ph)*0.5;
		float angle = d/(max(0.00001,dir.w-y-td)*light_angle);
        light_visibility = min(light_visibility, angle);
		ph = pos.w;
		if(dir.w >= distance2light) break;
		if(dir.w > maxd || pos.w < mind*dir.w) return 0.;
    }
	return 0.5 - 0.5*cos(PI*light_visibility);
}

// Function 1908
float abstract_glassy_field_cao(vec3 _1001, vec3 _1002)
{
    vec3 _1007;
    vec3 _1010;
    vec3 _1012;
    vec3 _1014;
    vec3 _1016;
    _1007 = _240;
    _1010 = _240;
    _1012 = _240;
    _1014 = _240;
    _1016 = _240;
    vec3 _1008;
    vec3 _1011;
    vec3 _1013;
    vec3 _1015;
    vec3 _1017;
    int _1019;
    float _1021;
    float _1023;
    bool _1025;
    int _1018 = 0;
    float _1020 = 0.0;
    float _1022 = 1.0;
    bool _1024 = true;
    for (; _1024; _1007 = _1008, _1010 = _1011, _1012 = _1013, _1014 = _1015, _1016 = _1017, _1018 = _1019, _1020 = _1021, _1022 = _1023, _1024 = _1025)
    {
        if (_1018 < 5)
        {
            float _1035 = 0.00999999977648258209228515625 + ((float(_1018) * 0.3499999940395355224609375) / 4.0);
            vec3 _1043 = _1016;
            _1043.x = _1002.x * _1035;
            vec3 _1044 = _1043;
            _1044.y = _1002.y * _1035;
            vec3 _1045 = _1044;
            _1045.z = _1002.z * _1035;
            vec3 _1056 = _1012;
            _1056.x = _1045.x + _1001.x;
            vec3 _1057 = _1056;
            _1057.y = _1045.y + _1001.y;
            vec3 _1058 = _1057;
            _1058.z = _1045.z + _1001.z;
            vec3 _1004 = _1058;
            float _1059 = abstract_glassy_field_map(_1004);
            _1008 = _1001;
            _1011 = _1045;
            _1013 = _1058;
            _1015 = _1002;
            _1017 = _1045;
            _1019 = _1018 + 1;
            _1021 = _1020 + ((_1035 - _1059) * _1022);
            _1023 = _1022 * 0.699999988079071044921875;
            _1025 = true;
        }
        else
        {
            return _f32_as_shared_Clamp_clamp(1.0 - _1020, 0.0, 1.0);
        }
    }
}

// Function 1909
float computeLightShadow(vec3 _lightPos, vec3 _pointPos, float _scale, float t)
{
    vec3 l2p = _pointPos-_lightPos;
    float far = min(CAM_FAR, length(l2p));
    return exp(-_scale*(far-shadows(_lightPos, normalize(l2p), 0.01, far, t)));
}

// Function 1910
vec3 Sample_SphLight_MIS2(vec2 s0, vec2 s1, float s2, vec3 V, vec3 p, vec3 N, vec3 albedo, float roughness, vec3 F0)
{
    float alpha = GGXAlphaFromRoughness(roughness);
    
    float ct; vec3 Lc, L0; float sang;
    Sample_SolidAngle(s0, p, LightPos, R2, /*out*/ ct, /*out*/ Lc, /*out*/ L0, /*out*/ sang);
    float pdf00 = 1.0/sang;

    vec3 L1; vec3 f1; float pdf11;
    Sample_GGX_R(s1, V, N, alpha, F0, /*out*/ L1, /*out*/ f1, /*out*/ pdf11);

    bool couldL1HitLight = dot(L1, Lc) > ct;
    
    vec3 f0 = Frostbite_R(V, N, L0, albedo, roughness, F0);
         f1 = Frostbite_R(V, N, L1, albedo, roughness, F0);

    float pdf01 = couldL1HitLight ? pdf00 : 0.0;
    float pdf10 = EvalPDF_GGX_R(V, N, L0, alpha);

    float w0, w1;
    #if 1
    w0 = Pow2(pdf00) / (Pow2(pdf00) + Pow2(pdf10));
    w1 = Pow2(pdf11) / (Pow2(pdf11) + Pow2(pdf01));        
    #elif 1
    w0 = (pdf00) / ((pdf00) + (pdf10));
    w1 = (pdf11) / ((pdf11) + (pdf01)); 
    #else
    w0 = 0.5; 
    w1 = 1.0 - w1;
    #endif

    float wn = couldL1HitLight == false ? 1.0 : w0 / (w0 + w1);

    bool doUseSmpl0 = s2 <= wn;

    float denom = doUseSmpl0 ? pdf00 * wn : pdf11 * (1.0 - wn);

    vec3 L = doUseSmpl0 ? L0 : L1;

    if(dot(N, L) <= 0.0 || denom == 0.0) return vec3(0.0);
    
    float t2; vec3 n2; vec3 a2; bool isLight2 = true;
    bool hit2 = Intersect_Scene(p, L, false, /*out*/ t2, n2, a2, isLight2);

    if(hit2 && isLight2)
    {
        if(doUseSmpl0)
            return f0 / denom * w0 * Radiance;
        else
            return f1 / denom * w1 * Radiance;
    }
}

// Function 1911
float mapLight(vec3 p, vec3 origin) {
    float d = 1000.;
    for (int i=0; i<lightsCount; i++)  d = min(d, length(p - getLightPos(origin, i)) - 0.02);
    return d;
}

// Function 1912
float calcAO( in vec3 pos, in vec3 nor )
{
	float ao = 0.0;
    for( int i=0; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
        ap *= sign( dot(ap,nor) );
        float h = hash1(float(i));
		ap *= h*0.3;
        ao += clamp( map( pos + nor*0.01 + ap ).x*1.0/h, 0.0, 1.0 );
    }
	ao /= 32.0;
	
    return clamp( ao*(4.0+nor.y), 0.0, 1.0 );
}

// Function 1913
vec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir1, vec3 lightDir2, vec3 lightCol1, vec3 lightCol2, float shadowMask1, float shadowMask2, float distance )
{
	// checker pattern
	vec3 albedoMain;	
	vec3 albedoVein;
	vec3 marbleAxis;
	vec3 check = fract((pos-vec3(0,-.18,0))*.5/1.5-.25)-.5;
	if ( check.x*check.y*check.z > .0 )
	{
		albedoMain = vec3(.3,.04,.02);
		albedoVein = vec3(1,.8,.5);
		marbleAxis = normalize(vec3(1,-3,2));
	}
	else
	{
		albedoMain = vec3(.8,.85,.9);
		albedoVein = vec3(.1,0,0);
		marbleAxis = normalize(vec3(1,2,3));
	}

	// marble pattern
/*	float marble = dot(pos,marbleAxis); // orientation (perp to seams)

	// multi-fractal noise
	vec3 mfp = pos*4.0; // noise frequency
	vec2 mfNoise = vec2(0);
	mfNoise += Noise(mfp);
	mfNoise += Noise(mfp*2.0)/2.0;
	mfNoise += Noise(mfp*4.0)/4.0;
	marble += mfNoise.x*.5; // noise amplitude
	
	marble *= 3.0; // adjust frequancy

//	vec3 albedo = vec3(1,.95,.9);
//	vec3 albedo = vec3(.7,.5,1);
//	vec3 albedo = vec3(.5,.3,.13);

	marble = abs(1.0-2.0*fract(marble)); // triangle wave
	marble = pow(smoothstep( 0.0, 1.0, marble ),20.0); // curve to thin the veins
*/

	// better marble
	vec3 mfp = (pos + dot(pos,marbleAxis)*marbleAxis*2.0)*2.0;
	float marble = 0.0;
	marble += abs(Noise(mfp).x-.5);
	marble += abs(Noise(mfp*2.0).x-.5)/2.0;
	marble += abs(Noise(mfp*4.0).x-.5)/4.0;
	marble += abs(Noise(mfp*8.0).x-.5)/8.0;
	marble /= 1.0-1.0/8.0;
	marble = pow( 1.0-marble,10.0); // curve to thin the veins
	
	vec3 albedo = mix( albedoMain, albedoVein, marble );


	vec3 ambient = envBrightness*mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient
//		ambient = mix( vec3(.03,.05,.08), vec3(.1), (-normal.y+1.0) ); // ambient
	// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3
	float aoRange = distance/20.0;
	
	float occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0
	occlusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve
	if ( Toggle(kAmbientOcclusion) )
		ambient *= occlusion*.8+.2; // reduce occlusion to imply indirect sub surface scattering

	float ndotl1 = max(.0,dot(normal,lightDir1));
	float ndotl2 = max(.0,dot(normal,lightDir2));
	float lightCut1 = smoothstep(.0,.1,ndotl1);//pow(ndotl,2.0);
	float lightCut2 = smoothstep(.0,.1,ndotl2);//pow(ndotl,2.0);

	vec3 light = vec3(0);
//	if ( Toggle(kDirectLight,3) )
	light += lightCol1*shadowMask1*ndotl1;
	light += lightCol2*shadowMask2*ndotl2;


	// And sub surface scattering too! Because, why not?
	float transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?
	float transmission1 = DistanceField( pos + lightDir1*transmissionRange )/transmissionRange;
	float transmission2 = DistanceField( pos + lightDir2*transmissionRange )/transmissionRange;
	vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);
	vec3 subsurface = vec3(1,.8,.5) * sslight;


	float specularity = 1.0-marble;
	//specularity = mix( specularity, Noise(pos/.02).x, .1 ); // add some noise
	
	vec3 h1 = normalize(lightDir1-ray);
	vec3 h2 = normalize(lightDir2-ray);
	float specPower = exp2(mix(5.0,12.0,specularity));
	vec3 specular1 = lightCol1*shadowMask1*pow(max(.0,dot(normal,h1))*lightCut1, specPower)*specPower/32.0;
	vec3 specular2 = lightCol2*shadowMask2*pow(max(.0,dot(normal,h2))*lightCut2, specPower)*specPower/32.0;
	
	vec3 rray = reflect(ray,normal);
	vec3 reflection = Sky( rray );
	
	
	// specular occlusion, adjust the divisor for the gradient we expect
	float specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0
	specOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve
	
	// prevent sparkles in heavily occluded areas
	specOcclusion *= occlusion;

	if ( Toggle(kReflectionOcclusion) )
		reflection *= specOcclusion; // could fire an additional ray for more accurate results
	
	float fresnel = pow( 1.0+dot(normal,ray), 5.0 );
	fresnel = mix( mix( .0, .01, specularity ), mix( .4, 1.0, specularity ), fresnel );
	
	vec3 result = vec3(0);

	// comment these out to toggle various parts of the effect
	light += ambient;

	if ( Toggle(kSubsurface) )
		light = mix( light, subsurface, .5 );//iMouse.y/iResolution.y );
	
	result = light*albedo;

	result = mix( result, reflection, fresnel );
	
	result += specular1 + specular2;

	return result;
}

// Function 1914
float compute_shadows(vec3 origin, vec3 n_light_direction, vec3 light_position)
{
    // TODO: Stop marching once light has been passed.
    // TODO: Use a point light or something!
    
    origin += n_light_direction * 0.005;	// Offset to avoid self-intersection
    
    vec3 point_of_intersection;
    if(find_intersection(origin, n_light_direction, 16, 0.05, 0, point_of_intersection))
    {
        return(0.0);
    }
    
    return(1.0);
}

// Function 1915
vec3 CalcLighting(Light light, Intersection i, vec3 origin)
{
	vec3 n = i.n;
	vec3 p = i.p;
	vec3 l = normalize(light.p-p);
	vec3 v = normalize(origin-p);
	vec3 h = normalize(l+v);
	float NdotL = saturate(dot(n,l));
	float NdotH = saturate(dot(n,h));
	vec3 diffuse = NdotL*i.diffuse;
	vec3 spec = pow(NdotH,8.0) * i.specular;
	float distA = 1.0-saturate(length(light.p-p)/light.radius);
	vec3 color;
	color = (diffuse+spec) * distA * light.color;
	
	float shadow = 1.0;
	Ray shadowRay;
	shadowRay.o = i.p;
	float lightDist = length(light.p-i.p);
	shadowRay.dir = (light.p-i.p)/lightDist;
	Intersection shadowI = SceneIntersection(shadowRay);
	if(shadowI.dist < lightDist)
	{
		shadow = 0.0;
	}
	color *= shadow;
	
	return color;
}

// Function 1916
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02 * fusLen;
  for (int i = 0; i < 50; i++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, 20. * h / d);
    d += 0.02 * fusLen;
    if (h < 0.001) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 1917
vec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, vec3 kdiffuse_kspecular_roughness )
{
	return add_light_contrib( albedo, l, n, v, Li, dwi, kdiffuse_kspecular_roughness.x, kdiffuse_kspecular_roughness.y, kdiffuse_kspecular_roughness.z );
}

// Function 1918
vec3 ComputeLightAttenuation(in vec3 pos)
{
    vec3 L = lightPos - pos;
    vec3 Ln = normalize(L);
    
    float att = getDistanceAtt(L,lightRadiusInvSqr);   
    return att * lightPower * ComputeLightPattern(Ln);
}

// Function 1919
float getSphereLightIntensity(float num) {
    return num > .5 ?
        clamp(fract(time)*10.-1., 0., 1.) :
		max(0., 1.-fract(time)*10.); 
}

// Function 1920
vec3 selfShadow(vec3 p, vec3 o)
{
    #ifndef SELF_SHADOWING
    	return vec3(1.0);
    #endif
    
    const int steps = 8;
    const float iSteps = 1.0 / float(steps);
    
    vec3 increment = o * iSteps;
    vec3 position = p;
    
    vec3 transmittance = vec3(1.0);
    
    for (int i = 0; i < steps; i++)
    {
        float od = calculateOD(position);
		position += increment;
        
        transmittance += od;
    }
    
    return exp2(-transmittance * scatterCoeff * iSteps);
}

// Function 1921
float getLight(vec2 p ,vec2 v, float t, float ts) {
    float d = length(l_pos-p);
    float a = dot(v, (l_pos-p)/d);
    if(d < t && a > cos(DA*0.5)) {
        return float(SAMPLES360)/(d+ts);
    }
    return 0.0;
}

// Function 1922
float softShadow(vec3 ro, vec3 rd, float start, float end, float k){

    float shade = 1.0;
    const int maxIterationsShad = 24;

    float dist = start;
    float stepDist = end/float(maxIterationsShad);

    // Max shadow iterations - More iterations make nicer shadows, but slow things down.
    for (int i=0; i<maxIterationsShad; i++){
    
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);

        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.
        dist += min(h, stepDist*2.);
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.001 || dist > end) break; 
    }

    // Shadow value.
    return min(max(shade, 0.) + 0.3, 1.0); 
}

// Function 1923
float softshadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t=0.01;
    for(int i=0; i<128; i++)
    {
        float h = map(ro + rd*t);
        if( h<0.001 )
            return 0.0;
        res = min( res, 200.*h/t );
        t += h;
        if(t>2.)
            break;
    }
    return res;
}

// Function 1924
vec3 directLight(vec3 pos){
    
    vec3 absorption = vec3(1.0);
    
    for(int i = 0; i < MaxSteps; i++){
        float dist = distanceEstimation(pos);
        pos -= LightDir * max(dist, StepSize);
        if(dist < StepSize) {
            float abStep = StepSize * randomFloat();
            pos -= LightDir * (abStep-StepSize);
            if(dist < 0.0){
                float absorbance = exp(-Density*abStep);
                absorption *= absorbance;
                if(maxV(absorption) < 1.0-MaxShadowAbso) break;
            }
        }
        
        if(length(pos) > SceneRadius) break;
    }
    return LightColor * max((absorption+MaxShadowAbso-1.0) / MaxShadowAbso, vec3(0));
}

// Function 1925
void Light_AddSpot( inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const vec3 vLightPos, const vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle, vec3 vLightColour )
{
    vec3 vPos = surface.vPos;
	vec3 vToLight = vLightPos - vPos;	
    
	vec3 vLightDir = normalize(vToLight);
	float fDistance2 = dot(vToLight, vToLight);
	float fAttenuation = 100.0 / (fDistance2);
	
	float fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );
    
    fShadowFactor *= Light_SpotFactor( vLightDir, vSpotDir, fSpotInnerAngle, fSpotOuterAngle );
	
	Light_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);    
}

// Function 1926
float shadow(vec3 ro, vec3 rd) {
	// based off of http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm
    float res = 1.0;
    float ph = 1e20;
    float tmin = 0.1;
    float tmax = 2.0;
    float k = 8.0;

    for (float t = tmin; t < tmax;) {
        vec2 h = sceneSDF(ro + rd * t);
        if (h.x < EPSILON) {
            return 0.0;
        }
        float y = (h.x * h.x) / (2.0 / ph);
        float d = sqrt((h.x * h.x) - (y * y));
        res = min(res, k * d / max(0.0, t - y));
        ph = h.x;
        t += h.x;
    }
    return res;
}

// Function 1927
void hitShadow(
    in vec3 startPos, in vec3 nvRayDir,
    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,
    out float lightPercent
){
    lightPercent = 1.0;
    float travel = 0.0;
    vec3 curPos = startPos;

    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {
        float sdCur = sdQuad(q00,q10,q11,q01, BOUNDARY_RADIUS, curPos);

        float curLightPercent = abs(sdCur)/(0.02*travel);
        lightPercent = min(lightPercent, curLightPercent);

        if (sdCur < MIN_DIST) {
            lightPercent = 0.0;
            break;
        }

        curPos += sdCur * nvRayDir;
        travel += sdCur;
        if (travel > MAX_DIST) {
            break;
        }
    }
}

// Function 1928
float softShadow(vec3 ro, vec3 lp, vec3 n, float k){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int iter = 24; 
    
    ro += n*.0015; // Bumping the shadow off the hit point.
    
    vec3 rd = lp - ro; // Unnormalized direction ray.

    float shade = 1.;
    float t = 0.; 
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;
    
    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);
    

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i = 0; i<iter; i++){

        float d = map(ro + rd*t);
        shade = min(shade, k*d/t);
        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        t += clamp(d, .01, .25); 
        
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (d<0. || t>end) break; 
    }

    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --
    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add 
    // AO also just for kicks. :)
    return max(shade, 0.); 
}

// Function 1929
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha,
                          vec3 p, vec3 eye, vec3 lightPos,
                          vec3 lightIntensity) {
    // Get normal vector at position p 
    vec3 N = estimateNormal(p);
    // Get direction of light to position p
    vec3 L = normalize(lightPos - p);
    // Get direction of camera to position p
    vec3 V = normalize(eye - p);
    // Get direction of reflection 
    vec3 R = normalize(reflect(-L, N));
    
    // Obtain dot product between light and normal 
    float dotLN = dot(L, N);
    // Obtain dot product between reflection and view ray 
    float dotRV = dot(R, V);
    
    // Light not visible from this point on surface
    if (dotLN < 0.0) {
        return vec3(0.0, 0.0, 0.0);
    }
    
    // Determine if light reflection is viewable 
    // from viewer
    if (dotRV < 0.0) {
        // If light reflection is opposite direction of viewer
        // Apply only diffuse lighting 
        return lightIntensity * (k_d * dotLN);
    }
    
    // Return phong lighting contribution 
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 1930
vec3 SampleLightMIS_d(Object light, int lightId, int ignoreObjId, vec3 P, vec3 N, vec2 s, float N_d, float N_h, bool sphericalLightIsTextured)
{
	vec3 V;
    vec3 L;
    float inversePDF_d;
    if (IsQuad(light)) {
        V = QuadLocalToWorld(s*2.0 - vec2(1.0), light) - P;
	    L = normalize(V);
		float distSqr = dot(V, V);
        inversePDF_d = GetQuadArea(light)*max(0.0, -dot(light.quadNormal, L))/distSqr;
    } else {
        // http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html
        vec3 pointToLight = light.pos - P;
		float radiusSqr = light.radius*light.radius;
        float sinThetaMaxSqr = radiusSqr/dot(pointToLight, pointToLight);
        float cosThetaMax = sqrt(1.0 - sinThetaMaxSqr);
        float cosTheta = cosThetaMax + (1.0 - cosThetaMax)*s.y;
        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
		if (sphericalLightIsTextured) {
			float dc = length(pointToLight);
			float ds = dc*cosTheta - sqrt(max(0.0, radiusSqr - dc*dc*sinTheta*sinTheta));
			float cosAlpha = (radiusSqr + dc*dc - ds*ds)/(2.0*dc*light.radius);
			float sinAlpha = sqrt(max(0.0, 1.0 - cosAlpha*cosAlpha));
			V = light.pos + light.radius*SampleHemisphere(-normalize(pointToLight), sinAlpha, cosAlpha, s.x) - P;
			L = normalize(V);
		} else {
			V = vec3(0);
			L = SampleHemisphere(normalize(pointToLight), sinTheta, cosTheta, s.x);
		}
        inversePDF_d = 2.0*PI*(1.0 - cosThetaMax);
	}
	inversePDF_d *= max(0.0, dot(N, L))/PI;
    if (inversePDF_d > 0.0 && IntersectScene(Ray(P, L), ignoreObjId) == lightId) {
		float PDF_d = 1.0/inversePDF_d;
		float PDF_h = 1.0;
	#if MIS_USE_POWER
		float b = MIS_power_b;
		return SampleLightColor(P + V, light)*pow(N_d*PDF_d, b - 1.0)/(pow(N_d*PDF_d, b) + pow(N_h*PDF_h, b));
	#else
		return SampleLightColor(P + V, light)/(N_d*PDF_d + N_h*PDF_h);
	#endif
	}
	return vec3(0);
}

// Function 1931
vec3 GetLightTerrain(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)
{                
  vec3 reflectDir = reflect( rayDir, normal );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);

  float occ = 1.;
  #ifdef PERFORM_AO_PASS
    occ = calcAO(shadowPos, normal );
  #endif

  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );


  #ifdef SHADOWS
    float shadow=1.;
  shadow = SoftShadow(shadowPos, sunPos);
  shadow = min(shadow, SoftShadowTower(shadowPos, sunPos, shadow));
  shadow = max(illuminance, shadow);
  dif*=shadow;
  #endif
    
  const vec3 sunColor = vec3(1.1, 0.53, 0.27); 
  lightTot += 3.*dif*sunColor;

  lightTot += .65*amb*vec3(0.35, 0.45, 0.6)*occ;  
  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.)*occ;
  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);
  lightTot = mix( lightTot, lightTot*2., fre );

  return clamp(lightTot, 0.22, 10.);
}

// Function 1932
float GroundAO(vec3 normal, vec3 pos, float dist) {
	float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
    
        float hr = 0.01 + dist * float(i) / 5.0;
        vec3 aopos =  normal * hr + pos;
        float dd = getDistance(aopos);
        occ += -(dd - hr)*sca;
        sca *= 0.35;
    }
    
    return saturate(1.0 - 3.0 * occ);    
}

// Function 1933
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.01;
  for (int j = 0; j < 30; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += max (0.01, h);
    if (sh < 0.05) break;
  }
  return sh;
}

// Function 1934
vec3 getSpecularLightColor( vec3 N, float roughness ) {
    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.
    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;
}

// Function 1935
void DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)
{
	float h = dot(sunLight,normal);
	float c = max(h, 0.0)+ambient;
	mat = mat * sunColour * c ;
	// Specular...
	if (h > 0.0)
	{
		vec3 R = reflect(sunLight, normal);
		float specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;
		mat = mix(mat, sunColour, specAmount);
	}
}

// Function 1936
vec3 evaluateLight(vec2 uv, out float areaPdf)
{
	vec3 srgb = texture(iChannel0, uv).xyz;
	areaPdf = 1.0;
	return LIGHT_POWER*pow(srgb, vec3(2.2));
}

// Function 1937
float SoftShadow(  vec3 origin,  vec3 direction )
{
  float res = 2.0, t = 0.0, h;
  for ( int i=0; i<32; i++ )
  {
    h = Map(origin+direction*t);
    res = min( res, 6.5*h/t );
    t += clamp( h, 0.07, 0.6 );
    if ( h<0.0025 ) break;
  }
  return clamp( res, 0.0, 1.0 );
}

// Function 1938
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = fScene( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1939
vec3 shade(float inLight, float n_h, float n_l, float n_v, float v_h)
{
  	return  one_pi*inLight*(n_l*rho_d+rho_s*D(alpha,ppp,n_h,K_ap)*G1(n_l)*G1(n_v)*Fresnel(F_0,F_1,v_h));
}

// Function 1940
float shadow_sample (vec3 org, vec3 dir) {
    float res = 1.0;
    float t = epsilon*200.0;
    for (int i =0; i < 100; ++i){
        float h = get_distance (org + dir*t);
		if (h <= epsilon) {
            return 0.0;
		}
        res = min (res, 32.0*h/t);
        t += h;
		if (t >= max_distance) {
      		return res;
		}
		
    }
    return res;
}

// Function 1941
vec3 shade( in vec3 pos, in vec3 nor, in vec3 ro, in vec3 rd, float dis, in float occ )
{
    // material
    float f = 1.0 + 0.5*fbm(96.0*pos);
    vec3 mate = vec3(f);

    // bump
    vec3 xnor = addbump( nor, 1.0, 0.25*pos );

    // lighting
    vec3 rgb = vec3(0.0);
    rgb += mate*vec3(0.50,0.55,0.60)*occ;
    rgb += mate*vec3(0.6,0.5,0.3)*3.0*occ*clamp(dot( xnor, lig ), 0.0, 1.0);

    // fog extintion
	rgb /= (1.0+dis);
    // fog inscattering
	rgb += vec3(0.53,0.57,0.50)*2.0*(1.0 - exp2(-0.25*dis));

	return rgb;
}

// Function 1942
vec3 calcLightingFast(vec3 r, vec3 s, vec3 t, vec2 uv) {
    return lightmap(min(getVoxel(r).light + 0.2, 15.));
}

// Function 1943
float resolveRayLightIntersection(sphere sun){
	vec3 OC=sun.pos-camera;
	float P=dot(OC,ray);
	float d=sqrt(pow(length(OC),2.0)+pow(P,2.0));
	return 1./d;
	
}

// Function 1944
float cao(in vec3 p, in vec3 n){
	
    float sca = 1., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.5/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 1945
light pointLight(vec3 position, float color, float intensity, float falloff) {
    return pointLight(position, vec3(color), intensity, falloff);
}

// Function 1946
vec3 calcLighting(vec3 col, vec3 p, vec3 n, vec3 r, float sh, float sp) {
    float d = max(dot(LIGHT_DIR,n),0.);
    float s = 0.;
    float sd = 1.;
    if(raymarch(p+LIGHT_DIR*SHADOW_BIAS,LIGHT_DIR,32) < MAX_DISTANCE)
        sd = 0.;
    if(sh > 0.)
        s = pow(max(dot(LIGHT_DIR,r),0.),sh)*sp;
    d *= sd;
    s *= sd;
    return (col*(LIGHT_AMB+LIGHT_COL*d))+(LIGHT_COL*s);
}

// Function 1947
vec4 shade(inout vec3 origin, inout vec3 ray) {
    vec3 lighting = vec3(0.2, 0.2, 0.2) * 5.0;
    vec3 lightingSpecular = vec3(0.0, 0.0, 0.0);
    
    float farPlane = 50.0;
    
	mat3 traced = trace(origin, ray, farPlane);
    vec3 t = traced[0];
    
    vec3 worldPos = origin + ray * t.x;
    
    vec3 normal = surfaceNormal(worldPos);
    
    float fresnel = 1.0 - max(dot(-ray, normal), 0.0);
    
    vec3 specular = normalize(reflect(ray, normal));
    
    if (t.y == -1.0) { /* sky */
        return vec4(0.0, 0.0, 0.0, 0.0);
    }
    
    vec4 diff = material(t.y, traced[1]);
        
    const int lightCount = 1;
    for (int i = -1; i <= lightCount; ++i) {
        float theta = iTime * 1.0 + float(i) / float(lightCount) * 6.28;

    	float modTimberPos = floor(worldPos.z/10.0+0.5) + float(i);
        vec3 lightPos = vec3(0.0, 2.0, 2.5+modTimberPos*10.0);
        
        vec3 surfaceToLight = lightPos - worldPos;
        float lightDist = length(surfaceToLight);
        surfaceToLight /= lightDist;
        

#ifdef ENABLE_SHADOWS
        float lightVisible = 0.0;
        mat3 lightTrace = trace(lightPos, -surfaceToLight, lightDist*0.999);
        if (lightTrace[0].y == -1.0) {
            //mat3 shadowTrace = trace(lightPos, -surfaceToLight, lightDist*0.9);
            lightVisible = 1.0;//min(shadowTrace[0].z * 16.0, 1.0);
        }
#else
        float lightVisible = 1.0;
#endif
        
        lightVisible *= max(dot(surfaceToLight, normal), 0.0);
        
        vec3 lightReflection = reflect(-surfaceToLight, normal);
        float lightSpecular = max(dot(-ray, lightReflection), 0.0);
        lightSpecular = min(pow(0.2 + lightSpecular, 4.0), 1.0);
        
        float lightPower = lightVisible * 1.0 / (1.0 + lightDist*lightDist*0.01);
        vec3 lightColour = vec3(1.0, 1.0, 1.0) * lightPower / float(lightCount);
        
        lighting += lightColour;
        lightingSpecular += lightSpecular * lightColour;
    }

    float fog = 1.0 - t.x / farPlane;
    
    float aoc = 1.0 - ambientOcclusion(worldPos, -ray);
    aoc = pow(max(aoc, 0.0), 8.0);
    
    vec3 final = aoc * fog * (diff.xyz * lighting) + lightingSpecular * 0.01;
    
    origin = worldPos + specular * 0.05;
    ray = specular;
                                 
    if (diff.w < 0.0) {
     	return vec4(lightingSpecular.xyz, 0.5);   
    }
    
    return vec4(final, diff.w * fresnel);
}

// Function 1948
vec3 compute_minecraft_light(TraceResult r, vec3 p , vec3 d)
{
    const vec3 grass_color = vec3(0.63, 1.0, 0.31);
    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);
    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);
    const vec3 sun_color = vec3(0.5, 0.5, 0.5);
    
    vec3 to_light1 = LIGHT1_POS - r.p;
    const float view_distance = 75.0;
    
    vec3 to_light2 = LIGHT2_POS - r.p;
    
    float sun_factor = max(0.0, dot(r.n, sun_dir));
    
    float light1_factor = compute_light1_factor(r.p, r.n);
    float light2_factor = compute_light2_factor(r.p, r.n);

    float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));
    vec3 fog_color = background(d);

    if (sun_factor > 0.0)
    {
         float sd = m_scale * (cloud_height - r.p.y) / sun_dir.y;
         if (traceVoxel(r.p, sun_dir, sd).hit)
             sun_factor = 0.0;
    }
   
    float ambient_factor = sample_ao(im_scale * r.vp, im_scale * r.p, r.n);

    float texel_noise = textureLod(iChannel3, im_scale * r.p * 0.5, 0.0).r;

    float grass_mix = 0.0;
    if (!voxel(r.vp + vec3(0, m_scale, 0)))
    {
         if (texel_noise * 4.0 + floor(fract(im_scale * r.p.y) * 16.0) > 15.0)
             grass_mix = 1.0;
         else
             grass_mix = max(0.0, r.n.y);
    }

    vec3 texel = vec3(texel_noise) * 0.3 + 0.7;
    vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);
    vec3 c = diffuse * (ambient_factor * ambient_color +
                        sun_factor * sun_color  +
                        light1_factor * LIGHT1_COLOR + 
                        light2_factor * LIGHT2_COLOR);

    return mix(c, fog_color, fog_factor);
}

// Function 1949
void light(inout float p, vec2 pv){
    vec2 lightPos = vec2(pv.x, pv.y);
    p *= 1.-smoothstep(0.0, 10., length(lightPos - vec2(sin(t), 0.0)));
}

// Function 1950
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  for (int j = 0; j < 10; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, 5. * h / d);
    d *= 1.7;
    if (h < 0.001) break;
  }
  return max (sh, 0.);
}

// Function 1951
vec3 LightDir(in mat3 t) 
{
    vec3 l = normalize(vec3(1.0, 1.0, -1.0));
    return t * l;
}

// Function 1952
vec4 shader(vec4 color, float dist, float radius){
	return vec4(mix(vec4(1.), color, .5 + min(.5, dist / radius / 2.)));
}

// Function 1953
vec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n, inout float fresnel) {
    n = normal(p,d);
    vec3 lpos = vec3(.1,9,7);
    vec3 l = normalize(lpos);

    float diff = clamp(dot(n,l),0.,1.);
    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 8.5);
    fresnel = mix(.0, .9, fresnel);
    
    vec3 h = vec3(.01);
    if(m==1.) h = vec3(0.690,0.408,0.012);
    if(m==2.) h = vec3(0.012,0.306,0.549);
    if(m==3.) h = vec3(0.161,0.129,0.173);
    if(m==3.) {
        h = mix(vec3(0.161,0.129,0.173),vec3(0.690,0.271,0.620),g5*4.);
    }

    return diff*h;
}

// Function 1954
vec3 LightSpaceToLightUV (vec3 lightPosition)
{
    // calculate the uv from the light position. X is flipped
    vec3 uv;
    uv.xy = lightPosition.xz;
    uv.x *= -1.0;
        
    // apply x axis modulus to make the light repeat
	uv.y = mod(uv.y + directionalLightModulus * 0.5, directionalLightModulus) - directionalLightModulus * 0.5;   

    // apply scaling of uv over distance to fake projection
	uv.xy /= (1.0 + lightPosition.y * directionalLightUVDistanceScale);   
    
    // calculate the instance index
    uv.z = floor((lightPosition.z + directionalLightModulus * 0.5) / directionalLightModulus);
    
    // return adjusted uv coordinates
    return uv;
}

// Function 1955
v3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}

// Function 1956
float GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )
{
	C_Ray shadowRay;
	shadowRay.vDir = vLightDir;
	shadowRay.vOrigin = vPos;

	C_HitInfo shadowIntersect;
	Raymarch(shadowRay, shadowIntersect, fLightDistance,25);
													     
	return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );           
}

// Function 1957
float ao(vec3 i) {
	vec3 n = normal(i);
    float t = 0.;
    for (int j = 0; j < 7; j++) {
    	t=abs(t-map(i+n).x);    
    }
    return max(t,1.);
}

// Function 1958
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    for( int i=0; i<8; i++ )
    {
        //float h = 0.01 + 0.22*float(i)/7.0;
        float h = 0.01 + 0.21*float(i)/7.0;
        occ += (h-map( pos + h*nor )).x;
    }
    return clamp( 1.0 - 5.8*occ/8.0, 0.0, 1.0 );    
}

// Function 1959
void computeLighting(
    in float diffuseCoefficient,
    in float specularCoefficient,
    in float specularExponent,
    in vec3 lightColor,
    in vec3 texColor,
    in vec3 nvNormal,
    in vec3 nvFragToLight,
    in vec3 nvFragToCam,
    out vec3 diffuse,
    out vec3 specular
) {
    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));
    valDiffuse *= diffuseCoefficient;

    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);
    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);
    valSpecular *= specularCoefficient;

    diffuse = valDiffuse * texColor * lightColor;
    specular = valSpecular * lightColor;
}

// Function 1960
bool intersectShadow (in Ray ray, in float dist) {
    Result ball1 = sphereIntersect (ray, vec3 (1.5, -1., 2.0), 1., 0);
    Result ball2 = sphereIntersect (ray, vec3 (1., -1.5, -1.0), .5, 3);
    Result ball3 = sphereIntersect (ray, vec3 (-1., -1.25, -2.0), .75, 6);
    Result ball4 = sphereIntersect (ray, vec3 (-.75, -1.25, .0), .75, 7);
    Result ball5 = sphereIntersect (ray, vec3 (1., -.5, -1.0), .5, 3);
    Result ball6 = sphereIntersect (ray, vec3 (1., .5, -1.0), .5, 3);
    Result ball7 = sphereIntersect (ray, vec3 (1., 1.5, -1.0), .5, 3);

    Result res = minResult (ball1, ball2);
    res = minResult (ball3, res);
    res = minResult (ball4, res);
    res = minResult (ball5, res);
    res = minResult (ball6, res);
    res = minResult (ball7, res);

    if (res.dist > .0001 && res.dist < dist)
        return true;

    return false;
}

// Function 1961
void computeLighting(
    in float diffuseCoefficient,
    in float specularCoefficient,
    in float specularExponent,
    in vec3 lightColor,
    in vec3 texColor,
    in vec3 nvNormal,
    in vec3 nvFragToLight,
    in vec3 nvFragToCam,
    out vec3 litColor
) {
    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));
    valDiffuse *= diffuseCoefficient;

    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);
    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);
    valSpecular *= specularCoefficient;

    litColor = valDiffuse*texColor*lightColor + valSpecular*lightColor;
}

// Function 1962
float sphereLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )
{
	vec3 L				= spherePos - pos;
	vec3 centerToRay	= dot( L, r ) * r - L;
	vec3 closestPoint	= L + centerToRay * clamp( sphereRad / length( centerToRay ), 0.0, 1.0 );	
	vec3 l				= normalize( closestPoint );
	vec3 h				= normalize( V + l );
	
	NoL				= clamp( dot( N, l ), 0.0, 1.0 );
	float HoN		= clamp( dot( h, N ), 0.0, 1.0 );
	float HoV		= dot( h, V );
	
	float distL		= length( L );
	float alpha		= roughness * roughness;
	float alphaPrime	= clamp( sphereRad / ( distL * 2.0 ) + alpha, 0.0, 1.0 );
	
	float specD		= specTrowbridgeReitz( HoN, alpha, alphaPrime );
	float specF		= fresSchlickSmith( HoV, f0 );
	float specV		= visSchlickSmithMod( NoL, NoV, roughness );
	
	return specD * specF * specV * NoL;
}

// Function 1963
float softShadow( vec3 pos, vec3 l )
{
    float tmin = 0.2;
    float tmax = 6.0;
    float k = 8.0;		// small value produces more penumbra
    float sh = 1.0;		// initially not shadow
    
    float t = tmin;
    for( int i=0; i<64; i++ )
    {
        float d = max( scene( pos + t*l ).x, 0.0 );
        sh = min( sh, k*d / t );
        t += clamp( d, 0.02, 0.1 );
        if( d < 0.001 ) break;
    }
    
    return clamp( sh, 0.0, 1.0 );
}

// Function 1964
float MarchShadowRay(vec3 aSamplePos, vec3 aLightPos, float aRand)
{
    vec3 vRD = aLightPos - aSamplePos;
    float vMaxMarchDist = min(SHADOW_FAR, length(vRD));
    vRD = normalize(vRD);
    
    float vTrI = 1.0;
    
    float vNormRandStep = aRand * gcRcpShadowSteps;
    float vP = gcRcpShadowSteps;
    float vD = 0.0;
    float vNextD;
    
    for (int vN = 0; vN < SHADOW_STEPS; ++vN)
    {
        vNextD = pow(vP + vNormRandStep, SHADOW_EXP) * vMaxMarchDist;
        
        float vSS = vNextD - vD;
    	vec3 vPos = aSamplePos + vRD * vD;   

        vec2 vDens = VolumeDensity(vPos);
        float vSampleE = vDens.x + vDens.y;
        float vOpticalDepth = vSampleE * vSS;
        float vTr = exp(-vOpticalDepth);
        if (vPos.y >= 1.5)
        {
            vTr = 0.0;
        }
        
        vTrI *= vTr;
        if (vTrI < 0.00)
        {
            vTrI = 0.0;
            break;
        }
        vD = vNextD; 
        vP += gcRcpShadowSteps;
    }

    return vTrI;
}

// Function 1965
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<20; i++ )
    {
		float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0., 0.1 );
        if(t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1966
float shadow(vec3 rpos, vec3 rdir) {
	float t = 1.0;
	float sh = 1.0;

	for (int i = 0; i < SHADOW_ITERS; i++) {
		vec3 pos = rpos + rdir * t;
		float h = scene(pos);
		if (h < 0.01) return 0.0;
		sh = min(sh, h/t*8.0);
		t += max(h, SHADOW_QUALITY);
	}
	
	return sh;
}

// Function 1967
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
		float h = doModel( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1968
vec3 shade( in vec3 p, in vec3 d, in vec3 e )
{
    // Get the distance for that gentle blend at the horizon.
    float l = length(p-e);
    // Get the sun direction and sky color once, and pass it around.
    vec3 ld = sunDir();
    vec3 s = sky(d,ld);
    
    // Take care of the appearance of culled stuff--they're sky now.
    if(l > MAX_DEPTH) return s;
    
    // Get the ID of the object we're shading, and make a place
    // to store the final result.
    vec4  id = distID(p,false);
    vec3 result;
    
    // Get the normal and create a general Oren Nayar term to be
    // the shade functions' village bicycle, right next to the
    // light direction, which is the village Razor scooter.
    vec3 n = norm(p,false);
    vec3 i = light(p,d,e,n,ld);
 
       
            
        if(id.t == ID_SAND)	result = shadeSandR(p,d,e,n,i,ld,l);
    else
        if ( id.t==ID_ROCK )
        {
            result = texture(iChannel2,id.zw/vec2(.2,20.)).rgb
                 * (.5 + .5*texture(iChannel1,id.zw/vec2(2.,100.)).r)*i
                ;
        }
    else
        result = shadeSandR(p,d,e,n,i,ld,l);
    shadeScene(result,false,id.t,p,l,n,id.zw,i,ld,d);  
    // Mix this shaded color with the color of the sky at far distances,
    // so we don't have that ugly plane() @ MAX_DEPTH edge.
	return mix(s,result,smoothstep(0.0, MAX_DEPTH*.125, clamp(MAX_DEPTH-l,0.0,MAX_DEPTH*.125)));
}

// Function 1969
vec3 getCameraOrigin(float t) {
	float gt = mod(t, 15.);
    float  r = 1.-(smoothstep(3.,6.,gt)*(1.-smoothstep(12.,15.,gt)));
    float  a = radians(35.*(2.+t*.1));
    return vec3(cos(a),0.,sin(a))*mix(7050.,15000.,r);   
}

// Function 1970
float sdf_shadow(float sdf, float size, vec2 light_dir)
{
    vec2 n = sdf_normal(sdf);
    float thresh = size * max(abs(dFdx(sdf)), abs(dFdy(sdf)));
    float mask = clamp(sdf/thresh, 0., 1.);
    return clamp(1. - sdf/size, 0., 1.) * clamp(-dot(light_dir, n), 0., 1.) * mask;
}

// Function 1971
Light getLight(int i) { return lights[i]; }

// Function 1972
float softshadow( in vec3 ro, in vec3 rd, in float k )
{
    float res = 1.0;
    float t = 0.0;
    for( int i=0; i<64; i++ )
    {
        vec4 kk;
        float h = map(ro + rd*t, kk);
        res = min( res, k*h/t );
        if( res<0.001 ) break;
        t += clamp( h, 0.01, 0.2 );
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1973
vec4 ts_shadow_lookup( TrnSampler ts, sampler2D ch, vec3 x )
{
    vec2 uv = ts_uv_centered( ts, x );
    if( ts_is_uv_safe( uv ) )
    {
		vec2 res = vec2( textureSize( ch, 0 ) );
    	vec2 aspect = vec2( res.y / res.x, 1 );
    	float aspect_shadow = min( 0.666666667, res.x / res.y - 1. );
        uv = ( .5 * uv + .5 ) * aspect_shadow * aspect + vec2( aspect.x, 0 );
 		return textureLod( ch, uv, 0. );
    }
    else
        return vec4(0);
}

// Function 1974
float cAO(in vec3 p,in vec3 n){float s=1.5,o=0.;
 for(float i=1.;i<6.;i++){float h=i*.5/6.;        
  float d=df(p+n*h);o+=(h-d)*s;s*=.7;}
 return clamp(1.- o,0.,1.);}

// Function 1975
float getAO(in vec3 pos, in vec3 nor)
{
	float rz = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.02 + 0.025*float(i);
        vec3 aopos =  nor*hr + pos;
        float dd = map(aopos);
        rz += -(dd-hr)*sca;
        sca *= 0.8;
    }
    return clamp(rz*-3.+1., 0., 1.);
}

// Function 1976
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 1977
float getAO(vec3 hitp, vec3 normal, float dist)
{
    vec3 spos = hitp + normal * dist;
    float sdist = map(spos).dist;
    return clamp(sdist / dist, 0.0, 1.0);
}

// Function 1978
float GrndSShadow (vec3 ro, vec3 rd)
{
  float sh = 1.;
  float d = 2.;
  for (int i = 0; i < 10; i++) {
    vec3 p = ro + rd * d;
    float h = p.y - GrndHt (p.xz, 0);
    sh = min (sh, 20. * h / d);
    d += 4.;
    if (h < 0.01) break;
  }
  return clamp (sh, 0., 1.);
}

// Function 1979
bool IsLight(Object obj)
{
    return max(max(obj.emissive.x, obj.emissive.y), obj.emissive.z) > 0.0;
}

// Function 1980
vec4 shade(in vec3 origin, in vec3 direction, in float samplev, in float depth,
        in float iteration_count, in vec2 pixel_coordinates, in vec2 fragCoord)
{
        vec3 position = origin + direction * depth;
        float daylight = 7. * sin(iTime * .3);

        vec4 color = mix(background(pixel_coordinates,fragCoord), vec4(1., .7, .6, .1),
                daylight * .1);

        vec3 light_position = vec3(0., daylight, 10.);

        color.gb += pow(iteration_count * .021, 1.75) * vec2(1.75, 1.15);

        if (samplev < EPSILON) {
                vec3 normal = calculate_normal(position);

                float lambert_factor = dot(normal,
                        normalize(light_position));
                lambert_factor = .3 + .7 *
                        clamp(lambert_factor, 0., 1.);

                float shadow_factor =
                        pow(shadow(position, light_position, .3), 2.);

                color = texture(iChannel1, position.xz) *
                        pow(ambient_occlusion(position, normal, .3),
                                7.) * shadow_factor;

                color = .15 * color + .85 * lambert_factor * color;
                color *= 1.5 * vec4(1., .88, .47, 1.);
        }

        float weight = step(MAXIMUM_DEPTH, depth);
        return mix(color, fog(color, distance(position, origin), direction,
                normalize(light_position)), weight);
}

// Function 1981
vec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {
	vec3 sunDir = normalize(vec3(6, 10, -4) - p),
	     n = calcNormal(p, d);
	return data.mat * (max(0., dot(sunDir, n)) * mix(.4, 1., calcShadow(p, vec3(6, 10, -4))) + max(0., dot(sunDir * vec3(-1, 0, -1), n)) * .3) * dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)) * vec3(2, 1.6, 1.4) * exp(-length(p) * .14);
}

// Function 1982
vec3 sampleLight( const in vec3 ro ) {
    vec3 n = randomSphereDirection() * lightSphere.w;
    return lightSphere.xyz + n;
}

// Function 1983
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05 || d > dstFar) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 1984
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )
{
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    vec3  view = normalize(-rd);
    vec3  lig1 = normalize(vec3(1.0,0.7,0.9));
    vec3  lig2 = normalize(vec3(1.0,0.9,0.9)*-1.);
    
    float spc1 = gaussianSpecular(lig1, view, nor, 0.95)*0.5;
    float dif1 = max(0., orenNayarDiffuse(lig1, view, nor, -20.1, 1.0));
    float sha1 = 0.0; if( dif1>0.01 ) sha1=calcSoftshadow( pos+0.01*nor, lig1 );
    vec3  col1 = vec3(2.,4.2,4.);
    lin += col1*spc1+dif1*col1*sha1;
    
    float spc2 = gaussianSpecular(lig2, view, nor, 0.95);
    float dif2 = max(0., orenNayarDiffuse(lig2, view, nor, -20.1, 1.0));
    float sha2 = 0.0; if( dif2>0.01 ) sha2=calcSoftshadow( pos+0.01*nor, lig2 );
    vec3  col2 = vec3(2.00,0.05,0.15);
    lin += col2*spc2+dif2*col2*sha1;

    // ambient light
    //-----------------------------
    lin += vec3(0.05);

    
    // surface-light interacion
    //-----------------------------
    vec3 col = mal*lin;

    return col;
}

// Function 1985
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    vec3 N = getNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 1986
SPointLight GetLightPoint1()
{
	return SPointLight
	(
		vec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),
		vec3(0.7,0.3,0.7)
	);
}

// Function 1987
void initLights() {
    #if (NUM_LIGHTS != 0)

    lights[0] = light(1.,//1 = point, 0 = direction
                      10.0,//importance
                      vec3(0.));//point pos or direction


    #endif
}

// Function 1988
float ComputeAO(const vec3 p, const vec3 n)
{
    float ao = 0.0;
    
    int   i = 0;
    float r,d;
    RayIntersection ri;
    while (i<AO_NUM_STEPS)
    {
        i++;
        d = AO_STEP_SIZE * float(i);
    	ri = GetNearestShape(p + n*d);
        if (ri.shape.isEmissive)
        { 
            ao = 0.;
            break;
        }
        
        r = ri.dist;
   
        ao += max(0.0, (d-r)/d);
    }
    
    return clamp(1.0 - ao*AO_INTENSITY, 0., 1.);
}

// Function 1989
float softShadow(vec3 ro, vec3 lp, float k, float t){

    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.
    const int maxIterationsShad = 48; 
    
    vec3 rd = lp-ro; // Unnormalized direction ray.

    float shade = 1.;
    float dist = .0025*(t*.125 + 1.);  // Coincides with the hit condition in the "trace" function.  
    float end = max(length(rd), 0.0001);
    //float stepDist = end/float(maxIterationsShad);
    rd /= end;

    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest 
    // number to give a decent shadow is the best one to choose. 
    for (int i=0; i<maxIterationsShad; i++){

        float h = map(ro + rd*dist);
        //shade = min(shade, k*h/dist);
        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.
        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.
        dist += clamp(h, .07, .5); 
        
        // Early exits from accumulative distance function calls tend to be a good thing.
        if (h<0.0 || dist > end) break; 
    }

    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. 
    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)
    return min(max(shade, 0.) + .15, 1.); 
}

// Function 1990
float castRayAO( in vec3 ro, in vec3 rd)
{
    float tmin = 0.1;
    
    float t = tmin;
    float precis = 0.005;
    for( int i=0; i<MAXDEPTH; i++ )
    {
        float res = map( ro+rd*t );
        if( res<precis  ) 
        {
#if MINWEIGHTMODE>1
        return max(res, 0.0);
#elif MINWEIGHTMODE>0
        return 1. / max(t, 1.001);
#else
        return max(t, 0.0);
#endif
        }

        t += res;
    }
#if WEIGHTMODE>0
    return 1. / max(t, 0.001);
#else
    return 1. / max(t, 1.001);
#endif

}

// Function 1991
float calcShadow(vec3 p, vec3 lightPos) {
    // Thanks iq.
    vec3 rd = normalize(lightPos - p);
	float res = 0.9, t = 0.0;
    for (float i = -0.1; i < SHADOW_STEPS; i++)
    {
		float h = map(p + rd * t).d;
        res = min(res, 2.0 * h / t);
        t += h;
        if (res < 0.0009 || t > 15.0) break;
    }
    return clamp(res, -0.1, 0.9);
}

// Function 1992
vec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){
 vec3 l=normalize(vec3(1.,.7,.9));//light direction
 float o=max(0.,dot(n,l)),
 c=max(0.,dot(n,normalize(l-i))),
 s;if(c>.01)s=shadow(p+.01*n,l); 
 const vec3 LigCol=vec3(1.);//light color
 vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  
 r+=s*c*pow(o,40.);//specular
 //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap
 r*=exp(-.01*d*d);//fog  
 return r;}

// Function 1993
void shadeSurface(inout Hit hit){
    
    vec3 color = BACKGROUND_COLOR;
    
    if (hit.isBackground) {
        hit.color = color;
        return;
    }

    vec3 ref = reflect(hit.ray.direction, hit.normal);

    #ifdef DEBUG
        color = hit.normal * 0.5 + 0.5;
    #else 
        color = doLighting(
            hit.model,
            hit.pos,
            hit.normal,
            ref,
            hit.ray.direction
        );
    #endif

    hit.color = color;
}

// Function 1994
void drawLight2(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 l2Norm;
    float light2T = traceSphere(ray.pos - LIGHT2_POS, ray.dir, 
                                        LIGHT2_RADIUS, l2Norm);
    
    if(light2T < cur_ctxt.t)
    {
        cur_ctxt.t=light2T;

        cur_ctxt.materialType = EMISSION;
        cur_ctxt.color=LIGHT2_COLOR;
        cur_ctxt.n = l2Norm;
        cur_ctxt.alpha = 0.0;
    }
}

// Function 1995
vec3 shadeWater(ray r, float t){
    vec3 hit_p = r.o + r.d * t;
    vec3 n = waterGrad(hit_p);
    
    float cosi = dot(-r.d, n);
    vec3 refl_dir = r.d + 2.0 * cosi * n;
    vec3 refl_col = sphereLookUp( refl_dir );
    float refr_depth = 0.752 * cosi;
    vec3 refr_col = mix( WATER_TINT, vec3(-0.8), clamp( refr_depth, 0.01, 0.999 ) );
    
    float icosi = 1.0 - cosi;
    float rschlick = 0.02 + 0.98 * icosi * icosi * icosi * icosi * icosi;
    
    ray refl;
    refl.o = hit_p;
    refl.d = refl_dir;
    float refl_hit = traceRefl(refl);

    return mix(refr_col, refl_col * refl_hit, rschlick);
    
}

// Function 1996
float ComputeShadow(const vec3 p, const vec3 n, const vec3 L, const float d2l)
{
    float shadow = 1.0;
    
    Ray r;
    r.o = p + n*SHADOW_BIAS; // Without this, the ray doesn't leave the surface
    r.d = L;
    
    RayIntersection ri = CastRay(r, d2l);
    if (ri.shape.type != NO_SHAPE) shadow = 0.0;
    else shadow = clamp(ri.shadow, .0,1.0);

    return shadow;
}

// Function 1997
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {
    // bounding volume
    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<24; i++ )
    {
		float h = map( ro + rd*t ).x;
        float s = clamp(8.0*h/t,0.0,1.0);
        res = min( res, s*s*(3.0-2.0*s) );
        t += clamp( h, 0.02, 0.2 );
        if( res<0.004 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 1998
vec3 shade(vec3 diff, float m, vec3 N, vec3 L, vec3 V)
{
  vec3 H = normalize(V + L);
  float F = 0.05 + 0.95 * pow(1. - dot(V, H), 5.);
  float R = F * pow(max(dot(N, H), 0.), m);
  return diff + R * (m + 8.) / 8.;
}

// Function 1999
float calculateAO(in vec3 pos, in vec3 nor)
{
	float sca = 3., occ = 0.;
    for(int i=0; i<5; i++){
    
        float hr = .01 + float(i)*.5/4.;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 2000
void materialShader(
    in float diffuseCoefficient,
    in float specularCoefficient,
    in float specularExponent,
    in vec3 lightColor,
    in vec3 texColor,
    in vec3 nvNormal,
    in vec3 nvFragToLight,
    in vec3 nvFragToCam,
    out vec3 diffuseContribution,
    out vec3 specularContribution
) {
    //compute diffuse intensity
    float intensityDiffuse = clamp(dot(nvNormal, nvFragToLight), 0.0, 1.0);
    intensityDiffuse *= diffuseCoefficient;

    //compute specular intensity
    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);
    float intensitySpecular = pow(clamp(dot(nvNormal, blinnH), 0.0, 1.0), specularExponent);
    intensitySpecular *= specularCoefficient;

    //output diffuse and specular values
    diffuseContribution = intensityDiffuse * texColor * lightColor;
    specularContribution = intensitySpecular * lightColor;
}

// Function 2001
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
		float h = dstScene( ro + rd*t );
        res = min( res, 32.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 2002
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for(int i=0; i<25; i++)
    {
    	float h = map(ro + rd*t, false).x;
        res = min(res, 4.5*h/t);
        t += clamp(h, 0.01, 0.12);
        if( h<0.001 || t>tmax ) break;
    }
    return smoothstep(0.0, 0.8, res);
}

// Function 2003
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.02;
  for (int j = VAR_ZERO; j < 20; j ++) {
    h = SceneDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 2004
vec2 GetDistanceShadowCasters( const in vec3 vPos )
{
	vec2 vResult = vec2(1000.0, -1.0);

	vec3 vCandlestickLocalPos = vPos - vCandlestickPos;	

	vec2 vCandlestick = GetDistanceCandlestick(vCandlestickLocalPos);
	if(vCandlestick.x < vResult.x)
	{
		vResult = vCandlestick;
	}
	
	vec2 vSphere = GetDistanceSphere(vPos);
	if(vSphere.x < vResult.x)
	{
		vResult = vSphere;
	}
	
	
	vec3 vPapereLocalPos = RotateY(vPos, g_PaperRotSin, g_PaperRotCos);
	
	vec2 vPaper = GetDistancePaper(vPapereLocalPos);
	if(vPaper.x < vResult.x)
	{
		vResult = vPaper;
	}

	
	#ifdef ENABLE_MIRROR
	
	vec3 vMirrorLocalPos = vPos - vec3(0.0, 0.0, 3.5);
	vMirrorLocalPos = RotateY(vMirrorLocalPos, g_MirrorRotSin, g_MirrorRotCos);
	
	vec2 vMirrorStand = GetDistanceMirrorStand(vMirrorLocalPos);
	if(vMirrorStand.x < vResult.x)
	{
		vResult = vMirrorStand;
	}
	
	
	vec3 vMirrorPaneLocalPos = vMirrorLocalPos - vec3(0.0, 2.7, 0.0);	
	vMirrorPaneLocalPos = RotateX(vMirrorPaneLocalPos, g_MirrorTiltSin, g_MirrorTiltCos);
	
	vec2 vMirror = GetDistanceMirror(vMirrorPaneLocalPos);
	if(vMirror.x < vResult.x)
	{
		vResult = vMirror;
	}
	#endif	

	return vResult;
}

// Function 2005
vec3 GetLight( vec3 vLightPos, vec3 vLightColour, const in vec3 vRayOrigin,  const in vec3 vRayDir )
{    
    vec3 vToLight = vLightPos - vRayOrigin;
    float fPointDot = dot(vToLight, vRayDir);
    fPointDot = clamp(fPointDot, 0.0, 100.0);

    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;
    float fDist = length(vClosestPoint - vLightPos);
	return sqrt(vLightColour * 0.5 / (fDist * fDist));    
}

// Function 2006
float ao(vec3 ro, vec3 norm, float k)
{
    float res = 0.0;
    float f = 0.1;
    for(int i = 1; i<6; i++)
    {
        vec3 rp = ro + f*float(i)*norm;
     	res+=(1.0/pow(2.0,float(i)))*(f*float(i)-map(rp).a);    
    }
	return 1.0-k*res;
}

// Function 2007
float drawLight(vec3 lp, vec3 rd, vec3 ro, float td, float pulse)
{
    float res = 0.0;
    if(td > distance(lp,ro))
    {
		float dlp = length(cross(lp-ro, lp-(ro+rd)))/length((ro+rd)-ro);
		res=max(exp(-dlp*64.0*((1.0-pulse)+0.5)),0.0);
    }
    return res;
}

// Function 2008
void TileShadowColors(int tile, out vec3 color0, out vec3 color1)
{
    color0 = color1 = vec3(0);
    if(tile == 1)
    {
        color0 = vec3(244,106,252)/255.0*.6;
        color1 = vec3(244,106,252)/255.0*.4;
    } else if(tile == 2)
    {
        color0 = vec3(106,244,252)/255.0*.6;
        color1 = vec3(106,244,252)/255.0*.4;
    }
    else if(tile == 3)
    {
        color0 = vec3(244,252,106)/255.0*.6;
        color1 = vec3(244,252,106)/255.0*.4;
    }
    else if(tile == 4)
    {
        color0 = vec3(244,252,106)/255.0*.6;
        color1 = vec3(244,252,106)/255.0*.4;
    }
}

// Function 2009
vec3 lightScattering(vec2 uv, vec2 lightPos, vec3 sun)
{    
    vec2 deltauv = vec2(uv - lightPos);
    vec2 st = uv;
    uv = uv * 2. - 1.;
    uv.x *= iResolution.x / iResolution.y;
    deltauv *= 1. /  float(NUM_SAMPLES) * DENSITY;
    float illuminationDecay = 1.;
    vec3 result = vec3(0.);

    for(int i = 0; i < NUM_SAMPLES; i++)
    {
        st -= deltauv;
        float lightStep = textureLod(iChannel1, st, 0.).a
            		* smoothstep(2.5, -1., length(uv-sun.xy));

        lightStep *= illuminationDecay * WEIGHT;

        result += lightStep;

        illuminationDecay *= DECAY;
    }
    
    return result * (SUN_COLOR) * .2;
}

// Function 2010
bool MarchShadowRay( vec3 start, vec3 dir, out vec3 pos CACHEARG )
{
    // Same as MarchCameraRay except lower tolerances because artifacts will barely be noticeable,
    // and we don't care about hit pos being accurate.
    // Caller should check bounds because sometimes we want to call this when we already know we're inside the bounds.
    
    pos = start + dir * SHADOW_EPSILON;
    
    float prevMarchDist = SHADOW_EPSILON;
    float prevSurfaceDist = BlobDist( start CACHE );
    
    for ( int i = 0; i < MAX_SHADOW_RAYMARCH_STEPS; i++ )
    {
        float surfaceDist = BlobDist( pos CACHE );
        if ( surfaceDist <= EPSILON )
            return true;
        
        float gradientAlongRay = (prevSurfaceDist - surfaceDist) / prevMarchDist;
        float safeGradient = max( gradientAlongRay, MIN_GRADIENT_FOR_SHADOW_RAYS );
        
        float addDist = (surfaceDist + SHADOW_EPSILON) / safeGradient;
        prevMarchDist = addDist;
        
        prevSurfaceDist = surfaceDist;
        pos += dir * addDist;

        vec3 relPos = pos - BLOB_BOUNDING_CENTER;
        relPos *= BLOB_BOUNDING_SCALE;
        if ( dot( relPos, relPos ) > BLOB_BOUNDING_RADIUS_SQR )
            return false;
	}
    
    return true;
}

// Function 2011
float shadow(vec3 ro) {
    vec3 lightpos = getlightpos();
    float lightlen = length(ro-lightpos);
    vec3 light = (ro-lightpos)/lightlen;
    
    float shadow = 0.0;
    vec2 box = iBox(ro-vec3(0,0.5,0),-light,vec3(4.0,0.5,4.0));
	box.y = min(box.y,lightlen);
    ivec4 piece = tracebricks(ro,-light,box.x,box.y);

    if (box.y < box.x+0.01) {
        shadow = 1.0;
    }
    
    return shadow;
}

// Function 2012
vec3 shade( vec2 fragCoord )
{
    // add some depth based on screen position (hack)
    float zscr = dot(fragCoord/iResolution.xy-.5,fragCoord/iResolution.xy-.5);
    zscr = .75*(.25-zscr);
    
    // process one layer of the fractal at a time so that we can apply different amounts of parallax to each
    for( float layer = 2.; layer < MAX_ITERS; layer++ )
    {
        float parallaxZ = layer-1.; parallaxZ = 4.5*parallaxZ*parallaxZ + zscr;
        vec2 off = vec2( cos(.33*iTime), sin(.133*iTime)) * 180./parallaxZ;
        
        if( intersectsLayer( fragCoord + off, layer ) )
        {
            return layerCol(layer);
        }
    }
    // bg
    return layerCol(10.);
}

// Function 2013
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float hardness )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<32; i++ )
    {
		float h = dstScene( ro + rd*t );
        res = min( res, hardness*h/t );
        t += clamp( h, 0.06, 0.30 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 2014
float ao(vec3 p, vec3 n, float d){
  	float o=1.0,ii=5.0;
  	for(int i=0;i<5;i++){
    	vec3 tmpV=p+n*(ii*d);
    	float tmp=map(tmpV);
    	if(tmp<0.0) tmp=0.0;
    	o-=(ii*d-tmp)/pow(2.0,ii);
    	ii=ii-1.0;
  	}
  	return o;
}

// Function 2015
float castShadowRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 9.5 + rs*0.5) * ri;
	float t = -1.0;
	float res = 10.0;
	
    // first step we check noching	
	vec2 mm = step( dis.xy, dis.yx ); 
	dis += mm * ris;
    pos += mm * rs;
	
    // traverse regular grid (2D)	
	for( int i=0; i<6; i++ ) 
	{
		float ma = map(pos);
		
        // test capped cylinder		
		vec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.009;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t = (-b - sqrt( h ))/a;
			if( (ro.y+t*rd.y)<ma )
			{
				res = 0.0;
    			break; 
			}
		}
		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}

	return res;
}

// Function 2016
vec3 lighting(vec4 color, vec2 pbr, vec4 pos, vec4 dir, vec4 norm, float shadow) 
{
	vec3 albedo = color.xyz;
	norm.w = dir.w;
    vec3 N = norm.xyz;
	vec4 ambient_color = ambient_occlusion(pos, norm);
	
	float metallic = pbr.x;
	vec3 F0 = vec3(0.04); 
	F0 = mix(F0, albedo, metallic);
	
	//reflectance equation
	vec3 Lo = vec3(0.0);
	vec3 V = -dir.xyz;
	
	
	{ //ambient occlusion contribution
		float roughness = pbr.y;
		vec3 L = normalize(norm.xyz);
		vec3 H = normalize(V + L);
		vec3 radiance = ambient_color.xyz;        
		
		// cook-torrance brdf
		float NDF = DistributionGGX(N, H, roughness);        
		float G   = GeometrySmith(N, V, L, roughness);      
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       
		
		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
		vec3 specular     = numerator / max(denominator, 0.001);  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(N, L), 0.0);                
		Lo += (kD * albedo / PI + specular) * radiance * NdotL;
	}
	
	vec3 sun_color = sky_color(light);

	{ //light contribution
		float roughness = pbr.y;
		vec3 L = normalize(light);
		vec3 H = normalize(V + L);
		vec3 radiance = sun_color*shadow;        
		
		// cook-torrance brdf
		float NDF = DistributionGGX(N, H, roughness);        
		float G   = GeometrySmith(N, V, L, roughness);      
		vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       
		
		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - metallic;	  
		
		vec3 numerator    = NDF * G * F;
		float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);
		vec3 specular     = numerator / max(denominator, 0.001);  
			
		// add to outgoing radiance Lo
		float NdotL = max(dot(N, L), 0.0);                
		Lo += (kD * albedo / PI + specular) * radiance * NdotL;
	}
	
	return Lo;
}

// Function 2017
float calcShadowFactor(vec3 p, vec3 norm, vec3 lightDir)
{
    float t = .0;
    vec3 rayStart = p + norm + eps*2.0;
        for (int i =0; i<16;i++)
        {
            vec3 sP = rayStart - lightDir * t;
            float dist = scene(sP);
            if(dist < eps)
            {
                return 1.0;
            }
            t+=dist;
        }
    return 0.0;
}

// Function 2018
vec3 shade(Ray ray, vec2 fragCoord) {
 
    Hit scn = raymarch(ray);
    float x = iMouse.x / iResolution.x;
    if(iMouse.x == 0.) x = .5;
    
    vec3 col = vec3(0.);
    
    if((fragCoord.x / iResolution.x) <= x) {
        
        col = vec3(scn.dst) / FAR_PLANE;
        
    } else {

        col = vec3(scn.iter) / float(MAX_ITERATIONS);
        
    }
    
    return col;
    
}

// Function 2019
float softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<24; i++ )
    {
		float h = dstScene( ro + rd*t ).dst;
        res = min( res,32.0*h/t );
        t += clamp( h, 0.05, 0.50 );
        if( h<0.001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 2020
vec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)
{
   vec3 color = vec3(0.0);
   int id = -1;
   i = false;
   //vec3 toLight = (lightf-hit);
   //float sqdist = dot(toLight,toLight);
   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);
   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;
 
   if(diffuse>0.0)
   {
      float ldist =distance(lightf,hit);// sqrt(sqdist);
      float sh = 1000.0;//distance(lightf,hit);
      intersectscene(hit + normal * 0.0001, L, sh, id, false);           
      if(sh>ldist)
         {color += cl * (diffuse/(ldist))*0.32; i = true;}
   }
   return color;
}

// Function 2021
vec4 MarchLight(in Ray ray) {//remaining, total, weighted min, steps
    ray.pos += LIGHT_eps*Normal(ray.pos);
    ray.vel = LIGHT_dir(ray);//point towards light
    float d;
    bool exit = false;
    
	vec4 dist = vec4(-1, 0, MARCH_maxl, 0);//remaining, total, weighted min, steps
    for (int i = 0; i < LIGHT_itr /*&& d > MARCH_eps && dist.x < MARCH_maxl*/; i++) {
    	d = Map(ray.pos).x;
        if (d > LIGHT_dist(ray)) {//touches light
            d = LIGHT_dist(ray);
            exit = true;
        }
        dist.y += d;
        dist.z = min(d/dist.y, dist.z);
        dist.w++;
        
        ray.pos += d*ray.vel;
        if (exit || !(d > MARCH_eps && dist.y < MARCH_maxl)) break;
    }
    dist.x = LIGHT_dist(ray);
	return dist/MARCH_norm.yywz;
}

// Function 2022
float texShade(vec3 p, in vec3 n){
    
    vec3 col = texCol(p, n);
    return dot(col, vec3(0.299, 0.587, 0.114));
}

// Function 2023
void
paintVoxelAO (inout vec4 color, in vec2 p, in ivec3 coord, in float alphaScale)
{
    float ao = 0.;
    float t = MAX_SDF_DISTANCE;
    
    bool opaqueLeft, opaqueRight, opaqueBottom, opaqueTop;
    opaqueLeft = opaqueRight = opaqueBottom = opaqueTop = false;
    
    if (isVoxelAtCoordOpaque(coord + ivec3(-1,0,0)))
    {
        opaqueLeft = true;
        ao += AO_Falloff((1.-(p.x + 1.)*.25));
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(1,0,0)))
    {
        opaqueRight = true;
        ao += AO_Falloff(1.-(-(p.x - 1.)*.25));
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(0,-1,0)))
    {
        opaqueBottom = true;
        ao += AO_Falloff(1.-(p.y + 1.)*.25);
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(0,1,0)))
    {
        opaqueTop = true;
        ao += AO_Falloff(1.-(-(p.y - 1.)*.25));
    }
    
    
    if (isVoxelAtCoordOpaque(coord + ivec3(-1,-1,0)) && !(opaqueBottom || opaqueLeft))
    {
        float a = 1.-clamp(customLength(p.x + 1., p.y + 1.)*.25, 0., 1.);
        ao += AO_Falloff(a);
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(1,-1,0)) && !(opaqueBottom || opaqueRight))
    {
        float a = 1.-clamp((customLength(-p.x + 1., p.y + 1.)*.25), 0., 1.);
        ao += AO_Falloff(a);
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(-1,1,0)) && !(opaqueTop || opaqueLeft))
    {
        float a = 1.-clamp(customLength(p.x + 1., -p.y + 1.)*.25, 0., 1.);
        ao += AO_Falloff(a);;
    }
    if (isVoxelAtCoordOpaque(coord + ivec3(1,1,0)) && !(opaqueTop || opaqueRight))
    {
        float a = 1.-clamp(customLength(-p.x + 1., -p.y + 1.)*.25, 0., 1.);
        ao += AO_Falloff(a);
    }
    
    vec4 voxelColor = vec4(0, 0, 0, alphaScale *  clamp(ao*.3, 0., 1.));
    //voxelColor.rgb *= voxelColor.a;
    //blendOver(fragColor, fragColor.rgb, voxelColor.rgb, fragColor.a, voxelColor.a);
    color = mix(color, voxelColor, voxelColor.a * (1.0 - color.a));
    ;//color.rgb *= (1. - clamp(ao*.3, 0., 1.) * alphaScale);
    
}

// Function 2024
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
	float res = 1.0;
    float t = mint;
    for(int i = 0; i < 32; i++)
    {
		float h = scene_dist(ro + rd*t);
        res = min(res, 2.0 * h / t);
        t += clamp(h, 0.02, 0.10);
        if(h < 0.001 || t>tmax ) 
            break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 2025
float softShadow(vec3 ro, vec3 rd, float maxDist) {
    float total = 0.;
    float s = 1.;
    
    for (int i = 0; i < SHADOW_STEPS; ++i) {
        float d = scene(ro + rd * total);
        if (d < EPS) {
            s = 0.;
            break;
        }
        if (maxDist < total) break;
        s = min(s, SHADOW_SOFTNESS * d / total);
        total += d;
    }
    
    return s;
}

// Function 2026
vec2 softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    vec2 res = vec2(1.,1.);
    float t = mint;
    for( int i=0; i<32; i++ )
    {
        SDObject hit=mapScene( ro + rd*t ,-1,false);
        float h = hit.d;
        #ifdef ENABLE_TRANSPARENCY
        if(hit.mat.type>0 && hit.mat.trans>0.)
        {
            res.y=min(res.y,1.-hit.mat.trans);
        }
        #endif
        res.x = min( res.x, (32.0*h/t) );
        t += clamp( h, 0.00001, 0.99999 );
        if( h<(0.00001) || t>tmax ) break;
    }
    return clamp( res,1.2-res.y, 1.0 );

}

// Function 2027
float light(vec3 n, vec3 l)
{
    //return dot(n,normalize(l))*.5+.5;
    return max(dot(n,normalize(l)),0.);
}

// Function 2028
float sdf_apply_light(float sdf, vec2 dir)
{
    vec2 grad = normalize(vec2(dFdx(sdf), dFdy(sdf)));
    return dot(dir, grad);
}

// Function 2029
float ObjSShadow (vec3 ro, vec3 rd, float dMax)
{
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  for (int j = VAR_ZERO; j < 30; j ++) {
    h = ObjDf (ro + d * rd);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += h;
    if (sh < 0.05 || d > dMax) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 2030
Result lightIntersect (in Ray ray) {
	return sphereIntersect (ray, lightPos(), lightSize(), 5);
}

// Function 2031
float calcAO2( in vec3 pos, in vec3 nor, in vec2 pix )
{
	float ao = 0.0;
    for( int i=0; i<32; i++ )
    {
        vec3 ap = forwardSF( float(i), 32.0 );
		ap *= sign( dot(ap,nor) ) * hash1(float(i));
        ao += clamp( map( pos + nor*0.05 + ap*0.2 )*100.0, 0.0, 1.0 );
    }
	ao /= 32.0;
	
    return clamp( ao, 0.0, 1.0 );
}

// Function 2032
vec3 lighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)
{
  
	float sh = shadow(pos+normal*.2,  sunLight);
    vec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;
    float occ = calcOcc(pos, normal);

    
    // Ambient...
	col += mat * SUN_COLOUR  * abs(-(normal.y*.14)) * occ;
    
    normal = reflect(eyeDir, normal); // Specular...
    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * sh * specular* occ;

	return min(col, 1.0);
}

// Function 2033
float shadow(vec3 from, vec3 increment)
{
	const float minDist = 1.0;
	
	float res = 1.0;
	float t = 1.0;
	for(int i = 0; i < SHADOW_ITERATIONS; i++) {
		float m;
        float h = distf2(from + increment * t,m);
        if(h < minDist)
            return 0.0;
		
		res = min(res, 8.0 * h / t);
        t += SHADOW_STEP;
    }
    return res;
}

// Function 2034
void accumulate_lightmap(inout vec4 fragColor, ivec2 address)
{
    if (uint(address.x) >= LIGHTMAP_SIZE.x || uint(address.y) >= LIGHTMAP_SIZE.y/4u)
        return;
    if (iFrame >= NUM_LIGHTMAP_FRAMES + NUM_POSTPROCESS_PASSES)
        return;

    if (postprocess(fragColor, address))
        return;
    
    int region = iFrame & 3;
    int base_y = region * int(LIGHTMAP_SIZE.y/16u);
    if (uint(address.y - base_y) >= LIGHTMAP_SIZE.y/16u)
        return;

    address.y = (address.y - base_y) * 4;
    vec4 light = vec4
        (
            texelFetch(iChannel0, address + ivec2(0,0), 0).x,
            texelFetch(iChannel0, address + ivec2(0,1), 0).x,
            texelFetch(iChannel0, address + ivec2(0,2), 0).x,
            texelFetch(iChannel0, address + ivec2(0,3), 0).x
		);

    vec4 weights = step(vec4(0), light);
    vec4 values = max(light, 0.);
    
    LightmapSample total = decode_lightmap_sample(fragColor);
    accumulate(total, LightmapSample(weights, values));
    fragColor = encode(total);
}

// Function 2035
float softShadow(vec3 pos, vec3 l, float r, float f, float td) {
	float d;
	vec3 p;
	float o = 1.0, maxI = 10., or = r;
	float len;
	for (float i=10.; i>1.; i--) {
		len = (i - 1.) / maxI;
		p = pos + ((l - pos) * len);
		r = or * len;
		d = clamp(df(p), 0.0, 1.0);
		o -= d < r ? (r -d)/(r * f) : 0.;
		
		if(o < 0.) break;
	}
	return o;
}

// Function 2036
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )
{
    vec3 col = mal.rgb;
    vec4 shr = vec4(1.0);
    
    // cross with ray dir for a velvety sort of effect
    vec4 shn = sh_project(cross(nor,rd));
    
    col *= 10.0 * vec3(shade_probe(shr, shn)); 

    return col;
}

// Function 2037
float softshadow( in vec3 ro, in vec3 rd, float k, in float time )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<32; i++ )
    {
        float h = map(ro + rd*t, time);
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 2038
float sampleLightSourcePdf(in vec3 x, vec3 ns, in vec3 wi, float d, float cosAtLight) {
    vec3 s = light.pos - vec3(1., 0., 0.) * light.size.x * 0.5 -
        				 vec3(0., 0., 1.) * light.size.y * 0.5;
    vec3 ex = vec3(light.size.x, 0., 0.);
    vec3 ey = vec3(0., 0., light.size.y);
    
    SphQuad squad;
    SphQuadInit(s, ex, ey, x, squad);
    return 1. / squad.S;
}

// Function 2039
float softshadow(in vec3 ro, in vec3 rd)
{
    float res = 1.0;
    float t = 0.0;
    for (int i = 0; i < SOFT_SHADOW_STEPS; ++i)
    {
		vec3 pos = ro + rd * t;
        float h = map(pos).x;
        res = min(res, float(SOFT_SHADOW_STEPS) * h / t);
        if(res < 0.0001)
		{
	    	break;
		}
        t += clamp(h, 0.01, 0.2);
    }
    return saturate(res);
}

// Function 2040
function SetShaderConstant1I(u,x){m.uniform1i(m.getUniformLocation(sB.mProgram,u),x);}

// Function 2041
vec3 sampleLightSource(		in vec3 x,
                          	in vec2 xi,
                       		out LightSamplingRecord sampleRec) {
    vec2 minp = vec2(objects[0].params_[0], objects[0].params_[1]);
    vec2 maxp = vec2(objects[0].params_[2], objects[0].params_[3]);
    vec2 size = maxp - minp;
    vec3 p_local = vec3(mix(minp, maxp, xi), 0.0);
    vec3 n_local = vec3(0.0, 0.0, 1.0);
    vec3 p_global = toVec3( objects[0].transform_*vec4(p_local, 1.0) );
    vec3 n_global = toVec3( objects[0].transform_*vec4(n_local, 0.0) );
    
    float pdfA = 1.0 / (size.x*size.y);
    sampleRec.w = p_global - x;
    sampleRec.d = length(sampleRec.w);
    sampleRec.w = normalize(sampleRec.w);
    float cosAtLight = dot(n_global, -sampleRec.w);
    vec3 L = cosAtLight>0.0?getRadiance(xi):vec3(0.0);
    sampleRec.pdf = PdfAtoW(pdfA, sampleRec.d*sampleRec.d, cosAtLight);
    
	return L*0.3;
}

// Function 2042
vec4 lighting( vec4 color, vec3 ro, vec3 rd, vec3 normal, float shadow) {
    vec3 lightpos = getlightpos();
    vec3 light = normalize(ro-lightpos);
    float ambient = ambientlight;
    
    float diffusion = dot(-light,normal);
    
    vec3 sp = pow(clamp(dot(-light,reflect(rd,normal)),0.0,1.0),25.0)*vec3(0.5,0.5,0.6);
    
    float lighting = clamp(diffusion*shadow,ambient,1.0);
    
    color.xyz = min(color.xyz*lighting+sp*shadow,1.0);
    return color;
}

// Function 2043
float calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    // bounding volume
    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );

    float res = 1.0;
    float t = mint;
    for( int i=ZERO; i<16; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( res<0.005 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 2044
LightSampleResult SampleLight(vec3 fragPos, vec3 normal, vec3 toEye, vec3 toLight, vec3 lightColor, Material material, bool useShadows)
{
    float dnl = dot(normal, toLight);
    LightSampleResult result;
    result.contrib = vec3(0.);
    result.isShadowed = false;
    if (dnl <= 0.)
    {
        return result;
    }
    float toLightLength = length(toLight);
    float ooToLightLength = 1./toLightLength;
    dnl *= ooToLightLength;
    vec3 toLightN = toLight*ooToLightLength;
    float softShadows = 1.;
    if (useShadows)
    {
        RayPayLoad rpl = RayMarch(fragPos + 0.1 * normal, toLightN, 0.);
        if (rpl.hitScene)
        {
            result.isShadowed = true;
            return result;
        }
        softShadows = 1. - smoothstep(0., 1., 10.*(0.1 - rpl.minDistToScene));
    }
    vec3 hvec = normalize(toLightN+toEye);
    vec3 f0 = vec3(0.005);
    vec3 fresnel = FresnelTermApprox(toEye, hvec, f0);
    if (material.roughness < 1.)
    {
        float D = MicrofacetDistribution(hvec, normal, material.roughness);
        result.specularContrib = fresnel * D;
    }
    else
    {
        result.specularContrib = vec3(0.);
    }
    result.diffuseContrib = (1./PI) * (1. - fresnel) * material.diffuse;
	result.diffuseContrib *= lightColor;
    result.contrib = (result.specularContrib+result.diffuseContrib)*(dnl*ooToLightLength*ooToLightLength);
    result.contrib *= softShadows;
    return result;
}

// Function 2045
vec3 shade(in vec3 col, in vec3 ro, in vec3 rd, in vec3 n, in float t, in int o, in sph l, in mat lmat) {
    // get material
    int m = getMaterial(o);
    mat mt = matLib[m];

    // get light properties
    vec3 lv = l.l - ro,
         nlv = normalize(lv);
    float ld = length(lv),
        sa = solidAngle(ld, l.r),
        ca = abs(sin(sa) / cos(sa));

    // IDS
    vec3 d, gi;
    if (o == pln1.d) {
        float ids1 = float(ids(ro, l.l, sph1, d));
        vec3 dhl = d - ro,
             surfDir = normalize(dhl);
        // treat it like a diffuse light source with the color of the light bouncing off the sphere
        gi = ids1 * pow(Lambertian(n, surfDir), 4.) * matLib[sph1.m].r * lmat.e / (1. + dot(dhl, dhl)) * 10.;
        ambient *= clamp(sqrt(sd(ro, sph1).d), 0., 1.);
    } else if (o == sph1.d) {
        // repeat for other objects
        float ids1 = float(ids(ro, l.l, pln1, d));
        vec3 dhl = d - ro,
             surfDir = normalize(dhl);
        // treat it like a diffuse light source with the color of the light bouncing off the plane
        gi = ids1 * pow(Lambertian(n, surfDir), 4.) * matLib[pln1.m].r * lmat.e / (1. + dot(dhl, dhl)) * 1.;
        ambient *= clamp(sqrt(sd(ro, pln1).d), 0., 1.);
    }
    
    // "Ratio of Solid Angles" shadows
    float rosa = ROSA(ro, l, sph1);
    
    // mul reflection color for 1st bounce, add 1st surface emissive
    return col * schlick(matLib[_air].f, mt.f, dot(n, rd)) +
           gi +
           rosa * lmat.e * mt.r * ggx(n, -rd, nlv, 1., 1.) / (1. + ld*ld) +
           mt.e +
           ambient;
}

// Function 2046
float shadow(vec4 P,vec3 R)
{
    float S = 0.;
    P = vec4(P.xyz,0);
    float E = .5;
 	for(int i = 0;i<10;i++)
    {
        
        P += vec4(R,1)*E;
        float H = height(P.xy);
        if (H<P.z)
        {
            S = min((H-P.z)*9.,S);
        }
    }
    return S;
}

// Function 2047
vec4 GetLightingDataWeightsForDepth( vec4 baseLightingDataSampleWeights, float depth, vec4 shadowDataSamples[4] )
{
    #if DEPTH_WEIGHTED_LIGHTING_INTERPOLATION
    vec4 weights;
    float totalWeight = 0.0;
    for ( int j = 0; j < 4; j++ )
        weights[j] = baseLightingDataSampleWeights[j] * WeightForDepthDiff( depth, shadowDataSamples[j].w );
    weights /= dot( weights, vec4( 1.0 ) );
    return weights;

    #else

    return baseLightingDataSampleWeights;
    #endif
}

// Function 2048
vec3 compute_minecraft_light(TraceResult r, vec3 p , vec3 d)
{
    const vec3 grass_color = vec3(0.63, 1.0, 0.31);
    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);
    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);
    const vec3 sun_color = vec3(0.5, 0.5, 0.5);
    
    vec3 to_light1 = LIGHT1_POS - r.p;
    const float view_distance = 75.0;
    
    vec3 to_light2 = LIGHT2_POS - r.p;
    
    float sun_factor = max(0.0, dot(r.n, sun_dir));
    
    float light1_factor = compute_light1_factor(r.p, r.n);
    float light2_factor = compute_light2_factor(r.p, r.n);

    float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));
    vec3 fog_color = background(d);

    if (sun_factor > 0.0)
    {
         float sd = m_scale * (cloud_height - r.p.y) / sun_dir.y;
         if (traceVoxel(r.p, sun_dir, sd).hit)
             sun_factor = 0.0;
    }
   
    float ambient_factor = sample_ao(im_scale * r.vp, im_scale * r.p, r.n);

    float texel_noise = textureLod(iChannel2, im_scale * r.p * 0.5, 0.0).r;

    float grass_mix = 0.0;
    if (!voxel(r.vp + vec3(0, m_scale, 0)))
    {
         if (texel_noise * 4.0 + floor(fract(im_scale * r.p.y) * 16.0) > 15.0)
             grass_mix = 1.0;
         else
             grass_mix = max(0.0, r.n.y);
    }

    vec3 texel = vec3(texel_noise) * 0.3 + 0.7;
    vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);
    vec3 c = diffuse * (ambient_factor * ambient_color +
                        sun_factor * sun_color  +
                        light1_factor * LIGHT1_COLOR + 
                        light2_factor * LIGHT2_COLOR);

    return mix(c, fog_color, fog_factor);
}

// Function 2049
float ObjSShadow (vec3 ro, vec3 rd)
{
  float sh, d, h;
  sh = 1.;
  d = 0.1;
  for (int j = 0; j < 40; j ++) {
    h = ObjDf (ro + rd * d);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += min (0.3, 3. * h);
    if (sh < 0.001) break;
  }
  return 0.6 + 0.4 * sh;
}

// Function 2050
vec3 shader1(){
	float t=iTime;
	vec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	vec2 p2=p;
	
	p.y /= 0.25;
	p.x/=0.25;
	
	
	vec3 color = vec3(2.0,0.8,0.3-1.07*p.y)*(1.0-0.25*length(p));	//cambia valores de fondo y hace gradiente
	



	float y=0.5;
	float x=t*0.5;
	x =	(-mod(x,4.5)+2.1);
	vec2 origen1=vec2(x,y);
	x=t*0.5;
	x =	(mod(x,4.5)-2.1);
	vec2 origen2=vec2(x,y);
	//para trabajar mejor con la operacion modulo, se multiplica la coordenada
	// actual ,comprendiada entre -1 y 1, por un entero y se desacha la parte 
	//decimal
	//pintado por franjas
	int posY= int(floor(p.y*4.0));
	
	//la segunda entrada del modulo indicara la division del espacio
	if(int(mod(float(posY),2.0))==0){
		corazon(origen1,p,1.00,color);
	}else{
		corazon(origen2,p,1.0,color);
	}
	return color;
}

// Function 2051
vec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in float id, in vec3 uvw, in float dis )
{
    vec3 ref = reflect(rd,nor);
    float occ = occlusion( pos, nor );
    float fre = clamp(1.0+dot(rd,nor),0.0,1.0);
    
    occ = occ*0.5 + 0.5*occ*occ;
    
    vec3 lin = vec3(0.0);
    lin += 1.0*vec3(0.6,0.6,0.6)*occ;
    lin += 0.5*vec3(0.3,0.3,0.3)*(0.2+0.8*occ);
    lin += 0.3*vec3(0.5,0.4,0.3)*pow( fre, 2.0 )*occ;
    lin += 0.1*nor.y + 0.1*nor;

    float dif = clamp( nor.y, 0.0, 1.0 ) * shadow( pos, vec3(0.0,1.0,0.0) );

    lin = lin*0.7 + 0.8*dif;
    
    vec3 mate = 0.6 + 0.4*cos( 10.0*sin(id) + vec3(0.0,0.5,1.0) + 2. );
    vec3 te = textureBox( iChannel0, 0.25*uvw, nor );
    vec3 qe = te;
    te = 0.1 + 0.9*te;
    mate *= te*1.7;
    
    float h = id / float(NUMSPHEREES);
    mate *= 1.0-smoothstep(0.5,0.6,sin(50.0*uvw.x*(1.0-0.95*h))*
                                   sin(50.0*uvw.y*(1.0-0.95*h))*
                                   sin(50.0*uvw.z*(1.0-0.95*h)) );

    vec3 col = mate*lin;

    float r = clamp(qe.x,0.0,1.0);
    col += 0.2 * r * pow( clamp(dot(-rd,nor), 0.0, 1.0 ), 4.0 ) * occ;
    col += 0.4 * r * pow( clamp(reflect(rd,nor).y, 0.0, 1.0 ), 8.0 ) * dif;

    
    //col *= 1.5*exp( -0.05*dis*dis );
    
    return col*0.8;
}

// Function 2052
float calcSoftshadowTerrain( in vec3 ro, in vec3 rd, float k )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=0; i<16; i++ )
    {
        float h = mapTerrain(ro + rd*t ).x;
        res = min( res, smoothstep(0.0,1.0,k*h/t) );
        t += clamp( h, 0.04, 0.1 );
		if( res<0.01 ) break;
    }
    return clamp(res,0.0,1.0);
}

// Function 2053
float dlight(vec3 p)
{
    const float r = .35, h = .6;
    float ds = length(p - vec3(1,abs(sin(iTime*.9))*h+r,-1.)) - r;
    return max(0., ds);  
}

// Function 2054
float softshadow(vec3 ro,vec3 rd) 
{
    float sh = 1.;
    float t = .02;
    float h = .0;
    for(int i=0;i<12;i++)  
	{
        if(t>20.)continue;
        h = map(ro+rd*t);
        sh = min(sh,4.*h/t);
        t += h;
    }
    return sh;
}

// Function 2055
void LightBoxLight (in vec3 cameraPos, in vec3 shadePoint, vec3 normal, vec3 directionalLightReverseDir, vec3 rayDir, in float specularPower, out vec3 diff, out vec3 spec) {
    
    // start with a white directional light diffuse
    float diffuse = clamp(dot(normal, directionalLightReverseDir), 0.0, 1.0);
    diff = vec3(diffuse);
    
    // add in specular
    vec3 reflection = reflect(directionalLightReverseDir, normal);
    float dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
    spec = vec3(pow(dp, specularPower));    

    // apply shadows
    vec3 shadowRayPos = shadePoint;        
    vec3 shadowRayDir = directionalLightReverseDir;
    vec3 shadowHitDiffuse = vec3(0.0);
    vec3 shadowHitEmissive = vec3(0.0);
    float shadowHitSpecularPower = 0.0;
    vec4 shadowHitInfo = vec4(10000.0, -directionalLightReverseDir); 
    bool shadowHitSomething = false;  
    TraceRay(cameraPos, shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecularPower, shadowHitSomething, true);
    diff *= float(!shadowHitSomething);
    spec *= float(!shadowHitSomething);

    // in mode greater than zero we limit this directional lighting to repeating boxes in uv coordinates
    vec3 uv;
	vec3 localPos;    
    if (GetMode() >= 1.0)
    {
        // get position in light space and get uv
        localPos = WorldSpaceToDirectionalLightSpace(shadePoint);
        uv = LightSpaceToLightUV(localPos);
        
        // set shade to 1 if it's inside, 0 if it's outside        
    	float shade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);
        
        // if it is behind the light source, don't light it!
        shade *= step(0.0, localPos.y);
        
        // apply distance attenuation
        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);   
        
        // apply shading to the lighting
        spec *= shade;
        diff *= shade;
    }
    
    // soften shadows over a distance
	if (GetMode() >= 2.0)
    {
        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.001, 0.999);
    	float softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));
    	float softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));
    	diff *= softenX * softenY;
        spec *= softenX * softenY;
    }
    
    // apply texture to light if we should!
    if (GetMode() >= 3.0)
    {
        diff *= GetLightColor(uv);
    }
    
    diff = clamp(diff, 0.0, 1.0);
    spec = clamp(spec, 0.0, 1.0);
}

// Function 2056
float shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){

    float shade = 1.0;
    const int shadIter = 14; 

    float dist = start;
    //float stepDist = end/float(shadIter);

    for (int i=0; i<shadIter; i++){
        float h = map(ro + rd*dist);
        shade = min(shade, k*h/dist);
        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.

        dist += clamp(h, 0.32, 0.2);
        
        // There's some accuracy loss involved, but early exits from accumulative distance function can help.
        if ((h)<0.001 || dist > end) break; 
    }
    
    return min(max(shade, 0.) + 0.0, 1.0); 
}

// Function 2057
vec3 BlinnPhongLighting(
    vec3 point,
    vec3 eye,
    vec3 N,
    vec3 ambient,
    vec3 diffuse,
    vec3 specular,
    float specularAlpha
){
    vec3 L = normalize(DirectionLightPosition);
    vec3 V = normalize(eye - point);
    vec3 H = normalize(L + V);

    float dotNH = clamp(dot(N, H), 0., 1.);
    float dotNL = clamp(dot(N, L), 0., 1.);


    vec3 ambientColor = diffuse * AmbientLight;
    vec3 diffColor = dotNL * diffuse;
    vec3 specColor = pow(dotNH, specularAlpha) * specular;

    return ambientColor + (DirectionLight * (diffColor + specColor));
}

// Function 2058
vec3 shade(vec3 p, vec3 rd, float b, mat3 m) {
	vec3 col = vec3(0.0);
	vec3 n = normalize(-grad(p, b));
	
	// material
	vec3  amb = vec3(0.05375, 0.05, 0.06625);
	vec3  dif = vec3(0.18275, 0.17, 0.22525);
	vec3  spe = vec3(0.332741, 0.328634, 0.346435);
	float shin = 39.4;
	
	// key light
	vec3 l = normalize(m*vec3(1.0));
	vec3 h = normalize(l-rd);
	float lambert = max(0.0, dot(n, l));
	float blinn = lambert > 0.0 ? pow(max(0.0, dot(n, h)), shin) : 0.0;
	col += vec3(3.0, 2.0, 3.0)*(0.4*dif*lambert + 1.4*spe*blinn + 0.1*amb);
	
	// fill light
	lambert = max(0.0, dot(n, -rd));
	blinn = lambert > 0.0 ? pow(lambert, shin) : 0.0;
	col += vec3(1.0)*(0.4*dif*lambert + 1.4*spe*blinn + 0.1*amb);
	
	// rim light
	col += 2.25*pow(clamp(1.0+dot(n, rd), 0.0, 1.0), 3.0); 
	
	return col/(col+1.0); // reinhard
}

// Function 2059
vec3 shade(hit_record rec) {
    bool wu = fract(rec.u*0.5)>0.5;
    bool wv = fract(rec.v*0.5)>0.5;
    if (wu^^wv) {
        return materials[rec.matidx].albedo;
    } else {
        return materials[rec.matidx].albedo2;
    }
}

// Function 2060
vec3 GetLightIntensity(){
	return 50.* LIGHTCOLOR;
}

// Function 2061
vec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )
{
    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),
				              softShadowSphere( pos, vec3(0.57703), sc1 )),
				              softShadowSphere( pos, vec3(0.57703), sc2 )),
                              softShadowSphere( pos, vec3(0.57703), sc3 ));
	float dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);
	float bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);
    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;
	     lin += occ*vec3(0.15,0.20,0.30);
	     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);

    return lin;
}

// Function 2062
float Shadow(Ray ray, vec3 light)
{
    float depth = Raymarch(ray).w;
    if(depth < length(light))
    {
        return 0.1;
    }
    return 1.0;
}

// Function 2063
void createLight(vec3 color,
                 float intensity,
                 vec3 pos,
                 vec2 size,
                 out Light light) {
    light.color_ = color;
    light.intensity_ = intensity;
    light.pos = pos;
    light.size = size;
}

// Function 2064
vec3 sceneLight(in float iTime) {
    return vec3(6.0, 7.8, -6.0);
}

// Function 2065
vec3 shader6(){
	vec2 p = (2.0*fragCoord2.xy-iResolution.xy)/min(iResolution.y,iResolution.x);
	vec2 uv=fragCoord2.xy / iResolution.xy - 0.5;
	
	vec3 color=caleidoscopio(uv);
	vec2 centerHeart;
	centerHeart = vec2(iResolution.x/2., iResolution.y/2.);
	float radius = 20.0;	
	
	//Si el cursor esta dentro de la circunferencia, el corazÃ³n se anima.
	if( length(iMouse.xy-centerHeart)<radius ) {		
		float tt = mod(iTime,1.5)/1.5;
		float ss = pow(tt,.2)*0.5 + 0.5;
		ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);
		p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);
	}
	vec2 posicion=vec2(0.0,0.2);
	float escala=1.0;
	corazonFbm(posicion,p,escala,color);
	return color;
}

// Function 2066
float calcSoftshadow(in vec3 ro, in vec3 rd) {
    float res = 1.0;
    float t = 0.0005; // selfintersection avoidance distance
    float h = 1.0;
    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps
        h = doModel(ro + rd * t);
        res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows
        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances
    }
    return clamp(res, 0.0, 1.0);
}

// Function 2067
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
    float res = 1.0;
    float dt = 0.02;
    float t = mint;
	ro += rd * 0.4;
    for( int i=0; i<32; i++ )
    {
        float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += max( 0.05, dt );
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 2068
float doShadow(vec3 ld, vec3 p, vec3 n) {
    float cosTheta = clamp(dot(n,ld),0.,1.);
	float bias = SHADOW_BIAS*tan(acos(cosTheta)); // cosTheta is dot( n,l ), clamped between 0 and 1
	bias = clamp(bias, 0., 0.01);
    return softshadow(p+ld*bias,ld,bias,MAX_DISTANCE);
}

// Function 2069
float calcShadowLight(in vec3 p) {
    float t = march(p, gLightDirection).x;
    return t > 40.0 ? 1.0 : 0.0;
}

// Function 2070
float cAO(in vec3 pos, in vec3 nor)
{
	float sca = 2.0, occ = 0.0;
    for( int i=0; i<5; i++ ){
    
        float hr = 0.01 + float(i)*0.5/4.0;        
        float dd = map(nor * hr + pos);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp( 1.0 - occ, 0.0, 1.0 );    
}

// Function 2071
float shadowhit( const vec3 ro, const vec3 rd, const float dist) {
    vec3 normal;
    float d = traceSphereGrid( ro, rd, vec2(.3, dist), normal, 4).y;
    d = min(d, iCylinder(ro, rd, vec2(.3, dist), normal, vec3(0,.2,0), 1.5, false));
    return d < dist-0.001 ? 0. : 1.;
}

// Function 2072
vec3 scene_lighting_ocean( vec3 albedo, vec3 Z, vec3 N, vec3 M, vec3 L, vec3 V, vec3 F,
                           float a, vec3 sky,
                           vec4 refl, float extra_T )
{
#if WITH_ILLUM_TEST
    float mu0 = max( 0., dot( N, L ) );
    return F * mu0 + refl.xyz;
#else
    // variation of the KSK microfacet model
    vec3 L_refract = normalize( -simple_refract( -L, Z ) );
    float mu0_refract = max( 0., dot( N, L_refract ) ) * max( 0., dot( L, Z ) );
    float mu0 = max( 0., dot( M, L ) );
    float mu = max( 0., dot( M, V ) );
    vec3 H = normalize( L + V );
    float cosxi = max( 0., dot( M, H ) );
    float cospsi = max( .0625, dot( L, H ) );
    float fr_mu = refl.w;
    float fr_psi = fresnel_schlick( .02, cospsi );
    float kd = ( 1. - fr_mu );
    float ks = extra_T * NDFdisk( cosxi, a, .5 * square( 7487. / 321226. ) ) / ( 4. * cospsi * cospsi );
    return F * mix( mu0_refract * albedo * kd, mu0 * vec3( ks ), fr_psi ) +
        albedo * sky * ( 1. - fr_mu ) + refl.xyz;
#endif
}

// Function 2073
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<32*1; i++ )
    {
        float h = mapScene( ro + rd*t ).d;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.01, 0.90 );
        if( h<(0.00001) || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 2074
bool calc_light(vec3 ray_origin, vec3 ray_dir, vec3 light_pos, out float q)
{
	bool found = false;
	
	vec3 d = -light_pos + ray_origin;
	float r = 0.15;
	
	float A = dot(ray_dir, ray_dir);
	float B = 2.0*dot(ray_dir, d);
	float C = dot(d, d) - r*r;
	
	float discriminant = B*B - 4.0*A*C;
	if( discriminant > 0.0 )
	{
		q = -(B + sqrt(discriminant))/(2.0*A);
		found = (q > 0.0);
	}
	return found;
}

// Function 2075
float sample_lightmap(vec3 camera_pos, vec3 dir, Options options, Intersection result)
{
    if (result.uv_axis == 3)
        return clamp(-dot(result.normal, ENTITY_LIGHT_DIR), ENTITY_MIN_LIGHT, 1.);
    if (result.plane == -1)
        return 1.;

    float unmapped_light = is_material_any_of(result.material, MATERIAL_MASK_LIQUID|MATERIAL_MASK_SKY) ? 1. : 0.;
    vec3 point = camera_pos + dir * result.t;
    vec2 offset = get_lightmap_offset(result.plane);
    if (any(lessThan(offset, LIGHTMAP_OFFSET)))
        return unmapped_light;

    vec2 uv = uv_map_axial(point, result.uv_axis);
#if LIGHTMAP_FILTER == 1 // snap to world texels
    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))
    	uv = floor(uv) + .5;
#endif
    uv = uv / LIGHTMAP_SCALE - offset;
    
#if LIGHTMAP_FILTER > 0
    uv -= .5;
#endif
    
    vec2 base = floor(uv);
    ivec2 addr = ivec2(base);
    if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y)
        return unmapped_light;
    
    uv -= base;
#if !LIGHTMAP_FILTER
    uv = vec2(0);
#endif
    
    float
        s00 = fetch_lightmap_texel(addr + ivec2(0,0)),
        s01 = fetch_lightmap_texel(addr + ivec2(0,1)),
        s10 = fetch_lightmap_texel(addr + ivec2(1,0)),
        s11 = fetch_lightmap_texel(addr + ivec2(1,1)),
        light = mix(mix(s00, s01, uv.y), mix(s10, s11, uv.y), uv.x);

#ifdef QUANTIZE_LIGHTMAP
    const float LEVELS = float(QUANTIZE_LIGHTMAP);
    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) && g_demo_stage != DEMO_STAGE_LIGHTING)
        light = floor(light * LEVELS + .5) * (1./LEVELS);
#endif
    
    return light;
}

// Function 2076
float pointLight( vec3 point, vec4 light ) {
    vec3 normal = sceneNormal( point );
    
    vec3 towardLight = light.xyz - point;
    float toLight = length( towardLight );
    towardLight = normalize( light.xyz - point );

    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );
    
    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;
    float d = rayMarch( lightStart, towardLight );
    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );

    float lightStrength = .7 + .3 * light.w / dot( toLight, toLight );  
    return diffuse * lightStrength;
}

// Function 2077
vec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )
{
    float NdotV = max( 0.0, dot( vView, vNormal ) );

    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );
}

// Function 2078
vec4 light( in vec4 fragColor, vec3 uv )
{
    uv = uv * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;
    vec3 rd = normalize(uv);
    vec3 ro = vec3(0.0, 0.0, -3.0);
    float t = trace(ro, rd);
    float fog = 1.0 / (1.0 + t * t * 0.1);
    vec3 fc = mix(vec3(fog),vec3(1.0,0.0,0.0),2.0);
    return vec4(vec3(min(uv.yyx,fc)), 1.0);
}

// Function 2079
float PrismShade( vec2 vUV )
{
    float d = GetPrismDist( vUV );
    
    float fEpsilon = 0.001;
    float fDX = GetPrismDist( vUV + vec2( fEpsilon, 0 ) );
    float fDY = GetPrismDist( vUV + vec2( 0, fEpsilon ) );
    
    vec2 vNorm = normalize( vec2( fDX - d, fDY -d ) / fEpsilon );
    
	float fEdge = clamp( 1.0 - abs(d) * 200.0, 0.0, 1.0 );
    
    float fLight = dot( normalize( vec2(0.5, -0.4) ), vNorm );
    
    float fLightA = clamp( fLight * 0.5 + 0.5, 0.0, 1.0 );
    float fLightB = pow( clamp( fLight, 0.0, 1.0 ), 100.0 ) * 2.0;
    
    float fShade = fEdge * (fLightA + fLightB + 0.5);
        
    if ( d < 0.0 )
    {
        fShade = max( fShade, 0.25 );   
    }
    
    fShade = max( 0.0f, fShade );
    
	return fShade * 0.05;
}

// Function 2080
vec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )
{
    vec3 oriCol = col;
    
    float dz = depth - t;
    float ao = clamp(dz*50.0,0.0,1.0);
    vec3  pos = ro + t*rd;
    vec3  nor = calcNormalTransparent( pos, 0.002 );
    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );
    vec3  hal = normalize( sunDir-rd );
    vec3  ref = reflect( -rd, nor );
    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );
    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );


    float ds = 1.6 - col.y;
    
    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );

    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );
    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);
    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    
    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );
    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );
    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,texture( iChannel1, 0.8*nor.xy ).x)*(0.1+0.9*fre*fre);
    
    // hide aliasing a bit
    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); 
}

// Function 2081
vec3 tex_lights(in vec3 p, in float d, in vec3 n)
{
    // Do some scaling.
    p *= 4.;
    // We do the same thing as with the pipes here. If the
    // fractional part of the position is less than a threshold,
    // we return one value, and a different one otherwise,
    // except we use smoothstep so we can filter based on distance.
    float f = smoothstep(.1-.5*d, .1+.5*d, p.x-floor(p.x)) 
            * smoothstep(.1-.5*d, .1+.5*d, p.z-floor(p.z));
    // Mix between the cage and light color.
    return mix(CAGECOLOR, LIGHTCOLOR, f);
    if(p.x-floor(p.x)<.2 || p.z-floor(p.z)<.2) return vec3(.1, .025, .01);
    return vec3(1.);
}

// Function 2082
float ObjSShadow (vec3 ro, vec3 rd)
{
  vec3 p;
  vec2 gIdP;
  float sh, d, h;
  sh = 1.;
  d = 0.05;
  gIdP = vec2 (-999.);
  for (int j = VAR_ZERO; j < 30; j ++) {
    p = ro + d * rd;
    gId = PixToHex (p.xz / hgSize);
    if (gId != gIdP) {
      gIdP = gId;
      SetPngConf ();
    }
    h = ObjDf (p);
    sh = min (sh, smoothstep (0., 0.05 * d, h));
    d += clamp (h, 0.05, 0.3);
    if (sh < 0.05) break;
  }
  return 0.5 + 0.5 * sh;
}

// Function 2083
float calcAO(in vec3 pos, in vec3 nor)
{
	float occ = 0.0;
    float sca = 1.0;
    for(int i=0; i<6; i++)
    {
        float hr = 0.01 + 0.12*float(i)/9.0;
        vec3 aopos =  nor*hr + pos;
        float dd = map(aopos, false).x;
        occ+= -(dd - hr)*sca;
        sca*= 0.85;
    }
    occ = 2.*smoothstep(0.06, 0.5, occ);
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 2084
float Lights( vec3 pos )
{
	return
		smin(smin(smin(smin(smin(smin(smin(smin(//smin(
			// ring light
			length(vec2(pos.z, length(pos.xy)-188.0))-.5,
			// landing lights
			length(pos-vec3(-8,-3,-9))-.3),
			length(pos-vec3( 8,-3,-9))-.3),
			length(pos-vec3(-8, 3,-9))-.3),
			length(pos-vec3( 8, 3,-9))-.3),
			length(pos-vec3(-8,-3, 9))-.3),
			length(pos-vec3( 8,-3, 9))-.3),
			length(pos-vec3(-8, 3, 9))-.3),
			length(pos-vec3( 8, 3, 9))-.3/*),
			length(pos-vec3(-8,-197,12.0*sin(iTime)))-.3*/
		);
}

// Function 2085
vec3 backgroundDirectLight(vec3 dir) {
	if(dot(dir, LightDirection) < cos(LightRadius)){return vec3(0.0);}
	float sphericalCapArea = sin(LightRadius)*sin(LightRadius);
	float lightStrength = LightIntensity/(sphericalCapArea);
	return lightStrength*LightColor.rgb;
}

// Function 2086
float computeLightInt(HitRecord hit)
{
    Ray r = computeLightRay(hit);
	vec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;
    float dotL = dot(hit.N, r.direction);
    
    float intensity = (1.0/ length(distToLight)) * .3;
    
    
    if(shadowDetect(r,spheres[5]))
       {
           intensity *= 0.00;
       }
    
    return intensity * dotL;
}

// Function 2087
bool isShadowed(Ray ray,float minDist,float maxDist)
{
	vec3 p;
    return intersect(ray,minDist,maxDist,p)!=OBJ_NONE;
}

// Function 2088
float vertexAo(vec2 side, float corner) {
	//if (side.x == 1.0 && side.y == 1.0) return 1.0;
	return (side.x + side.y + max(corner, side.x * side.y)) / 3.0;
}

// Function 2089
vec3 GetLight(vec3 p)
{

    vec3 rgb = vec3(0.,0.,0.);
    vec3 lightPos = vec3(0,3,6);
    vec3 lightPos2 = vec3(0,3,6);
    vec3 lightCol = vec3(0,0,0);
    
    vec3 l ;
    vec3 n ;
    float dif = 0.;
    vec2 rm ;
    float mindist ;
    float d ;
    
    
    lightPos.xz += vec2(5.*sin(iTime),5.*cos(iTime));
    l = normalize(lightPos - p);
    n = GetNormal(p);
    dif += clamp(dot(n,l),0.,1.);
    rm = RayMarch(p+n*(MIN_DIST+0.5),l);
    mindist = rm.y;
    d = rm.x;
    lightCol+= vec3(abs(sin(1./rm.x*0.1)))*0.2;
    if(d<length(lightPos-p)) dif*=0.03;
    
    if(d>=MAX_DIST)
    {
     lightCol += 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));
     }
     
    
    lightPos2.xz += vec2(5.*cos(iTime+3.14159),5.*sin(iTime+3.14159));
    l = normalize(lightPos2 - p);
    dif += clamp(dot(n,l),0.,1.);
    rm = RayMarch(p+n*(MIN_DIST+0.5),l);
    mindist = rm.y;
    d = rm.x;
    lightCol+= vec3(abs(sin(1./rm.x*0.1)))*0.2;
    if(d<length(lightPos-p)) dif*=0.03;
    
    if(d>=MAX_DIST)
    {
     lightCol += 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));
     }
    
    rgb = dif+lightCol;
    
    
    return rgb;
}

// Function 2090
result distanceFieldShadow(vec3 p, float t)
{
	result res;
	res = bouncyBoi(p,t);
	res = compare(res, world(p,t));
	return res;
}

// Function 2091
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) 
{
	vec3 color;
    
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    float dotLN = dot(L, N);
    if (dotLN < 0.0) {
        // light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    else
    {
        if (USE_SPECULAR == 1)
        {
            vec3 V = normalize(eye - p);
            vec3 R = normalize(reflect(-L, N));
            float dotRV = dot(R, V);
            //vec3 H = normalize(L * V);
            //float dotNH = dot(N, H);
            if (dotRV < 0.0) 
            {
                // light reflection in opposite direction as viewer, apply only diffuse
                // component
                color = lightIntensity * (k_d * dotLN);
            }
            else
                color = lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
        }
        else
        {
            color = lightIntensity * (k_d * dotLN);
        }
        
        vec3 lightToPos = p - lightPos;
        float maxDist = length(lightToPos);
        float dist = shortestDistanceToSurface(lightPos, normalize(lightToPos), 0.0f, maxDist);
        if (dist <= maxDist - EPSILON) 
        {
            // hit something between light source and point -> shadow
        	return color * SHADOW_VISIBILITY; //
    	}
    }
    return color;
}

// Function 2092
vec3 light( in vec3 p, in vec3 d, in vec3 e, in vec3 n )
{
    // Get ambient occlusion and shadow values.
    float amb = occlusion(p,n);
    float sdw = shadow(p,SUN_DIR,PENUMBRA_FACTOR);
    
    // Get light colors and irradiance for the three lights.
    vec3 skc = orenNayar(n,-d,UP)*sky(d);
    vec3 sun = orenNayar(n,-d,SUN_DIR)*SUN_COLOR;
    vec3 gnd = orenNayar(n,-d,-SUN_DIR)*GROUND_COLOR;
    
    // Modulate those by ambient occlussion and shadowing.
    skc *= amb;
    gnd *= amb;
    sun *= sdw;
    
    // Return the sum.
    return skc+gnd+sun+vec3(.05);
}

// Function 2093
float calcAO( in vec3 pos, in vec3 nor , float io )
{
float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.612*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos , io).x;
        occ += -(dd-hr)*sca;
        sca *= 0.5;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 2094
float softShadow(vec3 ro, vec3 lp)
{
	vec3 rd = normalize(lp-ro);
	float tmax = distance(lp,ro);
	float res = 1.0;
    float t = 0.1;
	for(int i = 0; i<256; i++ )
	{
        if(t>=tmax) break;
		float d = map(ro+rd*t).a;
		if(d < 0.001) return 0.0;
		res = min(res, 8.0*d);
		t += d;
	}
	return res;
}

// Function 2095
float calcAO( in vec3 pos, in vec3 nor, in vec3 rd )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        vec2 uv;
        float dd = map( aopos,rd ,uv);
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);
}

// Function 2096
float calcAO(vec3 pos, vec3 nor) {
  float occ = 0.0;
  float sca = 1.0;
  for (int i=0; i < 5; i++) {
    float hr = 0.01 + 0.12 * float(i) / 4.0;
    vec3 aopos = nor * hr + pos;
    float dd = scene(aopos).x;
    occ += -(dd - hr) * sca;
    sca *= 0.95;
  }
  return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// Function 2097
float shadow(vec3 px)
{
    // check whether the shadow maps z value is higher than the current one
    // if it's not, the point lies in shadow
     vec4 lookup = texture(iChannel0,px.xy);
     return float(lookup.x  > px.z - 0.002); 
}

// Function 2098
void TorchLight (in vec3 cameraPos, in vec3 shadePoint, vec3 normal, vec3 rayDir, in float specularPower, out vec3 diff, out vec3 spec) {
    
    vec3 lightPos = cameraPos + vec3(-1.5, 1.0, 0.0);
    
    vec3 lightColor = torchLightColor * (hash11(iTime)*0.25+0.75);
    
    // start with a yellow point light that has quadratic distance attenuation
    vec3 reverseLightVector = vec3(lightPos - shadePoint);
    vec3 reverseLightDir = normalize(reverseLightVector);
    float diffuse = clamp(dot(normal, reverseLightDir), 0.0, 1.0);
    float distToLight = length(reverseLightVector);
    float attenDistt = max(0.0, distToLight + torchLightDistanceBias);
    float falloff = 1.0 - clamp(torchLightDistanceAttenuation * attenDistt * attenDistt, 0.0, 1.0);
    diff = diffuse * lightColor * falloff;    
    
    // add in specular
    vec3 reflection = reflect(reverseLightDir, normal);
    float dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
    spec = pow(dp, specularPower) * lightColor * falloff;    
        
    // apply shadows by seeing if anything is between the shade point and the light
    vec3 shadowRayPos = shadePoint;        
    vec3 shadowRayDir = reverseLightDir;
    vec3 shadowHitDiffuse = vec3(0.0);
    vec3 shadowHitEmissive = vec3(0.0);
    float shadowHitSpecularPower = 0.0;
    vec4 shadowHitInfo = vec4(10000.0, -reverseLightDir); 
    bool shadowHitSomething = false;  
    TraceRay(cameraPos, shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecularPower, shadowHitSomething, true);
    float shadow = float(shadowHitSomething);
    shadow*= float(shadowHitInfo.x < distToLight);
    shadow = 1.0 - shadow;
    diff *= shadow;
    spec *= shadow;

    // clamp the resulting color
    diff = clamp(diff, 0.0, 1.0);
    spec = clamp(spec, 0.0, 1.0);
}

// Function 2099
float shadow( in vec3 start, in vec3 ldir, in float p )
{    
	float t = EPSILON;
	float res = 1.0;
    for ( int i = 0; i < 128; ++i )
    {
        float d = dist( start + ldir * t );
        if ( d < EPSILON*.1 )
            return 0.0;
		
		res = min( res, p * d / t );
        t += d;
		
		if ( t > MAX_DEPTH )
			break;
    }
    return res;
}

// Function 2100
vec3 shadeFast( vec3 p, vec3 n, vec3 ro, vec3 rd )
{
    float d = length(p-ro);
    vec3 sky = skyColor(rd);
    vec3 col = sky;
    
    if (d < 100.)
    {
        vec3 albedo = vec3(.8);
        float metalness = 0.;
        getMaterial(p, n, metalness, albedo);
        
        float ao = ambientOcclusion(p,n, 10., 2.);
        float shad = shadowFast(vec3(p), vec3(sunDir), float(0.5), float(80.));
		float fre = saturate(1.+dot(rd,n));
        
        vec3 amb = vec3(.5,.5,.5) * ao;
        vec3 diff = vec3(1.,.7,.5) * max(0., dot(n, sunDir) ) * shad;
                
        col = albedo * ( diff*2. + amb );
        
        col = mix(col, skyColor(vec3(1.,.2,.1))*.25, 1.-exp(-length(p-ro)*.01));
    }
    computeGlow(col,glowAcc);
    
    return col;
}

// Function 2101
vec3 calcLight(vec3 p, vec3 v, vec3 n)
{
    const int lCount = 3;
    Light[lCount] lights = Light[lCount](
        Light(vec3(5., 3., 6.), 8., vec3(1., .2, 0.), 8.),
        Light(vec3(0., 5., 5.), 4., vec3(1., .5, .1), 8.),
        Light(vec3(-4., -10., 2.), 7., vec3(1., 0.5, .8), 8.)
    );
    vec3 ambient = vec3(1.) * .05;
    
    vec3 color = vec3(0.);
    for (int i = 0; i < lCount; i++)
    {
        vec3 ldir = lights[i].point - p;
        float lmag = length(ldir); 
        ldir /= lmag;
        
        vec3 h = normalize(ldir - v);
        float spec = max(0., pow(dot(n, h), specExp));
        
        float diff = max(0., dot(ldir, n));

        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness) * 4.;
        
        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));
        color += strength * (lights[i].color * diff + vec3(1.) * spec);
    }
    
    return ambient + color;
}

// Function 2102
vec3 lighting(in vec3 ro, in vec3 rd) {
    vec3 n = normalAt(ro);
    float diffuse = max(0.0, dot(-rd, n));
    float specular = pow(diffuse, SPEC_POW);
    vec3 color = colorMap(ro);
    return color * (diffuse + specular);
}

// Function 2103
float getShadow( vec3 hp, vec3 nor, vec3 lrd, float d ) {
#ifdef SHADOWS
    sRay ray;
    ray.rd = lrd;
    ray.ro = hp;
    ray.sd = 0.05 / abs(dot(lrd, nor));
    ray.rl = d - ray.sd;
    sHit si;
    march(ray, si, 32, kNt);
    float s = step(0.0, si.hd) * step(d, si.hd );
    return s;
#else
    return 1.0;
#endif
}

// Function 2104
float shade_point(vec3 ro, vec3 rd, vec3 normal, vec3 hitPos, vec3 lightPos)
{
    vec3 lightDir = lightPos-hitPos;
    float lightIntensity = ( 1.0/max(dot(lightDir, lightDir), 0.001) );
    lightDir = normalize(lightDir);

    return max(dot(normal, lightDir), 0.0)*lightIntensity;
}

// Function 2105
SSphere lightPoint1Sphere()
{
	return SSphere
	(
		1,						//id
		lightPoint1().m_pos,		//center
		0.03,					//radius
		SMaterial
		(
			1.0,				//diffuse amount
			vec3(0.0,0.0,0.0),	//diffuse color
			1.0,				//specular amount
			vec3(0.0,0.0,0.0),	//specular color
			lightPoint1().m_color,//emissive color
			0.0,				//reflection amount
			0.0,				//refraction amount
			0.0					//refraction index
		)
	);	
}

// Function 2106
PathColor Light_GetFresnel( vec3 vView, vec3 vNormal, PathColor cR0, float fGloss )
{
    float NdotV = max( 0.0, dot( vView, vNormal ) );
    
    float f = pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );

    return ColorAdd( cR0, ColorScale( ColorSub( PathColor_One(), cR0), f ) );   
}

// Function 2107
float getLightDiffuse(vec3 p, float material, float height, vec3 normal) {
    vec3 l = normalize(lightPos - p);
    float dif = clamp(dot(normal, l), 0., 1.);
    return dif;
}

// Function 2108
vec3 shade(vec3 ro, vec3 rd, float t) {
    vec3 l = normalize(vec3(1.0, 0.0, -1.0));
      
    vec3 col = fullSky(l, rd);
    
    if (t > 0.0) {
        vec3 p = ro +t*rd;
        vec3 n = normal(p);
        vec3 h = normalize(l - rd);
        vec3 r = reflect(rd, h);
    	        
        float shin = 5.0, r0 = 0.25;
        float fresnel = (r0 + (1.0 - r0)*pow((1.0-dot(-rd, h)), 5.0));
        vec3 spec_light = fogColor(l, r);
        vec3 spec_brdf = vec3(1.0)*fresnel*(shin + 8.0)/(8.0*PI)*pow(max(dot(n, h), 0.0), shin);
        
        vec3 tex = material(p, n);
        vec3 diff_light = pow(vec3(168., 195., 224.)/255., vec3(2.2));
        vec3 diff_brdf = tex*(1.0-fresnel)/PI;
        
        float shadow = clamp(5.0*dot(normalL(p), l), 0.0, 1.0);
            
        float fog = 1.0 - exp(-0.25*t);
        vec3 lcol = (diff_brdf*diff_light + spec_brdf*spec_light)*shadow*max(dot(n, l), 0.0);
    	col = mix(0.97*lcol + 0.03*tex*n.y, fogColor(l, rd), fog);
    }
    return clamp(col / (col + 1.0), 0.0, 1.0);
}

// Function 2109
bool get_sun_light(in ray_t ray, inout float opticalDepthR, inout float opticalDepthM){
    float t0,t1;
    intersects_sphere(ray, atmosphere,t0,t1);
    
    float march_pos = 0.;
    float march_length = t1 / float(num_samples_light);
    
    for(int i=0; i<num_samples_light; i++){
        vec3 s = ray.origin + ray.direction*(march_pos + 0.5*march_length);
        float height = length(s)-earth_radius;
        opticalDepthR += exp(-height/hR) * march_length;
        opticalDepthM += exp(-height/hM) * march_length;
        
        march_pos += march_length;
    }
    return true;
}

// Function 2110
float shadow(result res, float time, float k)
{
	ray r;
	r.o = res.p + res.n * 0.01;
	vec3 l = getLightPos(time) - r.o;
	r.d = normalize(l);
	float maxDist = length(l);

	float s = 1.0;
	float t = 0.0;
	while(t <= maxDist)
	{
		vec3 p = r.o + r.d * t;
		float d = distanceFieldShadow(p, time).t;		
		if(d <= EPSILON) break;
		s = min(s, d*k / t);
		t += max(d, t * 0.0001);
	}	
	return min(s, t < maxDist ? 0.0 : 1.0);
}

// Function 2111
float AO(in vec3 p,in vec3 d,float s){
;float t=.0,a=1.,f,n=.01+.04*s
;for(float i=.0;i<iterAO;i++ 
){f=max(gd(p+d*t)*1.5,n)
 ;a=min(a,f/t+t*0.5)
 ;t+=f;
}return a;}

// Function 2112
void ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in float reflectionAmount, in vec3 rayDir)
{
	{
		// diffuse
		vec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);
		float dp = dot(collisionInfo.m_surfaceNormal, hitToLight);
		if(dp > 0.0)
			pixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;
				
		// specular
		vec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;
	}
}

// Function 2113
vec3 processLighting(vec3 baseColor1, vec3 baseColor2, vec3 eyePos, vec3 surfacePoint)
{
    vec3 normal = calcNormal(surfacePoint);
    vec3 toLight = normalize(eyePos + vec3(0, -1.0, -9.0) - surfacePoint);
    float pointDot = max(dot(toLight, normal), 0.0);
    float colMix = max(pointDot * 2.0 - 1.0, 0.0);
    vec3 color = baseColor2 + baseColor1 * colMix;
    return pointDot * color * 2.0;
}

// Function 2114
vec3 light( float t )
{
    return vec3(2.,3.5*sin(4.*t),2.);
}

// Function 2115
light pointLight(vec3 position, vec3 color, float intensity, float falloff) {
    return light(
        POINT_LIGHT, // type
        position, // position
        color, // color
        intensity, // intensity
        vec3(0.0), //direction (N/A)
        falloff, // falloff
        0.0, // spread (N/A)
        0.0 // taper (N/A)
    );
}

// Function 2116
vec3 calculateDirectLight(const in LightInfo light, const in SurfaceInteraction interaction, const in MaterialInfo material, out vec3 wi, out vec3 f, out float scatteringPdf) {
	
    // Light MIS
    vec3 wo = -interaction.incomingRayDir;
    vec3 Ld = vec3(0.);
    float lightPdf = 0., visibility = 1.;
    scatteringPdf = 0.;
    bool isBlack = false;
    
    vec3 Li = sampleLightType( light, interaction, wi, lightPdf, visibility, seed );
    Li *= visibility;
    
    isBlack = dot(Li, Li) == 0.;
    
    if (lightPdf > EPSILON && !isBlack ) {
        vec3 f = bsdfEvaluate(wi, wo, interaction.tangent, interaction.binormal, interaction, material) * abs(dot(wi, interaction.normal));
        float weight = 1.;
        
        #ifdef USE_MIS
        	scatteringPdf = bsdfPdf(wi, wo,interaction.tangent, interaction.binormal, interaction, material);
            weight = powerHeuristic(1., lightPdf, 1., scatteringPdf);
        #endif
        
        if( light.type == LIGHT_TYPE_SUN )
            weight = 1.;
            
		isBlack = dot(f, f) == 0.;
        if (!isBlack) {
           Ld += Li * f * weight/ lightPdf;
        }
    }
    
    // BSDF MIS
    f = bsdfSample( wi, wo, interaction.tangent, interaction.binormal, scatteringPdf, interaction, material);
    f *= abs(dot(wi, interaction.normal));
	
    #ifdef USE_MIS
        isBlack = dot(f, f) == 0.;
        Li = light.L;

        if (!isBlack && scatteringPdf > EPSILON && light.type != LIGHT_TYPE_SUN) {
            float weight = 1.;

            lightPdf = light_pdf(light, interaction);
            if (lightPdf < EPSILON) return Ld;
            weight = powerHeuristic(1., scatteringPdf, 1., lightPdf);

            Li *= visibilityTest(interaction.point + wi * .01, wi);
            isBlack = dot(Li, Li) == 0.;
        	if (!isBlack) {
            	Ld +=  Li * f * weight / scatteringPdf;
            }
        }
    #endif
    return Ld;
}

// Function 2117
vec2 get_lightmap_offset(int plane_index)
{
	const int NUM_BITS = 9, MASK = (1 << NUM_BITS) - 1;
	int packed_offset = LIGHTMAP_OFFSETS.data[plane_index];
    return (packed_offset >= 0) ?
        LIGHTMAP_OFFSET + vec2(packed_offset & MASK, packed_offset >> NUM_BITS) :
        LIGHTMAP_OFFSET + vec2(-1);
}

// Function 2118
float calcSoftShadow( in vec3 ro, in vec3 rd, float k )
{
	float res = 1.0;
	float t = 0.001;
	for( int i=ZERO; i<50; i++ )
	{
		float h = map(ro + rd*t ).x;

		res = min( res, smoothstep(0.0,1.0,1.8*k*(h+0.001)/sqrt(t)) );
		
		t += clamp( h, 0.003, 0.1 );
		if( res<0.001 || t>0.8) break;
	}
	return clamp(res,0.0,1.0);
}

// Function 2119
vec3 getLight(vec3 lookPos, vec3 dir) {
    
    vec3 col = vec3(0.0);
    float d = rayMarching(lookPos, dir);
    vec3 p = lookPos + dir * d, normal = getNormal(p), ref = normalize(reflect(dir, normal));

        if( d < MAX_DIST) {

            // ----- sun ----- //
            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));
            vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));
            float sunIntensity = 6.; 

            // ----- sky ----- //
            vec3 skyDir = vec3(0., 1., 0.);
            vec3 skyColor = normalize(vec3(0., .1, .3));
            float skyIntensity = 1.;

            float sunDiffuse = clamp(dot(normal, sunDir), 0., 1.);
            float skyDiffuse = clamp( 0.5 + 0.5*dot(normal, skyDir), 0., 1.);

            // ----- compute specular ----- //
            float sunSpecular = 0.;
            float skySpecular = 0.;

            sunSpecular = pow(max(0., dot(normal, normalize(sunDir - dir))), 16.);
            skySpecular = pow(max(0., dot(normal, normalize(skyDir - dir))), 16.);

            col += sunIntensity*sunColor*sunDiffuse + 0.6*sunSpecular*sunColor;
            col += skyIntensity*skyColor*skyDiffuse + 0.6*skySpecular*skyColor;

            col *= 0.2;
        }else {
            // sky
            col += (vec3(.4, .7, 1.) - 0.35 * dir.y)*0.9;
            col = mix(col, 1.-(1.-col)*(1.-col), exp(-8.*dir.y)); // lighten horizon using quadratic cuve 1-(1-x)^2
        }
        
    return col;
}

// Function 2120
vec3 lightingGrass(
    float depth,
    vec3 P,
    vec3 N,
    vec3 L,
    float type,
	vec2 _screenpos)
{
    float Lfact = max(0.0, dot(N, L));
    
    vec3 grassDff = GRASS_DIFFUSE;
    grassDff = SSG(_screenpos.xy, grassDff, grassDff*vec3(0.4), depth, TIME);
    
    vec3 dirtDff = DIRT_DIFFUSE;
    
    vec3 grassDiffuse = mix(
                        grassDff,
                        dirtDff,
                        fbm_hash(N.xz*0.6)
                    ) * fbm_hash((N*10.1).xz) * Lfact;
    //grassDiffuse = vec3(1., 0., 0.);
    vec3 treeDiffuse = TREE_DIFFUSE * Lfact * Lfact;
    return clamp(mix(
        			grassDiffuse, // TYPE_GRASS
        			treeDiffuse, // TYPE_TREE
        			clamp(type-TYPE_GRASS, 0.0, 1.0)
    				), 0.0, 1.0);
}

// Function 2121
float cao(in vec3 p, in vec3 n)
{
	float sca = 1., occ = 0.;
    for(float i=0.; i<5.; i++){
    
        float hr = .01 + i*.35/4.;        
        float dd = map(n * hr + p);
        occ += (hr - dd)*sca;
        sca *= 0.7;
    }
    return clamp(1.0 - occ, 0., 1.);    
}

// Function 2122
vec3 getLightPos( in int i )
{
    vec3 lpos;
    
    float la = 1.0;
    lpos.x = 0.5 + 2.2*cos(0.22+0.1*iTime + 17.0*float(i) );
    lpos.y = 0.25;
    lpos.z = 1.5 + 2.2*cos(2.24+0.1*iTime + 13.0*float(i) );

    // make the lights avoid the columns
    vec2 ilpos = floor( lpos.xz );
    vec2 flpos = lpos.xz - ilpos;
    flpos = flpos - 0.5;
    if( length(flpos)<0.2 ) flpos = 0.2*normalize(flpos);
    lpos.xz = ilpos + flpos;

    return lpos*SC;
}

// Function 2123
vec3 gamut_clip_preserve_lightness(vec3 rgb)
{
    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)
        return rgb;

    vec3 lab = linearSrgbToOklab(rgb);

    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;

    float L0 = clamp(L, 0.0, 1.0);

    float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.0 - t) + t * L;
    float C_clipped = t * C;

    return oklabToLinearSrgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

// Function 2124
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<30; i++ )
    {
		if( t>maxt ) break;

		float h = map( ro + rd*t ).x;
        res = min( res, k*h/t );
        t += 0.02;
    }
    return clamp( res, 0.0, 1.0 );

}

// Function 2125
float shadow_sdf(vec3 pose, bool inside)
{
    
    vec3 pos = pose;
    vec3 rot = pos;
    
    rot.xy -= vec2(0.36,-0.4);

    rot.xy = n_rotate(rot.xy,0.245);

    rot.xy += vec2(0.36,-0.4);
    
    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));
    
    if(door_box < 0.001)
        pos = rot;
        
        
    
    //use symetries:
        
        //mirror at axes
        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);
        
        //mirror at diagonals
        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;
        
    
    
    
     float d = 1000.;
    
    
    if(pos.z > 1.55)
    {
        float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2
        roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope
        d = min(d,roof);
        
        d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base
        float tar_rad = length(pos.xy);
        d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole
        d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light
        d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof
    }
    else
    {
        if(door_box > 0.001)
            d = min(d,door_box+0.001);
    
        if(pos.z > 0.73)
        {
            d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar
            d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar
            
            
            d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window
            
            if(pos.y < -0.4)
            {
                d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle
                
                d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical
                d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal
                
                d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock
            }
            
            
        }
        else
        {
            float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base
            base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)
            d = min(d,base);
        }
        
        d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars
        
        
        d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels
        
        d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar
        
        d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar
        
        d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar
        d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar
    }
    
    d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign
    d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside
    
    d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole
    
    d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1
    
    if(inside)
        d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back
    
    d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door
    
    if(door_box < 0.001)
         d = max(d,door_box+0.001);
      
    
    
     
    return (d);
}

// Function 2126
float softshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
	float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
    	float h = map(ro + rd*t);
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>tmax ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 2127
float sphSoftShadow(vec3 ro, vec3 rd, vec4 sph, float k) {
    vec3 oc = ro - sph.xyz;
    float r = sph.w * sph.w;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - r;
    float h = b * b - c;
    float d = -sph.w + sqrt(max(0.0, r - h));
    float t = -b - sqrt(max(0.0, h));
    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);
}

// Function 2128
float dAO(vec3 wp, vec3 n)
{
    float d = map(wp+n*AODIST).x;
    return 1.;
    return clamp(d/AODIST, 0., 1.);
}

// Function 2129
float carLights( vec3 p, float id )
{        
    // back lights
    p.z = abs( p.z );
    p.z -= 0.2;
    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );
    
    if ( id == 1.5 )
    	g_glowPlayerLights = min( g_glowPlayerLights, back );
       
    return back;
}

// Function 2130
vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in float _mat )
{
    vec3 mal = vec3(0.0);
    float specval = 0.0;
    if (_mat<=1.0)
    {
        float f = mod( floor(0.5*pos.z) + floor(0.5*pos.x), 2.0);
        mal = 0.2 + 0.2*f+0.2*vec3(0.45,0.85,1.0);
    }
    else
    {
        mal = vec3(0.5,0.15,0.1);
        specval = 1.1;
    }
    
    vec3 lin = vec3(0.0);

    // key light
    //-----------------------------
    vec3  lig = normalize(vec3(0.7,0.875,0.89));		// dir
    float dif = max(dot(nor,lig),0.0);
    float sha = 0.0;
    if( dif>0.01 )
        sha=calcSoftshadow( pos, lig, 0.02, 2.5 );
    lin += dif*vec3(1.00,1.00,1.00)*sha;
    float spec = pow(dif, 12.0) *specval;
    
    // ambient light
    //-----------------------------
    lin += vec3(0.50,0.50,0.50);
    
    // surface-light interacion
    //-----------------------------
    vec3 col = mal.xyz*lin;
    col+=spec;
    
    // fog    
    //-----------------------------
   	col *= exp(-0.0015*dis*dis);
    return col;
}

// Function 2131
float softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k, float time)
{
    float res = 1.0;
    float t = mint;
    for( int i=0; i<16; i++ )
    {
        float h = map( ro + rd*t, time).dist;
        res = min( res, k*h/t );
        t += clamp( h, 0.05, 0.2 );
        if( res<0.001 || t>maxt ) break;
    }
    return clamp( res, 0.0, 1.0 );
}

// Function 2132
vec3 shadeRay(lighting lit,vec3 end){
    vec3 normal=estimateNormal(end);
    vec3 phongShaded=phong(lit,normal,end)-0.2;
    return phongShaded;
}

// Function 2133
float calcAO(in vec3 pos, in vec3 nor, in float cuttingPlane) {
	float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
        float hr = 0.01 + 0.12 * float(i) / 4.0;
        vec3 aopos = nor * hr + pos;
        float dd = map( aopos, cuttingPlane).x;
        occ += -(dd - hr) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);
}

// Function 2134
void addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {
	vec3 lpos = vec3(0, 0,0);

	float dis = length(lpos - pos);
	vec3 invLight = normalize(lpos - pos);
	float diffuse = max(0.0, dot(invLight, normal));
	float spec = specular(normal, -invLight, normalize(eye - pos), 220.0);

	float str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);
	float tmp = 0.0;
	str = 1.0;
	color =  color * (0.0 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;
}

// Function 2135
mat4 light(in int lightID, in vec3 pos, in vec3 ref)
{
	mat4 lit = mat4(0);
     float t = gSongTime;
    float q = 1.- sin(mod(t*kTau, kTau*.25));
    if (0 == lightID)
    {
    	lit = mat4
	    (
			0.00, 15.00, 0.00,10.00, // Light position and attenuation.
        	1.00, 1.00, 1.00, 0.00, // Light color.
        	0.00, 0.00, 0.00, 0.00, // Reserved.
        	0.00, 0.00, 0.00, 0.00  // Reserved.
	    );
		lit[1].x*=1.;
		lit[1].y*=.25+.75*step(mod(t*4.,2.),1.);
		lit[1].z*=.25+.75*step(mod(t*4.,6.),3.);
        lit[1].x-=lit[1].y*lit[1].z;
        lit[1].xyz *= 1.-q;
    }
    else
    if (1 == lightID)
    {
    	lit = mat4
	    (
			-15.00, 15.00, 15.00,10.00, // Light position and attenuation.
        	1.00, 1.00, 1.00, 0.00, // Light color.
        	0.00, 0.00, 0.00, 0.00, // Reserved.
        	0.00, 0.00, 0.00, 0.00  // Reserved.
	    );
        
		lit[0].x*=1.+step(mod(t*4.,2.),1.);
		lit[0].z*=1.+step(mod(t*4.,6.),3.);
		lit[1].y*=1.;
		lit[1].x*=.25+.75*step(mod(t*4.,2.),1.);
		lit[1].z*=.25+.75*step(mod(t*4.,6.),3.);
        lit[1].y-=lit[1].x*lit[1].z;

        lit[1].xyz *= q;
    }
    else
    if (2 == lightID)
    {
    	lit = mat4
	    (
			15.00, 15.00, -15.00,10.00, // Light position and attenuation.
        	1.00, 1.00, 1.00, 0.00, // Light color.
        	0.00, 0.00, 0.00, 0.00, // Reserved.
        	0.00, 0.00, 0.00, 0.00  // Reserved.
	    );
		lit[0].x*=1.+step(mod(t*2.,2.),1.);
		lit[0].z*=1.+step(mod(t*2.,6.),3.);
		lit[1].z*=1.;
		lit[1].x*=.25+.75*step(mod(t*4.,2.),1.);
		lit[1].y*=.25+.75*step(mod(t*4.,6.),3.);
        lit[1].z-=lit[1].y*lit[1].x;

        lit[1].xyz *= q;
    }
    else
    if (3 == lightID)
    {
    	lit = mat4
	    (
			-15.00, 15.00, -15.00,10.00, // Light position and attenuation.
        	1.00, 1.00, 1.00, 0.00, // Light color.
        	0.00, 0.00, 0.00, 0.00, // Reserved.
        	0.00, 0.00, 0.00, 0.00  // Reserved.
	    );
		lit[0].x*=1.+step(mod(t*4.,4.),2.);
		lit[0].z*=1.+step(mod(t*4.,6.),3.);
		lit[1].x*=1.;
		lit[1].y*=.25+.75*step(mod(t*4.,2.),1.);
		lit[1].z*=.25+.75*step(mod(t*4.,6.),3.);
        lit[1].x-=lit[1].y*lit[1].z;

        lit[1].xyz *= q;
    }
    lit[3].xyz = normalize(lit[0].xyz - pos); // Computes light vector.
    return	lit;
}

// Function 2136
light create_light(vec3 position, vec3 color, float intension, bool shadows)
{
    light new_light;
    new_light.position = position;
    new_light.color = color;
    new_light.intension = intension;
    new_light.shadows = shadows;
    return new_light;
}

// Function 2137
float shadows(vec3 ro, vec3 rd, float tMax, float k, int octaves) {
    float res = 1.0;
	float t = 0.1;
	for(int i=0; i<22; i++) {
        if (t>=tMax) break;
        float h = map(ro + rd*t, octaves).x;
        res = min( res, k*h/t );
        t += h;
    }
    return clamp(res, 0.2, 1.0);
}

// Function 2138
vec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, in float ambient)
{       
    vec3 lightToPoint = gLightPosition - point;
    float spot = step(0.7, dot(normalize(lightToPoint), gLightDirection)) * Saturate(1.0 - length(lightToPoint) / 30.0);
    float lighting = Saturate(dot(normal, -gLightDirection)) * spot;
    
    // Slope bias
    float shadowMapBias = clamp(0.1 * tan(acos(Saturate(dot(normal, gLightDirection)))), 0.0, 0.1);
    float shadow = SampleShadowMap(point, shadowMapBias);
    
    return (albedo * lighting * shadow) + (albedo * ambient);
}

// Function 2139
vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    
    float dotLN = dot(L, N);
    float dotRV = dot(R, V);
    
    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    } 
    
    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

// Function 2140
vec3 GetLight(vec3 p, vec3 rd) {
    
	vec3 lightPos = vec3(0,0,0);
    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;
    vec3 l = normalize(lightPos - p);
    vec3 n = GetNormal(p);
    
    vec3 dif = vec3(clamp(dot(n,l),0.,.1));
    
    vec3 nor = GetNormal(p);
    
    // from
    // https://www.shadertoy.com/view/MsX3RH
    //triplanar blend vector
    vec3 tpn=normalize(max(vec3(0.0),(abs(nor.xyz)-vec3(0.2))*7.0))*0.5;
    //normal mapping
    float nms=.59;
    vec3 tuv=p*vec3(1.0 , 1. , 1.);	//texture coordinates

    vec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);
    vec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel1,nms);
    vec3 nmz=nmap(tuv.xy,iChannel2,nms)+nmap(-tuv.xy,iChannel2,nms);

    vec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);
    nor = normalize(nn + nor);


    float match = -dot( nor , rd );

    vec3 lightDir = normalize( p - lightPos );
    vec3 refl = reflect( lightDir , nor );

    float reflMatch = dot( rd , refl );

    vec3 iriCol = fogCube( p , rd , nor );        

    dif = iriCol * .25 + iriCol * pow( max( 0. , -reflMatch ) , 14. ) ;

       // float c = pow(( 1.-AO) , 5.)*  10.;
        float c = 0.;
        c += pow((1.- match),4.) * 1.;
        //c += pow(( 1.-AO) , 5.)*  2.;
        dif -= vec3( c) ;// * .4 * ( nor * .5 + .5 );
    	//dif = clamp(dif, 0.,.3);
    	return dif;
}

// Function 2141
float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<4; i++ )
    {
        float hr = 0.01 + 0.02*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos );
        occ += -(dd-hr)*sca;
        sca *= .95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 2142
vec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)
{
 	vec3 dir = normalize(l.pos - pos);  
    vec3 viewDir = normalize(camPos - pos);
    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;
    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);

    vec3 col = o.specKs*l.intensity*(l.color*pow(spec, o.specVal));
    return col;
}

// Function 2143
float shade( in vec3 ro, float mint, float maxt )
{
    float k = 2.3;
    vec3 rd = normalize(l-ro);
    float res = 1.0;
	float t=mint;
    for( int i = 0; i < 32; ++i)
    {
        if (t<maxt) ; else break;
        float h = map(ro + rd*t).x;
        if( h<0.001 )
            return 0.2;
        res = min( res, k*h/t );
        t += h;
    }
    return clamp(res+.2,0., 1.);
}

// Function 2144
vec3 Shade(MarchResult hit, vec3 direction, vec3 camera)
{
    vec3 color = vec3(0.0);

    if(hit.id == FLOOR)
    {
        float d = sdMaze(hit.position, 0.0).x;
        float a = smoothstep(0.05, 0.04, d);
        
        color = mix(vec3(0.3), vec3(1,0.1,1), a);
    }
    if(hit.id == WALLS)
    {
        float a = smoothstep(0.05, 0.04, min(-hit.position.z, hit.position.z + WALL_HEIGHT));
        color = mix(vec3(0.3), vec3(1, 0.1, 1), a);
    }
    color *= texture3Plane(iChannel0,hit.normal, hit.position * 4.0, -1.0).r * 0.5 + 0.5;
    
    //Lighting
    float ambient = 0.1;
    float diffuse = 0.5 * -dot(hit.normal, direction);
    float specular = 1.1 * max(0.0, -dot(direction, reflect(direction, hit.normal)));
    
    color *= vec3(ambient + diffuse + pow(specular, 5.0));
    color *= (1.0-(hit.steps / float(MAX_STEPS)));
	
    //Fog / haze
    float sky = smoothstep(MAX_DIST - 1.0, 0.0, hit.dist);
    float haze = clamp(0.5/(hit.dist/MAX_DIST),0.0,1.0);
    
    vec3 skycol = mix(HAZE_COLOR, SKY_COLOR, clamp(-hit.position.z * 0.2, 0.0, 1.0));
    
    color = mix(skycol, color, sky * haze);
    
    #ifdef SHOW_TILES
    color = texture(iChannel1, tile/iChannelResolution[1].xy+0.5, -99.0).rgb * (1.0-(hit.steps / float(MAX_STEPS)));
    #endif
    
    return color;
}

// Function 2145
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 3., occ = 0.;
    for(int i = 0; i<5; i++){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
}

// Function 2146
float calculateAO(in vec3 p, in vec3 n){
    
	float ao = 0.0, l;
	const float nbIte = 6.0;
	const float falloff = 1.;
    
    const float maxDist = 1.;
    for(float i=1.; i<nbIte+.5; i++){
    
        l = (i + hash(i))*.5/nbIte*maxDist;
        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);
    }
	
    return clamp( 1.-ao/nbIte, 0., 1.);
}

// Function 2147
vec3 Light(vec3 p, vec3 eye, vec3 Amb, vec3 Diff, vec3 Spec) {
    float IntensitySpec = 0.4;
    float IntensityDiff = 0.4;
    float shine = 10.0;
    vec3 source = vec3(sin(2.0*iTime)*3.0,cos(2.0*iTime)*3.0,sin(iTime)*cos(iTime)*4.0);
    //source = vec3(0.0,0.0,0.0);
    vec3 N = estimateNormal(p);
    vec3 L = normalize(source - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));
    Amb = interp(N,Amb,(1.0+cos(iTime))/2.0);
    vec3 col = Amb * 0.5;
    if (dot(L,N) < 0.0) {
        return col;
    }
    if (dot(R,V) < 0.0) {
        col += (Diff * IntensityDiff * dot(L,N));
        return col;
    }
    col += (Diff * IntensityDiff * dot(L,N));
    col += (Spec * pow(dot(R,V),shine));
    return col;
}

// Function 2148
vec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {
  if (dot(r,n) > 0.0) n = -n; // Face forwards
  vec3 c = baseColor*ambient;
  c += baseColor*diffuse*(max(0.0,dot(light,n)));
  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);
  c += specular*s*specularcolor;
  return c;
}

// Function 2149
float Shadows(vec3 Pos, vec3 Dir, float MaxDist, float ConeRatio) {
    Info t; float Dist=0.; float Occ=1.; float sD;
    while (Dist<MaxDist) {
        t=DF(Pos+Dir*Dist,iTime);
        if (t.d<0.001) return 0.;
        sD=Dist*ConeRatio;
        Occ=min(Occ,t.d/sD);
        Dist=Dist+t.d;
    }
    return Occ;
}

// Function 2150
vec3 applyLight(vec3 p, vec3 n,vec3 c, Light l){
  	vec3 toLight = l.pos - p;
    float emb = 0.04;
  	vec3 lightDir = normalize(toLight);
  	float d = length(toLight);
    
  	float k = dot(n,lightDir) * l.power;
    if(k < 0.)
    	return c * emb;
    
    //Shadow
    float lightTrace = tracer(p,lightDir,0.3);
    if(lightTrace != -1. && lightTrace <= d)
    	return c * emb;
    //
    
    float g = dot(vec3(k*k,k,1.0),1.0/(d*l.distKoef));
        
  	return c*l.color*g + c * emb;
    
}

// Function 2151
float calcAO(in vec3 p, in vec3 n)
{
	float sca = 3., occ = 0.;
    for( int i = 0; i<5; i++ ){
    
        float hr = float(i + 1)*.15/5.;        
        float d = map(p + n*hr);
        occ += (hr - d)*sca;
        sca *= .7;
    }
    
    return clamp(1. - occ, 0., 1.);  
    
    
}

// Function 2152
vec3 shadeFragment(in vec3 pos, in vec3 nrm, in vec3 view, in Material mtl)
{
    vec3 light = normalize(lightPosition.xyz - pos * lightPosition.w);
    vec3 h = normalize(view + light);
    vec3 vr = reflect(-view, nrm);
        
    float m2 = 1.0; // mtl.metallness * mtl.metallness;
    vec3 reflectance = vec3(0.04);
    
    vec3 diffuseColor = mtl.baseColor * (1.0 - m2);
    vec3 specularColor = mix(reflectance, mtl.baseColor, mtl.metallness);
    float maxF0 = max(specularColor.x, max(specularColor.y, specularColor.z));
        
    LightVariables lv;
    lv.shadow = calculateShadow(pos + 0.001 * nrm);
    lv.LdotN = max(0.0, dot(nrm, light));
    lv.VdotN = max(0.0, dot(nrm, view));
    lv.HdotN = max(0.0, dot(nrm, h));
    lv.HdotV = max(0.0, dot(view, h));
    lv.HdotL = max(0.0, dot(light, h));
    lv.roughness = max(0.02, mtl.roughness * mtl.roughness);
    lv.f0 = vec4(specularColor, maxF0);
        
    vec3 F = FRESNEL_SHLICK ? 
        F_Shlick(vec3(lv.f0.w), vec3(1.0), lv.VdotN) :
        F_Fresnel(vec3(lv.f0.w), lv.VdotN);
            
    vec3 diffuse = diffuseColor * 
        sampleDiffuseEnvironment(nrm) * lambertDiffuse(lv);
    
    vec3 specular = F * specularColor *
        (sampleReflectedEnvironment(vr, lv.roughness, lv.f0.w) + microfacetSpecular(lv));
    
    return (diffuse * DIFFUSE_SCALE + specular * SPECULAR_SCALE) * 
        (lightColor * lv.shadow) + ambientColor;
}

// Function 2153
float shadow(in vec3 position, in vec3 light_source_position, float step_size)
{
        float result = 0.;
        vec3 normal = normalize(light_source_position - position);

        for (int k = 0; k < 3; k++) {
                float i = float(k);

                result += (i * step_size -
                        query(position + normal * i * step_size)) / exp2(i);
        }

        return 1. - clamp(result, 0., 1.);
}

// Function 2154
float calculateAO( in vec3 p, in vec3 n)
{
	float ao = 0.0, l;
	const float nbIte = 6.0;
    const float maxDist = 3.;
	//const float falloff = 0.9;
    for(float i=1.; i< nbIte+.5; i++ ){
    
        l = (i*.66 + hash(i)*.34)/nbIte*maxDist;
        
        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);
    }
	
    return clamp( 1.-ao/nbIte, 0., 1.);
}

// Function 2155
float calcAO( in vec3 pos, in vec3 nor )
{
	float ao = 0.0;

	vec3 v = normalize(vec3(0.7,0.5,0.2));
	for( int i=ZERO; i<12; i++ )
	{
		float h = abs(sin(float(i)));
		vec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));
		ao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );
		v = v.yzx; if( (i&2)==2) v.yz *= -1.0;
	}
	ao /= 12.0;
	ao = ao + 2.0*ao*ao;
	return clamp( ao*5.0, 0.0, 1.0 );
}

// Function 2156
float light(vec2 p) {
    lightColor = vec3(.6,.8,1.);
    float box = sdBox(p - vec2(1.,0), vec2(.2));
    float circle = sdCircle(p + vec2(1.,0), .2);
    if(box > circle) lightColor = vec3(1,.9,.8);
    return smin(box, circle, 1.);
}

// Function 2157
float shadow( in vec3 ro, in vec3 rd)
{
	float res = 1.0;
    float t = .2;
    for (int i = 0; i < 12; i++)
	{
		float h = mapDE( ro + rd*t );
        if (h< -2.) break;
		res = min(10.*h / t, res);
		t += h+.2;
	}
    return max(res, .3);
}

// Function 2158
mat4 lightToWorldMatrix()
{
    return viewMatrix(lightPosition(), LIGHT_CAMERA_TARGET, UP);
}

// Function 2159
vec3 sampleLight( const in vec3 ro, inout float seed ) {
    vec3 n = randomSphereDirection(seed) * lightSphere.w;
    return lightSphere.xyz + n;
}

// Function 2160
float lightI( float t )
{
    // fade light when close to floor to avoid harsh pop
    return clamp((light(t).y-FLOORY)/2.,0.,1.);
}

// Function 2161
void shaderKoltes( out vec4 fragColor, in vec2 fragCoord , in vec2 resolution)
{
	vec2 uv = fragCoord.xy / resolution.xy;
    vec2 v=uv*(1.-uv);
    uv-=.5;
    uv.x*=resolution.x/resolution.y;
    uv.x = abs(uv.x);
    uv.x -= .45;
    
    vec3 ro=vec3(uv,-2),rd=vec3(uv,1),mp=ro;
    int i;
    for(i=0;i<50;++i){map2(mp);if(m.d<.001)break;mp+=rd*.5*m.d;}
    float ma=1.-float(i)/50.;
    vec3 c=m.c;
    c*=ma;
    if(length(mp)>INF){
        c=vec3(0.058, 1, 0.631)*.2;
    }
    c=pow(c,vec3(1./2.2));
    c *= pow(v.x*v.y * 25.0, 0.25);
	fragColor = vec4(c, 1.);
}

// Function 2162
float lightLevelCurve(float t) {
    t = mod(t, 1200.);
	return 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));
}

// Function 2163
float calcAO( in vec3 pos, in vec3 nor )
{
    #ifdef DISABLE_SHADOWS
        return 1.;
    #endif
    float occ = 0.0;
    float sca = 1.0;
    for( int i=ZERO; i<5; i++ )
    {
        float hr = 0.01 + 0.12*float(i)/4.0;
        vec3 aopos =  nor * hr + pos;
        float dd = map( aopos ).d;
        occ += -(dd-hr)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    
}

// Function 2164
vec3 RgbLightHit(vec3 posHit, vec3 normalRay, SHit hit)
{
	const float rScaleLightCone = 3.0;	// Enlarge light cone for softer shadows

	float uShadow = UConeTraceScene(
						posHit,
						g_normalLight,
						RLightCone() * rScaleLightCone,
						20.0,
						0.15,
						true);

#if DISABLE_SHADOWS
	uShadow = 1.0;
#endif

#if DEBUG_SHADOWS
	return vec3(uShadow);
#endif

	float uAmbient = UConeTraceScene(posHit, hit.m_normal, 1.0, 20.0, 0.05, false);

	// BB Hacky AO based on normal Z with height falloff

	uAmbient = min(uAmbient, mix(
								saturate(0.5 + 0.5 * hit.m_normal.z),
								1.0,
								saturate(posHit.z / 300.0)));

	float dSCellEdge = DSCellEdge(posHit);
	uAmbient = mix(uAmbient, 1.0, smoothstep(0.0, 1.0, 1.0 - dSCellEdge / 100.0));

#if DISABLE_AO
	uAmbient = 1.0;
#endif

#if DEBUG_AO
	return vec3(uAmbient);
#endif

	vec3 rgbLight = uAmbient * RgbAmbient() * hit.m_mtl.m_rgbDiffuse;
	float gDotLight = dot(g_normalLight, hit.m_normal);
	vec3 rgbDiffuse = hit.m_mtl.m_rgbDiffuse;
	float rDiffuse;
	float rSpecularLight = RSpecularLight(
							normalRay,
							hit.m_normal,
							hit.m_mtl.m_gGgxAlpha,
							rDiffuse);
	rgbDiffuse *= rDiffuse;
	rgbLight += uShadow * saturate(gDotLight) * (rgbDiffuse + rSpecularLight) * RgbLight();

	return rgbLight;
}

// Function 2165
float RayLight(vec3 ro,vec3 rd)
{
    float dO=0.0;
    for(int i=0; i<MAX_STEPS; i++)
    {
        vec3 p=ro+rd*dO;
        float ds=GetDist(p);
        dO+=ds;
        if(MAX_DIST<dO || ds<SURF_DIST)
        break;
    }
    return dO;
}

// Function 2166
vec3 OrenNayarLightModel(vec3 rd, vec3 ld, vec3 n){
	vec3 col = vec3(1.);//cubeMap(uCubeMap, ld, uCubeMapSize.x).rgb;

	float RDdotN = dot(-rd, n);
	float NdotLD = dot(n, ld);
    
    float aRDN = acos(RDdotN);
	float aNLD = acos(NdotLD);
    
	float mu = .3; // roughness
	if (iMouse.z>0.) mu = iMouse.y/iResolution.y;
    
	float A = 1.-.5*mu*mu/(mu*mu+0.57);
    float B = .45*mu*mu/(mu*mu+0.09);

	float alpha = max(aRDN, aNLD);
	float beta = min(aRDN, aNLD);
	
	float albedo = 1.1;
	
	float e0 = 3.1;
	col *= vec3(albedo / 3.14159) * cos(aNLD) * (A + ( B * max(0.,cos(aRDN - aNLD)) * sin(alpha) * tan(beta)))*e0;
	
	return col;
}

// Function 2167
float calcShadow( in vec3 ro, in vec3 rd )
{
    float res = 1.0;
    float t = 0.01;
    for( int i=ZERO; i<100; i++ )
    {
        vec3 pos = ro + rd*t;
        float h = mapShadow( pos ).x;
        res = min( res, 16.0*max(h,0.0)/t );
        if( h<0.0001 || pos.y>3.0 ) break;
        
        t += clamp(h,0.01,0.2);
    }
    
    return clamp(res,0.0,1.0);
}

// Function 2168
vec3 shade(float r, vec2 center, vec2 pos, vec3 l[2])
{
    float z = sqrt(r * r - pos.x * pos.x - pos.y * pos.y);
    vec3 n = normalize(vec3(pos.x, pos.y, z)); 		// Surface normal

    vec3 c_diff = vec3(0.9, 0.0, 0.7);				// Diffuse color    
    vec3 c_spec = vec3(0.0, 1.0, 1.0);				// Specular color

    float m = 11.0; 								// Surface Smoothness
    float El = 0.9; 								// Irradiance of light source
    vec3 Kd = c_diff.xyz / PI; 						// Diffuse term
    vec3 Ks = c_spec.xyz * ((m + 8.0) / (8.0 * PI));// Specular term

    vec3 Lo = vec3(0.0);
    for (int i = 0; i < 2; i++)
    {
        vec3 h = normalize(l[i] + n); // Half vector

        float cosTi = max(dot(n, l[i]), 0.0);
        float cosTh = max(dot(n, h), 0.0);
        Lo += (Kd.xyz + Ks.xyz * pow(cosTh, m)) * El * cosTi; // Outgoing radiance
    }  

    return Lo; 
    
}

