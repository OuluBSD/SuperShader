// Reusable Primitives Raymarching Functions
// Automatically extracted from raymarching/raytracing-related shaders

// Function 1
float sdPlane( vec3 p )
{ 
	return p.y;
}

// Function 2
vec3 bary_from_sphere(vec3 q) {    
    return bary_from_planar(planar_from_sphere(q));
}

// Function 3
bool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {
	vec3  ds = ro - sph;
	float bs = dot( rd, ds );
	float cs = dot(  ds, ds ) - 1.0;
	float ts = bs*bs - cs;
	
	if( ts > 0.0 ) {
		ts = -bs - sqrt( ts );
		if( ts>0. ) {
			normal = normalize( (ro+ts*rd)-sph );
			dist = ts;
			return true;
		}
	}
	
	return false;
}

// Function 4
float CappedCylinder( vec3 pos, vec3 p, vec2 h )
{
  p = p-pos;
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 5
float minBox( float d1, float d2 ){
return min(d1,d2);
}

// Function 6
bool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )
{
    vec3 N = vec3( pln.A, pln.B, pln.C );
    float NRd = dot( N, ray.d );
    float NRo = dot( N, ray.o );
    float t0 = (-pln.D - NRo) / NRd;
    if ( t0 < tmin || t0 > tmax ) return false;
    return true;
}

// Function 7
bool intPlane( in vec4 pl, in vec3 ro, in vec3 rd, out float t ) {
    float tt = -(dot(pl.xyz,ro)+pl.w)/dot(pl.xyz,rd);
    if (tt > 0.0) {
        t = tt;
        return true;
    }
    return false;
}

// Function 8
float sdTorus( vec3 p, vec2 t )
{
  return length( vec2(length(p.xz)-t.x*1.2,p.y) )-t.y;
}

// Function 9
void boxFold(inout vec3 z, inout float dz){z = clamp(z, -1.0, 1.0)*2.0-z;}

// Function 10
float sdBoxFrame( vec3 p, vec3 c, vec3 b, float e )
{
    p = p - c;
  p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 11
bool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return false;
	return tN>0.0 && tN<tmax;
}

// Function 12
float udRoundBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

// Function 13
void boxBlur( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / iResolution.xy;
    
	int kernel_window_size = BOXRADIUS*2+1;
    int samples = kernel_window_size*kernel_window_size;
    
    highp vec4 color = vec4(0);
    
    highp float wsum = 0.0;
    for (int ry = -BOXRADIUS; ry <= BOXRADIUS; ++ry)
    for (int rx = -BOXRADIUS; rx <= BOXRADIUS; ++rx)
    {
        highp float w = 1.0;
        wsum += w;
    	color += texture(iChannel0, uv+vec2(rx,ry)/iResolution.xy)*w;
    }
    
    fragColor = color/wsum;
}

// Function 14
float plane      (vec3 pos){return  pos.y+2.0;}

// Function 15
vec3 spheres(ray r, float t, vec3 bg)
{
	r.o += t*MOVEMENT;
	vec4 color = vec4(bg,0.0);
	for(int i = 0; i < NUMLAYERS; i++)
	{
		plane pl = plane(vec3(0.0,0.0,-1.0),LAYERS[i]);
		vec3 p = r.o + intersectPlane(r,pl).t * r.d;
		p = vec3(floor(p.xy)+vec2(0.5),p.z);
		
		float rnd = rand(p.xy+float(i));
		
		float radius = mix(0.01, 0.3, rnd);	
		vec2 offset = rand2D(p.xy+float(i));
		offset.x *= sin(3.0*radius*t+rnd);
		p.xy += offset*(0.5-radius);
		
		sphere s = sphere(p, radius);	
		vec4 c = getColor(r,intersectSphere(r, s),t,rnd,s);

		float a = c.a*(1.0-color.a);
		color.rgb = mix(color.rgb, c.rgb, a);
		color.a += a;
	}	
	return color.rgb;
}

// Function 16
float intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 nrm, out vec2 t) {
    vec3 t0 = (-o - ext) / d;
    vec3 t1 = (-o + ext) / d;
    vec3 n = min(t0,t1); t.x = max(max(n.x,n.y),n.z);
    vec3 f = max(t0,t1); t.y = min(min(f.x,f.y),f.z);
    r0 = o + d * t.x;
    nrm = abs(r0/ext);
    nrm = step(vec3(max(max(nrm.x,nrm.y),nrm.z)),nrm) * sign(r0);
    return step(t.x,t.y);
}

// Function 17
float plane(in vec3 p0, in vec3 l0, in vec3 l, in vec3 n) {
    return dot((p0 - l0), n) / dot(l, n);
}

// Function 18
float sphere(in vec3 p, in float r) { return length(p) - r; }

// Function 19
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {
    vec3 oc = ro - sph.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - sph.w * sph.w;
    float h = b * b - c;
    if (h < 0.0) return -1.0;

	float s = sqrt(h);
	float t1 = -b - s;
	float t2 = -b + s;
	
	return t1 < 0.0 ? t2 : t1;
}

// Function 20
bool intersectHyperplane(vec4 rayPosition, vec4 rayDirection, out float t)
{
    t = -rayPosition[3] / rayDirection[3];

    return t > 0.0 && !isinf(t);
}

// Function 21
float PrBox2Df (vec2 p, vec2 b)
{
  vec2 d = abs (p) - b;
  return min (max (d.x, d.y), 0.) + length (max (d, 0.));
}

// Function 22
float y_sphere_common(in float offset) {
    if (offset > 20.0 && offset <= 22.0)
        return sin((offset - 20.0) / 2.0 * PI / 2.0) * movement + movement;
    else if (offset > 22.0 && offset <= 30.0)
        return movement * 2.0;
    else if (offset > 30.0 && offset <= 64.0)
        return sin((offset - 30.0) / 2.0 * PI / 2.0 + PI / 2.0) * 2.0 * movement;
}

// Function 23
bool intersectSphere(in vec3 ro, in vec3 rd, in Sphere sphere, out vec3 col) {
    vec3 cp = ro + rd * dot(rd, sphere.center - ro);
    float H = length(cp-sphere.center);    
    float h = sqrt(sphere.radius*sphere.radius - H*H);
    col = cp - rd * h;
    return H<sphere.radius;
}

// Function 24
vec2 centerBox(Box A){
    return (A.min+A.max)*.5;
}

// Function 25
float dfPlane(vec3 p, vec3 n, float d) { return dot(p,n) + d; }

// Function 26
bool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,
                  out float t, out vec3 hitPos, out vec3 hitNormal )
{
    Plane_t faces[6];
    vec3 faces_normal[6];
    // calculate normal vectors of 6 faces
    faces_normal[0] = vec3(-cos(box.angle), 0.0, -sin(box.angle));
    faces_normal[1] = vec3(cos(box.angle), 0.0, sin(box.angle));
    faces_normal[2] = vec3(0.0, -1.0, 0.0);
    faces_normal[3] = vec3(0.0, 1.0, 0.0);
    faces_normal[4] = vec3(sin(box.angle), 0.0, -cos(box.angle));
    faces_normal[5] = vec3(-sin(box.angle), 0.0, cos(box.angle));

    for (int i = 0 ; i < 3 ; i++) {
        // construct 6 planes
        faces[2 * i] = Plane_t(faces_normal[2 * i].x, faces_normal[2 * i].y, faces_normal[2 * i].z,
                              -dot(faces_normal[2 * i], box.corner1), box.materialID);
        faces[2 * i + 1] = Plane_t(faces_normal[2 * i + 1].x, faces_normal[2 * i + 1].y, faces_normal[2 * i + 1].z,
                      -dot(faces_normal[2 * i + 1], box.corner2), box.materialID);
    }
    
    float largest_near = tmin;
    float smallest_far = tmax;

    vec3 near_hitPos;
    vec3 near_hitNormal;
    
    for (int i = 0 ; i < 3 ; i++) {
        // for each pair of parallel planes
        // check if the ray intersects with each of them
        float t_neg;
        vec3 hitPos_neg;
        vec3 hitNormal_neg;
        bool hashit_neg = IntersectPlane(faces[2 * i], ray, tmin, tmax,
                                         t_neg, hitPos_neg, hitNormal_neg);
        
        float t_pos;
        vec3 hitPos_pos;
        vec3 hitNormal_pos;
        bool hashit_pos = IntersectPlane(faces[2 * i + 1], ray, tmin, tmax,
                                         t_pos, hitPos_pos, hitNormal_pos);
        // at most 2 hits
        float t_near;
        float t_far;
        // if no hit
        if (!hashit_neg && !hashit_pos) {
            // check if origin of the ray is located between 2 planes 
            // and exactly parallel to these 2 planes
            float res1 = dot(ray.o, vec3(faces[2 * i].A, faces[2 * i].B, faces[2 * i].C)) + faces[2 * i].D;
            float res2 = dot(ray.o, vec3(faces[2 * i + 1].A, faces[2 * i + 1].B, faces[2 * i + 1].C)) + faces[2 * i + 1].D;
            if (res1 < -tmin && res2 < -tmin)
                // if it is, ignore
                continue;
            else 
                // otherwise there cannot be ray-box intersections
                return false;
        }
        else if (hashit_neg && !hashit_pos) {
            // only hit the negative plane, record it as t_far
            t_far = t_neg;
            if (smallest_far > t_far)
                smallest_far = t_far;
        }
        else if (!hashit_neg && hashit_pos) {
            // only hit the positive plane, record it as t_far 
            t_far = t_pos;
            if (smallest_far > t_far)
                smallest_far = t_far;
        }
        else if (hashit_neg && hashit_pos) {
            // hit both planes
            // the smaller t is t_near, the other is t_far
            t_near = t_neg < t_pos ? t_neg : t_pos;
            t_far = t_neg > t_pos ? t_neg : t_pos;
            if (largest_near < t_near) {
                // update if t_near is a larger one
                largest_near = t_near;
                near_hitPos = t_neg < t_pos ? hitPos_neg : hitPos_pos;
                near_hitNormal = t_neg < t_pos ? hitNormal_neg : hitNormal_pos;
            }
            if (smallest_far > t_far) {
                smallest_far = t_far;
            }
        }
    }    
    // if the ray exits a pair of planes while it has not enter another pair of planes
    // then no ray-box intersection
    if (largest_near >= smallest_far) return false;
    t = largest_near;
    hitPos = near_hitPos;
    hitNormal = near_hitNormal;

    return true;
}

// Function 27
float cone(vec3 p, vec2 a, float l) {
    return max(max(a.x*length(p.xy)+a.y*p.z, p.z), abs(p.z)-l);
}

// Function 28
vec4 ray_cylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ){
    vec3 ca = pb-pa;
    vec3 oc = ro-pa;
    float caca = dot(ca,ca);
    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    float a = caca - card*card;
    float b = caca*dot( oc, rd) - caoc*card;
    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;
    float h = b*b - a*c;
    if( h<0.0 ) return vec4(-1.0); //no intersection
    h = sqrt(h);
    float t = (-b-h)/a;
    // body
    float y = caoc + t*card;
    if( y>0.0 && y<caca ) return vec4( (oc+t*rd-ca*y/caca)/ra, t );
    // caps
    t = (((y<0.0)?0.0:caca) - caoc)/card;
    if( abs(b+a*t)<h ) return vec4( ca*sign(y)/caca, t );
    return vec4(-1.0); //no intersection
}

// Function 29
vec3 cosineHemisphere(vec2 uv, vec3 n)
{
    //http://www.amietia.com/lambertnotangent.html
    float phi = PI2 * uv.x;
    float cosTheta = 2.0*uv.y - 1.0;
    return normalize( n + vec3(sqrt(1.0-cosTheta*cosTheta) * vec2(cos(phi), sin(phi)), cosTheta) );
}

// Function 30
DAMValue plane(DAVec3 p){return DAMValue(addd(p.y,1.),1.);}

// Function 31
float plane(vec3 p, float D) {
	return D - dot(abs(p), normalize(vec3(0.0, 1.0, 0.0)));
}

// Function 32
float  Sphere( vec3 p, float s )
{
    return length(p)-s;
}

// Function 33
void TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)
{
    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);
    if (dist < info.dist)
    {
        info.objectPass = OBJECTPASS_RAYMARCH;
        info.dist = dist;
        
        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);
        int maxIndex = MaxCompIndex(relPos);
        if (maxIndex == 0)
        {
            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
        }
        else if(maxIndex == 1)
        {
            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);
        }
        else
        {
            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);
        }
        
        info.material = material;
    }    
}

// Function 34
vec4 noised_improveXYPlanes(in vec3 x)
{
    mat3 orthonormalMap = mat3(
        0.788675134594813, -0.211324865405187, -0.577350269189626,
        -0.211324865405187, 0.788675134594813, -0.577350269189626,
        0.577350269189626, 0.577350269189626, 0.577350269189626);
    x = x * orthonormalMap;
    
    vec4 result = noised(x);
    result.yzw = orthonormalMap * result.yzw;
    return result;
}

// Function 35
float box(vec3 p, vec3 t, vec3 s) { 
    return length(max(abs(p-t)-s,0.0)); 
}

// Function 36
float yplanedf( vec3 p, float offset )
{
    return abs(p.y - offset);
}

// Function 37
void dbox3(in vec3 x, in vec3 b, out float d)
{
  	vec3 da = abs(x) - b;
  	d = length(max(da,0.0)) + min(max(da.x,max(da.y,da.z)),0.0);
}

// Function 38
float dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}

// Function 39
float RoundBox( vec3 p, vec3 b, float r )
{
	return length(max(abs(p)-b,0.0))-r;
}

// Function 40
vec4 hemisphereImpact(in vec3 pos, in vec3 ray, in vec3 sphO, in float sphR){
    vec2 t = vec2(INFINI);
    vec3 d = sphO - pos;
    float b = dot(d, ray);
    
    if (b >= 0.){	// check if object in frontside first (not behind screen)
        float c = dot(d,d) - sphR*sphR;
    	float disc = b*b - c;
    	if (disc >= 0.){
        	float sqdisc = sqrt(disc);
            t.x = b + sqdisc;
            t.y = b - sqdisc;
        	
            t += step(t,vec2(0.))*INFINI;		// eliminate negative value
            vec2 h = pos.y + t*ray.y;
            
        	t += (1.-step(vec2(sphO.y), h))*INFINI;		// eliminate if intersection is below sphO
        }
    }
    float tt = min(t.x, t.y);
    float s = 1. - 2.*step(t.x,t.y);

    return vec4(s*normalize(pos + tt*ray - sphO), tt);
}

// Function 41
float intersectPlane(vec3 rOrigin, vec3 rayDir, vec3 origin, vec3 normal, vec3 up, out vec2 uv) {
    float d = dot(normal, (origin - rOrigin)) / dot(rayDir, normal);
  	vec3 point = rOrigin + d * rayDir;
	vec3 tangent = cross(normal, up);
	vec3 bitangent = cross(normal, tangent);
    point -= origin;
    uv = vec2(dot(tangent, point), dot(bitangent, point));
    return max(sign(d), 0.);
}

// Function 42
poly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {
#if 1
	return pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);
#else
    poly2 d = pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z));
    return pa_sub(pa_spow2(d),n.w * n.w * sign(n.w));
#endif
}

// Function 43
float plane(in vec3 ro, in vec3 rd, in vec3 norm, in vec3 pointInPlane) {
    return dot(pointInPlane-ro,norm)/dot(rd, norm);
}

// Function 44
float dePlane(vec3 p, vec3 planeN)
{
    return dot(p, planeN);
}

// Function 45
float  sphere( vec3 p, float s )
{
    return length(p)-s;
}

// Function 46
vec3 SphereRand( vec2 rand )
{
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

// Function 47
vec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )
{
	vec3 oc = ro;
    float a = dot( rd.xz, rd.xz );
	float b = dot( oc.xz, rd.xz );
	float c = dot( oc.xz, oc.xz ) - rad*rad;
	float h = b*b - a*c;
	if( h<0.0 ) return vec2(-1.0);
    h = sqrt(h);
	return vec2(-b-h,-b+h)/a;
}

// Function 48
float sdDuoCylinder(in vec4 p, in vec2 r1r2) {
  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;
  return min(max(d.x,d.y),0.) + length(max(d,0.));
}

// Function 49
void getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
	vec2 offset = grid + sphereOffset;
	center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}

// Function 50
float distBox( in vec3 p, in vec3 b )
{
  return length(max(abs(p)-b,0.0));
}

// Function 51
float sdWaveSphere(vec3 p, float radius, int waves, float waveSize)
{
  //bounding Sphere
  float d = length(p) - radius*2.2;
  if(d > 0.0) return 0.2;

  // deformation of radius
//d = waveSize * (radius - abs(p.y));
  d = waveSize * (radius*radius-(p.y*p.y));
  radius += d * cos(atan(p.x,p.z) * float(waves));
  return 0.5*(length(p) - radius);
}

// Function 52
float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 53
float sphereSlime(vec3 p)
{
    float t = sin(iTime)*0.4;
    p.xy *= rotate(t*PI*1.4);
    return length(p) - abs(cos(p.x+iTime))*.2 - abs(sin(p.y+iTime))*.2;
}

// Function 54
float SphereDist(vec3 position)
{
	return length(position - ExpPosition) - Radius;
}

// Function 55
vec2 boxRay(in vec3 ro, in vec3 rd)
{
    vec3 i_p = (vec3(box_x, box_y, box_x) - ro ) / rd;
    vec3 i_m = (-vec3(box_x,0.5*box_y, box_x) - ro ) / rd;
    
    vec3 vmin = min(i_p, i_m);
    vec3 vmax = max(i_p, i_m);
    
    // min, max
    return vec2(max(max(vmin.x, vmin.y), vmin.z),min(min(vmax.x, vmax.y), vmax.z));
}

// Function 56
void mainImagePlanet(out vec4 fragColor, in vec3 nor)
{

    float rot = rotation.z;
    nor = (mat3(1.0, 0.0, 0.0, 
                     0.0, cos(rot), - sin(rot), 
                     0.0, sin(rot), cos(rot)) * nor).xyz;
    rot = rotation.x;
    nor = (mat3(cos(rot), 0.0, sin(rot), 
                0.0, 1.0, 0.0,
                -sin(rot), 0.0, -cos(rot)) * nor).xyz;
    
    rot = iTime / 1000.0;
    vec2 pos = (mat3(cos(rot), 0.0, sin(rot), 0.0, 1.0, 0.0, -sin(rot), 0.0, cos(rot)) * vec3(nor.xy,-10.0)).xy;
    
	
    float time = iTime;
	float q = time / 1000.0;

    
	float srnd = snoise((q + nor.yx) * 50.0) / 5.0;
	srnd += snoise((q + nor.yx) * 10.0) / 2.0;
    srnd += snoise((q + nor.yx) * 100.0) / 10.0;
	float rnd = snoise((q + nor.xy) * 50.0) / 50.0;

    float lat = 0.5;
    float stormity = sqrt(max(0.0, 1.0 - abs(lat - nor.y) / lat) / 1.2);
    float s1 = snoise(nor.xy * 1.520) * stormity;
    float s2 = snoise(nor.xy * 1.75) * stormity;
    float s3 = snoise(nor.xy * 0.75) * stormity;
    
    float storm = s1 * s2 *s3;
    vec2 sv;
    if (storm > 0.0) {
    	sv = (nor * vec3(storm * storm * 10.0)).xy;
    } else {
        sv = vec2(0.0);
    }
    
    nor.xy *= (1.0 - sv);
        
	vec4 color = (texture(iChannel0,((nor + 1.0) * 0.5).yy + srnd / 100.0 + rnd / 10.0)
        +
        texture(iChannel0,((nor + 1.00) * 0.5).yy + 0.003 + srnd / 100.0  )
        +
        texture(iChannel0,((nor + 1.00) * 0.5).yy - 0.003 + srnd / 100.0)) / 3.0;
	
    
    fragColor = color;// * ((0.25 + dot(nor.xyz, vec3(-10.25, 10.5, 0.0))) / 4.0);
}

// Function 57
float sphere1(in vec3 rp) {
   	return length(rp-vec3(5.,0.,0.))-2.;
}

// Function 58
float sdBox(in vec3 p, in vec3 box) {
   vec3 d = abs(p) - box;
   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 59
float sdPlane(vec3 p, vec4 n) {
    return dot(p,n.xyz)+n.w;
}

// Function 60
float fBox2(vec2 p, vec2 b) {
	vec2 d = abs(p) - b;
	return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));
}

// Function 61
float fCylinder(vec3 p, float r, float height) {
float d = length(p.xz) - r;
d = max(d, abs(p.y) - height);
return d;
}

// Function 62
float RotatedBox(vec3 p, vec3 b, float rz, float rx) {
    vec3 pp=p;
    pp.xy=Rotate(p.xy,rz);
    pp.yz=Rotate(pp.yz,rx);
    return BoxC(pp,b);
}

// Function 63
float DispSphere(vec3 samplePos, float r)
{
	float bump = 0.0;
    
	if(length(samplePos) < r + BumpFactor)
    {
		bump = Tex3D(samplePos * TexScaleFactor, normalize(samplePos), iChannel0).r * BumpFactor;
	}
    
	return length(samplePos) - r + bump;
}

// Function 64
float diplane(vec3 p,vec3 b,vec3 rd){
    p/=b;
    vec3 dir = sign(rd)*.5;   
    vec3 rc = (dir-p)/rd;
    rc*=b;
    float dc = rc.z+0.01;
    return dc;
}

// Function 65
float torus(vec3 p, vec2 d)
{
	vec2 q = vec2(length(p.xz) - d.x, p.y);
	return length(q) - d.y;
}

// Function 66
float linesTextureGradBox( in float p, in float ddx, in float ddy, int id )
{
    float N = 12.0;//float( 2 + 7*((id>>1)&3) );

    float w = max(abs(ddx), abs(ddy)) + 0.01;
    float a = p + 0.5*w;                        
    float b = p - 0.5*w;           
    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-
                  floor(b)-min(fract(b)*N,1.0))/(N*w);
}

// Function 67
float intersectCylinder(out vec3 normal,
                        in Ray r,
                        in vec3 o,
                        float hl,
                        float r2)
{
    vec2 g = r.o.xy - o.xy;
    
    //<g + t*v.d, g + t*v.d> = r^2
    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0

    float a = dot(r.d.xy, r.d.xy);
    float b = 2.0*dot(g.xy, r.d.xy);
    float c = dot(g.xy, g.xy) - r2;
    
    float disc = b*b - 4.0*a*c;
    if(disc < 0.0) return -1.0;

    
    float d = sqrt(disc);
    float t0 = (-b - d)/(2.0*a);
    float t1 = (-b + d)/(2.0*a);

    float rcp = 1.0/r.d.z;
    float aa = rcp*(o - r.o).z;
    float ta = aa - abs(rcp)*hl;
    float tb = aa + abs(rcp)*hl;

    // cylinder is between near and far cap
    if(ta <= t0 && t0 <= tb) {
        vec2 w = g + t0*r.d.xy;
	    normal = normalize(vec3(w,0));
        return t0;
    }
            
    // near cap is inside infinite cylinder
    if(t0 < ta && ta < t1) {
     	normal = vec3(0,0,-sign(r.d.z));
        return ta;
    }

    return -1.0;
}

// Function 68
float sdTorus88( vec3 p, vec2 t )
{
  vec2 q = vec2(length8(p.xz)-t.x, p.y);
  return length8(q)-t.y;
}

// Function 69
vec3 Box(vec2 p)
{
	float t= sin(iTime*.03)*1.5;
	mat2 m = mat2(cos(t), sin(t), -sin(t), cos(t));
	p*= m;
	vec2 b = vec2(.6, .6);
	vec2 d = abs(p) - b;
  	float f = min(max(d.x, d.y),0.0) + length(max(d,0.0));
	float pix = Noise(p*20.0)*.29;
	if (f < pix && f > -pix) return hsv(Noise(p*33.0));
	else return vec3(0.0, 0.0, .0);
}

// Function 70
float SDFBox(vec3 point, vec3 size)
{
    vec3 d = abs(point) - size;
    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 71
vec3 random_in_unit_sphere() {
    vec3 h = hash3() * vec3(2.,6.28318530718,1.0)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 0.33333333333);
	return r * vec3(sqrt(1.0-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// Function 72
float sdCylinderXY( const vec3 p, const vec2 h ) {
  vec2 d = abs(vec2(length(p.xy),p.z)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 73
vec2 sdRepBox(vec3 p) {
    vec3 r;  // transform in xy id in z
    vec3 q;
    float id;
    float time = T*0.5;
    
    float l=4.;
    float sz=l/ float(ITEMS_COUNT);
    float a=(PI*(1.+1./float(ITEMS_COUNT-1)))*cos(-time*PI);
    q=p;
    
    bool headup = fract(time*.5) > .5;
    float stride = l*(1.-1./float(ITEMS_COUNT))/PI;
    q.x-=stride; // center
     q.x-=-2.*fract(time)*stride; // follow
     // a = 0.0;
    if ( headup ) {    
        // straight
        if ( abs(a) < 0.01 ) {
            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));
            q.y = q.y-sz*id; // repetion
        } else if ( a >0.) {
        // bend right
            float ll = l/a;
            r=opRepPolar(vec2(-q.x+ll,q.y),ll,ITEMS_COUNT,TAU-a);
            id=r.z;
            q=vec3(-r.x,r.y,q.z);
        } else {
        // bend left
            float ll = -l/a;
            r=opRepPolar(vec2(q.x+ll,q.y),ll,ITEMS_COUNT,TAU+a);
            id=r.z;
            q=vec3(r.x,r.y,q.z);
        }
    } else {
        // straight
        if ( abs(a) < 0.01 ) {
            q.xy=-q.xy;
            q.y-=-l+sz;
            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));
            q.y = q.y-sz*id; // repetion
            // id-=float(ITEMS_COUNT)+1.0;
        } else if ( a >0.0) {
        // bend right
            float ll = l/a;
            r=opRepPolarBU(vec2(-q.x-ll,q.y),ll,ITEMS_COUNT,TAU-a);
            id=r.z;
            q=vec3(-r.x,r.y,q.z);
        } else {
        // bend left
            float ll = -l/a;
            r=opRepPolarBU(vec2(q.x-ll,q.y),ll,ITEMS_COUNT,TAU+a);
            id=r.z;
            q=vec3(r.x,r.y,q.z);
        }
    }
    
    
    float d = sdCappedTorus(q.zxy-vec3(0.,0.,0.0),vec2(sin(2.),cos(2.)),.4,DONUT_SIZE);
	// float d = sdTorus(q,vec2(.4,DONUT_SIZE));
    // float d = sdHexPrism(q.zxy,vec2(0.4,DONUT_SIZE))-.02;
    // float d = sdOctahedron(q,0.4); 
    // float d = length(q)-0.4; // sphere
    return vec2(d,id);
}

// Function 74
float sbox(vec3 p){ return max(max(p.x, p.y), p.z); }

// Function 75
float box(vec3 p, vec3 b, float r) {
  vec3 q = abs(p) - b;
  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0)-r;
}

// Function 76
void BoxIntersectMin(vec3 ro, vec3 rd, vec3 box, vec3 bpos, float angle, inout bool result, inout HitInfo hit, bool transp) {
    float tnew;
    vec3 normnew;
    mat4 rot = rotationAxisAngle( normalize(vec3(1.0,1.0,0.0)),  angle);
	mat4 tra = translate(bpos);
	mat4 txi = tra * rot; 
	mat4 txx = inverse( txi );
    if (BoxIntersect(ro, rd, txx, txi, box, tnew, normnew)) {
        bool val=false;
        if(transp)val=tnew < MAX_DIST;
        else val=tnew < hit.t;
        if (val) {
            hit.t = tnew;
            hit.norm = normnew;
            if(transp){
                vec3 lc=hit.color.rgb;
                hit.color.a = texBox(ro,rd,hit.t,normnew,txx).r;
                hit.color.rgb=lc;
            }else{
                float la=hit.color.a;
                hit.color.rgb = texBox(ro,rd,hit.t,normnew,txx).r*vec3(1.,0.28,0.15);
                hit.color.a=la;
            }
            hit.obj_type = OBJ_CUBE;
        }
        result = true;
    }
}

// Function 77
float raySphere(in Ray r, in Shape s, out vec3 p, out vec3 n)
{
    float t = -1.0;
	vec3 dv = r.o - s.c;
    float distanceToCenterSquared = dot(dv, dv);
    float radiusSquared = s.dim.x * s.dim.x;
    
    bool startedInside = distanceToCenterSquared <= radiusSquared;
	
	float b = dot(r.d, dv);
    if (b <= 0.0) 
    {
		float d = b * b - distanceToCenterSquared + radiusSquared;
        if (d >= 0.0) 
        {
			d = sqrt(d);
            float t0 = -b - d;
            float t1 = -b + d;
            
            if (t0 < 0.0) t0 = huge;
            if (t1 < 0.0) t1 = huge;
            
            t = min(t0, t1);
            p = r.o + t * r.d;
            n = normalize(startedInside ? (s.c - p) : (p - s.c));
        }
    }
    
	return t;
}

// Function 78
TraceOutput tracePlaneCabin( Ray ray, float soft_shadow_sharpness, float window_radius_scale )
{
	float DBREAK = 0.0025; // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are
	float TFRAC = 0.25;

	TraceOutput to;
	to.t = 0.0;
	to.num_iterations = 0.0;
	to.dist = 0.0;
	to.shadow = 1.0;

	for ( int i = 0; i < MAX_ITERATIONS; ++i )
	{
		float d = sdPlaneCabin( ray.o + to.t * ray.d, window_radius_scale );
		to.dist = d;
		if ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > TMAX ) break;
		to.shadow = min( to.shadow, soft_shadow_sharpness * to.dist / to.t ); // http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf
		to.t += to.dist * TFRAC; // d can be negative... hmm
		to.num_iterations += 1.0;
	}

	to.shadow = max( 0.0, to.shadow ); // hide shitty artifacts
	return to;
}

// Function 79
float sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)
{
  vec3  ba = b - a;
  vec3  pa = p - a;
  float baba = dot(ba,ba);
  float paba = dot(pa,ba);
  float x = length(pa*baba-ba*paba) - r*baba;
  float y = abs(paba-baba*0.5)-baba*0.5;
  float x2 = x*x;
  float y2 = y*y*baba;
  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
  return sign(d)*sqrt(abs(d))/baba;
}

// Function 80
vec3 SampleHemisphereUniform(vec3 N, vec2 s)
{
	return SampleHemisphereUniformCone(N, s, PI*0.5);
}

// Function 81
void drawCylinder(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 cylNorm;
    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);
    
    if(cylT < cur_ctxt.t)
    {
        cur_ctxt.t = cylT;
        
        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;
    
        cur_ctxt.materialType = DIFFUSE; 
        cur_ctxt.color = 0.3*texture(iChannel0, worldPos.xz * worldPos.y).rgb 
                                        + 0.7*texture(iChannel2, ray.dir).rgb;
        //cur_ctxt.color = vec3(1, 0, 0);
        cur_ctxt.n = cylNorm;
        
        cur_ctxt.alpha = 0.0;
    }
}

// Function 82
float distCylinderXZ(vec3 p, vec3 c)
{
    return length(p.xz - c.xy) - c.z;
}

// Function 83
float fTorus(vec4 p4, float R) {
  // Torus distance
  // Distance from surface x^2 + y^2 = R^2
  return abs(R-length(p4.xy));
}

// Function 84
void TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)
{
    float dist = PlaneDistance(plane, rayPos);
    if (dist < info.dist)
    {
        info.objectPass = OBJECTPASS_RAYMARCH;
        info.dist = dist;        
        info.normal = plane.xyz;
        info.material = material;
    }    
}

// Function 85
Sphere createSphere(vec3 center, float radius)
{
    Sphere s;
    s.center = center;
    s.radius = radius;
    return s;
}

// Function 86
float intersect_sphere( Ray r, vec3 sphere, float rad )
{
	vec3 oc = r.origin - sphere;
	float b = dot( oc, r.dir );
	float c = dot( oc, oc ) - rad*rad;
	float h = b*b - c;
	if( h<0.0 ) return -1.0;
	return -b - sqrt( h );
}

// Function 87
void getTexBBox(float texIdx, out vec2 _min, out vec2 _max)
{
    vec2 texMinRC = vec2(0., floor(texIdx * TEXTURES_INV_ROW));
    texMinRC.x = texIdx - texMinRC.y*TEXTURES_ROW;
    _min = TEXTURES_INV_ROW * texMinRC;
    _max = _min + vec2(TEXTURES_INV_ROW);
}

// Function 88
float torusSDF_melt( vec3 p, float r, float thickness ){
  vec2 q = fract(.3 * vec2(length(p.xz)-r,p.y));
  return length(q)- thickness;
}

// Function 89
float sdCylinder (in vec3 p, in vec3 h)
{
  return length(p.xz - h.xy) - h.z;
}

// Function 90
void boxFold(inout vec3 z, inout float dz) {
                float wav = pow(texture(iChannel1, vec2(length(z.xy), 0.) ).x, 0.5) ;
				float foldingLimit = wav/50. + 2.0;
				z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
			}

// Function 91
float torus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 92
float box(in vec2 p, in vec2 b) 
{
    return length(max(abs(p)-b,0.));
}

// Function 93
float sdf_cone(vec3 p, float radius, float height) {
	vec2 q = vec2(length(p.xy), p.z);
	vec2 tip = q - vec2(0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

// Function 94
vec3 textureBox1(vec3 p)
{
    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);
    vec2 uv=f.x>.5?p.yz:f.y>.5?p.xz:p.xy;
    float l=clamp(-normalize(p-vec3(0,1,0)).y,0.,1.);
    vec2 b=box2(boxxfrm*p,boxxfrm*(vec3(0,1,0)-p));
    // Some lighting and a shadow (and approximated AO).
    float s=mix(.2,1.,smoothstep(0.,.8,length(p.xz)));
    vec3 d=.6*(1.-smoothstep(-1.,1.,p.y))*vec3(0.3,0.3,.5)*s+smoothstep(0.9,.97,l)*vec3(1,1,.8)*step(b.y,b.x);
    return texture(iChannel1,uv).rgb*d;
}

// Function 95
float SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)
{
    h = false;

    // Don't start at the origin, instead move a little bit forward
    float t=0.0;

    for(int i=0; i<MAX_STEPS; i++) {
        s=i;
        vec3 p = o+t*u;
        float v = object(p);
        // Hit object
        if (v < 0.0) {
            s=i;
            h = true;
            break;
        }
        // Move along ray
        t += max(EPSILON,v);
        // Escape marched too far away
        if (t>e)
            break;
    }
    return t;
}

// Function 96
float box(vec3 p, vec3 bmin, vec3 bmax)
{
   vec3 c = (bmin + bmax)*0.5;
   vec3 size = (bmax - bmin)*0.5;
   return sdBox(p - c, size);
}

// Function 97
float sdBox( vec3 p, vec3 s )
{
  vec3 d = abs(p) - s;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 98
rayData traceSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRad)
{
    rayData raycastOut;

    raycastOut.tMin = -1.0;
    raycastOut.tMax = -1.0;
    raycastOut.hit = false;
    raycastOut.expire = false;
    raycastOut.normal = vec3(0.0);

    vec3 oc = ro-sphPos;
    float b = dot(oc, rd);
    float c = dot(oc, oc)-sphRad*sphRad;
    float h = b*b-c;

    if(h < 0.0)
    {
        return raycastOut;
    }

    h = sqrt(h);

    raycastOut.tMin = -b-h;
    raycastOut.tMax = -b+h;
    raycastOut.hit = true;
    raycastOut.normal = normalize(ro+rd*raycastOut.tMin);

    return raycastOut;
}

// Function 99
float sdBox( in vec3 p, in vec3 b ) 
{
    vec3 q = abs(p) - b;
    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));
}

// Function 100
float sdBox( const in vec3 p, const in vec3 b ) {
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 101
float box( vec3 p, vec3 b )
{
	vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) +
           length(max(d,0.0));
}

// Function 102
float udRoundBox(in vec4 p,in vec4 b,in float r) {
  return length(max(abs(p)-b,0.0))-r;
}

// Function 103
vec3 randomInUnitSphere(vec3 seed)
{
    seed *= vec3(10.9, 223.0, 332.0);
    vec3 point = hash33(seed);
	for(int i = 1; i < 200; ++i)
    {
        point = hash33(seed + float(i)) * 2.0 - vec3(1.0);
        if(dot(point, point) < 1.0)
        {
            return point;
        }
    }
    
    return point;
}

// Function 104
float checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )
{
    // filter kernel
    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;                  
}

// Function 105
float distTorus(vec3 pos, float r1, float r2, vec3 z)
{
    float pz = dot(pos,normalize(z));
    return length(vec2(length(pos-z*pz)-r1,pz))-r2;
}

// Function 106
void intersectPlane(const vec3 ro, const vec3 rd, const float height, out float dist) {	
	dist = MAXDISTANCE;
	if (rd.y==0.0) {
		return;
	}
	
	float d = -(ro.y - height)/rd.y;
	d = min(MAXDISTANCE, d);
	if( d > 0. ) {
		dist = d;
	}
}

// Function 107
vec2 obj_round_box(vec3 p)
{
  float d = length(max(abs(p)-vec3(2.0,0.5,2.0),0.0))-0.2;
  return vec2(d,1);
}

// Function 108
float sdCylinderY(vec3 p, vec2 h)
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 109
v0 sphere(v3 ray,v2 u, v0 radius
){maxGISize = max(maxGISize,radius*ray.w)
 ;return ray.w*(length(ray.xyz-u)-radius);}

// Function 110
vec3 SphereMap( vec2 uv )
{
    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );
}

// Function 111
bool notEmptyPlanet(ivec3 p)
{
	vec4 samp = planetSample(p);
	if (length(vec3(p))<20.0+10.0*length(samp.rgb*samp.a)) return true;
	
	return false;
}

// Function 112
float udfBox( vec3 p, vec3 b ) {
    return length(max(abs(p)-b, 0.0));
}

// Function 113
float sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {
    return dot(p - planePoint, nvPlaneN);
}

// Function 114
float sdCylinder(vec3 p, float r)
{
  return length(p.xy)-r;
}

// Function 115
float boxSDF(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 116
float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 117
float PlaneTexture(float2 p, float t)
{
	return Arrows(p,t);
}

// Function 118
float fCone(vec3 p,float r,float h){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=normalize(vec2(h,r));float j=dot(t,vec2(m.y,-m.x)),d=max(dot(t,m),-q.y);if(q.y>h&&j<0.)d=max(d,length(t));if(q.x>r&&j>length(vec2(h,r)))d=max(d,length(q-vec2(r,0.)));return d;}

// Function 119
bool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {	
	if (rd.y==0.0) {
		return false;
	}
		
	float d = -(ro.y - height)/rd.y;
	d = min(100000.0, d);
	if( d > 0. ) {
		dist = d;
		return true;
	}
	return false;
}

// Function 120
float rbox(vec3 p, vec3 b, float r){
   return length(max(abs(p)-b,0.0))-r;
}

// Function 121
float intersectSphere(vec3 origin, vec3 ray, Sphere s) {   
   vec3 toSphere = origin - s.center_radius.xyz;      
   float sphereRadius = s.center_radius.w;
   float a = dot(ray, ray);      
   float b = dot(toSphere, ray);   
   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   
   float discriminant = b*b - a*c;      
   if(discriminant > 0.0) {      
      float t = (-b - sqrt(discriminant)) ;   
      if(t > 0.0) return t;      
   }   
   return 10000.0;   
}

// Function 122
float
cone_sd( in vec2 c, in vec3 p )
{
    p = abs(p);
    vec2 c1 = vec2(c.y,-c.x);
    return dot( c1, vec2(length(p.xy), p.z) );
}

// Function 123
vec4 iconUIBox(ivec2 idx) {
    
    vec2 iconCtr = iconCenter;
    
    iconCtr = floor(iconCtr+0.5);
    
    vec2 scl = vec2(2.5*iconSize, 3.*iconSize);
    iconCtr += vec2(float(idx.x), float(-idx.y))*scl + vec2(-1.5, 0.5)*scl; 
    
    return vec4(iconCtr, vec2(iconSize));
    
}

// Function 124
float squareToUniformSphereCapPdf(in float height)
{
    return 0.5 / ((1.0 - height) * PI);
}

// Function 125
float sdBoxXY(vec3 p, vec3 b)
{
  vec2 d = abs(p.xy) - b.xy;
  return min(max(d.x,d.y),0.0) +
         length(max(d,0.0));
}

// Function 126
float sphere(vec3 p, vec3 pos, float radius)
{
    return length(p - pos) - radius;
}

// Function 127
float sdCubicalCylinder(in vec4 p, in vec3 rh1h2) {
	vec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;
	return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));
}

// Function 128
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {
    float t = (-1.0 - 1e-4 - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) < 0.5) {
        normal = vec3(0, 1, 0);
        return t;
    }
    
    // dot(pos + t * dir, pos + t * dir) == r * r;
    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r
    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0
    float a = dot(dir.xz, dir.xz);
    float b = dot(pos.xz, dir.xz);
    float c = dot(pos.xz, pos.xz) - 0.5;
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    t = (-b - sqrt(D)) / a;
    if (t > 0.0) {
        worldPos = t * dir + pos;
        if (worldPos.y <= -1.0 - 1e-4) {
            normal = normalize(vec3(worldPos.x, 0, worldPos.z));
            return t;
        }
    }
    t = (-b + sqrt(D)) / a;
    if (t < 0.0) {
        return INF;
    }
    worldPos = t * dir + pos;
    if (worldPos.y <= -1.0 - 1e-4) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }
    return INF;
}

// Function 129
v0 fBox(v2 p,v2 s
){v2 d=abs(p)-s//mirror clamp
 ;v0 a=length(max(d,0.))//rounded corners
 ;v2 q=min(d,0.)//clamp
 ;v0 b=max(max(q.x,q.y),q.z)//keep largest of 3
 ;return a+b;}

// Function 130
MovingSphere createMovingSphere(vec3 center0, vec3 center1, float radius, float time0, float time1)
{
    MovingSphere s;
    s.center0 = center0;
    s.center1 = center1;
    s.radius = radius;
    s.time0 = time0;
    s.time1 = time1;
    return s;
}

// Function 131
float Sphere(float radius, vec3 position)
{
    return length(position) - radius;
}

// Function 132
float box(vec2 p){ p=abs(p); return max(p.x, p.y); }

// Function 133
vec3 getCylinderNormal(vec3 pos, vec3 properties)
{
	// Perform modulation to keep in line with our cylinder distance function.
	pos.xz = mod(pos.xz,TREE_REP.xz);
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	// Since we can assume that the cylinder is vertical,
	// the only coordinates that matter are x and z.
	// This speeds up normal generation quite a bit.
	vec2 normal = normalize(pos.xz-properties.xy);
	return vec3(normal.x, 0.0, normal.y);
}

// Function 134
float Plane(vec3 p, vec3 n, float offs) {
	return dot(p,n)-offs;
}

// Function 135
vec2 intersect_plane(vec3 ray_origin,
                     vec3 ray_direction,
                     vec3 plane_origin,                     
                     vec3 plane_normal)
{
    float ray_direction_dot_normal = dot(ray_direction, plane_normal);

    float denominator = ray_direction_dot_normal;
    
    float intersected = 0.;
    float t = BIG_NUMBER;
    if (abs(denominator) > REALLY_SMALL_NUMBER) {
        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    
        if (t > REALLY_SMALL_NUMBER) {
            intersected = 1.;
        }
    }
    return vec2(intersected, t);

}

// Function 136
float sdCone( vec3 p, vec2 c )
{
    // c must be normalized
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

// Function 137
vec2 intersectSphere(vec3 ro, vec3 rd)
{
    float a = dot(rd, rd), b = 2. * dot(rd, ro),
        c = dot(ro, ro) - 1., desc = b * b - 4. * a * c;

    if (desc < 0.)
        return vec2(-1);

    c = sqrt(desc);

    return (-b + vec2(-c, c)) / (2. * a);
}

// Function 138
float traceCylinderPlane(Cylinder cyl, vec3 normal, vec3 orig, vec3 dir)
{
    float d = cyl.height + cyl.center.y;
    float t = -(dot(normal, orig) + d) / dot(normal, dir);
    if (t < 0.0) {
        return INF;
    }
    
    vec3 pos = orig + t * dir;
    if (length(pos.xz - cyl.center.xz) > cyl.radius) {
        return INF;
    }
    
    return t;
}

// Function 139
float sdCappedCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz), p.y)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 140
Hit cutoffPlanes(Ray ray, float minD, float maxD, WORLD world){
    if(int(bap.id) >= AP_MOON_GRAD_NOISE_1 && 
       int(bap.id) <= AP_MOON_VORONOI_NOISE)
    {
        float phase = bap.phase;
        Sphere s = Sphere(world.moonBounds.origin + vec3(world.moonBounds.rad * 3.75, 0., 0.) * smoothstep(.75, .5, phase), world.moonBounds.rad + 1.);
        
        s.rad *= smoothstep(0., .25, phase) * smoothstep(1., .65, phase);
        
        Hit hit;
        if(sphere_hit(Sphere(s.origin, s.rad), ray, 0., minD, hit))
            return Hit(hit.dist, int(bap.id) - AP_MOON_GRAD_NOISE_1, hit.normal);
    }
    
    if(int(bap.id) >= AP_SHUTTLE_EXHAUST_1)
    {
        float dst = (world.exhaustBounds.A.y-ray.origin.y)/ray.direction.y;
        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_1];
        float phase = bap.phase;
        vec3 p = ray.origin + ray.direction * dst;
        p.z = abs(p.z);
        if(p.x < -.8 && p.x > -min(7., ph * 10.) && p.z < abs(p.x * .4) )
            return Hit(dst, AP_EXHAUST_PLANE, vec3(0., 1., 0.));
    }
    
    if(int(bap.id) >= AP_SHUTTLE_2)
    {
        vec3 res = vec3(MAX_FLOAT, 0., 0.);
        {
            float ph = apPhasesStates[AP_SHUTTLE_2];
            float dst = ((max(.025, smoothstep(.6, .15, ph)) + world.shuttleBounds.origin.y)-ray.origin.y)/ray.direction.y;
            vec3 p = ray.origin + ray.direction * dst;
            if(dst < minD){
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))
                              * smoothstep(.075, .025, distance(ph, .375)), .5)
                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;
            }
            
            dst = ((world.shuttleBounds.origin.y - max(.025, smoothstep(.6, .15, ph)))-ray.origin.y)/ray.direction.y;
            p = ray.origin + ray.direction * dst;
            if(dst < minD){
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))
                             * smoothstep(.075, .025, distance(ph, .375)), .5)
                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;
            }
            
            vec3 n = vec3(1., 0., 1.);
            if(plane_hit(ray, n * max(.33, smoothstep(.75, .5, ph) - .33), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                p.y -= world.shuttleBounds.origin.y;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1., 0.95, max(abs(p.y), abs(p.z)))
                              * smoothstep(.25, .05, distance(ph, .65)), .5)
                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;
            }
            
            n = vec3(-1., 0., 1.);
            if(plane_hit(ray, n * min(-.33, -smoothstep(.75, .5, ph)+.2), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                p.y -= world.shuttleBounds.origin.y;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))
                              * smoothstep(.25, .05, distance(ph, .75)), .5)
                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;
            }
            
            n = vec3(-1., 0., .25);
            if(plane_hit(ray, n *  max(.7, .5 + smoothstep(1., .75, ph)), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                p.y -= world.shuttleBounds.origin.y;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))
                              * smoothstep(.2, .05, distance(ph, .8)), .5)
                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;
            }
            
            n = vec3(-1., 0., -.25);
            if(plane_hit(ray, n *  max(.7, .5 + smoothstep(1., .75, ph)), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                p.y -= world.shuttleBounds.origin.y;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1., .95, max(abs(p.y), abs(p.z)))
                              * smoothstep(.2, .05, distance(ph, .8)), .5)
                          * max(.25, smoothstep(.025, .0125, distance(max(abs(p.y), abs(p.z)), .9))) * .35;
            }
            
            ph = apPhasesStates[AP_SHUTTLE_3];
            dst = (max(.025, smoothstep(.4, .2, ph))-ray.origin.z)/ray.direction.z;
            p = ray.origin + ray.direction * dst;
            p.y -= world.shuttleBounds.origin.y;
            if(dst < minD){
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.y)))
                              * smoothstep(.1, .025, distance(ph, .3)), .5)
                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.y)), 1.4))) * .35;
            }
            
            dst = (-max(.025, smoothstep(.4, .2, ph))-ray.origin.z)/ray.direction.z;
            p = ray.origin + ray.direction * dst;
            p.y -= world.shuttleBounds.origin.y;
            if(dst < minD){
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.y)))
                             * smoothstep(.1, .025, distance(ph, .3)), .5)
                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.y)), 1.4))) * .35;
            }
            
            dst = (world.shuttleBounds.origin.y-smoothstep(.4, .2, ph)-ray.origin.y)/ray.direction.y;
            p = ray.origin + ray.direction * dst;
            if(dst < minD){
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))
                             * smoothstep(.1, .025, distance(ph, .3)), .5)
                         * max(.25, smoothstep(.025, .0125, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;
            }
            
            n = normalize(vec3(1., 1.5, 0.));
            if(plane_hit(ray, n * -min(-world.shuttleBounds.origin.y+1., 1.2-world.shuttleBounds.origin.y-smoothstep(.6, .4, ph)), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.x), abs(p.z)))
                              * smoothstep(.2, .05, distance(ph, .5)), .5)
                          * max(.25, smoothstep(.05, .025, distance(max(abs(p.x), abs(p.z)), 1.4))) * .35;
            }
            /*
            n = normalize(vec3(1., -.5, 0.));
            //max(.7, smoothstep(.8, .6, ph))
            if(plane_hit(ray, n * (vec3(0.,-8.,0.) + smoothstep(.8, .6, ph)), n, dst) && dst < minD) {
                p = ray.origin + ray.direction * dst;
                //p.y -= world.shuttleBounds.origin.y;
                res.x = min(res.x, dst);
                res.y += pow(smoothstep(1.5, 1.45, max(abs(p.z),max(abs(p.x), abs(p.y))))
                              * smoothstep(.2, .05, distance(ph, .7)), .5)
                          * max(.25, smoothstep(.05, .025, distance(max(abs(p.z), max(abs(p.x), abs(p.y))), 1.4))) * .35;
            }
            */
        }
        return Hit(res.x, AP_SHUTTLE_CPLANES, vec3(res.yz, 0.));
    }
    
    return miss;
}

// Function 141
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) 
{
	// ray-box intersection
    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis
    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin
    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge
	
    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.
    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );

	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
    if (timeNear < 0.0)
        timeNear = timeFar;
    
    vec3 relPoint = rayOrigin + rayDirection * timeNear;
    
    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;
    
    vec3 normal;
    vec3 uaxis;
    vec3 vaxis;
    // if Y isn't the biggest value it can't be the normal axis
    if (absRelPoint.x >= absRelPoint.y)
    {
        // if X is the winner
        if (absRelPoint.x >= absRelPoint.z)
        {
            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);
			uaxis = vec3(0.0,1.0,0.0);
			vaxis = vec3(0.0,0.0,1.0);            
        }
        // else it's Z
        else
        {
            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,1.0,0.0);            
        }
    }
    // else X isn't the biggest value so it can't be the normal axis
    else
    {
        // if Y is the winner
        if (absRelPoint.y >= absRelPoint.z)
        {
            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,0.0,1.0);	           
        }
        // else it's Z
        else
        {
            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,1.0,0.0);            
        }        
    }
    
	uv = vec2
	(
		dot(relPoint, uaxis),
		dot(relPoint, vaxis)
	);    

	return vec4( timeNear, normal );    
}

// Function 142
float udBox(vec3 p, vec3 b, float r) {
    return length(max(abs(p) - b, 0.0)) - r;
}

// Function 143
vec3 torusKnot(float t, TorusKnotParameters tkp)
{
    vec2 sicXY = sic(tkp.kp * t);
    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);
    
    return vec3((sicRZ.x + tkp.r1)*sicXY, sicRZ.y);
}

// Function 144
float sdCappedCylinder(vec3 p, float h, float r) {
	vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);
	return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 145
void planet(inout Ray r,inout vec3 col,vec3 lp,vec3 sc){
    float t  = 0.0;
    float er = 2.0;
    float ar = er*1.5;
    float h  = 0.0;
    float lh  = 0.0;
    float c  = 0.0;
    float td = 0.0;
    float h_mie = 0.01;
    float h_ray = 0.04;
    float d_mie = 0.0;
    float d_ray = 0.0;
    float t_mie0 = 0.0;
    float t_ray0 = 0.0;
    float t_mie1 = 0.0;
    float t_ray1 = 0.0;
    float nl     = 0.0;
    vec3 c_ray = vec3(0.);
    vec3 c_mie = vec3(0.);
    vec3 c_mul = vec3(0.);
   
    vec3 kray = vec3(15, 40, 85.0);
    
    vec3 kmie = vec3(80.);
   
    vec2  et = sphere(r.o,r.d,vec4(sc,er));
    vec2  at = sphere(r.o,r.d,vec4(sc,ar));
    vec2  lt = sphere(lp,-lp,vec4(sc,ar));
    
    vec2  pt = intersect(vec4(at,et));
    vec3  ps = pt.x*r.d+r.o;
    vec3  pe = pt.y*r.d+r.o;
    vec3  pl = lt.x*normalize(-lp)+lp;
    vec3  n  = vec3(0);
    vec3  ep = pt.x*r.d+r.o;
    
    vec3  p  = ps;
    float stp = length(pt.y-pt.x)*1.1/MAXIT;
    
    if(at.x<=0.) return;
    
    for(int i=0;i<int(MAXIT);i++){
        p = p+r.d*stp;
        h = length(p)-er;
        lh = length(pl-p)*0.6;
         
        d_mie=density(h,h_mie);
        d_ray=density(h,h_ray);
        
        t_mie0+=d_mie*stp;
        t_ray0+=d_ray*stp;
        
        t_mie1=optic(lh,h,h_mie);
        t_ray1=optic(lh,h,h_ray);
        
        c_mul= exp(-(t_ray0+t_ray1)*kray*0.02-(t_mie0+t_mie1)*kmie*0.007);
        c_ray+= d_ray*c_mul*stp;
        c_mie+= d_mie*c_mul*stp;
        
    }
    
    n = normalize(p);
    c =  dot(normalize(lp),-r.d);
    nl = dot(n,normalize(lp));
   
    
    col += c_ray*kray*phase_ray(c*c)+c_mie*kmie*phase_mie(-0.77,c,c*c);

    if(length(p)<=er+0.001){
        nl = smoothstep(-0.3,1.0,nl);
        col +=fbm(3.*vec2(atan(p.z,p.x),p.y))*getColor(0.4)*0.6*nl;
        col *=nl;
        
    }
       
}

// Function 146
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {
    ro -= sph.xyz;
	float k = dot(ro, rd);
    float D = k*k - dot(ro, ro) + sph.w*sph.w;
    float q = sqrt(D);
    if (D < 0.0) {
        return D;
    } else {
    	return (vec2(-q,q) - k).x;
    }
}

// Function 147
float sBoxS(in vec2 p, in vec2 b, in float rf){
  
    vec2 d = abs(p) - b + rf;
  	return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;
}

// Function 148
vec3 nPlane( in vec3 ro, in vec4 obj )
{
    return obj.xyz;
}

// Function 149
float sdBox( vec3 p, vec3 b )
{
  vec3  di = abs(p) - b;
  float mc = max(di.x, max(di.y, di.z));
  return min(mc,length(max(di,0.0)));
}

// Function 150
float sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {
	float rba = rb - ra,
	      baba = dot(b - a, b - a),
	      papa = dot(p - a, p - a),
	      paba = dot(p - a, b - a) / baba,
	      x = sqrt(papa - paba * paba * baba),
	      cax = max(0., x - ((paba < .5) ? ra : rb)),
	      cay = abs(paba - .5) - .5,
	      f = clamp((rba * (x - ra) + paba * baba) / (rba * rba + baba), 0., 1.),
	      cbx = x - ra - f * rba,
	      cby = paba - f;
	return ((cbx < 0. && cay < 0.) ? -1. : 1.) * sqrt(min(cax * cax + cay * cay * baba, cbx * cbx + cby * cby * baba));
}

// Function 151
vec3 SpherePoints_GoldenAngle(float i, float numSamples) {
    float theta = i * goldenAngle;
    float z = (1.0 - 1.0 / numSamples) * (1.0 - 2.0 * i / (numSamples - 1.0));
    float radius = sqrt(1.0 - z * z);
    return vec3(radius * vec2(cos(theta), sin(theta)), z);
}

// Function 152
float sdfSphere(in vec3 p,in vec3 center,in float radius){
	return length(p-center)-radius;
}

// Function 153
float Cylinder( vec3 p, float r, float height ) 
{
	float d = length( p.xz ) - r;
	d = max( d, abs( p.y ) - height );
	return d;
}

// Function 154
float sdBox(vec3 p, vec3 b) {
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 155
vec4 shadeSphere(Ray ray, RaycastHit hit) {
    
    float diffuse = lighting(hit);
    float specular = pow(max(dot(normalize(sun), hit.normal), 0.), 45.);
    
    return (vec4(1., 0., 0., 1.) * diffuse) + specular;
    
}

// Function 156
vec3 Reorient_Hemisphere ( vec3 wo, vec3 N ) {
  float3 binormal, bitangent;
  Calculate_XY(N, binormal, bitangent);
  return bitangent*wo.x + binormal*wo.y + wo.z*N;
}

// Function 157
float sdTorus(in vec3 p, in vec3 t ) {
  vec3 q = vec3(length(p.xz)-t.x,p.y,p.z);
  return max(length(q.x)-t.y, length(q.y)-t.z);
}

// Function 158
float iPlane( vec3 ro, vec3 rd, Plane plane)
{
    float hit = 0.0;
    float dotP = dot(rd,plane.Normal);
    if(dotP == 0.0)
    {
        return hit;
    }
    
    float distToHit = dot(plane.Point - ro, plane.Normal) / dotP;
    if(distToHit < 0.0)
    {
        return hit;
    }
    
    hit = distToHit;
    return hit;
}

// Function 159
float planedist(in vec3 point, in vec3 norm) {

    return dot(point, norm) - norm.y;

}

// Function 160
vec3 randomSphereDirection () {
    vec2 r = vec2 (rand () * 6.2831, rand() * 6.2831);
	vec3 dr = vec3 (sin (r.x) * vec2 (sin (r.y), cos (r.y)), cos (r.x));
	return dr;
}

// Function 161
float sdTorus(in vec3 p, in vec2 t) {
    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;
}

// Function 162
vec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )
{
    vec3 w = abs(nor);
    return (w.x*texture( sam, pos.yz ).xyz + 
            w.y*texture( sam, pos.zx ).xyz + 
            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);
}

// Function 163
float distFromPlane(vec3 p){
;return dot(vec3(0,1,0), p)+1.5;}

// Function 164
float plane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 165
float rbox(vec3 p,vec3 s) {
	p = abs(p)-s;
    return length(p-min(p,0.0));
}

// Function 166
float sphere(vec4 ray,vec3 pos, float radius)
{
    maxGISize = max(maxGISize,radius*ray.w);
    return ray.w*(length(ray.xyz-pos) - radius);
}

// Function 167
SSphere GetfloorSphere3()
{
	return SSphere
	(
		9,						//id
		vec3(1.5, -1.0, 2.0),	//center
		0.2,					//radius
		SMaterial
		(
			vec3(0.8,0.8,0.0),	//diffuse color
			3.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 168
vec2 ray_vs_sphere(vec3 p, vec3 dir, float r)
{
	float b = dot(p, dir);
	float c = dot(p, p) - r * r;

	float d = b * b - c;
	if (d < 0.0)
		return vec2(MAX, -MAX);
	d = sqrt(d);

	return vec2(-b - d, -b + d);
}

// Function 169
float tracePlane(in vec3 ro, in vec3 rd, in vec3 pp, in vec3 pn)
{
    float a = dot(pp - ro, pn);
    float b = dot(rd, pn);
    float t = a / b;    
    return t;
}

// Function 170
vec2 add_plane(vec3 p, vec2 m) {
    return min2(plane(p),m);
}

// Function 171
vec3 nPlane( void )
{
    return vec3(0.0,1.0,0.0);
}

// Function 172
vec4 sphereColor( in vec3 pos, in vec3 nor )
{
	vec2 uv = vec2( atan( nor.x, nor.z ), acos(nor.y) );
    vec3 col = (texture( iChannel3, uv ).xyz);
    float ao = clamp( 0.75 + 0.25*nor.y, 0.0, 1.0 );
    return vec4( col, ao );
}

// Function 173
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 rv2 = hash2(seed);
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = normalize( cross( uu, n ) );
	
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831*rv2.x); 
	float ry = ra*sin(6.2831*rv2.x);
	float rz = sqrt( 1.0-rv2.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 174
float fBox(vec3 p,vec3 b){vec3 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(max(q.x,q.y),q.z);}

// Function 175
vec3 fibonacci_sphere(int i, int n)
{
    vec2 pt = vec2(2.*PI*mod(float(i)/PHI, 1.), acos(1. - float(2*i+1)/float(n)));
    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); 
}

// Function 176
float roundCone( vec3 p, float r1, float r2, float h ){
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 177
void planeUVAxis(in vec3 p, in vec3 n, out vec3 u, out vec3 v)
{
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    u = normalize(cross(worldUp, n));
    v = normalize(cross(n, u));
}

// Function 178
float boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
	vec3 p = (txx*vec4(pos,1.0)).xyz;
	vec3 n = (txx*vec4(nor,0.0)).xyz;
    
    // Orient the hexagon based on p
    vec3 f = rad * sign(p);
    
    // Make sure the hexagon is always convex
    vec3 s = sign(rad - abs(p));
    
    // 6 verts
    vec3 v0 = normalize( vec3( 1.0, 1.0,-1.0)*f - p);
    vec3 v1 = normalize( vec3( 1.0, s.x, s.x)*f - p);
    vec3 v2 = normalize( vec3( 1.0,-1.0, 1.0)*f - p);
    vec3 v3 = normalize( vec3( s.z, s.z, 1.0)*f - p);
    vec3 v4 = normalize( vec3(-1.0, 1.0, 1.0)*f - p);
    vec3 v5 = normalize( vec3( s.y, 1.0, s.y)*f - p);
    
    // 6 edges
    return abs( dot( n, normalize( cross(v0,v1)) ) * acos( dot(v0,v1) ) +
    	    	dot( n, normalize( cross(v1,v2)) ) * acos( dot(v1,v2) ) +
    	    	dot( n, normalize( cross(v2,v3)) ) * acos( dot(v2,v3) ) +
    	    	dot( n, normalize( cross(v3,v4)) ) * acos( dot(v3,v4) ) +
    	    	dot( n, normalize( cross(v4,v5)) ) * acos( dot(v4,v5) ) +
    	    	dot( n, normalize( cross(v5,v0)) ) * acos( dot(v5,v0) ))
            	/ 6.283185;
}

// Function 179
vec2 sdBoundingBox( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return vec2(min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),2.);
}

// Function 180
float signedDistanceBox(in vec2 p, in vec2 b) { return length(max((abs(p)-b),0.0)); }

// Function 181
float sdSphere (in vec3 p, in vec3 c, in float r) {
    return r - length(p - c);
}

// Function 182
float sdPlane( vec3 p, vec4 n ){
    
  n.xyz = normalize(n.xyz);
    vec3 q = n.w* n.xyz;
  return dot(q-p,n.xyz) + n.w;
}

// Function 183
vec3 map_box_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return reflect(rd, nrm);
}

// Function 184
vec3 random_in_unit_sphere()
{
    float phi = 2.0 * PI * rand2D();
    float cosTheta = 2.0 * rand2D() - 1.0;
    float u = rand2D();

    float theta = acos(cosTheta);
    float r = pow(u, 1.0 / 3.0);

    float x = r * sin(theta) * cos(phi);
    float y = r * sin(theta) * sin(phi);
    float z = r * cos(theta);

    return vec3(x, y, z);
}

// Function 185
vec3 cylinder( in vec2 t )
{
    float q = t.x*3.1416;
    return vec3( 0.5*cos(q), t.y, 0.5*sin(q) );
}

// Function 186
bvec4 RayVs4Boxes(in vec3 p, in vec3 dir, in vec4 pos_x, in vec4 pos_y, in vec4 pos_z,
				  in vec4 edge_x, in vec4 edge_y, in vec4 edge_z,
				  out vec4 t
	)
{
	vec3 inv_dir = vec3(1.)/dir;
	
	vec4 minim_x=pos_x-edge_x*.5;
	vec4 minim_y=pos_y-edge_y*.5;
	vec4 minim_z=pos_z-edge_z*.5;
	
	vec4 maxim_x=pos_x+edge_x*.5;
	vec4 maxim_y=pos_y+edge_y*.5;
	vec4 maxim_z=pos_z+edge_z*.5;

	vec4 omin_x = ( minim_x - p.x ) * inv_dir.x;
	vec4 omin_y = ( minim_y - p.y ) * inv_dir.y;
	vec4 omin_z = ( minim_z - p.z ) * inv_dir.z;
	
	vec4 omax_x = ( maxim_x - p.x ) * inv_dir.x;
	vec4 omax_y = ( maxim_y - p.y ) * inv_dir.y;
	vec4 omax_z = ( maxim_z - p.z ) * inv_dir.z;

	vec4 maxi_x = max ( omax_x, omin_x );
	vec4 maxi_y = max ( omax_y, omin_y );
	vec4 maxi_z = max ( omax_z, omin_z );
	
	vec4 mini_x = min ( omax_x, omin_x );
	vec4 mini_y = min ( omax_y, omin_y );
	vec4 mini_z = min ( omax_z, omin_z );

	vec4 start = max ( max ( mini_x, vec4(0.) ), max ( mini_y, mini_z ) );
	vec4 end = min ( maxi_x, min ( maxi_y, maxi_z ) );
	
	t = start;
	
	return greaterThan(end-start,vec4(.00001));
}

// Function 187
float distBox(vec3 samplePos, vec3 boxPos, vec3 boxDim)
{	
	vec3 normal;
	float bump = 0.0;
	if(length(samplePos-boxPos) < length(boxDim))
	{
	   	normal = normalize(samplePos-boxPos);
 		bump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;
	}
	vec3 d = abs(samplePos-boxPos) - boxDim;
	return min(max(d.x,max(d.y,d.z)),0.0) +
		length(max(d,0.0))+bump;
}

// Function 188
float udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}

// Function 189
maybe_vec2 get_distances_along_3d_line_to_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r
){
    vec3 B = normalize(B2 - B1);
    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);
    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);
    float a_in = min(a1.value, a2.value);
    float a_out = max(a1.value, a2.value);
    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);
    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);
    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);
    // TODO: do we need this line?
    float entrance = max(tube.value.y,  a_in);
    float exit     = min(tube.value.x, a_out);
    return maybe_vec2( 
        vec2(entrance, exit), 
        tube.exists && entrance < exit
    );
}

// Function 190
bool intersectPlane(Plane plane, Ray ray, out HitInfo hitInfo) {
    float t = -dot(ray.pos - plane.pos, plane.normal) / dot(ray.dir, plane.normal);
    if (t > 0.0) {
        hitInfo.t = t;
        hitInfo.pos = ray.pos + ray.dir * hitInfo.t;
        hitInfo.normal = plane.normal;
        return true;
    }
    
    return false;
}

// Function 191
bool closestDiskPlane(vec3 cDisk, vec3 nDisk, float rDisk, float eDisk, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
     closestDiskPlane(cDisk,nDisk,rDisk, pPlane,nPlane, out0,out1);
     return removeThickness(eDisk, 0., out0, out1);
}

// Function 192
void plane( Ray ray, PlaneParams planeParams, inout HitInfo hitInfo )
{
    hitInfo.primitiveType = PrimitiveType_None;
    hitInfo.t = -1.0;
    hitInfo.hit = 0.0;
 
    float d = dot( planeParams.pointOnPlane, planeParams.normal );
    float t = ( d - dot( ray.origin, planeParams.normal ) ) / dot( ray.direction, planeParams.normal );
 
    if( t < 0.00 )
    {
        return;
    }
 
    hitInfo.position = ray.origin + ray.direction * t;
    hitInfo.normal = normalize( planeParams.normal );
    hitInfo.t = t;
    hitInfo.dist = length( hitInfo.position - ray.origin );
    hitInfo.rayDir = ray.direction;
    hitInfo.diffuseColor = planeParams.diffuseColor;
    hitInfo.receiveShadow = planeParams.receiveShadow;
    hitInfo.shadowCasterIntensity = planeParams.shadowCasterIntensity;
    hitInfo.reflectionIntensity = planeParams.reflectionIntensity;
    hitInfo.lightVisualizer = 0;
    hitInfo.primitiveType = PrimitiveType_Plane;
    hitInfo.hit = 1.0;
}

// Function 193
vec3 rndDirHemisphere(vec3 n)
{
    float r2 = rand();
    float phi = 2.0*PI*rand();
    float sina = sqrt(r2);
    float cosa = sqrt(1. - r2);
    vec3 w = normalize(n), u = normalize(cross(w.yzx, w)), v = cross(w, u);
	return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;
}

// Function 194
float box(vec3 b, vec3 pos, vec3 p)
{
    vec3 q = abs(p - pos) - b;
  	return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 195
float sdSphere( vec3 p, float s )
{
    return length( p ) - s;
}

// Function 196
vec3 HemisphereRand( vec3 axis, uint seed )
{
    return PowRand( vec2(quasi2*seed)/exp2(32.), axis, 1. );
}

// Function 197
vec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)
{
    int sections = 1*int(max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 1./(max(tkp.kq,tkp.kp)-0.75);
    const int maxIterations = 900;//50
    
    float minDist;
    float bestT;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        bool failed = false;
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotSqDistanceDerivative(t, p, tkp);
            
            if(abs(lerningRate*dt) < 0.003)break;
            
            t -= lerningRate*dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                failed = true;
                break;
            }
        }
        if(failed)continue;
        
        float sqDist = torusKnotSqDistance(t, p, tkp);
        
        if(sqDist <= sq(tkp.r3))
        {
            return vec3(t, sqDist, 1.);
        }
    }
    
    return vec3(0.);
}

// Function 198
float funnysphere(vec3 p)
{
    p.y *= 1.5;
    vec3 n = normalize(p);
    vec2 sg = p.xz / (1. + p.y);

    float offset = length(fract(sg*6.+iTime*4.)-.5)*.35;

    return length(p+vec3(0,.4,0))-1. + offset;
}

// Function 199
float pCone(vec3 p, vec2 c) {float q = length(p.yz); return dot(c,vec2(q,p.x));}

// Function 200
float intersectSphere(vec3 origin, vec3 dir, vec3 spherePos, float sphereRad)
{
	vec3 oc = origin - spherePos;
	float b = 2.0 * dot(dir, oc);
	float c = dot(oc, oc) - sphereRad*sphereRad;
	float disc = b * b - 4.0 * c;
	if (disc < 0.0)
		return -1.0;    
    float q = (-b + ((b < 0.0) ? -sqrt(disc) : sqrt(disc))) / 2.0;
	float t0 = q;
	float t1 = c / q;
	if (t0 > t1) {
		float temp = t0;
		t0 = t1;
		t1 = temp;
	}
	if (t1 < 0.0)
		return -1.0;
    
    return (t0 < 0.0) ? t1 : t0;
}

// Function 201
vec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )
{
    vec2 mi = min(min(p0,p1),min(p2,p3));
    vec2 ma = max(max(p0,p1),max(p2,p3));
    
    return vec4( mi, ma );
}

// Function 202
float sdSphere( in vec3 p, in vec4 e )
{
	vec3 di = p - e.xyz;
	return length(di) - e.w;
}

// Function 203
float sdfSphere(in vec3 p, in float r)
{ return length(p) - r; }

// Function 204
float inBox( vec2 p , vec2 loc , float boxSize ){
 	
    if( 
        p.x < loc.x + boxSize / 2. &&
        p.x > loc.x - boxSize / 2. &&
        p.y < loc.y + boxSize / 2. &&
        p.y > loc.y - boxSize / 2. 
    ){
        
     return 1.;  
        
    }
   
    return 0.;
     
}

// Function 205
vec3 getBoxColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {
    vec3 color = getWallColor(obj);
    float occ = clamp(raymarchAO(pos, nor, 80.0), 0.0, 1.0);
    color *= getLightColor(obj, pos, rd, nor) * occ;
    return color;
}

// Function 206
vec4 iSphere( in vec3 ro, in vec3 rd, in vec3 ce, in float ra )
{
	vec3 oc = ro - ce;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - ra*ra;
	float h = b*b - c;
	if( h<0.0 ) return vec4(-1.0);
    float t = -b - sqrt( h );
	return vec4( t, (oc + t*rd)/ra );
}

// Function 207
vec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }

// Function 208
vec3 i_spheremap_16( uint data )
{
    vec2 v = unpackSnorm2x8(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 209
vec3 i_spheremap_24( uint data )
{
    vec2 v = unpackSnorm2x12(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 210
Box newBox(vec3 origin, vec3 radius, vec3 color, bool castShadow, bool lit){
    Box box;
    box.origin = origin;
    box.radius = radius;
    box.color = color;
    box.castShadow = castShadow;
    box.lit = lit;
    return box;
}

// Function 211
float sdPlane(vec2 dir, vec2 uv)
{
	return dot(normalize(dir), uv);   
}

// Function 212
float TorusSDF(vec3 samplePoint, vec2 dimensions)
{
	return length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;
}

// Function 213
float dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}

// Function 214
float sdPlane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 215
float sdSphere(vec3 p, float r)
{
	return length(p)-r;
}

// Function 216
float box_border(vec2 uv, vec4 bounds, vec4 border_size)
{
    return box(uv, bounds) *
	       (
               step(bounds.x, uv.x) * (1.0 - step(bounds.x + border_size.x, uv.x)) + 
               step(bounds.y, 1.0 - uv.x) * (1.0 - step(bounds.x + border_size.y, 1.0 - uv.x)) +
               step(bounds.z, 1.0 - uv.y) * (1.0 - step(bounds.z + border_size.z, 1.0 - uv.y)) +
               step(bounds.w, uv.y) * (1.0 - step(bounds.w + border_size.w, uv.y))
           );
}

// Function 217
float sdRoundCone(vec3 p, float r1, float r2, float h)
{
  vec2 q = vec2(length(p.xy), p.z);
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 218
float
intersect_plane(
	Ray ray,
    vec3 center,
    vec3 normal)
{
    float denom = dot(ray.dir, normal);
    float t = dot(center - ray.origin, normal) / denom;
	return t > 0.0 ? t : INFINITY;
}

// Function 219
bool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {
    vec3  ds = ro - sph.xyz;
    float bs = dot( rd, ds );
    float cs = dot(  ds, ds ) - sph.w*sph.w;
    float ts = bs*bs - cs;
	
    if( ts > 0.0 ) {
        ts = -bs - sqrt( ts );
		if( ts>0. ) {
			normal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );
			return true;
		}
    }

    return false;
}

// Function 220
vec3 SphereRand( uint seed )
{
    // use interference of 2 very large numbers, calibrated (by hand) to cover
    // lots of different directions very early on, and to fill in the gaps eventually
    float sina = (float((seed*0x734941U)&0xffffffU)/float(0x1000000))*2. - 1.;
    float b = 6.283*(float((seed*0xAF71F2U)&0xffffffU)/float(0x1000000));
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

// Function 221
float int_plane(Ray ry, Plane pl)
{
    // Basic Ray Tracer, pg. 32
	float omega = (-1.0 * (dot(pl.coef, ry.pos))
        / dot(pl.coef, ry.dir)
    );
    // skip bounds checking if all plane boundries are zeroed-out
    if (dot(pl.ur, pl.ll) != 0.0)
    {
        // cut the plane by emitting negative distance by calculating
        // and comparing against a solution point; this effectively
        // cuts out some plane calculations
        vec3 bound_pt = ry.pos + (omega * ry.dir);
        if ((bound_pt.x < pl.ll.x) || (bound_pt.x > pl.ur.x)
            || ((bound_pt.z < pl.ll.y) || (bound_pt.z) > pl.ur.y))
            return -42.0;
    }
    return omega;
}

// Function 222
vec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN>tF || tF<0.0) return vec2(-1.0); 
    
    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

    return vec2( tN, tF );
}

// Function 223
float sdCone( vec3 p, vec2 c )
{
    // c must be normalized
    float q = length(p.xz);
    return dot(c, vec2(q, p.y));
}

// Function 224
vec4 boxDivide(in vec2 p){
    
    
    // Scaling factor. If changing this, you may need to change a few settings
    // here and there to suit your needs.
    const float sc = 1.;
    p *= sc;
    
    // Basid grid tile ID. This will be further split into subtiles, which will
    // each have their own ID based on postion.
    vec2 ip = floor(p); 
    
    // Vertical offset. 
    #define VERT_OFFSET
   
    // If using the vertical offset option, update the position and ID accordingly.
    #ifdef VERT_OFFSET
    if(mod(ip.x, 2.)>.5){
        p.y -= 1./2.;
        ip = floor(p);
    }
    #endif
   
    p -= ip + .5; // The original grid tile's base local coordinates.

    
    // Block dimension. Every time there's a random split, it'll be factored down
    // according to the random split factor.
    vec2 l = vec2(1, 1);  
    
    // The starting point, which represents the bottom left corner (or is it the top left corner?)
    // of the grid cell. With every split, it will be moved to the new split position.
    vec2 s = vec2(-.5);    
    
    // Split number.
    const int iNum = 8;
    
    float count = 0.;
    
    
    // Create a box, divide it randomly, then do the same with the 
    // divided portions. Ad infinitum...
    for(int i=0; i<iNum; i++) {
 
        float r = hash21(ip + l + float(i)/float(iNum))*.35 + (1. - .35)/2.;
        // Forcing a vertical to horizontal split (and vice versa) every
        // iteration. It's not necessary, but I think it looks nicer.
        float r2 = mod(float(i), 2.)>.5? 0. : 1.;
        
        
        // Minimum width... Thrown in at the last minute to enforce a
        // minimum box size. There are probably better ways, but it works
        // well enough.
        const float mW = .125;
        if(l.x<mW && l.y<mW) break;
        if(l.x<mW && r2>.5) { r2 = 0.; }// r = .5;
        if(l.y<mW && r2<=.5) { r2 = 1.; }
        
        //if(hash21(ip + 113.523 + l.yx + float(i)/float(iNum))<.3) continue;
        
        // If the second random number is above a certain threshold, split 
        // vertically. Otherwise, split horizontally.
        if(r2>.5){ 
            
            // This line splits the current cell down the middle, in accordance with
            // the random factor, "r," and the cell width "l.x." 
            if(p.x>s.x + l.x*r) {

                s.x += l.x*r; // Advance the position to the right of the split.
                l.x *= (1. - r); // Reduce the width by a factor of "1 - r."
            }
            else l.x *= r; // No need to advance position, but we need to reduce the width.
        
        }
        else {
            
              // This line splits the current cell horizontally, in accordance with
             // the random factor, "r," and the cell height "l.y." 
             if(p.y>s.y + l.y*r) {

                s.y += l.y*r; // Advance the position above (or below?) the split.
                l.y *= (1. - r); // Reduce the height by a factor of "1 - r."

             }
             else l.y *= r; // No need to advance position, but we need to reduce the height.
        }
        
        // There are many ways to vary the line width.
        #ifdef VARIABLE_LINE_WIDTH
        l *= 1. - r*.03;
        //l *= 1. - length(l)*.02;
        //l *= .986;
        #endif

    }
    
    
    // Constructing the box itself: Actually, once you have the box coordinates, you can 
    // do whatever you want with them.
    //
    // Rounding factor: This depends on the look you're after. It could be a constant, 
    // or you could choose to have no rounding at all. After experimentingn, I decided 
    // to make the roundedness of the tile dependent on the minimum side length.
    float rf = min(l.x, l.y); 
    float d = sBoxS(p - s - l/2., l/2., .05*sqrt(rf));// + .001*sc;
    
   
    
    // Smoothing factor.
    float sf = 1./450.*sc;//1./iResolution.y*sc;
    
    // Individual, position-based tile ID. Note that it'll read into the texture
    // at the correct position.
    vec2 id = ip + s + l/2.;
    
    // If using the vertical offset, the ID needs to follow suit.
    #ifdef VERT_OFFSET
    if(mod(ip.x, 2.)>.5){
        id.y += .5;
    }
    #endif
    
    
    
    // Using the ID to color the individual tile.
   
    // Random colors using IQ's cosine palette.
    float rnd = hash21(id/sc);
    vec3 pCol = .5 + .5*cos(6.2831853*rnd + vec3(0, 1, 2)*1.6);
    pCol = mix(pCol, pCol.xzy, .2);//vec3(.2 + rnd*.4);//
    
    
    // Another random colored version.
    //pCol = vec3(1, hash21(id), hash21(id*57. + .5)*.8);
    //pCol = mix(pCol, pCol.xzy, .35);//vec3(.2 + rnd*.4);
    
     // Textured version. Note that this is not an overlay -- Each tile has 
    // a uniform color.
    //vec3 tx = texture(iChannel0, id/sc + .5).xyz; tx *= tx;
    //vec3 pCol = smoothstep(0., .5, tx);
    
    
   
    // Rectangular cell border and coloring.
    vec3 col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.
    col = mix(col, pCol, 1. - smoothstep(0., sf, d + .003*sc)); 
    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); 
    
    // Center, space preserving dots.
    // Just the center dot.
    //float d2 = length(p - s - l/2.) - .004/sc;
    // Splitting space to produce four rivot-looking dots.
    p = abs(p - s - l/2.) - l/2. + .015;
    float d2 = length(p) - .004/sc;
    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.  
    
    // Very subtle bump element for some highlighting.
    sf *= 2.;
    d += .002*sc;
    float b = mix(.05, 0., 1. - smoothstep(0., sf, d)); // Rounded pavers.
    b = mix(b, .5, 1. - smoothstep(0., sf, d + .003*sc)); 
    //b = mix(b, 0., 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); 
    b = mix(b, 0., 1. - smoothstep(0., sf, d2)); // Rounded pavers.  
    
      
    // Return the color and the bump value.
    return vec4(col, b);
    
}

// Function 225
float boxDist(vec2 p){
    vec2 d = abs(p)-1.0;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 226
void getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {
	// falling?
	float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );
	float t = fract(14.*s + time/s*.3);
	
	float y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );
	vec2 offset = grid + sphereOffset;
	
	center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}

// Function 227
void intersectSphere(
	vec3 rayOrigin,
	vec3 rayDir,
	vec3 sphereCentre,
	float sphereRadius,
	inout float rayT,
	inout vec3 geomNormal)
{
	// ray: x = o + dt, sphere: (x - c).(x - c) == r^2
	// let p = o - c, solve: (dt + p).(dt + p) == r^2
	//
	// => (d.d)t^2 + 2(p.d)t + (p.p - r^2) == 0
	vec3 p = rayOrigin - sphereCentre;
	vec3 d = rayDir;
	float a = dot(d, d);
	float b = 2.0*dot(p, d);
	float c = dot(p, p) - sphereRadius*sphereRadius;
	float q = b*b - 4.0*a*c;
	if (q > 0.0) {
		float denom = 0.5/a;
		float z1 = -b*denom;
		float z2 = abs(sqrt(q)*denom);
		float t1 = z1 - z2;
		float t2 = z1 + z2;
		bool intersected = false;
		if (0.0 < t1 && t1 < rayT) {
			intersected = true;
			rayT = t1;
		} else if (0.0 < t2 && t2 < rayT) {
			intersected = true;
			rayT = t2;
		}
		if (intersected) {
			geomNormal = normalize(p + d*rayT);
		}
	}
}

// Function 228
float iTorus( in vec3 ro, in vec3 rd, in vec2 tor )
{
    float po = 1.0;

    
    float Ra2 = tor.x*tor.x;
    float ra2 = tor.y*tor.y;
	
    float m = dot(ro,ro);
    float n = dot(ro,rd);
	
    float k = (m - ra2 - Ra2)/2.0;
    float k3 = n;
    float k2 = n*n + Ra2*rd.z*rd.z + k;
    float k1 = k*n + Ra2*ro.z*rd.z;
    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;
	
    #if 1
    // prevent |c1| from being too close to zero
    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )
    {
        po = -1.0;
        float tmp=k1; k1=k3; k3=tmp;
        k0 = 1.0/k0;
        k1 = k1*k0;
        k2 = k2*k0;
        k3 = k3*k0;

    }
	#endif

    float c2 = 2.0*k2 - 3.0*k3*k3;
    float c1 = k3*(k3*k3 - k2) + k1;
    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;

    
    c2 /= 3.0;
    c1 *= 2.0;
    c0 /= 3.0;
    
    float Q = c2*c2 + c0;
    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;
    
	
    float h = R*R - Q*Q*Q;
    float z = 0.0;
    if( h < 0.0 )
    {
    	// 4 intersections
        float sQ = sqrt(Q);
        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );
    }
    else
    {
        // 2 intersections
        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );
        z = sign(R)*abs( sQ + Q/sQ );
    }		
    z = c2 - z;
	
    float d1 = z   - 3.0*c2;
    float d2 = z*z - 3.0*c0;
    if( abs(d1) < 1.0e-4 )
    {
        if( d2 < 0.0 ) return -1.0;
        d2 = sqrt(d2);
    }
    else
    {
        if( d1 < 0.0 ) return -1.0;
        d1 = sqrt( d1/2.0 );
        d2 = c1/d1;
    }

    //----------------------------------
	
    float result = 1e20;

    h = d1*d1 - z + d2;
    if( h > 0.0 )
    {
        h = sqrt(h);
        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;
        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;
        if( t1 > 0.0 ) result=t1; 
        if( t2 > 0.0 ) result=min(result,t2);
    }

    h = d1*d1 - z - d2;
    if( h > 0.0 )
    {
        h = sqrt(h);
        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;
        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;
        if( t1 > 0.0 ) result=min(result,t1);
        if( t2 > 0.0 ) result=min(result,t2);
    }

    return result;
}

// Function 229
float distanceToSphere(vec3 p, float r) {
    return length(p)-r;   
}

// Function 230
vec3 uniform_sphere_volume (inout Random rng) {
    return uniform_sphere_area(rng) * pow(random(rng), 1.0/3.0);
}

// Function 231
d2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}

// Function 232
bool hitSphere(in ray r, float tmin, float tmax, inout hitRecord rec, sphere s)
{
    vec3 oc = origin(r) - s.center;
    float a = dot(direction(r),direction(r));
    float b = dot(oc, direction(r));
    float c = dot(oc,oc)-s.radius*s.radius;
    float d = b*b - a*c;
    if (d > 0.) 
    {
        float temp = (-b - sqrt(b*b-a*c))/a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.p = pointAtParameter(r,rec.t);
            rec.normal = (rec.p - s.center) / s.radius;
            rec.mat = s.mat;
            rec.color = s.color;
            return true;
        }
        temp = (-b + sqrt(b*b-a*c))/a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.p = pointAtParameter(r,rec.t);
            rec.normal = (rec.p - s.center) / s.radius;
            rec.mat = s.mat;
            rec.color = s.color;
            return true;
        }
    }
    return false;
}

// Function 233
d2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize
 ;c2 u=subdabsd(p,s)//u=abs(p)-s 
 ;return maxdm(u)     //return max(u.x,u.y)
 ;}

// Function 234
float distSphere( vec3 samplePos, vec3 spherePos, float radius)
{
	vec3 normal;
	float bump = 0.0;
	if(length(samplePos-spherePos) < radius+BUMP_FACTOR)
	{	
		normal = normalize(samplePos-spherePos);
		bump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;
	}
	return length(samplePos-spherePos)-radius+bump;
}

// Function 235
vec4 getSphere(int num) {

    float time = iTime/2. + float(num);
    float constRandom = rand(vec2(float(num), float(num) + 7.));
    
    float rStep = 1.;
    
    vec3 sizePos = vec3(
        sin(time + constRandom) + 1., 
        cos(time + constRandom * rStep++) + 1., 
        sin(time + constRandom * rStep++) + 1.) * 2.;
        
    sizePos *= sin(time + constRandom * rStep++) - .5;
    sizePos.x += float(NUM_SPHERES - NUM_SPHERES/2)/100.;
    sizePos.y  = sizePos.y * 0.8 + 0.3;

    sizePos.z *= 2.;

    return vec4(sizePos, 1.);
        
}

// Function 236
float boxgrid(vec3 p, vec3 s, vec3 r) {p=abs(p)-s; p=abs(max(p,p.yzx))-r; return max(p.x,max(p.y,p.z));}

// Function 237
vec2 iSphere( const in vec3 ro, const in vec3 rd, const in vec4 sp, const in vec3 ve, out vec3 nor )
{
    float t = -1.0;
	float s = 0.0;
	nor = vec3(0.0);
	
	vec3  rc = ro - sp.xyz;
	float A = dot(rc,rd);
	float B = dot(rc,rc) - sp.w*sp.w;
	float C = dot(ve,ve);
	float D = dot(rc,ve);
	float E = dot(rd,ve);
	float aab = A*A - B;
	float eec = E*E - C;
	float aed = A*E - D;
	float k = aed*aed - eec*aab;
		
	if( k>0.0 )
	{
		k = sqrt(k);
		float hb = (aed - k)/eec;
		float ha = (aed + k)/eec;
		
		float ta = max( 0.0, ha );
		float tb = min( 1.0, hb );
		
		if( ta < tb )
		{
            ta = 0.5*(ta+tb);			
            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );
            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );
            s = 2.0*(tb - ta);
		}
	}

	return vec2(t,s);
}

// Function 238
float sdrBox(vec3 p, vec3 b, float r) {
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;
}

// Function 239
void boxFold(inout vec3 z, inout float dz) {
	z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
}

// Function 240
float sSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
	float res = 1.0;
	
	vec3 oc = sph.xyz - ro;
	float b = dot( oc, rd );
	
	if( b<0.0 ) 
	{
		res = 1.0;
	}
	else
	{
	    float h = sqrt( dot(oc,oc) - b*b ) - sph.w;
		
        res = clamp( 16.0 * h / b, 0.0, 1.0 );
	}
	return res;

	
	
	return res;
}

// Function 241
hit traceSphere(in ray r, in sph s) {
    seg g = tSphere(r, s);
    float d = minT(g.t.y, g.t.x);
    vec3 l = r.o + r.d * d;
    return hit(l, nSphere(l, s), d, s.m);   
}

// Function 242
float atmosphereIntersection(in vec3 origin, in vec3 direction)
{
    float b = dot(direction, origin);
    float d = b * b - dot(origin, origin) + Ra * Ra;
    return (d >= 0.0) ? (-b + sqrt(d)) : 0.0;
}

// Function 243
float fSphere(vec3 p, float r) {
  return length(p) - r;
}

// Function 244
float box(vec4 ray, vec3 pos, vec3 size)
{
    maxGISize = max(maxGISize,length(size)*ray.w);
    
    ray.xyz = abs(ray.xyz-pos) - size;
    return ray.w*max(max(ray.x,ray.y),ray.z);
}

// Function 245
vec2 obj_sphere(in vec3 p)
{
  float d = length(p)-1.9;
  return vec2(d,1);
}

// Function 246
v0 cylinderY(v2 u,v0 r,v0 h){return cylinderZ(u.xzy,r,h);}

// Function 247
float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  return length(q)-t.y;
}

// Function 248
vec3 intersectPlane(vec3 rayOrigin, vec3 rayDirection, vec3 normal, float offset) {
	float dist = dot(normal, normal * offset - rayOrigin) / dot(normal, rayDirection);
	return rayOrigin + rayDirection * dist;
}

// Function 249
vec3 sphereNormal(vec4 sph, vec3 p) {
    return (p - sph.xyz) / sph.w;
}

// Function 250
vec4 get_collision_plane(int index)
{
    ivec2 addr = ivec2(ADDR_RANGE_COLLISION_PLANES.xy);
    addr.x += index;
    return texelFetch(SETTINGS_CHANNEL, addr, 0);
}

// Function 251
vec2 iSphere(in ray sceneRay, in vec4 sph) {
	//sphere at origin has equation |xyz| = r
	//so |xyz|^2 = r^2.
	//Since |xyz| = rayOrigin + t*rayDirection (where t is the distance to move along the ray),
	//we have rayOrigin^2 + 2*rayOrigin*t*rayDirection + t^2 - r^2. This is a quadratic equation, so:
	vec3 oc = sceneRay.origin - sph.xyz; //distance ray origin - sphere center
	
	float b = dot(oc, sceneRay.direction);
	float c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.
	
	vec2 t;
	if(h < 0.0) 
		t = vec2(-1.0);
	else  {
		float sqrtH = sqrt(h);
		t.x = (-b - sqrtH); //Again a = 1.
		t.y = (-b + sqrtH);
	}
	return t;
}

// Function 252
float sdTorus( vec3 p, vec2 t ) {
        vec2 q = vec2(length(p.xy) - t.x, p.z);
        return length(q) - t.y;
    }

// Function 253
void getSphereOffset( vec2 grid, inout vec2 center ) {
	center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);
}

// Function 254
void raytrace_plane(
	vec4 plane_center,
	vec4 plane_normal,
	vec4 ray_origin,
	vec4 ray_direction,
	inout vec3 inout_ray_color,
	inout float inout_ray_depth)
{    
    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form
    float depth = dot((plane_center - ray_origin), plane_normal) / dot(ray_direction, plane_normal);
    
    if ((depth >= 0.0) &&
        (depth < inout_ray_depth))
    {
        vec4 intersection = (ray_origin + (ray_direction * depth));

        float diffuse_fraction = (1.0 * max(0.0, dot(plane_normal, s_light_direction)));
        float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));
        
        vec3 surface_color = vec3(1.0);
        
        // Checkerboard
        if (true)
        {
            float fuzziness = (0.025 * depth);
            
            surface_color = 
                mix(
                	vec3(0.1),
                	vec3(0.9),
                	abs((smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.x)) + smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.z))) - 1.0));            
        }

        inout_ray_color = (surface_color * mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction))));
        inout_ray_depth = depth;
    }
}

// Function 255
float Sphere(vec4 p) {
  vec4 a = vec4(1.0,1.0,1.0,-2.0);
  return dot(a*p,p);
}

// Function 256
float dfPlane(vec3 p, vec3 n, float d)      {return dot(p, n) + d;}

// Function 257
float sdPlane(vec3 pos, float height)
{
	float plane = pos.y - height;
#ifdef FLOOR_DISPLACEMENT
    return plane - textureLod(iChannel0, pos.xz * .02, 0.).r * .01;   
#else
    return plane;
#endif
}

// Function 258
vec3 nPlane(in pln p) {
    return p.n;
}

// Function 259
float intersect_sphere(in Ray r, in Sphere s)
{
    r.o = r.o - s.p; //translate everything so that the sphere is centered
    
    float b = dot(r.o, r.d);
    float delta = b * b - dot(r.o, r.o) + s.r * s.r;
    
   	if (delta < 0.) return -1.;
    
    float sqdelta = sqrt(delta);
    
    if (-b - sqdelta > 0.001) return -b - sqdelta; //epsilon to avoid self intersection
    else if (-b + sqdelta > 0.001) return -b + sqdelta;
    return -1.;
}

// Function 260
vec3 Glowplanes(vec3 a,float b
){a=fract(a*.2)*2.-1.
 ;a.z=b
 ;float c=50.//brightness modifier
 ;for(int i=0;i<5;++i//iteration count is scene specific
 ){float d=clamp(dd(a),.05,.65);
  ;c*=d;
  ;a=abs(a)/d-1.31;
  ;a.xy=a.xy*mat2(1,1,-1,1)*t0
 ;}return a*c;}

// Function 261
float SphereIntersect( float rad, vec3 pos, Ray ray ){
	float t = INFINITY;
	float t0, t1;
	vec3 L = ray.origin - pos;
	float a = dot( ray.direction, ray.direction );
	float b = 2.0 * dot( ray.direction, L );
	float c = dot( L, L ) - (rad * rad);
	if (!solveQuadratic( a, b, c, t0, t1))
		return INFINITY;
	if ( t1 > 0.0 )
		t = t1;
	if ( t0 >= 0.0 )
		t = t0;
	return t;
}

// Function 262
float box(vec3 p, vec3 s) {

  vec3 ap=abs(p)-s;
  return length(max(vec3(0),ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));

}

// Function 263
float intersectSphere(in vec3 ro, in vec3 rd, in vec4 sph)
{
    // a sphere centered at the origin has equation |xyz| = r
    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2
    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0
	// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0
    // which is a quadratic equation, so

    vec3 oc = ro - sph.xyz;
    float b = 2.0 *dot(oc, rd);
    float c = dot(oc,oc) - sph.w*sph.w;
    float h = b*b - 4.0 *c;
    if(h <0.0) return -1.0; //no intersection

    //pick smaller one(i.e, close one)
    //not (-b+sqrt(h)) /2
    float t = (-b - sqrt(h))/ 2.0;
    return t;
}

// Function 264
RayHit traceBox(Ray ray, Box box){
    RayHit rayHit;
    vec3 bMin = box.origin - box.radius;
    vec3 bMax = box.origin + box.radius;
    vec3 rayInv = 1.0 / ray.direction;
    
    vec3 t1 = (bMin - ray.origin) * rayInv;
    vec3 t2 = (bMax - ray.origin) * rayInv;
    
    vec3 vMin = min(t1, t2);
    vec3 vMax = max(t1, t2);
    
    float tMin = max(vMin.z, max(vMin.x, vMin.y));
    float tMax = min(vMax.z, min(vMax.x, vMax.y));
    
    
    if((tMax <= tMin) || (tMin <= 0.0)){
        rayHit.hit = false;
        return rayHit;
    }
    rayHit.hit = true;
    rayHit.baseColor = box.color;
    rayHit.depth = tMin;
    rayHit.worldPosition = ray.origin + ray.direction * rayHit.depth;
    rayHit.lit = box.lit;
    
    if(t1.x == tMin) rayHit.normal = vec3(1.0, 0.0, 0.0);
    if(t2.x == tMin) rayHit.normal = vec3(-1.0, 0.0, 0.0);
    if(t1.y == tMin) rayHit.normal = vec3(0.0, 1.0, 0.0);
    if(t2.y == tMin) rayHit.normal = vec3(0.0, -1.0, 0.0);
    if(t1.z == tMin) rayHit.normal = vec3(0.0, 0.0, 1.0);
    if(t2.z == tMin) rayHit.normal = vec3(0.0, 0.0, -1.0);
    
    return rayHit;
}

// Function 265
bool RaySphereIntersection(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p0, out vec3 p1) {
    p0 = vec3(0.0);
    p1 = vec3(0.0);
    
   	vec3 oc = ro - c;
    float poc = dot(rd, oc);
    
    float sloc = dot(oc, oc);
    float test = poc*poc - sloc + r*r;
        
    if (test < 0.0) return false;
    
    float sqt = sqrt(test);
    float d0 = -poc - sqt;
    float d1 = -poc + sqt;
    
	p0 = ro + d0*rd;
    p1 = ro + d1*rd;
    return true;
}

// Function 266
float iPlane2(vec3 o, vec3 d, vec4 plane) { // ray Origin, ray Direction
	vec3 n = plane.xyz;
	float dist = -plane.w;
	float denom = dot(n, d);

	return - (dot(n, o)+dist)/denom;
}

// Function 267
float sdTwistedTorus( in vec3 pos, float angle)
{
  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.20, 0.05));
}

// Function 268
bool box_intersect(const in ray r, const in float t_min, const in float t_max,
                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {
    vec3 m = 1./r.direction;
    vec3 n = m*(r.origin - center);
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.) return false;
    
    float t = tN < t_min ? tF : tN;
    if (t < t_max && t > t_min) {
        dist = t;
		normal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
	    return true;
    } else {
        return false;
    }
}

// Function 269
float DE_Torus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 270
float Torus(vec3 p, float R, float r)
{
	return sqrt(sq(sqrt(sq(p.x)+sq(p.z))-R)+sq(p.y))-r;
}

// Function 271
float planeIntersection(vec3 N,vec3 V,vec3 pos){
	float distToPlane = -dot(pos,N);
	float rayDotPlane = -dot(V,N);
    if (rayDotPlane > 0. && distToPlane > 0.)
        return distToPlane/rayDotPlane;
    else return 0.;
}

// Function 272
float  sphere(vec3 p, float s )
{
    return length(p)-s;
}

// Function 273
float sdPlane( vec3 p, vec4 n )
{
  	return dot(p,n.xyz) + n.w;
}

// Function 274
float pTorus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 275
float cosineHemispherePDF(float NoL)
{
    return NoL / PI;
}

// Function 276
float sdCappedTorus(vec3 p, vec2 r, float per) {
    p.x = abs(p.x);
    vec2 sc = vec2(sin(per),cos(per));
    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);
    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;
}

// Function 277
float sdCappedYCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz), p.y)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 278
bool isinbox(vec2 a,vec2 b,float s){return all(lessThan(a-b,vec2(0)))||all(greaterThan(a-b,vec2(s)));}

// Function 279
vec2 uv_lens_half_sphere(vec2 uv, vec2 position, float radius, float refractivity){
	vec2 polar = uv_polar(uv, position);
	float cone = clamp(1.-polar.y/radius, 0., 1.);
	float halfsphere = sqrt(1.-pow(cone-1.,2.));
	float w = atan2(1.-cone, halfsphere);
	float refrac_w = w-asin(sin(w)/refractivity);
	float refrac_d = 1.-cone - sin(refrac_w)*halfsphere/cos(refrac_w);
	vec2 refrac_uv = position + vec2(sin(polar.x),cos(polar.x))*refrac_d*radius;
	return mix(uv, refrac_uv, float(length(uv-position)<radius));
}

// Function 280
float sdTorus( vec3 p, vec2 t )
{
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 281
v0 box(v3 ray, v2 u, v2 size
){maxGISize = max(maxGISize,length(size)*ray.w)
 ;ray.xyz = abs(ray.xyz-u) - size
 ;return ray.w*max(max(ray.x,ray.y),ray.z);}

// Function 282
ISObj intersectSphere(in Sphere s, in Ray r, in int id) {
    vec3 offset = (r.origin - s.center);
	float a = dot(r.dir, r.dir);
    float b = 2.0 * dot(offset, r.dir);
    float c = dot(offset, offset) - s.radius * s.radius;
    
    float det = sqrt(b*b - 4.0*a*c);
    
    if (det < 0.0) {
        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);
    } else {
        float t = min(- b - det, - b + det) / (2.0 * a);
    	return ISObj(t, OBJECT_TYPE_SPHERE, id);
    }

}

// Function 283
hit tracePlane(in ray r, in pln p) {
    float a = dot(p.n, r.d),
    	  d = dot(p.n, p.l - r.o) / a;
    d = (d < 0. || d > zfar)? zfar: d;
    return hit(r.o + r.d * d, p.n,
               vec3(max(0., d), a + 1.0 + p.i.x, 0.), p.m);
}

// Function 284
vec4 ProceduralSkybox(vec3 ro, vec3 rd)
{
    vec3 _WorldSpaceLightPos0 = vec3(2,sin(iTime*0.5)*10.0+1.0,20);
    vec3 kSkyTintInGammaSpace = _SkyTint;
    vec3 kScatteringWavelength = mix(ScatteringWavelength-ScatteringWavelengthRange,ScatteringWavelength+ScatteringWavelengthRange,vec3(1,1,1) - kSkyTintInGammaSpace);
    vec3 kInvWavelength = 1.0 / (pow(kScatteringWavelength, vec3(4.0)));
    float kKrESun = kRAYLEIGH * kSUN_BRIGHTNESS;
    float kKr4PI = kRAYLEIGH * 4.0 * 3.14159265;
    vec3 cameraPos = vec3(0,kInnerRadius + kCameraHeight,0);
    vec3 eyeRay = rd;
    float far = 0.0;
    vec3 cIn, cOut;
    if(eyeRay.y >= 0.0)
    {
        far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;
        vec3 pos = cameraPos + far * eyeRay;
        float height = kInnerRadius + kCameraHeight;
        float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));
        float startAngle = dot(eyeRay, cameraPos) / height;
        float startOffset = depth*Scale(startAngle);
        float sampleLength = far / kSamples;
        float scaledLength = sampleLength * kScale;
        vec3 sampleRay = eyeRay * sampleLength;
        vec3 samplePoint = cameraPos + sampleRay * 0.5;
        vec3 frontColor = vec3(0.0, 0.0, 0.0);
        for (int i=0; i<2; i++)
        {
            float height = length(samplePoint);
            float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));
            float lightAngle = dot(normalize(_WorldSpaceLightPos0.xyz), samplePoint) / height;
            float cameraAngle = dot(eyeRay, samplePoint) / height;
            float scatter = (startOffset + depth*(Scale(lightAngle) - Scale(cameraAngle)));
            vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));
            frontColor += attenuate * (depth * scaledLength);
            samplePoint += sampleRay;
        }
        cIn = frontColor * (kInvWavelength * kKrESun);
        cOut = frontColor * kKmESun;
    }
    else
    {
        far = (-kCameraHeight) / (min(-0.001, eyeRay.y));
        vec3 pos = cameraPos + far * eyeRay;
        float cameraScale = Scale(dot(-eyeRay, pos));
        float lightScale = Scale(dot(normalize(_WorldSpaceLightPos0.xyz), pos));
        float sampleLength = far / kSamples;
        float scaledLength = sampleLength * kScale;
        vec3 sampleRay = eyeRay * sampleLength;
        vec3 samplePoint = cameraPos + sampleRay * 0.5;
        vec3 frontColor = vec3(0.0, 0.0, 0.0);            
        float height = length(samplePoint);
        float d = exp(kScaleOverScaleDepth * (kInnerRadius - height));
        float scatter = d*(lightScale + cameraScale) - exp((-kCameraHeight) * (1.0/kScaleDepth))*cameraScale;
        vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));
        frontColor += attenuate * (d * scaledLength);
        samplePoint += sampleRay;
        cIn = frontColor * (kInvWavelength * kKrESun + kKmESun);
        cOut = clamp(attenuate, 0.0, 1.0);
    }
    vec3 groundColor = _Exposure * (cIn + _GroundColor*_GroundColor * cOut);
    vec3 skyColor = _Exposure * (cIn * (0.75 + 0.75 * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay) * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay))); 
    float lightColorIntensity = clamp(length(_LightColor0.xyz), 0.25, 1.0);
    vec3 sunColor = kHDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * _LightColor0.xyz / lightColorIntensity;	    
    vec3 ray = -rd;
    float y = ray.y / SKY_GROUND_THRESHOLD;
    vec3 color = mix(skyColor, groundColor, clamp(y,0.0,1.0));
    if(y < 0.0) color += sunColor * SunAttenuation(normalize(_WorldSpaceLightPos0.xyz), -ray);
    return vec4(sqrt(color),1.0);      
}

// Function 285
float box(vec2 p, vec2 b, float r)
{
  return length(max(abs(p)-b,0.0))-r;
}

// Function 286
vec4 char_ui_box(int idx) {
    
    const vec2 digit_rad = vec2(0.35, 0.5);
    
    return vec4(inset_ctr.x + (float(idx - 1))*text_size,
                2.*inset_ctr.y + 1.15*text_size,
                digit_rad*text_size);
    
}

// Function 287
float Sphere(vec3 p, float r){
  return length(p) -    r;
}

// Function 288
float cylinder(vec3 p, vec3 c, float r) {
    return length(p.yz-c.yz) - r;
}

// Function 289
void sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, out float sd){
	sd = sdSphere(pos, center, radius);
    vec2 e = vec2(0.01, 0.);
    normal = normalize(sd - vec3(
    	sdSphere(pos - e.xyy, center, radius),
    	sdSphere(pos - e.yxy, center, radius),
    	sdSphere(pos - e.yyx, center, radius)
    ));
}

// Function 290
Color3 shadowedAtmosphereColor(vec2 fragCoord, vec3 iResolution, float minVal) {
    vec2 rel = 0.65 * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;
    const float maxVal = 1.0;
    
    float a = min(1.0,
                  pow(max(0.0, 1.0 - dot(rel, rel) * 6.5), 2.4) + 
                  max(abs(rel.x - rel.y) - 0.35, 0.0) * 12.0 +                   
	              max(0.0, 0.2 + dot(rel, vec2(2.75))) + 
                  0.0
                 );
    
    float planetShadow = mix(minVal, maxVal, a);
    
    return atmosphereColor * planetShadow;

}

// Function 291
float sdCylinder (vec2 p, float r) { return length(p)-r; }

// Function 292
bool boxIntersect( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) 
{
	vec3 roo = ro - cen;
    if( abs(roo.x)<rad.x && abs(roo.y)<rad.y && abs(roo.z)<rad.z ) return true;

    vec3 m = 1.0/rd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	return ( tN < tF && tF > 0.0);
}

// Function 293
float intersect_box(vec3 ro,vec3 rd, out vec3 normal, vec3 size)
{
	float t_min = 0.0;
	float t_max = 999999999.0;
	if(intersect_aabb(ro,rd, AABB(-size, size), t_min, t_max)) {
		vec3 p = ray_at(ro,rd,t_min);
		p /= size;
		if(abs(p.x) > abs(p.y)) {
			if(abs(p.x) > abs(p.z)) {
				normal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);
			}
			else {
				normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);
			}
		}
		else if(abs(p.y) > abs(p.z)) {
			normal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);
		}
		else {
			normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);
		}

		return t_min;
	}

	return INFINITY;
}

// Function 294
d2 fBox(c2 p,v2 s){//v3 s=v3(1.5,.5,1.5);
 c2 d=suab(p,s);//mirror clamp
 d2 a=sd(ma(d,0.));//rounded corners
 c2 q=mi(d,0.);//clamp
 d2 b=madm(q);//keep largest of 3
 return ad(a,b);}

// Function 295
bool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, out float t, out SurfaceHitInfo isect ) {
	float phi;
	vec3 phit;
	float t0, t1;
    
	if (!iCylinder(r, radius, t0, t1))
		return false;

    if ( t1 < 0.0 )
        return false;
    
	t = t0;
    
	if (t0 < 0.0)
		t = t1;

	// Compute cylinder hit point and $\phi$
	phit = r.origin + r.dir*t;
	phi = atan(phit.y,phit.x);
    phi += PI;
    
	if (phi < 0.0)
        phi += TWO_PI;
 
	// Test cylinder intersection against clipping parameters
	if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {
		if (t == t1)
            return false;
		t = t1;
		// Compute cylinder hit point and $\phi$
		phit = r.origin + r.dir*t;
		phi = atan(phit.y,phit.x);
        phi += PI;

		if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )
			return false;
	}
    
    isect.position_ = phit;
    isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );
    
	return true;
}

// Function 296
vec3 cylinderImpact(in vec2 pos, in vec2 ray, in vec2 cylO, in float cylR){
    float t = INFINI;
    vec2 delta = pos - cylO;
    
    float a = dot(ray,ray);
    float b = dot(delta, ray);
    float c = dot(delta,delta) - cylR*cylR;
    float d = b*b - a*c;
    
    if (d >= 0.){
        float sd = sqrt(d);
        t = (-b - sd)/a;
        if (t < 0.001) t = INFINI;
    }
    
    vec2 norm = pos + t*ray - cylO;
	return vec3(norm,t);
}

// Function 297
float sphereInter( vec4 ro, vec3 rd, vec4 s ) {
    // Transform the ray into object space
    vec3 oro =  ro.xyz - s.xyz ;

    float a = dot(rd, rd);
    float b = 2.0 * dot(oro, rd);
    float c = dot(oro, oro) - s.w * s.w; // w is the sphere radius

    float d = b * b - 4.0 * a * c;

    if(d < 0.0) return d; // No intersection
    
    return (-b - sqrt(d)) / 2.0;
}

// Function 298
gia1 gia_sphere(gia1x3 p, float r) {
    return gia_sub(gia_sqrt(gia_add(gia_add(gia_pow2(p.x),gia_pow2(p.y)), gia_pow2(p.z))), gia_const(r));
}

// Function 299
float sphere(vec3 ro, vec3 rd, vec3 pos, float r){
    vec3 ce = ro-pos;
    float b = dot(rd, ce);
    return -b-sqrt(b*b-dot(ce, ce)+r*r);
}

// Function 300
vec2 GetDistanceSphere( const in vec3 vPos )
{
	float fDistance = length(vPos - vec3(1.3, 0.75, 1.0)) - 0.75;

	return vec2(fDistance, kMaterialChrome);
}

// Function 301
float plane(vec3 p){
	return p.y;
}

// Function 302
MapInfo box(vec3 origin, vec3 size, Material material) {
    return MapInfo(material, length(max(abs(origin) - size, 0.0)));
}

// Function 303
float box3(vec3 p, vec3 r) {
    vec3 d = abs(p) - r;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 304
float udBox (in vec3 p, in vec3 size, in float r)
{
    return length (max (abs (p) - (size -r), .0)) - r;
}

// Function 305
float box(vec3 org, vec3 dir, vec3 size, out float far)
{
	// compute intersection of ray with all six bbox planes
	vec3 invR = 1.0 / dir;
	vec3 tbot = invR * (-0.5*size - org);
	vec3 ttop = invR * (0.5*size - org);
	
	// re-order intersections to find smallest and largest on each axis
	vec3 tmin = min (ttop, tbot);
	vec3 tmax = max (ttop, tbot);
	
	// find the largest tmin and the smallest tmax
	vec2 t0 = max (tmin.xx, tmin.yz);
	float near;
	near = max (t0.x, t0.y);
	t0 = min (tmax.xx, tmax.yz);
	far = min (t0.x, t0.y);

	// check for hit
	return near < far && far > 0.0 ? near : INF;
}

// Function 306
float sdBox(vec3 p, vec3 b)
    {
        vec3 d = abs(p) - b;
        return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);
    }

// Function 307
bool plane_hit(in Ray inray, in Plane plane, out float dst) {
    float denom = dot(plane.normal, inray.dir);
    if (denom > 1e-6) {
        vec3 p0l0 = plane.origin - inray.origin;
        dst = dot(p0l0, plane.normal) / denom;
        return true;
    }
    return false;
}

// Function 308
vec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {
    float theta = acos(sqrt(1.0-Xi1));
    float phi = TWO_PI * Xi2;

    return sphericalToCartesian( 1.0, phi, theta );
}

// Function 309
float sphereSDF(vec3 p, float radius) {
    return length(p) - radius;
}

// Function 310
vec4 planeProjectNormalize(vec4 v, vec4 n){
    return normalize(v - n *dot(v, n));
}

// Function 311
bool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm
){t=10000000.
 ;float Al=ConeR_ab.x*rd.z
 ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y
 ;float A=dot(rd.xy,rd.xy)-Al*Al
 ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)
 ;float C=dot(ro.xy,ro.xy)-Bl*Bl
 ;vec2 tt
 ;if(!SolveSquare(A,B,C,tt))return false
 ;vec2 zz=ro.zz+rd.zz*tt
 ;int n=2
 //todo: apply zz.x-=zz.y and do the LessThan magic
 ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}
 ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}
 ;if(n==0)return false
 ;t=min(tt.x,tt.y)
 ;norm.xy=normalize(ro.xy+rd.xy*t)
 ;norm.z=-ConeR_ab.x
 ;norm=normalize(norm)
 ;return true;}

// Function 312
float sdTorus88( vec3 p, vec2 t )
{
    vec2 q = vec2(length8(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

// Function 313
float sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )
{
  return dot(p - p0,normalize(cross(p0 - p1, p0 - p2)));
}

// Function 314
float sphere(vec3 p)
{
    return length(p) - 1.0;
}

// Function 315
vec3 sphereIntersection(vec3 p, vec3 d, vec4 s)
{
	//Solve the quadratic equation to find a lambda if there are intersections.
	//Since d is unit length, a = dot(d,d) is always 1
	vec3 o = p-s.xyz;
	//If we move the 2-factor off b, and the 4-factor off c in the discriminant,
	//We can eliminate one multiply, and move the other into the "if", making it slightly faster.
	float b = dot(d,o);
	float c = dot(o,o) - s.w*s.w;

	float discriminant = b*b - c;
	if (discriminant >= 0.0) {
		float sqd = sqrt(discriminant);
		//If discriminant == 0, there's only one intersection, and lambda1 == lambda2.
		//This should be fairly uncommon.
		float lambda1 = -b-sqd;
		float lambda2 = -b+sqd;
		return vec3(discriminant, lambda1, lambda2);
	}
	//No intersection.
	return vec3(discriminant, 0.0, 0.0);
}

// Function 316
vec3 TORUS_ROTATE(vec3 ro, float t)
{
	return QtnRotate(ro,
                  	 vec4(vec3(1.0f, 0.0f, 0.0f) * sin(t), cos(t)));
}

// Function 317
float sdTorus( vec3 p, vec2 t ) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 318
bool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){
	return ((dot(n,a)*dot(n,b))>0.0);
}

// Function 319
float rSphere(vec3 o, vec3 d, vec3 c, float r)
{
    vec3 e= c - o;
    float a= dot(e, d);
    float b= r*r - dot(e,e) + a*a;
    if(b>0.0)
    {
        float t = a- sqrt(b);
       // if(t>PRECISION_STEP)
            return t;
    }
   return 1e999;
}

// Function 320
float sdPlane(vec3 p, vec4 n) {
    // n must be normalized
    return dot(p, n.xyz) + n.w;
}

// Function 321
bool closestSphereSphere(vec3 cSphere1, float rSphere1, vec3 cSphere2, float rSphere2, out vec3 out0, out vec3 out1) {
    out0 = cSphere1; out1 = cSphere2;
    return removeThickness(rSphere1, rSphere2, out0, out1);
}

// Function 322
float sdfBox(in vec3 p, in vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 323
float sdBox(in vec2 p, in vec2 size, in float radius)
{
  vec2 d = abs(p) - size + radius;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

// Function 324
float traceCylinderSide(Cylinder cyl, vec3 orig, vec3 dir)
{
    // length((orig + t * dir).xy) = cyl.radius
    // t = ?
    
    float a = sqr(length(dir.xz));
    float b = 2.0 * dot(dir.xz, orig.xz);
    float c = sqr(length(orig.xz)) - sqr(cyl.radius);
    float D = sqr(b) - 4.0 * a * c;
    if (D < 0.0) {
        return INF;
    }
    
    float t1 = (-b + sqrt(D)) / (2.0 * a);
    if (t1 < 0.0) {
        t1 = INF;
    }
    
    float t2 = (-b - sqrt(D)) / (2.0 * a);
    if (t2 < 0.0) {
        t2 = INF;
    }
    
    float t = min(t1, t2);
    vec3 pos = orig + t * dir;
    if ((pos.y > cyl.center.y + cyl.height) ||
             (pos.y < cyl.center.y - cyl.height)) {
        return INF;
    }
    return t;
}

// Function 325
vec2 sphere_trace_2( float tp, float h_sqr, float radius )
{
	float radius_sqr = radius * radius;
	if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere
	float dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)
	return vec2( tp - dt, tp + dt ); // record 2 hits In, If
}

// Function 326
float raySphere(vec3 ro, vec3 rd)
{
    float lp;
    float dst;
    vec3 p = ro;
    float dfs = 0.;
    // stepping through the sphere till a collition happens
    for (int s = 0; s < 80; s++)
    {
        dst = -(length(p) - 10.);
        
        if (dst < 0.01) break;
        dfs += dst;
        p += rd * dst;
    }
    return dfs;
}

// Function 327
float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.yz)-t.x,p.x);
  return length(q)-t.y;
}

// Function 328
vec3 nSphere( in vec3 pos, in vec4 sph ) {
    return (pos-sph.xyz)/sph.w;
}

// Function 329
float hitPlane(vec3 camPos, vec3 ray) {
    return dot(vec3(0.0, 1.0, 0.0), ray);
}

// Function 330
float sdTorus( vec3 p, vec2 t, mat3 m )
{
  p = m * p;
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 331
bool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > 0.0f && dist < info.dist)
    {
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
		info.diffuse = diffuse;        
        return true;
    }
    
    return false;
}

// Function 332
float box2(vec2 p, vec2 s) {
    p=abs(p)-s;
    return max(p.x, p.y);
}

// Function 333
float intersect_sphere( vec3 O, vec3 D, vec3 C, float r )
{
	float b = dot( O-=C, D ),
	      h = b*b - dot( O, O ) + r*r;
	return h < 0. ? -1.             // no intersection
	              : -b - sqrt(h);
}

// Function 334
float massSphere(float r, float density) {
    float v = 4.*r*r*r*PI/3.;  // volume sphere m
    return v * density; // masse 
}

// Function 335
float cone(vec3 p, vec2 c)
{
    // c must be normalized
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

// Function 336
result intersectSphere(ray r, sphere s)
{
	result res;
	res.t = -INFINITY;
	
	vec3 v = r.o - s.c;
	float vd = dot(v, r.d);
	float d = vd * vd - (dot(v, v) - s.r * s.r);
	if(d < EPSILON)
		return res;
	float q = sqrt(d);	
	res.t = (-vd -q) > 0.0 ? -vd -q : -vd + q;
	res.n = normalize((r.o + r.d * res.t) - s.c);
	return res;
}

// Function 337
float mSphere(vec3 p, float r)
{
    return length(p)-r;
}

// Function 338
float sdSphere( vec3 p, float r ) {
        return length(p) - r;
    }

// Function 339
float fCylinder(vec3 p, float r, float height)
{
    float d = length(p.xz) - r;
    d       = max(d, abs(p.y) - height);
    return d;
}

// Function 340
vec3 uniform_sphere_area (inout Random rng) {
    vec2 u = random2(rng);
    float phi = 6.28318530718*u.x;
    float rho_c = 2.0 * u.y - 1.0;
    float rho_s = sqrt(1.0 - (rho_c * rho_c));
    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);
}

// Function 341
vec3 getRandomHemisphereDir(vec3 basisNormal, vec3 surfaceNormal, float e) {
    float u1 = nextFloat();
    float u2 = nextFloat();
    float cosPhi = cos(2.0 * PI * u1);
    float sinPhi = sin(2.0 * PI * u1);
    float cosTheta = pow((1.0 - u2), 1.0 / (e + 1.0));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    float x = sinTheta * cosPhi;
    float y = sinTheta * sinPhi;
    float z = cosTheta;
    
    vec3 w = basisNormal;
    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0)), w));
    vec3 v = cross(w, u);
    
    vec3 dir = u * x + v * y + w * z;
    if (dot(dir, surfaceNormal) < 0.0) {	// dir is below the surface
        dir = -u * x - v * y + w * z;
    }
    
    return dir;
}

// Function 342
vec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)
{
    rp = rp - (p0 + p1) / 2.0;
    vec3 arp = abs(rp) / (p1 - p0);
    return normalize(step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp));
}

// Function 343
vec2 drawBox(vec3 p){
    vec3 prevP = p;
    vec3 size = vec3(3.5,0.01,3.5);
    p.z-=iTime*1.5;
    p.y+=noise3d(p*80.0)*0.005;
    p.z=mod(p.z,2.)-1.0;
    
    float d = B3D(p,size);
    p = prevP;
    float d2 = B3D(p,size);
    d = max(B3D(p,size),d);
    vec2 res = vec2(d, MATERIAL_BOX);
    return res;
}

// Function 344
float sdSphere(in vec3 p, in float r) {
    return length(p) - r;
}

// Function 345
float box(vec2 pos, float size) {
    
    return length(max(vec2(0.0),abs(pos)-size*0.5));
    
}

// Function 346
float sd_cylinder(vec3 p, float r, float height) {
  float d = length(p.xz) - r;
  d = max(d, abs(p.y) - height);
  return d;
}

// Function 347
RayHit TracePlanet( vec3 origin, vec3 direction, int steps, float maxDist)
{
  RayHit result;
  vec4 dist = vec4(1000000.);
  float precis = 0.0, t = 0.0;
  vec3 rayPos;

  for ( int i=0; i<steps+min(0, iFrame); i++ )
  {
    rayPos =origin+direction*t; 
    dist = MapPlanet( rayPos);
    precis =0.00001*t;

    if (dist.x<precis || t>maxDist)
    {             
      result.hit=!(t>maxDist);
      result.depth = t; 
      result.dist = dist;  
      result.hitPos = origin+((direction*t));    
      break;
    }

    t += dist.x*0.55;
  }

  return result;
}

// Function 348
vec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )
{
    // extremes
    vec2 mi = min(p0,p3);
    vec2 ma = max(p0,p3);

    // note pascal triangle coefficnets
    vec2 c = -1.0*p0 + 1.0*p1;
    vec2 b =  1.0*p0 - 2.0*p1 + 1.0*p2;
    vec2 a = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;

    vec2 h = b*b - a*c;

    // real solutions
    if( any(greaterThan(h,vec2(0.0))))
    {
        vec2 g = sqrt(abs(h));
        vec2 t1 = clamp((-b - g)/a,0.0,1.0); vec2 s1 = 1.0-t1;
        vec2 t2 = clamp((-b + g)/a,0.0,1.0); vec2 s2 = 1.0-t2;
        vec2 q1 = s1*s1*s1*p0 + 3.0*s1*s1*t1*p1 + 3.0*s1*t1*t1*p2 + t1*t1*t1*p3;
        vec2 q2 = s2*s2*s2*p0 + 3.0*s2*s2*t2*p1 + 3.0*s2*t2*t2*p2 + t2*t2*t2*p3;

        if( h.x > 0.0 )
        {
            mi.x = min(mi.x,min(q1.x,q2.x));
            ma.x = max(ma.x,max(q1.x,q2.x));
        }

        if( h.y > 0.0  )
        {
            mi.y = min(mi.y,min(q1.y,q2.y));
            ma.y = max(ma.y,max(q1.y,q2.y));
        }
    }
    
    return vec4( mi, ma );
}

// Function 349
float plane_d(vec3 p, vec3 norm)
{
    return dot(p, norm);
}

// Function 350
float PrConeDf (vec3 p, vec3 b)
{
  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);
}

// Function 351
void GetPlanetRotation(inout vec3 p)
{
  #ifdef ROTATING_PLANET
    pR(p.xz, (0.08*-iTime));
  #endif
}

// Function 352
float sdCappedXCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.yz), p.x)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 353
float cylinderDistance(vec3 point, float height, float radius) {
    vec2 d = abs(vec2(length(point.xz), point.y)) - vec2(radius, height);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 354
float sdBox( vec3 p, vec3 b ) 
{	
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 355
float sd_torus_xz( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 356
vec3 voronoiSphereMapping(vec3 n){
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
   	return getVoronoi(1.5*uv);}

// Function 357
float iBox(vec3 ro, vec3 rd, vec3 sides, out vec3 normal) {
	vec3 axis = normalize(vec3(0.0, 1.0, 0.0));
	mat3 rot = rotationAxisAngle(axis, PI/2.);
	vec3 xn = rot*vec3(1.0, 0.0, 0.0);
	vec3 yn = rot*vec3(0.0, 1.0, 0.0);
	vec3 zn = rot*vec3(0.0, 0.0, 1.0);
	axis = normalize(vec3(0.0, 1.0, 0.0));
	xn = rot*xn;
	yn = rot*yn;
	zn = rot*zn;	
	float t1, t2;
	float tNear = -10000.0;
	float tFar = 10000.0;
		
	// x -> yz-plane
	t1 = iPlane(ro, rd, vec4(xn, -0.5*sides.x));
	t2 = iPlane(ro, rd, vec4(xn, 0.5*sides.x));
	swapIfGreater(t1, t2);
	if(t1 > tNear) { normal = xn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar) return -1.0;
    if(tFar < 0.0) return -1.0;
	
	// y -> xz-plane
	t1 = iPlane(ro, rd, vec4(yn, -0.5*sides.y));
	t2 = iPlane(ro, rd, vec4(yn, 0.5*sides.y));	
	swapIfGreater(t1, t2);
	if(t1 > tNear) { normal = yn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar) return -1.0;
    if(tFar < 0.0) return -1.0;
	
	// z -> xy-plane
	t1 = iPlane(ro, rd, vec4(zn, -0.5*sides.z));
	t2 = iPlane(ro, rd, vec4(zn, 0.5*sides.z));	
	swapIfGreater(t1, t2);
	if(t1 > tNear) { normal = zn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar) return -1.0;
    if(tFar < 0.0) return -1.0;
	
	return tNear;
}

// Function 358
void closestPolyPlane(in vec3[POLY_SZ] v, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
    const int num = v.length();
    vec3 o0, o1, nPoly = normalize(cross(v[1]-v[0], v[0]-v[num-1]));
    float dmin = 1e5; 
    if (dot(nPoly,nPlane) == 0.) { // paralelle
        out0 = v[0];
        out1 = projPtOnPlane(v[0],pPlane, nPlane);
    } else {
        // Test segments
        for(int i=ZERO, j=num-1; i<num; j=i, i++) {
            closestSegmentPlane(v[i], v[j], pPlane, nPlane, o0, o1);
            float d = distance(o0,o1);
            if (d<dmin) {
                out0 = o0;
                out1 = o1;
                dmin = d;
            }
        }
    }
}

// Function 359
float sdSphere( vec3 p, float s )
{
	// The sphere is positioned at the origin (0,0,0) and has a radius of `s`.
	// the distance between the point `p` and the envelope of the shpere is
	// then the distance between the point and the origin, minus the radius
	// of the sphere.
	return length(p)-s;
}

// Function 360
vec3 getPlanetTexture( vec2 uv ) {
    return texture(iChannel0, uv).rgb;
}

// Function 361
vec2 sphere(vec3 o,vec3 dir,vec4 sp){
   vec3 a = sp.xyz - o;
   float b = dot(dir,a);
   float d = sqrt(dot(a,a)-b*b);
   float t = sqrt(sp.w*sp.w-d*d);
   if(d>sp.w) return vec2(-1); 
   return vec2(b-t,b+t);
}

// Function 362
float rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n);

    float s = 1e8;
    
    if (abs(dn) > 0.) {
        s = dot(p - o, n) / dn;
        s = s<0. ? 1e8 : s;
    }
    
    return s;//o + s*rd;
}

// Function 363
float sdRoundedCylinder( vec3 p, float ra, float rb, float h )
{
    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 364
float sdSphere(vec3 p) { return length(p) - 1.0; }

// Function 365
float sdTorus(vec2 t, vec3 p)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 366
SSphere GetSphere1()
{
	return SSphere
	(
		2,						//id
		vec3(0.0,0.0,0.0),		//center
		0.2,					//radius
		SMaterial
		(
			vec3(0.0,1.0,0.0),	//diffuse color
			10.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 367
vec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 368
float fCone(vec3 p, float radius, float height) {
	vec2 q = vec2(length(p.xz), p.y);
	vec2 tip = q - vec2(0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

// Function 369
float dBox(vec3 p, vec3 c, vec3 dimensions, mat3 rot) {
	vec3 d = abs((p - c) * rot) - dimensions;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 370
float IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {
    vec3 Z = ro-sc;
    float B = 2.0 * dot(rd, Z);
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;
    float D = B*B - 4.0*C;
    float d = -1.0;
    if(D>=0.0) {
        d = (.5*-B+(C>0.?-sqrt(D):sqrt(D)));
    }
    return d;
}

// Function 371
float iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
               float sphereRadius ) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - sphereRadius*sphereRadius;
    float h = b*b - c;
    if (h < 0.) {
        return MAX_DIST;
    } else {
	    h = sqrt(h);
        float d1 = -b-h;
        float d2 = -b+h;
        if (d1 >= distBound.x && d1 <= distBound.y) {
            normal = normalize(ro + rd*d1);
            return d1;
        } else if (d2 >= distBound.x && d2 <= distBound.y) { 
            normal = normalize(ro + rd*d2);            
            return d2;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 372
float sphere(vec3 p, float r)
{
 	return length(p) - r;
}

// Function 373
float sd_capped_cylinder(vec3 p, float half_height, float radius) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(radius, half_height);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 374
float sdBox(vec3 p, vec3 b) {
  p = abs(p) - b;
  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);
}

// Function 375
float sdTorusMedianCircle(const vec3 p, vec2 r, float inner_circle_scale) {
	vec2 q = vec2(MedianTriTorus_norm(vec2(p.x, p.z), r.x,inner_circle_scale), p.y);
	return MedianTriTorus_norm(q, r.y,inner_circle_scale);
}

// Function 376
float sdCylinderZ( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xy),p.z)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 377
float iRoundedBox(in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
   				  in vec3 size, in float rad ) {
	// bounding box
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*(size+rad);
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
    if (tN > tF || tF < 0.0) {
    	return MAX_DIST;
    }
    float t = (tN>=distBound.x&&tN<=distBound.y)?tN:
    		  (tF>=distBound.x&&tF<=distBound.y)?tF:MAX_DIST;

    // convert to first octant
    vec3 pos = ro+t*rd;
    vec3 s = sign(pos);
    vec3 ros = ro*s;
    vec3 rds = rd*s;
    pos *= s;
        
    // faces
    pos -= size;
    pos = max( pos.xyz, pos.yzx );
    if (min(min(pos.x,pos.y),pos.z)<0.0) {
        if (t >= distBound.x && t <= distBound.y) {
            vec3 p = ro + rd * t;
            normal = sign(p)*normalize(max(abs(p)-size,0.0));
            return t;
        }
    }
    
    // some precomputation
    vec3 oc = ros - size;
    vec3 dd = rds*rds;
	vec3 oo = oc*oc;
    vec3 od = oc*rds;
    float ra2 = rad*rad;

    t = MAX_DIST;        

    // corner
    {
    float b = od.x + od.y + od.z;
	float c = oo.x + oo.y + oo.z - ra2;
	float h = b*b - c;
	if (h > 0.0) t = -b-sqrt(h);
    }

    // edge X
    {
	float a = dd.y + dd.z;
	float b = od.y + od.z;
	float c = oo.y + oo.z - ra2;
	float h = b*b - a*c;
	if (h>0.0) {
	  h = (-b-sqrt(h))/a;
      if (h>=distBound.x && h<t && abs(ros.x+rds.x*h)<size.x ) t = h;
    }
	}
    // edge Y
    {
	float a = dd.z + dd.x;
	float b = od.z + od.x;
	float c = oo.z + oo.x - ra2;
	float h = b*b - a*c;
	if (h>0.0) {
	  h = (-b-sqrt(h))/a;
      if (h>=distBound.x && h<t && abs(ros.y+rds.y*h)<size.y) t = h;
    }
	}
    // edge Z
    {
	float a = dd.x + dd.y;
	float b = od.x + od.y;
	float c = oo.x + oo.y - ra2;
	float h = b*b - a*c;
	if (h>0.0) {
	  h = (-b-sqrt(h))/a;
      if (h>=distBound.x && h<t && abs(ros.z+rds.z*h)<size.z) t = h;
    }
	}
    
	if (t >= distBound.x && t <= distBound.y) {
        vec3 p = ro + rd * t;
        normal = sign(p)*normalize(max(abs(p)-size,1e-16));
        return t;
    } else {
        return MAX_DIST;
    };
}

// Function 378
float GetLightmapSphereFaceRes(Object obj)
{
    // assume 3x2 grid ..
	return (obj.lightmapBounds.w - obj.lightmapBounds.y)*0.5;
}

// Function 379
vec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {
    float theta = acos(sqrt(1.0-Xi1));
    float phi = TWO_PI * Xi2;

    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );
}

// Function 380
float box(in vec3 rp) {
    return max( -sdBox(rp-vec3(0.,0.,1.), vec3(8.,9,9.)),
                udBox(rp,vec3(9.,10.,9.)));
}

// Function 381
vec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {
    vec3 tMin=(bmin-origin)*dir;
    vec3 tMax=(bmax-origin)*dir;
    vec3 t1=min(tMin,tMax);
    vec3 t2=max(tMin,tMax);
    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));
}

// Function 382
float sdWobblySphere(vec3 p, float s) {
    return sdSphere(p,s)+sdDisplace(p)*0.1;
}

// Function 383
float fCone(vec3 p, float radius, float height) 
{
	vec2 q = vec2(length(p.xz), p.y);
	vec2 tip = q - vec2(0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

// Function 384
int plane(
    vec3 origin,
    vec3 direction,
    vec3 orient,
    float offset,
    inout float t,
    inout vec3 hit,
    inout vec3 normal)
{
    float t_plane = (offset - dot(origin, orient)) / dot(direction, orient);
    if (t_plane < epsilon || t < t_plane)
        return 0;
    t = t_plane;
    hit = origin + direction * t;
    normal = orient;
    return 1;
}

// Function 385
float castRayToSphere(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center;
    float qb = dot(ray.direction, oc);
    
    float det = qb * qb - dot(oc, oc) + sphere.radius * sphere.radius;
    if (det < 0.)
        return FAR_PLANE;
    
    float sqrt_det = sqrt(det);
    
    float t1 = -qb - sqrt_det;
    float t2 = -qb + sqrt_det;
    
    if (t1 < SHADOW_EPSILON)
        t1 = FAR_PLANE;
    if (t2 < SHADOW_EPSILON)
        t2 = FAR_PLANE;
    
    return min(t1, t2);
}

// Function 386
float box(vec3 p,vec3 o,vec3 s)
{
    p=abs(p-o)-s;
    return max(p.x,max(p.y,p.z));
}

// Function 387
int inbox(vec2 uv, vec2 pos, vec2 range)
{
	if(uv.x > pos.x-range.x && uv.x < pos.x+range.x)
        if(uv.y > pos.y-range.y && uv.y < pos.y+range.y)
            return 1;
    return 0;
}

// Function 388
float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}

// Function 389
vec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {
    vec3 tMin=(bmin-origin)*dir;
    vec3 tMax=(bmax-origin)*dir;
    vec3 t1=max(tMin,tMax);
    vec3 t2=min(tMin,tMax);
    return vec2(max(max(t2.x,t2.y),t2.z),min(min(t1.x,t1.y),t1.z));
}

// Function 390
float sdCubicalCylinder(vec4 p, vec3 rh1h2) {
	vec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;
	return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));
}

// Function 391
float sdCylinderXY( vec3 p, vec2 h ) {
  return max( length(p.xy)-h.x, abs(p.z)-h.y );
}

// Function 392
float sdBox(in vec2 P, in vec2 p, in vec2 b ){
    p = P-p;
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 393
float sphere(vec2 uv, float radius)
{
    return(length(uv)-radius);
}

// Function 394
float Sphere( vec3 centre, float radius, vec3 pos )
{
    return length(centre-pos)-radius;
}

// Function 395
float ellipticCylinderAppSurface(vec3 view, vec3 axis, vec2 radiuses, float height){
    float res = 0.f;
	res+= ellipseAppSurface(view, axis, radiuses, false);
	res+= ellipticTubeAppSurface(view, axis, radiuses, height);
    return res;
}

// Function 396
float sdSphere( vec3 p, float radius )
{
  return length(p) - radius;
}

// Function 397
RayHit BoxIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 boxPos, vec3 rad, float material)
{
    vec3 bmin = boxPos - rad;
    vec3 bmax = boxPos + rad;
    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;

    vec3 t1 = (bmin - pos) * rayInv;
    vec3 t2 = (bmax - pos) * rayInv;

    vec3 vmin = min(t1, t2);
    vec3 vmax = max(t1, t2);

    float tmin = max(vmin.z, max(vmin.x, vmin.y));
    float tmax = min(vmax.z, min(vmax.x, vmax.y));

    RayHit rh = NewRayHit();
    //rh.tMin = bignum;
    //rh.tMax = bignum;
    if ((tmax <= tmin)) return rh;
    if ((tmin <= 0.0)) return rh;
    //if ((tmax <= tmin) || (tmin <= 0.0)) return rh;
    rh.tMin = tmin;
    rh.tMax = tmax;
    rh.hitMin = pos + dirVecPLZNormalizeMeFirst * rh.tMin;
    rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;
    // optimize me!
    //if (t1.x == tmin) rh.normMin = vec3(-1.0, 0.0, 0.0);
    //if (t2.x == tmin) rh.normMin = vec3(1.0, 0.0, 0.0);
    //if (t1.y == tmin) rh.normMin = vec3(0.0, -1.0, 0.0);
    //if (t2.y == tmin) rh.normMin = vec3(0.0, 1.0, 0.0);
    //if (t1.z == tmin) rh.normMin = vec3(0.0, 0.0, -1.0);
    //if (t2.z == tmin) rh.normMin = vec3(0.0, 0.0, 1.0);
    rh.normMin = ElementwiseEqual(t1, tmin) - ElementwiseEqual(t2, tmin);
    // optimize me!
    //if (t1.x == tmax) rh.normMax = -vec3(-1.0, 0.0, 0.0);
    //if (t2.x == tmax) rh.normMax = -vec3(1.0, 0.0, 0.0);
    //if (t1.y == tmax) rh.normMax = -vec3(0.0, -1.0, 0.0);
    //if (t2.y == tmax) rh.normMax = -vec3(0.0, 1.0, 0.0);
    //if (t1.z == tmax) rh.normMax = -vec3(0.0, 0.0, -1.0);
    //if (t2.z == tmax) rh.normMax = -vec3(0.0, 0.0, 1.0);
    rh.normMax = ElementwiseEqual(t1, tmax) - ElementwiseEqual(t2, tmax);
    rh.material = material;
    return rh;
}

// Function 398
vec4 get_plane(int index)
{
    vec4 plane;
    
    if (index < NUM_MAP_AXIAL_PLANES)
    {
        uint
            brush = uint(index) / 6u,
        	side = uint(index) % 6u,
        	axis = side >> 1,
        	front = side & 1u;
        vec3 p = get_axial_point(int(brush * 2u + (front ^ 1u)));
        plane = vec4(0);
        plane[axis] = front == 1u ? -1. : 1.;
        plane.w = -p[axis] * plane[axis];
    }
    else
    {
        plane = get_nonaxial_plane(index - NUM_MAP_AXIAL_PLANES);
    }
    
    return plane;
}

// Function 399
float udRoundBox(in vec2 distFromCenter, in vec2 halfSize, in float cornerRadius)
{
    float t = length(max(abs(distFromCenter) - (halfSize - cornerRadius), 0.)) - cornerRadius;
    return smoothstep(-1., 1.,t);
}

// Function 400
vec4 CalculateOceanPlaneColor(vec4 baseColor, float yWorld, float yBackWorld, float yMidWorld, float yFrontWorld, float backPlaneToggle)
{
    #define BorderWidthHalf 0.1

    // Enlarge borders for steep vertical edges and for world dimensions
    float worldDimensionsAdjustment = abs(dFdy(yWorld)) * 1.5;
    float borderWidthHalfBack = BorderWidthHalf + abs(dFdx(yBackWorld)) + worldDimensionsAdjustment;
    float borderWidthHalfMid = BorderWidthHalf + abs(dFdx(yMidWorld)) + worldDimensionsAdjustment;
    float borderWidthHalfFront = BorderWidthHalf + abs(dFdx(yFrontWorld)) + worldDimensionsAdjustment;

    // Color

    // 1 when yWorld is below middle of the border, 0 otherwise
    float baseColorBack = step(yWorld, yBackWorld - borderWidthHalfBack);
    float baseColorMid = step(yWorld, yMidWorld - borderWidthHalfMid);
    float baseColorFront = step(yWorld, yFrontWorld - borderWidthHalfFront);

    float baseColorAlpha =
        max(
            1. * baseColorFront,
            max(
                .6 * baseColorMid * backPlaneToggle,
                .5 * baseColorBack * backPlaneToggle));

    //return vec4(baseColor, baseColorAlpha);

    // Border

    float borderBack =
        1. - smoothstep(0., borderWidthHalfBack, abs(yWorld - (yBackWorld - borderWidthHalfBack)));

    float borderMid =
        1. - smoothstep(0., borderWidthHalfMid, abs(yWorld - (yMidWorld - borderWidthHalfMid)));

    float borderFront =
        1. - smoothstep(0., borderWidthHalfFront, abs(yWorld - (yFrontWorld - borderWidthHalfFront)));

    // epsilon when front is visible, 1 otherwise
    #define FrontObscuredAlpha 0.4
    float borderFrontOpaqueness = (1. - baseColorFront) * (1. - FrontObscuredAlpha) + FrontObscuredAlpha;

    // epsilon when mid is visible, 1 otherwise
    #define MidObscuredAlpha 0.4
    float borderMidOpaqueness = (1. - baseColorMid) * (1. - MidObscuredAlpha) + MidObscuredAlpha;

    float borderAlpha =
        max(
            1. * borderFront,
            max(
                .9 * borderMid * borderFrontOpaqueness * backPlaneToggle,
                .7 * borderBack * borderFrontOpaqueness * borderMidOpaqueness * backPlaneToggle));

    //return vec4(1., 1., 1., borderAlpha);

    // Combine

    vec4 finalColor = mix(
        vec4(baseColor.xyz, baseColorAlpha * baseColor.w),
        vec4(1.), // Border color
        borderAlpha);

    return finalColor;
}

// Function 401
bool isect_sphere(vec3 o, vec3 d, vec3 c, float rsq, out float t)
{
    vec3 l = c-o;
    float tca = dot(l,d);
    if (tca < 0.0) return false;
    float dsq = -tca*tca + dot(l,l);
    if (dsq > rsq) return false;
    float thc = sqrt(rsq - dsq);
    t = tca - thc;
    return true;    
}

// Function 402
float sdf_centered_box(vec2 uv, vec2 center, vec2 size)
{
    return max(abs(uv.x-center.x) - size.x, abs(uv.y-center.y) - size.y);
}

// Function 403
maybe_float get_distance_along_3d_line_to_plane(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 N
){
    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);
}

// Function 404
float boxDistance(vec3 pos, vec3 center, vec3 scale) {
    vec3 localPos = pos - center;
    vec3 boxPos = clamp(localPos, -scale*0.5, scale*0.5);
    return length(pos - boxPos - center);
}

// Function 405
float emmSphere( in vec4 sph, in vec3 pos, in vec3 nor )
{
    vec3 di = sph.xyz - pos;
    float l = length(di);
    float at = 1.0-smoothstep(0.5,2.0,l);
	return at * pow(max(0.0,0.5+0.5*dot(nor,di/l)),2.0)*sph.w*sph.w/(l*l); 
}

// Function 406
float boundingBox( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 407
void sphere_fold(inout vec3 z, inout float dz) {
    float r2 = dot(z, z);
    if(r2 < min_radius2) {
        float temp = (fixed_radius2 / min_radius2);
        z *= temp;
        dz *= temp;
    }else if(r2 < fixed_radius2) {
        float temp = (fixed_radius2 / r2);
        z *= temp;
        dz *= temp;
    }
}

// Function 408
float sdCylinderXY( vec3 p, vec2 h ) {
  return length(p.xy)-h.x; //max( length(p.xy)-h.x, abs(p.z)-h.y );
}

// Function 409
vec2 paBox( in vec2 p, in vec2 b, in float r )
{
    vec2 q = abs(p)-b;
    
    return vec2( 
        
        // u = distance along perimeter
        (3.0+msign(p.x))*(b.x+b.y+1.570796*r) + msign(p.y*p.x)*
        (b.y + ((q.y>0.0)?r*((q.x>0.0)?atan(q.y,q.x):1.570796)+max(-q.x,0.0):q.y)),
        
	    // v = distance to box
    	min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r );
}

// Function 410
float DistanceToQuadOrPlane(vec3 P, Object quad, bool isInfinitePlane)
{
	vec3 V = P - quad.pos;
	float vz = abs(dot(V, quad.quadNormal));
	if (!isInfinitePlane) {
		float ex = 1.0/length(quad.quadBasisX);
		float ey = 1.0/length(quad.quadBasisY);
		float vx = ex*max(0.0, abs(dot(V, quad.quadBasisX)) - 1.0);
		float vy = ey*max(0.0, abs(dot(V, quad.quadBasisY)) - 1.0);
		vz = length(vec3(vx, vy, vz));
	}
	return vz;
}

// Function 411
float  plane(vec3 p, vec3 origin, vec3 normal){ 
   return dot(p - origin,normal);   
}

// Function 412
bool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in Box box ) 
{
    vec3 n = ird*(box.cen-ro);
    vec3 k = abs(ird)*box.rad;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    return tN<tF && tF>0.0;
}

// Function 413
vec4 blur_box(sampler2D tex, vec2 texel, vec2 uv, vec2 rect)
{
    vec4 total = vec4(0);
    
    float dist = inversesqrt(SAMPLES);
    for(float i = -0.5; i<=0.5; i+=dist)
    for(float j = -0.5; j<=0.5; j+=dist)
    {
        vec2 coord = uv+vec2(i,j)*rect*texel;
        total += texture(tex,coord);
    }
    
    return total * dist * dist;
}

// Function 414
vec3 randomSphereDir( vec2 rnd )
{
    float s = rnd.x*PI*2.;
    float t = rnd.y*2.-1.;
    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 415
float fTorus(vec4 p4) {
    float d1 = length(p4.xy) / length(p4.zw) - 1.;
    float d2 = length(p4.zw) / length(p4.xy) - 1.;
    float d = d1 < 0. ? -d1 : d2;
    d /= PI;
    return d;
}

// Function 416
float iSphere4( in vec3 ro, in vec3 rd, in float ra )
{
    // -----------------------------
    // solve quartic equation
    // -----------------------------
    
    float r2 = ra*ra;
    
    vec3 d2 = rd*rd; vec3 d3 = d2*rd;
    vec3 o2 = ro*ro; vec3 o3 = o2*ro;

    float ka = 1.0/dot(d2,d2);

    float k3 = ka* dot(ro,d3);
    float k2 = ka* dot(o2,d2);
    float k1 = ka* dot(o3,rd);
    float k0 = ka*(dot(o2,o2) - r2*r2);

    // -----------------------------
    // solve cubic
    // -----------------------------

    float c2 = k2 - k3*k3;
    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;
    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;

    float p = c2*c2 + c0/3.0;
    float q = c2*c2*c2 - c2*c0 + c1*c1;
    
    float h = q*q - p*p*p;

    // -----------------------------
    // skip the case of three real solutions for the cubic, which involves four
    // complex solutions for the quartic, since we know this objcet is convex
    // -----------------------------
    if( h<0.0 ) return -1.0;
    
    // one real solution, two complex (conjugated)
    float sh = sqrt(h);

    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot
    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot
    vec2  w = vec2( s+t,s-t );

    // -----------------------------
    // the quartic will have two real solutions and two complex solutions.
    // we only want the real ones
    // -----------------------------

#if 1
    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;
    float r = length(v);
    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;
#else
    float r = sqrt( c2*c2 + w.x*w.x + 2.0*w.x*c2 - c0 );
    return -sqrt( 3.0*w.y*w.y/(4.0*r+w.x*2.0+c2*8.0)) - c1/r - k3;
#endif    
}

// Function 417
vec2 lineIntersectSphere(in vec3 o, in vec3 t, float r)
{float b=dot(o,t),d=b*b+r*r-dot(o,o)
;if(d<.0)return vec2(MAX,-MAX)//code for no intersection?
;return vec2(-1,1)*sqrt(d)-b;}

// Function 418
float PrTorusDf (vec3 p, float ri, float rc)
{
  return length (vec2 (length (p.xy) - rc, p.z)) - ri;
}

// Function 419
float Cylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 420
bool Sphere_hit(Sphere sphere, Ray ray, float t_min, float t_max, out IntersectInfo rec)
{
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;

    float discriminant = b * b - a * c;

    if (discriminant > 0.0f)
    {
        float temp = (-b - sqrt(discriminant)) / a;

        if (temp < t_max && temp > t_min)
        {
            rec.t                = temp;
            rec.p                = ray.origin + rec.t * ray.direction;
            rec.normal           = (rec.p - sphere.center) / sphere.radius;
            rec.materialType     = sphere.materialType;
            rec.albedo           = sphere.albedo;
            rec.fuzz             = sphere.fuzz;
            rec.refractionIndex  = sphere.refractionIndex;

            return true;
        }


        temp = (-b + sqrt(discriminant)) / a;

        if (temp < t_max && temp > t_min)
        {
            rec.t                = temp;
            rec.p                = ray.origin + rec.t * ray.direction;
            rec.normal           = (rec.p - sphere.center) / sphere.radius;
            rec.materialType     = sphere.materialType;
            rec.albedo           = sphere.albedo;
            rec.fuzz             = sphere.fuzz;
            rec.refractionIndex  = sphere.refractionIndex;

            return true;
        }
    }

    return false;
}

// Function 421
float sdbox( vec3 p, vec3 s ) {
  vec3 d = abs( p ) - s;
  return min( max( max( d.x, d.y ), d.z ), 0.0 ) + length( max( d, vec3( 0 ) ) );
}

// Function 422
float plane(vec2 p, vec2 n, float l) {
    return dot(p,n)-l;
}

// Function 423
vec4 sphere_sdf(vec3 query_point, float sphere_radius) {
    float l = length(query_point);
    float df = l - sphere_radius;
    
    return vec4(
        query_point / l,
        df
    );
}

// Function 424
float box(vec3 p, vec3 b)
{
    vec3 d=abs(p)-b;
    return length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); 
}

// Function 425
float planeSDF(vec3 p, vec4 plane) { return dot(p, plane.xyz) + plane.w; }

// Function 426
float isec_plane(in ray_t ray, in plane_t plane) {
 	float ND = -dot(plane.normal, ray.dir);
 	if (ND < ISEC_EPSILON) return INFINITY;
 	float t = (dot(plane.normal, ray.origin) + plane.offset) / ND;
 	if (t < 0.) return INFINITY;
 	return t;
}

// Function 427
float sphere( vec3 p,float r )
{
    return length(p)-r;
}

// Function 428
float getSphereMappedTexture(in vec3 pointOnSphere) {
    /* Test to determine which face we are drawing on.
     * Opposing faces are taken care of by the absolute
     * value, leaving us only three tests to perform.
     */
    vec2 st = abs(
        insideBounds(sphereToCube(pointOnSphere    )) +
        insideBounds(sphereToCube(pointOnSphere.zyx)) +
        insideBounds(sphereToCube(pointOnSphere.xzy)));
    return textureFunc(st);
}

// Function 429
float sBox(in vec2 p, in vec2 b){
  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 430
vec3 sampleHemisphereCosWeighted(in vec2 xi) {
#ifdef CONCENTRIC_DISK
    vec2 xy = concentricSampleDisk(xi);
    float r2 = xy.x*xy.x + xy.y*xy.y;
    return vec3(xy, sqrt(max(0.0, 1.0 - r2)));
#else
    float theta = acos(sqrt(1.0-xi.x));
    float phi = TWO_PI * xi.y;
    return sphericalToCartesian( 1.0, phi, theta );
#endif
}

// Function 431
RayHit rayVsSphere(in Ray ray, in Sphere sphere){
    RayHit defaultResult = RayHit(fogColor, -ray.dir, maxDistance);
    
    //pythogorean solution
    vec4 sphereDiff = sphere.pos - ray.start;
    float sphereDist = dot(sphereDiff, ray.dir);
    float spherePerpDist = sqrt(dot(sphereDiff, sphereDiff) - sphereDist * sphereDist);
    
    float dt2 = sphere.radius * sphere.radius - spherePerpDist * spherePerpDist;
    float dt = sqrt(dt2);
    
    float t = sphereDist - dt;//no need for t2, as we haven no refractions
    vec4 hitPos = ray.start + ray.dir * t;
    vec4 sphereNormal = clamp(normalize(hitPos - sphere.pos), -1.0, 1.0);
    RayHit sphereHit = RayHit(
        sphere.color,
        //sphereNormal.xyz * 0.5 + 0.5,
        //clamp(sphereNormal.xyz * 0.5 + 0.5, 0.0, 1.0),
        sphereNormal,
        t
    );
    //sphereHit.color = sphereHit.n.xyz * 0.5 + 0.5;
    return mixRayHits(
        defaultResult, sphereHit, float((spherePerpDist < sphere.radius) && (t > 0.0))
    );
    
    
    //return result;
}

// Function 432
vec3 randomSphereDirection() {
    lowp vec2 r = hash2()*6.2831;
	lowp vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dr;
}

// Function 433
vec3 sphereNormal(vec3 sc, float sr, vec3 p) {
    return normalize(p - sc);
}

// Function 434
void drawPlane(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 planeNorm;
    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    
    
    if(planeT < cur_ctxt.t)
    {
        cur_ctxt.t = planeT;

        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; 
        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;
        cur_ctxt.n = planeNorm;
        
        cur_ctxt.alpha = 0.0;
        cur_ctxt.materialType = DIFFUSE;
        /*if(randVals.y < 0.5)
        {
            cur_ctxt.materialType = REFLECTION;
        }*/
    }
}

// Function 435
float SphereRadius(in float t)
{
    t = t*.003+.01;
	return min(t,256.0/iResolution.x);
}

// Function 436
vec3 nPlane( in vec3 ro, in vec4 obj ) {
    return obj.xyz;
}

// Function 437
Hit planeSdf(vec3 p) {
    const float PLANE_Y =/ 0.0;
    Hit hit;
    hit.dist = p.y - PLANE_Y;
    hit.color = vec3(0.55);
    return hit;
}

// Function 438
float lBox(vec2 p, vec2 a, vec2 b, float ew){
    
    float ang = atan(b.y - a.y, b.x - a.x);
    p = rot2(ang)*(p - mix(a, b, .5));
    
   vec2 l = vec2(length(b - a), ew);
   return sBox(p, (l + ew)/2.);
    
}

// Function 439
float sdSphere ( in float3 O, in float R ) { return length(O) - R; }

// Function 440
bool sphere2D( in vec3 ro, in vec3 rd, in vec3 sphereP, in float radius, out vec3 resN )
{
    vec3 deltaP = sphereP - ro;
    vec3 sphereDir = normalize( deltaP );
    float sphereDot = dot( rd, sphereDir );
    float dotThreshold = 1.0-(0.0002*radius);
    if ( sphereDot > dotThreshold )
    {
        vec3 p = ro+rd*length( deltaP );
        vec3 deltaSurfP = p-sphereP;
        float surfDist = length( deltaSurfP );
        vec3 surfDir = normalize( deltaSurfP );
        resN = vec3(0.0);
        resN.x = dot( surfDir, vec3(1.0, 0.0, 0.0) )*0.5+0.5;
        resN.y = dot( surfDir, vec3(0.0, 1.0, 0.0) )*0.5+0.5;
      	float smoothFront = sin( surfDist/(radius) );
        resN = (resN*smoothFront)+(vec3(0.0, 0.0, -1.0)*(1.0-smoothFront));
        resN = normalize( resN );
        return true;
    }
    return false;
}

// Function 441
void mandelbox(inout vec3 p, float bi, float ic, float sc, vec2 tr)
{
    boxfold(p, bi);
    if (acos(p.z)<ic) inversion(p, ic);
    scale(p, sc);
    trans(p, tr);
}

// Function 442
float torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)
{
    //|d| = 1
    
    //a^2 = c^2 - b^2
    //a^2 = c^2 - (b/c * c)^2
    //a^2 = c^2 - (cos() * c)^2
    
    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));
}

// Function 443
vec4 createSphere(vec3 c, float r, float phi, float teta){
	float x,y,z;
	x = c.x + r*sin(phi)*cos(teta);
	y = c.y + r*sin(phi)*sin(teta);
	z = c.z + r*cos(phi);
    return vec4(x,y,z,r);
    
}

// Function 444
bool isinbox(vec2 a, vec2 b, float size) {
    return all(greaterThan(a, b))&&all(lessThan(a,b+size));
}

// Function 445
float SphereDistance(vec3 point, vec3 center, float radius){
  point.z = modA(point.z);point.x = modA(point.x);
  return fSphere(point-center,radius);}

// Function 446
bool sameHemisphere(in vec3 a, in vec3 b){ return (a.z*b.z>0.0); }

// Function 447
vec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in Box box, out vec3 nor ) 
{
    vec3 n = ird*(box.cen-ro);
    vec3 k = abs(ird)*box.rad;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

	return vec2( tN, tF );
}

// Function 448
vec2 sdCylinder( in vec3 p )
{
    return vec2( length(p.xz), (p.y+50.0)/100.0 );
}

// Function 449
float sBox(vec2 p, vec2 b){ return length(max(abs(p) - b, 0.)); }

// Function 450
SSphere GetSphere2()
{
	return SSphere
	(
		3,						//id
		vec3(sin(iTime*1.3),sin(3.14 + iTime * 1.4)*0.25,cos(iTime*1.3)),	//center
		0.15,					//radius
		SMaterial
		(
			vec3(0.0,1.0,1.0),	//diffuse color
			3.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 451
float box(vec3 p, vec3 s){
  vec3 q = abs(p)-s;
  return max(q.x , max(q.z, q.y));
}

// Function 452
float sphere(vec3 pos)
{
	return length(pos)-1.0;   
}

// Function 453
float box(vec3 pos, vec3 dims)
{
	pos = abs(pos) - dims;
	return max(max(pos.x,pos.y),pos.z);
}

// Function 454
float fBox2(vec2 p, vec2 b) {
	vec2 d = abs(p) - b;
	return length(max(d, vec2(0))) + vmax2(min(d, vec2(0)));
}

// Function 455
float boxSDF(vec3 p, vec3 size, float r) {
    vec3 d = abs(p) - (size / 2.0) + r;
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance - r;
}

// Function 456
float Box(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
 	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 457
vec2 isphere(in vec3 ro, in vec3 rd, in float r ) {
  // sphere centered at the origin, with size rd
  float b = dot(ro,rd);
  float c = dot(ro,ro) - r*r;
  float h = b*b - c;

  if( h<0.0 ) return vec2(-1.0);  
  h = sqrt( h );  
  return -b + vec2(-h,h);
}

// Function 458
float sdPlane( vec3 p, vec3 n, float h )
{
  return dot(p,n) + h;
}

// Function 459
float noised_caustics_improveXYPlanes(in vec3 x)
{
    mat3 orthonormalMap = mat3(
        0.788675134594813, -0.211324865405187, -0.577350269189626,
        -0.211324865405187, 0.788675134594813, -0.577350269189626,
        0.577350269189626, 0.577350269189626, 0.577350269189626);
    x = x * orthonormalMap;
    
    vec4 result = noised(x);
    float value = noised(x - 0.125 * result.yzw).x;
    
    return value;
}

// Function 460
bool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)
{
    float dist = -1.0f;
    float denom = dot(plane.xyz, rayDir);
    if (abs(denom) > 0.001f)
    {
        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;
    
        if (dist > c_minimumRayHitTime && dist < info.dist)
        {
            info.hitAnObject = true;
            info.rayMarchedObject = false;
            info.dist = dist;        
            info.normal = plane.xyz;
            info.material = material;
            return true;
        }
    }
    return false;
}

// Function 461
float sdDuoCylinder( vec4 p, vec2 r1r2) {
                  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;
                   return min(max(d.x,d.y),0.) + length(max(d,0.));
                }

// Function 462
float sdHalfBox( vec3 p, vec3 b, float cutRot )
{    
	float boxBase = udRoundBox( p, b, 0.01 );
    vec3 cp = p * rotZ( cutRot );
        
    return max( cp.x, boxBase );
}

// Function 463
void PlanePM (float t, float vu)
{
  float tInterp = 100.;
  float dt = 2.;
  flPos = TrackPath (t);
  vec3 fpF = TrackPath (t + dt);
  vec3 fpB = TrackPath (t - dt);
  vec3 vel = (fpF - fpB) / (2. * dt);
  float vy = vel.y;
  vel.y = 0.;
  vec3 acc = (fpF - 2. * flPos + fpB) / (dt * dt);
  acc.y = 0.;
  vec3 va = cross (acc, vel) / length (vel);
  float m1, m2;
  if (vu == 0.) { m1 = 1.;  m2 = 25.; }
  else { m1 = 0.2;  m2 = 10.; }
  vel.y = vy;
  vec3 ort = vec3 (- m1 * asin (vel.y / length (vel)),
     atan (vel.z, vel.x) - 0.5 * pi, m2 * length (va) * sign (va.y));
  if (vu > 0.) { ort.xz *= -1.;  ort.y += pi; }
  vec3 cr = cos (ort);
  vec3 sr = sin (ort);
  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *
     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *
     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);
  float tDisc = floor ((t) / tInterp) * tInterp;
  float s = (t - tDisc) / tInterp;
  flPos.y = (1. - s) * GrndHt (TrackPath (tDisc).xz, 0) +
     s * GrndHt (TrackPath (tDisc + tInterp).xz, 0) + 7.;
}

// Function 464
float sdCylinder(vec3 p, vec3 a, vec3 b, float r)
{
    vec3  ba = b - a;
    vec3  pa = p - a;
    float baba = dot(ba,ba);
    float paba = dot(pa,ba);
    float x = length(pa*baba-ba*paba) - r*baba;
    float y = abs(paba-baba*0.5)-baba*0.5;
    float x2 = x*x;
    float y2 = y*y*baba;
    
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
    
    return sign(d)*sqrt(abs(d))/baba;
}

// Function 465
bool intersectSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r) {
    ro -= c;
	float b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;
	return (d>0. && -sqrt(d)-b > 0.);
}

// Function 466
bool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 467
void debugPlane(inout vec3 color, vec3 rayOrigin, vec3 rayDir, float dist)
{
  vec3 up = vec3(0.0, 1.0, 0.0);
  float t = trPlane(rayOrigin, rayDir, vec4(up, 0.0));  

  if(t > 0.0 && (t < dist || dist == -1.0))
  {
    vec3 pos = rayOrigin + rayDir * t;
    float d = sdf(pos);

    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);
	  col *= 1.0 - exp(-2.0 * abs(d));
	  col *= 0.8 + 0.2 * cos(20.0 * d);
	  col = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 0.15, abs(d)) );
    color = col;
  }
}

// Function 468
vec3 randomHemisphereDirection( const vec3 n, inout float seed ) {
	vec3 dr = randomSphereDirection(seed);
	return dot(dr,n) * dr;
}

// Function 469
float sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb) {
  float rba  = rb-ra,
     baba = dot(b-a,b-a),
     papa = dot(p-a,p-a),
     paba = dot(p-a,b-a)/baba,
     x = sqrt( papa - paba*paba*baba ),
     cax = max(-0.1,x-((paba<0.4)?ra:rb)),
     cay = abs(paba-0.4)-0.4,
     k = rba*rba + baba,
     f = clamp( (rba * (x - ra) + paba * baba) / k, -0.1, 0.9 ),
     cbx = x - ra - f * rba,
     cby = paba - f,
     s = (cbx < -0.1 && cay < -0.1) ? -0.9 : 0.9;
    return s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) );
}

// Function 470
float sdBox( vec3 p, vec3 b ) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 471
d222 fBoxCheap(c2 p,v2 s){
 ;return maxdm(subdabsd(p,s));}

// Function 472
void get_bbox(int b, int e, ivec3& bbox_min, ivec3& bbox_max) const {
	get_facet_bbox(triangle(b), bbox_min, bbox_max);
	for(int i=b+1; i<e; ++i) {
	    ivec3 cur_bbox_min, cur_bbox_max;
	    get_facet_bbox(triangle(i), cur_bbox_min, cur_bbox_max);
	    bbox_min = min(bbox_min, cur_bbox_min); bbox_max = max(bbox_max, cur_bbox_max);
	}
    }

// Function 473
float box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 474
float fBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// Function 475
float cylinder_intersection(
    in vec3 origin,
    in vec3 ray,
    in Cylinder cylinder,
    out vec3 position,
    out vec3 normal
) {
    mat3 mat = create_matrix(cylinder.direction);
    if (abs(det(mat)) < 1.0e-3) {
        return -1.0;
    }
    float res = regular_cylinder_intersection(
        solve(mat, origin - cylinder.origin),
        solve(mat, ray),
        cylinder.radius,
        cylinder.height,
        position,
        normal
    );
    position = mat * position + cylinder.origin;
    normal = mat * normal;
    return res;
}

// Function 476
float sphere(vec3 rp, vec3 c, float r)
{
	return distance(rp,c)-r;
}

// Function 477
float cylinderZ(vec4 ray,vec3 u, float radius, float height
){maxGISize = max(maxGISize,height*radius*ray.w)
 ;return ray.w*(max(length(ray.xy-u.xy)
 -radius, abs(ray.z-u.z)-height));}

// Function 478
bool intersects_sphere( vec3 ray_dir, vec3 origin, vec3 sphere, float sphere_radius2 ) {
   // intersect with sphere 
    vec3 origToSphere = sphere - origin;
    float tCA = dot( origToSphere, ray_dir);
    if( tCA < 0.0 ) {
        // ray center is towards back of ray. cant intsesect
        return false;
    } else 
    {
        float dd = length(origToSphere);
        float distToMidpoint2 = dd*dd-tCA*tCA;
        if( distToMidpoint2 > sphere_radius2 ) {
            return false;
        } 
        else {
            return true;
        }
    }
}

// Function 479
v0 box (v2 u, v2 s){return mav(abs(u)-s);}

// Function 480
vec3 getNextBox(in vec3 p, in vec3 v, in vec3 box){
    vec3 d = sign(v);
	vec3 dt = ((box+d*.5)*boxDim-p)/v;
    float dmin = min(min(dt.x,dt.y),dt.z);
    d *= step(dt, vec3(dmin));
    return box+d;
}

// Function 481
bool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 482
vec2 sdInsideBox(vec3 p)
{
    vec2 b1 = vec2(sdBox(p, vec3(0.9)), MAT_INSIDE);
    p = abs(p) - 0.47;
    vec2 b2 = vec2(sdBox(p, vec3(.45)), MAT_OUTSIDE);
    return opU(b1, b2);
}

// Function 483
void traceSphere( in vec4 pos, in vec4 dir, float radius, vec4 colour, inout float setDist,
                  inout vec4 setColour, inout vec4 setNormal)
{
    pos /= radius;
    
    float dirDot = -dot(dir, pos);
    if (dirDot < 0.)
		return;
    
    vec4  inPos = pos + dir * dirDot;
    float inner = length(inPos);
    
    if (inner > 1.)
        return;
    
    vec4  hit   = inPos - dir * sqrt(1. - inner * inner);
    
    float dist = length(pos - hit) * radius;
    if (dist >= setDist)
        return;
    
    setColour = colour;
    setDist   = dist;
    setNormal = normalize(hit);
}

// Function 484
float sdBox( vec3 p, vec3 b )
{
   vec3 d = abs(p) - b;
   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));
}

// Function 485
bool boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad,
                 out vec2 outT, out vec3 outNor, out vec2 outST, out int outFaceID ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 s = vec3((rdd.x<0.0)?1.0:-1.0,
                  (rdd.y<0.0)?1.0:-1.0,
                  (rdd.z<0.0)?1.0:-1.0);

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 t1 = m*(-roo + s*rad);
    vec3 t2 = m*(-roo - s*rad);

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return false;

    // compute normal (in world space), face and UV
         if( t1.x>t1.y && t1.x>t1.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t1.x; outFaceID=(1+int(s.x))/2; /* 0, 1 */ } 
    else if( t1.y>t1.z   )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t1.y; outFaceID=(5+int(s.y))/2; /* 2, 3 */ }
    else                              { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t1.z; outFaceID=(9+int(s.z))/2; /* 4, 5 */ }

	outT = vec2(tN,tF);
    
    return true;
}

// Function 486
float sphere(vec3 position, float radius) {
    position = abs(position);
    float d = max(max(position.x - radius, position.y), position.z);
    d = min(d, max(max(position.x, position.y - radius), position.z));
    d = min(d, max(max(position.x, position.y), position.z - radius));
    {
        float b = dot(vec2(1.0), position.yz);
        float c = dot(position.yz, position.yz) - (radius * radius);
        float discriminant = b * b - 2.0 * c;
        if (discriminant >= 0.0) {
            float t = (b - sqrt(discriminant)) / 2.0;
            d = min(d, max(t, position.x));
        }
    }
    {
        float b = dot(vec2(1.0), position.xz);
        float c = dot(position.xz, position.xz) - (radius * radius);
        float discriminant = b * b - 2.0 * c;
        if (discriminant >= 0.0) {
            float t = (b - sqrt(discriminant)) / 2.0;
            d = min(d, max(t, position.y));
       }
    }
    {
        float b = dot(vec2(1.0), position.xy);
        float c = dot(position.xy, position.xy) - (radius * radius);
        float discriminant = b * b - 2.0 * c;
        if (discriminant >= 0.0) {
            float t = (b - sqrt(discriminant)) / 2.0;
            d = min(d, max(t, position.z));
        }
    }
    float b = dot(vec3(1.0), position);
    float c = dot(position, position) - (radius * radius);
    float discriminant = b * b - 3.0 * c;
    if (discriminant >= 0.0) {
        float t = (b - sqrt(discriminant)) / 3.0;
        d = min(d, t);
    }
    
    return d;
}

// Function 487
float fCone(vec3 p, float radius, float height, vec3 direction) {
    p = reflect(p, normalize(mix(vec3(0,1,0), -direction, .5)));
    //p -= vec3(0,height,0);
    return fCone(p, radius, height);
}

// Function 488
float distSphere(vec3 p, float r)
{
	return length(p) - r;
}

// Function 489
vec3	sphere2xyz( float yaw, float pitch )
{
	return	vec3( sin( pitch ) * cos( yaw ),
				  cos( pitch ),
				  sin( pitch ) * sin( yaw ) );
}

// Function 490
float sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is
){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder
  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}

// Function 491
float sphereDist(vec3 p) {
    float sphere = length(p) - 1.;
	return sphere;
}

// Function 492
float sdPlane(vec3 p, vec4 n) {
  return dot(p,n.xyz) + n.w;
}

// Function 493
vec4 ColorizeSphereFace(int faceRow, int faceCol)
{
    vec4 colorize = vec4(0,0,0,1);
    if (faceCol == 0)
        colorize.r = 1.0;
    else if (faceCol == 1)
        colorize.g = 1.0;
    else // faceCol == 2
        colorize.b = 1.0;
    if (faceRow == 1)
        colorize.rgb = vec3(1) - colorize.rgb; // cyan,magenta,yellow
    colorize.rgb += (vec3(1) - colorize.rgb)*0.2; // whiten
    return colorize;
}

// Function 494
vec4 DebugPlanes(vec3 o,vec3 d,float t
){float c0=u5(sin(iTime*.1))*2.
 ;vec4 a=planeDebug(o,d,(c0*vec3(1,0,0)),t,x)*vec4(0,1,.5,1)
 ;vec4 b=planeDebug(o,d,(c0*vec3(0,1,0)),t,y)*vec4(.5,0,1,1)
 ;vec4 c=planeDebug(o,d,(c0*vec3(0,0,1)),t,z)*vec4(1,.5,0,1)
 ;return sat((a+b+c)*2.);}

// Function 495
Result sphereIntersect (in Ray ray, in vec3 p, in float r, in int id) {
    Result res = nullResult;

    // set up coefficients a, b and c
    float b = dot (2. * ray.rd, ray.ro - p);
    vec3 op = ray.ro - p;
    float c = dot (op, op) - r * r;
    float discriminant = b * b - 4. * c;
    if (discriminant < .0) return res;
    float d = sqrt (discriminant);

    // compute possible values for t
    float t1 = (-b + d) * .5;
    float t2 = (-b - d) * .5;

    if (t1 > .0 && t2 > .0) {
        if (t1 < t2) {
            vec3 i1 = ray.ro + t1 * ray.rd;
            float d1 = distance (i1, ray.ro);
            res.hit = true;
            res.point = i1;
            res.normal = normalize (i1 - p);
            res.dist = d1;
            res.id = id;
        } else {
            vec3 i2 = ray.ro + t2 * ray.rd;
            float d2 = distance (i2, ray.ro);
            res.hit = true;
            res.point = i2;
            res.normal = normalize (i2 - p);
            res.dist = d2;
            res.id = id;
        }
    }

    return res;
}

// Function 496
float sdCone(vec3 p, vec2 c)
{
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

// Function 497
vec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout int seed ) {
  	vec2 r = vec2(nextFloat(seed), nextFloat(seed));
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 498
vec4 findSeparatingPlane_planA()
{

    uint cia = pixelx/6u;
    uint cib = pixely/5u;
    
    if (cia>=CUBECOUNT) discard;
    if (cia<=cib) discard;
    
    
    float bestoffset=-1e30;
    vec3 bestplane;
    float bestplaneoffset;
    
//    for(uint m=0;m<2;m++)
//    for(uint k=0;k<30;k++)
    uint k = (pixelx%6u)+(pixely%5u)*6u;
    {
        vec3 sep;
        vec3 edgea = vec3( k%3u==0u?1.0:0.0, k%3u==1u?1.0:0.0, k%3u==2u?1.0:0.0);
        edgea = rotate(getCubeQuat(cia),edgea);
        vec3 edgeb = vec3( k/3u%3u==0u?1.0:0.0, k/3u%3u==1u?1.0:0.0, k/3u%3u==2u?1.0:0.0);
        edgeb = rotate(getCubeQuat(cib),edgeb);
        if (k%15u<9u)
        { 
            // edge crossings
            if (length(cross(edgea,edgeb))<0.001)
                sep = vec3(0.,0.,0.);  // parallel edges fail
            else
            	sep = normalize(cross(edgea,edgeb));
        }
        else
        {  // normals
            if (k<9u+3u)
            {
                sep = edgea;
            }
            else
            {
                sep =  vec3( k%3u==0u?1.0:0.0, k%3u==1u?1.0:0.0, k%3u==2u?1.0:0.0);
                sep = rotate(getCubeQuat(cib),sep);
            }
        }
        if (k>=15u) sep=-sep;
        
        if (cib==0u)
        {
            sep = vec3(0.,-1.,0.);
        }
        
        float minoffset = -1e30;
        for(uint j=0u;j<8u;j++)
        {
            vec3 v = getWCubeVert(cia,j);
            if (dot(v,sep)>minoffset)
            {
                minoffset = dot(v,sep);
            }
        }

        float maxoffset = 1e30;
        for(uint j=0u;j<8u;j++)
        {
            vec3 v = getWCubeVert(cib,j);
            if (dot(v,sep)<maxoffset)
            {
                maxoffset = dot(v,sep);
            }
        }
        float offset = -minoffset+maxoffset;
        
//        if (offset>bestoffset && offset!=0.0) // no improvement
        {
            bestoffset = offset;
            bestplaneoffset = (minoffset+maxoffset)*0.5;
            bestplane = sep;
        }
    }
    
    if (bestoffset>=0.0)
    {
        return vec4(0.,9999.0,0.,0.);
    }
    
    return vec4(-bestplane*(2.0-bestoffset),-bestplaneoffset);
}

// Function 499
float
cylinder_sd( in float r, in vec3 p )
{
    return length( p.xy ) - r;
}

// Function 500
float sphere(vec3 ro, vec3 rd, vec4 sph) {
    vec3 o = ro - sph.xyz;
    float b = dot(o, rd);
    float c = dot(o, o) - sph.w * sph.w;
    float h = b*b - c;
    if (h > 0.0)
        return - sqrt(h) - b;
    return -1.0;
}

// Function 501
float rayCastSphere( vec3 center, float radius, vec3 p, vec3 v )
{
	vec3 L = center - p;
    float tca = dot(L, v);
	
    if (tca < 0.0) 
	{
		return CAST_DISTANCE;
	}
	
	float radius2 = radius * radius;
    float d2 = dot(L, L) - tca * tca;
    if (d2 > radius2)
	{
		return CAST_DISTANCE;
	}
    float thc = sqrt(radius2 - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;
	
	return min( t0, t1 );
}

// Function 502
vec2 sdSphere( vec3 p,vec3 pos, float r ,int mat) {
    float d = length(p - pos) - r;
    return vec2(d,mat);
}

// Function 503
void getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {
	vec2 offset = grid + sphereOffset;
	center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}

// Function 504
float Sphere( vec3 p, float s )
{
  return length(p)-s;
}

// Function 505
float sdSphere( vec2 p, float s )
{
  return length(p)-s;
}

// Function 506
float RoundBox( vec3 p, vec3 b, float r )
{
	return length( max( abs( p ) - b, 0.0 ) ) - r;
}

// Function 507
float sdBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0)); }

// Function 508
bool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)
{
    float dist = -1.0f;
    float denom = dot(plane.xyz, rayDir);
    if (abs(denom) > 0.001f)
    {
        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;
    
        if (dist > c_minimumRayHitTime && dist < info.dist)
        {
            info.hitAnObject = true;
            info.objectPass = OBJECTPASS_RAYTRACE;
            info.dist = dist;        
            info.normal = plane.xyz;
            info.material = material;
            return true;
        }
    }
    return false;
}

// Function 509
float fCylinder(vec3 p, float r, float h) {
    float d = length(p.xz) - r;
    d = max(d, abs(p.y) - h);
    return d;
}

// Function 510
float fCylinderInf(vec3 p, float r) {
	return length(p.xz) - r;
}

// Function 511
float ifBox(Ray r, vec3 b) {
  vec2 v = hitAABB(r, AABB(-b,b));
  return (0.<=v.y&&v.x<=v.y)?v.x:NO_HIT_DIST;
}

// Function 512
float obj_box(vec3 p, vec3 center, vec3 size, float roundness){
    vec3 d = abs(p-center) - (size-roundness);
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;
}

// Function 513
float IntersectRayWithPlane(vec3 ro, vec3 rd, vec3 planePoint, vec3 planeNorm) {
 	float denom = dot(planeNorm, rd);
    if (denom > 1e-6) { 
        vec3 p0l0 = planePoint - ro; 
        float t = dot(p0l0, planeNorm) / denom; 
        return t; // distance from ro to plane
    }
    
    return -1.;
}

// Function 514
float fBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return length(ma(d,vec3(0)))+ma(min(d,vec3(0)));}

// Function 515
float sdSphere( vec2 p, float s )
{
  return length(p*iResolution.xy)/iResolution.x-s;
}

// Function 516
float sdSeaBox( vec3 p, vec4 n )
{
    float ns=getwaves(p.xz*0.1,iTime);
    p.y-=ns/1.0;
  	return dot(p,n.xyz) + n.w;
}

// Function 517
float sdBox( vec3 p, vec3 c, vec3 b )
{
  p = p - c;
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 518
float Torus(float x, float y, float z, float R, float r)
{
	return sqrt(sq(sqrt(sq(x)+sq(z))-R)+sq(y))-r;
}

// Function 519
bool isinbox(vec2 a,vec2 b,vec2 s){a-=b;s*=.5;return all(lessThan(abs(a-s),s));}

// Function 520
float sdCylinder6 (in vec3 p, in vec3 h)
{
  return max( length6(p.xz) - h.x, abs(p.y) - h.z );
}

// Function 521
float atmosphereDensity(vec3 x){
    float h = distance(x, planetPosition) - planetRadius;
    return exp(-h*atmosphereFalloff)*atmosphereBase;
}

// Function 522
bool cylinder(vec3 org, vec3 dir, out float near, out float far)
{
	// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5
	float a = dot(dir.xy, dir.xy);
	float b = dot(org.xy, dir.xy);
	float c = dot(org.xy, org.xy) - 0.25;

	float delta = b * b - a * c;
	if( delta < 0.0 )
		return false;

	// 2 roots
	float deltasqrt = sqrt(delta);
	float arcp = 1.0 / a;
	near = (-b - deltasqrt) * arcp;
	far = (-b + deltasqrt) * arcp;
	
	// order roots
	float temp = min(far, near);
	far = max(far, near);
	near = temp;

	float znear = org.z + near * dir.z;
	float zfar = org.z + far * dir.z;

	// top, bottom
	vec2 zcap = vec2(0.5, -0.5);
	vec2 cap = (zcap - org.z) / dir.z;

	if ( znear < zcap.y )
		near = cap.y;
	else if ( znear > zcap.x )
		near = cap.x;

	if ( zfar < zcap.y )
		far = cap.y;
	else if ( zfar > zcap.x )
		far = cap.x;
	
	return far > 0.0 && far > near;
}

// Function 523
float box(inout ray r){
	float d=max(max(abs(r.p.x),abs(r.p.y))-0.5,abs(r.p.z)-0.5);
	if(d<0.0){
		if(fract(length(r.p)*10.0+0.25)<0.5)r.c=vec4(1.0);
		else r.c=vec4(0.5);
		r.i=MAX_ITER_INTERNAL+1;
	}
	return d;
}

// Function 524
float sdCappedCylinder( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 525
float torus_sdf(in vec3 p) {
	vec2 to_centerline =
        vec2(abs(length(p.xz) - tor_rad1), p.y);
    return length(to_centerline) - tor_rad2;
}

// Function 526
float sphere( vec3 p, float r )
{
#ifdef TORUS_VER
	vec2 q = vec2(length(p.xy)-r*1.0,p.z);
	return length(q)-r * 0.25;	
#elif defined( BOX_VER )
	return length(max(abs(p)-vec3(r),0.0))-r*0.4;
#else
	return length( p ) - r;
#endif
}

// Function 527
float iBox( in vec3 roo, in vec3 rdd, in vec3 rad, out float tN, out float tF, out vec3 nN, out vec3 nF) 
{
	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	tN = max( max( t1.x, t1.y ), t1.z );
	tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) 
        return -1.;

	nN = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
	nF = -sign(rdd)*(1.-step(t2.yzx,t2.xyz))*(1.-step(t2.zxy,t2.xyz));

	return 1.;
}

// Function 528
vec4 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){
    float d = dot(po - ro, pd) / dot(rd, pd);
    return vec4(d * rd + ro, d);
}

// Function 529
float cylinder( vec3 p, vec2 s) {
    vec2 q = vec2(length(p.xz),p.y);
    return length(max(abs(q)-s,0.0));
}

// Function 530
bool planePlaneIntersection(const vec3 n1, float w1, const vec3 n2, float w2, out vec3 p, out vec3 n) {
    float d = n1.x * n2.y - n1.y * n2.x;
    if (abs(d) > 1e-5)
    {
        // this case should be handled by switching axes...
         p = vec3(w2*n1.y - w1*n2.y, w1*n2.x - w2*n1.x, 0.)/d;
    } else {
        d = n1.x * n2.z - n1.z * n2.x;
        p = vec3(w2*n1.z - w1*n2.z, 0., w1*n2.x - w2*n1.x)/d;
    }
    n = cross(n1, n2);
    if(length(n) == 0.0f) {
        return false;
    }
    n = normalize(n);
    return true;
}

// Function 531
float3 sphereTrace(float3 rayOrigin, float3 rayDir, out bool hit, out float displace)
{
	float3 pos = rayOrigin;
	hit = false;
	displace = 0.0;	
	float d;
	//float3 hitPos;
	float disp;
	for(int i=0; i<_MaxSteps; i++) {
		d = distanceFunc(pos, disp);
        	if (d < _DistThreshold) {
			hit = true;
			displace = disp;
			//hitPos = pos;
        		//break;	// early exit from loop doesn't work in ES?
        	}
		//d = max(d, _MinStep);
		pos += rayDir*d*_StepDistanceScale;
	}
	
	return pos;
	//return hitPos;
}

// Function 532
float distSquaredCylinder( vec3 p, vec3 d, float r)
{
	return max(length(max((abs(p.xz)-(d.xz-r)),0.0))-r,abs(p.y)-d.y);
}

// Function 533
float iPlane(in ray sceneRay, in vec4 plane) {
	return -(dot(sceneRay.origin, normalize(plane.xyz)) + plane.w) / dot(sceneRay.direction, plane.xyz);
}

// Function 534
float SDFSphere(vec3 point, float radius)
{
    return length(point) - radius;
}

// Function 535
float protoplanet(vec2 uv) {
    float lat = 180. * uv.y - 90.;
    float lon = 360. * uv.x;
    vec3 p = 1.5 * vec3(sin(lon*PI/180.) * cos(lat*PI/180.), sin(lat*PI/180.), cos(lon*PI/180.) * cos(lat*PI/180.));
    float x = 0.;
    for (float i = 0.; i < 5.; i++) {
        float c = craters(0.4 * pow(2.2, i) * p);
        float noise = 0.4 * exp(-3. * c) * FBM(10. * p);
        float w = clamp(3. * pow(0.4, i), 0., 1.);
		x += w * (c + noise);
	}
    return pow(x, 3.);
}

// Function 536
float boxSDF(vec3 samplePoint) {
    float boxDist = MAX_DIST;

    for(int i=0; i<numberOfPlanes; i++)
    {
        boxDist = min(boxDist, planeSDF(samplePoint, box[i]));
    }

    return boxDist;
}

// Function 537
vec3 sphere_from_gui(in vec2 p) {
    
    p -= inset_ctr;
    p *= inset_scl;
    
    float dpp = dot(p, p);
    
    if (dpp >= 1.) {
        return vec3(p/sqrt(dpp), 0);
    } else {    
        vec3 p3d = vec3(p, sqrt(1. - dot(p, p)));
        return ortho_proj*p3d;
    }
    
}

// Function 538
float d_conecomb( vec2 p, vec2 c )
{
    p.x += -0.005*sin(30.*p.x);
    p.x = -abs(p.x);

    p.x -= .15+.05*p.y;

    float d = 1e8;
    for (float i=0.25; i<.8; i+=.115)
    {
        vec2 pi = p;
        pi.y += i;
        d = min(d, d_cone(pi, c, .8*i+.5));
    }
    return d;
}

// Function 539
float sdSphere( vec3 p, vec4 o){
    float dist = length(o.xyz-p) - o.w;
    return dist;
}

// Function 540
vec2 boxMuller(vec2 uv){
    float r = sqrt(-2.0*log(uv.x));
    float th = 2.0*3.1415926*uv.y;
    return vec2(r*cos(th),r*sin(th));
}

// Function 541
float regular_cylinder_intersection(
    in vec3 origin,
    in vec3 ray,
    in float radius,
    in float height,
    out vec3 position,
    out vec3 normal
) {
    float res = regular_infinite_cylinder_intersection(
        origin,
        ray,
        radius,
        position,
        normal
    );
    if (position.z < 0.0) {
        position = origin - origin.z / ray.z * ray;
        res = radius * radius - dot(position.xy, position.xy);
    } else if (position.z > height) {
        position = origin + (height - origin.z) / ray.z * ray;
        res = radius * radius - dot(position.xy, position.xy);
    }
    return res;
}

// Function 542
float sdSphere( in vec3 p, in float r ) 
{
    return length(p)-r;
}

// Function 543
bool raySphereIntersect(vec3 rd, vec3 sphere, float radius, out vec2 hit
){hit=vec2(0)
 ;float b=dot(sphere, rd)
 ;float c=dot(sphere, sphere) - radius * radius
 ;float d=b*b-c
 ;//if (dot(rd, normalize(sphere)) > 1.0) return false
 ;if (d < 0.0)return false
 ;d=sqrt(d)
 ;hit=vec2(-b-d,d-b);return true;}

// Function 544
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5);
}

// Function 545
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

// Function 546
float getSdfWithPlane(vec3 p) {
  return min(getSdf(p), sdPlane(p, vec4(0,1,0,1)));
}

// Function 547
bool box(vec3 origin, vec3 dir, vec3 bmin, vec3 bsize, out vec2 bb) {
    vec3 tMin=(bmin-origin)*dir;
    vec3 tMax=(bmin+bsize-origin)*dir;
    vec3 t1=min(tMin,tMax);
    vec3 t2=max(tMin,tMax);
    bb=vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));
    return ((bb.x>0. && bb.x<bb.y) || (bb.x<0. && bb.y>0.));
}

// Function 548
float sdTorus( vec3 p, vec2 t ) {
	vec2 c = vec2(sin(iTime), cos(iTime)); // Rotate!!!
	p.yz = vec2(c.y*p.y - c.x*p.z, c.x*p.y + c.y*p.z);
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 549
float3 random_in_unit_sphere()
{	
    float phi = (rand()*2.0-1.0)*PI;
	float costheta = rand()*2.0-1.0;
	float u = rand();
    
	//float theta = acos( costheta );
    float sintheta = sqrt(1.0-costheta*costheta);
	float r = pow( u ,1.0/3.0);
    
    float x = r * sintheta * cos( phi );
	float y = r * sintheta * sin( phi );
	float z = r * costheta;
    
    return float3(x,y,z);
}

// Function 550
float sdfPlane(in vec3 pos, in vec3 n) {
    return dot(pos, n);
}

// Function 551
float planeIntersect( in vec3 ro, in vec3 rd, in vec4 p )
{
    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
}

// Function 552
float sdfPlane(in vec3 p, in vec3 n, in float d)
{
    return dot(p, n) + d;
}

// Function 553
float boxAppSurface(vec3 view ,vec3 axis, vec3 widths){
    vec3 newView= rotateVectorFromZenith(view,axis);
    return alignedBoxAppSurface(newView, widths);
}

// Function 554
vec3 SphereRand( vec2 rand )
{
    rand += .5;
    // use interference of 2 very large numbers, calibrated (by hand) to cover
    // lots of different directions very early on, and to fill in the gaps eventually
    float sina = rand.x*2. - 1.;
    float b = 6.283*rand.y;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

// Function 555
void getSphereOffset( const in vec2 grid, inout vec2 center ) {
	center = (hash22( grid ) - vec2(0.5) )*(GRIDSIZESMALL);
}

// Function 556
vec4 iRoundedCone( in vec3  ro, in vec3  rd, 
                   in vec3  pa, in vec3  pb, 
                   in float ra, in float rb )
{
    vec3  ba = pb - pa;
	vec3  oa = ro - pa;
	vec3  ob = ro - pb;
    float rr = ra - rb;
    float m0 = dot(ba,ba);
    float m1 = dot(ba,oa);
    float m2 = dot(ba,rd);
    float m3 = dot(rd,oa);
    float m5 = dot(oa,oa);
	float m6 = dot(ob,rd);
    float m7 = dot(ob,ob);
    
    float d2 = m0-rr*rr;
    
	float k2 = d2    - m2*m2;
    float k1 = d2*m3 - m1*m2 + m2*rr*ra;
    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;
    
	float h = k1*k1 - k0*k2;
	if(h < 0.0) return vec4(-1.0);
    float t = (-sqrt(h)-k1)/k2;
  //if( t<0.0 ) return vec4(-1.0);

    float y = m1 - ra*rr + t*m2;
    if( y>0.0 && y<d2 ) 
    {
        return vec4(t, normalize( d2*(oa + t*rd)-ba*y) );
    }

    // Caps. I feel this can be done with a single square root instead of two
    float h1 = m3*m3 - m5 + ra*ra;
    float h2 = m6*m6 - m7 + rb*rb;
    if( max(h1,h2)<0.0 ) return vec4(-1.0);
    
    vec4 r = vec4(1e20);
    if( h1>0.0 )
    {        
    	t = -m3 - sqrt( h1 );
        r = vec4( t, (oa+t*rd)/ra );
    }
	if( h2>0.0 )
    {
    	t = -m6 - sqrt( h2 );
        if( t<r.x )
        r = vec4( t, (ob+t*rd)/rb );
    }
    
    return r;
}

// Function 557
vec3 setBox(in vec3 p){
    return floor(p/boxDim + .5);
}

// Function 558
float sphereSDF (vec3 p, float r) {
  return length(p) - r;
}

// Function 559
float cylinderZ (in vec3 p, in float r) {
 	return length (p.xy) - r;
}

// Function 560
float sdBox( vec3 p, vec3 b )
{
   vec3 ah =  (normalize(p));
    ah = abs(sin(ah*15.0));
   float ahm = max(max(ah.x, ah.y), ah.z);
   //  ahm = sin(ahm);
    ahm = pow(ahm, 1.0);
   
  vec3 d = abs(p) - b - ahm*b;
  return (max(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)))*0.125;
}

// Function 561
float sdBox(vec3 p, vec3 b, vec3 ray_dir)
{
    vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 562
bool doBox( vec3 ro, vec3 rd, out float t ) {
    ro = rayToTexture(ro);
    vec3 b = vec3(0.0);
    bool res = box(ro, rd, b, 1.0 - b, t);
    t = (1.0/SCALE) * t;
    return res;
}

// Function 563
vec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta, float s_x)
{
	float phi = 2.0*PI*s_x;
	return MakeOrthoBasis(N)*SampleSpherical(sinTheta, cosTheta, phi);
}

// Function 564
float sphereDist(in Ray ray, in Sphere sphere) {
    return length(ray.origin - sphere.pos) - sphere.radius;
}

// Function 565
float get_fraction_of_sphere_not_occluded_by_sphere(
	in vec2 light_destination, in vec2 light_origin, in float light_radius, 
	in vec2 sphere_origin, in float sphere_radius
){
    const float EPSILON = 3e-8;
	// direction of light origin from destination
	vec2  light_direction  = normalize(light_origin-light_destination);
	float light_distance   = length(light_origin-light_destination);
	// direction of sphere origin from destination
	vec2  sphere_direction = normalize(sphere_origin-light_destination);
	float sphere_distance  = length(sphere_origin-light_destination);
	float cos_angular_separation = dot(light_direction, sphere_direction);
	// angular separation between light and sphere origins when viewed from destination
    if (light_distance < sphere_distance) return 1.0;
    if (cos_angular_separation <= 0.0) return 1.0;
    if (sphere_distance < sphere_radius) return 0.0;
	float angular_separation = acos(min(cos_angular_separation, 1.0-EPSILON));
	float angular_light_radius  = asin(min(light_radius/light_distance, 1.0-EPSILON));
	float angular_sphere_radius = asin(min(sphere_radius/sphere_distance, 1.0-EPSILON));
	// distance between light and sphere origins when viewed from destination, 
	// treating the two as circles on a 2d plane
	float angular_distance = angular_separation; //min(2.0 * tan(angular_separation / 2.0), 2.);
	float area = get_area_of_intersection_between_circle_and_circle(
		angular_light_radius, angular_sphere_radius, angular_distance
	);
	return 1.0 - area / (PI*angular_light_radius*angular_light_radius);
}

// Function 566
float plane(vec3 position, vec3 planeNormal, float planeDistance) {
    float d = dot(position, planeNormal) + planeDistance;
    return d / dot(planeNormal, sign(planeNormal));
}

// Function 567
vec2 sphereToPlane(vec3 p) {
    return 2. * p.xy / (1. - p.z);
}

// Function 568
float BoxC(vec3 p, vec3 b) {
    vec3 d=abs(p)-b;
    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 569
bool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {
    vec3 inv_rd = 1.0 / rd;
    vec3 n = inv_rd*(ro);
    vec3 k = abs(inv_rd)*BoxRadius;
    vec3 t1 = -n - k, t2 = -n + k;
    tn = max(max(t1.x, t1.y), t1.z);
    tf = min(min(t2.x, t2.y), t2.z);
    if (tn > tf) return false;
    return true;
}

// Function 570
vec3 getHemisphereUniformSample(vec3 n) {
    float cosTheta = getRandom();
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    
    float phi = 2. * M_PI * getRandom();
    
    // Spherical to cartesian
    vec3 t = normalize(cross(n.yzx, n));
    vec3 b = cross(n, t);
    
	return (t * cos(phi) + b * sin(phi)) * sinTheta + n * cosTheta;
}

// Function 571
DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}

// Function 572
float gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )
{
    const float N = 10.0;
    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;
    vec2 a = p + 0.5*w;
    vec2 b = p - 0.5*w;           
    vec2 i = (floor(a)+min(fract(a)*N,1.0)-
              floor(b)-min(fract(b)*N,1.0))/(N*w);
    return (1.0-i.x)*(1.0-i.y);
}

// Function 573
float board_box(vec2 p, vec2 bpp, float bsz, int midg) {
    float d = 0.;
    p += bpp;
    if (any(lessThanEqual(p, vec2(0.))) || any(greaterThanEqual(p, bsz * vec2(msize - ivec2(0, 2))))) return d;
    int mid = int(floor((p.y) / bsz) * float(msize.x) + floor((p.x) / bsz));
    p = mod(p, bsz) - bsz / 2.;
    d = block(p, 25.);
    float mv = 1.;
    if (d > 0.)if (maptmp(mid, midg) == 0)mv = 0.05;
    d *= mv;
    return d;
}

// Function 574
float plane(vec3 p,vec3 po,vec3 n){
    n=normalize(n);
    vec3 dp=po-p;
    return dot(dp,n);
}

// Function 575
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	vec2 r = rand2();
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 576
float dist_box( vec3 pos, vec3 size ) {
    
	return length( max( abs( pos ) - size, 0.0 ) );
}

// Function 577
float sdSphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 578
float iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, 
            in vec3 boxSize ) {
    vec3 m = sign(rd)/max(abs(rd), 1e-8);
    vec3 n = m*ro;
    vec3 k = abs(m)*boxSize;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if (tN > tF || tF <= 0.) {
        return MAX_DIST;
    } else {
        if (tN >= distBound.x && tN <= distBound.y) {
        	normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
            return tN;
        } else if (tF >= distBound.x && tF <= distBound.y) { 
        	normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
            return tF;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 579
float plane(vec3 pos, vec3 nrm, float dist){
    return max(-sdPlane(pos, nrm, -dist + CUTOFF_PLANES_THICKNESS),
               -sdPlane(pos, nrm * -1., dist + CUTOFF_PLANES_THICKNESS));
}

// Function 580
bool cylinder2( in vec4 sph, in vec3 ro, in vec3 rd, in float tmin )
{
    vec3  d = ro - sph.xyz;
    float a = dot( rd.xz, rd.xz );
    float b = dot( rd.xz, d.xz );
    float c = dot( d.xz, d.xz ) - sph.w*sph.w;
    float t = b*b - a*c;
    bool r = false;
    if( t>0.0 )
    {
        t = -(b+sqrt(t));
        r = (t>0.0) && (t<(tmin*a));
    }
    return r;
}

// Function 581
vec4 box_fog(vec3 p,vec3 b,float k
){vec3 refl=normalize(vec3(0.4,0.6,0.9))
 ;float sc=1.0
 ;for(int i=0;i < 6;i++
 ){refl.xy=rot(1.6)*refl.xy
  ;p-=2.*max(dot(refl,p),0.)*refl
  ;refl.yz=rot(2.1)*refl.yz
  ;p+=0.015*sin(10.*dot(refl,p)+sin(p.x*p.y));}
 ;float sdf=sdBox(p,b)/sc
 ;return vec4(density()*(vec3(.3,.6,.9)*+(.5+.5*sin(40.*vec3(.392,.580,1.000)*p.x)))*smoothstep(k,-k,sdf),sdf);}

// Function 582
float sdBumpedSphere(vec3 p)
{
	float k = getSphereMappedTexture(p) * 0.25;		// 
	float d = sdSphere(p, 4.0);
    return d+k;
}

// Function 583
float sdTorusOriented(vec3 p, vec3 n, vec2 t){
   float plane_dist = (dot(p,n)); //can skip abs() in this case
   return length( vec2(length(cross(p,n))-t.x,plane_dist) )-t.y;     
}

// Function 584
vec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831*rv2.x); 
	float ry = ra*sin(6.2831*rv2.x);
	float rz = sqrt( 1.0-rv2.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );

    return normalize( rr );
}

// Function 585
float spheresSDF(vec3 samplePoint) {
    float spheresDist = MAX_DIST;

    for(int i=0; i<numberOfSpheres-1; i++)
    {
        spheresDist = min(spheresDist, sphereSDF(samplePoint, spheres[i]));
    }
    spheresDist = min(spheresDist, oceanSDF(samplePoint, spheres[numberOfSpheres-1]));

    return spheresDist;
}

// Function 586
float rounded_cylinder_sdf( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)- 2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 587
vec3 skybox(vec3 nvDir) {
    return ( mix(0.25, 0.75, smoothstep(-0.2,0.2, nvDir.y)) )*vec3(0.7, 0.8, 1.0);
}

// Function 588
float distCylinder( vec3 pos, vec3 properties )
{
	pos.xz += sin(pos.zx)*.25;
	pos.xz = mod(pos.xz,TREE_REP.xz);
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	return length(pos.xz-properties.xy)-properties.z;
}

// Function 589
float sdCubicalCylinder(vec4 p, vec3 rh1h2) {
                	vec3 d = abs(vec3(length(p.xz), p.y, p.w)) - rh1h2;
                	 return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));
                }

// Function 590
float sdSphere( vec3 p, float r) {
 	return length(p) -r;   
}

// Function 591
float box(vec3 ray, vec3 pos, vec3 size)
{
    ray = abs(ray-pos) - size;
    return max(max(ray.x,ray.y),ray.z);
}

// Function 592
vec3 PlaneMaterial(Intersection i)
{
	float d = 0.0;
	d = mod(floor(i.p.x)+floor(i.p.z),2.0);
	return vec3(d,d,d)*0.8;
}

// Function 593
float
plane_sd( in vec3 p )
{
    return abs( p.z );
}

// Function 594
float box(vec3 org, vec3 dir, vec3 size)
{
	float far;
	return box(org, dir, size, far);
}

// Function 595
float sdPlane(vec3 p, float h)
{
	return p.y - h;
}

// Function 596
float AirplaneSDF( vec2 p, vec2 airplanePos, vec2 airplaneDir, float airplaneScale )
{    
	p -= airplanePos;
    airplaneDir *= airplaneScale;
    p = vec2( dot( p, vec2( airplaneDir.y, -airplaneDir.x ) ), dot( p, airplaneDir ) );
    
    float body = Rectangle( p + vec2( 0.0, -40.0 ), vec2( 6.0, 10.0 ) );
	body = Union( body, Ellipsoid( p + vec2( 0.0, -70.0 ), vec2( 6.0, 25.0 ) ) );
    body = Union( body, Ellipsoid( p + vec2( 0.0, -20.0 ), vec2( 6.0, 25.0 ) ) );
    
    vec2 t = p;
    t.x = abs( t.x );
	t += vec2( -20.0, -45.0 );
    float engine = Line( t, 15.0, 5.0 );
    t += vec2( -15.0, 10.0 );
    engine = Union( engine, Line( t, 15.0, 5.0 ) );
    
    t = p;
    t.x = abs( t.x );
    t.y -= 0.0;
    float wing = dot( t, normalize( vec2( 0.1, 0.12 ) ) ) - 55.0;
    wing = Substract( wing, dot( t, normalize( vec2( 0.1, 0.2 ) ) ) - 42.0 );
	wing = Substract( wing, -t.x + 50.0 );
    
    t = p;
    t.x = abs( t.x );
    t.y += 44.0;    
    float tail = dot( t + vec2( 0.0, 6.0 ), normalize( vec2( 0.1, 0.12 ) ) ) - 50.0;
    tail = Substract( tail, dot( t, normalize( vec2( 0.1, 0.5 ) ) ) - 40.0 );
	tail = Substract( tail, -t.x + 20.0 );
    
    float ret = Union( Union( Union( body, engine ), wing ), tail );
    return ret;
}

// Function 597
float distSquaredCylinder( vec3 p, vec3 d, float r)
{
	return max(length(max((abs(p.xz)-d.xz),0.0))-r,abs(p.y)-d.y);
}

// Function 598
vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	
	float d = b * b - c;
	if ( d < 0.0 ) {
		return vec2( MAX, -MAX );
	}
	d = sqrt( d );
	
	return vec2( -b - d, -b + d );
}

// Function 599
float sBox(in vec2 p, in vec2 b){
    
  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 600
float sphereSDF(vec3 p) {
    return length(p) - sphereSize ;
}

// Function 601
bool isinbox(vec2 a,vec2 b,float s){a-=b;return(a<0.)||(a>s);}

// Function 602
vec3 sphereNRM(vec3 p)
{
    return normalize(p);
}

// Function 603
bool closestSpherePoly(vec3 cSphere, float rSphere, vec3 poly[POLY_SZ], float ePoly, out vec3 out0, out vec3 out1) {
    out0 = cSphere; out1 = closestPtPoly(cSphere, poly);
    return removeThickness(rSphere, ePoly, out0, out1);
}

// Function 604
float sdBox( in vec2 p, in vec2 b ) 
{
    vec2 q = abs(p) - b;
    return min(max(q.x,q.y),0.0) + length(max(q,0.0));
}

// Function 605
vec3 normalforCylinder(vec3 hit,Cylinder cylinder)
{
    vec3 nor;
	nor.xz = hit.xz - cylinder.c.xz;
    nor.y = 0.0;
    nor = nor/cylinder.r;
    //nor.y = 1.0*sign(hit.y-cylinder.c.y);
    return nor;
}

// Function 606
vec4 iSphere( in vec3 ro, in vec3 rd, in vec3 M, in float radius)
{
  vec4 sph = vec4(M,radius);  
  float t = sdSphere(ro,rd,sph);
  if (t<0.0)    return vec4(-1);         //===>
  vec3 pos = ro + t * rd;
  vec3 n = sphereNormal (pos, sph);
  return vec4(n,t);
}

// Function 607
float fSphere(vec3 p,float r){return length(p)-r;}

// Function 608
float repCylinders( vec3 p, vec2 c )
{
    vec2 derp = mod(p.xz, c);
    vec2 q = derp-0.5*c;
    return length(q) - .34;
}

// Function 609
float sdCappedCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xy),p.z)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 610
vec3 LightBoxShadow (in vec3 position) {
    
    float shade = 1.0;

    // calculate whether or not the position is inside of the light box
    vec2 uv;
	vec3 localPos;    
    if (GetMode() >= 1.0)
    {
        // get position in light space and get uv
        localPos = WorldSpaceToDirectionalLightSpace(position);
    	uv = localPos.xz;
        uv.x *= -1.0;
        
        // apply scaling of uv over distance to fake projection
        uv /= (1.0 + localPos.y * directionalLightUVDistanceScale);
        
        // set shade to 1 if it's inside, 0 if it's outside        
    	shade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);
        
        // if it is behind the light source, don't light it!
        shade *= step(0.0, localPos.y);
        
        // apply distance attenuation
        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);        
    }
    
    // soften shadows over a distance
	if (GetMode() >= 2.0)
    {
        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.01, 0.99);
    	float softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));
    	float softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));
    	shade = shade * softenX * softenY;
    }
    
    // apply texture to light if we should!
    if (GetMode() >= 3.0)
    {
        uv = uv*0.5+0.5;
        return clamp((texture(iChannel0, uv).rgb * directionalLightTextureMADD.x + directionalLightTextureMADD.y) * shade, 0.0, 1.0);
    }
    
    return vec3(shade);
}

// Function 611
float sbox(vec2 p)
{
    return max(p.x, p.y);
}

// Function 612
void sphere( Ray ray, SphereParms sphereParams, inout HitInfo hitInfo )
{
    hitInfo.primitiveType = PrimitiveType_None;
    hitInfo.t = -1.0;
    hitInfo.hit = 0.0;
 
    vec3 newO = ray.origin - sphereParams.position;
    float b = 2.0 * dot( newO, ray.direction );
    float c = dot( newO, newO ) - (sphereParams.radius*sphereParams.radius);
 
    float h = b*b - (4.0*c);
    if( h < 0.0 ) return;
    float t = (-b - sqrt( h ) ) / 2.0;
 
    if ( t < Epsilon ) return;
    
    hitInfo.position = ray.origin + ray.direction * t;
    hitInfo.normal = normalize( ( hitInfo.position - sphereParams.position ) / sphereParams.radius );
    hitInfo.t = t;
    hitInfo.dist = length( hitInfo.position - ray.origin );
    hitInfo.rayDir = ray.direction;
    hitInfo.diffuseColor = sphereParams.diffuseColor;
    hitInfo.receiveShadow = sphereParams.receiveShadow;
    hitInfo.shadowCasterIntensity = sphereParams.shadowCasterIntensity;
    hitInfo.reflectionIntensity = sphereParams.reflectionIntensity;
    hitInfo.lightVisualizer = sphereParams.lightVisualizer;
    hitInfo.primitiveType = PrimitiveType_Sphere;
    hitInfo.hit = 1.0;
}

// Function 613
float sdCone(float dt, in vec3 p, in vec3 c)
{
    return sdCone(.1*dt + p,.03*dt + c);
}

// Function 614
void box_fold(inout vec3 z, inout float dz) {
    float fl = 1.;
    z = clamp(z, -fl, fl) * 2.0 - z;
}

// Function 615
float SphereTrace(vec3 o, vec3 u, out bool h,out int s)
{
  h = false;

    // Don't start at the origin, instead move a little bit forward
    float t=rA;

  for(int i=0; i<Steps; i++)
  {
    s=i;
    vec3 p = o+t*u;
    float v = object(p);
    float l = lobject(p);
    // Hit object
      if (v > 0.0)
      {
          s=i;
          h = true;
          break;
      }
      // Move along ray
      t += max(Epsilon,abs(v)/l);
      // Escape marched far away
      if (t>rB)
      {
          break;
      }
  }
  return t;
}

// Function 616
vec3 Sample_Sphere(float s0, float s1)
{
    float ang = Pi * s0;
    float s1p = sqrt(1.0 - s1*s1);
    
    return vec3(cos(ang) * s1p, 
                           s1 , 
                sin(ang) * s1p);
}

// Function 617
float sdPlane( vec3 p, float d ) {
	return p.y - d;
}

// Function 618
HessNum3 DE_Cylinder_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)
{
    
  return sub(a_sqrt(add(mult(x,x),mult(z,z))),1.);
 
}

// Function 619
float sdBox(vec3 p, vec3 b) {
	vec3 q = abs(p) - b;
	return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);
}

// Function 620
vec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec4(-1.0);

	vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

    // convert to ray space
	
	nor = (txi * vec4(nor,0.0)).xyz;

	return vec4( tN, nor );
}

// Function 621
float sdBox(vec3 p, vec3 b) {
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 622
float MarchAgainstPlanes( float t0, float dt, float wt, vec3 ro, vec3 rd, vec2 p )
{
    float t = t0;
    float res = 0.;
    vec3 pos;
    
    float firstWt = t0/dt;
    
    // first sample - blend in
    pos = ro + t * rd;
    res = max( res, firstWt*wt*smoothstep( 4., 2., length( pos.xz - p ) ) );
    t += dt;
    
    // interior samples
    for( int i = 1; i < SAMPLE_CNT-1; i++ )
    {
        pos = ro + t * rd;
        
        // render - in this case draw dots at each sample
        res = max( res, wt*smoothstep( 4., 2., length( pos.xz - p ) ) );
        
        t += dt;
    }
    
    // last sample - blend out
    pos = ro + t * rd;
    res = max( res,(1.-firstWt)*wt*smoothstep( 4., 2., length( pos.xz - p ) ) );
    t += dt;
    
    return res;
}

// Function 623
float IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)
{
	// Use dot product along line to find closest point on line
	vec3 eyeVec2 = normalize(posB-posA);
	float dp = dot(eyeVec2, pos - posA);
	vec3 pointOnLine = eyeVec2 * dp + posA;
	// Clamp that point to line end points if outside
	//if ((dp - radius) < 0) pointOnLine = posA;
	//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;
	// Distance formula from that point to sphere center, compare with radius.
	float distance = length(pointOnLine - pos);
	float ac = radius*radius - distance*distance;
	float rightLen = 0.0;
	if (ac >= 0.0) rightLen = sqrt(ac);
	intersectA2 = pointOnLine - eyeVec2 * rightLen;
	intersectB2 = pointOnLine + eyeVec2 * rightLen;
	distFromSphere = distance - radius;
	if (distance <= radius) return 1.0;
	return 0.0;
}

// Function 624
vec3 planetRotatedVec(in vec3 p)
{
    return p*g_planetRot;
}

// Function 625
float int_plane(Ray ry, Plane pl, out vec3 int_pt, out vec3 n)
{
	float omega = int_plane(ry, pl);
    int_pt = ry.pos + (ry.dir * omega);
    n = pl.coef.xyz;
    return omega;
}

// Function 626
float sphere(vec3 ray,vec3 pos, float radius)
{
    return length(ray-pos) - radius;
}

// Function 627
float torusSDFx( vec3 p, float r, float thickness ){
  vec2 q = abs(vec2(length(p.xz)-r,p.y)) - .2;
  return abs(length(q))- thickness;
}

// Function 628
vec4 getSphereSample( vec3 p, float r )
{
	if( getSphereDistance(p,r)<=0.0 )
	{
		p = normalize(p);
		p.x = sin(p.x*10.0 + 1.0*time)/3.0;
		p.y = cos(p.y*11.0 + 2.0*time)/3.0;
		p.z = sin(p.z*12.0 + 1.0*time)/3.0;
		
		//return vec4(vec3(p), 0.015);
		return vec4( 5.0*p.z*p.y,3.0*abs(p.x),0.9 , abs(p.x+p.y+p.z)/20.0 );
	}
	else
	{
		return getAmbientSample(p);
	}
}

// Function 629
vec2 sdBox( vec3 p, vec3 size ,vec3 pos,int mat)
{
  vec3  di = abs(p - pos) - size;
  float mc = max(di.x,max(di.y,di.z));
  float d = min(mc,length(max(di,0.0)));
  return vec2(d,mat);
}

// Function 630
float sdBox( vec3 p, vec3 b ) {
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 631
bool ballboxIntersection(vec2 circle, vec2 rect, float rectwidth, float rectheight, float circler)
{
   float circleDistanceX = abs(circle.x - rect.x - rectwidth/2.0);
   float circleDistanceY = abs(circle.y - rect.y - rectheight/2.0);
 
   if (circleDistanceX > (rectwidth/2.0 + circler)) { return false; }
   if (circleDistanceY > (rectheight/2.0 + circler)) { return false; }
 
   if (circleDistanceX <= (rectwidth/2.0)) { return true; }
   if (circleDistanceY <= (rectheight/2.0)) { return true; }
 
   float cornerDistance_sq = pow(circleDistanceX - rectwidth/2.0, 2.0) + pow(circleDistanceY - rectheight/2.0, 2.0);
 
   return (cornerDistance_sq <= (pow(circler, 2.0)));
}

// Function 632
float sdf_quarter2_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(pos.y, pos.x));
}

// Function 633
vec3 deBox(in vec3 box){
    return box*boxDim;		// return the center of the box
}

// Function 634
float opRepSphere( vec3 p, vec3 c , float r)
{
    vec3 q = mod(p,c)-0.5*c;
    vec3 re = (q-p)/c;
    return sdSphere( q  , r * 1.9 - .1 * length(re) );
}

// Function 635
float dist_cylinder(vec3 p,vec2 r)
{
	vec2 d=abs(vec2(length(p.xy),p.z))-r;
    return min(max(d.x,d.y),0.0)+length(max(d,0.0))-0.1;

}

// Function 636
float box(vec3 p, vec3 s) {
  vec3 ap=abs(p)-s;
  //return length(max(vec3(0),ap)) + min(0, max(ap.x,max(ap.y,ap.z)));
  return max(ap.x,max(ap.y,ap.z));
}

// Function 637
float conecapsule (vec3 p, vec3 p1 ,vec3 p2 ,vec3 r1,vec3 r2 ) {
// eats vec4 (x,y,z,r) X 2
    p1=vec3(p1.x,p1.y,max(-85.,p1.z));
    p2=vec3(p2.x,p2.y,max(-85.,p2.z));
vec3 a=mix(p1,p2,0.05);
vec3 b=mix(p1,p2,0.85);;
vec3 n1=pow(abs(normalize(p-a)),vec3(1.36));
vec3 n2=pow(abs(normalize(p-b)),vec3(1.36)); 
float		d1= length  ( vec3(r1.x*n1.x, r1.y*n1.y,r1.z*n1.z));
float		d2= length (vec3(r2.x*n2.x, r2.y*n2.y,r2.z*n2.z)); 
vec3		ba = b - a;
vec3		pa = p - a;
    float v= dot(pa,ba) / dot(ba,ba);
float		h = clamp(  v,   0.0,   1.0);
float			d=mix(d1,d2,  smoothstep(0.0,1.0,   h));
     float r= d ;// / 2.0;
 
            return length (pa - ba*h) - r;

}

// Function 638
vec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.
){if(n==0.)n=1.//worksafe
 ;float x=((k*2.+1.)/n)-1.
 ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!
 ;}

// Function 639
vec3 GetSkybox(const in vec3 rayOrigin, const in rayIntersect rIntersec)
{
    vec3 sky = SkyScatterring(rIntersec.mUV, rIntersec.rd);

    #ifdef ToD_ACTIVATED
        #ifndef DEBUG_NO_NIGHT
            float nightMult = abs(min(0.16667, sun_Color.w * 6.0 - 1.0));
            if(nightMult > 0.16667)
                sky += StarSky(rIntersec.rd) * nightMult;
        #endif
	#endif
    
    #ifdef DEBUG_NO_CLOUDS
        //Apply sun on sky and return
    	sky += sun_Color.xyz * pow(sunAmount, abs(SUN_RADIUS)) * 40.0;
        return sky;
    
    #else
		//Start and End of the cloud layer
		float cloudStart = (CLOUD_LOWER - rayOrigin.y) / abs(rIntersec.rd.y);
		float cloudEnd = (CLOUD_UPPER - rayOrigin.y) / abs(rIntersec.rd.y);

		// Clouds start rayOrigin
		vec3 cloudPos = vec3(rayOrigin.x + rIntersec.rd.x * cloudStart,
							 0.0,
							 rayOrigin.z + rIntersec.rd.z * cloudStart);

		// Raymarch steps to raytrace clouds
		vec3 add = rIntersec.rd * ((cloudEnd - cloudStart) / CLOUD_SAMPLES);
		vec2 shade = vec2(0.0, 0.0);

		// x == heigh value, y == mask (density on sky)
		vec2 cloudsValue = vec2(0.0, 0.0);

		// Loop for cloud density
		for(float i = 0.0; i < CLOUD_SAMPLES; ++i)
		{
			if (cloudsValue.y >= 1.0) 
				break;

			// Intensity of the current layer
			shade.y = max(MapClouds(cloudPos) - cloudy, 0.0);

			// Heigh value of the current layer
			shade.x = i/CLOUD_SAMPLES;

			// Merging new infos with backuped one
			cloudsValue += shade * (1.0 - cloudsValue.y);
			cloudPos += add;
		}
		cloudsValue.x /= 10.0;
		cloudsValue = min(cloudsValue, 1.0);
		
		// cloudsValue.x [0.17647058823529; 1.0] need to transpose to [0.61, 0.91];
		float cloudsIntensity = EaseInCircFct(cloudsValue.x / 2.75 + 0.54636);
		float sunHeight = clamp(sunDirection.y, 0.5, 1.0);
		float cloudContrast = 1.6875 - 1.25 * cloudy;

		// Applying contrast with cloudContrast and brightness with sunHeight
		vec3 clouds = mix(((AMBIENT_COLOR * cloudsIntensity) - 0.5) * cloudContrast + sunHeight,
						  vec3(1.0),
						  cloudsValue.x);

		//clouds intensity by ToD
		clouds *= max(sunDirection.y, 0.05);

		//Composite Sun on clouds
		clouds += sun_Color.xyz * min(pow(sunAmount, abs(SUN_RADIUS) * 0.025) * (cloudy + 0.2) / 3.2,
									  exp(sun_Color.w+0.4) * 0.3);

		//Composite sun on sky
		sky += sun_Color.xyz * pow(sunAmount, abs(SUN_RADIUS)) * 40.0;

		//Composite sky and clouds
		return mix(sky, min(clouds, 1.0), cloudsValue.y);
    #endif
}

// Function 640
vec3 skybox(in vec3 nv) {
    return mix(0.5+0.5*normalize(nv), vec3(0.8, 0.7, 1.0), 0.7);
}

// Function 641
float iPlane(in vec3 ro, in vec3 rd)
{
	//Plane equation, y = 0 = ro.y + t * rd.y;
	float t = (-ro.y / rd.y);
	return t;
}

// Function 642
vec3 shadeSphere( vec3 normal, vec3 vertPos, vec3 v, float time )
{		
	vec3 reflColor;
	vec3 newNormal = normal;
	vec3 dir = normalize(reflect(v, newNormal));
	vec3 pos = vertPos;
	int sphere = 0;
    
	for( int i = 0; i < REFLECTIONS; ++i )
	{
		if( pos.x < CAST_DISTANCE )
		{
			pos = castScene(pos, dir, newNormal, time);
			dir = normalize(reflect(dir, newNormal));
            sphere = 1;
		}
		else
		{
			break;
		}
	}
	
    // color
	vec3 col = sampleCube(dir);
    
    if(sphere == 1)
    {
        col = ApplyMaterial(col, dir, newNormal);
    }
    
    return col;
}

// Function 643
float sphereAppSurface(float radius){
    return PI*radius*radius;
}

// Function 644
float sdfRoundCone( vec3 p, float r1, float r2, float h, mat4 t){
  p = vec3(t * vec4(p, 1));
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 645
hit tracePlane(in ray r, in pln p) {
    seg s = tPlane(r, p);
    float d = minT(s.t.y, s.t.x);
    return hit(r.o + r.d * d, p.n, d, p.m);
}

// Function 646
mat3 inverseInertiaTensorSphere(float r, float density) {
    float v = 4.*r*r*r*PI/3.; // m
    float m = v*density;      // kg
    float it = 5./(2.*m*r*r); 
	return mat3(it,0,0,  0,it,0, 0,0,it);
}

// Function 647
float box( in vec3 p, in vec3 data )
{
    return max(max(abs(p.x)-data.x,abs(p.y)-data.y),abs(p.z)-data.z);
}

// Function 648
float box_dist(vec2 p, vec4 b) {
    
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
    
}

// Function 649
float fBox2(vec2 p,vec2 b){vec2 q,d=abs(p)-b;q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}

// Function 650
float boxLine( vec3 point, float z ) {
    
    float bsize = 0.9;
    
    vec3 box = vec3(0., bsize, z);
    
    float dist = sdBox(box, point, vec3(bsize));
    
    for( float i = 1.; i < 3.; i++ ) {
        vec3 npos = vec3(box.x + i*2.*(bsize+0.35), box.y, box.z);
        float newBox = sdBox(npos, point, vec3(bsize));
        dist = min(dist, newBox);
    }
    
    return dist;
}

// Function 651
int LTC_ClipQuadToHorizonPlane(inout vec3 L[5], in float d[4])
{
	// detect clipping config
	int config = 0;
	if (d[0] > 0.0) config += 1;
	if (d[1] > 0.0) config += 2;
	if (d[2] > 0.0) config += 4;
	if (d[3] > 0.0) config += 8;

	if (config == 1) { // L0 clip L1 L2 L3
		L[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)
		L[2] = -d[3] * L[0] + d[0] * L[3]; // L2 = clip(L3,L0)
		return 3;
	} else if (config == 2) { // L1 clip L0 L2 L3
		L[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)
		L[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)
		return 3;
	} else if (config == 3) { // L0 L1 clip L2 L3
		L[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)
		L[3] = -d[3] * L[0] + d[0] * L[3]; // L3 = clip(L3,L0)
		return 4;
	} else if (config == 4) { // L2 clip L0 L1 L3
		L[0] = -d[3] * L[2] + d[2] * L[3]; // L0 = clip(L3,L2)
		L[1] = -d[1] * L[2] + d[2] * L[1]; // L1 = clip(L1,L2)
		return 3;
//  } else if (config == 5) { // L0 L2 clip L1 L3  (impossible)
	} else if (config == 6) { // L1 L2 clip L0 L3
		L[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)
		L[3] = -d[3] * L[2] + d[2] * L[3]; // L3 = clip(L3,L2)
		return 4;
	} else if (config == 7) { // L0 L1 L2 clip L3
		L[4] = -d[3] * L[0] + d[0] * L[3]; // L4 = clip(L3,L0)
		L[3] = -d[3] * L[2] + d[2] * L[3]; // L3 = clip(L3,L2)
		return 5;
	} else if (config == 8) { // L3 clip L0 L1 L2
		L[0] = -d[0] * L[3] + d[3] * L[0]; // L0 = clip(L0,L3)
		L[1] = -d[2] * L[3] + d[3] * L[2]; // L1 = clip(L2,L3)
		L[2] =  L[3];
		return 3;
	} else if (config == 9) { // L0 L3 clip L1 L2
		L[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)
		L[2] = -d[2] * L[3] + d[3] * L[2]; // L2 = clip(L2,L3)
		return 4;
//	} else if (config == 10) { // L1 L3 clip L0 L2 (impossible)
	} else if (config == 11) { // L0 L1 L3 clip L2
		L[4] =  L[3];
		L[3] = -d[2] * L[3] + d[3] * L[2]; // L3 = clip(L2,L3)
		L[2] = -d[2] * L[1] + d[1] * L[2]; // L2 = clip(L2,L1)
		return 5;
	} else if (config == 12) { // L2 L3 clip L0 L1
		L[1] = -d[1] * L[2] + d[2] * L[1]; // L1 = clip(L1,L2)
		L[0] = -d[0] * L[3] + d[3] * L[0]; // L0 = clip(L0,L3)
		return 4;
	} else if (config == 13) { // L0 L2 L3 clip L1
		L[4] =  L[3];
		L[3] =  L[2];
		L[2] = -d[1] * L[2] + d[2] * L[1]; // L2 = clip(L2,L1)
		L[1] = -d[1] * L[0] + d[0] * L[1]; // L1 = clip(L1,L0)
		return 5;
	} else if (config == 14) { // L1 L2 L3 clip L0
		L[4] = -d[0] * L[3] + d[3] * L[0]; // L4 = clip(L0,L3)
		L[0] = -d[0] * L[1] + d[1] * L[0]; // L0 = clip(L0,L1)
		return 5;
	} else if (config == 15) // L0 L1 L2 L3 (no clipping)
		return 4;
	else
		return 0; // all points clipped
}

// Function 652
vec4 sldBox(in vec3 p, in vec3 b) {
  vec3 d = abs(p) - b;  // point on the line to corner
  float l = length(max(d, 0.0)) + min(max(d.z, max(d.x, d.y)), 0.0);
  return vec4(l, d);
}

// Function 653
float cylinder(vec3 position, float radius, float halfHeight) {
    position = abs(position);
    float d = max(position.x - radius, position.z);
    d = min(d, max(position.x, position.z - radius));
    float b = dot(vec2(1.0), position.xz);
    float c = dot(position.xz, position.xz) - (radius * radius);
    float discriminant = b * b - 2.0 * c;
    if (discriminant >= 0.0) {
        float t = (b - sqrt(discriminant)) / 2.0;
        d = min(d, t);
    }
    d = max(d, position.y - halfHeight);
    return d;
}

// Function 654
vec3 planeinterp(vec3 a, vec3 b, vec3 c, vec3 d, vec2 k) {
  a*=a;
  b*=b;
  c*=c;
  d*=d;
  return sqrt(mix(mix(a, b, k.x), mix(c, d, k.x),k.y));
}

// Function 655
float common_BoxTest(vec2 p, vec2 bottomLeft, vec2 topRight) 
{
    vec2 s = step(bottomLeft, p) - step(topRight, p);
    return s.x * s.y;
}

// Function 656
bool hit_box(const in Box b, const in Ray r, const in float tmin, 
                 const in float tmax, inout HitRecord rec) {

    vec3 m = 1./r.d;
    vec3 n = m*(r.o - b.center);
    vec3 k = abs(m)*b.radius;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.) return false;
    
    float t = tN < tmin ? tF : tN;
    float other_t = tN > tmin ? tF : tN; // to hold the other intersection
    if (t < tmax && t > tmin) {
        rec.t = t;
        rec.t2 = other_t;
        rec.pos = r.o + t*r.d;
		rec.normal = -sign(r.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
        rec.normal2 = -sign(r.d)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);
	    return true;
    } else {
        return false;
    }
    return false;
}

// Function 657
float pSphere(vec3 p, float s)
{
	return length(p)-s;
}

// Function 658
hit tracePlanePOM(in ray r, in pln p, in sampler2D heightMap, in vec3 comp, in float scale, in float heightScale) {
	//start with plane
    hit h = tracePlane(r, p);
    if (h.d >= zfar) return h;
    //start ray marching
    vec3 dl = vec3(p.l.x,0.,p.l.z), l = h.l - dl, ro = l, rd = r.d;
    float d = 0., depth = 1., height = 0., top = ro.y, ld = 0.,
          //find a balance between distance and angle for step size
          s = max(distance(r.o, h.l)*.01, .05/abs(dot(r.d, h.n)));
    for (int i = 0; i < 16; i++) {
        d += s;
        l = ro + rd*d;
        depth = 1.-(top-l.y),
        height = texComp(heightMap, fract(l.xz*scale), comp) * heightScale;
        if (depth < height) break;
        ld = depth - height;
    }
    //linear interpolate intersection to smooth
    float cd = height - depth, lerp = 1.-clamp(ld/(ld+cd),0.,1.);
    //update hit
    d -= s*lerp;
    h.l = ro + rd*d + dl;
    h.d += d;
    //get normal? we dont need it 'til texturing
    vec3 px = 1. / iResolution.yyy * vec3(-1.,0.,1.);
    //wtf
    h.n = norm3(heightMap, comp, px, fract((h.l.xz)*scale)).rbg * vec3(-1.,1.,-1.);
    return h;
}

// Function 659
float shadowSphere(vec3 ro, vec3 rd, vec3 p, float radius)
{
    vec3 d = p-ro;
    float b = dot(d, rd);
    if(b<0.)
        return 1.0;
   	vec3 c = ro+rd*b;
    float s = length(c-p)/radius;
    return max(0.,(min(1.,s)-.7)/.3);
}

// Function 660
float sphereSDF(vec3 samplePoint) {
	return length(samplePoint) - abs(sin(iTime * 1.) * 0.05 + 0.05 + 0.7);
}

// Function 661
vec2 planetMap(in vec3 p)
{p=planetSpin()*p
;float pn1=noise3(p/32.)
;float pn2=noise3(p*(2.1/32.))
;float pn3=noise3(p*(4.2/32.))//3 noises
;float pf1=pn1+.5*pn2+.25*pn3//united to a 3 octave noise
//Ridged multi fractal
;float s=pow((1.-abs(pn3)),2.),ss=sat(s*1.5)
,r=pow(1.-abs(pn2),2.)+.5*s*ss
#ifdef ENABLE_DETAILS
,pn4=noise3(p*8.82/32.)
,pn5=noise3(p*18.522/32.)
,pn6=noise3(p*38.8962/32.)
;pf1+=(pn4+pn5/2.+pn6/4.)/8.
;r+=pow((1.-abs(pn4)),2.)*ss/4.
;r+=pow((1.-abs(pn5)),2.)*ss/8.
;r+=pow((1.-abs(pn6)),2.)*ss/16.
#endif
// Mountain
;float mm=smoothstep(.55,1.,sat(abs(.925-pn2)))*sat(pf1)//land
,ma=mix(1.,2.,smoothstep(0.,.5,mm)) 
;s=ATMOSPHERE_HEIGHT/4.*pf1+mix(.0,2.5*r,mm)
;return vec2(length(p)-SEA_LEVEL-s,ma);}

// Function 662
vec3 cosWeightedRandomHemisphereDirection2(const vec3 n) {
	
    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));
	vec3  vv = cross(uu, n);	
    
	float ra = sqrt(rv2.y);
	float rx = ra*cos(6.2831 * rv2.x); 
	float ry = ra*sin(6.2831 * rv2.x);
	float rz = sqrt(1.0 - rv2.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);

    return normalize(rr);
}

// Function 663
float dSphere(vec3 pos, vec3 center, float radius)
{
    // find the distance to the center
    vec3 v = pos - center;
    
    // return that, minus the radius
    return length(v) - radius;
}

// Function 664
bool intersectHypersphere(vec3 rayPosition, vec3 rayDirection, out float t)
{
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(rayDirection, rayPosition);
    float c = dot(rayPosition, rayPosition) - 1.0;

    return solveQuadraticIntersection(a, b, c, t);
}

// Function 665
float distCone(vec3 pos, float radiusBase, float height)
{
    float slope = radiusBase / height;
    float r = length(pos.xz);
    float dist = r - (radiusBase - pos.y * slope);
    dist = soft_max2(dist, -pos.y, 1.0);
    return dist;
}

// Function 666
bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 20.;
	float delta = b*b - c;
	if( delta < 0.0) 
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}

// Function 667
float raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {
    vec3 ce = ro - spherePos;
    float b = dot(rd, ce);
    float c = dot(ce, ce) - r * r;
    float t = b * b - c;
    if (t > tmin) {
        t = -b - sqrt(t);
        if (t < tmax)
            return t;
        }
    return -1.0;
}

// Function 668
float cylinder(in vec3 p, in float r) { return length(p.xy) - r; }

// Function 669
float RoundBox( vec3 p, vec3 b, float r )
{
 	vec3 d = abs( p ) - b;
	return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) ) - r;
}

// Function 670
float RaySphere(vec3 P, vec3 V, vec3 A, float r)
{
	return Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));
}

// Function 671
vec4 digitUIBox(int idx) {
    
    const vec2 digitRad = vec2(0.35, 0.5);
    
    return vec4(pqrBox.x + (float(idx - 1))*pqrSize,
                pqrBox.y,
                digitRad*pqrSize);

}

// Function 672
float iSphere(Ray r, int i)
{
    vec4 s = SPHERES[i];
    vec3 L = s.xyz- r.o;
    float tc = dot(L, r.d);
    float d2 = dot(L, L) - tc * tc;
    float r2 = s.w * s.w;
    if (d2 > r2)
        return r.t;

    float tlc = sqrt(r2 - d2);
    float t0 = tc - tlc;
    float t1 = tc + tlc;
    if (t0 > t1) {
        float tmp = t0;
        t0 = t1;
        t1 = tmp;
    }
    if (t0 < 0.0) {
        if (t1 < 0.0)
            return r.t;
        return t1;
    }
    return t0;
}

// Function 673
bool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {
    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);
    return dot(direction, aux_a) > 0.0;
}

// Function 674
void getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {
	// falling?
	float s = 0.1+hash( grid.x*1.23114+5.342+754.324231*grid.y );
	float t = 14.*s + time/s;
	
	float y =  s * MAXHEIGHT * abs( cos( t ) );
	vec2 offset = grid + sphereOffset;
	
	center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}

// Function 675
float fBox(vec3 p, vec3 b, float r) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;
}

// Function 676
vec3 SphereTexture(sampler2D tex,vec3 normal) {
     float u = atan(normal.z, normal.x) / PI * 2.0;
     float v = asin(normal.y) / PI * 2.0;
     return texture(tex,vec2(u,v)).rgb;
}

// Function 677
bool BoxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out float tN, out vec3 norm) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    norm=vec3(0.,1.,0.);
    
	if( tN > tF || tF < 0.0) return false;
    if(tN<MIN_DIST && tN>MAX_DIST )return false;

	vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
	
	norm = (txi * vec4(nor,0.0)).xyz;

	return true;
}

// Function 678
float sphere(vec3 p, float r) {
    return length(p) - r;
}

// Function 679
vec3 closestPointOnCylinder(vec3 p, vec2 dim) {
    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));
}

// Function 680
float sphere(vec3 p)
{
// p.x = mod(p.x+1.0,-2.);

 vec3 q = fract(p) * 1.0-0.5;
    
 //q.z = (0.01*sin(iTime/20.0));
  //vec3 q;   
    
 q.x = cos(p.y+0.2*iTime);
    
 q.y = sin(p.x+0.2*iTime);  
 //vec3 q = mod(p, 3.1);   
 //return length(q) - (q.x * sin(iTime/10.1)+1.9);
 return length(q) - (1.5);
}

// Function 681
float sdPlane(in vec4 p) {
	return p.y;
}

// Function 682
float sdPlane(vec3 p, vec4  n) { return dot(p,n.xyz) + n.w; }

// Function 683
float sdCylinder(vec3 p, vec2 h) {
    return max( length(p.xz)-h.x, abs(p.y)-h.y );
}

// Function 684
vec3 naiveBoxBlur(
    in sampler2D tex,
    in vec2 uv,
    in vec2 resolution,
    in float size,
    in int samples
) {
    float f_samples = float( samples );
    vec2 px = 1. / resolution;
    float increment = size / ( f_samples - 1. );
    float halfSize = size * .5;
    
    vec3 color = vec3( 0. );
    float w = 0.;
    for ( float i = -halfSize; i <= halfSize; i += increment ) {
        for ( float j = -halfSize; j <= halfSize; j += increment ) {
            w += 1.;
            vec2 st = uv + vec2( i, j ) * px;
            color += texture( tex, st ).rgb;
        }
    }
    
    return color / w;
}

// Function 685
float sphereSDF(vec3 samplePoint) {
    vec3 position = vec3(2,0,2);
    vec3 position2 = samplePoint - position;
    return length(position2) - 1.0;
}

// Function 686
float sdSoftBox(in vec3 p, in float r)
{
  p *= p;
  p *= p;
  p *= p;
  return pow(p.x + p.y + p.z, 1.0/8.0) - r;
}

// Function 687
float repSphere(vec3 p, vec3 c, float r)
{
 	vec3 q = mod(p,c)-0.5*c;
    return sphere(q, r);
}

// Function 688
vec3 getspherecolor(vec3 p) {
  // Apply inversion to sphere.
  if (true) {
    vec3 q = vec3(0);
    if (iMouse.x > 0.0) {
      vec3 m = vec3((2.0*iMouse.xy-iResolution.xy)/iResolution.y,0);
      q = vec3(m.xyz);
    }
    // Any point is the centre of a sphere orthogonal to the
    // unit sphere, inverting in which leaves the unit sphere
    // invariant. Any point inverts to another point on the
    // line to the sphere centre, so just find other
    // intersection of ray p to r with unit sphere.
    // |p + kr|^2 = 1 where r = q-p
    // (p.p + 2kp.r + k^2(r.r)) = 1
    // 2p.r + k(r.r) = 0 since p.p = 1 & dividing by k
    vec3 r = q-p;
    float k = -2.0*dot(p,r)/dot(r,r);
    p += k*r;
  }
  p = transform(p); // autorotation
  // And stereographic projection from (0,0,1) to plane z = 0
  return gasketcolor(stereographic(p));
}

// Function 689
void get_bbox(const std::vector<vec3>& pts, vec3& bbox_min, vec3& bbox_max) { 
    bbox_min = pts[0]; bbox_max = pts[0]; 
    for(int i=1; i<pts.size(); ++i) {
	bbox_min = min(bbox_min, pts[i]); bbox_max = max(bbox_max, pts[i]);	
    }
}

// Function 690
vec4 getCubePlane(uint ci,uint k)
{
    vec3 norm = vec3( k%3u==1u?1.0:0.0, k%3u==0u?1.0:0.0, k%3u==2u?2.0:0.0)*(float(k/3u)*-2.0+1.0);
    norm = rotate(getCubeQuat(ci),norm);
    float offset = 1.0 + dot(getCubePos(ci),norm);
    return vec4(norm,offset);
}

// Function 691
void RayPlane(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)
{
	float3 dp0=rp0-tp0;

	float3 dett =cross(dp1,dp2);
	float3 detuv=cross(dp0,rd);

	float det=(-1.0)/dot(dett,rd);

	float u=(dot(detuv,dp2))*det;
	float v=(dot(detuv,dp1))*det;
	t=(dot(dett ,dp0))*det;
	if(t<0.0)
	{
		t=MAX_RAY_LENGTH;
		return;
	}
	
	uv=float3(u,v,0.0);
	n=normalize(dett);
}

// Function 692
float sphere( vec3 p, vec3 c,float s )
{
	return length(p-c)-s;
}

// Function 693
float torus(vec3 p, float r, float r2)
{
  return sdTorus(p, vec2(r, r2));	
}

// Function 694
float fBox(vec3 p,vec3 s){
 v3 d=abs(p)-s;//mirror clamp
 v1 a=length(max(d,0.));//rounded corners
 v3 q=min(d,0.);//clamp
 v1 b=max(max(q.x,q.y),q.z);//keep largest of 3
 return a+b;}

// Function 695
vec3 getRandomHemisphereDir(vec3 normal) {
    float e = 0.0;
    
    float u1 = nextFloat();
    float u2 = nextFloat();
    float cosPhi = cos(2.0 * PI * u1);
    float sinPhi = sin(2.0 * PI * u1);
    float cosTheta = pow((1.0 - u2), 1.0 / (e + 1.0));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    float x = sinTheta * cosPhi;
    float y = sinTheta * sinPhi;
    float z = cosTheta;
    
    vec3 w = normal;
    vec3 u = normalize(cross((abs(w.x) > 0.1 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0)), w));
    vec3 v = cross(w, u);
    
    return u * x + v * y + w * z;
}

// Function 696
float sdSphere(vec3 p, float d) { return length(p) - d; }

// Function 697
float sdCone( in vec3 p, in vec2 c )
{
  vec2 q = vec2( length(p.xz), p.y );

  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );
  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );
  
  float s = -sign( c.y );
  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),
			    vec2( dot( b, b ), s*(q.y-c.y)  ));
  return -sqrt(d.x)*sign(d.y);
}

// Function 698
float sdSphere(in vec3 p, in float size )
{
    return length(p) - size;
}

// Function 699
float sdBox(vec3 p,vec3 b)
{
  vec3 d = abs(p)-b;
  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 700
float cylinder(vec4 ray, vec4 pos, float size,
        float lenrayyzw,
        float lenrayzwx,
        float lenraywxy,
        float lenrayxyz) {
    return max(max(max(
        sphIntersect(ray.yzw*lenrayyzw,vec4(pos.yzw,size)).y*lenrayyzw,
        sphIntersect(ray.zwx*lenrayzwx,vec4(pos.zwx,size)).y*lenrayzwx),
        sphIntersect(ray.wxy*lenraywxy,vec4(pos.wxy,size)).y*lenraywxy),
        sphIntersect(ray.xyz*lenrayxyz,vec4(pos.xyz,size)).y*lenrayxyz);
    
}

// Function 701
float Box(in vec3 p, in vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 702
vec3 nCylinder( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3  ba = b - a;
    vec3  pa = pos - a;
    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
    return (pa - h*ba)/r;
}

// Function 703
vec3 stereographicPlaneToSphere(vec2 cartPointOnPlane) 
{
    float x2 = cartPointOnPlane.x*cartPointOnPlane.x;
    float y2 = cartPointOnPlane.y*cartPointOnPlane.y;
    return vec3(
        (2.0*cartPointOnPlane.x) / (1.0 + x2 + y2), 
	    (-1.0 + x2 + y2) / (1.0 + x2 + y2),
        (2.0*cartPointOnPlane.y) / (1.0 + x2 + y2));
}

// Function 704
bool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    if ( IS_ZERO( ray.dir.z ) )
    	return false;
    
    t = ( -ray.origin.z ) / ray.dir.z;
    
    isect.position_ = ray.origin + ray.dir*t;
    
    if( (isect.position_.x < min_x) ||
       	(isect.position_.x > max_x) ||
      	(isect.position_.y < min_y) ||
      	(isect.position_.y > max_y) )
        return false;
    
    if( !forShadowTest ) {
        isect.uv_.x 		= (isect.position_.x - min_x)/(max_x - min_x);
        isect.uv_.y 		= (isect.position_.y - min_y)/(max_y - min_y);
        isect.normal_ 		= vec3( 0.0, 0.0, 1.0 );
        isect.tangent_ 		= vec3( 1.0, 0.0, 0.0 );
    }
    
    return true;
}

// Function 705
float dist_box( vec3 pos, vec3 size ) {
	return length( max( abs( pos ) - size, 0.0 ) );
}

// Function 706
float sdbox(vec2 p, vec2 b)
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) +
         length(max(d,0.0));
}

// Function 707
vec4 planet(in vec2 pix, in float rotspeed, in float rot, in float light, in float zLight, in float time) 
{
    vec2 p = -1.0 + 2.0 * pix;
    p.x *= iResolution.x / iResolution.y;
    p = mat2(cos(rot), sin(rot), -sin(rot), cos(rot)) * p;
	
    vec3 ro = vec3( 0.0, 0.0, 2.25 );
    vec3 rd = normalize( vec3( p, -2.0 ) );

    vec3 col = vec3(0.0);

    // intersect sphere
    float b = dot(ro,rd);
    float c = dot(ro,ro) - 1.0;
    float h = b*b - c;
	float t = -b - sqrt(h);
	vec3 pos = ro + t*rd;
	vec3 nor = pos;

	// texture mapping
	vec2 uv;
	uv.x = atan(nor.x,nor.z)/6.2831 + rotspeed*time;
	uv.y = acos(nor.y)/3.1416;
	uv.y = 0.5 + spow(uv.y - 0.5, 1.2);
	uv += noiseOffset;
	
	float n2 = pnoise(uv * noiseScale2, noiseScale2) * 0.05;
	float n = pnoise(uv * noiseScale, noiseScale) + n2;
	
	float temp = cos(nor.y * 4.0) + pnoise(uv * noiseScale3, noiseScale3) * 0.8 + n * 0.5;
	
	float oceanity = min(1.0, 1.0 - smoothstep(0.19, 0.2, n) + 1.0 - smoothstep(0.05, 0.08, mod(temp - uv.x * 35.0 + 0.3, 1.0) + n * n * 0.35));
			
	float iceity = max(0.0, 1.0 - oceanity - smoothstep(-0.8, -0.6, temp));
	float coldity = max(0.0, 1.0 - iceity - oceanity - smoothstep(-0.4, 0.0, temp));
	float temperateity = max(0.0, 1.0 - iceity - coldity - oceanity - smoothstep(0.3, 0.8, temp));
	float warmity = max(0.0, 1.0 - iceity - coldity - temperateity - oceanity - smoothstep(1.05, 1.3, temp));
	float hottity = max(0.0, 1.0 - oceanity - iceity - coldity - temperateity - warmity);
	
	col = ocean * oceanity + ice * iceity + cold * coldity + temperate * temperateity + warm * warmity + hot * hottity;
	
	col *= (0.7 + abs(temp + n * 0.2) * 0.3);
	col *= 0.92 + step(0.1, mod(n2, 0.4)) * 0.08;
	col *= 1.0 + step(0.39, mod(n + uv.x, 0.4)) * 0.1;
	
	float cloudN = max(0.0, pnoise((uv + vec2(rotspeed * time, 0)) * cloudNoise, cloudNoise) + cloudiness + n2);
	col *= 0.7;
	col += vec3(cloudN, cloudN, cloudN) * 0.5;

    float lighting = max(sin(light) * nor.y * 2.0 + cos(light) * nor.x * 2.0 + nor.z * zLight,0.0);
	col *= 0.2 + lighting * 0.7;

    return vec4(mix(vec3(0.0), col, step(0.0, h)), 1.0);
}

// Function 708
float sdSphere(vec3 p, float s) {
	return length(p)-s;
}

// Function 709
float TTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// Function 710
bool intSphere( in vec4 sp, in vec3 ro, in vec3 rd, out float t ) {
    vec3  d = ro - sp.xyz;
    float b = dot(rd,d);
    float c = dot(d,d) - sp.w*sp.w;
    float tt = b*b-c;
    if ( tt > 0.0 ) {
        t = -b-sqrt(tt);
        return true;
    }
    return false;
}

// Function 711
void frontbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {
  
  vec3 invd = 1.0/r;
  
  vec3 t0 = ((pos-size) - s) * invd;
  vec3 t1 = ((pos+size) - s) * invd;
  vec3 mi = min(t0, t1);
  vec3 ma = max(t0, t1);
  
  float front = min(min(ma.x,ma.y),ma.z);
  float back = max(max(mi.x,mi.y),mi.z);
  
  if(back<d && back > 0.0 && back<front) {
    d = back;
    emi = vec3(0);
    n = (1.0-clamp(-(mi-back)*10000.0,0.0,1.0)) * sign(t1-t0);
  }
}

// Function 712
Hit intersectSphere(Sphere s, Ray r)
{
	vec3 op = s.p - r.o;
    float b = dot(op, r.d);
    float det = b * b - dot(op, op) + s.r * s.r;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t = b - det;
    if (t < 0.) t = b + det;
    if (t < 0.) return noHit;

    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);
}

// Function 713
float sdPlane(vec3 p,vec4 n)
{
  // n.xyz must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 714
float sphere(vec3 p, vec3 c, float r){
	
	return distance(p, c) - r;
}

// Function 715
d22 fBoxCheap(c22 p,v2 s
){
 ;c22 u=suab(p,s)//mirror clamp
     
 ;return madm(u);}

// Function 716
vec3 sphereCol(in float t) {
    return normalize(.5 + .5*cos(6.28318530718*(1.61803398875*floor(t)+vec3(0,.1,.2))));
}

// Function 717
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN>tF || tF<0.0) return 1.0;
	return 0.0;
}

// Function 718
bool intersectSphere(vec3 ro, vec3 rd, float r, out float t)
{
	float b = dot(-ro, rd);
	float det = b*b - dot(ro, ro) + r*r;
	if (det < 0.0) return false;
	det = sqrt(det);
	t = b - det;
	return t > 0.0;
}

// Function 719
Hit sphereSDF(vec3 p, Sphere s)
{
    return Hit(length(p - s.center) - s.radius, s.color);
}

// Function 720
vec2 sdPlane(vec3 p, vec4 n, float id)
{
  // n must be normalized
  return vec2(dot(vec3(p.x,p.y, max(p.z + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);
}

// Function 721
vec3 closestPointToBoxExterior( vec3 p, vec3 b )
{
    return p-sign(p)*max(abs(p)-b,0.0);
}

// Function 722
float box(vec4 p, float size) {
    vec4 p2 = abs(p)-size;
    return length(max(p2,0.0))+min(0.0,max(max(max(p2.x,p2.y),p2.z),p2.w));
}

// Function 723
bool sameHemisphere(in vec3 n, in vec3 a, in vec3 b){ return ((dot(n,a)*dot(n,b))>0.0); }

// Function 724
vec4 dualSphere(dualR3 p, float scale)
{
	return (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale));
}

// Function 725
float dbox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

// Function 726
float plane(vec2 p, vec3 pp) {
  return dot(p, pp.xy) + pp.z;
}

// Function 727
ProjectionResult projectSphere( /* sphere        */ in vec4 sph, 
				                /* camera matrix */ in mat4 cam,
							    /* projection    */ in float fle )
{
    // transform to camera space	
	vec3  o = (cam*vec4(sph.xyz,1.0)).xyz;
	
    float r2 = sph.w*sph.w;
	float z2 = o.z*o.z;	
	float l2 = dot(o,o);
	
	float area = -3.141593*fle*fle*r2*sqrt(abs((l2-r2)/(r2-z2)))/(r2-z2);
	
	//return area;
	
	
    //-- debug stuff ---

	
	// axis
	vec2 axa = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-z2)))*vec2( o.x,o.y);
	vec2 axb = fle*sqrt(-r2*(r2-l2)/((l2-z2)*(r2-z2)*(r2-l2)))*vec2(-o.y,o.x);

    //area = length(axa)*length(axb)*3.141593;	
	
	// center
	vec2  cen = fle*o.z*o.xy/(z2-r2);

	return ProjectionResult( area, 
							 cen, axa, axb, 
                     /* implicit ellipse f(x,y) = ax + by + cxy + dx + ey + f = 0 */
                     /* a */ r2 - o.y*o.y - z2,
                     /* b */ r2 - o.x*o.x - z2,
                     /* c */ 2.0*o.x*o.y,
                     /* d */ 2.0*o.x*o.z*fle,
                     /* e */ 2.0*o.y*o.z*fle,
                     /* f */ (r2-l2+z2)*fle*fle );
	
}

// Function 728
bool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)
{
    return length(A0-B0) < r;
}

// Function 729
float obj_planeZ(vec3 p, float planeZ){
    return p.z-planeZ;
}

// Function 730
bool raySphereIntersect(vec3 rayDirection, vec3 sphere, float radius, out vec2 hit) {
	hit = vec2(0.0);
    
	float b = dot(sphere, rayDirection);
	float c = dot(sphere, sphere) - radius * radius;
	
	float d = b * b - c;

    //if (dot(rayDirection, normalize(sphere)) > 1.0) return false;

	if (d < 0.0) {
        return false;
	}
    
	d = sqrt(d);
	
	hit = vec2(-b - d, -b + d);
    return true;
}

// Function 731
int get_plane_material(mediump int plane_index)
{
    // An encoding that only needs bit shifts/masks to decode
    // (like 4x8b, 4x4b or 8x4b) would be a much smarter choice.
    // On the other hand, 6x4b leads to a shorter textual encoding
    // for the array (and a slower decoding sequence).
    // Let's pretend character count matters and go with 6x4b...
    
    // Side note: we can use just 4 bits for each plane material id
    // because the material list is sorted by frequency of use
    // before the id's are assigned, and it just so happens that the map
    // currently uses only 16 materials. If we wanted to add just one more
    // we'd have to bump up the number of bits per face to 5.
    
    // better division/modulo codegen for unsigned ints:
    // http://shader-playground.timjones.io/a05d99ce3e6e1ae57ef111c8323e52d2
    mediump uint index = uint(plane_index);
    
    mediump uint unit_index = index / 6u;
    lowp uint bit_index = index % 6u;
    bit_index <<= 2;
    int code = uint(unit_index) < uint(NUM_MATERIAL_ENTRIES) ? materials.data[uint(unit_index)] : 0;

    return 15 & (code >> bit_index);
}

// Function 732
vec3 computeNormalBox(vec3 p,Box b)
{
    
	// project on edges

	vec3 center = (b.bmax + b.bmin)/2.;
	vec3 halfSize = (b.bmax - b.bmin)/2.;
	vec3 nx = vec3(1.,0.,0.);
	vec3 ny = vec3(0.,1.,0.);
	vec3 nz = vec3(0.,0.,1.);

	vec3 f1 = center + nx*halfSize.x;
	vec3 f2 = center - nx*halfSize.x;

	vec3 f3 = center + ny*halfSize.y;
	vec3 f4 = center - ny*halfSize.y;

	vec3 f5 = center + nz*halfSize.z;
	vec3 f6 = center - nz*halfSize.z;


	// compute side distance
	if(abs(dot(f1-p,nx)) < 0.00001)
	{
		return nx;
	}
	if(abs(dot(f2-p,nx)) < 0.00001)
	{
		return -nx;
	}
	if(abs(dot(f3-p,ny)) < 0.00001)
	{
		return ny;
	}
	if(abs(dot(f4-p,ny)) < 0.00001)
	{
		return -ny;
	}

	if(abs(dot(f5-p,nz)) < 0.00001)
	{
		return nz;
	}
	if(abs(dot(f6-p,nz)) < 0.00001)
	{
		return -nz;
	}



	return normalize(vec3(1.,1.,1.));
}

// Function 733
float sphere(vec3 p, float r){
	return length(p) - r;
}

// Function 734
float sphere(vec3 r,vec3 p, float radius)
{
    return length(r-p) - radius;
}

// Function 735
bool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)
{
    bool hit = false;
	float a = dot(direction, direction);
    float b = 2.0*dot(origin, direction);
    float c = dot(origin, origin) - 0.5*0.5;
    float disc = b*b - 4.0*a*c;           // discriminant
    tmin = tmax = 0.0;

    if (disc > 0.0) {
        // Real root of disc, so intersection
        float sdisc = sqrt(disc);
        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance
        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance

		tmax = t1;
        if (t0 >= 0.0) 
            tmin = t0;
        hit = true;
    }

    return hit;
}

// Function 736
float cylinderDist(vec3 center, vec2 dimension, vec3 point)
{
  	vec3 p = point - center;   
  	vec2 d = abs(vec2(length(p.xz), p.y)) - dimension;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 737
float sdBox2D( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 738
vec3 weightedRndDirHemisphere(vec3 n, float randomness)
{
    return mix(n, rndDirHemisphere(n), randomness);
}

// Function 739
vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)
{
    // only consider front face hits
    // Note: if you disable this line, you may get problems due to the fact that i don't push shadow rays away from the bounce surface.
    if (dot(rayDir, plane.xyz) >= 0.0)
        return vec4(-1.0);    
    
    // calculate the collision time
    float collisionTime = (-plane.w - dot(plane.xyz, rayPos)) / dot(plane.xyz, rayDir);
        
    // only consider positive hit times
    if (collisionTime < 0.0)
        return vec4(-1.0);
    
    // calculate normal
    bool fromInside = dot(plane.xyz, rayDir) > 0.0;
    vec3 normal = plane.xyz * (fromInside ? -1.0 : 1.0);
    
    // calculate tangent, bitangent
    vec3 tangent;
    if (abs(normal.x) > 0.1)
        tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));
    else
        tangent = normalize(cross(vec3(1.0, 0.0, 0.0), normal)); 
	vec3 bitangent = cross(normal, tangent);
    
    // calculate uv
    vec3 intersectionPoint = rayPos + rayDir * collisionTime;
    uv.x = dot(intersectionPoint, tangent);
    uv.y = dot(intersectionPoint, bitangent);
    
    // return hit info
    return vec4(collisionTime, normal);
}

// Function 740
vec4 flipBox(vec4 box, vec2 dims) {
    
    box = box.yxwz;
    box.xy = dims.yx - box.xy;
    
    return box;
    
}

// Function 741
float boxDistance(vec3 point, vec3 position, vec3 extents) {
    vec3 adjustedPoint = point - position;
    vec3 p = abs(adjustedPoint) - extents;
    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);
}

// Function 742
float conetip(vec2 uv, vec2 pos, float size, float min, vec3 iResolution)
{
    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);
    return max( min, 1. - length((uv - pos) * aspect / size) );
}

// Function 743
float sphere(vec3 p,float radius){
    return length(p)-radius;
}

// Function 744
bool iCylinder(in Ray r, float radius, out float t0, out float t1) {
	float a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;
	float b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);
	float c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;
	return solveQuadratic(a, b, c, t0, t1);
}

// Function 745
float sdRoundedBox(vec3 b, float r, vec3 p)
{
	return sdBox(b, p) - r;
}

// Function 746
vec3 sphereCenter2(int idx)
{
    return (noise3(float(idx) * 31.21) - vec3(0.5, 0.0, 0.5))
        * vec3(15.0, 0.5, 15.0) + vec3(0.0, 0.2, 12.0);
}

// Function 747
vec3 plane_intersect(vec3 p, vec3 d, vec3 q, vec3 n) {
    return p + d*dot(q-p, n)/dot(d, n);
}

// Function 748
float int_sphere(Ray ry, Sphere sp, out vec3 int_pt, out vec3 n)
{
    float omega = int_sphere(ry, sp);
    // now calculate the point of intersection and the surface normal
    int_pt = ry.pos + (ry.dir * omega);
    n = (int_pt - sp.pos) / sp.rad;
    return omega;
}

// Function 749
vec3 uniformHemisphere(float u1, float u2)
{
	float r=sqrt(1.-u1*u1);
	float phi=2.*PI*u2;
	return make_float3(r*cos(phi),r*sin(phi),u1);
}

// Function 750
float sdfPlane(vec3 pos, vec3 p, vec4 n){
  p = pos - p;
  n = normalize(n);
  return dot(p,n.xyz) + n.w;
}

// Function 751
float fBoxCheap(vec3 p, vec3 b) { return vmax(abs(p) - b);}

// Function 752
vec2 box(vec3 ro,vec3 rd,vec3 sz)
{
    vec3 t0 = (sz*-sign(rd) - ro) / rd,
        t1 = (sz*sign(rd) - ro) / rd;

    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));
}

// Function 753
float fBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0.))) + vmax(min(d, vec3(0.)));
}

// Function 754
bool intersectsSphere(vec3 center, float rad, vec3 origin, vec3 dir)
{
    vec3 oc = origin-center;
    float a = dot(dir,dir);
    float b = 2.0 * dot(dir,oc);
    float c = dot(oc,oc) - rad*rad;
    
    float det = b*b - 4.0*a*c;
    return (det >= 0.0) ? true : false;
}

// Function 755
vec3 sphere(vec3 p, float r)
{
    vec3 n = normalize(p);
    vec2 tc = asin(n.xz)/pi + 0.5;
	return vec3(length(p) - r, tc * 2.0);
}

// Function 756
float add_Plane( vec3 p )
{
	return p.y;
}

// Function 757
float sbox(vec2 p){ return max(p.x, p.y); }

// Function 758
SAxisAlignedBox orbitBox ()
{
	return SAxisAlignedBox
	(
		6,						//Id
		vec3(sin(2.0 + iTime*1.3),-0.2,cos(2.0 + iTime*1.3)),	//center
		vec3(0.5,0.5,0.5),	//scale
		SMaterial
		(
			1.0,				//diffuse amount
			vec3(0.0,0.0,0.0),//diffuse color
			20.0,				//specular amount
			vec3(0.0,0.0,0.0),	//specular color
			vec3(0.0,0.0,0.0),	//emissive
			0.0,				//reflection amount			
			1.0,				//refraction amount
			0.8					//refraction index			
		)
	);
}

// Function 759
void sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C) { // O, U, pos, radius, color
	
 // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;
 // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres 
 // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels
    r = length(U-P)/r; if (r>1.) return;

    U = normalize(U-P)*r;
    float A = (1.-O.a) * smoothstep(1.,.9,r);    // compositing and anti-aliasing
    vec3 N = vec3( U, sqrt(1.-dot(U,U)));
    O.rgb += A * clamp(  C*(.2 + max(0., (-N.x+N.y+N.z)/1.732))    // ambiant, diffuse
                       + pow(max(0., dot( N, normalize(vec3(-1,1,2.73)))), 50.)  // specular
                       ,0.,1.);                  // L=(-1,1,1), E=(0,0,1), z toward eye 
    O.a += A;
}

// Function 760
float getSphereMappedTexture(in vec3 pointOnSphere)
{
    /* Test to determine which face we are drawing on.
     * Opposing faces are taken care of by the absolute
     * value, leaving us only three tests to perform.
     */
    vec2 st = (
        insideBounds(sphereToCube(pointOnSphere)) +
        insideBounds(sphereToCube(pointOnSphere.zyx)) +
        insideBounds(sphereToCube(pointOnSphere.xzy)));
    
    st *= 12.0;
    float k = GetWaveDisplacement(vec3(st.x,0.0,st.y))*0.5;
    k = clamp(k,0.0,1.0);
	return 1.0-k;
    //return textureFunc(st);
}

// Function 761
float sdCappedCylinderPrecomputedQ(vec2 q, float h, float r)
{
  vec2 d = abs(q) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 762
float sphere(vec2 uv, vec2 spherePos, float sphereRad)
{
	vec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates
	float d = (1.-length(p))/H;  
	return clamp(d,-1.,1.);
}

// Function 763
float tracePlane(vec3 pos, vec3 dir, out vec3 normal) {
    float t = (-1.2 - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {
        return INF;
    }
    normal = vec3(0, 1, 0);
    return t;
}

// Function 764
float repeatedCone( vec3 p, vec3 c, vec2 cone )
{
  vec3 q = mod(p,c)-0.5*c;
  // "cone" must be normalized
  float qq = length(q.xy);
  return max( dot(cone,vec2(qq,q.z)),  // cone
              length(q)-0.125 // sphere
            );
}

// Function 765
float sdTorusYZ( const vec3 p, const vec2 t ) {
  vec2 q = vec2(length(p.yz)-t.x,p.x);
  return length(q)-t.y;
}

// Function 766
float sdPlane( vec3 p, vec4 n )
{
	// n must be normalized
	return dot( p, n.xyz ) + n.w;
}

// Function 767
vec3 GetRandomHemisphere(float r1, float r2)
{
    #if 0
    float st = sqrt(1.0 - r1 * r1);
    float phi = 2.0 * 3.15 * r2;
    float x = st * cos(phi);
    float z = st * sin(phi);
    return vec3(x, r1, z);
    #else
    float r = sqrt(r1);
    float theta = 2.0 * 3.15 * r2;
    float x = r * cos(theta);
    float y = r * sin(theta);
    return vec3(x, sqrt(max(0.0, 1.0 - r1)), y);
    #endif
}

// Function 768
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;
}

// Function 769
float box( vec3 p, vec3 b )
{
  vec3 d = abs(fract(p) - .5) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 770
vec3 randomHemisphereDirection(vec3 n,  float seed) {
    vec2 r = 2.*PI*hash2(seed);
    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
    float k = dot(dr,n);
    return k == 0. ? n : normalize(k*dr);
}

// Function 771
RaycastHit intersectPlane(Ray ray, float y, vec3 normal) {
 
    float num = -dot(normal,ray.ori-vec3(0.,y,0.));
    float denom = dot(normal, ray.dir);
	float t = num / denom;
			
	vec3 p = ray.ori + ray.dir * t;		
    
    RaycastHit hit;
    hit.point = p;
    hit.normal = normal;
    hit.id = t > 0. ? 1 : -1;
    
    return hit;
    
}

// Function 772
float sdSphere(vec3 p, float r) {
    return length(p)-r;
}

// Function 773
float curveSphereToPlane( vec3 p , float pSize)
{
    float c = cos(1.0*p.y) * .1;
    float s = sin(1.0*p.y) * .1;
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xz,p.y);
    return sphere(q,pSize);
}

// Function 774
float iCylinder( const in vec3 oc, const in vec3 rd, const in vec2 distBound, inout vec3 normal,
                 const in vec3 ca, const float ra, const bool traceCaps ) {
    float caca = dot(ca,ca);
    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    
    float a = caca - card*card;
    float b = caca*dot( oc, rd) - caoc*card;
    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;
    float h = b*b - a*c;
    
    if (h < 0.) return MAX_DIST;
    
    h = sqrt(h);
    float d = (-b-h)/a;

    float y = caoc + d*card;
    if (y >= 0. && y <= caca && d >= distBound.x && d <= distBound.y) {
        normal = (oc+d*rd-ca*y/caca)/ra;
        return d;
    } else if(!traceCaps) {
        return MAX_DIST;
    } else {
        d = ((y < 0. ? 0. : caca) - caoc)/card;

        if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {
            normal = normalize(ca*sign(y)/caca);
            return d;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 775
float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)
{
    // sampling independent computations (only depend on shape)
    vec3  ba = b - a;
    float l2 = dot(ba,ba);
    float rr = r1 - r2;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    // sampling dependant computations
    vec3 pa = p - a;
    float y = dot(pa,ba);
    float z = y - l2;
    float x2 = dot2( pa*l2 - ba*y );
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    // single square root!
    float k = sign(rr)*rr*rr*x2;
    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;
    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;
                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;
}

// Function 776
SDFResult torusSDF2( Torus torus, vec3 p )
{
    p -= torus.pos;
    
    const float scale = 0.05;
    float topdiff = clamp((0.1 - p.y), 0.0, scale);
    float botdiff = clamp((p.y - ((p.x*p.x*2.0)-scale)), 0.0, scale);
    
    if ( topdiff>0.0 && botdiff>0.0 )
    {
        float v = min(topdiff, botdiff)/scale;
        v = 3.0*v*v - 2.0*v*v*v;
        p.z-=v*scale*0.5;
    }
    
	vec2 q = vec2(length(p.xz)-torus.ring,p.y);
	return SDFResult(length(q)-torus.radius, torus.matindex);
}

// Function 777
bool isinbox(vec2 a,vec2 b,float s){a-=b;return(a>0.)&&(a<s);}

// Function 778
float sdSphere (vec3 p, float s){
	return length(p) - s;
}

// Function 779
float getSphereDist(vec3 p) {
    float sphere = length(p) - 1.;
	return sphere;
}

// Function 780
vec3 randomHemisphereDir(vec3 dir, float i)
{
	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
	return v * sign(dot(v, dir));
}

// Function 781
float rPlane(vec3 o,vec3 d,vec4 pn)
{
    float num = pn.w - dot(pn.xyz,o);
    float denom = dot(pn.xyz,d);
    float t = num/denom;
    if(t>PRECISION_STEP)
        return t;
    return CAMERA_FAR;
}

// Function 782
float sdBox2( vec2 p, vec2 b )
{
    vec2 d = abs(p) - b;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 783
float mandelbox_dist(vec3 pos) {
    vec4 p = vec4(pos, 1.0), p0 = p;
    float minRad2 = 0.25;
    vec4 scale = vec4(2.0) / minRad2;
    float absScalem1 = abs(2.0 - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));
    for (int i=0; i<20; i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
        p = p * scale + p0;
    }
    return ((length(p.xyz)*(5.0*sin(iTime/4.0)) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Function 784
float AABox(vec3 pmin, vec3 pmax, vec3 point)
{
	float dx = max(0.0, max(pmin.x - point.x, point.x - pmax.x));
    float dy = max(0.0, max(pmin.y - point.y, point.y - pmax.y));
    float dz = max(0.0, max(pmin.z - point.z, point.z - pmax.z));
    return sqrt(dx*dx + dy*dy + dz*dz);    
}

// Function 785
int get_exit_plane(const vec3 t1){
    vec3 test = step(t1.yzz,t1.xxy);
    return int(mix( test.yy*2.0, test.zz+1.0, test.xx ).x);
}

// Function 786
vec3 planeColor(vec3 loc,bool pc)
{
    loc *= 10.;
    vec2 loct = loc.xz * vec2(.1,-.1);
    vec3 ret3 = texture(iChannel2,loct,lodBias).xyz;
    if (pc) {
        if (loc.x >= 0.0)
        	ret3.r += .25;
    	if (loc.z >= 0.0)
        	ret3.b += .25;
        if (fract(loc.x*.05) >= .5)
            ret3.r -= .15;
        if (fract(loc.z*.05) >= .5)
            ret3.g -= .15;
	    vec2 loc2 = loct;
        if (fract(loc2.x*.05) >= .5)
            ret3.b -= .45;
        if (fract(loc2.y*.05) >= .5)
            ret3.g -= .45;
    }
	return ret3;
}

// Function 787
float oplanet( vec3 p ){
   	p *= rxy;
  	float d1 = length(p)-Radius.y;
  	float d2 = snoise(p.yx)*snoise(p.zy)*snoise(p.zx)*Offset.z; // displacement
    float ud = d1-d2;
    return ud<=Radius.x?ud+0.05:ud-0.05;// on creuse pour marquer la flotte
}

// Function 788
float sdYCappedCylinder( vec3 p, float h, float r )
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 789
bool boxIntersectAny( in vec3 ro, in vec3 rd, in vec3 ird, in Box box ) 
{
    vec3 n = ird*(box.cen-ro);
    vec3 k = abs(ird)*box.rad;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	return tN<tF && tF>0.0;
}

// Function 790
vec3 planeZoom(vec2 uv) {
    vec3 origin = vec3(0.0, 0.0, iTime * 5.0);
	vec3 ray = normalize(vec3(uv, 1.0)) * xrotate(iTime) * zrotate(iTime);
	float ta = (-1.0 - origin.y) / ray.y;
    float tb = (1.0 - origin.y) / ray.y;
    float t = max(ta, tb);
    vec3 view = origin + ray * t;
    float mat = max(sign(ta-tb), 0.0);
    vec3 tex = texture(iChannel1, view.xz * 0.01).xzy;
    vec3 diff = mix(tex.yxz, tex.zyx, mat);
    float fog = 1.0 / (1.0 + t * 0.1);
    return diff * fog;
}

// Function 791
vec2 sphereCoords(vec2 _st, float _scale) {
  float maxFactor = sin(1.570796327);
  vec2 uv = vec2(0.0);
  vec2 xy = 2.0 * _st.xy - 1.0;
  float d = length(xy);
  if (d < (2.0 - maxFactor)) {
    d = length(xy * maxFactor);
    float z = sqrt(1.0 - d * d);
    float r = atan(d, z) / 3.1415926535 * _scale;
    float phi = atan(xy.y, xy.x);
    uv.x = r * cos(phi) + 0.5;
    uv.y = r * sin(phi) + 0.5;
  } else {
    uv = _st.xy;
  }
  return uv;
}

// Function 792
float dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}

// Function 793
float qbox( vec3 p, float s ){
  return length(max(abs(p)-vec3(s,s,s),0.0));
}

// Function 794
float sdBox(vec3 p, vec3 s) {p=abs(p)-s;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}

// Function 795
float sdBox( vec2 p, in vec2 bounds )
{
    vec2 d = abs(p)-bounds;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 796
vec2 intersect_box(vec3 ro, vec3 rd,vec3 _min,vec3 _max)
{
    vec3 start = (_min - ro) / rd;
    vec3 end = (_max - ro) / rd;
    
    vec3 a = min(start,end);
    vec3 b = max(start,end);
    
    return vec2(
        	max(a.x,max(a.y,a.z)),
    		min(b.x,min(b.y,b.z))
        );
}

// Function 797
vec3 randomOnSphere(float seed, int i, vec3 bias)
{
#if 1 
    // something more uniformly distributed - if I can ever understand hash!
    // ahh need tan for gaussian distrib but maybe I can reformulate
    // or cube root of another hashvalue for uniform ball distribution
    // btw my hashes are *not* truly decorrelated 
    vec2 h = rndvec2(seed, i+17); //h = h.y * 2. - 1.;
    return normalize(
        distribSphere(h) + bias * SMOOTHNESS
        );
#else
    // the tan trick, ahh.  honestly, without normalizing, I have no idea how it works!
    // I have a feeling it's brighter simply because quite a lot more
    // cases wind up finding nothing due to sluggish motion due to not taking the full step it could,
    // resulting in more iterations needed, and more failure cases treated as sky.
    // anyway I redid it, now it's not nearly so clever as blackle's original
    // and I'm not sure I can put it back how it was, at this point.  Hrm.
    // but I got it to look almost the same as mine! I guess that's something.
    vec3 rnd = rndvec3(seed,i) + rndvec3(seed,i+55) + rndvec3(seed,i+99);
    rnd /= 3.;
    // https://shadertoy.com/view/3djyWW
    // also see comment by blackle, tyvm
    return normalize((normalize(tan(rnd)) + bias * SMOOTHNESS)); // why tan?!!  blackle, why?
#endif
}

// Function 798
void get_bbox(std::vector<ivec3>& mesh, int b, int e, ivec3& bbox_min, ivec3& bbox_max) {
    get_facet_bbox(mesh[b], bbox_min, bbox_max);
    for(int i=b+1; i<e; ++i) {
	ivec3 cur_bbox_min, cur_bbox_max;
	get_facet_bbox(mesh[i], cur_bbox_min, cur_bbox_max);
	bbox_min = min(bbox_min, cur_bbox_min); bbox_max = max(bbox_max, cur_bbox_max);
    }
}

// Function 799
float box(vec3 p, vec3 s)
{
   return length(max(abs(p)-s,0.));
}

// Function 800
float sphere(vec3 rp, float r) {
	return length(rp) - r;
}

// Function 801
vec2 RaySphereIntersection (in Ray ray, in Sphere sphere)
{
  vec3  h = ray.origin - sphere.center;
  float b = dot(ray.direction, h);
  float c = dot(h,h) - sqr (sphere.radius);
  float d = b*b - c;
  if (d < 0.0) return vec2(-1.0);
  d = sqrt(d);
  return vec2 (-d-b, d-b);
}

// Function 802
vec3 shadeSphere2(vec3 rayPos, vec3 normal)
{
    return vec3(0.0, 1.0, 0.0);
}

// Function 803
float g1_plane(vec3 p, rObj o) {
    return p.y - o.scale.x;
}

// Function 804
float sdBox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 805
float sphereIntersect(Ray ray, Sphere sphere){
    vec3 pos = sphere.position;
    vec3 dir = ray.direction;
    float radius = sphere.radius;
    vec3 oc = ray.origin - pos;
    float b = 2.0 * dot(oc, dir);
    float c = dot(oc, oc) - (radius * radius);
    float d = (b*b) - 4.0*c;
    if (d < 0.0) {
        return -1.0;
    }else{
        return (-b - sqrt(d)) * 0.5;
    }
}

// Function 806
float iBox( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal, 
            const in vec3 boxSize ) {
    vec3 m = sign(rd)/max(abs(rd), 1e-8);
    vec3 n = m*ro;
    vec3 k = abs(m)*boxSize;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if (tN > tF || tF <= 0.) {
        return MAX_DIST;
    } else {
        if (tN >= distBound.x && tN <= distBound.y) {
        	normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
            return tN;
        } else if (tF >= distBound.x && tF <= distBound.y) {
        //	normal = sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
            return tF;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 807
float hTorus(in vec4 pos, in float r1, in float r2)
{
    return length(vec3(length(pos.xz)-r1,pos.y, pos.w))-r2;
}

// Function 808
float sphere(vec3 _p, vec3 _c, float _r)
{
	return length(_p-_c)-_r;
}

// Function 809
vec2 planeUV(vec3 origin, vec3 n, vec3 p)
{
    vec3 uAxis;
    vec3 vAxis;
    planeUVAxis(origin, n, uAxis, vAxis);
    vec3 diff = p - origin;
    float uVal = dot(diff, uAxis);
    float vVal = dot(diff, vAxis);
    return vec2(uVal, vVal);
}

// Function 810
vec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) 
{
    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));
    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));
    
    return normalize(n1 + n2);
}

// Function 811
float tracePlane (vec3 pos, vec3 dir,  out vec3 normal) {
    float t = (-1.2 - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    vec3 worldPos = t*dir + pos;
    if (dot(worldPos.xz, worldPos.xz) >= 50.0) {
        return INF;
    }   
    normal = vec3(0, 1, 0);
    return t;
}

// Function 812
vec2 intersectCylinder(vec2 ro, vec2 rd, vec2 org, float rad)
{
    return intersectSphere(vec3(ro, 0), vec3(rd, 0), vec3(org, 0), rad);
}

// Function 813
vec3 randomSphereDir(in vec2 rnd)
{
	float s = rnd.x*PI*2.;
	float t = rnd.y*2.-1.;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 814
float sdGridOfSpheres(in vec3 pos) {
    float num = 3.0;
    float lim = 0.3;
    float rad = 0.75 * lim / (num - 1.0);
     
    pos.y -= lim + rad - 0.4;
    
    float step = (lim * 2.0) / (num - 1.0);
    
    float d = 1e9;
    
    vec3 c = vec3(0.0);
    
    for (c.x = -lim; c.x <= lim; c.x += step) {
    for (c.y = -lim; c.y <= lim; c.y += step) {
    for (c.z = -lim; c.z <= lim; c.z += step) {
        d = min(d, sdSphere(pos - c, rad));
    }}}
    return d;
}

// Function 815
float distToExitAtmosphere(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_R * A_R;
    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);
}

// Function 816
float sdCone( const vec3 p, const vec2 c ) {
    float q = length(p.yz);
    return dot(c,vec2(q,p.x));
}

// Function 817
Hit sphereSdf(vec3 p, vec3 c, float r) {
    Hit hit;
    hit.dist = length(p - c) - r;
    hit.color = vec3(1.0);
    return hit;
}

// Function 818
float sdf_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return length(q) - torus.y;
}

// Function 819
float fBox2Cheap(vec2 p, vec2 b) {
	return vmax(abs(p) - b);
}

// Function 820
bool RayIntersectAABox (in SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 821
float iSphere( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal,
               const float sphereRadius ) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - sphereRadius*sphereRadius;
    float h = b*b - c;
    if (h < 0.) {
        return MAX_DIST;
    } else {
	    h = sqrt(h);
        float d1 = -b-h;
        float d2 = -b+h;
        if (d1 >= distBound.x && d1 <= distBound.y) {
            normal = normalize(ro + rd*d1);
            return d1;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 822
vec3 Cylinder(vec3 x){
    return vec3(sin(x.x),x.y,cos(x.x));
}

// Function 823
float sdBox(vec3 p,vec3 s){p=abs(p)-s;return(length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.));}

// Function 824
float fSphere(vec3 p, float r) { return length(p) - r; }

// Function 825
Result planeIntersect (in Ray ray, in vec3 p, in vec3 n, in int id) {
    Result res = nullResult;

	// are ray and plane parallel?
    if (dot (n, ray.rd) > 1e-6) {
        return res;
    }

    // determine ray-plane intersection point
    vec3 i = ray.ro + (dot(p - ray.ro, n) / dot (ray.rd, n)) * ray.rd;

    // prepare result
    res.hit = true;
    res.point = i;
    res.normal = normalize (n);
    res.dist = distance (i, ray.ro);
    res.id = id;

    return res;
}

// Function 826
float sphere(in vec3 p, in float radius)
{
    return length(p) - radius;
}

// Function 827
MapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){
 
  MapValue mv;
  mv.material = m;
   
  mv.signedDistance = plane(p,origin,normal);
  return mv;
}

// Function 828
float RaySphere( vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius )
{
	vec3 oc = rayOrigin - spherePos;
	
	float b = dot( oc, rayDir );
	float c = dot( oc, oc ) - sphereRadius * sphereRadius;
	float h = b * b - c;
	
	float t;
	if ( h < 0.0 )
    {
		t = -1.0;
    }
	else
    {
		t = ( -b - sqrt( h ) );
    }
	return t;
}

// Function 829
float GetDistanceCylinderZ(const in vec3 vPos, const in float r)
{
	return length(vPos.xy) - r;
}

// Function 830
float sd_box(vec3 p, vec3 half_size) {
    vec3 q = abs(p) - half_size;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 831
float PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}

// Function 832
float sphere(vec3 pos, float radius) {
    return length(pos) - radius;
}

// Function 833
float mandelbox(vec3 z)
{
    float scale = 2.0;
	vec3 offset = z;
	float dr = 1.0;
	for (int n = 0; n < 10; n++)
    {
		boxFold(z,dr);
		sphereFold(z,dr);
        z = scale * z + offset;
        dr = dr * abs(scale) + 1.0;
	}
	float r = length(z);
	return r / abs(dr);
}

// Function 834
float plane(float p, float dist){
  return p-dist;
}

// Function 835
vec4 texBox(vec3 ro, vec3 rd, float d, vec3 nor, mat4 txx)
{
    vec3 pos = (ro+rd*d);
    vec3 opos = (txx*vec4(pos,1.0)).xyz;
	vec3 onor = (txx*vec4(nor,0.0)).xyz;
    vec3 tc=abs(onor.x)*texture( iChannel2, 0.5*opos.yz ).xyz + 
                   abs(onor.y)*texture( iChannel2, 0.5*opos.zx ).xyz + 
                   abs(onor.z)*texture( iChannel2, 0.5*opos.xy ).xyz;
    return vec4(tc,1.);
}

// Function 836
float BoxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 837
float sdTorusZ( vec3 p, vec2 t )
{
  return length( vec2(length(p.xy)-t.x,p.z) )-t.y;
}

// Function 838
vec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {
    asteroidTransForm( ori, id );
    asteroidTransForm( dir, id );
    
    vec2 td = vec2(0,1);
    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {
        td.y = asteroidMap(ori + dir * td.x, id);
        td.x += td.y;
    }
    return td;
}

// Function 839
float iPlane( in vec3 ro, in vec3 rd, in float h )
{
    return (h-ro.y)/rd.y;
}

// Function 840
float intersectCylinder( in Ray ray, in Cylinder cylinder, out vec3 normal, out vec2 uv ){
	// 
	float t_min = 0.0;
	float t_max = ray.distance;

	uv = vec2(0);
	normal = vec3(0);
	//   
    vec3  ce = vec3( cylinder.center.x, 0.0, cylinder.center.z );
    vec3  rc = ray.origin - ce;
    float a = dot( ray.direction.xz, ray.direction.xz );
    float b = dot( rc.xz, ray.direction.xz );
    float c = dot( rc.xz, rc.xz ) - cylinder.radius;
    float h = b*b - a*c;
    if( h<0.0 ) return ray.far;
	h = sqrt( h );
	//  
	float t1 = (-b - h)/a;
	float t2 = (-b + h)/a;
	float t = t1;
	bool flag_inside = true;	// 
	if (t<t_min) {
		t1 = t_min;
		t = t2;
		flag_inside = false;	//
	}
	if (t<t_min || t > t_max) return ray.far; 		// 
	vec3 p1 = ray.origin + t1 * ray.direction;
	vec3 p2 = ray.origin + t2 * ray.direction;
	if ( abs(p1.y) > cylinder.height && abs(p2.y) > cylinder.height) return ray.far;

	// 
	if ( abs(p1.y) > cylinder.height) {
		flag_inside = false;
		t = t2;
	}
	
	// 
	vec3 p = ray.origin + t * ray.direction;
	//   
	normal = normalize(vec3(ce.x - p.x, 0., ce.z - p.z)) * (flag_inside ? -1. : 1.);
	//normal = normalize(ce - p) * (flag_inside ? -1. : 1.);
	// 
	vec3 n = (p - cylinder.center);
	uv = vec2 (
		atan(n.x, n.z) / (2.*PI) + 0.5,
		(n.y * 0.5 + 0.5)
	) * 0.4;

	return t;
}

// Function 841
SDFResult planeSDF( Plane plane, vec3 p )
{
    return SDFResult(dot(plane.norm, p) - dot(plane.pos, plane.norm), plane.matindex);
}

// Function 842
float iPlane(in vec3 ro, in vec3 rd) {
	// equation of a plane, y=0 = ro.y + t*rd.y
    return -ro.y/rd.y;
}

// Function 843
float d_cone( vec2 p, vec2 c, float rot )
{
    if (p.x > 0.)
        return 1e8;
    p = rotate(p, rot);
    float q = 16.*length(p.x);
    return dot(c,vec2(q,p.y));
}

// Function 844
vec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)
{
    //all hard coded numbers depend on the 'r's
    
    int sections = int(2.*max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 1.5/(max(tkp.kq,tkp.kp));
    const int maxIterations = 50;//50
    
    float minDist;
    float bestT;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotSqDistanceDerivative(t, p, tkp);
            dt *= lerningRate;
            
            if(abs(dt) < 0.001)
            {
                float sqDist = torusKnotSqDistance(t, p, tkp);
        
                if(sqDist <= sq(tkp.r3))
                {
                    return vec3(t, sqDist, 1.);
                }
                
                break;
            }
            
            t -= dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                break;
            }
        }
    }
    
    return vec3(0.);
}

// Function 845
float SphereSD(vec3 position, vec3 center, float radius)
{
    return length(position - center) - radius;
}

// Function 846
float sdCylinder(vec3 p, vec3 c)
{
    return length(p.xz - c.xy) - c.z;
}

// Function 847
vec4 planet(vec3 view) {
#ifdef SHOW_PLANET
    const float PLANET_RADIUS = 0.65;
    if (view.y > -PLANET_RADIUS) {
        return vec4(0.0);
    } 
    
    // Compute the point on the planet sphere
    float angle  = atan(view.x, view.z);
    float radius = sqrt((1.0 + view.y) / (1.0 - PLANET_RADIUS));
    
    vec3 s = vec3(radius * normalize(view.xz), sqrt(1.0 - square(radius)));
    
    
    vec3 dir = s;
    dir = rotation(0.0, iTime * 0.01) * dir;
    float latLongLine = 0.0;// (1.0 - pow(smoothstep(0.0, 0.04, min(abs(fract(atan(dir.y, length(dir.xz)) / (15.0 * deg)) - 0.5), abs(fract(atan(dir.x, dir.z) / (15.0 * deg)) - 0.5)) * 2.0), 10.0));
    
    // Antialias the edge of the planet
    vec4 surface = vec4(1.2 * vec3(1.0, 0.3, 0.4) * 
  			(noise(dir * 39.0 + 3.5) * 0.5 + noise(dir * 26.0) + 2.0 * noise(dir * 13.0 + 1.0)) *
         vec3(s.yx * 0.5 + 0.5, 0.0).rbg, smoothstep(0.992, 0.988, radius));

    // Keep the clouds above the planet
    vec4 cloud = vec4(vec3(1.5),
                      smoothstep(1.0, 0.995, radius) * 
                      square(NOISE(vec2(iTime * 0.1, 0.0) + dir.xz * 11.0 * square(dir.y) + dir.yx * 3.0 + dir.zy * 1.2)));
    
    return vec4(
        mix(surface.rgb, cloud.rgb, cloud.a) * (max(0.1, s.y) * vec3(1.0 - latLongLine)),
        max(surface.a, cloud.a));
#else
    return vec4(0.0);
#endif
}

// Function 848
float Cylinder_intersection(in vec3 rd, out vec3 iPoint)
{
  float a = dot(rd.xz,rd.xz);
  float disc = a;
  if (disc < 0.0) return -1.0;

  iPoint = rd * inversesqrt(disc);
  if (dot(iPoint,vec3(1.0,0.0,0.0)) < 0.0) return -1.0;
 
  if (iPoint.y > 0.3 || 
      iPoint.y < -0.3) return -1.0;
  return 1.0;
}

// Function 849
bool isRayIntersectSphere(vec3 ro, vec3 rd, vec3 center, float radius)
{
    float tmin = -1.0, tmax = -1.0;
    float d = IntersectSphere(ro, rd, center, radius, tmin, tmax);
    return tmin>-1.0;
}

// Function 850
float sphereRadius(float t)
{
	t = abs(t);
	t *= 0.001;
	return clamp(t*t, 1000.0/iResolution.y, 3000.0);
}

// Function 851
float BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)
{
    point -= boxPos;
    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P
    
    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c
    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU
    vec3 q = abs(point) - boxRadius;
    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;
}

// Function 852
bool spherehit(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)
{
    vec3 rosp = ro - sp;
    float a = dot(rd, rd);
    float b = 2.0 * dot(rd, rosp);
    float c = dot(rosp, rosp) - (r * r);
    float b2m4ac = b * b - 4.0 * a * c;
    if (b2m4ac >= 0.0) {
        float r = sqrt(b2m4ac);
        t1 = (-b - r) / (2.0 * a);
        t2 = (-b + r) / (2.0 * a);
        return t1 >= 0.0 || t2 >= 0.0;
    } else {
        return false;
    }
}

// Function 853
vec3 randomSphereDirection() {
	vec2 r = hash2() * TWO_PI;
	return vec3(sin(r.x) * vec2(sin(r.y), cos(r.y)), cos(r.x));
}

// Function 854
vec4 sphere(vec3 pos, float radius)
{
    return vec4(
        length(pos) - radius,
        normalize(pos)
    );
}

// Function 855
float sdf_box(vec3 p, vec3 center, vec3 half_bound)
{
    p = abs(p - center) - half_bound;
    return max3(p.x, p.y, p.z);
}

// Function 856
float intersectSphere(vec3 C, float r, vec3 P, vec3 w) {	
	vec3 v = P - C;
	float b = -dot(w, v);
	float c = dot(v, v) - square(r);
	float d = (square(b) - c);
	if (d < 0.0) { return inf; }	
	float dsqrt = sqrt(d);
	
	// Choose the first positive intersection
	return min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));
}

// Function 857
float sdPlane(vec3 p, vec4 n) {
	return dot(p, n.xyz) + n.w;
}

// Function 858
float ssdHemisphere(vec3 p, vec3 n) {
    return acos(dot(p, n)) - M_PI_2;
}

// Function 859
vec4 getSphere(int num) {

    float time = iTime/2. + float(num);
    float constRandom = rand(vec2(float(num), float(num) + 7.));
    
    float rStep = 1.;
    
    vec3 sizePos = vec3(
        sin(time + constRandom) + 1., 
        cos(time + constRandom * rStep++) + 1., 
        sin(time + constRandom * rStep++) + 1.) * 2.;
        
    sizePos *= sin(time + constRandom * rStep++) - .5;
    sizePos.x += float(NUM_SPHERES - NUM_SPHERES/2)/100.;
    sizePos.y  = sizePos.y * 0.8 + 0.3;
    
    sizePos.z *= 2.;

    return vec4(sizePos, 1.);
        
}

// Function 860
float obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){
    vec3 tp = p-center;
    vec2 d = abs(vec2(length(tp.yz),tp.x)) - size;
    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;
}

// Function 861
float TraceBox( const in C_Ray ray, const in vec3 vCorner1, const in vec3 vCorner2 )
{
	vec3 vMin = min(vCorner1, vCorner2);
	vec3 vMax = max(vCorner1, vCorner2);
	
	float fNear = -kMaxDist;
	float fFar = kMaxDist;
	
	TraceSlab(ray, vMin, vMax, vec3(1.0, 0.0, 0.0), fNear, fFar);
	TraceSlab(ray, vMin, vMax, vec3(0.0, 1.0, 0.0), fNear, fFar);
	TraceSlab(ray, vMin, vMax, vec3(0.0, 0.0, 1.0), fNear, fFar);
	
	if(fNear > fFar)
	{
		return kMaxDist;
	}
	
	if(fFar < 0.0)
	{
		return kMaxDist;
	}
	
	return fNear;
}

// Function 862
vec3 unitVectorOnHemisphere(vec3 n) {
  float r = random();
  float angle = random() * (2.0 * PI);
  float sr = sqrt(r);
  vec2 p = vec2(sr * cos(angle), sr * sin(angle));
  vec3 ph = vec3(p.xy, sqrt(1.0 - dot(p, p)));

  vec3 b1, b2;
  orthonormalBasis(n, b1, b2);
  return b1 * ph.x + b2 * ph.y + n * ph.z;
}

// Function 863
vec2 intersectSpheres(in vec3 p, bool refrSph) {
    // hit object ID is stored in res.x, distance to object is in res.y

    vec2 res = vec2(ID_VOID, 2000.0);

    if (refrSph) res = vec2(ID_SPHERE_REFRACT, sdSphere(p + vec3(380.0, 468.8, 166.0), SPHERE_REFRACT.x));
    vec2 obj = vec2(ID_SPHERE_REFLECT, sdSphere(p + vec3(190.0, 448.8, 365.0), SPHERE_REFLECT.x));
    if (obj.y < res.y) res = obj;

    return res;
}

// Function 864
vec3 nSphere(in vec3 l, in sph s) {
    return (l - s.l) / s.r;   
}

// Function 865
float udBox( vec3 p, vec3 b ){
  return length(max(abs(p)-b,0.0));
}

// Function 866
float sdHypersphere(in vec4 p, in float r, out vec4 d) {
  d = abs(p) - r;
  return length(p) - r;
}

// Function 867
vec3 TexPlanet1( vec2 vTexCoord, float fRandom, float fHRandom )
{
    float fShade;
    float fMirrorY = 64.0 - abs(vTexCoord.y - 64.0);
    
    fShade = cos( 3.14 * (fMirrorY - 36.0) / 36.0 ) * 0.5 + 0.5;
    fShade *= fRandom * 0.5 + 0.5;

    float fStreak = clamp(0.0, 1.0, fHRandom + fMirrorY / 32.0);
    fShade *= fStreak;
    
	vec3 col = mix( vec3(59), vec3(147), fShade) / 255.0;

    vec2 vMin = vec2(4,7);
    vec2 vMax = vec2(58,60);
    
    float fIndex = 0.0;
    
    if ( vTexCoord.x > 128.0 )
    {
        vMin.x += 128.;
        vMax.x += 128.;
        
        fIndex += 2.0;
    }
    else
    if ( vTexCoord.x > 64.0 )
    {
        vMin.x += 64.;
        vMax.x += 64.;
        
        fIndex += 1.0;
    }
    
    if ( vTexCoord.y > 64.0 )
    {
        vMin.y += 62.;
        vMax.y += 62.;
        
        fIndex += 3.0;
    }
    
    if ( all( greaterThanEqual( vTexCoord, vMin ) ) &&
         all( lessThanEqual( vTexCoord, vMax ) ))
    {
        col = vec3(0.0);
        
        vec2 vUV = (vTexCoord - (vMin + 1.0)) / (vMax - vMin - 2.);
	    if ( all( greaterThanEqual( vUV, vec2(0.0) ) ) &&
    	     all( lessThan( vUV, vec2(1.0) ) ))
    	{
            col = vec3(0.0);

            float fSize = mod((1.0 + fIndex) * 1.45, 1.0);
            float fOffset = mod((1.0 + fIndex) * 1.84, 1.0);
            
            vec2 vXY = vUV * 2.0 - 1.0;
            vXY += fOffset;
            float l = length(vXY);

            vec3 vPlanetCol = vec3(0.5,0.2,.4) + vec3(8.3,2.24,5.89) * fIndex;
            vPlanetCol = mod( vPlanetCol, vec3(1));
            vPlanetCol *= vec3(1., .2, .01);
            vPlanetCol = normalize(vPlanetCol);
            
            if ( fIndex == 4.0 )
            {
            	col = vPlanetCol * max( 0.0, fRandom - l * 0.5 );
            }
            else
            {
            	// planet                       
                if ( l < fSize )
                {                
                    col = vPlanetCol;

                    vec3 vLight = vec3(0.1,0.5,.4) + vec3(5.435,32.345,32.923) * fIndex;
                    vLight = mod( vLight, 1.0);
                    vLight.xy = vLight.xy * 2.0 - 1.0;
                    vLight = normalize(vLight);


                    vec2 vD = vXY;
                    vec3 vNorm = vec3(vD, sqrt( fSize * fSize - l * l ));
                    float fPlanetShade = max(0.0, dot( vNorm, vLight));
                    col *= fPlanetShade; 
                }
                else
                {
                    float f = min(1.0, fRandom / .75);
                    col = vec3(1.) * pow( f, 100.0) * 0.25;
                    /*
                    if ( fRandom > 0.75 )
                    {
                        col = vec3(0.5);
                    }*/
                }
            }
            
            
            col += 0.1;
            // sheen
            col += max(0.0, 1.0 - (vUV.x + vUV.y) * 2.0) * 0.3;
        }
        
    }
	//if( Screen( col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, out vec2 vUV )
    
    
	return col;    
}

// Function 868
bool cylinder(vec3 ro, vec3 rd, float r, float h, out float tn, out float tf) {
	float a = dot(rd.xy, rd.xy), b = dot(ro.xy, rd.xy),
		  d = b*b - a*(dot(ro.xy, ro.xy) - r*r);    
	if(d < 0.) return false;
	d = sqrt(d);
	tn = (-b - d)/a; tf = (-b + d)/a;
	a = min(tf, tn); tf = max(tf, tn); tn = a; // order roots
	a = ro.z + tn * rd.z;
    b = ro.z + tf * rd.z;
	// top, bottom
	vec2 zcap = h*vec2(.5, -.5), cap = (zcap - ro.z) / rd.z;
    tn = a < zcap.y ? cap.y : a > zcap.x ? cap.x : tn;
	tf = b < zcap.y ? cap.y : b > zcap.x ? cap.x : tf;
    return tf > 0. && tf > tn;
}

// Function 869
float BoxIntersect( vec3 p, vec3 boxOrigin, vec3 boxDimensions)
{
  p = Translate(p, boxOrigin);
  vec3 q = abs(p) - boxDimensions;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 870
float leftplane  (vec3 pos){return  pos.x+2.0;}

// Function 871
vec3 uniformUnitHemisphere(uvec2 seed, vec3 n) {
    float t = uintBitsToFloat01(hash(seed))*2.0*PI;
    float u = uintBitsToFloat11(hash(seed + 6756984u));
    
    vec3 p = vec3(vec2(cos(t), sin(t)) * sqrt(1.0 - u*u), u);
    return p * (dot(n, p) > 0.0 ? 1.0 : -1.0); // sign(dot(n, p)) could result 0.0;
}

// Function 872
float signedDistanceSphere(in vec2 position, float radius ) { return length(position)-radius; }

// Function 873
float sdConeSection( vec3 p, float h, float r1, float r2 )
{
  float d1 = -p.y - h;
  float q = p.y - h;
  float si = 0.5*(r1-r2)/h;
  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );
  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);
}

// Function 874
vec3
rayOnHemisphere(float seed, vec3 nor)
{
    float u = hash( 78.233 + seed);
    float v = hash( 10.873 + seed);

    float a = 6.2831853 * v;
    u = 2.0*u - 1.0;
    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );   
}

// Function 875
float sdTorus( vec3 p, vec2 s ) {
  vec2 q = vec2(length(p.xz)-s.x,p.y);
  return length(q)-s.y;
}

// Function 876
float box(vec3 p, vec3 b)
{
    vec3 q = abs(p) - b;
    return max(q.x,max(q.y,q.z));//cheaper?
    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 877
RaycastHit intersectSphere(Ray ray, vec3 center, float radius) {
    
    float a = dot(ray.dir, ray.dir);
    float b = 2. * dot(ray.dir, ray.ori - center);
    float c = dot(ray.ori - center, ray.ori - center) -(radius * radius);
    float det = (b * b) - 4. * a * c;

	float lambda = (-b -sqrt(det)) / (2. * a);
	vec3 p = ray.ori + lambda * ray.dir;
	vec3 n = p - center;
    
    RaycastHit hit;
    hit.point = p;
    hit.normal = normalize(n);
    hit.id = (det >= 0. && lambda >= 0.) ? 0 : -1;
    
    return hit;
    
}

// Function 878
vec3 GetPlaneColor(vec3 hitAt, vec3 L, vec3 N, vec3 V)
{
  
    vec2 planeUV = vec2(80.0 + hitAt.x, hitAt.z) / 200.0;  
    vec3 col = CheckerBoard2(planeUV, vec3(0.1), vec3(0.5), 20.0);
    col =  0.5 * col + 0.5 * texture(iChannel0,V).xyz;
    //Shadows
    float shadowT = 0.0;
    int shadowHit = InShadow(hitAt, L,shadowT);
    if(shadowHit  > 1)
    {
      col *= 0.72;
    }
    return col;
}

// Function 879
float sdPlane( vec3 p, vec4 n )
{
   	p = vec3( p.z, p.x, -p.y ); // Coord fix
    // n must be normalized
          
    vec3 p0 = vec3(p.x, p.y, p.z);

    float fgProf = 0.3 * smoothstep( 2.5, 3.0, abs( p0.y ) );
    float bgProf = 2.0 * smoothstep( 4.5, 5.5, abs( p0.y ) );
    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy / 10. ).r, 0.0, 1.0 );
    float bg = 0.2 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy / 50.).r, 0.0, 2.0 );
    float displace = 1.5 * fg + 3.5 * bg;
    
    float sGround = dot(
        vec3( p.x, p.y, max( p.z + displace, p.z ) ),
        n.xyz )
        + n.w;
    
    sGround *= 0.5;
    
  	return sGround;
}

// Function 880
float fTorus(vec3 p, float smallRadius, float largeRadius) {
	return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

// Function 881
float sphere(vec3 r, float a)
{
    return length(r) - a;
}

// Function 882
vec4 link_ui_box() {
    
    return vec4(inset_ctr.x + 2.85*text_size,
                dfunc_y - 0.5*text_size,
                0.3*text_size, 0.5*text_size);
    
}

// Function 883
float CrossInSphere( in vec3 p, in float r, in float s )
{
  float d1 =  sdCross(p, s);  // cross
  float d2 = length(p) - r;   // sphere
  return max (d1,d2);         // intersection
}

// Function 884
bool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)
{
    vec3 relativeRayPos = rayPos_ - pos;
    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);
    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);
    
    float lengthCorrection = length(projectedRayDir);
    projectedRayDir /= lengthCorrection;
    
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = projectedRayPos;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, projectedRayDir);

	float c = dot(m, m) - radius * radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }

    // adjust distance
    dist /= lengthCorrection;

    // enforce height - note we may be invalid height for the first distance but not the second.
    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;
    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)
    {
        dist = -b + sqrt(discr);
        dist /= lengthCorrection;
        relativeHitPos = relativeRayPos + rayDir_ * dist;
        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)
      		return false;
    }
        
	if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.hitAnObject = true;
        info.objectPass = OBJECTPASS_RAYTRACE;
        info.dist = dist;        
        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);
		info.material = material;        
        return true;
    }
    
    return false;
}

// Function 885
float sdBox( in vec2 p, in vec2 c, in vec2 b ) 
{
    vec2 q = abs(p-c) - b;
    return min(max(q.x,q.y),0.0) + length(max(q,0.0));
}

// Function 886
v0 cylinderZ(v2 u,v0 r,v0 h){return max(length(u.xy)-r,abs(u.z)-h);}

// Function 887
vec3 fibonacci_sphere(int i, int n)
{
    vec2 pt = vec2(2.*PI*mod((float(i))/PHI, 1.), acos(1. - float(2*i+1)/float(n)));
    return vec3(cos(pt.x)*sin(pt.y), sin(pt.x)*sin(pt.y), cos(pt.y)); 
}

// Function 888
DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}

// Function 889
float mainBox(vec3 p)
{
    p.y += 3.2;
    
    float r = 1.0 - (smoothstep(.6, .75, abs(p.z)) + smoothstep(.6, .75, abs(p.x)));    
    float d = fBox(p, vec3(2.45, 2.25, 2.45) - r * .1);
    
    vec3 rp = rotateY(p, .787);
    d = max(d, fBox(rp, vec3(3.45)));
    
    return d;
}

// Function 890
float boxSDF( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 891
SAxisAlignedBox GetFloorBox()
{
	return SAxisAlignedBox
	(
		5,						//Id
		vec3(0.0,-1.6,0.0),		//center
		vec3(10.0,0.1,10.0),	//scale
		SMaterial
		(
			vec3(1.0,1.0,1.0),	//diffuse color
			20.0,				//specular amount
			vec3(0.0,0.0,0.0)	//specular color
		)
	);
}

// Function 892
float sphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius)
{
    vec3 rc = rayOrigin - sphereCenter; // create arrow pointing from sphereCenter to ray origin
    
    float c = dot(rc, rc) - (sphereRadius * sphereRadius); // magnitude of rc minus sphere radius squared
    
    float b = dot(rayDirection, rc); // dot product between ray direction and rc which gives a unit vector along rc's axis
    
    float d = b * b - c; // b squared minus c (gives distance squared)
    
    float t = -b - sqrt(abs(d)); // sqrt to get distance d; -b minus distance d
    
    float st = step(0.0, min(t, d)); // step from 0 the min of distance d or t
    
    return mix(-1.0, t, st); // return the interpolation between t and stepped t (st)
}

// Function 893
vec2 _box(vec3 p, vec3 b, float m){vec3 d = abs(p) - b;return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), m);}

// Function 894
float box(vec3 p, float r) {
  p=abs(p)-r;
  return max(p.x, max(p.y,p.z));
}

// Function 895
float sdTorus( vec3 p, vec3 c, vec2 t )
{
  p = p - c;
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 896
float sphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 897
float imTestSphere(vec3 p) {
    float r = 0.5;
    return p.x*p.x + p.y*p.y + p.z*p.z - r*r;
}

// Function 898
float sdCone(vec3 p, float radius, float height) {
	vec2 q = vec2(lengthn(p.xz, 8.0), p.y);
	vec2 tip = q - vec2(0.0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.0)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0.0)));
	}
	return d;
}

// Function 899
vec4 trace_spheres( in vec3 rayo, in vec3 rayd )
{
 	vec3 p = rayo;// + rayd;
	const vec3 voxelSize = vec3(1.0,1.0,1.0);

	// find current voxel

	vec3 V = floor(p);
	vec3 V0 = V;
	vec3 step = sign(rayd); // step length for each dimension +1 or -1 (what about zero?? - zero is fine)

	vec3 lp = p - V; // local coords inside voxel

	vec3 tmax;// = abs((voxelSize - lp) / rayd);

	if (step.x > 0.0) tmax.x = voxelSize.x - lp.x; else tmax.x = lp.x;
	if (step.y > 0.0) tmax.y = voxelSize.y - lp.y; else tmax.y = lp.y;
	if (step.z > 0.0) tmax.z = voxelSize.z - lp.z; else tmax.z = lp.z;

	tmax /= abs(rayd);

	vec3 tdelta = abs(voxelSize / rayd);
    
    // voxel traversal algorithm by Andrew Woo (http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf)

	for(int i=0; i<60; i++) {
		if (tmax.x < tmax.y) {
			if (tmax.x < tmax.z) {
				V.x += step.x;
				tmax.x += tdelta.x;
			} else {
				V.z += step.z;
				tmax.z += tdelta.z;
			}
		} else {
			if (tmax.y < tmax.z) {
				V.y += step.y;
				tmax.y += tdelta.y;
			} else {
				V.z += step.z;
				tmax.z += tdelta.z;
			}
		}

		//if (dot(V-V0,V-V0) < 8.0) continue; // cull sphere around viewer
		if (V.x > -1.0 && V.x < 1.0 && V.y > -1.0 && V.y < 1.0) continue; // cull a pillar (box-shaped) along the z-axis

		// now we have the voxel, check for intersections with sphere
		vec3 c = V + voxelSize*0.5 + 0.4*mhash3(V.x+50.0*V.y+2500.0*V.z); // sphere at center of voxel + rnd displacement

		float r = voxelSize.x*0.10; // sphere is 20% of voxel size
		float r2 = r*r;

		vec3 p_minus_c = p - c;
		float p_minus_c2 = dot(p_minus_c, p_minus_c);
		float d = dot(rayd, p_minus_c);
		float d2 = d*d;
		float root = d2 - p_minus_c2 + r2;
		float dist;

		const float divFogRange = 1.0/30.0; // 50-20
		const vec3 fogCol = vec3(0.3, 0.3, 0.6);
		const vec3 sunDir = vec3(-0.707106, 0.707106, 0.0);

		if (root >= 0.0) {
			dist = -d - sqrt(root);
			float z = max(0.0, 2.5*(dist-20.0)*divFogRange);
			float fog = clamp(exp(-z*z), 0.0, 1.0);

			//float3 col = mhash3(V.x+50*V.y+2500*V.z+12121);
			vec3 col = getColor(V);

			//float3 col = float3(dist/50.0, -dist, dist*dist/(50*50));

			vec3 normal = normalize(p + rayd*dist - c);
			float light = 0.7 + 1.0 * clamp(dot(normal, sunDir), 0.0, 1.0);

			col = clamp(light*col, 0.0, 1.0);

			col = mix(fogCol, col, fog);

	
            return vec4( col, 1.0);
		}

		if ( dot(V-V0,V-V0) > 2500.0) break; // outside voxel grid
	}

	return vec4(0.3, 0.3, 0.6, 1.0);
}

// Function 900
vec3 renderPlanePoint(vec2 uv, float zoom) 
{ 
    return vec3(uv.x, A_LA_FOV + zoom, uv.y);
}

// Function 901
vec4 boxIntersection(vec3 viewingNormal, vec3 boxPos){
    vec3 X = vec3(1,0,0);
    vec3 Y = vec3(0,1,0);
   	vec3 Z = vec3(0,0,1);
    
    float halfWidth = 0.5;
    for (int i = 0; i < 2; ++i){
        
        
        vec2 uv;
        vec3 pos;
        
        vec3 planePos = boxPos - halfWidth*X;
        float t = planeIntersection(X,viewingNormal,planePos);
        if (t != 0.){
            pos = t*viewingNormal;

            uv = (pos - planePos).yz;
            if (UVINBOUND){
                return vec4(uv,t,0.);
            }
        }

        planePos = boxPos - halfWidth*Y;
        t = planeIntersection(Y,viewingNormal,planePos);
        if (t != 0.){
            pos = t*viewingNormal;

            uv = (pos - planePos).xz;
            if (UVINBOUND){
                return vec4(uv,t,0.1);
            }
        }
        planePos = boxPos - halfWidth*Z;
        t = planeIntersection(Z,viewingNormal,planePos);;
        if (t != 0.){
            pos = -t*viewingNormal;

            uv = (pos + planePos).xy;
            if (UVINBOUND){
                return vec4(uv,t,0.2);
            }
        }

        X *= -1.;
        Y *= -1.;
        Z *= -1.;
    }
    return vec4(0);
}

// Function 902
float distSphere(vec3 pos, float r)
{
	return length(pos)-r;
}

// Function 903
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	lowp vec2 r = hash2();
    
	lowp vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	lowp vec3  vv = cross( uu, n );
	
	lowp float ra = sqrt(r.y);
	lowp float rx = ra*cos(6.2831*r.x); 
	lowp float ry = ra*sin(6.2831*r.x);
	lowp float rz = sqrt( 1.0-r.y );
	lowp vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 904
float BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal ){
	vec3 invDir = 1.0 / r.direction;
	vec3 tmin = (minCorner - r.origin) * invDir;
	vec3 tmax = (maxCorner - r.origin) * invDir;
	vec3 real_min = min(tmin, tmax);
	vec3 real_max = max(tmin, tmax);
	float minmax = min( min(real_max.x, real_max.y), real_max.z);
	float maxmin = max( max(real_min.x, real_min.y), real_min.z);
	if (minmax > maxmin){
        if (maxmin > 0.0){ // if we are outside the box
			normal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);
			return maxmin;	
		}
        else if (minmax > 0.0){ // else if we are inside the box
			normal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);
			return minmax;
		}
	}
	return INFINITY;
}

// Function 905
float torusSDF(vec3 p, float smallRadius, float largeRadius) {
	return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

// Function 906
float planeSD(vec3 p) {
    
    return min(sphere(p - vec3(1,1,1)), p.y+2.);
}

// Function 907
bool subtract_Sphere(in Sphere cut, in Ray r, float tmin, in HitRecord recSolid, inout HitRecord rec, in Material inside){  
 	bool hit = true;
    HitRecord recCut;   
    if(hit_sphere( cut, r, tmin, 1000.0, recCut)) //cut could be behind tmax
    {   
        hit = false;        
        // Hit the inside, starting from inside both spheres
        if(recCut.t2 < tmin && recSolid.t2 < tmin && recSolid.t > recCut.t){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        // Hit the inside, starting from inside the cut but outside the solid
        if(recCut.t2 < tmin && recSolid.t > tmin && recCut.t > recSolid.t && recCut.t < recSolid.t2){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        
        // no hit, starting from inside the cut but outside the solid
        if(recCut.t2 < recSolid.t && recCut.t > recSolid.t && recCut.t2 < tmin){
            return false; 
        }
        
        // Hit the inside
        if(recCut.t2 > recSolid.t && recCut.t2 < recSolid.t2 && recCut.t < recSolid.t){
        	rec.pos = pointOnRay(r, recCut.t2);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t2;
            rec.material = inside;
            return true;
        }
        // Hit the outside
        if ( recCut.t > recSolid.t || recCut.t2 < recSolid.t ) { // both intersections were before the hit point
            hit = true;
        }
        
    }
    if(hit){
        rec = recSolid;
    }
    return hit;  
}

// Function 908
vec3 nSphere(vec3 pos, vec3 c){

    return normalize(pos-c);
    
}

// Function 909
float hyperplaneBounded (vec4 p, float h, float b) {
    return max(abs(p.y-h)-0.1, 
        max(
        	abs(p.x)-b,
        	max(
        		abs(p.z)-b,
    			abs(p.w)-b
        	)
        )
    );
}

// Function 910
vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){
	sundir.y = max(sundir.y, -0.07);
	float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);
	float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);
	float raysundt = pow(abs(dot(sundir, raydir)), 2.0);
	float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);
	float mymie = sundt * special_trick * 0.2;
	vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);
	vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;
	vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));
	bluesky2 *= special_trick * (0.24 + raysundt * 0.24);
	return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;
}

// Function 911
float sdBox(vec2 q)
{
    float d = sdSlab(q, vec2(1, 0));
    d = max(d, sdSlab(q, vec2(0, 1)));
    if (d > 0. && // early out, don't bother unless outside
    	all(lessThan(vec2(1.), abs(q)))) // in corner voronoi regions
        d = distance(abs(q), vec2(1)); // must replace distance
    return d;
}

// Function 912
float sdTorus(vec3 p, vec2 r){
	float x = length(p.xz) - r.x;
    return length(vec2(x, p.y)) - r.y;
}

// Function 913
float SD_Torus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 914
float torus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz) - t.x, p.y);
  return length(q) - t.y;
}

// Function 915
float boxIntersect(vec3 ro, vec3 rd, vec3 b) {
    vec3 m = 1.0 / rd;
    vec3 n = m * ro;
    vec3 k = abs(m) * b;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float tN = max(max(t1.x, t1.y), t1.z);
    float tF = min(min(t2.x, t2.y), t2.z);
    return (tN > tF || tF < 0.0) ? -1.0 : tN;
}

// Function 916
float boxdf( vec3 p, vec3 bounds )
{
    vec3 boxd = abs(p) - .5 * bounds;
    return length(max(boxd, 0.));
}

// Function 917
float sdCylinder(vec3 p, vec3 a, vec3 b, float r) {
    vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap) / dot(ab, ab);
    
    vec3 c = a + t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-0.5)-0.5)*length(ab);
    float e = length(max(vec2(x, y), 0.0));
    float i = min(max(x, y), 0.0);
    return e+i;
}

// Function 918
Hit traceCylinder(Ray ray, Cylinder cylinder)
{
    // center the cylinder, normalize axis
    vec3 cc = 0.5 * (cylinder.bottom + cylinder.top);
    float ch = length(cylinder.top - cylinder.bottom);
    vec3 ca = (cylinder.top - cylinder.bottom) / ch;
    ch *= 0.5;

    vec3  oc = ray.origin - cc;

    float card = dot(ca, ray.direction);
    float caoc = dot(ca, oc);
    
    float a = 1.0 - card*card;
    float b = dot(oc, ray.direction) - caoc*card;
    float c = dot(oc, oc) - caoc*caoc - cylinder.radius*cylinder.radius;
    float d = b*b - a*c;
    
    Hit hit;
    
    if(d >= 0.0)
    {
        float sqrtd = sqrt(d);
        
        // body
        hit.t = (-b - sqrtd) / a;
        float y = caoc + hit.t*card;
        if(hit.t < t_max && hit.t > t_min)
        {
            if(abs(y) < ch)
            {
                hit.normal = normalize(oc + hit.t*ray.direction - ca*y);
                hit.mat = cylinder.mat;
                hit.hit = true;
                return hit;
            }
        }
        
        // caps
        float sy = sign(y);
        hit.t = (sy*ch - caoc) / card;
        if(hit.t < t_max && hit.t > t_min)
        {
            if(abs(b + a * hit.t) < sqrtd)
            {
                hit.normal = ca * sy;
                hit.mat = cylinder.mat;
                hit.hit = true;
                return hit;
            }
        }
    }

    hit.hit = false;
    return hit;
}

// Function 919
SDFResult torusSDF( Torus torus, vec3 p )
{
    p -= torus.pos;
    
	vec2 q = vec2(length(p.xz)-torus.ring,p.y);
	return SDFResult(length(q)-torus.radius, torus.matindex);
}

// Function 920
bool renderPlanet(Ray eyeRay, float minDistanceToPlanet, float maxDistanceToPlanet, inout Radiance3 L_o, inout Point3 hitPoint) {    
    Surfel surfel;
    
    if (intersectScene(eyeRay, minDistanceToPlanet, maxDistanceToPlanet, surfel)) {
        // Render the planet
        Radiance3 L_directOut = shade(surfel, w_i, -eyeRay.direction, B_i);

        // Clouds vary fairly slowly in elevation, so we can just measure at the
        // surface as an estimate of the density above the surface
        float cloudShadow = pow4(1.0 - clamp(cloudDensity(surfel.position, time), 0.0, 1.0));
        
        // "Ambient"
        Irradiance3 E_indirectIn = max(Irradiance3(0), Irradiance3(0.4) - 0.4 * Irradiance3(surfel.normal.yxx)); 
        Radiance3 L_indirectOut = 
            mix(E_indirectIn * surfel.material.color,
                mix(Color3(1.0), surfel.material.color, surfel.material.metal) * texture(iChannel0, reflect(w_i, surfel.normal)).rgb * 2.7, surfel.material.smoothness) * (1.0 / pi);
        
        hitPoint = surfel.position;
        L_o = (L_directOut + L_indirectOut) * cloudShadow;

        if (debugMaterials) {
            L_o = surfel.material.color;
        }
            
        return true;
    } else {
        // Missed the bounding sphere or final ray-march
        return false;
    }    
}

// Function 921
float dePlane(vec3 pos){
    return pos.y+SpheresRadius+2.*MinDist;
}

// Function 922
float coneSDF(vec3 p, float h, float r) {
    float r2 = ((h/2.0)-p.y)/h;
    r2 *= r;
    r2 = clamp(r2,0.0,r);
    return cylSDF(p,h,r2);
}

// Function 923
float boxDist(vec2 p, vec4 b) {
    
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
    
}

// Function 924
vec3 traceSphere(in vec3 ro, in vec3 rd, float r, out float t1, out float t2)
{
    t1=t2=-1.0;
    vec3 X = ro + rd * (dot(normalize(-ro), rd)) * length(ro);
    float disc = r*r-pow(length(X), 2.0);
    if (disc < 0.0) return vec3(1000000.0);
    disc=sqrt(disc);
    vec3 p=X-disc*rd;
    t1=length(p-ro);t2=t1+disc*2.;
    return p;
}

// Function 925
float sdfPlane(in vec3 p, in vec4 normal)
{
  	// n must be normalized
  	return dot(p, normal.xyz) + normal.w;
}

// Function 926
float sdf_quarter0_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(-pos.y, pos.x));
}

// Function 927
float sBox(vec3 p, vec3 b){

  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 928
float fBox(vec3 p, vec3 b) {
   vec3 d = abs(p) - b;
   return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// Function 929
float sdPlane( vec3 p ) {
	return p.y+14.+0.05*cos(p.x+iTime*2.);
}

// Function 930
vec3 textureBox2(vec3 p,vec3 p2)
{
    vec3 ap=abs(p),f=step(ap.zxy,ap.xyz)*step(ap.yzx,ap.xyz);
    vec2 uv=f.x>.5?p.yz:f.y>.5?p.xz:p.xy;
    vec3 n=normalize(-transpose(boxxfrm)*(f*sign(p)));
    float l=clamp(-normalize(p2-vec3(0,1,0)).y,0.,1.);
    vec3 d=1.*(1.-smoothstep(-1.,2.5,p2.y))*vec3(0.3,0.3,.7)+smoothstep(0.95,.97,l)*clamp(-n.y,0.,1.)*2.*vec3(1,1,.8)+
        	smoothstep(0.9,1.,l)*clamp(-n.y,0.,1.)*vec3(1,1,.8);
    return texture(iChannel3,uv).rgb*d;
}

// Function 931
float sdLineBox(vec3 p, vec3 b, float r)
{
    p = abs(p);
    float cx = sdCapsule(p, b, vec3(b.x,b.y,0), r);
    float cy = sdCapsule(p, b, vec3(0,b.y, b.z), r);
    float cz = sdCapsule(p, b, vec3(b.x,0, b.z), r);
    return min(min(cx, cy),cz);
}

// Function 932
float fSphere( vec3 p, float s )
{
    return length(p)-s;
}

// Function 933
float TraceCylinder( const in C_Ray ray, vec3 vPos, vec3 vDir, float fRadius, float fLength )
{	
	vec3 vOffset = vPos - ray.vOrigin;
	
	vec3 vProjOffset = Project(vOffset, vDir);
	vec3 vProjDir = Project(ray.vDir, vDir);
	float fProjScale = length(vProjDir);
	vProjDir /= fProjScale;
	
	// intersect circle in projected space
	
	float fTClosest = dot(vProjOffset, vProjDir);
	
	vec3 vClosest = vProjDir * fTClosest;
	float fDistClosest = length(vClosest - vProjOffset);
	if(fDistClosest > fRadius)
	{
		return kMaxDist;
	}
	float fHalfChordLength = sqrt(fRadius * fRadius - fDistClosest * fDistClosest);
	float fTIntersectMin = (fTClosest - fHalfChordLength) / fProjScale;
	float fTIntersectMax = (fTClosest + fHalfChordLength) / fProjScale;
	
	// cap cylinder ends
	TraceSlab(ray, vPos, vPos + vDir * fLength, vDir, fTIntersectMin, fTIntersectMax);

	if(fTIntersectMin > fTIntersectMax)
	{
		return kMaxDist;
	}
	
	if(fTIntersectMin < 0.0)
	{
		return kMaxDist;
	}
	
	return fTIntersectMin;		
}

// Function 934
float IntersectPlane(Ray r, Plane p) {
    float Vd = dot(r.d, p.n);
    float t = -1.0;
    float d = -1.0;
    if(Vd<0.0) {
        float V0 = -(dot(p.n, r.o)+length(p.o-r.o));
        float t = V0/Vd;
        if(t>=0.0) {
            d = t;
        }
    }
    return d;
}

// Function 935
void box_fold(inout vec3 z, inout float dz) {
    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;
}

// Function 936
float boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
	vec3 p = (txx*vec4(pos,1.0)).xyz;
	vec3 n = (txx*vec4(nor,0.0)).xyz;
    
    // 8 verts
    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);
    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);
    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);
    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);
    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);
    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);
    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);
    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);
    
    // 12 edges    
    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( clamp(dot(v0,v2),-1.0,1.0) );
    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( clamp(dot(v2,v3),-1.0,1.0) );
    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( clamp(dot(v3,v1),-1.0,1.0) );
    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( clamp(dot(v1,v0),-1.0,1.0) );
    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( clamp(dot(v4,v5),-1.0,1.0) );
    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( clamp(dot(v5,v7),-1.0,1.0) );
    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( clamp(dot(v7,v6),-1.0,1.0) );
    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( clamp(dot(v3,v7),-1.0,1.0) );
    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( clamp(dot(v6,v4),-1.0,1.0) );
    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( clamp(dot(v5,v1),-1.0,1.0) );
    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( clamp(dot(v0,v4),-1.0,1.0) );
    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( clamp(dot(v6,v2),-1.0,1.0) );
    
    // 6 faces    
    float occ = 0.0;
    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );
    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );
    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );
    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );
    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );
    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );
        
    return occ / 6.2831;
}

// Function 937
float intersect_sphere(ray_ ray, sphere_ sphere, inout vec4 color)
{
	vec3 v = ray.origin - sphere.center;
	float a0 = dot(v, v) - sphere.radius * sphere.radius;
	float DdotV = dot(ray.dir, v);

	if (DdotV <= 0.0){
		float discr = DdotV * DdotV - a0;
		if (discr >= 0.0){
			float distance = -DdotV - sqrt(discr);
			vec3 pos = ray.origin + ray.dir * distance;
			vec3 normal = normalize(pos - sphere.center);

			// float depth = 255.0 - min((distance / 20.0) * 255.0, 255.0);
			// color = vec4((normal + 1.0) * 0.5, 1.0);
			// color = vec4(vec3(depth / 255.0), 1.0);

			float NdotL = dot(normal, light.dir);
			vec3 H = normalize(light.dir - ray.dir);
			float NdotH = dot(normal, H);
			vec3 diffuse = vec3(1.0, 0.0, 0.0) * max(NdotL, 0.0);
			vec3 specular = vec3(1.0, 1.0, 1.0) * pow(max(NdotH, 0.0), 32.0);
        	color = vec4(vec3(light.color * (diffuse + specular)), 1.0);
			return 1.0;
		}
	}
	return 0.0;
}

// Function 938
float fCone(vec3 p, float radius, float height) {
   vec2 q = vec2(length(p.xz), p.y);
   vec2 tip = q - vec2(0, height);
   vec2 mantleDir = normalize(vec2(height, radius));
   float mantle = dot(tip, mantleDir);
   float d = max(mantle, -q.y);
   float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
   
   // distance to tip
   if ((q.y > height) && (projected < 0.)) {
      d = max(d, length(tip));
   }
   
   // distance to base ring
   if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
      d = max(d, length(q - vec2(radius, 0.)));
   }
   return d;
}

// Function 939
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0));
}

// Function 940
float PlaneSD(vec3 position, vec3 normal, float height)
{
    return dot(position, normal) + height;
}

// Function 941
float dist_box( vec3 pos, vec3 size ) {
	return dist_roundbox( pos, size, 0.2);
    //return sdTorus( pos, vec2(size.x, size.x * 0.5));
}

// Function 942
float SdBox( vec2 vPos, vec2 vMin, vec2 vMax )
{
    vec2 vMid = (vMin + vMax) * .5;
    return SdBox( vPos - vMid, (vMax - vMin) * .5 );
}

// Function 943
bool rayPlaneIntersection( Ray ray, Plane plane, out float t ){
    float dotVN = dot( ray.dir, plane.abcd.xyz );
   
    if ( abs( dotVN ) < EPSILON ) {
        return false;
    }
    
	t = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;
    
    return ( t > 0.0 );
}

// Function 944
float sdBox(vec3 p,vec3 s){
    p=abs(p)-s;
    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);
}

// Function 945
float sdBox(vec2 p, vec2 b) {
    vec2 r = abs(p) - b;
    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));
    //vec2 d = abs(p) - b;
  	//return length(max(d,0.0));
}

// Function 946
float udBox(vec3 p, vec3 b)
{
    return length(max(abs(p)-b, 0.0));
}

// Function 947
float plane(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 planenorm, float dist) {
  
  float dn = dot(r,planenorm);
  float dplane = (dist-dot(s,planenorm))/dn;
  if(dplane<d && dplane>0.0) {
    vec3 p = s + dplane * r;
    vec3 hole = vec3(4);
    p = abs(fract(p/hole+0.5)-.5);
    if(max(p.x,max(p.y,p.z))>0.44) {
      d = dplane;
      n = planenorm * sign(dn);
      emi = vec3(0.2,0.9,0.5) * 5.0 * val2;
    }
  }
  
  return d;
}

// Function 948
bool closestPolyPlane(vec3 poly[POLY_SZ], float epPoly, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
    closestPolyPlane(poly, pPlane, nPlane, out0, out1);
    return removeThickness(epPoly, 0., out0, out1);
}

// Function 949
float intersect_sphere(vec3 ro, vec3 rd){
    vec3 oc = ro - sphere.position;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - pow(sphere.diameter, 2.0);
    float h = b*b - c;
    if(h < 0.0)
        return -1.0;
    return -b - sqrt(h);
}

// Function 950
float isectPlane(vec3 ro,vec3 rd,vec3 n){
  float d=dot(ro,n)/dot(-rd,n);
  return d<0.?FAR:d;
}

// Function 951
float sphere_sdf( vec3 p, vec3 c, float r)
{
  return length(p - c) - r;
}

// Function 952
float sphereSize(float d)
{
    d = pix * d;
    return d;

}

// Function 953
vec4 Sphere1(vec4 sphereBase, float uRandom)
{
	return sphereBase + VecOsc(
							vec4(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0, 0),
							vec4(20, 100, 100, 0) +
							VecOsc(
								vec4(1.0328 / 14.0, 1.1381 / 6.0, 1.0238 / 10.0, 0),
								vec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);
}

// Function 954
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box, float border)
{
    fragColor.rgb *= mix(1.-shadow_box(fragCoord, box, border), 1., .5);
}

// Function 955
float sdBox4( vec4 p, vec4 b )
{
    vec4 d = abs(p) - b;
    return min(maxElem(d),0.0) + length(max(d,0.0));
}

// Function 956
vec3 plane (vec3 p, vec3 d) {
	float x = dot(-p,vec3(0,0,1))/dot(d,vec3(0,0,1));
    return p + d*x;
}

// Function 957
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) 
{
    // convert from ray to box space
	vec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;
	vec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*boxHalfSizes;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );
	
	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	vec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (abs(normal.x) > 0.9)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (abs(normal.y) > 0.9)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
    
    vec3 relPoint = roo + rdd * timeNear;
    
	uv = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);    

    // convert to ray space
	
	normal = (inverseBoxTransform * vec4(normal,0.0)).xyz;

	return vec4( timeNear, normal );
}

// Function 958
float sdBox(in vec2 p, in vec2 b)
{
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// Function 959
float sdCone( vec3 p, vec2 c, float h )
{
  // c is the sin/cos of the angle, h is height
  // Alternatively pass q instead of (c,h),
  // which is the point at the base in 2D
  vec2 q = h*vec2(c.x/c.y,-1.0);
    
  vec2 w = vec2( length(p.xz), p.y );
  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );
  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );
  float k = sign( q.y );
  float d = min(dot( a, a ),dot(b, b));
  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );
  return sqrt(d)*sign(s);
}

// Function 960
bool inCone(vec3 p, vec3 o, vec3 n, float side) {
	return side*dot(normalize(o-p), n) >= cosAngle;
}

// Function 961
float sphereSDF(vec3 samplePoint, float p, float s) {
    return length(samplePoint - p) - s;
}

// Function 962
float DistanceToSphere(vec3 P, Object sphere)
{
	vec3 V = P - sphere.pos;
	return length(V) - sphere.radius;
}

// Function 963
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 964
vec2 sphere(vec2 uv, float rsq)
{
    // zoom in on the texture
    float r = 0.3 * sqrt(rsq);
    
    // flatten the center piece for a 2d look
    return uv * max(0.24, r);
}

// Function 965
float sdSphere(vec3 pos,float radius){
	return length(pos)-radius;

}

// Function 966
float sdCappedCylinder( vec3 p, vec2 h )
      {
        vec2 d = abs(vec2(length(p.xz),p.y)) - h;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
      }

// Function 967
float Box(vec3 pos, vec3 b)
{
    return length(max(abs(pos)-b,0.0));
}

// Function 968
float Box(vec3 p, vec3 b)             { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }

// Function 969
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return -1.0;
	
	h = sqrt(h);
	
	float t1 = -b - h;
	float t2 = -b + h;
	
	if( t1<eps && t2<eps )
		return -1.0;
	
	if( t1<eps )
		return t2;
	
	return t1;
}

// Function 970
float iTorus( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
              in vec2 torus ) {
    // bounding sphere
    vec3 tmpnormal;
    if (iSphere(ro, rd, distBound, tmpnormal, torus.y+torus.x) > distBound.y) {
        return MAX_DIST;
    }
    
    float po = 1.0;
    
	float Ra2 = torus.x*torus.x;
	float ra2 = torus.y*torus.y;
	
	float m = dot(ro,ro);
	float n = dot(ro,rd);

#if 1
	float k = (m + Ra2 - ra2)/2.0;
    float k3 = n;
	float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;
    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);
    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);
#else
	float k = (m - Ra2 - ra2)/2.0;
	float k3 = n;
	float k2 = n*n + Ra2*rd.z*rd.z + k;
	float k1 = k*n + Ra2*ro.z*rd.z;
	float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;
#endif
    
#if 1
    // prevent |c1| from being too close to zero
    if (abs(k3*(k3*k3-k2)+k1) < 0.01) {
        po = -1.0;
        float tmp=k1; k1=k3; k3=tmp;
        k0 = 1.0/k0;
        k1 = k1*k0;
        k2 = k2*k0;
        k3 = k3*k0;
    }
#endif
    
    // reduced cubic
    float c2 = k2*2.0 - 3.0*k3*k3;
    float c1 = k3*(k3*k3-k2)+k1;
    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;
    
    c2 /= 3.0;
    c1 *= 2.0;
    c0 /= 3.0;

    float Q = c2*c2 + c0;
    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;
    
    float h = R*R - Q*Q*Q;
    float t = MAX_DIST;
    
    if (h>=0.0) {
        // 2 intersections
        h = sqrt(h);
        
        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root
        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root

        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));
    
        float y = sqrt(0.5*(length(s)+s.x));
        float x = 0.5*s.y/y;
        float r = 2.0*c1/(x*x+y*y);

        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;
        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;

        if (t1 >= distBound.x) t=t1;
        if (t2 >= distBound.x) t=min(t,t2);
	} else {
        // 4 intersections
        float sQ = sqrt(Q);
        float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );

        float d2 = -(w+c2); if( d2<0.0 ) return MAX_DIST;
        float d1 = sqrt(d2);

        float h1 = sqrt(w - 2.0*c2 + c1/d1);
        float h2 = sqrt(w - 2.0*c2 - c1/d1);
        float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;
        float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;
        float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;
        float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;

        if (t1 >= distBound.x) t=t1;
        if (t2 >= distBound.x) t=min(t,t2);
        if (t3 >= distBound.x) t=min(t,t3);
        if (t4 >= distBound.x) t=min(t,t4);
    }
    
	if (t >= distBound.x && t <= distBound.y) {
        vec3 pos = ro + rd*t;
        normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));
        return t;
    } else {
        return MAX_DIST;
    }
}

// Function 971
float sBox(in vec3 p, in vec3 b, in float sf){

  p = abs(p) - b + sf;
  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;
  
  // Unsigned.
  //return length(max(abs(p) - b + sf, 0.)) - sf;
}

// Function 972
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)
{
    vec3 oc = ro - sph.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - sph.w * sph.w;
    float h = b * b - c;
    if (h < 0.0)
        return -1.0;
    h = sqrt(h);
    float t1 = -b - h;
    float t2 = -b + h;
    if (t1 < .001 && t2 < .001)
        return -1.0;
    if (t1 < .001)
        return t2;
    return t1;
}

// Function 973
float
sphere3_sd( in float sph_r, in vec3 p )
{
    return length3(abs(p)) - sph_r;
}

// Function 974
vec4 PlaneYIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 planePos)
{
    // Ray trace a ground plane to infinity
    pos -= planePos;
    float t = -pos.y / dirVecPLZNormalizeMeFirst.y;
    if (t > 0.0) {
        vec3 normal = vec3(0.0, 1.0 * sign(-dirVecPLZNormalizeMeFirst.y), 0.0);
        return vec4(normal, t);
    } else return vec4(bignum);
}

// Function 975
float sdBox(vec2 p, vec2 b) {
    vec2 r = abs(p) - b;
    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));
}

// Function 976
vec3 randomHemisphereDir(in vec3 dir, in float i)
{
	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
	return v * sign(dot(v, dir));
}

// Function 977
float PlaneSDF(vec3 eye, vec3 p, vec4 n)
{ // NOTE: n must be normalized
    return dot(eye-p, n.xyz) + n.w;
}

// Function 978
vec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    
	vec3 w = normalize(d);
    vec3 u = normalize(cross(w.yzx, w));
    vec3 v = cross(w, u);
	return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;
}

// Function 979
float sdSpinningBox(vec3 p)
{
    if (iLoopedTime < NUM)
    {
        p.x -= NUM;
        p.z -= floor(iLoopedTime);
        p.zy = rotate(p.zy, fract(iTime)*halfPi);
    }
    else
    {
        p.x += floor(iLoopedTime-NUM-NUM+1.);
        p.z -= NUM;
        p.xy = rotate(p.xy, (1.-fract(iTime))*halfPi);
    }
    return sdBox(p+vec3(.5,-.5,.5), vec3(.4)) - .1;
}

// Function 980
float sdSphere(vec3 p, float s)
{
	return length(p)-s;
}

// Function 981
d222 fBoxCheap(c2 p,v2 s){;return ma(suab(p,s));}

// Function 982
float box(vec3 v, float r, float m) {
  return max(length(v.xy)-r, abs(v.z)-m);
}

// Function 983
float sBoxS(in vec2 p, in vec2 b, in float sf){

  //return length(max(abs(p) - b + sf, 0.)) - sf;
  p = abs(p) - b + sf;
  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;
}

// Function 984
float sdSphere( vec3 p, float s ) {
    return length(p)-s;
}

// Function 985
float sdBox(vec3 p, vec3 radius)
{
  vec3 dist = abs(p) - radius;
  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));
}

// Function 986
float osphere( vec3 p, float r ){ return length(p)-r;}

// Function 987
float sdBox(vec3 p, vec3 b) {
        return length(max (abs(p) -b ,0.0) );
}

// Function 988
float sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }

// Function 989
float obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){
    vec3 tp = p-center;
    vec2 d = abs(vec2(length(tp.yz),tp.x)) - (size-roundness);
    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;
}

// Function 990
SAxisAlignedBox GetbackBox1()
{
	return SAxisAlignedBox
	(
		6,						//Id
		vec3(0.0,0.0,3.0),		//center
		vec3(10.0,3.0,0.1),		//scale
		SMaterial
		(
			vec3(0.0,0.0,0.8),  //diffuse color
			20.0,				//specular amount
			vec3(0.0,0.0,0.0)	//specular color
		)
	);
}

// Function 991
float
half_cone_pos_sd( in vec2 c, in vec3 p )
{
    vec2 c1 = vec2(c.y,-c.x);
    return dot( c1, vec2(length(p.xy), p.z) );
}

// Function 992
vec4 cylindernormal(vec4 ray, vec4 pos, float size,
        float lenrayyzw,
        float lenrayzwx,
        float lenraywxy,
        float lenrayxyz) {
    vec4 lens = vec4(
        sphIntersect(ray.yzw*lenrayyzw,vec4(pos.yzw,size)).y*lenrayyzw,
        sphIntersect(ray.zwx*lenrayzwx,vec4(pos.zwx,size)).y*lenrayzwx,
        sphIntersect(ray.wxy*lenraywxy,vec4(pos.wxy,size)).y*lenraywxy,
        sphIntersect(ray.xyz*lenrayxyz,vec4(pos.xyz,size)).y*lenrayxyz);
    float len = max(max(max(lens.x,lens.y),lens.z),lens.w);
    vec4 mask = step(len,lens);
    pos += ray*len;
    return -pos/size*(1.0-mask);
}

// Function 993
vec3 deform_torus(vec3 p)
{
    float d = p.y + 1.1*sin(5.0*atan(p.z,p.x));
    vec3 pr = vec3(p.x,d,p.z);
    return pr;
}

// Function 994
float drawSphere(in vec3 p){
  
    p = fract(p)-.5;    
    return dot(p, p);
    
    //p = abs(fract(p)-.5);
    //return dot(p, vec3(.5));  
}

// Function 995
void createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {
    obj.type_ = OBJ_PLANE;
    obj.mtl_id_ = mtl;
    obj.transform_ = transform;
    obj.transform_inv_ = mat4Inverse( obj.transform_ );
    obj.params_[0] = minX;			//radius
    obj.params_[1] = minY;			//min z
    obj.params_[2] = maxX;			//max z
    obj.params_[3] = maxY;			//max phi
    obj.params_[4] = 0.0;		//not used
    obj.params_[5] = 0.0;		//not used
}

// Function 996
float sdBox2( vec3 p, vec3 b )
{
    p=abs(p)-b;
    return max(max(p.x,p.y),p.z);
}

// Function 997
float box(vec2 p) {
	return length(max(abs(p.x),abs(p.y))) - 0.5 * sin(iTime - length(p));
}

// Function 998
vec4 dualSphereStaticWarp(dualR3 p, float scale)
{
	return (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale)) + dMul(dSet(scale), dMul(dSet(0.02), deformX(p, scale)));
}

// Function 999
float sdSphere(vec3 p, float s)
{
	return length(p) - s;
}

// Function 1000
float sdfPlane(vec3 p){
    return p.y +1.5;
}

// Function 1001
vec3 planet_palette(float x) {
  vec3 col = vec3(0.1, 0.6, 0.9);
  col = (col + (0.2 * sin(((6.28318531 * x) + vec3(0.3, 0.2, 0.1)))));
  col = (col + (0.1 * sin(((14.4513262 * x) + vec3(0.1, 0.2, 0.3)))));
  return col;
}

// Function 1002
float sdTorus(vec3 p, vec2 t)
{
	p.y *= 0.7;
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  return length(q)-t.y;
}

// Function 1003
bool sBox( in vec3 ro, in vec3 rd, in vec3 rad, out float tN, out float tF)  {
    vec3 m = 1./rd, n = m*ro,
    	k = abs(m)*rad,
        t1 = -n - k, t2 = -n + k;
	tN = max( max( t1.x, t1.y ), t1.z );
	tF = min( min( t2.x, t2.y ), t2.z );
	return !(tN > tF || tF < 0.);
}

// Function 1004
vec2 bounding_sphere(const float distance_squared, const float radius, const int material)
{
    return vec2(fast_sqrt(distance_squared)+-radius, material);
}

// Function 1005
vec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = texture( sam, p.yz );
  vec4 y = texture( sam, p.zx );
  vec4 z = texture( sam, p.xy );
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1006
float cylinder(vec3 p, float r, float h){
    return max(length(p.xz) - r, -(h-abs(p.y)) );
}

// Function 1007
bool subtract_Box(in Box cut, in Ray r, float tmin, in HitRecord recSolid, inout HitRecord rec, in Material inside){  
 	bool hit = true;
    HitRecord recCut;     
    if(hit_box( cut, r, tmin, 1000.0, recCut)) //cut could be behind tmax
    {   
        hit = false;
        // Hit the inside, starting from inside both objects
        if(recCut.t2 < tmin && recSolid.t2 < tmin && recSolid.t > recCut.t){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = recCut.normal2;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        // Hit the inside, starting from inside the cut but outside the solid
        if(recCut.t2 < tmin && recSolid.t > tmin && recCut.t > recSolid.t && recCut.t < recSolid.t2){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = recCut.normal2;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        // no hit, starting from inside the cut but outside the solid
        if(recCut.t2 < recSolid.t && recCut.t > recSolid.t && recCut.t2 < tmin){
            return false;
        }
        // Hit the inside
        if(recCut.t2 > recSolid.t && recCut.t2 < recSolid.t2 && recCut.t < recSolid.t){
        	rec.pos = pointOnRay(r, recCut.t2);
            rec.normal = recCut.normal2;
            rec.t = recCut.t2;
            rec.material = inside;
            return true;
        }
        // Hit the outside
        if ( recCut.t > recSolid.t || recCut.t2 < recSolid.t) { // both intersections were before the hit point
            hit = true;
        }
    }
    if(hit){
        rec = recSolid;
    }
    return hit;  
}

// Function 1008
float fBoxCheap(vec3 p,vec3 b){vec3 q=(abs(p)-b);return max(max(q.x,q.y),q.z);}

// Function 1009
vec3 projVecOnPlane(vec3 u, vec3 n) {
    return u - dot(u,n)*n;
}

// Function 1010
vec3 PointOnHemisphereUniform( inout uint seed, vec3 n )
{
    vec3 dir = PointOnSphereUniform( seed );
    if ( dot( dir, n ) < 0.0 )
    {
        dir = -dir;
    }
    return dir;
}

// Function 1011
float fBox2(vec2 p, vec2 b) {
   vec2 d = abs(p) - b;
   return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));
}

// Function 1012
void planet_texture(in vec2 x, out vec3 col)
{
    vec3 light_orange = vec3(1.00,0.69,0.05),
        orange = vec3(0.95,0.45,0.01),
        dark_orange = vec3(0.98,0.73,0.01);
    
    //rock like appearance
    float d;
    mfnoise(x, 1.,400.,.65,d);
	col = mix(vec3(0.19,0.02,0.00), vec3(0.91,0.45,0.02), .5+.5*d);
    
    // big structures
    stroke(d,.01, d);
    col = mix(mix(.8*vec3(0.99,0.49,0.02),c.yyy,d*clamp(.2-.5*x.y/12.,0.,1.)), col, smoothstep(-.05,.05,d));
    col = mix(col, vec3(0.15,0.05,0.00), clamp(.2-.5*x.y/12.,0.,1.));
}

// Function 1013
float sdRoundCone( in vec3 p, in float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));
    
    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
    
    return dot(q, vec2(a,b) ) - r1;
}

// Function 1014
float sdBox(vec3 p, vec3 b)
{
  vec3  di = abs(p) - b;
  float mc = maxComp(di);
  return min(mc,length(max(di,0.0)));
}

// Function 1015
vec4 getSphereColor(vec3 P, vec3 center, float rad)
{    
    vec3 N = normalize(P - center);
    vec3 L1 = normalize(getLightPos() - P);
    vec3 V = normalize(eye - P);
    vec3 R = 2.0 * dot(N,L1) * N - L1;
    
    vec3 ambient = ia*0.5;
    vec3 diffuse = dot(N,L1) * id;
    vec3 specular = pow(max(dot(R,V),0.0),alpha) * is;
    
    return vec4(ambient + diffuse + specular, 1.0) * sphereColor;
}

// Function 1016
vec3 GetRandomWeightedHemisphereDir( vec3 seed, vec3 normal )
{
    // gets a point on a hemisphere oriented toward normal,
    // but weighted by cosine of angle from the normal
    
    // start with random point on disc
    vec2 r2 = rand2( seed );
    float angle = r2.x * TWOPI;
    vec2 discPoint = vec2( cos( angle ), sin( angle ) ) * sqrt( r2.y );
    
    return GetHemisphereDirForDiscPoint( normal, discPoint );
}

// Function 1017
float skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf
){float y=within(top.z,bottom.z,uv.y)
 ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}

// Function 1018
seg tPlane(in ray r, in pln p) {
    float t = dot(p.n, p.l - r.o) / dot(p.n, r.d);
    return seg(vec2(t, t+eps), ivec2(p.d, -p.d));
}

// Function 1019
float sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)
{
	vec3 rc = ray-center;
	float c = dot(rc, rc) - (radius*radius);
	float b = dot(dir, rc);
	float d = b*b - c;
	float t = -b - sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return mix(-1.0, t, st);
}

// Function 1020
float sphere(vec3 p, vec4 spr)
{
        return length(spr.xyz-p) - spr.w;
}

// Function 1021
float sdBox(vec3 p, vec3 b) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1022
float fSphere(vec3 p, float r) {
	return length(p) - r;
}

// Function 1023
float ConeIntersect( vec3 p0, float r0, vec3 p1, float r1, Ray r, out vec3 n ){
	r0 += 0.1;
	float t = INFINITY;
	vec3 locX;
	vec3 locY;
	vec3 locZ=-(p1-p0)/(1.0 - r1/r0);
	
	Ray ray = r;
	ray.origin-=p0-locZ;
	
	if(abs(locZ.x)<abs(locZ.y))
		locX=vec3(1,0,0);
	else
		locX=vec3(0,1,0);
		
	float len=length(locZ);
	locZ=normalize(locZ)/len;
	locY=normalize(cross(locX,locZ))/r0;
	locX=normalize(cross(locY,locZ))/r0;
	
	mat3 tm;
	tm[0]=locX;
	tm[1]=locY;
	tm[2]=locZ;
	
	ray.direction*=tm;
	ray.origin*=tm;
	
	float dx=ray.direction.x;
	float dy=ray.direction.y;
	float dz=ray.direction.z;
	
	float x0=ray.origin.x;
	float y0=ray.origin.y;
	float z0=ray.origin.z;
	
	float x02=x0*x0;
	float y02=y0*y0;
	float z02=z0*z0;
	
	float dx2=dx*dx;
	float dy2=dy*dy;
	float dz2=dz*dz;
	
	float det=(
		-2.0*x0*dx*z0*dz
		+2.0*x0*dx*y0*dy
		-2.0*z0*dz*y0*dy
		+dz2*x02
		+dz2*y02
		+dx2*z02
		+dy2*z02
		-dy2*x02
		-dx2*y02
        );
	
	if(det<0.0)
		return INFINITY;
		
	float t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))/(dx2-dz2+dy2);
	float t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))/(dx2-dz2+dy2);
	vec3 pt0=ray.origin+t0*ray.direction;
	vec3 pt1=ray.origin+t1*ray.direction;
	
	if(t1>0.0 && pt1.z>r1/r0 && pt1.z<1.0)
	{
		t=t1;
		n=pt1;
		n.z=0.0;
		n=normalize(n);
		n.z=-pt1.z/abs(pt1.z);
		n=normalize(n);
		n=tm*-n;
	}
	
	if(t0>0.0 && pt0.z>r1/r0 && pt0.z<1.0)
	{
		t=t0;
		n=pt0;
		n.z=0.0;
		n=normalize(n);
		n.z=-pt0.z/abs(pt0.z);
		n=normalize(n);
		n=tm*n;
	}
	return t;	
}

// Function 1024
float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}

// Function 1025
vec2 sphere_limits( float R, vec2 impact )
{
	float D = R * R - impact.x;
    return sqrt(D) * vec2( -1, 1 ) - impact.y;
}

// Function 1026
DAMValue plane(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}

// Function 1027
float spheres(vec3 p)
{
    vec3 p2 = p;
    p2.xz = mod(p.xz+2.0,4.0)-2.0;
    vec2 idx = p.xy-p2.xy;
    p2.xz += sin(idx*34.91)*.5;
    
	return length(p2)-1.0;	
}

// Function 1028
float sdBox( vec2 p, vec2 b )
{
  vec2 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);
}

// Function 1029
bool intersect_plane(vec3 p, vec3 n, vec3 ray, vec3 ray_origin, out vec3 hit) {
  vec3 dr = ray_origin - p;
  float proj = dot(n, dr);
  float ndv = dot(n, ray);
  if (proj * ndv > -1.0e-6) {
    return false;
  }
  float t = proj / ndv;
  hit = ray_origin - ray * t;
  return true;
}

// Function 1030
vec4 drawSelectionBox(vec2 c) {
	vec4 o = vec4(0.);
    float d = max(abs(c.x), abs(c.y));
    if (d > 6. && d < 9.) {
        o.a = 1.;
        o.rgb = vec3(0.9);
        if (d < 7.) o.rgb -= 0.3;
        if (d > 8.) o.rgb -= 0.1;
    }
    return o;
}

// Function 1031
float linePlaneIntersection(vec3 normal, vec3 coord, vec3 rayOrigin, vec3 rayDirection) 
{
    // get d value
    float d = dot(normal, coord);

    float denominator = dot(normal, rayDirection);

    // Compute the X value for the directed line ray intersecting the plane
    return (denominator == 0.0) ? -1.0 : ((d - dot(normal, rayOrigin)) / denominator);
}

// Function 1032
vec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n);

    float s = 1e8;
    
    if (abs(dn) > 0.0001) {
        s = dot(p-o, n) / dn;
        s += float(s < 0.0) * 1e8;
    }
    
    return o + s*rd;
}

// Function 1033
float planeSDF(vec3 samplePoint, Plane plane) {
    return dot( plane.normal , samplePoint - plane.center);
}

// Function 1034
seg tSphere(in ray r, in sph s) {
    vec3 oc = r.o - s.l;
    float c = dot(oc, oc) - s.r * s.r,
          b = -dot(oc, r.d),
          h = b*b - c;
    if (h < 0.) return nullSeg;
    h = sqrt(h);
    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));
}

// Function 1035
float fCylinderH(vec3 p, float r, float height) {
  float d = length(p.xz) - r;
  d = max(d, abs(p.y) - height);
  return d;
}

// Function 1036
vec3 getSphereColor( vec2 grid ) {
	return normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );
}

// Function 1037
vec2 IntersectPlane( vec3 rayStart, vec3 rayDir, vec3 normal, float dist )
{
    float rdn = dot( rayDir, normal );
    float rds = dot( rayStart, normal );
    
    float t = (dist - rds)/rdn;
    if ( abs(rdn) < epsilon )
    {
        t = far;
    }
    
    bool inside = (rdn > epsilon);
    return inside ? vec2(-far,t) : vec2(t,far);
    
    /* 4 cases: intersection behind/infront x rdn +/-
    	       	  t < 0 | t > 0
	rdn < 0|vec2(t,far) | vec2(t,far)
	rdn > 0|vec2(-far,t)| vec2(-far,t)
	^ so it should work for planes behind start
    */      
}

// Function 1038
float dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}

// Function 1039
float distToBox( in vec3 p, in vec3 abc )
{
	vec3 di = max(abs(p)-abc,0.0);
	return dot(di,di);
}

// Function 1040
float planeDistance(vec3 rayPosition) {
    return rayPosition.y;
}

// Function 1041
float dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}

// Function 1042
float imTestCylinder(vec3 p) {
    float r = 0.5;
    return p.x*p.x + p.y*p.y - r*r;
}

// Function 1043
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); 
}

// Function 1044
vec3 getSphereColor( vec2 grid ) {
	float m = hash12( grid.yx ) * 12.;
    return vec3(1.-m*0.08, m*0.03, m*0.06);
}

// Function 1045
Hit intersectCone(Cone s, Ray r)
{
    vec3 co = r.o - s.c;

    float a = dot(r.d,s.v)*dot(r.d,s.v) - s.cosa*s.cosa;
    float b = 2. * (dot(r.d,s.v)*dot(co,s.v) - dot(r.d,co)*s.cosa*s.cosa);
    float c = dot(co,s.v)*dot(co,s.v) - dot(co,co)*s.cosa*s.cosa;

    float det = b*b - 4.*a*c;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t1 = (-b - det) / (2. * a);
    float t2 = (-b + det) / (2. * a);

    // This is a bit messy; there ought to be a more elegant solution.
    float t = t1;
    if (t < 0. || t2 > 0. && t2 < t) t = t2;
    if (t < 0.) return noHit;

    vec3 cp = r.o + t*r.d - s.c;
    float h = dot(cp, s.v);
    if (h < 0. || h > s.h) return noHit;

    vec3 n = normalize(cp * dot(s.v, cp) / dot(cp, cp) - s.v);

    return Hit(t, n, s.m);
}

// Function 1046
vec4 getSphere(float sphereNo, float time)
{
	float lifetimedelta = sphereNo / spheresCount;
    
    time *= speed;

    float lifetimeDiv = floor(time + lifetimedelta);
    float lifetimeFrac = time + lifetimedelta - lifetimeDiv;

	sphereNo = sphereNo + lifetimeDiv * spheresCount;
    
    if (sin(sphereNo * 3.141) > 0.0) {sphereNo += spheresCount;};
    
    float x = sin(sphereNo/6.0)*spread;
    float y = sin(sphereNo/7.0)*spread;
    return vec4(x, y, initialDistance - lifetimeFrac * initialDistance, abs(sin(sphereNo*3.0))*initialSize + initialSize);
}

// Function 1047
float cylinder(vec3 p, vec3 a, vec3 b, float r)
{
    vec3 ab = b - a;
    // project c onto ab, computing parameterized position d(t) = a + t(b-a)
    float t = dot(p - a, ab) / dot(ab, ab);
    vec3 c = a + t*ab;
		
    float d = length(c - p) - r;
    
    vec3 n = normalize(ab);
    d = intersect(d, plane(p, n, b));
    d = intersect(d, plane(p, -n, a));
    return d;
}

// Function 1048
void planetColour(in vec3 pos, in float mat, out vec3 refl, out vec3 emitted) {
    vec3 oldPos = pos;
    pos = planetSpin()*pos;
    float land = clamp((length(pos)-SEA_LEVEL)/(ATMOSPHERE_HEIGHT), 0.0, 1.0);
    vec3 n = calcNormal(pos);
    vec3 up = normalize(pos);
    float updotn = dot(n, up);
    float ydotn = dot(n, vec3(0.0, 1.0, 0.0));
    float sundotn = dot(normalize(oldPos), sunDirection());
    float h = waterDepth(oldPos, 0.5);
    vec3 col = vec3(0.0);
    emitted = vec3(0.0);
    
    // Detail noises
    float pnb = noise3((pos+59.0)/16.0);
    float pn1 = noise3(pos/2.0);
    float pn2 = noise3((pos+59.0));
    float pn3 = noise3((pos+129.0)*2.0);
    
    vec2 cn1 = cellular2x2x2(pos);
    
    float pf = pn1 + .5*pn2 + .25*pn3;
    
#ifdef ENABLE_DETAILS
    float pn4 = noise3((pos+129.0)*4.0);
    float pn5 = noise3((pos+129.0)*8.0);
    float pn6 = noise3((pos+129.0)*16.0);
    
    pf += .125*pn4 + 0.0625*pn5 + 0.03125*pn6;
#endif
    
    // Land
    const vec3 cShore1 = vec3(0.62, 0.31, 0.4);
    const vec3 cShore2 = vec3(1.2, 0.1, 0.1);
    const vec3 cShore3 = vec3(1.2, 1.0, 1.0);
    const vec3 cShore4 = vec3(1.0, 1.0, 1.0);
    
    vec3 cShoreMix1 = mix(cShore1, cShore2, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));
    vec3 cShoreMix2 = mix(cShore3, cShore4, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));
    vec3 shoreCol = mix(cShoreMix1, cShoreMix2, (1.+pnb)/2.);
    float coastMask = smoothstep(0.04, 0.15, land+(0.04*pf));

    // Land is divided into grass and dessert - yum
    const vec3 cGrass1 = vec3(0.6, 0.9, 0.4)*0.65;
    const vec3 cGrass2 = vec3(0.8, 0.8, 0.2)*0.75;
    const vec3 cDesert = vec3(1.42, 0.8, 0.4);
    vec3 cGrassMix = mix(cGrass1, cGrass2, pf);
    float desertMask = smoothstep(0.1, 0.30, pnb+0.15*pf);
    vec3 biomeCol = mix(cGrassMix, cDesert, desertMask);
    
    vec3 landCol = mix(shoreCol, biomeCol, clamp(coastMask+0.5*desertMask, 0.0, 1.0));
    col += mix(vec3(0.0), landCol, clamp(1.0-abs(mat - 1.), 0.0, 1.0));
    
    // Cities in the desert - they turn their lights on at night, off during the day
    float cityMask = (1.0-smoothstep(0.25, 0.26, sundotn))*(cn1.y - cn1.x)*desertMask;
    vec3 cityLights = mix(vec3(0.0), vec3(2.0,0.5,1.5)*clamp(cityMask*pf, 0.0, 1.0), clamp(1.0-abs(mat - 1.), 0.0, 1.0));
    
    // Mountain
    const vec3 cMountainTopLow = vec3(0.6, 0.55, 0.65)*0.75;
    const vec3 cMountainTopHigh = vec3(1.2,1.2,1.2);
    const vec3 cMountain = vec3(0.6,0.55,0.55);
    vec3 mountainTopCol = mix(cMountainTopLow, cMountainTopHigh, smoothstep(0.7, 0.8, land));
    vec3 mountainCol = mix(cMountain, mountainTopCol, clamp(pow(updotn, 12.0), 0.0, 1.0));
    col += mix(vec3(0.0), mountainCol, clamp(1.0-abs(mat - 2.), 0.0, 1.0));
    
    // Sea
    const vec3 oceanColour = vec3(0.1, 0.0, 0.4);
    const vec3 shoreColour = vec3(.4, .5, .99)*1.0;
    vec3 cSeaMix = mix(oceanColour, shoreColour, smoothstep(0.35, 0.0, h+0.05*pf));
    col += mix(vec3(0.0), cSeaMix, float(mat==10.));

    refl = col;
    emitted = cityLights;
}

// Function 1049
vec4 raycastPlane(in vec3 rayOrigin, vec3 rayDirection, in float planeHeight)
{
 	float distanceToPlane = abs(rayOrigin.y - planeHeight);   
    rayDirection /= rayDirection.y;
    rayDirection *= distanceToPlane;
    vec3 hitPoint = rayOrigin + rayDirection;
    
    return vec4(hitPoint.x, hitPoint.z, hitPoint.y, length(rayDirection));
}

// Function 1050
float sphere(vec3 pos, float radius)
{
	return length(pos) - radius;
}

// Function 1051
float iCylinder( in vec3 ro, in vec3 rd, 
                 in vec3 pa, in vec3 pb, float ra )
{
    vec3 ba = pb-pa;

    vec3  oc = ro - pa;

    float baba = dot(ba,ba);
    float bard = dot(ba,rd);
    float baoc = dot(ba,oc);
    
    float k2 = baba            - bard*bard;
    float k1 = baba*dot(oc,rd) - baoc*bard;
    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return -1.0;
    h = sqrt(h);
    float t = (-k1-h)/k2;

    // body
    float y = baoc + t*bard;
    if( y>0.0 && y<baba ) return t;
    
    return -1.0;
}

// Function 1052
define fillbox(rx,ry,v) {V=abs(U-P.xy-vec2(0,5)*S); if(V.x<rx*S && V.y<ry*S) O=vec4(v);}

// Function 1053
float usdBox( in vec3 p, in vec3 b )
{
    return length( max(abs(p)-b,0.0 ) );
}

// Function 1054
mat4 rotation_mat4_xz_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    return mat4(
    	cos_theta, 0.0, (-1.0 * sin_theta), 0.0, // x-basis
        0.0, 1.0, 0.0, 0.0, // y-basis
        sin_theta, 0.0, cos_theta, 0.0, // z-basis
    	0.0, 0.0, 0.0, 1.0); // w-basis
}

// Function 1055
float sdBox_1062606552(vec3 position, vec3 dimensions) {
  vec3 d = abs(position) - dimensions;

  return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));
}

// Function 1056
vec3 sphereCenter(float time) {
    return vec3(0.,cos(0.5*time),5.) + vec3(sin(time),0.,2.*cos(0.5*time));
}

// Function 1057
float SphereRadius(float t)
{
	t = abs(t-250.0);
	t *= 0.01;
	return clamp(t*t, 50.0/iResolution.y, 80.0);
}

// Function 1058
float box(vec3 p, vec3 b)
{
    vec3 q = clamp(p, -b, b);
    return length(p - q);
}

// Function 1059
float sdBox(vec3 p, vec3 s) {
    p = min( (p)-s, (p)+s);
	return length(p)+(p.x+p.y);
}

// Function 1060
float sphere (vec3 o, vec3 d) {
    // <xyz,xyz> = R^2
    float disc = 4.0*dot(d,o)*dot(d,o)-4.0*dot(d,d)*(dot(o,o)-RADIUS*RADIUS);
    if (disc < 0.0) return INF;
    return (-2.0*dot(d,o)-sqrt(disc))/(2.0*dot(d,d));
}

// Function 1061
float sphereCopies(vec3 z)
{
  vec3 id = fract(z * 1.);
  z = mod(z,6.);
  
  z -= vec3(3.);
  
  
  return mandelbulb(z); // sphere DE
}

// Function 1062
bool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {
    t = -1.0;
	vec3  ce = ray.origin - sph.pos;
	float b = dot( ray.dir, ce );
	float c = dot( ce, ce ) - sph.radiusSq;
	float h = b*b - c;
    if( h > 0.0 ) {
		t = -b - sqrt(h);
	}
	
	return ( t > 0.0 );
}

// Function 1063
float dist_sphere( vec3 pos, float r ) {
	return length( pos ) - r;
}

// Function 1064
vec4 intersectSphere(vec3 rpos, vec3 rdir, vec3 pos, float rad)
{
	vec3 op = pos - rpos;
	float b = dot(op, rdir); 
	float det = b*b - dot(op, op) + rad*rad; 
		
	if (det > 0.0)
	{
		det = sqrt(det);
		float t = b - det;
		if (t > eps)
			return vec4(-normalize(rpos+rdir*t-pos), t);
	}
	
	return vec4(0.0);
}

// Function 1065
float
torusmhmh_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);
        return manhattan(q)-torus.y;
}

// Function 1066
vec4 color_ui_box(int idx) {
    
    return vec4(inset_ctr.x + (float(idx)-0.5)*text_size,
                dfunc_y - 3.5*text_size,
                vec2(0.45*text_size));
    
}

// Function 1067
float y_sphere_2(in float offset) {
    if (offset >= 0.0 && offset <= 8.0) 
        return 0.0;
    else if (offset > 8.0 && offset <= 10.0)
        return sin((offset - 8.0) / 2.0 * PI / 2.0) * movement;
    else if (offset > 10.0 && offset <= 20.0)
        return movement;
    else 
        return y_sphere_common(offset);
}

// Function 1068
float de_box(vec4 p, vec3 s) {
	vec3 a = abs(p.xyz) - s;
	return (min(max(max(a.x, a.y), a.z), 0.0) + length(max(a, 0.0))) / p.w;
}

// Function 1069
float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y+.5),0.0); 
}

// Function 1070
float planeSdf( vec3 p )
{
    return p.z;
}

// Function 1071
float fBox(vec3 p, vec3 b)
{
  return length(max(abs(p)-b,0.0))-0.2;
}

// Function 1072
float sdf_plane(vec2 pos, vec2 plane_pos, float angle) {
    pos -= plane_pos;
    return (sin(angle) * pos.y - cos(angle) * pos.x);
}

// Function 1073
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal) 
{
    float t = (-1.0 - pos.y) / dir.y;
    if (t <= 0.0) 
    {
        return INF;
    }
    
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) < 0.5) 
    {
        normal = vec3(0, 1, 0);
        return t;
    }
    
    float a = dot(dir.xz, dir.xz);
    float b = dot(pos.xz, dir.xz);
    float c = dot(pos.xz, pos.xz) - 0.5;
    float D = b * b - a * c;
    
    if (D < 0.0) 
    {
        return INF;
    }
    
    t = (-b - sqrt(D)) / a;
    if (t > 0.0) 
    {
        worldPos = t * dir + pos;
        if (worldPos.y <= -1.0) 
        {
            normal = normalize(vec3(worldPos.x, 0, worldPos.z));
            return t;
        }
    }
    
    t = (-b + sqrt(D)) / a;
    if (t < 0.0) 
    {
        return INF;
    }
    
    worldPos = t * dir + pos;
    if (worldPos.y <= -1.0) 
    {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }
    
    return INF;
}

// Function 1074
maybe_vec2 get_distances_along_3d_line_to_sphere(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in float r
){
    float xz = dot(B0 - A0, A);
    float z = length(A0 + A * xz - B0);
    float y2 = r * r - z * z;
    float dxr = sqrt(max(y2, 1e-10));
    return maybe_vec2(
        vec2(xz - dxr, xz + dxr), 
        y2 > 0.
    );
}

// Function 1075
float sdfCone(vec3 p, vec3 a, vec3 b, float ra, float rb)
{
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;
    float x = sqrt( papa - paba*paba*baba );
    float cax = max(0.0,x-((paba<0.5)?ra:rb));
    float cay = abs(paba-0.5)-0.5;
    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );
    float cbx = x-ra - f*rba;
    float cby = paba - f;
    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(cax*cax + cay*cay*baba,
                       cbx*cbx + cby*cby*baba) );
}

// Function 1076
float Sphere(vec3 p, vec3 rd, float r){
	float b = dot( -p, rd );
	float inner = b * b - dot( p, p ) + r * r;
	if( inner < 0.0 ) return -1.0;
	return b - sqrt( abs(inner) );
}

// Function 1077
vec3 randomHemisphereDir( vec3 dir, float i )
{
    vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
    return v * sign(dot(v, dir));
}

// Function 1078
int checkcone(vec3 p) {
  float height = dohyperboloid ? 2.0 : 1.0;//exp(iTime);
  if (doclip && abs(p.y) > height) return 0;
  float N = 16.0;
  float i = floor(N*(atan(p.z,p.x))/PI);
  float j = floor(N*p.y/height);
  return int(mod(i+j,2.0));
}

// Function 1079
bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 8.;
	float delta = b*b - c;
	if( delta < 0.0) 
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}

// Function 1080
float distToExitPlanet(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;
    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);
}

// Function 1081
float sdCappedCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1082
void createCylinder(mat4 transform, float r, float minZ, float maxZ, float maxTheta, int mtl, out Object obj) {
    obj.type_ = OBJ_CYLINDER;
    obj.mtl_id_ = mtl;
    obj.transform_ = transform;
    obj.transform_inv_ = mat4Inverse( obj.transform_ );
    obj.params_[0] = r;			//radius
    obj.params_[1] = minZ;		//min z
    obj.params_[2] = maxZ;		//max z
    obj.params_[3] = maxTheta;	//max phi
    obj.params_[4] = 0.0;		//not used
    obj.params_[5] = 0.0;		//not used
}

// Function 1083
float sdBox( in vec3 p, in vec3 b ) {
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1084
float sdSphere(vec3 rayPos, vec3 spherePos, float sphereRadius)
{
	float dist = length(rayPos - spherePos) - sphereRadius;
    return dist;
}

// Function 1085
float sdSphere(vec3 pos, vec3 center, float radius)
{
    return length(pos - center) - radius;
}

// Function 1086
float sdCappedCylinderZ( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xy),p.z)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1087
float sdBox(vec3 p, vec3 s) {
    p = abs(p) - s;
	return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);
}

// Function 1088
mat3 planetSpin() { return rotY(-iTime*PI/ROTATE_PERIOD); }

// Function 1089
float sBoxS(in vec2 p, in vec2 b, in float sf){
   

  vec2 d = abs(p) - b + sf;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;
}

// Function 1090
vs_output_data      vs_box(ray r,vec3 _min,vec3 _max)
{
    vs_output_data vs_out;
    vs_out.valid = 0.0;
    vs_out.depth = FAR;
    vs_out.pos_ws = vec3(0.0);
    vs_out.normal_ws = vec3(0.0);
    
    vec2 d = intersect_box(r.point,r.dir,_min,_max);
    if(d.x < d.y && d.x > 0.0) //should do more checking for near/far
    {
        vec3 center = (_max + _min) / 2.0;
        vec3 pos_ws = r.point + r.dir * d.x;
        vec3 normal_ws = box_normal_from_point(pos_ws - center,_max - center);
        vs_out.valid = 1.0;
        vs_out.depth = d.x;
        vs_out.pos_ws = pos_ws;
        vs_out.normal_ws = normal_ws;
    }
    
    return vs_out;
}

// Function 1091
bool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.hitAnObject = true;
        info.rayMarchedObject = false;
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
		info.material = material;        
        return true;
    }
    
    return false;
}

// Function 1092
float signDistanceSphere(vec3 pos, vec3 sphereCenter, float s_r)
{
	return length(sphereCenter - pos) - s_r; 
}

// Function 1093
float IntersectCone( vec3 ro, vec3 rd, float h, float r ) {
    vec3  oa = ro - vec3(0.0, h*0.5, 0.0);
    float m0 = h*h;
    float m1 = oa.y*-h;
    float m2 = rd.y*-h;
    if( m1<0.0 && dot(oa*m2-rd*m1, oa*m2-rd*m1)<(r*r*m2*m2) ) return -m1/m2;  // cap hit?
    float hy = m0 + r*r;
    float k2 = m0*m0            - m2*m2*hy;
    float k1 = m0*m0*dot(rd,oa) - m1*m2*hy + m0*r*r* m2;
    float k0 = m0*m0*dot(oa,oa) - m1*m1*hy + m0*r*r*(m1*2.0 - m0);
    float t = ( -k1-sqrt(k1*k1 - k2*k0) ) / k2;
    float y = m1 + t*m2;
    return ( y>=0.0 && y<=m0 ) ? t : -1.0;   // body hit?
}

// Function 1094
vec3 shadeSphere1(vec3 rayPos, vec3 normal)
{
    return vec3(1.0, 0.0, 0.0);
}

// Function 1095
vec3 sphereVolumeRandPoint()
{
    vec3 p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;
    while(length(p)>1.0)
    {
        p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;
    }
    return p;
}

// Function 1096
float rPlane(vec3 o,vec3 d,vec4 pn)
{
    float num = pn.w - dot(pn.xyz,o);
    float denom = dot(pn.xyz,d);
    float t = num/denom;
   // if(t>PRECISION_STEP)
        return t;
    return 1e999;
}

// Function 1097
SSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)
{
	vec3 posSphere = sphere.xyz;
	float sRadius = sphere.w;

	SSdfSample sdf;
	sdf.m_s = length(pos - posSphere) - sRadius;
	sdf.m_mtl = mtl;
	return sdf;
}

// Function 1098
float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p) - b;
    return length(max(d, vec2(0))) + min( max(d.x, d.y), 0.0 );
}

// Function 1099
float calculateSphereIntersection(in vec3 ro, in vec3 rd, in Sphere sph)
{
    vec3 dv = sph.cen - ro;
	float b = dot(rd, dv);
	float d = b * b - dot(dv, dv) + sph.rad * sph.rad;
	return (d < 0.0) ? -1.0 : b - sqrt(d);
}

// Function 1100
vec3 WavelengthToConeLinear( float fWavelength )
{
    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);
    float fIndex = fPos * float(standardObserver1931_length);
    float fFloorIndex = floor(fIndex);
    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );
    int iIndex0 = int(fFloorIndex);
    int iIndex1 = iIndex0 + 1;
    iIndex0 = min( iIndex0, standardObserver1931_length - 1);
    iIndex1 = min( iIndex1, standardObserver1931_length - 1);    
    return mix( coneFundamentals[iIndex0], coneFundamentals[iIndex1], fBlend );
}

// Function 1101
float sdBox( vec2 p, vec2 b )
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1102
bool inBox(vec2 coord, vec4 bounds) {
    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);
}

// Function 1103
float boxSDF( vec3 point, vec3 center, vec3 size ) {
    vec3 diff = abs( point - center ) - size;
    return max( diff.x, max( diff.y, diff.z ) );
}

// Function 1104
vec2 planetMap(in vec3 p) 
{
    p = planetSpin()*p;
    
    // Noises
    float pn1 = noise3(p/32.0);
    float pn2 = noise3(p*(2.1/32.0));
    float pn3 = noise3(p*(4.2/32.0));
    
    // Perlin FBM
    float pf1 = pn1 + 0.5*pn2 + 0.25*pn3;
    
    // Ridged multi fractal
    float rmf = 0.0;
    float signal = 0.0;
    signal = pow(1.0-abs(pn2), 2.0); rmf += signal;
    signal = pow((1.0-abs(pn3)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.5*signal;
    
#ifdef ENABLE_DETAILS
    float pn4 = noise3(p*(8.82/32.0));
    float pn5 = noise3(p*(18.522/32.0));
    float pn6 = noise3(p*(38.8962/32.0));
    
    pf1 += 0.125*pn4 + 0.0625*pn5 + 0.03125*pn6;
    
    signal = pow((1.0-abs(pn4)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.25*signal;
    signal = pow((1.0-abs(pn5)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.125*signal;
    signal = pow((1.0-abs(pn6)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.06125*signal;
#endif
    
    float d = 0.0;
    float mat = 1.0;
    d += ATMOSPHERE_HEIGHT/4.0 * pf1;
    float land = clamp(d/(ATMOSPHERE_HEIGHT/4.0), 0.0, 1.0);
    
    // Mountain
    float mn = 2.5*rmf;
    float mountainMask = smoothstep(0.55, 1.0, clamp(abs(0.925-pn2), 0.0, 1.0))*land;
    
    mat = mix(mat, 2.0, smoothstep(0.0, 0.5, mountainMask));
    d += mix(0.0, mn, mountainMask);
    
    return vec2(sdSphere(p, SEA_LEVEL+d), mat);
}

// Function 1105
float tetrahedronPlaneDistance(vec3 p, vec3 pa, vec3 pb, vec3 pc, vec3 pd, vec4 plane)
{
    vec3 tn0 = cross(pb - pa, pc - pa);
    vec3 tn1 = cross(pb - pd, pa - pd);
    vec3 tn2 = cross(pc - pd, pb - pd);
    vec3 tn3 = cross(pa - pd, pc - pd);
    
    vec3 n = normalize(plane.xyz);

    vec3 b0 = normalize(cross(n, cross(n, tn0)));
    vec3 b1 = normalize(cross(n, cross(n, tn1)));
    vec3 b2 = normalize(cross(n, cross(n, tn2)));
    vec3 b3 = normalize(cross(n, cross(n, tn3)));
    
    vec3 c0 = p + b0 * dot(pa - p, tn0) / dot(b0, tn0);
    vec3 c1 = p + b1 * dot(pd - p, tn1) / dot(b1, tn1);
    vec3 c2 = p + b2 * dot(pd - p, tn2) / dot(b2, tn2);
    vec3 c3 = p + b3 * dot(pd - p, tn3) / dot(b3, tn3);
    
    float td0 = dot(p - c0, b0);
    float td1 = dot(p - c1, b1);
    float td2 = dot(p - c2, b2);
    float td3 = dot(p - c3, b3);
	
    return min(abs(td0), min(abs(td1), min(abs(td2), abs(td3))));
}

// Function 1106
float udRoundBox( vec3 p, vec3 b, float r ) {
    //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
    return length( max( abs( p ) - b, 0.0 ) ) - r; 
}

// Function 1107
vec2 sphere_coordinates(vec3 p){
    float u = atan(p.x, p.z);
    float v = acos(p.y);
    return vec2(u, v);
}

// Function 1108
float rBox( vec3 p, vec3 b, float r ){
	return length(max(abs(p)-b,0.0))-r;
}

// Function 1109
float sdCone( in vec3 p, in float h, in float r1, in float r2 )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 1110
float box1(vec3 ro,vec3 rd)
{
    return min((sign(rd.x)-ro.x)/rd.x,min((sign(rd.y)-ro.y)/rd.y,(sign(rd.z)-ro.z)/rd.z));
}

// Function 1111
vec3 atmosphere(
	in vec3 pos,
	in vec3 dir,
	in vec3 lightDir
) {
	// Intersect the atmosphere
    vec2 intersect = raySphereIntersect(pos, dir, ATMOSPHERE_RADIUS);

	// Accumulators
	vec3 opticalDepth = vec3(0.0); // Accumulated density of particles participating in Rayleigh, Mie and ozone scattering respectively
    vec3 sumR = vec3(0.0);
    vec3 sumM = vec3(0.0);
    
    // Here's the trick - we clamp the sampling length to keep precision at the horizon
    // This introduces banding, but we can compensate for that by scaling the clamp according to horizon angle
    float rayPos = max(0.0, intersect.x);
    float maxLen = ATMOSPHERE_HEIGHT;
    maxLen *= (1.0 - abs(dir.y) * 0.5);
	float stepSize = min(intersect.y - rayPos, maxLen) / float(SAMPLES);
    rayPos += stepSize * 0.5; // Let's sample in the center
    
    for(int i = 0; i < SAMPLES; i++) {
        vec3 samplePos = pos + dir * rayPos; // Current sampling position

		// Similar to the primary iteration
		vec2 lightIntersect = raySphereIntersect(samplePos, lightDir, ATMOSPHERE_RADIUS); // No need to check if intersection happened as we already are inside the sphere

        vec3 lightOpticalDepth = vec3(0.0);
        
        // We're inside the sphere now, hence we don't have to clamp ray pos
        float lightStep = lightIntersect.y / float(LIGHT_SAMPLES);
        float lightRayPos = lightStep * 0.5; // Let's sample in the center
        
        for(int j = 0; j < LIGHT_SAMPLES; j++) {
            vec3 lightSamplePos = samplePos + lightDir * (lightRayPos);

			lightOpticalDepth += avgDensities(lightSamplePos) * lightStep;

            lightRayPos += lightStep;
        }

		// Accumulate optical depth
		vec3 densities = avgDensities(samplePos) * stepSize;
		opticalDepth += densities;

		// Accumulate scattered light
        vec3 scattered = exp(-(BETA_RAY * (opticalDepth.x + lightOpticalDepth.x) + BETA_MIE * (opticalDepth.y + lightOpticalDepth.y) + BETA_OZONE * (opticalDepth.z + lightOpticalDepth.z)));
        sumR += scattered * densities.x;
        sumM += scattered * densities.y;

        rayPos += stepSize;
    }

    float cosTheta = dot(dir, lightDir);
    
    return max(
        phaseR(cosTheta)    * BETA_RAY * sumR + // Rayleigh color
       	phaseM(cosTheta, G) * BETA_MIE * sumM,  // Mie color
    	0.0
    );
}

// Function 1112
float sdTorus(vec3 p, vec2 t)
{
    float distPtoTorusCircumference = length(vec2( length(p.xz)-t.x , p.y));
    return distPtoTorusCircumference - t.y;
}

// Function 1113
vec3 randInSphere(vec2 seed){
	vec3 p;
    int i = 0;
    do {
        p = 2.0*vec3(hash21(float(i)*seed+fract(iTime)*22.),hash21(float(i)+seed+fract(iTime)*43.),
                     hash21(seed-float(i)+fract(iTime+float(i))*97.)) - vec3(1,1,1);
    } while (dot(p,p) >= 1.0 && i++ < 500);
    return p;
}

// Function 1114
float sdSphere(vec3 p, vec3 c, float r) {
        return length(p - c) - r;
    }

// Function 1115
bool intersectBox(in Ray r, in Box b, inout HitTest test) {
    vec3 size = b.ma - b.mi;
    
    vec3 dA = (r.origin - b.mi) / -r.dir;
    vec3 dB = (r.origin - b.ma) / -r.dir;
    
    vec3 minD = min(dA, dB); // -
    vec3 maxD = max(dA, dB); // +
    
    float tmin = minD.x;
    float tmax = maxD.x;
    
    if (tmin > maxD.y || tmax < minD.y) return false;
    
    tmin = max(tmin, minD.y); //-
    tmax = min(tmax, maxD.y); //+
               
    if (tmin > maxD.z || tmax < minD.z) return false;
    
    tmin = max(tmin, minD.z); //-
    float insideScaling = sign(tmin);
    
    tmin = tmin <= 0.0 ? INF : tmin; //+
    
    tmax = min(tmax, maxD.z); //+
    tmax = tmax < 0.0 ? INF : tmax; //+
    float testVal = tmax;
    float d = min(tmin, tmax);// tmax
    
    float f = step(0.0, -d);
    d = d * (1.-f) + (f * INF);
    if (d > test.dist) return false;
    
    dA -= d;
    dB -= d;
    
    dA = step(vec3(0.001), abs(dA));
    dB = step(vec3(0.001), abs(dB));
    
    vec3 n = dA + -dB;
    
    test.dist = d;
    test.normal = n * insideScaling;
    
    return true;
}

// Function 1116
float sdBox(vec3 p,vec3 b){
  vec3 d=abs(p)-b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1117
float udRoundBoxBorder( vec3 p, vec3 b, float r, float borderPercent )
{
  return opS(udRoundBox(p, b*borderPercent, r), udRoundBox(p, b, r));
}

// Function 1118
vec3 sphere_from_planar(vec2 p) {
    
    return planar_proj * vec3(p, 1.);
    
}

// Function 1119
vec2 boxAnimation2(in vec2 uv, in vec2 id, in float frac)
{    
    vec2 rotation = vec2(0,0);
    
    float h = (90. + id.x * 180. + frac * 360. );
    float m = (0. - id.y * 180. - frac * 360. );
       
    float radianHour = radians(mod(h,360.));
    float radianMinute = radians(mod(m,360.));
    
    return vec2(radianHour,radianMinute);
}

// Function 1120
vec2 traceBox(in vec3 ro, in vec3 rd, in vec3 bp, in vec3 size, in mat3 rt)
{
    vec4 piv = vec4(size, 0.0);
    float f0 = traceQuad(ro, rd, bp, size.xy, rt, piv.wwz);
	float f1 = traceQuad(ro, rd, bp, size.xy * 1., rt, -piv.wwz);
	float f2 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), piv.wwx);
	float f3 = traceQuad(ro, rd, bp, size.zy, rt * roty(PI2), -piv.wwx);
	float f4 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), -piv.wwy);
    float f5 = traceQuad(ro, rd, bp, size.xz, rt * rotx(PI2), piv.wwy);
        
    float m = pmin(f0, f1); m = pmin(m, f2); m = pmin(m, f3); m = pmin(m, f4); m = pmin(m, f5);
    if (m < 0.0) return vec2(m);
    
    vec2 ret = vec2(m, 1.0);
    if (f0 > 0. && f0 != ret.x) ret.y = f0;
    else if (f1 > 0. && f1 != ret.x) ret.y = f1;
    else if (f2 > 0. && f2 != ret.x) ret.y = f2;
    else if (f3 > 0. && f3 != ret.x) ret.y = f3;
    else if (f4 > 0. && f4 != ret.x) ret.y = f4;
    else if (f5 > 0. && f5 != ret.x) ret.y = f5;
        
    return ret;
}

// Function 1121
bool intersectSphere(vec3 ro, vec3 rd, vec4 sp, float tm, out float t)
{
    bool r = false;
	vec3 v = ro - sp.xyz;
	float b = dot(v,rd);
	float c = dot(v,v) - sp.w*sp.w;
	t = b*b-c;
    if( t > 0.0 )
    {
        t = -b-sqrt(t);
        r = (t > 0.0) && (t < tm);
    }
    return r;
}

// Function 1122
float dTaperBox(vec3 p, vec3 b, float angle, float bottomDist) {
    vec3 prevP = p;
    float d = B3D(p,b);
    float a = radians(angle);
    p.x = abs(p.x);
    p.x-=bottomDist;    
    d = max(Slice(p.xy,a),d);

    p = prevP;
    a = radians(angle);
    p.z = abs(p.z);
    p.z-=bottomDist;
    d = max(Slice(p.zy,a),d);

    return d;
}

// Function 1123
float sdSphere(vec3 pos, float rad) {
	return length(pos) - rad;
}

// Function 1124
float ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
	
    float res = 1.0;
    if( b>0.0 )
    {
        float h = dot(oc,oc) - b*b - sph.w*sph.w;
        res = smoothstep( 0.0, 1.0, 12.0*h/b );
    }
    return res;
}

// Function 1125
bool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,
                      out float t, out vec3 hitPos, out vec3 hitNormal ) 
{
    /////////////////////////////////
    // TASK: WRITE YOUR CODE HERE. //
    /////////////////////////////////
    // get relative position of the ray to the center of the sphere
    Ray_t local_ray = Ray_t(ray.o - sph.center, ray.d);
    // solve quadratic equation
    float a = 1.0;
    float b = 2.0 * dot(local_ray.d, local_ray.o);
    float c = dot(local_ray.o, local_ray.o) - sph.radius * sph.radius;
    float d = b * b - 4.0 * a * c;
    // d <= 0.0 means no solution
    if ( d <= 0.0 )
        return false;
    
    float t_minus = ( -b - sqrt(d) ) / (2.0 * a);
    float t_plus =  ( -b + sqrt(d) ) / (2.0 * a);
    float t_positive = 0.0;
    // get the smallest positive solution
    if ( t_minus > 0.0 )
        t_positive = t_minus;
    else if ( t_plus > 0.0 )
        t_positive = t_plus;
    else
        return false;
    // if t value is out of range, no intersections
    if ( t_positive < tmin || t_positive > tmax ) return false;
    // return t value, hit position and normal vectors
    t = t_positive;
    hitPos = ray.o + t_positive * ray.d;
    hitNormal = normalize(hitPos - sph.center);
    return true;  // Replace this with your code.

}

// Function 1126
float intersectSphere(out vec3 normal,
	                  in Ray v,
                      in vec3 o,
                      in float r2)
{
    vec3 g = v.o - o;
    
    //<g + t*v.d, g + t*v.d> = r^2
    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0

    float a = dot(v.d, v.d);
    float b = 2.0*dot(g, v.d);
    float c = dot(g, g) - r2;
    
    float disc = b*b - 4.0*a*c;
    if(disc < 0.0) return -1.0;
    
    float d = sqrt(disc);
    float t0 = (-b - d)/(2.0*a);
    
    vec3 w = g + t0*v.d;
    normal = normalize(w);

    return t0;
}

// Function 1127
vec3 spheres_color(vec3 pos)
{
    //return pos.x*pos.y<0.?vec3(1.3):vec3(1.5, 1.1, 0.5);
    return vec3(1.3);
}

// Function 1128
vec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim) 
{
    vec3 m = 1.0/ray;
    vec3 n = m*(ctr-pos);
    vec3 k = abs(m)*dim;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tmax = max( max( t1.x, t1.y ), t1.z );
	float tmin = min( min( t2.x, t2.y ), t2.z );
	
	if( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);

    vec3 norm = -sign(ray)*step(t2, vec3(tmin));
    return vec4(norm, tmin);
}

// Function 1129
void Entity_UpdateSlideBox( inout Entity entity, float fTimestep )
{
    entity.fYaw += entity.fYawVel * fTimestep;

    const float fStepHeight = 24.1; // https://www.doomworld.com/vb/doom-general/67054-maximum-height-monsters-can-step-on/
    const float fClearanceHeight = 32.;
    
    float fDropOff = 10000.0;
    if ( entity.iType == ENTITY_TYPE_ENEMY )
    {
        // Enemies 
        fDropOff = 24.0;
    }
    entity.vVel.xz *= fTimestep;
    SlideVector( entity.iSectorId, entity.vPos.xz, entity.vVel.xz, entity.vPos.y + fStepHeight, entity.vPos.y + fClearanceHeight, fDropOff );
    entity.vVel.xz /= fTimestep;
}

// Function 1130
float sdTorus( vec3 p, vec2 t )
{
  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 1131
float obj_torus( vec3 p, vec3 center, vec2 t ){
    vec3 tp = p-center;
	vec2 q = vec2(length(tp.xy)-t.x,tp.z);
	return length(q)-t.y;
}

// Function 1132
float plane(vec3 ro, vec3 rd, vec3 n, float d)
{
    float nt = -(dot(ro,n) + d) / dot(n, rd);
    if(nt < .001)nt = 1e+31;
    
    if(nt < t)
    {
        t = nt;
        sp = ro + rd * t;
        sn = n;
    }
    
    return nt;
}

// Function 1133
float sdSphere(vec3 p, float r) {
	return length(p) - r;    
}

// Function 1134
float sdTorus88( vec3 p, vec2 t )
{
  vec2 q = vec2(length8(p.xz)-t.x,p.y);
  return length8(q)-t.y;
}

// Function 1135
Sphere GetLightSphere( int lightId ) {
    return spherelight[lightId];
}

// Function 1136
void createPlane(mat4 transform, float minX, float minY, float maxX, float maxY, int mtl, out Object obj) {
    obj.type_ = OBJ_PLANE;
    obj.mtl_id_ = mtl;
    obj.transform_ = transform;
    obj.transform_inv_ = mat4Inverse( obj.transform_ );
    obj.params_[0] = minX;			//min x
    obj.params_[1] = minY;			//min y
    obj.params_[2] = maxX;			//max x
    obj.params_[3] = maxY;			//max y
    obj.params_[4] = 0.0;		//not used
    obj.params_[5] = 0.0;		//not used
}

// Function 1137
float box(float boxpos, float boxw, float edgew, float x)
{
    return   smoothstep(boxpos-boxw*.5-edgew*.5,boxpos-boxw*.5+edgew*.5,x)
        *(1.-smoothstep(boxpos+boxw*.5-edgew*.5,boxpos+boxw*.5+edgew*.5,x));
}

// Function 1138
bool intersectPlane(vec3 plane_n, vec3 plane_p, vec3 ray_o, vec3 ray_d, out float t) { 
    // assuming vectors are all normalized
    float denom = dot(plane_n, ray_d); 
    if (abs(denom) > 1e-7) { 
        vec3 vec = plane_p - ray_o; 
        t = dot(vec, plane_n) / denom; 
        return (t >= 0.0); 
    } 
 
    return false; 
}

// Function 1139
bool cylinder_raycast(cylinder_t cylinder, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)
{
	// mat3 minv = inverse(cylinder.r);
	vec3 local_orig = cylinder.r * (orig - cylinder.p);
	vec3 local_dir = cylinder.r * dir;
	float r = cylinder.radius;
	float rsq = r * r;
	float hh = cylinder.height / 2.;
	
	bool isinside = false;
	
	float ray_proj = dot(-local_orig.xz, normalize(local_dir.xz));
	float orig_to_axis_dist_sq = dot(local_orig.xz, local_orig.xz);
	float axis_to_ray_sq = max(0., orig_to_axis_dist_sq - ray_proj * ray_proj);
	if(axis_to_ray_sq > rsq) return false;
	float foo = sqrt(rsq - axis_to_ray_sq);
    float dist1 = ray_proj - foo;
    float dist2 = ray_proj + foo;
	if(orig_to_axis_dist_sq < rsq && abs(local_orig.y) <= hh) isinside = true;
	if(isinside && !isfrominside) return false;
	if(isfrominside) intersect_dist = dist2 / length(local_dir.xz);
	else intersect_dist = dist1 / length(local_dir.xz);
	
	vec3 local_cast = local_orig + local_dir * intersect_dist;
	vec3 local_normal = vec3(local_cast.xz, 0.).xzy / r * (isfrominside ? -1.:1.);
	
	if(abs(local_cast.y) > hh)
	{
		float plane1 = (local_orig.y - hh) / (-local_dir.y);
		float plane2 = (local_orig.y + hh) / (-local_dir.y);
        if(isfrominside) intersect_dist = max(plane1, plane2);
        else intersect_dist = min(plane1, plane2);
		local_normal = vec3(0, -sign(local_dir.y), 0);
		local_cast = local_orig + local_dir * intersect_dist;
		if(length(local_cast.xz) > r) return false;
		uv = (local_cast.xz + vec2(r)) / (r * 2.);
	}
	else
	{
		uv.x = (atan(local_normal.z, local_normal.x) / PI) * .5 + .5;
        uv.y = (local_cast.y + hh) / cylinder.height;
	}
	
	castpoint = orig + dir * intersect_dist;
	normal = local_normal * cylinder.r;
	isfrominside = isinside;

    return true;
}

// Function 1140
float GetDistanceBox(const in vec3 vPos, const in vec3 vDimension)
{
	return length(max(abs(vPos)-vDimension,0.0));
}

// Function 1141
float sbox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1142
float sdPlaneWindowVolume( vec3 p, float window_radius_scale )
{
	vec3 cc = vec3( 0 );
	float wall_in = body_radius.x - 0.05;
	float wall_out = body_radius.x + 0.02;
	vec2 p2 = p.xz;
	p2.x = repeat_e( p.x, -windows_spacing, windows_spacing );
	p2.y -= windows_pos_from_center;
	// wx is window border mapped to 0,1
	float wx = saturate( ( ( p.y - cc.y ) - wall_in ) / ( wall_out - wall_in ) );
	p2 *= ( 1.0 + wx * 0.1 );
	float dw = sdAirlinerWindow( p2, window_radius_scale );
	return dw;
}

// Function 1143
float roundBoxSDF(vec3 p, vec3 boxDim, float radius) {
  return boxSDF(p, boxDim) - radius;
}

// Function 1144
float lBox(vec2 p, vec2 a, vec2 b, float ew){
    
    float ang = atan(b.y - a.y, b.x - a.x);
    p = rot2(ang)*(p - mix(a, b, .5));

    vec2 l = vec2(length(b - a), ew);
    return sBox(p, (l + ew)/2.) ;
}

// Function 1145
float sdTorus82( vec3 p, vec2 t )
{
  vec2 q = abs(vec2(length(p.xz)-t.x,p.y));
  return max(q.x,q.y)-t.y;
}

// Function 1146
float distCylinder( vec3 p, vec2 h, vec3 rot)
{
	p = rotMat(rot) * p;  
	float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / h.x;
    float v = p.y / h.y + .5;
    
    float disp = texture(iChannel0, vec2(u * .1 + .1,v * .5 + .1)).r;
    
	vec2 d = abs(vec2(length(p.xz),p.y)) - h;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - (disp * .05);
}

// Function 1147
float sdSphere(vec3 p)
{
    p += vec3(0,0,0);
    return length(p) - 1.0;
}

// Function 1148
float sdCappedCone(vec3 p, float h, float r1, float r2,vec3 offset)
{
  p = p - offset;
  vec2 q = vec2( length(p.xz), p.y );
  vec2 k1 = vec2(r2,h);
  vec2 k2 = vec2(r2-r1,2.0*h);
  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );
  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
  return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );
}

// Function 1149
float sphere(vec3 p, vec4 spr)
{
	return length(spr.xyz-p) - spr.w;
}

// Function 1150
vec3 calcCylinderNormal(vec3 a, vec3 b, vec3 c) {
    vec3 tangent = a - c;
    vec3 binormal = cross(a - b, c - b);
    vec3 normal = normalize(cross(tangent, binormal));
    return normal;
}

// Function 1151
void sampleSphereUniform(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){
    vec2 ksi = rand2();
    float polar = acos(1.0f - 2.0f * ksi.x);
    float azimuth = ksi.y * 2.0f * PI;
    sls.normal = vec3(sin(polar) *cos(azimuth), sin(polar) * sin(azimuth), cos(polar));
    sls.point = sphere.position + (sphere.radius ) * sls.normal;
    sls.pdf = 1.0f/ (FOUR_PI * sphere.radius2);
}

// Function 1152
float sdBox(vec3 p, vec3 b) {
    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z
    // So if all components of d are negative, then p is inside the unit cube
    vec3 d = abs(p) - b;
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 1153
bool
intersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
	// compute intersection of ray with all six bbox planes
	vec3 invR = 1.0 / rd;
	vec3 tbot = invR * (boxmin - ro);
	vec3 ttop = invR * (boxmax - ro);
	// re-order intersections to find smallest and largest on each axis
	vec3 tmin = min (ttop, tbot);
	vec3 tmax = max (ttop, tbot);
	// find the largest tmin and the smallest tmax
	vec2 t0 = max (tmin.xx, tmin.yz);
	tnear = max (t0.x, t0.y);
	t0 = min (tmax.xx, tmax.yz);
	tfar = min (t0.x, t0.y);
	// check for hit
	bool hit;
	if ((tnear > tfar)) 
		hit = false;
	else
		hit = true;
	return hit;
}

// Function 1154
float box(vec3 pos, vec3 size)
{
	return length(max(abs(pos) - size, 0.0));
}

// Function 1155
float sdHPlane(float h, vec3 p)
{
    return p.y - h;
}

// Function 1156
float sdPaperplane(vec3 r)
{
	float paperplane;	
    r.x=-abs(r.x);
    float lwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3(-0.05,0.5,0.0),vec3(-0.25,0.5,0.0))-0.005;
    //float rwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3( 0.05,0.5,0.0),vec3( 0.25,0.5,0.0))-0.005;
    float lbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(-0.05,0.5,0.0),vec3(0.0,0.35,0.0))-0.002;
    //float rbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(0.0,0.35,0.0),vec3( 0.05,0.5,0.0))-0.002;
    paperplane=min(lbase,lwing);
    //paperplane=min(rwing,lwing);
    //paperplane=min(paperplane,lbase);
    //paperplane=min(paperplane,rbase);
    return paperplane;
}

// Function 1157
float sdfSphere(vec3 p){
	return length(p)-(sin(p.y*sin(p.x*2.)*3.)*1.3)-1.;
}

// Function 1158
mat4 rotation_mat4_xy_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    return mat4(
    	cos_theta, sin_theta, 0.0, 0.0, // x-basis
        (-1.0 * sin_theta), cos_theta, 0.0, 0.0, // y-basis
        0.0, 0.0, 1.0, 0.0, // z-basis
    	0.0, 0.0, 0.0, 1.0); // w-basis
}

// Function 1159
float box(in vec3 p, in float s) { p = abs(p) - s; return max(p.x,max(p.y,p.z)); }

// Function 1160
float rBox( vec3 p, vec3 b, float r )
{
    return length(max(abs(p)-b,0.0))-r;
}

// Function 1161
float uBoxDist(in Ray ray, in Box box) {
    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);
}

// Function 1162
float Sphere(vec3 p, float r)         { return length(p) - r; }

// Function 1163
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    float t = -1.0;
	vec3  ce = ro - sph.xyz;
	float b = dot( rd, ce );
	float c = dot( ce, ce ) - sph.w*sph.w;
	float h = b*b - c;
	if( h>0.0 )
	{
		t = -b - sqrt(h);
	}
	return t;
}

// Function 1164
float sdXAlignedCylinder( vec3 p, float l, float r )
{
    p.z -= clamp( p.z, 0.0, l );
    return length(p) - r;
}

// Function 1165
float sphereSDF(vec3 pos)
{
    // Repeating pattern of spheres
    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);
    turned = 6.0*round(turned/6.0);
    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;
    /*pos.x -= 3.*round(pos.x/3.);
    if(pos.y>-1.5)
        pos.y -= 3.*round(pos.y/3.);
	*/
    pos.xy -= turned.xy;
    return length(pos-vec3(0.,0.,1.))-1.;
}

// Function 1166
float distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)
{
    return length(world_point - sphere_center) - radius;
}

// Function 1167
float DE_Sphere(in vec3 p, in vec3 center, in float r)
{
 	return length(p-center)-r;   
}

// Function 1168
float sd_sphere(vec3 p, float r) {
    return length(p) - r;
}

// Function 1169
float dist_sphere(vec3 p)
{
	return length(p)-1.0;
}

// Function 1170
Hit sphereTrace(in Ray r) {
  Surface s;
  for(int i=0; i<MAX_TRACE_STEP; i++) {
    s = map(_pos(r));
    s.d *= r.sgn;
    r.len += s.d * FUDGE_FACTOR;
    r.stp = float(i);
    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;
  }
  vec3 p = _pos(r);
  if (r.len > MAX_TRACE_DIST) {
    s.tc = s.rl = vec3(0);  // no refrect, refrat
    s.kd = vec3(1);         // full diffusion
  }
  return Hit(p, calcNormal(p)*r.sgn, r, s);
}

// Function 1171
float box(vec2 p,vec2 s)
{
    p=abs(p)-s;
    float d=max(p.x,p.y);
    return max(d,length(max(p,vec2(0))));
}

// Function 1172
float BoxSD(vec3 position, vec3 bounds)
{
    vec3 q = abs(position) - bounds;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1173
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// Function 1174
float sdTorus(vec3 p, vec2 t){
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 1175
float Box(vec3 p, vec3 b) {
    vec3 d = abs(p)-b;
    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 1176
vec2 torus(vec3 pos,vec2 h){
  vec2 q = vec2(length(pos.xz)-h.x,pos.y);
  return vec2(length(q)-h.y,1.);
}

// Function 1177
float SphereTracedObject(vec3 p)
{
	p.z=-p.z;
	float v = AmbiantEnergy;

	v += circle(p, vec3(0.0, 0.0, 0.0), normalize(vec3(sin(Time), tan(Time), cos(Time))), 3.0, Energy, Radius);
	v += point(p, vec3( 3.0 * cos(2.0 * Time), 3.0 * sin(2.0 * Time), 0.0), Energy, Radius);
	v += point(p, vec3( 3.0 * cos(3.0 * Time), 3.0 * sin(3.0 * Time), 1.0), Energy, Radius);
	v += point(p, vec3( 3.0 * cos(6.0 * Time), 3.0 * sin(6.0 * Time), 1.0), Energy, Radius);
	v += point(p, vec3( 0.0, 0.0, 0.0), Energy, 2.0);
	v += point(p, vec3( cos(2.0 * Time), 2.0 * sin(Time), 1.0), Energy, Radius);
	v += point(p, vec3( 3.0 * sin(3.0*Time), 1.0, 2.0 * cos(3.0*Time)), Energy, Radius);
	v += point(p, vec3( 3.0 * sin(2.0*Time + 0.5), 1.0, 3.0 * cos(2.0*Time)), Energy, Radius);

	return v;
}

// Function 1178
void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}

// Function 1179
void nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection
         ,out vec3 outNor,out vec2 outST,out int outFaceID
){// convert from ray to box space
 ;vec3 rdd=(txx*vec4(d,0.0)).xyz
 ;vec3 roo=(txx*vec4(o,1.0)).xyz
 ;// intersect and select
 ;vec3 s=-sign(rdd)
 ;vec3 t=(-roo+s*rad)/rdd
 ;// compute normal in world space
 ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1
 ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 
 ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 
 ;}}

// Function 1180
float sdCuttedBox(vec2 p) {
    float d = sdBox(p, vec2(0.3)) - 0.02;
    float c = sdCircle(abs(p) - vec2(0.28, 0.28), 0.24);
    d = max(d, -c);
    return d;
}

// Function 1181
void surface2x2_ortho_plane(in surface2x2 surf, float y,
	out surface2x1 slice) {
    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];

    slice[0] = A;
    slice[1] = C*y + D;
    slice[2] = (B*y + E)*y + F;
}

// Function 1182
float rayPlane(vec3 ro, vec3 rd, vec4 p ) {
  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
}

// Function 1183
vec3 spheresdf( vec3 p, 
                vec3 rdir ) 
{
    float dist = 10.;

    vec3 cellCoords = ceil(p / CELLBOX_SIZE);
    vec4 nextCellOffset = vec4(sign(rdir), 0.);
            
    // Look into this cell to check distance to that sphere and then
    // check the distance to the spheres for the next cells to see if
    // they are closer, we can guess the "next" cells by just looking
    // at the sign of the ray dir (so we don't check all 27 possible
    // cells - 9x9x9 grid).  This limits it down just to checking 8
    // possible cells.

    // XXX: we could limit this to 4 cell checks if we trace the 
    // ray through the 8 potential cells and only test the cells 
    // through which the ray passes.

    // 1. current cell
    vec3 result = spheredf( p, cellCoords );

    // 2. neighbor in the x direction of the ray
    vec3 neighborResult = spheredf(p, cellCoords + nextCellOffset.xww);    
    // DEBRANCHED - equivalent to
    // if (neighborResult.x < result.x) { result = neighborResult; }
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 3. neighbor in the y direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyw);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 4. neighbor in the z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wwz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));
    
    // 5. neighbor in the x-y direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyw);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 6. neighbor in the y-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 7. neighbor in the x-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xwz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));
        
    // 8. neighbor in the x-y-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyz);    
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    return result;
}

// Function 1184
float sdPlane(vec3 p) 
{
return p.y+(0.005*sin(p.x*10.))+(0.005*sin(p.z*12.))+0.4;
}

// Function 1185
float sdBox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1186
float aaa_box( mat2 K, vec2 uv, vec2 size, vec2 edge )
{
    return aaa_interval( max( edge.x, Linfinity( K[0] ) ), uv.x, size.x ) *
		   aaa_interval( max( edge.y, Linfinity( K[1] ) ), uv.y, size.y );
}

// Function 1187
Intersection RayPlane(Ray ray, Plane p)
{
	Intersection i;
	float num = p.d-dot(p.n, ray.o);
	float denom = dot(p.n, ray.dir);
	float t = num/denom;
	if(t > EPSILON)
	{
		i.p = ray.o + ray.dir * t;
		i.n = p.n;
		i.dist = t;
	}
	else
	{
		i.dist = ZMAX;
	}
	return i;
}

// Function 1188
float sdBox(in vec2 p, in vec2 b) {
  vec2 d = abs(p) - b;
  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// Function 1189
float hypersphere (vec4 p, float r) {
   return length(p) - r;
}

// Function 1190
vec3 nsphere(in vec3 pos, in vec3 o)
{
    return normalize(pos - o);
}

// Function 1191
float sdCylinder( vec3 p, vec2 h )
{
    float radius = h.x;
    float height = h.y;
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1192
float sdBox( in vec3 p, in vec3 b )
{
    vec3 d = abs(p) - b;
    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));
}

// Function 1193
float sphere2(in vec3 rp) {
   	return length(rp-vec3(0.,-5.5,0.))-2.;
}

// Function 1194
float sdSphere(in vec3 pos, in vec3 center, in float radius){
   	return length(pos-center) - radius;
}

// Function 1195
float torusA(vec3 p) {return torus (p, 2.4*cos (0.1*iTime), 4.5*sin (0.2*iTime), -0.2); }

// Function 1196
float fBox2Cheap(vec2 p, vec2 b) {
   return vmax(abs(p)-b);
}

// Function 1197
void boxEdge( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 uv = fragCoord.xy / iResolution.xy;
    vec4 original = texture(iChannel0, uv);
    vec4 blurred = vec4(0);
    boxBlur(blurred, fragCoord);
    fragColor = original - blurred;
}

// Function 1198
float y_sphere_0(in float offset) {
    if (offset >= 0.0 && offset <= 2.0) 
        return sin(offset / 2.0 * PI / 2.0) * movement;
    else if (offset > 2.0 && offset <= 20.0)
        return movement;
    else 
        return y_sphere_common(offset); 
    
}

// Function 1199
float cone(vec3 p, vec2 di) {
  vec2 crd = vec2(length(p.xy), p.z);
  return triangle(crd, di);
}

// Function 1200
float sdRoundedCylinder( vec3 p, float ra, float rb, float h, vec3 offset )
{
  p = p-offset;
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 1201
float box( in vec3 p, in vec3 b )
{
    vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1202
Ball from_plane(vec2 normal, float offset) {
    return Ball(normal, offset, true, false);
}

// Function 1203
float sphere(vec3 ro, vec3 rd)
{
    vec3 p = ro + ( dot(-ro, rd) * rd);
	float nt = length(p - ro) - sqrt(1. - dot(p,p));
    if(nt < .001)nt = 1e+31;
    
    if(nt < t)
    {
        t = nt;
        sp = ro + rd * t;
        sn = normalize(sp);
    }
    
    return nt;
}

// Function 1204
float sdBox( vec3 p, vec3 r )
{
  vec3 q = abs(p) - r;
  return length(max(q,0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);
}

// Function 1205
float box(in vec2 uv, in vec2 size)
{
    // Function for an axis-aligned rectangle
    // We have to do this independently for x- and y-direction to get smooth edging correct
    vec2 t = abs(uv / size);
    return smoothfill(t.x, 1., 10. / size.x) * smoothfill(t.y, 1., 10. / size.y);
}

// Function 1206
float fBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// Function 1207
float plane(in vec3 p, in vec3 n) { return dot(p, -n); }

// Function 1208
float sphere(vec3 where, vec3 center, float radius) {
  return length(where - center) - radius;
}

// Function 1209
float sphereSDF(vec3 p, float r)
{
    return length(p) - r;
}

// Function 1210
float conetip(vec2 uv, vec2 pos, float size, float min)
{
    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);
    return max( min, 1. - length((uv - pos) * aspect / size) );
}

// Function 1211
void get_sphere_uv(vec3 p, inout float u, inout float v) {
    u = p.x;
    v = p.z;
}

// Function 1212
vec3 random_cos_weighted_hemisphere_direction(const vec3 n, inout seed_t seed ) {
  	vec2 r = get_next_rnd(seed).xy;
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 1213
vec3 computeNormalSphere(vec3 p,Sphere s)
{
	return normalize(p - s.center);
}

// Function 1214
float  doubleplane(vec3 p, vec3 origin, vec3 normal){ 
   return max(dot(p - origin,normal),dot(-p - origin,normal));   
}

// Function 1215
float checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )
{
    // filter kernel
    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;                  
}

// Function 1216
vec3 sphereCenter(vec2 pos) {
    vec3 c = vec3(pos.x, 0., pos.y)+vec3(.25,.25,.25);
    c.xz += .5*hash22(pos);
	return c;
}

// Function 1217
float diplane(vec3 p,vec3 b,vec3 rd){
    vec3 dir = sign(rd)*b;   
    vec3 rc = (dir-p)/rd;
    return rc.z+0.01;
}

// Function 1218
float sdBox( vec3 p, vec3 b ) {
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - 0.1;
}

// Function 1219
float sphere(vec3 dir, vec3 center, float radius) {
    vec3 rp = -center;
	float b = dot(rp,dir);
	float dist = b * b - (dot(rp,rp) - radius * radius);
	if(dist <= 0.0) return -1.0;
	return -b - sqrt(dist);
}

// Function 1220
bool segment_box_intersection(
  in vec3 q1,
  in vec3 dirinv,
  in vec3 boxmin,
  in vec3 boxmax,
  in float t 
) {  
   vec3 T1 = dirinv*(boxmin - q1);
   vec3 T2 = dirinv*(boxmax - q1);
   vec3 Tmin = min(T1,T2);
   vec3 Tmax = max(T1,T2);
   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);
   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    
   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);
}

// Function 1221
float eyeRayToSphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)
{
    vec3 L = rayOrigin - sphereOrigin;
	float a = dot(rayDirection, rayDirection);
	float b = 2.0 * dot(rayDirection, L);
	float c = dot(L, L) - sphereRadius * sphereRadius;
	vec2 results = solveQuadratic(a, b, c);
    return results.x;
    
}

// Function 1222
float SdfSphere(Object obj, vec3 pos){
    return length(pos - obj.pos) - obj.scale.x;
}

// Function 1223
float sdPlane( vec3 p )
{
  return p.y;
}

// Function 1224
float cylinderSDF(const in vec3 p, const in vec2 h) {
    return plateSDF(vec2(length(p.xy), p.z), h);
}

// Function 1225
Hit boxSDF( vec3 p, Box b )
{
  vec3 q = abs(p - b.center) - (b.size);
  float radius = 0.02;
  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);
}

// Function 1226
float sphere2(in vec3 rp) {
   	return length(rp-vec3(0.,-1.,-5.))-3.;
}

// Function 1227
float boxDistance(vec2 pos, vec2 center, vec2 normal, vec2 scale) {
    mat2 rot = mat2(normal.x, -normal.y, normal.y, normal.x);
	vec2 delta = rot * (pos - center);
    delta = clamp(delta, -scale, scale);
    vec2 clampPos = center + delta * rot;
    return length(clampPos - pos);
}

// Function 1228
float iSphere(vec2 ro, vec2 rd, vec2 cPos, float r){

    vec2 O_C = ro-cPos;
    
    float a = dot(rd,rd);
    float b = 2.*dot(rd,O_C);
    float c = dot(O_C,O_C) - r*r;
    
    float disc = b*b-4.*a*c;
    
    if(disc < 0.) return -1.;
  

    float t1 = (-b - sqrt(disc))/(2.*a); 
    float t2 = (-b + sqrt(disc))/(2.*a);
    
    inside_circle = t1 < 0. && t2 > 0. ? 1. : 0.; 
    
    if(t1 >= 0.){return t1;}
    else if(t2 >= 0.){return t2;}
    else return -1.;
}

// Function 1229
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, float flag) {
    // dot(pos + t * dir, pos + t * dir) == r * r;
    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r
    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0
    float dis = flag * 1.0 * fractal_brownian_motion(pos);
    float a = dot(dir, dir);
    float b = dot(pos, dir);
    float c = dot(pos, pos) - (r + dis) * (r + dis);
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    float t = -b - sqrt(D);
    if (t > 0.0) {
        normal = normalize(pos + t * dir);
        return t;
    }
    t = -b + sqrt(D);
    if (t < 0.0) {
        return INF;
    }
    normal = normalize(pos + t * dir);
    return t;
}

// Function 1230
float getSphereUniformPdf()
{
	return 1.0/(4.0*PI);
}

// Function 1231
vec4 tri_ui_box(int idx, float delta) {
    
    return vec4(char_ui_box(idx).xy + vec2(0, 0.9*delta*text_size), 
                0.4*text_size, 0.3*text_size);
    
}

// Function 1232
float sphere(vec3 p, float r)
{return length(p) - r;}

// Function 1233
float sdCylinderXZ( vec3 p, vec2 h )
	{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }

// Function 1234
float box(vec3 p, vec3 b) {
	b = abs(p) - b;
	return min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));
}

// Function 1235
float atm_planet_shadow( float coschi, float cosbeta )
{
    return clamp( SCN_RAYCAST_SHADOW_UMBRA * ( coschi + cosbeta ) + .5, 0., 1. );
}

// Function 1236
vec4 sdCylinder(in vec3 p, float r1, float r2, float h, vec3 color){
    vec2 d = vec2(length(p.xz)-2.0 * r1+r2, abs(p.y) - h);
    float e= min(max(d.x, d.y),0.0) + length(max(d,0.0)) - r2;
    return vec4(color.rgb, e);
}

// Function 1237
float roundBox( in vec2 p, in vec2 b, in float r ) 
{
    vec2 q = abs(p) - b;
    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );
    float d = (m.x > 0.0) ? length(q) : m.y; 
    return d - r;
}

// Function 1238
float OpenCylinderIntersect( vec3 p0, vec3 p1, float rad, Ray r, out vec3 n ){
	float r2=rad*rad;
	
	vec3 dp=p1-p0;
	vec3 dpt=dp/dot(dp,dp);
	
	vec3 ao=r.origin-p0;
	vec3 aoxab=cross(ao,dpt);
	vec3 vxab=cross(r.direction,dpt);
	float ab2=dot(dpt,dpt);
	float a=2.0*dot(vxab,vxab);
	float ra=1.0/a;
	float b=2.0*dot(vxab,aoxab);
	float c=dot(aoxab,aoxab)-r2*ab2;
	
	float det=b*b-2.0*a*c;
	
	if(det<0.0)
	return INFINITY;
	
	det=sqrt(det);
	
	float t = INFINITY;
	
	float t0=(-b-det)*ra;
	float t1=(-b+det)*ra;
	
	vec3 ip;
	vec3 lp;
	float ct;
	if (t1 > 0.0)
	{
		ip=r.origin+r.direction*t1;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if((ct>0.0)&&(ct<1.0))
		{
			t = t1;
		     	n=(p0+dp*ct)-ip;
		}
		
	}
	if (t0 > 0.0)
	{
		ip=r.origin+r.direction*t0;
		lp=ip-p0;
		ct=dot(lp,dpt);
		if((ct>0.0)&&(ct<1.0))
		{
			t = t0;
			n=ip-(p0+dp*ct);
		}
		
	}
	return t;
}

// Function 1239
RayHit rayVsPlane(in Ray ray, in Plane plane){
    RayHit result = RayHit(vec3(0.0, 0.0, 0.0), -ray.dir, maxDistance);
    RayHit defaultResult = result;
    
    float planeDot = dot(ray.dir, -plane.n);
    float normalDist = dot(ray.start - plane.pos, plane.n);
    float t = normalDist / planeDot;
    result.dist = t;
    result.n = plane.n;
    result.color = sceneColor(ray.start + ray.dir * t);//vec3(1.0, 1.0, 1.0);
    //return result;
    return mixRayHits(defaultResult, result, float(
        (planeDot > 0.0) && (t > 0.0)
    ));
	    
    
    return result;
}

// Function 1240
bool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {
    float denom = dot(pn, rd);
    if (denom > MIN_FLOAT) {
        vec3 p0l0 = po - ro;
        float t = dot(p0l0, pn) / denom;
        if(t >= MIN_FLOAT && t < MAX_FLOAT){
			dist = t;
            return true;
        }
    }
    return false;
}

// Function 1241
float distSphere( vec3 p, float s )
{
    // Standard UV wrapping for a sphere
    float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / s / .5;
    float v = (.5 - asin(p.y) / 3.14159) / s / .5;
    float disp = texture( iChannel0,
                           vec2(u,v)).r;
    
    // The exponential smooths out the displacement so we don't have crazy looking poles
	return length(p)-s - (disp * 0.1 * (s / .5) * exp(1. - abs(p.y))/exp(1.));
}

// Function 1242
float cylinder(float r, float h, vec3 p) {
    return max(length(p.xy)-r, abs(p.z)-h);
}

// Function 1243
float sdfSphere(vec3 p, mat4 t) {
    p = vec3(t * vec4(p, 1));
    return length(p) - 1.;
}

// Function 1244
vec3 squareToUniformSphereCap(in vec2 s, in float height)
{
    vec3 result;
    result.z = s.y * (height - 1.0) + 1.0;
    
    float ringRadius = sqrt(1.0 - result.z * result.z);
    result.xy = vec2(sin(s.x * 2.0 * PI), cos(s.x * 2.0 * PI)) * ringRadius;
  
    return result;
}

// Function 1245
vec3 PlaneMaterial(Intersection i)
{
	float d = 0.0;
	// checkerboard function that returns 0 or 1
	d = mod(floor(i.p.x)+floor(i.p.z),2.0);
	// vary between red (0) and yellow (1)
	return vec3(0.8 + 0.1*d, 0.3 + 0.55*d, 0.15 - 0.1*d)*0.8;
}

// Function 1246
float torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; }

// Function 1247
float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)
{
  p.x = abs(p.x);
  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

// Function 1248
vec3 SampleHemisphereCosineWeighted(vec3 N, vec2 s)
{
    float sinThetaSqr = s.y;
	float sinTheta = sqrt(sinThetaSqr);
	float cosTheta = sqrt(1.0 - sinThetaSqr);
	return SampleHemisphere(N, sinTheta, cosTheta, s.x);
}

// Function 1249
float box(vec3 p, vec3 s) {
  p=abs(p)-s;
  return max(p.x, max(p.y,p.z));
}

// Function 1250
int findIndexShortestPlane(vec3 p){
    float planeDists = sdfPlane(p,planes[0].position,planes[0].normal);
    int minP = 0;
    planes[0].dist = planeDists;
    for(int i = 1; i < planes.length(); i++){
        if(i == planes.length()){
        	break;   
        }
        float iPlaneSdf = sdfPlane(p, planes[i].position, planes[i].normal);
        planeDists = min(planeDists,iPlaneSdf);
        planes[i].dist = iPlaneSdf;        
        if(planeDists == iPlaneSdf){
            minP = i;
        }
    }
    return minP;
}

// Function 1251
float sdCylinder( vec3 p, vec3 cen, float h)
{
    //I've reduced the Cylinder to this
    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(cen.z,h);
   // return length(max(d,0.));
    
    // and it can be expaned to
    float dx = length(p.xy) - cen.z;
    float dy = abs(p.z)  - h;
    return min(max(dx,dy),0.0) + length(max(vec2(dx,dy),0.));
    
}

// Function 1252
float sdTorus( vec3 p, vec2 t )
{
	vec2 q = vec2(length(p.zy)-t.x,p.x);

    return length(q)-t.y;
}

// Function 1253
float sdBox( vec3 p, vec3 b ,out vec2 uv)
{
    vec3 d = abs(p) - b;
    /*
    vec3 uv_ = abs(p);
    if(uv_.x>uv_.y)
    {
        if(uv_.x>uv_.z)
            uv = p.yz;
        else
            uv = p.xy;
    }
    else
    {
        if(uv_.y>uv_.z)
            uv = p.zx;
        else
            uv = p.xy;
    }
    */
    uv = p.xy;
    uv = uv*0.5 +0.5;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1254
vec3 cosineSampleHemisphere() {
    vec2 u = vec2(rnd(), rnd());
    float r = sqrt(u.x);
    float theta = 2.0 * PI * u.y;
    return vec3(r * cos(theta), r * sin(theta), sqrt(saturate(1.0 - u.x)));
}

// Function 1255
float sphereSD(vec3 p) {
    return length(p) - 1.0 - (uv(p, normalize(p), iChannel1).r * 0.2);
}

// Function 1256
float sdTorus82(in vec3 p, float r, vec2 sz) {
	return max(abs(length(p.xz) - r)-sz.x, abs(p.y) - sz.y);
}

// Function 1257
vec3 PointOnHemisphereCosine( inout uint seed, vec3 n )
{
    // from smallpt: http://www.kevinbeason.com/smallpt/

    vec2 uv = FRand2( seed );

    float r1 = 2.0f * PI * uv.x;
    float r2 = uv.y;
    float r2s = sqrt(r2);

    vec3 w = n;
    vec3 u;
    if (abs(w.x) > 0.1f)
        u = cross(vec3( 0.0f, 1.0f, 0.0f ), w);
    else
        u = cross(vec3( 1.0f, 0.0f, 0.0f ), w);

    u = normalize(u);
    vec3 v = cross(w, u);
    vec3 d = (u*cos(r1)*r2s + v*sin(r1)*r2s + w*sqrt(1.0 - r2));
    d = normalize(d);

    return d;
}

// Function 1258
vec2 intersect_box(in vec3 orig, in vec3 dir) {

	vec3 inv_dir = 1.0f / dir;
	vec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;
	vec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;
	vec3 tmin = min(tmin_tmp, tmax_tmp);
	vec3 tmax = max(tmin_tmp, tmax_tmp);

	return vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));
}

// Function 1259
float sdSphere( in vec3 p, in vec3 c, in float r )
{
    return length(p-c) - r;
}

// Function 1260
float sphere(vec3 p, float d) {
	return length(p) - d;
}

// Function 1261
float torus(vec3 pos, float x, float y, float z)
{
  const float TORUS_RADIUS = 2.0;
  const float TORUS_DIM = 0.4;
#ifdef SYMMETRY
  pos.x = abs(pos.x);
#endif    
  pos = rot(pos - vec3(x,y,z),x,y,z);
  return length(vec2(length(pos.xz)-TORUS_RADIUS,pos.y))-TORUS_DIM;   
}

// Function 1262
float planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {
    return dot(o - ro, n) / dot(rd, n);
}

// Function 1263
vec2 ConeDistances ( in Cone cone, in vec3 p, in vec3 v )
{
    // Convert to standard form A(d^2) + Bd + C = 0
    float t0 = v.z * cone.Zs;
    float t1 = cone.Zo + p.z*cone.Zs;
    float A = (v.x*v.x + v.y*v.y - t0*t0);
    float B = 2.0*(p.x*v.x + p.y*v.y - v.z*cone.Zs*t1);
    float C = (p.x*p.x + p.y*p.y - t1*t1);

	// Then solve, paying attention to numerical stability as shown in
	// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm
	// x1 = (-B-sgn(B)*sqrt(B^2-4AC))/2A
    // x2 = C/(Ax1)
    float discriminant = B*B-4.0*A*C;
	if ( discriminant < 0.0 )
    {
        return vec2(-1.0,-1.0);
    }
	float d1 = (-B-sign(B)*sqrt(discriminant))/(2.0*A);
    float d2 = C/(A*d1);
    vec2 res = vec2(d1, d2);
	return res;
}

// Function 1264
float sphere(in vec3 p, in float r)
{
    return length(p) - r;  
}

// Function 1265
maybe_float get_distance_along_3d_line_to_capped_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r1,
    in float r2
){
    float dh = length(B2 - B1);
    float dr = r2 - r1;
    float rmax = max(r2, r1);
    float rmin = min(r2, r1);
    float hmax = rmax * dr / dh;
    float hmin = rmin * dr / dh;
    vec3 B = sign(dr) * normalize(B2 - B1);
    vec3 Bmax = (r2 > r1? B2 : B1);
    vec3 B0 = Bmax - B * hmax;
    vec3 Bmin = Bmax - B * hmin;
    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);
    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));
    float c_h = dot(A0 + cone.value * A - B0, B);
    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;
    cone = get_distance_along_line_to_union(cone, end1);
    cone = get_distance_along_line_to_union(cone, end2);
    return cone;
}

// Function 1266
float Box(vec3 p, vec3 b) {
    vec3 d=abs(p-b*0.5)-b*0.5;
    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 1267
float sphere(vec4 ray,vec3 u, float radius
){maxGISize = max(maxGISize,radius*ray.w)
 ;return ray.w*(length(ray.xyz-u)-radius);}

// Function 1268
vec2 box( vec3 p, vec3 b, float r ) {
    vec3 c = vec3(4.0,4.0,4.0);
    vec3 p2 = mod(p,c)-0.5*c;
	return vec2(length(max(abs(p2)-b,0.0))-r,p2.z);
}

// Function 1269
float sphere(vec3 p, float r){
    return length(p)-r;
}

// Function 1270
float sdBox(vec3 p, vec3 b
){vec3 d=abs(p)-b//box (sharp corners, upper bound)
 ;return min(max(d.x,max(d.y, d.z)),0.)+length(max(d,0.))//box to boxRounded
 ;}

// Function 1271
vec4 Sphere2(vec4 sphereBase, float uRandom)
{
	return sphereBase + VecOsc(
							vec4(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0, 0),
							vec4(20, 100, 100, 0) +
							VecOsc(
								vec4(1.0 / 10.0, 1.0 / 14.0, 1.0 / 6.0, 0),
								vec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);
}

// Function 1272
float box (in float x, in float x1, in float x2, in float a, in float b) {
	return tanh(a * (x - x1)) + tanh(-b * (x - x2));
}

// Function 1273
float SphereSDF(vec3 point, float rad) {
    return length(point) - rad;
}

// Function 1274
int cylinder(
    vec3 origin,
    vec3 direction,
    vec3 center,
    vec3 orient,
    float radius,
    inout float t,
    inout vec3 hit,
    inout vec3 normal)
{
    vec3 approach = cross(direction, orient);
    float distance = abs(dot(origin - center, normalize(approach)));
    if (distance > radius)
        return 0;
    float t_center = dot(cross(orient, origin - center), approach) /
        dot(approach, approach);
    float t_half = sqrt(radius * radius - distance * distance) /
        dot(direction, normalize(cross(orient, approach)));
    float t_cylinder = t_center - t_half;
    if (t_cylinder < epsilon || t < t_cylinder)
        return 0;
    t = t_cylinder;
    hit = origin + direction * t;
    normal = ((hit - center) - dot(hit - center, orient) * orient) / radius;
    return 1;
}

// Function 1275
vec2 obj_torus(in vec3 p)
{
  vec2 r = vec2(2.1,0.5);
  vec2 q = vec2(length(p.xy)-r.x,p.z);
  float d = length(q)-r.y;
  return vec2(d,1);
}

// Function 1276
float sdBox(vec3 p, vec3 b) {
  	vec3 d = abs(p) - b;
  	return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 1277
float sdSphere( vec3 p, float s ) {
  return length(p)-s;
}

// Function 1278
bool sphere( in vec3 p, in vec3 sphereP, in float radius, out vec3 resN )
{
    vec3 deltaP = p - sphereP;
    if ( length( deltaP ) < radius )
    {
        resN = normalize( deltaP );
        return true;
    }
	return false;
}

// Function 1279
float box (in vec3 p, in vec3 b, in float r) {
	#ifdef BOX_NEGATIVE
	vec3 d = abs (p) - b + r;
	return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0)) - r;
	#else
	return length (max (abs (p) - b + r, 0.0)) - r;
	#endif
}

// Function 1280
float sdFibonacciHemisphere(vec3 p) {
    float d = sqdFibonacciPoint(p, NUM_SAMPLES, 0);
    for (int i = 1; i < NUM_SAMPLES; ++i) {
        d = min(d,sqdFibonacciPoint(p, NUM_SAMPLES, i));
    }
    
    d = sqrt(d) - 1.0;
	return max(d, -p.z);    
}

// Function 1281
vec3 boxDivide(in vec2 p) {
    
    vec2 ip = floor(p);
    
    p -= ip;
    
    vec2 l = vec2(1);

    bool flip=false;
    
    for(int i=0; i<8; i++) {
 
        float r = hash21(l + ip)*0.5 + 0.25;
        
        if(l.x>l.y) { p=p.yx; l=l.yx; flip=true; }
        
        if(p.x<r) { l.x /= r; p.x /= r; }
        else { l.x /= (1.-r); p.x = (p.x-r)/(1.-r); }
        
        if(flip){ p=p.yx; l=l.yx; flip=false; }
        
    }
    
    p = clamp(p, 0., 1.);
    
    // Making a basic rounded box.
    //float f = max(1.- dot(pow(abs(p - .5), vec2(6)), vec2(64)), 0.);
   
    float f = pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.5);
    
    //float f = pow(abs(sin(p.x*3.14159)*sin(p.y*3.14159)), 0.3);
    
    //return vec3(min(p*f*1.5, 1.), f);
    return vec3(f);
}

// Function 1282
float rounded_cone_sdf( vec3 p, float r1, float r2, float h )
{
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 1283
float oSphere( in vec3 pos, in vec3 nor, in vec4 sph )
{
    vec3 di = sph.xyz - pos;
    float l = length(di);
    return 1.0 - max(0.0,dot(nor,di/l))*sph.w*sph.w/(l*l); 
}

// Function 1284
Hit intersectSphere(Sphere s, Ray r)
{
	vec3 op = s.center - r.o;
    float b = dot(r.d, op);
    float det = b * b - dot(op, op) + s.r * s.r;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t = b - det;
    if (t < 0.) t = b + det;
    if (t < 0.) return noHit;

    return Hit(t, (r.o + t*r.d - s.center) / s.r, s.m);
}

// Function 1285
float sdTorus82( vec3 p, vec2 t, mat3 m  )
{
  p = m * p;
  vec2 q = vec2(length2(p.xz)-t.x,p.y);
  return length8(q)-t.y;
}

// Function 1286
v0 cylinderX(v2 u,v0 r,v0 h){return cylinderZ(u.zyx,r,h);}

// Function 1287
float planeDist(vec4 plane, vec3 point)
{
    
	return abs(dot(plane, vec4(point, 1.0)));
}

// Function 1288
float sphere (vec3 spherePos, vec3 pos, float radius){
    return length(pos-spherePos)-radius;
}

// Function 1289
float PrimSphere(vec3 p, float s) 
{
    return length(p)-s;
}

// Function 1290
float sdSphere(in vec3 l, in sph s) {
    vec3 oc = l - s.l;
    return dot(oc, oc) - s.r * s.r;
}

// Function 1291
void sampleSphereHemisphereCosinus(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){
    
    vec3 main_direction = normalize(viewer - sphere.position);
    sls.normal = randomDirectionHemisphere(main_direction, 1.0f);
    
    sls.point = sphere.position + (sphere.radius ) * sls.normal;
    
    sls.pdf = dot(main_direction, sls.normal) / (PI * sphere.radius2);
}

// Function 1292
float occSphere(vec3 u,vec3 n,vec4 s){vec3 i=s.xyz-u;return 1.-dot(n,normalize(i))*s.w*s.w/dd(i);}

// Function 1293
float plane(vec3 p, vec4 n) {
	return dot(p,n.xyz) - n.w;
}

// Function 1294
vec2 iCSphere2( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	float d = b * b - c;
	if ( d < 0.0 ) return vec2( MAX, -MAX );
	d = sqrt( d );
	return vec2( -b - d, -b + d );
}

// Function 1295
float sdBox(vec3 pos, vec3 bounds) {
    return length(max(abs(pos) - bounds, 0.));
}

// Function 1296
float boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
	vec3 p = (txx*vec4(pos,1.0)).xyz;
	vec3 n = (txx*vec4(nor,0.0)).xyz;
    
    // Orient the hexagon based on p
    vec3 f = rad * sign(p);
    
    // Make sure the hexagon is always convex
    vec3 s = sign(rad - abs(p));
    
    // 6 verts
    vec3 v0 = normalize( vec3( 1.0, 1.0,-1.0)*f - p);
    vec3 v1 = normalize( vec3( 1.0, s.x, s.x)*f - p);
    vec3 v2 = normalize( vec3( 1.0,-1.0, 1.0)*f - p);
    vec3 v3 = normalize( vec3( s.z, s.z, 1.0)*f - p);
    vec3 v4 = normalize( vec3(-1.0, 1.0, 1.0)*f - p);
    vec3 v5 = normalize( vec3( s.y, 1.0, s.y)*f - p);
    
    // 6 edges
    return abs( dot( n, normalize( cross(v0,v1)) ) * acos( dot(v0,v1) ) +
    	    	dot( n, normalize( cross(v1,v2)) ) * acos( dot(v1,v2) ) +
    	    	dot( n, normalize( cross(v2,v3)) ) * acos( dot(v2,v3) ) +
    	    	dot( n, normalize( cross(v3,v4)) ) * acos( dot(v3,v4) ) +
    	    	dot( n, normalize( cross(v4,v5)) ) * acos( dot(v4,v5) ) +
    	    	dot( n, normalize( cross(v5,v0)) ) * acos( dot(v5,v0) ))
            	/ 6.2831;
}

// Function 1297
bool intersectRayHyperPlane(in Ray4 _ray, in HyperPlane _plane, in Object _object, out Ray4Result _rayResult )
{
    
    _rayResult.m_d = - ( dot(_ray.m_pos,_plane.m_normal) + _plane.m_d ) / ( dot (_ray.m_dir,_plane.m_normal) );
	_rayResult.m_pos = _ray.m_pos + _ray.m_dir * _rayResult.m_d;
	_rayResult.m_normal = _plane.m_normal;
	_rayResult.m_object = _object;
    return true;

}

// Function 1298
vec2 plane_x(vec3 pos,float id){
	return vec2(pos.x,id);
}

// Function 1299
float sphere(vec3 pos, vec3 center, float radius)
{
	return length(pos - center) - radius; 
}

// Function 1300
float
capped_cylindery_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length( p.xz ), p.y ) ) - rh;
    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );
}

// Function 1301
bool rayConeIntersection( in Ray r, in float radius, in float radius2, in float height1, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    float height = (height1 * radius) / (radius - radius2);
    float k = radius / height;
    k = k * k;
    
    float a = r.dir.x * r.dir.x + r.dir.y * r.dir.y - k * r.dir.z * r.dir.z;
    float b = 2.0 * (r.dir.x * r.origin.x + r.dir.y * r.origin.y - k * r.dir.z * (r.origin.z - height));
    float c = r.origin.x * r.origin.x + r.origin.y * r.origin.y - k * (r.origin.z - height) * (r.origin.z - height);
    
	// Compute quadratic cone coefficients
	// Solve quadratic equation for _t_ values
	float t0, t1;
    if (!solveQuadratic( a, b, c, t0, t1) || ( t1 < 0.0 )){
		return false;
    } else {
        vec3 p;
        vec3 p0 = r.origin + r.dir * t0;
        vec3 p1 = r.origin + r.dir * t1;
        
        bool t0_is_valid = (t0 > 0.0) && (p0.z > 0.0) && (p0.z < height1);
        bool t1_is_valid = (t1 > 0.0) && (p1.z > 0.0) && (p1.z < height1);
        
        if(!t0_is_valid && !t1_is_valid) {
            return false;
        } else {
            t = mix(t1, t0, float(t0_is_valid));
            
            if( !forShadowTest ) {	
            	p = mix(p1, p0, vec3(t0_is_valid));
                float phi = atan(p.y,p.x) + PI;
                isect.position_ = p;
                isect.uv_.x = (phi)/TWO_PI;
                isect.uv_.y = (p.z)/(height1);
                isect.normal_ = normalize( vec3( p.xy, 0.0 ) );
                isect.tangent_ = orthogonalize(isect.normal_, vec3( 0.0, 0.0, 1.0 ));
            }

        	return true;
        }
    }
}

// Function 1302
float sdSphere( const vec3 p, const float r ) {
    return length(p) - r;
}

// Function 1303
void GetPlanet(vec3 sector, out planet res)
{
   	vec4 rnd = N24(vec2(sector.x + sector.z * 1.35, sector.y));
    float rad = mix(0.0, 0.4, rnd.x * rnd.w);
    res.radius = rad;
    res.center = vec3(rad) + rnd.yzw * vec3(1.0 - 2.0 * rad); // the smaller the planet is, the more off center it can get without crossing border
}

// Function 1304
float sdTorus( vec3 p, vec2 t ) {
    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 1305
vec4 sdPlane(vec3 p, float h, vec3 color){
    return vec4(color.rgb, p.y - h);
}

// Function 1306
float boxsdf(in vec3 ro, in vec3 r) {
    vec3 mo = abs(ro);
    vec3 b = mo - r;
    float d = max(b.x, max(b.y, b.z));
    // triplanar projection of animated noise for water effect
    vec3 mask = step(mo.zxy, mo.xyz) * step(mo.yzx, mo.xyz);
    ro *= 2.;
    float disp = mask.x * fractalnoise(ro.yz + vec2(0., iTime), 0.25) + mask.y * fractalnoise(ro.zx + vec2(iTime, 0.), 0.25) + mask.z * fractalnoise(ro.xy, 0.5);
    d += 0.015 * disp;
    return d;
}

// Function 1307
vec2 iSphere( in vec3 ro, in vec3 rd, in float rad )
{
	float b = dot( ro, rd );
	float c = dot( ro, ro ) - rad*rad;
	float h = b*b - c;
	if( h<0.0 ) return vec2(-1.0);
    h = sqrt(h);
	return vec2(-b-h, -b+h );
}

// Function 1308
float sdBox(vec2 p, vec2 s){
    p = abs(p) - s; return max(p.x, p.y);
}

// Function 1309
float sdSphere (in vec3 p, in float r) {
    return length (p) - r;
}

// Function 1310
float inv_sphere(in vec3 loc, in vec3 cent, in float rad) {
  return max(-rad, rad - length(cent - loc));
}

// Function 1311
vec3 sphereNormal(in vec3 p,in vec3 center,in float radius){
	return normalize(vec3(
        sdfSphere(vec3(p.x+EPSILON,p.y,p.z),center,radius)-sdfSphere(vec3(p.x-EPSILON,p.y,p.z),center,radius),
        sdfSphere(vec3(p.x,p.y+EPSILON,p.z),center,radius)-sdfSphere(vec3(p.x,p.y-EPSILON,p.z),center,radius),
        sdfSphere(vec3(p.x,p.y,p.z+EPSILON),center,radius)-sdfSphere(vec3(p.x,p.y,p.z-EPSILON),center,radius)
    ));
}

// Function 1312
vec4 fBox(DAVec3 p,vec3 s){//v3 s=v3(1.5,.5,1.5);
 m4 d=subdabsd(p,s);//mirror clamp
 v4 a=lengthd(maxdm(d,0.));//rounded corners
 m4 q=mindm(d,0.);//clamp
 v4 b=maxdm(q);//keep largest of 3
 return addd(a,b);}

// Function 1313
float box(vec3 p)
{
    vec3 d = abs(p) - 1.0;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1314
float mapSphere(in Sphere s, in vec3 p)
{
    return length(p - s.position) - s.radius;   
}

// Function 1315
sphereInfo GetSphereUvs(vec3 rd, vec2 i, vec2 rot, vec3 s) {
	sphereInfo res;
    rot *= 6.2831;
    vec4 q = aa2q(vec3(cos(rot.x),sin(rot.x),0), rot.y);
    vec3 o = qmulv(q, -s)+s;
    vec3 d = qmulv(q, rd);
    
    res.p1 = rd*i.x;
    vec3 p = o+d*i.x-s;
    res.uv1 = vec2(atan(p.x, p.z), p.y);
    res.n1 = res.p1-s;
    
    res.p2 = rd*i.y;
    p = o+d*i.y-s;
    res.uv2 = vec2(atan(p.x, p.z), p.y);
    res.n2 = s-res.p2;
        
    return res;
}

// Function 1316
Sphere newSphere(vec3 origin, float radius, vec3 color, bool castShadow, bool lit){
    Sphere sphere;
    sphere.origin = origin;
    sphere.radius = radius;
    sphere.color = color;
    sphere.castShadow = castShadow;
    sphere.lit = lit;
    return sphere;
}

// Function 1317
float boundingBox( in vec3 p, in vec3 r, out bool f )
{
	const float o = 0.05;
    f = false;
	if ( abs( p.x ) > r.x) return udBox( p, r - o );
	if ( abs( p.y ) > r.y) return udBox( p, r - o );
	if ( abs( p.z ) > r.z) return udBox( p, r - o );
	f = true;
    return length( p );
}

// Function 1318
float plane(vec3 p, vec4 n)
{
  // n must be normalized
  return dot(p, n.xyz) + n.w;
}

// Function 1319
float SphereShape(vec2 pos, vec2 centre, float radius, float curvep, float brightness)
{
    vec2 vec = (pos - centre);
    float dist = length(vec);
    if (dist > radius) return 0.0;
    return min(1.7,max(0.0, pow(1.0 - (dist / radius), curvep))) * brightness;   
}

// Function 1320
float BevelBox(vec3 p, vec3 size, float box_r)
{
	vec3 box_edge = size - box_r*0.5;
	vec3 dd = abs(p) - box_edge;

	//in (dd -ve)
	float maxdd = max(max(dd.x,dd.y),dd.z);
	//0 away result if outside
	maxdd = min(maxdd,0.0);
		
	//out (+ve);
	dd = max(dd,0.0);
	float ddd = (length(dd)-box_r);

	//combine the in & out cases
	ddd += maxdd;
	return ddd;
}

// Function 1321
float checkersGradBox(vec2 p) {
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;
}

// Function 1322
float
capped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )
{
    float R1z = (r1*h)/(r2-r1);
    float R2z = R1z + h;
    p = at_pos(vec3(0.0,0.0,-R1z),p);
	vec2 c = vec2(r2/R2z,1.0);
	return
	max( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),
         half_cone_pos_sd( c, p )
       );
}

// Function 1323
float box(vec3 p)
{
    p=abs(p);
    return max(max(p.x, p.y), p.z);
}

// Function 1324
float starbox(vec3 dir) {
	return starplane(dir.xyz) + starplane(dir.yzx) + starplane(dir.zxy);
}

// Function 1325
vec3 boxDivide(in vec2 p) {
    
    
    // Scaling factor. If changing this, you may need to change a few settings
    // here and there to suit your needs.
    const vec2 sc = vec2(1, 1)/3.; // See square tube scale.
    
   
    p *= sc;
   
    p.xy += .5;
    
    // Basid grid tile ID. This will be further split into subtiles, which will
    // each have their own ID based on postion.
    vec2 ip = floor(p); 
   
    // If using the vertical offset option, update the position and ID accordingly.
    #ifdef VERT_OFFSET
    if(mod(ip.x, 2.)>.5){
        p.y -= 1./2.;
        ip = floor(p);
    }
    #endif
   
    p -= ip + .5; // The original grid tile's base local coordinates.
    
    
    #ifdef SHOW_GRID
    float grid = abs(max(abs(p.x), abs(p.y)) - .5) - .005;
    #endif
    
    // Block dimension. Every time there's a random split, it'll be factored down
    // according to the random split factor.
    vec2 l = vec2(1, 1);  
    
    // The starting point, which represents the bottom left corner (or is it the top left corner?)
    // of the grid cell. With every split, it will be moved to the new split position.
    vec2 s = vec2(-.5);    
    
    // Split number.
    const int iNum = 6;

    
    //float r = hash21(ip);
    //float r2 = hash21(ip + .35);
    
    float count = 0.;
    
    
    // Create a box, divide it randomly, then do the same with the 
    // divided portions. Ad infinitum...
    for(int i=0; i<iNum; i++) {
 
        float r = hash21(ip + l + float(i)/float(iNum))*.3 + (1.-.3)/2.;
        // Forcing a vertical to horizontal split (and vice versa) every
        // iteration. It's not necessary, but I think it looks nicer.
        float r2 = mod(float(i), 2.)>.5? 0. : 1.;
        
        // Alternate, more randomized sequence.
        //float r2 = hash21(ip + 113.5 + l.yx + float(i)/float(iNum));
        // Alternate heuristic, for aesthetics purposes, to ensure at least one split.
        //if(i==iNum-1 && count<1.5) r2 = 1.;
		//if(i==iNum-1 && count>float(iNum) - 2.5) r2 = 0.;
 
        
        // Alternate way to randomize things. How this is achieved is up to the user.
        //r = hash21(l + r + float(i)/float(iNum))*.3 + (1.-.3)/2.;
        //r2 = hash21(l.yx + r + r2 + float(i)/float(iNum));
        
         
        //r2 = mod(float(i), 2.)>.5? 0. : 1.;
        //if(r2<.5) { p = p.yx; l = l.yx; s = s.yx; }
        
        // If the second random number is above a certain threshold, split 
        // vertically. Otherwise, split horizontally.
        if(r2>.5){ 
            
            // Counter for heuristics above. Uncomment if using them.
            // count++;
            
            // This line splits the current cell down the middle, in accordance with
            // the random factor, "r," and the cell width "l.x." 
            if(p.x>s.x + l.x*r) {

                s.x += l.x*r; // Advance the position to the right of the split.
                l.x *= (1. - r); // Reduce the width by a factor of "1 - r."
            }
            else l.x *= r; // No need to advance position, but we need to reduce the width.
        
        }
        else {
            
              // This line splits the current cell horizontally, in accordance with
             // the random factor, "r," and the cell height "l.y." 
             if(p.y>s.y + l.y*r) {

                s.y += l.y*r; // Advance the position above (or below?) the split.
                l.y *= (1. - r); // Reduce the height by a factor of "1 - r."

             }
             else l.y *= r; // No need to advance position, but we need to reduce the height.
            
        }

    }
    
    
    // Constructing the box itself: Actually, once you have the box coordinates, you can 
    // do whatever you want with them.
    //
    // Rounding factor: This depends on the look you're after. It could be a constant, 
    // or you could choose to have no rounding at all. After experimentingn, I decided 
    // to make the roundedness of the tile dependent on the minimum side length.
    float rf = min(l.x, l.y); 
    float d = sBox(p - s - l/2., l/2., .08*sqrt(rf));
    
   
    
    // Smoothing factor.
    float sf = 8./iResolution.y*sc.x;
    
    // Individual, position-based tile ID. Note that it'll read into the texture
    // at the correct position.
    vec2 id = ip + s + l/2.;
    
    // If using the vertical offset, the ID needs to follow suit.
    #ifdef VERT_OFFSET
    if(mod(ip.x, 2.)>.5){
        id.y += .5;
    }
    #endif
    
    
    
    // Using the ID to color the individual tile.
    
    
    // Textured version. Note that this is not an overlay -- Each tile has 
    // a uniform color.
    vec3 tx = texture(iChannel0, id/sc/1.5).xyz; tx *= tx;
    vec3 pCol = 1. - tx;
    
    // Original random colored version.
    //vec3 pCol = vec3(1, hash21(id), hash21(id*57. + .5));
    
    // 2D noise, etc.
    //float c =  n2D(id*2. + iTime);
    //vec3 pCol = min(vec3(c*.1 + .9, c + .05, c*c*.7), 1.); 

    
   
    
    vec3 col = vec3(.5);
    float sh = clamp(.5 - d*5./length(l), 0., 1.5);
    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.
    col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .02*sc.x)); 
    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .03*sc.x) - .001*sc.x)); 
    // More decoration, if so desired.
    //col = mix(col, mix(pCol*1.5, vec3(1), .35), 1. - smoothstep(0., sf, d + .02*sc.x)); 
    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d + .034*sc.x))*.9); 
    //col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .042*sc.x)); 
 
    
    // Center, space preserving dots.
    
    // Just the center dot.
    //float d2 = length(p - s - l/2.) - .015/sc;
    
    /*
    // Splitting space to produce four rivot-looking dots.
    p = abs(p - s - l/2.) - l/2. + .0225;
    float d2 = length(p) - .002/sc.x;
    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.
    col = mix(col, vec3(2), 1. - smoothstep(0., sf, d2 + .007)); // Rounded pavers.
    */
    
    #ifdef SHOW_GRID
    col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., grid - .005)); 
    col = mix(col, vec3(1, .8, .2), 1. - smoothstep(0., sf, grid)); 
    #endif
 
 
    
    return col;
    
}

// Function 1326
float sdRoundedCone(vec3 p, vec3 a, vec3 b, float r1, float r2)
{
    // sampling independent computations (only depend on shape)
    vec3  ba = b - a;
    float l2 = dot(ba,ba);
    float rr = r1 - r2;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    // sampling dependant computations
    vec3 pa = p - a;
    float y = dot(pa,ba);
    float z = y - l2;
    float x2 = dot2( pa*l2 - ba*y );
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    // single square root!
    float k = sign(rr)*rr*rr*x2;
    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;
    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;
                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;
}

// Function 1327
vec2 sdPlane(vec3 p, vec4 n, float id)
{
  // n must be normalized
 float bounce = (1.0 - gS.isFailed) * 0.05 * abs(sin(6.5*iTime));
  return vec2( dot(vec3(p.x,p.y, max(p.z + bounce + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);
}

// Function 1328
float sdPlane( vec3 p, vec4 n )
{
    // n must be normalized
    return dot(p,n.xyz) + n.w;
}

// Function 1329
bool hitSphere(Ray r, Sphere s, out HitRecord hit)
{        
    vec3 oc = r.origin - s.center;
    float a = dot(r.direction, r.direction);
    float b = 2.0 * dot(oc, r.direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float det = b*b - 4.0*a*c;
    if (det < 0.0) {
        return false;
    }
    
    // first possible intersection
    float t = (-b - sqrt(det)) / (2.0 * a);
    if (r.mint <= t && t < r.maxt) { 
        hit.t = t;
        hit.P = r.origin + t * r.direction;
        hit.N = normalize(hit.P - s.center);
        
        hit.col = s.color * computeLightInt(hit);
           
        return true;
    }

    // second possible intersection
    t = (-b + sqrt(det)) / (2.0 * a);
    if (r.mint <= t && t < r.maxt) { 
        hit.t = t;
        hit.P = r.origin + t * r.direction;
        hit.N = normalize(hit.P - s.center);
        return true;
    }

    return false;
}

// Function 1330
vec3 cosineSampleHemisphere(const in vec2 u) {
    vec2 d = concentricSampleDisk(u);
    float z = sqrt(max(EPSILON, 1. - d.x * d.x - d.y * d.y));
    return vec3(d.x, d.y, z);
}

// Function 1331
float shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)
{
	float lambda = dot(-(ro - sphere.xyz),rd);
	float dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;
	return mix(9999.0,dist,step(0.0,lambda)); 
}

// Function 1332
float sdPlane( const vec3 p ) {
	return p.y;
}

// Function 1333
float planeSDF(vec3 pos)
{
    // Bottom plane
    return pos.z+0.4;
}

// Function 1334
void nBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 outNor, out vec2 outST, out uint outFaceID ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    // intersect and select
    vec3 s = -sign(rdd);
    vec3 t = (-roo + s*rad)/rdd;
    
    // compute normal in world space
         if( t.x>t.y && t.x>t.z ) { outNor = txi[0].xyz*s.x; outST = roo.yz+rdd.yz*t.x; outFaceID=uint(1+int(s.x))/2U; /* 0, 1 */ } 
    else if( t.y>t.z )            { outNor = txi[1].xyz*s.y; outST = roo.zx+rdd.zx*t.y; outFaceID=uint(5+int(s.y))/2U; /* 2, 3 */ }
    else                          { outNor = txi[2].xyz*s.z; outST = roo.xy+rdd.xy*t.z; outFaceID=uint(9+int(s.z))/2U; /* 4, 5 */ }
}

// Function 1335
vec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k, in float LOD)
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz, LOD);
  vec4 y = textureLod( sam, p.zx, LOD);
  vec4 z = textureLod( sam, p.xy, LOD);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1336
float udRoundBox( vec2 p, vec2 b, float r )
{
    return length(max(abs(p)-b+r,0.0))-r;
}

// Function 1337
float drawPlane(vec3 ro1, vec3 rd1) {
    vec3 n = vec3(0.0, 1.0, 0.0);
    vec3 floorP = vec3(0.0);
    
    float t = -dot(ro1 - floorP, n) / dot(rd1, n);
    
    return t;
}

// Function 1338
bool sphere_trace(in vec3 orig, in vec3 dir, out vec3 pos) {
    if (dot(orig,orig) - dot(orig,dir)*dot(orig,dir) > sphere_radius*sphere_radius)
        return false;
    pos = orig;
    for(int i = 0; i < 128; i++) {
        float d = signed_distance(pos);
        if (d < 0.0) return true;
        pos = pos + dir*max(d*0.1, 0.01);
    }
    return false;
}

// Function 1339
float dfBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.))-r;}

// Function 1340
vec2 sdPlane( vec3 p, vec4 n, float id )
{
  float d =  dot(p,n.xyz) + n.w;
  return vec2(d,id);
}

// Function 1341
void findCylinderNearFar(vec3 ro, vec3 rd, float r, vec2 cy, out float fNear, out float fFar)
{
	// x^2 + z^2 = r^2 => (ro.x + t*rd.x)^2 + (ro.z + t*rd.z)^2 = r^2
	float fA = dot(rd.xz, rd.xz);
	float fB = 2. * dot(rd.xz, ro.xz);
	float fC = dot(ro.xz, ro.xz) - r * r;
	float fDet = fB * fB - 4. * fA * fC;
	if (fDet < 0.)
	{
		fNear = 0.;
		fFar = -1.;
		return;
	}
	float sqrtD = sqrt(fDet);
	float inv2A = 1. / (2. * fA);
	vec2 p = (cy - ro.y) / rd.y;
	p += step(rd.y,0.) * (p.yx - p);
	fNear = max((-fB - sqrtD) * inv2A, p.x);
	fFar = min((-fB + sqrtD) * inv2A, p.y);
}

// Function 1342
vec3 intersect_sphere(vec3 ro,                 
                             vec3 rd, 
                             float r,
                             vec3 sc)
{
    // Calculate the ray origin in object space of the sphere
    vec3 oro = ro - sc;

    // We don't consider an intersection if the ray is inside the sphere

    // DEBRANCH
    // Equivalent to:
    // if (dot(ospaceRayOrigin, ospaceRayOrigin) < radius*radius) {
    //     return vec3(0.);
    // }
    float inside = step(dot(oro, oro), r*r);
    
    float a = dot(rd, rd);
    float b = dot(oro, rd);
    float c = dot(oro, oro) - r*r;
    float discr = b*b - a*c; // discriminant

    // DEBRANCH
    // Equivalent to:
    // if (discr > 0.) {
    //     ...
    // }

    float isdiscrgtZero = step(0., discr);

    // Real root of disc, so intersection
    float sdisc = sqrt(abs(discr));
    float tmin = (-b - sdisc)/a;
    float tmax = (-b + sdisc)/a; 

    float hit = step(0., tmin) + step(0., tmax);

    return step(0., isdiscrgtZero) * vec3(hit, tmin, tmax);
}

// Function 1343
bool intersectsCylinder(vec3 center, float rad, vec3 origin, vec3 dir)
{
    vec2 center2D = vec2(center.x,center.y);
    vec2 origin2D = vec2(origin.x,origin.y);
    vec2 dir2D = vec2(dir.x,dir.y);
    
    vec2 oc = origin2D - center2D;
    float a = dot(dir2D,dir2D);
    float b = 2.0 * dot(dir2D,oc);
    float c = dot(oc,oc) - rad*rad;
    
    float det = b*b - 4.0*a*c;
    if (det < 0.0) {
        return false;   
    }
    else {
        float t1 = (-b - sqrt(det)) / (2.0*a);
        float t2 = (-b + sqrt(det)) / (2.0*a);
        float z1 = origin.z + dir.z*t1;
        float z2 = origin.z + dir.z*t2;
        if  (( (z1 < ground_z) && (z1 > 0.0) ) ||
             ( (z2 < ground_z) && (z2 > 0.0) )) {
            return true;        
        }
        return false;
    }
}

// Function 1344
bool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )
{
    float he2 = he*he;
    
    float k2 = 1.0        - rd.y*rd.y;
    float k1 = dot(ro,rd) - ro.y*rd.y;
    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return false;
    h = sqrt(h);
    float t = (-k1-h)/k2;

    // body
    float y = ro.y + t*rd.y;
    if( y>0.0 && y<he )
    {
        return t>0.0 && t<tmax;
    }
    
    // caps
    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;
    if( abs(k1+k2*t)<h )
    {
        return t>0.0 && t<tmax;
    }

    return false;
}

// Function 1345
float box( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1346
float CylinderXZ( vec3 p, vec3 c ) {
	return length(p.xz-c.xy)-c.z;
}

// Function 1347
traceData modsphere (vec3 p, float rad){

traceData tout;

tout.p = vec3(   mod(((2.*(p.x+.5))-1.),iModX)-.5*iModX ,  mod(((2.*(p.z+.5))-1.),iModY)-.5*iModY ,      mod(((2.*(p.y+.5))-1.),iModZ)-.5*iModZ);
tout.l = length(tout.p) - rad;
return tout;

}

// Function 1348
float alignedBoxAppSurface(vec3 view, vec3 widths){
    const vec3 xaxis = vec3(1.f,0.f,0.f);
    const vec3 yaxis = vec3(0.f,1.f,0.f);
    const vec3 zaxis = vec3(0.f,0.f,1.f);
	float res= rectAppSurface(view, zaxis, widths.xy, false);
    res+= rectAppSurface(view, xaxis, widths.yz, false);
    res+= rectAppSurface(view, yaxis, widths.xz, false);
    return res;
}

// Function 1349
vec3 sphere_from_plane(vec2 q) {

    float qq = dot(q, q);
        
    return vec3(2.*q, -1.+qq) / (1. + qq);

}

// Function 1350
float udRoundBox( vec3 p, vec3 b, float r )
{
  return length(max(abs(p)-b, 0.0))-r;
}

// Function 1351
float sdBox(in vec4 p, in vec4 b) {
  vec4 d = abs(p) - b;
  return min(max(d.x,max(d.y,max(d.z,d.w))),0.) + length(max(d,0.));
}

// Function 1352
float map_box(in vec3 ro) {
  vec3 d = abs(b1.c - ro) - b1.s;
  return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));
}

// Function 1353
float sdBox(float dt, vec3 p, vec3 b)
{
    return sdBox(p,(1.-1.3*spt(p,dt))*b);
}

// Function 1354
vec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3 oc = ro - sph.xyz;
    
	float b = dot(oc,rd);
	float c = dot(oc,oc) - sph.w*sph.w;
    float h = b*b - c;
    if( h<0.0 ) return vec2(-1.0);
    h = sqrt( h );
    return -b + vec2(-h,h);
}

// Function 1355
float Sphere( vec3 p, vec3 c, float r )
{
	return length(p-c)-r;
}

// Function 1356
float distSphere( vec3 p, float s )
{
    // Standard UV wrapping for a sphere
    float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / s / .5;
    float v = (.5 - asin(p.y) / 3.14159) / s / .5;
    float disp = texture( iChannel0,
                           vec2(u + iTime * .1,v)).r;
    
    vec3 normal = p;
    // The exponential smooths out the displacement so we don't have crazy looking poles
	return length(p)-s - (disp * 0.1 * exp(1. - abs(normal.y))/exp(1.));
}

// Function 1357
void getSphereIntersec(inout Primitive sph, vec3 rayOr, vec3 rayDir, float smoothVal) {
    vec3 rx = rayOr-sph.pos;
    float vrx = dot(rayDir, rx);
    float drx = distance(rayOr,sph.pos);
    float v = vrx*vrx 
         - (drx*drx - (sph.size+smoothVal)*(sph.size+smoothVal)); //sphere line intersection equation    
    float ld = -vrx; //sphere line intersection equation
	float sqrtv = sqrt(abs(v)); 
    float dist1 = ld + sqrtv; //dist to intersection point1
    float dist2 = ld - sqrtv; //dist to intersection point2
    sph.intersecPoint =rayOr+ min(dist1, dist2) * rayDir; //calculating the closest intersection point   	
    sph.isIntersected = v<0.?false:true;	//set whether the sphere was interseced 
    sph.normal =normalize(sph.intersecPoint - sph.pos); //set the surface normal at the intersection point
      
}

// Function 1358
float sphere(vec2 P, vec2 D, vec2 C, float r) {
   vec2 d = P-C;
    float b = dot(d,D), c = dot(d,d) - r*r, k = b*b-c, l;
    if (k>0.) {
        l = -b - sqrt(k); if (l > Eps) return l; // hit distance
        l = -b + sqrt(k); if (l > Eps) return l; // hit distance
    }
    return Inf;                         // no hit
}

// Function 1359
float CylinderXY( vec3 p, vec3 c ) {
	return length(p.xy-c.xy)-c.z;
}

// Function 1360
float Kalibox(vec3 pos) 
{
	float Scale = 1.84;						
	int Iterations = 14;			
	int ColorIterations = 3;		
	float MinRad2 = 0.34;	
	vec3 Trans = vec3(0.076,-1.86,0.036);			
	vec3 Julia = vec3(-0.66,-1.2+(kalitime/80.),-0.66);	
	vec4 scale = vec4(Scale, Scale, Scale, abs(Scale)) / MinRad2;
	float absScalem1 = abs(Scale - 1.0);
	float AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations));
    vec4 p = vec4(pos,1), p0 = vec4(Julia,1); 
	for (int i=0; i<14; i++)
		{
			p.xyz=abs(p.xyz)+Trans;
			float r2 = dot(p.xyz, p.xyz);
			p *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0); 
			p = p*scale + p0;
			if (i<ColorIterations) orbitTrap = min(orbitTrap, abs(vec4(p.xyz,r2)));
		}
	return (    (length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters    );
}

// Function 1361
float fCylinder(vec3 p,float r,float h){return max(length(p.xz)-r,abs(p.y)-h);}

// Function 1362
float box(vec3 p, vec3 c)
{
  vec3 q = abs(p)-c;
  return (min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)))*0.5;
}

// Function 1363
float sphere(vec3 p, vec3 position)
{	
	return length(p+position)-radius;
}

// Function 1364
float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1365
float sPlane( in vec3 ro, in vec3 rd, in vec4 pla )
{
    float t = (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );
	
	if( t<0.0 ) return 1.0;
	return 0.0;
}

// Function 1366
float sdConeSection( vec3 p, float h, float r1, float r2 ){
  float d1=-p.z-h;
  float q=p.z-h;
  float si=0.5*(r1-r2)/h;
  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );
  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}

// Function 1367
vec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return vec2(-1.0);
    h = sqrt(h);
	return vec2(-b-h,-b+h);
}

// Function 1368
float sphereSDF(vec3 samplePoint, float r) {
    return length(samplePoint) - r;
}

// Function 1369
void boxfold(inout vec3 p, float bi)
{
    if (length(p.xy)!=0.)
    {
        vec2 v2 = p.xy/(p.z+1.);
        if (abs(v2.x)>tan(bi/2.)) v2.x += (sign(v2.x)*tan(bi/2.)-v2.x)*2.;
        if (abs(v2.y)>tan(bi/2.)) v2.y += (sign(v2.y)*tan(bi/2.)-v2.y)*2.;
        float l = length(v2);
        p.xy = v2*sin(2.*atan(l))/l;
        p.z = cos(2.*atan(l));
    }
}

// Function 1370
float pPlane(vec3 p, vec3 n, float d) {return dot(p,n) + d;}

// Function 1371
float sdWaveSphere(vec3 p, float radius, int waves, float waveSize) 
{
  //bounding Sphere
  float d = length(p) - radius*2.2;
  if(d > 0.0) return 0.2;

  // deformation of radius
//d = waveSize * (radius - abs(p.y));
  d = waveSize * (radius*radius-(p.y*p.y));
  radius += d * cos(atan(p.x,p.z) * float(waves));
  return 0.5*(length(p) - radius);
}

// Function 1372
float
sdSphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 1373
float sdSphere(vec3 p){
    return length(p) - 0.5;
}

// Function 1374
MapInfo plane(vec3 origin, Material material) {
    return MapInfo(material, -origin.y);
}

// Function 1375
void intersectPlane( in vec3 pn, in vec3 ps, in vec3 ro, in vec3 rd, inout vec3 n, inout float d )
{
    // If we aren't on the plane, return without changing the current normal or nearest dist.
    if(dot(ps-ro, rd) == 0.0) return;
    
    float dist = dot(pn, (ps-ro)) / dot(pn, rd);
    if( dist > 0.0 && dist < d )
    {
        d = dist;
        n = pn;
    }
}

// Function 1376
vec3 shadeplanet(vec3 pos, vec3 k) { 

	vec3 n=normalize(planetpos+pos+.2); // tweaked sphere normal
	float c=max(0.,dot(LIGHTDIR,normalize(k-n))); // surface value
	vec3 col=PLANET_COLOR+vec3(c,c*c,c*c*c)*.7; // surface coloring
	// add some noise
	float noi=max(0.,texture(iChannel1,n.yz*.5).x-.6);
	noi+=max(0.,texture(iChannel1,n.yz).x-.6);
	noi+=max(0.,texture(iChannel1,n.yz*2.).x-.6);
	col+=noi*(1.5-c)*.7;
	return col*max(0.,dot(LIGHTDIR,-n)); // diff light
}

// Function 1377
vec3 getHemisphereDirection(vec3 n) {
	if (CosWeighted) {
		// Biased sampling (cosine weighted):
		// PDF = CosAngle / PI, BRDF = Albedo / PI
		return getCosWeightedSample(n);
	} else {
		// Unbiased sampling:
		// PDF = 1 / (2 * PI), BRDF = Albedo / PI
		return getHemisphereUniformSample(n);
	}
}

// Function 1378
float intersectPlane(in vec3 ro, in vec3 rd)
{
    //equation of a plane, y=0 = ro.y+t*rd.y
    // t = -ro.y/rd.y
    return -ro.y/rd.y;
}

// Function 1379
float dInvertedBox( vec3 p, vec3 s )
{
	return -dBox(p,s);
}

// Function 1380
float DispBox(vec3 samplePos, vec3 boxDim, float r)
{	
	vec3 normal;
	float bump = 0.0;
    
	if(length(samplePos) < length(boxDim))
	{
 		bump = Tex3D(samplePos * TexScaleFactor * TexScaleFactor, normal, iChannel0).r * BumpFactor;
	}
    
	vec3 d = abs(samplePos) - boxDim;
	return (min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0)) + bump - r);
}

// Function 1381
float spheredf( vec3 p, float r )
{
    return length(p) - r;    
}

// Function 1382
float iPlane( in vec3 ro, in vec3 rd ) {
    return (-1.0 - ro.y)/rd.y;
}

// Function 1383
vec4 HitBox(vec3 minp, vec3 maxp, vec3 start, vec3 dir) {
 	vec3 tminp = start - minp;
    vec3 tmaxp = start - maxp;
    vec3 invdir = -vec3(1.) / dir;
    tminp *= invdir;
    tmaxp *= invdir;
    vec3 tmin = min(tminp, tmaxp);
    vec3 tmax = max(tminp, tmaxp);
    float maxt = min(min(tmax.x, tmax.y), tmax.z);
    float mint = max(max(tmin.x, tmin.y), tmin.z);
    return vec4(start + dir * mint, maxt < mint ? -1. : (maxt - mint));
}

// Function 1384
vec3 nSphere(in vec3 pos, in vec4 sph) {
	return normalize((pos - sph.xyz)/sph.w);
}

// Function 1385
float sdf_half0_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, -pos.y);
}

// Function 1386
float sphere(in vec3 p, in float r) {
    return length(p) - r;
}

// Function 1387
float boxMap( sampler2D sam, in vec3 p, in vec3 n)
{
    p = p*vec3(.1, .03, .1);
    n = abs(n);
	float x = texture( sam, p.yz ).y;
	float y = texture( sam, p.zx ).y;
	float z = texture( sam, p.xy ).y;
	return (x*n.x + y*n.y + z*n.z)/(n.x+n.y+n.z);
}

// Function 1388
float sdf_seriffed_box(vec2 uv, vec2 origin, vec2 size, vec2 top_serif, vec2 bottom_serif)
{
    float h = clamp((uv.y - origin.y) / size.y, 0., 1.);
    float xmul = h < bottom_serif.y ? mix(1.+bottom_serif.x, 1., sqrt(1.-sqr(1.-(h/bottom_serif.y)))) :
    		h > (1.-top_serif.y) ? 1.+top_serif.x*sqr(1.-(1.-h)/(top_serif.y)) :
            1.;
    return sdf_centered_box(uv, vec2(origin.x, origin.y+size.y*.5), vec2(size.x*xmul*.5, size.y*.5));
}

// Function 1389
float box(vec3 pos)
{
    vec3 d = abs(pos) - 1.0;
  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1390
vec2 sphereToCube(in vec3 pointOnSphere) {
   return vec2(
        pointOnSphere.x/pointOnSphere.z,
        pointOnSphere.y/pointOnSphere.z
    );
}

// Function 1391
float box(vec2 p, vec2 o, vec2 b) {
    return length(max(abs(p-o)-b,0.0));
}

// Function 1392
float sdRoundCone( vec3 p, float r1, float r2, float h ){
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 1393
float CappedCylinderSDF( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1394
vec3 sampleHemisphere( const vec3 n, in float Xi1, in float Xi2 ) {
    vec2 r = vec2(Xi1,Xi2)*TWO_PI;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dot(dr,n) * dr;
}

// Function 1395
float sdfBox(vec3 p, vec3 b)
{
  return length(max(abs(p) - b, 0.0));
}

// Function 1396
MapValue xzPlane( vec3 p ,float y, Material m)
{
  MapValue mv;
  mv.material = m;
  mv.signedDistance = p.y - y;
  return mv;
}

// Function 1397
float sBox(in vec2 p, in vec2 b, in float sf){

  p = abs(p) - b + sf;
  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;
}

// Function 1398
float IntersectSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 Z = ro-center;
    float A = 1.0;
    float B = 2.0 * dot(rd, Z);
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-radius*radius;
    float D = B*B - 4.0*C;
    float t = -1.0;
    float d = -1.0;
    if(D>=0.0) {
        if(C>0.0) {
            d = (-B-sqrt(D))/2.0;
        }else{
            d = (-B+sqrt(D))/2.0;
        }
    }
    return d;
}

// Function 1399
float udBox(vec3 p, vec3 b, vec3 ray_dir)
{
	return length(max(abs(p)-b,0.0));
}

// Function 1400
void UI_ProcessCheckbox( inout UIContext uiContext, int iControlId, inout UIData_Bool data, Rect checkBoxRect )
{    
    bool bMouseOver = Inside( uiContext.vMouseCanvasPos, checkBoxRect ) && uiContext.bMouseInView;
    
    if ( uiContext.iActiveControl == IDC_NONE )
    {
        if ( uiContext.bMouseDown && (!uiContext.bMouseWasDown) && bMouseOver && !uiContext.bHandledClick )
        {
            uiContext.iActiveControl = iControlId;
            uiContext.bHandledClick = true;
        }
    }
    else
    if ( uiContext.iActiveControl == iControlId )
    {
        if ( !uiContext.bMouseDown )
        {
            uiContext.iActiveControl = IDC_NONE;
            if ( bMouseOver )
            {
                data.bValue = !data.bValue;
            }
        }
    }
    
    bool bActive = (uiContext.iActiveControl == iControlId);
    
    UI_DrawCheckbox( uiContext, bActive, bMouseOver, data.bValue, checkBoxRect );    
}

// Function 1401
float pdfCosHemisphere(float cosTheta)
{
    // p(omega) = C*cos(theta)
    // I[0,2pi][0,pi/2]{C*cos(theta)sin(theta)d(theta)d(phi)} = 1
    // C = 1/pi
    return cosTheta/PI;
}

// Function 1402
float udRoundBox( vec3 p, vec3 b, float r ){
  return length(max(abs(p)-b,0.0))-r;
}

// Function 1403
float sphereSDF(vec3 samplePoint, Sphere sphere) {
    return length(samplePoint-sphere.center) - sphere.radius;
}

// Function 1404
float distFlatSphere( vec3 p, float s )
{
	return length(p)-s;
}

// Function 1405
float raySphereIntersect(Ray ray, float radius)
{
    // note to future me: don't need "a" bcuz rd is normalized and dot(rd, rd) = 1
 	float b = 2. * dot(ray.origin, ray.direction);
    float c = dot(ray.origin, ray.origin) - radius * radius;
    float d = sqrt(b * b - 4. * c);
    return (-b + d) * .5;
}

// Function 1406
float de_sphere(vec4 p, float r) {
	return (length(p.xyz) - r) / p.w;
}

// Function 1407
float w_intersect_sphere( float max_t, vec3 ray_dir, vec3 origin, 
    vec3 sphere, float sphere_radius2, int idx_in, 
    out vec3 pos, out vec3 norm, out int idx ) {
   // intersect with sphere 
    vec3 origToSphere = sphere - origin;
    float tCA = dot( origToSphere, ray_dir);
    if( tCA < 0.0 ) {
        // ray center is towards back of ray. cant intsesect
        return max_t;
    } else 
    {
        float dd = length(origToSphere);
        float distToMidpoint2 = dd*dd-tCA*tCA;
        if( distToMidpoint2 > sphere_radius2 ) {
            return max_t;
        } 
        else {
            float thc = sqrt(sphere_radius2-distToMidpoint2);
            float t0 = tCA - thc;           // entry 
            if( t0 < max_t ) {
                pos = origin + t0*ray_dir;
                norm = normalize( pos-sphere);
                idx = idx_in;
                return t0;
            } else {
                return max_t;
            }
        }
    }
}

// Function 1408
vec4 boxmap(sampler2D sam,vec3 p,vec3 n)
{
    vec3 m = pow(abs(n), vec3(32.) );
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1409
float sdTorus( vec3 p, vec2 t )
{
   return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 1410
float TorusSDF(vec3 p, float R, float r)
{
    
    float xy = length(p.xy) - R;
    float z = length(vec2(xy, p.z)) - r;
    return z;
}

// Function 1411
vec4 skybox(vec2 fakeCoords, vec3 EulerAngles)
{
    vec3 Coords =  vec3(fakeCoords.x,fakeCoords.y,sqrt(sqrt(0.5*0.5*2.)-length(fakeCoords)));
    vec3 realCoords=  rotate(Coords,EulerAngles);
    
    vec3 hue=vec3(15./255.,125./215.,1.)*1.;
    float value=0.+1.2*abs(abs(realCoords.y)-1.);
    return vec4(hue*value,1);
}

// Function 1412
float distPlaneBump(vec3 samplePos, vec3 planeNormal, float planeHeight, sampler2D image, float scale)
{
	float bump = 0.0;
	float dist = dot(samplePos, normalize(planeNormal)) + planeHeight;
	if(dist < GROUND_BUMP_FACTOR*2.0)
		bump = texture(image, samplePos.xz*scale).r*GROUND_BUMP_FACTOR;
	return (dist-GROUND_BUMP_FACTOR)+bump;
}

// Function 1413
vec3 boxNormal( vec3 direction, vec3 point, float radius )
{
    vec3 n = point / direction;
    vec3 s = sign(direction);
    vec3 k = s * radius / direction;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    
    return normal;
}

// Function 1414
float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, -0.1)) + min(max(q.x, max(q.y, q.z)), -0.1);
}

// Function 1415
float IntersectXUnitCylinder ( vec3 ro, vec3 rd, float rad ) {
    vec3 oc = ro + vec3(0.5,0.0,0.0);
    float a = 1.0 - rd.x*rd.x;
    float b = dot(oc,rd) - oc.x*rd.x;
    float c = oc.y*oc.y + oc.z*oc.z - rad*rad;
    float h = b*b - a*c;
    if( h<0.0 ) return -1.0;              // miss
    h = sqrt(h);
    float t = (-b-h)/a;
    float y = oc.x + t*rd.x;
    if( y>0.0 && y<1.0 ) return t;        // body hit?
    t = (float(y>=0.0) - oc.x)/rd.x;
    return ( abs(b+a*t)<h ) ? t : -1.0;   // cap hit?
}

// Function 1416
vec4 Cone60(vec3 p, vec3 d) {
    vec4 Light=vec4(0.);
    vec3 sp; float t=1.; float sD=1.; float Lod=0.;
    for (int i=0; i<7; i++) {
        sp=p+d*t;
        Light+=VoxelFetch60(sp,Lod)*(1.-Light.w);
        t+=sD; sD*=2.; Lod+=1.;
    }
    return Light+vec4(vec3(0.1,0.3,0.5)*((d.y*0.5+0.5)*(1.-Light.w))*0.25,0.);
}

// Function 1417
float sdBox( vec3 p, vec3 b ) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1418
float sdBox2(in vec2 p,in vec2 b) {vec2 d=abs(p)-b;return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);}

// Function 1419
float sdCylinder(float dt, vec3 p, vec2 h)
{
    return sdCylinder(p, min(dt/h,.25));
}

// Function 1420
vec2 sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return vec2(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),1.));
}

// Function 1421
float sphere(vec3 p) {
    return length(mod(p, vec3(2.)) - vec3(1., 1., 1.)) - 0.2;
}

// Function 1422
float cylinder(vec3 p, float r, float h){
	vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 1423
float box(vec2 p, vec2 b)
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1424
RayTraceResult RayTraceSphere(in Ray ray, in vec3 c, in float r)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
    vec3 L = c - ray.org;
    float d = dot(L, ray.dir);
    float l2 = dot(L, L);
    float d2 = d*d;
    float r2 = r*r;
    
    if (d < .0 && l2 > r2)
    {
        //no intersect
        return res;
    }
    
    float m2 = l2 - d2;
    if (m2 > r2)
    {
        // no intersect
     	return res;   
    }
    
    float q = sqrt(r2 - m2);
    float t = l2 > r2 ? d - q : d + q;
    
    res.pos = t*ray.dir + ray.org;
    res.t = t;
    res.nn = normalize(res.pos - c);
    
    res.nn = l2 > r2 ? -res.nn : +res.nn;
    
    return res;
}

// Function 1425
float plane(vec3 p){
    //p = rotY(iTime / 4.) * p;
    float crazy = abs(p.x/2. - floor(p.x/2. + .5)) * 2.;
    float crazy2 = abs(p.z/2. - floor(p.z/2. + .5)) * 2.;
    float var1 = sin(p.x + iTime) * cos(p.z + iTime) / 2. + p.y + 5.;
	float var2 = -crazy * crazy2 / 2. * (sin(iTime) * .5 + .5) + p.y + 5.;
	//return mix(var1, var2, cos(iTime / 8.) / .5 + .5);
    return var1;
}

// Function 1426
vec4 getSphereColor(vec3 pos, vec3 dir, float index)
{
	vec4 color = vec4(0.0);
	
	float yy = -0.4 + sin(index * 0.5);
	
	vec3 startCenter = vec3(-2.0, yy, 4.0);
	vec3 endCenter = vec3(4.0, yy, 32.0);
	sphereCenter = startCenter + (endCenter - startCenter) * (index / float(numBalls));
	
	hasHitSphere = false;

	pos -= sphereCenter;

	float b = 2.0 * dot(pos,dir);
	float c = dot(pos,pos) - radius;

	float discr = b*b - 4.0*c;
	if (discr >= 0.0)
	{
		vec2 t = vec2(-b+discr, -b-discr) / 2.0;
		vec3 p = pos + min(t.x,t.y) * dir;
		floorHitPoint = p;
		hasHitSphere = (p.y > -0.7-yy);
		if (hasHitSphere)
		{
			color = getColor(normalize(p));
			hasHitSphere = true;
		}
		else
		{
			floorHitPoint = p;
		}
	}
	return color;
}

// Function 1427
float imTestCone(vec3 p) {
    p.z = (p.z - 1.0)*0.5;
    float r = 0.5;
    return (p.x*p.x + p.y*p.y)/(r * r) - p.z*p.z;
}

// Function 1428
float ProjectPlane( float x, vec2 n, float d )
{
    float yi = d / n.y;
    
    float y = x * -n.x / n.y - yi;
    
    return y;
}

// Function 1429
float plane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}

// Function 1430
void RCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)    
{
	float3 locX;
	float3 locY;
	float3 locZ=-(p1-p0)/(1.0-r1/r0);

    rp0-=p0-locZ;

	if(abs(locZ.x)<abs(locZ.y))
		locX=float3(1,0,0);
	else
		locX=float3(0,1,0);
		
	float len=length(locZ);
	locZ=normalize(locZ)/len;
	locY=normalize(cross(locX,locZ))/r0;
	locX=normalize(cross(locY,locZ))/r0;

	float3x3 tm;
	tm[0]=locX;
	tm[1]=locY;
	tm[2]=locZ;

    rd=rd*tm;	
    rp0=rp0*tm;
    	
	float dx=rd.x;
	float dy=rd.y;
	float dz=rd.z;

	float x0=rp0.x;
	float y0=rp0.y;
	float z0=rp0.z;

	float x02=x0*x0;
	float y02=y0*y0;
	float z02=z0*z0;

	float dx2=dx*dx;
	float dy2=dy*dy;
	float dz2=dz*dz;

	float det=(
		-2.0*x0*dx*z0*dz
        +2.0*x0*dx*y0*dy
        -2.0*z0*dz*y0*dy
        +dz2*x02
        +dz2*y02
        +dx2*z02
        +dy2*z02
        -dy2*x02
        -dx2*y02
        );
    

    if(det<0.0)
    {
		t=MAX_RAY_LENGTH;
        return;
    }

	float t0=(-x0*dx+z0*dz-y0*dy-sqrt(abs(det)))/(dx2-dz2+dy2);
	float t1=(-x0*dx+z0*dz-y0*dy+sqrt(abs(det)))/(dx2-dz2+dy2);

	t=t0;
	if(t<0.0)
    {
		t=MAX_RAY_LENGTH;
        return;
    }

	float3 pt=rp0+t*rd;

	if(pt.z>1.0)
    {
		t=MAX_RAY_LENGTH;
        return;
    }
        
    if(pt.z<r1/r0)
    {
		t=MAX_RAY_LENGTH;
        return;
    }

	n=float3(pt);
    uv.z=0.0;
    uv.y=n.z;
	n.z=0.0;
	n=normalize(n);
    uv.x=atan(n.x,n.y)/2.0/PI;
	n.z=-pt.z/abs(pt.z);
	n=normalize(n);
    n=tm*n;
    n=normalize(n);
}

// Function 1431
float mandelbox(vec3 position){
  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
  for (int i=0; i<ITERS; i++) {
    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3
    float r2 = dot(p.xyz, p.xyz);  // dp3
    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
    p.xyzw = p*scalevec + p0;  // mad4
  }
  return (length(p.xyz) - C1) / p.w - C2;
}

// Function 1432
vec4 gui_check_box(vec4 col, vec2 uv, vec2 pos, float scale, bool check)
{
    
    float unit = asp * 0.01 * scale;
    float h = box(uv, pos, vec2(1.8*unit));
    col = mix(col, vec4(vec3(0.9, 0.9, 1.), 1.), smoothstep(0.01, 0., h));
    col = mix(col, vec4(vec3(0., 0., 0.5), 1.), smoothstep(0.01, 0., abs(h)));
    
    
    if(check)
    {
        const vec2 dir1 = normalize(vec2(-1., 1.2));
        const vec2 dir2 = normalize(vec2(1., 1.));
    	h = line(uv, pos+vec2(0., unit*-0.5), pos+dir1*unit*2.1);
        col = mix(col, vec4(1., 0., 0., 1.), smoothstep(0.01, 0., abs(h)));
        h = line(uv, pos+vec2(0., unit*-0.5), pos+dir2*unit*4.2);
        col = mix(col, vec4(1., 0., 0., 1.), smoothstep(0.01, 0., abs(h)));
    }
    
    return col;
}

// Function 1433
void TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)
{
    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);
    if (dist < info.dist)
    {
        info.rayMarchedObject = true;
        info.dist = dist;
        
        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);
        int maxIndex = MaxCompIndex(relPos);
        if (maxIndex == 0)
        {
            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);
        }
        else if(maxIndex == 1)
        {
            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);
        }
        else
        {
            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);
        }
        
        info.material = material;
    }    
}

// Function 1434
SSphere GetfloorSphere1()
{
	return SSphere
	(
		7,						//id
		vec3(1.5, -1.0, 0.0),	//center
		0.2,					//radius
		SMaterial
		(
			vec3(0.8,0.8,0.0),	//diffuse color
			3.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 1435
float sphere( vec3 p, float s )
{
  return length(p)-s;
}

// Function 1436
float planetNoise( in vec3 x )
{
   vec3 p = floor(x);
   vec3 f = fract(x);
f = f*f*(3.0-2.0*f);

vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;
return mix( rg.x, rg.y, f.z );
}

// Function 1437
SSphere GetLightPoint1Sphere()
{
	return SSphere
	(
		1,						//id
		lightPoint1.m_pos,		//center
		0.06,					//radius
		SMaterial
		(
			lightPoint1.m_color,//diffuse color
			1.0,				//specular amount
			vec3(0.0,0.0,0.0)	//specular color
		)
	);	
}

// Function 1438
vec3 plane2sphere(in vec2 p) {
    float t = -4./(dot(p,p) + 4.);
    return vec3(-p*t, 1. + 2.*t);
}

// Function 1439
float sdBox(vec2 p,vec2 s)
{
    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);
}

// Function 1440
float sdBox( vec3 p, vec3 boxDimensions )
{
	vec3 d = abs(p) - boxDimensions;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1441
float sphere( vec3 p, float radius )
{
  return length(p)-radius;
}

// Function 1442
shapeResult plane(float origin, int materialId, float at) {
    return shapeResult(at - origin, materialId);
}

// Function 1443
float plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){
    float normdotp = dot(raydir, norm);
    if(normdotp >= 0.0){return -1.0;}
    return dot(point-rayori, norm)/normdotp;
}

// Function 1444
void getSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center ) {
	vec2 offset = grid + sphereOffset;
	center = vec4( offset.x + 0.5*GRIDSIZE, 1., offset.y + 0.5*GRIDSIZE, 1. );
}

// Function 1445
float sdSphereOrigin( vec3 p, float s){
	return length(p)-s;
}

// Function 1446
float sdf_sphere(vec3 pXp0, float radius)
{
 	return length((pXp0)) - radius;   
}

// Function 1447
void animateSphere(Sphere s)
{
    glowSphere.center = vec3(sin(iTime/2.)/3., sin(iTime/3.)*.1+.1,sin(iTime)*.15 -.5);
}

// Function 1448
float sphereSDF(vec3 p) {
    return length(p) - 1.0;
}

// Function 1449
vec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
    vec3 m = pow( abs(n), vec3(k) );
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1450
float roundBox(vec2 coord, vec2 pos, vec2 b ){
  return length(max(abs(coord-pos)-b,0.0));
}

// Function 1451
float pRoundBox(vec3 p, vec3 b, float r)
{
 	return length(max(abs(p)-b,0.0))-r;
}

// Function 1452
float iPlane( const in vec3 ro, const in vec3 rd, in vec2 distBound, inout vec3 normal,
              const in vec3 planeNormal, const in float planeDist) {
    float a = dot(rd, planeNormal);
    float d = -(dot(ro, planeNormal)+planeDist)/a;
    if (a > 0. || d < distBound.x || d > distBound.y) {
        return MAX_DIST;
    } else {
        normal = planeNormal;
    	return d;
    }
}

// Function 1453
float cylinderSDF( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

// Function 1454
vec2 planeProjection(in vec2 uv)
{
	vec3 eye = vec3(0.0, -0.25, 0.0);
    float viewPortZ = 0.5;
    float viewPortH = 2.0;
    float viewPortW = viewPortH * iResolution.x / iResolution.y;
    vec2 center = vec2(viewPortW/2.0, viewPortH/2.0);
    
    vec2 dir = (vec2(uv.x*viewPortW, uv.y*viewPortH) - center) / viewPortZ; // (dx,dy) per unit of z 
    
    
    // Intersecting (x,z) plane in y=0.0
    float zIntersect = eye.y / dir.y;
    float xIntersect = zIntersect * dir.x;
            
    vec2 planeUv = vec2(xIntersect, zIntersect);

    if(planeUv.y > 1.0)
    {
    	planeUv.y = -1.0;
    }
    
    return planeUv;
}

// Function 1455
float sdRbox( vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .05;
}

// Function 1456
float sdBox(vec2 p, vec2 dim)
{
    p = abs(p);
    dim /= 2.;
    
    float inDist  = min(-min(dim.x - p.x, dim.y - p.y), .0);
    float outDist = length(max(vec2(.0), p - dim));
    
    return inDist + outDist;
}

// Function 1457
float cylinder(vec3 l, vec2 scale, float bottom, float top) {
	vec2 scf = l.xz/scale;
	if (length(scf) >= 1.0) scf = normalize(scf);
	float coDist = distance(l.xz, scf*scale);
	float cg = max(l.y-bottom, top-l.y);
	return max(cg, coDist);
}

// Function 1458
float sdBoxFrame( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 1459
float sdTorus( vec3 p, vec2 t )
{
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 1460
float sdCappedCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);
    return min(max(d.x, d.y), -0.1) + length(max(d, -0.1));
}

// Function 1461
float box( vec3 p, vec3 b )
{
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.) +
	length(max(d,0.));
}

// Function 1462
float sdfPlane(in vec3 p, in vec4 normal)
{
  	// n must be normalized
	return dot(p, normal.xyz) + normal.w;
}

// Function 1463
vec2 sphere_trace( Ray ray, float radius, vec3 C )
{
	vec3 O = ray.o;
	vec3 d = ray.d;
	float tp = dot( C - O, d ); // P = project C on line (O,d)
	vec3 P = O + d * tp;
	float h_sqr = lensqr( P - C );
	float radius_sqr = radius * radius;
	if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere
//	bool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?
	float dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)
//	if ( start_inside )	return vec2(FLT_MAX,tp+dt);	// order In->O->If // record only far hit If
//	if ( tp < 0.0 )	return vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit
	return vec2( tp - dt, tp + dt ); // record 2 hits In, If
}

// Function 1464
vec3 randomHemisphereDirection(vec3 n,  float seed) {
    vec2 r = 2.*PI*hash22(seed);
    vec3 dr = vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
    float k = dot(dr,n);
    return k == 0. ? n : normalize(k*dr);
}

// Function 1465
float sdBox(vec3 p, vec3 s) {p = abs(p) - s;return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);}

// Function 1466
bool intersectSphere(in vec4 ro, in vec4 rd, in float r, out float dmin, out float dmax) {
	float b = dot(rd,ro),
		  d = b*b - dot(ro,ro) + r*r;
	if (d < 0.) return false;
    float edge = sqrt(d);
	dmin = -edge -b;
	dmax =  edge -b;
	return dmin > 0.;
}

// Function 1467
void createSphere(mat4 transform, float r, int mtl, out Object obj) {
    obj.type_ = OBJ_SPHERE;
    obj.mtl_id_ = mtl;
    obj.transform_ = transform;
    obj.transform_inv_ = mat4Inverse( obj.transform_ );
    obj.params_[0] = r;			//radius
    obj.params_[1] = r*r;		//radius^2
    obj.params_[2] = 0.0;		//not used
    obj.params_[3] = 0.0;		//not used
    obj.params_[4] = 0.0;		//not used 
    obj.params_[5] = 0.0;		//not used
}

// Function 1468
float planeSDF(vec3 p, vec3 n) {
    return -dot(p, n);
}

// Function 1469
void UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))
        return;
    
    uiContext.vWindowOutColor = vec4(1.0);
    
    if ( bActive && bMouseOver )
    {
        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);
    }

    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );

    Rect smallerRect = checkBoxRect;
    RectShrink( smallerRect, vec2(6.0));

    if ( bChecked )
    {
        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );
    }
}

// Function 1470
float sdCylinder( vec3 p, vec3 c ) {
        return length(p.xz - c.xy) - c.z;
    }

// Function 1471
bool intersectPlane( vec3 normal,vec3 ro,vec3 rd, out rtIntersection hit ) 
{
	float len = -dot(ro, normal) / dot(rd, normal);
    if (len < 0.0) return false;
    hit = rtIntersection(len, ro + len * rd, normal, -1);
    return true;
}

// Function 1472
float dBox(in vec3 ro) 
{
    vec3 m = 1.2/rd;
    vec3 t = -m*ro + abs(m)*ch2;
	return min(min(t.x, t.y), t.z);
}

// Function 1473
float torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)
{
    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));
}

// Function 1474
float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)
{
    p.x = abs(p.x);
    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

// Function 1475
vec4 RenderPlanet(vec3 pos, float d, vec3 rayDir, float worldAngle, float coverage)
{
	vec3 n = calcNormal(pos);
        
    float nDotV = abs(dot(n, rayDir));
 
    float fog = sat((MAX_DST - d) * 0.1);
    
 
    // compute some rim lighting to kind of blend everything together
    vec3 burn  = sat(mix(vec3(2.0, 2.0, 1.5), vec3(1.0, 0.4, 0.2), sat((MAX_DST - d) * 0.05) + nDotV) * 0.5);
    
    // Compute the flowery 'texture' on the planet
    vec3 flowers = sphereColor(pos, nDotV, d, worldAngle);
    
    
    // bogus lighting from the sun
    vec3 lightPos = pos + vec3(-15.0, -20.0, 60.0);
    float nDotL = sat(dot(n, normalize(lightPos - pos)) * 0.5 + 0.5);
    flowers *= nDotL * 0.8 + 0.5;
    
    // fades the planets at the horizon
    vec4 col;
    col.rgb = flowers + burn;
    
    
    col.a = fog * coverage;
    
    // Uncomment to debug coverage AA
    //col.rgb = mix(vec3(0,1,0), col.rgb, coverage);
    //col.a = fog;
    
    return col;
}

// Function 1476
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal)
{
    const float R = 1.0f;
    const float H = 0.1f;
    float floorT = (-1.0 - pos.y) / dir.y;
    if (floorT < 0.0)
        return INF;
    vec3 finalPos = pos + dir * floorT;
    if (dot(finalPos.xz, finalPos.xz) < R * R) {
        normal = vec3(0, 1, 0);
        return floorT;
    }
    
    float b = dot(pos.xz, dir.xz);
    float a = dot(dir.xz, dir.xz);
    float D = b * b - (dot(pos.xz, pos.xz) - R * R) * a;
    if (D < 0.0) {
        return INF;
    }
    float t = (-b - sqrt(D)) / a;
    if (pos.y + t * dir.y < -1.0) {
        vec3 wPos = pos + t * dir;
        normal = normalize(vec3(wPos.x, 0, wPos.z));
        return t;
    }
    
    return INF;
}

// Function 1477
float sdPlane( vec3 p ) {
	return p.y;
}

// Function 1478
vec3 randomSphereDir(vec2 rnd)
{
	float s = rnd.x*PI*2.;
	float t = rnd.y*2.-1.;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 1479
float
capped_cylindermh_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;
    return min( maxv(d), 0.0 ) + manhattan( max(d, 0.0) );
}

// Function 1480
vec3 Sample_Hemisphere(float s0, float s1, vec3 normal)
{
    vec3 smpl = Sample_Sphere(s0, s1);

    if(dot(smpl, normal) < 0.0)
        return -smpl;
    else
        return smpl;
}

// Function 1481
void drawCheckbox( inout vec4 c, vec2 p, vec2 t, float selected){
    p-=t;
    c = mix(c, vec4(0.,1.,0.,1.), selected*smoothstep(0.,.01, .03 - sdBox(p,vec2(.012))));
    c = mix(c, vec4(0.,0.,0.,1.), smoothstep(0.,.01, .01-abs(.03 - sdBox(p,vec2(.010)))));
    c = mix(c, vec4(1. ), selected*(1.-smoothstep(-0.011,0.0, -.015+mapX(p,  0.03)))) ; // icon
}

// Function 1482
float udRoundBox(vec3 p, vec3 b, float r)
{
  return length(max(abs(p)-b,0.0)) - r;
}

// Function 1483
float sdRoundCone( in vec3 p, in float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xz), p.y );
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));
    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
    return dot(q, vec2(a,b) ) - r1;
}

// Function 1484
float sdSphere(vec3 o, float r, vec3 p)
{
    return length(p - o) - r;
}

// Function 1485
float traceSphere(vec3 position, vec3 direction, float r, out vec3 normal) {
    float b = dot(position, direction);
    float D = b * b - dot(position, position) + r * r;
    if (D < 0.0) {
        return INF;
    }
    
    float t = -b - sqrt(D);
    if (t < 0.0)
        t = -b + sqrt(D);
    if (t < 0.0) {
        return INF;
    }
    normal = normalize(position + t * direction);
    return t;
}

// Function 1486
float opNoisyBox( in vec3 p, vec3 b )
{
    float d1 = sdBox(p, b);
    float d2 = sin(0.4*p.x)*sin(sin(iTime+p.y*8.2)*1.9*p.y)*sin(cos(iTime+p.z*6.8)*0.3*p.z-0.1);
    return d1+d2;
}

// Function 1487
vec3 renderPlanet(in vec3 ro, in vec3 rd, vec2 map)
{
    float tMax = SCALE*25.0;
    
    float t = map.x;
	float m = map.y;
	vec3 pos = ro + t*rd;
    
    // Calculate sunlight after passing through atmosphere
    vec3 sun = sunDirection();
    vec3 cLow = pos * (ATMOSPHERE_LOWER/length(pos));
    vec2 c = lineIntersectSphere(cLow, sun, ATMOSPHERE_UPPER);
    vec3 ppc = pos + sun*c.y;
    vec3 sunColour = attenuate(pos, ppc, vec3(0.0));
    
    // Fake a bit of skylight, depending on angle to the sun.
    float sunAngle = dot(normalize(pos), sun);
    sunColour += vec3(0.0, 0.235, 0.275) * sunAngle;
    
	vec3 nor = calcNormal(pos);
    vec3 ref = reflect( rd, nor );

    float dif = clamp( dot( nor, sun ), 0.0, 1.0 );
    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );
    float spe;
    
    vec3 col, em;
    planetColour(pos, m, col, em);
    vec3 brdf = vec3(0.0);
    
	// Land
    float isLand = mix(0.0, 1.0, float(m < 10.));
    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),12.0);
    brdf += 0.1*col * isLand;
    brdf += 0.9*dif*col * isLand;
    brdf += 0.01*spe*vec3(1.0, 1.0, 1.0)*dif * isLand;
    
    // Ocean
    float isOcean = mix(0.0, 1.0, float(m == 10.));
    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),16.0);
    brdf += 0.4*col * isOcean;
    brdf += 0.2*spe*vec3(1.0) * isOcean;
    
	return brdf*sunColour + em;
}

// Function 1488
float sdSphere( in vec3 p, in vec3 c, in float r )
{
  return length(p-c)-r;
}

// Function 1489
float sphere(vec3 o, vec3 l, vec3 c, float r2)
{
    const float eps = 0.0001;
    
    float a_ = dot(l,l);
	vec3 p = o - c;
    float b_ = 2.0 * dot(l,p);
    float c_ = dot(p,p) - r2;
    
    float a = b_*b_-4.0*a_*c_;
    if (a < 0.0) return -1.0;
    a = sqrt(a);
    float t2 = -b_ + a;
    if (t2 < eps) return -1.0;
    float t1 = -b_ - a;
    float result = (t1 > eps && t1 < t2) ? t1 : t2;
    return result * 0.5 / a_;
}

// Function 1490
surface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {
    return surface_t(
        id,
        length(query_point)  - sphere_radius
    );
}

// Function 1491
float torusSDF_multi( vec3 p, float r, float thickness ){ // a torus inside a torus inside a torus inside a torus inside a torus inside a torus
  vec2 q = fract(vec2(length(p.xz)-r,p.y) *.5);
  return length(q)- thickness;
}

// Function 1492
vec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,
                      out float visibility)
{
    vec3 posToSphereWS = lightSphere.xyz - posWS;
    float distToSphereCenter = length(posToSphereWS);
    float sqDistToSphere = distToSphereCenter * distToSphereCenter;
    float sqSphereRadius = lightSphere.a * lightSphere.a;
    
    float distToDisk = (1.0/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);
    float diskRadius = (lightSphere.a/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));
    
    float cosSphereAngularRadius = clamp(distToDisk/sqrt(distToDisk*distToDisk + 
                                        diskRadius*diskRadius), -1.0, 1.0);
    vec3 posToSphereDirWS = posToSphereWS/distToSphereCenter;
    
    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, 
                                     cosSphereAngularRadius, roughness);
    
    //The point to light can be inside the sphere, blend to 1.0 at the center
    if(distToSphereCenter < lightSphere.a)
    {
        sphereLighting = mix(1.0, sphereLighting, distToSphereCenter/lightSphere.a);
    }
    
	visibility = sphereLighting;
    
    return colour * sphereLighting;
}

// Function 1493
float sdSphere (in vec3 p, float r)
{
	return length (p) - r;
}

// Function 1494
float asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ 
    // geometric solution
    float sr2 = sr*sr;
    vec3 e0 = sp - ro; 
    float e1 = dot(e0,rd);
    float r2 = dot(e0,e0) - e1*e1; 
    if (r2 > sr2) return 1000.0; 
    float e2 = sqrt(sr2 - r2); 
    return e1-e2; 
}

// Function 1495
vec2 raySphere(vec3 ro, vec3 rd, vec4 s) {
    vec3 ce = s.xyz;
    float ra = s.w;
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - ra*ra;
    float h = b*b - c;
    if( h<0.0 ) return vec2(miss); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

// Function 1496
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1497
bool isInOtherSphereShadow(vec3 p, Sphere thisSphere, Light light)
{
	for(int i=0; i<numberOfSpheres; i++)
	{
		if(isInShadow(p, spheres[i], light))
			return true;
	}
	return false;
}

// Function 1498
float box( vec3 p, vec3 b )
{
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) +
	length(max(d,0.0));
}

// Function 1499
float sbox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1500
intersection skysphere(vec3 raydir)
{
    intersection result;
    result.distance = MAXDIST;
    result.normal = -raydir; // sky-sphere

    return result;
}

// Function 1501
void boxParams(in int i, out mat4 txx, out mat4 txi, out vec3 boxSize)
{
	vec3 trapos = bd[i].pos;
	mat4 tra = translate( trapos.x, trapos.y, trapos.z );
	txi = tra; 
	txx = inverse( txi );
	boxSize = bd[i].siz;
}

// Function 1502
float
sphere8_sd( in float sph_r, in vec3 p )
{
    return length8( p ) - sph_r;
}

// Function 1503
float cylinder_dist(vec3 q) {
	vec3 qp;
	q.z += 0.3 * sin(q.y + q.x);
	q.x += 0.3 * cos(q.y + q.x);
	qp.x = negmod(q.x, 2.0);
	qp.y = negmod(q.y, 2.0);
	qp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;
 
  return length(qp.xz)- 0.1 + max(0.01 * (q.y + 5.0 * sin(q.z + q.x)), 0.0);
}

// Function 1504
float sphereZero(vec3 ray,vec3 pos,float r)
{
  	float b = dot(ray,pos);
  	float c = dot(pos,pos) - b*b;
    float s=1.0;
    if (c<r*r) s=0.0;
    return s;
}

// Function 1505
float box(vec3 position, vec3 halfSize) {
    position = abs(position) - halfSize;
    return max(max(position.x, position.y), position.z);
}

// Function 1506
vec2 box(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {
    vec2 tMin=(bmin-origin)*dir;
    vec2 tMax=(bmax-origin)*dir;
    vec2 t1=max(tMin,tMax);
    vec2 t2=min(tMin,tMax);
    return vec2(max(t2.x,t2.y),min(t1.x,t1.y));
}

// Function 1507
float sphere( vec3 p, float s ){
  return length(p)-s;
}

// Function 1508
float iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad
){// convert from ray to box space
 ;vec3 rdd = (txx*vec4(rd,0.0)).xyz
 ;vec3 roo = (txx*vec4(ro,1.0)).xyz
 ;// ray-box intersection in box space
 ;vec3 m = 1.0/rdd
 ;vec3 n = m*roo
 ;vec3 k = abs(m)*rad
 ;vec3 t1 = -n - k
 ;vec3 t2 = -n + k
 ;float tN = max( max( t1.x, t1.y ), t1.z )
 ;float tF = min( min( t2.x, t2.y ), t2.z )
 ;if( tN > tF || tF < 0.0) tN = -1.0
 ;return tN;}

// Function 1509
bool intersectSphere(Sphere sphere, Ray R, inout float distance, inout Surfel surfel) {
	Point3  C = sphere.center;
	float   r = sphere.radius;
	Point3  P = R.origin;
	Vector3 w = R.direction;
	
	Vector3 v = P - C;
	float b = 2.0 * dot(w, v);
	float c = dot(v, v) - square(r);
	float d = square(b) - 4.0 * c;
	if (d < 0.0) { return false; }
	
	float dsqrt = sqrt(d);
	
	// Choose the first positive intersection
	float t = min(infIfNegative((-b - dsqrt) / 2.0),
				  infIfNegative((-b + dsqrt) / 2.0));

	if (t < distance) {	
		surfel.position = P + w * t;
		surfel.normal   = normalize(surfel.position - C);
		surfel.material = sphere.material;
		
		distance = t;
		return true;
	} else {
		return false;
	}
}

// Function 1510
vec4 ray_sphere(vec3 ro, vec3 rd, float R){
    float d = dot(-ro, rd);
    vec3 p = ro+d*rd;
    float s = R*R-dot(p, p);
    if(s < 0.0) return vec4(-1.0);
    float o = sqrt(s);
    float t = d - o;
    return vec4(normalize(ro+t*rd), t);
}

// Function 1511
float Box( vec3 p, vec3 b )
{
	vec3 d = abs( p ) - b;
	return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );
}

// Function 1512
float sphere(vec3 pos) {
    float distanceFromCenter = length(pos);
    float sphereRadius = 1.0;
	return distanceFromCenter - sphereRadius;
}

// Function 1513
float fSphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 1514
float doBox(vec3 p) {
  p += vec3(0, 1, 0) * sin(iTime * 3.);
  p.xz = rotate2D(p.xz, (iTime * 5. + sin(0.8 + iTime * 3.)) * 0.7);
  p.xy = rotate2D(p.xy, (iTime * 5. + sin(0.8 + iTime * 3.)) * 0.5);

  return sdBox_1062606552(p, vec3(0.3) - 0.05) - 0.05;
}

// Function 1515
float dBox(vec2 p, vec2 b)
{
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 1516
float
torus42_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length(p.xy)-torus.x,p.z);
    return length4(q)-torus.y;
}

// Function 1517
float sdRoundBox(vec3 p, vec3 b, float r)
{
	vec3 d = abs(p) - b;
	return length(max(d, 0.0)) - r;
}

// Function 1518
vec4 fake_planet( vec2 fragCoord )
{
    vec4 fragColor;
    vec2 fragCoord2;
    fragCoord2.x += sin(iTime/3.5)*12.0;
    fragCoord2.y += cos(iTime/3.5)*12.0;
    fragCoord2 = HyperbolicDisc(fragCoord);
    vec2 uv = fragCoord2.xy / iResolution.xy;
    float wolo = fworley(uv*iResolution.xy / 1919.0) + fworley((uv*iResolution.xy + sin(iTime*2.0)) / 3200.0)
         + fworley((uv*iResolution.xy - sin(iTime*2.0)) / 4800.0);
 	wolo *= .85*exp(-length2(abs(0.5*uv-0.9)));
    fragColor = vec4(wolo * vec3(0.1*wolo*wolo, 0.3*wolo, 1.2*pow(wolo, 0.90-wolo)), 1.0);
    vec3 hsv = rgb2hsv(fragColor.xyz);
    hsv.z *= sqrt(hsv.z) * 1.1+ cos(iTime/13.0)*0.4;
    hsv.x += hsv.z/200.0 * sin(iTime/2.0)*2.0;
    hsv.y -= hsv.z/102.0;
    fragColor.xyz = hsv2rgb(hsv);
    return fragColor;
}

// Function 1519
float sdCylinder(vec3 p, vec3 a, vec3 b, float r){
    vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap)/dot(ab,ab);
    t = clamp(t,0.,1.);//never fall outside of A and B
    
    vec3 c= a+t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-.5)-.5)*length(ab);
    float e = length(max(vec2(x,y),0.));
    float i = min(max(x,y),0.);//performance penalty 
    
    //make it smoother 
    return e+i;
    
}

// Function 1520
bool sphereHit(in Sphere s, in Ray r,float t_min,float t_max,out HitRecord rec)
{
	float3 oc = r.o - s.center;
    float a = dot(r.d,r.d);
    float b = dot(oc, r.d);
    float c = dot(oc,oc) - s.radius*s.radius;
    float discriminant = b*b -a*c;
    if(discriminant > 0.0)
    {
        float temp = (-b-sqrt(discriminant) )/ (a);
        if( (temp < t_max) && (temp > t_min) )
        {
        	rec.t = temp;
            rec.p = rayPointAtParameter(r,rec.t);
            rec.normal =( rec.p-s.center) / s.radius;
            return true;
        }
        temp = (-b+sqrt(discriminant) )/ (a);
        if( (temp < t_max) && (temp > t_min) )
        {
            rec.t = temp;
            rec.p = rayPointAtParameter(r,rec.t);
            rec.normal =( rec.p-s.center) / s.radius;
            return true;
        }
    }

    return false;

}

// Function 1521
float sdTorus( const vec3 p, const vec2 t ) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 1522
vec3 SphereTrace(vec3 a, vec3 u, out bool hit)
{
	hit = false;
	vec3 p = a;
	float lambda = object_lipschitz();
	float depth = 0.0;
	float step = 0.0;
	for(int i = 0; i < Steps; i++)
	{
		float v = SphereTracedObject(p);
		if (v > 0.0)
		{
			hit = true; 
			return p;
		}
		
		step = max(abs(v) / lambda, Epsilon);
		depth += step;
		
		if(depth > RayMaxLength)
			return p;
		
		p += step * u;
	}
	return p;
}

// Function 1523
float sdCappedCylinder(vec3 p, float r, float h)
{
    return max(length(p.xz) - r, abs(p.y) - h);
}

// Function 1524
float sdOctahedronTorusOriented(vec3 p, vec3 n, vec2 t){
   p = smooth_abs(p);
   return sdTorusOriented(p,n,t);   
}

// Function 1525
float cylinderY(vec4 ray,vec3 pos, float radius, float height)
{
    maxGISize = max(maxGISize,height*radius*ray.w);
    
    return ray.w*(max(length(ray.xz-pos.xz) - radius, abs(ray.y-pos.y)-height));
}

// Function 1526
float raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)
{
	float res = 9999.0;
	vec3 oc = ro - center;
	float b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation
	float c = dot(oc,oc)-(radius*radius);
	
	float bminac = (b*b)-c;
	if (bminac >= 0.0)
	{
		//intersection
		float sqrtbminac = sqrt(bminac);
		float t = (-b + multiplier*sqrtbminac);
		res = mix(res,t,step(0.0,t));
 	}
	
	return res;
	
}

// Function 1527
float sphere(vec3 p, float radius) {
    return length(p) - radius;
}

// Function 1528
vec3 randomHemisphereDir(vec3 dir, float i){
	vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );
	return v * sign(dot(v, dir));
}

// Function 1529
bool RayIntersectAABox (SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 1530
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .1 );
}

// Function 1531
vec4 Box4( vec4 p_x, vec4 p_y, vec4 p_z, vec4 b_x, vec4 b_y, vec4 b_z )
{
	vec4 d_x = abs(p_x) - b_x;
	vec4 d_y = abs(p_y) - b_y;
	vec4 d_z = abs(p_z) - b_z;
	
	vec4 mdx = max(d_x,0.);
	vec4 mdy = max(d_y,0.);
	vec4 mdz = max(d_z,0.);
	
	vec4 len = sqrt( mdx*mdx+mdy*mdy+mdz*mdz );
		
	return min(max(d_x,max(d_y,d_z)),vec4(0)) + len;
}

// Function 1532
float boxinteriortrace( vec3 origin, 
                        vec3 rayDir, 
                        float halfCellSize )
{
    
    vec3 pn = -sign(rayDir);
    vec3 ddn = rayDir * pn;
    vec3 po = halfCellSize * -pn;
    vec3 t = -(pn * (origin - po))/ddn;
    float dist = min(t.x, min(t.y, t.z));    

    return dist;
}

// Function 1533
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad) 
{
	// ray-box intersection in box space
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    
	float tN = max(max( t1.x, t1.y ), t1.z);
	float tF = min(min( t2.x, t2.y ), t2.z);

	return vec2(max(tN,0.0), tF);
}

// Function 1534
float boxSDF(vec3 p, vec3 boxDim) {
    vec3 q = abs(p) - boxDim;
    return length(max(q, 0.0)) + min(maxComp(q), 0.0);
}

// Function 1535
float box(vec3 p, vec3 s)
{
	vec3 d = abs(p) - s;
    return length(max(d,0.0)) - min(max(d.x,max(d.y, d.z)),0.0);
}

// Function 1536
float sdBox(vec3 p, vec3 b, out bool edge)
{
    edge = false;
    vec3 d = abs(p) - b;
    // Detect edges:
    float thresh = .02 + snoise(p.xy * 1.5)/ 75.;
    float hthresh = .07 + snoise(p.xy * 1.5)/ 75.;
    if ((abs(d.x) < thresh && abs(d.y) < thresh) ||
        (abs(d.z) < hthresh && abs(d.y) < hthresh) ||
        (abs(d.x) < thresh && abs(d.z) < thresh)) {
        edge = true;
    }
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1537
vec4 sldBoxEdges(vec3 p, in vec3 s) {
  vec3 d = abs(p) - s;
  float l = length(best2(d));
  return vec4(l, d);
}

// Function 1538
vec3 sampleRandomHemisphere(vec3 p, vec3 n){
    vec3 randomVector = normalize(hash33(p * 10000.0 + iTime));
	float dotValue = dot(randomVector, n);
    randomVector *= dotValue;
    randomVector = normalize(randomVector);

    return randomVector;
}

// Function 1539
vec4 projUIBox(float delta) {
    
    return vec4(projBox.xy + vec2(delta*6.5*projSize, 0),
                0.75*projSize, 1.0*projSize);
    
}

// Function 1540
float box(vec3 p,vec3 boxPos,vec3 boxSize){
    vec3 d = abs(p-boxPos)-boxSize;
    return max(d.x,max(d.y,d.z));
}

// Function 1541
float intersectPlane( const vec3 ro, const vec3 rd, const float height) {	
	if (rd.y==0.0) return 500.;	
	float d = -(ro.y - height)/rd.y;
	if( d > 0. ) {
		return d;
	}
	return 500.;
}

// Function 1542
float udBox( vec3 p, vec3 b )
{
  return length(max(abs(p)-b,0.0));
}

// Function 1543
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {
    float a = dot(dir, dir);
    float b = dot(pos, dir);
    float c = dot(pos, pos) - r * r;
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    float t = -b - sqrt(D);
    if (t > 0.0) {
        normal = normalize(pos + t*dir);
        return t;
    }
    t = -b + sqrt(D);
    if (t < 0.0) {
        return INF;
    }
    normal = normalize(pos + t*dir);
    return t;
}

// Function 1544
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)
{
	//sphere at origin has equation |xyz| = r
	//sp |xyz|^2 = r^2.
	//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),
	//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:
	vec3 oc = ro - sph.xyz; //distance ray origin - sphere center
	
	float b = dot(oc, rd);
	float c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - c; // delta
	if(h < 0.0) 
		return -1.0;
	float t = (-b - sqrt(h)); //Again a = 1.

	return t;
}

// Function 1545
float TorusSDF(vec3 p, vec2 radii)
{
	vec2 q = vec2(length(p.xz) - radii.x, p.y);
    return length(q) - radii.y;
}

// Function 1546
vec2 	UIStyle_CheckboxSize() 			{ return vec2(16.0); }

// Function 1547
void dbox(in vec2 p, in vec2 b, out float dst)
{
  	vec2 d = abs(p) - b;
  	dst = length(max(d,0.0)) + min(max(d.x,d.y),0.0); 
}

// Function 1548
float rayBox(in vec3 ro){
    
    vec3 p = 1./svRd;
    p = abs(p)*1.01 - p*ro;
	return min(min(p.x, p.y), p.z);
}

// Function 1549
float sdSphere(vec3 p, vec3 c, float rad) {
	return length(p-c) - rad;
}

// Function 1550
float sdSphere( vec3 p, float s )
{
  return length(p)-s;
}

// Function 1551
float sdf_quarter1_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(-pos.y, -pos.x));
}

// Function 1552
vec3 PointOnSphereUniform( inout uint seed )
{
    vec2 uv = FRand2( seed );
    
    float theta= acos( 2.0 * uv.y - 1.0f );
    float phi = 2.0f * PI * uv.x;
    
    return SphericalToCartesianDirection( vec2( theta, phi ) );    
}

// Function 1553
float checkersTextureGradBox( in vec3 p, in vec3 ddx, in vec3 ddy )
{
    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;   // filter kernel
    vec3 i = (tri(p+0.5*w)-tri(p-0.5*w))/w;    // analytical integral (box filter)
    return 0.5 - 0.5*i.x*i.y*i.z;              // xor pattern
}

// Function 1554
float sdSphere( in vec3 p, in float s ) {
    return length(p)-s;
}

// Function 1555
float box(vec2 p)
{
    p=abs(p);
    return max(p.x, p.y);
}

// Function 1556
bool inBox(vec2 coord, vec4 bounds) {
	return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);
}

// Function 1557
float planetSDF( vec3 point ) {
    vec2 rot = point.xy + TRIG(1.,iTime*0.235);
    float n = 
        + 0.10 * noise( rot * 3. )
        + 0.03 * noise( rot * 9. )
        + 0.01 * noise( rot * 23. )
    ;
    return length(point) - 1.1 + 2.9 * n;
}

// Function 1558
vec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2 )
{
    // extremes
    vec2 mi = min(p0,p2);
    vec2 ma = max(p0,p2);

    // maxima/minima point, if p1 is outside the current bbox/hull
    if( p1.x<mi.x || p1.x>ma.x || p1.y<mi.y || p1.y>ma.y )
    {
        // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2
        // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)
        // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);

        vec2 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);
        vec2 s = 1.0 - t;
        vec2 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;
        
        mi = min(mi,q);
        ma = max(ma,q);
    }
    
    return vec4( mi, ma );
}

// Function 1559
vec3 getPlanetTriplanarTexture( vec3 p, vec3 n, float s) {
    vec3 xy = texture(iChannel0, p.xy).rgb;
    vec3 yz = texture(iChannel0, p.yz).rgb;
    vec3 xz = texture(iChannel0, p.xz).rgb;
    
    vec3 d = pow(abs(n), vec3(s));
    d /= dot(d, vec3(1));
    
    return xy * d.z + yz * d.x + xz * d.y;
}

// Function 1560
float
torus_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length(p.xy)-torus.x,p.z);
    return length(q)-torus.y;
}

// Function 1561
float sphere(vec3 pos, float radius, vec3 scale)
{
    return length(pos*scale)-radius;
}

// Function 1562
bool
intersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
	// compute intersection of ray with all six bbox planes
	vec3 invR = 1.0 / rd;
	vec3 tbot = invR * (boxmin - ro);
	vec3 ttop = invR * (boxmax - ro);
	// re-order intersections to find smallest and largest on each axis
	vec3 tmin = min (ttop, tbot);
	vec3 tmax = max (ttop, tbot);
	// find the largest tmin and the smallest tmax
	vec2 t0 = max (tmin.xx, tmin.yz);
	tnear = min (t0.x, t0.y);
	t0 = min (tmax.xx, tmax.yz);
	tfar = min (t0.x, t0.y);
	// check for hit
	bool hit;
	if ((tnear > tfar)) 
		hit = false;
	else
		hit = true;
	return hit;
}

// Function 1563
float sdTorus( vec3 p, vec2 t ) {
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 1564
float planeSdf(vec3 p, float planeOffset)
{
    return length(p.z) - planeOffset;
}

// Function 1565
vec3 cBox(vec2 p, vec2 b) {
    
    vec2 s = sign(p);
    vec2 d = abs(p) - b;
    float md = max(d.x, d.y);
    if (md < 0.0) { // inside
        if (md == d.x) { // 
            return vec3(p - s*vec2(d.x, 0), -1.);
        } else {
            return vec3(p - s*vec2(0, d.y), -1.);
        }
    } else {
       	return vec3(clamp(p, -b, b), 1.); // outside
    }
    
}

// Function 1566
bool sphere_hit(const in Sphere sphere, const in Ray inray) {
    vec3 oc = inray.origin - sphere.origin;
    float a = dot(inray.direction, inray.direction);
    float b = dot(oc, inray.direction);
    float c = dot(oc, oc) - sphere.rad*sphere.rad;
    float discriminant = b*b - a*c;
    return discriminant > 0.;
}

// Function 1567
float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)
{
    // sampling independent computations (only depend on shape)
    vec3  ba = b - a;
    float l2 = dot(ba,ba);
    float rr = r1 - r2;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;

    // sampling dependant computations
    vec3 pa = p - a;
    float y = dot(pa,ba);
    float z = y - l2;
    float x2 = dot2( pa*l2 - ba*y );
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    // single square root!
    float k = sign(rr)*rr*rr*x2;
    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;
    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;
                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;
}

// Function 1568
vec3 sdgBox( in vec2 p, in vec2 b )
{
    vec2 w = abs(p)-b;
    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);
    
    float g = max(w.x,w.y);
	vec2  q = max(w,0.0);
    float l = length(q);
    
    return vec3(   (g>0.0)?l   : g,
                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));
}

// Function 1569
float sdBox( vec3 p, vec3 b ){ vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}

// Function 1570
float sdPlane( vec3 p ){ return p.y;}

// Function 1571
float sdSphere(vec3 p, float s)
{
    return length(p) - s;
}

// Function 1572
float sdSphere( in vec3 p, in vec4 s )
{
    return length(p-s.xyz) - s.w;
}

// Function 1573
float sdTorus88(float dt, vec3 p, vec2 t)
{
    return sdTorus88(p,(1.-dt)*t);
}

// Function 1574
float line_sphere_intersection(vec3 origin, vec3 direction, vec3 center, float radius, out vec3 intersections[2]) {
    vec3 diagonal = origin-center;
	vec3 parallel = dot(diagonal, direction)*direction;
    vec3 orthogonal = diagonal-parallel;
    float orthogonal_distance = length(orthogonal);
    if(orthogonal_distance > radius)
        return 0.0;
   	float parallel_distance = sin(acos(orthogonal_distance/radius))*radius;
    intersections[0] = origin-parallel-direction*parallel_distance;
    intersections[1] = origin-parallel+direction*parallel_distance;
    return parallel_distance*2.0;
}

// Function 1575
bool checksphere (vec3 p, vec3 r, vec3 centre, float radius2) {
  p -= centre; // centre on sphere
  float pr = dot(p,r);
  if (pr > 0.0) return false;
  float pp = dot(p,p);
  return pr*pr >= pp-radius2;
}

// Function 1576
float sdBox(vec3 p, vec3 b){
    vec3 d = abs(p) - b;
      return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 1577
mat4 rotation_mat4_yz_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    return mat4(
    	1.0, 0.0, 0.0, 0.0, // x-basis
        0.0, cos_theta, sin_theta, 0.0, // y-basis
        0.0, (-1.0 * sin_theta), cos_theta, 0.0, // z-basis
    	0.0, 0.0, 0.0, 1.0); // w-basis
}

// Function 1578
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7),0.5);
}

// Function 1579
float squareToHemisphereCosinePDF(vec3 sampleP)
{
    //TODO
    float length=sqrt(pow(sampleP.x, 2.0f) + pow(sampleP.y, 2.0f) + pow(sampleP.z, 2.0f));
    if(length != 0.0)
    {
        float cosine = abs(sampleP.z) / length;
        return cosine / Pi;
    }
    else
    {
        return 0.0;
    }

}

// Function 1580
float planetShade(vec3 p, float ttime) {
  vec4 s_p = planetDim(ttime);
  vec2 rsi = raySphere(p, innerSunDir, s_p);

  // Fake, fake softshadows
  return rsi.x >= 0.0 && rsi.x < miss ? exp(-3.0*(rsi.y - rsi.x)/(rsi.x+0.1)) : 1.0;
}

// Function 1581
shapeResult sphere(vec3 origin, float radius, int materialId, vec3 at) {
    return shapeResult(distance(origin, at) - radius, materialId);
}

// Function 1582
float box(vec2 u,vec2 w){return ma(abs(u-w));}

// Function 1583
vec3 sphereColor(vec3 dir) {
    vec3 n = nebula(dir);
    vec4 p = planet(dir);
    vec3 color = 
        sun(dir) + 
        mix(vec3(starfield(dir)) * (1.0 - maxComponent(n)) +  // Nebula holds out star
    	    n, // nebula
            p.rgb, p.a); // planet
    
	return color;
}

// Function 1584
bool InBox( ivec2 p, ivec2 a, ivec2 b )
{
/*    p = abs(2*p-a-b)-abs(a-b);
    return p.x < 0 && p.y < 0; // will have 1-pixel error on odd-width/height*/
    ivec2 i = min(a,b);
    ivec2 j = max(a,b);
    return p.x >= i.x && p.y >= i.y && p.x < j.x && p.y < j.y;
}

// Function 1585
float sdSphere(vec3 pos, float radius) {
    return length(pos) - radius;
}

// Function 1586
float occSphere( in vec4 sph, in vec3 pos, in vec3 nor )
{
    vec3 di = sph.xyz - pos;
    float l = length(di);
    return 1.0 - max(0.0,dot(nor,di/l))*sph.w*sph.w/(l*l); 
}

// Function 1587
float sdf_sphere(in vec3 pos, in vec3 offset) {
    return length(pos - offset) - THICKNESS;
}

// Function 1588
float distPlane(vec3 pos, vec4 n)
{
    return dot(pos, n.xyz) + n.w;
}

// Function 1589
float sphere(vec3 p, float r)
{
   return length(p) - r;
}

// Function 1590
float plane(vec3 p, vec3 planeN, vec3 planePos)
{
    return dot(p - planePos, planeN);
}

// Function 1591
vec3 randomSphereDirection() {
    vec2 r = hash2()*6.2831;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dr;
}

// Function 1592
float Box(vec3 p, float size){
vec3 q=abs(p)-size;
return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1593
float sphereHit(vec3 ray, vec3 dir, vec3 center, float radius) {
    vec3 rc = ray - center;
    float c = dot(rc, rc) - (radius * radius);
    float b = dot(dir, rc);
    float d = b * b - c;
    float t = -b - sqrt(abs(d));
    float st = step(0.0, min(t, d));
    return mix(-1.0, t, st);
}

// Function 1594
float box(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
  	return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 1595
float iBox(Obj obj, vec3 o, vec3 r, inout vec3 n)
{
    // Calculate bounds
    vec3 bmin = obj.pos - obj.dim.xyz / 2.0;
    vec3 bmax = obj.pos + obj.dim.xyz / 2.0;
    
    // Calculate minima and maxima
    vec3 tmin3 = (bmin - o) / r;
    vec3 tmax3 = (bmax - o) / r;
    
    // Make sure they're the right way around
    if (tmin3.x > tmax3.x) swap(tmin3.x, tmax3.x);
    if (tmin3.y > tmax3.y) swap(tmin3.y, tmax3.y);
    if (tmin3.z > tmax3.z) swap(tmin3.z, tmax3.z);
    
    // Calculate minimum and maximum distance
    float tmin = max3(tmin3);
    float tmax = min3(tmax3);
    float t = min(tmin, tmax);
    
    // Skip over box if we're out of bounds
    if (tmin > min3(tmax3) || max3(tmin3) > tmax)
        t = -1.0;
    
    // Calculate normal
    vec3 p = o + r * t;
    vec3 sn = 2.0 * (p - obj.pos) / obj.dim.xyz;
    n = vec3(0.0);
    
    // Calculate normal
    if (sn.x > 1.0 - EPS * 2.0) n = vec3(1.0, 0.0, 0.0);
    if (sn.x < EPS * 2.0 - 1.0) n = vec3(-1.0, 0.0, 0.0);
    if (sn.y > 1.0 - EPS * 2.0) n = vec3(0.0, 1.0, 0.0);
    if (sn.y < EPS * 2.0 - 1.0) n = vec3(0.0, -1.0, 0.0);
    if (sn.z > 1.0 - EPS * 2.0) n = vec3(0.0, 0.0, 1.0);
    if (sn.z < EPS * 2.0 - 1.0) n = vec3(0.0, 0.0, -1.0);
    
    // Return distance
    return t;
}

// Function 1596
float sdPlane(vec3 p) {
    return p.y;}

// Function 1597
float iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
             in vec3  pa, in vec3  pb, in float ra, in float rb ) {
    vec3  ba = pb - pa;
    vec3  oa = ro - pa;
    vec3  ob = ro - pb;
    
    float m0 = dot(ba,ba);
    float m1 = dot(oa,ba);
    float m2 = dot(ob,ba); 
    float m3 = dot(rd,ba);

    //caps
    if (m1 < 0.) { 
        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {
            float d = -m1/m3;
            if (d >= distBound.x && d <= distBound.y) {
                normal = -ba*inversesqrt(m0);
                return d;
            }
        }
    }
    else if (m2 > 0.) { 
        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {
            float d = -m2/m3;
            if (d >= distBound.x && d <= distBound.y) {
                normal = ba*inversesqrt(m0);
                return d;
            }
        }
    }
                       
    // body
    float m4 = dot(rd,oa);
    float m5 = dot(oa,oa);
    float rr = ra - rb;
    float hy = m0 + rr*rr;
    
    float k2 = m0*m0    - m3*m3*hy;
    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );
    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);
    
    float h = k1*k1 - k2*k0;
    if( h < 0. ) return MAX_DIST;

    float t = (-k1-sqrt(h))/k2;

    float y = m1 + t*m3;
    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {
        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);
        return t;
    } else {   
	    return MAX_DIST;
    }
}

// Function 1598
float udRoundBox( vec3 p, vec3 b, vec3 r )
{
  return length(max(abs(p)-b,0.0))-r.x;
}

// Function 1599
float udBox( vec3 p, vec3 b )
{
    return length(max(abs(p)-b,0.0));
}

// Function 1600
vec4 shadePlane(const Ray ray, const RaycastHit hit, vec4 clearColor) {
 
    if(hit.type == 1) {
     
        float scale = 1.;
        float u = hit.point.x;
        float v = hit.point.z;
        
        //vec2 uv = rot2D(vec2(u,v),45. * sin(iTime));
        //u = uv.x;
        //v = uv.y;
        
        u = mod(u * scale, 1.);
        v = mod(v * scale, 1.);
        
        vec3 diffuse = texture(iChannel1,vec2(u,v)).xyz;
        
        if((u > .5 || v > .5) && !(u > .5 && v > .5)) {
         
            diffuse /= 2.;
            
        }
        
   	 	diffuse *= lighting(ray, hit);
        
        //vec3 spec = vec3(1.);
        //spec *= specular(ray, hit, 40.);
		//diffuse += spec;
        
    	return vec4(diffuse.xyz,1.);
        
    }
    
    return clearColor;
    
}

// Function 1601
float distTorus(vec3 p, vec2 t)
{
  vec2 tpp = tPos;
  tpp.y *= sin(iTime * 0.3);
  vec2 q = vec2(length(p.xy - tpp) - t.x, p.z);
  return length(q - tPos) - t.y;
}

// Function 1602
vec3 skyBox(vec3 rayDir)
{
    float circle = mix(abs(rayDir.y), length(rayDir.xy), abs(sin(iTime*twistSpeed)));
    vec3 center = mix(skyColor2, skyColor1, smoothstep(circle,0.0,centerSize));
    vec3 skyColor = mix(skyColor2, skyColor1, circle);
    return skyColor*0.25 + center;
}

// Function 1603
float boxgrid(vec3 p, float s, float r) {return boxgrid(p, vec3(s), vec3(r));}

// Function 1604
int addSixSpheres(Sphere parentSphere, int count) {
    float radius = parentSphere.radius;
    vec3 center = parentSphere.center;
    float childRadius = radius/2.8;
    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y+radius+childRadius-0.1, center.z), vec3(random(), random(), random()));
    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y-radius-childRadius+0.1, center.z), vec3(random(), random(), random()));
    spheres[++count] = Sphere(childRadius, vec3(center.x+radius+childRadius-0.1, center.y, center.z), vec3(random(), random(), random()));
    spheres[++count] = Sphere(childRadius, vec3(center.x-radius-childRadius+0.1, center.y, center.z), vec3(random(), random(), random()));
    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z+radius+childRadius-0.1), vec3(random(), random(), random()));
    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z-radius-childRadius+0.1), vec3(random(), random(), random()));
    return count;
}

// Function 1605
float lBox(vec2 p, vec2 a, vec2 b, float ew){
    
    float ang = atan(b.y - a.y, b.x - a.x);
    p = rot2(ang)*(p - mix(a, b, .5));
    
   vec2 l = vec2(length(b - a), ew);
   return sBox(p, (l + ew)/2.) ;
}

// Function 1606
float sdPlane(in vec3 p) {
    return p.y;
}

// Function 1607
float sphere (in vec3 p, in float r) {
	return length (p) - r;
}

// Function 1608
float sdBox(vec3 p,vec3 b
){vec3 q=abs(p)-b;return length(ma0(q))+min(mav(q),0.);}

// Function 1609
float roundCylinder(in vec3 p, in float h, in float r1, in float r2) {
    float
        a = abs(p.y)-(h-r2),
        b = length(p.xz)-r1;
    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);
}

// Function 1610
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// Function 1611
float box(vec3 pos, vec3 size)
{
    
    return length(min(abs(pos) - size, 0.0));
}

// Function 1612
vec3 sphereProjectionColour(vec3 rp, vec3 col) {
    
    vec3 pc = vec3(0.0);

    rp.xy *= rot(rotation * rotateProjection);
        
    vec3 pd = normalize(rp - pp);
    float ft = planeIntersection(pp, pd, fn, fo);
    if (ft > 0.0) {
        vec3 prp = pp + pd * ft; 
        pc += gridColour(prp, col);
    }

    return pc;
}

// Function 1613
float coneSDF(vec3 p, float height, float radius) {
    // c must be normalized
    vec2 c = normalize(vec2(height, radius));
    p.y -= height;
    float q = length(p.xz);
    float cone = dot(c,vec2(q,p.y));
    float plane = planeSDF(p, vec4(0.0, 1.0, 0.0, height));

    return max(-plane,cone);
}

// Function 1614
float sphere(vec3 p, float r){
        return length(p) - r;
      }

// Function 1615
bool intersectSphere(in vec3 ro, in vec3 rd, in float r) {
	float b = dot(rd,ro), d = b*b - dot(ro,ro) + r*r;
	return (d>0. && -sqrt(d)-b > 0.);
}

// Function 1616
float cylinder(vec3 p, vec3 c, float r, float h) {
   vec3 d = p-c;
   return max(length(d.xz - c.xz) - r, abs(d.y) - h);
}

// Function 1617
float boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
	vec3 p = (txx*vec4(pos,1.0)).xyz;
	vec3 n = (txx*vec4(nor,0.0)).xyz;
    
    // 8 verts
    vec3 v0 = normalize( vec3(-1.0,-1.0,-1.0)*rad - p);
    vec3 v1 = normalize( vec3( 1.0,-1.0,-1.0)*rad - p);
    vec3 v2 = normalize( vec3(-1.0, 1.0,-1.0)*rad - p);
    vec3 v3 = normalize( vec3( 1.0, 1.0,-1.0)*rad - p);
    vec3 v4 = normalize( vec3(-1.0,-1.0, 1.0)*rad - p);
    vec3 v5 = normalize( vec3( 1.0,-1.0, 1.0)*rad - p);
    vec3 v6 = normalize( vec3(-1.0, 1.0, 1.0)*rad - p);
    vec3 v7 = normalize( vec3( 1.0, 1.0, 1.0)*rad - p);
    
    // 12 edges    
    float k02 = dot( n, normalize( cross(v2,v0)) ) * acos( dot(v0,v2) );
    float k23 = dot( n, normalize( cross(v3,v2)) ) * acos( dot(v2,v3) );
    float k31 = dot( n, normalize( cross(v1,v3)) ) * acos( dot(v3,v1) );
    float k10 = dot( n, normalize( cross(v0,v1)) ) * acos( dot(v1,v0) );
    float k45 = dot( n, normalize( cross(v5,v4)) ) * acos( dot(v4,v5) );
    float k57 = dot( n, normalize( cross(v7,v5)) ) * acos( dot(v5,v7) );
    float k76 = dot( n, normalize( cross(v6,v7)) ) * acos( dot(v7,v6) );
    float k37 = dot( n, normalize( cross(v7,v3)) ) * acos( dot(v3,v7) );
    float k64 = dot( n, normalize( cross(v4,v6)) ) * acos( dot(v6,v4) );
    float k51 = dot( n, normalize( cross(v1,v5)) ) * acos( dot(v5,v1) );
    float k04 = dot( n, normalize( cross(v4,v0)) ) * acos( dot(v0,v4) );
    float k62 = dot( n, normalize( cross(v2,v6)) ) * acos( dot(v6,v2) );
    
    // 6 faces    
    float occ = 0.0;
    occ += ( k02 + k23 + k31 + k10) * step( 0.0,  v0.z );
    occ += ( k45 + k57 + k76 + k64) * step( 0.0, -v4.z );
    occ += ( k51 - k31 + k37 - k57) * step( 0.0, -v5.x );
    occ += ( k04 - k64 + k62 - k02) * step( 0.0,  v0.x );
    occ += (-k76 - k37 - k23 - k62) * step( 0.0, -v6.y );
    occ += (-k10 - k51 - k45 - k04) * step( 0.0,  v0.y );
        
    return occ / 6.283185;
}

// Function 1618
bool isinbox(vec2 a,vec2 b,float s){return isinbox(a-b,vec2(s));}

// Function 1619
vec3 nSphere(vec3 pos, vec3 sphPos, float sphRadius) {
	return (pos - sphPos) / sphRadius;
}

// Function 1620
vec2 intersect_sphere(vec3 ro, vec3 rd, float radius)
{
    float sq_radius = radius * radius;
    float		rtl = dot(ro,ro);
    if ( rtl <= sq_radius )
        return vec2(INF,-INF); //inside sphere
    float		ca = - dot(ro,rd);
    if ( ca < 0.0 )
        return vec2(INF,-INF); //ray is directed away from the sphere
    float		hc = sq_radius - rtl + ( ca * ca );
    if ( hc < 0.0 )
        return vec2(INF,-INF);
    hc = sqrt(hc);
    return vec2(ca - hc,ca + hc);
}

// Function 1621
float sdInfiniteXBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d.yz, 0.0))
         + min(max(d.y, d.z), 0.0);
}

// Function 1622
float sdSphere( vec3 p, float radius ) { return length(p)-radius; }

// Function 1623
float sBoxS(in vec2 p, in vec2 b, in float sf){

  p = abs(p) - b + sf;
  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;
}

// Function 1624
float sdPlane(vec3 p, vec4 n) {
  return dot(p, n.xyz) + n.w;
}

// Function 1625
float d_cone1( vec2 p, vec2 c, float time )
{
    p.x += 0.03 * sin(20.*(p.y+0.2 *time) );
    float q = length(3.*p.x);
    return dot(c,vec2(q,p.y));
}

// Function 1626
bool IUnitSphere(vec3 ro, vec3 rd, out vec3 p0/*, out vec3 p1*/) {
    float p = dot(rd, ro);
    float t = p*p - dot(ro, ro) + 1.0;
    
    if (t < 0.0) return false;
    
    float sq = sqrt(t);
    
    p0 = ro - (p + sq)*rd;
    //p1 = ro - (p - sq)*rd;
    
    return true;
}

// Function 1627
vec4 iCappedCone( in vec3  ro, in vec3  rd, 
                  in vec3  pa, in vec3  pb, 
                  in float ra, in float rb ) {
    vec3  ba = pb - pa, oa = ro - pa;
    float m0 = dot(ba,ba), m1 = dot(oa,ba)*.942, m3 = dot(rd,ba)*.942,
          m4 = dot(rd,oa), m5 = dot(oa,oa),
          rr = ra - rb,
          hy = m0 + rr*rr,   
          k2 = m0*m0    - m3*m3*hy,
          k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.),
          k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2. - m0*ra),
          h = k1*k1 - k2*k0;
    if( h<0. ) return vec4(-1);
    float t = (-k1-sqrt(h))/k2;
    float y = m1 + t*m3;
    return y>0. && y<m0 ?
            vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y)) :
            vec4(-1);
}

// Function 1628
void sphereFold(inout vec3 z, inout float dz)
{
	float r2 = dot(z,z);
	if (r2 < 0.5)
    { 
		float temp = 2.0;
		z *= temp;
		dz*= temp;
	}
    else if (r2 < 1.0)
    { 
		float temp = 1.0 / r2;
		z *= temp;
		dz*= temp;
	}
}

// Function 1629
float boxDist(in Ray ray, in Box box) {
    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);
    vec3 cDist = max(dist, 0.0);
    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;
}

// Function 1630
vec4 mapSphere( vec3 pos, float radius )
{
//	float DEP_VAL =sin(time) +2.;
	float dist = length(  pos ) - radius;//+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));
	vec3 col = vec3( 1.0, .2, .2 );
	return  vec4( col, dist);
}

// Function 1631
float sdCylinder(vec3 p, vec3 a, vec3 b, float r) {
	vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap) / dot(ab, ab);
    //t = clamp(t, 0., 1.);
    
    vec3 c = a + t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-.5)-.5)*length(ab);
    float e = length(max(vec2(x, y), 0.));
    float i = min(max(x, y), 0.);
    
    return e+i;
}

// Function 1632
float sdRoundCone( in vec3 p, in float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xz), p.y );

    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));

    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;

    return dot(q, vec2(a,b) ) - r1;
}

// Function 1633
float planeIntersect(in vec3 ro, in vec3 rd, in vec3 p, in vec3 n) {
    return dot(n, p - ro) / dot(n, rd);
}

// Function 1634
float LocalDistanceToRoundBox(vec3 P, RoundBox box)
{
	return length(max(vec3(0), abs(P) - box.extent + box.roundRadius)) - box.roundRadius;
}

// Function 1635
float iCSphereF( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	float d = b * b - c;
	if ( d < 0.0 ) return -MAX;
	return -b + sqrt( d );
}

// Function 1636
float deTorusWarped( vec3 p, vec2 t, out int material)
{
	p.y -= height;
	p = rotateMat * p;
	float l = length(p.xz);
	l= pow(l, 4.0) * .00008;
	vec2 q = vec2(l-t.x,p.y);
	if (q.x < -3.5) material = 2;
	else material = 3;
	return length(q)-t.y;
}

// Function 1637
float cone(vec3 p, vec3 a, float baseR, vec3 b, float capR)
{
    vec3 ab = b - a;
    // project c onto ab, computing parameterized position d(t) = a + t(b-a)
    float t = dot(p - a, ab) / dot(ab, ab);
    //t = clamp(t, 0.0, 1.0);
    vec3 c = a + t*ab;	// point on axis

    float r = mix(baseR, capR, t);
    float d = length(c - p) - r;
    d *= 0.25;
    vec3 n = normalize(ab);
    d = intersect(d, plane(p, n, b));
    d = intersect(d, plane(p, -n, a));
    return d;
}

// Function 1638
SceneData intersectBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    SceneData data;
    data.sdf = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
    data.materialID = 1;     
    return data;
}

// Function 1639
vec2 lineIntersectSphere(in vec3 o, in vec3 dir, float r) {
	float b = dot( o, dir );
	float c = dot( o, o ) - r * r;
	
	float d = b * b - c;
	if ( d < 0.0 ) {
		return vec2( MAX, -MAX );
	}
	d = sqrt( d );
	
	return vec2( -b - d, -b + d );
}

// Function 1640
float sdTorus(vec3 p, vec2 t) {
	vec2 q = vec2(length(p.xz) - t.x, p.y);
	return length(q) - t.y;
}

// Function 1641
float sdCylinder6(float dt, vec3 p, vec2 h)
{
    return sdCylinder6(p,(1.-dt)*h+.05);
}

// Function 1642
float sdThreadedCylinder(in vec3 p, in float h, in float r, in float turns, in float turnOffset, in float threadThickness) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);
    float cylinder = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));

    float a = p.y * turns + turnOffset;
    float c = cos(a), s = sin(a);
    p.xz *= mat2(c, -s, s, c);
    p.z -= r;
    float threads = max(abs(p.x), abs(p.z)) - threadThickness;

    return max(cylinder, -threads);
}

// Function 1643
float sdSphere( vec3 p, vec3 origin, float s )
{
  p = Translate(p, origin);
  return length(p)-s;
}

// Function 1644
float box(vec3 p, vec3 s)
{ 
    vec3 w = abs(p) - s/2.0;
    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   
}

// Function 1645
vec3 closestPointToBox( vec3 p, vec3 b )
{
    vec3   d = abs(p) - b;
    float  m = min(0.0,max(d.x,max(d.y,d.z)));
    return p - vec3(d.x>=m?d.x:0.0,
                    d.y>=m?d.y:0.0,
                    d.z>=m?d.z:0.0)*sign(p);
}

// Function 1646
float sdTorus82( vec3 p, vec2 t )
{
  vec2 q = vec2(length2(p.xz)-t.x, p.y);
  return length8(q) - t.y;
}

// Function 1647
bool intersectHypersphere(
    vec2 rayPosition,
    vec2 rayDirection,
    vec2 center,
    float radius,
    out float t)
{
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * (dot(rayDirection, rayPosition) - dot(rayDirection, center));
    float c = dot(rayPosition, rayPosition) - 2.0 * dot(rayPosition, center) + dot(center, center) - H_sq(radius);

    return solveQuadraticIntersection(a, b, c, t);
}

// Function 1648
vec3 uvToCameraPlanePoint(in vec2 uv)
{
 	return vec3(uv.x, uv.y, 1.5 + sin(iTime * TIMESCALE * 0.3) * 0.2);   
}

// Function 1649
float SphereSDF(vec3 p,float r)
{
    return length(p) - r;
}

// Function 1650
void analytical_box(in vec3 o, in vec3 dir, in vec3 size, out float d)
{
    vec3 tlo = min((size-o)/dir,(-size-o)/dir); // Select 3 visible planes
    vec2 abxlo = abs(o.yz + tlo.x*dir.yz),
        abylo = abs(o.xz + tlo.y*dir.xz),
        abzlo = abs(o.xy + tlo.z*dir.xy);
    vec4 dn = 100.*c.xyyy;
    
    dn = mix(dn, vec4(tlo.x,c.xyy), float(all(lessThan(abxlo,size.yz)))*step(tlo.x,dn.x));
    dn = mix(dn, vec4(tlo.y,c.yxy), float(all(lessThan(abylo,size.xz)))*step(tlo.y,dn.x));
    dn = mix(dn, vec4(tlo.z,c.yyx), float(all(lessThan(abzlo,size.xy)))*step(tlo.z,dn.x));

    d = dn.r;
}

// Function 1651
float sdSphere(in vec4 p, in float s) {
    return length(p)-s;
}

// Function 1652
void sampleSphereHemisphereUniform(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){
    
    vec3 main_direction = normalize(viewer - sphere.position);
    sls.normal = randomDirectionHemisphere(main_direction, 0.0f);
   	if(dot(sls.normal, main_direction) < 0.0f) sls.normal *= -1.0f;
    
    sls.point = sphere.position + (sphere.radius ) * sls.normal;
    
    
    sls.pdf = 1.0f / (TWO_PI * sphere.radius2);
}

// Function 1653
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0)) - r
         + min(max(d.x,max(d.y,d.z)),0.0); 
}

// Function 1654
float sdCylinder(vec3 p, float h, float r)
{
    vec2 q = vec2( length(p.xz)-r, abs(p.y-h*0.5)-h*0.5 );
    return min( max(q.x,q.y),0.0) + length(max(q,0.0));
}

// Function 1655
vec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim, bool outside) 
{
    vec3 m = 1.0/ray;
    vec3 n = m*(ctr-pos);
    vec3 k = abs(m)*dim;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tmax = max( max( t1.x, t1.y ), t1.z );
	float tmin = min( min( t2.x, t2.y ), t2.z );
	
	if( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);

    if(outside){
        vec3 norm = -sign(ray)*step(vec3(tmax),t1);
        return vec4(norm, tmax);
    }
    else{
        vec3 norm = -sign(ray)*step(t2, vec3(tmin));
        return vec4(norm, tmin);
    }
}

// Function 1656
float sdCappedCylinder( vec3 p, vec2 h )
{
    
    
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1657
bool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	int closestAxis = 0;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestAxis = axis;
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}
	
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (closestAxis == 0)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (closestAxis == 1)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
	
	vec3 relPoint = info.m_intersectionPoint - box.m_pos;
	info.m_textureCoordinates = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);
	
	// bump mapping
	mat3 mattanspace = mat3
	(
		uaxis,
		vaxis,
		info.m_surfaceNormal
	);
	
	float delta = -1.0/512.0;
	if (box.m_Id == 4) {
		float A = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
		float B = texture(iChannel1, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    	float C = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, delta)).x;
		vec3 norm = normalize(vec3(B - A, C - A, 0.25));
		info.m_surfaceNormal = normalize(mattanspace * norm);
	}
	else {
		float A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
		float B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    	float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;
		vec3 norm = normalize(vec3(B - A, C - A, 0.25));
		info.m_surfaceNormal = normalize(mattanspace * norm);		
	}
	
	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 1658
vec3 box_normal_from_point(vec3 point,vec3 box_extents)
{
	vec3 normal = vec3(0.0);
	float m = INF;
	float d;

	d = abs(box_extents.x - abs(point.x));
	if (d < m)
	{
		m = d;
		normal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X
	}

	d = abs(box_extents.y - abs(point.y));
	if (d < m)
	{
		m = d;
		normal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y
	}

	d = abs(box_extents.z - abs(point.z));
	if (d < m)
	{
		m = d;
		normal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z
	}

	return normal;
}

// Function 1659
float box(vec2 p, float r) {
  p=abs(p)-r;
  return max(p.x, p.y);
}

// Function 1660
float
capped_cylinder_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;
    return min( maxv(d), 0.0 ) + length( max(d, 0.0) );
}

// Function 1661
float obj_planeX(vec3 p, float planeX){
    return p.x-planeX;
}

// Function 1662
float sdBox(vec3 p, vec3 s)
{
    p = abs(p) - s / 2.0;
    return max(max(p.x,p.y),p.z);
}

// Function 1663
void cylinder(vec3 ro, vec3 rd, vec3 d, float h0, float h1, float r, mat3 m,
			  inout float out_t, inout vec3 out_n, vec3 ofs)
{
	// Transform the ray. This is for convenience when transforming whole limbs.
	ro = m * ro - ofs;
	rd = m * rd;
	
	// Project the ray's origin onto the cylinder's axis.
	float dd = dot(ro, d);
	
	// Find a local coordinate system for the cylinder.   
	vec3 u = cross(vec3(1.0, 0.0, 0.0), d);
	vec3 v = normalize(cross(u, d));
	u = normalize(cross(v, d));
	
	mat3 cm = mat3(u, v, d);
	
	// Reduce the intersection problem to two dimensions.
	vec2 lro = vec2(dot(ro, u), dot(ro, v));
	vec2 lrd = vec2(dot(rd, u), dot(rd, v));
	
	vec2 t2 = intersectCircle(lro / r, lrd / r);
	
	if(t2.y > 1e2)
		return;
	
	// Find the intersection of the ray with the endcap planes.
	float t0 = (+h0 - dd) / dot(rd, +d);
	float t1 = (-h1 + dd) / dot(rd, -d);
	
	// Sort the endcap plane intersections.
	float mt0t1 = min(t0, t1);
	float xt0t1 = max(t0, t1);
	
	// Find the ray-cylinder interection interval.
	float i0 = max(min(t0, t1), t2.y);
	float i1 = min(max(t0, t1), t2.x);
	
	// If the interval is invalid, then there was no intersection.
	if(i1<=i0)
		return;
	
	vec3 rp = ro + rd * i0;
	
	// Find and transform the surface normal into worldspace.
	vec3 n = transpose(cm) * transpose(m) * normalize(rp - d * clamp(dot(rp, d), h0 + 0.2, h1 - 0.2));
	
	// Snap the normal to make the cylinder appear faceted. The normal is projected
	// onto a cube before snapping in 2D.
	vec3 an = abs(n);
	
	if(an.x > an.y && an.x > an.z)
	{
		n.yz = qu(n.yz / n.x);
		n.x = 1.0;
	}
	else if(an.y > an.x && an.y > an.z)
	{
		n.xz = qu(n.xz / n.y);
		n.y = 1.0;
	}
	else if(an.z > an.y && an.z > an.x)
	{
		n.xy = qu(n.xy / n.z);
		n.z = 1.0;
	}
	
	// Store the hitpoint data if it's valid.
	out_n = mix(cm * n, out_n, step(out_t, i0));
	out_t = min(i0, out_t);
}

// Function 1664
float traceSphere(vec3 ro, vec3 rd, float radsq)
{
	float a = dot(rd, rd);
	float b = dot(ro, rd);
	float c = dot(ro, ro) - radsq;
	float d = (b * b - a * c) * 4.0;

	return mix(1e4, (-b + sqrt(d)) / (2.0 * a), step(0.0, d));
}

// Function 1665
float sdBox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)),0.0) + length(max(d, 0.0));
}

// Function 1666
float sdCrateBox( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 1667
float planeSDF(vec3 p, vec4 plane) { return dot(p - plane.w, plane.xyz); }

// Function 1668
bool box(in vec2 p, in vec2 center, in vec2 halfSize, in vec2 skew) {
    p -= center;
    p.x += tan(skew.x)*p.y;
    p.y += tan(skew.y)*p.x;
    return clamp(p, -halfSize, halfSize) == p;
}

// Function 1669
float Map2Box(in vec3 pos, in vec2 top_half_size, in vec2 bottom_half_size, in float half_h)
{//center at (0,0,0)
	float y = abs(pos.y) - half_h;
	float p = pos.y*0.5/half_h + 0.5;
	p = clamp(p, 0.0,1.0);//bottom---top
	float x = abs(pos.x) - mix(bottom_half_size.x, top_half_size.x, p);
	float z = abs(pos.z) - mix(bottom_half_size.y, top_half_size.y, p);
	
	if (x<0.0 || y <0.0 || z<0.0)
		return max(max(x, y), z);
	return sqrt(x*x + y*y + z*z);
}

// Function 1670
float sdCylinder(vec3 p, vec3 a, vec3 b, float r){
  	vec3 ab = b - a;
    vec3 ap = p - a;
    
    float t = dot(ab, ap)/dot(ab, ab);
    //t = clamp(t, 0., 1.);
    vec3 c = a + t * ab;
    
    float x = length(p - c) - r;
    float y = (abs(t- .5) - .5) * length(ab);
    float e = length(max(vec2(x,y), 0.));
    float i = min(max(x,y), 0.);
        
    return e + i ;
}

// Function 1671
float cone_r( float z ) { return cone_radius_mult * z / (.375*iResolution.x); }

// Function 1672
float RLightCone()
{
	// tan of one half of subtended angle of sun disc in sky

	return 0.02;
}

// Function 1673
float plane(vec3 p,vec3 po,vec3 n){
    n=normalize(n);
    vec3 dp=p-po;
    return dot(dp,n);
}

// Function 1674
float regular_infinite_cylinder_intersection(
    in vec3 origin,
    in vec3 ray,
    in float radius,
    out vec3 position,
    out vec3 normal
) {
    vec2 p_ray = normalize(ray.xy);
    vec2 p_org = origin.xy;
    vec2 p_h = dot(p_ray, p_org) * p_ray - p_org;
    float res = radius * radius - dot(p_h, p_h);
    if (res < 0.0) {
        return res;
    }
    float t = dot(p_ray, -p_org) - sqrt(res);
    t *= 1.0 / length(ray.xy);
    position = origin + t * ray;
    normal = vec3(position.xy, 0.0);
    return res;
}

// Function 1675
bool intersectSphere(vec3 rd,vec3 o,out float near,out float far){
    float b = 2.0 * dot(rd,o);
    float c = dot(o,o) - sphere_radius_square;
    
    float delta = b*b - c*4.0;
    if(delta < 0.0) return false;
    delta = sqrt(delta);
    
    near = (-b - delta) / 2.0;
    far = (-b + delta) /2.0;
    
    return far > 0.0;
}

// Function 1676
float sdZAlignedCylinder( vec3 p, float l, float r )
{
    p.x -= clamp( p.x, 0.0, l );
    return length(p) - r;
}

// Function 1677
float plane(vec3 _p, float _h)
{
	return _p.y - _h;
}

// Function 1678
vec4 sdSphere(DAVec3 p){
 p.x*=.8;p.x-=.5*sin(1.61*iTime);
 p.y*=.8;
 p.z*=.8;p.z-=.5*cos(1.61*iTime);
 vec4 q=da_length(p.x,p.y,p.z);
 q=da_sub(q,1.);
 return q;}

// Function 1679
bool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)
{
	vec3 relDistance = (ro - pos);
	float b = dot(relDistance, rd);
	float c = dot(relDistance, relDistance) - radius*radius;
	float d = b*b - c;
	intersectPoint = ro + rd*(-b - sqrt(d));
	return d >= 0.0;
}

// Function 1680
float udRoundBox( vec3 p, vec3 b, float r )
{
  return length(max(abs(p)-b,0.0))-r;
}

// Function 1681
bool intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 r1) {
    vec3 t0 = (-o - ext) / d; 
    vec3 t1 = (-o + ext) / d;    
    vec3 n = min(t0,t1); n.x = max(max(n.x,n.y),n.z);
    vec3 f = max(t0,t1); f.x = min(min(f.x,f.y),f.z);
    r0 = o + d * n.x;
    r1 = o + d * f.x;
    return bool(step(n.x,f.x));
}

// Function 1682
vec4 plane_from_triangle(vec3 p0, vec3 d0, vec3 d1) {
    vec3 n = normalize(cross(d0, d1));
    return vec4(n, -dot(n, p0));
}

// Function 1683
vec2 cutoffPlanes(vec3 p, const in Ray ray){
    vec3 pos = p - birds[0].boundingSphere.origin;
    float rad = birds[0].boundingSphere.rad + 2.5;
    pos.z = abs(pos.z);
    
    float vc = sdCylinder(pos, vec2(10., 25.));
    float hc = sdCylinder(pos.yxz, vec2(5., 25.));
    float a = smoothstep(.5, .35, distance(.5, bap.phase));
    int bapid = int(bap.id);
    if(bapid == AP_SHAPE_SPHERE_CUT_TOP)
        return vec2(max(vc, plane(pos, normalize(vec3(0., 1., .5)), max(1.5, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_TOP] * 8.))), a);
    else if(bapid == AP_SHAPE_SPHERE_CUT_BOTTOM)
        return vec2(max(vc, plane(pos, normalize(vec3(0., -1., 1.)), max(1.5, apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BOTTOM] * 8.))), a);
    else if(bapid == AP_SHAPE_SPHERE_CUT_FRONT)
        return vec2(max(hc, plane(pos, normalize(vec3(1., 1., 1.5)), max(2.5, (apPhasesInvStates[AP_SHAPE_SPHERE_CUT_FRONT] + 1.) * 3.))), a);
    else if(bapid == AP_SHAPE_SPHERE_CUT_BACK){
        float hc = sdCylinder(pos.yxz, vec2(1., 25.));
        return vec2(max(hc, plane(pos, normalize(vec3(-.5, -1.5, 1.5)), max(.5, (apPhasesInvStates[AP_SHAPE_SPHERE_CUT_BACK] + .5) * 3.))), a);
    }else if(bapid == AP_SHAPE_WING_CUT_TOP_BOTTOM){
        float r = min(max(vc, plane(pos, normalize(vec3(0., 1., 0.)), max(1.5, apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM] * 8.))),
                      max(vc, plane(pos, normalize(vec3(0., -1., 0.)), max(1.5, apPhasesInvStates[AP_SHAPE_WING_CUT_TOP_BOTTOM] * 8.))));
        return vec2(r, a);
    }else if(bapid == AP_SHAPE_WING_CUT_FRONT)
        return vec2(max(hc, plane(pos, normalize(vec3(1., 0., 1.25)), max(2.5, (apPhasesInvStates[AP_SHAPE_WING_CUT_FRONT] + 1.) * 3.))), a);
    else if(bapid == AP_SHAPE_WING_CUT_BACK)
        return vec2(max(hc, plane(pos, normalize(vec3(-1., 0., -.5)), max(.5, (apPhasesInvStates[AP_SHAPE_WING_CUT_BACK] + .6) * 3.))), a);
    
    return vec2(MAX_FLOAT);
}

// Function 1684
float sdfSphere(vec3 center, vec3 pos, float rad) {
	float dist = length(center - pos) - rad;
    
    return dist;
}

// Function 1685
float sdBox( vec3 p, vec3 b ) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1686
bool closestSphereDisk(vec3 cSphere, float rSphere, vec3 cDisk, vec3 nDisk, float rDisk, float eDisk, out vec3 out0, out vec3 out1) {
    out0 = cSphere; out1 = closestPtDisk(cSphere, cDisk, nDisk, rDisk);
    return removeThickness(rSphere, eDisk, out0, out1);
}

// Function 1687
float sdBox(vec3 p, vec3 r) {
    p = abs(p) - r;
	return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));
}

// Function 1688
vec4 renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, inout float out_dStar, out vec3 out_id) { 
    out_id = vec3(9);

    roG -= sunPos;
    roG *= PLANET_FIELD_SCALE;
    roG.z+=.5;
    
    float distSunDrawing = out_dStar*PLANET_FIELD_SCALE;
    float rayon = 3.;
    float min_dist=0., max_dist=100.;
    
    vec4 col, sum = vec4(0);

  //  if (cylinder(roG, rd, rayon, 1., min_dist, max_dist)) {
        float dint, d = max(0., (length(roG)-rayon)); //min_dist;
        vec3 offset, id,
             ros = roG + rd*d,  
             pos = floor(ros),
             ri = 1./rd,
             rs = sign(rd),
             dis = (pos-ros + .5 + rs*.5) * ri;

        for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {
            if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {
                id = hash33(pos+sunPos);
                offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);
                offset.z = .5;
				
                col = renderPlanet((ros-(pos+offset))/PLANET_RADIUS, rd, vec4(id,.5), normalize((pos+offset)-ros), distSunDrawing);
                out_id = id;
                if (col.a>.95) out_dStar = dint;
                col.rgb *= col.a;				                                
                sum += (1.-sum.a)*col;
                if (sum.a>.99)
                    break;
            }
            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);
            dis += mm * rs * ri;
            pos += mm * rs;
            
        }
  //  }
    return sum;
}

// Function 1689
float sdBoundingBox( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 1690
float sdSphere( vec3 p, float s1 )
{
   vec4 s = vec4(0, s1, 9, s1);
   return  length(p-s.xyz)-s.w;   
}

// Function 1691
float sdTorus(vec3 p, vec2 r){
    //r.x would be r1, r.y would be r2
    float x = length(p.xz)-r.x;
    vec2 cp = vec2(x,p.y);
    float a = atan(p.x,p.z);
    cp*=Rot(a*3.+iTime);    
    cp.y=abs(cp.y)-mix(0.2,.5,abs(sin(iTime)));//-mix(0.2,.5,abs(sin(iTime)))
    float d = length(cp)-r.y;
    
    return d*0.5;
}

// Function 1692
float distCylinderBump( vec3 pos, vec3 properties, sampler2D image, float scale)
{
	// Add in a bit of positional variation.
	pos.xz += sin(pos.zx)*.25;
	
	// Mod the position along the XZ plane for repetition.
	pos.xz = mod(pos.xz,TREE_REP.xz);
	
	// Bring the location back to the center of the modded domain.
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	// Create a variable to store potential bump.
	float bump = 0.0;
	
	// Find the distance from the point to the object
	// accounting for minimum bump height.
	float dist = length(pos.xz-properties.xy)-properties.z;
	
	// If it's less than the maximum bump height we need to figure
	// out the specific distance to the object including proper bump.
	if(dist < FEATURE_BUMP_FACTOR*2.0)
	{
		// Get a general okay flat-surface normal.
		vec2 normal = normalize(pos.xz-properties.xy);
		
		// Get the bumpheight by sampling the red channel of a texture.
		bump = tex3D(pos*scale+pos, vec3(normal.x, 0.0, normal.y), image).r*FEATURE_BUMP_FACTOR;
	}
	return dist-bump;
}

// Function 1693
float Intersect_Ray_Sphere(
vec3 rp, vec3 rd, 
vec3 sp, float sr2, 
out vec2 t)
{	
	rp -= sp;
	
	float a = dot(rd, rd);
	float b = 2.0 * dot(rp, rd);
	float c = dot(rp, rp) - sr2;
	
	float D = b*b - 4.0*a*c;
	
	if(D < 0.0) return 0.0;
	
	float sqrtD = sqrt(D);
	// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;
	t = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;
	
	// if(start == inside) ...
	if(c < 0.0) t.xy = t.yx;

	// t.x > 0.0 || start == inside ? infront : behind
	return t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;
}

// Function 1694
float planeSDF(vec3 p) {
    return p.y;
}

// Function 1695
Result planeIntersect (in Ray ray, in vec3 p, in vec3 n, in int id) {
    Result res = nullResult;

	// are ray and plane parallel?
    if (dot (n, ray.rd) > 1e-6) {
        return res;
    }

    // determine ray-plane intersection point
    vec3 i = ray.ro + (dot(p - ray.ro, n) / dot (ray.rd, n)) * ray.rd;


    // prepare result
    res.hit = true;
    res.point = i;
    res.normal = normalize (n);
    res.dist = distance (i, ray.ro);
    res.id = id;

    return res;
}

// Function 1696
float sdSphere( vec3 p, float s ){ return length(p)-s;}

// Function 1697
float sdSphere( vec4 p, float r ) {
                    return length(p)-r;
                }

// Function 1698
float iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
              in vec3 planeNormal, in float planeDist) {
    float a = dot(rd, planeNormal);
    float d = -(dot(ro, planeNormal)+planeDist)/a;
    if (a > 0. || d < distBound.x || d > distBound.y) {
        return MAX_DIST;
    } else {
        normal = planeNormal;
    	return d;
    }
}

// Function 1699
vec3 randomSphereDirection(inout float seed) {
    vec2 r = hash2(seed)*6.2831;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dr;
}

// Function 1700
float sdCylinder(vec3 p,vec3 center,vec2 size)
{
    p-=center;
    return max(
        length(p.xz)-size.x,
        abs(p.y)-size.y*.5
    );
}

// Function 1701
vec3 getSphereColor(int i)
{
    
    float m;
        
	if(i==0 )
    {
    
        return vec3(0.,0.,0.);
    }
    
    if(i== 1 )
    {
        
        return vec3(0.,0.,1.);
    } 
    if(i== 2 )
    {
       return vec3(0.,1.,0.);
    } 
    if(i== 3 )
    {
        return vec3(0.,1.,1.);
    } 
    if(i== 4 )
    {
        return vec3(1., 0., 0.);
    } 
    
    if(i== 5 )
    {
        return vec3(1., 0.,1.);
        } 
    if(i== 6 )
    {
        
    	//return vec3(1., 1., 0.);
         
    } 
        
    if(i== 7 )
    {
        return vec3(1., 1., 1.);
       } 
    if(i== 8 )
    {
       
        return vec3(0.425, 0.56, 0.9); 
       } 
    if(i== 9 )
    {
        
        return vec3(0.5, 0.6, 0.6); 
     } 
    if(i== 10 )
    {
        return vec3(0.0, 1.0, 0.0);
    } 
    
    
    if(i== 11 )
    {
        return  vec3(0.5, 0.8, 0.9);;
    } 
    
    
    
  
    	
}

// Function 1702
float sdCylinder6( vec3 p, vec2 h )
{
    return max( length6(p.xz)-h.x, abs(p.y)-h.y );
}

// Function 1703
float sdSphere( vec3 p, float s )
{
    return length(p)-s;
}

// Function 1704
vec3 sdBoxNormal (vec3 p, vec3 b)
{
    // XXX: did I flip all the signs?
    if (abs(p.x) > abs(p.y)) {
        if (abs(p.x) > abs(p.z)) {
            return vec3(sign(p.x), 0, 0);
        } else {
            return vec3(0, 0, sign(p.z));
        }
    } else {
        if (abs(p.y) > abs(p.z)) {
            return vec3(0, sign(p.y), 0);
        } else {
            return vec3(0, 0, sign(p.z));
        }
    }
}

// Function 1705
float
sphere_sd( in float sph_r, in vec3 p )
{
    return length( p ) - sph_r;
}

// Function 1706
float box( float x ) { return abs( x ) < 1.0 ? 1.0 : 0.0; }

// Function 1707
float sdSphere(vec3 point, float radius)
{
    return length(point) - radius;
}

// Function 1708
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, in float rnd) {
    float distor = rnd * sin(16.0 * (pos.x + dir.x)) * sin(16.0 * (pos.y + dir.y)) * sin(16.0 * (pos.z + dir.z));
    float a = dot(dir, dir);
    float b = dot(pos, dir);
    float c = dot(pos, pos) - (r - distor) * (r - distor);
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    float t = -b - sqrt(D);
    if (t > 0.0) {
        normal = normalize(pos + t * dir);
        return t;
    }
    t = -b + sqrt(D);
    if (t < 0.0) {
        return INF;
    }
    normal = normalize(pos + t * dir);
    return t;
}

// Function 1709
float BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal ){
	vec3 invDir = 1.0 / r.direction;
	vec3 tmin = (minCorner - r.origin) * invDir;
	vec3 tmax = (maxCorner - r.origin) * invDir;
	
	vec3 real_min = min(tmin, tmax);
	vec3 real_max = max(tmin, tmax);
	
	float minmax = min( min(real_max.x, real_max.y), real_max.z);
	float maxmin = max( max(real_min.x, real_min.y), real_min.z);
	
	if (minmax > maxmin)
	{
		
		if (maxmin > 0.0) // if we are outside the box
		{
			normal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);
			return maxmin;	
		}
		
		else if (minmax > 0.0) // else if we are inside the box
		{
			normal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);
			return minmax;
		}
				
	}
	
	return INFINITY;
}

// Function 1710
float sdf_box(vec2 uv, vec2 mins, vec2 maxs)
{
    return sdf_centered_box(uv, (mins+maxs)*.5, (maxs-mins)*.5);
}

// Function 1711
SphereData GetSphereData(vec4 data, vec3 rd, vec3 ro)
{
    bool collided1 = data.x == -1. ? false : true;
    bool collided2 = data.z == -1. ? false : true;
    vec3 collideIn1 = ro + rd * data.x;
    vec3 collideOut1 = collideIn1 + rd * data.y;
    vec3 collideIn2 = collideOut1 + rd * data.z;
    vec3 collideOut2 = collideIn2 + rd * data.w;
    SphereData dat = SphereData(data.x, data.y, data.z, data.w, collided1, collided2, collideIn1, collideOut1, collideIn2, collideOut2);
    return dat;
}

// Function 1712
float sphere(ray r, sph s, float n){
	vec3 rc = r.ro-s.c;
	float c = dot(rc, rc) - (s.r*s.r);
	float b = dot(r.rd, rc);
	float d = b*b - c;
	float t = -b - n*sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return max(0.,mix(-1., t, st));
}

// Function 1713
bool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    float t0, t1;
    vec3 L = ray.origin;
    float a = dot( ray.dir, ray.dir );
    float b = 2.0 * dot( ray.dir, L );
    float c = dot( L, L ) - radiusSquared;
    
    if (!solveQuadratic( a, b, c, t0, t1))
		return false;
    
    if( t0 > 0.0 ) {
    	t = t0;
    } else {
        if ( t1 > 0.0 ) {
            t = t1;
        } else {
            return false;
        }
    }
    
    if( !forShadowTest ) {
        isect.position_ = ray.origin + ray.dir*t;
        isect.normal_ = normalize( isect.position_ );

        float rho, phi, theta;
        cartesianToSpherical( isect.normal_, rho, phi, theta );
        isect.uv_.x = phi/PI;
        isect.uv_.y = theta/TWO_PI;

        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
        vec3 tmp = cross( isect.normal_, isect.tangent_ );
        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );
    }
	
	return true;
}

// Function 1714
float intersectRayPlane(vec3 ro, vec3 rd, vec3 n, vec3 p) {
  const float eps = 0.0001;
  float denom = dot(rd, n);
  return abs(denom) < eps ? -1.0 : dot(p - ro, n) / denom;
}

// Function 1715
float intersect_plane(vec3 ray_origin, vec3 n_ray_direction, vec3 plane_origin, vec3 n_plane_normal)
{
    float denominator = dot(n_ray_direction, n_plane_normal);
    float t = dot(plane_origin - ray_origin, n_plane_normal) / denominator;
    return(t);
}

// Function 1716
vec3 planetColor(in vec3 u, in float m,out vec3 e,vec3 s)
{s.x=dot(normalize(u),s)
;float w=waterDepth(u,.5),v=dot(normalize(u),s);
;u=planetSpin()*u//planetspin is matrix. must be on left side
;vec3 n=dg(u),c=vec3(0)
;e=vec3(0); 
;vec2 cn1=cellular2x2x2(u);    
//;float updotn = dot(n, normalize(u)); 
//;float ydotn = dot(n, vec3(0,1,0));
;float pn0=noise3((u+59.)/16.)
,pn1=noise3(u*.5)
,pn2=noise3((u+59.))
,pn3=noise3((u+129.)*2.);
;float pf=pn1+.5*pn2+.25*pn3
,l=sat((length(u)-SEA_LEVEL)/(ATMOSPHERE_HEIGHT))
,cm=smoothstep(0.04, 0.15, l+(0.04*pf))
,dm=smoothstep(.1,.3,pn0+.15*pf)//desert mask
,cn=(smoothstep(0.26, 0.25,v))*(cn1.y-cn1.x)*dm
,sl=.25+.75*smoothstep(.0,.1, l)
,upf=u5(pf);
#ifdef ENABLE_DETAILS
;float pn4=noise3((u+129.0)*4.)
,pn5=noise3((u+129.0)*8.)
,pn6=noise3((u+129.0)*16.);
;pf+=.125*pn4+.0625*pn5+.03125*pn6
#endif
;const vec3 cDesert = vec3(1.42, 0.8, 0.4)
,cShore1=vec3(.62,.31,.4)
,cShore2=vec3(1.2,.1,.1)
,cShore3=vec3(1.2,1,1)
,cShore4=vec3(1)//this is an odd color todefine here.
,cGrass1=vec3(.6,.9,.4)*.65
,cGrass2=vec3(.8,.8,.2)*.75
,cMount1=vec3(.6,.55, .65)*.75
,cMount2=vec3(.6,.55,.55)
,cMount3=vec3(1.2,1.2,1.2)
,cOcean =vec3(.1,.0,.4)
,cShore =vec3(.4,.5,.99);

;vec3 cShoreMix1=mix(cShore1,cShore2,upf)*sl
,cShoreMix2=mix(cShore3,cShore4,upf)*sl
,shoreCol = mix(cShoreMix1,cShoreMix2,u5(pn0))
,cGrassMix = mix(cGrass1, cGrass2, pf)
,biomeCol=mix(cGrassMix,cDesert,dm)
,landCol=mix(shoreCol,biomeCol,sat(cm+.5*dm))
;c+=mix(vec3(0),landCol,sat(1.0-abs(m - 1.)))
// Cities in the desert only cisible at night.
;e=mix(vec3(0), vec3(2.0,0.5,1.5)*sat(cn*pf),sat(1.-abs(m-1.)));
;vec3 mountainTopCol=mix(cMount1,cMount3,smoothstep(.7,.8,l));
;vec3 mountainCol=mix(cMount2, mountainTopCol, sat(pow(dot(n, normalize(u)), 12.)));
;c += mix(vec3(0),mountainCol,sat(1.-abs(m-2.)));
//Ocean
;vec3 cSeaMix=mix(cOcean,cShore,smoothstep(.35,.0,w+.05*pf));
;c+=mix(vec3(.0),cSeaMix,float(m==10.))
;return c;
;}

// Function 1717
vec3 box_normal_from_point(vec3 point,vec3 box_extents)
{
    vec3 normal = vec3(0.0);
    float m = FAR;
    float d;

    d = abs(box_extents.x - abs(point.x));
    if (d < m)
    {
        m = d;
        normal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X
    }

    d = abs(box_extents.y - abs(point.y));
    if (d < m)
    {
        m = d;
        normal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y
    }

    d = abs(box_extents.z - abs(point.z));
    if (d < m)
    {
        m = d;
        normal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z
    }

    return normal;
}

// Function 1718
float hCylinder(in vec4 pos, float r)
{
	return length(pos.xyz)-r;   
}

// Function 1719
float SphereIntersect( vec3 p, vec3 origin, float s )
{
  p = Translate(p, origin);
  return length(p)-s;
}

// Function 1720
float roundConeDistance(vec3 point, float radiusA, float radiusB, float height) {
    vec2 q = vec2(length(point.xy), point.z);

    float b = (radiusA - radiusB) / height;
    float a = sqrt(1.0 - b * b);
    float k = dot(q, vec2(-b, a));

    if (k < 0.0) return length(q) - radiusA;
    if (k > a * height) return length(q - vec2(0.0, height)) - radiusB;

    return dot(q, vec2(a, b)) - radiusA;
}

// Function 1721
float intersectSphere(in Ray ray, in Sphere sphere) {
	// Sphere center to ray origin
	vec3 co = ray.origin - sphere.center;

	// The discriminant is negative for a miss, or a postive value
	// used to calcluate the distance
	float discriminant = dot(co, ray.direction) * dot(co, ray.direction)
			- (dot(co, co) - sphere.radius * sphere.radius);

	// If answer is not negative, calculate the origin-surface distance
	if (discriminant >= 0.0)
		return -dot(ray.direction, co) - sqrt(discriminant); //
	else
		return -1.; // Any negative number to indicate no intersect
}

// Function 1722
vec3 sphereNorm( vec3 pt, vec4 s ) {
    return (pt - s.xyz )/ s.w;
}

// Function 1723
vec4 bboxBezierSimple(in vec2 p0, in vec2 p1, in vec2 p2 )
{
    vec2 mi = min(p0,min(p1,p2));
    vec2 ma = max(p0,max(p1,p2));
    
    return vec4( mi, ma );
}

// Function 1724
float cylinder(vec3 p, float c)
{
	return length(p.xz) - c;
}

// Function 1725
float sdZTorus( vec3 p, vec2 t )
{
    vec2 q = vec2(length(p.xy)-t.x,p.z);
    return length(q)-t.y;
}

// Function 1726
float torus(vec4 p) {
  return dot(p.xw,p.xw) - R2;
}

// Function 1727
float sdCappedCylinder( vec3 p, vec2 h, mat3 m  )
{
    p = m * p;
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1728
vec3 Atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {
   
    pSun = normalize(pSun);
    r = normalize(r);

    vec2 p = RSI(r0, r, rAtmos);
    if (p.x > p.y)
        return vec3(0, 0, 0);

    p.y = min(p.y, RSI(r0, r, rPlanet).x);
    float iStepSize = (p.y - p.x) / float(ATMOSPHERE_STEPS_X);

  
    float iTime = 0.0;
    vec3 totalRlh = vec3(0.0);
    vec3 totalMie = vec3(0.0);
 
    float iOdRlh = 0.0;
    float iOdMie = 0.0;

    float mu = dot(r, pSun);
    float mumu = mu * mu;
    float gg = g * g;
    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);
    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));

  
    for (int i = 0; i < ATMOSPHERE_STEPS_X; i++) {
    
        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);
        float iHeight = length(iPos) - rPlanet;

        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;
        float odStepMie = exp(-iHeight / shMie) * iStepSize;

        iOdRlh += odStepRlh;
        iOdMie += odStepMie;
     
        float jStepSize = RSI(iPos, pSun, rAtmos).y / float(ATMOSPHERE_STEPS_Y);

        float jTime = 0.0;     
        float jOdRlh = 0.0;
        float jOdMie = 0.0;
      
        for (int j = 0; j < ATMOSPHERE_STEPS_Y; j++)
        {
            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);
            float jHeight = length(jPos) - rPlanet;           
            jOdRlh += exp(-jHeight / shRlh) * jStepSize;
            jOdMie += exp(-jHeight / shMie) * jStepSize; 
            jTime += jStepSize;
        }

        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));    
        totalRlh += odStepRlh * attn;
        totalMie += odStepMie * attn;    
        iTime += iStepSize;

    }
 
    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);
}

// Function 1729
Intersection intersectPlane(in Ray ray, in Plane plane)
{
    Intersection result;
    result.t = ray.tMax;
    
    float distance = dot(plane.p, plane.n) - dot(ray.o, plane.n);
    float t = distance / dot(ray.d, plane.n);
    
    if (t < ray.tMin || distance > 0.0)
        return result;
    
    result.t = t;
    result.p = ray.o + ray.d * t;
    result.n = plane.n;
    
    return result;
}

// Function 1730
float boxDivide(in vec2 p, in float sc) {
    
    
    //p += vec2(n3D(vec3(p*64., 1.)), n3D(vec3(p*64. + .5, 1.)))*.004 - .002;
    
    p *= .25;    
    p += .5;
    
    
    vec2 oP = p;
    
    vec2 ip = floor(p); p -= ip;
    
    
    vec2 l = vec2(1), lastL;    
    
    float r = hash21(ip);
    
    
    //if(r>.5) p = p.yx;
    
    // Create a box, divide it randomly, then do the same with the 
    // divided portions. Ad infinitum... That's a fancy mathematicians
    // way to say, repeat the process.
    
    for(int i=0; i<5; i++) {
 
        //r = hash21(l + ip)*.4 + (1.-.4)/2.;
        r = fract(dot(l, vec2(123.71, 439.43)) + r)*.4 + (1. - .4)/2.;
        
        lastL = l;
        if(l.x>l.y) { p = p.yx; l = l.yx;  }
         
        if(p.x<r) { l.x /= r; p.x /= r; }
        else { l.x /= (1. - r); p.x = (p.x - r)/(1. - r);  }
        
        if(lastL.x>lastL.y){ p = p.yx; l = l.yx;  }
         
        
    }
    
    // With the subdivided boxed space, you're free to do what you want.
    // I made slightly raised rounded square blocks.
     
    
    // Gap, or morter, width. Keeping it constant.
    float th = .0 + sc*.005;
    
    // Take subdivided space and turn them into rounded pavers.
    p = abs(p - .5);
    float c = dist(p, .5 - th*l);
    
    // Rounded shading.
    float sh = smoothstep(0., .05, (max(-c, 0.)));
    
    //float det = 1. - clamp(-cos(c*6.283*2. + .5)*2. + 1.75, 0., 1.); // Edging.
    //c = max(c, -(c + .03)); // Alternated edging.
    
    c = 1. - smoothstep(0., .1, c); // Rounded pavers.
    
    c *= sh*.9 + .1; // Smoothing them over.
    
    //c *= det*.1 + .95; // Raised edges.

    /*
    // Experiments with rivits. Doesnt' really work here.
    vec2 p2 = abs((p + vec2(-.25, -.25))/l);
    float riv = max(p2.x*.8550254 + p2.y*.5, p2.y) - .005;
    //float riv = length((p + vec2(-.3, -.3))/l) - .02;
    //float riv = length((p + vec2(-.35, -.35))) - .05;
    riv = 2. - smoothstep(0., .01, riv);
    
    //float sh1 = smoothstep(0., .15, (max(-c, 0.)));
    //c = max(c, 2.5 - smoothstep(0., .01, riv))*c;
    //c = mix(riv, c, .5);
    c *= riv;
    */
     
    // Additional surface texturing.
    //float tx = n3D(vec3(oP*64., sh));
    //tx = 1. - mix(tx, abs(abs(tx - .5)*4. - 1.) , .1);
    //c *= (.95 + tx*.1);

    
    return c;
    
}

// Function 1731
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return -1.0;
	return -b - sqrt( h );
}

// Function 1732
vec3 spheremapUnpack(vec2 n) {
    vec4 nn = vec4(2.0 * n - 1.0, 1.0, -1.0);
    float l = dot(nn.xyz,-nn.xyw);
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2.0 + vec3(0.0, 0.0, -1.0);
}

// Function 1733
vec3 spheres(vec3 p)
{
	rp(p, 12.0);
	p.x += 5.0;
	return sphere(p, 0.75);	
}

// Function 1734
float sdRoundedCappedCone( in vec3 p, vec3 hrs, float r )
{
    float h = hrs.x;
    float r1 = hrs.y;
    float r2 = hrs.z;
    
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) ) - r;
}

// Function 1735
void sphereTangents(in vec3 pointOnSphere, out vec3 u, out vec3 v) {
    u = vec3(
        -(1.+pointOnSphere.y*pointOnSphere.y),
        pointOnSphere.x*pointOnSphere.y,
        pointOnSphere.x);
    v = vec3(
        pointOnSphere.x*pointOnSphere.y,
        -(1.+pointOnSphere.x*pointOnSphere.x),
        pointOnSphere.y);
}

// Function 1736
void closestDiskPlane(vec3 cDisk, vec3 nDisk, float rDisk, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {   
    float dt = dot(nDisk,nPlane);
    if (dt == 1.) { // planes are paralleles 
        out0 = cDisk;
    } else {
        vec3 rd = normalize(cross(cross(nPlane,nDisk),nDisk));
        float a = dot(rd, nPlane);
        a = (dot(cDisk,nPlane)-dot(pPlane,nPlane))/a;
        out0 = cDisk - rd * sign(a) * min(abs(a), rDisk); // min if disk cross the plane
    }
    // project solution on plane
    out1 = out0 - nPlane*dot(out0-pPlane,nPlane);
}

// Function 1737
float sdXTorus( vec3 p, vec2 t )
{
    vec2 q = vec2(length(p.yz)-t.x,p.x);
    return length(q)-t.y;
}

// Function 1738
bool hit_sphere(Sphere s, Ray r, float tmin, float tmax, out HitRecord rec)
{
    vec3 oc = r.o - s.center;
    float a = dot(r.d, r.d);
    float b = dot(oc, r.d);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;
    if(discriminant > 0.0)
    {
        float sqrtDiscriminant = sqrt(discriminant);
        float temp = (-b - sqrtDiscriminant) / a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - s.center) / s.radius;
            return true;
        }
        temp = (-b + sqrtDiscriminant) / a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - s.center) / s.radius;
            return true;
        }
    }
    return false;
}

// Function 1739
float fTorus(vec3 p, float smallRadius, float largeRadius) {
    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

// Function 1740
bool closestCapsPlane(vec3 p1Line, vec3 p2Line, float ep, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
    closestSegmentPlane(p1Line, p2Line, pPlane, nPlane, out0, out1);
    return removeThickness(ep, 0., out0, out1);
}

// Function 1741
vec3 randomHemisphereDirection( const vec3 n ) {
	vec3 dr = randomSphereDirection();
	return dot(dr,n) * dr;
}

// Function 1742
Sample s_sphere(vec3 co, float radius) {
    Sample s;
    
    s.d = sphere(co, radius);
    s.color = vec3(1.0, 1.0, 1.0)*0.78;
    s.no = normalize(co);
    
    return s;
}

// Function 1743
vec4 mapLotsOfSpheres( vec3 pos)
{
	vec3 col = vec3(.3, .8, .2 );
	const float radius=6.0;
	float dist = length( mod( pos+15., 30.)-15.) -radius;
	return vec4( col, dist);
}

// Function 1744
vec3 cpPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {
    float t = dot(p - planePoint, nvPlaneN);
    return p - t*nvPlaneN;
}

// Function 1745
float iSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRadius) {
	vec3 oc = ro - sphPos;
	float b = dot(oc, rd);
	float c = dot(oc, oc) - sphRadius * sphRadius;
	float h = b * b - c;

	if (h < 0.0) {
		return -1.0;
	}
	return -b - sqrt(h);
}

// Function 1746
float box(vec3 r, vec3 a)
{
    vec3 p = (abs(r) - a) * 2.0;
	
	p = p * 0.5 + 0.5 * p * rotX(r.y / 3.);
	p = p * 0.5 + 0.5 * p * rotZ(r.y / 3.);
	p.z = clamp(p.x * (sin(p.z)-1.0) + p.x * abs(p.y - a.y) * 0.5, -a.z, a.z);
	p.y = clamp(p.y + p.z * abs(p.x - a.x) * 0.5, -a.y, a.y);
	p.y += p.x * p.z + p.y * sin(p.z * 4.);
	p.x += clamp(p.x * p.y, -a.z * 0.5, a.z * 0.5);
	
    return length(max(p, 0.));
}

// Function 1747
float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
    return dot(p, n) + distanceFromOrigin;
}

// Function 1748
vec4 triUIBox(int idx, float delta) {
    
    return vec4(digitUIBox(idx).xy + vec2(0, 0.9*delta*pqrSize), 
                0.4*pqrSize, 0.3*pqrSize);
    
}

// Function 1749
HessNum3 DE_Torus_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)
{
  HessNum3 x1 = sub(a_sqrt(add(mult(x,x),mult(z,z))),1.5);
                
  
    
  return sub(a_sqrt(add(mult(x1,x1),mult(y,y))),0.4);
 
}

// Function 1750
vec3 randomDirectionHemisphere(vec3 main_direction, float n){
	vec2 perturbation = randomPolar(n);
    vec3 direction = polarToCartesian(perturbation);
    if(abs(main_direction.z) > 0.99999f) return sign(main_direction.z) * direction;
    
    vec3 axis = normalize(cross(UP, main_direction));
    float angle = acos(main_direction.z);
   	
    return rotate(axis, angle, direction);
}

// Function 1751
float sdBox(float p)
{
    return abs(p) - 1.;
}

// Function 1752
float box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1753
vec4 paBox( in vec2 p, 
            in vec2 b, in float r, 
            in float s )
{
    vec2 q = abs(p)-b;
        
    float l = b.x+b.y + 1.570796*r;
    
    float k1 = min(max(q.x,q.y),0.0) + length(max(q,0.0))-r;
    float k2 = ((q.x>0.0)?atan(q.y,q.x):1.570796);
    float k3 = 3.0 + 2.0*msign(min(p.x,-p.y)) - msign(p.x);
    float k4 = msign(p.x*p.y);
    float k5 = r*k2+max(-q.x,0.0);
    
    float ra = s*round(k1/s);
    
	// show local and global parametrization
    ra = (fract((iTime+0.1)/5.0)<0.5)?ra:0.0;
    
    float l2 = l + 1.570796*ra;

    return vec4(k1-ra,
                k3*l2+k4*(b.y+((q.y>0.0)?k5+k2*ra:q.y)),
                4.0*l2,
                k1);
                
}

// Function 1754
float SphereDistance(in vec4 sphere, in vec3 point)
{
    return length(point - sphere.xyz) - sphere.w;
}

// Function 1755
float sphere(vec3 l, vec3 size) {
	vec3 sqf = sqrt(size);
	vec3 m = l/(sqf);
	if (length(m) > 1.0)
	{
		m = normalize(m);
	}
	m *= sqf;
	return length(l-m);
}

// Function 1756
float sdBox( vec3 p, vec3 t,vec3 b )
{
    p-=t;
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1757
double bbox_area(ivec3 bbox_min, ivec3 bbox_max, vec3 fbbox_min, vec3 fbbox_max) {
    double l1 = (double(bbox_max.x) - double(bbox_min.x)) * (fbbox_max.x - fbbox_min.x) / 1023.0;
    double l2 = (double(bbox_max.y) - double(bbox_min.y)) * (fbbox_max.y - fbbox_min.y) / 1023.0;
    double l3 = (double(bbox_max.z) - double(bbox_min.z)) * (fbbox_max.z - fbbox_min.z) / 1023.0;
    return l1*l2 + l2*l3 + l3*l1;
}

// Function 1758
vec3 SphereNormal(in vec3 d, in float r, in float e) {
    float theta = atan(d.y,d.x) ;
    float phy = acos(d.z);
    
    vec3 dy0 = vec3(cos(theta+e)*sin(phy), sin(theta+e)*sin(phy), cos(phy));
    vec3 dy1 = vec3(cos(theta-e)*sin(phy), sin(theta-e)*sin(phy), cos(phy));

    vec3 dx0 = vec3(cos(theta)*sin(phy+e), sin(theta)*sin(phy+e), cos(phy+e));
    vec3 dx1 = vec3(cos(theta)*sin(phy-e), sin(theta)*sin(phy-e), cos(phy-e));
    
    float ny0 = noise(dy0*r);
    float ny1 = noise(dy1*r);
    float nx0 = noise(dx0*r);
    float nx1 = noise(dx1*r);
    
    dy0 *= r + ny0;
    dy1 *= r + ny1;
    dx0 *= r + nx0;
    dx1 *= r + nx1;
    
    return normalize(cross(dy0 - dy1, dx1 - dx0));
}

// Function 1759
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;
}

// Function 1760
float plane(vec3 r, vec3 o, vec3 n) {
    return dot(r - o, n);
}

// Function 1761
float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 1762
float planet_surface(vec3 p,float grass_scale){
    vec3 p1 = p/5.0/size;
    return length((sin(p1.yzx/vec3(length(sin(p1/grass_scale)))))*size) - size*1.5;
}

// Function 1763
float
capped_cylindermh_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;
    return min( max(d), 0.0 ) + manhattan( max(d, 0.0) );
}

// Function 1764
SFHit	SphereFlakeIntersectStack( in vec3 ro, in vec3 rd )
{
    SFHit	hit;
    hit.dist	= -1.0;
    hit.resMin	= -1.0;
    hit.resMax	= 1000.0;

    int	idx	= 1;
// Get current element on the stack.
#define	SFEL g_stack[ idx ] 
// Get parent element on the stack
#define	SFPEL g_stack[ idx - 1 ]
// Get parent's parent element on the stack
#define	SFPPEL g_stack[ idx - 2 ]
// Do sphere intersect call on the current element on the stack.
#define SFIntersect sphIntersect( ro, rd, SFEL.center, SFEL.radius, hit )
// Do sphere intersect test call on the current element on the stack.
#define SFIntersectTest sphIntersectTest( ro, rd, SFEL.center, SFEL.radius )
// Check if current element on the stack has a small radius.
#define SFIsRadTooSmall isRadTooSmall( ro, SFEL.center, SFEL.radius )

    if( ! SFIntersectTest )
        return	hit;

    SFIntersect;

    idx = 2;
    while( idx > 1 )
    {
        if( SFEL.sphereIndex == TOTAL_SPHERES_COUNT )
        {
            SFEL.sphereIndex	= 0;
            idx--;
            continue;
        }

        int		sphIdx	= SFEL.sphereIndex;
        vec3	parDir	= SFPEL.direction;
        
        vec3	perp1	= normalize( cross( parDir, SFPPEL.direction ) );
        vec3	perp2	= normalize( cross( parDir, perp1 ) );

        vec3	rot		= perp1 * PERP1MOD( sphIdx ) 
            			+ perp2 * PERP2MOD( sphIdx );

        vec3	dirNN	= parDir * YAXIS_COS( sphIdx ) + rot;
        
        SFEL.direction	= normalize( dirNN );
        SFEL.center		= SFEL.direction * ( SFEL.radius + SFPEL.radius ) 
            			+ SFPEL.center;

        SFEL.sphereIndex++;
        
        if( SFIsRadTooSmall || ! SFIntersectTest )
            continue;

        SFIntersect;

        if( idx == STACK_MAX_SIZE )
            continue;

		idx++;
    }
    
    return	hit;
}

// Function 1765
float box(in vec3 p, vec3 b)
{
    vec3 d = abs(p) - b*.5;
  	return min(max(d.x,max(d.y,d.z)),0.0) +
		length(max(d,0.));
}

// Function 1766
float sphereSDF(vec3 p, float radius) { return length(p) - radius; }

// Function 1767
float SDPlane(vec3 p, vec4 n)
{
    return dot(p, n.xyz) + n.w;
}

// Function 1768
float sdSphere( vec3 p, vec3 cen, float rad)
{
    

    return length(p-cen)-rad;
    
}

// Function 1769
float udBox( in vec3 p, in vec3 b)
{
	return length( max( abs( p ) - b, 0.0 ) );
}

// Function 1770
f1 sdRoundedCylinder( f3 p, f1 ra, f1 rb, f1 h )
{
  f2 d = f2( LN(p.xz)-2.*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.) + LN(max(d,0.)) - rb;
}

// Function 1771
float sdBox(vec2 p, vec2 pos, vec2 e) {
	vec2 d = abs(p-pos)-e;
    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));
}

// Function 1772
float sdBox( vec2 p, vec2 t, vec2 b )
{
    p-=t;
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 1773
RaycastHit intersectSphere(vec3 position, float radius, const Ray ray) {
    
	float a = dot(ray.direction, ray.direction);
    float b = 2. * dot(ray.direction, ray.origin - position);
    float c = dot(ray.origin - position, ray.origin - position) -(radius * radius);
    float det = (b * b) - 4. * a * c;

	float lambda = (-b -sqrt(det)) / (2. * a);
	vec3 p = ray.origin + lambda * ray.direction;
	vec3 n = p - position;
    
    RaycastHit hit;
    hit.point = p;
    hit.normal = normalize(n);
    hit.det = det;
    hit.type = (det >= 0. && lambda >= 0.) ? 0 : -1;
    //hit.type = det >= 0. ? 0 : -1;
    
    return hit;
        
}

// Function 1774
float distBox( vec3 p, vec3 b )
{
  	return length(max(abs(p)-b,0.0));
}

// Function 1775
vec3 nSphere(in vec3 pos, in vec4 sph ) {
	return normalize((pos - sph.xyz)/sph.w);
}

// Function 1776
Intersection rayPlaneIntersection(in Ray ray, in Plane plane)
{
	Intersection i;
	i.hit = false;
	
	float dotProduct = dot(ray.direction, plane.normal);
	if (dotProduct == 0.0)
	{
		return i;
	}
	
	float distanceToHit = dot(plane.point - ray.origin, plane.normal)/dotProduct;
	if (distanceToHit < 0.0)
	{
		return i;
	}
	i.position = ray.origin + (ray.direction * distanceToHit);
	i.normal = plane.normal;
	i.material = plane.material;
	i.hit = true;
	return i;
}

// Function 1777
vec2 sphere_trace( Ray ray, float radius, vec3 center )
{
	vec3 O = ray.o;
	vec3 d = ray.d;
	float tp = dot( center - O, d ); // O + d * tp = center projected on line (O,d)
	float h_sqr = lensqr( ( O + d * tp ) - center );
	float radius_sqr = radius * radius;
	if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere
	float dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)
	return vec2( tp - dt, tp + dt ); // record 2 hits In, If
}

// Function 1778
float cylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1779
vec4 tracePlaneDepth(vec3 ray_origin, vec3 ray_dir, mat3 o, vec2 size, float max_depth, vec3 depth_filter, bool height, bool quad, out vec2 point_quad)
{
	// calculate inverse model map
	mat3 io = inverse(o);

	// calculate ray in model space
	vec3 ray_origin_model = io * ray_origin;
	vec3 ray_dir_model = io * ray_dir;

	// calculate plane coordinates of ray
	vec2 ray_origin_plane = ray_origin_model.xy;
	vec2 ray_dir_plane = ray_dir_model.xy;
	ivec2 ray_origin_plane_square = square(ray_origin_plane, size);

	// calculate ray distance to plane
	float ray_distance_shallow, ray_distance_deep;
	if(height)
	{
		ray_distance_shallow = -(ray_origin_model.z-max_depth) / ray_dir_model.z;
		ray_distance_deep = -ray_origin_model.z / ray_dir_model.z;
	}
	else {
		ray_distance_shallow = -ray_origin_model.z / ray_dir_model.z;
		ray_distance_deep = -(ray_origin_model.z+max_depth) / ray_dir_model.z;
	}

	// calculate plane coordinates of intersection
	vec2 point_plane_shallow = ray_origin_model.xy + ray_dir_model.xy * ray_distance_shallow;
	ivec2 point_plane_shallow_square = square(point_plane_shallow, size);
	vec2 point_plane_deep = ray_origin_model.xy + ray_dir_model.xy * ray_distance_deep;
	ivec2 point_plane_deep_square = square(point_plane_deep, size);

	// calculate quad coordinates of intersection
	vec2 point_quad_shallow = point_plane_shallow / size;
	if(quad) point_quad_shallow = fract(point_quad_shallow);
	vec2 point_quad_deep = point_plane_deep / size;
	if(quad) point_quad_deep = fract(point_quad_deep);

	float step_size = max_depth / 1., ray_step_size = (ray_distance_deep - ray_distance_shallow) * step_size / max_depth;
	float depth_estimate_shallow = 0., depth_estimate_deep = step_size;
	ray_distance_deep = ray_distance_shallow + ray_step_size;
	float depth_shallow, depth_deep;
	if(!quad || all(equal(point_plane_shallow_square, ivec2(0)))) {
			depth_shallow = max_depth * (1. - dot(texture(iChannel0, point_quad).rgb, depth_filter));
	}
	else if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_shallow = 0.;
	else if(ray_origin_plane_square.x == point_plane_shallow_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_shallow_square.y && ray_origin_plane_square.y != 0) depth_shallow = 1.;
	else depth_shallow = 0.;
	if(!quad || all(equal(point_plane_deep_square, ivec2(0)))) {
		depth_deep = max_depth * (1. - dot(texture(iChannel0, point_quad_deep).rgb, depth_filter));
	}
	else if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_deep = 0.;
	else if(ray_origin_plane_square.x == point_plane_deep_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_deep_square.y && ray_origin_plane_square.y != 0) depth_deep = 1.;
	else depth_deep = 0.;
	while(depth_deep > depth_estimate_deep && depth_deep < max_depth)
	{
		depth_estimate_shallow = depth_estimate_deep;
		ray_distance_shallow = ray_distance_deep;
		point_plane_shallow = point_plane_deep;
		point_plane_shallow_square = point_plane_deep_square;
		point_quad_shallow = point_quad_deep;
		depth_shallow = depth_deep;
		depth_estimate_deep += step_size;
		ray_distance_deep += ray_step_size;
		point_plane_deep = ray_origin_model.xy + ray_dir_model.xy * ray_distance_deep;
		point_plane_deep_square = square(point_plane_deep, size);
		point_quad_deep = point_plane_deep / size;
		if(quad) point_quad_deep = fract(point_quad_deep);
		if(!quad || all(equal(point_plane_deep_square, ivec2(0)))) {
			depth_deep = max_depth * (1. - dot(texture(iChannel0, point_quad_deep).rgb, depth_filter));
		}
		else if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_deep = 0.;
		else if(ray_origin_plane_square.x == point_plane_deep_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_deep_square.y && ray_origin_plane_square.y != 0) depth_deep = 1.;
		else depth_deep = 0.;
	}
	int i = 0;
	const int steps = 7;
	while(i < steps)
	{
		float depth_estimate_mid = (depth_estimate_shallow + depth_estimate_deep) * .5;
		float ray_distance_mid = (ray_distance_shallow + ray_distance_deep) * .5;
		vec2 point_plane_mid = ray_origin_model.xy + ray_dir_model.xy * ray_distance_mid;
		ivec2 point_plane_mid_square = square(point_plane_mid, size);
		vec2 point_quad_mid = point_plane_mid / size;
		if(quad) point_quad_mid = fract(point_quad_mid);
		float depth_mid;
		if(!quad || all(equal(point_plane_mid_square, ivec2(0)))) {
			depth_mid = max_depth * (1. - dot(texture(iChannel0, point_quad_mid).rgb, depth_filter));
		}
		else if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_mid = 0.;
		else if(ray_origin_plane_square.x == point_plane_mid_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_mid_square.y && ray_origin_plane_square.y != 0) depth_mid = 1.;
		else depth_mid = 0.;
		if(depth_mid > depth_estimate_mid)
		{
			depth_estimate_shallow = depth_estimate_mid;
			ray_distance_shallow = ray_distance_mid;
			point_plane_shallow = point_plane_mid;
			point_plane_shallow_square = point_plane_mid_square;
			point_quad_shallow = point_quad_mid;
			depth_shallow = depth_mid;
		}
		else
		{
			depth_estimate_deep = depth_estimate_mid;
			ray_distance_deep = ray_distance_mid;
			point_plane_deep = point_plane_mid;
			point_plane_deep_square = point_plane_mid_square;
			point_quad_deep = point_quad_mid;
			depth_deep = depth_mid;
		}
		i++;
	}

  bool shallow_in = all(lessThanEqual(point_plane_shallow, size)) && all(greaterThanEqual(point_plane_shallow, vec2(0.)));
  bool deep_in = all(lessThanEqual(point_plane_deep, size)) && all(greaterThanEqual(point_plane_deep, vec2(0.)));
  if(ray_distance_shallow > 0. && ray_distance_deep > 0. && (shallow_in && deep_in || !quad))
	{
    float error_shallow = depth_shallow - depth_estimate_shallow;
    float error_deep = depth_deep - depth_estimate_deep;
		float ray_distance = (ray_distance_shallow*error_deep-ray_distance_deep*error_shallow)/(error_deep-error_shallow);
		vec2 point_plane = ray_origin_model.xy + ray_dir_model.xy * ray_distance;
		point_quad = point_plane / size;
		if(quad) point_quad = fract(point_quad);
		float depth = max_depth * (1. - dot(texture(iChannel0, point_quad).rgb, depth_filter));
		return vec4(point_quad,-depth,1.);
	}
	return vec4(0.);
}

// Function 1780
float cone(vec3 p,vec3 po,vec3 n,float dr){
    n=normalize(n);
    vec3 dp=po-p;
    vec3 prj_dp=dot(n,dp)*n;
    float r=length(prj_dp)*dr;
    vec3 d=dp-prj_dp;
    return length(d)-r;
}

// Function 1781
void boxfold_pln(inout vec2 p, float bi)
{
    if (abs(p.x)>bi) p.x = 2.*sign(p.x)*bi-p.x;
    if (abs(p.y)>bi) p.y = 2.*sign(p.y)*bi-p.y;
}

// Function 1782
float cylinder( vec3 p, float r, float height ) 
{
    float d = length( p.xz ) - r;
    d = max( d, abs( p.y ) - height );
    return d;
}

// Function 1783
float sdTorus(float dt, vec3 p, vec2 t)
{
    return sdTorus(p,cos(sin(3.*dt))*t);
}

// Function 1784
float sdPlane( vec3 p, vec4 n )
{
    return dot(p,n.xyz) + n.w;
}

// Function 1785
bool RaySphereIntersection(Ray r, Sphere s, out HitInfo hitInfo)
{
	vec3 k = r.pos - s.pos;
    float b = dot(k, r.dir);
	float c = dot(k, k) - s.radius * s.radius;
	float d = b * b - c;
	 
	if(d < 0.0)
	{
		return false;
	}
		
	float sqrtfd = sqrt(d);

	float t1 = -b + sqrtfd;
	float t2 = -b - sqrtfd;

	float minT = min(t1,t2);
	float maxT = max(t1,t2);

	float t = (minT >= 0.0) ? minT : maxT;

	hitInfo.t = t;
	hitInfo.pos = PointFromRay(r, t);
	hitInfo.normal = (c < 0.0 ? -1.0 : 1.0) * normalize(hitInfo.pos - s.pos);
	hitInfo.mat = s.mat;
	
	return (t > 0.0);
}

// Function 1786
Result sphereIntersect (in Ray ray, in vec3 p, in float r, in int id) {
    Result res = nullResult;

    float a = dot (ray.rd, ray.rd);

    // exit early, if denominator would almost be zero 
    if (a <= 1e-6) {
        return res;
    }

    // set up coefficients a, b and c
    float b = dot (2. * ray.rd, ray.ro - p);
    vec3 op = ray.ro - p;
    float c = dot (op, op) - r * r;
    float d = sqrt (b * b - 4. * a * c);
    float twoA = 1. / 2.*a;

    // compute possible values for t
    float t1 = (-b + d) * twoA;
    float t2 = (-b - d) * twoA;

    // this case should not be possible 
    if (t1 <= .0 && t2 <= .0) {
		return res;
    }

    if (t1 > .0 && t2 > .0) {
        if (t1 < t2) {
            vec3 i1 = ray.ro + t1 * ray.rd;
            float d1 = distance (i1, ray.ro);
            res.hit = true;
            res.point = i1;
            res.normal = normalize (i1 - p);
            res.dist = d1;
            res.id = id;
        } else {
            vec3 i2 = ray.ro + t2 * ray.rd;
            float d2 = distance (i2, ray.ro);
            res.hit = true;
            res.point = i2;
            res.normal = normalize (i2 - p);
            res.dist = d2;
            res.id = id;
        }
    }

    return res;
}

// Function 1787
float sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1788
float fibspheren(vec3 p, float n, out float minidx, out vec3 sn)
{
    // get spherical coords for point p on surface of unit sphere
    vec2 sp = c2s(p);
    float avdist = sqrt(4.0 * pi / n);
    
    // calc the dominant zone number
    float k = max(2.0, floor(log(root5 * n * pi * (1.0 - sp.y * sp.y)) / logPhiPlusOne));   
    
    // calc basis vectors for this zone
    // [could all be precalculated and looked up for k,n]
    vec2 f = vec2(calcfk(k), calcfk(k + 1.0));
    vec2 bk = calcbk(f[0], n);
    vec2 bk1 = calcbk(f[1], n);
    mat2 b = mat2(bk, bk1);
    mat2 invb = inverse(b);
    
    // change of basis for point sp to local grid uv
    float z0 = 1.0 - 1.0 / n;
    vec2 c = floor(invb * (sp - vec2(0.0, z0)));
    
    // for k<=4 paper suggests using (-1,0,+1)^2 offset factors but we'll
    // stick with (0,1)^2 and live with the occasional glitches
    float mindist = pi;
    vec2 minisp;
    for (int s = 0; s < 4; s++) {
        // figure out the point index and generate fib point
        vec2 o = vec2(s - (s/2) * 2, s / 2);
        float idx = dot(f, c + o);
        if (idx > n) continue;        
        vec2 isp = calcpoint(idx, n);
        
        // walk on a random bearing a random distance to make cells move a bit
        //float b = mod((-0.05 + 0.1 * random(idx + 42.39)) * iTime, twoPi);
        //float d = dist * random(idx + 28.93) * cos((-0.5 + 1.0 * random(idx + 42.39)) * iTime);
        //isp = gcircle(isp, b, d);
        
        // closest?
        float dist = angdist(isp, sp);
        if (dist < mindist) {
			mindist = dist;
            minidx = idx;
            minisp = isp;
        }
    }
    
    // use nearest point to calculate surface normal via rotation around cotangent from p -> ip
    // ohhhh wow I can make keeled scales real easy if dist varies by direction!
    vec3 ip = s2c(minisp), cotan;
    if (convex) {
        cotan = cross(ip - p, p);
    } else {
        cotan = cross(p - ip, p);
    }
    sn = rotate(p, cotan, mindist / avdist);
    return mindist;
}

// Function 1789
void UI_DrawCheckbox( inout UIContext uiContext, bool bActive, bool bMouseOver, bool bChecked, Rect checkBoxRect )
{
	if (!uiContext.bPixelInView || Outside( uiContext.vPixelCanvasPos, checkBoxRect ))
        return;
    
    uiContext.vWindowOutColor = vec4(1.0);
    
    if ( bActive && bMouseOver )
    {
        uiContext.vWindowOutColor = vec4(0.85,0.85,0.85,1.0);
    }

#ifdef NEW_THEME
    DrawBorderRect( uiContext.vPixelCanvasPos, checkBoxRect, cCheckboxOutline, uiContext.vWindowOutColor );
#else    
    DrawBorderIndent( uiContext.vPixelCanvasPos, checkBoxRect, uiContext.vWindowOutColor );
#endif    

    Rect smallerRect = checkBoxRect;
    RectShrink( smallerRect, vec2(6.0));

    if ( bChecked )
    {
        vec4 vCheckColor = vec4(0.0, 0.0, 0.0, 1.0);
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.0, 0.75), smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), 2.0f, vCheckColor, uiContext.vWindowOutColor );
        DrawLine( uiContext.vPixelCanvasPos, smallerRect.vPos+ smallerRect.vSize * vec2(0.25, 1.0), smallerRect.vPos+ smallerRect.vSize * vec2(1.0, 0.25), 2.0f, vCheckColor, uiContext.vWindowOutColor );
    }
}

// Function 1790
Intersection RayPlane(Ray ray, Plane p)
{
	Intersection i;
	float num = p.d-dot(p.n, ray.o);
	float denom = dot(p.n, ray.dir);
	float t = num/denom;
	if(t > EPSILON)
	{
		i.p = ray.o + ray.dir * t;
		// hit rectangle?
		if ( i.p.x < -8.0 || i.p.x > 8.0 || i.p.z < 4.0 || i.p.z > 24.0 ) {
			// missed
			i.dist = ZMAX;
		} else {
			i.n = p.n;
			i.dist = t;
		}
	}
	else
	{
		// did not hit plane
		i.dist = ZMAX;
	}
	return i;
}

// Function 1791
void TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)
{
    float dist = SphereDistance(sphere, rayPos);
    if (dist < info.dist)
    {
        info.objectPass = OBJECTPASS_RAYMARCH;
        info.dist = dist;        
        info.normal = normalize(rayPos - sphere.xyz);
        info.material = material;
    }    
}

// Function 1792
float sphereSDF(vec3 p)
{
    return length(p) - 0.25;
}

// Function 1793
float sphere(vec4 s,vec3 p)
{
   return length(p-s.xyz)-s.w;
}

// Function 1794
vec3 closestPointToSphere( vec3 p, vec3 cen, float rad )
{
    return cen + rad*normalize(p-cen);
}

// Function 1795
vec2 sdPlane(vec3 p, vec4 n, float id)
{
  // n must be normalized
  return vec2(dot(p,n.xyz) + n.w, id);
}

// Function 1796
poly2 cone(poly2 x, poly2 y, poly2 z, vec2 a, float l) {
    return pa_max(
        pa_add(pa_mul(pa_add(pa_pow2(x),pa_pow2(y)),a.x),
               pa_mul(a.y, z)),z);
}

// Function 1797
float box(vec3 p, vec3 d) {
    vec3 q = abs(p) - d;
    return max(q.x, max(q.y, q.z));
}

// Function 1798
vec2 intersect_plane2_nx( Ray ray, float px, float nx )
{
	float epsilon = 1e-4;
	float vdotn = ray.d.x * nx;
	float d = ( ray.o.x - px ) * nx;
	float t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );
	return vec2( t, d );
}

// Function 1799
float iPlane( in vec3 ro, in vec3 rd, in vec4 pla )
{
    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );
}

// Function 1800
float box_size(vec2 st, float n) {
    st = (floor(st * n) + 0.5) / n;
    float offs = rand(st) * 5.;
    return (1. + sin(TIME * 3. + offs)) * 0.5;
}

// Function 1801
float sdHeartCylinder(vec3 p)
{
    p = abs(p);
	if (p.y<p.x) {p.xy = p.yx;}
	if (p.y<p.z) {p.yz = p.zy;}
    float c = sdRoundedCylinder( p, 0.2, 0.02, 0.95 );
    return c;
}

// Function 1802
vec3 sphereLookUp( vec3 dir ) {
    // a "hdri" for for water reflection lookup
    //vertical fade
    vec3 horizon_col = vec3(0.8, 0.8, 0.9);
    vec3 up_col = vec3(0.0, 0.12, 0.9);
    float ver_mix = dot( dir, vec3(0.0, 1.0, 0.0) ) * 2.0;
    vec3 vert_fade = mix( horizon_col, up_col, ver_mix );
    
    //sun spot
	float sun_ang = dot( dir, SUN_DIR );
    float sun_int = smoothstep( 0.7, 1.0, sun_ang ); 
    vec3 sun_spot = SUN_COL * sun_int * 2.0;
    float sun_int_inner = smoothstep( 0.95, 1.0, sun_ang );
    vec3 sun_spot_inner = SUN_COL * sun_int * 4.0;
    
	return vert_fade + sun_spot;
}

// Function 1803
float pdfUniformHemisphere()
{
    // p(omega) = C
    // I[0,2pi][0,pi/2]{C*sin(theta)d(theta)d(phi)} = 1
    // C = 1/(2pi)
 	return 1.0/PI2;   
}

// Function 1804
float deTorusKnot(in vec3 p)
{     
    float a = atan(p.z, p.x);
    p.xz *= rotate(a);
    p.x -= 1.0;
    p.xy *= rotate(a * 2.5);
    p.x = abs(p.x) - 0.3;
	return length(p.xy) - 0.2;
}

// Function 1805
float MBoxDf (vec3 p)
{
  vec4 q, q0;
  const int nIter = 12;
  q0 = vec4 (p, 1.);
  q = q0;
  for (int n = 0; n < nIter; n ++) {
    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;
    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;
  }
  return length (q.xyz) / abs (q.w);
}

// Function 1806
float sdPlane(vec3 p, float height)
{
   	return p.y - height;
}

// Function 1807
void backbox(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi, vec3 pos, vec3 size) {
  
  vec3 invd = 1.0/r;
  
  vec3 t0 = ((pos-size) - s) * invd;
  vec3 t1 = ((pos+size) - s) * invd;
  vec3 mi = min(t0, t1);
  vec3 ma = max(t0, t1);
  
  float front = min(min(ma.x,ma.y),ma.z);
  float back = max(max(mi.x,mi.y),mi.z);
  
  if(front<d && front > 0.0 && front>back) {
    d = front;
    n = (1.0-clamp((ma-front)*1000.0,0.0,1.0)) * sign(t1-t0);
    
    vec3 p = s + d * r;
    //vec2 diff=smoothstep(0.9,1.0, sin(p.zx + 10 * time * vec2(0.7,1.0)));
    
    //emi = vec3(dot(diff,vec2(1.0))) * step(p.y, -4.9) * 4;
    
    emi = vec3(0.4,0.5,0.9) * step(p.y, -4.9) * 4.0 * val * (1.0-val2);
    emi += vec3(0.8,0.4,0.3) * step(p.z, -9.9) * 4.0 * (1.0-val) * (1.0-val2);
  }
}

// Function 1808
float sdCylinderYZ( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.yz),p.x)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1809
bool sphere_hit(const in Sphere sphere, const in Ray inray, float t_min, float t_max, inout Hit rec) {
    vec3 oc = inray.origin - sphere.origin;
    float a = dot(inray.direction, inray.direction);
    float b = dot(oc, inray.direction);
    float c = dot(oc, oc) - sphere.rad*sphere.rad;
    float discriminant = b*b - a*c;
    if (discriminant > 0.) {
        float temp = (-b - sqrt(discriminant))/a;
        if (temp < t_max && temp > t_min) {
            rec.dist = temp;
            vec3 p = inray.origin + inray.direction * rec.dist;
            rec.normal = (p - sphere.origin) / sphere.rad;
            return true;
        }
    }
    return false;
}

// Function 1810
float sdHalfCylinder(vec3 pos , vec3 h){
    float cy=opS(
        sdCylinder(pos.yzx,h.xy),
        sdCylinder(pos.yzx,h.xy + vec2(0.03,-0.03))
    );
    float bx = sdBox(pos-vec3(0.,-h.x*h.z*2.,0.),vec3(h.x+0.3,h.x,h.y+0.3));
    return opS(bx,cy);
}

// Function 1811
float box( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 1812
bool hit_sphere(Sphere s, Ray r, float tmin, float tmax, inout HitRecord rec)
{
    vec3 oc = r.o - s.center;
    float a = dot(r.d, r.d);
    float b = dot(oc, r.d);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;
    if(discriminant > 0.0)
    {
        float sqrtDiscriminant = sqrt(discriminant);
        float t1 = (-b - sqrtDiscriminant) / a;        
        float t2 = (-b + sqrtDiscriminant) / a;     
        
        float first = min(t1,t2);
        float second = max(t1,t2);   
        
        if(first < tmax && first > tmin)
        {
            rec.t = first;
            rec.t2 = second;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - s.center) / s.radius;
            return true;
        }
        
        if(second < tmax && second > tmin)
        {
            rec.t = second;
            rec.t2 = first;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - s.center) / s.radius;
            return true;
        }
    }
    return false;
}

// Function 1813
float PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) 
{ 
    float t = -1.0f;
    normal = planeNormal;
    float denom = dot(-planeNormal, rayDirection); 
    if (denom > EPSILON) { 
        vec3 rayToPlane = planeOrigin - rayOrigin; 
        return dot(rayToPlane, -planeNormal) / denom; 
    } 
 
    return t; 
}

// Function 1814
float sphereDistance(vec3 rayPosition, vec3 spherePosition, float sphereRadius)
{
    float d = length(rayPosition - spherePosition) - sphereRadius;
    return d;
}

// Function 1815
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 1816
vec4 Cone(vec3 p, vec3 d, float CR, float Start) {
    vec4 Light=vec4(0.);
    vec3 sp; float t=Start;
    float sD,Lod; vec4 sC;
    for (int i=0; i<58; i++) {
        sp=p+d*t;
        sD=max(1.,t*CR); Lod=log2(sD);
        sC=VoxelFetch(sp,Lod);
        Light+=sC*(1.-Light.w);
        t+=sD;
    }
    return Light+vec4(vec3(0.1,0.3,0.5)*((d.y*0.5+0.5)*(1.-Light.w))*0.5,0.);
}

// Function 1817
vec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {
    vec2 r = vec2(Xi1,Xi2)*TWO_PI;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dot(dr,n) * dr;
}

// Function 1818
bool intersectSphere(Sphere s,vec3 p, vec3 dir,out Hit h)
{

	vec3 oc = p - s.center;

	float loc = dot(dir,oc);

	float discr = loc*loc - dot(oc,oc) + s.r*s.r;

	if(discr < 0.)
		return false;

    float t;
	if(abs(discr) < 0.00001)
	{
		t = -loc;
        
	}
	else{
		float sq = sqrt(discr);
		t = -loc - sq;
        // if inside use outgoing one
        t = t < 0. ? -loc + sq : t;
        
	}
	
    h = Hit(computeNormalSphere(p+t*dir,s),t);
	
    return t >= 0.;

}

// Function 1819
float sdTorus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 1820
vec3 distribSphere(vec2 uv)
{
    uv = fract(uv);
    uv.y = uv.y * 2. - 1.;
    return vec3(sqrt(max(0., 1. - uv.y*uv.y))
                * sin(vec2(.5*pi, 0) + uv.x * 2.*pi)
                , uv.y);
}

// Function 1821
float Cylinder(in vec3 p, in float r, in float h) 
{
    return max(length(p.xz) - r, abs(p.y) - h);
}

// Function 1822
float raySphereIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {
    
    float a = dot(rayDirection, rayDirection);
    vec3 d = rayOrigin - sphereCenter;
    float b = 2.0 * dot(rayDirection, d);
    float c = dot(d, d) - (sphereRadius * sphereRadius);
    if (b*b - 4.0*a*c < 0.0) {
        return -1.0;
    }
    return (-b + sqrt((b*b) - 4.0*a*c))/(2.0*a);
    
}

// Function 1823
float udBox( vec3 p, vec3 b ) {
        return length( max( abs(p) - b, 0.0 ) );
    }

// Function 1824
float plane(const in vec4 n, const in vec3 p) {
    return dot(p, n.xyz) - n.w;
}

// Function 1825
d2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);;}

// Function 1826
void m4_sphere(inout ray r, rObj o) {
    vec3 nml = normalize(r.pos - o.pos);
    r.pos += nml * EPSILON * 2.;
    r.dir = reflect(r.dir, hashRot(nml, 0.15));
    r.col *= vec3(0.89, 0.89, 0.99);
}

// Function 1827
float hitSphere(Sphere inSp, Ray r) {
    vec3 oc = r.o - inSp.center;
    float a = dot(r.d, r.d);
    float b = 2.0 * dot(oc, r.d);
    float c = dot(oc,oc) - inSp.radius*inSp.radius;
    float discriminant = b*b - 4.0*a*c;
    if (discriminant < 0.0) {
        return -1.0;}
    else {
        return (-b - sqrt(discriminant)) / (2.0 * a);
    }
}

// Function 1828
float box(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1829
float sphereSDF(vec3 p, vec3 center, float radius) {
    return length(p - center) - radius;
    // <=>
    //return (length((p - center)/radius) - 1.0)*radius;
}

// Function 1830
vec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {

    asteroidTransForm( ori, id );
    asteroidTransForm( dir, id );
    
    vec2 td = vec2(0.0);
    for(int i = 0; i < ASTEROID_NUM_STEPS; i++) {
        vec3 p = ori + dir * td.x;
        td.y = map(p, id);
        if(td.y < ASTEROID_TRESHOLD) break;
        td.x += (td.y-ASTEROID_TRESHOLD) * 0.9;
    }
    return td;
}

// Function 1831
vec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){
    
    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );
    
    //could also just write color = normalOfSurce
    //but trying to be explicit.
    
	return color;
}

// Function 1832
float sdRoundedCylinder(vec3 p, float ra, float rb, float h) {
    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);
    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;
}

// Function 1833
float PrRound4Box2Df (vec2 p, vec2 b, float r)
{
  return Length4 (max (abs (p) - b, 0.)) - r;
}

// Function 1834
float sdBox( vec3 p, vec3 b )
{
  vec3  di = abs(p) - b;
  float mc = maxcomp(di);
  return min(mc,length(max(di,0.0)));
}

// Function 1835
bool iPlane( in vec3 ro, in vec3 rd,
              in vec3 planeNormal, in float planeDist, out vec3 p0) {
    float a = dot(rd, planeNormal);
    float d = -(dot(ro, planeNormal)+planeDist)/a;
    p0 = ro+d*rd;
    if (a > 0.) {
        return false;
    } else {
    	return true;
    }
}

// Function 1836
vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)
{   
    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);
    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));
    vec3 vaxis = normalize(cross(plane.xyz, uaxis));
    vec3 collisionPos = rayPos + rayDir * collisionTime;
    uv.x = dot(collisionPos, uaxis);
    uv.y = dot(collisionPos, vaxis);    
    return vec4(collisionTime, plane.xyz);
}

// Function 1837
float sphereLeveled(vec3 ray,vec3 pos,float r)
{
    float level=1.;
  	float b = dot(ray,pos);
  	float c = dot(pos,pos) - b*b;
	float rq=r*r;
    float s=0.0;
    if(c <rq) {
        int z=0;
        float l1=sqrt(r-c);
        vec3 r1= ray*(b-l1)-pos;
        vec3 r2=abs(r1);
        float m=max(max(r2.x,r2.y),r2.z);
        vec3 r3=r1/abs(m);
        vec3 p;
        if ((r2.y<=r2.z) || (r2.y<=r2.x)) {
			p.x=r3.x;
			if (r3.z<0.) z=2;
			if (r3.z>0.) z=0;
			if (r2.x>r2.z) {
				p.x=r3.z;
				if (r3.x>0.) z=1;
				if (r3.x<0.) z=3;
			}
			p.y=r3.y;
        } else {
			p.x=r3.x;
			p.y=r3.z;
			if (r3.y>0.) z=4;
			if (r3.y<0.) z=5;
        }
        //vec2 si=vec2(1.0);
        //if (p.x<0.0) si.x=-si.x;
        //if (p.y<0.0) si.y=-si.y;
        //p.xy=abs(p.xy);
        //p.x=pow(p.x,0.9);
        //p.y=pow(p.y,0.9);
        //p.xy*=si;
        
        float l=0.8;//max(0.1,abs(dot(ray,normalize(r1))));
        //l=min(l,0.9);
               
        float d=16.0;
        vec2 rs;        
        
        //for (float i=0.0;(i<17.0);i+=1.0) {
        	vec3 rp=p;
        
        	//vec3 posp;
			//if (rp.z==0.) posp=vec3(rp.x-0.5,rp.y-0.5,0.5);
			//if (rp.z==1.) posp=vec3(0.5,rp.y-0.5,0.5-rp.x);
			//if (rp.z==2.) posp=vec3(0.5-rp.x,rp.y-0.5,-0.5);
			//if (rp.z==3.) posp=vec3(-0.5,rp.y-0.5,rp.x-0.5);
			//if (rp.z==4.) posp=vec3(rp.x-0.5,0.5,0.5-rp.y);
			//if (rp.z==5.) posp=vec3(0.5-rp.x,-0.5,0.5-rp.y);
        	//posp=normalize(posp);

        	d=max(0.0,log(iResolution.y*0.04/length(pos+r1))*1.4); //1.6609640474436811 3.321928094887362347870
        	level=d-fract(d)+1.0;
        
        	float scale=pow(2.0,level);
        	float iscale=1.0/scale;
        	rs=fract(rp.xy*scale)-0.5;
        	vec2 rpd=(rp.xy-(rs)*iscale)*0.5;
        
        	vec3 posp=r1;
			if (z==0) posp=vec3(rpd.x,rpd.y,0.5);
			if (z==1) posp=vec3(0.5,rpd.y,rpd.x);
			if (z==2) posp=vec3(rpd.x,rpd.y,-0.5);
			if (z==3) posp=vec3(-0.5,rpd.y,rpd.x);
			if (z==4) posp=vec3(rpd.x,0.5,rpd.y);
			if (z==5) posp=vec3(rpd.x,-0.5,rpd.y);
        	posp=normalize(posp);
        
        	d=max(0.0,log(iResolution.y*0.04/length(pos+posp))*1.4);
        	level=d-fract(d);
        
        	scale=pow(2.0,level);
        	iscale=1.0/scale;
        	rs=fract(rp.xy*scale)-0.5;

        	//if (level<d) level+=1.0;
        //}
        vec2 rs2=abs(rs)*2.0;
        rs2=(max(rs2,0.1+l*0.8)-0.1-l*0.8)/(1.0-0.1-l*0.8);
        //rp.xy=rp.xy*scale-fract(rp.xy*scale);
        
        //s=snoise(rp);
        s=fract(rs2.x)+fract(rs2.y);//min(fract(rp.x)+fract(rp.y),1.0);
    }
    return s;
}

// Function 1838
vec3 uniform_sample_cone(vec2 u12, 
                         float cosThetaMax, 
                         vec3 xbasis, vec3 ybasis, vec3 zbasis)
{
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * PI * 2.0;
    vec3 samplev = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

// Function 1839
vec3 sphereTransformation(vec3 pt){
    // Rotate around the Z axis, slowly accelerating:
    float r0 = iTime*exp(-1.0/pow(0.01+0.01*iTime,2.0));
    float cr0 = cos(r0);
    float sr0 = sin(r0);
    pt = vec3(pt.x*cr0-pt.y*sr0, pt.x*sr0+pt.y*cr0, pt.z);
    
    // Rotate around the X axis:
    float r1 = iTime*1.0;
    float sr1 = sin(r1);
    float cr1 = cos(r1);
    pt=vec3(pt.x, pt.y*cr1-pt.z*sr1, pt.y*sr1+pt.z*cr1);
    
    return pt;
}

// Function 1840
float hitPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p, vec3 v) {
    return dot(planePoint - p, nvPlaneN) / dot(v, nvPlaneN);
}

// Function 1841
vec3 apply_atmosphere(float travelDist, in vec3 color, in vec3 p)
{
    //From this nice article on fog:
    //http://iquilezles.org/www/articles/fog/fog.htm
    //or this PowerPoint from Crytek:
	//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17
	vec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));
    float c = 1.08;
    float b = 0.06;

    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;
    cumul_density = clamp(cumul_density,0.0,1.0);
    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);
    return FinalColor;
}

// Function 1842
float cylinder( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

// Function 1843
float dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}

// Function 1844
mat4 rotation_mat4_yw_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.
    return mat4(
    	1.0, 0.0, 0.0, 0.0, // x-basis
        0.0, cos_theta, 0.0, sin_theta, // y-basis
    	0.0, 0.0, 1.0, 0.0, // z-basis
        0.0, (-1.0 * sin_theta), 0.0, cos_theta); // w-basis
}

// Function 1845
float distanceToSphere(vec4 sphere,vec3 point) {
	return(length(point-sphere.xyz)-sphere.w);
}

// Function 1846
vec4 sdBox( vec3 p, vec3 b, vec3 color)
{
  vec3 q = abs(p) - b;
  float d= length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
  return vec4(color.rgb, d);
}

// Function 1847
float squarePlane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p, n.xyz) + n.w;
}

// Function 1848
HitTest intersectBox(in Ray r, in Box b) {
 	// box, 0 on y, +/-10 on x, +20 on y
   // vec3 p = vec3(0);
   // vec3 s = vec3(30);
    b.size *= 0.5;
    vec3 ba = b.pos-b.size, bb = b.pos+b.size;
    
    HitTest h = NOHIT;
    float d = INF;
    
    //r.origin -= p;
    
    vec3 dA = (r.origin - ba) / -r.dir;
    vec3 dB = (r.origin - bb) / -r.dir;
    
    dA.x = dA.x <= 0.0 ? INF : dA.x;
    dA.y = dA.y <= 0.0 ? INF : dA.y;
    dA.z = dA.z <= 0.0 ? INF : dA.z;
    dB.x = dB.x <= 0.0 ? INF : dB.x;
    dB.y = dB.y <= 0.0 ? INF : dB.y;
    dB.z = dB.z <= 0.0 ? INF : dB.z;
    
    float d1 = min(dA.x, min(dA.y, dA.z));
    float d2 = min(dB.x, min(dB.y, dB.z));
    
    d = min(d1, d2);
    
    vec3 endPoint = r.origin + r.dir * d;
    endPoint -= b.pos;
    //endPoint = abs(endPoint);
    
    
    if (d != INF) {
        h.hit = true;
        h.dist = d;
        h.ref = 0.0;
        
        if (abs(abs(endPoint.x) - bb.x) < 0.01) {
            bool l = endPoint.x < 0.0;
       		h.normal = vec3(l ? 1 : -1,0,0);
        	h.col = l ? vec4(1,0.5,0.5,1) : vec4(0.5,0.5,1,1);
    		return h;
        }
        if (abs(abs(endPoint.z) - bb.z) < 0.01) {
       		h.normal = vec3(0,0,-sign(endPoint.z));
        	h.col = vec4(1);
           // h.ref = 0.5;
    		return h;
        }
        
        // floor
       	h.normal = vec3(0,-sign(endPoint.y),0);
        h.col = vec4(1);
    	return h;
    }
    return h;
}

// Function 1849
vec4 sdCappedCone( vec3 p, float h, float r1, float r2 , vec3 color)
{
  vec2 q = vec2( length(p.xz), p.y );
  vec2 k1 = vec2(r2,h);
  vec2 k2 = vec2(r2-r1,2.0*h);
  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
  float d = s*sqrt( min(dot2(ca),dot2(cb)) );
  return vec4(color.rgb, d);
}

// Function 1850
vec4 projectionOnSphere(vec2 screenPos){

    vec3 rayOrigin = vec3( 0.0, 0.0, 2.5 );
    vec3 rayDir = normalize( vec3( screenPos, -2.0 ) );

    // intersect sphere
    float b = dot(rayOrigin,rayDir);
    float c = dot(rayOrigin,rayOrigin) - 1.0;
    float h = b*b - c;

    float t = -b - sqrt(h);
    vec3 pos = rayOrigin + t*rayDir;
	//if(length(pos) > SCALE)
	//{
		return vec4(-pos, length(pos));	
	//}
    //return vec4(pos, length(pos));
}

// Function 1851
void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)
{

	vec3 vLightPos = GetLightPos();
	vec3 vToLight = vLightPos - intersection.vPos;
	vec3 vLightDir = normalize(vToLight);
	
	#ifdef ENABLE_FOG
	// fog
	float fFogAmount = exp(intersection.fDistance * -kFogDensity);
	vec3 cFog = GetSkyGradient(ray.vDir);
	col = mix(cFog, col, fFogAmount) ;
	#endif
	
	// glare from light (a bit hacky - use length of closest approach from ray to light)
	#ifdef ENABLE_POINT_LIGHT_FLARE

	float fDot = dot(vToLight, ray.vDir);
	fDot = clamp(fDot, 0.0, intersection.fDistance);
	
	vec3 vClosestPoint = ray.vOrigin + ray.vDir * fDot;
	float fDist = length(vClosestPoint - GetLightPos());
	col += GetLightCol() * kGlareBrightness/ (fDist * fDist);
	#endif      
}

// Function 1852
float RayIntersectAABoxMin (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)
{
    vec3 boxMid = vec3(cellPos)+vec3(0.5);
    
	vec3 roo = rayPos - boxMid;
    vec3 rad = vec3(0.5);

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;

    return max( max( t1.x, t1.y ), t1.z );
}

// Function 1853
float torus(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q) - t.y;
}

// Function 1854
float sdTorus( vec3 p, vec2 t )
{
  return length(vec2(length(p.xz)-t.x, p.y)) - t.y;
}

// Function 1855
float sdCylinderX(vec3 p, vec3 c)
{
  return length(p.zy-c.xy)-c.z;
}

// Function 1856
float drawcone (vec3 ro, vec3 rd, vec3 cp, vec3 cd, float cl, float ca, float dither)
{
    float radialshapes;
    float increment = 1. / float(iterations);
    float spacing = cl * increment;
    
    for(int x = 0; x < iterations - 1; x++) //radialshapes
    {
        float iter = max( float(x) + (dither * 2. - 1.0) * 1.0, 0.001); // add dithering (hide iteration)
        float localpos = iter * spacing; //distance along forward vector of cone
        vec3 spos = localpos * cd + cp;
        float ssize = ( max((2. * localpos), iter) / tan(ca) ) ; // isosceles base length
    	float shape = 1. - saturate( distline(ro, rd, spos) / ssize );
        shape *= shape;
        shape *= (1. / iter) * (1. / iter);
        radialshapes += shape;
    }
    return radialshapes;
}

// Function 1857
vec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)
{
    float a = dot(rd, rd);
    float b = 2. * dot(rd, ro - org);
    float c = dot(ro - org, ro - org) - rad * rad;
    float desc = b * b - 4. * a * c;
    
    if (desc < 0.)
        return vec2(1, 0);

    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));
}

// Function 1858
float sdBox( in vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1859
Mesh genTorus( in int idx )
{
    float i = float( idx );
    float iT0 = mod( i, sepT );
    float iR0 = floor( i / sepT );
    float iT1 = iT0 + 1.0;
    float iR1 = iR0 + 1.0;
    float rad0 = radR + radT * cos( iT0 * thetaT );
    float rad1 = radR + radT * cos( iT1 * thetaT );
    float sin0 = sin( iR0 * thetaR );
    float sin1 = sin( iR1 * thetaR );
    float cos0 = cos( iR0 * thetaR );
    float cos1 = cos( iR1 * thetaR );    
    float h0 = radT * sin( iT0 * thetaT );
    float h1 = radT * sin( iT1 * thetaT );    
    //vec3 v0 = vec3( rad0 * sin0, h0, rad0 * cos0 );
    vec3 v1 = vec3( rad1 * sin0, h1, rad1 * cos0 );
    vec3 v2 = vec3( rad0 * sin1, h0, rad0 * cos1 );
    vec3 v3 = vec3( rad1 * sin1, h1, rad1 * cos1 );
    //if (idx < int( sepT * sepR ) ) return Mesh( v0, v1, v2 );
    return Mesh( v3, v2, v1 );
}

// Function 1860
float distCone(vec3 p, vec3 pos, vec3 c) {
 
    p -= pos;
    vec2 q = vec2( length(p.xz), p.y );
    vec2 v = vec2( c.z*c.y/c.x, -c.z );
    vec2 w = v - q;
    vec2 vv = vec2( dot(v,v), v.x*v.x );
    vec2 qv = vec2( dot(v,w), v.x*w.x );
    vec2 d = max(qv,0.0)*qv/vv;
    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));
    
}

// Function 1861
float occSphere( in vec4 sph, in vec3 pos, in vec3 nor )
{
    vec3 di = sph.xyz - pos;
    float l = length(di);
    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); 
}

// Function 1862
bool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {
    norm=vec3(0.,1.,0.);
    t=-1.;
    float dd = dot(rd, Plane.xyz);
    if (dd == 0.0) return false;
    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;
    if (t1 < 0.0) return false;
    norm = normalize(Plane.xyz);
    t = t1;
    return true;
}

// Function 1863
vec3 uniformDirectionOnSphere(in vec3 n, in vec3 p, in float rnd, in float xi)
{
    vec3 u;
    vec3 v;
    buildOrthonormalBasis(n, u, v);
    
    float phi = rnd * 2.0 * PI;
    float cosTheta = sqrt(xi);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    return (u * cos(phi) + v * sin(phi)) * cosTheta + n * sinTheta;
}

// Function 1864
float SdPlane(vec3 p)
{
    return p.y;
}

// Function 1865
float sdBox(vec3 p,vec3 b) {
    vec3 d=abs(p)-b;
    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));
}

// Function 1866
vec3 randomHemisphereDirection( const vec3 n ) {
	lowp vec3 dr = randomSphereDirection();
	return dot(dr,n) * dr;
}

// Function 1867
float directionalOcclusionSphere(in vec3 pos, in vec4 sphere, in vec4 cone) {
    vec3 occluder = sphere.xyz - pos;
    float occluderLength2 = dot(occluder, occluder);
    vec3 occluderDir = occluder * inversesqrt(occluderLength2);

    float cosPhi = dot(occluderDir, cone.xyz);
    // sq(sphere.w) should be a uniform --> capsuleRadius^2
    float cosTheta = sqrt(occluderLength2 / (sq(sphere.w) + occluderLength2));
    float cosCone = cos(cone.w);

    return 1.0 - sphericalCapsIntersection(cosTheta, cosCone, cone.w, cosPhi) / (1.0 - cosCone);
}

// Function 1868
vec2 intersectSphere(Ray r, vec4 o, float index){
	float a,b,c;
	a = dot(r.d,r.d);
	b = dot(2.*(r.o-o.xyz),r.d);
	c =(dot(r.o-o.xyz,r.o-o.xyz)) - pow(o.w,2.) ;
	
	float delta =  pow(b,2.)-4.*a*c ;
	if(delta <0.){
		return vec2(MAX_VALUE,-1);
	}else{
		float t1,t2;
		t1 = (-b + sqrt(delta) )/(2.*a);
		t2 = (-b - sqrt(delta) )/(2.*a);
		if(t1 <0.){
			return vec2(t2,index);
		}else if(t2<0.){
			return vec2(t1,index);
		}else{
			return t1<=t2 ? vec2(t1,index) : vec2(t2,index);
		}
	}
}

// Function 1869
float sdBox (in vec3 p, in vec3 size, in float r)
{
  vec3 d = abs(p) - size;
  return min (max (d.x, max (d.y,d.z)), .0) + length (max (d, .0)) - r;
}

// Function 1870
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    float t = -1.0;
	vec3  ce = ro - sph.xyz;
	float b = dot( rd, ce );
	float c = dot( ce, ce ) - sph.w*sph.w;
	float h = b*b - c;
	if( h>0.0 )
	{
		t = -b - sqrt(h);
	}
	
	return t;
}

// Function 1871
float udBox( vec3 p, vec3 b ) { return length(max(abs(p)-b,0.0)); }

// Function 1872
vec3 intersectSphere (vec3 rO, vec3 rD)
{
	float B, C, d, t0, t1, t;
	B = 2. * dot (rO, rD);
	C = dot (rO, rO) - BOUNDING_DOMAIN_SIZE;
	d = sqrt (B * B - 4. * C);
	t0 = (-B + d) * .5;
	t1 = (-B - d) * .5;
	t = min (t0, t1);
	rO += t * rD;
	return rO;
}

// Function 1873
bool isOnPlane(vec3 p, Transform squareTrans)
{
    mat4 squareMat = transformMatrix(squareTrans);
	vec3 ap = vec3(inverse(squareMat) * vec4(p, 1.0));
    if(ap.x < 0.5f && ap.x > -0.5f && ap.y < 0.5f && ap.y > -0.5f)
    {
    	return true;
    }
    else
    {
    	return false;
    }
}

// Function 1874
vec2 getExhaustPlaneColor(vec3 p, WORLD w){
    vec2 planeColor = vec2(1., .25);
    float span = .5;
    {
        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_2];
        float id = floor(abs(p.x)) * .1;
        float curWidth = smoothstep(id * span, (id+1.) * span, ph) * abs(p.x) * .35;
        planeColor.x *= max(smoothstep(.48, .47, distance(fract(p.x), .5)),
                            smoothstep(curWidth - .05, curWidth, abs(p.z)));
    }
    
    {
        float ph = apPhasesStates[AP_SHUTTLE_EXHAUST_3];
        
        float t = 0.;
        vec3 mp = p;
        float id = floor(abs(mp.x));
        mp.x = fract(mp.x);
        id *= .1;
        
        vec4 bubbles[] = getExhaustBubble(p, mp, id, t, w);
        float span = .34;
        for(int i=0; i<3; i++){
            vec4 b1 = bubbles[i];
            float curSpan = smoothstep(float(i) * span, float(i+1) * span, ph);
            float curWidth = smoothstep(id * span, (id + 1.) * span, curSpan)
                       * mix(.75, b1.w, pow(smoothstep(.5, 1., curSpan), .5))
                       * .75;
            
            float scale = smoothstep(0., .1, curSpan);
            planeColor.x *= smoothstep(.025 * scale, .05 * scale, distance(distance(b1.xz, mp.xz), curWidth));
        }
        
        planeColor.y *= apPhasesInvStates[AP_SHUTTLE_EXHAUST_4];
    }
    return planeColor;
}

// Function 1875
float SD_Sphere(vec3 P, float r) 
{
	return length(P) - r;
}

// Function 1876
float udRoundBox(vec3 p, vec3 b, float r) {
	p += ScaleFactor * noise(p);
	return length(max(abs(p) - b, 0.0)) - r;
}

// Function 1877
vec2 raySphereIntersect(in vec3 origin, in vec3 dir, in float radius) {
	float a = dot(dir, dir);
	float b = 2.0 * dot(dir, origin);
	float c = dot(origin, origin) - (radius * radius);
	float d = (b * b) - 4.0 * a * c;
    
	if(d < 0.0)return vec2(1.0, -1.0);
	return vec2(
		(-b - sqrt(d)) / (2.0 * a),
		(-b + sqrt(d)) / (2.0 * a)
	);
}

// Function 1878
vec3 voronoiSphereMapping(vec3 n){
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
    return getVoronoi(1.5*uv);}

// Function 1879
float sdTorus883( vec3 p, vec2 t )
{
  vec2 q = vec2(length8(p.yz)-t.x,p.x);
  return length8(q)-t.y;
}

// Function 1880
float sdTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x, p.y);
  return length(q)-t.y;
}

// Function 1881
float dfBox(vec3 p, vec3 size, float rad)   {return length(max(abs(p) - size + vec3(rad), 0.0)) - rad;}

// Function 1882
float sphere_intersection(vec3 r, vec3 p, vec4 sphere)
{
	p = p - sphere.xyz;
	if(p == vec3(0)) return sphere.w;
	
	float b = dot(p, r);
	float c = sphere.w*sphere.w - dot(p,p);
	float d = b*b + c;
	
	if((d <= 0.)) //if no intersection
	{
		return -length(cross(r, p)); //return closest dist
	}
	else
	{
		return -sqrt(d) - b; //use closest solution in the direction of the ray
	}
}

// Function 1883
float sdCylinderY(vec3 p, vec3 c)
{
  return length(p.xz-c.xy)-c.z;
}

// Function 1884
float sdCappedCylinder( vec2 p, float h, float r )
{
  vec2 d = abs(vec2(length(p.xy),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1885
float sdSphere(in ray r, in sph s) {
    vec3 oc = r.o - s.l;
    return dot(oc, oc) - s.r * s.r;
}

// Function 1886
vec3 sphere_from_bary(vec3 b) {
    return tri_verts * b;
}

// Function 1887
vec3 randomSphere(){
  float phi=TAU*random();
  float theta=acos(2.0*random()-1.);
  return vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));
}

// Function 1888
vec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)
{
    rp = rp - (p0 + p1) / 2.;
    vec3 arp = abs(rp) / (p1 - p0);
    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);
}

// Function 1889
float Sphere( in vec3 ro, in vec3 rd, in vec3 p, in float r)
{//intersect a sphere - based on iq's
	float t=100.0;
	p=ro-p;
	float b=dot(p,rd);
	float h=b*b-dot(p,p)+r*r;
	if(h>=0.0){
		float t=-b-sqrt(h);
		if(t>0.0)return t;
	}	
	return 10.0;
}

// Function 1890
float box(vec3 p, vec3 s)
{
    vec3 d = abs(p) - s;
    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
}

// Function 1891
bool in_half_plane(vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    return dot(pa, perp(ba)) > 0.0;
}

// Function 1892
vec3 nPlane2(vec3 pos) {
	return plane.xyz;
}

// Function 1893
float castPlanet(vec3 cell, vec3 pos, vec3 dir, out float coverage)
{
	vec2 pp = cell.xy + cell.xy;
    if (dot(pp.xy, pp.xy) < 1.5) return MAX_DST; // we leave a 'tunnel' empty along the z axis 
                
 	planet p;
    
    GetPlanet(cell, p);            
    if (p.radius < 0.06) return MAX_DST; // cull planets that are too small
    
    // ray sphere intersection from the start position
    
    return raySphereIntersect(pos, dir,  cell + p.center, p.radius, coverage); 
}

// Function 1894
float dstSphere(vec3 p, vec3 pos, float r) {
 
    return length(pos - p) - r;
    
}

// Function 1895
vec4 planet(vec3 ro, vec3 rd, vec3 nrd, vec3 pmod, float ttime, out float dist) {
  vec4 s_p = planetDim(ttime);
  vec2 rsi = raySphere(ro, rd, s_p);
  
  dist = rsi.x;

  if (rsi.x == miss || rsi.x <= 0.0) {
    return vec4(0.0);
  }
  
  vec3 pi = ro + rd*rsi.x;
  vec3 ni = normalize(pi - s_p.xyz);
  vec3 ppi = toSpherical((pi-s_p.xyz).zxy*pmod);
  float h = fbm(ppi.yz*5.0);

  float yf = smoothstep(.6, 1.0, abs(pi.y)/s_planet.w);
  yf *= yf;

  float gs = gasGiantShade(s_miniGiant, pi);

  float diff = (pow(max(dot(ni, innerSunDir), 0.0), 1.0));
  vec3 col = mix(0.9*vec3(0.5, 0.5, 0.45), 0.1*vec3(0.5, 0.5, 0.8), pow(h*h, 2.0)*(1.0-yf));
  col *= mix(0.0125, 1.5, diff);
  col *= gs;
  
  return vec4(col, smoothstep(0.0, 0.5, (rsi.y - rsi.x)/s_planet.w));
}

// Function 1896
float sdFluffTorus(vec3 p, vec2 s)
{
    float rad2 = s.y * 0.3;
    s.y -= rad2 * fbm(p*8.0);
    return sdTorus(p,s);
}

// Function 1897
float sdCappedCylinder(float h, float r, vec3 p)
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1898
float sphereSdf(vec3 pos) {
    float scale = mix(0.25, 1.0, 0.0);
    return length((pos - SPHERE.center)) - SPHERE.radius;
}

// Function 1899
float Cylinder(vec3 point, vec3 a, vec3 b, float radius) {

    float v = Diff( Capsule(point, a, b, radius),
                    Plane(point, normalize(a-b), b));
    
    v = Diff(v, Plane(point, normalize(b-a), a));
    return v;
}

// Function 1900
float dsBox(vec2 p, vec2 b, float r)
{
    p.x -= p.y*0.5;
    return length(max(abs(p)-b, 0.)) -r;
}

// Function 1901
float box( in vec2 p, in vec2 b ) {
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 1902
vec2 IntersectBox(vec3 orig, vec3 dir, vec3 pos, vec3 size)
{
    size = abs(size / dir / 2.0);

    vec3 tc = (pos - orig) / dir;    

    vec3 t0 = tc - size;
    vec3 t1 = tc + size;
    
    return vec2(
        max(max(t0.x,t0.y),t0.z), 
        min(min(t1.x,t1.y),t1.z)
    );
}

// Function 1903
float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
    float d1 = -q.y-c.z;
    float d2 = max( dot(q,c.xy), q.y);
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

// Function 1904
float sdSphere(vec3 p, float s) { return length(p) - s; }

// Function 1905
float soundSphere(vec3 pos, float r)
{
    float ry = atan(pos.x / pos.z);
    float rx = atan(pos.y / pos.z);
    
    int a = int(fract((ry / PI / 4. + .5) * 3.) * 512.);
    int b = int(fract((rx / PI / 4. + .5) * 3.) * 512.);
    
    float freq = texelFetch( iChannel0, ivec2(0, 0), 0).x; 
    float wave = texelFetch( iChannel0, ivec2(0, 1), 0).x;
    //bug.r = float(a);
    float disp = wave / 10. + freq;
    
    return length(pos) - r - disp;
}

// Function 1906
float udRoundBox( vec3 p, vec3 b, float r )
{
    vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
  return length(max(abs(p)-b,0.0))-r;
}

// Function 1907
float sdSphere( vec3 p, float r ) {
    return length(p) - r;
}

// Function 1908
vec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3 oc = ro - sph.xyz;
    
	float b = dot(oc,rd);
	float c = dot(oc,oc) - sph.w*sph.w;
    float h = b*b - c;
    
    if( h<0.0 ) return vec2(-1.0);

    h = sqrt( h );

    return -b + vec2(-h,h);
}

// Function 1909
float sphere (vec3 p, float s){
   return length(p) - s;
}

// Function 1910
float sdPlane(in vec3 p) 
{
	return p.y+(0.025*sin(p.x*10.  +1.4*iTime  ))+(0.025*sin(p.z*12.3*cos(0.4-p.x)+  1.6*iTime  ))-0.05;
}

// Function 1911
float RayRoundBoxIntersect(Ray ray, RoundBox box, bool convex, int numSteps)
{
	vec3 origin = WorldToLocal(ray.origin, box);
    vec3 dir = WorldToLocal(ray.origin + ray.dir, box) - origin;
	float t0 = 0.0;
	float t1 = FLT_REALLY_BIG;
	const float thresh = 0.0001; // fixed for now .. not even sure this is useful
	float dlen = length(dir);
	float q = 1.0/dlen;
	vec3 P = origin;
	vec3 V = dir*q;
	t0 *= q;
	t1 *= q;
	float d0 = FLT_REALLY_BIG;
	vec3 E = box.extent - box.roundRadius;
	for (int i = 0; i < numSteps; i++) {
		float d1 = LocalDistanceToRoundBox(P, box);
		if (d1 <= thresh)
			break;
		float dt = d1;
		if (convex) {
			vec3 G = normalize(clamp(P, -E, E) - P); // negative gradient vector
			dt /= dot(V, G);
		}
		t0 += dt;
		if (d1 > d0 || t0 >= t1)
			return 0.0; // distance is increasing (since object is convex, we know we missed), or we extended past the end of the ray
		P = origin + V*t0;
		d0 = d1;
	}
	return t0*dlen;
}

// Function 1912
vec3 normalSphere(in vec3 pos, in vec4 sph)
{
    //sphere center at (l, m, n) radius r
    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )
    return (pos - sph.xyz)/sph.w;
}

// Function 1913
float distToPlane(vec3 o, vec3 d, vec3 p, vec3 n)
{
    return dot(o - p, n) / dot(n, -d);
}

// Function 1914
vec2 PosToSphere(vec3 pos)
{
  float x = atan(pos.z, pos.x); 
  float y = acos(pos.y / length(pos)); 
  return vec2(2.*x / PI_TWO, 2.*y / PI);
}

// Function 1915
float raySphere(vec3 center, float radius, vec3 ray, vec3 rayOrigin)
{
    center -= rayOrigin;
    float b = -dot(center, ray);
    float c = dot(center,center) - radius*radius;
    float D = b*b - c;
    if(D < 0.0)
    {
        return 0.0;
    }
    else
    {
        return -b - sqrt(D);
    }
}

// Function 1916
Color3 samplePlanet(Point3 osPosition, out float e, out float k) {
	Point3 s = normalize(osPosition);    
    
    // Cylindrical map coords
    Point2 cylCoord = vec2(atan(s.z, -s.x) / pi, s.y * 0.5 + 0.5);

    // Length of osPosition = elevation
    float sampleElevation  = length(osPosition);//dot(osPosition, s);
    
    // Relative height of the sample point [0, 1]
    k = (sampleElevation - planetMinRadius) * (1.0 / maxMountain);

    // Use explicit MIPs, since derivatives
    // will be random based on the ray marching
    float lod = (iResolution.x > 800.0) ? 1.0 : 2.0;
    
    // Relative height of the surface [0, 1]
    e = mix(textureLod(elevationMap, cylCoord, lod).r, textureLod(elevationMap, s.xz, lod).r, abs(s.y));
    e = square((e - 0.2) / 0.8) * 0.5;
    
    // Soften glow at high elevations, using the mip chain
    // (also blurs 
    lod += k * 6.0;
    
    // Planar map for poles mixed into cylindrical map
    Color3 material = mix(textureLod(colorMap, cylCoord * vec2(2.0, 2.0), lod).rgb,
                          textureLod(colorMap, s.xz, lod).rgb, abs(s.y));

    // Increase contrast
    material = pow3(material);
    
    
    // Object space height of the surface
    float surfaceElevation = mix(planetMinRadius, planetMaxRadius, e);

    return material;
}

// Function 1917
float fBoxy(vec2 p, vec2 s) {
    return vmax(abs(p) - s);
}

// Function 1918
vec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {
    vec3 m = 1./rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    
    float tN = max(max(t1.x, t1.y), t1.z);
    float tF = min(min(t2.x, t2.y), t2.z);
    
    if(tN > tF || tF < .0) return vec2(-1);
    
    return vec2(tN, tF);
}

// Function 1919
float sdCylinder( vec3 p, vec3 c )
{
    return length(p.xz-c.xy)-c.z;
}

// Function 1920
float sdCylinder( vec3 p, vec2 h )
{
  return max( length(p.xz)-h.x, abs(p.y)-h.y );
}

// Function 1921
float iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {
    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );
}

// Function 1922
float sdBox2p(vec3 p, vec3 b1, vec3 b2) {
	vec3 pos = (b1 + b2) / 2.0;
	vec3 b = (b2 - b1) / 2.0;
	return sdBox(p - pos, b);
}

// Function 1923
float sphereDist(float3 p, float4 sphere)
{
    return length(p - sphere.xyz) - sphere.w;
}

// Function 1924
float sdBox( in vec3 p, in vec3 b ) {
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1925
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad )
{
    vec3 m = 1.0001/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    return vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
}

// Function 1926
float repeatedBox( vec3 p, vec3 c, float b, float r )
{
  return length(max(abs(mod(p,c)-0.5*c)-b,0.0))-r;
}

// Function 1927
float SphereIntersection(
    in vec3 rayOrigin, 
    in vec3 rayDirection, 
    in vec3 sphereCenter, 
    in float sphereRadius, 
    out vec3 normal)
{
      vec3 eMinusC = rayOrigin - sphereCenter;
      float dDotD = dot(rayDirection, rayDirection);

      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))
         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);

      if (discriminant < 0.0) 
         return -1.0;

      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))
             / dDotD;
      
      float t = firstIntersect;
    
      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);
      return t;
}

// Function 1928
vec3 spheredf( vec3 p, 
               vec3 cellcoords )
{


    // This default result has no material or heat, but does return a
    // default distance of half a cell size.  The is the "skipping"
    // distance since it will most likely jump to the next cell.  We
    // could optimize this "skip" "distance" by actually doing the
    // math to find the minimum amount that jumps to the next cell,
    // but this in practice gets the job done.
    vec3 result = vec3(.5 * CELLBOX_SIZE, 0., 0.);

    // Don't process the current cell if we're not in the box bound.
    // We use this check since we use distance lookups to find the
    // outer edge of the box of spheres with a 1 cell buffer, so the
    // "outer" cells can have "over extended" distance samples even
    // though those buffer cells do not contain any spheres.
    if ( inbounds( p, vec3( NUM_CELLBOXES * CELLBOX_SIZE ) ) ) 
    {

        float signal = 0.;

#if !HEAT_PLUMES_ONLY
        int selector = int(mod(g_time/10.,5.));
#endif 

#if !HEAT_PLUMES_ONLY
        // I like the heat plumes so I give them a little extra time
        // when cycling.
        if (selector == 0 || selector == 1)  // heat plumes
        {
#endif

            float t = -g_beatRate * .04125 * g_time;    
            float basst = .5 + .5 * smoothstep(.6, 
                                               .98, 
                                               g_audioFreqs[0]);
            t = mod(t + .5 * length(cellcoords + g_plumeOrigin), 15.);
            signal = basst * (smoothstep(0., 3., t) - 
                              smoothstep(3., 5., t));

#if !HEAT_PLUMES_ONLY
        }
#endif

#if !HEAT_PLUMES_ONLY

        float audiot = smoothstep(NUM_CELLBOXES/2., 
                                  -NUM_CELLBOXES/2.,
                                  cellcoords.y);
        audiot = audioAttenuate(1. - audiot);

        if (selector == 2) // audio vertical heat waves
        {

            signal = audiot * (.5 * sin(g_beatRate * 0.03125 * g_time + 
                dot(g_heatWaveDir, cellcoords) ) + .5);        

        }
        if (selector == 3) // audio heat pulses
        {            

            audiot = .1 + .9 * audiot;
            signal = audiot * pow(.5 * sin(-g_beatRate * 0.03925 * g_time + 
                .3 * length(cellcoords + 
                    vec3(0., NUM_CELLBOXES/3., 0.))) + .5, 2.);
        }
        if (selector == 4) // audio eminating heat boxes
        {

            audiot = .1 + .9 * audiot;
            signal =  audiot * (.5 * sin(-g_beatRate * 0.03925 * g_time + 
                .8 * max(abs(cellcoords.x), 
                     max(abs(cellcoords.y), 
                         abs(cellcoords.z)))) + .5);
        }
#endif

        float heat = 10000. * signal; 
        // Don't consider this a valid cell if it isn't hot enough.  
        if (heat > 100.) {

            // Bloat the radius based on the radius scale signal.
            // There is always a little bit of sphere if there is
            // enough heat.
            float radius = .8 * (.9 * signal + .1) * 
                            .5 * CELLBOX_SIZE;

            // Push the sphere away from the origin based on the
            // displacement signal
            vec3 sphereCenter = cellcoords * CELLBOX_SIZE - 
                            vec3(CELLBOX_SIZE * .5);
            vec3 towardsCenter = -normalize(sphereCenter);                
            sphereCenter -= (2. * signal - 1.) * 
                            (.5 * CELLBOX_SIZE - radius) * 
                            towardsCenter;
            

            result = vec3(length( p - sphereCenter ) - radius, 
                          1., 
                          heat);
        }
    }
    
    return result;
}

// Function 1929
float atmosphereDepth(vec3 ori, vec3 dir, float t1, float t2){
    //midpoint riemann integration
    float density = 0.;
    float dt = (t2-t1)/float(DEPTH_SAMPLES);
    float t = t1 + dt*.5;//+dt*.5 so we are taking midpoints
    for(int i=0; i<DEPTH_SAMPLES; i++){
        vec3 x = ori + dir*t;
    	density += atmosphereDensity(x)*abs(dt);
        t += dt;
    }
    return density;
}

// Function 1930
float sdCone( in vec3 p, in vec2 c, float h )
{
    vec2 q = h*vec2(c.x,-c.y)/c.y;
    vec2 w = vec2( length(p.xz), p.y );
    
	vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );
    float k = sign( q.y );
    float d = min(dot( a, a ),dot(b, b));
    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );
	return sqrt(d)*sign(s);
}

// Function 1931
float torusDistance(vec3 p, float inner_radius, float outer_radius)
{
	vec3 ring_p = vec3(normalize(p.xy) * outer_radius, 0.0);
	return distance(p, ring_p) - inner_radius;
}

// Function 1932
float sphere(vec3 p)
{ return length(p) - sphereRadius; }

// Function 1933
float mandelbox_dist(vec3 pos) {
    vec4 p = vec4(pos, 1.0), p0 = p;
    float minRad2 = 0.25;
    vec4 scale = vec4(2.0) / minRad2;
    float absScalem1 = abs(2.0 - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));
    for (int i=0; i<20; i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
        p = p * scale + p0;
    }
    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Function 1934
float sdCone( vec3 p, vec3 origin, vec2 c )
{
  p = Translate(p, origin);
  float q = length(p.xz);
  return dot(c,vec2(q,p.y));
}

// Function 1935
vec4 MapPlanet(vec3 p)
{
  vec3 moonPos = p-GetMoonPosition(p);
  vec2 mapPos = PosToSphere(moonPos);
  float heightMap = -fastFBM((moonPos*0.5)*.4);
  float moon = sdSphere(moonPos, 40.+heightMap);
  GetPlanetRotation(p);  
  mapPos = PosToSphere(p);
  heightMap = ((GetTerrainHeight(8.*p)*0.35))*textureLod(iChannel3, 2.*mapPos, log2(mapPos.y*2.)).z*1.5;
  return vec4(min(moon, sdSphere(p, 70.-min(2., (1.-heightMap)))), heightMap, moon, 0.);
}

// Function 1936
float iSphere(in vec3 ro, in vec3 rd)
{
    vec3 oc = ro;
    float b = dot(oc, rd);
    float c = dot(oc,oc) - 1.;
    float h = b*b - c;
    if(h <0.0) return -1.;
    return -b - sqrt(h);
}

// Function 1937
float sdBox( vec3 boxpos, vec3 p, vec3 b ) {
    p -= boxpos;
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 1938
vec2 boundingSphere( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3 oc = ro - sph.xyz;
    
	float b = dot(oc,rd);
	float c = dot(oc,oc) - sph.w*sph.w;
    float h = b*b - c;
    
    if( h<0.0 ) return vec2(-1.0);

    h = sqrt( h );

    return -b + vec2(-h,h);
}

// Function 1939
HessNum3 DE_Sphere_Hess(in HessNum3 x, in HessNum3 y, in HessNum3 z)
{
    return sub(a_sqrt(add(add(mult(x,x),mult(y,y)),mult(z,z))),1.4);  
}

// Function 1940
float MBoxDf (vec3 p)
{
  vec4 q, q0;
  const int nIter = 30;
  q0 = vec4 (p, 1.);
  q = q0;
  for (int n = 0; n < nIter; n ++) {
    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;
    q *= mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.);
    q += q0;
  }
  return length (q.xyz) / abs (q.w);
}

// Function 1941
float int_sphere(Ray ry, Sphere sp)
{
   	// solve for omega, scale factor of ray
    // using the quadratic equation (Basic Ray Tracer, pg 25)
    vec3 diff_pos = ry.pos - sp.pos;
	float b = 2.0 * (
          (ry.dir.x * diff_pos.x)
        + (ry.dir.y * diff_pos.y)
        + (ry.dir.z * diff_pos.z)
    );
    float c = (
          pow(ry.pos.x - sp.pos.x, 2.0)
        + pow(ry.pos.y - sp.pos.y, 2.0)
        + pow(ry.pos.z - sp.pos.z, 2.0)
        - pow(sp.rad, 2.0)
    );
    // b^2 - 4c (a  = 1) is called the discriminant
    float discrmt = pow(b, 2.0) - (4.0 * c);
    // imaginary numbers ignore; report negative direction
    // -42 is a good debugging value
	if (discrmt < 0.0)
    {
    	return -42.0;
    }
    // pick the closest intersection to the ray
    // (smallest positive root; -b - sqrt(discriminant))
    float omega = (-b - sqrt(discrmt)) / 2.0;
    return omega;
}

// Function 1942
float torus( vec3 p, float s) {
    vec2 q = vec2(length(p.xz),p.y);
    return length(abs(q)-vec2(s,0));
}

// Function 1943
vec3 spherecords(vec2 p) {
  float phi = acos(p.x);
  float lamb = p.y*acos(-1.);
  return vec3(cos(phi), sin(phi)*cos(lamb), sin(phi)*sin(lamb));
}

// Function 1944
float box_smooth(vec2 uv, vec4 bounds, vec4 smth)
{
	return smoothstep(bounds.x, bounds.x + smth.x, uv.x) *
	       smoothstep(bounds.y, bounds.y + smth.y, 1.0 - uv.x) *
	       smoothstep(bounds.z, bounds.z + smth.z, 1.0 - uv.y) *
	       smoothstep(bounds.w, bounds.w + smth.w, uv.y);
}

// Function 1945
vec3 rayPlaneIntersect(Ray ray)
{
   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)
                                      / dot(rect.front, ray.direction));
}

// Function 1946
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
}

// Function 1947
float udRoundBox(vec3 p, vec3 b, float r)
{
  return length(max(abs(p)-b,0.0))-r;
}

// Function 1948
bool resolveRaySphereIntersection(sphere ball){
	vec3 OC=ball.pos-camera;
	float P=dot(OC,ray);
	if(P<0.) return false;
	float d=sqrt(pow(length(OC),2.0)-pow(P,2.0));
	if(d>ball.size) return false;
	return true;
}

// Function 1949
vec4 findbestsepplane()
{
    pixelx-=CUBECOUNT;
    uint cia = pixelx;
    uint cib = pixely;
    if (cia>=CUBECOUNT) discard;
    if (cib>=cia) discard;
    float best=1e30;
    vec4 bestsep;
    for(uint m=0u;m<30u;m++)
    {
        vec4 sep = readTex0(cia*6u+m%6u+CUBECOUNT*12u,cib*5u+m/6u);
        if (length(sep.xyz)<best)
        {
            best = length(sep.xyz);
            bestsep = sep;
        }
    }
    return vec4(normalize(bestsep.xyz),bestsep.w);;
}

// Function 1950
vec3 randomOnSphere( void ) {
    float theta = (6.283185 / 32767.0) * float(rand());
    float u = (2.0 / 32767.0) * float(rand()) - 1.0;
    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);
}

// Function 1951
vec3 nPlane(in vec3 pos)
{
	return vec3(0.0, 1.0, 0.0);
}

// Function 1952
vec3 number_box(vec2 pos, vec2 offset)
{
    vec2 pos2 = pos - offset;
    vec3 box;
    
    #ifdef slant
    float ew = d_slant*d_height;
    #else
    float ew = 0.;
    #endif

    box.x = max(-pos2.x - n_border*d_width, pos2.x - float(nb_digits)*d_width - float(nb_digits - 1)*d_width*d_spacing - n_border*d_width - ew);
    box.y = max(-pos2.y - n_border*d_width, pos2.y - d_height - n_border*d_width);  
    
    float boxz1 = -pos2.x - n_border*d_width>-pos2.y - n_border*d_width?-1.:1.;
    float boxz2 = -pos2.x - d_height - n_border*d_width + float(nb_digits)*d_width + float(nb_digits - 1)*d_width*d_spacing + ew>-pos2.y - n_border*d_width?-1.:1.;
    box.z = pos2.y<0.?boxz1:boxz2; 
   
    return box;
}

// Function 1953
float box(vec2 p, vec2 b, float r)
{
	return length(max(abs(p) - b, 0.0)) - r;
}

// Function 1954
float roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )
{
	// bounding box
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*(size+rad);
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return -1.0;
    float t = tN;

    // convert to first octant
    vec3 pos = ro+t*rd;
    vec3 s = sign(pos);
    ro  *= s;
    rd  *= s;
    pos *= s;
        
    // faces
    pos -= size;
    pos = max( pos.xyz, pos.yzx );
    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;

    // some precomputation
    vec3 oc = ro - size;
    vec3 dd = rd*rd;
	vec3 oo = oc*oc;
    vec3 od = oc*rd;
    float ra2 = rad*rad;

    t = 1e20;        

    // corner
    {
    float b = od.x + od.y + od.z;
	float c = oo.x + oo.y + oo.z - ra2;
	float h = b*b - c;
	if( h>0.0 ) t = -b-sqrt(h);
    }

    // edge X
    {
	float a = dd.y + dd.z;
	float b = od.y + od.z;
	float c = oo.y + oo.z - ra2;
	float h = b*b - a*c;
	if( h>0.0 )
    {
	  h = (-b-sqrt(h))/a;
      if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;
    }
	}
    // edge Y
    {
	float a = dd.z + dd.x;
	float b = od.z + od.x;
	float c = oo.z + oo.x - ra2;
	float h = b*b - a*c;
	if( h>0.0 )
    {
	  h = (-b-sqrt(h))/a;
      if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;
    }
	}
    // edge Z
    {
	float a = dd.x + dd.y;
	float b = od.x + od.y;
	float c = oo.x + oo.y - ra2;
	float h = b*b - a*c;
	if( h>0.0 )
    {
	  h = (-b-sqrt(h))/a;
      if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;
    }
	}

    if( t>1e19 ) t=-1.0;
    
	return t;
}

// Function 1955
bool pointInBox( vec2 p, Box box ) {
    if( IN_RANGE( p.x, box.position_.x, box.position_.x + box.dimensions_.x ) &&
      	IN_RANGE( p.y, box.position_.y, box.position_.y + box.dimensions_.y ) )
        return true;
    
    return false;
}

// Function 1956
vec3 SphereTracedObjectNormal(in vec3 p)
{
	float eps = 0.0001;
	vec3 n;
	float v = SphereTracedObject(p);
	n.x = SphereTracedObject( vec3(p.x+eps, p.y, p.z) ) - v;
	n.y = SphereTracedObject( vec3(p.x, p.y+eps, p.z) ) - v;
	n.z = SphereTracedObject( vec3(p.x, p.y, p.z+eps) ) - v;
	return -normalize(n);
}

// Function 1957
bool RayMarchPerturbedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, 
                             out vec3 n, out vec3 sd) {
    n = vec3(0.0);
    sd = vec3(0.0);
    
    vec3 bp0 = vec3(0.0);
    vec3 bp1 = vec3(0.0);
    bool bres = RaySphereIntersection(ro, rd, c, br, bp0, bp1);
    if (!bres) return false;
    
    vec3 p0 = vec3(0.0); 
    vec3 p1 = vec3(0.0);
    bool res = RaySphereIntersection(ro, rd, c, r, p0, p1); 
    
    float dist = float(res)*length(p0 - bp0) + (1.0-float(res)) * length(bp0 - bp1);
	//float dist = length(bp0 - bp1);
    const float sc = 128.0;
    const float invsc = 1.0 / sc;
    float s = dist * invsc;
    
    bool ret = false;
    vec3 pn = vec3(0.0);
    for (float d = 0.0; d < sc; ++d) {
    	pn = (bp0 + d*s*rd) - c;
		
        sd = normalize(pn) * r;
        float h = length(pn) - r - s;
        
        float h0 = noise(sd);
        if (h0 > h) {
            ret = true;
            break;
        } 
    }
    
    n = SphereNormal(normalize(pn), r, s);
    return ret;
}

// Function 1958
float distToEnterPlanet(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;
    return max(-r * mu - sqrt(max(discriminant, 0.)), 0.);
}

// Function 1959
float udRoundBox(vec3 p, vec3 b, float r) {
    return length(max(abs(p)-b,0.0))-r;
}

// Function 1960
float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 1961
float distSphere(vec3 p, vec3 pos, float radius) {

    return length(pos - p) - radius;
    
}

// Function 1962
float sdCylinder( const vec3 p, const vec2 h ) {
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1963
float dPlaneY( vec3 p )
{
	return p.y;
}

// Function 1964
float Box(vec3 point, vec3 box) {

  vec3 q = abs(point) - box;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 1965
vec2 cylinderImpact(in vec2 pos, in vec2 cylO, in float cylR, in vec2 N_ray){
    float t_impact=INFINI, minDist=0.;
    vec2 delta = pos - cylO;

    // circle interception
    // pre-calculation
    float dot_N_ray_Sq = dot(N_ray,N_ray);
    float dot_delta_N_ray = dot(delta, N_ray);
    float c = dot(delta,delta) - cylR*cylR;
    
    float discr = dot_delta_N_ray*dot_delta_N_ray - dot_N_ray_Sq*c;
    
    if (discr >= 0.){
        float sqrt_discr = sqrt(discr);
        t_impact= min((-dot_delta_N_ray + sqrt_discr)/(dot_N_ray_Sq),
        		(-dot_delta_N_ray - sqrt_discr)/(dot_N_ray_Sq));
        if (t_impact < 0.001) t_impact=INFINI;
    }
    
    minDist = abs(c-dot_delta_N_ray*dot_delta_N_ray/dot_N_ray_Sq)/cylR;
    
	return vec2(t_impact,minDist);
}

// Function 1966
float fTorus(vec3 p,float i,float r){return length(vec2(length(p.xz)-r,p.y))-i;}

// Function 1967
MapValue sphere(vec3 p, float radius, Material m) {
  MapValue mv;
  mv.material = m;
  mv.signedDistance =length(p) - radius;
  return mv;
}

// Function 1968
vec3 SphereRand( uint seed )
{
    float a = (float((seed*0x73493U)&0xfffffU)/float(0x100000))*2. - 1.;
    float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));
    float cosa = sqrt(1.-a*a);
    return vec3(cosa*cos(b),a,cosa*sin(b));
}

// Function 1969
float PrimTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 1970
float sdCappedCylinderY(vec3 p, vec2 h)
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1971
float boxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return length(max(d,0.)) + min(max(d.x,max(d.y,d.z)),0.);
}

// Function 1972
float sdSphere(vec3 pos, float radius)
{
    return length(pos) - radius;
}

// Function 1973
vec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {
    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );

    vec3 intersection = ro + rd*d;
    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );
    vec4 res;

#ifndef HIDE_TERRAIN
    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && 
        					   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;
#endif
    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; 
    float mixDetailColor = 0.;
        
	if( d < 0. || d > maxd) {
#ifndef HIDE_TERRAIN
        if( renderTerrainDetail ) {
       		intersection = ro;
            n = normalize( ro );
        } else { 	       
	        return vec4(0);
        }
#else 
      	return vec4(0.);
#endif
	}
    if( d > 0. ) {
	    maxd = d;
    }
    float att = 0.;
    
    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );
    
    float dm = MAX, e = 0.;
    vec3 col, detailCol, nDetail;
    
    // normal and intersection 
#ifndef HIDE_TERRAIN
    if( renderTerrainDetail ) {   
        res = renderTerrain( ro, rd, intersection, nDetail );
        if( res.x < 0. && d < 0. ) {
	        return vec4(0);
        }
        if( res.x >= 0. ) {
            maxd = pow(res.x/4000.,4.)*50.;
            e = -10.;
        }
        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);
        n = normalize( mix( n, nDetail, mixDetailColor ) );
    } else 
#endif        
    if( renderSeaDetail ) {    
        float attsea, mf = smoothstep(.5,1.,d);

        renderSea( ro, rd, nDetail, attsea );

        n = normalize(mix( nDetail, n, mf ));
        att = mix( attsea, att, mf );
    } else {
        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));
#ifndef HIDE_TERRAIN
        if( d < 1500. ) {
            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);
        }
#endif  
    }
    
    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  
    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  
    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; 
                 
    // color  
#ifndef HIDE_TERRAIN
    if(renderTerrainDetail ) {
        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);
		d = 0.;
    }   
#endif
     
    if( mixDetailColor < 1. ) {
        if( e < .45 ) {
            // sea
            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    
        } else {
            // planet (land) far
            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );
            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );
            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;

            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;
            vec3 landColor2 = RING_COLOR_1 * land2;
            vec3 mixedLand = (landColor1 + landColor2)* 0.5;
            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));

            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;
#ifdef HIGH_QUALITY
            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );
#endif
        }
    }
    
    if( mixDetailColor > 0. ) {
        col = mix( col, detailCol, mixDetailColor );
    }
        
#ifdef DISPLAY_LLAMEL
    if(renderTerrainDetail ) {
        vec3 rom = terrainTransformRo(ro),
        rdm = terrainTransform(rd);
        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );
        if( d > 0. ) {
            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );
            col = mix(col, llamel.rgb, llamel.a);
        }
    }
#endif
    
    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );
    if( d > 0. ) { 
        float shadow;
		vec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);
        col *= shadow; 
        col = mix( col, clouds.rgb, clouds.w );
    }
    
    float m = MAX;
    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );

 	return vec4( col, 1. ); 
}

// Function 1974
float iBox(Obj obj, vec3 o, vec3 r, inout vec3 n)
{
    // Calculate bounds
    vec3 bmin = obj.pos - obj.dim.xyz / 2.0;
    vec3 bmax = obj.pos + obj.dim.xyz / 2.0;
    
    // Calculate minima and maxima
    vec3 tmin3 = (bmin - o) / r;
    vec3 tmax3 = (bmax - o) / r;
    
    // Make sure they're the right way around
    if (tmin3.x > tmax3.x) swap(tmin3.x, tmax3.x);
    if (tmin3.y > tmax3.y) swap(tmin3.y, tmax3.y);
    if (tmin3.z > tmax3.z) swap(tmin3.z, tmax3.z);
    
    // Calculate minimum and maximum distance
    float tmin = max3(tmin3);
    float tmax = min3(tmax3);
    float t = min(tmin, tmax);
    
    // Skip over box if we're out of bounds
    if (tmin > min3(tmax3) || max3(tmin3) > tmax)
        t = -1.0;
    
    // Calculate sphere normal
    vec3 p = o + r * t;
    vec3 sn = 2.0 * (p - obj.pos) / obj.dim.xyz;
    
    // Calculate normal
    n = step(vec3(1.0 - EPS * 2.0), abs(sn)) * mix(vec3(-1.0), vec3(1.0), step(vec3(0.0), sn));
    
    // Return distance
    return t;
}

// Function 1975
float udBox( vec3 p, vec3 b) {
  return length(max(abs(p)-b,0.0));
}

// Function 1976
float d_sphere(vec3 p, float r) {
    return length(p) - r;
}

// Function 1977
float torusSDF( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 1978
bool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out float dist, out vec3 normal ) {
    vec3  ds = ro - sph.xyz;
    float bs = dot( rd, ds );
    float cs = dot(  ds, ds ) - sph.w*sph.w;
    float ts = bs*bs - cs;
	
    if( ts > 0.0 ) {
        ts = -bs - sqrt( ts );
		if( ts>0. ) {
			normal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );
			dist = ts;
			return true;
		}
    }

    return false;
}

// Function 1979
vec3 SphereMap( vec2 uv )
{
    // uv is in the range [0,1)
    // map this range onto a unit sphere, with a uniform distribution of points
    
    // use the fact that the surface area of a slice of a sphere is the same
    // as the surface area of a cylinder with the height of the slice and the
    // radius of the sphere
    
    // wrap the 2D space around a cylinder
    float h = uv.y*2.-1.; // height up cylinder
    float a = uv.x*tau; // angle around the circle
    
    // position on the circular slice of the cylinder at this height
    vec2 v = vec2(sin(a),cos(a));
    
    // project onto the corresponding slice of the sphere
    // by multiplying by width of sphere at this height
    v = v * sqrt(1.-h*h);
    
    return vec3(v,h);
}

// Function 1980
vec2 intersectPlane(Ray r, vec4 n,float index){
    vec3 norm = normalize(n.xyz);
	float t = -( n.w + dot(r.o,norm)) / dot(r.d,norm);
	if(t>=0.){
		return vec2(t,index);
		
	}else{
		return vec2(MAX_VALUE,-1);
	}
}

// Function 1981
vec4 iCappedCone( in vec3  ro, in vec3  rd, 
                  in vec3  pa, in vec3  pb, 
                  in float ra, in float rb )
{
    vec3  ba = pb - pa;
    vec3  oa = ro - pa;
    vec3  ob = ro - pb;
    
    float m0 = dot(ba,ba);
    float m1 = dot(oa,ba);
    float m2 = dot(ob,ba); 
    float m3 = dot(rd,ba);

    //caps
         if( m1<0.0 ) { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) return vec4(-m1/m3,-ba*inversesqrt(m0)); }
    else if( m2>0.0 ) { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) return vec4(-m2/m3, ba*inversesqrt(m0)); }
    
    // body
    float m4 = dot(rd,oa);
    float m5 = dot(oa,oa);
    float rr = ra - rb;
    float hy = m0 + rr*rr;
    
    float k2 = m0*m0    - m3*m3*hy;
    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );
    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return vec4(-1.0);

    float t = (-k1-sqrt(h))/k2;

    float y = m1 + t*m3;
    if( y>0.0 && y<m0 ) 
    {
        return vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y));
    }
    
    return vec4(-1.0);
}

// Function 1982
float sdCylinder(in vec4 p,in vec2 h ) {
                  return max(length(p.xzw)-h.x, abs(p.y)-h.y );
                }

// Function 1983
bool spherehitd(vec3 sp, float r, vec3 ro, vec3 rd, out float t1, out float t2)
{
    return true; 
}

// Function 1984
float dBox(vec3 p, vec3 s) {
    return length(max(abs(p)-s, 0.0));
}

// Function 1985
Intersection intersectSphere(in Ray ray, in Sphere sphere)
{
    Quadric quadric;
    quadric.p = sphere.p;
    quadric.r = vec3(sphere.r);
    
    return intersectQuadric(ray, quadric);
}

// Function 1986
float sdAtmosphere(vec3 p) {
    float time = iTime;
    tRotate(p.yz, time);
    vec3 q = p;
    tFan(q.xz, 12.);
    float d = sdBox(q - vec3(.3, 0, 0), vec3(.01));
    tRotate(p.yx, time);
    q = p;
    tFan(q.yz, 12.);
    d = opU(d, sdBox(q - vec3(0, .23, 0), vec3(.01)));
    tRotate(p.xz, time);
    q = p;
    tFan(q.yx, 12.);
    d = opU(d, sdBox(q - vec3(0, .16, 0), vec3(.01)));
    
    return d;
}

// Function 1987
float distToSphere(Sphere s, vec3 inPos)
{
return length(inPos - s.pos) - s.r;
}

// Function 1988
bool calc_sphere(vec3 point, vec3 ray_origin, vec3 ray_dir, vec3 offset, out vec3 norm, out float q)
{
	vec3 ixyz = floor(point)-offset; 
	vec3 centre = ixyz + 0.5; //sphere centres
	centre.x += rand(ixyz.xy);
	centre.y += rand(ixyz.xz);
	//centre.z += random3(ixyz.yz);
	
	vec3 d = point - centre; //from centres of spheres to point
	bool found = false;
	
	float t;

	float r = 0.05 + 0.35*rand(ixyz.xy+150.0*ixyz.z);
	
	float A = dot(ray_dir, ray_dir);
	float B = 2.0*dot(ray_dir, d);
	float C = dot(d, d) - r*r;
	
	float discriminant = B*B - 4.0*A*C;
	
	if( discriminant > 0.0 )
	{
		t = -(B + sqrt(discriminant))/(2.0*A);
		
		vec3 p = d + t*ray_dir; //vector from centre to surface of sphere
		
		q = dot(point + t*ray_dir - ray_origin, ray_dir);
		if(q > 0.0)
		{
			norm = normalize(p);
			found = true;
		}
	}    
	
	return found;
}

// Function 1989
float planeSDF(vec3 p, vec4 n)
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 1990
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;
}

// Function 1991
float distPlane( vec3 p, vec3 n, float y )
{
	return dot(p-vec3(0,y,0),n);
}

// Function 1992
float plane(vec3 pos)
{
	return length(max(abs(pos)-vec3(12.0,0.5,12.0),0.0));
}

// Function 1993
float fPlane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 1994
float sdCappedCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
    vec2 v = vec2( c.z*c.y/c.x, -c.z );
    vec2 w = v - q;
    vec2 vv = vec2( dot(v,v), v.x*v.x );
    vec2 qv = vec2( dot(v,w), v.x*w.x );
    vec2 d = max(qv,0.0)*qv/vv;
    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));
}

// Function 1995
float sphere(vec3 p, float d)
{ 
    return length(p) - d/2.0;  
}

// Function 1996
vec3 randomSphereDirection(inout float seed) {
    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);
    float phi = h.y;
	return vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// Function 1997
float sphereSdf(vec3 p, float r)
{
    p.z -= r;
    return length(p) - r;
}

// Function 1998
float torusZ (in vec3 p, in float r1, in float r2) {
	vec2 q = vec2 (length (p.xy) - r1, p.z);
	return length (q) - r2;
}

// Function 1999
float
capped_cylinder8_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;
    return min( max(d), 0.0 ) + length8( max(d, 0.0) );
}

// Function 2000
vec2 raySphere (vec3 sphereCenter, float sphereRadius, vec3 origin, vec3 ray) {
    vec3 offset = origin - sphereCenter;
    float a = 1.0;
    float b = 2.0 * dot(offset, ray);
    float c = dot(offset, offset) - sphereRadius * sphereRadius;
    float d = b * b - 4.0 * a * c;

    if (d > 0.0) {
        float s = sqrt(d);
        float dstToSphereNear = max(0.0, (-b - s) / (2.0 * a));
        float dstToSphereFar = (-b + s) / (2.0 * a);
        if (dstToSphereFar >= 0.0) {
            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);
        }

    }
    return vec2(100.00, -1.0);
}

// Function 2001
vec3 cosineSampleHemisphere(float u1, float u2)
{
    const float r = Sqrt(u1);
    const float theta = 2 * kPi * u2;
 
    const float x = r * Cos(theta);
    const float y = r * Sin(theta);
 
    return Vector3(x, y, Sqrt(Max(0.0f, 1 - u1)));
}

// Function 2002
float box(in vec3 pos, in vec3 b) {  
  vec3 d = abs(pos) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 2003
float iPlane(vec3 ro, vec3 rd, vec4 pla) {
	return (-pla.w - dot(pla.xyz, ro)) / dot(pla.xyz, rd);
}

// Function 2004
float sphere(vec3 p) {
	return length(p) - 2.5;
}

// Function 2005
float sdBox( in vec4 p, in vec4 b )
{
    vec4 d = abs(p) - b;
    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));
}

// Function 2006
vec3 getHemisphereCosineSample(vec3 n, out float weight) {
    float cosTheta2 = getRandom();
    float cosTheta = sqrt(cosTheta2);
    float sinTheta = sqrt(1. - cosTheta2);
    
    float phi = 2. * M_PI * getRandom();
    
    // Spherical to cartesian
    vec3 t = normalize(cross(n.yzx, n));
    vec3 b = cross(n, t);
    
	vec3 l = (t * cos(phi) + b * sin(phi)) * sinTheta + n * cosTheta;
    
    // Sample weight
    float pdf = (1. / M_PI) * cosTheta;
    weight = (.5 / M_PI) / (pdf + 1e-6);
    
    return l;
}

// Function 2007
float Plane( vec3 p, vec4 plane ) 
{
    return dot( p, plane.xyz ) + plane.w;
}

// Function 2008
vec3 random_in_usphere( in vec3 seed )
{
	float x = hash( seed.x );
    float y = min( hash( seed.y ), sqrt( 1. - x * x ) );
    float z = min( hash( seed.z ), sqrt( 1. - x * x - y * y ) );
    
    vec3 p = 2. * vec3( x, y, z ) - 1.;
    
    return mix( p, normalize( p ), step( 1., dot( p, p ) ) );
}

// Function 2009
float SphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return -1.0;
	return -b - sqrt( h );
}

// Function 2010
RayTraceResult RayTracePlane(in Ray ray, vec3 pos, vec3 nn)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
	float m = dot(nn, ray.dir);
    if (abs(m) < epsilon)
    {
        return res;
    }
    
    vec3 L = ray.org - pos;
    float d = dot(nn, L);
    float t = -d/m;
    if (t > epsilon)
    {
        res.nn = nn;
        res.pos = ray.org + t*ray.dir;
        res.t = t;
    }
    
    return res;
}

// Function 2011
vec2 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim, out vec3 norm) 
{
    vec3 m = 1.0/ray;
    vec3 n = m*(ctr-pos);
    vec3 k = abs(m)*dim;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tmax = max( max( t1.x, t1.y ), t1.z );
	float tmin = min( min( t2.x, t2.y ), t2.z );
	
	if( tmax > tmin || tmin < 0.0) return vec2(INFINI, 0.);

    norm = -sign(ray)*step(vec3(tmax),t1);
    
    /********************************** AA process ******************************/
    /*** visual outside contour ***/
    // (tmin-tmax) represents the depth reach by the ray into the shape. 
    // larger is the diff between tmax and tmin, deeper into the shape goes the ray
    // when d is small (<1), we use it as a transparency factor
    //
    // As the cube surface is flat and has no thickness (no transparency factor can be used when thickness = 0)
    // we must apply a correction (corr) when visual angle is flat to emphasis the AA effect.
    float corr = dot(ray,-norm);
    corr = (.05+corr)*(1.2-corr*corr*corr);
    float d = (tmin-tmax)*iResolution.x*corr;
    
    #ifdef SPLIT
    if(gl_FragCoord.x > iResolution.x/2.+2.) return vec2(tmax, d);
    #endif
    
    /*** inside the visual border's shape, where 2 faces connect (crest). ***/
    // normals must be rotated progressively from one face to the other
    // so the shading of each face are mixed when distance to the crest is small
    // half way rotation is done (other half way is done when other face is hit)
    t1 *= 1.-step(vec3(tmax),t1);
    float tmed = max( max( t1.x, t1.y ), t1.z );	// finding 2nd closest hit
    vec3 norMed = -sign(ray)*step(vec3(tmed),t1);	// normal of the adjacent face
    corr = dot(ray,-norMed);
    corr = (.05+corr)*(1.2-corr*corr*corr);			// flat angle correction
    norm = mix(norMed, norm, .5*min(1.,.5*(tmax-tmed)*corr*iResolution.x/tmax)+.5);	// mixing the 2 normals
    
    d = max(0.,d);
    return vec2(tmax, d);
}

// Function 2012
float sdBox (vec3 p, vec3 s){
	p = abs(p) - s;
	return max(p.x, max(p.y, p.z));
}

// Function 2013
float sphereSDF(vec3 p, float r) {
    return length(p) - r;
}

// Function 2014
vec4 intersectPlane(vec3 rayPos, vec3 rayDir, vec3 n, float d)
{
	float t = -(dot(rayPos, n) + d) / dot(rayDir, n);
	return vec4(n * sign(dot(rayDir, n)), t);
}

// Function 2015
float sphere(vec3 p, vec3 rd, float r){
	float b = dot( -p, rd ),
	  inner = b*b - dot(p,p) + r*r;
	return inner < 0. ?  -1. : b - sqrt(inner);
}

// Function 2016
float rayPlaneIntersect( Ray ray, vec4 plane )
{
	float f = dot( ray.dir, plane.xyz );
	
	float t = -( dot( ray.org, plane.xyz ) + plane.w );
	t /= f;
	
	return t;
}

// Function 2017
Intersection raySphereIntersection(in Ray ray, in Sphere sphere)
{
	Intersection i;
	i.hit = false;
	
	vec3 centerToOrigin = ray.origin - sphere.center;
	float dotProduct = dot(ray.direction, centerToOrigin);
	float squareRootTerm = pow(dotProduct, 2.0) - pow(length(centerToOrigin), 2.0) + pow(sphere.radius, 2.0);
	if (squareRootTerm < 0.0)
	{
		return i;
	}
	
	float distanceToHit = (-dotProduct) - sqrt(squareRootTerm);
	if (distanceToHit < 0.0)
	{
		return i;
	}
	i.position = ray.origin + (ray.direction * distanceToHit);
	i.normal = normalize(i.position - sphere.center);
	i.material = sphere.material;
	i.hit = true;
	return i;
}

// Function 2018
vec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {
	
    vec3 oc = o - ctr;
    
    float a = dot(d, d);
    float b = 2.0*dot(oc, d);
    float c = dot(oc, oc) - r*r;
        
    float D = b*b - 4.0*a*c;
    
    if (D > 0.0) {
        
        float sqrtD = sqrt(D);
        
        float t = 0.5 * ( -b - sqrtD ) / a;
        
        if (t >= 0.0) {
            vec3 n = normalize( oc + t*d );
            return vec4(n, t);	
        }
        
    }
    
    return miss;
		
}

// Function 2019
float sdfCylinder( vec3 p, vec2 h, mat4 t )
{
  p = vec3(t * vec4(p, 1));
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2020
float sdTorus( vec3 p, vec2 t )
{
    //t = vec2( ring radius, ring thickness )
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 2021
vec3 randomInUnitSphere(inout float seed)
{
    vec3 h = hash3(seed) * vec3(2.0, 6.28318530718, 1.0) - vec3(1.0, 0.0, 0.0);
    float phi = h.y;
    float r = pow(h.z, 1.0/3.0);
	return r * vec3(sqrt(1.0 - h.x * h.x) * vec2(sin(phi), cos(phi)), h.x);
}

// Function 2022
float PrRoundBox2Df (vec2 p, vec2 b, float r)
{
  return length (max (abs (p) - b, 0.)) - r;
}

// Function 2023
vec4 sdSphere(in vec3 p, float r, vec3 color){
    return vec4(color.rgb, length(p) - r);
}

// Function 2024
float sphere( vec3 p, float s )
{
    return length( p ) - s;
}

// Function 2025
float sphere_sdf( vec3 p, float r)
{
  return length(p) - r;
}

// Function 2026
vec3 intersectPlane(vec3 ori, vec3 dir, vec3 planePos) {
    
    vec3 planeNormal = vec3(0, 1, 0);
    
	float a = dot(dir, planeNormal);
   
    float distToPlane = dot(ori-planePos, planeNormal);
    vec3 intersectPt = ori + dir*abs(distToPlane/a);
    
    return intersectPt;
}

// Function 2027
float sphere(vec3 p, float r) {
	return length(p) - r;
}

// Function 2028
float cone(vec3 u,vec2 c//c must be normalized
){return dot(c,vec2(u.x,length(u.yz)));}

// Function 2029
vec4 texture3Plane(sampler2D tex,vec3 norm, vec3 pos, float mip)
{
    vec4 texel = vec4(0);
    
    texel = mix(texel, texture(tex, pos.yz, mip), abs(norm.x));
    texel = mix(texel, texture(tex, pos.xz, mip), abs(norm.y));
    texel = mix(texel, texture(tex, pos.xy, mip), abs(norm.z));
    
    return texel;
}

// Function 2030
float tracePlane(vec3 pos, vec3 dir, out vec3 normal) 
{
    float t = (-1.2 - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {
        return INF;
    }
    normal = vec3(0, 1, 0);
    return t;
}

// Function 2031
vec4 ray_plane(vec3 ro, vec3 rd, vec4 plane){
    float a = dot(plane.xyz, rd);
    float b = dot(plane.xyz, ro) - plane.w;
    return vec4(plane.xyz, max(0.0, -b/a));
}

// Function 2032
vec4 getSphere( int id, float t )
{
    #if AA>1
    vec4 s1 = texelFetch( iChannel1, ivec2(id,0), 0 );        
    vec4 s2 = texelFetch( iChannel1, ivec2(id,1), 0 );
    return mix( s1, s2, t );
    #else
    return texelFetch( iChannel1, ivec2(id,0), 0 );
    #endif
}

// Function 2033
float dBox(vec3 p, vec3 s){
    return length(max(abs(p)-s,0.));
}

// Function 2034
float uSphereDist(in Ray ray, in Sphere sphere) {
    return abs(length(ray.origin - sphere.pos) - sphere.radius);
}

// Function 2035
float distSphere(vec3 pos)
{
    vec3 spp = spPos;
    spp.y *= sin(iTime);
    return length(pos - spp) - size;
}

// Function 2036
float sdCone( vec3 p, vec2 c )
{
    return dot(c,vec2(length(p.xy),p.z));
}

// Function 2037
float deTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  return length(q)-t.y;
}

// Function 2038
float deTorus( vec3 p, vec2 t )
{
	p.y -= height;
	p = rotateMat * p;
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 2039
vec3 gPlaneCabin( vec3 p, float window_radius_scale )
{
	float d = 0.05; // for near stuff
	float c = sdPlaneCabin( p, window_radius_scale );
	return normalize( vec3( sdPlaneCabin( p + vec3( d, 0.0, 0.0 ), window_radius_scale ) - c,
							sdPlaneCabin( p + vec3( 0.0, d, 0.0 ), window_radius_scale ) - c,
							sdPlaneCabin( p + vec3( 0.0, 0.0, d ), window_radius_scale ) - c ) );
}

// Function 2040
float conecaps(vec3 p, vec3 a, vec3 b, float r1, float r2) {

    vec3 ba = b-a;
    vec3 dir = ba;
    vec3 pa = p-a;

    float len2 = dot(dir,dir);
    float len = sqrt(len2);
    dir /= len;

    float diff = (r1-r2);

    float secproj = dot(pa,dir);
    vec3 tp2 = a + dir*secproj;
    float mm = length(tp2-p);

    float extside = max(0.001,sqrt(len2-diff*diff));
    float nn = mm*diff/extside;
    float finalprog = (secproj-nn)/len;

    finalprog = clamp(finalprog,0.0,1.0);

    float dist = length(pa-ba*finalprog) - mix(r1,r2,finalprog);

    return dist;
}

// Function 2041
float sdBox( vec3 p, vec3 b ) {
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2042
float d_sphere( vec2 p, float radius )
{
    return length(p) - radius;
}

// Function 2043
float SphereVal(vec3 p, vec4 s)
{
    return length(p - s.xyz) - s.w;
}

// Function 2044
float sd_sphere(vec3 p, float radius) {
	return length(p) - radius;
}

// Function 2045
vec3 fCylinder4(vec3 p, vec3 yOffset, vec3 r, vec3 height) {
	vec3 d = length(p.xz) - r;
	d = max(d, abs(p.y-yOffset) - height);
	return d;
}

// Function 2046
float shadow_box(vec2 fragCoord, vec4 box, float border)
{
    vec2 clamped = clamp(fragCoord, box.xy, box.xy + box.zw);
    return clamp(1.25 - length(fragCoord-clamped)*(1./border), 0., 1.);
}

// Function 2047
vec2 sphere_trace( vec2 O, vec2 d, float radius, vec2 C )
{
	float tp = dot( C - O, d ); // P = project C on line (O,d)
	vec2 P = O + d * tp;
	float h_sqr = lensqr( P - C );
	float radius_sqr = radius * radius;
	if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere
//	bool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?
	float dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)
//	if ( start_inside )	return vec2(FLT_MAX,tp+dt);	// order In->O->If // record only far hit If
//	if ( tp < 0.0 )	return vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit
	return vec2( tp - dt, tp + dt ); // record 2 hits In, If
}

// Function 2048
float sdPlaneInf(vec3 pos, float y)
{
 	return pos.y - y;   
}

// Function 2049
float sdTorus( vec3 p, vec2 t )
{
    //tyre look?
   p = NormalSinPowWarpTest(p, 13.0, 0.051, 10.0);
  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;
}

// Function 2050
float sdBox(in vec2 p, in vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);
}

// Function 2051
float obj_quartertorus( vec3 p, vec3 center, vec2 t ){
    vec3 tp = p-center;
    tp.x = max(tp.x,0.0);
    tp.y = max(tp.y,0.0);
    // okay that honestly isn't what I set out to make, but it saves me several other shapes..!
	vec2 q = vec2(length(tp.xy)-t.x,tp.z);
	return length(q)-t.y;
}

// Function 2052
vec3 Sample_Sphere(float s0, float s1, vec3 normal)
{	 
    vec3 sph = Sample_Sphere(s0, s1);

    vec3 ox, oz;
    OrthonormalBasisRH(normal, ox, oz);

    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);
}

// Function 2053
float sphere(vec3 p, float radius){
    return length(p)-radius;

}

// Function 2054
float sdRoundBox( in vec3 p, in vec3 b, in float r )
{
    vec3 q = abs(p) - b;
    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;
}

// Function 2055
RayHit TracePlane(in vec3 origin, in vec3 direction)
{
  RayHit result;
  float maxDist = 150.0;
  float t = 0.0, dist = 0.0;
  vec3 rayPos;
  eFlameDist=10000.0;
  for ( int i=0; i<RAYSTEPS; i++ )
  {
    rayPos =origin+direction*t;
    dist = MapPlane( rayPos);

    if (abs(dist)<0.003 || t>maxDist )
    {                
      result.hit=!(t>maxDist);
      result.depth = t; 
      result.dist = dist;                              
      result.hitPos = origin+((direction*t));   
      result.winDist = winDist;
      result.engineDist = engineDist;
      result.eFlameDist = eFlameDist;
      result.blackDist = blackDist;
      result.bombDist = bombDist;
      result.bombDist2 = bombDist2;
      result.missileDist = missileDist;
      result.frontWingDist = frontWingDist;
      result.rearWingDist = rearWingDist;
      result.topWingDist = topWingDist;
      break;
    }
    t += dist;
  }

  return result;
}

// Function 2056
bool intersectSphere(vec3 C, float r, vec3 rayOrigin, vec3 direction, inout float nearDistance, inout float farDistance) { vec3 P = rayOrigin; vec3 w = direction; vec3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }

// Function 2057
vec3 sphere(in vec3 ro, in vec3 rd, in vec3 center, in float radius) {
    vec3 oc = ro-center;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - radius*radius;
    float h = b*b - c;
    float sqmh = sqrt(max(h,0.));
    return vec3(-b-sqmh, -b+sqmh, h);
}

// Function 2058
float sdTorus82(float dt, vec3 p, vec2 t)
{
    return sdTorus82(p, dt*t);
}

// Function 2059
float oSphere( in vec3 pos, in vec3 nor, in vec4 sph )
{
    vec3  di = sph.xyz - pos;
    float l  = length(di);
    float nl = dot(nor,di/l);
    float h  = l/sph.w;
    float h2 = h*h;
    float k2 = 1.0 - h2*nl*nl;

    float res = max(0.0,nl)/h2;
    if( k2 > 0.0 ) 
        res = pow( clamp(0.5*(nl*h+1.0)/h2,0.0,1.0), 1.5 );

    return res;
}

// Function 2060
float bgSphereSlimes(vec3 p)
{
    p = mod(p, 0.75)-0.2;
    p.y -= 0.2;
    p.x -= 0.2;
    float t = cos(iTime)*0.3;
    p.xy *= rotate((t+p.x/p.y)*PI*1.4);
    return length(p) - 0.2 - abs(sin(p.x+iTime*1.2))*0.03 - abs(cos(p.y+iTime*1.2))*0.03;
}

// Function 2061
float sphere(vec3 p, float r) { return length(p) - r; }

// Function 2062
float sdCylinder (in vec3 p, float h, float r)
{
    float d = length (p.xz) - r;
    d = max (d, abs(p.y) - h);
    return d;
}

// Function 2063
vec3 normalPlane(in vec3 pos)
{
	// normal of plane
    return vec3(0.0, 1.0, 0.0);
}

// Function 2064
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {
    float t = INF;
    float b = dot(pos, dir);
    float D = b * b - dot(pos, pos) + r * r;
    if (D < 0.0) {
        return INF;
    } else {
        t = -b - sqrt(D);
        if (t > 0.0) {
            normal = normalize(pos + t * dir);
            return t;
        }
        t = -b + sqrt(D);
        if (t < 0.0) {
            return INF;
        } else {
            normal = normalize(pos + t * dir);
            return t;
        }            
    }
}

// Function 2065
float sphereHit(vec3 sc, float sr, vec3 ro, vec3 rd) {
    
    float a = dot(rd, rd);
    vec3 L = ro - sc;
    float b = 2.0 * dot(rd, L);
    //float c = dot(ro, ro) - 2.0 * dot(sc, ro) + dot(sc, sc) - sr * sr;
    float c = dot(L, L) - sr * sr;
    //return solveQuadratic(a, b, c);
    float discrim = b*b - 4.0*a*c;

    if (discrim < 0.0) return inf;
    //return min(-b-sqrt(discrim)
    return (-b - sqrt(discrim)) / (2.0 * a);
}

// Function 2066
bool intersectSphere( float radius, vec3 center, Material m, Ray ray, out Intersection hit ) {
	vec3 oc = center - ray.origin;
    float l = dot(ray.direction, oc);
    float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);
    if (det < 0.0) return false;

    // Find the Closer of Two Solutions
             float len = l - sqrt(det);
    if (len < 0.0) len = l + sqrt(det);
    if (len < 0.0) return false;
    vec3 pos = ray.origin + len * ray.direction;
    hit = Intersection(len, pos, (pos - center) / radius, m);
    return true;
}

// Function 2067
vec3 sphereColor(float T)
{
    vec3 whiteHotColor = vec3(.88, .98, .97);
    vec3 hotColor  = vec3(.95, .78, .23); 
    vec3 coolColor = vec3(0.43, .01, .003);
    vec3 noheatColor = vec3(.0);
    return mix(mix(noheatColor, coolColor,
                   smoothstep(200., 1000., T)),
               mix(hotColor, whiteHotColor, 
                    smoothstep(8000., 10000., T)),
                smoothstep(1000., 8000., T));

}

// Function 2068
bool sameHemisphere(in vec3 a, in vec3 b){
	return (a.z*b.z>0.0);
}

// Function 2069
float dfSphere(vec3 p, float rad)           {return length(p) - rad;}

// Function 2070
float plane(vec3 p, float height) {
    return p.z - height;
}

// Function 2071
float sdCylinderXZ( vec3 p, vec2 h ) {
  return max( length(p.xz)-h.x, abs(p.y)-h.y );
}

// Function 2072
void get_facet_bbox(ivec3 f, ivec3& bbox_min, ivec3& bbox_max) {
    bbox_min = decode_vertex(f.x); bbox_max = decode_vertex(f.x);
     ivec3 p = decode_vertex(f.y); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);
           p = decode_vertex(f.z); bbox_min = min(bbox_min, p); bbox_max = max(bbox_max, p);
}

// Function 2073
void moveInsideBox(inout vec3 localPosition, inout ivec3 chunk, vec3 directionSign, vec3 direcctionBound) {
    const float eps = 0.0000001;
    if (localPosition.x * directionSign.x >= direcctionBound.x - eps) {
        localPosition.x -= directionSign.x;
        chunk.x += int(directionSign.x);
    } else if (localPosition.y * directionSign.y >= direcctionBound.y - eps) {
        localPosition.y -= directionSign.y;
        chunk.y += int(directionSign.y);
    } else if (localPosition.z * directionSign.z >= direcctionBound.z - eps) {
        localPosition.z -= directionSign.z;
        chunk.z += int(directionSign.z);
    }
}

// Function 2074
bool insideBox(vec2 p, vec4 b) {
    return boxDist(p, b) <= 0.;
}

// Function 2075
bool RayBox( in vec3 p, in vec3 dir, in vec3 pos, in vec3 edge, out float t
		//	inout vec2 startend,
		//	inout vec3 nor, 
		//	inout vec3 hit
		   )
{
	float fix=.00001;
	vec3 minim=pos-edge*.5;
	vec3 maxim=pos+edge*.5;
	vec3 inv_dir = vec3(1.)/dir;
	vec3 omin = ( minim - p ) * inv_dir;
	vec3 omax = ( maxim - p ) * inv_dir;
	vec3 maxi = max ( omax, omin );
	vec3 mini = min ( omax, omin );
	vec2 startend;
	startend.y = min ( maxi.x, min ( maxi.y, maxi.z ) );
	startend.x = max ( max ( mini.x, 0.0 ), max ( mini.y, mini.z ) );
	float rayhit=0.;
	if (startend.y-startend.x>fix) rayhit=1.;

	t = startend.x;
	
//	hit=p+startend.x*dir; //intersection point
/*	
	// get normal
		nor=vec3(0.,0.,-1.);
		if (abs(hit.x-minim.x)<fix) nor=vec3( 1., 0., 0.);
		if (abs(hit.y-minim.y)<fix) nor=vec3( 0., 1., 0.);
		if (abs(hit.z-minim.z)<fix) nor=vec3( 0., 0., 1.);
		if (abs(hit.x-maxim.x)<fix) nor=vec3(-1., 0., 0.);
		if (abs(hit.y-maxim.y)<fix) nor=vec3( 0.,-1., 0.);
*/
	return rayhit>0.5;
}

// Function 2076
bool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return false;

	return true;
}

// Function 2077
int intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius, out float near, out float far)
{
    vec3 oc = origin - center;
    float a = dot(direction, direction);
    float b = 2. * dot(oc, direction);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4. * a * c;
    if (disc < 0.) {
        // no intersection?
        return 0;
    }

    near = (-b - sqrt(disc)) / (2. * a);
    far = (-b + sqrt(disc)) / (2. * a);
    return 1;
}

// Function 2078
vec4 skybox_color(vec3 p)
{
    return vec4(0.7, 0.8, 0.9, 1.0);
}

// Function 2079
vec4 createPlane(vec3 normal, float dist)
{
	return vec4(normalize(normal), dist);
}

// Function 2080
vec4 spheresdf(vec3 pos) {
    vec3 center = vec3(-3, 0, 1.5);
    float d = length(pos - center);
    vec3 norm = (pos - center) / d;
    return vec4(norm, d - 1.0);
}

// Function 2081
vec3 skyBox(vec3 rayDir, float blur)
{
    vec3 skyColor1 = vec3(0.5,0.5,1.0);
    vec3 skyColor2 = vec3(1.0,1.0,1.0);
    vec3 groundColor1 = vec3(1.0,0.4,0.3);
    vec3 clouds1 = noise(rayDir, vec3(4.0, 6.0, 3.5),  vec3(0.0, 1.0, 2.0), vec3(0.1, 0.0, 0.0));
    vec3 clouds2 = noise(rayDir + clouds1*0.2, vec3(2.0, 3.0, 2.5),  vec3(0.0, 1.0, 2.0), vec3(-0.1, 0.05, 0.0))*0.5+0.5;
    float c = (clouds2.x+clouds2.y+clouds2.z)*0.05;
    
    vec3 skyColor = mix(skyColor2+c, skyColor1, rayDir.y);
    float m = smoothstep(0.0, blur, (rayDir.y+0.5)+sin(rayDir.x*20.0)*0.01+sin(rayDir.z*15.0)*0.01);
    return mix(groundColor1, skyColor, m);
}

// Function 2082
float torus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 2083
vec3 intersectSphere(vec3 o, vec3 l, float r)
{
	vec3 res = vec3(0.0f);
	float l_dot_o = dot(l, o);
	float lo = length(o);
	float n = l_dot_o*l_dot_o - lo*lo + r*r;

	// 2 potential intersections
	if (n > 0.0f)
	{
		float sqn = sqrt(n);
		vec2 v = vec2(-l_dot_o + sqn, -l_dot_o - sqn); // v.x >= v.y, because sqrt(n) >= 0

		if (v.x >= 0.0)
		{
			if (v.y >= 0.0)
			{
				res.z = 2.0f;
				res.x = v.y;
				res.y = v.x;
			}
			else
			{
				res.z = 1.0f;
				res.x = v.x;
			}
		}
	}
	// 1 intersection, this means the ray grazes the sphere shell we consider we missed the in this case
	//else if (n == 0.0f)
	//{
	//	res.z = 1.0f;
	//	res.x = -l_dot_o;
	//}
	return res;
}

// Function 2084
void boxFold(inout vec3 z, inout float dz) 
{
    z = clamp(z, -FoldingLimit, FoldingLimit) * 2.0 - z;
}

// Function 2085
float sdBox(vec3 boxCenter, vec3 boxRadii, vec3 p) {
    vec3 q = boxRadii - abs(p - boxCenter);
    return length(min(q, 0.0)) - max( min(min(q.x, q.y), q.z), 0.0 );
}

// Function 2086
float dplane(vec3 p, vec3 o, vec3 n, float h)
{
    vec3 op = p-(o+n*h);
    return dot(op,n);
}

// Function 2087
vec2 MapBoxes(vec3 rayPoint)
{
    rayPoint += vec3(0.0, 0.0, -3.0);
    float a = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(4.2, 2.4, 7.2));
    float b = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(3.8, 2.0, 6.5));
    float c = SDFBox(rayPoint + vec3(-0.0, 0.4, -9.0), vec3(2.45, 0.45, 10.0)) - 0.4;
    
    vec3 rep = vec3(0.0, 0.0, 1.3);
    vec3 p = mod(rayPoint, rep) - rep * 0.5;
    float vent = SDFBox(p + vec3(0.0, -2.5, 0.0), vec3(3.1, 0.8, 0.4));
    float scene = max(max(max(a, -b), -c), -vent);
    float d = SDFBox(rayPoint + vec3(-5.2, 0.4, -0.0), vec3(2.45, 0.45, 3.0)) - 0.4;
    
    scene = max(scene, -d);
    
    
    
    return vec2(scene, TYPE_BOX);
}

// Function 2088
bool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )
{
	vec3 oc = ro - cen;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - rad*rad;
	float h = b*b - c;
	if( h<0.0 ) return false;
	float t = -b - sqrt( h );
    return t>0.0 && t<tmax;
}

// Function 2089
float box(vec3 p, vec3 b){
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 2090
float sdBox(vec3 p, vec3 b) {
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.1;
}

// Function 2091
float box(vec2 uv, float col, float x, float y, float w, float h){
    float o = 0.0;
    if( uv.x > x && uv.x < x+w && uv.y > y && uv.y < y + h){
     o = col;   
    }
	return o;
}

// Function 2092
Box createBox(vec3 center, vec3 radius)
{
    Box b;
    b.center = center;
    b.radius = radius;
    return b;
}

// Function 2093
float sdCone( in vec3 p, in vec2 c )
{
    // c is the sin/cos of the angle
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

// Function 2094
Hit intersectPlane(Plane p, Ray r)
{
    float dotnd = dot(p.n, r.d);
    if (dotnd > 0.) return noHit;

    float t = -(dot(r.o, p.n) + p.d) / dotnd;
    return Hit(t, p.n, p.m);
}

// Function 2095
float sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 2096
float cylinder(vec3 p, vec2 di) {
  vec2 crd = vec2(length(p.xy), p.z);
  crd.y = abs(crd.y)-di.y;
  crd.x -= di.x;
  
  float sg = sign(crd.x)+sign(crd.y);
  return sg == 2. ? length(crd) : max(crd.x,crd.y);
}

// Function 2097
float intersect_plane(vec3 ro, vec3 rd){
    ro -= plane.position;
    float t = (-ro.y/rd.y);
    vec3 pos = ro+rd*t;
    
    if(abs(plane.position.x-pos.x) > plane.width)  return -1.0;
    if(abs(plane.position.z-pos.z) > plane.height) return -1.0;
    return t;
}

// Function 2098
vec3 cone(float s) {
    float a = 3.14159*hash(s + 23.34);
    float b = 6.28138*hash(s + 93.34);
    
    return vec3(sin(a)*sin(b), sin(a)*cos(b), cos(a));
}

// Function 2099
float torusDistance(vec3 rayPosition, vec3 torusPosition, vec2 torusSize) {
    vec2 d = vec2( length(rayPosition.xz - torusPosition.xz) - torusSize.x, rayPosition.y - torusPosition.y);
    return length(d) - torusSize.y;
}

// Function 2100
vec3 getPlanetColor(in vec3 p, vec4 id) {
    float lava = smoothNoise(p*1.5*(5.*id.z) );
    return blackBodyColor((.5+id.x)*(1. - pow(lava,2.*id.y))); // todo: le faire sur une constante
}

// Function 2101
float sdTorus(vec3 p, vec2 t)
{
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 2102
vec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 ird, in Box box, out vec3 nor ) 
{
    vec3 n = ird*(box.cen-ro);
    vec3 k = abs(ird)*box.rad;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );

	nor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

	return vec2( tN, tF );
}

// Function 2103
define fillbox0(X,Y,v)  {V=abs(U-vec2(X,Y)*R+vec2(15,-15)); if(max(V.x,V.y)<15.) O=vec4(v);}

// Function 2104
float sdPlane(vec3 p) { return p.z + 1.0; }

// Function 2105
vec4 digitUIBox(int idx) {
    
    const vec2 digitRad = vec2(0.35, 0.5);
    
    return vec4(textCenter.x + (float(idx - 1))*textSize,
                textCenter.y,
                digitRad*textSize);

}

// Function 2106
vec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)
{
    ro -= org;
    float b = dot(rd, ro);
    float c = dot(ro, ro) - rad * rad;
    float desc = b * b - c;
    if (desc < 0.)
        return vec2(1, 0);
	desc = sqrt(desc);
    return vec2(-b - desc, -b + desc);
}

// Function 2107
vec3 sample_hemisphere_cos_weighted(vec3 n, float Xi1, float Xi2) 
{
    float theta = acos(sqrt(1.0-Xi1));
    float phi = 2. * PI * Xi2;

    return local_to_world(spherical_to_cartesian(1.0, phi, theta), n);
}

// Function 2108
float sdCone(vec2 c, float h, vec3 p)
{
  float q = length(p.xz);
  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);
}

// Function 2109
vec3 zcone(vec3 x){
    return vec3(0,0,length(x.xy));
}

// Function 2110
bool intersectSphere(in Ray r, in Sphere s, inout HitTest test) {
	vec3 o = r.origin - s.pos;
	float v = dot(o, r.dir);
	if(v > 0.) return false;
    
	float disc = (s.radius * s.radius) - (dot(o, o) - (v * v));
	
	if(disc < 0.) return false;
	
    float q = sqrt(disc);
	float dist = length(o);
    float d = dist-q;
    
    //float f = step(0.0, -d);
    //d = d * (1.-f) + (f * INF);
    if (d > test.dist) { return false; }
    
    test.dist = d;
    test.normal = ((r.origin + (r.dir * d)) - s.pos) / s.radius;
    return true;
}

// Function 2111
float dsphere(in vec3 pos, in vec3 o, in float r)
{
    return length(pos - o) - r;
}

// Function 2112
float sdSphere( in vec3 p, in float r )
{
    return length(p)-r;
}

// Function 2113
vec1 planeDebug2(vec3 o,vec3 d,vec3 c,inout float t,vec2 n//ray,ray,curPlane,time,domainLengths
){if(n.x<length(c)&&n.y>0.//debug plane //n.x=o.y n.y=d.y
 ){float p=tracePlane(c,c*t,o,d)//;if(abs(p)<9.){
  ;p=df(o+d*p).x
  ;float q=fract(p*8.)/(p*p*p*p+4.)
  ;p=mix(q,mix(1.,.5,q),step(p,0.))
  ;return p*.5;}//}
 ;return 0.;}

// Function 2114
vec2 sphereUV(vec3 center, float r, vec3 p)
{
    vec3 pDir = normalize(p - center);
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    float theta = acos(dot(pDir, worldUp));
    // If p is located at the positive part of z axis, then phi is 0-180.
    // If p is located at the negative part of z axis, then phi is 180-360.
    vec3 xzDir = normalize(vec3(pDir.x, 0.0, pDir.z));
    float phi = acos(dot(xzDir, vec3(1.0, 0.0, 0.0)));

    if(pDir.z < 0.0)
    {
        phi = phi + PI;
    }

    return vec2(theta / PI, phi / (2.0 * PI));
}

// Function 2115
float checkersGradBox( in vec2 p )
{
    // filter kernel
    vec2 w = fwidth(p) + 0.001;
    // analytical integral (box filter)
    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;
    // xor pattern
    return 0.5 - 0.5*i.x*i.y;                  
}

// Function 2116
float dist_torus(vec3 pos) {
	vec3 n = vec3(sin(iTime), sin(iTime), cos(iTime));
    float r = 2.0;
    vec3 on_circle = normalize(cross(n, cross(pos, n))) * r;
    return length(on_circle-pos) - .5;
}

// Function 2117
ISObj intersectPlane(in Plane p, in Ray r, in int id) {
    float t = - (p.offset + dot(r.origin, p.normal)) / dot(r.dir, p.normal);
    
    if (t < 0.0) {
        return ISObj(DIST_MAX, OBJECT_TYPE_NONE, -1);
    } else {
    	return ISObj(t, OBJECT_TYPE_PLANE, id);
    }

}

// Function 2118
vec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz ,0.);
  vec4 y = textureLod( sam, p.zx ,0.);
  vec4 z = textureLod( sam, p.xy ,0.);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 2119
float sdSphere( vec3 p, float s )
{
  return length(p) - s;
}

// Function 2120
bool plane_hit(Ray ray, in vec3 po, in vec3 pn, out float dist) {
    float denom = dot(pn, ray.direction);
    if (denom > MIN_FLOAT) {
        vec3 p0l0 = po - ray.origin;
        float t = dot(p0l0, pn) / denom;
        if(t >= MIN_FLOAT && t < MAX_FLOAT){
			dist = t;
            return true;
        }
    }
    return false;
}

// Function 2121
Intersection TraceSpheres( vec3 rayStart, vec3 rayDirection )
{
    Intersection intersection = noIntersection;

    for ( int i=0; i < spheres.length(); i++ )
    {
        vec3 centre = spheres[i].centre; // do everything relative to ray source
        vec3 pc = centre - rayStart;
        float radius = spheres[i].radius;
        float rad2 = radius*radius;
        
        float hyp2 = dot(pc,pc);
        float adj = dot(pc,rayDirection); // closest point on ray to sphere centre
        float opp2 = hyp2-adj*adj;
        
		if ( opp2 < rad2 )
        {
			float t = adj - sqrt( rad2 - opp2 );
            
            if ( t < intersection.dist && t > 0. )
            {
                intersection.dist = t;
                intersection.pos = rayStart + t*rayDirection;
                intersection.normal = normalize(intersection.pos - centre);
                intersection.material = spheres[i].material;
                intersection.uvw = (intersection.pos - centre)/radius;
            }
        }
    }
    
    return intersection;
}

// Function 2122
surface_t box_sdf(vec3 query_point, int id, vec3 dimensions) {
	vec3 q = abs(query_point) - dimensions;  
  
    return surface_t(
        id,
        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)
    );
}

// Function 2123
void plane_slice(in vec4 a, in vec4 b, out vec3 l0, out vec3 l1) {
    vec3 q = vec3(
        a.z*b.x - a.x*b.z,
        a.z*b.y - a.y*b.z,
        a.z*b.w - a.w*b.z
        );
    l0 = q / a.z;
    l1 = -q / b.z;
}

// Function 2124
float starplane(vec3 dir) { 
    float screenscale = 1.0 / iResolution.x;

    // Project to a cube-map plane and scale with the resolution of the display
    vec2 basePos = dir.xy * (0.5 / screenscale) / max(1e-3, abs(dir.z));
         
	const float largeStarSizePixels = 20.0;
    
    // Probability that a pixel is NOT on a large star. Must change with largeStarSizePixels
	const float prob = 0.97;
    	
	float color = 0.0;
	vec2 pos = floor(basePos / largeStarSizePixels);
	float starValue = hash2(pos);
    
    // Big stars
	if (starValue > prob) {

        // Sphere blobs
		vec2 delta = basePos - largeStarSizePixels * (pos + vec2(0.5));
		color = max(1.0 - length(delta) / (0.5 * largeStarSizePixels), 0.0);
		
        // Star shapes
        color *= 1.0 / max(1e-3, abs(delta.x) * abs(delta.y));
        
        // Avoid triplanar seams where star distort and clump
        color *= pow(abs(dir.z), 12.0);
    } 

    // Small stars

    // Stabilize stars under motion by locking to a grid
    basePos = floor(basePos);

    if (hash2(basePos.xy * screenscale) > 0.997) {
        float r = hash2(basePos.xy * 0.5);
        color += r * (0.3 * sin(iTime * (r * 5.0) + r) + 0.7) * 1.5;
    }
	
    // Weight by the z-plane
    return color * abs(dir.z);
}

// Function 2125
bool cylinderHit(const in Ray ray,  const in Cylinder cyl, inout Hit rec) {
  float cxmin, cymin, czmin, cxmax, cymax, czmax;
  if (cyl.A.z < cyl.B.z) {
      czmin = cyl.A.z - cyl.r; czmax = cyl.B.z + cyl.r;
  } else {
      czmin = cyl.B.z - cyl.r; czmax = cyl.A.z + cyl.r;
  }
  if (cyl.A.y < cyl.B.y) {
      cymin = cyl.A.y - cyl.r; cymax = cyl.B.y + cyl.r;
  } else {
      cymin = cyl.B.y - cyl.r; cymax = cyl.A.y + cyl.r;
  }
  if (cyl.A.x < cyl.B.x) {
      cxmin = cyl.A.x - cyl.r; cxmax = cyl.B.x + cyl.r;
  } else {
      cxmin = cyl.B.x - cyl.r; cxmax = cyl.A.x + cyl.r;
  }
    /*
  if (optimize) {
   if (start.z >= czmax && (start.z + dir.z) > czmax) return;
   if (start.z <= czmin && (start.z + dir.z) < czmin) return;
   if (start.y >= cymax && (start.y + dir.y) > cymax) return;
   if (start.y <= cymin && (start.y + dir.y) < cymin) return;
   if (start.x >= cxmax && (start.x + dir.x) > cxmax) return;
   if (start.x <= cxmin && (start.x + dir.x) < cxmin) return;
  }
*/

    vec3 AB = cyl.B - cyl.A;
    vec3 AO = ray.origin - cyl.A;
    vec3 AOxAB = cross(AO, AB);
    vec3 VxAB  = cross(ray.direction, AB);
    float ab2 = dot(AB, AB);
    float a = dot(VxAB, VxAB);
    float b = 2. * dot(VxAB, AOxAB);
    float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);
    float d = b * b - 4. * a * c;
    if (d < 0.)
        return false;
    
    rec.dist = (-b - 1. * sqrt(d)) / (2. * a);
    /*
    float[2] coef = float[2](1., -1.); 
    for(int i=0; i<2; i++){
        float time = (-b - coef[i] * sqrt(d)) / (2. * a);
        rec.dist[i] = time;
        rec.ptnt[i] = ray.origin + ray.direction * time;
        rec.nrm[i] = normalize(rec.ptnt[i] - vec3(0., rec.ptnt[i].y, 0.));
    }*/
    return true;
}

// Function 2126
vec3 uvFromBox(in Box box, in vec3 position, in int mode) {
	vec3 relativePosition = position - box.position;
    vec3 normalRel = relativePosition / box.size;

    //fragColor = vec4(box.color, 1);
    float maxFactor = max(max(abs(normalRel.x), abs(normalRel.y)), abs(normalRel.z));
    if(maxFactor < 1.0-TEXTURE_ACCURACY) {
        return vec3(0);
    }
    normalRel /= maxFactor;

    float x = normalRel.x;
    float y = normalRel.y;
    float z = normalRel.z;
    float boxXY = box.size.x/box.size.y;
    float boxYZ = box.size.y/box.size.z;
    float boxXZ = box.size.x/box.size.z;
    float boxYX = 1.0/boxXY;
    float boxZY = 1.0/boxYZ;
    float boxZX = 1.0/boxXZ;
    
    if(mode == STRETCH) {
        boxXY = boxYX = boxXZ = boxZX = boxYZ = boxZY = 1.0;
    }
    else if(mode == TILE_BIG) {
        if(boxXY > 1.0) {
            boxXY = 1.0;
        } else if(boxYX > 1.0) {
            boxYX = 1.0;
        }
        if(boxXZ > 1.0) {
            boxXZ = 1.0;
        } else if(boxZX > 1.0) {
            boxZX = 1.0;
        }
        if(boxZY > 1.0) {
            boxZY = 1.0;
        } else if(boxYZ > 1.0) {
            boxYZ = 1.0;
        }
    }
    else if(mode == TILE_SMALL) {
        if(boxXY < 1.0) {
            boxXY = 1.0;
        } else if(boxYX < 1.0) {
            boxYX = 1.0;
        }
        if(boxXZ < 1.0) {
            boxXZ = 1.0;
        } else if(boxZX < 1.0) {
            boxZX = 1.0;
        }
        if(boxZY < 1.0) {
            boxZY = 1.0;
        } else if(boxYZ < 1.0) {
            boxYZ = 1.0;
        }
    }

    if(abs(abs(x)-1.0) < TEXTURE_ACCURACY) {
        return vec3(mod((-z*0.5+0.5)*boxZY,1.0),mod((y*0.5+0.5)*boxYZ,1.0),1);
    }
    else if(abs(abs(y)-1.0) < TEXTURE_ACCURACY) {
        return vec3(mod((x*0.5+0.5)*boxXZ,1.0),mod((z*0.5+0.5)*boxZX,1.0),1);
    }
    else if(abs(abs(z)-1.0) < TEXTURE_ACCURACY) {
        return vec3(mod((x*0.5+0.5)*boxXY,1.0),mod((y*0.5+0.5)*boxYX,1.0),1);
    }
    return vec3(0);
}

// Function 2127
vec4 StrangeSphere( vec3 pos ) 
{
	//float move = sin(3.*time ) *.5 - 10.;
	float move = 10.;
	float rad = 10.;
	vec3 newPos = pos - vec3( .0+move, 5., 50.);
	vec4 val2 = mapSphere(newPos, rad );
	vec3 p = newPos;
	//float magicVal = 4.5 + 2.9*sin(1.*time);
	float magicVal = 2.5;
	float fact = .45;
	//if (val2.w < .1 )	// Optimization, don't try the strange thing outside the sphere
	for (int i = 0; i < 6; i++)
	{
		float t = float(i)*.11+0.004*iTime;
		float c = cos(t);
		float s = sin(t);
		mat2 m = mat2(c,-s,s,c);
		p.xy = m*p.xy;
			      
		rad *= fact;
		p.x = p.x - rad*2.;
		vec3 p2 = p;
		p2.xzy=mod (p.xzy+rad, rad*magicVal) -rad;
		//p2.z=mod (p.z+rad, rad*2.5) -rad;
		//p2=mod (p+rad, rad*2.5) -rad;

		//vec3 p2 = p;
		vec4 sph = mapSphere( p2, rad );
		//val2= combine(val2, sph);
		val2 = subst(val2, sph);
		//val2 = sph;
	}
	return val2;
}

// Function 2128
float repBox(vec3 p, vec3 c, vec3 b)
{
 	vec3 q = mod(p,c)-0.5*c;
    return box(q, b);
}

// Function 2129
void boxFold(inout vec4 z, vec3 r) {
	z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;
}

// Function 2130
float sdPlane( vec3 p, vec4 n )
{
  // n must be normalized
  return dot(p, n.xyz) + n.w;
}

// Function 2131
floor plane (intersection happens behind camera)
    {
        vec2 uv = findParallelogramUV(o,d,wsQuad);
        if(uv.x>0.0 && uv.x<1.0 &&
           uv.y>0.0 && uv.y<1.0 )
        {
            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);
        	vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);
            cScene = alphaBlend(cScene,cTest,0.5);
        }
    }

// Function 2132
vec3 traceSphereGrid( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal, const int maxsteps ) {  
	float m = 0.;
    if (ro.y < .5 || rd.y < 0.) {
        vec3 ros = ro.y < .5 ? ro : iPlaneInt(ro, rd, .5);
        if (length(ros.xz) < 11.) {
            vec3 roe = iPlaneInt(ro, rd,rd.y < 0. ?0.:.5);
            vec3 pos = floor(ros);
            vec3 rdi = 1./rd;
            vec3 rda = abs(rdi);
            vec3 rds = sign(rd);
            vec3 dis = (pos-ros+ .5 + rds*.5) * rdi;
            bool b_hit = false;

            // traverse grid in 2D
            vec2 mm = vec2(0);
            for (int i = ZERO; i<maxsteps; i++) {
                float l = length(pos.xz+.5);
                if (pos.y > .5 || pos.y < -1.5 || l > 11.) {
                    break;
                }
                else if ( l > 2. && pos.y > -.5 && pos.y < 1.5 ) {
                    float d = iSphere(ro-sphereCenter(pos.xz), rd, dist, normal, .25);
                    if (d < dist.y) {
                        m = 2.;
                        dist.y = d;
                        break;
                    }
                }	
                vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);
                dis += mm*rda;
                pos += mm*rds;
            }
        }
    }
	return vec3(dist, m);
}

// Function 2133
float sdBox(vec3 p, vec3 s){
	p = abs(p) - s;
    return max(p.x, max(p.y,p.z));
}

// Function 2134
float vertEllipticCylinderAppSurface(vec3 view, vec2 radiuses, float height){
    float res=0.f;
    vec3 zAxis=vec3(0,0,1);
	res+= ellipseAppSurface(view, zAxis, radiuses, false);
	res+= vertEllipticTubeAppSurface(view, radiuses, height);
    return res;
}

// Function 2135
Hit intersectCone(Cone cone, Ray r)
{
    Material blue = Material(vec3(0., 0., 1.), 0.0);
    Material green = Material(vec3(0., 1., 0.), 0.0);
    
    vec3 cone_o_to_ray_o = cone.origin - r.o;
    float b_sphere = dot(r.d, cone_o_to_ray_o);
    float det_sphere = b_sphere * b_sphere - dot(cone_o_to_ray_o, cone_o_to_ray_o) + cone.height * cone.height;
    if (det_sphere < 0.) return noHit;
	// Now we inside sphere
    vec3 co = r.o - cone.origin;

    float a_cone = dot(r.d,cone.direction)*dot(r.d,cone.direction) - cone.theta*cone.theta;
    float b_cone = 2. * (dot(r.d,cone.direction)*dot(co,cone.direction) - dot(r.d,co)*cone.theta*cone.theta);
    float c_cone = dot(co,cone.direction)*dot(co,cone.direction) - dot(co,co)*cone.theta*cone.theta;
    
    float det_cone = b_cone*b_cone - 4.*a_cone*c_cone;
    if (det_cone > 0.) {
    	// Now we inside cone
        det_cone = sqrt(det_cone);
        
        float t1 = (-b_cone - det_cone) / (2. * a_cone);
        float t2 = (-b_cone + det_cone) / (2. * a_cone);

        float t = t1;
        if (t < 0. || t2 > 0. && t2 < t) t = t2;
        if (t < 0.) return noHit; // ???

        vec3 cp = r.o + t * r.d - cone.origin;
        float h = dot(cp, cone.direction);
        
        vec3 n = normalize(cp * dot(cone.direction, cp) / dot(cp, cp) - cone.direction);
        
        if (h > 0. && h < cone.height) 
            return Hit(t, n, green); // Return cone
        
        if (h > cone.height) {
        	// Endless cone here, let cut off by sphere ending
            det_sphere = sqrt(det_sphere);
            float t_sphere = b_sphere - det_sphere;
            if (t_sphere < 0.) t_sphere = b_sphere + det_sphere;
            if (t_sphere < 0.) return noHit;
            
            vec3 n_sphere = (r.o + t_sphere*r.d - cone.origin) / cone.height;
			
            return Hit(t_sphere, n_sphere, blue); // Return bottom part
        } else return noHit; // Beyond spot light
        
    } else 
        return noHit; // Beyond spot light
}

// Function 2136
float GetDistanceBox( const in vec3 vPos, const in vec3 vDimension )
{
	vec3 vDist = abs(vPos) - vDimension;
  	float fDistance =  min(max(vDist.x,max(vDist.y,vDist.z)),0.0) + length(max(vDist,0.0));

	return fDistance;	
}

// Function 2137
vec3 Sample_Cos_Hemisphere ( float3 wi, float3 N, out float pdf,
                             inout float seed ) {
  vec2 u = Sample_Uniform2(seed);
  float3 wo = Reorient_Hemisphere(
                normalize(To_Cartesian(sqrt(u.y), TAU*u.x)), N);
  pdf = PDF_Cosine_Hemisphere(wo, N);
  return wo;
}

// Function 2138
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; //
}

// Function 2139
float fTorus(vec4 p4, out vec2 uv) {

    // Torus distance
    // We want the inside and outside to look the same, so use the
    // inverted outside for the inside.
    float d1 = length(p4.xy) / length(p4.zw) - 1.;
    float d2 = length(p4.zw) / length(p4.xy) - 1.;
    float d = d1 < 0. ? -d1 : d2;

    // Because of the projection, distances aren't lipschitz continuous,
    // so scale down the distance at the most warped point - the inside
    // edge of the torus such that it is 1:1 with the domain.
    d /= PI;

    // UV coordinates over the surface, from 0 - 1
    uv = (vec2(
        atan(p4.y, p4.x),
        atan(p4.z, p4.w)
    ) / PI) * .5 + .5;

    return d;
}

// Function 2140
vec4 planets(vec2 p, float fbeat, vec4 planet_color, vec4 moon_color)
{
    float swell = 0.4 + frac(fbeat) / 5.0;

    vec2 moon_pos = vec2(sin(iTime - 0.8), cos(iTime));
    vec4 moon = length(moon_pos - vec2(-1.0)) > 0.5
        ? moon_color * inv(circle(p, moon_pos, 0.2, 0.01))
        : black;

    vec4 planet = planet_color * inv(circle(p, vec2(0.0), swell, 0.01));

    return above(moon, planet);
}

// Function 2141
float fCylinder(vec3 p, float r, float height) {
   float d = length(p.xz) - r;
   d = max(d, abs(p.y) - height);
   return d;
}

// Function 2142
vec3 draw_planets(vec2 uv,vec3 v,vec3 planet_to_be_attacked_position,float planet_to_be_attacked_radius){
  vec4 red_planet=planet(uv,planet_to_be_attacked_position,planet_to_be_attacked_radius,time);
  red_planet.xyz-=0.3;
  float is_planet=sat(pow(sat(1.-sat(red_planet.w*0.5-0.3)),1.))*sat((length(red_planet)-0.10)*1000.) ;
  return clamp(3.*red_planet.xyz,0.,1.)*is_planet+v*(1.-is_planet);
}

// Function 2143
void RRCone(float3 p0, float r0, float3 p1, float r1, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)
{
 float3 l  = p1-p0;
 float ld = length(l);
 l=l/ld;
 float d=r0-r1;
 float sa = d/ld;
 float h0=r0*sa;
 float h1=r1*sa;
 float cr0 = sqrt(r0*r0-h0*h0);
 float cr1 = sqrt(r1*r1-h1*h1);
 float3 coneP0=p0+l*h0;
 float3 coneP1=p1+l*h1;
    
    float t0=MAX_RAY_LENGTH;
    {
        float t1;
        float3 uv1;
        float3 n1;
	    RCone(coneP0,cr0,coneP1,cr1,rp0,rd,t1,uv1,n1);
        if(t1<t0)
        {
            t0=t1;
            uv=uv1;
            n=n1;
        }
	    RSph(p0,r0,rp0,rd,t1,uv1,n1);
        if(t1<t0)
        {
            t0=t1;
            uv=uv1;
            n=n1;
        }
	    RSph(p1,r1,rp0,rd,t1,uv1,n1);
        if(t1<t0)
        {
            t0=t1;
            uv=uv1;
            n=n1;
        }
    }
    t=t0;
    
}

// Function 2144
float Sphere(vec3 p, vec3 rd, float r){//A RAY TRACED SPHERE
	float b = dot( -p, rd );
	float inner = b * b - dot( p, p ) + r * r;
	if( inner < 0.0 ) return -1.0;
	return b - sqrt( inner );
}

// Function 2145
float sphere(vec3 position, float r) {
	return length(position) - r;
}

// Function 2146
vec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2, out float pdf ) {
    pdf = 1.0 / (2.0 * PI);
    vec2 r = vec2(Xi1,Xi2)*TWO_PI;
	vec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));
	return dot(dr,n) * dr;
}

// Function 2147
float sdCheap2DBox ( float2 O, float2 b ) { return vmax(abs(O) - b); }

// Function 2148
float sdCylinder(vec3 p, vec3 a, vec3 b, float r, float offX, float offY, float offZ) {
	a.x += offX;
    b.x += offX;
    
    a.y += offY;
    b.y += offY;
    
    a.z += offZ;
    b.z += offZ;
    
    vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap) / dot(ab, ab);
    
    vec3 c = a + t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-.5)-.5)*length(ab);
    float e = length(max(vec2(x, y), 0.));
    float i = min(max(x, y), 0.);
    
    return e+i;
}

// Function 2149
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	vec2 r = hash2();
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 2150
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)
{
 //dot(pos+t*dir,pos+t*dir) == r*r // 
 //dot(pos,pos)+2*t*dot(pos,dir)+t*t*dot(dir,dir) == r*r
 //t*t+2.0*t*dot(pos,dir)+dot(pos,pos)-r*r == 0
     float b = dot(pos,dir);
         float D = b*b - dot(pos,pos) + r*r;
     if(D<0.0){
         return INF;
     }
     float t=-b-sqrt(D);
     if(t>0.0){
         normal = normalize(pos + t*dir);
         return t;
     }
     t=-b+sqrt(D);
     if(t<0.0){
         return INF;
     }
     normal = normalize(pos + t*dir);
     return t;
}

// Function 2151
vec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {
    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes
    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes
    vec3 k = abs(m)*boxSize;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
    if( tN>tF || tF<0.0) return vec2(miss); // no intersection
    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    return vec2( tN, tF );
}

// Function 2152
float sdPlane( vec3 p, vec4 n )
{
  
  return dot(p,n.xyz) + n.w;
}

// Function 2153
float sdTorus( in vec3 ro, in vec3 rd, in vec2 torus )
{
	float Ra2 = torus.x*torus.x;
	float ra2 = torus.y*torus.y;
	
	float m = dot(ro,ro);
	float n = dot(ro,rd);
		
	float k = (m - ra2 - Ra2)/2.0;
	float a = n;
	float b = n*n + Ra2*rd.z*rd.z + k;
	float c = k*n + Ra2*ro.z*rd.z;
	float d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;
	
    //----------------------------------

	float p = -3.0*a*a     + 2.0*b;
	float q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;
	float r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;
	p /= 3.0;
	r /= 3.0;
	float Q = p*p + r;
	float R = 3.0*r*p - p*p*p - q*q;
	
	float h = R*R - Q*Q*Q;
	float z = 0.0;
	if( h < 0.0 )
	{
		float sQ = sqrt(Q);
		z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );
	}
	else
	{
		float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );
		z = sign(R)*abs( sQ + Q/sQ );
	}
	
	z = p - z;
	
    //----------------------------------
	
	float d1 = z   - 3.0*p;
	float d2 = z*z - 3.0*r;

	if( abs(d1)<1.0e-4 )
	{
		if( d2<0.0 ) return -1.0;
		d2 = sqrt(d2);
	}
	else
	{
		if( d1<0.0 ) return -1.0;
		d1 = sqrt( d1/2.0 );
		d2 = q/d1;
	}

    //----------------------------------
	
	float result = 1e20;

	h = d1*d1 - z + d2;
	if( h>0.0 )
	{
		h = sqrt(h);
		float t1 = -d1 - h - a;
		float t2 = -d1 + h - a;
		     if( t1>0.0 ) result=t1;
		else if( t2>0.0 ) result=t2;
	}

	h = d1*d1 - z - d2;
	if( h>0.0 )
	{
		h = sqrt(h);
		float t1 = d1 - h - a;
		float t2 = d1 + h - a;
		     if( t1>0.0 ) result=min(result,t1);
		else if( t2>0.0 ) result=min(result,t2);
	}
	return result;
}

// Function 2154
float box(vec3 p, vec3 b ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2155
vec2 planar_from_sphere(vec3 q) {
    
    q = q * planar_proj;
    return q.xy / q.z;
    
}

// Function 2156
vec2 sphereToCube(in vec3 pointOnSphere)
{
   return vec2(pointOnSphere.x/pointOnSphere.z,pointOnSphere.y/pointOnSphere.z);
}

// Function 2157
float sdSphere( vec3 p, float s )
{
    p = NormalSinPowWarpTest(p, 15.0, -0.1, 3.0);
    return (length(p)-s)*0.25;
}

// Function 2158
vec3 norTorus (vec3 p, vec3 c, vec3 n, vec2 r) {
	p = p-c;
    float z = dot(p,n);
    vec3 q = p-z*n;
    q = normalize(q)*r.x;
    return normalize(p-q);
}

// Function 2159
float DE_Cylinder( vec3 p)
{
  return length(p.xz)-1.;
}

// Function 2160
vec3 nSphere( in vec3 pos, in vec4 sph )
{
    return (pos-sph.xyz)/sph.w;
}

// Function 2161
vec3 getSphereColor( const vec2 grid ) {
	vec3 col = hash3( grid+vec2(43.12*grid.y,12.23*grid.x) );
    return mix(col,col*col,.8);
}

// Function 2162
float cylinder(vec3 p,vec3 po,vec3 n,float r){
    return line(p,po,n)-r;
}

// Function 2163
float sdPlane (in vec3 p, in float h)
{
    return length (vec3 (.0, p.y + h, .0));
}

// Function 2164
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0)) - r
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
}

// Function 2165
float SdfPlane(Object obj, vec3 pos){
    return pos.y - obj.pos.y;
}

// Function 2166
float sdFakeRoundCone(vec3 p, float b, float r1, float r2)
{
    float h = clamp( p.y/b, 0.0, 1.0 );
    p.y -= b*h;
	return length(p) - mix(r1,r2,h);
}

// Function 2167
vec2 boxAnimation(in vec2 uv, in vec2 id, in float frac)
{    
    vec2 rotation = vec2(0,0);
    
    float h = (90. + id.x * 180. + frac * 360. );
    float m = (0. - id.y * 180. + frac * 360. );
      
    float radianHour = radians(mod(h,360.));
    float radianMinute = radians(mod(m,360.));
    
    return vec2(radianHour,radianMinute);
}

// Function 2168
float plane(vec3 p, vec3 n, vec3 pointOnPlane)
{	
  return dot(p, n) - dot(pointOnPlane, n);
}

// Function 2169
float sphere(vec3 ray, vec3 dir, vec3 center, float radius)
{
	vec3 rc = ray-center;
	float c = dot(rc, rc) - (radius*radius);
	float b = dot(dir, rc);
	float d = b*b - c;
	float t = -b - sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return mix(-1.0, t, st);
}

// Function 2170
vec2 iSphere(in vec3 rayOrigin, in vec3 rayDirection, in vec4 sph) {
	//sphere at origin has equation |xyz| = r
	//so |xyz|^2 = r^2.
	//Since |xyz| = rayOrigin + t*rayDirection (where t is the distance to move along the ray),
	//we have rayOrigin^2 + 2*rayOrigin*t*rayDirection + t^2 - r^2. This is a quadratic equation, so:
	vec3 oc = rayOrigin - sph.xyz; //distance ray origin - sphere center
	
	float b = dot(oc, rayDirection);
	float c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.
	
	vec2 t;
	if(h < 0.0) 
		t = vec2(-1.0);
	else  {
		float sqrtH = sqrt(h);
		t.x = (-b - sqrtH); //Again a = 1.
		t.y = (-b + sqrtH);
	}
	return t;
}

// Function 2171
float cylinder(vec3 r,vec3 p, float radius, float height)
{
    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);
}

// Function 2172
bool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 normal, out vec3 hitPos, inout float maxTime)
{
    if (sphere.w <= 0.0)
        return false;
    
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
        return false;
    
    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)
    if (collisionTime > maxTime)
        return false;
    
    // store the collision time as the new max time
    maxTime = collisionTime;
    
	//compute the point of intersection
	hitPos = rayPos + rayDir * collisionTime;    
    
   	// calculate the normal
	normal = hitPos - sphere.xyz;
	normal = normalize(normal); 

	return true;
}

// Function 2173
void surface2x2_perspective_plane(in surface2x2 surf, float y,
	out surface2x1 slice) {
    float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
    float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];

    slice[0] = (B*y + C)*y + A;
    slice[1] = E*y + D;
    slice[2] = F;
}

// Function 2174
float sdBox(vec3 p, vec3 s) {
    p = abs(p)-s;
	return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);
}

// Function 2175
float d_compound_cone_flame( vec2 p, vec2 c )
{
    float time = iTime;
    float d = d_cone1( p, c, time );
    for (float i=0.; i<7.; i+=1.)
    {
        float x = i*0.3;
        vec2 off = vec2(x,
            smoothstep(0.,1.1,x)
            *1.2
            );
        vec2 ofs = vec2(-off.x, off.y);
        vec2 pr = p;
        vec2 ps = p;
        if ((i == 2.0) || (i == 1.0))
        {
            pr = rotate(p+off, 0.15)-off;
            ps = rotate(p+ofs, -0.15)-ofs;
        }
    	d = min(d, d_cone1( pr+off, c, time+i*37. ));
        off.x = -off.x;
    	d = min(d, d_cone1( ps+off, c, time+i*13. ));
    }
    return d;
}

// Function 2176
vec2 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec3 resNor ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

    // convert to ray space
	
	resNor = (txi * vec4(nor,0.0)).xyz;

	return vec2( tN, tF );
}

// Function 2177
float sphere(vec3 ray, vec3 dir, vec3 center, float radius)
{
 vec3 rc = ray;
 float c = dot(rc, rc) - (radius*radius);
 float b = dot(dir, rc);
 float d = b*b - c;
 float t = -b - sqrt(abs(d));
 float st = step(0.0, min(t,d));
 return mix(-1.0, t, st);
}

// Function 2178
float box(vec2 p)
{
	p=abs(p); return max(p.x, p.y);
}

// Function 2179
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return vec2(-1.0);
	return vec2( tN, tF );
}

// Function 2180
float recursiveHallowBox(vec3 p, float size, int i){


while(i>0){
p=abs(p)-size/2.;
size*=1./3.;

p*=-1.;
if(size<max(max(p.x,p.y),p.z)){
if(p.x>=p.y&&p.x>=p.z){
p.x-=size;
}else{
if(p.y>p.x&&p.y>=p.z){
p.y-=size;
}else{
if(p.z>p.x&&p.z>p.y){
p.z-=size;
}}}}
p*=-1.;
p+=size/2.;
i--;
}
return Box(p,size) ;

}

// Function 2181
float sdScallopBox(vec3 p,vec3 center,vec3 size)
{
    size.xz+=2.;
    
    return max(
        sdBox3(p,center,size),
        max(
        	-(length(p.xy-vec2(0,center.y)-size.xy*.5)-size.y*.9),
        	-(length(p.zy-vec2(0,center.y)-size.zy*.5)-size.y*.9)
        )
    );
}

// Function 2182
float box(in vec3 pos, in vec3 dims) {
  vec3 d = abs(pos) - dims;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));   
}

// Function 2183
vec3 apply_atmosphere(float travelDist, vec3 color, vec3 p)
{
    //From this nice article on fog:
    //http://iquilezles.org/www/articles/fog/fog.htm
    //or this PowerPoint from Crytek:
	//GDC2007_RealtimeAtmoFxInGamesRev.ppt p17
	vec3 c_atmosphere = mix(vec3(0.87,0.94,1.0),vec3(0.6,0.80,1.0),clamp(3.0*p.y/length(p.xz),0.,1.));
    float c = 15.68;
    float b = 0.001;

    float cumul_density = c * exp(-1.0*b) * (1.0-exp( -travelDist*1.0*b ))/1.0;
    cumul_density = clamp(cumul_density,0.0,1.0);
    vec3 FinalColor = mix(color,c_atmosphere,cumul_density);
    return FinalColor;
}

// Function 2184
vec4 Scene_SphereA( vec3 vPos )
{
    float xPos = -0.5;
    //flost xPos = -0.5 * sin(iTime)
    vec3 vSphereDomain = vPos - vec3( xPos, 0.0, 2.0 );
    float fSphereRadius = 0.4;
    float fSphereDist = length( vSphereDomain ) - fSphereRadius;
    vec3 vSphereDir = vSphereDomain / fSphereRadius;
    //vec2 vSphereUV = vec2( vSphereDir.y, atan( vSphereDir.z, vSphereDir.x )) * 2.0;
    // Sphere UV code from 	wj
    vec2 vSphereUV = vec2(acos(vSphereDir.y / length(vSphereDir)), atan( vSphereDir.z, vSphereDir.x ))*2.0 ;
    vec4 vSphereResult = vec4( fSphereDist, vSphereUV, 2.0 );    
    
    return vSphereResult;
}

// Function 2185
v0 REbox(v3 ray, v2 u, v2 size
){maxGISize = max(maxGISize,length(size)*ray.w)
 ;ray.xyz = abs(ray.xyz-u) - size
 ;return ray.w*max(max(ray.x,ray.y),ray.z);}

// Function 2186
void boxClip(
    in vec3 boxMin, in vec3 boxMax,
    in vec3 p, in vec3 v,
    out vec2 tRange, out bool didHit
){
    //for each coord, clip tRange to only contain t-values for which p+t*v is in range
    vec3 tb0 = (boxMin - p) / v;
    vec3 tb1 = (boxMax - p) / v;
    vec3 tmin = min(tb0, tb1);
    vec3 tmax = max(tb0, tb1);

    //t must be > tRange.s and each tmin, so > max of these; similar for t1
    tRange = vec2(
        max(max(tmin.x, tmin.y), tmin.z),
        min(min(tmax.x, tmax.y), tmax.z)
    );

    //determine whether ray intersects the box
    didHit = step(tRange.s, tRange.t) > 0.5;
}

// Function 2187
float fCylinderV(vec3 p, float r, float height) {
  float d = length(p.yz) - r;
  d = max(d, abs(p.x) - height);
  return d;
}

// Function 2188
float sdBox( vec2 p, vec2 b )
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) +
         length(max(d,0.0));
}

// Function 2189
vec3 random_hemisphere_direction(vec3 dir,vec2 random_value)
{
	vec3 v = random_sphere_direction(random_value);
	return v * sign(dot(v, dir));
}

// Function 2190
float box(in vec3 rp) {
    return max( -sdBox(rp-vec3(0.,0.,1.), vec3(8.,9,9.)),
                sdBox(rp,vec3(9.,10.,9.)));
}

// Function 2191
vec3 renderPlaneCabin( scene_params_t scene_params, vec2 uv, float aspect, float window_radius_scale
					   , bool skip_shading, inout bool outside_visible )
{
	mat4 world_to_plane = mat4_inverse1( scene_params.plane_to_world );

	Ray plane_view_ray = get_view_ray2( ( uv - vec2( 0.5 ) ) * 2.0, aspect, 1.0 / scene_params.tan_half_fovy, scene_params.plane_render_camera );

	Ray plane_view_ray_plane_local = transform_ray( world_to_plane, plane_view_ray );
	TraceOutput to = tracePlaneCabin( plane_view_ray_plane_local, 1.0, window_radius_scale );

	bool sky = to.t > TMAX;
	outside_visible = sky;

	if ( skip_shading ) return CYAN; // just occlude with flat color

	vec3 p_plane_local = plane_view_ray_plane_local.o + to.t * plane_view_ray_plane_local.d;
	vec3 n_plane_local = gPlaneCabin( p_plane_local, window_radius_scale );

	float ao = 1.0;
	{
		// http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf
		float delta = 0.01;
		float a = 0.0;
		float bb = 1.0;
		for ( int i = 0; i < 5; i++ )
		{
			float fi = float( i );
			float d = sdPlaneCabin( p_plane_local + delta * fi * n_plane_local, window_radius_scale );
			a += ( delta * fi - d ) * bb;
			bb *= 0.5;
		}
		ao = max( 1.0 - 1.2 * a, 0.0 );
	}

	vec3 l = scene_params.sun_direction;

	float soft_shadow = 1.0;
	float soft_shadow_sharpness = 5.0;
	float direct_shadow = 1.0;
	if ( !sky )
	{
		Ray sun_ray;
		sun_ray.o = p_plane_local + n_plane_local * 0.05;
		sun_ray.d = transform_vector( world_to_plane, l );
		TraceOutput tos = tracePlaneCabin( sun_ray, soft_shadow_sharpness, window_radius_scale );
		soft_shadow = tos.shadow;
		direct_shadow = tos.t > TMAX ? 1.0 : 0.0;
	}
	float shadow = mix( soft_shadow, direct_shadow, 0.05 );

	vec3 v = plane_view_ray.d; // same orientation has world space
	vec3 n = transform_vector( scene_params.plane_to_world, n_plane_local );

	vec3 sky_color = vec3( 0.3, 0.4, 0.5 ) * 0.3; // todo: pick this color from BufB

	vec3 albedo = vec3( 1.0, 0.917, 0.866 );
	albedo *= albedo;

	if ( sky ) return sky_color;

	vec3 col = vec3( 0 );
#if 1
	float f = smoothstep( -0.707, 0., dot( n, scene_params.plane_to_world[1].xyz ) );
	// sky lobe
	col += f * SGDiffuseFitted( MakeSG( sky_color * 1.17 * 0.1, vec3( 0, 0, 1 ), 2.133 ), n, albedo );
	// cloud lobe
	col += f * SGDiffuseFitted( MakeSG( vec3( 0.05, 0.05, 0.05  ) * 1.17, vec3( 0, 0, -1 ), 2.133 ), n, albedo );
	// cabin light lobe
	col += ( 1.0 - f ) * SGDiffuseFitted( MakeSG( vec3( 0.05, 0.05, 0.05  ) * 0.2 * 1.17, -scene_params.plane_to_world[1].xyz, 2.133 ), n, albedo );
	// direct sun light
	vec3 kdiffuse_kspecular_roughness = vec3( 0.4, 0.2, 0.8 );
	col += shadow * add_light_contrib( albedo, l, n, -v, sun_Ls * 0.1, 1.0, kdiffuse_kspecular_roughness );
#endif
	vec3 l_plane_local = transform_vector( world_to_plane, l );
	float window_glow_d = sdPlaneWindowVolume( p_plane_local + l_plane_local * 0.2 * iSlider5, window_radius_scale );
	float window_glow = exp( -10.0 * max( 0., -window_glow_d ) );
	col += vec3( window_glow ) * 0.21 * sky_color;

	return col;
}

// Function 2192
float SphereSDF(vec3 p, float r) {
    return length(p) - r;
}

// Function 2193
vec4 fBoxCheap(DAVec3 p,v3 s){
 m4 u=subdabsd(p,s);//mirror clamp
 return maxdm(u);}

// Function 2194
float cone( vec3 p, vec2 c )
{
    p.x = length(p.xz);
    
    float l = dot(c,p.xy);
    
    vec2 q = p.xy-c*l;
    
    // this is optional
    if (q.x < 0.0) {
        l = length(p.xy)*sign(p.y*c.y);
    }
    
    return l;
}

// Function 2195
float Singlebox(vec3 pos) 
{
return length(max(abs(rotXaxis(pos+vec3(0.0,-0.5,0.0),iTime*0.47))-vec3(0.55-0.025*(kl+0.4)*sin(pos.z*pos.x*pos.y*35.)),0.0))-0.025; // Cube
}

// Function 2196
float rSphere(vec3 o, vec3 d,const vec3 c,const float r)
{
    vec3 e= c - o;
    float a= dot(e, d);
    float b= r*r - dot(e,e) + a*a;
    if(b<0.0)
        return -1.;
    return  a- sqrt(b);
  }

// Function 2197
float box(vec3 p, vec3 b){
   return length(max(abs(p)-b, 0.0));
}

// Function 2198
vec2 IntersectBox(vec3 orig, vec3 dir, vec3 pos, vec3 size)
{
    size /= 2.0;
    
    vec3 mins = pos - size;
    vec3 maxs = pos + size;

    vec3 t0 = (mins - orig) / dir;
    vec3 t1 = (maxs - orig) / dir;
    
    vec3 tmp = t0;
    if(dir.x < 0.0){ t0.x = t1.x; t1.x = tmp.x; }
    if(dir.y < 0.0){ t0.y = t1.y; t1.y = tmp.y; }
    if(dir.z < 0.0){ t0.z = t1.z; t1.z = tmp.z; }
    
    float tmin = max(max(t0.x,t0.y),t0.z);
    float tmax = min(min(t1.x,t1.y),t1.z);
    
	return vec2(tmin, tmax);
}

// Function 2199
float sdBox3(vec3 p, vec3 center, vec3 size)
{
    return sdBox2(p-center,size*.5);
}

// Function 2200
vec4 OutlineBox2D(vec2 uv, vec4 st, vec3 color)
{
    float d = sdBox(uv + st.zw, st.xy);
    color = DoOutline(d, color);
    return vec4(color, d);
}

// Function 2201
float sdPlaneY(vec3 p) {
	return abs(p.y);
}

// Function 2202
vec3 squareToUniformSphere(in vec2 s)
{
    vec3 result;
    result.z = s.y * 2.0 - 1.0;
    
    float ringRadius = sqrt(1.0 - result.z * result.z);
    result.xy = vec2(sin(s.x * 2.0 * PI), cos(s.x * 2.0 * PI)) * ringRadius;
  
    return result;
}

// Function 2203
float sphereSize(in float d)
{
	return pix*d*64.0;
}

// Function 2204
v0 cylinderZ(v3 ray,v2 u, v0 radius, v0 height
){maxGISize = max(maxGISize,height*radius*ray.w)
 ;return ray.w*(max(length(ray.xy-u.xy)
 -radius, abs(ray.z-u.z)-height));}

// Function 2205
float box(vec3 p, vec3 b)
{
    	vec3 d = abs(p) - b;
	return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
  return length(max(abs(p) - b, 0.0));
}

// Function 2206
bool intersectSphere(Ray r, vec3 sph_o, out float t) { 
    float t0, t1;
    
    vec3 L = r.origin - sph_o; 
    float a = dot(r.dir, r.dir); 
    float b = 2.0 * dot(r.dir, L); 
    float c = dot(L, L) - 1.0; 

    if (!solveQuadratic(a, b, c, t0, t1)) {
        return false;
    } else {
    	t = mix(mix(-1.0, t1, t1 > 0.0), t0, t0 > 0.0);
    	return (t > 0.0);
    }
}

// Function 2207
vec3 hemispherenormal(vec2 rng) {
  
  float radius = sqrt(rng.x);
  float angle = 2.0 * pi * rng.y;
  
  return vec3(radius * cos(angle), sqrt(1.0 - rng.x), radius * sin(angle));
}

// Function 2208
float wplane(vec3 a) {
  return a.y + 4.0;
}

// Function 2209
float box(vec2 p, vec2 s) {
    
    vec2 q = abs(p)-s;
    return corner(q);
    
}

// Function 2210
float box(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 2211
float box(vec2 p, vec2 c, vec2 sz)
{
	vec2 d = abs(p-c) - sz;
  	return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2212
float halftorus(vec3 p,float s) {
    float len = abs(length(vec2(p.x,min(p.y,0.0)))-s);
    return length(vec3(len,max(p.y,0.0),p.z));
}

// Function 2213
Ball from_sphere(vec2 cen, float r) {
    return Ball(cen, r, false, false);
}

// Function 2214
float sdTorus(in vec3 p, in vec2 t)
{
	vec2 q = vec2(length(p.xz)-t.x, p.y);
	return length(q)-t.y;
}

// Function 2215
vec4 get_nonaxial_plane(int index)
{
    ivec2 addr = ivec2(ADDR_RANGE_NONAXIAL_PLANES.xy) + ivec2(index&127,index>>7);
    return texelFetch(SETTINGS_CHANNEL, addr, 0);
}

// Function 2216
float sdCone(vec3 p, vec2 c)
{
    float q = length(p.xz);
    return dot(c, vec2(q, p.y));
}

// Function 2217
bool intersectBox(vec3 pos, vec3 invDir, vec3 mn, vec3 mx, float t)
{
#if USE_HIERARCHY
    vec3 t0 = (mn - pos) * invDir;
    vec3 t1 = (mx - pos) * invDir;
    
    float tmin = max(max(min(t0.x, t1.x), min(t0.y, t1.y)), min(t0.z,t1.z));
    float tmax = min(min(max(t0.x, t1.x), max(t0.y, t1.y)), max(t0.z,t1.z));
    return tmax >= tmin && tmin < t;
#else
    return true;
#endif
}

// Function 2218
float PrBoxDf (vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}

// Function 2219
float sdSphere( vec3 pos, float r ) {
	return length( pos ) - r;
}

// Function 2220
float SphereSDF(vec3 eye, vec3 p, float r)
{ 
	return distance(p,eye) - r;
}

// Function 2221
float sdSphere( vec3 p, float r)
{
   return (length(p)-r);
}

// Function 2222
float raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {
    // - r0: ray origin
    // - rd: normalized ray direction
    // - s0: sphere center
    // - sr: sphere radius
    // - Returns distance from r0 to first intersecion with sphere,
    //   or -1.0 if no intersection.
    float a = dot(rd, rd);
    vec3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
    if (b*b - 4.0*a*c < 0.0) {
        return -1.0;
    }
    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);
}

// Function 2223
vec3 nSphere4( in vec3 pos )
{
    return normalize( pos*pos*pos );
}

// Function 2224
bool raySphere(vec3 o, vec3 d, vec3 c, float r, inout float t1, inout float t2){
    o -= c, d -= c;
    float C = dot(o,o)-r*r;
    float B = 2.*dot(o,d);
    float A = dot(d,d);
    float D2 = B*B - 4.*A*C;
    if(D2<0.) return false;
    float D = sqrt(D2);
    t1 = (-B - D)/(2.*A);
    t2 = (-B + D)/(2.*A);
    return true;
}

// Function 2225
float boxDist(vec2 p, vec2 size, float radius)
{
  	vec2 d = abs(p) - size - radius;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

// Function 2226
float iPlane(Obj obj, vec3 o, vec3 r, inout vec3 n)
{
    // Normal
    n = vec3(0.0, step(obj.dim.x, o.y) * 2.0 - 1.0, 0.0);
    
    // Intersection distance
    return -o.y / r.y - obj.dim.x;
}

// Function 2227
float cone(vec3 p, float a, float b) {
  return max(length(p.xz)-p.y*a, p.y-b);
}

// Function 2228
float plane(vec3 p){
    return p.y + planeHohe;
}

// Function 2229
float torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)
{
    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
    //  
	//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
	//  
    
    vec3 tk = torusKnot(t, tkp);
    vec3 tkd = torusKnotDerivative(t, tkp);
        
    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);
    //  
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));
    //  
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));
    //  
    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));
}

// Function 2230
float SphereDistance(vec3 localPos, float radius) {
	return length(localPos) - radius;
}

// Function 2231
float roundCone(vec3 p, float r1, float r2, float h) {
    vec2 q = vec2(length(p.xz), p.y);
    float b = (r1 - r2) / h;
    float a = sqrt(1.0 - b * b);
    float k = dot(q, vec2(-b, a));
    if(k < 0.0)
        return length(q) - r1;
    if(k > a * h)
        return length(q - vec2(0.0, h)) - r2;
    return dot(q, vec2(a, b)) - r1;
}

// Function 2232
float scene_primitive_cylinder( Ray ray, vec2 size, inout float t, inout vec3 N )
{
    float R = size.x;
    float omzz = max( 0., 1. - ray.d.z * ray.d.z );
    float ooomzz = 1. / omzz;
    float od = dot( ray.o.xy, ray.d.xy );
    float u = square( dot( ray.o.xy, perp( ray.d.xy ) ) ) * ooomzz;
    float v = max( 0., R * R - u );
    float to = -od * ooomzz - sqrt( v * ooomzz );
    float dz = ray.o.z + sign( ray.d.z ) * size.y;
    float tz = -dz / ray.d.z;
    if( u < R * R )
    {
        if( to >= 0. && to < t && abs( ray.o.z + ray.d.z * to ) < size.y )
        {
            t = to;
            N = vec3( normalize( ray.o.xy + t * ray.d.xy ), 0. );
        }
        vec2 xy = ray.o.xy + ray.d.xy * tz;
        if( tz >= 0. && tz < t && dot( xy, xy ) < R * R )
        {
            t = tz;
            N = sign( ray.o ) * UNIT_Z;
        }
    }
    float shadow = 1.;
    if( ( od < 0. || -sign( ray.d.z ) * ray.o.z >= size.y ) &&
                      sign( ray.d.z ) * ray.o.z < size.y * 0.95 )
    {
        float somzz = sqrt( omzz );
        float K = 2. * max( 0., max( to, tz ) * SCN_RAYCAST_SHADOW_UMBRA_INV );
        float u1 = sqrt( u );
        float u2 = ( od * ray.d.z * ooomzz - ray.o.z ) * somzz;
        float R2 = sqrt( v ) * abs( ray.d.z ) + size.y * somzz;
        shadow = 1. - aaa_interval( K, u1, 2. * R ) *
            aaa_interval( K, u2, 2. * R2 );
    }
    return shadow;
}

// Function 2233
float cylinder (vec3 pos, vec3 p, float radius, float height){
    vec3 diff = p-pos;
    float yd = abs(diff.y);
    return (length(diff.xz)-radius)+smoothstep(yd, -height*0.5, height*0.6);//+smoothstep(abs(diff.y)-height, 0., -height);
}

// Function 2234
float box( vec3 p, vec3 b ) {
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 2235
float GetSphereDist(vec3 p) {
    
    // All spheres will have this radius.
    // Note that there appear to be more spheres along the
    // z-axis due to the repeated rendering that we do below.
    
    // Radius will be in range [0.09, 0.99]
    float radius = (sin(iTime / 6.) + 1.1) * .09;
    
    float minDist = FLOAT_MAX;
    
    // Calculate the distance to the closest sphere.
    // Note that the position of the spheres is randomly generated
    // based on 'i' in the loop below.
    for (float i = 0.; i < SPHERE_AMOUNT; i++) {
        // Every sphere's 'real' position will be at z = Z_PLANE.
        // However, due to the repeated rendering (see below)
        // there appear to be many more spheres.
        vec3 pos = vec3(hash21(i), Z_PLANE);
        
        // Convert values from [0, 1] to [-interval, interval].
        pos.xy = pos.xy * INTERVAL * 2. - INTERVAL;
            
    	// Repeater set-up based on Bekre's UFO shader, retrieved from:
    	// https://www.shadertoy.com/view/4dXGD4
		vec3 repeater = mod(p - pos, REPEAT) - 0.5 * REPEAT;
		float dist = length(repeater) - radius;
        
        if (dist < minDist) {
            minDist = dist;
        }    
    }
    
    return minDist;
}

// Function 2236
float sdTorus82( vec3 p, vec2 t )
{
  vec2 q = vec2(length2(p.yz)-t.x,p.x);
  return length8(q)-t.y;
}

// Function 2237
float sdBox( vec3 p, vec3 b )
{   
  vec3 d = abs(p) - b ;   
  return max(min(d.x, min(d.y, d.z)), .0) + length(max(d, .0));
}

// Function 2238
float
torus44_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length4(p.xy)-torus.x,p.z);
    return length4(q)-torus.y;
}

// Function 2239
float box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}

// Function 2240
float sdSphere(vec3 p, float s) {
   return length(p) - s;
}

// Function 2241
vec2 obj_sphere(in vec3 p, float r)
{
    return vec2(length(p) - r, 0);
}

// Function 2242
float box2D(in vec2 p, in vec2 b)
{
    vec2 d = abs(p) - b*.5;
    return min(max(d.x, d.y), 0.)+
        length(max(d,0.));
}

// Function 2243
vec4 boxmap( sampler2D sam, in vec3 p, in vec3 n )
{
    vec3 m = n*n; m=m*m; m=m*m;
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 2244
float d_box(vec3 v, vec3 p, vec3 b){
	vec3 d = abs(v - p) - b*0.5;
	return max(max(d.x, d.y), d.z);
}

// Function 2245
float sd_capped_cylinder_up(vec3 p, float height, float radius) {
    return sd_capped_cylinder(p - vec3(0.0, height*0.5, 0.0), height*0.5, radius);
}

// Function 2246
bool isinbox(vec2 a,vec2 b,float s){return all(greaterThan(a-b,vec2(0)))&&all(lessThan(a-b,vec2(s)));}

// Function 2247
float sdCylinder(vec3 p, vec3 a, vec3 b, float r) {
    vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap) / dot(ab, ab);
    //t = clamp(t, 0.0, 1.0);
    
    vec3 c = a + t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-0.5)-0.5)*length(ab);
    float e = length(max(vec2(x, y), 0.0));
    float i = min(max(x, y), 0.0);
    return e+i;
}

// Function 2248
bool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,
                     out float t, out vec3 hitPos, out vec3 hitNormal ) 
{
    vec3 N = vec3( pln.A, pln.B, pln.C );
    float NRd = dot( N, ray.d );
    float NRo = dot( N, ray.o );
    float t0 = (-pln.D - NRo) / NRd;
    if ( t0 < tmin || t0 > tmax ) return false;

    // We have a hit -- output results.
    t = t0;
    hitPos = ray.o + t0 * ray.d;
    hitNormal = normalize( N );
    return true;
}

// Function 2249
vec3 shadeBox(Ray ray, Hit scn) {
 
    vec3 n = calcNormal(scn.p);
    vec3 r = reflect(ray.dir, n);
    
    float sh = getShadow(Ray(scn.p+LIGHT_DIR*EPSILON,LIGHT_DIR));
    vec3 d = (vec3(max(dot(LIGHT_DIR,n), 0.)) * sh) * LIGHT_COL + LIGHT_AMB;
    vec3 s = (max(pow(dot(LIGHT_DIR,r), 30.), 0.)*sh) * LIGHT_COL;
    
    return d + s;
    
}

// Function 2250
vec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }

// Function 2251
bool sphere_hit(int i, vec3 ro, vec3 rd, float a, float ooa, float t_min, float t_max, inout hit_record rec) {
    vec3 cen = world[i].center;
    if (i==6) cen.y = 1.5*abs(sin(iTime*3.5));
    vec3 oc = ro - cen; 
    float b = dot(oc, rd);
    float c = dot(oc, oc) - world[i].radius2;
    float disc = b*b - a*c;
    if (disc > 0.0) {
        float sqdisc = sqrt(disc);
        float temp = (-b -sqdisc)*ooa;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = ro + rd*temp;
            rec.objcent = cen;
            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;
            rec.objidx = i;
            get_sphere_uv(rec.p, rec.u, rec.v);
            return true;
        }
        temp = (-b +sqdisc)*ooa;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = ro + rd*temp;
            rec.objcent = cen;
            rec.normal = (rec.p - rec.objcent) * world[i].radiusi;
            rec.objidx = i;
            get_sphere_uv(rec.p, rec.u, rec.v);
            return true;
        }
    }
    return false;
}

// Function 2252
Shape makeSphere(in vec3 c, in float r, int m) { Shape s; s.c = c; s.dim = vec3(r); s.cls = SHAPE_SPHERE; s.mtl = m; return s; }

// Function 2253
int HighesZ_ofSpheres
( float angle,   vec2 fragCoord){
   float Mz = noat;
    int num = -1;
    for(int i =0; i < 132; i ++){
        float tz =  ZPOS_circle( i,angle,fragCoord,isred[i]==0);
        
        if(tz != noat &&tz > Mz){Mz = tz; num=i;}
    }
        
   return num;     
}

// Function 2254
float softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
	
    float res = 1.0;
    if( b>0.0 )
    {
        float h = dot(oc,oc) - b*b - sph.w*sph.w;
        res = clamp( 2.0 * h / b, 0.0, 1.0 );
    }
    return res;
}

// Function 2255
void compute_planes(vec3 p[4], out vec3 n[3]) {
    vec3 e[6];
    compute_edges(p, e);
    n[0] = cross(e[0], e[3]);
    n[1] = cross(e[1], e[4]);
    n[2] = cross(e[2], e[5]);
    float det = 1.0/dot(n[0], e[1]);
    // premultiply the plane orthogonals by the inverse determinant
    n[0] *= det;
    n[1] *= det;
    n[2] *= det;
}

// Function 2256
vec3 planet_color(vec3 p) {
  p = (p * 2.0);
  float t = iTime;
  vec3 q = vec3((fbm3((p + (t * 0.03))) * 0.5), (fbm3(p) * 0.5), (fbm3((p + 33.33)) * 0.5));
  vec3 r = vec3((fbm3(((p + q) + (t * 0.01))) * 0.5), (fbm3((p + q)) * 0.5), (fbm3(((p + q) + 33.33)) * 0.6));
  float f = (fbm3(((p + (5.0 * r)) + (t * 0.02))) * 0.5);
  vec3 col = planet_palette(r.y);
  col = (col * ((clamp((f * f), 0.0, 1.0) * 0.9) + 0.1));
  col = clamp(col, 0.0, 1.0);
  return col;
}

// Function 2257
ct_plane2d ct_plane2d_create(
    in ct_axes axes
){
    float awidth = axes.xmax - axes.xmin;
    float aheight = axes.ymax - axes.ymin;
    
    float daspect = abs(iResolution.y / iResolution.x);
    float waspect = abs(aheight / awidth);
    
    if (daspect > waspect)
    {
        float excess = aheight * (daspect / waspect - 1.0);
        axes.ymax += excess / 2.0;
        axes.ymin -= excess / 2.0;
    }
    
    else if (daspect < waspect)
    {
        float excess = awidth * (waspect / daspect - 1.0);
        axes.xmax += excess / 2.0;
        axes.xmin -= excess / 2.0;
    }
    
    return ct_plane2d(
        axes,
        (axes.xmax - axes.xmin) / iResolution.x,
        (axes.ymax - axes.ymin) / iResolution.y
    );
}

// Function 2258
float fCylinder(vec3 p, float r, float height) 
{
	float d = length(p.xz) - r;
	d = max(d, abs(p.y) - height);
	return d;
}

// Function 2259
float fPlane(vec3 p,vec3 n,float d){return dot(p,n)+d;}

// Function 2260
float sphere(vec3 p, vec3 c, float r) {
  return length(p - c) - r;
}

// Function 2261
float sdBox(in vec2 p, in vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// Function 2262
float DE_Box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 2263
float sphere(vec3 pos, float r)
{
	return length(pos) - r;
}

// Function 2264
float sdTorus(vec3 p, vec2 t) {
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 2265
float MedianTriTorus_norm(const vec2 p, float x, float inner_circle_scale) {
	float offsetX = x * 0.86602540378;//sin of 60 degrees
	float circle_r = offsetX + offsetX;

    float y2 = sqr(x*0.5 + p.y);
    
	float x2 = p.x - offsetX;
	float x3 = p.x + offsetX;
	float c0 = x2*x2 + y2;
	float c1 = x3*x3 + y2;
	float c2 = dot2(vec2(p.x, p.y - x));

	float d2 = median3(c0, c1, c2);
	d2 = sqrt(d2) -  circle_r;

	float d3 = min(c0, min(c1, c2));
	d3= sqrt(d3)- circle_r*inner_circle_scale; 
	return max(d2, -d3);
}

// Function 2266
vec4 getCubePlane(int ci,int k)
{
    vec3 norm = vec3( k/2%3==0?1.0:0.0, k/2%3==1?1.0:0.0, k/2%3==2?2.0:0.0)*float(k%2*2-1);
    norm = rotate(getCubeQuat(ci),norm);
    float offset = 1.0 + dot(getCubePos(ci),norm);
    return vec4(norm,offset);
}

// Function 2267
float sdTorus82( vec3 p, vec2 t )
{
    vec2 q = vec2(length2(p.xz)-t.x,p.y);
    return length8(q)-t.y;
}

// Function 2268
Hit torusSdf(vec3 p, vec2 dims) {
    Hit hit;
    vec2 q = vec2(length(p.zy) - dims.x, p.x);

    hit.dist = length(q) - dims.y;
    hit.color = vec3(1.0);
    
    return hit;
}

// Function 2269
float sdSphere(vec3 p, float s)
{
  return length(p) - s;
}

// Function 2270
float sphere(vec3 p, float radius) {
    return length(fract(p) - .5) - .2 * radius;
}

// Function 2271
float rbox(in vec3 p, in vec3 b, in float r)
{
    return length(max(abs(p)-b, 0.0)) - r;  
}

// Function 2272
bool UI_ProcessWindowCloseBox( inout UIContext uiContext, inout UIWindowState window, int iControlId, Rect closeBoxRect )
{
    bool bPressed = UI_ProcessButton( uiContext, iControlId, closeBoxRect );
    
    if ( bPressed )
    {
 		window.bClosed = true;
    }

    bool bActive = (uiContext.iActiveControl == iControlId);
    
    return UI_DrawWindowCloseBox( uiContext, closeBoxRect );
}

// Function 2273
float Torus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 2274
float sdWaveSphere(vec3 p,float radius,int waves,float waveSize)
{
    //bounding Sphere
    float d=length(p)-radius*2.2;
    if(d>0.)return.2;
    // deformation of radius
    d=waveSize*(radius*radius-(p.y*p.y));
    radius+=d*cos(atan(p.x,p.z)*float(waves));
    return.5*(length(p)-radius);
}

// Function 2275
bool intersect_sphere(inout Ray ray, in Sphere sphere, out HitRecord hitRecord){
    
    vec3 sphereCenter = sphere.center - ray.origin;
    
    float a = dot(ray.dir, ray.dir);
	float bPrime = -dot(sphereCenter, ray.dir);
	float c = dot(sphereCenter, sphereCenter) - sphere.radius * sphere.radius;
	float deltaPrime  = bPrime * bPrime - a * c;

	if(deltaPrime >= 0.0){
		float t = -bPrime - sqrt(deltaPrime);
    
        if(t >= ray.t_min && t <= ray.t_max){
		    vec3 intersect_point = t * ray.dir;
		    hitRecord.normal = normalize(intersect_point - sphereCenter);
            ray.t_max = t;
            
            hitRecord.t = t;
            
            hitRecord.hitPoint = ray.origin + t * ray.dir;
            
            return true;
        }
        
        t = -bPrime + sqrt(deltaPrime);
    
        if(t >= ray.t_min && t <= ray.t_max){
		    vec3 intersect_point = t * ray.dir;
		    hitRecord.normal = normalize(intersect_point - sphereCenter);
            ray.t_max = t;
            
            hitRecord.t = t;
            
            hitRecord.hitPoint = ray.origin + t * ray.dir;
            
            return true;
        }
	} 
    
    return false;
    
}

// Function 2276
float sdCappedCone( vec3 p, vec3 origin, float h, float r1, float r2 )
{
  p -= origin;
  vec2 q = vec2( length(p.xz), p.y );
  vec2 k1 = vec2(r2,h);
  vec2 k2 = vec2(r2-r1,2.0*h);
  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
  return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 2277
float torus(vec3 p,vec2 r){
 return length(vec2(abs(abs(length(p.xy)-r.x)-.1),abs(p.z)-.1))-r.y;}

// Function 2278
float roundedBox(vec3 p, vec3 dim, float r) {
    vec3 d = abs(p) - dim;
    return length(max(d,vec3(0.0))) - r;
}

// Function 2279
float sdf_sphere(vec3 pXp0, float radius)
{
    return (length(pXp0) - (radius));
}

// Function 2280
vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)
{
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return vec4(-1.0);

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return vec4(-1.0);

	//ray now found to intersect sphere, compute smallest t value of intersection
	float normalMultiplier = 1.0;
	float collisionTime = -b - sqrt(discr);
    if (collisionTime < 0.0)
    {
        collisionTime = -b + sqrt(discr);
        normalMultiplier = -1.0;
    }
    
    // calculate the normal, flipping it if we hit the inside of the sphere
    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;
    
    // return the time t that the collision happened, as well as the surface normal
    return vec4 (collisionTime, normal);
}

// Function 2281
float sdSphere( vec3 p, float s ){
  return length(p)-s;
}

// Function 2282
float isphere(Ray r,vec4 s)
{
    vec3 co=r.o-s.xyz;
    float b=2.*dot(co,r.d);
    float c=dot2(co)-s.w*s.w;
    float delta=b*b-4.*c;
    if(delta<0.)
        return MaxDist;
    float selRoot;
    if(c<0.) selRoot=1.; 
    else if(b>0.) return MaxDist;
    else selRoot=-1.;
    return (-b+selRoot*sqrt(delta))/2.;
}

// Function 2283
float boxplane(vec3 p){
    vec3 p0 = p;
	p0.xz = fract(p0.xz);
    vec3 p1 = p;
    p1.xz = fract(p1.xz - 0.5);
    return max(
    	min(
        	box(p0,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25)),
        	box(p1,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25))
    	),
        box(p,vec3(0,0,48.76),vec3(1.24,1,50))
    );
}

// Function 2284
vec4 findSeparatingPlane_planB()  
{
    if (pixelx<=pixely) discard;
    if (pixelx>=(CUBECOUNT)) discard;    

    uint cia = pixelx;
    uint cib = pixely;

    if ((length(getCubePos(cia)-getCubePos(cib))>6.0 && cib!=0u)) discard;
    
    vec3 sep = normalize(getCubePos(cib)-getCubePos(cia));
    float offset =0.0;
    float dangle = 0.2;
    float lastoffset=-1e30;
    vec3 lastsep=sep;
    vec3 diff = vec3(0.0,0.0,0.0);
    
    for(uint k=0u;k<64u;k++)
    {
        if (cib==0u)
        {
            sep = vec3(0.,-1.,0.);
        }
        
        float minoffset = -1e30;
        vec3 minvert=vec3(0.0,0.0,0.0);
        for(uint j=0u;j<8u;j++)
        {
            vec3 v = getWCubeVert(cia,j);
            if (dot(v,sep)>minoffset)
            {
                minoffset = dot(v,sep);
                minvert = v;
            }
        }

        float maxoffset = 1e30;
        vec3 maxvert=vec3(0.0,0.0,0.0);
        for(uint j=0u;j<8u;j++)
        {
            vec3 v = getWCubeVert(cib,j);
            if (dot(v,sep)<maxoffset)
            {
                maxoffset = dot(v,sep);
                maxvert = v;
            }
        }
        offset = dot(maxvert-minvert,sep);
        
        dangle*=1.2;
        if (offset<lastoffset) // no improvement
        {
            sep=lastsep;
            dangle*=0.5/1.2;
            offset = lastoffset;
        }
        else
        {
	         diff = maxvert-minvert;
        }
        
        vec3 axis = normalize(cross(diff,sep));
        lastsep = sep;
        lastoffset = offset;
        sep = rotateAxisAngle(axis,dangle,sep);
        offset = (maxoffset+minoffset)*0.5;

    }
    
    return vec4(sep,offset);
}

// Function 2285
vec2 sphereIntersect(vec3 pos, vec3 dir, float radius) {
    float b = dot(pos, dir);
    float c = dot(pos, pos) - radius * radius;
    float discriminant = b * b - c;
    if (discriminant < 0.) return vec2(-1.);
	float s = sqrt(discriminant);
    return vec2(-b - s, -b + s);
}

// Function 2286
void PrecomputeCone ( inout Cone cn )
{
    cn.Zs = (cn.R1-cn.R0)/(cn.Z1-cn.Z0);
    cn.Zo = cn.R0 - (cn.Z0*cn.Zs);
}

// Function 2287
float
capped_cylinder8_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;
    return min( maxv(d), 0.0 ) + length8( max(d, 0.0) );
}

// Function 2288
void Airplane( float id, out vec2 pos, out vec2 dir, out float scale )
{
    float cell = floor( iTime * 0.1 + fract( ( id * 2.0 ) / AIRPLANE_NUM ) );
    float time = iTime * 0.1 + fract( ( id * 2.0 ) / AIRPLANE_NUM ) - cell;
    cell += id * 1.13;
    
    vec2 start  = vec2( Rand( cell, id ) * 1000.0, Rand( cell + 1.0, id + 2.0 ) * 1000.0 );
    float edge = Rand( cell + 7.0, id + 3.0 );
    if ( edge < 0.25 )
    {
    	start.x = 0.0;
	}
    else if ( edge < 0.5 )
    {
        start.x = 1000.0;
    }
    else if ( edge < 0.75 )
    {
        start.y = 0.0;
    }
    else
    {
        start.y = 1000.0;
    }    
    
    vec2 target = vec2( 300.0 + Rand( cell, id ) * 400.0, 150.0 + Rand( cell + 1.0, id + 2.0 ) * 300.0 );
    
    dir		= normalize( target - start );
    scale 	= floor( id / 3.0 ) + 2.0;
    pos 	= start + time * dir * ( 6000.0 / scale );
}

// Function 2289
float sphere(vec3 p, float r, vec3 c)
{
    return distance(p, c) - r;
}

// Function 2290
bool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {
  vec3 p = s.p;
  float r = s.r;
  float c = length(p);
  vec3 q = ray.q, d = ray.d;
  // Formula for x^2 + 2Bx + C = 0
  // |q + t*d - p|^2 = r^2
  float B = dot(q-p,d);
  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);
  float D = B*B - C;
  if (D < 0.0) return false;
  D = sqrt(D);
  float t0,t1;
  if (B >= 0.0) {
    t0 = -B-D; t1 = C/t0;
  } else {
    t1 = -B+D; t0 = C/t1;
  }
  hit[0] = Hit(t0,(q+t0*d-p)/r);
  hit[1] = Hit(t1,(q+t1*d-p)/r);
  return true;
}

// Function 2291
float rayboxintersect(ray r, aabb box)
{
    float tmin = (box.min.x - r.pos.x) / r.dir.x;
    float tmax = (box.max.x - r.pos.x) / r.dir.x;

    if (tmin > tmax)
    {
        // swap(tmin, tmax);
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
    }

    float tymin = (box.min.y - r.pos.y) / r.dir.y;
    float tymax = (box.max.y - r.pos.y) / r.dir.y;

    if (tymin > tymax)
    {
        // swap(tymin, tymax);
        float tmp = tymin;
        tymin = tymax;
        tymax = tmp;
    }

    if ((tmin > tymax) || (tymin > tmax))
        return MAXDIST; // no intersection

    if (tymin > tmin)
        tmin = tymin;

    if (tymax < tmax)
        tmax = tymax;

    float tzmin = (box.min.z - r.pos.z) / r.dir.z;
    float tzmax = (box.max.z - r.pos.z) / r.dir.z;

    if (tzmin > tzmax)
    {
        // swap(tzmin, tzmax);
        float tmp = tzmin;
        tzmin = tzmax;
        tzmax = tmp;
    }

    if ((tmin > tzmax) || (tzmin > tmax))
        return MAXDIST; // no intersection

    if (tzmin > tmin)
        tmin = tzmin;

    if (tzmax < tmax)
        tmax = tzmax;

    return tmin;
}

// Function 2292
d2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize
 ;c2 u=suab(p,s)//u=abs(p)-s 
 ;return ma(u)  //return max(u.x,u.y);}

// Function 2293
vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	
	float d = b * b - c;
	if ( d < 0.0 ) {
		return vec2( 1e4, -1e4 );
	}
	d = sqrt( d );
	
	return vec2( -b - d, -b + d );
}

// Function 2294
float sdBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 2295
SAxisAlignedBox GetOrbitBox()
{
	return SAxisAlignedBox
	(
		4,						//Id
		vec3(sin(2.0 + iTime*1.3),-0.2,cos(2.0 + iTime*1.3)),	//center
		vec3(0.5,0.5,0.5),	//scale
		SMaterial
		(
			vec3(1.0,0.0,0.0),	//diffuse color
			20.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 2296
bool renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, out vec3 out_posG, out vec3 out_id) { 
    out_id = vec3(9);
    float scale = 50.;
    roG -= sunPos;
    roG *= PLANET_FIELD_SCALE;
    roG.z+=.5;

    float rayon = 3.;
    float min_dist=0., max_dist=100.;
    
    vec4 col, sum = vec4(0);
    float pitch = 10./iResolution.x;
    float dint, d = max(0., (length(roG)-rayon)); //min_dist;
    vec3 offset, id,
        ros = roG + rd*d,  
        pos = floor(ros),
        ri = 1./rd,
        rs = sign(rd),
        dis = (pos-ros + .5 + rs*.5) * ri;

    for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {
        if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {
            id = hash33(pos+sunPos);
            offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);
            offset.z = .5;
            d = distanceRayPoint(ros, rd, pos+offset, dint);
            if(dint > 0. && d<PLANET_RADIUS+dint*pitch ) {
                vec3 pp = pos+offset;
                pp.z-=.5;
                out_posG = (pp/scale)+sunPos;
                out_id = id;
                return true;
            }
        }
        vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);
        dis += mm * rs * ri;
        pos += mm * rs;

    }
    return false;
}

// Function 2297
float sBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return -1.0;
	
	return tN;
}

// Function 2298
float box(vec3 p, vec3 b){
        vec3 d = abs(p) - b;
        return length(max(d,0.0))
              + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
      }

// Function 2299
vec2 ct_plane2d_project(
	in ct_plane2d self,
    in vec2 z
){
	return vec2(
        self.axes.xmin + z.x * self.xstep,
        self.axes.ymin + z.y * self.ystep
    );
}

// Function 2300
float DistanceToPlanet(vec3 eye, vec3 dir, float start, float end) {
    float old_dist;
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 cur_eye = eye + depth * dir;
        float dist = sphereSD(cur_eye);
        if (dist < EPSILON) {
            vec3 old_eye = eye - old_dist * dir;
			return depth - old_dist + old_dist * (old_dist - old_eye.y) / (cur_eye.y - old_eye.y - dist + old_dist);
        }
        depth += dist * 0.5;
        old_dist = dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 2301
vec4 QuadCone60(vec3 p, vec3 d) {
    vec4 C=vec4(0.);
    vec3 cp=p+d;
    C+=Lod0Fetch(cp-vec3(0.5,0.,0.5))*(1.-C.w);
    cp+=d;
    C+=Lod1Fetch(cp-vec3(1.,0.,1.))*(1.-C.w);
    cp+=d*2.;
    C+=Lod2Fetch(cp-vec3(2.,0.,2.))*(1.-C.w);
    cp+=d*4.;
    C+=Lod3Fetch(cp-vec3(4.,0.,4.))*(1.-C.w);
    cp+=d*8.;
    C+=Lod4Fetch(cp-vec3(8.,0.,8.))*(1.-C.w);
    return C+vec4(0.2,0.5,0.9,0.)*((1.-C.w)*(d.y*0.5+0.5));
}

// Function 2302
vec4 raySphere(vec3 rp, vec3 rd, vec3 pos, float radius) {
    rp -= pos;
    float c = dot(rp, rp)-radius*radius;
    float b = dot(rd, rp), 
        d = b*b - c;

    if (d >= 0.) {
        b = -b;
        float s = sqrt(d), t, n;
        if (s < b) {
            t = b-s;
            n = 1.;
        } else {
            t = b+s;
            n = -1.;
            if (t < 0.) return vec4(0,0,0,VIEW_DISTANCE);
        }
        return vec4(normalize(rp+rd*t)*n,t);
    }
    return NNO;
}

// Function 2303
vec2 sphere(in vec3 ro, in vec3 rd, in float r, out vec3 ni) {
	float pd = dot(ro, rd);
    float disc = pd*pd + r*r - dot(ro, ro);
    if (disc < 0.) return vec2(-1.);
    float tdiff = sqrt(disc);
    float tin = -pd - tdiff;
    float tout = -pd + tdiff;
    ni = normalize(ro + tin * rd);
    
    return vec2(tin, tout);
}

// Function 2304
float sdPlane(vec3 p, vec3 n) { return dot(p, n); }

// Function 2305
float IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {
    vec3 Z = ro-sc;
    float B = 2.0 * dot(rd, Z);
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;
    float D = B*B - 4.0*C;
    float d = -1.0;
    if(D>=0.0) {
        if(C==0.0) {
            tmax = -B/2.0;
            d = 0.0;
        }else{
            tmin = (-B-sqrt(D))/2.0;
            tmax = (-B+sqrt(D))/2.0;
            d = 1.0;
        }
    }
    return d;
}

// Function 2306
float sdBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }

// Function 2307
float rot_rep_torus(vec3 p, float time)
{  
  	float v = 0.0;
  	//vec3 newp = p;
  	vec3 newp = Repetition(p,vec3(8.0,8.0,8.0));
 	v = Blend(v, torus(rotateX(newp,time),vec3(0.0,0.0,0.0),vec3(1.0,1.3,3.2),1.0,1.0,0.5));
  	v = Blend(v, torus(rotateZ(newp,2.0*time),vec3(0.0,0.0,0.0),vec3(2.0,-1.3,1.6),2.0,1.0,0.5));
  	v = Blend(v, torus(rotateY(newp,0.5*time),vec3(0.0,0.0,0.0),vec3(-2.0,3.2,0.1),1.5,1.0,0.5));
    v = Blend(v, box(rotateY(rotateX(newp,time),time),vec3(-0.2,-0.2,-0.2),vec3(0.2,0.2,0.2),0.6,0.5));
    return v;
}

// Function 2308
vec4 iTorus( in vec3 ro, in vec3 rd, in vec2 torusRadii )
{
    float t = sdTorus (ro,rd,torusRadii);
    if (t <= 0.0)    return vec4(-1);    //===>
    vec3 pos = ro + t * rd;
    vec3 n = nTorus (pos, torusRadii);
    return vec4(n,t);
}

// Function 2309
float sdBox(in ray r, in box b) {
    vec3 s = (b.x - b.n)*.5, //size
         c = b.n + s, //center
         d = abs(c - r.o) - s; //displacement
    return vec3max(d);
}

// Function 2310
float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

// Function 2311
vec2 raySphere( vec3 ro, vec3 rd, float r ) {

    float b = dot(ro, rd);
    float c = dot(ro, ro) - r*r;
    float h = b*b  - c;
    
    if (h < 0.) return vec2(1000);
    
    h = sqrt(h);
    return vec2(-b-h, -b+h);
}

// Function 2312
float calculatePlaneIntersection(in vec3 ro, in vec3 rd)
{
    return (-1.0 - ro.y) / rd.y;
}

// Function 2313
float obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}

// Function 2314
float obj_planeY(vec3 p, float planeY){
    return p.y-planeY;
}

// Function 2315
float sdSphere(vec3 p, float s) {
    return length(p)-s;
}

// Function 2316
float sdBox(const in vec3 p, const in vec4 b) {
  vec3 d = abs(p) - b.xyz;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;
}

// Function 2317
vec4 sphere_range(vec4 col, vec2 p, vec2 center, float r)
{
	float h;
    
    h = circle(p, center , r);
    col = blend(col, vec4(0.435, 0.8, 0., smoothstep(0.01, 0., abs(h))));
    
    return col;
}

// Function 2318
float sdSphere(vec3 pos, vec3 center, float r) {
 	return length(pos-center) - r;
}

// Function 2319
float PlaneSDF(vec3 p, vec3 n, float d) {
    return dot(p, n) - d;
}

// Function 2320
float aoFromSphere(vec3 s, float r, vec3 p, vec3 n)
{	// iq's sphere ao - http://www.iquilezles.org/www/articles/sphereao/sphereao.htm
	vec3 dir = s - p;
	float lenSq = dot(dir, dir);
	dir *= inversesqrt(lenSq);
	return 1.0 - max(dot(n, dir) * (r*r / lenSq), 0.0);
}

// Function 2321
float SphereRadius(in float t)
{
	if (t< 1.4) t= (1.4-t) * 4.5;
	t = t*0.04;
	return max(t*t, 16.0/iResolution.x);
}

// Function 2322
float Sphere(vec3 p, sSphere sph)
{ 
  return length(p) - sph.radius; 
}

// Function 2323
void fastPlane( in vec3 pn, in vec3 ps, in vec3 ro, in vec3 rd, out float d)
{
    if(dot(ps-ro, rd) == 0.0) d=MAX_DEPTH*2.0;
    d = dot(pn, (ps-ro)) / dot(pn, rd);
}

// Function 2324
vec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
	float b = dot (rd, oc);
	float c = dot (oc, oc);
	float h = b*b - c + sph.w*sph.w;
	if (h < 0.0) return vec2(-1.0);
	h = sqrt(h);
	return vec2(-b-h, -b+h );
}

// Function 2325
float sdCylinder(vec3 p, vec3 a, vec3 b, float r) {
	vec3 ab = b-a;
    vec3 ap = p-a;
    
    float t = dot(ab, ap) / dot(ab, ab);
    
    vec3 c = a + t*ab;
    
    float x = length(p-c)-r;
    float y = (abs(t-.5)-.5)*length(ab);
    float e = length(max(vec2(x, y), 0.));
    float i = min(max(x, y), 0.);
    
    return e+i;
}

// Function 2326
vec4 sdPlane( vec3 p )
{
	return vec4(vec3(0.25,0.25,0.25) + mod(round(p.x)+round(p.y),2.)*vec3(0.5,0.5,0.5),p.z);
}

// Function 2327
float sdBox(vec3 p){
  p += vec3(0.0, 1.5, 0.0);
  vec3 b = vec3(0.5);
  vec3 q = abs(p)-b;
  return length(max(q, 0.0))+min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 2328
float box(vec3 p){ p= abs(p); return max(max(p.x, p.y), p.z); }

// Function 2329
float sd2Planes(vec3 p, vec4 n) {
	float plane1 = dot(p, n.xyz);
	float plane2 = dot(p, -n.xyz) - n.w;
	return max(plane1, plane2);
}

// Function 2330
float iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
                 in vec3 pa, in vec3 pb, float ra ) {
    vec3 ca = pb-pa;
    vec3 oc = ro-pa;

    float caca = dot(ca,ca);
    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    
    float a = caca - card*card;
    float b = caca*dot( oc, rd) - caoc*card;
    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;
    float h = b*b - a*c;
    
    if (h < 0.) return MAX_DIST;
    
    h = sqrt(h);
    float d = (-b-h)/a;

    float y = caoc + d*card;
    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {
        normal = (oc+d*rd-ca*y/caca)/ra;
        return d;
    }

    d = ((y < 0. ? 0. : caca) - caoc)/card;
    
    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {
        normal = normalize(ca*sign(y)/caca);
        return d;
    } else {
        return MAX_DIST;
    }
}

// Function 2331
vec4 circleBox( in vec4 background, 
            in vec4 circleColor,
            in vec2 position,
            in float radius,
           in float thickness,
            in vec2 sideLength  
              ) {

  vec2 relative = vUV-position;
  float distance = length(max(vec2(0.), abs(relative)-sideLength));

  
  
   distance = smoothstep(distance-thickness/2., distance+thickness/2.,radius);
  vec4 outColor = mix( circleColor,background,distance);
  return outColor;
}

// Function 2332
vec3 sphere( in vec2 t )
{
     vec2 q = vec2( t.x*3.1416, acos(t.y) );
     return vec3( cos(q.x)*sin(q.y), t.y, sin(q.x)*sin(q.y) );
}

// Function 2333
float intersectPlane(Ray r,Plane s){
	vec3 op=s.p-r.origin;
    float d=dot(op,s.normal)/dot(r.direction,s.normal);
    return d;

}

// Function 2334
float sdfPlane(in vec3 p, in vec4 n)
{
	return dot(p, n.xyz) + n.w; // normal must be normalized
}

// Function 2335
float box(vec3 p, vec3 c)
{
 	return length(max(abs(p)-c, 0.));   
}

// Function 2336
float SphereDist(vec3 p, vec3 c, float r)
{
    return length(p - c) - r;
}

// Function 2337
float GetCosWeightSpherePDF(in vec3 nDir,in vec3 wi){
	float pdf = 1.;
    float costheta = max(0.,dot(nDir,wi));
    pdf = costheta*M_1_PI_F;
    return pdf;
}

// Function 2338
vec2 sphere( vec3 pos,float r,float id){
	float d = length(pos)-r;
	return vec2(d,id);
}

// Function 2339
float sdYTorus( vec3 p, vec2 t )
{
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 2340
float board_box_vz(vec2 p, vec2 bpp, float bsz, float z, int midg) {
    float d = 0.;
    p += bpp;
    if (any(lessThanEqual(p, vec2(0.))) || any(greaterThanEqual(p, bsz * vec2(msize - ivec2(0, 2))))) return d;
    int mid = int(floor((p.y) / bsz) * float(msize.x) + floor((p.x) / bsz));
    p = mod(p, bsz) - bsz / 2.;
    d = block_z(p, z + 25.);
    float mv = 1.;
    if (d > 0.)if (maptmp(mid, midg) == 0)mv = 0.05;
    d *= mv;
    return d;
}

// Function 2341
float IntersectCylinder( out bool inside, out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )
{
    vec3 m = (a.xyz+b.xyz)/2.;
    
    pos -= m; // centre all maths on the cylinder
    
    float radius = a.w;
    vec3 n = (a.xyz-b.xyz)/2.;
    float l = length(n);
    n /= l;
    
    
    // intersect infinite cylinder
    // flatten everything along the axis
    float rdn = dot(ray,n);
    float pdn = dot(pos,n);
    vec3 r = ray-rdn*n;
    vec3 p = pos-pdn*n;
    float rl = length(r);
    r /= rl;;
    float rdp = dot(r,p);
    float pp = dot(p,p);

    inside = (pp < radius*radius && abs(pdn) < l);
    
    float q = pp - rdp*rdp;
    if ( q >= radius*radius ) return FLT_MAX;
    
    float d = sqrt(radius*radius-q);
    float front = (-rdp - d)/rl;
    float back = (-rdp + d)/rl;
    normal = normalize(p+front*r*rl);
    
    
    // intersect facing plane
    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }
    
    float front2 = (-l-pdn)/rdn;
    
    if ( front2 > front )
    {
        front = front2;
        normal = -n;
    }

    
    // clip the back sides
    if (
        front > back || // clip to back of cylinder
    	pdn+rdn*front > l // clip to back plane
        )
        return FLT_MAX;
    
    return front;
}

// Function 2342
float sdSphere( vec3 p )
{
    return length(p) - 1.0;
}

// Function 2343
float sdWeirdSphere(vec3 pos,float frequency) {
    float noise = perlin_noise3(pos * frequency) / (1. * frequency * 1.32);
	return mix(sdSphere(pos, 0.2) / 1.0,
               noise,
               0.85);
}

// Function 2344
float sdBox( vec3 p, vec3 b )
	{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }

// Function 2345
vec2 sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),1.);
}

// Function 2346
float raySphereIntersect(in Ray ray, in Sphere sphere) {
    
    vec3 rayToSphere = ray.origin - sphere.center;
    float b = dot(rayToSphere, ray.direction);
    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);
	float disc = b*b - c;
    float t = MAXX; // initialize to a large number
    if (disc > 0.0) {
        t = -b - sqrt(disc);
        if (t > 0.00001) {
            return t;
        }
        t = -b + sqrt(disc);
        if (t > 0.00001) {
            return t;
        }  
    }
    return t;
}

// Function 2347
float sdSphere (vec3 p, float r) { return length(p)-r; }

// Function 2348
float tracePlane(vec3 pos, vec3 dir, out vec3 normal, Plane p) 
{
     
    float t = (p.center[p.coord] - pos[p.coord]) / dir[p.coord];
    if (t <= 0.0) {
        return INF;
    }
    
    int x = (p.coord != 0) ? 0 : 1;
    int z = (p.coord != 2) ? 2 : 1;
     
    vec3 worldPos = t * dir + pos;
    if ((abs(worldPos[x]) > p.r) || (abs(worldPos[z]) > p.r) )
    {
        return INF;
    }
    normal = vec3(0.0);
    normal[p.coord] = 1.0 * float((p.center[p.coord] > 0.0) ? -1 : 1);
    //float((p.y < 0.0) ? -1 : 1);
    return t;
}

// Function 2349
float distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }

// Function 2350
float plane (vec3 p)
{
    return p.y + .25;
}

// Function 2351
float box(vec3 p, vec3 b) {
	vec3 q = abs(p) - b;
	return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);
}

// Function 2352
float Sphere(vec3 point, vec3 center, float radius) 
{
    return length(point - center) - radius;
}

// Function 2353
vec2 iBox(vec3 ro, vec3 rd, vec3 rad)
    {
        vec3 m = 1. / rd,
          n = m * ro,
          k = abs(m) * rad,
          t1 = -n - k,
          t2 = -n + k;
        return vec2(max(max(t1.x, t1.y), t1.z),
                 min(min(t2.x, t2.y), t2.z));
    }

// Function 2354
float Sphere(vec3 point, vec3 pos, float radius) {

    return length(point - pos) - radius;
}

// Function 2355
vec2 sdCylinder(vec3 p, vec3 a, vec3 b, float r)
{
    vec3 pa = p - a;
    vec3 ba = b - a;
    float baba = dot(ba,ba);
    float paba = dot(pa,ba);

    float x = length(pa*baba-ba*paba) - r*baba;
    float y = abs(paba-baba*0.5)-baba*0.5;
    float x2 = x*x;
    float y2 = y*y*baba;
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
    return vec2(sign(d)*sqrt(abs(d))/baba,21.);
}

// Function 2356
bool hit_movingSphere(MovingSphere s, Ray r, float tmin, float tmax, out HitRecord rec)
{
    vec3 sphereCenter = center(s, r.t);
    vec3 oc = r.o - sphereCenter;
    float a = dot(r.d, r.d);
    float b = dot(oc, r.d);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discriminant = b * b - a * c;
    if(discriminant > 0.0)
    {
        float sqrtDiscriminant = sqrt(discriminant);
        float temp = (-b - sqrtDiscriminant) / a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - sphereCenter) / s.radius;
            return true;
        }
        temp = (-b + sqrtDiscriminant) / a;
        if(temp < tmax && temp > tmin)
        {
            rec.t = temp;
            rec.pos = pointOnRay(r, rec.t);
            rec.normal = (rec.pos - sphereCenter) / s.radius;
            return true;
        }
    }
    return false;
}

// Function 2357
float sSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
	
    return step( min( -b, min( c, b*b - c ) ), 0.0 );
}

// Function 2358
float dSphere( vec3 p, float s )
{
	return length(p)-s;
}

// Function 2359
float box(vec2 st, float size) {
    size = 0.5 + size * 0.5;
    st = step(st, vec2(size)) * step(1.0 - st, vec2(size));
    return st.x * st.y;
}

// Function 2360
vec2 plane(vec3 p, vec3 d, vec3 normal)
{
    vec3 up = vec3(0,1,0);
    vec3 right = cross(up, normal);
    
    float dn = dot(d, normal);
    float pn = dot(p, normal);
    
    vec3 hit = p - d / dn * pn;
    
    vec2 uv;
    uv.x = dot(hit, right);
    uv.y = dot(hit, up);
    
    return uv;
}

// Function 2361
float wallbox(vec3 p, vec3 d) {
    vec3 q = abs(p) - d;
    return max(q.x, q.z);
}

// Function 2362
Hit intersectSphere(vec3 ori, vec3 dir, vec3 p, float r) {
    
    float a = dot(dir,dir), b = 2. * dot(dir,ori-p), c = dot(ori-p,ori-p)-(r*r);
    float d = (b*b)-4.*a*c;
    float l = (-b-sqrt(d))/(2.*a);
    
    vec3 pos = ori+dir*l;
    return Hit(pos,normalize(pos-p),(d >= 0. && l >= 0.) ? 0 : -1);
    
}

// Function 2363
float box( in vec2 p, in vec2 a, in vec2 b )
{

    return  1.-max(-isInside(p,a),-isInside(-p,-b));
}

// Function 2364
float pBox(vec3 p, vec3 b)
{
  return length(max(abs(p)-b,0.0));
}

// Function 2365
float sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }

// Function 2366
vec2 rayIntersectNearestGridPlanes(vec3 orig, vec3 ray)
{
    orig = fract(orig);
    float zInv = 1.0 / ray.z;
    float dFront = (1.0 - orig.z) * zInv;
    float dBack = (2.0 - orig.z) * zInv;

    if (ray.z < 0.0)
    {
    	dFront = (orig.z) * -zInv;
        dBack = (orig.z + 1.0) * -zInv;        
    }
    
    return vec2(dFront, dBack);
}

// Function 2367
float box(vec3 p, vec3 pos, vec3 size)
{
	return max(max(abs(p.x-pos.x)-size.x,abs(p.y-pos.y)-size.y),abs(p.z-pos.z)-size.z);
}

// Function 2368
float sdPlane(vec3 p) {
	return p.y;
}

// Function 2369
vec3 nTorus( in vec3 pos, vec2 tor )
{
	return normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));
}

// Function 2370
vec3 random_in_unit_sphere(inout float seed) {
    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 1./3.);
	return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// Function 2371
bool intersectPlane(in Ray r, in Plane p, inout HitTest test) {
    // Intersect plane
    float a = dot(r.dir, p.n);
    
    float d = -(dot(r.origin, p.n) + p.d) / a;
    
    float f = step(0.0, -d);
    d = d * (1.-f) + (f * INF);
    
    if (d < test.dist) {
        test.dist = d;
        test.normal = p.n * -sign(a);
 		return true;
    }
 	return false;   
}

// Function 2372
vec3 voronoiSphereMapping(vec3 n)
{
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
    float voroRatio = CELLS_DENSITY_DEFAULT;
	//if ( iMouse.z > 0. ) {voroRatio=iMouse.x/iResolution.x * CELLS_DENSITY_MAX;}
    return getVoronoi(voroRatio*uv);
}

// Function 2373
float sd_torus(vec3 p, float outer_radius, float inner_radius) {
    vec2 q = vec2(length(p.xz)-outer_radius,p.y);
    return length(q)-inner_radius;
}

// Function 2374
float fBox2Cheap(vec2 p, vec2 b) {
	return vmax(abs(p)-b);
}

// Function 2375
float sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){
    vec3 oc = rayori-sphpos;
    float b = dot(oc, raydir);
    float c = dot(oc, oc)-sphrad*sphrad;
    float h = b*b-c;
    if(h < 0.0){return -1.0;}
    h = sqrt(h);
    return -b-h;
}

// Function 2376
vec4 intersectSphere(vec3 rpos, vec3 rdir)
{
    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;
    //float rad = 0.3;
  
    float eps = 1e-5;
    float b = dot(op, rdir);
    float det = b*b - dot(op, op) + rad*rad;
      
    if (det > 0.0)
    {
        det = sqrt(det);
        float t = b - det;
        if (t > eps)
        {
            vec4 P = vec4(normalize(rpos+rdir*t), t);
            Rz = rad*P.z;   // 1/2 ray length inside object
#if LINEAR_DENSITY    
            // skin layer counts less
            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);
            if (dH>0.) // core region
                Rz *= .5*(1.+sqrt(dH));
            else
                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;
#endif
            return P;
        }
    }
  
    return vec4(0.0);
}

// Function 2377
float Torus(vec3 point, float radius, float r) {
    
    return Circle(point, radius) - r; 
}

// Function 2378
vec4 rmAtmosphere(vec3 rayStart, vec3 rayDir, float minDist)
{
    float totalDist = minDist;
    float dist;
    vec3 color = vec3(0.0);
    float stepBias;
    vec3 atmColor;
    vec4 dfRes;
    
    for(int i = 0; i < MAX_STEPS; ++i)
    {   
        stepBias = max(0.5, float(i) / float(MAX_STEPS));//to avoid artefacts
        dfRes = colorDistanceField(rayStart + rayDir * totalDist);
        dist = dfRes.w;        
        totalDist += dist * stepBias;
        
        if(dist <= MIN_DIST * stepBias)
        {
            atmColor = dfRes.xyz;
            color = lerp(color, skyColor, pow(totalDist / MAX_DIST, 1.0 / FOG_STR));            
        	return vec4((color + atmColor), totalDist);   
        }
        
        if(totalDist >= MAX_DIST)
        {
            return vec4(color + skyColor, MAX_DIST);  
        }                       
        //color accumulation while raymarching to add emission FX
        atmColor = dfRes.xyz;
        color += (clamp(atmColor - vec3(1.0), vec3(0.0), vec3(3.0)) * max(1.5 - dist, 0.0)) / (totalDist * totalDist);    
    }      
        
    return vec4(color + skyColor, totalDist);    
}

// Function 2379
vec2 plane( vec3 p)
{
    
    float x = float(int(mod(p.x*5.0,2.0)+1.00));
    float z = float(int(mod(p.z*5.0,2.0)+1.00));
    float check = abs(x-z)*-0.1;
	return vec2(p.y,check);
}

// Function 2380
float sdCylinderXZ( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2381
vec3 GetHemisphereDirForDiscPoint( vec3 normal, vec2 discPoint )
{
    // get two perpendicular vectors
    // right = normal x (0,0,1)
    vec3 right = normalize( vec3( normal.y, -normal.x, 0.0 ) );
    vec3 up = cross( right, normal );
    return right * discPoint.x + up * discPoint.y + normal * sqrt( 1.0 - dot( discPoint, discPoint ) );
}

// Function 2382
float sdCappedCylinder( vec3 p, float h, float r ){
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2383
bool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
	float phi;
	vec3 phit;
    
	// Compute quadratic cylinder coefficients
	float a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;
	float b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);
	float c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;
 
	// Solve quadratic equation for _t_ values
	float t0, t1;
	if (!solveQuadratic( a, b, c, t0, t1))
		return false;

    if ( t1 < 0.0 )
        return false;
    
	t = t0;
    
	if (t0 < 0.0)
		t = t1;

	// Compute cylinder hit point and $\phi$
	phit = r.origin + r.dir*t;
	phi = atan(phit.y,phit.x);
    phi += PI;
    
	if (phi < 0.0)
        phi += TWO_PI;
 
	// Test cylinder intersection against clipping parameters
	if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {
		if (t == t1)
            return false;
		t = t1;
		// Compute cylinder hit point and $\phi$
		phit = r.origin + r.dir*t;
		phi = atan(phit.y,phit.x);
        phi += PI;

		if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )
			return false;
	}
    
    if( !forShadowTest ) {
        isect.position_ = phit;
        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);
        isect.uv_.y = phi/maxPhi;
        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );
        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );
    }
    
	return true;
}

// Function 2384
float box(vec3 p, vec3 b){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2385
float dsBox(vec2 p, vec2 b, float r)
{
    return length(max(abs(p)-b, 0.)) -r;
}

// Function 2386
float sdTorus( vec3 p, float ra, float rb )
{
    return length( vec2(length(p.xz)-ra,p.y) )-rb;
}

// Function 2387
float repeatedSphere( vec3 p, vec3 c, float s )
{
  return length( mod(p,c)-0.5*c ) - s;
}

// Function 2388
float headSphere(vec3 p) { return (length(p / vec3(1, .8, 1)) - 1.) * .8; }

// Function 2389
float intersect_box(inout intersection_info inf,float id, vec3 ro, vec3 rd,vec3 _min, vec3 _max)
{
    vec2 d = intersect_box(ro,rd,_min,_max);
    if(d.x > d.y || d.x < 0.0)
        return 0.0;
    if(d.x < inf.dist_id.x && abs(inf.dist_id.y - id) > 0.5)
    {
        vec3 center = (_max + _min) / 2.0;
        inf.pos_ws = ro + rd * d.x;
        inf.normal_ws = box_normal_from_point(inf.pos_ws - center,_max - center);
    	inf.dist_id = vec2(d.x,id);
        return 1.0;
    }
    return 0.0;
}

// Function 2390
float d_cylinder6( vec3 p, vec2 h ){
  return max(length6(p.xz) - h.x, abs(p.y) - h.y);
}

// Function 2391
vec4 bboxBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 )
{
    // extremes
    vec2 mi = min(p0,p3);
    vec2 ma = max(p0,p3);

    vec2 k0 = -1.0*p0 + 1.0*p1;
    vec2 k1 =  1.0*p0 - 2.0*p1 + 1.0*p2;
    vec2 k2 = -1.0*p0 + 3.0*p1 - 3.0*p2 + 1.0*p3;

    vec2 h = k1*k1 - k0*k2;

    if( h.x>0.0 )
    {
        h.x = sqrt(h.x);
        //float t = (-k1.x - h.x)/k2.x;
        float t = k0.x/(-k1.x-h.x);
        if( t>0.0 && t<1.0 )
        {
            float s = 1.0-t;
            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;
            mi.x = min(mi.x,q);
            ma.x = max(ma.x,q);
        }
        //t = (-k1.x + h.x)/k2.x;
        t = k0.x/(-k1.x+h.x);
        if( t>0.0 && t<1.0 )
        {
            float s = 1.0-t;
            float q = s*s*s*p0.x + 3.0*s*s*t*p1.x + 3.0*s*t*t*p2.x + t*t*t*p3.x;
            mi.x = min(mi.x,q);
            ma.x = max(ma.x,q);
        }
    }

    if( h.y>0.0)
    {
        h.y = sqrt(h.y);
        //float t = (-k1.y - h.y)/k2.y;
        float t = k0.y/(-k1.y-h.y);
        if( t>0.0 && t<1.0 )
        {
            float s = 1.0-t;
            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;
            mi.y = min(mi.y,q);
            ma.y = max(ma.y,q);
        }
        //t = (-k1.y + h.y)/k2.y;
        t = k0.y/(-k1.y+h.y);
        if( t>0.0 && t<1.0 )
        {
            float s = 1.0-t;
            float q = s*s*s*p0.y + 3.0*s*s*t*p1.y + 3.0*s*t*t*p2.y + t*t*t*p3.y;
            mi.y = min(mi.y,q);
            ma.y = max(ma.y,q);
        }
    }
   
    return vec4( mi, ma );
}

// Function 2392
float raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {
	radius = radius * radius;
	float dt = dot(rdir, sp - rpos);
	if (dt < 0.0) {
		return -1.0;
	}
	vec3 tmp = rpos - sp;
	tmp.x = dot(tmp, tmp);
	tmp.x = tmp.x - dt*dt;
	if (tmp.x >= radius) {
		return -1.0;
	}
	dt = dt - sqrt(radius - tmp.x);
	point = rpos + rdir * dt;
	normal = normalize(point - sp);
	return dt;
}

// Function 2393
float tracePlane(vec3 pos, vec3 dir, out vec3 normal, Plane plane, float radius_restrict) {
    // <plane.normal, pos + t*dir - plane.point> = 0
    // t = <plane.normal, plane.point - pos> / <plane.normal, dir>
    float t = dot(plane.normal, plane.point - pos) / dot(plane.normal, dir);
    float r = radius_restrict; // Table radius
    if (t < 0.0) {
        return INF;
    }
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) >= r*r){            
        return INF;
    }
    normal = plane.normal;
    return t;
}

// Function 2394
vec3 getConeSample(vec3 dir, float extent, vec2 seed) {
	dir = normalize(dir);
	vec3 o1 = normalize(ortho(dir));
	vec3 o2 = normalize(cross(dir, o1));
	vec2 r =  seed;
	r.x=r.x*2.*PI;
	r.y=1.0-r.y*extent;
	float oneminus = sqrt(1.0-r.y*r.y);
	return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;
}

// Function 2395
float sdBox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))   ;
}

// Function 2396
vec3 randInUnitSphere(vec2 st) {
    float phi = random(st.yx) * 2.0 * 3.14159265;
    float theta = random(st.xy) * 3.14169265;
    
    return vec3(cos(phi) * sin(theta), cos(theta), sin(phi) * sin(theta));
}

// Function 2397
float box (vec3 pos) {
    float dist;
    
    float radius = 4.;
    float size = .2;
    vec3 p = pos;
    p.y -= radius;
    p.xy *= rot(-iTime*.5);
    float index = amod(p.xy, 16.);
    p.x -= radius-1.5;
    p.xy *= rot(iTime+index);
    
    dist =sdBox(p,vec3(0.2));
   
    return dist;
}

// Function 2398
float sdHollowBox(vec3 pos, vec3 size, float hole) {
  float box = sdBox(pos, size);
  box = max(box, -sdBox(pos, size * vec3(2., hole, hole)));
  box = max(box, -sdBox(pos, size * vec3(hole, hole, 2.)));
  return box;
}

// Function 2399
void initSpheres() {
	spheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),	vec3(0.), vec3(.75, .25, .25), DIFF);
	spheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);
	spheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),		vec3(0.), vec3(.75), DIFF);
	spheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);
	spheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),		vec3(0.), vec3(.75), DIFF);
	spheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);
	spheres[6] = Sphere(16.5, vec3(27., 16.5 + 2.*bump(iTime, 5.), 47.), 	vec3(0.), vec3(1.), SPEC);
	spheres[7] = Sphere(16.5, vec3(73., 16.5 + 15.*bump(iTime, 1.6), 78.), 	vec3(0.), vec3(.7, 1., .9), REFR);
	spheres[8] = Sphere(600., vec3(50., 681.33, 81.6),	vec3(12.), vec3(0.), DIFF);
}

// Function 2400
result intersectPlane(ray r, plane pl)
{
	result res;
	res.t = -INFINITY;

	float d = dot(pl.n, r.d);
	if(abs(d) < EPSILON)
		return res;
	res.t = (-pl.d - dot(pl.n, r.o)) / d;
	res.n = pl.n;
	return res;
}

// Function 2401
vec3 sphere(vec3 ro, vec3 rd, vec3 p, float radius, float id)
{
    
    vec3 d = ro-p;
    float a = dot(rd, rd);
    float b = dot(d, rd);
    float c = dot(d,d)-radius*radius;
    
    float disc = b*b-a*c;
    if(disc<0.)
        return vec3(-1.);
    
    float sqrtDisc = sqrt(disc);
    float invA = 1.0/a;
    
    vec3 hit = (ro+(rd*(-b-sqrtDisc)*invA));
    
    if(blinkID[int(id)])
        return vec3(1.,length(p+hit-ro),disc);
    
    vec3 norm = normalize(hit-p);
    vec3 ref = reflect(rd,norm);

    float dist = length(hit-ro);
 
    float litv = 0.;
    vec3 light = normalize(lightPos-(hit));
    float lit = 0.;
    float spec = 0.;

    float shade = shadow(hit, light, id);
    if(shade>0.)
    {


        lit = max(0.,dot(light, norm))*shade;
        spec = pow(max(0.,dot(light, ref)),100.);
        litv+=lit*.5+spec;
    }
    for(int i=0; i<numLights; i++)
    {
        vec3 light = normalize(spherePos[lightID[int(i)]]-(hit));
        float lit = 0.;
        float spec = 0.;

        float shade = shadow(hit, light, id);
        if(shade>0.)
        {


            lit = max(0.,dot(light, norm))*shade;
            spec = pow(max(0.,dot(light, ref)),3.);
            litv+=(lit+spec)*.2;
        }
    }
    ref +=iTime*.2;
    ref *=3.;
    float fresnel = (1.-dot(norm,-rd));
    float wall = fresnel*fresnel*fresnel*smoothstep(.3,0.0,min(4.*length(.5-fract(ref.x)),4.*length(.5-fract(ref.y))));
    vec3 v = vec3(max(0.,litv+wall));
    

    return vec3(v.x, length(p+hit-ro), disc);
}

// Function 2402
float d_sphere(vec3 v, vec3 p, float r){
	return length(v - p) - r;
}

// Function 2403
float distCappedCylinder(vec3 p, vec2 h)
{
    vec2 d = abs(vec2(length(p.xz), p.y)) - h;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2404
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max (max (t1.x, t1.y), t1.z);
	float tF = min (min (t2.x, t2.y), t2.z);
	if (tN > tF || tF < 0.0) return vec2(-1.0);
	return vec2( tN, tF );
}

// Function 2405
vec4 GetDistanceCylinderMaterialSelectorZ(const in vec3 vPos, const in float r, const in float segcount)
{
	
	//+ PI
	vec3 vNorm = normalize(vPos);
	float atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;
	//float segment = (segcount-1.0) - mod((floor(atn * (segcount - 0.5) ) + 2.0),segcount);
	float segment = floor(atn * segcount);

	float seg_norm = mod((segment / segcount) + 0.25, 1.0);
	float d = length(vPos.xy) - (r);// + segment * 0.1);
	return vec4(d,seg_norm , vNorm.x, vNorm.y);
}

// Function 2406
float sdCylinder(vec3 p, vec4 c)
{
	return max(length(p.xz-c.xy)-c.z,abs(p.y) - c.w);
}

// Function 2407
float udRoundBox( vec3 p, vec3 b, float r ) {
  return length(max(abs(p)-b,0.0))-r;
}

// Function 2408
void dbox(in vec2 x, in vec2 b, out float d)
{
    vec2 da = abs(x)-b;
    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);
}

// Function 2409
Hit tracePlane(Ray ray, Plane plane)
{
    Hit hit;
    
    float dn = dot(ray.direction, plane.normal);
    if(dn != 0.0)
    {
        hit.t = dot(plane.point - ray.origin, plane.normal) /  dn;
        if(hit.t < t_max && hit.t > t_min)
        {
            hit.normal = plane.normal;
            hit.mat = plane.mat;
            hit.hit = true;
            return hit;
        }
    }
    
    hit.hit = false;
    return hit;
}

// Function 2410
vec3 GetPlaneColor(vec3 hitAt, vec3 L, vec3 N, vec3 V)
{
  
    lowp vec2 planeUV = vec2(hitAt.x + 80.0, hitAt.z) * 0.005;//200.0;  
    lowp vec3 col = CheckerBoard2(planeUV, vec3(0.2), vec3(0.5), 30.0);
     col+=  0.5*texture(iChannel1, V).xyz;
    lowp float shadowT = 0.0;
    int shadowHit = InShadow(hitAt, L,shadowT);  
    if(shadowHit > 0)
    {
       col *= 0.2;
    }
    
    return col;
}

// Function 2411
void ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)
{
    #ifdef ENABLE_FOG
    // fog
    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);
    vec3 cFog = GetSkyGradient(ray.vDir);

    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE
    C_DirectionalLight directionalLight = GetDirectionalLight();
    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);
    cFog += directionalLight.cColour * pow(fDirDot, 10.0);
    #endif 

    col = mix(cFog, col, fFogAmount);
    #endif

    // glare from light (a bit hacky - use length of closest approach from ray to light)
    #ifdef ENABLE_POINT_LIGHT_FLARE
    C_PointLight pointLight = GetPointLight();

    vec3 vToLight = pointLight.vPos - ray.vOrigin;
    float fPointDot = dot(vToLight, ray.vDir);
    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);

    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;
    float fDist = length(vClosestPoint - pointLight.vPos);
    col += pointLight.cColour * 0.01/ (fDist * fDist);
    #endif    
}

// Function 2412
bool raySphereIntersection(in Ray ray, in Sphere sphere, inout Intersection currentInter, int sptr){
    vec3 oc = ray.origin - sphere.position;
    float b = dot( oc, ray.direction );
    float c = dot( oc, oc ) - sphere.radius2;
    float h = b*b - c;
    if( h<0.0 ) return false;
    h = sqrt( h );
    float t1 = -b-h;
    float t2 = -b+h;
    float t = 0.0f;
    if(t1 < 0.0f && t2 < 0.0f) return false;
    else if(t1 > 0.0f){
    	if(t2 > 0.0f) t = min(t1,t2);
        else t = t1;
    }else{
    	t = t2;
    }
    if(t > currentInter.t && currentInter.hit) return true;
    vec3 point = ray.origin + t *  ray.direction;
    vec3 normal = (point - sphere.position) / sphere.radius;   
    currentInter = yay(point, t, normal, ray, sphere.material,  -1, sptr);
    return true;
}

// Function 2413
float Kalibox(vec3 pos) 
{
	float Scale = 1.84;						
	int Iterations = 14;			
	int ColorIterations = 3;		
	float MinRad2 = 0.34;	
	vec3 Trans = vec3(0.076,-1.86,0.036);			
	vec3 Julia = vec3(-0.66,-1.2+(kalitime/80.),-0.66);	
	vec4 scale = vec4(Scale, Scale, Scale, abs(Scale)) / MinRad2;
	float absScalem1 = abs(Scale - 1.0);
	float AbsScaleRaisedTo1mIters = pow(abs(Scale), float(1-Iterations));
    vec4 p = vec4(pos,1), p0 = vec4(Julia,1); 
	for (int i=0; i<14; i++)
		{
			p.xyz=abs(p.xyz)+Trans;
			float r2 = dot(p.xyz, p.xyz);
			p *= clamp(max(MinRad2/r2, MinRad2), 0.0, 1.0); 
			p = p*scale + p0;
			if (i<ColorIterations) orbitTrap = min(orbitTrap, abs(vec4(p.xyz,r2)));
		}
		return (    (length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters    );
}

// Function 2414
float traceCubePlane(Cube cube, vec3 normal, vec3 orig, vec3 dir) 
{
    // normal * (orig + t * dir) + cube.size = 0
    // t = ?
    float t = -(dot(normal, orig) + cube.size) / dot(normal, dir);
    if (t < 0.0) {
        return INF;
    }
    
    vec3 pos = orig + t * dir;
    if (abs(pos.x) > cube.size + PRECISION     ||
            abs(pos.y) > cube.size + PRECISION ||
            abs(pos.z) > cube.size + PRECISION) {
        return INF;
    }
    
    return t;
}

// Function 2415
bool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)
{
	vec3 oc = o-c;
    
    float b=dot(d,oc);
    float k = dot(oc,oc)-r*r;
    t=b*b-k;
       
    if (t<=0.0) return false;
    
    t=-b-sqrt(t);
    if (t<0.0) return false;
    
    // Normal
    n=(o+t*d-c)/r;

   return true;
 }

// Function 2416
float sdfBox(vec2 p) {
  vec2 d = abs(p) - vec2(1.0);
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2417
float sdBox(in vec3 p, in vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 2418
void sphere_fold(inout vec3 z, inout float dz) {
    float fr = 0.8; //2. - iMouse.z / 100.;
    float mr = .1; // + iMouse.w / 100.;
    
    float r2 = dot(z, z);
    if(r2 < mr) {
        float temp = (fr / mr);
        z *= temp;
        dz *= temp;
    }else if(r2 < fr) {
        float temp = (fr / r2);
        z *= temp;
        dz *= temp;
    }
}

// Function 2419
bool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, out float t, out SurfaceHitInfo isect ) {
    if ( ray.dir.z == 0.0 )
    	return false;
    
    t = ( -ray.origin.z ) / ray.dir.z;
    
    isect.position_ = ray.origin + ray.dir*t;
    isect.normal_ 	= vec3( 0.0, 0.0, 1.0 );
    return	(isect.position_.x > min_x) &&
       		(isect.position_.x < max_x) &&
      		(isect.position_.y > min_y) &&
      		(isect.position_.y < max_y);
}

// Function 2420
float sdPlane(vec3 p, vec3 n, float h)
{
  return dot(p,normalize(n)) + h;
}

// Function 2421
float sphere(vec3 p, float r)
{
	return length(p)-r;   
}

// Function 2422
float dBox( vec3 p, vec3 s )
{
	vec3 d = abs(p) - s; 
    return min(max(d.x,max(d.y,d.z)),0.0) +length(max(d,0.0));
}

// Function 2423
float sdBox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0);}

// Function 2424
bool isInSpheresShadow(Intersect intersection, Light light) {
    float lightDist = length(light.position - intersection.position); //light dist
    vec3 shadowDir = normalize(light.position - intersection.position);  //light dir

    Ray shadowRay =  Ray(intersection.position + 10.0*EPSILON*shadowDir, shadowDir);
    float shadowDist = shortestDistanceToSpheres(shadowRay);

    // if intersected sphere in light direction then shadow before reaching light
    if(shadowDist != MAX_DIST_SHADOW && shadowDist < lightDist) 
        return true;
    return false;

}

// Function 2425
SDFResult sphereSDF2(Sphere sphere, vec3 p) 
{
    vec3 delta = sphere.pos - p;
    delta.xz += delta.y*delta.y*delta.y*10.0;
    return SDFResult(length(delta) - sphere.radius, sphere.matindex);
}

// Function 2426
float plane(vec3 p, vec3 n, float k){
        return dot(p, normalize(n)) + k;
      }

// Function 2427
float GetSphereArea(Object sphere)
{
	return 4.0*PI*sphere.radius*sphere.radius;
}

// Function 2428
bool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)
{
    bool hitSomething = false;
    for (int i = 0; i < spheres.length(); ++i) {
        if (hitSphere(r, spheres[i], hit)) {
            
            hitSomething = true;
            // if we hit a sphere we update maxt on the ray to only find
            // intersections that are even closer
            r.maxt = hit.t;
        }
    }
    
    
    return hitSomething;
}

// Function 2429
float MapBox(in vec3 pos, in vec3 half_size)
{//center at (0,0,0)
	vec3 v = abs(pos)-half_size;
	
	if (v.x<0.0 || v.y <0.0 || v.z<0.0)
		return max(max(v.x, v.y), v.z);
	return length(v);
}

// Function 2430
v0 cylinderY(v3 ray,v2 u, v0 radius, v0 height
){maxGISize=max(maxGISize,height*radius*ray.w)
 ;return ray.w*(max(length(ray.xz-u.xz)
 -radius, abs(ray.y-u.y)-height));}

// Function 2431
vec3 torusKnotDerivative(float t, TorusKnotParameters tkp)
{
    vec2 sicXY = sic(tkp.kp * t);
    vec2 sicRZ = tkp.r2 * sic(tkp.kq * t);
    
    vec2 dSicXY = tkp.kp * vec2(-1, 1) * sicXY.yx;
    vec2 dSicRZ = tkp.kq * vec2(-1, 1) * sicRZ.yx;
    
    return vec3(dSicRZ.x*sicXY + dSicXY*(sicRZ.x + tkp.r1), dSicRZ.y);
}

// Function 2432
float planeIntersect( vec3 ro, vec3 rd, float plane)
{
    float h = plane - ro.y;
    return h/rd.y;
}

// Function 2433
float box(vec3 pos, vec3 size)
{
    return length(max(abs(pos) - size, 0.0));
}

// Function 2434
float sphere(in vec3 pos, in float radius) {
    return length(pos) - radius;
}

// Function 2435
vec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz ,0.4);
  vec4 y = textureLod( sam, p.zx ,0.4);
  vec4 z = textureLod( sam, p.xy ,0.4);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 2436
float sdCappedCylinder( vec3 p, vec2 h ) {
        vec2 d = abs(vec2(length(p.xz),p.y)) - h;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0));
    }

// Function 2437
float intersect_sphere(inout intersection_info inf,float id, vec3 ro, vec3 rd,vec3 pos, float radius)
{
    vec2 d = intersect_sphere(ro - pos,rd,radius);
    //intersection is closer and avoid self intersection:
    if(d.x < d.y && d.x < inf.dist_id.x && abs(inf.dist_id.y - id) > 0.5)
    {
        inf.pos_ws = ro + rd * d.x;
        inf.normal_ws = normalize(inf.pos_ws - pos);
    	inf.dist_id = vec2(d.x,id);
        return 1.0;
    }
    return 0.0;
}

// Function 2438
float sphere(vec3 p, float r)
{
  return length(p)-r;
}

// Function 2439
float asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ 
    // geometric solution
    float sr2 = sr*sr;
    vec3 e0 = sp - ro; 
    float e1 = dot(e0,rd);
    float r2 = dot(e0,e0) - e1*e1; 
    if (r2 > sr2) return 1000.0; // 1000.0 is a "miss" value. unlikely to appear in "hit" data.
    float e2 = sqrt(sr2 - r2); 
    return e1-e2; 
}

// Function 2440
mat3 tile_sphere(inout vec3 pos) {
    
    mat3 M = mat3(1.);
    
    ////////////////////////////////////////////////////
    // part 1: guarantee that the point lives inside
    // the cluster of p triangles that share the vertex
    // (0, 0, 1)
    
    M *= mirror(pos, vec3(1, 0, 0));
   
    vec3 m = tri_edges[0];

    for (float i=0.; i<5.; ++i) {

        // mirror
        M *= mirror(pos, m);
        m -= tri_edges[1] * 2.0 * dot(m, tri_edges[1]);

        M *= mirror(pos, m);
        m -= tri_edges[2] * 2.0 * dot(m, tri_edges[2]);

    }

    ////////////////////////////////////////////////////
    // part 2: fold in the XY plane to make sure the 
    // point lives in the triangular cone just to the
    // right of the y axis
       
    M *= mirror(pos, vec3(1, 0, 0));
       
    float p = pqr.x;
    float k = p >= 5.0 ? 4. : p >= 3.0 ? 2. : 1.;
    
    float theta = k * PI / p;

    m = vec3(-cos(theta), sin(theta), 0); // lq
    
    if (p >= 5.0) {        
        M *= mirror(pos, m);
        m = half_angle(m);
    }
    
    if (p >= 3.0) {
        M *= mirror(pos, m);
        m = half_angle(m);
    }
    
    M *= mirror(pos, m);    

    return M;
        
}

// Function 2441
float cboxc(vec2 p,float s){s*=.5;p+=s
 ;return max(-length(abs(p)+s)+.9,length(abs(p-vec2(.3,0))-s)-1.)
 ;}

// Function 2442
float sdCylinder ( in float3 O, in float r, in float height ) {
  float d = length(O.xz) - r;
  d = max(d, abs(O.y) - height);
  return d;
}

// Function 2443
float torus(vec4 p, vec2 r) {//creates 4 toruses
    return length(vec2(abs(length(p.xyz)-r.x),p.w))-r.y;
}

// Function 2444
float sdSphere( vec3 p, float r )
{
    return length(p) - r;
}

// Function 2445
float iSphere( in vec3 ro, in vec3 rd, in vec4 sp, out vec3 nor )
{
    float t = -1.0;
	nor = vec3(0.0);
	
	vec3  rc = ro - sp.xyz;
	float b =  dot(rc,rd);
	float c =  dot(rc,rc) - sp.w*sp.w;
	float k = b*b - c;
	if( k>0.0 )
	{
		t = -b - sqrt(k);
		nor = normalize( (ro+rd*t) - sp.xyz );
	}

	return t;
}

// Function 2446
float sdBox(vec3 p, vec3 s)
{
    vec3 diffVec = abs(p) - s;
    float surfDiff_Outter = length(max(diffVec,0.0));
    float surfDiff_Inner = min( max(diffVec.z,max(diffVec.x,diffVec.y)),0.0);
    return surfDiff_Outter + surfDiff_Inner;              
}

// Function 2447
vec2 worldToProjectionPlane(vec3 point)
{
    vec4 camStart = vec4(projectionCenter + cameraOffset, 1.0);
    vec4 camToPoint = vec4(normalize(point - camStart.xyz), 0.0);
    vec4 projectionPlane = vec4(projectionForward, -FOCAL_LENGTH);
    float intersectDist = dot(projectionPlane, camStart) / dot(projectionPlane, camToPoint);
    vec3 pointOnPlane = camStart.xyz + camToPoint.xyz * intersectDist;
    float u = dot(pointOnPlane, projectionRight) / dot(projectionRight, projectionRight);
    float v = dot(pointOnPlane, projectionUp) / dot(projectionUp, projectionUp);
    return vec2(u, v);
}

// Function 2448
float IntersectCylinder( out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )
{
    vec3 m = (a.xyz+b.xyz)/2.;
    
    pos -= m; // centre all maths on the cylinder
    
    float radius = a.w;
    vec3 n = (a.xyz-b.xyz)/2.;
    float l = length(n);
    n /= l;
    
    
    // intersect infinite cylinder
    // flatten everything along the axis
    vec3 r = ray-dot(ray,n)*n;
    vec3 p = pos-dot(pos,n)*n;
    float rl = length(r);
    r /= rl;;
    float rdp = dot(r,p);
    float pp = dot(p,p);
    float q = pp - rdp*rdp;
    if ( q >= radius*radius ) return FLT_MAX;
    
    float d = sqrt(radius*radius-q);
    float front = (-rdp - d)/rl;
    float back = (-rdp + d)/rl;
    normal = normalize(p+front*r*rl);
    
    
    // intersect facing plane
    float rdn = dot(ray,n);
    float pdn = dot(pos,n);
    
    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }
    
    float front2 = (-l-pdn)/rdn;
    
    if ( front2 > front )
    {
        front = front2;
        normal = -n;
    }

    
    // clip the back sides
    if (
        front > back || // clip to back of cylinder
    	pdn+rdn*front > l // clip to back plane
        )
        return FLT_MAX;
    
    return front;
}

// Function 2449
float monsterBox(vec3 ro, vec3 rd)
{
	float hit = INF;
	float size = 0.33;
	float halfSize = 0.5*size;
	HIT(box (ro, rd, vec3(size)));
	
	ro.y -= halfSize;
	ro.z += halfSize;
	mat2 m = rot(0.017*(sin(iTime) - 48.0));
	ro.yz = m*ro.yz;
	rd.yz = m*rd.yz;
	ro.z -= halfSize;
	
	HIT(box (ro, rd, vec3(size, 0.04, size)));
	return hit;
}

// Function 2450
vec3 getConeSample(vec3 dir, float extent) {
	dir = normalize(dir);
	vec3 o1 = normalize(ortho(dir));
	vec3 o2 = normalize(cross(dir, o1));
	vec2 r =  rv2;
	r.x=r.x*2.*pi;
	r.y=1.0-r.y*extent;
	float oneminus = sqrt(1.0-r.y*r.y);
	return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;
}

// Function 2451
float sd_box(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2452
traceData sphere (vec3 p,float rad){

traceData tout;

//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - iSphereRad;
float lod1 = 0.;
if (lod1 > 0.1 ){  tout.l = lod1;}
else{
tout.p = fract((2.*(p+.5))-1.)  -.5;
tout.l = (length(tout.p) - rad)*0.8;
}
return tout;

}

// Function 2453
float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 2454
float udBox(vec3 p, vec3 b) {
	return length(max(abs(p) - b, 0.0));
}

// Function 2455
float udBox(in vec2 p, in vec2 b) {
	return length(max(abs(p)-b,0.));
}

// Function 2456
float sdBoundingBox( vec3 p, vec3 b, float e)
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 2457
int get_entry_plane(vec3 t0, vec3 tm){
    vec3 test   = step( t0.yzz,t0.xxy);
    vec3 mixed  =  mix( t0.zzz, t0.xxx, test.yyy );
    vec3 mixed2 =  mix( t0.zzz, t0.yyy, test.zzz );
    vec3 comb   =  mix( mixed2, mixed,  test.xxx );
    vec3 plane  = step( tm.zyx, comb );
    return convert_plane( bvec3(plane) );
}

// Function 2458
SSphere GetfloorSphere2()
{
	return SSphere
	(
		8,						//id
		vec3(1.5, -1.0, 1.0),	//center
		0.2,					//radius
		SMaterial
		(
			vec3(0.8,0.8,0.0),	//diffuse color
			3.0,				//specular amount
			vec3(1.0,1.0,1.0)	//specular color
		)
	);
}

// Function 2459
float sdf_half1_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, pos.y);
}

// Function 2460
vec3 uniformHemisphere(vec2 uv, vec3 n)
{
    // create tnb:
    //http://jcgt.org/published/0006/01/01/paper.pdf
    float signZ = (n.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0
    float a = -1.0 / (signZ + n.z);
    float b = n.x * n.y * a;
    vec3 b1 = vec3(1.0 + signZ * n.x * n.x * a, signZ*b, -signZ*n.x);
    vec3 b2 = vec3(b, signZ + n.y * n.y * a, -n.y);

    // remap uv to uniformly distributed points on the hemisphere around n
    float phi = PI2 * uv.x;
    float cosTheta = sqrt(uv.y);
    float sinTheta = sqrt(1.0-uv.y);
    return cosTheta*(cos(phi)*b1 + sin(phi)*b2) + sinTheta*n;
}

// Function 2461
vec3 getplane(int j) {
#if 1
  return planes[j].n;
#else
  for (int i = 0; i < 12; i++) {
    if (i == j) return planes[i].n;
  }
  return vec3(0);
#endif
}

// Function 2462
float sdCylinder( vec3 p, vec3 c )
{
	return length(p.xz-c.xy)-c.z;
}

// Function 2463
float sdCylinder( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

// Function 2464
vec3 Camera_uv_2_plane(Camera cam, vec2 uv) {
    return cam.ll + uv.x * cam.u * cam.width + uv.y * cam.v * cam.height;
}

// Function 2465
float sdBox( in vec2 p, in vec2 b ) {
	vec2 d = abs(p) - b;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2466
vec2 sdBox(vec3 p,vec3 r, float id){
    p=abs(p)-r;
    return vec2(max(max(p.x,p.y),p.z),id);
}

// Function 2467
float sdCone( vec3 p, vec2 c )
{
    float q = length(p.xy);
    return dot(c,vec2(q,p.z));
}

// Function 2468
float Box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 2469
d2 fBoxCheap(c2 p,v2 s
){c2 u=suab(p,s)//mirror clamp
 ;return madm(u);}

// Function 2470
float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return length(max(d,0.0))
    + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 2471
vec3 atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {
    // Normalize the sun and view directions.
    pSun = normalize(pSun);
    r = normalize(r);

    // Calculate the step size of the primary ray.
    vec2 p = rsi(r0, r, rAtmos);
    if (p.x > p.y) return vec3(0,0,0);
    p.y = min(p.y, rsi(r0, r, rPlanet).x);
    float iStepSize = (p.y - p.x) / float(iSteps);
	float rs = rsi2(Ray(r0, r), Sphere(vec3(0), rAtmos));
	vec3 px = r0 + r * rs;
shMie *= ( (pow(fbmHI(px  ) * (supernoise3dX(px* 0.00000669 + time * 0.001)*0.5 + 0.5) * 1.3, 3.0) * 0.8 + 0.5));
    
    // Initialize the primary ray time.
    float iTime = 0.0;

    // Initialize accumulators for Rayleigh and Mie scattering.
    vec3 totalRlh = vec3(0,0,0);
    vec3 totalMie = vec3(0,0,0);

    // Initialize optical depth accumulators for the primary ray.
    float iOdRlh = 0.0;
    float iOdMie = 0.0;

    // Calculate the Rayleigh and Mie phases.
    float mu = dot(r, pSun);
    float mumu = mu * mu;
    float gg = g * g;
    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);
    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));

    // Sample the primary ray.
    for (int i = 0; i < iSteps; i++) {

        // Calculate the primary ray sample position.
        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);

        // Calculate the height of the sample.
        float iHeight = length(iPos) - rPlanet;

        // Calculate the optical depth of the Rayleigh and Mie scattering for this step.
        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;
        float odStepMie = exp(-iHeight / shMie) * iStepSize;

        // Accumulate optical depth.
        iOdRlh += odStepRlh;
        iOdMie += odStepMie;

        // Calculate the step size of the secondary ray.
        float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);

        // Initialize the secondary ray time.
        float jTime = 0.0;

        // Initialize optical depth accumulators for the secondary ray.
        float jOdRlh = 0.0;
        float jOdMie = 0.0;

        // Sample the secondary ray.
        for (int j = 0; j < jSteps; j++) {

            // Calculate the secondary ray sample position.
            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);

            // Calculate the height of the sample.
            float jHeight = length(jPos) - rPlanet;

            // Accumulate the optical depth.
            jOdRlh += exp(-jHeight / shRlh) * jStepSize;
            jOdMie += exp(-jHeight / shMie) * jStepSize;

            // Increment the secondary ray time.
            jTime += jStepSize;
        }

        // Calculate attenuation.
        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));

        // Accumulate scattering.
        totalRlh += odStepRlh * attn;
        totalMie += odStepMie * attn;

        // Increment the primary ray time.
        iTime += iStepSize;

    }

    // Calculate and return the final color.
    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);
}

// Function 2472
float fBoxCheap(vec3 p, vec3 b) { //cheap box
   return vmax(abs(p) - b);
}

// Function 2473
float in_cylinder(
    in vec3 point,
    in Cylinder cylinder
) {
    float dist2 = distance2_point_line(point, cylinder.origin, cylinder.direction);
    return cylinder.radius * cylinder.radius - dist2;
}

// Function 2474
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return -1.0;
	return -b - sqrt( h );
}

// Function 2475
float sphere(vec3 pos, float radius)
{
    return length(pos) - radius;
}

// Function 2476
vec3 centerSphere(Ray ray) {
    // Weird colors
    float colStep = smoothstep(-0.25, 0.25, cos(iTime/2.0));
    vec3 sphereColor = vec3(0.0, 0.5, 0.5);
    float radius = length(ray.pos-vec3(0.0, 1.5, 0.0));
    sphereColor = mix(sphereColor, vec3(0.5, 0.5, 0.0), smoothstep(0.295, 0.3, radius));

    // Beach ball
    float phi = ceil(acos(dot(normalize(ray.pos.xz), vec2(1,0)))/(PI/3.0))+3.0*step(0.0, ray.pos.z);
    vec3 bbColor = vec3(0.0);
    bbColor += vec3(1.0,0.0,0.0)*step(0.5, phi)*step(phi, 1.5);
    bbColor += vec3(1.0)*step(1.5, phi)*step(phi, 2.5);
    bbColor += vec3(0.0,0.0,1.0)*step(2.5, phi)*step(phi, 3.5);
    bbColor += vec3(1.0,0.5,0.0)*step(3.5, phi)*step(phi, 4.5);
    bbColor += vec3(0.75,0.7,0.3)*step(4.5, phi)*step(phi, 5.5);
    bbColor += vec3(0.0,1.0,0.0)*step(5.5, phi)*step(phi, 6.5);

    bbColor = mix(vec3(1.0), bbColor, step(0.01, dot(ray.pos.xz, ray.pos.xz)));

    return mix(sphereColor, bbColor, colStep);
}

// Function 2477
float fBox2(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));
}

// Function 2478
float sphere ( vec3 p ) {
	p -= vec3(0.,0.,1.);
	return length(p) - 0.5;
}

// Function 2479
bool sphereIntersection(in Ray r,out HitRecord hit, float maxT) {
    /* 
     Function used to find intersection between the traced ray and spheres.
     r, the traced ray
     hit, current hitrecod
     maxT, largest distance
    */
    
    float minT = 0.0001;
    float currentT = maxT;
    vec3 normal;
    material mat;

    for (int i = 0; i < spheres.length(); ++i) { // Loop through all spheres
        // Code for ray-spehere intersection, the intersection is found by combining the equations and solve for t.
        vec3 oc = r.orig - spheres[i].center; // Difference ray origin and sphere's center.
        float a = dot(r.dir, r.dir);
        float b = 2.0 * dot(oc, r.dir);
        float c = dot(oc, oc) - spheres[i].radius * spheres[i].radius;
        float det = b*b - 4.0*a*c;
        float denominator = (2.0 * a);

        // Possible intersection
        if (denominator != 0.0 && det >= 0.0) {
            float t1 = (-b - sqrt(det)) / denominator;
            float t2 = (-b + sqrt(det)) / denominator;
            float t = min(t1, t2);
            if (minT < t && t < currentT) { 
                currentT = t;
                normal = normalize(r.orig + t * r.dir - spheres[i].center);
                mat = spheres[i].mat;
            }
        }  
    }
    if (currentT != maxT) {
        hit.t = currentT;
        hit.mat = mat;
        hit.normal = normal;
        return true;
    }
    else
        return false;
}

// Function 2480
float sdBox( vec3 p, vec3 b)
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2481
float cappedCylinderSDF(vec3 p, vec2 h) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2482
float sdBox(vec3 p, vec3 b, float idx)
{
    p.xz *= r2d(PI/4.0+idx*25.);
    vec3 a = abs(p)-b;
    return max(a.x, max(a.y, a.z));
}

// Function 2483
maybe_float get_distance_along_3d_line_to_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r,
    in float h
){
    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));
    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;
    cone = get_distance_along_line_to_union(end, cone);
    return cone;
}

// Function 2484
vec3 i_spheremap_32( uint data )
{
    vec2 v = unpackSnorm2x16(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 2485
intersection_t sphere_intersect( sphere_t s, ray_t r )
{
    intersection_t intersection;
    
    float a = dot( r.d, r.d );
    float b  = 2.0 * dot( r.o - s.pos, r.d );
    float c  = - (s.r * s.r) + dot( r.o  - s.pos, r.o - s.pos );
    float d  = b*b - 4.0*a*c;
    if( d < 0.0 ) { ist.t = INFINITY; return ist; }
    ist.t = ( - b - sqrt( d ) ) / (2.0 * a);
    if( ist.t < 0.0 ) { ist.t = INFINITY; return ist; }
    ist.iray = r.d;
    ist.hitpt = (r.d * ist.t) + r.o;
    ist.normal = normalize( ist.hitpt - s.pos );
    ist.mat = s.mat;
    
    return ist;
}

// Function 2486
vec2 sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 N_ray){
    
    float t_impact = INFINI;
    float t1, t2;
    vec3 delta = pos - sphO;
    float dmin = 0.;
    
    // Sphere interception
    // pre-calculation
    float dot_delta_N_ray = dot(delta, N_ray);
    float c = dot(delta,delta) - sphR*sphR;
    
    float discr = dot_delta_N_ray*dot_delta_N_ray - c;
    
    if (discr >= 0.){
       	float sqrt_discr = sqrt(discr);
        t1= (-dot_delta_N_ray + sqrt_discr);
        t2= (-dot_delta_N_ray - sqrt_discr);
        t_impact = min(t1,t2) ;
        if (t_impact <= 0.001){
            t_impact = max(t1,t2);
            if (t_impact <= 0.001) t_impact = INFINI;
        } 
    }
        
    dmin = abs(c - dot_delta_N_ray*dot_delta_N_ray)/sphR;
    
    return vec2(t_impact, dmin);
}

// Function 2487
float box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2488
void TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)
{
    float dist = SphereDistance(sphere, rayPos);
    if (dist < info.dist)
    {
        info.rayMarchedObject = true;
        info.dist = dist;        
        info.normal = normalize(rayPos - sphere.xyz);
        info.material = material;
    }    
}

// Function 2489
float tracePlane( in vec4 pl, in vec3 ro, in vec3 rd ) {
    return -(dot(pl.xyz,ro)+pl.w)/dot(pl.xyz,rd);
}

// Function 2490
float SphereD(vec3 po, vec3 rd){
	float b=dot(po,rd);
	return sqrt(abs(dot(po,po)-b*b));
}

// Function 2491
float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra, float tmin, float tmax )
{
    vec2 tt = sphIntersect(ro, rd, ce, ra);
    bool hit = false;
    if (tt.x > tmin && tt.x < tmax) { hit = true; tmax = tt.x; }
    if (tt.y > tmin && tt.y < tmax) { hit = true; tmax = tt.y; }
    return (hit) ? tmax : -1.;
}

// Function 2492
bool intersectSphere(Sphere sphere, Ray ray, out HitInfo hitInfo) {
    bool hit = false;
    vec3 v = sphere.pos - ray.pos;
    float b = dot(v, ray.dir);
    float c = dot(v, v) - sphere.radius * sphere.radius;
    float disc = b * b - c;
    
    if (disc < 0.0) {
        return false;
    }
    
    disc = sqrt(disc);
    
    hitInfo.t = b - disc;
    if (hitInfo.t <= 0.0) {
        hitInfo.t = b + disc;
        if (hitInfo.t <= 0.0) {
            return false;
        }
    }
    
    hitInfo.pos = ray.pos + ray.dir * hitInfo.t;
    hitInfo.normal = normalize(hitInfo.pos - sphere.pos);
    return true;
}

// Function 2493
float sdCylinderZ(vec3 p, vec2 h)
{
  vec2 d = abs(vec2(length(p.xy),p.z)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2494
float box(vec2 uv){
    float d = abs(uv.x);
    
    d = smoothstep(0.05,0.045,d) * smoothstep(0.05,0.045,abs(uv.y));
    
    return d;
}

// Function 2495
float sdCone( vec3 p, vec2 c )
{
    // c is the sin/cos of the angle
    vec2 q = vec2( length(p.xz), p.y );
    float d = length(q-c*max(dot(q,c), 0.0));
    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);
}

// Function 2496
vec2 stereographicSphereToPlane(vec3 cartPointOnSphere) 
{
    return vec2(
        cartPointOnSphere.x / (1.0-cartPointOnSphere.y), 
        cartPointOnSphere.z / (1.0-cartPointOnSphere.y));
}

// Function 2497
void getMovingSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center, inout vec3 speed ) {
	// falling?
	float s = 0.1+hash12( grid );
    
	float t = fract(14.*s + time/s*.3);	
	float y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );
    
    speed = vec3(0, s * MAXHEIGHT * ( 8.*t - 4. ), 0 ) * (1./FPS);
    
	vec2 offset = grid + sphereOffset;
	
	center = vec4(  offset.x + 0.5*GRIDSIZE, 1. + y, offset.y + 0.5*GRIDSIZE, 1. );
}

// Function 2498
vec3 uniformHemisphere(float u1, float u2)
{
	float r=sqrt(1.-u1*u1);
	float phi=2.*PI*u2;
	return vec3(r*cos(phi),u1, r*sin(phi));
}

// Function 2499
float distSphere( vec3 pos, float radius ) {
    return length( pos ) - radius;
}

// Function 2500
vec4 traceCylinder(vec3 rayDirection)
{
    float radius = 0.5;
    float zmax = 1.0;
    float zmin = -1.0; // cylinder length is 2, centered on origin
    
    vec3 eye = vec3(0.0, 0.2, 0.0);
 
    float a = dot(rayDirection.xy, rayDirection.xy);
    float b = -2.0 * dot(eye.xy, rayDirection.xy);
    float c = dot(eye.xy, eye.xy) - radius * radius;

    float t = b*b - 4.0 * a*c;
    vec3 intersection;
    bool cap = true;
    
    if (abs(a) > 0.0)
    {
        float t1 = (b + sqrt(t)) / (2.0 * a);
        float t2 = (b - sqrt(t)) / (2.0 * a);
        if (t1 > t2)
        {
            float temp = t1;
            t1 = t2;
            t2 = temp;
        }
        if (t1 > 0.0 && t2 > 0.0)
        {
	        float z1 = eye.z + t1 * rayDirection.z;
    	    float z2 = eye.z + t2 * rayDirection.z;
        
        	if (z1 > zmin && zmax > z2)
        	{
            	cap = false;
                intersection = eye + t1 * rayDirection;
        	}
        }
        else if (t1 > 0.0)
        {
	        float z1 = eye.z + t1 * rayDirection.z;
        
        	if (z1 > zmin && zmax > z1)
        	{
            	cap = false;
                intersection = eye + t1 * rayDirection;
        	}
        }
        else
        {
	        float z1 = eye.z + t2 * rayDirection.z;
        
        	if (z1 > zmin && zmax > z1)
        	{
            	cap = false;
                intersection = eye + t2 * rayDirection;
        	}
        }
    }
        
    float pi = 3.1415926;
    float two_pi = 2.0 * pi;

    if (cap)
    {
        // since the cylinder is canonically at the origin
        if (rayDirection.z > 0.0)
        {
            // intersect ray with +z cap
            //t = -(dot(eye, capNormal + d) / (dot(rayDirection, capNormal);
            t = -(-eye.z + zmax) / -rayDirection.z;
            intersection = eye + t * rayDirection;
	        float angle = atan(intersection.y, intersection.x);
    	    angle = mod(angle + two_pi, two_pi) / two_pi;
            float radius = dot(intersection.xy, intersection.xy);
        	return vec4(mod(angle * 16.0, 1.0) * 2.0 * radius, 0, 0, 1);
        }
        // intersect ray with -z cap
        //t = -(dot(eye, capNormal + d) / (dot(rayDirection, capNormal);
        t = -(eye.z + zmax) / rayDirection.z;
        intersection = eye + t * rayDirection;
        float angle = atan(intersection.y, intersection.x);
        angle = mod(angle + two_pi, two_pi) / two_pi;
        float radius = dot(intersection.xy, intersection.xy);
       	return vec4(mod(angle * 16.0, 1.0) * 2.0 * radius, 0, 0, 1);
    }
    else
    {        
        // cylinder
        float angle = atan(intersection.y, intersection.x);
        angle = mod(angle + two_pi, two_pi) / two_pi;
        return vec4(mod(angle * 16.0, 1.0), 0, 0, 1);
    }
}

// Function 2501
vec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)
{
    
  if ( ray_dir.z > 0.0)
  {
    return vec3(0,0,0);
  }

  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;
  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);
  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);
  return vec3(intresection_x, intresection_y, 0);
}

// Function 2502
float iSphere4( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
                in float ra ) {
    // -----------------------------
    // solve quartic equation
    // -----------------------------
    
    float r2 = ra*ra;
    
    vec3 d2 = rd*rd; vec3 d3 = d2*rd;
    vec3 o2 = ro*ro; vec3 o3 = o2*ro;

    float ka = 1.0/dot(d2,d2);

    float k0 = ka* dot(ro,d3);
    float k1 = ka* dot(o2,d2);
    float k2 = ka* dot(o3,rd);
    float k3 = ka*(dot(o2,o2) - r2*r2);

    // -----------------------------
    // solve cubic
    // -----------------------------

    float c0 = k1 - k0*k0;
    float c1 = k2 + 2.0*k0*(k0*k0 - (3.0/2.0)*k1);
    float c2 = k3 - 3.0*k0*(k0*(k0*k0 - 2.0*k1) + (4.0/3.0)*k2);

    float p = c0*c0*3.0 + c2;
    float q = c0*c0*c0 - c0*c2 + c1*c1;
    float h = q*q - p*p*p*(1.0/27.0);

    // -----------------------------
    // skip the case of 3 real solutions for the cubic, which involves 
    // 4 complex solutions for the quartic, since we know this objcet is 
    // convex
    // -----------------------------
    if (h<0.0) {
        return MAX_DIST;
    }
    
    // one real solution, two complex (conjugated)
    h = sqrt(h);

    float s = sign(q+h)*pow(abs(q+h),1.0/3.0); // cuberoot
    float t = sign(q-h)*pow(abs(q-h),1.0/3.0); // cuberoot

    vec2 v = vec2( (s+t)+c0*4.0, (s-t)*sqrt(3.0) )*0.5;
    
    // -----------------------------
    // the quartic will have two real solutions and two complex solutions.
    // we only want the real ones
    // -----------------------------
    
    float r = length(v);
	float d = -abs(v.y)/sqrt(r+v.x) - c1/r - k0;

    if (d >= distBound.x && d <= distBound.y) {
	    vec3 pos = ro + rd * d;
	    normal = normalize( pos*pos*pos );
	    return d;
    } else {
        return MAX_DIST;
    }
}

// Function 2503
float sphere( in vec3 p, in float size)
{
	return length(p)-size;
}

// Function 2504
vec3 projPtOnPlane(vec3 p, vec3 pPlane, vec3 nPlane) {
    return pPlane + projVecOnPlane(p-pPlane, nPlane) ;
}

// Function 2505
float sdRoundCone( in vec3 p, in float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));
    
    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
    return dot(q, vec2(a,b) ) - r1;
}

// Function 2506
float deSpheres(vec3 pos){
    return vornoi(pos) - SpheresRadius;
}

// Function 2507
float traceSphere( in vec3 ro, in vec3 rd, in vec4 sph ){

	ro -= sph.xyz;
	float b = dot(ro, rd);
	float h = b*b - dot(ro, ro) + sph.w*sph.w;
    return h<0. ? -1. : -b - sqrt( h );
}

// Function 2508
float sdf_sphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 2509
float sdCone(in vec4 p,in vec2 h ) {
  return max( length(p.xzw)-h.x, abs(p.y)-h.y) - h.x*p.y;
}

// Function 2510
SDFResult sphereSDF(Sphere sphere, vec3 p) 
{
    vec3 diff = (sphere.pos - p);
    diff.y *= 0.65;
    return SDFResult(length(diff) - sphere.radius, sphere.matindex);
}

// Function 2511
vec3 ClosestPointOnQuadOrPlane(vec3 P, Object quad, bool isInfinitePlane)
{
	vec3 V = P - quad.pos;
	float vz = dot(V, quad.quadNormal);
	if (!isInfinitePlane) {
		float vx = dot(V, quad.quadBasisX); // note quadBasis is divided by extent
		float vy = dot(V, quad.quadBasisY);
		vx = clamp(vx, -1.0, 1.0);
		vy = clamp(vy, -1.0, 1.0);
		return QuadLocalToWorld(vec2(vx, vy), quad);
	} else
		return P - quad.quadNormal*vz;
}

// Function 2512
float
torus2mh_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);
    return length(q)-torus.y;
}

// Function 2513
float ubox(vec3 samplePoint) {
    return length(max(abs(samplePoint) - vec3(1.0, 1.0, 1.0), 0.0));
}

// Function 2514
float BoxDF(vec3 coord)
{
    // Fixed-position 3/4-unit box at the origin
    vec3 d = abs(coord) - vec3(0.75, 0.75, 0.75);
  	return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)); 
}

// Function 2515
bool isinbox(vec2 a,vec2 b,float s){return(a>b)&&(a<b+s);}

// Function 2516
float sdCone( vec3 p, vec2 c )
{
    float q = length(p.xz);
    return max( dot(c,vec2(q,p.y)), p.y );
}

// Function 2517
vec3 skyBox(vec3 rayDir)
{
    float c = clamp(1.0 - length(rayDir.xy),0.0, 1.0);
    
    return mix(mix(skyColor1, skyColor3, rayDir.y), skyColor2, c);
}

// Function 2518
vec4 makeSphere( vec2 pos )
{
	vec3  rr = hash3(pos);
	float ha = 0.2 + 1.3*rr.z;
	vec2  oo = 0.5 + 0.3*(-1.0 + 2.0*rr.xy);
	vec3  ce = vec3( pos.x+oo.x, ha, pos.y+oo.y );
	float ra = (0.5+0.5*rr.z)*min( min(oo.x,1.0-oo.x), min(oo.y,1.0-oo.y) );
ra *= 0.85+0.15*sin( 1.5*iTime + hash1(pos)*130.0 );
	
	ce.y += 0.3*smoothstep( 0.995, 0.996, sin(0.015*iTime+100.0*hash1(hash1(pos))) );
	
	return vec4( ce, ra );
}

// Function 2519
vec3 GetPointOnPlane(vec4 S, vec2 p){
    return vec3(p.xy,(S.w-dot(S.xy,p))/S.z);
}

// Function 2520
float DF_sphere( vec3 p, float size )
{
	return length(p)-size;    
}

// Function 2521
float sdSphere(in vec3 p, float s) {
    return length(p) - s;
}

// Function 2522
float box(in vec3 p, in vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2523
bool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)
{    
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.fromInside = fromInside;
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        return true;
    }
    
    return false;
}

// Function 2524
int sphereVisibility( in vec3 ca, in float ra, in vec3 cb, float rb, in vec3 c )
{
    float aa = dot(ca-c,ca-c);
    float bb = dot(cb-c,cb-c);
    float ab = dot(ca-c,cb-c);
    
    float s = ab*ab + ra*ra*bb + rb*rb*aa - aa*bb; 
    float t = 2.0*ab*ra*rb;

	     if( s + t < 0.0 ) return 1;
	else if( s - t < 0.0 ) return 2;
	                       return 3;
}

// Function 2525
float sdCappedCylinder( vec3 p, float h, float r )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2526
vec4 traceSphere(vec3 camera, vec3 dir, float radius) {
    float k = dot(camera, dir);
    float c = dot(camera, camera) - radius * radius;
    float D = k * k - c;
    if (D < 0.) return vec4(0); 
    float s = -k - sqrt(D);
    vec3 p = camera + s * dir;
    return vec4(normalize(p), smoothstep(0., 0.03, D));
}

// Function 2527
float Boxes(vec3 pos) 
{
vec3 rok = vec3(0.35);
float m;
m = length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,0.0),iTime*0.3 ),iTime*0.15))-rok,0.0))-0.03; // Cube
m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3, 1.2),iTime*0.21),iTime*0.24))-rok,0.0))-0.03); 
m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(0.0,-0.3,-1.2),iTime*0.2 ),iTime*0.3 ))-rok,0.0))-0.03); 
m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(1.2,-0.3, 0.0),iTime*0.17),iTime*0.26))-rok,0.0))-0.03); 
m = min (m,length(max(abs(rotYaxis(rotXaxis(pos+vec3(-1.2,-0.3,0.0),iTime*0.32),iTime*0.2 ))-rok,0.0))-0.03); 
return m;
}

// Function 2528
float sdSphere(vec3 p, float s) {
    return length(p) - s;
}

// Function 2529
vec4 planetDim(float ttime) {
  vec4 s_p = s_planet;
  s_p.xz *= ROT(-(ttime-26.0*TAU)*0.01);
  return s_p;
}

// Function 2530
float sdSphere( vec3 p, float s )
{
	return length(p)-s;
}

// Function 2531
float sphere(vec3 v, float r) {
    return length(v) - r;
}

// Function 2532
float BoundingBoxSD(vec3 position, vec3 bounds, float edge, float bevel)
{
    position = abs(position) - bounds;
    vec3 q = abs(position + edge) - edge;
    return min(min(
        length(max(vec3(position.x, q.y, q.z), 0.0)) + min(max(position.x, max(q.y, q.z)), 0.0),
        length(max(vec3(q.x, position.y, q.z), 0.0)) + min(max(q.x, max(position.y, q.z)), 0.0)),
        length(max(vec3(q.x, q.y, position.z), 0.0)) + min(max(q.x, max(q.y, position.z)), 0.0))- bevel;
}

// Function 2533
vec3 map_box_norm(vec3 ro) { 
    vec3 d = ro - b1.c;
    //do a nice bevel
    return normalize(step(b1.s * .95, abs(d))*sign(d));
}

// Function 2534
float distBox( vec3 p, vec3 halfSize)
{
    vec3 q = abs(p) - halfSize;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2535
poly2 sphere(poly2 x, poly2 y, poly2 z, float r) {
    return pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(y)),pa_pow2(z)), r*r);
}

// Function 2536
vec2 boxIntersect( in vec3 ro, in vec3 rd,
                   in vec3 c, in vec3 r,
                   out vec3 normal )
{
    ro -= c;
    rd += 1e-20; // Avoid errors when ray is aligned with an axis
    vec3 m = 1.0/rd;
    vec3 n = m * ro;
    vec3 k = abs(m) * r;
    vec3 t1 = -n-k;
    vec3 t2 = -n+k;
    
    float tmin = max(t1.x, max(t1.y, t1.z));
    float tmax = min(t2.x, min(t2.y, t2.z));
    
    if(tmax < tmin || tmax < 0.0) return vec2(-1.0); // no intersection
    
    normal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    return vec2(tmin, tmax);
}

// Function 2537
float sdCylinder( vec3 p, float c )
{
  return length(p.xz)-c;
}

// Function 2538
float sphere_sdf(vec3 query_point, float sphere_radius) {
    float l = length(query_point);
    float df = l - sphere_radius;
    
    return df;
}

// Function 2539
float distBox(vec3 p, vec3 r){
  vec3 t = abs(p) - r;
  return length(max(t,0.0)) + min(max(t.x,max(t.y,t.z)),0.0);
}

// Function 2540
vec2 planeProjection(in vec2 uv)
{
	vec3 eye = vec3(0.0, -0.2, 0.0);
    float viewPortZ = 0.5;
    float viewPortH = 2.0;
    float viewPortW = viewPortH * iResolution.x / iResolution.y;
    vec2 center = vec2(viewPortW/2.0, viewPortH/2.0);
    
    vec2 dir = (vec2(uv.x*viewPortW, uv.y*viewPortH) - center) / viewPortZ; // (dx,dy) per unit of z 
    
    
    // Intersecting (x,z) plane in y=0.0
    float zIntersect = eye.y / dir.y;
    float xIntersect = zIntersect * dir.x;
            
    vec2 planeUv = vec2(xIntersect, zIntersect);

    if(planeUv.y > 1.0)
    {
    	planeUv.y = -1.0;
    }
    
    return planeUv;
}

// Function 2541
float distFromPlane(Plane plane, vec3 p) {
	return dot(plane.normal, p) + plane.offset;
}

// Function 2542
float planetIntersection(in vec3 origin, in vec3 direction)
{
    float b = dot(direction, origin);
    float d = b * b - dot(origin, origin) + Re * Re;
    return (d >= 0.0) ? (-b - sqrt(d)) : 0.0;
}

// Function 2543
float sdSphere(vec3 pos, float rad)
{
 	return length(pos) - rad;
}

// Function 2544
vec3 boxN(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {
    vec3 tMin=(bmin-origin)*dir;
    vec3 tMax=(bmax-origin)*dir;
    vec3 t2=min(tMin,tMax);
    return ((t2.x>t2.y && t2.x>t2.z)?vec3(-sign(dir.x),0.,0.):((t2.y>t2.z)?
    				vec3(0.,-sign(dir.y),0.):vec3(0.,0.,-sign(dir.z))));
}

// Function 2545
bool raySphereIntersect(const in vec3 orig, const in vec3 dir, const in float radius, out float t0, out float t1) {
    float b = dot(dir, orig);
    float c = dot(orig, orig) - (radius * radius);
	float test = b*b - c;
    // Intersection should have two points
    if (test <= 0.0) return false;
	test = sqrt(test);
	t0 = -b - test;
	t1 = -b + test;
	if (t0 > t1) t0 = t1, t1 = t0;
	return true;
}

// Function 2546
vec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )
{
    // project+fetch
    vec4 x = texture( s, p.yz );
    vec4 y = texture( s, p.zx );
    vec4 z = texture( s, p.xy );
    
    // blend factors
    vec3 w = pow( abs(n), vec3(k) );
    // blend and return
    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);
}

// Function 2547
vec3 squareToHemisphereCosine(vec2 sampleP)
{
    //TODO
    vec3 diskSample = squareToDiskConcentric(sampleP);
    float z = sqrt(1.0 - pow(diskSample.x, 2.0) - pow(diskSample.y, 2.0));
    return vec3(diskSample.x, diskSample.y, z);
}

// Function 2548
void m3_sphere(inout ray r, rObj o) {
    vec3 nml = normalize(r.pos - o.pos);
    r.pos += nml * EPSILON * 2.;
    r.dir = reflect(r.dir, hashRot(nml, 0.05));
    r.col *= vec3(0.89, 0.99, 0.89);
}

// Function 2549
float sdfSphere(in vec3 pos, in float radius) {
	return length(pos) - radius;   
}

// Function 2550
RayHit SphereIntersect2(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, float material)
{
    RayHit rh = NewRayHit();
    rh.material = material;
    vec3 delta = spherePos - pos;
    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);
    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;
    vec3 bv = proj - delta;
    float b = length(bv);
    if (b > rad) {
        //rh.tMin = bignum;
        //rh.tMax = bignum;
        return rh;
    }
    float x = sqrt(rad*rad - b*b);
    rh.tMin = projdist - x;
    if (rh.tMin < 0.0) {
        rh.tMin = bignum;
        return rh;
    }
    rh.tMax = projdist + x;
    rh.hitMin = pos + dirVecPLZNormalizeMeFirst * rh.tMin;
    rh.hitMax = pos + dirVecPLZNormalizeMeFirst * rh.tMax;
    rh.normMin = normalize(rh.hitMin - spherePos);
    rh.normMax = normalize(spherePos - rh.hitMax);
    return rh;
}

// Function 2551
float sdCone(in vec4 p,in vec2 h ) {
                  return max( length(p.xzw)-h.x, abs(p.y)-h.y) - h.x*p.y;
                }

// Function 2552
void intersect_sphere(
	in ray_t ray,
	in sphere_t sphere,
	inout hit_t hit
){
	vec3 rc = sphere.origin - ray.origin;
	float radius2 = sphere.radius * sphere.radius;
	float tca = dot(rc, ray.direction);
//	if (tca < 0.) return;

	float d2 = dot(rc, rc) - tca * tca;
	if (d2 > radius2)
		return;

	float thc = sqrt(radius2 - d2);
	float t0 = tca - thc;
	float t1 = tca + thc;

	if (t0 < 0.) t0 = t1;
	if (t0 > hit.t)
		return;

	vec3 impact = ray.origin + ray.direction * t0;

	hit.t = t0;
	hit.origin = impact;
	hit.normal = (impact - sphere.origin) / sphere.radius;
}

// Function 2553
float sdPlane( vec3 p )
{
	return p.y;
}

// Function 2554
float sdCone_(vec3 p, vec3 a, vec3 b, float r1, float r2)
{
    vec3 ab = b-a, ap = p-a;
    float t = clamp(dot(ap,ab)/max(dot(ab,ab),P),0.,1.);
    return length(ap-ab*t)-mix(r1,r2,t);
}

// Function 2555
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	vec2 r = hash2();
    //vec2 r = Halton();
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 2556
float plane(vec3 n, vec3 pos){
    return dot(pos, n);
}

// Function 2557
float rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n), t = 1e8;
    
    if (abs(dn)>.0001){
        t = dot(p - o, n)/dn;
        t += float(t<0.)*1e8;
    }
    
    return t;
}

// Function 2558
float sdBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 2559
float y_sphere_1(in float offset) {
    if (offset >= 0.0 && offset <= 4.0) 
        return 0.0;
    else if (offset > 4.0 && offset <= 6.0)
        return sin((offset - 4.0) / 2.0 * PI / 2.0) * movement;
    else if (offset > 6.0 && offset <= 20.0)
        return movement;
    else
        return y_sphere_common(offset);
}

// Function 2560
float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
	return dot(p, n) + distanceFromOrigin;
}

// Function 2561
float sdTorus( in vec3 p, in float ra, in float rb )
{
    return length( vec2(length(p.xz)-ra,p.y) )-rb;
}

// Function 2562
float hyperplane (vec4 p, float h) {
    return p.y-h;
}

// Function 2563
void surface2x3_perspective_plane(in surface2x3 surf, float x,
	out surface2x2 slice) {
	float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
	float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];
	float G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];
    float J = surf.c[9];

    // y -> y
    // z -> x
    slice.c[0] = (A*x + E)*x + C;
    slice.c[1] = B;
    slice.c[2] = D*x + F;
    slice.c[3] = G*x + I;
    slice.c[4] = H;
    slice.c[5] = J;
}

// Function 2564
vec3 SPHERE_ROTATE(vec3 ro, float t)
{
    // Spheres are uniform in every direction + contain no hidden
    // surfaces
    return ro;
}

// Function 2565
float sdCappedCylinder( vec3 p, vec2 h )
{
  p -= vec3(0.,h.y, 0);
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2566
void boxFold(inout vec3 z, inout float dz) {
	float foldingLimit = 1.0;
    z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
}

// Function 2567
vec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout seed_t seed ) {
    vec2 r = get_next_rnd(seed).xy;
    vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
    vec3  vv = cross(uu, n);
    float ra = sqrt(r.y);
    float rx = ra*cos(6.28318530718*r.x); 
    float ry = ra*sin(6.28318530718*r.x);
    float rz = sqrt(1.-r.y);
    vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 2568
float plane(in vec3 p, in vec3 n, in float d)
{
    return dot(p, n) + d;
}

// Function 2569
float bentBox(in vec2 bp, in vec3 pos, in vec3 dims) {
    float c = cos(bp.x * pos.y);
    float s = sin(bp.y * pos.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m * pos.xy, pos.z);
    return box(q, dims);
}

// Function 2570
vec4 intersectCylinder(vec3 rpos, vec3 rdir, vec3 pos, float rad)
{
	vec3 op = pos - rpos;
	vec2 rdir2 = normalize(rdir.yz);
	float b = dot(op.yz, rdir2);
	float det = b*b - dot(op.yz, op.yz) + rad*rad; 
	
	if (det > 0.0)
	{
		det = sqrt(det);
		float t = b - det;
		if (t > eps)
			return vec4(-normalize(rpos.yz+rdir2*t-pos.yz), 0.0, t);
		t = b + det;
		if (t > eps)
			return vec4(-normalize(rpos.yz+rdir2*t-pos.yz), 0.0, t);
	}
	
	return vec4(0.0);
}

// Function 2571
float hSphere(in vec4 pos, float r)
{
    return length(pos)-r;
}

// Function 2572
float sphere2(vec2 p, float r) {
	return length(p) - r;
}

// Function 2573
float sdCylinder(vec3 p, float r)
{
    return length(p.xz) - r;
}

// Function 2574
float sBox(vec2 p, vec2 b, float r){
  
  // Just outside lines.
  //p = max(abs(p) - b + r, 0.);
  //return length(p) - r;

  // Inside and outside lines.
  vec2 d = abs(p) - b + r;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;
}

// Function 2575
vec3 sphereNormals(in vec2 uv) {
  uv = fract(uv) * 2.0 - 1.0;
  vec3 ret;
  ret.xy = sqrt(uv * uv) * sign(uv);
  ret.z = sqrt(abs(1.0 - dot(ret.xy, ret.xy)));
  ret = ret * 0.5 + 0.5;
  return mix(vec3(0.0), ret, smoothstep(1.0, 0.98, dot(uv, uv)));
}

// Function 2576
bool rayZPlaneIntersection( in Ray ray, in vec3 pos, in vec2 size, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    t = (pos.y - ray.origin.y) / ray.dir.y;
    isect.position_ = ray.origin + ray.dir*t;
    vec3 p_loc 		= isect.position_ - pos;
    isect.uv_ 		= (p_loc.xz - (-size*0.5)) / size;
    isect.normal_ 	= vec3( 0.0, 1.0, 0.0 );
    isect.tangent_ 	= vec3( 1.0, 0.0, 0.0 );
    return ((p_loc.x > -size.x*0.5) && (p_loc.x < size.x*0.5) && (p_loc.z > -size.y*0.5) && (p_loc.z < size.y*0.5));
}

// Function 2577
vec4 SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)
{
    vec3 radialVec = pos - spherePos;
    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);
    float c = dot(radialVec, radialVec) - rad * rad;
    float h = b * b - c;
    if (h < 0.0) return vec4(bignum);
    float t = -b - sqrt(h);

    vec3 normal = normalize(radialVec + dirVecPLZNormalizeMeFirst * t);
    return vec4(normal, t);
}

// Function 2578
float sdTorus (in vec3 p, in vec2 t)
{
    vec2 q = vec2 (length (p.xz) - t.x, p.y);
    return length (q) - t.y;
}

// Function 2579
void getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {
	// falling?
	float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );
	float t = fract(14.*s + time/s*.3);
	
	float y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );
	vec2 offset = grid + sphereOffset;
	
	center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );
}

// Function 2580
float udRoundBox(vec3 p, vec3 b, float r) {
    return length(max(abs(p)-b, .0)) -r;
}

// Function 2581
float sdInfBox(vec2 p, vec2 b) {
	vec2 d = abs(p) - b;
	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2582
vec4 cylinder(vec3 ray, vec3 pos, float size, vec3 raylen) {
    vec3 lens = vec3(
        circle((ray.yz)*raylen.x,vec3(pos.yz,size)).y*raylen.x,
    	circle((ray.xz)*raylen.y,vec3(pos.xz,size)).y*raylen.y,
        circle((ray.xy)*raylen.z,vec3(pos.xy,size)).y*raylen.z);
    
    vec3 mask = vec3(greaterThan(lens,max(lens.yzx,lens.zxy)));
    float len = dot(lens,mask);
    
    return vec4(len, (pos+ray*dot(lens,mask))*(1.0-mask)/size);
}

// Function 2583
float cylinder( in vec4 sph, in vec3 ro, in vec3 rd )
{
    vec3  d = ro - sph.xyz;
    float a = dot( rd.xz, rd.xz );
    float b = dot( rd.xz, d.xz );
    float c = dot( d.xz, d.xz ) - sph.w*sph.w;
    float t;

    t = b*b - a*c;
    if( t>0.0 )
    {
        t = -(b+sqrt( t ))/a;
    }

    return t-.001;

}

// Function 2584
float sdf_half2_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, pos.x);
}

// Function 2585
vec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )
{
    return sign(pos)*normalize(max(abs(pos)-siz,0.0));
    
}

// Function 2586
float plane( in vec3 p) {
  return p.y + 1.0;
}

// Function 2587
vec3 boxmap(vec3 p, vec3 n) {
	n = pow(abs(n), vec3(32));
	vec3 tx = tex1(p.yz);
	vec3 ty = tex2(p.zx);
	vec3 tz = tex3(p.xy);
	return (tx*n.x + ty * n.y + tz * n.z) / (n.x + n.y + n.z);
}

// Function 2588
void getSphereOffset( const vec2 grid, out vec2 center ) {
	center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);
}

// Function 2589
float sdPlane( vec3 p)
{
  return p.y;
}

// Function 2590
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf
}

// Function 2591
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	return vec2( max( max( t1.x, t1.y ), t1.z ),
	             min( min( t2.x, t2.y ), t2.z ) );
}

// Function 2592
vec4 box(vec3 pos, vec3 size)
{
    vec3 d = abs(pos) - size;
    return vec4(
        min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)),
        normalize(pos)
    );
}

// Function 2593
float cone4(vec4 u,vec2 c//c must be normalized, sphere is in .yzw plane
){return dot(c,vec2(u.x,length(u.yzw)));}

// Function 2594
float trPlane(vec3 rayOrigin, vec3 rayDir, vec4 normal)
{  
	float d = dot(normal.xyz, rayDir);

  // Normal and ray perpendicular 
	if (d == 0.0)
		return -1.0;
	
	float t = (normal.w - dot(normal.xyz, rayOrigin)) / d;

	// Behind ray
  if (t <= 0.0)
  	return -1.0;
	
	return t;
}

// Function 2595
vec2 sdSphere(vec3 p, float s, float id)
{
  return vec2(length(p) - s, id);
}

// Function 2596
float sdSphere(vec3 p, vec3 pos, float r)
{
    return distance(pos, p) - r;
}

// Function 2597
float torus(vec3 r, vec2 a)
{
    vec2 p = vec2(length(r.xz) - a.x, r.y);
    return length(p) - a.y;
}

// Function 2598
float sdRoundedCylinder( vec3 p, float ra, float rb, float h )
{
    vec2 d = vec2( length(p.xz)-ra+rb, abs(p.y) - 0.5*h );
    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 2599
void LightBoxLight (in vec3 cameraPos, in vec3 shadePoint, vec3 normal, vec3 directionalLightReverseDir, vec3 rayDir, in float specularPower, out vec3 diff, out vec3 spec) {
    
    // start with a white directional light diffuse
    float diffuse = clamp(dot(normal, directionalLightReverseDir), 0.0, 1.0);
    diff = vec3(diffuse);
    
    // add in specular
    vec3 reflection = reflect(directionalLightReverseDir, normal);
    float dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
    spec = vec3(pow(dp, specularPower));    

    // apply shadows
    vec3 shadowRayPos = shadePoint;        
    vec3 shadowRayDir = directionalLightReverseDir;
    vec3 shadowHitDiffuse = vec3(0.0);
    vec3 shadowHitEmissive = vec3(0.0);
    float shadowHitSpecularPower = 0.0;
    vec4 shadowHitInfo = vec4(10000.0, -directionalLightReverseDir); 
    bool shadowHitSomething = false;  
    TraceRay(cameraPos, shadowRayPos, shadowRayDir, shadowHitInfo, shadowHitDiffuse, shadowHitEmissive, shadowHitSpecularPower, shadowHitSomething, true);
    diff *= float(!shadowHitSomething);
    spec *= float(!shadowHitSomething);

    // in mode greater than zero we limit this directional lighting to repeating boxes in uv coordinates
    vec3 uv;
	vec3 localPos;    
    if (GetMode() >= 1.0)
    {
        // get position in light space and get uv
        localPos = WorldSpaceToDirectionalLightSpace(shadePoint);
        uv = LightSpaceToLightUV(localPos);
        
        // set shade to 1 if it's inside, 0 if it's outside        
    	float shade = float(abs(uv.x) < 1.0 && abs(uv.y) < 1.0);
        
        // if it is behind the light source, don't light it!
        shade *= step(0.0, localPos.y);
        
        // apply distance attenuation
        shade *=  1.0 - clamp(directionalLightFalloff * localPos.y * localPos.y, 0.0, 1.0);   
        
        // apply shading to the lighting
        spec *= shade;
        diff *= shade;
    }
    
    // soften shadows over a distance
	if (GetMode() >= 2.0)
    {
        float softenDistance = clamp(localPos.y * directionalLightSoften, 0.001, 0.999);
    	float softenX = smoothstep(1.0, 1.0 - softenDistance, abs(uv.x));
    	float softenY = smoothstep(1.0, 1.0 - softenDistance, abs(uv.y));
    	diff *= softenX * softenY;
        spec *= softenX * softenY;
    }
    
    // apply texture to light if we should!
    if (GetMode() >= 3.0)
    {
        diff *= GetLightColor(uv);
    }
    
    diff = clamp(diff, 0.0, 1.0);
    spec = clamp(spec, 0.0, 1.0);
}

// Function 2600
float sphere
	(vec3 ray, vec3 dir, vec3 center, float radius, vec3 color, inout vec3 nml, inout vec3 mat, float closestHit)
{
	vec3 rc = ray-center;
	float c = dot(rc, rc) - (radius*radius);
	float b = dot(dir, rc);
	float d = b*b - c;
	float t = -b - sqrt(abs(d));
	float st = step(0.0, min(t,d)) * step(t, closestHit);
	closestHit = mix(closestHit, t, st);
	nml = mix(nml, (center-(ray+dir*t)) / radius, st);
	mat = mix(mat, color, st);
	return closestHit;
}

// Function 2601
bool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {	
	if (rd.y==0.0) {
		return false;
	}
		
	float d = -(ro.y - height)/rd.y;
	d = min(100000.0, d);
	if( d > 0. && d < dist ) {
		dist = d;
		return true;
    } else {
		return false;
	}
}

// Function 2602
float SphereRadius(in float t)
{
    t = t * .001*(500./iResolution.y);
    return (t+.001);
}

// Function 2603
vec4 Box4Y( vec4 p_x, vec4 p_y, vec4 p_z, vec4 b_x, vec4 b_y, vec4 b_z, out vec4 Y )
{
	vec4 d_x = abs(p_x) - b_x;
	vec4 d_y = abs(p_y) - b_y;
	vec4 d_z = abs(p_z) - b_z;
	
	vec4 mdx = max(d_x,0.);
	vec4 mdy = max(d_y,0.);
	vec4 mdz = max(d_z,0.);
	
	vec4 len = sqrt( mdx*mdx+mdy*mdy+mdz*mdz );
	
	vec4 max_dxz = max(d_x,d_z);

#if 0	
	Y = mix(vec4(1e10), d_y, vec4(lessThan(max_dxz, vec4(0.))) );	//select y dist if inside ow. far out
#else	
	Y.x = max_dxz.x < 0. ? d_y.x : 1e10;
	Y.y = max_dxz.y < 0. ? d_y.y : 1e10;
	Y.z = max_dxz.z < 0. ? d_y.z : 1e10;
	Y.w = max_dxz.w < 0. ? d_y.w : 1e10;
#endif
	
	return min( max(d_y,max_dxz), vec4(0)) + len;
}

// Function 2604
float sdfCappedCone( vec3 p, float r1, float r2, float h,  mat4 t )
{
  p = vec3(t * vec4(p, 1));
  vec2 q = vec2( length(p.xz), p.y );
  vec2 k1 = vec2(r2,h);
  vec2 k2 = vec2(r2-r1,2.0*h);
  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
  return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 2605
float box(vec3 p){ p=abs(p); return max(max(p.x, p.y), p.z); }

// Function 2606
vec4 sphere_search(vec4 col, vec2 p, vec2 center)
{
	float d = map(center)*0.99;
    
    float h;
    
    col = sphere_range(col, p, center, d);
    col = sphere_point(col, p, center, vec3(0., 0.8, 1.), vec3(0., 0.435, 1.));
    
    return col;
}

// Function 2607
float sdTorus82( vec3 p, vec2 t ){
  vec2 q = vec2(length2(p.xz)-t.x,p.y);
  return length8(q)-t.y;
}

// Function 2608
float sdfSphere(vec3 pt, vec3 center, float radius)
{
    return length(pt - center) - radius;
}

// Function 2609
vec2 	UIStyle_CheckboxSize() 			{ return vec2(24.0); }

// Function 2610
float DistanceToPlane(vec3 eye, vec3 dir, float start, float end){
    float old_dist;
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 cur_eye = eye + depth*dir;
        float dist = planeSD(cur_eye);
        if (dist < EPSILON) {
            vec3 old_eye = eye - old_dist * dir;
            return depth - old_dist + old_dist * (old_dist - old_eye.y) / (cur_eye.y - old_eye.y - dist + old_dist);
        }
        depth += dist * 0.5;
        old_dist = dist;
        if (depth >= end) {
            return end;
        }     
    }
    return end; 
}

// Function 2611
vec4 StarPlane(vec2 uv, float dens, int blur)
{
    dens = 1.0 - dens;
    vec2 res = iChannelResolution[1].xy;
    uv = floor(uv * res);
    
    vec4 acc = vec4(0.0);
    
    for(int i = -MAX_BLUR;i <= MAX_BLUR;i++)
    {
        if(i >= -blur && i <= blur)
        {
            vec4 n = step(dens, texture(iChannel1, (uv + vec2(i,0))/res));
            acc += n * (cos(pi * float(i) / float(blur + 1)) * 0.5 + 0.5);
        }
    }
    
	return acc;
}

// Function 2612
float intersectPlane(out vec3 normal,
                     in Ray r,
                     in vec3 n,
                     float d)
{
    normal = n;
    return -(d - dot(r.o, n))/dot(r.d, n);
}

// Function 2613
float dSphere(vec3 p, vec3 c, float r) {
    return length(p - c) - r;
}

// Function 2614
void box(inout vec3 col, vec2 coord, vec4 bounds, vec3 color) {
    bool bb = 	all(greaterThanEqual(coord, bounds.xy)) &&
        		all(lessThan(coord, bounds.zw));
    col=bb?color:col;
}

// Function 2615
Hit boxSdf(vec3 p, vec3 c, vec3 s) {
    Hit hit;
    hit.dist = vmax(abs(p - c) - s);
    hit.color = vec3(1.0);
    return hit;
}

// Function 2616
uint spheremap_32( in vec3 nor )
{
    vec2 v = nor.xy * inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x16(v);
}

// Function 2617
void piecePlane( ivec2 c, out vec4 pl, out vec3 center, out vec3 px, out vec3 py )
{
	mat4 m = transformOverTime( c );
	vec3 pz = m[2].xyz;
	px = m[0].xyz;
	py = m[1].xyz;
	pl = vec4( pz, -dot( pz, m[3].xyz ) );
	center =  m[3].xyz;
}

// Function 2618
float sdTorus(vec3 p, vec2 t, vec3 c) {
    p -= c;
	vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// Function 2619
vec3 atmosphere(
	in vec3 pos,
	in vec3 dir,
	in vec3 lightDir
) {
	// Intersect the atmosphere
    vec2 intersect = raySphereIntersect(pos, dir, ATMOSPHERE_RADIUS);

	vec3 opticalDepth = vec3(0.0);
    vec3 sumR = vec3(0.0);
    vec3 sumM = vec3(0.0);
    
    float rayPos = max(0.0, intersect.x);
    float maxLen = ATMOSPHERE_HEIGHT;
    maxLen *= (1.0 - abs(dir.y) * 0.5);
	float stepSize = min(intersect.y - rayPos, maxLen) / float(SAMPLES);
    rayPos += stepSize * 0.5;
    
    for(int i = 0; i < SAMPLES; i++) {
        vec3 samplePos = pos + dir * rayPos;

		vec2 lightIntersect = raySphereIntersect(samplePos, lightDir, ATMOSPHERE_RADIUS);

        vec3 lightOpticalDepth = vec3(0.0);
        float lightStep = lightIntersect.y / float(LIGHT_SAMPLES);
        float lightRayPos = lightStep * 0.5;
        
        for(int j = 0; j < LIGHT_SAMPLES; j++) {
            vec3 lightSamplePos = samplePos + lightDir * (lightRayPos);

			lightOpticalDepth += avgDensities(lightSamplePos) * lightStep;

            lightRayPos += lightStep;
        }

		vec3 densities = avgDensities(samplePos) * stepSize;
		opticalDepth += densities;

		vec3 scattered = exp(-(BETA_RAY * (opticalDepth.x + lightOpticalDepth.x) + BETA_MIE * (opticalDepth.y + lightOpticalDepth.y) + BETA_OZONE * (opticalDepth.z + lightOpticalDepth.z)));
        sumR += scattered * densities.x;
        sumM += scattered * densities.y;

        rayPos += stepSize;
    }

    float cosTheta = dot(dir, lightDir);
    
    return max(
        phaseR(cosTheta)    * BETA_RAY * sumR + // Rayleigh color
       	phaseM(cosTheta, G) * BETA_MIE * sumM,  // Mie color
    	0.0
    );
}

// Function 2620
float iBox( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) tN = -1.0;
	return tN;
}

// Function 2621
Intersection RaySphere(Ray ray, Sphere sphere)
{
	Intersection i;
	i.dist = ZMAX;
	vec3 c = sphere.c;
	float r = sphere.r;
	vec3 e = c-ray.o;
	float a = dot(e, ray.dir);
	float b = r*r - dot(e,e) + a*a;
	if( b>0.0 )
	{
		float f = sqrt(b);
		float t = a - f;
		if(t > EPSILON)
		{
			i.p = ray.o + ray.dir*t;
			i.n = normalize(i.p-c);
			i.dist = t;
		}
	}
	return i;
}

// Function 2622
float Box(vec2 p, vec2 b) {
    vec2 d=abs(p-b*0.5)-b*0.5;
    return min(max(d.x,d.y),0.)+length(max(d,0.));
}

// Function 2623
vec2 sdSphere( vec3 p, float s )
{
    return vec2(length(p)-s,0);
}

// Function 2624
float dbox( vec3 p, vec3 b, float r ) {
  return length(max(abs(p)-b,0.0))-r;
}

// Function 2625
float sdSphere( vec4 p, float s ) {
    return length(p)-s;
}

// Function 2626
float udBox( vec3 p, vec3 b ){
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) +
         length(max(d,0.0));
}

// Function 2627
float sdPlane(vec3 p, vec3 n, float h ) {
  return dot(p,n) + h;
}

// Function 2628
mat2x4 BoxIsect(vec3 ro,
                vec3 rd,
                vec3 scale, // Scale on x/y/z
                vec3 ori)
{
    // Synthesize box boundaries from the given origin + scale
    scale *= 0.5f;
    mat2x3 bounds = mat2x3(ori - scale,
                           ori + scale);
    // Evaluate per-axis distances to each plane in the box
    mat2x3 vecT = mat2x3((bounds[0] - ro) / rd,
                      	 (bounds[1] - ro) / rd); // Maybe possible to optimize this down to matrix division...
    // Keep near distances in [0], far distances in [1]
	vecT = mat2x3(min(vecT[0], vecT[1]),
                  max(vecT[0], vecT[1]));
    // Evaluate scalar min/max distances for the given ray
    vec2 sT = vec2(max(max(vecT[0].x, vecT[0].y), vecT[0].z),
                   min(min(vecT[1].x, vecT[1].y), vecT[1].z));
    sT = vec2(min(sT.x, sT.y), max(sT.x, sT.y)); // Keep near distance in [x], far distance in [y]
    // Return min/max distances + intersection status
    bool isect = (vecT[0].x < vecT[1].y && vecT[0].y < vecT[1].x &&
                  vecT[0].z < sT.y && sT.x < vecT[1].z);
    return mat2x4(ro + (rd * sT.x), isect,
                  ro + (rd * sT.y), isect);
}

// Function 2629
float sdCappedCylinder( vec3 p, vec2 h )
{
    
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2630
void IntersectPlanes( float3 n, float3 rd, float3 ro, out float t_0, out float dt, out float wt )
{
    // step size
    float ndotrd = dot( rd, n );
    dt = PERIOD / abs( ndotrd );

    // raymarch start offset - skips leftover bit to get from ro to first strata lines
    t_0 = -fmod( dot( ro, n ), PERIOD ) / ndotrd;
    if( t_0 < 0. ) t_0 += dt;

    // ray weight
    float minperiod = PERIOD;
    float maxperiod = .8*sqrt( 2. )*PERIOD;
    wt = smoothstep( maxperiod, minperiod, dt );
}

// Function 2631
vec2 rayIntersectSphere( vec3 eye, vec3 dir, float r ) {
	float b = dot(eye, dir);
    float ac = dot(eye, eye) - r * r;
    float delta = b * b - ac;
    if(delta < 0.0)
        return vec2(MAX, -MAX);
    delta = sqrt(delta);
    return vec2(-b - delta, -b + delta);
}

// Function 2632
float rightplane (vec3 pos){return -pos.x+2.0;}

// Function 2633
floor plane (intersection happens behind camera)
    {
        vec3 pImage = o+tImage*d;
        vec2 uv = camProj(perspectiveCam,pImage);
        
        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)
        {
            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);
            cScene = alphaBlend(cScene,cPersp,0.5);
        }
    }

// Function 2634
float headSphere(vec3 p) {
    return (length(p / vec3(0.9, 0.7, 0.9)) - 0.9) * 0.7;
}

// Function 2635
vec2 RaySphere(vec3 rd, vec3 p) {
    float l = dot(rd, p);
    float det = l*l - dot(p, p) + 1.;
    if (det < 0.) return vec2(-1);

    float sd = sqrt(det);
    return vec2(l - sd, l+sd);
}

// Function 2636
float sdPlane( vec4 p ) {
                	return p.y;
                }

// Function 2637
float sdSphere( in vec3 pos, in float r ) {
    return length(pos) - r;
}

// Function 2638
float sdPlane(vec3 p, float h) {
    return p.y - h;
}

// Function 2639
vec4 boxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec4(-1.0);

	vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

    // convert to ray space
	
	nor = (txi * vec4(nor,0.0)).xyz;

	return vec4( tN, nor );
}

// Function 2640
float torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)
{
    return sq(torusKnot(t, tkp) - p);
}

// Function 2641
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    // fake soft shadow
    if( tF<0.0) return 1.0;
    float sh = clamp(0.3*sk*(tN-tF)/tN,0.0,1.0);
    return sh*sh*(3.0-2.0*sh);
}

// Function 2642
float rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) 
{
    //Same principle as lineLineIntersection() :
    //"How far is the plane"/"approach rate".
    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.
    return dot(po-o,pn)/dot(d,pn);
}

// Function 2643
bool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm
){t=10000000.
 ;float A=dot(rd,rd)
 ;float B=2.0*dot(ro,rd)
 ;float C=dot(ro,ro)-SpRad*SpRad
 ;vec2 tt
 ;if(!SolveSquare(A,B,C,tt))return false
 ;t=min(tt.x,tt.y)
 ;if(t<0.0)return false
 ;norm=normalize(ro+t*rd)
 ;return true;}

// Function 2644
float plane( vec3 p, vec4 plane ) 
{
    return dot( p, plane.xyz ) + plane.w;
}

// Function 2645
vec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)
{
    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;
    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;
    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));
}

// Function 2646
float Sphere( vec3 p, float s )
{
	return length( p ) - s;
}

// Function 2647
float sdTorus(vec3 p,vec2 t)
{
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 2648
float Box( vec3 p, vec3 b )
{
    vec3 d = abs( p ) - b;
    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );
}

// Function 2649
float sphere( vec3 p, float r )
{
	return length( p ) - r;
}

// Function 2650
vec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )
{
    vec4 cx = texture( tex, pos.yz );
    vec4 cy = texture( tex, pos.xz );
    vec4 cz = texture( tex, pos.xy );
    vec3 m = nor*nor;
    return (cx*m.x + cy*m.y + cz*m.z)/(m.x+m.y+m.z);
}

// Function 2651
vec4 renderPlanet(in vec3 ro, in vec3 rd, in vec4 id, in vec3 lightDir, float dSun) {
    vec4 color = vec4(0.);
  	float r = 1.;
    float dist, edge;   
    
    if (intersectSphere(ro, rd, r, dist, edge)) {
        if (dist<dSun) {

            vec3  pos = ro+rd*dist,
                  nor = normalize(pos);
            float a = smoothstep(0., .8*r, edge); 
            vec3 oCol = getPlanetColor(pos, id);

            vec3 norm = -normalize(pos);
            float dif = clamp(dot(lightDir, norm), 0.0, 1.0);

            vec3 h = normalize(-rd + lightDir);
            float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 4.0);

            oCol = dif * oCol ;
            oCol += dif * spe;
            color = vec4(oCol, 1.);
       }
    }
	return clamp(color, vec4(0.),vec4(1.));
}

// Function 2652
void CollideSphere(inout vec3 pos, float radius)
{
    float d;
    vec3 n = SceneNormal(pos, radius, d, IZERO);
    pos -= n * min(0., d - radius);
}

// Function 2653
float sdSphere(vec3 p, float r)
{
    return length(p)-r;
}

// Function 2654
vec3 normalForSphere(vec3 hit, Sphere s) {   
   return (hit - s.center_radius.xyz) / s.center_radius.w;   
}

// Function 2655
float PrBox2Df (vec2 p, vec2 b)
{
  vec2 d;
  d = abs (p) - b;
  return min (max (d.x, d.y), 0.) + length (max (d, 0.));
}

// Function 2656
float sd_torus_yz( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.yz)-t.x,p.x);
  return length(q)-t.y;
}

// Function 2657
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    return vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
}

// Function 2658
float fCylinder(vec3 p, float r, float height) {
	return max(length(p.xz) - r, abs(p.y) - height);
}

// Function 2659
vec3 doAtmosphere(vec3 colour, 
                  vec2 frag,
                  vec3 O, vec3 D, float rayDist)
{
    // cone light from https://www.shadertoy.com/view/llBGzm
    
    vec3 lightPos = vec3(-0.2, 6.0, -0.3);
    float intensity = 10.0;
    
    float originAlong = dot(lightPos - O, D); 
    vec3 originNearest = O + D * originAlong;

    vec3 normal = vec3(0.0, -1, 0.0);
    intensity *= pow(max(0.0, dot(normal, normalize(originNearest - lightPos))), 10.0); 
    intensity /= pow(1.0 + distance(lightPos, originNearest) * 1.1, 2.0); 
    
    float rain = rainAmount(frag)*0.8+0.2;
    colour += rain*LightColour*intensity;
    
    return colour;
}

// Function 2660
float sphereWipeClean(float wipe, float y, float thickness)
{
    //float no_poles = clamp(abs(y),0.,0.8); 
    //float no_poles = smoothstep(.9, 0.8,abs(y)); 
    return wipeClean(1.-wipe,y,thickness, false);
}

// Function 2661
float CylinderXZ( vec3 p, vec3 c ) {
	return length(p.xz-c.xy)-c.z;
}

// Function 2662
Hit intersectHashedSphere(Sphere s, Ray r)
{
	vec3 op = s.p - r.o;
    float b = dot(op, r.d);
    float det = b * b - dot(op, op) + s.r * s.r;
    if (det < 0.) return noHit;

    det = sqrt(det);
    float t1 = b - det;
    float t2 = b + det;

    float t = t1;
    vec3 p = r.o + t * r.d;
    vec3 n = (r.o + t*r.d - s.p) / s.r;
    
    // Reject intersection solution based on random magic.
    if (t < 0. || surfaceHash(p.xy + vec2(0., -iTime), 3.) < 0.5)
    {
        t = t2;
        p = r.o + t * r.d;
        n = -(r.o + t*r.d - s.p) / s.r;
    }
    if (t < 0. || surfaceHash(p.xy + vec2(0., -iTime), 3.) < 0.5)
    {
        return noHit;
    }

    return Hit(t, n, s.m);
}

// Function 2663
float planet_surface(vec3 p){
 return	length(p)-planet_size;
}

// Function 2664
int sphere(
    vec3 origin,
    vec3 direction,
    vec3 center,
    float radius,
    inout float t,
    inout vec3 hit,
    inout vec3 normal)
{
    vec3 offset = origin - center;
    float b = dot(offset, direction);
    float c = dot(offset, offset) - radius * radius;
    float discriminant = b * b - c;
    if (discriminant <= 0.0)
        return 0;
    float t_sphere = -b - sqrt(discriminant);
    if (t_sphere < epsilon || t < t_sphere)
        return 0;
    t = t_sphere;
    hit = origin + direction * t;
    normal = normalize(hit - center);
    return 1;
}

// Function 2665
float RoundBox( vec3 p, vec3 b)
{
	return length(max(abs(p)-b,0.0))-.5;
}

// Function 2666
void initMovingSphere( float time ) {
	movingSphere = vec4( 1.+abs(1.0*sin(time*1.3)), 1.+abs(2.0*sin(time)), 7.-abs(6.*cos(time*0.4)), 1.0);
}

// Function 2667
float sdSphere(vec3 p,float r)
{
	return length(p)-r;
}

// Function 2668
vec2 sdBox(vec3 pos, vec3 size, float id)
{
    return vec2(length(max(abs(pos) - size, 0.0)), id);
}

// Function 2669
float getSphereDistance( vec3 p, float r )
{
	return max( 0.0, length(p)-r );
//	return length(p)-r;
}

// Function 2670
int convert_plane(bvec3 p){return hsum(convert_index(p));}

// Function 2671
float sdCylinderYZ( vec3 p, vec2 h ) {
  return max( length(p.yz)-h.x, abs(p.x)-h.y );
}

// Function 2672
void sphereFold(inout vec3 z, inout float dz) {
	float r2 = dot(z,z);
	if (r2<minRadius2) { 
		// linear inner scaling
		float temp = (fixedRadius2/minRadius2);
		z *= temp;
		dz*= temp;
	} else if (r2<fixedRadius2) { 
		// this is the actual sphere inversion
		float temp =(fixedRadius2/r2);
		z *= temp;
		dz*= temp;
	}
}

// Function 2673
vec3 random_sphere_direction(vec2 random_value)
{
	float s = random_value.x * MPI * 2.0;
	float t = random_value.y * 2.0 - 1.0;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 2674
vec2 _sphere(vec3 p, float s, float m){return vec2(length(p)-s,m);}

// Function 2675
vec3 renderPlanet(vec3 u,vec3 t,vec2 m,vec3 s)
{float tMax=SCALE*25.;u+=m.x*t
;vec3 l=u*(ATMOSPHERE_LOWER/length(u))
,c=u+s*lineIntersectSphere(l,s,ATMOSPHERE_UPPER).y
,a=attenuate(u,c,vec3(0))
+vec3(0,.235,.275)*dot(normalize(u),s)// Fake skylight
,n=dg(u)
;float dif=sat(dot(n,s))
//;float fre = pow( sat(1.0+dot(n,t)),2.);//unused fresnel?
;vec3 e
;c=planetColor(u,m.y,e,s)
;float spe=sat(dot(reflect(t,n),s))//specular base       
//;vec3 land=(.1+.9*dif)*c+.01*pow(spe,12.)*dif
//;vec3 ocean=.4*c+.2*pow(spe,16.)
//;brdf=mix(land,ocean,step(10.,m.y));
//;brdf=mix(land,ocean,smoothstep(0.,1.,m.y-10.));
//above is for softcoast!=0
//below branching code is likely faster for hard coastline:
;bool isLand=m.y<10.    
;if(isLand){
 ;vec3 land=(.1+.9*dif)*c+.01*pow(spe,12.)*dif
 ;c=land
;}else{
 ;vec3 ocean=.4*c+.2*pow(spe,16.)
 ;c=ocean;}
return c*a+e;}

// Function 2676
float box( vec3 p, vec3 b )
{
    vec3 q = abs(p)-b;
	return max(max(q.x,q.y),q.z);
}

// Function 2677
float sdBox( vec3 p, vec3 b )
{
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2678
vec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )
{
   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));
   float phi = acos( sqrt(1.0 - rnd.x)) ;
   float theta = 2.0 * 3.14 * rnd.y ;

   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));
   vec3 tdir = cross(normal, sdir);

   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);
}

// Function 2679
float fBoxCheap(vec3 p, vec3 b) { //cheap box
	return vmax(abs(p) - b);
}

// Function 2680
bool intersect_sphere(vec3 camera_pos, vec3 ray_dir, vec3 pos,
                      float radius, out vec3 out_normal, out float out_t1,  out float out_t2) {
    vec3 dr = pos - camera_pos;
    float dr_dot_v = dot(dr, ray_dir);
    float c = dot(dr, dr) - dr_dot_v * dr_dot_v;
    float radius2 = radius;
    radius2 = radius2 * radius2;
    if (c < radius2) {
        float t = dr_dot_v;
        if (t < -1.0e-3)
            return false;
        float dt = sqrt(radius2 - c);
        out_t1 = t - dt;
        out_t2 = t + dt;
        out_normal = normalize(camera_pos + ray_dir * t - pos);
        return true;
    }
    return false;
    
}

// Function 2681
void sphere(inout vec4 O,inout float zmin, vec2 U, vec3 P, float r, vec3 C) { // O, U, pos, radius, color
	
	U -= P.xy;
    r = length(U)/r; if (r>1.) return;

    U = normalize(U)*r;
    float z = sqrt(1.-dot(U,U)); 
    if (zmin < P.z-.1*z) return; 
    zmin = P.z-.1*z;
    vec3 N = vec3(U,z);
    O.rgb =  clamp(  C*(.2 + max(0.,(-N.x+N.y+N.z)/1.732))    // ambiant, diffus
                       + pow(max(0.,dot(N,normalize(vec3(-1,1,2.73)))),50.) // spec
                       ,0.,1.);               // L=(-1,1,1), E=(0,0,1), z toward eye 
}

// Function 2682
float distPlane(in vec3 p, vec4 n)
{
    return dot(p, n.xyz) * n.w;
}

// Function 2683
float profileSphere(vec2 p, float r) {
    return length(p) - r;
}

// Function 2684
vec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)
{
    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;
	float distance_to_ray = length(cur_shpere.position - distance_point);
    
    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))
    {
        return vec3(0,0,0);
    }

    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));

	vec3 intersect_point = distance_point - (ray_dir * inner_line_length);

    return intersect_point;
}

// Function 2685
vec4 torus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r) {
	float dn = dot(d,n);
    float wn = dot(p-c,n);
    vec3 s = p-c-wn*n;
    vec3 q = d - dn*n;
    float qq = dot(q,q);
    float sq = dot(s,q);
    float ss = dot(s,s);
    float A = (dn*dn+qq)*0.5/r.x;
    float B = (wn*dn+sq)/r.x;
    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;
    return vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);
    
}

// Function 2686
vec3 skybox(vec3 vDir) {
    return texture(iChannel1, vDir).rgb;
}

// Function 2687
void getPlaneIntersec(inout Primitive plane, vec3 rayOr, vec3 rayDir) {
    float rdn = dot( rayDir, plane.normal); //plane line intersection
    float frdn = rdn==0.?1.:rdn; 
    float dfc = dot(plane.normal, (plane.pos - rayOr))/frdn; //dist of plane from ray origin
     plane.intersecPoint = rayOr + dfc*rayDir; //intersection point of plane and ray
   
    plane.isIntersected = rdn==0.?false:true; //whether or not the plane was intersected, without considering its size
    vec3 dVec = vec3(plane.intersecPoint - plane.pos); //distance from the center of the plane to the point of intersection
    plane.isIntersected = (plane.isIntersected&&(abs(dVec.x)	//if the point of intersection is outside the plane 
                          +abs(dVec.y)+abs(dVec.z)<=plane.size))?true:false;	//set as not intersected, otherwise intersected
    
    
}

// Function 2688
float sdSphere( vec3 position, float radius )
{
    return length(position)-radius;
}

// Function 2689
void plane(vec3 q) {
    vec4 c = _stack.position;
    
    add_field(vec2(dot(vec3(c.xy,1.0),q), dot(vec3(c.zw,1.0),q)));
}

// Function 2690
float fBox(vec3 p,vec3 b){
    vec3 q,d=abs(p)-b;q=min(d,0.);
    return length(max(d,0.))+max(max(q.x,q.y),q.z);}

// Function 2691
vec4 sphere_point(vec4 col, vec2 p, vec2 center, vec3 inner_col, vec3 outer_col)
{
	float h;
    
    h = circle(p, center, 0.02);
    col = blend(col, vec4(inner_col, smoothstep(0.01, 0., h)));
    
    h = circle(p, center, 0.02);
    col = blend(col, vec4(outer_col, smoothstep(0.01, 0., abs(h))));
    
    return col;
}

// Function 2692
float sBox( in vec2 p, in vec2 b )
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2693
MapInfo sphere(vec3 origin, float rad, Material material) {
    return MapInfo(material, length(origin) - rad);
}

// Function 2694
float sphere(vec3 p, float r)
{
 	return length(p)-r;   
}

// Function 2695
float splitPlane(float a, float b, vec3 p, vec3 plane) {
    float split = max(sign(dot(p, plane)), 0.);
    return mix(a, b, split);
}

// Function 2696
void initSpheres() {
	spheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),	vec3(0.), vec3(.75, .25, .25), DIFF);
	spheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), DIFF);
	spheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),		vec3(0.), vec3(.75), DIFF);
	spheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);
	spheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),		vec3(0.), vec3(.75), DIFF);
	spheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);
	spheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), 	vec3(0.), vec3(1.), SPEC);
	spheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), 	vec3(0.), vec3(.7, 1., .9), REFR);
	spheres[8] = Sphere(600., vec3(50., 681.33, 81.6),	vec3(12.), vec3(0.), DIFF);
}

// Function 2697
float sdCylinder(in vec3 p, in vec2 h )
{
  vec2 d = abs(vec2(length(p.xz), p.y)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2698
float sdBox( vec3 p, vec3 b)
{
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2699
float plane(vec3 p, vec3 n, float h)
{
    return dot(p, n) + h;
}

// Function 2700
float sphere(vec3 p, float radius){
    return length(p)-radius;
}

// Function 2701
float g2_sphere(vec3 p, rObj o) {
    return length(p - o.pos) - o.scale.x;
}

// Function 2702
float udBox( vec4 p, vec4 b )
{
  return length(max(abs(p)-b,0.0));
}

// Function 2703
float MapCylinder(in vec3 pos, in float r, in float half_h)
{
	float y = abs(pos.y) - half_h;
	float rr = length(pos.xz) - r;
	return Combine(y, rr);
}

// Function 2704
vec3 rndSphere(in vec3 chaos) {
    return normalize(bell33(chaos)*2.-1.);
}

// Function 2705
bool isinbox(vec2 a,float s){return isinbox(a,vec2(s));}

// Function 2706
bool huecylinder(vec3 ro, vec3 rd, vec3 p, float cap, float rscale, out vec3 uv) {
    ro = ro.xzy;
    rd = rd.xzy;
    cap = max(cap, 0.0001);
    ro -= p;
    ro.z += 0.5;
    ro.z /= cap;
    rd.z /= cap;
    ro.z -= 0.5;
    
    float near, far;
    if (cylinder(ro, rd, near, far)) {
        vec3 p = ro + rd * near;
        
        uv.x = (p.z + 0.5) * cap;
        uv.x = srgb_linear(uv.x);
        uv.yz = p.xy * rscale;
#ifdef CLAMP_BICONE
        float r = (1.0-abs(uv.x-0.5)*2.0) * 0.7071;
        //float r = (1.0-abs(uv.x-0.5)*2.0) * 0.53235;
        uv.yz *= r;
#else
        //uv.yz *= 1.1681404025202;
#endif
        uv = clamp(uv, vec3(0.0,-0.5,-0.5), vec3(1.0,0.5,0.5));
        
        return true;
    }    
    return false;
}

// Function 2707
vec4 sphere(vec3 pos)
{	dualR3 p =  dualR3(pos.x,pos.y,pos.z,1.,1.,1.);
	vec4 f = dualSphereStaticWarp(p, shapeOuterRadius);
	float distOuter = f.x / length(f.yzw);
	
	
	float a = (distOuter>0.)            ? 0. 
 			  : ( (distOuter<-furDepth) ? 1. 
			  : 		     		abs(distOuter)/furDepth 
  				);
	return vec4(a, -f.yzw);	
}

// Function 2708
vec4 tracePlane(vec3 ro, vec3 rd, mat3 o, vec2 s, bool quad, out vec2 ip)
{
	// rd = normalize(rd);
	mat3 io = inverse(o);
	vec3 iro = io * ro;
	vec3 ird = io * rd;
	float t = -iro.z / ird.z;
	ip = iro.xy + ird.xy * t;
	vec3 p = o * (iro + ird * t);
	ip /= s;
	return vec4(p, t > 0. && (!quad || all(lessThan(ip, vec2(1.))) && all(greaterThan(ip, vec2(0.)))) ? 1. : 0.);
}

// Function 2709
float box(vec3 l, vec3 size) {
	vec3 m = clamp(l, -size/2.0,size/2.0);
	return distance(l, m);
}

// Function 2710
float sphere(vec3 p) {
    return length(p + vec3(2.*sin(iTime), -0.2, 2.*cos(iTime))+1.0) - 0.3;
}

// Function 2711
vec2 iSphere(vec3 ro, vec3 rd, vec4 sph)
{
    vec3 tmp = ro - sph.xyz;

    float b = dot(rd, tmp);
    float c = dot(tmp, tmp) - sph.w * sph.w;
    
    float disc = b * b - c;
    
    if(disc < 0.0) return vec2(-M_MAX, -M_MAX);
    
    float disc_sqrt = sqrt(disc);
	
    float t0 = -b - disc_sqrt;
    float t1 = -b + disc_sqrt;
    
    return vec2(t0, t1);
}

// Function 2712
float torus(vec3 p, vec3 c, vec3 u, float r, float e, float R)
{
    return e*falloff(d_circle(p,c,u,r),R);
}

// Function 2713
float coneSdf(vec3 p)
{
    float t = 1.0;
    if(apply)
    {
        t = applyMobius(p);
        p = normalize(p);
    }
    float q = length(p.xy);
    return dot(coneAngle, vec2(q, -p.z)) * t;
}

// Function 2714
float planeSdf(vec3 p)
{
    return length(p.z);
}

// Function 2715
float sphereIntersect(vec3 ray, vec3 dir, vec3 center, float radius)
{
 vec3 rc = ray-center;
 float c = dot(rc, rc) - (radius*radius);
 float b = dot(dir, rc);
 float d = b*b - c;
 float t = -b - sqrt(abs(d));
 float st = step(0.0, min(t,d));
 return mix(-1.0, t, st);
}

// Function 2716
vec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {
    vec3 m = pow( abs(p), vec3(k) );
	vec4 x = texture(t, p.yz);
	vec4 y = texture(t, p.zx);
	vec4 z = texture(t, p.xy);
	return (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);
}

// Function 2717
vec2 sdfBox( vec3 currentRayPosition ){
  
  // First we define our box position
  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );
    
  // than we define our box dimensions using x , y and z
  vec3 boxSize = vec3( .4 , .3 , .2 );
    
  // Here we get the 'adjusted ray position' which is just
  // writing the point of the ray as if the origin of the 
  // space was where the box was positioned, instead of
  // at 0,0,0 . AKA the difference between the vectors in
  // vector format.
  vec3 adjustedRayPosition = currentRayPosition - boxPosition;
    
  // finally we get the distance to the box surface.
  // I don't get this part very much, but I bet Inigo does!
  // Thanks for making code for us IQ !
  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;
  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); 
  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );
  
  // Finally we build the full box information, by giving it an ID
  float boxID = 2.;
    	
  // And there we have it! A fully described box!
  vec2 box = vec2( distanceToBoxSurface,  boxID );
    
  return box;
    
}

// Function 2718
vec4 triUIBox(int idx, float delta) {
    
    return vec4(digitUIBox(idx).xy + vec2(0, 0.9*delta*textSize), 
                0.4*textSize, 0.3*textSize);
    
}

// Function 2719
float sdCone( vec3 p, vec2 c )
{
	// c must be normalized
	float q = length(p.xz);
	return dot(c,vec2(q,p.y));
}

// Function 2720
float sd_cylinderx( vec3 p, vec3 c, float r ) { return length( p.yz - c.yz ) - r; }

// Function 2721
double bbox_area(ivec3 bbox_min, ivec3 bbox_max) {
	double l1 = (double(bbox_max.x) - double(bbox_min.x)) * (fbbox_max.x - fbbox_min.x) / 1023.0;
	double l2 = (double(bbox_max.y) - double(bbox_min.y)) * (fbbox_max.y - fbbox_min.y) / 1023.0;
	double l3 = (double(bbox_max.z) - double(bbox_min.z)) * (fbbox_max.z - fbbox_min.z) / 1023.0;
	return l1*l2 + l2*l3 + l3*l1;
    }

// Function 2722
float cullPlane(const in vec3 p) {
  return p.y >= -0.502 ? p.y + 0.5 : 20.0;
}

// Function 2723
float sdHPlane( vec3 p, float n)
{ 
  return p.y + n;
}

// Function 2724
bool intersect_plane(inout Ray ray, in Plane plane, out HitRecord hitRecord) {
   float t = dot(plane.N, plane.P0 - ray.origin) / dot(plane.N, ray.dir);
    if(t >= ray.t_min && t <= ray.t_max){
        ray.t_max = t;
        hitRecord.t = t;
        hitRecord.normal = plane.N;
        hitRecord.hitPoint = ray.origin + t * ray.dir;
        float distToPlaneCenter = length(plane.P0 - ray.origin + t * ray.dir);
        int randColorBand = int(distToPlaneCenter);
        if(randColorBand - 4 * (randColorBand / 4) == 0){
            hitRecord.color = vec3(1, 1, 1) ;
        } else {
            hitRecord.color = vec3(0, 0, 0);
        }
        return true;
    } else {
        return false;
    }
}

// Function 2725
uint spheremap_24( in vec3 nor )
{
    vec2 v = nor.xy*inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x12(v);
}

// Function 2726
vec2 intersectCylinder(vec2 ro, vec2 rd, float r)
{
    float a = dot(rd, rd);
    float b = 2.0 * dot(rd, ro);
    float c = dot(ro, ro) - r * r;
    float desc = b * b - 4.0 * a * c;
    if (desc < 0.0)
        return vec2(1.0, 0.0);

    return vec2((-b - sqrt(desc)) / (2.0 * a), (-b + sqrt(desc)) / (2.0 * a));
}

// Function 2727
float distSphere(vec3 p, float size)
{
    return length(p) - size;
}

// Function 2728
vec2 sphereIntersect(vec3 start, vec3 dir, float radius){
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0){
    	return vec2(1e5, -1e5);
    }
    return vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));
}

// Function 2729
float conejo(vec3 p, float r){
  // TEST ROT
  p.xz *= rot(1.6);
  float d = 1.;
  const float sv = .5;
  
  //p.xy *= rot(sin(time*10.)*.25);
  p.z += sin(p.x*.25+time*2.)*1.6;
  p.y -= sin(p.x*.50+time*5.)*1.5;
  
  
  //orejas
  vec3 porejas = p;
  porejas.x -= 1.3;
  porejas.z = abs(porejas.z)-.125;
  float orejas = cil(porejas.xz, r*.08);
  
  orejas = max(orejas, -porejas.y+.225);
  orejas = max(orejas, porejas.x);
  orejas = max(orejas, porejas.y-1.25);
  vec3 porificios = p;
  porificios.y -= 1.45;
  porificios.x -= 1.3;
  porificios.z = abs(porificios.z)-.1;
  float orificios = esf(porificios, .0001);
  orejas = smin(orejas, orificios, 0.7);
  d = smin(d, orejas, sv);
  //cabeza
  vec3 pcabeza = p;
  pcabeza.y += .25;
  pcabeza.x -= 1.25;
  float rcabeza =  r*.4;
  float cabeza = esf(pcabeza,rcabeza);
  d = smin(d, cabeza, sv);
  
  //ojos
  vec3 pojos = p;
  pojos.y += .2;
  pojos.x -= 1.55;
  pojos.z = abs(pojos.z)-rcabeza+.1;
  float ojos = esf(pojos, r*.035);
  d = min(d, ojos);
  
  //cuerpo
  float cuerpo =  esf(p, r*.85);
  d = smin(d, cuerpo, sv);
  //patas
  vec3 ppatas = p;
  ppatas.y += 1.05;
  
  float absm = .44;
  anim(absm);
  ppatas.x = abs(ppatas.x)-absm;
  
  ppatas.z = abs(ppatas.z)-.25;
  float rpatas = r*.15;
  float patas = esf(ppatas, rpatas);
  d = smin(d, patas, sv);
  //cola
  vec3 pcola = p;
  pcola.y -= .5;
  pcola.x += 1.;
  
  vec3 p1 = p;
  float rcola = r*.15 tn * .4;
  float cola = esf(pcola, rcola);
  d = smin(d, cola, sv);
  
  
  return d;
}

// Function 2730
Hit sphereHit(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection, int id) {
    float a = dot(rayDirection, rayDirection);
    vec3 L = rayOrigin - center;
    float b = 2.0 * dot(rayDirection, L);
    float c = dot(L, L) - radius*radius;
    float discrim = b*b - 4.0*a*c;
    if (discrim < 0.0) return noHit;
    float t = (-b - sqrt(discrim)) / (2.0 * a);
    if (t < 0.0) return noHit;
    vec3 p = rayOrigin + t*rayDirection;
    return Hit(t, p, normalize(p-center), id);
}

// Function 2731
float linesTextureGradBox( in float p, in float ddx, in float ddy, int id )
{
    float N = float( 2 + 7*((id>>1)&3) );

    float w = max(abs(ddx), abs(ddy)) + 0.01;
    float a = p + 0.5*w;                        
    float b = p - 0.5*w;           
    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-
                  floor(b)-min(fract(b)*N,1.0))/(N*w);
}

// Function 2732
float cylinder(vec3 p, vec2 h) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - h;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2733
v0 sphere(v2 u,v0 r){return length(u.xyz)-r;}

// Function 2734
vec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )
{
    return sign(pos)*normalize(max(abs(pos)-siz,0.0));
}

// Function 2735
float sdPlane( vec3 rayPos, vec4 n )
{
  n = normalize(n); // orientation of plane, n must be normalized!
  return dot(rayPos,n.xyz) + n.w;
}

// Function 2736
float getSphereLightIntensity(float num) {
    return num > .5 ?
        clamp(fract(time)*10.-1., 0., 1.) :
		max(0., 1.-fract(time)*10.); 
}

// Function 2737
float fBoxCheap(vec3 p, vec3 b) {
	return vmax(abs(p) - b);
}

// Function 2738
vec4 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim) 
{
    vec3 m = 1.0/ray;
    vec3 n = m*(ctr-pos);
    vec3 k = abs(m)*dim;
	
    vec3 t1 = n - k;
    vec3 t2 = n + k;

	float tmax = max( max( t1.x, t1.y ), t1.z );
	float tmin = min( min( t2.x, t2.y ), t2.z );
	
	if( tmax > tmin || tmin < 0.0) return vec4(vec3(0.),INFINI);

    vec3 norm = -sign(ray)*step(t2, vec3(tmin));
    return vec4(norm, tmin);
    
}

// Function 2739
float dbox(vec3 q, vec3 e)
{
    q = abs(q) - e;
	return all(lessThan(q, vec3(0))) 
        ? max(max(q.x,q.y),q.z)
        : length(max(q, 0.));
}

// Function 2740
float sdTorus(vec3 p, vec2 r) 
{
    float x = length(p.xz)-r.x;
    return length(vec2(x, p.y))-r.y;
}

// Function 2741
float sdPlane( vec3 p, vec4 n ){ return dot(p,n.xyz) + n.w + 0.1*sin(p.z*3.0)*sin(p.x*3.0); }

// Function 2742
float sdPlane(vec3 p) {
  return p.y;
}

// Function 2743
SDFResult roundboxSDF( RoundBox box, vec3 p )
{
    p -= box.pos;
    vec3 d = abs(p) - box.dimensions;
    SDFResult res;
    res.dist = length(max(d,0.0)) - box.radius + min(max(d.x,max(d.y,d.z)),0.0);
    res.matindex = box.matindex;
    return res;
}

// Function 2744
float sdSphere(vec3 p, vec3 offs, float r)
{
    return length(p - offs) - r;
}

// Function 2745
float sdSphere( vec3 p, vec3 cen, float rad )
{
    return length(p-cen)-rad;
}

// Function 2746
float boxes (vec3 pos, float salt) {
    vec3 p = pos;
    float ry = cell * .43*(.3+salt);
    float rz = cell * .2*(.5+salt);
    float salty = rng(vec2(floor(pos.y/ry), floor(pos.z/rz)));
    pos.y = repeat(pos.y, ry);
    pos.z = repeat(pos.z, rz);
    float scene = sdBox(pos, vec3(.1+.8*salt+salty,.1+.2*salt,.1+.2*salty));
    scene = max(scene, sdBox(p, vec3(cell*.2)));
    return scene;
}

// Function 2747
vec3 boxgrad(in vec3 ro, in vec3 r) {
    vec2 diff = vec2(RAYMARCH_TOL, 0.);
    float dx = boxsdf(ro + diff.xyy, r) - boxsdf(ro - diff.xyy, r);
    float dy = boxsdf(ro + diff.yxy, r) - boxsdf(ro - diff.yxy, r);
    float dz = boxsdf(ro + diff.yyx, r) - boxsdf(ro - diff.yyx, r);
    return normalize(vec3(dx, dy, dz));
}

// Function 2748
float dsphere(vec3 p, vec3 c, float r)
{
    return length(p-c) - r;
}

// Function 2749
float voronoiTorus(vec3 p){
    vec2 size = vec2(12,5);
    vec2 q = vec2(length(p.xz) - size.x, p.y);
	vec2 uv=vec2(atan(p.z, p.x),atan(q.y, q.x))/3.1415;
	vec3 vr=voronoi(uv*vec2(20,8));
    vec2 p2=vec2(lpNorm(vr.yz,12.0)-0.5, sdTorus(p,size));
    //vec2 p2=vec2(length(vr.yz)-0.5, sdTorus(p,size));
	return lpNorm(p2,5.0)-0.1; 
}

// Function 2750
bool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)
{
	// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5
	float a = dot(dir.xy, dir.xy);
	float b = dot(org.xy, dir.xy);
	float c = dot(org.xy, org.xy) - 12.;

	float delta = b * b - a * c;
	if( delta < 0.0 )
		return false;

	// 2 roots
	float deltasqrt = sqrt(delta);
	float arcp = 1.0 / a;
	near = (-b - deltasqrt) * arcp;
	far = (-b + deltasqrt) * arcp;
	
	// order roots
	float temp = min(far, near);
	far = max(far, near);
	near = temp;

	float znear = org.z + near * dir.z;
	float zfar = org.z + far * dir.z;

	// top, bottom
	vec2 zcap = vec2(1.85, -1.85);
	vec2 cap = (zcap - org.z) / dir.z;

	if ( znear < zcap.y )
		near = cap.y;
	else if ( znear > zcap.x )
		near = cap.x;

	if ( zfar < zcap.y )
		far = cap.y;
	else if ( zfar > zcap.x )
		far = cap.x;
	
	return far > 0.0 && far > near;
}

// Function 2751
bool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {
    return dot(wo, normal) * dot(wi, normal) > 0.0;
}

// Function 2752
float rpBox( vec3 p, vec3 c ) {
    vec3 q = mod(p,c)-0.5*c;
    return udBox( p, vec3(0.5, 0.5, 0.5) );
}

// Function 2753
float sdBox(vec2 p, vec2 b) {
  vec2 d = abs(p) - b;
  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); 
}

// Function 2754
float plane( vec3 p, vec3 n, float h )
{
  return dot(p,n) + h;
}

// Function 2755
float sdCylinder6( vec3 p, vec2 h )
{
  return max( length6(p.xz)-h.x, abs(p.y)-h.y );
}

// Function 2756
float distPlane( vec3 pos ) {
    return pos.y;
}

// Function 2757
float sphereImpact(in vec3 pos, in vec3 ray, in vec3 O, in float R, inout vec3 norm ){
    float d=0., t = INFINI;
    vec3 a = O - pos;
    float b = dot(a, ray);
    
    if (b >= 0.){	// check if object in frontside first (not behind screen)
        float c = dot(a,a) - R*R;
    	d = b*b - c;
    	if (d >= 0.){
        	float sd = sqrt(d);
            t = b - sd;
            norm = normalize(pos + t*ray - O);
        }
    }
    
    return t;
}

// Function 2758
vec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)
{
    // Fancy lighty debug plane
    if (ray_start.y > cut_plane && ray_dir.y < 0.) {
       float d = (ray_start.y - cut_plane) / -ray_dir.y;
       if (d < ray_len) {
           vec3 hit = ray_start + ray_dir*d;
           float hit_dist = fField(hit);
           float iso = fract(hit_dist*5.0);
           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);
           dist_color *= 1.0/(max(0.0,hit_dist)+.001);
           ray_len = d;
           return vec4(dist_color,.1);
      }
   }
   return vec4(0);
}

// Function 2759
float boxSDF(vec2 p, vec2 size) {
	vec2 r = abs(p) - size;
    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));
}

// Function 2760
float box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering) {
    vec3 dr = 1.0/rd;
    vec3 n = ro * dr;
    vec3 k = r * abs(dr);
    
    vec3 pin = - k - n;
    vec3 pout =  k - n;
    float tin = max(pin.x, max(pin.y, pin.z));
    float tout = min(pout.x, min(pout.y, pout.z));
    if (tin > tout) return -1.;
    if (entering) {
    	nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);
    } else {
        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);
    }
    return entering ? tin : tout;
}

// Function 2761
float intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius)
{
    vec3 oc = origin - center;
    float a = dot(direction, direction);
    float b = 2. * dot(oc, direction);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4. * a * c;
    if (disc < 0.) {
        // no intersection?
        return -1.;
    } else {
        return (-b - sqrt(disc)) / (2. * a);
    }
}

// Function 2762
vec3 getConeSample(vec3 dir, float extent) {
	// Create orthogonal vector (fails for z,y = 0)
	dir = normalize(dir);
	vec3 o1 = normalize(ortho(dir));
	vec3 o2 = normalize(cross(dir, o1));

	// Convert to spherical coords aligned to dir
	vec2 r = hash2();

	r.x = r.x * 2. * PI;
	r.y = 1.0 - r.y * extent;

	float oneminus = sqrt(1.0 - r.y * r.y);
	return normalize(cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir);
}

// Function 2763
bool closestCapsPlane(vec3 p1Line, vec3 p2Line, float ep, vec3 pPlane0, vec3 nPlane, inout vec3 out0, inout vec3 out1, inout vec3 n) {
 //   closestSegmentPlane(p1Line, p2Line, pPlane-nPlane*10., nPlane, out0, out1);
    vec3 rd = normalize(p2Line - p1Line),
         pdk, pPlane = pPlane0 - nPlane*10.;
    float a = dot(rd, nPlane),
          d = -(dot(p1Line, nPlane)-dot(nPlane,pPlane))/a;
    // Just project sommets of line on plane and select the closest
    vec3 p1OnPlane = projPtOnPlane(p1Line, pPlane, nPlane),
         p2OnPlane = projPtOnPlane(p2Line, pPlane, nPlane);   
    if (distance(p1Line, p1OnPlane) < 10. && distance(p2Line, p2OnPlane) < 10.) {
        out0 = (p1Line+p2Line)*.5;
        out1 =projPtOnPlane(out0, pPlane, nPlane);
    } else if (distance(p1Line, p1OnPlane) < distance(p2Line, p2OnPlane)) {
        out0 = p1Line;
        out1 = p1OnPlane;
    } else {
        out0 = p2Line;
        out1 = p2OnPlane;
    }
    return removeThickness(ep, 10., out0, out1, n);
}

// Function 2764
float areaBox(Box A){
	return max(A.max.x-A.min.x,0.)*max(A.max.y-A.min.y,0.);
}

// Function 2765
vec3 nSphere(in vec3 pos, in vec4 sph )
{
	return (pos - sph.xyz)/sph.w;
}

// Function 2766
void sphere(in Ray R, in Sphere S, in Material M, inout Intersection I) {
   float t;
   if(intersect_sphere(R, S, t) && t < I.t) {
      I.t = t;
      I.material = M;
      I.P = R.Origin + t*R.Dir;
      I.N = normalize(I.P - S.Center);
   }
}

// Function 2767
float sdf_rounded_cylinder( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 2768
vec2 ray_box(in ray r, in vec3 pos, in vec3 size) 
{
    vec3 m = 1.0 / r.dir; // can precompute if traversing a set of aligned boxes
    vec3 n = m * (r.pos - pos);   // can precompute if traversing a set of aligned boxes
    vec3 k = abs(m) * size;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float t_near = max( max( t1.x, t1.y ), t1.z );
    float t_far = min( min( t2.x, t2.y ), t2.z );
    
    if( t_near > t_far || t_far < 0.0) 
        return vec2(1000,-1000); // no intersection
        
    return vec2(t_near,t_far);
}

// Function 2769
Plane mkplane( vec3 base, vec3 normal ) { Plane plane; plane.base = base; plane.normal = normal; return plane; }

// Function 2770
vec2 boxIntersect(vec3 ro, vec3 rd, vec3 r, out vec3 normal, out vec3 normal2)
{
    // Compute intersection time t of ray ro+t*rd
    // with a box of half-size r centered at 0.
    ro *= sign(rd);
    vec3 t1 = (-r-ro)/abs(rd);
    vec3 t2 = (r-ro)/abs(rd);
    float tmin = max(t1.x, max(t1.y, t1.z));
    float tmax = min(t2.x, min(t2.y, t2.z));
    normal = -sign(rd) * step(t1.yzx,t1.xyz) * step(t1.zxy, t1.xyz);
    normal2 = -sign(rd) * step(t2.xyz,t2.yzx) * step(t2.xyz, t2.zxy);
    if(tmax < tmin) return vec2(-1.);
    return vec2(tmin, tmax);
}

// Function 2771
float iPlane(in vec3 ro, in vec3 rd, in float d) {
	// equation of a plane, y=0 = ro.y + t*rd.y
    return -(ro.y+d)/rd.y;
}

// Function 2772
float box2(vec2 p, vec2 r) {
    vec2 d = abs(p) - r;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2773
vec3 closestPointToBox2( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    vec3 s = sign(p);

    // interior
    vec3 q; float ma;
                 { q=p; q.x=s.x*b.x; ma=d.x; }
    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }
    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }
    if( ma<0.0 ) return q;

    // exterior
    return p - s*max(d,0.0);
}

// Function 2774
hit traceSphere(in ray r, in sph s) {
    vec3 oc = r.o - s.l;
    float c = dot(oc, oc) - s.r * s.r;
    float b = dot(oc, r.d),
		  h = sqrt(b * b - c),
          d = (h > 0.)? minPositive(-b+h,-b-h): zfar;
    vec3 l = r.d * d + r.o;
    return hit(l, (l - s.l) / s.r,
               vec3(max(0., d), h, 0.), s.m);   
}

// Function 2775
float sdBox( vec3 p, vec3 b, mat3 m )
{
  p = m * p;
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2776
float sdSphere(vec2 p, float r)
{
    return length(p)-r;
}

// Function 2777
float sphere(vec3 ray, vec3 dir, vec3 center, float radius)
{
 vec3 rc = ray-center;
 float c = dot(rc, rc) - (radius*radius);
 float b = dot(dir, rc);
 float d = b*b - c;
 if(d<0.0) return -1.0;
 float t = -b - sqrt(d);
 if(t>0.0) return t;
 t = -b + sqrt(d);
 if(t>0.0) return t;
 return -1.0;
}

// Function 2778
float IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {
    vec3 Z = ro-sc;
    float B = 2.0 * dot(rd, Z);
  
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;
    float D = B*B - 4.0*C;
    float d = -1.0;
    if(D>=0.0) {
        if(C==0.0) {
            tmin = -B/2.0;
            tmax = -1.;
            d = 0.0;
        }else{
            tmin = (-B-sqrt(D))/2.0;
            tmax = (-B+sqrt(D))/2.0;
            d = 1.0;
        }
    }
    return d;
}

// Function 2779
float PlaneDistance(in vec4 plane, in vec3 point)
{
    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);
}

// Function 2780
float SdSphere(vec3 p, float s)
{
	return length(p) - s;  
}

// Function 2781
float infi_box(vec2 p, vec2 b)
{
    vec2 d=abs(p)-b;
    return length(max(d,0.0))+min(max(d.x,d.y),0.0); 
}

// Function 2782
vec4 rayPlane(vec3 rp, vec3 rd, vec3 pos, vec3 normal) {
    float dst = dot(rp-pos,normal)/dot(rd,normal);
    if (dst < 0.) return vec4(normal,-dst);
    return NNO;
}

// Function 2783
void sampleSphereSA(vec3 viewer, in Sphere sphere, inout SurfaceLightSample sls){
    // get costheta and phi
    vec3 main_direction = (viewer - sphere.position);
    float d = length(main_direction);
    main_direction /= d;
    float d2 = d*d;
    float sinthetamax = sphere.radius /d;
    
    //float thetamax = asin(sinthetamax);
    float costhetamax = sqrt(1.0f - sinthetamax * sinthetamax);//cos(thetamax);
    
    float costheta = 1.0f - rand1()  * (1.0f - costhetamax);
    
    float sintheta = sqrt(1.0 - costheta * costheta);//sin(acos(costheta))
    float phi = rand1() * TWO_PI;
    
    // D = 1 - d sin  / r
    float sintheta2 =  sintheta * sintheta;
    float D = 1.0 - d2 * sintheta2 / sphere.radius2;
    bool D_positive = D > 0.0f;
    
    float cosalpha = float(D_positive) * (sintheta2 / sinthetamax +  costheta * sqrt(abs(D)))
        			+float(!D_positive) * sinthetamax;
    
    float sinalpha = sin(acos(cosalpha));//sqrt(1.0 - cosalpha * cosalpha);

    vec3 direction = vec3(sinalpha * cos(phi), sinalpha * sin(phi), cosalpha);
    if(abs(main_direction.z) > 0.99999f){
        sls.normal = direction * sign(main_direction.z);
    }
    else{
        vec3 axis = normalize(cross(UP, main_direction));
        float angle = acos(main_direction.z);

        sls.normal = rotate(axis, angle, direction);
    }
    sls.point = sphere.position + sphere.radius * sls.normal;
    float solid_angle = TWO_PI * (1.0 - costhetamax);
    sls.pdf = 1.0f / solid_angle;
}

// Function 2784
float cylinderSDF(vec3 p, float h, float r) {
    // How far inside or outside the cylinder the point is, radially
    float inOutRadius = length(p.xy) - r;
    
    // How far inside or outside the cylinder is, axially aligned with the cylinder
    float inOutHeight = abs(p.z) - h/2.0;
    
    // Assuming p is inside the cylinder, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);

    // Assuming p is outside the cylinder, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 2785
vec2 sphereIntersect( in vec3 ro, in vec3 rd,
                      in vec3 c, in float r,
                      out vec3 normal)
{
    // Closest and farthest point of intersection with the sphere
    // If no intersection, both are -1.
    ro -= c;
    float rord = dot(ro, rd);
    float Delta_prime = rord*rord + r*r - dot(ro, ro);
    float dt = sqrt(Delta_prime);
    float tmin = -rord-dt, tmax = -rord+dt;
    if(Delta_prime < 0.0 || tmax < 0.0) return vec2(-1.0); // no intersection
    normal = normalize(ro + tmin * rd);
    return vec2(tmin, tmax);
}

// Function 2786
float plane(vec3 rp, vec4 pn)
{
  return dot(rp, pn.xyz) + pn.w;
}

// Function 2787
vec3 RandomInUnitSphere(vec3 seed) 
{
    vec3 h = hash3(g_seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 1./3.);
	return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// Function 2788
float tetrahedronPlanes(vec3 p, float d) { 
  float dn =1.0/sqrt(3.0);
  
   //The tetrahedran is the intersection of four planes:
    float sd1 = plane(p,vec3(d,d,d) ,vec3(-dn,dn,dn)) ; 
    float sd2 = plane(p,vec3(d,-d,-d) ,vec3(dn,-dn,dn)) ;
 	float sd3 = plane(p,vec3(-d,d,-d) ,vec3(dn,dn,-dn)) ;
 	float sd4 = plane(p,vec3(-d,-d,d) ,vec3(-dn,-dn,-dn)) ;
  
    //max intersects shapes
    dn = max(max(sd1,sd2),max(sd3,sd4));
  return dn; 
}

// Function 2789
vec3
sample_cos_hemisphere(vec2 uv)
{
	vec2 disk = sample_disk(uv);
	return vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);
}

// Function 2790
float sdPlane(vec3 p, vec3 n, float h ) {
    return dot(p,n) + h;
}

// Function 2791
float sdCone(in vec3 p, in vec3 c)
{
    vec2 q = vec2(length(p.xz), p.y );
#if 0
	return max(max(dot(q, c.xy), p.y), -p.y - c.z );
#else
    float d1 = -p.y - c.z;
    float d2 = max(dot(q, c.xy), p.y);
    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);
#endif    
}

// Function 2792
float CylinderYZ( vec3 p, vec3 c ) {
	return length(p.yz-c.xy)-c.z;
}

// Function 2793
float sdDistancePlanes(vec3 p)
{
    if (_ambOccMarch == true || keyInfo(74.,2.) > 0. || keyInfo(72.,2.) > 0.) return 1e10;
    
    float d = 1e10;
    
    if ((_plane_xz == true && _ortho == false) || (_ortho == true && _plane_xy == false && _plane_yz == false))
    d = min(d,abs(p.y));
    
    if (_plane_xy == true)
    d = min(d,abs(p.z));
    
    if (_plane_yz == true)
    d = min(d,abs(p.x));
    
    return d;
}

// Function 2794
float BoxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.2;
}

// Function 2795
vec3 projOnPlane( vec3 q, vec3 p , vec3 n){
    
    vec3 v = q - dot(q - p, n) * n;
    return v;
}

// Function 2796
float Plane(vec3 p, float h){
    return p.y - h;
}

// Function 2797
float yBox( vec3 p, vec2 b )
{
	vec2 d = abs(p.xz) - b;
    return min(max(d.x,d.y),0.0) +
           length(max(d,0.0));
}

// Function 2798
vec3 planeRay(vec3 p,vec3 o,vec3 d){d=normalize(d);
 const float aco3=acos(-1.)/3.;vec3 n=vec3(0,-1,0);
 float i=apos(  n              ,1.,o,d),//northern   
 j=apos(-vec3(r(n.xy, aco3),n.z),1.,o,d),//southeast
 k=apos(-vec3(r(n.xy,-aco3),n.z),1.,o,d);//southwest
 return o+d*min(min(i,j),k);
}

// Function 2799
float getPlaneDist(vec3 p) {
    //plane is at y = 0, so 
    //y component is the distance
	return p.y;
}

// Function 2800
float sphere(in vec3 pos, in float r)
{
    return length(pos) - r;
}

// Function 2801
void createTorus( mat4 transform, float R, float r, int mtl, out Object obj) {
    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );
    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );
    obj.type_ = OBJ_TORUS;
    obj.mtl_id_ = mtl;
    obj.transform_ = transform;
    obj.transform_inv_ = mat4Inverse( obj.transform_ );
    obj.params_[0] = R*R;
    obj.params_[1] = r*r;
}

// Function 2802
float intersect_plane_line(vec4 plane, vec3 ro, vec3 rd) {    
    vec3 p0 = -dot(vec4(ro,1.0), plane)*plane.xyz;
    return dot(p0, plane.xyz) / dot(rd, plane.xyz);
}

// Function 2803
float sdConeSection( vec3 p, float h, float r1, float r2
){vec2 d=vec2(-p.z,p.z)-h
 ;float si=.5*(r1-r2)/h
 ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)
 ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}

// Function 2804
float sdCylinder( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2805
float planeSDF(vec3 p, vec3 n)
{
    return length(p) * dot(normalize(p), n);
}

// Function 2806
vec4 sphereI(vec3 pos, const vec3 dir, vec3 sPos){
    pos -= sPos;
	float b = -dot(pos, dir);
	float d = b * b - dot(pos, pos) + .2;
	if (d < 0.0) return vec4(-1.);
	b -= sqrt(d);
	return vec4(normalize(pos+b*dir), b);
}

// Function 2807
float IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out float distFromSphere, out vec3 intersectA2, out vec3 intersectB2)
{
	// Use dot product along line to find closest point on line
	vec3 eyeVec2 = normalize(posB-posA);
	float dp = dot(eyeVec2, pos - posA);
	vec3 pointOnLine = eyeVec2 * dp + posA;
	// Clamp that point to line end points if outside
	//if ((dp - radius) < 0) pointOnLine = posA;
	//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;
	// Distance formula from that point to sphere center, compare with radius.
	float distance = length(pointOnLine - pos);
	float ac = radius*radius - distance*distance;
	float rightLen = 0.0;
	if (ac >= 0.0) rightLen = sqrt(ac);
	intersectA2 = pointOnLine - eyeVec2 * rightLen;
	intersectB2 = pointOnLine + eyeVec2 * rightLen;
	distFromSphere = distance - radius;
	if (distance <= radius) return 1.0;
	return 0.0;
}

// Function 2808
float sphereSDF(sphere s,vec3 p){
	return length(s.p-p)-s.size;
}

// Function 2809
vec2 iCappedCone2( in vec3  ro, in vec3  rd, 
                  in vec3  pa, in vec3  pb, 
                  in float ra, in float rb )
{
    vec3  ba = pb - pa;
    vec3  oa = ro - pa;
    vec3  ob = ro - pb;
    
    float m0 = dot(ba,ba);
    float m1 = dot(oa,ba);
    float m3 = dot(rd,ba);

    // body
    float m4 = dot(rd,oa);
    float m5 = dot(oa,oa);
    float rr = ra - rb;
    float hy = m0 + rr*rr;
    
    float k2 = m0*m0    - m3*m3*hy;
    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );
    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return vec2(-1.0);

    return ((vec2(-1, +1) * sqrt(h)) - k1) / k2;
}

// Function 2810
Box makeBox(vec3 center, vec3 halfSize)
{
 	return Box(center-halfSize,center + halfSize);   
}

// Function 2811
bool intersectSphere(vec3 ro, vec3 rd, float r, out float t)
{
	float b = dot(-ro, rd);
	float det = b*b - dot(ro, ro) + r*r;
	if (det < 0.0) return false;
	det = sqrt(det);
	t = b - det;
	return t > 0.0;
}

// Function 2812
float Box(float radius, vec3 position)
{
    return max(max(abs(position.x), abs(position.y)), abs(position.z)) - radius;
}

// Function 2813
float raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr, out float coverage) {
    // - r0: ray origin
    // - rd: normalized ray direction
    // - s0: sphere center
    // - sr: sphere radius
    // - Returns distance from r0 to first intersecion with sphere,
    //   or MAX_DST if no intersection.
    float a = dot(rd, rd);
    vec3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
    
    float inside = b*b - 4.0*a*c;
    
    if (inside < 0.0) {
        return MAX_DST;
    }
    
    float dst = (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);
    
    // This is a fallof around the edge used for AO
    // chnage the magic value for a smoother border
    coverage = S(inside, 0.0, 0.65 * sr * dst / iResolution.x);
    
    return dst;
}

// Function 2814
float qbox( vec3 p, float s )
{
  return length(max(abs(p)-vec3(s,s,s),0.0));
}

// Function 2815
TraceResult traceCylinder(Cylinder cyl, vec3 orig, vec3 dir)
{
    TraceResult res;
    
    float dist = INF;
    vec3 normal;
    
    vec3 plane = vec3(0, -1, 0);
    float toPlane = traceCylinderPlane(cyl, plane, orig, dir);
    if (toPlane < dist) {
        dist = toPlane;
        normal = -plane;
    }
    
    float toSide = traceCylinderSide(cyl, orig, dir);
    if (toSide < dist) {
        dist = toSide;
        normal = calcCylSideNormal(cyl, dist, orig, dir);
    }
    
    res.dist = dist;
    res.n = normal;
    res.hit = dist >= 0.0 && dist < INF;
    
    return res;
}

// Function 2816
float distTorus(vec3 p, float R, float r)
{
    return length(p-vec3(normalize(p.xy),0)*R)-r;
}

// Function 2817
float MBoxDf (vec3 p)
{
  vec4 q, q0;
  const float mScale = 2.62;
  const int nIter = 12;
  q0 = vec4 (p, 1.);
  q = q0;
  for (int n = 0; n < nIter; n ++) {
    q.xyz = clamp (q.xyz, -1., 1.) * 2. - q.xyz;
    q = q * mScale / clamp (dot (q.xyz, q.xyz), 0.5, 1.) + q0;
  }
  return length (q.xyz) / abs (q.w);
}

// Function 2818
float sphere_intersection(vec3 r, vec3 p, vec4 sphere)
{
	p = p - sphere.xyz;
	if(p == vec3(0)) return sphere.w;
	
	float b = dot(p, r);
	float c = sphere.w*sphere.w - dot(p,p);
	float d = b*b + c;
	
	if((d <= 0.)) //if no intersection
	{
		return -length(cross(r, sphere.xyz)); //return closest dist
	}
	else
	{
		return -sqrt(d) - b; //use closest solution in the direction of the ray
	}
}

// Function 2819
vec4 Sphere0(vec4 sphereBase, float uRandom)
{
	return sphereBase + VecOsc(
							vec4(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0, 0.0),
							vec4(20, 100, 100, 0) +
							VecOsc(
								vec4(1.10382 / 6.0, 1.092385 / 10.0, 1.03389 / 14.0, 0),
								vec4(10, 50, 50, 0), 100.0 * uRandom), 100.0 * uRandom);
}

// Function 2820
void addSphere(vec3 position, float radius, Material material, inout Scene scene){
	scene.spheres[scene.nbSpheres++] = Sphere(position, radius, radius*radius, material);
    if(isEmissive(material)){
    	scene.light_spheres[scene.nbLightSpheres++] = scene.nbSpheres-1u;
    }
}

// Function 2821
vec2 sdCylinder( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),21.);
}

// Function 2822
float PlaneProjectScale( vec3 v )
{
    // project onto the plane through (1,0,0), (0, 1, 0), (0, 0, 1)    
    return 1.0 / dot( v, vec3(1.0) );
}

// Function 2823
float scene_primitive_sphere( Ray ray, float R, inout float t, inout vec3 N )
{
    vec2 sph = sphere_impact( ray.o, ray.d );
    if( sph.x < R * R )
    {
        float to = sphere_limits( R, sph ).x;
        if( to >= 0. && to < t )
        {
            t = to;
            N = normalize( ray.o + t * ray.d );
        }
    }
    float shadow = 1.;
    if( sph.y < 0. )
    {
        float K = -2. * sph.y * SCN_RAYCAST_SHADOW_UMBRA_INV;
        float u = sqrt( sph.x );
        shadow = 1. - aaa_interval( K, u, 2. * R );
    }
    return shadow;
}

// Function 2824
float rbox( vec3 p, vec3 b, float r ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

// Function 2825
float BoxSDF(vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return length(max(d,0.0)) +
        	min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 2826
float sdRoundBox( in vec2 p, in vec2 b, in float r ) 
{
    vec2 q = abs(p) - b+r; // AB added + r here so that size stay constant
    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );
    float d = (m.x > 0.0) ? length(q) : m.y; 
    return d - r;
}

// Function 2827
float Plane(vec3 point, vec3 nor, vec3 pos) {

    return dot(point - pos, nor);
}

// Function 2828
float distBox(vec3 p, vec3 pos, vec3 r) {
    
    return length(max(abs(pos - p) - r, 0.));
    
}

// Function 2829
bool closestSpherePlane(vec3 cSphere, float rSphere, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
    out0 = cSphere; out1 = projPtOnPlane(cSphere, pPlane, nPlane);
    return removeThickness(rSphere, 0., out0, out1);
}

// Function 2830
vec3 SampleHemisphere(vec3 N, float sinTheta, float cosTheta, float s_x)
{
	float phi = 2.0*PI*s_x;
	float sinPhi = sin(phi);
	float cosPhi = cos(phi);
	return MakeOrthoBasis(N)*vec3(vec2(cosPhi, sinPhi)*sinTheta, cosTheta);
}

// Function 2831
vec3 planeColor( vec3 p , vec3 n  , float ao ){
    
   
   return cPal( length( p ) * .1 ) *ao;
   
}

// Function 2832
float sdBox( vec3 point, vec3 b )
{
    vec3 d = abs(point) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2833
float cone( vec2 p, vec2 c )
{
    p.x = abs(p.x);
    
    float l = dot(c,p.xy);
    
    vec2 q = p.xy-c*l;
    
    // this is optional
    if (q.x < 0.0) {
        l = length(p.xy)*sign(p.y*c.y);
    }
    
    return l;
}

// Function 2834
float opRepTorus( vec3 p, vec3 c, vec2 t )
{
    vec3 q = mod(p,c)-0.5*c;
    return sdTorus( q, t );
}

// Function 2835
float insideBox3D(vec3 p, vec3 center, vec3 size)
    {
        vec3 s = step(center - size, p) - step(center + size, p);
        return s.x * s.y * s.z;
    }

// Function 2836
float udRoundBox(vec3 p, vec3 b, float r)
    {
        return length(max(abs(p) - b, 0.0))- r;
    }

// Function 2837
float sphereDist(vec4 sphere, vec3 point)
{
    return length(point - sphere.xyz) - sphere.w;
}

// Function 2838
Result cylinderIntersect(in Ray ray, in vec3 p, in vec3 n, in float h , in float r, in int id){
    Result res = nullResult;
	return res;
}

// Function 2839
vec3 uniformSphere(vec2 uv, in Sphere s)
{
    // generate a point uniformly distributed on the unit hemisphere
    // 1 = I[Hemisphere]{C d(omega)} = 
    // I[0,2pi]x[0,pi/2]{C*sin(theta)d(theta)d(phi)} = 
    // -2*pi*C(cos(pi/2) - cos(0)) = 2*pi*C -> C = 1/(2*pi)
    // Then for the whole sphere C' = 1/(4*pi)
    
    // p(theta) = I[0,2pi]{C*sin(theta)d(phi)} = sin(theta)
    // p(omega) = 1/(2*pi), p(phi,theta) = sin(theta)/(2*pi)
    // p(phi|theta) = p(phi,theta)/p(theta) = 1/(2*pi)
    
    // P(theta) = I[0,theta]{p(theta)d(theta)} = 1-cos(theta)
    // u ~ 1-cos(theta) ~ cos(theta)
    // To extend this to the whole sphere, cos(theta) must be in [-1,1]
    // Since uniformly distributed points on a sphere are uniformly distributed
    // on the hemisphere we can just do u->u' in [-1,1] : u' = 2*u-1
    
    // P(phi) = I[0,phi]{p(phi|theta)d(phi)} = phi/(2*pi) -> phi = 2*pi*phi
    
    float cosTheta = 2.0*uv.x-1.0;
    float sinTheta = sqrt(1.0-cosTheta*cosTheta);
    float phi = PI2*uv.y;
    
    vec3 result = s.pos + s.radius*vec3(sinTheta*vec2(cos(phi), sin(phi)), cosTheta);
    return result;
}

// Function 2840
float box(in vec3 p, in float s){
 	return length(max(abs(p)-s, 0.));
}

// Function 2841
float traceCylinder(vec3 position, vec3 direction, out vec3 normal) {
    float t = (-1.0 - position.y) / direction.y;
    if (t <= 0.0) {
        return INF;
    }
    
    vec3 worldPos = position + t * direction;
    if (dot(worldPos.xz, worldPos.xz) < 0.5) {
        normal = vec3(0, 1, 0);
        return t;
    }
    
    float a = dot(direction.xz, direction.xz);
    float b = dot(position.xz, direction.xz);
    float c = dot(position.xz, position.xz) - 0.5;
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    
    t = (-b - sqrt(D)) / a;
    if (t > 0.0) {
        worldPos = position + t * direction;
        if (worldPos.y <= -1.0) {
            normal = normalize(vec3(worldPos.x, 0, worldPos.z));
            return t;
        }
    }
    
    t = (-b + sqrt(D)) / a;
    if (t < 0.0) {
        return INF;
    }
    
    worldPos = position + t * direction;
    if (worldPos.y <= -1.0) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }
    return INF;
}

// Function 2842
vec4 shadePlane(Ray ray, RaycastHit hit) {
 
    float diffuse = lighting(hit);
    vec2 uv = mod(hit.point.xz / 3., vec2(1.));
    
    vec3 rd = reflect(ray.dir, hit.normal);
    Ray rr = Ray(hit.point + (rd * .001), rd);
    RaycastHit rh = intersectScene(rr);
    
    vec4 tex = texture(iChannel1, uv);
    
    vec4 rc = rh.id == 0 ? shadeSphere(rr, rh) : texture(iChannel0, rd);
    vec4 col = tex * diffuse;
    //return col;
    float tf = (tex.x + tex.y + tex.z) / 3.;
    return mix(col, rc, tf);
    
}

// Function 2843
float torus(in vec3 p, in vec2 t, in float n1, in float n2)
{
    vec2 q = vec2(length2(p.xz, n1) - t.x, p.y);                              
    return length2(q, n2) - t.y;                                         
}

// Function 2844
float boxSDF(vec2 p,vec2 s
){vec2 r=abs(p)-s
 ;return min(max(r.x,r.y),0.)+length(max(r,vec2(0)));}

// Function 2845
float sphereSDF(vec3 p, Sphere s) {
    return length(p - s.c) - s.r;
}

// Function 2846
vec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) 
{
    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes
    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes
    vec3 k = abs(m)*boxSize;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection
    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    return vec2( tN, tF );
}

// Function 2847
vec2 box( vec3 pos,vec3 xyz,float o,float id){
	float d = length( max(abs(pos)-xyz,0.0))-o;
	return vec2(d,id);
}

// Function 2848
vec3 computeSphereNormal(in Sphere s, in Ray r, in float dist) {
    return normalize((r.origin + r.dir * dist) - s.center);
}

// Function 2849
vec3 uniformSampleCone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {
    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;
    float sinTheta = sqrt(1. - cosTheta * cosTheta);
    float phi = u12.y * TWO_PI;
    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));
    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;
}

// Function 2850
float fCylinder(vec3 p, float r, float height) {
	float d = length(p.xz) - r;
	d = max(d, abs(p.y) - height); //
	return d;
}

// Function 2851
vec4 dfunc_ui_box(int idx, int row) {
    
    return vec4(inset_ctr.x + (float(idx - 2))*text_size,
    	        dfunc_y - float(1-row)*text_size,
                vec2(0.45*text_size));
    
}

// Function 2852
float torus(vec3 p) {
	vec2 t = vec2(1.0, 0.32);
  	vec2 q = vec2(length(p.xy)-t.x,p.z);
  	return length(q)-t.y;
}

// Function 2853
float sphere(vec3 p,float r) {
	return length(p)-r;
}

// Function 2854
float sdfSphere(vec3 coord, vec3 center, float radius){ 
    return distance(coord,center) - radius; 
}

// Function 2855
float sdPlane( vec3 p, vec4 n ) {
  return dot(p,n.xyz) + n.w;
}

// Function 2856
HyperPlane readPlane(in Object _object)
{
    HyperPlane plane;
    plane.m_normal[0] = load(0, _object.m_id-10);
    plane.m_normal[1] = load(1, _object.m_id-10);
    plane.m_normal[2] = load(2, _object.m_id-10);
    plane.m_normal[3] = load(3, _object.m_id-10);
    plane.m_d = load(4, _object.m_id-10);
    
    return plane;
}

// Function 2857
float sdBox ( float3 O, float3 b ) {
  float3 d = abs(O) - b;
  return length(max(d, float3(0.0))) + vmax(min(d, float3(0.0)));
}

// Function 2858
float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs( p ) - b;
    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );
}

// Function 2859
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0)) - r
         + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 2860
float sdBox(vec3 p, vec3 bc, vec3 b) {    
    vec3 d = abs(bc - p) - b; 
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));;
}

// Function 2861
float sdRoundedCylinder( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 2862
vec3 planetPhongLightingModel(in vec3 k_d,in vec3 k_s,in float shininess,in vec3 p,in vec3 eyePos,in vec3 lightPos,in vec3 lightIntensity){
	vec3 N = sphereNormal(p,planetCenter,planetRadius);
    vec3 L = normalize(lightPos-p);
    vec3 V = normalize(eyePos-p);
    vec3 R = normalize(reflect(-L,N));
    
    float dotLN = dot(L,N);
    float dotRV = dot(R,V);
    if(dotLN<0.)
    {
        return vec3(0.,0.,0.);//light not visible from this point on the surface
    }
    if(dotRV<0.)
    {
        return lightIntensity*(k_d*dotLN);//light reflection in opposite direction as viewer,apply only diffuse component
    }
    return (k_d*dotLN+k_s*pow(dotRV,shininess))*lightIntensity;
}

// Function 2863
vec3 gettorusnormal(vec3 pos) {
    float xp = torussdf(pos + vec3(eps, 0., 0.));
    float xm = torussdf(pos - vec3(eps, 0., 0.));
    float ddx = xp - xm;
    float yp = torussdf(pos + vec3(0., eps, 0.));
    float ym = torussdf(pos - vec3(0., eps, 0.));
    float ddy = yp - ym;
    float zp = torussdf(pos + vec3(0., 0., eps));
    float zm = torussdf(pos - vec3(0., 0., eps));
    float ddz = zp - zm;
    return normalize(vec3(ddx, ddy, ddz));
}

// Function 2864
float magicBox(vec3 p) {
    // The fractal lives in a 1x1x1 box with mirrors on all sides.
    // Take p anywhere in space and calculate the corresponding position
    // inside the box, 0<(x,y,z)<1
    p = 1.0 - abs(1.0 - mod(p, 2.0));
    
    float lastLength = length(p);
    float tot = 0.0;
    // This is the fractal.  More iterations gives a more detailed
    // fractal at the expense of more computation.
    for (int i=0; i < MAGIC_BOX_ITERS; i++) {
      // The number subtracted here is a "magic" paremeter that
      // produces rather different fractals for different values.
      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;
      float newLength = length(p);
      tot += abs(newLength-lastLength);
      lastLength = newLength;
    }

    return tot;
}

// Function 2865
bool rayHitSphere( in vec3 ro, in vec3 rd, vec3 spC, float spR, out float dist, out vec3 norm )
{
	vec3 oc = ro - spC;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - spR * spR;
	float h = b*b - c;
	if( h < 0.0 ) return false;
	dist = -b - sqrt( h );
	if ( dist < 0.0 ) return false;
	norm = normalize( ro + rd * dist - spC );
	return true;
}

// Function 2866
float planeSDF(vec3 p) {
    return abs(p.y);
}

// Function 2867
Object MakeSphere(vec3 pos, float radius, vec3 albedo, vec3 emissive, int materialType)
{
	Object sphere;
	sphere.pos = pos;
	sphere.radius = radius;
	sphere.quadNormal = vec3(0);
	sphere.quadBasisX = vec3(0);
	sphere.quadBasisY = vec3(0);
#if LIGHT_TEXTURED
	sphere.quadLightTexture = 0U;
#endif // LIGHT_TEXTURED
#if LIGHTMAP
    sphere.lightmapBounds = vec4(0);
#endif // LIGHTMAP
    sphere.albedo = albedo;
	sphere.emissive = emissive;
	sphere.materialType = materialType;
	return sphere;
}

// Function 2868
float
spheremh_sd( in float sph_r, in vec3 p )
{
    return manhattan(p) - sph_r;
}

// Function 2869
float sdCylinderZY( const vec3 p, const vec2 h ) {
  vec2 d = abs(vec2(length(p.zy),p.x)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2870
float sphereDf(vec3 p, vec3 centre, float radius) {
  vec3 n = normalize(p-centre);
  vec3 tex = triplanar(n,sampler,doadjust3d,dorescale).xyz;
  float k = !dovariabledisplacement? 1.0: sin(0.25*PI*(iTime-9.5));
  if (do3d) {
    vec3 displacement = tex;
    displacement *= k*dscale;
    float dist = length(p-centre-displacement) - radius;
    return dist;
  } else {
    float displacement = dolengthdisplacement? length(tex): tex.x;
    displacement *= k*dscale;
    float dist = length(p-centre) - radius - displacement;
    return dist;
  }
}

// Function 2871
float sphere(vec3 p, float r, vec3 c) {
    return distance(p, c) - r;
}

// Function 2872
float sBox(vec2 p, vec2 b){

  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 2873
float udRoundBox(vec3 p, vec3 b, float r)
{
  	return length(max(abs(p)-b,0.0))-r;
}

// Function 2874
void boxFold(inout vec3 z, inout float dz)
{
	z = clamp(z, -1.0, 1.0) * 2.0 - z;
}

// Function 2875
float plane(vec3 p, vec3 c, vec3 n) {
   return dot(p-c, n);
}

// Function 2876
vec3 SampleHemisphereUniformCone(vec3 N, vec2 s, float halfConeAngleInRadians)
{
	float cosTheta = s.y;
	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
	float phi = 2.0*PI*s.x;
	vec3 V = SampleSpherical(sinTheta, cosTheta, phi);
	float NdotV = dot(N, V);
	if (NdotV < 0.0) { // necessary if N != {0,0,1}
		V = -V;
		NdotV = -NdotV;
	}
	if (halfConeAngleInRadians != PI*0.5) {
		float c2 = cos(acos(NdotV)*halfConeAngleInRadians); c2 *= c2;
		float s2 = 1.0 - c2;
		float z = sqrt((c2/s2)*(1.0 - NdotV*NdotV)) - NdotV;
		V = normalize(V + N*z);
	}
    return V;
}

// Function 2877
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
	// ray-box intersection in box space
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    
	float tN = max(max( t1.x, t1.y ), t1.z);
	float tF = min(min( t2.x, t2.y ), t2.z);

	return vec2(max(tN,0.0), tF);
}

// Function 2878
void hitBox2FromOutside(
    in vec2 boxMin, in vec2 boxMax,
    in vec2 p, in vec2 v,
    out float t, out float didHit
) {
    vec2 tb0 = (boxMin - p) / v;
    vec2 tb1 = (boxMax - p) / v;
    vec2 tmin = min(tb0, tb1);
    vec2 tmax = max(tb0, tb1);

    vec2 tRange = vec2(
        max(tmin.x, tmin.y),
        min(tmax.x, tmax.y)
    );

    didHit = step(tRange.s, tRange.t) * step(0.0, tRange.s);
    t = tRange.s;
}

// Function 2879
bool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, 
               out vec3 p0, out vec3 p1) 
{
    vec3 t0 = (bmin - ro) * invrd;
    vec3 t1 = (bmax - ro) * invrd;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    float fmin = max(max(tmin.x, tmin.y), tmin.z);
    float fmax = min(min(tmax.x, tmax.y), tmax.z);
    
    p0 = ro + rd*fmin;
    p1 = ro + rd*fmax;
 
    return fmax >= fmin;   
}

// Function 2880
RayTraceResult RayTraceHoledSphere(in Ray ray)
{
    RayTraceResult res = RayTraceSphere(ray, sphereCenter, sphereRadius);
    if (!HolePattern(res.pos, sphereCenter))
    {
        res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    }
    
    return res;
}

// Function 2881
bool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)
{
    float dist = -1.0f;
    float denom = dot(plane.xyz, rayDir);
    if (abs(denom) > 0.001f)
    {
        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;
    
        if (dist > 0.0f && dist < info.dist)
        {
            info.dist = dist;        
            info.normal = plane.xyz;
            info.diffuse = diffuse;
            return true;
        }
    }
    return false;
}

// Function 2882
vec2 plane_y(vec3 pos,float id){
	return vec2(pos.z,id);
}

// Function 2883
void boxFromLMN(in vec3 lmn, out vec3 boxMin, out vec3 boxMax) {
    vec3 boxSize = (BOX_MAX - BOX_MIN) / BOX_N;

    boxMin = BOX_MIN + (floor(lmn)/BOX_N) * (BOX_MAX - BOX_MIN);
    boxMax = boxMin + boxSize;
}

// Function 2884
float sbox(in vec3 p, in vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2885
vec3 nSphere( in vec3 pos, in vec4 sph ) {
	return (pos - sph.xyz) / sph.w;
}

// Function 2886
vec3 SampleHemisphere_Uniform(float i, float numSamples)
{
	vec2 xi = Hammersley(i, numSamples);
    
    float phi      = xi.y * 2.0 * PI;
    float cosTheta = 1.0 - xi.x;
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Function 2887
vec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )
{
    //return vColor;
    vec3 vResult = vColor;
    
    
	float fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );
	vec3 vFogColor = Env_GetFogColor( vRayDir );	
	//Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    
    vResult = mix( vFogColor, vResult, fFogFactor );

    return vResult;	    
}

// Function 2888
float roundedConeSDF(in vec3 iPoint, in float iSmallRadius, in float iBigRadius, in float iHeight) {
    
    vec2 q = vec2(length(iPoint.xz), iPoint.y);
    
    float b = (iBigRadius - iSmallRadius)/iHeight;
    float a = sqrt(1.0 - b*b);
    float k = dot(q, vec2(-b, a));

    if (k < 0.0) return length(q) - iBigRadius;
    if (k > a*iHeight) return length(q - vec2(0.0, iHeight)) - iSmallRadius;

    return dot(q, vec2(a, b)) - iBigRadius;
    
}

// Function 2889
float box(vec2 coord, vec2 pos, vec2 size){
	if((coord.x<(pos.x+size.x)) &&
	   (coord.x>(pos.x-size.x)) &&
	   (coord.y<(pos.y+size.y)) && 
	   (coord.y>(pos.y-size.y)) ) 
		return 1.0;
	return 0.0;
}

// Function 2890
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 2891
float skewbox(vec2 uv, vec3 top, vec3 bottom, float blur) {
	float y = within(top.z, bottom.z, uv.y);
    float left = mix(top.x, bottom.x, y);
    float right = mix(top.y, bottom.y, y);
    
    float horizontal = B(left, right, uv.x, blur);
    float vertical = B(bottom.z, top.z, uv.y, blur);
    return horizontal*vertical;
}

// Function 2892
float sdCappedZCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xy), p.z)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2893
vec4 HitXZPlane(vec3 start, vec3 dir) {
    float t = -start.y / dir.y;
    return vec4(start + dir * t, t);
}

// Function 2894
float sdCone (in vec3 p, in vec3 c)
{
  vec2 q = vec2( length(p.xz), p.y );
  #if 0
    return max( max( dot(q, c.xy), p.y), -p.y -c.z );
  #else
    float d1 = -p.y - c.z;
    float d2 = max( dot(q, c.xy), p.y);
    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);
  #endif
}

// Function 2895
void cameraTransformPlanet( inout vec3 ro, inout vec3 rd )
{
	float c = cos(-iTime);
	float s = sin(-iTime);
    mat3 rot = mat3(
		  c,  0.0,   s,
		0.0,  1.0,  0.0,
		 -s,  0.0,   c
	);
	ro *= rot;
	rd *= rot;
}

// Function 2896
float sdBoundingBox( vec3 p, vec3 b, float e)
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),
                      dot2(max(vec3(q.x,p.y,q.z),0.0))),
                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) 
         +min(0.0,min(min( max(p.x,max(q.y,q.z)),
                           max(p.y,max(q.z,q.x))),
                           max(p.z,max(q.x,q.y))));
}

// Function 2897
vec2 sphere_impact( vec3 o, vec3 d )
{
    float q = dot( o, d );
    /*
    return vec2( dot( o, o ) - q * q, q );
	/*/
    vec3 h = o - d * q / dot( d, d );
    return vec2( dot( h, h ), q );
    //*/
}

// Function 2898
float sdSphere2( vec3 p, float r ) {
        return abs(length(p) - r);
    }

// Function 2899
hit traceBox(in ray r, in box b) {
    vec3 t1 = (b.n - r.o)/r.d,
         t2 = (b.x - r.o)/r.d,
         tn = min(t1, t2), tx = max(t1, t2);
    float tmin = vec3max(tn),
    	  tmax = vec3min(tx),
   		  f = minPositive(tmax, tmin);
    vec3 l = r.o + r.d*f*.9999,
         c = (b.x - b.n)*.5,
         d = b.n+c-l;
    return hit(l, step(c,abs(d)), vec3(max(0., f), tmax-tmin, 0.), b.m);
}

// Function 2900
vec2 coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 N_ray){
    float t_impact = INFINI, minDist=INFINI;
    vec3 delta = pos - coneO;
    
    float Dy = coneH - delta.y;
    float r2 = coneR*coneR/(coneH*coneH);
	
    // circle interception
    // pre-calculation
    float dot_N_ray_Sq_XZ = dot(N_ray.xz,N_ray.xz);
    float dot_delta_N_ray_XZ = dot(delta.xz, N_ray.xz);
    float c = dot(delta.xz,delta.xz) - r2*Dy*Dy;
    float calc = dot_delta_N_ray_XZ + r2*Dy*N_ray.y;
    
    float discr = calc*calc - (dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y) * c;
    
    if (discr >= 0.){
        float sqrt_discr = sqrt(discr);
        float t1 = (-calc + sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);
        float t2 = (-calc - sqrt_discr)/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y);
       
        if (t1 <= 0.001) t1 = INFINI;
        else if (-N_ray.y*t1 + Dy < 0.) t1 = INFINI;
        else if (-N_ray.y*t1 + Dy > coneH) t1 = INFINI;
        
        if (t2 <= 0.001) t2 = INFINI;
        else if (-N_ray.y*t2 + Dy < 0.) t2 = INFINI;
        else if (-N_ray.y*t2 + Dy > coneH) t2 = INFINI;
        
        t_impact = min(t1,t2);  
        if (t_impact < INFINI) minDist = abs(c-calc*calc/(dot_N_ray_Sq_XZ - r2*N_ray.y*N_ray.y))/(coneR/coneH);
    }
    
	return vec2(t_impact,minDist);
}

// Function 2901
vec4 normalize_plane(vec4 pl) {
    return pl / length(pl.xyz);
}

// Function 2902
float tToPlane(vec3 o, vec3 d)
{
    float t = 9999999.9;
    if (abs(d.x) > 0.0001)
    {
      float tt = -(5.0 * sign(d.x) + o.x)/d.x;
      if (tt >= 0.0)
      {
        vec2 s = o.yz + tt * d.yz;
        if ((abs(s.x) <= 5.0) && (abs(s.y) <= 5.0)) {
          t = tt;
        }
      }
    }
    return t;
}

// Function 2903
float vertCylinderAppSurface(vec3 view, float radius, float height){
    const vec3 zaxis = vec3(0.f,0.f,1.f);
	float res= diskAppSurface(view, zaxis, radius, false);
    res+= vertTubeAppSurface(view, radius, height);
    return res;
}

// Function 2904
HitTest intersectSphere(in Ray r, in Sphere s) {
	vec3 o = r.origin - s.pos;
	float v = dot(o, r.dir);
	if(v > 0.) return NOHIT;
    
	float disc = (s.radius * s.radius) - (dot(o, o) - (v * v));
	
	if(disc < 0.) return NOHIT;
	
	float dist = length(o) - (sqrt(disc));
	return HitTest(true, dist, normalize((r.origin + r.dir * dist) - s.pos), vec4(0), sin(iTime * 0.25)*.5+.5);
}

// Function 2905
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {
	vec3 oc = ro - sph.xyz;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - sph.w*sph.w;
	float h = b*b - c;
	if( h<0.0 ) return -1.;
	return -b - sqrt( h );
}

// Function 2906
vec2 plane(vec3 pos,float id){
	
	return vec2(pos.y,id);
}

// Function 2907
vec2 ray_sphere_intersect(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

// Function 2908
vec2 sphereImpact(in vec3 pos, in vec3 ray, in vec3 O, in float R, inout vec3 norm ){
    float d=0., t = INFINI;
    vec3 a = O - pos;
    float b = dot(a, ray);
    
    if (b >= 0.){	// check if object in frontside first (not behind screen)
        float c = dot(a,a) - R*R;
    	d = b*b - c;
    	if (d >= 0.){
        	float sd = sqrt(d);
            t = b - sd;
            if (t < 0.001) b + sd;
            norm = normalize(pos + t*ray - O);
        }
    }
    
    // The depth reach by the ray depends on the discriminant d.
    // The depth vary from 0 to large value. We consider transparency factor is d when 0.<d<1.
    // As AA concern only 1 or 2 pixels, we have to convert d related to 1 pixel.
    // if object is far, 1 pixel can represent a large amount of sphere radius
    // d must go from 0 to 1 in a pixel size.
    d = max(0.,d);
    return vec2(t, d*iResolution.x/R);
}

// Function 2909
float isectPlane(vec3 n, float d, vec3 org, vec3 dir)
{
    float t = -(dot(org, n) + d) / dot(dir, n);

    return t;
}

// Function 2910
float obj_box(vec3 p, vec3 center, vec3 size, float roundness){
    vec3 d = abs(p-center)-size;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - roundness;
}

// Function 2911
float sdTorusYX( const vec3 p, const vec2 t ) {
  vec2 q = vec2(length(p.yx)-t.x,p.z);
  return length(q)-t.y;
}

// Function 2912
vec2 activeSphereGrid(float t) {
  vec2 p = randomInUnitDisk(vec2(floor(t),.5));
  return floor(p * 8.5 + 1.75*normalize(p));
}

// Function 2913
float iSphere(vec2 ro, vec2 rd, vec2 cPos, float r){

    vec2 O_C = ro-cPos;
    
    float a = dot(rd,rd);
    float b = 2.*dot(rd,O_C);
    float c = dot(O_C,O_C) - r*r;
    
    float disc = b*b-4.*a*c;
    
    if(disc < 0.) return -1.;
    
    //I finally forgot brackets around the numerator
    //it finally happened
    //it's the things that I did yesterday that are hurting me today

    float t1 = (-b - sqrt(disc))/(2.*a); 
    float t2 = (-b + sqrt(disc))/(2.*a);
    
    if(t1 >= 0.){return t1;}
    else if(t2 >= 0.){return t2;}
    else return -1.;
}

// Function 2914
float sBox(in vec2 p, in vec2 b){
   
    vec2 d = abs(p) - b;
    return min(max(d.x, d.y), 0.) + length(max(d, 0.));
}

// Function 2915
float sdTorusJ(vec3 p, vec2 t)
{
	
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  float d = length(q)-t.y;

	if (p.y > 0.0) {
		d = max(d, p.y);
	}
	return d;
}

// Function 2916
float sdSphere(vec3 p, float r) {
	return length(p) - r;
}

// Function 2917
float Sphere( vec3 p, float s )
{
    return length( p ) - s;
}

// Function 2918
float sdCylinder( vec3 p, float r )
{
  return length(p.xz) - r;
}

// Function 2919
float backplane  (vec3 pos){return -pos.z+2.0;}

// Function 2920
HyperPlane pointAndNormToHyperPlane ( in vec4 _p, in vec4 _n )
{
    return HyperPlane ( _n , -dot(_p,_n) );
}

// Function 2921
float plane (vec3 o, vec3 d) {
    // y = p plane
    float p = -RADIUS - abs(sin(iTime*2.0))*0.25;
    float t = (p-o.y) / d.y;
    if (t < 0.0) return INF;
    return t;
}

// Function 2922
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {
    float up = -1.0;
    float down = -1.5;
    float t = (up - pos.y) / dir.y;
    float r = CYLINDER_RADIUS;
    if (t < 0.0) {
        return INF;
    } 
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) < r*r){  
        normal = vec3(0, 1, 0);
        return t;
    }    
    
    float a = dot(dir.xz, dir.xz);
    float b = dot(pos.xz, dir.xz);
    float D = b * b - (dot(pos.xz, pos.xz) - r*r) * a;
    if (D < 0.0) {
        return INF;
    }
    t = (-b - sqrt(D)) / a;
    worldPos = t * dir + pos;
    if ((worldPos.y >= down) && (worldPos.y < up) && (t > 0.0)) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }

    t = (-b + sqrt(D)) / a;
    worldPos = t * dir + pos;
    if ((worldPos.y >= down) && (worldPos.y < up) && (t > 0.0)) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }    
    
    return INF;
}

// Function 2923
float plane(vec2 p,vec2 pos)
{
    p-=pos;
    float d0=segment(p,vec2(0.0,0.15),vec2(0.0,0.0));
    d0=smoothstep(0.01,0.015,d0);
    float d1=segment(p,vec2(-0.1,0.115),vec2(0.1,0.115));
    d1=smoothstep(0.01,0.015,d1);
    float d2=segment(p,vec2(-0.035,0.0),vec2(0.035,0.0));
    d2=smoothstep(0.01,0.015,d2);
    float d=min(d0,d1);
    d=min(d,d2);
    return d;
}

// Function 2924
float box(vec2 u,vec2 w,vec2 v){return ma(abs(u-w)-v);}

// Function 2925
vec3 pointOnSphere(vec2 r) {
    r=vec2(6.283185*r.x,2.*r.y-1.);
    return vec3(sqrt(Epsilon-r.y*r.y)*vec2(cos(r.x),sin(r.x)),r.y); // 1.001 required to avoid NaN
}

// Function 2926
float dBox(vec3 p,vec3 c,vec3 s,float r){vec3 d=abs(p-c)-(s-r);
 return min(max(d.x,max(d.y,d.z)),.0)+length(max(d,.0))-r;}

// Function 2927
float cylinderZ(vec4 ray,vec3 pos, float radius, float height)
{
    maxGISize = max(maxGISize,height*radius*ray.w);
    
    return ray.w*(max(length(ray.xy-pos.xy) - radius, abs(ray.z-pos.z)-height));
}

// Function 2928
vec3 squareToCosineHemisphere(in vec2 s)
{
    float r = sqrt(s.x);
    vec2 disc = vec2(r * sin(2.0 * PI * s.y), r * cos(2.0 * PI * s.y));
    
    return vec3(disc, sqrt(1.0 - s.x));
}

// Function 2929
float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)
{
    p.x = abs(p.x);
    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

// Function 2930
float doCastSphere( in vec3 p, in vec3 rd )
{
    float b = dot( p, rd );
    float c = dot( p, p ) - 1.0;
    
    float f = b * b - c;
    if( f >= 0.0 )
    {
        return -b - sqrt( f );
    }
    return -1.0;
}

// Function 2931
float sdCylinder( in vec3 p, in vec2 h ) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2932
vec2 intSphere(vec3 ro, vec3 rd, vec3 p, float r) {
    float a = dot(rd,rd);
    float b = 2.*dot(rd,ro-p);
    float c = dot(ro-p,ro-p)-(r*r);
    float d = (b*b)-4.*a*c;
    float l = (-b-sqrt(d))/(2.*a);
    return vec2(l,(l >= 0. && d >= 0.)?0.:-1.);
}

// Function 2933
vec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)
{
	// Derivation for formula:
	//		Let the ray be represented as a point P plus a scalar multiple t of the direction vector v,
	//		The ray can then be expressed as P + vt
	//
	//		The point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r
	//		from the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r
	//
	//		It therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,
	//		(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of
	//		intersection

	// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.
	float a = dot(dir_vector, dir_vector);
	float b = 2.0 * dot(pos_vector, dir_vector);
	float c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;

	// to avoid imaginary number, we will find the absolute value of the discriminant.
	float discriminant = b * b - 4.0 * a*c;
	float abs_discriminant = abs(discriminant);
	float min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);
	float max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);

    // return the two intersections, along with the discriminant to determine if
    // the intersections actually exist.
	return float3(min_dist, max_dist, discriminant);

}

// Function 2934
vec4 cylinder_radialrepeat( vec3 p, float r )
{
	vec2 d = vec2( FAR_CLIP, 0 );

	p *= parms2.w;
	{
		vec3 dp = p; //vec3( dp2d.x, p.y, dp2d.y );

		dp.zx = rot2d( dp.xz, 0.3*iTime );
		vec2 ds = sdHalfCircle( dp );

		dp.xy = rot2d( dp.xy, -0.7 * iTime );
		ds = sel_min ( ds, sdHalfCircle( dp.xyz*1.3 ) );

		dp.xz = rot2d( dp.xz, 1.1*iTime );
		ds = sel_min ( ds, sdHalfCircle( dp.xyz*1.8 ) );

		dp.xz = rot2d( dp.xz, -1.3*iTime );
		ds = sel_min ( ds, sdHalfCircle( dp.xyz*2.8 ) );

		d = sel_min( d, ds );
	}

	return vec4( d, vec2(0,0) );
}

// Function 2935
vec3 sphereProject(vec2 plane)
{
    vec3 r;
    plane.x -= 0.55;
    plane.y -= 0.35;
    float denom = (1.0 + plane.x*plane.x + plane.y*plane.y);
    r.x = (2.0*plane.x)/denom;    
    r.y = (2.0*plane.y)/denom;
    r.z = (1.0 - plane.x*plane.x+plane.y*plane.y)/denom;
    return r*1.2;
}

// Function 2936
vec3 getPlaneNormal(vec3 hitPoint,Plane p){
	return normalize(hitPoint+p.normal);
}

// Function 2937
float sdSphere( vec3 p, float s )
{

		float modValue = snoise( vec4( 1.0 * normalize( p ), 0.2 * iTime ) );
    return length( p ) - ( s + 0.5 * modValue );
		// return length( p ) - s;
}

// Function 2938
bool intersectHyperplane(vec3 rayPosition, vec3 rayDirection, out float t)
{
    t = -rayPosition[2] / rayDirection[2];

    return t > 0.0 && !isinf(t);
}

// Function 2939
float get_angular_radius_of_sphere_at_distance_alternate(
	in float sphere_radius, in float sphere_distance
){
	float r = sphere_radius;
	float h = sphere_distance;
	// "a2": squared distance to the tangent point, found using pythagorean theorem, 
	// scaled so hypoteneuse = 1
	float a2 = 1.0-r*r/(h*h);
	return r * sqrt(a2) / (h * a2);
}

// Function 2940
vec3 map_box_pm(vec3 ro, float d) {
    return vec3(0.);
}

// Function 2941
float IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {
    vec3 Z = ro-sc;
    float B = 2.0 * dot(rd, Z);
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;
    float D = B*B - 4.0*C;
    float t = -1.0;
    float d = -1.0;
    if(D>=0.0) {
        if(C>0.0) {
            d = (-B-sqrt(D))/2.0;
        }else{
            d = (-B+sqrt(D))/2.0;
        }
    }
    return d;
}

// Function 2942
float sdTorus(vec3 p, vec2 t) 
{
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 2943
float sdTorus( vec3 p, vec2 t ){
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 2944
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	float rz = sqrt(1.-r.y);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    return normalize(rr);
}

// Function 2945
vec4 Cone(vec3 pos, vec3 dir, float ConeRatio) {
    float dist=IRES+IRES*0.7*noise(pos);
    float sD,sL,sW; vec3 sP; vec4 sC;
    vec4 Col=vec4(0.,0.,0.,0.);
//Tracing
    for (int i=0; i<32; i++) {
        sD=max(IRES,dist*ConeRatio);
    	sP=pos+dir*dist;
        sL=log2(sD*RES);
        sC=VoxelFetch(sP,sL);
        sW=1.-Col.w;
        Col=Col+sC*sW;//pow(sW,2.);
        dist=dist+sD;
    }
    return Col;
}

// Function 2946
float intersectPlane(vec3 ro, vec3 rd, vec3 nor, float dist) {
  float denom = dot(rd, nor);
  float t = -(dot(ro, nor) + dist) / denom;

  return t;
}

// Function 2947
float getLightSphere(vec3 p, Sphere sphere) {
    vec3 lightPos = vec3(-sin(iTime), 20.0 * sin(cos(iTime)), -cos(iTime));
    
    vec3 l = normalize(lightPos - p);
    vec3 n = getNormalSphere(p, sphere);
    
    float dif = dot(n, l);
    float d = rayMarch(Ray(p + n*SURFACE_DIST*2., l), sphere);
    
    if (d < length(lightPos - p)) {
        dif *= .1;
    }
    
    return dif;
}

// Function 2948
vec4 select_plane_normal(vec4 b) {
    float lc = min(min(b.x, b.y), min(b.z, b.w));
    return step(b, vec4(lc));
}

// Function 2949
float sdBox(vec3 P, vec3 p, vec3 b, float r)
{
  p = P-p;
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

// Function 2950
float sdCylinder( vec3 p, vec3 c )
{
  return length(c.xy - p.xz) - c.z;
}

// Function 2951
bool RaySphere(in Ray r, in Sphere s, out float t0, out float t1)
{
	float3 l=s.p-r.p;
	float tc=dot(l,r.d);
	if(tc<0.0)
	{
		return false;
	};

	float d2=s.r*s.r+tc*tc-dot(l,l);

	if(d2<0.0)
	{
		return false;
	};

	float thc=sqrt(d2);
	t0=tc-thc;
	t1=tc+thc;
	return true;
}

// Function 2952
float sdBox(vec3 p, vec3 b)
{
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2953
float rayboxintersect(ray r, aabb box)
{
    float t1 = (box.min.x - r.pos.x) / r.dir.x;
    float t2 = (box.max.x - r.pos.x) / r.dir.x;
    float t3 = (box.min.y - r.pos.y) / r.dir.y;
    float t4 = (box.max.y - r.pos.y) / r.dir.y;
    float t5 = (box.min.z - r.pos.z) / r.dir.z;
    float t6 = (box.max.z - r.pos.z) / r.dir.z;

    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));

    if (tmax < 0.0) // box on ray but behind ray origin
    {
        return MAXDIST;
    }

    if (tmin > tmax) // ray doesn't intersect box
    {
        return MAXDIST;
    }

    return tmin;
}

// Function 2954
float boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {
    vec3 tMin=(bmin-origin)*dir;
    vec3 tMax=(bmax-origin)*dir;
    vec3 t2=max(tMin,tMax);
    return min(min(t2.x,t2.y),t2.z);
}

// Function 2955
RayTraceResult RayTraceCylinder(in Ray ray, vec3 pos, float radius, float height)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
    //< Credits : [0]iq
    // intersect capped cylinder		
    vec3  ce = vec3( pos.x, 0.0, pos.z );
    vec3  rc = ray.org - ce;
    float a = dot( ray.dir.xz, ray.dir.xz );
    float b = dot( rc.xz, ray.dir.xz );
    float c = dot( rc.xz, rc.xz ) - radius;
    float h = b*b - a*c;
    if( h>=0.0 )
    {
        // cylinder			
        float t = (-b - sqrt( h ))/a;
        if( t>0.0 && (ray.org.y+t*ray.dir.y)<height )
        {
            res.t = t;
            res.pos = ray.org + ray.dir*t;
            res.nn = normalize(vec3(ce.x - res.pos.x, 0., ce.z - res.pos.z));
        }
        // cap			
        t = (height - ray.org.y)/ray.dir.y;
        if( t>0.0 && (t*t*a+2.0*t*b+c)<0.0 )
        {
            res.t = t;
            res.pos = ray.org + ray.dir*t;
            res.nn = vec3(0., 1., 0.);
        }
    }
    
    return res;
}

// Function 2956
bool intersectPlane( vec3 normal, Material m, Ray ray, out Intersection hit ) {
	float len = -dot(ray.origin, normal) / dot(ray.direction, normal);
    if (len < 0.0) return false;
    hit = Intersection(len, ray.origin + len * ray.direction, normal, m);
    return true;
}

// Function 2957
vec2 boxIntersect(vec3 ro, vec3 rd, vec3 rad)  {
    vec3 m = 1.0 / rd;
    vec3 n = m * ro;
    vec3 k = abs(m) * rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max(max(t1.x, t1.y), t1.z);
    float tF = min(min(t2.x, t2.y), t2.z);
	
    if(tN > tF || tF < 0.0)
        return vec2(-1.0); // no intersection
    return vec2(tN, tF);
}

// Function 2958
vec3 skybox(vec3 nvDir) {
    float sep = -0.15;
    float blend = 0.025;
    return mix(
        mix(vec3(1.0), vec3(0.8, 0.45, 0.25), unmix(-1.0, sep, nvDir.x)),
        mix(vec3(1.0), vec3(0.7, 0.6, 1.0), unmix(sep, 1.0, nvDir.x)),
        smoothstep(sep-blend, sep+blend, nvDir.x)
    );
}

// Function 2959
float intersect_plane(ray_ ray, plane_ plane, inout vec4 color)
{
	float t = dot((plane.p - ray.origin), plane.normal) / dot(plane.normal, ray.dir);
	if(t > 0.0){
		vec3 intersect = ray.dir * t + ray.origin;
		if (abs(mod(floor(intersect.x * 0.1) + floor(intersect.z * 0.1), 2.0)) < 1.0){
			color = vec4(vec3(0.0), 1.0);
		}else{
			color = vec4(vec3(1.0), 1.0);
		}
		float reflectiveness = 0.25;
		color *= (1.0 - reflectiveness);
		ray_ r = ray_(intersect, normalize(ray.dir - 2.0 * dot(ray.dir, plane.normal) * plane.normal));

		vec4 c = vec4(0.0);
		float hit = 0.0;
		hit = intersect_sphere(r, sp1, c);
		color += reflectiveness * c * hit;

		// hit = intersect_sphere(r, sp2, c);
		// color += reflectiveness * c * hit;
		return 1.0;
	}
	return 0.0;
}

// Function 2960
float sdSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
  vec3 oc = ro - sph.xyz;
  float b = dot (oc, rd);
  float c = dot (oc, oc) - sph.w*sph.w;
  float h = b*b - c;
  if (h<0.0) return -1.0;
  return -b -sqrt(h);
}

// Function 2961
vec2 sphereMap(vec3 pos, float rad)
{
    return vec2(atan(pos.z, pos.x), acos(pos.y / rad));
}

// Function 2962
vec3 sampleHemisphere(float u1, float u2, vec3 normal)
{
	vec3 u = normal;
	vec3 v = abs(u.y) < abs(u.z) ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);
	vec3 w = normalize(cross(u, v));
	v = cross(w, u);

	float r = sqrt(u1);
	float theta = 2.0 * 3.1415926535 * u2;
	float x = r * cos(theta);
	float y = r * sin(theta);
	return normalize(u * sqrt(1.0 - u1) + v * x + w * y);
}

// Function 2963
float hitBox(vec3 ro, vec3 rd, vec3 box0, vec3 box1, float minMax) {
	vec3 pos0 = (box0 - ro) / rd;
	vec3 pos1 = (box1 - ro) / rd;
	float tmin = max3(min(pos0, pos1));
	float tmax = min3(max(pos0, pos1));
    
    float t = (bool(minMax))? tmax : tmin;
	return (tmin < tmax && tmax > 0.0)? t : -1.0;
}

// Function 2964
float intersectSphere(Ray r,Sphere s){
    vec3 oc=r.origin-s.center;
    vec3 t=r.direction;
	float a=dot(t,t);
    float b=2.0*dot(t,oc);
    float c=dot(oc,oc)-s.radius*s.radius;
    float discriminant=b*b-4.0*a*c;
    if (discriminant<=0.0)
        return -1.0;
    else
    {
    	float x1=(-b-sqrt(discriminant))/(2.0*a);
        if(x1>T_MIN&&x1<T_MAX)
        	return x1;
        x1=(-b+sqrt(discriminant))/(2.0*a);
         if(x1>T_MIN&&x1<T_MAX)
        	return x1;
    }
}

// Function 2965
float sphere_sdf(in highp vec3 point) {
    vec3 sphere_center =
        vec3(0.9 * sin(0.6 * iTime),
             0.9 * cos(1.1 * iTime),
             -1.0);
	return length(point - sphere_center) - sphere_rad;
}

// Function 2966
float sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }

// Function 2967
float sphere(vec3 p, float radius)
{
  return length(p)-radius;
}

// Function 2968
float boxfilter( float x, float min, float max )
{
	if( x < min || x > max )
		return 0.0;
	else
		return x;
}

// Function 2969
vec3 sample_uniform_hemisphere(in vec3 N,float x1, float x2, out float pdf){
	float z = x1;
	float r = sqrt(max(0., 1. - z*z));
	float phi = M_2PI_F * x2;
	float x = r * cos(phi);
	float y = r * sin(phi);
	vec3 T, B;
	frisvad (N, T, B);
	pdf = 0.5 * M_1_PI_F;
    return x * T + y * B + z * N;
}

// Function 2970
void get_bbox(const std::vector<vec3>& pts, vec3& bbox_min, vec3& bbox_max) {
    bbox_min = pts[0]; bbox_max = pts[0];
    for(int i=1; i<pts.size(); ++i) {
	bbox_min = min(bbox_min, pts[i]); bbox_max = max(bbox_max, pts[i]);	
    }
}

// Function 2971
float sdCylinderZ(vec3 p, vec3 c)
{
  return length(p.xy-c.xy)-c.z;
}

// Function 2972
surface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {
    return surface_t(
        id,
        length(query_point)  - sphere_radius,
        normalize(query_point)
    );
}

// Function 2973
float sdBox(vec3 p,vec3 b)
{
  vec3 d=abs(p)-b;
  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 2974
DAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}

// Function 2975
float sdf_sbox(in vec3 p, in vec3 l)
{
  vec3 d = abs(p) - l;
  return min(max(d.x, max(d.y, d.z)), length(max(d, 0.0)));
}

// Function 2976
float smoothCylinderDistance(vec3 point, float height, float radius, float smoothing) {
    return cylinderDistance(point, height - smoothing, radius - smoothing) - smoothing;
}

// Function 2977
float
torus82_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length(p.xy)-torus.x,p.z);
    return length8(q)-torus.y;
}

// Function 2978
float DistBox(in vec3 p, in vec3 dimensions)
{
	return length(max(abs(p) - dimensions,0.0)); 
}

// Function 2979
vec2 intersect_plane(vec3 ro,
                     vec3 rd,
                     vec3 pn,
                     vec3 po)
{
    float rddotpn = dot(rd, pn);
    // if the ray direction is parallel to the plane, let's just treat the 
    // ray as intersecting *really* far off, which will get culled as a
    // possible intersection.

    float denom = ztsign(rddotpn) * max(abs(rddotpn), SMALL_FLOAT);
    float t = min(BIG_FLOAT, -dot(pn, (ro - po)) / denom);    
    return vec2(step(SMALL_FLOAT, t), t);
}

// Function 2980
void initializeCornelBox()
{
    
    
    // Primitive initialization
	floorSquare.transform.trans = vec3(0, -2.5, 0);
	floorSquare.transform.rotate = vec3(-90, 0, 0);
	floorSquare.transform.scale = vec3(10, 10, 1);
    floorSquare.primitiveId = SQUARE_PLANE;
    floorSquare.matColor = vec3(0.85, 0.81, 0.78);
    primitives[0] = floorSquare;
    
    redWall.transform.trans = vec3(5, 2.5, 0);
	redWall.transform.rotate = vec3(0, -90, 0);
	redWall.transform.scale = vec3(10, 10, 1);
    redWall.primitiveId = SQUARE_PLANE;
    redWall.matColor = vec3(0.63, 0.065, 0.05);
    primitives[1] = redWall;
    
    greenWall.transform.trans = vec3(-5, 2.5, 0);
    greenWall.transform.rotate = vec3(0, 90, 0);
	greenWall.transform.scale = vec3(10, 10, 1);
    greenWall.primitiveId = SQUARE_PLANE;
    greenWall.matColor = vec3(0.14, 0.45, 0.091);
    primitives[2] = greenWall;
    
    backWall.transform.trans = vec3(0, 2.5, 5);
    backWall.transform.rotate = vec3(0, 180,  0);
	backWall.transform.scale = vec3(10, 10, 1);
    backWall.primitiveId = SQUARE_PLANE;
    backWall.matColor = vec3(0.85, 0.81, 0.78);
    primitives[3] = backWall;
    
    ceilingWall.transform.trans = vec3(0, 7.5, 0);
    ceilingWall.transform.rotate = vec3(90, 0, 0);
	ceilingWall.transform.scale = vec3(10, 10, 1);
    ceilingWall.primitiveId = SQUARE_PLANE;
    ceilingWall.matColor = vec3(0.85, 0.81, 0.78);
    primitives[4] = ceilingWall;
    
    shortCube.transform.trans = vec3(-2, -1, 0.75);
    shortCube.transform.rotate = vec3(0, -17.5, 0);
	shortCube.transform.scale = vec3(3, 3, 3);
    shortCube.primitiveId = CUBE;
    shortCube.matColor = vec3(0.85, 0.81, 0.78);
    primitives[5] = shortCube;
    
    longCube.transform.trans = vec3(2, 0, 3);
    longCube.transform.rotate = vec3(0, 27.5, 0);
	longCube.transform.scale = vec3(3, 6, 3);
    longCube.primitiveId = CUBE;
    longCube.matColor = vec3(0.85, 0.81, 0.78);
    primitives[6] = longCube;
    
 
    
    // Light initlaization
    pointLight.id = 0;
    pointLight.typeId = POINT_LIGHT;
    pointLight.intensity = 2.0;
    pointLight.lightColor = vec3(17, 12, 4);
    pointLight.transform.trans = vec3(0, 7.0, -2.0);
    pointLight.transform.rotate = vec3(90, 0, 0);
    pointLight.transform.scale = vec3(3, 3, 1);
    
    return;
}

// Function 2981
float mBox(vec3 p, vec3 b)
{
	return max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);
}

// Function 2982
float sphere(ray r, sph s, float n){//sphere ray intersection
	vec3 rc = r.ro-s.c;
	float c = dot(rc, rc) - (s.r*s.r);
	float b = dot(r.rd, rc);
	float d = b*b - c;
	float t = -b - n*sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return max(0.,mix(-1., t, st));
}

// Function 2983
vec2 sphere ( vec3 ray ) 
{
    vec3 orig = vec3( 0. , 0. , -3.0 );
    vec3 dist = ray - orig;
    dist *= rotateY( iTime );
    float noise = noise3( ray ) * sin( iTime ) + sin( iTime / 2.0 );
    dist += noise;
    float radius = 1.1;
   	float le = length( dist ) - radius;
    
    float id = 1.;
    
	return vec2( le, id );
}

// Function 2984
float distCylinderXY(vec3 p, vec3 c)
{
    return length(p.xy - c.xy) - c.z;
}

// Function 2985
float sdRoundBox( vec3 p, vec3 b, float r )
{
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

// Function 2986
bool sphere_raycast(sphere_t sphere, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)
{
	vec3 o = orig;
	vec3 d = dir;
	vec3 c = sphere.p;
	float r = sphere.radius;
    float rsq = r * r;
    mat3 rot_mat = sphere.r;
	
	bool isinside = false;

    vec3 o2c = c - o;
    float distsq = dot(o2c, o2c);
    float o2cdp = dot(o2c, d);
    float c2raysq = max(0., distsq - o2cdp * o2cdp);
    if(c2raysq > rsq) return false;
    float foo = sqrt(rsq - c2raysq);
    float dist1 = o2cdp - foo;
    float dist2 = o2cdp + foo;
    if(distsq < rsq) isinside = true;
	if(isinside && !isfrominside) return false;

    if(isinside || isfrominside) intersect_dist = dist2;
    else intersect_dist = dist1;
    
    if(!isfrominside && intersect_dist < 0.) return false;
    
	castpoint = o + d * intersect_dist;
    vec3 nor = (castpoint - c) / r;
    normal = nor;
    if(isfrominside) normal = -normal;
	isfrominside = isinside;
	
    vec3 uvn = nor * rot_mat;
	uv.x = (atan(uvn.z, uvn.x) / PI) * .5 + .5;
	uv.y = (atan(uvn.y, length(uvn.xz)) / PI) * .5 + .5;
    return true;
}

// Function 2987
float PDF_Cone ( float lobe ) {
  if ( lobe < 0.001 ) return 1.0;
  return (TAU*SQR(sin(0.5*lobe)));
}

// Function 2988
bool closestSphereCaps(vec3 cSphere, float rSphere, vec3 pLine1, vec3 pLine2, float ep, out vec3 out0, out vec3 out1) {
    out0 = cSphere; out1 = closestPtSeg(cSphere, pLine1, pLine2);
    return removeThickness(rSphere, ep, out0, out1);
}

// Function 2989
float TorusSD(vec3 position, vec2 dimensions)
{
    vec2 q = vec2(length(position.xz) - dimensions.x, position.y);
    return length(q) - dimensions.y;
}

// Function 2990
float sphere (vec3 p, float r) { return length(p)-r; }

// Function 2991
Hit sphereTrace(in Ray r) {
  Surface s;
  for(int i=0; i<MAX_TRACE_STEP; i++) {
    s = map(_pos(r));
    s.d *= r.sgn;
    r.len += s.d * FUDGE_FACTOR;
    r.stp = float(i);
    if (s.d < TRACE_PRECISION) break;
    if (r.len > MAX_TRACE_DIST) return nohit(r);
  }
  vec3 p = _pos(r);
  float interior = .5-r.sgn*.5;
  s.rr = mix(s.rr, vec3(1), interior);
  s.tc = max(s.tc, interior);
  return Hit(p, _calcNormal(p)*r.sgn, r, s, (len2(s.tc)>.001), (len2(s.rl)>.001));
}

// Function 2992
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	return vec2( tN, tF );
}

// Function 2993
bool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)
{
    vec3 relativeRayPos = rayPos_ - pos;
    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);
    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);
    
    float lengthCorrection = length(projectedRayDir);
    projectedRayDir /= lengthCorrection;
    
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = projectedRayPos;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, projectedRayDir);

	float c = dot(m, m) - radius * radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }

    // adjust distance
    dist /= lengthCorrection;

    // enforce height - note we may be invalid height for the first distance but not the second.
    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;
    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)
    {
        dist = -b + sqrt(discr);
        dist /= lengthCorrection;
        relativeHitPos = relativeRayPos + rayDir_ * dist;
        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)
      		return false;
    }
        
	if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.hitAnObject = true;
        info.rayMarchedObject = false;
        info.dist = dist;        
        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);
		info.material = material;        
        return true;
    }
    
    return false;
}

// Function 2994
float torus2(vec4 p, vec2 r) {//creates 4 toruses
    return length(vec3(abs(length(p.xy)-r.x),p.zw))-r.y;
}

// Function 2995
float sdTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

// Function 2996
bool RayIntersectAABoxNormal (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)
{
    vec3 boxCenter = (boxMin+boxMax)*0.5;
	vec3 roo = rayPos - boxCenter;
    vec3 rad = (boxMax - boxMin)*0.5;

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
    
    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)
    if (time.x > maxTime)
        return false;
    
    // if time invalid or we hit from inside, bail out
    if (time.y < time.x || time.x < 0.0)
        return false;
	
    // calculate surface normal
    hitPos = rayPos + rayDir * time.x;   
    vec3 hitPosRelative = hitPos - boxCenter;
    vec3 hitPosRelativeAbs = abs(hitPosRelative);
    vec3 distToEdge = abs(hitPosRelativeAbs - rad);

    float closestDist = 1000.0;
    for(int axis = 0; axis < 3; ++axis)
    {
        if (distToEdge[axis] < closestDist)
        {
            closestDist = distToEdge[axis];
            normal = vec3(0.0);
            if (hitPosRelative[axis] < 0.0)
                normal[axis] = -1.0;
            else
                normal[axis] = 1.0;
        }
    }        

    // store the collision time as the new max time
    maxTime = time.x;
    return true;
}

// Function 2997
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
    
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( abs(1.0-r.y) );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize(rr);
}

// Function 2998
float Box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 2999
vec4 decor_ui_box(int idx) {
    
    return vec4(inset_ctr.x + (float(idx)-1.5)*text_size*1.1,
                dfunc_y - 2.5*text_size,
                vec2(0.45*text_size));
    
}

// Function 3000
vec2 cylinder(vec3 pos,vec2 h,float id){

	vec2 d = abs(vec2(length(pos.xz),pos.y)) - h;
	
	return vec2(min(max(d.x,d.y),0.0) + length(max(d,0.0)),id);
}

// Function 3001
float sdfBox2d(vec2 p, vec2 b) {
  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 3002
vec2 iConeY(in vec3 ro, in vec3 rd, in float k )
{
	float a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;
    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;
    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; 
        
    float h = b*b-a*c;
    if( h<0.0 ) return vec2(-1.0);
    h = sqrt(h);
    return vec2(-b-h,-b+h)/a;
}

// Function 3003
bool intersects_sphere(in ray_t ray, in sphere_t sphere, inout float t0, inout float t1){
    vec3 rc = sphere.origin - ray.origin;
	float radius2 = sphere.radius * sphere.radius;
	float tca = dot(rc, ray.direction);
	float d2 = dot(rc, rc) - tca * tca;
	if (d2 > radius2) return false;
	float thc = sqrt(radius2 - d2);
	t0 = tca - thc;
	t1 = tca + thc;
	return true;
}

// Function 3004
bool RayIntersectSphere (in SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 3005
float torus( vec3 p, vec2 t ) {
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  return length(q)-t.y;
}

// Function 3006
float sdDuoCylinder( vec4 p, vec2 r1r2) {
  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;
  return min(max(d.x,d.y),0.) + length(max(d,0.));
}

// Function 3007
vec4 moduloUvPlanes(vec3 orig, vec3 ray, vec2 dist)
{
    return vec4(fract(orig.xy + ray.xy * dist.x), fract(orig.xy + ray.xy * dist.y));
}

// Function 3008
float Cylinder(vec3 p, vec2 h)        { vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }

// Function 3009
float sdConeSection( vec3 p, float h, float r1, float r2 )
{
  float d1 = -p.z - h;
  float q = p.z - h;
  float si = 0.5*(r1-r2)/h;
  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );
  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);
}

// Function 3010
float fCone(vec3 p, float angle) {
    vec2 c = vec2(length(p.xz), p.y);
    pR(c, angle);
    return length(max(c, vec2(0))) + vmax(min(c, vec2(0)));
}

// Function 3011
float fPlane(vec3 p, vec3 a, vec3 b, vec3 c, vec3 inside, float distanceFromOrigin) {
    vec3 n = normalize(cross(c - b, a - b));
    float d = -dot(a, n);
    
    if (dot(n, inside) + d > 0.) {
        n = -n;
        d = -d;
    }

    return fPlane(p, n, d + distanceFromOrigin);
}

// Function 3012
vec3 getspherecolor(vec3 p) {
  uint index = uint(p.x<0.0)+(uint(p.y<0.0)<<1)+(uint(p.z<0.0)<<2);
  p = abs(p);
  p /= dot(p,vec3(1));
  vec2 z = p.xy;
  float E = 10.0;
  float t = 0.5*iTime;
  uint epoch = uint((t+0.5*E+1.0)/(E+2.0));
  t = mod(t,E+2.0)-1.0;
  t = max(t,0.0);
  if (t > 0.5*E) t = max(0.5*E,t-1.0);
  t = min(t,E-t); // t < 0.5*E
  randseed = ihash(epoch^index+1U); // 0 hashes to 0!
  vec3 col = hsv2rgb(vec3(rand(),0.8,1));
  for (int i = 0; i < depth; i++) {
    int j;
    if  (z.x > 0.5) { j = 0; z = 2.0*vec2(z.x-0.5,z.y); }
    else if (z.y > 0.5) { j = 1; z = 2.0*vec2(z.x,z.y-0.5); }
    else if (z.x + z.y < 0.5) { j = 2; z = 2.0*z; }
    else { j = 3; z = 0.5-z; }
    if (i > 0 && j == 3 && (gasketonly || rand() < 2.0*t/E)) return vec3(0);
    index = (index << 2) + uint(j);
    randseed = ihash(epoch^index+1U); // 0 hashes to 0!
    if (rand() < pcolorchange) col = hsv2rgb(vec3(rand(),0.8,1));
  }
  return docolor ? col : vec3(0.8);
}

// Function 3013
float sphereSDF(vec3 p) {
    return length(p) - 1.0 - (uv(p, normalize(p), iChannel1).r * 0.1);
}

// Function 3014
float torus(vec3 p, vec2 di) {
  vec2 crd = vec2(length(p.xy), p.z);
  return length(crd-vec2(di.x,0)) - di.y;
}

// Function 3015
float fBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// Function 3016
float sphereDist2(vec3 a, vec3 b) {
	// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2
    return 2.0-2.0*dot(normalize(a),normalize(b));
}

// Function 3017
vec3 WorldPosToBlobSpherePos( vec3 pos )
{
    pos -= BLOB_ORIGIN;
    // tilt slightly
    pos.y -= pos.x * 0.1;
    pos *= BLOB_SCALE;
    return pos;
}

// Function 3018
float ConeTraceDist(vec3 beam_origin, vec3 beam_dir, float beam_radius, float iTime)
{
    float dist = 0.;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        float cap_radius = dist * beam_radius;
        
        vec3 p = beam_origin + beam_dir * dist;
        
        float nearest = GetSceneDist(p, iTime);

        if (nearest <= cap_radius)
        	break;

        dist += nearest - cap_radius;

        if (dist > MAX_DIST)
            break;
    }
    
    return dist;
}

// Function 3019
float box( vec3 p, vec3 b )
{
    vec3 d = abs( p ) - b;
    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );
}

// Function 3020
float sphere1(vec3 u){
;vec3 s=vec3(0,0,8);//(vec3(0.0,cos(iTime),8.0+0.5*sin(iTime)))
;return (length(repeat(u)-s)-1.5);
}

// Function 3021
float boxDist(vec2 p, vec2 size, float radius)
{
	size -= vec2(radius);
	vec2 d = abs(p) - size;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

// Function 3022
float rayBox(in Ray r, in Shape s, out vec3 p, out vec3 n)
{
    float resultMin = -huge;
    float resultMax = +huge;

    float txmin, txmax, tymin, tymax, tzmin, tzmax;
    
    vec3 boxmin = s.c - 0.5 * s.dim;
    vec3 boxmax = s.c + 0.5 * s.dim;

    float divx = 1.0 / r.d.x;
    if (divx >= 0.0)
    {
        txmin = (boxmin.x - r.o.x) * divx;
        txmax = (boxmax.x - r.o.x) * divx;
    }
    else
    {
        txmin = (boxmax.x - r.o.x) * divx;
        txmax = (boxmin.x - r.o.x) * divx;
    }

    if (txmin > resultMin)
        resultMin = txmin;
    
    if (txmax < resultMax)
        resultMax = txmax;

    float divy = 1.0 / r.d.y;
    if (divy >= 0.0)
    {
        tymin = (boxmin.y - r.o.y) * divy;
        tymax = (boxmax.y - r.o.y) * divy;
    }
    else
    {
        tymin = (boxmax.y - r.o.y) * divy;
        tymax = (boxmin.y - r.o.y) * divy;
    }
    
    if ((resultMin > tymax) || (tymin > resultMax))
        return -1.0;

    if (tymin > resultMin)
        resultMin = tymin;
    
    if (tymax < resultMax)
        resultMax = tymax;

    float divz = 1.0 / r.d.z;
    if (divz >= 0.0)
    {
        tzmin = (boxmin.z - r.o.z) * divz;
        tzmax = (boxmax.z - r.o.z) * divz;
    }
    else
    {
        tzmin = (boxmax.z - r.o.z) * divz;
        tzmax = (boxmin.z - r.o.z) * divz;
    }

    if ((resultMin > tzmax) || (tzmin > resultMax))
        return -1.0;
    
    if (tzmin > resultMin)
        resultMin = tzmin;
    
    if (tzmax < resultMax)
        resultMax = tzmax;
    
    float t = min(resultMin, resultMax);
    p = r.o + r.d * t;
	
    n = vec3(0.0);
    if (abs(p.x - boxmin.x) < epsilon) n = vec3(-1.0, 0.0, 0.0);
    if (abs(p.y - boxmin.y) < epsilon) n = vec3(0.0, -1.0, 0.0);
    if (abs(p.z - boxmin.z) < epsilon) n = vec3(0.0, 0.0, -1.0);
    if (abs(p.x - boxmax.x) < epsilon) n = vec3(+1.0, 0.0, 0.0);
    if (abs(p.y - boxmax.y) < epsilon) n = vec3(0.0, +1.0, 0.0);
    if (abs(p.z - boxmax.z) < epsilon) n = vec3(0.0, 0.0, +1.0);
    return t;
}

// Function 3023
float intersectRaySphere(vec3 ray, vec3 dir, vec3 center, float radius)
{
	vec3 rc = ray-center;
	float c = dot(rc, rc) - (radius*radius);
	float b = dot(dir, rc);
	float d = b*b - c;
	float t = -b - sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return mix(-1.0, t, st);
}

// Function 3024
float dBlackholePlane(vec3 ro, vec3 rd, vec3 n){return -dot(ro, n)/dot(rd, n);}

// Function 3025
float sdSphere (vec3 p, float s)
{
	return length(p)-s;
}

// Function 3026
float sphere(vec3 p, vec3 o)
{
	return 1.0 - distance(p, o);
}

// Function 3027
float3 Sample_Uniform_Cone ( float lobe, out float pdf, inout float seed ) {
  float2 u = Sample_Uniform2(seed);
  float phi = TAU*u.x,
        cos_theta = 1.0 - u.y*(1.0 - cos(lobe));
  pdf = PDF_Cone(lobe);
  return To_Cartesian(cos_theta, phi);
}

// Function 3028
float	SphereFlakeShadowStack( in vec3 ro, in vec3 rd )
{
    float	result	= 1.0;

    int	idx	= 1;
// Get current element on the stack.
#define	SFEL g_stack[ idx ] 
// Get parent element on the stack
#define	SFPEL g_stack[ idx - 1 ]
// Get parent's parent element on the stack
#define	SFPPEL g_stack[ idx - 2 ]
// Do sphere intersect call on the current element on the stack.
#define SFShadow sphSoftShadow( ro, rd, SFEL.center, SFEL.radius, result )
// Do sphere intersect test call on the current element on the stack.
#define SFIntersectTest sphIntersectTest( ro, rd, SFEL.center, SFEL.radius )
// Check if current element on the stack has a small radius.
#define SFIsRadTooSmall isRadTooSmall( ro, SFEL.center, SFEL.radius )

    if( ! SFIntersectTest )
        return	result;

    SFShadow;

    idx = 2;
    while( idx > 1 )
    {
        if( SFEL.sphereIndex == TOTAL_SPHERES_COUNT )
        {
            SFEL.sphereIndex	= 0;
            idx--;
            continue;
        }

        vec3	perp1	= normalize( cross( SFPEL.direction, SFPPEL.direction ) );
        vec3	perp2	= normalize( cross( SFPEL.direction, perp1 ) );

        vec3	rot		= perp1 * PERP1MOD( SFEL.sphereIndex ) 
            			+ perp2 * PERP2MOD( SFEL.sphereIndex );

        vec3	dirNN	= SFPEL.direction * YAXIS_COS( SFEL.sphereIndex )
            			+ rot;
        
        SFEL.direction	= normalize( dirNN );
        SFEL.center		= SFEL.direction * ( SFEL.radius + SFPEL.radius ) 
            			+ SFPEL.center;

        SFEL.sphereIndex++;
        
        if( SFIsRadTooSmall || ! SFIntersectTest )
            continue;

        SFShadow;

        if( idx == STACK_MAX_SIZE )
            continue;

		idx++;
    }
    
    return	result;
}

// Function 3029
bool intersectHypersphere(vec4 rayPosition, vec4 rayDirection, out float t)
{
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(rayDirection, rayPosition);
    float c = dot(rayPosition, rayPosition) - 1.0;

    return solveQuadraticIntersection(a, b, c, t);
}

// Function 3030
void ToHalfplane(inout vec2 z){// z -> -iz-i / z-1
    float x=z[0], y=z[1];
    float denom = x*x + y*y + 1. - 2.*x;
    z = vec2(-2.*y, -x*x-y*y+1.) / denom;
}

// Function 3031
vec4 planeDistance(vec3 pos, vec3 center, vec3 normal) {
    vec3 delta = pos - center;
    float dist = dot(delta, normal);
    vec3 surface = pos - normal * dist;
    return vec4(surface, dist);
}

// Function 3032
float sdQuaterBox( vec3 p, vec3 b, vec2 sign )
{
    b.xy *= sqrt(2.0);
	float boxBase = udRoundBox( p * rotZ( 0.25 * 3.14 ), b, 0.01 );
        
    return max( sign.y * p.y, max( sign.x * p.x, boxBase ) );
}

// Function 3033
float shape_box2d(vec2 p, vec2 b) {
  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 3034
float box(vec2 uv, vec4 bounds)
{
	return step(bounds.x, uv.x) *
	       step(bounds.y, 1.0 - uv.x) *
	       step(bounds.z, 1.0 - uv.y) *
	       step(bounds.w, uv.y);
}

// Function 3035
float sdVertTorus( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xy)-t.x,p.z);
  return length(q)-t.y;
}

// Function 3036
float torusDist(vec3 pos, float R, float r)
{
    return length(vec2(length(pos.xy)-R,pos.z))-r;
}

// Function 3037
bool raySphereIntersection( Ray ray, in Sphere sph, out float dist ) {
    float t = -1.0;
	vec3  ce = ray.origin - sph.pos;
	float b = dot( ray.dir, ce );
	float c = dot( ce, ce ) - sph.radiusSq;
	float h = b*b - c;
    if( h > 0.0 ) {
		t = -b - sqrt(h);
	}
    
    if ( t > 0.0 ) {
    	dist = t;
        return true;
    }
	
	return false;
}

// Function 3038
float sdCappedCylinder( vec3 p, float r, float h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,0.5*h);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3039
float
torusmh2_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length(p.xy)-torus.x,p.z);
    return manhattan(q)-torus.y;
}

// Function 3040
float udRoundBox( vec3 p, vec3 b, float r, mat3 m  )
{
  p = m * p; 
  return length(max(abs(p)-b,0.0))-r;
}

// Function 3041
float sphere(vec3 pos){
    return length(pos);
}

// Function 3042
poly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {
#if 1
	return pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);
#else
    poly2 d = pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z));
    return pa_sub(pa_spow2(d),n.w * n.w * sign(n.w));    
#endif
}

// Function 3043
vec3 HemisphereRand( vec3 a, uint seed )
{
    vec3 r = SphereRand(seed);
    return dot(r,a) > .0 ? r : -r;
}

// Function 3044
mat4 rotation_mat4_zw_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
    
    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.
    return mat4(
    	1.0, 0.0, 0.0, 0.0, // x-basis
        0.0, 1.0, 0.0, 0.0, // y-basis
    	0.0, 0.0, cos_theta, sin_theta, // z-basis
        0.0, 0.0, (-1.0 * sin_theta), cos_theta); // w-basis
}

// Function 3045
float round_box( vec3 where, vec3 sizes, float roundness ) {
	return length(max(abs(where)-sizes,0.0))-roundness;
}

// Function 3046
float sdPlane(vec3 p, vec4 n)
{
    return dot(p, n.xyz) + n.w;
}

// Function 3047
float roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )
{
    
	// bounding box
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*(size+rad);
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return -1.0;
    float t = tN;

    // convert to first octant
    vec3 pos = ro+t*rd;
    vec3 s = sign(pos);
    ro  *= s;
    rd  *= s;
    pos *= s;
        
    // faces
    pos -= size;
    pos = max( pos.xyz, pos.yzx );
    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;
  
  	// fat edges
    float d;
    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);
    t = d > 0. ? d : 1e20;
    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);
    t = min(d > 0. ? d : 1e20, t);    
    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);
    t = min(d > 0. ? d : 1e20, t);    

    if( t>1e19 ) t=-1.0;
    
	return t;
}

// Function 3048
bool isinbox(vec2 a,vec2 b,float s){return all(greaterThan(a,b        ))&&all(lessThan(a,b+s));}

// Function 3049
float sdCone( vec3 p, vec3 center, vec2 c, float h )
{
    p = p - center;
  float q = length(p.xz);
  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);
}

// Function 3050
vec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sp, in vec3 ve, out vec3 nor )
{
    float t = -1.0;
	float s = 0.0;
	nor = vec3(0.0);
	
	vec3  rc = ro - sp.xyz;
	float A = dot(rc,rd);
	float B = dot(rc,rc) - sp.w*sp.w;
	float C = dot(ve,ve);
	float D = dot(rc,ve);
	float E = dot(rd,ve);
	float aab = A*A - B;
	float eec = E*E - C;
	float aed = A*E - D;
	float k = aed*aed - eec*aab;
		
	if( k>0.0 )
	{
		k = sqrt(k);
		float hb = (aed - k)/eec;
		float ha = (aed + k)/eec;
		
		float ta = max( 0.0, ha );
		float tb = min( 1.0, hb );
		
		if( ta < tb )
		{
            ta = 0.5*(ta+tb);			
            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );
            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );
            s = 2.0*(tb - ta);
		}
	}

	return vec2(t,s);
}

// Function 3051
bool drawSphere(vec2 coor, vec3 c, float r, out vec3 hit, out vec3 col) {
    vec3 p = vec3(coor, -1.0);
    vec3 dir = vec3(0, 0, 1);
    for (int i = 0; i < 32; ++i) {
        float sdf = sphere(p, c, r);
        if (sdf < 0.0001) {
            hit = p;
            col = 0.3  + 0.4 * vec3(dot(normalize(hit - c), vec3(0, 0, -1))) * (sin(iTime) * 0.5 + 0.5);
            return true;
        }
        p += sdf * 0.5 * dir;
    }
    return false;
}

// Function 3052
float sdBox( vec3 p, vec3 b )
{
    p=abs(p)-b;
    return max(max(p.x,p.y),p.z);
}

// Function 3053
vec3 cone_uniform(in float theta, in vec3 dir, inout float seed)
{
    
    vec3 left = cross(dir, vec3(0., 1., 0.));//error for vertical vectors
    //vec3 left2 = cross(dir, vec3(0., 0., 1.));
    //left = length(left) > length(left2) ? normalize(left) : normalize(left2);
    left = length(left) > 0.1 ? normalize(left) : normalize(cross(dir, vec3(0., 0., 1.)));
    vec3 up = normalize(cross(dir, left));
    
    //cone sampling implementation from pbrt
    vec2 u = hash2(seed);
    float cos_theta = (1. - u.x) + u.x * cos(theta);
    float sin_theta = sqrt(1. - cos_theta * cos_theta);
    float phi = u.y * 2. * M_PI;    
    return normalize(
           left * cos(phi) * sin_theta +
           up   * sin(phi) * sin_theta +
           dir  * cos_theta);

}

// Function 3054
vec2 Box(vec2 box_origin, vec2 box_dx, vec2 box_dy, vec2 box_dims, float thickness, float roundness, vec2 uv, float pixel_uv_size)
{
	vec2 r = uv - box_origin;

	{
		float x = dot(r, box_dx);
		float y = dot(r, box_dy);

		r = ApplyWarp(vec2(x,y), 1.2);
	}

	vec2 r_in_box = clamp(r, vec2(0.0,0.0), box_dims);

	float dist_from_box = distance(r, r_in_box);
	float surface		= dist_from_box - thickness;

	float	colour	= smoothstep(pixel_uv_size, 0.0, surface);
	float	alpha	= colour;
    
    if (r == r_in_box)
    {
		vec2 box_half_size	= box_dims * 0.5;
		vec2 from_mid		= r - box_half_size;
		vec2 to_corner		= sign(from_mid);
		vec2 nearest_corner = box_half_size + to_corner * box_half_size;
		vec2 corner_sphere	= nearest_corner - to_corner * roundness;
		vec2 to_edge		= abs(box_half_size) - abs(from_mid);

		float dist_from_edge = min(to_edge.x, to_edge.y);

		colour = smoothstep(pixel_uv_size, 0.0, dist_from_edge);

		if (sign(r - corner_sphere) == to_corner)
		{
			float dist_from_corner = roundness - distance(corner_sphere, r);

			colour = max(colour, smoothstep(pixel_uv_size, 0.0, dist_from_corner));
		}
    }

	return vec2(colour, alpha);
}

// Function 3055
float SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)
{
    vec3 radialVec = pos - spherePos;
    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);
    float c = dot(radialVec, radialVec) - rad * rad;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

// Function 3056
RayHit traceManySpheres(int numSpheresX, int numSpheresY, Ray ray){
    RayHit hit;
    RayHit rayTrace;
    float depth = 1000000.0;
    for(int x = 0; x < numSpheresX; x++){
        for(int y = 0; y < numSpheresY; y++){
            Sphere sphere = newSphere(vec3((x - numSpheresX / 2) * 20, -30.0, (y) * 20 + 200), 10.00, vec3(1.0, 0.0, 0.0), true, true);
            rayTrace = traceSphere(ray, sphere);
            if(rayTrace.hit){
                if(rayTrace.depth < depth){
                    depth = rayTrace.depth;
    				hit = rayTrace;
                }
            }
        }
    }
   return hit;
}

// Function 3057
float sdSphere( vec3 p, float s )
	{ return length(p)-s;}

// Function 3058
vec3 SphereRand( uint seed )
{
    vec4 rand = Rand(seed);
    float sina = rand.y*2. - 1.;
    float b = 6.283*rand.z;
    float cosa = sqrt(1.-sina*sina);
    return vec3(cosa*cos(b),sina,cosa*sin(b));
}

// Function 3059
float boxfar2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {
    vec2 tMin=(bmin-origin)*dir;
    vec2 tMax=(bmax-origin)*dir;
    vec2 t2=max(tMin,tMax);
    return min(t2.x,t2.y);
}

// Function 3060
void initLightSphere( float time ) {
	lightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5 );
}

// Function 3061
RayHit traceSphere(Ray ray, Sphere sphere){
    RayHit hit;
    
    vec3 sphereRelLoc = sphere.origin - ray.origin;
    
    float projDist = dot(sphereRelLoc, ray.direction);
    vec3 proj = ray.direction * projDist;
    
    vec3 bv = proj - sphereRelLoc;
    
    float b2 = dot(bv, bv);
    
    if(b2 > sphere.radius * sphere.radius){
        hit.hit = false;
        return hit;
    }
    
    hit.hit = true;
    float x = sqrt(sphere.radius * sphere.radius - b2);
    hit.depth = projDist - x;
    hit.worldPosition = ray.origin + ray.direction * hit.depth;
    hit.normal = normalize(sphere.origin - hit.worldPosition);
    hit.baseColor = sphere.color;
    hit.lit = sphere.lit;
    
    return hit;
}

// Function 3062
float distBox(vec3 p, vec3 pos, vec3 r) {
 
    return length(max(abs(pos - p)-r, 0.));
    
}

// Function 3063
float iBox(vec3 o, vec3 d, vec3 center, vec3 sides, out vec3 normal) {
	vec3 axis = normalize(vec3(1.0, 1.0, 0.0));
	mat3 rot = rotationAxisAngle(axis, PI/2.);
	vec3 xn = rot*vec3(1.0, 0.0, 0.0);
	vec3 yn = rot*vec3(0.0, 1.0, 0.0);
	vec3 zn = rot*vec3(0.0, 0.0, 1.0);
	axis = normalize(vec3(0.0, 1.0, 0.0));
	rot = rotationAxisAngle(axis, iTime);
	xn = rot*xn;
	yn = rot*yn;
	zn = rot*zn;	
	float t1, t2;
	float tNear = -10000.0;
	float tFar = 10000.0;
	
	o = o - center; // translation
	
	// x -> yz-plane
	t1 = iPlane2(o, d, vec4(xn, -0.5*sides.x));
	t2 = iPlane2(o, d, vec4(xn, 0.5*sides.x));
	if(t1>t2) swap(t1, t2);
	if(t1 > tNear) { normal = xn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar || tFar < 0.0) return -1.0;
	
	// y -> xz-plane
	t1 = iPlane2(o, d, vec4(yn, -0.5*sides.y));
	t2 = iPlane2(o, d, vec4(yn, 0.5*sides.y));	
	if(t1>t2) swap(t1, t2);
	if(t1 > tNear) { normal = yn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar || tFar < 0.0) return -1.0;
	
	// z -> xy-plane
	t1 = iPlane2(o, d, vec4(zn, -0.5*sides.z));
	t2 = iPlane2(o, d, vec4(zn, 0.5*sides.z));	
	if(t1>t2) swap(t1, t2);
	if(t1 > tNear) { normal = zn; tNear = t1; }
	if(t2 < tFar) tFar = t2;
	if(tNear > tFar || tFar < 0.0) return -1.0;
	
	return tNear;
}

// Function 3064
SDFResult planeSDF2( Plane plane, vec3 p )
{
    float ly = dot((p-plane.pos), plane.norm);
    vec3 local = p - (plane.pos + plane.norm*ly);
    
    float ridgex = mod(local.x, 1.0)-0.5;
    float ridgey = mod(local.y, 1.0)-0.5;
    float ridgez = mod(local.z, 1.0)-0.5;
    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;
    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;
    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;
    
    return SDFResult(ly - ridgex - ridgey - ridgez, plane.matindex);
}

// Function 3065
vec3 skyboxGlobal(vec3 nvDir) {
    float t = abs(nvDir.y);
    return colormapPhi(t*(1.0-0.5*t));
}

// Function 3066
vec4 test_sphere( vec4 sphere, vec3 ray ) {
    
	vec3 r2s = ray * dot( sphere.xyz, ray );
    vec3 near2s = r2s - sphere.xyz;
    
    vec4 rgbz = vec4( 0, 0, 0, 0 );
    
    if( length( near2s ) < sphere.w ) {
        vec3 r0s = r2s - ray * sqrt(  pow( sphere.w, 2. ) - pow( length( near2s ), 2. )  );
        float l1 = 0.2-0.8*dot( ray, normalize( r0s - sphere.xyz ) );
        vec3 c = vec3( 1, 0, 0 ) * pow( l1, 1.5 ) * ( 1.0 - smoothstep( 100., 180., sphere.z ) );
        rgbz = vec4( c, length( r0s ) );
    }
    
	return rgbz;
}

// Function 3067
float fBox(vec3 p, vec3 b, vec3 c)
{
	vec3 d = abs(p-c) - b;
	return max(max(d.x, d.y), d.z);
}

// Function 3068
float sphere_dist(vec3 q) {
	vec3 qp;
	q.x += 0.5 * cos(q.z * 0.1) + 0.5 * sin(q.x * 0.1) + 0.3 * sin(q.y + q.x);
    q.y += 0.5 * sin(q.z) + 0.5 * cos(q.x);
    q.z += 0.5 * sin(q.y * 0.1) + 0.5 * cos(q.x * 0.1) + 0.3 * cos(q.y + q.x);
	qp.x = negmod(q.x, 2.0);
	qp.y = negmod(q.y, 2.0);
	qp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;
	return length(qp) - 1.0
		+  0.1 * sin(q.x * 5.0 + 2.0 * q.z + 3.0 * q.y + time)
		+ 0.1 * cos(q.x * 2.3 + 4.1 * q.z + 1.8 * q.y + time*1.7)
		 + max(0.1 * (q.y + 5.0 * sin(q.z + q.x) + 1.0), 0.0);
}

// Function 3069
float DistanceToBoxBack(in vec3 dir, out int side)
{ 
    
	// Don't need 'tmax' as we're inside the box looking for the back.
	vec3 invDir = 40.0/dir;

	float tx1 = (-40. - dir.x)*invDir.x;
	float tx2 = ( 40. - dir.x)*invDir.x;
	float tmin = min(tx1, tx2); side =1;
	
	float ty1 = (-40. - dir.y)*invDir.y;
	float ty2 = ( 40. - dir.y)*invDir.y;
    
    float m =  min(ty1, ty2);
	if (tmin < m)
    	{tmin = m; side = 2;}
        

	float tz1 = (-40. - dir.z)*invDir.z;
	float tz2 = (40. - dir.z)*invDir.z;
	m = min(tz1, tz2);
   	if (tmin < m)
	    {tmin =  m; side = 0;}

	return tmin;
}

// Function 3070
float y_sphere_3(in float offset) {
    if (offset >= 0.0 && offset <= 12.0) 
        return 0.0;
    else if (offset > 12.0 && offset <= 14.0)
        return sin((offset - 12.0) / 2.0 * PI / 2.0) * movement;
    else if (offset > 14.0 && offset <= 20.0)
        return movement;
    else 
        return y_sphere_common(offset);
}

// Function 3071
float sphereRadius2(int idx)
{
    return sphereCenter2(idx).y + GROUND_HEIGHT;
}

// Function 3072
float magicBox(vec3 p, float magic) {
    // The fractal lives in a 1x1x1 box with mirrors on all sides.
    // Take p anywhere in space and calculate the corresponding position
    // inside the box, 0<(x,y,z)<1
    p = 1.0 - abs(1.0 - mod(p, 2.0));
    
    float lastLength = length(p);
    float tot = 0.0;
    // This is the fractal.  More iterations gives a more detailed
    // fractal at the expense of more computation.
    for (int i=0; i < MAGIC_BOX_ITERS; i++) {
      // The number subtracted here is a "magic" paremeter that
      // produces rather different fractals for different values.
      p = abs(p)/(lastLength*lastLength) - magic;
      float newLength = length(p);
      tot += abs(newLength-lastLength);
      lastLength = newLength;
    }

    return tot;
}

// Function 3073
float sdSphere( vec3 p, float r) { 
    return length(p) - r;
}

// Function 3074
float sdCylinder(vec3 p, vec2 h){
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3075
vec3 nPlane(vec3 ro, vec4 obj) {
	return obj.xyz;
}

// Function 3076
bool intersectBox(vec3 p, vec3 dir, vec3 size)
{
    //vec3 n=cross(cross(dir,p),dir);
    //return length(p-dot(p,n)*n/dot(n,n))<size.y;

    //return true;
    
    size*=.5;
    float tmin, tmax, tymin, tymax, tzmin, tzmax; 
    
    vec3 s=sign(dir);
    vec3 invdir=1./dir;

    tmin  = (-size.x*s.x - p.x) * invdir.x; 
    tmax  = ( size.x*s.x - p.x) * invdir.x; 
    tymin = (-size.y*s.y - p.y) * invdir.y; 
    tymax = ( size.y*s.y - p.y) * invdir.y; 
 
    if ((tmin > tymax) || (tymin > tmax)) return false; 
    if (tymin > tmin) tmin = tymin; 
    if (tymax < tmax) tmax = tymax; 
 
    tzmin = (-size.z*s.z - p.z) * invdir.z; 
    tzmax = ( size.z*s.z - p.z) * invdir.z; 
 
    if ((tmin > tzmax) || (tzmin > tmax)) return false; 
    if (tzmin > tmin) tmin = tzmin; 
    if (tzmax < tmax) tmax = tzmax; 
 
    return true; 
}

// Function 3077
float sdSphere( vec3 p, float s )
{
	p.y = pow(p.y, 13.0);
    return length(p)-s;
}

// Function 3078
float sphere(vec3 p, float radius){
    return length(p)-(radius*(tan(iTime*0.2)+6.));

}

// Function 3079
float IntersectSphere(Ray ray, Object sphere)
{
	vec3 V = sphere.pos - ray.origin;
    float r = sphere.radius;
	float b = dot(V, ray.dir);
	float det = b*b - dot(V, V) + r*r;
	if (det < 0.0)
		return 0.0;
	else {
		det = sqrt(det);
		float epsilon = 1e-3;
		float t;
		return (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.0);
	}
}

// Function 3080
Hit traceSphere(Ray ray,Sphere sphere)
{
   	float a = dot(ray.direction,ray.direction);
    float b = dot(ray.direction,ray.origin-sphere.center)*2.0;
    float c = dot(ray.origin-sphere.center,ray.origin-sphere.center)-sphere.radius*sphere.radius;
    float d = b*b-4.0*a*c;
    Hit hit;
    
    if(d >= 0.0)
    {
        hit.t = (-b-sqrt(d))/(2.0*a);
      	if(hit.t < t_max && hit.t > t_min)
        {
        	hit.normal = normalize((ray.origin+ray.direction*hit.t)-sphere.center);
        	hit.mat = sphere.mat;
        	hit.hit = true;
        	return hit;
       }
        
        hit.t = (-b+sqrt(d))/(2.0*a);
        if(hit.t < t_max && hit.t > t_min)
        {
        	hit.normal = normalize((ray.origin+ray.direction*hit.t)-sphere.center);
        	hit.mat = sphere.mat;
        	hit.hit = true;
        	return hit;
        }
    }
    
	hit.hit = false;
	return hit;   
}

// Function 3081
float sdPlane  ( in float3 O, in float3 N, in float D ) {
  return dot(O, N) + D;
}

// Function 3082
SSphere lightPoint1Sphere()
{
	return SSphere
	(
		1,						//id
		lightPoint1().m_pos,		//center
		0.03,					//radius
		SMaterial
		(
			1.0,				//diffuse amount
			vec3(0.0,0.0,0.0),	//diffuse color
			1.0,				//specular amount
			vec3(0.0,0.0,0.0),	//specular color
			lightPoint1().m_color,//emissive color
			0.0,				//reflection amount
			0.0,				//refraction amount
			0.0					//refraction index
		)
	);	
}

// Function 3083
Shape makeBox(in vec3 c, in vec3 d, int m) { Shape s; s.c = c; s.dim = d; s.cls = SHAPE_BOX; s.mtl = m; return s; }

// Function 3084
float sdBox(vec3 p, vec3 s){
    p = abs(p)-s;
    float  i = min(max(p.x, max(p.y, p.z)), 0.);
    float  e = length(max(p, 0.));
	return e + i ;
    
}

// Function 3085
float pTorus(vec3 p, vec2 t) {vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y;}

// Function 3086
bool RayIntersectSphere (SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 3087
float fplane (vec3 p){
 	return p.y+10.0;   
}

// Function 3088
float iSphere(v33 r,vec4 s){vec3 e=r.a-s.xyz;float b=dot(r.b,e),h=b*b-dd(e)+s.w*s.w,t=-1.;if(h>0.)t=-b-sqrt(h);return t;}

// Function 3089
float fBox2Cheap(vec2 p,vec2 b){vec2 q=abs(p)-b;return max(q.x,q.y);}

// Function 3090
float sdfBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;

    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3091
float sphereOrCubeDist(vec3 a, vec3 b) {
    return mix(length(a-b), sqrt(sphereDist2(a,b)), sphere_fraction);    
}

// Function 3092
vec3 cosUnitHemisphere(uvec2 seed, vec3 n) {
    float t = uintBitsToFloat01(hash(seed))*(2.0*PI);
    float u = uintBitsToFloat11(hash(seed + 6756984u));
    
    return normalize(n + vec3(vec2(cos(t), sin(t)) * sqrt(1.0 - u*u), u));
}

// Function 3093
float sdBox(float s, vec2 uv)
{
	return max(abs(uv.x), abs(uv.y)) - s;   
}

// Function 3094
float sdf_quarter3_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(pos.y, -pos.x));
}

// Function 3095
maybe_float get_distance_along_3d_line_to_infinite_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float cosb
){
    vec3 D = A0 - B0;
    float a = dot(A, B) * dot(A, B) - cosb * cosb;
    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);
    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;
    float det = b * b - 4. * a * c;
    if (det < 0.)
    {
        return maybe_float(0.f, false);
    }

    det = sqrt(det);
    float t1 = (-b - det) / (2. * a);
    float t2 = (-b + det) / (2. * a);
    // This is a bit messy; there ought to be a more elegant solution.
    float t = t1;
    if (t < 0. || t2 > 0. && t2 < t)
    {
        t = t2;
    }
    else {
        t = t1;
    }

    vec3 cp = A0 + t * A - B0;
    float h = dot(cp, B);
    return maybe_float(t, t > 0. && h > 0.);
}

// Function 3096
float cylinder(vec3 r, vec2 a)
{
	vec2 p = abs(vec2(length(r.xz), r.y)) - a;
	
	return min(max(p.x, p.y), 0.0) + length(max(p, 0.));
}

// Function 3097
float cboxc2(vec2 p,float s){s*=.5;p+=s*.5
 ;vec2 a=abs(p+vec2(.1))-s
 ;return length(a)-1.  //vec2(.1)offsets a circle s is needed in here for scaling,within offset,and thats pretty bad style
 //;return(length(max(vec2(0),abs(p)-s)))
 ;}

// Function 3098
vec3 HemisphereRand( vec3 axis, uint seed )
{
    return PowRand( Rand(seed), axis, 1. );
}

// Function 3099
float sdPlane( vec3 p, vec3 pointonplane, vec3 norm )
{
	return dot( norm, p-pointonplane);
}

// Function 3100
float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    //h = height
    //r1 = bottom radius;
    //r2 = top radius;
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

// Function 3101
vec4 intersectSphere_raymarch(vec3 o, vec3 l, float r)
{
	int max_steps = 200;
	float max_delta = r * 1e3f;
	float min_delta = r / 1e5f;
	float end_delta = r / 1e4f;

	vec4 NO_HIT = vec4(0.0f, 0.0f, 0.0f, -1.0f);
	vec3 rd = l;
	vec3 p = o;

	int i;
	for (i = 0; i < max_steps; i++)
	{
		float d = sdSphere(p, r);
		if (d > max_delta)
			return NO_HIT;
		if (d < end_delta)
			break;
		p += rd * max(d, min_delta);
	}

	if (i == max_steps)
		return NO_HIT;
	else
		return vec4(p, 1.0f);
}

// Function 3102
vec2 BoxMuller( vec2 rand )
{
//    float r = sqrt(-2.*log(rand.x));
    float a = tau * rand.y;

// alternative curve, to hang onto small details AND do larger ones
float r = -2.*log(max(.0001,rand.x));
//float r = pow(-2.*log(rand.x),3.); // push it even further - weird
    
    return r*vec2(sin(a),cos(a));
}

// Function 3103
vec3 skybox(vec3 nvDir) {
    return ( mix(0.1, 0.2, smoothstep(-0.2,0.2, nvDir.y)) )*vec3(1.0);
}

// Function 3104
float PrRoundBoxDf (vec3 p, vec3 b, float r) {
  return length (max (abs (p) - b, 0.)) - r;
}

// Function 3105
float fCylinder(vec3 p, float r, float height) {
	float d = length(p.xz) - r;
	d = max(d, abs(p.y) - height);
	return d;
}

// Function 3106
float sphereSDF(vec3 samplePoint) {
    return length(samplePoint) - 1.0;
}

// Function 3107
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal, float height, float radius) {
    float t = (height - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    vec3 worldPos = t * dir + pos;
    if (dot(worldPos.xz, worldPos.xz) < radius) {
        normal = vec3(0, 1, 0);
        return t;
    }
    float a = dot(dir.xz, dir.xz);
    float b = dot(pos.xz, dir.xz);
    float c = dot(pos.xz, pos.xz) - radius;
    float D = b * b - a * c;
    if (D < 0.0) {
        return INF;
    }
    t = (-b - sqrt(D)) / a;
    if (t > 0.0) {
        worldPos = t * dir + pos;
        if (worldPos.y <= height) {
            normal = normalize(vec3(worldPos.x, 0, worldPos.z));
            return t;
        }
    }
    t = (-b + sqrt(D)) / a;
    if (t < 0.0) {
        return INF;
    }
    worldPos = t * dir + pos;
    if (worldPos.y <= height) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    }
    return INF;
}

// Function 3108
float sdBoundingBox( vec3 p, vec3 b, float e )
{
       p = abs(p  )-b;
  vec3 q = abs(p+e)-e;

  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 3109
float fPlane(vec3 p, vec3 n, float d) { return dot(p, n) + d; }

// Function 3110
float boxLength(vec2 pos) {
	vec2 q = abs(pos);
	return max(q.x, q.y);
}

// Function 3111
bool iSphere(in Ray ray, in vec3 sph_o, in float sph_r2, out float t0, out float t1) {
    vec3 L = ray.origin - sph_o;
    float a = dot( ray.dir, ray.dir );
    float b = 2.0 * dot( ray.dir, L );
    float c = dot( L, L ) - sph_r2;
    return solveQuadratic(a, b, c, t0, t1);
}

// Function 3112
float sdCylinder( vec3 p, float r )
{
  return length(p.xz)-r;
}

// Function 3113
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) {
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	return vec2( max( max( t1.x, t1.y ), t1.z ),
	             min( min( t2.x, t2.y ), t2.z ) );
}

// Function 3114
bool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, out float dist) {	
	if (rd.y==0.0) {
		return false;
	}
	
	float d = -(ro.y - height)/rd.y;
	d = min(100000.0, d);
	if( d > 0. ) {
		dist = d;
		return true;
	}
	return false;
}

// Function 3115
float intersectSphere(in Ray ray, in Sphere sphere){
    vec3 oc = ray.o - sphere.pos;
    float b = 2.0 * dot(ray.d, oc);
    float c = dot(oc, oc) - sphere.rad*sphere.rad;
    float disc = b * b - 4.0 * c;

    if (disc < 0.0)
        return -1.0;

    // compute q as described above
    float q;
    if (b < 0.0)
        q = (-b - sqrt(disc))/2.0;
    else
        q = (-b + sqrt(disc))/2.0;

    float t0 = q;
    float t1 = c / q;

    // make sure t0 is smaller than t1
    if (t0 > t1) {
        // if t0 is bigger than t1 swap them around
        float temp = t0;
        t0 = t1;
        t1 = temp;
    }

    // if t1 is less than zero, the object is in the ray's negative direction
    // and consequently the ray misses the sphere
    if (t1 < 0.0)
        return -1.0;

    // if t0 is less than zero, the intersection point is at t1
    if (t0 < 0.0) {
        return t1;
    } else {
        return t0; 
    }
}

// Function 3116
float ConeD(vec3 p, float h, float r){          // cone dist
    
//float lod1 = wP.x*wP.x+wP.y*wP.y+wP.z*wP.z - 2    ;
float lod1 =0.;      
if (lod1> 0.1 )  return lod1;
    
    mat2 rotation = rotate2d(ceil(p.y)*0.6);
    //mat2 rotation = rotate2d(0.);

    p=(fract(p));
	p-=0.5;

    p.yz *= rotation;
    
    float pl = length(p.xy)/r;

    return max((pl+(p.z)-0.5), -p.z);
    }

// Function 3117
float Torus( vec3 position, vec3 axis, float majorRadius, float minorRadius )
{
    axis = normalize(axis);
    float perp = dot(axis,position);
    position -= perp*axis;
    return length( vec2( perp, length(position) - majorRadius ) ) - minorRadius;
}

// Function 3118
vec3 map_box_rgb(vec3 ro, vec3 rd, vec3 nrm) {
    //sample Ssphere
    vec3 smp = normalize(ro - Ssphere.xyz),
         rotnrm = rotateXY(smp, vec2(0., iTime*.5)),
         col = tex(iChannel0, rotnrm).rgb;
	//sample light
    float lightcontrib = max(0., dot(normalize(light.xyz - ro), nrm)),
          ssphcontrib = max(0., dot(-smp, nrm));
    return col*col*ssphcontrib + lightCol*lightcontrib*brightness;
}

// Function 3119
float intersectSphere(in Ray ray, in Sphere sphere) {
	vec3 co = ray.origin - sphere.center;

	float discriminant = dot(co, ray.direction) * dot(co, ray.direction)
			- (dot(co, co) - sphere.radius * sphere.radius);

	if (discriminant >= 0.0)
		return -dot(co, ray.direction)-sqrt(discriminant);
	else
		return -1.;
}

// Function 3120
float sdPlane(vec3 p) {
    return p.y + 3.5;
}

// Function 3121
bool IntersectRayCutCylinder(const Ray ray, const Capsule capsule, out vec3 p1, out vec3 n1, out float tout)
{
    vec3 ro = ray.m_Origin;
    vec3 rd = ray.m_Direction;
    vec3 cc = (capsule.m_A+capsule.m_B)/2.0;
    float ch = length( capsule.m_B - capsule.m_A );
    vec3 ca = ( capsule.m_B - capsule.m_A )/ch;
    float cr = capsule.m_Radius;

    // ----
    
    vec3  oc = ro - cc;
    ch *= 0.5;

    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    
    float a = 1.0 - card*card;
    float b = dot(oc,rd) - caoc*card;
    float c = dot(oc,oc) - caoc*caoc - cr*cr;
    float h = b*b - a*c;
    if( h<0.0 ) return false;
    
    float t = (-b-sqrt(h))/a;
    float y = caoc + t*card;

    if( abs(y)>ch ) return false;
    
    p1 = ro + rd*t;
    n1 = normalize( oc+t*rd - ca*y );
    tout = t;
    return true;
}

// Function 3122
vec4 ray_box(vec3 ro, vec3 rd, vec3 A, vec3 B){
    vec3 sgn = max(vec3(0.0), sign(rd));
    vec3 cN = mix(B, A, sgn);
    vec3 cF = mix(A, B, sgn);
    vec3 qA = (cN-ro)/rd;
    vec3 qB = (cF-ro)/rd;
    float tN = max(qA.x, max(qA.y, qA.z));
    float tF = min(qB.x, min(qB.y, qB.z));
    if(tN > tF) return vec4(-1.0);
    float t = tN > 0.0 ? tN : tF;
    vec3 nrm = sign(rd)*vec3(
    qA.x == tN ? 1.0 : 0.0,
    qA.y == tN ? 1.0 : 0.0,
    qA.z == tN ? 1.0 : 0.0
    );
    return vec4(nrm, t);
}

// Function 3123
vec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {
  	vec2 r = hash2(seed);
    
	vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	vec3  vv = cross( uu, n );
	
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( 1.0-r.y );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    
    return normalize( rr );
}

// Function 3124
HyperPlane centerNormToHyperPlane ( in World _world, in vec4 _n, in float _dist )
{
	vec4 n = _world.m_cube.m_rot * _n;
	vec4 p = _world.m_cube.m_trans + _dist*n;
	
    return HyperPlane ( n , -dot(p,n) );
}

// Function 3125
vec2 intersect_box(vec3 ro, vec3 rd,vec3 _min,vec3 _max)
{
    vec3 start = (_min - ro) / rd;
    vec3 end = (_max - ro) / rd;
    
    vec3 a = min(start,end);
    vec3 b = max(start,end);
    
    return vec2(
            max(a.x,max(a.y,a.z)),
            min(b.x,min(b.y,b.z))
        );
}

// Function 3126
bool intersectsInfinitePlane(in Ray ray, in InfinitePlane plane, out float t, out vec3 position, out vec3 normal)
{
	float denom = dot(plane.normal, ray.direction);
    if (denom == 0.0) return false;
    t = dot(plane.normal, plane.origin - ray.origin) / denom;
    
    position = ray.origin + ray.direction * t;
    
    if (denom > 0.0) { 
        if (plane.unidirectionnal) {
            return false;
        } else {
        	normal = -plane.normal;
        }
    } else {
        normal = plane.normal;
    }
    
    return t > 0.0;
}

// Function 3127
float mBox(vec3 p, vec3 b) {
	return max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);
}

// Function 3128
Voxel boxNormal( vec3 direction, vec3 point, float radius )
{
    vec3 directionInverse = 1.0 / direction;
    vec3 n = point * directionInverse;
    vec3 s = sign(direction);
    vec3 k = s * radius * directionInverse;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    
    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
	
    bool isHit = tN <= tF && tF >= 0.0;
        
    Voxel voxel;
    voxel.normal = normal;
    voxel.isHit = isHit;
    
    return voxel;
}

// Function 3129
float sdCylinder(in vec4 p,in vec2 h ) {
  return max(length(p.xzw)-h.x, abs(p.y)-h.y );
}

// Function 3130
float sdf_torus(vec3 p, vec2 t)
{
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 3131
float GDotLightCone()
{
	return cos(atan(RLightCone()));
}

// Function 3132
float distSphere(vec3 p, float radius)
{
    //if point is outside the radius it will return +ve
    // else it will return -ve value
    return length(p) - radius;
}

// Function 3133
vec3 getSphereNormal(vec3 hitPoint,Sphere s){
	return normalize(hitPoint-s.center);
}

// Function 3134
void initplanes() {
  planes[0] = Plane(0,vec3(0.3568, 0, 0.9342));
  planes[1] = Plane(4,vec3(-0.3568, 0, 0.9342));
  planes[2] = Plane(1,vec3(0.5774, 0.5774, 0.5774));
  planes[3] = Plane(2,vec3(-0.5774, 0.5774, 0.5774));  //0
  planes[4] = Plane(3,vec3(0, 0.9342, 0.3568));        //1
  planes[5] = Plane(2,vec3(0.5774, -0.5774, 0.5774));  //2
  planes[6] = Plane(3,vec3(-0.5774, -0.5774, 0.5774)); //3
  planes[7] = Plane(4,vec3(0.9342, 0.3568, 0));
  planes[8] = Plane(1,vec3(0, -0.9342, 0.3568));
  planes[9] = Plane(3,vec3(0.9342, -0.3568, 0));
}

// Function 3135
float sdBox(vec3 p, vec3 r)
{
    p=abs(p)-r;
    return max(max(p.x,p.y),p.z);
}

// Function 3136
float roundedBox( vec3 p, vec3 b, float r )
{
	return length(max(abs(p)-b,0.0))-r;
}

// Function 3137
bool intersectBox(vec3 p, vec3 dir, vec3 size)
{
    size*=.5*sign(dir);

    vec3 vmin = (-size-p)/dir;
    vec3 vmax = ( size-p)/dir;
    
    float tmin=vmin.x, tmax=vmax.x;
    
    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; 
    tmin=max(tmin,vmin.y);
    tmax=min(tmax,vmax.y);
 
    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; 
    tmin=max(tmin,vmin.z);
    tmax=min(tmax,vmax.z);
 
    return true; 
}

// Function 3138
float fBoxCheap(v3 p,v3 b){
 v3 q=abs(p);q=q-p;//mirror clamp
 return max(max(q.x,q.y),q.z);}

// Function 3139
float planeSDF(vec3 p, vec3 n, float h) { return dot(p,n) - h;  }

// Function 3140
float sdSphere(vec3 p){
    return length(p)-1.0;
}

// Function 3141
float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);
    
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2) / dot2(k2), 0.0, 1.0 );
    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 3142
vec3 cone(float s) {
    float a = 3.14159*hash(s + 12.23);
    float b = 6.28238*hash(s + 83.34);
    
    return vec3(sin(a)*sin(b), sin(a)*cos(b), cos(a));
}

// Function 3143
float sdPlaneFlat( vec3 p )
{
  return p.y;
}

// Function 3144
float plane( in vec3 p )
{
    return p.y;
}

// Function 3145
float infinitePlane(vec3 pos, float height)
{
    return pos.y - height;
}

// Function 3146
float sdTorus( vec3 p, vec2 t )
{
    return length( vec2(length(p.xz)-t.x, p.y)) - t.y;
}

// Function 3147
float sdBox( in vec2 p, in vec2 b ) 
{
    vec2 q = abs(p) - b;
    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );
    return (m.x > 0.0) ? length(q) : m.y; 
}

// Function 3148
float raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    vec3 ce = ro - spherePos;
    float b = dot(rd, ce);
    float c = dot(ce, ce) - (sphereRadius * sphereRadius);
    float t = b * b - c;
    if (t > tmin) {
        t = -b - sqrt(t);
        if (t < tmax)
            return t;
    }
    return -1.0;
}

// Function 3149
vec3 sampleHemisphereCosWeighted( in vec3 n, in vec2 xi ) {
    return l2w( sampleHemisphereCosWeighted( xi ), n );
}

// Function 3150
vec3 tilePlane(vec3 p) {
    p.xz = mod(p.xz, 1.1);
    return p;
}

// Function 3151
vec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, in vec3 center,out vec3 oN ) 
{
    ro -= center;
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection
    
    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);

    return vec2( tN, tF );
}

// Function 3152
float torus4d( vec4 p, float r, float thickness ){
  vec2 q = vec2(length(p.xz)-r,p.y);
  return length(q)- thickness;
}

// Function 3153
bool raySphereIntersection( in Ray ray, in float radiusSquared, out float t, out SurfaceHitInfo isect ) {
    float t0, t1;
    if (!iSphere(ray, vec3(.0), radiusSquared, t0, t1))
		return false;
    
    t = mix(mix(-1.0, t1, float(t1 > 0.0)), t0, float(t0 > 0.0));
    
    isect.position_ = ray.origin + ray.dir*t;
    isect.normal_ = normalize( isect.position_ );
	
	return (t != -1.0);
}

// Function 3154
float sdFibSphere(in vec3 pos, in float rad1, in float rad2) {

    float d = 1e9;
    
    // early-out.
    // this approach to bounding volume destroys exactness of SDF.
    // discussion in https://www.shadertoy.com/view/ssBXRG
    float sdBounds = abs(sdSphere(pos, rad1)) - rad2;
    if (sdBounds > rad2 * 0.2) {
        return sdBounds;
    }

    // golden angle
    const float phi = 3.14159265359 * (3.0 - sqrt(5.0));
    
    const float num           = 50.0;
    const float num_minus_one = num - 1.0;
    
    for (float n = 0.0; n < num; ++n) {
        // y goes from 1 to -1
        float y = 1.0 - (n / num_minus_one * 2.0);
        
        // radius at y
        float radius = sqrt(1.0 - y * y);
        
        // shrink the ones near the top
        float rad2Fac = smoothstep(1.0, 0.0, abs(y)) * 0.4 + 0.6;
        
        float theta = phi * n;
        
        float x = cos(theta) * radius;
        float z = sin(theta) * radius;
        
        d = min(d, sdSphere(pos - vec3(x, y, z) * rad1, rad2 * rad2Fac));
    }
    
    return d;
}

// Function 3155
float sdCappedCylinder( vec3 p, vec2 h ) {
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3156
float udBox( vec3 p )
{
  
  vec3 q = fract(p)*0.1-0.05;
    
  q.x = cos(p.y+0.4*iTime);
    
  q.y = sin(p.x+0.4*iTime); 
  vec3 b = vec3(0.1,0.1,0.1);
  return length(max(abs(q)-b,0.0));
}

// Function 3157
vec3 fragCoordToProjectionPlane(vec2 fragUv)
{
	vec2 uv = pixelToNormalizedspace(fragUv);
    return projectionCenter + projectionRight * uv.x + projectionUp * uv.y;
}

// Function 3158
float iSphere (vec3 ro, vec3 rd, vec3 c, float r, out float t){

    float B = 2.0* dot(ro - c,rd);
    float C = pow(length(ro -c),2.0) -pow(r,2.0);
    float d = pow(B,2.0) - 4.0*C;
    if (d < 0.0){
    	return -1.0;
    }
    
    t = (-B - sqrt(d))/2.0;    
    return 1.0;
	
}

// Function 3159
float sphere(vec3 ro, vec3 rd, float r)
{
	float b = dot(ro, rd);
	float c = dot(ro, ro) - r * r;
	float a = dot(rd, rd);
	// Exit if rs origin outside s (c > 0) and r pointing away from s (b > 0)
	if (c > 0.0 && b > 0.0)
		return INF;
	float discr = b*b - a*c;
	// A negative discriminant corresponds to ray missing sphere
	if (discr < 0.0)
		return INF;
	// Ray now found to intersect sphere, compute smallest t value of intersection
	float t = - b - sqrt(discr);
	t /= a;
	// If t is negative, ray started inside sphere so clamp t to zero
	t = max(0.0, t);
	return t;
}

// Function 3160
float fCone(vec3 p, float radius, float height) {
	vec2 q = vec2(length(p.xz), p.y);
	vec2 tip = q - vec2(0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));

	// distance to tip
	if ((q.y > height) && (projected < 0.)) {
		d = max(d, length(tip));
	}

	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

// Function 3161
vec2 box2(vec3 ro,vec3 rd)
{
    return vec2(max((-sign(rd.x)-ro.x)/rd.x,max((-sign(rd.y)-ro.y)/rd.y,(-sign(rd.z)-ro.z)/rd.z)),box1(ro,rd));
}

// Function 3162
float pTorus2(vec3 p, vec2 t) {vec2 q = vec2(length(p.xy)-t.x,p.z); return length(q)-t.y;}

// Function 3163
float intersectCone( in vec3  ro, in vec3  rd, 
                    in float ra, in float rb,
                    in float  paz, in float pbz)
{
    float ba = pbz - paz;
    vec3  oa = ro - vec3(0, 0, paz);
    vec3  ob = ro - vec3(0, 0, pbz);

    float m0 = ba * ba;
    float m1 = oa.z * ba;
    float m2 = ob.z * ba; 
    float m3 = rd.z * ba;

    // body
    float m4 = dot(rd,oa);
    float m5 = dot(oa,oa);
    float rr = ra - rb;
    float hy = m0 + rr*rr;

    float k2 = m0*m0    - m3*m3*hy;
    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );
    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);

    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return -1.0;

    float t0 = (-k1-sqrt(h))/k2;
    float t1 = (-k1+sqrt(h))/k2;

    float y0 = m1 + t0*m3;
    float y1 = m1 + t1*m3;

    if(paz>pbz)
        return ( y0>0.0 && y0<m0 ) ? (-k1-sqrt(h))/k2 : -1.;
    else
        return ( y1>0.0 && y1<m0 ) ? (-k1+sqrt(h))/k2 : -1.;
}

// Function 3164
float sdRoundCone(vec3 a, vec3 b, float r1, float r2, vec3 p)
{
    vec3  ba = b - a;
    float l2 = dot(ba,ba);
    float rr = r1 - r2;
    float a2 = l2 - rr*rr;
    float il2 = 1.0/l2;
    
    vec3 pa = p - a;
    float y = dot(pa,ba);
    float z = y - l2;
    vec3 x =  pa*l2 - ba*y;
    float x2 = dot(x, x);
    float y2 = y*y*l2;
    float z2 = z*z*l2;

    float k = sign(rr)*rr*rr*x2;
    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;
    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;
                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;
}

// Function 3165
float iPlane(vec3 ro, vec3 rd, vec4 plane) {
	vec3 n = plane.xyz;
	float dist = -plane.w;
	float denom = dot(n, rd);
	return - (dot(n, ro) + dist) / denom;
}

// Function 3166
float PrBoxDf (vec3 p, vec3 b)
{
  vec3 d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}

// Function 3167
float cylinder(vec3 u,vec2 rh
){return RoundXy(vec2(length(u.xy),u.z)-rh);}

// Function 3168
void mandelbox_pln(inout vec2 p, float bi, float ic, float sc, vec2 tr)
{
    boxfold_pln(p, bi);
    if (length(p)<ic) inversion_pln(p, ic);
    scale_pln(p, sc);
    trans_pln(p, tr);
}

// Function 3169
float sphere( vec3 p, float r ){ return length(p)-r;}

// Function 3170
void getPlanet( in int i, out float r, out float d, out vec3 c, out float op, out float rp, out float ga)
{
    // i index
    // r radius (km)
    // d distance (km)
    // c color (rgb)
    // op orbital period (days)
    // rp rotation period (days)
    // ga geometric albedo (fraction)
    
    if( i == 0 )
    {
        // Sol
		r = 695700.0;
		d = 0.0;
		c = vec3( 1.0, 0.5, 0.0 );
        op = 0.0;
        rp = 0.0;
        ga = 1.0;
        return;
    }
    if( i == 1 )
    {
        // Mercury
		r = 2439.7;
		d = (69816.9+46001.2+57909.05)/3.0*1000.0;
		c = vec3( 0.6, 0.6, 0.6 );
        op = 87.9691;
        rp = 58.646;
        ga = 0.142;
        return;
    }
    if( i == 2 )
    {
        // Venus
		r = 6051.8;
		d = (108939.0+107477.0+108208.0)/3.0*1000.0;
		c = vec3(0.8, 0.76, 0.66 );  // 204, 195, 168
        op = 224.701;
        rp = -243.025;
        ga = 0.67;
        return;
    }
    if( i == 3 )
    {
        // Earth
		r = 6378.1;
		d = (152100.0+147095.0+149598.0)/3.0*1000.0;
		c = vec3(0.3, 0.3, 0.5);
        op = 365.256363;
        rp = 0.99726968;
        ga = 0.367;
        return;
    }
    if( i == 4 )
    {
        // Mars
		r = 3389.5;
		d = (249.2+206.7+227.9392)/3.0*1000.0*1000.0;
		c = vec3(0.66, 0.44, 0.28); // 168, 112, 72
        op = 686.971;
        rp = 1.025957;
        ga = 0.170;
        return;
    }
	if( i == 5 )
    {
        // Jupiter
		r = 69911.0;
		d = (816.04+740.55+778.299)/3.0*1000.0*1000.0;
		c = vec3( 0.73, 0.68, 0.62 ); // 187, 173, 157
        op = 4332.59;
        rp = 9.925/24.0;
        ga = 0.52;
        return;
    }
    if( i == 6 )
    {
        // Saturn
		r = 58232.0;
		d = (1509.0+1350.0+1429.39)/3.0*1000.0*1000.0;
		c = vec3( 0.65, 0.58, 0.43 ); // 166, 149, 109
        op = 10759.22;
        rp = 10.55/24.0;
        ga = 0.47;
        return;
    }
    if( i == 7 )
    {
        // Uranus
		r = 25362.0;
		d = (3008.0+2742.0+2875.04)/3.0*1000.0*1000.0;
		c = vec3( 0.75, 0.88, 0.91 ); // 190, 228, 231
        op = 30688.5;
        rp = 0.71833;
        ga = 0.51;
        return;
    }
    if( i == 8 )
    {
        // Moon
		r = 1737.1;
		d = (362600.0+405400.0+384399.0)/3.0;
		c = vec3( 0.39, 0.38, 0.37 ); // 100, 97, 94
        op = 27.321661;
        rp = 27.321661;
        ga = 0.136;
        return;
    }
}

// Function 3171
float sdSphere( vec3 p, float s ) { return length(p)-s; }

// Function 3172
vec2 plane( vec3 p) {
    return vec2(p.y+2.0,1.0);
}

// Function 3173
vec3 cosWeightedHemisphereDirection( const vec3 n, in vec2 r) {
	vec3  uu = normalize(cross(n, vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	float ra = sqrt(r.y);
	float rx = ra*cos(6.2831*r.x); 
	float ry = ra*sin(6.2831*r.x);
	float rz = sqrt( abs(1.0-r.y) );
	vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    return normalize(rr);
}

// Function 3174
intersection_t plane_intersect( plane_t p, ray_t r)
{
	intersection_t ist;
    ist.t = INFINITY;
    
    float t = dot( ( p.center - r.o ), p.normal ) / dot( r.d, p.normal );
    if( t < 0.0 ) { return ist; }
    
    vec3 pt = (r.d * t) + r.o;
    vec3 rad = pt - p.center;
    if( ( abs( dot( rad, p.up ) ) < p.dims.y ) && ( abs( dot( rad, cross( p.up, p.normal ) ) ) < p.dims.x ) )
    {
    	ist.t = t;
        ist.iray = r.d;
        ist.hitpt = pt;
        ist.normal = p.normal;
        ist.mat = p.mat;
    }
    
    return ist;
}

// Function 3175
float cylinder( vec3 p )
{
    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(1,1);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3176
float box(vec3 r, vec3 p, vec3 size)
{
    r = abs(r-p) - size;
    return max(max(r.x,r.y),r.z);
}

// Function 3177
float sdHalfRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - (b-r);
  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);
}

// Function 3178
vec2 sphereTracing( const vec3 o, const vec3 d, const float tmin, const float eps, const bool bInternal)
{
    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
    //http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf p.5-89
    //[modified for internal marching]
    float tmax = 10.0;
    float t = tmin;
    float dist = GEO_MAX_DIST;
    for( int i=0; i<50; i++ )
    {
        vec3 p = o+d*t;
	    dist = (bInternal?-1.:1.)*map(p).d;
        if( abs(dist)<eps || t>tmax )
            break;
        t += dist;
    }
    
    dist = (dist<tmax)?dist:GEO_MAX_DIST;
    return vec2( t, dist );
}

// Function 3179
mat3x4 PlaneIsect(vec3 norml,
                  float offs,
                  vec3 ro,
                  vec3 rd)
{
    vec3 srcNorml = norml;
    norml *= -1.0f; // This intersection algorithm renders planes upside-down, idk why...
    float proj = dot(norml, rd);
    // Synthesize planar origin
    vec3 ori = norml * offs; // Normal is in global space
        
    // Find the vector connecting the planar origin to the
    // ray origin, then find it's projection onto
    // the local normal
    // (scales distances to account for varying collinearity 
    // between [rd] and [norml])
    vec3 rP = (ori - ro);
    float rPProj = dot(rP, norml);
        
    // Total distance will equal the ratio of [rpProj] and [proj];
    // generate that value and use it to find the intersection
    // position before returning to the callsite
    float t = rPProj / proj;
    return mat3x4(vec4(ro + rd * t, t),
                  vec4(ori, t >= 0.0f && proj > EPSILON),
                  vec4(srcNorml, 0.0f));
}

// Function 3180
vec4 GetPlane(vec3 n, vec3 p){
    n = normalize(n);
    float D = dot(n,p);
    return vec4(n, D);
}

// Function 3181
vec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color)
{
  vec3 q = abs(p) - b;
  float d= length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
  return vec4(color.rgb, d);
}

// Function 3182
float sdHexBox(vec2 position, vec2 halfSize) {
	vec2 absPosition = abs(position);
return max(dot(absPosition, axisH) - halfSize.y, dot(absPosition, axisV) - halfSize.x);
}

// Function 3183
float sdCone( vec3 p, vec2 c )
{
	// c must be normalized
	float q = length(p.xy);
	return dot(c,vec2(q,p.z));
}

// Function 3184
float cylinder(vec3 ray,vec3 pos, float radius, float height)
{
    return max(length(ray.xy-pos.xy) - radius, abs(ray.z-pos.z)-height);
}

// Function 3185
float sdbox( vec3 p, vec3 b ) {
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3186
HitQuery intersect_sphere(Ray ray, Sphere sphere) {

    
    float radius_sq = sphere.radius *  sphere.radius;
    
    vec2 origin2center = sphere.center - ray.origin;
    float origin2center_norm = length(origin2center);
    float origin2center_norm_sq = origin2center_norm * origin2center_norm;
    
    bool is_inside =  origin2center_norm <= sphere.radius;
    
    float projection = dot(origin2center, ray.dir);
    float projection_sq = projection*projection;
    
    if ( !is_inside && projection < eps) {
        return no_hit;
    }
    
    float perp_sq = origin2center_norm_sq - projection_sq;
    
    if (!is_inside && perp_sq > radius_sq) {
        return no_hit;
    }
    
    float dist_proj2bdr = sqrt(radius_sq - perp_sq);
    float t1 = projection - dist_proj2bdr;
    float t2 = projection + dist_proj2bdr;
    float t = t1 >= eps ? t1 : (t2 >= eps ? t2 : infinity);


    vec2 p = ray.origin + t * ray.dir;

    vec2 normal = normalize(p - sphere.center);


    return HitQuery(t, p, normal, sphere.material, 1.0);
    
}

// Function 3187
float sdPlane(vec3 p)
{
	return p.y;
}

// Function 3188
float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2(length(p.xz), p.y );
    float d1 = -q.y - c.z;
    float d2 = max(dot(q,c.xy), q.y);
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

// Function 3189
float intersectBox (in Ray ray, in Box box, out vec3 normal, out vec2 uv) {
	// 
	float t_min = 0.0;
	float t_max = ray.distance;
	// 
	for (int i = 0; i < 3; ++i) {
		//       i
		float t_axis_min = box.center[i] - box.size[i] * 0.5;
		float t_axis_max = t_axis_min + box.size[i];
		//    i
		if (abs(ray.direction[i]) < 0.0001) {
			//    -  
			if (ray.origin[i] < t_axis_min || ray.origin[i] > t_axis_max) return ray.far;
		} else {
			//     
			float t1 = (t_axis_min - ray.origin[i]) / ray.direction[i];
			float t2 = (t_axis_max - ray.origin[i]) / ray.direction[i];
			//  min < max
			if (t1 > t2) {
				float temp = t1;
				t1 = t2;
				t2 = temp;
			}
			//  
			if(t1 > t_min) t_min = t1;
			if(t2 < t_max) t_max = t2;
			if (t_min > t_max) return ray.far;	//    
		}
	}
	// 
	bool flag_inside = (t_min == 0.0); 				//    
	float t = (flag_inside) ? (t_max) : (t_min);	//   
	vec3 p = ray.origin + ray.direction * t;		// 
	//   
	float t_axis = t_max; 	// 
	int n_axis = 0;
	for (int i = 0; i < 3; ++i) {
		float distFromPos  = abs(box.center[i] - p[i]);
		float distFromEdge = abs(distFromPos - (box.size[i] * 0.5));
		if (distFromEdge < t_axis) {
			n_axis = i;
			t_axis = distFromEdge;
			normal = vec3(0);
			normal[i] = (p[i] < box.center[i]) ? -1.0 : 1.0;
		}
	}
	normal *= (flag_inside ? -1. : 1.);
	// 
	vec3 n = p - box.center;
	if (n_axis == 0) {
		uv = vec2 ( n.y, n.z );
	} else if (n_axis == 1) {
		uv = vec2 ( n.x, n.z );
	} else if (n_axis == 2) {
		uv = vec2 ( n.x, n.y );
	}
	uv *= 0.25;

	return t;	
}

// Function 3190
vec3 faceToSphere(vec2 facePoint) {
	return normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));
}

// Function 3191
uint spheremap_16( in vec3 nor )
{
    vec2 v = nor.xy*inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x8(v);
}

// Function 3192
float box(vec3 p, vec3 s)
{ 
    vec3 w = abs(p) - s;
    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   
}

// Function 3193
float sdSphere(vec3 p) {
    return length(p) - 1.0;
}

// Function 3194
float sdBox   (vec3 p, vec3  b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));
}

// Function 3195
float sphereSDF(vec3 p, Sphere sphere) {
    float dSphere = length(p - sphere.position.xyz) - sphere.radius;
    return dSphere;
}

// Function 3196
float sdfTorus(in vec3 p, in vec2 torusDimensions)
{
    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);
    return length(q) - torusDimensions.y;
}

// Function 3197
float sdXCappedCylinder( vec3 p, float h, float r )
{
    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3198
float sphere(vec3 pos,float r){
	return length(pos)-r;
}

// Function 3199
void draw_sphere_inset(in vec2 p, inout vec3 color) {    
    
    float px = inset_scl;
    
    float dot_size = max(3.0*px, 0.03);
    float line_width = max(.25*px, 0.003);

    float lp = length((p - inset_ctr)*px);
        
    vec3 sp = sphere_from_gui(p);
    
    if (lp < 1.) {
        
        color = vec3(1);        
      
        float d_tri = 1e5;
        
        
        float d_circ = 1e5;
        
        for (int i=0; i<3; ++i) {

            d_circ = min(d_circ, length(sp - tri_verts[i]));
            d_circ = min(d_circ, length(sp - tri_spoints[i]));
            
            d_tri = min(d_tri, dot(sp, tri_edges[i]));
        }
        
        d_circ = min(d_circ, length(sp - tri_spoints[3]));
                   
        float d_V = length(sp - poly_vertex);
                
        vec3 sp2 = sp;
        tile_sphere(sp2); 
        

        float d_gray = 1e5;
        
        for (int i=0; i<3; ++i) {
            d_gray = min(d_gray, abs(dot(sp2, tri_edges[i])));
        }
        
        
        float d_pink = length(sp2 - poly_vertex);
        
        color = mix(color, vec3(0.85), smoothstep(px, 0.0, d_gray-2.*line_width));

        color = mix(color, vec3(0.9, 0.5, 0.5), smoothstep(px, 0.0, d_pink-0.7*dot_size));

        color = mix(color, vec3(0.6), smoothstep(px, 0.0, -d_tri));
        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_tri)-line_width));

        color = mix(color, vec3(1), step(d_circ, dot_size));
        color = mix(color, vec3(0.7, 0, 0), smoothstep(px, 0.0, d_V-dot_size));
        color = mix(color, vec3(0), smoothstep(px, 0.0, abs(d_circ - dot_size)-line_width));

    
    }    
    
    color = mix(color, vec3(0), smoothstep(px, 0.0, abs(lp - 1.)-line_width));                                                 
    
}

// Function 3200
bool intersectSphere(in vec3 ro, in vec3 rd, in float r, out float dist, out float edge) {
	float b = dot(rd,-ro), d = b*b - dot(ro,ro) + r*r;
	if (d < 0.) return false;
    edge = sqrt(d);
	dist = b - edge;
	return dist > 0.;
}

// Function 3201
float sdPlaneZ(vec3 p) {
	return abs(p.z);
}

// Function 3202
float torusSDF_multi2( vec3 p, float r, float thickness ){
  vec2 q = vec2(length(p.xz)-r,p.y);
    vec2 qq = fract(q) * 2. - 1.;
  return length(qq)- thickness;
}

// Function 3203
Intersection groundPlane(in vec3 ro, in vec3 rd, in float h) 
{
	Intersection isect;
    isect.valid = false;
    isect.point = vec3(0);
    isect.normal = vec3(0, 1, 0);
    isect.t = -1.0;
    
    vec3 p0 = vec3(0, h, 0);
    vec3 N = vec3(0, 1, 0);
    
    ro.y -= h;
    
    if (dot(-rd, N) < 0.001) return isect; // parallel or away
    
    float t = dot(p0 - ro, N) / dot(rd, N);
 	vec3 p = ro+vec3(0.0, h, 0.0) + t * rd;

    
    isect.t = t;
    isect.point = p;
    isect.valid = true;
    return isect;
}

// Function 3204
void closestSegmentPlane(vec3 p1Line, vec3 p2Line, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {
    // if intersect : get intersection
    vec3 rd = normalize(p2Line - p1Line);
    vec3 pdk;

    float a = dot(rd, nPlane);
    float d = -(dot(p1Line, nPlane)-dot(nPlane,pPlane))/a;
    if (d>0. && d<distance(p1Line, p2Line)) {
        out1 = out0 = p1Line + rd * d;
    } else {
        // Just project sommets of line on plane and select the closest
        vec3 p1OnPlane = projPtOnPlane(p1Line, pPlane, nPlane),
             p2OnPlane = projPtOnPlane(p2Line, pPlane, nPlane);   
        if (distance(p1Line, p1OnPlane) < distance(p2Line, p2OnPlane)) {
            out0 = p1Line;
            out1 = p1OnPlane;
        } else {
            out0 = p2Line;
            out1 = p2OnPlane;
        }
    }
}

// Function 3205
float rSphere(vec3 o, vec3 d, vec3 c, float r)
{
    vec3 e= c - o;
    float a= dot(e, d);
    float b= r*r - dot(e,e) + a*a;
    if(b>0.0)
    {
        float t = a- sqrt(b);
        if(t>PRECISION_STEP)
            return t;
    }
    return CAMERA_FAR;
}

// Function 3206
vec4 HitXYPlane(vec3 start, vec3 dir) {
    float t = -start.z / dir.z;
    return vec4(start + dir * t, t);
}

// Function 3207
vec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const int iInsideObject )
{
    //return vColor;
    vec3 vResult = vColor;
    
    /*
	float fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist, fInsideObject );
	vec3 vFogColor = Env_GetFogColor( vRayDir, fInsideObject );	
	Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    
    vResult = mix( vFogColor, vResult, fFogFactor );
	*/
    
    // Glass extinction
    if ( iInsideObject == MAT_GLASS || iInsideObject == MAT_WINE )
    {
        vec3 vExtCol = vec3(0);

        if ( iInsideObject == MAT_WINE )
        {
            vExtCol = vec3(1.0) - vec3(1.0, 0.5, 0.01);
        }
        else
        {
            if ( vRayOrigin.z > 0.0 )
            {
                if ( vRayOrigin.x < 0.0 )
                {
                    vExtCol = vec3(1.0) - vec3(0.01, 0.01, 1.0);
                }
                else
                {
                    vExtCol = vec3(1.0) - vec3(1.0, 0.2, 0.8);
                    vExtCol *= 20.0;
                }
            }
        }
        
		vResult *= exp(fDist * -vExtCol);	
    }
    

    return vResult;	    
}

// Function 3208
int convert_planeXOR(bvec3 p){return hsum(convert_index(arithXOR(p,bvec3(rayInvert.zyx))));}

// Function 3209
float hitSphere(vec3 camPos, vec3 ray) {
    return length(camPos) * sin(getAngle( - camPos, ray)) - sphereSize;
}

// Function 3210
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)
{
	//sphere at origin has equation |xyz| = r
	//sp |xyz|^2 = r^2.
	//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),
	//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:
	vec3 oc = ro - sph.xyz; //distance ray origin - sphere center
	
	float b = 2.0 * dot(oc, rd);
	float c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - 4.0 * c; // delta
	if(h < 0.0) 
		return -1.0;
	float t = (-b - sqrt(h)) / 2.0; //Again a = 1.

	return t;
}

// Function 3211
bool intersectSphere( float radius, vec3 center, vec3 ro,vec3 rd, out rtIntersection hit ) 
{
	vec3 oc = center - ro;
    float l = dot(rd, oc);
    float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);
    if (det < 0.0) return false;

             float len = l - sqrt(det);
    if (len < 0.0) len = l + sqrt(det);
    if (len < 0.0) return false;

    vec3 pos = ro + len * rd;
    hit = rtIntersection(len, pos, (pos - center) / radius,-1);
    return true;
}

// Function 3212
float SphereDist(vec3 position, vec3 rposition, float radius)
{
    return length(position - rposition) - radius;
}

// Function 3213
float plane(in vec3 pos) {
    return -pos.y;
}

// Function 3214
float dbox3(vec3 x, vec3 b)
{
  b = abs(x) - b;
  return length(max(b,0.))
         + min(max(b.x,max(b.y,b.z)),0.);
}

// Function 3215
float dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}

// Function 3216
float Cylinder( vec3 p, float r, float height ) 
{
    float d = length( p.xz ) - r;
    d = max( d, abs( p.y ) - height );
    return d;
}

// Function 3217
float PrRoundBoxDf (vec3 p, vec3 b, float r)
{
  return length (max (abs (p) - b, 0.)) - r;
}

// Function 3218
bool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {	
	if (rd.y==0.0) {
		return false;
	}
	
	float d = -(ro.y - height)/rd.y;
	d = min(100000.0, d);
	if( d > 0. ) {
		dist = d;
		return true;
	}
	return false;
}

// Function 3219
v4 fSphere(DAVec3 p){v4 q=lengthd(p.x,p.y,p.z);return subd(q,1.);;}

// Function 3220
float sdCone( vec3 p, vec2 c )
{
  // c is the sin/cos of the angle
  float q = length(p.xy);
  return dot(c,vec2(q,p.z));
}

// Function 3221
vec3 sample_cos_hemisphere(in vec3 N,float x1, float x2,out float pdf){
    float phi = M_2PI_F * x1;
	float r = sqrt(x2);
	x1 = r * cos(phi);
	x2 = r * sin(phi);
	vec3 T, B;
	frisvad (N, T, B);
	float costheta = sqrt(max(1.0f - x1 * x1 - x2 * x2, 0.0));
	pdf = M_1_PI_F;
	return x1 * T + x2 * B + costheta * N;
}

// Function 3222
float sdCylinder(vec3 p, vec2 h)
{
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3223
bool intersectsSphere(in Ray ray, in Sphere sphere, out float t, out vec3 position, out vec3 normal) 
{ 
    float t0, t1; // solutions for t if the ray intersects 
    float radius2 = sphere.radius * sphere.radius;
    // geometric solution
    vec3 L = sphere.center - ray.origin; 
    float tca = dot(L, ray.direction); 
    // if (tca < 0) return false;
    float d2 = dot(L, L) - tca * tca; 
    if (d2 > sphere.radius * sphere.radius) return false; 
    float thc = sqrt(sphere.radius * sphere.radius - d2); 
    t0 = tca - thc; 
    t1 = tca + thc;  
    if (t0 > t1) {
       	float tmp = t0;
        t0 = t1;
      	t1 = tmp;
    } 
 
    if (t0 < 0.0) { 
        t0 = t1; // if t0 is negative, let's use t1 instead 
        if (t0 < 0.0) return false; // both t0 and t1 are negative 
    } 
 
    t = t0; 
    
    position = ray.origin + ray.direction * t;
    normal = normalize(ray.origin + ray.direction * t - sphere.center);
 
    return true; 
}

// Function 3224
float cylinderY(vec4 ray,vec3 u, float radius, float height
){maxGISize=max(maxGISize,height*radius*ray.w)
 ;return ray.w*(max(length(ray.xz-u.xz)
 -radius, abs(ray.y-u.y)-height));}

// Function 3225
float planeSDF(vec3 p) {
    vec3 position = vec3(0,-2,0);
    vec3 position2 = p - position;
    
    vec3 d = abs(position2) - vec3(5.0, 0.1, 5.0);

    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);

    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 3226
vec3 random_in_unit_sphere(vec3 r) {
    vec3 p;
    p = 2.0 * r - vec3(1.0);
    while (dot(p,p) > 1.0) p *= 0.7;
    return p;
}

// Function 3227
float udRoundBox (in vec3 p, in vec3 size, in float r)
{
    return length (max (abs (p) - (size - r), .0)) - r;
}

// Function 3228
HessNum3 DE_Cone_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)
{
  
    HessNum3 q = a_sqrt(add(mult(x,x),mult(z,z)));
    vec2 c = normalize(vec2(1.,1.));
    
    return add(mult(q,c.x),mult(y,c.y));
                       
 
}

// Function 3229
float SFSphere(vec3 p, vec4 s)
{//-> Here is a raw scalar field of a sphere.
    vec3 q = p - s.xyz;
    return dot(q, q) - (s.w * s.w);
}

// Function 3230
float sdSphere( vec3 p, float r ) {
	return length( p ) - r;
}

// Function 3231
float sdBox(vec3 p, vec3 b)
{
    vec3 h = abs(p) - b;
    return max(h.x, max(h.y, h.z));
}

// Function 3232
float squareToUniformSpherePdf()
{
    return 1.0 / (4.0 * PI);
}

// Function 3233
vec3 sphereColor(vec3 worldPos, float nDotV, float dist, float worldAngle)
{    
    // which planet are we talnikg about already?
    // This is done way to much for final rendering, could be optimized out
    planet p;
	vec3 sector = floor(worldPos);
    GetPlanet(sector, p);

    // Scale AA accourding to disatnce and facing ratio
   	float aaScale = 4.0 - nDotV * 3.8 + min(4.0, dist * dist * 0.025);
    
    // Find local position on the sphere
    vec3 localPos = worldPos - (sector + p.center);
    
    // Random seed that will be used for the two flower layers
    vec4 rnd = N24(vec2(sector.x, sector.y + sector.z * 23.4));
    vec4 rnd2 = N24(rnd.xy * 5.0);
    
    // compensate for the world Z rotation so planets stay upright
    localPos = (rotationZ(-worldAngle) * vec4(localPos, 0.0)).xyz;
    // Planet rotation at random speed
    localPos = (rotationY(iTime * (rnd.w - 0.5)) * vec4(localPos, 0.0)).xyz;
   
    
    // Compute polar coordinates on the sphere
    float lon = (atan(localPos.z, localPos.x)) + pi;  // 0.0 - 2 * pi
    float lat  = (atan(length(localPos.xz), localPos.y)) - halfPi; //-halfPi <-> halfPi
    
    // Compute the number of flowers at the equator according to the size of the planet
    float numAtEquator = floor(3.0 + p.radius * 15.0);
    float angle = pi2 / numAtEquator; // an the angle they cover ath the equator
    
    vec3 col1;
    vec3 col2;
    
    float petalAngle = rnd.w * 45.35 + iTime * 0.1;
    
    // Compute on layer of flower by dividing the sphere in horizontal bands of 'angle' height 
    float eq = (floor(lat / angle + 0.5)) * angle;
    vec2 uvs = ringUv(vec2(lon + eq * rnd.y * 45.0, lat), angle, eq);
    vec4 flPattern1 = flower((vec2(0.5) - uvs) * 0.95, rnd, 2.0, aaScale, petalAngle, col1, 0.8);
    
    
    // Compute a second layer of flowers with bands offset by half angle
    float eq2 = (floor(lat / angle) + 0.5) * angle;
    vec2 uvs2 = ringUv(vec2(lon + eq2 * rnd.x * 33.0, lat), angle, eq2);
    vec4 flPattern2 = flower((vec2(0.5) - uvs2) * 0.95, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);
    

    // Compute flower with planar mapping on xz to cover the poles. 
    vec4 flPattern3 = flower(localPos.xz / p.radius, rnd2, 2.0, aaScale, petalAngle, col2, 0.8);
    
    float bg = (1.0 - nDotV);
    vec3 bgCol = rnd2.y > 0.5 ? col1 : col2; // sphere background is the color of one of the layers
    
    vec3 col = bgCol; 
    
    // mix the 3 layers of flowers together
    col = mix(col, flPattern1.rgb, flPattern1.a);
    col = mix(col, flPattern2.rgb, flPattern2.a);
    col = mix(col, flPattern3.rgb, flPattern3.a);
    
    // add some bogus colored shading
    
    //Front lighting
    //col *= mix(vec3(1.0), bgCol * 0.3, (bg * bg) * 0.8);

    return col;
}

// Function 3234
float cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )
{
	vec2 p0 = p;

	float pole = 0.1;
	p.y = ( p.y - pole ) / ( 1.0 - 2.0 * pole );

	// p0 is in x 0,1
	// q0 is in x 0,2

	vec3 q = vec3( p * vec2( 2, 1 ), 0.0 );

	vec3 q0 = q;

//	q += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); // 1
//	q += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); // 2
//	q += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); // 3
	q += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); // 4
//	q += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); // 5
	q += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); // 6
//	q += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); // 7

	vec2 qoff = vec2( 0.0, 0 );
#ifdef CLOUD_FLOW
	qoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; //cloud flow (doesn't fix black line)
#endif

	NoiseTiledParams ntp;
	ntp.eye = camera[3].xyz;
	ntp.n = n;
	ntp.p = n * earth_radius;
	ntp.bias = bias;

	float a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );

	a *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); // would like to do better than that...

	float a0 = a;

	{
		//increase density on areas that have vortices
		a += length( q - q0 ) * 0.5;
		a += q.z * q.z * 5.0;
	}

	// add a little bit more oompf detail, helps overall + on cloud close ups
	a += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;

	a = contrast( a + 0.05, 2.75 ); // higher contrast = deeper blue if we keep negative cloud
	a = soft_max( a, 0.0, 15.0 );
	return a;
}

// Function 3235
vec2 sphere(vec3 raydir, vec3 offset, vec4 sparams)
{
    vec3 tcenter = sparams.xyz - offset;
 	float c = dot(tcenter,tcenter)-sparams.w*sparams.w;
    float b = 2.0*dot(-tcenter, raydir);
    //float a = 1.0;//dot(raydir, raydir);
    float det = b*b-4.0*c;
    vec2 hits = vec2(-1.0,-1.0);
    if(det > 0.0) {
    	float t1 = 0.5*(-b+sqrt(det));
    	float t2 = 0.5*(-b-sqrt(det));
        if(t1 < t2) { hits = vec2(t1,t2); }
        else { hits = vec2(t2,t1); }
    }
    return hits;
}

// Function 3236
bool intersectSphere(Sphere s, Ray ray, out Hit hit[2]) {
  vec3 p = s.p;
  float r = s.r;
  float c = length(p);
  vec3 q = ray.q, d = ray.d;
  // Formula for x^2 + 2Bx + C = 0
  // |q + t*d - p|^2 = r^2
  float B = dot(q-p,d);
  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);
  float D = B*B - C;
  if (D < 0.0) return false;
  D = sqrt(D);
  float t0,t1;
  if (B >= 0.0) {
    t0 = -B-D; t1 = C/t0;
  } else {
    t1 = -B+D; t0 = C/t1;
  }
  hit[0] = Hit(t0,(q+t0*d-p)/r);
  hit[1] = Hit(t1,-(q+t1*d-p)/r);
  return true;
}

// Function 3237
float intersectPlane(
        vec3 rayOrigin,
        vec3 rayDirection,
        vec3 planeNormal,
        vec3 planeOrigin) {
    float denom = dot(planeNormal, rayDirection);
    vec3 p0l0 = planeOrigin - rayOrigin;
    return dot(p0l0, planeNormal) / denom;
}

// Function 3238
float box(vec3 b, vec3 p){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3239
float sphereSize(float d)
{
    return d * 128.0 * pix;
}

// Function 3240
float planet_surface(vec3 p){
    p /= 10.0;
    //p /= 100.0;
    p += warp(p.yzx/500.0)*500.0;
    vec3 p1 = p/size;
    p = (sin(p1.yzx+(length(sin(p/100.0))+sin(p1.yxz))))*size;
    return length(p) + p.y - size;
}

// Function 3241
float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y);
		float t = sin(time)*sin(p.z);
        return max( max( dot(q,c.xy), p.y), -p.y-c.z );
}

// Function 3242
float box(vec4 p, float s) { vec4 ap = abs(p); return min(length(max(vec4(0),ap-s)), max(max(ap.x,ap.y),max(ap.z,ap.w))-s); }

// Function 3243
Sphere sphereConstruct(in float3 center,in float radius)
{
	Sphere s;
    s.center = center;
    s.radius = radius;
    return s;
}

// Function 3244
vec3 getHemisphereUniformSample(vec3 dir) {
	return getConeSample(dir, 1.0);
}

// Function 3245
bool segment_box_intersection(
  in vec3 q1,
  in vec3 dirinv,
  in vec3 boxmin,
  in vec3 boxmax,
  in float t // t of current intersection, used for pruning, see iq's comment.
) {  
   // References: 
   //    https://tavianator.com/fast-branchless-raybounding-box-intersections/ 
   vec3 T1 = dirinv*(boxmin - q1);
   vec3 T2 = dirinv*(boxmax - q1);
   vec3 Tmin = min(T1,T2);
   vec3 Tmax = max(T1,T2);
   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);
   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);    
   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= t);
}

// Function 3246
bool IntersectRaySphere(const Ray ray, const Sphere sphere, out float tmin, out float tmax)
{
	vec3 CO = ray.m_Origin - sphere.m_Center;

	float a = dot(ray.m_Direction,ray.m_Direction);
	float b = 2.0 * dot(CO,ray.m_Direction);
	float c = dot(CO,CO) - (sphere.m_Radius * sphere.m_Radius);

	float discriminant = b * b - 4.0 * a * c;
	if (discriminant < 0.0)
		return false;

	tmin = (-b - sqrt(discriminant)) / (2.0 * a);
	tmax = (-b + sqrt(discriminant)) / (2.0 * a);
	if (tmin > tmax)
	{
		float temp = tmin;
		tmin = tmax;
		tmax = temp;
	}

	return true;
}

// Function 3247
float iPlane( in vec3 ro, in vec3 rd )
{
    return (-0.21 - ro.y)/rd.y;
}

// Function 3248
bool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )
{
    /////////////////////////////////
    // TASK: WRITE YOUR CODE HERE. //
    /////////////////////////////////
    // get relative postion of the ray to the center of the sphere
    Ray_t local_ray = Ray_t(ray.o - sph.center, ray.d);
    // solve quadratic equation
    float a = 1.0;
    float b = 2.0 * dot(local_ray.d, local_ray.o);
    float c = dot(local_ray.o, local_ray.o) - sph.radius * sph.radius;
    float d = b * b - 4.0 * a * c;
    // d <= 0.0 means no intersection
    if ( d <= 0.0 )
        return false;
        
    float t_minus = ( -b - sqrt(d) ) / (2.0 * a);
    float t_plus =  ( -b + sqrt(d) ) / (2.0 * a);

    float t_positive = 0.0;
    // get the smallest positive solution
    if ( t_minus > 0.0 )
        t_positive = t_minus;
    else if ( t_plus > 0.0 )
        t_positive = t_plus;
    else
        return false;
    // if t value is out of range, no intersections
    if ( t_positive < tmin || t_positive > tmax ) return false;

    return true;  // Replace this with your code.

}

// Function 3249
float pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}

// Function 3250
vec4 renderPlanet( const in vec3 ro, const in vec3 rd, inout float maxd ) {
    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );
                      
	if( d < 0. || d > maxd) {
        return vec4(0);
	}
    maxd = d;
    vec3 col = vec3( .2, 7., 4. ) * 0.4;
    
    col *= diffuse( normalize( ro+rd*d ), SUN_DIRECTION ) * SUN_COLOR;
                 
    float m = MAX;
    col *= (1. - renderRingFar( ro+rd*d, SUN_DIRECTION, m ).w );
    
 	return vec4( col, 1 ); 
}

// Function 3251
vec3 traceSpherePath(int index, out float radscale)
{
    // Set up initial position and velocity
    vec3 origin = vec3(0, 2, 0);
    vec3 initial_velocity = vec3(.6, 1.5 + cos(float(index)) * .4, 0);

    // Rotate velocity
    float ya = float(index);
    initial_velocity.xz *= mat2(cos(ya), sin(ya), -sin(ya), cos(ya));
    
    // Gravity
    vec3 acceleration = vec3(0, -1.2, 0) * 3.;

    vec3 pos, norm;

    float tt = time + float(index)*.2;

    float lifetime = 2.5;
    tt = mod(tt, lifetime);
    radscale = 1.;
    radscale = smoothstep(0., .1, tt) - smoothstep(lifetime - .1, lifetime, tt);

    float rad;

    // Go through the whole particle motion up to the current timepoint, one parabolic arc at a time.
    // Gravity is kept constant, so acceleration is not changed.
    for(int j = 0; j < 3; ++j)
    {
        float minq = tt;

        // Candidate arc resulting from a collision
        vec3 new_origin, new_initial_velocity;

        for(int i = 0; i < 5; ++i)
        {
            pos = discP[i].xyz;
            rad = discP[i].w;
            norm = discN[i];

            // Set up a quadratic equation representing the intersection of the current
            // parabolic arc with the plane which this disc lies on.
            // This works because the arc of motion lies in a plane. The intersection of that
            // plane with the disc's plane is a line. This line can be projected back in to the
            // arc's plane and the intersection test then becomes a test for intersection between
            // a parabola and a line in 2D, which is a quadratic equation.
            float b = initial_velocity.y + dot(initial_velocity.xz, norm.xz) / norm.y;      
            float d = b * b - acceleration.y * dot(origin - pos, norm) / norm.y * 4.;            
            float q = (-b - sqrt(d)) / acceleration.y / 2.;

            if(d > 0.)
            {
                // The equation has a real root
                vec3 o = origin + initial_velocity * q + acceleration * q * q;

                if(q > 0.&& q < minq && length(o - pos) < rad)
                {
                    // The intersection timepoint is valid, and the intersection point is
                    // contained by the disc. So, update the collision candidate.
                    new_origin = o;
                    new_initial_velocity = reflect(initial_velocity + acceleration * q * 2., norm) * .6;
                    minq = q;
                }
            }
        }

        if(tt>minq)
        {
            // The current arc collided with a disc, so replace it
            // with a new arc representing the deflected particle motion.
            origin = new_origin;
            initial_velocity = new_initial_velocity;
            tt -= minq;
        }
        else
            break;
    }

    // Calculate the final particle position by evaluating the final parabola.
    pos = origin + initial_velocity * tt + acceleration * tt * tt;

    return pos;
}

// Function 3252
vec3 closestPtPlane(vec3 p, vec3 pPlane, vec3 nPlane) {
	return projPtOnPlane(p, pPlane, nPlane);
}

// Function 3253
vec2 iBox( in vec3 ro, in vec3 rd, in vec4 b) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-b.xyz);
    vec3 k = abs(m)*b.w;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	return vec2( tN, tF );
}

// Function 3254
float fCylinder(vec3 p) {
    float d = length(p.xz) - .5;
    d = max(d, abs(p.y) - 1.0);
    return d * .5;
}

// Function 3255
float
torus88_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length8(p.xy)-torus.x,p.z);
    return length8(q)-torus.y;
}

// Function 3256
float sdTorus882( vec3 p, vec2 t )
{
  vec2 q = vec2(length8(p.xy)-t.x,p.z);
  return length8(q)-t.y;
}

// Function 3257
float sdBox(in vec3 p, in vec3 box) {
    vec3 d = abs(p) - box;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3258
float sdPlane(vec3 p)
{
    return p.y;
}

// Function 3259
float Torus( vec3 position, float majorRadius, float minorRadius )
{
    float majorCircle = length(position.xy) - majorRadius;
    vec2 crossSection = vec2( position.z, majorCircle );
    return length( crossSection ) - minorRadius;
}

// Function 3260
float plane (vec3 p, vec3 d) {
	return  dot(-p,vec3(0,0,1))/dot(d,vec3(0,0,1));
}

// Function 3261
float UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)
{
	float sRay = 3.0;

	float uOcclusion = 1.0;

	float uRandom = 0.0;

	// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)

	float rConeNoOcc = rConeWidth;

	if (!fCrossCells)
	{
		uRandom = UHashFromPos(posRay);
		posRay = PosWrap(posRay);
	}

	for (int iStep = 0; iStep < 50; ++iStep)
	{
		vec3 pos = posRay + normalRay * sRay;

		float sConeWidth = sRay * rConeWidth;

		// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of
		//	dUOccMax.

		float dSMin = max(dS, 2.0 * dUOccMax * sRay * rConeWidth);

		// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new
		//	i.e., march until until new cone potentially touches surface
		//	Solution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)
        //  Then add dSMin to potentially get some occlusion.

		SSdfSample sdf;
		if (fCrossCells)
		{
			uRandom = UHashFromPos(pos);
			sdf = SdfScene(PosWrap(pos), uRandom);

			float dSCellEdge = DSCellEdge(pos);
			const float sEdgeSlop = 10.0;
			sRay += max(
						0.0,
						(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /
						(1.0 + rConeNoOcc));
            sRay += dSMin;
		}
		else
		{
			sdf = SdfScene(pos, uRandom);

			sRay += max(0.0, (sdf.m_s - sRay * rConeNoOcc) / (1.0 + rConeNoOcc));
            sRay += dSMin;
		}

		// Update occlusion and non-occluded cone width

		uOcclusion = min(uOcclusion, saturate(0.5 * (1.0 + sdf.m_s / sConeWidth)));
		rConeNoOcc = rConeWidth * saturate(2.0 * uOcclusion - 1.0);

		if (uOcclusion < 0.01 ||
			pos.z < 0.0 ||
			(pos.z > g_zMax && normalRay.z >= 0.0))
		{
			return uOcclusion;
		}
	}

	return uOcclusion;
}

// Function 3262
float sdZCappedCylinder( vec3 p, float h, float r )
{
    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3263
float sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {
  p.x = abs(p.x);
  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);
  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

// Function 3264
float box(vec3 p, vec3 b)
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3265
vec3 nearPlanePoint(vec2 v, float time)
{
 	return vec3(v.x, NEAR_PLANE * (1.0 + sin(time * 0.2) * 0.4), v.y);   
}

// Function 3266
float PrimCylinder( vec3 p, vec3 c )
{
    return length(p.xz-c.xy)-c.z;
}

// Function 3267
float cone_sdf(in vec3 loc) {
    float cone_length = 
        abs(loc.x) + length(loc.yz);
	cone_length = 0.7 * (cone_length - 1.5);

	return cone_length;
}

// Function 3268
Plane2 mkplane2( vec2 base, vec2 normal ) { Plane2 plane; plane.base = base; plane.normal = normal; return plane; }

// Function 3269
int findIndexShortestSphere(vec3 p){
    float sphereDists = sdfSphere(p,spheres[0].position,spheres[0].radius);
    int minS = 0;
    spheres[0].dist = sphereDists;
    for(int i = 1; i < spheres.length(); i++){
        if(i == spheres.length()){
        	break;   
        }
        float iSphereSdf = sdfSphere(p,spheres[i].position,spheres[i].radius);
        sphereDists = min(sphereDists,iSphereSdf);
        spheres[i].dist = iSphereSdf;
        if(sphereDists == iSphereSdf){
            minS = i;
        }
    }
    return minS;
}

// Function 3270
float sdSphere(float dt, vec3 p, float s)
{
    return sdSphere(p,dt*s);
}

// Function 3271
float fBoxCheap(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
}

// Function 3272
float iRoundedCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,
                    in vec3  pa, in vec3  pb, in float ra, in float rb ) {
    vec3  ba = pb - pa;
	vec3  oa = ro - pa;
	vec3  ob = ro - pb;
    float rr = ra - rb;
    float m0 = dot(ba,ba);
    float m1 = dot(ba,oa);
    float m2 = dot(ba,rd);
    float m3 = dot(rd,oa);
    float m5 = dot(oa,oa);
	float m6 = dot(ob,rd);
    float m7 = dot(ob,ob);
    
    float d2 = m0-rr*rr;
    
	float k2 = d2    - m2*m2;
    float k1 = d2*m3 - m1*m2 + m2*rr*ra;
    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2. - m0*ra*ra;
    
	float h = k1*k1 - k0*k2;
    if (h < 0.0) {
        return MAX_DIST;
    }
    
    float t = (-sqrt(h)-k1)/k2;
    
    float y = m1 - ra*rr + t*m2;
    if (y>0.0 && y<d2) {
        if (t >= distBound.x && t <= distBound.y) {
        	normal = normalize( d2*(oa + t*rd)-ba*y );
            return t;
        } else {
            return MAX_DIST;
        }
    } else {
        float h1 = m3*m3 - m5 + ra*ra;
        float h2 = m6*m6 - m7 + rb*rb;

        if (max(h1,h2)<0.0) {
            return MAX_DIST;
        }

        vec3 n = vec3(0);
        float r = MAX_DIST;

        if (h1 > 0.) {        
            r = -m3 - sqrt( h1 );
            n = (oa+r*rd)/ra;
        }
        if (h2 > 0.) {
            t = -m6 - sqrt( h2 );
            if( t<r ) {
                n = (ob+t*rd)/rb;
                r = t;
            }
        }
        if (r >= distBound.x && r <= distBound.y) {
            normal = n;
            return r;
        } else {
            return MAX_DIST;
        }
    }
}

// Function 3273
float udSqBox( vec3 p, vec3 b )
{
	float di = 0.0;
	float dx = abs(p.x)-b.x; if( dx>0.0 ) di+=dx*dx;
    float dy = abs(p.y)-b.y; if( dy>0.0 ) di+=dy*dy;
    float dz = abs(p.z)-b.z; if( dz>0.0 ) di+=dz*dz;
    return di;
}

// Function 3274
float sdSphere (in vec3 p, in float r)
{
    return length (p) - r;
}

// Function 3275
float box(vec3 p, vec3 b) {
   vec3 d = abs(p) - b;
   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3276
float sphere (vec3 p, float size)
{
	return length (p) - size;
}

// Function 3277
float CylinderSDF(vec3 p,float radius)
{
    
    float d = length(p.xz)-radius;
    d = max(d, p.y - 1.0);
    d = max(d,-p.y - 1.0);
    return d;
}

// Function 3278
float sdfSphere(sphere s)
{
    return length(s.position) - s.radius;
}

// Function 3279
float sdBox (in vec2 p, in vec2 b)
{
	vec2 d = abs(p) - b;
 	return length(max(d,0.0)) + min(max(d.x,d.y),0.0); 
}

// Function 3280
vec2 iSphere2(in vec3 ro, in vec3 rd)
{
    vec3 oc = ro;
    float b = dot(oc, rd);
    float c = dot(oc,oc) - 1.;
    float h = b*b - c;
    if(h <0.0) return vec2(-1.);
    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));
}

// Function 3281
float sdPrisonBox(vec3 p){
    vec3 p2 = p;
    p2.y -= 1.3;
    
    float r = 8.0;
    p2 = mod(p2-r*0.5, r)-r*0.5;//repeat 
 
  	float d = max(   sdBox(NormalSinPowWarp(p2, 12.0, 0.41, 3.0), vec3(1.0)),//outward warp
             		 -sdBox(NormalSinPowWarp(p2, 4.0, -0.41, 3.0), vec3(1.50)));  //inward
    
    return d;
}

// Function 3282
Dst dstBox(vec3 p, vec3 pos, vec3 b) {
 
    vec3  q = pos - p;
    float d = length(max(abs(q)-b,0.));
    
    return Dst(d, 0);
    
}

// Function 3283
float iSphere(Obj obj, vec3 o, vec3 r, inout vec3 n)
{
    // Move to local co-ordinates
    o -= obj.pos;
    n = vec3(0.0);
    
    // Solve the intersection equation
    float ret = 0.0;
    float b = 2.0 * dot(o, r);
    float c = dot(o, o) - obj.dim.x * obj.dim.x;
    float h = b * b - 4.0 * c;
    if (h < 0.0) ret = -1.0;
    else ret = (-b - sqrt(h)) / 2.0;
    
    // Return normal and distance
    n = (o + r * ret) / obj.dim.x;
    return ret;
}

// Function 3284
float sBoxSU(in vec2 p, in vec2 b, in float sf){

  return length(max(abs(p) - b + sf, 0.)) - sf;
}

// Function 3285
float RoundBox( vec3 p, vec3 b, float r )
{
  return length(max(abs(p)-b,0.0))-r;
}

// Function 3286
vec3 plane_quadratic_dist(vec2 n, float coeffs[6]) {
    float A = coeffs[0]; float B = coeffs[1]; float C = coeffs[2];
    float D = coeffs[3]; float E = coeffs[4]; float F = coeffs[5];
    float K = n.x;
	float L = n.y;
    float AB = A*B;
    float BC = B*C;
    float AD = A*D;
    float DE = D*E;
    float EE = E*E;
    float BK = B*K;
    float AL = A*L;
    float EL = E*L;
    // if det is 0, there is no maximum we could fit the plane to
    float det = 4.0*AB - EE;
    // +-q yields the plane we are interested in
    // nice to know: setting q=0 returns the center of the surface
	float q = sqrt((C*(BC - DE) + AD*D - F*det)/((BK - EL)*K + AL*L));
    float dx = 2.0*BC - DE;
    float dy = 2.0*AD - C*E;
    float x = ((EL - 2.0*BK)*q - dx)/det;
    float y = ((E*K - 2.0*AL)*q - dy)/det;
    float w = -dot(n,vec2(x,y));
	return vec3(x,y,w);
}

// Function 3287
float dist_roundbox( vec3 pos, vec3 size, float r )
{
  return length(max(abs(pos)-size,0.0))-r;
}

// Function 3288
bound3 CylinderAABB( in vec3 pa, in vec3 pb, in float ra )
{
    vec3 a = pb - pa;
    vec3 e = ra*sqrt( 1.0 - a*a/dot(a,a) );
    
    return bound3( min( pa - e, pb - e ),
                   max( pa + e, pb + e ) );
}

// Function 3289
float RayIntersectAABoxMax (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)
{
    vec3 boxMid = vec3(cellPos)+vec3(0.5);
    
	vec3 roo = rayPos - boxMid;
    vec3 rad = vec3(0.5);

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t2 = -n + k;

    return min( min( t2.x, t2.y ), t2.z );
}

// Function 3290
float ifBox(Ray r, vec3 b) {
  vec2 v=hitAABB(r,AABB(-b,b));
  return (0.<=v.y&&v.x<=v.y)?v.x:NO_HIT_DIST;
}

// Function 3291
SSphere sphere2 ()
{
	return SSphere
	(
		5,						//id
		vec3(sin(iTime*1.3),sin(3.14 + iTime * 1.4)*0.25,cos(iTime*1.3)),	//center
		0.15,					//radius
		SMaterial
		(
			1.0,				//diffuse amount
			vec3(1.0,0.2,0.3),	//diffuse color
			40.0,				//specular amount
			vec3(1.0,1.0,1.0),	//specular color
			vec3(0.0,0.0,0.0),	//emissive
			1.0,				//reflection amount		
			0.0,				//refraction amount
			0.0					//refraction index			
		)
	);
}

// Function 3292
float sphere(vec3 p, vec3 c, float r) {
    return length(p - c) - r;
}

// Function 3293
float iPlane(Obj obj, vec3 o, vec3 r, inout vec3 n)
{
    // Normal
    if (o.y > obj.dim.x)
        n = vec3(0.0, 1.0, 0.0);
    else
        n = vec3(0.0, -1.0, 0.0);
    
    // Intersection distance
    return -o.y / r.y - obj.dim.x;
}

// Function 3294
vec3 renderPlanet(vec3 color, vec3 ray) {
    vec3 pos;
    float dist;
    float t = planetSpeed * iTime;
    float s = sin(t);
    float c = cos(t);
    mat3 rev = mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);
    if (hit(-planetCenter, ray, dist, pos)) {
        vec3 p = rev * planetRot * pos;
        
        p += planetTurbulence * fbm3(10.0 * p + 0.01 * iTime);

        vec3 bands = fbm3(planetBands * vec3(0.05, 0.05, 1.0) * p);
        vec3 planetC = planetColor;
        planetC += planetAccentX * bands.x;
        planetC += planetAccentY * bands.y;
        planetC += planetAccentZ * bands.z;
        float d, r;
        float ringShadow = 1.0 - hitRing(pos, sunDir, d, r);
        color = clamp(planetC, 0.0, 1.0) * clamp(dot(pos, sunDir) * ringShadow, 0.0, 1.0);
    } else {
        dist = 100.0;
    }
    
    float ringDist, radius;
    float ringAlpha = hitRing(-planetCenter, ray, ringDist, radius);
    vec3 ringC = ringColor + ringAccent * fbm1(15.0 * radius);
    color = mix(color, ringC, ringAlpha * step(ringDist, dist));
    return color;
}

// Function 3295
float sdPlane( vec3 p )
{
    return p.y;
}

// Function 3296
float getDistBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
}

// Function 3297
void m2_sphere(inout ray r, rObj o) {
    vec3 nml = normalize(r.pos - o.pos);
    r.pos += nml * EPSILON * 2.;
    r.dir = reflect(r.dir, nml);
    r.col *= vec3(0.99, 0.89, 0.89);
}

// Function 3298
float sphereSDF(const in vec3 p) {
    return length(p) - 1.0;
}

// Function 3299
float softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = sph.xyz - ro;
    float b = dot( oc, rd );
	
    float res = 1.0;
    if( b>0.0 )
    {
        float h = dot(oc,oc) - b*b - sph.w*sph.w;
        res = smoothstep( 0.0, 1.0, 2.0*h/b );
    }
    return res;
}

// Function 3300
vec3 random_sphere(float p)
{
    return normalize(randn(p))*pow(abs(hash(p+1.)), 0.3333);
}

// Function 3301
float dCylinder(vec3 p,vec3 c,vec2 s,float r){vec3 t=p-c;
 vec2 d=abs(vec2(length(t.yz),t.x))-s;return min(max(d.x,d.y)+r,.0)+length(max(d,.0))-r;}

// Function 3302
float sdTorus82( vec3 p, vec2 t )
{
  vec2 q = vec2(length2(p.xz)-t.x,p.y);
  return length8(q)-t.y;
}

// Function 3303
void sphere (inout vec3 p, inout vec3 d) {
	float r = .7, dp = dot(d,p), pp = dot(p,p), det = dp*dp+r*r-pp;
    if (det < 0.) star = true;
    float x = -dp+sqrt(det);
    p = (p+d*x);
    d = reflect(normalize(p),d);
}

// Function 3304
float obj_cylinder(vec3 p, vec3 center, vec2 size, float roundness){
    vec3 tp = p-center;
    vec2 d = abs(vec2(length(tp.xz),tp.y)) - size;
    return min(max(d.x,d.y)+roundness,0.0) + length(max(d,0.0))-roundness;
}

// Function 3305
float sdPlane( vec3 p )
{
	return p.y-noise(p/4.+iTime)/4.-noise(p.zyx/7.+iTime/1.5)/4.-(sin(p.x-iTime*7.)/3.+sin(p.z+iTime/3.)/19.)/8.;
    if(p.y <= 0.0) return p.y;
}

// Function 3306
vec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos, float extraSeed)
{
    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) * extraSeed),
                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) *extraSeed),
                rand01(iTime * (rayDir.z + rayPos.z + 425.357) * extraSeed));
}

// Function 3307
bool intersect_sphere( in vec3 ray, in vec3 center, in float R, out float T )
{
    float B = dot(center,ray);
    float det = B*B - dot(center,center) + R * R;
    if( det < 0.0 ) return false;
    
    T = dot(ray, center) - sqrt(det);
    return T > 0.0;
}

// Function 3308
void RayTraceMountainCylinders(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, in float seed, in float radius, in float maxMountainHeight)
{
    SMaterial material;
    material.diffuse = vec3(1.0f, 1.0f, 1.0f);
    material.specular = vec3(0.0f, 0.0f, 0.0f);
    material.roughness = 0.025f;
    material.emissive = vec3(0.0f, 0.0f, 0.0f);

    SRayHitInfo oldHitInfo = hitInfo;

    if(TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, -15.0f, 0.0f), radius, maxMountainHeight, material))
    {
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        float azimuthPercent = clamp((atan(hitPos.z, hitPos.x) + c_pi) / c_twopi, 0.0f, 1.0f);
        float heightPercent = (hitPos.y + 15.0f) / maxMountainHeight;

        float thisHeightIndex = floor(azimuthPercent * 20.0f);
        float nextHeightIndex = mod(thisHeightIndex + 1.0f, 20.0f);
        float thisHeightIndexFraction = fract(azimuthPercent * 20.0f);

        float thisHeight = hash12(vec2(thisHeightIndex, seed)) * 0.75f + 0.25f;
        float nextHeight = hash12(vec2(nextHeightIndex, seed)) * 0.75f + 0.25f;

        float mountainHeight = mix(thisHeight, nextHeight, thisHeightIndexFraction);

        if (heightPercent > mountainHeight)
        {
            hitInfo = oldHitInfo;
        }
        else
        {
            vec3 brightPink = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f)) * 5.0f;
            
            float borderSize = 0.25f / maxMountainHeight;
            
            hitInfo.material.emissive = brightPink * smoothstep(mountainHeight - borderSize, mountainHeight, heightPercent);
        }
    }    
}

// Function 3309
float tracePlane(vec3 pos, vec3 dir, out vec3 normal)
{
     float t = (-1.2 - pos.y)/dir.y;
     if(t<=0.0){
         return INF;
     }
     vec3 worldPos = t*dir + pos; 
     if(dot(worldPos.xz, worldPos.xz)>=100.0){
         return INF;
     }
     normal = vec3(0,1,0);
     return t;
}

// Function 3310
float getDist2Sphere(vec3 camPos, vec3 ray) {
    float ang = getAngle( - camPos, ray);
    float dist = length( - camPos);
    if (hitSphere(camPos, ray) < 0.0) {
        return dist * cos(ang) - sqrt(pow(dist * cos(ang), 2.0) - pow(dist, 2.0) + pow(sphereSize, 2.0));
    } else {
        return INFTY;
    }
}

// Function 3311
void draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box)
{
    draw_shadow_box(fragColor, fragCoord, box, DEFAULT_SHADOW_BOX_BORDER);
}

// Function 3312
float atmosphereDepth(vec3 pos, vec3 dir)
{
    return max(-pos.y, 0.0)/ max(dir.y, 0.0);
}

// Function 3313
float BoxCross(vec3 pos)
{
    return AddTheseTwoShapes(AddTheseTwoShapes(Box(pos, vec3(2.0,0.5,0.5)),Box(pos, vec3(0.5,0.5,2.0))),Box(pos, vec3(0.5,2.0,0.5)));
}

// Function 3314
void drawPlane(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 planeNorm;
    float planeT = tracePlane(ray.pos, ray.dir, planeNorm);    
    
    if(planeT < cur_ctxt.t)
    {
        cur_ctxt.t = planeT;

        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos; 
        cur_ctxt.color = texture(iChannel0, worldPos.xz * 0.1).rgb;
        cur_ctxt.n = planeNorm;

        cur_ctxt.materialType = DIFFUSE;
        /*if(randVals.y < 0.5)
        {
            cur_ctxt.materialType = REFLECTION;
        }*/
    }
}

// Function 3315
float sdTorus(const in vec3 p, const in vec2 t) {
  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;
}

// Function 3316
float torusSDF( vec3 p, float r, float thickness ){
  vec2 q = vec2(length(p.xz)-r,p.y);
  return length(q)- thickness;
}

// Function 3317
Complex M_fromPlaneToDisk(Complex z)
{
   return Complex(2.0 * z.x, H_sqnorm(z) - 1.0) / (H_sq(z.x) + (1.0 + z.y) * (1.0 + z.y));
}

// Function 3318
vec3 iPlaneInt(vec3 ro, vec3 rd, float d) {
    d = -(ro.y - d) / rd.y;
    return ro + d * rd;
}

// Function 3319
vec3 BlobSpherePosToWorldPos( vec3 pos )
{
    pos *= (1.0 / BLOB_SCALE);
    pos.y += pos.x * 0.1;
    pos += BLOB_ORIGIN;
    return pos;
}

// Function 3320
float get_car_box_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)
{
    return 1.0 - max(abs(dot(uv, carDir) * carLengthInv), abs(dot(uv, carLeft) * carWidthInv));
}

// Function 3321
float coneSDF( vec3 p, vec2 c )
{
    float q = length(p.xz);
    return dot(c,vec2(q,p.y));
}

// Function 3322
bool intersectSphere(Point3 C, float r, Ray R, inout float nearDistance, inout float farDistance) { Point3 P = R.origin; Vector3 w = R.direction; Vector3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }

// Function 3323
void boxClip(
    in vec3 boxMin, in vec3 boxMax,
    in vec3 p, in vec3 v,
    out vec2 tRange, out float didHit
){
    //for each coord, clip tRange to only contain t-values for which p+t*v is in range
    vec3 tb0 = (boxMin - p) / v;
    vec3 tb1 = (boxMax - p) / v;
    vec3 tmin = min(tb0, tb1);
    vec3 tmax = max(tb0, tb1);

    //t must be > tRange.s and each tmin, so > max of these; similar for t1
    tRange = vec2(
        max(max(tmin.x, tmin.y), tmin.z),
        min(min(tmax.x, tmax.y), tmax.z)
    );

    //determine whether ray intersects the box
    didHit = step(tRange.s, tRange.t);
}

// Function 3324
float sdCappedCylinder(vec3 p,vec2 h)
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3325
float sdBox( float p, float b )
{
  return abs(p) - b;
}

// Function 3326
vec3 sampleSphereUniform(vec2 uv)
{
	float cosTheta = 2.0*uv.x - 1.0;
	float phi = 2.0*PI*uv.y;
	return unitVecFromPhiCosTheta(phi, cosTheta);
}

// Function 3327
float rayPlane(vec3 ro, vec3 rd, vec3 n, float d){


    float t = 1e8;
    //float retval = 0.; // Inside or outside the object. Not used here.

	float ndotdir = dot(rd, n);
     
	if (ndotdir < 0.){
	
		float dist = (-d - dot(ro, n) + 9e-7)/ndotdir;	// + 9e-7
   		
		if (dist>0. && dist<t){ 
            t = dist; 
            //retval = 1.;
		}
	}
    
    return t;

}

// Function 3328
void sphereFold(inout vec3 z, inout float dz) {
	float r2 = dot(z,z);
    float minRadius2 = 0.5;
    float fixedRadius2 = 1.0;
	if (r2 < minRadius2) { 
		// linear inner scaling
		float temp = (fixedRadius2/minRadius2);
		z *= temp;
		dz*= temp;
	} else if (r2 < fixedRadius2) { 
		// this is the actual sphere inversion
		float temp =(fixedRadius2/r2);
		z *= temp;
		dz*= temp;
	}
}

// Function 3329
vec3 randomSphereDir(vec2 rnd){
	float s = rnd.x*PI*2.;
	float t = rnd.y*2.-1.;
	return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);
}

// Function 3330
float Box( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 3331
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph, in float rad) {
	// This is relating directly to parametric equation
    // where we define a function xyz = ro + t*rd
    // solving the quadradic equation below
 	vec3 oc = ro - sph.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - rad*rad;
    float t = b*b - c;
    if( t > 0.0) 
        t = -b - sqrt(t);
    return t;

}

// Function 3332
float mandelbox(vec3 z)
{
	vec3 offset = z;
	float dr = 1.0;
	for (int n = 0; n < Iterations; n++) {
		boxFold(z,dr);       
		sphereFold(z,dr);    
		z=Scale*z + offset;  
        dr = dr*abs(Scale)+1.0;
	}
	float r = length(z);
	return r/abs(dr);
}

// Function 3333
float
sphere4_sd( in float sph_r, in vec3 p )
{
    return length4( p ) - sph_r;
}

// Function 3334
float RayPlane(vec3 ro, vec3 rd, vec3 n, float d) {
	return (d-dot(ro, n)) / dot(rd, n);
}

// Function 3335
vec4 calcColor_plane(vec3 ro, vec3 rd, float d)
{
    vec3 p = (ro+rd*d);
    vec2 real_uv=(p.xy+vec2(-pos_x,-pos_y))/(vs*2.)+vec2(0.5,0.5); // real quad UV
    vec2 ssUV=texture(iChannel3,real_uv).rg; // screen space UV reprojection from BufD
    float tc=texture(iChannel1,ssUV).a; // read saved frame in screen space UV
    return vec4(tc*vec3(0.5,0.8,1.)*2.,0.);
}

// Function 3336
RayHit GetDistancePlanet( vec3 origin, vec3 direction, int steps, float maxDist, inout vec3 hitPos)
{
  RayHit result;
  float dist = 1000000.;
  float precis = 0.0, t = 0.0;
  vec3 rayPos;

  for ( int i=0; i<steps+min(0, iFrame); i++ )
  {
    rayPos =origin+direction*t; 
    hitPos = rayPos;
    dist = min(dist, sdSphere(rayPos, 70.));
    t += dist;
  }

  result.hit=(dist<1.);
  result.depth = t; 
  result.dist.x = dist;  
  result.hitPos = origin+((direction*t)); 

  return result;
}

// Function 3337
vec3 SampleHemisphere_Cosinus(float i, float numSamples)
{
    vec2 xi = Hammersley(i, numSamples);
    
    float phi      = xi.y * 2.0 * PI;
    float cosTheta = sqrt(1.0 - xi.x);
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
     
    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);
}

// Function 3338
float udRoundBox( vec3 p, vec3 b, float r,inout vec3 col)
{
    col =vec3(0.4,0.4,0.8);
  	return length(max(abs(p)-b,0.0))-r;
}

// Function 3339
float TraceCylinder( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vCylinderOrigin, const in vec3 vCylinderDir, const in float fLength, const in float fCylinderRadius, inout vec3 vNormal )
{	
	
	vec3 vOffset = vCylinderOrigin - vRayOrigin;
	
	vec3 vProjOffset = Project(vOffset, vCylinderDir);
	vec3 vProjDir = Project(vRayDir, vCylinderDir);
	float fProjScale = length(vProjDir);
	vProjDir /= fProjScale;
	
	// intersect circle in projected space
	
	float fTClosest = dot(vProjOffset, vProjDir);
	
	vec3 vClosest = vProjDir * fTClosest;
	float fDistClosest = length(vClosest - vProjOffset);
	if(fDistClosest < fCylinderRadius)
	{		
		float fHalfChordLength = sqrt(fCylinderRadius * fCylinderRadius - fDistClosest * fDistClosest);
		float fTIntersectMin = clamp((fTClosest - fHalfChordLength) / fProjScale, 0.0, 100000.0);
		float fTIntersectMax = (fTClosest + fHalfChordLength) / fProjScale;	
		
		if(fTIntersectMax > fTIntersectMin)
		{	
            vec3 vHitPos = vRayOrigin + vRayDir * fTIntersectMin;
            float hitU = dot( vHitPos - vCylinderOrigin, vCylinderDir );
            if ( hitU >= 0.0 && hitU <= fLength )
            {
				vNormal = normalize(vProjDir * (fTClosest - fHalfChordLength) - vProjOffset );
				return fTIntersectMin;
            }
		}		
	}
    
    // end cap

    vec3 vEndPos = vCylinderOrigin;
	vNormal = vCylinderDir;
    
    if ( dot( vRayDir, vCylinderDir) < 0.0 )
    {
        vEndPos += vCylinderDir * fLength;
        vNormal = -vNormal;
    }
    
    vec3 vEndOffset = vEndPos - vRayOrigin;
    float endDot = dot( vEndOffset , vCylinderDir );
    float dirDot = dot( vRayDir, vCylinderDir );
    
    float capT = endDot / dirDot;
    
    if ( capT > 0.0 )
    {
        vec3 vCapPos = vRayOrigin + vRayDir * capT;
        
        if ( length( vEndPos - vCapPos ) < fCylinderRadius )
        {
            return capT;
        }
    }
    
    
    return 100000.0;
}

// Function 3340
float box(vec2 p, vec2 b) {
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 3341
float scaleSphere( vec3 p, vec3 scale, float s )
{
    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));
}

// Function 3342
vec3 random_in_unit_sphere(vec2 p)
{
    vec3 rand = hash32(p);
    float phi = 2.0 * PI * rand.x;
    float cosTheta = 2.0 * rand.y - 1.0;
    float u = rand.z;

    float theta = acos(cosTheta);
    float r = pow(u, 1.0 / 3.0);

    float x = r * sin(theta) * cos(phi);
    float y = r * sin(theta) * sin(phi);
    float z = r * cos(theta);

    return vec3(x, y, z);
}

// Function 3343
float capsphere(vec3 h, float radius) {
	vec2 orig = h.xy;
	if (length(orig) >= radius) {
		orig = normalize(orig)*radius;
	}
	return length(vec3(h.xy-orig.xy,h.z));
}

// Function 3344
float pSphere(vec3 p, float s) {return length(p)-s;}

// Function 3345
float IntersectSphere ( vec3 ro, vec3 rd, float rad ) {
    float b = dot(ro,rd);
    float h = b*b - dot(ro,ro) + rad*rad;
    return (h<0.0) ? -1.0 : -b-sqrt(h);   // -b+sqrt(h) = backface distance
}

// Function 3346
float sdBoxXY( vec3 p, vec3 b )
{
  vec2 d = abs(p.xy) - b.xy;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3347
vec3 planeColor(vec3 V,vec3 N,vec3 lightVec,vec2 uv){
    float lightDist = length(lightVec);
    float threshold = 1./lightDist/lightDist/lightDist;
    //float brightness = 1000. * threshold * dot(N,lightVec);
    float brightness = dot(N,lightVec/lightDist);
    vec3 reflected = reflect(V,N);
    
    vec2 pixel = vec2(1./1024.);
    //float shine = 600. * threshold * pow(max(0.,dot(reflected,lightVec/lightDist)),50.);
    float shine = 0.3*pow(max(0.,dot(reflected,lightVec/lightDist)),50.);
    return (brightness+shine+0.2)*texture(iChannel0,501.*pixel+8.*pixel*(0.5*uv+0.5)).xyz;
}

// Function 3348
float sdCylinder(vec3 p, vec3 a, vec3 b, float r)
{
    vec3 pa = p - a;
    vec3 ba = b - a;
    float baba = dot(ba,ba);
    float paba = dot(pa,ba);

    float x = length(pa*baba-ba*paba) - r*baba;
    float y = abs(paba-baba*0.5)-baba*0.5;
    float x2 = x*x;
    float y2 = y*y*baba;
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));
    return sign(d)*sqrt(abs(d))/baba;
}

// Function 3349
float iPlane( in vec3 ro, in vec3 rd )
{
    return (-1.0 - ro.y)/rd.y;
}

// Function 3350
vec2 intersect_plane2_nz( Ray ray, float pz, float nz )
{
	float epsilon = 1e-4;
	float vdotn = ray.d.z * nz;
	float d = ( ray.o.z - pz ) * nz;
	float t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );
	return vec2( t, d );
}

// Function 3351
float sphere_intersect(vec3 ro, vec3 rd, vec3 p, float r) {
  vec3 oc = (ro - p);
  float b = dot(oc, rd);
  float c = (dot(oc, oc) - (r * r));
  float h = ((b * b) - c);
  if(h < 0.0) {
    return -1.0f;
  } else {
    return ((-b) - sqrt(h));
  }
}

// Function 3352
float box(vec3 p, vec3 s, float b) { vec3 ap = abs(p)-s; return min(max(ap.x,max(ap.y,ap.z)),0.0) + length(max(ap,0.0))-b; }

// Function 3353
float PrTorusBxDf (vec3 p, vec3 b, float ri)
{
  return length (vec2 (length (max (abs (p.xy) - b.xy, 0.)) - b.z, p.z)) - ri;
}

// Function 3354
float sdTorus(in vec3 position, in float ringRadius, in float pipeRadius) {
  vec2 q = vec2(length(position.xz) - ringRadius, position.y);
  return length(q) - pipeRadius;
}

// Function 3355
float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) +
           length(max(d,0.0));
}

// Function 3356
vec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)
{
    int sections = 3*int(max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);
    const int maxIterations = 100;//50
    
    float minDist;
    float bestT;
    bool found = false;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        bool failed = false;
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);
            
            if(abs(dt) < 0.1)break;
            
            t -= lerningRate*dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                failed = true;
                break;
            }
        }
        if(failed)continue;
        
        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);
        
        if(lineSqDist <= sq(tkp.r3))
        {
            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);

            if(!found || distAlongD < minDist)
            {
                minDist = distAlongD;
                bestT = t;
            }
            
            found = true;
        }
    }
    
    return vec3(bestT, minDist, found ? 1. : 0.);
}

// Function 3357
float sdBox(vec3 p, vec3 b) {
   vec3 q = abs(p) - b;
   return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 3358
float 
sdBox( vec3 p, vec3 b )
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3359
float rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){
    
    vec3 q = fullRotate( rot ) * p;
    return udRoundBox( q , size , rad );
    
    
}

// Function 3360
float plane(vec3 p) { return p.y; }

// Function 3361
float iCone( const in vec3 oa, const in vec3 rd, const in vec2 distBound, inout vec3 normal,
             const in vec3 pb, const in float ra, const in float rb ) {
    vec3  ba = pb;
    vec3  ob = oa - pb;
    
    float m0 = dot(ba,ba);
    float m1 = dot(oa,ba);
    float m2 = dot(ob,ba); 
    float m3 = dot(rd,ba);

    //caps - only top cap needed for scene
    if (m1 < 0. && dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {
        float d = -m1/m3;
        if (d >= distBound.x && d <= distBound.y) {
            normal = -ba*inversesqrt(m0);
            return d;
        }
    }
    
    // body
    float m4 = dot(rd,oa);
    float m5 = dot(oa,oa);
    float rr = ra - rb;
    float hy = m0 + rr*rr;

    float k2 = m0*m0    - m3*m3*hy;
    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );
    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);

    float h = k1*k1 - k2*k0;
    if( h < 0. ) return MAX_DIST;

    float t = (-k1-sqrt(h))/k2;

    float y = m1 + t*m3;
    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {
        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);
        return t;
    } else {   
        return MAX_DIST;
    }
}

// Function 3362
bool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = normalize(info.m_intersectionPoint - sphere.m_center);
	
	// texture coordinates are just the angular part of spherical coordiantes of normal
	info.m_textureCoordinates = vec2
	(
		atan(info.m_surfaceNormal.y, info.m_surfaceNormal.x) / 8.0,
		acos(info.m_surfaceNormal.z ) / 8.0
	);
	
	// bump mapping
	vec3 uaxis = normalize(cross(vec3(0.0,1.0,0.0), info.m_surfaceNormal));
	vec3 vaxis = normalize(cross(uaxis, info.m_surfaceNormal));
	mat3 mattanspace = mat3
	(
		uaxis,
		vaxis,
		info.m_surfaceNormal
	);
	
	float delta = -1.0/512.0;
	float A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
	float B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;
	
	vec3 norm = normalize(vec3(B - A, C - A, 0.25));
	
	info.m_surfaceNormal = normalize(mattanspace * norm);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 3363
vec3 sphereNormal(vec3 coord, vec3 center){
	return normalize(coord-center);
}

// Function 3364
vec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )
{
    return vColor;
}

// Function 3365
void surface2x3_ortho_plane(in surface2x3 surf, float x,
	out surface2x2 slice) {
	float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
	float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];
	float G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];
    float J = surf.c[9];

    // y -> y
    // z -> x
    slice.c[0] = C;
    slice.c[1] = B;
    slice.c[2] = F;
    slice.c[3] = E*x + I;
    slice.c[4] = D*x + H;
    slice.c[5] = (A*x + G)*x + J;
}

// Function 3366
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) 
{
	// ray-box intersection in box space
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
	if( tN > tF || tF < 0.0) return vec2(-1.0);

	return vec2( tN, tF );
}

// Function 3367
float xBox( vec3 p, vec2 b )
{
	vec2 d = abs(p.zy) - b;
    return min(max(d.x,d.y),0.0) +
           length(max(d,0.0));
}

// Function 3368
float
capped_cylinder_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;
    return min( max(d), 0.0 ) + length( max(d, 0.0) );
}

// Function 3369
float sdCone( in vec3 p, in vec3 c )
{
    vec2 q = vec2( length(p.xz), p.y );
	return max( max( dot(q,c.xy), p.y), -p.y-c.z );
}

// Function 3370
void m1_plane(inout ray r, rObj o) {
    r.pos.y += EPSILON * 2.;
    r.dir = hashRot(reflect(r.dir, vec3(0,1,0)), 0.15);
	//r.dir = reflect(r.dir, hashRot(vec3(0,1,0), 0.01));
    r.col *= vec3((int(mod(floor(r.pos.x), 2.0)) ^ int(mod(floor(r.pos.z), 2.0))) == 0 ? 0.5 : 0.6);
}

// Function 3371
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3372
void sphereClip(
    in vec3 center, in float radius,
    in vec3 p, in vec3 v,
    out vec2 tRange, out float didHit
) {
    // Solve quadratic in t: |p+tv - center|^2 = radius^2
    // Or, |A+tB|^2 = 1, with A = (p-center)/radius, B = v/radius
    // Solution: t = (-A.B +- sqrt(D))/|B|^2, D = (A.B)^2 + |B|^2 * (1-|A|^2).

    vec3 A = (p - center) / radius;
    vec3 B = v / radius;

    float AA = dot(A,A);
    float AB = dot(A,B);
    float BB = dot(B,B);

    float D = AB*AB + BB*(1.0 - AA);
    float sqD = sqrt(abs(D));
    didHit = 1.0 - step(D, 0.0);

    float t0 = (-AB + sqD)/BB;
    float t1 = (-AB - sqD)/BB;
    tRange = vec2(min(t0,t1), max(t0,t1));
}

// Function 3373
float CheckersGradBox(vec2 p)
{ // iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm
    vec2 w = fwidth(p) + .001;
    vec2 i = 2.0 * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;
    return .5 - .5*i.x*i.y;
}

// Function 3374
vec3 getPlaneColor(in vec3 ro, in vec3 rd, in float t, in int i, in int j) {
    vec3 f = (Weights[i]-Weights[j]).xyz;
    f = normalize(f);
    return lighting(ro + rd*t, rd, f.xyz, Colors[int(weightToClassMap[i])]);
}

// Function 3375
void intersectSphere(inout Surface surface, vec3 p)
{
    float d = sphere(p, 0.1);
    float b1 = sdBox(p, vec3(10.0, 0.02, 10.0));
    float b2 = sdBox(p, vec3(0.02, 10.0, 10.0));
    float b3 = sdBox(p, vec3(10.0, 10.0, 0.02));
    float s = sphere(p, 0.098);
    d = max(-b1, d);
    d = max(-b2, d);
    d = max(-b3, d);
    d = max(-s, d);
    
    
    if (d < surface.dist) {
        surface.dist = d;
        surface.diffuse = vec3(0.25);
        surface.specular = vec3(0.15);
        surface.roughness = 10.0;
        surface.emission = vec4(1.0, 0.25, 0.35, 1.0);
        surface.pattern = normalize(p);
    }
    
    float dd = sphere(p, 0.08);
    if (dd < d) {
        surface.dist = dd;
        surface.diffuse = vec3(0.25);
        surface.specular = vec3(0.15);
        surface.roughness = 5.0;
        surface.emission = vec4(1.0, 0.25, 0.35, 1.0);
        surface.pattern = vec3(0.0);
    }
}

// Function 3376
float sphereSdf(vec3 p, float r) 
{
    p.z -= r;
    return length(p) - r;
}

// Function 3377
float sd_box(vec3 p, vec3 b) {
  vec3 q  = abs(p) - b;
  return max(max(q.x, q.y), q.z);
}

// Function 3378
float sdSphere(vec3 p, float r)
{
  return length(p) - r;
}

// Function 3379
float ground_plane_intersect( vec3 ray_dir, vec3 origin, float ground, out vec3 pos, out vec3 norm ) {
    if( ray_dir.y >= 0.0 ) {
        return maximum_dist;
    }
    float t = ( ground-origin.y ) /  ray_dir.y; 
    norm = vec3( 0.0, 1.0f, 0.0f );
    pos = origin + ray_dir*t;
    return t;
}

// Function 3380
float hybridbox(in vec3 ro, in vec3 rd, in vec3 r, out vec3 n, in bool entering) {
    // first check for intersection with the basic primitive
    float t = box(ro, rd, r, n, entering);
    if (t > 0.) {
        // refine the distance to the perturbed surface through raymarching
        for (int i=0; i<RAYMARCH_STEPS; i++) {
            float dist = boxsdf(ro + t*rd, r);
            t += (entering ? dist : -dist);
            if (dist < RAYMARCH_TOL) {
                n = boxgrad(ro + t*rd, r);
                return t;
            }
        }
    }
    return -1.;
}

// Function 3381
float sphere(vec3 p, vec3 c, float r) {
   return length(p-c) - r;
}

// Function 3382
float fBoxCheap(vec3 p, vec3 b) { //cheap box
	return vmax3(abs(p) - b);
}

// Function 3383
vec3 planeNorm(vec3 p, float id){
   
    if(id<1.5) return normalize(vec3(0, 0, -1));
    else return normalize(vec3(0, 1, 0));
    
}

// Function 3384
float roundBox(vec2 p, vec2 b, float r) {
	return length(max(abs(p)-b,0.0))-r;
}

// Function 3385
float IntersectSphere(Ray r, Sphere s) {
    vec3 Z = r.o-s.c;
    float A = 1.0;//r.d.x*r.d.x+r.d.y*r.d.y+r.d.z*r.d.z; // 1.0 if r.d normalized
    float B = 2.0 * dot(r.d, Z);//(r.d.x * (r.o.x - s.c.x) + r.d.y * (r.o.y - s.c.y) + r.d.z * (r.o.z - s.c.z));
    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-s.r*s.r;//(r.o.x - s.c.x)*(r.o.x - s.c.x) + (r.o.y - s.c.y)*(r.o.y - s.c.y) + (r.o.z - s.c.z)*(r.o.z - s.c.z) - s.r*s.r;
    float D = B*B - 4.0*C;
    float t = -1.0;
    float d = -1.0;
    if(D>=0.0) {
        /*t = (- B - sqrt(D)) / 2.0;
        if(t>0.0) { // okay this is the closest one
        }else{ // nope we recompute
            t = (- B + sqrt(D)) / 2.0;
        }
        d = t;*/
        // self-made optimisation only one sqrt in both cases
        if(C>0.0) {
            d = (-B-sqrt(D))/2.0;
        }else{
            d = (-B+sqrt(D))/2.0;
        }
    }
    return d;
}

// Function 3386
float DE_Cone( vec3 p, vec2 c )
{
    // c must be normalized
    float q = length(p.xz);
    return dot(c,vec2(q,p.y));
}

// Function 3387
bool IsSphere(Object obj)
{
	return obj.radius > 0.0;
}

// Function 3388
vec3 sampleHemisphereCosWeighted( in float Xi1, in float Xi2 ) {
    float theta = acos(clamp(sqrt(1.0-Xi1),-1.0, 1.0));
    float phi = TWO_PI * Xi2;
    return sph2cart( 1.0, phi, theta );
}

// Function 3389
float sdSphere( vec3 p, float r )
{
	return length(p) - r;
}

// Function 3390
float sdBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.));

}

// Function 3391
bool box(vec3 ro, vec3 rd, vec3 lb, vec3 rt, out float t) {
    vec3 inv = 1.0 / rd;
    
    vec3 t0 = (lb - ro) * inv;
    vec3 t1 = (rt - ro) * inv;
    
    vec3 max0 = max(t0, t1);
    vec3 min0 = min(t0, t1);
    
    float tmax = min(min(max0.x, max0.y), max0.z);
    float tmin = max(max(min0.x, min0.y), min0.z);

    t = tmin;

    return (tmax < 0.0 || tmin > tmax) ? false : true;
}

// Function 3392
float sphere4d(vec4 p, float radius){
    return length(p) - radius; 
}

// Function 3393
float sdSphere( vec3 p, float s )
{
    return length(p) - s;
}

// Function 3394
void drawCylinder(Ray ray, inout TraceResult cur_ctxt)
{
    vec3 cylNorm;
    float cylT = traceCylinder(ray.pos, ray.dir, cylNorm);
    
    if(cylT < cur_ctxt.t)
    {
        cur_ctxt.t = cylT;
        
        vec3 worldPos = cur_ctxt.t * ray.dir + ray.pos;
    
        cur_ctxt.materialType = DIFFUSE; 
        cur_ctxt.color = 0.3*texture(iChannel2, worldPos.xz * worldPos.y).rgb 
                                        + 0.7*texture(iChannel3, ray.dir).rgb;
        //cur_ctxt.color = vec3(1, 0, 0);
        cur_ctxt.n = cylNorm;
    }
}

// Function 3395
float Sphere( vec3 p, vec3 c, float r )
{
	return length(p-c) - r;
}

// Function 3396
float fBox(vec3 p, vec3 b) 
{
	vec3 d=abs(p)-b;
    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));
}

// Function 3397
float sdBox(vec3 p,vec3 b)
{
	vec3 d = abs(p) - b;
  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 3398
float getDist2Plane(vec3 camPos, vec3 ray) {
    float ang = getAngle(vec3(0.0, - 1.0, 0.0), ray);
    float dist = abs(camPos.y);
    if (hitPlane(camPos, ray) < 0.0) {
        return dist / cos(ang);
    } else {
        return INFTY;
    }
}

// Function 3399
vec3 cosWeightedRandomHemisphereDirection( const vec3 n ) {
  	lowp vec2 r = hash2();
	lowp vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );
	lowp vec3  vv = cross( uu, n );
	lowp float ra = sqrt(r.y);
	lowp float rx = ra*cos(6.2831*r.x); 
	lowp float ry = ra*sin(6.2831*r.x);
	lowp float rz = sqrt( 1.0-r.y );
	lowp vec3  rr = vec3( rx*uu + ry*vv + rz*n );
    return normalize( rr );
}

// Function 3400
float sdRoundedCylinder( vec3 p, float R, float r, float h )
{
  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;
}

// Function 3401
float sdBoxMinusSphere( in vec3 pos, in float radius)
{
  return opDifference (udRoundBox(pos, vec3(0.15), 0.05)
                      ,sdSphere(  pos, radius - 0.012 + 0.02*sinTime));
}

// Function 3402
float PlaneDist( const in vec3 vPos, const in vec4 vPlane )
{
    return dot(vPlane.xyz, vPos) - vPlane.w;
}

// Function 3403
float cylinderAppSurface(vec3 view, vec3 axis, float radius, float height){
    float res=0.f;
	res+= diskAppSurface(view, axis, radius, false);
	res+= tubeAppSurface(view, axis, radius, height);
    return res;
}

// Function 3404
float box (vec3 p, vec3 c)
{
    vec3 q = abs(p)-c;
    return min(0., max(q.z,max(q.x,q.y))) + length(max(q,0.));
}

// Function 3405
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = ro - sph.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - sph.w * sph.w;
    float h = b * b - c;
    if (h < 0.0) return -1.0;

	float s = sqrt(h);
	float t1 = -b - s;
	float t2 = -b + s;
	
	return t1 < 0.0 ? t2 : t1;
}

// Function 3406
void loadBSphere(sampler2D txBuf, int idBody, inout vec3 c, inout float r) {
    vec4 pc = Loadv4(txBuf, idBody*SIZEOF_BODY);
    r = pc.w;
    c = pc.xyz;
}

// Function 3407
vec3 vecInHemisphere(vec3 dir, float phi, float sina, float cosa) {
    // Define a local frame from the normal
	vec3 w = normalize(dir), u = normalize(cross(w.yzx, w)), v = cross(w, u);
   
	return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;
}

// Function 3408
float shortestDistanceToSpheres(Ray ray) {

    float depth = MIN_DIST;// distance marched 
    //start raymarching loop
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        //distance from sphere
        float dist = spheresSDF(ray.origin + depth * ray.direction);
        //hit a sphere
        if (dist < EPSILON) {
            return depth;
        }
        depth += dist;
        //didnt hit a sphere
        if (depth >= MAX_DIST_SHADOW) {
            return MAX_DIST_SHADOW;
        }
    }
    return MAX_DIST_SHADOW;
}

// Function 3409
float sdTorus(vec3 p, vec2 r){
    float x = length(p.xz)-r.x;
    return length(vec2(x, p.y))-r.y;
}

// Function 3410
vec3 hemisphere_cosine_random()
{
	/* see http://people.cs.kuleuven.be/~philip.dutre/GI/TotalCompendium.pdf (19a + 35) */
	float r1 = rand();
	float r2 = rand();
	float r = sqrt(r1);
	float phi = 6.2830 * r2;

	return vec3(
		r * cos(phi),
		r * sin(phi),
		sqrt(1.0 - r*r));
}

// Function 3411
float raytracePlane(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    vec3 p = ro - planePos;
    float t = -p.y / rd.y;
    if (t > tmin && t < tmax) {
        return t;
    }
    return -1.0;
}

// Function 3412
float sdf_cbox(in vec3 p, in float l)
{
    float fmax = 10000000.0;
    float b0 = sdf_sbox(p, vec3(fmax, l, l));
    float b1 = sdf_sbox(p, vec3(l, fmax, l));
    float b2 = sdf_sbox(p, vec3(l, l, fmax));
    return min(b0, min(b1, b2));
}

// Function 3413
vec3 getHemisphereGGXSample(vec3 n, vec3 v, float roughness, out float weight) {
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;
    
    float epsilon = clamp(getRandom(), 0.001, 1.);
    float cosTheta2 = (1. - epsilon) / (epsilon * (alpha2 - 1.) + 1.);
    float cosTheta = sqrt(cosTheta2);
    float sinTheta = sqrt(1. - cosTheta2);
    
    float phi = 2. * M_PI * getRandom();
    
    // Spherical to cartesian
    vec3 t = normalize(cross(n.yzx, n));
    vec3 b = cross(n, t);
    
	vec3 microNormal = (t * cos(phi) + b * sin(phi)) * sinTheta + n * cosTheta;
    
    vec3 l = reflect(-v, microNormal);
    
    // Sample weight
    float den = (alpha2 - 1.) * cosTheta2 + 1.;
    float D = alpha2 / (M_PI * den * den);
    float pdf = D * cosTheta / (4. * dot(microNormal, v));
    weight = (.5 / M_PI) / (pdf + 1e-6);
    
    if (dot(l, n) < 0.)
        weight = 0.;
    
    return l;
}

// Function 3414
float box( vec3 p ) {
	float s = sin(time);
	float c = cos(time);
	p -= vec3(0.,s,1.); // translate
	float xn = c * p.x - s * p.z;
	float zn = s * p.x + c * p.z;
	p = vec3(xn, p.y, zn); // rotate
	return length(max(abs(p)-vec3(0.4),0.0));
}

// Function 3415
float sphere(vec3 p,float r){
    return length(p)-r;
}

// Function 3416
float sphere(vec3 v, float r){
  return length(v)-r;
}

// Function 3417
float cboxc3(vec2 p,float s){s*=.5;p+=s*.5
 ;vec2 a=abs(p)+s
 ;return -length(a)+1.  //vec2(.1)offsets a circle s is needed in here for scaling,within offset,and thats pretty bad style
 //;return(length(max(vec2(0),abs(p)-s*.5)))
 ;}

// Function 3418
bool rayPlaneIntersection( Ray ray, Plane plane, out float t ){
    float dotVN = dot( ray.dir, plane.abcd.xyz );
   
	t = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;
    return ( t > 0.0 );
}

// Function 3419
RaycastHit intersectSphere(vec3 position, float radius, const Ray ray) {
    
	float a = dot(ray.dir, ray.dir);
    float b = 2. * dot(ray.dir, ray.ori - position);
    float c = dot(ray.ori - position, ray.ori - position) -(radius * radius);
    float det = (b * b) - 4. * a * c;

	float lambda = (-b -sqrt(det)) / (2. * a);
	vec3 p = ray.ori + lambda * ray.dir;
	vec3 n = p - position;
    
    return RaycastHit(p,normalize(n),(det >= 0. && lambda >= 0.) ? 0 : -1);
        
}

// Function 3420
float sdPlaneX(vec3 p) {
	return abs(p.x);
}

// Function 3421
float
torus33_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);
    return length3(abs(q))-torus.y;
}

// Function 3422
float line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {
    float determinant = dot(direction, plane_normal);
    float zero = 0.0;
    if(determinant == 0.0)
        return zero/zero;
    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;
    return parallel_distance;
}

// Function 3423
void intersect_ray_plane(vec3 origin, vec3 direction, vec3 plane_normal, float plane_offset, out float near)
{
    float t = -(dot(plane_normal, origin) + plane_offset) / dot(plane_normal, direction);
    near = t * length(direction);
}

// Function 3424
float planet(vec3 p) {
    return (sphere(p,planet_size))*scale/10.0;
}

// Function 3425
float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )
{
    vec2 q = vec2( length(p.xz), p.y );
    
    vec2 k1 = vec2(r2,h);
    vec2 k2 = vec2(r2-r1,2.0*h);
    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 3426
vec2 getUVSphere(vec3 p)
{
	p = normalize(p);
	float x = atan(p.z, p.x) / TWOPI;
	float y = asin(p.y) / PI;
	
	return vec2(0.5) + vec2(x,y);
}

// Function 3427
vec2 closestPointOnBox(vec2 P, vec2 p, vec2 b){
    vec2 pB = max(abs(P-p)-b,0.0);
    vec2 d = P - pB;
    if(P.x < p.x-b.x){ d.x = P.x + pB.x; }
   	if(P.y < p.y-b.y){ d.y = P.y + pB.y; }
    return d;
}

// Function 3428
float sdCone( in vec3 p, in vec2 c ) {
  vec2 q = vec2( length(p.xz), p.y );

  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)/dot(c,c), 0.0, 1.0 );
  vec2 b = q - c*vec2( clamp( q.x/c.x, 0.0, 1.0 ), 1.0 );
  
  float s = -sign( c.y );
  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),
			    vec2( dot( b, b ), s*(q.y-c.y)  ));
  return -sqrt(d.x)*sign(d.y);
}

// Function 3429
float sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )
{
  return dot(p - p0, normalize(cross(p0 - p1, p0 - p2)));
}

// Function 3430
bool UI_DrawWindowCloseBox( inout UIContext uiContext, Rect closeBoxRect )
{
	if (!uiContext.bPixelInView || !Inside( uiContext.vPixelCanvasPos, closeBoxRect ))
        return false;
    
    vec2 vCrossPos = closeBoxRect.vPos + closeBoxRect.vSize * 0.5;        
    vec2 vCrossSize = closeBoxRect.vSize * 0.5 * 0.4;
    vec4 crossColor = vec4(0.0, 0.0, 0.0, 1.0);

    vec2 vCrossSizeFlip = vCrossSize * vec2(1.0, -1.0);
    
    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSize, vCrossPos + vCrossSize, 2.0f, crossColor, uiContext.vWindowOutColor );
    DrawLine( uiContext.vPixelCanvasPos, vCrossPos - vCrossSizeFlip, vCrossPos + vCrossSizeFlip, 2.0f, crossColor, uiContext.vWindowOutColor );
    
    return true;
}

// Function 3431
float torusSDF(vec3 p, vec2 t)
{
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 3432
bool intersectWithSphere(vec3 rayOrig, vec3 rayDir, vec3 sphereCenter, float sphereRadius, inout float t)
{
    vec3 op = rayOrig - sphereCenter;

	//float A = dot(rayDir, rayDir); //rayDir is normalized
	float B = dot(op, rayDir);
	float C = dot(op, op) - sphereRadius*sphereRadius;

	float delta = B*B - C;
	if (delta < 0.f)
		return false;

	float sqrDelta = sqrt(delta);
	float t1 = -B - sqrDelta;
	float t2 = -B + sqrDelta;
	if(t1 > t2)
    {
        float tt = t1;
        t1 = t2;
        t2 = tt;
    }
    
    if(t1 < 0.0001)
    {
        if(t2 < 0.0001) return false;
     	t1 = t2;   
    }
    
	if(t1 > t) return false;
    t = t1;
    
    return true;
}

// Function 3433
void plane_intersect(Plane pl, Ray ray, inout Intersection isect)
{
    float d = -dot(pl.p, pl.n);
    float v = dot(ray.dir, pl.n);


    // Check if the plane is parallel to the ray.
    if (abs(v) < 1.0e-6)
        return;

    float t = -(dot(ray.org, pl.n) + d) / v;

    if ( (t > 0.0) && (t < isect.t) )
    {
        isect.hit = 1;
        isect.t   = t;
        isect.n   = pl.n;

        vec3 p = vec3(ray.org.x + t * ray.dir.x,
                      ray.org.y + t * ray.dir.y,
                      ray.org.z + t * ray.dir.z);
        isect.p = p;
        float offset = 0.2;
        vec3 dp = p + offset;

        if (dpmod(dp.x) * dpmod(dp.y) * dpmod(dp.z) < 0.0)
            isect.col = pl.col1;
        else
            isect.col = pl.col2;
    }
}

// Function 3434
void sphereFold(inout vec3 z, inout float dz){
	float r2 = dot(z,z);
	if (r2 < 0.5){ 
		float temp = 2.0;
		z *= temp;
		dz*= temp;}
    else if (r2 < 1.0){ 
		float temp = 1.0/r2;
		z *= temp;
		dz*= temp;}}

// Function 3435
void sphereFold(inout vec3 z, inout float dz) 
{
    float r2 = dot2(z);
    if(r2 < MinRadius2) 
    {
        float temp = FixedRadius2 / MinRadius2;
        z *= temp;
        dz *= temp;
    }
    else if(r2 < FixedRadius2) 
    {
        float temp = FixedRadius2 / r2;
        z *= temp;
        dz *= temp;
    }
}

// Function 3436
float iSphere(in vec3 ro, in vec3 rd, in vec4 sph)
{
	//sphere at origin has equation |xyz| = r
	//sp |xyz|^2 = r^2.
	//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),
	//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:
	vec3 oc = ro - sph.xyz; //distance ray origin - sphere center
	
	float b = dot(oc, rd);
	float c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.
	
	float t;
	if(h < 0.0) 
		t = -1.0;
	else
		t = (-b - sqrt(h)); //Again a = 1.
	return t;
}

// Function 3437
float boxDist(vec2 p, vec4 b) {
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
}

// Function 3438
float box(vec3 p, vec3 b)
{
  return length(max(abs(p) - b, 0.0));
}

// Function 3439
float sdTorus88( vec3 p, vec2 t )
{
    
  vec2 q = vec2(length8(p.xy)-t.x,p.z);
  return length8(q)-t.y;
}

// Function 3440
vec3 RandomPointInSphere( vec3 seed )
{
    vec3 r3 = rand3( seed );
    // https://mathworld.wolfram.com/SpherePointPicking.html
    float theta = r3.x * TWOPI;
    float z = r3.y * 2.0 - 1.0;
    float r = sqrt( 1.0 - z * z );
    vec3 pointOnSphere = vec3( r * cos( theta ), r * sin( theta ), z );
    return pointOnSphere * pow( r3.z, 0.33333 );
}

// Function 3441
float fBox(vec2 p,float b){vec2 d=abs(p)-b,q=min(d,0.);return length(max(d,0.))+ma2(q);}

// Function 3442
vec4 makeplane(vec3 p, vec3 q, vec3 r) {
  vec3 n = cross(q-p,r-p);
  n = normalize(n);
  float k = dot(p,n);
  // Fix so that away from origin is +ve distance
  if (k < 0.0) { k = -k; n = -n; }
  return vec4(n,k);
}

// Function 3443
float SphereTracing(vec3 o, vec3 u, out bool h, out int s)
{
    float kGlobal = KGlobal();
    float t = ra;
  	h = false;	
    s = 0;
  	for(int i = 0; i < StepsMax; i++)
    {
        vec3 p = o + t * u;
        float v = Object(p);
        s++;

        // Hit object
        if (v > 0.0)
        {
            h = true;
            break;
        }
        
        // Move along ray
        t += max(Epsilon, abs(v) / kGlobal);
        
        // Escape marched far away
        if (t > rb)
            break;
	}
    return t;
}

// Function 3444
float plane( in vec4 pla, in vec3 ro, in vec3 rd )
{
    float de = dot(pla.xyz, rd);
    de = sign(de)*max( abs(de), 0.001);
    float t = -(dot(pla.xyz, ro) + pla.w)/de;
    return t;
}

// Function 3445
float iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {
    lowp vec3 oc = ro - sph.xyz;
    lowp float b = dot(oc, rd);
    lowp float c = dot(oc, oc) - sph.w * sph.w;
    lowp float h = b * b - c;
    if (h < 0.0) return -1.0;

	lowp float s = sqrt(h);
	lowp float t1 = -b - s;
	lowp float t2 = -b + s;
	
	return t1 < 0.0 ? t2 : t1;
}

// Function 3446
float IntersectQuadOrPlane(Ray ray, Object quad, bool isInfinitePlane, bool twoSided)
{
	vec3 V = quad.pos - ray.origin;
	float t = 0.0;
	float d = dot(ray.dir, quad.quadNormal);
	if (d < 0.0 || twoSided) {
		t = max(0.0, dot(V, quad.quadNormal)/d);
		if (t > 0.0 && !isInfinitePlane) {
			V -= t*ray.dir;
			float vx = dot(V, quad.quadBasisX); // note quadBasis is divided by extent
			float vy = dot(V, quad.quadBasisY);
			if (max(abs(vx), abs(vy)) > 1.0)
				t = 0.0;
		}
	}
	return t;
}

// Function 3447
float traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, float dis_flag) 
{
    float dis = dis_flag * 0.085 * sin(16.0 * (pos.x + dir.x)) 
                                 * sin(16.0 * (pos.y + dir.y))
                                 * sin(16.0 * (pos.z + dir.z));
    float a = dot(dir, dir);
    float b = dot(pos, dir);
    float c = dot(pos, pos) - (r + dis) * (r + dis);
    float D = b * b - a * c;
    
    if (D < 0.0) 
    {
        return INF;
    }
    
    float t = -b - sqrt(D);
    if (t > 0.0) 
    {
        normal = normalize(pos + t * dir);
        return t;
    }
    
    t = -b + sqrt(D);
    if (t < 0.0) 
    {
        return INF;
    }
    
    normal = normalize(pos + t * dir);
    return t;
}

// Function 3448
float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));
}

// Function 3449
float sdBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
  	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

// Function 3450
void intersect_plane_edge(int mc, vec4 plane, vec3 ro, vec3 rd, inout vec3 edge_near, inout vec3 edge_far, inout bvec2 has_edge) {
    float d = intersect_plane_line(plane, ro, rd);
    if (abs(d) < 1.0) {
        vec3 p = viewspace(ro + rd * d);
        float d;
        if (mc == 0) {
            d = dFrustumV(p);
        } else {
            d = dFrustumH(p);
        }
        if (d <= 0.0) {
            if (!has_edge[0] || (p.z < edge_near.z)) {
                edge_near = p;
                has_edge[0] = true;
            }
            if (!has_edge[1] || (p.z > edge_far.z)) {
                edge_far = p;
                has_edge[1] = true;
            }
        }
    }
}

// Function 3451
vec3 SphereMap(vec3 vert) {
    vec3 inormal = normalize(vert);
    float ndist = length(inormal);
    float ncross = atan(inormal.x, inormal.z);
    float ncross2 = atan(length(inormal.xz), inormal.y);
    vec2 ncase = vec2(ncross, ncross2)/vec2(-maxAng, -maxAng);
    vec4 wmap = texture(iChannel0, ncase+0.5);
    return wmap.rgb;
}

// Function 3452
float box(vec2 p){ p= abs(p); return max(p.x, p.y); }

// Function 3453
float opRepSphere( vec3 p, vec3 c )
{
    vec3 q = mod(p,c)-0.5*c;
    return sdSphere( q, RADIUS );
}

// Function 3454
vec3 closestPointToTorus( vec3 p, float ra, float rb )
{
    float l = length(p.xz);
    vec3  q = vec3(ra*p.x/l,0.0,ra*p.z/l);
    return q + rb*normalize(p-q);
}

// Function 3455
vec4 iconUIBox(ivec2 idx) {
    
    vec2 iconCtr = iconsBox.xy;
    
    iconCtr = floor(iconCtr+0.5);
    
    vec2 scl = vec2(2.5*iconSize, 3.*iconSize);
    iconCtr += vec2(float(idx.x), float(-idx.y))*scl + vec2(-2., 0.5)*scl; 
    
    return vec4(iconCtr, vec2(iconSize));
    
}

// Function 3456
float atmosphere(float r, float w, in vec3 c, in Ray R, in vec3 light_pos) {
    
    /*
		returns atmospheric light
		
		r : radius
        w : width in percentage of r
        c : center
	*/
    
    vec3 light = normalize(c - light_pos);
    
    float r1 = r;     // outer radius
    float r2 = w*r;   // inner radius
    
    // ray cast of two concentric balls
    vec3 r1m, r1p, r2m, r2p;
    bool hit1 = ball_hit(r1, c, R, r1m, r1p);
    if (!hit1) return 0.0;    
    bool hit2 = ball_hit(r2, c, R, r2m, r2p);

    // ray parameter start - stop
   	float t0 = length(r1m - R.pos);
    float t1 = hit2 ? length(r2m - R.pos) : length(r1p - R.pos);
    
    // integrate atmosphere normal along ray
    vec3 integ_n = integral(c, R, t1) - integral(c, R, t0);
    
    // return integrated light along ray
    return (1.0/r1)*dot(integ_n, -light);
}

// Function 3457
vec3 CollideSphere(vec3 pos, float radius)
{
#if 0
    float d;
    vec3 n = SceneNormal(pos, radius, d);
    pos -= n * min(0., d - radius * .7); // collision
    n = SceneNormal(pos, radius, d);
    pos -= n * min(0., d - radius * .9); // again!
    n = SceneNormal(pos, radius, d);
    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices
    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case
#endif
    return pos;
}

// Function 3458
Box intersectBox(Box A, Box B){
	return Box(max(A.min, B.min), min(A.max, B.max));   
}

// Function 3459
float MapPlane( vec3 p)
{
  float  d=100000.0;
  vec3 pOriginal = p;
  // rotate position 
  p=TranslatePos(p, pitch, roll);
  float mirrored=0.;
  // AABB TEST  
  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    
  if (test>1.0) return test;

  // mirror position at x=0.0. Both sides of the plane are equal.
  mirrored = pMirror(p.x, 0.0);

  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));
  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);
  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   

  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   

  // window
  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));
  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);
  winDist = max(winDist, -body);
  body = min(body, winDist);
  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));
  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));

  // front (nose)
  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));
  checkPos = p-vec3(0, 0, 2.5);
  pR(checkPos.yz, 1.57);
  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);
  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);

  // wings       
  frontWingDist = MapFrontWing(p, mirrored);
  d=min(d, frontWingDist);   
  rearWingDist = MapRearWing(p);
  d=min(d, rearWingDist);
  topWingDist = MapTopWing(p, mirrored);
  d=min(d, topWingDist);

  // bottom
  checkPos = p-vec3(0., -0.6, -5.0);
  pR(checkPos.yz, 0.07);  
  d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);

  float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  
  checkPos = p;
  pR(checkPos.yz, 0.85);
  holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); 
  d=fOpUnionRound(d, holder, 0.25);

  // large bomb
  bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   
  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   
  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   

  d=min(d, bombDist2);

  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    

  checkPos = p- vec3(0, 0.2, -5.0);
  d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);

  d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);

  // engine cutout
  blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); 
  d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.45, 2.4)); 

  // engine
  d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));

  engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);
  checkPos = p- vec3(0.4, -0.1, -8.3);
  pR(checkPos.yz, 1.57);
  engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));
  engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));

  checkPos = p-vec3(0., 0., -9.24);  
  checkPos.xy-=vec2(0.4, -0.1);
  checkPos.xy = pModPolar(checkPos.xy, 22.0);

  float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);
  engineDist=min(engineDist, engineCone);

  d=min(d, engineDist);
  eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0)*0.014), vec3(.17, 0.17, .10));
  d=min(d, eFlameDist);

  d=min(d, winDist);
  d=min(d, body);

  d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); 
  checkPos = p-vec3(0.65, 0.55, -1.4);
  pR(checkPos.yz, -0.35);
  d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));

  return min(d, eFlameDist);
}

// Function 3460
void sphereFold(inout vec3 z, inout float dz) {

				float fixedRadius2 = 2.0;
				float minRadius2  = 0.5 ;

				float r2 = dot(z,z);
				if (r2 < minRadius2) { 
					// linear inner scaling
					float temp = (fixedRadius2/minRadius2);
					z *= temp;
					dz*= temp;
				} else if (r2 < fixedRadius2) { 
					// this is the actual sphere inversion
					float temp =(fixedRadius2/r2);
					z *= temp;
					dz*= temp;
				}
			}

// Function 3461
float xorTextureGradBox( in vec2 pos, in vec2 ddx, in vec2 ddy )
{
    float xor = 0.0;
    for( int i=0; i<8; i++ )
    {
        // filter kernel
        vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  
        // analytical integral (box filter)
        vec2 f = 2.0*(abs(fract((pos-0.5*w)/2.0)-0.5)-abs(fract((pos+0.5*w)/2.0)-0.5))/w;
        // xor pattern
        xor += 0.5 - 0.5*f.x*f.y;
        
        // next octave        
        ddx *= 0.5;
        ddy *= 0.5;
        pos *= 0.5;
        xor *= 0.5;
    }
    return xor;
}

// Function 3462
float sdTorus( vec3 position, vec2 params )
{
    float R=params.x;
    float r=params.y;
    return length( vec2(length(position.xz)-R,position.y) )-r;
}

// Function 3463
float box3D (vec3 boxPos, vec3 boxSize, vec3 pos){
    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);
    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short
    return n;
}

// Function 3464
float mapBetweenSpheres(in Sphere s1, in Sphere s2, in vec3 p)
{
	return abs((length(p - s1.position) - s1.radius)-(length(p - s2.position) - s2.radius)) - 0.5;   
}

// Function 3465
float sdTorus(vec3 p, vec2 t)
{
	return length(vec2(length(p.yz)-t.x, p.x))-t.y;
}

// Function 3466
float sbox(vec3 p)
{
    return max(max(p.x, p.y), p.z);
}

// Function 3467
float cylinder( vec3 p, vec2 h )
{
  return max( length(p.xy)-h.x, abs(p.z)-h.y );
}

// Function 3468
float sphereSDF(vec2 p, float size) {
	return length(p) - size;
}

// Function 3469
float cylinder(vec3 p,vec3 dir,float h,float r)
{
    float t=dot(p,dir);
    float d=distance(p,dir*t);
    return length(max(abs(vec2(d,t))-vec2(r,h),vec2(0)));
    d=max(d,-t);
    d=max(d,t-h);
    return d;
}

// Function 3470
float UdRoundBox( vec3 p, vec3 b, float r )
{
    //vec3 vToFace = abs(p) - b;
    //vec3 vConstrained = max( vToFace, 0.0 );
    //return length( vConstrained ) - r;
    return length(max(abs(p)-b,0.0))-r;
}

// Function 3471
float squarePlane(vec3 p, Transform squareTrans)
{
    mat4 squareMat = transformMatrix(squareTrans);
    vec3 planeNormal = vec3(0, 0, 1);
    vec3 actualPoint = vec3(inverse(squareMat) * vec4(p, 1.0f));    
	return abs(dot(actualPoint, planeNormal));
}

// Function 3472
float distBox(vec3 p, vec3 b)
{
	return length(max(abs(p)-b, 0.0));
}

// Function 3473
float sdConeSection( in vec3 p, in float h, in float r1, in float r2 )
{
    float d1 = -p.y - h;
    float q = p.y - h;
    float si = 0.5*(r1-r2)/h;
    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

// Function 3474
bool sphere_intersect(const in ray r, const in float t_min, const in float t_max,
                      const in vec3 center, const in float radius, inout float dist) {
	vec3 oc = r.origin - center;
    float b = dot(oc, r.direction);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - c;
    if (discriminant < 0.0) return false;

	float s = sqrt(discriminant);
	float t1 = -b - s;
	float t2 = -b + s;
	
	float t = t1 < t_min ? t2 : t1;
    if (t < t_max && t > t_min) {
        dist = t;
	    return true;
    } else {
        return false;
    }
}

// Function 3475
float fSphere       (vec3 p,float r){return length(p)-r;}

// Function 3476
vec2 coneImpact(in vec3 pos, in vec3 ray, in vec3 O, in float H, in float R, inout vec3 norm){
    vec3 tt = vec3(INFINI);
    float t = INFINI;
    float tmin,tmed,tmax;
    vec3 normy = vec3(0.,-1.,0.);
    float dmin = 0.;
    vec3 d = O - pos;
    float Dy = H + d.y;
    float r2 = R*R/(H*H);
    float a = dot(ray.xz,ray.xz) - r2*ray.y*ray.y;
    float b = -dot(d.xz, ray.xz) + r2*Dy*ray.y;
    float c = dot(d.xz,d.xz) - r2*Dy*Dy;
    float disc = b*b - a*c;
    if (disc >= 0.){
        float sqdis = sqrt(disc);
        tt.xy = (-b + vec2(sqdis,-sqdis))/a;		// cone intercept
        if(abs(ray.y) > 0.01) tt.z = d.y/ray.y;		// bottom intercept
        tt += step(tt,vec3(0.))*INFINI; 			// eliminate neg values
		
        												/*** AA process ***/
        tmax = max(max(tt.x,tt.y),tt.z);				// sort all tt (tmin, tmed, tmax)
        tmin = min(min(tt.x,tt.y),tt.z);				// needed for AA
        vec3 ttemp = step(tt, vec3(tmin))*INFINI + tt;	//
    	tmed = min(min(ttemp.x,ttemp.y),ttemp.z);		//
        
        vec2 ofc = Dy - ray.y*tt.xy;						// checking upper-lower bounary of the cone
        tt.xy *= step(vec2(0.),ofc)*step(ofc,vec2(H));
        tt.xy += step(tt.xy,vec2(0.))*INFINI;				// eliminate outboud interception of cone
        
        tt.z += step(R,length(d.xz-tt.z*ray.xz))*INFINI;	// eliminate outboud interception of bottom 
        
        t = min(min(tt.x,tt.y),tt.z);
        vec3 p = pos+t*ray;
        
        /********************************** AA process ******************************/
        // 2 situations to deal with, depending on cone or bottom hit.
        if(t != tt.z){		// not bottom, so... cone surface
        	norm = normalize(vec3(p.x-O.x, R*R/(H*H)*(H+O.y-p.y), p.z-O.z));
            
            // depth reached by the ray must be consider on the side of the cone or at the connection with the bottom cap
            // we keep the min.
            dmin = min( abs(disc/a)/(ofc.y*R/H),	// distance inside a cone (by the sides)
                       .5*(tt.z-t) )*iResolution.x;	// distance at the border of the bottom cut
            
            #ifdef SPLIT
    		if(gl_FragCoord.x < iResolution.x/2.) 
            #endif
            // mixing the cone and the bottom normals to anti-aliase the crest created by the junction of the two faces.
            if(tt.x != INFINI) norm = mix(normy, norm, .5*min(1.,.25*abs(tmed-tmin)*iResolution.x/TH)+.5);
        }
        else{	// bottom hit
            norm = normy;
            float corr = dot(ray,-norm);
    		corr = (.05+corr)*(1.7-corr*corr*corr);		// here we add correction (same issue as the cube flat surface)
            dmin = .5*(tt.x-t)*corr*iResolution.x;		// depth reach when entering by the bottom (exiting the blind face of the cone)
            #ifdef SPLIT
    		if(gl_FragCoord.x < iResolution.x/2.) 
            #endif
            // finallly, anti-aliase the crest created by the junction of the bottom with the cone.
            // mixing normals with the bottom and the cone surface.
            if(tt.x != INFINI) norm = mix( normalize(vec3(pos.x+tmed*ray.x-O.x, 0., pos.z+tmed*ray.z-O.z)) , norm, .5*min(1.,abs(tmed-tmin)*iResolution.x/t)+.5);
        }
    }
    dmin = max(0.,dmin);
	return vec2(t,dmin);
}

// Function 3477
float sphere(in vec3 pos, in float r) {
    return length(pos) - r;
}

// Function 3478
float cullPlane(const in vec3 p) {
  return p.y >= -0.502 ? p.y + .5 : 20.0;
}

// Function 3479
vec2 sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )
{
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - ra*ra;
    float h = b*b - c;
    if( h<0.0 ) return vec2(-1.0); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

// Function 3480
vec2 spheremapPack(vec3 n)
{
    float p = sqrt(n.z * 8.0 + 8.0);
    vec2 normal = n.xy / p + 0.5;
    return normal;
}

// Function 3481
float CappedCylinder( vec3 p, vec3 cylinderOrigin, float h, float r )
{
  p = Translate(p, cylinderOrigin);
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3482
float iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)
{
	vec3  rc = ro - cylinder.c;
    float a = dot( rd.xz, rd.xz );
	float b = dot( rc.xz, rd.xz );
	float c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;
	float d = b*b - a*c;
	if( d>=0.0 )
	{
		// cylinder			
		float s = (-b - sqrt( d ))/a;
        float hy = ro.y-cylinder.c.y+s*rd.y;
		if( s>0.0 && hy<cylinder.h && hy>-cylinder.h )
		{
			return s;
		}
		// cap			
		/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;
		if( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )
		{
			return s;
		}*/
	}
    return 100000.0;
}

// Function 3483
float iSphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {
    // Thanks for IQ's ray sphere instruction
	// http://www.iquilezles.org/blog/?p=2411
	// This is relating directly to parametric equation
    // where we define a function xyz = ro + t*rd
    // solving the quadradic equation below
 	vec3 oc = ro - sph.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - rad*rad;
    float t = b*b - c;
    if( t > 0.0) 
        t = -b - sqrt(t);
    return t;
}

// Function 3484
vec4 planetSample(ivec3 p)
{
	vec3 pp = vec3(p)/iChannelResolution[0].xyx;
	float s = atan(pp.z,pp.x)/3.14159;
	float t = pp.y-0.5;
	return texture(iChannel0, vec2(s,t)/10.0);
}

// Function 3485
float sdPlane(vec3 p, vec4 n) {
    return dot(p,n.xyz)-n.w;
}

// Function 3486
float sdPlane(vec3 p, vec4 n)
{
  return dot(p,n.xyz) - n.w;
}

// Function 3487
float sdCappedCylinder( vec3 p, vec3 origin, float h, float r )
{
	p -= origin;
  	vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);
	return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3488
float d_cylinder(vec3 v, vec3 p, vec3 n, float r, float l){
	float dvn = dot(v - p, n);
	return max(
		length(v - n*dvn) - r,
		abs(dvn) - l*0.5
	);
}

// Function 3489
vec3 sphereNormal( in vec3 pos, in vec4 sph )
{
  return normalize(pos - sph.xyz);
}

// Function 3490
float sdSphere(const in vec3 p, const in float s) {
  return length(p) - s;
}

// Function 3491
float boxLid(vec3 p)
{
    p.y += 1.3;
    p.xz *= mix(1.0, 1.1, saturate((p.y - .375) * 2.5));
        
    float r = 1.0 - (smoothstep(.6, .75, abs(p.z)) + smoothstep(.6, .75, abs(p.x)));
    
    float d = fBox(p, vec3(2.6, .6, 2.6) - r * .1);
    
    vec3 rp = rotateY(p, .787);
    d = max(d, fBox(rp, vec3(3.7)));
    
    return d * .5;
}

// Function 3492
float centerBox(vec2 p) {
    p *= r2(iTime);
	float box = sdBox(p, vec2(.3)); 
    box = max(box, -sdCircle(p - vec2(0,.5), .49) + cos(iTime) * .02);
    box = max(box, -sdCircle(p - vec2(0,-.5), .49) + cos(iTime) * .02);
    return box;
}

// Function 3493
float sphere(in vec3 p, in vec2 uv) {
  vec3 truc = vec3(p.x,p.y,0.0);
  return length(truc)-1.0;
}

// Function 3494
float RAYINTERSEC_plane(vec3 o, vec3 d, vec3 po, vec3 pn)
{
    return dot(po-o,pn)/dot(d,pn); 
}

// Function 3495
float udRoundBox( vec3 p, vec3 b, float r )
{
  return abs(length(max(abs(p)-b,0.0))-r);
}

// Function 3496
float sdCone(vec3 p, vec2 c) {
    // c must be normalized
    return dot(c,vec2(length(p.zx),p.y));
}

// Function 3497
float sdBox(vec2 p, vec2 b) {
  p = abs(p) - b;
  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);
}

// Function 3498
float sphere(vec3 ro, vec3 rd)
{
    float b = dot(ro,rd);
    float c = dot(ro,ro)-1.0;
    float h = b*b-c;
    return (h<0.0)?-1.0:-b-sqrt(h);
}

// Function 3499
float d_sphere(vec3 p, vec3 c, float r)
{
  vec3 pc = p-c;
  return abs(length(pc)-r);
}

// Function 3500
vec3 raySphereIntersection(in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere)
{
    vec3 oc = rayOrigin - sphere.xyz;
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphere.w * sphere.w;
    float discriminant = b * b - 4.0 * c;
    if(discriminant < 0.0)
    {
        return vec3(-1);
    }
    else
    {
        float t = (-b - sqrt(discriminant)) / (2.0);
        vec3 endpoint = rayDir * t + rayOrigin;
        if(endpoint.y < rayOrigin.y) return vec3(-1);
        return endpoint;
    }
}

// Function 3501
float box(vec2 p, vec2 d) {
    vec2 q = abs(p)-d;
    return length(max(q,0.)) + min(0.,max(q.x,q.y));
}

// Function 3502
bool isinbox(vec2 a,vec2 s){return all(lessThan(abs(a-s*.5),s*.5));}

// Function 3503
float sdTorus(vec3 p, vec2 r) {
    float x = length(p.xz)-r.x;
    return length(vec2(x, p.y))-r.y;
}

// Function 3504
vec3 spherePos(vec2 pos, vec2 center, float rad)
{
    vec2 dir = pos - center;
    return vec3(dir, sqrt(rad * rad - dot(dir, dir)));
}

// Function 3505
float fTwoBoxes(vec3 p) {
//   float box0 = fBox(p, vec3(1));
//   float box1 = fBox(p-vec3(1), vec3(1));
//   return fOpUnionChamfer(box0, box1, 0.2);
// }

// Function 3506
bool checkBox(in vec3 box){
    float h = H3(floor(box),0.)*(emptyChance + 2.);
    return bool(int(floor( max(0.,h-emptyChance) )));
}

// Function 3507
float tracePlane(vec3 position, vec3 direction, out vec3 normal) {
    float t = (-1.2 - position.y) / direction.y;
    if (t <= 0.0) {
        return INF;
    }
    
    vec3 worldPos = position + t * direction;
    if (dot(worldPos.x, worldPos.x) >= 30.0 || dot(worldPos.z, worldPos.z) >= 30.0) {
        return INF;
    }
    
    normal = vec3(0, 1, 0);
    return t;
}

// Function 3508
float fCylinder(vec3 p, float r, float height) {
  float d = length(p.xy) - r;
  d = max(d, abs(p.z) - height);
  return d;
}

// Function 3509
float sdSphere( vec3 p, float r)
{
  return length(p)-r;
}

// Function 3510
SDFResult boxSDF2( RoundBox box, vec3 p )
{    
    p -= box.pos;
    vec3 d = abs(p) - box.dimensions;
    float l = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);

    float ridgex = mod(p.x, 1.0)-0.5;
    float ridgey = mod(p.y, 1.0)-0.5;
    float ridgez = mod(p.z, 1.0)-0.5;
    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;
    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;
    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;    
 
    return SDFResult((l - ridgex - ridgey - ridgez), box.matindex);
}

// Function 3511
vec4 sphereTexture(in sampler2D _tex, in vec2 _uv) {
  vec2 st = sphereCoords(_uv, 1.0);
  float aspect = iChannelResolution[0].y / iChannelResolution[0].x;
  st.x = fract(st.x * aspect + iTime * speedMoon);
  return textureLod(_tex, st, -16.0);
}

// Function 3512
bool intersectCylinder( in vec3 ro, in vec3 rd, in vec3 A, in vec3 B, in float radius, out float dist, out vec3 normal) {
	vec3 AB = B - A;
	vec3 AO = ro - A;
 
	float AB_dot_d = dot( AB, rd );
	float AB_dot_AO = dot( AB, AO );
	float AB_dot_AB = dot( AB, AB );
 
	float m = AB_dot_d / AB_dot_AB;
	float n = AB_dot_AO / AB_dot_AB;
 
	vec3 Q = rd - (AB * m);
	vec3 R = AO - (AB * n);
 
	float a = dot( Q, Q );
	float b = 2.0 * dot( Q, R );
	float c = dot( R, R ) - (radius*radius);
 
	if(a == 0.0) {
		float adist = 100000., bdist = 100000.;
		if(	!intersectSphere( ro, rd, vec4( A, radius ), adist, normal ) ||
			!intersectSphere( ro, rd, vec4( B, radius ), bdist, normal ) ) {
			return false;
		}
 		dist = min (adist, bdist);
		normal = normalize((ro+rd*dist) - (adist<bdist?A:B) );
		return true;
	}
 
	float discriminant = b * b - 4.0 * a * c;
	if(discriminant < 0.0) {
		return false;
	}
 
	float sqrtdis = sqrt(discriminant);
	float tmin = (-b - sqrtdis) / (2.0 * a);
	float tmax = (-b + sqrtdis) / (2.0 * a);
	if( tmin < 0. )
		tmin = tmax;
	else 
		tmin = min(tmin, tmax); 
	
	if( tmin < 0. ) return false;
	
	float t_k1 = tmin * m + n;
	float dc = 10000000.;
	
	vec3 nc;
	
	if(t_k1 < 0.0)	{		
		if(intersectSphere( ro, rd, vec4( A, radius ), dist, normal)) {
			return true;
		} else {
			return false;
		}
	}
	else if(t_k1 > 1.0) {
		if(intersectSphere( ro, rd, vec4( B, radius ), dist, normal)) {
			return true;
		} else {
			return false;
		}
	} else {
		// On the cylinder...
		vec3 p1 = ro + (rd * tmin);
 		vec3 k1 = A + AB * t_k1;
		dist = tmin;
		normal = normalize( p1 - k1 );
		return true;
	}
	return false;
}

// Function 3513
float box(vec3 p, vec3 s) {
    p=abs(p)-s;
    return max(p.x, max(p.y,p.z));
	//return length(max(p,vec3(0))) + min(0.,max(p.x,max(p.y,p.z)));
}

// Function 3514
float sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)
{
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;

    float x = sqrt( papa - paba*paba*baba );

    float cax = max(0.0,x-((paba<0.5)?ra:rb));
    float cay = abs(paba-0.5)-0.5;

    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );

    float cbx = x-ra - f*rba;
    float cby = paba - f;
    
    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;
    
    return s*sqrt( min(cax*cax + cay*cay*baba,
                       cbx*cbx + cby*cby*baba) );
}

// Function 3515
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) 
{
	vec3 rdd = rayDirection;
	vec3 roo = rayOrigin;

	// ray-box intersection
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*boxHalfSizes;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );
	
	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	vec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (abs(normal.x) > 0.9)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (abs(normal.y) > 0.9)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
    
    vec3 relPoint = roo + rdd * timeNear;
    
	uv = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);    

	return vec4( timeNear, normal );
}

// Function 3516
float intersectSphere (in Ray ray, in Sphere sphere, out vec3 normal, out vec2 uv) {
	// 
	float t_min = 0.0;
	float t_max = ray.distance;
	//   
	vec3 a = ray.origin - sphere.center;		//      
	float b = dot(a, ray.direction);
	float c = dot(a, a) - sphere.radius * sphere.radius;
	float h = b * b - c;
	if (h < 0.0) return ray.far; 				//   
	h = sqrt(h);
	float t = -b - h;
	bool flag_inside = false; 					//  
	if (t < t_min) {
		t = -b + h;
		flag_inside = true;						//  
	}
	if (t < t_min || t > t_max) return ray.far; //     
	vec3 p = ray.origin + ray.direction * t;	// 
	//  ( )
	vec3 n = p - sphere.center;
	uv = vec2(
		acos(n.y/sphere.radius)/PI,
		(atan(n.x,n.z)+PI)/(2.*PI)
	) * 0.4;
	//   
	normal = normalize(n) * (flag_inside ? -1. : 1.);

	return t;
}

// Function 3517
float box(vec3 p,vec3 s)
{
    p=abs(p)-s;
    float d=max(p.x,max(p.y,p.z));
    return max(d,length(max(p,vec3(0))));
}

// Function 3518
float intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {
	vec3  ds = ro - sph;
	float bs = dot( rd, ds );
	float cs = dot( ds, ds ) - 1.0;
	float ts = bs*bs - cs;

	if( ts > 0.0 ) {
		ts = -bs - sqrt( ts );
		if( ts > 0. ) {
			return ts;
		}
	}
	return 500.;
}

// Function 3519
float box(vec4 ray, vec3 u, vec3 size
){maxGISize = max(maxGISize,length(size)*ray.w)
 ;ray.xyz = abs(ray.xyz-u) - size
 ;return ray.w*max(max(ray.x,ray.y),ray.z);}

// Function 3520
void initLightSphere( float time ) {
	lightSphere = vec4( 2.5+2.2*sin(time),3.+2.*sin(time*0.7),6.0 + 1.0 * sin(time*1.7), 0.6 + 0.4 * sin(time*.5) );
}

// Function 3521
bool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.hitAnObject = true;
        info.objectPass = OBJECTPASS_RAYTRACE;
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
		info.material = material;        
        return true;
    }
    
    return false;
}

// Function 3522
float plane(vec3 p, vec4 n)
{
   return dot(p, n.xyz) - n.w;
}

// Function 3523
float cylinder(vec3 p, float r, float h) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3524
float l_rot_rep_torus()
{  
  	return lambda(0.6,0.5);
}

// Function 3525
float sdPlanet( vec3 p, float s )
{

    return length(p)- s + .1 * triNoise3D( p * .5 , .01 )+ .04 * sin( p.x * p.y * p.z * 10. + iTime );;//+ .03 * noise( sin(p) * 10. + p ) + .03 * sin( p.x * p.y * p.z * 10. + iTime )+ .02 * sin( p.x + p.y + p.z * 2. + iTime );//* (1.+ .4 * triNoise3D( p * .1 ,.3 ) + .2* triNoise3D( p * .3 ,.3 )) 
  
}

// Function 3526
float box( vec2 p, vec2 b )
{
  vec2 d = abs(p) - b;
  return min(max(d.x,d.y),0.0) +
         length(max(d,0.0));
}

// Function 3527
bool sSphere(in vec3 ro, in vec3 rd, in float r, out float tN, out float tF) {
	float b = dot(rd, ro), d = b*b - dot(ro, ro) + r;
	if (d < 0.) return false;
	tN = -b - sqrt(d);
	tF = -tN-b-b;
	return tF > 0.;
}

// Function 3528
float sphere(in vec3 p, in float r)
{
    return length(p) - r;
}

// Function 3529
void browseBox(in vec3 box, in vec3 pos, in vec3 ray, inout int hitObj){
    float t = INFINI;
    float hitNbr = 0.;
    for(int i=0; i<maxBoxRnge;i++){
    	vec3 newBox = getNextBox(pos,ray,box);
        vec3 d = newBox - box;
        
        if(checkBox(newBox)) {
            hitNbr ++;
            color += 1./hitNbr*((dot(-d,lightRay)+1.)*.3+.4)*vec3(.08,H3(newBox,0.)/5.,0.3);
            
            #ifdef BORDER
            vec3 o = deBox(newBox-.5*d);
            if(d.x != 0.){
                t = (o.x-pos.x)/ray.x;
                vec3 p = pos+t*ray;
                color += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));
            }
            else if(d.y != 0.){
                t = (o.y-pos.y)/ray.y;
                vec3 p = pos+t*ray;
                color += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.z-p.z)));
            }
            else if(d.z != 0.){
                t = (o.z-pos.z)/ray.z;
                vec3 p = pos+t*ray;
                color += .1*(smoothstep(.4*boxDim, .5*boxDim ,abs(o.x-p.x)) + smoothstep(.4*boxDim, .5*boxDim ,abs(o.y-p.y)));
            }
            #endif
            
            vec3 refl = reflect(ray,d);
            color += .9*skyGlow(refl);
            
            #ifdef NO_TRANSPARENCY
            if(bool(mod(newBox.y, 2.))){
                hitObj = BOX;
                break;
            }
            #endif
        }
        box = newBox;
    } 
    color = clamp(color,0.,1.);
}

// Function 3530
vec4 createSphere(vec3 pos, float radius)
{
 	return vec4(pos, radius);   
}

// Function 3531
void iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out vec4 nearInfo, out vec4 farInfo ) 
{
    // convert from ray to box space
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN > tF || tF < 0.0) {
        nearInfo = vec4(9999.0);
        farInfo = vec4(9999.0);
        return;
    }

	vec3 norN = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
	vec3 norF = -sign(rdd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);

    // convert to ray space
	
	norN = (txi * vec4(norN,0.0)).xyz;
	norF = (txi * vec4(norF,0.0)).xyz;
    
    nearInfo = vec4(tN, norN);
    farInfo = vec4(tF, norF);

}

// Function 3532
vec3 uniformSampleHemisphere(const in vec2 u) {
    float z = u[0];
    float r = sqrt(max(EPSILON, 1. - z * z));
    float phi = 2. * PI * u[1];
    return vec3(r * cos(phi), r * sin(phi), z);
}

// Function 3533
bool RayBoxIntersection(Ray r, Box b, out HitInfo hitInfo)
{
	vec3 invdir = 1.0 / (r.dir * MAX_RAY_DISTANCE);
    vec3 minC = b.pos - b.ext;
    vec3 maxC = b.pos + b.ext;
	
	vec3 p0Int = (minC - r.pos) * invdir;
	vec3 p1Int = (maxC - r.pos) * invdir;
	
	vec3 closest = min(p0Int, p1Int);
	vec3 furthest = max(p0Int, p1Int);

	float minT = max(closest.x, max(closest.y, closest.z));
	float maxT = min(furthest.x, min(furthest.y, furthest.z));
		
    if (maxT < 0.0 || minT > maxT)
    {
        return false;
    }
    
	hitInfo.t = minT * MAX_RAY_DISTANCE;
	hitInfo.pos = PointFromRay(r, hitInfo.t);
	hitInfo.mat = b.mat;
    
    if(minT == p0Int.x)
        hitInfo.normal = vec3(-1,0,0);     
    else if(minT == p1Int.x)
        hitInfo.normal = vec3(1,0,0);
    else if(minT == p0Int.y)
        hitInfo.normal = vec3(0,-1,0);
    else if(minT == p1Int.y)
        hitInfo.normal = vec3(0,1,0);
    else if(minT == p0Int.z)
        hitInfo.normal = vec3(0,0,-1);
    else// if(minT == p1Int.z)
        hitInfo.normal = vec3(0,0,1);        
        
	return true;
}

// Function 3534
float mandelbox(vec3 position){
  vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
  float C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), float(1-ITERS));
  vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
  for (int i=0; i<ITERS; i++) {
    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3, mad3
    float r2 = dot(p.xyz, p.xyz);  // dp3
    p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
    p.xyzw = p*scalevec + p0;  // mad4
  }
  return (length(p.xyz) - C1) / p.w - C2;
}

// Function 3535
float sdBoxXY( vec3 p, float b )
{
  vec2 d = abs(p.xy) - b;
  return min(max(d.x,d.y),0.0) +
         length(max(d,0.0));
}

// Function 3536
float sdf_round_box(vec3 p, vec3 b, float r)
{
    return length(max(abs(p) - b, 0.)) - r;
}

// Function 3537
vec4 dualSphereDynamicWarp(dualR3 p, float scale)
{
	return (dSqrt(dSqrX(p) + dSqrY(p) + dSqrZ(p)) - dSet(scale)) + dMul(dMul(dSet(abs(cos(iTime))), dSet(0.1) ), deformX(p, scale) );
}

// Function 3538
float fBox(vec3 p, vec3 b) {
	vec3 d = abs(p) - b;
	return length(max(d, vec3(0))) + vmax3(min(d, vec3(0)));
}

// Function 3539
float bumpSphere(in Ray ray, in Sphere s) {
	// sphere
    ray.origin -= s.pos;
    
    vec3 n = normalize(ray.origin);
    float t = iTime*.5;
    float h;
    if (mod(t, kPI * 4.0) < kPI * 2.0) {
        h = bump3d(ray, n) * (sin(t));
    } else {
        h = bumpRadial(ray, n) * (sin(t)*0.50);
    }
    return length(ray.origin) - s.radius + h;
}

// Function 3540
float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)
{ 
    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); 
}

// Function 3541
bool subtract_Sphere(in Sphere cut, in Ray r, float tmin, in HitRecord recSolid, inout HitRecord rec, in Material inside){  
 	bool hit = true;
    HitRecord recCut;    
    if(hit_sphere( cut, r, tmin, 1000.0, recCut)) //cut could be behind tmax
    {   
        hit = false;        
        // Hit the inside, starting from inside both spheres
        if(recCut.t2 < tmin && recSolid.t2 < tmin && recSolid.t > recCut.t){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        // Hit the inside, starting from inside the cut but outside the solid
        if(recCut.t2 < tmin && recSolid.t > tmin && recCut.t > recSolid.t && recCut.t < recSolid.t2){
        	rec.pos = pointOnRay(r, recCut.t);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t;
            rec.material = inside;
            return true;
        }
        // no hit, starting from inside the cut but outside the solid
        if(recCut.t2 < recSolid.t && recCut.t > recSolid.t && recCut.t2 < tmin){
            return false;
        }
        // Hit the inside
        if(recCut.t2 > recSolid.t && recCut.t2 < recSolid.t2 && recCut.t < recSolid.t){
        	rec.pos = pointOnRay(r, recCut.t2);
            rec.normal = (cut.center - rec.pos) / cut.radius;
            rec.t = recCut.t2;
            rec.material = inside;
            return true;
        }
        // Hit the outside
        if ( recCut.t > recSolid.t || recCut.t2 < recSolid.t) { // both intersections were before the hit point
            hit = true;
        }
    }
    if(hit){
        rec = recSolid;
    }
    return hit;  
}

// Function 3542
float sdPlane( vec3 p, vec4 n ) {
        return dot( p, n.xyz ) + n.w;
    }

// Function 3543
vec3 randomInHalfSphere(vec3 seed, vec3 facing)
{
    vec3 rnd = randomInUnitSphere(seed);
    float projection = dot(rnd, facing);
    if(projection > 0.0)
    {
        return rnd;
    }
    else
    {
        return rnd - 2.0*projection*facing;
    }
}

// Function 3544
float sdTorusDualMedianCircle(const vec3 p, vec2 r, float inner_circle_scale) {
  return min(   sdTorusMedianCircle(p, r,inner_circle_scale),
             sdTorusMedianCircle(-p, r,inner_circle_scale));
    
}

// Function 3545
float boxSoftShadow( in vec3 ro, in vec3 rd, in mat4 txx, in vec3 rad, in float sk ) 
{
	vec3 rdd = (txx*vec4(rd,0.0)).xyz;
	vec3 roo = (txx*vec4(ro,1.0)).xyz;

    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	
    if( tN<tF && tF>0.0) return 0.0;
    
    float sh = 1.0;
    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );
    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );
    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );
    sh = clamp(sk*sqrt(sh),0.0,1.0);
    return sh*sh*(3.0-2.0*sh);
}

// Function 3546
vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){
	sundir.y = max(sundir.y, -0.07);
	float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);
	float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);
	float raysundt = pow(abs(dot(sundir, raydir)), 2.0);
	float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);
	float mymie = sundt * special_trick * 0.2;
	vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);
	vec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;
	vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.004 * (special_trick + -6.0 * sundir.y * sundir.y));
	bluesky2 *= special_trick * (0.24 + raysundt * 0.24);
	return bluesky2 + mymie * suncolor;
}

// Function 3547
vec4 SphereMap(sampler2D sam, in vec3 p)
{
  vec2 spherePos = PosToSphere(p);
  return textureLod(sam, spherePos, 2.*log2(spherePos.y*2.));
}

// Function 3548
RaycastHit intersectPlane(vec3 position, vec3 normal, const Ray ray) {
 
    //float num = position.y - dot(normal, ray.origin);
	float num = -dot(normal,ray.origin-position);
    float denom = dot(normal, ray.direction);
	float t = num / denom;
			
	vec3 p = ray.origin + ray.direction * t;		
    
    RaycastHit hit;
    hit.point = p;
    hit.normal = normal;
    hit.det = t;
    hit.type = t > 0. ? 1 : -1;
    
    return hit;
    
}

// Function 3549
bool intersect_sphere(in Ray R, in Sphere S, out float t) {
   vec3 CO = R.Origin - S.Center;
   float a = dot(R.Dir, R.Dir);
   float b = 2.0*dot(R.Dir, CO);
   float c = dot(CO, CO) - S.R*S.R;
   float delta = b*b - 4.0*a*c;
   if(delta < 0.0) {
      return false;
   }
   t = (-b-sqrt(delta)) / (2.0*a);
   return (t > 0.0);
}

// Function 3550
float torus(vec3 pos)
{
	vec2 q = vec2(length(pos.xz)-2.0,pos.y);
  	return length(q)-0.5;   
}

// Function 3551
float sphere3(in vec3 rp) {
   	return length(rp-vec3(-5.,0.,0.))-2.;
}

// Function 3552
MarchData sdPlane(vec3 p) {
	MarchData result;
	result.mat = vec3(.29, .33, .13);
	result.isCloud = false;

	// Scale, position, rotate.
	p *= 1.5;
	p.xz *= rot(time * .6);
	p.xy -= vec2(1.5, .4);
	p.xy *= rot(sin(time * 3.) * .1);

	// Fuselage.
	vec3 ppp,
	     pp = p + vec3(0, 0, .15);
	result.d = sdBox(pp, vec2(.04 + pp.z * .05, .3).xxy);

	// Prop.
	ppp = pp;
	ppp.z -= .33;
	ppp.xy *= rot(time * 8.);
	float d = sdBox(ppp, vec3(.09, .01 * sin(length(p.xy) * 34.), .005));

	// Tail.
	pp.yz += vec2(-.05, .26);
	result.d = min(min(result.d, sdBox(pp, vec3(.01, .06 * cos(pp.z * 25.6), .03))), sdBox(pp + vec3(0, .05, 0), vec3(.15 * cos(pp.z * 12.), .01, .03)));

	// Wings
	p.y = abs(p.y) - .08;
	result.d = min(result.d, sdBox(p, vec3(.3, .01, .1)));
	if (d < result.d) {
		result.d = d;
		result.mat = vec3(.05);
	}

	result.d = (result.d - .005) * .4;
	return result;
}

// Function 3553
float rayPlane( vec3 ro, vec3 rd, vec3 po, vec3 pn )
{
    return -dot( ro - po, pn ) / dot( rd, pn );
}

// Function 3554
vec2 MapSpheres(vec3 rayPoint)
{
    float a = SDFSphere(rayPoint + vec3(+0.3, 1.6, -1.7), 0.5);
    float b = SDFSphere(rayPoint + vec3(-1.0, 1.3, -4.0), 0.8);
    
    return vec2(min(a, b), TYPE_SPHERE);
}

// Function 3555
void TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)
{
    float dist = PlaneDistance(plane, rayPos);
    if (dist < info.dist)
    {
        info.rayMarchedObject = true;
        info.dist = dist;        
        info.normal = plane.xyz;
        info.material = material;
    }    
}

// Function 3556
vec4 intersectSphere(vec3 rpos, vec3 rdir)
{
	vec3 op = vec3(0.0, 0.0, 0.0) - rpos;
	float rad = 5.0;
	
	float eps = 1e-5;
	float b = dot(op, rdir); 
	float det = b*b - dot(op, op) + rad*rad; 
		
	if (det > 0.0)
	{
		det = sqrt(det);
		float t = b - det;
		if (t > eps)
			return vec4(normalize(rpos+rdir*t), t);
	}
	
	return vec4(0.0);
}

// Function 3557
float d_box(vec3 p, vec3 pmin, vec3 pmax)
{
  vec3 ppmin = pmin-p;
  vec3 pmaxp = p-pmax;
    float dx = max(0.0, max(ppmin.x, pmaxp.x));
    float dy = max(0.0, max(ppmin.y, pmaxp.y));
    float dz = max(0.0, max(ppmin.z, pmaxp.z));
    return sqrt(dx*dx + dy*dy + dz*dz);
}

// Function 3558
float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { 
    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); 
}

// Function 3559
float intersectionSphereRay(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection){
    vec3 oc = rayOrigin - center;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc,oc) - radius*radius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant < 0.0){
        return -1.0;
    }
    else{
        return (-b - sqrt(discriminant)) / (2.0*a);
    }
}

// Function 3560
float plane(vec3 p) {
    return p.y;
}

// Function 3561
float sdBox(vec3 p, vec3 b)
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3562
float sphereSDF(vec3 p, float radius){
    return length(p) - radius; 
}

// Function 3563
vec3 CheapSkyBox(const in vec3 rayOrigin, const in rayIntersect rIntersec)
{
    vec3 sky = SkyScatterring(rIntersec.mUV, rIntersec.rd);

    //Start and End of the cloud layer
    float cloudStart = (CLOUD_LOWER - rayOrigin.y) / abs(rIntersec.rd.y);
    float cloudEnd = (CLOUD_UPPER - rayOrigin.y) / abs(rIntersec.rd.y);

    // Clouds start rayOrigin
    vec3 cloudPos = vec3(rayOrigin.x + rIntersec.rd.x * cloudStart,
                         0.0,
                         rayOrigin.z + rIntersec.rd.z * cloudStart);

    // Raymarch steps to raytrace clouds
    vec3 add = rIntersec.rd * ((cloudEnd - cloudStart) / CLOUD_SAMPLES);
    vec2 shade = vec2(0.0, 0.0);

    // x == heigh value, y == mask (density on sky)
    vec2 cloudsValue = vec2(0.0, 0.0);

    // Loop for cloud density
    for(float i = 0.0; i < CLOUD_SAMPLES; ++i)
    {
        if (cloudsValue.y >= 1.0) 
            break;

        // Intensity of the current layer
        shade.y = max(MapClouds(cloudPos) - cloudy, 0.0);

        // Heigh value of the current layer
        shade.x = i/CLOUD_SAMPLES;

        // Merging new infos with backuped one
        cloudsValue += shade * (1.0 - cloudsValue.y);
        cloudPos += add;
    }
    cloudsValue.x /= 10.0;
    cloudsValue = min(cloudsValue, 1.0);

    float cloudsIntensity = cloudsValue.x * rIntersec.rd.y;
    float sunHeight = clamp(sunDirection.y, 0.5, 1.0);
    
    // Applying contrast with cloudContrast and brightness with sunHeight
    vec3 clouds = mix(((AMBIENT_COLOR * cloudsIntensity) - 0.5) + sunHeight,
                      vec3(1.0),
                      cloudsValue.x);

    //clouds intensity by ToD
    clouds *= max(sunDirection.y, 0.05);

    //Composite sky and clouds
    return mix(sky, clouds, cloudsValue.y);
}

// Function 3564
float traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {
    float t = (-0.5 - pos.y) / dir.y;
    if (t <= 0.0) {
        return INF;
    }
    vec3 worldPos = t*dir + pos;
    if (dot(worldPos.xz, worldPos.xz) < 1.3) {
        normal = vec3(0, 1, 0);
        return t;
    }   
    
    
    float a = dot(dir.xz, dir.xz);
    float b = dot(dir.xz, pos.xz);
    float c = dot(pos.xz, pos.xz) - 1.3;
    float D = b * b - a * c;
    if (D < 0.0 ) {
        return INF;
    }
    
    t = (-b - sqrt(D)) / a;
    if (t > 0.0) {
        worldPos = t * dir + pos;
        if (worldPos.y <= -0.5) {
            normal = normalize(vec3(worldPos.x, 0, worldPos.z));
            return t;
        }
    }
     t = (-b + sqrt(D)) / a;
    if (t < 0.0) {
        return INF;
    } 
    worldPos = t * dir + pos;
    if (worldPos.y <= -0.5) {
        normal = normalize(vec3(worldPos.x, 0, worldPos.z));
        return t;
    } 
    return INF;
}

// Function 3565
float sdRoundBox( vec3 p, vec3 b, float r )
{
  vec3 q = abs(p) - (b-r);
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

// Function 3566
float distTorus(vec3 pos, float r1, float r2, vec3 z, out float ang)
{
    float pz = dot(pos,normalize(z));
    vec2 r = vec2(length(pos-z*pz)-r1,pz);
    ang = atan(r.y,r.x);
    return length(r)-r2;
}

// Function 3567
float fBox2Cheap(vec2 p, vec2 b) {return vmax(abs(p)-b);}

// Function 3568
float sphere(vec3 p, vec3 t, float radius){
    return length(p-t)-radius; //length(s)
}

// Function 3569
float box(vec3 p, vec3 pmin, vec3 pmax, float e, float R)
{
    return e*falloff(d_box(p,pmin,pmax),R);
}

// Function 3570
float box4d( in vec4 p, in vec4 b ){
    vec4 d = abs(p) - b;
    return min( max(max(d.x,d.y),max(d.z,d.w)),0.0) + length(max(d,0.0));
    //return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 3571
float sdBox(vec2 p, vec2 s){
	 p = abs(p) - s;
	return max(p.x, p.y);
}

// Function 3572
vec2 cylinderImpact(in vec2 pos,in vec2 ray, in vec2 O, in float R, inout vec2 norm){
    float t=INFINI;
    vec2 d = pos - O;
    float a = dot(ray,ray);
    float b = dot(d, ray);
    float c = dot(d,d) - R*R;
    float discr = b*b - a*c;
    if (discr >= 0.){
        t = (-b - sqrt(discr))/a;
        if (t < 0.001) t = (-b + sqrt(discr))/a;
        if (t < 0.001) t=INFINI;

        norm = normalize(pos + t*ray - O);
    }
    discr = max(0.,discr);
	return vec2(t,discr/a*iResolution.x/R);
}

// Function 3573
bool BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r, out Hit hit) {
	vec3 tbot = r.invDir * (boxMin - r.o);
	vec3 ttop = r.invDir * (boxMax - r.o);
	vec3 tmin = min(ttop, tbot);
	vec3 tmax = max(ttop, tbot);
	vec2 t = max(tmin.xx, tmin.yz);
	float t0 = max(t.x, t.y);
	t = min(tmax.xx, tmax.yz);
	float t1 = min(t.x, t.y);
	hit.tmin = t0;
	hit.tmax = t1;
return t1 > max(t0, 0.0);
}

// Function 3574
float sphere(inout ray r){
	float d=length(r.p)-0.5;	
	if(d<0.0){
		r.c=vec4(1.0);
		r.i++;
	}
	return d;
}

// Function 3575
void SphereMarchDiagram( inout vec3 o, vec2 uv )
{
    float size = iResolution.y*.55; // don't scale uv, it will break the anti aliasing
    
    if ( abs(uv.x) > .8*size || abs(uv.y) > .27*size )
        return;
    
	vec2 a = size*vec2(-.3,.1);
    vec2 b = size*vec2(.5,.0 );
    float l = length(b-a);
    
    float tt = fract(iTime/10.)*10.;
    float t[10];
    for( int i=0; i < t.length(); i++ )
    {
        t[i] = smoothstep(.0,1.,tt-float(i));
    }
    
    vec2 p0 = a;
    vec2 p1 = mix(a,b,.5);
    vec2 p2 = mix(a,b,.74);
    vec2 p3 = mix(a,b,.92);
    vec2 p4 = mix(a,b,.98);
    
    Circle( o, p4, l*.025*t[8], vec3(1,.5,.5), uv );
    Circle( o, p4, l*.015*t[8], vec3(1,0,0), uv );
    Circle( o, p3, l*.065*t[6], vec3(1,.5,.5), uv );
    Circle( o, p3, l*.055*t[6], vec3(1,0,0), uv );
    Circle( o, p2, l*.185*t[4], vec3(1,.5,.5), uv );
    Circle( o, p2, l*.175*t[4], vec3(1,0,0), uv );
    Circle( o, p1, l*.245*t[2], vec3(1,.5,.5), uv );
    Circle( o, p1, l*.235*t[2], vec3(1,0,0), uv );
    Circle( o, p0, l*.505*t[0], vec3(1,.5,.5), uv );
    Circle( o, p0, l*.495*t[0], vec3(1,0,0), uv );
    
    vec2 arrowhead = normalize(b-a)*.3*size+a;
    Line( o, a, arrowhead, size*.01, vec3(0), uv );
    Line( o, arrowhead+vec2(-.04,.06)*size, arrowhead, size*.01, vec3(0), uv );
    Line( o, arrowhead+vec2(-.06,-.05)*size, arrowhead, size*.01, vec3(0), uv );
         
    Line( o, p0, mix(p0,p1,t[1]), size*.005, vec3(1), uv );
    Line( o, p1, mix(p1,p2,t[3]), size*.005, vec3(1), uv );
    Line( o, p2, mix(p2,p3,t[5]), size*.005, vec3(1), uv );
    Line( o, p3, mix(p3,p4,t[7]), size*.005, vec3(1), uv );
    Line( o, p4, mix(p4,b,t[7]), size*.005, vec3(1), uv );
    Circle( o, p0, size*.017, vec3(1), uv );
    Circle( o, p1, size*.017*t[1], vec3(1), uv );
    Circle( o, p2, size*.017*t[3], vec3(1), uv );
    Circle( o, p3, size*.017*t[5], vec3(1), uv );
    Circle( o, p4, size*.017*t[7], vec3(1), uv );
    Circle( o, b, size*.017*t[9], vec3(1), uv );

    Line( o, size*vec2(.7,.1), size*vec2(.43,-.08), size*.02, vec3(0), uv );
    Line( o, size*vec2(.29,-.18), size*vec2(.43,-.08), size*.02, vec3(0), uv );
    Line( o, size*vec2(.29,-.18), size*vec2(.04,-.165), size*.02, vec3(0), uv );
    Line( o, size*vec2(-.1,-.3), size*vec2(.04,-.165), size*.02, vec3(0), uv );
}

// Function 3576
float mandelbox(vec3 z) 
{
    vec3 offset = z;
    float dr = 1.0;
    for(int i = 0; i < MANDELBOX_ITERATIONS; ++i) 
    {
        boxFold(z, dr);
        sphereFold(z, dr);
        z = Scale * z + offset;
        dr = dr * abs(Scale) + 1.0;
    }
    float r = length(z);
    return r / abs(dr);
}

// Function 3577
float sdTorus82(in vec3 p, in vec2 t) {
    vec2 q = vec2(length2(p.xz) - t.x, p.y);
    return length8(q) - t.y;
}

// Function 3578
float dist2box(vec2 p, float a){
	p=abs(p)-vec2(a);
	return max(p.x,p.y);
}

// Function 3579
vec3 getNormalSphere(vec3 p, Sphere sphere) {
    vec2 e = vec2(.0001, 0);
    float d = sphereSDF(p, sphere);
    vec3 n = d - vec3(
        sphereSDF(p-e.xyy, sphere),
        sphereSDF(p-e.yxy, sphere),
        sphereSDF(p-e.yyx, sphere));
    return normalize(n);
}

// Function 3580
float zBox( vec3 p, vec2 b )
{
	vec2 d = abs(p.xy) - b;
    return min(max(d.x,d.y),0.0) +
           length(max(d,0.0));
}

// Function 3581
vec3 optimizedBoxBlur(
    in sampler2D tex,
    in vec2 uv,
    in vec2 resolution,
    in vec2 direction,
    in float size,
    in int samples
) {
    float f_samples = float( samples );
    float w = 1. / f_samples;
    vec2 px = 1. / resolution;
    float increment = size / ( f_samples - 1. );
    float halfSize = size * .5;
    vec2 dpx = direction * px;

    vec3 color = vec3( 0. );
    for ( float i = -halfSize; i <= halfSize; i += increment ) {
        vec2 st = uv + dpx * i;
        color += texture( tex, st ).rgb * w;
    }
    
    return color;
}

// Function 3582
float boxSDF(vec3 p, vec3 size) {
    vec3 d = abs(p) - (size / 2.0);
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 3583
vec4 planet(vec2 uv,vec3 pos,float r,float t){
    vec2 p=(uv-pos.xy)*1./r;
    vec3 n;
    n.xy=p;
    n.z=sqrt(1.-(p.x*p.x+p.y*p.y));
    n=normalize(n);
    vec3 l=normalize(vec3(-uv,0.));
    
	
    float d = length(p);
    p *= (acos(d) - 1.57079632)/d;    
    vec3 v;
    v=func(p,t*8.)*max(1.-d*d*d, 0.);
    

    v=2.*clamp(v,0.,1.)*(vec3(1.0,0.6,0.)*sat(dot(n,l))+0.25);
    v+=vec3(1.,0.8,0.6)*sat(pow(1.-abs(n.z),1.5));
    
    return vec4(v,length(uv-pos.xy)/r);
}

// Function 3584
bool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)
{
	vec3 roo = rayPos - (boxMin+boxMax)*0.5;
    vec3 rad = (boxMax - boxMin)*0.5;

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    time = vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
	
    return time.y>time.x && time.y>0.0;
}

// Function 3585
float sdRoundCone( vec3 p, float r1, float r2, float h )
{
    vec2 q = vec2( length(p.xy), p.z );
    
    float b = (r1-r2)/h;
    float a = sqrt(1.0-b*b);
    float k = dot(q,vec2(-b,a));
    
    if( k < 0.0 ) return length(q) - r1;
    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
    return dot(q, vec2(a,b) ) - r1;
}

// Function 3586
Hit sphereTrace(in Ray r) {
  Surface s;
  for(int i=0; i<MAX_TRACE_STEP; i++) {
    s = map(_pos(r));
    s.d *= r.sgn;
    r.len += s.d * FUDGE_FACTOR;
    r.stp = float(i);
    if (s.d < TRACE_PRECISION || r.len > MAX_TRACE_DIST) break;
  }
  vec3 p = _pos(r);
  if (r.len > MAX_TRACE_DIST) return nohit(r);
  return Hit(p, calcNormal(p)*r.sgn, r, s);
}

// Function 3587
float udBox(in vec2 p, in vec2 b){
	return length(max(abs(p) - b + .1, 0.)) - .1;
}

// Function 3588
bool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm
){if(spZRad1.x>spZRad2.x
 ){vec2 tmp=spZRad1
  ;spZRad1=spZRad2
  ;spZRad2=tmp;}
 ;vec2 ConeCaps
 ;float spdz=spZRad2.x-spZRad1.x
 ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz
 ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz
 ;ConeCaps.x=spZRad1.x-h1
 ;ConeCaps.y=spZRad2.x-h2
 ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)
 ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)
 ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)
 ;vec2 ConeR_ab
 ;ConeR_ab.x=dZdR.y/dZdR.x
 ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x
 ;float sp_t
 ;vec3 sp_n
 ;int n=0
 ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}
 ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)
 ){if(sp_t<t
  ){t=sp_t
   ;norm=sp_n;}
  ;n++;}
 ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)
 ){if(sp_t<t
  ){t=sp_t
   ;norm=sp_n;}
  ;n++;}
 ;return(n>0);}

// Function 3589
vec3 boxPos(vec3 p, float diff, float o) {
    vec3 bp = vec3(0., -1.0, gTime());
    float c = floor((p.z + diff)/diff*2.0);    
    float rnd = hash(c);
    
    bp.y = 1.8*cos(sin(iTime + o)*3. + iTime + o);
        
    return bp;
}

// Function 3590
float fTorus(vec3 p, float smallRadius, float largeRadius) {
   return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

// Function 3591
float sdCappedCylinder( vec3 p, vec2 h )
{
	vec2 d = abs(vec2(length(p.xy),p.z )) - h;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3592
int findIndexShortestBox(vec3 p){
    float boxDists = sdBox(p,boxes[0].position,boxes[0].size, boxes[0].roundness);
    int minB = 0;
    boxes[0].dist = boxDists;
    for(int i = 1; i < boxes.length(); i++){
        if(i == boxes.length()){
        	break;   
        }
        float iBoxSdf = sdBox(p, boxes[i].position, boxes[i].size, boxes[0].roundness);
        boxDists = min(boxDists,iBoxSdf);
        boxes[i].dist = iBoxSdf;        
        if(boxDists == iBoxSdf){
            minB = i;
        }
    }
    return minB;
}

// Function 3593
float PlaneSDF(vec3 p, float y)
{
    return p.y+y;
}

// Function 3594
vec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }

// Function 3595
float PrTorusDf (vec3 p, float ri, float rc)
{
  vec2 q = vec2 (length (p.xy) - rc, p.z);
  return length (q) - ri;
}

// Function 3596
float cylinderImpact(in vec2 pos,in vec2 ray, in vec2 O, in float R, inout vec2 norm){
    float t=INFINI;
    vec2 d = pos - O;
    float a = dot(ray,ray);
    float b = dot(d, ray);
    float c = dot(d,d) - R*R;
    float discr = b*b - a*c;
    if (discr >= 0.){
        t = (-b - sqrt(discr))/a;
        if (t < 0.001) t = (-b + sqrt(discr))/a;
        if (t < 0.001) t=INFINI;

        norm = normalize(pos + t*ray - O);
    }
	return t;
}

// Function 3597
vec3 Camera_p3_2_plane(Camera cam, vec3 p) {
    vec3 q = p - cam.origin;
    float t = planeIntersect(cam.origin, q, cam.origin+cam.w, cam.w);
    vec3 cp = cam.origin + t * q;
    return cp;
}

// Function 3598
float sdPlane (vec3 p, vec4 n)
{
	// n must be normalized
	return dot(p,n.xyz) + n.w;
}

// Function 3599
mat4 rotation_mat4_xw_plane(
	float theta)
{
    float cos_theta = cos(theta);
    float sin_theta = sin(theta);
 
    // NOTE: I'm unsure of what the proper rotation-signs should be for rotations involving the w-axis.
    return mat4(
    	cos_theta, 0.0, 0.0, sin_theta, // x-basis
        0.0, 1.0, 0.0, 0.0, // y-basis
    	0.0, 0.0, 1.0, 0.0, // z-basis
        (-1.0 * sin_theta), 0.0, 0.0, cos_theta); // w-basis
}

// Function 3600
Hit traceSphere(Ray ray, Sphere sphere)
{
   	float a = dot(ray.direction, ray.direction);
    float b = dot(ray.direction, ray.origin - sphere.center) * 2.0;
    float c = dot(ray.origin - sphere.center, ray.origin - sphere.center) - sphere.radius * sphere.radius;
    float d = b*b - 4.0*a*c;
    
    Hit hit;
    
    if(d >= 0.0)
    {
        hit.t = (-b - sqrt(d)) / (2.0*a);
      	if(hit.t < t_max && hit.t > t_min)
        {
        	hit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);
        	hit.mat = sphere.mat;
        	hit.hit = true;
        	return hit;
        }
        
        hit.t = (-b + sqrt(d)) / (2.0*a);
        if(hit.t < t_max && hit.t > t_min)
        {
        	hit.normal = normalize((ray.origin + ray.direction * hit.t) - sphere.center);
        	hit.mat = sphere.mat;
        	hit.hit = true;
        	return hit;
        }
    }
    
	hit.hit = false;
	return hit;
}

// Function 3601
float sdPlane(vec3 pos, vec3 norm, float d) {
    return abs(dot(pos, norm) - d);
}

// Function 3602
float distFromSphere(Sphere s, vec3 p) {
 	return distance(repeat(p),s.position)-s.radius;  
}

// Function 3603
vec3 random_sphere()
{
    return normalize(randn())*pow(rand(),0.333333);
}

// Function 3604
vec2 iSphere(in vec3 ro, in vec3 rd, in float rad)
{
	//sphere at origin has equation |xyz| = r
	//sp |xyz|^2 = r^2.
	//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),
	//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:
	//vec3 oc = ro - sph.xyz; //distance ray origin - sphere center
	
	float b = dot(ro, rd);					//=dot(oc, rd);
	float c = dot(ro, ro) - rad * rad;		//=dot(oc, oc) - sph.w * sph.w; //sph.w is radius
	float h = b*b - c; // delta
	if(h < 0.0) 
		return vec2(-1.0);
    //h = sqrt(h);
    h *= 0.5;		// just some rough approximation to prevent sqrt.
    return vec2(-b-h, -b+h);
}

// Function 3605
float distanceToGroundPlane(vec3 p) {
     return p.y+0.5;   
}

// Function 3606
float PlaneSDF(vec3 p, float y)
{
    return p.y + y;
}

// Function 3607
float
capped_cylinder4_sd( in vec2 rh, in vec3 p )
{
    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;
    return min( maxv(d), 0.0 ) + length4( max(d, 0.0) );
}

// Function 3608
float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
   return dot(p, n) + distanceFromOrigin;
}

// Function 3609
float torussdf( vec3 pos )
{
    vec3 p = pos - vec3(sin(iTime) * 2., 0.8, sin(iTime / 2.) * 10.);
    vec2 q = vec2(length(p.yz)-outradius,p.x);
    return length(q)-inradius;
}

// Function 3610
float sdCappedCylinder( vec3 p, float h, float r, vec3 offset )
{
  p = p-offset;
  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3611
float sphereLight( vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )
{
	vec3 L				= spherePos - pos;
	vec3 centerToRay	= dot( L, r ) * r - L;
	vec3 closestPoint	= L + centerToRay * clamp( sphereRad / length( centerToRay ), 0.0, 1.0 );	
	vec3 l				= normalize( closestPoint );
	vec3 h				= normalize( V + l );
	
	NoL				= clamp( dot( N, l ), 0.0, 1.0 );
	float HoN		= clamp( dot( h, N ), 0.0, 1.0 );
	float HoV		= dot( h, V );
	
	float distL		= length( L );
	float alpha		= roughness * roughness;
	float alphaPrime	= clamp( sphereRad / ( distL * 2.0 ) + alpha, 0.0, 1.0 );
	
	float specD		= specTrowbridgeReitz( HoN, alpha, alphaPrime );
	float specF		= fresSchlickSmith( HoV, f0 );
	float specV		= visSchlickSmithMod( NoL, NoV, roughness );
	
	return specD * specF * specV * NoL;
}

// Function 3612
float planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)
{
    return dot(pp-o,pn)/dot(d,pn);
}

// Function 3613
intersection RAYBOXINTERSECT(ray r, aabb box)
{
    intersection result;
    result.distance = rayboxintersect(r, box);
    //result.normal = -r.dir; // sky-sphere
    //if(result.distance < MAXDIST) result.normal = cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0);

    result.normal = mix(-r.dir, cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0), step(result.distance, MAXDIST));

    return result;
}

// Function 3614
float sdDisplacementSphere( vec3 p, vec3 f, vec3 cp, int fn )
{
    
    float w = sqrt(f.x);
    
    // different combinations with the distances
    if( fn == 1 ) 		w = 1.0 - f.x;
    else if( fn == 2 ) 	w = f.y - f.x;
    else if( fn == 3 )	w = 0.5*f.x + 0.25*f.y + 0.125*f.z;
    else if( fn == 4 )	w = sqrt( 1.0 - 2.0*( 0.5*f.x - 0.1*f.y ) );

    w = clamp( w, 0.0, 1.0 );
        
    float d1 = sdSphere( p, 1.0 );
    float d2 = 0.06*( 1.0 - w );
    //float d2 = 0.06*( 1.3 + 0.3*sin( 10.0*iTime ) )*(1.0 - w );
    return d1 + d2;
}

// Function 3615
vec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) 
{
    vec3 m = 1.0 / rd;
    vec3 n = m * ro;
    vec3 k = abs( m ) * rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	return vec2( max( max( t1.x, t1.y ), t1.z ),
	             min( min( t2.x, t2.y ), t2.z ) );
}

// Function 3616
float coneContour(vec3 p){
    vec3 zero=vec3(0,0,0);
    float d=0.0;
    float x0=contour[0].x;
    float y0=contour[0].y;
    vec3 q0=vec3(x0,y0,-1);
    for(int i=1;i<MAX_P;i++){
        float x=contour[i].x;
        float y=contour[i].y;
        vec3 q1=vec3(x,y,-1);
        vec3 v1=q1-q0;
        vec3 n=normalize(cross(q0,v1));
        q0=q1;  
        d=opI(d,plane(p,zero,n));
    }
    //close the contour
    vec3 q1=vec3(x0,y0,-1);
    vec3 v1=q1-q0;
    vec3 n=normalize(cross(q0,v1));
    d=opI(d,plane(p,zero,n));
    return d;
}

// Function 3617
float sdSphere( vec3 p, float s )
{
  return length(p)- s;//+ .1 * sin( p.x * p.y * p.z * 10. + iTime );//* (1.+ .4 * triNoise3D( p * .1 ,.3 ) + .2* triNoise3D( p * .3 ,.3 )) ;
}

// Function 3618
float sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)
{
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;

    float x = sqrt( papa - paba*paba*baba );

    float cax = max(0.0,x-((paba<0.5)?ra:rb));
    float cay = abs(paba-0.5)-0.5;

    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );

    float cbx = x-ra - f*rba;
    float cby = paba - f;
    
    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;
    
    return s*sqrt( min(cax*cax + cay*cay*baba,
                       cbx*cbx + cby*cby*baba) );
}

// Function 3619
float box (vec3 p, vec3 c, vec3 s)
{
	float x = max(p.x - c.x - s.x, c.x - p.x - s.x);
	float y = max(p.y - c.y - s.y, c.y - p.y - s.y);   
	float z = max(p.z - c.z - s.z, c.z - p.z - s.z);
	return max(max(x,y),z);
}

// Function 3620
float
intersect_box(Ray ray, out vec3 normal, vec3 size)
{
	float t_min = 0.0;
	float t_max = 999999999.0;
	if(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {
		vec3 p = ray_at(ray, t_min);
		p /= size;
		if(abs(p.x) > abs(p.y)) {
			if(abs(p.x) > abs(p.z)) {
				normal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);
			}
			else {
				normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);
			}
		}
		else if(abs(p.y) > abs(p.z)) {
			normal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);
		}
		else {
			normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);
		}

		return t_min;
	}

	return INFINITY;
}

// Function 3621
float sdCylinderXY( vec3 p, vec2 h )
{
    vec2 d = abs(vec2(length(p.xy),p.z)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3622
float sdSphere(in vec3 p, float s) {
    return length(p) - s;}

// Function 3623
float box(vec3 p,vec3 b){
    vec3 q= abs(p)-b;
    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));
}

// Function 3624
float intersectRaySphere(vec3 ro, vec3 rd, vec3 sp, float rsq) {
  vec3 n = ro - sp;
  float a = dot(rd, rd);
  float b = 2.0 * dot(rd, n);
  float c = dot(n, n) - rsq;
  float d = b * b - 4.0 * a * c;
  return d < 0.0 ? -1.0 : (-b - sqrt(d)) / 2.0 * a;
}

// Function 3625
float sdBox(vec3 p, vec3 b) 
{
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3626
void raytrace_sphere(
    vec4 sphere_center,
    float sphere_radius,
	vec4 ray_origin,
	vec4 ray_direction,
	inout vec3 inout_ray_color,
	inout float inout_ray_depth)
{
    vec4 local_ray_origin = (ray_origin - sphere_center);
    
    // Solving for the intersections via the quadratic equation, as seen in: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
    float quadratic_a = 1.0; // dot(ray_direction, ray_direction)
    float quadratic_b = (2.0 * dot(local_ray_origin, ray_direction));
    float quadratic_c = (dot(local_ray_origin, local_ray_origin) - sq(sphere_radius));
    float quadratic_discriminant = (sq(quadratic_b) - (4.0 * quadratic_a * quadratic_c));
    
    if (quadratic_discriminant >= 0.0)
    {
        float sqrt_quadratic_discriminant = sqrt(quadratic_discriminant);
        float quadratic_divisor = (1.0 / (2.0 * quadratic_a));
        
        float depth_near = (((-1.0 * quadratic_b) - sqrt_quadratic_discriminant) * quadratic_divisor);
        float depth_far = (((-1.0 * quadratic_b) + sqrt_quadratic_discriminant) * quadratic_divisor);
        
        float depth = ((depth_near >= 0.0) ? depth_near : depth_far);
        
        if ((depth >= 0.0) &&
            (depth < inout_ray_depth))
        {
            vec4 intersection = (ray_origin + (ray_direction * depth));
            
            vec4 normal = normalize(intersection - sphere_center);
            float diffuse_fraction = (1.0 * max(0.0, dot(normal, s_light_direction)));
            float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));
            
            inout_ray_color = mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction)));
            inout_ray_depth = depth;
        }
    }
}

// Function 3627
float boxSDF(vec3 p, vec3 bb) {
    vec3 d = abs(p) - bb;
	return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf
}

// Function 3628
float boxOcclusion( in vec3 pos, in vec3 nor, in mat4 txx, in mat4 txi, in vec3 rad ) 
{
	vec3 p = (txx*vec4(pos,1.0)).xyz;
	vec3 n = (txx*vec4(nor,0.0)).xyz;
    vec4 w = vec4( n, -dot(n,p) ); // clipping plane
    
    // 8 verts
    vec3 v0 = vec3(-1.0,-1.0,-1.0)*rad;
    vec3 v1 = vec3( 1.0,-1.0,-1.0)*rad;
    vec3 v2 = vec3(-1.0, 1.0,-1.0)*rad;
    vec3 v3 = vec3( 1.0, 1.0,-1.0)*rad;
    vec3 v4 = vec3(-1.0,-1.0, 1.0)*rad;
    vec3 v5 = vec3( 1.0,-1.0, 1.0)*rad;
    vec3 v6 = vec3(-1.0, 1.0, 1.0)*rad;
    vec3 v7 = vec3( 1.0, 1.0, 1.0)*rad;
    

    // 6 faces    
    float occ = 0.0;
    occ += triOcclusion( p, n, v0, v2, v3, w );
    occ += triOcclusion( p, n, v0, v3, v1, w );

    occ += triOcclusion( p, n, v4, v5, v7, w );
    occ += triOcclusion( p, n, v4, v7, v6, w );
    
    occ += triOcclusion( p, n, v5, v1, v3, w );
    occ += triOcclusion( p, n, v5, v3, v7, w );
    
    occ += triOcclusion( p, n, v0, v4, v6, w );
    occ += triOcclusion( p, n, v0, v6, v2, w );
    
    occ += triOcclusion( p, n, v6, v7, v3, w );
    occ += triOcclusion( p, n, v6, v3, v2, w );
    
    occ += triOcclusion( p, n, v0, v1, v5, w );
    occ += triOcclusion( p, n, v0, v5, v4, w );

    return occ;
}

// Function 3629
float sdCylinder( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3630
float
torus32_sd( in vec2 torus, in vec3 p )
{
    vec2 q = vec2(length(p.xy)-torus.x,p.z);
    return length3(abs(q))-torus.y;
}

// Function 3631
DAMValue planeOLD(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}

// Function 3632
vec2 sphereIntersectionDistances(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius) {
    vec3 toCenter = sphereOrigin - rayOrigin;
    float toCenterAlongRay = dot(toCenter, rayDirection);
    
    float perpendicularDistanceSquared = dot(toCenter, toCenter) - toCenterAlongRay * toCenterAlongRay;
    float radiusSquared = sphereRadius * sphereRadius;
    
    if (perpendicularDistanceSquared > radiusSquared) { // ray doesnt touch the sphere
        return vec2(0.);
    }
    
    float insideSphereAlongRay = sqrt(radiusSquared - perpendicularDistanceSquared); // half the length of the portion of the ray inside the sphere
    
    float intersection1 = toCenterAlongRay - insideSphereAlongRay;
    float intersection2 = toCenterAlongRay + insideSphereAlongRay;
    if (intersection1 > intersection2) {
        float t = intersection1;
        intersection1 = intersection2;
        intersection2 = t;
    }
    
    if (intersection1 < 0.) { // first intersection is before the start of the ray
        if (intersection2 < 0.) { // ditto second, though that shouldnt happen?
            return vec2(0.);
        } else {
            intersection1 = intersection2;
            intersection2 = 0.;
        }
    }
    
    return vec2(intersection1, intersection2);
}

// Function 3633
float sdSphere(vec3 p, float r)
{
  return length(p)-r;;
}

// Function 3634
float TORUS(vec3 p)
{
    vec2 t = vec2(1.0, 0.4);
	vec2 q = vec2(length(p.xz) - t.x, p.y);
	return length(q) - t.y;
}

// Function 3635
bool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)
{
    Plane_t faces[6];
    vec3 faces_normal[6];
    // calculate normal vectors of 6 faces
    faces_normal[0] = vec3(-cos(box.angle), 0.0, -sin(box.angle));
    faces_normal[1] = vec3(cos(box.angle), 0.0, sin(box.angle));
    faces_normal[2] = vec3(0.0, -1.0, 0.0);
    faces_normal[3] = vec3(0.0, 1.0, 0.0);
    faces_normal[4] = vec3(sin(box.angle), 0.0, -cos(box.angle));
    faces_normal[5] = vec3(-sin(box.angle), 0.0, cos(box.angle));
    for (int i = 0 ; i < 3 ; i++) {
        // construct 6 planes
        faces[2 * i] = Plane_t(faces_normal[2 * i].x, faces_normal[2 * i].y, faces_normal[2 * i].z,
                              -dot(faces_normal[2 * i], box.corner1), box.materialID);
        faces[2 * i + 1] = Plane_t(faces_normal[2 * i + 1].x, faces_normal[2 * i + 1].y, faces_normal[2 * i + 1].z,
                      -dot(faces_normal[2 * i + 1], box.corner2), box.materialID);
    }
    float largest_near = tmin;
    float smallest_far = tmax;
    vec3 near_hitPos;
    vec3 near_hitNormal;
    for (int i = 0 ; i < 3 ; i++) {
        // for each pair of parallel planes
        // check if the ray intersects with each of them
        float t_neg;
        vec3 hitPos_neg;
        vec3 hitNormal_neg;
        bool hashit_neg = IntersectPlane(faces[2 * i], ray, tmin, tmax,
                                         t_neg, hitPos_neg, hitNormal_neg);
        
        float t_pos;
        vec3 hitPos_pos;
        vec3 hitNormal_pos;
        bool hashit_pos = IntersectPlane(faces[2 * i + 1], ray, tmin, tmax,
                                         t_pos, hitPos_pos, hitNormal_pos);
        // at most 2 hits
        float t_near;
        float t_far;
        // if no hit
        if (!hashit_neg && !hashit_pos) {
            // check if origin of the ray is located between 2 planes 
            // and exactly parallel to these 2 planes
            float res1 = dot(ray.o, vec3(faces[2 * i].A, faces[2 * i].B, faces[2 * i].C)) + faces[2 * i].D;
            float res2 = dot(ray.o, vec3(faces[2 * i + 1].A, faces[2 * i + 1].B, faces[2 * i + 1].C)) + faces[2 * i + 1].D;
            if (res1 < -tmin && res2 < -tmin)
                // if it is, ignore
                continue;
            else 
                // otherwise there cannot be ray-box intersections
                return false;
        }
        else if (hashit_neg && !hashit_pos) {
            // only hit the negative plane, record it as t_far
            t_far = t_neg;
            if (smallest_far > t_far)
                smallest_far = t_far;
        }
        else if (!hashit_neg && hashit_pos) {
            // only hit the positive plane, record it as t_far 
            t_far = t_pos;
            if (smallest_far > t_far)
                smallest_far = t_far;
        }
        else if (hashit_neg && hashit_pos) {
            // hit both planes
            // the smaller t is t_near, the other is t_far
            t_near = t_neg < t_pos ? t_neg : t_pos;
            t_far = t_neg > t_pos ? t_neg : t_pos;
            if (largest_near < t_near) {
                // update if t_near is a larger one
                largest_near = t_near;
                near_hitPos = t_neg < t_pos ? hitPos_neg : hitPos_pos;
                near_hitNormal = t_neg < t_pos ? hitNormal_neg : hitNormal_pos;
            }
            if (smallest_far > t_far) {
                smallest_far = t_far;
            }
        }
    }    
    // if the ray exits a pair of planes while it has not enter another pair of planes
    // then no ray-box intersection
    if (largest_near >= smallest_far) return false;
    
    return true;
}

// Function 3636
float PDF_Cosine_Hemisphere ( float3 wi, float3 N ) {
  return abs(dot(wi, N)) * IPI;
}

// Function 3637
SHit HitPlane(vec4 plane, SMaterial mtl, vec3 posRay, vec3 normalRay)
{
	float gDotNormal = dot(plane.xyz, normalRay);

	float s = -dot(plane, vec4(posRay, 1.0)) / gDotNormal;

	SHit hit;

	hit.m_normal = plane.xyz;
	vec3 posHit = (posRay + s * normalRay);
	hit.m_normal.xy += saturate(-normalRay.z) * 0.1 * sin(posHit.xy / (100.0));
	hit.m_normal = normalize(hit.m_normal);
	hit.m_s = (abs(gDotNormal) > 1e-6 && s > 0.0) ? s : g_sRayMax;
	hit.m_mtl = mtl;

	return hit;
}

// Function 3638
float sdf_half3_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, -pos.x);
}

// Function 3639
float fCone(vec3 p,float r,float h//this needs some optimization;
){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))
 ;float j=dt(t,vec2(m.y,-m.x))
 ;float d=max(dt(t,m),-q.y)
 ;if(q.y>h&&j<0.)d=max(d,le(t))
 ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))
 ;return d;}

// Function 3640
float spheretracing(vec3 ori, vec3 dir, out vec3 p) {
    float t = 0.0;    
    for(int i = 0; i < NUM_STEPS; i++) {
        p = ori + dir * t;
        float d = map(p);
        if(d <= 0.0 || t > 2.0) break;
        t += max(d*0.3,EPSILON);
    }    
    return step(t,2.0);
}

// Function 3641
int intersectSphere(vec3 ro, vec3 rd, float r, out float t1, out float t2) {
    float b = dot(ro,rd), d = b*b - dot(ro,ro) + r*r;
    if (d <= 0.) return -1;
    t1 = -b-sqrt(d);
    t2 = -2.*b-t1;
    return t1 > 0. ? 1 : t2 > 0. ? 2 : 0;
}

// Function 3642
float iUnitSphere(vec3 ro, vec3 rd, out vec3 p0) {
    float p = dot(rd, ro);
    float t = p*p - dot(ro, ro) + 1.0;
    
    float sq = sqrt(max(0.0, t));
    
    p0 = ro - (p + sq)*rd;
    
    return t;
}

// Function 3643
maybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r
){
    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center
    // see closest-approach-between-line-and-cylinder-visualized.scad
    // implementation shamelessly copied from Inigo: 
    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    vec3 D = A0 - B0;
    float BA = dot(B, A);
    float BD = dot(B, D);
    float a = 1.0 - BA * BA;
    float b = dot(D, A) - BD * BA;
    float c = dot(D, D) - BD * BD - r * r;
    float h = sqrt(max(b * b - a * c, 0.f));
    return maybe_vec2(
        vec2((-b + h) / a, (-b - h) / a), 
        h > 0.0
    );
}

// Function 3644
vec3 ray_sphere_intersect_inverse(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)
{
    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;
	float distance_to_ray = length(cur_shpere.position - distance_point);
    
    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))
    {
        return vec3(0,0,0);
    }

    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));

	vec3 intersect_point = distance_point + (ray_dir * inner_line_length);

    return intersect_point;
}

// Function 3645
float distBox( vec3 pos, vec3 scale ) {
    return length( max( abs( pos ) - scale, vec3( 0.0 ) ) );
}

// Function 3646
vec4 Cone60(vec3 pos, vec3 dir) {
    float dist=IRES;
    float sL=0.;
    float sD,sW; vec3 sP; vec4 sC;
    vec4 Col=vec4(0.,0.,0.,0.);
//Tracing
    for (int i=0; i<6; i++) {
    	sP=pos+dir*dist;
        sC=VoxelFetch(sP,sL);
        sW=1.-Col.w;
        Col=Col+sC*sW;
        sL=sL+1.;
        dist=dist*2.;
    }
    return Col;
}

// Function 3647
float sdCappedCylinder( vec3 p, float h, float r )
{
  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3648
float fSphere(vec3 p, float r) {
   return length(p) - r;
}

// Function 3649
vec3 renderPlanet(vec3 cameraPos, vec3 rayDir, vec3 lightDir, vec2 rayPlanetIntersect){
    
    float diff = dot(normalize(cameraPos + normalize(rayDir) * rayPlanetIntersect.x), lightDir); 
    if(diff < 0.0){
    	return vec3(0.0);
    }
    //Planet is lit with diffuse grey
    return diff * vec3(0.2, 0.2, 0.2);
}

// Function 3650
v0 fBoxCheap(v2 p,v2 b
){v2 q=abs(p);q=q-p//mirror clamp
 ;return max(max(q.x,q.y),q.z);}

// Function 3651
float sdPlaneCabin( vec3 p, float window_radius_scale )
{
	vec3 cc = vec3( 0 );

	float wall_in = body_radius.x - 0.05;
	float wall_out = body_radius.x + 0.02;

	float l = 72.25; //a350len
	float d = opI( opI( ( p - cc ).x - l * 0.5, //front clip
				  opI( -sd_cylinderx( p, cc, wall_in ),
					   sd_cylinderx( p, cc, wall_out ) ) ), // plane body wall
			 -( p - cc ).x - l * 0.5 ); // back clip

	// https://www.airbus.com/content/dam/corporate-topics/publications/backgrounders/techdata/aircraft_characteristics/Airbus-Commercial-Aircraft-AC-A350-900-1000.pdf
	// Page 9 for window size and position
	vec2 p2 = p.xz;
	p2.x = repeat_e( p.x, -windows_spacing, windows_spacing );
	p2.y -= windows_pos_from_center;
	// wx is window border mapped to 0,1
	float wx = saturate( ( ( p.y - cc.y ) - wall_in ) / ( wall_out - wall_in ) );
	p2 *= ( 1.0 + wx * 0.1 );
	float dw = sdAirlinerWindow( p2, window_radius_scale );
	d = opI( d, dw );
	float d1 = opI( -sd_cylinderx( p, cc, wall_in + 0.02 ),
					sd_cylinderx( p, cc, wall_in + 0.03 ) );
	d = opS( d, d1 );
	return d;
}

// Function 3652
float sdRoundBox( vec3 p, vec3 b, float r ) {
  vec3 d = abs(p) - b;
  return length(max(d,0.0)) - r
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf
}

// Function 3653
float doubleCone (vec3 pos, vec3 p, float radius, float height){
    vec3 diff = p-pos;
    float yd = abs(diff.y)-height;
    return (length(diff.xz)-radius)-yd;
}

// Function 3654
bool segment_box_intersection(
  in vec3 q1,
  in vec3 dirinv,
  in vec3 boxmin,
  in vec3 boxmax
) {  
   vec3 T1 = dirinv*(boxmin - q1);
   vec3 T2 = dirinv*(boxmax - q1);
   vec3 Tmin = min(T1,T2); 
   vec3 Tmax = max(T1,T2);
   float tmin = max(max(Tmin.x, Tmin.y),Tmin.z);
   float tmax = min(min(Tmax.x, Tmax.y),Tmax.z);   
   return (tmax >= 0.0) && (tmin <= tmax) && (tmin <= 1.0);
}

// Function 3655
float gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )
{
	// filter kernel
    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;

	// analytic (box) filtering
    vec2 a = p + 0.5*w;                        
    vec2 b = p - 0.5*w;           
    vec2 i = (floor(a)+min(fract(a)*N,1.0)-
              floor(b)-min(fract(b)*N,1.0))/(N*w);
    //pattern
    return (1.0-i.x)*(1.0-i.y);
}

// Function 3656
float SdBox( vec2 vPos, vec2 vSize )
{
  vec2 d = abs(vPos) - vSize;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3657
float sdPlane( vec3 p, vec3 n )
{
  return dot(p, normalize(n));
}

// Function 3658
float map_spheres(vec3 pos, vec3 center, float d, float r)
{
    pos-= center;
    pos.xz = rotateVec(pos.xz, iTime*0.5);
    pos.x = abs(pos.x);
    pos.x-= d;
    pos.z = abs(pos.z);
    pos.z-= d;
    return length(pos) - r;   
}

// Function 3659
bool planeIntersection(in Ray r,out HitRecord hit, float maxT) {
    /*
    Checks for intersections with the plane obejcts in the scene.
    Updates hit attribute with relevant information. 
    */
    float minT = 0.0001;
    float currentT = maxT;
    vec3 normal;
    material mat;
    
    for (int j = 0; j < planes.length(); ++j) {
        vec3 p = planes[j].p;
        vec3 n = planes[j].n;

        float t = dot(p - r.orig, n) / dot(r.dir, n);
        if (minT < t && t < currentT) {
            currentT = t;
            normal = n;
            mat = planes[j].mat;
        }
    }
    if (currentT < maxT) {
        hit.t = currentT;
        hit.mat = mat;
        hit.normal = normal;
        return true;
    }
    else
        return false;
}

// Function 3660
float sdPlane(vec3 p) {
	return p.y + 0.5;
}

// Function 3661
float sdPlane1 (vec3 p)
{
  return p.y;
}

// Function 3662
float sdCappedCylinder( vec3 p, vec2 h ,vec3 pos,int mat)
{
    p = p - pos;
  	vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  	return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3663
float boxSDF( vec3 p, vec3 sizes ){
  vec3 q = abs(p) - sizes;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3664
float sdSphere( vec4 p, float s )
{
    
  return abs(length(mod(p, c) - 0.5f*c)-s);
}

// Function 3665
float udRoundBox(float dt, vec3 p, vec3 b, float r)
{
    return udRoundBox(p,dt*b,r);
}

// Function 3666
float dfBox(vec3 p, vec3 b, float r) { return r-length(max(abs(p)-b,0.));}

// Function 3667
float sBoxS(in vec2 p, in vec2 b, in float rf){
  
  vec2 d = abs(p) - b + rf;
  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;
    
}

// Function 3668
float isec_sphere(in ray_t ray, in sphere_t sphere) {
	vec3 v = sphere.center - ray.origin;
	float b = dot(v, ray.dir);
	float c = dot(v, v) - sphere.radius2;
	float det2 = b * b - c;
	if (det2 < 0.) return INFINITY;
	float t = b - sqrt(det2);
	if (t < 0.) return INFINITY;
	return t;
}

// Function 3669
float sdBox(vec3 p, vec3 b)
{
    return length(max(abs(p) - b, 0.0));
}

// Function 3670
float sdPlane2(vec3 point, vec4 normal)
{
    return dot(point, normal.xyz) + normal.w;
}

// Function 3671
vec2 sphereIter(vec3 p, float radius, float subA)
{
    finWidth = 0.1;
    teeth = globalTeeth;
    float blender = 0.25;
    vec2 final = vec2(1000000.0, 0.0);
    for (int i = 0; i < RECURSION_LEVELS; i++)
    {
#ifdef SPLIT_ANIM
        // rotate top and bottom of sphere opposite directions
        p = RotateY(p, spinTime*sign(p.y)*0.05/blender);
#endif
        // main sphere
        float d = length(p) - radius*outness;
#ifdef SPLIT_ANIM
        // subtract out disc at the place where rotation happens so we don't have artifacts
        d = max(d, -(max(length(p) - radius*outness + 0.1, abs(p.y) - finWidth*0.25)));
#endif

        // calc new position at 8 vertices of cube, scaled
        vec3 corners = abs(p) + diagN * radius;
        float lenCorners = length(corners);
        // subtract out main sphere hole, mirrored on all axises
        float subtracter = lenCorners - radius * subA;
        // make mirrored fins that go through all vertices of the cube
        vec3 ap = abs(-p) * 0.7071;	// 1/sqrt(2) to keep distance field normalized
        subtracter = max(subtracter, -(abs(ap.x-ap.y) - finWidth));
        subtracter = max(subtracter, -(abs(ap.y-ap.z) - finWidth));
        subtracter = max(subtracter, -(abs(ap.z-ap.x) - finWidth));
        // subtract sphere from fins so they don't intersect the inner spheres.
        // also animate them so they are like teeth
        subtracter = min(subtracter, lenCorners - radius * subA + teeth);
        // smoothly subtract out that whole complex shape
        d = -smin(-d, subtracter, blender);
        //vec2 sphereDist = sphereB(abs(p) + diagN * radius, radius * inner, cut);	// recurse
        // do a material-min with the last iteration
        final = matMin(final, vec2(d, float(i)));

#ifndef SPLIT_ANIM
        corners = RotateY(corners, spinTime*0.25/blender);
#endif
        // Simple rotate 90 degrees on X axis to keep things fresh
        p = vec3(corners.x, corners.z, -corners.y);
        // Scale things for the next iteration / recursion-like-thing
        radius *= inner;
        teeth *= inner;
        finWidth *= inner;
        blender *= inner;
    }
    // Bring in the final smallest-sized sphere
    float d = length(p) - radius*outness;
    final = matMin(final, vec2(d, 6.0));
    return final;
}

// Function 3672
float sdCylinder(vec3 p, vec2 h) {
  vec2 d = abs(vec2(length(p.xz), p.y)) - h;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 3673
vec3 CosineWeightedSampleOnHemisphere(float u1, float u2) {	
	float cos_theta = sqrt(1.0f - u1);
	float sin_theta = sqrt(u1);
	float phi = 2.0f * g_pi * u2;
	
	return vec3(cos(phi) * sin_theta, 
                sin(phi) * sin_theta, 
                cos_theta);
}

// Function 3674
void intersectRayHyperPlaneRange (in Ray4 _ray, in HyperPlane _plane, in Object _object, inout Ray4Result _rayResFront, inout Ray4Result _rayResRear )
{
    Ray4Result curr;
    intersectRayHyperPlane ( _ray, _plane, _object, curr );
    
    if ( dot(_ray.m_dir,_plane.m_normal) > 0.0 )
    {
        minRay4Result ( _rayResRear, curr );
    }
    else
    {
        maxRay4Result ( _rayResFront, curr );
    }
}

// Function 3675
float fBoxCheap(vec3 p, vec3 b)
{  // cheap box
    return vmax(abs(p) - b);
}

// Function 3676
float udBox( in vec3 p, in vec3 abc )
{
	return length(max(abs(p)-abc,0.0));
}

// Function 3677
float sdConeSection(float dt, in vec3 p, in float h, in float r1, in float r2)
{
    return sdConeSection(p, min(h/dt,.4), r1,r2);
}

// Function 3678
vec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)
{
    float a = dot(rd, rd);
    float b = 2. * dot(rd, ro - org);
    float c = dot(ro - org, ro - org) - rad * rad;
    float desc = b * b - 4. * a * c;
    if (desc < 0.)
        return vec2(1, 0);

    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));
}

// Function 3679
float box2(vec2 p, float s) { vec2 ap = abs(p); return min(length(max(vec2(0),ap-s)),max(ap.x, ap.y)-s); }

// Function 3680
vec3 IntoSphere(vec2 uv)
{
	vec3 dir;
	uv = (-1.0 + 2.0 * uv);
	dir.x = uv.x;
	dir.z = uv.y;
	dir.y = sqrt(1.0-dir.x * dir.x  - dir.z*dir.z) * FLATTEN;
	if (length(dir) >= 1.0) return vec3(0.0, .001, .999);
	dir = normalize(dir);
	
	return dir;
}

// Function 3681
float dBox(vec3 ro, vec3 invRd, float size) 
{
    vec3 t = -ro*invRd + abs(invRd)*size;
	return min(min(t.x, t.y), t.z);
}

// Function 3682
vec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}

// Function 3683
float plane(vec3 pos, vec3 center, vec4 dimensions)
{
	return dot(center, dimensions.xyz) + dimensions.w;
}

// Function 3684
void print_box(vec2 p, vec2 s, vec4 c)
{
    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)
        col += c;
}

// Function 3685
float sdBox(vec3 b, vec3 p)
{
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 3686
float hitBox2FromInside(
    in vec2 boxMin, in vec2 boxMax,
    in vec2 p, in vec2 v
) {
    return min(
        hitIntervalFromInside(boxMin.x, boxMax.x, p.x, v.x),
        hitIntervalFromInside(boxMin.y, boxMax.y, p.y, v.y)
    );
}

// Function 3687
void sphere_intersect(Sphere s,  Ray ray, inout Intersection isect)
{
    // rs = ray.org - sphere.c
    vec3 rs = ray.org - s.c;
    float B = dot(rs, ray.dir);
    float C = dot(rs, rs) - (s.r * s.r);
    float D = B * B - C;

    if (D > 0.0)
    {
        float t = -B - sqrt(D);
        if (t > 0.0 && t < isect.t)
        {
            isect.t = t;
            isect.hit = 1;

            // calculate normal.
            vec3 p = vec3(ray.org.x + ray.dir.x * t,
                          ray.org.y + ray.dir.y * t,
                          ray.org.z + ray.dir.z * t);
            vec3 n = p - s.c;
            n = normalize(n);
            isect.n = n;
            isect.p = p;
            isect.col = s.col;
        }
    }
}

// Function 3688
float sdPlaneNoDisplacement(vec3 pos, float height)
{
	return pos.y - height;
}

// Function 3689
float fBox(vec2 p,vec2 b){vec2 d=abs(p)-b,q=min(d,0.);return length(max(d,0.))+max(q.x,q.y);}

// Function 3690
vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)
{
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return vec4(-1.0);

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return vec4(-1.0);

	//ray now found to intersect sphere, compute smallest t value of intersection
    // NOTE: this will report a miss if ray starts inside the sphere.
	float collisionTime = -b - sqrt(discr);
    
    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);
    
    // texture coordinates are just the angular part of spherical coordiantes of normal
    uv = vec2
	(
		atan(normal.z, normal.x),
		acos(normal.y)
	);
    
    return vec4 (collisionTime, normal);
}

// Function 3691
float CabinBoxIntersect( vec3 p, vec3 boxOrigin, vec3 boxDimensions)
{
    return BoxIntersect(p, boxOrigin, boxDimensions) + CabinLogDeformation(p);
}

// Function 3692
float sdBox(vec3 p, vec3 b, float r) {
        vec3 d = abs(p) - b;
        return min(maxcomp(d),0.0) - r + length(max(d,0.0));
        // Inlined maxcomp
        //return min(max(d.x,max(d.y,d.z)),0.0) - r + length(max(d,0.0));
    }

// Function 3693
float sphereSDF(vec3 p, float size) {
    return length(p) - size;
}

// Function 3694
float sdBox( in vec2 p, in vec2 b ) {
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 3695
MapResult map_torus(vec3 position)
{
	MapResult result;
	result.material.color = vec3(0.0, 0.5, 0.8);
	
	position = (rotationMatrix(vec3(0,0,1), iTime) * vec4(position, 1.0)).xyz;
	position = (rotationMatrix(vec3(0,1,0), iTime) * vec4(position, 1.0)).xyz;
	position = (rotationMatrix(vec3(1,0,0), iTime) * vec4(position, 1.0)).xyz;
	
	vec2 q = vec2(length(position.xz) - 2.5, position.y);
	result.dist = length(q) - 0.2;
			
	return result;
}

// Function 3696
float boxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {
    vec2 tMin=(bmin-origin)*dir;
    vec2 tMax=(bmax-origin)*dir;
    vec2 t2=max(tMin,tMax);
    return min(t2.x,t2.y);
}

// Function 3697
vec4 rayBox(vec3 rp, vec3 rd, vec3 pos, vec3 ext) {
    rp -= pos;
    vec3 mind = (rp+ext)/rd, maxd = (rp-ext)/rd;
	mind = -(mind-step(vec3(-1e-6),mind)*(mind+VIEW_DISTANCE));
	maxd = -(maxd-step(vec3(-1e-6),maxd)*(maxd+VIEW_DISTANCE));
	mind = min(mind,maxd);
    
    vec4 nrm;
    nrm.w = VIEW_DISTANCE;
    if (mind.x < VIEW_DISTANCE && mind.x < nrm.w) {
        vec2 pd = abs(rp.zy+rd.zy*mind.x)-ext.zy;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(-sign(rd.x),0.,0.,mind.x);
    }
    if (mind.y < VIEW_DISTANCE && mind.y < nrm.w) {
        vec2 pd = abs(rp.xz+rd.xz*mind.y)-ext.xz;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(0,-sign(rd.y),0.,mind.y);
    }
    if (mind.z < VIEW_DISTANCE && mind.z < nrm.w) {
        vec2 pd = abs(rp.xy+rd.xy*mind.z)-ext.xy;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(0.,0.,-sign(rd.z),mind.z);
    }
    return nrm;
}

// Function 3698
float sphere(vec3 co, float radius) {
    return length(co) - radius;
}

// Function 3699
vec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {
    vec3 m = 1.0/rd;
    vec3 n = m*ro;
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    return vec2( max(max(t1.x, t1.y), t1.z), 
                 min(min(t2.x, t2.y), t2.z) );
}

// Function 3700
HitTest intersectBox(in Ray r, in Box b) {
 	// box, 0 on y, +/-10 on x, +20 on y
   // vec3 p = vec3(0);
   // vec3 s = vec3(30);
    b.size *= 0.5;
    vec3 ba = b.pos-b.size, bb = b.pos+b.size;
    
    HitTest h = NOHIT;
    float d = INF;
    
    //r.origin -= p;
    
    vec3 dA = (r.origin - ba) / -r.dir;
    vec3 dB = (r.origin - bb) / -r.dir;
    
    dA.x = dA.x <= 0.0 ? INF : dA.x;
    dA.y = dA.y <= 0.0 ? INF : dA.y;
    dA.z = dA.z <= 0.0 ? INF : dA.z;
    dB.x = dB.x <= 0.0 ? INF : dB.x;
    dB.y = dB.y <= 0.0 ? INF : dB.y;
    dB.z = dB.z <= 0.0 ? INF : dB.z;
    
    float d1 = min(dA.x, min(dA.y, dA.z));
    float d2 = min(dB.x, min(dB.y, dB.z));
    
    d = min(d1, d2);
    
    vec3 endPoint = r.origin + r.dir * d;
    endPoint -= b.pos;
    //endPoint = abs(endPoint);
    
    
    if (d != INF) {
        h.hit = true;
        //h.emissive = false;
        h.dist = d;
        h.ref = 0.0;
        
        if (abs(abs(endPoint.x) - b.size.x) < 0.01) {
            bool l = endPoint.x < 0.0;
       		h.normal = vec3(l ? 1 : -1,0,0);
        	h.col = l ? vec4(0.9,0.5,0.5,0) : vec4(0.5,0.5,0.9,0);
    		return h;
        }
        if (abs(abs(endPoint.z) - b.size.z) < 0.01) {
       		h.normal = vec3(0,0,-sign(endPoint.z));
        	h.col = vec4(0.9, 0.9, 0.9, 0.0);
           // h.ref = 0.5;
    		return h;
        }
        
        // floor
       	h.normal = vec3(0,-sign(endPoint.y),0);
        h.col = vec4(1,1,1, sign(endPoint.y) * clamp(sin(t*0.242)+0.8, 0.2, 1.2));
       // h.emissive = endPoint.y > 0.0;
    	return h;
    }
    return h;
}

// Function 3701
float pdfUniformSphere(in Sphere s)
{
    return 1.0/(PI4*s.radius*s.radius);
}

// Function 3702
float sdPlane( vec4 p ) {
	return p.y;
}

// Function 3703
float Box_SDF(in vec3 point, in vec3 bounds)
{
 	return length(max(abs(point) - bounds, 0.0));   
}

// Function 3704
f1 sdBox( f3 p, f3 b )
{
  f3 q = abs(p) - b;
  return LN(Q(q,0.)) + M(Q(q.x,Q(q.y,q.z)),0.);
}

// Function 3705
float bentCappedCylinder( vec3 p, vec2 h )
{
    
 
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 3706
RayTraceResult RayTraceHoledSphereDoubleSize(in Ray ray)
{
    RayTraceResult toSphere = RayTraceSphere(ray, sphereCenter, sphereRadius);
    RayTraceResult toSphereHole = RayTraceHoledSphere(ray);
    if (toSphereHole.t == infinite && toSphere.t < infinite)
    {
        vec3 bckOrg = ray.org;
        ray.org = toSphere.pos + ray.dir*epsilon;
        toSphereHole = RayTraceHoledSphere(ray);
        toSphereHole.t += length(bckOrg - ray.org);
    }
    return toSphereHole;
}

// Function 3707
vec3 integrateHemisphere(vec3 normal, float progress)
{
    //Add some randomness in between progress steps.
    float ff = 0.5-(fract(normal.x*4913.)
	               +fract(normal.y*4913.)
	               +fract(normal.z*4913.))/6.0;
    
    progress += max(0.,ff/float(CONVERGENCE_FRAME_COUNT));
        
    vec3 up = vec3(0,1,0);
    vec3 right = normalize(cross(up,normal));
    up = cross(normal,right);

    vec3 sampledColour = vec3(0,0,0);
    float index = 0.;
    float theta = 0.;
    
    //http://www.codinglabs.net/article_physically_based_rendering.aspx
    for(int j=0; j < SAMPLES_PER_ITERATION; ++j)
    {
        float circular_angle_01 = index/float(SAMPLES_PER_ITERATION)+fract(progress*87316.)/float(SAMPLES_PER_ITERATION);
        vec3 sampleVector = rotateSample(normal, progress, circular_angle_01, theta);
		vec3 linearGammaColor = pow(texture( iChannel0, sampleVector, -100.0 ).rgb,vec3(2.2));
        float sampledArea = sin(theta);
		sampledColour += linearGammaColor * cos(theta) * sampledArea;
		index ++;
	}

    return vec3( 3.14159 * sampledColour / index);
}

// Function 3708
vec3 ClosestPointOnSphere(vec3 P, Object sphere)
{
	vec3 V = P - sphere.pos;
	return sphere.pos + normalize(V)*sphere.radius;
}

// Function 3709
vec2 PosToSphere(vec3 pos)
{
  float x = atan(pos.z, pos.x); 
  float y = acos(pos.y / length(pos)); 
  return vec2( x / (2.0 * PI), y / PI);
}

// Function 3710
vec3 random_in_unit_sphere() {
    // Returns a random direction in unit sphere (used in the BRDF)
    float phi = 2.0 * PI * rand2D();
    float cosTheta = 2.0 * rand2D() - 1.0;
    float u = rand2D();

    float theta = acos(cosTheta);
    float r = pow(u, 1.0 / 3.0);

    // Change of variables 
    // Spherical Coordinates -> Carthesian Coordinates, to get (x, y, z) values 
    float x = r * sin(theta) * cos(phi);
    float y = r * sin(theta) * sin(phi);
    float z = r * cos(theta);

    return vec3(x, y, z);
}

// Function 3711
vec3 RenderPlane(vec2 uv) 
{
  return CamLoc + (CamHorizontalVec*uv.x*16. + CamVerticalVec*uv.y*10. + /* camFwdVec here: */ normalize(vec3(0., 3., 0.)-CamLoc));
}

// Function 3712
float Cone( vec3 p, vec2 c )
{
    // c must be normalized
//    float q = length(p.xz);
	
	p.xz *= p.xz;
	p.xz *= p.xz;
	p.xz *= p.xz;
	float q = pow(p.x+p.z, 1./8.);	
		
    return dot(c,vec2(q,p.y));
}

// Function 3713
vec4 skyboxLocal(vec2 phiTheta) {
    vec2 phiThetaT = vec2(phiTheta.s + 0.05*iTime, phiTheta.t);
    float a = textureLod(iChannel0, phiThetaT*vec2(1.0,3.0), 0.0).r;
    a = 0.75*a*a;
    return a*vec4(vec3(1.0), 1.0);
}

// Function 3714
float fCone(vec3 p, float radius, float height) {
	vec2 q = vec2(length(p.xz), p.y);
	vec2 tip = q - vec2(0.0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.0)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

