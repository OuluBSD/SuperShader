// Reusable Ray Operations Raymarching Functions
// Automatically extracted from raymarching/raytracing-related shaders

// Function 1
vec3 mapRMWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = sdPlane(pt)+waterDetails(pt, iTime);    
    normal.x = (sdPlane(pt)+waterDetails(vec3(pt.x+e,pt.y,pt.z), iTime)) - normal.y;
    normal.z = (sdPlane(pt)+waterDetails(vec3(pt.x,pt.y,pt.z+e), iTime)) - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 2
vec2 calcRayIntersection_3_6(vec3 rayOrigin, vec3 rayDir) {
  return calcRayIntersection_3_6(rayOrigin, rayDir, 20.0, 0.001);
}

// Function 3
vec3 normal(in vec2 a) {
	vec3 n = vec3(0.0);
#ifdef ADDBASE
	n += basen(a);
#endif
#ifdef ADDNOISE
	n += 0.25 * vnoisen2(NOISESCALE * a);
#endif
	return normalize(n);
}

// Function 4
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.0001,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 5
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
   
#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (2.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<104; i++ )
    {
	    float precis = 0.0005*t;
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 6
vec2 safe_normalize(vec2 v)		{ return all(equal(v, vec2(0))) ? vec2(0) : normalize(v); }

// Function 7
vec3 calcNormal(in vec3 p) {
    vec2 e = vec2(1.0, -1.0) * 0.0025;
    return normalize(e.xyy * map(p + e.xyy).x + 
					 e.yyx * map(p + e.yyx).x + 
					 e.yxy * map(p + e.yxy).x + 
					 e.xxx * map(p + e.xxx).x);
}

// Function 8
vec3 Ray(float z,in vec2 u)
{return vec3( u.xy-iResolution.xy*.5,iResolution.x*z );}

// Function 9
vec3 getnormal(vec3 n){
    vec2 e = vec2(1.0,-1.0)*(n.y<0.002-1.?.002:.002);
    return normalize(e.xyy*de(n+e.xyy)+e.yyx*de(n+e.yyx)+e.yxy*de(n+e.yxy)+e.xxx*de(n+e.xxx));
}

// Function 10
RayMarchObject RayMarch(vec3 ro, vec3 rd) 
{
	float dO=0.;
    int materialID;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        RayMarchObject object = GetScene(p);
        float dS = object.dist;
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) {
            materialID = object.materialID;
            break;
        }
    }
    
    return RayMarchObject(materialID, dO);
}

// Function 11
float rayleighPhase(float cosTheta)
{
    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));
    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));
    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));
}

// Function 12
vec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )
{
    #ifdef ENABLE_REFLECTIONS    
    {
        // get colour from reflected ray
        const float fSeparation    = 0.1;

        C_Ray reflectRay;
        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);
        reflectRay.vOrigin = hitInfo.vPos;
        reflectRay.fLength = 16.0;
        reflectRay.fStartDistance = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));
        
        return GetSceneColourSecondary(reflectRay);      
    }
    #else
        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              
    #endif
}

// Function 13
vec4 rayTracing(vec2 fragCoord){
	//cast a ray w/ camera
	
	//(x,y) in range [-1;1] 
	float x = (2.*fragCoord.x - iResolution.x )/iResolution.x;
	float y = (2.*fragCoord.y - iResolution.y )/iResolution.y;
   
	float xMouse = (2.*iMouse.x - iResolution.x )/iResolution.x;
	float yMouse = (2.*iMouse.y - iResolution.y )/iResolution.y;
	
	//camera
	Camera c;
    vec3 u1;
	//c.e = vec3(xMouse*15.,yMouse*15.,15.);//cam position
	c.e = vec3( xMouse*15.,15. + yMouse*15.,15.);//cam position
	c.v = normalize(-c.e);
	u1 = vec3(0.,1.,0.);
	c.r = normalize(cross(c.v,u1));
	c.u = normalize(cross(c.r,c.v));
	
	//Ray
	Ray r;
	float D = 1./tan(PI/4.);
	r.o = c.e;
	vec3 rd = x*c.r + y *c.u+ D*c.v;
	r.d = normalize(rd);    
    
    //Ray Tracing
    float index = -1.;
    vec3 accum = vec3(0.,0.,0.);
    vec3 mask = vec3(1.,1.,1.);
    vec3 color,pos, refl_ray,refr_ray;
	float epsilon =0.;
    float nu1 = 1.;//suppose it's air
    float scal,nu,nu2;
    for(int i=1;i<=STEP_NB;i++){
		MarchingPack rmp = rayC(r,index);
        if(rmp.hit){
    		pos = r.o+r.d*rmp.dist;
			color = directIllumination(c,pos, rmp.dist, rmp.index,c.e.z*2.);
			Properties prop = getProperties(rmp.index);
            vec3 n = getNormal(c,pos,rmp.index);
            accum =  accum + mask*color;
            if(prop.reflective){ 
                
				mask = mask*prop.c_refl;
                refl_ray =  normalize ( 2.*n*(dot(n,-r.d)) + r.d );
				r = Ray(pos,refl_ray);
                
            }else if(prop.transmissive){
                
				mask = mask*prop.c_trans;
                nu2 = prop.c_trans;
                nu = nu1/nu2;
                scal = dot(n,-r.d);
                refr_ray = ( nu*scal - sqrt( 1.- nu*nu*(1. - scal*scal)) )*n - nu*(-r.d);
                refr_ray = normalize(refr_ray);
				r = Ray(pos,refr_ray);
                nu1 = prop.c_trans;
                
            }else{//ray is absorbed
    			return vec4(accum,1.);
                
            }
            
         	index = rmp.index;
            
        }else{
            color = mask;
    		return vec4(accum,1.);
        }
    }
    
    return vec4(accum,1.);
   // return vec4(accum/float(STEP_NB),1.);
	
    
    
}

// Function 14
float Raymarch(in vec3 from, in vec3 to, in mat3 matrix)
{
    float dist  = MIN_DIST;
    float depth = 0.0;

    for(int i = 0; i < NUM_STEPS; ++i)
    {
        if(dist < MIN_DIST || depth > MAX_DIST) 
            break;

        dist  = Pentagram((from + to * depth) * matrix);
        depth += dist;

        // past maximum raymarch distance - no surface hit
        if(depth > MAX_DIST)
            return 0.0;
    }

    return depth;
}

// Function 15
vec3 calcNormal( in vec3 pos )
{
#if 1
    // vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    vec2 e = vec2( 2.0, -2.0 ) * 0.6773 * 0.02;
    return normalize( e.xyy*map( pos + e.xyy ).t + 
					  e.yyx*map( pos + e.yyx ).t + 
					  e.yxy*map( pos + e.yxy ).t + 
					  e.xxx*map( pos + e.xxx ).t );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3( 0.0 );
    for( int i = ZERO; i < 2; i++ )
    {
        vec3 e = 0.6773*(3.0*vec3((((i+4)>>2)&2),((i>>2)&2),(i&2))-2.0);
        n += e * map( pos + 0.0006 * e ).x;
    }
    return normalize( n );
#endif    
}

// Function 16
Ray genRay( in Camera c, in vec2 uv, in vec2 xi ) {
    Ray ray;
    
    vec2 ixy = (uv-0.5)*c.iPlaneSize;
	vec3 dirLocal = normalize(vec3(ixy, -1.0));
    vec3 posGlobal = c.pos;//cs_.posToGlobal(vec3(0.0));
	vec3 dirGlobal = c.rotate*dirLocal;
	return Ray(posGlobal, dirGlobal);

    /*
	vec2 ixy = (uv - 0.5) * c.iPlaneSize;
    
    if( c.lensSize > EPSILON ) {
        vec2 uv = uniformPointWithinCircle( c.lensSize, xi );
        vec3 newPos = c.pos + c.rotate[0]*uv.x*c.lensSize + c.rotate[1]*uv.y*c.lensSize;
        vec3 focusPoint = c.pos - c.focusDist*c.rotate[2];
        vec3 newBack = normalize(newPos - focusPoint);
        vec3 newRight = normalize( cross( c.rotate[1], newBack ) );
        vec3 newUp = cross( newBack, newRight );
        mat3 newRotate;
        newRotate[0] = newRight;
        newRotate[1] = newUp;
        newRotate[2] = newBack;


        ray.origin = newPos;
        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    } else {
        ray.origin = c.pos;
        ray.dir = c.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    }

	return ray;*/
}

// Function 17
vec3 sdfNormal(vec3 p, float epsilon, bool detail)
{
    vec3 normal = vec3(0.0);
    float s = sdf(p, detail);
    
    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, detail) - s;
    }
    
    return normalize(normal);
}

// Function 18
vec2 RayMarch(vec3 r_origin, vec3 r_direction)
{
    float d_origin = 0.;
    float min_dist = 1000000.0;
    
    for(int i=0; i<MAX_STEPS; i++) 
    {
        vec3 p = r_origin + d_origin*r_direction;
        float d_surf = GetDist(p);
        min_dist = min(d_surf, min_dist);
        d_origin += d_surf;
        if(d_surf<MIN_DIST || d_origin>MAX_DIST) break;
    }
    
    return vec2(d_origin,min_dist);
}

// Function 19
vec3 calcNormal( in vec3 p ) {
    const float h = 1e-4;
    vec3 n = vec3(0.0);
    for(int i = min(iFrame,0); i<4; i++) {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(p+e*h).x;
    }
    return normalize(n);
}

// Function 20
float traceRay(in vec3 ro, in vec3 rd)
{
    vec3 p = ro;
    float d = map(p);
    float dAcc = d;
    bool hit = (d < epsilon || dAcc >= t_max);
    for(int i = 0; i < MAX_SPHERETRACE_STEP; i++)
    {
        if(hit)
            break;
        else
        {
            p += d * rd;
            d = map(p);
            dAcc += d;
            hit = (d < epsilon || dAcc >= t_max);
        }
    }
    return dAcc;
}

// Function 21
vec3 normal(vec3 p)
{
    vec2 n = vec2(2,-2)*EPS;
    return normalize(dist(p+n.xxy)*n.xxy+
    dist(p+n.xyx)*n.xyx+dist(p+n.yxx)*n.yxx+dist(p+n.y)*n.y);
}

// Function 22
void rayCast(inout float dist, inout vec3 pos, in vec3 rayDir )
{
    float totalDist = 0.0;
    
    for (int i = 0; i < MAX_ITER; i++)
    {
    	// Either we've hit the object or hit nothing at all, either way we should break out of the loop
        if (dist < EPSILON || totalDist > MAX_DIST)
            break; // If you use windows and the shader isn't working properly, change this to continue;

        dist = distfunc(pos).x; // Evalulate the distance at the current point
        totalDist += dist;
        pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance
    }
}

// Function 23
vec3 get_normal(vec3 point) {
	float d0 = get_distance(point);
	float dX = get_distance(point-vec3(epsilon, 0.0, 0.0));
	float dY = get_distance(point-vec3(0.0, epsilon, 0.0));
	float dZ = get_distance(point-vec3(0.0, 0.0, epsilon));
		
	return normalize(vec3(dX-d0, dY-d0, dZ-d0));
}

// Function 24
vec3 getNormal(vec3 p)
{
	float d=0.01;
	return normalize(vec3(
        dist_func(p+vec3(d,0.0,0.0))-dist_func(p+vec3(-d,0.0,0.0)),
        dist_func(p+vec3(0.0,d,0.0))-dist_func(p+vec3(0.0,-d,0.0)),
        dist_func(p+vec3(0.0,0.0,d))-dist_func(p+vec3(0,0.0,-d))
    ));
}

// Function 25
vec3 normal(in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.005;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 26
vec3 getNormal(in vec3 p) {
    vec3 e = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),
                          mapScene(p + e.yxy) - mapScene(p - e.yxy),
                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));
}

// Function 27
vec3 rayBackground(vec3 rp, vec3 rd) {
    return vec3(0);
}

// Function 28
vec3 castRay( in vec3 ro, in vec3 rd, in float maxd ) {
	float d = MAX_DIST;
	float lastt, t = PRECISION*10.0;
    
	// edge detection
    float lastDistEval = 1e10;
	float edge = 0.0;
    float iter = 0.;
    //float dmin = MAX_DIST; // min sur le chemin (ne compte pas l'intersection)
    
    for( int i=0; i<NB_ITER; i++ ) {
		if (d<PRECISION || t>maxd) break;
        
		d = map(ro+rd*t);       
        if (d < lastDistEval) {
            lastt = t;
            lastDistEval = d;
        } else if (d > lastDistEval + 0.00001 && lastDistEval/lastt < EDGE_WIDTH) {
			edge = 1.0;
		}
		t += d;// + t*1e-3;
       // iter++;
	}
	return vec3(t, edge, iter);
}

// Function 29
vec3 normal( vec3 pos ) {
	const vec3 dx = vec3( grad_step, 0.0, 0.0 );
	const vec3 dy = vec3( 0.0, grad_step, 0.0 );
	const vec3 dz = vec3( 0.0, 0.0, grad_step );
	return normalize (
		vec3(
			map( pos + dx ).x - map( pos - dx ).x,
			map( pos + dy ).x - map( pos - dy ).x,
			map( pos + dz ).x - map( pos - dz ).x			
		)
	);
}

// Function 30
bool ray_intersect(Sphere s, vec3 orig, vec3 dir, out float t0) {
  vec3 center = s.center;
  float radius = s.radius;
  vec3 L = center - orig;
  float tca = dot(L,dir);
  float d2 = dot(L,L) - tca*tca;
  float disc = radius*radius - d2;
  if (disc < 0.0) return false;
  float thc = sqrt(disc);
  // t0*t1 = tca^2 - thc^2 = tca^2 - disc
  float t1, K = tca*tca - disc;
  if (tca < 0.0) {
    t0 = tca - thc;
    t1 = K/t0;
  } else {
    t1 = tca + thc;
    t0 = K/t1;
  }
  if (t0 < 0.0) t0 = t1;
  if (t0 < 0.0) return false;
  return true;
}

// Function 31
float ray(vec3 ro, vec3 rd, float t) 
{
    vec3 p = ro+t*rd;
    float h = 0.;
    for (int i=0;i<100;i++) {
        float h = p.y-srf(p.xz,ITERS_RAY, iTime).x;
        if (h<t*EPS*4.) return t;
        t+=h;
        p+=rd*h;
    }
    return t;
}

// Function 32
float raymarching(
  in vec3 prp,
  in vec3 scp,
  in int maxite,
  in float precis,
  in float startf,
  in float maxd,
  out int objfound)
{ 
  const vec3 e=vec3(0.1,0,0.0);
  float s=startf;
  vec3 c,p,n;
  float f=startf;
  objfound=1;
  for(int i=0;i<256;i++){
    if (abs(s)<precis||f>maxd||i>maxite) break;
    f+=s;
    p=prp+scp*f;
    s=obj(p);
  }
  if (f>maxd) objfound=-1;
  return f;
}

// Function 33
vec3 calcNormal(vec3 pos, float t )
{
    const float worldStep = 1.0 / 4.0;

	float uvStep = (1.0 / resolution.x);
	vec2 eps = vec2((worldStep * t), 0.0);
	float run = ((2.0 * eps.x) * uvStep);

    return normalize(vec3(terrainHeight(pos.xy - eps.yx) - terrainHeight(pos.xy + eps.yx),
                          terrainHeight(pos.xy - eps.xy) - terrainHeight(pos.xy + eps.xy),
						  run));
}

// Function 34
Ray Camera_getRay(Camera cam, vec2 uv) {
    return Ray(cam.origin, 
               normalize(cam.ll + uv.x * cam.width * cam.u + uv.y * cam.height * cam.v - cam.origin));
}

// Function 35
vec3 getNormal(vec3 p, float eps) {
    // bteitler: Approximate gradient.  An exact gradient would need the "map" / "map_detailed" functions
    // to return x, y, and z, but it only computes height relative to surface along Y axis.  I'm assuming
    // for simplicity and / or optimization reasons we approximate the gradient by the change in ocean
    // height for all axis.
    vec3 n;
    n.y = map_detailed(p); // bteitler: Detailed height relative to surface, temporarily here to save a variable?
    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y; // bteitler approximate X gradient as change in height along X axis delta
    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y; // bteitler approximate Z gradient as change in height along Z axis delta
    // bteitler: Taking advantage of the fact that we know we won't have really steep waves, we expect
    // the Y normal component to be fairly large always.  Sacrifices yet more accurately to avoid some calculation.
    n.y = eps; 
    return normalize(n);

    // bteitler: A more naive and easy to understand version could look like this and
    // produces almost the same visuals and is a little more expensive.
    // vec3 n;
    // float h = map_detailed(p);
    // n.y = map_detailed(vec3(p.x,p.y+eps,p.z)) - h;
    // n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - h;
    // n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - h;
    // return normalize(n);
}

// Function 36
vec2 RayDirToNetXY(vec3 rayDir){
    ivec3 XYFace = RayDirToXYFace(rayDir);
    if(XYFace.z==0){         return 1024.-vec2(XYFace.xy) + vec2(0,1)*1024.;
    } else if(XYFace.z==1){  return 1024.-vec2(XYFace.xy) + vec2(1,2)*1024.;
    } else if(XYFace.z==2){  return 1024.-vec2(XYFace.xy) + vec2(1,1)*1024.;
    } else if(XYFace.z==3){  return 1024.-vec2(XYFace.xy) + vec2(2,1)*1024.;
    } else if(XYFace.z==4){  return 1024.-vec2(XYFace.xy) + vec2(1,0)*1024.;
    } else if(XYFace.z==5){  return 1024.-vec2(XYFace.xy) + vec2(3,1)*1024.;
    } else return vec2(0);
}

// Function 37
float rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)
{
    vec3 n = b - a;
    float D = length(n);
    float cosnd = dot(n, d)/D; //ray plane normal angle cosine
    float l = D*.5 - dot(p - a, n)/D;
    float t = l/cosnd; //ray parameter
    return (cosnd>0.)?t:1e10;
}

// Function 38
vec3 normal(in vec3 p){
  
    vec2 e = vec2(-1., 1.)*.001;  
    
	float d1 = map(p + e.yxx).x, d2 = map(p + e.xxy).x;
	float d3 = map(p + e.xyx).x, d4 = map(p + e.yyy).x; 
    
    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );
	return n1;   
}

// Function 39
Ray rayScreen(in vec2 p, in Camera c) {
  return ray(c.pos, normalize(_mat3(c) * vec3(p.xy, -c.fcs)));
}

// Function 40
bool raymarch(in vec3 ro, in vec3 rd, inout float t, in float tmax, in surface paras,
           in bool useFirstOrder, in bool usePowerMethod,
           out float dist, out int steps) {      
      steps = 0;
      dist = 10000.0;
      vec3 pos;
      float lastT = 0.;  
      for (int i = 0; i < maxSteps; i++) {
        pos = ro + t * rd;
        float d = DE(pos, paras, useFirstOrder, usePowerMethod);
        // hit surface
        if (d < eps) {
          dist = 0.;
          t = lastT;
          return true;
        }
        // update step
        lastT = t;
        t += d;
        steps++;
        // ray outside rang
        if (t > tmax)
          return false;
      }
      return false; // i >= maxSteps      
}

// Function 41
vec3 sdBoxNormal (vec3 p, vec3 b)
{
    // XXX: did I flip all the signs?
    if (abs(p.x) > abs(p.y)) {
        if (abs(p.x) > abs(p.z)) {
            return vec3(sign(p.x), 0, 0);
        } else {
            return vec3(0, 0, sign(p.z));
        }
    } else {
        if (abs(p.y) > abs(p.z)) {
            return vec3(0, sign(p.y), 0);
        } else {
            return vec3(0, 0, sign(p.z));
        }
    }
}

// Function 42
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 200; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 43
vec3 refraction(in vec3 v, in vec3 normal, inout float n1, inout float n2)
{
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    if (sinA > n2 / n1) {
        return normalize(reflect(v, normal));
    }
    vec3 tang = normalize(v - cosA * normal);
    float sinB = sinA * (n1 / n2);
    float cosB = sqrt(1.0 - sinB * sinB);
    float tmp = n1;
    n1 = n2;
    n2 = tmp;
    return normalize(sinB * tang + cosB * normal);
}

// Function 44
vec4 raymarchGas(vec3 ro, vec3 rd,
                  in float tmin, in float tmax,
                  in vec2 uv,
                  in vec3 Lp,
                  in vec3 Lcolor,
                  out float blendAlpha)
{
    if(tmax<0. || tmin<0.) return vec4(1., 0., 0., 0.);
    float maxTargetTravel = tmax-tmin;
    float cStep = 0.08;
    float vStep = maxTargetTravel*cStep;
    vec3 totalRadiance = vec3(0.);
    float Tr = 1.;
    float screenShift = 1.0*hash2D(rd.xy+fract(iTime));
    tmin -= vStep*screenShift;
    float d = tmin;
    #if defined(USE_SKY) && defined(CLOUDS_RAYMARCH_MIE)
    vec3 miec;
    vec3 Pa = ro+rd*tmax;
    Lcolor = getSkyLight(Pa, RotXV3(normalize(Lp-Pa), 90.*(-1.+2.*hash2D(10.*uv+fract(iTime)))), Lp, SKY_BETA_RAY, SKY_BETA_MIE, miec, SKY_MIE_HEIGHT);
    Lcolor = miec;
    #endif
    for(d=tmin; d<tmax; d+=vStep)
	{
        vec3 P = ro+rd*d;        
        vec3 L = normalize(Lp-P);
        // map
        #ifdef USE_TEXTURE_MAP
        float map = 1.;
        #else
        float map = max(0., length(P-TARGETPOS)); // not 1-x, magic
        #endif
        // density
        float den = map*density(P, TARGETPOS);
        if(den>0.)
        {
            float sumLuminance = 0.;
            float transmittance = 1.;
            float phase = 0.;
            {
            	float mu = dot(rd, L);
                float cosAngle = 0., g = 0.;
                cosAngle = mu; g = mix(-.30, .50, .5);//.5*(1.+cosAngle));
                phase = mix(phaseHenyeyGreenstein(-.2, mu), phaseHenyeyGreenstein(.8, mu), .5);
            }
            sumLuminance += phase * transmittance;
            float accDensity = 0., accLength = 0.;
            #ifdef USE_TEXTURE_MAP
            float stepL = (CLOUDEND-CLOUDSTART)*0.01;
            #else
            float stepL = 0.1;
            #endif
            for(int i = 0;i < 4; ++i)
            {
                vec3 Pl = P+L*float(i)*stepL;
        		#ifdef USE_TEXTURE_MAP
                	float lmap = 1.0;
                #else
                	float lmap = max(0., TARGETSIZE-length(Pl-TARGETPOS))/TARGETSIZE;
                #endif
                float det = lmap*density(Pl, TARGETPOS);

                #ifdef USE_TEXTURE_MAP
                transmittance *= BeersPowder(det, stepL, 1.);
                #else
                transmittance *= exp(-det*float(i)*stepL);
                accDensity += det;
                accLength += float(i)*stepL;
                #endif
                stepL *= 1.6;
                if(transmittance<=0.05) break;
            }
            #ifdef USE_TEXTURE_MAP
            // Use computed transmittance for the shadowing, then overwrite it to compute the proper
            // transmittance
            sumLuminance = phase * SUNINTENSITY * transmittance;
            //
            transmittance = BeersPowder(den, vStep, 1.);
            #else
            sumLuminance = phase * SUNINTENSITY * exp(-accDensity*accLength);
            #endif
            float nPy = length(P-EARTHPOS);
            float amb = mix(0.05, 0.2, remap01(nPy, CLOUDSTART, CLOUDEND));
            vec3 radiance = (amb + sumLuminance*Lcolor)*den;
            // scattering
            totalRadiance += Tr * (radiance-transmittance*radiance) / den;
            Tr *= transmittance;
            if(Tr<=0.05) break;
            vStep = maxTargetTravel*cStep*.5;
        }
        else
           vStep = maxTargetTravel*cStep;
	}
    {
        vec3 Pmax = ro+rd*(tmax-screenShift);
        float mu = dot(rd, normalize(Lp-Pmax));
        //d = 1.;
        float phase = 0.;
        {
            float cosAngle = 0., g = 0.;
            cosAngle = mu; g = mix(-.30, .50, 0.5);
            phase = phaseHenyeyGreenstein(g, cosAngle);
        }
        vec2 P2d = 0.5*(Pmax.xz/Pmax.y);
        P2d.y = 1.-P2d.y;
        float tex = remap01(texture(iChannel3, 100.1*P2d
    	#if !defined(CLOUDS_FIXED_POS)
                                    +.001*iTime
    	#endif
                                   ).r, .4, 1.);
        tex = pow(tex, 1.);
        float mainForm = clamp(tex*tex*(3.-2.*tex), 0., 1.);
        float den = max(0., mainForm-.2*fbm_hash(20.*P2d+iTime));
        if(den>0.)
        {
            float transmittance = BeersPowder(den, 2., 1.);
            float lum = phase * transmittance;
            vec3 radiance = (0.08+lum*Lcolor)*den;
            totalRadiance += Tr * (radiance-transmittance*radiance) / den;
            Tr *= transmittance;
        }
    }   
    float rdy = remap01(tmin, 1e5, 6e5);
    rdy = 1.-(exp(-8.*rdy));
    
    blendAlpha = clamp(rdy, 0., 1.);
	return vec4(Tr, totalRadiance);
}

// Function 45
vec4 rayMarch(inout vec3 p, in vec3 rd, out vec3 dists) {
  float dS = 99., d = 0., minDS = dS, steps = 0.;
  for (int i = 0; i < MAX_STEPS; i++) {
    steps += 1.;
    dS = mapWDists(p, dists);
    minDS = min(minDS, abs(dS));
    d += dS;
    p = p + rd * dS;
    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;
  }
  return vec4(d, dS, minDS, steps);
}

// Function 46
vec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {
    vec2 xy = fragCoord - resolution.xy / 2.0;
    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 47
vec3 normal(vec3 p, vec3 dir) {
    vec3 n = vec3(
        sceneDist(vec3(p.x + NORMAL_EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - NORMAL_EPSILON, p.y, p.z)),
        sceneDist(vec3(p.x, p.y + NORMAL_EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - NORMAL_EPSILON, p.z)),
        sceneDist(vec3(p.x, p.y, p.z  + NORMAL_EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - NORMAL_EPSILON))
    );

    return normalize(n - max(0.0, dot(n, dir)) * dir);
}

// Function 48
void normal(inout ray _r)
{
    vec2 eps = vec2(.001,.0);
    float dx = map(_r.hp + eps.xyy).x - map(_r.hp - eps.xyy).x;
    float dy = map(_r.hp + eps.yxy).x - map(_r.hp - eps.yxy).x;
    float dz = map(_r.hp + eps.yyx).x - map(_r.hp - eps.yyx).x; 
    _r.n = normalize(vec3(dx,dy,dz));
}

// Function 49
vec4 castRay(vec3 dir, vec3 points[4], vec4 faces[6], vec4 colors[6]){
    //I opted for plain raycasting instead of raymarching because I thought it would improve perfomance.
    //But I'm a terrible graphics programmer, so that didn't turn out to be the case. Oh well.
    
    vec3 u[6]; vec3 v[6];
    //The components of the faces. There has to be a better way to do this...
    u[0] = points[1] - points[0]; v[0] = points[2] - points[0];
    u[1] = points[2] - points[0]; v[1] = points[3] - points[0];
    u[2] = points[3] - points[0]; v[2] = points[1] - points[0];
    u[3] = points[0] - points[1]; v[3] = points[0] - points[2];
    u[4] = points[0] - points[2]; v[4] = points[0] - points[3]; 
    u[5] = points[0] - points[3]; v[5] = points[0] - points[1];
    
    const vec3 camera = vec3(0, 0, 5);
    float minT = 1e20;
    int bestFace = -1;
    float bestA;
    float bestB;
    
    for(int i = 0; i < 6; i++){ //Iterating over the faces.
        float t = -(faces[i].w + dot(faces[i].xyz, camera))/(dot(faces[i].xyz, dir));
        //The distance to the point of intersection with a face. I guess the formula works?
        if(t < minT && t > 0.0){
        	vec3 p = camera + dir*t; //The actual point of intersection.
        	if(i < 3) p = p - points[0];
        	else p = p + points[0];
            //...And adjusting it so that the following formulas will work.
        	float a = (p.x*v[i].y - p.y*v[i].x)/(u[i].x*v[i].y - u[i].y*v[i].x);
        	float b = (p.x*u[i].y - p.y*u[i].x)/(u[i].y*v[i].x - u[i].x*v[i].y);
            //a and b are the distances along the face components to the point.
            //I would use matrices here, but I don't know any linear algebra :(
            if(a >= 0.0 && a < 1.0 && b >= 0.0 && b < 1.0){
                //Checking to see if the point of intersection is actually on the face.
                minT = t;
            	bestFace = i;
                bestA = a;
                bestB = b;
            }
        }      
    }
    //What do you mean, non-constant array indices aren't allowed? Guess there's this workaround...
    for(int i = 0; i < 6; i++){
        if(bestFace == i) return texture(iChannel0, vec2(bestA, bestB)) * colors[i];
        //Finally returning the point on the face intersecting the ray.
    }
    return background();
}

// Function 50
float castRay(vec3 eye, vec3 ray, out float dist, out vec3 norm) {
    vec3 pos = floor(eye);
    vec3 ri = 1.0 / ray;
    vec3 rs = sign(ray);
    vec3 ris = ri * rs;
    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;
    
    vec3 dim = vec3(0.0);
    for (int i = 0; i < maxIter; ++i) {
        if (voxelHit(pos)) {
            dist = dot(dis - ris, dim);
            norm = -dim * rs;
            return 1.0;
        }
    
        dim = step(dis, dis.yzx);
		dim *= (1.0 - dim.zxy);
        
        dis += dim * ris;
        pos += dim * rs;
    }

	return 0.0;
}

// Function 51
vec3 Normal(vec3 pos) {
    #define swzl vec2(0, MARCH_eps)
    return normalize(vec3(
        (Map(pos+swzl.yxx) - Map(pos-swzl.yxx)).x,
        (Map(pos+swzl.xyx) - Map(pos-swzl.xyx)).x,
        (Map(pos+swzl.xxy) - Map(pos-swzl.xxy)).x
    ));
    #undef swzl
}

// Function 52
vec4 rayCrystal2(vec3 rp, vec3 rd) {
    rp -= crystal2_pos;
    return rayCrystal2B(rp,rd);
}

// Function 53
bool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    float t0, t1;
    vec3 L = ray.origin;
    float a = dot( ray.dir, ray.dir );
    float b = 2.0 * dot( ray.dir, L );
    float c = dot( L, L ) - radiusSquared;
    
    if (!solveQuadratic( a, b, c, t0, t1))
		return false;
    
    if( t0 > 0.0 ) {
    	t = t0;
    } else {
        if ( t1 > 0.0 ) {
            t = t1;
        } else {
            return false;
        }
    }
    
    if( !forShadowTest ) {
        isect.position_ = ray.origin + ray.dir*t;
        isect.normal_ = normalize( isect.position_ );

        float rho, phi, theta;
        cartesianToSpherical( isect.normal_, rho, phi, theta );
        isect.uv_.x = phi/PI;
        isect.uv_.y = theta/TWO_PI;

        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
        vec3 tmp = cross( isect.normal_, isect.tangent_ );
        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );
    }
	
	return true;
}

// Function 54
vec3 getNormal(vec3 p, vec3 rd)
{
	vec3 normal;
    vec3 ep = vec3(0.01, 0, 0);
    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;
    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;
    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;
    return normalize(normal);

}

// Function 55
vec3 calcNormal(vec3 pos)
    { // http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
       vec2 e = vec2(1, -1) * .002;
       return N(e.xyy * map(pos + e.xyy).x +
                e.yyx * map(pos + e.yyx).x +
                e.yxy * map(pos + e.yxy).x +
                e.xxx * map(pos + e.xxx).x);
    }

// Function 56
float ct_normal_pi(
    in vec2 z,
    in float sa
){
    float a = atan(z[1], z[0]) + sa;
    if (a < 0.0) a += 6.28318;
    a /= 6.28318;
    return a;
}

// Function 57
vec2 rayMarch(Ray ray)
{
	float dist = 0.;
    vec2 result = vec2(-1.);
    for(int i = 0; i < 128; ++i)
    {  
        result = sdScene(ray.origin + ray.direction * dist);
        if (result.x < EPS * dist || dist >= cameraFar) break;
        dist += result.x;
    }

    if (dist >= cameraFar) result.y = -1.;
    return vec2(dist, result.y);
}

// Function 58
vec2 rayBox(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal )  {
    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes
    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes
    vec3 k = abs(m)*boxSize;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
    if( tN>tF || tF<0.0) return vec2(miss); // no intersection
    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    return vec2( tN, tF );
}

// Function 59
vec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3  ba = b - a;
    vec3  pa = pos - a;
    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
    return (pa - h*ba)/r;
}

// Function 60
vec3 refraction(vec3 rd, vec3 n, float p) {
	float dot_nd = dot(rd, n);
	return p * (rd - dot_nd * n) + sqrt(1.0 - (p * p) * (1.0 - dot_nd * dot_nd)) * n;
}

// Function 61
vec3 normal(vec2 uv){
    vec3 delta = vec3(1./iResolution.xy, 0.);
    float du = texture(iChannel0, uv + delta.xz).x - texture(iChannel0, uv - delta.xz).x;
    float dv = texture(iChannel0, uv + delta.zy).x - texture(iChannel0, uv - delta.zy).x;
    return normalize(vec3(du,dv,1.));
}

// Function 62
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    float t;
    Material res_mtl;
    SurfaceHitInfo currentHit;
    
    vec3 aabbmin, aabbmax;
    float tt;
    int ballid = -1;
    
    rayTableIntersection(ray, distMin, forShadowTest, hit, nearestDist);
    
   /* vec4 laabb = loadAABB(1);
    vec4 raabb = loadAABB(2);
    
    aabbmin = vec3(laabb.x, -1.0, laabb.y) - EPSILON;
    aabbmax = vec3(laabb.z,  1.0, laabb.w) + EPSILON;
    bool hitl = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    
    aabbmin = vec3(raabb.x, -1.0, raabb.y) - EPSILON;
    aabbmax = vec3(raabb.z,  1.0, raabb.w) + EPSILON;
    bool hitr = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    */
    
    vec4 aabb = loadAABB(0);
    aabbmin = vec3(aabb.x, -1.0, aabb.y) - EPSILON;
    aabbmax = vec3(aabb.z,  1.0, aabb.w) + EPSILON;
    bool bhit = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    
    if(/*forShadowTest || hitl || hitr*/bhit){
        //intersect balls
        for(int i=0; i<numBalls; i++) {
            Ball ball = loadBall(iChannel0, i);

#ifdef MOTION_BLUR
            vec3 pos = mix(ball.mtx_prev[3].xyz, ball.mtx[3].xyz, ray.time);
#else
            vec3 pos = ball.mtx[3].xyz;
#endif
            if(intersectSphere(ray, pos, t) && (t > distMin) && (t < nearestDist)) {
                if(forShadowTest){
                    return false;
                } else {
                    ballid = i;
                    vec3 p = ray.origin + ray.dir * t;
                    hit.normal_ = /*normalize*/(p - pos);//try to remove it's not needed
                    hit.tangent_ = normalize(orthogonalize(hit.normal_, ball.mtx[1].xyz));
                    hit.position_ = p;

                    mat4 mtx;
#ifdef MOTION_BLUR
            		mtx = mtxLerp2(ball.mtx_prev, ball.mtx, ray.time);
#else
            		mtx = ball.mtx;
#endif
                    mat4 inv_mtx = inverse(mtx);

                    vec3 p_local = toVec3( inv_mtx*vec4(p, 1.0));
                    float rho, phi, theta;
                    cart2sph( p_local, rho, phi, theta );
                    hit.uv_.x = clamp((phi+PI*0.5)/PI, 0.0, 1.0);
                    hit.uv_.y = clamp((theta+PI)/TWO_PI, 0.0, 1.0);
                }

                nearestDist = t;
            }
        }

        if(ballid != -1) {
            hit.mtl_id_ = SURFACE_ID_BASE + num_mtl + ballid;
        }
    }
    
    
    //intersect light
    bool hit_result = rayZPlaneIntersection( ray, light.pos, light.size, forShadowTest, t, currentHit );
    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {
        //Convert results to world space
        currentHit.position_ = ray.origin + ray.dir * t;
        currentHit.normal_   = vec3(0.0, -1.0, 0.0);
        currentHit.tangent_  = vec3(-1.0, 0.0, 0.0);

        nearestDist = t;
        hit = currentHit;
        hit.mtl_id_ = LIGHT_ID_BASE+0;
    }
    
    //intersect cue
    float distToCue;
    Cue cue = readCue(iChannel0);
    mat4 inv_mtx = inverse(cue.mtx);
    Ray rayLocal;
    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );
    
    //float h = (cue.h * cue.r0) / (cue.r0 - cue.r1);
    hit_result = rayConeIntersection( rayLocal, cue.r0, cue.r1, cue.h, forShadowTest, distToCue, currentHit );
    if( hit_result && ( distToCue > distMin ) && ( distToCue < nearestDist ) ) {
        currentHit.position_ = ray.origin + ray.dir * distToCue;
        //currentHit.position_ = toVec3( cue.mtx*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( cue.mtx*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( cue.mtx*vec4( currentHit.tangent_ , 0.0 ) );
        currentHit.mtl_id_ = SURFACE_ID_BASE+1;

        hit = currentHit;
        nearestDist = distToCue;
    }
    /*
    //intersect chalk
    inv_mtx = inverse(chalk.mtx);
    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );
    
    hit_result = rayAABBIntersection( rayLocal, -vec3(chalk.size*0.5), vec3(chalk.size*0.5), forShadowTest, t, currentHit );
    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {
        hit = currentHit;
        hit.position_ = ray.origin + ray.dir * t;
        //currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        hit.normal_   = toVec3( chalk.mtx*vec4( currentHit.normal_  , 0.0 ) );
        hit.tangent_  = toVec3( chalk.mtx*vec4( currentHit.tangent_ , 0.0 ) );
        hit.mtl_id_ = SURFACE_ID_BASE+2;

        nearestDist = t;
    }*/
    
    return ( nearestDist < 1000.0 );
}

// Function 63
vec3 normal( in vec3 p )
{
	vec3 eps = vec3(0.001, 0.0, 0.0);
	return normalize( vec3(
		map(p+eps.xyy)-map(p-eps.xyy),
		map(p+eps.yxy)-map(p-eps.yxy),
		map(p+eps.yyx)-map(p-eps.yyx)
	) );
}

// Function 64
vec3 getNormal(vec3 pos, float e)
{  
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,
                          map(pos + q.xyx).x - map(pos - q.xyx).x,
                          map(pos + q.xxy).x - map(pos - q.xxy).x));
}

// Function 65
float ray(inout vec3 cp, vec3 rd, out float st)
{
    float cd = 0.;
    for(st = 0.; st < 1.; st += 1. / 512.)
    {
        cd = map(cp);
        if(abs(cd) < .01)
            break;
        cp += rd * cd;
    }
    
    return cd;
}

// Function 66
vec3 getNormal(vec3 pos, float e)
{  
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e2*map(pos + e*e2, false).x;
    }
    return normalize(n);
}

// Function 67
float RaymarchScene(in Ray ray, inout float nearest)
{
    float sdf = FarClip;
    
    vec3 o = (ray.origin) + (ray.direction * 2.0);
    
    for(float depth = NearClip; depth < FarClip; )
    {
    	vec3 pos = o + (ray.direction * depth);
        
        sdf = Scene_SDF(pos);
        nearest = min(sdf, nearest);
        
        if(sdf < Epsilon)
        {
            return depth;
        }
        
        depth += sdf;
    }
    
    return FarClip;
}

// Function 68
rayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,int rotation){
    float N=5.; 
	rayCastResults  res;
    
    vec3 c=vec3(.5);
    float theta= PI/2.*float(rotation%4);
    rayPosOrig = rotate( theta,3) *(rayPosOrig-c) +c;
    rayDir= rotate( theta,3)*rayDir; 
    theta= PI/2.*float(rotation/4);
    rayPosOrig = rotate( theta,2) *(rayPosOrig-c)+c;
    rayDir= rotate( theta,2)*rayDir; 
    
    
     vec3 ro = (rayPosOrig) *N;

    
	//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);

       
	vec3 ri = 1.0/rayDir;
	vec3 rs = sign(rayDir);
    vec3 pos = floor(ro+rs*0.001);
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	
	res.hit=false;
	vec3 mm = vec3(0.);
    float t=0.;
    
	for( int i=0; i<int(N)*3; i++ ) 
    {	
        if(i>0){
            mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);
            vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
            t = max ( mini.x, max ( mini.y, mini.z ) );
        }	
        
        dis += mm * rs * ri;
        pos += mm * rs;
        if( sdBox( ro+t*rayDir-vec3(N/2.),vec3(N/2.) )>.05) {res.hit=false; break;}
        
        //SHAPES
        
     
        float x= floor(mod(iTime,N));
        //SINGLE BLOCK
        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}
     

        if(shape==1){// POLE
        	if( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}
	      
        }else if(shape==2){//STEP 1
            if(sdBox( pos-vec3(2.,2.,0.) +rs*0.001 ,vec3(2.5,2.5,0.5) )<.01) {res.hit=true; break;}
          
        }else if(shape==3){//STEP 2
             if( sdBox( pos-vec3(2.,2.,0.) +rs*0.001 ,vec3(2.5,2.5,1.5) )<.01) {res.hit=true; break;}
           
        }else if(shape==4){//FENCE 1
         	if( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}
          	if( sdBox( pos-vec3(2.,2.,4.) +rs*0.001 ,vec3(.5,2.5,.5) )<.01) {res.hit=true; break;}
          
        }else if(shape==5){//FENCE 2
        	if( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}
          	if( sdBox( pos-vec3(1.,2.,4.) +rs*0.001 ,vec3(1.5,.5,.5) )<.01) {res.hit=true; break;}
          	if( sdBox( pos-vec3(2.,1.,4.) +rs*0.001 ,vec3(.5,1.5,.5) )<.01) {res.hit=true; break;}

        }else if(shape==6){//SLOPE 1
            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0. ) {res.hit=true; break;}
            
        }else if(shape==7){//PANEL
            if(sdBox( pos-vec3(0.,2.,2.) +rs*0.001 ,vec3(.5,2.5,2.5) )<0.) {res.hit=true; break;}
            
        }               
	}

    if(res.hit){
        res.normal = (- mm*rs); 
        vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
        res.dist =max ( mini.x, max ( mini.y, mini.z ) )/N;
       // res.rayPos =(ro+res.dist*rayDir)/N;

    }
    return res;
   

}

// Function 69
vec3 sceneNormal(vec3 point, float worldTime) {
  #if 0
    float epsilon = 0.0001;
    vec3 xOffset = vec3(epsilon, 0.0, 0.0);
    vec3 yOffset = vec3(0.0, epsilon, 0.0);
    vec3 zOffset = vec3(0.0, 0.0, epsilon);
    
    vec3 direction = vec3(
        sceneDistance(point + xOffset, worldTime) - sceneDistance(point - xOffset, worldTime),
        sceneDistance(point + yOffset, worldTime) - sceneDistance(point - yOffset, worldTime),
        sceneDistance(point + zOffset, worldTime) - sceneDistance(point - zOffset, worldTime)
    );
    
    return normalize(direction);
  #else
    // Snagged from iq's "Raymarching - Primitives" shader,
    // which in turn says this is inspired by tdhooper and klems.
    vec3 n = vec3(0.0);
    for(int i = ZERO; i < 4; i += 1) {
        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);
        n += e * sceneDistance(point + 0.0005 * e, worldTime);
    }

    return normalize(n);
  #endif
}

// Function 70
Ray getRay(Camera c, vec2 ndc)
{
    Ray r;
    r.o = c.pos;
    r.d = normalize(c.z + c.x*ndc.x + c.y*ndc.y);
    return r;
}

// Function 71
vec3 GetNormal(vec3 p)
{   float d = GetDist(p).x;
    vec2 e = vec2(.001, 0);
    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);
    return normalize(n);
}

// Function 72
float rayleigh_phase_func(float mu)
{
	return
			3. * (1. + mu*mu)
	/ //------------------------
				(16. * PI);
}

// Function 73
vec3 ObjectNormal(in vec3 p )
{	
    float eps = 0.001;
    float v = Object(p);
    vec3 n;
    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;
    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;
    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;
    return normalize(n);
}

// Function 74
float rayIntersect(const vec3 ro, const vec3 rd, const float prec, const float mind, const float maxd)
{
    float h, t = mind;
    for(int i=0; i < MAX_RAYMARCHING_ITERATION; i++)
    {
        h = distFunc(ro+rd*t);
        if (h<prec*t||t>maxd)break;
        t += h;
    }
    return t;
}

// Function 75
vec3 calcNormal( in vec3 pos )
{
#if 0    
    vec3 eps = vec3(0.002,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.002*e).x;
    }
    return normalize(n);
#endif    
}

// Function 76
float ExObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 120; j ++) {
    d = ExObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFarEx) break;
    dHit += d;
  }
  return dHit;
}

// Function 77
vec3 calcNormalstage9(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage9 (p+e.xyy) - mapstage9(p-e.xyy),
            mapstage9 (p+e.yxy) - mapstage9(p-e.yxy),
            mapstage9 (p+e.yyx) - mapstage9(p-e.yyx)                            
        )
	);
}

// Function 78
Hit raymarch(CastRay castRay){

    float currentDist = INTERSECTION_PRECISION * 2.0;
    Model model;

    Ray ray = Ray(castRay.origin, castRay.direction, 0.);

    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){
        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {
            break;
        }
        model = map(ray.origin + ray.direction * ray.len);
        currentDist = model.dist;
        ray.len += currentDist * FUDGE_FACTOR;
    }

    bool isBackground = false;
    vec3 pos = vec3(0);
    vec3 normal = vec3(0);
    vec3 color = vec3(0);

    if (ray.len > MAX_TRACE_DISTANCE) {
        isBackground = true;
    } else {
        pos = ray.origin + ray.direction * ray.len;
        normal = calcNormal(pos);
    }

    return Hit(ray, model, pos, isBackground, normal, color);
}

// Function 79
vec3 calcNormal(vec3 p, float t) {
	vec2 e = vec2(EPSILON*t,0.);
    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),
                  dstScene(p+e.yxy)-dstScene(p-e.yxy),
                  dstScene(p+e.yyx)-dstScene(p-e.yyx));
    return normalize(n);
}

// Function 80
void setArray(in float id, in vec4[ARRAY_MAX] va, inout vec4 fragColor, in vec2 fragCoord)
{
    for (int i = 0; i < ARRAY_MAX; ++i)
    {
        vec2 re = vec2(id + float(i), .0);
        fragColor = (isInside(fragCoord, re) > 0.0) ? va[i] : fragColor;
    }
}

// Function 81
vec4 RayMarch(Ray initialRay)
{
	if (TerrainMiss(initialRay))
	{
		return SKY;
	}
	
	// raycast directly to MAX_H if above MAX_H and casting downwards
	if (initialRay.origin.z > MAX_H && initialRay.direction.z < 0.0)
	{
		initialRay = CastRay(initialRay, (initialRay.origin.z - MAX_H) / abs(initialRay.direction.z));
	}
	
	float marches = Marches();
	float delt = MAX_H / marches / abs(initialRay.direction.z);
	
	for(float t = 0.0; t <= INF;  t++)
	{
		if (t > marches)
		{
			break;
		}
				
		float dist = delt * t;
		Ray ray = CastRay(initialRay, dist);
		
		// We marched our way right out of the terrain bounds...
		if (TerrainMiss(ray))
		{
			return SKY;
		}
		
		if (ray.origin.z < TerrainHeight(ray.origin))
		{
			// todo: ray backtracing
			return TerrainColor(ray.origin);
		}
	}
	
	return RED;
}

// Function 82
vec3 ray(vec3 p, vec3 d)
{
    const vec3 grass_color = vec3(0.63, 1.0, 0.31);
    const vec3 dirt_color = vec3(0.78, 0.56, 0.4);
    const vec3 ambient_color = vec3(0.5, 0.5, 0.5);
    const vec3 sun_color = vec3(0.5, 0.5, 0.5);
    const float view_distance = 75.0;

    TraceResult r = traceVoxel(p, d, view_distance);
    TraceResult rc = traceClouds(p, d, view_distance);
    if (rc.hit && (!r.hit || rc.r > r.r))
        r = rc;
    if (r.hit)
    {
        float sun_factor = max(0.0, dot(r.n, sun_dir));
        
        float fog_factor = min(1.0, sq(length(r.p - p) / view_distance));
        vec3 fog_color = background(d);

        if (r.vp.y == cloud_height)
        {
            vec3 c = 1.9 * ambient_color + sun_factor * sun_color;
            return mix(c, fog_color, fog_factor * 0.6 + 0.4);
        }

        if (sun_factor > 0.0)
        {
        	float sd = (cloud_height - r.p.y) / sun_dir.y;
            if (traceVoxel(r.p, sun_dir, sd).hit)
                sun_factor = 0.0;
            else if (traceClouds(r.p, sun_dir, sd + 2.0).hit)
                sun_factor *= 0.3;
        }

        float ambient_factor = sample_ao(r.vp, r.p, r.n);

        float texel_noise = textureLod(iChannel0, r.p * 0.5, 0.0).r;

		float grass_mix = 0.0;
        if (!voxel(r.vp + vec3(0, 1, 0)))
        {
            if (texel_noise * 4.0 + floor(fract(r.p.y) * 16.0) > 15.0)
                grass_mix = 1.0;
            else
                grass_mix = max(0.0, r.n.y);
        }

        vec3 texel = vec3(texel_noise) * 0.3 + 0.7;
        vec3 diffuse = texel * mix(dirt_color, grass_color, grass_mix);
        vec3 c = diffuse * (ambient_factor * ambient_color + sun_factor * sun_color);

        return mix(c, fog_color, fog_factor);
    }
    return background(d);
}

// Function 83
void RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
{
    // floor
    {
    	SMaterial material;
        material.diffuse = vec3(0.1f, 0.1f, 0.1f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), -5.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = intersectPos.xz;
                        
            uv = fract(uv / 75.0f);
            
            float dist = min(abs(uv.x - 0.5), abs(uv.y - 0.5));
            dist = step(dist, 0.005f);
                       
            float len2d = (cos(intersectPos.x * 0.01530f + intersectPos.y * 0.06320f) + 1.0f) / 2.5f;
            
            vec3 brightPurple = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f));
            brightPurple = mix(brightPurple, vec3(0.0625f, 0.0f, 1.0f), len2d);
            
            vec3 darkPurple = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));
            
            hitInfo.material.emissive = mix(darkPurple, brightPurple, dist);
            hitInfo.material.specular = mix(vec3(0.33f, 0.33f, 0.33f), vec3(0.0f, 0.0f, 0.0f), dist);
        }
    }
    
    // reflective balls
    {
    	SMaterial material;
        material.diffuse = vec3(0.5f, 0.5f, 0.5f);
        material.specular = vec3(1.0f, 1.0f, 1.0f);
        material.roughness = 0.035f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	TestSphereTrace(rayPos, rayDir, hitInfo, vec4(20.0f, 5.0f, -20.0f, 10.0f), material);
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-60.0f, 0.0f, 20.0f, 10.0f), material);
        
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 5.0f,  -65.0f, 10.0f), material);
        
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(15.0f, -3.0f, 65.0f, 2.0f), material);
    }
    
    // Cylinders with mountain cutouts - draw front to back
    {
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo,  284.0f, 700.0f, 50.0f);
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1337.0f, 800.0f, 150.0f);
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1932.0f, 900.0f, 250.0f);
	}
    
    // dark sun with gradient
    {
    	SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
        
        SRayHitInfo oldHitInfo = hitInfo;
        
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 0.0f, -1.0f)), -1000.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = intersectPos.xy;
            
            int stripe = int((-uv.y + 500.0f) / 50.0f);
            if (stripe > 1)
                stripe = (stripe-1) % 2;
            else
                stripe = 0;
            
            if (length(uv) > 500.0f)
            {
                hitInfo = oldHitInfo;
            }
            else if (stripe == 1)
            {
                hitInfo.material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));
            }
            else
            {
                vec3 topColor = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f));
                vec3 bottomColor = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));

                float lerp = clamp((uv.y - 100.0f) / 400.0f, 0.0f, 1.0f);
                lerp = Bias(lerp, 0.05);
                hitInfo.material.emissive = mix(bottomColor, topColor, lerp);
            }
        }
    }
    
    // ringed planet
    {
        // planet
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.0f, 0.0f, 0.0f);
            if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 500.0f, -1200.0f, 200.0f), material))
            {
                // TODO: gradient: yellow to red, then red to purple?
                vec3 intersectPos = rayPos + rayDir * hitInfo.dist;

                float lerpTop = clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);
                float lerpMiddle = 1.0f - clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);
                float lerpBottom = clamp((intersectPos.y - 500.0f) / -200.0f, 0.0f, 1.0f);
                
                lerpTop = Bias(lerpTop, 0.1f);
                lerpMiddle = Bias(lerpMiddle, 0.9f);
                lerpBottom = Bias(lerpBottom, 0.1f);

                vec3 color = vec3(1.0f, 1.0f, 0.0f) * lerpTop;
                color += vec3(1.0f, 0.0f, 0.0f) * lerpMiddle;
                color += vec3(1.0f, 0.0f, 1.0f) * lerpBottom;

                hitInfo.material.emissive = color;
            }
        }
        
        // ring
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.8f, 0.0f, 1.0f);// * 2.0f;// * 0.1f;

            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 300.0f, 10.0f, material);
            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 350.0f, 10.0f, material);
            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 375.0f, 10.0f, material);
        }
    }
    
    // sky dome
    {
    	SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));
    	if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 0.0f, 2000.0f), material))
        {
            const float c_skyStarCells = 45.0f;
            
            // convert the hit position to polar, but percentages from 0 to 1.
            // make the pole at the horizon to hide the distortion that would be in the sky otherwise.
            vec3 hitPos = (rayPos + rayDir * hitInfo.dist).yzx;
            float theta = (atan(hitPos.y, hitPos.x) + c_pi) / c_twopi;
            float phi = (atan(sqrt(hitPos.x*hitPos.x + hitPos.y*hitPos.y), hitPos.z) + c_pi) / c_twopi;

            // figure out what cell we are in and the offset in that cell
            vec2 cellIndex = vec2(floor(theta * c_skyStarCells), floor(phi * c_skyStarCells));
            vec2 cellUV = vec2(fract(theta * c_skyStarCells), fract(phi * c_skyStarCells));

            // make a star at a random place in the cell
            float starRadius = hash12(cellIndex) * 0.1f + 0.07f;
			vec2 starPos = hash22(cellIndex) * (1.0f - starRadius * 2.0f) + starRadius;
            float dist = sdStar(starPos - cellUV, starRadius, 4, 3.75f);
            
            dist *= pow(length(starPos - cellUV) / starRadius, 10.0f);
                       
            float value = step(dist, 0.0f);
			value *= pow(1.0f - clamp(length(starPos - cellUV) / starRadius, 0.0f, 1.0f), 3.0f);
                        
            hitInfo.material.emissive = mix(material.emissive, vec3(1.0f, 1.0f, 1.0f), value);            
        }
    }
}

// Function 84
vec3 GetNormal2(vec3 hitPoint) {
    float ep = 0.0002;
#if 0    
    vec3 e=vec3(1e-2,0,0);
    float d = sceneInsideGlassMaterials(hitPoint).x;
    return normalize(vec3(sceneInsideGlassMaterials(hitPoint + e.xyy).x - d,
                          sceneInsideGlassMaterials(hitPoint + e.yxy).x - d,
                          sceneInsideGlassMaterials(hitPoint + e.yyx).x - d));
#else
    // inspired by iq who was inspired by klems
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);
        n += e*sceneInsideGlassMaterials(hitPoint+e*ep).x;
    }
    return normalize(n);
#endif 
}

// Function 85
vec3 getNormal (in vec3 p) {
	vec4 q;
	const vec2 h = vec2 (DELTA, 0.0);
	return normalize (vec3 (
		getDistance (p + h.xyy, q) - getDistance (p - h.xyy, q),
		getDistance (p + h.yxy, q) - getDistance (p - h.yxy, q),
		getDistance (p + h.yyx, q) - getDistance (p - h.yyx, q)
	));
}

// Function 86
float ObjRay (vec3 ro, vec3 rd)
{
  const float dTol = 0.001;
  float d;
  float dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < dTol || dHit > dstFar) break;
  }
  return dHit;
}

// Function 87
vec3 calcNormal( in vec3 pos, in float eps )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, kk ).x + 
					  e.yyx*map( pos + e.yyx, kk ).x + 
					  e.yxy*map( pos + e.yxy, kk ).x + 
					  e.xxx*map( pos + e.xxx, kk ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*eps).x;
    }
    return normalize(n);
#endif    
}

// Function 88
vec3
camera_ray( vec4 camPos, vec4 camRot, vec2 uv )
{
    vec3 ret = normalize( vec3( uv, 1 ) );
    ret.zy = ret.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*ret.yz;
    ret.xz = ret.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*ret.zx;
    return ret;
}

// Function 89
vec4 subRayCast(vec3 ro, vec3 rd) {
    
    vec4 color = vec4(1.0,1.0,1.0,1.0);
 	vec4 color1 = vec4(0.0,1.0,0.2,1.0);
    vec4 color2 = vec4(0.0,0.2,1.0,1.0);
        
    float t = 0.0;
    const int N = 80; // iteration number
    for (int i = 0; i < N; i++) {
        vec3 p = ro+t*rd;
     	float d = -distanceToObjects(p);
        if (d < 0.01) {
        	//color = mix(color1,color2,float(i)/float(N));
            float a = pow(1.5,-2.5*t);
            color = a*shade(p,calculateNormal(p));
            break;
        }
        else {
            t += d;
        }
    }
    
    return color;
}

// Function 90
vec4 ShadowInfoForRay( vec3 seed, vec3 start, vec3 dir, float depth )
{
    if ( depth >= NO_HIT_DEPTH )
	    return ShadowInfoForBackground( seed, start, dir CACHE );

    vec3 hitPos = start + dir * depth;
    
    vec4 res = vec4( 0.0 );
    
    vec3 normal = GetNormal( hitPos CACHE );
    
    const vec3 DirectLightingSampleScale = vec3( 2.0 * BG_BOX_SCALE.x / float( BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT ), 0.0, 2.0 * BG_BOX_SCALE.z / float( BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT ) );
    for ( int z = 0; z < BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT; z++ )
    {
        for ( int x = 0; x < BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT; x++ )
        {
            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            vec3 ceilingPos = vec3( BG_BOX_CENTER.x - BG_BOX_SCALE.x, CEILING_HEIGHT, BG_BOX_CENTER.z - BG_BOX_SCALE.z );
            ceilingPos += vec3( float( x ) + r2.x, 0.0, float( z ) + r2.y ) * DirectLightingSampleScale;
            ceilingPos.x *= GetBrightnessForTime( blobTime );
            vec3 lightDir = normalize( ceilingPos - hitPos );

            float lightDot = dot( lightDir, normal );
            vec3 ignoreHitPos;
            if ( lightDot > 0.0 && !MarchShadowRay( hitPos, lightDir, ignoreHitPos CACHE ) )
                res.x += 1.0;
        }
    }
    res.x /= float( BUF_DIRECT_LIGHTING_SAMPLE_X_COUNT * BUF_DIRECT_LIGHTING_SAMPLE_Z_COUNT );
    
    const float RadiusScale = 1.0 / float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT );
    const float AngleScale = TWOPI / float( BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    for ( int r = 0; r < BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT; r++ )
    {
        for ( int a = 0; a < BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT; a++ )
        {
            // get a weighted point on the hemisphere oriented toward normal.
            // start with random point on unit disc.

            vec2 r2 = rand2( seed );
            seed.xy += r2 * 100.0;

            float angle = (float( a ) + r2.x) * AngleScale;
            float radius = sqrt( (float( r ) + r2.y) * RadiusScale );

            vec2 discPoint = vec2( cos( angle ), sin( angle ) ) * radius;

            vec3 ambientTestDir = GetHemisphereDirForDiscPoint( normal, discPoint );

            vec3 shadowApproxHitPos;
            if ( MarchShadowRay( hitPos, ambientTestDir, shadowApproxHitPos CACHE ) )
                res.z += BlobEmissionAmountAtPos( shadowApproxHitPos );
            else
                res.y += 1.0;
        }
    }
    res.yz /= float( BUF_AMBIENT_LIGHTING_SAMPLE_RADIUS_COUNT * BUF_AMBIENT_LIGHTING_SAMPLE_ANGLE_COUNT );
    res.y = MIN_AMBIENT + res.y * (1.0 - MIN_AMBIENT);
    
    res.xy *= GetBrightnessForTime( blobTime );
    
    return res;
}

// Function 91
vec3 godRaySet2( in vec2 uv, inout float count, in vec3 oceanGradient )
{
    vec2 sunBeamOrigin;
    float beamAngle;
    
    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );
	
    for(float i=0.0; i<4.0; i++)
    {
        sunBeamOrigin = vec2(0.25 + i*0.3,5.0);
        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 1.75, 4.0);
        float t = (1.0+sin(iTime*1.25+0.9873))*0.5;
        t = remap(t, 0.0,1.0,0.75,1.25);
        beamAngle = abs(sin(0.0035*PI*t)) * noise;
            
        vec2 sunToPoint = normalize(uv - sunBeamOrigin);
        float theta = acos(dot(sunToPoint, beamDir));
        
        if( theta < beamAngle )
        {           
            count += 1.0;
            
            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);
            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);
            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));
        }
    }
    
    return vec3(0.0);
}

// Function 92
void calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (2.0*pix-iResolution.xy)/iResolution.y;
	
     // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 93
rayhit rayScene(vec3 rp, vec3 rd) {
    rayhit h;
	h.normal.w = VIEW_DISTANCE;

    //container, floor, ceiling and walls
    rt(rayBox(rp,rd,vec3(0),vec3(4,1,4)),
        h.diffuse = vec4(.8,.8,.8,0);
    	h.metallic = 0.;
        h.opacity = 1.;
       
        vec3 hp = rp+rd*s.w;
        if (hp.y > .99) {
       		//light emission
            hp.xz = abs(abs(hp.xz)-1.);
       	    h.diffuse.w = max(0.,(.5-max(hp.x,hp.z))*100.)*(.02+pow(max(0.,dot(rd,vec3(0,1,0))),10.)*.98);
        } else if (max(abs(hp.x),abs(hp.z)) > 3.99) {
         	//normal mapped voronoi walls
            vec2 tc = (vec2(dot(hp.zx,s.xz),hp.y)+10.)*70.;
            float bdst = voronoiWall(tc);
            tc = normalize(vec2(voronoiWall(tc+vec2(.01,0)),voronoiWall(tc+vec2(0,.01)))-bdst)*-.3;
            h.normal.xyz = normalize(h.normal.xyz+vec3(tc.x*h.normal.z,tc.y,tc.x*h.normal.x));
            h.diffuse = vec4(.3,.45,.52,0);
            h.specular = vec4(.76,.82,.83,0);
            h.metallic = .4;
            h.roughness = .08;
        }
    );
    
    //crystal pedestals
    #define pedestal(pos) rt(rayBox(rp,rd,pos,vec3(.2,.3,.2)),\
    h.diffuse = vec4(.1,.1,.1,0);\
    h.specular = vec4(.1,.1,.1,0);\
    h.metallic = .7;\
    h.roughness = .001;\
    h.opacity = 1.;);
    
    pedestal(vec3(1,-.5,1));
    pedestal(vec3(-1,-.5,1));
    pedestal(vec3(1,-.5,-1));
    pedestal(vec3(-1,-.5,-1));

    //flip refraction index inside crystal
    #define RFLIP(df,cp) if (df(rp+rd*s.w-cp) < EPSILON) {h.refrIndex = 1./h.refrIndex;}
    
    //crystal 1 clear with little refraction
    rtc(rayCrystal1(rp,rd),crystal1_pos,.4,
       h.specular = vec4(.9,.99,.92,0);
       h.roughness = 0.;
       h.metallic = 1.;
       h.opacity = 0.03;
       h.refrIndex = .92;
    );
    
    //crystal 2 rough bright green
    rtc(rayCrystal2(rp,rd),crystal2_pos,.4,
       h.specular = vec4(.1,.99,.1,0);
       h.roughness = 0.02;
       h.metallic = 1.;
       h.opacity = .2;
       h.refrIndex = .7;
       RFLIP(crystal2,crystal2_pos);
    );
    
    //crystal 3 blueish purple
    rtc(rayCrystal3(rp,rd),crystal3_pos,.4,
       h.specular = vec4(.6,.2,.99,0);
       h.roughness = 0.005;
       h.metallic = 1.;
       h.opacity = .3;
       h.refrIndex = .95;
       RFLIP(crystal3,crystal3_pos);
    );
    
    //crystal 4 yellow
    rtc(rayCrystal4(rp,rd),crystal4_pos,.4,
       h.specular = vec4(1,1,0.,0);
       h.roughness = 0.;
       h.metallic = 1.;
       h.opacity = 0.1;
       h.refrIndex = .6;
       RFLIP(crystal4,crystal4_pos);
    );
    
    return h;
}

// Function 94
vec3 getNormals(vec3 p) {
    float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;
    float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;
    float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;
    return normalize(vec3(x, y, z));
}

// Function 95
vec3 normal(vec3 p)
{
    vec2 e = vec2(.01,.0);
    float m = map(p);
    return normalize(vec3(
    	m - map(p + e.xyy),
    	m - map(p + e.yxy),
    	m - map(p + e.yyx)
    ));
}

// Function 96
vec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {
	vec3 p;
	float t = 0., ri;

	float dither = random(uv);

	for (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it "fast"
		ri = i;
		p = ro + rd * t;
		float d = de(p);
		d *= 1. + dither * .05; // avoid banding & add a nice "artistic" little noise to the rendering (leon gave us this trick)
		d = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW
		t += d * .5;
	}

	// Shading: uv, iteration & glow:
	vec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);
	c.r += sin(p.z * .1) * .2;
	c += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1

	return c;
}

// Function 97
float pReflect(inout vec3 p, vec3 planeNormal, float offset) {
   float t = dot(p, planeNormal)+offset;
   if (t < 0.) {
      p = p - (2.*t)*planeNormal;
   }
   return sgn(t);
}

// Function 98
vec3 calcNormal( in vec3 pos ) {
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
}

// Function 99
vec3 normal(vec3 p) {
    float diff = 0.00001;
    distanceestimation d = distanceestimation(
        vec3(0.0), //p
        vec3(0.0), //s
        vec3(0.0), //d
        0.0, //l
        vec3(0.0) //n
    );
    d.p = p - diff * i3;
    float nx = DistanceEstimator(d);
    d.p = p + diff * i3;
    float px = DistanceEstimator(d);
    d.p = p - diff * j3;
    float ny = DistanceEstimator(d);
    d.p = p + diff * j3;
    float py = DistanceEstimator(d);
    d.p = p - diff * k3;
    float nz = DistanceEstimator(d);
    d.p = p + diff * k3;
    float pz = DistanceEstimator(d);
    return normalize(vec3(
        px - nx,
        py - ny,
        pz - nz
    ));
}

// Function 100
vec3 normal(vec3 p, float eps, const in int cur_space) {
    // sample 6 distances around the given point, taking into account the body we're currently inside of
    vec3 v = vec3(eps,0.0,0.0);
    int _;
    return normalize(
        v.xyy*(map(p+v.xyy, cur_space, _)-map(p-v.xyy, cur_space, _)) +
        v.yxy*(map(p+v.yxy, cur_space, _)-map(p-v.yxy, cur_space, _)) +
        v.yyx*(map(p+v.yyx, cur_space, _)-map(p-v.yyx, cur_space, _))
    );
}

// Function 101
float GetRayFirstStep( const in C_Ray ray )
{
    return ray.fStartDistance;  
}

// Function 102
vec3 normal(vec3 p) {
	const vec2 eps = vec2(0.1, 0.0);
	float h = terrain(p.xz);
	return normalize(vec3(
		(terrain(p.xz+eps.xy)-h),
		eps.x,
		(terrain(p.xz+eps.yx)-h)
	));
}

// Function 103
vec3 normal(vec3 pos) {
	float e = 0.001;
    vec3 n;
    n.x = (field(pos+vec3(e,0,0)) - field(pos-vec3(e,0,0)))/(2.*e);
    n.y = (field(pos+vec3(0,e,0)) - field(pos-vec3(0,e,0)))/(2.*e);
    n.z = (field(pos+vec3(0,0,e)) - field(pos-vec3(0,0,e)))/(2.*e);
    return n;
}

// Function 104
vec4 marchRay(vec3 ro, vec3 rd) {

    float d = 10.0; //distance marched
    vec4 pc = vec4(0.); //pixel colour

    for (int i = 0; i < MAXIMUM_STEPS; ++i) {
        vec3 rp = ro + rd * d;
        
        
        float ns = nearestSurface(rp);
        d += ns;
        
        if (ns < DISTANCE_THRESHOLD) {
            vec3 sunPos = vec3(sin(iTime)*-32., 12., cos(iTime)*-32.);
            vec3 norm = normal(rp);
            
            float diffuse = dot(normalize(sunPos), norm);
            
            vec3 reflection = reflect(normalize(sunPos), normalize(norm));
            float specularAngle = max(0.0, dot(reflection, vec3(0,0,1.)));
            vec4 illuminationSpecular = clamp(pow(specularAngle, 0.01), 0., 0.01) * vec4(1.);
            
            vec4 clr = vec4(diffuse) * 0.2;
            pc = BASE_COLOR + clr + illuminationSpecular;
            break;
        }
        
        if (d > FAR_CLIP) {
            break;
        }
    }

    return pc;
}

// Function 105
rayHit rayQuery(highp vec3 start, highp vec3 dir)
{
    highp float d = 0.0;
    const highp float eps = MARCH_EPS;
    const int numIter = 76;
    
    for(int i = 0; i < numIter; ++i)
    {
        highp vec3 p = start + dir * d;
        sdv v = scene(p);
        if(v.d < eps)
        {
            rayHit ret;
            ret.idx = v.idx;
            ret.p = p;
            return ret;
        }
        
        d += v.d;
    }
    
    rayHit ret;
    ret.idx = -1;
    ret.p = vec3(0.0);
    return ret;
}

// Function 106
vec3 calcNormal(  vec3 pos )
{    
  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );
}

// Function 107
vec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){
    float 	focal = 1.;
    vec3 ww = normalize( camTarget - pos);
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;
    vec3 vv = cross(uu,ww);
	// create view ray
	return normalize( st.x*uu + st.y*vv + focal*ww );
}

// Function 108
vec3 normal (vec3 p) {
    float e = .01;
    return normalize(vec3(map(p+vec3(e,0,0))-map(p+vec3(-e,0,0)),
                          map(p+vec3(0,e,0))-map(p+vec3(0,-e,0)),
                          map(p+vec3(0,0,e))-map(p+vec3(0,0,-e))));
}

// Function 109
vec3 getRay(vec3 ro, vec3 look, vec2 uv){
    vec3 f = normalize(look - ro);
    vec3 r = normalize(vec3(f.z,0,-f.x));
    vec3 u = cross (f,r);
    return normalize(f + uv.x * r + uv.y * u);
}

// Function 110
vec3 createRay(vec2 px, mat4 PInv, mat4 VInv) {

  // convert pixel to NDS
  // [0,1] -> [-1,1]
  vec2 pxNDS = px * 2. - 1.;

  // choose an arbitrary point in the viewing volume
  // z = -1 equals a point on the near plane, i.e. the screen
  vec3 pointNDS = vec3(pxNDS, -1.);

  // as this is in homogenous space, add the last homogenous coordinate
  vec4 pointNDSH = vec4(pointNDS, 1.0);
  // transform by inverse projection to get the point in view space
  vec4 dirEye = PInv * pointNDSH;

  // since the camera is at the origin in view space by definition,
  // the current point is already the correct direction (dir(0,P) = P - 0 = P
  // as a direction, an infinite point, the homogenous component becomes 0
  // the scaling done by the w-division is not of interest, as the direction
  // in xyz will stay the same and we can just normalize it later
  dirEye.w = 0.;

  // compute world ray direction by multiplying the inverse view matrix
  vec3 dirWorld = (VInv * dirEye).xyz;

  // now normalize direction
  return normalize(dirWorld);
}

// Function 111
float ComputeFresnellReflectance(const RayIntersection ri)
{
    float R, Ro, cosTheta, c5;
 
    cosTheta = 1. + dot(ri.shape.normal.xyz, ri.ray.d);
    c5 = cosTheta*cosTheta*cosTheta*cosTheta*cosTheta;

    Ro = (ri.ray.n - ri.shape.snellIndex) / (ri.ray.n + ri.shape.snellIndex);
    Ro *= Ro;

    R = Ro + (1.-Ro)*c5;
    
    float o = ri.shape.glossy + (1.-ri.shape.glossy)*R;
    return clamp(o, 0., 1.);
}

// Function 112
mat2x3 tangentBinormal(vec3 norm) {
	mat2x3 t;
	if (abs(norm.x) > abs(norm.y)) t[0] = normalize(vec3(-norm.z,0,norm.x));
	else t[0] = normalize(vec3(0,norm.z,-norm.y)); 
	t[1] = cross(norm,t[0]);
	return t;
}

// Function 113
vec2 NormalizeScreenCoords(vec2 screenCoord)
{
    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);
    result.x *= iResolution.x/iResolution.y;
    return result;
}

// Function 114
vec3 getNormal(vec3 pos)
{
    const float e = EPS;
    const vec3 dx = vec3(e, 0, 0);
    const vec3 dy = vec3(0, e, 0);
    const vec3 dz = vec3(0, 0, e);

    float d = distFunc(pos);

    return normalize(vec3(
        d - distFunc(vec3(pos - dx)),
        d - distFunc(vec3(pos - dy)),
        d - distFunc(vec3(pos - dz))
    ));
}

// Function 115
void calcRayForPixel( vec2 pix, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;
	
     // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 116
vec2 raycast( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        //return vec2(tb.x,2.0);
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 117
vec3 ComputeRefraction(const RayIntersection ri)
{
    vec3  absortion = vec3(1);
    vec3  prevD     = ri.ray.d;
    float prev_n 	= ri.ray.n;
    float next_n	= ri.shape.snellIndex;

	Ray refractedRay;
    refractedRay.o = ri.pos - ri.shape.normal.xyz * 3.*EPSILON;
    //Compute the refraction direction
    float r = prev_n / next_n;
    refractedRay.d = refract(prevD, ri.shape.normal.xyz, r);
    if (dot(refractedRay.d, prevD) <= 0.) refractedRay.d *= -1.;

    refractedRay.n = ri.shape.snellIndex;
    next_n = 1.;

	int  i = 0;
    vec3 N;
    RayIntersection ri2 = CastRay(refractedRay, MAX_DISTANCE);
    while ( ri2.shape.type != NO_SHAPE && ri2.shape.color.a < 1. && i<4)
    { // We have collided with another transparent surface
        i++;
        absortion = exp(-ri2.shape.color.rgb * ri2.dist);
        
        N = (mod(float(i),2.) != 0.) ? ri2.shape.normal.xyz : -ri2.shape.normal.xyz;

        r = refractedRay.n/next_n;
		prevD = refractedRay.d;
        
        refractedRay.o = ri2.pos + N * 3.*EPSILON;
		refractedRay.d = refract(prevD, -N, r);
        if (dot(refractedRay.d, prevD) <= 0.) refractedRay.d *= -1.;
        refractedRay.n = next_n;
        
        ri2 = CastRay(refractedRay, MAX_DISTANCE);
        if (ri2.shape.type == NO_SHAPE)
        { // FIXME
            return SHADOW_COLOR.rgb * absortion;
        }
        
        next_n = ri2.shape.snellIndex;
    }

    return SampleLights(ri2) * absortion;
}

// Function 118
void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)
{
	vec3 vForwards = normalize(vInterest - vPos);
	vec3 vUp = vec3(0.0, 1.0, 0.0);

	GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);
}

// Function 119
vec3 calcNormal(in vec3 p){

    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.
    vec2 e = vec2(0.001, -0.001); 
    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));
}

// Function 120
vec3 normal(vec3 p) {
    return normalize(vec3(
        scene(vec3(p.x + epsilon, p.y, p.z)) - scene(vec3(p.x - epsilon, p.y, p.z)),
        scene(vec3(p.x, p.y + epsilon, p.z)) - scene(vec3(p.x, p.y - epsilon, p.z)),
        scene(vec3(p.x, p.y, p.z + epsilon)) - scene(vec3(p.x, p.y, p.z - epsilon))
    ));
}

// Function 121
vec3 godRaySet1( in vec2 uv, inout float count, in vec3 oceanGradient )
{
    vec2 sunBeamOrigin;
    float beamAngle;
    
    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );
	
    for(float i=0.0; i<2.0; i++)
    {
        sunBeamOrigin = vec2(0.45 + i*0.5,5.0);
        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 8.0, 2.5);
        float t = (1.0+sin(iTime*2.5+0.1073))*0.5;
        t = remap(t, 0.0,1.0,0.5,1.1);
        beamAngle = abs(sin(0.0035*PI*t)) * noise;
            
        vec2 sunToPoint = normalize(uv - sunBeamOrigin);
        float theta = acos(dot(sunToPoint, beamDir));
        
        if( theta < beamAngle )
        {           
            count += 1.0;
            
            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);
            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_LARGE, 0.5);
            return mix(OCEANBLUE3, godRayColor, beta*(uv.y+0.1));
        }
    }
    
    return vec3(0.0);
}

// Function 122
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 160; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 123
vec3 getNormal(vec2 uv, int tex ) {
#ifdef NORMAL_MAPS
    float heightScale = 0.004;
    float dHdU, dHdV;
    
    float hpx, hmx, hpy, hmy, h0;
    vec3 c, c1, c2, c3, c4;
    vec2 duv;
    
    if(tex==0){
        vec2 res = iChannelResolution[0].xy;
    	duv = vec2(1.0) / res.xy;
 		c = texture( iChannel0, uv).xyz;
        c1 = texture( iChannel0, uv + vec2(duv.x, 0.0)).xyz;
        c2 = texture( iChannel0, uv - vec2(duv.x, 0.0)).xyz;
        c3 = texture( iChannel0, uv + vec2(0.0, duv.y)).xyz;
        c4 = texture( iChannel0, uv - vec2(0.0, duv.y)).xyz;
    } else if(tex==1) {
        vec2 res = iChannelResolution[1].xy;
    	duv = vec2(1.0) / res.xy;
        c = texture( iChannel1, uv).xyz;
        c1 = texture( iChannel1, uv + vec2(duv.x, 0.0)).xyz;
        c2 = texture( iChannel1, uv - vec2(duv.x, 0.0)).xyz;
        c3 = texture( iChannel1, uv + vec2(0.0, duv.y)).xyz;
        c4 = texture( iChannel1, uv - vec2(0.0, duv.y)).xyz;
        res = iChannelResolution[1].xy;
    } else {
        vec2 res = iChannelResolution[2].xy;
    	duv = vec2(1.0) / res.xy;
        c = texture( iChannel2, uv).xyz;
        c1 = texture( iChannel2, uv + vec2(duv.x, 0.0)).xyz;
        c2 = texture( iChannel2, uv - vec2(duv.x, 0.0)).xyz;
        c3 = texture( iChannel2, uv + vec2(0.0, duv.y)).xyz;
        c4 = texture( iChannel2, uv - vec2(0.0, duv.y)).xyz;
        res = iChannelResolution[2].xy;
    }
    
    h0	= heightScale * dot(c , vec3(1.0/3.0));
    hpx = heightScale * dot(c1, vec3(1.0/3.0));
    hmx = heightScale * dot(c2, vec3(1.0/3.0));
    hpy = heightScale * dot(c3, vec3(1.0/3.0));
    hmy = heightScale * dot(c4, vec3(1.0/3.0));
    dHdU = (hmx - hpx) / (2.0 * duv.x);
    dHdV = (hmy - hpy) / (2.0 * duv.y);
    
    return normalize(vec3(dHdU, dHdV, 1.0));
#else
    return vec3(0.0, 0.0, 1.0);
#endif
}

// Function 124
Complex H_normalize(Complex h)
{
    return normalize(h);
}

// Function 125
vec3 calculateNormal( in vec3 position )
{
    vec2 e = vec2(0.0001, 0.0);
    return normalize(vec3(mapObjects(position+e.xyy)-mapObjects(position-e.xyy),
                          mapObjects(position+e.yxy)-mapObjects(position-e.yxy),
                          mapObjects(position+e.yyx)-mapObjects(position-e.yyx) ) );
}

// Function 126
void OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)
{
	float sig = n.z < 0.0 ? 1.0 : -1.0;
	
	float a = 1.0 / (n.z - sig);
	float b = n.x * n.y * a;
	
	ox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);
	oz = vec3(b, sig + n.y * n.y * a, n.y);
}

// Function 127
vec2 stdNormalMap(in vec2 uv) 
{
    float height = texture(heightMap, uv).r;
    return -vec2(dFdx(height), dFdy(height)) * pixelToTexelRatio;
}

// Function 128
Mobius M_Normalize(Mobius m)
{
    vec2 k = C_Inv(C_Sqrt(m.A * m.D - m.B * m.C));
    return M_Scale(m, k);
}

// Function 129
vec3 calcNormal(vec3 p) {
    float eps = 0.001;
    Obj x1 = df(p + vec3(eps, 0, 0));
    Obj x2 = df(p - vec3(eps, 0, 0));
    Obj y1 = df(p + vec3(0, eps, 0));
    Obj y2 = df(p - vec3(0, eps, 0));
    Obj z1 = df(p + vec3(0, 0, eps));
    Obj z2 = df(p - vec3(0, 0, eps));
    return normalize(vec3(x1.dist - x2.dist, y1.dist - y2.dist, z1.dist - z2.dist));
}

// Function 130
ray getRay(float u, float v, camera cam) { return ray(cam.o,cam.llc + u*cam.h + v*cam.v); }

// Function 131
vec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {  vec3 len = y / (sin(theta) - x * cos(theta));  if (len.r < 0.0) {len.r=1000.0;}  if (len.g < 0.0) {len.g=1000.0;}  if (len.b < 0.0) {len.b=1000.0;}  return len; }

// Function 132
vec3 getNormal(vec3 p){
    vec2 e = vec2(0.002, -0.002); 
    return normalize(
        e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + 
        e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));
}

// Function 133
void rayMarch(inout ray _r)
{
	// ray start point
	vec3 p = _r.o;
	vec2 d = vec2(0.);
	float ld = 0.;
		
	// traverse frustum
	for(float s=ncp; s<fcp; s+=step)
	{
		// step in front
		p += _r.d*step;
		
		// check hit
		d = map(p);
		if(!_r.h && d.x<0.)
		{
			_r.h = true;
			
			// interpolate p
			float i = step*ld/(ld-d.x);
			_r.hp = p;//_r.o + _r.d * (s-step+i);            
            break;
		}
		
		//last d
		ld = d.x;
	}
}

// Function 134
float3 pixelRay(float2 uv)
{
    if(!keyToggled(KEY_R))
    {
		uv*=0.75;
	  	return normalize(forward+up*uv.y+right*uv.x);
    }
    else
    {
		uv*=0.65;
        if(dot(uv,uv)>1.0)
            return float3(0.0);
        
        float z=sqrt(1.0-uv.x*uv.x-uv.y*uv.y)*1.95-0.95;
        float3 uvz=float3(uv,z);
        uvz=normalize(uvz);
        return normalize(forward*uvz.z+up*uvz.y+right*uvz.x);
    }
}

// Function 135
void marchRay(inout Ray ray, inout vec3 colour) {
    bool inside = false; // are we inside or outside the glass object
    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours

    vec3 startpoint = ray.origin;
    
#ifdef DEBUG   
vec4 debugColour = vec4(1, 0, 0, 1);
#endif
    
    SDResult result;
    vec3 n;
    vec3 glassStartPos;
    
    for (int i=0; i<kMAXITERS; i++) {
        // Get distance to nearest surface
        result = sceneDist(ray);
        
        // Step half that distance along ray (helps reduce artefacts)
        float stepDistance = inside ? abs(result.d) : result.d;
        ray.origin += ray.dir * stepDistance;
        
        float f = fog(ray, stepDistance);
        
        colour = mix(colour, vec3(0.7), clamp(f, 0., 1.));
        impact *= 1. - f;
        
       // if (length(ray.origin) > 40.0) { break; }
        
        if (stepDistance < eps) {
            // colision
            // normal
            // Get the normal, then clamp the intersection to the surface
    		n = normal(ray);
            //clampToSurface(ray, stepDistance, n);
#ifdef DEBUG
#endif
            
            if (result.material == kFLOORMATERIAL) {
            	// ray hit floor
              
                // Add some noise to the normal, since this is pretending to be grit...
                vec3 randomNoise = texture(iChannel2, ray.origin.xz * .050, 0.0).rgb;
                randomNoise += texture(iChannel2, ray.origin.xz * .10, 0.0).rgb;
                n = mix(vec3(0,1,0), randomNoise-1.0, 0.25);
                colour = mix(colour, kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n)), impact);
                /*
				n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);
                
                // Colour is just grey with crappy fake lighting...
                colour += mix(
                    kFLOORCOLOUR, 
                    vec3(0), 
                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)
                ) * impact;
				*/
                impact *= 0.;
                break;
            }
            
            if ( result.material == kMATTEMATERIAL ) {
                // ray hit thing
                
                // tex coord from normal
                vec2 coord = texCoordFromNormal(n);
                	
                float fresnel = fresnelTerm(ray, n, 2.0);
                
                // Add some noise to the normal, since this is pretending to be grit...
                vec3 randomNoise = texture(iChannel2, n.xy * .50, fresnel * 4.0).rgb;
                randomNoise += texture(iChannel2, n.xz * .50, fresnel * 4.0).rgb;
                randomNoise += texture(iChannel2, n.yz * .50, fresnel * 4.0).rgb;
                randomNoise /= 3.0;
                n = mix(n, randomNoise-0.5, 0.3);
                colour = mix(colour, kMATTECOLOUR * light(ray, n) * vec3(occlusion(ray, n)), impact);
                /*
				n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);
                
                // Colour is just grey with crappy fake lighting...
                colour += mix(
                    kFLOORCOLOUR, 
                    vec3(0), 
                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)
                ) * impact;
				*/
                impact *= 0.;
                break;
            }
            
            // check what material it is...
            
            if (result.material == kMIRRORMATERIAL) {
                
                // handle interior glass / other intersecion
                if (inside) {
                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    				glassStartPos = ray.origin;
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
                }
                
                // it's a mirror, reflect the ray
                ray.dir = reflect(ray.dir, n);
                    
                // Step 2x epsilon into object along normal to ensure we're beyond the surface
                // (prevents multiple intersections with same surface)
                ray.origin += n * eps * 2.0;
                
                // Mix in the mirror colour
                impact *= kMIRRORCOLOUR;
                
            } else {
                // glass material
            
                if (inside) {
                	// refract glass -> air
                	ray.dir = refract(ray.dir, -n, 1.0/kREFRACT);
                    
                    // Find out how much to tint (how far through the glass did we go?)
                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
#ifdef DEBUG
debugValue += glassTravelDist / 2.0;
#endif
      
                
              	} else {
               		// refract air -> glass
                	glassStartPos = ray.origin;
                    
              	  	// Mix the reflection in, according to the fresnel term
                	float fresnel = fresnelTerm(ray, n, 1.0);
                    fresnel = fresnel;
    				/*
                    colour = mix(
                    	colour, 
                    	texture(iChannel1, reflect(ray.dir, n)), 
                    	vec4(fresnel) * impact);
*/
                    colour = mix(
                        colour,
                        backgroundColour(ray, 0.0),
                        vec3(fresnel) * impact);
                    impact *= 1.0 - fresnel;
    			
                	// refract the ray
            		ray.dir = refract(ray.dir, n, kREFRACT);
                    
#ifdef DEBUG
//debugValue += 0.5;
#endif
                }
            
            	// Step 2x epsilon into object along normal to ensure we're beyond the surface
                ray.origin += (inside ? n : -n) * eps * 2.0;
                
                // Flip in/out status
                inside = !inside;
            }
        }
        
        // increase epsilon
        eps += divergence * stepDistance;
    }
    
    // So far we've traced the ray and accumulated reflections, now we need to add the background.
   // colour += texture(iChannel0, ray.dir) * impact;
    ray.origin = startpoint;
    colour.rgb += backgroundColour(ray, 0.0) * impact;
    
#ifdef DEBUG
//debugColour.rgb = ray.dir;
debugColour.rgb = vec3(float(debugStep)/2.0);
colour = debugColour;
#endif
}

// Function 136
void Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )
{          
	result.fDistance = kRaymarchStartDistance;
	result.vObjectId.x = 0.0;
				    
	for(int i=0;i<=kRaymarchMatIter;i++)                
	{
		result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
		vec4 vSceneDist = GetDistanceScene( result.vPos );
		result.vObjectId = vSceneDist.yzw;
		
		// abs allows backward stepping - should only be necessary for non uniform distance functions
		if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))
		{
			break;
		}                          	
		
		result.fDistance = result.fDistance + vSceneDist.x;      
	}
	
	
	if(result.fDistance >= fMaxDist)
	{
		result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
		result.vObjectId.x = 0.0;
		result.fDistance = 1000.0;
	}
}

// Function 137
vec3 SceneNormal(in vec3 pos, in float depth)
{
    vec2 eps = vec2(0.001 * depth, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,
                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,
                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));
}

// Function 138
vec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {
	vec3 forward = normalize(lookAt - ro),
	     right = normalize(cross(vec3(0, 1, 0), forward));
	return normalize(forward + right * uv.x + cross(forward, right) * uv.y);
}

// Function 139
float intersectRaySphere(vec3 ro, vec3 rd, vec3 sp, float rsq) {
  vec3 n = ro - sp;
  float a = dot(rd, rd);
  float b = 2.0 * dot(rd, n);
  float c = dot(n, n) - rsq;
  float d = b * b - 4.0 * a * c;
  return d < 0.0 ? -1.0 : (-b - sqrt(d)) / 2.0 * a;
}

// Function 140
vec2 raymarchUnderWater(vec3 ro, vec3 rd, in float tmin, in float tmax) {
    vec2 m = vec2(-1.0, -1.0);
    vec2 res = vec2(tmin, -1.0);
    res.x = tmin;
	for( int i=0; i<REFR_NUM_STEPS; i++ )
	{
        m = mapUnderWater(ro + res.x*rd);
		if( m.x<tmin || res.x>tmax ) break;
		res.x += /*0.5**/m.x*log(1.0+float(i));
        res.y = m.y;
	}
    if( res.x>tmax ) res.y=-1.0;
	return res;
}

// Function 141
vec3 cosineWeightedRay(vec3 n, float t) {
    float u = rand(vec2(12.9898, 78.233), t);
    float v = rand(vec2(63.7264, 10.873), t);
    float phi = 2.0 * PI * u;
    float stheta  = sqrt(v);
    vec3 x = abs(n.x) < 0.5 ? vec3(1, 0, 0) : vec3(0, 1, 0);
    vec3 z = normalize(cross(x, n));
    x = cross(n, z);
    return mat3(x, n, z) * vec3(stheta * cos(phi), sqrt(1.0 - v), stheta * sin(phi));
}

// Function 142
vec3
calc_normal( in vec3 pos, in float t )
{
    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);
	return normalize( vec3(
           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,
           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,
           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );
}

// Function 143
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.002,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 144
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,
	    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,
	    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 145
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;

		float precis = 0.001;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<1; i++ )
    {
	    	vec2 res = map( ro + rd*t );
        if( res.x < precis || t > tmax ) break;
        t += res.x;
	    	m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 146
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.002;

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*scene( pos + v1*eps ) + 
					  v2*scene( pos + v2*eps ) + 
					  v3*scene( pos + v3*eps ) + 
					  v4*scene( pos + v4*eps ) );
}

// Function 147
vec3 getRay_870892966(mat3 camMat, vec2 screenPos, float lensLength) {
  return normalize(camMat * vec3(screenPos, lensLength));
}

// Function 148
float rayTrace( in vec3 ro, in vec3 rd )
{
    return shpIntersect( ro, rd, sph1 );
}

// Function 149
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;


	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 150
bool RayMarch(vec3 org, vec3 dir, out vec3 p)
{
	p=org;
	bool hit = false;
	float dist = .0;
	// 'Break'less ray march...
	for(int i = 0; i < 120; i++)
	{
		if (!hit && dist < 25.0)
		{
			p = org + dir*dist;
			float d = Scene(p);
			if (d < 0.05)
			{
				hit = true;
			}
			dist += d*.5;
		}
	}
	return hit;
}

// Function 151
vec2 Reflection(vec2 pos, vec2 line)
{
    float d = (pos.x + (pos.y - line.y) * line.x) / (1.0 + line.x * line.x);
    return vec2(2.0 * d - pos.x, 2.0 * d * line.x - pos.y + 2.0 * line.y);
}

// Function 152
vec3 calculateNormals(vec3 pos)
{
	vec2 eps = vec2(0.0, EPSILON);
	vec3 n = normalize(vec3(
	distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),
	distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),
	distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));
	return n;
}

// Function 153
vec4 raymarch(vec3 raydirection, vec3 rayorigin){
    vec3 rayposition = rayorigin;
    float distanceestimate;
    float distancetravelled = 0.0;
    bool hit = false;
    for(int i = 0; i < maxmarches; i++){
        distanceestimate = distanceestimator(rayposition);
        if(distanceestimate < collisiondistance){hit = true; break;}
        rayposition += raydirection*distanceestimate;
        distancetravelled += distanceestimate;
        if(distancetravelled > maxdistance){break;}
    }
    if(hit){return vec4(rayposition, distancetravelled);}
    else{return vec4(-1.0);}
}

// Function 154
vec3 calcNormal( in vec3 pos, in float dt )
{
    vec2 e = vec2(1.0,-1.0)*dt;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 155
vec3 est_normal(vec3 rp ) {

const float diff = 0.0001;

vec3 x_p = vec3(diff ,0.0,0.0);
vec3 x_m = vec3(-diff ,0.0,0.0);

vec3 y_p = vec3(0.0,diff ,0.0);
vec3 y_m = vec3(0.0,-diff ,0.0);

vec3 z_p = vec3(0.0,0.0 ,diff);
vec3 z_m = vec3(0.0,0.0,-diff);


float x_diff = obj(rp+x_p) - obj(rp+x_m);
float y_diff = obj(rp+y_p) - obj(rp+y_m);
float z_diff = obj(rp+z_p) - obj(rp+z_m);

return normalize(vec3(x_diff,y_diff,z_diff));

}

// Function 156
vec3 normal(vec3 p) {
	vec3 n, E = vec3(.005, 0., 0.);

/*
	float n1,n2,n3;

	n1=map(p);
	n2=map(p - 1.0 * E.xyy);
	n3=map(p + 1.0 * E.xyy);
	if (abs(n1-n2)>abs(n3-n1)) {n.x=(n3 - n1)*2.0;  }
	else n.x=(n1 - n2)*2.0;

	n2=map(p - 1.0 * E.yxy);
	n3=map(p + 1.0 * E.yxy);
	if (abs(n1-n2)>abs(n3-n1)) {n.y=(n3 - n1)*2.0;  }
	else n.y=(n1 - n2)*2.0;

	n2=map(p - 1.0 * E.yyx);
	n3=map(p + 1.0 * E.yyx);
	if (abs(n1-n2)>abs(n3-n1)) {n.z=(n3 - n1)*2.0;  }
	else n.z=(n1 - n2)*2.0;
*/


	n.x = map(p + E.xyy) - map(p - E.xyy);
	n.y = map(p + E.yxy) - map(p - E.yxy);
	n.z = map(p + E.yyx) - map(p - E.yyx);
	return normalize(n);
}

// Function 157
vec3 calcNormal(in vec3 p)                                                      
{                                                                               
    vec3 e = vec3(0.001, 0.0, 0.0);                                             
    vec3 n;                                                                     
                                                                                
    n.x = map(p + e.xyy).x - map(p - e.xyy).x;                                  
    n.y = map(p + e.yxy).x - map(p - e.yxy).x;                                  
    n.z = map(p + e.yyx).x - map(p - e.yyx).x;                                  
                                                                                
    return normalize(n);                                                        
}

// Function 158
vec2 raytrace(vec3 rp, vec3 rd) {
    vec2 d = sdf(rp);
    float dist = d.x;
    float t = 0.;
    int i;
    for (i=0; i<100; i++) {
        t += dist/1.3;
        d = sdf(rp + t * rd);
        dist = d.x;
        if (abs(dist) < eps || dist > maxdist) break;
    }
    if (abs(dist) < eps) {
        return vec2(t, d.y);
    } else {
        return vec2(t, 0.);
    }
}

// Function 159
vec2 unpack_normal(float x) {
    float a = x * 2.0;
    vec2 s;
    s.x = sign(a);
    s.y = sign(1.0 - a*s.x);
    vec2 q;
    q.y = fract(a) - 0.5;
    q.x = sqrt(0.5 - q.y*q.y);
    return q*mat2(s.y,-s.x,s.xy);
}

// Function 160
vec3 getNormal( in vec3 pos ) {
// from iq
	vec3 eps = vec3( MinimumDistance, 0.0, 0.0 );
	vec3 nor = vec3(
	    DistanceEstimator(pos+eps.xyy) - DistanceEstimator(pos-eps.xyy),
	    DistanceEstimator(pos+eps.yxy) - DistanceEstimator(pos-eps.yxy),
	    DistanceEstimator(pos+eps.yyx) - DistanceEstimator(pos-eps.yyx) );
	return normalize(nor);
}

// Function 161
bool shadowRaySceneIntersection( in Ray ray, in float distMin ) {
    
}

// Function 162
float RayMarch(vec3 ro, vec3 rd){
    float dO = 0.;
    for (int i =0; i<MAX_STEPS; i++){
        vec3 p = ro+dO*rd;
        float dS = GetDist(p);
        dO +=dS;
        if (dS<SURF_DIST|| dO>MAX_DIST) break;
    }
    return dO;
}

// Function 163
vec3 calcNormal(vec3 pos)
{
    float eps = 0.0001;
	float d = map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 164
vec3 CalcNormal( in vec3 pos )
{    
  return normalize( vec3(TerrainDistance(pos+eps.xyy) - TerrainDistance(pos-eps.xyy), 0.5*2.0*eps.x, TerrainDistance(pos+eps.yyx) - TerrainDistance(pos-eps.yyx) ) );
}

// Function 165
void generate_ray(Camera c, out Ray r, in vec2 fragCoord)
{
	float ratio = iResolution.x / iResolution.y;

	vec2  uv = (2.0 * fragCoord.xy / iResolution.xy - 1.)
			 * vec2(ratio, 1.0);
	
	r.o = c.p;
	r.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(CAMERA_FOV * .5)));
	
	vec3 cd = c.t - c.p;

	vec3 rx,ry,rz;
	rz = normalize(cd);
	rx = normalize(cross(rz, c.u));
	ry = normalize(cross(rx, rz));
	
	mat3 tmat = mat3(rx.x, rx.y, rx.z,
			  		 ry.x, ry.y, ry.z,
					 rz.x, rz.y, rz.z);

	r.d = normalize(tmat * r.d);
}

// Function 166
Ray castRay(vec2 uv, Camera camera) 
{
    float imgAspectRatio = iResolution.x / iResolution.y; // assuming width > height
        
    // Compute ndc space point from screenspace point //[-1,1] to [0,1] range
    vec2 NDC_Space_Point = uv * 2.0 - 1.0;
    
    float tanFOV_Y_by2 = tan(FOV_Y *0.5 * deg2rad);
    
    vec3 cam_x = NDC_Space_Point.x * tanFOV_Y_by2 * imgAspectRatio * camera.right;
    vec3 cam_y = NDC_Space_Point.y * tanFOV_Y_by2 * camera.up;

    //convert to world space
    vec3 ref = camera.eye + camera.forward;
    vec3 p = ref + cam_x + cam_y; //facing the screen
    
    Ray ray;
    ray.origin = camera.eye;
    ray.dir = normalize(p - camera.eye);
    return ray;
}

// Function 167
vec3 gradGray(float t)
{
    return grad(t, pal[0], pal[11], pal[12], pal[15], pal[1], pal[15], pal[12], pal[11]);
}

// Function 168
void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)
{
    vec2 vUV = ( fragCoord.xy / iResolution.xy );
    vec2 vViewCoord = vUV * 2.0 - 1.0;	

	vViewCoord.y *= -1.0;

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vWorldUp, vForwards));
    vec3 vUp = cross(vRight, vForwards);
        
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    
}

// Function 169
vec3 getNormal(vec3 p, float eps, float SEA_TIME) {
    vec3 n;
    n.y = map_detailed(p, SEA_TIME);    
    n.x = map_detailed(vec3(p.x+eps,p.y,p.z), SEA_TIME) - n.y;
    n.z = map_detailed(vec3(p.x,p.y,p.z+eps), SEA_TIME) - n.y;
    n.y = eps;
    return normalize(n);
}

// Function 170
bool rayQuadUV( vec3 ro, vec3 rd, vec3 po, vec3 pn, vec2 psz, out vec2 uv, out float rt )
{
    rt = rayPlane( ro, rd, po, pn );
    if( !(rt > 0.) ) return false; // NaN caught here!
    vec3 pos = ro + rt * rd;
    float x = dot(pos - po, l2w( vec3(1.,0.,0.), pn ) );
    float y = dot(pos - po, l2w( vec3(0.,0.,1.), pn ) );
    uv = vec2(x,y)/psz;
    if( abs(uv.x) >= .5001 || abs(uv.y) >= .5001 ) return false;
    uv += .5;
    return true;
}

// Function 171
vec3 calcNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 172
vec3 normals(vec3 p){
    vec3 eps = vec3(0.001, 0.0, 0.0);
    return normalize(vec3(
        dist(p+eps.xyy)-dist(p-eps.xyy),
        dist(p+eps.yxy)-dist(p-eps.yxy),
        dist(p+eps.yyx)-dist(p-eps.yyx)
    ));
}

// Function 173
vec3 SceneNormal(vec3 pos )
{
    float eps = 0.001;
    vec3 n;
	int m;
    float d = Scene(pos, m);
    n.x = Scene( vec3(pos.x+eps, pos.y, pos.z), m ) - d;
    n.y = Scene( vec3(pos.x, pos.y+eps, pos.z),m ) - d;
    n.z = Scene( vec3(pos.x, pos.y, pos.z+eps),m ) - d;
    return normalize(n);
}

// Function 174
MarchRes marchRay(vec3 pos, vec3 dir, float speed)
{
 	MarchRes res;
    Object o;
    
    res.totalDist = 0.001;
    res.glowAmt = 1.0;
    res.minDist = 1000.0;

    for(int x=0; x<150; x++)
    {
 		res.curRay = pos + (dir*res.totalDist);
        
        o = map(res.curRay);
        
        if(abs(o.dist) < 0.00001)
        {
            res.obj = o;
            break;
        }
        else if(res.totalDist >= VIEW_DIST) break;
           
        
        if(o.dist < res.minDist) res.minDist = o.dist;
        res.totalDist += o.dist*speed;
    }
    
    if(res.totalDist < VIEW_DIST)
    {
        o.normal = calcNormal(res.curRay, o.normEps);
        
        res.obj = o;
    }
    	
    
    return res;
}

// Function 175
vec4 castRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	
	vec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );

    // traverse regular grid (in 2D)
	for( int i=0; i<24; i++ ) 
	{
		if( res.x>0.0 ) continue;
		
        // intersect sphere
		vec4  sph = makeSphere( pos );
			
		vec3  rc = ro - sph.xyz;
		float b = dot( rd, rc );
		float c = dot( rc, rc ) - sph.w*sph.w;
		float h = b*b - c;
		if( h>0.0 )
		{
			float s = -b - sqrt(h);
			res = vec4( s, 0.0, pos );
		}
        else
		{
            float a = dot( rd.xz, rd.xz );
            b = dot( rc.xz, rd.xz );
            c = dot( rc.xz, rc.xz ) - min(0.25*sph.w*sph.w,0.005);
            h = b*b - a*c;
            if( h>=0.0 )
            {
                // cylinder			
                float s = (-b - sqrt( h ))/a;
                if( s>0.0 && (ro.y+s*rd.y)<sph.y )
                {
                    res = vec4( s, 1.0, pos );
                }
            }
		}
			
        // step to next cell		
		vec2 mm = step( dis.xy, dis.yx ); 
		dis += mm*ris;
        pos += mm*rs;
	}

	return res;
}

// Function 176
vec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )
{
	vec4 sum = vec4(0.0);

	float t = (50.0-ro.y)/rd.y;
    
	if( t>0.0 )
    {
        for(int i=0; i<512; i++ )
        { 
            vec3  pos = ro + t*rd;
            float den = map( pos );
            if( den>0.001 )
            { 
                // lighting
                float dif = clamp( (den - map(pos+50.0*sundir))*1.0, 0.0, 1.0 ); 
                vec3 lin = vec3(0.5,0.7,0.9)*0.5 + vec3(1.0, 0.7, 0.5)*dif*5.0;
                vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.1,0.2,0.3), sqrt(clamp(den,0.0,1.0) )), den );
                col.xyz *= lin;
                col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0005*t) );
                col.a *= 0.1;
                // front to back blending    
                col.rgb *= col.a;
                sum = sum + col*(1.0-sum.a);
                // early skip
                if( sum.a > 0.99 || pos.y>300.0) break;
            }
            t += 2.0;
        }
    }
    
    return clamp( sum, 0.0, 1.0 );
}

// Function 177
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(0.002, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 178
vec4 raymarch(in vec3 pos, in vec3 dir, in float maxL) {
	float l = 0.;
	for (int i = 0; i < TRACE_STEPS; ++i) {
		float d = world(pos + dir * l);
		if (d < TRACE_EPSILON*l) break; // if we return here, browser will crash on mac os x, lols
		l += d;
		if (l > maxL) break;
	}
	return vec4(pos + dir * l, l);
}

// Function 179
vec3 worldReflection(vec3 org, vec3 dir, vec3 sun_direction)
{    
    if(castRay(org, dir, 0.05) != -1. || dir.y < 0.0)
        return vec3(0.0);
    
    return skyRay(org, dir, sun_direction, true);
}

// Function 180
void GrayscaleInterp(inout vec3 rgb,float coeff)
{
   float avg = (rgb.x + rgb.y + rgb.z)/3.0;
   vec3 gscale = vec3(avg, avg, avg);
   rgb = mix(rgb,gscale,pow(coeff,1.5));
}

// Function 181
bool getRay(vec2 uv, out vec3 ro, out vec3 rd)
{
    mat3 cam = getCam(get(CamA));
    vec2 apert_cent = -0.*uv; 
    vec2 ap = aperture();  
    if(!(distance(ap, apert_cent) < 1.0)) return false;  
    float apd = length(ap);  
    vec3 daperture = ap.x*cam[0] + ap.y*cam[1]; 
    ro = get(CamP).xyz + aperture_size*daperture;
    float focus =2.5 + 0.8*pow(apd,5.0);
    rd = normalize(focus*(cam*vec3(FOV*uv, 1.0)) - aperture_size*daperture);
    return true;
}

// Function 182
sHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )
{
    sHit sRes = createHit( -1.0, -1.0, rd );

    // raymarch primitives   
    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 25.0 ), rd, vec3( 8.0, 5.0, 55.0 ) );
    
    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )
    {
        tmin = max( tb.x, tmin );
        tmax = min( tb.y, tmax );       

        float t = tmin;
        for( int i = ZERO; i < 228 && t < tmax; i++ )
        {
            sHit h = map( ro + rd * t );
            if( abs( h.t ) < ( 0.002 * t ) )
            { 
                // res = vec2(t,h.y); 
                sRes = createHit( t, h.m, h.lPos ); 
                break;
            }
            t += h.t;
        }
    }
    
    return sRes;
}

// Function 183
float RayMarchOut(vec3 ro, vec3 rd) 
{
	float dO=0.;
    
    for(float i=0.0; i<1.0; i+=0.05) 
	{
    	vec3 p = ro + rd*i;
        float dS = GetDist(p);
		dO += 0.05 * step(dS, 0.0);
    }
	return exp(-dO*1.1);
}

// Function 184
vec3 GetNormal(vec3 p)
{
    float d = GetDist(p);
    vec2 e = vec2(.01,0);
    
    vec3 n = d - vec3( 
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
        
    return normalize(n);
}

// Function 185
float inverseRayleigh (float intensity, float theta)
{
    return pow(Kr / intensity * (1.+pow(cos(theta),2.)), 1./4.);
}

// Function 186
vec3 ray_dir(vec2 size, vec2 pos) {
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( radians( 90.0 - FOV * 0.5 ) );	
	float z = size.y * 0.5 * cot_half_fov;
	
	return normalize( vec3( xy, -z ) );
}

// Function 187
vec3 GetNormal(vec3 p) 
{
    raysample d = GetDist(p);
    
    vec2 e = vec2(.01, 0);
    vec3 n = d.dist - vec3(
        GetDist(p-e.xyy).dist,
        GetDist(p-e.yxy).dist,
        GetDist(p-e.yyx).dist);
    
    return normalize(n);
}

// Function 188
vec3 lookRay(vec3 origin, vec3 target, vec2 p){
    vec3 ray = normalize(target-origin);
    vec3 right = normalize(cross(ray,normalize(vec3(0.,1.,0.))));
    vec3 up = normalize(cross(ray,normalize(right)));
    return normalize(ray + right*p.x + up*p.y);
}

// Function 189
vec3 getRay_9_4(mat3 camMat, vec2 screenPos, float lensLength) {
  return normalize(camMat * vec3(screenPos, lensLength));
}

// Function 190
vec2 normalizedField(vec2 cellPos)
{
    vec2 field = vec2(0.0, 0.0);
    
    for(int i = 0; i < _ChargeCount; i++)
    {
        field += (_CoulombK * Charge[i] / pow(length(ChargePos[i] - cellPos), 3.0)) * (ChargePos[i] - cellPos);
    }
    
    return field / length(field);
}

// Function 191
float RayMarch (vec3 or, vec3 dir){
    for(float i=0.;i<renderDist;){
    
    vec3 pos= i*dir+or;
    float DE=DE(pos);
    if(DE<SUR_ACC){
    return i;
    
    }else{
    i+=DE*0.9;
    }
    }
    return renderDist;
}

// Function 192
vec3 getNormalC( vec3 p ) {
	//central differences
    float eps=NORMALEPSILON;
    vec3  n = vec3( fbm( vec2(p.x-eps,p.z), HIGHITER ) - fbm( vec2(p.x+eps,p.z), HIGHITER ), 
				  	2.0*eps,
    				fbm(vec2(p.x,p.z-eps), HIGHITER ) - fbm(vec2(p.x,p.z+eps), HIGHITER ) );
    return normalize( n );
}

// Function 193
bool ray_aabb(vec3 org,vec3 dir,vec3 lb, vec3 rt,out float dist)
{
    bool rta = false;
    vec3 dirfrac = 1.0 / dir;
    vec3 A = (lb-org)*dirfrac;
    vec3 B = (rt-org)*dirfrac;
    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));
    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));
    if (tmin<=tmax && tmin>0.0)
    {
        rta = true;
        dist = tmin;
    }
	return rta;
}

// Function 194
vec3 raymarch(in vec3 ro, in vec3 rd, in vec2 seed)
{
    float t = 0.;
    for (int i=0; i<INIT_ITERS; i++)
    {
    	float dist = map(ro + t*rd);
        t += dist;
    }
    float transmission = 1.0;
    float threshold = noise(seed)*0.7 + 0.2;
    for (int i=0; i<ITERS; i++)
    {
        float st = STEP * (1.+(noise(seed)-0.5)*0.8);
    	transmission *= (1.0 - density(ro + t*rd));
        if (transmission < threshold)
        {
            break;
        }
        seed = noise2D(seed);
        t += st;
    }
    
    //secondary ray
    ro = ro + t*rd;
    vec3 reflectance = vec3(step(ro.y, 0.), step(ro.x, 0.), step(-ro.y, 0.))*smoothstep(length(ro),5., 6.);
    t = 0.;
    vec3 light_dir = normalize(vec3(noise2D(seed), noise(seed)) - 0.5);
    float intensity = pow(light_dir.y + 1., 2.);
    for (int i=0; i<ITERS; i++)
    {
        t += STEP;
    	transmission *= (1.0 - density(ro + t*light_dir));
    }
    
    vec3 n = normal(ro);
    vec3 h = normalize(light_dir - rd);
    float spec = pow(max(0., dot(h, n)), 10.);
    float diffuse = max(0., dot(n, light_dir));
    return reflectance*(spec + diffuse)*intensity;
}

// Function 195
MarchResult MarchRay(vec3 orig,vec3 dir)
{
    float steps = 0.0;
    float dist = 0.0;
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float sceneDist = Scene(orig + dir * dist);
        
        dist += sceneDist * STEP_MULT;
        
        steps++;
        
        if(abs(sceneDist) < MIN_DIST)
        {
            break;
        }
    }
    
    MarchResult result;
    
    result.position = orig + dir * dist;
    result.normal = Normal(result.position);
    result.dist = dist;
    result.steps = steps;
    
    return result;
}

// Function 196
vec3 get_reflection(vec3 ro, vec3 rd, vec3 n)
{
    vec3 new_rd=reflect(rd,n);
    ro+=0.1*n;
    
    acc1=0.;
    float t=0.1;
    for(int i=0;i<20;++i)
    {
        float d=core(ro+t*new_rd);
        d*=rnd; t+=d;
        if(d<0.1 || t>=FAR)
            break;
    }
    vec3 col=vec3(0);
    if(t<FAR)
        col=acc1*0.1*lightcolor(rd.x);
    return col;
}

// Function 197
float Raymarch( const in C_Ray ray )
{        
    float fDistance = 0.1;
        
    for(int i=0;i<=kMaxIterations;i++)              
    {
        float fSceneDist = GetDistanceScene( ray.vOrigin + ray.vDir * fDistance );
        
        if((fSceneDist <= 0.01) || (fDistance >= 1000.0))
        {
            break;
        }                        

        fDistance = fDistance + fSceneDist; 
    }

	fDistance = min(fDistance, 1000.0);
	
	return fDistance;
}

// Function 198
vec3 sceneNormal( vec3 pos, float d )
{
    float eps = 0.0001;
    vec3 n;
	
    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;
    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;
    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;
	
    return normalize(n);
}

// Function 199
vec3 Normals (in vec2 UV, in float Strength, in float T, in float MipLvl, in sampler2D height)
{
    float dx = -Strength*(texture(height,UV+vec2(T,0.0),MipLvl).x - texture(height,UV-vec2(T,0.0),MipLvl).x);
    
    float dy = -Strength*(texture(height,UV+vec2(0.0,T),MipLvl).x - texture(height,UV-vec2(0.0,T),MipLvl).x);    
    
    vec3 Normal = normalize(vec3(dx,dy,sqrt(clamp(1.0-dx*dx-dy*dy,0.0,1.0))));

    return Normal;   
}

// Function 200
float RayMarch(vec3 rayOrigin, vec3 rayDirection)
{
    float distanceFromOrigin = 0.;
    for(int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;
        float distanceToScene = GetDistanceToNearestSurface(p);
        distanceFromOrigin += distanceToScene;
        bool foundSurface = distanceToScene < SURFACE_DIST;
        bool exceededMax = distanceFromOrigin > MAX_DIST;
        if (foundSurface || exceededMax)
            break;
    }
    return distanceFromOrigin;
}

// Function 201
vec3 getNormal(vec3 pos, float epsilon) {
    float rad = 0.0;
	vec3 e = vec3(epsilon, 0.0, 0.0);
    vec3 normal = vec3(map(pos + e.xyy, rad).y - map(pos - e.xyy,rad).y,
                       map(pos + e.yxy,rad).y - map(pos - e.yxy,rad).y,
                       map(pos + e.yyx,rad).y - map(pos - e.yyx,rad).y);
    return normalize(normal);
}

// Function 202
vec3 calcNormal(vec3 pos) {
    vec2 e = vec2(1.0, -1.0) * 1e-3;
    return normalize(e.xyy * map(pos + e.xyy).dist +
                     e.yxy * map(pos + e.yxy).dist +
                     e.yyx * map(pos + e.yyx).dist +
                     e.xxx * map(pos + e.xxx).dist);
}

// Function 203
float ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	const int max_iterations = 255;
	const float stop_threshold = 0.001;
	float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {
		float dist = DE_atlogo( origin + dir * depth );
		if ( dist < stop_threshold ) {
			return depth;
		}
		depth += dist;
		if ( depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 204
void RaymarchScene(in Ray ray, inout RayHit hit)
{
    hit.hit = false;
    
    vec2 sdf   = vec2(FarClip, 0.0);
    vec3 hNorm = vec3(0.0);
    
    float depth = NearClip;
    
    for(int steps = 0; (depth < FarClip) && (steps < 80); ++steps)
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        hit.steepness = 0.0;
        hNorm         = Scene_Normal(pos, 0.0, hit);
        hit.steepness = smoothstep(0.75, 1.0, hNorm.y);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf.x < Epsilon)
        {
            hit.hit       = true;
            hit.surfPos   = pos;
            hit.surfNorm  = Scene_Normal(pos, 1.0, hit);
            hit.depth     = depth;
            hit.heightmap = sdf.y;
            
            break;
        }
        
        depth += sdf.x;
    }
}

// Function 205
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (p);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 206
void makeRay(in vec2 pixelCoord, out vec3 ro, out vec3 rd) {
    rd = vec3(pixelCoord, Lens);
    rd = normalize(rd);

    ro = vec3(0.0, 0.0, -7.0);

    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;
    mouse *= 3.14;
    
    float cx = cos(mouse.x);
    float cy = cos(mouse.y);
    float sx = sin(mouse.x);
    float sy = sin(mouse.y);
    mat3 rotate = mat3(cx, -sx*sy, sx*cy,
                       0.,     cy,    sy,
                       -sx, -cx*sy, cx*cy);
    rd *= rotate;
    ro *= rotate;
}

// Function 207
vec3 normal(vec3 p)
{
	vec3 o = vec3(0.001, 0.0, 0.0);
    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),
                          map(p+o.yxy) - map(p-o.yxy),
                          map(p+o.yyx) - map(p-o.yyx)));
}

// Function 208
bool rayIntersectsLineSegment(vec3 rayOrigin, vec3 rayDirection, vec3 point1, vec3 point2) {
    vec3 v1 = rayOrigin - point1;
    vec3 v2 = point2 - point1;
    vec3 v3 = vec3(-rayDirection.y, rayDirection.x, 0.0);

    float d = dot(v2, v3);
    if (abs(d) < 0.000001)
        return false;

    float t1 = cross2d(v2, v1) / d;
    float t2 = dot(v1, v3) / d;

    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0))
        return true;

    return false;
}

// Function 209
vec2 calcNormal(vec2 p) {
    float h = 0.0001;
    vec2 k = vec2(1,-1);
    vec2 n = normalize( vec2(scene(vec2(p.x + h, p.y)) - scene(vec2(p.x - h, p.y)),
                      scene(vec2(p.x, p.y + h)) - scene(vec2(p.x, p.y - h)))) ;    
    return n;
}

// Function 210
Intersection castRayWithPlan(vec3 p, vec3 a, vec3 b, vec3 o, vec3 d, float flag) {
	Intersection result;
    vec3 n = cross(a,b);

    if (flag > 0.0) {
    	//---------------------------
        // High school Method
    	//---------------------------
        result.t = dot(p-o,n)/dot(d,n);
    	result.u = dot(o+result.t*d-p,a);
    	result.v = dot(o+result.t*d-p,b);
    }
    else {
        //---------------------------
        // Linear Algebra
        //---------------------------
        mat3 A;
        A[0] = -d;
        A[1] = a;
        A[2] = b;
        vec3 x = inverse(A)*(o-p);
        result.t = x[0];
        result.u = x[1];
        result.v = x[2];
    }
    
    // boundary check for the planar surface
    if ( pow(mod(result.u,2.0)-1.0,2.0)+pow(mod(result.v,2.0)-1.0,2.0) > 1.0) {
        result.t = -1.0;   
    }
    
    return result;
}

// Function 211
vec4 castRay(const in vec3 ro, const in vec3 rd) {
  float t = 1.0;
  float tmax = 50.0;

  float precis = 0.0001;
  for(int i = 0; i < 100; i++) {
    vec3 temprd = rd;
    temprd.z += float(i) * 0.0001;
    float dist = mapDistance(ro + temprd * t);
    if(dist < precis || t > tmax)
      break;
    t += dist;
  }

  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).xyz;
  return vec4(t, m);
}

// Function 212
float raymarchTerrain( in vec3 ro, in vec3 rd )
{
	float maxd = 30.0;
    float t = 0.1;
    for( int i=0; i<256; i++ )
    {
	    float h = mapTerrain( ro+rd*t );
        if( h<(0.001*t) || t>maxd ) break;
        t += h*0.8;
    }

    if( t>maxd ) t=-1.0;
    return t;
}

// Function 213
vec3 genNormal(vec3 p){
//	vec3 normal=vec3(
//		sdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),
//		sdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),
//		sdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))
//		);
//	return normalize(normal);
//}

// Function 214
float SheetRay (vec3 ro, vec3 rd)
{
  vec3 r, q;
  vec2 g;
  float d, dMin, sz, szMax, szMin, grLen;
  bvec2 ilt;
  bool bkTrak;
  grLen = 0.92 * spLen;
  dMin = dstFar / grLen;
  rd /= grLen;
  szMax = float (nBallE - 1);
  szMin = 1./32.;
  g = vec2 (0.);
  bkTrak = false;
  sz = szMax;
  for (int ns = 0; ns < nsMax; ns ++) {
    if (sz == szMin) {
      r = GetR (g) - ro;
      q = cross (r, rd);
      if (dot (q, q) < sz * sz && length (g - vec2 (0.5 * szMax)) < 0.5 * szMax) {
       d = dot (rd, r);
        if (d < dMin) {
          dMin = d;
          qgHit = g;
        }
      }
      bkTrak = true;
    }
    q = cross (GetR (g + 0.5 * sz) - ro, rd);
    bkTrak = bkTrak || (dot (q, q) > sz * sz);
    if (bkTrak) {
      bkTrak = false;
      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));
      g.x += ilt.x ? sz : - sz;
      if (! ilt.x) {
        g.y += ilt.y ? sz : - sz;
        if (! ilt.y) {
          sz *= 2.;
          if (sz == szMax) break;
          bkTrak = true;
        }
      }
    } else if (sz > szMin) sz *= 0.5;
  }
  return dMin * grLen;
}

// Function 215
rayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed){
 
	rayCastResults  res;
    
    
    vec3 c=vec3(.5);
    float theta1= PI/2.*floor(mod(rotation,4.));
    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;
    rayDir= rotate( theta1,3)*rayDir; 
    float theta2= PI/2.*(floor(rotation/4.));
    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;
    rayDir= rotate( theta2,2)*rayDir; 
       
     vec3 ro = (rayPosOrig) *N_SUBVOXEL;
   
	//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);
       
	vec3 ri = 1.0/rayDir;
	vec3 rs = sign(rayDir);
    vec3 pos = floor(ro-rayDir*0.002);
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	
	res.hit=false;
	vec3 mm = vec3(0.);
    float t=0.;
       
	for( int i=0; i<int(N_SUBVOXEL)*3; i++ ) 
    {	
        
        
		if(i>=0){
       	 mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           
        }
         dis += mm * rs * ri;
         pos += mm * rs;
        
        //if( sdBox( ro+t*rayDir-vec3(N_SUBVOXEL/2.),vec3(N_SUBVOXEL/2.) )>.05) {res.hit=false; break;}
        
        //float timestep= floor(mod(iTime,N_SUBVOXEL));
        //SHAPES
       
        //SINGLE BLOCK
        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}
     

        if(shape==1){// POLE
        	if( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}
	      
        }else if(shape==2){//STEP 1
            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.5,2.5,0.5) )<.001) {res.hit=true; break;}
          
        }else if(shape==3){//STEP 2
             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.5,2.5,1.5) )<.001) {res.hit=true; break;}

#ifdef ACTIONS
        }else if(shape==4){//FENCE 1
         	if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}
          	if( sdBox( pos-vec3(2.,2.,4.)  ,vec3(.5,2.5,.5) )<.001) {res.hit=true; break;}
          
        }else if(shape==5){//FENCE 2
        	if( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}
          	if( sdBox( pos-vec3(1.,2.,4.)  ,vec3(1.5,.5,.5) )<.001) {res.hit=true; break;}
          	if( sdBox( pos-vec3(2.,1.,4.)  ,vec3(.5,1.5,.5) )<.001) {res.hit=true;break;}

        }else if(shape==6){//SLOPE 1
            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0.001 
            && sdBox( pos-vec3(2.,2.,2.),vec3(2.5,2.5,2.5) )<.001  ) {res.hit=true; break;}
            
        }else if(shape==7){//PANEL
            if(sdBox( pos-vec3(0.,2.,2.)  ,vec3(.5,2.5,2.5) )<.001) {res.hit=true; break;}
#endif           
        }
#ifdef TREE_DETAIL        
        else if(shape==8){//TREE W LEAFS
            
     		if( sdCross( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,1.5) )<.001) {res.hit=true; res.vox.id=10.; break;}
            //vec3 applePos= vec3(1.,1.,1.);//floor(hash33(seed)*5.);
            //if( sdBox( pos-applePos  ,vec3(.5,.5,.5) )<.01 ){res.hit=true; res.vox.id=14.; break;}

            if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(2.5,2.5,2.5) )<.001 && hash13(floor(pos)+seed+.5 )  >.75){res.hit=true; res.vox.id=11.; break;}
    
            //
        }else if(shape==9){//TRUNK
			vec3 p=pos-vec3(2.,2.,2.);
            //p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);
            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}
         
        }
#endif        
	}
	
	
    if(res.hit){
        res.normal = - mm*rs; 
        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);
        res.dist=hitPos.a/N_SUBVOXEL;
        vec3 xyz = hitPos.xyz - pos;
        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );
        if(abs(mm.x)>0.) res.uv=res.uv.yx; //invert xz 
        //relative to absolute normals:
   		res.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;
    }
    return res;  
}

// Function 216
vec3
rayOnHemisphere(float seed, vec3 nor)
{
    float u = hash( 78.233 + seed);
    float v = hash( 10.873 + seed);

    float a = 6.2831853 * v;
    u = 2.0*u - 1.0;
    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );   
}

// Function 217
vec2 castRay( in vec3 ro, in vec3 rd ) {
    float tmin = 0.5;
    float tmax = MAX_T;
    
    // bounding volume
    const float top = 0.95;
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
    
    float t = tmin;
    float mat = -1.;
    
    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );
    rd1 = rotateY( rd1, CLOCK_ROT_Y );
    
	float secs = mod( floor(iDate.w),        60.0 );
	float mins = mod( floor(iDate.w/60.0),   60.0 );
	float hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;
    
    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );
    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );
    
    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );
    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );
    
    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );
    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );
    
    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));
    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));
    
    for( int i=0; i<48; i++ ) {
	    float precis = 0.00025*t;
	    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, 
                       watchIntersect, pencilIntersect );
        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);
        t += res.x;
        mat = res.y;
    }

    if( t>tmax ) t=-1.0;
    return vec2(t, mat);
}

// Function 218
vec3 normal(vec3 p, float t, float mindist) {
    float e = mindist*t;
    vec2 h = vec2(1.0,-1.0)*0.5773;
    return normalize( h.xyy*map( p + h.xyy*e ).x + 
                      h.yyx*map( p + h.yyx*e ).x + 
                      h.yxy*map( p + h.yxy*e ).x + 
                      h.xxx*map( p + h.xxx*e ).x );
}

// Function 219
vec4 packNormal( const in float value ){
    vec4 res = fract( value*bitShL );
	res.yzw -= res.xyz/256.0;
	return res;
}

// Function 220
float trace_ray(in ray r, inout seed_t seed) {   
    float reflectance = 1.0;
    bool stop = false;
    
    for (int i = 0; i < 10; i++) {
        reflectance *= hit(r, r, stop, seed);
        if (stop) break;
    }
    
    if (stop) {
    	return reflectance;
    } else {
        return 0.0;
    }
}

// Function 221
float reflectivity(in vec3 p, in vec3 n, in vec3 d, in float id, in float rid)
{
    float r = 0.;
    // The garage floor and ceiling have their own reflectivities.
    if(id == ID_GARAGE)
    {
        // The floor is shinier where puddles are.
        if(n.y > 0.8)
        {   
            // This is keyed with the puddle texture.
            r = mix(.1,.2, step(.6, fbm(PUDDLESCALE*p, n)));
        }
        // The ceiling isn't shiny everywhere.
        else if(n.y < -.8)
            r = mix(.0, .075, smoothstep(.3,.7, fbm(.005*p, n)));
        else r = 0.0;
    }
    // The pipes are quite shiny.
    else if(id == ID_PIPES)
    {
        r = .333;
    }
    // If we are reflecting the lights, bump up how reflected they are to
    // mimick the reflection of a light source being brighter than the
    // rest of the reflected image.
    if(rid == ID_LIGHTS) r *= 2.0;
    return r*=pow(length(cross(n,d)),2.0);
}

// Function 222
vec3 positionOnRay(in Ray ray, in float t) {
  return ray.origin + ray.direction * t;
}

// Function 223
vec2 rayMarch(in vec3 u,vec3 t,float l,float m,float zFar)
{float g = -1.//matrrial
;for(float i=.0;i<iterRm;i++
){vec2 r=gd(u+t*m);g=r.y
 ;if(r.x<eps||m>zFar)break
 ;m+=r.x*l
;}
;g=mix(-1.,g,step(m,zFar));
;return vec2(m,g);}

// Function 224
vec3 getDetailNormal(vec3 p, vec3 normal, float t, int id){
    vec3 tangent;
    vec3 bitangent;
    //Construct orthogonal directions tangent and bitangent to sample detail gradient in
    pixarONB(normal, tangent, bitangent);
    
    tangent = normalize(tangent);
    bitangent = normalize(bitangent);
    
    float EPS = DETAIL_EPSILON * 0.2;
    
    vec3 delTangent = vec3(0);
    vec3 delBitangent = vec3(0);
    
    for(int i = ZERO; i < 2; i++){
        
        //i ->  s
        //0 ->  1
        //1 -> -1
        float s = 1.0 - 2.0 * float(i&1);
    
        delTangent += s * getDetailExtrusion(p + s * tangent * EPS, normal, id);

        delBitangent += s * getDetailExtrusion(p + s * bitangent * EPS, normal, id);

    }
    
    return normalize(cross(delTangent, delBitangent));
}

// Function 225
vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)
{   
    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);
    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));
    vec3 vaxis = normalize(cross(plane.xyz, uaxis));
    vec3 collisionPos = rayPos + rayDir * collisionTime;
    uv.x = dot(collisionPos, uaxis);
    uv.y = dot(collisionPos, vaxis);    
    return vec4(collisionTime, plane.xyz);
}

// Function 226
vec3 normal(vec3 p, float t){
    float e = MIN_DIST*t;
    vec2 h =vec2(1,-1)*.5773;
    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+
             h.yyx * map(p+h.yyx*e,0.).x+
             h.yxy * map(p+h.yxy*e,0.).x+
             h.xxx * map(p+h.xxx*e,0.).x;
    return normalize(n);
}

// Function 227
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.0001, 0.0, 0.0 );
    float d = map(pos).x;
    return normalize( vec3(
	    map(pos+eps.xyy).x - d,
	    map(pos+eps.yxy).x - d,
	    map(pos+eps.yyx).x - d)
	);
}

// Function 228
void abstract_glassy_field_refract(inout vec3 _2144, vec3 _2145, vec3 _2146, float _2147)
{
    float _2161 = ((_2146.x * _2145.x) + (_2146.y * _2145.y)) + (_2146.z * _2145.z);
    float _2166 = 1.0 - ((_2147 * _2147) * (1.0 - (_2161 * _2161)));
    float _2207;
    vec3 _2208;
    vec3 _2209;
    vec3 _2210;
    vec3 _2211;
    vec3 _2212;
    vec3 _2213;
    if (_2166 < 0.0)
    {
        abstract_glassy_field_vec3s(_2144, 0.0);
        _2207 = _242;
        _2208 = _240;
        _2209 = _240;
        _2210 = _240;
        _2211 = _240;
        _2212 = _240;
        _2213 = _240;
    }
    else
    {
        vec3 _2179 = _240;
        _2179.x = _2147 * _2145.x;
        vec3 _2180 = _2179;
        _2180.y = _2147 * _2145.y;
        vec3 _2181 = _2180;
        _2181.z = _2147 * _2145.z;
        float _2183 = sqrt(_2166);
        float _2184 = (_2147 * _2161) + _2183;
        vec3 _2192 = _240;
        _2192.x = _2184 * _2146.x;
        vec3 _2193 = _2192;
        _2193.y = _2184 * _2146.y;
        vec3 _2194 = _2193;
        _2194.z = _2184 * _2146.z;
        _2144.x = _2181.x - _2194.x;
        _2144.y = _2181.y - _2194.y;
        _2144.z = _2181.z - _2194.z;
        _2207 = _2183;
        _2208 = _2194;
        _2209 = _2181;
        _2210 = _2146;
        _2211 = _2194;
        _2212 = _2145;
        _2213 = _2181;
    }
}

// Function 229
vec4 raycast(in vec2 uv, in vec3 pos, in vec3 target) {
    vec3 up = vec3(0, 0, 1);
    vec3 w = normalize(target - pos);
    vec3 u = normalize(cross(w, up));
    vec3 v = cross(u, w);
    vec3 ray = normalize(w * FDIST + (uv.x - iResolution.x/2.) * u / iResolution.x + (uv.y - iResolution.y/2.) * v / iResolution.x);
    
    int i;
    float currdepth = 0.;
    for (i=0; i<20;i++) {
        currdepth += totalsdf(pos + currdepth * ray).w;
    }
    vec4 d;
    if (abs((d = totalsdf(pos + currdepth * ray)).w) < 0.1) {
        float xnorm = dot(u, d.xyz);
        float ynorm = dot(v, d.xyz);
        return vec4(1., xnorm/2.+0.5, ynorm/2.+0.5, 1.);
    } else {
        return vec4(0., 0., 0., 1.);
    }
}

// Function 230
int cast_ray(const in vec3 origin, const in vec3 direction, out vec3 intersection, const in int cur_space) {
    vec3 ray_pos = origin;
    int next_space;
    float dist = 0.0;
    int num_rays = 0;
    do {
        ray_pos += dist * direction;
        num_rays ++;
        dist = abs(map(ray_pos, cur_space, next_space));
    } while(length(ray_pos) < CLIP_FAR && dist > TOUCH_DIST && num_rays < RAY_STEP_LIMIT);
    if(dist > TOUCH_DIST) next_space = 0; // far-clipped or reached step limit
    intersection = ray_pos;
    return next_space;
}

// Function 231
vec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {
    vec2 m = vec2(-1.0, -1.0);
    vec2 res = vec2(tmin, -1.0);
    res.x = tmin;
	for( int i=0; i<NUM_STEPS; i++ )
	{
        m = map(ro + res.x*rd);
		if( m.x<tmin || res.x>tmax ) break;
		res.x += 0.5*m.x;
        res.y = m.y;
	}
    if( res.x>tmax ) res.y=-1.0;
	return res;
}

// Function 232
vec3 castRay( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t=tmin;
    float m=-1.0, id=-1.0;

    for( int i=0; i<100; i++ )
    {
        float precis = 0.0005*t;

        vec3 res = map( ro+rd*t );
        if( t<precis || t>tmax ) break;
        t += res.x;
        m = res.y;
        id = res.z;
    }

    if( t>tmax ) { m=-1.0; id=-1.0; }
    return vec3( t, m, id );
}

// Function 233
float RayMarch(vec3 ro, vec3 rd,out float glowCumul) {
	float dO=0.0;  
    float dS;
    float dC; // distance to cell boundaries
    float glowDist;
    glowCumul=0.0;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        dS = GetDist(p,glowDist,dC);
        dO += min(dS*.9,dC+0.05); 
        float at = 1.0 / (1. + pow(glowDist*20.,3.0) );
        glowCumul+=at;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }    
    return dO;
}

// Function 234
vec3 normal(vec3 p,vec3 ray,float t,vec4 m,mat4 B//4tap tetrahedralOffset derivative in3d.
){mat4 n=(outerProduct(vec4(p,0),vec4(1))
 +(((mat4(0,0,0,2,0,4,4,2,4,0,4,2,4,4,0,2)-2.)*t/iResolution.x)))
 ;vec4 a=vec4(map(n[0].xyz).x
             ,map(n[1].xyz).x
             ,map(n[2].xyz).x
             ,map(n[3].xyz).x)
 ;p=(n*a).xyz-p*ad(a)
 ;p-=max(.0,dot(p,ray))*ray
 ;if(p==vec3(0))return vec3(1)//NaN-evasion, normalize(vec3(0)) divides by /0.
 ;return normalize(p);}

// Function 235
hitInfo rayCubeIntersec(vec3 ro, vec3 rd, vec3 size)
{
    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;
    vec3 viewSign = cullingDir*sign(rd);
    vec3 t = (viewSign*size-ro)/rd;
    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]
    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;
    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;
    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return hitInfo(t.x,(uvx+1.)/2.);
    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return hitInfo(t.y,(uvy+1.)/2.);
    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return hitInfo(t.z,(uvz+1.)/2.);
	return hitInfo(MAX_DIST,vec2(0));
}

// Function 236
vec3 map_Ssph_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return reflect(rd, nrm);
}

// Function 237
vec4 sampleNormalMap(vec3 N) 
{
    float u = 1.-(atan(N.x, N.z)+PI)/(2.*PI);
	float v = (acos(N.y)/PI);	// 1.- becouse the coordinates origin is in the bottom-left, but I backed from top-left
    return texture(iChannel0, vec2(u, v));   
}

// Function 238
vec3 RayScattering()
{
    vec3 Scattering;
    Scattering.r = kAtmRayScattering_680nm;
    Scattering.g = kAtmRayScattering_550nm;
    Scattering.b = kAtmRayScattering_440nm;
    return Scattering * kKilometersToMeters;
}

// Function 239
vec3 getNormal(vec2 uv, int tex ) {
#ifdef NORMAL_MAPS
    const float heightScale = 0.004;

    vec2 res = getTexRes(tex);
    vec2 duv = vec2(1.0) / res.xy;
    vec3 c  = getColor( uv, tex).xyz;
    vec3 c1 = getColor( uv + vec2(duv.x, 0.0), tex).xyz;
    vec3 c2 = getColor( uv - vec2(duv.x, 0.0), tex).xyz;
    vec3 c3 = getColor( uv + vec2(0.0, duv.y), tex).xyz;
    vec3 c4 = getColor( uv - vec2(0.0, duv.y), tex).xyz;
    
    float h0	= heightScale * dot(c , vec3(1.0/3.0));
    float hpx = heightScale * dot(c1, vec3(1.0/3.0));
    float hmx = heightScale * dot(c2, vec3(1.0/3.0));
    float hpy = heightScale * dot(c3, vec3(1.0/3.0));
    float hmy = heightScale * dot(c4, vec3(1.0/3.0));
    float dHdU = (hmx - hpx) / (2.0 * duv.x);
    float dHdV = (hmy - hpy) / (2.0 * duv.y);
    
    return normalize(vec3(dHdU, dHdV, 1.0));
#else
    return vec3(0.0, 0.0, 1.0);
#endif
}

// Function 240
float raytrace(vec3 ro, vec3 rd) {
	
    // Parameters
    int maxSteps = 500;
    float maxStepDist = 0.12;
    float maxDist = 100.0;
    int maxIterations = 10;
    float eps = 0.01;
    
    // Initial Raymarching Steps
    bool didHit = false;
    float beforeDist = -1.0;
    float afterDist = 0.0;
    float t = 0.0;
    for (int i = 0; i < maxSteps && t < maxDist; i++) {
        
        beforeDist = afterDist;
        afterDist = t;
    	vec3 p = ro + t * rd;
        float height = heightMap(p.xz);
        if (p.y - height < eps) {
			didHit = true;
            break;
        }
        
        // Normally raymarching would just be done using 'p.y - height', however this does not
        // take into account the proximity to the nearest cliff. To account for this, a maximum
        // step size is imposed. Additionally, if the ray is currently above the maximum height
        // of the heightmap, it can safely move forward by the distance to the top of the heightmap
        //t += min(p.y - height, maxStepDist);
        t += max(min(p.y - height, maxStepDist), p.y - VSCALE);
        
    }
    if (!didHit) {
    	return -1.0;
    }
    
    // Use the interval bisection method to find a closer point, as moving forward by a fixed step
    // size may have embedded the ray in a cliff
    for (int i = 0; i < maxIterations; i++) {
    	float midVal = (beforeDist + afterDist) / 2.0;
        vec3 p = ro + midVal * rd;
        if (p.y < heightMap(p.xz)) {
        	afterDist = midVal;
        }
        else {
        	beforeDist = midVal;
        }
    }
    
    // Return the midpoint of the closest point before the terrain, and the closest point after it
    return (beforeDist + afterDist) / 2.0;
    

}

// Function 241
vec3 RayTrace(vec3 ro, vec3 rd, vec4 noise) 
{
	vec3 color = vec3(0,0,0);
    
    float dist = GetSceneDistance(ro,rd);

    vec2 atmosInOut = sphIntersect( ro, rd, PLANETCENTER, ATMOSPHERETHICKNESS+PLANETRADIUS);
    
    if (dist<MAX_DIST)
    {
        // Hit planet

        atmosInOut.y = dist;
        vec3 pos = ro + rd * dist;   
		vec3 n = GetNormal(pos);
        
        vec3 localPos = (pos - PLANETCENTER)*0.5;
		localPos = RotateY(localPos, iTime*0.05);
        float heatDistribution = smoothstep(2.5, 0.5, (abs(localPos.y) + GetNoise(localPos+vec3(-20,55,20))));
        
        float height = GetFBM(localPos) * 0.6;
        float waterMask = smoothstep(OCEANS_LEVEL+0.05, OCEANS_LEVEL-0.05, height);

        float waterHeight = clamp((height / OCEANS_LEVEL),0.0,1.1); 
        float groundHeight = clamp(((height-OCEANS_LEVEL) / (1.0-OCEANS_LEVEL)),0.0,1.0); 
        float foamNoise =  GetNoise(localPos*7.0*(0.75+0.25*sin(iTime*0.1)))*0.25;
        float foamLimit = smoothstep(0.6+foamNoise, 1.0, waterHeight);
        foamLimit = 0.7*foamLimit + 0.3*fract(foamLimit*4.0-iTime*.2)*foamLimit*smoothstep(1.0, 0.85, foamLimit);

		float iceDistribution = smoothstep(4.0, 4.3, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5 + GetNoise(localPos+vec3(-20,55,20))));
		float wideIceDistribution = smoothstep(2.5, 3.0, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5));

        float flatening = waterMask*(1.0-iceDistribution);
        flatening = max(flatening, iceDistribution*0.75);
        
        float light = GetLight(pos, n, height, flatening);
        float dif = clamp(light, 0., 1.);
        float invdif = smoothstep(0.1, 0.1-0.05, light);
        
		vec3 lightPos = LIGHTPOS;
	    vec3 l = normalize(lightPos-pos);
	    float rawNdotL = clamp(dot(n, l), 0.0, 1.0);
        rawNdotL = smoothstep(0.0, 0.2, rawNdotL);
		dif = max(dif,rawNdotL*0.4); 
        dif*=rawNdotL;
        
        vec3 groundColor = mix (vec3(.3,.1,0), vec3(1.0,.5,.40),clamp(groundHeight*3.0, 0.0, 1.0));
        groundColor = mix (groundColor, vec3(0.76,.36,.36),clamp((groundHeight-0.23)*3.0, 0.0, 1.0));
        groundColor = mix (groundColor, vec3(0.86,.8,.8),clamp((groundHeight-0.53)*6.0, 0.0, 1.0));
        vec3 hotWaterColor =mix (vec3(0.0,.2,.6), vec3(0.0,.4,1.00),smoothstep(0.0, 0.9, waterHeight)); 
        vec3 coldWaterColor =mix (vec3(0.15,.3,0.500), vec3(0.2,0.5,.7), smoothstep(0.0, 0.9, waterHeight)); 
        vec3 waterColor =mix (coldWaterColor, hotWaterColor, heatDistribution); 
		waterColor = mix (waterColor , vec3(0.7,.8,0.9),foamLimit);

        vec3 finalColor = mix(groundColor, waterColor, waterMask);

		finalColor = mix (finalColor, mix(vec3(1.1,1.1,1.1),vec3(.9,1.0,1.0),abs(sin(height*10.0))), iceDistribution);

        float fresnel =pow (1.0-clamp(dot(n, -rd), 0., 1.), 3.0);

        invdif*= (1.0-fresnel);
        dif *= (1.0-fresnel);
        color = vec3(dif) * finalColor;
        
		float citiesLimit = smoothstep(0.0, 0.1, groundHeight)*smoothstep(0.15, 0.13, groundHeight)*(1.0-waterMask)*(1.0-iceDistribution);

        float greenArea = smoothstep(0.0, 0.01, groundHeight)*smoothstep(0.45, 0.3, groundHeight)*(1.0-waterMask)*(1.0-wideIceDistribution);

        vec2 cityInfo = inverseSF(normalize(localPos), 150.0)+
            inverseSF(normalize(localPos), 100.0);
        localPos = normalize(localPos);
        
        vec2 lightInfo1 = inverseSF(localPos, 23000.0);
        vec2 lightInfo2 = inverseSF(RotateX(localPos, 1.0), 38000.0);
        vec2 lightInfo3 = inverseSF(RotateX(localPos, 1.5), 33000.0);

        float townMask = smoothstep(0.28, 0.1, cityInfo.y);
        
		float lightIntensity = min(min(lightInfo1.y*1.25*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015))), 
								lightInfo2.y*1.75*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015)))
                                ), lightInfo3.y*(1.0+smoothstep(0.8,0.4,GetHash1((lightInfo1.x)*.015))));
		lightIntensity = smoothstep(0.01, 0.000, lightIntensity);
        
        float cityArea = smoothstep(0.2, 0.18, cityInfo.y) * citiesLimit;
		citiesLimit*=townMask* lightIntensity;
	        
        greenArea *=smoothstep(0.4, 0.3, cityInfo.y)*smoothstep(0.25, 0.28, cityInfo.y);
        color = mix (color,vec3(dif) * mix(vec3(.45, .65, .15),vec3(.1, .35, .1), GetNoise(localPos*150.0))
                     , clamp(greenArea-GetNoise(localPos*70.0)*0.6, 0.0, 1.0));
        
        color = mix (color, vec3(.15, .15, .15), cityArea);
        color = mix(color, vec3(.35, .35, .35), clamp(citiesLimit*2.0, 0.0, 1.0));
    	color += vec3(0.95, 0.8, 0.5)*invdif*citiesLimit*2.0;
  
		vec3 localPosClouds = (pos - PLANETCENTER)*0.25;
		localPosClouds = RotateY(localPosClouds, iTime*0.055 + localPosClouds.y*0.85);
        float clouds = GetFBMClouds(localPosClouds*3.0-vec3(iTime*0.025)) * 0.6;

		vec3 localPosCloudsBis = (pos+l*0.1 - PLANETCENTER)*0.25;
		localPosCloudsBis = RotateY(localPosCloudsBis, iTime*0.055);
        float cloudsBis = GetFBMClouds(localPosCloudsBis*3.0-vec3(iTime*0.025)) * 0.6;

        float level = smoothstep(OCEANS_LEVEL-0.1, OCEANS_LEVEL+0.6, height);
        clouds = smoothstep(0.5+level*0.85, 0.8+level*0.85, clouds);
        float cloudShadow = 1.0-smoothstep(0.5+level*0.85, 1.0+level*0.85, cloudsBis)*0.75*(1.0 - clamp(dot(n, l), 0.0, 1.0));
        
        color = mix (color*cloudShadow, vec3(1)*rawNdotL*cloudShadow, clouds);
    }
    else
    {
        
		float dO=0.;
 
	    vec2 inter = sphIntersect( ro, rd, MOONCENTER, MOONRADIUS);
		if (inter.x>=0.0)
        {
            // moon hit
            
            vec3 hitPos = inter.x * rd + ro;
            vec3 hitNormal = normalize(hitPos-MOONCENTER);
       		vec3 lightPos = LIGHTPOS;
		    vec3 l = normalize(lightPos-hitPos);

            float dif = clamp(dot(l, hitNormal), 0.0, 1.0);
            float noise = GetFBM(hitPos*0.4);
            color = mix(vec3(0.2), vec3(.4), noise)*dif;
        }
		else
        {
            // background
            
            vec3 pos = normalize(ro + rd * 1000.0);   
            pos = pos.xyz;

            for(float i=0.0;i<5.0;i++)
            {
                vec2 info = inverseSF(pos, 50000.0 + i*5000.0);
                float random = GetHash1((info.x + i*10.0)*.015);
                float distToStar = smoothstep(0.00025+0.0015*pow((1.0-random), 15.0), 0.0002,info.y) * smoothstep(0.1, 0.0,random ); 

                color = max(color, vec3(distToStar));
            }
                
            float noise = GetFBM(pos*2.0 + vec3(0.0, 0.0, iTime*0.05));
            float nebulae = smoothstep(0.4, 1.8, noise);
			float nebulae1 = max(0.3-abs(nebulae-0.3), 0.0)*1.0;
			float nebulae2 = max(0.2-abs(nebulae-0.4), 0.0)*1.0;
			float nebulae3 = max(0.3-abs(nebulae-0.5), 0.0)*1.0;

            vec3 nebulaeColor = vec3(0.0, 0.2, 0.7)*nebulae1 + vec3(0.5, 0.4, 0.3)*nebulae2 + vec3(0.1, 0.2, 0.4)*nebulae3;

            color += nebulaeColor;
        }        
    }
    
    if (atmosInOut.x>=0.0)
    {
        float density = .1;
        
        atmosInOut.x-=noise.r;
        // Atmosphere
        float atmosphereToGo = atmosInOut.y - atmosInOut.x;
        
        vec3 startPosition = ro + rd * atmosInOut.x;
        
        float lightEnergy  = 0.0;
        float transmittance = 1.0;
        float steps = 0.0051;
        for(float i = 0.0; i<atmosphereToGo;i+=steps)
        {
			vec3 pos = startPosition+rd*i;
            
            float localDensity = Density(pos)*steps;
            vec3 lightDir = -normalize(pos-LIGHTPOS);
            float shadow = GetSceneDistance(pos, lightDir);
            shadow = step(MAX_DIST*0.9, shadow);
            
            lightEnergy+=  localDensity * shadow;
			transmittance *= (1.0-localDensity*1.0);
            
        }
        color = mix(color, 
                    mix( vec3(0.1,0.15,0.7), vec3(0.65,0.8,1.0),(1.0-exp(-lightEnergy*0.6)))
                        *clamp(lightEnergy*0.5, 0.0, 1.0),(1.0-transmittance)* (1.0-exp(-lightEnergy*0.6)));
    }
    

    
    return color;
}

// Function 242
vec3 cameraRay ( in vec3 camPos, in vec3 camTar, in vec2 uv, in vec3 F, in vec3 R, in vec3 U) {
	vec3 ref = camPos + 0.1 * F;
    float len = 0.1;
    float aspect = iResolution.x / iResolution.y;
    vec2 fuv = 2.0 * uv - 1.0;
    vec3 p = ref + aspect * fuv.x * len * 0.41421356237 * R + fuv.y * len * 0.41421356237 * U;
    return normalize(p - camPos);
}

// Function 243
float raymarchAO(in vec3 ro, in vec3 rd, float tmin) {
    float ao = 0.0;
    for (float i = 0.0; i < 5.0; i++) {
        float t = tmin + pow(i / 5.0, 2.0);
        vec3 p = ro + rd * t;
        float d = intersect(p).y;
        ao += max(0.0, t - 0.5 * d - 0.05);
    }
    return 1.0 - 0.00125 * ao;
}

// Function 244
float raymarch(vec3 ray_ori, vec2 uv) {
	vec3 target = vec3(0);
	vec3 ray_dir = camera(ray_ori, target, uv);
	vec3 pos = ray_ori;

	// local density/distance
	float ldensity = 0.;

	// accumulation color & density
	vec4 sum = vec4(0.);

	float tmax = 25.;
	float tdist = 0., dist = 0.;

	for (float i = 0.; (i < 1.); i += 1. / 64.) {

		if (dist < tdist * .001 || tdist > tmax || sum.a > .95)
			break;

		// evaluate distance function
		dist = de(pos) * .59;

		// check whether we are close enough (step)
		// compute local density and weighting factor 
		const float h = .05;
		ldensity = (h - dist) * step(dist, h);

		vec4 col = vec4(1);
		col.a = ldensity;

		// pre-multiply alpha
		// checkout: https://www.shadertoy.com/view/XdfGz8
		// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf
		col.rgb *= col.a;
		sum += (1. - sum.a) * col;

		// from duke/las
		sum.a += .004;

		// enforce minimum stepsize
		dist = max(dist, .03);

		// step forward
		pos += dist * ray_dir; // sphere-tracing
		tdist += dist;
	}

	// from duke/las
	// simple scattering approximation
	sum *= 1. / exp(ldensity * 3.) * 1.25;

	sum.r = pow(sum.r, 2.15);
	sum.r -= texture(iChannel0, uv * 6.).r * .18;

	return sum.r;
}

// Function 245
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = minRay;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0001 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;

    // raymarch primitives
    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = max(tmin,minRefrac);
#if AA>1
        for( int i=0; i<70 * AA && t<tmax; i++ )
#else
        for( int i=0; i<70 && t<tmax; i++ )
#endif
        {
            vec2 h = map( ro+rd*t );

            t = minRefrac > 0. ? abs(t) : t;
            if( abs(h.x)<(0.0001*t) )
            {
                res = vec2(t,h.y);
                break;
            }
            t +=  minRefrac > 0. ? -(h.x) : h.x;
        }
    }
    return res;
}

// Function 246
vec3 normal(vec3 p){

	vec3 n = vec3(0.);
	n.x = map(p + MINX) - map(p - MINX);
	n.y = map(p + MINY) - map(p - MINY);
	n.z = map(p + MINZ) - map(p - MINZ);
	
	return normalize(n);
}

// Function 247
vec3 calcNormal( in vec3 pos )
{
#ifdef ANALYTIC_NORMALS	
	return norMetaBalls( pos );
#else	
    vec3 eps = vec3(precis,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy) - map(pos-eps.xyy),
           map(pos+eps.yxy) - map(pos-eps.yxy),
           map(pos+eps.yyx) - map(pos-eps.yyx) ) );
#endif
}

// Function 248
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,3.0) );
    //if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        //tmin = max(tb.x,tmin);
        //tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 249
vec3 dfNormal( in vec3 p ) {
    
    
	vec3 eps = vec3(0.0005, 0.0, 0.0);
	vec3 res = vec3(
	    map(p+eps.xyy).d - map(p-eps.xyy).d,
	    map(p+eps.yxy).d - map(p-eps.yxy).d,
	    map(p+eps.yyx).d - map(p-eps.yyx).d);
	return normalize(res);
	
}

// Function 250
void intersect_ray_plane(vec3 origin, vec3 direction, vec3 plane_normal, float plane_offset, out float near)
{
    float t = -(dot(plane_normal, origin) + plane_offset) / dot(plane_normal, direction);
    near = t * length(direction);
}

// Function 251
vec3 getNormalSphere(vec3 p, Sphere sphere) {
    vec2 e = vec2(.0001, 0);
    float d = sphereSDF(p, sphere);
    vec3 n = d - vec3(
        sphereSDF(p-e.xyy, sphere),
        sphereSDF(p-e.yxy, sphere),
        sphereSDF(p-e.yyx, sphere));
    return normalize(n);
}

// Function 252
float castRay(const int scene, vec3 eye, vec3 dir, float start, float end, float epsilon, int max_marching_steps, out int material) {
#if FIND_CLOSEST_MATERIAL
    float min_d = 1e10;
    int min_material = 0;
#endif
    
    float depth = start;
    for (int i = 0; i < max_marching_steps; i++) {
        float d = sceneSDF(scene, eye + depth * dir, material);
#if FIND_CLOSEST_MATERIAL
        if (d < min_d) {
            min_d = d;
            min_material = material;
        }
#endif

        if (d < epsilon)
			return depth;

        depth += d;
        if (depth >= end)
            break;
    }

#if FIND_CLOSEST_MATERIAL
    // If we ran out of steps -OR- we didn't hit anything,
    // pretend we hit whatever was closest in the ray segment
    // that we did trace.
    material = min_material;
#endif
    return end;
}

// Function 253
vec3 normal(vec3 p)
{
	float c = scene(p).w;
	vec2 h = vec2(0.01, 0.0);
	return normalize(vec3(scene(p + h.xyy).w - c, 
						  scene(p + h.yxy).w - c, 
		                  scene(p + h.yyx).w - c));
}

// Function 254
bool refractFunc(in vec3 v, in vec3 n, in float ni_over_nt, out vec3 refracted){
    float dt = dot(normalize(v), n);
    float discreminant = 1.0 - ni_over_nt*ni_over_nt*(1.0-dt*dt);
    if(discreminant > 0.0){
        refracted = refract(v, n, ni_over_nt);
        return true;
    }
    return false;
}

// Function 255
vec3 NormalBlend_RNM(vec3 n1, vec3 n2)
{
    // Unpack (see article on why it's not just n*2-1)
	n1 = n1*vec3( 2,  2, 2) + vec3(-1, -1,  0);
    n2 = n2*vec3(-2, -2, 2) + vec3( 1,  1, -1);
    
    // Blend
    return n1*dot(n1, n2)/n1.z - n2;
}

// Function 256
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 180; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += 0.2 * h + 0.007 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 7; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 257
vec3 waterNormals(vec2 uv){
    uv.x *= .25;
    float eps = 0.008;    
    vec3 n=vec3( waterHeight(uv) - waterHeight(uv+vec2(eps,0.)),
                 1.,
                 waterHeight(uv) - waterHeight(uv+vec2(0.,eps)));
   return normalize(n);
}

// Function 258
vec3 calcNormal(vec3 p){
    const float eps = collisiondistance;
    const vec2 h = vec2(eps, 0.0);
    return normalize(vec3(distanceestimator(p+h.xyy)-distanceestimator(p-h.xyy),
                          distanceestimator(p+h.yxy)-distanceestimator(p-h.yxy),
                          distanceestimator(p+h.yyx)-distanceestimator(p-h.yyx)));
}

// Function 259
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce ) {
    specularBounce = false;
    
    lowp vec3 r = cosWeightedRandomHemisphereDirection( n );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        lowp float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1.0; 
            n2 = 1.5;
            n = -n;
        } else {
            n1 = 1.5;
            n2 = 1.0; 
        }

        lowp float r0 = (n1-n2)/(n1+n2); r0 *= r0;

		lowp float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),2.);
        
        lowp vec3 ref;
        
        ref = reflect( rd, n );
        
        return normalize( ref + 0.1 * hash1() * r );
	}
}

// Function 260
vec2 raycast( in vec3 ro, in vec3 rd )
{
    float tmax = 7.0;
	float tmin = kPrecis;    

    // intersect clipping plane
    #ifdef CUT
    const float kSplit = 0.01;
    float tpS = (kSplit-ro.y)/rd.y;
    if( tpS>0.0 )
    {
        if( ro.y>kSplit ) tmin = max(tmin,tpS);
        else              tmax = min(tmax,tpS);
    }
	#endif
    
    // intersect lower clipping plane
    #if 1
    {
    float tpF = (-0.8-ro.y)/rd.y;
    if( tpF>0.0 ) tmax = min(tmax,tpF);
    }
    #endif

    // intersect bounding sphere
    #if 1
    vec2 bv = iSphere( ro, rd, kBSRad );
    if( bv.y<0.0 ) return vec2(-2.0,0.0);
    tmin = max(tmin,bv.x);
    tmax = min(tmax,bv.y);
	#endif
    
    // raymarch
    vec2  res = vec2(-1.0);
    float t = tmin;
	float lt = 0.0;
	float lh = 0.0;
    for(int i=0; i<1024; i++ )
    {
        res = map(ro+rd*t);
        if( res.x<kPrecis ) break;
		lt = t;
		lh = res.x;
        #ifndef TRAPS
        t += min(res.x,0.2);
        #else
        t += min(res.x,0.01)*(0.5+0.5*frand());
        #endif
        if( t>tmax ) break;
    }
    // linear interpolation for better isosurface
	if( lt>0.0001 && res.x<0.0 ) t = lt - lh*(t-lt)/(res.x-lh);
	
    res.x = (t<tmax)?t:-1.0;

    return res;
}

// Function 261
vec3 normal(vec3 p, vec3 dist) 
{
    float eps = dot2(dist) * EPSILON_NRM;
    vec3 n;
    n.y = seaFragmentMap(p); 
    n = vec3(seaFragmentMap(vec3(p.x + eps, p.y, p.z)) - n.y,
	     	 seaFragmentMap(vec3(p.x, p.y, p.z + eps)) - n.y,
	     	 eps);
    return normalize(n);
}

// Function 262
vec3 normalL(vec3 p) {
    vec2 q = vec2(0., EPS);
    return normalize(vec3(mapL(p+q.yxx) - mapL(p-q.yxx),
                		  mapL(p+q.xyx) - mapL(p-q.xyx),
                		  mapL(p+q.xxy) - mapL(p-q.xxy)));
}

// Function 263
vec3 normal(in vec3 p)
{
  //tetrahedron normal
  const float n_er=0.01;
  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er));
  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er));
  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er));
  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er));
  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
}

// Function 264
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.01;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<400; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x*0.05;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 265
vec3 normal(vec3 p)
{
	return normalize(vec3(
    	map(p + E.xyy) - map(p - E.xyy),
    	map(p + E.yxy) - map(p - E.yxy),
    	map(p + E.yyx) - map(p - E.yyx)
    ));
}

// Function 266
vec4 castRay(vec3 ro , vec3 rd,float imax){
    
    float i = 0.002;
    vec2 dat;
    
    for(int n = 0; n < 256; n++){
        
        dat.xy = map(ro+rd*i);
        
        if(dat.x < 0.002)return vec4(ro+rd*i,dat.y);
        
        if(i > imax)return vec4(ro+rd*i,-1.1);
        
        i+=max(abs(dat.x),0.002);
    }
    
    return vec4(ro+rd*i,-1.1);
}

// Function 267
vec3 calcNormal( in vec3 pos ) {
    vec3 eps = vec3( 0.01, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
}

// Function 268
vec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){
    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;
	return normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 269
vec3 getNormal(vec3 p) {
	float d = sceneDist(p);
    
    //just a helper variable
    vec2 e = vec2(.01, 0);
    
    //shift the point by a small
    //amount along each axis
    vec3 n = d - vec3(
        sceneDist(p - e.xyy),
        sceneDist(p - e.yxy),
        sceneDist(p - e.yyx)
    );
    
    return normalize(n);
}

// Function 270
float DistRay(ray r, vec3 p) {
    return length(p-ClosestPoint(r,p));
}

// Function 271
int Reflection(vec3 p, vec3 L,vec3 N, out float t)
{
    Ray reflR;
    int reflHit = 0;
    reflR.Direction = reflect(L,N);
    reflR.Orgin = p + reflR.Direction * 0.1;
    t = Trace(reflR, reflHit);
    return reflHit;
}

// Function 272
float raymarcher( in vec3 ro, in vec3 rd )
{
	const float maxd = 50.0;
	const float precis = 0.01;
    float h = precis*2.0;
    float t = 0.0;
	float res = -1.0;
    for( int i=0; i<100; i++ )
    {
        if( h<precis||t>maxd ) break;
	    h = scene( ro+rd*t );
        t += h * 1.0;
    }

    if( t<maxd ) res = t;
    return res;
}

// Function 273
vec3 raymarch(vec3 ro, vec3 rd) {
    float rl = PHI;
    vec2 sdmat = vec2(0.0);
    
    for (int i = 0; i < MAX_ITER; i++) {
        vec3 p = ro + rl * rd;
        sdmat = sdmat_scene(p);
        if (sdmat.x < PHI) { break; }
        rl += sdmat.x;
        if (rl >= MAX_DEPTH) { break; }
    }
    
    return vec3(rl, sdmat);
}

// Function 274
vec3 normal(vec3 p)
{
	float m = map(p).x;
	vec2 e = vec2(0,.05);
	return normalize(m-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));
}

// Function 275
mat4 reflection(vec4 n) {
  float k = 2.0/dot(n,n);
  return mat4(1)-k*mat4(n.x*n, n.y*n, n.z*n, n.w*n);
}

// Function 276
TriangleHit rayTriHit(vec3 origin, vec3 dir, uvec3 indices) {
	vec3 v1 = icoVec(indices.x);
    vec3 v2 = icoVec(indices.y);
    vec3 v3 = icoVec(indices.z);
    
    vec3 d12 = v2 - v1;
    vec3 d13 = v3 - v1;
    
    vec3 h = cross(dir, d13);
    float a = dot(d12, h);
    float f = 1.0 / a;
    
    vec3 s = origin - v1;
    float u = dot(s, h) * f;
    vec3 q = cross(s, d12);
    float v = dot(dir, q) * f;
    float w = 1.0 - u - v;
    float t = dot(d13, q) * f;
    
    if (t >= 0.0001 && u >= 0.0 && u < 1.0 && v >= 0.0 && w > 0.0) {
    	TriangleHit hit;
        hit.t = t;
        hit.bary = vec3(u, v, w);
        hit.normal = normalize(cross(d12, d13));
        return hit;
    }

    return noHit;
}

// Function 277
vec3 GetNormal (vec3 p) 
{ 
    vec2 e = vec2(0.01, 0.0); 
    return normalize(vec3(
        map(p+e.xyy)-map(p-e.xyy),
        map(p+e.yxy)-map(p-e.yxy),
        map(p+e.yyx)-map(p-e.yyx)
        )); 
}

// Function 278
SDFRes castRay(in vec3 ro, in vec3 rd, in float tmin)
{    
    float tmax = 20.0;    
    
    SDFRes p;
    p.d = tmin;
    p.m = 0.0;
    p.m2 = 0.0;
    p.b = 0.0;
    
	float precis = 0.000001;
    
    for (int i=0; i<50; i++)
    {
        SDFRes s = map( ro + rd * p.d );
        if (s.d < precis || s.d > tmax)
        {
            break;
        }
        
        p.m = s.m;
        p.m2 = s.m2;
        p.b = s.b;
        p.d += s.d;
    }
    
    if (p.d > tmax)
        p.m = -1.0;
    
    return p;
}

// Function 279
Ray castPrimaryRay(in vec2 fragCoord)
{
    float t = 0.0; // + 0.5 * iTime;
    float cd = 20.0;
    vec3 viewPoint = vec3(0.0, 10.0, 0.0);
	vec3 cameraPosition = viewPoint + vec3(cd * sin(t), 0.0, cd * cos(t));
    
    vec3 d = normalize(viewPoint - cameraPosition);
    vec3 u = vec3(0.0, 1.0, 0.0);
    vec3 s = cross(d, u);
    u = cross(s, d);
    
	vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;
    return makeRay(cameraPosition, normalize(uv.x * s + uv.y * u + d));
}

// Function 280
vec3 Normal(vec3 p)
{
    vec2 offs = vec2(eps,0);
    float c = Map(p);
    return normalize(vec3(
        Map(p+offs.xyy) - c,
        Map(p+offs.yxy) - c,
        Map(p+offs.yyx) - c
    ));
}

// Function 281
vec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {
    vec2 m = vec2(-1.0, -1.0);
    vec2 res = vec2(tmin, -1.0);
    res.x = tmin;
	for( int i=0; i<NUM_STEPS; i++ )
	{
        m = map(ro + res.x*rd);
		if( m.x<tmin || res.x>tmax ) break;
		res.x += m.x;
        res.y = m.y;
	}
    if( res.x>tmax ) res.y=-1.0;
	return res;
}

// Function 282
vec3 GetReflection(vec3 rayDir)
{
	vec3 tex = texture(iChannel1, -rayDir).xyz;
	return(tex*tex);
}

// Function 283
bool rayMarchSolids(vec3 startPos, vec3 direction, out float rayDist) {
    vec3 position = startPos ;
    bool intersected = false ;
    rayDist = 0.0 ;
    float delta = minPrimStepSize ;
    float precis = 0.0005 ;
    
    for (int i = 0 ; i < primNumSamples ; ++i) {
		if (isIntersectingRocket(position,precis,delta)) {
            return true ;
        } else {
            precis = 0.0005 * rayDist ;
		    rayDist += delta ;
            position = (rayDist)*direction + startPos ;
        }
    }
    
    return false ;
}

// Function 284
vec3 wrecked_normals(vec3 p) {
    // normals epsilons are way overshot, this is what gives the ocean smoothness
    const vec2 e = vec2(0.3,0.0);
    return normalize(scene(p)-vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx)));
}

// Function 285
float castRay(vec3 ro,vec3 rd) 
{
    float precis=.0001;
    float h=precis*2.;
    float t=0.;
	for(int i=0;i<100;i++) //*************************************
	{
        if(abs(h)<precis||t>12.) break;
		h=map(ro+rd*t);
        t+=h;
	}
    return t;
}

// Function 286
float castRay( in vec3 ro, in vec3 rd, in float tmin)
{
    float tmax = 10.0;   
#if 1
    float maxY = 3.0;
    float minY = -1.0;
    // bounding volume
    float tp1 = (minY-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (maxY-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>maxY ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif    
    float t = tmin;
    for( int i=0; i<100; i++ )
    {
	    float precis = 0.0005*t;
	    float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }
    if( t>tmax ) return -1.;
    return t;
}

// Function 287
vec3 normal(vec3 p){
    vec3 e = vec3(0, 1,-1)*MIN_DIST;
    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));
}

// Function 288
bool RayMarch(
	const in Ray r, 
	const float startT, const float endT, 
	const float stp, 
	const int N,
	out float t, out float v, out int i)
{
	float t0=startT;
	t=t0;
	v=Value(r.p+r.d*t);

	if(v<0.)
		return true;

	i=0;
	for(int j=0;j<1;j+=0)
	{
		t+=max(v*.85, stp);
		float v1=Value(r.p+r.d*t);
		if(v1<0.)
		{
			// Linear interpolation between two last steps
			t=t0+(t-t0)*v/(v-v1);
			v=Value(r.p+r.d*t);
			return true;
		}
		if(t>endT)
			return false;
		i++;
		if(i>N)
			return false;
		v=v1;
		t0=t;
	}
	return false;
}

// Function 289
vec3 calc_normal(vec3 v){
  	float e=0.0001;
  	vec3 n=vec3(
    map(vec3(v.x+e,v.y,v.z))-map(vec3(v.x-e,v.y,v.z)),
    map(vec3(v.x,v.y+e,v.z))-map(vec3(v.x,v.y-e,v.z)),
    map(vec3(v.x,v.y,v.z+e))-map(vec3(v.x,v.y,v.z-e)));
  	return normalize(n);
}

// Function 290
float IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out float distFromSphere, out vec3 intersectA2, out vec3 intersectB2)
{
	// Use dot product along line to find closest point on line
	vec3 eyeVec2 = normalize(posB-posA);
	float dp = dot(eyeVec2, pos - posA);
	vec3 pointOnLine = eyeVec2 * dp + posA;
	// Clamp that point to line end points if outside
	//if ((dp - radius) < 0) pointOnLine = posA;
	//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;
	// Distance formula from that point to sphere center, compare with radius.
	float distance = length(pointOnLine - pos);
	float ac = radius*radius - distance*distance;
	float rightLen = 0.0;
	if (ac >= 0.0) rightLen = sqrt(ac);
	intersectA2 = pointOnLine - eyeVec2 * rightLen;
	intersectB2 = pointOnLine + eyeVec2 * rightLen;
	distFromSphere = distance - radius;
	if (distance <= radius) return 1.0;
	return 0.0;
}

// Function 291
Ray ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.,1.); }

// Function 292
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.0005;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + 
					  e.yyx*map( pos + e.yyx*eps ) + 
					  e.yxy*map( pos + e.yxy*eps ) + 
					  e.xxx*map( pos + e.xxx*eps ) );
}

// Function 293
bool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {
    bool hitResult = false;
    float t;
    SurfaceHitInfo currentHit;

    //Convert ray to object space
    Ray rayLocal;
    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );

    if( obj.type_ == OBJ_PLANE ) {
        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_SPHERE ) {
        hitResult = raySphereIntersection( 	rayLocal, obj.params_[1], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_CYLINDER ) {
        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_AABB ) {
        float t1;
        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );
    }

    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {
        //Convert results to world space
        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );

        dist = t;
        hit = currentHit;
        hit.material_id_ = obj.mtl_id_;

        if( dot( ray.dir, hit.normal_ ) > 0.0 )
            hit.normal_ *= -1.0;
        
        return true;
    }
    
    return false;
}

// Function 294
vec4 ray_march_vol(vec3 p, vec3 r)
{
    vec4 color = vec4(0., 0., 0., 0.);
    vec4 background = vec4(0.1);
    for(int i = 0; i < 90; i++)
    {
        vec3 tcolor = COL(p);
        float density = length(tcolor);
        float noise  =(1.+0.5*rand());
        float d = 4.*DX*exp(-2.*min(density,2.))*noise;
        float opacity = 1.-exp(-OPACITY*density*d);
        float newa = max(color.w + (1. - color.w)*opacity,0.0001);
        color.xyz = (color.xyz*color.w + (1.-color.w)*opacity*tcolor)/newa;
        color.w = newa;
        if(1. - newa < 0.02) break;
        p += r*d;
    }
    return background + color;
}

// Function 295
bool rayConeIntersection( in Ray r, in float radius, in float radius2, in float height1, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    float height = (height1 * radius) / (radius - radius2);
    float k = radius / height;
    k = k * k;
    
    float a = r.dir.x * r.dir.x + r.dir.y * r.dir.y - k * r.dir.z * r.dir.z;
    float b = 2.0 * (r.dir.x * r.origin.x + r.dir.y * r.origin.y - k * r.dir.z * (r.origin.z - height));
    float c = r.origin.x * r.origin.x + r.origin.y * r.origin.y - k * (r.origin.z - height) * (r.origin.z - height);
    
	// Compute quadratic cone coefficients
	// Solve quadratic equation for _t_ values
	float t0, t1;
    if (!solveQuadratic( a, b, c, t0, t1) || ( t1 < 0.0 )){
		return false;
    } else {
        vec3 p;
        vec3 p0 = r.origin + r.dir * t0;
        vec3 p1 = r.origin + r.dir * t1;
        
        bool t0_is_valid = (t0 > 0.0) && (p0.z > 0.0) && (p0.z < height1);
        bool t1_is_valid = (t1 > 0.0) && (p1.z > 0.0) && (p1.z < height1);
        
        if(!t0_is_valid && !t1_is_valid) {
            return false;
        } else {
            t = mix(t1, t0, float(t0_is_valid));
            
            if( !forShadowTest ) {	
            	p = mix(p1, p0, vec3(t0_is_valid));
                float phi = atan(p.y,p.x) + PI;
                isect.position_ = p;
                isect.uv_.x = (phi)/TWO_PI;
                isect.uv_.y = (p.z)/(height1);
                isect.normal_ = normalize( vec3( p.xy, 0.0 ) );
                isect.tangent_ = orthogonalize(isect.normal_, vec3( 0.0, 0.0, 1.0 ));
            }

        	return true;
        }
    }
}

// Function 296
vec3 ray_at(ray_t ray,float t) {
	return ray.C+t*ray.D;
}

// Function 297
float RayMarch(vec3 ro, vec3 rd){
    // distance from origin
    float dO=0.;
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO*rd;
        
        // get distance to seam
        float ds = GetDist(p);
        //move origin to new point
        dO+=ds;
        if(ds < SURFACE_DIST || dO > MAX_DIST){
            break;
        }
    }
    return dO;
}

// Function 298
vec3 castRay(in vec3 ro, in vec3 rd)
{
    const float maxt = MAX_DIST;
    const float delt = MAX_DIST / 1000.0;
    
    for(float t = 0.0; t < MAX_DIST; t += delt)
    {
        vec3 p = ro + rd*maxt*pow(t/maxt, 1.5);
        
        if (p.y < f(p.x, p.z)) {
            return p;
        }
    }
    
    return ro + rd*maxt;
}

// Function 299
vec3 NormalMapTex( vec2 uv )
{
	float eps = -1.0 / 256.0;        
    float a = texture( iChannel2, uv + vec2( 0.0, 0.0 ) ).x;
	float b = texture( iChannel2, uv + vec2( eps, 0.0 ) ).x;
    float c = texture( iChannel2, uv + vec2( 0.0, eps ) ).x;
	return -normalize( vec3( b - a, 0.25, c - a ) );
}

// Function 300
vec3 normal(vec3 p) {
	#define NEPS vec3(EPS,0,0)
	nsampling = 1.;
	vec3 n = normalize(vec3(geometry(p+NEPS),geometry(p+NEPS.yxz),geometry(p+NEPS.yzx))-geometry(p));
	nsampling = 0.;
	return n!=n?vec3(0,1,0):n;
}

// Function 301
vec3 calculateNormals(vec3 pos)
{
	vec2 eps = vec2(0.0, EPSILON*1.0);
	vec3 n = normalize(vec3(
	distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),
	distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),
	distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));
    
	return n;
}

// Function 302
Ray refract_ray(in Ray R, in Intersection I, in float n1, in float n2) {
    return Ray(I.P, refract(normalize(R.Dir), I.N, n1/n2));
}

// Function 303
Primitive processRayIntersect(vec3 rayOr, vec3 rayDir,inout Primitive prims[NUM_PRIMS], float smoothVal) {
     
    minLen = FAR+1.; //initialize minLen to the farthest possible distance   
    prim = nope;   //no object has been intersected yet
    
       float tl; 
    for(int i=1;i<NUM_PRIMS;i++) { //for every primitive in prims
       
    	prims[i].id = float(i);
        getSphereIntersec(prims[i], rayOr, rayDir, smoothVal); //process sphere-ray intersection
        tl = distance(rayOr, prims[i].intersecPoint);	//get distance from the ray origin to the intersection point
        minLen = prims[i].isIntersected&&tl<=minLen?tl:minLen; //if the current primitive was intersected, and t1 is less than minLen, 
																//set minLen as t1
        
        if(tl==minLen) {	//if minLen is same as t1
            prim = prims[i];	//this is the first primitive the ray has encountered
        }
    }
    
    getPlaneIntersec(prims[0], rayOr ,rayDir); // process plane-ray intersection
    tl = distance(rayOr, prims[0].intersecPoint); // distance from ray origin to point of intersection on plane
    minLen = prims[0].isIntersected&&tl<=minLen?tl:minLen; //if the plane has been intersected and if t1 is less than minLen
															// then set t1 as minLen
        
    if(tl==minLen) {    //if t1 is minLen
        prim = prims[0]; //the object that is interected first is the plane

    }
    return prim; //return the primitive that was that is first intersected by the ray
    
   
    }

// Function 304
bool raySphereIntersect(vec3 rayDirection, vec3 sphere, float radius, out vec2 hit) {
	hit = vec2(0.0);
    
	float b = dot(sphere, rayDirection);
	float c = dot(sphere, sphere) - radius * radius;
	
	float d = b * b - c;

    //if (dot(rayDirection, normalize(sphere)) > 1.0) return false;

	if (d < 0.0) {
        return false;
	}
    
	d = sqrt(d);
	
	hit = vec2(-b - d, -b + d);
    return true;
}

// Function 305
vec3 normal(const in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.04;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 306
vec3 boxNormal( vec3 direction, vec3 point, float radius )
{
    vec3 n = point / direction;
    vec3 s = sign(direction);
    vec3 k = s * radius / direction;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    
    return normal;
}

// Function 307
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 200; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 308
Voxel boxNormal( vec3 direction, vec3 point, float radius )
{
    vec3 directionInverse = 1.0 / direction;
    vec3 n = point * directionInverse;
    vec3 s = sign(direction);
    vec3 k = s * radius * directionInverse;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    vec3 normal = -s * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);
    
    float tN = max( max( t1.x, t1.y ), t1.z );
    float tF = min( min( t2.x, t2.y ), t2.z );
	
    bool isHit = tN <= tF && tF >= 0.0;
        
    Voxel voxel;
    voxel.normal = normal;
    voxel.isHit = isHit;
    
    return voxel;
}

// Function 309
vec3 surfaceNormal(vec2 coord, float delta)
{
	float diffX = marquetry(vec2(coord.x+diff, coord.y), delta).r - marquetry(vec2(coord.x-diff, coord.y), delta).r;
	float diffY = marquetry(vec2(coord.x, coord.y+diff), delta).r - marquetry(vec2(coord.x, coord.y-diff), delta).r;
	vec2 localDiff = vec2(diffX, diffY);
	localDiff *= -1.0;
	localDiff = (localDiff/2.0)+.5;
	float localDiffMag = length(localDiff);
	float z = sqrt(max(0.,1.0-pow(localDiffMag, 2.0)));
	return vec3(localDiff, z);
}

// Function 310
vec3 normal(vec3 p) {
	vec3 o = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),
                          map(p+o.yxy) - map(p-o.yxy),
                          map(p+o.yyx) - map(p-o.yyx)));
}

// Function 311
vec3 raymarch(vec3 p, vec3 dir) {
    float contrib = 1.;
    vec3 color = vec3(0., 0., 0.);

    for (int i = 0; i < STEPS; i++) {
        Thing thing = scene(p);

        if (abs(thing.dist) < EPS) {
            vec3 n = normal(p);
            vec3 light_dir = normalize(vec3(0., 1., 0.));

            // Ambient lighting
            color += contrib * (1. - thing.refl) * thing.color;

            contrib *= thing.refl;

            p -= 2. * EPS * dir; // back up a bit

            // Reflection
            dir -= 2. * dot(n, dir) * n;
        }

        p += thing.dist * dir;
    }

    return color;
}

// Function 312
vec4 rayMarch(vec3 rayDir, vec3 cameraOrigin)
{
    const int maxItter = 200;
	const float maxDist = 70.0;
    
    float totalDist = 0.0;
	vec3 pos = cameraOrigin;
	vec3 dist = vec3(epsilon, 0.0, 0.0);
    
    for(int i = 0; i < maxItter; i++)
	{
       	dist = distfunc(pos);
        
		totalDist += dist.x; 
        
		pos += dist.x * rayDir;
        
        if(dist.x < epsilon || totalDist > maxDist)
		{
			break;
		}
	}
    
    return vec4(dist.x, totalDist, dist.y, dist.z);
}

// Function 313
RayTraceResult RayTracePlane(in Ray ray, vec3 pos, vec3 nn)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
	float m = dot(nn, ray.dir);
    if (abs(m) < epsilon)
    {
        return res;
    }
    
    vec3 L = ray.org - pos;
    float d = dot(nn, L);
    float t = -d/m;
    if (t > epsilon)
    {
        res.nn = nn;
        res.pos = ray.org + t*ray.dir;
        res.t = t;
    }
    
    return res;
}

// Function 314
vec3 compute_normal(vec3 pos)
{
    vec3 eps = vec3(0.01, 0.0, 0.0);
    vec3 pos00 = (pos + eps.xyy);
    vec3 pos01 = (pos - eps.xyy);
    vec3 pos10 = (pos + eps.yxy);
    vec3 pos11 = (pos - eps.yxy);
    vec3 pos20 = (pos + eps.yyx);
    vec3 pos21 = (pos - eps.yyx);
	vec3 normal = vec3(intersect(pos00) - intersect(pos01), 
                       intersect(pos10) - intersect(pos11), 
                       intersect(pos20) - intersect(pos21));
	return normalize(normal);
}

// Function 315
vec3 calcNormal( in vec3 pos )
{    
  return normalize( vec3(MapTerrain(pos+eps.xyy) - MapTerrain(pos-eps.xyy), 0.5*2.0*eps.x, MapTerrain(pos+eps.yyx) - MapTerrain(pos-eps.yyx) ) );
}

// Function 316
SRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir, int panel, in vec2 pixelPos)
{
    SRayHitInfo hitInfo;
    hitInfo.dist = c_rayMaxDist;
    
    // get a screen space random number to use for stochastic transparency
    float rng;
    {
        int frame = 0;
        #if ANIMATE_NOISE
            frame = iFrame % 64;
        #endif    
        if ((panel%3) == 0)
        {
            // white noise
            rng = hash13(vec3(pixelPos, float(frame)));
        }
        else if ((panel%3) == 1)    
        {
            // blue noise
            rng = texture(iChannel1, pixelPos / 1024.0f).r;
            rng = fract(rng + c_goldenRatioConjugate * float(frame));
        }
        else // if ((panel%3) == 2)
        {
            // interleaved gradient noise
            rng = InterleavedGradientNoise(pixelPos, frame);
        }
    }

    // the floor
    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))
    {
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        vec2 uv = hitPos.xz / 100.0f;
        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));
        hitInfo.diffuse = vec3(shade, shade, shade);
    }
        
    // some floating spheres
	SRayHitInfo oldHitInfo;
    
    oldHitInfo = hitInfo;
    if (RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f)))
    {
        float alpha = 0.2f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f)))
    {
        float alpha = 0.4f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f)))
    {
        float alpha = 0.6f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f)))
    {
        float alpha = 0.8f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f)))
    {
        float alpha = clamp((sin(float(iFrame % 120) / 120.0f * 2.0f * c_pi) * 0.75f + 0.5f), 0.0f, 1.0f);
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        

    
    return hitInfo;
}

// Function 317
vec3 calcNormal(vec3 p)
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
	return normalize( e.xyy *map(p + e.xyy) + 
					  e.yyx *map(p + e.yyx) + 
					  e.yxy *map(p + e.yxy) + 
				  	  e.xxx *map(p + e.xxx) );
}

// Function 318
vec3 getNormal(vec3 p) {
    float d = EPSILON;
    return normalize(vec3(
        sceneSDF(p + vec3(d, 0.0, 0.0)) - sceneSDF(p),
        sceneSDF(p + vec3(0.0, d, 0.0)) - sceneSDF(p),
        sceneSDF(p + vec3(0.0, 0.0, d)) - sceneSDF(p)
    ));
}

// Function 319
vec3 calcNormal(vec3 pos)
{
    float eps=0.01;
	float d=map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 320
RefractionResult calcRefraction(vec3 v, vec3 normal, float n1, float n2) {
    RefractionResult res;
    
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3  tang = normalize(v - cosA * normal);
    float sinB = sinA / n2 * n1;
    
    if (abs(sinB) > 1.0) {
        res.newDir = reflect(v, normal);
        res.isReflection = true;
        return res;
    }
    
    float cosB = sqrt(1.0 - sinB * sinB);
    
    res.newDir = sinB * tang + cosB * normal;
    return res;
}

// Function 321
vec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )
{
	vec4 sum = vec4( 0.0 );

	float sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );
	float t = 0.0;
	for( int i=0; i<60; i++ )
	{
		if( t>tmax || sum.w>0.95 ) break;//continue;
		vec3 pos = ro + t*rd;
		vec4 col = mapClouds( pos );
		
        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);
		col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );
		
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	

		t += max(0.1,0.05*t);
	}

	sum.xyz /= (0.001+sum.w);

	return clamp( sum, 0.0, 1.0 );
}

// Function 322
ray_ getRay(vec2 pixel, camera_ camera)
{
	vec3 right = cross(camera.front, camera.up);
	vec3 up = cross(right, camera.front);
	float fovScale = tan(camera.fov * 0.5 * 3.1415926535 / 180.0) * 2.0;
	vec2 point = pixel;
	vec3 r = right * point.x * fovScale;
	vec3 u = up * point.y * fovScale;
	return ray_(camera.eye, normalize(camera.front + r + u));
}

// Function 323
vec3 sphNormal(in vec3 pos, in vec4 sph) {
    return normalize(pos - sph.xyz);
}

// Function 324
vec3 getNormal(vec3 p){
    int o;
	return normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o) - distScene(p - vec3(EPSN, 0., 0.), o),
    					  distScene(p + vec3(0., EPSN, 0.), o) - distScene(p - vec3(0., EPSN, 0.), o),
                          distScene(p + vec3(0., 0., EPSN), o) - distScene(p - vec3(0., 0., EPSN), o)));
}

// Function 325
vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	
	float d = b * b - c;
	if ( d < 0.0 ) {
		return vec2( MAX, -MAX );
	}
	d = sqrt( d );
	
	return vec2( -b - d, -b + d );
}

// Function 326
vec3 waterNormal(vec2 p, float eps) {
    vec2 h = vec2(eps, 0.0);
    #define i WATER_NORMAL_ITERATIONS
    return normalize(vec3(heightmap(p - h.xy, i) - heightmap(p + h.xy, i),
                          2.0 * eps,
                          heightmap(p - h.yx, i) - heightmap(p + h.yx, i)));
}

// Function 327
float rayMarch(in float dmod, in vec3 ro, inout vec3 rd, float mint, float minstep, out int rep, out vec3 col, out float ref, out float trans, out vec3 absorb)
{
  float t = mint;
  for (int i = 0; i < MAX_RAY_MARCHES; i++)
  {
    float distance_ = distanceField(ro + rd*t, col, ref, trans, absorb);
    float distance = dmod*distance_;
    if (distance < TOLERANCE*t || t > MAX_RAY_LENGTH) break;
    t += max(distance, minstep);
    rep = i;
  }
  return t;
}

// Function 328
vec3 gray(float t)
{
    return vec3(t);
}

// Function 329
vec3 GetNormal(vec3 p, vec3 ro, float dO) {
	float d = GetDist(p, ro);
    vec2 e = vec2(.005, 0); // ##
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy, ro),
        GetDist(p-e.yxy, ro),
        GetDist(p-e.yyx, ro));
    
    return normalize(n);
}

// Function 330
ray getRefRay(vec3 origin, vec3 normal, vec3 originalDirection) {
    ray ray;
    ray.direction = normalize(reflect(originalDirection, normal));
    ray.origin = origin + ray.direction*OBJECT_MIN_SURFACE_DISTANCE_REFLECTION_OFFSET;
    return ray;   
}

// Function 331
vec4 GenerateNormalHeight (sampler2D tex, vec2 uv, vec2 res, float width)
{
    vec2 texelSize = 1. / (res * width);
    vec4 h;
    h[0] = dot(GrayscaleWeights, texture(tex, uv + vec2(texelSize * vec2( 0,-1)) ).rgb);
    h[1] = dot(GrayscaleWeights, texture(tex, uv + vec2(texelSize * vec2(-1, 0)) ).rgb);
    h[2] = dot(GrayscaleWeights, texture(tex, uv + vec2(texelSize * vec2( 1, 0)) ).rgb);
    h[3] = dot(GrayscaleWeights, texture(tex, uv + vec2(texelSize * vec2( 0, 1)) ).rgb);
    vec3 n;
    n.y = h[0] - h[3];
    n.x = h[1] - h[2];
    n.z = .25;
    float height = dot(GrayscaleWeights, texture(tex, uv).rgb);
    return vec4(normalize(n), height);
}

// Function 332
vec2 toNormalized(vec2 coord, vec2 R) {
    return (coord + coord - R) / R.y;
}

// Function 333
float raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)
{
	float res = 9999.0;
	vec3 oc = ro - center;
	float b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation
	float c = dot(oc,oc)-(radius*radius);
	
	float bminac = (b*b)-c;
	if (bminac >= 0.0)
	{
		//intersection
		float sqrtbminac = sqrt(bminac);
		float t = (-b + multiplier*sqrtbminac);
		res = mix(res,t,step(0.0,t));
 	}
	
	return res;
	
}

// Function 334
float god_ray(float d)
{
    //ligth position in camera plane
    vec3 lp = projection(light*10000.);
    vec2 r = lp.z*normalize(lp.xy - p + vec2(0.001)); 
    float xl = min(screen_max(p, r),distance(lp.xy, p));
    float dx = 1. + (1. + xl*god_ray_step)*InterleavedGradientNoise(p, iFrame);
    float occ = 0.; float esum = 0.001;
    for(float x = 0.; x < xl; x += dx)
    {
        float cd = length(cpos - texel(ch1, ivec2(p + r*x)).yzw);
        occ += mix(1.,(0.5*tanh(0.2*(cd/d - 1.)) + 0.5), exp(-0.5*fog_depth*cd))*dx;
        esum += dx;
    }
    occ /= esum;
    return mix(1., occ*occ, pow(abs(0.5*(ray.z + 1.)),0.5));
}

// Function 335
float rayTetra(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3, vec3 v4){
	float t = rayTriangle(P, w, n, v1, v2, v3);
    vec3 n1;
    float t1 = rayTriangle(P, w, n1, v1, v3, v4);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v2, v4, v3);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v1, v4, v2);
    if(t1 < t) { t = t1; n = n1; }
    return t;
}

// Function 336
vec3 distMapNormal(vec3 p) {
    return normalize(vec3(
        distMap(vec3(p.x+NORMAL_EPILSON,p.y,p.z))-distMap(vec3(p.x-NORMAL_EPILSON,p.y,p.z)),
        
		distMap(vec3(p.x,p.y+NORMAL_EPILSON,p.z))-distMap(vec3(p.x,p.y-NORMAL_EPILSON,p.z)),
        
        distMap(vec3(p.x,p.y,p.z+NORMAL_EPILSON))-distMap(vec3(p.x,p.y,p.z-NORMAL_EPILSON))
        ));
}

// Function 337
vec3 calcNormal(in vec3 position)
{
    vec3 eps = vec3(0.0001,0.0,0.0);
    vec4 dummyOrbitTrap;

    return normalize( 
        vec3(
        sceneDistanceFunction(position+eps.xyy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.xyy, dummyOrbitTrap),
        sceneDistanceFunction(position+eps.yxy, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yxy, dummyOrbitTrap),
        sceneDistanceFunction(position+eps.yyx, dummyOrbitTrap) - sceneDistanceFunction(position-eps.yyx, dummyOrbitTrap))
    	);
}

// Function 338
float raynextroot(float t) {
    return nextroot(pa_map(pa_init(t)));
}

// Function 339
float phaseRayleigh(float cosViewLight)
{
    return (1.0 + cosViewLight * cosViewLight) * rayleighConstant;
}

// Function 340
vec3 normalPlane(in vec3 pos)
{
	// normal of plane
    return vec3(0.0, 1.0, 0.0);
}

// Function 341
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 342
Trace traceRay(in Ray ray, float maxDistance) {
    Trace trace = castRay(ray,maxDistance);
    trace.normal = calculateNormal(trace.p);
    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));

    return trace;
}

// Function 343
vec3 raymarch(in vec3 orig, in vec3 dir) {
	float result = 0.0;
    vec3 p = orig;
    for (int i = 0; i < 32; ++i) {
    	float d = torus_sdf(p);
        result = result + d;
        p = p + d * dir;
        if (d < 1.0e-4) {
            return p;
        }
    }
    return p;
}

// Function 344
void marchRay(inout Ray ray, inout vec4 colour, inout int steps, in int maxSteps) {
    bool inside = false; // are we inside or outside the glass object
    vec4 impact = vec4(1.0); // This decreases each time the ray passes through glass, darkening colours
    bool hit = false;
#ifdef DEBUG   
vec4 debugColour = vec4(1, 0, 0, 1);
#endif
    for (int i=0; i<kMAXITERS; i++) {
        // Get distance to nearest surface
        float d = sceneDist(ray);
        
        // Step half that distance along ray (helps reduce artefacts)
        ray.origin += ray.dir * abs(d);  
        
        if (abs(d) < kEPSILON) {
            // colision
    
            hit = true;
            /*
            if ( ray.origin.y < kEPSILON ) {
                // ray hit floor
                impact *= vec4(0.6,0.6,0.6,1.0);
                ray.dir = reflect(ray.dir, vec3(0,1,0));
            	// Intersection count inc, break if over limit else next iteration
                if (nextStepIsFinal(steps, maxSteps)) { break; } else { continue; }
            }
            */
            // Get the normal, then clamp the intersection to the surface
    		vec3 n = normal(ray);
            clampToSurface(ray, d, n);
#ifdef DEBUG
debugColour.rgb = n;
//break;
#endif
            
            if (inside) {
                // refract glass -> air
            	ray.dir = refract(-n, -ray.dir, 1.0/kREFRACT);
            	impact *= vec4(0.4, 0.5, 0.9, 1.0);
          
                
            } else {
                // refract air -> glass
                // Calulcate a fresnel term for reflections
                float fresnel = min(1., dot(ray.dir, n) + 1.0);
       			fresnel = pow(fresnel, 2.);
                
                // Mix the reflection in, according to the fresnel term
    			colour = mix(
                    colour, 
                    texture(iChannel1, reflect(ray.dir, n) * kFLIPY), 
                    vec4(fresnel) * impact);
    			
                // refract the ray
            	ray.dir = refract(ray.dir, n, kREFRACT);
            }
            
            // Intersection count inc, break if over limit
            if (nextStepIsFinal(steps, maxSteps)) { break; }
            
            // Step 2x epsilon into object along normal to ensure we're beyond the surface
            // (prevents multiple intersections with same surface)
            ray.origin += (inside ? n : -n) * kEPSILON * 2.0;
            
            // Flip in/out status
            inside = !inside;
        }
    }
    
    // So far we've traced the ray and accumulated reflections, now we need to add the background.
    colour += texture(iChannel0, ray.dir * kFLIPY) * impact;// / float(steps+1);
#ifdef DEBUG
colour = debugColour;
//colour.rgb = vec3(float(steps)/8.);
//colour.rgb = ray.dir;
#endif
}

// Function 345
vec2 refraction(vec2 n, vec2 d, float r ) {
	// well I just realised after I posted this, that GLSL already has a 
    // refract function. :P. That will teach me to RTFM first...
    // I will just leave this here for reference...
    
    //float c = dot(-n, d);
	//return r*d + (r*c - sqrt(1.-(r*r) * (1.-(c*c)))) * n;
    return refract(d,n,r);
}

// Function 346
vec3 getRay(vec2 angles, vec2 pos)
{
    mat3 camera = getCamera(angles);
    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));
}

// Function 347
vec3 interpolateNormals(vec3 a, vec3 b, float c
){;return normalize(mix(a,b,vec3(smoothstep(0.,1.,c))));}

// Function 348
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    //Texture of white and black in image
    vec2 e = vec2(.001, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    
    return normalize(n);
}

// Function 349
Ray Camera_GetRay(in Camera camera, vec2 uv)
{
    Ray ray;
    
    uv    = (uv * 2.0) - 1.0;
    uv.x *= (iResolution.x / iResolution.y);
    
    ray.origin    = camera.origin;
    ray.direction = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5));

    return ray;
}

// Function 350
vec3 CameraRay(vec2 fragCoord, float n) {
    float a = 1.0/max(iResolution.x, iResolution.y);
    
    return normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));
}

// Function 351
vec3 normal(vec3 sp)
{
    vec3 eps = vec3(.0001, 0.0, 0.0);
    
    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)
                       ,map(sp+eps.yxz) - map(sp-eps.yxz)
                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));
    
    
 return normal;   
}

// Function 352
float point2rayDistSq(vec3 p, vec3 ray) {
    vec3 dd = p - dot(p, ray) / dot(ray, ray) * ray;
    return dot(dd, dd);
}

// Function 353
vec3 calcNormal(vec3 pos)
{
    float eps=0.0001;
	float d=map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 354
vec3 getNormal(vec3 pos, float e)
{
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),
                          map(pos + q.xyx) - map(pos - q.xyx),
                          map(pos + q.xxy) - map(pos - q.xxy)));
}

// Function 355
vec2 rayMarch(vec3 ro, vec3 rd)
{
    float t = 0.0;
    vec3 p;
    vec2 obj;
    for (int i = 0; i < MAX_STEPS; i++)
    {
        p = ro + t * rd;
       	
        obj = map(p);
        
        if (obj.x < SURFACE_DIST || t > MAX_DIST) break;
        
        t += obj.x;
    }
    
    obj.x = t;
    return obj;
}

// Function 356
float RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )
{
    //Variation of the Distance Field Soft Shadow from : https://www.shadertoy.com/view/Xds3zN
    //Initialize the minimum aperture (angle tan) allowable with this distance-field technique
    //(45deg: sin/cos = 1:1)
    float minAperture = 1.0; 
    float t = 0.0;
    float dist = GEO_MAX_DIST;
    for( int i=0; i<6; i++ )
    {
        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance
        float dist = map( p ).d;
        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)
        minAperture = min(minAperture,curAperture);
        t += 0.03+dist; //0.03 : min step size.
    }
    
    //The cone width controls shadow transition. The narrower, the sharper the shadow.
    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.
}

// Function 357
vec3 ringArray(vec2 cm, float w){
	return(vec3(step(.5,fract(length(cm)*2.0/(5.0)/w))));
}

// Function 358
vec3 createnormal(vec3 p) {
  float e = 0.001;
  return normalize( vec3(
    sdf( vec3(p.x+e,p.y,p.z) ) - sdf( vec3(p.x-e,p.y,p.z) ) ,
    sdf( vec3(p.x,p.y+e,p.z) ) - sdf( vec3(p.x,p.y-e,p.z) ) ,
    sdf( vec3(p.x,p.y,p.z+e) ) - sdf( vec3(p.x,p.y,p.z-e) )
  ));
}

// Function 359
vec3 calcNormal( in vec3 pos )
{
    // epsilon = a small number
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0002;
    
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 360
float castRay( in vec3 ro, in vec3 rd, float tmax)
{
    float tmin = 1.0;
    
    float t = tmin;
    float precis = 0.0005;
    for( int i=0; i<64; i++ )
    {
        float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }
    return t;
}

// Function 361
vec3 calcRocketNormal( in vec3 pos ) {
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*sampleRocketCCy( pos + e.xyy ) + 
					  e.yyx*sampleRocketCCy( pos + e.yyx ) + 
					  e.yxy*sampleRocketCCy( pos + e.yxy ) + 
					  e.xxx*sampleRocketCCy( pos + e.xxx ));
}

// Function 362
vec3 calcNormal( in vec3 pos ){

    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
}

// Function 363
vec3 normal(vec3 p) {
    vec2 e = vec2(.001,0.);
    return normalize(vec3(
        world(p+e.xyy) - world(p-e.xyy),
        world(p+e.yxy) - world(p-e.yxy),
        world(p+e.yyx) - world(p-e.yyx)));
}

// Function 364
float castRay( in vec3 ro, in vec3 rd ,out vec2 uv)
{
    float res = -0.0;

    float tmin = 1.0;
    float tmax = 20.0;

    //floor plane
    float tp1 = (-1.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = tp1;
    } 
    
    //sky
    tp1 = (10.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = tp1;
    } 
    
    // raymarch primitives   
    {
        tmin = 1.;
        tmax = 30.;
        float t = tmin;
        for( int i=0; i<100 ; i++ )
        {
            if(t>=tmax) break;
            vec2 uvT;
            float h = map( ro+rd*t ,rd,uvT);
            uv = uvT;
            if( h<0.0001 )
            { 
                //uv = uvT;
                res = t; 
                break;
            }
			t += h;
        }
    }
     
    return res;
}

// Function 365
traceData catchRay(ray newRay){
    traceData notrace;
    return notrace;
}

// Function 366
vec3 castRay(in vec3 ro, in vec3 rd)
{
    /*
    float stp_loc = stp;
    
    float dd = dMin;
    
    for(float d = dMin; d < dMax; d += stp)
    {
        vec3 pos = ro + dd * rd;
        if(pos.z < terrainHeight(pos.xy))
        {
            return terrainColor(ro, rd, dd - stp * 0.5);
        }
        
        dd += stp_loc;
        stp_loc += stp / 10.0;
    }
	*/
    
    float t = -ro.z/rd.z;
    if(t > 0.0)
        return terrainColor(ro, rd, -t);
    
    return skyColor(ro, rd);
}

// Function 367
vec3 camera_ray(vec3 vo, vec2 uv, vec2 muv, float iTime)
{
    vec3 vd = normalize(vec3(uv,1));
    
    //Add Mouse rotation
    vec4 cs = vec4(cos(muv),sin(muv));
    vd.yz = mat2(cs.y,cs.w,-cs.w,cs.y)*vd.yz;
    vd.xz = mat2(cs.x,cs.z,-cs.z,cs.x)*vd.xz;
    //Add Water bobbing
    vec2 ang = norm(vo.xz,5, iTime).xz*-.05*PI;
    cs = vec4(cos(ang),sin(ang));
    vd.xy = mat2(cs.x,cs.z,-cs.z,cs.x)*vd.xy;
    vd.zy = mat2(cs.y,cs.w,-cs.w,cs.y)*vd.zy;    
    return vd;
}

// Function 368
vec3 reflection(vec3 pos, vec3 ref)
{
    //ref = normalize(ref);
    
    pos += ref * MIN_DST * 4.0;
    float d = castRay(pos, ref, MAX_DST, MIN_DST);
    
    //vec3 nPos = pos + ref * d.x;

    
    if (d > MAX_DST)
    {
        return textureLod(iChannel1, ref, 4.0).rgb;
    }
    else   
    {
   
        vec3 col = vec3(1.0, 0.0, 0.0);
        
        vec3 pointDir = lightPos - pos;
        float len = length(pointDir);
        
        float atten = sat(1.0 - len / 20.0);
        
        pointDir /= len;
        float lambertPoint = 0.0;
        
        vec3 n = calcNormal(pos);
        
       // float shadow = shadow(pos, n, lightPos); 
        
        lambertPoint = sat(dot(n, pointDir));
        
        lambertPoint *= /*shadow */ atten; 
        
        vec3 refl = reflect(ref, n);
        //float specular =  sat(dot(pointDir, refl));
        
        //specular = specular * specular * shadow * atten;

        vec3 diffuseCol = vec3(lambertPoint);
        
        //vec3 specularCol = vec3(specular);
        
        col =  diffuseCol;// + specularCol;
        
        float dst = 1.0 - sat(SDF(pos + n * 0.5) * 1.0);

        col *= vec3((1.0 - dst * dst) * 0.7 + 0.3); // Fake AO
        
        float fresnel = pow(1.0 - abs(dot(n, ref)), 1.0);
        
        //col += reflection(pos, ref, lightPos)
        
        col += textureLod(iChannel1, n, 4.0).rgb * fresnel;
        
        
        
        return col;
    }
}

// Function 369
vec3 calcNormalForTriangle(vec3 a, vec3 b, vec3 c)
{
    vec3 dir = cross(b - a, c - a);
	vec3 normal = normalize(dir);
    return normal;
}

// Function 370
vec3 getNormalHex(vec3 pos)
{
	float d=map(pos).dist;
	return normalize(
        vec3(
            map(
                pos+vec3(EPSILON,0,0)).dist-d,
                map(pos+vec3(0,EPSILON,0)).dist-d,
                map(pos+vec3(0,0,EPSILON)).dist-d 
        	)
    	);
}

// Function 371
vec3 normal(vec3 p) {
    const vec2 NE = vec2(MIN_EPSILON, 0.);
    return normalize(vec3(scene(p+NE.xyy,MIN_EPSILON).x-scene(p-NE.xyy,MIN_EPSILON).x,
                          scene(p+NE.yxy,MIN_EPSILON).x-scene(p-NE.yxy,MIN_EPSILON).x,
                          scene(p+NE.yyx,MIN_EPSILON).x-scene(p-NE.yyx,MIN_EPSILON).x));
}

// Function 372
vec3 computeNormal( vec3 p )
{
    vec2 epsilon = vec2(0.01,0.0);
     
    float deltaX = map(p+epsilon.xyy).distance - map(p-epsilon.xyy).distance;
    float deltaY = map(p+epsilon.yxy).distance - map(p-epsilon.yxy).distance;
    float deltaZ = map(p+epsilon.yyx).distance - map(p-epsilon.yyx).distance;
    
    return normalize(vec3(deltaX,deltaY,deltaZ));
}

// Function 373
vec3 normal(vec3 p)
{
 	vec3 P = vec3(-4, 4, 0) * PRE;

 	vec3 N = normalize(model(p+P.xyy)*P.xyy+model(p+P.yxy)*P.yxy+
                  model(p+P.yyx)*P.yyx+model(p+P.xxx)*P.xxx);
    
    vec3 B = vec3(t3(iChannel0,p+P.xzz,N).r,t3(iChannel0,p+P.zxz,N).r,
                  t3(iChannel0,p+P.zzx,N).r)-t3(iChannel0,p,N).r;
    B = (B-N*dot(B,N));
    return normalize(N+B*8.0);
}

// Function 374
vec4 GetNormal(vec3 u//4tap derivative
){vec2 e=vec2(.003,0.)
 ;float o=map(u,-1)
 ;return vec4(normalize(vec3(map(u+e.xyy,-1)
                            ,map(u+e.yxy,-1)
                            ,map(u+e.yyx,-1))-o),o);}

// Function 375
vec3 normal(vec3 p) {
	vec2 e = vec2(0.0, Detail);
    return -normalize(vec3(
        map(p-e.yxx)-map(p+e.yxx),
        map(p-e.xyx)-map(p+e.xyx),
        map(p-e.xxy)-map(p+e.xxy)
    ));
}

// Function 376
vec3 get_ray(vec3 lookfrom, vec3 lookat, float tilt, float vfov, vec2 uv) {
    // camera up vector
    vec3 vup = vec3(sin(tilt), cos(tilt), 0.0);
    // camera look direction
    vec3 lookdir = normalize(lookat - lookfrom);
    // unit vector in camera x axis
    vec3 u = cross(lookdir, vup);
    // unit vector in camera y axis
    vec3 v = cross(u, lookdir);
    // vector in camera z axis normalized by the fov
    vec3 w = lookdir * (1.0 / tan(vfov*PI/360.0));
    // camera transformation matrix
    mat3 t = mat3(u, v, w);
    // camera direction
    return normalize(t * vec3(uv, 1.0));
}

// Function 377
float CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )
{
    const float maxd = 5.0;
    
	float h = 0.5;
    float t = 0.0;
   
    for ( int i = 0; i < 50; ++i )
    {
        if ( h < 0.001 || t > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t, localToWorld );
        t += h;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }
	
    return t;
}

// Function 378
vec3 ray_direction(mat3 camera, vec2 pos, float lens)
{
    return normalize(camera * vec3(pos, lens));
}

// Function 379
void surface2x3_ortho_ray(in surface2x3 surf, vec2 p,
	out surface2x1 slice) {
	float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
	float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];
	float G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];
    float J = surf.c[9];
    
    slice[0] = C;
    slice[1] = E*p.x + F*p.y + I;
    slice[2] = (A*p.x + G)*p.x + (D*p.x + B*p.y + H)*p.y + J;
}

// Function 380
vec4 castRay(vec3 pos, vec3 dir, float maxDst, float worldAngle)
{
    // we assume we are traversing space facing Z
    
    vec3 dirZ = dir / dir.z; // direction vector that adavance a full cell along Z
    
    vec3 cell = floor(pos); // starting cell
    
    vec3 start = pos; // saves the start of the ray
    pos -= fract(pos.z) * dirZ; // pulls back pos on the closes cell boundary behind
   

    float d = 0.0;
    float dst;
    
    vec2 layers[20];
    int num = 0;

    float coverage;
    float opacity = 1.0;

    while (d < MAX_DST)
    {
		// Check current cell
        dst = castPlanet(cell, start, dir, coverage);
        if (dst < MAX_DST)
        {
            // Blends the hit planet behind the previous ones according to coverage
            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + dst * dir, dst, dir, worldAngle, coverage));
            layers[num++] = vec2(dst, coverage);
            opacity *= (1.0 - coverage);
            if (opacity < 0.01) break;
        }
        
        // Advances a step
        pos += dirZ;
        
        //Compute next cell on y
        vec3 newCell = floor(pos);
        
        bool a = false;
        bool b = false;
        float cornerDst = MAX_DST;
        
 		
        if (cell.x != newCell.x) // have we crossed a cell diagonally on X ?
        {
            vec3 stepCell = vec3(newCell.x, cell.yz);

            dst = castPlanet(stepCell, start, dir, coverage);
        	if (dst < cornerDst) cornerDst = dst;
            a == true;
        }
        
        if (cell.y != newCell.y)  // have we crossed a cell diagonally on Y ?
        {
            vec3 stepCell = vec3(cell.x, newCell.y, cell.z);

            dst = castPlanet(stepCell, start, dir, coverage);
        	if (dst < cornerDst) cornerDst = dst;
            b == true;
        }
        
        if (a && b)  // have we crossed a cell diagonally on both X & Y?
        {
            vec3 stepCell = vec3(cell.xy, cell.z);

            dst = castPlanet(stepCell, start, dir, coverage);
        	if (dst < cornerDst) cornerDst = dst;
        }
        
        if (cornerDst < MAX_DST) // We have hit a planet in a corner intersection
        {
            // Blends the hit planet behind the previous ones according to coverage
            //ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + cornerDst * dir, cornerDst, dir, worldAngle, coverage));
            //if (ColorFTB.a > 0.99) return ColorFTB;
            
            layers[num++] = vec2(cornerDst, coverage);
            opacity *= (1.0 - coverage);
            if (opacity < 0.01) break;
        }
        
        
       	// rinse / repeat
        cell = newCell;
        d += 1.0;
    }
    
        
    vec4 ColorFTB = vec4(0.0);
    
    for (int i = 0; i < num; i++)
    {
        vec2 layer = layers[i];
        ColorFTB = BlendFTB(ColorFTB, RenderPlanet(start + layer.x * dir, layer.x, dir, worldAngle, layer.y));
    }
    
    return ColorFTB;
}

// Function 381
vec3 calcNormal( in vec3 pos, in float t, in float px )
{
    vec4 tmp;
    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;
    return normalize( e.xyy*map( pos + e.xyy,tmp ) + 
					  e.yyx*map( pos + e.yyx,tmp ) + 
					  e.yxy*map( pos + e.yxy,tmp ) + 
					  e.xxx*map( pos + e.xxx,tmp ) );
}

// Function 382
vec3 normal(vec3 p) {
    vec3 eps = vec3(0., det, 0.);
	return normalize(vec3(de(p + eps.yxx), de(p + eps.xyx), de(p + eps.xxy)) - de(p));
}

// Function 383
vec3 getRay_870892966(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {
  mat3 camMat = calcLookAtMatrix_1460171947(origin, target, 0.0);
  return getRay_870892966(camMat, screenPos, lensLength);
}

// Function 384
bool resolveRaySphereIntersection(sphere ball){
	vec3 OC=ball.pos-camera;
	float P=dot(OC,ray);
	if(P<0.) return false;
	float d=sqrt(pow(length(OC),2.0)-pow(P,2.0));
	if(d>ball.size) return false;
	return true;
}

// Function 385
vec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { 
	
    // Roughly two pixel edge spread, but increased slightly with larger resolution.
    vec2 e = vec2(ef/mix(450., iResolution.y, .5), 0);

	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));

      
    // Wider sample spread for the curvature.
    //e = vec2(12./450., 0);
	//d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	//d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	//d5 = map(p + e.yyx), d6 = map(p - e.yyx);
    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
 	 
    
    e = vec2(.0025, 0); //iResolution.y - Depending how you want different resolutions to look.
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 386
vec3 calculate_normal(in vec3 world_point)
{
    const vec3 small_step = vec3(0.001, 0.0, 0.0);

    float gradient_x = map_the_world(world_point + small_step.xyy)
        - map_the_world(world_point - small_step.xyy);
    float gradient_y = map_the_world(world_point + small_step.yxy) 
        - map_the_world(world_point - small_step.yxy);
    float gradient_z = map_the_world(world_point + small_step.yyx) 
        - map_the_world(world_point - small_step.yyx);

    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

    return normalize(normal);
}

// Function 387
float raymarch(vec3 ori, vec3 dir) {
    float t = 0.;
    for(int i = 0; i < MAX_ITERATIONS; i++) {
    	float scn = dstScene(ori+dir*t);
        if(scn < EPSILON*t || t > MAX_DISTANCE)
            break;
        t += scn * .75;
    }
    return t;
}

// Function 388
vec3 calcNormal( in vec3 pos )
{
#if 0    
    vec3 eps = vec3(0.002,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*0.002).x;
    }
    return normalize(n);
#endif    
    }

// Function 389
vec2 raymarch(in vec3 origin, in vec3 ray)
{
    float t = 0.0; // t is the clipping plane where anything below this is removed.
    float id = -1.0; // For the Background
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec2 dist = scene(origin + ray * t);
        if (dist.x < EPSILON)
        {
            break; // We are inside the surface.
        }
        // Move along the ray in constant steps
        t += dist.x;
        // Since each element has an ID, we want that there too!
        id = dist.y;

        if (t >= MAX_DIST)
        {
            id = BACKGROUND;
            return vec2(MAX_DIST, id); //We are too far away!
        }
    }
    return vec2(t, id);
}

// Function 390
vec3 calculateRay(vec3 res, vec2 screenPos, 
                  vec3 eye, vec3 look_at, vec3 up) {
	vec2 screen_pos = screenPos.xy / res.xy;
    float aspect = res.y / res.x;
    screen_pos -= 0.5;
    screen_pos.y *= aspect;
    vec3 look_center = normalize(look_at - eye);
    vec3 look_right = cross(up, look_center);
    vec3 look_up = cross(look_center, look_right);
        
	vec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);
    return newRay;
}

// Function 391
float ray(vec3 cp, vec3 rd)
{
    cp += rd * far;
    for(float st =0.; st < 1.; st += 1./sp)
    {
    	float cd = map(cp);
        if(cd < .01)
        {
            return st;
        }
        
        cp -= rd * cd;
    }
    return 1.;
}

// Function 392
float RayleighPhaseFunction(float nu) {
    //return .125;
  float k = 3.0 / (16.0 * PI);
  return k * (1.0 + nu * nu);
}

// Function 393
vec3 normalForSphere(vec3 hit, Sphere s) {   
   return (hit - s.center_radius.xyz) / s.center_radius.w;   
}

// Function 394
vec3 ray(vec3 p, vec3 d){
	
	float dist = 1.0;
	
	for(int i = 0; i < I; i++){
		
		if(dist < MIN)
			return p;
		if(length(p) > MAX)
			return p;
		dist = map(p);
		p += d * dist;
	}
	return vec3(0.0);
}

// Function 395
bool shadowRayIntersect(Ray r, Sphere s[SN], float tmin, float tmax)
{
    for(int i=0;i<SN;++i)
    {
        float t = intersect(r, s[i]);
        if(t>tmin && t<tmax)
        {
            return true;
        }
    }
    return false;
}

// Function 396
float pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;if(t<0.){p=p-(t+t)*n;}return (t<0.)?-1.:1.;}

// Function 397
ray genRay( vec2 ndc ) {
    //camera positioning and allignment
    vec3 cam_pos = vec3(0.0, 1.0, 5.0);
    vec3 cam_tar = vec3(0.0);
    vec3 cam_up = vec3(0.0, 1.0, 0.0);
    
    //cam animation
    cam_pos.y += sin( iTime * 2.0 ) * 0.05;
    cam_tar.y += sin( ( iTime - 0.3 ) * 2.0 ) * 0.05;
    cam_up.z += sin( iTime * 2.0 ) * 0.001;
    
    vec3 cam_dir = normalize(cam_tar - cam_pos);   
    
    //camera space s and t vectors
    vec3 cam_s = normalize(cross(cam_dir, cam_up));
    vec3 cam_t = cross(cam_s, cam_dir);
    
    cam_pos -= cam_s * iTime * 0.2;
    
    //intersection with "film" plane
    vec3 cam_c = cam_pos + cam_dir;
    vec3 cam_i = cam_c + cam_s * ndc.x + cam_t * ndc.y;
    
    //build ray
    ray r;
    r.o = cam_pos;
    r.d = normalize( cam_i - cam_pos );
    return r;
}

// Function 398
vec3 calcNormal( in vec3 pos )
{
    DAValue d = doModel(da_domain(pos));
    return d.xyz;
}

// Function 399
vec2 euclidean_reflection(vec2 p, vec2 a, vec2 b){
    vec2 n = vec2(-(b-a).y, (b-a).x);
    n = normalize(n);
    return p - 2.0*dot(p-a,n)*n;
}

// Function 400
Ray sfCreateRay(vec3 origin, vec3 dir)
{
    Ray r;
    r.origin = origin;
    r.direction = normalize(dir);
    return r;
}

// Function 401
vec3 normal(vec3 p) {
    vec2 h = vec2(0.001, 0.0);
    vec3 n = normalize(vec3(
		de(p + h.xyy) - de(p - h.xyy),
        de(p + h.yxy) - de(p - h.yxy),
        de(p + h.yyx) - de(p - h.yyx)
	));
    
    return n;
}

// Function 402
Ray rayRefract(in Hit h, in float rr) {
  vec3 r = refract(h.ray.dir, h.nml, h.ray.rr/rr);
  if (len2(r)<.001) return rayReflect(h, vec3(1));
  return ray(h.pos - h.nml*.01, r, h.ray.col*h.srf.tc, rr, -h.ray.sgn);
}

// Function 403
vec3 calcNormal(vec4 p, float dx) {
	const vec3 k = vec3(1,-1,0);
	return normalize(k.xyy*DE(p + k.xyyz*dx) +
					 k.yyx*DE(p + k.yyxz*dx) +
					 k.yxy*DE(p + k.yxyz*dx) +
					 k.xxx*DE(p + k.xxxz*dx));
}

// Function 404
vec3 raymarch(vec3 pathdir, vec3 pathorig){
    vec3 pathpos = pathorig;
    pathpos += pathdir*14.0;
    vec3 surfnormal;
    float distest, lightdistest;
    int bounces = 0;
    int object = 0;
    vec3 closestpos = pathpos;
    vec3 outCol = vec3(1.0);
    for(int i = 0; i < maxmarches; i++){
        // Check if the path is done
        if(length(pathpos) > scenesize || pathpos.z < -3.9 || bounces > maxbounces){break;}
        if(light(pathpos) < collisiondist){return outCol*vec3(1.0);}

        // Find the distance to the scene
        distest = DE(pathpos);
        lightdistest = light(pathpos);

        // Michael0884: Closest Non-Colliding Position
        if(distest > min(collisiondist, lightdistest)){closestpos = pathpos;}

        // Bounce the Path if it hits something
        if(distest < collisiondist){
            int object = getmat(pathpos);
            vec4 matprops = materialproperties(pathpos, object);
            outCol *= matprops.rgb;
            surfnormal = normal(pathpos);
            pathpos = closestpos;
            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));
            bounces++;
        }

        // Otherwise just keep going
        else{pathpos += pathdir*min(distest, lightdistest);}
    }
    return vec3(0.0);
}

// Function 405
vec3 GetNormal(vec3 p, float sphereR)
{
	vec2 j = vec2(sphereR, 0.0);
	vec3 nor  	= vec3(0.0,		Terrain2(p.xz, sphereR), 0.0);
	vec3 v2		= nor-vec3(j.x,	Terrain2(p.xz+j, sphereR), 0.0);
	vec3 v3		= nor-vec3(0.0,	Terrain2(p.xz-j.yx, sphereR), -j.x);
	nor = cross(v2, v3);
	return normalize(nor);
}

// Function 406
Hit castRay(inout vec3 p, vec3 dir)
{	
	Hit hit;
	Distance dist = distance(p);
	float eps = 0.001;
    bool r = false;
    vec3 c = vec3(0.0);
	
	for (int i = 0; i < MAX_STEPS; i++)
	{
		Distance dist;
        if (r)
            dist = distance2(p);
        else
            dist = distance(p);
                
		float d = dist.value;
		if (abs(d) <= eps)
		{
           	if (!r && dist.color.b > 0.55)
            {            
            	dir = refract(dir, getNormal(p, 0.001), 0.9);
                c = dist.color;
                r = true;
            }
            else
            {
                hit.is = true;
                hit.pos = p;
                hit.normal.x = distance(p + vec3(eps,0,0)).value - distance(p - vec3(eps,0,0)).value;
                hit.normal.y = distance(p + vec3(0,eps,0)).value - distance(p - vec3(0,eps,0)).value;
                hit.normal.z = distance(p + vec3(0,0,eps)).value - distance(p - vec3(0,0,eps)).value;
                hit.normal = normalize(hit.normal);
                hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));
                if (r)
                    hit.color += c;
                return hit;
            }
		}
		p += dir*d;
	}	
	hit.is = false;
	hit.color = vec3(0);
	return hit;
}

// Function 407
float castRayx(vec3 ro,vec3 rd) 
{
    float function_sign=(map(ro)<0.)?-1.:1.;
    float precis=.01;
    float h=precis*2.;
    float t=0.;
	for(int i=0;i<50;i++) 
	{
        if(abs(h)<precis||t>12.)break;
		h=function_sign*map(ro+rd*t);
        t+=h;
	}
    return t;
}

// Function 408
void rayMarch(vec3 ro, vec3 rd, out float t, out float d, in float maxd)
{
    t = 0.;
    d = 0.;
    vec3 cp = ro;
    for(int i=0;i<200;++i)
    {
        d = map(cp);
        t += d;
        cp = ro+rd*t;
        if (d < .001 || d > maxd || abs(cp.y) > 35.)
            break;
    }
}

// Function 409
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(0.001, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 410
vec3 traceRay(Ray primaryRay) {
    /*
    Traces primary ray in the scene and allows the ray to bounce up to 4 times.
    The reflected light is approximated by calculating the sum of incoming light
    which in turn is the sum of reflected light at the next ray intersections.
    Depending on the SAMPLES-variable this function may take a long time to calculate
    and might freeze your computer, therfore we recommend to use no value larger than 10.
    */

    float minT = 0.0001; // Minimum distance between ray origin and intersection
    float maxT = 10e10; // Largest distance
    
    HitRecord primaryHit; // Struct for storing information about the intersection point
  
    // trace primary ray and see if we hit something       
    vec3 L0 = vec3(0.0); // The total emitted and reflected light at the first intersection point
    if (objectIntersection(primaryRay, primaryHit, maxT)) {

        HitRecord secondHit;
        secondHit.t = maxT;

        for(int depth1 = 0; depth1 < SAMPLES; ++depth1) {
            vec3 hitPoint = primaryRay.orig + primaryHit.t * primaryRay.dir;
            vec3 nextDir = getReflection(primaryRay, primaryHit);
            
            Ray secondaryRay = Ray(hitPoint, nextDir);
                  
            vec3 L1 = vec3(0.0);
            if(objectIntersection(secondaryRay, secondHit, maxT)) {
                HitRecord thirdHit;
                thirdHit.t = maxT;
                
                for(int depth2 = 0; depth2 < SAMPLES; ++depth2) {
                    hitPoint = secondaryRay.orig + secondHit.t * secondaryRay.dir;
                    nextDir = getReflection(secondaryRay, secondHit);
                       
                    Ray thridRay = Ray(hitPoint, nextDir);
                    
                    objectIntersection(thridRay, thirdHit, maxT);
                    
                    vec3 L2 = vec3(0.0);
					if(objectIntersection(thridRay, thirdHit, maxT)) {
						HitRecord fourthHit;
                		fourthHit.t = maxT;

						for(int depth3 = 0; depth3 < SAMPLES; ++depth3) {
							hitPoint = thridRay.orig + thirdHit.t * thridRay.dir;
							nextDir = getReflection(thridRay, thirdHit);
							Ray fourthRay = Ray(hitPoint, nextDir);
						
							objectIntersection(fourthRay, fourthHit, maxT);

							vec3 L3 = fourthHit.mat.emission;
							L2 += BDRFcontribution(thridRay, fourthRay, thirdHit, L3); // Adding Li sample contribution
						}
						L2 += thirdHit.mat.emission;
					}
					L1 += BDRFcontribution(secondaryRay, thridRay, secondHit, L2);
                }
                L1 += secondHit.mat.emission;
            }
            L0 += BDRFcontribution(primaryRay, secondaryRay, primaryHit, L1);
        }
        L0 += primaryHit.mat.emission;
        primaryHit.t = maxT;
    }

    return L0;
}

// Function 411
vec3 AABoxNormal(vec3 bmin, vec3 bmax, vec3 p) 
{
    vec3 n1 = -(1.0 - smoothstep(0.0, 0.03, p - bmin));
    vec3 n2 = (1.0 -  smoothstep(0.0, 0.03, bmax - p));
    
    return normalize(n1 + n2);
}

// Function 412
void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)
{
    vec2 vUV = coord.xy;
    vec2 vViewCoord = vUV * 2.0 - 1.0;	

	vViewCoord.y *= -1.0;

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vWorldUp, vForwards));
    vec3 vUp = cross(vRight, vForwards);
        
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    
}

// Function 413
void GetCameraRayLookat( const in vec3 vPos, const in vec3 vCameraTarget, const in vec2 px, out C_Ray ray)
{
	vec3 vForwards = normalize(vCameraTarget - vPos);
	vec3 vUp = vec3(0.0, 1.0, 0.0);

	GetCameraRay(vPos, vForwards, vUp, px, ray);
}

// Function 414
float ObjRay (vec3 ro, vec3 rd)
{
  const int nStep = 50;
  float d, h, s;
  d = 0.;
  s = 0.;
  for (int j = 0; j < nStep; j ++) {
    h = ObjDf (ro + d * rd);
    d += h;
    ++ s;
    if (h < 0.0003 || d > dstFar) break;
  }
  qStep = s / float (nStep);
  return d;
}

// Function 415
void queueRay(ray newRay){
    rayTree[rtQCursor] = newRay;
    rtQCursor = (rtQCursor > 30) ? 0 : rtQCursor +1;

}

// Function 416
vec3 normal_at(vec3 p){
    float dist = scene_sdf(p).x;
    return normalize(dist - vec3( 
        scene_sdf(p - vec3(0.01, 0, 0)).x,
        scene_sdf(p - vec3(0, 0.01, 0)).x,
        scene_sdf(p - vec3(0, 0, 0.01)).x
    ));
}

// Function 417
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.1, 0., 0. );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 418
vec3 getNormalAtPoint( vec3 pos ) {
    float delta = 0.001;
    vec2 unit = vec2( 1.0, 0.0 );
    return normalize(
        vec3(
            computeDist( pos + unit.xyy * delta ) - computeDist( pos - unit.xyy * delta ),
            computeDist( pos + unit.yxy * delta ) - computeDist( pos - unit.yxy * delta ),
            computeDist( pos + unit.yyx * delta ) - computeDist( pos - unit.yyx * delta )
        )
    );
}

// Function 419
void raytraceTreeline(vec3 rayPt, vec3 rayDir, float treelineZ, float treeGapX, float offX, float groundY){
    
    float rayGapStepsZ = (treelineZ-rayPt.z)/rayDir.z;
    float rayX = rayPt.x + rayDir.x*rayGapStepsZ;
    float treeX = floor((rayX-offX)/treeGapX)*treeGapX + treeGapX*0.5 + offX;
    
    if (abs(treeX) > 240.0) return;
    
    raytraceTree(rayPt,rayDir,vec3(treeX,groundY,treelineZ),
    	sin(treeX+treelineZ)*1.5,//yOff
        sin(treeX*0.7+treelineZ)*4.0,//heightOff
        sin(treeX*0.85+treelineZ)*1.0//widthOff
    );
    
    #ifdef DRAW_CLIP_RAYTRACES
    //color.r += sin(treeX*0.1)*0.01+0.5;
    #endif
    
}

// Function 420
vec3 normal(vec3 p)
{
	float c = scene(p);
	vec3 delta;
	vec2 h = vec2(0.01, 0.0);
	delta.x = scene(p + h.xyy) - c;
	delta.y = scene(p + h.yxy) - c;
	delta.z = scene(p + h.yyx) - c;
	return normalize(delta);
}

// Function 421
vec4 atmRay(vec3 ro, vec3 rd)
{
	vec3 atmCol = vec3(0.f);

	// optional fake sun using phase
	vec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);
	if (res.w <= 0.0f)
	{
		vec3 toCam = -rd; // normalize(pA - pB);
		float cos_theta = dot(sunDir(), toCam);
		float phase = phaseFunction(cos_theta, -0.99f);
		atmCol += vec3(1.5, 1.3, 0.9) * vec3(0.01f) * phase;
	}

	//
	vec3 pA, pB;
	int foundPath = getAtmPath(ro, ro + rd * EARTH_R * 1e2f, pA, pB, ATM_R, EARTH_R);
	if (foundPath == 0)
		return vec4(atmCol, 0.0);

	//
	vec3 SUN_COLOR = vec3(1.0);

	// rayleigh
	vec3 rayleigh = inScattering(ro, pA, pB, SUN_COLOR, Kr, 0.0f);
	atmCol += rayleigh;

	//
	return vec4(atmCol, 1.0);
}

// Function 422
vec3 GetSceneNormal( const in vec3 vPos )
{
    const float fDelta = 0.001;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetSceneDistance( vPos + vOffset1 ).x;
    float f2 = GetSceneDistance( vPos + vOffset2 ).x;
    float f3 = GetSceneDistance( vPos + vOffset3 ).x;
    float f4 = GetSceneDistance( vPos + vOffset4 ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 423
vec3 castRay(vec3 p, vec3 rd) {
    CP cp = findIntersection(p, rd);
   
    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);
    calcRecursion(ray);
    ray.col += getRayColor(ray);
	return ray.col;
    
}

// Function 424
vec3 ray_dir( float fov, vec2 size, vec2 pos ) {
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( radians( 90.0 - fov * 0.5 ) );	
	float z = size.y * 0.5 * cot_half_fov;
	
	return normalize( vec3( xy, -z ) );
}

// Function 425
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.0001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<130; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;
        t += h;
        vec3 p = ro+rd*t;
	    vec2 res = map( p );
        h = res.x;
	    m = res.y;
    }

    if( t>maxd ) m=-1.0;
    return vec2( t, m );
}

// Function 426
vec3 calcNormal( in vec3 pos, in float mat )
{
	vec3 nor = vec3(0.0);
	
	if( mat<4.5 ) nor = nSphere( pos, sphere[3] );
	if( mat<3.5 ) nor = nSphere( pos, sphere[2] );
	if( mat<2.5 ) nor = nSphere( pos, sphere[1] );
	if( mat<1.5 ) nor = nSphere( pos, sphere[0] );
	if( mat<0.5 ) nor = nPlane(  pos, vec4(0.0,1.0,0.0,1.0) );
					  
    return nor;					  
}

// Function 427
vec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)
{
    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.
    // Used for reflection off the surface of the object, and refraction out the back of the object.
    
    // if we hit the box, return the lit box color
    vec2 uv;
    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);
    if (rayInfo.x >= 0.0)
        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);
    // else return skybox color
    else
        return texture(iChannel0, rayDir).rgb;
}

// Function 428
vec3 refraction(vec3 v,  vec3 normal, float n1, float n2) {
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA*cosA);
    vec3 tang = normalize(v - cosA * normal);
    float sinB = sinA * (n1 / n2) ;
    float cosB = sqrt(1.0 - sinB*sinB);
    return normalize(sinB * tang + cosB * normal);
}

// Function 429
vec3 calcNormal( vec3 pos )
{
    float eps = 0.01; // precission
    float gradX = scene( pos + vec3(eps, 0.0, 0.0) ).x - scene( pos - vec3(eps, 0.0, 0.0)).x;
    float gradY = scene( pos + vec3(0.0, eps, 0.0) ).x - scene( pos - vec3(0.0, eps, 0.0)).x;
    float gradZ = scene( pos + vec3(0.0, 0.0, eps) ).x - scene( pos - vec3(0.0, 0.0, eps)).x;
    return normalize( vec3( gradX, gradY, gradZ ) );
}

// Function 430
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 120; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 431
vec3 getNormalStd (in vec3 p)
{
  float d = sphere(p);
  vec3 eps = vec3(0.0001, 0.0, 0.0);
  return normalize(vec3(
           d - sphere(p - eps.xyy),
           d - sphere(p - eps.yxy),
           d - sphere(p - eps.yyx)));
}

// Function 432
vec3 calcNormal(vec3 p)
{ // by iq
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
	return normalize(	e.xyy *map(p + e.xyy) + 
						e.yxy *map(p + e.yxy) + 					  
						e.yyx *map(p + e.yyx) + 					  
				  	  	e.xxx *map(p + e.xxx) );
}

// Function 433
vec4 cylindernormal(vec4 ray, vec4 pos, float size,
        float lenrayyzw,
        float lenrayzwx,
        float lenraywxy,
        float lenrayxyz) {
    vec4 lens = vec4(
        sphIntersect(ray.yzw*lenrayyzw,vec4(pos.yzw,size)).y*lenrayyzw,
        sphIntersect(ray.zwx*lenrayzwx,vec4(pos.zwx,size)).y*lenrayzwx,
        sphIntersect(ray.wxy*lenraywxy,vec4(pos.wxy,size)).y*lenraywxy,
        sphIntersect(ray.xyz*lenrayxyz,vec4(pos.xyz,size)).y*lenrayxyz);
    float len = max(max(max(lens.x,lens.y),lens.z),lens.w);
    vec4 mask = step(len,lens);
    pos += ray*len;
    return -pos/size*(1.0-mask);
}

// Function 434
vec3 GetNormal(vec3 p) {
	float d = DE(p);
    vec2 e = vec2(.01, 0);
    
    vec3 n = d - vec3(
        DE(p-e.xyy),
        DE(p-e.yxy),
        DE(p-e.yyx));
    
    return normalize(n);
}

// Function 435
vec3 computeNormal(vec3 pos, vec3 lightPos)
{
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),
                          sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),
                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));
}

// Function 436
vec3 WaterNormal(vec3 p, float e)
{
    vec3 N;
    N.y = Water(p.xz);
    N.x = Water(p.xz-vec2(e, 0.))-N.y;
    N.z = Water(p.xz-vec2(0., e))-N.y;
    return normalize(N);
}

// Function 437
vec3 calcNormal( in vec3 pos )
{
    const vec3 v1 = vec3(1.0,0.0,0.0);
    const vec3 v2 = vec3(0.0,1.0,0.0);
    const vec3 v3 = vec3(0.0,0.0,1.0);
	return normalize(vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))
                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)));
}

// Function 438
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.1, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    
    return normalize(n);
}

// Function 439
vec3 rayMarch(vec3 rayDir, vec3 cameraOrigin, vec3 lightPos)
{
    const int MAX_ITER = 50;
	const float MAX_DIST = 10.0;
    
    float totalDist = 0.0;
	vec3 pos = cameraOrigin;
	vec2 dist = vec2(EPSILON, 0.0);
    
    for(int i = 0; i < MAX_ITER; i++)
	{
		dist = distfunc(pos, lightPos - pos);
		totalDist += dist.x;
		pos += dist.x*rayDir;
        
        if(dist.x < EPSILON || totalDist > MAX_DIST)
		{
			break;
		}
	}
    
    return vec3(dist.x, totalDist, dist.y);
}

// Function 440
vec4 raymarch(vec3 from, vec3 increment)
{
	const float maxDist = 200.0;
	const float minDist = 0.001;
	const int maxIter = RAYMARCH_ITERATIONS;
	
	float dist = 0.0;
	float material = 0.0;
	
	for(int i = 0; i < maxIter; i++) {
		vec3 pos = (from + increment * dist);
		float distEval = distf(pos, material);
		
		if (distEval < minDist) {
			break;
		}
		
		dist += distEval;
	}
	
	if (dist >= maxDist) material = 0.0;
	
	return vec4(dist, material, 0, 0);
}

// Function 441
float ringRayNoise(vec3 ray, vec3 pos, float r, float size, float anim) {
  	float b = dot(ray,pos);
    vec3 pr = ray*b-pos;
    float c = length(pr),
     	  s = max(0.,(1.-size*abs(r-c)));
    pr = pr/c;
    float n=.4, ns=1., nd = noise4q(vec4(pr*1.0,-anim+c))*2.0;
    if (c > r) {
        n  = noise4q(vec4(pr*10.0,-anim+c));
        ns = noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;
    }
    n *= n*nd*nd*ns;
    return s*s*(s*s+n);
}

// Function 442
vec3 calcNormal(vec3 p) {
 	   
    vec2 eps = vec2(.001,0.);
    vec3   n = vec3(dstScene(p + eps.xyy) - dstScene(p - eps.xyy),
                    dstScene(p + eps.yxy) - dstScene(p - eps.yxy),
                    dstScene(p + eps.yyx) - dstScene(p - eps.yyx));
    return normalize(n);
    
}

// Function 443
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.0002;
    vec4 kk;
    vec3 nor;
#if 0
	nor.x = map( vec3(pos.x+eps, pos.y, pos.z), kk ) - map( vec3(pos.x-eps, pos.y, pos.z), kk );
	nor.y = map( vec3(pos.x, pos.y+eps, pos.z), kk ) - map( vec3(pos.x, pos.y-eps, pos.z), kk );
	nor.z = map( vec3(pos.x, pos.y, pos.z+eps), kk ) - map( vec3(pos.x, pos.y, pos.z-eps), kk );
#else
    nor = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        nor += e*map(pos+eps*e, kk);
    }
#endif    
	return normalize( nor );
}

// Function 444
vec3 ComputeDetailNormal(vec2 uv)
{
    const vec4 avgRGB0 = vec4(1.0/3.0, 1.0/3.0, 1.0/3.0, 0.0);
    const float scale = 0.02;
    const vec2 du = vec2(1.0/512.0, 0.0);
    const vec2 dv = vec2(0.0, 1.0/512.0);

    float h0  = dot(avgRGB0, texture(iChannel0, uv)) * scale;
    float hpx = dot(avgRGB0, texture(iChannel0, uv + du)) * scale;
    float hmx = dot(avgRGB0, texture(iChannel0, uv - du)) * scale;
    float hpy = dot(avgRGB0, texture(iChannel0, uv + dv)) * scale;
    float hmy = dot(avgRGB0, texture(iChannel0, uv - dv)) * scale;
    
    float dHdU = (hmx - hpx) / (2.0 * du.x);
    float dHdV = (hmy - hpy) / (2.0 * dv.y);
    
    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;
}

// Function 445
vec3 calc_normal(vec3 sample_point) {
    const float h = 0.01; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    
    vec3 normal = normalize(
		k.xyy * sample_world( sample_point + k.xyy*h ) + 
		k.yyx * sample_world( sample_point + k.yyx*h ) + 
		k.yxy * sample_world( sample_point + k.yxy*h ) + 
		k.xxx * sample_world( sample_point + k.xxx*h ) );
    normal = normal.zyx;
    return normal;
}

// Function 446
Ray genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {
    Ray ray;
	//vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	//vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    //ray.origin = camera.pos;
    //ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    
    
    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    
    if( camera.lensSize > EPSILON ) {
        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );
        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;
        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];
        vec3 newBack = normalize(newPos - focusPoint);
        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );
        vec3 newUp = cross( newBack, newRight );
        mat3 newRotate;
        newRotate[0] = newRight;
        newRotate[1] = newUp;
        newRotate[2] = newBack;


        ray.origin = newPos;
        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    } else {
        ray.origin = camera.pos;
        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    }

	return ray;
}

// Function 447
vec3 hyperNormalizeP(vec3 u) {
    float s = u.z < 0. ? -1. : 1.;
    return u * (s / sqrt(-hyperDot(u, u)));
}

// Function 448
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.0,0.5,0.1), rd, vec3(0.4,0.5,0.5) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 449
vec3 getNormal(vec3 p, float t, sphere s, float rnd)
{
	vec2 d = vec2(0.01, 0.0);
	float dx = distanceField(p + d.xyy,t,s,rnd)
				- distanceField(p - d.xyy,t,s,rnd);
	float dy = distanceField(p + d.yxy,t,s,rnd)
				- distanceField(p - d.yxy,t,s,rnd);
	float dz = distanceField(p + d.yyx,t,s,rnd)
				- distanceField(p - d.yyx,t,s,rnd);
	return normalize(vec3(dx, dy, dz));
}

// Function 450
vec3 calcNormal( in vec3 pos, in float time, in float t )
{
    float eps = 0.001*t;
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + 
					  e.yyx*mapD( pos + e.yyx*eps,time ) + 
					  e.yxy*mapD( pos + e.yxy*eps,time ) + 
					  e.xxx*mapD( pos + e.xxx*eps,time ) );
#else
    vec4 n = vec4(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        s[i] += eps;
        n[i] = mapD(s.xyz, time);
        //if( n.x+n.y+n.z+n.w>100.0 ) break;
    }
    return normalize(n.xyz-n.w);
#endif    
}

// Function 451
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 80; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 452
vec3 raydir(vec2 uv, vec3 ro, vec3 lookat, float zoom) {
    vec3 forward = normalize(lookat - ro);
    vec3 temp = cross(vec3(0.0, 1.0, 0.0), forward);
    vec3 up = normalize(cross(forward, temp));
    vec3 right = cross(up, forward);
    vec3 screen_center = ro + forward * zoom;
    vec3 i = screen_center + uv.x * right + uv.y * up;
    vec3 rd = i-ro;
    return rd;

}

// Function 453
vec3 getNormal(vec3 pos, float e)
{
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx, false) - map(pos - q.yxx, false),
                          map(pos + q.xyx, false) - map(pos - q.xyx, false),
                          map(pos + q.xxy, false) - map(pos - q.xxy, false)));
}

// Function 454
vec2 getNormal(line l)
{
    vec2 c = l.a-l.b;
    return vec2(-c.y,c.x);
}

// Function 455
bool RayIntersectAABox (SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 456
ray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom){
        ray a;
        a.o = camPos;
        
        vec3 f = normalize(lookat - camPos);
        vec3 r = cross(vec3(0.,1,0.), f);
        vec3 u = cross(f, r);//zoom is the distance of camera to screen,.
        vec3 c = a.o +  f* zoom;    //center of screen point, f is normalized
        vec3 i = c + uv.x * r + uv.y * u;
        a.d = normalize(i - a.o);//distance of ray from focus to screen.
        return a;
    
    }

// Function 457
float RayMarchStepCount(vec3 ray_origin, vec3 ray_dir, float initial_dist, float iTime)
{
    float dist = initial_dist;
    
    int i = 0;
    for (; i < MAX_STEPS; ++i)
    {
        vec3 p = ray_origin + ray_dir * dist;
        
        float nearest = GetSceneDist(p, iTime);
        
        if (nearest < MIN_DIST)
            break;
        
        dist += nearest;

        if (dist > MAX_DIST)
            break;
    }
    
    return float(i);
}

// Function 458
vec3 getSurfaceNormal(vec3 endPoint, float epsilonParam, vec3 ro, vec3 rd)
{
	float epsilon = epsilonParam;

	vec2 e = vec2(1.0,-1.0)*0.5773*epsilon;
	return normalize( e.xyy*SDF( endPoint + e.xyy, ro, rd).x + 
					  e.yyx*SDF( endPoint + e.yyx, ro, rd).x + 
					  e.yxy*SDF( endPoint + e.yxy, ro, rd).x + 
					  e.xxx*SDF( endPoint + e.xxx, ro, rd).x );
}

// Function 459
vec4 raymarch(vec3 rayOrigin, vec3 rayDir)
{
	float totalDist = 0.0;
	for(int j=0; j<MAXSTEPS; j++)
	{
		vec3 p = rayOrigin + totalDist*rayDir;
		float dist = distanceField(p);
		if(abs(dist)<EPSILON)	//if it is near the surface, return an intersection
		{
			return vec4(p, 1.0);
		}
		totalDist += dist;
		if(totalDist>=MAXDEPTH) break;
	}
	return vec4(0);
}

// Function 460
SDObject castRay( in Ray ray )
{
    int cd=1;
    float precis =0.00001;//(state.y+1.<iTime)?0.0001:0.003;
    float t = ray.tmin;
    SDObject res=NoSDObject;
    SDObject  ores=NoSDObject;
    vec3 p;
    int citer=0;
    for( int i=0; i<200; i++ )
    {
        p=ray.ro+ray.rd*t;
        res = mapScene( p,ray.id,ray.solo );
        if( res.d<precis || t>ray.tmax) {              
            break;
        }
        t += res.d;
    }
    res.t=t;
    if( t>ray.tmax ) return NoSDObject;
    //   res.ray.ro=p;
    return res;
}

// Function 461
float distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {
    h = dot(p-ro,rd);
    return length(p-ro-rd*h);
}

// Function 462
vec3 raymarch(in vec3 from, in vec3 dir) 

{
	float ey=mod(t*.5,1.);
	float glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;
	vec2 d=vec2(1.,0.);
	vec3 p, col=vec3(0.);
	vec3 origdir=dir,origfrom=from,sphNorm;
	
	//FAKING THE SQUISHY BALL BY MOVING A RAY TRACED BALL
	vec3 wob=cos(dir*500.0*length(from-pth1)+(from-pth1)*250.+iTime*10.)*0.0005;
	float t1=Sphere(from-pth1+wob,dir,0.015);
	float tg=Sphere(from-pth1+wob,dir,0.02);
	if(t1>0.){
		ref=1.0;from+=t1*dir;sphdist=t1;
		sphNorm=normalize(from-pth1+wob);
		dir=reflect(dir,sphNorm);
	} 
	else if (tg>0.) { 
		vec3 sphglowNorm=normalize(from+tg*dir-pth1+wob);
		glow+=pow(max(0.,dot(sphglowNorm,-dir)),5.);
	};
	
	for (int i=0; i<RAY_STEPS; i++) {
		if (d.x>det && totdist<3.0) {
			p=from+totdist*dir;
			d=de(p);
			det=detail*(1.+totdist*60.)*(1.+ref*5.);
			totdist+=d.x; 
			energy=ENERGY_COLOR*(1.5+sin(iTime*20.+p.z*10.))*.25;
			if(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);
			if (d.y<.5 && d.x<0.03){//ONLY DOING THE GLOW WHEN IT IS CLOSE ENOUGH
				float glw=min(abs(3.35-p.y-ey),abs(3.35-p.y+ey));//2 glows at once
				eglow+=max(0.,.03-d.x)/.03*
				(pow(max(0.,.05-glw)/.05,5.)
				+pow(max(0.,.15-abs(3.35-p.y))/.15,8.))*1.5;
			}
		}
	}
	float l=pow(max(0.,dot(normalize(-dir.xz),normalize(lightdir.xz))),2.);
	l*=max(0.2,dot(-dir,lightdir));
	vec3 backg=.5*(1.2-l)+LIGHT_COLOR*l*.7;
	backg*=AMBIENT_COLOR;
	if (d.x<=det) {
		vec3 norm=normal(p-abs(d.x-det)*dir);//DO THE NORMAL CALC OUTSIDE OF LIGHTING (since we already have the sphere normal)
		col=light(p-abs(d.x-det)*dir, dir, norm, d.y)*exp(-.2*totdist*totdist); 
		col = mix(col, backg, 1.0-exp(-1.*pow(totdist,1.5)));
	} else { 
		col=backg;
	}
	vec3 lglow=LIGHT_COLOR*pow(l,30.)*.5;
	col+=glow*(backg+lglow)*1.3;
	col+=pow(eglow,2.)*energy*.015;
	col+=lglow*min(1.,totdist*totdist*.3);
	if (ref>0.5) {
		vec3 sphlight=light(origfrom+sphdist*origdir,origdir,sphNorm,2.);
		col=mix(col*.3+sphlight*.7,backg,1.0-exp(-1.*pow(sphdist,1.5)));
	}
	return col; 
}

// Function 463
void raytraceBranch(vec3 rayPt, vec3 rayDir, vec3 treeOrigin, float theBranchEnd, float pitch, float yaw){
    
    
    branchEnd = theBranchEnd;//is it a terrible idea to use globals to avoid passing arguments over and over? (or a great idea?)
    
    
    moveToBranchSpace(rayPt, rayDir, treeOrigin, pitch, yaw);
    
    float testDist = -1.0;
    if (!testAABB(rayPt, rayDir,
                  vec3((branchStart+branchEnd)*0.5,-0.05,0.0),//hardcoded y offset
                  vec3((branchEnd-branchStart)*0.5,0.8,2.0),//hardcoded size
                  testDist)) return;
    
    
    
    vec3 p = rayPt + rayDir*testDist;

    float f=testDist;
    float d=0.01;
    float curMaxD = testDist + branchEnd*2.0;//slightly overkill but close enough
    int mat, dummyMat;
    for(int i=0;i<16;i++){
        if (f >= curMaxD) {
			f = maxd;
			break;
		}
		if (abs(d) < .01) break;
        f+=d;
        p=rayPt + rayDir*f;
        d = branchDistance(p,mat);
    }
    
    
    
    
    
    if (f < nearestD) {

        nearestD = f;

        // this normal calculation actually ignores the branch's tilt,
        // but whatever, it's close enough for lighting this vague
        vec3 n = normalize(vec3(d-branchDistance(p-e.xyy,dummyMat),
                                d-branchDistance(p-e.yxy,dummyMat),
                                d-branchDistance(p-e.yyx,dummyMat)));
        

        if (mat == 1) {
            
            float diffuse=max(dot(n,vec3(0.0,1.0,0.0)),0.0);
            diffuse = pow(diffuse,0.5);
            color = mix(vec3(0.90,0.55,0.00),vec3(0.95,0.85,0.70),diffuse);
            
        } else {
            
            float diffuse=max(dot(n,vec3(0.0,1.0,0.0)),0.0);
            color = vec3(0.1,0.2,0.2) * diffuse;

        }

    }
    
    #ifdef DRAW_CLIP_RAYTRACES
    color = mix(color,vec3(1.0,0.0,0.0),0.1);
    #endif
    
}

// Function 464
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    yin_yang(pos+eps.xyy).x - yin_yang(pos-eps.xyy).x,
	    yin_yang(pos+eps.yxy).x - yin_yang(pos-eps.yxy).x,
	    yin_yang(pos+eps.yyx).x - yin_yang(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 465
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 466
vec3 normal_o349467(vec3 p){  
  const vec3 e=vec3(0.001,-0.001,0.0);
  float v1=input_o349467(p+e.xyy).x;
  float v2=input_o349467(p+e.yyx).x;
  float v3=input_o349467(p+e.yxy).x;
  float v4=input_o349467(p+e.xxx).x;
  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
}

// Function 467
vec3 GetReflectionMap(vec3 rayDir, vec3 normal)
{
  return texture(iChannel3, reflect( rayDir, normal )).rgb;
}

// Function 468
float rayMarch(vec3 ro, vec3 rd) {
	vec3 pos = ro;
    float inc = 0.;
    float d = 0.;
    for(int i=0;i<ITERATIONS;i++) {
    	pos = ro + d*rd;
        inc = sdScene(pos);
        d += inc;
        if(inc < MIN_D || d > MAX_D) break;
    }
    return d;
}

// Function 469
vec3 getReflectedVector(vec3 v, vec3 n, vec3 t, vec3 b, float roughness, float anisotropy) {
    vec3  anisotropyDirection = anisotropy >= 0.0 ? b : t;
    vec3  anisotropicTangent  = cross(anisotropyDirection, -v);
    vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);
    vec3  bentNormal          = normalize(mix(n, anisotropicNormal, abs(anisotropy)));

    return reflect(v, bentNormal);
}

// Function 470
vec3 getNormalFace( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*faceFunc( pos + e.xyy ) + 
					  e.yyx*faceFunc( pos + e.yyx ) + 
					  e.yxy*faceFunc( pos + e.yxy ) + 
					  e.xxx*faceFunc( pos + e.xxx ) ) ;
}

// Function 471
vec2 Reflect(line ray, line l)
{
    vec2 c = getIntersect(ray, l);
    vec2 n1 = getNormal(l);
    vec2 n2 = (dot(ray.a-c, n1) / dot(n1, n1)) * n1;
    vec2 d = 2.*(n2-ray.a+c)+ray.a-c;
    return 50.*d+c;
}

// Function 472
vec3 normals(vec3 p){
	vec3 eps = vec3(PIXELR, 0.0, 0.0 );
    return normalize(vec3(
        sdf(p+eps.xyy) - sdf(p-eps.xyy),
        sdf(p+eps.yxy) - sdf(p-eps.yxy),
        sdf(p+eps.yyx) - sdf(p-eps.yyx)
    ));
}

// Function 473
vec3 GetSceneNormal( const in vec3 vPos )
{
	// tetrahedron normal
	float fDelta = 0.025;

	vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
	vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
	vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
	vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

	float f1 = GetDistanceScene( vPos + vOffset1 ).x;
	float f2 = GetDistanceScene( vPos + vOffset2 ).x;
	float f3 = GetDistanceScene( vPos + vOffset3 ).x;
	float f4 = GetDistanceScene( vPos + vOffset4 ).x;

	vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

	return normalize( vNormal );
}

// Function 474
vec3 calcNormal( in vec3 pos )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
#endif    
}

// Function 475
vec3 calcNormal( in vec3 p, in float t )
{
#if 0    
    float e = 0.001*t;

    vec2 h = vec2(1.0,-1.0)*0.5773;
    return normalize( h.xyy*map( p + h.xyy*e ).x + 
					  h.yyx*map( p + h.yyx*e ).x + 
					  h.yxy*map( p + h.yxy*e ).x + 
					  h.xxx*map( p + h.xxx*e ).x );
#else    
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(p+e*0.001*t).x;
    }
    return normalize(n);
#endif    
}

// Function 476
vec4 ray_march(inout vec4 p, vec4 ray, float sharpness) {
	//March the ray
	float d = DE(p);
	if (d < 0.0 && sharpness == 1.0) {
		vec3 v;
		if (abs(iMarblePos.x) >= 999.0f) {
			v = (-20.0 * iMarbleRad) * iMat[2].xyz;
		} else {
			v = iMarblePos.xyz - iMat[3].xyz;
		}
		d = dot(v, v) / dot(v, ray.xyz) - iMarbleRad;
	}
	float s = 0.0;
	float td = 0.0;
	float min_d = 1.0;
	for (; s < float(MAX_MARCHES); s += 1.0) {
		//if the distance from the surface is less than the distance per pixel we stop
		float min_dist = max(FOVperPixel*td, MIN_DIST);
		if (d < min_dist) {
			s += d / min_dist;
			break;
		} else if (td > MAX_DIST) {
			break;
		}
		td += d;
		p += ray * d;
		min_d = min(min_d, sharpness * d / td);
		d = DE(p);
	}
	return vec4(d, s, td, min_d);
}

// Function 477
float castRay(vec3 rayOrigin, vec3 rayDir)
{
    float t = 0.0; // Stores current distance along ray
     
    for (int i = 0; i < MAX_STEPS; i++)
    {
        float res = sdf(rayOrigin + rayDir * t);
        if (res < (EPSILON * t))
        {
            return t;
        }
        t += res;
    }
     
    return -1.0;
}

// Function 478
vec3 getNormal(in vec3 p) {
    return normalize(vec3(mapScene(p + GRAD_STEP.xyy).dist - mapScene(p - GRAD_STEP.xyy).dist,
                          mapScene(p + GRAD_STEP.yxy).dist - mapScene(p - GRAD_STEP.yxy).dist,
                          mapScene(p + GRAD_STEP.yyx).dist - mapScene(p - GRAD_STEP.yyx).dist));
}

// Function 479
vec3 getNormal(vec3 pos)
{
    float epsilon = 0.001;
    
	vec2 t = vec2(0.0, epsilon);
    vec3 n = vec3(scene(pos + t.yxx) - scene(pos - t.yxx),
           	      scene(pos + t.xyx) - scene(pos - t.xyx),
                  scene(pos + t.xxy) - scene(pos - t.xxy));
    
    return normalize(n);
}

// Function 480
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 150; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.25, 0.4 * h) + 0.005 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 6; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 481
vec3 getCrystalNormal(vec3 p, in vec2 cell, float dens) {
    vec3 n;
    n.x = crystalSDF(vec3(p.x+EPSILON,p.y,p.z), cell);
    n.y = crystalSDF(vec3(p.x,p.y+EPSILON,p.z), cell);
    n.z = crystalSDF(vec3(p.x,p.y,p.z+EPSILON), cell);
    n = n - crystalSDF(p, cell);   
    float cr = (tri(p.y*1.4) + tri(p.y*2.7)) * 0.4;
    n.y += cr * 1e-4;
    return normalize(n);
}

// Function 482
vec3 MarchRay(vec3 origin,vec3 dir)
{
    vec3 marchPos = origin;
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float sceneDist = Scene(marchPos);
        
        marchPos += dir * sceneDist * STEP_MULT;
        
        if(sceneDist < MIN_DIST)
        {
            break;
        }
    }
    
    return marchPos;
}

// Function 483
float ObjRay (vec3 ro, vec3 rd)
{
  const int nStep = 150;
  float dHit, d, s;
  dHit = 0.;
  s = 0.;
  for (int j = 0; j < nStep; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    ++ s;
    if (d < 0.0003 || dHit > dstFar) break;
  }
  qnStep = s / float (nStep);
  return dHit;
}

// Function 484
vec3 calcNormal( in vec3 pos )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
                      e.yyx*map( pos + e.yyx ).x + 
                      e.yxy*map( pos + e.yxy ).x + 
                      e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
#endif    
}

// Function 485
vec3 GetNormal( vec3 pos )
{
	vec3 n;
	vec2 delta = vec2(0,1);

	// allow a slight curve so it looks more interesting
	#ifdef FIRST_PERSON
		delta *= .004;
	#else
		delta *= .04;
	#endif
	
	n.x = DistanceField( pos+delta.yxx ) - DistanceField( pos-delta.yxx );
	n.y = DistanceField( pos+delta.xyx ) - DistanceField( pos-delta.xyx );
	n.z = DistanceField( pos+delta.xxy ) - DistanceField( pos-delta.xxy );

	// we get some black on surfaces because of flat spots in the voronoi
	// fix that by giving it an arbitrary (and incorrect) normal
	if ( dot(n,n) == 0.0 )
		n.y += 1.0;

	return normalize(n);
}

// Function 486
vec3 normalLevel( vec3 p, const float eps ) {
    float d = level(p);
    vec2 e = vec2(eps, 0.);
    
    vec3 n;
    
    n.x = d - level(p-e.xyy);
    n.y = d - level(p-e.yxy);
    n.z = d - level(p-e.yyx);
    
    return normalize(n);
}

// Function 487
vec3 getNormalWS(vec3 p, float dt)
{
    vec3 normalWS = oz.yyy;
    for( int i = NON_CONST_ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        vec4 mat;
        float dist = fSDF(p + e * dt, false, mat);
        normalWS += e*fMaterialSDF(dist, mat);
    }
    return normalize(normalWS);    
}

// Function 488
void raytrace_sphere(
    vec4 sphere_center,
    float sphere_radius,
	vec4 ray_origin,
	vec4 ray_direction,
	inout vec3 inout_ray_color,
	inout float inout_ray_depth)
{
    vec4 local_ray_origin = (ray_origin - sphere_center);
    
    // Solving for the intersections via the quadratic equation, as seen in: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection
    float quadratic_a = 1.0; // dot(ray_direction, ray_direction)
    float quadratic_b = (2.0 * dot(local_ray_origin, ray_direction));
    float quadratic_c = (dot(local_ray_origin, local_ray_origin) - sq(sphere_radius));
    float quadratic_discriminant = (sq(quadratic_b) - (4.0 * quadratic_a * quadratic_c));
    
    if (quadratic_discriminant >= 0.0)
    {
        float sqrt_quadratic_discriminant = sqrt(quadratic_discriminant);
        float quadratic_divisor = (1.0 / (2.0 * quadratic_a));
        
        float depth_near = (((-1.0 * quadratic_b) - sqrt_quadratic_discriminant) * quadratic_divisor);
        float depth_far = (((-1.0 * quadratic_b) + sqrt_quadratic_discriminant) * quadratic_divisor);
        
        float depth = ((depth_near >= 0.0) ? depth_near : depth_far);
        
        if ((depth >= 0.0) &&
            (depth < inout_ray_depth))
        {
            vec4 intersection = (ray_origin + (ray_direction * depth));
            
            vec4 normal = normalize(intersection - sphere_center);
            float diffuse_fraction = (1.0 * max(0.0, dot(normal, s_light_direction)));
            float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));
            
            inout_ray_color = mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction)));
            inout_ray_depth = depth;
        }
    }
}

// Function 489
RayHit rayVsPlane(in Ray ray, in Plane plane){
    RayHit result = RayHit(vec3(0.0, 0.0, 0.0), -ray.dir, maxDistance);
    RayHit defaultResult = result;
    
    float planeDot = dot(ray.dir, -plane.n);
    float normalDist = dot(ray.start - plane.pos, plane.n);
    float t = normalDist / planeDot;
    result.dist = t;
    result.n = plane.n;
    result.color = sceneColor(ray.start + ray.dir * t);//vec3(1.0, 1.0, 1.0);
    //return result;
    return mixRayHits(defaultResult, result, float(
        (planeDot > 0.0) && (t > 0.0)
    ));
	    
    
    return result;
}

// Function 490
float aoray(in vec3 ro, in vec3 rd)
{
    
    float maxt = AO_DIST;
    
    float t = AO_SMALL_PREC;
    vec3 d = rd; // cur highest dir

    for(int i = 0; i<AO_RAY_ITER; i++)
    {
        vec3 p = ro + rd*t;
        p.y = map( p.xz ); // p design the map point
        float t_d = t/dot(rd, d); // compute dist between vertical at p and ro alog dir
        vec3 p2 = ro+d * t_d; // and deduce point along d
        if( p2.y < p.y )
        {
            d = normalize(p-ro);
        } 
        t +=  ao_factor * t;       
    }

    return acos(d.y)/3.141593;
    
}

// Function 491
vec2 castRay( in vec3 ro, vec3 rd, float time )
{
    float m = -1.0;
    float t = 0.01;
    int i=0;
    for( i=0; i<100; i++ )
    {
        float precis = 0.001 * t;
        vec3 pos = ro + t*rd;

        vec2 h = map( pos, time );
        m = h.y;
        if( h.x<precis )
            break;
        t += h.x;
        if( t>20.0 )
            break;
    } 
    if( t>20.0 ) m=-1.0;
    return vec2(t, m);
}

// Function 492
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.8,0.8,-0.8), rd, vec3(4.0,4.0,4.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 493
vec3 getRayColor(vec3 origin, vec3 ray, out vec3 p, out vec3 normal, out bool hit)
{
    vec3 col = vec3(0.0);
    
    float dist, depth;
    depth = 0.0;

    const int maxsteps = 128;

    for (int i = 0; i < maxsteps; i++)
    {
        p = origin + ray * depth;

        dist = distFunc(p);

        if (dist < EPS)
        {
            break;
        }

        depth += dist;
    }

    float shadow = 1.0;
    
    if (dist < EPS)
    {
        float ao = 1.0;
        normal = getNormal(p);

        float diff = dot(normal, normalize(lightDir));
        float spec = pow(clamp(dot(reflect(lightDir, normal), ray), 0.0, 1.0), 10.0);

        shadow = genShadow(p + normal * EPS, lightDir);

        ao = AmbientOcclusion(p + normal * EPS, normal);

        float u = 1.0 - floor(mod(p.x, 2.0));
        float v = 1.0 - floor(mod(p.z, 2.0));
        
        const float width = 0.2;
        
        if ((u + width >= 1.0) || (v + width >= 1.0))
        {
            diff *= 0.5;
        }
        else
        {
            diff *= 0.7;
        }
        //if ((u == 1.0 && v < 1.0) || (v == 1.0 && u < 1.0))
        //{
        //    diff *= 0.7;
        //}

        col = sceneColor(p).rgb * vec3(diff) + vec3(0.5) * spec;
        col *= max(0.7, ao);
        col *= max(0.5, shadow);
        
        hit = true;
    }
    else
    {
        vec4 cube = texture(iChannel0, ray);
    	col = cube.xyz;
        hit = false;
    }
    
    return col;
}

// Function 494
vec3 SceneNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.01, 0.0, 0.0 );
	vec3 normal = vec3(
	    Scene( pos + eps.xyy ).x - Scene( pos - eps.xyy ).x,
	    Scene( pos + eps.yxy ).x - Scene( pos - eps.yxy ).x,
	    Scene( pos + eps.yyx ).x - Scene( pos - eps.yyx ).x );
	return normalize( normal );
}

// Function 495
vec4 raymarch(vec3 origin, vec3 dir) {
	float t = 0.0;
	const int max_steps = 256;
	float epsilon = 0.00075;
	vec3 fog_color = vec3(1.0);
	vec4 color = vec4(fog_color,1);
	int num_reflections = 1;
	int reflections_left = num_reflections;
	for(int i = 0; i < max_steps; ++i) {
		vec3 p = origin + dir * t;
		float d = total_distance(p);
		if(d < epsilon) {
			vec3 n = normal(p);
			vec3 sample_color = vec3(0.8);
			// distance fade
			sample_color = mix(sample_color, fog_color, vec3(clamp(1.0-exp(-length(p)/8.0), 0.0, fog_color.x))); // Sphere color
			// front light
			//color.xyz += 0.1 * vec3(1) * clamp(dot(-dir, n),0,1);
			// ambient occlusion
			sample_color *= ambient_occlusion(p, n, num_reflections - reflections_left);

			if (false) {
				float step_intensity = 1.0-(float(i))/float(max_steps);
				color.yz *= vec2(step_intensity);
			}
            float f = 1.0;
            if (num_reflections != reflections_left)
            	f = 0.075;
			color.xyz = mix(color.xyz, sample_color, f);
            break;/*
			if (reflections_left == 0) {
				break;
			} else {
				// restart loop starting from new reflection point
				reflections_left -= 1;
				epsilon *= 10.0;
				origin = p + n * epsilon * 2.0;
				dir = normalize(dir-2.0*n*dot(dir,n));
				i = 0;
				t = 0.0;
				max_steps /= 4;
				continue;
			}*/
		}
		t += d * 1.0;
	}
	return vec4(pow(color.xyz, vec3(2.2)), color.w);
}

// Function 496
ray ray_translate(const in ray r, const in vec3 t) {
    ray rt = r;
    rt.origin -= t;
    return rt;
}

// Function 497
float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){
    vec3 pos = start;
    float h = 0.0;
    float hupper = depth;
    float hlower = 0.0;
    vec2 zer = vec2(0.0);
    vec3 dir = normalize(end - start);
    float eps = 0.01;
    for(int i=0;i<318;i++){
        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH/int(1.0+length(pos/100.0))) * depth - depth;
        float dist_pos = distance(pos, camera);
        if(h + eps*dist_pos > pos.y) {
            return dist_pos;
        }
        pos += dir * (pos.y - h);
        eps *= 1.01;
    }
    return -1.0;
}

// Function 498
mat3 OrthoNormalMatrixFromZY( vec3 zDirIn, vec3 yHintDir )
{
	vec3 xDir = normalize( cross( zDirIn, yHintDir ) );
	vec3 yDir = normalize( cross( xDir, zDirIn ) );
	vec3 zDir = normalize( zDirIn );

	mat3 result = mat3( xDir, yDir, zDir );
		
	return result;
}

// Function 499
vec3 normal(vec3 p, int id)
{
    vec2 q = vec2(0,EPS);
    return normalize(vec3(map(p+q.yxx, id) - map(p-q.yxx, id),
                          map(p+q.xyx, id) - map(p-q.xyx, id),
                          map(p+q.xxy, id) - map(p-q.xxy, id)));
}

// Function 500
float RayMarch(vec3 ro, vec3 rd)
{
    float d0 = 0.;
    for(int i = 0; i < Max_Steps; i++)
    {
        vec3 p = ro + rd*d0;
        float ds = GetDist(p);
        d0+=ds;
        if(d0>Max_Dist || ds < Surf_Dist) 
            break;           
    }
                     
    return d0;     
}

// Function 501
vec3 calculateNormal( in vec3 position, in int material )
{
    vec2 e = vec2(epsilon, 0.0);
    vec3 normal = vec3(0.0f);
    switch(material)
    {
        case Lava:
        {
            normal = normalize(mapLavaAndMetal(position) - vec3(mapLavaAndMetal(position-e.xyy),
                                    mapLavaAndMetal(position-e.yxy),
                                    mapLavaAndMetal(position-e.yyx) ) );
            break;
        }
        
        case Glass:
        {
            normal = normalize(mapGlass(position) - vec3(mapGlass(position-e.xyy),
                                    mapGlass(position-e.yxy),
                                    mapGlass(position-e.yyx) ) );
            break;
        }
    }
    return normal;
}

// Function 502
float ObjRayT (vec3 ro, vec3 rd)
{
  vec3 p, rdi;
  vec2 srd, h;
  float dHit, dLim, d;
  RdNZero (rd);
  srd = - sign (rd.xy);
  rdi = 1. / abs (rd.xyz);
  dHit = 0.;
  dLim = rngBlk;
  ro.xy /= fntSize.x;
  rd.xy /= fntSize.x;
  ro.xy += 0.5;
  for (int j = 0; j < 150; j ++) {
    p = ro + dHit * rd;
    h = rdi.xy * fract (srd * p.xy);
    d = max (min (fntSize.x, 1.) * FontTexDf (p.xy), abs (p.z) - 0.5 * fntSize.y);
    dHit += min (d, 0.01 + fntSize.x * min (h.x, h.y));
    if (d < 0.0001 || dHit > dLim) break;
  }
  if (d >= 0.0001) dHit = dstFar;
  return dHit;
}

// Function 503
float rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord, float seedA, float seedB, float speed)
{
	vec2 sourceToCoord = coord - raySource;
	float cosAngle = dot(normalize(sourceToCoord), rayRefDirection);
	
	return clamp(
		(0.45 + 0.15 * sin(cosAngle * seedA + iTime * speed)) +
		(0.3 + 0.2 * cos(-cosAngle * seedB + iTime * speed)),
		0.0, 1.0) *
		clamp((iResolution.x - length(sourceToCoord)) / iResolution.x, 0.5, 1.0);
}

// Function 504
vec3 getNormal(vec3 p)
{
    float d = getDist(p).x;
    
    vec2 e = vec2(0.001, 0.0);
    //vec2 e = vec2(0.1, 0.0);
    
    vec3 n = d - vec3(getDist(p - e.xyy).x,
                  	  getDist(p - e.yxy).x,
                      getDist(p - e.yyx).x);
    
    return normalize(n);
}

// Function 505
void Vector2SphericalNormalized(vec3 v, inout float theta, inout float phi)
{
	theta = acos(v.y) / PI;
	phi = atan(v.x, v.z) / (2.0*PI);
	//phi = (phi < 0.0) ? (phi + 2.0*PI)/(2.0*PI) : (phi/(2.0*PI));
}

// Function 506
vec3 normal(vec3 p) {
    vec2 h = vec2(0.001, 0.0);
    vec3 n = vec3(
        de(p + h.xyy) - de(p - h.xyy),
        de(p + h.yxy) - de(p - h.yxy),
        de(p + h.yyx) - de(p - h.yyx)
	);
    return normalize(n);
}

// Function 507
vec3 normal(vec3 p, float t)
{
    float e = MIN_DIST*t;
    vec2 h =vec2(1,-1)*.5773;
    vec3 n = h.xyy * map(p+h.xyy*e).x+
             h.yyx * map(p+h.yyx*e).x+
             h.yxy * map(p+h.yxy*e).x+
             h.xxx * map(p+h.xxx*e).x;
    return normalize(n);
}

// Function 508
vec3 GetCameraRayDir( const in vec2 vWindow, const in mat3 mCameraRot )
{
	vec3 vDir = normalize( CameraToWorld(vec3(vWindow.x, vWindow.y, 2.0), mCameraRot) );

	return vDir;
}

// Function 509
bool ray_march_hit(vec3 rayOrigin, vec3 rayDir) {
        float distanceTravelled = 0.0;
        const int NUMBER_OF_STEPS = 32;
        const float MINIMUM_HIT_DISTANCE = 0.001;
        const float MAXIMUM_TRACE_DISTANCE = 1000.0;
        for(int i = 0; i < NUMBER_OF_STEPS; i++) {
            vec3 currPos = rayOrigin + distanceTravelled * rayDir;
            float sceneDist = scene_dist(currPos).x;
            if (sceneDist < MINIMUM_HIT_DISTANCE) {
                return true;
            }
            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {
                break;
            }
            distanceTravelled += sceneDist;
        }
        return false;
    }

// Function 510
vec3 CabNormal(vec3 p) {
	float d = CabDist(p).x;
    vec2 e = vec2(1e-4, 0);
    
    vec3 n = d - vec3(
        CabDist(p-e.xyy).x,
        CabDist(p-e.yxy).x,
        CabDist(p-e.yyx).x);
    
    return normalize(n);
}

// Function 511
vec3 ray(vec2 uv, Cam cam)
{
    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);
}

// Function 512
vec4 rayCrystal1(vec3 rp, vec3 rd) {
    rp -= crystal1_pos;
    return rayCrystal1B(rp,rd);
}

// Function 513
vec4 castRay( vec3 startPosition, vec3 lookatDirection )  {
    // return vec4 = last worldPosition, 1 if terrain / 0 if sky
    float step = 0.03;
    float lastStep;
    float altitude = 0.0;
    float lastAltitude;
    float lastY;
    float walkStep = 0.0;
    vec3 p;
	float delta;
    lastStep=step;
    for( int i = 0; i < 180; i++ ) { // GLSL limitation: loop on int only
        p = startPosition + lookatDirection * walkStep;
        altitude = fbm( vec2(p.x, p.z),LOWITER);
		delta = p.y -  altitude;
        if(delta<0.0 ){
            // we are under floor: linear interpolate the intersect
            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);
            p = startPosition + lookatDirection * walkStep;
            altitude = fbm( vec2(p.x, p.z),HIGHITER ); //high definition altitude
            return vec4(p.x,altitude,p.z,walkStep);
        }
        if( p.y <  0.001){
			// under the flow, exit
            walkStep = walkStep - lastStep + lastStep*(lastAltitude-lastY)/(p.y-lastY-altitude+lastAltitude);
            p = startPosition + lookatDirection * walkStep;
            return vec4(p.x,0,p.z,walkStep);
        }
        if (p.y > 5.0) {break;} // far in the sky
        lastAltitude = altitude;
        lastStep=step;
        lastY = p.y;
        step = max(max(0.05,.5*delta) , float(i)/2000.0); // step is big when far from floor and far from camera
		//step+=0.0005;
        walkStep += step;
        
    }
    return  vec4(p.x,p.y,p.z,-walkStep);  
}

// Function 514
ray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom) {
        ray a;
        a.o = camPos;
        vec3 f = normalize(lookat-camPos);
        vec3 r = cross(vec3(0, 1., 0), f);
        vec3 u = cross(f, r);
        vec3 c = a.o + f * zoom;
        vec3 i = c + uv.x * r + uv.y * u;

        a.d = normalize(i - a.o);

        return a;
    }

// Function 515
vec3 ray(vec3 p, vec3 d, vec2 seed)
{
    const float view_distance = 300.0;
    vec3 color = vec3(1);
    vec3 ro = p;
    vec3 rd = d;
    float occ = 1.0;
    vec3 sun = normalize(vec3(-3., 5, -0));
    for (int i = 0; i < 2; i += 1) {
        occ /= 2.0;
        TraceResult r = traceVoxel(ro, rd, view_distance);
        if (!r.hit) {
            color *= texture(iChannel3, rd).xyz;
            break;
        }
        if (r.vp.y >= -0.) {
            if (r.vp.y >= 1.) {
                color *= boxmap(iChannel0, r.p, r.n, 1.0).xyz;//((texture(iChannel0, r.p.xz).xyz)+(texture(iChannel0, r.p.xy).xyz))/2.0;
            } else {
                color *= 0.2;
            }
            vec3 target = r.p + r.n + rus(rd.xy+float(i)+seed);
            rd = target - r.p;
        } else {
            color *= vec3(1.0, 0.5, 0.125)*texture(iChannel0, r.p.xz).xyz*10.0;
            rd = reflect(rd, r.n);
            break;
        }
        ro = r.p;
    }
    return color;//vec3(r.hit : r.n ? 0.0);
}

// Function 516
vec3 textureNormal(vec2 uv) {
    vec3 normal = texture( iChannel1, 100.0 * uv ).rgb;
    normal.xy = 2.0 * normal.xy - 1.0;
    
    // Adjust n.z scale with mouse to show how flat normals behave
    normal.z = sqrt(iMouse.x / iResolution.x);
    return normalize( normal );
}

// Function 517
Ray getRay(vec2 uv)
{
    float dis=1./tan(.5*cam.fov*PI/180.);
    return Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+cam.f*dis));
}

// Function 518
vec3 sceneNormal(vec3 p) {
    vec3 v1 = vec3(1.0, -1.0, -1.0);
    vec3 v2 = vec3(-1.0, -1.0, 1.0);
    vec3 v3 = vec3(-1.0, 1.0, -1.0);
    vec3 v4 = vec3(1.0, 1.0, 1.0);
    return normalize(
        v1 * sceneSDF(p + v1*EPSILON).x +
        v2 * sceneSDF(p + v2*EPSILON).x +
        v3 * sceneSDF(p + v3*EPSILON).x +
        v4 * sceneSDF(p + v4*EPSILON).x
    );
}

// Function 519
vec2 rayMarching(vec3 ro, vec3 rd) {
    float tmax = MAX_DIST;
    float t = 0.0;
    vec2 result = vec2(-1.0);
    
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ro + rd * t;
        vec2 res = sceneSDF(p);
        if (res.x < EPSILON || t > tmax) break;
        result.x = t;
        result.y = res.y;
        t += res.x;
    }
    if (t > tmax) {
        result.x = tmax;
        result.y = -1.0;
    }
    return result;
}

// Function 520
vec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { 
	
    // It's worth looking into using a fixed epsilon versus using an epsilon value that
    // varies with resolution. Each affects the look in different ways. Here, I'm using
    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.
    // As for accounting for PPI; There's not a lot I can do about that.
    vec2 e = vec2(3./mix(450., min(850., iResolution.y), .35), 0);//*(1. + t*t*.7);

	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
     
    // Wider sample spread for the curvature.
    //e = vec2(12./450., 0);
	//d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	//d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	//d5 = map(p + e.yyx), d6 = map(p - e.yyx);
    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
 
    
    e = vec2(.001, 0); //iResolution.y - Depending how you want different resolutions to look.
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 521
vec3 getNormal(vec3 p)
{
    vec2 d = vec2(0.01, 0.0);
    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),
                     	  distFunc(p + d.yxy) - distFunc(p - d.yxy),
 	                      distFunc(p + d.yyx) - distFunc(p - d.yyx)));
}

// Function 522
vec3 sdfNormal(vec3 p, float epsilon)
{
    vec3 eps = vec3(epsilon, -epsilon, 0.0);
    
	float dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);
	float dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);
	float dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); 

	return normalize(vec3(dX,dY,dZ));
}

// Function 523
vec3 createRay (in vec2 uv) {
	return normalize(vec3(uv, 1.0)) * camMatrix;
}

// Function 524
vec3 normal(in Ray ray) {
    vec2 eps = vec2(0.0001, 0);
    float baseDist = sceneDist(ray);
 	return normalize(vec3(
        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)) - baseDist,
        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)) - baseDist,
        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)) - baseDist
        ));
}

// Function 525
vec3 calcNormal( in vec3 pos, in float ep )
{
    vec4 kk;
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + 
					  e.yyx*map( pos + e.yyx*ep, kk, false ) + 
					  e.yxy*map( pos + e.yxy*ep, kk, false ) + 
					  e.xxx*map( pos + e.xxx*ep, kk, false ) );
#else
    // prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*ep, kk, false);
    }
    return normalize(n);
#endif    
    
}

// Function 526
vec3 normal(in vec3 position) {
    vec3 epsilon = vec3(0.001, 0.0, 0.0);
    vec3 n = vec3(
          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,
          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,
          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);
    return normalize(n);
}

// Function 527
vec3 getNormal(vec3 pos, float e, bool inside)
{  
    vec2 q = vec2(0, e);
    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),
                          map(pos + q.xyx) - map(pos - q.xyx),
                          map(pos + q.xxy) - map(pos - q.xxy)));
}

// Function 528
vec4 castRay(vec3 eye, vec3 ray, vec2 center) {
    vec2 block = floor(eye.xy);
    vec3 ri = 1.0 / ray;
    vec3 rs = sign(ray);
    vec3 side = 0.5 + 0.5 * rs;
    vec2 ris = ri.xy * rs.xy;
    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;

    for (int i = 0; i < 16; ++i) {
        float d = dot(block - center, cameraDir.xy);
        float height = 3.0 * hash1(block) - 1.0 + 1.5 * d - 0.1 * d * d;

        vec2 lo0 = vec2(block);
        vec2 loX = vec2(0.45, 0.45);
        vec2 hi0 = vec2(block + 0.55);
        vec2 hiX = vec2(0.45, 0.45);

        float dist = 500.0;
        float face = 0.0;

        {
            vec4 signHash = hash4(block);
            vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;
            float width = 0.06 + 0.1 * signHash.w;

            vec3 lo = vec3(center.x - width, 0.55, -100.0);
            vec3 hi = vec3(center.x + width, 0.99, center.y + width + height);

            float s = step(0.5, signHash.z);
            lo = vec3(block, 0.0) + mix(lo, lo.yxz, s);
            hi = vec3(block, 0.0) + mix(hi, hi.yxz, s);

            vec3 wall = mix(hi, lo, side);
            vec3 t = (wall - eye) * ri;

            vec3 dim = step(t.zxy, t) * step(t.yzx, t);
            float maxT = dot(dim, t);
            float maxFace = dim.x - dim.y;

            vec3 p = eye + maxT * ray;
            dim += step(lo, p) * step(p, hi);

            if (dim.x * dim.y * dim.z > 0.5) {
                dist = maxT;
                face = maxFace;
            }
        }

        for (int j = 0; j < 5; ++j) {
            float top = height - 0.4 * float(j);
            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), -100.0);
            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);

            vec3 wall = mix(hi, lo, side);
            vec3 t = (wall - eye) * ri;

            vec3 dim = step(t.zxy, t) * step(t.yzx, t);
            float maxT = dot(dim, t);
            float maxFace = dim.x - dim.y;

            vec3 p = eye + maxT * ray;
            dim += step(lo, p) * step(p, hi);

            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {
                dist = maxT;
                face = maxFace;
            }
        }

        if (dist < 400.0) {
            return vec4(dist, height, face, 1.0);
        }

        float t = eye.z * ri.z;
        vec3 p = eye - t * ray;
        vec2 g = p.xy - block;

        vec2 dim = step(dis.xy, dis.yx);
        dis += dim * ris;
        block += dim * rs.xy;
    }

    return vec4(100.0, 0.0, 0.0, 1.0);
}

// Function 529
vec3 getNormal(vec2 uv, int tex ) {
    return vec3(0.0, 0.0, 1.0);
}

// Function 530
vec3 Raymarche(vec3 org, vec3 dir, int step)
{
	float d=0.0;
	vec3 p=org;
	
	for(int i=0; i<64; i++)
	{
		d = scene(p);
		p += d * dir;
	}
	
	return p;
}

// Function 531
vec3 normal(vec2 p) {
  vec2 v;
  vec2 w;
  vec2 e = vec2(0.0001, 0);
  
  vec3 n;
  n.x = fbm(p + e.xy) - fbm(p - e.xy);
  n.y = 2.0*e.x;
  n.z = fbm(p + e.yx) - fbm(p - e.yx);
  
  return normalize(n);
}

// Function 532
float rayMarch(in vec3 ro, in vec3 rd, out int mr) {
	float dO = 0.0;
    
    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {
		vec3 p = ro + rd * dO;
        float dS = getDist(p);
        dO += dS;
        if (dO > RAYMARCH_MAX_DIST) break;
        if (dS < RAYMARCH_SURFACE_DIST) {
            mr = 1;
            break;
        }
    }
    
    return dO;
}

// Function 533
vec3 normal( in vec3 p, in vec3 proj ) {
    vec2 dir = proj.xy - p.xy;
    vec3 tang = vec3(dir, proj.z*0.12);
    vec3 nine = vec3(dir, 0).yxz;
    nine.x = -nine.x;
    return normalize(cross(nine, tang));
}

// Function 534
vec3 normalSea(vec3 P, vec3 up, vec3 tgt, float e)
{
 	vec3 n;
    vec3 t1 = cross(up, tgt);
    n.y = mapSea(P+up*e, up);
    n.x = mapSea(P+t1*e, up) - n.y;
    n.z = mapSea(P+tgt*e, up) - n.y;
    n.y = e;
    n = up*n.y + t1*n.x + tgt*n.z;
    return normalize(n);
}

// Function 535
vec3 calculate_normal( in vec3 pos)
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.0005;
    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + 
					  e.yyx*map_the_world( pos + e.yyx ).x + 
					  e.yxy*map_the_world( pos + e.yxy ).x + 
					  e.xxx*map_the_world( pos + e.xxx ).x );  
}

// Function 536
vec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)
{
    // Calculate camera's "orthonormal basis", i.e. its transform matrix components
    vec3 camForward = normalize(camTarget - camPos);
    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));
     
    float fPersp = 2.0;
    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);
 
    return vDir;
}

// Function 537
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce ) {
    specularBounce = false;
    
    lowp vec3 r = cosWeightedRandomHemisphereDirection( n );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        lowp float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1.0; 
            n2 = 1.5;
            n = -n;
        } else {
            n1 = 1.5;
            n2 = 1.0; 
        }

        lowp float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		lowp float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),2.);
        
        lowp vec3 ref;
        
        if( hash1() < fresnel ) {
            ref = reflect( rd, n );
        } else {
            ref = refract( rd, n, n2/n1 );
        }
        
        return normalize( ref + 0.1 * r );
	}
}

// Function 538
vec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){

  //First we set some default values
 
  
  // our distance to surface will get overwritten every step,
  // so all that is important is that it is greater than our
  // 'how close is close enough' value
  float distanceToSurface 			= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;
    
  // The total distance traveled by the ray obviously should start at 0
  float totalDistanceTraveledByRay 	= 0.;
    
  // if we hit something, this value will be overwritten by the
  // totalDistance traveled, and if we don't hit something it will
  // be overwritten by the furthest our ray can reach,
  // so it can be whatever!
  float finalDistanceTraveledByRay 	= -1.;
    
  // if our id is less that 0. , it means we haven't hit anything
  // so lets start by saying we haven't hit anything!
  float finalID = -1.;

    
    
  //here is the loop where the magic happens
  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){
      
    // First off, stop the iteration, if we are close enough to the surface!
    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;
      
    // Second off, stop the iteration, if we have reached the end of our scene! 
    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;
    
    // To check how close we are to things in the world,
    // we need to get a position in the scene. to do this, 
    // we start at the rays origin, AKA the eye
    // and move along the ray direction, the amount we have already traveled.
    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;
    
    // Distance to and ID of things in the world
    //--------------------------------------------------------------
	// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'
	//--------------------------------------------------------------
    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );
      
      
 	// we get out the results from our mapping of the world
    // I am reassigning them for clarity
    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;
    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;
     
    // We save out the distance to the surface, so that
    // next iteration we can check to see if we are close enough 
    // to stop all this silly iteration
    distanceToSurface           = distanceToThingsInTheWorld;
      
    // We are also finalID to the current closest id,
    // because if we hit something, we will have the proper
    // id, and we can skip reassigning it later!
    finalID = idOfClosestThingInTheWorld;  
     
    // ATTENTION: THIS THING IS AWESOME!
   	// This last little calculation is probably the coolest hack
    // of this entire tutorial. If we wanted too, we could basically 
    // step through the field at a constant amount, and at every step
    // say 'am i there yet', than move forward a little bit, and
    // say 'am i there yet', than move forward a little bit, and
    // say 'am i there yet', than move forward a little bit, and
    // say 'am i there yet', than move forward a little bit, and
    // say 'am i there yet', than move forward a little bit, and
    // that would take FOREVER, and get really annoying.
      
    // Instead what we say is 'How far until we are there?'
    // and move forward by that amount. This means that if
    // we are really far away from everything, we can make large
    // movements towards the surface, and if we are closer
    // we can make more precise movements. making our marching functino
    // faster, and ideally more precise!!
      
    // WOW!
      
    totalDistanceTraveledByRay += distanceToThingsInTheWorld;
      

  }

  // if we hit something set the finalDirastnce traveled by
  // ray to that distance!
  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){
  	finalDistanceTraveledByRay = totalDistanceTraveledByRay;
  }
    
    
  // If the total distance traveled by the ray is further than
  // the ray can reach, that means that we've hit the edge of the scene
  // Set the final distance to be the edge of the scene
  // and the id to -1 to make sure we know we haven't hit anything
  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ 
  	finalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;
    finalID = -1.;
  }

  return vec2( finalDistanceTraveledByRay , finalID ); 

}

// Function 539
vec3 calculateNormal(in vec3 point)
{
    vec2 h = vec2(EPSILON, 0.0); // Some small value(s)
    return normalize(vec3(scene(point + h.xyy).x - scene(point - h.xyy).x,
                          scene(point + h.yxy).x - scene(point - h.yxy).x,
                          scene(point + h.yyx).x - scene(point - h.yyx).x));
}

// Function 540
maybe_float get_distance_along_3d_line_nearest_to_ray(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B
){
    vec3 D = B0 - A0;
    // offset
    vec3 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 541
vec2 RayMarch(vec3 ro, vec3 rd){
    // distance from origin
    vec2 dO=vec2(0.,0.);
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO.x*rd;
        
        // get distance to seam
        vec2 ds = GetDist(p);
        //move origin to new point
        
        /*if(ds.y==7.){
            dO+=ds.x*.4;
        }
        else{
            dO+=ds.x*.7;
        }*/
         dO+=ds.x*.8;
        if(ds.x < SURFACE_DIST){
            dO.y = ds.y;
            break;
        }
        else if( dO.x > MAX_DIST){
            dO.y= -1.;
            break;
        }
    }
    return dO;
}

// Function 542
vec4 ray(vec3 p, vec3 d)
{
    float k = min_distance;
    for (int j = 0; j < max_reflections; ++j)
    {
        for (int i = 0; i < maxsteps; ++i)
        {
            if (k > max_distance)
                return texture(iChannel0, d);
            float ss = stepsize(p + d * k);
            if (f(p + d * (k + ss)) < 0.0)
            {
                k += ss - min_stepsize * 0.5;
                k += f(p + d * k) / dot(d, fd(p + d * k));
                k += f(p + d * k) / dot(d, fd(p + d * k));
                p += d * k;
                d = reflect(d, normalize(fd(p)));
                k = 0.0;
                break;
            }
            k += ss;
        }
    }
    return texture(iChannel0, d);
}

// Function 543
vec3 getRayDir(in vec2 uv)
{
    return normalize(vec3(uv, -1.0));
}

// Function 544
float SceneRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d, eps;
  eps = 0.0001;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    d = SceneDf (ro + dHit * rd);
    dHit += d;
    if (d < eps || dHit > dstFar || p.y < 0.) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 545
vec3 rayMarch(vec3 rayDir, vec3 cameraOrigin)
{
    const int maxItter = 100;
	const float maxDist = 30.0;
    
    float totalDist = 0.0;
	vec3 pos = cameraOrigin;
	vec4 dist = vec4(epsilon);
    
    for(int i = 0; i < maxItter; i++)
	{
		dist = distfunc(pos);
		totalDist += dist.x;
		pos += dist.x * rayDir;
        
        if(dist.x < epsilon || totalDist > maxDist)
		{
			break;
		}
	}
    
    return vec3(dist.x, totalDist, dist.y);
}

// Function 546
vec3 calcNormal(vec3 p)
{
    const vec3 eps = vec3(0.001, 0., 0.);
    
    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;
    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;
    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;
    
    return normalize(vec3(deltaX, deltaY, deltaZ));
}

// Function 547
float castRay( in vec3 ro, in vec3 rd, inout float depth )
{
	float t = 15.0;
	float res;
	for( int i=0; i<RAYMARCHING_STEP; i++ )
	{
		vec3 pos = ro+rd*t;
		res = map( pos );
		if( res < 0.01 || t > 150. ) break;
		t += res*RAYMARCHING_JUMP;
		depth += 1./float(RAYMARCHING_STEP);
	}
	return t;
}

// Function 548
vec3 CAM_getRay(Cam cam,vec2 uv)
{
    uv = cam.lens*uv/(cam.lens-length(uv)*length(uv));
    uv *= cam.zoom;
    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);
}

// Function 549
vec3 furNormal(vec3 pos, float density)
{
    float eps = 0.01;
    vec3 n;
	vec2 uv;
    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;
    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;
    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;
    return normalize(n);
}

// Function 550
vec3 marchRay(vec3 eyePos,vec3 dir)
{
    vec3 color = vec3(0);
    vec3 currentPoint = eyePos;
    while(length(currentPoint) < MAX_DISTANCE)
    {
        vec3 sceneCol1, sceneCol2;
        float dist = sceneDf(currentPoint, sceneCol1, sceneCol2);
        if(dist <= MIN_DISTANCE)
        {
            color = processLighting(sceneCol1, sceneCol2, eyePos, currentPoint);
            float absz = -currentPoint.z;
            color *= 1.0-vec3(max(absz - 40.0, 0.0)/10.0);
            break;
        }
        currentPoint += (dist * dir);
    }
    return color;
}

// Function 551
vec3 getRayDirection(vec2 pos, vec2 res, float fov)
{
	float fx = tan(radians(fov) * 0.5) / res.x;
	vec2 d = (2.0 * pos - res) * fx;
	return normalize(vec3(d, 1.0));
}

// Function 552
vec3 calcNormal( in vec3 pos)
{
    vec2 e = vec2(1.0,-1.0)*EPSILON_NRM;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 553
ray camera_get_ray(camera c, vec2 uv) {
    return ray(c.origin, 
               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin));
}

// Function 554
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,3.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 555
vec3 sphNormal( in vec3 pos, in vec4 sph )
{
    return normalize(pos-sph.xyz);
}

// Function 556
vec3 calcNormal(vec3 p, float t) {
    vec2 e = vec2(MIN_DIST*t,0.);
    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),
                  dstScene(p+e.yxy)-dstScene(p-e.yxy),
                  dstScene(p+e.yyx)-dstScene(p-e.yyx));
    return normalize(n);
}

// Function 557
vec3 raycast(vec3 ro, vec3 rd, out bool hit)
{
    hit = false;
    vec3 pos = ro;

    for(int i=0; i<maxSteps; i++)
    {
        float d = network(pos);
        //float d = sphere(pos, 0.5);
        if (abs(d) < hitThreshold) {
            hit = true;
            break;
        }
        pos += d*rd;
    }
    return pos;
}

// Function 558
vec3 normal(const in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.005;
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 559
vec3 getRay(vec2 pos)
{
    rmat = getRot(angles);
    vec2 uv = FOV*(pos - R*0.5)/R.x;
    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);
}

// Function 560
vec3 drawPathAndNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec3 pathColor, in float normLength )
{
    vec3 d = vec3(1000.0);
    for( int i=0; i<kNumPoints; i++ )
    {
        vec2 a = path[(i-1+kNumPoints)%kNumPoints];
        vec2 b = path[(i+0+kNumPoints)%kNumPoints];
        vec2 c = path[(i+1+kNumPoints)%kNumPoints];

        vec2 n = computeTangent( a, b, c );
        
        n = normLength*normalize(vec2(n.y, -n.x ));

        d = min( d, vec3(sdSegmentSq(p,b,c), 
                         sdPointSq(p,b),
                         sdSegmentSq(p,b,b+n)) );
    }
    d = sqrt(d);

    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.x) );
    col = mix( col, pathColor, 1.0-smoothstep(5.0*e,6.0*e,d.y) );
    col = mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d.z) );
    
    return col;
}

// Function 561
Material NormalMaterial(vec3 albedo, int flags)
{
    return Material(albedo, flags);
}

// Function 562
vec3 getNormal(in vec2 sphereCenter, in float sphereRadius, in vec2 point){
	// Need to figure out how far the current point is from the center to lerp it
	float distFromCenter = distance(point, sphereCenter);
	float weight = distFromCenter/sphereRadius;
	
	// Z component is zero since at the edge the normal will be on the XY plane
	vec3 edgeNormal = vec3(point - sphereCenter, 0);
	edgeNormal = normalize(edgeNormal);
	
	// We know the normal at the center of the sphere points directly at the viewer,
	// so we can use that in our mix/lerp.
	return mix(vec3(0,0,1), edgeNormal, weight); 
}

// Function 563
Ray createRayPerspective(in vec2 resolution, in vec2 screenPosition,
                         in float verticalFov) {
  vec2 topLeft = vec2(-resolution.x, -resolution.y) * .5;
  float z = (resolution.x * .5) / abs(tan(verticalFov / 2.0));

  return Ray(vec3(0.0),
             normalize(vec3(topLeft + screenPosition, -z)));
}

// Function 564
vec3 NormalSinPowWarp(vec3 pos, float freq, float amp, float power) {
    vec3 dir = normalize(pos);
	vec3 warp = abs(sin(dir*freq));
	float mw = max(max(warp.x,warp.y), warp.z);
	mw = pow(mw, power);
	return pos - dir * mw * amp;
}

// Function 565
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    scene(pos+eps.xyy) - scene(pos-eps.xyy),
	    scene(pos+eps.yxy) - scene(pos-eps.yxy),
	    scene(pos+eps.yyx) - scene(pos-eps.yyx));
	return normalize(nor);
}

// Function 566
float myreflect( float x, float a ) { return a + ( a - x ); }

// Function 567
float raymarch(vec3 cam_pos, vec3 march_dir, float t) {
    float depth = MIN_DIST;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = scene(cam_pos + depth * march_dir, t);
        if (dist < EPS) {
            return depth;
        }
        depth += dist;
        if (depth >= MAX_DIST) {
            return MAX_DIST;
        }
    }
    return MAX_DIST;
}

// Function 568
vec3 castRay(in vec3 ro, in vec3 rd, in float mint, in float maxt)
{
    float t = mint;
    
    for (int i = 0; i < 96; i++)
    {
        vec3 p = ro + rd*t;
        float dist = map(p);
        
        if (dist <= 0.0 || t > maxt)
            break;
        
        t += max(dist, 0.0001);
    }
    
    return ro + rd*min(t, maxt);
}

// Function 569
vec3 doNormal(vec3 pos, bool ignoreSpecs)
{

	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    DF(pos+eps.xyy, ignoreSpecs) - DF(pos-eps.xyy, ignoreSpecs),
	    DF(pos+eps.yxy, ignoreSpecs) - DF(pos-eps.yxy, ignoreSpecs),
	    DF(pos+eps.yyx, ignoreSpecs) - DF(pos-eps.yyx, ignoreSpecs));
	return normalize(nor);
}

// Function 570
vec3 getNormal(vec3 p) {
	vec2 t = vec2(0.001,0.);    
    return normalize(vec3(
    	map(p + t.xyy).d - map(p - t.xyy).d,
    	map(p + t.yxy).d - map(p - t.yxy).d,
    	map(p + t.yyx).d - map(p - t.yyx).d
    ));
}

// Function 571
vec3 estimate_normal(vec3 p, vec3 ro) {
  return normalize(vec3(
    sdf_scene(vec3(p.x + RENDER_EPSILON, p.y, p.z), ro)
    - sdf_scene(vec3(p.x - RENDER_EPSILON, p.y, p.z), ro),
    sdf_scene(vec3(p.x, p.y + RENDER_EPSILON, p.z), ro)
    - sdf_scene(vec3(p.x, p.y - RENDER_EPSILON, p.z), ro),
    sdf_scene(vec3(p.x, p.y, p.z + RENDER_EPSILON), ro)
    - sdf_scene(vec3(p.x, p.y, p.z - RENDER_EPSILON), ro)
    ));
}

// Function 572
Object rayMarching(vec3 origin, vec3 direction, out vec3 p)
{
    float currentDistance = 0.0;

    Object res=Object(0.0,vec3(0.0,0.0,0.0));

    float lowerThreshold=0.001;
    float upperThreshold=30.0; 
    for(int i=0;i<maxIterations;i++)
    {
        p=origin+direction*currentDistance;
	Object obj=map(p);
	float distanceToClosestSurface = obj.distance;
        currentDistance += distanceToClosestSurface;
        if(distanceToClosestSurface<lowerThreshold)
	{
	  return obj;
	  break;
	}
        
        if(distanceToClosestSurface>upperThreshold)
        {
            currentDistance=0.0;
            break;
        }
    }

    return res;
}

// Function 573
vec2 rayMarch( in vec3 origin, in vec3 direction ) {
    vec2 total = vec2( .0 );
    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {
        vec3 point = origin + direction * total.x;
        vec2 current = sceneDistance( point, total.x );

#ifdef THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION
        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {
            break;
        }
        // Note: Ray advancement occurs after checking for a surface hit.
        //
        // Ray shortening: Shorter for the first few iterations.
        total.x += i<32? current.x*.35 : current.x*.85; 
        total.y = current.y;
#else
        total.x += current.x;
        total.y = current.y;

        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {
            break;
        }     
#endif

    }
    return total;
}

// Function 574
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
}

// Function 575
Hit raymarch(vec3 eye, vec3 ray){
	float dsum = 0.0;
	for(int i=0; i<iterations; i++){
		vec3 p = eye + dsum*ray;
		float dmin = dist(p);
		if(dmin < threshold){
			return Hit(p, grad(p), dsum);
		} else {
			dsum += max(min_step, dmin*step_fraction);
		}
	}
	
	vec3 p = eye + dsum*ray;
	return Hit(p, grad(p), dsum);
}

// Function 576
vec3 EstimateNormal(vec3 p) {

    #define ZERO (min(iFrame,0)) // non-constant zero
    
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy * SceneSDF( p + k.xyy * EPSILON ) + 
                      k.yyx * SceneSDF( p + k.yyx * EPSILON ) + 
                      k.yxy * SceneSDF( p + k.yxy * EPSILON ) + 
                      k.xxx * SceneSDF( p + k.xxx * EPSILON ) );
}

// Function 577
vec3 getNormal(vec3 p, float t){
    float eps = 0.001 * t;

    return normalize(vec3( 
        getHeight(vec3(p.x-eps, p.y, p.z), normalLimit) 
        - getHeight(vec3(p.x+eps, p.y, p.z), normalLimit),
        
        2.0*eps,
        
        getHeight(vec3(p.x, p.y, p.z-eps), normalLimit) 
        - getHeight(vec3(p.x, p.y, p.z+eps), normalLimit) 
    ));
}

// Function 578
vec4 castRay(in vec4 pos, in vec4 direction)
{
    vec4 rayPos = pos+0.25*direction;
    vec4 rayDirection = direction;
    float distance = 0.0;
    float rayDistance = distance;
    
    float iterations = 0.0;
    
    for (int i = 0; i < ITERATIONS; ++i)
    {
        iterations += 1.0;
        
        
        vec2 mapPoint = map(rayPos);
        distance = max(mapPoint.y, 0.25*mapPoint.x);
        
        rayPos += distance*rayDirection;
        rayDistance += distance;
        
        if (mapPoint.x < EPSILON) break;
        if (rayDistance  > FAR) break;
        
    }
    
    
    vec4 lightdir = normalize(vec4(0.0, 0.0, 0.0, 1.0));
    vec4 normal = calculateNormal(rayPos, EPSILON);
    
    
    vec3 aura = vec3(1.0)*iterations/float(ITERATIONS)/pow(rayDistance*0.0625, 0.5);
    vec3 color = vec3(0.0, 0.2, 0.0)*(dot(lightdir, normal))/pow(rayDistance*0.25, 0.5);
    
    if (distance < 0.1)
       return vec4(vec3(color+aura-0.25), 1.0);
    else
   		return vec4(vec3(aura-0.25), 1.0);
}

// Function 579
vec3 calcNormal( in vec3 pos, in vec3 rd )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e, rd).x;
    }
    return normalize(n);
#endif    
}

// Function 580
vec3 normal_o354282(vec3 p) {
	float d = o354282_input_in1(p);
    vec2 e = vec2(.001,0);
    vec3 n = d - vec3(
        o354282_input_in1(p-vec3(e.xyy)),
        o354282_input_in1(p-vec3(e.yxy)),
        o354282_input_in1(p-vec3(e.yyx)));
    return normalize(n);
}

// Function 581
vec3 RayDir(vec2 pixPos,
            vec2 viewSizes)
{
    vec3 dir = vec3(pixPos - (viewSizes / 2.0),
                	viewSizes.y / tan(1.62 / 2.0));
    return normalize(dir);
}

// Function 582
vec3 reCalcNormalFast(vec2 uv)
{
    float offsetPixel = 1.0;
    
    vec3 center = reCalcWorldPosition(uv);
    
    // Only sample two points, but vary which ones per frame in the hopes that temporal AA will smooth out artifacts
    if(iFrame % 4 == 0)
    {
        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));
        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));
    
        return normalize(cross(up-center, center-right));
    }
    else if(iFrame % 4 == 1)
    {
        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));
        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));

        return normalize(cross(center-down, left-center));
    }
    else if(iFrame % 4 == 2)
    {
        vec3 up = reCalcWorldPosition(uv+vec2(0, offsetPixel/iResolution.y));
        vec3 left = reCalcWorldPosition(uv+vec2(-offsetPixel/iResolution.x, 0));

        return normalize(cross(up-center, left-center));
    }
    else
    {
        vec3 down = reCalcWorldPosition(uv+vec2(0, -offsetPixel/iResolution.y));
        vec3 right = reCalcWorldPosition(uv+vec2(offsetPixel/iResolution.x, 0));

        return normalize(cross(center-down, center-right));
    }
}

// Function 583
float rayMarch(vec3 rayDir, vec3 cameraOrigin)
{
    const int MAX_ITER = 50;
	const float MAX_DIST = 30.0;
    
    float totalDist = 0.0;
    float totalDist2 = 0.0;
	vec3 pos = cameraOrigin;
	float dist = EPSILON;
    vec3 col = vec3(0.0);
    float glow = 0.0;
    
    for(int j = 0; j < MAX_ITER; j++)
	{
		dist = distfunc(pos);
		totalDist = totalDist + dist;
		pos += dist*rayDir;
        
        if(dist < EPSILON || totalDist > MAX_DIST)
		{
			break;
		}
	}
    
    return totalDist  ;
}

// Function 584
vec3 ComputeReflection(in RayIntersection ri)
{
    vec4 o = vec4(0);
    
    Ray bounceRay;
    bounceRay = ri.ray;
    float bouncedDist = 0.;
    
    int i=0;
    while (i<MAX_BOUNCES)
    {
        i++;
        bounceRay.o = ri.pos + ri.shape.normal.xyz * EPSILON;
        bounceRay.d = reflect(bounceRay.d, ri.shape.normal.xyz);
        bounceRay.n = 1.;

        ri = CastRay(bounceRay, MAX_REFLECTION_DIST);
        bouncedDist += ri.dist;

        if (ri.shape.type == NO_SHAPE)
        {
            break;
        }
        else if (ri.shape.isEmissive)
        {
            o = ri.shape.color;
            break;
        }

        o.rgb += SampleLights(ri) *
        		 clamp((MAX_REFLECTION_DIST - bouncedDist) / MAX_REFLECTION_DIST,
                         0., 1.);
		if (ri.shape.glossy == 0.) break;
    }
    
	return o.rgb / float(i);
}

// Function 585
vec3 calcNormal( in vec3 pos, in float time )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.00025;
    return normalize( e.xyy*map( pos + e.xyy*eps, time ) + 
					  e.yyx*map( pos + e.yyx*eps, time ) + 
					  e.yxy*map( pos + e.yxy*eps, time ) + 
					  e.xxx*map( pos + e.xxx*eps, time ) );
}

// Function 586
vec3 rayMarching(vec3 start,vec3 dir,float maxDepth){
    vec3 steps=-dir/dir.z*maxDepth/float(iteration);
    vec3 pos=start;
    for(int i=0;i<iteration+1;i++){
        vec3 next=pos+steps;
        if(next.z+texDepth(next.xy)<0.){
            for(int j=0;j<binaryPass;j++){
                vec3 mid=(pos+next)/2.;
                if(mid.z+texDepth(mid.xy)<0.){
                    next=mid;
                }else{
                	pos=mid;
                }
            }
            return pos;
        }
        pos=next;
    }
    return pos;
}

// Function 587
vec3 genNormal(vec3 p){
	vec3 normal=vec3(
		sdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),
		sdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),
		sdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))
		);
	return normalize(normal);
}

// Function 588
vec3 normal(vec3 p)
{
  vec2 e = vec2(.05,.0);
  float d = map(p);
  return normalize(vec3(
    d - map(p + e.xyy),
    d - map(p + e.yxy),
    d - map(p + e.yyx)
  ));
}

// Function 589
vec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fov) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 590
vec3 SceneNormal( in vec3 pos, mat3 localToWorld )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),
	    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),
	    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );
	return normalize( -nor );
}

// Function 591
Hit raymarch(vec3 eye, vec3 ray){
	float dsum = 0.0;
	for(int i=0; i<iterations; i++){
		vec3 p = eye + dsum*ray;
		float dmin = dist(p);
		if(dmin < threshold){
			return Hit(p, grad(p), dsum);
		} else {
			dsum += max(min_step, dmin*step_fraction);
		}
	}
	
	vec3 p = eye + dsum*ray;
	return Hit(p, vec3(0), dsum);
}

// Function 592
vec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld)
{
    const float maxd = 5.0;
    
	float h = 0.5;
    float t = 0.0;
    float steps = 0.0;
   
    for ( int i = 0; i < 200; ++i )
    {
        if ( h < 0.001 || t > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t, localToWorld )/4.0;
        t += h;
        steps += 1.0;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }
	
    return vec2(t, steps);
}

// Function 593
vec3 calculate_normal(in vec3 world_point)
{
    const vec3 small_step = vec3(0.0025, 0.0, 0.0);

    float gradient_x = distance_to_closest_object(world_point + small_step.xyy)
        - distance_to_closest_object(world_point - small_step.xyy);
    float gradient_y = distance_to_closest_object(world_point + small_step.yxy) 
        - distance_to_closest_object(world_point - small_step.yxy);
    float gradient_z = distance_to_closest_object(world_point + small_step.yyx) 
        - distance_to_closest_object(world_point - small_step.yyx);

    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

    return normalize(normal);
}

// Function 594
vec3 reflectionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, inout vec3 att) {
	for (float i = 0.0; i < 2.0; i++) {
        Hit icp = marching(ori, dir, 1.0);
        vec3 interP = ori + icp.dist * dir; 
        vec3 nor = getNormal(interP);
        Material mat = getMaterial(icp.matIndex);
        if (icp.matIndex < 0) {
            pixColor += vec3(0.0);//mix(pixColor, backColor, att);
        } else {
            vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); 
            pixColor = mix(pixColor, localColor, att);
            dir = reflect(dir, nor);
            ori = interP + dir * EPSILON;
            att *= mat.reflection;
        }
    }
    return pixColor;
}

// Function 595
Quaternion H_normalize(Quaternion h)
{
    return normalize(h);
}

// Function 596
vec3 rayCastScene(in Ray originalRay, in Scene scene){
    const vec3 ambientColor = vec3(0.2, 0.2, 0.2);
    vec3 finalColor = vec3(0.0);
    
    Ray curRay = originalRay;
    float baseFogDist = 0.0;
  	float subRayMultiplier = 1.0;
    
    for (int i = 0; i < maxSurfaceHits; i++){    
    	RayHit curHit = rayCastBase(curRay, scene);

    	float rayDot = clamp(dot(-curRay.dir, curHit.n), 0.0, 1.0);
   		float fresnSimple = 1.0 - rayDot;
    	fresnSimple = mix(0.1, 1.0, fresnSimple * fresnSimple);
        //fresnSimple = 0.5;    
    
    	vec3 baseColor = curHit.color;
    	vec4 worldPos = curHit.dist * curRay.dir + curRay.start;
    	vec4 worldNormal = curHit.n;
    
    	float lightFactor = getLightFactor(scene.sunPos, worldPos, worldNormal, scene);
        
        vec3 curFinalColor = vec3(0.0);
        curFinalColor += baseColor * ambientColor;
        curFinalColor += baseColor * lightFactor;
        curFinalColor = applyFog(curFinalColor, curHit.dist + baseFogDist);
            
        finalColor = mix(finalColor, curFinalColor, subRayMultiplier);
    	//finalColor += addedLight * subRayMultiplier;
        
    	const float bounceBias = 0.001;
    	vec4 reflected = reflect(curRay.dir, curHit.n);
    	vec4 curPos = curRay.start + curRay.dir * curHit.dist;
    	Ray nextRay = Ray(curPos + reflected * bounceBias, reflected);            
        baseFogDist += curHit.dist + bounceBias;
        
        subRayMultiplier *= fresnSimple;
        curRay = nextRay;
        //break;
    }
    
    return finalColor;
    //return applyFog(finalColor, curHit.dist);
}

// Function 597
vec3 calculate_normal(vec3 p) {
        const vec3 step = vec3(0.001, 0.0, 0.0);
        float gradX = scene_dist(p + step.xyy).x - scene_dist(p - step.xyy).x;
        float gradY = scene_dist(p + step.yxy).x - scene_dist(p - step.yxy).x;
        float gradZ = scene_dist(p + step.yyx).x - scene_dist(p - step.yyx).x;
        return normalize(vec3(gradX, gradY, gradZ));
    }

// Function 598
vec4 Raymarcher(vec3 p,vec3 dir,bool A)
{
    float tmin = 1.8;// rFloor(p,dir,0.035);
    
    if(A)
    {
   		 float h=rSphere(p,dir,pins(0)+vec3(0,-0.21,0),BOUNDS);
  		  tmin=min(tmin,h);
    }
    float tmax = MAX_DIST;
    float t = tmin;
    vec4  dist = vec4(MAX_DIST,0.,0.,0.);
    for( int i=0; i<MAX_ITERATIONS; i++ )
    {
	    dist = sdScene( p+dir*t ,A);
        if( (dist.x)<MIN_DIST || t>MAX_DIST ) break;
        t += dist.x;
    }
    
    return vec4( t, dist.yzw );

}

// Function 599
vec4 rayCast(vec3 eye, vec3 dir){
    vec3 pos; float depth=0.,dist;
    vec4 rc;
    const int maxsteps = 500;
    for (int i = 0; i < maxsteps; i++){
        pos = eye + dir * depth;
        rc = map(pos);
        dist = rc.w;
        depth += dist;
        if (dist < eps){
            break;
        }else if(depth>depthmax){
            depth = depthmax+eps;
            break;
        }        
    }
    rc.w=depth;
    return rc;
}

// Function 600
raymarch_result raymarch(
    vec3 eye, vec3 direction, float start, float end)
{
    raymarch_result result;
    float depth = start;
    int stepCount = 0;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        stepCount = i;
        float dist = sceneSDF(eye + depth * direction);
        if (dist < EPSILON) {
            result.depth = depth;
            result.steps = stepCount;
            return result;
        }
        depth += dist;
        if (depth >= end) {
            result.depth = end;
            result.steps = stepCount;
            return result;
        }
    }
    result.depth = end;
    result.steps = stepCount;
    return result;
}

// Function 601
vec3 getNormal(vec3 p) {
    vec2 eps = vec2(0.0, EPSILON);
    vec3 normal = normalize(vec3(
        scene(p + eps.yxx).x - scene(p - eps.yxx).x,
        scene(p + eps.xyx).x - scene(p - eps.xyx).x,
        scene(p + eps.xxy).x - scene(p - eps.xxy).x));
    return normal;
}

// Function 602
float rayPlane(vec3 ro, vec3 rd, vec3 n, float d){


    float t = 1e8;
    //float retval = 0.; // Inside or outside the object. Not used here.

	float ndotdir = dot(rd, n);
     
	if (ndotdir < 0.){
	
		float dist = (-d - dot(ro, n) + 9e-7)/ndotdir;	// + 9e-7
   		
		if (dist>0. && dist<t){ 
            t = dist; 
            //retval = 1.;
		}
	}
    
    return t;

}

// Function 603
vec3 calcNormal(vec3 p) {
 
    vec2 eps = vec2(.001,0.);
    vec3   n = vec3(dstScene(p + eps.xyy) - dstScene(p - eps.xyy),
                    dstScene(p + eps.yxy) - dstScene(p - eps.yxy),
                    dstScene(p + eps.yyx) - dstScene(p - eps.yyx));
    return normalize(n);
    
}

// Function 604
vec3 getNormal(vec3 pos){ // this gets the normal
	/* So we're gonna check the distance field at little steps in each direction
		the subtractions will give us the gradient in each direction
		so if distance goes up in a direction we get positive that way
*/
	vec2 eps = vec2(0.0, EPS);
	return normalize(vec3( // always normalise directions godammit
			scenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),
			scenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),
			scenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));
}

// Function 605
float RAYCAST_floor(vec3 o, vec3 d)
{
    vec3 n = vec3(0,1,0);
    vec3 p = vec3(-0.1);
    float t = dot(p-o,n)/dot(d,n);
    return (t<0.0)?GEO_MAX_DIST:t;
}

// Function 606
vec3 normal(in vec3 p) {
	const vec2 e = vec2(0.005, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 607
float castShadowRay( in vec3 ro, in vec3 rd )
{
    for( uint i=0U; i<NUMBOXES; i++ )
    {
        mat4 ma; vec3 si; getLocation(i, ma, si);

        if( iBox( ro, rd, ma, si )>0.0 )
            return 0.0;
    }
	return 1.0;
}

// Function 608
void ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)
{
	if(t == tRoom.y)
	{            
		mref = vec2(0.0,0.0);
        normal =-normalForCube(hit, box0);   
        if(normal.x>0.0)
        { 
            mcol.xyz = vec3(0.95,0.05,0.05);
        } 
        else if(normal.x<0.0)
        { 
            mcol.xyz = vec3(0.05,0.95,0.05);
        } 
	}     
	else   
	{
        	 if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,10.0); mref = vec2(0.0,0.0);}
    }  
}

// Function 609
RMResult raymarch(vec3 ro, vec3 rd, out float t)
{
	t = 0.;
    vec3 p = ro + t * rd;
    RMResult s = RMResult(-1., FAR);
    for(int i = 0; i < I_MAX; i++)
    {
		s = map(p);
        if (t + s.dist < FAR && abs(s.dist) > EPS) 
        {
			t += s.dist;
	        p = ro + t * rd;

        }
        else
        {
            if (t + s.dist > FAR)
            {
               s.id = -1.;
            }
            break;
        }
    }
    return s;
}

// Function 610
void ray(inout vec3 cp, in vec3 rd, out float st, out float cd)
{
  for(; st < 1.; st += 1./200.)
  {
    cd = map(cp);
    if(cd < .01 || cd > INF)
    {
      break;
    }
    
    cp += rd * cd * st ;
  }
}

// Function 611
float ray_vs_world( vec3 pos, vec3 dir, out vec3 mask, out vec3 center ) {
	// grid space
	vec3 grid = floor( pos );
	vec3 grid_step = sign( dir );
	vec3 corner = max( grid_step, vec3( 0.0 ) );
	
	// ray space
	vec3 inv = vec3( 1.0 ) / dir;
	vec3 ratio = ( grid + corner - pos ) * inv;
	vec3 ratio_step = grid_step * inv;
	
	// dda
	float hit = -1.0;
	for ( int i = 0; i < 512; i++ ) {
		if ( voxel( grid ) > 0.5 ) {
			hit = 1.0;
			continue;
		}

		vec3 cp = step( ratio, ratio.yzx );

		mask = cp * ( vec3( 1.0 ) - cp.zxy );
		
		grid  += grid_step  * mask;		
		ratio += ratio_step * mask;
	}
	
	center = grid + vec3( 0.5 );
	return dot( ratio - ratio_step, mask ) * hit;
}

// Function 612
vec3 calcNormal(vec3 position) {
    // Step around the point and see how far we are from the map at each position
    // and do some math to figure out what the normal is
    // I use a value of 0.02 because I find that's the best balance between accuracy and
    // avoiding those nasty rings on some objects
    vec2 eps = vec2(0.0, 0.005);
    return normalize(vec3(
        map(position + eps.yxx).hit - map(position - eps.yxx).hit,
        map(position + eps.xyx).hit - map(position - eps.xyx).hit,
        map(position + eps.xxy).hit - map(position - eps.xxy).hit
    ));
}

// Function 613
vec3 calcNormal( in vec3 pos ){
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,
        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,
        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );
    return normalize(nor);
}

// Function 614
Ray genRay(vec2 pixel)
{
	vec2 iplane_size=2.*tan(0.5*cam_vfov)*make_float2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iplane_size;
	vec3 cam_dir=normalize(make_float3(ixy.x,ixy.y,-1.));
	vec3 world_dir=cam_mat*cam_dir;
	Ray ray;
	ray.dir=world_dir;
	ray.origin=cam_origin;	
	return ray;
}

// Function 615
vec3 getRayDir(vec3 cameraDir, vec2 screenPos) {
	vec3 planeU = vec3(1.0, 0.0, 0.0);
	vec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);
	return normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);
}

// Function 616
vec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float startf, in float maxd )
{
    float h = precis*10.0;
    vec3 c;
    float t = h*4.0;
    float dsp = 0.0;
    float sid = -1.0;
    for( int i=0; i<50; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;
        t += h;
	    vec3 res = map( ro+rd*t );
        h = res.x;
	    sid = res.y;
		dsp = res.z;
    }

    if( t>maxd ) sid=-1.0;
    return vec3( t, sid, dsp );
}

// Function 617
vec3 ShadeRay( vec3 pos, vec3 ray, float time )
{
    // animate moving objects
    float r = -(time+sin(time))*50.;
//    vec4 s0 = vec4(-.7071,-1.+.7071,0,1), s1 = vec4(.7071,-1.+3.*.7071,0,0);
    vec4 s0 = vec4(-1.5,0,0,1), s1 = vec4(1.5,1,0,0);
    Scene[0] = s0;
    Scene[1] = s1;
    Scene[0].xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;
    Scene[1].xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;
    Scene[0].w = .1;//.5+.5*pow(1.-fract(time*2.),2.);
    
    vec3 normal = vec3(0);
    int material = -1;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;
        
        vec3 sun = normalize(vec3(-.5,2,3));
        vec3 testn = vec3(0);
        int ignore;
        Trace(testn,ignore,pos,sun);
        
        vec3 light = vec3(.05,.065,.09)*(normal.y*.3+1.); // ambient
        if ( length(testn) == 0. )
        {
        	light += max(0.,dot(normal,sun)) * vec3(1,.95,.92);
        }
        
        vec3 albedo = smoothstep(.01,.02,abs(fract( pos+.001 )-.5));
        
        if ( material == 0 ) { albedo = vec3(1,0,0); }//light += vec3(1.); }
        
        col = light*albedo;
    }

// Function 618
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
        vec2 xy = fragCoord - size / 2.0;
        float z = size.y / tan(radians(fieldOfView) / 2.0);
        return normalize(vec3(xy, -z));
    }

// Function 619
Ray mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }

// Function 620
float rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n), t = 1e8;
    
    if (abs(dn)>.0001){
        t = dot(p - o, n)/dn;
        t += float(t<0.)*1e8;
    }
    
    return t;
}

// Function 621
vec2 normal(vec2 uv) {
	vec2 eps = vec2( 0.0005, 0.0 );
	return normalize(
		vec2(sdfMap(uv+eps.xy) - sdfMap(uv-eps.xy),
		     sdfMap(uv+eps.yx) - sdfMap(uv-eps.yx)));
}

// Function 622
vec3 calcNormal( in vec3 pos )
{
vec3 eps = vec3( 0.001, 0.0, 0.0 );
vec3 nor = vec3(
map(pos+eps.xyy) - map(pos-eps.xyy),
map(pos+eps.yxy) - map(pos-eps.yxy),
map(pos+eps.yyx) - map(pos-eps.yyx) );
return normalize(nor);
}

// Function 623
vec3 rayMarch(vec3 rd, vec3 ro, out float d){
    vec3 p = ro;
    float s = prec;
    for(int i=0;i<rayMarchSteps;i++)
	{      
		if (s<prec||s>maxd) break;
		s = map(p) * marchPrecision;
		d += s;
		p = ro+rd*d;
	}
    return p;
}

// Function 624
vec3 bumpNormal(vec2 p)
{
    vec2 eps=vec2(1e-5,0.0);
    float bumpScale=10.0;
    float c=bumpHeight(p);
    float d0=(bumpHeight(p+eps.xy))-c;
    float d1=(bumpHeight(p+eps.yx))-c;
    return normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));
}

// Function 625
vec3 normal( in vec3 p ) {
    vec4 dummyColor = vec4(0);
	vec3 e = vec3(0.0, 0.0001, 0.0);
    float d = de(p, dummyColor, false);
	return normalize(vec3(
		d-de(p-e.yxx, dummyColor, false),
		d-de(p-e.xyx, dummyColor, false),
		d-de(p-e.xxy, dummyColor, false)));	
}

// Function 626
vec4 ReflectionInfoForRay( vec3 seed, vec3 start, vec3 firstDir, float depth )
{
    vec3 hitPos;

    if ( depth >= NO_HIT_DEPTH )
        return vec4( 0.0, 0.0, 0.0, BLOB_REFLECT );
    
    vec3 firstHitPos = start + firstDir * depth;

    vec3 firstHitNormal = GetNormal( firstHitPos CACHE );

    vec4 reflectionColor = vec4( 0.0 );

    for ( int r = 0; r < BUF_REFLECTION_SAMPLE_COUNT; r++ )
    {
        float remainingColorFrac = BLOB_REFLECT;

        vec3 dir = firstDir;
        hitPos = firstHitPos;
        vec3 normal = firstHitNormal;

        seed += rand3( seed ) * 100.0;

        // We can't afford to do random sampling here (compile time issue, not runtime issue)
        // So BUF_REFLECTION_SAMPLE_COUNT is just 1 and we don't randomize the normal (too flickery even with the blur).
        // We just rely on the buffer blur to make it soft, and it mostly does.
        dir = reflect( dir, normal ); // RandomizeNormal( normal, seed, BLOB_REFLECT_BLUR ) );
        start = hitPos;

        if ( !MarchReflectionRay( start, dir, hitPos CACHE ) )
        {
            reflectionColor.w += remainingColorFrac;
            continue;
        }

        for ( int reflectionIndex = 1; reflectionIndex < MAX_REFLECTIONS; reflectionIndex++ )
        {
            normal = GetNormal( hitPos CACHE );

            // average two lighting samples. i'm finding i don't need as many reflection samples if the lighting is less noisy
            vec3 light = CalcLightingForPointOnBlob( seed, hitPos, normal CACHE );
            seed += vec3( 13.2, 2.5, 1.0 );
            light += CalcLightingForPointOnBlob( seed, hitPos, normal CACHE );
            light *= 0.5;

            reflectionColor.xyz += BlobColorAtPos( hitPos ) * light * remainingColorFrac;
            reflectionColor.xyz += BlobEmissionAtPos( hitPos ) * remainingColorFrac;

            if ( !MarchReflectionRay( start, dir, hitPos CACHE ) )
            {
                vec3 bgColor = GetBackgroundColorForRayGivenLightingData( seed, start, dir, FAKE_BACKGROUND_SHADOW_DATA_FOR_REFLECTIONS * GetBrightnessForTime( blobTime ) CACHE );

                reflectionColor.xyz += bgColor * remainingColorFrac;
                break;
            }
        }
    }

    return reflectionColor / float( BUF_REFLECTION_SAMPLE_COUNT );
}

// Function 627
vec3 getRay_7_2(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {
  mat3 camMat = calcLookAtMatrix_8_1(origin, target, 0.0);
  return getRay_7_2(camMat, screenPos, lensLength);
}

// Function 628
vec3 getNormal (in vec3 p) {
	const vec2 h = vec2 (DELTA, -DELTA);
	return normalize (
		h.xxx * getDistance (p + h.xxx) +
		h.xyy * getDistance (p + h.xyy) +
		h.yxy * getDistance (p + h.yxy) +
		h.yyx * getDistance (p + h.yyx)
	);
}

// Function 629
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    
    if( SCENE_MODE == 0 ) {
 	   return normalize( e.xyy*map_0( pos + e.xyy ).x + 
					  e.yyx*map_0( pos + e.yyx ).x + 
					  e.yxy*map_0( pos + e.yxy ).x + 
					  e.xxx*map_0( pos + e.xxx ).x );
    } else if( SCENE_MODE == 1 ) {
            return normalize( e.xyy*map_1( pos + e.xyy ).x + 
					  e.yyx*map_1( pos + e.yyx ).x + 
					  e.yxy*map_1( pos + e.yxy ).x + 
					  e.xxx*map_1( pos + e.xxx ).x );
    } else if( SCENE_MODE == 2 ) {
            return normalize( e.xyy*map_2( pos + e.xyy ).x + 
					  e.yyx*map_2( pos + e.yyx ).x + 
					  e.yxy*map_2( pos + e.yxy ).x + 
					  e.xxx*map_2( pos + e.xxx ).x );
    } else if( SCENE_MODE == 3 ) {
            return normalize( e.xyy*map_3( pos + e.xyy ).x + 
					  e.yyx*map_3( pos + e.yyx ).x + 
					  e.yxy*map_3( pos + e.yxy ).x + 
					  e.xxx*map_3( pos + e.xxx ).x );
    } else if( SCENE_MODE == 4 ) {
            return normalize( e.xyy*map_4( pos + e.xyy ).x + 
					  e.yyx*map_4( pos + e.yyx ).x + 
					  e.yxy*map_4( pos + e.yxy ).x + 
					  e.xxx*map_4( pos + e.xxx ).x );
    } else if( SCENE_MODE == 5 ) {
            return normalize( e.xyy*map_5( pos + e.xyy ).x + 
					  e.yyx*map_5( pos + e.yyx ).x + 
					  e.yxy*map_5( pos + e.yxy ).x + 
					  e.xxx*map_5( pos + e.xxx ).x );
    } else if( SCENE_MODE == 6 ) {
            return normalize( e.xyy*map_6( pos + e.xyy ).x + 
					  e.yyx*map_6( pos + e.yyx ).x + 
					  e.yxy*map_6( pos + e.yxy ).x + 
					  e.xxx*map_6( pos + e.xxx ).x );
    }
}

// Function 630
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float dt = .01,
         den = 0., _den, lut,
           t = intersect_sphere( ro, rd, vec3(0), BR );
    if ( t == -1. ) return vec4(0); // the ray misses the object 
    t += 1e-5;                      // start on bounding sphere
    
    for(int i=0; i<500; i++) {
        vec3 pos = ro + t*rd;
        if(   sum.a > .99               // end if opaque or...
           || length(pos) > BR ) break; // ... exit bounding sphere
                                    // --- compute deltaInt-density
        _den = den; den = map(pos); // raw density
        float _z = z;               // depth in object
        lut = LUTs( _den, den );    // shaped through transfer function
        if( lut > .0                // optim
          ) {                       // --- compute shading                  
#if 0                               // finite differences
            vec2 e = vec2(.3,0);
            vec3 n = normalize( vec3( map(pos+e.xyy) - den,
                                      map(pos+e.yxy) - den,
                                      map(pos+e.yyx) - den ) );
         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
            float dif = clamp( -dot(n, sundir), 0., 1.);
#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm
         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction 
            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse
#endif
/*
            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse
                  col = vec3(.2 + dif);
            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog
*/            
            vec3 col = exp(- vec3(3,3,2) *(1.-z));     // dark with shadow
         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));  // dark with depth
                   //      *  exp(- 1.5 *(1.-z));
            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;
        }
        t += dt;  // stepping
    }

    return sum; 
}

// Function 631
float ray_marching(vec3 origin, vec3 dir, float start, float end) {
	float depth = start;
	for (int i = 0; i < max_iterations; i++) {
		float dist = dist_field(origin + dir * depth);
		if (dist < stop_threshold) {
			return depth;
		}
		depth += dist;
		if (depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 632
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 220; j ++) {
    d = ObjDf (ro + rd * dHit);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 633
float Intersect_Ray_Sphere(
vec3 rp, vec3 rd, 
vec3 sp, float sr2, 
out vec2 t)
{	
	rp -= sp;
	
	float a = dot(rd, rd);
	float b = 2.0 * dot(rp, rd);
	float c = dot(rp, rp) - sr2;
	
	float D = b*b - 4.0*a*c;
	
	if(D < 0.0) return 0.0;
	
	float sqrtD = sqrt(D);
	// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;
	t = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;
	
	// if(start == inside) ...
	if(c < 0.0) t.xy = t.yx;

	// t.x > 0.0 || start == inside ? infront : behind
	return t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;
}

// Function 634
vec3 calcNormal(vec3 p, bool insideSphere, float time) {
    vec2 e = vec2(epsilon, 0.0);
    bool u1=insideSphere, u2=insideSphere, u3=insideSphere, u4=insideSphere, u5=insideSphere, u6=insideSphere;
    return normalize(vec3(map(p+e.xyy, u1, time) - map(p-e.xyy, u2, time),
                          map(p+e.yxy, u3, time) - map(p-e.yxy, u4, time),
                          map(p+e.yyx, u5, time) - map(p-e.yyx, u6, time)));
}

// Function 635
bool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity
){dist = 0.0 + 10.1*hash1(gl_FragCoord.xy + time)
 ;float minStep = 0.01
 ;light_intensity = 1.
 ;float mapDist
 ;for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++
 ){p = ray_start + ray_dir * dist
  ;mapDist = mapBlocks(p, ray_dir).y
  ;if (mapDist < MIN_RAYMARCH_DELTA
  ){iterations = i
   ;return true;}
  ;light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist)
  ;dist += max(mapDist, minStep)
  ;if(dist>=maxDist||p.y>maxY)break
 ;}
 ;return false;}

// Function 636
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.001;
	float h=0.002;
	float t = 0.0;
	float m = -1.0;
	
	//float count = 1.0;
	for(int i=0; i<16; i++ )
	{
		if( abs(h)<precis||t>maxd )
		{
			//return float2( t, -1.0 );
			//int dummy = 0; // do nothing
		}
		else
		{
			t += h;
			float res = dist( ro+rd*t );
			h = res;
			//m = res.y;
			//count = count+1.0;
		}
		
	}
	
	#ifdef VISUALISE_RAYSTEPS
	// return number of steps
	// return float2(count/64.0, m);
	#else
	
	m = 72.0;
	if( t>maxd ) m=-1.0;
	return vec2( t, m );
	#endif
}

// Function 637
vec4 raycast(vec3 start, vec3 castSpeedStart) {
	vec3 castSpeed = vec3(castSpeedStart.xyz);
    float skyAmount = castSpeed.y*.4;
    
	vec4 returnValue = vec4(skyColor*skyAmount, 0.0);
	vec3 ray = vec3(start.xyz);
	
    float shadowing = 1.0;
    vec3 currentCast = vec3(floor(ray));
    
    int collideWith = 0;
	
    bool skipLoop = false;
    for(float its=0.0; its<200.0; its++) {
        if(skipLoop) {
            skipLoop = false;
            continue;
        }
		if(currentCast.y<0.0 || currentCast.y>=worldSize*.4) {
			returnValue = vec4(skyColor*skyAmount, 0);
			break;
		}
        
		vec3 inBlock = getFG(vec3(mod(currentCast.x, worldSize), mod(currentCast.y, worldSize), mod(currentCast.z, worldSize)));
		if(inBlock.x != -1.0) {
            float finalShadowing = clamp(shadowing-length(ray-start)/60.0, 0.0, 1.0);
            
            finalShadowing *= mod(.7*(float(collideWith)+5.0), 1.0)*.8+.2;
            
            returnValue = vec4(inBlock*finalShadowing+(1.0-finalShadowing)*skyColor*skyAmount, 0.0 );
            break;
		} // Here is also where I used to do reflections and fun stuff... recursively though
        
        // These last three IFs are checking if the ray passes the next voxel plane
		if(castSpeed.x != 0.0) {
			float t = ( floor(currentCast.x+clamp(sign(castSpeed.x), 0.0, 1.0)) -ray.x)/castSpeed.x;
			vec3 cast1Tmp = ray+castSpeed*t;
			if(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {
				ray = cast1Tmp;
				currentCast.x += sign(castSpeed.x);
				collideWith = (castSpeed.x>0.0?0:1);
                skipLoop = true;
				continue;
			}
		}
		if(castSpeed.y != 0.0) {
			float t = ( floor(currentCast.y+clamp(sign(castSpeed.y), 0.0, 1.0)) -ray.y)/castSpeed.y;
			vec3 cast1Tmp = ray+castSpeed*t;
			if(cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0 && cast1Tmp.z>=currentCast.z && cast1Tmp.z<=currentCast.z+1.0) {
				ray = cast1Tmp;
				currentCast.y += sign(castSpeed.y);
				collideWith = (castSpeed.y>0.0?2:3);
                skipLoop = true;
				continue;
			}
		}
		if(castSpeed.z != 0.0) {
			float t = ( floor(currentCast.z+clamp(sign(castSpeed.z), 0.0, 1.0)) -ray.z)/castSpeed.z;
			vec3 cast1Tmp = ray+castSpeed*t;
			if(cast1Tmp.y>=currentCast.y && cast1Tmp.y<=currentCast.y+1.0 && cast1Tmp.x>=currentCast.x && cast1Tmp.x<=currentCast.x+1.0) {
				ray = cast1Tmp;
				currentCast.z += sign(castSpeed.z);
				collideWith = (castSpeed.z>0.0?4:5);
                skipLoop = true;
				continue;
			}
		}
	}
	returnValue.w = length(ray-start);
    float val = 1.0-returnValue.w/70.0;
	return vec4(returnValue.xyz*val, 1.0);
}

// Function 638
vec3 Raymarch( vec3 ro, vec3 rd, vec2 p )
{
    vec3 fragColor = vec3(0.);
    
    // this intersects the ray with a set of planes (shown as lines in the diagram).
    // these calculations could be moved outside the pixel shader in normal scenarios.
    vec2 t, dt, wt;
    SetupSampling( t, dt, wt, ro, rd );
    
    if( wt.x >= 0.01 )
    {
        float march = MarchAgainstPlanes( t.x, dt.x, wt.x, ro, rd, p );
        fragColor = max( fragColor, march * .6*vec3(1.2,.2,.2) );
    }
    if( wt.y >= 0.01 )
    {
        float march = MarchAgainstPlanes( t.y, dt.y, wt.y, ro, rd, p );
        fragColor = max( fragColor, march * .6*vec3(.2,1.2,.2) );
    }
    
    return fragColor;
}

// Function 639
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.002;             // precision of the normal computation

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ) + 
					  v2*doModel( pos + v2*eps ) + 
					  v3*doModel( pos + v3*eps ) + 
					  v4*doModel( pos + v4*eps ));
}

// Function 640
vec3 asteroidGetNormal(vec3 p, vec3 id) {
    asteroidTransForm( p, id );
    
    vec3 n;
    n.x = map_detailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);
    n.y = map_detailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);
    n.z = map_detailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);
    n = normalize(n-map_detailed(p, id));
    
    asteroidUnTransForm( n, id );
    return n;
}

// Function 641
bool raySphereIntersection( in Ray ray, in float radiusSquared, out float t, out SurfaceHitInfo isect ) {
    float t0, t1;
    if (!iSphere(ray, vec3(.0), radiusSquared, t0, t1))
		return false;
    
    t = mix(mix(-1.0, t1, float(t1 > 0.0)), t0, float(t0 > 0.0));
    
    isect.position_ = ray.origin + ray.dir*t;
    isect.normal_ = normalize( isect.position_ );
	
	return (t != -1.0);
}

// Function 642
Ray get_view_ray2( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp, mat4 camera ) { return mkray( camera[3].xyz, transform_vector( camera, get_view_dir( normalized_pos, aspect, tan_half_fovy_rcp ) ) ); }

// Function 643
vec3 getNormal(vec3 p){
    vec3 n = vec3(0.0);
    int id;
    for(int i = ZERO; i < 4; i++){
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*getSDF(p+e*EPSILON);
    }
    return normalize(n);
}

// Function 644
vec3 mockNormal(vec2 uv) {
    vec3 normal;
    normal.xy = sin( vec2( 318.1, 178.2 ) * uv );
    normal.z = 1.0 + cos( 82.2 * uv.x ); 
    return normalize( normal );
}

// Function 645
vec3 normal(in vec2 fragCoord)
{
	float R = abs(luminance(texsample( OFFSET_X,0, fragCoord)));
	float L = abs(luminance(texsample(-OFFSET_X,0, fragCoord)));
	float D = abs(luminance(texsample(0, OFFSET_Y, fragCoord)));
	float U = abs(luminance(texsample(0,-OFFSET_Y, fragCoord)));
				 
	float X = (L-R) * .5;
	float Y = (U-D) * .5;

	return normalize(vec3(X, Y, 1. / DEPTH));
}

// Function 646
vec3 reflectVec(vec3 v, vec3 n)
{
     return v - 2.0f * dot(v, n) * n;
}

// Function 647
vec3 calcNormal( in vec3 pos, in bool showSphere )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.0005;
    return normalize( e.xyy*map( pos + e.xyy*eps, showSphere ).x + 
					  e.yyx*map( pos + e.yyx*eps, showSphere ).x + 
					  e.yxy*map( pos + e.yxy*eps, showSphere ).x + 
					  e.xxx*map( pos + e.xxx*eps, showSphere ).x );
}

// Function 648
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(4.0,4.0,4.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 649
vec3 normal(vec3 p) 
{  
    vec4 n = vec4(0.0);
    for (int i=ZERO; i<4; i++) 
    {
        vec4 s = vec4(p, 0.0);
        s[i] += EPS;
        n[i] = map(s.xyz).x;
    }
    return normalize(n.xyz-n.w);
}

// Function 650
vec3 reflection(ray r, result res, float time)
{
	r.o = res.p + res.n * 0.01;
	r.d = reflect(r.d, res.n);
	res = trace(r, time);
	return getColor(res,time);
}

// Function 651
vec3 calcNormal( in vec3 pos )
{
#if 1
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
#endif    
}

// Function 652
vec3 calcNormal(vec3 pos){
    isMap = false;
    vec3 eps = vec3(.001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).x * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    isMap = true;
    return normalize(nor);
}

// Function 653
bool castRay( in Ray ray, out float t, out vec3 n ){
    float tmin = 0.0;
    float tmax = 100.0;
    
    if(!iSphere(ray, vec3(0.), 2.25, tmin, tmax))return false;
    tmin = max(tmin, 0.0);
    
    t = tmin;
    for( int i=0; i<256; i++ )
    {
	    float precis = 0.0002*t;
        vec3 p = ray.origin + ray.dir*t;
        float d = map( p );
	    
        if( d<precis || t>tmax ) break;
        t += d;
    }
    
    n = calcNormal( ray.origin + ray.dir*t );
    bool res = t > tmin && t < tmax;
    
    return res;
}

// Function 654
vec3 RayMarchCloud(vec3 ro,vec3 rd){
    vec3 col = vec3(0.1,0.1,0.1);  
    float sundot = clamp(dot(rd,lightDir),0.1,2.0);
    
     // sky      
    col = vec3(0.3,0.6,0.95)*2.1 - rd.y*rd.y*0.6;
    col = mix( col, 0.95*vec3(0.8,0.85,0.95), pow( 2.0-max(rd.y,0.1), 5.0 ) );
    // sun
    col += 0.35*vec3(2.0,0.8,0.5)*pow( sundot,6.0 );
    col += 0.35*vec3(2.0,0.9,0.7)*pow( sundot,74.0 );
    col += 0.5*vec3(2.0,0.9,0.7)*pow( sundot,612.0 );
    // clouds
    col = Cloud(col,ro,rd,vec3(2.0,1.05,2.0),2.);
            // .
    col = mix( col, 0.78*vec3(0.5,0.75,2.0), pow( 2.0-max(rd.y,0.1), 26.0 ) );
    return col;
}

// Function 655
vec3 normal(vec3 p) {
 
    const float d = .001;
    
    vec3 left = vec3(p.x - d,p.yz);
    vec3 right = vec3(p.x + d,p.yz);
    vec3 up = vec3(p.x,p.y-d,p.z);
    vec3 down = vec3(p.x,p.y+d,p.z);
    vec3 front = vec3(p.xy,p.z-d);
    vec3 back = vec3(p.xy,p.z+d);
    
    float distLeft = distToScene(left).dist;
    float distRight = distToScene(right).dist;
    float distUp = distToScene(up).dist;
    float distDown = distToScene(down).dist;
    float distFront = distToScene(front).dist;
    float distBack = distToScene(back).dist;
    
    return normalize(vec3(distRight-distLeft,distDown-distUp,distBack-distFront));
    
}

// Function 656
vec3 calcNormal( in vec3 pos )
{
	// precision of the normal computation
    const float eps = 0.01;           

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ).x + 
					  v2*doModel( pos + v2*eps ).x + 
					  v3*doModel( pos + v3*eps ).x + 
					  v4*doModel( pos + v4*eps ).x );
}

// Function 657
void raytraceTree(vec3 u,vec3 d,vec3 t,float o,float h, float v,inout vec3 color,inout float nearestD){t.y+=6.+o;
 vec2 n=normalize(d.xz),g=t.xz-u.xz,b=t.y+vec2(-12,20);
 float y=u.y+d.y*length(g)/length(d.xz);
 if(y<b.x||y>b.y)return;//above of below bounding plane.
 float q=dot(g,n)/length(n);//distToPointOnRayClosestToCenterOfTree
 if (q<=.0) return;//should consider radius of cylinder too, but won't matter for this scene
 const vec2 cone=vec2(14,2);// test within cylinder radius
 float cdttc = length(u.xz+n*q-t.xz);//closestDistToTreeCenter
 if (cdttc>cone.y+(cone.x-cone.y)*(1.-(y-b.x)/(b.y-b.x))) return;
 const float j=11.0,m=.2;
 for(float i=.0;i<j;i++){float b=i/j,w=waveT(iTime*1.5-t.x*.007);w=1.-w;w=1.-w*w;
  float s=sin(iTime*3.+t.x*-.01 + b*1.2);s=1.-u5(s);s=(1.-s*s)*((w-w*m)+m)*-.04;
  raytraceBranchShelf(u,d,t+vec3(0,1.+(pow(1.-b,.6))*(13.+h),0),//height
                      branchStart+.5+(9.+v)*b,.05+.6*b+s,3.*b,color,nearestD);}//length//pitch//yaw offset
 float r=-(y-(t.y+8.0))*.1;
 if(y<t.y+10.){
  if(cdttc<r){// this is utterly fudged, but it's close enough for such a tiny detail
   float f=(1.-pow((cdttc/r),3.))*r,k=q-f;    
   if(k<nearestD)color=vec3(.15,.1,0)*(f+.2);
   #ifdef DRAW_CLIP_RAYTRACES
    else color-=vec3(0,.5,0);
   #endif
   nearestD=min(k,nearestD);
 }}
 #ifdef DRAW_CLIP_RAYTRACES
 color=mix(color,vec3(0,1,0),.1);
 #endif
 return;
}

// Function 658
vec3 getNormal(vec3 p, float t)
{
	vec2 d = vec2(0.01, 0.0);
	float dx = distanceField(p + d.xyy,t).t
				- distanceField(p - d.xyy,t).t;
	float dy = distanceField(p + d.yxy,t).t
				- distanceField(p - d.yxy,t).t;
	float dz = distanceField(p + d.yyx,t).t
				- distanceField(p - d.yyx,t).t;
	return normalize(vec3(dx, dy, dz));
}

// Function 659
vec3 getNormal(vec3 p)
{
  float d = sphere(p);
  vec3 eps = vec3(0.0001, 0.0, 0.0);
  return normalize(vec3(
           d - sphere(p - eps.xyy),
           d - sphere(p - eps.yxy),
           d - sphere(p - eps.yyx)));
}

// Function 660
vec3 GetSurfaceNormal(vec3 p)
{
    float d0 = GetDistanceToNearestSurface(p);
    const vec2 epsilon = vec2(.0001,0);
    vec3 d1 = vec3(
        GetDistanceToNearestSurface(p-epsilon.xyy),
        GetDistanceToNearestSurface(p-epsilon.yxy),
        GetDistanceToNearestSurface(p-epsilon.yyx));
    return normalize(d0 - d1);
}

// Function 661
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0) * 0.01;
    
    return normalize( e.xyy*mapH( pos + e.xyy ) + 
					  e.yyx*mapH( pos + e.yyx ) + 
					  e.yxy*mapH( pos + e.yxy ) + 
					  e.xxx*mapH( pos + e.xxx ) );
}

// Function 662
vec3 raymarchFast( vec3 ro, vec3 rd, const vec2 nf, const float eps ) {
    glowAcc = vec2(999.);
    vec3 p = ro + rd * nf.x;
    float l = 0.;
    for(int i=0; i<64; i++) {
		float d = world(p);
        l += d;
        p += rd * d*1.2;
        
        if(d < eps || l > nf.y)
            break;
    }
    
    return p;
}

// Function 663
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){
	float precis = 0.001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<120; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;
        t += h;
	    vec2 res = map( ro+rd*t );
        h = res.x; //dist to solid
	    m = res.y; //fft
    }
    if (t>maxd) { t=-0.5; m=0.0; }
    return vec2( t, m );
}

// Function 664
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 180; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz, 0);
    if (h < 0.) break;
    sLo = s;
    s += max (0.25, 0.4 * h) + 0.005 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 8; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz, 0));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 665
vec3 normal(in vec3 p, in vec3 rd)
{
    vec2 e = vec2(-1., 1.)*2e-5;
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy));   
}

// Function 666
vec3 normal( vec3 p ) 
{
    const float h = EPSILON;
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*map( p + k.xyy*h ) + 
                      k.yyx*map( p + k.yyx*h ) + 
                      k.yxy*map( p + k.yxy*h ) + 
                      k.xxx*map( p + k.xxx*h ) );
}

// Function 667
vec3 getNormal(vec3 p) {
    vec3 eps = vec3(0.001, 0.0, 0.0);
	vec3 nor = vec3(
	    getDistance(p+eps.xyy) - getDistance(p-eps.xyy),
	    getDistance(p+eps.yxy) - getDistance(p-eps.yxy),
	    getDistance(p+eps.yyx) - getDistance(p-eps.yyx));
	return normalize(nor);
}

// Function 668
float reflection(vec2 a, vec2 b, float power, float fresnel, Slide slides[SLIDE_COUNT]) {
    float r = 0.0;

#ifdef LIGHTING_DIRECT
	vec2 delta = b - a;
    float len = length(delta);
	vec3 visa = trace(a, delta/len, len, slides);
	r += visa.y / (1.0 + len * len * power);
#endif

#ifdef LIGHTING_BOUNCE_ONCE
    for (int i = 0; i < SLIDE_COUNT; ++i) {
        vec2 deltai = a - slides[i].pos;
        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);

        vec2 rayi = refi - b;
        float leni = length(rayi);
        rayi /= leni;
        vec3 pathi = trace(b, rayi, leni, slides);
        if (pathi.z != float(i)) {
            continue;
        }
		vec2 hiti = b + rayi * pathi.x;
        
        vec2 delta = hiti - a;
        float len = length(delta);
        delta /= len;
        vec3 path = trace(a, delta, len*0.99, slides);
        if (path.y == 0.0) {
            continue;   
        }

        float pathLength = leni;
        float prod = abs(dot(-normalize(delta), slides[i].normal));
        r += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);
    }
#endif // LIGHTING_BOUNCE_ONCE
    
#ifdef LIGHTING_BOUNCE_TWICE
	for (int i = 0; i < SLIDE_COUNT; ++i) {
        vec2 deltai = a - slides[i].pos;
        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);
        for (int j = 0; j < SLIDE_COUNT; ++j) {
            if (j==i) {
                continue;
            }
            
        	vec2 deltaj = refi - slides[j].pos;
        	vec2 refj = slides[j].pos - reflect(deltaj, slides[j].normal);
            
            vec2 rayj = refj - b;
            float lenj = length(rayj);
            rayj /= lenj;
            vec3 pathj = trace(b, rayj, lenj, slides);
            if (pathj.z != float(j)) {
                continue;
            }
            vec2 hitj = b + rayj * pathj.x;
            
            vec2 rayi = refi - hitj;
            float leni = length(rayi);
            rayi /= leni;
            hitj += rayi * 0.01;
            vec3 pathi = trace(hitj, rayi, leni, slides);
            if (pathi.z != float(i)) {
                continue;
            }
            vec2 hiti = rayi + hitj * pathi.x;
            
            vec2 delta = hiti - a;
            float len = length(delta);
            delta /= len;
            vec3 path = trace(a, delta, len*0.99, slides);
            if (path.y == 0.0) {
                continue;
            }

        	float pathLength = lenj;
        	float prod = abs(dot(-normalize(delta), slides[i].normal));
            prod *= abs(dot(-normalize(rayi), slides[j].normal));
        	r += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);
        }
    }
#endif // LIGHTING_BOUNCE_TWICE
 
    return r;
}

// Function 669
vec3 normal(vec3 rp) {
 	float x = distance_field(rp + vec3(eps,0,0)) - distance_field(rp - vec3(eps,0,0));
    float y = distance_field(rp + vec3(0,eps,0)) - distance_field(rp - vec3(0,eps,0));
    float z = distance_field(rp + vec3(0,0,eps)) - distance_field(rp - vec3(0,0,eps));
    return normalize(vec3(x,y,z));
}

// Function 670
vec3 worldSpaceNormal( vec3 pos ) {
	const vec3 dx = vec3( normalStep, 0.0, 0.0 );
	const vec3 dy = vec3( 0.0, normalStep, 0.0 );
	const vec3 dz = vec3( 0.0, 0.0, normalStep );
	return normalize (
		vec3(
			distField(pos + dx) - distField(pos - dx),
            distField(pos + dy) - distField(pos - dy),
            distField(pos + dz) - distField(pos - dz)
		)
	);
}

// Function 671
bool calculateRayHit(float os, float rayLength){
	return rayLength > os * rayLength;
}

// Function 672
vec3 RayMarch(vec3 origin,vec3 direction)
{
    float hitDist = 0.0;
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float sceneDist = Scene(origin + direction * hitDist);
        
        hitDist += sceneDist;
        
        if(sceneDist < MIN_DIST)
        {
            break;
        }
    }
    
    return origin + direction * hitDist;
}

// Function 673
vec3 findnormal(vec2 uv)
{
    return normalize(cross(getpos(uv+vec2(1.0,0.0))-getpos(uv-vec2(1.0,0.0)),getpos(uv+vec2(0.0,1.0))-getpos(uv-vec2(0.0,1.0))));
}

// Function 674
float parametric_normal_iteration2(float t, vec2 uv){
	vec2 uv_to_p=parametric(t)-uv;
	vec2 tang=parametric_diff(t);
	vec2 snd_drv=parametric_snd_diff(t);

	float l_tang=dot(tang,tang);

	float fac=dot(tang,snd_drv)/(2.*l_tang);
	float d=-dot(tang,uv_to_p);

	float t2=d/(l_tang+fac*d);

	return t+factor*t2;
}

// Function 675
vec3 calcNormal(in vec3 p){

    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.
    vec2 e = vec2(0.0025, -0.0025); 
    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));
}

// Function 676
vec2 castRay( in vec3 ro, in vec3 rd, out vec2 oVos, out vec2 oDir )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	float t = -1.0;
	float ic = 0.0;
	
	vec2 mm = vec2(0.0);
	for( int i=0; i<450; i++ ) 
	{
		float ma = map(pos);
		vec3  ce = vec3( pos.x+0.5, ma, pos.y+0.5 );
		vec3  rc = ro - ce;
		
		// cylinder
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.45*0.45;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t1 = (-b-sqrt(h))/a;
			if( t1>0.0 && (ro.y+t1*rd.y)<ma )
			{
				t = t1;
				ic = 1.0;
    			break; 
			}

			// sphere
			b = dot( rd, rc );
			c = dot( rc, rc ) - 0.45*0.45;
			h = b*b - c;
			if( h>0.0 )
			{
				t = -b-sqrt(h);
			 	ic = 3.0;
			 	break;
			}
		}

		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}

	oDir = mm;
	oVos = pos;

	return vec2( t, ic );

}

// Function 677
vec3 toGrayscale(in vec3 col)
{
	float x = (col.x + col.y + col.z) / 3.0;
    return vec3(x);
}

// Function 678
vec3 calculateNormal(vec3 pos)
{
    // Tetrahedral normal calculation method by iq
    vec2 e = vec2(0.002,-0.002);
    return normalize(e.xxx * sceneSDF(pos+e.xxx)
            + e.xyy * sceneSDF(pos+e.xyy)
            + e.yxy * sceneSDF(pos+e.yxy)
            + e.yyx * sceneSDF(pos+e.yyx));
}

// Function 679
vec4 rayMarchCycle(vec3 rayOrigin, vec3 rayDir,vec2 fragCoord,out vec3 outPhit)
{
    vec3 col=vec3(0.);
	vec3 L = normalize( vec3(.1, .9, -.23 ));

    vec3 finalColor=vec3(0.0);
    vec3 cloudColor;
    vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,0);
    float dist=rayHit[0];
    float mat=rayHit[1];
    vec3 pHit=rayOrigin+rayDir*dist;
    outPhit=pHit;
    
    vec3 N=calcNormal(pHit);
    float NoL = max(dot(N, L), 0.0);
    float ao=calcAO(pHit,N);

    vec3 skyColor=Sky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);
    vec3 darkSkyColor=nightSky(pHit,(mat==2.0)?reflect(rayDir,N):rayDir,iTime,L);
    vec3 finSkyCol=skyColor;
    
    if (mat==1.0) // paper plane
    {
        finalColor=vec3(NoL)*vec3(0.58,0.12,0.12);
    }
    else if (mat==2.0) // sea plane sea scene/night
    {
        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);
        else if (iTime>=65.0) finSkyCol=darkSkyColor;
		//vec3 reflektCol=reflekkt(rayOrigin,rayDir,fragCoord);        
        vec3 col=mix(vec3(pow(NoL,8.0))*vec3(0.01,0.01,0.02),finSkyCol,0.6);
        finalColor=clamp(col,vec3(0.0),vec3(1.0));
        // final fadeout
        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));
    }
    else if (mat==3.0) // cage bars
    {
        vec3 barCol=vec3(0.74);
        finalColor=barCol.xyz*ao;
        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));
    }
    else if (mat==4.0) // cage base
    {
        vec3 barCol=vec3(0.22);
        //float d=distance(pHit,vec3(0.0));
        //vec3 fgcol=fog(barCol,d,vec3(0.8));
        finalColor=barCol.xyz*ao;
        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));
    }
    else if (mat==5.0) // cage floor
    {
        float d=distance(pHit,vec3(0.0));
        vec3 floorCol=vec3(0.01);
        vec3 fgcol=fog(floorCol,d,vec3(0.8));
        finalColor=fgcol.xyz;
        if (iTime>=70.0) finalColor=mix(vec3(0.0),finalColor,clamp((iTime-70.0),0.0,1.0));
    }
    else if ((iTime<20.0)||(iTime>=70.0)) // cage scene
    {
        finalColor=vec3(0.8);
    }
    else
    {
        if ((iTime>=60.0)&&(iTime<65.0)) finSkyCol=mix(darkSkyColor,skyColor,(65.0-iTime)/5.0);
        else if (iTime>=65.0) finSkyCol=darkSkyColor;
        
        finalColor=finSkyCol+cloudColor*0.85;

        // final fadeout
        if (iTime>=65.0) finalColor=mix(finalColor,vec3(0.0),clamp((iTime-65.0)/3.0,0.0,1.0));
    }

    // ghost mode
    if ((iTime>12.0)&&(iTime<20.0))
    {
    	vec2 rayHit = rayMarch(rayOrigin, rayDir,cloudColor,fragCoord,1);
        if (rayHit[1]==1.0)
        {
            finalColor+=vec3(NoL)*vec3(0.58,0.12,0.12);
        }
    }
    
    return vec4(finalColor,-999999.0);    
}

// Function 680
vec3 _calcNormal(vec3 pos){
    vec3 eps = vec3(.001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).dist * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

// Function 681
vec3 getNormal(vec3 pos, float e)
{
    vec2 q = vec2(0, e);
    vec3 norm = normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,
                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,
                          map(pos + q.xxy, true).x - map(pos - q.xxy.x, true)));
    return norm;
}

// Function 682
vec3 estimateNormal(vec3 p) {
    float EPSILON = 0.000001;
    return normalize(vec3(
        map(vec3(p.x + EPSILON, p.y, p.z)).Md - map(vec3(p.x - EPSILON, p.y, p.z)).Md,
        map(vec3(p.x, p.y + EPSILON, p.z)).Md - map(vec3(p.x, p.y - EPSILON, p.z)).Md,
        map(vec3(p.x, p.y, p.z + EPSILON)).Md - map(vec3(p.x, p.y, p.z - EPSILON)).Md
    ));
}

// Function 683
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.0005;
    return normalize( e.xyy*map( pos + e.xyy*eps ).x + 
					  e.yyx*map( pos + e.yyx*eps ).x + 
					  e.yxy*map( pos + e.yxy*eps ).x + 
					  e.xxx*map( pos + e.xxx*eps ).x );
}

// Function 684
vec2 normal_pack(vec3 n)
{
    return n.xy*0.5+0.5;
}

// Function 685
int scene_raycast_objects( Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )
{
    int result = -1;
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        float to = t;
        vec3 N = ZERO;
        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );
        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_PRIMITIVE:
        scene_obj_primitive( obj, localray, to, albedo, N );
        break;
        }
        if( to < t )
            result = i, t = to, out_N = obj.B * N;
    }
    return result;
}

// Function 686
vec2 LBeamRay (vec3 ro, vec3 rd)
{
  vec3 p;
  vec2 d2;
  float dHit;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 80; j ++) {
    d2 = LBeamDf (ro + dHit * rd);
    dHit += d2.x;
    if (d2.x < 0.001 || dHit > dstFar) break;
  }
  return vec2 (dHit, d2.y);
}

// Function 687
float TransObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 120; j ++) {
    d = TransObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 688
vec3 safeNormalize(vec3 p)
{
    float l = length(p);
    if (l == 0.) return vec3(0);
    return p/l;
}

// Function 689
vec3 calcNormal(vec3 p, float t) {
#ifndef FAST_NORMALS
    vec2 e = vec2(.001*t,0.);
    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,
                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,
                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);
    return normalize(n);
#else
    return normalize(-cross(dFdy(p),dFdx(p)));
#endif
}

// Function 690
vec3 getNormal( vec3 p ) 
{
	vec2 e = vec2(0.006, 0.0);
	return (vec3( getDist(p+e.xyy), getDist(p+e.yxy), getDist(p+e.yyx)) - getDist(p)) / e.x;
}

// Function 691
bool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	int closestAxis = 0;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestAxis = axis;
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}
	
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (closestAxis == 0)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (closestAxis == 1)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
	
	vec3 relPoint = info.m_intersectionPoint - box.m_pos;
	info.m_textureCoordinates = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);
	
	// bump mapping
	mat3 mattanspace = mat3
	(
		uaxis,
		vaxis,
		info.m_surfaceNormal
	);
	
	float delta = -1.0/512.0;
	if (box.m_Id == 4) {
		float A = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
		float B = texture(iChannel1, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    	float C = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, delta)).x;
		vec3 norm = normalize(vec3(B - A, C - A, 0.25));
		info.m_surfaceNormal = normalize(mattanspace * norm);
	}
	else {
		float A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
		float B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    	float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;
		vec3 norm = normalize(vec3(B - A, C - A, 0.25));
		info.m_surfaceNormal = normalize(mattanspace * norm);		
	}
	
	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 692
vec3 get_ray_direction(Camera cam, vec2 uv) {
  // Get the direction the camera is facing, based on what
  // it's supposed to be looking at
  vec3 cam_direction = normalize(-cam.position - cam.look_at);
  vec3 cam_side = cross(cam_direction, cam.up);
  // Get the normalized ray direction
  return normalize(
      vec3(cam_side * uv.x + cam.up * uv.y + cam_direction * cam.focus));
}

// Function 693
RayTraceResult RayTraceSphere(in Ray ray, in vec3 c, in float r)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
    vec3 L = c - ray.org;
    float d = dot(L, ray.dir);
    float l2 = dot(L, L);
    float d2 = d*d;
    float r2 = r*r;
    
    if (d < .0 && l2 > r2)
    {
        //no intersect
        return res;
    }
    
    float m2 = l2 - d2;
    if (m2 > r2)
    {
        // no intersect
     	return res;   
    }
    
    float q = sqrt(r2 - m2);
    float t = l2 > r2 ? d - q : d + q;
    
    res.pos = t*ray.dir + ray.org;
    res.t = t;
    res.nn = normalize(res.pos - c);
    
    res.nn = l2 > r2 ? -res.nn : +res.nn;
    
    return res;
}

// Function 694
vec3 calcNormal( in vec3 pos, in float eps )
{
    vec3 kk;
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, kk ).x + 
					  e.yyx*map( pos + e.yyx, kk ).x + 
					  e.yxy*map( pos + e.yxy, kk ).x + 
					  e.xxx*map( pos + e.xxx, kk ).x );
#else
    // trick by klems, to prevent the compiler from inlining map() 4 times
    vec4 n = vec4(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        s[i] += eps*0.25;
        n[i] = map(s.xyz,kk).x;
    }
    return normalize(n.xyz-n.w);
#endif    
}

// Function 695
vec3 localNormal(vec3 p) {
    vec3 n = normal(p), ln;
    vec3 up = camup;
    vec3 side = cross(rd, up);
    return vec3(dot(n,  side), dot(n,  up), dot(n,  -rd));
}

// Function 696
Result raymarch (in vec3 ro, in vec3 rd)
{
    Result res = Result (.0, 0);

    for (int i = 0; i < MAX_ITER; i++)
    {
        vec3 p = ro + res.d * rd;
        Result tmp = scene (p);
        if (abs (tmp.d) < EPSILON*(1. + .125*tmp.d)) return res;
        res.d += tmp.d * STEP_SIZE;
        res.id = tmp.id;
    }

    return res;
}

// Function 697
vec3 Normal( in vec3 pos, in float dist )
{
	vec3  eps = vec3(0.0002,0.0,0.0);
	vec3 nor = vec3(de(pos+eps.xyy) - de(pos-eps.xyy),
					de(pos+eps.yxy) - de(pos-eps.yxy),
					de(pos+eps.yyx) - de(pos-eps.yyx));
	return normalize(nor);
}

// Function 698
vec3 normal(vec3 pos) {
    vec2 eps = vec2(0.001, 0.0);
    return normalize(vec3(	map(pos + eps.xyy) - map(pos - eps.xyy),
                    		map(pos + eps.yxy) - map(pos - eps.yxy),
                         	map(pos + eps.yyx) - map(pos - eps.yyx)));
}

// Function 699
vec3 getNormal( in vec3 p )
{
    vec2 e = vec2(0.005, -0.005);
    return normalize(
        e.xyy * Cube(p + e.xyy) +
        e.yyx * Cube(p + e.yyx) +
        e.yxy * Cube(p + e.yxy) +
        e.xxx * Cube(p + e.xxx));
}

// Function 700
vec3 normal(vec3 p, float d)
{
	float e = 0.005;
	float dx = scene(vec3(e, 0.0, 0.0) + p) - d;
	float dy = scene(vec3(0.0, e, 0.0) + p) - d;
	float dz = scene(vec3(0.0, 0.0, e) + p) - d;
	return normalize(vec3(dx, dy, dz));
}

// Function 701
float castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out uint oID )
{
    float tmi = 1e20;
    mat4  cma; 
    vec3  csi; 
    uint  cin = 0xffffffffU;    
    
    for( uint i=0U; i<NUMBOXES; i++ )
    {
        mat4 ma; vec3 si; getLocation(i, ma, si);

        float res = iBox( ro, rd, ma, si );
        if( res>0.0 && res<tmi )
        {
            cma = ma;
            csi = si;
            cin = i;
            tmi = res;
        }
    }

    uint resID;
    nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID );
    oID = cin*6U + resID;
    
    return (cin==0xffffffffU) ? -1.0 : tmi;
}

// Function 702
float shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)
{
	float lambda = dot(-(ro - sphere.xyz),rd);
	float dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;
	return mix(9999.0,dist,step(0.0,lambda)); 
}

// Function 703
vec3 SuperFastNormalFilter(sampler2D _tex,vec2 uv,float strength){
    float p00 = GetTextureLuminance(_tex,uv);
    return normalize(vec3(-dFdx(p00),-dFdy(p00),1.-strength));
}

// Function 704
float rayMarchToAreaLight(in vec3 ro, in vec3 rd)
{
    const float numStep = 4.0;
    float shadow = 1.0;
  	float stepDist = length(rd - ro) / numStep;
    vec3 dir = normalize(rd - ro);
    for(float i = 0.5; i < numStep; i += 1.0)
    {
        vec3 pos = ro + dir * (i / (numStep));
        shadow *= exp(-densityVoumetricFog(pos * 253.0) * stepDist);
    }
    return shadow;
}

// Function 705
Hit ray_march(vec3 rayfrom, vec3 raydir) {
    // begin at ray origin
    float t = 0.0;
    Hit hit;
    // ray march loop
    for(int i=0; i<MAX_STEPS; ++i) {
        // compute next march point
        vec3 p = rayfrom+t*raydir;
        // get the distance to the closest surface
        hit = map(p);
        // hit a surface
        if(abs(hit.d) < (SURF_DIST*t))
            break;
        // increase the distance to the closest surface
        t += hit.d;
        if(t > MAX_DIST) {
            hit.material = 0;
            break;
        }
    }
    // return the distance to `rayfrom`
    hit.d = t;
    return hit;
}

// Function 706
vec3 TraceRay( const in vec3 vOrigin, const in vec3 vDir )
{	
	vec4 vHit = Raycast(vOrigin, vDir);
	
	vec3 vHitPos = vOrigin + vDir * vHit.x;
	vec3 vHitNormal = GetSceneNormal(vHitPos);
	
	float fShade = 1.0;
	float fGlow = 0.0;
	vec3 vEnvDir = vDir;
	if(vHit.x < kFarClip)
	{
		vEnvDir = reflect(vDir, vHitNormal);
		fGlow = clamp(1.2 - vHit.z * 0.1, 0.0, 1.0);
		fGlow = pow(fGlow, 2.0);
		fShade = fGlow;
	}
	
	vec3 vEnv = texture(iChannel0, vEnvDir).rgb;
	vEnv = vEnv * vEnv;	
	vEnv = -log2(1.0 - min(vEnv, 0.99));

    vec3 vEnvColour = UI_GetColor( DATA_BACKGROUND_COLOR );
	vEnv *= vEnvColour;
	
	vec3 vColour = vEnv * (0.25 + fShade * 0.75);
	
    float fIntensity = UI_GetFloat( DATA_INTENSITY );
    
    float fTemp = 0.0;
	// object glow
	if(vHit.x < kFarClip)
	{	
        vColour += blackbody( fGlow ) * 20.0 * fIntensity;
	}
	
    
	// outer glow
	{				
		float f = 1.0 - clamp(vHit.w * 0.5, 0.0, 1.0);		
		
		float fGlowAmount = 0.0;
		
		// big glow
		float f1 = pow(f, 20.0);
		fGlowAmount += f1 * 2.0 * (0.5 + fShade * 0.5);
	
		// small glow
		float f2 = pow(f, 200.0);
		fGlowAmount += f2 * 5.0 * fShade;
		
		//vColour += vGlowColour * fGlowAmount;
        
        vColour += blackbody( fGlowAmount * 0.25 ) * 10.0 * fIntensity;        
	}    
    
	return vColour;
}

// Function 707
vec3 getNormal(vec3 p, float d) {
    return normalize(vec3(
        getElevation(vec2(p.x-nEPS,p.z), d) - getElevation(vec2(p.x+nEPS,p.z), d),
        2.0*nEPS,
        getElevation(vec2(p.x,p.z-nEPS), d) - getElevation(vec2(p.x,p.z+nEPS), d)
    ));
}

// Function 708
bool RayIntersectAABox (in SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 709
float raymarch(vec3 ori, vec3 dir) {
 
    float t = 0.;
    for(int i = 0; i < MAX_ITER; i++) {
    	vec3  p = ori + dir * t;
        float d = dstScene(p);
        if(d < EPSILON || t > MAX_DIST)
            break;
        t += d * .75;
    }
    return t;
    
}

// Function 710
vec4 rayTrace(Ray ray)
{
  vec4 accumulatedColor = vec4(0,0,0,1);
  float frac = 1.0;
  for(int i=0; i < maxNumberOfReflections + 1; i++)
  {
	  float tMin = infinity;
	  int sphereMin = -1;
      Sphere sphere = spheres[0];
      Material material = materials[0];
	  for(int i=0; i<numberOfSpheres; i++)
	  {	
		float t = intersect(ray, spheres[i]);
		if(t < tMin)
		{
			tMin = t;
			sphereMin = i;
            sphere = spheres[i];
            material = materials[i];
		}
	  }

	  if(!isinf(tMin))
	  {
		vec3 p = ray.position + tMin*ray.direction;
		vec3 n = normalize(p - sphere.position);
		Material mat = materials[0];
		vec4 localColor = blinnPhongShading(p, n, sphere, material);
		accumulatedColor += localColor * frac;
		if(mat.reflectivity > 0.0)
		{
			ray.position = p;
			ray.direction = normalize(reflect(ray.direction, n));
			frac *= mat.reflectivity;
		}
		else
		{
			break;
		}
	  }  
	 
	  accumulatedColor += scene.background * frac;
  }
  return accumulatedColor;
}

// Function 711
vec4 ray(vec3 ro, vec3 rd) {
	vec3 r = ro;
    vec3 final = sky(rd);
    bool hit = false;
    for (int i = 0; i < RES; i++) {
        float f = dF(r, distance(ro,r));
    	r+=rd*f/2.;//, distance(ro,r)); 
        if (f < .5) {
            hit = true;
        }
    }
    if (hit) {
    	final =( texture(iChannel0, r.xz/100.0).gbr+
                texture(iChannel0, r.xz/10.0).bgr)/2.; 
    }
    return vec4(final, distance(ro,r));
}

// Function 712
float raymarchShadows(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    for(int i = 0; i < 50; i++) {
        vec3 p = ro + rd * t;
        float d = intersectSpheres(p, true).y;
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            break;
    }
    return sh;
}

// Function 713
vec3 EvalRay(Ray ray, float t) {
    return ray.o + ray.d * t;
}

// Function 714
vec3 GetRayDirection(float fov, vec2 res, vec2 fragCoord) {
    vec2 xy = fragCoord - res/2.;
    float z = res.y / tan(radians(fov/2.));
    return normalize(vec3(xy, -z));
}

// Function 715
vec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )
{
    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);
    float t0 = fract( time );
    float t1 = fract( time + 0.5 );
    
    float o0 = t0 - 0.5;
    float o1 = t1 - 0.5;
    
    float i0 = floor( time );
    float i1 = floor( time + 0.5 );
    
    vec2 vUV0 = vUV + Hash2(i0);
    vec2 vUV1 = vUV + Hash2(i1);
    
    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );
    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );

    float weight = abs( t0 - 0.5 ) * 2.0;
    //weight = smoothstep( 0.0, 1.0, weight );

    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );
    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );
    
    vec4 result=  mix( sample0, sample1, weight );
    result.xyz = normalize(result.xyz);

    fOutFoamTex = mix( foam0, foam1, weight );

    return result;
}

// Function 716
float ray( vec3 ro, vec3 rd, out float den )
{

    float t = 0.0, maxD = 0.0; den = 0.0; 
    
    for( int i = 0; i < STEPS; ++i )
    {
    
        vec3 p = ro + rd * t;
        den = map( p );
        maxD = maxD < den ? den : maxD;
        if( maxD > 1.0 || t > FAR ) break;
        t += 0.1;
                
    }
    
    den = maxD;
    return t;

}

// Function 717
float rayMarch(Ray r) {
    float t = EPSILON;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = sceneSDF(r.o + t * r.d);
        if (dist < EPSILON) {
			return t;
        }
        t += dist;
        if (t >= MAX_DIST || i == MAX_MARCHING_STEPS - 1) {
            return MAX_DIST;
        }
    }
    return t;
}

// Function 718
float raySphereIntersect(in Ray ray, in Sphere sphere) {
    
    vec3 rayToSphere = ray.origin - sphere.center;
    float b = dot(rayToSphere, ray.direction);
    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);
	float disc = b*b - c;
    float t = MAXX; // initialize to a large number
    if (disc > 0.0) {
        t = -b - sqrt(disc);
        if (t > 0.00001) {
            return t;
        }
        t = -b + sqrt(disc);
        if (t > 0.00001) {
            return t;
        }  
    }
    return t;
}

// Function 719
vec3 reflectedVal(inout vec3 cam, inout vec3 p){
    vec3 col;
    float ref = objectMapReflectiveness(p);
    float o = (outlineOnOff == true ? 2. : outlineOnOff == false ? 0. : 3.);

	raymarchResult rmRes = raymarch(reflect(p-cam,objectMapNormals(p)), p, RenderDistance * ref, o); //reflected position, if any
    vec3 refR = rmRes.position;
    if(rmRes.type == 2.){
        return vec3(0.); //reflection color of outline
    }
	float b = 0.;
	for(int i = 0; i < lights.length(); i++){ b += shadow(lights[i].position, p); }
    if(b / float(lights.length()) == 0.){ return vec3(0.); }      
    col += objectMapMaterial(refR, p); //add the material of the object you hit
    cam = p;
    p = refR;
	return col;
}

// Function 720
float raySphereIntersect(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {
    
    float a = dot(rayDirection, rayDirection);
    vec3 d = rayOrigin - sphereCenter;
    float b = 2.0 * dot(rayDirection, d);
    float c = dot(d, d) - (sphereRadius * sphereRadius);
    if (b*b - 4.0*a*c < 0.0) {
        return -1.0;
    }
    return (-b + sqrt((b*b) - 4.0*a*c))/(2.0*a);
    
}

// Function 721
vec4 ray_grid(vec3 ro, vec3 rd, out int obj_id){
    const float epsilon = 0.0001;
    float depth = 0.0;
    float stepsize = 1.0;
    //Could use some optimization
    for(int i = 0; i < 50; i++){
        vec3 p = fract(ro + (depth)*rd);
        vec3 F = floor(ro + depth*rd);
        
        if(length(F.xy) < 36.0){
        
            vec4 hash = hash42(F.xy);
            float rad = 0.2 + 0.15*hash.w*hash.z;

            vec3 in_cell = rad+(1.0-2.0*rad)*hash.xyz;

            in_cell.z = 1.0+sqrt(1600.0-dot(F.xy, F.xy));

            vec4 h;
            vec4 h1;
            int obj_id_tmp;
            h1 = ray_sphere(ro-vec3(F.xy, 0.0)-in_cell, rd, rad);
            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
                h = h1;
                obj_id_tmp = 1;
            }
            
            h1 = ray_cylinder(ro-vec3(F.xy, 0.0), rd, in_cell-vec3(0.0, 0.0, 3.0), in_cell, rad/4.0);
            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
                h = h1;
                obj_id_tmp = 2;
            }
            
            if(h.w > 0.0){obj_id = obj_id_tmp; return h;};
        
        }
        vec3 o = 1.0 - max(vec3(0.0), sign(-rd));
        float q1 = min(
            -(p.x-o.x)/rd.x,
            -(p.y-o.y)/rd.y
            );
        
        depth += q1+epsilon;
    }
    return vec4(0.0);
}

// Function 722
bool isReflective(int matID) {
    return (matID == 1 || matID == 6);
}

// Function 723
vec3 GetNormal( in vec3 p ,const bool A)
{
/*	const float d = 0.01;
     const vec2 e = vec2(d,-d);
    return normalize( e.xyy*sdScene( p + e.xyy, A ).x +  e.yyx*sdScene( p + e.yyx, A ).x + 
					  e.yxy*sdScene( p + e.yxy, A ).x +  e.xxx*sdScene( p + e.xxx, A ).x );
*/
    //I love it! from Klems!
    vec4 n = vec4(0);
    for (int i = 0 ; i < 4 ; i++) {
        vec4 s = vec4(p, 0);
        s[i] += 0.001;
        n[i] = sdScene(s.xyz,A).x;
    }
    return normalize(n.xyz-n.w);


}

// Function 724
vec4 raymarch( in vec3 ro, in vec3 rd )
{
    vec4 sum = vec4(0, 0, 0, 0);
    
    // setup sampling - compute intersection of ray with 2 sets of planes
    float2 t, dt, wt;
	SetupSampling( t, dt, wt, ro, rd );
    
    // fade samples at far extent
    float f = .45; // magic number - TODO justify this
    float endFade = f*float(SAMPLE_COUNT)*PERIOD;
    float startFade = .99*endFade;
    
    for(int i=0; i<SAMPLE_COUNT; i++)
    {
        if( sum.a > 0.99 ) continue;

        // data for next sample
        vec4 data = t.x < t.y ? vec4( t.x, wt.x, dt.x, 0. ) : vec4( t.y, wt.y, 0., dt.y );
        // somewhat similar to: https://www.shadertoy.com/view/4dX3zl
        //vec4 data = mix( vec4( t.x, wt.x, dt.x, 0. ), vec4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );
        vec3 pos = ro + data.x * rd;
        pos *= 1.1;
        float w = data.y;
        t += data.zw;
        
        // fade samples at far extent
        w *= smoothstep( endFade, startFade, data.x );
        
        vec4 col = map( pos );
        
        // iqs goodness
        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );
        vec3 lin = vec3(0.54, 0.55, 0.60)*1.79 + 0.35*vec3(0.85, 0.57, 0.3)*dif;
        col.xyz *= lin;
        
        col.xyz *= col.xyz;
        
        col.a *= col.a;
        col.rgb *= col.a;

        // integrate
        sum += col * (1.2 - sum.a) * w * 0.66;
    }

    sum.xyz /= (0.001+sum.w);
     vec3 hsv = rgb2hsv(sum.xyz);
    hsv.x -= 0.06;
    hsv.y -= 0.02;
    hsv.z *=  1.2;
    hsv.z += 0.063;
    sum.xyz = hsv2rgb(hsv);

    return clamp( sum, 0.0, 1.0 );
}

// Function 725
void renderRay(inout ray ray, inout rayMarchHit hit, inout vec3 colour, bool isReflection, float time) {
    vec3 skybox = mix(vec3(0.03,0.1,0.25),vec3(0.5,0.4,0.3),(ray.direction.y*0.5+0.5)+0.2);
	vec3 block= vec3(floor(hit.origin.xz/blockSize), floor(hit.origin.y));
    
    #if defined(DEBUG_OCCLUSION)
        float occlusion = getOcclusion(hit.origin, hit.surfaceNormal, time);
    #endif
    
    if(hit.materialId == MAT_SKY) {
        colour = skybox;
    } else if (hit.materialId == MAT_WALL) {
        textureWall(block, ray, hit, colour, isReflection, time);
    } else if (hit.materialId == MAT_SOLID) {
        textureSolid(block, ray, hit, colour, isReflection, time);
    } else if (hit.materialId == MAT_NEON) {
        #if defined(DEBUG_WHITE_NEON)
        	float lightStrobe = getRoadLightStrobe(hit.distance, time);
        	colour = mix(roadLightColour*0.1,vec3(4.0),lightStrobe)*roadLightBrightness;
        #else 
        	colour = vec3(0.0);
        #endif
    } else {
        colour = vec3(0.5,0.4,0.3);
    }
    #if defined(DEBUG_LIGHTING)
    if (hit.materialId != MAT_NEON) {
        vec3 diffuseLight;
        vec3 specularLight;
        float shininess = 1.0;
        float specularIntensity = 0.1;

        if (hit.materialId == MAT_SOLID || hit.materialId == MAT_WALL) {
            shininess = 5.0;
            specularIntensity = 2.5;
        } else if (hit.materialId == MAT_WINDOW) {
            shininess = 20.0;
            specularIntensity = 2.0;
        } 

        getLight(hit.origin, hit.surfaceNormal, ray.direction, shininess, ray.origin, diffuseLight, specularLight, isReflection, time);

        #if defined(DEBUG_AMBIENT)
            vec3 ambient = skybox;
            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)
            if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {
                float distanceRatio = hit.distance/RAY_MAX_DISTANCE;
                if(distanceRatio<0.4) {
                    float occlusion = 1.0-getOcclusion(hit.origin, hit.surfaceNormal, time);
                    if(distanceRatio>0.2) {
                        occlusion*=1.0-((distanceRatio-0.2)*5.0);
                    } 
                    ambient *= 1.0-occlusion;
                }                 
            }
            #endif
        	diffuseLight += ambient;
        #endif
        
        /*#if defined(DEBUG_AMBIENT)
            vec3 ambient = skybox;
            #if defined(DEBUG_AMBIENT_OCCLUSION) && !defined(DEBUG_OCCLUSION)
                if (hit.materialId == MAT_WALL || hit.materialId == MAT_SOLID) {
                    ambient *= (getOcclusion(hit.origin, hit.surfaceNormal, time));
                }
            #endif
        	diffuseLight += ambient;
        #endif*/

        if (hit.materialId != MAT_WINDOW) {
            colour*=diffuseLight;
        }
        colour+=(specularLight*specularIntensity);
    }
    #else
    //dim the whoels scene down and exagerate the over-brights
    	colour=pow(colour*0.5,vec3(1.7));
    #endif
    
	#if defined(DEBUG_OCCLUSION)
		colour*=occlusion;
	#endif
    
    #if defined(DEBUG_DISTANCE_FOG)
    float distanceFog = hit.distance/RAY_MAX_DISTANCE;
    colour = mix(colour, skybox, distanceFog);
    #endif
    
    #if defined (DEBUG_FACE_FOG)
    if(!isReflection) {
    	float faceFog = getFog(ray.direction+ray.origin,time) * (FACE_FOG_DENSITY+0.1*sin(time*0.1));
    	colour += hit.neon * (0.5+faceFog*2.0);
    	colour = mix(colour, vec3(2.0), faceFog);
    } else {
        colour += hit.neon;
    }
    #else
    colour += hit.neon;
    #endif
}

// Function 726
vec3 getNormal(in vec3 pos, in Sphere sph)
{
    return normalize((pos - sph.cen) / sph.rad);
}

// Function 727
vec2 ct_vfield_normal(
    in vec2 p,
    float npow
){
    vec2 g = vec2(0.0, 0.0);
    
    const int imax = CT_N + 1;
    
    for (int i = 0; i < imax; ++i)
    {
        vec2 dif = g_vfp[i].p - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1];
        float mass = pow(sum, npow);
        
      	g[0] = g[0] + g_vfp[i].m * dif[0] / mass;
      	g[1] = g[1] + g_vfp[i].m * dif[1] / mass;
    }
    
    return normalize(g);
}

// Function 728
DistId castRay(vec3 origin, vec3 dir) {
    float minDist = 1.;
    float maxDist = 100.;

    float t = minDist;
    int matId = -1;
    for (int i=0; i<128; i++) {
        float eps = 1e-4*t;
        DistId res = map(origin + dir*t);
        matId = res.matId;
        if (res.dist < eps || t > maxDist) break;
        t += res.dist;
    }
    if (t > maxDist)
        matId = -1;
    return DistId(t, matId);
}

// Function 729
float raymarch (in vec3 ro, in vec3 rd)
{
    float t = .0;
    float d = .0;
    for (int i = 0; i < 64; ++i) {
        vec3 p = ro + d * rd;
        t = scene (p);
        if (abs(t) < EPSILON*(1. + .125*t)) break;
        d += t * .75;
    }

    return d;
}

// Function 730
bool tubeRayIntersect(out vec3 intPt, in vec4 tube, in vec3 p1, in vec3 p2)
{
    //Since the tubes have no rotation, we don't care where along the y-axis
    //the ray hits and can therefore ignore the y-coordinate of the ray
    vec2 flatp1 = vec2(p1.xz);
    vec2 flatp2 = vec2(p2.xz);
    
    //We can perform a simple ray-circle intersection between a cross-section
    //of the tube and our newly flattened ray.
    vec2 center = vec2(tube.xy);
    float radius = float(tube.z);
    
    //We get p1 position in circle space.
    vec2 localP1 = flatp1 - center;
    
    //Calculate and normalize the ray direction vector, then drop the
    //y-coordinate of that.
    vec3 orRayDir = normalize(p2 - p1);
    vec2 rayDir = vec2(orRayDir.xz);
    
    //Caculate ray-circle intersection
    float a = dot(rayDir,rayDir);
    float b = dot(rayDir,localP1);
    float c = dot(localP1,localP1) - (radius*radius);
    float delta = (b * b) - (a * c);
    
    //No intersection
    if (delta <= 0.0)
    {
        return false;
    }
    
    else 
    {
        //Calculate t with some quadratic magic and store intersection point
        //where ro + rd*t = y into intPt.
        float t = (-b-sqrt(delta)*sign(radius))/a;
        intPt = p1 + (orRayDir*t);
        return true;
    }
}

// Function 731
vec3 furNormal(vec3 pos, float density) {
    	float eps = 0.0001;
    	vec3 n;
    	n.x = furDensity( vec3(pos.x + eps, pos.y, pos.z)) - density;
    	n.y = furDensity( vec3(pos.x, pos.y + eps, pos.z)) - density;
    	n.z = furDensity( vec3(pos.x, pos.y, pos.z + eps)) - density;
    	return normalize(n);
	}

// Function 732
vec3 simple_refract_inv( vec3 I, vec3 R, vec3 Z ) { vec3 result = normalize( I - R * length( simple_refract( I, Z ) ) ); return I - R * length( simple_refract( I, result ) ); }

// Function 733
bool raymarch(vec3 ro, vec3 rd, inout float t, float t1, float step_size, float eps) {
    for (int i=int(ZERO); i<100; i++) {
        float dt = step_size*mapDist(ro+rd*t);
        t += dt;
        if (abs(dt) < eps) break;
        if (t > t1) return false;
    }
    return true;
}

// Function 734
float RaySphere( vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius )
{
	vec3 oc = rayOrigin - spherePos;
	
	float b = dot( oc, rayDir );
	float c = dot( oc, oc ) - sphereRadius * sphereRadius;
	float h = b * b - c;
	
	float t;
	if ( h < 0.0 )
    {
		t = -1.0;
    }
	else
    {
		t = ( -b - sqrt( h ) );
    }
	return t;
}

// Function 735
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 160; j ++) {
    d = ObjDf (ro + rd * dHit);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 736
vec3 castRay(in vec3 rayOrigin, in vec3 rayDirection)
	{
		const int 	numSteps = 128;
		const float	dMin = 0.0,
					dNear = 0.000001,
					dMax = 100.0;
		float		d = dMin,
					dLast = dMin,
			m = -1.0;
		for(int i=0; i<numSteps; i++)
		{
			vec3 p = rayOrigin+rayDirection*d;
			vec2 res = sceneMap(p, rayDirection);

			dLast = res.x;
			d += res.x;
			m = res.y;

			if(res.x<dNear || d>dMax)
				break;
		}
		if(d>dMax)
			m = -1.0;

		return vec3(d, m, dLast);
	}

// Function 737
vec3 getNormal(vec2 p, int noiseLayers)
{	
 	float v00 = getTerrainNoise(p, noiseLayers);
    float v10 = getTerrainNoise(p + vec2(EPSILON, 0.0), noiseLayers);
    float v01 = getTerrainNoise(p + vec2(0.0, EPSILON), noiseLayers);
    
    return normalize(cross(vec3(EPSILON, 0, v10 - v00), vec3(0, EPSILON, v01 - v00)));
}

// Function 738
vec3 getRayDir(vec3 ro, vec2 uv) {
	vec3 forward = normalize(-ro),
	     right = normalize(cross(vec3(0, 1, 0), forward));
	return normalize(forward + right * uv.x + cross(forward, right) * uv.y);
}

// Function 739
void ray_march_scene(Ray r, float k, inout vec3 c)
{
    float uniform_step = k;
    float jit = 1.;
    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));
   
    float t_gen = 1.;

    float param_t = intersect_sphere(r, m.pos, RADIUS);
    if(param_t <= -1.)
        return;
    vec3 p = ray_interpolation(r, k*jit);        
     
    //rgb transparency               
    
    vec3 t_acc = vec3(1.);	// accumulated parameters for transparency
    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );
    int s = 0;
    
    for(s; s <90; s++)
    {               
        float dist_dist = dot(p-cam.pos, p-cam.pos);
        float dist_center = length(m.pos-cam.pos);
        vec3 center = p-m.pos;

        float d = length(center)-RADIUS-.5-jit*k;
        float size = length(center)/RADIUS;

        if(length(center)-RADIUS < 0.)
        {
            
            #if COLOR            
            #if ANIM      
            	anim = iTime/10.;
            
            #endif
            float n = fbm( ( 
                p/( clamp(0., RADIUS, length(center)) + cos(PI+snoise(p)) - 1./size*anim ) //shockwave stuff
            			) )  ;
            

            float mask = smoothstep(1.,
                                   	20.*RADIUS,
                                  	RADIUS/length(center));

            
            //Optical density/depth : dens for density
            float dens = ( clamp( mask,
                               	  0.,
                                  1.) *n);
            
           if(length(p-cam.pos) >(dist_center+m.radius) || 
           (k*dens  < -9.9))
        	{
         	break;
        	}
            //How colors (rgb) are absorbed at point p in the current iteration
            //k is the step size          
             vec3 rgb_t = exp(-vec3(
                		k * 15. * dens, 
                      	k * 10. * dens,
              	      	k * 15. * 1./size * dens));    
            
            t_acc *= (rgb_t);           
    
    		//blending
   			c += t_acc*vec3(1.)*(1.-rgb_t);
            #endif
        }

        //if it will never be in the shape anymore, return;        
        
        p += r.dir*k;

        k = uniform_step;
    }
    

    //c =float(s)/vec3(50,150,20); return;

    #if COLOR

    #else
    c = vec3(t_gen); return;
    #endif
}

// Function 740
float raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr, out float coverage) {
    // - r0: ray origin
    // - rd: normalized ray direction
    // - s0: sphere center
    // - sr: sphere radius
    // - Returns distance from r0 to first intersecion with sphere,
    //   or MAX_DST if no intersection.
    float a = dot(rd, rd);
    vec3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
    
    float inside = b*b - 4.0*a*c;
    
    if (inside < 0.0) {
        return MAX_DST;
    }
    
    float dst = (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);
    
    // This is a fallof around the edge used for AO
    // chnage the magic value for a smoother border
    coverage = S(inside, 0.0, 0.65 * sr * dst / iResolution.x);
    
    return dst;
}

// Function 741
bool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, out float t, out SurfaceHitInfo isect ) {
    vec3 boxMin = vec3( minX, minY, minZ );
    vec3 boxMax = vec3( maxX, maxY, maxZ );
    
    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;
    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;
    vec3 MAX = max ( OMAX, OMIN );
    vec3 MIN = min ( OMAX, OMIN );
    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );
    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );
    
    if ( t1 <= t )
        return false;
    
    isect.position_ = ray.origin + ray.dir*t;
    if( isect.position_.x < minX - EPSILON ) {
        isect.normal_ =  vec3( -1.0, 0.0, 0.0 );
    } else if( isect.position_.x > maxX - EPSILON ) {
        isect.normal_ =  vec3( 1.0, 0.0, 0.0 );
    } else if( isect.position_.y < minY - EPSILON ) {
        isect.normal_ =  vec3( 0.0, -1.0, 0.0 );
    } else if( isect.position_.y > maxY - EPSILON ) {
        isect.normal_ =  vec3( 0.0, 1.0, 0.0 );
    } else if( isect.position_.z < minZ - EPSILON ) {
        isect.normal_ =  vec3( 0.0, 0.0, -1.0 );
    } else /*if( isect.position_.z > maxZ - EPSILON ) )*/ {
        isect.normal_ =  vec3( 0.0, 0.0, 1.0 );
    }
    
    return true;
}

// Function 742
vec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )
{
	vec3 vForward = normalize(vCameraTarget - vCameraPos);
	vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));
	vec3 vUp = normalize(cross(vForward, vRight));
							  
	vec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);

	return vDir;
}

// Function 743
vec3 box_normal_from_point(vec3 point,vec3 box_extents)
{
	vec3 normal = vec3(0.0);
	float m = INF;
	float d;

	d = abs(box_extents.x - abs(point.x));
	if (d < m)
	{
		m = d;
		normal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X
	}

	d = abs(box_extents.y - abs(point.y));
	if (d < m)
	{
		m = d;
		normal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y
	}

	d = abs(box_extents.z - abs(point.z));
	if (d < m)
	{
		m = d;
		normal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z
	}

	return normal;
}

// Function 744
vec3 GetNormal(vec3 hitPoint) {
    float ep = 0.0002;
#if 0    
    vec3 e=vec3(1e-2,0,0);
    float d = sceneWithMaterials(hitPoint).x;
    return normalize(vec3(sceneWithMaterials(hitPoint + e.xyy).x - d,
                          sceneWithMaterials(hitPoint + e.yxy).x - d,
                          sceneWithMaterials(hitPoint + e.yyx).x - d));
#else
    // inspired by iq who was inspired by klems
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);
        n += e*sceneWithMaterials(hitPoint+e*ep).x;
    }
    return normalize(n);
#endif    
}

// Function 745
float getRayleigMultiplier(vec2 p, vec2 lp){
	return 1.0 + pow(1.0 - clamp(distance(p, lp), 0.0, 1.0), 2.0) * pi * 0.5;
}

// Function 746
bool customRefract(vec3 v, vec3 n, float niOverNt, out vec3 refracted)
{
    vec3 uv = normalize(v);
    float dt = dot(uv, n);
    float discriminant = 1.0 - niOverNt * niOverNt * (1.0 - dt * dt);
    if(discriminant > 0.0)
    {
        refracted = niOverNt * (uv - n * dt) - n * sqrt(discriminant);
        return true;
    }
    return false;
}

// Function 747
vec4 castRay( in vec3 ro, in vec3 rd, in float time, 
              out ivec2 outPrismID, out int outFaceID )
{
	ivec2 hid = hexagonID(ro.xz);
    
	vec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );

    const float k3 = 0.866025;
    const vec2 n1 = vec2( 1.0,0.0);
    const vec2 n2 = vec2( 0.5,k3);
    const vec2 n3 = vec2(-0.5,k3);
    
    float d1 = 1.0/dot(rd.xz,n1);
    float d2 = 1.0/dot(rd.xz,n2);
    float d3 = 1.0/dot(rd.xz,n3);
    float d4 = 1.0/rd.y;
    
    float s1 = (d1<0.0)?-1.0:1.0;
    float s2 = (d2<0.0)?-1.0:1.0;
    float s3 = (d3<0.0)?-1.0:1.0;
    float s4 = (d4<0.0)?-1.0:1.0;

    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;
    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;
    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;

    // traverse hexagon grid (in 2D)
    bool found = false;
    vec2 t1, t2, t3, t4;
	for( int i=0; i<100; i++ ) 
	{
        // fetch height for this hexagon
		vec2  ce = hexagonCenFromID( hid );
        float he = 0.5*map(ce, time);

        // compute ray-hexaprism intersection
        vec3 oc = ro - vec3(ce.x,he,ce.y);
        t1 = (vec2(-s1,s1)-dot(oc.xz,n1))*d1;
        t2 = (vec2(-s2,s2)-dot(oc.xz,n2))*d2;
        t3 = (vec2(-s3,s3)-dot(oc.xz,n3))*d3;
        t4 = (vec2(-s4,s4)*he-oc.y)*d4;
        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));
        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));
        if( tN<tF && tF>0.0 )
        {
            found = true;
            break;
        }
        
        // move to next hexagon
             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;
        else if( t2.y<t3.y )              hid += i2;
        else                              hid += i3;
	}

	if( found )
    {
                         {res=vec4(t1.x,s1*vec3(n1.x,0,n1.y)); outFaceID=(d1<0.0)?-1: 1;}
        if( t2.x>res.x ) {res=vec4(t2.x,s2*vec3(n2.x,0,n2.y)); outFaceID=(d2<0.0)?-2: 2;}
        if( t3.x>res.x ) {res=vec4(t3.x,s3*vec3(n3.x,0,n3.y)); outFaceID=(d3<0.0)?-3: 3;}
        if( t4.x>res.x ) {res=vec4(t4.x,s4*vec3( 0.0,1,0));    outFaceID=(d4<0.0)? 4:-4;}

        outPrismID = hid;
    }
    
	return res;
}

// Function 748
vec3 computePixelRay( in vec2 p, out vec3 cameraPos )
{
    // camera orbits around explosion
	
    float camRadius = 3.8;
	// use mouse x coord
	float a = iTime*20.;
	if( iMouse.z > 0. )
		a = iMouse.x;
	float theta = -(a-iResolution.x)/80.;
    float xoff = camRadius * cos(theta);
    float zoff = camRadius * sin(theta);
    cameraPos = vec3(xoff,expCenter.y,zoff);
     
    // camera target
    vec3 target = vec3(0.,expCenter.y,0.);
     
    // camera frame
    vec3 fo = normalize(target-cameraPos);
    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));
    vec3 up = normalize(cross(fo,ri));
     
    // multiplier to emulate a fov control
    float fov = .5;
	
    // ray direction
    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);
	
	return rayDir;
}

// Function 749
bool raySceneIntersection( in Ray ray, in float distMin, out RayHit hit, out int objId, out float dist ) {
    float nearest_dist = 10000.0;
    
    //check lights
    for( int i=0; i<LIGHT_COUNT; i++ ) {
        float distToLight;
        if( raySphereIntersection( ray, spherelight[i], distToLight ) && (distToLight > distMin) && ( distToLight < nearest_dist ) ) {
            nearest_dist = distToLight;

            hit.pos = ray.origin + ray.dir*nearest_dist;
            hit.normal = normalize(hit.pos - spherelight[i].pos);
            hit.materialId = i;
            objId = i;
        }
    }
    
    //check sphere
    float distToSphere;
    if( raySphereIntersection( ray, sphereGeometry, distToSphere ) && (distToSphere > distMin) && ( distToSphere < nearest_dist ) ) {
        nearest_dist = distToSphere;

        hit.pos = ray.origin + ray.dir*nearest_dist;
        hit.normal = normalize(hit.pos - sphereGeometry.pos);
        
        vec3 n = normalize( vec3( hit.normal.x, 0.0, hit.normal.z ) );
        float u = acos( dot( vec3(1.0, 0.0, 0.0), n ) )/PI;
        float v = acos( dot( vec3(0.0, 1.0, 0.0), hit.normal ) )/PI;
        
        hit.uv = vec2( u, v );
        
        hit.materialId = MTL_SPHERE;
        objId = 2;
    }
    
    //check ground
    float distToPlane;
    if( rayPlaneIntersection( ray, ground, distToPlane ) && (distToPlane > distMin) && (distToPlane < nearest_dist ) ){
        nearest_dist = distToPlane;

        hit.pos = ray.origin + ray.dir*nearest_dist;
        hit.normal = ground.abcd.xyz;
        float uvScale = 2.0;
        hit.uv = vec2( abs( mod( hit.pos.x, uvScale )/uvScale ), abs( mod(hit.pos.z, uvScale)/uvScale ) );
        hit.materialId = MTL_WALL;
        objId = 3;
    }
    
    dist = nearest_dist;
    if( nearest_dist < 1000.0 ) {
    	hit.E = ray.dir*(-1.0);
        return true;
    } else {
    	return false;
    }
}

// Function 750
vec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){
	vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 751
float ray_invaabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)
{
	float t = 0.0;
	for (int axis = 0; axis < 3; axis++) {
		float d = dir[axis];
		float p = pos[axis];
		float mn = aabb_min[axis];
		float mx = aabb_max[axis];
		float nt = 0.0;
		if (d >= 0.0 && p < mx) {
			float nt = (mx-p)/d;
			if (axis == 0 || nt < t) {
				t = nt;
				normal = vec3(0.0);
				normal[axis] = -1.0;
			}
		} else if (d < 0.0 && p > mn) {
			float nt = (mn-p)/d;
			if (axis == 0 || nt < t) {
				t = nt;
				normal = vec3(0.0);
				normal[axis] = 1.0;
			}
		}
	}

	return t;
}

// Function 752
vec3 normal(vec3 p){
	vec2 e = vec2(.001, 0.0);
    return normalize(vec3(
    	getDist(p + e.xyy) - getDist(p - e.xyy),
        getDist(p + e.yxy) - getDist(p - e.yxy),
        getDist(p + e.yyx) - getDist(p - e.yyx)
    ));
}

// Function 753
Ray generateRay(in Camera cam, in vec2 uv)
{
    return Ray(cam.o, normalize(uv.x * cam.e0 + uv.y * cam.e1 + cam.e2));
}

// Function 754
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
    /*
	vec3 eps = vec3( 0.0005, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
	*/
}

// Function 755
vec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)
{
    // only consider front face hits
    // Note: if you disable this line, you may get problems due to the fact that i don't push shadow rays away from the bounce surface.
    if (dot(rayDir, plane.xyz) >= 0.0)
        return vec4(-1.0);    
    
    // calculate the collision time
    float collisionTime = (-plane.w - dot(plane.xyz, rayPos)) / dot(plane.xyz, rayDir);
        
    // only consider positive hit times
    if (collisionTime < 0.0)
        return vec4(-1.0);
    
    // calculate normal
    bool fromInside = dot(plane.xyz, rayDir) > 0.0;
    vec3 normal = plane.xyz * (fromInside ? -1.0 : 1.0);
    
    // calculate tangent, bitangent
    vec3 tangent;
    if (abs(normal.x) > 0.1)
        tangent = normalize(cross(vec3(0.0, 1.0, 0.0), normal));
    else
        tangent = normalize(cross(vec3(1.0, 0.0, 0.0), normal)); 
	vec3 bitangent = cross(normal, tangent);
    
    // calculate uv
    vec3 intersectionPoint = rayPos + rayDir * collisionTime;
    uv.x = dot(intersectionPoint, tangent);
    uv.y = dot(intersectionPoint, bitangent);
    
    // return hit info
    return vec4(collisionTime, normal);
}

// Function 756
vec3 normal( in vec3 pos, in float r )
{
	vec2 eps = vec2( r*1., 0.0);
	vec3 nor = vec3(
	    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),
	    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),
	    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx) );
	return normalize(nor);
}

// Function 757
vec3 calcNormal(vec3 pos) {
  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;
  return normalize(e.xyy * scene(pos + e.xyy).x +
                   e.yyx * scene(pos + e.yyx).x +
                   e.yxy * scene(pos + e.yxy).x +
                   e.xxx * scene(pos + e.xxx).x);
}

// Function 758
mat3 mat3FromNormal(in vec3 n) {
    vec3 x, y;
    branchlessONB(n, x, y);
    return mat3(x,y,n);
}

// Function 759
vec3 NormalBlend_Whiteout(vec3 n1, vec3 n2)
{
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;
    
	return normalize(vec3(n1.xy + n2.xy, n1.z*n2.z));    
}

// Function 760
vec4 castRay(const in vec3 ro, const in vec3 rd) {
  float t = 1.0;
  float tmax = 50.0;

  float precis = 0.002;
  for(int i = 0; i < 50; i++) {
    float dist = mapDistance(ro + rd * t);
    if(dist < precis || t > tmax)
      break;
    t += dist;
  }

  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;
  return vec4(t, m);
}

// Function 761
vec3 raymarch(in vec3 from, in vec3 dir) 

{
	float ey=mod(t*.5,1.);
	float glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;
	vec2 d=vec2(1.,0.);
	vec3 p, col=vec3(0.);
	vec3 origdir=dir,origfrom=from,sphNorm;
	
    for (int i=0; i<RAY_STEPS; i++) {
		if (d.x>det && totdist<6.0) {
			p=from+totdist*dir;
			d=de(p);
			det=detail*(1.+totdist*60.)*(1.+ref*5.);
			totdist+=max(detail,d.x); 
			if (d.y<.5) glow+=max(0.,.02-d.x)/.02;
		}
	}
	vec3 ov=normalize(vec3(1.,.5,1.));
	vec3 sol=dir+lightdir;
    float l=pow(max(0.,dot(normalize(-dir*ov),normalize(lightdir*ov))),1.5)+sin(atan(sol.x,sol.y)*20.+length(from)*50.)*.002;
    totdist=min(5.9,totdist);
    p=from+dir*(totdist-detail);
    vec3 backg=.4*(1.2-l)+LIGHT_COLOR*l*.75;
	backg*=AMBIENT_COLOR*(1.-max(0.2,dot(normalize(dir),vec3(0.,1.,0.)))*.2);
	float fondo=0.;
	vec3 pp=p*.5+sin(t*2.)*.5;
    for (int i=0; i<15; i++) {
        fondo+=clamp(0.,1.,texture1(pp+dir*float(i)*.02))*max(0.,1.-exp(-.03*float(i)));
    }
    vec3 backg2=backg*(1.+fondo*(LIGHT_COLOR)*.75);
    if (d.x<.01) {
        vec3 norm=normal(p);
		col=mix(light(p-abs(d.x-det)*dir, dir, norm, d.y),backg,1.-exp(-.3*totdist*totdist)); 
		col = mix(col, backg2, 1.0-exp(-.02*pow(abs(totdist),2.)));
	} else { 
		col=backg2;
	}
	vec3 lglow=LIGHT_COLOR*pow(abs(l),30.)*.5;
    col+=glow*(.3+backg+lglow)*.005;
	col+=lglow*min(1.,totdist*totdist*.03)*1.2;
	return col; 
}

// Function 762
vec3 getNormal( in vec2 pos)
{
    vec2  eps = vec2( 1., 0 );
    return normalize( vec3( terrain(pos-eps.xy) - terrain(pos+eps.xy),
                           2.*eps.x,
                 		   terrain(pos-eps.yx) - terrain(pos+eps.yx) ));
}

// Function 763
sdf_result send_ray(vec3 pos,vec3 dir,int maxIters){
    sdf_result sdf;
    sdf.dist=0.0;
    sdf.start=pos;
    sdf.end=sdf.start;
    sdf.dir=normalize(dir);
    int i=0;
    float dist=0.0;
    for(i=0;i<maxIters;i++){
	    float d=sceneSDF(sdf.end);
        sdf.finalDist=d;
        sdf.dist+=d;
		sdf.end+=d*sdf.dir;
        if(d<EPSILON){
            return sdf;
        }
    }
    return sdf;
}

// Function 764
vec3 normal(vec3 p) {
	vec2 e = vec2(1,0)/1e3;
    p += 0.01 * vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx))/ (2. * length(e));
	return normalize(p);
}

// Function 765
Ray setupRay(in vec2 uv, in vec3 origin)
{
 	vec2 sPosition = 2.*uv - 1.;
    float aspect = iResolution.y/iResolution.x;
    
    float width = tan(FOV);
    float height = width*aspect;
    
    vec3 forward = normalize(vec3(0, 0, 1));
    vec3 up = normalize(vec3(0,1, 0));
    vec3 right = normalize(cross(up, forward));
    
    Ray rayT;
    rayT.direction = normalize(forward+sPosition.x*width * right+sPosition.y*height*up);
    rayT.origin = origin;
    return rayT;
    //vec4 color = shade(camOrigin, direction, lightPos);   
}

// Function 766
vec3 calcNormal( in vec3 pos, in float ic )
{
	return mix( normalize(vec3(pos.x,0.0,pos.z)), vec3(0.0,1.0,0.0), ic );
}

// Function 767
float castShadowRay(vec3 ro,vec3 rd
){for( int i=0; i<NUMBOXES; i++ //es100 safe
 ){mat4 ma; vec3 si; getLocation(i, ma, si)
  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}
 ;return 1.;}

// Function 768
vec3 castray(vec3 pos, vec3 dir) {
    vec3 c = vec3(0.0);
    vec2 trange = boxIntersect(pos - vec3(0, 1.4, 0), dir, vec3(36.0, 5.5, 36.0));
    vec3 p = pos;
    float mat = -1.0;
    if (trange.y > 0.0) {
        int i = 0;
        float t = trange.x;
        for (; t < trange.y && i < 150; ++i) {   
            p = pos + t * dir;
            vec2 res = sdf(p);
            float d = res.x;
            if (d < 0.05) {
                if (max(abs(p.x), abs(p.z)) > 32.0)
                    break;
                mat = res.y;
                if (mat == BOARD_MAT) {
                    c = floorColor(p.xz, dir);
                    break;
                }
                vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);
                albedo += vec3(.1,.1,.05) * (mat == BLACK_MAT ? 0.5 : 2.2) * (0.2 * sin(15.0 * p.x + 25.0 * sin(2.0 * p.z)));
                c = shade(albedo, norm(p), p, dir, 1.0, true);
                break;
            }
            t += d;
        }
        t = min(t, trange.y);
        p = pos + t * dir;
    }
    if (RENDER_SKY && mat < 0.0) {
        // Sky
        const vec3 C1 = vec3(0.12, 0.08, 0.08);
        const vec3 C2 = vec3(0.04, 0.03, 0.06) * 2.0;
        float y = dir.y + 0.2 * triNoise3D(dir * 2.0, 1.0);
        c = mix(C1, C2, smoothstep(-0.35, 0.0, y));
        float disp = triNoise3D(dir * 0.9, 0.08);
        c += vec3(1.0) * (pow(disp, 5.0) * 3.47);
        
        // Fade to black
        float h = dot(dir - 0.08 * triNoise3D(dir * 0.3, 0.0), vec3(0.02, 1.0, -0.01));
        float hstart = -0.2;
        float hend = -0.5;
        c = mix(c, vec3(0.0), smoothstep(hstart, hend, h));
    }
    
    // Mist
    float fog = integrateFog(pos, p);
    const vec3 FOG_COLOR = vec3(1.5, 1.1, 0.9);
    return mix(c, FOG_COLOR, clamp(fog, 0.0, 1.0));
}

// Function 769
vec3 calcNormal( in vec3 pos ){
    
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x );
    return normalize(nor);
}

// Function 770
vec3 calculateNormal(in vec3 currentPosition) {
    const vec3 small_step = vec3(0.001, 0.0, 0.0);

    float gradient_x = mapTheWorld(currentPosition + small_step.xyy) - mapTheWorld(currentPosition - small_step.xyy);
    float gradient_y = mapTheWorld(currentPosition + small_step.yxy) - mapTheWorld(currentPosition - small_step.yxy);
    float gradient_z = mapTheWorld(currentPosition + small_step.yyx) - mapTheWorld(currentPosition - small_step.yyx);

    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);

    return normalize(normal);
}

// Function 771
vec3 traceRay(in vec3 origin, in vec3 direction) {
    

   vec3 t=vec3(1.0);
    
    for (int i = 0; i < 20; i++) {
        vec3 hit = vec3(map(origin + direction * t.x),1.0);
        
        t += hit;
       
    }
return t;
    

    
}

// Function 772
void GetNormal(in vec3 pos, in vec3 cam_up, in vec3 cam_right, in vec3 cam_forward, in Obj obj, out vec3 normal)
{
	Obj obj_copy = obj;
	vec3 pos_up = pos + cam_up * EPSILON;
	vec3 pos_down = pos - cam_up * EPSILON;
	vec3 pos_left = pos - cam_right * EPSILON;
	vec3 pos_right = pos + cam_right * EPSILON;
	
	//up
	obj_copy.m_obj_idx = -1;
	Map(pos_up, obj_copy);
	pos_up += cam_forward * obj_copy.m_dist;
	
	//down
	obj_copy.m_obj_idx = -1;
	Map(pos_down, obj_copy);
	pos_down += cam_forward * obj_copy.m_dist;
	
	//left
	obj_copy.m_obj_idx = -1;
	Map(pos_left, obj_copy);
	pos_left += cam_forward * obj_copy.m_dist;
	
	//right
	obj_copy.m_obj_idx = -1;
	Map(pos_right, obj_copy);
	pos_right += cam_forward * obj_copy.m_dist;
	
	normal = normalize(cross(pos_right-pos_left, pos_up-pos_down));
}

// Function 773
vec3 getRay(vec2 uv){
    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);
	vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);	
    if(Resolution.x < 400.0) return proj;
	vec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;
    return ray;
}

// Function 774
vec3 normalQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {
    vec3 x = cpQuadBoundary(q0,q1,q2,q3, p);
    return normalize(p - x);
}

// Function 775
bool isRayIntersectSphere(vec3 ro, vec3 rd, vec3 center, float radius)
{
    float tmin = -1.0, tmax = -1.0;
    float d = IntersectSphere(ro, rd, center, radius, tmin, tmax);
    return tmin>-1.0;
}

// Function 776
vec3 GetRayDir(vec2 uv) {
	vec3 up = vec3(0., 1., 0.);
    vec3 vdir = normalize(at - eye);
    vec3 xdir = normalize(cross(vdir, up));
    up = normalize(cross(xdir, vdir));
    vec3 center = eye + vdir * near;
    vec2 zuv = (uv - vec2(.5)) * iResolution.xy * zoom;
    vec3 pix = center + zuv.x * xdir + zuv.y * up;
    return pix - eye;
}

// Function 777
vec3 RayMarch(vec3 ro, vec3 rd) {
	float dO=MIN_DIST;
    float dS;
    float matId=0.;
    
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        vec2 g = GetDist(p);
        dS = g.x;
        dO += dS;
        matId = g.y;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    
    return vec3(dO, abs(dS), matId);
}

// Function 778
vec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax, bool refrSph) {
    vec3 res = vec3(ID_NONE);
    float t = tmin;
    for (int i = 0; i < 250; i++) {
        vec3 p = ro + rd * t;
        res = vec3(intersect(p, refrSph), t);
        float d = res.y;
        if (d < (0.001 * t) || t > tmax)
            break;
        t += 0.5 * d;
    }
    return res.xz;
}

// Function 779
float rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)
{
    d = max(d,.0);
    float oldD = d;
    bool hit = false;
    for (int i = 0; i < 80; i++)
    {
		float de = mapDE(pos + dir * d);

       if(de < sphereSize(d) || d > 2000.0) break;

		oldD = d;
		d += 0.5*de;

        
   
    }
	if (d > 2000.0)
		oldD = 2000.0;

    
    return oldD;
}

// Function 780
vec3 Normal(vec3 p)
{
	vec3 o = vec3(0.01, 0, 0);
    return normalize(vec3(Scene(p-o.xyz)-Scene(p+o.xyz),Scene(p-o.zxy)-Scene(p+o.zxy),Scene(p-o.yzx)-Scene(p+o.yzx)));
}

// Function 781
vec3 calcNormal( in vec3 pos, in float ic )
{
	if( ic>1.5 ) return vec3(0.0,1.0,0.0);
	return normalize(pos*vec3(1.0,1.0-ic,1.0));
}

// Function 782
vec3 normal(in vec3 p) {
	const vec2 e = vec2(0.002, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 783
Ray cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ 
	vec3 v = normalize(lookAtCenter -viewPoint);
    
    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));
    vec3 n2 = cross(n1,v);  
        
    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);
                                    
    Ray ray;
                    
    ray.origin = viewPoint;
   	ray.direction =  normalize(lookAtPoint - viewPoint);
    
    return ray;
}

// Function 784
vec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol, out float resT )
{
	vec4 sum = vec4(0.0);
    float t = tmax;
	for( int i=0; i<512; i++ )
	{
		vec3 pos = ro + t*rd;
		if( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;
		
		vec4 col = mapTrees( pos, rd );

		col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );
        
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	
		
		t += 0.0035*t;
	}
    
    resT = t;

	return clamp( sum, 0.0, 1.0 );
}

// Function 785
vec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance, int panel, in vec2 pixelPos)
{
    // trace primary ray
	SRayHitInfo hitInfo = RayVsScene(rayPos, rayDir, panel, pixelPos);
    
    // set the hitDistance out parameter
    hitDistance = hitInfo.dist;
    
    if (hitInfo.dist == c_rayMaxDist)
        return texture(iChannel0, rayDir).rgb;
    
    // calculate where the pixel is in world space
	vec3 hitPos = rayPos + rayDir * hitInfo.dist;
    hitPos += hitInfo.normal * c_hitNormalNudge;

    // shoot a shadow ray    
    SRayHitInfo shadowHitInfo = RayVsScene(hitPos, c_lightDir, panel, pixelPos);
    float shadowTerm = (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f;
    
    // do diffuse lighting
    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);
	return c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;
}

// Function 786
vec2 raycast( in vec3 ro, in vec3 rd )
{
    
    // raymarch primitives   
    // distance from origin
    float dO=0.;
    float ID = -1.;
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO*rd;
        
        // get distance to seam
        vec2 getObj = map(p);
        ID = getObj.y;
        float ds = getObj.x;
        //move origin to new point
        if(ID == 15.){
            dO+=ds*.8;
        }
        else if(ID == 17.){
            dO+=ds*.8;
        }
        else if(ID == 1.){
            dO+=ds*.8;
        }
        else if(ID == 90.){
            dO+=ds*.8;
        }else{
            dO+=ds;
        }
        if(ds < SURFACE_DIST || dO > MAX_DIST){
            break;
        }
    }
    return vec2(min(dO, MAX_DIST),ID);
}

// Function 787
vec3 calcNormal(vec3 p, float t) {
    return normalize(cross(dFdy(p),dFdx(p)));
}

// Function 788
vec2 castRay( vec3 ro, vec3 rd, int octaves) {
	const float p = 0.0001; // precision
	float t = 0.0; // distance
	float h = p * 2.0; // step
	float m = -1.0;
	for (int i=0; i<34; i++) {
		if (abs(h)>p || t<dMax ) {
			t += h; // next step
			vec2 res = map(ro + rd*t, octaves); // get intersection
			h = res.x; // get distance
			m = res.y; // get material
		} 
		else break;
	}
	if (t>dMax) m = -1.0; // if no intersection, material ID is -1.0;
	return vec2(t, m);
}

// Function 789
vec3 GetNormal(vec3 p)
{
    float d = GetDist(p);
    vec2 e = vec2(0.01,0);
    
    vec3 n = d-vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    return normalize(n);
}

// Function 790
vec3 calcNormal( in vec3 pos, float e, in vec4 c )
{
    vec3 eps = vec3(e,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy,c).x - map(pos-eps.xyy,c).x,
           map(pos+eps.yxy,c).x - map(pos-eps.yxy,c).x,
           map(pos+eps.yyx,c).x - map(pos-eps.yyx,c).x ) );
}

// Function 791
Ray Camera_GetRay(in Camera camera, vec2 uv) 
{ 
    uv    = (uv * 2.0) - 1.0; 
    uv.x *= (iResolution.x / iResolution.y); 
    
    Ray ray; 
    ray.o = camera.origin; 
    ray.d = normalize((uv.x * camera.right) + (uv.y * camera.up) + (camera.forward * 2.5)); 
    
    return ray; 
}

// Function 792
vec3 normal(vec3 x) {
	const vec2 eps = vec2(0.1, 0.0);
	float h = scene(x);
	return normalize(vec3(
		(scene(x+eps.xyy)-h),
		(scene(x+eps.yxy)-h),
		(scene(x+eps.yyx)-h)
	));
}

// Function 793
vec4 estimateNormal (vec4 p) {
    return normalize(
        vec4(
            sdf(vec4(p.x+E, p.yzw))    .sdf - sdf(vec4(p.x-E, p.yzw)).sdf,
            sdf(vec4(p.x, p.y+E, p.zw)).sdf - sdf(vec4(p.x, p.y-E, p.zw)).sdf,
            sdf(vec4(p.xy, p.z+E, p.w)).sdf - sdf(vec4(p.xy, p.z-E, p.w)).sdf,
            sdf(vec4(p.xyz, p.w+E))    .sdf - sdf(vec4(p.xyz, p.w-E)).sdf
        )
    );
}

// Function 794
vec3 FastNormalFilter(sampler2D _tex,vec2 uv,float strength,vec2 offset){
	vec3 e = vec3(offset,0.);
    float p00 = GetTextureLuminance(_tex,uv);
    float p10 = GetTextureLuminance(_tex,uv + e.xz);
    float p01 = GetTextureLuminance(_tex,uv + e.zy);
    /* Orgin calculate 
    vec3 ab = vec3(1.,0.,p10-p00);
    vec3 ac = vec3(0.,1.,p01-p00);
    vec3 n = cross(ab,ac);
    n.z *= (1.-strength);
    return normalize(n);
	*/
	vec2 dir = p00-vec2(p10,p01);
    return normalize(vec3(dir,1.-strength));
}

// Function 795
ray get_ray(in camera c, in vec2 uv, in float wavelength) {
	float theta = c.fov * 3.14/180.0;
    float h_height = tan(theta/2.0);
    float h_width = c.aspect * h_height;
    
    vec3 w = normalize(c.look_from - c.look_at);
    vec3 u = normalize(cross(c.up, w));
    vec3 v = cross(w, u);
    
    // Rotate
    float phi = PRISM_ROT - 3.14/6.0;
    mat3 r = mat3(
        vec3(cos(phi), 0., -sin(phi)),
        vec3(0., 1., 0.),
        vec3(sin(phi), 0., cos(phi)));

    w = r*w;
    u = r*u;
    v = r*v;
    
    vec3 ll = c.look_from - h_width*u - h_height*v - w;
    vec3 horizontal = 2.0 * h_width*u;
    vec3 vertical = 2.0 * h_height*v;
    
    return ray(
        c.look_from, 
        normalize(ll + uv.x*horizontal + uv.y*vertical - c.look_from),
        wavelength,
        ENV_IOR
    );
}

// Function 796
float castRay( in vec3 ro, in vec3 rd )
{
    float t = 0.;
    
    for( int i=0; i<50; i++ )
    {
   		float res = map( ro+rd*t );
   		if (res < 0.001)
            break;
    	t += res;
        if (t > 5.)
            break;
    }

    return t;
}

// Function 797
vec3 mapNormal(vec3 pt, float e)
{
    vec3 normal;
    normal.y = map(pt).x;    
    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 798
void sampleArray( out float[25] refA, out float[25] refB,
                  out float[25] refC, out float[25] refD,
                  out float[25] refE, out float[25] refF,
                  in vec2 uv, in vec2 po )
{
    int s = 0;
    
    for (int y = 0; y < 5; y++) {
        float v = uv.y + po.y * float(y);
        
        for (int x = 0; x < 5; x++, s++) {
            vec4 tmpA = texture(iChannel0, vec2(uv.x + po.x * float(x), v));
            vec4 tmpB = texture(iChannel1, vec2(uv.x + po.x * float(x), v));
            
            refA[s] = tmpA.x;
            refB[s] = tmpA.y;
            refC[s] = tmpA.z;
            refD[s] = tmpA.w;
            refE[s] = tmpB.x;
            refF[s] = tmpB.y;
        }
    }
}

// Function 799
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,
	    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,
	    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 800
bool checkRefract(vec3 v, vec3 n, float niOverNt)
{
    vec3 uv = v;
    float dt = dot(uv, n);
    float discriminant = 1.0 - niOverNt * niOverNt * (1.-dt*dt);
    if (discriminant > 0.)
    {
        return true;
    }
    return false;
}

// Function 801
vec3 calcNormal( in vec3 pos )
{

#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
      //if( n.x+n.y+n.z>100.0 ) break;
    }
    return normalize(n);
#endif    
}

// Function 802
bool rayTriangleIntersection(in Ray ray,  in Triangle tri, inout Intersection currentInter, int tptr)
{
    vec3 v1v0 = tri.v1 - tri.v0;
    vec3 v2v0 = tri.v2 - tri.v0;
    vec3 rov0 = ray.origin - tri.v0;
    vec3  n = cross( v1v0, v2v0 );
    vec3  q = cross( rov0, ray.direction );
    float d = 1.0/dot( ray.direction, n );
    float u = d*dot( -q, v2v0 );
    float v = d*dot(  q, v1v0 );
    float t = d*dot( -n, rov0 );
    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t <= 0.0f) return false;
    if(t > currentInter.t && currentInter.hit) return true;
    vec3 point = ray.origin + ray.direction * t;
    currentInter = yay(point, t, normalize(n), ray, tri.material, tptr, -1);
    return true;
}

// Function 803
vec3 getNormal(vec3 p)
{
  vec2 o = vec2(0.001, 0.);
  return normalize(vec3(  map(p+o.xyy)-map(p-o.xyy),
                          map(p+o.yxy)-map(p-o.yxy),
                          map(p+o.yyx)-map(p-o.yyx)));
}

// Function 804
vec3 Raymarch(Ray r, float startT)
{
    float t = startT;
    float d = 0.0;
    float iterations = 0.0;
    
	for(int j = 0; j < MAX_ITERATIONS; j++)
	{
		d = sdf(r.origin + r.direction * t, false);

		if(d < EPSILON)
            break;
        
		t += d;
        
        if(t > MAX_DISTANCE)
            break;
        
        iterations += 1.0;
	}
    
    t = min(t, MAX_DISTANCE);
    
    return vec3(t, iterations / float(MAX_ITERATIONS), d);
}

// Function 805
vec3 normal(vec3 pos) {
	vec3 eps = vec3(.0001, 0, 0);
	vec3 nor = vec3(0);
	float invert = 1.;
	for (int i = 0; i < NORMAL_STEPS; i++) {
		nor += de(pos + eps * invert) * eps * invert;
		eps = eps.zxy;
		invert *= -1.;
	}
	return normalize(nor);
}

// Function 806
vec3 rayPointAt(Ray ray, float t) {
 	return ray.origin + t * ray.direction;   
}

// Function 807
vec4 BakeNormalWorldSpace(float theta, float phi) 
{   
    vec3 dir = vec3(sin(theta)*sin(phi), cos(phi), -sin(phi)*cos(theta));
    vec3 ro = dir*10.;	// The ray starts outside the models
    Hit hP = RayMarchHighDetailModel(ro, -dir);
    
    return vec4(normalize(hP.normal) * 0.5 + 0.5, .1);
}

// Function 808
bool raytraceScene(in Ray ray, out vec3 position, out vec3 normal, out Material mat)
{
    float t;
    bool intersected = false;
    
    float tmpT; 
    vec3 tmpPos, tmpNorm;
    
    if (intersectsQuad(ray, lightQuad, tmpT, tmpPos, tmpNorm)) {
        t = tmpT;
        position = tmpPos;
        normal = tmpNorm;
        mat = materials[0];
        intersected = true;
    }
    
    for (int i = 0; i < INF_PLANES_NB; i++) {
        if (intersectsInfinitePlane(ray, boxPlanes[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {
        	t = tmpT;
        	position = tmpPos;
        	normal = tmpNorm;
        	mat = materials[i + 1];
        	intersected = true;
    	}
    }
    
    if (max(max(abs(position.x), abs(position.y)), abs(position.z)) > 2.0 + 0.001) 
        return false;
    
    for (int i = 0; i < SPHERES_NB; i++) {
        if (intersectsSphere(ray, spheres[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {
        	t = tmpT;
        	position = tmpPos;
        	normal = tmpNorm;
        	mat = materials[i + INF_PLANES_NB + 1];
        	intersected = true;
    	}
    }
    
    return intersected;
}

// Function 809
Ray getRay(vec3 lookFrom, vec3 targetDir, vec3 upVector, float FOV, float aspect, float aperture, float focusDist, vec2 fragCoord) {
    float halfHeight = tan(radians(FOV*0.5));
    float halfWidth = aspect * halfHeight;
    vec3 origin = lookFrom;
    vec3 w = targetDir;
    vec3 u = normalize(cross(upVector, w));
    vec3 v = cross(w, u);
    vec3 lowerLeftCorner = origin
        - halfWidth * focusDist * u
        - halfHeight * focusDist * v
        - focusDist * w;
    vec3 horizontal = 2.0 * halfWidth * focusDist * u;
    vec3 vertical = 2.0 * halfHeight * focusDist * v;

    vec2 rd = 0.5*aperture * randomInUnitDisk(randomSeed);
    vec3 offset = u * rd.x + v * rd.y;
    return Ray(origin + offset, normalize(lowerLeftCorner 
               + (fragCoord.x/iResolution.x) * horizontal 
               + (fragCoord.y/iResolution.y) * vertical
               - origin - offset));
}

// Function 810
float castRay(out vec3 n, out int id, in Ray r)
{
    id = 0;
    float t = 1e37;
    for(int k=0; k<3; k++) {
        for(int j=0; j<3; j++) {
            for(int i=0; i<3; i++) {
                vec3 nn;
                float tt;

                int kk = i+j+k;
                
                vec3 o = vec3(i-1, j-1, k-1);
                
                if((kk % 3)==0) {
	                tt = intersectSphere(nn, r, o, 0.45*0.45);
                }
                else if((kk %3)==1) {
                    tt = intersectCylinder(nn, r, o, 0.45, 0.45*0.45);
                }
                else {
	                tt = intersectCube(nn, r, o, vec3(0.45));
                }
                 if(0.0 < tt && tt < t) {
                    t = tt;
                    n = nn;
                    id = 3*(3*k+j) + i + 2; 
                }
            }
        }
    }
 
    {
        vec3 nn;
        float tt = intersectPlane(nn, r, vec3(0,1,0), 2.0);
        if(0.0 < tt && tt < t) {
            t = tt;
            n = nn;
            id = 1;
        }
    }
    
    return t < 1e37 ? t : -1.0;
}

// Function 811
float castRayToSphere(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center;
    float qb = dot(ray.direction, oc);
    
    float det = qb * qb - dot(oc, oc) + sphere.radius * sphere.radius;
    if (det < 0.)
        return FAR_PLANE;
    
    float sqrt_det = sqrt(det);
    
    float t1 = -qb - sqrt_det;
    float t2 = -qb + sqrt_det;
    
    if (t1 < SHADOW_EPSILON)
        t1 = FAR_PLANE;
    if (t2 < SHADOW_EPSILON)
        t2 = FAR_PLANE;
    
    return min(t1, t2);
}

// Function 812
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = .5;
    float tmax = 20.0;
       
    float t = tmin;
    float m = -1.0;

    if( SCENE_MODE == 0 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_0( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } else if( SCENE_MODE == 1 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_1( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } else if( SCENE_MODE == 2 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_2( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } else if( SCENE_MODE == 3 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_3( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } else if( SCENE_MODE == 4 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_4( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } else if( SCENE_MODE == 5 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_5( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    }  else if( SCENE_MODE == 6 ) {
        for( int i=0; i<64; i++ )
        {
            float precis = 0.00005*t;
            vec2 res = map_6( ro+rd*t );
            if( res.x<precis || t>tmax ) break;
            t += res.x;
            m = res.y;
        }
    } 

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 813
vec2 cameraRayToUv(ray cameraRay, float projectionDist)
{
    vec2 uv = vec2(normalize(cameraRay.direction).x, normalize(cameraRay.direction).y);
    uv *= projectionDist/dot(normalize(cameraRay.direction), vec3(0, 0, projectionDist));
    return uv;
}

// Function 814
vec3 castray2(vec3 pos, vec3 dir) {
    if (!RENDER_REFLECTIONS)
        return SKY;
    float tmax = (7.0 - pos.y) / dir.y;
    int i = 0;
	for (float t = 0.1; t < tmax && i < 50; ++i) {
        vec3 p = pos + t * dir;
		vec2 res = sdf(pos + t * dir);
        float d = res.x;
        float mat = res.y;
		if (d < 0.001) {
            vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);
            return shade(albedo, norm(p), p, dir, 1.0, false);
		}
		t += d;
	}
    return SKY;
}

// Function 815
vec3 normal(vec3 pos){
    const vec2 diff = vec2(collisiondist*0.1, 0.0);
    return normalize(vec3(DE(pos+diff.xyy)-DE(pos-diff.xyy),
                          DE(pos+diff.yxy)-DE(pos-diff.yxy),
                          DE(pos+diff.yyx)-DE(pos-diff.yyx)));
}

// Function 816
vec4 rayTracer(Ray ray)
{
    vec4 accumulatedColor = vec4(0,0,0,1); // accumulated light over all raymarch
    vec4 localColor = vec4(0); // local light contribution of each intersected object
    float frac = 1.0; // lost of light at each reflexion
    float dist = MAX_DIST; // distance of scene object
    float depth = MIN_DIST; // distance marched since last intersection
    float depthAccumulator = MIN_DIST; // total distance marched
    vec3 p; //position in space

    Ray reflectRay = Ray(ray.origin,  ray.direction);
    Intersect intersection = Intersect(0.0, vec3(0), vec3(0), 
                                       Material(vec3(0), 
                                                vec3(0), 
                                                vec3(0),
                                                0.0,0.0));

    int reflectionCounter = 0; //number of reflexive object encountered
    //start raymarching loop
    for(int i=0; i<MAX_MARCHING_STEPS; i++)
    {
        //compute distance from position to scene 
        p = reflectRay.origin + depth * reflectRay.direction;
        dist = sceneSDF(p);

        //if hit something
        if (dist < EPSILON) {
            intersection = Intersect(dist, p, calcNormal(p), 
                                     Material(vec3(0), 
                                              vec3(0), 
                                              vec3(0),
                                              0.0,0.0));
            //retrieve material of object. not optimal I know
            for(int j=0; j<numberOfSpheres-1; j++)
            {
                if (sphereSDF(p, spheres[j]) <= EPSILON) intersection.material = spheres[j].material;
            }

            if (oceanSDF(p, spheres[numberOfSpheres-1]) <= EPSILON) intersection.material = spheres[numberOfSpheres-1].material;

            for(int j=0; j<numberOfPlanes; j++)
            {
                if (planeSDF(p, box[j]) <= EPSILON) intersection.material = box[j].material;
            }

            //compute lighting contribution of object with phong model
            localColor = phongIllumination(reflectRay, intersection);
            //compute accumulated lighting
            accumulatedColor += localColor * frac;

            depthAccumulator += depth;
            //if object we hit is reflexive continue
            if( (intersection.material.reflectivity > 0.0)&&(reflectionCounter < MAX_REFLECT_STEPS))
            {
                reflectionCounter += 1;
                depth = MIN_DIST;
                reflectRay = Ray(p + 5.0*EPSILON*intersection.normal,  normalize(reflect(reflectRay.direction, intersection.normal)));
                frac *= intersection.material.reflectivity;
            }
            //if object we hit is not reflexive stop
            else
            {
                break;
            }

        }
        //if traveled maximum distance
        if (depthAccumulator >= MAX_DIST) {
            break;
        }
        //advance of distance to scene over the ray
        depth += dist;

    }
    return accumulatedColor;
}

// Function 817
bool shadowRayCast(vec3 r, vec3 light_pos)
{
    vec3 d = light_pos - r;
    
    float lowest_t = length( d );

    d = normalize(d);
    
    bool hit = false;
    
    for( int j = 0; j < NUM_SPHERES - 1; ++j )
    {
		float t;
        if( isect_sphere( r, d, g_spheres[j].xyz, g_spheres[j].w, t ) )
        {
			if( t < lowest_t )
            {
                lowest_t = t; hit = true;
            }
        }
    }
    
    for( int j = 0; j < NUM_PLANES; ++j )
    {
		vec3 np = g_planes[j].xyz;
        float np_dot_d = dot(np, d);
        if( abs(np_dot_d) > 0.001 )
        {
            float t = (g_planes[j].w - dot(np, r)) / np_dot_d;
            if( t > 0.0 && t < lowest_t )
            {
				lowest_t = t; hit = true;
            }
        }
    }
    
    return hit;
}

// Function 818
float marchGodRay(vec3 ro, vec3 rd, vec3 light, float hitDist) {
    // March through the scene, accumulating god rays.
    vec3 p = ro;
    vec3 st = rd * hitDist / 96.0;
    float god = 0.0;
    for (int i = 0; i < 96; i++) {
        float distFromGodLight = 1.0 - godLight(p, light);
        god += godLight(p, light);
        p += st;
    }
    
    god /= 96.0;

    return smoothstep(0.0, 1.0, min(god, 1.0));
}

// Function 819
vec3 CalculateNormalMapNormal(in vec2 uv, in float height, in vec3 normal, in vec3 tangent, in vec3 binormal)
{   
    vec3 normalMap = SampleNormalMap(uv, height).rgb;
	return normalize((normal * normalMap.b) + (binormal * normalMap.g) + (tangent * normalMap.r));
}

// Function 820
vec3 heightmapNormal(vec2 uv) {
	float xdiff = heightmap(uv) - heightmap(uv+epsi.xy);
	float ydiff = heightmap(uv) - heightmap(uv+epsi.yx);
	return normalize(cross(vec3(epsi.yx, -xdiff), vec3(epsi.xy, -ydiff)));
}

// Function 821
float rayPlaneIntersect( Ray ray, vec4 plane )
{
	float f = dot( ray.dir, plane.xyz );
	
	float t = -( dot( ray.org, plane.xyz ) + plane.w );
	t /= f;
	
	return t;
}

// Function 822
vec3 calcNormal( in vec3 pos) {
	vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;
	return normalize(e.xyy * map(pos + e.xyy).x +
		e.yyx * map(pos + e.yyx).x +
		e.yxy * map(pos + e.yxy).x +
		e.xxx * map(pos + e.xxx).x);
}

// Function 823
vec3 scene_normal(vec3 pos, float d)
{
    return normalize(
		vec3(dst(vec3(pos.x + EPS, pos.y, pos.z)),
			 dst(vec3(pos.x, pos.y + EPS, pos.z)),
		 	 dst(vec3(pos.x, pos.y, pos.z + EPS))) - d);
}

// Function 824
vec3 Raymarch(Ray r, float startT)
{
    float t = startT;
    float d = 0.0;
    float iterations = 0.0;
    
	for(int j = 0; j < MAX_ITERATIONS; j++)
	{
		d = sdf(r.origin + r.direction * t, false);

		if(d < EPSILON)
            break;
        
		t += d * .4;
        
        if(t > MAX_DISTANCE)
            break;
        
        iterations += 1.0;
	}
    
    t = min(t, MAX_DISTANCE);
    
    return vec3(t, iterations / float(MAX_ITERATIONS), d);
}

// Function 825
vec3 calcNormal( in vec3 p, in vec4 c )
{
    const vec2 e = vec2(0.001,0.0);
    vec4 za = vec4(p+e.xyy,0.0);
    vec4 zb = vec4(p-e.xyy,0.0);
    vec4 zc = vec4(p+e.yxy,0.0);
    vec4 zd = vec4(p-e.yxy,0.0);
    vec4 ze = vec4(p+e.yyx,0.0);
    vec4 zf = vec4(p-e.yyx,0.0);

  	for(int i=0; i<numIterations; i++)
    {
        za = qsqr(za) + c; 
        zb = qsqr(zb) + c; 
        zc = qsqr(zc) + c; 
        zd = qsqr(zd) + c; 
        ze = qsqr(ze) + c; 
        zf = qsqr(zf) + c; 
    }
    return normalize( vec3(log2(qlength2(za))-log2(qlength2(zb)),
                           log2(qlength2(zc))-log2(qlength2(zd)),
                           log2(qlength2(ze))-log2(qlength2(zf))) );

}

// Function 826
vec3 calcNormal( in vec3 pos )
{
    vec2 eps = vec2(0.001,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 827
vec3 normal(vec3 p) {
	vec2 h = vec2(0.001, 0.0);
	vec3 n = vec3(
		map(p + h.xyy) - map(p - h.xyy),
		map(p + h.yxy) - map(p - h.yxy),
		map(p + h.yyx) - map(p - h.yyx)
	);
	return normalize(n);
}

// Function 828
vec3 getNormal(vec3 p) {
    vec2 e = vec2(NORMAL_EPS, 0);
    return normalize(
    	vec3(
            scene(p + e.xyy).x - scene(p - e.xyy).x,
            scene(p + e.yxy).x - scene(p - e.yxy).x,
            scene(p + e.yyx).x - scene(p - e.yyx).x
        )
    );
}

// Function 829
float castRay(in vec3 ro, in vec3 rd, in float maxt) 
{
    float precis = prec;
    float h = precis * 2.0;
    float t = depth;

    for(int i = 0; i < 122; i++) 
	{
        if(abs(h) < precis || t > maxt) break;
        orbitTrap = vec4(10.0);
		h = map(ro + rd * t);
        t += h;
	}
    return t;
}

// Function 830
vec3 estimateNormal(vec3 p) {
    // assuming we are on the surface where sceneSDF ~ 0
    return normalize(vec3(
        sceneSDF(vec3(p.x + NORMAL_DELTA, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + NORMAL_DELTA, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z + NORMAL_DELTA))
    ));
}

// Function 831
vec3 normal_clouds(vec3 p, vec3 dir) {
    vec3 eps = vec3(0., .05, 0.);
	vec3 n = normalize(vec3(de_clouds(p + eps.yxx, dir), de_clouds(p + eps.xyx, dir), de_clouds(p + eps.xxy, dir)) - de_clouds(p, dir));
	return n;
}

// Function 832
vec3 normal(vec3 p) {
   vec3 normal = vec3(sdf(p + vec3(EPSILON,0.0,0.0)) - sdf(p - vec3(EPSILON,0.0,0.0)),
                      sdf(p + vec3(0.0,EPSILON,0.0)) - sdf(p - vec3(0.0,EPSILON,0.0)),
                      sdf(p + vec3(0.0,0.0,EPSILON)) - sdf(p - vec3(0.0,0.0,EPSILON)));
   return normalize(normal);
}

// Function 833
vec3 calcNormal(in vec3 p) {
	const vec2 e = vec2(.002, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 834
vec3 length_normalize( vec2 x ) { float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec3( x, p ) * q; }

// Function 835
vec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane )
{
	vec3 p = ro+rd*nfplane.x;
	float t = 0.;
	for(int i=0; i<64; i++)
	{
        float d = map(p);
        t += d;
        p += rd*d;
		if( d < 0.001 || t > nfplane.y )
            break;
            
	}
	
	return p;
}

// Function 836
vec3 raycast(vec3 ro, vec3 rd)
{
    vec3 normal, normal2;
    float t = sceneIntersect(ro, rd, normal);
    vec3 p = ro+t*rd;
    // And after one bounce
    vec3 ro2 = p + 0.01*normal, rd2 = reflect(rd, normal);
    float t2 = sceneIntersect(ro2, rd2, normal2);
    
    //return (t < T_MAX) ? 0.5+0.5*normal : vec3(0);
    
    vec3 _; // Dummy variable
    if(t < T_MAX)
    {
        // Let's do some shading!
        float ao = 0.5+0.5*normal.z;
        float darkVoid = smoothstep(FLOOR,0.,p.z);
        ao *= darkVoid;
        
        float isInWindow, _;
        vec3 emission = computeEmission(p, rd, t, normal, isInWindow);
        vec3 emission2 = computeEmission(ro2+t2*rd2, rd2, t+t2, normal2, _);
        emission2 = t2 < T_MAX ? emission2 : skyColor(rd2);
        
        vec3 roomSize, roomCenter, roomHash;
        getRoom(p, rd, roomSize, roomCenter, roomHash);
    	vec3 surfCol = 0.4+0.5*smoothstep(0.5,0.9,roomHash.rrr)-0.2*isInWindow;
        vec3 F0 = 0.04+vec3(0.04,0.1,0.2)*surfCol;
        
    	vec3 fre = F0 + (1.-F0) * pow(clamp(1.-dot(-rd,normal),0.,1.),5.);
        vec3 col = mix(emission, emission2, fre);
        col = mix(vec3(0.), col, isInWindow);
        //vec3 col = emission;
        //col += surfCol* clamp(dot(normal, sun), 0., 1.) * sunCol  * darkVoid;
        //col += surfCol* clamp(dot(normal, -rd), 0., 1.)  * darkVoid * 2./ t;
        //col += surfCol*vec3(0.5,0.7,0.9) * 0.1 * (0.5+0.5*normal.z) * ao;
        //col += surfCol* sunCol*sunCol * 0.1 * clamp(dot(normal.xy, -sun.xy), 0., 1.) * ao;
        
        col += surfCol * ao * 0.2 * (0.5-0.2*normal.z) 
            * smoothstep(10.0,-30.0,p.z) * vec3(1.,0.8,0.6);
		
        col = mix(col, vec3(0.), 1.-exp(-t*0.003));
        col = mix(col, skyColor(rd), 1.-exp(-t*0.01));
        col *= exp(0.02*min(p.z,0.));
        //col +=;
        return col;
    }
    else
    {
        vec3 col = skyColor(rd);
        // Stars
        float stars = smoothstep(0.96,1.01,textureLod(iChannel1,(round(1.5*rd.yz/(rd.x+1.)*iResolution.y)+0.5)/256., 0.).r)
            * smoothstep(0.0,1.0,textureLod(iChannel1,(rd.yz/(rd.x+1.)*450.)/256., 0.).r);
        col += stars*stars*smoothstep(0.0,0.2,rd.z);
        return col;
    }
}

// Function 837
vec3 drawRay(vec3 origin, vec3 dir) {
    vec3 color = vec3(0.0);
    
    // First test ray intersection with the outer shell
    TriangleHit hit = rayIcoOuterHit(origin, dir);
    if (hit.t > 10.0) {
    	return background(dir);
    }
    
    // Render reflections
    vec3 reflDir = reflect(dir, hit.normal);
    vec3 bgColor = pow(background(reflDir), vec3(1.0));
    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(dir, -hit.normal), 0.0), 5.0);
    color += bgColor * fresnel;
    
    // Check if we're close enough to the edge of the triangle to render a wall
    float d = min(min(hit.bary.x, hit.bary.y), hit.bary.z);
    if (d < WALL_THICKNESS) {
        vec4 wc = wallColor(dir, hit);
    	return color * wc.a + wc.rgb;
    }
    
    // Move origin inside the icosahedron and check inner intersections
    origin = origin + hit.t * dir;
    hit = rayIcoInnerHit(origin, dir);
    vec3 transmittance = vec3(1.0);
    
    // Bounce rays inside the icosahedron until a wall is hit or we run out of iterations
    for (int i = 0; i < REFL_COUNT; i++) {
    	float d = min(min(hit.bary.x, hit.bary.y), hit.bary.z);
        if (d < WALL_THICKNESS) {
        	return color + transmittance * wallColor(dir, hit).rgb;
        }
        
        origin = origin + hit.t * dir;
        dir = reflect(dir, hit.normal);
        origin += dir * 0.001;
        transmittance *= vec3(0.50, 0.47, 0.38); // Every reflection loses some light
        
        hit = rayIcoInnerHit(origin, dir);
    }
    
    return color;
}

// Function 838
vec3 calcNormal(in vec3 pos) {
    const float eps = 0.002; // precision of the normal computation

    const vec3 v1 = vec3(1.0, -1.0, -1.0);
    const vec3 v2 = vec3(-1.0, -1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0, -1.0);
    const vec3 v4 = vec3(1.0, 1.0, 1.0);

    return normalize(v1 * doCombinedModels(pos + v1 * eps) + 
                     v2 * doCombinedModels(pos + v2 * eps) +
                     v3 * doCombinedModels(pos + v3 * eps) + 
                     v4 * doCombinedModels(pos + v4 * eps));
}

// Function 839
vec3 get_normal(vec3 point) {
  float d0 = get_distance(point);
  float dX = get_distance(point - vec3(0.001, 0.0, 0.0));
  float dY = get_distance(point - vec3(0.0, 0.001, 0.0));
  float dZ = get_distance(point - vec3(0.0, 0.0, 0.001));
    
  	return normalize(vec3(dX-d0, dY-d0, dZ-d0));
    
}

// Function 840
vec3 normalize(vec3 u)     { return (1.0 / length(u)) * u; }

// Function 841
vec3 ray(vec3 z, vec3 d) {
    float r = 1.3333;
    meet a = test_in(z, d);
    if (a.N < 0) {
        // Complete miss
        // printf("Miss\n");
        return d;
    }
    // First refraction
    z = a.z;
    
    if (unifrm(-1.23, z.xy, 0.0, 1.0) < 0.0) {
        return reflect(d, normalize(norms[a.N]));
    }
    
    d = refrct(normalize(d), normalize(norms[a.N]), r);
    z = a.z+bias*d;
    int count = 0;
    // We're now inside
    while (true) {
        if (count > 2) {
            return vec3(0.0, 0.0, 0.0);
        }
        ++count;
        meet a = test_out(z, d);
        if (a.N < 0) {
            // Complete miss
            // printf("Error - no way out!\n");
            return vec3(0.0, 0.0, 0.0);
        }
        z = a.z;
        // printf("newz = %f %f %f\n", z.x, z.y, z.z);
        vec3 td = refrct(normalize(d), normalize(norms[a.N]), r);
        if (td != vec3(0.0, 0.0, 0.0)) {
            return td;
        }
        // TIR
        d = reflect(d, normalize(norms[a.N]));
        z = a.z+bias*d;
    }
}

// Function 842
void computeReflectivities(Material material, out Color3 p_L, out Color3 p_G, out float glossyExponent) {
	p_L = mix(material.color, Color3(0.0), material.metal);
	p_G = mix(Color3(0.04), material.color, material.metal);
	glossyExponent = exp2(material.smoothness * 15.0);
}

// Function 843
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        world(vec3(p.x + EPSILON, p.y, p.z)).dist - world(vec3(p.x - EPSILON, p.y, p.z)).dist,
        world(vec3(p.x, p.y + EPSILON, p.z)).dist - world(vec3(p.x, p.y - EPSILON, p.z)).dist,
        world(vec3(p.x, p.y, p.z  + EPSILON)).dist - world(vec3(p.x, p.y, p.z - EPSILON)).dist
    ));
}

// Function 844
float rayLine( vec2 p, vec2 d, vec2 start, vec2 end, float I )
{
    // do ray-line segment intersection by computing angle to line
    // segment start and end points and detecting if ray direction
    // is in the angle range. really ugly, should have just looked
    // up the geometric line-line intersection!
    
    vec2 off1 = start - p;
    float theta1 = atan( off1.y, off1.x );
    if( theta1 < 0. ) theta1 += TWOPI;
    
    vec2 off2 = end - p;
    float theta2 = atan( off2.y, off2.x );
    if( theta2 < 0. ) theta2 += TWOPI;
    
    float thetaAvg = (theta1+theta2)/2.;
    float thetaDif = abs(theta1-theta2);
    if( thetaDif > PI )
    {
        // wrong way around, flip
        thetaDif = TWOPI - thetaDif;
    	d = -d;
    }
    
    float theta = atan( d.y, d.x );
    if( theta < 0. ) theta += TWOPI;
    
    if( abs(theta-thetaAvg) > thetaDif/2. )
        return 0.;
    
    return line(p,start,end,I);
}

// Function 845
vec3 getNormal(vec3 pos)
{
	float d=getDist(pos);
	// Create the normal vector by comparing the distance near our point.
	return normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));
}

// Function 846
vec3 hnormalize(vec3 p) {
  if (p.z < 0.0) p = -p;
  return p/sqrt(-rdot(p,p));
}

// Function 847
vec3 cloudNormal(vec3 p) {
	const vec2 e = vec2(.5773, -.5773);
	return normalize(e.xyy * sdCloud(p + e.xyy) + e.yyx * sdCloud(p + e.yyx) + e.yxy * sdCloud(p + e.yxy) + e.xxx * sdCloud(p + e.xxx));
}

// Function 848
RayHit RaymarchScene(in Ray ray)
{
    RayHit hit;
    
    hit.hit      = false;
    hit.material = 0.0;
    
    float sdf = FarClip;
    
    for(float depth = NearClip; depth < FarClip; )
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf < Epsilon)
        {
            hit.hit      = true;
            hit.surfPos  = pos;
            hit.surfNorm = Scene_Normal(pos);
            
            return hit;
        }
        
        depth += sdf;
    }
    
    return hit;
}

// Function 849
bool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
	float phi;
	vec3 phit;
    
	// Compute quadratic cylinder coefficients
	float a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;
	float b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);
	float c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;
 
	// Solve quadratic equation for _t_ values
	float t0, t1;
	if (!solveQuadratic( a, b, c, t0, t1))
		return false;

    if ( t1 < 0.0 )
        return false;
    
	t = t0;
    
	if (t0 < 0.0)
		t = t1;

	// Compute cylinder hit point and $\phi$
	phit = r.origin + r.dir*t;
	phi = atan(phit.y,phit.x);
    phi += PI;
    
	if (phi < 0.0)
        phi += TWO_PI;
 
	// Test cylinder intersection against clipping parameters
	if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {
		if (t == t1)
            return false;
		t = t1;
		// Compute cylinder hit point and $\phi$
		phit = r.origin + r.dir*t;
		phi = atan(phit.y,phit.x);
        phi += PI;

		if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )
			return false;
	}
    
    if( !forShadowTest ) {
        isect.position_ = phit;
        isect.uv_.x = (phit.z - minZ)/(maxZ - minZ);
        isect.uv_.y = phi/maxPhi;
        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );
        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );
    }
    
	return true;
}

// Function 850
float castRay(vec3 pos, vec3 dir, float time, float maxDist)
{
    float totalDist = 0.0;
    float distToSurface = distModel(pos + dir * 0.1, time);
    
    while(totalDist < maxDist)
    {
        totalDist += distToSurface + 0.01;
        vec3 currentPos = pos + dir * totalDist;
        distToSurface = distModel(currentPos, time);
        
        if(distToSurface < 0.00)
        {
            //Return a little bit to better hit the surface pos
        	totalDist += distToSurface;
            return totalDist;
        }
    }
    
    return maxDist;
}

// Function 851
vec3 computePixelRay( in vec2 p, out vec3 cameraPos )
{
    // camera orbits around origin
	
    float camRadius = 2.8 + 100.*iMouse.x/iResolution.x;
	// use mouse x coord
	float a = iTime*10.;
	//if( iMouse.z > 0. )
	//	a = iMouse.x;
	float theta = -(a-iResolution.x)/80.;
    float xoff = camRadius * cos(theta);
    float zoff = camRadius * sin(theta);
    cameraPos = vec3(xoff,1.,zoff);
     
    // camera target
    vec3 target = vec3(0.,.4,0.);
     
    // camera frame
    vec3 fo = normalize(target-cameraPos);
    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));
    vec3 up = normalize(cross(fo,ri));
     
    // multiplier to emulate a fov control
    float fov = .5;
	
    // ray direction
    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);
	
	return rayDir;
}

// Function 852
float rayBox(in Ray r, in Shape s, out vec3 p, out vec3 n)
{
    float resultMin = -huge;
    float resultMax = +huge;

    float txmin, txmax, tymin, tymax, tzmin, tzmax;
    
    vec3 boxmin = s.c - 0.5 * s.dim;
    vec3 boxmax = s.c + 0.5 * s.dim;

    float divx = 1.0 / r.d.x;
    if (divx >= 0.0)
    {
        txmin = (boxmin.x - r.o.x) * divx;
        txmax = (boxmax.x - r.o.x) * divx;
    }
    else
    {
        txmin = (boxmax.x - r.o.x) * divx;
        txmax = (boxmin.x - r.o.x) * divx;
    }

    if (txmin > resultMin)
        resultMin = txmin;
    
    if (txmax < resultMax)
        resultMax = txmax;

    float divy = 1.0 / r.d.y;
    if (divy >= 0.0)
    {
        tymin = (boxmin.y - r.o.y) * divy;
        tymax = (boxmax.y - r.o.y) * divy;
    }
    else
    {
        tymin = (boxmax.y - r.o.y) * divy;
        tymax = (boxmin.y - r.o.y) * divy;
    }
    
    if ((resultMin > tymax) || (tymin > resultMax))
        return -1.0;

    if (tymin > resultMin)
        resultMin = tymin;
    
    if (tymax < resultMax)
        resultMax = tymax;

    float divz = 1.0 / r.d.z;
    if (divz >= 0.0)
    {
        tzmin = (boxmin.z - r.o.z) * divz;
        tzmax = (boxmax.z - r.o.z) * divz;
    }
    else
    {
        tzmin = (boxmax.z - r.o.z) * divz;
        tzmax = (boxmin.z - r.o.z) * divz;
    }

    if ((resultMin > tzmax) || (tzmin > resultMax))
        return -1.0;
    
    if (tzmin > resultMin)
        resultMin = tzmin;
    
    if (tzmax < resultMax)
        resultMax = tzmax;
    
    float t = min(resultMin, resultMax);
    p = r.o + r.d * t;
	
    n = vec3(0.0);
    if (abs(p.x - boxmin.x) < epsilon) n = vec3(-1.0, 0.0, 0.0);
    if (abs(p.y - boxmin.y) < epsilon) n = vec3(0.0, -1.0, 0.0);
    if (abs(p.z - boxmin.z) < epsilon) n = vec3(0.0, 0.0, -1.0);
    if (abs(p.x - boxmax.x) < epsilon) n = vec3(+1.0, 0.0, 0.0);
    if (abs(p.y - boxmax.y) < epsilon) n = vec3(0.0, +1.0, 0.0);
    if (abs(p.z - boxmax.z) < epsilon) n = vec3(0.0, 0.0, +1.0);
    return t;
}

// Function 853
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    for(int i=0; i<8; i++ ) {
        CHECK_OBJ( objects[i] );
    }
    return ( nearestDist < 1000.0 );
}

// Function 854
vec3 calcNormal( in vec3 pos )
{
    const float ep = 0.0001;
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*ep ) + 
					  e.yyx*map( pos + e.yyx*ep ) + 
					  e.yxy*map( pos + e.yxy*ep ) + 
					  e.xxx*map( pos + e.xxx*ep ) );
}

// Function 855
vec3 SpecularReflection(PBRInfo pbrInputs) {
    return pbrInputs.Reflectance0 + (pbrInputs.Reflectance90 - pbrInputs.Reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}

// Function 856
vec3 calcNormalFish( in vec3 pos )
{
#if 0    
    const vec3 eps = vec3(0.08,0.0,0.0);
	float v = sdDolphin(pos).x;
	return normalize( vec3(
           sdDolphin(pos+eps.xyy).x - v,
           sdDolphin(pos+eps.yxy).x - v,
           sdDolphin(pos+eps.yyx).x - v ) );
#else
    #define ZERO (min(iFrame,0))

    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*sdDolphin(pos+0.08*e).x;
    }
    return normalize(n);
#endif    
}

// Function 857
vec3 getNormal(vec3 p){
    const float d = eps;
    return normalize(vec3(distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),
                          distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),
                          distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))));
}

// Function 858
float marchRay(vec3 ro, vec3 rd) {
  float t = 0.0;
  for(int i = 0; i < 300; i++) {
    vec3 p = ro + t * rd;
    float h = map(p);
    if (h < 0.0001) return t;
    t += h;
    if (t > farClip) return 0.0;
  }
  return t;
}

// Function 859
void castRay(inout Ray ray) {
	// Cast ray from origin into scene
	float dt = 0.008;
	float lastdiff = 0.0;
	for (int i = 0; i < 200; i++) {
		if (length(ray.m_origin - ray.m_point) > maxdist) return;
		if (ray.m_point.z > 0.1 && ray.m_point.y + ray.m_point.x < -0.5 && ray.m_direction.z > 0.0) return;
		float dist2scene = scene(ray.m_point);
		float diff = ray.m_point.z - heightmap(ray.m_point.xy);

		if (abs(dist2scene) < epsi.x) {
			ray.m_intersected = 2;
			return;
		}

		if (diff < 0.0) {
			ray.m_point -= dt * diff / (diff - lastdiff) * ray.m_direction;
			ray.m_intersected = 1;
			return;
		}

		dt = dt*1.02;
		ray.m_point += min(dt*max(diff*(1.0-abs(ray.m_direction.z)+max(ray.m_direction.z,0.0)*30.0)*80.0,1.0),dist2scene) * ray.m_direction;
		lastdiff = diff;
	}
}

// Function 860
bool cast_ray (vec3 p, vec3 d, out int id, out float dist, out vec3 n) {
    
    vec3 camp = p;
    
    id = 0;
    dist = 1e9;
    n = vec3(0.);
    
    if (p.y > 1.) {
        // trace down onto plane where all the grounds below
        float a = p.y-1.;
        float h = a/dot(d, vec3(0., -1., 0.));
        if (dot(d, vec3(0., -1., 0.)) > 0.) {
            p += d*h;
        }
        else {
            return false;
        }
	}
    
    // help with whole number glitches
    if (p.x == floor(p.x)) {
        p.x += 1e-5;
    }
    if (p.y == floor(p.y)) {
        p.y += 1e-5;
    }
    if (p.z == floor(p.z)) {
        p.z += 1e-5;
    }

    float dist_d;
    float dist_l;
    float dist_b;
    float dist_u;
    float dist_r;
    float dist_f;
    vec3 lp;
    float closest_dist;
    vec3 closest_n;

    if (bloctyp(p) != 0) {
        // u need to be in a transparent block
        // to see anything
        id = 0;
        dist = 0.;
        n = vec3(0., 0., -1.);
        return true;
    }

    for (int i=0; i<100; ++i) {

        closest_dist = 1e9;
        closest_n = vec3(0.);

        lp = fract(p);
        //float dist_d = inter_ray_plane(p, d, vec3(0., floor(p.y), 0.), vec3(0., 1., 0.)).dist;
        //float dist_d = lp.y/dot(d, vec3(0., -1., 0.));
        // d l f b r u
        dist_d = lp.y/-d.y;
        if (dist_d < closest_dist && -d.y > 0.) {
            closest_dist = dist_d;
            closest_n = vec3(0., 1., 0.);
        }
        dist_l = lp.x/-d.x;
        if (dist_l < closest_dist && -d.x > 0.) {
            closest_dist = dist_l;
            closest_n = vec3(1., 0., 0.);
        }
        dist_b = lp.z/-d.z;
        if (dist_b < closest_dist && -d.z > 0.) {
            closest_dist = dist_b;
            closest_n = vec3(0., 0., 1.);
        }

        dist_u = (1.-lp.y)/d.y;
        if (dist_u < closest_dist && d.y > 0.) {
            closest_dist = dist_u;
            closest_n = vec3(0., -1., 0.);
        }
        dist_r = (1.-lp.x)/d.x;
        if (dist_r < closest_dist && d.x > 0.) {
            closest_dist = dist_r;
            closest_n = vec3(-1., 0., 0.);
        }
        dist_f = (1.-lp.z)/d.z;
        if (dist_f < closest_dist && d.z > 0.) {
            closest_dist = dist_f;
            closest_n = vec3(0., 0., -1.);
        }
        
        if (closest_dist < 1e9) {
            // jots [prta;
            // -hits portal
            vec3 p2 = p+d*(closest_dist+1e-5);
            int current_bloctyp = bloctyp(p2);
            // int current_bloctyp = p2.y < -10. ? 1 : 0;
            if (current_bloctyp != 0) {
                id = current_bloctyp;
                dist = length(p2-camp);
                n = closest_n;
                return true;
            }
            else {
                p = p2;
            }
        }
        if (p.y > 2. || length(p-camp) > fog_start+fog_dist) {
            return false;
        }
        
    }
    
    return false;
    
}

// Function 861
bool raySphereIntersection( Ray ray, in Sphere sph, out float dist ) {
    float t = -1.0;
	vec3  ce = ray.origin - sph.pos;
	float b = dot( ray.dir, ce );
	float c = dot( ce, ce ) - sph.radiusSq;
	float h = b*b - c;
    if( h > 0.0 ) {
		t = -b - sqrt(h);
	}
    
    if ( t > 0.0 ) {
    	dist = t;
        return true;
    }
	
	return false;
}

// Function 862
vec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {
  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);
  return normalize(camMat * vec3(screenPos, lensLength));
}

// Function 863
Hit castRay(inout vec3 p, vec3 dir)
{	
	Hit hit;
	Distance dist = distance(p);
	float eps = 0.001;
	
	for (int i = 0; i < MAX_STEPS; i++)
	{
		Distance dist = distance(p);
		float d = dist.value;
                
		if (d <= eps)
		{
            hit.is = true;
            hit.pos = p;
            hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));
            return hit;
		}
        
		p += dir*d*0.9;
	}	
	hit.is = false;
	hit.color = vec3(0);
	return hit;
}

// Function 864
vec3 getNormalWater(vec3 p, float eps) {   
    vec3 n;
    n.y = mapWater(p, ITER_FRAGMENT, true);    
    n.x = mapWater(vec3(p.x+eps,p.y,p.z), ITER_FRAGMENT, true) - n.y;
    n.z = mapWater(vec3(p.x,p.y,p.z+eps), ITER_FRAGMENT, true) - n.y;
    n.y = eps;  
    return normalize(n);
}

// Function 865
vec3 calcNormal(vec3 pos)
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    scene(pos+eps.xyy).dist - scene(pos-eps.xyy).dist,
	    scene(pos+eps.yxy).dist - scene(pos-eps.yxy).dist,
	    scene(pos+eps.yyx).dist - scene(pos-eps.yyx).dist );
	return normalize(nor);
}

// Function 866
vec2 estimateNormal(vec2 p) {
    return normalize(vec2(
        mapSeed01(vec2(p.x + 1., p.y)) - mapSeed01(vec2(p.x - 1., p.y)),
        mapSeed01(vec2(p.x, p.y + 1.)) - mapSeed01(vec2(p.x, p.y - 1.))
    ));
}

// Function 867
bool RayIntersectAABox (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec2 time)
{
	vec3 roo = rayPos - (boxMin+boxMax)*0.5;
    vec3 rad = (boxMax - boxMin)*0.5;

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    time = vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
	
    return time.y>time.x && time.y>0.0;
}

// Function 868
vec3 SeaNormal( in vec3 pos, in float d, out float height)
{
	float p = .005 * d * d / iResolution.x;
	vec3 nor  	= vec3(0.0,		    SeaMap(pos.xz), 0.0);
	vec3 v2		= nor-vec3(p,		SeaMap(pos.xz+vec2(p,0.0)), 0.0);
	vec3 v3		= nor-vec3(0.0,		SeaMap(pos.xz+vec2(0.0,-p)), -p);
    height = nor.y;
	nor = cross(v2, v3);
	return normalize(nor);
}

// Function 869
void generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )
{
	vec2 p = (-iResolution.xy + 2.0*pi)/iResolution.y;
        
    // camera matrix
    vec3 ww = normalize( ta - po );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );

    resRo = po;
    resRd = rd;
}

// Function 870
vec3 normal(vec3 p)
{
    vec2 eps = vec2(0.001,0.);
    return normalize(vec3(map(p + eps.xyy) - map(p-eps.xyy),
                  map(p + eps.yxy) - map(p-eps.yxy),
                  map(p + eps.yyx) - map(p-eps.yyx)
                 )
            );
}

// Function 871
vec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)
{
	vec3 vForward = normalize(vCameraDir);
	vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));
	vec3 vUp = normalize(cross(vForward, vRight));
    
	vec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);

	return vDir;
}

// Function 872
vec3 getNormal2(Camera c,vec3 pos, float index){
    vec3 n;
    if(index <= float(PLANE_NB)){
        n = normalize( getObject(index).xyz );
    }else{
       	n = normalize( pos - getObject(index).xyz );
    }
    return n;
}

// Function 873
vec3 calcNormal(vec3 p, float t) {
  // Scale epsilon for distance from origin.
  float eps = 1.0*length(p)*0.001;
  //float eps = 0.005;
  vec2 e = vec2(eps, 0.0);
  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),
                        eval(p + e.yxy) - eval(p - e.yxy),
                        eval(p + e.yyx) - eval(p - e.yyx)));
}

// Function 874
vec3 orientRay(vec3 ray, vec3 v)
{
    return normalize(dot(v, ray) * ray);
}

// Function 875
void RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
{
    // floor
    {
    	SMaterial material;
        material.diffuse = vec3(0.5f, 0.5f, 0.5f);
        material.specular = vec3(0.3f, 0.3f, 0.3f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), 0.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = floor(intersectPos.xz / 20.0f);
            float shade = mix(0.2f, 0.6f, mod(uv.x + uv.y, 2.0f));
            material.roughness = mix(0.02f, 0.2f, mod(uv.x + uv.y, 2.0f));
            hitInfo.material.diffuse = vec3(shade, shade, shade);
        }
    }
    
    // walls
    {
    	SMaterial material;
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
        
        vec3 offset = vec3(0.0f, 80.0f, -80.0f);
        vec3 scale = vec3(80.0f, 80.0f, 1.0f);
        vec3 A = vec3( 1.0f,  1.0f, 0.0f) * scale + offset;
        vec3 B = vec3(-1.0f,  1.0f, 0.0f) * scale + offset;
        vec3 C = vec3(-1.0f, -1.0f, 0.0f) * scale + offset;
        vec3 D = vec3( 1.0f, -1.0f, 0.0f) * scale + offset;
        
        // back wall
		material.diffuse = vec3(0.9f, 0.9f, 0.9f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.xyz, B.xyz, C.xyz, D.xyz, material);
        
        // left wall
        material.diffuse = vec3(0.9f, 0.1f, 0.1f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx, B.zyx, C.zyx, D.zyx, material);
        
        // right wall
        material.diffuse = vec3(0.1f, 0.9f, 0.1f);
        vec3 multiplier = vec3(-1.0f, 1.0f, 1.0f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx * multiplier, B.zyx * multiplier, C.zyx * multiplier, D.zyx * multiplier, material);
    }
    
    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2
    
        // shadow casting ball
        {
            SMaterial material;
            material.diffuse = vec3(0.9f, 0.9f, 0.9f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.0f, 0.0f, 0.0f);
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4( 0.0f, 40.0f, -30.0f, 15.0f), material);
        }

        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        
        }        
    
    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2 || SCENE == SCENE_MULTIFOG || SCENE == SCENE_ORGANICFOG
    
        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        
        }  
    
    #elif SCENE == SCENE_EMISSION
    
    	// none!
    
    #elif SCENE == SCENE_LIGHTINFOG1 || SCENE == SCENE_LIGHTINFOG2
    
        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, -30.0f, 5.0f), material);        
        }     
    
    #endif
}

// Function 876
float castRay(vec3 pos, vec3 dir, float maxDst, float minDst)
{
    float dst = SDF(pos);
    //return dst;
    
    float t = 0.0;
    
    while (dst > minDst && t < maxDst)
    {
        t += dst;
        pos += dst * dir;
        dst = SDF(pos);
    }
    
    return t + dst;
}

// Function 877
vec3 calcNormalGlass( in vec3 pos ) {
    const vec2 e = vec2(1.0,-1.0)*0.005;
    return normalize( e.xyy*mapGlass( pos + e.xyy ) + 
					  e.yyx*mapGlass( pos + e.yyx ) + 
					  e.yxy*mapGlass( pos + e.yxy ) + 
					  e.xxx*mapGlass( pos + e.xxx ) );
}

// Function 878
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 vri, vf, hv, p;
  vec2 edN[3], pM, gIdP;
  float dHit, d, s, eps;
  if (rd.x == 0.) rd.x = 0.0001;
  if (rd.z == 0.) rd.z = 0.0001;
  eps = 0.0005;
  edN[0] = vec2 (1., 0.);
  edN[1] = 0.5 * vec2 (1., sqrt3);
  edN[2] = 0.5 * vec2 (1., - sqrt3);
  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));
  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));
  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;
  pM = HexToPix (PixToHex (ro.xz / hgSize));
  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;
  s = Minv3 (hv);
  gIdP = vec2 (-999.);
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    gId = PixToHex (p.xz / hgSize);
    if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim) {
      if (gId != gIdP) {
        gIdP = gId;
        SetObjConf ();
      }
      d = ObjDf (p);
    } else d = dstFar;
    if (dHit + d < s) dHit += d;
    else {
      dHit = s + eps;
      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));
      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;
      s = Minv3 (hv);
    }
    if (d < eps || dHit > dstFar || p.y < 0.) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 879
vec2 rayMarch(vec3 rayOrigin, vec3 rayDir, out vec3 cloudColor,vec2 fragCoord, int traceMode)
{
    float t = 0.0;
    vec3 pixelColor;
    vec3 skyColor = vec3(0.9);

    if ((iTime>20.0)&&(iTime<52.0))
    {
    	float adder=((iTime>=36.0)&&(iTime<44.0))?(fract(hash12(rayDir.xz))*0.1):0.0;
        for (int rayStep = 0; rayStep < NUM_STEPS; ++rayStep)
        {
            vec3 position = adder+0.05 * float(NUM_STEPS - rayStep) * rayDir;
            position.z+=iTime;
            float noiseScale=0.75;
            float posMulty=((iTime>=28.0)&&(iTime<36.0))?0.35:1.25;
            float signedCloudDistance = position.y+posMulty;
            for (int octaveIndex = 0; octaveIndex < NUM_NOISE_OCTAVES; ++octaveIndex)
            {
                position *= 2.0;
                noiseScale *= 2.0;
                signedCloudDistance -= RandomNumber(position) / noiseScale;
            }
            if (signedCloudDistance < 0.0)
                pixelColor+=(pixelColor-1.-signedCloudDistance * skyColor.zyx)*signedCloudDistance*0.15;
        }

        cloudColor=pixelColor;
    }
    
    for (int i = 0; i < 128; i++)
    {
        vec2 res = (iTime<20.0)?SDFCageScene(rayOrigin + rayDir * t,traceMode):
        	(iTime<52.0)?SDFscene(rayOrigin + rayDir * t):
        	(iTime<70.0)?SDFSeaScene(rayOrigin + rayDir * t):
        	SDFCageScene(rayOrigin + rayDir * t,traceMode);
        if (res[0] < (0.0001*t))
        {
            return vec2(t,res[1]);
        }
        t += res[0];
    }
     
    return vec2(-1.0,-1.0);
}

// Function 880
vec3 normal(vec3 p, float d){//from dr2
  vec2 e=vec2(d,-d);vec4 v=vec4(DE(p+e.xxx),DE(p+e.xyy),DE(p+e.yxy),DE(p+e.yyx));
  return normalize(2.*v.yzw+vec3(v.x-v.y-v.z-v.w));
}

// Function 881
vec2 rayMarch(vec3 rayDir, vec3 cameraOrigin)
{
    const int MAX_ITER = 100;
	const float MAX_DIST = 40.0;
    
    float totalDist = 0.0;
	vec3 pos = cameraOrigin;
	float dist = EPSILON;
    
    for(int i = 0; i < MAX_ITER; i++)
	{
		dist = distfunc(pos);
		totalDist += dist;
		pos += dist*rayDir;
        
        if(dist < EPSILON || totalDist > MAX_DIST)
		{
			break;
		}
	}
    
    return vec2(dist, totalDist);
}

// Function 882
vec4 RayMarch(Ray initialRay)
{
	if (TerrainMiss(initialRay))
	{
		return SKY;
	}
	
	// raycast directly to MAX_H if above MAX_H and casting downwards
	if (initialRay.origin.z > MAX_H && initialRay.direction.z < 0.0)
	{
		initialRay = CastRay(initialRay, (initialRay.origin.z - MAX_H) / abs(initialRay.direction.z));
	}
	
	float delt = MAX_H / MARCHES / abs(initialRay.direction.z);
	
	for(float t = 0.0; t <= MARCHES;  t++)
	{				
		float dist = delt * t;
		Ray ray = CastRay(initialRay, dist);
		
		// We marched our way right out of the terrain bounds...
		if (TerrainMiss(ray))
		{
			return SKY;
		}
		
        float depthBelowTerrain = MixedTerrainHeight(ray.origin) - ray.origin.z;
        
		if (depthBelowTerrain >= 0.1)
		{
            // ray backtracking
            ray = CastRay(initialRay, dist - (depthBelowTerrain / ray.direction.z));
            
			return MixedTerrainColor(ray.origin);
		}
	}
	
	return RED;
}

// Function 883
vec3 getDetailNormal(vec3 p, vec3 normal, vec3 idx){
    vec3 tangent;
    vec3 bitangent;
    //Construct orthogonal directions tangent and bitangent to sample detail gradient in
    pixarONB(normal, tangent, bitangent);
    
    tangent = normalize(tangent);
    bitangent = normalize(bitangent);
    
    float EPS = 1e-3;
    vec3 delTangent = 	getDetailExtrusion(p + tangent * EPS, normal, idx) - 
        				getDetailExtrusion(p - tangent * EPS, normal, idx);
    
    vec3 delBitangent = getDetailExtrusion(p + bitangent * EPS, normal, idx) - 
        				getDetailExtrusion(p - bitangent * EPS, normal, idx);
    
    return normalize(cross(delTangent, delBitangent));
}

// Function 884
vec3 heightFieldNormal(vec2 uv)
{
    vec2 e = vec2(1. / 512., 0);
    float h0 = heightField(uv);
    float h1 = heightField(uv + e.xy);
    float h2 = heightField(uv + e.yx);
    float h3 = heightField(uv - e.xy);
    float h4 = heightField(uv - e.yx);
    return normalize(cross(vec3(0, h2 - h4, e.x * 2.), vec3(e.x * 2., h1 - h3, 0)));
}

// Function 885
float DistRay(ray r, vec3 p){
	return length(p - ClosestPoint(r, p));
}

// Function 886
float RayMarch(vec4 rayOrigin, vec4 rayDistance)
{
    float distanceOrigin = 0.0018;
    
    for(int i = 0; i < MAX_STEPS; i++)
    {
        //Get next point
        vec4 p = rayOrigin + rayDistance*distanceOrigin;
        
        //Get distance from new point to the scene
        float dS  = GetDist(p);
        
        //Add distance from new point to total distance from origin
        distanceOrigin += dS;
        
        //If we have marched too far or if we are sufficiently close to scene, we're done marching
        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;
    }
    return distanceOrigin;
}

// Function 887
vec3 calcNormal_0( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    
    return normalize( e.xyy*map_0( pos + e.xyy ).x + 
					  e.yyx*map_0( pos + e.yyx ).x + 
					  e.yxy*map_0( pos + e.yxy ).x + 
					  e.xxx*map_0( pos + e.xxx ).x );
}

// Function 888
vec3 raytrace(vec3 raydirection){
    vec2 intersection = sphIntersect(cameraposition, raydirection);
    vec3 normal = normalize((cameraposition+(raydirection*intersection.x))-sphereposition);
    vec3 randomnormal = normalize(normal+nrand3(fbm(normal*16.0)*0.1, vec3(0.0)));
    vec3 reflected = reflect(raydirection, randomnormal);
    vec3 color = fresnel(raydirection, normal)*texture(iChannel1, reflected).rgb;
    if(intersection == vec2(-1.0)){color = texture(iChannel1, raydirection).rgb;}
    return color;
}

// Function 889
vec3 calcNormal(vec3 p) {
 
    vec2 eps = vec2(.001,0.);
    vec3 n   = vec3(dstScene(p+eps.xyy)-dstScene(p-eps.xyy),
                    dstScene(p+eps.yxy)-dstScene(p-eps.yxy),
                    dstScene(p+eps.yyx)-dstScene(p-eps.yyx));
    return normalize(n);
    
}

// Function 890
vec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale, float lod)
{
    vec3 P = vec3(-4, 4, 0) * 0.01;
    
    vec3 B;
    B.x = triplanarMap(tex, p+P.xzz, N, scale, lod).r;
    B.y = triplanarMap(tex, p+P.zxz, N, scale, lod).r;
    B.z = triplanarMap(tex, p+P.zzx, N, scale, lod).r;
    B -= triplanarMap(tex, p, N, scale, lod).r;
    
    B = (B-N*dot(B,N));
    return normalize(N+B*strength);
}

// Function 891
vec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {
    vec3 F = ref - eye;
    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));
    vec3 U = normalize(cross(R, F));
    
    vec3 V = U * length(F) * tan(FOVY * 0.5);
    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);
    
    vec3 p = ref + ndc.x * H + ndc.y * V;
    
    return normalize(p - eye);
}

// Function 892
Ray getScreenRay(in vec2 uv)
{
    float vFov = 3.14 / 10.0;
    float hFov = atan(iResolution.x / iResolution.y * tan(vFov));
    
    vec2 coord = 2.0 * uv - 1.0;
    
    float dv = atan(coord.y * tan(vFov));
    float dh = atan(coord.x * tan(hFov));
    
    vec3 direction = vec3(sin(dh), sin(dv) * cos(dh), -cos(dh)*cos(dv));
    return Ray(vec3(0,0,9), direction);
}

// Function 893
vec2 borderReflect(vec2 p, float r)
{
    float eps = 0.0001;
    vec2 epsx = vec2(eps,0.0);
    vec2 epsy = vec2(0.0,eps);
    vec2 b = (1.+vec2(r,r))* 0.5;
    r /= 3.0;
    
    p -= 0.5;
    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),
                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;
    float d = roundSquare(p, b, r);
    p += 0.5;
    return p + d*normal;
}

// Function 894
MarchResult MarchRay(vec3 orig,vec3 dir)
{
    float steps = 0.0;
    float dist = 0.0;
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float sceneDist = Scene(orig + dir * dist);
        
        dist += sceneDist * STEP_MULT;
        
        steps++;
        
        if(abs(sceneDist) < MIN_DIST)
        {
            break;
        }
    }
    
    MarchResult result;
    
    result.position = orig + dir * dist;
    result.normal = Normal(result.position);
    result.dist = dist;
    result.steps = steps;
    return result;
}

// Function 895
Obj castRay(vec3 ro, vec3 rd) 
{   
    float t = 0.0;
    
    Obj intersection;
    
    for (int i = 0; i < MAX_STEPS; i++) 
    {	
        vec3 p = ro + rd*t;
        intersection = getDist(p); 
        
        // This makes the bottom of a box completely transparent
        if (intersection.type == GROUND)
            t += intersection.dist;
        else
            t += abs(intersection.dist);
        
        // The ray has marched far enough but hit nothing. 
        // Render the pixel as a part of the sky.
        if (t > MAX_DIST) 
        {
        	intersection = Obj(SKY, t, p, vec3(0.));
            break;
        }

        // The ray has marched close enough to an object
        if (abs(intersection.dist) < SURF_DIST) 
        {
            intersection = Obj(intersection.type, t, p, vec3(0.));
        	break;
        }
        
        intersection.dist = t;
    }
    
    return intersection;
}

// Function 896
vec3 getNormal( in vec3 p ){

    vec2 e = vec2(0.5773,-0.5773)*EPS;   //0.001;
    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + 
                      e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));
}

// Function 897
vec4 ray(vec3 p, vec3 d)
{    
    vec3 n;
    float t = intersect_diamond(p, d, 1.0, n);
    if (t <= 0.0)
		return background(d);

    float f = fresnel(1.0, N, dot(-d, n));
    vec4 c = background(reflect(d, n)) * f;
    float cr = 1.0 - f;

    p += d * t;
    d = refract(d, n, 1.0 / N);

    for (int i = 0; i < MAX_REFLECTIONS; ++i)
    {
        if (cr < 0.05)
            break;
        t = intersect_diamond(p, d, -1.0, n);
        if (t > 0.0)
        {
            vec3 r = refract(d, n, N);
            if (r != vec3(0.0))
            {
                f = fresnel(N, 1.0, dot(-d, n));
                c += background(r) * (1.0 - f) * cr;
                cr *= f;
            }
            p += d * t;
            d = reflect(d, n);
        }
    }
    return c + background(d) * cr;
}

// Function 898
Ray initRayToTarget(vec3 origin, vec3 target) {
    Ray ray;

    // Init ray values
    // Calculate ray direction
    ray.direction = normalize(target - origin);

    // Start a bit away from the origin so we don't hit whatever is at the start
    ray.origin = origin + ray.direction * EPSILON;

    ray.target = target;
    ray.position = origin;

    return ray;
}

// Function 899
vec3 get_normal(vec2 uv) {
    // http://web.cs.ucdavis.edu/~amenta/s12/findnorm.pdf
 	uv = uv * (1.0 + 0.6*cos(iTime));
    
    float phi = 2.0*3.1416*uv.x;
    float theta = 2.0*3.1416*uv.y;
    
    vec3 dphi = vec3(-sin(phi), cos(phi), 0.0);
    vec3 dtheta = vec3(-sin(theta)*cos(phi), -sin(theta)*sin(phi), cos(theta));
    
    return normalize(cross(dphi, dtheta));  
}

// Function 900
vec3 GetBumpMapNormal (vec2 uv, mat3 tangentSpace)
{    
	float delta = -1.0/512.0;
	float A = texture(iChannel1, uv + vec2(0.0, 0.0)).x;
	float B = texture(iChannel1, uv + vec2(delta, 0.0)).x;
    float C = texture(iChannel1, uv + vec2(0.0, delta)).x;    
    
	vec3 norm = normalize(vec3(A - B, A - C, 0.15));
	
	return normalize(tangentSpace * norm);
}

// Function 901
vec2 rayMarching(vec3 ro, vec3 rd) {
    float tmax = MAX_DIST;
    float t = 0.0;
    vec2 result = vec2(-1.0);
    
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ro + rd * t;
        vec2 res = sceneSDF(p);
        if (res.x < EPSILON || t > tmax) break;
       
        t += res.x;
        result.x = t;
        result.y = res.y;
    }
    
    if (t > tmax) result.x = tmax;
    return result;
}

// Function 902
vec4 raymarch(vec4 P,vec3 R)
{
    P = vec4(P.xyz+R*2.,2);
    float E = 1.;
 	for(int i = 0;i<300;i++)
    {
        P += vec4(R,1)*E;
        float H = height(P.xy);
        E = clamp(E+(H-P.z)-.5,E,1.);
        if (H-E*.6<P.z)
        {
        	P -= vec4(R,1)*E;
            E *= .7;
            if (E<PRE*P.w/FOG) break;
        }
    }
    return P;
}

// Function 903
bool RayMarching(in vec2 screen_pos, in float near, in float far, out vec3 hit_pos, out float cal_delta)
{
	const float delta = 1.0/float(K_MACRO_STEP);
	
	float z_param1 = far-near;
	float z_param2 = near/z_param1;
	
	for (int i=0;i<K_MACRO_STEP; ++i)
	{
		vec3 pos = vec3(screen_pos, float(i)*delta);
		//ortho inv trans
		pos.z += z_param2;
		pos.z *= z_param1;
		
		//view inv trans
		//pass
		
		vec3 pre_pos = vec3(pos.xy, pos.z - delta * z_param1);
		
		vec3 re = pre_pos;
		if( Hit(pos, pre_pos, re))
		{
			hit_pos = re;
			cal_delta = delta*z_param1;
			return true;
		}
	}
	return false;
}

// Function 904
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = VAR_ZERO; j < 220; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.5, 0.8 * h);
  }
  if (h < 0.) {
    sHi = s;
    for (int j = VAR_ZERO; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > GrndHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 905
vec3 computeSurfaceNormal(vec3 p){
    float d = distanceToNearestSurface(p);
    return normalize(vec3(
        distanceToNearestSurface(p+deltax)-d,
        distanceToNearestSurface(p+deltay)-d,
        distanceToNearestSurface(p+deltaz)-d
    ));
}

// Function 906
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 160; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.5, 0.5 * h);
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > GrndHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 907
vec3 getNormal( in vec3 p ){

    // Note the larger than usual sampline distance (epsilon value). It's an old trick to give
    // rounded edges, and with the right objects it gives a slightly blurred antialiased look.
    vec2 e = vec2(0.015, -0.015);
    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));
}

// Function 908
vec2 shootRay(vec2 ro,vec2 rd, float s) {
    // i need this "nudge" to escape the boundary, when I switch between
    // positive and negative :/ 
	ro += rd*0.01;
	for (int i=0; i<20; i++) {
		float dis = s*sdfMap(ro);
		if (dis < .0) break;
		ro += rd*dis;
	}
	return ro;
}

// Function 909
vec4 raymarch(vec3 from, vec3 increment)
{
	const float maxDist = 200.0;
	const float minDist = 0.1;
	const int maxIter = RAYMARCH_ITERATIONS;
	
	float dist = 0.0;
	
	float material = 0.0;
	
	for(int i = 0; i < maxIter; i++) {
		vec3 pos = (from + increment * dist);
		float distEval = distf(pos, material);
		
		if (distEval < minDist) {
			break;
		}
		
		dist += distEval * RAYMARCH_DOWNSTEP;
	}
	
	
	if (dist >= maxDist) {
		material = 0.0;
	}
	
	return vec4(dist, material, 0.0, 0.0);
}

// Function 910
bool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = normalize(info.m_intersectionPoint - sphere.m_center);
	
	// texture coordinates are just the angular part of spherical coordiantes of normal
	info.m_textureCoordinates = vec2
	(
		atan(info.m_surfaceNormal.y, info.m_surfaceNormal.x) / 8.0,
		acos(info.m_surfaceNormal.z ) / 8.0
	);
	
	// bump mapping
	vec3 uaxis = normalize(cross(vec3(0.0,1.0,0.0), info.m_surfaceNormal));
	vec3 vaxis = normalize(cross(uaxis, info.m_surfaceNormal));
	mat3 mattanspace = mat3
	(
		uaxis,
		vaxis,
		info.m_surfaceNormal
	);
	
	float delta = -1.0/512.0;
	float A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;
	float B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;
    float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;
	
	vec3 norm = normalize(vec3(B - A, C - A, 0.25));
	
	info.m_surfaceNormal = normalize(mattanspace * norm);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 911
vec3 calcNormalstage5(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage5 (p+e.xyy) - mapstage5(p-e.xyy),
            mapstage5 (p+e.yxy) - mapstage5(p-e.yxy),
            mapstage5 (p+e.yyx) - mapstage5(p-e.yyx)                           
        
        )
	);
}

// Function 912
float rayMarch(in vec3 ro, in vec3 rd, out int mat, out int iter)
{
  float t = 0.0;
  float distance;
  for (int i = 0; i < MAX_RAY_MARCHES; i++)
  {
    iter = i;
    distance = map(ro + rd*t, mat);
    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;
    t += distance;
  }
  
  if (abs(distance) > 100.0*TOLERANCE) return MAX_RAY_LENGTH;
  
  return t;
}

// Function 913
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + 
                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + 
                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + 
                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );
}

// Function 914
vec3 SceneNormal(vec3 p, float h, out float d, int izero)
{
	vec3 n, o = vec3(0,0,h);
	vec4 s;
	for (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))
		s[i] = Scene(p + o).d;        
	n = s.yzw - (d = s.x);
	if (dot(n,n) < 1e-7) n = vec3(0,1,0);
	else n = normalize(n);
	return n;
}

// Function 915
vec4 GetNormal(vec3 u
){vec2 e = vec2(0.003,0.)
 ;float o=map(u,-1)
 ;return vec4(normalize(vec3(map(u+e.xyy,-1)
                            ,map(u+e.yxy,-1)
                            ,map(u+e.yyx,-1))-o),o);}

// Function 916
vec3 Normal( vec3 pos )
{
	// in theory we should be able to get a good gradient using just 4 points
	vec2 d = vec2(-1,1) * .01;
	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 = DistanceField(p0);
	float f1 = DistanceField(p1);
	float f2 = DistanceField(p2);
	float f3 = DistanceField(p3);
	
	return normalize( p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3) );
}

// Function 917
vec3 normal_unpack(vec2 enc)
{
    vec3 n;
    n.xy = enc*2.0-1.0;
    n.z = sqrt(1.0-dot(n.xy, n.xy));
    return n;
}

// Function 918
void buildOrthonormalBasis(in vec3 n, out vec3 u, out vec3 v)
{
	float sgn = (n.z < 0.0) ? -1.0 : 1.0;
    float a = -1.0 / (sgn + n.z);
   	float b = n.x * n.y * a;
    u = vec3(1.0 + sgn * n.x * n.x * a, sgn * b, -sgn * n.x);
    v = vec3(b, sgn + n.y * n.y * a, -n.y);
}

// Function 919
vec3 RayDirection(float fov, vec2 size, vec2 fragCoord)
{
    vec2 xy = fragCoord - (size / 2.0);
    float z = size.y / tan(radians(fov) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 920
TriangleHit rayIcoOuterHit(vec3 origin, vec3 dir) {
    for (int i = 0; i < ICO_FACES; i++) {
    	TriangleHit hit = rayTriHit(origin, dir, icoIndices[i]);
        if (hit.t <= 10.0 && dot(dir, hit.normal) < 0.0) {
        	return hit;
        }
    }
    return noHit;
}

// Function 921
bool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {
    bool hitResult = false;
    float t;
    SurfaceHitInfo currentHit;

    //Convert ray to object space
    Ray rayLocal;
    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );

    if( obj.type_ == OBJ_PLANE ) {
        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_SPHERE ) {
        hitResult = raySphereIntersection( 	rayLocal, obj.params_[1], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_CYLINDER ) {
        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_AABB ) {
        hitResult = rayAABBIntersection( rayLocal, vec3(obj.params_[0], obj.params_[1], obj.params_[2]), vec3(obj.params_[3], obj.params_[4], obj.params_[5]), forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_DISK ) {
        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );
    }

    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {
        //Convert results to world space
        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );

        dist = t;
        hit = currentHit;
        hit.mtl_id_ = obj.mtl_id_;
        
        return true;
    } else {
    	return false;
    }
}

// Function 922
vec3 calcNormal( in vec3 p, in vec4 c )
{
    vec4 z = vec4(p,0.0);

    // identity derivative
    vec4 J0 = vec4(1,0,0,0);
    vec4 J1 = vec4(0,1,0,0);
    vec4 J2 = vec4(0,0,1,0);
    
  	for(int i=0; i<numIterations; i++)
    {
        vec4 cz = qconj(z);
        
        // chain rule of jacobians (removed the 2 factor)
        J0 = vec4( dot(J0,cz), dot(J0.xy,z.yx), dot(J0.xz,z.zx), dot(J0.xw,z.wx) );
        J1 = vec4( dot(J1,cz), dot(J1.xy,z.yx), dot(J1.xz,z.zx), dot(J1.xw,z.wx) );
        J2 = vec4( dot(J2,cz), dot(J2.xy,z.yx), dot(J2.xz,z.zx), dot(J2.xw,z.wx) );

        // z -> z2 + c
        z = qsqr(z) + c; 
        
        if(qlength2(z)>4.0) break;
    }
    
	vec3 v = vec3( dot(J0,z), 
                   dot(J1,z), 
                   dot(J2,z) );

    return normalize( v );
}

// Function 923
vec3 calcNormal( in vec3 pos, in float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 924
vec3 calcNormalstage4(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage4 (p+e.xyy) - mapstage4(p-e.xyy),
            mapstage4 (p+e.yxy) - mapstage4(p-e.yxy),
            mapstage4 (p+e.yyx) - mapstage4(p-e.yyx)                           
        
        )
	);
}

// Function 925
bool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {
    t = -1.0;
	vec3  ce = ray.origin - sph.pos;
	float b = dot( ray.dir, ce );
	float c = dot( ce, ce ) - sph.radiusSq;
	float h = b*b - c;
    if( h > 0.0 ) {
		t = -b - sqrt(h);
	}
	
	return ( t > 0.0 );
}

// Function 926
vec3 calcNormal(vec3 p) {
 
    vec2 eps = vec2(.001,0.);
    vec3   n = vec3(dstScene(p + eps.xyy,false).dst - dstScene(p - eps.xyy,false).dst,
                    dstScene(p + eps.yxy,false).dst - dstScene(p - eps.yxy,false).dst,
                    dstScene(p + eps.yyx,false).dst - dstScene(p - eps.yyx,false).dst);
    return normalize(n);
    
}

// Function 927
float rayDistance(Ray r,vec3 p){
    vec3 v = r.origin - p;
    return length(v - dot(v,r.direction)*r.direction);
}

// Function 928
vec3 combineNormals1(vec3 n0, vec3 n1) {
    n0 = n0 * 2.0 - 1.0;
    n1 = n1 * 2.0 - 1.0;
    n0 = vec3(n0.xy + n1.xy, n0.z * n1.z);
    return normalize(n0) * 0.5 + 0.5;
}

// Function 929
vec3 normal(vec3 surface){
  vec2 offset = vec2(0.01,0.);
    vec3 nDir = vec3(
      obj(surface+offset.xyy),
        obj(surface+offset.yxy),
        obj(surface+offset.yyx)
    ) - obj(surface);
    return normalize(nDir);
}

// Function 930
vec3 normal(vec3 p)
{
    vec2 e = vec2(0.0001, 0.0);
    float d = map(p);
    vec3 n = d - vec3(
        map(p - e.xyy),
        map(p - e.yxy),
        map(p - e.yyx));
    return normalize(n);
}

// Function 931
void normal(in vec3 x, out vec3 n, in float dx)
{
    vec2 s, na;
    
    scene(x,s);
    scene(x+dx*c.xyy, na);
    n.x = na.x;
    scene(x+dx*c.yxy, na);
    n.y = na.x;
    scene(x+dx*c.yyx, na);
    n.z = na.x;
    n = normalize(n-s.x);
}

// Function 932
vec4 RayMarch(vec3 ro, vec3 rd) {
	float dO=0.;
    float dS=0.;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        dS = GetDist(p, ro);
        dO += dO>MAX_DIST || dS<SURF_DIST ? 0.00 : dS;
    }
    
    return vec4( ro + rd*dO,dO); // ##
}

// Function 933
vec3 GetNormal( vec3 pos, float eps, bool i )
{
    vec2 d = vec2(-1,1)*eps;
    return normalize(
				SDF(pos+d.xxx,i)/d.xxx +
				SDF(pos+d.xyy,i)/d.xyy +
				SDF(pos+d.yxy,i)/d.yxy +
				SDF(pos+d.yyx,i)/d.yyx
            );
}

// Function 934
raymarchResult raymarchFast(vec3 at, vec3 normal) {
    for(int iteration = 0; iteration < 24; iteration++) {
        shapeResult sam = scene(at);
        if(sam.distance < 0.1)
            return raymarchResult(at, sam.materialId);
        at += normal * sam.distance;
    }
    return raymarchResult(vec3(0.0), MATERIAL_SKY);
}

// Function 935
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.001, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    
    return normalize(n);
}

// Function 936
vec3 RayMarchReflection(vec3 ro, vec3 dir) {
    float traveled = 0.0;
    vec2 distAndMaterial = vec2(0);
    
    for (int i=ZERO; i < 30; ++i){
        distAndMaterial = sceneWithMaterials(ro + dir * traveled);
        traveled += distAndMaterial.x;
        if (distAndMaterial.x < .01 || distAndMaterial.x > MAXDISTANCE) {
            break;
        }
    }
    
    vec3 hitPoint = ro + dir * traveled;
    
    vec3 color = vec3(1);
    color = GetColor(distAndMaterial, hitPoint, traveled, dir);
    return color;
}

// Function 937
vec3 normal_from_bary(vec3 n[3], vec4 w) {
    return normalize(n[0] * (w.w - w.x) + n[1] * (w.w - w.y) + n[2] * (w.w - w.z));
}

// Function 938
vec2 normal(vec2 p) {
    vec2 d = vec2(0.0001, 0.0);
    return normalize(
        vec2(
        	map(p + d.xy) - map(p - d.xy),
            map(p + d.yx) - map(p - d.yx)) / (2.0 * d.x));
}

// Function 939
vec3 GetRay( vec3 dir, float zoom, vec2 uv )
{
	uv = uv - .5;
	uv.x *= iResolution.x/iResolution.y;
	
	dir = zoom*normalize(dir);
	vec3 right = normalize(cross(vec3(0,1,0),dir));
	vec3 up = normalize(cross(dir,right));
	
	return normalize(dir + right*uv.x + up*uv.y);
}

// Function 940
vec3 normal(vec3 p)
{
	const vec2 eps = vec2(0.01, 0);
	float nx = distanceField(p + eps.xyy) - distanceField(p - eps.xyy);
	float ny = distanceField(p + eps.yxy) - distanceField(p - eps.yxy);
	float nz = distanceField(p + eps.yyx) - distanceField(p - eps.yyx);
	return normalize(vec3(nx, ny, nz));
}

// Function 941
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    CHECK_OBJ( objects[0] )
    CHECK_OBJ( objects[1] )
    CHECK_OBJ( objects[2] )
    CHECK_OBJ( objects[3] )
    CHECK_OBJ( objects[4] )
    CHECK_OBJ( objects[5] )
    CHECK_OBJ( objects[6] )
    CHECK_OBJ( objects[7] )
    
    return ( nearestDist < 1000.0 );
}

// Function 942
vec3 genNormal(vec3 p){
	return normalize(p);
}

// Function 943
RayTraceResult RayTraceHoledSphereDoubleSize(in Ray ray)
{
    RayTraceResult toSphere = RayTraceSphere(ray, sphereCenter, sphereRadius);
    RayTraceResult toSphereHole = RayTraceHoledSphere(ray);
    if (toSphereHole.t == infinite && toSphere.t < infinite)
    {
        vec3 bckOrg = ray.org;
        ray.org = toSphere.pos + ray.dir*epsilon;
        toSphereHole = RayTraceHoledSphere(ray);
        toSphereHole.t += length(bckOrg - ray.org);
    }
    return toSphereHole;
}

// Function 944
vec3 refraction(vec3 v_in, vec3 normal, float n1, float n2) {
    if (dot(v_in, normal) < 0.0)
        normal = -normal;
    float cosA = dot(v_in, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3 tang = normalize(v_in - cosA * normal);
    float sinB = n1 * sinA / n2;
    float cosB = sqrt(1.0 - sinB * sinB);
    return tang * sinB + normal * cosB;
}

// Function 945
vec3 getSurfaceNormal(vec2 fragCoord) {
    return 2.0*( read(2, fragCoord).xyz - 0.5 );
}

// Function 946
float rayMarch(vec3 ro, vec3 rd) {
    // Distance to the object
    float dO = 0.0; 
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + (dO * rd);
        float dS = getDistance(p);
        dO += dS;
        if (dS <= SURFACE_DIST || dS > MAX_DISTANCE) break;
    }

    return dO;
}

// Function 947
float TrackRay (vec3 ro, vec3 rd)
{
  vec3 p, rdi;
  vec2 cIdP, s;
  float dHit, d, eps;
  eps = 0.0001;
  if (rd.x == 0.) rd.x = 0.0001;
  if (rd.z == 0.) rd.z = 0.0001;
  rdi.xz = 1. / rd.xz;
  cIdP = vec2 (-999.);
  dHit = max (0., PrBox2Df (ro.xz, vec2 (rgHSize)));
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    cId = floor (p.xz);
    if (cId != cIdP) {
      cIdP = cId;
      SetTrkParms ();
    }
    d = TrackDf (p);
    s = (cId + step (0., rd.xz) - p.xz) * rdi.xz;
    dHit += min (d, 0.001 + max (0., min (s.x, s.y)));
    if (d < eps || dHit > dstFar || p.y < 0.) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 948
vec3 calcNormal( in vec3 pos ) {
    const vec2 e = vec2(1.0,-1.0)*0.0025;

    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + 
					    e.yyx*map( pos + e.yyx )   + 
					    e.yxy*map( pos + e.yxy )   + 
					    e.xxx*map( pos + e.xxx )   );  
    return n;
}

// Function 949
vec2 raymarchVoxel(vec3 ro, vec3 rd, out vec3 nor, vec2 beats) {
  vec3 pos = floor(ro);
  vec3 ri = 1.0 / rd;
  vec3 rs = sign(rd);
  vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;
  
  float res = -1.0;
  vec3 mm = vec3(0.0);
  
  for (int i = 0; i < 38; i++) {
    float k = voxelModel(pos, ro, beats);
    if (k > 0.5) {
      res = k;
      break;
    }
     
    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);
		dis += mm * rs * ri;
    pos += mm * rs;
  }
  
  if (res < -0.5) {
    return vec2(-1.0);
  }
  
  nor = -mm * rs;
  
  vec3 vpos = pos;
  vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
  float t = max(mini.x, max(mini.y, mini.z));
  
  return vec2(t, 0.0);
}

// Function 950
vec3 rayDirection(float fieldOfView, vec2 fragCoord) {
    vec2 xy = fragCoord - iResolution.xy / 2.0;
    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 951
vec3 getNormal (vec3 p) { vec2 e = vec2(.01,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }

// Function 952
vec3 calcNormal( vec3 pos, vec3 ray, float t) {
  //  vec2 e = vec2(eps.x, -eps.x); 
  //  return normalize(e.xyy * map(pos + e.xyy).x + e.yyx * map(pos + e.yyx).x + e.yxy * map(pos + e.yxy).x + e.xxx * map(pos + e.xxx).x);;

	float pitch = .5 * t / iResolution.x;
    
//#ifdef FAST
//	// don't sample smaller than the interpolation errors in Noise()
	pitch = max( pitch, .005 );
//#endif
	
	vec2 d = vec2(-1,1) * pitch;

	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 = map(p0).x;
	float f1 = map(p1).x;
	float f2 = map(p2).x;
	float f3 = map(p3).x;
	
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);
	//return normalize(grad);	// prevent normals pointing away from camera (caused by precision errors)
	return normalize(grad - max(.0,dot (grad,ray ))*ray);
}

// Function 953
vec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)
{
    // initialize
    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
    vec3 rayPos = startRayPos;
    vec3 rayDir = startRayDir;
    int bounceIndex = 0;
    for (; bounceIndex <= c_numBounces; ++bounceIndex)
    {
        // shoot a ray out into the world
        SRayHitInfo hitInfo;
        hitInfo.material = GetZeroedMaterial();
        hitInfo.dist = c_superFar;
        hitInfo.fromInside = false;
        TestSceneTrace(rayPos, rayDir, hitInfo);
        
        // if the ray missed, we are done
        if (hitInfo.dist == c_superFar)
        {           
            break;
        }
        
        // do absorption if we are hitting from inside the object
        if (hitInfo.fromInside)
            throughput *= exp(-hitInfo.material.refractionColor * hitInfo.dist);
        
        // get the pre-fresnel chances
        float specularChance = hitInfo.material.specularChance;
        float refractionChance = hitInfo.material.refractionChance;
        //float diffuseChance = max(0.0f, 1.0f - (refractionChance + specularChance));
        
        // take fresnel into account for specularChance and adjust other chances.
        // specular takes priority.
        // chanceMultiplier makes sure we keep diffuse / refraction ratio the same.
        float rayProbability = 1.0f;
        if (specularChance > 0.0f)
        {
        	specularChance = FresnelReflectAmount(
            	hitInfo.fromInside ? hitInfo.material.IOR : 1.0,
            	!hitInfo.fromInside ? hitInfo.material.IOR : 1.0,
            	rayDir, hitInfo.normal, hitInfo.material.specularChance, 1.0f);
            
            float chanceMultiplier = (1.0f - specularChance) / (1.0f - hitInfo.material.specularChance);
            refractionChance *= chanceMultiplier;
            //diffuseChance *= chanceMultiplier;
        }
        
        // calculate whether we are going to do a diffuse, specular, or refractive ray
        float doSpecular = 0.0f;
        float doRefraction = 0.0f;
        float raySelectRoll = RandomFloat01(rngState);
		if (specularChance > 0.0f && raySelectRoll < specularChance)
        {
            doSpecular = 1.0f;
            rayProbability = specularChance;
        }
        else if (refractionChance > 0.0f && raySelectRoll < specularChance + refractionChance)
        {
            doRefraction = 1.0f;
            rayProbability = refractionChance;
        }
        else
        {
            rayProbability = 1.0f - (specularChance + refractionChance);
        }
        
        // numerical problems can cause rayProbability to become small enough to cause a divide by zero.
		rayProbability = max(rayProbability, 0.001f);
        
        // update the ray position
        if (doRefraction == 1.0f)
        {
            rayPos = (rayPos + rayDir * hitInfo.dist) - hitInfo.normal * c_rayPosNormalNudge;
        }
        else
        {
            rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;
        }
         
        // Calculate a new ray direction.
        // Diffuse uses a normal oriented cosine weighted hemisphere sample.
        // Perfectly smooth specular uses the reflection ray.
        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared
        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.
        vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));
        
        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);
        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));

        vec3 refractionRayDir = refract(rayDir, hitInfo.normal, hitInfo.fromInside ? hitInfo.material.IOR : 1.0f / hitInfo.material.IOR);
        refractionRayDir = normalize(mix(refractionRayDir, normalize(-hitInfo.normal + RandomUnitVector(rngState)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));
                
        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);
        rayDir = mix(rayDir, refractionRayDir, doRefraction);
        
		// add in emissive lighting
        ret += hitInfo.material.emissive * throughput;
        
        // update the colorMultiplier. refraction doesn't alter the color until we hit the next thing, so we can do light absorption over distance.
        if (doRefraction == 0.0f)
        	throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);
        
        // since we chose randomly between diffuse, specular, refract,
        // we need to account for the times we didn't do one or the other.
        throughput /= rayProbability;
        
        // Russian Roulette
        // As the throughput gets smaller, the ray is more likely to get terminated early.
        // Survivors have their value boosted to make up for fewer samples being in the average.
        {
        	float p = max(throughput.r, max(throughput.g, throughput.b));
        	if (RandomFloat01(rngState) > p)
            	break;

        	// Add the energy we 'lose' by randomly terminating paths
        	throughput *= 1.0f / p;            
        }
    }
 
   // return pixel color
   #if SHOW_BOUNCE_VIS==1
       return c_colors[bounceIndex];
   #else
       return ret;
   #endif
}

// Function 954
float ray_aabb_intersect(in vec3 pos, in vec3 dir, in vec3 aabb_min, in vec3 aabb_max, out vec3 normal)
{
	float t = 0.0;
	int hit_axis = -1;
	for (int axis = 0; axis < 3; axis++) {
		float d = dir[axis];
		float p = pos[axis];
		float mn = aabb_min[axis];
		float mx = aabb_max[axis];
		float nt = 0.0;
		if (d >= 0.0 && p < mn) {
			float nt = (mn-p)/d;
			if (axis == 0 || nt > t) {
				t = nt;
				hit_axis = axis;
				normal = vec3(0.0);
				normal[axis] = -1.0;
			}
		} else if (d < 0.0 && p > mx) {
			float nt = (mx-p)/d;
			if (axis == 0 || nt > t) {
				t = nt;
				hit_axis = axis;
				normal = vec3(0.0);
				normal[axis] = 1.0;
			}
		}
	}

	if (hit_axis < 0) return INF;

	vec3 hit = pos + dir * t;
	for (int axis = 0; axis < 3; axis++) {
		if (axis == hit_axis) continue;
		if (hit[axis] < aabb_min[axis] || hit[axis] > aabb_max[axis]) {
			return INF;
		}
	}

	return t;
}

// Function 955
vec3 normal(vec3 p, float ds)
{
    ds *= ds;
	float e = min(.4, pix * ds);

    return normalize( vec3( de(p+vec3(e,0.0,0.0)).x - de(p-vec3(e,0.0,0.0)).x,
                            de(p+vec3(0.0,e,0.0)).x - de(p-vec3(0.0,e,0.0)).x,
                            de(p+vec3(0.0,0.0,e)).x - de(p-vec3(0.0,0.0,e)).x));
}

// Function 956
void raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {
    eye = vec3(0.0, 4.0, -20.0);
    ref = vec3(0.0, 1.0, 0.0);
    
    float len = tan(3.14159 * 0.125) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * iResolution.x / iResolution.y;
    vec3 p = ref + uv.x * H + uv.y * V;
    dir = normalize(p - eye);
}

// Function 957
void TraceRay( inout vec3 vOrigin, inout vec3 vDir, out vec3 vColour, inout vec3 vRemaining )
{	
    vec3 vLightPos = GetLightPos();
	vec2 vHit = Raycast(vOrigin, vDir);
	
	vec3 vHitPos = vOrigin + vDir * vHit.x;
	vec3 vHitNormal = GetSceneNormal(vHitPos);
	
	vec3 vAlbedo = vec3(0.0);
	vec3 vSpecR0 = vec3(0.0);
	float fSmoothness = 0.0;

	vec3 vEmissive = vec3(0.0);
	vec3 vGlow = GetFlameIntensity(vOrigin, vDir, vHit.x);

	if(vHit.x > 20.0)
	{
		vColour = vGlow + GetFlareIntensity(vOrigin, vDir);
		vColour *= vRemaining;
		vOrigin = vHitPos;
	}
	else
	{
		float fAmbientOcclusion = GetAmbientOcclusion(vHitPos, vHitNormal);
	
		
		if(vHit.y <= kMaterialWood)
		{
			vAlbedo = texture(iChannel2, vHitPos.xz * 0.25 ).rgb;
			vAlbedo = vAlbedo * vAlbedo;	
			
			fSmoothness = vAlbedo.r * vAlbedo.r * 0.1;
		}
		else
		if(vHit.y <= kMaterialGold)
		{
			vAlbedo = vec3(0.3, 0.1, 0.05);
			vSpecR0 = vec3(0.9, 0.5, 0.05);
			fSmoothness = 1.0;
		}
		else
		if(vHit.y <= kMaterialWax)
		{
			vAlbedo = vec3(0.9);
			vSpecR0 = vec3(0.01);
			
			float fDistanceThroughWax = GetDistanceWaxTop(vHitPos - vCandlestickPos - GetFlameWander() * 0.025);
			vEmissive = vFlameLightColour * (exp(fWaxExtinction * fDistanceThroughWax));
		}
		else
		if(vHit.y <= kMaterialWick)			
		{
			vAlbedo = vec3(0.01);
		}
		else
		if(vHit.y <= kMaterialChrome)			
		{
			vAlbedo = vec3(0.3);
			vSpecR0 = vec3(0.85);
			fSmoothness = 1.0;
		}
		else
		if(vHit.y <= kMaterialPaper)			
		{
			vAlbedo = vec3(0.9);
			vSpecR0 = vec3(0.0);
			fSmoothness = 0.0;
		}

				
		vec3 vDiffuseLight = SampleDiffuse(vHitNormal) * fAmbientOcclusion;
			
		vec3 vToLight = vLightPos - vHitPos;
		float fDistToLight = length(vToLight);
		vec3 vNormToLight = normalize(vToLight);
		
		float fDot = clamp(dot(vNormToLight, vHitNormal), 0.0, 1.0);
		
		float fShadow = RaycastShadow(vHitPos, vToLight, 1.0);
	
		// Fake shadow from candle
		fShadow *= smoothstep(0.4, 0.6, length(vToLight.xz) / max(vToLight.y, 0.01));

		fShadow = mix(0.1 + 0.15 * fAmbientOcclusion, 1.0, fShadow);
	
		vec3 vLightIntensity = vFlameLightColour * fDot * fShadow;
		vLightIntensity /= fDistToLight * fDistToLight;
		vDiffuseLight += vLightIntensity;
		
		vec3 vReflectDir = normalize(reflect(vDir, vHitNormal));
		
		vec3 vHalf = normalize(vReflectDir + -vDir);
		float fFresnelDot = clamp(1.0 - dot(vHalf, -vDir), 0.0, 1.0);	
		float fFresnel = pow(fFresnelDot, 5.0);
				
		vec3 vReflectFraction = vSpecR0 + (vec3(1.0) - vSpecR0) * fFresnel * fSmoothness;
	
		vColour = (vDiffuseLight * vAlbedo + vEmissive) * (vec3(1.0) - vReflectFraction);
		vColour += GetFlareIntensity(vOrigin, vDir);
		vColour += vGlow;
		vColour *= vRemaining;
		vRemaining *= vReflectFraction;
		vOrigin = vHitPos;
		vDir = vReflectDir;
	}
	
}

// Function 958
vec3 GetNormal(in vec3 point) 
{
    IntersectionData d0 = CheckSceneForIntersection(point);
    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));
    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));
    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));
    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));
}

// Function 959
void raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {
    eye = rotateY(vec3(0.0, 1.0, 15.0), 3.14159 * 1.5);
    ref = vec3(0.0, 0.0, 0.0);
    
    float len = tan(3.14159 * 0.125) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * iResolution.x / iResolution.y;
    vec3 p = ref + uv.x * H + uv.y * V;
    dir = normalize(p - eye);
}

// Function 960
vec3 calcNormal(const in vec3 pos) {
  vec3 eps = vec3(0.001, 0.0, 0.0);
  vec3 nor = vec3(
      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),
      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),
      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));
  return normalize(nor);
}

// Function 961
float rayleigh (float theta, float lambda)
{
    return Kr * (1. + pow(cos(theta),2.)) / pow(lambda, 4.);
}

// Function 962
vec3 normal(int number, float angle,vec2 fragCoord){
 int y = number/12;
    int x = number%12;
    vec3 p_temp = vec3((float(x) - 6.)*p_scale.x,(float(y) - 5.5)*p_scale.y,0.);
 float px =
        p_temp.x*(cos(angle) +pow(dir_angle.x,2.)*(1. - cos(angle))) 
        +p_temp.y*(dir_angle.y*dir_angle.x*(1. - cos(angle)) + dir_angle.z* sin(angle))
        +p_temp.z*(dir_angle.z*dir_angle.x*(1. - cos(angle)) - dir_angle.y* sin(angle));
       float py = 
       p_temp.x*(dir_angle.x*dir_angle.y*(1. - cos(angle)) - dir_angle.z* sin(angle)) 
      +p_temp.y*(cos(angle) +pow(dir_angle.y,2.)*(1. - cos(angle)) )
      +p_temp.z*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.x* sin(angle));
     float pz = 
       p_temp.x*(dir_angle.z*dir_angle.y*(1. - cos(angle)) + dir_angle.y* sin(angle)) 
      +p_temp.y*(dir_angle.z*dir_angle.z*(1. - cos(angle)) - dir_angle.x* sin(angle)) 
      +p_temp.z*(cos(angle) +pow(dir_angle.z,2.)*(1. - cos(angle)));
    
  
  float  radius2 =  radius + (pz)*s_ratio;
    
   //this is broken  
    bool red = (isred[number]==1);
    
    vec2 cent = fragCoord - vec2(px ,py) - 
                (red? center2.xy: center.xy)*iResolution.xy;
    
     float z =sqrt( pow(radius2,2.) - pow(cent.x,2.) - pow(cent.y,2.));  //1. 
    

    
    return normalize( vec3(cent,z));
}

// Function 963
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(0.005, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 964
vec3 ray_shade(in vec3 ro, in vec3 rd) {
    
    // handle resolution scaling
    ro *= resolution;

    // hit_nt will hold normal and distance
    vec4 hit_nt;
    
    // prev_cell and hit_cell store cell before and after intersection
    vec3 prev_cell, hit_cell;
    
    // do raytrace
    raytrace(ro, rd, hit_nt, prev_cell, hit_cell);
    
    svObjID = objID;
    
    // output color
    vec3 color = vec3(0);
    
    //vec3 light_dir = normalize(lp - ro);
    vec3 sk = sky(ro, rd);
    color = sk;
    
    // if ray hit
    if (hit_nt.w >= 0.0) {
        
        // get the cell center where it hit
        vec3 cell_center = hit_cell * cell_size;
        
        // get the intersection point
        vec3 pintersect = ro + rd * hit_nt.w;
        
        // store distance to border, to neighbor cell
        float bdist, ndist;
        
        // see if we hit top/bottom or side
        if (abs(hit_nt.z) > 0.0) {
            
            // was top/bottom
            bdist = hexDist(pintersect.xy - cell_center.xy);
            ndist = neighborDist(prev_cell, hit_cell, pintersect); 
            
        } else {
            
            // was side
            vec2 n = hit_nt.xy;
            bdist = abs(fract(pintersect.z/cell_height)-0.5)*cell_height;
                    
            vec2 p = pintersect.xy - cell_center.xy;
            p -= n * dot(p, n);
            bdist = min(bdist, abs(length(p) - 0.5/hex_factor));
            
            ndist = neighborDist(prev_cell, hit_cell, pintersect);
            ndist = min(ndist, vertEdgeDist(prev_cell, hit_cell, pintersect));

        }
        
        // default case: assume shadow - note for "realism" we would set 0.0 here
        float diffuse = 0.05;
        
        // A distant point light, so it's almost directional, but it still has a
        // slight point light feel... if that makes any sense. :)
        vec3 light_dir = normalize(lp - pintersect);
        
        // see if on lit side
        if (dot(hit_nt.xyz, light_dir) > 0.0) {
            
            // shadow ray
            vec4 shadow_nt;
            raytrace(pintersect + 0.001*hit_nt.xyz, light_dir, 
                     shadow_nt, prev_cell, hit_cell);
            
            // full light if shadow ray missed
            if (shadow_nt.w < 0.0) { diffuse = 1.0; }

            
        }
        
        // shade the hit point
        color = shade(ro, rd, hit_nt, bdist, ndist, diffuse);

        
    } 
    
    color = mix(color, sk, smoothstep(0., .95, hit_nt.w*.6/100.));
    
	return color;
	
}

// Function 965
vec3 getNormal(in vec3 p) {
    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)).x - mapScene(p - vec3(0.001, 0.0, 0.0)).x,
                          mapScene(p + vec3(0.0, 0.001, 0.0)).x - mapScene(p - vec3(0.0, 0.001, 0.0)).x,
                          mapScene(p + vec3(0.0, 0.0, 0.001)).x - mapScene(p - vec3(0.0, 0.0, 0.001)).x));
}

// Function 966
vec3 calcNormal( in vec3 pos )
{
    vec3  eps = vec3(precis,0.0,0.0);
    vec3 nor;
    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;
    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;
    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;
    return normalize(nor);
}

// Function 967
vec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {
    if (material == 1) {
        return vec3(0.2);
    }
    else if (material == 2) {
        return vec3(0.0);
    }
    else if (material == 3) {
        return vec3(0.2);
    }
    else {
        return vec3(0.0, 1e9, 0.0);
    }
}

// Function 968
float IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)
{
	// Use dot product along line to find closest point on line
	vec3 eyeVec2 = normalize(posB-posA);
	float dp = dot(eyeVec2, pos - posA);
	vec3 pointOnLine = eyeVec2 * dp + posA;
	// Clamp that point to line end points if outside
	//if ((dp - radius) < 0) pointOnLine = posA;
	//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;
	// Distance formula from that point to sphere center, compare with radius.
	float distance = length(pointOnLine - pos);
	float ac = radius*radius - distance*distance;
	float rightLen = 0.0;
	if (ac >= 0.0) rightLen = sqrt(ac);
	intersectA2 = pointOnLine - eyeVec2 * rightLen;
	intersectB2 = pointOnLine + eyeVec2 * rightLen;
	distFromSphere = distance - radius;
	if (distance <= radius) return 1.0;
	return 0.0;
}

// Function 969
float rayMarch(in vec3 ro, in vec3 rd) {
  float mn=0., mx=300.;
  float thr = 1e-6;

  float d=mn;
  for(int i=0;i<100;i++) {
    vec3 pos = ro + rd*d;
    float tmp = map(pos);
    if(tmp<thr || mx<tmp) break;
    d += tmp * 0.3;
  }
  return d;
}

// Function 970
vec3 getRay(vec2 uv){
   uv = (uv * 2.0 - 1.0)* vec2(resolution.x / resolution.y, 1.0);
	vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));	
    if(resolution.y < 400.0) return proj;
	vec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;
    return ray;
}

// Function 971
vec3 getNormal(vec3 p)
{
	vec3 normal;
    vec3 ep = vec3(eps,0.0,0.0);
    normal.x = scene(p+ep.xyz) - scene(p-ep.xyz);
    normal.y = scene(p+ep.yxz) - scene(p-ep.yxz);
    normal.z = scene(p+ep.yzx) - scene(p-ep.yzx);
    return normalize(normal);
}

// Function 972
vec3 normal(vec3 p) {
	vec3 e=vec3(0.01,-0.01,0.0);
	return normalize( vec3(	e.xyy*DE(p+e.xyy).x +	e.yyx*DE(p+e.yyx).x +	e.yxy*DE(p+e.yxy).x +	e.xxx*DE(p+e.xxx).x));
}

// Function 973
float get_ray_elevation( vec3 c, Ray view_ray ) { return get_ray_elevation( c, view_ray.o, view_ray.d ); }

// Function 974
float cubic_bezier_normal_iteration2(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){
	//horner's method
	vec2 a_2=a2+t*a3;
	vec2 a_1=a1+t*a_2;
	vec2 b_2=a_2+t*a3;

	vec2 uv_to_p=a0+t*a_1;
	vec2 tang=a_1+t*b_2;
	vec2 snd_drv=2.*(b_2+t*a3);

	float l_tang=dot(tang,tang);

	float fac=dot(tang,snd_drv)/(2.*l_tang);
	float d=-dot(tang,uv_to_p);

	float t2=d/(l_tang+fac*d);

	return t+factor*t2;
}

// Function 975
float rayMarch(vec3 ro,vec3 rd, bool setMat){
    float tot = 0.;
    float dst = 0.;
    for(int i = 0; i < MAX_DST; i++){
        vec3 p = ro + rd*tot;
        dst = map(p,setMat);
        tot+=dst;
        if(dst<EPSI||tot>float(MAX_DST)){
        	tot = float(i)/float(MAX_DST);
            break;
        }
     }
    if(dst>EPSI && setMat){//sky
    	mat = 1;
    }
	return tot;
}

// Function 976
vec2 ReflectOffSurf(vec2 p, vec2 r){
	float d=max(DE(p),0.001);
	vec2 v=vec2(d,0.0);
	vec2 N=normalize(vec2(DE(p+v.xy)-DE(p-v.xy),DE(p+v.yx)-DE(p-v.yx)));
	d=clamp(sqrt(d)*1.1,0.0,1.0);
	r=mix(reflect(r,N)*clamp(0.5-0.5*dot(r,N),0.0,1.0),r*d,d);
	return r;
}

// Function 977
vec3 NormalSinPowWarpTest(vec3 pos, float freq, float amp, float power) {
	return NormalSinPowWarpOffset(pos, GetOffset(), freq, amp, power);
}

// Function 978
vec3 calcNormal( in vec3 pos )
{
#if 0
    vec3 eps = vec3(0.005,0.0,0.0);
	return normalize( vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,
                            map(pos+eps.yxy).x - map(pos-eps.yxy).x,
                            map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
#else   
    vec2 e = vec2(-1.0,1.0) * 0.005;   
	return normalize( e.yxx*map( pos + e.yxx ).x + 
					  e.xxy*map( pos + e.xxy ).x + 
					  e.xyx*map( pos + e.xyx ).x + 
					  e.yyy*map( pos + e.yyy ).x );    
#endif
    
}

// Function 979
bool IntersectRaySphere(const Ray ray, const Sphere sphere, out float tmin, out float tmax)
{
	vec3 CO = ray.m_Origin - sphere.m_Center;

	float a = dot(ray.m_Direction,ray.m_Direction);
	float b = 2.0 * dot(CO,ray.m_Direction);
	float c = dot(CO,CO) - (sphere.m_Radius * sphere.m_Radius);

	float discriminant = b * b - 4.0 * a * c;
	if (discriminant < 0.0)
		return false;

	tmin = (-b - sqrt(discriminant)) / (2.0 * a);
	tmax = (-b + sqrt(discriminant)) / (2.0 * a);
	if (tmin > tmax)
	{
		float temp = tmin;
		tmin = tmax;
		tmax = temp;
	}

	return true;
}

// Function 980
vec3 Map_GetNormal( vec3 pos )
{
    const float delta = 0.01;
    
    const int normalOctaves = 8;
    vec3 normal = vec3(1.0f, 0.0f, 1.0f) * Map_GetHeight( pos.xz, normalOctaves, true ).height
           + Map_GetHeight( pos.xz + vec2(delta, 0.0f), normalOctaves, true ).height * vec3(-1.0f, 0.0, 0.0)
        + Map_GetHeight( pos.xz + vec2(0.0f, delta), normalOctaves, true ).height * vec3(0.0f, 0.0, -1.0) + vec3(0.0, delta, 0.0);
    
    return normalize( normal );
}

// Function 981
vec2 ray_march(vec3 cam_pos, vec3 cam_dir){
    float t_near = 0.0;
    for(int i = 0; i < STEP_MAX; i++){
        vec3 p = cam_pos + cam_dir * t_near; // t_near is how far we can go along ray without hitting object
        vec2 dist = scene_sdf(p);
        t_near += dist.x;
        // Check if we missed entirely or hit something
        // > DIST_MAX then we missed all objects, less than EPSILON, we hit an object 
        if(t_near > DIST_MAX){ 
            return vec2(-1., -1);
        }else if(dist.x < EPSILON){
            return vec2(t_near, dist.y); 
        }
    }
    
    return vec2(-1., -1);
}

// Function 982
vec3 raymarch( vec3 ro, vec3 rd, const vec2 nf, const float eps ) {
    glowAcc = vec2(999.);
    vec3 p = ro + rd * nf.x;
    float l = 0.;
    for(int i=0; i<128; i++) {
		float d = worldSafe(p);
        l += d;
        p += rd * d;
        
        if(d < eps || l > nf.y)
            break;
    }
    
    return p;
}

// Function 983
RayIntersection CastRay(const Ray r, const float max_dst)
{
    RayIntersection o;
    o.ray         = r;
 	o.distance    = max_dst;
    o.shadow      = max_dst;
    o.shape.type  = NO_SHAPE;
    
    int i = 0;
    float travelDist = 0.0f;
    RayIntersection tmpRI;
    
    while (travelDist<max_dst && i<MAX_ITERATIONS)
    {
        i++;

		tmpRI = GetNearestShape(r.o + r.d*travelDist);
        
        travelDist += tmpRI.distance;
        
        // Soft shadows
        o.shadow = min(o.shadow, SOFT_SHADOWS_C*tmpRI.distance/travelDist);
        
        if (tmpRI.distance < EPSILON)
        { // We collided
            o.pos      = r.o + r.d*travelDist;
            o.shape    = tmpRI.shape;
            o.distance = travelDist;
            if (o.shape.normal == vec4(0))
            { // Avoid computing the normals of shapes that already have them
              // (such as planes)
            	o.shape.normal = vec4(ComputeNormals(o.pos), 1);
            }
            break;
        }
    }
    
    if (o.shape.type == FLOOR_PLANE)
    {
    	o.shape.color = vec4(vec3(CheckersGradBox(o.pos.xz*.5)*.5 + .25), 1);
        o.shape.glossy *= o.shape.color.r;
    }

    o.numIt = i;
    return o;
}

// Function 984
vec3 GetNormal( vec3 pos CACHEARG )
{
    float val = BlobDist( pos CACHE );
    return normalize( vec3( BlobDist( pos + vec3( NORMALEPSILON, 0.0, 0.0 ) CACHE ), BlobDist( pos + vec3( 0.0, NORMALEPSILON, 0.0 ) CACHE ), BlobDist( pos + vec3( 0.0, 0.0, NORMALEPSILON ) CACHE ) ) - vec3( val ) );
}

// Function 985
vec2 ct_vfield_normal(
    in vec2 p,
    float npow
){
    vec2 g = vec2(0.0, 0.0);
    
    const int imax = CT_N;
    
    float abase = 6.28318 / float(imax);
    float rbase = 1. / float(imax);
    
    for (int i = 0; i < imax * 2; ++i)
    {
        float angle = abase * float(i);
        float radius = rbase * float(i);
        
        angle += sin(iTime * .5) * 3.1459;
       
        vec2 vp = vec2(
            cos(angle) * radius * (1. + abs(sin(iTime))), 
            sin(angle) * radius * (1. + abs(cos(iTime)))
        );
        
        float vm = -1.;
        
        vec2 dif = vp - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1];
        float mass = pow(sum, npow);
        
      	g[0] = g[0] + vm * dif[0] / mass;
      	g[1] = g[1] + vm * dif[1] / mass;
    }
    
    return normalize(g);
}

// Function 986
vec3 calcNormal( in vec3 pos )
{
#if 0    
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*0.001).x;
    }
    return normalize(n);
#endif    
}

// Function 987
vec3 normal(const in vec3 p){  
    vec2 e = vec2(-1., 1.)*0.005;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );}

// Function 988
vec3 normal(vec3 p)
{
    return normalize(vec3(
        dist(p + vec3(EPS, 0.0, 0.0) - vec3(EPS, 0.0, 0.0)),
        dist(p + vec3(0.0, EPS, 0.0) - vec3(0.0, EPS, 0.0)),
        dist(p + vec3(0.0, 0.0, EPS) - vec3(0.0, 0.0, EPS))
    ));
}

// Function 989
float raymarch(vec3 ori, vec3 dir) {
    float t = 0.;
    for(int i = 0; i < 256; i++) {
    	float dst = dstScene(ori+dir*t);
        if(dst < .001 || t > 256.)
            break;
        t += dst * .75;
    }
    return t;
}

// Function 990
vec3 camray(vec2 uv)
{
	uv -= vec2(0.5);
	uv.x *= (iResolution.x/iResolution.y);
	vec2 vv = uv*0.8;
	return normalize( camdir + camX*vv.x + camY*vv.y );
}

// Function 991
vec3 getNormal( vec3 p ) {
    return normalize( getDistance( p ) - 
        getDistances( p - EPZ.yxx, p - EPZ.xyx, p - EPZ.xxy )
    );
}

// Function 992
vec3 calcNormal( in vec3 pos, float e, vec3 dir)
{
    vec3 eps = vec3(e,0.0,0.0);

    return normalize(vec3(
           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,
           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,
           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));
}

// Function 993
vec3 calculateFloorNormal(const vec3 base ) {
	vec3 A = intersectFloor(base);
	vec3 B = intersectFloor(vec3(base.x + NORM_SEARCH_DIST, base.yz));
	vec3 C = intersectFloor(vec3(base.xy, base.z + NORM_SEARCH_DIST));
	return normalize(cross(C - A, B - A));
}

// Function 994
vec3 calcNormal( in vec3 pos, in float e )
{
    vec3 eps = vec3(e,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 995
vec4 octreeray(vec3 ro, vec3 rd, float maxdist,
               out vec3 lro, out vec3 fro,
               out float size, out float proxim) {
    size = pow(tree,float(-mindetail));
    lro = mod(ro,size);
    fro = ro-lro;
    vec3 srd = sign(rd);
    vec3 ird = 1.0/max(rd*srd,0.001);
    vec3 mask;
    bool exitoct = false;
    int recursions = mindetail;
    float dist = 0.0;
    int i;
    float edge = 1.0;
    proxim = 1.0;
    float lastsize = size;
    vec3 hit = voxel(lro, rd, ird, size);
    
    //the octree traverser loop
    //each iteration i either:
    // - check if i need to go up a level
    // - check if i need to go down a level
    // - check if i hit a cube
    // - go one step forward if cube is empty
    for (i = 0; i < steps; i++)
    {
        if (dist > maxdist) break;
        int voxelstate = getvoxel(fro*size,size);
        //int voxelstate = getvoxel(floor(fro/size+0.5)*size,size);
        
        //i go up a level
        if (exitoct)
        {
            vec3 newfro = floor(fro/size/tree+0.5/tree)*size*tree;
            
            lro += fro-newfro;
            fro = newfro;
            
            recursions--;
            size *= tree;
            exitoct = (recursions > mindetail) && (((mod(dot(fro/size,mask)+0.5,tree)-tree*0.5)*dot(srd,mask)) < -tree*0.5+0.75);
            
            if (!exitoct) {
            	hit = voxel(lro, rd, ird, size);
            }
        }
        //subdivide
        else if(voxelstate == 1&&recursions<maxdetail)
        {
            
            recursions++;
            size /= tree;
            
            vec3 mask2 = clamp(floor(lro/size),0.0,tree-1.0);
            fro += mask2*size;
            lro -= mask2*size;
            hit = voxel(lro, rd, ird, size);
        }
        //move forward
        else if (voxelstate == 0 || (voxelstate == 1 && recursions == maxdetail))
        {
#ifdef softshadow
            if (lastsize >= size) {
                lastsize = size;
            } else {
                proxim = lastsize;
            }
#endif
            
            //raycast and find distance to nearest voxel surface in ray direction
            if (hit.x < min(hit.y,hit.z)) {
                mask = vec3(1,0,0);
            } else if (hit.y < hit.z) {
                mask = vec3(0,1,0);
            } else {
                mask = vec3(0,0,1);
            }
            float len = dot(hit,mask);
            
            //moving forward in ray direction
            lro += rd*len-mask*srd*size;
            dist += len;
            hit -= len;
            hit += mask*ird*size;
            
            vec3 newfro = fro+mask*srd*size;
            //this line is a bit ugly, this checks if i've gone out of octree bounds
            exitoct = (floor(newfro/size/tree+0.5/tree)!=floor(fro/size/tree+0.5/tree))&&(recursions>0);
            fro = newfro;
        }
        else
        {
            break;
        }
    }
    return vec4(dist, mask);
}

// Function 996
vec3 raymarch_main_normal(vec3 _p, float eps, float t)
{
    vec3 n;
    n.y = raymarch_main_scene_normals(_p, t).x;
    n.x = raymarch_main_scene_normals(_p+vec3(eps, 0., 0.), t).x-n.y;
    n.z = raymarch_main_scene_normals(_p+vec3(0., 0., eps), t).x-n.y;
    n.y = raymarch_main_scene_normals(_p+vec3(0., eps, 0.), t).x-n.y;
    return normalize(n);
}

// Function 997
vec3 ray_position(in Ray ray, float t) {
    return ray.origin + ray.direction * t;
}

// Function 998
float FlyerRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = FlyerDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0002 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 999
vec3 normal (in vec3 p)
{
    vec2 e = vec2(.0001, .0);
    float d = scene (p).d;
    vec3 n = vec3 (scene (p + e.xyy).d - d,
                   scene (p + e.yxy).d - d,
                   scene (p + e.yyx).d - d);
    return normalize(n);
}

// Function 1000
float refraction( in vec3 i, in vec3 n, in float ior, out vec3 r )
{
    float r_mat = step( 1., ior ); // refraction index of 1 is vacuum, less than that is impossible
    ior = max( 1., ior );
    
    float c1 = dot( i, n );
    
    float _in = step( 0., c1 ); // if c1 < 0, we are going from the outside (air) to inside
    n = mix( n, -n, _in );
    float r1 = mix( 1., ior, _in );
    float r2 = mix( ior, 1., _in );
    c1 = mix( -c1, c1, _in );
    float r_idx = r1 / r2;
    
    float c2 = 1. - r_idx * r_idx * ( 1. - c1 * c1 );
    float valid = step( 0., c2 ); // careful with the negative discriminant
    
    
    r = r_idx * i + ( r_idx * c1 - sqrt( max( 0., c2 ) )) * n;
    //r = r_idx * ( i + n * c1 ) - sqrt( max( 0., c2 ) ) * n;
    
    float reflect_prob = min( valid, schlick( mix( c1, ior * c1, _in ), r_idx ) );
    //float reflect_prob = 1.;
    
    //float p = 1.;
    float p = hash( c1 );
    
    
    return ( 1.- step( p, reflect_prob ) ) * r_mat;
}

// Function 1001
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.8,0.8,-0.8), rd, vec3(4.0,4.0,4.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<120 && t<tmax; i++ )
        {
            vec2 h = map( ro+rd*t );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec2(t,h.y); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 1002
float intersectionSphereRay(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection){
    vec3 oc = rayOrigin - center;
    float a = dot(rayDirection, rayDirection);
    float b = 2.0 * dot(oc, rayDirection);
    float c = dot(oc,oc) - radius*radius;
    float discriminant = b*b - 4.0*a*c;
    if(discriminant < 0.0){
        return -1.0;
    }
    else{
        return (-b - sqrt(discriminant)) / (2.0*a);
    }
}

// Function 1003
vec3 normals(vec3 p){
  vec3 eps = vec3(E, 0.0, 0.0);
  return normalize(vec3(
    scene(p+eps.xyy) - scene(p-eps.xyy),
    scene(p+eps.yxy) - scene(p-eps.yxy),
    scene(p+eps.yyx) - scene(p-eps.yyx)
  ));
}

// Function 1004
Refracted refract0(vec3 v,vec3 n, float ni_nt)
{
    Refracted ref;
    
    v = normalize(v);
    float dt = dot(v, n);
    float disc = 1.0 - ni_nt*ni_nt * (1.0 - dt*dt);
    
    if(disc > 0.0){
        ref.direction = ni_nt * (v - n*dt) - n*sqrt(disc);
        ref.did = true;
    }
    else
    {
        ref.did = false;
    }
    
    return ref;
    	
}

// Function 1005
bool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 1006
void castRay(
    inout vec3 pRay, inout vec3 nvRay, inout int rayFace,
    out vec4 cFinal, out float glowDsq, out float shadowAmount,
    out float dHit, out int matHit, out vec3 nvHit
) {
    float tRemaining = T_MAX;
    cFinal = vec4(0.0);
    glowDsq = 1e5;
    shadowAmount = 0.0;

    for (int i=0; i<100; i++) {
        bool finished;

        if (rayFace == 0) {
            traverseFace0(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);
        } else if (rayFace == 1) {
            traverseFace1(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);
        } else if (rayFace == 2) {
            traverseFace2(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);
        } else {
            traverseFace3(false, pRay, nvRay, tRemaining, cFinal, glowDsq, shadowAmount, finished, matHit, nvHit, rayFace);
        }

        if (finished) {
            break;
        }
    }

    dHit = T_MAX - tRemaining;
}

// Function 1007
float approx_air_column_density_ratio_along_2d_ray_for_curved_world(
    float x_start, // distance along path from closest approach at which we start the raymarch
    float x_stop,  // distance along path from closest approach at which we stop the raymarch
    float z2,      // distance at closest approach, squared
    float r,       // radius of the planet
    float H        // scale height of the planet's atmosphere
){
    
    // GUIDE TO VARIABLE NAMES:
    //  "x*" distance along the ray from closest approach
    //  "z*" distance from the center of the world at closest approach
    //  "r*" distance ("radius") from the center of the world
    //  "h*" distance ("height") from the surface of the world
    //  "*b" variable at which the slope and intercept of the height approximation is sampled
    //  "*0" variable at which the surface of the world occurs
    //  "*1" variable at which the top of the atmosphere occurs
    //  "*2" the square of a variable
    //  "d*dx" a derivative, a rate of change over distance along the ray

    float a = 0.45;
    float b = 0.45;

    float x0 = sqrt(max(r *r -z2, 0.));
    // if ray is obstructed
    if (x_start < x0 && -x0 < x_stop && z2 < r*r)
    {
        // return ludicrously big number to represent obstruction
        return 1e20;
    }
    
    float r1      = r + 6.*H;
    float x1      = sqrt(max(r1*r1-z2, 0.));
    float xb      = x0+(x1-x0)*b;
    float rb2     = xb*xb + z2;
    float rb      = sqrt(rb2);
    float d2hdx2  = z2 / sqrt(rb2*rb2*rb2);
    float dhdx    = xb / rb; 
    float hb      = rb - r;
    float dx0     = x0          -xb;
    float dx_stop = abs(x_stop )-xb;
    float dx_start= abs(x_start)-xb;
    float h0      = (0.5 * a * d2hdx2 * dx0      + dhdx) * dx0      + hb;
    float h_stop  = (0.5 * a * d2hdx2 * dx_stop  + dhdx) * dx_stop  + hb;
    float h_start = (0.5 * a * d2hdx2 * dx_start + dhdx) * dx_start + hb;

    float rho0  = exp(-h0/H);
    float sigma = 
        sign(x_stop ) * max(H/dhdx * (rho0 - exp(-h_stop /H)), 0.) 
      - sign(x_start) * max(H/dhdx * (rho0 - exp(-h_start/H)), 0.);

    // NOTE: we clamp the result to prevent the generation of inifinities and nans, 
    // which can cause graphical artifacts.
    return min(abs(sigma),1e20);
}

// Function 1008
float rayleighPhase(vec3 p, vec3 lp) {
    return 0.375 * (1.0 + pow(dot(p, lp), 2.0));
}

// Function 1009
float rayleigh_phase(float cos2) {
    return 0.75 * (1.0 + cos2);
}

// Function 1010
vec3 blendNormals(in vec3 norm1, in vec3 norm2)
{
	return normalize(vec3(norm1.xy + norm2.xy, norm1.z));
}

// Function 1011
float raymarchTerrain( in vec3 ro, in vec3 rd )
{
	float maxd = 50.0;
	float precis = 0.001;
    float h = 1.0;
    float t = 0.0;
    for( int i=0; i<80; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;
        t += h;
	    h = mapTerrain( ro+rd*t );
    }

    if( t>maxd ) t=-1.0;
    return t;
}

// Function 1012
vec3 raymarch_flopine(vec3 ro, vec3 rd, vec2 uv)
{
	vec3 col;
	float dither = random(uv);
	float t = 0.;
	vec3 p;// = ro;
	for (float i = 0.; i < 80.; i++)
	{
		p = ro + t * rd;
		float d = SDF(p);
		if (d < 0.001)
		{
			col = vec3(i / 80.);
			break;
		}
		d *= 1. + dither * 0.1;

		t += d * .8;
	}

	float g2_force = mix(0., 0.8, smoothstep(10., 14., time) * (1. - smoothstep(116., 120., time)));
	col += g1 * vec3(0.2, 0.4, 0.);
	col += (g2* g2_force) * vec3(0., 0.5, 0.5);
	col = mix(col, vec3(0., 0.3, 0.4), 1. - exp(-0.001*t*t));

	return col;
}

// Function 1013
vec2 normalizeScreenCoords(vec2 screenCoord)
{
    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);
    result.x *= iResolution.x/iResolution.y;
    return result;
}

// Function 1014
vec2 getScreenspaceUvFromRayDirectionWS(
    vec3 rayDirectionWS,
	vec3 cameraForwardWS,
	vec3 cameraUpWS,
	vec3 cameraRightWS,
	float aspectRatio)
{
    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;
    // project rayDirectionWs onto camera forward
    float projDist                 = dot(rayDirectionWS, cameraForwardWS);
    vec3  eyeToPosOnCameraPlaneWS = (rayDirectionWS / projDist) * kCameraPlaneDist;
    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;

    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);
    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);
    
    xDist /= aspectRatio;
    xDist = xDist * 0.5 + 0.5;
    yDist = yDist * 0.5 + 0.5;

    return vec2(xDist, yDist);
}

// Function 1015
float raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    vec3 ce = ro - spherePos;
    float b = dot(rd, ce);
    float c = dot(ce, ce) - (sphereRadius * sphereRadius);
    float t = b * b - c;
    if (t > tmin) {
        t = -b - sqrt(t);
        if (t < tmax)
            return t;
    }
    return -1.0;
}

// Function 1016
vec3 normalmap(vec2 p) {
    vec2 e = vec2(1e-3, 0);
    return normalize(vec3(
        heightmap(p - e.xy) - heightmap(p + e.xy),
        heightmap(p - e.yx) - heightmap(p + e.yx),
        2. * e.x));
}

// Function 1017
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    for(int i=0; i<7; i++) {
        CHECK_OBJ(objects[i]);
    }
    return ( nearestDist < 1000.0 );
}

// Function 1018
vec2 castRay( in vec4 ro, in vec4 rd, in float maxd ) {
	float precis = 0.0005;
    float h=precis*2.0;
    float t = 2.0;
	vec2 res;
    for( int i=0; i<RAY_STEP; i++ ) {
        if (abs(h)<precis || t>maxd ) break;
        t += h;
        res = map( ro+rd*t );
        h = res.x;
    }
    return vec2( t, t>=maxd ? -1. : res.y );
}

// Function 1019
ray castRayR(vec3 ro , vec3 rd,float imax){
    
    float i = 0.002;
    vec2 dat;
    bool pass = false;
    float pre = 1.0;
    
    for(int n = 0; n < 512; n++){
        
        dat.xy = map(ro+rd*i);
        
        
        if(dat.x < 0.002 && dat.y > -0.5)return ray(vec3(ro+rd*i),vec3(rd),dat.y);
        
        if(i > imax)return ray(vec3(ro+rd*i),vec3(rd),-1.1);
        
        if(pre < 0.0 && dat.x > 0.0){
            pass=true;
            ro=ro+rd*i;
            rd=normalize(rd+calcNormal(ro)*1.0/1.5);
            i=0.000;
        }
        
        if(pre > 0.0 && dat.x < 0.0){
            pass=false;
            ro=ro+rd*i;
            rd=normalize(rd-calcNormal(ro)*1.5);
            i=0.000;
        }
        
        i+=max(abs(dat.x),0.002);
        pre=dat.x;
    }
    
    return ray(vec3(ro+rd*i),vec3(rd),-1.1);
}

// Function 1020
vec3 calcNormal( in vec3 pos )
{
    const float ep = 0.002;
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*ep ).x + 
					  e.yyx*map( pos + e.yyx*ep ).x + 
					  e.yxy*map( pos + e.yxy*ep ).x + 
					  e.xxx*map( pos + e.xxx*ep ).x );
}

// Function 1021
vec3 NormalBlend_PartialDerivatives(vec3 n1, vec3 n2)
{	
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;
    
    return normalize(vec3(n1.xy*n2.z + n2.xy*n1.z, n1.z*n2.z));
}

// Function 1022
rayCastResults rayCast(vec3 rayPos, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {
	   
      
    bool hit = false;
    voxel vox;
    vox.id=0.;
    float waterDist=0.;
    float fog=0.;   
    rayCastResults subRes;
    subRes.hit=false;

    vec3 raySign= sign(rayDir);
    vec3 rayInv = 1./rayDir;
    vec3 mapPos=floor(rayPos+raySign*0.001);
    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;
    vec3 mask=vec3(0.); 
    float t=0.;
    
	vec3 hitWater =getCachedVoxel( mapPos).id==12.? rayPos: vec3(0.);

        
    for (int i = 0; i < int( load(_rayLimit).r); i++) {

        if(i>0){
       		mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);
            vec3 mini = (mapPos-rayPos + 0.5 - 0.5*vec3(raySign))*rayInv;
            t = max ( mini.x, max ( mini.y, mini.z ) );
        }
		sideDist += mask *  raySign *rayInv;
        mapPos += mask *  raySign;
        
        if ( mapPos.z < 0. ) break;
        if ( mapPos.z >= heightLimit){
            if(rayDir.z > 0.)  break;
            
            //MAP RAY FROM ABOVE
            float nstep= -((mapPos.z - heightLimit)*rayInv.z);
			mapPos +=  rayDir *nstep;
            sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) *rayInv;
            continue;
        }
                   
        vox = getVoxel( mapPos);
#ifdef SUBVOXEL        
        if(vox.shape!=0){ 
            //SUB VOXEL
            vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;
			float t = max ( mini.x, max ( mini.y, mini.z ) );
    		vec3 hitVoxelPos = rayDir * t + rayPos;
            
             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,vox.rotation);
            if(subRes.hit) { 		
       		 	hit = true; 
                break;
            }else {vox.id=0.;hit = false;}
        }
#endif        
        
        if(vox.id==12.){
        	//ENTERING WATER
            if(hitWater.z<1.) {
                hitWater=mapPos;
                // deviate ray xy if intercept water
                vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;
			    float t = max ( mini.x, max ( mini.y, mini.z ) );
    			vec3 endRayPos = rayDir * t + rayPos;
 				rayDir.xy*=0.8+.1*snoise(vec3(endRayPos.xy,iTime));
                rayDir=normalize(rayDir);rayInv=1./rayDir;
                sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) /rayDir;
                
            }
        	
            vox.id=0.;
            continue;
        }
        if( vox.id !=0. && vox.id!=26.){
        	hit = true; 
           	break;
        } 
        else if(hitWater.z>0.){
        	//HANDLE RAY OUTSIDE FROM THE WATER
            hitWater =vec3(0.);
            waterDist +=length(hitWater-mapPos) ;
            
            // deviate ray xy 
			vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;
			float t = max ( mini.x, max ( mini.y, mini.z ) );
    		vec3 endRayPos = rayDir * t + rayPos;          
            rayDir.xy*=1.2+.1*snoise(vec3(endRayPos.xy,iTime));
            rayDir=normalize(rayDir);rayInv=1./rayDir;
            sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) /rayDir;
            

        }
        
        //FOG & CLOUDS
        float fogd= fogDensity(mapPos)/4.;
        if(fogd >4. && rayType!=2) break;        
        fog += fogDensity(mapPos)/4.;
        
        
        //NO HIT
        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;

	}
    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);      
    
    
    if(load(_stats).r>0.5){
    	vec4 range2= calcLoadRange(rayPos.xy,iResolution.xy,1.,load(_loadDistLimit).r);
    	if(hit && inRange(mapPos.xy, range)  && !inRange(mapPos.xy, range2)) vox.id = 8.;    
    }
        
    if(!hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){
        if(mapPos.z>55.) {vox.id = 0.; hit=false;}
        else { vox.id=3.; hit = true;}
    }
    
    vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;
	 t = max ( mini.x, max ( mini.y, mini.z ) );
    
  
    
    rayCastResults res;
    res.hit = hit;

    res.mapPos = mapPos;
    res.normal = -raySign * mask;
    res.rayPos = rayDir * t + rayPos;
    res.dist = length(rayPos - res.rayPos);
    res.vox=vox;
    res.water =waterDist;
    res.fog=fog;
    
    if(subRes.hit){
        res.rayPos = rayDir * (t + subRes.dist) + rayPos;
       	res.normal=subRes.normal;
        mask=subRes.normal.xyz;
        res.dist = length(rayPos - res.rayPos);
        //res.vox=subRes.vox;
        
    }
    
    //vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;
   	vec2 uv;
    vec3 tangent1;
    vec3 tangent2;
      
                   
    if (abs(mask.x) > 0.) {
        uv = fract(res.rayPos.yz);
        tangent1 = vec3(0,1,0);
        tangent2 = vec3(0,0,1);
    }
    else if (abs(mask.y) > 0.) {
        uv = fract(res.rayPos.xz);
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,0,1);
    }
    else {
        uv = fract(res.rayPos.yx);
        tangent1 = vec3(0,1,0);
        tangent2 = vec3(1,0,0);
    }
    
    res.uv = uv ;
    res.tangent = tangent1;
    res.bitangent = tangent2;
    
    res.rayPos -= rayDir * t /100.; //trick to avoid wrong shadow if hitpoint inside cube
    return res;
}

// Function 1023
vec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)
{
    vec2 xy = pixID - (viewSizes / 2.0);
    float z = viewSizes.y / tan(fovRads / 2.0);
    return normalize(vec3(xy, z));
}

// Function 1024
rayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {
        vec3 mapPos = floor(rayPos);
        vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
        vec3 rayStep = sign(rayDir);
        vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
        vec3 mask;
        bool hit = false;
        for (int i = 0; i <= MAX_PICK_DISTANCE*3; i++) {
            mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);
            sideDist += vec3(mask) * deltaDist;
            mapPos += vec3(mask) * rayStep;

            if (mapPos.z < 0. || mapPos.z >= heightLimit) break;
            voxel vox = getCachedVoxel(mapPos - offset);
            if (vox.id!= 0. && vox.id!= 12.) { 
                hit = true; 
                break;
            }

        }
        vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;


        rayCastResults res;
        res.hit = hit;

        res.mapPos = mapPos;
        res.normal = -rayStep * mask;
        res.rayPos = endRayPos;
        res.dist = length(rayPos - endRayPos);
        return res;
    }

// Function 1025
vec3 GetNormalAtSurfacePoint(vec3 P, RoundBox box)
{
	P = WorldToLocal(P, box);
	if (box.roundRadius == 0.0) {
		vec3 V = P/box.extent;
		vec3 A = abs(V);
		float Amax = max3(A);
		vec3 N = vec3(0);
		if      (Amax == A.x) N.x = sign(V.x);
		else if (Amax == A.y) N.y = sign(V.y);
		else                  N.z = sign(V.z);
		return N;
	} else {
		vec3 E = box.extent - box.roundRadius;
		return normalize(P - clamp(P, -E, E));
	}
}

// Function 1026
vec3 CalcNormal(vec3 p)
{
	vec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;
    return normalize( e.xyy * SdScene( p + e.xyy ).x + 
					  e.yyx * SdScene( p + e.yyx ).x + 
					  e.yxy * SdScene( p + e.yxy ).x + 
					  e.xxx * SdScene( p + e.xxx ).x );
}

// Function 1027
vec4 raymarch(vec3 org, vec3 dir)
{
	float d = 0.0, glow = 0.0, eps = 0.02;
	vec3  p = org;
	bool glowed = false;
	
	for(int i=0; i<64; i++)
	{
		d = scene(p) + eps;
		p += d * dir;
		if( d>eps )
		{
			if(flame(p) < .0)
				glowed=true;
			if(glowed)
       			glow = float(i)/64.;
		}
	}
	return vec4(p,glow);
}

// Function 1028
float RayMarch(vec3 ro, vec3 rd){
    // distance from origin
    float dO=0.;
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO*rd;
        
        // get distance to seam
        float ds = GetDist(p);
        //move origin to new point
        dO+=ds*.1;
        if(ds < SURFACE_DIST || dO > MAX_DIST){
            break;
        }
    }
    return dO;
}

// Function 1029
void calcRayForPixel( in vec2 pix, in vec2 res, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (-res.xy + 2.0*pix) / res.y;
	
     // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 1030
vec3 GetNormal(vec3 p) {
	float d = GetScene(p).dist;
    vec2 e = vec2(.0001, 0);
    
    vec3 n = d - vec3(
        GetScene(p - e.xyy).dist,
        GetScene(p - e.yxy).dist,
        GetScene(p - e.yyx).dist);
    
    return normalize(n);
}

// Function 1031
vec3 raymarch(Ray inputray)
{
    const float exposure = 1e-2;
    const float gamma = 2.2;
    const float intensity = 100.0;
    vec3 ambient = vec3(0.2, 0.3, 0.6) *6.0* intensity / gamma;

    vec3 prevcolour = vec3(0.0, 0.0, 0.0);
    vec3 colour = vec3(0.0, 0.0, 0.0);
    vec3 mask = vec3(1.0, 1.0, 1.0);
    vec3 fresnel = vec3(1.0, 1.0, 1.0);
    
    Ray ray=inputray;
        
#ifdef LIGHTBULB    
    vec3 lightpos = g_light.pos;
#else
    vec3 lightpos = -g_light.pos*200000000000.0;	// 'directional'
#endif
    
    for (int i=0; i<REFLECT_ITERATIONS; i++)
    {
        Result result = raymarch_query(ray, 10.0);

        vec3 tolight = lightpos - result.pos;
        tolight = normalize(tolight);
                
        if (result.t > NOT_CLOSE)
        {
#ifdef LIGHTBULB            
            vec3 spotlight = drawlights(ray)*600.0;
#else            
            vec3 spotlight = vec3(1e4) * pow(clamp(dot(ray.dir, tolight),0.0,1.0), 75.0);
#endif //LIGHTBULB           
            
//          ambient = texture(iChannel1, ray.dir).xyz*100.0;
            ambient = mix(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.5), pow(abs(ray.dir.y), 0.5))*300.0;
                       
            colour += mask * (ambient + spotlight);                             
            break;
        }
        else
        {   
            //result.mat.colour.rgb *= noise(ray.pos);
			prevcolour = result.mat.colour.rgb;
            
            vec3 r0 = result.mat.colour.rgb * result.mat.specular;
            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);
            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);
            mask *= fresnel;            
            
            vec3 possiblelighting = clamp(dot(result.normal, tolight), 0.0, 1.0) * g_light.colour
                    * result.mat.colour.rgb * result.mat.diffuse
                    * (1.0 - fresnel) * mask / fresnel;
            
            if (length(possiblelighting) > 0.01f)
            {
                Ray shadowray = Ray(result.pos+result.normal*0.01, tolight);
                Result shadowresult = raymarch_query(shadowray, length(lightpos - result.pos)*0.9);
#ifdef SOFTSHADOWS                
                colour += possiblelighting*clamp(shadowresult.mint*4.0, 0.0, 1.0);
#else
                if (shadowresult.travelled >= length(lightpos - result.pos)*0.9)
                	colour += possiblelighting;
#endif
            }
            
            Ray reflectray;
            reflectray.pos = result.pos + result.normal*0.02f;
            reflectray.dir = reflect(ray.dir, result.normal);
            ray = reflectray;
        }
    }
        
    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    
    return colour;    
}

// Function 1032
bool RaySphere(in Ray r, in Sphere s, out float t0, out float t1)
{
	float3 l=s.p-r.p;
	float tc=dot(l,r.d);
	if(tc<0.0)
	{
		return false;
	};

	float d2=s.r*s.r+tc*tc-dot(l,l);

	if(d2<0.0)
	{
		return false;
	};

	float thc=sqrt(d2);
	t0=tc-thc;
	t1=tc+thc;
	return true;
}

// Function 1033
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.005,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1034
bool intersectRayHyperPlane(in Ray4 _ray, in HyperPlane _plane, in Object _object, out Ray4Result _rayResult )
{
    
    _rayResult.m_d = - ( dot(_ray.m_pos,_plane.m_normal) + _plane.m_d ) / ( dot (_ray.m_dir,_plane.m_normal) );
	_rayResult.m_pos = _ray.m_pos + _ray.m_dir * _rayResult.m_d;
	_rayResult.m_normal = _plane.m_normal;
	_rayResult.m_object = _object;
    return true;

}

// Function 1035
void raytraceHillTreeline(vec3 u,vec3 d,vec2 o,vec3 a,inout vec3 color,
                          inout float nearestD){a.x*=sign(d.x);
 float t=floor((u.z+d.z*(a.x-u.x)/d.x-o.x)/a.y)*a.y+a.y*.5+o.x;
 if(t>40.||t<-70.) return;//clipping planes
 if(t>.0)o.y+=t*a.z;//catches trees that otherwise float in the air
 raytraceTree(u,d,vec3(a.x,o.y,t),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,
              sin(t*.85+a.x),color,nearestD);}

// Function 1036
vec3 estimateNormal(vec3 p)
{
    return normalize(vec3(
        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),
        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),
        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1037
void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 px, out C_Ray ray)
{
    vec2 vUV = ( px / iResolution.xy );
    vec2 vViewCoord = vUV * 2.0 - 1.0;	

	vViewCoord.x *= iResolution.x / iResolution.y;
	vViewCoord.y *= -1.0;

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vWorldUp, vForwards));
    vec3 vUp = cross(vRight, vForwards);
    
	vViewCoord *= 0.5;
	
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);    
}

// Function 1038
vec3 calcNormal(in vec3 p) {
    vec2 e = vec2(eps.x, -eps.x); 
    return normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);;
}

// Function 1039
vec3 calcNormal( vec3 pos ) {
    vec3 eps = vec3(0.1,0.0,0.0);

	return normalize( vec3(
           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),
           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),
           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );
}

// Function 1040
float sdNormalArrow(vec3 p)
{
    if(_ambOccMarch == true || keyInfo(67.,2.) < 1.) return 1e10;

    vec3 n = getNormalExclusive(_cast);
    
    return min(
        sdCone_(p,_cast,_cast+n*.1,0.005,0.005),
        sdCone_(p,_cast+n*.1,_cast+n*.13,0.015,0.0)
    );
}

// Function 1041
vec3 mapUnderWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapUnderWater(pt).x;    
    normal.x = mapUnderWater(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapUnderWater(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 1042
float rayMarch( in vec3 origin, in vec3 direction ) {
    float total = .0;
    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {
        vec3 point = origin + direction * total;
                
        float current = sceneDistance( point );
        total += current;
        if ( total > RAY_MARCH_TOO_FAR || current < RAY_MARCH_CLOSE ) {
            break;
        }
    }
    return total;
}

// Function 1043
vec3 WaterNormal(vec3 pos,float rz){
    float EPSILON =rz*rz* 0.003;
    vec3 dx = vec3( EPSILON, 1.,1. );
    vec3 dz = vec3( 1.,1., EPSILON );
      
    vec3  normal = vec3( 1., 2., 1. );
    float bumpfactor = 0.4 * pow(2.-clamp((rz)/2000.,1.,2.),7.);//
    
    normal.x = -bumpfactor * (WaterMap(pos + dx) - WaterMap(pos-dx) ) / (3. * EPSILON);
    normal.z = -bumpfactor * (WaterMap(pos + dz) - WaterMap(pos-dz) ) / (3. * EPSILON);
    return normalize( normal ); 
}

// Function 1044
vec3 calcNormal( in vec3 pos, in float id )
{
    vec3 eps = vec3(0.01,0.0,0.0);

	return normalize( vec3(
           map2(pos+eps.xyy,id) - map2(pos-eps.xyy,id),
           map2(pos+eps.yxy,id) - map2(pos-eps.yxy,id),
           map2(pos+eps.yyx,id) - map2(pos-eps.yyx,id) ) );
}

// Function 1045
vec3 calcNormal( in vec3 pos, float e )
{
    vec3 eps = vec3(e,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1046
vec3 rayDirection(vec2 fragCoord){
    float zoom=1.2;
    vec2 offset=fragCoord/iResolution.xy-0.5;
    offset.y/=iResolution.x/iResolution.y;
    vec3 rawDir=vec3(offset/zoom,-1.);
    vec2 mouseAngles=iMouse.xy/iResolution.xy-0.5;
    vec4 qUpDown=quaternion(vec3(1,0,0),radians(45.+mouseAngles.y*30.0));
    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(-45.-mouseAngles.x*30.0));
    vec4 q=quaternionMultiply(qLeftRight,qUpDown);
    return normalize(rotation(q,rawDir));
}

// Function 1047
ray get_ray(in camera c, in vec2 uv, in float wavelength) {
	float theta = c.fov * 3.14/180.0;
    float h_height = tan(theta/2.0);
    float h_width = c.aspect * h_height;
    
    vec3 w = normalize(c.look_from - c.look_at);
    vec3 u = normalize(cross(c.up, w));
    vec3 v = cross(w, u);
    
    vec3 ll = c.look_from - h_width*u - h_height*v - w;
    vec3 horizontal = 2.0 * h_width*u;
    vec3 vertical = 2.0 * h_height*v;
    
    return ray(
        c.look_from, 
        normalize(ll + uv.x*horizontal + uv.y*vertical - c.look_from),
        wavelength
    );
}

// Function 1048
vec3 normal( vec3 pos, float eps, vec4 h )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*(map( pos + e.xyy ).x + h.x) +
					  e.yyx*(map( pos + e.yyx ).x + h.y) +
					  e.yxy*(map( pos + e.yxy ).x + h.z) +
					  e.xxx*(map( pos + e.xxx ).x + h.w) );
}

// Function 1049
vec3 calcNormal(vec3 pos, float eps) {
  const vec3 v1 = vec3( 1.0,-1.0,-1.0);
  const vec3 v2 = vec3(-1.0,-1.0, 1.0);
  const vec3 v3 = vec3(-1.0, 1.0,-1.0);
  const vec3 v4 = vec3( 1.0, 1.0, 1.0);

  return normalize( v1 * map( pos + v1*eps ) +
                    v2 * map( pos + v2*eps ) +
                    v3 * map( pos + v3*eps ) +
                    v4 * map( pos + v4*eps ) );
}

// Function 1050
vec3 calcNormal(vec3 p, float t) {
	float d = .01 * t * .33;
	vec2 e = vec2(1, -1) * .5773 * d;
	return normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);
}

// Function 1051
vec3 NetXYToRayDir(vec2 p){
    vec2 major = floor(p/1024.);
    vec2 minor = 1024.-mod(p,vec2(1024.));
    
    int face=-1;
    if(major==vec2(0,1)){         face = 0;    
    } else if(major==vec2(1,1)){  face = 2;    
    } else if(major==vec2(2,1)){  face = 3;    
    } else if(major==vec2(3,1)){  face = 5;    
    } else if(major==vec2(1,0)){  face = 4;    
    } else if(major==vec2(1,2)){  face = 1;
    }
    vec2 xy = minor - .5;
    return XYFaceToRayDir(ivec3(xy,face));
}

// Function 1052
float rayCastSphere( vec3 center, float radius, vec3 p, vec3 v )
{
	vec3 L = center - p;
    float tca = dot(L, v);
	
    if (tca < 0.0) 
	{
		return CAST_DISTANCE;
	}
	
	float radius2 = radius * radius;
    float d2 = dot(L, L) - tca * tca;
    if (d2 > radius2)
	{
		return CAST_DISTANCE;
	}
    float thc = sqrt(radius2 - d2);
    float t0 = tca - thc;
    float t1 = tca + thc;
	
	return min( t0, t1 );
}

// Function 1053
Result raymarchHF(Ray ray, float mindist, float maxdist, float stepsize, bool water)
{
    Result result;
    float dist = mindist;
    float h = 1.0;
    float dh = 1.0;
    float lastdh = -1.0;
    float lastdist = 0.0;
    float fracstep = 0.5;
    
    float maxy = water?WAVEHEIGHT:0.0;
    dist = max(dist, planeIntersect(ray.pos, ray.dir, vec4(0.0, 1.0, 0.0, -maxy)));
        
    for (float i=0.0; i<90.0; i++)
    {
        vec3 pos = ray.pos + ray.dir*dist;
        h = terrain(pos, water);
        dh = pos.y - h;
        if (dh<(0.001*i) || dist>maxdist)
        {
            break;    
        }
        lastdh = dh;
        lastdist = dist;
        dist+=stepsize;
        stepsize+=(0.0004*i);
    }
    
    if (dist<maxdist)
    {
        fracstep = lastdh/(lastdh-dh);    
        dist = mix(lastdist, dist, fracstep);
    }
    result.dist = dist;
    result.travelled = dist;
    result.pos = ray.pos + ray.dir*dist; 
    const float dn = 0.1;	
    result.normal.x = terrain(result.pos, water) - terrain(result.pos+XAXIS*dn, water);
    result.normal.y = dn;
    result.normal.z = terrain(result.pos, water) - terrain(result.pos+ZAXIS*dn, water);
    result.normal = normalize(result.normal);
    result.mat = g_basic;
    return result;
}

// Function 1054
float RayMatching(vec3 rayOri, vec3 rayDir)
{
	float nearDist = 0.1f;
    float farDist = 80.0f;
    float stp = 0.05f;
    
    float d = nearDist;
    float lastHeight;
    float lastPosy;
    while(d < farDist)
    {
        vec3 pos = rayOri + rayDir*d;
        float hight = HightFunction(pos);    
        if(hight > pos.y)
        {
            //intersection
            float delt = hight - pos.y;
            return d - stp*delt/(lastPosy -lastHeight + delt);
        }
        lastHeight = hight;
        lastPosy = pos.y;
        stp += 0.01;
        d += stp;
    }

    return -1.0;
}

// Function 1055
vec3 objectMapNormals(vec3 pos){
    const float grad_step = 0.02;
	const vec3 dx = vec3( grad_step, 0.0, 0.0 );
	const vec3 dy = vec3( 0.0, grad_step, 0.0 );
	const vec3 dz = vec3( 0.0, 0.0, grad_step );
	return normalize (
		vec3(
			map( pos + dx ).Md - map( pos - dx ).Md,
			map( pos + dy ).Md - map( pos - dy ).Md,
			map( pos + dz ).Md - map( pos - dz ).Md			
		)
	);
}

// Function 1056
vec3 bit3d_normal(bit3d_coordinate l) {
	return normalize(vec3(
		scenef(cadd(l, ev.xyz))-scenef(cadd(l,0.0-ev.xyz)),
		scenef(cadd(l, ev.yxz))-scenef(cadd(l,0.0-ev.yxz)),
		scenef(cadd(l, ev.zyx))-scenef(cadd(l,0.0-ev.zyx))
	));
}

// Function 1057
bool RayTraceScene(Ray ray, out HitInfo hitInfo)
{
    hitInfo.t = MAX_RAY_DISTANCE;
	
	bool isHit = false;
	for (int i = 0; i < SCENE_SPHERE_COUNT; i++) 
    {
		HitInfo tempInfo;
		if(RaySphereIntersection(ray, sceneSpheres[i], tempInfo))
		{
			if(hitInfo.t > tempInfo.t)
			{
				isHit = true;
				hitInfo = tempInfo;
			}
		}
	}
	
	for (int i = 0; i < SCENE_BOX_COUNT; i++) 
    {
		HitInfo tempInfo;
		if(RayBoxIntersection(ray, sceneBoxes[i], tempInfo))
		{
			if(hitInfo.t > tempInfo.t)
			{
				isHit = true;
				hitInfo = tempInfo;
			}
		}
	}
	
	return isHit;
}

// Function 1058
vec3 calcNormal(vec3 pos)
{
    float eps=0.001;
	float d=map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 1059
vec3 getRaysSecondPass(vec2 coord, out float mask){
    
    const int numSteps = int(Num_Steps * Density);
    int weight = 0;
    
    vec3 gr = vec3(0.0);
    
    vec2 mouseCoord = coord.xy - (iMouse.xy / iResolution.xy);
    
    vec2 delta = (mouseCoord) * (Density / float(numSteps));
    vec2 customTexcoord = coord.st;
    
    float visibility = 1.0-sqrt(pow(mouseCoord.x,2.0) + pow(mouseCoord.y,2.0));
    visibility = pow(visibility,1.0);
    visibility += pow(visibility,2.0);
    visibility = clamp(visibility,0.0,1.0);
    visibility = 1.0;
	
    for(int i = 0; i < numSteps; i++){
        
        customTexcoord -= delta;
    	float noise = getNoiseTexture(customTexcoord);
        
        gr += getNoiseTexture(customTexcoord.st + delta * noise);
        
        weight++;
    }
    
    gr /= float(weight);
    gr *= visibility;
    mask = (gr.r + gr.g + gr.b) / 3.0;
    mask = pow(mask,2.2);
    gr *= mask;
    gr = max(gr,0.0);
    
    return gr;
    
}

// Function 1060
vec3 geometryNormal(vec3 pos, const in Ray ray, const in WORLD w){
    vec2 e = vec2(1.0,-1.0)*0.5773*EPS;
    return normalize( e.xyy*world( pos + e.xyy, ray, w ).dist + 
					  e.yyx*world( pos + e.yyx, ray, w ).dist + 
					  e.yxy*world( pos + e.yxy, ray, w ).dist + 
					  e.xxx*world( pos + e.xxx, ray, w ).dist );
}

// Function 1061
vec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)
{
    rp = rp - (p0 + p1) / 2.0;
    vec3 arp = abs(rp) / (p1 - p0);
    return normalize(step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp));
}

// Function 1062
void TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)
{
    SPointLight lightPoint1 =
        SPointLight
        (
            vec3(sin(1.57 + iTime*1.5),sin(iTime*0.5),cos(1.57 + iTime*1.5)),
            vec3(0.9,0.9,0.9)
        );
    
    //----- primitives
    SSphere lightPoint1Sphere =
        SSphere
        (
            1,						//id
            lightPoint1.m_pos,		//center
            0.03,					//radius
            SMaterial
            (
                0.0,				//diffuse amount
                vec3(0.0,0.0,0.0),	//diffuse color
                1.0,				//specular amount
                vec3(0.0,0.0,0.0),	//specular color
                lightPoint1.m_color,//emissive color
                0.0,				//refraction amount
                0.0					//refraction index
            )
        );	

    SSphere sphere1 =
        SSphere
        (
            2,						//id
            vec3(0.0,0.0,0.0),		//center
            0.3,					//radius
            SMaterial
            (
                1.0,				//diffuse amount
                vec3(1.0,1.0,1.0),	//diffuse color
                5.0,				//specular amount
                vec3(1.0,1.0,1.0),	//specular color
                vec3(0.0,0.0,0.0),	//emissive color
                0.0,				//refraction amount
                0.0					//refraction index			
            )
        );
    
    SAxisAlignedBox orbitBox = 
        SAxisAlignedBox
        (
            3,						//Id
            vec3(sin(2.0 + iTime*1.3),0.0,cos(2.0 + iTime*1.3)),	//center
            vec3(0.5,0.75,0.5),	//scale
            SMaterial
            (
                0.25,				//diffuse amount
                vec3(1.0,1.0,1.0),  //diffuse color
                20.0,				//specular amount
                vec3(1.0,1.0,1.0),	//specular color
                vec3(0.0,0.0,0.0),	//emissive
                0.75,				//refraction amount
                0.9					//refraction index			
            )
        );
    
    SAxisAlignedBox orbitBox2 = 
        SAxisAlignedBox
        (
            4,						//Id
            vec3(sin(5.14 + iTime*1.3),0.0,cos(5.14 + iTime*1.3)),	//center
            vec3(0.5,0.75,0.5),	//scale
            SMaterial
            (
                0.25,				//diffuse amount
                vec3(1.0,1.0,1.0),  //diffuse color
                20.0,				//specular amount
                vec3(1.0,1.0,1.0),	//specular color
                vec3(0.0,0.0,0.0),	//emissive
                0.75,				//refraction amount
                0.9					//refraction index			
            )
        );    
    
	int lastHitPrimitiveId = 0;
	float colorMultiplier = 1.0; // used by reflections and refractions that aren't fully 1.0
	
	vec3 rayToCameraDir = rayDir;
	
	for(int index = 0; index < c_maxRayBounces; ++index)
	{
		
		SCollisionInfo collisionInfo =
			SCollisionInfo
			(
				0,
				false,
				false,
				-1.0,
				vec3(0.0,0.0,0.0),
				vec3(0.0,0.0,0.0),
				vec2(0.0,0.0),
				SMaterial(
					1.0,
					vec3(0.0,0.0,0.0),
					1.0,
					vec3(0.0,0.0,0.0),
					vec3(0.0,0.0,0.0),
					0.0,
					0.0
				)
			);

		// run intersection against all objects, including light objects		
		#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		SPHEREPRIMLISTWITHLIGHTS
		#undef PRIM
			
		// run intersections against all boxes
		#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		BOXPRIMLIST
		#undef PRIM

	
		if (collisionInfo.m_foundHit)
		{			
			if (collisionInfo.m_Id == 4)
				collisionInfo.m_material.m_diffuseColor = texture(iChannel1, collisionInfo.m_textureCoordinates).xyz;
			else
				collisionInfo.m_material.m_diffuseColor = texture(iChannel0, collisionInfo.m_textureCoordinates).xyz;
			
			// point lights
			#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);
			POINTLIGHTLIST
			#undef LIGHT				

			// ambient light
			pixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * colorMultiplier;
			
			// emissive color
			pixelColor += collisionInfo.m_material.m_emissiveColor * colorMultiplier;		
			
			//do refraction if we should
			if (collisionInfo.m_material.m_refraction > 0.0)
			{					
				if (collisionInfo.m_fromInside)
					collisionInfo.m_surfaceNormal *= -1.0;
				
				// if we are entering a refractive object, we can't ignore it since we need to go out the back
				// side possibly.  Since we can't ignore it, we need to push a little bit past the point of
				// intersection so we don't intersect it again.
				lastHitPrimitiveId = 0;				
				rayPos = collisionInfo.m_intersectionPoint + rayDir * 0.001;
				
				// 
				rayDir = refract(rayToCameraDir, collisionInfo.m_surfaceNormal, collisionInfo.m_material.m_refractionIndex);
				
				colorMultiplier *= collisionInfo.m_material.m_refraction;
				if (colorMultiplier < 0.1)
					return;				
			}	
			// else we are done
			else
				return;
		}
		// no hit means bail out
		else
		{
			pixelColor+= colorMultiplier * texture(iChannel2, rayDir).rgb;
			return;
		}
	}
			
}

// Function 1063
float grayScale(in vec3 col)
{
    return dot(col, vec3(0.2126, 0.7152, 0.0722));
}

// Function 1064
vec3 normal(vec3 pos)
{
    float eps=0.01;
	float d=map(pos).dist;
	return normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));
}

// Function 1065
bool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity) {
    dist = 0.; 
    float minStep = 1.0;
    light_intensity = 1.0;
	float mapDist;
    for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++) {
        p = ray_start + ray_dir * dist;
        mapDist = mapBlocks(p, ray_dir).y;
        if (mapDist < MIN_RAYMARCH_DELTA) {
            iterations = i;
            return true;
        }
		light_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist);
		dist += max(mapDist, minStep);
        if (dist >= maxDist || p.y > maxY) { break; }
    }
    return false;
}

// Function 1066
vec3 calcNormal(vec3 p) {
	vec2 e = vec2(EPSILON,0.);
    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),
                  dstScene(p+e.yxy)-dstScene(p-e.yxy),
                  dstScene(p+e.yyx)-dstScene(p-e.yyx));
    return normalize(n);
}

// Function 1067
vec3 getNormal( vec3 center, vec3 p )
{
	vec3 diff = p - center;
	return normalize( diff );
}

// Function 1068
vec3 normal(in vec3 p, float d) {
	const vec2 e = vec2(0.01, 0);
	return normalize(vec3(d - map(p - e.xyy), d - map(p - e.yxy),	d - map(p - e.yyx)));
}

// Function 1069
float raymarch(vec3 ro, vec3 rd) {
    float d = 0., t = 0.0;
    for (int i = 0; i < STEPS; ++i) {
        d = map(ro + t*rd);
        if (d < EPS*t || t > FAR)
            break;
        t += max(0.35*d, 2.*EPS*t);
    }
   
    return d < EPS*t ? t : -1.;
}

// Function 1070
vec3 getNormalS(vec3 p) {
    return normalize(vec3(
        sphereSD(vec3(p.x + EPSILON, p.y, p.z)) - sphereSD(vec3(p.x - EPSILON, p.y, p.z)),
        sphereSD(vec3(p.x, p.y + EPSILON, p.z)) - sphereSD(vec3(p.x, p.y - EPSILON, p.z)),
        sphereSD(vec3(p.x, p.y, p.z  + EPSILON)) - sphereSD(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1071
vec3 rayHexIntersect(vec2 ro, vec2 rd, vec2 h) {

    vec2 n = CART_FROM_HEX(h);

    // solve for u such that dot(n, ro+u*rd) = 1.0
    float u = (1.0 - dot(n, ro)) / dot(n, rd);

    // return the 
    return vec3(h, u);

}

// Function 1072
vec3 getNormal(vec3 p)
{
    float e = 0.03;
	float d = map(p);
    vec2 delta = vec2(e,0.);
    return normalize(
    	vec3(
        	map(p+vec3(delta.xyy))-d,
            map(p+vec3(delta.yxy))-d,
            map(p+vec3(delta.yyx))-d
        )
    );
}

// Function 1073
vec3 calcNormalTex(in vec3 pos)
{
    
    float center = luminosity(texture(iChannel0, pos.xy*TEXTURE_TILE_XY).xyz) * NORMAL_STRENGTH;
    float n = luminosity(texture(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(0.0, TEX_SAMPLE)).xyz) * NORMAL_STRENGTH;
    float s = luminosity(texture(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(0.0, -TEX_SAMPLE)).xyz) * NORMAL_STRENGTH;
    float e = luminosity(texture(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(TEX_SAMPLE, 0.0)).xyz) * NORMAL_STRENGTH; 
    float w = luminosity(texture(iChannel0, pos.xy*TEXTURE_TILE_XY + vec2(-TEX_SAMPLE, 0.0)).xyz) * NORMAL_STRENGTH; 
    
    
    float epsilon = 0.001;
    float meshCenter = scene(pos);
    float meshX = scene(pos - vec3(epsilon, 0.0, 0.0));
    float meshY = scene(pos - vec3(0.0, epsilon, 0.0));
    float meshZ = scene(pos - vec3(0.0, 0.0, epsilon));
    
    vec3 meshNorm = normalize(vec3(meshX-meshCenter, meshY-meshCenter, meshZ-meshCenter));
    
    vec3 norm = meshNorm;
    vec3 temp = norm;
    if (norm.x == 1.0)
    {
     	temp.y += 0.5;   
    }
    else
    {
     	temp.x += 0.5;   
    }
    
    vec3 perp1 = normalize(cross(norm, temp));
    vec3 perp2 = normalize(cross(norm, perp1));
    
    vec3 offset = -NORMAL_STRENGTH * (((n-center)-(s-center) * perp1) + ((e-center) - (w-center)) * perp2);
    norm += offset;
    
    return norm;
}

// Function 1074
vec3 SceneNormal(vec3 p, float h, out float d)
{
    vec3 n = vec3(
          Scene(p + vec3(h,0,0))
        , Scene(p + vec3(0,h,0))
        , Scene(p + vec3(0,0,h))
      ) - (d = Scene(p));
    if (dot(n,n) < 1e-7) n = vec3(0,1,0);
    else n = normalize(n);
    return n;
}

// Function 1075
vec3 findnormal(vec3 p, float len, float d) {
    vec2 eps = vec2(d/iResolution.y*2.0,0.0);
    
    return normalize(vec3(
        len-map(p-eps.xyy),
        len-map(p-eps.yxy),
        len-map(p-eps.yyx)));
}

// Function 1076
float3 dfNormal(float3 pos)
{
    float eps = 0.001;
    float3 n;
    float s;
#if 0
    // central difference
    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - distanceFunc( float3(pos.x-eps, pos.y, pos.z), s );
    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - distanceFunc( float3(pos.x, pos.y-eps, pos.z), s );
    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - distanceFunc( float3(pos.x, pos.y, pos.z-eps), s );
#else
    // forward difference (faster)
    float d = distanceFunc(pos, s);
    n.x = distanceFunc( float3(pos.x+eps, pos.y, pos.z), s ) - d;
    n.y = distanceFunc( float3(pos.x, pos.y+eps, pos.z), s ) - d;
    n.z = distanceFunc( float3(pos.x, pos.y, pos.z+eps), s ) - d;
#endif

    return normalize(n);
}

// Function 1077
bool RayHitsBlobBounds( vec3 start, vec3 dir, out vec3 hitPos )
{
    vec3 relStart = start - BLOB_BOUNDING_CENTER;
    relStart *= BLOB_BOUNDING_SCALE;
    vec3 relDir = dir * BLOB_BOUNDING_SCALE;
    
    float c = dot( relStart, relStart ) - BLOB_BOUNDING_RADIUS_SQR;
    
    if ( c < 0.0 )
    {
        // starts inside sphere
        hitPos = start;
        return true;
    }

    float a = dot( relDir, relDir );
    float b = dot( relStart, relDir );

    float discriminant = b * b - a * c;
    if ( discriminant < 0.0 )
        return false; // infinite line misses sphere
    
    if ( b >= 0.0 )
        return false; // ray points away from sphere
    
    // (this is the quadratic formula with b being half its normal value, which cancels out the 4 and 2 normally in the formula)
    float t = (-b - sqrt( discriminant )) / a;
    hitPos = start + dir * t;
    
    return true;
}

// Function 1078
float raymarch(vec3 ro, vec3 rd) {
  float d = 0.;
  float t = 0.;
  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
    d = map(ro + t * rd);
    if (d < EPSILON * t || t > MAX_DIST) break;
    t += 0.5 * d;
  }

  return d < EPSILON * t ? t : -1.;
}

// Function 1079
vec3 get_normal(vec3 pos, float tm) {
    float eps = 0.001;
    float dx = model(pos+vec3(eps,0.,0.),tm).x-model(pos-vec3(eps,0.,0.),tm).x;
    float dy = model(pos+vec3(0.,eps,0.),tm).x-model(pos-vec3(0.,eps,0.),tm).x;
    float dz = model(pos+vec3(0.,0.,eps),tm).x-model(pos-vec3(0.,0.,eps),tm).x;
    return normalize(vec3(dx,dy,dz));
}

// Function 1080
Refracted refract0(vec3 v,vec3 n, float ni_nt)
{
    Refracted ref;
    v = normalize(v);
    float dt = dot(v,n);
    float disc = 1.0-ni_nt*ni_nt*(1.0-dt*dt);
    if(disc > 0.0){
        ref.direction = ni_nt*(v-n*dt)-n*sqrt(disc);
        ref.did = true;
    }
    else ref.did = false;
    
    return ref;
    	
}

// Function 1081
vec3 calcNormal(vec3 pos)
{
    float eps=0.1;
	float d=map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 1082
vec3 calcNormal( in vec3 pos )
{
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.001*e).d;
    }
    return normalize(n);
}

// Function 1083
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(0.0025, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1084
vec2 rayMarch(vec3 ro, vec3 rd) {
	float dO=0.;
    float matId = -1.;
    
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        vec2 res = getDist(p);
        float dS = res.x;
        dO += dS;
        matId = res.y;
        
        if(dO>MAX_DIST || dS<SURF_DIST) break;
    }
    
    return vec2(dO, matId);
}

// Function 1085
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        drawScene(vec3(p.x + EPSILON, p.y, p.z)) - drawScene(vec3(p.x - EPSILON, p.y, p.z)),
        drawScene(vec3(p.x, p.y + EPSILON, p.z)) - drawScene(vec3(p.x, p.y - EPSILON, p.z)),
        drawScene(vec3(p.x, p.y, p.z  + EPSILON)) - drawScene(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1086
vec3 ray(vec3 start, vec3 direction, float t) {
	
	return start + t * direction;
	
}

// Function 1087
vec3 calcNormalTerrain( in vec3 pos, in float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapTerrainH( pos + e.xyy ).x + 
					  e.yyx*mapTerrainH( pos + e.yyx ).x + 
					  e.yxy*mapTerrainH( pos + e.yxy ).x + 
					  e.xxx*mapTerrainH( pos + e.xxx ).x );
}

// Function 1088
vec3 normal(vec3 p) { return normalize( vec3(scene( vec3(p.x + epsilon, p.y, p.z)) - scene( vec3(p.x - epsilon, p.y, p.z)) , scene( vec3(p.x, p.y + epsilon, p.z)) - scene( vec3(p.x, p.y - epsilon, p.z)), scene( vec3(p.x, p.y, p.z + epsilon)) - scene( vec3(p.x, p.y, p.z - epsilon)))); }

// Function 1089
float castRay(vec3 eye, vec3 ray, float time, out float dist, out vec3 norm) {
    vec3 pos = floor(eye);
    vec3 ri = 1.0 / ray;
    vec3 rs = sign(ray);
    vec3 ris = ri * rs;
    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;
    
    vec3 dim = vec3(0.0);
    for (int i = 0; i < maxIter; ++i) {
        if (pos.z < 0.0 || voxelHit(pos, time)) {
            dist = dot(dis - ris, dim);
            norm = -dim * rs;
            return 1.0;
        }
    
        dim = step(dis, dis.yzx);
		dim *= (1.0 - dim.zxy);
        
        dis += dim * ris;
        pos += dim * rs;
    }

    if (ray.z < 0.0) {
        dist = -eye.z / ray.z;
        norm = vec3(0.0, 0.0, 1.0);
        return 1.0;
    }
	return 0.0;
}

// Function 1090
vec3 CAM_getRay(Cam cam,vec2 uv)
{
    uv *= 2.0*iResolution.x/iResolution.y;;
    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D*2.5);
}

// Function 1091
Mobius M_Normalize( in Mobius m )
{
	// See Visual Complex Analysis, p150
	vec2 k = C_Inv( C_Sqrt( m.A * m.D - m.B * m.C ) );
	return M_Scale( m, k );
}

// Function 1092
vec3 GetColorForRay(in vec3 rayPos, in vec3 rayDir, out float hitDistance)
{
    // trace primary ray
	SRayHitInfo hitInfo = RayVsScene(rayPos, rayDir);
    
    // set the hitDistance out parameter
    hitDistance = hitInfo.dist;
    
    if (hitInfo.dist == c_rayMaxDist)
        return texture(iChannel0, rayDir).rgb;
    
    // trace shadow ray
    vec3 hitPos = rayPos + rayDir * hitInfo.dist;
    hitPos += hitInfo.normal * c_hitNormalNudge;
    SRayHitInfo shadowHitInfo = RayVsScene(hitPos, c_lightDir);
    float shadowTerm = (shadowHitInfo.dist == c_rayMaxDist) ? 1.0f : 0.0f;
    
    // do diffuse lighting
    float dp = clamp(dot(hitInfo.normal, c_lightDir), 0.0f, 1.0f);
	return c_lightAmbient * hitInfo.diffuse + dp * hitInfo.diffuse * c_lightColor * shadowTerm;
}

// Function 1093
vec3 estimateNormal(vec3 p)
{
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z))
            - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z))
            - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON))
            - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1094
vec3 calcNormalHigh( in vec3 pos, float t, in float time )
{
    vec2 e = vec2(1.0,-1.0)*0.001*t;

    return normalize( e.xyy*mapH( pos + e.xyy, time ) + 
					  e.yyx*mapH( pos + e.yyx, time ) + 
					  e.yxy*mapH( pos + e.yxy, time ) + 
					  e.xxx*mapH( pos + e.xxx, time ) );
}

// Function 1095
vec4 raymarch(float world, vec3 from, vec3 increment)
{
	const float maxDist = 200.0;
	const float minDist = 0.1;
	const int maxIter = RAYMARCH_ITERATIONS;
	
	float dist = 0.0;
	
	float material = 0.0;
	
	float glow = 1000.0;
	
	for(int i = 0; i < maxIter; i++) {
		vec3 pos = (from + increment * dist);
		float distEval = distf(int(world), pos, material);
		
		if (distEval < minDist) {
			break;
		}
		
		#ifdef GLOW
		if (material == 3.0) {
			glow = min(glow, distEval);
		}
		#endif
		
		
		if (length(pos.xz) < 12.0 && 
			pos.y > 0.0 &&
			(from + increment * (dist + distEval)).y <= 0.0) {
			if (world == 0.0) {
				world = 1.0;
			} else {
				world = 0.0;
			}
		}
		dist += distEval;
	}
	
	
	if (dist >= maxDist) {
		material = 0.0;
	}
	
	return vec4(dist, material, world, glow);
}

// Function 1096
vec3 ray(vec3 start, vec3 direction, float t) {
	return start + t * direction;
}

// Function 1097
Obj castRay(vec3 o, vec3 r, out vec3 n, out vec3 p)
{
    // Setup variables
    vec3 col = vec3(0.0);
    int rn = 0;
    
    // Initialise normal vector and distance
    n = vec3(0.0);
    float t = BIG_NUMBER;

    // Calculate intersection
    Obj obj = intersect(o, r, t, n);
    
    // Setup the point
    p = o + r * t;
    
    // Return colour
    return obj;
}

// Function 1098
void bumpNormalTexture ( inout Ray ray, in float size, in sampler2D tex, in vec2 texture_size) {
	vec3 uaxis = normalize(cross(normalize(abs(ray.direction)), ray.normal));
	vec3 vaxis = normalize(cross(uaxis, ray.normal));
	mat3 space = mat3( uaxis, vaxis, ray.normal );

	float A = texture2D(tex, ray.object.uv - vec2(0,0) / texture_size).r;
	float B = texture2D(tex, ray.object.uv - vec2(1,0) / texture_size).r;
    float C = texture2D(tex, ray.object.uv - vec2(0,1) / texture_size).r;
	ray.normal = normalize(vec3(B - A, C - A, clamp(1.- size, 0.,1.)));
	ray.normal = normalize(space * ray.normal);
}

// Function 1099
vec2 traceRay(in vec3 origin, in vec3 direction) {
    float material = -1.0;

    float t = 0.004;
    
    for (int i = 0; i < 1000; i++) {
        vec2 hit = scene(origin + direction * t);
        if (hit.x < 0.001 || t > 20.0) break;
        t += hit.x;
        material = hit.y;
    }

    if (t > 20.0) {
        material = -1.0;
    }

    return vec2(t, material);
}

// Function 1100
vec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {
	// Add some noise to prevent banding
	float totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));
	vec3 dir2 = dir;
	float distance;
	int steps = 0;
	vec3 pos;
	for (int i=0; i <= MaxSteps; i++) {
		pos = from + totalDistance * dir;
		distance = DE(pos)*FudgeFactor;
		totalDistance += distance;
		if (distance < MinimumDistance) break;
		steps = i;
	}
	
	// 'AO' is based on number of steps.
	// Try to smooth the count, to combat banding.
	float smoothStep =   float(steps) ;
		float ao = 1.0-smoothStep/float(MaxSteps);
	
	// Since our distance field is not signed,
	// backstep when calc'ing normal
	vec3 normal = getNormal(pos-dir*normalDistance*3.0);
	vec3 bg = vec3(0.2);
	if (steps == MaxSteps) {
		return vec4(bg,1.0);
	}
	vec3 color = getColor(normal, pos);
	vec3 light = getLight(color, normal, dir);
	
	color = mix(color*Ambient+light,bg,1.0-ao);
	return vec4(color,1.0);
}

// Function 1101
float scene_raycast_terrain( Ray ray, float wlevel, float tmax2nd, inout float t0, inout vec3 r )
{
    bool submerged = length( ray.o ) - g_data.radius < wlevel;
    float t = 0., h = 0., alt = 0.;
    float lasth = 0., lastt = 0., lasta = 0.;
    vec4 tsmpl = vec4( 0 );
    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );
    float C0 = length( ray.o ) - g_data.radius;
    float C1 = dot( ray.o, ray.d ) / length( ray.o );
    float C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; i++ )
    {
        r = ray.o + t * ray.d;
        tsmpl = ts_sample( g_ts, iChannel1, r );
        lasta = alt;
        alt =
        #if WITH_TRN_HIGHP_RAYCAST
            t < t_switch ? C0 + t * C1 + t * t * C2 :
        #endif
            length( r ) - g_data.radius;
        lasth = h;
        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );
        if( h < 0. )
        {
            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );
            r = ray.o + t * ray.d;
            return t;
        }
        else
            if( submerged && alt >= wlevel )
            {
                if( t0 > 0. )
                    break;
                t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );
                r = ray.o + t * ray.d;
                vec3 Z = normalize( r );
                vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );
                ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );
                ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );
                ray.o = r;
                t0 = t;
                t = 0.;
            #if WITH_TRN_HIGHP_RAYCAST
                C0 = length( ray.o ) - g_data.radius;
                C1 = dot( ray.o, ray.d ) / length( ray.o );
                C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
            #endif
                alt = wlevel;
                h = wlevel - ts_sample( g_ts, iChannel1, r ).w;
            }
        lastt = t;
        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );
        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) || ( t0 > 0. && t + t0 >= tmax2nd ) )
            break;
    }
    return SCN_ZFAR;
}

// Function 1102
float get_ray_elevation( vec3 c, vec3 o, vec3 d ) { return safe_acos( dot( d, normalize( c - o ) ) ); }

// Function 1103
vec3 calcNormal( in vec3 pos ) {
    vec3 n = calcNormalSimple( pos );
    if( pos.y > 0.12 ) return n;

#ifdef BUMPMAP
    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );

    if( abs(pos.x)<8. ) {
		oc = pos.xz;
    }
    
     vec3 p = pos * 250.;
   	 vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);
     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);
    
    n = normalize( xn + n );
#endif
    
    return n;
}

// Function 1104
vec3 normal(vec3 p) {
	vec2 e = vec2(.0005, 0);
	return normalize(vec3(
		de(p + e.xyy) - de(p - e.xyy),
		de(p + e.yxy) - de(p - e.yxy),
		de(p + e.yyx) - de(p - e.yyx)
	));
}

// Function 1105
vec3 getNormal    (vec3 p){vec2 b=vec2(0,.00001);return Derivative9Tap(Df ,p,b);}

// Function 1106
vec3 estimate_entity_normal(vec3 p, float dist)
{
    const float EPSILON = 1e-3;
    vec3 normal = vec3(-dist);
    for (int i=NO_UNROLL(0); i<3; ++i)
    {
        vec3 p2 = p;
        p2[i] += EPSILON;
        normal[i] += map_entities(p2).x;
    }
    return normalize(normal);
}

// Function 1107
vec3 random_ray(vec3 n, vec4 seed)
{
    vec2 uv = vec2(hash(51.5*seed.x + 15.6*seed.y + 37.1*seed.z + 13.1*seed.w + 15.1*iTime), 
                   hash(19.6*seed.x + 91.1*seed.y + 15.1*seed.z + 21.5*seed.w + 7.8*iTime));
    return lambert_distrib(n, uv);
}

// Function 1108
vec3 normal( in vec3 pos, in float d )
{
	vec2 eps = vec2( max(sphereSize(d*2.), .01), 0.0);
	vec3 nor = vec3(
	    mapDE(pos+eps.xyy) - mapDE(pos-eps.xyy),
	    mapDE(pos+eps.yxy) - mapDE(pos-eps.yxy),
	    mapDE(pos+eps.yyx) - mapDE(pos-eps.yyx)
    );
	return normalize(nor);
}

// Function 1109
vec2 RayLineDist(vec3 ro, vec3 rd, vec3 a, vec3 b) {
    
    b -= a;
    vec3 rdb = cross(rd,b);
    vec3 rop2 = a-ro;
    
	float t1 = dot( cross(rop2, b), rdb ); 
    float t2 = dot( cross(rop2, rd), rdb );
    
    return vec2(t1, t2) / dot(rdb, rdb);
}

// Function 1110
float RayMarch(vec3 ro, vec3 rd, int PMaxSteps)
{   float t = 0.; 
    vec3 dS=vec3(9999.0,-1.0,-1.0);
    float marchCount = 0.0;
    vec3 p;
    float minDist = 9999.0; 
    
    for(int i=0; i <= PMaxSteps; i++) 
    {  	p = ro + rd*t;
        dS = GetDist(p);
        t += dS.x;
        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)
            {mObj.hitbln = true; minDist = abs(t); break;}
        if(t>MAX_DIST)
            {mObj.hitbln = false;    minDist = t;    break; } 
        marchCount++;
    }
    mObj.dist = minDist;
    mObj.id_color = dS.y;
    mObj.marchCount=marchCount;
    mObj.id_material=dS.z;
    mObj.normal=GetNormal(p);
    mObj.phit=p;
    return t;
}

// Function 1111
vec3 normal(vec3 pos, float dist, bool inside) 
{
if(pos.z < 0.0001)
    return vec3(0,0,1);
    
    float h = 0.0001 * dist; 
    //const vec2 k = vec2(1,-1);
    //return normalize( k.xyy*sdf( pos + k.xyy*h ,inside) + 
    //                  k.yyx*sdf( pos + k.yyx*h ,inside) + 
    //                  k.yxy*sdf( pos + k.yxy*h ,inside) + 
    //                  k.xxx*sdf( pos + k.xxx*h ,inside) );
                      
                      
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*sdf(pos + e * h,inside);
    }
    return normalize(n);
}

// Function 1112
vec3 get_normal(in vec3 p) { //get normal at position
    vec2 e = vec2(EPSILON, 0.0);
	return normalize(
			vec3(
					scene(p+e.xyy).x - scene(p-e.xyy).x,
					scene(p+e.yxy).x - scene(p-e.yxy).x,
					scene(p+e.yyx).x - scene(p-e.yyx).x
			)
	);
}

// Function 1113
void calcRayForPixel(in vec2 fragCoord, in vec2 res, in vec2 mouse, in float t, out vec3 ro, out vec3 rd)
{
    vec2  uv = fragCoord / res;
	vec2  p  = (-res + 2.0 * fragCoord) / res.y;
    float h  = t * .5;
    float r  = sin(t * .1) * .5 + .5;
    
    vec2 mo = mouse.xy/res.xy;
    mo=vec2(0);
	float time = 15.0 + t*1.5-2.5;

    // camera	
    vec3 ta = vec3( 0, .5, 0 );
     ro = vec3(1.2*cos(0.1*time + 6.0*mo.x), .75 + 2.0*mo.y, -5.5);    
	/*    
    vec3  ta = vec3(-ro.x, 0., -ro.z);
    ro 		 = ro * vec3(r, 1, r);
    */
    mat3  ca = computeCameraMatrix(ro, ta, 0.0);
    rd       = ca * normalize(vec3(p.xy,  2.0));
}

// Function 1114
float TunRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 160; j ++) {
    d = TunDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1115
vec3
ray_at(in Ray ray, float t)
{
	return ray.origin + t * ray.dir;
}

// Function 1116
float raymarch (in vec3 ro, in vec3 rd, inout int iter) {
    float t = .0;
    float d = .0;
    for (int i = 0; i < MAX_ITER; ++i) {
        vec3 p = ro + d * rd;
        t = scene (p);
        if (abs (t) < EPSILON * (1. + .125*t)) break;
        d += t*STEP_BIAS;
        iter = i;
    }

    return d;
}

// Function 1117
vec3 getNormal(in vec3 p)
{
    const float e = 0.01;
    return normalize(vec3(scene(vec3(p.x + e, p.y, p.z)) - scene(vec3(p.x - e, p.y, p.z)),
                          scene(vec3(p.x, p.y + e, p.z)) - scene(vec3(p.x, p.y - e, p.z)),
                          scene(vec3(p.x, p.y, p.z + e)) - scene(vec3(p.x, p.y, p.z - e))));
}

// Function 1118
Intersection Raymarch(Camera camera)
{    
    Intersection outData;
    outData.sdf = 0.0;
    outData.density = 0.0;
    outData.totalDistance = MIN_DISTANCE;
        
	for(int j = 0; j < MAX_STEPS; ++j)
	{
        vec3 p = camera.origin + camera.direction * outData.totalDistance;
		outData.sdf = sdf(p);

		outData.totalDistance += outData.sdf;
                
		if(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)
            break;
	}
    
    return outData;
}

// Function 1119
float rayPlane( vec3 ro, vec3 rd, vec3 po, vec3 pn )
{
    return -dot( ro - po, pn ) / dot( rd, pn );
}

// Function 1120
vec4 normalMap(sampler2D channel, vec2 uv) {
  return vec4(
    bumpFromDepth(
      channel,
      uv
    ).rgb * .5 + .5, 
    1.
  );
}

// Function 1121
vec3 SceneNormal(vec3 pos) {
	const float DX = 0.004;
	const vec3 dx = vec3(DX, 0.0, 0.0);
    const vec3 dy = vec3(0.0, DX, 0.0);
    const vec3 dz = vec3(0.0, 0.0, DX);
    return normalize(vec3(
        SceneDistance(pos + dx) - SceneDistance(pos - dx),
        SceneDistance(pos + dy) - SceneDistance(pos - dy),
        SceneDistance(pos + dz) - SceneDistance(pos - dz)
    ));
}

// Function 1122
bool intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 r1) {
    vec3 t0 = (-o - ext) / d; 
    vec3 t1 = (-o + ext) / d;    
    vec3 n = min(t0,t1); n.x = max(max(n.x,n.y),n.z);
    vec3 f = max(t0,t1); f.x = min(min(f.x,f.y),f.z);
    r0 = o + d * n.x;
    r1 = o + d * f.x;
    return bool(step(n.x,f.x));
}

// Function 1123
vec3 normal(vec3 p, float s){vec2 e = vec2(0.01, 0.0);return normalize(vec3(map(p + e.xyy),map(p + e.yxy),map(p + e.yyx)) - s);}

// Function 1124
vec3 OceanNormal( vec3 pos )
{
	vec3 norm;
	vec2 d = vec2(.01*length(pos),0);
	
	norm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );
	norm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );
	norm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );

	return normalize(norm);
}

// Function 1125
HitData AllObjectsRayTest(vec3 rayPos, vec3 rayDir)
{
    HitData hitData;
    hitData.rayLength = 9999.0; //default value if can't hit anything

    for(int i = 0; i < SPHERECOUNT; i++)
    {
        vec3 sphereCenter = AllSpheres[i].xyz;
        float sphereRadius = AllSpheres[i].w;
        //----hardcode sphere pos animations-------------------------------------
        if(i == 0)
        {
            float t = fract(iTime * 0.7);
            t = -4.0 * t * t + 4.0 * t;
            sphereCenter.y += t * 0.7;
            
            sphereCenter.x += sin(iTime) * 2.0;
            sphereCenter.z += cos(iTime) * 2.0;
        }
             
        if(i == 1)
        {
            float t = fract(iTime*0.47);
            t = -4.0 * t * t + 4.0 * t;
            sphereCenter.y += t * 1.7;
            
            sphereCenter.x += sin(iTime+3.14) * 2.0;
            sphereCenter.z += cos(iTime+3.14) * 2.0;
        }             
        //---------------------------------------
                
        float resultRayLength = raySphereIntersect(rayPos,rayDir,sphereCenter,sphereRadius);
        if(resultRayLength < hitData.rayLength && resultRayLength > 0.001)
        {
            //if a shorter(better) hit ray found, update
            hitData.rayLength = resultRayLength;
            vec3 hitPos = rayPos + rayDir * resultRayLength;
    		hitData.normal = normalize(hitPos - sphereCenter);
        }
    }
    
    //all test finished, return shortest(best) hit data
    return hitData;
}

// Function 1126
vec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )
{
	vec3 vForward = normalize(vCameraTarget - vCameraPos);
	vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));
	vec3 vUp = normalize(cross(vForward, vRight));
							  
    float fPersp = 3.0;
	vec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fPersp);

	return vDir;
}

// Function 1127
vec3 getNormal(vec3 point){
	float distPoint = intersect(point);
    vec2 e = vec2(0.01, 0);
    
    vec3 norm = distPoint - vec3(intersect(point - e.xyy), intersect(point - e.yxy), 
                            	 intersect(point - e.yyx));
    return normalize(norm);
}

// Function 1128
vec3 normalEstimation(vec3 pos){
  float dist = distanceEstimation(pos);
  return normalEstimation(pos, dist);
}

// Function 1129
vec4 rays(vec4 color, vec4 background, vec2 position, float radius, float rays, float ray_length, sampler2D sound, vec2 uv)
{
    float inside = (1.0 - ray_length) * radius; //empty part of circle
    float outside = radius - inside; //rest of circle
    float circle = 2.0*M_PI*inside; //circle lenght
    for(int i = 1; float(i) <= rays; i++)
    {
        float len = outside * texture(sound, vec2(float(i)/rays, 0.0)).x; //length of actual ray
        background = bar(color, background, vec2(position.x, position.y+inside), vec2(circle/(rays*2.0), len), rotate(uv, position, 360.0/rays*float(i))); //Added capsules
    }
    return background; //output
}

// Function 1130
vec3 getRay_9_4(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {
  mat3 camMat = calcLookAtMatrix_7_1(origin, target, 0.0);
  return getRay_9_4(camMat, screenPos, lensLength);
}

// Function 1131
vec3 calcNoiseNormal(  vec3 pos )
{    
  return normalize( vec3(fbm(pos+eps.xyy) - fbm(pos-eps.xyy), 0.5*2.0*eps.x, fbm(pos+eps.yyx) - fbm(pos-eps.yyx) ) );
}

// Function 1132
vec3 getNormalHex(vec3 pos)
{
	float d=map(pos).x;
	return normalize(
        vec3(
            map(
                pos+vec3(EPSILON,0,0)).x-d,
                map(pos+vec3(0,EPSILON,0)).x-d,
                map(pos+vec3(0,0,EPSILON)).x-d 
        	)
    	);
}

// Function 1133
vec3 castRay(in vec3 ro, in vec3 rd) {
  float tmin = 0.0;
  float tmax = 30.0;
  int steps = 0;

  float t = tmin;
  float m = -1.0;
  for (int i = 0; i < 64; i++) {
    float precis = 0.0005 * t;
    vec2 res = map(ro + rd * t);
    if (res.x < precis || t > tmax) break;
    t += res.x;
    m = res.y;
    steps = i;
  }

  if (t > tmax) m = -1.0;
  return vec3(t, m, float(steps));
}

// Function 1134
vec3 normal (in vec3 p) {
	float d = map (p);
    vec3 e = vec3 (.001, .0, .0);
    return normalize (vec3 (map (p + e.xyy) - d,
                            map (p + e.yxy) - d,
                            map (p + e.yyx) - d));
}

// Function 1135
mat3 mat3FromNormal(in vec3 n) {
    vec3 x;
    vec3 y;
    basis(n, x, y);
    return mat3(x,y,n);
}

// Function 1136
vec3 calcNormal( in vec3 pos, float t )
{
	float e = 0.001;
	e = 0.0001*t;
    vec3  eps = vec3(e,0.0,0.0);
    vec3 nor;
    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);
    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);
    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);
    return normalize(nor);
}

// Function 1137
vec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {
    float i = tileId( pos, nor );
    if( i > 0. ) {
        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );
        nor = normalize( nor );
    }
    return nor;
}

// Function 1138
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0);

    const float tmax = 10.0;
    float t = 1.0;
    for( int i=0; i<128; i++ )
    {
        vec3 p = ro + t*rd;
        vec2 h = map( p );
        res = vec2(t,h.y);
        if( abs(h.x)<0.0001 || t>tmax ) break;
        t += h.x*0.8;
    }

    if( t>tmax ) res = vec2(-1.0);

    return res;
}

// Function 1139
vec3 calcNormal(in vec3 pos) {
    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 1140
vec3 Normal( vec3 pos, vec3 ray )
{
	// in theory we should be able to get a good gradient using just 4 points
	vec2 d = vec2(-1,1) * .01;
	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 = DistanceField(p0);
	float f1 = DistanceField(p1);
	float f2 = DistanceField(p2);
	float f3 = DistanceField(p3);
	
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);
	
	// prevent normals pointing away from camera (caused by precision errors)
	float gdr = dot ( grad, ray );
	grad -= max(.0,gdr)*ray;
	
	return normalize(grad);
}

// Function 1141
vec3 rayrender(vec3 pos, vec3 dir)
{
   vec3 col = vec3(0.0);
    
   float dist = raymarcher(pos, dir);
    
    if (dist==-1.0) col = background(dir);
    else
    {
    	vec3 inters = pos + dist * dir;
    	col = material(inters, dir);
    }
    
    return col;
}

// Function 1142
vec3 castRay(vec3 pos, vec3 dir) {
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
		float dist = sceneSDF(pos);
        if (dist < EPSILON) {
			return pos;
        }
		pos += dist * dir;
	}    
	return pos;
}

// Function 1143
vec3 calcNormal(in vec3 pos, in vec3 ray, in float t) {

	float pitch = .2 * t / iRes.x;
	pitch = max( pitch, .002 );
	
	vec2 d = vec2(-1,1) * pitch;

	vec3 p0 = pos+d.xxx, p1 = pos+d.xyy, p2 = pos+d.yxy, p3 = pos+d.yyx;
	float f0 = map(p0), f1 = map(p1), f2 = map(p2), f3 = map(p3);
	
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);
	// prevent normals pointing away from camera (caused by precision errors)
	return normalize(grad - max(.0, dot (grad,ray))*ray);
}

// Function 1144
vec3 GetNormal(vec3 p) 
{
    return normalize(p-PLANETCENTER);
}

// Function 1145
vec3 getRay(vec2 angles, vec2 pos)
{
    mat3 camera = getRot(angles);
    return normalize(transpose(camera)*vec3(FOV*pos.x, FOV*pos.y, 1.));
}

// Function 1146
float reflection( inout vec3 start, in vec3 ldir, out vec3 finish)
{    
	float t = EPSILON;
	vec2 iter, res = vec2(1.0);
    for ( int i = 0; i < R_STEPS; ++i )
    {
        finish = start + ldir*t;
        iter = distID( finish );
        if ( iter.s < EPSILON*.1 )
            return iter.t;
        t += iter.s;
		if ( t > MAX_DEPTH )
			break;
    }
    return res.t;
}

// Function 1147
vec3 Normal(Object obj, vec3 position) {
    vec3 normal = vec3(Sdf(obj, position + vec3(EPSILON, 0.0, 0.0)) - Sdf(obj, position - vec3(EPSILON, 0.0, 0.0)),
                       Sdf(obj, position + vec3(0.0, EPSILON, 0.0)) - Sdf(obj, position - vec3(0.0, EPSILON, 0.0)),
                       Sdf(obj, position + vec3(0.0, 0.0, EPSILON)) - Sdf(obj, position - vec3(0.0, 0.0, EPSILON)));
    return normal / length(normal);
}

// Function 1148
float objectMapReflectiveness(vec3 p){
    mapResult M = map(p);
    float m = M.Md;
    return m > 50.0 ? 0.
         : m == spheres[M.minS].dist ? spheres[M.minS].reflectiveness
         : m == boxes[M.minB].dist ? boxes[M.minB].reflectiveness
         : m == planes[M.minP].dist ? planes[M.minP].reflectiveness : 0.;
}

// Function 1149
Hit raymarch(Ray ray, bool shadow) {
 
    vec3 p = ray.ori;
    int id = -1;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        Dst scn = dstScene(p, shadow);
        p += ray.dir * scn.dst * .75;
        
        if(scn.dst < MIN_DISTANCE) {
         
            id = scn.id;
            break;
            
        }
        
    }
    
    return Hit(p,id);
    
}

// Function 1150
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1151
bool ray_edge(vec3 org,vec3 dir,vec3 lb, vec3 rt)
{
    bool rta = false;
    vec3 dirfrac = 1.0 / dir;
    vec3 A = (lb-org)*dirfrac;
    vec3 B = (rt-org)*dirfrac;
    float tmin = max(max(min(A.x, B.x), min(A.y, B.y)), min(A.z, B.z));
    float tmax = min(min(max(A.x, B.x), max(A.y, B.y)), max(A.z, B.z));
    if (tmin<=tmax && tmin>0.0)
    {
        int cant = 0;
		vec3 Ip = org + dir*tmin;
        vec3 Ta = abs(Ip - lb);
        vec3 Tb = abs(Ip - rt);
        if( Ta.x < EP)
            cant++;
        if( Ta.y < EP)
            cant++;
        if( Ta.z < EP)
            cant++;
        
        if( Tb.x < EP)
            cant++;
        if( Tb.y < EP)
            cant++;
        if( Tb.z < EP)
            cant++;
        
        rta = cant>=2 ? true : false;
    }
	return rta;
}

// Function 1152
vec3 normal(vec2 p) {
	vec2 eps=vec2(0,res*.5);
	float d1=terrain(p+eps.xy)-terrain(p-eps.xy);
	float d2=terrain(p+eps.yx)-terrain(p-eps.yx);
	vec3 n1=(vec3(0.,eps.y*2.,d1));
	vec3 n2=(vec3(eps.y*2.,0.,d2));
	return normalize(cross(n1,n2));
}

// Function 1153
Ray GetRipplesRefractedRay(Ray r, float H, float A, float slopeAngle, float d){
    float eta = slopeAngle;
    float theta = acos(dot(r.d, vec3(.0,.0,1.))); // rayAngle
    float l = H/cos(theta);
    vec3 incidentPoint = r.o + r.d*l;
    
    float Anglei = theta;
    
    if (slopeAngle < 0.){
        eta = - eta;
    }
    Anglei = abs(eta - theta);
    
    float phi = GetRefractedAngle(1.,Anglei, n); //refracted angle
    
    vec3 refractedDir = normalize(r.d*Rotate(Anglei-phi, normalize(cross(r.d,vec3(0.,0.,1.)))));
    
    Ray ray;
    ray.o = incidentPoint - refractedDir *l*n;
    ray.d = refractedDir;
	return ray;
}

// Function 1154
Ray GetRayFromCamera(Camera cam)
{
    const vec3 up = vec3(0,1,0);
    
    vec3 dirF = normalize(cam.dir);
    vec3 dirT = -normalize(cross(dirF, up));
    vec3 dirU = normalize(cross(dirF, dirT));
	
	vec2 jitteredUV = fragUV.xy + vec2(EDGE_SIZE, cam.aspect * EDGE_SIZE) * 2.0 * vec2(Rand() - 0.5, Rand() - 0.5);
	
	vec3 sensor = GetSensorPoint(cam, jitteredUV);	
	vec3 focalPoint = normalize(sensor) * cam.focusDist;
	
	vec3 lensPoint = GetAperturePoint(cam);
	vec3 refractLocalRay = normalize(focalPoint - lensPoint);
	
	vec3 rayPos = cam.pos + (dirT * lensPoint.x + dirU * lensPoint.y + dirF * lensPoint.z);
	vec3 rayDir = normalize(dirT * refractLocalRay.x + dirU * refractLocalRay.y + dirF * refractLocalRay.z);
	
    return Ray(rayPos, rayDir, 0, vec3(1,1,1), 1.0);
}

// Function 1155
vec3 sphereNormal(vec4 sph, vec3 p) {
    return (p - sph.xyz) / sph.w;
}

// Function 1156
vec3 calcNormal( in vec3 pos ) {
    const vec2 e = vec2(1.0,-1.0)*0.005;

    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + 
					    e.yyx*map( pos + e.yyx )   + 
					    e.yxy*map( pos + e.yxy )   + 
					    e.xxx*map( pos + e.xxx )   );  
    
#ifdef BUMPMAP
    vec3 p = pos * 20.;
    if( abs(pos.x+xoffset(pos.z))>2.48 )n = normalize( n + 0.1*vec3(0.,fbm(p.yz)-0.5,fbm(p.zy)-0.5));
#endif
    
    return n;
}

// Function 1157
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(precis,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1158
vec4 raymarch(vec3 campos, vec3 raydir, vec4 o1) {
	float totaldist = 0.0;
	vec3 pos = campos;
	float dist = EPS;
	
	for (int i = 0; i < MAX_ITER; i++) {
    	if (dist < EPS || totaldist > MAX_DIST)
        	break;
	
    	dist = distfunc(pos, o1);
	    totaldist += dist;
    	pos += dist * raydir;
    }
    
    return vec4(pos, dist);
}

// Function 1159
vec3 SceneNormal(vec3 p, float h, out float d, int izero)
{
    vec3 n, o = vec3(0,0,h);
    vec4 s;
    for (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))
        s[i] = Scene(p + o).d;        
    n = s.yzw - (d = s.x);
    if (dot(n,n) < 1e-7) n = vec3(0,1,0);
    else n = normalize(n);
    return n;
}

// Function 1160
vec2 pixelToNormalizedspace(vec2 pixel)
{
    vec2 res;
    res.x = pixel.x * 2.0 / iResolution.x - 1.0;
    res.y = pixel.y * 2.0 / iResolution.y - 1.0;
    res.y *= iResolution.y / iResolution.x;//correct aspect ratio
    return res;
}

// Function 1161
vec4 rayMarch(vec3 startPoint, vec3 direction, int iterations, float maxStepDist)
{
 	vec3 point = startPoint;
    direction = normalize(direction);
    float distSum = 0.0;
    float shadowData = 1.0;
    float dist = 10.0;
    
    int i;
    for (i = 0; i < iterations && distSum < MAX_VIEW_DISTANCE && abs(dist) > EPSILON; i++)
    {
     	dist = terrainDist(point, direction.xy);
        dist = min(dist, maxStepDist) * 0.4;
        distSum += dist;
        point += direction * dist;
    }
    
    return vec4(point.xyz, distSum);
}

// Function 1162
vec3 calcNormal( vec3 pos ) {
    float delta = 0.01;
    vec2 unit = vec2(1.0, 0.0);
    return normalize( vec3(
            map(pos + unit.xyy*delta) - map(pos - unit.xyy*delta),
            map(pos + unit.yxy*delta) - map(pos - unit.yxy*delta),
            map(pos + unit.yyx*delta) - map(pos - unit.yyx*delta)));
}

// Function 1163
HitQuery ray_trace(Ray ray, Scene scene) { 
    
 
    float throughput = 1.0;
    HitQuery hit_query = no_hit;
    
    // trace a path recursivly until max_depth
    for (int i = 0; i < max_depth; i++) {
        
        // intersect ray with scene
        hit_query = intersect_scene(ray, scene);
        
        
        // if missed or emiter, stop
        if (hit_query.material == none || hit_query.material == emiter) {
            if (i == 0 && ONLY_INDIRECT) {
                hit_query = no_hit;
            }
            break;
        }
        // oherwise, sample new ray according to material
        else {
            Sample sample_dir;
            if (hit_query.material == mirror) {
                sample_dir = sample_mirror(hit_query, ray);
            } 
            else if (hit_query.material == dielectric) {
                sample_dir = sample_dielectric(hit_query, ray);
            } 
            ray = sample_dir.ray;
            // everything should cancel out, but just for the form.
            throughput *= sample_dir.contrib * sample_dir.attenuation/(sample_dir.pdf + eps);
        }
        
        
        
    }
    hit_query.throughput = throughput;
    return hit_query;

}

// Function 1164
float pdfLambertianReflection(const in vec3 wi, const in vec3 wo, const in vec3 normal) {
    return sameHemiSphere(wo, wi, normal) ? abs(dot(normal, wi))/PI : 0.;
}

// Function 1165
float rayMarch( in vec3 ro, in vec3 rd, float tmax )
{
    float t = 0.0;
    
    // bounding plane
    float h = (1.0-ro.y)/rd.y;
    if( h>0.0 ) t=h;

    // raymarch 30 steps    
    for( int i=0; i<30; i++ )    
    {        
        vec3 pos = ro + t*rd;
        float h = map( pos );
        if( h<0.001 || t>tmax ) break;
        t += h;
    }
    return t;    
}

// Function 1166
vec3 getNormalMesh(vec3 p){vec2 b=vec2(0,.00001);return Derivative9Tap(Dfm,p,b);}

// Function 1167
vec3 SurfaceNormal(in vec3 pos, in mat3 matrix)
{
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    return normalize(-vec3(Pentagram((pos + eps.xyy) * matrix) - Pentagram((pos - eps.xyy) * matrix),
                           Pentagram((pos + eps.yxy) * matrix) - Pentagram((pos - eps.yxy) * matrix),
                           Pentagram((pos + eps.yyx) * matrix) - Pentagram((pos - eps.yyx) * matrix)));
}

// Function 1168
vec4 ray(vec2 rs, vec2 uv) {
    vec3 cuv = vec3(uv-vec2(0.5), 1);
    for (int t = 0; t < 150; t++) {
    	vec3 p = vec3(rs, .5)+cuv*(float(t)/128.0);
        if (inters(p)) return vec4(texture(iChannel0, p.xy/2.0).rgb, 1);
    }
    return vec4(0);
}

// Function 1169
float intersectRayTri(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {
  const float eps = 0.0000001;

  vec3 e1 = v1 - v0;
  vec3 e2 = v2 - v0;
  vec3 h = cross(rd, e2);
  float a = dot(e1, h);
  if (a > -eps && a < eps) {
    return -1.0;
  }

  float f = 1.0 / a;
  vec3 s = ro - v0;
  float u = f * dot(s, h);
  if (u < 0.0 || u > 1.0) {
    return -1.0;
  }

  vec3 q = cross(s, e1);
  float v = f * dot(rd, q);
  if (v < 0.0 || u + v > 1.0) {
    return -1.0;
  }

  float t = f * dot(e2, q);
  if (t < eps) {
    return -1.0;
  }

  return t;
}

// Function 1170
vec4 castRay(vec3 ro, vec3 rd, int steps)
{
    float t   = i_kNear, stepLength = 0., prevRad = i_kFar, prevErr = i_kFar, err, k = 1.2;
    vec2  res = vec2(1);
    for (; (steps >= 0) && (t < i_kFar); --steps)
    {
        res = mapScene(ro + rd * t);
        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);
        if (sor)
        {
            stepLength-= k * stepLength;
            k = 1.;            
        }        
        else
            stepLength = res.x * k;

        prevRad = res.x;
        err = res.x / t;
        if (!sor)
        {
            if (err < prevErr     ) { res.x = t; prevErr = err; }
            if (err < gTexelRadius) break;
        }
        t  += stepLength;
    }
    return vec4(t, res.xy, steps);
}

// Function 1171
vec3 getNormal(vec3 p, float t){
    float e = (MINDIST + .0001) *t;
    vec2 h = vec2(1.,-1.)*.5773;
    return normalize( h.xyy*map( p + h.xyy*e ,0.).x + 
					  h.yyx*map( p + h.yyx*e ,0.).x + 
					  h.yxy*map( p + h.yxy*e ,0.).x + 
					  h.xxx*map( p + h.xxx*e ,0.).x );
}

// Function 1172
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.01;
    float t = tmin;
    float m = 0.0;
    for( int i=0; i<30; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.;
    return vec2( t, m );
}

// Function 1173
float intersectionRayBox(vec3 o, vec3 d, vec3 ext, out vec3 r0, out vec3 nrm, out vec2 t) {
    vec3 t0 = (-o - ext) / d;
    vec3 t1 = (-o + ext) / d;
    vec3 n = min(t0,t1); t.x = max(max(n.x,n.y),n.z);
    vec3 f = max(t0,t1); t.y = min(min(f.x,f.y),f.z);
    r0 = o + d * t.x;
    nrm = abs(r0/ext);
    nrm = step(vec3(max(max(nrm.x,nrm.y),nrm.z)),nrm) * sign(r0);
    return step(t.x,t.y);
}

// Function 1174
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start
          dt = 0.,
         den = 0., _den, lut, dv;
    for(int i=0; i<150; i++) 
    {
        vec3 pos = ro + t*rd;
        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;
        _den = den; den = map(pos);  // raw density
        if( abs(pos.x) > .5 )        // cut a slice 
        {
            dv = -.6+sin(2.*iTime);  // explore isovalues
            lut = LUTs( _den+dv, den+dv ); // shaped through transfer function
            if (lut>.01)             // not empty space
            { 
                vec3  col = mix(hue(.1*pos.z) , vec3(1), .8);
                col = mix( col , bgcol, 1.-exp(-.003*t*t) ); // fog
                sum += (1.-sum.a) * vec4(col,1)* (lut* dt*10.); // blend. Original was improperly just den*.4;
            }  }
        t += dt = max(.05,.02*t);     // stepping
    }

    return sqrt(1.-sum);              // black on white + sRGB
}

// Function 1175
vec3 raymatch_iter2(vec3 ro , vec3 rd ) {

        vec3 rp = ro;
        float s = 0.0;
        const int mstep = 20;
        const float eps = 0.0001;
        for (int i = 0; i < mstep ; i++) {

                s = obj(rp);

                rp = rp + rd*s;
        }

        vec3 n = est_normal(rp);
        vec3 ret = vec3(0.0);

        if (abs(s) < eps) {
            ret = vec3(1.0)*lambert(n, l);
         }

        return ret;

}

// Function 1176
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<150; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 1177
vec3 Scene_GetNormal(const in vec3 vPos, const int iInsideObject)
{
    const float fDelta = 0.001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta, iInsideObject ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta, iInsideObject ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta, iInsideObject ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta, iInsideObject ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
}

// Function 1178
vec3 getRays(vec2 coord, out float mask){
    
    const int numSteps = int(Num_Steps * Density);
    int weight = 0;
    
    vec3 gr = vec3(0.0);
    
    vec2 mouseCoord = coord.xy - (iMouse.xy / iResolution.xy);
    
    vec2 delta = (mouseCoord) * (Density / float(numSteps));
    vec2 customTexcoord = coord.st;
    
    float visibility = 1.0-sqrt(pow(mouseCoord.x,2.0) + pow(mouseCoord.y,2.0));
    visibility = pow(visibility,1.0);
    visibility += pow(visibility,2.0);
    visibility = clamp(visibility,0.0,1.0);
    visibility = 1.0;
	
    for(int i = 0; i < numSteps; i++){
        
        customTexcoord -= delta;
    	float noise = getNoiseTexture(customTexcoord);
        
        gr += getTexure(customTexcoord.st + delta * noise);
        
        weight++;
    }
    
    gr /= float(weight);
    gr *= visibility;
    mask = (gr.r + gr.g + gr.b) / 3.0;
    mask = pow(mask,2.2);
    gr *= mask;
    gr = max(gr,0.0);
    
    return gr;
    
}

// Function 1179
vec3 getNormal(vec2 uv) {
    return textureLod(iChannel0, uv, 0.).xyz;
}

// Function 1180
vec4 SPLINE_PointArray(int i, SPLINE_CtrlPts ctrlPts)
{
    //Just a way to get around the fact global arrays do not support random index access.
    //(only texture/resources)
    if(i==0 || i==SPLINE_POINT_COUNT  ) return ctrlPts.p[0];
    if(i==1 || i==SPLINE_POINT_COUNT+1) return ctrlPts.p[1];
    if(i==2 || i==SPLINE_POINT_COUNT+2) return ctrlPts.p[2];
    if(i==3) return ctrlPts.p[3];
    if(i==4) return ctrlPts.p[4];
    if(i==5) return ctrlPts.p[5];
    if(i==6) return ctrlPts.p[6];
    if(i==7) return ctrlPts.p[7];
    return vec4(0);
}

// Function 1181
bool rayTracing( vec3 ro, vec3 rd, out float t ) {
//    t = 0.0;
//    for (int i = 0; i < NUM_STEPS; i++) {
//        float d = sdf(ro + t * rd);
//        if (abs(d) < EPSILON) return true;
//        t -= d / grad(ro, rd, t);
//    }
//    return false;
//}

// Function 1182
vec3 reCalcNormalSlow(vec2 uv)
{
    float offsetPixel = 1.0;
    vec3 center = reCalcWorldPosition(uv);
    return calcNormal(center);
}

// Function 1183
vec3 rayMarch(ray marcher){
    float epsilon = 0.001;
    float t = 0., d, d2;
    vec3 targetSphere = sphere1Pos;
    float targetRad = sphere1Rad;
    vec3 point;
    
    for (float i = 0.; i < maxIterations; i++){
        point = marcher.position + marcher.direction * t;
        
        d = distFunc(point);
        if (d < epsilon){
            // Calc phong illumination
            vec3 normal = getNormal(point);
            vec3 light1Dir = normalize(lightPos - point);
            vec3 viewDir = normalize(eye - point);
            vec3 reflection1 = reflect(light1Dir, normal);
            // Add the ambient component
            float Ip = test.amb;
            // Add the diffuse component
            Ip += max(0., test.diff * dot(light1Dir, normal));
            // Add the specular component
            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));
            return Ip * vec3(.816, 0.26, .96); //getNormal(point);
        }
        
        d2 = faceFunc(point);
        if (d2 < epsilon){
            // Calc phong illumination
            vec3 normal = getNormalFace(point);
            vec3 light1Dir = normalize(lightPos - point);
            vec3 viewDir = normalize(eye - point);
            vec3 reflection1 = reflect(light1Dir, normal);
            // Add the ambient component
            float Ip = test.amb;
            // Add the diffuse component
            Ip += max(0., test.diff * dot(light1Dir, normal));
            // Add the specular component
            Ip += max(0., pow(test.spec * dot(reflection1, viewDir), test.shiny));
            return Ip * vec3(1.);
        }
        
        t+=min(d, d2);
    }
    return vec3(0.);
}

// Function 1184
vec3 getNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1185
vec2 raycast(Ray r) {
    vec2 ret = vec2(MAX_T, -1.0);
    float t = MAX_T;
    t = IntersectPlane(r, scene.ps[0]);
    if(t>0.0 && t<ret.x) {
        ret.x = t;
        ret.y = 0.0;
    }
    t = IntersectSphere(r, scene.sphs[0]);
    if(t>0.0 && t<ret.x) {
        ret.x = t;
        ret.y = 1.0;
    }
    t = IntersectSphere(r, scene.sphs[1]);
    if(t>0.0 && t<ret.x) {
        ret.x = t;
        ret.y = 2.0;
    }
    t = IntersectSphere(r, scene.sphs[2]);
    if(t>0.0 && t<ret.x) {
        ret.x = t;
        ret.y = 3.0;
    }
    t = IntersectSphere(r, scene.sphs[3]);
    if(t>0.0 && t<ret.x) {
        ret.x = t;
        ret.y = 4.0;
    }
    return ret;
}

// Function 1186
MarchResult raymarchScene(in vec3 ro, in vec3 rd, out vec4 scattering, in vec2 fragCoord)
{
    float tmin = 0.0;
    float tmax = 50.0;
    float t = tmin;
    float prevt = t;
    float d = 0.0, eps = 0.0;
    float prevd = d;
    float density = 0.0;
    float transmittance = 1.0;
    float stp = 0.0;
    vec3 inscatteredLight = vec3(0.0);
    vec3 inscatteredLightFromEquiAngularSampling = vec3(0.0);
    MarchResult result;
    int stepsEquiAngularSampling = 0;
    
    for (int i = 0; i < 300; ++i)
    {
        eps = t * 0.001;
        vec3 p = ro + t * rd;    
          
        density = (densityVoumetricFog(p * 253.0));
        integrateVolumetricFog(p, rd, density, stp, transmittance, inscatteredLight, fragCoord);
        if (stepsEquiAngularSampling < 32)
        {
            float u = rand(rand(fragCoord.x * iResolution.y + fragCoord.y + d * 1.5) + iTime + 1234.32598);
            float v = rand(rand(fragCoord.y * iResolution.x + fragCoord.x + d * 2.5) + iTime * 2.0 + 6234.32598);
            vec3 lightPos;
            vec3 lightCol;
            sampleAreaLight(vec2(u, v), lightPos, lightCol);

            float x0 = rand(rand(fragCoord.y * iResolution.y + fragCoord.x + d * 3.5 + iTime) + 236526.436346);
            // --- equi-angular sampling
            float DT = dot(lightPos - ro, rd);
            float D = length(ro + DT * rd - lightPos);
            float tha = atan(0.0 - DT, D);
            float thb = atan(length(tmax - ro) - DT, D);
            float tsampled = D * tan(mix(tha, thb, x0));
            float pdf = D / ((thb - tha) * (D * D + tsampled * tsampled));
            float x = DT + tsampled;
            vec3 sampledPos = ro + x * rd;
            
        	float densityFromSampledPos = (densityVoumetricFog(sampledPos * 253.0));
        	integrateVolumetricFogFromSampledPosition(sampledPos, rd, densityFromSampledPos, x, inscatteredLightFromEquiAngularSampling, lightPos, lightCol, pdf); 
        	stepsEquiAngularSampling++;        
        }
        
        SceneData res = intersectTerrain(p.xz);
        float h = res.sdf;
        d = p.y - h;
        
        vec3 prot = getRotation() * (p - AreaLightPosition);
        SceneData lightPlane = intersectBox(prot, AreaLightSize);
        SceneData terrain;
        terrain.sdf = d;
        terrain.materialID = res.materialID;
        SceneData scene = unite(terrain, lightPlane);
        d = scene.sdf;
        result.materialID = scene.materialID;
        if (d < eps)
            break;        
        
        stp = d * 0.32;
        prevt = t;
        prevd = d;
        t += stp;
        if (t > tmax)
            break;
    }
    if (t > tmax)
        t = -1.0;
    else
        t = mix(prevt, t, d/prevd);
    
    inscatteredLightFromEquiAngularSampling *= 1.0 / float(stepsEquiAngularSampling); 
    scattering = vec4(inscatteredLight + inscatteredLightFromEquiAngularSampling, transmittance);
    result.t = t;
    return result;
}

// Function 1187
vec3 calcNormal( in vec3 p ) {
    vec2 e = vec2( 0.01, 0.0 );
    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),
                            map( p + e.yxy ) - map( p - e.yxy ),
                            map( p + e.yyx ) - map( p - e.yyx ) ) );
}

// Function 1188
vec3 GetNormal(vec3 p)
{
    float d = GetDist(p);
    vec2 e = vec2(.01,0);

    vec3 n = d-vec3(
       GetDist(p-e.xyy),
       GetDist(p-e.yxy),
       GetDist(p-e.yyx));
     
     return normalize(n);
}

// Function 1189
bool castray_ground(vec3 orig,vec3 dir,int idx,out vec3 hitp,out vec3 hitnor,out vec4 col,out float mirr)
{
	//groundplane
	float c = -orig.y/dir.y;
	mirr = 0.2;
	hitp = orig + dir*c;
	hitp.y = 0.;
	hitnor = vec3(0.);
	hitnor.y = -sign(dir.y);
	vec2 gridfrac = hitp.xz*0.1;
	vec2 gridpos = floor(gridfrac);
	gridfrac -= gridpos;
	int sqgr = (int(floor(gridpos.x))^int(floor(gridpos.y)))&1;
	col = texture(iChannel0,gridfrac);
	if(sqgr==1)
		col = vec4(0.3,0.3,0.2,1.) + vec4(0.6,0.6,0.4,0.);
//	col = vec4(0.3,0.3,0.2,1.) + vec4(0.6,0.6,0.4,0.)*float(sqgr);
	return (c>0.);
//	return (c>0.)&&(sqgr==0);
}

// Function 1190
vec3 getRayColor( sRay ray ) {
    sHit i;
    march(ray, i, MARCHSTEPS, kTt); //256

    vec3 color;
    if(i.oid.x < 0.5) {
        color = getBackground(ray.rd);
    } else  {
        sSurf s;
        s.nor  = normal(i.hp, kTt);
        sMat m = getMaterial( i );
        s.ref  = getReflection(ray, i, s);
        if(m.trs > 0.0) s.tra = getTransparency(ray, i, s, m);
        color  = setColor(ray, i, s, m);
    }

    getFog(color, ray, i); // BUG? Is this intentional that color is not updated??
    return color;
}

// Function 1191
vec3 eliNormal( vec3 p, vec3 cen, vec3 rad )
{
    return normalize( (p-cen)/rad );
}

// Function 1192
vec3 normalFunction(int world, vec3 p)
{
	const float eps = 0.01;
	float m;
    vec3 n = vec3( (distf(world,vec3(p.x-eps,p.y,p.z),m) - distf(world,vec3(p.x+eps,p.y,p.z),m)),
                   (distf(world,vec3(p.x,p.y-eps,p.z),m) - distf(world,vec3(p.x,p.y+eps,p.z),m)),
                   (distf(world,vec3(p.x,p.y,p.z-eps),m) - distf(world,vec3(p.x,p.y,p.z+eps),m))
				 );
    return normalize( n );
}

// Function 1193
vec2 raymarch(vec3 ori, vec3 dir, int iter) {
    float  t = 0.;
    float id = -1.;
    for(int i = 0; i < MAX_ITERATIONS; i++) {
        if(t >= MAX_DISTANCE || i >= iter) {
        	break;   
        }
    	vec2 scn = dstScene(ori+dir*t);
        if(scn.x < EPSILON) {
        	id = scn.y;
            break;   
        }
        t += scn.x * .75;
    }
    return vec2(t,id);
}

// Function 1194
vec3 NormalBlend_UDN(vec3 n1, vec3 n2)
{
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;    
    
	return normalize(vec3(n1.xy + n2.xy, n1.z));
}

// Function 1195
float rayf(float t) {
#if 1
    poly2 f = pa_map(ro, rd, t);
    return f.a[0]*coeff_scale;
#elif 0
    prepare_ray(t, 0.5);
    poly2 f = pa_map(ro, rd, 0.0);
    return f.a[2]*coeff_scale;
#else
    poly2 f = pa_map(ro, rd, 0.0);
    return pa_f(f.a, t).x*coeff_scale;
#endif
}

// Function 1196
vec3 calcNormal(vec3 p)
{
    vec2 e = vec2(eps, 0);
    return normalize(vec3(
        map(p+e.xyy)-map(p-e.xyy),
        map(p+e.yxy)-map(p-e.yxy),
        map(p+e.yyx)-map(p-e.yyx)
        ));
}

// Function 1197
vec3 getNormal(vec3 pos){ // this gets the normal
						  // if you understand, good. if not, not much I can do.
	vec2 eps = vec2(0.0, EPS);
	return normalize(vec3( // always normalise directions godammit
			scenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),
			scenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),
			scenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));
}

// Function 1198
float ray_radius(ray_t ray,float t) {
	return ray.r_start + abs(t*ray.r_per);
}

// Function 1199
bool sunRay( in vec3 ro, in vec3 rd, out float resS )
{
    const float rayStep = 10.0;
    const float nearClip = 0.1;
    const float farClip = 100.0;
    float t = 0.1;
    vec3 p = ro + rd*t;
    float h = soup( p.x, p.z );
    if ( p.y < h )
    {
        resS = 0.42;

        return true;
    }
    vec3 fuzzballN;
    float fuzzballDisp;
    if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )
    {
        resS = 0.42;

        return true;
    }
    
    // cast larger shadow from fuzzball
    float fuzzballDist = length( fuzzballSoupPos-ro );
    p = ro+rd*fuzzballDist;
    if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )
    {
        resS = 0.42;

        return true;
    }
    
    resS = 1.0;
    
    return false;
}

// Function 1200
vec3 donormal(Surface surface, vec3 p) {
  return goursatnormal(surface,p);
}

// Function 1201
vec4 GenerateNormalHeightMultipass (sampler2D tex, vec2 uv, vec2 res)
{
    float dist = 0.5;
    vec4 multi;
	multi += GenerateNormalHeight(tex, uv, res, 1. * dist);
	multi += GenerateNormalHeight(tex, uv, res, 2.5 * dist);
	multi += GenerateNormalHeight(tex, uv, res, 5. * dist);
	multi += GenerateNormalHeight(tex, uv, res, 10. * dist);    
    multi *= 0.25;
    return multi;
}

// Function 1202
vec3 computeNormal(vec3 pos, vec3 lightPos) {
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),
                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),
                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));
}

// Function 1203
vec3 nvGeometryNormal(in vec3 p) {
    float sdXA, sdXB, sdYA, sdYB, sdZA, sdZB;

    const float eps = 1e-2;
    sdGeometry(p - vec3(eps, 0.0, 0.0), sdXA);
    sdGeometry(p + vec3(eps, 0.0, 0.0), sdXB);
    sdGeometry(p - vec3(0.0, eps, 0.0), sdYA);
    sdGeometry(p + vec3(0.0, eps, 0.0), sdYB);
    sdGeometry(p - vec3(0.0, 0.0, eps), sdZA);
    sdGeometry(p + vec3(0.0, 0.0, eps), sdZB);

    return normalize(vec3(sdXB-sdXA, sdYB-sdYA, sdZB-sdZA));
}

// Function 1204
vec3 normalEstimation(vec3 pos, float time){
  vec2 k = vec2(MinDist, 0);
  return normalize(vec3(sdf(pos + k.xyy, time) - sdf(pos - k.xyy, time),
	  					sdf(pos + k.yxy, time) - sdf(pos - k.yxy, time),
  						sdf(pos + k.yyx, time) - sdf(pos - k.yyx, time)));
}

// Function 1205
vec4 raymarch(vec3 p, vec3 d)
{
    float S = 0.0;
    float T = S;
    vec3 D = normalize(d);
    vec3 P = p+D*S;
    for(int i = 0;i<240;i++)
    {
        S = model(P);
        T += S;
        P += D*S;
        if ((T>MAX) || (S<PRE)) {break;}
    }
    return vec4(P,min(T/MAX,1.0));
}

// Function 1206
vec3 rayDirection(vec3 cameraDir, vec2 uv){
    
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;
	return normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 1207
vec4 ray(mat4 transformation, mat4 inv) {
 
  // Sphere collision
  vec4 p = transformation * vec4(0,0,0,1);
  float distance_squared = dot(p.xy, p.xy);
    
  if (distance_squared < 1.0) {
      // calculate collision position
      vec3 norm = vec3(-p.x, -p.y, - sqrt(1.0 - distance_squared));
      vec3 spec = reflect(vec3(0, 0, 1), norm);
      return texture(iChannel0, (inv * vec4(spec, 0)).xyz) * 0.8 +
           vec4(0.1); // ambient light
  }

  return texture(iChannel0, (inv * vec4(0,0,1,0)).xyz);
}

// Function 1208
Ray computeLightRay(HitRecord hit)
{
    Ray r;
    r.origin = hit.P;
    
    vec3 distToLight = (glowSphere.center - hit.P) - glowSphere.radius * glowSphere.radius;
        
    r.direction = normalize(distToLight);
    r.mint = 0.0;
    r.maxt = length(distToLight);
    return r;
}

// Function 1209
vec4 Raymarch_Sprite( vec2 fragCoord, vec4 vSpriteInfo )
{
    vec4 vResult = vec4( 0 );
    
    vec2 vSpritePos = fragCoord - vSpriteInfo.xy;
    float fSpriteX = vSpritePos.x - vSpriteInfo.z * 0.5;
    
    float fRotation = g_scene.fCameraRotation;
    
    //fRotation += iTime;
    
    vec3 vCameraPos;
    vCameraPos.x = cos(fRotation) * fSpriteX;
    vCameraPos.y = vSpritePos.y;
    vCameraPos.z = sin(fRotation) * fSpriteX;
    
    vec3 vCameraDir = vec3(-sin(fRotation), 0, cos(fRotation));
    
    vCameraPos -= vCameraDir * 200.0;

	SceneResult sceneResult = Scene_Trace( vCameraPos, vCameraDir, 1000.0 );
    
    if ( sceneResult.fDist > 400.0 )
    {
        return vResult;
    }

    vec3 vHitPos = vCameraPos + vCameraDir * sceneResult.fDist;
    
    vec3 vNormal = Scene_GetNormal( vHitPos );
    
    float fShade = max( 0.0, dot( vNormal, g_scene.vLightDir ) );
    
    float fSpecIntensity = 1.0;
    
    float fFBM1 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4), 0.2 );    
    float fFBM2 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4) + 5.0, 0.5 );
    vec3 vDiffuseCol = vec3(1.);
    if ( sceneResult.fObjectId == MAT_CHARACTER )
    {
        float fUniformBlend = smoothstep( 0.5, 0.6, fFBM1 );
        
        vDiffuseCol = mix( g_scene.charDef.vUniformColor0, 
                          g_scene.charDef.vUniformColor1, 
                          fUniformBlend );
        
        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vSkinColor, step(2.2,sceneResult.vUVW.x) );

        float fBootBlend = step(sceneResult.vUVW.x, .4);
        
        fBootBlend = max( fBootBlend, step( abs(2.5 - sceneResult.vUVW.x), 0.2 ) ); // arm thing
        
        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vBootsColor, fBootBlend );
                
        float fGoreBlend = smoothstep( 0.6, 0.7, fFBM2 );
        fGoreBlend = max( fGoreBlend, step(2.9,sceneResult.vUVW.x) ); // bloody hands
        
        vDiffuseCol = mix( vDiffuseCol, 
                          vec3(1,0,0), 
                          fGoreBlend );
        
        //vDiffuseCol = fract(sceneResult.vUVW);//g_scene.charDef.vCol;
        //vDiffuseCol = sceneResult.vUVW.xxx / 5.0;//g_scene.charDef.vCol;
    }
    else if ( sceneResult.fObjectId == MAT_SHOTGUN )
    {
        vDiffuseCol = vec3( 0.2 );
    }
    else if ( sceneResult.fObjectId == MAT_WOOD )
    {
        vDiffuseCol = vec3( 0.4, 0.2, .1 );
    }
    else if ( sceneResult.fObjectId == MAT_HEAD )
    {
        vDiffuseCol = g_scene.charDef.vSkinColor;
        float fHairBlend = step( sceneResult.vUVW.x + fFBM1 * 0.5, 0.1 );
        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vHairColor, fHairBlend );
    }
    else if ( sceneResult.fObjectId == MAT_EYE )
    {
        vDiffuseCol = g_scene.charDef.vEyeColor;
    }
    else if ( sceneResult.fObjectId == MAT_GREY )
    {
        vDiffuseCol = vec3( 0.2 );
        fSpecIntensity = 0.1;
    }
    
    vec3 vDiffuseLight = g_scene.vAmbientLight + fShade * g_scene.vLightColor;
    vResult.rgb = vDiffuseCol * vDiffuseLight;
    
    vec3 vRefl = reflect( vec3(0, 0, 1), vNormal );
    float fDot = max(0.0, dot( vRefl, g_scene.vLightDir )) * fShade;
    float fSpec = pow( fDot, 5.0 );
    vResult.rgb += fSpec * fSpecIntensity;
    
    vResult.rgb = 1.0 - exp2( vResult.rgb * -2.0 );
    vResult.rgb = pow( vResult.rgb, vec3(1.0 / 1.5) );
    
    vResult.a = 1.0;
    
    return vResult;
}

// Function 1210
vec3 normal(in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.0001;
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 1211
vec3 calcNormal( vec3 pos )
{
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e * SDF(pos+0.0005*e);
    }
    return normalize(n);
}

// Function 1212
vec3 sceneNormal(in vec3 pos, in float t )
{
    float eps = 0.0001;
    vec3 n;
    float m;
    float d = scene(pos, m, t);
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z), m, t ) - d;
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z), m, t ) - d;
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps), m, t ) - d;
    return normalize(n);
}

// Function 1213
vec2 solveGrayScott(float feed, float kill, vec2 uv, vec4 uplus, vec4 ucross, vec4 vplus, vec4 vcross) 
{

    vec2 duv;

    #ifdef USE_NINE
    duv.x = diff.x*lapnine(uv.x, uplus, ucross);
    duv.y = diff.y*lapnine(uv.y, vplus, vcross);
    #else 
    duv.x = diff.x*lap(uv.x, uplus);
    duv.y = diff.y*lap(uv.y, vplus);
    #endif
    duv.x += - uv.x*uv.y*uv.y + feed*(1.0 - uv.x);
    duv.y += uv.x*uv.y*uv.y - (feed+kill)*uv.y;

    return uv + dt*duv;;
}

// Function 1214
float NormalDistributionGGX(float NdotH, float roughness)
{    
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH2 = NdotH * NdotH;
    
    float numerator = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom *= denom * PI;
    
    return numerator / denom;
}

// Function 1215
vec3 colorNormal(float t) {
  float r = .529-.054*t+.55*cos(5.498*t+2.779);
  float g = .21+.512*t+.622*cos(4.817*t-1.552);
  float b = .602-.212*t+.569*cos(5.266*t+2.861);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}

// Function 1216
vec3 rayMin(vec3 a, vec3 b) {
    return a.z < b.z ? a : b;
}

// Function 1217
float ray(v1 u){if(u.x>0.)return length(u);return u.y;}

// Function 1218
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<60; i++ )
    {
		if( abs(h)<precis || t>maxd ) break;  {
			t += h;
			vec2 res = map( ro+rd*t );
			h = res.x;
			m = res.y;
		}
    }

    if( t>maxd ) m=-1.0;
    return vec2( t, m );
}

// Function 1219
vec4 draw_ray(vec4 col, vec2 p, vec2 a, vec2 b)
{
	float h = line(p, a, b);
    col = blend(col, vec4(0., 0.435, 1., smoothstep(0.01, 0., abs(h))));
    return col;
}

// Function 1220
float Reflectance0(float n1, float n2) {
	float sqrt_R0 = (n1 - n2) / (n1 + n2);
	return sqrt_R0 * sqrt_R0;
}

// Function 1221
vec3 fetch_normal(in vec3 uvw, in vec3 rd, in float dt)
{
	vec3 gradient;

	gradient.x = fetch_distance(uvw + (vec3(dt, 0.0f, 0.0f) * rd)) - fetch_distance(uvw - (vec3(dt, 0.0f, 0.0f) * rd));
	gradient.y = fetch_distance(uvw + (vec3(0.0f, dt, 0.0f) * rd)) - fetch_distance(uvw - (vec3(0.0f, dt, 0.0f) * rd));
	gradient.z = fetch_distance(uvw + (vec3(0.0f, 0.0f, dt) * rd)) - fetch_distance(uvw - (vec3(0.0f, 0.0f, dt) * rd));

    // bugfix: nan, add epsilon
	return( -normalize(gradient + EPSILON) ); // normal from central differences (gradient) 
}

// Function 1222
vec3 calcNormalTransparent( in vec3 pos, in float eps )
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + 
					  e.yyx*mapTransparent( pos + e.yyx, kk ).x + 
					  e.yxy*mapTransparent( pos + e.yxy, kk ).x + 
					  e.xxx*mapTransparent( pos + e.xxx, kk ).x );
}

// Function 1223
bool refract_me(in float3 v,in float3 n,in float ni_over_nt,out float3 refracted)
{
	float3 uv = normalize(v);
    float dt = dot(uv, n);
    float discriminant = 1.0 - ni_over_nt*ni_over_nt*(1.0-
                                                      dt*dt);
    if(discriminant > 0.0)
    {
    	refracted = ni_over_nt*(uv - n*dt) - n*sqrt(discriminant);     
        return true;
    }
    else
    {
    	return false;
    }
}

// Function 1224
void RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )
{
    float stepScale = 1.0;
#ifdef ENABLE_CONE_STEPPING
    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );
    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); // represents the biggest gradient in our heightfield
    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );

    float fRdotG = dot( vRayProfile, vGradPerp );
    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );

    stepScale = -fOdotG / fRdotG;

    if ( stepScale < 0.0 )
    {
        intersection.m_objId = OBJ_ID_SKY;
        intersection.m_dist = k_fFarClip;
        return;
    }
#endif
    
    intersection.m_dist = 0.01;
    intersection.m_objId = OBJ_ID_SKY;
    
    float fSceneDist = 0.0;
    
    float oldT = 0.01;
    for( int iter = 0; iter < k_raymarchSteps; iter++ )
    {
        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;
      
        // into sky - early out
        if ( vRayDir.y > 0.0 )
        {
            if( vPos.y > 1.0 )
            {
                intersection.m_objId = OBJ_ID_SKY;
                intersection.m_dist = k_fFarClip;
                break;
            }
        }

      
        fSceneDist = GetSceneDistance( vPos );

        oldT = intersection.m_dist;
        intersection.m_dist += fSceneDist * stepScale;
                
        intersection.m_objId = OBJ_ID_GROUND;
        if ( fSceneDist <= 0.01 )
        {
            break;
        }

        if ( intersection.m_dist > k_fFarClip )
        {
            intersection.m_objId = OBJ_ID_SKY;
            intersection.m_dist = k_fFarClip;
            break;
        }        

        
    }    
    
    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;
}

// Function 1225
vec2 getNormal(vec2 p)
{    
	vec2 e = vec2(P,0);
    return normalize(vec2(scene(p+e.xy)-scene(p-e.xy),scene(p+e.yx)-scene(p-e.yx)));
}

// Function 1226
void MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)
{
	vec2 ooR = 1./iResolution.xy;
    vec2 q = fragCoord.xy * ooR;
    vec2 p =  2.*q -1.;
    p.x *= iResolution.x * ooR.y;
	
    vec3 lookAt = //vec3(-4.,-8.,0.);
					//vec3(0.2349,0.737,-2.49);
					vec3(0.);
	float t = sin(iTime*.5)*2.5;
	eye = vec3(2.5,5.,-2.5) * 1.; // (t+2.);
//	eye = RotY(eye,smoothstep(0.,1.,t)*-0.5*pi);	
	eye = RotY(eye,iTime);
	
    // camera frame
    vec3 fo = normalize(lookAt-eye);
    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));
    vec3 up = normalize(cross(fo,ri));
     
    float fov = .25;
	
    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);
}

// Function 1227
vec3 RayMarchGlass(vec2 uv, vec3 ro, vec3 dir) {
    float traveled = 0.0;
    float everythingTraveled = 0.0;
    
    vec2 distAndMaterial = vec2(0);
    vec2 dnmEverythingElse = vec2(0);
    
    vec3 impact = vec3(1.0);
    bool goneTooFar = false;
    bool everythingsGoneTooFar = false;
    bool hitGlass = false;
    bool hitOtherThings = false;
    
    for (int i=ZERO; i < 100; ++i){
        dnmEverythingElse = sceneWithMaterials(ro + dir * everythingTraveled);
        everythingTraveled += dnmEverythingElse.x;
        
#ifndef WITHOUTKODOS
        distAndMaterial = sceneWithGlassMaterials(ro + dir * traveled);
        traveled += distAndMaterial.x;
#endif
        
        if (dnmEverythingElse.x < .01) {
            hitOtherThings = true;
        }
        
#ifndef WITHOUTKODOS
        if (distAndMaterial.x < .01) {
            hitGlass = true;
        }
        
        
        if (distAndMaterial.x > MAXDISTANCE) {
            goneTooFar = true;
        }
#endif
        
        if (dnmEverythingElse.x > MAXDISTANCE) {
            everythingsGoneTooFar = true;
        }
        
#ifndef WITHOUTKODOS
        if (hitGlass && (hitOtherThings || everythingsGoneTooFar)) {
            break;
        }
        
        if (hitOtherThings && (goneTooFar || hitGlass)) {
            break;
        }
        
        if (goneTooFar && everythingsGoneTooFar) {
            break;
        }
#else
        if (hitOtherThings) {
            break;
        }
        
        if (everythingsGoneTooFar) {
            break;
        }
#endif
    }
    
    vec3 color = starryBackground(dir);
    
    if (hitGlass && hitOtherThings) {
        vec3 scenePoint = ro + dir * everythingTraveled;
        vec3 glassPoint = ro + dir * traveled;
        
        float sceneDistance = distance(ro, scenePoint);
        float glassDistance = distance(ro, glassPoint);
        
        if (glassDistance >= sceneDistance) {
            hitGlass = false;
        } else {
            hitOtherThings = false;
        }
    }
    
    if (hitOtherThings) {
        vec3 hitPoint = ro + dir * everythingTraveled;
        color = GetColor(dnmEverythingElse, hitPoint, everythingTraveled, dir);
        return color;
    }
    
    if (hitGlass) {
        // Reflective/Refractive Surface
        color = vec3(71.0/255.0, 142.0/255.0, 232.0/255.0);;
        vec3 hitPoint = ro + dir * traveled;
        vec3 hitNormal = GetNormal1(hitPoint);
        
        vec3 refractionDirection = normalize(refract(hitNormal, -dir,1.0/1.6));
        
        bool outside = dot(dir, hitNormal) < 0.0;
        
        float surfaceWidth = 0.001;
        vec3 bias = surfaceWidth * hitNormal;
        
#ifdef ALLOWREFLECTIONS
        vec3 reflectionDirection = normalize(reflect(dir, hitNormal));
        vec3 reflectionRayOrig = outside ? hitPoint + bias : hitPoint - bias;
        vec3 reflectionColor = RayMarchReflection(reflectionRayOrig, reflectionDirection);
        float reflection = 0.04 + 0.96 * pow(1.0 - dot(-dir, hitNormal), 5.0);
#endif
        
        vec3 refractionRayOrig = outside ? hitPoint - bias : hitPoint + bias;
        vec4 refractionDandM = RayMarchInteriorGlass(refractionRayOrig, refractionDirection);
        vec3 newHit =  refractionRayOrig + refractionDirection * refractionDandM.w;
        vec3 newNormal = GetNormal2(hitPoint);
        
        float light = dot(newNormal, normalize( vec3(0,5,-5)))*.5+.5;
        float glassTravelDist =  1.-clamp(distance(refractionRayOrig, newHit) / 16.0, 0., 1.);
        
#ifdef ALLOWREFLECTIONS
        color = mix(reflectionColor*(1.0-reflection)+refractionDandM.xyz, color, 0.3);
        
        //color = reflectionColor*(1.0-reflection)+refractionDandM.xyz;
        //color = mix(reflectionColor*(1.0-reflection), color, 0.5);
#else
        color = refractionDandM.xyz;
#endif
        
        float glassLight = dot(hitNormal, normalize( vec3(0,5,-5)))*.5+.5;
        
        float specularStrength = 0.5;
        vec3 lightColor = vec3(1);
        vec3 viewDir = normalize(ro - hitPoint);
        vec3 reflectDir = reflect(-normalize( vec3(0,5,-5)), hitNormal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.);
        vec3 specular = specularStrength * spec * lightColor;
        
        color = color * (glassLight + specular);
        return color;
    }
    
    return color;
}

// Function 1228
float Raymarch(Camera camera, vec2 uv)
{    
    float totalDistance = 0.0;
    
    int bounceFrame = BounceFrame(iFrame);
    
    float maxDistance = MAX_DISTANCE;
    
    if(bounceFrame > 0)
		maxDistance = 15.0;
    
	for(int j = 0; j < MAX_STEPS; ++j)
	{
        vec3 p = camera.origin + camera.direction * totalDistance;
		float d = max(0.0, sdf(p));

		totalDistance += d;
                
		if(d < EPSILON || totalDistance > maxDistance)
            break;
	}
    
    return totalDistance;
}

// Function 1229
vec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)
{
    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;
	float distance_to_ray = length(cur_shpere.position - distance_point);
    
    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))
    {
        return vec3(0,0,0);
    }

    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));

	vec3 intersect_point = distance_point - (ray_dir * inner_line_length);

    return intersect_point;
}

// Function 1230
vec3 WorleyTangentSpaceNormal(vec3 pos) {
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),
                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),
                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));

}

// Function 1231
vec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {
  vec2 xy = fragCoord - size / 2.0;
  float z = size.y / tan(radians(fieldofView) / 2.0 );
  return normalize(vec3(xy,-z));
}

// Function 1232
vec4 select_plane_normal(vec4 b) {
    float lc = min(min(b.x, b.y), min(b.z, b.w));
    return step(b, vec4(lc));
}

// Function 1233
bool rayHitPiece( vec3 vo, vec3 vd, ivec2 c, out float dist, out vec3 norm )
{
	vec4 plane;
	vec3 center, px, py;
	piecePlane( c, plane, center, px, py );

	float d = dot( vd, plane.xyz );
	if ( abs( d ) < 0.0001 ) return false;
	dist = ( - plane.w - dot( vo, plane.xyz ) ) / d;
	if ( dist < 0.001 ) return false;

	vec3 p = vo + dist * vd;
	vec2 vg = vec2( dot( p - center, px ), dot( p - center, py ) );
	if ( vg.x < 0.0 || vg.x > c_fGlassWidth || vg.y < 0.0 || vg.y > c_fGlassHeight ) return false;
	float fvn = voronoi( vg, c );
	vec2 vc = pointInCell( c ); // cell center
	float fDistToCenter = length( vc - vg );
	float fd = fDistToCenter - fvn;
	norm = plane.xyz;
	return abs( fd ) < 0.001;
}

// Function 1234
bool isRefractive(int matID) {
    return (matID == 2);
}

// Function 1235
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  float dHit = dstFar;
  for (int j = 0; j < 150; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz, 0);
    if (h < 0.) break;
    sLo = s;
    s += max (0.15, 0.4 * h) + 0.008 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 10; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz, 0));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 1236
vec3 calcNormal(vec3 p) {
	float eps = 0.01;
	const vec3 v1 = vec3( 1.0,-1.0,-1.0);
	const vec3 v2 = vec3(-1.0,-1.0, 1.0);
	const vec3 v3 = vec3(-1.0, 1.0,-1.0);
	const vec3 v4 = vec3( 1.0, 1.0, 1.0);
	return normalize( v1 * map( p + v1*eps ) +
					  v2 * map( p + v2*eps ) +
					  v3 * map( p + v3*eps ) +
					  v4 * map( p + v4*eps ) );
}

// Function 1237
vec2 castRay( in vec3 ro, in vec3 rd )
{
  float tmin = 0.5;   // min & max ray distances
  float tmax = 12.0;

  #if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
  #endif

  float t = tmin;
  float m = -1.0;
  for( int i=0; i<64; i++ )
  {
    float precis = 0.0004*t;
    vec2 res = map( ro+rd*t );
    if( res.x<precis || t>tmax ) break;
    t += res.x;
    m = res.y;
  }

    if( t>tmax ) m=-1.0;
  return vec2( t, m );
  // return t=distance, m=material
}

// Function 1238
vec3 getNormal(vec3 pos, float e)
{  
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),
                          map(pos + q.xyx) - map(pos - q.xyx),
                          map(pos + q.xxy) - map(pos - q.xxy)));
}

// Function 1239
vec3 normal(vec3 rp){
    vec2 e = vec2(0.1,0.);
    float d = nearestSurface(rp);
    vec3 n = vec3(
        d-nearestSurface(rp-e.xyy),
        d-nearestSurface(rp-e.yxy),
        d-nearestSurface(rp-e.yyx)
    );
    return normalize(n);
}

// Function 1240
RayHit RayTraceScene(vec3 camPos, vec3 rayVec, const in int maxIter, bool cinematicHack)
{
    RayHit ray = Bike(camPos, rayVec, bikeAPos, bikeAAngle, 1.0);
    if (!cinematicHack) {
        ray = Union(ray, Bike(camPos, rayVec, bikeBPos, bikeBAngle, 5.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -1.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -2.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -3.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -4.0), 0.0));

        vec3 posI;
        RayHit voxels = MarchOneRay(camPos, rayVec, posI, maxIter);
        ray = Union(ray,voxels);

        // I/O Tower
        ray = Union(ray, BoxIntersect(camPos, rayVec, vec3(iotower.x, 0.25, iotower.y), vec3(0.5, 256.0, 0.5), 9.0));
    }
    return ray;
}

// Function 1241
float scene_raycast_object_shadows( Ray ray )
{
    float result = 1.;
    float t = SCN_ZFAR;
    vec3 albedo, N;
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );
        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_PRIMITIVE:
        result *= scene_obj_primitive( obj, localray, t, albedo, N );
        break;
        }
    }
    return max( 0., result );
}

// Function 1242
ivec4 normals_data(in int i) {
#  ifdef R
#    undef R
#  endif
#  define R(i,a,b,c,d) case i: r=ivec4(a,b,c,d); break;
  ivec4 r;
  switch(i) {
R(0x0000,0x2cfaf3aa,0x29fa97c8,0x316a0798,0x336ad76a)R(0x0001,0x2d4a0fbd,0x307a8397,0x308bb36f,0x303987ac)R(0x0002,0x2e690bc3,0x27a97be6,0x36483f6d,0x38997337)R(0x0003,0x36ab9b14,0x3bca4ecc,0x34295782,0x2fbc3761)R(0x0004,0x2f3b7f85,0x357ccadd,0x302d371f,0x3779734d)R(0x0005,0x39e87729,0x2f38ebbd,0x2bb87fda,0x3197bbaa)R(0x0006,0x3736bf55,0x3ba7fefe,0x3b56a2f8,0x3e386ea1)R(0x0007,0x3a8c0676,0x3f693232,0x3d8aee36,0x2ffb4f84)R(0x0008,0x2c5cf35c,0x2d4dcf16,0x29cc8786,0x332e1e76)R(0x0009,0x37ed421d,0x2dfe6ecc,0x31da2b90,0x3668336b)R(0x000a,0x38072b4b,0x2db873cc,0x32276fa2,0x2d2853d1)R(0x000b,0x37975755,0x3b5636ed,0x3ea6ee7e,0x3df6067c)R(0x000c,0x3fc76223,0x3b8c05ea,0x3fb869ca,0x3e2a85d5)R(0x000d,0x274c9392,0x28bb77b6,0x289e5715,0x26ed5b6a)R(0x000e,0x2a1f0eae,0x240d6772,0x339e45da,0x2eaefe4b)R(0x000f,0x381d15ae,0x24ba67e1,0x28795fe4,0x31d6739c)
R(0x0010,0x3205b78b,0x2a2847e3,0x31d8b3a4,0x2bd8cfd7)R(0x0011,0x36893b60,0x3c089af2,0x3f07266c,0x3f263e13)R(0x0012,0x3ea5c601,0x3f46adc2,0x3b7ba58a,0x3de79d4e)R(0x0013,0x3da9cd68,0x20ec7ba6,0x219ba7c5,0x23cf36d1)R(0x0014,0x223e5335,0x29df8e2f,0x252fb26d,0x1dbe3f3c)R(0x0015,0x1d4d936b,0x348dc57e,0x2e7f19e1,0x301eb59c)R(0x0016,0x383c5d4b,0x1e3a37ea,0x1f6943f8,0x24373ff8)R(0x0017,0x2a93e794,0x260553d7,0x22a8b3fb,0x2e29c7bb)R(0x0018,0x33398b8b,0x2709cbe4,0x37194f56,0x3a79730e)R(0x0019,0x3e095e95,0x3fa91205,0x3fb765d0,0x3e05a5a7)R(0x001a,0x3dc5e181,0x3c660d38,0x3a4ab916,0x3a26d8e2)R(0x001b,0x3b58c0fb,0x1cdc8ba0,0x1dab9bc6,0x207f92a0)R(0x001c,0x1eded707,0x2a9f75be,0x25bfd9ef,0x220fea36)R(0x001d,0x1c9e4f34,0x1b4e0747,0x1a6d5b70,0x341cdd09)R(0x001e,0x304e1935,0x2b5f055d,0x363b20cc,0x1a39efe7)R(0x001f,0x19987ff3,0x18e75bf0,0x1c53a7a8,0x1e82cb82)
R(0x0020,0x1b081bf8,0x1f9a1bec,0x2b0a37ca,0x2fe9e3a9)R(0x0021,0x313b4378,0x245a9fdd,0x2d6e5edc,0x3b2a56df)R(0x0022,0x3dbaea19,0x3f1945af,0x3e180153,0x3af57920)R(0x0023,0x3a364cf0,0x37d5d0c8,0x36c9aca9,0x35367c8d)R(0x0024,0x37a7dca8,0x19fbdfb4,0x1fbfb683,0x1e1f1ee4)R(0x0025,0x25df9d86,0x234fd9b2,0x234ff207,0x197e8315)R(0x0026,0x1b5e1343,0x189db352,0x15fcfb6d,0x314b588a)R(0x0027,0x2f0d0cc5,0x2bbde8df,0x262ef116,0x3189a861)R(0x0028,0x1669bbda,0x186833f0,0x1655a7cf,0x1493e38e)R(0x0029,0x1602b35b,0x17673fe9,0x1c1a97df,0x1e3adfdb)R(0x002a,0x2b19abd2,0x2ca96fcc,0x23cc73a3,0x213eeafd)R(0x002b,0x1cea43e7,0x24694bf3,0x2a4f2a98,0x30ceb246)R(0x002c,0x324e69ac,0x3d2a897d,0x3d68cd3e,0x39d7ccd2)R(0x002d,0x3685a8b5,0x34d67488,0x3405c88b,0x3335c880)R(0x002e,0x30b8444b,0x2e16d83a,0x121b379b,0x2ebdcf03)R(0x002f,0x1c5f62b8,0x25ee0f3e,0x22ef6545,0x256f8d71)
R(0x0030,0x3beb965e,0x1a7e0345,0x160deb2f,0x145e3b04)R(0x0031,0x150d634d,0x128c4f74,0x2e69f448,0x2c3c0874)R(0x0032,0x272da0a7,0x21ae8cdc,0x2e686c37,0x0ea937a6)R(0x0033,0x13d83bd8,0x15c607d3,0x18a35f90,0x15730b6b)R(0x0034,0x15735f7d,0x18a9d7e3,0x1b1b1bd0,0x193a33df)R(0x0035,0x298837e7,0x28184bed,0x170c4397,0x16fe86ff)R(0x0036,0x26ce970a,0x13a92bd1,0x1a584bf6,0x22a713f9)R(0x0037,0x2b4eb2d4,0x2cef462e,0x28cfa1d0,0x31ad50ff)R(0x0038,0x27eec912,0x395910cf,0x3866e4bd,0x33c6cc75)R(0x0039,0x30d5c464,0x2e35e849,0x2f75845c,0x2ce57049)R(0x003a,0x2cc64038,0x2b978c23,0x2cd7082f,0x101a879c)R(0x003b,0x39094332,0x30b9afa5,0x278a9bd3,0x212eccf4)R(0x003c,0x336b94b0,0x3dba0d7a,0x3df98294,0x3f691dc9)R(0x003d,0x1c6ab7dd,0x140c737b,0x162e3319,0x0e6de2c8)R(0x003e,0x184d2373,0x179b97b4,0x2e68d03a,0x2b1a6039)R(0x003f,0x276bdc50,0x208d5c84,0x1e9df8ad,0x30677c4a)
R(0x0040,0x181a97d2,0x1317dfd3,0x18349bbd,0x1e238ba7)R(0x0041,0x18e35f91,0x1bb8fbf6,0x1a5b93bf,0x19796feb)R(0x0042,0x11183fc4,0x25d62be8,0x1f454be0,0x089b5f12)R(0x0043,0x09cd6280,0x166f0aba,0x262ee6ed,0x29de6f01)R(0x0044,0x0b97ef89,0x113737c2,0x18b613e2,0x20f4bbd2)R(0x0045,0x24aeeaf4,0x26af8e7c,0x280fb612,0x185fbde0)R(0x0046,0x22afb280,0x2bbbd869,0x0dcd20f9,0x243bb840)R(0x0047,0x2af8cc21,0x3495e490,0x31655875,0x2ee5d850)R(0x0048,0x2be54845,0x27b56c2a,0x29152038,0x2d340479)R(0x0049,0x3504f0b3,0x34f6ec83,0x3717d09e,0x1b9b4bcc)R(0x004a,0x372c3adf,0x317b3776,0x262c2ba7,0x1a3c9b97)R(0x004b,0x23dcf473,0x34c7a07b,0x3bd86907,0x3b5c1e10)R(0x004c,0x39ab712f,0x0edbe75f,0x091bd703,0x10ae52c2)R(0x004d,0x04bbae7e,0x03abaa1f,0x132c8f6d,0x12ab5b9b)R(0x004e,0x30d8c44f,0x2a19b026,0x26ba7025,0x210bdc40)R(0x004f,0x1e1ce46d,0x1bdd8494,0x21bc2bb3,0x271b9fb9)
R(0x0050,0x2da897cc,0x3205cb8c,0x2eb70bc1,0x1e6b5fce)R(0x0051,0x1ae937f2,0x16b5bfd3,0x0a26ab6b,0x2393d7b0)R(0x0052,0x1fe2db87,0x071452da,0x0207aab2,0x032a8a95)R(0x0053,0x08dcd6a7,0x14fc238f,0x265e6321,0x29ae9eef)R(0x0054,0x26cecaf5,0x05a6df18,0x0a06135e,0x10651795)R(0x0055,0x18a413ad,0x1db2df86,0x299df72e,0x247f46c4)R(0x0056,0x2b9f6a2a,0x2fdee62e,0x126e86c7,0x07bd31fe)R(0x0057,0x2c2d4f48,0x1e6de757,0x27c9fc20,0x0549c8fd)R(0x0058,0x0f480c4b,0x26290c0e,0x24478805,0x29861826)R(0x0059,0x2f943488,0x2be3fc6f,0x3a4624f5,0x2664883d)R(0x005a,0x2035441e,0x22350825,0x24c3a059,0x2c214939)R(0x005b,0x35a32d28,0x3a051918,0x390768c3,0x3118ac51)R(0x005c,0x10cba77f,0x294f923f,0x252ee6f2,0x188ebef5)R(0x005d,0x0e2dc2d1,0x235af427,0x2fc70847,0x2d08742d)R(0x005e,0x32ca307a,0x2d0f0987,0x26ce78e9,0x06dc4e9a)R(0x005f,0x03db7266,0x031b4a3b,0x0119f622,0x00796603)
R(0x0060,0x00084a0a,0x0017cddf,0x0149aa5d,0x0017d5dd)R(0x0061,0x27296c15,0x24d9f415,0x225ad022,0x1eabc43d)R(0x0062,0x1b2c9864,0x170cbc7d,0x134bf78a,0x23ec1bb1)R(0x0063,0x2fdaef91,0x3757ab5b,0x3785df3c,0x2ec863c4)R(0x0064,0x253987ee,0x2194cfd3,0x1652fb6e,0x0565caf5)R(0x0065,0x24926b66,0x1da1631c,0x08034a9a,0x02455654)R(0x0066,0x02b76acb,0x0848e352,0x1627a3e5,0x20baafe1)R(0x0067,0x2afc3b8b,0x2aadbf36,0x307c3359,0x02e65eb8)R(0x0068,0x062542f5,0x0b03f71f,0x12a2df49,0x1511a700)R(0x0069,0x1df1671f,0x3a19bb11,0x393be6bc,0x3dbad22f)R(0x006a,0x3d7a667b,0x0e5dcad2,0x046be1b8,0x3668736a)R(0x006b,0x2c8b4fa3,0x276d0f79,0x1a6d6b6c,0x25dc2054)R(0x006c,0x1dc86c01,0x07383cbc,0x0dd5e070,0x17f47c45)R(0x006d,0x28543451,0x320bcca7,0x2244e029,0x21d51423)R(0x006e,0x2763d45b,0x2b73009c,0x27434873,0x35b65498)R(0x006f,0x22c3e44a,0x1ce4d42c,0x1725f425,0x19e4e032)
R(0x0070,0x1ea10107,0x21a06165,0x2ac1d0ed,0x31246892)R(0x0071,0x2cf7a82c,0x2688900c,0x0028ba1b,0x1fefd199)R(0x0072,0x1bbfd648,0x111eea5b,0x083d463b,0x1e581800)R(0x0073,0x28572c14,0x1d7ac021,0x222cfc71,0x1aaee90f)R(0x0074,0x047c0e06,0x028b0ddf,0x00c961be,0x00083dfa)R(0x0075,0x002895d8,0x00475a36,0x00f6724c,0x01961999)R(0x0076,0x0156b188,0x01d6e562,0x01b70166,0x20989c01)R(0x0077,0x21c96408,0x209a7819,0x1deb9438,0x195c0452)R(0x0078,0x138cf0a3,0x128af457,0x01f9569a,0x181acbce)R(0x0079,0x2bf963d1,0x31d59f8b,0x31347f6f,0x2bcad7b6)R(0x007a,0x2a069bdc,0x32789b9e,0x36846f19,0x2351631a)R(0x007b,0x13915acc,0x03553e90,0x2490b2c2,0x1df03a72)R(0x007c,0x0cb21a9c,0x0683423f,0x0d41d27d,0x071456dc)R(0x007d,0x0c36d38a,0x166557c9,0x1e0593e5,0x2327ebfc)R(0x007e,0x2eb743c2,0x31da0393,0x38584b49,0x0195aa33)R(0x007f,0x0454a68e,0x09034ec0,0x0dd252d5,0x11613e8e)
R(0x0080,0x1ad05a7d,0x3cf77ed5,0x3ef8ba73,0x3fd83a1c)R(0x0081,0x3e069293,0x087cf68a,0x039a3944,0x385452e8)R(0x0082,0x35d73370,0x2a2c039a,0x234e5b30,0x2f0c775b)R(0x0083,0x2eec336a,0x0dcd72ea,0x24ff795e,0x11eddcf7)R(0x0084,0x03b84d10,0x14a42065,0x0a373c8b,0x1124e867)R(0x0085,0x19332477,0x21225896,0x2ca1a514,0x38e4f101)R(0x0086,0x3d1b01ab,0x32ee65d4,0x22d2489b,0x2213146c)R(0x0087,0x1ea31c6a,0x279208c0,0x285260ad,0x2392f076)R(0x0088,0x27e67c19,0x1d039058,0x13951c4d,0x10d59058)R(0x0089,0x15159038,0x15e248bf,0x19c049a1,0x17f09570)R(0x008a,0x1d61d0bd,0x23b49834,0x2287d001,0x01079582)R(0x008b,0x156f69a6,0x0c3e35c0,0x071cc59d,0x12484c31)R(0x008c,0x1928b80d,0x111c2090,0x179d84a6,0x0f3df12c)R(0x008d,0x04ab997e,0x036a414c,0x05297cfa,0x002885d8)R(0x008e,0x001885ff,0x001891eb,0x00e70a69,0x00b68234)R(0x008f,0x00f605f7,0x001765f4,0x0037e5c4,0x01778969)
R(0x0090,0x1d37c802,0x1ca81002,0x1df89402,0x1e690804)R(0x0091,0x1cfa881d,0x167a2c2b,0x117c6c9a,0x0dccb4db)R(0x0092,0x0db9a469,0x00082deb,0x0567af1b,0x21b62ff0)R(0x0093,0x26c3efaa,0x212ba7c6,0x25eb9fbd,0x318a2b93)R(0x0094,0x1ca52fdb,0x3a171f20,0x3b440a4f,0x34b1fa38)R(0x0095,0x22702255,0x12811a8f,0x12c23318,0x04044a49)R(0x0096,0x23501225,0x1f5009cf,0x10b0f9fd,0x1560965c)R(0x0097,0x13c0ee8b,0x1fc072a9,0x1881e332,0x23a2ab77)R(0x0098,0x2873f7a3,0x2f23f770,0x34868b7c,0x37858732)R(0x0099,0x039491a6,0x0493ddf5,0x0822da57,0x0b821a70)R(0x009a,0x0ed13e0d,0x15a07223,0x1d9009e4,0x3cd5eaad)R(0x009b,0x3f77624a,0x3fc765e4,0x3fc73609,0x38c2f20f)R(0x009c,0x03bbb5e7,0x05e850d7,0x32c191cd,0x38f412c3)R(0x009d,0x37a6df4e,0x25cd576f,0x1d2ed305,0x2c9d5343)R(0x009e,0x369af332,0x352b8336,0x2ded4f36,0x0c8e1a6b)R(0x009f,0x2dbf360d,0x1b9f916e,0x079c012f,0x0176618e)
R(0x00a0,0x04f4417b,0x1790bd56,0x0e25ec6c,0x14c48057)R(0x00a1,0x1ef26492,0x256188de,0x3fa80640,0x389cda63)R(0x00a2,0x25c0d131,0x25e13104,0x1cb1d0bf,0x1bd1a8ce)R(0x00a3,0x23b0b138,0x2711111a,0x21d168de,0x1ae214b0)R(0x00a4,0x1f46d005,0x11435ca7,0x0b14ccb6,0x0ed40ca1)R(0x00a5,0x14750849,0x1363ac82,0x1610899f,0x1670a976)R(0x00a6,0x162204d1,0x1b74b432,0x01788d6a,0x091c210f)R(0x00a7,0x09990898,0x082a74d0,0x0d3a407b,0x011999a9)R(0x00a8,0x0a6c08ed,0x003739e2,0x00180220,0x0066c1e9)R(0x00a9,0x0007e9f5,0x0145f1c3,0x0018b1fd,0x00792dd1)R(0x00aa,0x1ac6f40b,0x1a57bc08,0x1b381005,0x1a089c0a)R(0x00ab,0x1518541f,0x123ae858,0x0dcd04f0,0x00c8f19f)R(0x00ac,0x01375685,0x13c48fa2,0x0288febb,0x095a7344)R(0x00ad,0x229927f7,0x3106d3a9,0x34a3c317,0x3471e227)R(0x00ae,0x36d289b1,0x31b159ee,0x24a0cacf,0x2972a75b)R(0x00af,0x1d3102f3,0x0ad20dcb,0x24b0399f,0x16d0e943)
R(0x00b0,0x178061b0,0x24104a76,0x224005ed,0x23a0bacd)R(0x00b1,0x24e08aa6,0x26009eaa,0x27c17309,0x2c32532d)R(0x00b2,0x35f3fb0b,0x07d4151f,0x07635d73,0x095259f2)R(0x00b3,0x0d91cd77,0x160085a5,0x1f306561,0x3e95c225)R(0x00b4,0x39c3c282,0x3d94fa02,0x037a2d47,0x08a66caf)R(0x00b5,0x2a916515,0x354211cf,0x3a644aa3,0x39169f2f)R(0x00b6,0x20ee8327,0x1e2ed308,0x296d8f4d,0x320c633a)R(0x00b7,0x2b4e6ef2,0x0f7ed1db,0x37ecca8f,0x31fe9229)R(0x00b8,0x22cfd9ad,0x125e9d46,0x045ad54a,0x0c91a61d)R(0x00b9,0x00f699a7,0x0d3181f6,0x18404227,0x238015d2)R(0x00ba,0x0fe43c8c,0x1ab3406b,0x21529087,0x2ad1bcf4)R(0x00bb,0x3692d692,0x3c183af1,0x3011558c,0x27609d63)R(0x00bc,0x26706d7e,0x2710599c,0x1f307d4e,0x17b0f931)R(0x00bd,0x10b2150d,0x0a336118,0x1301a11a,0x17b3287e)R(0x00be,0x19b57c23,0x1515583c,0x14d11147,0x18d041c0)R(0x00bf,0x1970b944,0x156214d2,0x15d47851,0x0149a19c)
R(0x00c0,0x05dbd95f,0x002741f1,0x0165a1ef,0x0017e5de)R(0x00c1,0x001851e4,0x005919df,0x00378630,0x00f9f1f0)R(0x00c2,0x0109f1e1,0x15468826,0x16778818,0x16e7dc14)R(0x00c3,0x13c77c27,0x14f77420,0x13d8d029,0x0b6b94c2)R(0x00c4,0x0048ede9,0x00288a20,0x0048763a,0x07b77f4b)R(0x00c5,0x249417b7,0x2931af14,0x2ab08638,0x303145a2)R(0x00c6,0x36023a11,0x34335b06,0x35a4a734,0x32820aa7)R(0x00c7,0x1f9005df,0x25e02615,0x20403a7a,0x2310bace)R(0x00c8,0x27f126e6,0x38a2f9cc,0x28c05211,0x0588e8e5)R(0x00c9,0x0a6510b7,0x3562419e,0x3a13a664,0x3ab69709)R(0x00ca,0x210ef6f8,0x20cf06f1,0x280df33b,0x2dddc712)R(0x00cb,0x280f8671,0x178f455d,0x3a8be687,0x3be7caf7)R(0x00cc,0x359dde19,0x28ef8daa,0x1a6f6555,0x0eedd527)R(0x00cd,0x043ac148,0x13f09a1c,0x17b04a24,0x16a06a42)R(0x00ce,0x02d59171,0x21d05e96,0x11b350a5,0x1a4248a4)R(0x00cf,0x2a11f0da,0x26b18ce4,0x3353330b,0x21d011c3)
R(0x00d0,0x1f1140ed,0x20d3a452,0x2c040070,0x1d138459)R(0x00d1,0x1cf021ae,0x2720599d,0x3002dcd6,0x1a535869)R(0x00d2,0x13744868,0x002899da,0x0116e26f,0x00387632)R(0x00d3,0x001855e1,0x00a931bd,0x013a05cd,0x02182eb4)R(0x00d4,0x021882b2,0x006931ea,0x001895ed,0x1475b439)R(0x00d5,0x1346f42e,0x14f72c22,0x08f8889e,0x0ba7a075)R(0x00d6,0x00084a06,0x0017ba25,0x0ce39b2b,0x1ae0a6b9)R(0x00d7,0x1c700de2,0x30f23ee3,0x26602ddd,0x3514ef49)R(0x00d8,0x39049ae7,0x3892edd7,0x30617975,0x0b66b480)R(0x00d9,0x3311e184,0x38e3021f,0x3b8a42d6,0x25cf46bb)R(0x00da,0x281ebeef,0x2bcefaa1,0x28cfae06,0x1e6e64ce)R(0x00db,0x3c16dee7,0x3c3b4e70,0x32e31309,0x38bcf63f)R(0x00dc,0x2d7f2dc8,0x1b5f694f,0x0ecdf135,0x04aa0117)R(0x00dd,0x1d0009f9,0x1b701606,0x15807623,0x1330ade6)R(0x00de,0x20507aac,0x0f31f137,0x1774e43c,0x1b9220aa)R(0x00df,0x24f174e3,0x30118962,0x2bd2e4a6,0x2e6288d9)
R(0x00e0,0x38f34d94,0x3592916e,0x3973a17c,0x33b410c4)R(0x00e1,0x29b5dc2b,0x1e26b407,0x0038363b,0x00288229)R(0x00e2,0x0218aab1,0x0088e9b8,0x01a9d591,0x0018a1ec)R(0x00e3,0x00786a51,0x00c89a67,0x00286dd8,0x001875ee)R(0x00e4,0x16e72417,0x0d17c063,0x0007c606,0x01958a23)R(0x00e5,0x01d55a16,0x1dc29375,0x2b23fb93,0x3334474a)R(0x00e6,0x35c2565d,0x3251b987,0x3412dd1e,0x3b9415c3)R(0x00e7,0x32ae5259,0x2b1f4274,0x2d4ec558,0x32c2fb04)R(0x00e8,0x38b4ff04,0x3d596eb3,0x1d806298,0x39fbd2a8)R(0x00e9,0x32ce623d,0x23afd1aa,0x166f315e,0x0ced6522)R(0x00ea,0x08f79c9c,0x1d2015c7,0x191035d9,0x0f117589)R(0x00eb,0x0f9121e7,0x19111d12,0x28234c76,0x30e2610b)R(0x00ec,0x2d23848f,0x2b037082,0x2b50d574,0x31e179b3)R(0x00ed,0x35128163,0x2b6260c4,0x28454431,0x20472c02)R(0x00ee,0x1837f00f,0x01c9129a,0x00c9b613,0x01989299)R(0x00ef,0x01ea1591,0x007939d7,0x0018a212,0x01c84959)
R(0x00f0,0x0038d9eb,0x0007edff,0x00a6da46,0x0e93833e)R(0x00f1,0x28a2173b,0x29605e20,0x2050417c,0x2b8240cf)R(0x00f2,0x398c5178,0x2d31caf2,0x3382eaf0,0x3bf7aaf5)R(0x00f3,0x3c5a12c3,0x354d7e90,0x2a3f8e0f,0x1d4fc998)R(0x00f4,0x119e1512,0x13960039,0x19509d59,0x14e0b58d)R(0x00f5,0x0e61f546,0x1310c1b7,0x1be1c4c4,0x25838061)R(0x00f6,0x24624c9e,0x1d803592,0x2a80a98c,0x16614119)R(0x00f7,0x1924c837,0x05f7d0d5,0x0058ca34,0x01da3a5e)R(0x00f8,0x01eab601,0x007935d4,0x0018aa0a,0x00082a05)R(0x00f9,0x0076e632,0x0d31d27d,0x0175a5e3,0x0ee300db)R(0x00fa,0x1890b551,0x3b145686,0x3b2be263,0x3c64d987)R(0x00fb,0x308eca2a,0x249fd9c5,0x199dfcbd,0x2004d429)R(0x00fc,0x1a3164ec,0x13d15d2d,0x21d2748f,0x04b5c11c)R(0x00fd,0x01d5e596,0x012609c6,0x00c7259e,0x0079421b)R(0x00fe,0x005919ef,0x001805da,0x00083df0,0x0007c1f9)R(0x00ff,0x00377dcb,0x1e5158e3,0x36580091,0x2b8d3cac)
R(0x0100,0x00000000,0x00000000,0x00000000,0x00000000)  }
  return r;
}

// Function 1243
Ray generate_ray (Camera cam, vec2 uv)
{
    return Ray(cam.o, cam.e3 + uv.x*cam.e1 + uv.y*cam.e2);
}

// Function 1244
float raymarch(vec3 ro, vec3 rd) {
    float t = 0.;
    for(int i = 0; i < MAX_ITER; i++) {
        float d = dstScene(ro+rd*t);
        if(d < MIN_DIST || t > MAX_DIST) {
            break;
        }
        t += d * .75;
    }
    return t;
}

// Function 1245
vec3 ray_dir( float fov, vec2 size, vec2 pos ) {
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );	
	float z = size.y * 0.5 * cot_half_fov;
	
	return normalize( vec3( xy, -z ) );
}

// Function 1246
vec3 normal(vec3 p,float t){
    float d=map(p,t);
    vec2 e=vec2(.001,0);
    
    vec3 n=d-vec3(
        map(p-e.xyy,t),
        map(p-e.yxy,t),
        map(p-e.yyx,t)
    );
    
    return normalize(n);
}

// Function 1247
float ObjRay (vec3 ro, vec3 rd)
{
  float dTol = 0.001;
  float d;
  float dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;
    dTol *= 1.01;
  }
  return dHit;
}

// Function 1248
vec3 calcNormal(vec2 R, vec2 u) {
    vec2 U = toNormalized(u, R);    
    float ht, hb, hl, hr;    
    
    ivec2 off_u = ivec2(u)+ivec2(0,1);
    ht = texelFetch(iChannel3, off_u, 0).x;
    off_u = ivec2(u)+ivec2(0,-1);
    hb = texelFetch(iChannel3, off_u, 0).x;
    off_u = ivec2(u)+ivec2(-1,0);
    hl = texelFetch(iChannel3, off_u, 0).x;
    off_u = ivec2(u)+ivec2(1,0);
    hr = texelFetch(iChannel3, off_u, 0).x;

    return normalize(vec3(2.0*(hl-hr),2.0*(hb-ht),4.0));
}

// Function 1249
vec3 estimateNormal(vec3 p) {
    float smallNumber = 0.002;
    vec3 n = vec3(
    scene(vec3(p.x + smallNumber, p.yz)).x -
    scene(vec3(p.x - smallNumber, p.yz)).x,
    scene(vec3(p.x, p.y + smallNumber, p.z)).x -
    scene(vec3(p.x, p.y - smallNumber, p.z)).x,
    scene(vec3(p.xy, p.z + smallNumber)).x -
    scene(vec3(p.xy, p.z - smallNumber)).x );

	return normalize(n);
}

// Function 1250
vec3 terrNormal(vec3 pos)
{
    //float h0 =hTerr(pos);
    vec2  dh=vec2(hTerr(pos+vec3(1,0,0))-hTerr(pos-vec3(1,0,0)),
    			  hTerr(pos+vec3(0,1,0))-hTerr(pos-vec3(0,1,0)))*.5;
    return normalize(vec3(-dh,1));
}

// Function 1251
vec3 calcNormal( in vec3 p ) {
    vec2 e = vec2(0.0001, 0.0);
    
	return normalize( vec3( 
        map(p+e.xyy) - map(p-e.xyy),
        map(p+e.yxy) - map(p-e.yxy),
        map(p+e.yyx) - map(p-e.yyx)
    ));
}

// Function 1252
RayHit mixRayHits(in RayHit a, in RayHit b, float factor){
    return RayHit(
        mix(a.color, b.color, factor),
        mix(a.n, b.n, factor),
        mix(a.dist, b.dist, factor)
    );
}

// Function 1253
vec3 getRay_7_2(mat3 camMat, vec2 screenPos, float lensLength) {
  return normalize(camMat * vec3(screenPos, lensLength));
}

// Function 1254
vec2 raycast(in vec3 ro, in vec3 rd, bool refr){
    float t = TMIN;
    float mat = -1.0;
    for(int i = 0; i < STEPS; i++){
    	vec2 res = map(ro + rd * t, refr);
        t += res.x;
        mat = res.y;
        if(t > TMAX || res.x < THRESHOLD) break;
    }
    if(t > TMAX){
    	mat = -1.0;	
    }
    return vec2(t, mat);
}

// Function 1255
vec3 sceneNormal(vec3 at) {
    return normalize(vec3(
        scene(at + NORMAL_OFFSET.xyy).distance - scene(at - NORMAL_OFFSET.xyy).distance,
        scene(at + NORMAL_OFFSET.yxy).distance - scene(at - NORMAL_OFFSET.yxy).distance,
        scene(at + NORMAL_OFFSET.yyx).distance - scene(at - NORMAL_OFFSET.yyx).distance
    ));
}

// Function 1256
vec3 calcNormal0(in vec3 p) {
  const vec2 e = vec2(0.0001, 0.0);
  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
                        map(p + e.yxy) - map(p - e.yxy),
                        map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1257
void Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const float fTransparentScale )
{        
    result.fDistance = GetRayFirstStep( ray );
    result.vObjectId.x = 0.0;
        
    for(int i=0;i<=kRaymarchMaxIter;i++)              
    {
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        vec4 vSceneDist = GetDistanceScene( result.vPos, fTransparentScale );
        result.vObjectId = vSceneDist.yzw;
        
        // abs allows backward stepping - should only be necessary for non uniform distance functions
        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))
        {
            break;
        }                        

        result.fDistance = result.fDistance + vSceneDist.x; 
    }


    if(result.fDistance >= ray.fLength)
    {
        result.fDistance = 1000.0;
        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;
        result.vObjectId.x = 0.0;
    }
}

// Function 1258
mat3 OrthoNormalMatrixFromZ( vec3 zDir )
{
	if ( abs( zDir.y ) < 0.999f )
	{
		vec3 yAxis = vec3( 0.0f, 1.0f, 0.0f );
		return OrthoNormalMatrixFromZY( zDir, yAxis );
	}
	else
	{
		vec3 xAxis = vec3( 1.0f, 0.0f, 0.0f );
		return OrthoNormalMatrixFromZY( zDir, xAxis );
	}
}

// Function 1259
float rayf(float t) {
    
    t = t + 1.5;
    
    return map(ro + rd * t);
}

// Function 1260
vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l-p), // forward
        r = normalize(cross(vec3(0,1,0), f)), // right
        u = cross(f,r), // up
        c = f*z, // 
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}

// Function 1261
vec3 calcNormal( in vec3 pos, in float t )
{
    vec2 eps = vec2( 0.005*t, 0.0 );
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1262
Ray makeRay(in vec3 o, in vec3 d) { Ray r; r.o = o; r.d = d; return r; }

// Function 1263
vec3 dNormal(vec3 p)
{
   const vec2 e = vec2(0.01,0.0);
   return normalize(vec3(
      fField(p + e.xyy) - fField(p - e.xyy),
      fField(p + e.yxy) - fField(p - e.yxy),
      fField(p + e.yyx) - fField(p - e.yyx) ));
}

// Function 1264
vec3 getNormal(vec3 pos, float e, bool inside)
{
    vec2 q = vec2(0, e);
    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),
                          map(pos + q.xyx) - map(pos - q.xyx),
                          map(pos + q.xxy) - map(pos - q.xxy)));
}

// Function 1265
void rayMarch(vec3 pos, vec3 dir)
{
    // Efficiently start the ray just in front of the drone...
    float l = max(length(drone-pos)-14.2, .0);
    float d =  l;
    l+=23.;// ...and end it just after
    int hits = 0;
	// Collect 4 of the closest scrapes on the tracing sphere...
    for (int i = 0; i < 55; i++)
    {
        // Leave if it's gone past the drone or when it's found 7 stacks points...
        if(d > l || hits == 6) break;
        vec3 p = pos + dir * (d);
		float r= SphereRadius(d);
		float de = mapDE(p);
        // Only store the closest ones (roughly), which means we don't
        // have to render the 8 stack points, just the most relavent ones.
        // This also prevents the banding seen when using small stacks.
        if(de < r &&  de < eStack.x)
        {
            // Rotate the stack and insert new value!...
			dStack = dStack.wxyz; dStack.x = d; 
            eStack = eStack.wxyz; eStack.x = de;
			hits++;    
        }
		d +=de*.9;
    }
    return;
}

// Function 1266
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = VAR_ZERO; j < 220; j ++) {
    p = ro + s * rd;
    h = GrndDf (p);
    if (h < 0.) break;
    sLo = s;
    s += max (0.001, h);
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = VAR_ZERO; j < 10; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (GrndDf (p) > 0.) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 1267
vec3 terrainNormal( in vec2 pos )
{
#if 1
    return terrainMapD(pos).yzw;
#else    
    vec2 e = vec2(0.03,0.0);
	return normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,
                           2.0*e.x,
                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );
#endif    
}

// Function 1268
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1269
vec3 getNormal(vec3 p) {
    vec2 t= vec2(0.001, 0.);
  return normalize(map(p).x - vec3(
    map(p - t.xyy).x,
    map(p - t.yxy).x,
    map(p - t.yyx).x
  ));
}

// Function 1270
vec3 calcNormal( in vec3 pos )
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773*0.002;
    return normalize( e.xyy*map( pos + e.xyy, kk ) + 
					  e.yyx*map( pos + e.yyx, kk ) + 
					  e.yxy*map( pos + e.yxy, kk ) + 
					  e.xxx*map( pos + e.xxx, kk ) );
}

// Function 1271
vec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )
{
  float t = 1e20;

  vec3 s = vec3(.5); //vec3(R.y < 0. ? 1.-sqrt(-R.y/(P.y+1.)) : 1.); // P.y+1 floor pos
  for( int i=0; i<SPH; i++ ) {    
    float h = sphIntersect( P, R, sphere[i] );
    if( h>0.0 && h<t ) {
      s = i == iid ? tint * 2. : vec3(0.);
      t = h;        
    }
  }     
  return max(vec3(0.), s);           
}

// Function 1272
sHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )
{
    sHit sRes = createHit( -1.0, -1.0, rd );

    // raymarch primitives   
    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 6.0 ), rd, vec3( 5.0, 5.0, 35.0 ) );
    
    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )
    {
        tmin = max( tb.x, tmin );
        tmax = min( tb.y, tmax );       

        float t = tmin;
        for( int i = ZERO; i < 42 && t < tmax; i++ )
        {
            sHit h = mapRefl( ro + rd * t );
            if( abs( h.t ) < ( 0.002 * t ) )
            { 
                sRes = createHit( t, h.m, h.lPos ); 
                break;
            }
            t += h.t;
        }
    }

    return sRes;
}

// Function 1273
vec3 RayMarchTerrial(vec3 ro,vec3 rd,float rz){
    vec3 col = vec3(1.,1.,1.);
    vec3 pos = ro + rz * rd;
    vec3 nor = CalcTerrianNormal(pos,rz);

    vec3 ref = reflect( rd, nor );
    float fre = clamp( 2.0+dot(rd,nor), 0.1, 2.0 );
    vec3 hal = normalize(lightDir-rd);
	col = vec3(0.09,0.06,0.04);
    // lighting     
    float amb = clamp(0.6+0.6*nor.y,0.1,2.0);
    float dif = clamp( dot( lightDir, nor ), 0.1, 2.0 );
    float bac = clamp( 0.3 + 0.9*dot( normalize( vec3(-lightDir.x, 0.1, lightDir.z ) ), nor ), 0.1, 2.0 );

    //shadow
    float sh = 2.0; 
  
    vec3 lin  = vec3(0.1,0.1,0.1);
    lin += dif*vec3(8.00,6.00,4.00)*2.3;
    lin += amb*vec3(0.50,0.70,2.00)*2.2;
    lin += bac*vec3(0.50,0.60,0.70);
    col *= lin;
  
    // fog
    float fo = 1.2-exp(-pow(0.002*rz/SC,2.5));
    vec3 fco = 0.75*vec3(0.5,0.75,2.0);// + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );
    col = mix( col, fco, fo );
  return col;
}

// Function 1274
vec3 raymarch(vec3 rayorig, vec3 raydir) {
  vec3 pos = rayorig;
  float d = getSdfWithPlane(pos);
  int work = 0;

  for (int step = 0; step < renderDepth; step++) {
    work++;
    pos = pos + raydir * d;
    d = getSdfWithPlane(pos);
    if (abs(d) < 0.001) {
      break;
    }
  }

  return showRenderDepth
    ? vec3(float(work) / float(renderDepth))
    : (abs(d) < 0.001) 
      ? illuminate(pos)
      : background;
}

// Function 1275
vec2 rayInt(
    vec2 o1, vec2 d1,
    vec2 o2, vec2 d2
) {
    return o1 + d1 * rayIntScalar(
        o1, d1,
        o2, d2
    );
}

// Function 1276
vec4 RayMarch(vec3 origin, vec3 direction) {
	
    float distance = 0.;
    float closest = FLOAT_MAX;
    vec2 closestPoint = vec2(0.);
    
    for(int i = 0; i < MAX_STEPS; i++) {
        
    	vec3 p = origin + direction * distance;        
        float sphereDistance = GetSphereDist(p);
        
        distance += sphereDistance;
        
        // If the calculated distance to the closest sphere
        // is smaller than what it was, update it and
        // update the hit point as well.
        if (sphereDistance < closest ) {
            closest = sphereDistance;
            closestPoint = p.xy;
        }
        
        if (distance > MAX_DIST) {
            // No hit
            return vec4(-1, closest, closestPoint);
        }
        
        if (sphereDistance < SURF_DIST) {
            // Sphere hit
            return vec4(distance, 0, closestPoint);
        }
    }
    
    // No hit
    return vec4(-1, closest, closestPoint);
}

// Function 1277
void raytrace_scene(
	vec4 ray_origin,
	vec4 ray_direction,
	out vec3 out_ray_color,
	out float out_ray_depth)
{
    out_ray_color = vec3(0.0, 0.0, 0.0);
    out_ray_depth = 10.0;
    
#ifdef ENABLE_HYPERSPHERES
    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)
    {
        raytrace_sphere(
            s_bloblet_positions[bloblet_index],
            s_bloblet_radii[bloblet_index],
            ray_origin,
            ray_direction,
        	out_ray_color,
        	out_ray_depth);
    }
#endif
    
    vec4 tesseract_scale = vec4(0.6);
    //tesseract_scale = vec4(0.8, 0.2, 0.2, 0.7);
    tesseract_scale = vec4(0.6, 0.6, 0.6, 0.2);
      
    raytrace_tesseract(
		vec4(0.0, 0.3, 0.0, 0.0), // tesseract_center
        tesseract_scale,
    	ray_origin,
        ray_direction,
        out_ray_color,
        out_ray_depth);
        
    raytrace_plane(
    	vec4(0.0, -0.8, 0.0, 0.0),
    	normalize(vec4(0.0, 1.0, 0.0, 0.0)),
        ray_origin,
        ray_direction,
        out_ray_color,
        out_ray_depth);
}

// Function 1278
void CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, 
                    out vec3 ro, out vec3 rd, out mat3 t) 
{
    float a = 1.0/max(iResolution.x, iResolution.y);
    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));
 
    ro = vec3(0.0, 0.0, -d);
    
    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));
    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * TAU);
    m.y = -m.y;
    
    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));
    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));
    
    t = rotY * rotX;
    
    ro = t * ro;
    ro = c + ro;

    rd = t * rd;
    
    rd = normalize(rd);
}

// Function 1279
vec2 raySphereIntersect(in vec3 origin, in vec3 dir, in float radius) {
	float a = dot(dir, dir);
	float b = 2.0 * dot(dir, origin);
	float c = dot(origin, origin) - (radius * radius);
	float d = (b * b) - 4.0 * a * c;
    
	if(d < 0.0)return vec2(1.0, -1.0);
	return vec2(
		(-b - sqrt(d)) / (2.0 * a),
		(-b + sqrt(d)) / (2.0 * a)
	);
}

// Function 1280
vec3 normal(vec3 pos)
{
	vec2 eps = vec2(1e-3, 0.0);
	float h = scene(pos).x;
	return normalize(vec3(
		scene(pos-eps.xyy).x-h,
		scene(pos-eps.yxy).x-h,
		scene(pos-eps.yyx).x-h
	));
}

// Function 1281
vec3 tubeNormal(in vec4 tube, in vec3 pt)
{
    vec2 n = normalize(vec2(pt.xz) - vec2(tube.xy));
    
    return vec3(n.x, 0.0, n.y);
}

// Function 1282
vec3 normalEstimation(vec3 pos, float dist){
  vec2 k = vec2(dist, 0);
  return normalize(vec3(distanceEstimation(pos + k.xyy),
	  					distanceEstimation(pos + k.yxy),
  						distanceEstimation(pos + k.yyx))
				 - vec3(dist));
}

// Function 1283
GBuffer tracePrimaryRay(vec3 ro, vec3 rd) {
  GBuffer gbuf;

  vec3 normal0;
  vec4 color;
  // get the depth, normal and color for this ray
  float depth = traceSceneRay(ro, rd, normal0, color);
  normal0 = normalize(normal0);

  float emissive = color.a;

  // fill the gbuffer with the material data
  gbuf.albedo = color.rgb;
  gbuf.depth = depth;
  gbuf.normal = normal0;

  // move the ray to the hit point
  ro += rd * depth;
  // slightly displace by the normal to prevent self-intersection
  ro += normal0 * 0.00001;

  vec3 ro0 = ro;

  // radiance sum for this pixel
  float radiance = 0.0;

  // radiance squared sum for this pixel
  // used later on for variance estimation
  float radiance2 = 0.0;

  for (uint q = UZERO; q < NUM_SAMPLES; q++) {
    // get a random direction on the hemisphere around the normal
    ro = ro0;
    rd = unitVectorOnHemisphere(normal0);

    // radiance sum for the current path
    float r = 0.0;

    // keep bouncing and gathering light
    for (uint i = UZERO; i < MAX_BOUNCES; i++) {
      vec3 normal;
      depth = traceSceneRay(ro, rd, normal, color);
      if (depth > 100.0) {
        break;
      }

      // gather whatever we hit
      r += color.a;

      // calculate the ray for the next bounce
      normal = normalize(normal);
      ro += rd * depth;
      ro += normal * 0.00001;
      rd = unitVectorOnHemisphere(normal);
    }

    // add to the total radiance
    radiance += r;
    radiance2 += r * r;
  }

  radiance /= float(NUM_SAMPLES);
  radiance2 /= float(NUM_SAMPLES);

  // variance = sum(x^2) - sum(x)^2
  gbuf.variance = radiance2 - radiance * radiance;
  gbuf.radiance = radiance + emissive;

  return gbuf;
}

// Function 1284
vec3 calcNormal (in vec3 pos)
{
	const vec3 eps = vec3 (0.0001, 0, 0);
    float d = distanceFunction(pos);
    return normalize( 
      vec3 (distanceFunction(pos+eps.xyy) - d,
	        distanceFunction(pos+eps.yxy) - d,
	        distanceFunction(pos+eps.yyx) - d));
}

// Function 1285
vec3 rayMarch( in vec3 ro, in vec3 rd, out float idObj, out vec3 ptCol ) {

        float dist = 0.0;
        vec3 vdist;
        vec3 np = ro;
        for( int i = 0; i < MAX_ITERATIONS; i++ ) {
            
            vdist = map(np);
            dist = vdist.x;
            if (dist < 0.001)
                break;
            np += rd * dist;

        }

        idObj = vdist.y;
        ptCol = np;

        if (dist < 0.01) {
            return colorize(np, vdist.y);
        }

        return vec3( 0.6, .6, 0.8);    

    }

// Function 1286
vec3 getNormals(vec2 pos){
	vec3 normals = vec3(0.0);
	
	float delta = 0.01;
    
	float d0 = getHeight(pos);
	float d1 = getHeight(pos + vec2(delta, 0.0));
	float d2 = getHeight(pos + vec2(0.0, delta));
	
	float dx = (d0 - d1) / delta;
	float dy = (d0 - d2) / delta;
	
	normals = normalize(vec3(dx, dy, 1.0 - d0));
	
	return normals;
}

// Function 1287
vec3 calcNormal(in vec3 p)
{
	const vec2 e = vec2(0.0001, 0.0);
	return normalize(vec3(
		map(p + e.xyy) - map(p - e.xyy),
		map(p + e.yxy) - map(p - e.yxy),
		map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1288
float raymarch()
{
  float d = 0.0, t = 0.0;
  for(int i = 0; i < 32; ++i)
  {
    d = sphere(camera.origin + t * camera.direction);
    if(abs(d) < 0.01) return t;
    if(t > 100.0) return -1.0;
    t += d;
  }
  return -1.0;
}

// Function 1289
vec4 castRay( in vec3 ro, in vec3 rd )
{
    vec4 res = vec4(-1.0,-1.0,-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec4( tp1, 1.0, 0.0, 0.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.0,0.0,0.0), rd, vec3(2.0,2.0,3.0) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for( int i=0; i<70 && t<tmax; i++ )
        {
            vec4 h = map( ro+rd*t, rd );
            if( abs(h.x)<(0.0001*t) )
            { 
                res = vec4(t,h.y, h.z, h.w); 
                 break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 1290
vec3 asteroidGetNormal(vec3 p, vec3 id) {
    asteroidTransForm( p, id );
    
    vec3 n;
    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);
    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);
    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);
    n = normalize(n-asteroidMapDetailed(p, id));
    
    asteroidUnTransForm( n, id );
    return n;
}

// Function 1291
float raymarch_cube(vec3 origin, vec3 dir, float start, float end) {
	const int max_iterations = 64;
	const float stop_threshold = 0.01;
	float depth = start;
	for (int i=0; i<max_iterations; i++) {
		float dist = DE_cube(origin + dir*depth);
		if (dist < stop_threshold) return depth;
		depth += dist;
		if (depth >= end) return end;
	}
	return end;
}

// Function 1292
Ray Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)
{
    vec3 forward = normalize(d - o);
    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up      = normalize(cross(right, forward));

    uv    = (uv * 2.0) - 1.0;
    uv.x *= (iResolution.x / iResolution.y);

    Ray ray;
    ray.o = o;
    ray.d = normalize((uv.x * right) + (uv.y * up) + (forward * 2.0));

    return ray;
}

// Function 1293
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<128; i++ )
    {
        if( abs(h)<precis||t>maxd ) continue;//break;
        t += h;
	    vec2 res = map( ro+rd*t );
        h = res.x;
	    m = res.y;
    }

    if( t>maxd ) m=-1.0;
    return vec2( t, m );
}

// Function 1294
vec3 getNormal(in vec3 p, float t) {
	const vec2 e = vec2(.001, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1295
vec3 calcNormal(vec3 pos){
    vec3 eps = vec3(.0005,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert) * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

// Function 1296
float RayMarch(vec3 ro, vec3 rd) 
{
	float dO=0.;
    
    for(int i=0; i<MAX_STEPS; i++) 
	{
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO>MAX_DIST || dS<SURF_DIST) break;
    }
    
    return dO;
}

// Function 1297
vec3 calcNormal(in vec3 p) 
{
    vec3 e = vec3(0.001, 0.0, 0.0);
    vec3 nor = vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx));
    return normalize(nor);
}

// Function 1298
bool RayVsQuad(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 diffuse, bool doubleSided)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (doubleSided && dot(normal, rayDir) > 0.0f)
    {
        normal *= -1.0f;
        
		vec3 temp = d;
        d = a;
        a = temp;
        
        temp = b;
        b = c;
        c = temp;
    }
    
    vec3 p = rayPos;
    vec3 q = rayPos + rayDir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;
    
    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return false;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return false;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }
    
    float dist;
    if (abs(rayDir.x) > 0.1f)
    {
        dist = (intersectPos.x - rayPos.x) / rayDir.x;
    }
    else if (abs(rayDir.y) > 0.1f)
    {
        dist = (intersectPos.y - rayPos.y) / rayDir.y;
    }
    else
    {
        dist = (intersectPos.z - rayPos.z) / rayDir.z;
    }
    
	if (dist > 0.0f && dist < info.dist)
    {
        info.dist = dist;        
        info.normal = normal;
		info.diffuse = diffuse;        
        return true;
    }    
    
    return false;
}

// Function 1299
void resolveRay(float howManiethReflection){
	if(closestPoint.distanceFromCamera<100000.){
		camera+=ray*(closestPoint.distanceFromCamera)-normalize(closestPoint.normal);
		ray=normalize(reflect(ray,closestPoint.normal));
		float sunlight=length(sun.pos-camera)/min(max(0.4/resolveRayLightIntersection(sun),0.01),1.0);
		color+=vec3(closestPoint.color/(0.11*sunlight*(howManiethReflection*1.1+1.)));
		//ray=normalize(ray)*vec3(0.77);

	}
}

// Function 1300
vec2 raytrace(vec3 U) {
    vec3  p = vec3(0,0,50), D = normalize(U), q;                 // ray start & direction                             
    vec2  M = 8.*CAM;                                            // stupidely can't call cam in common
    
        p.yz *= rot( .5 - M.y ), D.yz *= rot( .5 - M.y ),        // rotations
        p.xz *= rot( 2. - M.x ), D.xz *= rot( 2. - M.x );
    
    // --- ray ( P = C+kD ) - cylinder (O,Z,r) intersection: ------------------
    //    | OP - (OP.Z)Z | = r    |OP| - (OP.Z) = r -> second degree polynom in k
    float a = 1. - D.z*D.z, b = dot(p,D) - p.z*D.z, c = dot(p,p) - p.z*p.z - 25.,
          d = b*b - a*c, k, T=.925;

    if ( d < 0. ) return vec2(0);                                // miss cylinder
    
#define getHit(sgn) {                                       \
      k = (-b sgn sqrt(d) ) / a;                            \
      q = p + k* D;                                         \
      s = 5.63* atan(q.y,q.x);   /* 4.77 */                 \
   /* r = vec2(s-q.z,s+q.z),             */                 \
      r = vec2(s,q.z)* mat2(cos(T+vec4(0,33,11,0))) *1.41,  \
      s = Amax(r);                                          \
      E = 6.28* 5.63* cos(T+vec2(0,11)) *1.41, /* bridge */ \
      s = min( s, Amax(r+E) );                              \
      s = min( s, Amax(r-E) );                              \
    }
    float s; vec2 r,E;
    getHit(-);                                                   // front
    if ( s > 21. ) getHit(+);                                    // back
    if ( s > 21. ) return vec2(0);                               // miss (sides)

 // q.xz  *= rot( -(2. - M.x) ), q.yz *= rot( -(.5 - M.y) );     // back to screen space
 // _hit = q;                                                    // return hit point and view-shading
    _shad = abs( dot(q.xy,D.xy) / 5. );
    return r/10.;                                                // coordinates on puzzle or 0
}

// Function 1301
vec3 normal(vec3 pos, const in int cur_space) {
  return normal(pos, 0.0002, cur_space);
}

// Function 1302
void getRay()
{
    vec2 uv = (p - R*0.5)/R.x;
    ray = normalize(vec3(FOV*uv, 1.));
}

// Function 1303
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 100; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1304
vec3 getNormal(in vec3 pos) {
	vec2 d = vec2(EPS, 0.0);
	return normalize(vec3(map(pos + d.xyy) - map(pos - d.xyy),
		map(pos + d.yxy) - map(pos - d.yxy),
		map(pos + d.yyx) - map(pos - d.yyx)));
}

// Function 1305
vec3 RayTrace(in vec2 fragCoord )
{
    marchCount = 0.0;
	// -------------------------------- animate ---------------------------------------
    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;
	sunDir = normalize(vec3(0.93, 1.0, 1.0));
    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;
    skyCol = vec3(0.3,0.5,0.95);
    exposure = 1.0;
    fade = 1.0;

	vec3 camPos, camUp, camLookat;
	// ------------------- Set up the camera rays for ray marching --------------------
    // Map uv to [-1.0..1.0]
	vec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;
    uv /= 2.0;  // zoom in

#ifdef MANUAL_CAMERA
    // Camera up vector.
	camUp=vec3(0,1,0);

	// Camera lookat.
	camLookat=vec3(0,0.0,0);

    // debugging camera
    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;
	float my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;
	camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35
#else
    // Do the camera fly-by animation and different scenes.
    // Time variables for start and end of each scene
    const float t0 = 0.0;
    const float t1 = 8.0;
    const float t2 = 14.0;
    const float t3 = 24.0;
    const float t4 = 38.0;
    const float t5 = 56.0;
    const float t6 = 58.0;
    /*const float t0 = 0.0;
    const float t1 = 0.0;
    const float t2 = 0.0;
    const float t3 = 0.0;
    const float t4 = 0.0;
    const float t5 = 16.0;
    const float t6 = 18.0;*/
    // Repeat the animation after time t6
    localTime = fract(localTime / t6) * t6;
    if (localTime < t1)
    {
        float time = localTime - t0;
        float alpha = time / (t1 - t0);
        fade = saturate(time);
        fade *= saturate(t1 - localTime);
        camPos = vec3(13.0, 3.3, -3.5);
        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;
        camUp=vec3(0,1,0);
        camLookat=vec3(0,1.5,1.5);
    } else if (localTime < t2)
    {
        float time = localTime - t1;
        float alpha = time / (t2 - t1);
        fade = saturate(time);
        fade *= saturate(t2 - localTime);
        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);
        camPos.z -= alpha * 2.8;
        camUp=vec3(0,1,0);
        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);
        
        sunDir = normalize(vec3(0.95, 0.6, 1.0));
        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;
        exposure *= 0.7;
        skyCol *= 1.5;
    } else if (localTime < t3)
    {
        float time = localTime - t2;
        float alpha = time / (t3 - t2);
        fade = saturate(time);
        fade *= saturate(t3 - localTime);
        camPos = vec3(12.0, 6.3, -0.5);
        camPos.y -= alpha * 5.5;
        camPos.x = cos(alpha*1.0) * 5.2;
        camPos.z = sin(alpha*1.0) * 5.2;
        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));
        camLookat=vec3(0,1.0,-0.5);
    } else if (localTime < t4)
    {
        float time = localTime - t3;
        float alpha = time / (t4 - t3);
        fade = saturate(time);
        fade *= saturate(t4 - localTime);
        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);
        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;
        camUp=normalize(vec3(0,1,0.0));
        camLookat=vec3(0,0.5+alpha,alpha*5.0);
    } else if (localTime < t5)
    {
        float time = localTime - t4;
        float alpha = time / (t5 - t4);
        fade = saturate(time);
        fade *= saturate(t5 - localTime);
        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);
        camUp=normalize(vec3(0,1,0.0));
        camLookat=vec3(-2.0,0.3+alpha,-0.0);
        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));
        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;
        localTime *= 16.0;
        exposure *= 0.4;
        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;
        skyCol = vec3(0.75,0.5,0.95);

    } else if (localTime < t6)
    {
        fade = 0.0;
        camPos = vec3(26.0, 100.0, 2.0);
        camUp=vec3(0,1,0);
        camLookat=vec3(0.3,0.15,0.0);
    }
#endif

	// Camera setup for ray tracing / marching
	vec3 camVec=normalize(camLookat - camPos);
	vec3 sideNorm=normalize(cross(camUp, camVec));
	vec3 upNorm=cross(camVec, sideNorm);
	vec3 worldFacing=(camPos + camVec);
	vec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;
	vec3 rayVec = normalize(worldPix - camPos);

	// ----------------------------- Ray march the scene ------------------------------
	vec2 distAndMat;  // Distance and material
	float t = 0.05;// + Hash2d(uv)*0.1;	// random dither-fade things close to the camera
	const float maxDepth = 45.0; // farthest distance rays will travel
	vec3 pos = vec3(0.0);
    const float smallVal = 0.000625;
	// ray marching time
    for (int i = 0; i < 250; i++)	// This is the count of the max times the ray actually marches.
    {
        marchCount+=1.0;
        // Step along the ray.
        pos = (camPos + rayVec * t);
        // This is _the_ function that defines the "distance field".
        // It's really what makes the scene geometry. The idea is that the
        // distance field returns the distance to the closest object, and then
        // we know we are safe to "march" along the ray by that much distance
        // without hitting anything. We repeat this until we get really close
        // and then break because we have effectively hit the object.
        distAndMat = DistanceToObject(pos);

        // 2d voxel walk through the city blocks.
        // The distance function is not continuous at city block boundaries,
        // so we have to pause our ray march at each voxel boundary.
        float walk = distAndMat.x;
        float dx = -fract(pos.x);
        if (rayVec.x > 0.0) dx = fract(-pos.x);
        float dz = -fract(pos.z);
        if (rayVec.z > 0.0) dz = fract(-pos.z);
        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;
        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.
        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.
        walk = min(walk, nearestVoxel);

        // move down the ray a safe amount
        t += walk;
        // If we are very close to the object, let's call it a hit and exit this loop.
        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;
    }

    // Ray trace a ground plane to infinity
    float alpha = -camPos.y / rayVec.y;
    if ((t > maxDepth) && (rayVec.y < -0.0))
    {
        pos.xz = camPos.xz + rayVec.xz * alpha;
        pos.y = -0.0;
        t = alpha;
        distAndMat.y = 0.0;
        distAndMat.x = 0.0;
    }
	// --------------------------------------------------------------------------------
	// Now that we have done our ray marching, let's put some color on this geometry.
	vec3 finalColor = vec3(0.0);

	// If a ray actually hit the object, let's light it.
    if ((t <= maxDepth) || (t == alpha))
	{
        float dist = distAndMat.x;
        // calculate the normal from the distance field. The distance field is a volume, so if you
        // sample the current point and neighboring points, you can use the difference to get
        // the normal.
        vec3 smallVec = vec3(smallVal, 0, 0);
        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,
                           dist - DistanceToObject(pos - smallVec.yxy).x,
                           dist - DistanceToObject(pos - smallVec.yyx).x);
        vec3 normal = normalize(normalU);

        // calculate 2 ambient occlusion values. One for global stuff and one
        // for local stuff
        float ambientS = 1.0;
        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);
        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);
        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);
        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);
        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);
        ambient = max(0.025, pow(ambient, 0.5));	// tone down ambient with a pow and min clamp it.
        ambient = saturate(ambient);

        // calculate the reflection vector for highlights
        vec3 ref = reflect(rayVec, normal);

        // Trace a ray toward the sun for sun shadows
        float sunShadow = 1.0;
        float iter = 0.01;
        vec3 nudgePos = pos + normal*0.002;	// don't start tracing too close or inside the object
		for (int i = 0; i < 40; i++)
        {
            vec3 shadowPos = nudgePos + sunDir * iter;
            float tempDist = DistanceToObject(shadowPos).x;
	        sunShadow *= saturate(tempDist*150.0);	// Shadow hardness
            if (tempDist <= 0.0) break;

            float walk = tempDist;
            float dx = -fract(shadowPos.x);
            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);
            float dz = -fract(shadowPos.z);
            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);
            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;
            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.
            walk = min(walk, nearestVoxel);

            iter += max(0.01, walk);
            if (iter > 4.5) break;
        }
        sunShadow = saturate(sunShadow);

        // make a few frequencies of noise to give it some texture
        float n =0.0;
        n += noise(pos*32.0);
        n += noise(pos*64.0);
        n += noise(pos*128.0);
        n += noise(pos*256.0);
        n += noise(pos*512.0);
        n = mix(0.7, 0.95, n);

        // ------ Calculate texture color  ------
        vec2 block = floor(pos.xz);
        vec3 texColor = vec3(0.95, 1.0, 1.0);
        texColor *= 0.8;
        float windowRef = 0.0;
        // texture map the sides of buildings
        if ((normal.y < 0.1) && (distAndMat.y == 0.0))
        {
            vec3 posdx = dFdx(pos);
            vec3 posdy = dFdy(pos);
            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);

            // Quincunx antialias the building texture and normal map.
            // I guess procedural textures are hard to mipmap.
            vec3 colTotal = vec3(0.0);
            vec3 colTemp = texColor;
            vec3 nTemp = vec3(0.0);
            CalcWindows(block, pos, colTemp, windowRef, nTemp);
            colTotal = colTemp;

            colTemp = texColor;
            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);
            colTotal += colTemp;

            colTemp = texColor;
            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);
            colTotal += colTemp;

            colTemp = texColor;
            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);
            colTotal += colTemp;

            colTemp = texColor;
            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);
            colTotal += colTemp;

            texColor = colTotal * 0.2;
            windowRef *= 0.2;

            normal = normalize(normal + nTemp * 0.2);
        }
        else
        {
            // Draw the road
            float xroad = abs(fract(pos.x+0.5)-0.5);
            float zroad = abs(fract(pos.z+0.5)-0.5);
            float road = saturate((min(xroad, zroad)-0.143)*480.0);
            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color
            texColor *= mix(0.1, 1.0, road);

            // double yellow line in middle of road
            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);
            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);
            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);
            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);

            // white dashed lines on road
            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);
            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);
            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);
            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line
            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);
            texColor = mix(texColor, vec3(0.5), whiteLine);

            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);
            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);
            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);
            texColor = mix(texColor, vec3(0.5), whiteLine);

            // crosswalk
            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);
            crossWalk *= saturate((zroad-0.15)*880.0);
            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);
            crossWalk *= n*n;
            texColor = mix(texColor, vec3(0.25), crossWalk);
            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);
            crossWalk *= saturate((xroad-0.15)*880.0);
            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);
            crossWalk *= n*n;
            texColor = mix(texColor, vec3(0.25), crossWalk);

            {
                // sidewalk cracks
                float sidewalk = 1.0;
                vec2 blockSize = vec2(100.0);
                if (pos.y > 0.1) blockSize = vec2(10.0, 50);
                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);
                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);
                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));
                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));
                sidewalk = saturate(mix(0.7, 1.0, sidewalk));
                sidewalk = saturate((1.0-road) + sidewalk);
                texColor *= sidewalk;
            }
        }
        // Car tires are almost black to not call attention to their ugly.
        if (distAndMat.y == 3.0)
        {
            texColor = vec3(0.05);
        }

        // apply noise
        texColor *= vec3(1.0)*n*0.05;
        texColor *= 0.7;
        texColor = saturate(texColor);

        float windowMask = 0.0;
        if (distAndMat.y >= 100.0)
        {
            // car texture and windows
            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;
            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white
            texColor = max(vec3(0.25), texColor);  // not too saturated color.
            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)
            texColor *= Hash11(distAndMat.y*0.789) * 0.15;
            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);
            vec2 dirNorm = abs(normalize(normal.xz));
            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));
            pillars = pow(max(0.0, pillars-0.15), 0.125);
            windowMask = max(windowMask, pillars);
            texColor *= windowMask;
        }

        // ------ Calculate lighting color ------
        // Start with sun color, standard lighting equation, and shadow
        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;
        // weighted average the near ambient occlusion with the far for just the right look
        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;
        // Add sky color with ambient acclusion
        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;
        lightColor *= 4.0;

        // finally, apply the light to the texture.
        finalColor = texColor * lightColor;
        // Reflections for cars
        if (distAndMat.y >= 100.0)
        {
            float yfade = max(0.01, min(1.0, ref.y*100.0));
            // low-res way of making lines at the edges of car windows. Not sure I like it.
            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));
            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);
            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);
        }
        // reflections for building windows
        if (windowRef != 0.0)
        {
            finalColor *= mix(1.0, 0.6, windowRef);
            float yfade = max(0.01, min(1.0, ref.y*100.0));
            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);
            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;
        }
        finalColor *= 0.9;
        // fog that fades to reddish plus the sun color so that fog is brightest towards sun
        vec3 rv2 = rayVec;
        rv2.y *= saturate(sign(rv2.y));
        vec3 fogColor = GetEnvMap(rv2, sunDir);
        fogColor = min(vec3(9.0), fogColor);
        finalColor = mix(fogColor, finalColor, exp(-t*0.02));

        // visualize length of gradient of distance field to check distance field correctness
        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);
        //finalColor = vec3(marchCount)/255.0;
	}
    else
    {
        // Our ray trace hit nothing, so draw sky.
        finalColor = GetEnvMap(rayVec, sunDir);
    }

    // vignette?
    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));
    finalColor *= 1.3*exposure;

	// output the final color without gamma correction - will do gamma later.
	return vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));
}

// Function 1306
vec3 MarchRay(vec3 origin,vec3 dir)
{
    bool inWarp = false;
    
    float dist = 0.0;
    
    //Distance to the "warp zone".
    float warpDist = MarchWarp(origin,dir);
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        float sceneDist = Scene(origin + dir * dist);
        
        //Reset the march distance, set the ray origin to the surface of the "warp zone", scale the map and ray origin.
        #ifndef DISABLE_WARP
        if(warpDist < dist && !inWarp)
    	{
            scale.x = 4.0;
            
            dist = 0.0;
            origin = origin + dir * warpDist;
            origin /= scale;
            
            inWarp = true;
    	}
        #endif
        
        dist += sceneDist * STEP_MULT;
        
        if(abs(sceneDist) < MIN_DIST || sceneDist > MAX_DIST)
        {
            if(sceneDist < 0.0)
            {
                dist += MIN_DIST;
            }
            
            break;
        }
    }
    
    return origin + dir * dist;
}

// Function 1307
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.0005;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<75; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 1308
vec3 RayTrace(in vec2 fragCoord )
{
    fade = 1.0;
    effect = 0.0;

	vec3 camPos, camUp, camLookat;
	// ------------------- Set up the camera rays for ray marching --------------------
    // Map uv to [-1.0..1.0]
	vec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;
    uv /= 2.0;  // zoom in

    bool cinematicHack = false;
    // End game cinematic
    if ((gameStage >= 600.0) && (gameStage < 700.0)) {
        cinematicHack = true;
        bikeAAngle = PI;
        bikeAPos = vec3(0);
    }

    // Camera up vector.
	camUp=vec3(0,1,0);

	// Camera lookat.
	camLookat=vec3(0,0.5,0) + vec3(bikeAPos.x, max(1.0, bikeAPos.y), bikeAPos.z);

    // debugging camera
    float mx=-iMouse.x/iResolution.x*PI*2.0;
	float my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;
    vec3 bikeDir = round(vec3(cos(bikeAAngle), 0.0, -sin(bikeAAngle)));
    if (cinematicHack) {
        camPos = vec3(2,1.0,0.95);
        float uplook = smoothstep(0.0, 1.0, saturate((gameStage - 605.0)*0.0625))*10.0;
        //uplook = saturate((gameStage - 604.0)*0.25);
        camLookat=vec3(0,1.0 + uplook,0.95);
    } else {
    	camPos = camFollowPos.xyz;
        if ((gameStage >= 100.0) && (gameStage < 102.0)) {
            camLookat = mix(camLookat, vec3(bikeBPos.x, 1.0, bikeBPos.z), saturate((gameStage-100.0)*0.5));
        }
        if ((gameStage >= 102.0) && (gameStage < 104.0)) {
            camLookat = mix(vec3(bikeBPos.x, 1.0, bikeBPos.z), camLookat, saturate((gameStage-102.0)*0.5));
        }
    }
    // debug camera
	//camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*82.0 + bikeAPos;

	// Camera setup for ray tracing / marching
	vec3 camVec=normalize(camLookat - camPos);
	vec3 sideNorm=normalize(cross(camUp, camVec));
	vec3 upNorm=cross(camVec, sideNorm);
	vec3 worldFacing=(camPos + camVec);
	vec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;
	vec3 rayVec = normalize(worldPix - camPos);

    // End game cinematic
    if (cinematicHack) {
        cinematicHack = true;
        bikeAAngle = PI;
        float accel = pow(3.0, max(0.0, gameStage - 604.0));
        bikeAPos = vec3(-accel+1.0, 0.3, 0.125);
        effect = 1.0-saturate((gameStage - 600.0) * 0.5);
    }

	// ----------------------------- Ray trace the scene ------------------------------

    vec3 finalColor = vec3(0.0);
	RenderScene(camPos, rayVec, finalColor, cinematicHack);

    // vignette?
    finalColor *= saturate(1.0 - length(uv/2.5));
    finalColor *= exposure;
    if ((gameStage >= 500.0) && (gameStage < 600.0)) finalColor = mix(finalColor, vec3(1), saturate((gameStage - 500.0) * 0.5));
    if ((gameStage >= 600.0) && (gameStage < 700.0)) {
        finalColor = mix(vec3(1), finalColor, saturate((gameStage - 600.0) * 0.5));
        finalColor = mix(finalColor, vec3(1.0), saturate((gameStage - 607.0) * 0.333));
    }

	// output the final color without gamma correction - will do gamma later.
	return vec3(saturate(finalColor)*saturate(fade));
}

// Function 1309
vec3 faceted_normal(vec3 n)
{
	vec3 an = abs(n);
	
	if(an.x > an.y && an.x > an.z)
	{
		n.yz = qu(n.yz / n.x);
		n.x = 1.0;
	}
	else if(an.y > an.x && an.y > an.z)
	{
		n.xz = qu(n.xz / n.y);
		n.y = 1.0;
	}
	else if(an.z > an.y && an.z > an.x)
	{
		n.xy = qu(n.xy / n.z);
		n.z = 1.0;
	}
    return n; 
}

// Function 1310
bit3d_Ray rayof(vec3 o, vec3 t, int mi) {
	bit3d_Ray r;
	r.origin = o;
	r.direction = t;
	r.maxIterations = unroll(8);
	return r;
}

// Function 1311
vec3 capsuleNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3  u = b - a;
    vec3  v = pos - a;
    float h = clamp(dot(v,u)/dot(u,u), 0.0, 1.0);
    return (v - h*u) / r;
}

// Function 1312
vec3 normal(vec3 pos, float e) {
    vec3 eps = vec3(e, 0.0, 0.0);

    return normalize(vec3(
        map(pos + eps.xyy) - map(pos - eps.xyy),
        map(pos + eps.yxy) - map(pos - eps.yxy),
        map(pos + eps.yyx) - map(pos - eps.yyx)));
}

// Function 1313
vec3 getReflection(Ray r, HitRecord hit) {
    /*
    Calculating the reflection direction based on the specular attribute of the material.
    Either it is a perfect reflection (specular = 1), a perfect diffuse (specular = 0) or
    something in between.
    */
    vec3 diffuseDir = normalize(hit.normal + random_in_unit_sphere());
    vec3 specularDir = reflect(r.dir, hit.normal);

    vec3 nextDir = mix(diffuseDir, specularDir, hit.mat.specular);
    return normalize(nextDir);
}

// Function 1314
dsvec3 calcRayPos(vec3 ro, vec3 rd, vec2 t)
{
    dsvec3 dsrd = set(rd);
    dsvec3 dsrp = set(ro);
    dsrd.x = ds_mul(dsrd.x, t);
    dsrd.y = ds_mul(dsrd.y, t);
    dsrd.z = ds_mul(dsrd.z, t);
    dsrp.x = ds_add(dsrp.x, dsrd.x);
    dsrp.y = ds_add(dsrp.y, dsrd.y);
    dsrp.z = ds_add(dsrp.z, dsrd.z);
    return dsrp;
}

// Function 1315
vec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )
{
    RaymarchScene( vRayOrigin, vRayDir, intersection );        

    if ( intersection.m_objId == OBJ_ID_SKY )
    {
        return GetSkyColour( vRayDir, 1.0 );
    }
    
    Surface surface;
    GetSurfaceInfo( intersection, surface );

    vec3 vIgnore = vec3(0.0);
    vec3 vResult = vec3(0.0);
    float fSunShadow = 1.0;
    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );
    AddSkyLight( surface, vResult, vIgnore);
    return vResult * surface.m_albedo;
}

// Function 1316
void castRay(in vec3 ro, in vec3 rd) 
{
	vec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));		
    float t = 0.;
    for (int i = 0; i < 70; i++) 
	{
		if(col.w>0.999 ||t>15.0)continue;
		rCoC=CircleOfConfusion(t);
		h = map(ro)+0.5*rCoC;
		if(h<rCoC)
		{
			pcoc=ro-rd*abs(h-rCoC);
			vec2 v=vec2(rCoC*0.5,0.0);
			vec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));
			vec3 scol=2.3*getColor();	
			float newdiff = clamp(dot(lig, N), 0.0, 1.0);
			float newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);
			float newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);			
			scol *= 0.5*newdiff+newspec;
		 	scol *= newsh;
			float alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);
			col+=vec4(scol*alpha,alpha);
		}
		h=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));
		ro+=h*rd;
		t += h;
	}
}

// Function 1317
vec3 getNormal(vec3 p, inout float edge, inout float crv) { 
	
    vec2 e = vec2(.01, 0); // Larger epsilon for greater sample spread, thus thicker edges.

    // Take some distance function measurements from either side of the hit point on all three axes.
	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;	// The hit point itself - Doubled to cut down on calculations. See below.
     
    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how
    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum
    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface 
    // curves that register a discernible difference.
    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.
    
    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you 
    // do that is up to you. This is what I came up with for now, but I might tweak it later.
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
    
    // We may as well use the six measurements to obtain a rough curvature value while we're at it.
    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .6, 0., 1.);
	
    // Redoing the calculations for the normal with a more precise epsilon value.
    e = vec2(.0025, 0);
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx); 
    
    
    // Return the normal.
    // Standard, normalized gradient mearsurement.
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 1318
vec2 opReflect(vec2 v, vec2 normal) {
	v -= 2. * min(0., dot(v, normal)) * normal;
	return v;
}

// Function 1319
vec3 normal(vec3 p) {
	vec3 e = vec3(0.0,det,0.0);
	
	return normalize(vec3(
			de(p+e.yxx)-de(p-e.yxx),
			de(p+e.xyx)-de(p-e.xyx),
			de(p+e.xxy)-de(p-e.xxy)
			)
		);	
}

// Function 1320
float normalCurve(float x) {
	const float pi = 3.141592653589;
	// const float e = 2.71828;
	// return pow(e, -x*x*0.5) / sqrt(2.0 * pi);
	// Cauchy:
	return 1.0/(pi * (1.0 + x*x));
}

// Function 1321
vec2 raymarch(vec3 ro, vec3 rd, float t) {
    float id = -1.;
    for(int i = 0; i < MAX_ITER; i++) {
        vec2 scn = dstScene(ro+rd*t);
        if(scn.x < MIN_DIST*t || t > MAX_DIST) {
            id = scn.y;
            break;
        }
        t += scn.x * .5;
    }
    return vec2(t,id);
}

// Function 1322
vec3 calcWallNormal( vec3 p,
                     vec3 rdir )
{
    vec3 epsilon = vec3( EPSILON, 0.0, 0.0 );
    vec3 n = vec3(
        boxinteriortrace(p + epsilon.xyy, rdir, BOXWALL_EXTENT) - 
            boxinteriortrace(p - epsilon.xyy, rdir, BOXWALL_EXTENT),
        boxinteriortrace(p + epsilon.yxy, rdir, BOXWALL_EXTENT) - 
            boxinteriortrace(p - epsilon.yxy, rdir, BOXWALL_EXTENT),
        boxinteriortrace(p + epsilon.yyx, rdir, BOXWALL_EXTENT) - 
            boxinteriortrace(p - epsilon.yyx, rdir, BOXWALL_EXTENT) );
    return normalize( n );
}

// Function 1323
vec3 normal(vec3 p, float k)
{
	vec2 e = vec2(0,k);
	return normalize(vec3(
		map(p + e.yxx).x - map(p - e.yxx).x,
		map(p + e.xyx).x - map(p - e.xyx).x,
		map(p + e.xxy).x - map(p - e.xxy).x
	));
}

// Function 1324
vec3 calcNormal(vec3 p, float t) {
    vec2 e = vec2(EPSILON*t,0.);
    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,
                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,
                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);
    return normalize(n);
}

// Function 1325
vec3 Scene_GetNormal( const in vec3 vPos, int insideObjId )
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos, insideObjId ).fDist * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos, insideObjId ).fDist * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos, insideObjId ).fDist * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos, insideObjId ).fDist * e.yyy;
    
    return normalize( vNormal );
}

// Function 1326
vec3 getTerrainNormal(in vec3 p) {
    float eps = 0.025;
    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),
                          2.0 * eps,
                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));
}

// Function 1327
vec3 Raymarch(Ray r, float startT)
{
    float t = startT;
    float d = 0.0;
    float iterations = 0.0;
    
	for(int j = 0; j < MAX_ITERATIONS; j++)
	{
		d = sdf(r.origin + r.direction * t, true);

		if(d < EPSILON)
            break;
        
		t += d;
        
        if(t > MAX_DISTANCE)
            break;
        
        iterations += 1.0;
	}
    
    t = min(t, MAX_DISTANCE);
    
    return vec3(t, iterations / float(MAX_ITERATIONS), d);
}

// Function 1328
float traceSceneRay(vec3 ro, vec3 rd, out vec3 normal, out vec4 color) {
  const vec3 up = vec3(0.0, 1.0, 0.0);

  float minT = 1e10;
  color = vec4(1.0, 1.0, 1.0, 0.0);

  for (int i = 0; i < sceneSpheres.length(); i++) {
    Sphere sphere = sceneSpheres[i];
    vec3 p = sphere.position;
    float r2 = sphere.radius * sphere.radius;
    float t = intersectRaySphere(ro, rd, p, r2);
    if (t > 0.0 && t < minT) {
      normal = (ro + rd * t) - p;
      color = sphere.color;
      minT = t;
    }
  }

  for (int i = 0; i < sceneTris.length(); i++) {
    Tri tri = sceneTris[i];
    float t = intersectRayTri(ro, rd, tri.v0, tri.v1, tri.v2);
    if (t > 0.0 && t < minT) {
      normal = normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));
      color = tri.color;
      minT = t;
    }
  }

  return minT;
}

// Function 1329
float raymarch()
{
  float d = 0.0, t = 0.0;
  for(int i = 0; i < 32; ++i)
  {
    d = sphere(camera.origin + t * camera.direction);
    if(abs(d) < 0.01) return t;
    if(t > 100.0) return -1.0;
    t += d;
  }
  return -1.0;  // no intersection
}

// Function 1330
float normalizedSin(float x) {
    return abs(sin(x));
}

// Function 1331
vec3 normal(vec3 p)
{
 	vec3 P = vec3(-4, 4, 0) * 0.01;

 	return normalize(
        scene(p+P.xyy).z * 
        P.xyy + scene(p+P.yxy).z * 
        P.yxy + scene(p+P.yyx).z * 
        P.yyx + scene(p+P.xxx).z * 
        P.xxx
    );
}

// Function 1332
float raySphere(vec3 ro, vec3 rd)
{
    float lp;
    float dst;
    vec3 p = ro;
    float dfs = 0.;
    // stepping through the sphere till a collition happens
    for (int s = 0; s < 80; s++)
    {
        dst = -(length(p) - 10.);
        
        if (dst < 0.01) break;
        dfs += dst;
        p += rd * dst;
    }
    return dfs;
}

// Function 1333
vec4 height2gray(float h){
	if(h < deepsea)
        return vec4(0.0,0.0,0.0,1.0);
    else if (h < shallowsea)
        return vec4(0.05,0.05,0.05,1.0);
    else if (h < beach)
        return vec4(0.4,0.4,0.4,1.0);
    else if (h < ground)
        return vec4(0.6, 0.6, 0.6, 1.0);
    else
        return vec4(1.0, 1.0, 1.0, 1.0);
}

// Function 1334
vec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {
    vec2 dO = vec2(0.0);
    
    float lastDistEval = 1e10; 
    float dist;
    for(int i=0; i<stepnum; i++) {
        vec3 p = ro + rd*dO.x;
        vec2 dS = GetDist(p);
        dist = dS.x;
        dO.x += dS.x*side;
        dO.y = dS.y;
        
        if(stepnum == MAX_STEPS){
            if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.0005) {
                edge = 1.0;
            }
            if (dist < lastDistEval) lastDistEval = dist;
        }
        
        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;
    }
    
    return dO;
}

// Function 1335
float getRayleighPhase(float cosTheta) {
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

// Function 1336
float rayboxintersect(ray r, aabb box)
{
    float t1 = (box.min.x - r.pos.x) / r.dir.x;
    float t2 = (box.max.x - r.pos.x) / r.dir.x;
    float t3 = (box.min.y - r.pos.y) / r.dir.y;
    float t4 = (box.max.y - r.pos.y) / r.dir.y;
    float t5 = (box.min.z - r.pos.z) / r.dir.z;
    float t6 = (box.max.z - r.pos.z) / r.dir.z;

    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));

    if (tmax < 0.0) // box on ray but behind ray origin
    {
        return MAXDIST;
    }

    if (tmin > tmax) // ray doesn't intersect box
    {
        return MAXDIST;
    }

    return tmin;
}

// Function 1337
vec3 GetNormal( vec3 p )
{
    vec2 d = vec2(-1,1)*epsilon;
    return normalize(
        	SDF(p+d.xxx).x*d.xxx +
        	SDF(p+d.yyx).x*d.yyx +
        	SDF(p+d.yxy).x*d.yxy +
        	SDF(p+d.xyy).x*d.xyy
        );
}

// Function 1338
vec3 GetNormal(vec3 p) {
	vec2 e = vec2(SURFACE_DISTANCE, 0.0);
    float dist = MAP_DETAILED_Scene(p).w;
    return normalize(dist-vec3(
    	MAP_DETAILED_Scene(p-e.xyy).w,
        MAP_DETAILED_Scene(p-e.yxy).w,
        MAP_DETAILED_Scene(p-e.yyx).w
    ));
}

// Function 1339
float dfNormal(vec3 p) {
    return min(p.y+texture(iChannel0, p.xz).x*.04,//floor bump displacement
               min(length(p-vec3(0.,2.,0.))-1.,
                  length(p.xyz-vec3(sin(iTime*.43),.5,cos(iTime*.4))*3.)-1.));
}

// Function 1340
vec3 GetNormal( vec3 p )
{
    vec2 d = vec2(-1,1)*epsilon;
    return normalize(
        	SDF(p+d.xxx)*d.xxx +
        	SDF(p+d.yyx)*d.yyx +
        	SDF(p+d.yxy)*d.yxy +
        	SDF(p+d.xyy)*d.xyy
        );
}

// Function 1341
float ray(vec3 from, vec3 direction) {
    // How far we travelled (so far)
    float travel_distance = 0.0;
    
    for (int i = 0; i < 50; i++) {
        // calculate the current position along the ray
	    vec3 position = from + direction * travel_distance;
	    float distance_to_closest_object = map(position);
    	if (distance_to_closest_object < 0.0001) {
        	return travel_distance;
    	}
        // We can safely advance this far since we know that the closest
        // object is this far away. (But possibly in a completely different
        // direction.)
        travel_distance += distance_to_closest_object;
    }
    
    // We walked 50 steps without hitting anything.
    return 0.0;
}

// Function 1342
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {
    specularBounce = false;
    
    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1./1.5; n2 = 1.;
            n = -n;
        } else {
            n2 = 1./1.5; n1 = 1.;
        }
                
        float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
        
        vec3 ref = refract( rd, n, n2/n1 );        
        if( ref == vec3(0) || hash1(seed) < fresnel || m > 6.5 ) {
            ref = reflect( rd, n );
        }
        
        return ref; // normalize( ref + 0.1 * r );
	}
}

// Function 1343
vec3 normal(vec3 pos)
{
    vec2 eps = vec2(0.001, 0.0);
    return normalize(vec3(	map(pos + eps.xyy).x - map(pos - eps.xyy).x,
                    		map(pos + eps.yxy).x - map(pos - eps.yxy).x,
                         	map(pos + eps.yyx).x - map(pos - eps.yyx).x));
}

// Function 1344
float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){
    vec3 pos = start;
    float h = 0.0;
    float hupper = depth;
    float hlower = 0.0;
    vec2 zer = vec2(0.0);
    vec3 dir = normalize(end - start);
    for(int i=0;i<318;i++){
        h = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;
        if(h + 0.01 > pos.y) {
            return distance(pos, camera);
        }
        pos += dir * (pos.y - h);
    }
    return -1.0;
}

// Function 1345
vec3 wnormal(vec3 a) {
  vec2 e = vec2(EPSILON, 0.);
  float w = world1(a);
  return normalize(vec3(
    world1(a+e.xyy) - w,
    world1(a+e.yxy) - w,
    world1(a+e.yyx) - w));
}

// Function 1346
vec3 calcNormal(vec3 p) {
  float h = 0.0001;
  vec2 k = vec2(1,-1);
  return normalize( k.xyy*map( p + k.xyy*h ) + 
                    k.yyx*map( p + k.yyx*h ) + 
                    k.yxy*map( p + k.yxy*h ) + 
                    k.xxx*map( p + k.xxx*h ) );
}

// Function 1347
vec3 brdf_ray(in vec3 p, in vec3 n, in vec3 rd, in float id)
{
    return cosdir(n);
}

// Function 1348
void raytraceBranchShelf(vec3 u, vec3 d,vec3 o,float r,
                        float p,float y,inout vec3 color,inout float nearestD){
 vec2 s=vec2(sin(p),cos(p))*r;float dd;
 if(!testAABB(u,d,o-vec3(0,s.x,0),vec3(s.y,abs(s.x)+2.,s.y),dd)) return;
 const float b=4.;
 float E=0.;
 for(int i=0;i<8;i++){E=raytraceBranch(u,d,o,r,p,y+PI*float(i)/b,E,color,nearestD);}
 #ifdef DRAW_CLIP_RAYTRACES
 color=mix(color,vec3(0,0,1),.1);
 #endif
}

// Function 1349
void RayStack_Set( int index, RayInfo rayInfo )
{
    rayStack[index] = rayInfo;
}

// Function 1350
void marchRay(inout Ray ray, inout vec3 colour) {
    bool inside = false; // are we inside or outside the glass object
    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours

    vec3 startpoint = ray.origin;
    
#ifdef DEBUG   
vec3 debugColour = vec3(1, 0, 0);
#endif
    
    SDResult result;
    vec3 n;
    vec3 glassStartPos;
    
    //float glow = 0.0;
    
    for (int i=0; i<kMAXITERS; i++) {
        // Get distance to nearest surface
        result = sceneDist(ray);
        
        //glow += result.material == kGLOWMATERIAL ? 
        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01
        //    : 0.0;
        
        // Step half that distance along ray (helps reduce artefacts)
        float stepDistance = (inside ? abs(result.d) : result.d) * 0.25;
        ray.origin += ray.dir * stepDistance;
        //if (length(ray.origin) > 40.0) { break; }
        
        if (stepDistance < eps) {
            // colision
            // normal
            // Get the normal, then clamp the intersection to the surface
    		n = normal(ray);
            //clampToSurface(ray, stepDistance, n);
#ifdef DEBUG
//debugColour = n;
//break;
#endif
            
            if ( result.material == kFLOORMATERIAL ) {
                // ray hit floor
                
                // Add some noise to the normal, since this is pretending to be grit...
                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);
                randomNoise.xz = randomNoise.xz * 2. - 1.;
                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.3);
                
                // Colour is just grey with crappy fake lighting...
                float o = occlusion(ray, n);
                colour += vec3(1) * o * impact;
                impact *= 0.;
                break;
            }
            
            if ( result.material == kMATTEMATERIAL ) {
                // ray hit floor
                
                // Add some noise to the normal, since this is pretending to be grit...
                //vec3 randomNoise = texrand(n.xz * 0.5 + 0.5, 0.0);
                //randomNoise.xz = randomNoise.xz * 2. - 1.;
               // n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z * 0.1);
                
                // Colour is just grey with crappy fake lighting...
                float o = occlusion(ray, n);
                o = pow(o, 2.0);
               // o = 1.0;
                vec3 tex = surfaceColour(ray, n);
                //tex = mod(ray.origin, 1.0);
                //tex = vec3(1);
                vec3 l = texture(iChannel3, n).rgb * 0.5 + 0.5;
                colour += tex * l * o * impact;
                impact *= 0.;
                break;
            }
            
            if (result.material == kGLOWMATERIAL) {
             	colour = mix(colour, kGLOWCOLOUR, impact);
                impact *= 0.;
                break;
            }
            
            // check what material it is...
            
            if (result.material == kMIRRORMATERIAL) {
                
                // handle interior glass / other intersecion
                if (inside) {
                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    				glassStartPos = ray.origin;
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
                }
                
                // it's a mirror, reflect the ray
                ray.dir = reflect(ray.dir, n);
                    
                // Step 2x epsilon into object along normal to ensure we're beyond the surface
                // (prevents multiple intersections with same surface)
                ray.origin += n * eps * 4.0;
                
                // Mix in the mirror colour
                colour += highlight(ray, n);
                impact *= kMIRRORCOLOUR;
                float o = occlusion(ray, n);
                impact *= o;
#ifdef DEBUG
debugColour = vec3(o);
break;
#endif
                
            } else {
                // glass material
            
                if (inside) {
                	// refract glass -> air
                	ray.dir = refract(ray.dir, -n, 1.0/kREFRACT);
                    
                    // Find out how much to tint (how far through the glass did we go?)
                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
#ifdef DEBUG
debugValue += glassTravelDist / 2.0;
#endif
      
                
              	} else {
               		// refract air -> glass
                	glassStartPos = ray.origin;
                    
              	  	// Mix the reflection in, according to the fresnel term
                	float fresnel = fresnelTerm(ray, n, 1.0);
                    fresnel = fresnel;
    				/*
                    colour = mix(
                    	colour, 
                    	texture(iChannel1, reflect(ray.dir, n)), 
                    	vec4(fresnel) * impact);
*/
                    colour = mix(
                        colour,
                        backgroundColour(ray, 0.0),
                        vec3(fresnel) * impact);
                	colour += n.x * 0.1;//highlight(ray, n);
                    impact *= 1.0 - fresnel;
    			
                	// refract the ray
            		ray.dir = refract(ray.dir, n, kREFRACT);
                    
#ifdef DEBUG
//debugValue += 0.5;
#endif
                }
            
            	// Step 2x epsilon into object along normal to ensure we're beyond the surface
                ray.origin += (inside ? n : -n) * eps * 2.0;
                
                // Flip in/out status
                inside = !inside;
            }
        }
        
        // increase epsilon
        eps += divergence * stepDistance;
    }
    
    // So far we've traced the ray and accumulated reflections, now we need to add the background.
   // colour += texture(iChannel0, ray.dir) * impact;
    ray.origin = startpoint;
    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;
    
#ifdef DEBUG
//debugColour.rgb = ray.dir;
//debugColour = vec3(float(debugStep)/2.0);
colour = debugColour;
#endif
}

// Function 1351
vec3 mapNormal(vec3 p,float d) {
    mat3 k = mat3( p, p, p ) - mat3( NEAR );// * d );
    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x) );
}

// Function 1352
vec3 calcNormal(vec3 p, float t) {
	vec2 e = vec2(.5773, -.5773) * t * 1e-4;
	return normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);
}

// Function 1353
vec3 getNormal(vec3 p, inout float edge, inout float crv) { 
	
    // Roughly two pixel edge spread, regardless of resolution.
    vec2 e = vec2(7./iResolution.y, 1);

	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*3.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);
    edge = smoothstep(1., 2., sqrt(edge/e.x*3.));
/*    
    // Wider sample spread for the curvature.
    e = vec2(12./450., 0);
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
*/
    
    e = vec2(.0025, 1); //iResolution.y - Depending how you want different resolutions to look.
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 1354
vec3 normal(in vec3 p, in vec3 ray, in float t) {
	float pitch = .4 * t / iResolution.x;
    vec2 d = vec2(-1,1) * pitch;
	vec3 p0 = p+d.xxx, p1 = p+d.xyy, p2 = p+d.yxy, p3 = p+d.yyx; // tetrahedral offsets
	float f0 = M(p0), f1 = M(p1), f2 = M(p2), f3 = M(p3);
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);
	// prevent normals pointing away from camera (caused by precision errors)
	return normalize(grad - max(.0,dot (grad,ray ))*ray);
}

// Function 1355
Ray reflectionForRay(Ray ray, float fade) {
	vec3 normal = -heightmapNormal(ray.m_point.xy);
	float frensel = abs(dot(ray.m_direction, normal));
	vec3 atten = fade * ray.m_attenuation * 0.9 * (1.0 - frensel*0.98);
	vec3 reflected = reflect(ray.m_direction, normal);

	return newRay(ray.m_point + normal*0.01, reflected, atten);
}

// Function 1356
vec3 getNormal(vec3 p)
{
	vec3 eps=vec3(.1,0,0);
	return normalize(vec3(scene(p+eps.xyy),scene(p+eps.yxy),scene(p+eps.yyx)));
}

// Function 1357
vec3 normal(in vec3 pos)
{
	return normalize(pos);   
}

// Function 1358
void TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)
{
	int lastHitPrimitiveId = 0;
	float colorMultiplier = 1.0; // used by reflections and refractions that aren't fully 1.0
	
	vec3 rayToCameraDir = rayDir;
	
	for(int index = 0; index < c_maxRayBounces; ++index)
	{
		
		SCollisionInfo collisionInfo =
			SCollisionInfo
			(
				0,
				false,
				false,
				-1.0,
				vec3(0.0,0.0,0.0),
				vec3(0.0,0.0,0.0),
				SMaterial(
					1.0,
					vec3(0.0,0.0,0.0),
					1.0,
					vec3(0.0,0.0,0.0),
					vec3(0.0,0.0,0.0),
					0.0,
					0.0,
					0.0
				)
			);

		// run intersection against all objects, including light objects		
		#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		SPHEREPRIMLISTWITHLIGHTS
		#undef PRIM
			
		// run intersections against all boxes
		#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		BOXPRIMLIST
		#undef PRIM

	
		if (collisionInfo.m_foundHit)
		{	
			
			// do texture sampling for the floorbox
			if (collisionInfo.m_Id == floorBox.m_Id)
			{
				collisionInfo.m_material.m_diffuseColor = 
				texture(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;
			}
			
			// point lights
			#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);
			POINTLIGHTLIST
			#undef LIGHT
				
			// directional lights
			#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);
			DIRLIGHTLIST				
			#undef LIGHT

			// ambient light
			pixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * colorMultiplier;
			
			// emissive color
			pixelColor += collisionInfo.m_material.m_emissiveColor * colorMultiplier;		
			
			//do refraction if we should
			if (collisionInfo.m_material.m_refraction > 0.0)
			{					
				if (collisionInfo.m_fromInside)
					collisionInfo.m_surfaceNormal *= -1.0;
				
				// if we are entering a refractive object, we can't ignore it since we need to go out the back
				// side possibly.  Since we can't ignore it, we need to push a little bit past the point of
				// intersection so we don't intersect it again.
				lastHitPrimitiveId = 0;				
				rayPos = collisionInfo.m_intersectionPoint + rayDir * 0.001;
				
				// 
				rayDir = refract(rayToCameraDir, collisionInfo.m_surfaceNormal, collisionInfo.m_material.m_refractionIndex);
				
				colorMultiplier *= collisionInfo.m_material.m_refraction;
				if (colorMultiplier < 0.1)
					return;				
			}
			//else do reflection if we should
			else if (collisionInfo.m_material.m_reflection > 0.0)
			{			
				rayPos = collisionInfo.m_intersectionPoint;
				rayDir = reflect(rayDir, collisionInfo.m_surfaceNormal);
			
				lastHitPrimitiveId = collisionInfo.m_Id;
				colorMultiplier *= collisionInfo.m_material.m_reflection;
			
				if (colorMultiplier < 0.1)
					return;
			}			
			// else we are done
			else
				return;
		}
		// no hit means bail out
		else
		{
			pixelColor+= vec3(0.1,0.1,0.1) * colorMultiplier;
			return;
		}
	}
			
}

// Function 1359
vec3 normal( in vec3 p )
{
	vec3 eps = vec3(0.01, 0.0, 0.0);
	return normalize( vec3(
		map(p+eps.xyy)-map(p-eps.xyy),
		map(p+eps.yxy)-map(p-eps.yxy),
		map(p+eps.yyx)-map(p-eps.yyx)
	) );
}

// Function 1360
void marchRay(inout Ray ray, inout vec4 colour) {
    bool inside = false; // are we inside or outside the glass object
    vec4 impact = vec4(1.0); // This decreases each time the ray passes through glass, darkening colours

#ifdef DEBUG   
vec4 debugColour = vec4(1, 0, 0, 1);
#endif
    
    SDResult result;
    vec3 n;
    vec3 glassStartPos;
    
    for (int i=0; i<kMAXITERS; i++) {
        // Get distance to nearest surface
        result = sceneDist(ray);
        
        // Step half that distance along ray (helps reduce artefacts)
        float stepDistance = inside ? abs(result.d) : result.d;
            //result.material == kGLASSMATERIAL ? abs(result.d) : result.d;
        ray.origin += ray.dir * stepDistance * 0.5;
        if (length(ray.origin) > 30.0) { break; }
        
        if (stepDistance < eps) {
            // colision
            // normal
            // Get the normal, then clamp the intersection to the surface
    		n = normal(ray);
            clampToSurface(ray, stepDistance, n);
#ifdef DEBUG
//debugColour = vec4(-n*1.0, 1);
//debugStep++;
//if (debugStep == 3) break;
          //  break;
//if (mod(ray.origin.y, 1.0) > 0.5) break;
//debugValue += 0.25;
#endif
            
            if ( result.material == kFLOORMATERIAL ) {
                // ray hit floor
                
                // Add some noise to the normal, since this is pretending to be grit...
                vec3 randomNoise = texrand(ray.origin.xz * 0.4);
                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);
                
                // Colour is just grey with crappy fake lighting...
                colour += mix(
                    kFLOORCOLOUR, 
                    vec4(0,0,0,1), 
                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)
                ) * impact;
                impact *= 0.;
                break;
            }
            
            // check what material it is...
            
            if (result.material == kMIRRORMATERIAL) {
                // it's a mirror, reflect the ray
                ray.dir = reflect(ray.dir, n);
                    
                // Step 2x epsilon into object along normal to ensure we're beyond the surface
                // (prevents multiple intersections with same surface)
                ray.origin += n * eps * 2.0;
                
                // Mix in the mirror colour
                impact *= kMIRRORCOLOUR;
                
            } else {
                // glass material
            
                if (inside) {
                	// refract glass -> air
                	ray.dir = refract(ray.dir, -n, 1.0/kREFRACT);
                    
                    // Find out how much to tint (how far through the glass did we go?)
                    float glassTravelDist =  clamp(distance(glassStartPos, ray.origin) / 1.0, 0., 1.);
                    
                    // Get a random colour
                	impact *= mix(vec4(1), kGLASSCOLOUR, glassTravelDist);
                    
#ifdef DEBUG
debugValue += glassTravelDist / 2.0;
#endif
      
                
              	} else {
               		// refract air -> glass
                	glassStartPos = ray.origin;
                    
              	  	// Mix the reflection in, according to the fresnel term
                	float fresnel = fresnelTerm(ray, n, 2.0);
    				colour = mix(
                    	colour, 
                    	texture(iChannel1, reflect(ray.dir, n)), 
                    	vec4(fresnel) * impact);
                    impact *= 1.0 - fresnel;
    			
                	// refract the ray
            		ray.dir = refract(ray.dir, n, kREFRACT);
                    
#ifdef DEBUG
//debugValue += 0.5;
#endif
                }
            
            	// Step 2x epsilon into object along normal to ensure we're beyond the surface
                ray.origin += (inside ? n : -n) * eps * 2.0;
                
                // Flip in/out status
                inside = !inside;
            }
        }
        
        // increase epsilon
        eps += divergence * stepDistance;
    }
    
    // So far we've traced the ray and accumulated reflections, now we need to add the background.
    colour += texture(iChannel0, ray.dir) * impact;
    
    
#ifdef DEBUG
//debugColour.rgb = ray.dir;
debugColour.rgb = vec3(float(debugStep)/2.0);
colour = debugColour;
#endif
}

// Function 1361
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start
          dt = 0.,
         den = 0., _den, lut;
    for(int i=0; i<550; i++) {
        vec3 pos = ro + t*rd;
        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;
                                    // --- compute deltaInt-density
        _den = den; den = map(pos); // raw density
        lut = LUTs( _den, den );    // shaped through transfer function
        
        if( lut > .0                // optim
       //   && abs(pos.x) > .5      // cut a slice 
          ) {                       // --- compute shading
            
#if 0                               // finite differences
            vec2 e = vec2(.3,0);
            vec3 n = normalize( vec3( map(pos+e.xyy) - den,
                                      map(pos+e.yxy) - den,
                                      map(pos+e.yyx) - den ) );
         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
            float dif = clamp( -dot(n, sundir), 0., 1.);
#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm
         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction 
            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse
#endif
          // dif = 1.;
           vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse
          //     col = lin * mix( vec3(1,.95,.8), vec3(.25,.3,.35), lut );// pseudo- shadowing with in-cloud depth ? 
          //     col = lin * clamp(1.-lut,0.,1.);
                 col = vec3(.2 + dif);
             col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog
             sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;
        }
        t += dt = .06; // max(.05,.02*t); // stepping
    }

    return sum; // clamp( sum, 0., 1. );
}

// Function 1362
vec4 raymarch(vec3 from, vec3 increment)
{
	const float maxDist = 200.0;
	const float minDist = 0.001;
	const int maxIter = RAYMARCH_ITERATIONS;
	
	float dist = 0.0;
	
	float lastDistEval = 1e10;
#ifdef TRADITIONAL
	float edge = 1.0;
#else
	float edge = 0.0;
#endif
	
	for(int i = 0; i < maxIter; i++) {
		vec3 pos = (from + increment * dist);
		float distEval = distf(pos);
		
#ifdef TRADITIONAL
		if (distEval < minDist) {
			if (i > RAYMARCH_ITERATIONS - 5) edge = 0.0;
			// Probably should put a break here, but it's not working with GL ES...
		}
#else
	#ifdef PERSPECTIVE_FIX
		// Could not figure out the math :P
		if (lastDistEval < (EDGE_WIDTH / dist) * 20.0 && distEval > lastDistEval + 0.001) {
			edge = 1.0;
		}
	#else
		if (lastDistEval < EDGE_WIDTH && distEval > lastDistEval + 0.001) {
			edge = 1.0;
			// Also should put a break here, but it's not working with GL ES...
		}
	#endif
		if (distEval < minDist) {
			break;
		}
#endif
		
		dist += distEval;
		if (distEval < lastDistEval) lastDistEval = distEval;
	}
	
	return vec4(dist, 0.0, edge, 0);
}

// Function 1363
vec3 sampleReflectionMap(vec3 sp, float lodBias){
    #ifdef LOD_BIAS
    	lodBias = LOD_BIAS;
    #endif
    vec3 color = SRGBtoLINEAR(textureLod(iChannel0, sp, lodBias).rgb);
    #if defined (HDR_FOR_POORS)
    	//color *= 1.0 + 2.0*smoothstep(hdrThreshold, 1.0, dot(LUMA, color)); //HDR for poors
    	color = InvTM(color, hdrThreshold);
   	#endif
    return color;
}

// Function 1364
float RayMarch( in vec3 ro, in vec3 rd )
{
	float precis = 0.0005;
    float h		 = precis*.2;
    float t		 = 0.01;
	float res	 = 2000.0;
	bool hit	 = false;

    for( int i=0; i< 150; i++ )
    {
		if (!hit && t < 8.0)
		{
			h = de(ro + rd * t);
			t += h * .8;
			if (h < precis)
			{
				res = t;
				hit = true;;
			}
			precis *= 1.03;
		}
    }
	
    return res;
}

// Function 1365
vec3 calcNormal( in vec3 pos )
{
	float e = 0.5773*0.0005;
	return normalize(
		float3(e, -e, -e)	* map(pos + float3(e, -e, -e)) +
		float3(-e, -e, e)	* map(pos + float3(-e, -e, e)) +
		float3(-e, e, -e)	* map(pos + float3(-e, e, -e)) +
		float3(e, e, e)		* map(pos + float3(e, e, e)));
}

// Function 1366
vec3 raymarch(Ray ray)
{
    vec3 glowBase = vec3(1., .0, .3) * .002;
    vec3 glow = vec3(0.);
    float t = 0.;
    for (int i = 0; i < maxSteps && t <= maxDistance; i++)
    {
        vec3 currentPos = rayToPos(ray, t);
        Hit closestHit = map(currentPos);
        
        if (closestHit.t < hitThreshold)
        {
            vec3 normal = calcNormal(currentPos);
            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);
            return color + glow;
        }
        t += closestHit.t;
        glow += glowBase;
    }

    return vec3(0.01, 0.02, 0.03) + glow;
}

// Function 1367
vec3 gettorusnormal(vec3 pos) {
    float xp = torussdf(pos + vec3(eps, 0., 0.));
    float xm = torussdf(pos - vec3(eps, 0., 0.));
    float ddx = xp - xm;
    float yp = torussdf(pos + vec3(0., eps, 0.));
    float ym = torussdf(pos - vec3(0., eps, 0.));
    float ddy = yp - ym;
    float zp = torussdf(pos + vec3(0., 0., eps));
    float zm = torussdf(pos - vec3(0., 0., eps));
    float ddz = zp - zm;
    return normalize(vec3(ddx, ddy, ddz));
}

// Function 1368
vec3 Ray( float zoom, vec2 fragCoord )
{
	return vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );
}

// Function 1369
Ray get_ray(in vec2 uv) {
	uv = uv*2.0 - 1.0;
	uv.x *= float(iResolution.x) / iResolution.y;
	Ray ray;
	ray.pos = vec3(0.0, 2.0, 9.0);
    ray.dir = normalize(vec3(uv*tan(radians(FOV * 0.5)), -1.0));
	ray.mat = 0.0;
	ray.energy = vec3(1.0);
	return ray;
}

// Function 1370
vec3 rayIntersect( vec3 ro, vec3 rd )
{

    vec3 t = vec3( 0.0, 0.0, 0.0);
    int maxiter = 64;
    
    for(int i = 0; i < maxiter; ++i )
    {
    
    	vec3 hit = ro + rd * t;
        vec3 d = map(hit);
        t += d * vec3( 0.5 );
    
    }
    
    return t;

}

// Function 1371
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.;
    float tmax = 80.0;
    
	float precis = 0.001;
    float t = tmin;
    float m = 0.0;
    for( int i=0; i<80; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
   		m = res.y;
    }

    if( t>tmax ) m=-1.;
    return vec2( t, m );
}

// Function 1372
vec2 sdSceneNormal(vec3 pos)
{
	return vec2(sdPlane(pos, -.75), 1.);
}

// Function 1373
float rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)
{
    d = max(d,.0);
    bool hit = false;
	float de = 0.0, od = 0.0;
    for (int i = 0; i < 150; i++)
    {
        de = mapDE(pos + dir * d);

       if(de < sphereSize(d)  || d > 2000.0) break;

        od = d;
		d += 0.5*de;

   
    }
	if (d < 2000.0)
        d = binarySubdivision(pos, dir, vec2(d, od));
	else
		d = 2000.0;
    
    return d;
}

// Function 1374
v3 GetNormal(v2 u
){v1 e = v1(0.003,0.)
 ;v0 o=map(u,-1)
 ;return v3(norma(v2(map(u+e.xyy,-1)
                    ,map(u+e.yxy,-1)
                    ,map(u+e.yyx,-1))-o),o);}

// Function 1375
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        SDF(vec3(p.x + EPSILON, p.y, p.z)).x - SDF(vec3(p.x - EPSILON, p.y, p.z)).x,
        SDF(vec3(p.x, p.y + EPSILON, p.z)).x - SDF(vec3(p.x, p.y - EPSILON, p.z)).x,
        SDF(vec3(p.x, p.y, p.z  + EPSILON)).x - SDF(vec3(p.x, p.y, p.z - EPSILON)).x
    ));
}

// Function 1376
rayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {
	vec3 mapPos = floor(rayPos);
    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = sign(rayDir);
    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    vec3 mask;
    bool hit = false;
    for (int i = 0; i < 9; i++) {
		mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);
		sideDist += vec3(mask) * deltaDist;
		mapPos += vec3(mask) * rayStep;
		
        if (mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;
        if (getHit(mapPos - offset)) { 
            hit = true; 
            break;
        }

	}
    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;
   	vec2 uv;
    vec3 tangent1;
    vec3 tangent2;
    if (abs(mask.x) > 0.) {
        uv = endRayPos.yz;
        tangent1 = vec3(0,1,0);
        tangent2 = vec3(0,0,1);
    }
    else if (abs(mask.y) > 0.) {
        uv = endRayPos.xz;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,0,1);
    }
    else {
        uv = endRayPos.xy;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,1,0);
    }
    uv = fract(uv);
    rayCastResults res;
    res.hit = hit;
    res.uv = uv;
    res.mapPos = mapPos;
    res.normal = -rayStep * mask;
    res.tangent = tangent1;
    res.bitangent = tangent2;
    res.rayPos = endRayPos;
    res.dist = length(rayPos - endRayPos);
    return res;
}

// Function 1377
vec3 calculateReflection( vec3 currentPixelColor, vec3 viewDir, HitInfo hitInfo )
{    
     Ray reflectionRay;
     reflectionRay.direction = normalize( reflect( hitInfo.rayDir, hitInfo.normal ) );
     reflectionRay.origin = hitInfo.position + hitInfo.normal * Epsilon;
    
     HitInfo rHitInfo = intersect( reflectionRay );
     currentPixelColor += ( rHitInfo.diffuseColor * hitInfo.reflectionIntensity );
    
    
     return currentPixelColor;
}

// Function 1378
RayHit raymarching(inout RayHit ray)
{
    RayHit nohit;
    ray.uv = ray.dir;
    
    //ray
    for (int i = 0; i < 400; i++)
    {        
      	Hit hit = mapDistance(ray.pos);
        ray.hit = hit;
        ray.distanceTotal	+= hit.distanceRadius;           // total
        ray.pos 			+= hit.distanceRadius * ray.dir; // walk point to direction
        
        if (hit.distanceRadius < .01) break;						// so close... performance otimization...
        if (hit.distanceRadius > 500.) { ray = nohit; break; }	// so far..... performance otimization...
 
    }
    if (ray.pos.x != 0.){
        ray.clo = close3d(ray);
        ray.nor = normal3d(ray);
        ray.refl = reflect(ray.dir, ray.nor );
    }
    
    return ray;
}

// Function 1379
Ray GetCameraRay(Camera cam, const vec2 uv)
{
    Ray o;
    
    o.o = cam.pos;
  	o.d = normalize(uv.x * cam.right +
                    uv.y * cam.up +
                    cam.forward * cam.fPersp);
    o.n = 1.;
    return o;
}

// Function 1380
vec3 rayColor(vec3 ro, vec3 rd, vec2 iMouse, float iTime, vec2 seed) {
    vec3 color = vec3(1);
    
    vec3 ro_ = ro;
    vec3 rd_ = rd;
    for (int i = 0; i < 5; i++) {
        float t;
        if (rayMarch(ro_, rd_, iMouse, iTime, t)) {
            vec3 pos = ro_ + rd_ * t;
            vec3 normal = calcNormal(pos, iMouse, iTime);            
            
            vec3 scatter_direction = normal + random_unit_vector(seed + float(i));
            // catch degenerate scatter direction
            if (near_zero(scatter_direction)) {
                scatter_direction = normal;
            }
            ro_ = pos;
            rd_ = scatter_direction;
            
            color *= appleCol;
        } else {
            vec3 unit_direction = normalize(rd);
            float t = 0.5 * (unit_direction.y + 1.0);
            color *= mix(appleCol, skyCol, t);
            return color;
        }
    }
    
    return vec3(0);
}

// Function 1381
vec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState, in vec2 fragCoord)
{
    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);
    
    vec3 rayPos = startRayPos;
    vec3 rayDir = startRayDir;
       
    for (int i = 0; i <= c_numBounces; ++i)
    {
        SRayHitInfo hitInfo;
		hitInfo.hitAnObject = false;
        hitInfo.dist = c_superFar;
        
        // ray trace first, which also gives a maximum distance for ray marching
        RayTraceScene(rayPos, rayDir, hitInfo);
        
        // ray march next
        RayMarchScene(rayPos, rayDir, hitInfo);
        
        // Volumetric ray march after that
        vec3 absorption;
        RayMarchVolumetric(rayPos, rayDir, hitInfo, absorption, rngState, fragCoord);
        
        // apply absorption to the color multiplier before shading the object or sampling the skybox
        colorMultiplier *= absorption;
        
		// handle ray misses by sampling a skybox and exiting the loop
        if (!hitInfo.hitAnObject)
        {
            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;
            break;
        }
                      
        // update the ray position
        rayPos += rayDir * hitInfo.dist;
               
        // get the material info if it was a ray marched object
        if (hitInfo.objectPass == OBJECTPASS_RAYMARCH)
			hitInfo = TestSceneMarch(rayPos);
                
		// add in emissive lighting
        ret += hitInfo.material.emissive * colorMultiplier;
        
        // set up the next ray direction       
        if (hitInfo.objectPass == OBJECTPASS_RAYMARCHVOLUMETRIC)
        {            
            // volumetrics set up their own raydir in the normal
			rayDir = hitInfo.normal;
        }
        else
        {
            // figure out whether we are going to shoot out a specular or diffuse ray.
            // If neither, exit
            float diffuseLength = length(hitInfo.material.diffuse);        
            float specularLength = length(hitInfo.material.specular);
            if (diffuseLength + specularLength == 0.0f)
                break;
            float specularWeight = specularLength / (diffuseLength + specularLength);       
            float doSpecular = float(RandomFloat01(rngState) < specularWeight);
            
        	float roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);
        	vec3 reflectDir = reflect(rayDir, hitInfo.normal);
            
			vec3 randomDir = RandomUnitVector(rngState);
        	rayDir = normalize(mix(reflectDir, randomDir, roughness));
        	if (dot(rayDir, hitInfo.normal) < 0.0f)
            	rayDir *= -1.0f;        
        
        	// move the ray away from the surface it hit a little bit
        	rayPos += hitInfo.normal * c_rayPosNormalNudge;
            
            // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)
            hitInfo.material.diffuse *= dot(hitInfo.normal, rayDir);
            
            // Make all future light affected be modulated by either the diffuse or specular reflection color
            // depending on which we are doing.
            colorMultiplier *= mix(hitInfo.material.diffuse, hitInfo.material.specular, doSpecular);                 
        }
        
        // Russian Roulette
        // Randomly terminate a path with a probability inversely equal to the throughput
        {
        	float p = max(colorMultiplier.r, max(colorMultiplier.g, colorMultiplier.b));
        	if (RandomFloat01(rngState) > p)
            	break;

        	// Add the energy we 'lose' by randomly terminating paths
        	colorMultiplier *= 1.0f / p;            
        }
    }
    
    return ret;
}

// Function 1382
float ct_normal_mod_pi(
    in vec2 z
){
    float a = atan(z[1], z[0]);
    if (a < 0.0) a += 6.28318;
    return mod(a, 1.0);
}

// Function 1383
vec3 calcNormalMed( in vec3 pos, float t )
{
	float e = 0.005*t;
    vec2  eps = vec2(e,0.0);
    float h = terrainMed( pos.xz );
    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));
}

// Function 1384
bool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {
    float testingHeight = MAX_ELEVATION;

    if(!intersectSphere(origin, ray, Sphere(sphere_center, sphere_radius + testingHeight), m)) {
        return false;
    }
    
    normal = normalize(m);

    // Start slow scan
    for(int i = 0; i<400; i++) {
        float r = length(m - sphere_center) - sphere_radius;
        
        // m exits sphere
        if(r > MAX_ELEVATION+STEP) {
            return false;
        }
        
        float dist = r - getHeight(m);
        
        // side collision
        if(dist < -STEP) {
            normal = computeNormalAndSnapPoint(m);
            return true;
        }
        if(dist < STEP) {
            normal = computeNormal(m);
            m += ray * dist;
            return true;
        }
        m += ray * STEP;    
    }
    
    return false;
}

// Function 1385
vec3 goursatnormal(Surface surface, vec3 p) {
  // 4ppp + 4k(p.p)p + 2k'a^2p
  float k = surface.params[0];
  float k1 = surface.params[1];
  float a = surface.params[3];
  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;
}

// Function 1386
vec3 normalMap( in vec2 pos )
{
	pos *= 2.0;
	
	float v = texture( iChannel3, 0.015*pos ).x;
	vec3 nor = vec3( texture( iChannel3, 0.015*pos+vec2(1.0/1024.0,0.0)).x - v,
	                 1.0/16.0,
	                 texture( iChannel3, 0.015*pos+vec2(0.0,1.0/1024.0)).x - v );
	nor.xz *= -1.0;
	return normalize( nor );
}

// Function 1387
float distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {
    h = dot(p-ro,rd);
    return length(p-ro-rd*h);
	//return length(cross(p-ro,rd));
}

// Function 1388
vec3 calcNormal( in vec3 pos )
{
    float kk;
    float eps = 0.0002;
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, kk ) + 
					  e.yyx*map( pos + e.yyx, kk ) + 
					  e.yxy*map( pos + e.yxy, kk ) + 
					  e.xxx*map( pos + e.xxx, kk ) );

#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 nor = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        nor += e*map(pos+eps*e, kk);
    }
    return normalize(nor);
#endif    
}

// Function 1389
vec3 GetSurfaceNormal(vec3 hitPos, Object obj)
{
	if (IsQuad(obj))
		return obj.quadNormal;
	else
		return normalize(hitPos - obj.pos);
}

// Function 1390
Ray get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )
{
	Ray view_ray;
	view_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;
	view_ray.d = normalize( view_ray.o );
	return view_ray;
}

// Function 1391
float intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius)
{
    vec3 oc = origin - center;
    float a = dot(direction, direction);
    float b = 2. * dot(oc, direction);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4. * a * c;
    if (disc < 0.) {
        // no intersection?
        return -1.;
    } else {
        return (-b - sqrt(disc)) / (2. * a);
    }
}

// Function 1392
vec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {
  vec2 xy = fragCoord - size * 0.5;
  float z = size.y / tan(radians(fov) * 0.5);
  return normalize(vec3(xy, -z));
}

// Function 1393
vec3 normal( vec3 p )
{
    vec2 e = 0.001 * vec2(1, -1);
    return normalize(
          e.xxx * map(p+e.xxx)
        + e.xyy * map(p+e.xyy)
        + e.yxy * map(p+e.yxy)
        + e.yyx * map(p+e.yyx)
    );
}

// Function 1394
rayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset, vec4 range) {
	vec3 mapPos = floor(rayPos);
    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = sign(rayDir);
    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    vec3 mask;
    bool hit = false;
    for (int i = 0; i < 50; i++) {
		mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);
		sideDist += vec3(mask) * deltaDist;
		mapPos += vec3(mask) * rayStep;
		
        if (!inRange(mapPos.xy, range) || mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;
        if (getHit(mapPos - offset)) { 
            hit = true; 
            break;
        }

	}
    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;
   	vec2 uv;
    vec3 tangent1;
    vec3 tangent2;
    if (abs(mask.x) > 0.) {
        uv = endRayPos.yz;
        tangent1 = vec3(0,1,0);
        tangent2 = vec3(0,0,1);
    }
    else if (abs(mask.y) > 0.) {
        uv = endRayPos.xz;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,0,1);
    }
    else {
        uv = endRayPos.xy;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,1,0);
    }
    uv = fract(uv);
    rayCastResults res;
    res.hit = hit;
    res.uv = uv;
    res.mapPos = mapPos;
    res.normal = -rayStep * mask;
    res.tangent = tangent1;
    res.bitangent = tangent2;
    res.rayPos = endRayPos;
    res.dist = length(rayPos - endRayPos);
    return res;
}

// Function 1395
vec3 calcNormal( in vec3 pos )
{
    vec2 eps = vec2(0.0, EPSILON);
    vec3 normal = normalize(vec3(
        distfunc(pos + eps.yxx).x - distfunc(pos - eps.yxx).x,
        distfunc(pos + eps.xyx).x - distfunc(pos - eps.xyx).x,
        distfunc(pos + eps.xxy).x - distfunc(pos - eps.xxy).x));
    return normal;
}

// Function 1396
vec3 getNormal(vec3 pos, float e, float o)
{
    vec2 q = vec2(0, e);
    if (o==0.) return normalize(vec3(map_obj(pos + q.yxx) - map_obj(pos - q.yxx),
                          map_obj(pos + q.xyx) - map_obj(pos - q.xyx),
                          map_obj(pos + q.xxy) - map_obj(pos - q.xxy)));
    else return normalize(vec3(map_floor(pos + q.yxx) - map_floor(pos - q.yxx),
                          map_floor(pos + q.xyx) - map_floor(pos - q.xyx),
                          map_floor(pos + q.xxy) - map_floor(pos - q.xxy)));
}

// Function 1397
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 vri, vf, hv, p;
  vec2 edN[3], pM, gIdP;
  float dHit, d, s, eps;
  eps = 0.0005;
  edN[0] = vec2 (1., 0.);
  edN[1] = 0.5 * vec2 (1., sqrt3);
  edN[2] = 0.5 * vec2 (1., - sqrt3);
  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));
  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));
  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),
     dot (ro.xz, edN[2])) / hgSize;
  pM = HexToPix (PixToHex (ro.xz / hgSize));
  gIdP = vec2 (-99.);
  dHit = 0.;
  for (int j = 0; j < 160; j ++) {
    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;
    s = Minv3 (hv);
    p = ro + dHit * rd;
    gId = PixToHex (p.xz / hgSize);
    if (gId.x != gIdP.x || gId.y != gIdP.y) {
      gIdP = gId;
      SetObjConf ();
    }
    d = ObjDf (p);
    if (dHit + d < s) {
      dHit += d;
    } else {
      dHit = s + eps;
      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));
    }
    if (d < eps || dHit > dstFar || p.y < 0.) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 1398
Hit raymarch(Ray ray) {

    vec3 p = ray.ori;
    bool h = false;
    
    for(int i = 0; i < 64; i++) {
        
        float dst = dstScene(p);
        p += ray.dir * dst * .5;
        
        if(dst < .001) {
         
            h = true;
            break;
            
        }
        
    }
    
    return Hit(p,h);
    
}

// Function 1399
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,
                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,
                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );
    return normalize(nor);
}

// Function 1400
vec3 SuperFastNormalFilter(sampler2D _tex,ivec2 iU,float strength){
    float p00 = GetTextureLuminance(_tex,iU);
    return normalize(vec3(-dFdx(p00),-dFdy(p00),1.-strength));
}

// Function 1401
vec3 normal(vec3 p) {
    return normalize(vec3(
        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),
        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),
        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1402
vec3 normal(vec3 p) {
    float d = sdf(p).dist;
    vec2 e = vec2(.001, 0.);
    
    vec3 n = d - vec3(sdf(p - e.xyy).dist,
                      sdf(p - e.yxy).dist,
                      sdf(p - e.yyx).dist);
	return normalize(n);
}

// Function 1403
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p, rdi, s, cIdP;
  float dHit, d, eps;
  eps = 0.0005;
  dHit = eps;
  if (rd.x == 0.) rd.x = 0.001;
  if (rd.y == 0.) rd.y = 0.001;
  if (rd.z == 0.) rd.z = 0.001;
  ro /= bSize;
  rd /= bSize;
  rdi = 1. / rd;
  cIdP = vec3 (-99.);
  stepCnt = 0.;
  for (int j = 0; j < 180; j ++) {
    p = ro + dHit * rd;
    cId = floor (p);
    if (cId.x != cIdP.x || cId.y != cIdP.y || cId.z != cIdP.z) {
      SetEngConf ();
      cIdP = cId;
    }
    s = (cId + step (0., rd) - p) * rdi;
    d = min (ObjDf (bSize * (p - cId - 0.5)), abs (min (min (s.x, s.z), s.y)) + eps);
    dHit += d;
    ++ stepCnt;
    if (d < eps || dHit > dstFar) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 1404
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                    e.yyx*map( pos + e.yyx ).x +
                    e.yxy*map( pos + e.yxy ).x +
                    e.xxx*map( pos + e.xxx ).x );
}

// Function 1405
vec3 calcNormal(vec3 pos)
{
    // Center sample
    float c = dist(pos);
    // Use offset samples to compute gradient / normal
    vec2 eps_zero = vec2(0.1, 0.0);
    return normalize(vec3( dist(pos + eps_zero.xyy), dist(pos + eps_zero.yxy), dist(pos + eps_zero.yyx) ) - c);
}

// Function 1406
vec3 normalHigh(vec3 x) {
	const vec2 eps = vec2(0.05, 0.0);
	float h = sceneHigh(x);
	return normalize(vec3(
		(sceneHigh(x+eps.xyy)-h),
		(sceneHigh(x+eps.yxy)-h),
		(sceneHigh(x+eps.yyx)-h)
	));
}

// Function 1407
vec3 ellipsoidNormal( in vec3 pos, in Ellipsoid sph )
{
  return normalize((pos-sph.center) / sph.radius);
}

// Function 1408
vec3 getRay(vec3 rayDir, float rot) {
	rayDir = normalize(rayDir);
    float cosVal = cos(rot);
    float sinVal = sin(rot);    
    return vec3((rayDir.x * cosVal) + (rayDir.z * sinVal), rayDir.y, (rayDir.z * cosVal) - (rayDir.x * sinVal));
}

// Function 1409
bool VoxelRayCast(vec3 ro, vec3 rd, bool isPrimaryRay, /**/ out vec3 vp, out vec3 fm, out float t)
{
	vec3 pos = floor(ro);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 off = (-ro + (rs * 0.5 + 0.5)) * ri;

	vec3 mm = vec3(0.0);
    
	bool hit = false;
	for(int i = 0; i < 128; i++) 
	{
		if(map(pos, isPrimaryRay)) { hit = true; break; }
        
        vec3 dis = pos * ri + off;// re-comp dis every iter so we dont accu float errors
		mm = step(dis.xyz, dis.yzx) * (1.0 - step(dis.zxy, dis.xyz));
        pos += mm * rs;
	}
	
    // intersect the cube	
    vec3 mini = (pos - rs) * ri + off;   
	t = max(mini.x, max(mini.y, mini.z));

	fm = mm;
	vp = pos;

	return hit;
}

// Function 1410
vec3 get_normal(vec3 pos)
{
    vec3 eps = vec3(0.0001,0.0,0.0);
	return normalize(vec3(
           f(pos+eps.xyy) - f(pos-eps.xyy),
           f(pos+eps.yxy) - f(pos-eps.yxy),
           f(pos+eps.yyx) - f(pos-eps.yyx)));
}

// Function 1411
vec2 castRay( in vec4 ro, in vec4 rd, in float maxd ) {
            float t = 2.0;
        	float precis = 0.0005;
             float h=precis*2.0;
    
        	vec2 res;
            for( int i=0; i<RAY_STEP; i++ ) {
                if (abs(h)<precis || t>maxd ) break;
                 
                 t += h;
                  res = map( ro+rd*t );
                   h = res.x;
            }
             return vec2( t, t>=maxd ? -1. : res.y );
        }

// Function 1412
vec2 raymarch_main_scene(vec3 _p, float t)
{
    vec2 sand = scene_base_sand(_p);
    #if defined(ENABLE_HD_SAND_DEPTH)
    sand.x = max(sand.x, -(length(_p-vec3(30., 10., 140.))-90.));
    #else
    sand.x = max(sand.x, -(length(_p-vec3(-20., 2., 53.))-16.));
    #endif
    #if defined(ENABLE_REEDS)
 	return scene_min(scene_reeds(_p-vec3(1., 0., -3.), sand.x, t), scene_min(sand, scene_pyramids(_p)));
    #else
        return scene_min(sand, scene_pyramids(_p));
    #endif
}

// Function 1413
float TransObjRay (vec3 ro, vec3 rd)
{
  float dTol = 0.001;
  float d;
  float dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = TransObjDf (ro + dHit * rd);
    dHit += d;
    if (d < dTol*(1.0+dHit) || dHit > dstFar) break;
    dTol *= 1.01;
  }
  return dHit;
}

// Function 1414
vec3 normalise(float amp1, float amp2)
{

	return vec3((amp1 + amp2 + 2.) / 4.);   
}

// Function 1415
bool castRay(vec3 ro, vec3 rd, out float resT)
{
    const float mint = 45.;
    const float maxt = 170.0;
    
    float dt = .5;
    float lh = 0.0;
    float ly = 0.0;
    
    float t = mint;
    
    for (float t = mint; t < maxt; t += dt)
    {
        vec3 p = ro + rd * t;
        p.y += sin(iTime) * BOB;
        float h = sceneSDF(p);
        if ((p.y >= 0. && p.y < h) || (p.y <= 0. && p.y > h))
        {
            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);
            return true;
        }
        lh = h;
        ly = p.y;
        dt = .01 * t;
    }
    
    return false;
}

// Function 1416
vec3 getNormal(vec3 p )
{
    float eps = 0.05;
   // if(p.y>1.0) return vec3(0.0,1.0,0.0);
    return normalize( vec3( getHeightMap(vec2(p.x-eps,p.z)) - getHeightMap(vec2(p.x+eps,p.z)),
                            2.0*eps,
                            getHeightMap(vec2(p.x,p.z-eps)) - getHeightMap(vec2(p.x,p.z+eps)) ));
}

// Function 1417
vec3 normal( in vec3 x)
{
    vec2 e = vec2( .01, 0.0 );
    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,
                            map(x+e.yxy).x - map(x-e.yxy).x,
                            map(x+e.yyx).x - map(x-e.yyx).x ) );
}

// Function 1418
vec3 GetNormalForReflection(vec3 p) {
	vec2 e = vec2(SURFACE_DISTANCE, 0.0);
    float dist = MAP_SIMPLE_Scene(p).w;
    return normalize(dist-vec3(
    	MAP_SIMPLE_Scene(p-e.xyy).w,
        MAP_SIMPLE_Scene(p-e.yxy).w,
        MAP_SIMPLE_Scene(p-e.yyx).w
    ));
}

// Function 1419
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = VAR_ZERO; j < 80; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.5, 0.8 * h);
  }
  if (h < 0.) {
    sHi = s;
    for (int j = VAR_ZERO; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > GrndHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 1420
vec3 normal(in vec3 at) {
	vec2 e = vec2(0., NORMAL_EPSILON);
	return normalize(vec3(world(at+e.yxx)-world(at), 
						  world(at+e.xyx)-world(at),
						  world(at+e.xxy)-world(at)));
}

// Function 1421
vec3 NormalSinPowWarpOffset(vec3 pos, vec3 offset, float freq, float amp, float power) {
	return NormalSinPowWarp(pos + offset, freq, amp, power) - offset;
}

// Function 1422
vec3 getNormal(vec3 hitPos) {
	const float derivDist = 0.00001;
	const float derivDist2 = 2.0 * derivDist;
	float x = hitPos.x;
	float y = hitPos.y;
	float z = hitPos.z;
	vec3 surfaceNormal;
	surfaceNormal.x = distanceField(vec3(x + derivDist, y, z)) 
					- distanceField(vec3(x - derivDist, y, z));
	surfaceNormal.y = distanceField(vec3(x, y + derivDist, z)) 
					- distanceField(vec3(x, y - derivDist, z));
	surfaceNormal.z = distanceField(vec3(x, y, z + derivDist)) 
					- distanceField(vec3(x, y, z - derivDist));
	surfaceNormal = normalize(surfaceNormal / derivDist2);
	return surfaceNormal;
}

// Function 1423
float rayMarch(vec3 ro, vec3 rd, float start)
{
    float t = start;
    for (int i = 0; i < 256; ++i)
    {
        float d = sdf(ro + rd * t);
        if (d < VERY_SMOL)
            return t;
        t += d;
        if (t >= MAX_DIST) return MAX_DIST;
    }
    return -t;
}

// Function 1424
float rayff(float t) {
    return pa_map(pa_init(t)).a[1];
}

// Function 1425
vec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {
	vec3 f = normalize(lookAt - ro),
	     r = normalize(cross(vec3(0, 1, 0), f));
	return normalize(f + r * uv.x + cross(f, r) * uv.y);
}

// Function 1426
vec3 getNormal(in vec3 p) {
    vec2 eps = vec2(0.005, 0.0);
    return normalize(vec3(intersect(p + eps.xyy).y - intersect(p - eps.xyy).y,
                          intersect(p + eps.yxy).y - intersect(p - eps.yxy).y,
                          intersect(p + eps.yyx).y - intersect(p - eps.yyx).y));
}

// Function 1427
float RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )
{
    //Variation of the Distance Field Soft Shadow from : https://www.shadertoy.com/view/Xds3zN
    //Initialize the minimum aperture (angle tan) allowable with this distance-field technique
    //(45deg: sin/cos = 1:1)
    float minAperture = 1.0; 
    float t = 0.0; //initial travel distance, from geometry surface (usually, pretty close)
    float dist = 10.0;
    for( int i=0; i<7; i++ )
    {
        vec3 p = o+L*t; //Sample position = ray origin + ray direction * travel distance
        float dist = DF_composition( p ).d;
        dist = min(dist,t);
        float curAperture = dist/t; //Aperture ~= cone angle tangent (sin=dist/cos=travelDist)
        minAperture = min(minAperture,curAperture);
        //Step size : limit range (0.02-0.42)
        t += 0.02+min(dist,0.4);
    }
    
    //The cone width controls shadow transition. The narrower, the sharper the shadow.
    return saturate(minAperture/coneWidth); //Should never exceed [0-1]. 0 = shadow, 1 = fully lit.
}

// Function 1428
float phase_ray( float cc ) {
	return ( 3.0 / 16.0 / PI ) * ( 1.0 + cc );
}

// Function 1429
bool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 normal, out vec3 hitPos, inout float maxTime)
{
    if (sphere.w <= 0.0)
        return false;
    
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
        return false;
    
    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)
    if (collisionTime > maxTime)
        return false;
    
    // store the collision time as the new max time
    maxTime = collisionTime;
    
	//compute the point of intersection
	hitPos = rayPos + rayDir * collisionTime;    
    
   	// calculate the normal
	normal = hitPos - sphere.xyz;
	normal = normalize(normal); 

	return true;
}

// Function 1430
vec3 getNormal(vec3 p, inout float edge, inout float crv) { 
	
    // Roughly two pixel edge spread, regardless of resolution.
    vec2 e = vec2(6./iResolution.y, 0);

	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
/*    
    // Wider sample spread for the curvature.
    e = vec2(12./450., 0);
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
*/
    
    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 1431
Ray genRay(Camera c, in vec2 uv, float ratio, in float Xi1, in float Xi2, in float time ) {
    Ray ray;
    ray.time = time;
    
    vec2 iPlaneSize=2.*tan(0.5*c.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(uv - 0.5)*iPlaneSize;
    
    mat4 mtx;
#ifdef MOTION_BLUR
    mtx = mtxLerp2(c.mtx_prev, c.mtx, ray.time);
#else
    mtx = c.mtx;
#endif
    
    if( c.lensSize > EPSILON ) {
        vec2 uv = uniformPointWithinCircle( c.lensSize, rnd(), rnd() );
        vec3 newPos = mtx[3].xyz + mtx[0].xyz*uv.x*c.lensSize + mtx[1].xyz*uv.y*c.lensSize;
        vec3 focusPoint = mtx[3].xyz - c.focusDist*mtx[2].xyz;
        vec3 newBack = normalize(newPos - focusPoint);
        vec3 newRight = normalize( cross( mtx[1].xyz, newBack ) );
        vec3 newUp = cross( newBack, newRight );
        mat3 newRotate;
        newRotate[0] = newRight;
        newRotate[1] = newUp;
        newRotate[2] = newBack;

        ray.origin = newPos;
        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    } else {
        ray.origin = mtx[3].xyz;
        ray.dir = toVec3(mtx*normalize(vec4(ixy.x, ixy.y, -1.0, 1.0)));
    }

	return ray;
}

// Function 1432
float trace_ray(in ray r, inout seed_t seed) {   
    float reflectance = 1.0;
    bool stop = false;
    r.ior = ENV_IOR;

    for (int i = 0; i < 10; i++) {
        reflectance *= hit(r, r, stop, seed);
        if (stop) break;
    }

    if (stop) {
        return reflectance;
    } else {
        return 0.0;
    }
}

// Function 1433
MarchRes marchRay(vec3 pos, vec3 dir, float speed)
{
 	MarchRes res;
    res.minDist = 100000.0;
    res.glowAmt = 1.0;
    Object o;
    
    res.totalDist = 0.001;

    for(int x=0; x<200; x++)
    {
 		res.curRay = pos + (dir*res.totalDist);
        
        o = map(res.curRay);
        res.glowAmt = min(res.glowAmt, 0.5*o.dist/(0.02+abs(0.02*sin(iTime))*res.totalDist));
        if(abs(o.dist) < 0.00001)
        {
            res.minDist = o.dist;
            res.obj = o;
            break;
        }
        else if(res.totalDist >= VIEW_DIST) break;
            
        if(o.dist < res.minDist)
            res.minDist = o.dist;
        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (
    }
    
    if(res.totalDist < VIEW_DIST)
    {
        o.normal = calcNormal(res.curRay, o.normEps);
        res.obj = o;
    }
    	
    res.glowAmt = max(res.glowAmt, 0.0);
    res.glowAmt = smoothstep(0.0, 1.0, res.glowAmt);// res.glowAmt*res.glowAmt*(3.0-2.0*res.glowAmt);
    return res;
}

// Function 1434
vec2 castRay( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = minRay;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0-ro.y)/rd.y;
    if( tp1>0.0001 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    //else return res;
    
    // raymarch primitives   
    vec2 tb = iBox( ro-vec3(0.0,0.4,0.0), rd, vec3(2.5,0.41,2.5) );
    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)
    {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = max(tmin,minRefrac);
#if AA>1
        for( int i=0; i<70 * AA && t<tmax; i++ )
#else
        for( int i=0; i<70 && t<tmax; i++ )         
#endif
        {
            vec2 h = map( ro+rd*t );
            
            t = minRefrac > 0. ? abs(t) : t;
            if( abs(h.x)<(0.0001*t) )
            {
                res = vec2(t,h.y);
                break;
            }
            t +=  minRefrac > 0. ? -(h.x) : h.x;
        }
    }
    
    return res;
}

// Function 1435
vec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {
	float t = 0.0;
	const int maxIter = 100;
	const float maxDis = 300.0;
	float d = 0.0;
	vec3 p = vec3(-1.0, -1.0, -1.0);
	vec3 col = vec3(0);
	const int jumps = 3;
	float ref = 1.0;
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;
	for (int j = 0; j < jumps; j++) {
		for (int i = 0; i < maxIter; i++) {
			p = ro + rd * t;

			vec2 res = map(p, rd);
			d = res.x;
			float fogAmount = 0.01;
			float lightDis = -1.0;
			vec3 light = evaluateLight(p, lightDis);
			d = min(min(d, 1.0), max(lightDis, 0.05));
			vec3 lightIntegrated = light - light * exp(-fogAmount * d);
			scatteredLight += transmittance * lightIntegrated;
			transmittance *= exp(-fogAmount * d);

			t += d;
			float m = res.y;
			bool end = i == maxIter - 1 ||t > maxDis;
			if (d < 0.01 || end) {
				vec3 c = vec3(1);
				vec3 normal = getNormal(p, rd);
				if (m == MAT_WALL) {
					c = vec3(1,0,0);
				} else if (m == MAT_SPIN) {
					c = vec3(0.5);
				} else if (m == MAT_GROUND) {
					vec3 q = floor(p);
					c = vec3(0.3,0.3,1);
				}

				c *= occlusion(p, normal, rd);
				addLightning(c, normal, eye, p);
				if (end) {
					transmittance = 0.0;
				}
				col = mix(col, transmittance * c + scatteredLight, ref);
				if (m == MAT_SPIN) {
					ref *= 0.8;
				} else {
					ref = 0.0;
				}
				rd = reflect(rd, getNormal(p, rd));
				ro = p + rd*0.05;
				t = 0.0;
				break;
			}
			if (t > maxDis) {
				break;
			}
		}

		if (ref < 0.1) {
			break;
		}
	}
	finalPos = p;
	return col;
}

// Function 1436
vec2 unpack_normal(float x) {
    float si = fract(x + 0.5)*2.0 - 1.0;
    float cx = 20.0 / (si*si + 4.0) - 4.0;
    float cy = sqrt(1.0 - cx*cx);
    return vec2(cx,cy) * sign(0.5-fract(vec2(0.25,0.0) + x*0.5));
}

// Function 1437
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
	vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 1438
vec3 normal(vec3 pos, float time)
{
	vec3 eps = vec3(0.001,0.,0.);
	float dx = map(pos+eps.xyy,time).x;
	float dy = map(pos+eps.yxy,time).x;
	float dz = map(pos+eps.yyx,time).x;
	float mdx = map(pos-eps.xyy,time).x;
	float mdy = map(pos-eps.yxy,time).x;
	float mdz = map(pos-eps.yyx,time).x;
	return normalize(vec3(dx-mdx,dy-mdy,dz-mdz));
}

// Function 1439
float3 rayPointAtParameter(in Ray r,float t)
{
	return r.o + t*r.d;
}

// Function 1440
Ray CameraGetRay(Camera cam, vec2 point)
{
    float halfAngle = radians(cam.fov) / 2.;
	float hSize = tan(halfAngle);
	float d = 1.0;
	float left = -hSize;
	float right = hSize;
	float top = hSize;
	float bottom = -hSize;
	
	float aspectRatio = iResolution.x / iResolution.y;
	
	float x = bottom+(top-bottom)*point.y ;
	float y = (left+(right-left)*point.x)* aspectRatio;
	vec3 dir = (d*cam.w) + x*cam.v + y*cam.u;

	Ray ray = Ray(cam.origin, normalize(dir));
    
    return ray;
}

// Function 1441
float cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){
	//horner's method
	vec2 a_2=a2+t*a3;
	vec2 a_1=a1+t*a_2;
	vec2 b_2=a_2+t*a3;

	vec2 uv_to_p=a0+t*a_1;
	vec2 tang=a_1+t*b_2;

	float l_tang=dot(tang,tang);
	return t-factor*dot(tang,uv_to_p)/l_tang;
}

// Function 1442
vec3 get_normal(int v) {
   int xyz = normals[v];
   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); 
   return vec3(-1) + vec3(XYZ) / 512.0;    
}

// Function 1443
float rayTriangle(vec3 P, vec3 w, inout vec3 n, vec3 v1, vec3 v2, vec3 v3){
    //Edge vectors
    vec3 e1 = v2-v1;
    vec3 e2 = v3-v1;
    
    n = normalize(cross(e1, e2));
    
    vec3 q = cross(w, e2);
    float a = dot(e1, q);
    
    vec3 s = (P - v1) / a;
    vec3 r = cross(s, e1);
    
    float b0 = dot(s, q);
    float b1 = dot(r, w);
    float b2 = 1.0 - b0 - b1;
    if ((b0 >= 0.0) && (b1 >= 0.0) && (b2 >= 0.0)) return dot(e2, r);
    return longTime;
    
}

// Function 1444
vec2 ray_sphere_intersect(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

// Function 1445
vec3 get_normal(in vec3 p)
{
	vec3 eps = vec3(0.001, 0, 0); 
	float nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x; 
	float ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x; 
	float nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x; 
	return normalize(vec3(nx,ny,nz)); 
}

// Function 1446
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1447
float rayfff(float t) {
    t = t - RO;
    poly2 f = pa_map(ro, rd, t);
    return f.a[2];
}

// Function 1448
vec3 rayPlaneIntersect(Ray ray)
{
   return ray.origin + ray.direction * (dot(rect.front, rect.center - ray.origin)
                                      / dot(rect.front, ray.direction));
}

// Function 1449
vec3 calcNormal( in vec3 pos, in float t )
{
    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);
	return normalize( vec3(
           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),
           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),
           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );

}

// Function 1450
vec3 getNormal(in vec3 p) {
	
    const vec2 e = vec2(.001, 0);
    
    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
    //map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
    
    // This mess is an attempt to speed up compiler time by contriving a break... It's 
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.;
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = 0; i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break; // Fake conditional break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 1451
void normal(in vec3 x, out vec3 n)
{
    const float dx = 1.e-2;
    vec2 s, na;
    
    scene(x,s);
    scene(x+dx*c.xyy, na);
    n.x = na.x;
    scene(x+dx*c.yxy, na);
    n.y = na.x;
    scene(x+dx*c.yyx, na);
    n.z = na.x;
    n = normalize(n-s.x);
}

// Function 1452
vec3 calcNormal( vec3 p, int octaves) {
	const vec3 eps = vec3(0.0005, 0.0, 0.0);
	return normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,
			       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,
			       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );
}

// Function 1453
vec3 normal (vec3 p, float epsilon)
{
    vec2 e = vec2 (epsilon, .0);
    return normalize (vec3 (map (p + e.xyy).x,
                            map (p + e.yxy).x,
                            map (p + e.yyx).x) - map (p).x);
}

// Function 1454
vec3 calcNormal(vec3 pos){
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).d;
    }
    return normalize(n);
}

// Function 1455
vec3 calcNormalDamage( in vec3 pos, in float eps ) {
    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   		
	        return vec3( 0., 1., 0. );
    } else {    
        vec2 e = vec2(1.0,-1.0)*(0.5773*eps);
        vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + 
                             e.yyx*mapDamageHigh( pos + e.yyx ) + 
                             e.yxy*mapDamageHigh( pos + e.yxy ) + 
                             e.xxx*mapDamageHigh( pos + e.xxx ) );
        n = bumpMapNormal( pos, n );
        return n;  
    }
}

// Function 1456
bool isReflection(float m)
{
#if MODE>1
        bool reflection = m < 15.;
#elif MODE>0
        bool reflection = m < 2.;
#else
        bool reflection = m > -6999.;
#endif
    
   	return reflection;
}

// Function 1457
vec3 approxNormal(vec3 pos)
{
    float epsilon = 0.001;
	vec2 t = vec2(0.0, epsilon);
    vec3 n = vec3(map(pos + t.yxx) - map(pos - t.yxx),
           	  map(pos + t.xyx) - map(pos - t.xyx),
              map(pos + t.xxy) - map(pos - t.xxy));
    return normalize(n);
}

// Function 1458
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 1459
vec3 normal(vec2 uv)
{
    const float eps = 0.001; // or some other value
    const vec2 h = vec2(eps,0);
    return normalize( vec3( height(uv-h.xy) - height(uv+h.xy),
                            2.0*h.x,
                            height(uv-h.yx) - height(uv+h.yx) ) );
}

// Function 1460
vec3 calcNormal(vec3 p)
{
    vec2 e = vec2(0.0001, 0.0);
    return normalize(vec3(
        map(p + e.xyy).x - map(p - e.xyy).x,
        map(p + e.yxy).x - map(p - e.yxy).x,
        map(p + e.yyx).x - map(p - e.yyx).x)
    );
}

// Function 1461
vec3 getNormal(vec3 p) {
	vec3 eps = vec3(0.001, 0.0, 0.0);
    return normalize(vec3(
        sphere(p + eps.xyy) - sphere(p - eps.xyy),
        sphere(p + eps.yxy) - sphere(p - eps.yxy),
        sphere(p + eps.yyx) - sphere(p - eps.yyx)
    ));
}

// Function 1462
vec3 distanceRaySegment( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb )
{
	vec3 ba = pb - pa;
	vec3 oa = ro - pa;
	
	float oad  = dot( oa, rd );
	float dba  = dot( rd, ba );
	float baba = dot( ba, ba );
	float oaba = dot( oa, ba );
	
	vec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);
	
	th.x = max(   th.x, 0.0 );
	th.y = clamp( th.y, 0.0, 1.0 );
	
	vec3 p = pa + ba*th.y;
	vec3 q = ro + rd*th.x;
	
	return vec3( length( p-q ), th );
}

// Function 1463
vec3 map_light_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return rd;
}

// Function 1464
vec3 getNormal(in vec3 pos )
{
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).d - map(pos-eps.xyy).d,
	    map(pos+eps.yxy).d - map(pos-eps.yxy).d,
	    map(pos+eps.yyx).d - map(pos-eps.yyx).d );
	return normalize(nor);
}

// Function 1465
bool refract2(vec3 v, vec3 n, float ni_over_nt, inout vec3 refracted) {
    vec3 uv = normalize(v);
    float dt = dot(uv, n);
    float disc = 1.0 - ni_over_nt * ni_over_nt * (1.0-dt*dt);
    if (disc > 0.0) {
        refracted = ni_over_nt * (uv - n*dt) - n*sqrt(disc);
        return true;
    } else {
        return false;
    }
}

// Function 1466
vec4 calculateNormal(vec4 pos, float epsilon)
{
	vec4 epsilonVec = vec4(epsilon, 0.0, 0.0, 0.0);
    vec4 xyyy = vec4(epsilon, 0.0, 0.0, 0.0);
    vec4 yxyy = vec4(0.0, epsilon, 0.0, 0.0);
    vec4 yyxy = vec4(0.0, 0.0, epsilon, 0.0);
    vec4 yyyx = vec4(0.0, 0.0, 0.0, epsilon);
    
	vec4 normal = vec4(
	    map(pos+xyyy).x - map(pos-xyyy).x,
	    map(pos+yxyy).x - map(pos-yxyy).x,
	    map(pos+yyxy).x - map(pos-yyxy).x,
    	map(pos+yyyx).x - map(pos-yyyx).x);
	return normalize(normal);
}

// Function 1467
vec3 makeRay(vec2 origin)
{
    vec2 res;
    res.x = origin.x - iResolution.x * 0.5;
    res.y = origin.y - iResolution.y * 0.5;
    return normalize(vec3(res / iResolution.yy, 3));
}

// Function 1468
float grayscale(vec3 color)
{
    return dot(color, vec3(0.299, 0.587, 0.114));
}

// Function 1469
vec3 GetNormal(vec3 pos)
{
    vec3 dx = vec3(EPS, HightFunction(pos+vec3(EPS, 0.0, 0.0))-HightFunction(pos), 0.0);
    vec3 dz = vec3(0, HightFunction(pos+vec3(0.0, 0.0, EPS))-HightFunction(pos), EPS);
    return normalize(cross(dz, dx));
}

// Function 1470
vec3 getCylinderNormal(vec3 pos, vec3 properties)
{
	// Perform modulation to keep in line with our cylinder distance function.
	pos.xz = mod(pos.xz,TREE_REP.xz);
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	// Since we can assume that the cylinder is vertical,
	// the only coordinates that matter are x and z.
	// This speeds up normal generation quite a bit.
	vec2 normal = normalize(pos.xz-properties.xy);
	return vec3(normal.x, 0.0, normal.y);
}

// Function 1471
vec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l-p),
        r = normalize(cross(vec3(0,1,0), f)),
        u = cross(f,r),
        c = p+f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i-p);
    return d;
}

// Function 1472
vec3 normalMap(in vec3 p){
  
    vec2 e = vec2(-1., 1.)*.001;  
    
	float d1 = detail(p + e.yxx), d2 = detail(p + e.xxy);
	float d3 = detail(p + e.xyx), d4 = detail(p + e.yyy); 
    
    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );
	return n1;   
}

// Function 1473
vec3 getPlaneNormal(vec3 hitPoint,Plane p){
	return normalize(hitPoint+p.normal);
}

// Function 1474
vec3 raymarching(vec3 ro, vec3 rd)
{
    vec3 bg = vec3(0.0);
    
    vec2 res = render(ro, rd);
    vec3 col;
    if (res.y > -0.5) {
        vec3 pos = ro + rd * res.x;
        vec3 nor = normal(pos);
        vec3 view = -rd;
        float dif = dot(nor, view);
        dif = dif * 0.5 + 0.5;
        
        float h = clamp(height(pos) + 0.2, 0.0, 1.0) * HEIGHT;
        vec3 light = vec3(0.3 + hash11(res.y * 0.2), 0.3 + hash11(res.y * 0.4), 0.3 + hash11(res.y * 0.6));
        col = vec3(0.8, 0.85, 1.0);
        light = palette(pos.y * 0.2, vec3(0.5, 0.5, 0.5),vec3(0.5, 0.5, 0.5),vec3(1.0, 1.0, 0.5), light);
        col = mix(light, col, smoothstep(h * 0.8, h, pos.y)) * dif;
    	col = mix(bg, col, smoothstep(0.0, 0.3, pos.y));
    }
    
    // distance fog
    col = mix(col, bg, smoothstep(DMIN, DMAX, res.x));
    
    //return vec3(res.y + 1.0);
    return col;
}

// Function 1475
vec3 raymarch_visualize(vec2 ro, vec2 rd, vec2 uv)
{
	//ro - ray origin
	//rd - ray direction

	vec3 ret_col = vec3(0.0);

	const float epsilon = 0.001;
	float t = 0.0;
	for(int i = 0; i < 10; ++i)
	{
		vec2 coords = ro + rd * t;
		float dist = field(coords);
		ret_col += visualize_region(uv, dist, coords);
		t += dist;
		if(abs(dist) < epsilon)
			break;
	}

	//return t;
	return ret_col;
}

// Function 1476
vec3 rayToTexture( vec3 p ) {
    return (p*SCALE + vec3(0.5,0.5,0.5));
}

// Function 1477
vec3 calcNormal( in vec3 pos, float time )
{

    #if 0
    vec2 e = vec2(1.0,-1.0)*0.005773;
    return normalize( e.xyy*map( pos + e.xyy, time ) + 
                     e.yyx*map( pos + e.yyx, time ) + 
                     e.yxy*map( pos + e.yxy, time ) + 
                     e.xxx*map( pos + e.xxx, time ) );
    #else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.001*e,time);
    }
    return normalize(n);
    #endif    
}

// Function 1478
vec3 normal(in vec3 p)
{
  //tetrahedron normal
  const float n_er=0.01;
  float v1=obj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;
  float v2=obj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;
  float v3=obj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;
  float v4=obj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;
  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
}

// Function 1479
float gray( vec3 c ) {
  return 0.299 * c.x + 0.587 * c.y + 0.114 * c.z;
}

// Function 1480
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 160; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.002 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1481
vec3 traceRayGlow(Ray r)
{
    
    HitRecord hit;
    
    if (hitSphere(r, glowSphere, hit))
    {
        return vec3(1,1,1);
        
    }
    
    return vec3(0.0,0.0,0.0);
}

// Function 1482
bvec4 RayVs4Boxes(in vec3 p, in vec3 dir, in vec4 pos_x, in vec4 pos_y, in vec4 pos_z,
				  in vec4 edge_x, in vec4 edge_y, in vec4 edge_z,
				  out vec4 t
	)
{
	vec3 inv_dir = vec3(1.)/dir;
	
	vec4 minim_x=pos_x-edge_x*.5;
	vec4 minim_y=pos_y-edge_y*.5;
	vec4 minim_z=pos_z-edge_z*.5;
	
	vec4 maxim_x=pos_x+edge_x*.5;
	vec4 maxim_y=pos_y+edge_y*.5;
	vec4 maxim_z=pos_z+edge_z*.5;

	vec4 omin_x = ( minim_x - p.x ) * inv_dir.x;
	vec4 omin_y = ( minim_y - p.y ) * inv_dir.y;
	vec4 omin_z = ( minim_z - p.z ) * inv_dir.z;
	
	vec4 omax_x = ( maxim_x - p.x ) * inv_dir.x;
	vec4 omax_y = ( maxim_y - p.y ) * inv_dir.y;
	vec4 omax_z = ( maxim_z - p.z ) * inv_dir.z;

	vec4 maxi_x = max ( omax_x, omin_x );
	vec4 maxi_y = max ( omax_y, omin_y );
	vec4 maxi_z = max ( omax_z, omin_z );
	
	vec4 mini_x = min ( omax_x, omin_x );
	vec4 mini_y = min ( omax_y, omin_y );
	vec4 mini_z = min ( omax_z, omin_z );

	vec4 start = max ( max ( mini_x, vec4(0.) ), max ( mini_y, mini_z ) );
	vec4 end = min ( maxi_x, min ( maxi_y, maxi_z ) );
	
	t = start;
	
	return greaterThan(end-start,vec4(.00001));
}

// Function 1483
vec2 marchRay(vec3 ro, vec3 rd) 
{
    float mint = 0.01;
    float t = 0.0;
    while(t < MAX_VIEW_DISTANCE+10.0)
    {	
        vec3 p = ro + rd*t;
        if(p.y < 0.0 && p.y > 2.0) break;
        vec2 h = sdScene(p);
        if( h.x < 0.01)
        {
            return vec2(t, h.y);
        }
        t+=h.x;
    }
    return vec2(MAX_VIEW_DISTANCE, -1.0); // No hit
}

// Function 1484
vec3 normal(vec3 pos){
	const vec2 e = vec2(0.001,0.);
    return normalize(
    	vec3(
        	map(pos + e.xyy),
            map(pos + e.yxy),
            map(pos + e.yyx)
        )-map(pos)
    );
}

// Function 1485
MarchResult MarchRay(vec3 orig,vec3 dir)
{
    float steps = 0.0;
    float dist = 0.0;
    float id = 0.0;
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        vec2 object = Scene(orig + dir * dist);
        //Add the sky dome and have it follow the camera.
        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));
        
        dist += abs(object.x) * STEP_MULT;
        
        id = object.y;
        
        steps++;
        
        if(abs(object.x) < MIN_DIST * dist)
        {
            break;
        }
    }
    
    MarchResult result;
    
    result.position = orig + dir * dist;
    result.normal = Normal(result.position);
    result.dist = dist;
    result.steps = steps;
    result.id = id;
    
    return result;
}

// Function 1486
v33 calcRayForPixel(vec2 pix,vec2 res
){vec2 p=(-res.xy+2.0*pix)/res.y
 ;vec3 ro,ta
 ;calcCamera(ro,ta)
 ;vec3 w=normalize(ta-ro)
 ;vec3 u=normalize(cross(w,vec3(0,1,0)))
 ;vec3 rd=normalize(p.x*u+p.y*normalize(cross(u,w))+1.5*w)
 ;return v33(ro,rd);}

// Function 1487
vec3 calcNormal( in vec3 pos, in vec2 tmat)
{
	return normalize(pos-mix(ballPos,vec3(0.0),tmat.y));
}

// Function 1488
raymarchResult raymarch(vec3 at, vec3 normal) {
    for(int iteration = 0; iteration < 128; iteration++) {
        shapeResult sam = scene(at);
        if(sam.distance < 0.1)
            return raymarchResult(at, sam.materialId);
        at += normal * sam.distance * 0.5;
    }
    return raymarchResult(vec3(0.0), MATERIAL_SKY);
}

// Function 1489
vec3 sphereNormals(in vec2 uv) {
  uv = fract(uv) * 2.0 - 1.0;
  vec3 ret;
  ret.xy = sqrt(uv * uv) * sign(uv);
  ret.z = sqrt(abs(1.0 - dot(ret.xy, ret.xy)));
  ret = ret * 0.5 + 0.5;
  return mix(vec3(0.0), ret, smoothstep(1.0, 0.98, dot(uv, uv)));
}

// Function 1490
vec3 traceReflection(vec3 rayPos, vec3 rayDir)
{
	vec3 col = vec3(0.0);
	float t = 1e20;
			
	// Intersect trunk
	vec4 resTrunk = trunk(rayPos, rayDir);
	if (resTrunk.w > 0.0 && resTrunk.w < t)
	{
		t = resTrunk.w;
		col = resTrunk.xyz;
	}
	
	// Intersect leaves
	vec4 resLeaves = leaves(rayPos, rayDir);
	if (resLeaves.w > 0.0 && resLeaves.w < t)
	{
		vec3 pos = rayPos + rayDir * resLeaves.w;
		vec2 uv = (pos.xz - leavesPos.xz) * 0.3;
		float tex = texture(iChannel0, uv).r * 0.6 + 0.5;
		
		t = resLeaves.w;
		col = leavesCol * lightLeaves(pos, resLeaves.xyz) * tex;
	}
		
	if (t > 1e7) return sky(rayDir);
	
	return col;
}

// Function 1491
vec3 rayCast(vec3 ro, vec3 rd, out float t, out bool edge, out float minDist)
{ 
    // Threshold for how close we have to come to the cross before we add the aura.
    // There are more correct ways to do distance but this is accurate enough empirically.
    float thr = .0;
    t = 1.;
    for (int i = 0; i < 100; i++) 
    {
        vec3 p = ro + t * rd;
        float dist = sdG(p, edge);
        if (dist < EP) {
            return p;
        }
        if (t > 150.) {
         	t = -1.;
            return p;
        }
        t += dist;
        minDist = min(dist, minDist);
    }
}

// Function 1492
Ray computeCameraRay(vec2 uv)
{
    float aspectRatio = iResolution.x / iResolution.y;
    Ray r;
    r.origin = origin;
    r.direction = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +
          uv.x * horizontal * aspectRatio +
          uv.y * vertical;
    r.mint = 0.0;
    r.maxt = 1e20;
    return r;
}

// Function 1493
vec3 normal( vec3 x )
{
    vec2 e = vec2( .01, 0 );
    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,
                            map(x+e.yxy).x - map(x-e.yxy).x,
                            map(x+e.yyx).x - map(x-e.yyx).x ) );
}

// Function 1494
vec2 rayProcess(vec3 camPos, vec3 rayDir, float start, float end) {
	float depth = start;
	for(int i = 0; i < 200; ++i) {
        vec3 p = camPos + depth * rayDir;
		vec2 dist = map(p);
		if(abs(dist.x) < 1e-3) return vec2(depth, dist.y);
		depth += dist.x;
		if(dist.x >= end) break;
	}
	return vec2(end, 0.);
}

// Function 1495
float SheetRay (vec3 ro, vec3 rd)
{
  vec3 r, q;
  vec2 g;
  float d, dMin, sz, szMax, szMin, grLen;
  bvec2 ilt;
  bool bkTrak;
  grLen = 0.92 * spLen;
  dMin = dstFar / grLen;
  rd /= grLen;
  szMax = float (nBallEy - 1);
  szMin = 1./32.;
  g = vec2 (0.);
  bkTrak = false;
  sz = szMax;
  nsCount = 0.;
  for (int ns = 0; ns < nsMax; ns ++) {
    if (sz == szMin) {
      r = GetR (g) - ro;
      q = cross (r, rd);
      if (dot (q, q) < sz * sz) {
        d = dot (rd, r);
        if (d < dMin) {
          dMin = d;
          qgHit = g;
        }
      }
      bkTrak = true;
    }
    q = cross (GetR (g + 0.5 * sz) - ro, rd);
    bkTrak = bkTrak || (dot (q, q) > sz * sz);
    if (bkTrak) {
      bkTrak = false;
      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));
      g.x += ilt.x ? sz : - sz;
      if (! ilt.x) {
        g.y += ilt.y ? sz : - sz;
        if (! ilt.y) {
          sz *= 2.;
          if (sz == szMax) break;
          bkTrak = true;
        }
      }
    } else if (sz > szMin) sz *= 0.5;
    ++ nsCount;
  }
  return dMin * grLen;
}

// Function 1496
CastRes rayCast(Cam cam)
{
	CastRes res;
	res.color = vec3(0.1);
	


	
	float dist = 0.0;

	for(int i = 0; i < MAX_ITERATIONS; ++i)
	{
		res.pos = cam.pos + cam.ray * dist;
		res = DistFunc(res);
		
		if(res.dist <= EPS)
		{
			break;
		}
		
		dist += res.dist;
				
		if(dist >= MAX_DIST)
		{
			break;
		}
	}
	
	res.dist = dist;
	
	res.color = GetColor(cam, res);

	return res;
}

// Function 1497
vec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax ) {
    //start at starting loc
    float t = tminmax.x;
    //small delta
    float dt = (tminmax.y - tminmax.x) / float(vol_steps);
    //output color
    vec3 col= vec3(0.);
    vec3 pos = ro;
    //current sample
    float c = 0.;
    for( int i=0; i<vol_steps; i++ ) {
        //this steps through empty space faster
        t += (.7 + t*t * 0.007) * dt*exp(-c*c);
        pos = ro+t*rd;
        //get plasma density
        c = map(pos*size);
		//adjusted sumation
        col += c*c*normalize(abs(pos.zyx));
    }
    return col * 0.008;
}

// Function 1498
vec3 calcNormal(vec3 p) {
 
    vec2 eps = vec2(.001,0.);
    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,
                    dstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,
                    dstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);
    return normalize(n);
    
}

// Function 1499
float pReflect(inout vec3 p, vec3 planeNormal, float offset) {
	float t = dot(p, planeNormal)+offset;
	if (t < 0.) {
		p = p - (2.*t)*planeNormal;
	}
	return sign(t);
}

// Function 1500
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (p);
    dHit += d;
    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;
  }
  if (p.y < 0.) dHit = dstFar;
  return dHit;
}

// Function 1501
vec3 interpolateNormals(vec3 v0, vec3 v1, float x) {
	x = smoothstep(0., 1., x);
	return normalize(vec3(mix(v0.x, v1.x, x),
		mix(v0.y, v1.y, x),
		mix(v0.z, v1.z, x)));
}

// Function 1502
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {
    specularBounce = false;
    
    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1.0; 
            n2 = 1.5;
            n = -n;
        } else {
            n1 = 1.5;
            n2 = 1.0; 
        }
                
        float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
        
        vec3 ref;
        
        if( hash1(seed) < fresnel ) {
            ref = reflect( rd, n );
        } else {
            ref = refract( rd, n, n2/n1 );
        }
        
        return ref; // normalize( ref + 0.1 * r );
	}
}

// Function 1503
vec2 castRay( in vec3 ro, in vec3 rd ) {
    float tmin = 0.001;
    float tmax = MAX_T;
    
    // bounding volume
    const float top = 0.95;
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
    
    float t = tmin;
    float mat = -1.;
    
    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );
    rd1 = rotateY( rd1, CLOCK_ROT_Y );
    
	float secs = mod( floor(TIME),        60.0 );
	float mins = mod( floor(TIME/60.0),   60.0 );
	float hors = mod( floor(TIME/3600.0), 24.0 ) + mins/60.;
    
    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );
    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );
    
    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );
    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );
    
    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );
    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );
    
    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));
    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));
    
    for( int i=0; i<64; i++ ) {
	    float precis = 0.00001;
	    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, 
                       watchIntersect, pencilIntersect );
        if( abs(res.x)<precis || t>tmax ) break; //return vec2(t, mat);
        t += res.x;
        mat = res.y;
    }

    if( t>tmax ) t=-1.0;
    return vec2(t, mat);
}

// Function 1504
void raycast(vec3 origin, vec3 direction, out vec3 iNormal, out vec3 iCoordinate, out float iDepth, out bool iHit, out float iCDepth) {
    vec3 d = normalize(direction);
    // The reason is that the direction is a unit vector; it may not be the same
    // as the direction specified.
    float depth = 0.0;
    // Now we need to initialize the results.
    iNormal = vec3(0.0,0.0,-1.0);
    iDepth=0.0;
    iHit=false;
    iCoordinate = origin;
    iCDepth=0.0;
    for (int i=0;i<maxIterations;++i) {
        vec3 coord = origin+d*depth;	// Calculate the absolute coordinates
        float s = scene(coord);
        vec3 n = CalcNormal(coord);
        iCDepth=float(i)/float(maxIterations);
        if (s <= eps) {
            iCoordinate=coord;
            iHit=true;
            iDepth=depth;
            iNormal=n;
            return;
        }
        depth += s;
    }
    iCDepth=1.0;
}

// Function 1505
float rayMarch(in vec3 ro, in vec3 rd) {
	float dO = 0.0;
    
    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {
		vec3 p = ro + rd * dO;
        float dS = getDist(p);
        dO += dS;
        if (dO > RAYMARCH_MAX_DIST) break;
        if (dS < RAYMARCH_SURFACE_DIST) {
            break;
        }
    }
    
    return dO;
}

// Function 1506
vec3 calcNormal(in vec3 p)
{
    vec2 eps = vec2(epsilon, 0.0);
    return normalize(vec3(map(p + eps.xyy) - map(p - eps.xyy),
                          map(p + eps.yxy) - map(p - eps.yxy),
                          map(p + eps.yyx) - map(p - eps.yyx)));
}

// Function 1507
Ray rayReflect(in Hit h, in vec3 rl) {
  return ray(h.pos + h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.rr, h.ray.sgn);
}

// Function 1508
vec3 calcNormal_3997203925(vec3 pos, float eps) {
  const vec3 v1 = vec3( 1.0,-1.0,-1.0);
  const vec3 v2 = vec3(-1.0,-1.0, 1.0);
  const vec3 v3 = vec3(-1.0, 1.0,-1.0);
  const vec3 v4 = vec3( 1.0, 1.0, 1.0);

  return normalize( v1 * doModel( pos + v1*eps ).x +
                    v2 * doModel( pos + v2*eps ).x +
                    v3 * doModel( pos + v3*eps ).x +
                    v4 * doModel( pos + v4*eps ).x );
}

// Function 1509
vec3 getNormal(in vec3 p)
{
    float eps = 0.001;
    vec3 n = vec3(f(p.x - eps, p.z) - f(p.x + eps, p.z),
                  2.0*eps,
                  f(p.x, p.z - eps) - f(p.x, p.z + eps) );
    return normalize(n);
}

// Function 1510
float pReflect(inout vec3 p, vec3 planeNormal, float offset) {
    float t = dot(p, planeNormal)+offset;
    if (t < 0.) {
        p = p - (2.*t)*planeNormal;
    }
    return sign(t);
}

// Function 1511
vec3 normal( in vec3 x )
{
    vec2 e = vec2( .01, 0.0 );
    return normalize( vec3( map2(x+e.xyy) - map2(x-e.xyy),
                            map2(x+e.yxy) - map2(x-e.yxy),
                            map2(x+e.yyx) - map2(x-e.yyx) ) );
}

// Function 1512
vec3 calcNormal(vec3 p, float t) {
  vec2 e = vec2(t*precis, 0.0);
  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),
                        de(p + e.yxy) - de(p - e.yxy),
                        de(p + e.yyx) - de(p - e.yyx)));
}

// Function 1513
TriangleHit rayIcoInnerHit(vec3 origin, vec3 dir) {
    for (int i = 0; i < ICO_FACES; i++) {
    	TriangleHit hit = rayTriHit(origin, dir, icoIndices[i]);
        if (hit.t <= 10.0) return hit;
    }
    return noHit;
}

// Function 1514
vec4 raymarch( in vec3 ro, in vec3 rd )
{
    vec4 sum = vec4(0, 0, 0, 0);
    
    // setup sampling - compute intersection of ray with 2 sets of planes
    float2 t, dt, wt;
	SetupSampling( t, dt, wt, ro, rd );
    
    // fade samples at far extent
    float f = .6; // magic number - TODO justify this
    float endFade = f*float(SAMPLE_COUNT)*PERIOD;
    float startFade = .8*endFade;
    
    for(int i=0; i<SAMPLE_COUNT; i++)
    {
        if( sum.a > 0.99 ) continue;

        // data for next sample
        vec4 data = t.x < t.y ? vec4( t.x, wt.x, dt.x, 0. ) : vec4( t.y, wt.y, 0., dt.y );
        // somewhat similar to: https://www.shadertoy.com/view/4dX3zl
        //vec4 data = mix( vec4( t.x, wt.x, dt.x, 0. ), vec4( t.y, wt.y, 0., dt.y ), float(t.x > t.y) );
        vec3 pos = ro + data.x * rd;
        float w = data.y;
        t += data.zw;
        
        // fade samples at far extent
        w *= smoothstep( endFade, startFade, data.x );
        
        vec4 col = map( pos );
        
        // iqs goodness
        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );
        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;
        col.xyz *= lin;
        
        col.xyz *= col.xyz;
        
        col.a *= 0.75;
        col.rgb *= col.a;

        // integrate. doesn't account for dt yet, wip.
        sum += col * (1.0 - sum.a) * w;
    }

    sum.xyz /= (0.001+sum.w);

    return clamp( sum, 0.0, 1.0 );
}

// Function 1515
SceneData raymarch(in vec3 ro, in vec3 rd)
{
    float t = 0.0;
    SceneData sceneOutput = SceneData(MAX_DIST, kInvMat);
    for (int i = 0; i < 90; ++i)
    {
        SceneData scene = map(ro + rd * t);
        if (scene.dist < MIN_DIST)
        {
            sceneOutput = SceneData(t, scene.material);
            break;
        }
        t += scene.dist;
        if (t > MAX_DIST)
        {
            break;
        }
    }
    return sceneOutput;
}

// Function 1516
vec3 normal(vec3 p)
{
    mat3 k = mat3(p,p,p) - mat3(0.001);
    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));
}

// Function 1517
float cast_ray( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out float matInfo )
{
    float t = mindist;
    for( int i=0; i<256; i++ )
    {
        vec3 p = ro + t*rd;
        float h = map( p, matInfo );
        if( abs(h)<(0.005*t) || t>maxdist ) break;
        t += h*0.1;
    }
    
    if( t>maxdist ) t=-1.0;
    
	return t;
}

// Function 1518
vec4 castRay( in vec3 ro, in vec3 rd, float time )
{
    vec4 res = vec4(-1.0,-1.0,0.0,1.0);

    float tmin = 0.5;
    float tmax = 20.0;
    
	#if 1
    // raytrace bounding plane
    float tp = (3.5-ro.y)/rd.y;
    if( tp>0.0 ) tmax = min( tmax, tp );
	#endif    
    
    // raymarch scene
    float t = tmin;
    for( int i=0; i<256 && t<tmax; i++ )
    {
        vec4 h = map( ro+rd*t, time );
        if( abs(h.x)<(0.0005*t) )
        { 
            res = vec4(t,h.yzw); 
            break;
        }
        t += h.x;
    }
    
    return res;
}

// Function 1519
float shadowRay(vec3 startP, vec3 lightDir){ // iq soft shadows 
    
    float t = 0.0;
    float shadowHardness = 10.;
    float minD = 1.; // close-by distance 
    
    for (int r = 0; r < 8; ++r){
        
        vec3 p = startP + vec3(t*lightDir.x,t*lightDir.y,t*lightDir.z) + normalize(startP)/shadowHardness; // safe offset
        
        vec3 pp = normalize(p) * sphereBaseRadius;                 
        float sp = sphereBaseRadius + map(pp) * dispValue;
        float d = length(p) - sp;
        
        minD = min(minD,d);        
        if ( d < 0.0){  
       		break;   
        }        
        t += 0.08;
    }    
    return smoothstep(0.,1.0,minD*shadowHardness);
}

// Function 1520
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {
    specularBounce = false;
    
    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1./1.5; n2 = 1.;
            n = -n;
        } else {
            n2 = 1./1.5; n1 = 1.;
        }
                
        float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
        
        vec3 ref;
        
        if( hash1(seed) < fresnel ) {
            ref = reflect( rd, n );
        } else {
            ref = refract( rd, n, n2/n1 );
        }
        
        return ref; // normalize( ref + 0.1 * r );
	}
}

// Function 1521
vec3 calcNormal( in vec3 pos )
{
/*#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else*/
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
//#endif    
}

// Function 1522
vec3 trace_refraction(vec3 origin, vec3 n_direction)
{
    vec3 point_of_intersection;
    vec3 refraction = trace_ray(origin, n_direction, point_of_intersection);

    float travelled_distance_in_water = distance(origin, point_of_intersection);
    refraction = apply_fog(refraction, travelled_distance_in_water,
                           fog_water_color, fog_water_extinction_coefficient);

    return(refraction);
}

// Function 1523
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;
    
    return normalize( vNormal );
}

// Function 1524
float intersectRaySphere(vec3 ray, vec3 dir, vec3 center, float radius)
{
	vec3 rc = ray-center;
	float c = dot(rc, rc) - (radius*radius);
	float b = dot(dir, rc);
	float d = b*b - c;
	float t = -b - sqrt(abs(d));
	float st = step(0.0, min(t,d));
	return mix(-1.0, t, st);
}

// Function 1525
float phaseFunctionRayleigh(in float cosTheta)
{
    return (3.0 / 4.0) * (1.0 + cosTheta * cosTheta);
}

// Function 1526
Impact castRay(in vec3 ro, in vec3 d)
{
    vec3 r = ro+d*PRIM_RAY_STEP*1.0;
    Impact impact;
 	for (int i = 0; i < PRIM_RAY_IT; i++)
    {
        impact = map(r);     
        if(impact.d < PRIM_RAY_STEP*0.1) {
            impact.d = length(r-ro);
            return impact;
        }
        r += (impact.d)*d;          
    }
    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);
}

// Function 1527
vec4 normalMap(vec2 uv) { return heightToNormal(normalChannel, normalSampling, uv, normalStrength); }

// Function 1528
bool RayIntersectSphere (SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 1529
vec3 normal2rgb(vec3 normal) {
    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));
}

// Function 1530
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0003 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1531
vec4 ray_trace(in vec3 origin, in vec3 ray) {
    const float loop_max = 1.5 * nebula_radius + camera_radius;
    const float fudge_factor = 2.1;
    vec4 acc = vec4(0.0);
    for(float i=0.0; i<loop_max; i+=step_size) {
        vec3 pos = origin + i * ray;
        vec4 samplez = nebula(pos);
        // TODO: accumulator is not step_size independent... why?
        // TODO: remove the fudge factor exp(w * step_size)
        acc = acc + (1.0 - acc.w) * vec4(samplez.xyz * samplez.w, samplez.w);
    }
    acc.xyz *= fudge_factor;
    return acc;
}

// Function 1532
vec3 normalAt( vec3 p) {
    vec3 e = vec3 (.001, -.001, 0); 
    return normalize(e.xyy * altitude(p + e.xyy)
                   + e.yyx * altitude(p + e.yyx)
                   + e.yxy * altitude(p + e.yxy)
                   + e.xxx * altitude(p + e.xxx));
}

// Function 1533
Ray createRay(vec3 o, vec3 d)
{
    return createRay(o, d, 0.0);
}

// Function 1534
vec2 rayMarch(vec3 ro, vec3 rd)
{
    vec2 dist 	= vec2(0.0);
    vec2 d 		= vec2(0.0);
    vec3 pos 	= vec3(0.0);
    
    for(int i=0; i<MAX_STEPS; i++)
    {
        pos = ro + dist.x * rd;
        d = getDist(pos);
		dist.x += d.x;
        dist.y = d.y;
		if (dist.x<MIN_DIST)
            break;
        
        if (dist.x>MAX_DIST)
            return vec2(0.0, 0.0);
    }
    
    return dist;
}

// Function 1535
vec4 calcNormal(vec3 p, float dx, in vtx co) {
	const vec3 k = vec3(1,-1,0);
	return   (k.xyyx*map(p + k.xyy*dx, vec3(0,0,1), co) +
			 k.yyxx*map(p + k.yyx*dx,vec3(0,0,1), co) +
			 k.yxyx*map(p + k.yxy*dx,vec3(0,0,1), co) +
			 k.xxxx*map(p + k.xxx*dx,vec3(0,0,1), co))/vec4(4.*dx,4.*dx,4.*dx,4.);
}

// Function 1536
vec3 rayTraceSubPixel(vec2 fragCoord) {
    vec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;
	calcRayForPixel( fragCoord + vec2(0.0,    0.0), ro, rd );
	calcRayForPixel( fragCoord + vec2(1.0/3.0,0.0), ddx_ro, ddx_rd );
	calcRayForPixel( fragCoord + vec2(0.0,    1.0), ddy_ro, ddy_rd );
		
    // trace
	vec3 pos, nor;
	float occ;
    int mid;
    float t = intersect( ro, rd, pos, nor, occ, mid );

	vec3 col = vec3(0.9);
	if( mid!=-1 )
	{
		// -----------------------------------------------------------------------
        // compute ray differentials by intersecting the tangent plane to the  
        // surface.		
		// -----------------------------------------------------------------------

		// computer ray differentials
		vec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);
		vec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);

		// calc texture sampling footprint		
		vec2     uv = texCoords(     pos, mid );
		vec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;
		vec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;
       
		// shading		
		vec3 mate = vec3(0.0);
        #if 0
	    bool lr = fragCoord.x < iResolution.x/2.0;
        if( lr ) mate = vec3(1.0)*xorTexture( uv );
        else     mate = vec3(1.0)*xorTextureGradBox( uv, ddx_uv, ddy_uv );
        #else
        //mate = vec3(1.0)*xorTexture( uv );
        mate = vec3(1.0)*xorTextureGradBox( uv, ddx_uv, ddy_uv );
        #endif
        mate = pow( mate, vec3(1.5) );
        
        // lighting	
		vec3 lin = doLighting( pos, nor, occ, rd );

        // combine lighting with material		
		col = mate * lin;
		
        // fog		
        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );
	}
	
    // gamma correction	
	col = pow( col, vec3(0.4545) );

    // line
	return col;// * smoothstep( 1.0, 2.0, abs(fragCoord.x-iResolution.x/2.0) );
}

// Function 1537
int tryreflect(inout vec2 z, vec2 norm) {
  float k = dot(z,norm);
  if (k <= 0.0) {
    return 0;
  } else {
    z -= 2.0*k*norm;
    return 1;
  }
}

// Function 1538
vec3 getNormal(vec3 p)
{
    vec2 e = vec2(0.0001, 0);//error bias
    vec3 n = normalize(vec3(
            map(p + e.xyy).x - map(p - e.xyy).x,
            map(p + e.yxy).x - map(p - e.yxy).x,
            map(p + e.yyx).x - map(p - e.yyx).x));
    return n;
}

// Function 1539
vec3 getReflection( sRay ray, sHit hitInfo, sSurf s ) {
#ifdef REFLECTIONS
    sRay rRay;
    rRay.rd = reflect(ray.rd, s.nor);
    rRay.ro = hitInfo.hp;
    rRay.rl = 16.0;
    rRay.sd = 0.1 / abs(dot(rRay.rd, s.nor));
    return getColor(rRay);
#else
    return getBackground(reflect(ray.rd, s.nor));
#endif
}

// Function 1540
bool raySceneIntersection(in Ray ray, in Scene scene, inout Intersection inter){
    for(uint i = 0u ; i < scene.nbSpheres ; ++i){
    	raySphereIntersection(ray, scene.spheres[i], inter, int(i));
    }
    for(uint i = 0u ; i < scene.nbTriangles ; ++i){
    	rayTriangleIntersection(ray, scene.triangles[i], inter, int(i));
    }
    return inter.hit;
}

// Function 1541
vec3 GetNormal(vec3 p) 
{
	float d = GetDist(p);
    vec2 e = vec2(.01, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    
    return normalize(n);
}

// Function 1542
Intersection RayPlane(Ray ray, Plane p)
{
	Intersection i;
	float num = p.d-dot(p.n, ray.o);
	float denom = dot(p.n, ray.dir);
	float t = num/denom;
	if(t > EPSILON)
	{
		i.p = ray.o + ray.dir * t;
		i.n = p.n;
		i.dist = t;
	}
	else
	{
		i.dist = ZMAX;
	}
	return i;
}

// Function 1543
vec2 raySphere(vec3 ro, vec3 rd, vec4 s) {
    vec3 ce = s.xyz;
    float ra = s.w;
    vec3 oc = ro - ce;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - ra*ra;
    float h = b*b - c;
    if( h<0.0 ) return vec2(miss); // no intersection
    h = sqrt( h );
    return vec2( -b-h, -b+h );
}

// Function 1544
vec3 getNormal( in vec3 pos )
{
    vec2 e = vec2(0.001, -0.001);
    return normalize(
        e.xyy * map(pos + e.xyy) + 
        e.yyx * map(pos + e.yyx) + 
        e.yxy * map(pos + e.yxy) + 
        e.xxx * map(pos + e.xxx));
}

// Function 1545
float raynextroot(float t) {
    t = t - RO;
    poly2 f = pa_map(ro, rd, t);    
    return nextroot(f);
}

// Function 1546
float raytracePlane(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    vec3 p = ro - planePos;
    float t = -p.y / rd.y;
    if (t > tmin && t < tmax) {
        return t;
    }
    return -1.0;
}

// Function 1547
float phase_rayleigh(float VL)
{
    return 3.0 * (1.0 + VL * VL) / (16.0 * PI);
}

// Function 1548
vec3 calcNormal( in vec3 pos , in float io ){
    
vec3 eps = vec3( 0.001, 0.0, 0.0 );
vec3 nor = vec3(
   map( pos+eps.xyy , io ).x - map( pos-eps.xyy , io ).x,
   map( pos+eps.yxy , io ).x - map( pos-eps.yxy , io ).x,
   map( pos+eps.yyx , io ).x - map( pos-eps.yyx , io ).x );
return normalize(nor);
}

// Function 1549
vec3 getNormal (in vec3 p)   
{ const vec2 k = vec2(0.01,-0.01);
  return normalize (k.xyy*sphere(p+k.xyy) 
                   +k.yyx*sphere(p+k.yyx)
                   +k.yxy*sphere(p+k.yxy)
                   +k.xxx*sphere(p+k.xxx)); }

// Function 1550
void addRay(R newRay) {
    float minProp = 2.0;
    int minI = -1;
    for (int i = 0; i < RCOUNT; ++i)
        if (!allRays[i].on) {
    		doneAny = true;
            allRays[i] = newRay;
            return;
        } else if (allRays[i].prop < minProp) {
            minProp = allRays[i].prop;
            minI = i;
        }
    if (minProp < newRay.prop) {
        doneAny = true;
        allRays[minI] = newRay;
    }
}

// Function 1551
vec3
render_no_reflections( in Material materials_table[MAT_COUNT],
                       in vec3 start, in vec3 dir, in float max_dist,
                       inout float t, out vec3 normal, out int material_index )
{
    vec3 ret = rgb_from_hsv(vec3(0.57,0.5,0.7));
    vec3 sun_specular_color = vec3(0.8,1.0,1.0);
    vec3 sun_light_dir = normalize( rotate( vec3(0.0,0.0,0.0*iTime*TAU/16.0), vec3( -0.0, 1.0, -1.0 ) ) );

    MPt mp = raymarch( start, dir, t, max_dist );
    material_index = int(mp.y);
    Material mat;
    for ( int i = 0; i != MAT_COUNT; ++i )
    {
        if ( i == material_index )
        {
            mat = materials_table[i];
        }
	}

    if ( t > 0.0 )
    {
        vec3 point = start + dir * t;
        normal = calc_normal( point, t );
        // ret = 0.5 + normal * 0.5;return ret;
        

        #if DRAW_ITERATIONS_GRADIENT
        mp.y += shadow( point, -sun_light_dir );
        #else
        float sh = 1.0 - shadow( point, -sun_light_dir );
        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );
        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );
        #endif

        float diffuse_pl = 0.0, spec_pl = 0.0;

        for ( int i=0; i!=nl; ++i )
        {
        	vec3 pld = -at_pos( point_light_pos + float(i)*rep, repeated( rep, point ) );
        	float ld = length( pld );
        	pld /= ld;
        	float ld2 = ld*ld;
            float sh_pl = 0.0;

        	#if DRAW_ITERATIONS_GRADIENT
        	mp.y += shadow( point, pld );
        	#else
        	if ( ld <= point_light_radius )
        	{
	            sh_pl      = 1.0 - shadow( point, pld );
	        	float diffuse_pl_ = sh_pl * max( 0.0, dot( normal, pld ) );
	        	float spec_pl_    = sh_pl * pow( max( 0.0, dot( reflect( dir, normal ) , pld ) ), mat.shininess  );
                diffuse_pl += diffuse_pl_ * point_light_int / ld2;
                spec_pl    += spec_pl * point_light_int / ld2;
	    	}
            #endif
        }
        
        #if !DRAW_ITERATIONS_GRADIENT
        float ambient = 0.3;
        ret = ( ( diffuse + diffuse_pl ) * mat.diffuse_reflection +
                  ambient   * mat.ambient_reflection ) * mat.color +
                ( spec + spec_pl  ) * mat.specular_reflection * sun_specular_color;
        #endif
    } else
    if ( t == 0.0 )
    {
        ret = mat.color / ( 1.0 - 20.0 * mp.distance );
    }
    #if DRAW_ITERATIONS_GRADIENT
    material_index = int(mp.y);
    #endif
    return ret;
}

// Function 1552
vec3 triplanarNormal(vec3 p, vec3 nor, vec3 w) {
    // compute rotation matrices for the 3 normal maps
    vec3 xrY = cross(nor, vec3(0,1,0));
    vec3 xrX = cross(xrY, nor);
    mat3 xrot = mat3(xrX, sign(nor.x) * xrY, nor);

    vec3 yrY = cross(nor, vec3(0,0,1));
    vec3 yrX = cross(yrY, nor);
    mat3 yrot = mat3(yrX, sign(nor.y) * xrY, nor);

    vec3 zrY = cross(nor, vec3(1,0,0));
    vec3 zrX = cross(zrY, nor);
    mat3 zrot = mat3(zrX, sign(nor.z) * xrY, nor);

    vec3 tnor = vec3(0);
    tnor += w.x * xrot * normalmap(p.yz + 5.);
    tnor += w.y * yrot * normalmap(p.zx + vec2(9., 14.));
    tnor += w.z * zrot * normalmap(p.xy + vec2(12., 7.));
    tnor = normalize(tnor);
    
    return tnor;
}

// Function 1553
float RayMarch(vec3 ro, vec3 rd) {
    float dO = 0.0;
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO>MAX_DIST || dS<SURF_DIST) break;
    }
    
    return dO;
}

// Function 1554
mat4 arrayToM4(float e[16]){
    mat4 m4;
    
    m4[0][0]=e[0] ;
m4[0][1]=e[1] ;
m4[0][2]=e[2] ;
m4[0][3]=e[3] ;
m4[1][0]=e[4] ;
m4[1][1]=e[5] ;
m4[1][2]=e[6] ;
m4[1][3]=e[7] ;
m4[2][0]=e[8] ;
m4[2][1]=e[9] ;
 m4[2][2]=e[10];
 m4[2][3]=e[11];
 m4[3][0]=e[12];
 m4[3][1]=e[13];
 m4[3][2]=e[14];
 m4[3][3]=e[15];
    
	return m4;
}

// Function 1555
vec3 calcNormal(vec3 pos){
    vec3 eps = vec3(.0001,0,0);
    vec3 nor = vec3(0);
    float invert = 1.;
    for (int i = 0; i < NORMAL_STEPS; i++){
        nor += map(pos + eps * invert).dist * eps * invert;
        eps = eps.zxy;
        invert *= -1.;
    }
    return normalize(nor);
}

// Function 1556
vec4 earthRay(vec3 ro, vec3 rd)
{
	vec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);
	if (res.w <= 0.0)
		return vec4(0.0);

	// diffuse
	vec3 p = vec3(res.x, res.y, res.z);
	vec3 n = normalize(p);
	float diff = SUN_INTENSITY * max(dot(n, sunDir()), 0.0f);

	// gi
	float amb = SUN_INTENSITY * EARTH_AMBIENT;

	return vec4(EARTH_COLOR * (diff + amb), 1.0);
}

// Function 1557
RaycastHit raycastScene(const Ray ray) {

    float time = iTime;
    if(iMouse.z > 0.) time = 6.5 * (iMouse.x / iResolution.x);
    
    float x = sin(time) / 2.;
    float nx = tan(time) / 2.;
    return intersectSphere(vec3(nx,x,0.),.6,ray);
    
}

// Function 1558
de castRay( in vec3 ro, in vec3 rd ) {
    // returns a distance and a material id
    
    float dmin = 1.0;
    float dmax = 100.0;
    
	float precis = 0.002;
    
    de o;
    o.d = dmin;
    o.m = -1.0;
    
    for( int i=0; i<MAX_STEPS; i++ )
    {
	    de res = map( ro+rd*o.d, rd );
        if( res.d<precis || o.d>dmax ) break;
        
        float d = o.d;
        o = res;
        o.d += d;
    }

    if( o.d>dmax ) o.m=-1.0;
    
    return o;
}

// Function 1559
vec3 Spline_EvaluateBinormal(mat4 MG, float t )
{
	vec4 tvec = vec4(6.*t, 2., 0., 0.);	
	vec3 p = (MG*tvec).xyz;
	return p;
}

// Function 1560
vec2 RaySphere(vec3 rd, vec3 p) {
    float l = dot(rd, p);
    float det = l*l - dot(p, p) + 1.;
    if (det < 0.) return vec2(-1);

    float sd = sqrt(det);
    return vec2(l - sd, l+sd);
}

// Function 1561
RayHit MarchReflection( vec3 origin,  vec3 direction)
{
  RayHit result;
  float maxDist = 90.0;
  float t = 0.0, dist = 0.0;
  vec3 rayPos;
 
  for ( int i=0; i<32; i++ )
  {
    rayPos =origin+direction*t;
    dist = Map( rayPos);
 

    if (abs(dist)<0.05 || t>maxDist )
    {             
      result.hit=!(t>maxDist);
      result.depth = t; 
      result.dist = dist;                              
      result.hitPos = origin+((direction*t));   
      result.steelDist = steelDist;
      result.platformDist = platformDist;
      result.terrainDist =terrainDist;
      result.waterDist =waterDist;
      break;
    }
    t += dist;
  }

  return result;
}

// Function 1562
vec2 calcRayIntersection_3_6(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {
  float latest = precis * 2.0;
  float dist   = +0.0;
  float type   = -1.0;
  vec2  res    = vec2(-1.0, -1.0);

  for (int i = 0; i < 40; i++) {
    if (latest < precis || dist > maxd) break;

    vec2 result = geometry(rayOrigin + rayDir * dist);

    latest = result.x;
    type   = result.y;
    dist  += latest;
  }

  if (dist < maxd) {
    res = vec2(dist, type);
  }

  return res;
}

// Function 1563
vec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {
     vec3 cl = vec3(1);
    for(int j = 0; j < 2; ++j) {

        CP cp = findIntersection(p, rd);
        if (length(cp.p) > 2.) {
            break;
        }
        cl *= SURFACE_COLOR;//*(abs(dot(rd, cp.normal)));
        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;
        rd = refract(rd, -normal, eta);

        p = cp.p;
        eta = 1./eta;
        p += normal*DIST_EPSILON*2.;
    }
     float d = clamp( dot( rd, ld ), 0.0, 1.0 );
     return smoothstep(0.99, 1., d)*cl;
}

// Function 1564
Ray makeRay(in vec2 fragCoord, in Viewer viewer){
    vec2 uv = fragCoord/iResolution.xy;    
    uv = uv * 2.0 - 1.0;
    uv.y *= iResolution.y/iResolution.x;
    Ray result = Ray(
        viewer.pos,
        viewer.forward + viewer.right * uv.x + viewer.up * uv.y
    );
    result.dir = normalize(result.dir);
    return result;
}

// Function 1565
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.002,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy) - map(pos-eps.xyy),
           map(pos+eps.yxy) - map(pos-eps.yxy),
           map(pos+eps.yyx) - map(pos-eps.yyx) ) );
}

// Function 1566
vec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {
    vec3 forward = normalize(lookAt - ro),
         right = normalize(cross(vec3(-0.1, 0.9, -0.1), forward)),
         up = cross(forward, right);
    return normalize(forward + right * uv.x + up * uv.y);
}

// Function 1567
vec3 ray_dir( float fov, vec2 size, vec2 pos ) {
		vec2 xy = pos - size * 0.5;

		float cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));	
		float z = size.y * 0.5 * cot_half_fov;
	
		return normalize( vec3( xy, z ) );
	}

// Function 1568
vec3 getRectangleNormal(Ray r,Rectangle rec){
    vec3 normal=normalize(rec.plane.normal);
    if (dot(r.direction,rec.plane.normal)>T_MIN)
    {
    	return  -normal;
    }else
		return normal;
}

// Function 1569
Ray4Result rayCastCube ( in World _world, in Ray4 _ray )
{  
    Ray4Result rayResFront, rayResRear;
    
    rayResFront.m_d = 0.0;
    rayResRear.m_d = MAX;
    
    // a cube is convex, so we can intersect all planes, this will give us a range of frontal max and rear min
	
	#define INTERSECT_PLANE_RANGE(_Plane,_PlaneId) intersectRayHyperPlaneRange ( _ray, _Plane, _PlaneId, rayResFront, rayResRear );
	FOREACH_PLANES(_world,INTERSECT_PLANE_RANGE)
        
	return rayResFront;
}

// Function 1570
float renormalize(float c)
{
    vec2 nx = texelFetch(iChannel2, ivec2(0, 0), 0).rg;
    float range = nx.y - nx.x;
    float offset = nx.x;
    return (c - nx.x)*1./range;
}

// Function 1571
vec3 raycast( in vec3 ro, in vec3 rd, in vec4 c )
{
	float maxd = 8.0;
	float precis = 0.002;
    float h = 1.0;
    float t = 0.0;
	float d = 0.0;
    float m = 1.0;
    for( int i=0; i<150; i++ )
	{
        if( h<precis||t>maxd ) break;
        t += h;
	    vec3 res = map( ro+rd*t, c );
        h = res.x;
		d = res.y;
		m = res.z;
    }

    if( t>maxd ) m=-1.0;
    return vec3( t, d, m );
}

// Function 1572
float rayff(float t) {
    t = t - RO;
    poly2 f = pa_map(ro, rd, t);
    return f.a[1];
}

// Function 1573
bool rayZPlaneIntersection( in Ray ray, in vec3 pos, in vec2 size, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    t = (pos.y - ray.origin.y) / ray.dir.y;
    isect.position_ = ray.origin + ray.dir*t;
    vec3 p_loc 		= isect.position_ - pos;
    isect.uv_ 		= (p_loc.xz - (-size*0.5)) / size;
    isect.normal_ 	= vec3( 0.0, 1.0, 0.0 );
    isect.tangent_ 	= vec3( 1.0, 0.0, 0.0 );
    return ((p_loc.x > -size.x*0.5) && (p_loc.x < size.x*0.5) && (p_loc.z > -size.y*0.5) && (p_loc.z < size.y*0.5));
}

// Function 1574
vec3 getRayColor(Ray ray) {


    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));
    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));
    vec3 col = getColor(ray);

    float q = exp(-d*ray.cp.dist);
    col = col*q+matColor*(1.-q);
    return col*ray.share;
}

// Function 1575
void RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)
{
    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));
    
    float rayDistance = c_minimumRayHitTime;
    float lastRayDistance = c_minimumRayHitTime;
    
    float lastHitInfoDist = 0.0f;
    
    SRayHitInfo newHitInfo = oldHitInfo;
    newHitInfo.hitAnObject = false;
    
    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)
    {
        vec3 rayPos = startingRayPos + rayDistance * rayDir;
        
        newHitInfo = TestSceneMarch(rayPos);
        
        // these two lines are so that the material code goes away when the test functions are inlines
        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);
        newHitInfo.material = dummyMaterial;
        
        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;
        if (newHitInfo.hitAnObject)
            break;
        
        lastRayDistance = rayDistance;
        rayDistance += max(newHitInfo.dist, c_minStepDistance);

        lastHitInfoDist = newHitInfo.dist;
        
        if (rayDistance > oldHitInfo.dist)
            break;
    }
    
    if (newHitInfo.hitAnObject)
    {
		float refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);
        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);
        
        if (newHitInfo.dist < oldHitInfo.dist)
            oldHitInfo = newHitInfo;
    }
}

// Function 1576
float ct_normal_pi(
    in vec2 z
){
    vec2 d = vec2(z[0] * z[0] + z[1] * z[1]);
    float a = atan(d[1], d[0]);
    if (a < 0.0) a += 6.28318;
    a /= 6.28318;
    return a;
}

// Function 1577
vec3 calcNormal( in vec3 pos, in float eps, float t )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps*t;
    return normalize( e.xyy*map( pos + e.xyy, t ).x + 
					  e.yyx*map( pos + e.yyx, t ).x + 
					  e.yxy*map( pos + e.yxy, t ).x + 
					  e.xxx*map( pos + e.xxx, t ).x );
}

// Function 1578
vec3 rayToTexture( vec3 p ) {
    return (p - vec3(0.0,0.5,0.0)) * 0.2 + 0.5;
}

// Function 1579
vec3 calcNormal( in vec3 pos, float prec )
{
	vec3 eps = vec3( prec, 0., 0. );
	vec3 nor = vec3(
        map(pos+eps.xyy) - map(pos-eps.xyy),
        map(pos+eps.yxy) - map(pos-eps.yxy),
        map(pos+eps.yyx) - map(pos-eps.yyx) );
	return normalize(nor);
}

// Function 1580
void pReflect(inout vec3 p, vec3 planeNormal, float offset) {
	float t = dot(p, planeNormal)+offset;
	p -= step(0.,-t)*2.*t*planeNormal;
}

// Function 1581
vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)
{
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return vec4(-1.0);

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return vec4(-1.0);

	//ray now found to intersect sphere, compute smallest t value of intersection
	float normalMultiplier = 1.0;
	float collisionTime = -b - sqrt(discr);
    if (collisionTime < 0.0)
    {
        collisionTime = -b + sqrt(discr);
        normalMultiplier = -1.0;
    }
    
    // calculate the normal, flipping it if we hit the inside of the sphere
    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;
    
    // return the time t that the collision happened, as well as the surface normal
    return vec4 (collisionTime, normal);
}

// Function 1582
vec3 df_normal(vec3 p)
{
    const float EPS = 0.001;
    vec3 result;
    float d = df(p);
    result.x = df(p + vec3(EPS, 0.0, 0.0)) - d;
    result.y = df(p + vec3(0.0, EPS, 0.0)) - d;
    result.z = df(p + vec3(0.0, 0.0, EPS)) - d;
    return normalize(result);
}

// Function 1583
void maxRay4Result ( inout Ray4Result _rayResultMax, in Ray4Result _curr )
{  
    if ( _curr.m_d < _rayResultMax.m_d )
        return;
    
    _rayResultMax = _curr;
}

// Function 1584
vec3 starshipNormal(vec3 pos) {
    vec2 e = vec2(1.0, -1.0) * 0.5773;
    const float eps = 0.0005;
    return normalize(e.xyy * starshipSdf(pos + e.xyy*eps) + 
                     e.yyx * starshipSdf(pos + e.yyx*eps) + 
                     e.yxy * starshipSdf(pos + e.yxy*eps) + 
                     e.xxx * starshipSdf(pos + e.xxx*eps) +
                     ripple * eps * fbm3(3.0 * pos.x));
}

// Function 1585
vec4 raymarch(in vec3 ro, in vec3 rd)
{
    vec4 acc = vec4(0.);
    float t = 0.0;
    for (int i = 0; i < 32 && acc.a < 0.95; ++i)
    {
        vec3 pos = ro + t * rd;
        float d = map(pos);
        float a = clamp(d * -30., 0.0, 0.2);
        float s = map(pos + 0.3 * sundir);
        float diff = clamp((s - d) * 0.4, 0.0, 1.0);
        vec3 brdf = vec3(0.65,0.68,0.7)* 0.2 + 3.*vec3(0.7, 0.5, 0.3)*diff;
        acc.w += (1. - acc.w) * a;
        acc.xyz += a * brdf;
        t += max(d * 0.5, 0.02);
    }
    
    acc.xyz /= (0.001 + acc.w);
    return acc;
}

// Function 1586
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 200; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0. || s > dstFar) break;
    sLo = s;
    s += stepFac * (max (0.3, 0.6 * h) + 0.008 * s);
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 1587
vec4 raymarch( in vec3 ro, in vec3 rd )
{
	vec4 sum = vec4(0, 0, 0, 0);

	float t = 0.0;
	vec3 pos = vec3(0.0, 0.0, 0.0);
	for(int i=0; i<100; i++)
	{
		if (sum.a > 0.8 || pos.y > 9.0 || pos.y < -2.0) continue;
		pos = ro + t*rd;

		vec4 col = map( pos );
		
		// Accumulate the alpha with the colour...
		col.a *= 0.08;
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	
    	t += max(0.1,0.04*t);
	}
	sum.xyz /= (0.003+sum.w);

	return clamp( sum, 0.0, 1.0 );
}

// Function 1588
vec3 normal(vec3 p)
{
 	vec3 N = vec3(-8,8,0) * PRE;
 	N = normalize(model(p+N.xyy)*N.xyy+model(p+N.yxy)*N.yxy+model(p+N.yyx)*N.yyx+model(p+N.xxx)*N.xxx);
 	return bump(iChannel2,p/4.0,N,0.01);
}

// Function 1589
vec2 castRay(vec3 ro, vec3 rd, int octaves) {
	const float p = 0.001;
	float t = 0.0;
	float h = p * 2.0;
	float m = -1.0;
	for (int i=0; i<36; i++) {
		if (abs(h)<=p || t>=28.0) break;
        t += h;
        vec2 res = map(ro + rd*t, octaves);
        h = res.x;
        m = res.y;
	}
	if (t>28.0) m = -1.0;
	return vec2(t, m);
}

// Function 1590
vec3 rayHexIntersect(in vec2 ro, in vec2 rd, in vec2 h) {
    
    //return vec3(0); 

    vec2 n = CART_FROM_HEX(h);

    // solve for u such that dot(n, ro+u*rd) = 1.0
    float u = (1.0 - dot(n, ro)) / dot(n, rd);
    
    // return the 
    return vec3(h, u);

}

// Function 1591
vec2 traceRay(in vec3 origin, in vec3 direction) {
    float material = -1.0;

    float t = 0.02;
    
    for (int i = 0; i < 1000; i++) {
        vec2 hit = scene(origin + direction * t);
        if (hit.x < 0.002 || t > 20.0) break;
        t += hit.x;
        material = hit.y;
    }

    if (t > 20.0) {
        material = -1.0;
    }

    return vec2(t, material);
}

// Function 1592
t normalize(vec3

float d(vec3 p)
{
    return 9. - abs(p.y) - texture(iChannel0, p.xz*.01).x * 7.;
}

// Function 1593
vec3 getNormal(in vec3 p) {
    return normalize(vec3(mapScene(p + vec3(0.001, 0.0, 0.0)) - mapScene(p - vec3(0.001, 0.0, 0.0)),
                          mapScene(p + vec3(0.0, 0.001, 0.0)) - mapScene(p - vec3(0.0, 0.001, 0.0)),
                          mapScene(p + vec3(0.0, 0.0, 0.001)) - mapScene(p - vec3(0.0, 0.0, 0.001))));
}

// Function 1594
vec3 calcNormal(in vec3 pos)
{
    vec3 eps = vec3(0.0001, 0.0, 0.0);
    vec3 n;
    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;
    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;
    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;
    return normalize(n);
}

// Function 1595
vec3 calcTexNormal(in sampler2D sam, in vec2 pos )
{    
  return normalize(vec3(textureLod(sam, pos + vec2(-0.001, 0),0.0).r-textureLod(sam, pos + vec2(+0.001, 0),0.0).r, textureLod(sam, pos + vec2(0, -0.001),0.0).r-textureLod(sam, pos + vec2(0, +0.001),0.0).r, .03)) * 0.5 + 0.5;
}

// Function 1596
vec3 getNormal(vec3 pos){
    vec2 e = vec2(1.0, 0.0);
    return normalize(vec3(
        hpotential(pos + epsilon * e.xyy),
        hpotential(pos + epsilon * e.yxy),
        hpotential(pos + epsilon * e.yyx))
        - hpotential(pos));
}

// Function 1597
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.0001,0.0,0.0);

    return normalize( vec3(
      map( pos+eps.xyy ) - map( pos-eps.xyy ),
      map( pos+eps.yxy ) - map( pos-eps.yxy ),
      map( pos+eps.yyx ) - map( pos-eps.yyx ) ) );
}

// Function 1598
float raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t = tmin;
	for( int i=0; i<300; i++ )
	{
        vec3 pos = ro + t*rd;
		float h = pos.y - terrainM( pos.xz );
		if( abs(h)<(0.0015*t) || t>tmax ) break;
		t += 0.4*h;
	}

	return t;
}

// Function 1599
vec3 calcNormal(vec3 p1, vec3 p2, vec3 p3) {
    vec3 u = p2-p1;
    vec3 v = p3-p1;
    
    return normalize(vec3(u.y*v.z-u.z*v.y,
                       u.z*v.x-u.x*v.z,
                       u.x*v.y-u.y*v.x));
}

// Function 1600
vec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {
    
    float height = getHeight(uv, bumpMap, maxHeight);
        
    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;
    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;
    return cross(slopeX, slopeY).zyx;
}

// Function 1601
float CastRay(vec3 ro, vec3 rd)
{
    float t = 0.0;
    
    for(int i=0 ; i<64 ; i++)
    {
        float ray = map(ro + rd * t);
        
        if(ray < (0.0001*t))
        {
            return t;
        }
        
        t += ray;
    }
    
    return -1.0;
}

// Function 1602
Obj rayMarch(vec3 ro, vec3 rd) {
	
    float t = 0.;
    
    Obj hitObj = Obj(SKY, t, ro + rd);
    for (int i = 0; i < MAX_STEPS; i++) {
    	
        vec3 p = ro + rd*t;
        
        hitObj = getDistance(p);
        t += hitObj.d*0.35;
        
        // the ray has marched far enough but hit nothing. 
        // Render the pixel as a part of the sky.
        if (t > MAX_DIST) {
        	hitObj = Obj(SKY, t, p);
            break;
        }

        // the ray has marched close enough to an object
        if (abs(hitObj.d) < SURF_DIST) {
            hitObj = Obj(hitObj.type, t, p);
        	break;
        }
        
        hitObj.d = t;
    }
    
    return hitObj;
}

// Function 1603
vec4 GetNormal(vec3 pos)
{
    vec2 e = vec2(0.003,0.);
    float o = map(pos,-1);
    return vec4(normalize(vec3(	map(pos+e.xyy,-1) - o,
                          		map(pos+e.yxy,-1) - o,
                          		map(pos+e.yyx,-1) - o)),o);
}

// Function 1604
vec2 safeNormalize(vec2 v)
{
    float l2 = dot(v, v);
    return (l2 < 1e-15) ? vec2(0.0) : (v / sqrt(l2));
}

// Function 1605
vec3 surface_normal( vec3 p )
{
    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );
    vec3 n = vec3(
        scenedf(p + epsilon.xyy) - scenedf(p - epsilon.xyy),
        scenedf(p + epsilon.yxy) - scenedf(p - epsilon.yxy),
        scenedf(p + epsilon.yyx) - scenedf(p - epsilon.yyx) );
    return normalize( n );
}

// Function 1606
vec3 Normal( vec3 pos )
{
    vec2 d = vec2(-1,1) * .000004;
    return
        normalize(
            SDF( pos + d.xxx, true )*d.xxx +
            SDF( pos + d.xyy, true )*d.xyy +
            SDF( pos + d.yxy, true )*d.yxy +
            SDF( pos + d.yyx, true )*d.yyx
        );
}

// Function 1607
vec3 calcNormal( in vec3 pos , in vec3 rd)
{
    rd = vec3(0.,0.,0.);
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    vec2 uv;
    return normalize( e.xyy*map( pos + e.xyy ,rd,uv) + 
					  e.yyx*map( pos + e.yyx  ,rd,uv) + 
					  e.yxy*map( pos + e.yxy  ,rd,uv) + 
					  e.xxx*map( pos + e.xxx  ,rd,uv) );   
}

// Function 1608
vec3 sfRayTrace(vec2 uv) {
    Ray r = sfCreateCameraRay(uv);
    return sfMissShader(r);    
}

// Function 1609
Ray getRay(Camera cam, vec2 uv)
{
    return createRay(
        cam.origin,
        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin));
}

// Function 1610
vec4 intersectSphere_raymarch(vec3 o, vec3 l, float r)
{
	int max_steps = 200;
	float max_delta = r * 1e3f;
	float min_delta = r / 1e5f;
	float end_delta = r / 1e4f;

	vec4 NO_HIT = vec4(0.0f, 0.0f, 0.0f, -1.0f);
	vec3 rd = l;
	vec3 p = o;

	int i;
	for (i = 0; i < max_steps; i++)
	{
		float d = sdSphere(p, r);
		if (d > max_delta)
			return NO_HIT;
		if (d < end_delta)
			break;
		p += rd * max(d, min_delta);
	}

	if (i == max_steps)
		return NO_HIT;
	else
		return vec4(p, 1.0f);
}

// Function 1611
vec3 getchainnormal(vec3 pos) {
    float xp = chainsdf(pos + vec3(eps, 0., 0.));
    float xm = chainsdf(pos - vec3(eps, 0., 0.));
    float ddx = xp - xm;
    float yp = chainsdf(pos + vec3(0., eps, 0.));
    float ym = chainsdf(pos - vec3(0., eps, 0.));
    float ddy = yp - ym;
    float zp = chainsdf(pos + vec3(0., 0., eps));
    float zm = chainsdf(pos - vec3(0., 0., eps));
    float ddz = zp - zm;
    return normalize(vec3(ddx, ddy, ddz));
}

// Function 1612
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;

#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
        else           tmax = min( tmax, tp2 ); }
#endif

    float t = tmin;
    float m = -1.0;
    for( int i=0; i<65; i++ )
    {
        float precis = 0.0005*t;
        vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
        m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 1613
vec3 calculateNormal(vec3 pos)
{
	vec2 eps = vec2(EPS, 0.);
    return normalize(vec3(sdSceneNormal(pos + eps.xyy).x, 
                          sdSceneNormal(pos + eps.yxy).x, 
                          sdSceneNormal(pos + eps.yyx).x) 
                     - sdSceneNormal(pos).x);
}

// Function 1614
vec3 get_normal(in vec3 p, in float t) {
	//https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
    float h = 0.0002*t; 
    #define ZERO (min(iFrame,0))
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ ){
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(p+e*h).x;
    }
    return normalize(n);
}

// Function 1615
vec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )
{
    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);
    float t0 = fract( time );
    float t1 = fract( time + 0.5 );
    
    float i0 = floor( time );
    float i1 = floor( time + 0.5 );
    
    float o0 = t0 - 0.5;
    float o1 = t1 - 0.5;
    
    vec2 vUV0 = vUV + Hash2(i0);
    vec2 vUV1 = vUV + Hash2(i1);
    
    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );
    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );

    float weight = abs( t0 - 0.5 ) * 2.0;
    //weight = smoothstep( 0.0, 1.0, weight );

    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );
    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );
    
    vec4 result=  mix( sample0, sample1, weight );
    result.xyz = normalize(result.xyz);

    fOutFoamTex = mix( foam0, foam1, weight );

    return result;
}

// Function 1616
vec3 createRay(vec2 px, mat4 PInv, mat4 VInv)
{


    vec2 pxNDS = px*2. - 1.;
    vec3 rayNDS = vec3 (pxNDS,1.);

    vec4 rayClip = vec4 (rayNDS.xy, -1.0, 1.0);
    vec4 rayEye = PInv * rayClip;

    rayEye.w = 0.;

    vec3 rayWorld = (VInv * rayEye).xyz;
    
    return normalize (rayWorld);   
}

// Function 1617
float rayMarch(vec3 ro, vec3 rd){
 	float R0 = 0.;
    for(int i = 0; i < MAX_COUNT; i++){
     	vec3 p = ro + R0 * rd;
        float d = getDist(p);
        R0 += d;
        if(d < MIN_DIST || R0 > MAX_DIST) break;
    }
    return R0;
}

// Function 1618
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3(0.01,0.0,0.0);
	return normalize( vec3(
		map(pos+eps.xyy) - map(pos-eps.xyy),
		map(pos+eps.yxy) - map(pos-eps.yxy),
		map(pos+eps.yyx) - map(pos-eps.yyx) ) );
}

// Function 1619
vec3 calcNormal(vec3 pos){
    vec2 off = vec2(0.002,0.0);
    
   	vec3 normal = normalize(vec3(
    map(pos+off.xyy).x - map(pos-off.xyy).x,
    map(pos+off.yxy).x - map(pos-off.yxy).x,
    map(pos+off.yyx).x - map(pos-off.yyx).x )); 
    
    return normal;
}

// Function 1620
vec3 getNormalMesh(in vec3 p) {
    return normalize(vec3(mapSceneMesh(p + vec3(0.001, 0.0, 0.0)) - mapSceneMesh(p - vec3(0.001, 0.0, 0.0)),
                          mapSceneMesh(p + vec3(0.0, 0.001, 0.0)) - mapSceneMesh(p - vec3(0.0, 0.001, 0.0)),
                          mapSceneMesh(p + vec3(0.0, 0.0, 0.001)) - mapSceneMesh(p - vec3(0.0, 0.0, 0.001))));
}

// Function 1621
vec2 RAYMARCH_distanceField( vec3 o, vec3 dir)
{
    //From Inigo Quilez DF ray marching :
    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
    float tmax = GEO_MAX_DIST;
    float t = 0.0;
    float dist = GEO_MAX_DIST;
    for( int i=0; i<50; i++ )
    {
	    dist = DF_composition( o+dir*t ).d;
        if( abs(dist)<0.0001 || t>GEO_MAX_DIST ) break;
        t += dist;
    }
    
    return vec2( t, dist );
}

// Function 1622
vec2 estimateNormal(vec2 p) {
    return normalize(vec2(
        mapSeed(vec2(p.x + EPSILON, p.y)) - mapSeed(vec2(p.x - EPSILON, p.y)),
        mapSeed(vec2(p.x, p.y + EPSILON)) - mapSeed(vec2(p.x, p.y - EPSILON))
    ));
}

// Function 1623
vec3 getNormal(vec3 p)
{
    const float h = 0.2;
    #define ZERO (min(iFrame,0))
    vec3 n = vec3(0.);
    for (int i=ZERO; i<4; i++)
    {
        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);
        n += e*map(p+e*h).x; /* btw: s/pos/p */
    }
    return normalize(n);
}

// Function 1624
vec3 refraction(vec3 v, vec3 normal, float n1, float n2) {
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3 tang = normalize(v - cosA * normal);
    float sinB = sinA / n2 * n1;
    float cosB = sqrt(1.0 - sinB * sinB);
    return sinB * tang + cosB * normal;
}

// Function 1625
vec3 ray_dir_spherical( float fov, vec2 size, vec2 pos ) {
	vec2 angle = ( pos - vec2( 0.5 ) * size ) * ( fov / size.y * DEG_TO_RAD );

	vec2 c = cos( angle );
	vec2 s = sin( angle );
	
	return normalize( vec3( c.y * s.x, s.y, -c.y * c.x ) );
}

// Function 1626
void TraceRay (in vec3 rayPos, in vec3 rayDir, in float fogMod)
{
	int lastHitPrimitiveId = 0;
	
	vec3 rayToCameraDir = rayDir;
	
	vec3 pixelColor = vec3(0.0,0.0,0.0);	
	SCollisionInfo collisionInfo =
		SCollisionInfo
		(
			0,
			false,
			false,
			-1.0,
			vec3(0.0,0.0,0.0),
			vec3(0.0,0.0,0.0),
			SMaterial(
				vec3(0.0,0.0,0.0),
				1.0,
				vec3(0.0,0.0,0.0)
			)
		);

	// run intersection against all objects, including light objects		
	#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
	SPHEREPRIMLISTWITHLIGHTS
	#undef PRIM
			
	// run intersections against all boxes
	#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
	BOXPRIMLIST
	#undef PRIM

	if (collisionInfo.m_foundHit)
	{	
			
		// do texture sampling for the floorbox
		if (collisionInfo.m_Id == floorBox.m_Id)
		{
			collisionInfo.m_material.m_diffuseColor = 
			texture(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;
		}
			
		// point lights
		#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, rayDir);
		POINTLIGHTLIST
		#undef LIGHT
				
		// directional lights
		#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, rayDir);
		DIRLIGHTLIST				
		#undef LIGHT

		// ambient light
		pixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor;
					
		vec4 fog = vec4(fogColor, FogAmount(rayPos, collisionInfo.m_intersectionPoint, fogMod));

		shadingStack.m_addColor = pixelColor;
		shadingStack.m_fogColorAndAmount = fog;
	}
	// no hit means all fog
	else
		shadingStack.m_fogColorAndAmount = vec4(fogColor,1.0);
}

// Function 1627
vec3 getNormal(vec3 p)
{
    const float eps = .001;
    float d0x = scene(vec3(p.x - eps,p.yz));
    float d1x = scene(vec3(p.x + eps,p.yz));
    float d0y = scene(vec3(p.x,p.y - eps,p.z));
    float d1y = scene(vec3(p.x,p.y + eps,p.z));
    float d0z = scene(vec3(p.xy,p.z - eps));
    float d1z = scene(vec3(p.xy,p.z + eps));
    //return vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(.5/eps);
    //return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(2.5/eps));
    return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z));
    //return vec3(1.0,0.0,0.0);
}

// Function 1628
bool raySceneIntersection( 	in Ray ray,
                          	in float distMin,
                          	out RaySurfaceHit hit ) {
    hit.obj_id = -1;
    hit.dist = 1000.0;
    hit.E = ray.dir*(-1.0);
    
    //check lights
    for( int i1=0; i1<LIGHT_COUNT; i1++ ){
        float dist;
        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {
            hit.dist = dist;
          	vec3 hitpos = ray.origin + ray.dir*hit.dist;
    		hit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);
    		hit.mtl_id = 4 + i1;
            hit.obj_id = i1;
        }
    }
    
    //check walls
    for( int i=0; i<WALL_COUNT; i++ ){
        float dist;
        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){
            hit.dist = dist;
//            hit.pos = ray.origin + ray.dir*hit.dist;
    		hit.N = walls[i].abcd.xyz;
    		hit.mtl_id = 0;
            hit.obj_id = LIGHT_COUNT + i;
        }
    }
    
#ifdef SHOW_PLANES
    //check planes
    for( int i=0; i<PLANE_COUNT; i++ ){
        float dist;
        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){
            vec3 hitPos = ray.origin + ray.dir*dist;
            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {
                hit.dist = dist;
//                hit.pos = hitPos;
                hit.N = planes[i].abcd.xyz;
                hit.mtl_id = 1+i;
                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;
            }        
        }
    }
#endif
    
    return ( hit.obj_id != -1 );
}

// Function 1629
void CameraOrbitRay(in vec2 fragCoord, in float n, in vec3 c, in float d, 
                    out vec3 ro, out vec3 rd, out mat3 t) 
{
    float a = 1.0/max(iResolution.x, iResolution.y);
    rd = normalize(vec3((fragCoord - iResolution.xy*0.5)*a, n));
 
    ro = vec3(0.0, 0.0, -d);
    
    float ff = min(1.0, step(0.001, iMouse.x) + step(0.001, iMouse.y));
    vec2 m = PI*ff + vec2(((iMouse.xy + 0.1) / iResolution.xy) * (PI*2.0));
    m.y = -m.y;
    m.y = sin(m.y*0.5)*0.6 + 0.6;
        
    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));
    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));
    
    t = rotY * rotX;
    
    ro = t * ro;
    ro = c + ro;

    rd = t * rd;
    
    rd = normalize(rd);
}

// Function 1630
vec3 sphereNormal(vec3 sc, float sr, vec3 p) {
    return normalize(p - sc);
}

// Function 1631
vec3 uniformRay(float t) {
    float u = rand(vec2(12.9898, 78.233), t);
    float v = rand(vec2(63.7264, 10.873), t);
    float phi = 2.0 * PI * u;
    float ctheta = 1.0 - 2.0 * v;
    float stheta = sqrt(1.0 - ctheta * ctheta);
    return vec3(stheta * cos(phi), ctheta, stheta * sin(phi));
}

// Function 1632
float castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {

    float precis = 0.001;
    float h = precis * 2.0;
    float t = -3.5+rnd(co+0.01*iTime)*7.;
    for(int i = 0; i < 200; i++) 
    {
    	if(abs(h) < precis || t > maxt) break;
        h = map(ro+rd*t);
        t += 0.5*h;
    }
    return t;
}

// Function 1633
vec3 calculate_normal(in vec3 position)
{
        return normalize(
                vec3(
                        query(position + vec3(EPSILON, 0., 0.)) -
                        query(position - vec3(EPSILON, 0., 0.)),
                        query(position + vec3(0., EPSILON, 0.)) -
                        query(position - vec3(0., EPSILON, 0.)),
                        query(position + vec3(0., 0., EPSILON)) -
                        query(position - vec3(0., 0., EPSILON))
                )
        );
}

// Function 1634
vec4 length_normalize( vec3 x ) { float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec4( x, p ) * q; }

// Function 1635
vec3 normalAt(in vec3 ro) {
    return normalize(vec3(map(ro + EV.xyy) - map(ro - EV.xyy),
                          map(ro + EV.yxy) - map(ro - EV.yxy),
                          map(ro + EV.yyx) - map(ro - EV.yyx)));
}

// Function 1636
vec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )
{
  float t = 1e20;

  vec3 s = vec3(R.y < 0. ? 1.-sqrt(-R.y/(P.y+1.)) : 1.); // P.y+1 floor pos
  for( int i=0; i<SPH; i++ )
  {    
    float h = sphIntersect( P, R, sphere[i] );
    if( h>0.0 && h<t )
    {
      s = i == iid ? tint * 2. : vec3(0.);
      t = h;
    }
  }     
  return max( vec3(0.), s);           
}

// Function 1637
void TraceRay (in vec3 cameraPos, in vec3 rayPos, in vec3 rayDir, inout vec4 hitInfo, inout vec3 hitDiffuse, inout vec3 hitEmissive, inout float hitSpecularPower, inout bool hitSomething, in bool shadowRay)
{
    vec4 info = hitInfo; 
    vec2 uv;
    
    // the floor
    info = RayIntersectPlane(rayPos, rayDir, vec4(0.0, 1.0, 0.0, 0.0), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        float checkerBoard = (mod(floor(uv.x) + floor(uv.y), 2.0) < 1.0 ? 1.0 : 0.4);        
        hitDiffuse = vec3(checkerBoard);
        hitEmissive = vec3(0.0);
        hitSpecularPower = 1000.0;
        hitInfo = info;
        hitSomething = true;        
    }
    
    for (int objectIndex = 0; objectIndex < 3; ++objectIndex)
    {
        // a blue box
        mat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.0);
        vec3 trans = ObjectRepeat(cameraPos.z, 27.2, 3.1 + float(objectIndex)*4.7, 0.25);
        mat4 tra = translate( trans.x, trans.y, trans.z);
        mat4 txi = tra * rot; 
        mat4 txx = inverse( txi );    
        info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.25), uv);
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.2, 0.2, 0.9);
            hitEmissive = vec3(0.0);
            hitSpecularPower = 10.0;
            hitInfo = info;
            hitSomething = true;
        }    

        // a red ball
        trans = ObjectRepeat(cameraPos.z, 28.3, 1.5 + float(objectIndex)*8.2, 0.5);
        info = RayIntersectSphere(rayPos, rayDir, vec4(trans.x, trans.y, trans.z, 0.5), uv);
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.9, 0.2, 0.2);
            hitEmissive = vec3(0.0);
            hitSpecularPower = 100.0;
            hitInfo = info;
            hitSomething = true;        
        }    

        // a green ball
        trans = ObjectRepeat(cameraPos.z, 29.7, 1.7 + float(objectIndex)*6.3, 0.125);
        info = RayIntersectSphere(rayPos, rayDir, vec4(trans.x, trans.y, trans.z, 0.125), uv);
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.2, 0.9, 0.2);
            hitEmissive = vec3(0.0);
            hitSpecularPower = 100.0;
            hitInfo = info;
            hitSomething = true;        
        }     

        // a magenta box
        trans = ObjectRepeat(cameraPos.z, 26.8, 2.0  + float(objectIndex)*7.28, 0.125);
        rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.9);
        tra = translate(trans.x, trans.y, trans.z);
        txi = tra * rot; 
        txx = inverse( txi );    
        info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.125), uv);
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.9, 0.2, 0.9);
            hitEmissive = vec3(0.0);
            hitSpecularPower = 10.0;
            hitInfo = info;
            hitSomething = true;
        }
    }
           

    // Walls and cieling 
    if (GetMode() >= 4.0)
    {
        // left wall
        info = RayIntersectPlane(rayPos, rayDir, vec4(-1.0, 0.0, 0.0, 2.0), uv);
        if (info.x > 0.0 && info.x < hitInfo.x)
        {
            hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;
            hitEmissive = vec3(0.0);
            hitSpecularPower = 1000.0;
            hitInfo = info;
            hitSomething = true;    
            
            // do some fake bump mapping
			mat3 tangentSpace = mat3
			(
				vec3(0.0, 0.0, 1.0),
				vec3(0.0, 1.0, 0.0),
				vec3(-1.0, 0.0, 0.0)
			);
            hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);
        }      
        
        // Dont consider cieling and right wall for shadows.
        // a hack to get around the fact that we grow the uv's, but use the directional light to cast back
        // up the directional light, which WILL have shadows. We ought to be adjusting reverse light direction.
        if (!shadowRay)
        {
            // cieling
            info = RayIntersectPlane(rayPos, rayDir, vec4(0.0, -1.0, 0.0, 4.0), uv);
            if (info.x > 0.0 && info.x < hitInfo.x)
            {
                hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;
                hitEmissive = vec3(0.0);
                hitSpecularPower = 1000.0;
                hitInfo = info;
                hitSomething = true;        
                
                // do some fake bump mapping
                mat3 tangentSpace = mat3
                (
                    vec3(1.0, 0.0, 0.0),
                    vec3(0.0, 0.0, 1.0),
                    vec3(0.0,-1.0, 0.0)
                );
                hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);                
            }              

            // right wall
            info = RayIntersectPlane(rayPos, rayDir, vec4( 1.0, 0.0, 0.0, 2.0), uv);
            if (info.x > 0.0 && info.x < hitInfo.x)
            {   
                vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);
                vec3 lightuv = LightSpaceToLightUV(lightpos);

                if (abs(lightuv.x) >= 1.0 || abs(lightuv.y) >= 1.0)
                {
                    hitDiffuse = texture(iChannel1, uv/2.0).rgb * 5.0;
                    hitEmissive = vec3(0.0);
                    hitSpecularPower = 1000.0;
                    hitInfo = info;
                    hitSomething = true;               
                    
                    // do some fake bump mapping
                    mat3 tangentSpace = mat3
                    (
						vec3(0.0, 0.0, 1.0),
						vec3(0.0, 1.0, 0.0),
						vec3(1.0, 0.0, 0.0)
                    );
                    hitInfo.yzw = GetBumpMapNormal(uv/2.0, tangentSpace);                        
                }
                else
                {
                    hitDiffuse = vec3(0.0);
                    hitEmissive = GetLightColor(lightuv);
                    hitSpecularPower = 1000.0;
                    hitInfo = info;
                    hitSomething = true;                                   
                }
            }   
        }
        
    }
    
    // light source plane - test last
    mat4 lightMatrix = GetDirectionalLightMatrixInverse();
    vec4 plane;
    plane.xyz = lightMatrix[1].xyz;
    plane.w = length(directionalLightSourcePosition);
    info = RayIntersectPlane(rayPos, rayDir, plane, uv);    
    // if ever a shadow ray hits the light source as the closest intersection, return a miss, so we don't get shadows from behind the light source!
    if (shadowRay)
    {
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.0);
            hitEmissive = vec3(0.0);
            hitSpecularPower = 0.0;
            hitInfo = vec4(1000.0, -rayDir);
            hitSomething = false;        
        }        
    }
    // else if we are not doing a shadow ray, and the mode is >= 1, then we want to show the light source as an object
    else if (GetMode() >= 1.0)
    {
        if (info.x > 0.0 && info.x < hitInfo.x) {
            
            vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);
            vec3 lightuv = LightSpaceToLightUV(lightpos);            
            
            if (abs(lightuv.x) <= 1.0 && abs(lightuv.y) <= 1.0)
            {
            	hitDiffuse = vec3(0.0);
                if (GetMode() >= 3.0)
            		hitEmissive = GetLightColor(lightuv);
                else
                    hitEmissive = vec3(1.0);
            	hitSpecularPower = 10.0;
            	hitInfo = info;
            	hitSomething = true;
            }
        }            
    }    
}

// Function 1638
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.;
    float z = size.y / tan(radians(fieldOfView) / 2.);
    return normalize(vec3(xy, -z));
}

// Function 1639
vec4 primaryRayMarchSmoke(vec3 startPos, vec3 direction, vec3 lightDir) {
    vec3 position = startPos ;
    vec3 stepVector = direction * primSmokeSampleSize ;
    float dist ;
    float extinction = 1.0 ;
    vec3 colour = vec3(0.0) ;
    for (int i = 0 ; i < primSmokeNumSamples ; ++i) {
        if (extinction < 0.05 || !isIntersectingSmokeShape(position,0.005,dist))
            break ;
     	float vertDistFromRocket = abs(position.y - smokeEnd.y) ;
        float deltaYDensityMod = (1.f-(vertDistFromRocket)/(smokeEnd.y-smokeStart.y));
		float density = sampleSmoke(position) * deltaYDensityMod * deltaYDensityMod;
        extinction *= exp(-extinctionCoeff*density*primSmokeSampleSize);
        vec3 scattering = primSmokeSampleSize * density * scatteringCoeff * (ambientCol +  sunCol * getIncidentSunlight(position, lightDir)) ;
        colour += scattering * extinction ;
        position += stepVector ;
    }
    
    return vec4(colour,extinction) ;    
}

// Function 1640
bool rayQuadUV( vec3 ro, vec3 rd, vec3 po, vec3 pn, vec2 psz, out vec2 uv, out float rt )
{
    rt = rayPlane( ro, rd, po, pn );
    if( !(rt > 0.) ) return false; // NaN caught here!
    vec3 pos = ro + rt * rd;
    float x = dot(pos - po, l2w( vec3(1.,0.,0.), pn ) );
    float y = dot(pos - po, l2w( vec3(0.,0.,1.), pn ) );
    uv = vec2(x,y)/psz;
    if( abs(uv.x) >= .5001 || abs(uv.y) >= .5001 ) return false;
    uv += .5; 
    return true;
}

// Function 1641
vec3 Normal(in vec3 p, in vec3 ray, in float t) {
    float pitch = .2 * t / iResolution.x;


    vec2 d = vec2(-1,1) * pitch;

    vec3 p0 = p+d.xxx; // tetrahedral offsets
    vec3 p1 = p+d.xyy;
    vec3 p2 = p+d.yxy;
    vec3 p3 = p+d.yyx;

    float f0 = DE(p0).x;
    float f1 = DE(p1).x;
    float f2 = DE(p2).x;
    float f3 = DE(p3).x;

    vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);
    //return normalize(grad);	// prevent normals pointing away from camera (caused by precision errors)
    return normalize(grad - max(.0,dot (grad,ray ))*ray);
}

// Function 1642
vec3 calcNormal(vec3 p, inout float edge, inout float crv, float t) { 
    
    float eps = 3./mix(450., min(850., iResolution.y), .35);

    float d = map(p);
    
    vec3 e = vec3(eps, 0, 0);
    
    vec3 da = vec3(-2.*d);
    for( int i = min(iFrame,0); i<3; i++ )
    {
        for( int j=min(iFrame,0); j<2; j++ )
            da[i] += map(p + e*float(1-2*j));
        e = e.zxy;
    }
    da = abs(da);
    
    edge = da.x + da.y + da.z;
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
    
    vec3 n = vec3(0.0);
    for( int i=min(iFrame, 0); i<4; i++ )
    {
        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);
        n += e*map(p + .001*e);
    }
    
    return normalize(n);
}

// Function 1643
vec3 get_normal(vec3 p) {
    const float eps = 0.0001;
    vec2 e = vec2(1.0,-1.0);
    return normalize(e.xyy*map(p + e.xyy*eps).d + 
                     e.yyx*map(p + e.yyx*eps).d + 
                     e.yxy*map(p + e.yxy*eps).d + 
                     e.xxx*map(p + e.xxx*eps).d);
}

// Function 1644
vec3 getNormal(in vec3 p) {
	//as I explained in the bump function, it get's the gradient
    //around the point of interest, although here instead of a reference we
    //get the slope between a bit above to a bit below the point of interest, etc.
    //They are the slopes of distances so float values, and they are used to 
    //represent components of a vector3 and that vector can be used as the normal.
   
	const float eps = 0.001;
	return normalize(vec3(
		map(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),
		map(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),
		map(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))
	));

}

// Function 1645
vec3 getNormalHex(vec3 p) {
	float d=map(p).dist;
	float e=.001;
	return normalize(
        vec3(
            map(
                p+vec3(e,0,0)).dist-d,
                map(p+vec3(0,e,0)).dist-d,
                map(p+vec3(0,0,e)).dist-d
        	)
    	);
}

// Function 1646
vec3 calcNormalmapBeach( in vec3 pos, in float ep )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*mapBeach(pos+e.xyy*ep) + 
					 e.yyx*mapBeach(pos+e.yyx*ep) + 
					 e.yxy*mapBeach(pos+e.yxy*ep) + 
					 e.xxx*mapBeach(pos+e.xxx*ep) );
}

// Function 1647
vec3 raymarch(inout Ray ray, vec3 playerPos, bool drawPlayer, bool drawRefractive, vec3 SUN_DIR) {
    float h = 1.0;
    float t = 0.0;
    for(int i = 0; i < MAX_STEPS; i++) {
        h = map(ray.src + t*ray.dir, ray.matID, playerPos, drawPlayer, drawRefractive);
        t += h;
        ray.iter = i;
        if (t > TMAX) break;
    }
    int missed = int(step(TMAX, t));
    ray.matID = (1- missed) * ray.matID;
    ray.t = float(missed)*TMAX + float(1-missed)*t;
    ray.pos = ray.src + ray.t*ray.dir;
    ray.nor = calculateNormal(ray.pos, playerPos);
    if (texture(iChannel1, vec2(KEY_N, 0.25)).x > 0.5)			// Color with normals
        return normalize(0.5*(ray.nor+1.0));
    return computeColor(ray, playerPos, SUN_DIR);
}

// Function 1648
void rayCast(inout ray _r)
{	
	// ray start point
	vec3 p = _r.o;
	vec2 d = vec2(0.);
	float ld = 0.;
    
    sincos(iTime*-4.);
    
    // traverse map
    for(int t = 0; t < 1000; t++)
    {
        d = map(p);        
        p += _r.d * d.x;
        if(d.x < 0.001)
        {
            _r.h = true;
            _r.hp = p;
            _r.m = d.y;
                       
            break;
        }
    }
}

// Function 1649
vec3 calcNormal( in vec3 pos )
{
    // a large epsilon is used here because the underlying data is coarse
    const float eps = 0.01;             // precision of the normal computation

    //const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ).x + 
					  v2*doModel( pos + v2*eps ).x + 
					  v3*doModel( pos + v3*eps ).x + 
					  v4*doModel( pos + v4*eps ).x );
}

// Function 1650
vec3 pointOnRay(Ray r, float t)
{
    return r.o + r.d * t;
}

// Function 1651
float GetRefractedAngle(float ni, float thetai, float nf){
    return asin(ni/nf*sin(thetai));
}

// Function 1652
vec3 calcNormal( in vec3 p, in float id ) {
        vec3 eps = vec3(0.002,0.0,0.0);

        vec3 nor = normalize( vec3(
            map( p + eps.xyy).x - map(p - eps.xyy).x,
            map( p + eps.yxy).x - map(p - eps.yxy).x,
            map( p + eps.yyx).x - map(p - eps.yyx).x));

        if (id == 2.0) {
            return doBumpMap(p,nor);
        }

        return nor;
    }

// Function 1653
vec2 calcRayIntersection_3557608877(vec3 rayOrigin, vec3 rayDir) {
  return calcRayIntersection_3557608877(rayOrigin, rayDir, 20.0, 0.001);
}

// Function 1654
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(EPSILON,0.0,0.0);
	return normalize( vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x, map(pos+eps.yxy).x - map(pos-eps.yxy).x, map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1655
float cast_ray(inout vec3 p, in vec3 h) {
    float depth = 0.0;
    float d;
    for (int a = 0; a < MAX_STEPS; a ++) {
        d = f(p);     // test distance
        p += d * h;   // step the point
        depth += d;
        if (d < DISTANCE_THRESHOLD) {
            break;
        }
    }
    return d;
}

// Function 1656
vec3 calcNormal( in vec3 pos ){
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 1657
float castRayGlass( in vec3 ro, in vec3 rd ) {
    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );
    rd1 = rotateY( rd1, CLOCK_ROT_Y );

    float t = -1.;
    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);
    if (bb.y > 0.) {
        t = max(bb.x, 0.);
        float tmax = bb.y;
        for( int i=0; i<24; i++ ) {
            float precis = 0.00025*t;
            float res = mapGlass( p1+rd1*t );
            if( res<precis || t>tmax ) break; 
            t += res;
        }

        if( t>tmax ) t=-1.0;
    }
    return t;
}

// Function 1658
vec3 skyRay(vec3 org, vec3 dir, vec3 sun_direction, bool fast)
{
    const float ATM_START = EARTH_RADIUS+CLOUD_START;
	const float ATM_END = ATM_START+CLOUD_HEIGHT;
    
    int nbSample = fast ? 13 : 35;   
    vec3 color = vec3(0.0);
	float distToAtmStart = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_START);
    float distToAtmEnd = intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END);
    vec3 p = org + distToAtmStart * dir;    
    float stepS = (distToAtmEnd-distToAtmStart) / float(nbSample);    
    float T = 1.;    
    float mu = dot(sun_direction, dir);
    float phaseFunction = numericalMieFit(mu);
    p += dir*stepS*hash(dot(dir, vec3(12.256, 2.646, 6.356)) + iTime);
    if(dir.y > 0.015)
	for(int i=0; i<nbSample; i++)
	{        
        float cloudHeight;
		float density = clouds(p, cloudHeight, fast);
		if(density>0.)
		{
			float intensity = lightRay(p, phaseFunction, density, mu, sun_direction, cloudHeight, fast);        
            vec3 ambient = (0.5 + 0.6*cloudHeight)*vec3(0.2, 0.5, 1.0)*6.5 + vec3(0.8) * max(0.0, 1.0-2.0*cloudHeight);
            vec3 radiance = ambient + SUN_POWER*intensity;
            radiance*=density;			
            color += T*(radiance - radiance * exp(-density * stepS)) / density;   // By Seb Hillaire                  
            T *= exp(-density*stepS);            
			if( T <= 0.05)
				break;
        }
		p += dir*stepS;
	}
        
    if(!fast)
    {
        vec3 pC = org + intersectSphere(org, dir, vec3(0.0, -EARTH_RADIUS, 0.0), ATM_END+1000.0)*dir;
    	color += T*vec3(3.0)*max(0.0, fbm(vec3(1.0, 1.0, 1.8)*pC*0.002)-0.4);
    }
	vec3 background = 6.0*mix(vec3(0.2, 0.52, 1.0), vec3(0.8, 0.95, 1.0), pow(0.5+0.5*mu, 15.0))+mix(vec3(3.5), vec3(0.0), min(1.0, 2.3*dir.y));
    if(!fast) 	background += T*vec3(1e4*smoothstep(0.9998, 1.0, mu));
    color += background * T;
    
    return color;
}

// Function 1659
float raymarch(vec3 ori, vec3 dir, int maxIter) {
 
    float d = 0.;
    for(int i = 0; i < 256; i++) {
        if(d > 1000. || i >= maxIter) {
			break;            
        }
        vec3    p = ori+dir*d;
        float dst = dstScene(p);
        d += dst * .75;
        if(dst < .001) {
            break;
        }
    }
    return d;
    
}

// Function 1660
Ray cameraRay( in vec2 uv ) {
#ifdef CAMERA_MOUSE
    vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;
    vec2 T = TRIG( 4., mx.x * PI2 );
    vec2 V = TRIG( 4., mx.y * PI2 * .5 );
        
    vec3 eye  = vec3( T.x, mx.y * 4. +2. , T.y );
    vec3 look = vec3( 0. );
    
    float zoom = 1.;
    float roll = .0;
#else
    vec2 T = TRIG( 1., iTime );
    
	vec3  eye  = vec3( 6. * T.x, 2., 6. * T.y );
	vec3  look = vec3( .0, 0, .0 );
    
    eye = vec3( .3 * T.x, 4. , iTime * 3.);
    
    float g = ground( eye );
    eye.y = 3. - g;
    
    look = vec3( .0, eye.y, eye.z + 2. );
    
	float roll = 0.0002 * T.x; // TODO: stars need to match..
    float zoom = 1.2;
    
    //roll = .0;
#endif
    
	mat3 camera = makeCamera( eye, look, roll );
    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );

    return Ray( eye, direction );
}

// Function 1661
ray getRay(vec2 uv, camera camera) {
    ray ray;
    ray.origin = camera.origin;
    vec3 center = ray.origin + camera.forward * camera.zoom;
    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );
    ray.direction = normalize(intersection - ray.origin);
    return ray;   
}

// Function 1662
vec2 sdf_normal(float sdf)
{
    vec2 n = vec2(dFdx(sdf), dFdy(sdf));
	float sqlen = dot(n, n);
    return n * ((sqlen > 0.) ? inversesqrt(sqlen) : 1.);
}

// Function 1663
vec3 normal(in vec3 p
){vec2 e=vec2(-1,1)*.001
 ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)
                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}

// Function 1664
vec3 getNormal(vec3 pos, float e, bool inside)
{  
    vec2 q = vec2(0, e);
    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,
                          map(pos + q.xyx).x - map(pos - q.xyx).x,
                          map(pos + q.xxy).x - map(pos - q.xxy).x));
}

// Function 1665
void screenToRay ( in Camera _camera, in vec2 _screenPos, out Ray _ray )
{
    vec3 rayPoint;
    
    //fov is hardcoded here (distance of Z plane)
    screenToWorld ( _camera, _screenPos, 3.0, rayPoint );        
    
    _ray.m_pos = _camera.m_matrix[3].xyz;
    _ray.m_dir = normalize(rayPoint-_ray.m_pos);
}

// Function 1666
vec3 ray_march_diffuse(vec3 rayOrigin, vec3 rayDir, vec3 diffuse) {
        float distanceTravelled = 0.0;
        const int NUMBER_OF_STEPS = 64;
        const float MINIMUM_HIT_DISTANCE = 0.001;
        const float MAXIMUM_TRACE_DISTANCE = 1000.0;
        const int BOUNCE_AMOUNTS = 3;
        vec3 finalDiffuse = diffuse;
        bool done = false;
        for(int r = 0; r < BOUNCE_AMOUNTS; r++) {
            if (done) {
                break;
            }
            for(int i = 0; i < NUMBER_OF_STEPS; i++) {
                vec3 currPos = rayOrigin + distanceTravelled * rayDir;
                vec4 sceneData = scene_dist(currPos);
                float sceneDist = sceneData.x;
                vec3 sceneDiffuse = sceneData.yzw;
                if (sceneDist < MINIMUM_HIT_DISTANCE) {
                    float addWeight = pow(0.5, float(r + 1));
                    finalDiffuse = (1.0 - addWeight) * finalDiffuse + addWeight * sceneDiffuse;
                    vec3 normal = calculate_normal(currPos);
                    rayOrigin = currPos;
                    rayDir = reflect(rayDir, normal);
                    break;
                }
                if (sceneDist > MAXIMUM_TRACE_DISTANCE) {
                    done = true;
                    break;
                }
                distanceTravelled += sceneDist;
            }
        }
        finalDiffuse = 0.6 * Sky(rayOrigin, rayDir) + 0.4 * finalDiffuse;
        return finalDiffuse;
    }

// Function 1667
vec3 SphereNormal(in vec3 d, in float r, in float e) {
    float theta = atan(d.y,d.x) ;
    float phy = acos(d.z);
    
    vec3 dy0 = vec3(cos(theta+e)*sin(phy), sin(theta+e)*sin(phy), cos(phy));
    vec3 dy1 = vec3(cos(theta-e)*sin(phy), sin(theta-e)*sin(phy), cos(phy));

    vec3 dx0 = vec3(cos(theta)*sin(phy+e), sin(theta)*sin(phy+e), cos(phy+e));
    vec3 dx1 = vec3(cos(theta)*sin(phy-e), sin(theta)*sin(phy-e), cos(phy-e));
    
    float ny0 = noise(dy0*r);
    float ny1 = noise(dy1*r);
    float nx0 = noise(dx0*r);
    float nx1 = noise(dx1*r);
    
    dy0 *= r + ny0;
    dy1 *= r + ny1;
    dx0 *= r + nx0;
    dx1 *= r + nx1;
    
    return normalize(cross(dy0 - dy1, dx1 - dx0));
}

// Function 1668
ray get_ray(in camera c, in vec2 uv, in float wavelength) {
	float theta = c.fov * 3.14/180.0;
    float h_height = tan(theta/2.0);
    float h_width = c.aspect * h_height;
    
    vec3 w = normalize(c.look_from - c.look_at);
    vec3 u = normalize(cross(c.up, w));
    vec3 v = cross(w, u);
    
    vec3 ll = c.look_from - h_width*u - h_height*v - w;
    vec3 horizontal = 2.0 * h_width*u;
    vec3 vertical = 2.0 * h_height*v;
    
    return ray(
        c.look_from, 
        normalize(ll + uv.x*horizontal + uv.y*vertical - c.look_from),
        wavelength,
        ENV_IOR
    );
}

// Function 1669
RayHit TraceTerrainReflection( vec3 origin, vec3 direction, int steps)
{
  RayHit result;
  float precis = 0.0, maxDist = 100.0, t = 0.0, dist = 0.0;
  vec3 rayPos;

  for ( int i=0; i<steps; i++ )
  {
    rayPos =origin+direction*t; 
    dist = MapTerrainSimple( rayPos);
    precis = 0.01*t;

    if (dist<precis || t>maxDist )
    {             
      result.hit=!(t>maxDist);
      result.depth = t; 
      result.dist = dist;                              
      result.hitPos = origin+((direction*t));     
      break;
    }

    t += dist*0.5;
  }

  return result;
}

// Function 1670
vec3 getNormal(in vec3 p){
	
    const vec2 e = vec2(.001, 0);
    
    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
    //map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
    
    // This mess is an attempt to speed up compiler time by contriving a break... It's 
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.;
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = 0; i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break; // Fake conditional break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 1671
vec3 getNormal(vec3 pos, float e, bool inside)
{  
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx, inside).x - map(pos - q.yxx, inside).x,
                          map(pos + q.xyx, inside).x - map(pos - q.xyx, inside).x,
                          map(pos + q.xxy, inside).x - map(pos - q.xxy, inside).x));
}

// Function 1672
void normal(in vec3 x, out vec3 n)
{
    vec2 s, na;
    scene(x,s);
    scene(x+dx*c.xyy, na);
    n.x = na.x;
    scene(x+dx*c.yxy, na);
    n.y = na.x;
    scene(x+dx*c.yyx, na);
    n.z = na.x;
    n = normalize(n-s.x);
}

// Function 1673
Ray getRay(Camera cam, vec2 uv)
{
    vec2 rd = cam.lensRadius * randomInUnitDisk(gSeed);
    vec3 offset = cam.u * rd.x + cam.v * rd.y;
    float time = cam.time0 + hash1(gSeed) * (cam.time1 - cam.time0);
    return createRay(
        cam.origin + offset,
        normalize(cam.lowerLeftCorner + uv.x * cam.horizontal + uv.y * cam.vertical - cam.origin - offset),
        time);
}

// Function 1674
float Intersect_Ray_Cube(
vec3 rp, vec3 rd, 
vec3 cp, vec3 cth, 
out vec2 t, out vec3 n0, out vec3 n1)
{	
	rp -= cp;
	
	vec3 m = 1.0 / -rd;
    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));
    //vec3 os = sign(-rd);
	vec3 o = -cth * os;
	
    
	vec3 uf = (rp + o) * m;
	vec3 ub = (rp - o) * m;
	
	//t.x = max(uf.x, max(uf.y, uf.z));
	//t.y = min(ub.x, min(ub.y, ub.z));
	
    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else 
                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}
    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}
    
    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else 
                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}
    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}
    
    
	// if(ray start == inside cube) 
	if(t.x < 0.0 && t.y > 0.0) 
    {
        t.xy = t.yx;  
        
        vec3 n00 = n0;
        n0 = n1;
        n1 = n00;
        
        return 1.0;
    }
	
	return t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);
}

// Function 1675
vec4 raymarch( in vec3 rayo, in vec3 rayd, in float expInter, in vec2 fragCoord )
{
    vec4 sum = vec4( 0.0 );
     
    float step = 0.075;
     
    // dither start pos to break up aliasing
	vec3 pos = rayo + rayd * (expInter + step*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x);
	
    for( int i=0; i<25; i++ )
    {
        if( sum.a > 0.99 ) continue;
		
		float radiusFromExpCenter = length(pos - expCenter);
		
		if( radiusFromExpCenter > expRadius+0.01 ) continue;
		
		float dens, rawDens;
		
        dens = densityFn( pos, radiusFromExpCenter, rawDens, sum.a );
		
		vec4 col = vec4( computeColour(dens,radiusFromExpCenter), dens );
		
		// uniform scale density
		col.a *= 0.6;
		
		// colour by alpha
		col.rgb *= col.a;
		
		// alpha blend in contribution
		sum = sum + col*(1.0 - sum.a);  
		
		// take larger steps through negative densities.
		// something like using the density function as a SDF.
		float stepMult = 1. + 2.5*(1.-clamp(rawDens+1.,0.,1.));
		
		// step along ray
		pos += rayd * step * stepMult;
    }
	
    return clamp( sum, 0.0, 1.0 );
}

// Function 1676
float FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)
{
        // Schlick aproximation
        float r0 = (n1-n2) / (n1+n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        if (n1 > n2)
        {
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            // Total internal reflection
            if (sinT2 > 1.0)
                return f90;
            cosX = sqrt(1.0-sinT2);
        }
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;

        // adjust reflect multiplier for object reflectivity
        return mix(f0, f90, ret);
}

// Function 1677
SRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)
{
    SRayHitInfo hitInfo;
    hitInfo.dist = c_rayMaxDist;

    // the floor
    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))
    {
        // uncomment this for a checkerboard floor
        /*
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        vec2 uv = floor(hitPos.xz / 100.0f);
        float shade = mix(0.6f, 0.2f, mod(uv.x + uv.y, 2.0f));
        hitInfo.diffuse = vec3(shade, shade, shade);
		*/
    }
    
    // some floating spheres to cast shadows
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));
    
    // back wall
    {
        vec3 scale = vec3(100.0f, 40.0f, 1.0f);
        vec3 offset = vec3(0.0f, 0.0f, 10.0f);
        vec3 A = vec3(-1.0f, 0.0f, 0.0f) * scale + offset;
        vec3 B = vec3(-1.0f, 1.0f, 0.0f) * scale + offset;
        vec3 C = vec3( 1.0f, 1.0f, 0.0f) * scale + offset;
        vec3 D = vec3( 1.0f, 0.0f, 0.0f) * scale + offset;
    	RayVsQuad(rayPos, rayDir, hitInfo, A, B, C, D, vec3(1.0f, 0.0f, 1.0f), true);
	}     
    
    return hitInfo;
}

// Function 1678
vec3 normal(in vec3 p, float ef) {
	vec2 e = vec2(.001*ef, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1679
vec3 calcNormal( in vec3 pos, float t, int j ) {
    float e = 0.005*t;
    vec2 eps = vec2( e, 0.0 );
    float h = terrain( pos.xz );
    return normalize( vec3( terrain(pos.xz-eps.xy)-h, e, terrain(pos.xz-eps.yx)-h ));
}

// Function 1680
bool refraction(vec3 v, vec3 n, float niOverNt, out vec3 refracted) {
    vec3 uv = normalize(v);
    float dt = dot(uv, n);
    float discriminant = 1.0 - niOverNt*niOverNt*(1.0-dt*dt);
    if(discriminant > 0.0) {
        refracted = niOverNt*(uv - n*dt) - n*sqrt(discriminant);
        return true;
    }else{
        return false;
    }
}

// Function 1681
vec3 CreateScreenRay(vec2 screenPos, float screenAspect)
{
    float VFOV = 80.0;
	float tanVFOV = tan(VFOV*0.5*PI/180.0); // could precompute this
    return normalize(vec3(screenPos*vec2(screenAspect, 1)*tanVFOV, 1));
}

// Function 1682
vec3 normal(vec3 pos, float e ,float time)
{
    vec3 eps = vec3(e,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy, time).dist - map(pos-eps.xyy, time).dist,
           map(pos+eps.yxy, time).dist - map(pos-eps.yxy, time).dist,
           map(pos+eps.yyx, time).dist - map(pos-eps.yyx, time).dist ) );
}

// Function 1683
vec3 raycast(vec2 puv, vec2 pos, vec2 dir)
{
	float clx = 0.0;
	vec2 aprox = vec2(0.0);
    float n = 5.0;
    float np = pow(2.0, n);
	float inp = pow(2.0, -n);
    for(float i = 0.0; i < np; ++i)
	{
		vec2 aprox = ceil(pos + dir * 2.0 *  1.41421356237 * i) * inp;
		if(aprox.x == puv.x && aprox.y == puv.y)
			clx = 0.5;
	}
	return vec3(clx, 0, 0);
}

// Function 1684
void RayTraceMountainCylinders(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, in float seed, in float radius, in float maxMountainHeight)
{
    SMaterial material;
    material.diffuse = vec3(1.0f, 1.0f, 1.0f);
    material.specular = vec3(0.0f, 0.0f, 0.0f);
    material.roughness = 0.025f;
    material.emissive = vec3(0.0f, 0.0f, 0.0f);

    SRayHitInfo oldHitInfo = hitInfo;

    if(TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, -15.0f, 0.0f), radius, maxMountainHeight, material))
    {
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        float azimuthPercent = clamp((atan(hitPos.z, hitPos.x) + c_pi) / c_twopi, 0.0f, 1.0f);
        float heightPercent = (hitPos.y + 15.0f) / maxMountainHeight;

        float thisHeightIndex = floor(azimuthPercent * 20.0f);
        float nextHeightIndex = mod(thisHeightIndex + 1.0f, 20.0f);
        float thisHeightIndexFraction = fract(azimuthPercent * 20.0f);

        float thisHeight = hash12(vec2(thisHeightIndex, seed)) * 0.75f + 0.25f;
        float nextHeight = hash12(vec2(nextHeightIndex, seed)) * 0.75f + 0.25f;

        float mountainHeight = mix(thisHeight, nextHeight, thisHeightIndexFraction);

        if (heightPercent > mountainHeight)
        {
            hitInfo = oldHitInfo;
        }
        else
        {
            vec3 brightPink = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f)) * 5.0f;
            
            float borderSize = 0.25f / maxMountainHeight;
            
            hitInfo.material.emissive = brightPink * smoothstep(mountainHeight - borderSize, mountainHeight, heightPercent);
        }
    }    
}

// Function 1685
RayIntersection CastRay(const Ray r, const float max_dst)
{
    RayIntersection o;
    o.ray         = r;
 	o.dist        = MAX_DISTANCE;
    o.shadow      = MAX_DISTANCE;
    o.shape.type  = NO_SHAPE;
    o.shape.color = vec4(NULL_PINK, 1);
    
    int i = 0;
    float travelDist = 0.0f;
    RayIntersection tmpRI;
    
    while (travelDist<max_dst && i<MAX_ITERATIONS)
    {
        i++;

		tmpRI = GetNearestShape(r.o + r.d*travelDist);
        
        travelDist += abs(tmpRI.dist);
        
        // Soft shadows
        o.shadow = min(o.shadow, SOFT_SHADOWS_C*tmpRI.dist/travelDist);
        
        if (abs(tmpRI.dist) < EPSILON) // The abs allows inner rays
        { // We collided
            o.pos   = r.o + r.d*travelDist;
            o.shape = tmpRI.shape;
            o.dist  = travelDist;
            
            if (o.shape.normal == vec4(0) || o.shape.blendType == BLEND)
            { // Avoid computing the normals of shapes that already have them,
              // or calculate them again if the shape is blended
            	o.shape.normal = vec4(ComputeNormals(o.pos), 1);
            }
            break;
        }
    }
    
    o.shadow = clamp(o.shadow, 0.,1.);
    o.numIt = i;
    return o;
}

// Function 1686
vec3 REFLECTION_RayMarch(vec3 ro, vec3 rd) {
	vec3 color = vec3(0.5);
    float st = 1.0/float(MAX_REFLECTION_STEPS);
    vec3 p = vec3(0.0);
    
    for (int i = 0; i < MAX_REFLECTION_STEPS; i++) {
    	p = ro + rd*st;
        vec4 mesh = MAP_REFLECTION_Scene(p, ro, 0);
        
        // Scene Color
        if (mesh.w <= SURFACE_DISTANCE) {
            mesh = MAP_REFLECTION_Scene(p, ro, 1);
            vec3 sceneColor = mesh.xyz;
        	
             if (st>=FOG_START) {
            	float nrmlz = st - FOG_START;
                nrmlz /= FOG_END - FOG_START;
                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));
            }
            
            color = sceneColor;
            break;
        }
        
        if (st >= MAX_RENDER_DISTANCE) {
        	break;
        }
        
        st += mesh.w;
    }
    
    // Sky(Background) Color
    if (st >= MAX_RENDER_DISTANCE) {
    	color = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));
    }
    
    return color;
}

// Function 1687
vec3 computeSurfaceNormal(vec3 p){
    float d = mapDist(p);
    return normalize(vec3(
            mapDist(vec3(p.x + EPSILON, p.y, p.z)) - d ,
            mapDist(vec3(p.x, p.y + EPSILON, p.z)) - d ,
            mapDist(vec3(p.x, p.y, p.z + EPSILON)) - d
            ));
}

// Function 1688
vec3 normal(vec3 p)
{
	vec2 e = vec2(0,.0001);
	return normalize(map(p, false).x-vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));
}

// Function 1689
vec3 calcNormalBk( in vec3 pos, in float eps )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapBk( pos + e.xyy ) + 
					  e.yyx*mapBk( pos + e.yyx ) + 
					  e.yxy*mapBk( pos + e.yxy ) + 
					  e.xxx*mapBk( pos + e.xxx ) );
#else
    // trick by klems, to prevent the compiler from inlining map() 4 times
    vec4 n = vec4(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        s[i] += eps;
        n[i] = mapBk(s.xyz);
    }
    return normalize(n.xyz-n.w);
#endif    
}

// Function 1690
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.0001, 0.0, 0.0 );
    float d = map(pos).x;
    return normalize( vec3(
	    map(pos+eps.xyy).x - d,
	    map(pos+eps.yxy).x - d,
	    map(pos+eps.yyx).x - d)
	);

}

// Function 1691
vec3 normalforCylinder(vec3 hit,Cylinder cylinder)
{
    vec3 nor;
	nor.xz = hit.xz - cylinder.c.xz;
    nor.y = 0.0;
    nor = nor/cylinder.r;
    //nor.y = 1.0*sign(hit.y-cylinder.c.y);
    return nor;
}

// Function 1692
vec3 calcNormal( in vec3 pos ){

    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,
        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,
        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );
    return normalize(nor);
}

// Function 1693
vec3 getNormal(in vec3 p) {
	
    const vec2 e = vec2(.001, 0);
    
    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
    //map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
    
    // This mess is an attempt to speed up compiler time by contriving a break... It's 
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.;
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = min(iFrame, 0); i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break; // Fake conditional break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 1694
vec3 get_normal(vec3 p)
{
    vec2 eps=vec2(0.001,0.);
    return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),
                    map(p+eps.yxy)-map(p-eps.yxy),
                    map(p+eps.yyx)-map(p-eps.yyx)));
}

// Function 1695
bool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out vec3 normal) {
    
    float	marchingDist = 39.5;
    float 	nbIter 		 = 0.0;

 	m = origin;   
    
    float lastestIntensity = -1000.;
    
    for(int i=0; i<200; i++) {
        
    	float fieldIntensity = getFieldIntensity(m, normal);
        
      if(lastestIntensity>fieldIntensity) {
            break;
        }
        
        if(fieldIntensity > THRESHOLD-0.01) {
            return true;
        }
        else {
            float delta = THRESHOLD - fieldIntensity;
            marchingDist += 0.01;//sqrt(delta)*0.5;
        	m = origin + ray * marchingDist;    
        }
    }
    
	return false;    
}

// Function 1696
vec3 ray(vec2 uv,float z){
	vec3 r = normalize(vec3(uv,z));
    r.yz *= genRot(PI / 4.);
    r.xy *= genRot(PI/4.-iTime / 2.);
	return r;
}

// Function 1697
vec3 calculateNormal(vec3 p)
{
    float normalEpsilon = 0.0001;
    vec3 eps = vec3(normalEpsilon,0,0);
    vec3 normal = vec3( map(p + eps.xyy).x - map(p - eps.xyy).x,
                       	map(p + eps.yxy).x - map(p - eps.yxy).x,
                       	map(p + eps.yyx).x - map(p - eps.yyx).x
                       );
    return normalize(normal);
}

// Function 1698
vec3 calcNormal( in vec3 pos, float t ){
    vec2  eps = vec2( 0.002*t, 0.0 );
    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),
                            2.0*eps.x,
                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );
}

// Function 1699
vec3 calcNormal( in vec3 pos, in float ep )
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + 
					  e.yyx*map( pos + e.yyx*ep, kk, false ) + 
					  e.yxy*map( pos + e.yxy*ep, kk, false ) + 
					  e.xxx*map( pos + e.xxx*ep, kk, false ) );
}

// Function 1700
vec3 SurfaceNormal(in vec3 pos)
{
    vec3 eps = vec3( MIN_DIST, 0., 0. );
    return normalize(-vec3(Ring(pos + eps.xyy) - Ring(pos - eps.xyy),
                           Ring(pos + eps.yxy) - Ring(pos - eps.yxy),
                           Ring(pos + eps.yyx) - Ring(pos - eps.yyx)));
}

// Function 1701
bool ray_marching( vec3 o, vec3 dir, inout float depth, inout vec3 n ) {
	float t = 0.0;
    float d = 10000.0;
    float dt = 0.0;
    for ( int i = 0; i < 128; i++ ) {
        vec3 v = o + dir * t;
        d = dist_field( v );
        if ( d < 0.001 ) {
            break;
        }
        dt = min( abs(d), 0.1 );
        t += dt;
        if ( t > depth ) {
            break;
        }
    }
    
    if ( d >= 0.001 ) {
        return false;
    }
    
    t -= dt;
    for ( int i = 0; i < 4; i++ ) {
        dt *= 0.5;
        
        vec3 v = o + dir * ( t + dt );
        if ( dist_field( v ) >= 0.001 ) {
            t += dt;
        }
    }
    
    depth = t;
    n = normalize( gradient( o + dir * t ) );
    return true;
    
    return true;
}

// Function 1702
vec3 GetNormal(in vec3 hit_pos, in float delta)
{
	vec3 pre_p = hit_pos - vec3(0,0,delta);
	vec3 p = hit_pos + vec3(0,0,delta);
	
	vec3 t, l, r, b;
	t = l = r = b =  hit_pos + vec3(0.0,0.0, 10000.0);//hit very far away
	vec3 eps = vec3(M_EPSILON, 0.0, 0.0);
	t += eps.yxy;
	l -= eps.xyy;
	r += eps.xyy;
	b -= eps.yxy;
	
	Hit(p + eps.yxy , pre_p + eps.yxy, t);
	Hit(p -eps.xyy , pre_p -eps.xyy, l);
	Hit(p + eps.xyy , pre_p + eps.xyy, r);
	Hit(p -eps.yxy , pre_p -eps.yxy, b);

	return normalize(cross(r-l, t-b));
}

// Function 1703
void TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in vec4 apple)
{
    vec3 reverseLightDir = normalize(vec3(-1.0,3.0,-1.0));
    const vec3 lightColor = vec3(0.5,0.5,0.5);	
    const vec3 ambientColor = vec3(0.2,0.2,0.2); 
    
	vec3 normal = vec3(0.0);            
    vec3 diffuseColor;
    float shinyness = 0.0;
    float maxRayHitTime = 1000.0;
    bool hit = false;
    vec3 hitPos = vec3(0.0);
    
    //----- Ray vs snake
    if (RayIntersectSnakeBody(rayPos, rayDir, normal, hitPos, maxRayHitTime, diffuseColor, shinyness))
        hit = true;
    
	//----- Ray vs game board
    if (RayIntersectAABoxNormal(vec3(-1.0,-0.2,-1.0), vec3(1.0,0.0,1.0), rayPos, rayDir, hitPos, normal, maxRayHitTime))
    {
        hit = true;
        // wooden game board framing
        if (hitPos.x > 0.98 || hitPos.x < -0.98 || hitPos.z > 0.98 || hitPos.z < -0.98 || hitPos.y < -0.01)
        {       
            if (abs(normal.x) > 0.1)
                diffuseColor = texture(iChannel1, hitPos.yz).rgb;
            else if(abs(normal.y) > 0.1)
                diffuseColor = texture(iChannel1, hitPos.xz).rgb;
            else
                diffuseColor = texture(iChannel1, hitPos.xy).rgb;
            shinyness = diffuseColor.r * 0.25;
        }
        // tiled game board
        else
        {
            bool tileIsWhite = mod(floor(hitPos.x * c_quarterGridSize) + floor(hitPos.z * c_quarterGridSize), 2.0) < 1.0;
            vec3 textureSample = texture(iChannel2, hitPos.xz*0.25).rgb;       
            shinyness = (tileIsWhite ? 1.0 : 0.5) * textureSample.r;
            diffuseColor = mix(vec3(tileIsWhite ? 1.0 : 0.4), textureSample, 0.33);        
        }
    }
	
    if (!hit)
		return;
    
    // directional light diffuse
    pixelColor = diffuseColor * ambientColor;
    float dp = dot(normal, reverseLightDir);
	if(dp > 0.0)
		pixelColor += (diffuseColor * dp * lightColor);    
    
    // directional light specular    
    vec3 reflection = reflect(reverseLightDir, normal);
    dp = dot(rayDir, reflection);
    if (dp > 0.0)
        pixelColor += pow(dp, 15.0) * 0.5 * shinyness;	
    
    // reflection (environment mappping)
    reflection = reflect(rayDir, normal);
    pixelColor += texture(iChannel3, reflection).rgb * 0.5 * shinyness;
    
    // handle point light at apple
    if (apple.z == 1.0)
    {
        const vec3 appleLightColor = vec3(5.0,0.0,0.0);
        vec2 appleGrid = floor(clamp(apple.xy * c_maxGridCell, 0.0, c_maxGridCell));
        float offsetY = sin(iTime*5.0) * c_radius / 3.0;
        vec3 applePos;
        applePos.x = (appleGrid.x-c_halfGridSize)/c_halfGridSize + c_radius;
        applePos.y = c_radius + offsetY;
        applePos.z = (appleGrid.y-c_halfGridSize)/c_halfGridSize + c_radius;
        
        float dist = length(applePos - hitPos);
        float distFactor = 1.0 - clamp(dist / 1.0, 0.0, 1.0);
        distFactor = pow(distFactor, 5.0);
        
		// diffuse
		vec3 hitToLight = normalize(applePos - hitPos);
		float dp = dot(normal, hitToLight);
		if(dp > 0.0)
			pixelColor += diffuseColor * dp * appleLightColor * distFactor;
			
		// specular
		vec3 reflection = reflect(hitToLight, normal);
		dp = dot(rayDir, reflection);
		if (dp > 0.0)
			pixelColor += pow(dp, 15.0) * appleLightColor * shinyness * distFactor;
    }    
}

// Function 1704
vec3 hyperNormalizeG(vec3 v) {
    return v / sqrt(hyperDot(v, v));
}

// Function 1705
vec3 map_box_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return reflect(rd, nrm);
}

// Function 1706
float rayf(float t) {
    t = t - RO;
    poly2 f = pa_map(ro, rd, t);
    return f.a[0];
}

// Function 1707
float rayPlane(vec3 ro, vec3 rd, vec4 p ) {
  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);
}

// Function 1708
vec3 calcNormal(vec3 p) {
  vec2 e = vec2(0.0001, 0.0);
  return normalize(vec3(
    map(p + e.xyy) - map(p - e.xyy),
    map(p + e.yxy) - map(p - e.yxy),
    map(p + e.yyx) - map(p - e.yyx)));
}

// Function 1709
vec4 RayMarch(vec3 coord, vec3 rayVector)
{
	vec3 marchCoord = coord;
	
	for (float t = 0.0; t < MAX_T; t++)
	{
		float dist = DELT * pow(t, LOD);
		marchCoord += rayVector * dist;
		
		if (InFloor(marchCoord))
		{
			float fog = (MAX_T - t) / MAX_T;
			return fog * FloorColor(marchCoord);
		}
	}
	
	return BackgroundColor();
}

// Function 1710
bool try_reflect(inout vec2 p, Ball B, inout int count, inout float scale) {
    vec2 cen = B.cen;
    float r = B.r;
    if (B.isplane) {
        float k = dot(vec3(p, 1), vec3(cen, r));
        if (k >= 0.)
            return true;
        p -= 2. * k  * cen;
        count += 1;
        return false;
    }
    else {
        vec2 q = p - cen;
        float d2 = dot(q, q);
        float k = (r * r) / d2;
        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )
            return true;
        p = k * q + cen;
        scale *= k;
        count += 1;
        return false;
    }
}

// Function 1711
vec3 normal(vec3 p){
   vec2 eps = vec2(0.001,0.);
   return normalize(
           vec3(
           map(p-eps.xyy) - map(p+eps.xyy), 
           map(p-eps.yxy) - map(p+eps.yxy),
           map(p-eps.yyx) - map(p+eps.yyx))
           );
}

// Function 1712
vec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {
		
		float depth = start;
		vec3 salida = vec3(end);
		vec3 dist = vec3(2800.0);
		
		for ( int i = 0; i < max_iterations; i++ ) 		{
			if ( dist.x < stop_threshold || depth > end ) break;
                dist = map( origin + dir * depth );
                depth += dist.x;
				dist.y = float(i);
		}
		
		salida = vec3(depth, dist.y, dist.z);
		return salida;
	}

// Function 1713
vec3 calcNormalmapWater( in vec3 pos, in float ep )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*mapWater(pos+e.xyy*ep) + 
					 e.yyx*mapWater(pos+e.yyx*ep) + 
					 e.yxy*mapWater(pos+e.yxy*ep) + 
					 e.xxx*mapWater(pos+e.xxx*ep) );
}

// Function 1714
float raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {
    // - r0: ray origin
    // - rd: normalized ray direction
    // - s0: sphere center
    // - sr: sphere radius
    // - Returns distance from r0 to first intersecion with sphere,
    //   or -1.0 if no intersection.
    float a = dot(rd, rd);
    vec3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
    if (b*b - 4.0*a*c < 0.0) {
        return -1.0;
    }
    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);
}

// Function 1715
vec4 RayMarch(in Ray ray)
{
    float depth   = NearClip;
    float nearest = FarClip;          // Keeps track of nearest pass for SDF Near-Miss outline
    float edge    = 0.0;              // Keeps track of if edge for SDF Edge outline
    float lastSDF = FarClip;          // Keeps track of last SDF value for SDF Edge outline
    
    for(int i = 0; i < MaxSteps; ++i)
    {
    	vec3 pos = ray.o + (ray.d * depth);
        vec2 sdf = Scene(pos);
        
        nearest = min(sdf.x, nearest);
        
        if((lastSDF < EdgeThresold) && (sdf.x > lastSDF))
        {
            edge = 1.0;
        }
        
        if(sdf.x < Epsilon)
        {
            return vec4(clamp(depth, NearClip, FarClip), nearest, edge, sdf.y);
        }
        
        depth  += sdf.x * 0.35;        // Note: Modifying the '* 0.35' affects the outlines in subtle ways.
        lastSDF = sdf.x;
    }
    
    return vec4(FarClip, nearest, edge, 0.0);
}

// Function 1716
vec3 raycast( in vec3 ro, vec3 rd )
{
    float t = 2.5;
    float dt = .035;
    vec3 col= vec3(0.);
    for( int i=0; i<100; i++ )
	{                
        vec2 v = field(ro+t*rd);  
        float c=v.x, f=v.y;
        t+=dt*f;
        dt *= 1.03;
        col = .95*col+ .09*vec3(c*c*c, c*c, c);	
    }
    
    return col;
}

// Function 1717
Ray GetCameraRay(int frame, vec2 uv, vec2 mouse)
{   
    // Problem of doing it this way is that it will be slow on fullscreen, but I want easy reproj stability
    float time = float(frame) / 60.0;
    vec3 target = vec3(0.0, .55, 0.0);
    vec3 p = vec3(-3.56402609672, -1.25, 1.81596199896);
    
    // Simple animation
    float introMask = smoothstep(45.0, 0.0, time);    
    p += vec3(-1.0, -.7, 1.0) * introMask;
    p += vec3(9.0, -1.5, 15.0) * smoothstep(25.0, -10.0, time);
    target.y -= 10.0 * smoothstep(35.0, 0.0, time);
    
#ifdef ENABLE_CONTROLS
    target.y += mouse.y * 3.5 - 1.25;
#endif
    
    vec3 forward = normalize(target - p);
    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up = cross(forward, left);
    
    float zoom = .635;
#ifdef ENABLE_CONTROLS
    zoom = clamp(.5 - mouse.x * .9, 0.01, 1.0);
#endif
    
    float castleTime = time * .03;
#ifndef ANIMATE_SCENE
    castleTime = 0.0;
#endif
    
    p += vec3(cos(castleTime*4.0), sin(castleTime*2.0), cos(castleTime * 7.0)) * .1;
    pR(p.xy, cos(castleTime * 15.0) * .01);
    pR(p.yz, sin((castleTime + PI) * 7.0) * .01);
 
    Ray ray;
    ray.origin = p + vec3(0.0, 0.5, 0.0);
    ray.direction = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);
    ray.forward = forward;
    
    return ray;
}

// Function 1718
vec3 normal(vec3 rp, out float edge) {
    
    vec2 e = vec2(EPS, 0.0);
	float d1 = map(rp + e.xyy).x;
    float d2 = map(rp - e.xyy).x;
	float d3 = map(rp + e.yxy).x;
    float d4 = map(rp - e.yxy).x;
	float d5 = map(rp + e.yyx).x;
    float d6 = map(rp - e.yyx).x;
	float d = map(rp).x * 2.0;

    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how
    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum
    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface 
    // curves that register a discernible difference.
    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    
    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.
    
    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you 
    // do that is up to you. This is what I came up with for now, but I might tweak it later.
    edge = smoothstep(0.0, 1.0, sqrt(edge / e.x * 2.0));
    
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 1719
vec3 PointFromRay(Ray r, float t)
{
	return r.pos + t * r.dir;
}

// Function 1720
vec3 calcNormal(vec3 p, float t) {
    const float sceneAdjust = 0.23;
    float d = 0.009 * t * sceneAdjust;
    vec2 e = vec2(0.9, -0.9) * 0.4773 * d;
    return normalize(e.xyy * map(p + e.xyy).d + 
					 e.yyx * map(p + e.yyx).d + 
					 e.yxy * map(p + e.yxy).d + 
					 e.xxx * map(p + e.xxx).d);
}

// Function 1721
float rgbToGray(vec4 rgba) {
	const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    return dot(rgba.xyz, W);
}

// Function 1722
Ray getCameraRay(vec2 uv, float t)
{
    uv *= (CAMERA_FOV / 360.) * PI; // fov
    vec3 origin = vec3(0., CAMERA_HEIGHT, CAMERA_DEPTH);
    vec3 target = vec3(0., origin.y + CAMERA_PITCH,  CAMERA_DEPTH - 1.2);
    mat3 camera = getCameraMatrix(origin, target);
    vec3 direction = normalize(camera * vec3(uv, CAMERA_ZOOM));
    return Ray(origin, direction);
}

// Function 1723
vec3 calcNormal( in vec3 p ) {
    vec2 e = vec2( 0.0001, 0.0 );
    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),
                            map( p + e.yxy ) - map( p - e.yxy ),
                            map( p + e.yyx ) - map( p - e.yyx ) ) );
}

// Function 1724
float raymarch(vec3 ray_origin, vec3 ray_direction) {
	float d = 0.0;
	
	for (int i = 0; i < max_steps; i++) {
		vec3 new_point = ray_origin + ray_direction*d;
		float s = get_distance(new_point);
		if (s < epsilon) return d;
		d += s;
		if (d > max_distance) return max_distance;
	}
	return max_distance;
}

// Function 1725
float godray(vec2 uv)
{
    //get the screen space coordinates of the light vector
     vec2 mse =iMouse.xy/iResolution.x-vec2(.5,.5+(iResolution.y-iResolution.x)/(2.*iResolution.x));
    mse*=8.*vec2(-1,1)/*part of the fix*/;
    if(iMouse.xy==vec2(0))
        mse=vec2(-2.5,.3);
    mat3 iroty = mat3(1,0,0,0,cos(mse.y),-sin(mse.y),0,sin(mse.y),cos(mse.y));
	mat3 irotx = mat3(cos(mse.x),0,-sin(mse.x),0,1,0,sin(mse.x),0,cos(mse.x));
    mat3 ir =irotx*iroty;    
    vec3 ld = normalize(vec3(-1.,.5,-.5));
    ld=(ir*(ld*vec3(1,1,-1)).zyx);
    
    
    //the actual godrays code
    if(ld.z>0.)
    {
    vec2 o = ld.xy/ld.z;//project the ligt vector on the screen
    o=(o*iResolution.y+iResolution.xy)*.5/iResolution.xy; //
        float s = 0.;
        float d0 =texture(iChannel0,uv).a; //sampled depth
    for (int i = 0; i < Samples; i++)  
  	{  
    	vec2 c = mix(uv, o, (float(i)+rand(uv)) / float(Samples-1)); //a kind of "ray marching"
   	   
        if(texture(iChannel0,c).a>=FAR)s+=1./float(Samples); //if the "ray position" is not occluded, increment

  	}  
    return s;
    }
    return 1.;
}

// Function 1726
RayHit rayVsSphere(in Ray ray, in Sphere sphere){
    RayHit defaultResult = RayHit(fogColor, -ray.dir, maxDistance);
    
    //pythogorean solution
    vec4 sphereDiff = sphere.pos - ray.start;
    float sphereDist = dot(sphereDiff, ray.dir);
    float spherePerpDist = sqrt(dot(sphereDiff, sphereDiff) - sphereDist * sphereDist);
    
    float dt2 = sphere.radius * sphere.radius - spherePerpDist * spherePerpDist;
    float dt = sqrt(dt2);
    
    float t = sphereDist - dt;//no need for t2, as we haven no refractions
    vec4 hitPos = ray.start + ray.dir * t;
    vec4 sphereNormal = clamp(normalize(hitPos - sphere.pos), -1.0, 1.0);
    RayHit sphereHit = RayHit(
        sphere.color,
        //sphereNormal.xyz * 0.5 + 0.5,
        //clamp(sphereNormal.xyz * 0.5 + 0.5, 0.0, 1.0),
        sphereNormal,
        t
    );
    //sphereHit.color = sphereHit.n.xyz * 0.5 + 0.5;
    return mixRayHits(
        defaultResult, sphereHit, float((spherePerpDist < sphere.radius) && (t > 0.0))
    );
    
    
    //return result;
}

// Function 1727
vec3 calcNormal( vec3 pos )
{
    // computes planet in sector
    planet p;
    vec3 sector = floor(pos);
    GetPlanet(sector, p);
    
    // return vector 
    return normalize(pos - (sector + p.center));
}

// Function 1728
float rayBox(in vec3 ro){
    
    vec3 p = 1./svRd;
    p = abs(p)*1.01 - p*ro;
	return min(min(p.x, p.y), p.z);
}

// Function 1729
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 150; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.25, 0.4 * h) + 0.005 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 8; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      h = step (0., p.y - GrndHt (p.xz));
      sLo += h * (s - sLo);
      sHi += (1. - h) * (s - sHi);
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 1730
vec3 calcNormal( in vec3 pos ) {
    const float eps = 0.1;

    // AN ORTHOGONAL 4X3 MATRIX USED FOR THE MATHS BELOW
    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

    // IF THERE WERE ONLY ONE SPHERE IN THE MIDDLE, YOU COULD GET THE NORMALS BY MERELY
    // NORMALIZING THE POSITION. HOWEVER, WHEN THERE IS MORE THAN ONE SPHERE, YOU
    // GET THE NORMALS BY NORMALIZING THE POSITION RELATIVE TO THE POSITION OF THE CENTER
    // OF EACH SPHERE. THE "MAKE SCENE" FUNCTION DOES JUST THAT.
	return normalize( v1 * makeScene( pos + v1 * eps ) + 
					  v2 * makeScene( pos + v2 * eps ) + 
					  v3 * makeScene( pos + v3 * eps ) + 
					  v4 * makeScene( pos + v4 * eps ) );

}

// Function 1731
vec3 ComputeReflection(inout Ray r, const float g)
{
    RayIntersection ri = CastRay(r, MAX_REFLECTION_DIST);
    
    r = ri.ray;
    
    vec4 o = vec4(BLACK,1);
    DoTheLighting(ri, o);
    
    return mix(BLACK, o.rgb, g).rgb * REFLECTION_INTENSITY * g;
}

// Function 1732
float raymarch(vec3 ori, vec3 dir) {
 
    float t = 0.;
    for(int i = 0; i < MAX_ITERATIONS; i++) {
    	vec3  p = ori + dir * t;
        float d = dstScene(p);
        if(d < EPSILON || t > MAX_DISTANCE) {
            break;
        }
        t += d * .75;
    }
    return t;
    
}

// Function 1733
vec3 GetNormal(vec3 point)
{
    vec2 e = vec2(0.0, 0.001);
    return normalize(MapScene(point).x - vec3(
        MapScene(point - e.yxx).x,
        MapScene(point - e.xyx).x,
        MapScene(point - e.xxy).x
    ));
}

// Function 1734
vec4 raymarch(vec2 resolution, vec2 uv, vec4 start_data, mat4 camera_transform) {
    // Convert to range (-1, 1) and correct aspect ratio
    vec2 screen_coords = (uv - 0.5) * 2.0;
    screen_coords.x *= resolution.x / resolution.y;
    
    
    vec3 ray_start_position = camera_transform[3].xyz;
    
    vec3 ray_direction = normalize(vec3(screen_coords * LENS, 1.0));
    ray_direction = (camera_transform * vec4(ray_direction, 0.0)).xyz;
    
    
    float dist = start_data.a * 0.9;
    vec3 sample_point = ray_start_position + dist * ray_direction;
    
    float results = sample_world(sample_point);
    
    float tolerance = 0.0;
    
    for (int i=0; i<steps; i += 1) {
        dist += results;
        sample_point += ray_direction * results;
        results = sample_world(sample_point);
        
        // TODO: Derive from resolution, camera lens and distance
    	tolerance = LENS / resolution.x * dist;
        
        if (results < tolerance || dist > 5.0) {
        	break; 
        }
    }
    
    
    
    return vec4(sample_point, dist);
}

// Function 1735
vec3 getnaejangnormal (vec2 uv, float time)
{
    vec3 normal;
    vec2 smol = vec2(0.00001, 0.0);
    vec3 uv3D = vec3(uv, 0.0);
    
    // calculate normal via central whatever method
    normal.x = (samplenaejang(uv3D - smol.xyy, time) - samplenaejang(uv3D + smol.xyy, time));
    normal.y = (samplenaejang(uv3D - smol.yxy, time) - samplenaejang(uv3D + smol.yxy, time));
    normal.z = 2.0 * smol.x;
    return normalize(normal);
}

// Function 1736
float RayPlane(vec3 ro, vec3 rd, vec3 n, float d) {
	return (d-dot(ro, n)) / dot(rd, n);
}

// Function 1737
vec3 NormalBlend_Overlay(vec3 n1, vec3 n2)
{
    vec3 n;
    n.x = overlay(n1.x, n2.x);
    n.y = overlay(n1.y, n2.y);
    n.z = overlay(n1.z, n2.z);

    return normalize(n*2.0 - 1.0);
}

// Function 1738
mat3 createCameraYPR(float cameraYaw, float cameraPitch, float cameraRoll )
{
    vec3 forward = -normalize(vec3(sin(cameraYaw), sin(cameraPitch), cos(cameraYaw)));
	vec3 up = vec3(0.0, 1.0, 0.0);
	vec3 cameraRight = normalize( cross(forward, up) );
	vec3 cameraUp = normalize( cross(cameraRight, forward) );
    return rotationMatrix(forward, cameraRoll) * mat3( cameraRight, cameraUp, forward);
}

// Function 1739
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.002,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 1740
Intersection rayPlaneIntersection(in Ray ray, in Plane plane)
{
	Intersection i;
	i.hit = false;
	
	float dotProduct = dot(ray.direction, plane.normal);
	if (dotProduct == 0.0)
	{
		return i;
	}
	
	float distanceToHit = dot(plane.point - ray.origin, plane.normal)/dotProduct;
	if (distanceToHit < 0.0)
	{
		return i;
	}
	i.position = ray.origin + (ray.direction * distanceToHit);
	i.normal = plane.normal;
	i.material = plane.material;
	i.hit = true;
	return i;
}

// Function 1741
vec4 castRay(in vec2 fragCoord) {
	vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;
    vec3 ray_orig = vec3(0.0, 0.5, -5.0);
	vec3 ray_dir = normalize(vec3(uv, 5.0));
    
    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;
    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));
    float ct = sin(wiggle);
    float st = cos(wiggle);
    mat3 twist = mat3(ct, 0.0, st,
                      0.0, 1.0, 0.0,
                      -st, 0.0, ct);
    ray_dir = twist * ray_dir;
    ray_orig = twist * ray_orig;
    
    float d = cast_to_vehicle(ray_orig, ray_dir);
    
    if (d < MAX_DIST) {
        vec3 pt = ray_orig + d * ray_dir;
        ray_dir = get_bounce(pt, ray_dir);
    }

    return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);
}

// Function 1742
void intersectRayHyperPlaneRange (in Ray4 _ray, in HyperPlane _plane, in Object _object, inout Ray4Result _rayResFront, inout Ray4Result _rayResRear )
{
    Ray4Result curr;
    intersectRayHyperPlane ( _ray, _plane, _object, curr );
    
    if ( dot(_ray.m_dir,_plane.m_normal) > 0.0 )
    {
        minRay4Result ( _rayResRear, curr );
    }
    else
    {
        maxRay4Result ( _rayResFront, curr );
    }
}

// Function 1743
Hit rayCast(Ray r)
{
    vec4 s[3];
    s[0]=sphere0;
    s[1]=sphere1;
    s[2]=sphere2;
    vec3 cpos=vec3(0,4,-2);
    vec3 csiz=vec3(9,8,12);
    vec3 lpos=vec3(0,8.07,3);
    vec3 lsiz=vec3(4.,.2,1.);
    float d[ObjCount];
    bool isIn[ObjCount];
    d[s1id]=isphere(r,s[0]);
    d[s2id]=isphere(r,s[1]);
    d[s3id]=isphere(r,s[2]);
    d[cid]=icube(r,cpos,csiz,isIn[cid]);
    d[lid]=icube(r,lpos,lsiz,isIn[lid]);
    Hit h=getAHit();
    for(int i=0;i<ObjCount;i++)
        if(d[i]<h.dis)
        {
            h.id=i;
            h.dis=d[i];
        }
    h.pos=r.o+r.d*h.dis;
    h.isIn=isIn[h.id];
    //set info
    if(h.id>=0)
    {
        if(h.id>=s1id)
        {
            h.nml=(h.pos-s[h.id-2].xyz)/s[h.id-2].w;
            if(h.id==s1id)
            {
                h.mat.albedo=vec3(.7,.3,.3);
                h.mat.emission=vec3(0);
                h.mat.specularPercent=.5;
                h.mat.roughness=.4;
                h.mat.specularCol=vec3(.3,.3,.7);
            }
            else if(h.id==s2id)
            {
                h.mat.albedo=vec3(.2,.5,.4)*1.6;
                h.mat.emission=vec3(0);
                h.mat.specularPercent=.9;
                h.mat.roughness=.1;
                h.mat.specularCol=vec3(.3,.5,.4);
            }
            else if(h.id==s3id)
            {
                h.mat.albedo=vec3(.5,.5,.1);
                h.mat.emission=vec3(0.);
                h.mat.specularPercent=.1;
                h.mat.roughness=.8;
                h.mat.specularCol=vec3(.4,.9,.1);
            }
            
        }   
        else if(h.id==cid||h.id==lid)
        {
            vec3 cp=h.pos-cpos;
            h.nml=normalize(pit(csiz/2.-1e-6,cp)*sign(cp));
            if(h.isIn)
                h.nml=-h.nml;
            vec3 lrWallPass=vec3(step(.5,h.nml.x),step(.5,-h.nml.x),0);
            lrWallPass=mix(vec3(1.),lrWallPass,step(.5,abs(h.nml.x)));
            h.mat.albedo=vec3(.6)*lrWallPass;
            h.mat.emission=vec3(0.);
            h.mat.specularPercent=.1;
            h.mat.roughness=.4;
            h.mat.specularCol=vec3(.6)*lrWallPass;
            if(h.id==lid)
            {
                h.mat.albedo=vec3(0.6);
                h.mat.emission=vec3(1,.9,.8)*10.;
            }
        }  
    }
    
    return h;
}

// Function 1744
vec3 getRefractedColor(vec3 ori, vec3 dir, vec3 n, vec3 p, vec2 c, float eta) {
    vec3 rdir = refract(dir,n,eta);
    ori = p + rdir * advance(p,rdir,0.0);   

    vec3 cr_p, cr_n;
    vec2 cr_cell;
    vec3 cell_origin = vec3((c+0.5),0.0).xzy;           
    vec3 st_res = marchCrystal(ori,-rdir,vec2(0.0,1.5),cell_origin,c,cr_p);
    cr_n = getCrystalNormal(cr_p - cell_origin, c, st_res.x);                               
    
    //vec3 refl_dir = reflect(rdir,-cr_n);    
    rdir = refract(rdir,-cr_n,eta);
    //float fresnel = pow(1.0 - max(dot(cr_n,rdir),0.0), 5.0);
    ori = cr_p + rdir * advance(cr_p,rdir,0.0);

    vec3 cr_ti = trace(ori,rdir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);
    vec3 color = getBlockColor(cr_p, cr_n, cr_cell);
    
    // internal reflection    
    /*ori = cr_p + rdir * advance(cr_p,rdir,0.0);
    cr_ti = trace(ori,refl_dir,vec2(0.0),NUM_REFR_ITER, cr_p,cr_n,cr_cell);
    vec3 refl_color = getBlockColor(cr_p, cr_n, cr_cell);        
    color = mix(color,refl_color,fresnel);*/
    
    color = addFog(color,rdir,cr_ti);

    return color;
}

// Function 1745
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = -0.98 * ro.y / rd.y;
  for (int j = VAR_ZERO; j < 100; j ++) {
    p = ro + dHit * rd;
    d = p.y + 0.01 * step (GrndHt (p.xz), -0.01);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1746
vec3 calcNormal( vec3 pos, vec3 ray, float t,  in bool tree, in bool landscape) {
  //  vec2 e = vec2(eps.x, -eps.x); 
  //  return normalize(e.xyy * map(pos + e.xyy).x + e.yyx * map(pos + e.yyx).x + e.yxy * map(pos + e.yxy).x + e.xxx * map(pos + e.xxx).x);;

	float pitch = .2 * t / iResolution.x;
    
//#ifdef FAST
//	// don't sample smaller than the interpolation errors in Noise()
	pitch = max( pitch, .005 );
//#endif
	
	vec2 d = vec2(-1,1) * pitch;

	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 =  map0(p0, tree, landscape);
    float f1 = map0(p1, tree, landscape);
	float f2 = map0(p2, tree, landscape);
	float f3 = map0(p3, tree, landscape);
	
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);
	//return normalize(grad);	// prevent normals pointing away from camera (caused by precision errors)
	return normalize(grad - max(.0,dot (grad,ray ))*ray);
}

// Function 1747
float gray(sampler2D channel, vec2 uv)
{
    vec3 tex = textureGamma(channel, uv);
    return (tex.x + tex.y + tex.z) / 3.0;
}

// Function 1748
vec3 calcNormal( in vec3 pos )
{
#if 1
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
#endif    
}

// Function 1749
vec4 castRay(in vec2 fragCoord) {
	vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;
    vec3 ray_orig = vec3(0.0, 0.5, -5.0);
	vec3 ray_dir = normalize(vec3(uv, 5.0));
    
    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;
    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));
    float ct = sin(wiggle);
    float st = cos(wiggle);
    mat3 twist = mat3(ct, 0.0, st,
                      0.0, 1.0, 0.0,
                      -st, 0.0, ct);
    ray_dir = twist * ray_dir;
    ray_orig = twist * ray_orig;
    
    float d = cast_to_vehicle(ray_orig, ray_dir);
    
    if (d < MAX_DIST) {
        vec3 pt = ray_orig + d * ray_dir;
        ray_dir = get_bounce(pt, ray_dir);
        // ray_dir = transpose(twist) * ray_dir;
        vec3 offset_ray_dir = normalize(ray_dir - 0.1 * normalize(vehicle_sdf_grad(pt)));
        float e = eyeness(pt);
        const vec4 color = vec4(0.5, 0.8, 0.9, 1.0);
        vec4 eye_color = vec4(0.6 + 0.4 * ray_dir, 1.0);
        eye_color.rgb = eye_color.bgr;
        return mix(color * 0.5 * (fake_cubemap_blur(ray_dir) + fake_cubemap_blur(offset_ray_dir)),
                   eye_color * fake_cubemap(ray_dir), e);
    }

    // ray_dir = transpose(twist) * ray_dir;
    return fake_cubemap(ray_dir);
}

// Function 1750
float rayMarch( in vec3 ro, in vec3 rd, float tmax )
{
    float t = 0.0;
    
    // bounding plane
    float h = (1.0-ro.y)/rd.y;
    if( h>0.0 ) t=h;

    // raymarch
    for( int i=0; i<20; i++ )    
    {        
        vec3 pos = ro + t*rd;
        float h = map( pos );
        if( h<0.001 || t>tmax ) break;
        t += h;
    }
    return t;    
}

// Function 1751
void RayPlane(float3 tp0, float3 dp1, float3 dp2, float3 rp0, float3 rd, out float t, out float3 uv, out float3 n)
{
	float3 dp0=rp0-tp0;

	float3 dett =cross(dp1,dp2);
	float3 detuv=cross(dp0,rd);

	float det=(-1.0)/dot(dett,rd);

	float u=(dot(detuv,dp2))*det;
	float v=(dot(detuv,dp1))*det;
	t=(dot(dett ,dp0))*det;
	if(t<0.0)
	{
		t=MAX_RAY_LENGTH;
		return;
	}
	
	uv=float3(u,v,0.0);
	n=normalize(dett);
}

// Function 1752
vec3 RandomizeNormal( vec3 normal, vec3 seed, float amount )
{
    return normalize( normal + RandomPointInSphere( seed ) * amount );
}

// Function 1753
void RayLaunchDiagram( inout vec3 o, vec2 uv )
{
    float size = iResolution.y*.2; // don't scale uv, it will break the anti aliasing
    
    if ( abs(uv.x) > 2.*size || abs(uv.y) > .9*size ) return;
    
    vec3 eye = vec3(0,0,-2);
    vec3 frame = vec3(1,.6,0);
    
    // isometric projection to 2D
    vec3 i = vec3(1,0,0)*size;
    vec3 j = vec3(0,1,0)*size;
    vec2 a = vec2(.125,1./12.)*6.28*smoothstep(vec2(-.5),vec2(.5,.2),vec2(sin(iTime/2.)));
    Rotate( i, a );
    Rotate( j, a );
    
    vec2 pe = vec2(dot(i,eye),dot(j,eye));
    vec2 pf0 = vec2(dot(i,frame),dot(j,frame));
    vec2 pf1 = vec2(dot(i,frame*vec3(-1,1,0)),dot(j,frame*vec3(-1,1,0)));
    vec2 pf2 = vec2(dot(i,frame*vec3(1,-1,0)),dot(j,frame*vec3(1,-1,0)));
    vec2 pf3 = vec2(dot(i,frame*vec3(-1,-1,0)),dot(j,frame*vec3(-1,-1,0)));
    
    // screen edges
    Line( o, pf0, pf1, size*.02, vec3(.8), uv );
    Line( o, pf3, pf1, size*.02, vec3(.8), uv );
    Line( o, pf3, pf2, size*.02, vec3(.8), uv );
    Line( o, pf0, pf2, size*.02, vec3(.8), uv );
    
    // rays firing through screen
    vec3 ray = vec3(Hash(uint(iTime/1.)),2.*fract(iTime/1.));
    vec2 p = mix(mix(pf3,pf2,ray.x),mix(pf1,pf0,ray.x),ray.y);
    Circle( o, p, size*.02, vec3(1), uv );
    Line( o, mix(pe,p,ray.z), mix(pe,p,ray.z+.1), size*.01, vec3(1), uv );
    
    // frustum
    Line( o, pe, pf0, size*.01, vec3(.8), uv );
    Line( o, pe, pf1, size*.01, vec3(.8), uv );
    Line( o, pe, pf2, size*.01, vec3(.8), uv );
    Line( o, pe, pf3, size*.01, vec3(.8), uv );
    
    
    // [would be nice to show rays hitting something and colour appearing on screen
}

// Function 1754
vec3 computeNormal(vec3 pos)
{
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),
                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),
                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));
}

// Function 1755
float castRayx(vec3 ro,vec3 rd) 
{
    float function_sign=(map(ro)<0.)?-1.:1.;
    float precis=.0001;
    float h=precis*2.;
    float t=0.;
	for(int i=0;i<120;i++) 
	{
        if(abs(h)<precis||t>12.)break;
		h=function_sign*map(ro+rd*t);
        t+=h;
	}
    return t;
}

// Function 1756
vec3 getNormal(vec3 p, rObj o) {
    return normalize(vec3(
        geometryDistance(vec3(p.x + EPSILON, p.y, p.z), o) - geometryDistance(vec3(p.x - EPSILON, p.y, p.z), o),
        geometryDistance(vec3(p.x, p.y + EPSILON, p.z), o) - geometryDistance(vec3(p.x, p.y - EPSILON, p.z), o),
        geometryDistance(vec3(p.x, p.y, p.z  + EPSILON), o) - geometryDistance(vec3(p.x, p.y, p.z - EPSILON), o)
    ));
}

// Function 1757
vec3 DiffuseUnitSpehreRay(float x1,float x2){
	float theta = acos(sqrt(1.0-x1));
    float phi   = TWO_PI * x2;
    float sinTheta = sin(theta);
    return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cos(theta));
}

// Function 1758
vec3 normal(vec3 pos) {
	vec3 eps = vec3(.01, 0, 0);
	vec3 nor = vec3(0);
	float invert = 1.;
	for (int i = 0; i < NORMAL_STEPS; i++) {
		nor += map(pos + eps * invert) * eps * invert;
		eps = eps.zxy;
		invert *= -1.;
	}
	return normalize(nor);
}

// Function 1759
vec3 rayDirection(vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(CAMERA_FOV) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 1760
vec3 normal(in vec3 p, in float d)
{  
    vec2 e = vec2(-1., 1.)*0.003*d;
	return normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x +
					 e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   
}

// Function 1761
vec3 normal(vec3 p, float e) {
    vec2 h = vec2(1.0,-1.0)*0.5773;
    return normalize( h.xyy*map( p + h.xyy*e ).x + 
					  h.yyx*map( p + h.yyx*e ).x + 
					  h.yxy*map( p + h.yxy*e ).x + 
					  h.xxx*map( p + h.xxx*e ).x );
}

// Function 1762
vec3 calculateNormal(vec3 p) {
    return calculateGradientFromDistanceField(p);
}

// Function 1763
vec3 GetNormal(vec3 p, float sphereR)
{
	vec2 eps = vec2(sphereR*.5, 0.0);
	return normalize( vec3(
           Map(p+eps.xyy) - Map(p-eps.xyy),
           Map(p+eps.yxy) - Map(p-eps.yxy),
           Map(p+eps.yyx) - Map(p-eps.yyx) ) );
}

// Function 1764
vec3 raymatch(vec3 ro , vec3 rd ) {

        vec3 rp = ro;
        float s = 0.0;
        const int mstep = 80;
        const float eps = 0.0001;
	for (int i = 0; i < mstep ; i++) {

	
                s = obj(rp);

                rp = rp + rd*s;
                if (abs(s) < eps ) break;
	
	}

        //vec3 n = normalize(vec3 (rp));

        vec3 n = est_normal(rp);
        vec3 ret = vec3(0.0);

        if (abs(s) < eps) {
            //ret = vec3(1.0)*lambert(n, l) ;//+0.6*raymatch_iter2(rp+vec3(0.1), normalize(-reflect((rp-ro),n)));
        ret = 0.5+0.5*n;
        }

        return ret;

}

// Function 1765
float ExtractPortalRay(in float t, out vec3 rayOrigin, out vec3 rayDir)
{
	float ret = 0.0; 
	rayOrigin = vec3(0.0); 
	rayDir = vec3(0.0);
	
	for (int i=0;i<NUM_PORTAL_RECURSIONS;++i)
	{
		float isCopy = step(distances[i],t);
		float minusIsCopy = 1.0 - isCopy; 
		
		ret = (distances[i]*isCopy)+(ret*minusIsCopy);
		rayOrigin = (rayPositions[i]*isCopy)+(rayOrigin*minusIsCopy);
		rayDir = (rayDirections[i]*isCopy)+(rayDir*minusIsCopy);		
	}
	return ret;
}

// Function 1766
vec2 boxRay(in vec3 ro, in vec3 rd)
{
    vec3 i_p = (vec3(box_x, box_y, box_x) - ro ) / rd;
    vec3 i_m = (-vec3(box_x,0.5*box_y, box_x) - ro ) / rd;
    
    vec3 vmin = min(i_p, i_m);
    vec3 vmax = max(i_p, i_m);
    
    // min, max
    return vec2(max(max(vmin.x, vmin.y), vmin.z),min(min(vmax.x, vmax.y), vmax.z));
}

// Function 1767
void Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )
{
    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );
    vRayOrigin = cam.vPos;
    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );
    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );
}

// Function 1768
vec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)
{
    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection
    float multiplier = 1.0;
    vec3 ret = vec3(0.0);
    float absorbDistance = 0.0;
	for (int i = 0; i < MAX_RAY_BOUNCES; ++i)
    {
        // try and intersect the object
    	vec4 rayInfo = RayIntersectObject(rayPos, rayDir);
        
        // should "never" happen but handle it anyways
    	if (rayInfo.x < 0.0)  
            return ret;
        
        // move the ray position to the intersection point.
        rayPos = rayPos + rayDir * rayInfo.x;
        
        // calculate beer's law absorption.
        absorbDistance += rayInfo.x;    
        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);
        
        // calculate how much to reflect or transmit (refract or diffuse)
        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);
        float refractMultiplier = 1.0 - reflectMultiplier;
        
        // add in refraction outside of the object
        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);
        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;
        
        // add specular highlight based on refracted ray direction
        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; 
        
        // follow the ray down the internal reflection path.
        rayDir = reflect(rayDir, rayInfo.yzw);
        
        // move the ray slightly down the reflect path
        rayPos += rayDir * 0.001;
        
        // For reflection, we are only going to be reflecting what is refracted on further bounces.
        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.
		multiplier *= reflectMultiplier;        
    }
    
    // return the color we calculated
    return ret;
}

// Function 1769
void raytrace(in vec3 ro, in vec3 rd,
              out vec4 hit_nt, 
              out vec3 prev_cell,
              out vec3 cur_cell) {
    
 
    
    // find nearest hex cell center to ray origin    
    cur_cell = vec3(nearestHexCell(ro.xy), floor(ro.z/cell_height + 0.5));
    
    // we also will care about the cell we entered in from
    prev_cell = cur_cell;
    
    // current cell center
    vec3 cur_center = cur_cell * cell_size;

    // see if ray is pointed up or down
    float dz = rd.z < 0.0 ? -1.0 : 1.0;

    // get the three candidate wall directions for this ray (i.e. the
    // three hex side directions that correspond to normals with positive
    // dot products to ray direction)
    vec2 h0 = alignNormal(vec2(0.0, 1.0), rd.xy);
    vec2 h1 = alignNormal(vec2(1.0, 0.5), rd.xy);
    vec2 h2 = alignNormal(vec2(1.0, -0.5), rd.xy);

	// have we hit a hex yet?    
    bool hit = false;
    
    // initialize normal to zero and intersection distance to negative
    hit_nt = vec4(0, 0, 0, -1.0);    

    // march along ray, one iteration per cell
    for (int i=0; i<grid_steps; ++i) {
        
        // once we hit we're good
        if (hit) { continue; }
        
        // distance from ray origin to current cell center
        vec3 rdelta = ro-cur_center;
        
        // first, test intersections with sides:
        // after three tests, ht.xy holds the direction, ht.z holds the
        // ray distance parameter with intersecting sides
        vec3 ht = rayHexIntersect(rdelta.xy, rd.xy, h0);
        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h1));
        ht = rayMin(ht, rayHexIntersect(rdelta.xy, rd.xy, h2));
        
        // next, test intersection with top/bottom 
        float tz = (0.5*dz*cell_height - rdelta.z) / rd.z;
        
        // now we will need to figure out how to update the current cell
        // either horizontally or vertically.
        
        // stash the previous cell
        prev_cell = cur_cell;        

        // variable to hold return value if we do hit
        vec4 new_nt;
 
        // check whether we hit top/bottom before side
        if (tz < ht.z) {
            
            // hit top/bottom first, so march vertically
            cur_cell.z += dz;
            
            // set up normal and ray distance for return value
            new_nt = vec4(0, 0, -dz, tz);
            
        } else {
            
            // hit side first, so march horizontally
            cur_cell.xy += 2.0*ht.xy;
            
            // set up normal and ray distance for return value
            new_nt = vec4(-CART_FROM_HEX(ht.xy), 0, ht.z);
            
        }
        
        // we updated the current cell, now update the cell center position
        cur_center = cur_cell * cell_size;
            
        // see if the new cell center is occupied
        if (map(cur_center/resolution) < 0.0) {
            hit = true;
            hit_nt = new_nt;
        }
        
        

    }

}

// Function 1770
vec3 computeNormal(inout vec3 pos) {
    vec2 latlon = _3DToLatLon(normalize(pos));
    
    const float latlonPixel = PIXEL_SIZE;
    
    vec2 discreteLatlon = discretize(latlon, latlonPixel);
    vec3 filteredPos = latLonTo3D(discreteLatlon + 0.5*latlonPixel);
    
    return normalize(filteredPos);
}

// Function 1771
vec3 getNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*distFunc( pos + e.xyy ) + 
					  e.yyx*distFunc( pos + e.yyx ) + 
					  e.yxy*distFunc( pos + e.yxy ) + 
					  e.xxx*distFunc( pos + e.xxx ) ) ;
}

// Function 1772
vec3 NormalMap( vec3 normal, vec3 pos, vec3 triPlanarWeights )
{
    return normalize( normal + NormalMapTex( pos.yz ) * triPlanarWeights.x + NormalMapTex( pos.xz ) * triPlanarWeights.y + NormalMapTex( pos.xy ) * triPlanarWeights.z );
}

// Function 1773
vec3 normal( in vec3 pos )
{
    const float eps = 0.005;

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*scene( pos + v1*eps ) + 
					  v2*scene( pos + v2*eps ) + 
					  v3*scene( pos + v3*eps ) + 
					  v4*scene( pos + v4*eps ) );
}

// Function 1774
vec3 ray_march(vec3 rayOrigin, vec3 rayDir) {
        float distanceTravelled = 0.0;
        const int NUMBER_OF_STEPS = 2048;
        const float MINIMUM_HIT_DISTANCE = 0.001;
        const float MAXIMUM_TRACE_DISTANCE = 1000.0;
        for(int i = 0; i < NUMBER_OF_STEPS; i++) {
            vec3 currPos = rayOrigin + distanceTravelled * rayDir;
            vec4 sceneData = scene_dist(currPos);
            float sceneDist = sceneData.x;
            vec3 sceneDiffuse = sceneData.yzw;
            if (sceneDist < MINIMUM_HIT_DISTANCE) {
                vec3 normal = calculate_normal(currPos);
                vec3 lightPos = vec3(200.0, -500.0, 150.0);
                vec3 dirToLight = normalize(currPos - lightPos);
                float lightIntensity = max(0.2, dot(normal, dirToLight));
                vec3 reflectDir = reflect(rayDir, normal);
                sceneDiffuse = ray_march_diffuse(currPos + reflectDir * 0.002, reflectDir, sceneDiffuse);
                if (ray_march_hit(currPos + dirToLight * 0.01, dirToLight)) {
                    lightIntensity = 0.15;
                }
                return ((sceneDiffuse) / 2.0) * lightIntensity + 0.2 * vec3(1.0, 1.0, 1.0);
            }
            if (sceneDist > MAXIMUM_TRACE_DISTANCE) {
                break;
            }
            distanceTravelled += sceneDist;
        }
        return Sky(rayOrigin, rayDir);
        
    }

// Function 1775
vec3 calcNormal(in vec3 p) {
    // Thanks iq! I didn't fancy deriving this...
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( p + e.xyy ).x + 
					  e.yyx*map( p + e.yyx ).x + 
					  e.yxy*map( p + e.yxy ).x + 
					  e.xxx*map( p + e.xxx ).x );
}

// Function 1776
float distanceOnNormalizedAngle(float angle, float refPoin)
{
  
  float d =abs( angle - refPoin);
  if(d> 0.5) d = 1. - d;
  return d;
}

// Function 1777
float normalizedLogCToRelativeExposure(float x)
{
if (x > 0.149659)
return (pow(10.0, (x - 0.385537) / 0.247189) - 0.052272) / 5.555556;
else
return (x - 0.092809) / 5.367650;
}

// Function 1778
vec3 normal(vec3 p){
    vec2 eps = vec2(.001, 0);
    return (vec3(
        dist(p + eps.xyy),
        dist(p + eps.yxy),
        dist(p + eps.yyx))
        - dist(p))/eps.x;
}

// Function 1779
vec3 trace_ray(vec3 origin, vec3 n_direction, out vec3 point_of_intersection)
{
    if(find_intersection(origin, n_direction, 32, 0.1, 10, point_of_intersection))
    {
        vec2 uv = compute_uv(normalize(point_of_intersection - cubemap_origin));	// TODO: Normalization required?
        vec3 color = shade_pixel(point_of_intersection, n_direction, uv);

        return(shade_pixel(point_of_intersection, n_direction, uv));
    }     

    return(vec3(0.0, 1.0, 0.0));  
}

// Function 1780
void rayMarch (inout Ray ray) {
	//
	ray.origin += ray.near * ray.direction;
	
	ray.distance 	= ray.far;
	ray.normal 		= vec3(0);
	ray.object.uv   = vec2(0);
	ray.object.id	= -1;
	ray.hit 		= false;
	
	float d;
	vec3 normal;
	vec2 uv;
	
	d = intersectSphere(ray, sphere_light, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 1;
		ray.hit 		= true;
	}
	
	d = intersectSphere(ray, sphere1, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 2;
		ray.hit 		= true;
	}
	
	d = intersectBox(ray, box1, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 3;
		ray.hit 		= true;
	}
	
	d = intersectBox(ray, box2, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 4;
		ray.hit 		= true;
	}

	d = intersectSphere(ray, sphere2, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 5;
		ray.hit 		= true;
	}

	d = intersectCylinder(ray, cylinder1, normal, uv);
	if (ray.distance > d) {
		ray.distance 	= d;
		ray.normal		= normal;
		ray.object.uv	= uv;
		ray.object.id	= 6;
		ray.hit 		= true;
	}

	ray.position = ray.origin + ray.direction * ray.distance;
}

// Function 1781
vec3 Raymarch(Ray r)
{
    float t = 0.0;
    float d = 0.0;
    
	for(int j = 0; j < MAX_ITERATIONS_FOREGROUND; j++)
	{
		d = sdf(r.origin + r.direction * t, r);

		if(d < EPSILON)
            break;
        
		t += d;
        
        if(t > MAX_DISTANCE)
            break;
	}
    
    t = min(t, MAX_DISTANCE);
    
    return vec3(t, 0.0, d);
}

// Function 1782
bool rayMarch(vec3 ro, vec3 rd, vec2 iMouse, float iTime, out float t) {
    t = 1e-4;
    for(int i = 0; i < 18; i++) {
        vec3 p = ro + t*rd;
        float h = map(p, iMouse, iTime);
        if( abs(h) < 1e-5) {
            return true;
        }

        if (t > maxT) {
            return false;
        }
        t += h;
    }
    return true;
}

// Function 1783
float pReflect(inout vec3 p, vec3 planeNormal, float offset)
{
  float t = dot(p, planeNormal)+offset;
  if (t < 0.0)
  {
    p = p - (2.0*t)*planeNormal;
  }
  return sgn(t);
}

// Function 1784
Hit raymarch(vec3 rayOrigin, vec3 rayDirection){

    float currentDist = INTERSECTION_PRECISION * 2.0;
    float rayLength = 0.;
    Model model;

    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){
        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {
            break;
        }
        model = map(rayOrigin + rayDirection * rayLength);
        currentDist = model.dist;
        rayLength += currentDist * (1. - model.underStep);
    }

    bool isBackground = false;
    vec3 pos = vec3(0);
    vec3 normal = vec3(0);

    if (rayLength > MAX_TRACE_DISTANCE) {
        isBackground = true;
    } else {
        pos = rayOrigin + rayDirection * rayLength;
        normal = calcNormal(pos);
    }

    return Hit(
        model,
        pos,
        isBackground,
        normal,
        rayOrigin,
        rayLength,
        rayDirection
    );
}

// Function 1785
Ray ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.); }

// Function 1786
float3 CalcNormal(float3 p, float n0)
{
	float3 n;
	float d=0.001;
	n.x=Value(p+float3(d,0.0,0.0))-n0;
	n.y=Value(p+float3(0.0,d,0.0))-n0;
	n.z=Value(p+float3(0.0,0.0,d))-n0;

	n=normalize(n);
	return n;
}

// Function 1787
vec3 camera_ray(in Camera camera, in vec2 uv) {
    uv = uv * 2.0 - 1.0;
    float radian = camera.fov;
    float h = tan(radian * 0.5);
    float w = h * camera.aspect;
    vec3 right = normalize(cross(camera.direction, camera.up_direction));
    vec3 up = normalize(cross(right, camera.direction));
    return normalize(right * w * uv.x + up * h * uv.y + camera.direction);  
}

// Function 1788
vec3 GetRayDir(vec2 uv, vec3 ro) {
	vec3 f = normalize(vec3(0)-ro),
        r = normalize(cross(vec3(0,1,0), f)),
        u = cross(f, r),
        c = ro + f,
        i = c + uv.x*r + uv.y*u,
        rd = normalize(i-ro);
    return rd;
}

// Function 1789
vec3 reflected(vec3 raydir, vec3 normal)
{
    return raydir - 2.0*dot(raydir, normal)*normal;
}

// Function 1790
float raymarchWater(Ray ray, float tmin, float tmax) {
 
    float t = tmin;
    for(int i = 0; i < 256; i++) {
     
        vec3 p  = ray.ori + ray.dir * t;
        float h = p.y - getHeight(p.xz);
        if(h < EPSILON * t || t > tmax) break;
        t += h * .5;
        
    }
    return t;
    
}

// Function 1791
vec3 getNormal(vec3 p) {
    
    // Central differences method to generate a normal vector
    // This is imperfect for this non-continuous heightmap, and I believe
    // this is the cause of the bad normal lighting
    vec2 eps = vec2(0.005, 0.00);
    vec3 normal = vec3(
    	heightMap(p.xz + eps.xy) - heightMap(p.xz - eps.xy),
		2.0 * eps.x,
		heightMap(p.xz + eps.yx) - heightMap(p.xz - eps.yx)
    );
    normal = normalize(normal);
    return normal;
    
}

// Function 1792
vec3 getNormal(vec3 p){
    vec2 e = vec2(0.0, 0.001);
    return normalize((vec3(map(p + e.yxx), map(p + e.xyx), map(p + e.xxy)) - map(p)) / e.y);
}

// Function 1793
vec3 computeNormal(in vec3 pos)
{
    int material;
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	     map(pos+eps.xyy, material) - map(pos-eps.xyy, material),
	     map(pos+eps.yxy, material) - map(pos-eps.yxy, material),
	     map(pos+eps.yyx, material) - map(pos-eps.yyx, material));
	return normalize(nor);
}

// Function 1794
vec4 raymarch(vec3 eye, vec3 dir)
{
    vec4 depth = vec4(0);
    for (int i = 0; i < 128; i++)
    {
        vec3 p = eye + dir * depth.w;
        
        vec4 dist = scene(p);
        if (dist.w < EPSILON * length(p)) {
			return vec4(saturate(dist.xyz), depth.w);
        }
        depth.w += dist.w;
        if (depth.w > MAX_DIST) {
            return MAX_VEC;
        }
    }
    return MAX_VEC;
}

// Function 1795
vec2 rayGround(vec3 ro,  vec3 rd,  float dmin,  float dmax, out vec3 out_n, out float out_val) {
    
    float t1, t2;
    // Test bounding sphere
    int type = intersectSphere(ro, rd, .5/H_COEFF+1., t1, t2);
    if (type > 0) {
        dmin = max(dmin,t1);
        dmax = min(dmax,t2);

        // Go step by step until the ray traverse the ground
        float d, h, rand = dd*hash1(dot(ro+rd*dmin,vec3(127.1,311.7,758.5453123)));
        for(d = dmin+rand; d<dmax+dd; d += dd) {
            h = altitude(ro+rd*d);
            if (h <= 0.) break;
        }

        // Precise the true intersection point
        if (d <= dmax) {
            d = preciseSurfaceGround(ro, rd, max(dmin, d-dd), min(d,dmax));
            out_n = normalAt(ro+rd*d);				
            out_val = altitude(ro+rd*d);
            return vec2(d, GROUND_ID);
        }
    }
	return vec2(NO_INTERSECTION, NO_ID);
}

// Function 1796
vec2 castRay(vec3 ro, vec3 rd) {
	float tmin = 0.0;
	float tmax = Far;

	float precis = 0.002;
	float t = tmin;
	float m = -1.0;

	for (int i = 0; i < MaxSteps; i++) {
		vec2 res = map(ro + rd * t);
		if (res.x < precis || t > tmax) {
			break;
		}
		t += res.x * MarchDumping;
		m = res.y;
	}
	if (t > tmax) {
		m = -1.0;
	}
	return vec2(t, m);
}

// Function 1797
vec3 rayMarchReflection(vec3 rayDir, vec3 cameraOrigin)
{
    const int maxItter = 30;
	const float maxDist = 20.0;
    
    float totalDist = 0.0;
	vec3 pos = cameraOrigin;
	vec4 dist = vec4(epsilon);

    for(int i = 0; i < maxItter; i++)
	{
		dist = distfunc(pos);
		totalDist += dist.x;
		pos += dist.x * rayDir;
        
        if(dist.x < epsilon || totalDist > maxDist)
		{
			break;
		}
	}
    
    return vec3(dist.x, totalDist, dist.y);
}

// Function 1798
vec3 normal(in vec3 p, in float ds)
{  
    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 1799
vec4 Raymarch(vec3 ro, vec3 rd, out float emission) 
{
	float dO=0.;
    vec3 color = vec3(0.);
    
    for(int i=0; i<MAX_STEPS; i++) 
    {
    	vec3 p = ro + rd*dO;
        float dS = Scene(p);
        dO += dS;
        
        if(dO>MAX_DIST || dS<SURF_DIST) break;

        float tunnel = 1. - saturate(abs(dS - ObjTunnel(p)));

        color = vec3(.2,.05,.05); // ground
        color = mix(color, vec3(1,0,0), smoothstep(0.2, 1., tunnel));
    }
    
    return vec4(dO, color);
}

// Function 1800
float castRay3(const vec3 ro, const vec3 rd, out float resT) {
    
    float t2 = 0.0;
    float ret2 = 0.0;
    
    for (int i = 0; i < 256; i++) {
        vec3 p2 = ro + rd*t2;
        float h2 = map3(p2);
        
        //h = min(h, h2);
        if (h2 > 0.0 && h2 < 0.01) {
            resT = t2;
            ret2 = 1.0;
        }
        
        t2 += h2;
    }
    
    return ret2;
}

// Function 1801
vec3 normal(vec3 p){
    vec2 u = vec2(0.,EPSI); float d = df(p);
    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);
}

// Function 1802
vec3 rayToPos(Ray ray, float t)
{
    return ray.origin + ray.dir * t;
}

// Function 1803
vec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;
  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)
             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)
             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}

// Function 1804
vec2 sampleRay(vec3 ro, vec3 rd)
{
    vec2 energy = vec2(0);
    vec2 spectrum = vec2(1.);
    vec2 mats = vec2(.9, .5) * .99;
    vec3 lo = vec3(.7, .8, .1), ls = vec3(1, 0, 0) * .2, lt = vec3(0, 0, 1) * .2;
    vec3 ln = normalize(cross(ls, lt));
    float lightArea = length(ls) * length(lt);
    float lightRadiance = 50.0;

    for(int i = 0; i < 3; ++i)
    {
        vec3 n, p0, p1, uvw;
        vec2 res = traceScene(ro, rd, n, uvw);
        vec3 rp = ro + rd * res.x;
        if(res.x < 0. || res.x > 1e3)
            break;

        float t = dot(lo - ro, ln) / dot(rd, ln);
        if(t > 0. && t < res.x && dot(rd, ln) < 0.)
        {
            vec3 rp = ro + rd * t;
            vec2 uv = vec2(dot(rp - lo, ls) / dot(ls, ls), dot(rp - lo, lt) / dot(lt, lt));
            if(abs(uv.x) < 1. && abs(uv.y) < 1.)
            {
                energy += spectrum * lightRadiance;
            }
        }

        float fr = mix(0.001, 1.0, pow(1. - clamp(dot(-rd, n), 0., 1.), 3.));

        vec3 absuvw = abs(uvw);
        vec2 uv = absuvw.x > absuvw.y ? (absuvw.x > absuvw.z ? uvw.yz : uvw.xy) : (absuvw.y > absuvw.z ? uvw.xz : uvw.xy);

            if(res.y < .5)
            {
                // No intersection.
                break;
            }
        else if(res.y < 1.5)
        {
            // Diffuse box 1.
            if(rp.y > .99)
                spectrum *= .5;
            else
                spectrum *= mats;
            vec2 dc = texture(iChannel0,uvw).rg/float(iFrame)*12.;
            dc *= mix(.3, 1., textureLod(iChannel2, uv / 2., 1.).r);
            if(rp.y > .999 && abs(rp.x - -.3) < .6 && abs(rp.z - .1) < .8)
            {
                energy += spectrum * vec2(1.3, 1.).yx * mix(.7, 1., textureLod(iChannel1, rd, 2.).r);
                fr = 1.;
            }
            else
            {
                energy += spectrum * dc * (1. - fr);
            }
        }
        else if(res.y < 2.5)
        {
            // Diffuse box 2.
            spectrum *= mats.yx;
            vec2 dc = texture(iChannel0,uvw).ba / float(iFrame) * 12.;
            dc *= mix(.3, 1., textureLod(iChannel3, uv / 2., 1.).b);
            energy += spectrum * dc * (1. - fr);
        }
        else if(res.y < 3.5)
        {
            // Mirror box.
            fr = 1.;
        	fr *= mix(1., .25, pow(textureLod(iChannel2, rp.zx, 1.).r, 3.));
        }
        spectrum *= .9 * fr;
        ro = rp + n * 5e-3;
        rd = reflect(rd, n);
        
        if(max(spectrum.x, spectrum.y) < 1e-4)
            break;
    }
    return energy;
}

// Function 1805
vec3 raycast(vec3 pos, vec3 dir)
{
	float np = pow(2.0, depth);
	pos *= np;
    float inp = pow(2.0, -depth);
	for(float i = 0.0; i < np; ++i)
	{
		vec3 aprox = (pos + dir * 3.46410161514 * i);
        aprox = ceil(aprox) * inp;;
		if(inradius(aprox))
			return aprox;
	}
	return vec3(0.0);
}

// Function 1806
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {

    const float precis = 0.002;   
    float h=2.0*precis;

    float t = 0.0;
    float m = -1.0;

    for( int i=0; i<rayiter; i++ )
    {
        if( abs(h)<precis||t>maxd ) continue;//break;
        t += h;
        vec2 res = map( ro+rd*t );
        h = res.x;
        m = res.y;        
    }    

    if (t > maxd) {
        m = -1.0;
    }

    return vec2(t, m);

}

// Function 1807
vec3 cubemapRayDir(in vec2 fragCoord, vec2 bufferSize) 
{     
    bufferSize.y = min(bufferSize.y, bufferSize.x*0.66667 + 4.0);
    
    float ts = (bufferSize.y - 2.0) * 0.5;
    
    fragCoord = min(fragCoord, 
                    vec2(ts*3.0 - 1.0, 2.0*ts + 1.0));
    
    vec2 tc = vec2(fragCoord.x / ts, 
                   fragCoord.y*2.0 / bufferSize.y); 
    
    vec2 ti = floor(tc) - vec2(1.0, 0.0);
    vec3 n = -vec3((1.0 - abs(ti.x))*(ti.y*2.0 - 1.0), 
                   ti.x*ti.y, ti.x*(1.0 - ti.y));

    float bpy = min(0.9999, fragCoord.y / ts);
    float tpy = max(1.0, (fragCoord.y - 2.0) / ts);

    vec2 p = fract(vec2(tc.x, (bpy * (1.0 - floor(tc.y)) 
                               + tpy * floor(tc.y)))) - 0.5;
    
    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * step(0.5, n.x)
              + vec3(0.5*n.x, -p.x, -p.y*n.x) * step(n.x, -0.5);
    vec3 py = vec3(-p.x*n.y, 0.5*n.y, p.y) * abs(n.y);
    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);
    
    return normalize(px + py + pz);
}

// Function 1808
vec3 SceneNormal(in vec3 pos, in float depth)
{
    vec2 eps = vec2(0.001 * depth, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy, 0.0).x - Scene(pos - eps.xyy, 0.0).x,
                          Scene(pos + eps.yxy, 0.0).x - Scene(pos - eps.yxy, 0.0).x,
                          Scene(pos + eps.yyx, 0.0).x - Scene(pos - eps.yyx, 0.0).x));
}

// Function 1809
vec3 getNormal(vec3 p, float d)
{
    vec3 n;
    n.y = terrain(p);    
    n.x = terrain(p + vec3(d, 0.0, 0.0)) - n.y;
    n.z = terrain(p + vec3(0.0, 0.0, d)) - n.y;
    n.y = d;
    return normalize(n);
}

// Function 1810
Hit rayMarch(vec3 ro, vec3 rd) {
    Hit resultHit;
    resultHit.dist = 0.0;

    for(int i = 0; i < MAX_STEPS; ++i) {
        vec3 p = ro + resultHit.dist * rd;
        Hit hit = sdf(p);
        resultHit.dist += hit.dist;
        resultHit.color = hit.color;
        if(hit.dist < EPSILON || resultHit.dist > MAX_DIST) {
            break;
        }
    }
    return resultHit;
}

// Function 1811
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 1812
float RayIntersectAABoxMax (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)
{
    vec3 boxMid = vec3(cellPos)+vec3(0.5);
    
	vec3 roo = rayPos - boxMid;
    vec3 rad = vec3(0.5);

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t2 = -n + k;

    return min( min( t2.x, t2.y ), t2.z );
}

// Function 1813
int traceRay(
    out int id, out vec2 end,
    inout vec2 dir, inout vec2 start, float maxLength,
    bool draw, vec2 uv, inout vec3 col
) {
    if (draw) {
        col = drawPoint(col, pointColor, 12., uv, start);	//first dot
    }
    
    vec2 poi = start;
    float lLeft = maxLength;
    id = -1;
    
    int i;
    for (i = 0; i <= maxIterations && lLeft > 0.; i++) {
        
        float l = lLeft;
        start = poi;
        int except = id;
        vec2 hitDir = firstIntersection(id, except, start, dir, l);	// l is inout
        
        //if(l < 0.) {col = debugCol; break;}
        hitDir = normalize(hitDir);	// can be raplaced w/ hitDir / pl[id]
        vec2 surfaceNml = vec2(hitDir.y, -hitDir.x);
        lLeft -= l;
        poi = start + l*dir;
        
        if (draw) {
            col = drawSegment(col, lineColor, rayWidth, uv, start, dir, l);
            col = drawPoint(col, pointColor, rayWidth * 3., uv, poi);
        }
        
        dir = reflect(dir, surfaceNml);
    }
    
    if (draw) {
        col = drawPoint(col, pointColor, 12., uv, poi);	//last dot
    }
    
    end = poi;
    return i;
}

// Function 1814
float castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID
){float tmi = 1e20
 ;mat4  cma
 ;vec3  csi
 ;int  cin = 0xffffffff
 ;for( int i=0; i<NUMBOXES; i++   //es100 safe
 ){mat4 ma; vec3 si; getLocation(i, ma, si)
  ;float res = iBox( ro, rd, ma, si )
  ;if( res>0.0 && res<tmi
  ){cma = ma
   ;csi = si
   ;cin = i
   ;tmi = res
 ;}}
 ;int resID
 ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )
 ;oID = cin*6 + resID
 ;return (cin==0xffffffff) ? -1.0 : tmi;}

// Function 1815
vec2 rayIntersectNearestGridPlanes(vec3 orig, vec3 ray)
{
    orig = fract(orig);
    float zInv = 1.0 / ray.z;
    float dFront = (1.0 - orig.z) * zInv;
    float dBack = (2.0 - orig.z) * zInv;

    if (ray.z < 0.0)
    {
    	dFront = (orig.z) * -zInv;
        dBack = (orig.z + 1.0) * -zInv;        
    }
    
    return vec2(dFront, dBack);
}

// Function 1816
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.004, 0.0, 0.0 );
    vec3 nor = vec3(
        mapScene(pos+eps.xyy,-1,false).d - mapScene(pos-eps.xyy,-1,false).d,
        mapScene(pos+eps.yxy,-1,false).d - mapScene(pos-eps.yxy,-1,false).d,
        mapScene(pos+eps.yyx,-1,false).d - mapScene(pos-eps.yyx,-1,false).d );
    return normalize(nor);
}

// Function 1817
vec3 normal(vec3 p)
{
    vec2 o = vec2(0.001,0.);//slight offset
    float c = geo(p).w;
    return normalize(c - vec3(geo(p - o.xyy).w, geo(p - o.yxy).w, geo(p - o.yyx).w));
}

// Function 1818
vec3 normal(vec3 p) {
	vec2 e = vec2(1,0)/1e3;
    p += 0.04 * vec3(
        map(p + e.xyy).x - map(p - e.xyy).x,
        map(p + e.yxy).x - map(p - e.yxy).x,
        map(p + e.yyx).x - map(p - e.yyx).x)/ (2. * length(e));
	return normalize(p);
}

// Function 1819
vec2 raymarch_main(vec3 _ro, vec3 _rd, float _near, float _far, float t)
{
    vec2 close;
    close.x = 0.;
    for(int i = 0;i < MAIN_SCENE_MAX_STEPS; ++i)
    {
        vec3 p = _ro+_rd*close.x;
        // eval scene
        vec2 t = raymarch_main_scene(p, t);
        if(t.x<_near || close.x>_far)
            break;
        close.x += t.x*0.5;
        close.y = t.y;
    }
    return close;
}

// Function 1820
vec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )
{    
    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));
  	float fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);
    
    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));
    float fGradientAscent = 0.25 + (fFoam * -1.5);
    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);
    fScale *= max(0.25, 1.0 - fFoam * 5.0); // flatten normal in foam
    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );
    return vec4( normalize( vBlended ), dxy.z * fScale );
}

// Function 1821
Ray rayReflect(Hit h, vec3 rl) {
  return ray(h.pos + h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.sgn);
}

// Function 1822
vec3 getNormal(vec3 p) {
	float d = getDist(p);
    vec2 e = vec2(0.01, 0.0);
    
    vec3 n = d - vec3(
        getDist(p - e.xyy),
        getDist(p - e.yxy),
        getDist(p - e.yyx));
    
    return normalize(n);
}

// Function 1823
vec3 normal(vec3 p, float k)
{
	vec2 e = vec2(0,k);
	return normalize(vec3(
		map(p + e.yxx) - map(p - e.yxx),
		map(p + e.xyx) - map(p - e.xyx),
		map(p + e.xxy) - map(p - e.xxy)
	));
}

// Function 1824
vec3 get_water_normal(vec3 water_plane_point_of_intersection)
{
    vec3 noise = texture(iChannel3, water_plane_point_of_intersection.xz * 0.2).rgb;	// TODO: Why can't we use "water_plane_point_of_intersection"???
    
    // TODO: This time-based code has numerical precision issues:
    float water_time = iTime * 9.0;
    
    vec3 offset;
    offset.x = sin(water_time + noise.r * two_pi);
    offset.y = sin(water_time + noise.g * two_pi);
    offset.z = sin(water_time + noise.b * two_pi);
            
    return(normalize(offset + vec3(0.0, 1.0 / 0.03, 0.0)));
}

// Function 1825
vec3 getNormal(in vec3 pos)
{
    vec2 eps = vec2(0.001, 0.0);
    vec3 normal = vec3(
        map(pos + eps.xyy) - map(pos - eps.xyy),
        map(pos + eps.yxy) - map(pos - eps.yxy),
        map(pos + eps.yyx) - map(pos - eps.yyx));
    return normalize(normal);
}

// Function 1826
float rayboxintersect(ray r, aabb box)
{
    float tmin = (box.min.x - r.pos.x) / r.dir.x;
    float tmax = (box.max.x - r.pos.x) / r.dir.x;

    if (tmin > tmax)
    {
        // swap(tmin, tmax);
        float tmp = tmin;
        tmin = tmax;
        tmax = tmp;
    }

    float tymin = (box.min.y - r.pos.y) / r.dir.y;
    float tymax = (box.max.y - r.pos.y) / r.dir.y;

    if (tymin > tymax)
    {
        // swap(tymin, tymax);
        float tmp = tymin;
        tymin = tymax;
        tymax = tmp;
    }

    if ((tmin > tymax) || (tymin > tmax))
        return MAXDIST; // no intersection

    if (tymin > tmin)
        tmin = tymin;

    if (tymax < tmax)
        tmax = tymax;

    float tzmin = (box.min.z - r.pos.z) / r.dir.z;
    float tzmax = (box.max.z - r.pos.z) / r.dir.z;

    if (tzmin > tzmax)
    {
        // swap(tzmin, tzmax);
        float tmp = tzmin;
        tzmin = tzmax;
        tzmax = tmp;
    }

    if ((tmin > tzmax) || (tzmin > tmax))
        return MAXDIST; // no intersection

    if (tzmin > tmin)
        tmin = tzmin;

    if (tzmax < tmax)
        tmax = tzmax;

    return tmin;
}

// Function 1827
float softray( in vec3 ro, in vec3 rd , in float hn)
{
    float res = 1.0;
    float t = 0.0005;
	float h = 1.0;
    for( int i=0; i<40; i++ )
    {
        h = scene(ro + rd*t);
        res = min( res, hn*h/t );
		t += clamp( h, 0.02, 2.0 );
    }
    return clamp(res,0.0,1.0);
}

// Function 1828
vec3 getSphereNormal(vec3 hitPoint,Sphere s){
	return normalize(hitPoint-s.center);
}

// Function 1829
vec3 normal(vec3 p, float cd)
{
    vec2 e = vec2(.01,.0);
    return normalize(vec3(cd - map(p + e.xyy),
                    cd - map(p + e.yxy),
                    cd - map(p + e.yyx)));
}

// Function 1830
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.01, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    
    return normalize(n);
}

// Function 1831
vec3 GetNormal (vec3 p) {
    float d = GetDist(p);
    vec2 e = vec2(.01,0);
    vec3 pointNormal = d - vec3(
    	GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx)
    );
    return normalize(pointNormal);
}

// Function 1832
vec3 ray_vector(float fov, vec3 iResolution, vec2 fragCoord) {
    
    // scale relative to pixel density
    float size = sqrt(iResolution.x * iResolution.y);
    
    // calculate vector in screen coordinates
    vec2 xy = fragCoord - iResolution.xy / 2.0;
    float z = (size / 2.0) / tan(fov / 2.0);
    
    // return normalized vector
    return normalize(vec3(xy, z));
}

// Function 1833
vec4 castRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	
	vec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );

    // traverse regular grid (in 2D)
	vec2 mm = vec2(0.0);
	for( int i=0; i<200; i++ ) 
	{

		float ma = map(pos);
		
        // intersect capped cylinder		
		vec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.249;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
            // cylinder			
			float s = (-b - sqrt( h ))/a;
			if( s>0.0 && (ro.y+s*rd.y)<ma )
			{
				res = vec4( s, 0.0, pos );
    			break; 
			}
            // cap			
			s = (ma - ro.y)/rd.y;
			if( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )
			{
				res = vec4( s, 1.0, pos );
				break;
			}
		}

        // step to next cell		
		mm = step( dis.xy, dis.yx ); 
		dis += mm*ris;
        pos += mm*rs;
	}


	return res;
}

// Function 1834
vec2 heightmapNormal(vec2 p)
{
    return vec2(sin(p.x+iTime*0.25)*0.15, sin(p.y-iTime*0.125)*0.15);
}

// Function 1835
vec3 Normal(vec3 p)
{
    vec3 off = vec3(NORMAL_OFFS,0,0);
    return normalize
    ( 
        vec3
        (
            Scene(p+off.xyz) - Scene(p-off.xyz),
            Scene(p+off.zxy) - Scene(p-off.zxy),
            Scene(p+off.yzx) - Scene(p-off.yzx)
        )
    );
}

// Function 1836
vec3 hemispherenormal(vec2 rng) {
  
  float radius = sqrt(rng.x);
  float angle = 2.0 * pi * rng.y;
  
  return vec3(radius * cos(angle), sqrt(1.0 - rng.x), radius * sin(angle));
}

// Function 1837
float castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
   
#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
    float t = tmin;
    for( int i=0; i<128; i++ )
    {
	    float precis = 0.0005*t;
	    float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }

    if( t>tmax ) t=-1.0;
    return t;
}

// Function 1838
float multi_refract(inout Ray R, inout Intersection I) {
    float result = 0.0;
    for(int i=0; i<10; ++i) {
        if(dot(R.Dir,I.N) > 0.0) { // Exiting matter
            result += I.t;
            vec3 old_dir = R.Dir;
            I.N = -I.N;
            R = refract_ray(R, I, refract_index, 1.0);
            if(R.Dir == vec3(0)) { 
               //R.Dir = reflect(old_dir, I.N); // total reflection (what I should do I think) 
               R.Dir = old_dir; // I do that instead (not correct but looks better).
            }
        } else { // Entering matter
            R = refract_ray(R, I, 1.0, refract_index);
            R.Dir = normalize(R.Dir); // Needs to be unit, so that on exit, I.t is distance
        }
        I.t = FARAWAY;
        if(!mesh_AABB(R, I)) { break; }  
    }
    return result;
}

// Function 1839
vec3 calcNormal(in vec3 pos)
{
	vec2 e = vec2(1.0,-1.0)*0.5773;
	const float eps = 0.0005;
	return normalize(
		e.xyy*sdf(pos + e.xyy*eps) + 
		e.yyx*sdf(pos + e.yyx*eps) + 
		e.yxy*sdf(pos + e.yxy*eps) + 
		e.xxx*sdf(pos + e.xxx*eps)
	);
}

// Function 1840
vec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )
{
	vec4 sum = vec4( 0.0 );

	float t=dither(pixel);
	
	for( int i=0; i<100; i++ )
	{
		if( sum.a > 0.99 ) break;
		
		vec3 pos = ro + t*rd;
        float d= map( pos );
		vec4 col = vec4(mix( vec3(1.0,1.0,1.23), vec3(0.1,0.0,0.10), d ),1.);

		col *= d*3.;

		sum +=  col*(1.0 - sum.a);	

		t += 0.05;
	}

	return clamp( sum.xyz, 0.0, 1.0 );
}

// Function 1841
vec3 calcNormal(vec3 p, float t) {
  // Try and scale epsilon for ray length.
  // This doesn't seem to work too well
  //float eps = t*0.0002;
  float eps = 0.002;
  vec2 e = vec2(eps, 0.0);
  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),
                        eval(p + e.yxy) - eval(p - e.yxy),
                        eval(p + e.yyx) - eval(p - e.yyx)));
}

// Function 1842
vec3  computeNormal(const vec3 pos)
{
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*mapScene(pos+0.0005*e).x;
    }
    return normalize(n);
}

// Function 1843
vec3 raymarch(vec3 eye, vec3 dir)
{
    vec3 depth = MIN_VEC;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++)
    {
        vec3 p = eye + dir * depth.z;
        
        vec3 dist = scene(p);
        if (dist.z < EPSILON * length(p)) {
			return vec3(dist.xy, depth.z);
        }
        depth.z += dist.z * (dist.z/(MAX_DIST) + 1.0);
        if (depth.z > MAX_DIST) {
            return MAX_VEC;
        }
    }
    return MAX_VEC;
}

// Function 1844
vec3 calcNormal(vec3 p) 
{
	float d = getDist(p).dist;
    
    vec2 e = vec2(.01, 0.);    
    vec3 n = d - vec3(
        getDist(p-e.xyy).dist,
        getDist(p-e.yxy).dist,
        getDist(p-e.yyx).dist);
    
    return normalize(n);
}

// Function 1845
vec3 getNormal(in vec3 p){
    vec2 eps = vec2(0.01,0);
    float d = scene(p).w;
    
    return normalize(vec3(
        scene(p + eps.xyy).w - d,
        scene(p + eps.yxy).w - d,
        scene(p + eps.yyx).w - d
    ));
}

// Function 1846
vec4 GetNormal(vec3 pos, vec3 lpos, vec4 shipQuat, float time)
{
    vec2 e = vec2(0.003,0.) * length(pos-ro);
    float o = map(pos,lpos,time);
    return vec4(normalize(vec3(	map(pos+e.xyy,lpos+Rotate(shipQuat,e.xyy),time) - o,
                          		map(pos+e.yxy,lpos+Rotate(shipQuat,e.yxy),time) - o,
                          		map(pos+e.yyx,lpos+Rotate(shipQuat,e.yyx),time) - o)),o);
}

// Function 1847
vec3 GetNormal(vec3 p){
    //distance to point being analyzed
    float d = GetDist(p).x;
    
    //distance to another point along the objects surface that is closeby
    vec2 e = vec2(0.01,0);
    
    //slope between the two points
    //note: swizzel is the .xxy or .yyx etc
    vec3 n = d - vec3(
         GetDist(p-e.xyy).x,
         GetDist(p-e.yxy).x,
         GetDist(p-e.yyx).x);
         
    return normalize(n);
    
}

// Function 1848
RaycastHit raycastScene(const Ray ray) {

    RaycastHit sphere1 = intersectSphere(vec3(sin(iTime),0.,0.),.6,ray);
    RaycastHit plane = intersectPlane(vec3(0., -.6, 0.), vec3(0.,1.,0.),ray);
    
    if(sphere1.type > -1) {
     
        return sphere1;
        
    }
    
    return plane;
    
}

// Function 1849
vec4 calcNormal(vec3 p, float dx, in object co) {
	const vec3 k = vec3(1,-1,0);
	return   (k.xyyx*map(p + k.xyy*dx, co) +
			 k.yyxx*map(p + k.yyx*dx, co) +
			 k.yxyx*map(p + k.yxy*dx, co) +
			 k.xxxx*map(p + k.xxx*dx, co))/vec4(4.*dx,4.*dx,4.*dx,4.);
}

// Function 1850
vec3 ray(vec2 uv, Cam cam)
{
    uv -= 0.5;
    uv.y *= iResolution.y/iResolution.x;
    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);
}

// Function 1851
float rayMarch(vec3 pos, vec3 dir, vec2 uv, float d)
{
    d = max(d,.0);
    float oldD = d;
    bool hit = false;
    for (int i = 0; i < 80; i++)
    {
		float de = mapDE(pos + dir * d);

		if(de < sphereSize(d) || d > 2000.0) break;
		oldD = d;

		d += 0.5*de;
   
    }
	if (d > 2000.0)
		oldD = 2000.0;

    
    return oldD;
}

// Function 1852
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<60; i++ )
    {
        if( abs(h)<precis||t>maxd ) continue;//break;
        t += h;
	    vec2 res = map( ro+rd*t );
        h = res.x;
	    m = res.y;
    }

    if( t>maxd ) m=-1.0;
    return vec2( t, m );
}

// Function 1853
vec3 getRayDirByCoord(vec2 coord){
	vec3 pointV3 = getPointV3ByFragCoord(coord);
    vec3 ray = pointV3 - cameraPosition;
    return normalize(ray);
}

// Function 1854
ray camera_get_ray(camera c, vec2 uv) {
    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);
    // add pixel antialiasing
    vec2 aa = (hash2(g_seed)-0.5)/iResolution.y;
    vec3 offset = c.u * rd.x + c.v * rd.y;
    return ray(c.origin + offset, 
            normalize(c.lower_left_corner + (uv.x+aa.x)*c.horizontal + (uv.y+aa.y)*c.vertical - c.origin - offset));
}

// Function 1855
vec3 getRayDir(vec2 fragCoord)
{
  vec2 uv = (fragCoord.xy / iResolution.xy )*2.0 - 1.0;
  uv.x *= iResolution.x/iResolution.y;                   
  return normalize(uv.x * cam.right + uv.y * cam.up + cam.forward);
}

// Function 1856
void GetBumpNormal(in vec3 pos, inout Material mat, int id)
{
    if(id != 1)
    {
        return;    // We only bump map the wood material
    }
    
    vec2 uv  = pos.xz * 0.25;
    vec2 eps = vec2(0.001, 0.0);

    float sampleU = texture(iChannel0, uv - eps.yx).r;
    float sampleD = texture(iChannel0, uv + eps.yx).r;
    float sampleL = texture(iChannel0, uv - eps.xy).r;
    float sampleR = texture(iChannel0, uv + eps.xy).r;

   	vec3 delta = vec3(
        (sampleL * sampleL - sampleR * sampleR), 
        0.0, 
        (sampleU * sampleU - sampleD * sampleD));

    mat.bump = normalize(mat.bump + (delta * 2.0));
}

// Function 1857
vec4 ray(vec2 uv, vec2 p, vec2 pid, float a, float difa)
{
    // Set up a point which passes through the ray.
    vec2 v = 1.*vec2(cos(a), sin(a));
    vec2 rd = p + v;
    
    // The signs of ray direction which tells us which cell boundries to worry about.
    float stepX = sign(v.x);
    float stepY = sign(v.y);
    
    vec2 rp = p;
    
    float d = 0.;
    float n = 0.;
    
    for(float i = 0.0; i < steps; i++){
        // Determine where the lines we want to intersect are on the screen depending on what cell we're in. 
        // and the direction we're looking.
    	float offX = (step(0., stepX) + pid.x) / gs; // Vertical lines.
    	float offY = (step(0., stepY) + pid.y) / gs; // Horizontal lines.	   
        
        // Calculate t value on ray for both the horizontal and vertical lines in question.
        float tMaxX = (offX - p.x) / (v.x);
    	float tMaxY = (offY - p.y) / (v.y);
        
        // The minimum of the two tells us how far we can travel in the current cell without leaving it.
        float t = (min(tMaxX, tMaxY));
        
        // Calculate intersection point.
        rp = (0.9999 - t)*p + (t + 0.0001)*rd;
        
        // Set new cell id for the ray position.
    	pid = floor(rp*gs);
        
        
        // Check if new id has an object in the way.
        if(GetTile(pid)==1){
            // Ray perpandicular distance to wall
            d = length(rp - p);
            d = d*cos(difa);
            
            // "normal" of wall
            n = step(tMaxX, tMaxY);
            
            return vec4(d, n, rp);
            
     		break;	   
        }
    	
    }
     
    d = FAR;
    
    return vec4(d, n, pid);
}

// Function 1858
vec3 castRay(vec3 pos, vec3 dir, float treshold) {
	for (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {
			float dist = distanceField(pos);
			if (abs(dist) < treshold) break;
			pos += dist * dir;
	}
	return pos;
}

// Function 1859
vec4 raymarching(vec3 ro, vec3 rd)
{
    float t = 0.0;
    for (int i = 0; i < 50; i++) {
       	float distToSurf = map(ro + t * rd);
        t += distToSurf;
        if (distToSurf < PRECIS || t > DMAX) break; 
    }
    
    vec4 col = vec4(0.0);
    if (t <= DMAX) {
        vec3 nor = normal(ro + t * rd);
        col.z = 1.0 - abs((t * rd) * camMat).z / DMAX; // Depth
        col.xy = (nor * camMat * 0.5 + 0.5).xy;	// Normal
        col.w = dot(lightDir, nor) * 0.5 + 0.5; // Diff
        col.w *= shadow(ro + t * rd, lightDir);
    }
    
    return col;
}

// Function 1860
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce ) {
    specularBounce = false;
    
    vec3 r = cosWeightedRandomHemisphereDirection( n );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1./1.5; n2 = 1.;
            n = -n;
        } else {
            n2 = 1./1.5; n1 = 1.;
        }
                
        float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
        
        vec3 ref;
        
        if( hash1() < fresnel ) {
            ref = reflect( rd, n );
        } else {
            ref = refract( rd, n, n2/n1 );
        }
        
        return ref; // normalize( ref + 0.1 * r );
	}
}

// Function 1861
vec3 fixNormalBackFacingness(vec3 rayDirWS, vec3 normalWS)
{
    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;
    return normalWS;
}

// Function 1862
void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, in vec2 fragCoord, out C_Ray ray)
{
	vec3 vForwards = normalize(vInterest - vPos);
	vec3 vUp = vec3(0.0, 1.0, 0.0);

	GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);
}

// Function 1863
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0. );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 1864
bool RayIntersectSnakeBody (in vec3 rayPos, in vec3 rayDir, out vec3 normal, out vec3 hitPos, inout float maxTime, out vec3 diffuseColor, out float shinyness)
{
	const float c_radius = 1.0/c_gridSize;
    bool hit = false;
    
    // find where the ray starts and ends within the grid, and then walk the grid to
    // find cells to test against.
    // grid cell walking from http://www.cse.yorku.ca/~amana/research/grid.pdf
    vec2 hitTime;
    if (!RayIntersectAABox(vec3(-1.0,0.0,-1.0), vec3(1.0,c_radius*2.0,1.0), rayPos, rayDir, hitTime))
        return false;
    
    #if DV_PLAYBOX
    	hit = true;
    	diffuseColor = vec3(0.0,1.0,0.0);
    #endif
       
    // Grid traversal from http://www.cse.yorku.ca/~amana/research/grid.pdf
    vec3 lineStart = rayPos+(rayDir*hitTime.x);
    vec3 lineEnd = rayPos+(rayDir*hitTime.y);
    
    // calculate where the line starts and stops in grid coordinates
    vec2 lineStartGrid = max(min((lineStart.xz+1.0)*c_halfGridSize, c_gridSize-0.001),0.0);
    vec2 lineEndGrid = max(min((lineEnd.xz+1.0)*c_halfGridSize, c_gridSize-0.001),0.0);
    
    // calculate where the cell positions that the line starts and stops at
    vec2 lineStartCell = floor(lineStartGrid);
    vec2 lineEndCell = floor(lineEndGrid);
    
    // step direction of traversal on each axis
    float stepX = lineEndGrid.x > lineStartGrid.x ? 1.0 : -1.0;
    float stepY = lineEndGrid.y > lineStartGrid.y ? 1.0 : -1.0;
    
    // how far to edge on each axis
    vec2 len = abs(lineEndGrid - lineStartGrid);

    // tDelta.x is time t that it takes to cross a cell horizontally (to next X cell)
    // tDelta.y is time t that it takes to cross a cell vertically (to next Y cell)
    vec2 tDelta = 1.0 / len;
    
    // tMaxX is time t when the line hits a vertical line in the grid (the next X cell)
    // tMaxY is time t when the line hits a horizontal line in the grid (the next Y cell)
    vec2 frac = fract(lineStartGrid);
    float tMaxX = lineEndGrid.x > lineStartGrid.x ? (1.0 - frac.x) / len.x : frac.x / len.x;
    float tMaxY = lineEndGrid.y > lineStartGrid.y ? (1.0 - frac.y) / len.y : frac.y / len.y; 
    
    // debug visualization of first grid cell hit.
    #if DV_PLAYGRID
    hit = true;
    diffuseColor = vec3(lineStartCell.x / c_gridSize, lineStartCell.y / c_gridSize, 1.0 - lineStartCell.x / c_gridSize);
   	shinyness = 0.0;
    maxTime = hitTime.x;
    return true;    
	#endif
    
    vec4 cell = texture( iChannel0, (lineStartCell+0.5) / iChannelResolution[0].xy, -100.0 );
    float offsetY = sin(iTime*5.0) * (1.0 - cell.z) * c_radius / 3.0;
    vec4 sphere;
    sphere.x = (lineStartCell.x-c_halfGridSize)/c_halfGridSize + c_radius;
    sphere.y = c_radius + offsetY;
    sphere.z = (lineStartCell.y-c_halfGridSize)/c_halfGridSize + c_radius;
    sphere.w = c_radius * cell.x;

    if (RayIntersectSphere(sphere, rayPos, rayDir, normal, hitPos, maxTime))
    {
        hit = true;
        diffuseColor = vec3(cell.y,cell.z,0.0);
        shinyness = 0.5;
        return true;
    }    
    
    // Loop
    const int c_loopCount = int(c_gridSize*2.0);
    for (int i = 0; i < c_loopCount; ++i)
    {
        if (tMaxX < tMaxY)
        {
            tMaxX += tDelta.x;
            lineStartCell.x += stepX;
        }
        else
        {
            tMaxY += tDelta.y;
            lineStartCell.y += stepY;
        }
        
        // bail out if we are out of bounds
        if (lineStartCell.x < 0.0 || lineStartCell.y < 0.0
           || lineStartCell.x > c_maxGridCell || lineStartCell.y > c_maxGridCell)
        {
            break;
        }        
        
        vec4 cell = texture( iChannel0, (lineStartCell+0.5) / iChannelResolution[0].xy, -100.0 );
        float offsetY = sin(iTime*5.0) * (1.0 - cell.z) * c_radius / 3.0;
        vec4 sphere;
        sphere.x = (lineStartCell.x-c_halfGridSize)/c_halfGridSize + c_radius;
        sphere.y = c_radius + offsetY;
        sphere.z = (lineStartCell.y-c_halfGridSize)/c_halfGridSize + c_radius;
        sphere.w = c_radius * cell.x;
        
        if (RayIntersectSphere(sphere, rayPos, rayDir, normal, hitPos, maxTime))
		{
            hit = true;
            diffuseColor = vec3(cell.y,cell.z,0.0);
            shinyness = 0.5;                          
            return true;
		}            
        
        // bail out if we are done
        if (lineStartCell == lineEndCell)
        {     
            break;
        }
    }
    
    return hit;
}

// Function 1865
bool IRayAABox(in vec3 ro, in vec3 rd, in vec3 invrd, in vec3 bmin, in vec3 bmax, 
               out vec3 p0, out vec3 p1) 
{
    vec3 t0 = (bmin - ro) * invrd;
    vec3 t1 = (bmax - ro) * invrd;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    
    float fmin = max(max(tmin.x, tmin.y), tmin.z);
    float fmax = min(min(tmax.x, tmax.y), tmax.z);
    
    p0 = ro + rd*fmin;
    p1 = ro + rd*fmax;
 
    return fmax >= fmin;   
}

// Function 1866
float ray(vec3 eye, vec3 dir)
{
    float depth = start;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        
        float dist = sdf(eye + depth * dir);
        
        if (dist < EPSILON) {
            return depth;
        }
        depth += dist;

        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 1867
vec3 CalcNormal(vec3 point) {
    return normalize(vec3(
        scene(point+vec3(eps,0.0,0.0))-scene(point-vec3(eps,0.0,0.0)),
        scene(point+vec3(0.0,eps,0.0))-scene(point-vec3(0.0,eps,0.0)),
        scene(point+vec3(0.0,0.0,eps))-scene(point-vec3(0.0,0.0,eps))
    ));
}

// Function 1868
vec3 refraction(vec3 I, vec3 N, float refractive_index) { // Snell's law
  float cosi = -max(-1.0, min(1.0, dot(I,N)));
  float etai = 1.0, etat = refractive_index;
  vec3 n = N;
  // if the ray is inside the object, swap the indices and
  // invert the normal to get the correct result  
  if (cosi < 0.0) {
    cosi = -cosi;
    float tmp = etai; etai = etat; etat = tmp; // swap
    n = -N;
  }
  float eta = etai / etat;
  float k = 1.0 - eta*eta*(1.0 - cosi*cosi);
  return k < 0.0 ? vec3(0) : I*eta + n*(eta * cosi - sqrt(k));
}

// Function 1869
bool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == box.m_Id)
		return false;
	
	float rayMinTime = 0.0;
	float rayMaxTime = FLT_MAX;
	
	//enforce a max distance
	if(info.m_collisionTime >= 0.0)
	{
		rayMaxTime = info.m_collisionTime;
	}	
	
	// find the intersection of the intersection times of each axis to see if / where the
	// ray hits.
	for(int axis = 0; axis < 3; ++axis)
	{
		//calculate the min and max of the box on this axis
		float axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;
		float axisMax = axisMin + box.m_scale[axis];

		//if the ray is paralel with this axis
		if(abs(rayDir[axis]) < 0.0001)
		{
			//if the ray isn't in the box, bail out we know there's no intersection
			if(rayPos[axis] < axisMin || rayPos[axis] > axisMax)
				return false;
		}
		else
		{
			//figure out the intersection times of the ray with the 2 values of this axis
			float axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];
			float axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];

			//make sure min < max
			if(axisMinTime > axisMaxTime)
			{
				float temp = axisMinTime;
				axisMinTime = axisMaxTime;
				axisMaxTime = temp;
			}

			//union this time slice with our running total time slice
			if(axisMinTime > rayMinTime)
				rayMinTime = axisMinTime;

			if(axisMaxTime < rayMaxTime)
				rayMaxTime = axisMaxTime;

			//if our time slice shrinks to below zero of a time window, we don't intersect
			if(rayMinTime > rayMaxTime)
				return false;
		}
	}
	
	//if we got here, we do intersect, return our collision info
	info.m_fromInside = (rayMinTime == 0.0);
	if(info.m_fromInside)
		info.m_collisionTime = rayMaxTime;
	else
		info.m_collisionTime = rayMinTime;
	info.m_material = box.m_material;
	
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// figure out the surface normal by figuring out which axis we are closest to
	float closestDist = FLT_MAX;
	for(int axis = 0; axis < 3; ++axis)
	{
		float distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);
		float distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));

		if(distFromEdge < closestDist)
		{
			closestDist = distFromEdge;
			info.m_surfaceNormal = vec3(0.0,0.0,0.0);
			if(info.m_intersectionPoint[axis] < box.m_pos[axis])
				info.m_surfaceNormal[axis] = -1.0;
			else
				info.m_surfaceNormal[axis] =  1.0;
		}
	}

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = box.m_Id;
	return true;	
}

// Function 1870
vec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )
{
	vec4 sum = vec4( 0.0 );

	float t = 0.0;

    // dithering	
	t += 0.05*textureLod( iChannel0, pixel.xy/iChannelResolution[0].x, 0.0 ).x;
	
	for( int i=0; i<100; i++ )
	{
		if( sum.a > 0.99 ) break;
		
		vec3 pos = ro + t*rd;
		vec4 col = map( pos );
		
		col.xyz *= mix( 3.1*vec3(1.0,0.5,0.05), vec3(0.48,0.53,0.5), clamp( (pos.y-0.2)/2.0, 0.0, 1.0 ) );
		
		col.a *= 0.6;
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	

		t += 0.05;
	}

	return clamp( sum.xyz, 0.0, 1.0 );
}

// Function 1871
vec3 GetNormal(vec3 color)
{
    vec3 n = vec3(0., 0., -1.);
    float lum = dot(color, vec3(0.2126, 0.7152, 0.0722));
    n.z = -lum;
    n *= RotX(((1.-color.r)*2.-1.)*PI*0.5);
    n *= RotY(((1.-color.g)*2.-1.)*PI*0.5);
    
    return normalize(n);
}

// Function 1872
vec4 raymarch( in vec3 ro, in vec3 rd, in vec2 nfplane )
{
    float glow = 0.;
	vec3 p = ro+rd*nfplane.x;
	float t = 0.;
	for(int i=0; i<256; i++)
	{
        float d = map(p)*.8;
        t += d;
        p += rd*d;
		glow += 1./256.;
		if( d < 0.0001 || t > nfplane.y )
            break;
            
	}
	
	return vec4(p,glow);
}

// Function 1873
vec3 bumpTexNormal(vec2 uv) {
    vec2 uvPixel = 1.0 / iResolution.xy;
    float hSA = bumpTex(uv + vec2(-uvPixel.s, 0.0)).a;
    float hSB = bumpTex(uv + vec2( uvPixel.s, 0.0)).a;
    float hTA = bumpTex(uv + vec2(0.0,-uvPixel.t)).a;
    float hTB = bumpTex(uv + vec2(0.0, uvPixel.t)).a;

    vec2 dhdt = vec2(hSB-hSA, hTB-hTA) / (2.0 * uvPixel);
    vec2 gradh = BUMP_TEX_DEPTH * dhdt;
    return normalize(vec3( -gradh, 1.0 ));
}

// Function 1874
vec3 textureNormal(vec2 uv) {
    vec3 normal = texture( iChannel1, 100.0 * uv ).rgb;
    normal.xy = 2.0 * normal.xy - 1.0;
    normal.z = sqrt(iMouse.x / iResolution.x);
    return normalize( normal );
}

// Function 1875
vec2 raymarch(vec3 ro, vec3 rd) {
	float tmin = 0.0;
	float tmax = Far;

	float precis = 0.0002;
	float t = tmin;
	float m = MAT_NONE;

	for (int i = 0; i < MaxSteps; i++) {
		vec2 res = abs(map(ro + rd * t));

		if (res.x < precis || t > tmax) {
			break;
		}
		t += res.x * MarchDumping;
		m = res.y;
	}

	if (t > tmax) {
		m = MAT_NONE;
	}
	return vec2(t, m);
}

// Function 1876
float pack_normal(vec2 n) {
    vec2 s = sign(n);
    return (n.y*s.x - s.y*(n.x + s.x - 2.0)) * 0.25;
}

// Function 1877
vec3 soupNormal( in float x, in float y )
{
    return normalize( vec3(soup(x-SAMP_DIST,y) - soup(x+SAMP_DIST,y),
                           2.0*SAMP_DIST, 
                           soup(x,y-SAMP_DIST) - soup(x,y+SAMP_DIST)) );
}

// Function 1878
float rayMarch(vec3 origin, vec3 dir)
{
    float dist = 0.0;
    for (int i =0; i < 256; ++i)
    {
        vec3 pos = origin + dir*dist;
        float h = scene(pos);
        if (h < 0.001) break;
        dist += h;
    }
    return dist;
}

// Function 1879
rayCastResults  getMouseRay(){
       
   vec4 mouseRay=  texture(iChannel3, vec2(0.));
   rayCastResults res;
   res.hit = mouseRay.a!=0.;
   res.mapPos = mouseRay.rgb;
    
   float eN = mouseRay.a -1.;
   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  
   return res;
}

// Function 1880
vec3 lnormalize(vec3 p) {
  return p/sqrt(rdot(p,p));
}

// Function 1881
vec3 CAM_getRay(Cam cam,vec2 uv)
{
    uv *= CAM_FOV;
    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);
}

// Function 1882
vec3 normal(vec3 pos, float t) {
	vec2  eps = vec2( 0.002*t, 0.0 );
    return normalize( vec3( fbmH(pos.xz-eps.xy) - fbmH(pos.xz+eps.xy),
                            2.0*eps.x,
                            fbmH(pos.xz-eps.yx) - fbmH(pos.xz+eps.yx) ) );
}

// Function 1883
vec3 normalEstimation(vec3 pos, float hd){
  vec2 k = vec2(hd, 0);
  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),
	  					sdf(pos + k.yxy) - sdf(pos - k.yxy),
  						sdf(pos + k.yyx) - sdf(pos - k.yyx)));
}

// Function 1884
vec3 SampleNormalMap(in vec2 uv, in float height)
{
    const float strength = 40.0;    
    float d0 = SampleTexture(uv.xy);
    float dX = SampleTexture(uv.xy - vec2(EPSILON, 0.0));
    float dY = SampleTexture(uv.xy - vec2(0.0, EPSILON));
    return normalize(vec3((dX - d0) * strength, (dY - d0) * strength, 1.0));
}

// Function 1885
vec3 refractFix(vec3 I, vec3 N, float eta) {
    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
    return k < 0.0
        ? reflect(I, N) // <- 'refract' returns 0 here
    	: eta * I - (eta * dot(N, I) + sqrt(k)) * N;
}

// Function 1886
vec3 gradientNormal(vec3 p) {
    return normalize(vec3(
        map(p + vec3(GRADIENT_DELTA, 0, 0)).y - map(p - vec3(GRADIENT_DELTA, 0, 0)).y,
        map(p + vec3(0, GRADIENT_DELTA, 0)).y - map(p - vec3(0, GRADIENT_DELTA, 0)).y,
        map(p + vec3(0, 0, GRADIENT_DELTA)).y - map(p - vec3(0, 0, GRADIENT_DELTA)).y));
}

// Function 1887
void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, in vec2 fragCoord, out C_Ray ray)
{
	vec2 vPixelCoord = fragCoord.xy;
	#ifdef ENABLE_MONTE_CARLO
	vPixelCoord += gPixelRandom.zw;
	#endif
	vec2 vUV = ( vPixelCoord / iResolution.xy );
	vec2 vViewCoord = vUV * 2.0 - 1.0;

	vViewCoord *= 0.75;
	
	float fRatio = iResolution.x / iResolution.y;

	vViewCoord.y /= fRatio;                            

	ray.vOrigin = vPos;

	vec3 vRight = normalize(cross(vForwards, vWorldUp));
	vec3 vUp = cross(vRight, vForwards);
	     
	ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);         
}

// Function 1888
vec3 raymarche( in vec3 ro, in vec3 rd, in vec2 nfplane )
{
	vec3 p = ro+rd*nfplane.x;
	float t = 0.;
	for(int i=0; i<1256; i++)
	{
        float d = map(p);
        t += d;
        p += rd*d;
		if( t > nfplane.y )
            break;
            
	}
	
	return p;
}

// Function 1889
vec3 EyeRay(vec2 fragCoord, vec3 eyeDir)
{
  	vec2 uv = fragCoord.xy / iResolution.xy; 
  	uv = uv * 2.0 - 1.0;
  	uv.x *= iResolution.x / iResolution.y;

    vec3 forward = normalize(eyeDir);
	vec3 right   = normalize(cross(vec3(.0, 1., .0), forward));
	vec3 up      = normalize(cross(forward, right));    

	return normalize(uv.x * right + uv.y * up + forward * FOV);
}

// Function 1890
bool rayMarching(in vec3 origin, in vec3 ray, out vec3 m, out int material) {
    
    float	marchingDist = 0.0;
    float 	nbIter 		 = 0.0;

    for(int i = 0; i<1000; i++) {
        
        m = origin + ray * marchingDist;    
        
    	float dist = map(m, material);
        
        if(dist < 0.000001) {
            return true;
        }
        else {
            marchingDist += dist;
            
            if(marchingDist >= 500.) {
                break;
            }
        }
    }
    
	return false;    
}

// Function 1891
float castVRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	float res = 1.0;
	
	vec2 mm = step( dis.xy, dis.yx ); 
	dis += mm * ris;
    pos += mm * rs;

	for( int i=0; i<48; i++ ) 
	{
		float ma = map(pos);
		vec3  ce = vec3( pos.x+0.5, ma, pos.y+0.5 );
		vec3  rc = ro - ce;
		
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.45*0.45;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t = (-b - sqrt( h ))/a;
			if( (ro.y+t*rd.y)<ma )
			{
				res = 0.0;
    			break; 
			}
			b = dot( rd, rc );
			c = dot( rc, rc ) - 0.45*0.45;
			h = b*b - c;
			if( h>0.0 )
			{
				res = 0.0;
			 	break;
			}			
		}

		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}


	return res;
}

// Function 1892
vec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst)
{
    vec2 dst = SDF(pos);
    //return dst;
    
    float t = 0.0;
    
    while (dst.x > minDst && t < maxDst)
    {
        t += dst.x;
        pos += dst.x * dir;
        dst = SDF(pos);
    }
    
    return vec2(t + dst.x, dst.y);
}

// Function 1893
define ARRAY_PRINT( STATE, STYLE, SAMPLER, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, SAMPLER, CHAR_ARRAY[i] ); }

// Function 1894
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.05;	//0.0005
    return normalize( e.xyy*map( pos + e.xyy*eps ) + 
					  e.yyx*map( pos + e.yyx*eps ) + 
					  e.yxy*map( pos + e.yxy*eps ) + 
					  e.xxx*map( pos + e.xxx*eps ) );
}

// Function 1895
vec3 getViewRay(vec2 px, float hfov)
{
    vec2 xy = px - iResolution.xy * 0.5;
    float z = iResolution.y / tan(radians(hfov));
    vec3 d = normalize(vec3(xy, z));
    if (iMouse.x > 0.0) {// Don't use the initial mouse position
    	pR(d.yz, iMouse.y / iResolution.y * 2.0 - 1.0);
    	pR(d.xz, iMouse.x / iResolution.x * 2.0 - 1.0);
    }
    return d;
}

// Function 1896
float ray(vec3 ro, vec3 rd, float t) 
{
    vec3 p = ro+t*rd;
    float h = 0.0;
    for (int i=0;i<50;i++) {
        float h = p.y-srf(p.xz,ITERS_RAY, iTime).x;
        t+=h;
        p+=rd*h;
        if (h<EPS*t) return t;
    }
    return t;
}

// Function 1897
vec3 pixtoray(vec2 uv)
{
    vec3 pixpos;
    pixpos.xy = uv - 0.5;
    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction
    pixpos.z = -0.6; // Focal length (Controls field of view)
    return normalize(pixpos);
}

// Function 1898
vec3 GetNormal(vec3 p) {
	float d = GetDist(p).x;
    vec2 e = vec2(.001, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy).x,
        GetDist(p-e.yxy).x,
        GetDist(p-e.yyx).x);
    
    return normalize(n);
}

// Function 1899
vec3 GetNormal(vec3 p)
{
    int dummy = 0;
    float d = CombineSDF(vec3(p.x , p.y, p.z), dummy);
    return 
    normalize(vec3(
		CombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - d,
		CombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - d,
		CombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - d
		));
}

// Function 1900
vec3 calcRay(vec2 uv, float fov, float aspect) {
    uv = uv * 2.0 - 1.0;
    float d = 1.0 / tan(radians(fov) * 0.5);
    return normalize(vec3(aspect * uv.x, uv.y, d));
}

// Function 1901
vec3 raycolor(vec3 p, vec3 r, vec3 light) {
  vec3 n;
  int type = intersectscene(p,r,n);
  if (type == 0) {
    return vec3(0);
  } else {
    float ambient = 0.3;
    float diffuse = 0.3;
    vec3 basecolor = getcolor(n);
    if (type == 2) basecolor *= 0.8;
    vec3 color = basecolor*(ambient+diffuse*max(0.0,dot(light,n)));
    float specular = pow(max(0.0,dot(reflect(light,n),r)),5.0);
    //vec3 speccol = vec3(1);
    vec3 speccol = basecolor;
    color += 0.5*specular*speccol;
    return color;
  }
}

// Function 1902
vec3 calcNormal( in vec3 pos, in float eps )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapTotal( pos + e.xyy ) + 
					  e.yyx*mapTotal( pos + e.yyx ) + 
					  e.yxy*mapTotal( pos + e.yxy ) + 
					  e.xxx*mapTotal( pos + e.xxx ) );
#else
    // trick by klems, to prevent the compiler from inlining map() 4 times
    vec4 n = vec4(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        s[i] += eps;
        n[i] = mapTotal(s.xyz);
    }
    return normalize(n.xyz-n.w);
#endif    
   
}

// Function 1903
void calcRayForPixel(vec2 pix, out vec3 rayOrigin, out vec3 rayDir) {
    // Mouse controlled focal distance and viewpoint spread
    float screenWidth = (iResolution.x/iResolution.y) * screenSize;
    float focalLeft   = -((iMouse.x/iResolution.x)-0.45)*2.0;  
    float focalRight  = screenWidth - focalLeft;
    float focalDist   = -1.0-(iMouse.y/iResolution.y) * 5.0; // -2.0 is a good default
    
    // Normalized pixel coordinates (from 0 to 1)
    vec2 screenCoord = pix/iResolution.xy;
    
    // Get the current view for this subpixel
    float view = screenCoord.x;
	view += screenCoord.y * slope;
	view *= pitch;
	view -= center;
	view = 1.0 - mod(view + ceil(abs(view)), 1.0);
    
    // Calculate the ray dir assuming pixels of a given view converge
    // at points along a line segment floating "focalDist" above the display.
    // TODO: Take into account the refraction of the acrylic, which changes
    // the rays' angle of attack as they converge on pxFoc
    vec3 pxPos = vec3(screenCoord.x * screenWidth, screenCoord.y * screenSize, 0.0);
    vec3 pxFoc = vec3(mix(focalLeft, focalRight, view), 0.5, focalDist);
    vec3 pxDir = pxFoc - pxPos; pxDir /= length(pxDir);
    vec3 pxOri = pxPos + (1.0 * pxDir); // <- Increase for protruding objects
    rayOrigin  = pxOri; rayDir = -pxDir;
    
    // Offset and Swizzle for IQ's Coordinate System
    rayOrigin = vec3(-rayOrigin.z, rayOrigin.y, rayOrigin.x) + vec3(3.2,0.0,-0.9);
    rayDir = vec3(-rayDir.z, rayDir.y, rayDir.x);
}

// Function 1904
vec2 RayMarch(vec3 ro, vec3 rd){
    // distance from origin
    vec2 dO=vec2(0.,0.);
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO.x*rd;
        
        // get distance to seam
        vec2 ds = GetDist(p);
        //move origin to new point
        dO+=ds.x*.5;
        if(ds.x < SURFACE_DIST){
            dO.y = ds.y;
            break;
        }
        else if( dO.x > MAX_DIST){
            dO.y= -1.;
            break;
        }
    }
    return dO;
}

// Function 1905
float toGray(float dist)
{
    float fH = 0.5f * fwidth(dist);
    
    return( smoothstep(fH, -fH, dist) );
}

// Function 1906
bool castray_ball(vec3 orig,vec3 dir,int idx,out vec3 hitp,out vec3 hitnor,out vec4 col,out float mirr,vec3 pos,float rad)
{
	mirr = 0.95;
	col = vec4(0.8,0.3,0.2,1.);
	vec3 m = orig-pos;
	float b = dot(m,dir);
	float c = dot(m,m)-rad*rad;
	if(c>0.&&b>0.)return false; // pointing away.
	float discr = b*b-c;
	if(discr<0.)return false; // miss.
	float t = -b-sqrt(discr);  // distance?

	if(t<=0.)return false; // started inside.
	hitp = orig + dir*t;
	hitnor = normalize(hitp-pos);
	return true;
}

// Function 1907
vec2 ray_box(in ray r, in vec3 pos, in vec3 size) 
{
    vec3 m = 1.0 / r.dir; // can precompute if traversing a set of aligned boxes
    vec3 n = m * (r.pos - pos);   // can precompute if traversing a set of aligned boxes
    vec3 k = abs(m) * size;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
    float t_near = max( max( t1.x, t1.y ), t1.z );
    float t_far = min( min( t2.x, t2.y ), t2.z );
    
    if( t_near > t_far || t_far < 0.0) 
        return vec2(1000,-1000); // no intersection
        
    return vec2(t_near,t_far);
}

// Function 1908
vec3 calcNormal(vec3 pos){
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 nor = vec3(
        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,
        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,
        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );
    return normalize(nor);
}

// Function 1909
vec3 trn_normalmapLod( vec3 pos, float scale )
{
    float lod = log2( scale / 0.001 );
    return .15 * texturenoiseLod( pos / 0.01, lod - 3.322 ).xyz +
        .35 * texturenoiseLod( pos / 0.003, lod - 1.585 ).xyz +
        .35 * texturenoiseLod( pos / 0.001, lod ).xyz +
        .15 * texturenoiseLod( pos / 0.0003, lod + 1.585 ).xyz;
}

// Function 1910
vec3 Normal( vec3 u,vec3 ray,float f){
;float e=2.*f/iResolution.x;
#ifdef FAST
// don't sample smaller than the interpolation errors in Noise()
;e=max(e,.001);
#endif	
;vec2 d=vec2(-1,1) * e;
;vec3 p0=u+d.xxx,p1=u+d.xyy,p2=u+d.yxy,p3=u+d.yyx
;e=dg(p0,f)
;float b=dg(p1,f),c=dg(p2,f);f=dg(p3,f)
	
;vec3 g = p0*e+p1*b+p2*c+p3*f - u*(b+c+f+e)
;return normalize(g-max(.0,dot(g,ray))*ray)
;}

// Function 1911
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 250; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1912
RayTraceResult RayTraceRoom(in Ray ray)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
    vec3 dir[6];
    dir[0] = vec3(+1.,0.,0.);
    dir[1] = vec3(-1.,0.,0.);
    dir[2] = vec3(0.,+1.,0.);
    dir[3] = vec3(0.,-1.,0.);
    dir[4] = vec3(0.,0.,-1.);
    dir[5] = vec3(0.,0.,+1.);
    
    float fMaxSqrDist = infinite;
    
    for (int i=0; i<6; ++i)
    {
        vec3 pos = roomSize*dir[i];
        vec3 nn = dir[i];
        
        RayTraceResult current = RayTracePlane(ray, pos, nn);
        if (current.t < fMaxSqrDist)
        {
            fMaxSqrDist = current.t;
            res = current;
        }
    }
    
    return res;
}

// Function 1913
vec3 calcNormal(in vec3 p) {
  const vec2 e = vec2(0.0001, 0.0);
  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),
                        eval(p + e.yxy) - eval(p - e.yxy),
                        eval(p + e.yyx) - eval(p - e.yyx)));
}

// Function 1914
Ray cameraGetRay(in Camera cam,in float2 uv)
{
    float3 rd = cam.lens_radius*random_in_unit_disk();
    float3 offset = cam.u * rd.x + cam.v * rd.y;
	return Ray(cam.origin + offset,cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin - offset);
}

// Function 1915
float raySphereIntersect(Ray ray, float radius)
{
    // note to future me: don't need "a" bcuz rd is normalized and dot(rd, rd) = 1
 	float b = 2. * dot(ray.origin, ray.direction);
    float c = dot(ray.origin, ray.origin) - radius * radius;
    float d = sqrt(b * b - 4. * c);
    return (-b + d) * .5;
}

// Function 1916
vec3 calcNormalTransparent( in vec3 pos, in float eps )
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + 
                      e.yyx*mapTransparent( pos + e.yyx, kk ).x + 
                      e.yxy*mapTransparent( pos + e.yxy, kk ).x + 
                      e.xxx*mapTransparent( pos + e.xxx, kk ).x );
}

// Function 1917
vec3 calcNormal( in vec3 p, float h)
{
    #define ZERO (min(int(iTime),0)) // non-constant zero
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(p+e*h).x;
    }
    return normalize(n);
}

// Function 1918
vec3 getNormal(vec3 p) {
    int id;
    return normalize(vec3(
        getSDF(vec3(p.x + EPSILON, p.y, p.z), id) - 
        getSDF(vec3(p.x - EPSILON, p.y, p.z), id),
        getSDF(vec3(p.x, p.y + EPSILON, p.z), id) - 
        getSDF(vec3(p.x, p.y - EPSILON, p.z), id),
        getSDF(vec3(p.x, p.y, p.z + EPSILON), id) - 
        getSDF(vec3(p.x, p.y, p.z - EPSILON), id)
    ));
}

// Function 1919
vec2
raymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )
{
    MPt mp;
    for ( int it=0; it!=RAYM_MAX_ITERS; ++it )
    {
        vec3 here = start + dir * t;
        mp = map( here );
        #if DRAW_ITERATIONS_GRADIENT
        mp.y = mp.y * 10000.0 + float(it);
        #endif
        if ( mp.distance < ( T_EPS * t ) || t > t_max )
        {
        	break;
        }
        #if 1
        // NOTE(theGiallo): this is to sample nicely the twisted things
        t += mp.distance * 0.4;
        #else
        t += mp.distance;
        #endif
    }
    if ( t > t_max )
    {
        t = -1.0;
    }
    return mp;
}

// Function 1920
vec3 calcNormal(vec3 p) {
 
    vec2 e = vec2(EPSILON,0.);
    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),
                  dstScene(p+e.yxy)-dstScene(p-e.yxy),
                  dstScene(p+e.yyx)-dstScene(p-e.yyx));
    return normalize(n);
    
}

// Function 1921
vec3 calcNormal( in vec3 pos, in bool showSurface )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.0005;
    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface ).x + 
					  e.yyx*map( pos + e.yyx*eps, showSurface ).x + 
					  e.yxy*map( pos + e.yxy*eps, showSurface ).x + 
					  e.xxx*map( pos + e.xxx*eps, showSurface ).x );
}

// Function 1922
vec3 surfaceNormal (in vec3 pos) {
    vec3 normal = vec3(
        map(pos + xDir).x - map(pos - xDir).x,
        map(pos + yDir).x - map(pos - yDir).x,
        map(pos + zDir).x - map(pos - zDir).x
    );
    return normalize(normal);
}

// Function 1923
void minRay4Result ( inout Ray4Result _rayResultMin, in Ray4Result _curr )
{ 
    if ( _curr.m_d > _rayResultMin.m_d )
        return;
    
    _rayResultMin = _curr;
}

// Function 1924
vec3 getStarToRayVector(vec3 rayBase, vec3 rayDirection, vec3 starPosition) {
	float r = (dot(rayDirection, starPosition) - dot(rayDirection, rayBase)) / dot(rayDirection, rayDirection);
    vec3 pointOnRay = rayBase + r * rayDirection;
    return pointOnRay - starPosition;
}

// Function 1925
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).d - map(pos-eps.xyy).d,
	    map(pos+eps.yxy).d - map(pos-eps.yxy).d,
	    map(pos+eps.yyx).d - map(pos-eps.yyx).d );
	return normalize(nor);
}

// Function 1926
float TransObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 60; j ++) {
    d = TransObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1927
vec2
RayMarch(vec3 ro, vec3 rd)
{
    vec2 res = vec2(-1.0, -1.0);
    float t = 0.00;
    vec2 hit;

    for(int i =0 ; i < MAX_STEPS && t < MAX_DIST; ++i)
    {
        hit = Map(ro + t *rd);
        if(abs((hit.x)) < t * MIN_DIST)
        {
            res = vec2(t, hit.y);
            break;
        }

        t += hit.x;
    }
    
    return res;
}

// Function 1928
vec3 sdfNormal(vec3 p, float epsilon)
{
    vec3 eps = vec3(epsilon, -epsilon, 0.0);
    
	float dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);
	float dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);
	float dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); 

	return normalize(vec3(dX,dY,dZ));
}

// Function 1929
bool castRay(vec3 ro, vec3 rd, out float resT)
{
    const float mint = 0.001;
    const float maxt = 50.0;
    const float dt = 1.0;
    float lh = 0.0;
    float ly = 0.0;
    
    float t = mint;
    
    for (float t = mint; t < maxt; t += dt)
    {
        vec3 p = ro + rd * t;
        float h = f(p.x, p.z);
        if (p.y < h)
        {
            resT = t - dt + dt * (lh - ly) / (p.y - ly - h + lh);
            return true;
        }
        lh = h;
        ly = p.y;
    }
    
    return false;
}

// Function 1930
Result raymarchDE(Ray ray, float distfactor, float maxtravel)
{
	float travelled=0.0;
    for (int i=0; i<DE_ITERATIONS; i++)
    {
    	vec2 res = sceneSDF(ray.pos);
                        
        ray.pos += res.x*ray.dir*distfactor; 
        travelled += res.x*distfactor;
        
        if (travelled>maxtravel)
            break;
    }     
    
    Result result = resultsDE(ray.pos);
    result.travelled=travelled;
    return result;
}

// Function 1931
float lightRay(vec3 p, float phaseFunction, float dC, float mu, vec3 sun_direction, float cloudHeight, bool fast)
{
    int nbSampleLight = fast ? 7 : 20;
	float zMaxl         = 600.;
    float stepL         = zMaxl/float(nbSampleLight);
    
    float lighRayDen = 0.0;    
    p += sun_direction*stepL*hash(dot(p, vec3(12.256, 2.646, 6.356)) + iTime);
    for(int j=0; j<nbSampleLight; j++)
    {
        float cloudHeight;
        lighRayDen += clouds( p + sun_direction*float(j)*stepL, cloudHeight, fast);
    }    
    if(fast)
    {
        return (0.5*exp(-0.4*stepL*lighRayDen) + max(0.0, -mu*0.6+0.3)*exp(-0.02*stepL*lighRayDen))*phaseFunction;
    }
    float scatterAmount = mix(0.008, 1.0, smoothstep(0.96, 0.0, mu));
    float beersLaw = exp(-stepL*lighRayDen)+0.5*scatterAmount*exp(-0.1*stepL*lighRayDen)+scatterAmount*0.4*exp(-0.02*stepL*lighRayDen);
    return beersLaw * phaseFunction * mix(0.05 + 1.5*pow(min(1.0, dC*8.5), 0.3+5.5*cloudHeight), 1.0, clamp(lighRayDen*0.4, 0.0, 1.0));
}

// Function 1932
vec3 normal(in vec3 p, inout float edge) { 
	
    vec2 e = vec2(.034, 0); // Larger epsilon for greater sample spread, thus thicker edges.

    // Take some distance function measurements from either side of the hit point on all three axes.
	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;	// The hit point itself - Doubled to cut down on calculations. See below.
     
    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how
    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum
    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface 
    // curves that register a discernible difference.
    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.
    
    
    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you 
    // do that is up to you. This is what I came up with for now, but I might tweak it later.
    //
    edge = smoothstep(0., 1., sqrt(edge/e.x*8.));
    
    // Curvature. All this, just to take out the inner edges.
    float crv = (d1 + d2 + d3 + d4 + d5 + d6 - d*3.)/e.x;;
    //crv = clamp(crv*32., 0., 1.);
    if (crv<0.) edge = 0.; // Comment out to see what it does.

	
    // Redoing the calculations for the normal with a more precise epsilon value. If you can roll the 
    // edge and normal into one, it saves a lot of map calls. Unfortunately, we want wide edges, so
    // there are six more, making 12 map calls in all. Ouch! :)
    e = vec2(.005, 0);
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx); 
    
    // Return the normal.
    // Standard, normalized gradient mearsurement.
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 1933
Intersection RaySphere(Ray ray, Sphere sphere)
{
	Intersection i;
	i.dist = ZMAX;
	vec3 c = sphere.c;
	float r = sphere.r;
	vec3 e = c-ray.o;
	float a = dot(e, ray.dir);
	float b = r*r - dot(e,e) + a*a;
	if( b>0.0 )
	{
		float f = sqrt(b);
		float t = a - f;
		if(t > EPSILON)
		{
			i.p = ray.o + ray.dir*t;
			i.n = normalize(i.p-c);
			i.dist = t;
		}
	}
	return i;
}

// Function 1934
raysample RayMarch(vec3 rO, vec3 rD, int bounces, vec3 col) 
{
    //	Set Distance to Origin
    raysample dO = raysample(0., rO, 0, col);
    
    for (int i=0; i<MAX_STEPS; i++) 
    {
        //	Step Forward
        vec3 p = rO+dO.dist*rD;
        raysample dS = GetDist(p);
        dO.dist += dS.dist;
        dO.point = p;
        dO.material = dS.material;
        
        //	On surface? Can we stop?
        if (dS.dist<SURF_DIST) {
            //	Surface has been hit.
            //	Is it a mirror? Can we bounce?
            if (dO.material == 0 && bounces > 0) {
                //	Reflect ray
                rO = rO+dO.dist*rD;
                rD = reflect(rD, GetNormal(rO));
                rO = rO-dO.dist*rD;
                //	Nudge ray away from surface
                dO.dist += 2.0*SURF_DIST;
                //	Pick up some color
                dO.color *= M[dO.material].specular + M[dO.material].color * M[dO.material].diffuse;
                bounces--;
            } else {
                break;
            }
        }
        //	Tired of marching? Can we stop?
        if (dO.dist>MAX_DIST) break;
    }
    
    return dO;
}

// Function 1935
float RayMarch(vec3 ro, vec3 rd, float side) {
	float dO=0.;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p)*side;
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    return dO;
}

// Function 1936
vec3 calcNormal( in vec3 pos, in float t )
{
    vec2 e = vec2(1.0,-1.0)*surface*t;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 1937
vec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float maxd )
{
    float t = 0.001;
    float dsp = 0.0;
    float sid = -1.0;
    for( int i=0; i<128; i++ )
    {
	    vec3 res = map( ro+rd*t );
        if( abs(res.x)<(precis*t)||t>maxd ) break;
	    sid = res.y;
		dsp = res.z;
        t += res.x;
    }

    if( t>maxd ) sid=-1.0;
    return vec3( t, sid, dsp );
}

// Function 1938
vec3 XYFaceToRayDir(ivec3 p){
    vec2 x = vec2(p-512) + 0.5;
           if (p.z==0){     return vec3( 512,-x.y,-x.x);
    } else if (p.z==1){     return vec3( x.x, 512, x.y);
    } else if (p.z==2){     return vec3( x.x,-x.y, 512);
    } else if (p.z==3){     return vec3(-512,-x.y, x.x);
    } else if (p.z==4){     return vec3( x.x,-512,-x.y);
    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);
    } else return vec3(0);
}

// Function 1939
vec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){
    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));
    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);
    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;
    float fish = 1.0 - dot(uv, uv) * FISHEYE;
	return normalize(cameraDir*fish + uv.x * cameraPlaneU + uv.y * cameraPlaneV);

}

// Function 1940
vec3 normalT(vec3 p,vec3 ray,float t,vec4 m,mat4 B//4tap tetrahedral derivative in3d
){vec2 e=vec2(E.y,-E.y); 
 ;p=e.xyy*map(p+e.xyy).x
   +e.yyx*map(p+e.yyx).x
   +e.yxy*map(p+e.yxy).x
   +e.xxx*map(p+e.xxx).x
 ;if(p==vec3(0))return vec3(1)//NaN-evasion, normalize(vec3(0)) divides by /0. 
 ;return normalize(p);}

// Function 1941
vec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )
{
    // tetrahedron normal
    const float fDelta = 0.025;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;
    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;
    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;
    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 1942
void TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec4 hitInfo, inout vec3 hitDiffuse, inout vec3 hitEmissive, inout vec4 hitSpecular, inout bool hitSomething, in bool shadowRay)
{
    vec4 info = hitInfo; 
    vec2 uv;
    
    // a blue box
    mat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.0);
    mat4 tra = translate( -0.5, 0.0, 0.0 );
    mat4 txi = tra * rot; 
    mat4 txx = inverse( txi );    
    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.25), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        hitDiffuse = vec3(0.2, 0.2, 0.9);
        hitEmissive = vec3(0.0);
        hitSpecular = vec4(1.0, 1.0, 1.0, 10.0);
        hitInfo = info;
        hitSomething = true;
    }
    
    // the floor
    txi = translate( 0.0, -0.25, 0.0 );
    txx = inverse( txi );    
    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(10.0, 0.01, 10.0), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        float checkerBoard = (mod(floor(uv.x * 10.0) + floor(uv.y * 10.0), 2.0) < 1.0 ? 1.0 : 0.4);        
        hitDiffuse = vec3(checkerBoard);
        hitEmissive = vec3(0.0);
        hitSpecular = vec4(1.0, 1.0, 1.0, 1000.0);
        hitInfo = info;
        hitSomething = true;        
    }    

    // a red ball
    info = RayIntersectSphere(rayPos, rayDir, vec4(0.5, 0.25, 0.25, 0.5), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        hitDiffuse = vec3(0.9, 0.2, 0.2);
        hitEmissive = vec3(0.0);
        hitSpecular = vec4(1.0, 1.0, 1.0, 100.0);
        hitInfo = info;
        hitSomething = true;        
    }    
    
    // a green ball
    info = RayIntersectSphere(rayPos, rayDir, vec4(-0.75, -0.125, -0.5, 0.125), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        hitDiffuse = vec3(0.2, 0.9, 0.2);
        hitEmissive = vec3(0.0);
        hitSpecular = vec4(1.0, 1.0, 1.0, 100.0);
        hitInfo = info;
        hitSomething = true;        
    }     
    
    // a magenta box
    rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), 1.9);
    tra = translate( -0.1, -0.125, -1.0 );
    txi = tra * rot; 
    txx = inverse( txi );    
    info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(0.125), uv);
    if (info.x > 0.0 && info.x < hitInfo.x) {
        hitDiffuse = vec3(0.9, 0.2, 0.9);
        hitEmissive = vec3(0.0);
        hitSpecular = vec4(1.0, 1.0, 1.0, 10.0);
        hitInfo = info;
        hitSomething = true;
    }    

    // test the light source
    txi = GetDirectionalLightMatrixInverse();
    txx = GetDirectionalLightMatrix();        
	info = RayIntersectBox(rayPos, rayDir, txx, txi, vec3(directionalLightExtents.x, 0.001, directionalLightExtents.y), uv);    
    
    // if ever a shadow ray hits the light source as the closest intersection, return a miss, so we don't get shadows from behind the light source!
    if (shadowRay)
    {
        if (info.x > 0.0 && info.x < hitInfo.x) {
            hitDiffuse = vec3(0.0);
            hitEmissive = vec3(0.0);
            hitSpecular = vec4(0.0);
            hitInfo = vec4(1000.0, -cameraFwd);
            hitSomething = false;        
        }        
    }
    // else if we are not doing a shadow ray, and the mode is >= 4, then we want to show the light source as an object
    else if (GetMode() >= 4.0)
    {
        if (info.x > 0.0 && info.x < hitInfo.x) {
            vec3 lightpos = WorldSpaceToDirectionalLightSpace(rayPos+rayDir*info.x);
            vec2 lightuv = vec2(-lightpos.x, lightpos.z);
            hitDiffuse = vec3(0.0);
            float backSideBlack = step(0.0, lightpos.y);            
            hitEmissive = clamp((texture(iChannel0, lightuv*0.5+0.5).rgb * directionalLightTextureMADD.x + directionalLightTextureMADD.y) * backSideBlack, 0.0, 1.0);
            hitSpecular = vec4(1.0, 1.0, 1.0, 1000.0);
            hitInfo = info;
            hitSomething = true;        
        }    
    }
}

// Function 1943
bool raytrace_mesh(in Ray R, inout Intersection I) {
    int prev_id = I.id; // index of latest intersected triangle
    bool result = false;  
    // ... But I still keep a single AABB around the whole mesh.
    // We could do without it, but it gains a couple of FPS.
    vec3 invDir = vec3(1.0/R.Dir.x, 1.0/R.Dir.y, 1.0/R.Dir.z);
    if(!segment_box_intersection(R.Origin, invDir, scale*bbox_min, scale*bbox_max, I.t)) {
        return false;
    }
    for(int i=0; i<triangles.length(); ++i) {
       if(i == prev_id) { continue; } // skip latest triangle
       bool t_isect = triangle(R, i, I);
       result = result || t_isect;
    }
    if(result) { // Interpolating between facetted and smooth shading, just for fun.
        I.N = mix(normalize(I.N), normalize(I.Nsmooth), smoothness);
        I.N = normalize(I.N); 
    }
    return result;
}

// Function 1944
vec3 sphereNormal( in vec3 pos, in vec4 sph )
{
  return normalize(pos - sph.xyz);
}

// Function 1945
vec3 getNormal(vec2 uv, int tex ) {
#ifdef NORMAL_MAPS
    float heightScale = 0.004;
    float dHdU, dHdV;
    
    float hpx, hmx, hpy, hmy, h0;
    vec3 c, c1, c2, c3, c4;
    vec2 duv;
    
#if __VERSION__ < 300
    if(tex==0){
        GET_COLORS(0, 0);
    } else if(tex==1) {
        GET_COLORS(1, 1);
    } else {
        GET_COLORS(2, 2);
    }
#else
    switch(tex){
        case 0: {GET_COLORS(0, 0);}
        case 1: {GET_COLORS(1, 1);}
        case 2: {GET_COLORS(2, 2);}
    }
#endif
    
    h0	= heightScale * dot(c , vec3(1.0/3.0));
    hpx = heightScale * dot(c1, vec3(1.0/3.0));
    hmx = heightScale * dot(c2, vec3(1.0/3.0));
    hpy = heightScale * dot(c3, vec3(1.0/3.0));
    hmy = heightScale * dot(c4, vec3(1.0/3.0));
    dHdU = (hmx - hpx) / (2.0 * duv.x);
    dHdV = (hmy - hpy) / (2.0 * duv.y);
    
    return normalize(vec3(dHdU, dHdV, 1.0));
#else
    return vec3(0.0, 0.0, 1.0);
#endif
}

// Function 1946
vec3 getNormal( in vec3 pos )
{
	vec2 eps = vec2( EPS_NOR, 0.0 );	
	vec3 nor = vec3(
		map(pos+eps.xyy).d - map(pos-eps.xyy).d,
		map(pos+eps.yxy).d - map(pos-eps.yxy).d,
		map(pos+eps.yyx).d - map(pos-eps.yyx).d );
    
	return normalize(nor);
}

// Function 1947
void GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)
{
    vec2 vUV = ( fragCoord.xy / iResolution.xy );
    vec2 vViewCoord = vUV * 2.0 - 1.0;

    float fRatio = iResolution.x / iResolution.y;
    vViewCoord.y /= fRatio;                          

    ray.vOrigin = vPos;

    vec3 vRight = normalize(cross(vForwards, vWorldUp));
    vec3 vUp = cross(vRight, vForwards);
        
    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); 
    ray.fStartDistance = 0.0;
    ray.fLength = kFarClip;      
}

// Function 1948
Hit raymarch(Ray ray) {
 
    vec3 p = ray.ori;
    int id = -1;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        Dst dst = dstScene(p);
        p += ray.dir * dst.dst * .75;
        
        if(dst.dst <= MIN_DISTANCE) {
         
            id = dst.id;
            break;
            
        }
        
    }
    
    return Hit(p,id);
    
}

// Function 1949
vec3 raymarch( in vec3 ro, in vec3 rd, in vec2 ani, in vec2 pixel )
{
    // background color	
	vec3 bgc = vec3(0.6,0.7,0.7) + 0.3*rd.y;
    bgc *= 0.2;
	

    // dithering	
	float t = 0.03*texture( iChannel0, pixel.xy/iChannelResolution[0].x ).x;

    // raymarch	
	vec4 sum = vec4( 0.0 );
	for( int i=0; i<150; i++ )
	{
		if( sum.a > 0.99 ) continue;
		
		vec3 pos = ro + t*rd;
		vec4 col = map( pos, ani );

        // lighting		
		float dif = 0.1 + 0.4*(col.w - map( pos + lig*0.15, ani ).w);
		col.xyz += dif;

        // fog		
		col.xyz = mix( col.xyz, bgc, 1.0-exp(-0.005*t*t) );
		
		col.rgb *= col.a;
		sum = sum + col*(1.0 - sum.a);	

        // advance ray with LOD
		t += 0.03+t*0.012;
	}

    // blend with background	
	sum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );
	
	return clamp( sum.xyz, 0.0, 1.0 );
}

// Function 1950
vec2 raymarch(in vec3 ro, in vec3 rd)
{
    float t = MIN_TRACE_DIST;
    vec2 h;
    for(int i=0; i<MAX_TRACE_STEPS; i++)
    {
        h = map(ro + t * rd);
        if (h.x < PRECISION * (t*0.125+1.))
            return vec2(t, h.y);

        if (t > MAX_TRACE_DIST)
            break;

        t += h.x;
    }
    return vec2(-1.0);
}

// Function 1951
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1952
float RayMarching(vec2 screen_pos, float near, float far)
{
	const int steps = 128;
	float delta = 1.0/float(steps);
	
	
	for (int i=0; i<steps; ++i)
	{
		vec3 pos = vec3(screen_pos, float(i)*delta);
		
		//ortho inv trans
		pos += vec3(0.0, 0.0, near/(far-near));//obj pos
		pos.z *= (far-near);
		
		//view inv trans
		//pass
		
		
		
		//world inv trans
		vec3 pos1 = pos - vec3(-0.5, 0, 1.0);
		float scale = 0.4;
		pos1 = Transform(pos1, vec3(iTime, iTime*0.2, iTime*0.1), 1.0/scale);
		if (HitC(pos1, 0.5, 1.0,0.9))
		//if (HitUnitCircle(pos))
		{
			return 1.0-float(i)*delta;
		}
		
		
		//world inv trans
		vec3 pos2 = pos - vec3(0.5, 0, 1.0);
		float scale2 = 0.4;
		pos2 = Transform(pos2, vec3(0.0, iTime*0.5, 0.0), 1.0/scale);
		if (HitY(pos2, 0.5, 0.2, 1.0))
		{
			return 1.0-float(i)*delta;
		}
	}
	return -1.0;
}

// Function 1953
vec3 getNormal(vec2 p)
{
	vec3 j = vec3(1.0/iChannelResolution[0].xy, 0.0);
	vec3 nor  	= vec3(0.0,		textureLod(iChannel0,fract(p), 0.0).w, 0.0);
	vec3 v2		= nor-vec3(j.x,	textureLod(iChannel0,fract(p+j.xz), 0.0).w, 0.0);
	vec3 v3		= nor-vec3(0.0,	textureLod(iChannel0,fract(p-j.zy), 0.0).w, -j.y);
	nor = cross(v2, v3);
	return normalize(nor);
}

// Function 1954
vec3 computeNormal(vec3 pos, vec3 lightPos)
{
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),
                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),
                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));
}

// Function 1955
void maxRay4Result ( inout Ray4Result _rayResultMax, in float _min, in float _max, in Ray4Result _curr )
{
    if ( _curr.m_d < _min )
        return;
    
    if ( _curr.m_d > _max )
        return;
    
    if ( _curr.m_d < _rayResultMax.m_d )
        return;
    
	_rayResultMax = _curr;
}

// Function 1956
float F0FromReflectance(float reflectance)
{
    return reflectance * reflectance * 0.16;
}

// Function 1957
vec3 normal(vec3 p)
{
	const float eps = 0.01;
	float m = 0.0;
    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z), m) - distf(vec3(p.x+eps,p.y,p.z), m)),
                   (distf(vec3(p.x,p.y-eps,p.z), m) - distf(vec3(p.x,p.y+eps,p.z), m)),
                   (distf(vec3(p.x,p.y,p.z-eps), m) - distf(vec3(p.x,p.y,p.z+eps), m))
				 );
    return normalize(n);
}

// Function 1958
vec3 normal (in vec3 p)
{
    float d = map (p);
    vec3 e = vec3 (.001, .0, .0);
    vec3 n = vec3 (map (p + e.xyy) - d,
                   map (p + e.yxy) - d,
                   map (p + e.yyx) - d);

    return normalize (n);
}

// Function 1959
vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l - p),
        r = normalize(cross(vec3(0., 1., 0.), f)),
        u = cross(f, r),
        c = f * z,
        i = c + uv.x * r + uv.y * u,
        d = normalize(i);
    return d;
}

// Function 1960
vec3 castRay( in vec3 ro, in vec3 rd, in float maxd ) {
	float precis = 0.001;	// when to call a hit
    float h=precis*2.0;		// howmuch to move along the ray
    float t = 0.0;			// moved already
    vec2 m = vec2(-1.0);	// color/uv, depends on use, here - uv
    vec3 pos = vec3(0.0);	// 3d position
    for( int i=0; i<60; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;	// voila
        t += h;					//  move
        pos = ro+rd*t;			// update current 3d position
	    vec2 res = map( pos );	// get de
        h = res.x;				// get de
	    m = vec2(res.y);		// uv/color
    }
    // corrections of uv
    if( abs(pos.x)<0.5 && pos.y>0.99 && abs(pos.z)<0.5) { m= vec2(.5+pos.x, .5+pos.z); }
    else {	m = vec2(pos.x/10.5+1.5, pos.z/10.5+1.5);	}
    // it was a good day :)
    return vec3( t, m );
}

// Function 1961
vec3 normal(vec3 rp)
{
    vec3 eps = vec3( 0.002 ,0.0,0.0);
	return normalize( vec3(
           map(rp+eps.xyy).a - map(rp-eps.xyy).a,
           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   
           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );

}

// Function 1962
vec3 normal(in vec3 p)
{
    // Took this pretty much straight from Ignacio's code, it computes the differentials in
    // three axes. That's our distance field gradient and our "normal".
	vec3 stepsize = vec3(0.01, 0.0, 0.0);
    vec3 N = vec3(
        scene_dist(p + stepsize.xyz) - scene_dist(p - stepsize.xyz),
        scene_dist(p + stepsize.yxz) - scene_dist(p - stepsize.yxz),
        scene_dist(p + stepsize.yzx) - scene_dist(p - stepsize.yzx));
    return normalize(N);
}

// Function 1963
vec3 normalEstimation(vec3 pos){
	float dist = distanceEstimation(pos);
	vec3 xDir = vec3(dist, 0, 0);
	vec3 yDir = vec3(0, dist, 0);
	vec3 zDir = vec3(0, 0, dist);
	return normalize(vec3(	distanceEstimation(pos + xDir),
							distanceEstimation(pos + yDir),
							distanceEstimation(pos + zDir))
					- vec3(dist));
}

// Function 1964
float multi_refract(inout Ray R, inout Intersection I) {
    float result = 0.0;
    for(int i=0; i<10; ++i) {
        if(dot(R.Dir,I.N) > 0.0) { // Exiting matter
            result += I.t;
            vec3 old_dir = R.Dir;
            I.N = -I.N;
            R = refract_ray(R, I, refract_index, 1.0);
            if(R.Dir == vec3(0)) { 
               R.Dir = reflect(old_dir, I.N); // total reflection  
            }
        } else { // Entering matter
            R = refract_ray(R, I, 1.0, refract_index);
            R.Dir = normalize(R.Dir); // Needs to be unit, so that on exit, I.t is distance
        }
        I.t = FARAWAY;
        if(!raytrace_mesh(R, I)) { break; }  
    }
    return result;
}

// Function 1965
Ray _nextRay(Hit h) {
  if (h.isTransparent) return rayRefract(h, h.srf.rr.x);
  return rayReflect(h, fresnel(h.srf.rl, dot(h.ray.dir, h.nml)));
}

// Function 1966
float castRay( in vec3 ro, in vec3 rd ,bool shadowing)
{
RO=ro;
RD=normalize(rd);
ooRD=1.0/rd;
PRIM=-1;
Z=CAMERA_FAR;
N = vec3(0,1,0);
UV = vec3(-1.0);
MATID = -1;
trace();
if(!shadowing)
{
dMATID =-1;
float tmin = CAMERA_NEAR;
float tmax = Z;
float precis = 0.001;
float t = tmin;
float m = -1.0;
for( int i=0; i<MAX_ITERATIONS; i++ )
{
float z = map( ro+rd*t );
if( z<precis || t>tmax ) break;
t += z;
}
if(t<Z)
{
Z=t;
MATID=dMATID;
PRIM=PRIM_DF;
}
}
return Z;
}

// Function 1967
vec3 calcNormal( in vec3 pos )
{
    vec4 kk;
	float kk2;
#if 0    
    float eps = 0.01;
	float ref = map(pos,kk,kk2);
	vec3 nor = vec3( map( vec3(pos.x+eps, pos.y, pos.z), kk, kk2 ) - ref,
                     map( vec3(pos.x, pos.y+eps, pos.z), kk, kk2 ) - ref,
                     map( vec3(pos.x, pos.y, pos.z+eps), kk, kk2 ) - ref );
	return normalize( nor );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*0.01,kk,kk2);
    }
    return normalize(n);
#endif    
    
    
}

// Function 1968
vec3 raymarch(in vec3 from, in vec3 dir) 

{
	hitcar=0.;
	ref=0.;
	float totdist=0.;
	float glow=0.;
	float d=1000.;
	vec3 p=from, col=vec3(0.5);

	float deta=DETAIL*(1.+backcam); // lower detail for HUD cam
	vec3 carp=vec3(0.); // coordinates for car hit
	vec3 carn=vec3(0.); // normal for car
	float cardist=0.; // ray length for car
	vec3 odir=dir; // save original ray direction

	for (int i=0; i<RAY_STEPS; i++) {
		if (d>det && totdist<MAX_DIST) {
			d=de(p);
			p+=d*dir;
			det=max(deta,deta*totdist*.5*(1.+ref)); // scale detail with distance or reflect
			totdist+=d; 
			float gldist=det*8.; // background glow distance 
			if(d<gldist&&totdist<20.) glow+=max(0.,gldist-d)/gldist*exp(-.1*totdist); //accum glow
#ifndef LOW_QUALITY
			if (hitcar>0. && ref<1.) { // hit car, bounce ray (only once)
				p=p-abs(d-det)*dir; // backstep
				carn=normal(p); // save car normal
				carp=p; // save car hit pos
				dir=reflect(dir,carn); // reflect ray
				p+=det*dir*10.; // advance ray
				d=10.; cardist=totdist;
				ref=1.;
			}
#endif
		} 
#ifdef LOOP_BREAKS		
		else break;
#endif
	}

	tubeinterval=abs(1.+cos(p.z*3.14159*.5))*.5; // set light tubes interval
	float cglow=1./(1.0+minL*minL*5000.0); // car glow
	float tglow=1./(1.0+minT*minT*5000.0); // tubes glow
	float l=max(0.,dot(normalize(-dir),normalize(LIGHTDIR))); // lightdir gradient
	vec3 backg=AMBIENT_COLOR*.4*max(0.1,pow(l,5.)); // background
	float lglow=pow(l,50.)*.5+pow(l,200.)*.5; // sun glow

	if (d<.5) { // hit surface
		vec3 norm=normal(p); // get normal
		p=p-abs(d-det)*dir; // backstep
		col=shade(p, dir, norm); // get shading 
		col+=tglow*TUBE_COLOR*pow(tubeinterval,1.5)*2.; // add tube glow
		col = mix(backg, col, exp(-.015*pow(abs(totdist),1.5))); // distance fading

	} else { // hit background
		col=backg; // set color to background
		col+=lglow*SUN_COLOR; // add sun glow
		col+=glow*pow(l,5.)*.035*LIGHT_COLOR; // borders glow
		
#ifdef LOW_QUALITY
		vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;
		for (int i = 0; i < 14; i++) st = abs(st) / dot(st,st) - .9;

		col+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 ); // add stars
#else
		float planet=Sphere(planetpos,dir, 2.); // raytrace planet

		// kaliset formula - used for stars and planet surface 
		float c;
		if (planet>0.) c=1.; else c=.9; // different params for planet and stars
		vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;
		for (int i = 0; i < 14; i++) st = abs(st) / dot(st,st) - c;

		col+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 ); // add stars
		
		// planet atmosphere
		col+=PLANET_COLOR*pow(max(0.,dot(dir,normalize(-planetpos))),100.)*150.*(1.-dir.x);
		// planet shading
		if (planet>0.) col=shadeplanet(planet*dir,st);
#endif
		
	}
	// car shading

		// add turbine glows
	
#ifdef LOW_QUALITY
	cglow*=1.15;
#else
	if (ref>0.) {
		ref=0.;
		col=shade(carp,odir,carn)+col*.3; // car shade + reflection
		// I wanted a lighter background for backward reflection
		l=max(0.,dot(normalize(-odir),normalize(LIGHTDIR)));
		backg=AMBIENT_COLOR*.4*max(0.1,pow(l,5.)); 
		col = mix(backg, col,exp(-.015*pow(abs(cardist),1.5))); // distance fading
	}
#endif 

	
	col+=TURBINES_COLOR*pow(abs(cglow),2.)*.4;
	col+=TURBINES_COLOR*cglow*.15;


	return col; 
}

// Function 1969
void orthonormalBasis(const vec3 n, out vec3 b1, out vec3 b2) {
  float s = n.z >= 0.0 ? 1.0 : -1.0;
  float a = -1.0 / (s + n.z);
  float b = n.x * n.y * a;
  b1 = vec3(1.0 + s * n.x * n.x * a, s * b, -s * n.x);
  b2 = vec3(b, s + n.y * n.y * a, -n.y);
}

// Function 1970
float CastRay( in vec3 ro, in vec3 rd )
{
    const float maxd = 5.0;
    
	float h = 1.0;
    float t = 0.0;
   
    for ( int i = 0; i < 50; ++i )
    {
        if ( h < 0.001 || t > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t );
        t += h;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }
	
    return t;
}

// Function 1971
vec3 NormalBlend_UnpackedRNM(vec3 n1, vec3 n2)
{
	n1 += vec3(0, 0, 1);
	n2 *= vec3(-1, -1, 1);
	
    return n1*dot(n1, n2)/n1.z - n2;
}

// Function 1972
vec3 calcNormal( in vec3 pos ) {
    const vec2 e = vec2(1.0,-1.0)*0.0075;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 1973
void computeNormals( out vec2 norm[kNumPoints], in vec2 path[kNumPoints] )
{
    for( int i=0; i<kNumPoints; i++ )
    {
        vec2 n = computeTangent( path[(i-1+kNumPoints)%kNumPoints],
                                 path[(i+0+kNumPoints)%kNumPoints],
                                 path[(i+1+kNumPoints)%kNumPoints] );
        norm[i] = vec2(n.y, -n.x );
    }
}

// Function 1974
vec3 calcNormal( in vec3 pos, in float objID, in Scene scn )
{
    if( objID<1.5 ) return nPlane();
    if( objID<2.5 ) return nTriangle( scn.v1, scn.v2, scn.v3 );
    if( objID<3.5 ) return nSphere( pos, vec4(scn.pA,0.07) );
    if( objID<4.5 ) return nSphere( pos, vec4(scn.pB,0.07) );
    if( objID<5.5 ) return nCylinder( pos, scn.pA, scn.pB, 0.02 );
    return vec3(0.0,1.0,0.0);
}

// Function 1975
Ray generateCameraRay(in vec2 uv)
{
    vec3 posCam = getPos();
    vec3 dirCam = getDir();
    vec3 targetCam = posCam + dirCam;
    
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 sidewaysCam = normalize(cross(up, dirCam));
    vec3 upCam = cross(dirCam, sidewaysCam);
    
    float zNear = 1.0;
    float xNear = -tan(radians(FOV) / 2.0) * zNear;
    float yNear = xNear * iResolution.y / iResolution.x;
    
    vec3 posNear =
        xNear * sidewaysCam * 2.0 * (-uv.x + 0.5) +
        yNear * upCam * 2.0 * (-uv.y + 0.5) +
        zNear * dirCam;
    
    Ray ray;
    ray.o = posCam;
    ray.d = normalize(posNear);
    ray.tMin = EPSILON;
    ray.tMax = INFINITY;
    
    return ray;
}

// Function 1976
vec4 RayMarch(vec3 ro,vec3 rd,vec3 p)
{
    float dO=0.0;
    int k=0;
    int i;
    for(i=0; i<MAX_STEPS; i++)
    {
        float ds=GetDist(p);
        float fds=ds;
        float mindist=2.0,maxdist=15.0;
        fds=min(fds, length(p)-mindist);
        fds=min(fds, maxdist-length(p));
        //dO+=fds*pow(maxdist/mindist,float(k));
        dO+=fds;
        p+=fds*rd;
        if(length(p)-mindist<=SURF_DIST)
        {
            p=normalize(p)*(maxdist-SURF_DIST*1.2);
            k--;
            
        }
        if(length(p)>=maxdist-SURF_DIST)
        {
            p=normalize(p)*(mindist+SURF_DIST*1.2);
            k++;
            fck-=0.3;
        }

        
        if(MAX_DIST<dO || k>2 || k<-3)
        {
        fck=0.0;
        break;
        }

        if(MAX_DIST<dO || ds<=SURF_DIST)
        break;
    }

    return vec4(p,dO);
}

// Function 1977
vec3 setupRayDirection(float camFov)
{
	vec2 coord = vec2(gl_FragCoord.xy);
    vec2 v = vec2(coord / iResolution.xy) * 2.0 - 1.0;
    float camAspect = iResolution.x/iResolution.y;
    float fov_y_scale = tan(camFov/2.0);
    vec3 raydir = vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0);
    return normalize(raydir);
}

// Function 1978
float raymarch(vec3 ori, vec3 dir, int iter) {
    float t = 0.;
    for(int i = 0; i < MAX_ITERATIONS; i++) {
        if(i >= iter) {
            t = MAX_DISTANCE;
        	break;
        }
        vec3  p = ori+dir*t;
        float d = dstScene(p);
        if(d < EPSILON)
            break;
        t += d * .75;
    }
    return t;
}

// Function 1979
vec2 rayMarch(vec3 origin, vec3 direct)
{
    float res = 0.0;
    
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec3 tmp = origin + direct * res;
        vec2 d = getDist(tmp);
        res += d.x;
        
        if (d.x < EPSILON)
        	return vec2(res, d.y);
        
        if (res >= MAX_DIST)
            return vec2(MAX_DIST, 0);
    }

    return vec2(MAX_DIST, 0);
}

// Function 1980
vec3 ObjectNormal(in vec3 p )
{
  const float eps = 0.0001;
  vec3 dx = vec3(eps,0.0,0.0);
  vec3 dy = vec3(0.0,eps,0.0);
  vec3 dz = vec3(0.0,0.0,eps);
  vec3 n;
  float v = object(p);
  n.x = object( p+dx ) - v;
  n.y = object( p+dy ) - v;
  n.z = object( p+dz ) - v;
  return normalize(n);
}

// Function 1981
float ExObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 80; j ++) {
    d = ExObjDf (ro + dHit * rd);
    if (d < 0.001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 1982
vec3 rayColor(in vec3 ro, in vec3 rd)
{
    // magic params for kali-set
    vec3 par2 = vec3(.63, .55, .73),				// normal/bump map
         par3 = vec3(1.02, 0.82, 0.77); 			// normal/texture
    
    float t = trace(ro, rd);
    vec3 p = ro + t * rd;
    float d = DE(p);
    
    vec3 col = vec3(0.);

    // did ray hit?
    if (d < 0.03) 
    {
        float scr_eps = max(0.001, (t-0.1)*0.025);
        // "some" texture values
        vec3 kt = kali_tex(p, par3);
        // surface normal
        vec3 n = DE_norm(p, 0.5*scr_eps), nn = n;
        // normal displacement
        n = normalize(n + 0.3*kali_tex_norm(p, par3+0.1*n, vec3(1), scr_eps));
        n = normalize(n + 0.3*DE_norm(sin(n*3.+kt), 2.*scr_eps)); // micro-bumps
        // reflected ray
        vec3 rrd = reflect(rd,n);
		// normal towards light
        vec3 ln = normalize(vec3(1,2,3));
		// 1. - occlusion
        float ao = pow(traceAO(p, n), 1.+3.*t);
        // surface color
        vec3 col1 = .45 * (vec3(.7,1.,.4) + kali_tex(p, par3));
        vec3 col2 = vec3(1.,.8,.6) + .3 * vec3(1.,.7,-.6) * kali_tex(p, par3);
        vec3 k = kali_set_av(sin(p*(1.+3.*ao))*.3, par3);
        vec3 surf = (.1 + .9 * ao) 
            		//* vec3(1.);
            		* mix(col1, col2, min(1., pow(ao*2.2-.8*kt.x,5.)));
		// desaturate
        surf += .24 * (dot(surf,vec3(.3,.6,.1)) - surf);

        // -- lighting --
        
        float fres = pow(max(0., 1.-dot(rrd, n)), 1.) / (1.+2.*t);

        // phong
        surf += .25 * ao * max(0., dot(n, ln));
        // spec
        float d = max(0., dot(rrd, ln));
        surf += .4 * pow(ao*1.2,5.) * (.5 * d + .7 * pow(d, 8.));

        // fresnel highlight
        surf += clamp((t-.06)*8., 0.,1.6) * 
            	(.2+.8*ao) * vec3(.7,.8,1.) * fres;
        
        // environment map
        surf += .2 * (1.-fres) * ao * skyColor(rrd);
    
        // distance fog
    	col = surf * pow(1.-t / max_t, 1.3);
        //col = n;
    }
    
    return col;
}

// Function 1983
vec3 TraceRay( vec3 vRayOrigin, vec3 vRayDir )
{
    vec3 vRayOffest;
    vec3 g, t, l; 
    
    vec3 vWorldPos;
	
    vRayDir.z += vRayDir.y * .5;
    
    vRayOffest = vec3(0);
    vec3 vFog = vec3(0);
        
    vec3 pPrev = vRayOffest;
    
    bool sky = vRayDir.y > 0.;
    
    vec2 vTextureUV;
    
    for ( float h=0.; h<.6; h+=.001 )
    {        
        vRayOffest = vRayDir * h / vRayDir.y;
        vWorldPos = vRayOrigin + vRayOffest;
    	if (sky )
        {
        	vWorldPos.xz *= .2;
            vWorldPos.xz += iTime * 0.25;
        }
        
		vTextureUV = vWorldPos.xz;
		l = T( vTextureUV, sky );
		t = textureLod( iChannel1, vTextureUV, 15. * (l.x-vRayOffest.y) ).rgb;
		g = pow( l*t,
                    t+7. 
					+ sin(vRayOffest.x * 5. + iTime)
					+ sin(vRayOffest.z * 5. + iTime)                                                                           
				) * h;
        
        vec3 pDelta = pPrev - vRayOffest;
        vFog.rgb+= g * exp(length(pDelta.xyz) * .4);
        
        if (vRayOffest.y >= l.x )
            break;        
	}
            
            
    l -= T( vTextureUV - .1, sky );

    
    if ( vRayDir.y > 0. )
        l += vec3(0.4, 0.3, 0.2);
    else 
        l += vec3(0.2, 0.3, 0.4);
    
    vec3 vResult = vec3(0);
    
    vResult = vFog +
         t * l 
        + g * 1e3
        	* vRayOffest.y 
        ;
    
    if ( vRayDir.y > 0. )
        vResult = vResult.zyx;
    
    vResult *= exp( -dot(vRayOffest, vRayOffest)*.03);
        
    vResult = 1. - exp(-vResult * 1.5);     
    
    return vResult;
}

// Function 1984
vec3 raycolor(vec3 q, vec3 r) {
  vec3 background = 0.1*regioncolor(5); //vec3(0.05,0,0);
  float t = march(q,r);
  if (t < 0.0) return background;
  vec3 p = q+t*r;
  vec3 normal = getnormal(p);
  vec3 color = getcolor(p);
  vec3 speccolor = color;
  float ambient = 0.5;
  float diffuse = 0.3*clamp(dot(normal,lightdir),0.0,1.0);
  color *= ambient+diffuse;
  float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),10.0);
  color += 0.8*specular*speccolor;
  color = mix(color,background,clamp((t-fogdist)/(maxdist-fogdist),0.0,1.0));
  return color;
}

// Function 1985
float RAYINTERSEC_plane(vec3 o, vec3 d, vec3 po, vec3 pn)
{
    return dot(po-o,pn)/dot(d,pn); 
}

// Function 1986
vec3 NormalSinPowWarp(vec3 pos, float freq, float amp, float power) {
    vec3 dir = normalize(pos);
	vec3 warp = abs(sin(dir*freq));
	float mw = max_element(warp);
	mw = pow(mw, power);
	return pos - dir * mw * amp;
}

// Function 1987
vec3 normal(vec3 p)
{
    vec2 e = vec2(.0001, 0);
    return normalize(vec3(
        scene(vec3(p + e.xyy)) - scene(vec3(p - e.xyy)),
        scene(vec3(p + e.yxy)) - scene(vec3(p - e.yxy)),
        scene(vec3(p + e.yyx)) - scene(vec3(p - e.yyx))));
}

// Function 1988
vec3 GetNormal(vec3 pos, float distance)
{
    distance *= 0.001+.0001;
	vec2 eps = vec2(distance, 0.0);
	vec3 nor = vec3(
	    Map(pos+eps.xyy) - Map(pos-eps.xyy),
	    Map(pos+eps.yxy) - Map(pos-eps.yxy),
	    Map(pos+eps.yyx) - Map(pos-eps.yyx));
	return normalize(nor);
}

// Function 1989
vec2 raycast( in vec3 ro, in vec3 rd )
{
    vec2 res = vec2(-1.0,-1.0);

    float tmin = .1;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (-1.0-ro.y)/rd.y;
    if( tp1>0.0 )
    {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }

    glow = 999.;
    float t = tmin;
    for( int i=0; i<170 && t<tmax; i++ )
    {
        vec2 h = map( ro+rd*t );
        if( abs(h.x)<(0.0001*t) )
        { 
            res = vec2(t,h.y); 
            break;
        }
        t += h.x;
        if (h.x<glow) glow = h.x;
    }
    
    return res;
}

// Function 1990
vec2 alignNormal(vec2 h, vec2 d) {
    return h*sign(dot(h, CART_FROM_HEX(d)));
}

// Function 1991
vec3 normal(in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.001;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + 
					 e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   
}

// Function 1992
RayHit MarchOneRay(const in vec3 start, const in vec3 rayVec,
                 out vec3 posI, const in int maxIter)
{
    RayHit rh = NewRayHit();
    rh.material = 256.0;
	float dist = 1000000.0;
	float t = 0.0;
	vec3 pos = vec3(0.0);
    vec3 signRay = max(vec3(0.0), sign(rayVec));
	// ray marching time
    pos = start;
    posI = floor(start);
    vec3 delta = signRay - fract(pos);
    vec3 hit = (delta/rayVec);
    vec3 signRayVec = sign(rayVec);
    vec3 invAbsRayVec = abs(1.0 / rayVec);
    // This is the highest we can ray march before early exit.
    float topBounds = max(10.0, start.y);
    for (int i = 0; i < maxIter; i++)	// This is the count of the max times the ray actually marches.
    {
#ifdef DISTANCE_FIELD
        //dist = DistanceToTerrain(posI);
		dist = posI.y - texelFetch(iChannel0, ivec2(posI.xz+gameGridCenter),0).x;
#else
		vec4 terrainTex = texelFetch(iChannel0, ivec2(posI.xz+gameGridCenter),0);
        dist = terrainTex.x;
#endif
        if ((terrainTex.y != 0.0) && (dist >= posI.y)) {
            if (round(posI.y) == 1.0)
            {
                float inGameGrid = max(abs(posI.x), abs(posI.z));
                float tex = mod(terrainTex.y, 16.0);
                // Only draw yellow trail walls if we're inside the game grid.
                if (inGameGrid <= gameGridRadius) {
                    vec3 boxSizeX = vec3(0.02, 0.25, 0.02);
                    vec3 boxSizeZ = vec3(0.02, 0.25, 0.02);
                    boxSizeX.x += sign(float(int(tex)&1))*0.25;
                    boxSizeX.x += sign(float(int(tex)&2))*0.25;
                    boxSizeZ.z += sign(float(int(tex)&4))*0.25;
                    boxSizeZ.z += sign(float(int(tex)&8))*0.25;
                    vec3 boxOffsetX = posI + 0.5 - vec3(0,0.25,0);
                    vec3 boxOffsetZ = posI + 0.5 - vec3(0,0.25,0);
                    // Shrink the blue trail when bad guy dies
                    if (terrainTex.y >= 16.0) {
                        float anim = saturate(animA.x);
                        boxSizeX.y *= anim;
                        boxSizeZ.y *= anim;
                        boxOffsetX.y -= (1.0 - anim) * 0.25;
                        boxOffsetZ.y -= (1.0 - anim) * 0.25;
                    }
                    boxOffsetX.x -= sign(float(int(tex)&1))*0.25;
                    boxOffsetX.x += sign(float(int(tex)&2))*0.25;
                    boxOffsetZ.z -= sign(float(int(tex)&4))*0.25;
                    boxOffsetZ.z += sign(float(int(tex)&8))*0.25;
                    RayHit rh = BoxIntersect(pos, rayVec, boxOffsetX, boxSizeX, 1.0);
                    rh = Union(rh, BoxIntersect(pos, rayVec, boxOffsetZ, boxSizeZ, 1.0));
                    if (rh.tMin == bignum) dist = smallVal;
                    else {
                        rh.material = 128.0;
                        if (terrainTex.y >= 16.0) rh.material = 129.0;
                        return rh;
                    }
                }
            }
            if (terrainTex.y == 256.0) {
                vec3 bpos = pos - (posI + 0.5);
                bpos = RotateY(bpos, localTime*8.0);
                vec3 rayVecR = RotateY(rayVec, localTime*8.0);
                bpos += (posI + 0.5);
                RayHit rh = BoxIntersect(bpos, rayVecR, posI + 0.5, vec3(0.28), 8.0);
                if (rh.tMin == bignum) dist = smallVal;  // Missed powerup. Keep ray marching.
                else return rh;  // Hit powerup
            }
            //vec4 hitS = SphereIntersect(pos, rayVec, posI + 0.5, 0.5);
            //if (hitS.w == bignum) dist = smallVal;
        }
        // || (t > maxDepth)
#ifdef DISTANCE_FIELD
        if ((dist < smallVal) || (posI.y > topBounds)) break;
#else
        if ((dist >= posI.y) || (posI.y > topBounds)) break;
#endif

        vec3 absHit = abs(hit);
        t = min(absHit.x, min(absHit.y, absHit.z));
        vec3 walk = step(absHit, vec3(t));
        hit += walk * invAbsRayVec;
        posI += walk * signRayVec;
        /*if (t == absHit.x) {
            hit.x += invAbsRayVec.x;
            posI.x += signRayVec.x;
        }
        if (t == absHit.y) {
            hit.y += invAbsRayVec.y;
            posI.y += signRayVec.y;
        }
        if (t == absHit.z) {
            hit.z += invAbsRayVec.z;
            posI.z += signRayVec.z;
        }*/
    }
#ifdef DISTANCE_FIELD
    if (dist >= smallVal) return rh;
#else
    if (dist < posI.y) return rh;
#endif
    // Hit the voxel terrain
    pos = t * rayVec + start;
	//vec4 tex = texelFetch(iChannel0, ivec2(pos.xz+gameGridCenter),0);
    //if (abs(pos.y - tex.x) > 2.5) rh.material = 1.0;
    rh.tMin = t;
    rh.hitMin = pos;
    rh.normMin = CalcNormal(pos, rayVec);
    rh.tMax = rh.tMin + 1.0;
    return rh;
}

// Function 1993
vec3 calcNormal(vec3 p)
{
    const float h = 0.0001;
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + 
                      k.yyx*sceneSDF( p + k.yyx*h ) + 
                      k.yxy*sceneSDF( p + k.yxy*h ) + 
                      k.xxx*sceneSDF( p + k.xxx*h ) );
}

// Function 1994
vec2 castRay( in vec3 ro, in vec3 rd, float tmin, float tmax, float flip) {
    float t = tmin;
    float m = -1.0;
    
    for( int i=0; i < MAX_RAY_STEPS; i++ )
    {
	    float precis = 0.0001;//PRECIS*t;
	    vec2 res = map( ro+rd*t );
        if( flip*res.x < precis || t>tmax ) break;
        t += flip*res.x*ERROR;
	    m = res.y;
    }

    if( t>tmax ) { t=-1.0; m=-1.0; }
    return vec2( t, m );
}

// Function 1995
vec3 objNormal(vec3 p){
  const float n_er=0.02;
  float v1=inObj(vec3(p.x+n_er,p.y-n_er,p.z-n_er)).x;
  float v2=inObj(vec3(p.x-n_er,p.y-n_er,p.z+n_er)).x;
  float v3=inObj(vec3(p.x-n_er,p.y+n_er,p.z-n_er)).x;
  float v4=inObj(vec3(p.x+n_er,p.y+n_er,p.z+n_er)).x;
  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));
}

// Function 1996
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 220; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 1997
vec3 calcNormal( in vec3 pos, in float eps, in float t )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, t ) + 
					  e.yyx*map( pos + e.yyx, t ) + 
					  e.yxy*map( pos + e.yxy, t ) + 
					  e.xxx*map( pos + e.xxx, t ) );
}

// Function 1998
bool RayMarchPerturbedSphere(in vec3 ro, in vec3 rd, in vec3 c, in float r, in float br, 
                             out vec3 n, out vec3 sd) {
    n = vec3(0.0);
    sd = vec3(0.0);
    
    vec3 bp0 = vec3(0.0);
    vec3 bp1 = vec3(0.0);
    bool bres = RaySphereIntersection(ro, rd, c, br, bp0, bp1);
    if (!bres) return false;
    
    vec3 p0 = vec3(0.0); 
    vec3 p1 = vec3(0.0);
    bool res = RaySphereIntersection(ro, rd, c, r, p0, p1); 
    
    float dist = float(res)*length(p0 - bp0) + (1.0-float(res)) * length(bp0 - bp1);
	//float dist = length(bp0 - bp1);
    const float sc = 128.0;
    const float invsc = 1.0 / sc;
    float s = dist * invsc;
    
    bool ret = false;
    vec3 pn = vec3(0.0);
    for (float d = 0.0; d < sc; ++d) {
    	pn = (bp0 + d*s*rd) - c;
		
        sd = normalize(pn) * r;
        float h = length(pn) - r - s;
        
        float h0 = noise(sd);
        if (h0 > h) {
            ret = true;
            break;
        } 
    }
    
    n = SphereNormal(normalize(pn), r, s);
    return ret;
}

// Function 1999
vec3 GetNormal(vec3 p){
    //distance to point being analyzed
    float d = GetDist(p);
    
    //distance to another point along the objects surface that is closeby
    vec2 e = vec2(0.01,0);
    
    //slope between the two points
    //note: swizzel is the .xxy or .yyx etc
    vec3 n = d - vec3(
         GetDist(p-e.xyy),
         GetDist(p-e.yxy),
         GetDist(p-e.yyx));
         
    return normalize(n);
    
}

// Function 2000
vec3 normal_decode(vec2 enc)
{
    vec3 n;
    n.xy = enc*2.0-1.0;
    n.z = sqrt(1.0-dot(n.xy, n.xy));
    return n;
}

// Function 2001
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3(0.015,0.0,0.0);
	
	return normalize( vec3(
		mapTerrain(pos+eps.xyy).w - mapTerrain(pos-eps.xyy).w,
		mapTerrain(pos+eps.yxy).w - mapTerrain(pos-eps.yxy).w,
		mapTerrain(pos+eps.yyx).w - mapTerrain(pos-eps.yyx).w ) );

}

// Function 2002
float rayleighPhase(vec2 p, vec2 lp){
	return 0.375 * (1.0 + pow(1.0 - distance(p, lp), 2.0));
}

// Function 2003
vec3 calcNormal( in vec3 pos )
{
    const vec2 e = vec2(1.0,-1.0)*0.5773*kPrecis;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 2004
float raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    float breakOut = 0.0;
    int i = 0;
    while (i < 40 && breakOut != 1.0) {
        vec3 p = ro + rd * t;
        float d = p.y - fBm(p.xz);
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            breakOut = 1.0;
        i++;
    }
    return sh;
}

// Function 2005
vec3 normal(vec3 p){
    vec2 e= vec2(0,0.001);
	return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),
                          map(p+e.xyx)-map(p-e.xyx),
                          map(p+e.xxy)-map(p-e.xxy)));
}

// Function 2006
float raycast( in vec3 rayOrigin, in vec3 rayDirection, in float searchLimit, in int material )
{
    float travelDistance = 0.0;
    for( int i = 0; i < maxIterations; i++ )
    {
        vec3 position = rayOrigin + travelDistance * rayDirection;
        float rayPointToObject = 0.0f;
        switch(material)
        {
            case Lava:
            {
                rayPointToObject = mapLavaAndMetal(position);
                break;
            }
            
            case Glass:
            {
                rayPointToObject = mapGlass(position);
                break;
            }
        }

        if( rayPointToObject < epsilon )
           break;   
        
        travelDistance += rayPointToObject;
        if( travelDistance > searchLimit )
           break;
    }   
    if( travelDistance > searchLimit )
        travelDistance = 0.0;
    return travelDistance;
}

// Function 2007
vec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )
{
    // animate moving objects
    float r = -(time+sin(time))*10.;
    float a = time/3.;
    vec4 s0 = vec4(.1*cos(a),.1*sin(a)+.05,0,1), s1 = vec4(-.1*cos(a),-.1*sin(a)+.05,0,2);
    s0.xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;
    s1.xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;
    //s0.w *= .5+.5*pow(1.-fract(time*2.),2.);
    Scene[0] = s0;
    Scene[1] = s1;
    
    vec3 normal = vec3(0);
    int material = 0;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;

        Material mat = GetMaterial(pos,material);
        
        if ( material == 2 ) mat.roughness = ROUGHNESS;

        float specPower = 1./(mat.roughness*mat.roughness);
        float specStrength = (specPower+8.)/(4.*tau);
        

        // sample light
        vec3 sun = normalize(vec3(-.5,2,3));
        
        // soften shadow by sampling radius around sun
        vec3 areaLight = PowRand( rand.zx, -sun, 1. );
        vec3 suntap = normalize( sun + areaLight*.03 );
        
        vec3 testn = vec3(0);
        int ignore;
        Trace(testn,ignore,pos,suntap);
        
        float ndotl = max(0.,dot(normal,sun));
        float ndoth = max(0.,dot(normal,normalize(-ray+sun)));

        vec3 ambientColour = vec3(.05,.065,.09);
        vec3 lightColour = vec3(1,.95,.92);
        vec3 light = ambientColour*(normal.y*.3+1.); // ambient
        vec3 specular = vec3(0);
        if ( length(testn) == 0. )
        {
        	light += ndotl * lightColour;
	        specular += lightColour*ndotl*pow(ndoth,specPower)*specStrength;
        }

        
        // randomize reflection direction with Blinn-Phong probability distribution
        vec3 microfacet = PowRand( rand.zy, normal, specPower );

        // sample reflection
        vec3 reflection = vec3(0);
        
        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera
        {
            vec3 refray = reflect(ray,microfacet);
            vec3 refn = vec3(0);
            int refmati = 0;
            float reft = Trace(refn,refmati,pos,refray);

            reflection = Sky(refray);
            if ( length(refn) > 0. )
            {
                Material refmat = GetMaterial(pos+refray*reft,refmati);
                reflection = refmat.albedo * (max(0.,dot(refn,sun)) * lightColour + ambientColour*(refn.y*.3+1.));
            }
        }
        
        reflection += specular;
        
        col = light*mat.albedo;

        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );
        
        col = mix( col, reflection, fresnel );
    }
    
    return col;
}

// Function 2008
vec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){
	float precis = 0.015;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<120; i++ )
    {
        if( abs(h)<precis||t>maxd ) break;
        t += h;
	    vec2 res = map( ro+rd*t );
        h = res.x; //dist to solid
	    m = res.y; //fft
    }
    if (t>maxd) { t=-0.5; m=0.0; }
    return vec2( t, m );
}

// Function 2009
bool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)
{
    vec3 uv = normalize(v);

    float dt = dot(uv, n);

    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);

    if (discriminant > 0.0f)
    {
        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);

        return true;
    }
    else
        return false;
}

// Function 2010
bool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    vec3 boxMin = vec3( minX, minY, minZ );
    vec3 boxMax = vec3( maxX, maxY, maxZ );
    
    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;
    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;
    vec3 MAX = max ( OMAX, OMIN );
    vec3 MIN = min ( OMAX, OMIN );
    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );
    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );
    
    if ( t1 <= t )
        return false;
    
    if( !forShadowTest ) {
        isect.position_ = ray.origin + ray.dir*t;
        
        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {
            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );
            isect.tangent_ 		= vec3( 0.0, 1.0, 0.0 );
            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);
    		isect.uv_.y = (isect.position_.y - minY)/(maxY - minY);
        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {
            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );
            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
            isect.uv_.x = (isect.position_.z - minZ)/(maxZ - minZ);
    		isect.uv_.y = (isect.position_.y - minY)/(maxY - minY);
        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);
    		isect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);
        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);
    		isect.uv_.y = (isect.position_.z - minZ)/(maxZ - minZ);
        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);
    		isect.uv_.y = (isect.position_.y - minY)/(maxY - minY);
        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_.x = (isect.position_.x - minX)/(maxX - minX);
    		isect.uv_.y = (isect.position_.y - minY)/(maxY - minY);
        }
        
        isect.uv_ /= 2.0;
    }
    
    return true;
}

// Function 2011
vec3 calcNormal( in vec3 pos, float t )
{
    vec2  eps = vec2( 0.002*t, 0.0 );
    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),
                            2.0*eps.x,
                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );
}

// Function 2012
vec3 getNormal(vec3 pos)
{
	float d=getDist(pos);
	return normalize(vec3( getDist(pos+vec3(EPSILON,0,0))-d, getDist(pos+vec3(0,EPSILON,0))-d, getDist(pos+vec3(0,0,EPSILON))-d ));
}

// Function 2013
Hit raymarch(Ray ray) {
 
    vec3 p = ray.ori;
    int id = -1;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        Dst scn = dstScene(p);
        p += ray.dir * scn.dst * .75;
        
        if(scn.dst < MIN_DISTANCE) {
         
            id = scn.id;
            break;
            
        }
        
    }
    
    return Hit(p,id);
    
}

// Function 2014
float rayAABB(Ray ray, AABB aabb, float tmin, float tmax) {
    vec3 invD = 1.0/ray.d;
	vec3 t0s = (aabb.min - ray.o) * invD;
  	vec3 t1s = (aabb.max - ray.o) * invD;
    
  	vec3 tsmaller = min(t0s, t1s);
	vec3 tbigger  = max(t0s, t1s);

	tmin = max(tmin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));
	tmax = min(tmax, min(tbigger[0], min(tbigger[1], tbigger[2])));
	return (tmin < tmax) ? tmin : 0.0;
}

// Function 2015
vec3 normal(in vec3 p) {
  return normalize(
      vec3(sdf(p + vec3(EPS, 0., 0.)) - sdf(p - vec3(EPS, 0., 0.)),
           sdf(p + vec3(0., EPS, 0.)) - sdf(p - vec3(0., EPS, 0.)),
           sdf(p + vec3(0., 0., EPS)) - sdf(p - vec3(0., 0., EPS))));
}

// Function 2016
float raymarch(vec3 pos, vec3 dir) {
	float dist = 0.0;
	float dscene;

	for (int i = 0; i < RM_ITERS; i++) {
		dscene = scene(pos + dist * dir);
		if (abs(dscene) < 0.1)
			break;
		dist += RM_FACTOR * dscene;
	}

	return dist;
}

// Function 2017
vec4 rayMarch(vec3 rayOrigin, vec3 rayStep, out vec3 pos)
{
	vec4 sum = vec4(0, 0, 0, 0);
	pos = rayOrigin;
	for(int i=0; i<_VolumeSteps; i++) {
		vec4 col = volumeFunc(pos);
		col.a *= _Density;
		// pre-multiply alpha
		col.rgb *= col.a;
		sum = sum + col*(1.0 - sum.a);	
		pos += rayStep;
	}
	return sum;
}

// Function 2018
vec3 calcNormal( in vec3 pos )
{
#if 0    
    vec2 e = vec2(0.002,0.0); 
    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,
                            map(pos+e.yxy).x - map(pos-e.yxy).x,
                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*0.002).x;
    }
    return normalize(n);
#endif    
}

// Function 2019
vec3 calcNormal(in vec3 pos) {
    vec2 e = vec2(1,-1)*.00005;
    return normalize(e.xyy*map(pos + e.xyy).x +
                     e.yyx*map(pos + e.yyx).x +
                     e.yxy*map(pos + e.yxy).x +
                     e.xxx*map(pos + e.xxx).x);
}

// Function 2020
vec3 sdfNormal(vec3 p, float epsilon, Ray ray)
{
    vec3 normal = vec3(0.0);

    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, ray) - sdf(p - offset, ray);
    }
    
    return normalize(normal);
}

// Function 2021
float castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {
    float precis = 0.001;
    float h = precis * 2.0;
    float t = -3.5+rnd(co+0.01*iTime)*7.;
    for(int i = 0; i < 200; i++) 
    {
    	if(abs(h) < precis || t > maxt) continue;
        h = map(ro+rd*t,1);
        t += 0.25*h;
    }
    return t;
    

}

// Function 2022
vec3 getNormal(const in vec3 p, float rmPrec){  
    vec2 e = vec2(-1., 1.)*rmPrec;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );
}

// Function 2023
Ray ray(vec3 o, vec3 d, vec3 c, float s) { return Ray(o,d,c,0.,0.,s); }

// Function 2024
vec3 normal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,
        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist
    ));
}

// Function 2025
float castShadowRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	float t = -1.0;
	float res = 1.0;
	
    // first step we check noching	
	vec2 mm = step( dis.xy, dis.yx ); 
	dis += mm * ris;
    pos += mm * rs;
	
    // traverse regular grid (2D)	
	for( int i=0; i<16; i++ ) 
	{
		float ma = map(pos);
		
        // test capped cylinder		
		vec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.249;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t = (-b - sqrt( h ))/a;
			if( (ro.y+t*rd.y)<ma )
			{
				res = 0.0;
    			break; 
			}
		}
		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}

	return res;
}

// Function 2026
vec3 calcNormal(vec3 p) {
	float eps = 0.001;
	const vec3 v1 = vec3( 1.0,-1.0,-1.0);
	const vec3 v2 = vec3(-1.0,-1.0, 1.0);
	const vec3 v3 = vec3(-1.0, 1.0,-1.0);
	const vec3 v4 = vec3( 1.0, 1.0, 1.0);
	return normalize( v1 * map( p + v1*eps ) +
					  v2 * map( p + v2*eps ) +
					  v3 * map( p + v3*eps ) +
					  v4 * map( p + v4*eps ) );
}

// Function 2027
vec3 sceneNormal(vec3 pos )
{
    float eps = 0.0001;
    vec3 n;
#if 0
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - scene( vec3(pos.x, pos.y-eps, pos.z) );
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );
#else
    float d = scene(pos);
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;
#endif
    return normalize(n);
}

// Function 2028
vec3 tut_calcNormal(in vec3 pos) {
    vec2 e = vec2(1.0, -1.0) * 0.0005;
    return normalize(
        e.xyy * tut_map(pos + e.xyy) +
        e.yyx * tut_map(pos + e.yyx) +
        e.yxy * tut_map(pos + e.yxy) +
        e.xxx * tut_map(pos + e.xxx));
}

// Function 2029
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 160; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 2030
void objNormal(in vec3 p, out vec3 hitNormal) {
    float fXA, fXB, fYA, fYB, fZA, fZB;
    vec3 uv;

    sdBaseUV(p - vec3(GRAD_EPS, 0.0, 0.0), uv, fXA);
    sdBaseUV(p + vec3(GRAD_EPS, 0.0, 0.0), uv, fXB);
    sdBaseUV(p - vec3(0.0, GRAD_EPS, 0.0), uv, fYA);
    sdBaseUV(p + vec3(0.0, GRAD_EPS, 0.0), uv, fYB);
    sdBaseUV(p - vec3(0.0, 0.0, GRAD_EPS), uv, fZA);
    sdBaseUV(p + vec3(0.0, 0.0, GRAD_EPS), uv, fZB);

    hitNormal = vec3(fXB-fXA, fYB-fYA, fZB-fZA);
}

// Function 2031
vec3 GetNormal( in vec3 pos )
{
    #define ZERO (min(iFrame,0))
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*QueryDistanceField(pos+0.005*e, DEFAULT_INTERSECT_FLAG).x;
    }
    return normalize(n);
}

// Function 2032
vec3 calcNormal( in vec3 p, in vec4 c )
{
#if 1
    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;
    vec4 za=vec4(p+e.xyy,0.0); float mz2a=qlength2(za), md2a=1.0;
    vec4 zb=vec4(p+e.yyx,0.0); float mz2b=qlength2(zb), md2b=1.0;
    vec4 zc=vec4(p+e.yxy,0.0); float mz2c=qlength2(zc), md2c=1.0;
    vec4 zd=vec4(p+e.xxx,0.0); float mz2d=qlength2(zd), md2d=1.0;
  	for(int i=0; i<numIterations; i++)
    {
        md2a *= mz2a; za = qsqr(za)+c; mz2a = qlength2(za);
        md2b *= mz2b; zb = qsqr(zb)+c; mz2b = qlength2(zb);
        md2c *= mz2c; zc = qsqr(zc)+c; mz2c = qlength2(zc);
        md2d *= mz2d; zd = qsqr(zd)+c; mz2d = qlength2(zd);
    }
    return normalize( e.xyy*sqrt(mz2a/md2a)*log2(mz2a) + 
					  e.yyx*sqrt(mz2b/md2b)*log2(mz2b) + 
					  e.yxy*sqrt(mz2c/md2c)*log2(mz2c) + 
					  e.xxx*sqrt(mz2d/md2d)*log2(mz2d) );
#else    
    const vec2 e = vec2(0.001,0.0);
    vec4 za=vec4(p+e.xyy,0.0); float mz2a=qlength2(za), md2a=1.0;
    vec4 zb=vec4(p-e.xyy,0.0); float mz2b=qlength2(zb), md2b=1.0;
    vec4 zc=vec4(p+e.yxy,0.0); float mz2c=qlength2(zc), md2c=1.0;
    vec4 zd=vec4(p-e.yxy,0.0); float mz2d=qlength2(zd), md2d=1.0;
    vec4 ze=vec4(p+e.yyx,0.0); float mz2e=qlength2(ze), md2e=1.0;
    vec4 zf=vec4(p-e.yyx,0.0); float mz2f=qlength2(zf), md2f=1.0;
  	for(int i=0; i<numIterations; i++)
    {
        md2a *= mz2a; za = qsqr(za) + c; mz2a = qlength2(za);
        md2b *= mz2b; zb = qsqr(zb) + c; mz2b = qlength2(zb);
        md2c *= mz2c; zc = qsqr(zc) + c; mz2c = qlength2(zc);
        md2d *= mz2d; zd = qsqr(zd) + c; mz2d = qlength2(zd);
        md2e *= mz2e; ze = qsqr(ze) + c; mz2e = qlength2(ze);
        md2f *= mz2f; zf = qsqr(zf) + c; mz2f = qlength2(zf);
    }
    float da = sqrt(mz2a/md2a)*log2(mz2a);
    float db = sqrt(mz2b/md2b)*log2(mz2b);
    float dc = sqrt(mz2c/md2c)*log2(mz2c);
    float dd = sqrt(mz2d/md2d)*log2(mz2d);
    float de = sqrt(mz2e/md2e)*log2(mz2e);
    float df = sqrt(mz2f/md2f)*log2(mz2f);
    
    return normalize( vec3(da-db,dc-dd,de-df) );
#endif    
}

// Function 2033
vec4 ray_march( in vec3 ro, in vec3 rd, int maxstep ) {
    float t = 0.0001;
    vec3 m = vec3(0.);
    for( int i=0; i<maxstep; i++ ) {
        vec4 d = map(ro + rd * t);
        m = d.yzw;
        if(d.x<.001*t||t>MAX_DIST) break;
        t += d.x*.5;
    }
    return vec4(t,m);
}

// Function 2034
float RayMarchDist(vec3 ray_origin, vec3 ray_dir, float initial_dist, float iTime)
{
    float dist = initial_dist;
    
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        vec3 p = ray_origin + ray_dir * dist;
        
        float nearest = GetSceneDist(p, iTime);
        
        if (nearest < MIN_DIST)
            break;
        
        dist += nearest;
        
        if (dist > MAX_DIST)
            break;
    }
    
    return dist;
}

// Function 2035
vec3 Ray( float zoom )
{
	return vec3( glFragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );
}

// Function 2036
vec4 rayMarch(vec3 p, vec3 d, inout vtx co)
{    
    float td = 0.; float DE = 1e10;
    for(int i = min(0, iFrame); i < maxs; i++)
    {
        //march
        DE = map(p, d, co);
        
        p += DE*d;
        td += DE;
        
        //outide of the scene
        if(td > maxd) return vec4(p, -1.);
        //has hit the surface
        if(DE < mind*td)
        {
            p += - mind*td*d;
            break;
        }
    }
    return vec4(p, DE);
}

// Function 2037
vec4 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 700.0;
   
    float t = tmin;
    vec3 c = vec3(-1.0,-1.0,-1.0);
    for (int i=0; i<200; i++) {
        float precis = 0.0005*t;
        vec4 res = map( vec4(ro+rd*t,iTime) );
        if (res.x < precis) {
            c = res.yzw;
            break;
        }
        t += res.x;
        if (t > tmax) break;
    }
    return vec4( t, c );
}

// Function 2038
vec3 calcNormal(in vec3 p){
  vec3 v=vec3(.001,0,map(p).d);
  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));
}

// Function 2039
vec3 generateRay( vec2 fragCoord, vec3 eye, vec3 target )
{
    vec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;
    vec3 cw = normalize( target - eye );
    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );
    vec3 cv = cross( cu, cw );
    mat3 cm = mat3( cu, cv, cw );
    vec3 rd = cm * normalize( vec3( uv, 2.5 ) );
    return rd;
}

// Function 2040
vec3 normal(ray r, float d)
{
	float e = 0.001;
	float dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;
	float dy = scene(vec3(0.0, e, 0.0) + r.p) - d;
	float dz = scene(vec3(0.0, 0.0, e) + r.p) - d;
	return normalize(vec3(dx, dy, dz));
}

// Function 2041
vec3 getNormal(vec3 pos, float e)
{  
    vec2 q = vec2(0, e);
    return normalize(vec3(map(pos + q.yxx, true).x - map(pos - q.yxx, true).x,
                          map(pos + q.xyx, true).x - map(pos - q.xyx, true).x,
                          map(pos + q.xxy, true).x - map(pos - q.xxy, true).x));
}

// Function 2042
vec3 calcNormal(in vec3 pos)
{
    vec3  eps = vec3(.001,0.0,0.0);
    vec3 nor;
    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;
    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;
    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;
    return normalize(nor);
}

// Function 2043
float castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col, out vec3 n )
{
    uv = vec2(0.); n = uv.xxx;
    
    float rt = DIST_MAX;
    for( int i = 0; i < QUAD_COUNT; i++ )
    {
        vec2 uvi; float rti;
        if( rayQuadUV( ro, rd, quads[i].p, quads[i].n, quads[i].scl, uvi, rti ) 
          && rti < rt )
        {
            uv = quads[i].uv_c + (uvi-.5)*quads[i].uv_wh;
            col = GetColor(quads[i].col);
            n = quads[i].n;
            rt = rti;
        }
    }
    
    return rt;
}

// Function 2044
bool raymarch(vec3 o, vec3 dir, inout float depth, inout vec3 n) {
	float t = 0.0;
    float d = 10000.0;
    float dt = 0.0;

    for (int i = 0; i < 128; i++)
    {
        vec3 v = o + dir * t;
        d = world(v);

        if (d < 0.001)
        {
            break;
        }

        dt = min(abs(d), 0.1);
        t += dt;

        if (t > depth)
        {
            break;
        }
    }
    
    if (d >= 0.001)
    {
        return false;
    }
    
    t -= dt;

    for (int i = 0; i < 4; i++)
    {
        dt *= 0.5;
        vec3 v = o + dir * (t + dt);

        if (world(v) >= 0.001)
        {
            t += dt;
        }
    }
    
    depth = t;
    n = normalize(calcNormal(o + dir * t));
    
    return true;
}

// Function 2045
float castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )
{
	vec3 pos = floor(ro);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 ris = ri*rs;
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	float t = -1.0;
	
	vec3 mm = vec3(0.0);
	for( int i=0; i<256; i++ ) 
	{
		if( map(pos)>0.5 ) 
		{ 
            // intersect cube exactly			
			vec3 pr = pos+0.5-ro;
			vec3 mini = (pr-0.5*rs)*ri;
	        float s = max( mini.x, max( mini.y, mini.z ) );

            // raymarch internal shape			
			float id = hash1( pos );
			float h = 0.0;
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			h = map2( -pr+rd*s, id ); s += max(0.0,h);
			if( h<0.025 )
			{
				t = s;
				break; 
			}
		}
		vec3 mi = step( dis.xyz, dis.yzx ); 
		mm = mi*(1.0-mi.zxy);
		dis += mm * ris;
        pos += mm * rs;
        
        if( pos.y>21.0 ) break;
	}

	oDir = mm;
	oVos = pos;

	return t;

}

// Function 2046
vec3 normal(vec3 p)
{
    vec3 n;
    
    n.x = map(p + vec3(EPS,0.,0.)) - map(p-vec3(EPS,0.,0.));
    n.y = map(p + vec3(0.,EPS,0.)) - map(p-vec3(0.,EPS,0.));
    n.z = map(p + vec3(0.,0.,EPS)) - map(p-vec3(0.,0.,EPS));   
    
    return normalize(n);
}

// Function 2047
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(0.0035, 1);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 2048
vec3 getSurfaceNormal( vec3 hitPos )
{    
	vec3 x = vec3( 0.001, 0.0, 0.0 );
    vec3 y = vec3( 0.0 , 0.001 , 0.0 );
    vec3 z = vec3( 0.0 , 0.0 , 0.001 );
    
   	float upTinyChangeInX = useShape( hitPos + x ).x; 
    float downTinyChangeInX = useShape( hitPos - x ).x; 
    
    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;
    
    
    float upTinyChangeInY   = useShape( hitPos + y ).x; 
    float downTinyChangeInY = useShape( hitPos - y ).x; 
    
    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;
    
    
    float upTinyChangeInZ   = useShape( hitPos + z ).x; 
    float downTinyChangeInZ = useShape( hitPos - z ).x; 
    
    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;
    
    
	vec3 normal = vec3( tinyChangeInX, tinyChangeInY, tinyChangeInZ );
    
	return normalize(normal);
}

// Function 2049
vec4 normalTerrain(in vec2 p)
{
   	p *= 0.4;
    vec3 res = fbm9D(p);
    res *= 0.8;
    vec2 mdf = smoothstepd(-0.112, 0.1, res.x);
    res.x = res.x + mdf.x * 0.8;
    res.yz = res.yz + mdf.y * 0.8 * res.yz;
    res.x *= 0.4;
    res.yz *= 0.4;
    
    return vec4(res.x, normalize(vec3(-res.y, 1.0, -res.z)));
}

// Function 2050
vec3 normal(in vec3 pos){
    vec3 eps = vec3(0.01, 0, 0);
    // calc normal via gradient calculation using map to get points very close to pos on the surface
    vec3 nor;
    nor.x = map(pos+eps.xyy, false).x - map(pos-eps.xyy, false).x;
    nor.y = map(pos+eps.yxy, false).x - map(pos-eps.yxy, false).x;
    nor.z = map(pos+eps.yyx, false).x - map(pos-eps.yyx, false).x;
    return normalize(nor);
}

// Function 2051
vec3 ray_trace(vec2 uv, vec2 ro, vec3 col){
    
    vec2 t_and_a = time_and_animation();
    
    //rays
    for(float i = 0.; i<pi; i += pi/float(RAY_N)){
    
        vec2 rd = vec2(1.,0.)*rot(i-pi/2.*sin(iTime/6.));
        vec2 bounce_ro = ro;
        //bounces
        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);
        }
        
    
    
    return col;
}

// Function 2052
vec3 calcNormal(vec3 pos) {
  return calcNormal(pos, 0.002);
}

// Function 2053
vec4 raymarch(vec2 resolution, vec2 uv, vec4 start_data, mat4 camera_transform) {
    // Convert to range (-1, 1) and correct aspect ratio
    vec2 screen_coords = (uv - 0.5) * 2.0;
    screen_coords.x *= resolution.x / resolution.y;
    
    
    vec3 ray_start_position = camera_transform[3].xyz;
    
    vec3 ray_direction = normalize(vec3(screen_coords * LENS, 1.0));
    ray_direction = (camera_transform * vec4(ray_direction, 0.0)).xyz;
    
    
    float dist = start_data.a * 0.9;
    vec3 sample_point = ray_start_position + dist * ray_direction;
    
    float results = sample_world(sample_point);
    
    float tolerance = 0.0;
    
    for (int i=0; i<steps; i += 1) {
        dist += results*1.125;
        sample_point += ray_direction * results;
        results = sample_world(sample_point);
        
        // TODO: Derive from resolution, camera lens and distance
        ;
    	tolerance=4.*LENS/resolution.x*dist*dist;
        
        if (results < tolerance || dist > 5.0) {
        	break; 
        }
    }
    
    
    
    return vec4(sample_point, dist);
}

// Function 2054
vec3 GetNormal( vec3 pos )
{
	const vec2 delta = vec2(normalPrecision, 0);
	
	vec3 n;

// it's important this is centred on the pos, it fixes a lot of errors
	n.x = Isosurface( pos + delta.xyy ) - Isosurface( pos - delta.xyy );
	n.y = Isosurface( pos + delta.yxy ) - Isosurface( pos - delta.yxy );
	n.z = Isosurface( pos + delta.yyx ) - Isosurface( pos - delta.yyx );
	return normalize(n);
}

// Function 2055
vec3 SceneNormal(in vec3 p, in float d)
{
    vec2 eps = vec2(0.001 * d, 0.0);
    return normalize(vec3(Scene(p + eps.xyy).x - Scene(p - eps.xyy).x,
                          Scene(p + eps.yxy).x - Scene(p - eps.yxy).x,
                          Scene(p + eps.yyx).x - Scene(p - eps.yyx).x));
}

// Function 2056
vec4 atm_reflection_sample( sampler2D ch, vec2 uv )
{
    uv = uv * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV;
    uv.x = g_vrmode ? uv.x + .25 : max( uv.x, .5001 / float( textureSize( ch, 0 ).x ) ) + .5;
#if WITH_ATM_BILATERAL_UPSAMPLE
    vec2 tc = vec2( textureSize( ch, 0 ).xy ) * uv;
    vec2 rtc = round( tc );
    ivec2 itc = ivec2( rtc ) - 1;
    vec4 sa = texelFetchOffset( ch, itc, 0, ivec2( 0, 0 ) );
    vec4 sb = texelFetchOffset( ch, itc, 0, ivec2( 1, 0 ) );
    vec4 sc = texelFetchOffset( ch, itc, 0, ivec2( 0, 1 ) );
    vec4 sd = texelFetchOffset( ch, itc, 0, ivec2( 1, 1 ) );
    float wx0 = abs( rtc.x + .5 - tc.x );
    float wx1 = abs( rtc.x - .5 - tc.x );
    float wy0 = abs( rtc.y + .5 - tc.y );
    float wy1 = abs( rtc.y - .5 - tc.y );
    float wa = wx0 * wy0 * float( sa != vec4(0,0,0,1) );
    float wb = wx1 * wy0 * float( sb != vec4(0,0,0,1) );
    float wc = wx0 * wy1 * float( sc != vec4(0,0,0,1) );
    float wd = wx1 * wy1 * float( sd != vec4(0,0,0,1) );
    return ( sa * wa + sb * wb + sc * wc + sd * wd ) / ( wa + wb + wc + wd + 1e-6 );
#else
    return textureLod( ch, uv, 0. );
#endif
}

// Function 2057
vec3 Ray(vec2 size, vec2 fragCoord) {   
    vec2 uv =  2.0 * (fragCoord / size) - 1.;
	uv.x *= size.x / size.y;
    return normalize(vec3(uv, -5));
}

// Function 2058
float castRay( vec3 ro, vec3 rd ) {
    float startDelta=renderRange.x, delta=startDelta, stopDelta=renderRange.y;
    float maxDist = 0.002;
    for(int i = 0; i < 64; i++) {
        float dist = map(ro + rd * delta);
        if(dist <= maxDist || dist > stopDelta) break;
        delta += dist;
    }
    return delta;
}

// Function 2059
float RayPortalIntersection(
	in vec3 rayOrigin,
	in vec3 rayDir, 
	in vec3 portalNorm, 
	in vec3 portalLeft, 
	in vec3 portalUp,
	in vec3 portalPos, 
	in float portalRadius, 
	in float otherRadius,
	out vec3 localRayDir,
	out vec2 localPos, 
	out float signedDist
)
{
	float t = dot(portalNorm,portalPos-rayOrigin) / (dot(rayDir,portalNorm)); 
	vec3 intersectionPos = rayOrigin + t*rayDir; 
	
	float dotRayNorm = dot(rayDir,portalNorm); 
	
	vec3 localp = intersectionPos - portalPos;
	localPos = vec2(dot(localp,portalLeft),dot(localp,portalUp));
	localRayDir = vec3(dot(rayDir,portalLeft),dot(rayDir,portalUp),dotRayNorm); 
					
	//check distance to portal 
	const vec2 scale = vec2(PORTAL_SHAPE_INV_SCALE_X,1.0); 

	vec2 localPosScaled = localPos*scale;
	
	vec2 closestBorderPoint = normalize(localPosScaled)*min(portalRadius,otherRadius); 
	vec2 borderDeltaVec = localPosScaled - closestBorderPoint; 
	
	signedDist = dot(borderDeltaVec,closestBorderPoint)*length(borderDeltaVec/scale); 
	
	//return data
	float insidePortal = step(dotRayNorm,0.0)*step(EPSILON,t)*step(length(localPosScaled),portalRadius);
	return mix(9999.0,t,insidePortal);
}

// Function 2060
vec3 ray_sphere_intersect_inverse(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)
{
    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;
	float distance_to_ray = length(cur_shpere.position - distance_point);
    
    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))
    {
        return vec3(0,0,0);
    }

    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));

	vec3 intersect_point = distance_point + (ray_dir * inner_line_length);

    return intersect_point;
}

// Function 2061
vec3 GetTextureWithRay(Ray r, vec4 rect, float z){
    //rect = (left.x, right.x, down.y, up.y)
    float dz = (z - r.o.z);
    float dx = r.d.x/r.d.z*dz;
    float dy = r.d.y/r.d.z*dz;
    
    float x = Map(dx + r.o.x, vec2(rect.x, rect.y), vec2(-.5, .5));
    float y = Map(dy + r.o.y, vec2(rect.z, rect.w),  vec2(-.5, .5));
    
    if(x > .5 || x < -.5 || y > .5 || y < -.5) {
        return vec3(0.);
    } else return texture(iChannel0, vec2(x,y)).xyz;
}

// Function 2062
vec3 getNormal(vec3 p) {
    const vec2 e = vec2(0.0001, 0.);
    return normalize(
        vec3(
            map(p + e.xyy).x - map(p  - e.xyy).x,
            map(p + e.yxy).x - map(p  - e.yxy).x,
            map(p + e.yyx).x - map(p  - e.yyx).x
            )
        );
}

// Function 2063
vec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )
{
	vec4 sum = vec4(0.0);

	float t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;

    MARCH(40,map5);
    MARCH(40,map4);
    MARCH(30,map3);
    MARCH(30,map2);

    return clamp( sum, 0.0, 1.0 );
}

// Function 2064
void cameraRay(vec2 p, vec2 r, out vec3 ro, out vec3 rd)
{
	vec2 q = (p + p - r) * .5/r.y; // signed aspect-correct uv
	vec3 rc = vec3(0); // look at point, spins around
    float mx = iMouse.x; // mouse lookaround
    if (dot(iMouse.xy, vec2(1)) < 1.5) mx = iTime * -1.; // slowly spin if unattended
	ro = vec3(6. * cossin(4. + .02 * mx), 7).xzy; // camera rotate
	vec3 ww = normalize(rc - ro)
	, uu = normalize(cross(vec3(0,1,0), ww))
	, vv = normalize(cross(ww, uu));
	rd = normalize(uu * q.x + vv * q.y + ww);
}

// Function 2065
vec3 ComputeBaseNormal(vec2 uv) 
{
    uv = fract(uv) * 2.0 - 1.0;    
        
    vec3 ret;
    ret.xy = sqrt(uv * uv) * sign(uv);
    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));
    
    ret = ret * 0.5 + 0.5;
    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));
}

// Function 2066
vec3 draw_ray(vec2 A1, vec2 B1, vec3 col, vec2 uv){

    //line 1
    float f = 1.0-smoothstep(0.02,0.06,abs(distToLine(A1, B1, uv)));
    col = mix(col, vec3(1.,.2,.5), f);//0.5
    //segment end points line 1
    f = 1.-smoothstep(0.03,0.08,length(uv-A1)-0.02);
    col = mix(col, line1Col, f);
    //segment end points line 1
    f = 1.-smoothstep(0.03,0.08,length(uv-B1)-0.02);
    col = mix(col, line1Col, f);
    return col;
}

// Function 2067
vec3 rayDir(vec3 ro, vec3 at, vec2 uv) {
	vec3 f = normalize(at - ro),
		 r = normalize(cross(vec3(0, 1, 0), f));
	return normalize(f + r * uv.x + cross(f, r) * uv.y);
}

// Function 2068
define PRIM_RM_NORMAL(map)    {vec3 eps = vec3( 0.001, 0.0, 0.0 );N =normalize( vec3( map(P+eps.xyy) - map(P-eps.xyy),map(P+eps.yxy) - map(P-eps.yxy),map(P+eps.yyx) - map(P-eps.yyx) ));}

// Function 2069
vec4 getnormal(vec3 ro) {
    vec2 d = vec2(eps, 0.0);
    float x1 = map(ro+d.xyy).x;
    float x2 = map(ro-d.xyy).x;
    float y1 = map(ro+d.yxy).x;
    float y2 = map(ro-d.yxy).x;
    float z1 = map(ro+d.yyx).x;
    float z2 = map(ro-d.yyx).x;
    return vec4(normalize(vec3(
        x1-x2,
        y1-y2,
        z1-z2)),
        x1+x2+y1+y2+z1+z2-6.*map(ro).x);
}

// Function 2070
float castRay2(vec3 ro,vec3 rd) 
{
//	tunnel effects
    float precis=.01;
//	super waves
    if (efx_==0) precis=.3;
//	mirror carpet
    if (efx_==1) precis=.8;
    float h=0.;
    float t=.1;
    for(int i=0;i<40;i++) 
	{
		if(abs(h)>precis) break;
		h=map(ro+rd*t);
		t-=h;
	}
	return t;
}

// Function 2071
Hit traceRay(Ray r)
{
    int object = -1;
    float t = r.t;
    for (int i = 0; i < NUM_SPHERES; ++i) {
        float nt = iSphere(r, i);
        if (nt < t) {
            t = nt;
            object = i;
        }
    }
    vec3 position = vec3(0);
    vec3 normal = vec3(0);
    if (object >= 0) {
        position = r.o + t * r.d;
        normal = normalize(position - SPHERES[object].xyz);
    }
    return Hit(object >= 0, position, normal, evalMaterial(position, object));
}

// Function 2072
float AstRay (vec3 ro, vec3 rd)
{
  vec3 cIdP, p, s;
  float dHit, d, eps;
  eps = 0.0005;
  if (rd.x == 0.) rd.x = 0.001;
  if (rd.y == 0.) rd.y = 0.001;
  if (rd.z == 0.) rd.z = 0.001;
  cIdP = vec3 (-999.);
  dHit = eps;
  for (int j = 0; j < 100; j ++) {
    p = ro + rd * dHit;
    p = AstCell (p);
    if (length (cId - cIdP) > 0.) {
      AstState ();
      cIdP = cId;
    }
    d = AstDf (p);
    s = (bGrid * (cId + step (0., rd)) - p) / rd;
    d = min (d, abs (Minv3 (s)) + eps);
    dHit += d;
    if (d < eps || dHit > dstFar) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 2073
vec3 normal (in vec3 p, in float epsilon)
{
    float d = scene (p).d;
    vec3 e = vec3 (epsilon, .0, .0);
    return normalize (vec3 (scene (p + e.xyy).d - d,
                            scene (p + e.yxy).d - d,
                            scene (p + e.yyx).d - d));
}

// Function 2074
vec3 calcNormal( in vec3 pos, float t )
{
    float e = 0.001 * t;
    vec3  eps = vec3(e,0.0,0.0);
    vec3 nor;
    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);
    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);
    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);
    return normalize(nor);
}

// Function 2075
void ScreenRay(vec2 uv, Camera cam, out vec3 ro, out vec3 rd)
{
    vec3 far = ScreenToCamera(uv, 1.0, cam);
    vec3 near = cam.near / cam.far * far;
    vec3 cpos = cam.target - cam.dist * RotateFWD(cam.rot);
    ro = QuatMul(cam.rot, near) + cpos;
    rd = QuatMul(cam.rot, far);
}

// Function 2076
vec4 RayMarchInteriorGlass(vec3 ro, vec3 dir) {
    float traveled = 0.0;
    vec2 distAndMaterial = vec2(0);
    
    for (int i=ZERO; i < 50; ++i){
        distAndMaterial = sceneInsideGlassMaterials(ro + dir * traveled);
        traveled += distAndMaterial.x;
        if (distAndMaterial.x < .01 || distAndMaterial.x > MAXDISTANCE) {
            break;
        }
    }
    
    vec3 hitPoint = ro + dir * traveled;
    
    vec3 color = vec3(1);
    color = GetColor2(distAndMaterial, hitPoint, traveled);
    return vec4(color, traveled);
}

// Function 2077
vec4 ray_box(vec3 ro, vec3 rd, vec3 A, vec3 B){
    vec3 sgn = max(vec3(0.0), sign(rd));
    vec3 cN = mix(B, A, sgn);
    vec3 cF = mix(A, B, sgn);
    vec3 qA = (cN-ro)/rd;
    vec3 qB = (cF-ro)/rd;
    float tN = max(qA.x, max(qA.y, qA.z));
    float tF = min(qB.x, min(qB.y, qB.z));
    if(tN > tF) return vec4(-1.0);
    float t = tN > 0.0 ? tN : tF;
    vec3 nrm = sign(rd)*vec3(
    qA.x == tN ? 1.0 : 0.0,
    qA.y == tN ? 1.0 : 0.0,
    qA.z == tN ? 1.0 : 0.0
    );
    return vec4(nrm, t);
}

// Function 2078
float RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)
{
	float bL = length(lE-lS);
	vec3 bD = (lE-lS)/bL;
	vec3 tD = lS-rP;
	float aDb = dot(rD,bD);
	float aDt = dot(rD,tD);
	float bDt = dot(bD,tD);
	float u = (aDt-bDt*aDb)/(1.-aDb*aDb);
	float v = max(min(u*aDb-bDt,bL),0.);
	u = max(min(v*aDb+aDt,1e6),0.);
	return length((rP+rD*u)-(lS+bD*v));
}

// Function 2079
bool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    if ( IS_ZERO( ray.dir.z ) )
    	return false;
    
    t = ( -ray.origin.z ) / ray.dir.z;
    
    isect.position_ = ray.origin + ray.dir*t;
    
    if( (isect.position_.x < min_x) ||
       	(isect.position_.x > max_x) ||
      	(isect.position_.y < min_y) ||
      	(isect.position_.y > max_y) )
        return false;
    
    if( !forShadowTest ) {
        isect.uv_.x 		= (isect.position_.x - min_x)/(max_x - min_x);
        isect.uv_.y 		= (isect.position_.y - min_y)/(max_y - min_y);
        isect.normal_ 		= vec3( 0.0, 0.0, 1.0 );
        isect.tangent_ 		= vec3( 1.0, 0.0, 0.0 );
    }
    
    return true;
}

// Function 2080
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
    vec3 fuckyPos;
    float minBox, minSphere;
    vec3 adjusted;
    
	vec3 nor = vec3(
	    dist(pos+eps.xyy, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.xyy, fuckyPos, minBox, minSphere, adjusted).x,
	    dist(pos+eps.yxy, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.yxy, fuckyPos, minBox, minSphere, adjusted).x,
	    dist(pos+eps.yyx, fuckyPos, minBox, minSphere, adjusted).x - dist(pos-eps.yyx, fuckyPos, minBox, minSphere, adjusted).x );
	return normalize(nor);
}

// Function 2081
float arrayBin(DataFont f){
    float c = 0.,o = 3., y = FontUV.y-8.;
    c = Bin(f.a.r,FontUV.x,FontUV.y,c);c = Bin(f.c.r,FontUV.x,y,c);
    FontUV.x -= o;c = Bin(f.a.g,FontUV.x,FontUV.y,c);c = Bin(f.c.g,FontUV.x,y,c);
    FontUV.x -= o;c = Bin(f.a.b,FontUV.x,FontUV.y,c);c = Bin(f.c.b,FontUV.x,y,c);
    FontUV.x -= o;c = Bin(f.b.r,FontUV.x,FontUV.y,c);c = Bin(f.d.r,FontUV.x,y,c);
    FontUV.x -= o;c = Bin(f.b.g,FontUV.x,FontUV.y,c);c = Bin(f.d.g,FontUV.x,y,c);
    return c;
}

// Function 2082
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(0.002,0.0); 
    
    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,
                            map(pos+e.yxy).x - map(pos-e.yxy).x,
                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );
}

// Function 2083
vec3 calcNormal(vec3 p, float t) {
	vec2 e = vec2(EPSILON*t,0.);
    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,
                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,
                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);
    return normalize(n);
}

// Function 2084
vec2 TriangularNoise2DShereRay(vec2 n,float time){
	float theta = TWO_PI*GetRandom();
    float r = TriangularNoise(n,time);
    return vec2(cos(theta),sin(theta))*(1.-r);
}

// Function 2085
vec3 calcNormal( in vec3 pos )
{
    const float ep = 0.0001;
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*ep ).x + 
					  e.yyx*map( pos + e.yyx*ep ).x + 
					  e.yxy*map( pos + e.yxy*ep ).x + 
					  e.xxx*map( pos + e.xxx*ep ).x );
}

// Function 2086
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d, eps, sy;
  eps = 0.0005;
  dHit = eps;
  if (rd.y == 0.) rd.y = 0.001;
  for (int j = 0; j < 220; j ++) {
    p = ro + dHit * rd;
    p.y -= vShift;
    cIdV = floor (p.y / bSizeV);
    sy = (bSizeV * (cIdV + step (0., rd.y)) - p.y) / rd.y;
    d = abs (sy) + eps;
    if (cIdV >= 0. && cIdV < 2. * nFlr) {
      p.y = p.y - bSizeV * (cIdV + 0.5);
      d = min (ObjDf (p), d);
    }
    dHit += d;
    if (d < eps || dHit > dstFar) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 2087
void raycast( vec3 ro, vec3 rd, float to, float tMax, out float resT, out vec3 resPos, out uint resSurface, out uint submat )
{
    float t = to;
    for( int i=ZERO; i<256; i++ )
	{
        resPos = ro + t*rd;
		float h = map( resPos, resSurface, submat );
		if( h<0.0001 )
		{
		    resT = t;
			return;
		}
        t += h*0.75;
        if( t>tMax ) break;
	}
    resSurface = 666u;
}

// Function 2088
vec2 normalPack(vec3 n)
{
    return n.xy*0.5+0.5;
}

// Function 2089
bool raymarch(float3 start, float3 d, float t0, float t1,float stp, const int N, out float t)
{
    t=t0;
    
    int i=0;
    for(int j=0;j<1;j+=0)
    {
	    float3 p=start+d*t;
        float v=value(p);
        if(v<0.0)
            return true;
        i++;
        if(i>N)
            break;
        t+=min(0.01+v*0.25,stp);
    }
    return false;
}

// Function 2090
vec3 calcNormal( in vec3 pos, float t ) 
{
    vec2 e = vec2(0.001, 0.0);
    return normalize( vec3(map(pos+e.xyy,t).x-map(pos-e.xyy,t).x,
                           map(pos+e.yxy,t).x-map(pos-e.yxy,t).x,
                           map(pos+e.yyx,t).x-map(pos-e.yyx,t).x ) );
}

// Function 2091
float castRay(in vec3 ray_origin, in vec3 ray_direction) {
    float relaxation = 1.6;
    float distance_min =  0.01;
    float distance_max = 20.0;
    float precis   = 0.001;
    float distance = distance_min;
    float previous_radius = 0.0;
    float stepLength = 0.0;
    float function_sign = 1.0;
    if(map(ray_origin) < 0.) function_sign = -1.;
    
	for(int i = 0; i < 80; i++ ) {
        iter = float(i);
        float result= map(ray_origin + ray_direction * distance);
       
        float signed_radius = function_sign * result;
        float radius = abs(signed_radius);
        
        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;
        if(sorFail) {
        	stepLength -= relaxation * stepLength; 
            relaxation = 1.0;
        } else {
        	stepLength = signed_radius * relaxation;   
        }
        previous_radius = radius;
        if(!sorFail && radius < precis || distance > distance_max ) break;
        distance += stepLength;
    }
    return  distance;
}

// Function 2092
vec3 normal(vec3 p)
{
 	vec3 P = vec3(-4, 4, 0) * EPSILON;
 	return normalize(
        thing(p+P.xyy).x * 
        P.xyy + thing(p+P.yxy).x * 
        P.yxy + thing(p+P.yyx).x * 
        P.yyx + thing(p+P.xxx).x * 
        P.xxx
    );
}

// Function 2093
vec3 normal(vec3 position) {
    float epsilon = 0.001;
    vec3 gradient = vec3(
        sdf(position + vec3(epsilon, 0, 0)).x - sdf(position + vec3(-epsilon, 0, 0)).x,
        sdf(position + vec3(0, epsilon, 0)).x - sdf(position + vec3(0, -epsilon, 0)).x,
        sdf(position + vec3(0, 0, epsilon)).x - sdf(position + vec3(0, 0, -epsilon).x)
    );
    return normalize(gradient);
}

// Function 2094
vec3 getNormal(vec3 p, float eps) {
    vec3 n;
    n.y = map_detailed(p);    
    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;
    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;
    n.y = eps;
    return normalize(n);
}

// Function 2095
vec3 normal(vec3 p) {
    vec2 h = vec2(0.001, 0.0);
    vec3 n = vec3(
        de(p + h.xyy).x - de(p - h.xyy).x,
        de(p + h.yxy).x - de(p - h.yxy).x,
        de(p + h.yyx).x - de(p - h.yyx).x
    );
    return normalize(n);
}

// Function 2096
vec3 getRay(vec2 uv){
    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);
	vec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.1);	
    if(Resolution.x < 400.0) return proj;
	vec3 ray = axisangle(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * axisangle(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;
    return ray;
}

// Function 2097
vec3 GetNormal(vec3 p){
   vec2 e = vec2(.01,0.);
   float d = GetDist(p);
   vec3 n = d-vec3(
           GetDist(p-e.xyy),
           GetDist(p-e.yxy),
           GetDist(p-e.yyx));
   return normalize(n);
}

// Function 2098
vec3 calc_surface_normal(vec3 hit) {
	return normalize(vec3(
            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,
            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,
            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x
    ));
}

// Function 2099
vec3 calcNormal(in vec3 pos) 
{
    int mat;
    vec2 e = vec2(1.0, -1.0) * 0.001;
    return normalize(
        e.xyy * map(pos + e.xyy, mat) +
        e.yyx * map(pos + e.yyx, mat) +
        e.yxy * map(pos + e.yxy, mat) +
        e.xxx * map(pos + e.xxx, mat));
}

// Function 2100
vec2 RayMarch(vec3 ro, vec3 rd)
{
    float dO = 0.0; //distance from origin
    vec2 retval = vec2(0);
    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ro + dO*rd;	//march the ray
        retval = GetDist(p);
        float dS = retval.y;	//minimum distance from surface relative to p
        dO += dS;				//it is safe to march at least the distance dS without intersecting
        
        //approached surface close enough OR reached "infinity"
		if (dS < SURFACE_DIST || dO > MAX_DIST)
            break;
    }
    
    retval.y = dO;				//retval.x is the detected object type
    return retval;
}

// Function 2101
IntersectInfo raymarch(vec3 pos,vec3 dir){
	IntersectInfo info;
    info.distance = 1.;
    float d = 0.;
    for(int i=0;i<64;i++){
		info.surface = pos+dir*info.distance;
        d = map(info.surface);
		info.distance += d;
        if(d < 0.02||info.distance>31.) break;
    }
    info.surface += d*dir;
	info.normal = normal(info.surface);
    return info;
}

// Function 2102
vec3 CalcTerrianNormal( in vec3 pos, float t )
{
    vec2  eps = vec2( 0.003*t, 0.1 );
    return normalize( vec3( TerrainH(pos.xz-eps.xy) - TerrainH(pos.xz+eps.xy),
                            3.0*eps.x,
                            TerrainH(pos.xz-eps.yx) - TerrainH(pos.xz+eps.yx) ) );
}

// Function 2103
RMResult raymarch(vec3 ro, vec3 rd, out float t)
{
	t = 0.;
    vec3 p = ro + t * rd;
    RMResult s = map(p);
    float isInside = sign(s.dist);
    for(int i = 0; i < I_MAX; i++)
    {
        float inc = isInside * s.dist;
        if (t + inc < FAR && abs(s.dist) > EPS) 
        {
			t += inc;
	        p = ro + t * rd;
            s = map(p);
        }
        else
        {
            if (t + inc > FAR)
            {
               s.id = -1.;
            }
            break;
        }
    }
    return s;
}

// Function 2104
vec3 calcNormal(in vec3 p) {
    vec2 e = vec2(1.0, -1.0) * 0.0005;
    return normalize(
        e.xyy * map(p + e.xyy) +
        e.yyx * map(p + e.yyx) +
        e.yxy * map(p + e.yxy) +
        e.xxx * map(p + e.xxx));
}

// Function 2105
vec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {
    vec3 forward = normalize(lookAt - ro);
    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
    vec3 up = cross(forward, right);
    return normalize(forward + right * uv.x + up * uv.y);
}

// Function 2106
vec3 normal (vec3 p, float t) {
    float d = map (p, t);
    return normalize (vec3 (
        map (p - vec3 (EPSILON, 0.0, 0.0), t) - d,
        map (p - vec3 (0.0, EPSILON, 0.0), t) - d,
        map (p - vec3 (0.0, 0.0, EPSILON), t) - d
    ));
}

// Function 2107
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start
          dt = 0.,
         den = 0., _den, lut;
    for(int i=0; i<150; i++) {
        vec3 pos = ro + t*rd;
        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;
        _den = den; den = map(pos); // raw density
        lut = LUTs( _den, den );    // shaped through transfer function
        
        if( lut > .01               // optim
            && abs(pos.x) > .5      // cut a slice 
          ) {
            float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction 
         // float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse
            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse
                  col = lin * mix( vec3(1,.95,.8), vec3(.25,.3,.35), lut );// pseudo- shadowing with in-cloud depth ? 
            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog

            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // blend. Original was improperly just den*.4;
        }
        t += dt = max(.05,.02*t); // stepping
    }

    return sum; // clamp( sum, 0., 1. );
}

// Function 2108
vec3 calculateNormal(vec3 p) {
    float epsilon = 0.001;
    
    vec3 normal = vec3(
                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,
                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,
                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance
                       );
    
    return normalize(normal);
}

// Function 2109
vec3 Scene_Normal(vec3 p, float r, inout RayHit hit)
{
    vec2 e = vec2(1.0, -1.0);
    
    vec2 r0 = Scene_SDF(p + e.xyy, hit);
    vec2 r1 = Scene_SDF(p + e.yyx, hit);
    vec2 r2 = Scene_SDF(p + e.yxy, hit);
    vec2 r3 = Scene_SDF(p + e.xxx, hit);
    
    vec3 norm = e.xyy * mix(r0.x, r0.y, r) + 
                e.yyx * mix(r1.x, r1.y, r) + 
                e.yxy * mix(r2.x, r2.y, r) + 
                e.xxx * mix(r3.x, r3.y, r);
    
    return normalize(norm);
}

// Function 2110
float castRays(vec2 p){
    // cast rays in all directions out from point
    float c = 0.0;
    float a = rand(p)*DA;
    for (int i = 0 ; i < SAMPLES360 ; i++) {
        a += DA;
        vec2 v = vec2(sin(a), cos(a));
        c += traceRay(p, v);
    }
    c /= float(SAMPLES360);
    return c;
}

// Function 2111
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 150; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (p);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;
  }
  if (p.y < 0.) dHit = dstFar;
  return dHit;
}

// Function 2112
vec3 GetEnvColorReflection(vec3 rayDir, vec3 sunDir, float ambient)
{
	vec3 tex = texture(iChannel0, rayDir).xyz;
	tex = tex * tex;
    vec3 texBack = texture(iChannel0, rayDir).xyz;
    vec3 texDark = pow(texBack, vec3(50.0)).zzz;	// fake hdr texture
    texBack += texDark*0.5 * ambient;
    return texBack*texBack*texBack;
}

// Function 2113
float Raymarch( const in C_Ray ray )
{        
    float fDistance = .1;
    bool hit = false;
    for(int i=0;i < 50; i++)
    {
			float fSceneDist = MapToScene( ray.vOrigin + ray.vDir * fDistance );
			if(fSceneDist <= 0.01 || fDistance >= 150.0)
			{
				hit = true;
                break;
			} 

        	fDistance = fDistance + fSceneDist;
	}
	
	return fDistance;
}

// Function 2114
bool simulateRay(inout ray r) {
    float dist;
    rObj o;
    
    while(dist < 100.0) {
        float tDist;
        o = closestObj(tDist, r.pos);
        dist += tDist;
        r.pos += r.dir * tDist;
        if(tDist < EPSILON) {
            material(r, o);
            return true;
        }
    }
    
    r.col *= texture(iChannel1, r.dir).xyz * 2.;
    
    return false;
}

// Function 2115
vec3 normal(vec3 pos)
{
	vec2 eps = vec2(0.001, 0.0);
	float dx = map(pos+eps.xyy)-map(pos-eps.xyy);
	float dy = map(pos+eps.yxy)-map(pos-eps.yxy);
	float dz = map(pos+eps.yyx)-map(pos-eps.yyx);
	return normalize(vec3(dx, dy, dz));
}

// Function 2116
bool traceShadowRay(Ray ray) {
    for (int k = 0; k < NUM_SPHERES; k++) {
        HitInfo hitInfoTemp;
        if (intersectSphere(spheres[k], ray, hitInfoTemp)) {
            return true;
        }
    }
    for (int k = 0; k < NUM_PLANES; k++) {
        HitInfo hitInfoTemp;
        if (intersectPlane(planes[k], ray, hitInfoTemp)) {
            return true;
        }
    }
    
    return false;
}

// Function 2117
vec3 normal2(in vec3 rp) {
    return normalize(vec3(df(rp+ne)-df(rp-ne),
                          df(rp+ne.yxz)-df(rp-ne.yxz),
                          df(rp+ne.yzx)-df(rp-ne.yzx)));
}

// Function 2118
vec3 getNormalInterp(vec3 lmn, float time) {
    vec3 grad = vec3(
        DENSITY(lmn + vec3(0.1, 0.0, 0.0)) - DENSITY(lmn - vec3(0.1, 0.0, 0.0)),
        DENSITY(lmn + vec3(0.0, 0.1, 0.0)) - DENSITY(lmn - vec3(0.0, 0.1, 0.0)),
        DENSITY(lmn + vec3(0.0, 0.0, 0.1)) - DENSITY(lmn - vec3(0.0, 0.0, 0.1))
    );
    return -grad/(length(grad) + 1e-5);
}

// Function 2119
vec3 get_normal(vec3 pos) {
    const vec3 small_step = vec3(1e-1, 0.0, 0.0);

    float gradient_x = get_distance(pos + small_step.xyy) - get_distance(pos - small_step.xyy);
    float gradient_y = get_distance(pos + small_step.yxy) - get_distance(pos - small_step.yxy);
    float gradient_z = get_distance(pos + small_step.yyx) - get_distance(pos - small_step.yyx);
    
    return normalize(vec3(gradient_x, gradient_y, gradient_z));
}

// Function 2120
vec3 ray_color(vec3 eye, vec3 dir) {
    // time-varying sky parameters
    vec3 sky_color = mix(sky_base, sun_color, scat_frac*h*h*h);
    vec3 sun_dir = normalize(vec3(cos(iTime/SQRT2), -0.5, sin(iTime/SQRT2)));
    
    float r = 0.;
    for (int cnt = 0; cnt < steps; cnt++) {
        // find ray position
        vec3 p = eye + r*dir;
        
        // find scene distance
        float dist = scene(p);
        
        // march
        if (dist < eps) {
            vec3 normal = normalize(scene_grad(p));
            vec3 rad = radiance(vec3(1.0, 0.4, 0.5), sky_color, normal, dir, sun_dir);
            
            // this is a kludgy way to deal with the fact that the spheres cover
            // the whole sky. the idea is that faraway spheres act like dust
            // that contributes to atmospheric perspective, rather than distinct
            // objects that block out the sky. the implementation probably isn't
            // very physical; i just picked something that looked all right
            vec3 atm_color;
            if (r < dust_horizon) {
                atm_color = sky_color;
            } else {
                atm_color = mix(skylight(dir, sun_dir), sky_color, exp(-0.05*(r-dust_horizon)));
            }
            return mix(atm_color, rad, exp(-0.2*r));
        } else if (r > horizon) {
            return skylight(dir, sun_dir);
        } else {
            r += dist;
        }
    }
    
    // if you see lime green, we ran out of steps
    return vec3(0., 1., 0.);
}

// Function 2121
vec3 normal(vec3 p)
{
    float d = map(p);
    vec2 e = vec2(.001,.0);
    return normalize(
    vec3(
    	d - map(p + e.xyy),
    	d - map(p + e.yxy),
    	d - map(p + e.yyx)
        )
    );
}

// Function 2122
mat2x4 rayTrace(in vec3 ro, in vec3 rd) {
    vec3 p0 = ro;

    vec2 dir = normalize(rd.xz);
    float s = rd.y / length(rd.xz);
    
    vec2 mg = vec2(0.0), mr = vec2(0.0), n = vec2(0.0), f = vec2(0.0);
    voronoi_s(p0.xz, n, f, mg, mr);
    
    vec2 pmg = mg, pmr = mr;
    float h = map(n + pmg);
    
    vec3 dn = voronoi_n(dir, n, f, mg, mr);
    vec3 pdn = dn;
    
    float rh = p0.y + dn.x*s, prh = p0.y;
	
    const int steps = 128;
    for (int  i = 0; i < steps; ++i) { 
        if (h > prh || h > rh || rh > 32.0) break; 
        
        prh = rh; 
        pmg = mg; pmr = mr;
        pdn = dn;

        h = map(n + mg);
        dn = voronoi_n(dir, n, f, mg, mr);
        
        rh = p0.y + dn.x*s;
    }
    
    if (!(h > prh || h > rh || rh < 32.0)) return mat2x4(0.0); 

    
    vec3 p = vec3(p0.xz + dir*abs((p0.y - h)/s), h).xzy;
    vec3 nor = vec3(0.0, 1.0, 0.0);
    if (h > prh) {
    	p = vec3(p0.xz + dir*pdn.x, prh).xzy;
    	nor = vec3(-pdn.yz, 0.0).xzy;
    }
    
    return mat2x4(vec4(nor, 1.0), vec4(p, 1.0));
}

// Function 2123
vec3 calcNormal( const vec3 pos ) {
    vec3 eps = vec3(0.1,0.0,0.0);

	return normalize( vec3(
           mapTerrain(pos+eps.xyy).x - mapTerrain(pos-eps.xyy).x,
           mapTerrain(pos+eps.yxy).x - mapTerrain(pos-eps.yxy).x,
           mapTerrain(pos+eps.yyx).x - mapTerrain(pos-eps.yyx).x ) );
}

// Function 2124
vec3 getNormal(in vec3 p, in float bounce, in float stretch) {
    vec3 e = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(mapScene(p + e.xyy, bounce, stretch) - mapScene(p - e.xyy, bounce, stretch),
                          mapScene(p + e.yxy, bounce, stretch) - mapScene(p - e.yxy, bounce, stretch),
                          mapScene(p + e.yyx, bounce, stretch) - mapScene(p - e.yyx, bounce, stretch)));
}

// Function 2125
vec3 getNormal(vec3 p)
{
	float h = 0.0001;

	return normalize(vec3(
		distanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),
		distanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),
		distanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));
}

// Function 2126
vec3 getNormal(vec3 p, float sphereR)
{
	vec2 j = vec2(sphereR, 0.0);
	vec3 nor  	= vec3(0.0,		terrainD(p.xz, sphereR), 0.0);
	vec3 v2		= nor-vec3(j.x,	terrainD(p.xz+j, sphereR), 0.0);
	vec3 v3		= nor-vec3(0.0,	terrainD(p.xz-j.yx, sphereR), -j.x);
	nor = cross(v2, v3);
	return normalize(nor);
}

// Function 2127
vec2 checkRayHit( vec3 eyePos, vec3 rayDir )
{
  	float distToSurface = SURFACE_HIT_PRECISION * 2.;
    
  	// The total distance traveled by the ray obviously should start at 0
  	float totalDist = 0.;
  	float finalDist = 0.;
    
  	// if our id is less that 0. , it means we haven't hit anything
  	float id = -1.;

  	for( int i = 0; i < MAX_STEPS; i++ ) {
    	// Break if we hit the surface
    	if( distToSurface < SURFACE_HIT_PRECISION ) break;
    
    	// Break if we reach end of the scene
    	if( totalDist > MAX_DIST ) break;
    
    	// Current pos starts at eyePos then follows rayDir along the total distance traveled by the ray
    	vec3 currentPos = eyePos + rayDir * totalDist;
    	vec2 distToObj = useShape( currentPos );
 	
		id = distToObj.y;
        totalDist += distToObj.x;
	}

  	if( totalDist < MAX_DIST ) {
  		finalDist = totalDist;
  	}

  	if( totalDist > MAX_DIST ){ 
  		finalDist = MAX_DIST;
    	id = -1.;
  	}

  	return vec2( finalDist , id );
}

// Function 2128
vec3 normal(vec3 p)
{
	vec3 o = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),
                          map(p+o.yxy) - map(p-o.yxy),
                          map(p+o.yyx) - map(p-o.yyx)));
}

// Function 2129
void setRay(vec2 uv, out vec3 ray_origin, out vec3 ray_dir)
{
    ray_origin = cam_pos;
    ray_dir = normalize(uv.x * cam_right + uv.y * cam_up + cam_forward);
}

// Function 2130
float4 rayMarch(float3 rayOrigin, float3 rayStep, out float3 pos)
{
	float4 sum = float4(0, 0, 0, 0);
	pos = rayOrigin;
	for(int i=0; i<_VolumeSteps; i++) {
		float4 col = volumeFunc(pos);
		col.a *= _Density;
		col.a = min(col.a, 1.0);
		
		// pre-multiply alpha
		col.rgb *= col.a;
		sum = sum + col*(1.0 - sum.a);	
#if 0
		// exit early if opaque
        	if (sum.a > _OpacityThreshold)
            		break;
#endif		
		pos += rayStep;
	}
	return sum;
}

// Function 2131
vec3 calcNormal( in vec3 pos ){
    
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
    
}

// Function 2132
vec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {
	vec3 f = normalize(lookAt - ro),
	     r = normalize(cross(vec3(0, 1, 0), f));
	return normalize(f + r * uv.x + cross(f, r) * uv.y);
}

// Function 2133
vec3 normalFunction(vec3 p)
{
	const float eps = 0.01;
	float m;
    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z),m) - distf(vec3(p.x+eps,p.y,p.z),m)),
                   (distf(vec3(p.x,p.y-eps,p.z),m) - distf(vec3(p.x,p.y+eps,p.z),m)),
                   (distf(vec3(p.x,p.y,p.z-eps),m) - distf(vec3(p.x,p.y,p.z+eps),m))
				 );
    return normalize( n );
}

// Function 2134
vec3 ray(vec2 uv, vec3 ro, vec3 ta){
  
    vec3 fwd = normalize(ta - ro);
    vec3 uu = vec3(0.,1.,0.);
    vec3 ri = normalize(cross(uu,fwd));
    vec3 up = normalize(cross(fwd,ri));
  
    
    return normalize(uv.x*ri + uv.y*up + fwd*0.9);
}

// Function 2135
vec3 calcNormal(vec3 pos)
{
    float eps = 0.0002, d = map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 2136
void raytrace_tesseract(
	vec4 tesseract_center,
    vec4 tesseract_scale,
	vec4 world_ray_origin,
	vec4 world_ray_direction,
	inout vec3 inout_ray_color,
	inout float inout_ray_depth)
{
    // Using this method: https://tavianator.com/fast-branchless-raybounding-box-intersections/
        
    vec4 local_ray_origin = (s_tesseract_world_to_local_rotation * (world_ray_origin - tesseract_center));
    vec4 local_ray_direction = (s_tesseract_world_to_local_rotation * world_ray_direction);
    
    vec4 local_ray_direction_inverse = (1.0 / local_ray_direction);
    
    float result_near_depth = 0.0;
    float result_far_depth = 1000000.0;
    
    // X-slab
    {
        float pos_x_depth = ((tesseract_scale.x - local_ray_origin.x) * local_ray_direction_inverse.x);
        float neg_x_depth = (((-1.0 * tesseract_scale.x) - local_ray_origin.x) * local_ray_direction_inverse.x);
        
        float x_near_depth = min(pos_x_depth, neg_x_depth);
        float x_far_depth = max(pos_x_depth, neg_x_depth);
        
        result_near_depth = max(result_near_depth, x_near_depth);
        result_far_depth = min(result_far_depth, x_far_depth);
    }
    
    // Y-slab
    {
        float pos_y_depth = ((tesseract_scale.y - local_ray_origin.y) * local_ray_direction_inverse.y);
        float neg_y_depth = (((-1.0 * tesseract_scale.y) - local_ray_origin.y) * local_ray_direction_inverse.y);
        
        float y_near_depth = min(pos_y_depth, neg_y_depth);
        float y_far_depth = max(pos_y_depth, neg_y_depth);
        
        result_near_depth = max(result_near_depth, y_near_depth);
        result_far_depth = min(result_far_depth, y_far_depth);
    }
    
    // Z-slab
    {
        float pos_z_depth = ((tesseract_scale.z - local_ray_origin.z) * local_ray_direction_inverse.z);
        float neg_z_depth = (((-1.0 * tesseract_scale.z) - local_ray_origin.z) * local_ray_direction_inverse.z);
        
        float z_near_depth = min(pos_z_depth, neg_z_depth);
        float z_far_depth = max(pos_z_depth, neg_z_depth);
        
        result_near_depth = max(result_near_depth, z_near_depth);
        result_far_depth = min(result_far_depth, z_far_depth);
    }    
    
    // W-slab
    {
        float pos_w_depth = ((tesseract_scale.w - local_ray_origin.w) * local_ray_direction_inverse.w);
        float neg_w_depth = (((-1.0 * tesseract_scale.w) - local_ray_origin.w) * local_ray_direction_inverse.w);
        
        float w_near_depth = min(pos_w_depth, neg_w_depth);
        float w_far_depth = max(pos_w_depth, neg_w_depth);
        
        result_near_depth = max(result_near_depth, w_near_depth);
        result_far_depth = min(result_far_depth, w_far_depth);
    }
    
    if ((result_near_depth <= result_far_depth) &&
        (result_near_depth < inout_ray_depth))
    {
        vec4 normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_near_depth)) / tesseract_scale);
        
        float cube_hole_fraction = smoothstep(0.1, 1.0, s_mouse_fractions.x);
        cube_hole_fraction = 0.8;
        
        if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))
        {
            inout_ray_color = vec3(1.0);
            inout_ray_depth = result_near_depth;

            // Lighting
            if (true)
            {
                vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * sign(normalized_local_surface));
                float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));

                inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);
            }
        }
        else if (result_far_depth < inout_ray_depth)
        {
            normalized_local_surface = ((local_ray_origin + (local_ray_direction * result_far_depth)) / tesseract_scale);

            if ((step(cube_hole_fraction, abs(normalized_local_surface)) * step(abs(normalized_local_surface), vec4(0.999999))) != vec4(0.0))
            {
                inout_ray_color = vec3(1.0);
                inout_ray_depth = result_far_depth;

                // Lighting
                if (true)
                {
                    vec4 surface_normal = (normalize(step(0.999, abs(normalized_local_surface))) * (-1.0 * sign(normalized_local_surface)));
                    float diffuse_fraction = (1.0 * max(0.0, dot(surface_normal, (s_tesseract_world_to_local_rotation * s_light_direction))));

                    inout_ray_color *= mix(s_light_ambient_color, vec3(1.0), diffuse_fraction);
                }
            }
        }
    }
}

// Function 2137
vec3 normal(vec3 p)
{
  vec2 e = vec2(.01,.0);

  return normalize(vec3(
  map(p - e.xyy) - map(p + e.xyy),
  map(p - e.yxy) - map(p + e.yxy),
  map(p - e.yyx) - map(p + e.yyx)
));
}

// Function 2138
Ray Camera_getRay(Camera camera, float s, float t)
{
    vec3 rd = camera.lensRadius * random_in_unit_disk();
    vec3 offset = camera.u * rd.x + camera.v * rd.y;

    Ray ray;

    ray.origin = camera.origin + offset;
    ray.direction = camera.lowerLeftCorner + s * camera.horizontal + t * camera.vertical - camera.origin - offset;

    return ray;
}

// Function 2139
vec3 normal(vec3 p) {
    float diff = 0.00001;
    DistanceEstimation d = DistanceEstimation(
        vec3(0.0), //p
        vec3(0.0), //s
        vec3(0.0), //d
        0.0, //l
        vec3(0.0), //n
        emat
    );
    d.p = p - diff * I3;
    float nx = distanceEstimation(d);
    d.p = p + diff * I3;
    float px = distanceEstimation(d);
    d.p = p - diff * J3;
    float ny = distanceEstimation(d);
    d.p = p + diff * J3;
    float py = distanceEstimation(d);
    d.p = p - diff * K3;
    float nz = distanceEstimation(d);
    d.p = p + diff * K3;
    float pz = distanceEstimation(d);
    return normalize(vec3(
        px - nx,
        py - ny,
        pz - nz
    ));
}

// Function 2140
float TransObjRay (vec3 ro, vec3 rd)
{
  const float dTol = 0.01;
  float d;
  float dHit = 0.;
  for (int j = 0; j < 100; j ++) {
    d = TransObjDf (ro + dHit * rd);
    dHit += d;
    if (d < dTol || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2141
Impact castRay(in vec3 ro, in vec3 inputDir)
{	
    vec3 dir = normalize(inputDir);
    float t;
    t = 0.1;
    Impact impact;
 	for (int i = 0; i < PRIM_RAY_IT; i++)
    {
        vec3 p = ro+t*dir;
        impact = map(p);     
        if(impact.d < t*0.002) {
            impact.d = t + impact.d;
            return impact;
        }
       
        t += impact.d*0.05;        
    }
    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);
}

// Function 2142
vec3 calculateNormal(vec3 pos, vec3 playerPos) {
    const vec3 e = vec3(EPS, 0.0, 0.0);
	float p = map(pos, junkMatID, playerPos, true, true);
	return normalize(vec3(map(pos + e.xyy, junkMatID, playerPos, true, true) - p,
           				  map(pos + e.yxy, junkMatID, playerPos, true, true) - p,
                          map(pos + e.yyx, junkMatID, playerPos, true, true) - p));
}

// Function 2143
vec4 castRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 10.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	
	vec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );

    // traverse regular grid (in 2D)
	vec2 mm = vec2(0.0);
	for( int i=0; i<200; i++ ) 
	{

		float ma = map(pos);
		
        // intersect capped cylinder		
		vec3  ce = vec3( pos.x+1.25, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.9;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
            // cylinder			
			float s = (-b - sqrt( h ))/a;
			if( s>0.0 && (ro.y+s*rd.y)<ma )
			{
				res = vec4( s, 0.0, pos );
    			break; 
			}
            // cap			
			s = (ma - ro.y)/rd.y;
			if( s>0.0 && (s*s*a+1.7*s*b+c)<0.0 )
			{
				res = vec4( s, 10.0, pos );
				break;
			}
		}

        // step to next cell		
		mm = step( dis.xy, dis.yx ); 
		dis += mm*ris;
        pos += mm*rs;
	}


	return res;
}

// Function 2144
bool IntersectRayCutCylinder(const Ray ray, const Capsule capsule, out vec3 p1, out vec3 n1, out float tout)
{
    vec3 ro = ray.m_Origin;
    vec3 rd = ray.m_Direction;
    vec3 cc = (capsule.m_A+capsule.m_B)/2.0;
    float ch = length( capsule.m_B - capsule.m_A );
    vec3 ca = ( capsule.m_B - capsule.m_A )/ch;
    float cr = capsule.m_Radius;

    // ----
    
    vec3  oc = ro - cc;
    ch *= 0.5;

    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    
    float a = 1.0 - card*card;
    float b = dot(oc,rd) - caoc*card;
    float c = dot(oc,oc) - caoc*caoc - cr*cr;
    float h = b*b - a*c;
    if( h<0.0 ) return false;
    
    float t = (-b-sqrt(h))/a;
    float y = caoc + t*card;

    if( abs(y)>ch ) return false;
    
    p1 = ro + rd*t;
    n1 = normalize( oc+t*rd - ca*y );
    tout = t;
    return true;
}

// Function 2145
void MakeViewRay(out vec3 viewP, out vec3 viewD, vec2 fragCoord)
{
	vec2 xy = fragCoord.xy;
	xy.y=iResolution.y-fragCoord.y;
	vec2 filmUv = (xy + vec2(0.5,0.5))/iResolution.xy;

	float tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);
	float ty = (1.0 - 2.0*filmUv.y);
	float tz = 0.0;

	viewP = vec3(0.0, 0.0, 5.0);
	viewD = vec3(tx, ty, tz) - viewP;	
	
	viewD = normalize(viewD);

	float t = iTime*0.2-pi*0.4;
//	float t = pi*0.5;
	viewD=RotX(viewD,pi*0.25); //2+sin(iTime)*0.2);
	
	viewP.y += 24.0;
	viewP.z += 20.0;
	
//	viewP.y += sin(iTime)*8.;
	
	viewP.yz -= cos(iTime*0.3)*12.;
//	viewP.yz += 8.;
		
	viewP = RotY(viewP,t);
	
	viewD = RotY(viewD,t);

}

// Function 2146
vec3 totalRayleigh(vec3 lambda)
{
    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));
}

// Function 2147
vec3 calcNormal(in vec3 p) {
	const vec2 e = vec2(0.005, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 2148
vec3 normal(vec2 pos, float e, float depth){
    vec2 ex = vec2(e, 0);
    H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;
    vec3 a = vec3(pos.x, H, pos.y);
    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y)), 
                           normalize(a-vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e))));
}

// Function 2149
vec3 textureNormal(vec2 uv) {
    uv = fract(uv) * 3.0 - 1.5;    
        
    vec3 ret;
    ret.xy = sqrt(uv * uv) * sign(uv);
    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));
    ret = ret * 0.5 + 0.5;    
    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.98,dot(uv,uv)));
}

// Function 2150
float rayhorizon(float t) {
    t = t - RO;
    poly2 f = pa_map(ro, rd, t);    
    return f.h;
}

// Function 2151
float RAYMARCH_DFAO( vec3 o, vec3 N, float isoSurfaceValue)
{
    //Variation of DFAO from : https://www.shadertoy.com/view/Xds3zN
    //Interesting reads:
    //https://docs.unrealengine.com/latest/INT/Engine/Rendering/LightingAndShadows/DistanceFieldAmbientOcclusion/index.html#howdoesitwork?
    //Implementation notes:
    //-Doubling step size at each iteration
    //-Allowing negative distance field values to contribute, making cracks much darker
    //-Not reducing effect with distance (specific to this application)
    float MaxOcclusion = 0.0;
    float TotalOcclusion = 0.0;
    const int nSAMPLES = 4;
    float stepSize = 0.11/float(nSAMPLES);
    for( int i=0; i<nSAMPLES; i++ )
    {
        float t = 0.01 + stepSize;
        //Double distance each iteration (only valid for small sample count, e.g. 4)
        stepSize = stepSize*2.0;
        float dist = DF_composition( o+N*t ).d-isoSurfaceValue;
        //Occlusion factor inferred from the difference between the 
        //distance covered along the ray, and the distance from other surrounding geometry.
        float occlusion = zclamp(t-dist);
        TotalOcclusion += occlusion;//Not reducing contribution on each iteration
        MaxOcclusion += t;
    }
    
    //Here, TotalOcclusion can actually exceed MaxOcclusion, where the rays
    //get inside the shape and grab negative occlusion values. It does look good
    //that way IMHO (much darker in the cracks), therefore the maximum occlusion is bumped
    //25% to allow those cracks to get darker.
    return saturate(1.0-TotalOcclusion/(MaxOcclusion*1.25));
}

// Function 2152
vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l-p),
        r = normalize(cross(f,vec3(0,1,0))),
        u = cross(r,f),
        c = f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}

// Function 2153
vec3 sampleNormal( vec3 p ) {
    vec3 eps = vec3(1e-3,0.,0.);
    float dx = world(p+eps).x-world(p-eps).x;
    float dy = world(p+eps.yxy).x-world(p-eps.yxy).x;
    float dz = world(p+eps.yyx).x-world(p-eps.yyx).x;
    return normalize(vec3(dx,dy,dz));
}

// Function 2154
float castShadowRay(vec3 pos, vec3 lightPos, float treshold) {
	vec3 dir = normalize(pos - lightPos);
	float maxDist = length(lightPos - pos);
	vec3 rayPos = lightPos;
	float distAccum = 0.0;
	for (int i = 0; i < MAX_SECONDARY_RAY_STEPS; i++) {
		float dist = distanceField(rayPos);
		rayPos += dist * dir;
		distAccum += dist;
	}
	if (distAccum > maxDist - treshold) return 1.0;
	else return 0.0;
}

// Function 2155
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.01;
    
#if 1    
    // dont unroll normal calculation ( from https://www.shadertoy.com/view/ldd3DX )
    
    vec3 n = vec3(0.0);
    for( int i=0; i<NO_UNROLL(4); i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*Scene_GetDistance(vPos+e*fDelta).fDist;
    }
    
    return normalize( n );
#else
    
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
#endif
}

// Function 2156
void sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){
	sd = sdWater(pos);
    vec2 e = vec2(0.01, 0.);
    normal = normalize(sd - vec3(
    	sdWater(pos - e.xyy),
    	sdWater(pos - e.yxy),
    	sdWater(pos - e.yyx)
    ));
}

// Function 2157
vec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)
{   
    vec4 sum = vec4(0.0);
    vec3 pos = ro + rd * t;
    for (int i = 0; i < 40; i++) {
        if (sum.a > 0.99 || 
            pos.y < (MIN_HEIGHT-1.0) || 
            pos.y > (MAX_HEIGHT+1.0)) break;
        
        float den = density(pos);
        
        if (den > 0.01) {
            float dif = clamp((den - density(pos+0.3*sundir))/0.6, 0.0, 1.0);

            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        
            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);
            col.rgb *= lin;

            // front to back blending    
            col.a *= 0.5;
            col.rgb *= col.a;

            sum = sum + col*(1.0 - sum.a); 
        }
        
        t += max(0.05, 0.02 * t);
        pos = ro + rd * t;
    }
    
    sum = clamp(sum, 0.0, 1.0);
    
    float h = rd.y;
    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );
    
    return mix(backCol, sum.xyz, sum.a);
}

// Function 2158
float rayleighPhase(float mu) {
    float phase = (3.0 / (16.0 * PI)) * (1.0 + mu * mu);
    return phase;
}

// Function 2159
vec3 calcNormal_3997203925(vec3 pos) {
  return calcNormal_3997203925(pos, 0.002);
}

// Function 2160
vec3 computeNormalSphere(vec3 p,Sphere s)
{
	return normalize(p - s.center);
}

// Function 2161
float raycast (in vec3 origin, in vec3 direction, in vec4 normal, in float color, in vec3 channel) {

	// The ray continues...
	color *= 1.0 - ALPHA;
	float intensity = ALPHA;
	float distanceFactor = 1.0;
	float refractIndex = dot (REFRACT_INDEX, channel);
	for (int rayBounce = 1; rayBounce < RAY_BOUNCE_MAX; ++rayBounce) {

		// Interface with the material
		vec3 refraction = refract (direction, normal.xyz, distanceFactor > 0.0 ? 1.0 / refractIndex : refractIndex);
		if (dot (refraction, refraction) < DELTA) {
			direction = reflect (direction, normal.xyz);
			origin += direction * DELTA * 2.0;
		} else {
			direction = refraction;
			distanceFactor = -distanceFactor;
		}

		// Ray marching
		float dist = RAY_LENGTH_MAX;
		for (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {
			dist = distanceFactor * getDistance (origin);
			float distMin = max (dist, DELTA);
			normal.w += distMin;
			if (dist < 0.0 || normal.w > RAY_LENGTH_MAX) {
				break;
			}
			origin += direction * distMin;
		}

		// Check whether we hit something
		if (dist >= 0.0) {
			break;
		}

		// Get the normal
		normal.xyz = distanceFactor * getNormal (origin);

		// Basic lighting
		if (distanceFactor > 0.0) {
			float relfectionDiffuse = max (0.0, dot (normal.xyz, lightDirection));
			float relfectionSpecular = pow (max (0.0, dot (reflect (direction, normal.xyz), lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;
			float localColor = (AMBIENT + relfectionDiffuse) * dot (COLOR, channel) + relfectionSpecular;
			color += localColor * (1.0 - ALPHA) * intensity;
			intensity *= ALPHA;
		}
	}

	// Get the background color
	float backColor = dot (texture (iChannel0, direction).rgb, channel);

	// Return the intensity of this color channel
	return color + backColor * intensity;
}

// Function 2162
vec3 normal(in vec3 rp) {
    return normalize(vec3(df(rp+ne)-df(rp-ne),
                          df(rp+ne.yxz)-df(rp-ne.yxz),
                          df(rp+ne.yzx)-df(rp-ne.yzx)));
}

// Function 2163
float rayAABBIntersect(vec3 co, vec3 ci, out vec3 n){
    vec3 p = vec3(0.0, -0.51069, -1.6)-co;
    
    // TODO: vectorize!
    // Reject early if for some axis,
    // the camera points perpendicular to that axis, and
    // the camera ray could not possibly intersect the cube.
    
    vec3 b=vec3(0.319,0.417,0.319);
    
    // This is a bit of a hack; while computing the inverse
    // of each of the elements of ci, we just set the value
    // to a really large value if the component is close to 0.
    // This makes t1 very negative and t2 very positive, which
    // works out.
    
    // Q: Is there a better way of doing this?
    
    vec3 cii = vec3(1000000.0);
    float eps = 0.000001;
    
    if(abs(ci.x)>eps){
        cii.x=1.0/ci.x;
    }
    if(abs(ci.y)>eps){
        cii.y=1.0/ci.y;
    }
    if(abs(ci.z)>eps){
        cii.z=1.0/ci.z;
    }
    
    vec3 pi = p*cii;
    vec3 bc = abs(b*cii);
    
    vec3 t1 = pi-bc;
    vec3 t2 = pi+bc;
    float tmin = max(t1.x, max(t1.y, t1.z));
    float tmax = min(t2.x, min(t2.y, t2.z));
    
    if(tmin>tmax || tmax<0.0) return -1.0;
    
    // Compute the normal
    n = vec3(0.0);
    if(t1.x>=tmin) n.x=-1.0;
    if(t1.y>=tmin) n.y=-1.0;
    if(t1.z>=tmin) n.z=-1.0;
    n*=sign(ci);
    
    return tmin;
}

// Function 2164
vec3 getNormal(const in vec3 p){  
    vec2 e = vec2(-1., 1.)*0.005;   
	return normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );}

// Function 2165
bool rayMarch(vec3 r0, vec3 rd, inout float d)
{
    d = 0.0;
    for(int i = 0; i < 100; ++i)
        {
            vec3 p = r0 + d * rd;
            float t = map(p);
            d += t;
            if(abs(t) < 0.001)
            {
                return true;
            }
            if(d > 200.0) break;
        }
    return false;
}

// Function 2166
Ray GetRay(vec2 uv, vec3 camPos, vec3 dir, float zoom){
    Ray r;
    r.o = camPos;
    vec3 f = normalize(dir);
    vec3 right = cross(vec3(.0,1.,.0), f);
    vec3 u = cross(f,right);
    
    vec3 c = r.o + f*zoom;
    vec3 i = c + uv.x *right + uv.y *u;
    r.d = normalize(i -r.o);
    return r;
}

// Function 2167
bool rayAABBIntersection( in Ray ray, AABB aabb, out float t_enter, out float t_exit ) {
    vec3 OMIN = ( aabb.min_ - ray.origin ) / ray.dir;
    vec3 OMAX = ( aabb.max_ - ray.origin ) / ray.dir;
    vec3 MAX = max ( OMAX, OMIN );
    vec3 MIN = min ( OMAX, OMIN );
    t_exit = min ( MAX.x, min ( MAX.y, MAX.z ) );
    t_enter = max ( MIN.x, max ( MIN.y, MIN.z ) );
    
    if ( t_exit <= t_enter )
        return false;
    
    return ( t_exit > t_enter );
}

// Function 2168
vec2 raymarch(vec3 ro, vec3 rd) {
	float tmin = .01;
    float tmax = 80.;
    float m = -1.;
    float t = tmin;
    for(int i = 0; i < 99; i++) {
		vec3 pos = ro + rd * t;
        vec2 h = scene(pos);
        m = h.y;
        if(abs(h.x) < (stopThreshold * t)) break;
        t += h.x;
        if(t > tmax) break;
    }
    if(t > tmax) m = -1.;
    return vec2(t, m);
}

// Function 2169
vec2 raymarch(vec3 ro, vec3 rd, float tmin, float tmax)
{
    vec2 nearest = vec2(tmin, TYPE_DEFAULT);
    for(int i=0;i<RAYMARCH_ITERATIONS;i++)
    {
        vec3 p = ro+rd*nearest.x;
        vec2 res = map(p);
        if(res.x<tmin || nearest.x>tmax)
            break;
        nearest.x += 0.5*res.x*res.x; // res square solves a lot of temporal depth noise
        nearest.y = res.y;
    }
    return nearest;
}

// Function 2170
vec3 worldGetBRDFRay( in vec3 pos, in vec3 nor, in vec3 eye, float fre )
{
    if( random2f().x > fre )
    {
        return cosineDirection( nor );
    }
    else
    {
        return reflect(eye, nor);
    }
}

// Function 2171
float raymarch_againstphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )
{
    return raymarch( o, target, start_time, -1., objPos );
}

// Function 2172
vec3 getNormal(vec3 p, float e)
{
    return normalize( vec3( map(p+vec3(e,0.0,0.0), e) - map(p-vec3(e,0.0,0.0), e),
                            map(p+vec3(0.0,e,0.0), e) - map(p-vec3(0.0,e,0.0), e),
                            map(p+vec3(0.0,0.0,e), e) - map(p-vec3(0.0,0.0,e), e) ) );
}

// Function 2173
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(.001, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 2174
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 2175
vec3 calcNormal(vec3 pos)
{

    vec3	col;
    vec2	eps = vec2(EPS, 0);
	float d = map(pos);
	return normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));
}

// Function 2176
hitInfo rayMarchArray(vec3 origin, vec3 dir)
{
    vec3 size = vec3(0.95,0.95,0.95);
    float t=1.0;
    hitInfo info;
    for(int i=0; i < 100; ++i)
    {
        //Cube position
        vec3 p = origin+t*dir;
        vec3 cubePos = floor(p/CELL_SIZE)*CELL_SIZE+0.5*CELL_SIZE;
        
        //rotation values
        float yaw = sin(iTime+cubePos.x+cubePos.y+cubePos.z);
        float pitch = iTime/1.0+sin(iTime+cubePos.x+cubePos.y+cubePos.z);
    	
        //rotated ray origin and direction
        vec3 rd = rotate(dir,yaw,pitch);
		vec3 ro = rotate(origin-cubePos,yaw,pitch);
        
        //ray-cube intersection function
        info = rayCubeIntersec(ro,rd,size);
        
        //check for hit : stop or continue.
        if(info.dist<MAX_DIST)
        	break;
        
        //Step into the next cell.
        t = t+CELL_SIZE; 
    }
    return info;
}

// Function 2177
vec3 getNormal (vec3 p) { vec2 e = vec2(.001,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }

// Function 2178
vec3 raymarch(vec3 raydir, vec3 rayori){
    // Start our ray (moved slightly forward for dithering)
    vec3 raypos = rayori+(raydir*rand()*stepsize);

    for(uint i = 0U; i < maxmarches; i++){
        // Check if we reached our Source
        if(raypos.z > 0.0){return vec3(signal(raypos.xy));}

        // Check if the Ray is Outside an Acceptable Position
        if(abs(raypos.z) < scenesize || length(raypos.xy) > transmissionlanesize){break;}

        // "Distort" the Ray
        raydir = normalize(raydir+(fbm3(raypos*2.0)*0.025));

        // March the Ray
        raypos += raydir*stepsize;
    }

    // If the ray reached an unacceptable position or never hit anything, output 0.0
    return vec3(0.0);
}

// Function 2179
vec3 calcNormal( in vec3 pos ){
    
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 2180
vec3 calcNormalstage7(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage7 (p+e.xyy) - mapstage7(p-e.xyy),
            mapstage7 (p+e.yxy) - mapstage7(p-e.yxy),
            mapstage7 (p+e.yyx) - mapstage7(p-e.yyx)                            
        )
	);
}

// Function 2181
vec3 calcNormal( in vec3 pos, float time )
{
    
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;
    return normalize( e.xyy*map( pos + e.xyy, time ).x + 
					  e.yyx*map( pos + e.yyx, time ).x + 
					  e.yxy*map( pos + e.yxy, time ).x + 
					  e.xxx*map( pos + e.xxx, time ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.001*e,time).x;
    }
    return normalize(n);
#endif    
}

// Function 2182
vec3 TowerReflect(vec3 p)
{
	vec3 q=p;
	q.xz=abs(p.xz); 
	q.xz -= vec2(6.,8.);
	return q;
}

// Function 2183
vec3 normal2(vec3 p){
    return normalize(vec3(
        plane(vec3(p.x + E, p.y, p.z)) - plane(vec3(p.x - E, p.y, p.z)),
        plane(vec3(p.x, p.y + E, p.z)) - plane(vec3(p.x, p.y - E, p.z)),
        plane(vec3(p.x, p.y, p.z + E)) - plane(vec3(p.x, p.y, p.z - E))
    ));
}

// Function 2184
float RayMarch(vec3 ro, vec3 rd) {
	float dO=0.;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    return dO;
}

// Function 2185
float cubic_bezier_normal_iteration3(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){
	vec2 tang=(3.*a3*t+2.*a2)*t+a1;
	vec3 poly=vec3(dot(a0,tang),dot(a1,tang),dot(a2,tang))/dot(a3,tang);

	/* newton iteration on this polynomial is equivalent to cubic_bezier_normal_iteration */
	return newton_iteration3(poly,t);

	/* halley iteration on this polynomial is equivalent to cubic_bezier_normal_iteration2 */
	//return halley_iteration3(poly,t);
}

// Function 2186
vec3 getNormal2(vec3 p){
    float c;
    int o;
	return normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),
    					  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),
                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));
}

// Function 2187
vec3 rayDir( float fov, vec2 size, vec2 pos )
{
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );	
	float z = size.y * 0.5 * cot_half_fov;
	
	return normalize( vec3( xy, z ) );
}

// Function 2188
vec3 godRaySet3( in vec2 uv, inout float count, in vec3 oceanGradient )
{
    vec2 sunBeamOrigin;
    float beamAngle;
    
    const vec2 beamDir = normalize( vec2(-0.05, -1.0) );//vec2(-0.2,-1.0);

    for(float i=0.0; i<=10.0; i++)
    {
        sunBeamOrigin = vec2(0.25 + i*0.1,5.0);
        float noise = remap(rand(sunBeamOrigin), 0.0, 1.0, 0.35, 1.15);
        float t = (1.0+sin(iTime*0.4+0.45678))*0.5;
        t = remap(t, 0.0,1.0,0.5,1.0);
        beamAngle = abs(sin(0.0035*PI*t)) * noise;
            
        vec2 sunToPoint = normalize(uv - sunBeamOrigin);
        float theta = acos(dot(sunToPoint, beamDir));
        
        if( theta < beamAngle )
        {
            count += 1.0;
            //float alpha = theta*0.15915; // 1/(2*PI) = 0.15915
            float beta = smoothstep(0.0, 0.8, 1.0-theta/beamAngle);
            vec3 godRayColor = mix(oceanGradient, SUN_BEAM_SMALL, 0.5);
            return mix(OCEANBLUE3, godRayColor, beta*uv.y);
        }
    }
    
    return vec3(0.0);
}

// Function 2189
vec3 getNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,
        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,
        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist
    ));
}

// Function 2190
float castRay(const vec3 ro, const vec3 rd, out float resT) {
    const float odelt = 0.01f;
    float delt = odelt;
    float dt = delt;
    const float mint = 0.001f;
    const float maxt = 10.0f;
    float lh = 0.0f;
    float ly = 0.0f;
    
    float t = iFrame == 0 ? mint : resT; //max(mint, resT);
    vec3 p = ro + rd*t;
    float h = terrain(p);
    if (p.y < h) {
        t = (mint + t) / 2.0;
        //t = mint;
    }
    
    float ret = 0.0;
    for (int i = 0; i < 1000; i++) {
        
        vec3 p = ro + rd*t;
        float h = terrain(p);
        
        //h = min(h, h2);
        resT = t;
        if (p.y < h) {
            // interpolate the intersection distance
            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);
            ret = 2.0;
            break;
        }
        
        t += delt;
        if (t > maxt) break;
        
        // allow the error to be proportional to the distance
        delt = odelt * t;
        dt = delt;
        lh = h;
        ly = p.y;
    }
    
    /*if (ret == 0.0) {
    	ret = castRay2(ro, rd, resT);
    }*/
    ret = castRay2(ro, rd, ret, resT);
    
    return ret;
}

// Function 2191
float castRayx(vec3 ro,vec3 rd) 
{
    float precis = .0001;
    float h = precis*2.;
    float t = 0.;
	for(int i=0;i<100;i++) 
	{
        if(abs(h)<precis||t>12.)break;
		h = -map(ro+rd*t); 
        t += h;
	}
    return t;
}

// Function 2192
vec3 calcNormal( in vec3 pos, in float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 2193
Ray castRay(Ray ray)
{
    Hit hit = traceScene(ray);
    ray.t = hit.t;
    float roughness = hit.mat.roughness * hit.mat.roughness;
    
    // check if there were any participating media along the way and update ray
    ray = traceVolumes(ray);
    
    if(hit.hit)
    {
        float ref_idx = hit.mat.refractiveIndex;
        
        ray.radiance = vec3(0.0);
        ray.rand = random(ray.rand);
        
        ray.origin = ray.t*ray.direction + ray.origin;
        ray.attenuation = ray.attenuation * hit.mat.albedo;
        
        if(hit.mat.type == DIELECTRIC)
        {
            float cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);
            float schlick = schlick(cosine, ref_idx);
            
            if(ray.rand > schlick)
            {
				ray.direction = normalize(hit.normal + randv(ray.rand));
            }
            else
            {
				ray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);
            }
        }
        
        else if(hit.mat.type == METALIC)
        {
			ray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);
        }
        
        // from raytracing in a weekend
        else if(hit.mat.type == GLASS)
        {        
            float cosine;
            float ni_nt;
            vec3 normal;
            
            if(dot(ray.direction, hit.normal) > 0.0)
            {
				normal = -hit.normal;
               	ni_nt = ref_idx;
                cosine = ref_idx * dot(ray.direction, hit.normal) / length(ray.direction);
            }
            else
            {
                normal = hit.normal;
                ni_nt = 1.0 / ref_idx;
                cosine = -dot(ray.direction, hit.normal) / length(ray.direction);
            }
            
            float schlick0;
            Refracted ref = refract0(ray.direction, normal, ni_nt);
            
            if(ref.did)
            {
                schlick0 = schlick(cosine, ref_idx);
            }
            else
            {  
                schlick0 = 1.0;
            }
           	
            if(ray.rand > schlick0)
            {
                ray.direction = normalize(ref.direction + randv(ray.rand)*roughness);
            }
            else
            {
				ray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);
            }
        }
        else if(hit.mat.type == EMISSIVE)
        {
			float cosine = -dot(ray.direction, mix(hit.normal, -ray.direction, roughness)) / length(ray.direction);
            float schlick = schlick(cosine, ref_idx);
            
            if(ray.rand > schlick)
            {
                ray.direction = normalize(hit.normal + randv(ray.rand)*roughness);
                ray.radiance = hit.mat.albedo;
            }
            else
            {
				ray.direction = normalize(reflect(ray.direction, hit.normal) + randv(ray.rand)*roughness);
            }
            ray.done = true;
        }
    }
    else
    {
        ray.radiance = backgroundColor(ray.direction);
        ray.done = true;
    }
    
    return ray;   
}

// Function 2194
float CastRay( in vec3 ro, in vec3 rd )
{
    const float maxd = 500.0;
    
    float h = 1.0;
    float t = 0.0;
   
    for ( int i = 0; i < 128; ++i )
    {
        if ( h < 0.01 || t > maxd ) 
        {
            break;
        }
        
        h = Scene( ro + rd * t );
        t += h;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }

    return t;
}

// Function 2195
vec3 getNormal(vec3 p) {
    
    // This is a somewhat hacky way of getting the normal for this heightmap
    // The above getNormal function is imperfect due to the non-continous heightmap
    
    // Get the normal of the value noise (not the stepped heightmap)
    
    vec2 eps = vec2(0.005, 0.00);
    vec3 normal = vec3(
    	(valueNoise((p.xz + eps.xy) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.xy) * HSCALE) * VSCALE),
		2.0 * eps.x,
		(valueNoise((p.xz + eps.yx) * HSCALE) * VSCALE) - (valueNoise((p.xz - eps.yx) * HSCALE) * VSCALE)
    );
    
    // Work out whether the point is in a horizontal or vertical section
    float stepEps = 0.012;
    float stepSection = mod(p.y / STEPHEIGHT, 1.0);
    bool isOnCliff = true;
    if (stepSection < stepEps || stepSection > (1.0 - stepEps)) {
    	isOnCliff = false;
    }
    
    // Adjust the normal accordingly
    if (isOnCliff) {
    	normal = vec3(normal.x, 0.0, normal.z);
    }
    else {
    	normal = vec3(0.0, 1.0, 0.0);
    }
    
    // Normalise and return the normal
    normal = normalize(normal);
    return normal;
    
}

// Function 2196
float get_dist_ray_point(Ray ray, vec3 point)
{
    float t = (dot(ray.dir, point - ray.pos)/dot(ray.dir, ray.dir));
    
    if (t > 0.0)
    {
        return length(point - (ray.pos + t * ray.dir));
    }
    
    return length(point - ray.pos);
}

// Function 2197
vec3 getNormalP(vec3 p) {
    return normalize(vec3(
        planeSD(vec3(p.x + EPSILON, p.y, p.z)) - planeSD(vec3(p.x - EPSILON, p.y, p.z)),
        planeSD(vec3(p.x, p.y + EPSILON, p.z)) - planeSD(vec3(p.x, p.y - EPSILON, p.z)),
        planeSD(vec3(p.x, p.y, p.z  + EPSILON)) - planeSD(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 2198
vec3 getNormal(vec3 pos)
{
    vec3 eps = vec3(0.0001,0.0,0.0);

    return normalize( vec3(
      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,
      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,
      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );
}

// Function 2199
vec3 calcNormal(in vec3 pos, float camtime)
{
  vec2 eps = vec2(0.002, 0.0);
  vec3 nor;
  nor.x = map(pos+eps.xyy,camtime).x - map(pos-eps.xyy,camtime).x;
  nor.y = map(pos+eps.yxy,camtime).x - map(pos-eps.yxy,camtime).x;
  nor.z = map(pos+eps.yyx,camtime).x - map(pos-eps.yyx,camtime).x;
  return normalize(nor);
}

// Function 2200
vec3 safe_normalize(vec3 v)		{ return all(equal(v, vec3(0))) ? vec3(0) : normalize(v); }

// Function 2201
vec3 getNormal(vec3 p) {
	vec2 t = vec2(0.0001,0.);    
    return normalize(vec3(
    	map(p + t.xyy).d - map(p - t.xyy).d,
    	map(p + t.yxy).d - map(p - t.yxy).d,
    	map(p + t.yyx).d - map(p - t.yyx).d
    ));
}

// Function 2202
v4 fRay(DAVec3 p){p.x.w=mix(0.,p.x.w,step(p.x.w,0.));
 v4 q=lengthd(p.x,p.y,p.z);return subd(q,1.);}

// Function 2203
vec3 detailsNormalTrees(vec3 n, vec3 p)
{
    return normalize(n+hash33(p));
}

// Function 2204
vec3 normal(vec3 rp)
{
    vec3 eps = vec3( 0.002 ,0.0,0.0);
	return normalize( vec3(
           map(rp+eps.xyy).a - map(rp-eps.xyy).a,
           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   //shamelessly stolen from iq :(
           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );

}

// Function 2205
vec3 calcNormal(in vec3 pos)
{
	vec2 eps = vec2( 0.001, 0.0);
	vec3 nor = vec3(
	    scene(pos+eps.xyy) - scene(pos-eps.xyy),
	    scene(pos+eps.yxy) - scene(pos-eps.yxy),
	    scene(pos+eps.yyx) - scene(pos-eps.yyx) );
	return normalize(nor);
}

// Function 2206
vec3 normal(vec2 p, float td) {
	vec2 eps=vec2(0.,.001);
    return normalize(vec3(map(p+eps.yx)-map(p-eps.yx),2.*eps.y,map(p+eps.xy)-map(p-eps.xy)));
}

// Function 2207
vec2 raySphere (vec3 sphereCenter, float sphereRadius, vec3 origin, vec3 ray) {
    vec3 offset = origin - sphereCenter;
    float a = 1.0;
    float b = 2.0 * dot(offset, ray);
    float c = dot(offset, offset) - sphereRadius * sphereRadius;
    float d = b * b - 4.0 * a * c;

    if (d > 0.0) {
        float s = sqrt(d);
        float dstToSphereNear = max(0.0, (-b - s) / (2.0 * a));
        float dstToSphereFar = (-b + s) / (2.0 * a);
        if (dstToSphereFar >= 0.0) {
            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);
        }

    }
    return vec2(100.00, -1.0);
}

// Function 2208
Ray createRay(vec3 o, vec3 d, float t)
{
    Ray r;
    r.o = o;
    r.d = d;
    r.t = t;
    return r;
}

// Function 2209
vec3 normal(vec3 p) {
	vec2 e = vec2(1,0)/1e3;
    p += 0.01 * vec3(
        map(p - e.xyy) - map(p + e.xyy),
        map(p - e.yxy) - map(p + e.yxy),
        map(p - e.yyx) - map(p + e.yyx))/ (2. * length(e));
	return normalize(p);
}

// Function 2210
arr setArray(){ //this could be read from a vertex buffer.
 ;arr a=newA()
 ;setN(a,1,1)
 ;setN(a,2,3)
 ;setN(a,3,4)
 ;setN(a,4,2)
 ;setN(a,5,5)
//If (you want to see a yellow border)
//The commonTab lists a few symmetric costasArrays
//But so far, larger arrays crashed opengl of quite a fre environments.
//It is silly/naive to do this in 1 fragment shader

/*
//order 27 crashed my opengl once, that is exactly once too often
;setN(a, 1,1)
;setN(a, 2,25)
;setN(a, 3,19)
;setN(a, 4,5)
;setN(a, 5,4)
;setN(a, 6,12)
;setN(a, 7,10)
;setN(a, 8,16)
;setN(a, 9,26)
;setN(a,10,7)
;setN(a,11,18)
;setN(a,12,6)
;setN(a,13,23)
;setN(a,14,27)
;setN(a,15,24)
;setN(a,16,8)
;setN(a,17,21)
;setN(a,18,11)
;setN(a,19,3)
;setN(a,20,22)
;setN(a,21,17)
;setN(a,22,20)
;setN(a,23,13)
;setN(a,24,15)
;setN(a,25,2)
;setN(a,26,9)
;setN(a,27,14)
*/     

 ;return a;}

// Function 2211
vec3 debugNormals(Ray r)
{
    HitRecord rec;
    vec3 col = vec3(1.0);
    for(int i = 0; i < 1; ++i)
    {
        if(hit_world(r, 0.001, 10000.0, rec))
        {
			col = (rec.normal + 1.0) / 2.0;
        }
        else
        {
            float t = 0.5 * (r.d.y + 1.0);
            col *= mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
            return col;
        }
    }
    return col;
}

// Function 2212
void minRay4Result ( inout Ray4Result _rayResultMin, in float _min, in float _max, in Ray4Result _curr )
{
    if ( _curr.m_d < _min )
        return;
    
    if ( _curr.m_d > _max )
        return;
    
    if ( _curr.m_d > _rayResultMin.m_d )
        return;
    
	_rayResultMin = _curr;
}

// Function 2213
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, h, s, sLo, sHi, eps;
  eps = 0.0005;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 220; j ++) {
    h = ObjDf (ro + s * rd);
    if (h < eps || s > dstFar) {
      sHi = s;
      break;
    }
    sLo = s;
    s += h;
  }
  if (h < eps) {
    for (int j = 0; j < 6; j ++) {
      s = 0.5 * (sLo + sHi);
      if (ObjDf (ro + s * rd) > eps) sLo = s;
      else sHi = s;
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 2214
SRayHit 	rayMarchBlobs(SBlob blob1, SBlob blob2, vec3 rayOrigin, vec3 rayDirection, float farDist)
{
    SRayHit	hit;
    vec3 	currentPos = rayOrigin;
    float 	currentDist = 3.0f;

    while (currentDist < farDist)
    {
        currentPos += rayDirection * rayMarchDist;
        currentDist += rayMarchDist;
        
        float 	sumInfluence = 0.0f;
        
        vec3 	curToBlob1 = blob1.m_Position - currentPos;
        float 	blobInfluence1 = blob1.m_Intensity / dot(curToBlob1, curToBlob1);

		sumInfluence += blobInfluence1;
        
    	vec3 	curToBlob2 = blob2.m_Position - currentPos;
        float 	blobInfluence2 = blob2.m_Intensity / dot(curToBlob2, curToBlob2);

		sumInfluence += blobInfluence2;

        if (sumInfluence > solidSurfThreshold)
        {
            hit.m_Distance = currentDist;
            hit.m_Position = currentPos;
            return hit;
        }
	}
    hit.m_Distance = infinity;
	hit.m_Position = vec3(infinity);
    return hit;
}

// Function 2215
vec3 getNormal( in vec3 p ){

    // Note the slightly increased sampling distance, to alleviate
    // artifacts due to hit point inaccuracies.
    vec2 e = vec2(.0015, -.0015); 
    return normalize(
        e.xyy * map(p + e.xyy) + 
        e.yyx * map(p + e.yyx) + 
        e.yxy * map(p + e.yxy) + 
        e.xxx * map(p + e.xxx));
}

// Function 2216
vec3 RayMarch(in vec3 position, in vec3 direction, out int mtl){
  vec3 hitColor;
  vec3 r;
  float sg=1.;
  float nextDistance= 1.;
  float shadowReflections=MAX_SHADOW_REFLECTIONS;
  float maxDist =MAX_DIST;
  float maxSteps=MAX_STEPS;
  int hardLimit =MAX_HARD;
  float eps     =.01;
  for(int ever=3;ever!=0;++ever){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlimit in the loop-
    nextDistance=df(position,mtl);
	position+=direction*nextDistance;
    if(nextDistance<eps){//if we hit a surface.
      vec3 n=ComputeNormal(position,mtl,eps);n=normalize(n);
      vec3 col=MaterialColor(mtl);
	  position+=n;
      if(shadowReflections>0.0){//if we stil calculate shadows (for this reflection)
		vec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));
        lightpos=lightpos-position;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);
		float shadow = SoftShadow(position, lightVector, 0.3, lightdist,shadowHardness);
        if(mtl==BUILDINGS_MTL){col=mix(shadowColor,col,clamp(position.y/7.0,0.0,1.0));}
		float attenuation=clamp(dot(n,lightVector),0.0,1.0);
		shadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);
        float AO=AmbientOcclusion(position,n, 1.0, 7.0);col=mix(shadowColor,col,AO);shadowReflections-=1.0;}
      float refl=.45;//surface reflectiveness
      if (mtl==GROUND_MTL)refl=.3;//ground has other reflectiveness
      r=mix(col,r,1.-sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.
      sg=sg*refl;if(sg<.01)return r;
      direction=direction-(n*1.5*(dot(direction,n)));//direction gets reflected at surface normal. 
        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.
        //this is a reasonable fps booster for less quality in reflections.
    }hardLimit--;
    epsmod1 
    epsmod2 
    epsmod3 	
    if(maxSteps<0.||maxDist<0.||hardLimit<0){
	  if (direction.y<0.)return mix(groundColor,r,1.-sg);
                         return mix(skyColor   ,r,1.-sg);}}return vec3(3,3,3);}

// Function 2217
vec2 texNormalMap(in vec2 uv)
{
    vec2 s = 1.0/heightMapResolution.xy;
    
    float p = texture(heightMap, uv).x;
    float h1 = texture(heightMap, uv + s * vec2(textureOffset,0)).x;
    float v1 = texture(heightMap, uv + s * vec2(0,textureOffset)).x;
       
   	return (p - vec2(h1, v1));
}

// Function 2218
bool rayTrace( vec3 vo, vec3 vd, out vec3 color )
{
	bool bResult = false;
	color = vec3( 0.0 );
	
	float dglass = 1e6;
	vec3 normGlass;
	vec3 clBG = texture( iChannel1, vd ).rgb;
	color = clBG;
	vec3 clGlassRefl;

	vec3 clGlass;
	for( int cy = -1; cy < c_iGlassHeight; cy++ )
		for( int cx = -1; cx < c_iGlassWidth; cx++ )
		{
			float d;
			if ( rayHitPiece( vo, vd, ivec2( cx, cy ), d, normGlass ) )
			{
				if ( d < dglass )
				{
					dglass = d;
					bResult = true;
					clGlassRefl = texture( iChannel1, reflect( vd, normGlass ) ).xyz;
					clGlass = mix( clBG, clGlassRefl, 0.4 );
				}
			}
		}

	const float fBulletSpeed = 100.0;
	vec3 vBulletPos = vec3( c_fGlassWidth * 0.5, c_fGlassHeight * 0.5, -g_fSceneTime * fBulletSpeed );
	const float fBulletRadius = 0.2;
	vec3 norm;
	float d;
	if ( rayHitSphere( vo, vd, vBulletPos, fBulletRadius, d, norm ) )
	{
		bResult = true;
		vec3 crefl = texture( iChannel1, reflect( vd, norm ) ).xyz;
		color = mix( vec3( 0.8, 0.8, 0.4 ), crefl, 0.7 );
		if ( d > dglass )
		{
			color = mix( color, clGlass, 0.4 );
		}
	}
	else if ( bResult )
		color = clGlass;
	
	return bResult;
}

// Function 2219
float calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {
  float latest = precis * 2.0;
  float dist   = +0.0;
  float type   = -1.0;
  float res    = -1.0;

  for (int i = 0; i < 30; i++) {
    if (latest < precis || dist > maxd) break;

    float result = map(rayOrigin + rayDir * dist);

    latest = result;
    dist  += latest;
  }

  if (dist < maxd) {
    res = dist;
  }

  return res;
}

// Function 2220
void sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, out float sd){
	sd = sdSphere(pos, center, radius);
    vec2 e = vec2(0.01, 0.);
    normal = normalize(sd - vec3(
    	sdSphere(pos - e.xyy, center, radius),
    	sdSphere(pos - e.yxy, center, radius),
    	sdSphere(pos - e.yyx, center, radius)
    ));
}

// Function 2221
vec3 noiseNormal( vec3 pos ){
 return normalize( vec3(hash(pos.x) , hash( pos.y ), hash( pos.z) ) );  
}

// Function 2222
vec4 rayMarch1d(inout vec4 p, in vec4 rd, in vec4 rd2, out vec4 dists) {
  vec4 dists2, p2;
  float dS = 99., dSx = 99., dSy, dSz, dSw, d = 0., minDS = dS, steps = 0.;
  for (int i = 0; i < MAX_STEPS; i++) {
    steps++;
    dS = mapWDists(p, dists);
    if (dS > SURF_DIST) {  // we are receeding,
      p2 = p - rd2 * 1.41;
      vec4 innerRmd = rayMarch(p2, rd2 * vec4(1,1,1,1), dists2);
      steps += innerRmd.w;
      if (innerRmd.y < SURF_DIST) { p = p2; }
      /* minWith 4d */
      // float ddS = dS - innerRmd.y;
      // dists = (max(0., ddS) * dists + max(0., -ddS) * dists2) * -1. / abs(ddS);
      /* -- end minWith */
      dists = minWith14(dS, dists, innerRmd.y, dists2);
      dS = min(dS, innerRmd.y);
      minDS = min(minDS, innerRmd.z);
    }
    minDS = min(minDS, (dS));
    mat4 chBasis = mat4(0, 0, 0, 0, 0, 0, 0, 0, rd.x, rd.y, rd.z, rd.w, rd2.x, rd2.y, rd2.z, rd2.w);
    vec4 components = normalize(dists * chBasis);
    d += dS;
    /* first, take the largest of the components we got back from the change
    of basis (it breaks for some angles with less than this - I'm not really
    sure why) */
    float dsFactor = maxOf(vec4(components.zw, -components.zw));
    #ifdef SLOW_THRU
    // then, slow down the ray whenever it has a coordinate near 0 for some axis.
    dsFactor *= min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01));
    #endif
    p = p + rd * dS * dsFactor;
    // * sin(atan(dSw, dSz)) * (min(1., max(minOf(abs(p)) + SPOOK_BE_GONE, .01))); // move slower inside;
    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;
  }
  return vec4(d, dS, minDS, steps);
}

// Function 2223
float RayMarch(vec3 ro, vec3 rd)
{
    float dO = 0.;
    
    for(int i = 0 ; i < MAX_STEPS; i++){
        vec3 p = ro + rd * dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO > MAX_DIST || dS < SURF_DIST) break;
    }
    return dO;
}

// Function 2224
rtIntersection rayTraceScene(vec3 ro,vec3 rd)
{
    float maxt=10000.0;
    rtIntersection noResult=rtIntersection(-1.0,vec3(0.0),vec3(0.0),0);

    rtIntersection resultSphere;
    if (intersectSphere(.3,vec3(0.0,.3,4.5+5.0*sin(iTime/2.0)),ro,rd,resultSphere))
    {
        maxt=resultSphere.dist;
        resultSphere.material=0;
    }

    rtIntersection resultSphere2;
    if (intersectSphere(0.23,vec3(.8*sin(iTime),.2,-1.*cos(iTime)),ro,rd,resultSphere2))
    {
        maxt=min(maxt,resultSphere2.dist);
        resultSphere2.material=3;
    }

    rtIntersection resultSphere3;
    if (intersectSphere(.2,vec3(cos(iTime),.2,-0.25),ro,rd,resultSphere3))
    {
       	maxt=min(maxt,resultSphere3.dist);
        resultSphere3.material=1;
    }
    
    rtIntersection resultPlane;
    if (intersectPlane(vec3(0.0,1.0,0.0),ro,rd,resultPlane))
    {
        maxt=min(maxt,resultPlane.dist);
        resultPlane.material=2;
    }

    rtIntersection resultPlane2; // Up
    if (intersectPlane(vec3(0.0,-1.0,0.0),ro-vec3(0.0,2.0,0.0),rd,resultPlane2))
    {
        maxt=min(maxt,resultPlane2.dist);
        resultPlane2.material=2;
    }

    rtIntersection resultPlane3;
    if (intersectPlane(vec3(1.0,0.0,0.0),ro-vec3(-1.2,0.0,0.0),rd,resultPlane3))
    {
        maxt=min(maxt,resultPlane3.dist);
        resultPlane3.material=2;
    }

    rtIntersection resultPlane4;
    if (intersectPlane(vec3(-1.0,0.0,0.0),ro-vec3(1.2,0.0,0.0),rd,resultPlane4))
    {
        maxt=min(maxt,resultPlane4.dist);
        resultPlane4.material=2;
    }

    const int numBoxes=4;
    rtIntersection resultBoxes[numBoxes];
    float boxDist[numBoxes];
    if (iTime>=(60.0/globalTempo)*32.)
    {
        for (int b=0;b<numBoxes;b++)
        {
            float x=0.2;//float(b)*0.1;
            float y=1.9;//mod(float(b)*234.0,4.0);
            vec3 dimensions=vec3(1.5,.1,2.2);

            if (b==2)
            {
                x=.5;
                dimensions=vec3(0.2,2.1,2.2);
            }

            if (b==0)
            {
                x=-0.1;
                dimensions=vec3(0.2,2.1,2.2);
            }

            vec3 resNormal;
            boxDist[b]=intersect_box(ro-vec3(-.7+x*4.0,y,-64.0+mod(32.0*iTime+float(b)*32.0,128.0)),rd,resNormal,
                                     dimensions);
            if (boxDist[b]!=INFINITY)
            {
                maxt=min(maxt,boxDist[b]);
                resultBoxes[b].material=b+4;
                resultBoxes[b].dist=boxDist[b];
                resultBoxes[b].normal=resNormal;
            }
        }
    }
    
    if (maxt==resultSphere.dist) return resultSphere;
    if (maxt==resultSphere2.dist) return resultSphere2;
    if (maxt==resultSphere3.dist) return resultSphere3;
    if (maxt==resultPlane.dist) return resultPlane;
    if (maxt==resultPlane2.dist) return resultPlane2;
    if (maxt==resultPlane3.dist) return resultPlane3;
    if (maxt==resultPlane4.dist) return resultPlane4;
    
    if (iTime>=(60.0/globalTempo)*32.)
    {
        for (int b=0;b<numBoxes;b++)
        {
            if (maxt==boxDist[b]) return resultBoxes[b];
        }
    }
        
    return noResult;
}

// Function 2225
vec3 Normal(vec3 p)
{
    vec3 off = vec3(NORMAL_OFFS, 0, 0);
    return normalize
    ( 
        vec3
        (
            Scene(p + off.xyz).x - Scene(p - off.xyz).x,
            Scene(p + off.zxy).x - Scene(p - off.zxy).x,
            Scene(p + off.yzx).x - Scene(p - off.yzx).x
        )
    );
}

// Function 2226
ray_t camera_getRay( camera_t c, vec2 uv )
{
    ray_t ray;
    ray.o = c.pos;
    
    // Rotate camera according to mouse position
    float ca = cos(mouse.x), sa = sin(mouse.x);
    mat3 rotX = mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);
    ca = cos(mouse.y), sa = sin(mouse.y);
    mat3 rotY = mat3(1.0, 0.0, 0.0, 0.0, ca, -sa, 0.0, sa, ca);
    mat3 rotM = rotX * rotY;
    
	ray.o = rotM*c.pos;
    ray.d = rotM*normalize( vec3( uv, -1.0 ) ); // should be -1! facing into scene
    
	return ray;
}

// Function 2227
float RayMarch(vec3 rayOrigin, vec3 rayDirection, out Hit result)
{
    const int MAX_STEPS = 200;
    float totalDistance = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        vec3 rayPoint = rayOrigin + rayDirection * totalDistance;
        vec2 mapResult = MapScene(rayPoint);
        if (mapResult.x < MIN_DIST) 
        {
            result.point = rayPoint;
            result.normal = GetNormal(rayPoint);
            result.type = mapResult.y;
            return totalDistance;
        }
        totalDistance += mapResult.x;
        if (totalDistance > MAX_DIST) break;
    }
    result.type = TYPE_NONE;
    return MAX_DIST;
}

// Function 2228
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.05, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 2229
vec3 normal(vec3 p){
    const float eps = 0.005;
    return normalize(vec3(dist(p+vec3(eps,0,0))-dist(p-vec3(eps,0,0)),
                          dist(p+vec3(0,eps,0))-dist(p-vec3(0,eps,0)),
                          dist(p+vec3(0,0,eps))-dist(p-vec3(0,0,eps))));
}

// Function 2230
vec2 ct_vfield_normal(
    in vec2 p,
    float npow
){
    vec2 g = vec2(0.0, 0.0);
    
    const int imax = CT_N * CT_N + 1;
    
    for (int i = 0; i < imax; ++i)
    {
        vec2 dif = g_vfp[i].p - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1];
        float mass = pow(sum, npow);
        
      	g[0] = g[0] + g_vfp[i].m * dif[0] / mass;
      	g[1] = g[1] + g_vfp[i].m * dif[1] / mass;
    }
    
    return normalize(g);
}

// Function 2231
define ARRAY_PRINT(STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i<CHAR_ARRAY.length(); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }

// Function 2232
vec3 calcNormal(vec3 pos)
{
    float eps=0.04; pos-=0.01;
	float d=map(pos);
	return normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));
}

// Function 2233
vec3 calcNormal( in vec3 pos )
  {
	vec2 eps = vec2( 0.0001, 0.0 );
	vec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
  }

// Function 2234
Hit raymarch(Ray ray) {
 
    float d  = 0.;
    int iter = 0;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        d += dstScene(ray.ori + ray.dir * d) * .75;
        
        if(d <= MIN_DISTANCE || d > FAR_PLANE) {
         
            iter = i;
            break;
            
        }
        
    }
    
    return Hit(d,iter);
    
}

// Function 2235
float getRayleighPhase( float fCos2 ) {
    return 0.75 * ( 2.0 + 0.5 * fCos2 );
}

// Function 2236
vec3 normal (vec3 o) {
    vec3 normal = vec3(0,1,0);
    if (o.y > -RADIUS+0.0001) {
    	/* get the sphere normal */
    	normal = normalize(o);
    }
    return normal;
}

// Function 2237
vec3 calcNormal(in vec3 p) {
  vec2 e = vec2(1., -1.) * 1e-3;
  return normalize(
      e.xyy * map(e.xyy+p) +
      e.yxy * map(e.yxy+p) +
      e.yyx * map(e.yyx+p) +
      e.xxx * map(e.xxx+p)
    );
}

// Function 2238
vec3 estimateNormal( const int scene, const float epsilon, in vec3 p )
{
    int m;
    vec2 h = vec2(epsilon, 0);
    return normalize( vec3(sceneSDF(scene, p+h.xyy, m) - sceneSDF(scene, p-h.xyy, m),
                           sceneSDF(scene, p+h.yxy, m) - sceneSDF(scene, p-h.yxy, m),
                           sceneSDF(scene, p+h.yyx, m) - sceneSDF(scene, p-h.yyx, m) ) );
}

// Function 2239
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.001;
    return normalize( e.xyy*map( pos + e.xyy*eps ) + 
					  e.yyx*map( pos + e.yyx*eps ) + 
					  e.yxy*map( pos + e.yxy*eps ) + 
					  e.xxx*map( pos + e.xxx*eps ) );
}

// Function 2240
Ray createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)
{
	Ray ray;
	ray.org = center;
	vec3 dir = normalize(lookAt - center);
	up = normalize(up - dir*dot(dir,up));
	vec3 right = cross(dir, up);
	uv = 2.*uv - vec2(1.);
	fov = fov * 3.1415/180.;
	ray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;
	ray.dir = normalize(ray.dir);	
	return ray;
}

// Function 2241
vec3 smoothReflect(in vec3 pos, in vec3 ray, in vec3 light, in Type_Param PARAM, in bool Noticeable, in vec3 stepOut){
    vec3 col = vec3(0.);
    vec3 p = pos + PARAM.t * ray + stepOut;	// a little step back to avoid black dithering
    vec3 refl = reflect(ray,PARAM.n);
    float bkg = backGround(light,refl);
    vec3 reflCol = vec3(bkg);
    vec3 reflColAA = vec3(bkg);

    Type_Param RFL = Type_Param(INFINI, SKY, vec3(0.), 1.);
    Type_Param RFLAA = Type_Param(INFINI, SKY, vec3(0.), 1.);

    trace(p, refl, RFL, RFLAA);
    setColor(reflCol, p, refl, light, RFL);
    setColor(reflColAA, p, refl, light, RFLAA);

    
    /*** shadow of reflection ***/
    
    // the reflection can be under shadow
    // so we have to extend the ray... only if noticeable!
    if(Noticeable){
        if(RFL.t<INFINI){
            vec3 p2 = p + RFL.t * refl + .001*(RFL.n+RFLAA.n);
            float shad = shadowTrace(p2, light);
            reflCol *= 1.-SC*shad;
        }
        if(RFLAA.t<INFINI){
            vec3 p2 = p + RFLAA.t * refl + .01*(RFL.n+RFLAA.n);
            float shad = shadowTrace(p2, light);
            reflColAA *= 1.-SC*shad;
        }
    }
    
    /****************************  demo option  ******************************/
    /**/ #ifdef SPLIT
    /**/ if(gl_FragCoord.x > iResolution.x/2.) col = RC*reflCol;
    /**/ else 
    /**/ #endif    
    /*************************************************************************/
    
    col = RC*(reflCol*min(1.,RFL.d/(RFL.t+PARAM.t)/RF) + reflColAA*max(0.,(1.-RFL.d/(RFL.t+PARAM.t)/RF)));

	return col;
}

// Function 2242
float getNormalZ(vec3 p)
{
    const float eps = .0001;
    float d0z = scene(vec3(p.xy,p.z + eps));
    float d1z = scene(vec3(p.xy,p.z - eps));
    //return (d1 - d0)/eps;
    return (d1z-d0z)/eps;
}

// Function 2243
float rayMarch(vec3 eye, vec3 marchingDirection, 
               float start, float end) {
	// Define starting depth 
    float depth = start;
    // March until maxMarchSteps is reached
    for (int i = 0; i < maxMarchSteps; i++) {
        // Obtain distance from closest surface 
        float dist = sceneSDF(eye + depth *
                              marchingDirection);
        // Determine if marched inside surface
        if (dist < epsilon) {
            // Inside scene surface
            return depth; 
        }
        // Update depth 
        depth += dist;
        // Determine if marched too far 
        if (depth >= end) {
            // Return farthest allowable
            return end;
        }
    }
    // Return distance if marched more than max steps
    return end;
}

// Function 2244
vec3 normal(in vec3 p){

    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.
    vec2 e = vec2(0.005, -0.005); 
    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));
}

// Function 2245
Hit raymarch(Ray ray) {
 
    vec3 p = ray.ori;
    float t = 0.;
    int id = -1;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        Dist d = distToScene(p);
        p += ray.ori + (ray.dir * d.dist);
        
        if(d.dist <= MIN_DISTANCE) {
         
            t = d.dist;
            id = d.id;
            
            break;
            
        }
        
    }
    
    return Hit(p,Dist(t,id));
    
}

// Function 2246
vec3 getNormal(vec3 p) {
	vec2 q = vec2(0.0, 0.002);

	float x = map(p + q.yxx).x - map(p - q.yxx).x;
	float y = map(p + q.xyx).x - map(p - q.xyx).x;
	float z = map(p + q.xxy).x - map(p - q.xxy).x;

	return normalize(vec3(x, y, z));
}

// Function 2247
vec3 rayMarch(vec3 origin, vec3 dir) {
    vec3 p = origin;
    while(true) {
        float d = sceneSDE(p);
        if (d < 0.01) { return p; }
        if (length(p - origin) > 100.) { return p; }
        p += dir * d;
    }
}

// Function 2248
vec2 calcRayIntersection_3557608877(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {
  float latest = precis * 2.0;
  float dist   = +0.0;
  float type   = -1.0;
  vec2  res    = vec2(-1.0, -1.0);

  for (int i = 0; i < 90; i++) {
    if (latest < precis || dist > maxd) break;

    vec2 result = doModel(rayOrigin + rayDir * dist);

    latest = result.x;
    type   = result.y;
    dist  += latest;
  }

  if (dist < maxd) {
    res = vec2(dist, type);
  }

  return res;
}

// Function 2249
vec3 getVolumetricRaymarcher(vec3 p, vec3 o, float dither, vec3 background)
{
	const float isteps = 1.0 / float(steps);
	
	vec3 increment = -p * isteps;
	vec3 marchedPosition = increment * dither + p;
	
	float stepLength = length(increment);
	
	vec3 scatter = vec3(0.0);
	vec3 transMittance = vec3(1.0);
	vec3 currentTransmittence = vec3(1.0);
	
	for (int i = 0; i < steps; i++){
		vec3 od = calculateOD(marchedPosition) * scatterCoeff * stepLength;
		
		marchedPosition += increment;
		
		scatter += calculateVolumetricLight(marchedPosition, o, od) * currentTransmittence;
		
		currentTransmittence *= exp2(od);
		transMittance *= exp2(-od);
	}
	
	return background * transMittance + scatter * transMittance;
}

// Function 2250
void Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )
{
    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );
    vRayOrigin = cam.vPos;
    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );
    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );
}

// Function 2251
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.008;	//0.0005
    return normalize( e.xyy*map( pos + e.xyy*eps ) + 
					  e.yyx*map( pos + e.yyx*eps ) + 
					  e.yxy*map( pos + e.yxy*eps ) + 
					  e.xxx*map( pos + e.xxx*eps ) );
}

// Function 2252
vec3 calcNormal(vec3 p) {
  vec3 eps = vec3(.0001,0,0);
  vec3 n = vec3(
    map(p + eps.xyy) - map(p - eps.xyy),
    map(p + eps.yxy) - map(p - eps.yxy),
    map(p + eps.yyx) - map(p - eps.yyx)
  );
  return normalize(n);
}

// Function 2253
Hit raymarch(vec3 rayOrigin, vec3 rayDirection){

    float currentDist = INTERSECTION_PRECISION * 2.0;
    float rayLength = 0.;
    Model model;

    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++){
        if (currentDist < INTERSECTION_PRECISION || rayLength > MAX_TRACE_DISTANCE) {
            break;
        }
        model = map(rayOrigin + rayDirection * rayLength);
        currentDist = model.dist;
        rayLength += currentDist * (1. - FUDGE_FACTOR);
    }

    bool isBackground = false;
    vec3 pos = vec3(0);
    vec3 normal = vec3(0);

    if (rayLength > MAX_TRACE_DISTANCE) {
        isBackground = true;
    } else {
        pos = rayOrigin + rayDirection * rayLength;
        normal = calcNormal(pos);
    }

    return Hit(model, pos, isBackground, normal, rayOrigin, rayDirection);
}

// Function 2254
Hit castRay(vec3 ro, vec3 rd, float maxt)
{
    Hit hit; 
    
    float dt = 0.01;;
    float mint = 0.01;
    float resT = 0.0;
    float d = 1.0;
    for( float t = mint; t < maxt; t += dt )
    {	
        vec3 p = ro + rd*t;
        vec4 tx = getHeightMap(p.xz);
        hit.textureMap = tx;
        hit.h = tx.w;
        if( p.y < hit.h)
        {
            resT = t - 0.8f*dt;
            hit.t = resT; 
            return hit;
        }
        dt = 0.01f*t;
    }
    hit.t = MAX_VIEW_DISTANCE; 
    return hit;
}

// Function 2255
void MakeViewRay(out vec3 eye, out vec3 ray, in vec2 fragCoord)
{
	vec2 ooR = 1./iResolution.xy;
    vec2 q = fragCoord.xy * ooR;
    vec2 p =  2.*q -1.;
    p.x *= iResolution.x * ooR.y;
	
    vec3 lookAt = vec3(0.,0.,0.);
	float t = iTime*0.1;
//	t=0.;
	t = mod(t,3.);
	if (t < 1.)
	{
		eye = vec3(10.,10.,10)*4.;
		eye = RotY(eye,smoothstep(0.,1.,t)*-0.5*pi);
	
	}
	else if (t < 2.)
	{
		t -= 1.;
		float s = smoothstep(0.,1.,t);
		eye = vec3(50.+s*10.,90.*(1.-s*0.5),50.);
		lookAt = vec3(5.,0.,-10.);		
	}
	else
	{
		t -= 2.;
		float s = smoothstep(0.,1.,t);
		eye = vec3(-10.*(s*2.-1.),60. - s*30. ,-25.);
		lookAt = vec3(-20.*s,s,s*10.);
	}
	
    // camera frame
    vec3 fo = normalize(lookAt-eye);
    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));
    vec3 up = normalize(cross(fo,ri));
     
    float fov = .25;
	
    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);
}

// Function 2256
vec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )
{
    RaymarchScene( vRayOrigin, vRayDir, intersection );        

    if ( intersection.m_objId == OBJ_ID_SKY )
    {
        return GetSkyColour( vRayDir );
    }
    
    Surface surface;
    GetSurfaceInfo( intersection, surface );

    vec3 vIgnore = vec3(0.0);
    vec3 vResult = vec3(0.0);
    float fSunShadow = 1.0;
    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );
    AddSkyLight( surface, vResult, vIgnore);
    return vResult * surface.m_albedo;
}

// Function 2257
vec3 calcNormal(vec3 pos)
{
    float eps = 0.002, d = map(pos,0);
    if (scene==4) eps = 0.2;
    if (scene==5) eps = 0.02;
	return normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));
}

// Function 2258
vec3 getGateNormal(in vec3 p, float e) {
    vec2 eps = vec2(e, 0.0);
    return normalize(vec3(map(p + eps.xyy).y - map(p - eps.xyy).y,
                          2.0 * eps.x,
                          map(p + eps.yyx).y - map(p - eps.yyx).y));
}

// Function 2259
Ray genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {
    Ray ray;
	vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    ray.origin = camera.pos;
    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));
	return ray;
}

// Function 2260
vec3 calcNormal( in vec3 pos )
{
    // epsilon = a small number
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
    /*
	vec3 eps = vec3( 0.0005, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
	*/
}

// Function 2261
vec4 raycast(in vec3 pos, in vec3 ray) {
    
    int i;
    float currdepth = 0.;
    for (i=0; i<13;i++) {
        currdepth += floorsdf(pos + currdepth * ray)/1.5;
    }
    vec3 finalPos = pos + currdepth * ray;
    float col = (mod(finalPos.x * finalPos.y, 5.)-2.5) * mod(finalPos.y, 5.) / 2. + 0.5;
    float col2 = exp(pow(finalPos.z, 2.) * 20. - 3.);
    return vec4((vec3(col * 0.5, 0.85-col*2.,0.5-col) + col2 * vec3(1., 1., 1.)) * exp(-length(finalPos.xy)/10.), 1.);
}

// Function 2262
float raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {
    vec3 ce = ro - spherePos;
    float b = dot(rd, ce);
    float c = dot(ce, ce) - r * r;
    float t = b * b - c;
    if (t > tmin) {
        t = -b - sqrt(t);
        if (t < tmax)
            return t;
        }
    return -1.0;
}

// Function 2263
vec3 mapNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = map(pt).x;    
    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 2264
vec3 ray_trace(vec2 uv, vec2 ro, vec3 col){
    
    vec2 t_and_a = time_and_animation();
    //rays
    for(float i = 0.; i<fov; i += fov/float(RAY_N)){
    
        vec2 rd = vec2(1.,0.)*rot(i-pi*sin(iTime/6.));
        vec2 bounce_ro = ro;
        //bounces
        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);
        }
        
    
    
    return col;
}

// Function 2265
vec3 normal(vec3 p) {
    vec3 d=vec3(0.,det*2.,0.);
	return normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));
}

// Function 2266
vec4 rayMarch1d(inout vec3 p, in vec3 rd, in vec3 rd2, out vec3 dists) {
  float dS = 99., dSx = 99., dSy, dSz, d = 0., minDS = dS, steps = 0.;
  vec3 dists2;
  for (int i = 0; i < MAX_STEPS; i++) {
    steps += 1.;
    dS = 99.;
    dS = mapWDists(p, dists);
    minDS = min(minDS, abs(dS));
    if (dS > SURF_DIST) {
      vec3 p2 = p - rd2 * 2.;
      vec4 innerRmd = rayMarch(p2, rd2, dists2);
      // steps += innerRmd.w;
      if (innerRmd.x < MAX_DIST && innerRmd.y < SURF_DIST) {
        p = p2;
        return vec4(length(vec2(innerRmd.x, d)), innerRmd.yz, steps);
      } else {
        dS = min(dS, min(innerRmd.y, 99.));
        minDS = min(minDS, abs(innerRmd.z));
      }
    }
    // backported chBasis + slow_thru from 4d version
    mat3 chBasis = mat3(rd.x, rd.y, rd.z, 0, 0, 0, rd2.x, rd2.y, rd2.z);
    vec3 components = normalize(dists * chBasis);
    d += dS;
    float dsFactor = maxOf(vec4(components.xz, -components.xz));
    dsFactor *= min(1., max(minOf(abs(p)) + .08, .01));
    p = p + rd * dS * dsFactor;
    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;
  }
  return vec4(d, dS, minDS, steps);
}

// Function 2267
vec3 getNormal(vec3 p, vec3 rd) {
	vec3 ep = vec3(0.01, 0, 0);
    vec3 normal;
    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;
    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;
    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;
    return normalize(normal);
}

// Function 2268
vec3 normal_o354278(vec3 p) {
	float d = input_o354278(p).x;
    vec2 e = vec2(.001,0);
    vec3 n = d - vec3(
        input_o354278(p-vec3(e.xyy)).x,
        input_o354278(p-vec3(e.yxy)).x,
        input_o354278(p-vec3(e.yyx)).x);
    return normalize(n);
}

// Function 2269
vec3 GetNormal(vec3 pos){
 	vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*GetDist( pos + e.xyy ).d + 
					  e.yyx*GetDist( pos + e.yyx ).d + 
					  e.yxy*GetDist( pos + e.yxy ).d + 
					  e.xxx*GetDist( pos + e.xxx ).d );
}

// Function 2270
vec4 raymarch(vec3 org, vec3 dir)
{
        float d = 0.0, glow = 0.0, eps = 0.02;
        vec3  p = org;
        bool glowed = false;

        for(int i=0; i<64; i++)
        {
                d = scene(p) + eps;
                p += d * dir;
                if( d>eps )
                {
                        if(flame(p) < .0)
                                glowed=true;
                        if(glowed)
                        glow = float(i)/64.;
                }
        }
        return vec4(p,glow);
}

// Function 2271
Ray cameraRay (in vec2 uv, in vec3 ro, in vec3 lookAt, in float zoom) {
	Ray ray = Ray (vec3 (.0), vec3 (.0));

    vec3 worldUp = vec3 (.0, 1., .0);
    vec3 forward = normalize (lookAt - ro);
    vec3 right = normalize (cross (worldUp, forward));
    vec3 up = normalize (cross (forward, right));
    vec3 camCenter = ro + zoom * forward;
    vec3 i = camCenter + uv.x * right + uv.y * up;
    vec3 rd = normalize (i - ro);

    ray.ro = ro;
    ray.rd = rd;

	return ray;
}

// Function 2272
vec3 eye_ray(vec3 eye, vec3 look_at, vec3 eye_up, float fov){
	// Do as a matrix?
	vec3 forward = normalize(look_at - eye);
	vec3 right = cross(forward, normalize(eye_up));
	vec3 up = cross(right, forward);
	
	vec2 clip = clip_coord();
	return normalize(forward + (clip.x*fov)*right + clip.y*up);
}

// Function 2273
vec3 calcNormal(vec3 p) 
{
    vec3 e = vec3(0.0001,0.,0.);
	if (ef==1) e = vec3(0.01,0.,0.);
	return normalize (vec3(map(p + e.xyy) - map(p - e.xyy),  map(p + e.yxy) - map(p - e.yxy),  map(p + e.yyx) - map(p - e.yyx)));
}

// Function 2274
vec3 snormal(vec3 a) {
   vec2 e = vec2(.0001, 0.);
   float w = scene(a);
   return normalize(vec3(
       scene(a+e.xyy) - w,
       e.x,
       scene(a+e.yyx) - w));
}

// Function 2275
vec3 GetNormal(vec3 p)
{
	vec3 eps = vec3(0.01,0.0,0.0);
	return normalize(vec3(
		Scene(p+eps.xyy)-Scene(p-eps.xyy),
		Scene(p+eps.yxy)-Scene(p-eps.yxy),
		Scene(p+eps.yyx)-Scene(p-eps.yyx)
		));
}

// Function 2276
vec3 raymarch(vec3 raydir, vec3 raypos){
    float distest;
    for(uint i = 0U; i < maxmarches; i++){
        distest = DE(raypos);
        if(distest < collisiondist){return vec3(1.0);}
        raypos += raydir*distest;
        if(length(raypos) > scenesize){break;}
    }
    return vec3(0.0);
}

// Function 2277
vec4 raymarch(float end, vec3 pos, vec3 dir, float h)
{
    float total = 0.0;
    for (int i = 0; i < MARCHMAX; i++)
    {
        vec3 current = pos + total * dir;
        // NOTE: form must fit inside in 0..1 grid-cell!
        current -= 0.5; // center in 0..1 cube
        float dist = mix(sphereSDF(current), cubeSDF(current), h);
        if (dist < MARCHEPS) // We're inside the scene surface!
        {
            vec3 n = mix(sphereNRM(current), cubeNRM(current), h);

            return vec4(n * 0.5 + 0.5, 1.0);
        }

        // Move along the view ray
        //total += dist; // XXX artifacts on cube-edges when using full step-size (possibly due to GRIDEPS?) XXX
        total += 0.5 * dist; // XXX half step-size hides (or solves?) this XXX

        if (total >= end) // Gone too far; give up
        {
            return vec4(0.0);
        }
    }

    return vec4(0.0);
}

// Function 2278
vec3 calcNormal(in vec3 pos, in float h)
{
    vec4 e = vec4(0.0005,-0.0005, 1., -1);
    pos = pos - e.xxx;
    return normalize(e.zww*map( pos + e.xyy ).w + 
  			 		 e.wwz*map( pos + e.yyx ).w + 
			  		 e.wzw*map( pos + e.yxy ).w + 
              		 e.zzz*h );
}

// Function 2279
vec3 normalSphere(in vec3 pos, in vec4 sph)
{
    //sphere center at (l, m, n) radius r
    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )
    return (pos - sph.xyz)/sph.w;
}

// Function 2280
vec3 Normal(vec3 a) {
	vec2 e = vec2(.001, 0.);
	float w = World(a);
	return normalize(vec3(World(a+e.xyy) - w,
						  World(a+e.yxy) - w,
		                  World(a+e.yyx) - w));
}

// Function 2281
float FlyerEngRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 50; j ++) {
    d = FlyerEngDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0002 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2282
void prepare_ray(float s, float t) {
    //s = 0.0;
    float q = tri(iTime*0.3);
    vec2 c = vec2(mix(0.0,3.2,q),0.0);
    vec2 w = vec2(1.0,1.0)*mix(0.1,1.5,q);
    s = s*2.0 - 1.0;
    t = t*2.0 - 1.0;
    vec3 p1 = vec3(c + w*vec2(s,t), 0.0);
    vec3 p0 = vec3(p1.xy * 0.0, -1.0);
    ro = p0;
    rd = p1 - p0;
}

// Function 2283
vec3 calcNormal(vec3 p) {
  const vec2 e = vec2(0.001, 0.0);
  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
                        map(p + e.yxy) - map(p - e.yxy),
                        map(p + e.yyx) - map(p - e.yyx)));
}

// Function 2284
vec3 getNormal(in vec3 p) {
	
	const float eps = 0.001;
	return normalize(vec3(
		map(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),
		map(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),
		map(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))
	));

}

// Function 2285
vec3 calcNormalmap( in vec3 pos, in float ep )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*map(pos+e.xyy*ep).x + 
					 e.yyx*map(pos+e.yyx*ep).x + 
					 e.yxy*map(pos+e.yxy*ep).x + 
					 e.xxx*map(pos+e.xxx*ep).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*ep).x;
    }
    return normalize(n);
#endif    
    
}

// Function 2286
Hit raymarch(Ray ray)
{
	vec3 pos;
	Hit hit;
	hit.dist = 0.;
	Hit curHit;
	for (int i = 0; i < 40; i++)
	{
		pos = ray.org + hit.dist * ray.dir;
		curHit = scene(pos);
		hit.dist += curHit.dist;
		glowAmt += clamp(pow(curHit.dist+0.1, -8.),0.,0.15)*glows(curHit.index);
	}
	hit.index = curHit.index;
	hit.index = curHit.dist < 0.01 ? hit.index : -1.;
	return hit;
}

// Function 2287
vec3 computeNormal(vec3 p) {
    vec3 n = vec3(0.0);
    float eps = .001;
    for( int i=(min(iFrame,0)); i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*sceneMap3D(p+eps*e);
    }
    return normalize(n);
}

// Function 2288
vec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)
{
    
  if ( ray_dir.z > 0.0)
  {
    return vec3(0,0,0);
  }

  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;
  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);
  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);
  return vec3(intresection_x, intresection_y, 0);
}

// Function 2289
vec3 calcNormal( in vec3 pos )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
      //if( n.x+n.y+n.z>100.0 ) break;
    }
    return normalize(n);
#endif    
}

// Function 2290
vec2 PackNormals(in vec3 v)
{
	vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));
	return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;
}

// Function 2291
float pack_normal(vec2 n) {
    vec2 s = sign(n);
    return s.y*(s.x * (sqrt(5.0/(n.x*s.x + 4.0) - 1.0) - 0.5) + 0.5);
}

// Function 2292
vec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )
{
	vec3 vForward = normalize(vCameraTarget - vCameraPos);
	vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));
	vec3 vUp = normalize(cross(vForward, vRight));
	
    const float kFOV = 1.8;
    
	vec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);

	return vDir;
}

// Function 2293
vec3 RayMarch(vec3 ro,vec3 rd)
{
    float hd = 0.0;
    id=0;
    for(int i = 0;i < 128;i++)
    {
        float d = Scene(ro + rd * hd);
        hd += d;
        if(d < 0.0001) {id=1;break;}
    }   
    return ro + rd * hd;
}

// Function 2294
vec4 raymarch (vec3 ro, vec3 rd)
{
	for (int i=0;i<16;i++)
	{
		float t = map(ro);
		if (t<0.001) return ProceduralSkybox(ro,rd);     
		ro+=t*rd;
	}
	return vec4(0,0,0,1);
}

// Function 2295
vec3 CalcNormal( in vec3 pos )
{
    vec2 eps = vec2(EPSILON,0.0);
	return normalize( vec3( Map(pos+eps.xyy) - Map(pos-eps.xyy), Map(pos+eps.yxy) - Map(pos-eps.yxy), Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );
}

// Function 2296
vec3 calcNormal(in vec3 pos) {
	vec3 eps = vec3( 0.01, 0.0, 0.0 );
	vec3 nor = vec3(
	    d(pos+eps.xyy).x - d(pos-eps.xyy).x,
	    d(pos+eps.yxy).x - d(pos-eps.yxy).x,
	    d(pos+eps.yyx).x - d(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 2297
float RayMarch(vec3 ro, vec3 rd) {
	float dO=0.;
    
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    
    return dO;
}

// Function 2298
vec3 Normal2(vec3 p){if(df(p)<.03)return Normal(p);return vec3(-.7);}

// Function 2299
bool RayVsSphere(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in vec3 diffuse)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > 0.0f && dist < info.dist)
    {
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
		info.diffuse = diffuse;        
        return true;
    }
    
    return false;
}

// Function 2300
vec2 RayMarch(vec3 ro, vec3 rd) {
	float dO=0.;    
    vec2 m;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        m = GetDist(p);
        float dS = m.x;
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }    
    return vec2(dO,m.y);
}

// Function 2301
vec3 normal(in vec3 pos)
{
  vec3  eps = vec3(NORM_OFF,0.0,0.0);
  vec3 nor;
  int mat;
  nor.x = map(pos+eps.xyy, mat) - map(pos-eps.xyy, mat);
  nor.y = map(pos+eps.yxy, mat) - map(pos-eps.yxy, mat);
  nor.z = map(pos+eps.yyx, mat) - map(pos-eps.yyx, mat);
  return normalize(nor);
}

// Function 2302
vec3 calcCameraRayDir(float fov, vec2 fragCoord, vec2 resolution)
{
	float tanFov = tan(fov / 2.0 * 3.14159 / 180.0) / resolution.x;
	vec2 p = tanFov * (fragCoord * 2.0 - resolution.xy);
	vec3 rayDir = normalize(vec3(p.x, p.y, 1.0));
	rotateAxis(rayDir.yz, iCamRotX);
	rotateAxis(rayDir.xz, iCamRotY);
	rotateAxis(rayDir.xy, iCamRotZ);
	return rayDir;
}

// Function 2303
float NormalDistributionRand( inout uint seed )
{
    // https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    
    float U1 = FRand(seed);
    float U2 = FRand(seed);
    
    return sqrt( -2.0 * log( U1 ) ) * cos( TAU * U2 );
}

// Function 2304
vec3
calc_normal( in vec3 pos, in float t )
{
    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);
	return normalize( vec3(
           map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,
           map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,
           map( pos + eps.yyx ).x - map( pos - eps.yyx ).x ) );
}

// Function 2305
vec3 shade_reflect(vec3 p, vec3 rd, vec3 n)
{
	vec3 diffuse = background(reflect(rd, n));
	vec3 l = normalize(LightPos - p);

	// Phong shading
	vec3 color = 0.4 * diffuse; // "Ambiant" Term
	
    float penumbra = 1.0;
	float lambertTerm = dot(n,l);
	if(lambertTerm > 0.0)
	{
		#ifdef SELF_SHADOWING
		bool gotout = false;
		bool hit = false;
		vec3 p2 = p + Epsilon * l;
		for(int i = 0; i < Steps; i++)
		{
			float v = SphereTracedObject(p2);
			if (v < 0.0)
			{
				gotout = true;
				break;
			}

			p2 += Epsilon * l;
		}
        #ifdef SOFT_SHADOW
        if(gotout)
            penumbra = clamp(softShadow(p2, l, 16.0), 0.0, 1.0);
        #else
		if(gotout)
			SphereTrace(p2, l, hit);
		if(hit) // We're in shadows, skip diffuse and specular terms 
			return color;
        #endif
		#endif
		
        vec3 shaded = penumbra * LightColor;
        
		// Diffuse Term
		color += lambertTerm * shaded * diffuse;	

		// Specular Term
		vec3 r = reflect(l, n);
		float specular = pow( max(dot(r, rd), 0.0), 8.0);
		color += specular * shaded;	
	}

	return color;
}

// Function 2306
vec3 GetNormal(vec3 p)
{
    float d = GetDist(p).y;
    vec2 e = vec2(0.01, 0);
    
    vec3 n = d - vec3 (
        GetDist(p - e.xyy).y,
        GetDist(p - e.yxy).y,
        GetDist(p - e.yyx).y
    );
    return normalize(n);
}

// Function 2307
void calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (2.0*pix-iResolution.xy)/iResolution.y;
	
     // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 2308
vec3 normals(in vec3 p){
    vec2 e = vec2(.01, 0.);
    vec3 n = p - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));
    return normalize(n);
}

// Function 2309
float raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations) {
    dist = 0.0;
    float minStep = 0.1;
	vec2 mapRes;
    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {
        p = ray_start + ray_dir * dist;
        mapRes = map(p, ray_dir);
        if (mapRes.y < MIN_RAYMARCH_DELTA) {
           iterations = i;
           return mapRes.x;
        }
        dist += max(mapRes.y, minStep);
    }
    return -1.;
}

// Function 2310
vec3 getNormal(vec3 pos)
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773 * 1e-4;
    return normalize(
        e.xyy*map( pos + e.xyy ).x +
        e.yyx*map( pos + e.yyx ).x +
        e.yxy*map( pos + e.yxy ).x +
        e.xxx*map( pos + e.xxx ).x
    );
}

// Function 2311
void Grayscale(inout vec3 rgb)
{
   float avg = 0.3*rgb.x + 0.59*rgb.y + 0.11*rgb.z;
    rgb = vec3(avg, avg, avg);
}

// Function 2312
vec3 calcNormal(vec3 pos)
{
	vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);
        n += (iTime<20.0)?e*SDFCageScene(pos+0.0005*e,0)[0]:
        (iTime<52.0)?e*SDFscene(pos+0.0005*e)[0]:
        (iTime<70.0)?e*SDFSeaScene(pos+0.0005*e)[0]:
        e*SDFCageScene(pos+0.0005*e,0)[0];
    }
    return normalize(n);
}

// Function 2313
vec3 computeNormalAndSnapPoint(inout vec3 pos) {

    float posLen = length(pos);
    vec2 latlon = _3DToLatLon(pos/posLen);
      
    const float latlonPixel = PIXEL_SIZE;
    
    vec2 discreteLatlon = discretize(latlon, latlonPixel);
    vec3 filteredPos = latLonTo3D(discreteLatlon + 0.5*latlonPixel);
    vec3 normal = normalize(filteredPos);
    
    vec3 nx = normalize(cross(vec3(0,1,0), normal));
    vec3 ny = cross(normal, nx);    

    vec2 dll = (latlon - discreteLatlon) / latlonPixel;
    
    bool TL = dll.x > dll.y;
    bool BL = dll.x < (1.0 - dll.y);
    
    if(TL) {
         if(BL) {
            latlon.y = latlon.y;
            
            normal = -nx;
         }
         else {
            latlon.x = discreteLatlon.x + latlonPixel;         
            normal = +ny;
         }
    }
    else {
         if(BL) {
            latlon.x = discreteLatlon.x;
            normal = -ny;
         }
         else {
                 latlon.y = discreteLatlon.y + latlonPixel;         
         
            normal = +nx;
         }
    }


    // snap
   //pos = latLonTo3D(latlon) * posLen;
    
    return normal;
}

// Function 2314
vec3 calcNormalDamage( in vec3 pos, in float eps ) {
    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   		
	        return vec3( 0., 1., 0. );
    }
    
    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);
    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + 
			     		 e.yyx*mapDamageHigh( pos + e.yyx ) + 
					  	 e.yxy*mapDamageHigh( pos + e.yxy ) + 
					  	 e.xxx*mapDamageHigh( pos + e.xxx ) );
    n = bumpMapNormal( pos, n );
    return n;    
}

// Function 2315
vec3 treesNormal( in vec3 pos, in float t )
{
    float kk1, kk2, kk3;
#if 0    
    const float eps = 0.005;
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + 
                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + 
                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + 
                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);
    }
    return normalize(n);
#endif    
}

// Function 2316
vec3 getNormal (vec3 pos) {
  vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
  return normalize( e.xyy*map( pos + e.xyy ) + e.yyx*map( pos + e.yyx ) + e.yxy*map( pos + e.yxy ) + e.xxx*map( pos + e.xxx ) );
}

// Function 2317
vec3 refraction(vec3 v, vec3 normal, float n1, float n2, out bool flag)
{
    if (dot(v, normal) < 0.0) 
    {
        normal = -normal;
    }
    
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3  tang = normalize(v - cosA * normal);
    
    float sinB = sinA / n2 * n1;
    if (abs(sinB) >= 1.0)
    {
        flag = false;
        return reflect(v, normal);
    }
    else 
    {
        flag = true;
        float cosB = sqrt(1.0 - sinB * sinB);
        return sinB * tang + cosB * normal;
    }
}

// Function 2318
vec3 getRayDir(vec3 camDir, vec2 fragCoord) {
  vec3 yAxis = vec3(0, 1, 0);
  vec3 xAxis = normalize(cross(camDir, yAxis));
  vec2 q = fragCoord / iResolution.xy;
  vec2 p = 2.0 * q - 1.0;
  p.x *= iResolution.x / iResolution.y;
  return normalize(p.x * xAxis + p.y * yAxis + 5.0 * camDir);
}

// Function 2319
vec3 getNormal(vec2 uv) {
    return 2.0 * (texture(iChannel0, vcubeFromFragCoord(2, uv*1024.0)).xyz - 0.5);
}

// Function 2320
vec3 castCamRay(vec2 xy){
    float ratio = Cam.dir.z/length(Cam.dir.xy);
    vec3 VertPerp = vec3(-Cam.dir.x*ratio, -Cam.dir.y*ratio, length(Cam.dir.xy));
    vec3 yComp = VertPerp * xy.y;
    
    vec3 HoriPerp = vec3(Cam.dir.y,-Cam.dir.x,0.0)/length(vec3(Cam.dir.y,-Cam.dir.x,0.0));
    vec3 xComp = HoriPerp * xy.x;
    
    vec3 ray = (Cam.dir*3.0)+xComp+yComp;
    vec3 rayDir = (ray/length(ray));

    vec3 P = Cam.pos;
    vec3 N = vec3(0.0,0.0,0.0);
    vec3 Collision = checkCollide(P,rayDir);
    if(Collision.x>0.0){
        if(int(Collision.y)==0){ //Sphere
            Sphere tempS = objects.spheres[int(Collision.z)];
			
            if(bounceCount>=1){
                P = P + (rayDir*Collision.x);
                N = (tempS.pos-P)/length(tempS.pos-P);
                P = P + N*(0.0001);
                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));
                return b1(P,tempRef,-N,tempS.col,tempS.gTd,tempS.sTr,tempS.fres);
            }
            else{
                return tempS.col;
            }
        }
        if(int(Collision.y)==1){ //Triangle
            Triangle tempT = objects.triangles[int(Collision.z)];

            if(bounceCount>=1){
                P = P + (rayDir*Collision.x);
                N = cross((tempT.Vert1-tempT.Vert2),(tempT.Vert1-tempT.Vert3));
                N = -N/length(N);
                P = P + N*(0.00001);
                vec3 tempRef = reflect(rayDir,N)/length(reflect(rayDir,N));
                return b1(P,tempRef,N,tempT.col,tempT.gTd,tempT.sTr,tempT.fres);
            }
            else{
                return tempT.col;
            }
        }

        if(int(Collision.y)==2){ //Light
            Light tempL = objects.lights[int(Collision.z)];
            return tempL.col;

        }

    }
    else{
		if(eviLight){
			return texture(iChannel0,vec3(rayDir.x,rayDir.z,rayDir.y)).xyz;
        }
    }
    
    
    

}

// Function 2321
vec3 calculateNormal(vec3 p) {
 
    vec3 epsilon = vec3(0.001, 0., 0.);
    
    vec3 n = vec3(map(p + epsilon.xyy).x - map(p - epsilon.xyy).x,
                  map(p + epsilon.yxy).x - map(p - epsilon.yxy).x,
                  map(p + epsilon.yyx).x - map(p - epsilon.yyx).x);
    
    return normalize(n);
}

// Function 2322
float rayfff(float t) {
    return pa_map(pa_init(t)).a[2];
}

// Function 2323
vec3 getNormal(vec3 p, inout float edge, inout float crv, float ef, float t){ 
	
    vec2 e = vec2(ef/iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.

    // Take some distance function measurements from either side of the hit point on all three axes.
	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;	// The hit point itself - Doubled to cut down on calculations. See below.
     
    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how
    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum
    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface 
    // curves that register a discernible difference.
    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.
    
    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you 
    // do that is up to you. This is what I came up with for now, but I might tweak it later.
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));
    
    
    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
	
    // Redoing the calculations for the normal with a more precise epsilon value.
    e = vec2(.002, 0);//*min(1. + t, 5.)
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx); 
    
    // Return the normal.
    // Standard, normalized gradient mearsurement.
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 2324
ray camera_get_ray(camera c, vec2 uv) {
    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);
    vec3 offset = c.u * rd.x + c.v * rd.y;
    return ray(c.origin + offset, 
               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));
}

// Function 2325
vec3 castRay(in vec3 ro, in vec3 rd, in float maxd, in float aa)
{
	vec4 col = vec4(0.0);	// Forground (pre-multiplied)
	float c = 1.;			// Keep track if we are moving closer or away from a surface
	
	float precis = 0.001;
    float h = 0.0, mh = 1e20;
    float t = 0.0, mt = 0.0;
    float m = -1.0, mm = -1.0;
	
    for(int i=0; i<100; i++ )
    {
        t += h;
	    vec2 res = map( ro+rd*t );
        h = res.x;
	    m = res.y;
		
		if(abs(h)<precis || t>maxd ) break;
		
		if(h < mh) { // closer
			c = 1.0;
			mh = h;
			mt = t;
			mm = m;
		} else if(c > 0.0) { // away
			c = 0.0;
			float s = (mt+1.0)/iResolution.y;
			if(mh < s) {
				float a = 1. - (mh / s);
				vec3 rgb = GetColor(ro, rd, mt, mm);
				col = Blend(col, vec4(rgb*a, a));
			}
		}
    }
	
	if(texture(iChannel3, vec2(KEY_A,0.75)).x > 0.) {
 		col = vec4(0.0);
	}
	
	if(texture(iChannel3, vec2(KEY_T,0.75)).x > 0.) {
		if(m > 1.) col.a = 1.;
		return vec3(pow(col.a, 2.2));
	}
	
	col = Blend(col, vec4(GetColor(ro, rd, t, m), 1.));
	
	col.rgb /= col.a;	
	col.rgb *= exp( -0.01*t*t );
	
    return col.rgb;
}

// Function 2326
vec3 getNormal(in vec3 p) {
    vec3 n=vec3(0.);
    vec3 e =vec3(0.001,0,0);
    for(int i=min(iFrame,0);i<=2;i++){       
        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapVoxel(p + j* e) ;
        e=e.zxy; //TdHopper trick
    }
    return normalize(n);
}

// Function 2327
vec3 normalLowDetailModel(vec3 P)
{
	vec2 eps = vec2(0.,0.001);
    return normalize(vec3(
        SD_LowDetailModel(P+eps.yxx).d - SD_LowDetailModel(P-eps.yxx).d, 
		SD_LowDetailModel(P+eps.xyx).d - SD_LowDetailModel(P-eps.xyx).d, 
        SD_LowDetailModel(P+eps.xxy).d - SD_LowDetailModel(P-eps.xxy).d));
}

// Function 2328
vec3 normal( vec3 pos, float t )
{
    vec2 dd = vec2(0.01,0.);
    vec4 c;
    return normalize(
        vec3(sdf(pos+dd.xyy,t,c), sdf(pos+dd.yxy,t,c), sdf(pos+dd.yyx,t,c) ) - vec3(sdf(pos,t,c))
                    );
}

// Function 2329
vec4 raymarche( in vec3 org, in vec3 dir, in vec2 nfplane )
{
	float d = 1.0, g = 0.0, t = 0.0;
	vec3 p = org+dir*nfplane.x;
	
	for(int i=0; i<64; i++)
	{
		if( d > 0.001 && t < nfplane.y )
		{
			d = map(p);
			t += d;
			p += d * dir;
			g += 1./64.;
		}
	}
	
	return vec4(p,g);
}

// Function 2330
bool rayBunnyIntersection( in Ray ray, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    bool res = castRay( ray, t, isect.normal_ );
    isect.position_ = ray.origin + ray.dir*t;
    return res;
}

// Function 2331
float2 Normal_Sampler ( in sampler2D s, in float2 uv ) {
  float2 eps = float2(0.003, 0.0);
  return float2(length(texture(s, uv+eps.xy)) - length(texture(s, uv-eps.xy)),
                length(texture(s, uv+eps.yx)) - length(texture(s, uv-eps.yx)));
}

// Function 2332
vec2 normalizeScreenCoords(vec2 screenCoord)
{
    vec2 result = 2.0*(screenCoord/iResolution.xy - 0.5);
    result.x *= iResolution.x/iResolution.y;
    return result;
}

// Function 2333
Ray createRandomReflect(Ray ray, mat4 hit)
{
	vec3 normal = hit[1].xyz;
	if(dot(normal,ray.direction) > 0.0)
    	normal = -normal;

    vec3 worldUp = vec3(1,1,0);
	vec3 e0 = normalize(normal);
	vec3 e1 = normalize(cross(e0,worldUp));
	vec3 e2 = normalize(cross(e0,e1));

	//Create evenly distributed ray
	//reference: http://mathworld.wolfram.com/SpherePointPicking.html

    float phi = rand()*M_PI*2.0;
	float x = rand();
	float theta = abs(acos(x));//NOTE : sometimes acos will give a small negiative number.
	vec3 direction = normalize(sin(theta)*cos(phi)*e1 +
		sin(theta)*sin(phi)*e2 +
		abs(cos(theta))*e0);

    vec3 intersection = normalize(ray.direction)*hit[0].z + ray.origin;
	vec3 origin = intersection
		+direction*0.0001; //workaround float point accuracy issue
    
	Ray reflect = createRay(origin, direction);
	return reflect;
}

// Function 2334
vec3 normal(vec3 p) {
	vec3 e = vec3(0.0,det,0.0);
	
	return normalize(vec3(
			de(p+e.yxx).x-de(p-e.yxx).x,
			de(p+e.xyx).x-de(p-e.xyx).x,
			de(p+e.xxy).x-de(p-e.xxy).x
			)
		);	
}

// Function 2335
vec4 raytrace(vec3 ro, vec3 rd) {
    vec2 t = vec2(0.);
    vec2 m = map(ro);
    //fac.xyz are consecutive measurements, fac.w is the last local minimum
    vec4 fac = vec4(maxdist);
    int i;
    for (i=0; i<iters; i++) {
        t.x += m.x;
        m = map(ro + rd * t.x);
        fac.x = m.x / t.x;
        //update facmin to last seen local minimum (not counting voxel borders)
        if (fac.y < fac.x && fac.y <= fac.z && fac.y < fac.w) {
            fac.w = fac.y;
            t.y = t.x;
        }
        fac.zy = fac.yx;
        if (abs(m.x) < tol) {
            return vec4(t, m.y, fac.w);
        } else if (t.x > maxdist) {
            break;
        }
    }
    return vec4(t, 0., fac.w);
}

// Function 2336
vec3 normal( in vec3 pos ){
    vec2 e = vec2(0.002, -0.002);
    return normalize(
        e.xyy * map(pos + e.xyy).x + 
        e.yyx * map(pos + e.yyx).x + 
        e.yxy * map(pos + e.yxy).x + 
        e.xxx * map(pos + e.xxx).x);
}

// Function 2337
vec3 computeSphereNormal(in Sphere s, in Ray r, in float dist) {
    return normalize((r.origin + r.dir * dist) - s.center);
}

// Function 2338
vec3 calcNormal( in vec3 pos, float t )
{
    vec2  eps = vec2( 0.001*t, 0.0 );
    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),
                            2.0*eps.x,
                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );
}

// Function 2339
vec3 getNormal(vec3 pos)
{
    vec2 eps = vec2(0.0, EPSILON);
	return normalize(vec3(
        distanceField(pos + eps.yxx) - distanceField(pos - eps.yxx),
        distanceField(pos + eps.xyx) - distanceField(pos - eps.xyx),
        distanceField(pos + eps.xxy) - distanceField(pos - eps.xxy)
    ));
}

// Function 2340
vec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )
{
    float t = tminmax.x;
    float dt = 0.02;
    if (animate_pattern)
      dt = 0.02 + 0.01*cos(time*0.5);

    vec3 col= vec3(0.);
    float c = 0.;
    for( int i=0; i<64; i++ )
    {
        t+=dt*exp(-2.*c);
        if(t>tminmax.y)break;
        vec3 pos = ro+t*rd;
        c = 0.45 * map(ro+t*rd);
        col = 0.98*col + 0.08*vec3(c*c, c, c*c*c);  // green
        col = 0.99*col + 0.08*vec3(c*c*c, c*c, c);  // blue
        col = 0.99*col + 0.08*vec3(c, c*c*c, c*c);  // red
    }
    return col;
}

// Function 2341
vec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)
{
	vec3 localRay = normalize(rayDir);
	float dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);
	float sunIntensity = 0.015 / dist;
	sunIntensity = pow(sunIntensity, 0.3)*100.0;

    sunIntensity += exp(-dist*12.0)*300.0;
	sunIntensity = min(sunIntensity, 40000.0);
	return sunCol * sunIntensity*0.0425;
}

// Function 2342
vec3 calcNormal( in vec3 pos ) {
    const float eps = INTERSECTION_PRECISION;

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*sdf( pos + v1*eps ) + 
					  v2*sdf( pos + v2*eps ) + 
					  v3*sdf( pos + v3*eps ) + 
					  v4*sdf( pos + v4*eps ) );
}

// Function 2343
float SheetRay (vec3 ro, vec3 rd)
{
  vec3 r;
  vec2 g;
  float d, dMin, sz, szMax, szMin, grLen;
  bvec2 ilt;
  bool bkTrak;
  dMin = dstFar;
  grLen = 0.92 * spLen;
  szMax = max (bGrid.x, bGrid.y);
  szMin = 1./16.;
  g = vec2 (0.);
  bkTrak = false;
  sz = szMax;
  for (int ns = 0; ns < 2000; ns ++) {
    if (sz == szMin) {
      r = GetR (g) - ro;
      if (length (cross (r, rd)) < sz * grLen) {
        d = dot (rd, r);
        if (d < dMin) {
          dMin = d;
          qgHit = g;
        }
      }
      bkTrak = true;
    }
    bkTrak = bkTrak || (length (cross (GetR (g + 0.5 * sz) - ro, rd)) > sz * grLen);
    if (bkTrak) {
      bkTrak = false;
      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));
      g.x += ilt.x ? sz : - sz;
      if (! ilt.x) {
        g.y += ilt.y ? sz : - sz;
        if (! ilt.y) {
          sz *= 2.;
          if (sz == szMax) break;
          bkTrak = true;
        }
      }
    } else if (sz > szMin) sz *= 0.5;
  }
  return dMin;
}

// Function 2344
vec3 combineNormals0(vec3 n0, vec3 n1) {
    n0 = n0 * 2.0 - 1.0;
    n1 = n1 * 2.0 - 1.0;
    return normalize(n0 + n1) * 0.5 + 0.5;
}

// Function 2345
vec3 getNormal(vec3 p) {
	vec2 t = vec2(0.0005,0.);    
    return normalize(vec3(
    	map(p + t.xyy).d - map(p - t.xyy).d,
    	map(p + t.yxy).d - map(p - t.yxy).d,
    	map(p + t.yyx).d - map(p - t.yyx).d
    ));
}

// Function 2346
SurfaceInteraction rayMarch(vec3 ro, vec3 rd) {
    
    SurfaceInteraction interaction = SurfaceInteraction(-1., rd, vec3(0.), vec3(0.), vec3(0.), vec3(0.), -10.);
    
    float t = 0.;
    vec3 p = ro;    
    vec2 obj = vec2(0.);
    float d = INFINITY;
    
    for (int i = 0; i < RAY_MARCH_STEPS; i++) {
        
        obj = map(p);
        d = obj.x;
        
        t += d;
        p += rd * d;
        
        if (d < .001) { break; }
        obj.y = 0.;
        
    }

    interaction.id = obj.y;        
    interaction.point = p;
    interaction.normal = calculateNormal(interaction.point);
    interaction.objId = obj.y;
    return interaction;
}

// Function 2347
vec3 genDiffRay(vec3 P, vec3 N, vec2 seed){
    /*vec2 randAng = vec2(rand(seed)*PI,rand(seed*2.0)*PI);
    
    float ratio = N.z/length(N.xy);
    
    vec3 VertPerp = vec3(0.0,0.0,0.0);
    vec3 HoriPerp = vec3(0.0,0.0,0.0);
	if(N==vec3(0.0,0.0,1.0)||N==vec3(0.0,0.0,-1.0)){
        VertPerp = vec3(1.0,0.0,0.0);
        HoriPerp = vec3(0.0,1.0,0.0);
    }
    else{
        VertPerp = vec3(-N.x*ratio, -N.y*ratio, length(N.xy));
        HoriPerp = vec3(N.y,-N.x,0.0)/length(vec3(N.y,-N.x,0.0));
    }
    
    vec3 yComp = (VertPerp * cos(randAng.x))+(N*sin(randAng.x));
    yComp/=length(yComp);
    vec3 xComp = (HoriPerp * cos(randAng.y))+(N*sin(randAng.y));
    xComp/=length(xComp);
    vec3 diffRay = yComp+xComp-N;*/
    
    
    vec3 randPoint = vec3((rand(seed)*2.0)-1.0,(rand(seed*4.0)*2.0)-1.0,(rand(seed*3.0)*2.0)-1.0)+P; //gen rand point around P
    vec3 randRay = P-randPoint;
    //randRay = randRay/length(randRay);
    vec3 diffRay = N+randRay;
    return (diffRay/length(diffRay));
}

// Function 2348
bool castRay( in vec3 ro, in vec3 rd, out float resT, out float resH, out vec3 resN, out float resS, out vec4 resC )
{    
    for( float t = NEAR_CLIP; t < FAR_CLIP; t += RAY_STEP )
    {
        vec3 p = ro + rd*t;
        float h = soup( p.x, p.z );
        if ( p.y < h )
        {
            if ( t == NEAR_CLIP )
            {
                resT = 0.0;
                resH = h;
                resN = vec3(0.0, 0.0, -1.0);
                resC = HEIGHT_FOG_COLOR*0.1;
                resS = 1.0;
                
                return true;
            }
            
            resT = t - 0.5*RAY_STEP;
            resH = h;
            resN = soupNormal( p.x, p.z );
            // soup color
            resC = vec4(vec3(0.64), 1.0);
            
            if (p.z < SHADOWS_MAX_DIST)
            {
                float sunRayS;
                vec3 sunDir = normalize( sunPos - p ); 
                //*/
                if ( sunRay( p, sunDir, sunRayS ) )
                {
                    resS = sunRayS;
                    // shadow color
                    resC = vec4(0.42, 0.0, 1.0, 1.0);
                }
                else
                {
                    resS = 1.0;
                }
                /*/
                resS = 1.0;
                //*/ 
                
                // scatter some fuzzball color in there
                float scatterRadius = 128.0;
                float fuzzballDist = length( fuzzballSoupPos-p );
                if ( fuzzballDist < scatterRadius )
                {
                    float blend = fuzzballDist/scatterRadius;
                    resC = (resC*blend)+(FUZZBALL_COLOR*(1.0-blend));
                }
            }

            return true;
        }
        
        if (dustTex.r > 0.0)
        {            
            if (t > (DUST_MIN_DIST + (dustTex.g*(DUST_MAX_DIST-DUST_MIN_DIST))))
            {
                resT = t - 0.5*RAY_STEP;
                resH = h;
                resN = vec3(0.0, 0.5, 0.5);
                resS = 1.0;
                // dust color
                resC = vec4(0.0, 0.8, 0.8, 1.0);  
                
                return true;
            }
        }
        
        // Player fuzzball
        vec3 fuzzballN;
        float fuzzballDisp;
        if ( fuzzball( p, fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, fuzzballDisp ) )
        {
            resT = t - 0.5*RAY_STEP;
            resH = h;
            //resN = fuzzballN;
            float sampDist = 0.1;
            float x1, x2, y1, y2, z1, z2;
            float disp;
            x1 = fuzzball( p+vec3(sampDist,0.0,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            x2 = fuzzball( p+vec3(-sampDist,0.0,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            y1 = fuzzball( p+vec3(0.0,sampDist,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            y2 = fuzzball( p+vec3(0.0,-sampDist,0.0), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            z1 = fuzzball( p+vec3(0.0,0.0,sampDist), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            z2 = fuzzball( p+vec3(0.0,0.0,-sampDist), fuzzballSoupPos, FUZZBALL_RADIUS, fuzzballN, disp ) ? 1.0 : 0.0;
            resN = vec3((x1-x2)/(2.0*sampDist), (y1-y2)/(2.0*sampDist), (z1-z2)/(2.0*sampDist));
            
            if ( resN == vec3(0.0) )
            {
                resN = vec3(0.0, 0.0, -1.0);
            }
            resN = normalize( resN );
            if (p.z < SHADOWS_MAX_DIST)
            {
                float sunRayS;
                vec3 sunDir = normalize( sunPos - p ); 
                if ( sunRay( p, sunDir, sunRayS ) )
                {
                    resS = sunRayS;
                    // shadow color
                    resC = vec4(0.42, 0.0, 1.0, 1.0);
                }
                else
                {
                    resS = 1.0;
                }
            }
            // fuzzball color
            float blend = (0.42+0.042*fuzzballDisp);
            blend = 1.0 - blend;
            blend = pow( blend, 2.0 );
            blend = 1.0 - blend;
            resC = (FUZZBALL_COLOR*blend)+(FUZZBALL_COLOR2*(1.0-blend));

            return true;
        }
    }
    
    // Draw sun and moon in background
    vec3 sphereN;
    if ( sphere2D( ro, rd, sunPos, 100.0, sphereN ) )
    {
        resT = 0.0;
        resH = sunPos.y+200.0;
        resN = sphereN;
        resS = 1.0;
        // sun color
        resC = vec4(2.0, 0.8, 0.4, 0.0);

        return true;
    }
    if ( sphere2D( ro, rd, moonPos, 42.0, sphereN ) )
    {
        resT = 0.0;
        resH = moonPos.y+200.0;
        resN = sphereN;
        resS = 1.0;
        // moon color
        resC = vec4(0.42, 0.42, 0.42, 0.0);

        return true;
    }
    
    return false;
}

// Function 2349
vec3 GetNormal(vec3 p) {
	float d = GetDist(p).x;
    vec2 e = vec2(1e-4, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy).x,
        GetDist(p-e.yxy).x,
        GetDist(p-e.yyx).x);
    
    return normalize(n);
}

// Function 2350
vec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)
{
    rp = rp - (p0 + p1) / 2.;
    vec3 arp = abs(rp) / (p1 - p0);
    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);
}

// Function 2351
vec3 getNormal( in vec3 p ) {
    vec4 n = vec4(0);
    for (int i = Z ; i < 4 ; i++) {
        vec4 s = vec4(p, 0);
        s[i] += 0.0001;
        n[i] = de(s.xyz);
    }
    return normalize(n.xyz-n.w);
}

// Function 2352
float GetNormalizedDepth(float x)
{
	return (FAR-x)/(FAR-NEAR);   
}

// Function 2353
vec3 calcWaterNormal( vec2 pos, float res )
{   
  return normalize(vec3(noise2D((pos + vec2(-0.001, 0))* res,WATER_LOD)-noise2D((pos + vec2(+0.001, 0))* res,WATER_LOD), noise2D((pos + vec2(0, -0.001))*res,WATER_LOD)-noise2D((pos + vec2(0, +0.001))* res,WATER_LOD), .005)) * 0.5 + 0.5;
}

// Function 2354
vec3 calcNormalOpaque( in vec3 pos, in float eps )
{
    vec4 kk;
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + 
                      e.yyx*mapOpaque( pos + e.yyx, kk ).x + 
                      e.yxy*mapOpaque( pos + e.yxy, kk ).x + 
                      e.xxx*mapOpaque( pos + e.xxx, kk ).x );
}

// Function 2355
vec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )
{
	vec4 sum = vec4(0.0);

	float t = 0.0;//0.05*texelFetch( iChannel0, px&255, 0 ).x;
    for(int i=0; i<256; i++)
    {
       vec3 pos = ro + t*rd;
       if( /*pos.y<-3.0 || pos.y>2.0 ||*/ sum.a>0.99 ) break;
       float den = map( pos );
       if( den>0.01 )
       {
         float dif = clamp((den - map(pos+0.3*sundir))/0.6, 0.0, 1.0 );
         vec3  lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0,0.6,0.3)*dif;
         vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );
         col.xyz *= lin;
         col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.005*t*t) );
         col.w *= 0.4;
         
         col.rgb *= col.a;
         sum += col*(1.0-sum.a);
       }\
       t += max(0.05,0.01*t);\
    }

    return clamp( sum, 0.0, 1.0 );
}

// Function 2356
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ) +
                      e.yyx*map( pos + e.yyx ) +
                      e.yxy*map( pos + e.yxy ) +
                      e.xxx*map( pos + e.xxx ) );
}

// Function 2357
float RaycastShadow( const in vec3 vOrigin, const in vec3 vDir, const in float k )
{
	float fShadow = 1.0;
	float t = 0.01;
	float fDelta = 1.0 / float(kShadowIter);
	for(int i=0; i<kShadowIter; i++)
	{
		float d = GetDistanceShadowCasters(vOrigin + vDir * t).x;
		
		fShadow = min( fShadow, k * d / t );
		
		t = t + fDelta;
	}
	
	return clamp(fShadow, 0.0, 1.0);
}

// Function 2358
float raysSDF(vec2 st, int N) { // 30
    st -= .5;
    return fract(atan(st.y, st.x) / TAU * float(N));
}

// Function 2359
vec3 raySphereIntersection(in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere)
{
    vec3 oc = rayOrigin - sphere.xyz;
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - sphere.w * sphere.w;
    float discriminant = b * b - 4.0 * c;
    if(discriminant < 0.0)
    {
        return vec3(-1);
    }
    else
    {
        float t = (-b - sqrt(discriminant)) / (2.0);
        vec3 endpoint = rayDir * t + rayOrigin;
        if(endpoint.y < rayOrigin.y) return vec3(-1);
        return endpoint;
    }
}

// Function 2360
vec3 normal(vec3 p){
    vec2 e = vec2(0,DELTA);
    
    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),
                map(p+e.xyx)-map(p-e.xyx),
                map(p+e.xxy)-map(p-e.xxy))); 
}

// Function 2361
float RayMarch(vec3 ro, vec3 rd) {
	float dO = 0.;
    
    for(int i = 0; i < MAX_STEPS; i++) {
    	vec3 p = ro + rd * dO;
        float dS = GetDist(p);
        dO += abs(dS);
        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;
    }
    
    return dO;
}

// Function 2362
float RayleighScattering( float cos_theta ) { return 0.75 * ( 1.0 + cos_theta * cos_theta ); }

// Function 2363
vec3 refraction(vec3 v, vec3 normal, float n1, float n2) {
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3 tang = normalize(v - cosA * normal);
    float sinB = sinA / n2 * n1;
    if (sinB > 1.0) return reflect(v, normal);
    float cosB = sqrt(1.0 - sinB * sinB);
    return sinB * tang + cosB * normal;
}

// Function 2364
RayHit BuildRayHit(in Ray ray, in vec4 hitInfo)
{
	RayHit hit;
    
    vec3  hitSurfNorm  = UnpackNorm(hitInfo.r);    
    vec3  hitSceneInfo = UnpackR8G8B8(hitInfo.g);  // .r = 2D heightmap value, .g = shadow value, .b = steepness
    float hitDepth     = hitInfo.b;
    
    hit.hit       = (hitInfo.a > Epsilon ? true : false);
    hit.surfPos   = ray.origin + (ray.direction * hitDepth);
    hit.surfNorm  = hitSurfNorm;
    hit.heightmap = hitSceneInfo.r;
    hit.shadow    = hitSceneInfo.g;
    hit.steepness = (hitSceneInfo.b * 2.0) - 1.0;
    
    return hit;
}

// Function 2365
vec4 RayMarcher(in vec2 fragCoord)
{
    vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1
	p.x *= iResolution.x / iResolution.y; // Correct aspect ratio
    
    vec2 mo = iMouse.xy/iResolution.xy;
		 
	float time = 15.0 + iTime;

    //BackGround
    vec3 col = background;
    
    
	// camera	
	vec3 cameraOrigin 	= vec3( 0.0+mo.x*0.5, 4.0+mo.y, 4.0 ); //camera origin
	vec3 cameraTarget 	= vec3( 0.0, 0.0, 0.0 ); //Camera target
    vec3 upDirection 	= vec3(	0.0, -1.0, 0.0 );
	
	// camera-to-world transformation
    mat3 ca = setCamera(cameraOrigin, cameraTarget, upDirection );
    
    vec3 rayDir = normalize(ca[0] * p.x + ca[1] * p.y +ca[2]);
    
    render(col, rayDir, cameraOrigin);
    
    return vec4( col, 1.0 );
    
}

// Function 2366
vec3 get_normals(vec3 p)
{
    float x1 = scene_d(p-vec3(EPSILON,0,0));
    float x2 = scene_d(p+vec3(EPSILON,0,0));
    float y1 = scene_d(p-vec3(0,EPSILON,0));
    float y2 = scene_d(p+vec3(0,EPSILON,0));
    float z1 = scene_d(p-vec3(0,0,EPSILON));
    float z2 = scene_d(p+vec3(0,0,EPSILON));

    return normalize(vec3(x2-x1,y2-y1,z2-z1)/(2.*EPSILON));
}

// Function 2367
vec2 texCoordFromNormal(in vec3 n) {
	vec2 c = n.xy * abs(n.z) + n.xz * abs(n.y) + n.yz * abs(n.x);
    return c * 0.5 + 0.5;
//    c.x = mix(n.x, n.y, abs(n.y) - abs(n.x));
 //   c.y = mix(n.y, n.z, abs(n.z) - abs(n.y));
 //   return c * 0.5 + 0.5;
}

// Function 2368
void ray(inout vec3 cp, vec3 rd, out float st, out float cd)
{
    st = 0.;
    cd = 0.;
    for(; st < 1.;  st += 1./64.)
    {
        cd = map(cp);
        if(cd < .01 || cd > INF)
        {
            break;
        }
        cp += rd * cd * .5;
    }
}

// Function 2369
vec3 raycast (vec3 ro, vec3 rd, vec2 p)
{
    float t = sphere(ro,rd);
    if (t > 0.0)
    {
    	vec3 d = ro+rd*t;
        p=vec2(acos(d.y/length(d)), atan(d.z,d.x));  
        return (atlas(p).xyz+grid(p*3.0));        
    } 
    return 1.7-vec3(length(p));;
}

// Function 2370
float dsqPointRay(vec3 a, vec3 p, vec3 nv) {
	float tMinA = max(0.0, minPointLine(p, nv, a));
    return dsq( a, p + tMinA*nv );
}

// Function 2371
float RayMarch(vec3 ro, vec3 rd){
    // distance from origin
    float dO=0.;
    // march until max steps is achieved or object hit
    for(int i=0; i <MAX_STEPS; i++){
        // current point being evaluated
        vec3 p = ro + dO*rd;
        
        // get distance to seam
        float ds = GetDist(p);
        //move origin to new point
        dO+=ds*.7;
        if(ds < SURFACE_DIST || dO > MAX_DIST){
            break;
        }
    }
    return dO;
}

// Function 2372
vec3 calcNormal(vec3 p) {
	float eps = 0.0001;
	const vec3 v1 = vec3( 1.0,-1.0,-1.0);
	const vec3 v2 = vec3(-1.0,-1.0, 1.0);
	const vec3 v3 = vec3(-1.0, 1.0,-1.0);
	const vec3 v4 = vec3( 1.0, 1.0, 1.0);
	return normalize( v1 * map( p + v1*eps ) +
					  v2 * map( p + v2*eps ) +
					  v3 * map( p + v3*eps ) +
					  v4 * map( p + v4*eps ) );
}

// Function 2373
vec3 getNormal(vec3 p)
{
	float h = 0.0001;
	return normalize(vec3(
		distanceField(p + vec3(h, 0, 0)) - distanceField(p - vec3(h, 0, 0)),
		distanceField(p + vec3(0, h, 0)) - distanceField(p - vec3(0, h, 0)),
		distanceField(p + vec3(0, 0, h)) - distanceField(p - vec3(0, 0, h))));
}

// Function 2374
vec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {
    float t = tmin;
    vec3 res = vec3(-1.0);
    float breakOut = 0.0;
    int i = 0;
    while (i < 10 && breakOut != 1.0) {
        vec3 p = ro + rd * t;
        res = vec3(map(p), t);
        float d = res.y;
        if (d < (0.001 * t) || t > tmax)
            breakOut = 1.0;
        t += 0.5 * d;
        i++;
    }
    return res;
}

// Function 2375
vec4 Raycast( const in vec3 vOrigin, const in vec3 vDir )
{
	float fClosest = kFarClip;
	vec2 d = vec2(0.0);
	float t = 0.01;
	for(int i=0; i<kRaymarchIterations; i++)
	{
		d = GetSceneDistance(vOrigin + vDir * t);
		fClosest = min(fClosest, d.x / t);
		if(abs(d.x) < 0.0001)
		{
			break;
		}
		t += d.x;
		if(t > kFarClip)
		{
			t = kFarClip;
			break;
		}
	}
	
	return vec4(t, d.x, d.y, fClosest);
}

// Function 2376
vec3 raymarchScattering(vec3 pos, 
                              vec3 rayDir, 
                              vec3 sunDir,
                              float tMax,
                              float numSteps) {
    float cosTheta = dot(rayDir, sunDir);
    
	float miePhaseValue = getMiePhase(cosTheta);
	float rayleighPhaseValue = getRayleighPhase(-cosTheta);
    
    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;
    for (float i = 0.0; i < numSteps; i += 1.0) {
        float newT = ((i + 0.3)/numSteps)*tMax;
        float dt = newT - t;
        t = newT;
        
        vec3 newPos = pos + t*rayDir;
        
        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);
        
        vec3 sampleTransmittance = exp(-dt*extinction);

        vec3 sunTransmittance = getValFromTLUT(iChannel0, iChannelResolution[0].xy, newPos, sunDir);
        vec3 psiMS = getValFromMultiScattLUT(iChannel1, iChannelResolution[1].xy, newPos, sunDir);
        
        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
        vec3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral*transmittance;
        
        transmittance *= sampleTransmittance;
    }
    return lum;
}

// Function 2377
vec3 Ray_at_t(Ray r, float t) { return r.o + t * r.d; }

// Function 2378
vec3 castRayTerrain2(vec3 camPos, vec3 camDir){
    for(float i=1.; i<12.; i+=.01){
    	vec3 p = camPos + i*camDir;
        
        if (p.y <0.) break;
        if(pointTerrain(p)){
            vec3 col = vec3(p.xz, terrain(p.xz));
            vec3 normal = calculate_normal(p);
            
            float lightDist = 9.;
            float lightHeight = 5.;
            vec3 light_position = vec3(lightDist*cos(-iTime), lightHeight, lightDist*sin(-iTime));
            light_position = camPos + vec3(-5.,0.,1.);
            
            vec3 direction_to_light = normalize(p - light_position);
            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));
            
            vec3 color=vec3(1,0,0);
            float temp = p.y;
            p.y/=3.5;
            if(p.y<0.18) color = vec3(0.2,0.2 + 0.8 *p.y*p.y*30.,1)*(p.y*3.+.4);
            else if(p.y<0.22) color = vec3(246./255.,215./255.,150./255.)*(1.-p.y)*1.5;
            else if(p.y<0.3) color = vec3(11./255.,102./255.,35./255.);
            else if(p.y<0.33) color = vec3(139./255.,69./255.,19./255.);
            else color = vec3(1.);
                
            vec3 eye = normalize(vec3(p.x, terrain(p.xz), p.z)-camPos);
            vec3 reflec = 2.*normal*dot(normal, direction_to_light)-direction_to_light;
            float spec = dot(eye, reflec);
            spec = pow(spec, 5.);
            //spec*=0.2;
            //spec *= water(p.xz)*300.;
            spec=0.;
            
            color  = 1. * terrain(p.xz) * vec3(.8, .5, .2);
            color = fbm(p.xz*0.2)*vec3(34./255., 139./255., 34./255.);
            //color = mix(color, vec3(1.), 0.5*max(0.,));
            
            if(normal.y>-0.91) color = mix(color, vec3(139./255.,69./255.,19./255.)*0.4, -normal.y*0.8);
            //color = mix(color, vec3(114./255., 98./255., 91./255.), terrain(p.xz)*0.9);
            color = mix(color, vec3(130./255., 100./255., 80./255.), terrain(p.xz)*0.9);
            
            if(dot(normal, -vec3(0,1,0))>0.99) color = vec3(1.)*0.6;
            if(water(p.xz)>0.0002) color = vec3(1.)*0.6;//vec3(139./255.,69./255.,19./255.)*0.4;
            
            
            
            
            
            //spec *= length(color)*length(color)*0.2;
            diffuse_intensity *=2.;
            return color*0.1 + color*diffuse_intensity + vec3(1.)*spec;
        }
    }
    return vec3(1.);
}

// Function 2379
vec3 normalAt(in vec3 ro) {
    vec2 ep = vec2(EPSILON, 0.0);
    return normalize(vec3(map(ro + ep.xyy) - map(ro - ep.xyy),
                          map(ro + ep.yxy) - map(ro - ep.yxy),
                          map(ro + ep.yyx) - map(ro - ep.yyx)));
}

// Function 2380
RayTraceSceneResult RayTraceScene(in Ray ray, bool bIgnoreDummyLight)
{
    const int nbObj = 3 + cylinderCount;
    RayTraceResult obj[nbObj];
    
    obj[0] = RayTraceHoledSphereDoubleSize(ray);
    obj[1] = RayTraceRoom(ray);
    obj[2] = RayTraceSphere(ray, lightPos, .3);
    
    if (bIgnoreDummyLight)
    {
        obj[2].t = infinite;
    }
    
    for (int c = 0; c < cylinderCount; ++c)
    {
    	obj[c+3] =  RayTraceCylinder(ray, cylinderData[c].xyz, cylinderRadius, cylinderData[c].w);
    }
    
    float minT = infinite;
   	RayTraceSceneResult res; res.emissive = vec3(0.); res.color = vec3(0.);
    int hitI = 0;
    for (int i = 0; i < nbObj; ++i)
    {
        if (minT > obj[i].t)
        {
           	res.hit = obj[i];
            minT = obj[i].t;
            hitI = 0;
        }
    }
    
    if (hitI == 2) //Dummy light
    {
        res.emissive = (ComputeLightPattern(normalize(lightPos - obj[2].pos)) + 0.2);
        res.emissive *= 64.0;
    }
    else
    {
        res.color = colorWhite;
    }
    
    return res;
}

// Function 2381
vec3 castRay( vec3 emitterP, vec3 rayV )
{
	float t = 0.0;
	vec3 rayP = emitterP;

	for(int i=0;i<CASTITERATIONS;i++)
	{
        	float h = getSphereDistance(rayP, SPHERERADIUS);
        	if( h<CASTDELTA )
			break;
		if( h>CASTDISTANCE )
			return emitterP + rayV*CASTDISTANCE; 
		rayP += rayV*h;
	}
	return rayP;
}

// Function 2382
vec2 CastRay(vec3 ro, vec3 rd)
{
    float t = 0.0;
    
    for(int i=0 ; i<64 ; i++)
    {
        vec2 ray = map(ro + rd * t);
        
        if(ray.x < (0.0001*t))
        {
            return vec2(float(i)/64., ray.y);
        }
        
        t += ray.x;
    }
    
    return vec2(-1.0, 0.0);
}

// Function 2383
vec3 calcNormal(vec3 pos){
    vec3 eps = vec3(.001,0,0);
    vec3 nor = vec3(
        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,
        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,
        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );
    return normalize(nor);
}

// Function 2384
Ray rayRefract(Hit h, float rr) {
  vec3 r = refract(h.ray.dir, h.nml, (h.ray.sgn>0.)?(1./rr):rr);
  if (len2(r)<.001) return ray(h.pos+h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col, h.ray.sgn);
  return ray(h.pos - h.nml*.01, r, h.ray.col*((h.ray.sgn>0.)?h.srf.tc:vec3(1)), -h.ray.sgn);
}

// Function 2385
void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)
{
	vec3 vForwards = normalize(vInterest - vPos);
	vec3 vUp = vec3(0.0, 1.0, 0.0);

	GetCameraRay(vPos, vForwards, vUp, ray);
}

// Function 2386
vec3 getRayDirection(vec2 fragCoord, vec3 cameraDirection) {
    vec2 uv = fragCoord.xy / iResolution.xy;
	
    const float screenWidth = 1.0;
    float originToScreen = screenWidth / 2.0 / tan(FIELD_OF_VIEW / 2.0);
    
    vec3 screenCenter = originToScreen * cameraDirection;
    vec3 baseX = normalize(cross(screenCenter, vec3(0, -1.0, 0)));
    vec3 baseY = normalize(cross(screenCenter, baseX));
    
    return normalize(screenCenter + (uv.x - 0.5) * baseX + (uv.y - 0.5) * iResolution.y / iResolution.x * baseY);
}

// Function 2387
vec3 getNormal(vec3 p)
{
    vec2 e = vec2(0.01, 0);
    float d = map(p);
    
    vec3 n = d - vec3(
        map(p - e.xyy),
        map(p - e.yxy),
        map(p - e.yyx));
    return normalize(n);
}

// Function 2388
vec3 GetNormal(vec3 p)
{
	float d = GetDst(p);
    vec2 e = vec2(0.01, 0);
    
    vec3 normal = d - vec3(
        GetDst(p - e.xyy),
        GetDst(p - e.yxy),
        GetDst(p - e.yyx));
    
    return normalize(normal);
}

// Function 2389
vec3 calcNormal( in vec3 p )
{
	const vec2 e = vec2( 0.0001, 0.0 );
	vec3 n = vec3(
		map( p + e.xyy ) - map( p - e.xyy ),
		map( p + e.yxy ) - map( p - e.yxy ),
		map( p + e.yyx ) - map( p - e.yyx ) );
	return normalize( n );    
}

// Function 2390
float raycast(in vec3 ro, in vec3 rd)
{
	float t = 1.0;
    for (int i = 0; i < ITERS; ++i)
    {
        float d = scene_dist(ro + rd * t);
        if (d < THRESHOLD || d > MAX_T)
        {
            break;
        }
        t += d;
    }
    
    return t;    
}

// Function 2391
vec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {
		
		float depth = start;
		vec3 salida = vec3(end);
		vec3 dist = vec3(0.1);
		
		for ( int i = 0; i < max_iterations; i++ ) 		{
			if ( dist.x < stop_threshold || depth > end ) break;
                dist = map( origin + dir * depth );
                depth += dist.x;
		}
		
		salida = vec3(depth, dist.y, dist.z);
		return salida;
	}

// Function 2392
vec3 estimateNormal( const int scene, const float h, in vec3 p )
{
    int m;
    
    const vec2 k = vec2(1,-1);
    return normalize( k.xyy*sceneSDF( scene, p + k.xyy*h, m ) + 
                      k.yyx*sceneSDF( scene, p + k.yyx*h, m ) + 
                      k.yxy*sceneSDF( scene, p + k.yxy*h, m ) + 
                      k.xxx*sceneSDF( scene, p + k.xxx*h, m ) );
}

// Function 2393
vec3 sdfNormal(vec3 p, float epsilon, float d, bool detail)
{
    vec3 normal = vec3(0.0);

    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, detail) - d;
    }
    
    return normalize(normal);
}

// Function 2394
void raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)
{
    eye = EYE_POS;
    ref = REF_POS;
    
    float len = tan(3.14159 * 0.125) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * float(iResolution.x) / float(iResolution.y);
    vec3 p = ref + uv.x * H + uv.y * V;
    dir = normalize(p - eye);
}

// Function 2395
bool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {
    bool hitResult = false;
    float t;
    SurfaceHitInfo currentHit;

    //Convert ray to object space
    Ray rayLocal;
    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );

    if( obj.type_ == OBJ_PLANE ) {
        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], t, currentHit );
    } else if( obj.type_ == OBJ_SPHERE ) {
        hitResult = raySphereIntersection( 	rayLocal, obj.params_[1], t, currentHit );
    } else if( obj.type_ == OBJ_CYLINDER ) {
        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], t, currentHit );
    } else if( obj.type_ == OBJ_AABB ) {
        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], t, currentHit );
    } else if( obj.type_ == OBJ_BUNNY ) {
        hitResult = rayBunnyIntersection( rayLocal, forShadowTest, t, currentHit );
    }

    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {
        //Convert results to world space
        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );

        dist = t;
        hit = currentHit;
        hit.mtl_id_ = obj.mtl_id_;
        
        return true;
    } else {
    	return false;
    }
}

// Function 2396
vec3 computeNormal(in vec3 iPoint) {
    
    return normalize(vec3(
        sceneSDF(vec3(iPoint.x + EPSILON, iPoint.y, iPoint.z)) - sceneSDF(vec3(iPoint.x - EPSILON, iPoint.y, iPoint.z)),
        sceneSDF(vec3(iPoint.x, iPoint.y + EPSILON, iPoint.z)) - sceneSDF(vec3(iPoint.x, iPoint.y - EPSILON, iPoint.z)),
        sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z  + EPSILON)) - sceneSDF(vec3(iPoint.x, iPoint.y, iPoint.z - EPSILON))
    ));
    
}

// Function 2397
vec3 getNormal(in vec3 p, float t) {
	
    const vec2 e = vec2(.001, 0);
    
    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),	
    //                      m(p + e.yyx) - m(p - e.yyx)));
    
    // This mess is an attempt to speed up compiler time by contriving a break... It's 
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.;
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = min(iFrame, 0); i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break; // Fake conditional break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 2398
vec2 RaySphereIntersection (in Ray ray, in Sphere sphere)
{
  vec3  h = ray.origin - sphere.center;
  float b = dot(ray.direction, h);
  float c = dot(h,h) - sqr (sphere.radius);
  float d = b*b - c;
  if (d < 0.0) return vec2(-1.0);
  d = sqrt(d);
  return vec2 (-d-b, d-b);
}

// Function 2399
ray_t get_primary_ray(
	in vec3 cam_local_point,
	inout vec3 cam_origin,
	inout vec3 cam_look_at)
{
	vec3 fwd = normalize(cam_look_at - cam_origin);
	vec3 up = vec3(0, 1, 0);
	vec3 right = cross(up, fwd);
	up = cross(fwd, right);

    ray_t r;
    r.origin = cam_origin;
    r.direction = normalize(fwd + up * cam_local_point.y - right * cam_local_point.x);
	return r;
}

// Function 2400
float FlyerRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    d = FlyerDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0005 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2401
vec3 raymarch(vec3 pathdir, vec3 pathorig){
    vec3 pathpos = pathorig;
    pathpos += pathdir*6.0;
    vec3 surfnormal;
    float distest, lightdistest;
    int bounces = 0;
    int object = 0;
    vec3 closestpos = pathpos;
    vec3 outCol = vec3(1.0);
    for(int i = 0; i < maxmarches; i++){
        // Check if the path is done
        if(length(pathpos) > scenesize || pathpos.z < -4.0 || bounces > maxbounces){break;}
        if(light(pathpos) < collisiondist){return outCol*vec3(1.0);}

        // Find the distance to the scene
        distest = DE(pathpos);
        lightdistest = light(pathpos);

        // Michael0884: Closest Non-Colliding Position
        if(distest > min(collisiondist, lightdistest)){closestpos = pathpos;}

        // Bounce the Path if it hits something
        if(distest < collisiondist){
            int object = getmat(pathpos);
            vec4 matprops = materialproperties(pathpos, object);
            outCol *= matprops.rgb;
            surfnormal = normal(pathpos);
            pathpos = closestpos;
            pathdir = reflect(pathdir, normalize(nrand3(matprops.w, surfnormal)));
            bounces++;
        }

        // Otherwise just keep going
        else{pathpos += pathdir*min(distest, lightdistest);}
    }
    return vec3(0.0);
}

// Function 2402
vec3 getNormal(vec3 p)
{
    const float eps = 0.02;
    vec3 n = vec3(
        f(p.x - eps, p.z) - f(p.x + eps, p.z),
        2.0 * eps,
        f(p.x, p.z - eps) - f(p.x, p.z + eps));
    return normalize(n);  
}

// Function 2403
vec3 reflection(vec3 pos, vec3 ref, vec3 lightPos)
{
    pos += ref * MIN_DST * 4.0;
    
    vec2 d = castRay(pos, ref, MAX_DST, MIN_DST);
    
    vec3 nPos = pos + ref * d.x;

    float hAtten = sat((5.0 - nPos.y) / 3.0);
    
    if (d.x > MAX_DST)
    {
        return fogColor * hAtten; 
    }
    else   
    {
   
        vec3 col = MatColor(d.y, nPos).rgb;// * atten;
      	  
      	vec3 pointDir = lightPos - nPos;
        float len = length(pointDir);
        
                
        vec3 n = calcNormal(nPos);
        
        float atten = sat(1.0 - len / 20.0);
        
        atten *= shadow(nPos, n, lightPos);
        
        pointDir /= len;
        
        float diffuse = sat(dot(n, pointDir));
        
        col *= (diffuse * (atten * atten) * hAtten);
        
        return col;
    }
}

// Function 2404
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 200; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.5, 0.5 * h);
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > GrndHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 2405
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 120; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 2406
vec3 dNormal(vec3 p)
{
   const vec2 e = vec2(.005,0);
   return normalize(vec3(
      fField(p + e.xyy) - fField(p - e.xyy),
      fField(p + e.yxy) - fField(p - e.yxy),
      fField(p + e.yyx) - fField(p - e.yyx) ));
}

// Function 2407
float CastRay( in vec3 ro, in vec3 rd )
{
    const float maxd = 10.0;
    
	float h = 1.0;
    float t = 0.0;
   
    for ( int i = 0; i < 50; ++i )
    {
        if ( h < 0.001 || t > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t );
        t += h;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }
	
    return t;
}

// Function 2408
void normal(in vec3 x, out vec3 n)
{
    const float dx = 5.e-4;
    vec2 s, na;
    
    scene(x,s);
    scene(x+dx*c.xyy, na);
    n.x = na.x;
    scene(x+dx*c.yxy, na);
    n.y = na.x;
    scene(x+dx*c.yyx, na);
    n.z = na.x;
    n = normalize(n-s.x);
}

// Function 2409
vec3 calcNormal( in vec3 pos )
{
    const vec2 e = vec2(1.0,-1.0)*0.003;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 2410
vec3 sampleReflectionMap(vec3 p, float b) {
    vec3 col = textureLod(reflectTex, p, b).rgb;
    
    // fake HDR
    //col *= 1.0 + 1.0 * smoothstep(0.5, 1.0, dot(LUMA, col));
    
    return col;
}

// Function 2411
vec3 normalHigh(vec3 x) {
	const vec2 eps = vec2(0.1, 0.0);
	float h = sceneHigh(x);
	return normalize(vec3(
		(sceneHigh(x+eps.xyy)-h),
		(sceneHigh(x+eps.yxy)-h),
		(sceneHigh(x+eps.yyx)-h)
	));
}

// Function 2412
vec4 findnormal(vec4 p) {
    vec2 eps = vec2(0.01,0.0);
    
    return normalize(vec4(
        map(p+eps.xyyy)-map(p-eps.xyyy),
        map(p+eps.yxyy)-map(p-eps.yxyy),
        map(p+eps.yyxy)-map(p-eps.yyxy),
        map(p+eps.yyyx)-map(p-eps.yyyx)));
}

// Function 2413
float rayMarching(vec3 eye, vec3 dir) {
    float full_dist = MIN_DIST;
    
    for (int i = 0; i < MARCH_STEPS; i++) {
        float current_dist = sceneSDF(eye + dir * full_dist);
        
        if (current_dist < EPSILON) {
            return full_dist;
        }
        
        full_dist += current_dist;
        if (full_dist >= MAX_DIST) {
            return MAX_DIST;
        }
    }
    
     return MAX_DIST;
}

// Function 2414
vec3 normal(vec3 p)
{
    vec2 e = vec2(.001,0);
    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);
    return normalize(n);
}

// Function 2415
vec3 getNormal(CastRes res)
{
	CastRes r = res, l = res;
	#define DELTA 0.02
	vec2 t = vec2(DELTA, 0);
	vec3 d;
	l.pos = res.pos + t.xyy;
	r.pos = res.pos - t.xyy;
	d.x = DistFunc(l).dist - DistFunc(r).dist;
	
	l.pos = res.pos + t.yxy;
	r.pos = res.pos - t.yxy;
	d.y = DistFunc(l).dist - DistFunc(r).dist;

	l.pos = res.pos + t.yyx;
	r.pos = res.pos - t.yyx;
	d.z = DistFunc(l).dist - DistFunc(r).dist;	
	
	return normalize( d );
}

// Function 2416
vec4 castRay(in vec3 ro, in vec3 rd, in float texelRadius)
{
    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;
    vec2  res = vec2(kFarPlaneDist, 0);
	int   i   = kMaxSteps;
    for (; (i >= 0) && (t < kFarPlaneDist); --i)
    {
        res = mapScene(ro + rd * t);
        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);
        if (sor)
        {
            stepLength-= k * stepLength;
            k = 1.;            
        }        
        else
            stepLength = res.x * k;

        prevRad = res.x;
        err = res.x / t;
        if (!sor)
        {
            if (err < prevErr    ) { res.x = t; prevErr = err; }
            if (err < texelRadius) break;
        }
        t  += stepLength;
    }
    return vec4(t, res.xy, kMaxSteps - i);
}

// Function 2417
vec3 SampleRay(Ray ray, float t)
{
    return ray.origin + ray.direction * t;
}

// Function 2418
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3(surface*0.5,0.0,0.0);
	vec3 nor;
	float f = map(pos-eps.xyy).x;
	nor.x = map(pos+eps.xyy).x - f;
	nor.y = map(pos+eps.yxy).x - f;
	nor.z = map(pos+eps.yyx).x - f;
	return normalize(nor);
}

// Function 2419
vec3 quadric_normal(vec4 quadric, vec3 p) {
	float A = quadric.x; float B = quadric.y; float C = quadric.z;
    return normalize(vec3(A,B,C)*p);
}

// Function 2420
vec3 heightFieldNormal(vec2 p)
{
    vec2 eps=vec2(1e-1,0.0);
    float bumpScale=10.0;
    float c=heightField(p);
    float d0=(heightField(p+eps.xy))-c;
    float d1=(heightField(p+eps.yx))-c;
    vec3 n0 = normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));
    vec3 bn = bumpNormal(p);
    return normalize(n0+(bn-n0*dot(n0,bn))*0.2);
}

// Function 2421
float FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)
{
    #if DO_FRESNEL
        // Schlick aproximation
        float r0 = (n1-n2) / (n1+n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        if (n1 > n2)
        {
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            // Total internal reflection
            if (sinT2 > 1.0)
                return 1.0;
            cosX = sqrt(1.0-sinT2);
        }
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;

        // adjust reflect multiplier for object reflectivity
        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);
        return ret;
    #else
    	return OBJECT_REFLECTIVITY;
    #endif
}

// Function 2422
vec3 IdealSpecularReflect(vec3 d, vec3 n) {
	return reflect(d, n);
}

// Function 2423
vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {
    vec3 f = normalize(l-p),
        r = normalize(cross(vec3(0,1,0), f)),
        u = cross(f,r),
        c = f*z,
        i = c + uv.x*r + uv.y*u,
        d = normalize(i);
    return d;
}

// Function 2424
vec3 normal(vec3 p) {
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ ) {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*sdScene(p+0.0005*e);
    }
    return normalize(n);
}

// Function 2425
vec3 calc_normal(vec3 sample_point) {
    const float h = NORMAL_SAMPLE_SIZE; // replace by an appropriate value
    const vec2 k = vec2(1,-1);
    
    vec3 normal = normalize(
		k.xyy * map( sample_point + k.xyy*h ) + 
		k.yyx * map( sample_point + k.yyx*h ) + 
		k.yxy * map( sample_point + k.yxy*h ) + 
		k.xxx * map( sample_point + k.xxx*h ) );
    normal = normal.zyx;
    return normal;
}

// Function 2426
vec3 estimator_normals (in Ray r, in Scene s)
{
    Isect_data data;
    float t = intersect(r, 0.0, INF, data, s);
    
    /* return black if no intersection */
    if(!(t<INF)) return vec3(0);
    
    
    /* ---- return the normal if there is an intersection ---- */
    
    /* correct normal is in the oppoiste hemisphere of the incident ray */
    vec3 n = -data.n * sign(dot(data.n, r.d));

    /* map from S^2 to [0,1]^3 */
    return 0.5*n+vec3(0.5);
}

// Function 2427
vec4 raymarche( in vec3 org, in vec3 dir, in vec2 nfplane )
{
	float d = 1.0, g = 0.0, t = 0.0;
	vec3 p = org+dir*nfplane.x;
	
	for(int i=0; i<42; i++)
	{
		if( d > 0.001 && t < nfplane.y )
		{
			d = map(p);
			t += d;
			p += d * dir;
			g += 1./42.;
		}
	}
	
	return vec4(p,g);
}

// Function 2428
vec3 calcCylinderNormal(vec3 a, vec3 b, vec3 c) {
    vec3 tangent = a - c;
    vec3 binormal = cross(a - b, c - b);
    vec3 normal = normalize(cross(tangent, binormal));
    return normal;
}

// Function 2429
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.001, 0);
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    return normalize(n);
}

// Function 2430
vec2 ct_vfield_normal(
    in vec2 p,
    float npow
){
    vec2 g = vec2(0.0, 0.0);
    
    const int imax = CT_N;
    
    for (int i = 0; i < imax; ++i)
    {
        vec2 dif = g_vfp[i].p - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1];
        float mass = pow(sum, npow);
        
      	g[0] = g[0] + g_vfp[i].m * dif[0] / mass;
      	g[1] = g[1] + g_vfp[i].m * dif[1] / mass;
        
        
    }
    
    return normalize(g);
}

// Function 2431
Ray createRay(vec3 o, vec3 d)
{
    Ray r;
    r.o = o;
    r.d = d;
    return r;
}

// Function 2432
vec4 castRay( in vec3 ro, in vec3 rd, in int num )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;
	
	vec4 res = vec4( -1.0, 0.0, 0.0, 0.0 );
	
    // traverse regular grid (in 2D)
	for( int i=0; i<12; i++ ) 
	{
		if( i>num ) break;
		
        // intersect sphere
		vec3  rr = hash3(pos);
		vec2  oo = 0.5 + 0.3*(-1.0 + 2.0*rr.xy);
		vec3  ce = vec3( pos.x+oo.x, 0.5, pos.y+oo.y );
		float ra = (0.5+0.5*rr.z)*min( min(oo.x,1.0-oo.x), min(oo.y,1.0-oo.y) );
		vec3  rc = ro - ce;
		float b = dot( rd, rc );
		float c = dot( rc, rc ) - ra*ra;
		float h = b*b - c;
		if( h>0.0 )
		{
			float s = -b - sqrt(h);
			res = vec4( s, 0.0, pos );
			break;
		}

        // step to next cell		
		vec2 mm = step( dis.xy, dis.yx ); 
		dis += mm*ris;
        pos += mm*rs;
	}

	return res;
}

// Function 2433
void raytraceTreeline(vec3 u,vec3 d,vec4 a,inout vec3 color,inout float nearestD){ 
 float t=floor((u.x+d.x*(a.x-u.z)/d.z-a.z)/a.y)*a.y+a.y*.5+a.z;
 if(abs(t)>240.)return;
 raytraceTree(u,d,vec3(t,a.w,a.x),sin(t+a.x)*1.5,sin(t*.7+a.x)*4.,
              sin(t*.85+a.x),color,nearestD);}

// Function 2434
float SchlickReflectance(float n1, float n2, float c) {
	float R0 = Reflectance0(n1, n2);
	return R0 + (1.0f - R0) * c * c * c * c * c;
}

// Function 2435
RMResult raymarch(float time, vec3 ro, vec3 rd, out float t)
{
	t = 0.;
    vec3 p = ro + t * rd;
    RMResult s = map(p, time);
    float isInside = sign(s.dist);
    for(int i = 0; i < I_MAX; i++)
    {
        float inc = isInside * s.dist;
        if (min(abs(p.z - 3. * BOARD_UNIT), abs(p.z)) < 0.5 * BOARD_UNIT)
        {
            inc *= 0.7;         // dirty hack to fix domain discontinuity near z=0 and z=3*BOARD_UNIT plane 
            if (abs(p.x - 1.5 * BOARD_UNIT) < 0.5 * BOARD_UNIT)
                inc *= 0.6;     // fix annoying artefacts on the moving bishop that I couldn't remove otherwise
        }
        if (t + inc < FAR && abs(s.dist) > EPS) 
        {
			t += inc;
	        p = ro + t * rd;
            s = map(p, time);
        }
        else
        {
            if (t + inc > FAR)
            {
               s.id = -1.;
            }
            break;
        }
    }
    return s;
}

// Function 2436
Ray getCameraRay(vec2 uv)
{
    vec3 origin = cameraPosition;
    vec3 target = vec3(0., 1., 0.);
    mat3 camera = getCameraMatrix(origin, target);
    vec3 direction = normalize(camera * vec3(uv, 2.5));
    return Ray(origin, direction);
}

// Function 2437
vec3 normal(vec3 p)
{
    vec3 n = vec3(0.0);
    for( int i=min(iFrame,0); i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(p+0.001*e);
    }
    return normalize(n);
    }

// Function 2438
vec3 normalHighDetailModel(vec3 P)
{
	vec2 eps = vec2(0.,0.001);
    return normalize(vec3(
        SD_HighDetailModel(P+eps.yxx).d - SD_HighDetailModel(P-eps.yxx).d, 
		SD_HighDetailModel(P+eps.xyx).d - SD_HighDetailModel(P-eps.xyx).d, 
        SD_HighDetailModel(P+eps.xxy).d - SD_HighDetailModel(P-eps.xxy).d));
}

// Function 2439
vec3 Scene_Normal(vec3 p)
{
    RayHit hit;
    
    float e = Epsilon;
    
	return clamp(normalize(vec3(
        (Scene_SDF(vec3(p.x + e, p.y, p.z), hit) - Scene_SDF(vec3(p.x - e, p.y, p.z), hit)),
        (Scene_SDF(vec3(p.x, p.y + e, p.z), hit) - Scene_SDF(vec3(p.x, p.y - e, p.z), hit)),
        (Scene_SDF(vec3(p.x, p.y, p.z + e), hit) - Scene_SDF(vec3(p.x, p.y, p.z - e), hit)))), -1.0, 1.0);
}

// Function 2440
float normalWeight(vec3 normal0, vec3 normal1) {
  const float exponent = 64.0;
  return pow(max(0.0, dot(normal0, normal1)), exponent);
}

// Function 2441
vec3 calcCylSideNormal(Cylinder cyl, float dist, vec3 orig, vec3 dir)
{
    vec3 pos = orig + dist * dir;
    vec3 normal = normalize(vec3(pos.x, 0.0, pos.z));
    return normal;
}

// Function 2442
vec3 calcNormal(in vec3 p, in bool tree, in bool landscape) {
    vec2 e = vec2(eps.x, -eps.x); 
    return normalize(e.xyy * map0(p + e.xyy, tree, landscape) +
                     e.yyx * map0(p + e.yyx, tree, landscape) + 
                     e.yxy * map0(p + e.yxy, tree, landscape) + 
                     e.xxx * map0(p + e.xxx, tree, landscape));
}

// Function 2443
vec2 estimateNormal(vec2 p) 
{
    return normalize(vec2(
        map(vec2(p.x + EPSILON, p.y)) - map(vec2(p.x - EPSILON, p.y)),
        map(vec2(p.x, p.y + EPSILON)) - map(vec2(p.x, p.y - EPSILON))
    ));
}

// Function 2444
Ray transform_ray( mat4 m, Ray ray ) { return mkray( transform_point( m, ray.o ), transform_vector( m, ray.d ) ); }

// Function 2445
vec4 reflection(vec3 ro, vec3 rd) {
    
    vec2 box = iBox(ro-vec3(0,0.5,0),rd,vec3(4.0,0.5,4.0));
    ivec4 piece = tracebricks(ro,rd,box.x,box.y);

    if (box.y < box.x+0.01) {
       return textureLod(iChannel1,rd,0.0)*0.4;
    }
    
    return shadebrick(ro+rd*box.x, rd, piece);
}

// Function 2446
vec3 normal(vec2 pos, float e, float depth){
    vec2 ex = vec2(e, 0);
    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;
    vec3 a = vec3(pos.x, H, pos.y);
    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), 
                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));
}

// Function 2447
vec2 rayIntersectSphere( vec3 eye, vec3 dir, float r ) {
	float b = dot(eye, dir);
    float ac = dot(eye, eye) - r * r;
    float delta = b * b - ac;
    if(delta < 0.0)
        return vec2(MAX, -MAX);
    delta = sqrt(delta);
    return vec2(-b - delta, -b + delta);
}

// Function 2448
vec3 objectsNormal(vec3 p, float eps) {
    vec2 h = vec2(eps, 0);
    #define f artifactDist
    return normalize(vec3(f(p + h.xyy) - f(p - h.xyy),
                          f(p + h.yxy) - f(p - h.yxy),
                          f(p + h.yyx) - f(p - h.yyx)));
}

// Function 2449
vec2 castRay(vec3 ro, vec3 rd) {
  const float tmin = 0.2;
  const float tmax = 20.0;
  float t = tmin;
  float m;
  for (int i=0; i < 300; i++) {
    vec2 res = scene(ro + rd * t);
    if (res.x < 0.0001 || t > tmax) break;
    t += res.x;
    m = res.y;
  }
  if (t > tmax) m = -1.0;
  return vec2(t, m);
}

// Function 2450
vec3 texNormal(vec2 pos){
    if(abs(pos.x-0.5)>=0.25||abs(pos.y-0.5)>=0.25){
        if(abs(pos.x-0.5)<=0.5&&abs(pos.y-0.5)<=0.5){
            vec3 leftdown=(pos.x>pos.y)?vec3(0,1,1):vec3(1,0,1);
            vec3 rightup=(pos.x>pos.y)?vec3(-1,0,1):vec3(0,-1,1);
            return normalize((pos.x+pos.y>=1.)?rightup:leftdown);
        }
    }
    float dsquare=(pos.x-0.5)*(pos.x-0.5)+(pos.y-0.5)*(pos.y-0.5);
    if(dsquare<=1./16.){
        return normalize(vec3(pos.x-0.5,pos.y-0.5,sqrt(1./16.-dsquare)));
    }
	return vec3(0,0,1);
}

// Function 2451
vec3 getNormal(in vec3 pos) {
	vec3 e = vec3(0.0,normalDistance,0.0);
	
	return normalize(vec3(
			DE(pos+e.yxx)-DE(pos-e.yxx),
			DE(pos+e.xyx)-DE(pos-e.xyx),
			DE(pos+e.xxy)-DE(pos-e.xxy)
			)
		);
}

// Function 2452
vec3 raymarch_o349467(vec2 uv) {
    uv-=0.5;
	vec3 cam=vec3((sin(sin(iTime*0.2)*0.5+0.5)*4.0),p_o349467_CamY,(sin(sin(iTime*0.3)*0.5+0.5)*4.0))*p_o349467_CamZoom;
	vec3 lookat=vec3(p_o349467_LookAtX,p_o349467_LookAtY,p_o349467_LookAtZ);
	vec3 ray=normalize(lookat-cam);
	vec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));
	vec3 cY=normalize(cross(cX,ray));
	vec3 rd = normalize(ray*p_o349467_CamD+cX*uv.x+cY*uv.y);
	vec3 ro = cam;
	
	float d=0.;
	vec3 p=vec3(0);
	vec2 dS=vec2(0);
	march_o349467(d,p,dS,ro,rd);
	
    vec3 color=vec3(0.0);
	vec3 objColor=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));
	vec3 light=normalize(vec3(p_o349467_SunX,p_o349467_SunY,p_o349467_SunZ));
	if (d<50.0) {
	    vec3 n=normal_o349467(p);
		float l=clamp(dot(-light,-n),0.0,1.0);
		vec3 ref=normalize(reflect(rd,-n));
		float r=clamp(dot(ref,light),0.0,1.0);
		float cAO=mix(1.0,calcAO_o349467(p,n),p_o349467_AmbOcclusion);
		float shadow=mix(1.0,calcSoftshadow_o349467(p,light,0.05,5.0),p_o349467_Shadow);
		color=min(vec3(max(shadow,p_o349467_AmbLight)),max(l,p_o349467_AmbLight))*max(cAO,p_o349467_AmbLight)*objColor+pow(r,p_o349467_Pow)*p_o349467_Specular;
		//reflection
		d=0.01;
		march_o349467(d,p,dS,p,ref);
		vec3 objColorRef=vec3(0);
		if (d<50.0) {
			objColorRef=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));
			n=normal_o349467(p);
			l=clamp(dot(-light,-n),0.0,1.0);
			objColorRef=max(l,p_o349467_AmbLight)*objColorRef;
		} else {
			objColorRef=o349467_input_hdri(equirectangularMap(ref.xzy)).xyz;
		}
		color=mix(color,objColorRef,p_o349467_Reflection);
	} else {
		color=o349467_input_hdri(equirectangularMap(rd.xzy)).xyz;
	}
	return color;
}

// Function 2453
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 vri, vf, hv, p;
  vec2 edN[3], pM, gIdP;
  float dHit, d, s;
  edN[0] = vec2 (1., 0.);
  edN[1] = 0.5 * vec2 (1., sqrt3);
  edN[2] = 0.5 * vec2 (1., - sqrt3);
  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));
  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));
  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),
     dot (ro.xz, edN[2])) / hgSize;
  pM = HexToPix (PixToHex (ro.xz / hgSize));
  gIdP = vec2 (-999.);
  dHit = 0.;
  for (int j = VAR_ZERO; j < 200; j ++) {
    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;
    s = Minv3 (hv);
    p = ro + dHit * rd;
    gId = PixToHex (p.xz / hgSize);
    if (gId != gIdP) {
      gIdP = gId;
      SetPngConf ();
    }
    d = ObjDf (p);
    if (dHit + d < s) {
      dHit += d;
    } else {
      dHit = s + 0.002;
      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));
    }
    if (d < 0.0005 || dHit > dstFar || p.y < 0. || rd.y > 0. && p.y > 5.) break;
  }
  if (d >= 0.0005) dHit = dstFar;
  return dHit;
}

// Function 2454
MarchingPack rayCL(Ray r,Light l,float index){
	vec3 pos; 
    	
	vec2 minDist = vec2(length(r.o-l.p),-1);
	vec2 maxDist = vec2(-1,-1);
    
	float j;
    //for each object of the scene
	for(int i=1; i<=OBJ_NB ;i++){
		//test intersection btw ray and object
		j=float(i);
        if(j != index){
            vec2 dist = checkIntersection(r,getObject(j),j);	
            //remember the object if dist < previous tests
            if(dist.y != -1. && dist.x < minDist.x){
                minDist = dist;
            }
       }
	}
	//compute pixel colour
    MarchingPack cp ;
    if(minDist.y == -1.){
    	cp = MarchingPack(minDist.x,minDist.y,false);
    }else{
    	cp = MarchingPack(minDist.x,minDist.y, true);
    }
    
    return cp;
}

// Function 2455
vec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )
{
	vec4 sum = vec4(0, 0, 0, 0);
	rays = 0.0;
    
	float sun = clamp( dot(rd,lig), 0.0, 1.0 );
	float t = 0.1*texelFetch( iChannel0, px&ivec2(255), 0 ).x;
	for(int i=0; i<64; i++)
	{
		if( sum.w>0.99 || t>tmax ) break;
		vec3 pos = ro + t*rd;
		vec4 col = mapClouds( pos );

		float dt = max(0.1,0.05*t);
		float h = (2.8-pos.y)/lig.y;
		float c = fbm( (pos + lig*h)*0.35 );
		//kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);
		rays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));
	
		
		col.xyz *= vec3(0.4,0.52,0.6);
		
        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);
		
		col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );
		
		col.a *= 0.5;
		col.rgb *= col.a;

		sum = sum + col*(1.0 - sum.a);	

		t += dt;//max(0.1,0.05*t);
	}
    rays = clamp( rays, 0.0, 1.0 );

	return clamp( sum, 0.0, 1.0 );
}

// Function 2456
vec3 calcMissileNormal( in vec3 pos, Missile missile )
{    
  return normalize( vec3(MapFlyingMissile(pos+eps.xyy, missile) - MapFlyingMissile(pos-eps.xyy, missile), 0.5*2.0*eps.x, MapFlyingMissile(pos+eps.yyx, missile) - MapFlyingMissile(pos-eps.yyx, missile) ) );
}

// Function 2457
vec4 rayBox(vec3 rp, vec3 rd, vec3 pos, vec3 ext) {
    rp -= pos;
    vec3 mind = (rp+ext)/rd, maxd = (rp-ext)/rd;
	mind = -(mind-step(vec3(-1e-6),mind)*(mind+VIEW_DISTANCE));
	maxd = -(maxd-step(vec3(-1e-6),maxd)*(maxd+VIEW_DISTANCE));
	mind = min(mind,maxd);
    
    vec4 nrm;
    nrm.w = VIEW_DISTANCE;
    if (mind.x < VIEW_DISTANCE && mind.x < nrm.w) {
        vec2 pd = abs(rp.zy+rd.zy*mind.x)-ext.zy;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(-sign(rd.x),0.,0.,mind.x);
    }
    if (mind.y < VIEW_DISTANCE && mind.y < nrm.w) {
        vec2 pd = abs(rp.xz+rd.xz*mind.y)-ext.xz;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(0,-sign(rd.y),0.,mind.y);
    }
    if (mind.z < VIEW_DISTANCE && mind.z < nrm.w) {
        vec2 pd = abs(rp.xy+rd.xy*mind.z)-ext.xy;
        if (max(pd.x,pd.y) < 0.) nrm = vec4(0.,0.,-sign(rd.z),mind.z);
    }
    return nrm;
}

// Function 2458
vec3 mapRMWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapWaterDetailed(pt);    
    normal.x = mapWaterDetailed(vec3(pt.x+e,pt.y,pt.z)) - normal.y;
    normal.z = mapWaterDetailed(vec3(pt.x,pt.y,pt.z+e)) - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 2459
float RayCircleIntersect( vec2 vRayOrigin, vec2 vRayDir, vec2 vCircleOrigin, float fRadius2 )
{
    vec2 vRayOriginToCircleOrigin = vCircleOrigin - vRayOrigin;
    float fProjection = dot( vRayOriginToCircleOrigin, vRayDir );        
    vec2 vClosestPos = vRayOrigin + vRayDir * fProjection;
    vec2 vClosestToCircle = vCircleOrigin - vClosestPos;
    float fClosestDist2 = dot( vClosestToCircle, vClosestToCircle );
    if ( fClosestDist2 < fRadius2 )
    {
        float fHalfChordLength = sqrt( fRadius2 - fClosestDist2 );
        float fHitT = fProjection - fHalfChordLength;

        return fHitT;
	}

    return -1.0;
}

// Function 2460
vec3 dNormal(in vec3 p, in float eps)
{
   vec2 e = vec2(eps,0.);
   return normalize(vec3(
      dField(p + e.xyy) - dField(p - e.xyy),
      dField(p + e.yxy) - dField(p - e.yxy),
      dField(p + e.yyx) - dField(p - e.yyx) ));
}

// Function 2461
void Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )
{
    vec2 vView = Cam_GetViewCoordFromUV( vUV );
    vRayOrigin = cam.vPos;
    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );
    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );
}

// Function 2462
float raymarch(vec3 rayOrigin, vec3 rayDirection)
{
    float t = 0.0;
    for(int i = 0; i < maxSteps; ++i)
    {
        //pick a point p from origin along rayDirection
        //at distance step t. (addition of 2 vectors)
        vec3 p = rayOrigin + rayDirection * t; 
        
        //calculate distance of p from sphere
        float d = distSphere(p, sphereRadius);
        
        
        //increment the step value by distance
        t += d;
        
        //if we are close enough to target pixel. break
        if(d < epsilon)
        {
            break;
        }
    }
    return t;
}

// Function 2463
vec3 getNormal(in vec2 uv)
{
    //This could probably be more efficient
    //dx
    vec2 dx = vec2(EPS,0.);
    vec3 t = vec3(EPS,rockVoronoi(uv+dx),0.);
    vec3 s = vec3(-EPS,rockVoronoi(uv-dx),0.);
    vec3 uv_dx = normalize((t - s));
    
    //dy
    vec2 dz = vec2(0.,EPS);
    t = vec3(0.,rockVoronoi(uv+dz),EPS);
    s = vec3(0.,rockVoronoi(uv-dz),-EPS);
    vec3 uv_dz = normalize((t - s));
    return cross(uv_dx, uv_dz);
}

// Function 2464
vec3 ComputeNormals(vec3 p)
{
    vec3 o;
    
    vec3 epsilonX = vec3(EPSILON, 0, 0);
    vec3 epsilonY = vec3(0, EPSILON, 0);
    vec3 epsilonZ = vec3(0, 0, EPSILON);
    
    // To estimate the normal in an axis, from a surface point, we move slightly
    // in that axis and get the changing in the distance to the surface itself.
    // If the change is 0 or really small it means the surface doesn't change in that
    // direction, so its normal in that point won't have that axis component.
    float reference = GetNearestShape(p).distance;
    o.x = GetNearestShape(p+epsilonX).distance - reference;
    o.y = GetNearestShape(p+epsilonY).distance - reference;
    o.z = GetNearestShape(p+epsilonZ).distance - reference;
    
    return normalize(o);
}

// Function 2465
float rayMarching (vec3 ro, vec3 rd, out vec3 pos)
{
	float totalDist = 0.0;
	pos = ro;
	float dist = EPSILON;
	
	for (int i = 0; i < MAX_ITER; i++) {
		if (dist < EPSILON || totalDist > MAX_DIST) break;
		dist = distanceFunction(pos);
		totalDist += dist*0.98;
		pos = ro + totalDist * rd;
	}		
	return dist;
}

// Function 2466
vec3 mapNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapDetailed(pt).x;    
    normal.x = mapDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 2467
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 80; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (p);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 2468
vec3 castRay( vec3 ro, vec3 rd, float linesSpeed )
{
	vec3 col = vec3(0.0);
	
		
	float mindist = 10000.0;
	vec3 p = vec3(0.2);
	float h = 0.0;
	float rad = 0.04 + 0.15*freqs[0];
	float mint = 0.0;
    for( int i=0; i<128; i++ )
	{
		vec3 op = p;
		
		op = p;
		p  = 1.25*1.0*normalize(snoise3( 64.0*h + linesSpeed*0.015*iTime ));
		
		vec3 dis = distanceRaySegment( ro, rd, op, p );
		
		vec3 lcol = 0.6 + 0.4*sin( 10.0*6.2831*h + vec3(0.0,0.6,0.9) );
		
		float m = pow( texture( iChannel0, vec2(h*0.5,0.25) ).x, 2.0 )*(1.0+2.0*h);
		
		float f = 1.0 - 4.0*dis.z*(1.0-dis.z);
		float width = 1240.0 - 1000.0*f;
		width *= 0.25;
		float ff = 1.0*exp(-0.06*dis.y*dis.y*dis.y);
		ff *= m;
		col += 0.3*lcol*exp( -0.3*width*dis.x*dis.x )*ff;
		col += 0.5*lcol*exp( -8.0*width*dis.x*dis.x )*ff;
		h += 1.0/128.0;
	}


    return col;
}

// Function 2469
float rayMarch(vec3 rayOrig, vec3 rayDir) {
	float dist = 0.;
    
    for (int i = 0; i < MAX_STEPS; ++i) {
		vec3 p = rayOrig + dist * rayDir;
		float sceneDist = sceneDist(p);
        
        dist += sceneDist;
       
        if (dist > MAX_DIST || sceneDist < SURF_DIST) {
        	break;
        }
	}
    
    return dist;
}

// Function 2470
vec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)
{
	vec3 eps=vec3(1.0/resolution,0.0);
	vec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),
					 length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));
	
	return norm;
}

// Function 2471
vec4 raymarch (vec3 ro, vec3 rd)
{
    vec3 color = vec3(0.0);
	for (int i = 0; i < 512; i++)
	{
 		bool hit = InsideTetrahedronII(vec3(0.943, 0, -0.333 ),vec3( -0.471, 0.816, -0.333), vec3( -0.471, -0.816, -0.333), vec3(0, 0, 1 ),ro,color);
 		if (hit) return vec4(color,1.0); 
    	ro += rd * 0.01;
     }
	return vec4(0,0,0,1);
}

// Function 2472
vec3 calcNormalmap( in vec3 pos, in float ep )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*map(pos+e.xyy*ep).x + 
					 e.yyx*map(pos+e.yyx*ep).x + 
					 e.yxy*map(pos+e.yxy*ep).x + 
					 e.xxx*map(pos+e.xxx*ep).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*ep).x;
    }
    return normalize(n);
#endif    
}

// Function 2473
bool MarchReflectionRay( vec3 start, vec3 dir, out vec3 pos CACHEARG )
{
    // same as MarchCameraRay except lower tolerances because artifacts won't be very noticeable.
    // no bounds checking because reflection rays always start near the surface
    
    // assumes dir is normalized
    pos = start + dir * REFLECTION_EPSILON;
    
    float prevMarchDist = REFLECTION_EPSILON;
    float prevSurfaceDist = BlobDist( start CACHE );
    
    for ( int i = 0; i < MAX_REFLECTION_RAYMARCH_STEPS; i++ )
    {
        float surfaceDist = BlobDist( pos CACHE );
        if ( surfaceDist < EPSILON )
        {
            if ( surfaceDist < 0.0 )
            	pos = RefineSurfacePos( pos, dir, surfaceDist, prevSurfaceDist, prevMarchDist, REFLECTION_EPSILON CACHE );
            return true;
        }
        
        float gradientAlongRay = (prevSurfaceDist - surfaceDist) / prevMarchDist;
        float safeGradient = max( gradientAlongRay, MIN_GRADIENT_FOR_REFLECTION_RAYS );
        
        float addDist = (surfaceDist + REFLECTION_EPSILON) / safeGradient;
        prevMarchDist = addDist;
        
        prevSurfaceDist = surfaceDist;
        pos += dir * addDist;
        
        vec3 relPos = pos - BLOB_BOUNDING_CENTER;
        relPos *= BLOB_BOUNDING_SCALE;
        if ( dot( relPos, relPos ) > BLOB_BOUNDING_RADIUS_SQR )
            return false;
    }
    
    return true;
}

// Function 2474
float castRay2(vec3 ro,vec3 rd) 
{
    float precis = 0.2;
    float h = 0.;
    float t = 0.01;

    for(int i = 0; i < 90; i++) 
	{
		if(abs(h) > precis ) break;
		h = map(ro + rd * t);
		t-=h;
	}
	return t;
}

// Function 2475
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// Function 2476
Ray get_ray(vec2 uv)
{
    vec3 front = normalize(-CAMERA_POS);
    vec3 up = vec3(0,1,0);
    vec3 right = normalize(cross(front,up));
    up = normalize(cross(right,front));
    vec3 viewVec = normalize(front+right*uv.x+up*uv.y);
    
    return Ray(CAMERA_POS, viewVec);
}

// Function 2477
vec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){
    float 	focal = 1.;
    vec3 ww = normalize( camTarget - pos );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;
    vec3 vv = cross(uu,ww);
	// create view ray
	return normalize( st.x*uu + st.y*vv + focal*ww );
}

// Function 2478
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 100.0;
    
    
	float precis = 0.00001;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    vec2 res = fScene( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 2479
vec3 llamelGetNormal( in vec3 ro ) {
    vec2 e = vec2(1.0,-1.0)*0.001;

    return normalize( e.xyy*llamelMap( ro + e.xyy ) + 
					  e.yyx*llamelMap( ro + e.yyx ) + 
					  e.yxy*llamelMap( ro + e.yxy ) + 
					  e.xxx*llamelMap( ro + e.xxx ) );
}

// Function 2480
float grayscale(vec3 c)
{
    return dot(c, vec3(.21, .72, .07));
}

// Function 2481
vec3 getNormal(vec3 p)
{
    float d = getDist(p).x;
    vec2 e = vec2(EPSILON, 0);
    
    vec3 n = d - vec3(
        getDist(p-e.xyy).x,
        getDist(p-e.yxy).x,
        getDist(p-e.yyx).x
    );
    
    return normalize(n);
}

// Function 2482
void ray(inout vec3 cp,vec3 rd, out float st, out float cd)
{
  for(st = 0.; st < 1.; st += 1./200.)
  {
    cd = map(cp);
    if(cd < .01 || cd > 60.)
      break;
    cp += rd * cd * st;
  }
}

// Function 2483
vec3 normal(vec3 p) {
	vec2 e = vec2(.001, 0.);
	return normalize(vec3(
		de(p + e.xyy) - de(p - e.xyy),
		de(p + e.yxy) - de(p - e.yxy),
		de(p + e.yyx) - de(p - e.yyx)
	));
}

// Function 2484
float RayMarch(vec3 ro,vec3 rd) { float cd = 0.;float pd = MID*1.1;for(int s = 0; s < MS && cd < MAD && pd > MID;s++){pd = getDist(ro+rd*cd);cd += pd;}return cd;}

// Function 2485
float raymarchShadow(Ray ray)
{
    float shadow = 1.;
	float t = CAMERA_NEAR;
    vec3 p = vec3(0.);
    float h = 0.;
    for(int i = 0; i < 80; ++i)
	{
	    p = ray.origin + t * ray.direction;
        h = p.y - terrainFbm(p.xz, MQ_OCTAVES, iChannel0);
		shadow = min(shadow, 8. * h / t);
		t += h;
		if (shadow < 0.001 || p.z > CAMERA_FAR) break;
	}
	return SAT(shadow);
}

// Function 2486
void populateSoundArray()
{
    // Get FFT values from texture
    for (int i = 0; i < afFrequencies.length(); i++)
    {
        afFrequencies[i] = texture( iChannel0, vec2(float(i)/float(afFrequencies.length()), 0.25) ).x;
    }
}

// Function 2487
vec3 OceanNormal(vec2 p, vec3 camPos)
{
    vec2 e = vec2(0, 1.0 * EPS);
    float l = 20.0 * distance(vec3(p.x, 0.0, p.y), camPos);
    e.y *= l;
    
    float hx = OceanHeight(p + e.yx) - OceanHeight(p - e.yx);
    float hz = OceanHeight(p + e.xy) - OceanHeight(p - e.xy);
    return normalize(vec3(-hx, 2.0 * e.y, -hz));
}

// Function 2488
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.001;             // precision of the normal computation

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ).x + 
					  v2*doModel( pos + v2*eps ).x + 
					  v3*doModel( pos + v3*eps ).x + 
					  v4*doModel( pos + v4*eps ).x );
}

// Function 2489
Hit RayMarchHighDetailModel(vec3 ro, vec3 dir) 
{
    vec3 P = vec3(0.,0.,0.);
    float t = 0.;
    while(t < MAX_MARCHING_DISTANCE) 
    {
        P = ro + t*dir;
        Hit hit = SD_HighDetailModel(P);
        if((hit.d)<0.01) 
    	{
            hit.normal = normalHighDetailModel(P);
            hit.tangent = tangent(hit.normal);
            hit.binormal = normalize(cross(hit.normal, hit.tangent));
			return hit;
        }
        t+=hit.d;
    }
    return Hit(-1, MAX_MARCHING_DISTANCE,vec3(0.),vec3(0.),vec3(0.),vec3(0.));
}

// Function 2490
Ray reflect_ray(in Ray R, in Intersection I) {
    return Ray(I.P, reflect(R.Dir, I.N));
}

// Function 2491
void getRays(inout Ray ray, out Ray r1, out Ray r2) {
     vec3 p = ray.cp.p;
    float cs = dot(ray.cp.normal, ray.rd);
    // simple approximation
    float fresnel = 1.0-abs(cs);
    vec3 normal = sign(cs)*ray.cp.normal;
    vec3 refr = refract(ray.rd, -normal, ray.eta);
    vec3 refl = reflect(ray.rd, ray.cp.normal);
    vec3 z = normal*DIST_EPSILON*2.;
    p += z;
    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);
    p -= 2.*z;
    r2 = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);
}

// Function 2492
vec3 Normal( vec3 pos, vec3 ray, float t )
{
	// in theory we should be able to get a good gradient using just 4 points

	float pitch = .2 * t / iResolution.x;
#ifdef FAST
	// don't sample smaller than the interpolation errors in Noise()
	pitch = max( pitch, .005 );
#endif
	
	vec2 d = vec2(-1,1) * pitch;

	vec3 p0 = pos+d.xxx; // tetrahedral offsets
	vec3 p1 = pos+d.xyy;
	vec3 p2 = pos+d.yxy;
	vec3 p3 = pos+d.yyx;
	
	float f0 = DistanceField(p0,t);
	float f1 = DistanceField(p1,t);
	float f2 = DistanceField(p2,t);
	float f3 = DistanceField(p3,t);
	
	vec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);
	
	// prevent normals pointing away from camera (caused by precision errors)
	float gdr = dot ( grad, ray );
	grad -= max(.0,gdr)*ray;
	
	return normalize(grad);
}

// Function 2493
vec3 getNormal(vec3 p)
{
	float d = 0.0001;
	
    return normalize(vec3(
        distMap(p + vec3(  d, 0.0, 0.0)) - distMap(p + vec3( -d, 0.0, 0.0)),
        distMap(p + vec3(0.0,   d, 0.0)) - distMap(p + vec3(0.0,  -d, 0.0)),
        distMap(p + vec3(0.0, 0.0,   d)) - distMap(p + vec3(0.0, 0.0,  -d))
    ));
}

// Function 2494
vec3 getNormal( vec3 p ) {
	//noise derivative
    vec3 value;
	value = fbmDerivative( p.xz, HIGHITER);
	if (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); }
	float dfx=value.y;
	float dfz=value.z;
	//float vy = 1.0 ;	vy -= dfx*dfx + dfz*dfz;vy=sqrt(vy);
	
	return normalize(vec3( -value.y, 1.0, -value.z));
}

// Function 2495
vec3 getNormal(in vec3 p)
{
    const float e = EPS;
    const vec3 dx = vec3(e, 0, 0);
    const vec3 dy = vec3(0, e, 0);
    const vec3 dz = vec3(0, 0, e);
    
    float d = distFunc(p);
    
    return normalize(vec3(
    	d - distFunc(p - dx),
    	d - distFunc(p - dy),
    	d - distFunc(p - dz)
    ));
}

// Function 2496
vec3 calcNormal( in vec3 pos, float t )
{
    vec2  eps = vec2( 0.004*t, 0.0 );
    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),
                            2.0*eps.x,
                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );
}

// Function 2497
float raySphere(in Ray r, in Shape s, out vec3 p, out vec3 n)
{
    float t = -1.0;
	vec3 dv = r.o - s.c;
    float distanceToCenterSquared = dot(dv, dv);
    float radiusSquared = s.dim.x * s.dim.x;
    
    bool startedInside = distanceToCenterSquared <= radiusSquared;
	
	float b = dot(r.d, dv);
    if (b <= 0.0) 
    {
		float d = b * b - distanceToCenterSquared + radiusSquared;
        if (d >= 0.0) 
        {
			d = sqrt(d);
            float t0 = -b - d;
            float t1 = -b + d;
            
            if (t0 < 0.0) t0 = huge;
            if (t1 < 0.0) t1 = huge;
            
            t = min(t0, t1);
            p = r.o + t * r.d;
            n = normalize(startedInside ? (s.c - p) : (p - s.c));
        }
    }
    
	return t;
}

// Function 2498
vec3 normal(vec3 p) {
    vec2 e = vec2(epsilon_, 0.0);
    return normalize(vec3(
        eval_scene(p+e.xyy).d-eval_scene(p-e.xyy).d,
        eval_scene(p+e.yxy).d-eval_scene(p-e.yxy).d,
        eval_scene(p+e.yyx).d-eval_scene(p-e.yyx).d
    ));
}

// Function 2499
float rayf(float t) {
    return pa_map(pa_init(t)).a[0];
}

// Function 2500
vec3 calcNormal( in vec3 p )
{
    #ifdef TRAPS
    the code below only works for the actual Julia set, not the traps
    #endif
        
    vec4 z = vec4(p,0.0);

    // identity derivative
    mat4x4 J = mat4x4(1,0,0,0,  
                      0,1,0,0,  
                      0,0,1,0,  
                      0,0,0,1 );

  	for(int i=0; i<kNumIte; i++)
    {
        // f(q) = q + c = 
        //   x =  xx - 3yx - 3zx - 3wx + c.x
        //   y = 3xy -  yy -  zy -  wy + c.y
        //   z = 3xz -  yz -  zz -  wz + c.z
        //   w = 3xw -  yw -  zw -  ww + c.w
		//
        // Jacobian, J(f(q)) =
        //   3(x-y-z-w)  6xy            6xz            6xw
        //    -6xy           3x-3y-z-w -2yz           -2yw
        //    -6xz          -2yz            3x2-y-3z-w -2zw
        //    -6xw          -2yw           -2zw            3x-y-z-3w
        
        float k1 = 6.0*z.x*z.y, k2 = 6.0*z.x*z.z;
        float k3 = 6.0*z.x*z.w, k4 = 2.0*z.y*z.z;
        float k5 = 2.0*z.y*z.w, k6 = 2.0*z.z*z.w;
        float sx = z.x*z.x, sy = z.y*z.y;
        float sz = z.z*z.z, sw = z.w*z.w;
        float mx = 3.0*sx-3.0*sy-3.0*sz-3.0*sw;
        float my = 3.0*sx-3.0*sy-    sz-    sw;
        float mz = 3.0*sx-    sy-3.0*sz-    sw;
        float mw = 3.0*sx-    sy-    sz-3.0*sw;
        
        // chain rule of jacobians
        J = J*mat4x4( mx, -k1, -k2, -k3,
                      k1,  my, -k4, -k5,
                      k2, -k4,  mz, -k6,
                      k3, -k5, -k6,  mw );
        // q = q + c
        z = qCube(z) + kC; 
        
        // exit condition
        if(dot2(z)>256.0) break;
    }

    return (p.y>0.0 ) ? vec3(0.0,1.0,0.0) : normalize( (J*z).xyz );
}

// Function 2501
void raytrace(vec3 s, inout float d, vec3 r, inout vec3 n, inout vec3 emi) {
  
  backbox(s,d,r,n,emi, vec3(0), vec3(10,5,10));
  
  frontbox(s,d,r,n,emi, vec3(7,3,0), vec3(5,0.5,4));
  
  plane(s,d,r,n,emi, normalize(vec3(curve(time+3.2,0.8),1.0,curve(time+7.8,0.8))), 2.0 + (curve(time,0.8)-.5)*10.0);
}

// Function 2502
ray uvToCameraRay(vec2 uv, float projectionDist)
{
    ray cameraRay;
    cameraRay.direction = normalize(vec3(uv.x, uv.y, projectionDist));
    return cameraRay;
}

// Function 2503
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 2504
vec4 calcNormal(vec3 p, float dx) {
	const vec3 k = vec3(1,-1,0);
	return   (k.xyyx*map(p + k.xyy*dx) +
			 k.yyxx*map(p + k.yyx*dx) +
			 k.yxyx*map(p + k.yxy*dx) +
			 k.xxxx*map(p + k.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);
}

// Function 2505
vec4 raymarch( in vec3 rayo, in vec3 rayd, in vec2 expInter, in float t, out float d )
{
    vec4 sum = vec4( 0.0 );
    
    float step = 1.5 / float(steps);
     
    // start iterating on the ray at the intersection point with the near half of the bounding sphere
	//vec3 pos = rayo + rayd * (expInter.x + step*texture( iChannel2, gl_FragCoord.xy/iChannelResolution[0].x ).x);		// dither start pos to break up aliasing
	//vec3 pos = rayo + rayd * (expInter.x + 1.0*step*fract(0.5*(gl_FragCoord.x+gl_FragCoord.y)));	// regular dither
	vec3 pos = rayo + rayd * (expInter.x);	// no dither

    float march_pos = expInter.x;
    d = 4000.0;
    
    // t goes from 0 to 1 + mult delay. that is 0 to 1 is for one explosion ball. the delay for time distribution of the multiple explosion balls.
    // t_norm is 0 to 1 for the whole animation (incl mult delay).
    float t_norm = t / tmax;
    float smooth_t = sin(t_norm*2.1);	//sin(t*2.);

	//float bright = 6.1;
	float t1 = 1.0 - t_norm;	// we use t_norm instead of t so that final color is reached at end of whole animation and not already at end of first explosion ball.
    //float bright = 3.1 + 18.0 * t1*t1;
	//float bright = 3.1 + 1.4 * t1*t1;
	//float bright = 3.1 + 4.4 * t1*t1;
	float bright = brightness.x + brightness.y * t1*t1;
	//float bright = smoothstep(0.0, 30.1, 1.0);
	//float bright = smoothstep(20.0, 3.1, 1.0);
    //float bright = 10.;

    for( int i=0; i<steps; i++ )
    {
        if( sum.a >= 0.98 ) { d = march_pos; break; }
        if ( march_pos >= expInter.y ) break;
        
        float rad, r, rawDens;
        vec4 col;
        calcDens( pos, rad, r, rawDens, t, smooth_t, col, bright );

        if ( rawDens <= 0.0 )
        {
            float s = step * 2.0;
            pos += rayd * s;
            march_pos += s;
            continue;
        }
        
#ifdef OLD_COLORING
        contributeDens( rad, r, rawDens, bright, col, sum );
#else
        contributeColor( col, sum );
#endif
		
		// take larger steps through low densities.
		// something like using the density function as a SDF.
		float stepMult = 1.0 + (1.-clamp(rawDens+col.a,0.,1.));
		// step along ray
		pos += rayd * step * stepMult;
        march_pos += step * stepMult;

		//pos += rayd * step;
	}

#ifdef SHOW_BOUNDS
    if ( sum.a < 0.1 )
        sum = vec4(0.,0.,.5,0.1);
#endif
	
    return clamp( sum, 0.0, 1.0 );
}

// Function 2506
vec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { 
	
    // Roughly two pixel edge spread, but increased slightly with larger resolution.
    vec2 e = vec2(ef/mix(450., iResolution.y, .5), 0);

	float d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	float d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	float d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	float d = map(p)*2.;

    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);
    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);
    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));

    /*
    // Wider sample spread for the curvature.
    e = vec2(12./450., 0);
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);
	*/
    
    e = vec2(.0015, 0); //iResolution.y - Depending how you want different resolutions to look.
	d1 = map(p + e.xyy), d2 = map(p - e.xyy);
	d3 = map(p + e.yxy), d4 = map(p - e.yxy);
	d5 = map(p + e.yyx), d6 = map(p - e.yyx);
	
    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));
}

// Function 2507
float RayRoundBoxIntersect(Ray ray, RoundBox box, bool convex, int numSteps)
{
	vec3 origin = WorldToLocal(ray.origin, box);
    vec3 dir = WorldToLocal(ray.origin + ray.dir, box) - origin;
	float t0 = 0.0;
	float t1 = FLT_REALLY_BIG;
	const float thresh = 0.0001; // fixed for now .. not even sure this is useful
	float dlen = length(dir);
	float q = 1.0/dlen;
	vec3 P = origin;
	vec3 V = dir*q;
	t0 *= q;
	t1 *= q;
	float d0 = FLT_REALLY_BIG;
	vec3 E = box.extent - box.roundRadius;
	for (int i = 0; i < numSteps; i++) {
		float d1 = LocalDistanceToRoundBox(P, box);
		if (d1 <= thresh)
			break;
		float dt = d1;
		if (convex) {
			vec3 G = normalize(clamp(P, -E, E) - P); // negative gradient vector
			dt /= dot(V, G);
		}
		t0 += dt;
		if (d1 > d0 || t0 >= t1)
			return 0.0; // distance is increasing (since object is convex, we know we missed), or we extended past the end of the ray
		P = origin + V*t0;
		d0 = d1;
	}
	return t0*dlen;
}

// Function 2508
bool RayIntersectSphere (in SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)
{
	if (ignorePrimitiveId == sphere.m_Id)
		return false;

	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.m_center;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.m_radius * sphere.m_radius;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;


	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;

	//not inside til proven otherwise
	bool fromInside = false;

	//ray now found to intersect sphere, compute smallest t value of intersection
	float collisionTime = -b - sqrt(discr);

	//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside
	if(collisionTime < 0.0)
	{
		collisionTime = -b + sqrt(discr);
		fromInside = true;
	}

	//enforce a max distance if we should
	if(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)
		return false;

	// set all the info params since we are garaunteed a hit at this point
	info.m_fromInside = fromInside;
	info.m_collisionTime = collisionTime;
	info.m_material = sphere.m_material;

	//compute the point of intersection
	info.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;

	// calculate the normal
	info.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;
	info.m_surfaceNormal = normalize(info.m_surfaceNormal);

	// we found a hit!
	info.m_foundHit = true;
	info.m_Id = sphere.m_Id;
	return true;
}

// Function 2509
vec3 normal( vec3 p, float fts ) {
    vec3 e = vec3(0.01,-0.01,0.0);
    return normalize( vec3(
        e.xyy*DE(p+e.xyy,fts).x +
        e.yyx*DE(p+e.yyx,fts).x +
        e.yxy*DE(p+e.yxy,fts).x +
        e.xxx*DE(p+e.xxx,fts).x)
    );
}

// Function 2510
Ray genRay( in Camera camera, in vec2 pixel ) {
	vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    
    Ray ray;
    ray.origin = camera.pos;
	ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));

	return ray;
}

// Function 2511
mat3 RayMarch(vec3 ro, vec3 rd) {
	float dO = 0.;
    float world = 0.;
    
    for(int i=0; i<MAX_STEPS; i++) {
        // Calculate step.
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        
        // Determine if we passed through a portal.
        float t = intersectPlane(p, rd, vec3(0, 0, 1), vec3(0));
        float portal = intersectPortal(p, rd, vec3(0, 0, 1), vec3(0), t);
        if (portal != 0. && t < dS) {
          ro += PORTAL_TRANSLATE;
          dS = t + EPSILON;
          world += sign(dot(rd, vec3(0, 0, 1)));
        }
        
        // Determine if we should stop.
        dO += dS;
        if (dO>MAX_DIST) {
            dO = MAX_DIST;
            break;
        } else if (dS<EPSILON) {
            break;
        }
    }
    
    mat3 result;
    result[0] = vec3(ro + rd * dO);
    result[1] = vec3(dO, 0, 0);
    result[2] = vec3(world, 0, 0);
    return result;
}

// Function 2512
void cameraRay(vec2 fragCoord, mat4 t, int s, out vec3 ro, out vec3 rd) {
    uvec2 seed = uvec2(s, iFrame);
    vec2 o = vec2(uintBitsToFloat01(hash(seed)),
                  uintBitsToFloat01(hash(seed + 2797941u)));
    
    float e = 1.0/iResolution.x;
    vec2 uv = (fragCoord - iResolution.xy*0.5) * e + (o - 0.5)*e*1.5;

    rd = mat3(t)*normalize(vec3(uv, 0.4)); 
    ro = t[3].xyz;
}

// Function 2513
vec3 normal(vec3 p, float t, float mindist) {
    float e = mindist*t;
    vec2 h = vec2(1.,-1.)*.5773;
    return normalize( h.xyy*map( p + h.xyy*e ).x + 
					  h.yyx*map( p + h.yyx*e ).x + 
					  h.yxy*map( p + h.yxy*e ).x + 
					  h.xxx*map( p + h.xxx*e ).x );
}

// Function 2514
vec3 RayAt(vec2 fragCoord) {
    float x = 2. * fragCoord.x - 1.0;
    float y = 2. * fragCoord.y - 1.0;
	x *= iResolution.x / iResolution.y;
    float z = FOCAL_LENGTH;
    vec3 ray = vec3(x, y, z);
    return ray / length(ray);
}

// Function 2515
vec3 getNormal( in vec3 pos )
{
    vec2 e = vec2(0.002, -0.002);
    return normalize(
        e.xyy * map(pos + e.xyy) + 
        e.yyx * map(pos + e.yyx) + 
        e.yxy * map(pos + e.yxy) + 
        e.xxx * map(pos + e.xxx));
}

// Function 2516
vec3 terrainCalcNormalHigh( in vec3 pos, float t ) {
    vec2 e = vec2(1.0,-1.0)*0.001*t;

    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + 
					  e.yyx*terrainMapH( pos + e.yyx ) + 
					  e.yxy*terrainMapH( pos + e.yxy ) + 
					  e.xxx*terrainMapH( pos + e.xxx ) );
}

// Function 2517
void TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)
{
	int lastHitPrimitiveId = 0;
	float reflectionAmount = 1.0;
	
	for(int index = 0; index < c_maxRayBounces; ++index)
	{
		
		SCollisionInfo collisionInfo =
			SCollisionInfo
			(
				0,
				false,
				false,
				-1.0,
				vec3(0.0,0.0,0.0),
				vec3(0.0,0.0,0.0),
				SMaterial(
					1.0,
					vec3(0.0,0.0,0.0),
					1.0,
					vec3(0.0,0.0,0.0),
					vec3(0.0,0.0,0.0),
					0.0
				)
			);

		// run intersection against all objects, including light objects		
		#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		SPHEREPRIMLISTWITHLIGHTS
		#undef PRIM
			
		// run intersections against all boxes
		#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);
		BOXPRIMLIST
		#undef PRIM

	
		if (collisionInfo.m_foundHit)
		{	
			// point lights
			#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, reflectionAmount, rayDir);
			POINTLIGHTLIST
			#undef LIGHT
				
			// directional lights
			#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, reflectionAmount, rayDir);
			DIRLIGHTLIST				
			#undef LIGHT

			// ambient light
			pixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * reflectionAmount;
			
			// emissive color
			pixelColor += collisionInfo.m_material.m_emissiveColor * reflectionAmount;		
			
			//set up our next ray
			rayPos = collisionInfo.m_intersectionPoint;
			rayDir = reflect(rayDir, collisionInfo.m_surfaceNormal);
			
			lastHitPrimitiveId = collisionInfo.m_Id;
			reflectionAmount *= collisionInfo.m_material.m_reflection;
			
			if (reflectionAmount < 0.1)
				return;
		}
		// no hit means bail out
		else
		{
			pixelColor+= vec3(0.1,0.1,0.1) * reflectionAmount;
			return;
		}
	}
			
}

// Function 2518
float ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {
        vec3 p = origin + dir * depth;
		float dist = dist_field( p ) / length( gradient( p ) );
		if ( abs( dist ) < stop_threshold ) {
			return depth;
		}
		depth += dist * 0.9;
		if ( depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 2519
vec3 CalcNormal(const in vec3 pos, const in vec3 rayVec)
{
    // find the axis that is closest to 1.0 or 0.0.
    vec3 normal = vec3(0.0);
    vec3 frpos = 0.5-abs(0.5-fract(pos));
    vec3 fr = frpos * 2.0;
    fr = pow(fr, vec3(0.25));
    float sum = fr.x + fr.y + fr.z;
    vec3 div = fr / sum;
    float minAll = min(frpos.x, min(frpos.y, frpos.z));
    if (frpos.x == minAll) normal = vec3(-1.0, 0.0, 0.0) * sign(rayVec.x);
    if (frpos.y == minAll) normal = vec3(0.0, -1.0, 0.0) * sign(rayVec.y);
    if (frpos.z == minAll) normal = vec3(0.0, 0.0, -1.0) * sign(rayVec.z);
    //normal = normalize(div + normal);

    // Water wave normals
    if (pos.y < waterLevel+0.01) {
        normal.x += texture(iChannel1, (pos.xz + localTime)*0.125).x*0.2-0.1;
        normal.y += texture(iChannel1, (pos.zx - localTime)*0.1).x*0.2-0.1;
        //normal = normalize(normal);
    }
    return normal;
}

// Function 2520
vec4 ts_unpack_normal( TrnSampler ts, vec4 tsmpl )
{
    vec3 N = ts.TB * tsmpl.xy + ts.r_hat * sqrt( max( 0., 1. - dot( tsmpl.xy, tsmpl.xy ) ) );
    return vec4( N, tsmpl.w );
}

// Function 2521
vec3 normals(in vec3 p) {
  vec2 e = vec2(EPS, 0.0);
  vec3 gr = vec3( map(p + e.xyy) - map(p - e.xyy),
                  map(p + e.yxy) - map(p - e.yxy),
                  map(p + e.yyx) - map(p - e.yyx));
  return normalize(gr);
}

// Function 2522
vec3 normal(vec3 p)
{
	vec3 o = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,
                          map(p+o.yxy).x - map(p-o.yxy).x,
                          map(p+o.yyx).x - map(p-o.yyx).x));
}

// Function 2523
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.00001, 0.0, 0.0 );
    vec3 nor = vec3(
        mapScene(pos+eps.xyy).d - mapScene(pos-eps.xyy).d,
        mapScene(pos+eps.yxy).d - mapScene(pos-eps.yxy).d,
        mapScene(pos+eps.yyx).d - mapScene(pos-eps.yyx).d );
    return normalize(nor);
}

// Function 2524
Ray castRay(Ray ray)
{
    Hit hit = traceScene(ray);
    ray.t = hit.t;
    float roughness = hit.mat.roughness*hit.mat.roughness;
    
    if(hit.hit)
    {     
        ray.radiance = vec3(0.0);
        ray.rand = random(ray.rand);   
        
        if(hit.mat.type == DIELECTRIC)
        {     
            float ref_idx = 1.45;
            float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);
            float schlick = schlick(cosine,ref_idx);
            
            if(ray.rand > schlick)
            {   		
        		ray.attenuation = ray.attenuation*hit.mat.albedo;
        		ray.origin = ray.t*ray.direction+ray.origin;
				ray.direction = normalize(hit.normal+randv(ray.rand));  			    	
            }
            else
            {
                ray.attenuation = ray.attenuation*vec3(1.0);
        		ray.origin = ray.t*ray.direction+ray.origin;
				ray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*roughness);
                ray.done = dot(ray.direction,hit.normal)<=0.0;
            }         
            return ray;
        }
        
        else if(hit.mat.type == METALIC)
        {
            //float ref_idx = 1.5;
			//float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);
            //float schlick = schlick(cosine,ref_idx)-schlick(1.0,ref_idx);
            
            ray.attenuation = ray.attenuation*hit.mat.albedo;
        	ray.origin = ray.t*ray.direction+ray.origin;
			ray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*roughness);
            ray.done = dot(ray.direction,hit.normal)<=0.0;
            
            return ray;
        }
        
        //The glass code is from raytracing in a weekend
        //is still have trouble wrapping my head around the finer details of refraction
        else if(hit.mat.type == GLASS)
        {        
            float ref_idx = 1.5;
            float cosine;
            
            float ni_nt;
            
            vec3 normal;
            
            if(dot(ray.direction,hit.normal) > 0.0)
            {
				normal = -hit.normal;
               	ni_nt = ref_idx;
                cosine = ref_idx*dot(ray.direction,hit.normal)/length(ray.direction);
            }
            else
            {
                normal = hit.normal;
                ni_nt = 1.0/ref_idx;
                cosine = -dot(ray.direction,hit.normal)/length(ray.direction);
            }
            
            float schlick0;
            Refracted ref = refract0(ray.direction,normal,ni_nt);
            
            if(ref.did)
            {
                schlick0 = schlick(cosine,ref_idx);
            }
            else
            {  
                schlick0 = 1.0;
            }
            
            
           	if(ray.rand > schlick0)
            {  
                ray.origin = ray.t*ray.direction+ray.origin;
                ray.direction = normalize(ref.direction);  		    	
            }
            else
            {
                ray.attenuation = ray.attenuation*vec3(1.0);
        		ray.origin = ray.t*ray.direction+ray.origin;
				ray.direction = normalize(reflect(ray.direction,hit.normal));  

            }
            
            return ray;
        }
        
        
        else if(hit.mat.type == EMISSIVE)
        {                        
        	float ref_idx = 1.5;
			float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);
            float schlick = schlick(cosine,ref_idx);
            
            if(ray.rand > schlick)
            {   	
                ray.radiance = hit.mat.albedo; 			    	
            }
            else
            {
                ray.attenuation = ray.attenuation*vec3(1.0);
        		ray.origin = ray.t*ray.direction+ray.origin;
				ray.direction = normalize(reflect(ray.direction,hit.normal)+randv(ray.rand)*hit.mat.roughness);
                
                //return ray;
            }     
        }
        
        else if(hit.mat.type == TEST)
        {                        
        	float ref_idx = 1.5;
			float cosine = -dot(ray.direction,mix(hit.normal,-ray.direction,roughness))/length(ray.direction);
            float schlick = schlick(cosine,ref_idx)-schlick(1.0,ref_idx);
            
 	
           	ray.radiance = vec3(schlick); 			    	   
        }  
    }
    
    else
    {
       ray.radiance = backgroundColor(ray.direction);
    }
    
    ray.done = true;
    return ray;   
}

// Function 2525
float raymarch( vec3 o, vec3 target, float start_time, float timeDir, out vec4 objPos )
{
    objPos = vec4(0.,0.,0.,1.);
    vec3 delta = target - o;
    float dist = length( delta );
   
    vec3 d = delta / dist;
    
    float eps = 0.001;
    
    float x = 0.;
    float t = start_time;
    
    for( int i = 0; i < 150; i++ )
    {
        float dx = sdf( o + x * d, t, objPos );
        
        if( abs(dx) < eps )
        {
            return x;
        }

        dx *= .7;
        x += dx;
        if( x >= dist )
            break;
        
        // progress time as ray advances to simulate flight time of photon
        t += timeDir * light_time_per_m() * dx;
    }
    
    return ZFAR;
}

// Function 2526
bool TraceRay(vec3 pos, vec3 dir, out HIT R, float Time) {
    DF t; float dist=0.; R.P=pos;
    float FAR;
    if (pos.x>0. && pos.x<8. && pos.z>0. && pos.z<8.) {
    	FAR=boxfar(pos,1./dir,vec3(0.),vec3(8.));
    } else {
        vec2 BB=box(pos,1./dir,vec3(0.),vec3(8.));
        if (BB.x>0. && BB.y>BB.x) {
            FAR=BB.y;
            dist=BB.x;
        } else
            return false;
    }
    for (int i=0; i<128; i++) {
        if (dist>FAR) break;
        R.P=pos+dir*dist;
        t=SDF(R.P,Time);
        if (t.D<eps.x) {
			R.D=dist;
            R.N=Gradient(R.P,Time);
            R.C=t.C;
            R.Mat=t.Mat;
            return true;
        }
        dist=dist+t.D;
    }
	return false;
}

// Function 2527
float castShadowRay( in vec3 ro, in vec3 rd, out vec3 oVos )
{

	vec3 pos = floor(ro);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	vec3 ris = ri*rs;
	
	float res = 1.0;

    // detailed raymarching
    
    for( int i=0; i<DETAIL_INTER; i++ ) 
	{
		if( map(pos)>0.5 && i>0 )
		{
            float id = hash1( pos );
            vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
            float t = max ( mini.x, max ( mini.y, mini.z ) );
            float h = 0.0;
            vec3 ce = pos + 0.5;
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            h = map2( ro+rd*t-ce,id ); t += max(0.0,h);
            if( h<0.001 )
            {
                return 0.0;
                res=0.0; 
                break; 
			}
		}
		vec3 mi = step( dis.xyz, dis.yzx ); 
		vec3 mm = mi*(1.0-mi.zxy);
		dis += mm * ris;
        pos += mm * rs;
	}
	

    // coarse raymarching

	for( int i=0; i<(16-DETAIL_INTER); i++ ) 
	{
		if( map(pos)>0.5 && i>0 )
		{
            res=0.0; 
            break; 
		}
		vec3 mi = step( dis.xyz, dis.yzx ); 
		vec3 mm = mi*(1.0-mi.zxy);
		dis += mm * ris;
        pos += mm * rs;
	}
	
	oVos = pos;
	
	return res;
}

// Function 2528
HitData rayMarch(vec4 point, vec4 dir){
    HitData hd;
	float marched = 0.;
    float epsilon = 0.1;
    float lastDistance = 0.;
    while(marched < 10000.){
    	float distance = getDistance(point);
        marched += distance;
        point += dir*distance;
        if(distance < epsilon){
            return HitData(marched, 1.-distance/lastDistance);
        }
        lastDistance = distance;
        
    }return HitData(1000.,1.);
}

// Function 2529
float raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )
{
    vec4 kk;
    float t = tmin;
	for( int i=0; i<512; i++ )
    {
		vec3 p = ro + t*rd;
        float h = map(p,kk,false);
		if( abs(h)<(0.15*t/iResolution.x) ) break;
		t += h*0.5;
        if( t>tmax ) return -1.0;;
	}
    //if( t>tmax ) t=-1.0;

    return t;
}

// Function 2530
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.01, 0);
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx));
    return normalize(n);
}

// Function 2531
vec3 uvToRayDir( vec2 uv ) {
    vec2 v = PI * ( vec2( 1.5, 1.0 ) - vec2( 2.0, 1.0 ) * uv );
    return vec3(
        sin( v.y ) * cos( v.x ),
        cos( v.y ),
        sin( v.y ) * sin( v.x )
    );
}

// Function 2532
vec3 rayMarch(ray marcher){
    float epsilon = 0.001;
    float t = 0.;
    for (float i = 0.; i < maxIterations; i++){
        vec3 point = marcher.position + marcher.direction * t;
        float d = distFunc(point);
        if (d < epsilon){
            // UV wrapping so we can texture the sphere
            float u = (.5 + atan(point.z, point.x)
               / (2. * 3.14159)) / sphere1Rad / .5;
   	 		float v = (.5 - asin(point.y) / 3.14159) / sphere1Rad / .5;
      
            // Calc phong illumination
            vec3 normal = getNormal(point, sphere1Pos, sphere1Rad);
            vec3 lightDir = normalize(lightPos - point);
            vec3 viewDir = normalize(eye - point);
            vec3 reflection = reflect(lightDir, normal);
            // Add the ambient component
            float Ip = test.amb;
            // Add the diffuse component
            Ip += test.diff * dot(lightDir, normal);
            // Add the specular component
            Ip += pow(test.spec * dot(reflection, viewDir), test.shiny);
            return Ip * texture(iChannel1, vec2(u + iTime * 0.1, v)).xyz;
        }
        t+=d;
    }
    return vec3(0.);
}

// Function 2533
vec2 CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )
{
    const float maxd = 5.0;
    
	float h = 0.5;
    float t = 0.0;
    float steps = 0.0;
   
    for ( int i = 0; i < 50; ++i )
    {
        if ( h < 0.001 || t > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t, localToWorld );
        t += h;
        steps += 0.03;
    }

    if ( t > maxd )
    {
        t = -1.0;
    }
	
    return vec2(t, steps);
}

// Function 2534
vec3 cameraRay(vec2 uv, vec3 position, vec3 lookAt, float zoom) {
    vec3 forward = normalize(lookAt - position);
    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
    vec3 up = cross(forward, right);
    vec3 lensPlane = forward * zoom;
    vec3 lensPoint = lensPlane + uv.x * right + uv.y * up;
    vec3 direction = normalize(lensPoint);
    return direction;
}

// Function 2535
vec3 drawNormals( in vec3 col, in vec2 p, in float e, in vec2 path[kNumPoints], in vec2 norm[kNumPoints], in vec3 pathColor, in float normLength )
{
    float d = 1000.0;
    for( int i=0; i<kNumPoints; i++ )
    {
        vec2 b = path[i];
        vec2 n = normLength*normalize(norm[i]);

        d = min( d, sdSegmentSq(p,b,b+n) );
    }
    d = sqrt(d);

    return mix( col, pathColor, 1.0-smoothstep(0.0,2.0*e,d) );
}

// Function 2536
void rayMarch(vec3 worldVector, out float depth, out vec3 rayPosition){
    const float rMarchSteps = 1. / float(marchSteps);
    
    const float startDepth = 0.;
    const float endDepth = farPlane;
    
    vec3 increment = (endDepth - startDepth) * worldVector * rMarchSteps;
    // increment is 10 * pixelPos * 0.001953125
    rayPosition = increment + startDepth * worldVector;    
    // rayposition is increment (-0.0195325 <> 0.0195325) + 0 * -1<>1
        
    float os = 0.0;
    
    depth = 0.0;
    
    for (int i = 0; i < marchSteps; ++i, rayPosition += increment){
        float rayLength = length(rayPosition);
        calculateShape(rayPosition, os);
        
        depth = rayLength;
        
        if (calculateRayHit(os, rayLength)) break;
    }
}

// Function 2537
vec3 normal(vec3 p) {
 
    const float d = .001;
    
    vec3 left = vec3(p.x - d,p.yz);
    vec3 right = vec3(p.x + d,p.yz);
    vec3 up = vec3(p.x,p.y-d,p.z);
    vec3 down = vec3(p.x,p.y+d,p.z);
    vec3 front = vec3(p.xy,p.z-d);
    vec3 back = vec3(p.xy,p.z+d);
    
    float distLeft = distScene(left).dist;
    float distRight = distScene(right).dist;
    float distUp = distScene(up).dist;
    float distDown = distScene(down).dist;
    float distFront = distScene(front).dist;
    float distBack = distScene(back).dist;
    
    return normalize(vec3(distRight-distLeft,distDown-distUp,distBack-distFront));
    
}

// Function 2538
vec3 EstimateNormal(vec3 point)
{
    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),
                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),
                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));
}

// Function 2539
vec3 normal(in vec3 p)
{
    return normalize(vec3(
        map(p + E.yxx).dist - map(p - E.yxx).dist,
        map(p + E.xyx).dist - map(p - E.xyx).dist,        
        map(p + E.xxy).dist - map(p - E.xxy).dist
    ));
}

// Function 2540
vec3 castRay(vec3 p, vec3 rd) {
    CP cp = findIntersection(p, rd);
   
    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);
    calcRecursion(ray);
    ray.col = getRayColor(ray);
	return ray.col;
    
}

// Function 2541
vec3 normal(vec3 p){return normalize(vec3(cn(xyy),cn(yxy),cn(yyx)));}

// Function 2542
vec3 rayDirection(float fov, vec2 size, vec2 fragCoords) {
    // Center coordinate system 
    // Define x and y coordinates 
    vec2 xy = fragCoords - size / 2.0;
    // Find z
    float z = size.y / tan(radians(fov) / 2.0);
    // Return normalized direction to march 
    return normalize(vec3(xy, -z));
}

// Function 2543
void GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)
{
    vec3 vForwards = normalize(vInterest - vPos);
    vec3 vUp = vec3(0.0, 1.0, 0.0);

    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);
}

// Function 2544
vec4 raycastPlane(in vec3 rayOrigin, vec3 rayDirection, in float planeHeight)
{
 	float distanceToPlane = abs(rayOrigin.y - planeHeight);   
    rayDirection /= rayDirection.y;
    rayDirection *= distanceToPlane;
    vec3 hitPoint = rayOrigin + rayDirection;
    
    return vec4(hitPoint.x, hitPoint.z, hitPoint.y, length(rayDirection));
}

// Function 2545
Ray genRay( in vec2 pixel, in float Xi1, in float Xi2 ) {
    Ray ray;

    vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    
    ray.origin = camera.pos;
    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));

	return ray;
}

// Function 2546
bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 20.;
	float delta = b*b - c;
	if( delta < 0.0) 
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}

// Function 2547
float RayleighPhase(float m){return (3./4.)*(1.+m*m);}

// Function 2548
vec3 normal (in vec3 p, in float epsilon)
{
    vec2 e = vec2 (epsilon, .0);
    return normalize (vec3 (scene (p + e.xyy),
                            scene (p + e.yxy),
                            scene (p + e.yyx)) - scene (p));
}

// Function 2549
bool raySphereIntersect(const in vec3 orig, const in vec3 dir, const in float radius, out float t0, out float t1) {
    float b = dot(dir, orig);
    float c = dot(orig, orig) - (radius * radius);
	float test = b*b - c;
    // Intersection should have two points
    if (test <= 0.0) return false;
	test = sqrt(test);
	t0 = -b - test;
	t1 = -b + test;
	if (t0 > t1) t0 = t1, t1 = t0;
	return true;
}

// Function 2550
vec3
CalcNormal(vec3 p)
{
    vec2 e = vec2(0.0001, 0.0);
    return normalize(vec3(Map(p + e.xyy).x - Map(p - e.xyy).x,
                          Map(p + e.yxy).x - Map(p - e.yxy).x,
                          Map(p + e.yyx).x - Map(p - e.yyx).x
    ));
}

// Function 2551
vec3 raytrace(in vec2 uv)
{
    vec3 ro = vec3(uv, 0.0);
    vec3 rd = normalize(vec3(uv, 2.5));
    vec3 color = vec3(0.0);
    vec3 matColor = vec3(0.0);
    float atten = 1.0;
    float bounces = 1.0;
    float rx = (iMouse.x / iResolution.x * 2.0 - 1.0) * (PI * 2.0);
    float ry = (iMouse.y / iResolution.y * 2.0 - 1.0) * (PI * 2.0);
   	mat2 rxm = rot(rx);
    mat2 rym = rot(ry);
    
    ro.yz *= rym;
   	rd.yz *= rym;
    
    ro.xz *= rxm;
    rd.xz *= rxm;
    
    for (int i = 0; i < RAY_BOUNCES; ++i)
    {
        SceneData scene = raymarch(ro, rd);
        if (scene.material.emissive == 0)
        {
        	vec3 p = ro + rd * scene.dist;
            vec3 n = norm(p);

            if (scene.material.reflective < 1.0)
            {
                vec3 d = normalize(reflect(rd, n)) + randomUnitVector() * 0.5;
                vec3 o = p + d * 0.1;
                SceneData refScene = raymarch(o, d);
                atten *= 0.5;
                matColor += (refScene.material.color * atten);
                bounces += 1.0;
            }
            rd = n + randomUnitVector() * scene.material.reflective;
            ro = p + rd * 0.1;
            matColor += (scene.material.color) * atten;
            bounces += 1.0;                        
            atten *= 0.5;
        }
        else
        {
            color = mix(scene.material.color, matColor * scene.material.color, max(0.0, float(i)));
            break;
        }

    }
    
    color /= bounces;
    return color;
}

// Function 2552
vec3 Ray( float zoom, in vec2 fragCoord )
{
	return vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );
}

// Function 2553
vec3 map_Gsph_ray(vec3 ro, vec3 rd, vec3 nrm) {
	return refract(rd, nrm, 0.85);
}

// Function 2554
bool rayPlaneIntersection( Ray ray, Plane plane, out float t ){
    float dotVN = dot( ray.dir, plane.abcd.xyz );
   
	t = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;
    return ( t > 0.0 );
}

// Function 2555
vec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)
{
    #if OBJECT_TYPE == 0
    	return RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));
    #elif OBJECT_TYPE == 1
    	vec2 uv;
    	vec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);
    	if (dot(rayDir, ret.yzw) > 0.0)
            ret.yzw *= -1.0;
    	return ret;
    #else
    	vec2 rayMinMax = vec2(-1.0, 1000.0);
    	vec3 nearNormal;
    	vec3 farNormal;
    
    	float size = -0.5;
    	TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);
		TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   
    	TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);
		TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   
    	TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);
		TrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     

    	if (rayMinMax.x > rayMinMax.y)
            return vec4(-1.0);
    
    	if (rayMinMax.x > 0.0)
    		return vec4(rayMinMax.x, nearNormal);
    	else
            return vec4(rayMinMax.y, -farNormal);
    #endif
}

// Function 2556
vec3 Normal(vec3 p)
{
    vec3 off = vec3(NORMAL_OFFS, 0, 0);
    return normalize
    ( 
        vec3
        (
            Scene(p + off.xyz) - Scene(p - off.xyz),
            Scene(p + off.zxy) - Scene(p - off.zxy),
            Scene(p + off.yzx) - Scene(p - off.yzx)
        )
    );
}

// Function 2557
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.0002 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 2558
vec3 normal(vec3 pos){
    float normprecision = collisiondist*0.1;
    vec2 k = vec2(1.0, -1.0);
    return normalize(k.xyy*DE(pos+k.xyy*normprecision)+
                     k.yyx*DE(pos+k.yyx*normprecision)+
                     k.yxy*DE(pos+k.yxy*normprecision)+
                     k.xxx*DE(pos+k.xxx*normprecision));
}

// Function 2559
mat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )
{
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
    return mat3( uu, vv, ww );
}

// Function 2560
void RayInfo_Clear( inout RayInfo rayInfo )
{
    rayInfo = RayInfo( vec3(0), vec3(0), 0., -1., 1.0, -1, 0., vec3(0), vec3(1), -1, -1 );
}

// Function 2561
vec3 calcNormalWater( in vec3 pos )
{
    const vec3 eps = vec3(0.025,0.0,0.0);
    float v = sdWater(pos).x;	
	return normalize( vec3( sdWater(pos+eps.xyy).x - v,
                            eps.x,
                            sdWater(pos+eps.yyx).x - v ) );
}

// Function 2562
endif
raymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )
{
    MPt mp;
    for ( int it=0; it!=120; ++it )
    {
        vec3 here = start + dir * t;
        mp = map( here );
        if ( mp.distance < ( T_EPS * t ) || t > t_max )
        {
        	break;
        }
        #if 1
        // NOTE(theGiallo): this is to sample nicely the twisted things
        t += mp.distance * 0.4;
        #else
        t += mp.distance;
        #endif
    }
    if ( t > t_max )
    {
        t = -1.0;
    }
    return mp;
}

// Function 2563
vec3 getNormal(vec3 p) {
    return normalize(vec3(
        map(vec3(p.x+EPSILON,p.y,p.z))-map(vec3(p.x-EPSILON,p.y,p.z)),
        map(vec3(p.x,p.y+EPSILON,p.z))-map(vec3(p.x,p.y-EPSILON,p.z)),
        map(vec3(p.x,p.y,p.z+EPSILON))-map(vec3(p.x,p.y,p.z-EPSILON))
    ));
}

// Function 2564
vec4 MapTerrainReflections( vec3 p)
{
    treeDist = 10000.;
  float boatDist= 10000.;
  float bridgeDist=10000.;
  float height = GetTerrainHeight(p); 
  float tHeight= height + GetStoneHeight(p.xz, height);
  tHeight*=1.4;
  if (tHeight>0.)
  {
    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;  
               
      #ifdef TREES   
      vec3 treePos = p-vec3(0.,tHeight+2.,0.);
      vec2 mm = floor( treePos.xz/8.0 );	
	treePos.xz = mod( treePos.xz, 8.0 ) - 4.0;

      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);
      
      if(treeHeight>0.05)
      {             
          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));
                     treeDist+=(noise(p*1.26)*.6285);
         treeDist+=(noise(p*3.26)*.395);
           treeDist+=(noise(p*6.26)*.09825);
      }
    #endif
  }
  #ifdef BRIDGE
    bridgeDist=MapBridge(p);   
  #endif
    #ifdef BOAT
    #ifdef ACCURATE_BOAT_REFLECTION
    boatDist=MapBoat(p); 
    #else
    // fake boat by using ellipsoid
    boatDist=sdEllipsoid( TranslateBoat(p)- vec3(0, -0.20, -1.0), vec3(1.65, 1., 3.40));
    #endif
    
  #endif

    // mask tower position by placing a cone
    return  vec4(min(treeDist,min(min(boatDist, bridgeDist), min(p.y - max(tHeight, 0.), sdConeSection(p-vec3(-143, 0., 292)-vec3(0., 13., 0.), 10.45, 3.70, 1.70)))), boatDist, bridgeDist, tHeight);
}

// Function 2565
vec3 NormalBlend_Linear(vec3 n1, vec3 n2)
{
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;
    
	return normalize(n1 + n2);    
}

// Function 2566
float RayMarch(vec3 startPos, vec3 dir) {
	float depth = 0.0;
    for (int i = 0; i < 64; i++) {
        vec3 pos = startPos + dir * depth;
        float dist = SceneDistance(pos);
        if (dist < 0.0001) {
        	return depth;
        }
        depth += 0.6 * dist;
        if (depth >= MAX_DEPTH) {
            return MAX_DEPTH;
        }
    }
    return MAX_DEPTH;
}

// Function 2567
bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 8.;
	float delta = b*b - c;
	if( delta < 0.0) 
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}

// Function 2568
float raymarchGateShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {
    float sh = 1.0;
    float t = tmin;
    float breakOut = 0.0;
    int i = 0;
    while (i < 80 && breakOut != 1.0) {
        vec3 p = ro + rd * t;
        float d = map(p, false).y;
        sh = min(sh, 16.0 * d / t);
        t += 0.5 * d;
        if (d < (0.001 * t) || t > tmax)
            breakOut = 1.0;
        i++;
    }
    return sh;
}

// Function 2569
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.2,0.0,0.0);
    return normalize( vec3(
        map(pos+eps.xyy).x - map(pos-eps.xyy).x,
        map(pos+eps.yxy).x - map(pos-eps.yxy).x,
        map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 2570
vec3 computeNormalBox(vec3 p,Box b)
{
    
	// project on edges

	vec3 center = (b.bmax + b.bmin)/2.;
	vec3 halfSize = (b.bmax - b.bmin)/2.;
	vec3 nx = vec3(1.,0.,0.);
	vec3 ny = vec3(0.,1.,0.);
	vec3 nz = vec3(0.,0.,1.);

	vec3 f1 = center + nx*halfSize.x;
	vec3 f2 = center - nx*halfSize.x;

	vec3 f3 = center + ny*halfSize.y;
	vec3 f4 = center - ny*halfSize.y;

	vec3 f5 = center + nz*halfSize.z;
	vec3 f6 = center - nz*halfSize.z;


	// compute side distance
	if(abs(dot(f1-p,nx)) < 0.00001)
	{
		return nx;
	}
	if(abs(dot(f2-p,nx)) < 0.00001)
	{
		return -nx;
	}
	if(abs(dot(f3-p,ny)) < 0.00001)
	{
		return ny;
	}
	if(abs(dot(f4-p,ny)) < 0.00001)
	{
		return -ny;
	}

	if(abs(dot(f5-p,nz)) < 0.00001)
	{
		return nz;
	}
	if(abs(dot(f6-p,nz)) < 0.00001)
	{
		return -nz;
	}



	return normalize(vec3(1.,1.,1.));
}

// Function 2571
vec4 rayMarch(inout vec4 p, in vec4 rd, out vec4 dists) {
  float dS = 99., d = 0., minDS = dS, steps = 0.;
  for (int i = 0; i < MAX_STEPS; i++) {
    steps++;
    dS = mapWDists(p, dists);
    minDS = min(minDS, abs(dS));
    d += dS;
    p = p + rd * dS;
    if ((0. <= dS && dS < SURF_DIST) || d > MAX_DIST) break;
  }
  return vec4(d, dS, minDS, steps);
}

// Function 2572
Ray CreateRay(vec2 uv)
{
    // moveable cam
    vec3 p0, p1;
    p0=vec3(0.0, 2.0, 0.0);
    p1=vec3(0.0, 0.0, 3.0);

    vec2 vmouse;    
    if (iMouse.x<20.0)
    {
        // auto!
        const float introtime=17.3;
        const float beat = 4.02;
        if (iTime<introtime)
        {
        	vmouse = vec2(0.5+sin(iTime*0.3)*0.1, 0.25+sin(iTime*0.2)*0.15);
        }
        else
        {
        	float t = mod(iTime-introtime, beat);
            float s = floor((iTime-introtime) / beat);
            vec2 v1 = vec2(perlin(s, 1.0), 0.1+sqrt(perlin(s, 2.0))); 
            vec2 v2 = vec2(perlin(s, 3.0), 0.1+perlin(s, 4.0)*perlin(s, 4.0));
            
            if (mod(s,10.0)>=6.0 && mod(s,10.0)<=8.0)
            {
            	v1.y = 0.1+v1.y*0.25;    
            	v2.y = 0.1+v2.y*0.25;    
            }
            
            t=clamp(t/2.5, 0.0, 1.0);                   
            vmouse=mix(v1, v2, t*t*(3.0-2.0*t));            
        }
    }    
    else
    {
        vmouse = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);
    }    
	p0=vec3(0.0 + 16.0*vmouse.x - 8.0, 16.0*vmouse.y, 0.0);
    
    p0.z += iTime*g_movespeed;        
    p1.z += iTime*g_movespeed;    
                        
    Ray ray;
    float roll = 0.0;
    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);
    dir = normalize(dir);
    vec3 up = vec3(dir.x*roll, 1.0, 0.0);
    up = normalize(up);
    vec3 right = cross(dir, up);
    right = normalize(right);
    up = cross(right, dir);
    up = normalize(up);
    
    ray.pos = vec3(0.0, 0.0, 0.0) + p0;
    ray.dir = dir*0.8 + up*uv.y + right*uv.x;
    ray.dir = normalize(ray.dir); 
    return ray;
}

// Function 2573
void TraceRay( in vec3 rayOrigin, in vec3 rayDirection, out vec3 diffuseColor, out vec3 specularColor, out float depth, out int materialID)
{
    depth = SCENE_MAX_T;
    diffuseColor = specularColor = vec3(0.0);
    
    float t;
    materialID = INVALID_MATERIAL_ID;
    Intersect(rayOrigin, rayDirection, 0.1, DEFAULT_INTERSECT_FLAG, materialID, t);
    
    if( materialID != INVALID_MATERIAL_ID )
    {
        depth = t;
        vec3 position = rayOrigin + t*rayDirection;
        Material material = GetMaterial(materialID, position);
		if(IsLightSource(material))
        {
            diffuseColor = min(material.albedo, vec3(1.0));
            return;
        }       
        
        vec3 normal = GetNormal( position );
       	UpdateMaterial(materialID, position, normal, true, material);
        vec3 reflectionDirection = reflect( rayDirection, normal );
		
        CalculateLighting(position, normal, reflectionDirection, material, true, diffuseColor, specularColor);
    }
    else
    {
       diffuseColor = GetSkyColor(rayDirection);
    }
}

// Function 2574
vec4 raymarchSea(vec3 ro, vec3 rd, vec3 up, vec3 fwd, in mat3 cam,
                  in float tmin, in float tmax,
                  in vec3 Lo,
                  in vec3 Lcolor)
{
    if(tmax<0. || tmin<0.) return vec4(1., 0., 0., 0.);
    float maxTargetTravel = tmax-tmin;
    float cStep = 0.08;
    float vStep = maxTargetTravel*cStep;

    float t = 0.;
    if((length(ro+rd*tmin-EARTHPOS)-EARTHRADIUS)<tmin)
        return vec4(1., 0., 0., 1.);
    for(int i = 0;i<60;++i)
    {
        vec3 p = ro+rd*t;
        float depth = mapSea(p, up);
        if(depth<tmin || t>tmax) break;
        t += 0.5*depth;
    }

    float rdy = clamp((tmax-t)/(tmax-tmin), 0., 1.);
    
    rdy = exp(-10.*(t-tmin)/(tmax-tmin));
    
    vec4 c = vec4(1., 0., 0., clamp(rdy*rdy, 0., 1.));
    
    // lighting
    #if 1
    vec3 Pw = ro+rd*t;
    vec3 Nw = normalSea(Pw, up, fwd, 0.01);
    vec3 Lw = normalize(Lo-Pw);
    #if 0
    float tsmin = -1.0, tsmax = -1.0;
    float de = IntersectSphere(
        ro, rd, Lp, SUNRADIUS,
        tsmin, tsmax);
    vec3 H = normalize(-rd+normalize((ro+rd*tsmin)-Pw));
    #else
    vec3 H = normalize(-rd+Lw);
    #endif
    float NoL = dot(Nw, Lw);
    float NoV = dot(Nw, -rd);
    
    float HoN = max(0., dot(H, Nw));
    float F = clamp(Fresnel_Schlick(1., 1.033, NoV), 0., 1.);
    
    vec3 diffuse = mix(vec3(0.02, 0.25, 0.45), vec3(0.46, 0.71, 0.76), F);
    
    c.rgb = SUNINTENSITY * (
        diffuse*max(0., NoL)
        + diffuse*.2*max(0., dot(Nw, up))
        + Lcolor * pow(max(0., HoN), 64.)
        );
    c.a *= F;
    #else
        vec3 Pw = ro+rd*t;
        vec3 Nw = normalSea(Pw, up, fwd, 0.01);
    	c.rgb = oceanLighting(ro, rd, Lo, Pw, Nw, fwd, cross(fwd, up));
    //vec3 pouet;
    //c.rgb = getSkyLight(Pw, reflect(rd, vec3(0., 1., 0.)), Lo, SKY_BETA_RAY, SKY_BETA_MIE, pouet, SKY_MIE_HEIGHT);
    #endif
    
	return c;
}

// Function 2575
vec3 calcNormal( in vec3 pos, in float eps )
{
    vec3 kk;
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*map( pos + e.xyy, kk ).x + 
					  e.yyx*map( pos + e.yyx, kk ).x + 
					  e.yxy*map( pos + e.yxy, kk ).x + 
					  e.xxx*map( pos + e.xxx, kk ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*eps,kk).x;
    }
    return normalize(n);
#endif    
}

// Function 2576
MarchResult MarchRay(vec3 orig,vec3 dir)
{
    float steps = 0.0;
    float dist = 0.0;
    float id = 0.0;
    
    for(int i = 0;i < MAX_STEPS;i++)
    {
        vec2 object = Scene(orig + dir * dist);
        
        //Add the sky dome and have it follow the camera.
        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));
        
        dist += object.x * STEP_MULT;
        
        id = object.y;
        
        steps++;
        
        if(abs(object.x) < MIN_DIST * dist)
        {
            break;
        }
    }
    
    MarchResult result;
    
    result.position = orig + dir * dist;
    result.normal = Normal(result.position);
    result.dist = dist;
    result.steps = steps;
    result.id = id;
    
    return result;
}

// Function 2577
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.0002,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 2578
vec3 surfaceNormal(vec3 pos) {
 	vec3 delta = vec3(0.01, 0.0, 0.0);
    vec3 normal;
    normal.x = combinedDistanceOnly(pos + delta.xyz) - combinedDistanceOnly(pos - delta.xyz);
    normal.y = combinedDistanceOnly(pos + delta.yxz) - combinedDistanceOnly(pos - delta.yxz);
    normal.z = combinedDistanceOnly(pos + delta.zyx) - combinedDistanceOnly(pos - delta.zyx);
    return normalize(normal);
}

// Function 2579
vec3 calcNormal( in vec3 pos, in float objID, in Scene scn )
{
    if( objID<1.5 ) return nPlane();
    if( objID<2.5 ) return nTriangle( scn.v1, scn.v2, scn.v4 );
    if( objID<3.5 ) return nSphere( pos, vec4(scn.pA,0.07) );
    if( objID<4.5 ) return nSphere( pos, vec4(scn.pB,0.07) );
    if( objID<5.5 ) return nCylinder( pos, scn.pA, scn.pB, 0.02 );
    return vec3(0.0,1.0,0.0);
}

// Function 2580
float RayMarch(vec3 ro, vec3 rd, float fft) {
	float dO=-333.;
    float SURF_DIST = fft * 13.;
    if(iTime>9.8){
        SURF_DIST = 0.;
    }
    if(iTime>22.95){
        SURF_DIST = fft;
    }

    if(iTime>70.06){
        SURF_DIST = sin(iTime)*10.;
    }
    
    if(iTime>78.06){
        SURF_DIST = fft;
    }
    if(iTime>104.){
        SURF_DIST = 2.0 + sin(iTime * 0.5);
    }
    if(iTime>218.){
        SURF_DIST = 100.;
    }
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    return dO;
}

// Function 2581
vec4 raytrace(vec3 raydir, vec3 rayori){
    vec3 raypos = rayori, outCol = vec3(1.0), albedo, spec, norm;
    float depth, rough;
    uint objectid;
    for(uint i = 0U; i < maxbounces; i++){
        float intersection = intersect(raydir, raypos, norm, objectid);
        if(i == 0U){
            depth = intersection;
        }
        if(intersection <= 0.0){break;}
        raypos += raydir*intersection;
        raypos += norm*stepthreshold;
        getmat(objectid, raypos, albedo, spec, norm, rough);
        outCol *= albedo*fresnel(raydir, norm, spec);
        raydir = reflect(raydir, normalize(nrand3(rough, norm)));
    }

    // Return the Color of the Sky
    return vec4(outCol*skycol(raydir), depth);
}

// Function 2582
vec3 sampleReflectionMap(vec3 sp, float lodBias){    
    vec3 color = SRGBtoLINEAR(textureLod(reflectTex, sp, lodBias).rgb);
    #if defined (HDR_FOR_POORS)
    	color *= 1.0 + 2.0*smoothstep(0.7, 1.0, dot(LUMA, color)); //HDR for poors
   	#endif
    return color;
}

// Function 2583
vec3 calculateNormals(vec3 pos, vec3 lightPos)
{
	vec2 eps = vec2(0.0, EPSILON*2.0);
	vec3 n = normalize(vec3(
	distfunc(pos + eps.yxx, lightPos).x - distfunc(pos - eps.yxx, lightPos).x,
	distfunc(pos + eps.xyx, lightPos).x - distfunc(pos - eps.xyx, lightPos).x,
	distfunc(pos + eps.xxy, lightPos).x - distfunc(pos - eps.xxy, lightPos).x));
	return n;
}

// Function 2584
vec4 raySphere(vec3 rp, vec3 rd, vec3 pos, float radius) {
    rp -= pos;
    float c = dot(rp, rp)-radius*radius;
    float b = dot(rd, rp), 
        d = b*b - c;

    if (d >= 0.) {
        b = -b;
        float s = sqrt(d), t, n;
        if (s < b) {
            t = b-s;
            n = 1.;
        } else {
            t = b+s;
            n = -1.;
            if (t < 0.) return vec4(0,0,0,VIEW_DISTANCE);
        }
        return vec4(normalize(rp+rd*t)*n,t);
    }
    return NNO;
}

// Function 2585
vec3 calcNormal( in vec3 pos, in float cuttingPlane ) {
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for (int i = 0; i < 4; i++) {
        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);
        n += e * map(pos + 0.0005 * e, cuttingPlane).x;
    }
    return normalize(n);
}

// Function 2586
void initRay4Result ( inout Ray4Result _rayResult )
{
    _rayResult.m_d = MAX;
    _rayResult.m_object.m_id = -1;    
}

// Function 2587
vec3 gradientNormal(vec3 p//6tap 3d derivative. 
){vec2 e=vec2(0,GRADIENT_DELTA)
 ;return normalize(vec3
 (map(p+e.yxx).y-map(p-e.yxx).y
 ,map(p+e.xyx).y-map(p-e.xyx).y
 ,map(p+e.xxy).y-map(p-e.xxy).y));}

// Function 2588
void ray_march_scene(Ray r, float k, inout vec3 c)
{
    float uniform_step = k;
    float jit = 1.;
    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));
   
    float t_gen = 1.;

    float param_t = intersect_sphere(r, m.pos, RADIUS);
    if(param_t <= -1.)
        return;
    vec3 p = ray_interpolation(r, k*jit);        
     
    //rgb transparency               
    
    vec3 t_acc = vec3(1.);	// accumulated parameters for transparency
    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );
    
    for(int s = 10; s <110; s++)
    {               
        float dist_dist = dot(p-cam.pos, p-cam.pos);
        float dist_center = length(m.pos-cam.pos);
        vec3 center = p-m.pos;

        float d = length(center)-RADIUS-.5-jit*k;
        float size = length(center)/RADIUS;

        if(sdf_rounded_cylinder( center, 1.20, 0.2, 5. ) < 0.)
        {
            
            #if COLOR            
            #if ANIM      
            	anim = iTime/5.;
            
            #endif
            
            
            float n = fbm( ( 
                (p)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./size*anim) //shockwave stuff
            			) )  ;; ;
            // 1./size is the speed of the wave propgation 
            /////////////////////

            float mask = smoothstep(0.,
                                   	70.*RADIUS,
                                    RADIUS/length(center));

            
            //Optical density/depth : dens for density
            float dens = ( clamp( mask,
                               	  0.,
                                  1.) *n);
                        
           if(length(p-cam.pos) >(dist_center+m.radius) 
              )//|| (k*dens  < -9.9))
        	{
         	break;
        	}
            //How colors (rgb) are absorbed at point p in the current iteration
            //k is the step size          
             vec3 rgb_t = exp(-vec3(
                		k * 25. * f(p.x) * dens, 
                      	k * 10. * dens,
              	      	k * 15. * f(p.z) * dens ));    
                
    		//blending
   			c += t_acc*vec3(1.)*(1.-rgb_t);
                        t_acc *= (rgb_t);           

            #endif
        }

        //if it will never be in the shape anymore, return;        
        
        p += r.dir*k;

        k = uniform_step;
    }
    

    //c =float(s)/vec3(50,150,20); return;

    #if COLOR

    #else
    c = vec3(t_gen); return;
    #endif
}

// Function 2589
vec2 castRay(in vec3 ro, in vec3 rd, in float maxd) {
    bool withTree = intersectSphere(ro-vec3(0.,2.6,0.), rd, 2.7);
    // TODO intersect plane for landscape
    
	float precis=.004, h=precis*2., t=5.;
	float res;
    for( int i=0; i<60; i++ ) {		
		if (abs(h) < precis && t > maxd) break; 
        t += h;
        res = map0(ro+rd*t, withTree, true);
        h = res;
    }
    return vec2(t, (t<maxd) ? map(ro+rd*t, withTree, true).y : -1.);
}

// Function 2590
ray camera_get_ray(camera c, vec2 uv) {
    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);
    vec3 offset = c.u * rd.x + c.v * rd.y;
    return ray(c.origin + offset, 
               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),
               mix(c.time0, c.time1, hash1(g_seed)));
}

// Function 2591
vec3 traceRay(Ray r)
{
    
    HitRecord hit;
    
    if (hitSpheres(r, spheres, hit))
    {
        return hit.col;
        
    }
    
    return vec3(0.0,0.0,0.0);
}

// Function 2592
vec3 rayDir(float fov, vec2 size, vec2 pos)
{
    vec2 xy = pos - size * 0.5;
    
    float cotHalfFOV = tan((90.0 - fov * 0.5) * DEG_TO_RAD);
    float z = size.y * 0.5 * cotHalfFOV;
    
    return normalize(vec3(xy, -z));
}

// Function 2593
vec3 rayCast(vec3 eye, vec3 ref, vec2 uv) {

    float len = tan(FOVY) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * iResolution.x / iResolution.y;
    vec3 p = ref + uv.x * H + uv.y * V;
    return normalize(p - eye);
}

// Function 2594
float cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){
	//horner's method
	vec2 a_2=a2+t*a3;
	vec2 a_1=a1+t*a_2;
	vec2 b_2=a_2+t*a3;

	vec2 uv_to_p=a0+t*a_1;
	vec2 tang=a_1+t*b_2;

	float l_tang=dot(tang,tang);
	return t-dot(tang,uv_to_p)/l_tang;
}

// Function 2595
vec2 spray(vec2 uv, vec2 center, vec2 dir, float strength, float eyeWall){
	vec2 d = uv - center;
	return vec2(d.x, d.y)/(dot(d,d)/strength+eyeWall)*dot(d,dir);
}

// Function 2596
float dsqSegmentRay(vec3 a, vec3 b, vec3 p, vec3 nv) {
    float tMinA = max(0.0, minPointLine(p, nv, a));
    float tMinB = max(0.0, minPointLine(p, nv, b));
    float dsqMin = min(
        dsq( a, p + tMinA*nv ),
        dsq( b, p + tMinB*nv )
    );

    float lenSeg = length(a - b);
    vec3 nvSeg = (a - b) / lenSeg;

    float sMinP = clamp(minPointLine(b, nvSeg, p), 0.0, lenSeg);
    dsqMin = min( dsqMin, dsq(p, b + sMinP*nvSeg) );

    vec2 minInterior = minLineLine(b, nvSeg, p, nv);
    if (minInterior.s > 0.0 && minInterior.s < lenSeg && minInterior.t > 0.0) {
        vec3 cpSeg = b + minInterior.s*nvSeg;
        vec3 cpLine = p + minInterior.t*nv;
        dsqMin = min( dsqMin, dsq(cpSeg, cpLine) );
    }

    return dsqMin;
}

// Function 2597
vec3 normal(vec3 p)
{
    vec2 e = vec2(.0001,0);
    vec3 n=  vec3 (map(p+e.xyy).x-map(p-e.xyy).x,map(p+e.yxy).x-map(p-e.yxy).x,map(p+e.yyx).x-map(p-e.yyx).x);
    return normalize(n);
}

// Function 2598
void getRay(out vec3 ro, out vec3 rd, vec2 pos, ivec2 p)
{
    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;
 	mat3 camera = getCamera(angles);
    int kk = int(iMouse.z);
  	//dither position on the aperture
    vec4 blue = texture(iChannel2, vec2(p)/1024. + PI*iTime);
    int I = int(blue.x * float(Nsamp));
    
    pos += (blue.yz - 0.5)/iResolution.x;
    vec2 delta = 2.*aperture*fcircle(I, Nsamp);
    vec3 ro0 = vec3(delta.x, 0., delta.y);
    vec3 rd0 = focal_plane*vec3(FOV*pos.x, 1, FOV*pos.y) - ro0;
    
    ro = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0).xyz + transpose(camera)*ro0;
    rd = normalize(transpose(camera)*rd0);
}

// Function 2599
bool Raycylinderintersect(vec3 org, vec3 dir, out float near, out float far)
{
	// quadratic x^2 + y^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 = 0.5
	float a = dot(dir.xy, dir.xy);
	float b = dot(org.xy, dir.xy);
	float c = dot(org.xy, org.xy) - 12.;

	float delta = b * b - a * c;
	if( delta < 0.0 )
		return false;

	// 2 roots
	float deltasqrt = sqrt(delta);
	float arcp = 1.0 / a;
	near = (-b - deltasqrt) * arcp;
	far = (-b + deltasqrt) * arcp;
	
	// order roots
	float temp = min(far, near);
	far = max(far, near);
	near = temp;

	float znear = org.z + near * dir.z;
	float zfar = org.z + far * dir.z;

	// top, bottom
	vec2 zcap = vec2(1.85, -1.85);
	vec2 cap = (zcap - org.z) / dir.z;

	if ( znear < zcap.y )
		near = cap.y;
	else if ( znear > zcap.x )
		near = cap.x;

	if ( zfar < zcap.y )
		far = cap.y;
	else if ( zfar > zcap.x )
		far = cap.x;
	
	return far > 0.0 && far > near;
}

// Function 2600
int raycast( in vec3 ro, in vec3 rd, out vec3 oUVT)
{
    int   obj = 0;
    float tmin = 2.0;
    float tmax = 5.0;
    vec2  uv = vec2(0.0);

    // floor
    #ifdef SHADOWS
    float tf = (-2.0 - ro.y) / rd.y;
    if( tf>0.0 ) { tmax=min(tmax,tf); obj=1; oUVT = vec3(0.0,0.0,tf); }
    #endif

    // bounding sphere
    vec2 bs = iSphere(ro,rd,vec4(0.0,0.0,0.0,sqrt(3.0)+kRoundness));
    if( bs.y>0.0 )
    {
        tmin = max(tmin,bs.x); // clip search space
        tmax = min(tmax,bs.y); // clip search space
        
        // rayamarch cube
        float t = tmin;
        for( int i=0; i<256; i++ )	
        {
            vec3 pos = ro + t*rd;
            vec3 duv = map(pos);
            uv = duv.yz;
            if( (duv.x)<0.001 ) break;
            t += duv.x;
            if( t>tmax ) break;        
        }

        if( t<tmax )
        {
            obj = 2;
            oUVT = vec3(uv,t);
        }
    }

    return obj;
}

// Function 2601
void raymarch(vec3 from, vec3 increment)
{
	const int   kMaxIterations = 60;
	const float kHitDistance   = 0.01;
	
	marchDistance    = -15.0;
	marchMaterial    = -1.0;
	
	for(int i = 0; i < kMaxIterations; i++)
	{
		distanceField(from + increment * marchDistance);
		if (fieldDistance > kHitDistance)
		{
			marchDistance += fieldDistance;
			marchMaterial  = fieldMaterial;
		}
	}
	
	marchPosition = from + increment * marchDistance;
    if (marchDistance > 32.0)
        marchMaterial = -1.0;
}

// Function 2602
float raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {
	radius = radius * radius;
	float dt = dot(rdir, sp - rpos);
	if (dt < 0.0) {
		return -1.0;
	}
	vec3 tmp = rpos - sp;
	tmp.x = dot(tmp, tmp);
	tmp.x = tmp.x - dt*dt;
	if (tmp.x >= radius) {
		return -1.0;
	}
	dt = dt - sqrt(radius - tmp.x);
	point = rpos + rdir * dt;
	normal = normalize(point - sp);
	return dt;
}

// Function 2603
SDObject castRay( in Ray ray )
{
    //clip planes
    float tmin = .10;
    float tmax = 20.0;

   
    float precis =0.00001;//(state.y+1.<iTime)?0.0001:0.003;
    float t = tmin;
	SDObject res;
    vec3 p;
    for( int i=0; i<200; i++ )
    {
        p=ray.ro+ray.rd*t;
         res = mapScene( p );
        if( res.d<precis || t>tmax ) break;
        t += res.d;
    }

    if( t>tmax ) return noSDObject();

    return res;
}

// Function 2604
vec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {
  vec2 p = -1.0 + 2.0 * uv;
  p.x *= invSize.y / invSize.x;
  vec3 rd = normalize(view * vec3(p, 2.0));
  return render(origin, rd);
}

// Function 2605
vec2 castRay(vec3 ro, vec3 rd, float maxt)
{
    float dt = 0.01f;
    float mint = 0.001f;
    float resT = 0.0f;
    float d = 1.0;
    for( float t = mint; t < maxt; t += dt )
    {
        vec3 p = ro + rd*t;
        float h = getHeightMap(p.xz);
        d = min(d, 4.0*(abs(h-p.y)/t));
        if( p.y < h)
        {
            resT = t - 0.8f*dt;
            return vec2(resT, d);
        }
    }
    return vec2(-1.0, d);
}

// Function 2606
vec3 normal(vec3 p)
{
    vec2 e = vec2(.0001, .0);
    float d = map(p);
    vec3 n = d - vec3(
        map(p - e.xyy*p),
        map(p - e.yxy*p),
        map(p - e.yyx*p));
    return normalize(n);
}

// Function 2607
vec3 castRay(vec3 pos, vec3 dir)
{
    //Initialize RayMarching
    vec3 p = pos;
    float rl = 0.0;
    
    vec3 color = vec3(0);//Output color
    
    float near = FAR;
    float iters = 0.0;
    
    //March
    for(int i = 0; i < MAX_ITER; i++)
    {
        near = map(p);//Nearest surface distance
        
        rl += near;
        if(near <= DELTA || rl > FAR)//If the ray hits something
        {
            break;
        }
        p += STEP_SIZE*near*dir;//March forward
        iters++;
    }
    
    if(near >= DELTA)//If the point is outside a volume
    {
        vec3 a = SKY_COLOR;
        vec3 b = GLOW_COLOR;
        float n = pow(iters/float(MAX_ITER), 1.0/GLOW_POWER);
        color = mix(a,b,n);
    }
    else
    {
        vec2 delta = vec2 (DELTA, 0.0);
		vec3 normal = normalize (vec3 (
			map (p + delta.xyy) - map (p - delta.xyy),
			map (p + delta.yxy) - map (p - delta.yxy),
			map (p + delta.yyx) - map (p - delta.yyx)));
        
        float lightFactor = getLightFactor(p,normal);
        
        vec3 sky = GLOW_COLOR;
        
        vec2 ss = p.xz*2.0;
        
        color = vec3(texture(iChannel0, mod(ss.xy/30.0,vec2(1))).r/1.7,texture(iChannel0, mod(ss.xy/30.0,vec2(1))).g/1.5,0);
        color = mix(color,sky/3.0,1.0-lightFactor);
        float fog = clamp(rl / FAR,0.0,1.0);
        color = mix(color,GLOW_COLOR,fog);
    }
   	
    //color += vec3(pow(iters/float(MAX_ITER), 1.0/GLOW_POWER));
    //fog
    return color;
}

// Function 2608
sdf_result send_ray_from_to(vec3 from,vec3 to,int maxIters){
    return send_ray(from,to-from,maxIters);
}

// Function 2609
float RayMarch(vec3 ro, vec3 rd) {
    float dO = 0.;
    

    for (int i = 0; i<MAX_STEPS; i++) {
        vec3 p = ro+dO*rd;
        float dS = GetDist(p);
        dO+=dS;
        if(dS<SURF_DIST || dO>MAX_DISTANCE) break;
    }
        return dO;    
}

// Function 2610
vec3 distance_field_normal(in vec3 pos) {
    const float eps = 0.1;
    float d  = signed_distance(pos);
    float nx = signed_distance(pos + vec3(eps, 0.0, 0.0)) - d;
    float ny = signed_distance(pos + vec3(0.0, eps, 0.0)) - d;
    float nz = signed_distance(pos + vec3(0.0, 0.0, eps)) - d;
    return normalize(vec3(nx, ny, nz));
}

// Function 2611
vec4 castRay( in vec3 ro, in vec3 rd ,out vec3 n_out)
{
    float tmin = CAMERA_NEAR;
    
    float precis = PRECISION_STEP;
    
    vec3 m =  vec3(-2.0);
    n_out =vec3(0.0);
    vec4 traced = trace(ro,rd,n_out);
    float tmax =min(CAMERA_FAR,traced.x);
    float t = tmin;
    vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);
    
    if(traced.x < CAMERA_FAR)
        return traced;
    
    
    n_out=vec3(0);
    m=vec3(-2.0);
    return vec4( CAMERA_FAR, m.x,m.y,m.z );
}

// Function 2612
vec3 calcNormal( in vec3 pos )
{
    const vec3 v1 = vec3(1.0,0.0,0.0);
    const vec3 v2 = vec3(0.0,1.0,0.0);
    const vec3 v3 = vec3(0.0,0.0,1.0);

	return normalize(vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))
                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)));
}

// Function 2613
vec3 ObjectNormal(vec3 p)
{
    float eps = 0.002;
    vec3 n;
    float v = object(p);
    n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;
    n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;
    n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;

    return normalize(n);
}

// Function 2614
float getRayleigMultiplier(vec2 p, vec2 lp)
{
    float dist = greatCircleDist(p, lp)/pi*5.;
	return 1.0 + pow(1.0 - clamp(dist, 0.0, 1.0), 2.0) * pi * 0.5;
}

// Function 2615
vec3 getNormal (vec2 p) {
    return normalize(
        cross(
            vec3(
                epsilon,
                0.,
                y(vec2(p.x+epsilon, p.y))-y(p)
            ),
            vec3(
                0.,
                epsilon,
                y(vec2(p.x, p.y+epsilon))-y(p)
            )
       	)
    );
}

// Function 2616
vec2 castRay( in vec3 ro, in vec3 rd )
{
    const float maxd = 10.0;
    
	vec2 h = vec2(1.0,0.0);
    vec2 t = vec2(0.0);
   
    for ( int i = 0; i < 50; ++i )
    {
        if ( h.x < 0.001 || t.x > maxd ) 
        {
            break;
        }
        
	    h = Scene( ro + rd * t.x );
        t = vec2(t.x+h.x, h.y);
    }

    if ( t.x > maxd )
    {
        t.x = -1.0;
    }
	
    return t;
}

// Function 2617
vec3 calcNormal( in vec3 p )
{

	vec3 e = vec3(0.001,0.0,0.0);
	return normalize( vec3(map(p+e.xyy) - map(p-e.xyy),
						   map(p+e.yxy) - map(p-e.yxy),
						   map(p+e.yyx) - map(p-e.yyx) ) 
					);
						   
}

// Function 2618
vec4 raycast( in vec3 ro, in vec3 rd )
{
    vec4 res = vec4(-1.0, 0.0, 0.0, 0.0);
    
    vec2 tminmax = iSphere( ro, rd, 100.0 );
	if( tminmax.y>0.0 )
    {
        float t = max(tminmax.x,0.001);
        for( int i=0; i<256 && t<tminmax.y; i++ )
        {
            vec4 h = map(ro+t*rd);
            if( h.x<0.001 ) { res=vec4(t,h.yzw); break; }
            t += h.x;
        }
    }
    
    return res;
}

// Function 2619
float eyeRayToSphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)
{
    vec3 L = rayOrigin - sphereOrigin;
	float a = dot(rayDirection, rayDirection);
	float b = 2.0 * dot(rayDirection, L);
	float c = dot(L, L) - sphereRadius * sphereRadius;
	vec2 results = solveQuadratic(a, b, c);
    return results.x;
    
}

// Function 2620
void raytraceBranchShelf(vec3 rayPt, vec3 rayDir, vec3 shelfOrigin, float shelfRad, float shelfPitch, float shelfYawOff){
    
    float shelfHeight = sin(shelfPitch)*shelfRad;
    float shelfWidth = cos(shelfPitch)*shelfRad;
    
    float dummyDist;
    if (!testAABB(rayPt, rayDir,
                  shelfOrigin-vec3(0.0,shelfHeight,0.0),
                  vec3(shelfWidth,abs(shelfHeight)+2.0,shelfWidth),//hardcoded box height padding
                  dummyDist)) return;
    
    
    const int branchesAround = 8;
    for(int i=0; i<8; i++){
    	raytraceBranch(rayPt,rayDir,shelfOrigin,shelfRad,shelfPitch,shelfYawOff + PI*float(i)/float(branchesAround)*2.0);
    }
    
    #ifdef DRAW_CLIP_RAYTRACES
    color = mix(color,vec3(0.0,0.0,1.0),0.1);
    #endif
}

// Function 2621
float reflections_ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	
    float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {        
		float dist = coolThing( ( origin + dir * depth )/2.0, 1.7)*2.0;
        dist -= dist*0.95;
		if ( dist < stop_threshold ) {
			return depth;
		}
		depth += dist;
		if ( depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 2622
vec3 calcNormalOpaque( in vec3 pos, in float eps )
{
    vec4 kk;
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + 
					  e.yyx*mapOpaque( pos + e.yyx, kk ).x + 
					  e.yxy*mapOpaque( pos + e.yxy, kk ).x + 
					  e.xxx*mapOpaque( pos + e.xxx, kk ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*mapOpaque(pos+eps*e,kk).x;
    }
    return normalize(n);
#endif    
}

// Function 2623
vec4 Raymarch(Ray ray)
{
    float depth = 0.0;
    vec3 position = vec3(0.0);
    for(int i = 0; i < RAYMARCHING_MAX_STEPS; ++i)
    {
        position = ray.origin + (depth * ray.direction);
        float distance = SceneSD(position);
        
        if(distance < RAYMARCHING_THRESHOLD || distance >= RAYMARCHING_MAX_DEPTH)
        {
            break;
        }
        
        depth += distance;
    }
    
    return vec4(position, depth);
}

// Function 2624
float castray(vec3 ro, vec3 rd) {
    float d = 1.;
  	float inc;
    for(int i=0; i< ITERATIONS;i++) {
        vec3 p = ro + d * rd;
     	inc = sdScene(p);
        d += inc;
        if(d > MAX_DISTANCE || inc <= MIN_DISTANCE) break;
    }
    return d;
}

// Function 2625
vec4 normalize_plane(vec4 pl) {
    return pl / length(pl.xyz);
}

// Function 2626
vec3 calcNormal(in vec3 pos, in vec3 dir)
	{
		const vec3 eps = vec3(0.001, 0.0, 0.0);
		vec3 n = vec3(	sceneMap(pos+eps.xyy, dir).x - sceneMap(pos-eps.xyy, dir).x,
						sceneMap(pos+eps.yxy, dir).x - sceneMap(pos-eps.yxy, dir).x,
						sceneMap(pos+eps.yyx, dir).x - sceneMap(pos-eps.yyx, dir).x );
		return normalize(n);
	}

// Function 2627
vec3 ray_dir(vec2 screen_pt, float t) {
    // let's pretend the camera's on an airplane. point the yaw axis along the
    // lift vector for a perfect banked turn
    const vec3 gravity = vec3(0., -120., 0.);
    vec3 roll_ax = normalize(cam_vel(t));
    vec3 thrust_lift = cam_accel(t) - gravity;
    vec3 lift = thrust_lift - dot(roll_ax, thrust_lift)*roll_ax;
    vec3 yaw_ax = normalize(lift);
    vec3 pitch_ax = cross(roll_ax, yaw_ax);
    
    vec3 screen_dir = normalize(vec3(screen_pt, -1.));
    return mat3(pitch_ax, yaw_ax, -roll_ax) * screen_dir;
}

// Function 2628
vec3 calcNormal(vec3 pt)
{
    const vec3 smallStep = vec3(gradStep, 0.0, 0.0);
    
    float gradX = world(pt + smallStep.xyy) - world(pt - smallStep.xyy);
    float gradY = world(pt + smallStep.yxy) - world(pt - smallStep.yxy);
    float gradZ = world(pt + smallStep.yyx) - world(pt - smallStep.yyx);

    vec3 normal = vec3(gradX, gradY, gradZ);

    return normalize(normal);
}

// Function 2629
vec3 getNormals(vec3 p){
    const vec2 eps = vec2(EPSILON, 0);
    return normalize(vec3(map(p + eps.xyy).d - map(p - eps.xyy).d,
                          map(p + eps.yxy).d - map(p - eps.yxy).d,
                          map(p + eps.yyx).d - map(p - eps.yyx).d));
}

// Function 2630
float getNormalizedBAP(BreakdownAnimationPhase bas, float id){
	if(id == bas.id)
        return bas.phase;
    else
        return step(id, bas.id);
}

// Function 2631
RayHit RaymarchScene(in Ray ray)
{
    RayHit hit;
    
    hit.hit      = false;
    hit.material = 0.0;
    
    float sdf   = FarClip;
    int   steps = 0;
    
    for(float depth = NearClip; (depth < FarClip) && (steps < MarchSteps); ++steps)
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf < Epsilon)
        {
            hit.hit      = true;
            hit.surfPos  = pos;
            hit.surfNorm = Scene_Normal(pos);
            
            return hit;
        }
        
        depth += sdf;
    }
    
    return hit;
}

// Function 2632
vec3 calcNormal( in vec3 pos )
{
    vec2  eps = vec2(0.001,0.0);
    return normalize( vec3( map(pos+eps.xyy) - map(pos-eps.xyy),
                            map(pos+eps.yxy) - map(pos-eps.yxy),
                            map(pos+eps.yyx) - map(pos-eps.yyx) ) );
}

// Function 2633
vec3 Normal( vec3 pos, float rad )
{
	vec2 delta = vec2(0,rad);
	vec3 grad;
	grad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );
	grad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );
	grad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );
	return normalize(grad);
}

// Function 2634
vec3 Normal(vec3 p) 
{
	float d = Scene(p);
    vec2 e = vec2(.01, 0);
    
    vec3 n = d - vec3(
        Scene(p-e.xyy),
        Scene(p-e.yxy),
        Scene(p-e.yyx)
    );
    
    return normalize(n);
}

// Function 2635
vec3 getNormal(vec3 pos, float e, bool inside)
{  
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e2*map_smooth(pos + e*e2);
    }
    return (inside?-1.:1.)*normalize(n);
}

// Function 2636
vec3 Scene_GetNormal( const in vec3 vPos )
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;
    
    return normalize( vNormal );
}

// Function 2637
vec3 simple_refract( vec3 I, vec3 N ) { return  I - .8 * ( 1.5 - dot( N, I ) ) * N; }

// Function 2638
float unpackNormal( const in vec4 value ){ return dot( value, bitShR );}

// Function 2639
float rayMarch( in vec3 ro, in vec3 rd, float tmax, in vec3 samples123 )
{
    float t = 0.0;
    
    // bounding plane
    float h = (1.0-ro.y)/rd.y;
    if( h>0.0 ) t=h;

    // raymarch
    for( int i=0; i<20; i++ )    
    {        
        vec3 pos = ro + t*rd;
        float h = map( pos, samples123.x );
        if( h<0.001 || t>tmax ) break;
        t += h;
    }
    return t;    
}

// Function 2640
vec3 getNormal(vec3 p)
{
    vec2 e=vec2(PRECISION,0);
    return(normalize(vec3(map(p+e.xyy).d-map(p-e.xyy).d
                          ,map(p+e.yxy).d-map(p-e.yxy).d
                          ,map(p+e.yyx).d-map(p-e.yyx).d)));}

// Function 2641
float rayMarcher(vec3 ro, vec3 rd){
	float tot = 0.;
    for(int i=0;i<MAX_DIST;i++){
    	vec3 p = ro+rd*tot;
        float diff = SDF(p);
        tot+=diff;
        if(diff<EPSI || tot>float(MAX_DIST)){
        	tot = float(i)/float(MAX_DIST-500);
            break;
        }
    }
    return tot;
}

// Function 2642
vec3 reflection(vec3 dir, vec3 n){
	return -dir + 2.0f * n * dot(dir, n);
}

// Function 2643
vec3 normalFunction(vec3 p)
{
	const float eps = 0.01;
	float m;
    vec3 n = vec3( (distanceField(vec3(p.x-eps,p.y,p.z),m) - distanceField(vec3(p.x+eps,p.y,p.z),m)),
                   (distanceField(vec3(p.x,p.y-eps,p.z),m) - distanceField(vec3(p.x,p.y+eps,p.z),m)),
                   (distanceField(vec3(p.x,p.y,p.z-eps),m) - distanceField(vec3(p.x,p.y,p.z+eps),m))
				 );
    return normalize( n );
}

// Function 2644
vec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )
{
/*  we have to do animation here to get motion blur - which is a bit shit
	would be better if we stored cylinder list in a buffer, with previous frame's list on the next row
	but that would limit us to linear interpolations (of end points - so rotation would shorten cylinders! eek)*/
/*	// animate moving objects
    float r = -(time+sin(time))*10.;
    float a = time/3.;
    vec3 d = vec3(cos(r),0,sin(r))*cos(a)+vec3(0,sin(a),0);
    vec3 cp = vec3(.8,.5,3);
    Scene[0] = vec4(cp+d*.03,.5);
    Scene[1] = vec4(cp-d*.03,5);
    cp = vec3(-1.3,.5,0);
    d.x = -d.x;
    Scene[2] = vec4(cp+d*.3,.3);
    Scene[3] = vec4(cp-d*.3,5);*/
    
    vec3 normal = vec3(0);
    int material = 0;
    float t = Trace(normal,material,pos,ray);
    
    vec3 col = Sky(ray);
    if ( length(normal) > 0. )
    {
        pos += ray*t;

        Material mat = GetMaterial(pos,normal,material);
        
        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );
        if ( length(mat.specularColour) == 0. ) fresnel = vec3(0); // override fresnel if spec colour is 0 - e.g. for emissive shapes

        float specPower = 1./(mat.roughness*mat.roughness);
        float specStrength = (specPower+8.)/(4.*tau);

        
        // sample specular or diffuse bounced light
        float proportionSpecular = Grey(fresnel)/(Grey(mat.albedo) + Grey(fresnel));
        bool tapIsSpecular = ( rand.w+.5 < proportionSpecular );
        
        
        // randomize reflection direction with Blinn-Phong probability distribution
        vec3 microfacet = PowRand( rand.yz, normal, tapIsSpecular ? specPower : 1. );
        
        // sample reflection
        vec3 diffuse = vec3(0);
        vec3 reflection = vec3(0);
        vec3 tapalb = vec3(0);
        vec3 tapn = vec3(0);
        vec3 tappos = pos;
        float tapemi = 0.;
        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera
        {
            vec3 tapray = tapIsSpecular ? reflect(ray,microfacet) : microfacet;
            int tapmati = 0;
            float tapt = Trace(tapn,tapmati,pos,tapray);

            if ( length(tapn) > 0. )
            {
                tappos = pos+tapray*tapt;
                Material tapmat = GetMaterial(tappos,tapn,tapmati);

                // turn metallic surfaces into a sky-tinted diffuse surface, because we're doing no more bounces
                vec3 bounce2 = Sky(reflect(tapray,tapn)); // would be good if I could blur this
                tapalb = mix(tapmat.albedo,bounce2,tapmat.specularColour);
                tapemi = tapmat.emissive;

                vec3 ambient = Sky(tapn);
                //vec3 ambient = mix(vec3(.1),vec3(.5),tapn.y*.5+.5);
                vec3 bounceLight = mix( ambient, vec3(1), tapemi );
                bounceLight = mix(tapmat.albedo*bounceLight,bounce2,tapmat.specularColour);
                if ( tapIsSpecular )
                    reflection += bounceLight / proportionSpecular;
                else
                    diffuse += bounceLight / (1.-proportionSpecular);
            }
            else
            {
                // reflected ray didn't hit an object
                vec3 bounceLight = Sky(tapray);
                if ( tapIsSpecular )
                    reflection += bounceLight / proportionSpecular;
                else
                    diffuse += bounceLight / (1.-proportionSpecular);
            }
        }

/* actually doing bounces now
		// ambient light
        vec3 ambientColour = vec3(0);//.05,.065,.09);
        vec3 diffuse = ambientColour*(normal.y*.3+1.);
        if ( length(tapn) > 0. ) reflection += tapalb * ambientColour*(tapn.y*.3+1.);
*/
        for ( int i=0; i < lights.length(); i++ )
        {
/*
	>vec3 position;
    >vec3 target; distance falloff
    >vec3 colour;
    float innerRadius; // at target
    float outerRadius;
    >float sourceRadius; // area lighting

lights*/
        

            // sample light
            vec3 sun = normalize(lights[i].position-pos);//normalize(lights[i].position-lights[i].target);

            // soften shadow by sampling radius around sun
            vec3 suntap = sun;
            if ( lights[i].sourceRadius > 0. )
            {
                vec3 areaLight = PowRand( rand.zx, -sun, 1. );
                suntap = normalize( lights[i].position + areaLight*lights[i].sourceRadius - pos );
            }

            float ndotl = max(0.,dot(normal,sun));
            float ndoth = max(0.,dot(normal,normalize(-ray+sun)));

            vec3 lightCol = lights[i].colour;
            float lightStrength = 1./dot(pos-lights[i].position,pos-lights[i].position);
            float cosa = dot(sun,normalize(lights[i].position-lights[i].target));
            float angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );
            angleFade = angleFade*angleFade;
            lightStrength *= angleFade;

            if ( cosa > 0. && angleFade > .001 )//&& lightStrength > 0.001 ) this light strength test is ignoring base brightness, which is wrong
            {
                vec3 testn = vec3(0);
                int ignore;
                float st = Trace(testn,ignore,pos,suntap);
                if ( length(testn) == 0. || st > length(lights[i].position-pos) ) // we didn't hit anything before the light
                {
                    vec3 lightC = lightCol*lightStrength;

                    // diffuse
                    diffuse += ndotl * lightC;

                    // specular
                    reflection += lightC * ndotl*pow(ndoth,specPower)*specStrength;
                }
			}
			else
            {
                //if ( cosa > 0. && lightStrength > .0005 ) diffuse += lights[i].colour*.1; // show bounding volumes
        	}

            if ( length(tapn) > 0. )
            {
                //lightCol = lights[i].colour / dot(refpos-lights[i].position,refpos-lights[i].position);
                // just reuse the light on the reflector

                sun = normalize(lights[i].position-tappos);

// disabled this if it doesn't make a difference (e.g. sun-lit scenes)
#if 0 
				// recompute light strength for the reflected position
				// not sure if this looks right
                lightStrength = 1./dot(tappos-lights[i].position,tappos-lights[i].position);
                cosa = dot(sun,normalize(lights[i].position-lights[i].target));
                angleFade = 0.;
                if ( cosa > 0. ) angleFade = smoothstep( lights[i].outerRadius, lights[i].innerRadius, sqrt(1.-cosa*cosa) );
                lightStrength *= angleFade*angleFade;
#endif
                vec3 lightC = lightCol*lightStrength;

                
                // apply light to reflected object!
                vec3 bounceLight = tapalb * mix( max(0.,dot(tapn,sun)) * lightC, vec3(0), tapemi );
                if ( tapIsSpecular )
	                reflection += bounceLight / proportionSpecular;
                else
	                diffuse += bounceLight / (1.-proportionSpecular);
            }
        }

        col = mat.albedo * diffuse;

        col = mix( col, reflection, fresnel );
        
        col = mix( col, mat.albedo, mat.emissive );
    }
    
    return col;
}

// Function 2645
vec4 ray_cylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra ){
    vec3 ca = pb-pa;
    vec3 oc = ro-pa;
    float caca = dot(ca,ca);
    float card = dot(ca,rd);
    float caoc = dot(ca,oc);
    float a = caca - card*card;
    float b = caca*dot( oc, rd) - caoc*card;
    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;
    float h = b*b - a*c;
    if( h<0.0 ) return vec4(-1.0); //no intersection
    h = sqrt(h);
    float t = (-b-h)/a;
    // body
    float y = caoc + t*card;
    if( y>0.0 && y<caca ) return vec4( (oc+t*rd-ca*y/caca)/ra, t );
    // caps
    t = (((y<0.0)?0.0:caca) - caoc)/card;
    if( abs(b+a*t)<h ) return vec4( ca*sign(y)/caca, t );
    return vec4(-1.0); //no intersection
}

// Function 2646
vec2 rayMarching(in vec3 camPos, in vec3 rayDirection)
{
    float dMin = 1.;
    float dMax = 50.;
    float precis = 0.002;
    float traveledDistance = dMin;
    float color = -1.;
    
    for( int i = 0 ; i < 50 ; i++ )
    {
        vec2 res = scene( camPos + (rayDirection * traveledDistance) );
        
        if( res.x<precis || traveledDistance>dMax )
        {
            break;
        }
        
        traveledDistance += res.x;
        color = res.y;
    }
    
    if( traveledDistance > dMax )
    {
        color = -1.0;
    }
    return vec2( traveledDistance, color );
}

// Function 2647
vec3 raymarch(CastRay castRay){

    float currentDist = INTERSECTION_PRECISION * 2.0;
    float lastDist = currentDist;
    vec3 pos, lastPos = vec3(0);    
    vec4 outline = vec4(0);
    
    Model model;
    Ray ray = Ray(castRay.origin, castRay.direction, 0.);

    for (int i = 0; i < NUM_OF_TRACE_STEPS; i++) {

        lastPos = pos;
        pos = ray.origin + ray.direction * ray.len;

        if (ray.len > MAX_TRACE_DISTANCE) {
            break;
        }

        if (currentDist < INTERSECTION_PRECISION) {
            break;
        }

        if (currentDist > lastDist && currentDist < OUTLINE) {

            float t = lastDist / OUTLINE;
            
            vec4 newOutline = shadeOutline(pos, t);
            float contribution = 1. - outline.a;
            outline.rgb = mix(outline.rgb, newOutline.rgb, contribution);
            outline.a += newOutline.a * contribution;

            if (t < OUTLINE_BOUNDRY) {
                pos = lastPos;
                break;
			}
        }

        model = map(pos);
        lastDist = currentDist;
        currentDist = model.dist;
        ray.len += currentDist * FUDGE_FACTOR;
    }
	
    vec3 color = mix(
        shadeSurface(pos, ray),
       	outline.rgb,
        outline.a
	);
    
    return color;
}

// Function 2648
vec4 raymarch(vec3 from, vec3 increment)
{
	const float maxDist = 200.0;
	const float minDist = 0.1;
	const int maxIter = 120;
	
	float dist = 0.0;
	
	float material = 0.0;
	
	for(int i = 0; i < maxIter; i++) {
		float distEval = distanceField(from + increment * dist, material);
		
		if (distEval < minDist) {
			break;
		}
		
		dist += distEval;
	}
	
	
	if (dist >= maxDist) {
		material = 0.0;
	}
	
	return vec4(dist, 0.0, 0.0, material);
}

// Function 2649
vec2 castRay( vec3 ro, vec3 rd )    
{
    int   i     = 0;                           // raycaster iteration loop factor
    float close = 1.0;                         // raycaster min distance
    float far   = 3.0;                         // raycaster max distance
   	float p     = PR * close;                  // raycaster precision
    float id    = .0;                          // casted object id
       
    while( i ++< IT)
    {    
	  vec2 res = map(ro + rd * close);         // map() > response vec2(depth, id)
        
      if(abs(res.x) < p || close > far) break; // break when object something is encountred or when outside of bounds
     
      	close += res.x;				           // add depth to caster 
	  	id  = res.y;						   // write object'id
    }

    //if( close > far ) id = .0;				   // when there no response we return the background id
   
    return vec2( close, id );				   // return depth value and id
}

// Function 2650
vec3 cast_ray(vec3 orig, vec3 dir) {
  int depth = 0, state = 0, materialindex;
  vec3 value,point, N,reflect_color,refract_color;
  while(true) {
    if (state == 0) {
      if (!scene_intersect(orig, dir, point, N, materialindex)) {
        value = background(dir);
        state = 1;
      } else if (depth == MAXDEPTH) {
        reflect_color = refract_color = background(dir);
        state = 2;
      } else {
        stack[stackptr++] = StackEntry(ivec3(0,depth,materialindex),vec3(0),dir,point,N);
        if (materials[materialindex].albedo[2] == 0.0) {
          // Go directly to unwind if no reflection
          value = vec3(0);
          state = 1;
        } else {
          vec3 reflect_dir = normalize(reflect(dir, N));
          // offset the original point to avoid occlusion by the object itself    
          vec3 reflect_orig = dot(reflect_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;
          orig = reflect_orig;
          dir = reflect_dir;
          depth++;
          // and loop
        }
      }
    }
    if (state == 1) {
      if (stackptr == 0) return value;
      int type = stack[stackptr-1].iparams[0];
      depth = stack[stackptr-1].iparams[1];
      materialindex = stack[stackptr-1].iparams[2];
      dir = stack[stackptr-1].dir;
      point = stack[stackptr-1].point;
      N = stack[stackptr-1].N;
      Material material = materials[materialindex];
      if (type == 0) {
        // Don't actually pop the stack, but modify the top item
        stack[stackptr-1].value = value;
        stack[stackptr-1].iparams[0] = 1; //type = 1
        if (material.albedo[3] == 0.0) {
          value = vec3(0);
        } else {
          vec3 refract_dir = normalize(refraction(dir, N, material.refractive_index));
          vec3 refract_orig = dot(refract_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;
          orig = refract_orig;
          dir = refract_dir;
          depth++;
          state = 0;
        }
      } else {
        reflect_color = stack[stackptr-1].value;
        refract_color = value;
        stackptr--;
        state = 2;
      }
    }
    if (state == 2) {
      Material material = materials[materialindex];
      float diffuse_light_intensity = 0.0;
      float specular_light_intensity = 0.0;
      for (int i=0; i<NLIGHTS; i++) {
        vec3 light_dir       = normalize(lights[i].position - point);
        float light_distance = length(lights[i].position - point);

        // checking if the point lies in the shadow of the lights[i]
        vec3 shadow_orig = dot(light_dir,N) < 0.0 ? point - N*1e-3 : point + N*1e-3;
        vec3 shadow_pt, shadow_N;
        int tmpmaterial;
        if (scene_intersect(shadow_orig, light_dir, shadow_pt, shadow_N, tmpmaterial) &&
            length(shadow_pt-shadow_orig) < light_distance)
          continue;
                            
        diffuse_light_intensity  += lights[i].intensity * max(0.0, dot(light_dir,N));
        specular_light_intensity += pow(max(0.0, -dot(reflect(-light_dir, N),dir)),
                                        material.specular_exponent)*lights[i].intensity;
      }
      value = material.diffuse_color * diffuse_light_intensity * material.albedo[0] +
                                              vec3(1,1,1)*specular_light_intensity * material.albedo[1] +
                                              reflect_color*material.albedo[2] +
                                              refract_color*material.albedo[3];
      state = 1;
    }
  }
}

// Function 2651
void getRay(in vec2 fragCoord, out vec3 ro, out vec3 rd, out float fade)
{
    // misc
    float r = EARTH_R;
    vec3 top = vec3(0, r * 1.0001f, 0);

    // time / segment
    const float SEGMENT_DURATION = 5.5;
    float t = iTime;
    float segment = trunc(t / SEGMENT_DURATION);
    float segT = mod(t, SEGMENT_DURATION) / SEGMENT_DURATION;
    
    // fade
    float fadePercent = 0.12;
    fade = smoothstep(0.0, fadePercent, segT) * (1.0 - smoothstep(1.0 - fadePercent, 1.0, segT));
    if (t/SEGMENT_DURATION<0.5)
        fade = 1.0;
    
    //     
    float s = (segment+10.0)/202.0;
    float rand1 = clamp(texture(iChannel0, vec2(s, s)).x, 0.0, 1.0);
    float rand2 = clamp(texture(iChannel0, vec2(s, rand1)).x, 0.0, 1.0);
    float rand3 = clamp(texture(iChannel0, vec2(rand1+s, rand2)).x, 0.0, 1.0);
    
    // source
    float thetaCoef = rand1;
    float thetaSign = sign(rand2-0.5);
    float theta = -PI*0.5 + thetaSign * mix(0.4, 1.1, thetaCoef);
    float phi = PI*0.5 + PI*0.27 * mix(-1.0, 1.0, rand3); 
    
    float maxH = mix(r*6.0, r*3.0, thetaCoef); 
    float h = mix(r*1.1, maxH, rand2);
    
    vec3 start = vec3(theta, phi, h);    
    
    vec3 end = start;
    end.x += thetaSign * PI * 0.35 / (1.0+thetaCoef);
    
    float maxZChange = r*2.5;
    float minZ = r * 1.0001f;
    float tgtZ = max(start.z * 0.3, minZ);
    float change = min(start.z - tgtZ, maxZChange);
    end.z = start.z - change;
    
    vec3 cur = mix(start, end, segT);       
    ro = sph(cur.x, cur.y, cur.z);
    
    // target
    vec3 dirTop = normalize(top - ro);
    vec3 dirSun = sunDir();
    float coef = length(ro - top) / r;
    vec3 dir = mix(dirSun, dirTop, 0.4);
    vec3 tgt = ro + dir * r;
    
    // final ray
    mat3 cam = setCamera(ro, tgt, 0.0);    
	vec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;
    rd = cam * normalize(vec3(p.xy, FOCAL));        
}

// Function 2652
vec2 raymarch(inout vec3 pos, inout vec3 dir)
{
    vec2 result;	//the scene is contained in this variable
    
    for(float i = 0.0; i < EVALCNT; i++)
    {
        result = scene(pos);
        pos += dir * result.x;
        if(result.x < AEPSILON)
        {
            return result;
        }
    }
 	return vec2(99999.0, 99999.0);   //here should be some sky color computations, but now, I cannot do such
    						 //thing with my n00b ass...nonetheless, cornflower blue rulz
}

// Function 2653
float castRay(in vec4 ro, in vec4 rd, in float mint, in float maxt) {
	float h=.02, t=mint;
    for (int i=0; i<RAYMARCHING_ITER; i++) {
		if(abs(h)<.01||t>=maxt) break;		
        t += h = map(ro+rd*t);   
    }
    return t;
}

// Function 2654
vec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	
    float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {
        vec2 distResult = map( origin + dir * depth );
		float dist = distResult.x;
        dist -= dist*0.95;
		if ( dist < stop_threshold ) {
			return vec2(depth,distResult.y);
		}
		depth += dist;
		if ( depth >= end) {
			return vec2(end,-1.0);
		}
	}
	return vec2(end,-1.0);
}

// Function 2655
vec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = size.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 2656
vec3 rayDirection(float fieldOfView, vec2 fragCoord) {
    vec2 xy = fragCoord - iResolution.xy / 2.0;
    float z = iResolution.y / tan(radians(fieldOfView) / 2.0);
    return normalize(vec3(xy, -z));
}

// Function 2657
float raytraceBranch(vec3 u, vec3 D,vec3 t, float theE,float pitch, 
                    float yaw,float E,inout vec3 color,inout float nearestD){
 E=theE;   //this like is a terrible leftover from the pathethic original using too many globals.
 u=moveToBranchSpace(u-t,D,pitch,yaw);float testDist=-1.;
 if(!testAABB(u,D,vec3((branchStart+E)*.5,-.05,.0),
              vec3((E-branchStart)*.5,.8,2.),testDist))return E;
    //hardcoded y offset, size
 vec3 q=u+D*testDist;float f=testDist,d=.01;int mat,dummyMat;
 for(int i=0;i<16;i++){if(f>=testDist+E*2.){
  f=maxd;break;}if(abs(d)<.01)break;f+=d;q=u+D*f;d=branchDistance(q,mat,E);}
 if(f<nearestD){nearestD=f;
  vec3 n=normalize(vec3(d-branchDistance(q-eps.xyy,dummyMat,E),
                        d-branchDistance(q-eps.yxy,dummyMat,E),
                        d-branchDistance(q-eps.yyx,dummyMat,E)));
  if(mat==1)color=mix(vec3(.9,.55,.0),vec3(.95,.85,.7),
                      pow(max(dot(n,vec3(0,1,0)),.0),.5));
  else color=vec3(.1,.2,.2)*max(dot(n,vec3(0,1,0)),.0);}
 #ifdef DRAW_CLIP_RAYTRACES
 color = mix(color,vec3(1,0,0),.1);
 #endif   
 return E;}

// Function 2658
vec3 calcNormal2( in vec3 pos, in float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*shape( pos + e.xyy ) + 
					  e.yyx*shape( pos + e.yyx ) + 
					  e.yxy*shape( pos + e.yxy ) + 
					  e.xxx*shape( pos + e.xxx ) );
}

// Function 2659
vec3 calcNormalSimple( in vec3 pos ) {   
    const vec2 e = vec2(1.0,-1.0)*0.005;

    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + 
					    e.yyx*map( pos + e.yyx )   + 
					    e.yxy*map( pos + e.yxy )   + 
					    e.xxx*map( pos + e.xxx )   );  
    return n;
}

// Function 2660
vec3 calcNormal( in vec3 pos, in float t, float px, in float tre )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t*px;
    return normalize( e.xyy*map( pos + e.xyy, t, tre ).x + 
					  e.yyx*map( pos + e.yyx, t, tre ).x + 
					  e.yxy*map( pos + e.yxy, t, tre ).x + 
					  e.xxx*map( pos + e.xxx, t, tre ).x );
}

// Function 2661
Ray ray_from_camera(vec2 uv, float fov, vec3 cam_pos, vec3 look_at, vec3 right_vector)
{//fov is expressed in radians
    float fl = 1./tan(fov / 2.); //focal length
   	return Ray(cam_pos, normalize(vec3(uv.x, fl, uv.y)));
}

// Function 2662
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 0.0;
    float tmax = 30.0;
   
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (10.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>10.0 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }

    
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
	    float precis = 0.0005*t;
	    float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }

    if( t>tmax ) return vec2(t, 0);
    return vec2(t, 1);
}

// Function 2663
void Reflect(in vec3 dir, in vec3 pos, out Obj obj, out vec3 reflect_pos)
{
	float march_len = 1.0;
	for (int i=0; i< REFLECT_STEPS; ++i)
	{
		reflect_pos = pos + dir * march_len;
		ReflectMap(reflect_pos, obj);
		if (obj.m_dist<= EPSILON)
		{
			reflect_pos += dir * obj.m_dist;
			break;
		}
		march_len += obj.m_dist;
	}
}

// Function 2664
void resolveRayPolygonIntersection(polygon poly){
	
	vec3 e1=poly.B-poly.A;
	vec3 e2=poly.C-poly.A;
	vec3 pvec=cross(ray, e2);
	float det=dot(e1, pvec);
	
	float invDet=1.0/det;
	vec3 tvec=camera-poly.A;
	float u=dot(tvec,pvec)*invDet;
	if(u<0.0||u>1.0) return;
	vec3 qvec=cross(tvec,e1);
	float v=dot(ray,qvec)*invDet;
	if(v<0.0||v>1.0||(u+v)>1.0) return;
	float t=dot(e2,qvec)*invDet;
	if(t>0.0)
	if(t<closestPoint.distanceFromCamera){
		closestPoint.distanceFromCamera=t;
		closestPoint.normal=normalize(cross(e1, e2));
		closestPoint.color=poly.color;
	}
}

// Function 2665
float rayMarch(in vec3 iOrigin, in vec3 iRay, inout int ioObjectHit) {
    
 	float t = 0.0;
    vec3 p = iOrigin;
	
    for (int i = 0; i < MAX_STEPS; i++) {
        p = iOrigin + t*iRay;
     	float m = allMushroomsSDF(p);
     	float o = allOrbsSDF(p);
     	float g = groundSDF(p);
		
		float depth = min(min(o, m), g);
		// We hit an orb
		if (o < m && o < g) {
			depth = o;
			ioObjectHit = 2;
		} 
		// We hit a mushroom
		if (m < o && m < g) {
			depth = m;
			ioObjectHit = 1;
		}
		// We hit the ground
		if (g < o && g < m) {
			depth = g;
			ioObjectHit = 0;
		}		
        t += depth; 
        if (abs(depth) < EPSILON) {
            break;
        }
    }
	
    return t;
    
}

// Function 2666
float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}

// Function 2667
vec3 normal(vec3 p){
    return normalize(vec3(
        map(vec3(p.x + E, p.y, p.z)) - map(vec3(p.x - E, p.y, p.z)),
        map(vec3(p.x, p.y + E, p.z)) - map(vec3(p.x, p.y - E, p.z)),
        map(vec3(p.x, p.y, p.z + E)) - map(vec3(p.x, p.y, p.z - E))
    ));
}

// Function 2668
vec3 calcNormal( in vec3 pos )
{   
    const vec3 eps = vec3(0.02, 0.0, 0.0);
  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );
}

// Function 2669
vec3 getNormal( in vec3 p ) {
	vec3 e = vec3(0.0, 0.03, 0.0);
	return normalize(vec3(
		de(p+e.yxx)-de(p-e.yxx),
		de(p+e.xyx)-de(p-e.xyx),
		de(p+e.xxy)-de(p-e.xxy)));	
}

// Function 2670
float GrndRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = 0; j < 200; j ++) {
    p = ro + s * rd;
    h = p.y - GrndHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.2, 0.35 * h);
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = 0; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > GrndHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = 0.5 * (sLo + sHi);
  }
  return dHit;
}

// Function 2671
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        DE(vec3(p.x + EPSILON, p.y, p.z)) - DE(vec3(p.x - EPSILON, p.y, p.z)),
        DE(vec3(p.x, p.y + EPSILON, p.z)) - DE(vec3(p.x, p.y - EPSILON, p.z)),
        DE(vec3(p.x, p.y, p.z  + EPSILON)) - DE(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 2672
vec3 castRay(vec3 p, vec3 rd) {
   
   
    CP cp = findIntersection(p, rd);
   
    rays[0] = Ray( rd, cp, vec3(0), 1., ETA);

    for(int i = 0; i < RAY_COUNT/2; ++i) {
        Ray ray = rays[i];
        
		vec3 p = ray.cp.p;
       	 float cs = dot(ray.cp.normal, ray.rd);
        float fresnel = 1.0-abs(cs);
        //float fresnel =mix(0.2, 1., pow(1.-abs(cs),2.));
         vec3 normal = sign(cs)*ray.cp.normal;
    	vec3 refr = refract(ray.rd, -normal, ray.eta);
        vec3 refl = reflect(ray.rd, ray.cp.normal);
        vec3 z = normal*DIST_EPSILON*2.;
        p += z;
        rays[i*2+1] = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);
        p -= 2.*z;
        rays[i*2 + 2] = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);
    }
    
    for(int i = RAY_COUNT-1; i>=0;--i) {
        Ray ray = rays[i];
        vec3 p =  ray.cp.p;
		vec3 atColor;
        float  d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));
        vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));
        vec3 col = getColor(ray, p);
        float q = exp(-d*ray.cp.dist);
        col = col*q+matColor*(1.-q);
        rays[(i-1)/2].col += col*ray.share;

    }
   
	return rays[0].col;
}

// Function 2673
vec3 normal(vec3 p) {
    vec2 h = vec2(0.001, 0.0);
    vec3 n = normalize(vec3(
        de(p + h.xyy) - de(p - h.xyy),
        de(p + h.yxy) - de(p - h.yxy),
        de(p + h.yyx) - de(p - h.yyx)
	));
    
    return n;
}

// Function 2674
vec3 normal(const in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.005;   
	return normalize(e.yxx*map(p + e.yxx).x + e.xxy*map(p + e.xxy).x + 
					 e.xyx*map(p + e.xyx).x + e.yyy*map(p + e.yyy).x );   
}

// Function 2675
vec2 reflectPG(vec2 p, vec3 c) {
    if (c.z == 0.) {
        return p - (2.*dot(p, c.xy))*c.xy;
    } else {
        return invertPC(p, c);
    }
}

// Function 2676
vec3 calcNormalstage8(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage8 (p+e.xyy) - mapstage8(p-e.xyy),
            mapstage8 (p+e.yxy) - mapstage8(p-e.yxy),
            mapstage8 (p+e.yyx) - mapstage8(p-e.yyx)                            
        )
	);
}

// Function 2677
vec3 calcNormal(vec3 pos, float ep)
{
    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,
                		map(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,
                		map(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                
}

// Function 2678
vec3 getReflection(vec3 ro,vec3 rd)
{
	vec3 color = vec3(0);
	vec4 ob,col;
    vec2 mat;
	float tm = calcInter(ro,rd,ob,col,mat);
	if(tm < maxDist)
	{
		vec3 pt = ro + rd*tm;
		vec3 n = normalize(pt - ob.xyz);
		color = calcShade(pt,ob,col,mat,n);
	}
	return color;
}

// Function 2679
vec4 heightToNormal(sampler2D height, vec3 samplingResolution, vec2 uv, float normalMultiplier) {

    vec2 s = 1.0/samplingResolution.xy;
    
    float p = texture(height, uv).x;
    float h1 = texture(height, uv + s * vec2(1,0)).x;
    float v1 = texture(height, uv + s * vec2(0,1)).x;
       
   	vec2 xy = (p - vec2(h1, v1)) * normalMultiplier;
   
    return vec4(xy + .5, 1., 1.);
}

// Function 2680
vec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)
{   
    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);
    vec3 rayHitDiffuse = vec3(1.0);
    vec3 additiveColor = vec3(0.0);
    
    float fogAmount = 0.0;
        
    vec2 uv;    
    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.5, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);
    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)
    {
        bestRayHitInfo = rayInfo;
        rayHitDiffuse = Checkerboard(uv);
    }
    
    rayInfo = RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));
    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)
    {       
        // light the surface of the ball a bit
        additiveColor += LightPixel(vec3(0.1), rayDir, rayInfo.yzw, 40.0);

        // move the ray to be just inside the sphere and refract the ray direction
        rayPos += rayDir * (rayInfo.x + 0.01);
        rayDir = refract(rayDir, rayInfo.yzw, REFRACTIONRATIO);
        
        // reset the best hit info so we can test only against the glints
        bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);       
        
        // ray trace the glints
        for (int i = 0; i < NUMGLINTS; ++i)
        {      
        	vec3 plane = normalize(hash32(vec2(float(i), float(i)*1.337)));
            vec3 offset = (hash32(vec2(float(i)*1.756, float(i)*1.534)) * 2.0 - 1.0) * 0.4;
            vec3 glintColor = hash32(vec2(float(i)*5.362, float(i)*9.253)) * 10.0;
        	rayInfo = RayIntersectPlane(rayPos + offset, rayDir, vec4(plane, 0.0), uv);

        	if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x && abs(uv.x) < GLINTSIZE*0.5 && abs(uv.y) < GLINTSIZE*0.5)
            {
                bestRayHitInfo = rayInfo;  
                rayHitDiffuse = glintColor;
            }
        }
        
        // If we hit a glint, return the lit glint color
        if (bestRayHitInfo.x < 1000.0)
        {
            fogAmount = 1.0 - exp( -FOGDENSITY * bestRayHitInfo.x );
            vec3 glintColor = LightPixelGlint(rayHitDiffuse, rayDir, bestRayHitInfo.yzw, 10.0);
            return mix(glintColor, FOGCOLOR, fogAmount) + additiveColor;
        }
        
        // ray trace out the back of the sphere and refract the ray direction again by the inverse amount.
        // Reset the best ray hit info so we can see if we hit anything
        rayInfo = RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));
        if(rayInfo.x >= 0.0)
        {
        	rayPos += rayDir * rayInfo.x;
        	rayDir = refract(rayDir, rayInfo.yzw, 1.0 / REFRACTIONRATIO);    
        	bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);
        	rayHitDiffuse = vec3(0.0);     
            
            fogAmount = 1.0 - exp( -FOGDENSITY * rayInfo.x );
        }
        
        // once outside of the sphere, need to test against platform again, after resetting the best ray hit info
		rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.5, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);
    	if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)
    	{
        	bestRayHitInfo = rayInfo;
        	rayHitDiffuse = Checkerboard(uv);
    	}        
    }
    
    vec3 color;
    if (bestRayHitInfo.x == 1000.0)    
		color = texture(iChannel0, rayDir).rgb;
    else
        color = LightPixel(rayHitDiffuse, rayDir, bestRayHitInfo.yzw, 100.0);
    

    return mix(color, FOGCOLOR, fogAmount) + additiveColor;
}

// Function 2681
vec3 marchRay(in vec3 ro, in vec3 rd) {
    const int MAX_ITERS = 100;
    float dist = EPSILON;
    float totalDist = 0.0;
    
    for (int i = 0; i < MAX_ITERS; i++) {
        if (abs(dist) < EPSILON || totalDist > MAX_RAY_DIST) {
            break;
        }
        
        dist = map(ro);
        ro += rd * dist;
        totalDist += dist;
    }
    
    if (abs(dist) < EPSILON) {
        return lighting(ro, rd);
    } else {
        return BG_COLOR;
    }
}

// Function 2682
vec2 SceneNormal(vec2 p, float h, out float d)
{
    vec2 n = vec2(
          Scene(p + vec2(h,0))
        , Scene(p + vec2(0,h))
      ) - (d = Scene(p));
    if (dot(n,n) < 1e-7) n = vec2(0,1);
    else n = normalize(n);
    return n;
}

// Function 2683
float intersectRayPlane(vec3 ro, vec3 rd, vec3 n, vec3 p) {
  const float eps = 0.0001;
  float denom = dot(rd, n);
  return abs(denom) < eps ? -1.0 : dot(p - ro, n) / denom;
}

// Function 2684
RayHit NewRayHit()
{
    RayHit rh;
    rh.tMin = bignum;
    rh.tMax = bignum;
    rh.hitMin = vec3(0.0);
    rh.hitMax = vec3(0.0);
    rh.normMin = vec3(0.0);
    rh.normMax = vec3(0.0);
    rh.material = 0.0;
    return rh;
}

// Function 2685
vec3 getGlassNormal(vec2 pos)
{
    vec3 n = normalize(vec3(-getGradH(pos,1.4),.5));
    return n;
}

// Function 2686
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.01, 0.0, 0.0 );
	vec3 nor = vec3(
   map(pos+eps.xyy).x - map(pos-eps.xyy).x,
   map(pos+eps.yxy).x - map(pos-eps.yxy).x,
   map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 2687
void generateRay(out vec3 rayDir, out vec3 rayPos, in vec2 px )
{
    vec2 s = (-iResolution.xy+2.0*px)/iResolution.y;
    

    // barrel distort
	float r2 = s.x*s.x*0.32 + s.y*s.y;
	s *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);
    
    // set camera position and orientation
#if 0
         rayPos = vec3( -0.1564345, 1.0938345,  0.0123116 );
	vec3 rayTar = vec3( -0.0408938, 0.4444526,  1.0619653 );
	vec3 rayUp  = vec3(  0.0,       0.9999299, -0.0118397 );
#else
    float time = 0.5 + iTime*0.5;
    time = 0.5 - (iTime-10.0);

    vec3 rayTar = vec3( 0.0, 0.5, 1.0 );
	rayPos = rayTar - vec3(1.0,-0.75,1.0)*cos(6.2831853*time/20.0 + vec3(-1.5708,0.5,0.0));
	rayTar += 0.075*vec3(noise3f(vec3(2.0*iTime,0.0,0.5),0),
	                     noise3f(vec3(2.0*iTime,0.1,0.4),7),
	                     noise3f(vec3(2.0*iTime,0.2,0.3),9));
	float roll = 0.1*noise3f(vec3(2.0*time,0.0,0.0),13);
	vec3 rayUp = vec3( 0.0, cos(roll), sin(roll) );
#endif
        
    // compute camera matrix
    mat3 mat = setCamera( rayPos, rayTar, rayUp );

    // create ray direction
    rayDir = normalize( mat * vec3( -s.x, s.y, -1.0 ) );
}

// Function 2688
vec3 compute_normal(vec3 pos, float density)
{
	
    float eps = rayStep*2.0;
    vec3 n;
	
    n.x = density_function( vec3(pos.x+eps, pos.y, pos.z) ) - density;
    n.y = density_function( vec3(pos.x, pos.y+eps, pos.z) ) - density;
    n.z = density_function( vec3(pos.x, pos.y, pos.z+eps) ) - density;
    return normalize(n);
}

// Function 2689
vec3 CombineNormal(vec3 n1, vec3 n2, int technique)
{
 	if (technique == TECHNIQUE_RNM)
        return NormalBlend_RNM(n1, n2);
    else if (technique == TECHNIQUE_PartialDerivatives)
        return NormalBlend_PartialDerivatives(n1, n2);
    else if (technique == TECHNIQUE_Whiteout)
        return NormalBlend_Whiteout(n1, n2);
    else if (technique == TECHNIQUE_UDN)
        return NormalBlend_UDN(n1, n2);
    else if (technique == TECHNIQUE_Unity)
        return NormalBlend_Unity(n1, n2);
    else if (technique == TECHNIQUE_Linear)
        return NormalBlend_Linear(n1, n2);
    else
        return NormalBlend_Overlay(n1, n2);
}

// Function 2690
vec3 sceneNormal(vec3 p) {
	float d = sceneDistance(p);
    vec2 e = vec2(RAY_MARCH_CLOSE, .0);
    return normalize( d - vec3(
        sceneDistance(p-e.xyy),
        sceneDistance(p-e.yxy),
        sceneDistance(p-e.yyx))
    );
}

// Function 2691
float castShadowRay( in vec3 ro, in vec3 rd, in float time )
{
    float res = 1.0;
    
    ivec2 hid = hexagonID(ro.xz);
    
    const float k3 = 0.866025;
    const vec2 n1 = vec2( 1.0,0.0);
    const vec2 n2 = vec2( 0.5,k3);
    const vec2 n3 = vec2(-0.5,k3);
    
    float d1 = 1.0/dot(rd.xz,n1);
    float d2 = 1.0/dot(rd.xz,n2);
    float d3 = 1.0/dot(rd.xz,n3);
    float d4 = 1.0/rd.y;
    
    float s1 = (d1<0.0)?-1.0:1.0;
    float s2 = (d2<0.0)?-1.0:1.0;
    float s3 = (d3<0.0)?-1.0:1.0;
    float s4 = (d4<0.0)?-1.0:1.0;

    ivec2 i1 = ivec2( 2,0); if(d1<0.0) i1=-i1;
    ivec2 i2 = ivec2( 1,1); if(d2<0.0) i2=-i2;
    ivec2 i3 = ivec2(-1,1); if(d3<0.0) i3=-i3;

    vec2 c1 = (vec2(-s1,s1)-dot(ro.xz,n1))*d1;
    vec2 c2 = (vec2(-s2,s2)-dot(ro.xz,n2))*d2;
    vec2 c3 = (vec2(-s3,s3)-dot(ro.xz,n3))*d3;

    // traverse regular grid (2D)	
	for( int i=0; i<8; i++ ) 
	{
		vec2  ce = hexagonCenFromID( hid );
        float he = 0.5*map(ce, time);
                
        vec2 t1 = c1 + dot(ce,n1)*d1;
        vec2 t2 = c2 + dot(ce,n2)*d2;
        vec2 t3 = c3 + dot(ce,n3)*d3;
        vec2 t4 = (vec2(1.0-s4,1.0+s4)*he-ro.y)*d4;
        
        float tN = max(max(t1.x,t2.x),max(t3.x,t4.x));
        float tF = min(min(t1.y,t2.y),min(t3.y,t4.y));
        if( tN < tF && tF > 0.0)
        {
            res = 0.0;
            break;
		}
        
             if( t1.y<t2.y && t1.y<t3.y ) hid += i1;
        else if( t2.y<t3.y )              hid += i2;
        else                              hid += i3;
	}

	return res;
}

// Function 2692
vec3 unpack_normal( float a ) { uint b = floatBitsToUint( a ); return ( vec3( uvec3( b >> 20u, b >> 10u, b ) & 1023u ) - 512. ) / 511.; }

// Function 2693
vec3 calcNormal2(in vec3 p) {
    vec2 e = vec2(1.0, -1.0) * 0.0005;
    return normalize(
        e.xyy * map2(p + e.xyy) +
        e.yyx * map2(p + e.yyx) +
        e.yxy * map2(p + e.yxy) +
        e.xxx * map2(p + e.xxx));
}

// Function 2694
HitInfo raymarch(const in Ray ray, float start, float end) {
    float depth = start;
    HitInfo hit;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        hit = sceneH(ray.eye + depth * ray.dir);
        if (hit.dist < EPSILON) {
            return HitInfo(hit.object, depth);
        }
        depth += hit.dist;
        if (depth >= end) {
            return HitInfo(NO_HITS, 0.);
        }
    }
    return HitInfo(NO_HITS, 0.);
}

// Function 2695
vec3 normal(vec3 p, ivec4 piece) {
    vec2 eps = vec2(0.0001,0.0);
    
    return normalize(vec3(
        map(p+eps.xyy,piece)-map(p-eps.xyy,piece),
        map(p+eps.yxy,piece)-map(p-eps.yxy,piece),
        map(p+eps.yyx,piece)-map(p-eps.yyx,piece)));
}

// Function 2696
float raymarch(vec3 ray_origin, vec3 ray_direction) {
  float d = 0.0;

  for (float i = 0.; i < 70.; i++) {
    vec3 new_point = ray_origin + ray_direction*d;
    float s = get_distance(new_point);
    if (s < 0.001) return d;
    d += s;
    if (d > 70.) return 300.;
  }
  return 300.;
}

// Function 2697
float RayMarch(vec3 ro, vec3 rd) 
{
	
    // The extra distance might force a near-plane hit, so
    // it's set back to zero.
    float dO = 0.; 
    //Determines size of shadow
    for(int i=0; i<MAX_STEPS; i++) 
    {
    	vec3 p = ro + rd*dO;
        float dS = GetDist(p);
        
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
        dO += dS;
        
    }
    
    return dO;
}

// Function 2698
float castray(in vec3 ro, in vec3 rd)
{
    
    vec2 box = boxRay(ro, rd);
    
    if(box.x > box.y || box.y <= 0.0)
        return -1.0;
    
    float mint = box.x;
    float maxt = box.y;
    
    vec3 first = ro + rd*box.x;
    
    if(map(first.xz) > first.y)
        return -2.0;
    

    
    float delt = (maxt-mint) / float(RAY_ITER);
    
    float lh = 0.0;
    float ly = 0.0;
    float t = mint;
    vec3  p;
    for(int i = 0; i<RAY_ITER; i++)
    {
        t+= delt;
        p = ro + rd*t;
        float h = map( p.xz );
        if( p.y < h )
        {
            delt = delt / float(RAY_ITER_BW);
            for(int j = 0; j<RAY_ITER_BW; j++)
            {
                t-= delt;
                p = ro + rd*t;
        		h = map( p.xz );
                if( p.y > h )
            		return t - delt + delt*(lh-ly)/(p.y-ly-h+lh);
                lh = h;
        		ly = p.y;
            }
        }
        lh = h;
        ly = p.y;
        
    }
    
    return -1.0;
    
}

// Function 2699
bool computeRayHit( in vec3 ray, in float dist )
{
    vec3 normalsSign = -sign(ray);
    vec3 dots = vec3(ray.x * normalsSign.x, ray.y * normalsSign.y, ray.z * normalsSign.z);

    ivec3 ptrSteps = ivec3(1, 1, 1); //-normalsSign);
    if(ray.x < 0.0)	ptrSteps.x = -1;
    if(ray.y < 0.0)	ptrSteps.y = -1;
    if(ray.z < 0.0)	ptrSteps.z = -1;
    
    vec3 crossValues = max(vec3(0.0, 0.0, 0.0), normalsSign);	// 0.0 or 1.0

    for(int i = 0; i < 64; i++)
    {
        vec3 vDist = ((1.0 - crossValues - fraction) * normalsSign) / dots;

        float shortestDist = min(min( vDist.x, vDist.y), vDist.z);
        dist -= shortestDist;
        if(dist <= 0.0)
        {
            // far dist or light dist reached
		    break;
        }

        // to current cube exit coord
        fraction = fraction + (ray * shortestDist);
        
        // which side
        if(all(lessThanEqual( vDist.xx, vDist.yz)))  	mask = vec3(1.0, 0.0, 0.0);	  // cut X ?
        else if(vDist.y <= vDist.z)         			mask = vec3(0.0, 1.0, 0.0);   // cut Y ?
        else            								mask = vec3(0.0, 0.0, 1.0);	  // then must be cuting Z
        
        // next cube ( the cube we should be entering )
		ivec3 nextPtr = ptr + ptrSteps * ivec3(mask);
        if( mapCube( nextPtr ) )
        {
            return true;
        }
        
        // bumping on a cube edge ?
        vec3 temp = (1.0 - mask) * abs( fraction - 0.5 );
        float distToClosestSide = max( max( temp.x, temp.y ), temp.z);
        if(distToClosestSide > 0.4)
        {
            return true;
        }

        // next cube is now current
        ptr = nextPtr;
        fraction = mix(fraction, crossValues, mask);	// got to reset the crossing coord component (float imprecision)
	}
    return false;
}

// Function 2700
vec2 normal (vec2 p)
{
    return normalize(vec2(
        map(vec2(p.x + .001,p.y)) - map(vec2(p.x - .001,p.y)),
        map(vec2(p.x,p.y + .001)) - map(vec2(p.x,p.y - .001))
        ));
}

// Function 2701
rayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset, vec4 range) {
	vec3 mapPos = floor(rayPos);
    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = sign(rayDir);
    vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 
    vec3 mask;
    bool hit = false;
    for (int i = 0; i < 384; i++) {
		mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);
		sideDist += vec3(mask) * deltaDist;
		mapPos += vec3(mask) * rayStep;
		
        if (!inRange(mapPos.xy, range) || mapPos.z < 0. || mapPos.z >= packedChunkSize.x * packedChunkSize.y) break;
        if (getHit(mapPos - offset)) { 
            hit = true; 
            break;
        }

	}
    vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;
   	vec2 uv;
    vec3 tangent1;
    vec3 tangent2;
    if (abs(mask.x) > 0.) {
        uv = endRayPos.yz;
        tangent1 = vec3(0,1,0);
        tangent2 = vec3(0,0,1);
    }
    else if (abs(mask.y) > 0.) {
        uv = endRayPos.xz;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,0,1);
    }
    else {
        uv = endRayPos.xy;
        tangent1 = vec3(1,0,0);
        tangent2 = vec3(0,1,0);
    }
    uv = fract(uv);
    rayCastResults res;
    res.hit = hit;
    res.uv = uv;
    res.mapPos = mapPos;
    res.normal = -rayStep * mask;
    res.tangent = tangent1;
    res.bitangent = tangent2;
    res.rayPos = endRayPos;
    res.dist = length(rayPos - endRayPos);
    return res;
}

// Function 2702
MarchResult raymarch(const in Camera cam)
{
	MarchResult march;
	
	float depth = 0.0;
	for(int i = 0; i < MAX_ITERATIONS; ++i)
	{
		march.position = cam.position + cam.rayDir * depth;
		march.hit = map(march.position);
		
		
		if(march.hit.dist <= EPSILON || depth >= MAX_DEPTH)
		{
			break;
		}
		
		depth += march.hit.dist;
	}
	
	if(depth < MAX_DEPTH)
	{
		vec3 eps = vec3(EPSILON, 0, 0);
		march.normal=normalize(
			   vec3(march.hit.dist - map(march.position-eps.xyy).dist,
					march.hit.dist - map(march.position-eps.yxy).dist,
					march.hit.dist - map(march.position-eps.yyx).dist));
		
	}
	
	return march;
}

// Function 2703
vec3 calcNormal(vec3 p ) 
{
    float t_atPoint = sceneSDF(p).t;
    vec3 normal = vec3( sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).t - t_atPoint,
                        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).t - t_atPoint,
                        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).t - t_atPoint );
    return normalize(normal);
}

// Function 2704
vec4 raytrace_curtain_background_rail(vec3 campos,vec3 camdir)
{
    // raycast 1024*512 voxels with spatial tree
    // note that the cloth has only 128x64 vertices, 
    // but linear filtered reading of the positions texture oversamples it
    
    const float minst = 1.0/8.0; // oversampling voxelgeometry by 8x8 
    const float voxelsize = minst*0.77*maxextentionratio;
    float mindept=999.0;
    vec2 c = vec2(0.0,0.0);
    vec2 minc=vec2(-1.0,-1.0);
    float st = SIZY;
    float levelup=0.0;
    
    
    float cnt=0.0;
    for(float i=0.0;i<5000.0;i+=1.0) // less than 200 iterations for most pixels
    {
        cnt+=1.0;
            
        vec3 wp = getpos(c);
        
        if (st==minst)
        {
        	float d=length( cross(wp-campos,camdir) );
        	if (d<=voxelsize)
        	{
                float dept = dot(camdir,wp);
                if (dept<mindept)
                {
                    mindept = dept;
                    minc = c;
                }
	        }
            
        	if (st==minst)            
	            levelup=1.0;
        }
        
        vec3 boundingcenter= getpos(c.xy + vec2(st*0.5));

        if (  length( cross(boundingcenter-campos,camdir) )>st*0.79*maxextentionratio )
        {
            levelup=1.0;
        }
        
        
        
        if (levelup>0.0)
        {
            levelup=0.0;
            
            if ( fract(c.x/st/2.0)<0.25 )
            {
                c.x += st;
            }
            else
            {
                c.x -= st;            

                if ( fract(c.y/st/2.0)<0.25 )
                {
                    c.y += st;
                }
                else
                {
                    c.y -= st;
                    st *= 2.0;
                    levelup=1.0;
                }
            }
        }
        else
        {
            
            if (st>minst) st/=2.0;
            
        }
        
//        if (c.x>=SIZX) break;    
        if (c.y>=SIZY) break;    
    }
    
    if (minc.x>=0.0)
    {
        vec3 diffuse;
        diffuse = clamp( (texture(iChannel0,vec2(minc.x/SIZX,minc.y/SIZX)).xyz-0.3)*-30.0,0.7,1.0)*1.5;
        
        vec3 normal = findnormal(minc);
        
        if ( dot(camdir,normal) < -0.1) // back side detection with antibug cheat
        {
            normal*=-1.0;  // backside color of curtian
            diffuse*=vec3(0.5,0.7,1.0);
        }
        else
        {
			diffuse*=vec3(1.0,0.8,0.6); // front color 
        }
        
        mindept-=dot(campos,camdir);
        vec3 hitpos = campos + camdir*mindept;
        
        // ball analitic ambient occlusion on curtian
        float aaom = clamp( (hitpos.y-ballpos().y)/ballradius,-1.0,1.0)*0.5+0.5;
        
        float balld = length(hitpos-ballpos());
        float aao = 1.0 - aaom * max(dot(normal,(hitpos-ballpos())),0.0)/balld/balld/balld*ballradius*ballradius*1.3;
        
//        aao = 1.0;
        
        return  vec4(diffuse*lighting(normal)*aao,mindept);
        
    }
    else
    {
        vec3 dir = camdir; // quick anti aliased 3d line
        dir.x = 0.0;
        vec3 p2 = campos;
        p2.x = 0.0;
        float rod = min(length(cross(normalize(dir),p2))/0.8,1.0);
        if (dot(dir,p2)>0.0) rod = 1.0;
        float mul = rod;
        return background(campos,camdir)*vec4(mul,mul,mul,1.0);
    }
    

}

// Function 2705
vec3 GetNormal(vec3 p) {
    float d = GetDist(p).x;
    vec2 e = vec2(.001, 0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy).x,
        GetDist(p-e.yxy).x,
        GetDist(p-e.yyx).x);
    
    return normalize(n);
}

// Function 2706
Ray Ray_LookAt(in vec2 uv, in vec3 o, in vec3 d)
{
    vec3 forward = normalize(d - o);
    vec3 right   = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
    vec3 up      = normalize(cross(right, forward));

    uv = (uv * 2.0) - 1.0;

    float u = tan(CamFOV) * distance(o, d);
    float v = u * (iResolution.y / iResolution.x);

    return Ray(o, normalize(d + (uv.x * u * right) + (uv.y * v * up) - o));
}

// Function 2707
vec3 GetNormal(vec3 p){
	float d = GetDist(p);
    vec2 e = vec2(0.01, 0);
    vec3 n = d - vec3(GetDist(p - e.xyy),//same to vec3(d- d1, d- d2, d- d3);
                      GetDist(p - e.yxy),
                      GetDist(p - e.yyx));
    
   
    return normalize(n);
}

// Function 2708
vec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {
    vec3 rand = normalize(cos(cos(p)*512.124+cos(p.yzx*16.234)*64.3249+cos(p.zxy*128.234)*12.4345));
    return rand*sign(dot(d,rand));
}

// Function 2709
vec3 calcNormal(vec3 pos, float freq, float t)
{
    vec2 eps = vec2( 0.002 * t, 0.0 );
    int norLod = int(max(5., float(HQ_OCTAVES) - (float(HQ_OCTAVES) - 1.)
                         * t / CAMERA_FAR));
    return normalize( 
        vec3(terrainFbm(pos.xz - eps.xy, norLod, iChannel0) - terrainFbm(pos.xz
					+ eps.xy, norLod, iChannel0),
             2.0 * eps.x,
             terrainFbm(pos.xz - eps.yx, norLod, iChannel0) - terrainFbm(pos.xz
					+ eps.yx, norLod, iChannel0)));
}

// Function 2710
vec4 rayMarch(vec3 p, vec3 d, inout object co)
{
    if(co.id < 0)
    {
        co = getObject(0);
    }
    
    float td = 0.; float DE = 1e10;
    for(int i = min(0, iFrame); i < maxs; i++)
    {
        //march
        DE = map(p, co);
        
        p += DE*d;
        td += DE;
        
        //outide of the scene
        if(td > maxd) return vec4(p, -1.);
        //has hit the surface
        if(DE < mind*td) break;
    }
    return vec4(p, DE);
}

// Function 2711
vec3 findnormal(vec2 c)
{
    return normalize(cross(  getpos(c-vec2(1.0,0.0))-getpos(c+vec2(1.0,0.0)) ,  getpos(c-vec2(0.0,1.0))-getpos(c+vec2(0.0,1.0)) ));
}

// Function 2712
vec3 getRay(vec3 pos, vec3 dir, vec3 up, vec2 fragCoord)
{
	vec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5);
	xy.y *= -iResolution.y / iResolution.x;

	vec3 eyed = normalize(dir);
	vec3 ud = normalize(cross(vec3(0.0, -1.0, 0.0), eyed));
	vec3 vd = normalize(cross(eyed, ud));

	float f = FOV * length(xy);
	return normalize(normalize(xy.x * ud + xy.y * vd) + (1.0 / tan(f)) * eyed);
}

// Function 2713
vec2 raymarch(vec3 position, vec3 direction)
{
    /*
	This function iteratively analyses the scene to approximate the closest ray-hit
	*/
    // We track how far we have moved so we can reconstruct the end-point later
    float total_distance = NEAR_CLIPPING_PLANE;
    vec2 result;
    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)
    {
        result = scene(position + direction * total_distance);
        // If our ray is very close to a surface we assume we hit it
        // and return it's material
        if(result.x < EPSILON)
        	break;
        
        // Accumulate distance traveled
        // The result.x contains closest distance to the world
        // so we can be sure that if we move it that far we will not accidentally
        // end up inside an object. Due to imprecision we do increase the distance
        // by slightly less... it avoids normal errors especially.
        total_distance += result.x * DISTANCE_BIAS;
        
        // Stop if we are headed for infinity
        if(total_distance > FAR_CLIPPING_PLANE)
            break;
    }
    // By default we return no material and the furthest possible distance
    // We only reach this point if we didn't get close to a surface during the loop above
    return vec2(total_distance, result.y);
}

// Function 2714
vec3 normal(vec2 P)
{
    vec2 N = vec2(1,0);
    N = height(P-N.xy*PRE)*-N.xy+height(P+N.xy*PRE)*N.xy+height(P-N.yx*PRE)*-N.yx+height(P+N.yx*PRE)*N.yx;
 	return normalize(vec3(N,-PRE));
}

// Function 2715
Ray GetCameraRay(Camera cam, const vec2 uv)
{
    Ray o;
    
    o.o = cam.pos;
  	o.d = normalize(uv.x * cam.right +
                    uv.y * cam.up +
                    cam.forward * cam.fPersp);
    return o;
}

// Function 2716
Hit raymarch(CastRay castRay){

    float currentDist = INTERSECTION_PRECISION * 2.0;
    Model model;
    
    Ray ray = Ray(castRay.origin, castRay.direction, 0.);

    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){
        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {
            break;
        }
        model = map(ray.origin + ray.direction * ray.len);
        currentDist = model.dist;
        ray.len += currentDist * FUDGE_FACTOR;
    }
    
    bool isBackground = false;
    vec3 pos = vec3(0);
    vec3 normal = vec3(0);
    vec3 color = vec3(0);
    
    if (ray.len > MAX_TRACE_DISTANCE) {
        isBackground = true;
    } else {
        pos = ray.origin + ray.direction * ray.len;
        normal = calcNormal(pos);
    }

    return Hit(ray, model, pos, isBackground, normal, color);
}

// Function 2717
vec3 Normal(vec3 position)
{
    float distance = SceneSD(position);
    vec2 offset = vec2(0.001, 0.0);
    
    vec3 normal = distance - vec3(
        SceneSD(position-offset.xyy),
        SceneSD(position-offset.yxy),
        SceneSD(position-offset.yyx));
    
    return normalize(normal);
}

// Function 2718
vec3 sceneNormal( in vec3 point ) {
    return normalize( sceneDistance( point ).x - vec3(
        sceneDistance( point - RAY_EPSILON.xyy ).x,
        sceneDistance( point - RAY_EPSILON.yxy ).x,
        sceneDistance( point - RAY_EPSILON.yyx ).x
    ));
}

// Function 2719
vec3 calcNormal(vec3 p) {   
    return normalize(vec3(
        world(vec3(p.x + eps, p.y, p.z)) - world(vec3(p.x - eps, p.y, p.z)),
        world(vec3(p.x, p.y + eps, p.z)) - world(vec3(p.x, p.y - eps, p.z)),
        world(vec3(p.x, p.y, p.z  + eps)) - world(vec3(p.x, p.y, p.z - eps))
    ));
}

// Function 2720
vec3 calcNormal(vec3 p) {
  vec3 eps = vec3(1e-4,0,0);
  vec3 n = vec3(map(p + eps.xyy) - map(p - eps.xyy),
                map(p + eps.yxy) - map(p - eps.yxy),
                map(p + eps.yyx) - map(p - eps.yyx));
  return normalize(n);
}

// Function 2721
vec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {
	// Add some noise to prevent banding
	float totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));
	vec3 dir2 = dir;
	float distance;
	int steps = 0;
	vec3 pos;
	for (int i=0; i <= MaxSteps; i++) {
		pos = from + totalDistance * dir;
		distance = DE(pos)*FudgeFactor;
		
		totalDistance += distance;
		if (distance < MinimumDistance) break;
		steps = i;
	}
	
	// 'AO' is based on number of steps.
	float ao = 1.0-float(steps)/float(MaxSteps);
	
	// Since our distance field is not signed,
	// backstep when calc'ing normal
	vec3 normal = getNormal(pos-dir*normalDistance*3.0);
	vec3 b = bg(dir);
	b = mix(b, vec3(0.0,0.0,0.0), 0.2);
	if (steps == MaxSteps) {
		return vec4(b,1.0);
	}
	vec3 color = getColor(normal, pos);
	vec3 light = getLight(color, normal, dir);
	color =(color*Ambient+light)*(ao);
	return vec4(color,1.0);
}

// Function 2722
vec4 octreeray(in vec3 ro,
               in vec3 rd,
               in float maxdist,
               out vec3 lro, out vec3 fro,
               out float size,
               in int reflects,
               inout float fogl) {
    size = 1.0;
    lro = mod(ro,size);
    fro = ro-lro;
    vec3 mask;
    bool exitoct = false;
    int recursions = 0;
    float dist = 0.0;
    int i;
    float edge = 1.0;
    float lastsize = size;
    
    //the octree traverser loop
    //each iteration i either:
    // - check if i need to go up a level
    // - check if i need to go down a level
    // - check if i hit a cube
    // - go one step forward if cube is empty
    for (i = 0; i < steps; i++)
    {
        if (dist > maxdist) break;
        int voxelstate = getvoxel(fro,size);
        
        //i go up a level
        if (exitoct)
        {
            
            vec3 newfro = floor(fro/size*0.5+0.25)*size*2.0;
            
            lro += fro-newfro;
            fro = newfro;
            
            recursions--;
            size *= 2.0;
            
            exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);
        }
        //subdivide
        else if(voxelstate == 1&&recursions<=detail)
        {
            
            recursions++;
            size *= 0.5;
            
            //find which of the 8 voxels i will enter
            vec3 mask2 = step(vec3(size),lro);
            fro += mask2*size;
            lro -= mask2*size;
        }
        else if (voxelstate == 2)
        {
            break;
        }
        //move forward
        else
        {
            //raycast and find distance to nearest voxel surface in ray direction
            vec3 hit = voxel(lro, rd, size);
            if (hit.x < min(hit.y,hit.z)) {
                mask = vec3(1,0,0);
            } else if (hit.y < hit.z) {
                mask = vec3(0,1,0);
            } else {
                mask = vec3(0,0,1);
            }
            
            float len = dot(hit,mask);
            
            //moving forward in ray direction, and checking if i need to go up a level
            lro += rd*len-mask*sign(rd)*size;
            vec3 newfro = fro+mask*sign(rd)*size;
            dist += len;
            fogl -= len;
            if (fogl <= 0.0) {
                dist -= fogl;
                fogl = 0.0;
            }
            exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);
            fro = newfro;
        }
    }
    return vec4(dist, mask);
}

// Function 2723
vec2 RayMarch(vec3 ro, vec3 rd, inout vec3 gc) {
	float dO=0.;
    vec2 dm;
    for(int i=0; i<MAX_STEPS; i++) {
    	vec3 p = ro + rd*dO;
        dm = GetDist(p);
        // Ripped from Shaw
        float at = .03 / (1. + dm.x * dm.x * 100.);
        vec3 gcc = vec3(1., .5, 0.); // hsv2rgb(vec3(Hash(dm.y),0.8,1.)); // 
        gc += gcc * at;       
        float dS = dm.x;
        dO += dS;
        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;
    }
    
    return vec2(dO,dm.y);
}

// Function 2724
vec4 WorldRayFromScreenPoint(in vec2 scr_pt,
    in mat4 view_inv,
    in mat4 proj_inv,
    in mat4 viewp_inv)
{   // Returns world coords of a point on a ray passing through
    // the camera position and scr_pt.

    vec4 ndc = viewp_inv * vec4(scr_pt,0.0,1.0);
        // z=0.0 => it's a ray.  0 is an arbitrary choice in the
        // view volume.
        // w=1.0 => we don't need to undo the perspective divide.
        //      So clip coords == NDC

    vec4 view_coords = proj_inv * ndc;
        // At this point, z=0 will have become something in the
        // middle of the projection volume, somewhere between
        // near and far.
    view_coords = view_coords / view_coords.w;
        // Keepin' it real?  Not sure what happens if you skip this.
    //view_coords.w = 0.0;
        // Remove translation components.  Note that we
        // don't use this trick.
    vec4 world_ray_point = view_inv * view_coords;
        // Now scr_pt is on the ray through camera_pos and world_ray_point
    return world_ray_point;
}

// Function 2725
vec2 normal(in vec2 p) {
    const vec2 NE = vec2(.1,0.);
    return normalize(vec2( height(p+NE)-height(p-NE),
                           height(p+NE.yx)-height(p-NE.yx) ));
}

// Function 2726
vec3 calcNormal( in vec3 pos) 
{
    vec2 e = vec2(0.00001, 0.0);
    return normalize( vec3(sdf(pos+e.xyy).x-sdf(pos-e.xyy).x,
                           sdf(pos+e.yxy).x-sdf(pos-e.yxy).x,
                           sdf(pos+e.yyx).x-sdf(pos-e.yyx).x ) );
}

// Function 2727
vec3 terrainNormal(vec2 pos)
{    
    return vec3(0,0,1);
}

// Function 2728
vec3 getNormal(vec3 pos, float e)
{  
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e2*map(pos + e*e2).x;
    }
    return normalize(n);
}

// Function 2729
vec2 rayMarch(vec3 ro, vec3 rd)
{
    float t = 0.0001;
    vec2 res;
    for(int i = 0; i < MAX_STEPS; i++)
    {
        vec3 p = ro + t*rd;
        res = map(p);
        if(res.x < SURF_DIST || res.x > MAX_DIST) break;
        t += res.x;
    }

    if (t > MAX_DIST) t = -1.0;
    
    return vec2(t, res.y);
}

// Function 2730
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.0001;             // precision of the normal computation

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ).x + 
					  v2*doModel( pos + v2*eps ).x + 
					  v3*doModel( pos + v3*eps ).x + 
					  v4*doModel( pos + v4*eps ).x );
}

// Function 2731
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in mat4 boxTransform, in mat4 inverseBoxTransform, in vec3 boxHalfSizes, out vec2 uv ) 
{
    // convert from ray to box space
	vec3 rdd = (boxTransform*vec4(rayDirection,0.0)).xyz;
	vec3 roo = (boxTransform*vec4(rayOrigin,1.0)).xyz;

	// ray-box intersection in box space
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*boxHalfSizes;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );
	
	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	vec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (abs(normal.x) > 0.9)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (abs(normal.y) > 0.9)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
    
    vec3 relPoint = roo + rdd * timeNear;
    
	uv = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);    

    // convert to ray space
	
	normal = (inverseBoxTransform * vec4(normal,0.0)).xyz;

	return vec4( timeNear, normal );
}

// Function 2732
vec4 ray_plane(vec3 ro, vec3 rd, vec4 plane){
    float a = dot(plane.xyz, rd);
    float b = dot(plane.xyz, ro) - plane.w;
    return vec4(plane.xyz, max(0.0, -b/a));
}

// Function 2733
vec3 marchRay (vec3 ro, vec3 rs)
{
    float d = .0;
    float m;
    vec3 r;
    for (int i = 0; i <= 150 && d <= 10.; i++)
    {
        vec3 r = ro + rs*d;
        m = dist3D(r);
        if (m <= 0.001) return r;
        d += m*.7;
    }
}

// Function 2734
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 125.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 2735
float grayscale(vec3 image) {
    return dot(image, vec3(0.3, 0.59, 0.11));
}

// Function 2736
float castRay(inout vec3 p, vec3 dir)
{	
	float t = 0.1;    
	float d = 0.1;
	for (int i = 0; i < 200; i++)
	{
		float h = terrain(p + dir*t);
		if (h < 0.0)
			break;
		
		d *= 1.05;
        t += d;
        if (i == 199)
            return 20000.0;
	}
    
	float t2 = t;
	float h2 = terrain(p + dir*t2);
	if (h2 > 0.0)
		return t2;
	float t1 = t - d*10.0;
	float h1 = terrain(p + dir*t1);
	for (int i = 0; i < 8; i++)
	{
		t = mix(t1, t2, h1/(h1-h2));
		float h = terrain(p + dir*t);
		if (h < 0.0)
		{
            t2 = t; 
            h2 = h;
        }
		else
		{
            t1 = t; 
            h1 = h;
        }
	}	
	p = p + dir*t;
	return t;
}

// Function 2737
HitInfo rayMarch(vec3 o, vec3 d)
{
    const float tMax = 75.0;
    float t = 0.0;
    for(int i=0; i < 40; ++i)
    {
        itCount += 1.0;
        float d = map(o+t*d).d;
        t += d>0.?d:0.75*d;
        if(abs(d)<0.001 || t > tMax)
            break;
    }
    
    HitInfo info = map(o+t*d);
    info.matID = (t>tMax)?MAT_SKY:info.matID;
    info.d = min(t,tMax);
    return info;
}

// Function 2738
vec3 calcNormal(vec3 pos) {
	vec2 eps = vec2(0.001, 0.0);

	vec3 nor = vec3(map(pos + eps.xyy).x - map(pos - eps.xyy).x,
			map(pos + eps.yxy).x - map(pos - eps.yxy).x,
			map(pos + eps.yyx).x - map(pos - eps.yyx).x);
	return normalize(nor);
}

// Function 2739
vec3 getNormal( in vec3 p ){

    // Note the slightly increased sampling distance, to alleviate
    // artifacts due to hit point inaccuracies.
    vec2 e = vec2(0.0025, -0.0025); 
    return normalize(
        e.xyy * map(p + e.xyy) + 
        e.yyx * map(p + e.yyx) + 
        e.yxy * map(p + e.yxy) + 
        e.xxx * map(p + e.xxx));
}

// Function 2740
float ScatteringRayLifetime( float pDensity, float fRand )
{
    // avoid log(0) and divide by 0
    pDensity = clamp( pDensity, 0.000001, 0.999999 );
    
    // avoid log(0)
    fRand = max( 0.000001, fRand );
    
    // logn(X) / logn(X) is the same for all bases
    float g = log2( fRand ) / log2( 1.0f - pDensity );
    return g;
}

// Function 2741
vec3 normal(vec3 p, vec3 dist) 
{
    float eps = dot2(dist) * EPSILON_NRM;
    vec3 n;
    n.y = sea_fragment_map(p); 
    n = vec3(sea_fragment_map(vec3(p.x + eps, p.y, p.z)) - n.y,
	     	 sea_fragment_map(vec3(p.x, p.y, p.z + eps)) - n.y,
	     	 eps);
    return normalize(n);
}

// Function 2742
vec3 ColorForRayWithDepth( vec3 seed, vec4 reflectionData, vec3 shadowData, CameraInfo cam, vec2 uv, vec3 dir, float bestDepth, float weightedDepth )
{
    #if !SHOWBLOB
	    return GetBackgroundColorForRayGivenLightingData( seed, cam.origin, dir, shadowData CACHE );
    #endif
    
    vec3 start = cam.origin;
    vec3 hitPos;
    vec3 colorPos;
    
    #if DEBUG_REFLECTION_RAYS
    	vec3 rayStart;
    	bool hitBlob = false;
        if ( RayHitsBlobBounds( start, dir, rayStart ) )
            hitBlob = MarchReflectionRay( rayStart, dir, hitPos CACHE );
    	colorPos = hitPos;
    #elif DEBUG_SHADOW_RAYS
    	vec3 rayStart;
    	bool hitBlob = false;
        if ( RayHitsBlobBounds( start, dir, rayStart ) )
            hitBlob = MarchShadowRay( rayStart, dir, hitPos CACHE );
    	if ( hitBlob )
            return vec3( 0.0 );
    	colorPos = hitPos;
    #else
    	bool hitBlob = (bestDepth < NO_HIT_DEPTH);
    	hitPos = start + dir * bestDepth;
    	colorPos = start + dir * weightedDepth;
    #endif
    
    if ( !hitBlob )
    {
        #if DEBUG_BOUNDS
            vec3 ignore;
            if ( RayHitsBlobBounds( start, dir, ignore ) )
                return vec3( 0.5, 0.5, 0.5 );
        #endif
        return GetBackgroundColorForRayGivenLightingData( seed, start, dir, shadowData CACHE );
    }
    
    #if DEBUG_BOUNDS
        vec3 scaledHitPos = (hitPos - BLOB_BOUNDING_CENTER) * BLOB_BOUNDING_SCALE;
        if ( dot( scaledHitPos, scaledHitPos ) > BLOB_BOUNDING_RADIUS_SQR * 0.99 )
            return vec3( 1.0, 0.0, 0.0 );
    #endif

    #if DEBUG_SURFACE_REFINEMENT
        if ( BlobDist( hitPos CACHE ) <= 0.0 )
            return vec3( 1.0, 0.0, 0.0 );
    #endif

    vec3 firstDir = dir;
    vec3 normal = GetNormal( hitPos CACHE );
    vec3 pixelColor = BlobColorAtPos( colorPos );
    
    #if SHADOWS_ENABLED
    vec3 ambientColor = mix( AMBIENT_LIGHT_FROM_BELOW, AMBIENT_LIGHT_FROM_ABOVE, normal.y * 0.5 + 0.5 );
    pixelColor *= LIGHT_COLOR * shadowData.x + ambientColor * shadowData.y + BLOB_EMISSION_LIGHT * shadowData.z;
    #endif
    
    pixelColor += BlobEmissionAtPos( colorPos );

    #if REFLECTION_ENABLED
    float backgroundReflectionAmount = reflectionData.w;
    if ( backgroundReflectionAmount > 0.0 )
    {
        // need to do a little bit of antialiasing for places where the reflection changes abruptly (tight surface curves).
        // we just intersect the camera rays with the plane at hitPos with 'normal', and then calculate the normals at the intersection points.
        // the intersection points probably aren't exactly on the surface, but the normals at those points should be close enough.
        
        vec3 reflectionColor = vec3( 0.0 );
        
        float camDistOverPlane = -dot( cam.origin - hitPos, normal );
        for ( int y = 0; y < FULLRES_REFLECTION_SAMPLE_COUNT; y++ )
        {
            for ( int x = 0; x < FULLRES_REFLECTION_SAMPLE_COUNT; x++ )
            {
                vec2 r2 = rand2( seed );
                seed.xy += r2 * 100.0;
                
                vec2 subUv = uv + (vec2( float( x ) + r2.x, float( y ) + r2.y ) / float( FULLRES_REFLECTION_SAMPLE_COUNT ) - vec2( 0.5 )) / iResolution.xy;
                
                vec3 subDir = normalize( cam.bottomLeft + cam.right * subUv.x + cam.up * subUv.y );
                
                float dirDotN = dot( subDir, normal );
                float t = camDistOverPlane / dirDotN;
                
                vec3 subHitPos = cam.origin + subDir * t;
                
                vec3 subNormal = GetNormal( subHitPos CACHE );

                dir = reflect( subDir, RandomizeNormal( subNormal, seed, BLOB_REFLECT_BLUR ) );

                vec3 bgColor = GetBackgroundColorForRayGivenLightingData( seed, hitPos, dir, FAKE_BACKGROUND_SHADOW_DATA_FOR_REFLECTIONS * GetBrightnessForTime( blobTime ) CACHE );

                reflectionColor += bgColor;
            }
        }
        
        pixelColor += reflectionColor * backgroundReflectionAmount / float( FULLRES_REFLECTION_SAMPLE_COUNT * FULLRES_REFLECTION_SAMPLE_COUNT );
    }
    pixelColor += reflectionData.xyz;
    #endif
    
    return pixelColor;
}

// Function 2743
vec3 ray_at(vec3 ro,vec3 rd, float t)
{
	return ro + t * rd;
}

// Function 2744
vec3 rayDir(vec3 camFwd, float fov, vec2 uv)
{
    // In what direction to shoot?
    vec3 camUp = vec3(0.,0.,1.);
    camUp = normalize(camUp - camFwd*dot(camFwd, camUp)); // Orthonormalize
    vec3 camRight = cross(camFwd, camUp);
    return normalize(camFwd + (uv.x * camRight + uv.y * camUp)*fov);
}

// Function 2745
Intersection raySphereIntersection(in Ray ray, in Sphere sphere)
{
	Intersection i;
	i.hit = false;
	
	vec3 centerToOrigin = ray.origin - sphere.center;
	float dotProduct = dot(ray.direction, centerToOrigin);
	float squareRootTerm = pow(dotProduct, 2.0) - pow(length(centerToOrigin), 2.0) + pow(sphere.radius, 2.0);
	if (squareRootTerm < 0.0)
	{
		return i;
	}
	
	float distanceToHit = (-dotProduct) - sqrt(squareRootTerm);
	if (distanceToHit < 0.0)
	{
		return i;
	}
	i.position = ray.origin + (ray.direction * distanceToHit);
	i.normal = normalize(i.position - sphere.center);
	i.material = sphere.material;
	i.hit = true;
	return i;
}

// Function 2746
vec3 normal(in Ray ray) {
    vec2 eps = vec2(0.0001, 0);
    float baseDist = sceneDist(ray).d;
 	return normalize(vec3(
        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - baseDist,
        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d - baseDist,
        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d - baseDist
        ));
}

// Function 2747
vec3 RayMarchCloud(Ray ray, vec3 sunDir, vec3 bgColor)
{
    vec3 rayPos = ray.o;
    rayPos += ray.dir * (kCloudHeight - rayPos.y) / ray.dir.y;
    
    float dl = 1.0;
    float scatter = 0.0;
    vec3 t = bgColor;
    for(int i = 0; i < RAYMARCH_CLOUD_ITER; i++) {
        rayPos += dl * ray.dir;
        float dens = SmoothNoise(vec3(0.05, 0.001 - 0.001 * iTime, 0.1) * rayPos - vec3(0,0, 0.2 * iTime)) * 
            SmoothNoise(vec3(0.01, 0.01, 0.01) * rayPos);
        t -= 0.01 * t * dens * dl;
        t += 0.02 * dens * dl;
	}
    return t;
}

// Function 2748
bool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, float max_t, vec3 aabb_mins, vec3 aabb_maxs)
{
    vec3 t0 = (aabb_mins - ray_origin) * rcp_ray_delta;
    vec3 t1 = (aabb_maxs - ray_origin) * rcp_ray_delta;
    vec4 tmin = vec4(min(t0, t1), 0.);
    vec4 tmax = vec4(max(t0, t1), max_t);
    return max_component(tmin) <= min_component(tmax);
}

// Function 2749
vec4 findnormal(vec4 p, float len) {
    vec2 eps = vec2(0.01,0.0);
    
    return normalize(vec4(
        map(p+eps.xyyy)-len,
        map(p+eps.yxyy)-len,
        map(p+eps.yyxy)-len,
        map(p+eps.yyyx)-len));
}

// Function 2750
Ray getViewRay(vec2 iResolution, vec2 fragCoord){
    vec3 lookAt = vec3(25. * apPhasesStates[AP_BIRDS_SPREAD], 0., 0.);
    float rad = 50. + 50. * apPhasesStates[AP_ANIMATE_HEIGHT];
    float ang = (QPI * pow(apPhasesStates[AP_SHAPE_SPHERE_CUT_TOP], 2.5))
              + (-QPI * apPhasesStates[AP_SHAPE_SPHERE_CUT_FRONT])
              + (HPI * pow(apPhasesStates[AP_ANIMATE_ROLL], 8.))
              + (-HPI * apPhasesStates[AP_ANIMATE_WINGS]);
    vec3 eye = vec3(rad * sin(ang),
                    30. * apPhasesInvStates[AP_SHAPE_SPHERE_CUT_TOP]
                   +30. * apPhasesStates[AP_SHAPE_WING_CUT_TOP_BOTTOM],
                    rad * cos(ang));
    
    vec2 offset = vec2(0.);//vec2(iResolution.x * .15, 0.);
    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord + offset);
    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;
    
    return Ray(eye, worldDir);
}

// Function 2751
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p, cm, fv;
  float dHit, d, dd, s;
  cMid = sign (ro) * floor (abs (ro) + 0.5);
  cm = mod (cMid, 2.);
  s = cm.x + cm.y + cm.z;
  if (s == 1. || s == 2.)
     cMid += step (abs (cm.yzx - cm.zxy), vec3 (0.5)) * sign (ro - cMid);
  dHit = 0.;
  for (int j = 0; j < 220; j ++) {
    p = cMid - (ro + dHit * rd);
    fcId = 0.;
    d = dstFar;
    for (float k = 1.; k <= 7.; k ++) {
      fv = FcVec (k);
      s = dot (fv, rd);
      if (s != 0.) {
        dd = dot (p + sign (s) * fv, fv)  / s;
        if (dd < d) {
          d = dd;
          fcId = sign (s) * k;
        }
      }
    }
    cMid = floor (cMid + 2. * sign (fcId) * FcVec (abs (fcId)) + 0.5);
    dHit += d;
    if (HitMand (cMid) || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2752
float raymarchTerrain(Ray ray)
{
	float t = CAMERA_NEAR, h = 0.;
    for (int i = 0; i < 200; ++i)
    {
    	vec3 pos = ray.origin + ray.direction * t;
        h = pos.y - terrainFbm(pos.xz, MQ_OCTAVES, iChannel0);
        if (abs(h) < (t * .002) || t > CAMERA_FAR)
            break;
        t += h * .5;
    }
    return t;
}

// Function 2753
bool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, vec3 aabb_mins, vec3 aabb_maxs)
{
    return ray_vs_aabb(ray_origin, rcp_ray_delta, 1., aabb_mins, aabb_maxs);
}

// Function 2754
vec3 map_ray(vec3 ro, vec3 rd, vec3 nrm, int c) { 
    if (c == mtLight)	 return map_light_ray(ro, rd, nrm);
    else if (c == mtSsph)return map_Ssph_ray(ro, rd, nrm);
    else if (c == mtGsph)return map_Gsph_ray(ro, rd, nrm);
    else if (c == mtBox) return map_box_ray(ro, rd, nrm);
    else return rd;
}

// Function 2755
vec3 normal(vec3 ray_hit_position, float smoothness)
{	
    // From https://www.shadertoy.com/view/MdSGDW
	vec3 n;
	vec2 dn = vec2(smoothness, 0.0);
	n.x	= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;
	n.y	= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;
	n.z	= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;
	return normalize(n);
}

// Function 2756
float raySphere(vec3 center, float radius, vec3 ray, vec3 rayOrigin)
{
    center -= rayOrigin;
    float b = -dot(center, ray);
    float c = dot(center,center) - radius*radius;
    float D = b*b - c;
    if(D < 0.0)
    {
        return 0.0;
    }
    else
    {
        return -b - sqrt(D);
    }
}

// Function 2757
RMInfo Raymarch(vec3 from, vec3 to)
{
    float t = 0.;
    int objId = BACKGROUND_ID;
    vec3 pos;
    vec3 normal;
    float dist;
    
  	for (int i = 0; i < NUM_STEPS; ++i)
    {
    	pos = from + to * t;
        dist = Ring(pos);

        if (dist > MAX_DIST || abs(dist) < MIN_DIST)
            break;

        t += dist * 0.43;
        objId = RING_ID;
  	}
    
    if (t < MAX_DIST)
    {
        normal = SurfaceNormal(pos);
    }
    else
    {
        objId = BACKGROUND_ID;
    }

    return RMInfo(pos, normal, objId);
}

// Function 2758
vec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {
	float b = dot( p, dir );
	float c = dot( p, p ) - r * r;
	
	float d = b * b - c;
	if ( d < 0.0 ) {
		return vec2( 1e4, -1e4 );
	}
	d = sqrt( d );
	
	return vec2( -b - d, -b + d );
}

// Function 2759
bool raySphereIntersect(vec3 rd, vec3 sphere, float radius, out vec2 hit
){hit=vec2(0)
 ;float b=dot(sphere, rd)
 ;float c=dot(sphere, sphere) - radius * radius
 ;float d=b*b-c
 ;//if (dot(rd, normalize(sphere)) > 1.0) return false
 ;if (d < 0.0)return false
 ;d=sqrt(d)
 ;hit=vec2(-b-d,d-b);return true;}

// Function 2760
bool raySphereIntersection(in Ray ray, in Sphere sphere, inout Intersection currentInter, int sptr){
    vec3 oc = ray.origin - sphere.position;
    float b = dot( oc, ray.direction );
    float c = dot( oc, oc ) - sphere.radius2;
    float h = b*b - c;
    if( h<0.0 ) return false;
    h = sqrt( h );
    float t1 = -b-h;
    float t2 = -b+h;
    float t = 0.0f;
    if(t1 < 0.0f && t2 < 0.0f) return false;
    else if(t1 > 0.0f){
    	if(t2 > 0.0f) t = min(t1,t2);
        else t = t1;
    }else{
    	t = t2;
    }
    if(t > currentInter.t && currentInter.hit) return true;
    vec3 point = ray.origin + t *  ray.direction;
    vec3 normal = (point - sphere.position) / sphere.radius;   
    currentInter = yay(point, t, normal, ray, sphere.material,  -1, sptr);
    return true;
}

// Function 2761
float IntersectRay(Ray r1, Ray r2) {
    vec3 a = r1.o+r1.d;
    vec3 b = r2.o+r2.d;
    vec3 c = a-b;
    return _notreallyperpdot(c, a)/_notreallyperpdot(a, b);
}

// Function 2762
vec4 Raymarch_GetColor( vec3 vRayOrigin, vec3 vRayDir )
{
    vec4 vColor = vec4(0);
    
    return vColor;
}

// Function 2763
float Intersect_Ray_Cube(
vec3 rp, vec3 rd, 
vec3 cp, vec3 cth, 
out vec2 t)
{	
	rp -= cp;
	
	vec3 m = 1.0 / -rd;
	vec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);
	
	vec3 uf = (rp + o) * m;
	vec3 ub = (rp - o) * m;
	
	t.x = max(uf.x, max(uf.y, uf.z));
	t.y = min(ub.x, min(ub.y, ub.z));
	
	// if(ray start == inside cube) 
	if(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}
	
	return t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);
}

// Function 2764
vec3 SceneNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 normal = vec3(
	    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),
	    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),
	    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );
	return normalize( normal );
}

// Function 2765
vec3 normal( in vec3 p )
{
	vec3 eps = vec3(0.0001, 0.0, 0.0);
	return normalize( vec3(
		map(p+eps.xyy)-map(p-eps.xyy),
		map(p+eps.yxy)-map(p-eps.yxy),
		map(p+eps.yyx)-map(p-eps.yyx)
	) );
}

// Function 2766
float computeMeanDensRay(float y, float z, float r)
{
	float xmax = sqrt(abs(r*r - y*y));
	return DENS*(-(2./3.)*pow(xmax,3.)/(rad*rad)+2.*xmax-(2.*(y*y+z*z))*xmax/(rad*rad));
}

// Function 2767
vec3 calcWaterNormal(vec3 p, float t) {
 
    //vec2 eps = vec2(EPSILON * t, 0.);
    //vec3   n = vec3(getHeight(p.xz - eps.xy) - getHeight(p.xz + eps.xy),
    //                2. * eps.x,
    //                getHeight(p.xz - eps.yx) - getHeight(p.xz + eps.yx));
    //return normalize(n);
    
    float eps = EPSILON * t;
    float h   = getHeight(p.xz);
    vec3  n   = vec3(
        getHeight(p.xz + vec2(eps,0.)) - h,
        eps,
        getHeight(p.xz + vec2(0.,eps)) - h
    );
    return normalize(n);
    
}

// Function 2768
bool RayBoxIntersection(Ray r, Box b, out HitInfo hitInfo)
{
	vec3 invdir = 1.0 / (r.dir * MAX_RAY_DISTANCE);
    vec3 minC = b.pos - b.ext;
    vec3 maxC = b.pos + b.ext;
	
	vec3 p0Int = (minC - r.pos) * invdir;
	vec3 p1Int = (maxC - r.pos) * invdir;
	
	vec3 closest = min(p0Int, p1Int);
	vec3 furthest = max(p0Int, p1Int);

	float minT = max(closest.x, max(closest.y, closest.z));
	float maxT = min(furthest.x, min(furthest.y, furthest.z));
		
    if (maxT < 0.0 || minT > maxT)
    {
        return false;
    }
    
	hitInfo.t = minT * MAX_RAY_DISTANCE;
	hitInfo.pos = PointFromRay(r, hitInfo.t);
	hitInfo.mat = b.mat;
    
    if(minT == p0Int.x)
        hitInfo.normal = vec3(-1,0,0);     
    else if(minT == p1Int.x)
        hitInfo.normal = vec3(1,0,0);
    else if(minT == p0Int.y)
        hitInfo.normal = vec3(0,-1,0);
    else if(minT == p1Int.y)
        hitInfo.normal = vec3(0,1,0);
    else if(minT == p0Int.z)
        hitInfo.normal = vec3(0,0,-1);
    else// if(minT == p1Int.z)
        hitInfo.normal = vec3(0,0,1);        
        
	return true;
}

// Function 2769
vec3 calcNormal( in vec3 pos )
{
    // from Paul Malin (4 samples only in a tetrahedron	
    vec2 e = vec2(1.0,-1.0)*0.002;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 2770
bool RayVsPlane(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in vec3 diffuse)
{
    float dist = -1.0f;
    float denom = dot(plane.xyz, rayDir);
    if (abs(denom) > 0.001f)
    {
        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;
    
        if (dist > 0.0f && dist < info.dist)
        {
            info.dist = dist;        
            info.normal = plane.xyz;
            info.diffuse = diffuse;
            return true;
        }
    }
    return false;
}

// Function 2771
float ray(inout vec3 cp, vec3 rd, out float cd)
{
  float st = 0.;
  for(;st < 1.; st += 1. /128.)
  {
    cd = map(cp);
    if(cd < .01)
    {
      break;
    }
    cp += rd * cd * .75;
  }

  return st;
}

// Function 2772
vec3 get_normal( in vec3 p ) {  // sample along 3 axes to get a normal  
    const float o = 0.0009765625; // 1 / 1024
    float c = f(p); // calculate redundantly for now to avoid the bug
    const vec2 h = vec2(o, 0); // transpose instead of making new per axis
    return normalize(vec3( f(p + h.xyy) - c,
                           f(p + h.yxy) - c,
                           f(p + h.yyx) - c) );
}

// Function 2773
Hit raymarch(Ray ray) {
 
    vec3 p = ray.ori;
    float t = 0.;
    int id = -1;
    
    for(int i = 0; i < MAX_ITERATIONS; i++) {
     
        Dist d = distScene(p);
        p += ray.dir * d.dist;
        
        if(d.dist <= MIN_DISTANCE) {
         
            t = d.dist;
            id = d.id;
            
            break;
            
        }
        
    }
    
    return Hit(p,Dist(t,id));
    
}

// Function 2774
vec3 normal(vec3 p){
    return normalize(vec3(map(vec3(p.x + 0.0001, p.yz)) - map(vec3(p.x - 0.0001, p.yz)),
                          map(vec3(p.x, p.y + 0.0001, p.z)) - map(vec3(p.x, p.y - 0.0001, p.z)),
                	      map(vec3(p.xy, p.z + 0.0001)) - map(vec3(p.xy, p.z - 0.0001))));
}

// Function 2775
vec2 alignNormal(vec2 h, vec2 d) {
    return h * sign(dot(h, CART_FROM_HEX(d)));
}

// Function 2776
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 80; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2777
Ray createCameraRay(Camera cam, vec2 uv)
{
    vec3 right = normalize(cross(cam.direction,cam.up));
    vec3 direction = cam.direction
        + cam.up * 2.0 * (uv.y - 0.5)
        + right * 2.0 * (0.5 - uv.x);
    Ray ray;
    ray = createRay(cam.position, direction);
    return ray;
}

// Function 2778
bool RayBox( in vec3 p, in vec3 dir, in vec3 pos, in vec3 edge, out float t
		//	inout vec2 startend,
		//	inout vec3 nor, 
		//	inout vec3 hit
		   )
{
	float fix=.00001;
	vec3 minim=pos-edge*.5;
	vec3 maxim=pos+edge*.5;
	vec3 inv_dir = vec3(1.)/dir;
	vec3 omin = ( minim - p ) * inv_dir;
	vec3 omax = ( maxim - p ) * inv_dir;
	vec3 maxi = max ( omax, omin );
	vec3 mini = min ( omax, omin );
	vec2 startend;
	startend.y = min ( maxi.x, min ( maxi.y, maxi.z ) );
	startend.x = max ( max ( mini.x, 0.0 ), max ( mini.y, mini.z ) );
	float rayhit=0.;
	if (startend.y-startend.x>fix) rayhit=1.;

	t = startend.x;
	
//	hit=p+startend.x*dir; //intersection point
/*	
	// get normal
		nor=vec3(0.,0.,-1.);
		if (abs(hit.x-minim.x)<fix) nor=vec3( 1., 0., 0.);
		if (abs(hit.y-minim.y)<fix) nor=vec3( 0., 1., 0.);
		if (abs(hit.z-minim.z)<fix) nor=vec3( 0., 0., 1.);
		if (abs(hit.x-maxim.x)<fix) nor=vec3(-1., 0., 0.);
		if (abs(hit.y-maxim.y)<fix) nor=vec3( 0.,-1., 0.);
*/
	return rayhit>0.5;
}

// Function 2779
vec3 CastRay( in Ray_t ray, 
              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) 
{
    // Find whether and where the ray hits some object. 
    // Take the nearest hit point.

    bool hasHitSomething = false;
    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.
    vec3 nearest_hitPos;              // 3D position of the nearest hit point.
    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.
    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.

    float temp_t;
    vec3 temp_hitPos;
    vec3 temp_hitNormal;
    bool temp_hasHit;

    /////////////////////////////////////////////////////////////////////////////
    // TASK:
    // * Try interesecting input ray with all the planes and spheres,
    //   and record the front-most (nearest) interesection.
    // * If there is interesection, need to record hasHitSomething,
    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.
    /////////////////////////////////////////////////////////////////////////////

    // check if the ray intersects with each plane
    for (int i = 0 ; i < NUM_PLANES ; i++) {
        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, 
                                     temp_t, temp_hitPos, temp_hitNormal);
        if (temp_hasHit && temp_t < nearest_t) {
            hasHitSomething = true;
            nearest_t = temp_t;
            nearest_hitPos = temp_hitPos;
            nearest_hitNormal = temp_hitNormal;
            if (i == 0) {
                // for the horizontal plane
                // calculate texture coordinates of the galaxy floor
                float galaxy_x = temp_hitPos.x - global_center.x + galaxy_L / 2.0;
                float galaxy_y = temp_hitPos.z - global_center.z + galaxy_W / 2.0;
                vec2 galaxy_coord = vec2(galaxy_x / galaxy_L * iResolution.x, galaxy_y / galaxy_W * iResolution.y);
                vec4 galaxy_color;
                // get galaxy color
                getGalaxy(galaxy_color, galaxy_coord);
                // if inside the focus circle, make it darker
                float focus_distance = (temp_hitPos.x - global_center.x) * (temp_hitPos.x - global_center.x) + 
                              (temp_hitPos.z - global_center.z) * (temp_hitPos.z - global_center.z);
                if (focus_distance <= focus_radius) galaxy_color.rgb *= focus_darker;
                // set galaxy color to material 8, and it will be used later
                Material[8].k_d = galaxy_color.rgb;
                Material[8].k_a = 0.2 * Material[0].k_d;
                Material[8].k_r = 2.0 * Material[0].k_d;
                Material[8].k_rg = 0.5 * Material[0].k_r;
                Material[8].n = 64.0;
                nearest_hitMatID = 8;
            }
            else if (i == 1)
                nearest_hitMatID = Plane[i].materialID;
        }
    }

    // check if the ray intersects with each sphere
    for (int i = 0 ; i < NUM_SPHERES ; i++) {
        // if the ball is not visible right now, skip it
        // to be more cost-efficient
        if (!Sphere[i].visible) continue;
        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, 
                             temp_t, temp_hitPos, temp_hitNormal);
        // if hits and a smaller t value is got, update information of the nearest point
        if (temp_hasHit && temp_t < nearest_t) {
            hasHitSomething = true;
            nearest_t = temp_t;
            nearest_hitPos = temp_hitPos;
            nearest_hitNormal = temp_hitNormal;
            nearest_hitMatID = Sphere[i].materialID;
        }
    }

    // check if the ray intersects with each box
    for (int i = 0 ; i < NUM_BOXES ; i++) {
        // if the ball is not visible right now, skip it
        // to be more cost-efficient
        if (!Box[i].visible) continue;
        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, 
                             temp_t, temp_hitPos, temp_hitNormal);
        // if hits and a smaller t value is got, update information of the nearest point
        if (temp_hasHit && temp_t < nearest_t) {
            hasHitSomething = true;
            nearest_t = temp_t;
            nearest_hitPos = temp_hitPos;
            nearest_hitNormal = temp_hitNormal;
            nearest_hitMatID = Box[i].materialID;
        }
    }

    /////////////////////////////////
    // TASK: WRITE YOUR CODE HERE. //
    /////////////////////////////////



    // One of the output results.
    hasHit = hasHitSomething;
    if ( !hasHitSomething ) return BACKGROUND_COLOR;

    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.

    /////////////////////////////////////////////////////////////////////////////
    // TASK:
    // * Accumulate lighting from each light source on the nearest hit point. 
    //   They are all accumulated into I_local.
    // * For each light source, make a shadow ray, and check if the shadow ray
    //   intersects any of the objects (the planes and spheres) between the 
    //   nearest hit point and the light source.
    // * Then, call PhongLighting() to compute lighting for this light source.
    /////////////////////////////////////////////////////////////////////////////

    // for each light, check if it can reach the hitting point
    for (int i2 = 0 ; i2 < NUM_LIGHTS ; i2++) {
        // construct shadow ray, points from hitting point to the light source
        vec3 shadow_ray_d = normalize( Light[i2].position - nearest_hitPos );
        Ray_t shadow_ray = Ray_t(nearest_hitPos + shadow_ray_d * DEFAULT_TMIN, shadow_ray_d);
        bool inShadow = false;
        bool temp_inShadow = false;
        // the shadow ray cannot reach any point beyond the light source
        float tmax_to_light = dot(shadow_ray_d, (Light[i2].position - nearest_hitPos));

        // check if any plane blocks the shadow ray
        for (int j = 0 ; j < NUM_PLANES ; j++) {
            temp_inShadow = IntersectPlane(Plane[j], shadow_ray, DEFAULT_TMIN, tmax_to_light);
            if (temp_inShadow) {
                inShadow = temp_inShadow;
                break;
            }
        }

        // check if any sphere blocks the shadow ray
        if (!inShadow) {
             for (int k = 0 ; k < NUM_SPHERES ; k++) {
                 if (!Sphere[k].visible) continue;
                 temp_inShadow = IntersectSphere(Sphere[k], shadow_ray, DEFAULT_TMIN, tmax_to_light);
                 if (temp_inShadow) {
                     inShadow = temp_inShadow;
                     break;
                 }
             }
        }
        
        // check if any box blocks the shadow ray
        if (!inShadow) {
             for (int m = 0 ; m < NUM_BOXES ; m++) {
                 if (!Box[m].visible) continue;
                 temp_inShadow = IntersectBox(Box[m], shadow_ray, DEFAULT_TMIN, tmax_to_light);
                 if (temp_inShadow) {
                     inShadow = temp_inShadow;
                     break;
                 }
             }
        }
        // debug with default no shadow
        I_local += PhongLighting(shadow_ray.d, nearest_hitNormal, -ray.d, inShadow, 
                                 Material[nearest_hitMatID], Light[i2]);
            
    }
    /////////////////////////////////
    // TASK: WRITE YOUR CODE HERE. //
    /////////////////////////////////



    // Populate output results.
    hitPos = nearest_hitPos;
    hitNormal = nearest_hitNormal;
    k_rg = Material[nearest_hitMatID].k_rg;

    return I_local;
}

// Function 2780
vec4 ray(vec3 src, vec3 direction, float globalTime)
{
	return vec4(intersects(src, direction, globalTime), 1);
}

// Function 2781
float castRay( in vec3 ro, vec3 rd ) {
  float t = 0.0;
    for (int i=0; i<100; i++)
    {
    	vec3 pos = ro + t*rd;
        float h = map( pos );
        // h < 0.001 means that we are inside the sphere
        if(h<0.001 || t>FAR ) break;
        t += h;
        if ( t>FAR ) break;
    }   
    if (t>FAR) t = -1.0;
    
    return t;
}

// Function 2782
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.002;             // precision of the normal computation

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ).x + 
					  v2*doModel( pos + v2*eps ).x + 
					  v3*doModel( pos + v3*eps ).x + 
					  v4*doModel( pos + v4*eps ).x );
}

// Function 2783
vec3 GetNormal(vec3 p, float sphereR)
{
	vec2 eps = vec2(sphereR, 0.0);
	return normalize( vec3(
           Map(p+eps.xyy) - Map(p-eps.xyy),
           Map(p+eps.yxy) - Map(p-eps.yxy),
           Map(p+eps.yyx) - Map(p-eps.yyx) ) );
}

// Function 2784
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) 
{
	// ray-box intersection
    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis
    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin
    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge
	
    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.
    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );

	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
    if (timeNear < 0.0)
        timeNear = timeFar;
    
    vec3 relPoint = rayOrigin + rayDirection * timeNear;
    
    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;
    
    vec3 normal;
    vec3 uaxis;
    vec3 vaxis;
    // if Y isn't the biggest value it can't be the normal axis
    if (absRelPoint.x >= absRelPoint.y)
    {
        // if X is the winner
        if (absRelPoint.x >= absRelPoint.z)
        {
            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);
			uaxis = vec3(0.0,1.0,0.0);
			vaxis = vec3(0.0,0.0,1.0);            
        }
        // else it's Z
        else
        {
            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,1.0,0.0);            
        }
    }
    // else X isn't the biggest value so it can't be the normal axis
    else
    {
        // if Y is the winner
        if (absRelPoint.y >= absRelPoint.z)
        {
            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,0.0,1.0);	           
        }
        // else it's Z
        else
        {
            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);
			uaxis = vec3(1.0,0.0,0.0);
			vaxis = vec3(0.0,1.0,0.0);            
        }        
    }
    
	uv = vec2
	(
		dot(relPoint, uaxis),
		dot(relPoint, vaxis)
	);    

	return vec4( timeNear, normal );    
}

// Function 2785
float rayMarching(vec3 ro, vec3 rd) {
    float d = 0.;
    for(int i = 0; i < 50; i++) {
        float dScene = getDistance(ro + rd * d);
        if( d > MAX_DIST || dScene < SURF_DIST*0.99) break;
        d += dScene;
    }
    return d;
}

// Function 2786
float phaseRayleigh(float c)
{
 	return 3.0 / (16.0 * PI) * (1.0 + c * c);
}

// Function 2787
vec3 calc_normal(vec3 p)
{
	vec3 n;
	n.x = dist(p + vec3(0.01,0.0,0.0)) - dist(p - vec3(0.01,0.0,0.0));
	n.y = dist(p + vec3(0.0,0.01,0.0)) - dist(p - vec3(0.0,0.01,0.0));
	n.z = dist(p + vec3(0.0,0.0,0.01)) - dist(p - vec3(0.0,0.0,0.01));
	return normalize(n);
}

// Function 2788
vec3 calcNormal(vec3 p)
{
    float e = 0.01;
    
    vec3 normal;
    vec3 f,u;
    normal.x = sceneDf(vec3(p.x + e,p.y,p.z), f,u) - sceneDf(vec3(p.x - e, p.y, p.z), f,u);
    normal.y = sceneDf(vec3(p.x,p.y + e,p.z), f,u) - sceneDf(vec3(p.x, p.y - e, p.z), f,u);
    normal.z = sceneDf(vec3(p.x,p.y,p.z + e), f,u) - sceneDf(vec3(p.x, p.y, p.z - e), f,u);
    
    return normalize(normal);
}

// Function 2789
vec3 getNormal( in vec3 pos )
{
    
	vec3 eps = vec3( 0.01, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy) - map(pos-eps.xyy),
	    map(pos+eps.yxy) - map(pos-eps.yxy),
	    map(pos+eps.yyx) - map(pos-eps.yyx) );
	return normalize(nor);
}

// Function 2790
MarchRes marchRay(vec3 pos, vec3 dir, float speed)
{
 	MarchRes res;
    Object o;
    
    res.totalDist = 0.001;
    res.minDist = 1000.0;

    for(int x=0; x<250; x++)
    {
 		res.curRay = pos + (dir*res.totalDist);
        
        o = map(res.curRay);
        
        if(abs(o.dist) < 0.001)
        {
            res.obj = o;
            break;
        }
        else if(res.totalDist >= VIEW_DIST) break;
           
        
        if(o.dist < res.minDist) res.minDist = o.dist;
        res.totalDist += o.dist*speed;
    }
    
    if(res.totalDist < VIEW_DIST)
    {
        o.normal = calcNormal(res.curRay, o.normEps);
        
        res.obj = o;
    }
    	
    
    return res;
}

// Function 2791
vec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )
{
    //float tt = (150.0-ro.y)/rd.y; if( tt>0.0 ) tmax = min( tmax, tt );
    
    float dis, th;
    float t2 = -1.0;
    float t = tmin; 
    float ot = t;
    float odis = 0.0;
    float odis2 = 0.0;
    for( int i=ZERO; i<400; i++ )
    {
        th = 0.001*t;

        vec3  pos = ro + t*rd;
        vec2  env = terrainMap( pos.xz );
        float hei = env.x;

        // tree envelope
        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);
        if( dis2<th ) 
        {
            if( t2<0.0 )
            {
                t2 = ot + (th-odis2)*(t-ot)/(dis2-odis2); // linear interpolation for better accuracy
            }
        }
        odis2 = dis2;
        
        // terrain
        dis = pos.y - hei;
        if( dis<th ) break;
        
        ot = t;
        odis = dis;
        t += dis*0.8*(1.0-0.75*env.y); // slow down in step areas
        if( t>tmax ) break;
    }

    if( t>tmax ) t = -1.0;
    else t = ot + (th-odis)*(t-ot)/(dis-odis); // linear interpolation for better accuracy
    return vec2(t,t2);
}

// Function 2792
vec3 RayMarch(vec3 ro, vec3 rd){
    float dt = 0.0;
    for (int i = 0; i < MAX_STEPS; i++){
        vec3 p = ro + dt * rd;
        Hit hit = map(p);
        float dist = hit.d;
        if(dist < MIN_DIST){
            isHit = true;
            break;
        }
        if(isHit == true || dist > MAX_DIST){
            return vec3(0.0, 0.0, 0.2);
            break;
        }
        dt += dist*0.925; // Multiplied by 0.925 to stop weird things from happening
    }
    return ro + dt * rd;
}

// Function 2793
float raymarchAO(in vec3 ro, in vec3 rd, float tmin) {
    float ao = 0.0;
    for (float i = 0.0; i < 5.0; i++) {
        float t = tmin + pow(i / 5.0, 2.0);
        vec3 p = ro + rd * t;
        float d = p.y - fBm(p.xz);
        ao += max(0.0, t - 0.5 * d - 0.05);
    }
    return 1.0 - 0.4 * ao;
}

// Function 2794
float raymarch(vec3 ro,vec3 rd)
{
	float t = 0.;
    vec3 p ;
    for(float i = 0.;i < MAXSTEP;i++)
    {
    	p = ro+rd*t;
        float d = map(p);
        t += d*.1;
        if(abs(d) < EPS || t > FAR) break;
        count += 1./(1.+d*d);
    }
    return t;
}

// Function 2795
vec3 GetNormal(vec3 p) {
	float d = GetDist(p);
    vec2 e = vec2(.001, 0.);
    
    vec3 n = d - vec3(
        GetDist(p - e.xyy),
        GetDist(p - e.yxy),
        GetDist(p - e.yyx));
    
    return normalize(n);
}

// Function 2796
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p, rdi, s, cIdP;
  float dHit, d, eps;
  eps = 0.0005;
  dHit = eps;
  if (repObj) {
    if (rd.x == 0.) rd.x = 0.001;
    if (rd.y == 0.) rd.y = 0.001;
    if (rd.z == 0.) rd.z = 0.001;
    ro /= gSize;
    rd /= gSize;
    rdi = 1. / rd;
    cIdP = vec3 (-99.);
  } else {
    SetEngConf ();
  }
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    if (repObj) {
      cId = floor (p);
      if (cId != cIdP) {
        SetEngConf ();
        cIdP = cId;
      }
      s = (cId + step (0., rd) - p) * rdi;
      p = gSize * (p - (cId + 0.5));
    } else {
      p = ro + dHit * rd;
    }
    d = ObjDf (p);
    if (repObj) d = min (d, abs (Minv3 (s) + eps));
    dHit += d;
    if (d < eps || dHit > dstFar) break;
    if (! repObj && j >= 120) break;
  }
  if (repObj && d >= eps) dHit = dstFar;
  return dHit;
}

// Function 2797
void calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;
	
     // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 2798
vec3 CalcTerrainNormal(const in vec3 mPos, const in float dist)
{
    vec2 eps = vec2(1.0 / iResolution.y * dist * dist, 0.0);
    vec3 nor;
    nor.x = TerrainDisplacement(mPos.xz - eps.xy) - 
        	TerrainDisplacement(mPos.xz + eps.xy);
    nor.y = 0.5 * eps.x;    
    
    nor.z = TerrainDisplacement(mPos.xz - eps.yx) - 
        	TerrainDisplacement(mPos.xz + eps.yx);
    
    nor = normalize(nor);
    
    vec3 msand = DoBumpMap(mPos, nor, 0.07, dist);
    
    return normalize(msand);
}

// Function 2799
vec3 calcuNormal(in vec3 p)
{  
    vec2 e = vec2(-1., 1.)*0.001;   
    return normalize(e.yxx*map2(p + e.yxx).d + e.xxy*map2(p + e.xxy).d + 
                     e.xyx*map2(p + e.xyx).d + e.yyy*map2(p + e.yyy).d );   
}

// Function 2800
void raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {
    eye = rotateY(vec3(0.0, 5.0, 15.0), 3.14159 * 1.5);
    ref = vec3(0.0, 0.0, 0.0);
    
    float len = tan(3.14159 * 0.125) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * iResolution.x / iResolution.y;
    vec3 p = ref + uv.x * H + uv.y * V;
    dir = normalize(p - eye);
}

// Function 2801
RayPayLoad RayMarch(vec3 marchingPosition, vec3 rayDirection, float marchedDistance){
    RayPayLoad result;
    result.minDistToScene = FAR_CLIP;
    result.marchedDistance = marchedDistance;
    for (int i = 0; i < 1024; i++) {
        SceneSamplePayLoad scenePayLoad = GetClosestObject(marchingPosition);
        marchingPosition = marchingPosition + rayDirection * scenePayLoad.distToScene;
        result.marchedDistance = result.marchedDistance + scenePayLoad.distToScene;
        result.minDistToScene = min(result.minDistToScene, scenePayLoad.distToScene);
        if (abs(scenePayLoad.distToScene) < EPSILON){
            // Found object
            result.hitScene = true;
            result.obj = scenePayLoad.closestObj;
            result.hitPosition = marchingPosition;
            result.normal = Normal(scenePayLoad.closestObj, marchingPosition);
            break;
        }
        if (result.marchedDistance > FAR_CLIP){
            // Went too far
            result.hitScene = false;
            break;
        }
    }
    return result;
}

// Function 2802
vec2 rayMarch(in vec3 ro, in vec3 rd, float tol, float tmin, float tmax) {
	float t = tmin;
	float m = -1.0;
    
    for (int i=0; i<60; i++) {
		vec2 res = map(ro+rd*t);
        m = res.y;
		if (res.x < precis || t > tmax)  break;
		t += res.x*tol;
	}

	if (t > tmax) {
		m = -1.0;
	}
	return vec2(t, m);
}

// Function 2803
vec4 rayCrystal3(vec3 rp, vec3 rd) {
    rp -= crystal3_pos;
    return rayCrystal3B(rp,rd);
}

// Function 2804
Hit raymarch(Ray ray) {
 
    vec3 p = ray.ori;
    bool b = false;
    
    for(int i = 0; i < 128; i++) {
     
        float dst = dstScene(p);
        p += ray.dir * dst * .75;
        
        if(dst < .001) {
         
            b = true;
            break;
            
        }
        
    }
    
    return Hit(p,b);
    
}

// Function 2805
vec2 castRay( in vec3 ro, in vec3 rd) {
	float tmin = .10;
	float tmax = 50.0;
	float t = tmin;
	float m = -1.0;
	for (int i = 0; i < 80; i++) {
		float precis = 0.0001 * t;
		vec2 res = map(ro + rd * t);
		if (res.x < precis || t > tmax) break;
		t += res.x * .7;
		m = res.y;
	}
	if (t > tmax) m = -1.0;
	return vec2(t, m);
}

// Function 2806
vec3 normal(vec3 p) {
    return normalize(vec3(
        height(vec3(p.x + EPSILON, p.y, p.z)) - height(vec3(p.x - EPSILON, p.y, p.z)),
        height(vec3(p.x, p.y + EPSILON, p.z)) - height(vec3(p.x, p.y - EPSILON, p.z)),
        height(vec3(p.x, p.y, p.z + EPSILON)) - height(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

// Function 2807
int intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius, out float near, out float far)
{
    vec3 oc = origin - center;
    float a = dot(direction, direction);
    float b = 2. * dot(oc, direction);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4. * a * c;
    if (disc < 0.) {
        // no intersection?
        return 0;
    }

    near = (-b - sqrt(disc)) / (2. * a);
    far = (-b + sqrt(disc)) / (2. * a);
    return 1;
}

// Function 2808
vec3 getNormal(vec3 p) {
    const float h = 0.001;
    vec2 e = vec2(h, 0);	
	const vec2 k = vec2(1., -1.);
    return normalize(k.xyy * getDistance( p + k.xyy*h ) + k.yyx * getDistance( p + k.yyx*h ) + 
                     k.yxy * getDistance( p + k.yxy*h ) + k.xxx * getDistance( p + k.xxx*h ) );
}

// Function 2809
float rayhorizon(float t) {
    return pa_map(pa_init(t)).h;
}

// Function 2810
vec3 calcNormal( in vec3 pos, in float t, in float fovfactor, vec3 c )
{
    vec4 tmp;
    float surface = clamp( 0.3 * 0.0015*t*fovfactor, 0.0001, 0.1 );
    vec2 eps = vec2( surface, 0.0 );
	return normalize( vec3(
           map(pos+eps.xyy,c,tmp) - map(pos-eps.xyy,c,tmp),
           map(pos+eps.yxy,c,tmp) - map(pos-eps.yxy,c,tmp),
           map(pos+eps.yyx,c,tmp) - map(pos-eps.yyx,c,tmp) ) );

}

// Function 2811
bool castray(vec3 orig,vec3 dir,int idx,out vec3 hitp,out vec3 hitnor,out vec4 col,out float mirr)
{
	float best = 1.e12;
	bool tr;
	vec3 tmp1;
	vec3 tmp2;
	vec4 tmp3;
	float mir;
	col = vec4(0.,0.,0.,1.);
	tr = castray_ground(orig,dir,idx,tmp1,tmp2,tmp3,mir);
	if( tr )
	{
		float d = length(tmp1-orig);
		if(d<best)
			{hitp=tmp1;hitnor=tmp2;col=tmp3;mirr=mir;best=d;}
	}
	// now for some balls.
	int i;
	for(i=0;i<50;i++)
	{
		vec2 tstuv = vec2(float(i&7)*0.1,float(i>>3)*0.1);
		vec4 smp1 = texture(iChannel1,tstuv);
		vec4 smp2 = texture(iChannel1,tstuv+vec2(0.05));
		vec3 sp_pos = vec3(fract(smp1.r*20.),fract(smp1.g*20.),fract(smp1.b*20.)) - vec3(0.5);
		vec3 sp_dir = vec3(fract(smp2.r*20.),fract(smp2.g*20.),fract(smp2.b*20.)) - vec3(0.5);
		sp_pos.y += 0.5;
		sp_pos *= 8.;
		sp_dir *= 2.;
		float fwdbak = sin(fract(iTime*0.2*(0.6+0.2*fract(sp_pos.y)))*6.283185);
		tr = castray_ball(orig,dir,idx,tmp1,tmp2,tmp3,mir,sp_pos+sp_dir*fwdbak,0.55);
		if( tr )
		{
//			tmp3 = vec4(0.7,0.3,0.2,1.);
			tmp3 = vec4( 0.1+0.8*float((i>>1)&1) , 0.1+0.8*float((i>>2)&1) , 0.1+0.8*float((i>>3)&1) , 1. );
			float d = length(tmp1-orig);
			mir = 0.1+0.8*float(i&1);
			if(d<best)
				{hitp=tmp1;hitnor=tmp2;col=tmp3;mirr=mir;best=d;}
		}
	}

	tr = castray_ball(orig,dir,idx,tmp1,tmp2,tmp3,mir,vec3(-1.,2.*(fract(iTime*0.25)),0.),0.8);
	if( tr )
	{
		float d = length(tmp1-orig);
		if(d<best)
			{hitp=tmp1;hitnor=tmp2;col=tmp3;mirr=mir;best=d;}
	}
	return best<1.e11;
}

// Function 2812
vec4 raymarch(vec2 resolution, vec2 uv, vec4 start_data, mat4 camera_transform) {
    int steps = 16;
    
    // Convert to range (-1, 1) and correct aspect ratio
    vec2 screen_coords = (uv - 0.5) * 2.0;
    screen_coords.x *= resolution.x / resolution.y;
    
    
    vec3 ray_start_position = camera_transform[3].xyz;
    
    vec3 ray_direction = normalize(vec3(screen_coords * LENS, 1.0));
    ray_direction = (camera_transform * vec4(ray_direction, 0.0)).xyz;
    
    
    float dist = start_data.a * 0.9;
    vec3 sample_point = ray_start_position + dist * ray_direction;
    
    vec4 results = sample_world(sample_point);
    
    float tolerance = 0.0;
    
    for (int i=0; i<steps; i += 1) {
        dist += results.a;
        sample_point += ray_direction * results.a;
        results = sample_world(sample_point);
        
        // TODO: Derive from resolution, camera lens and distance
    	tolerance = LENS / resolution.x * dist;
        
        if (results.a < tolerance) {
        	break; 
        }
    }
    
    vec4 data = vec4(
        vec3(results) * 0.5 + 0.5,
        dist
    );
    
    return data;
}

// Function 2813
vec4 QuadRay(vec3 p, vec3 d) {
    vec3 IDir=1./d;
    float FAR=boxfar2(p.xz,IDir.xz,vec2(0.),vec2(HRES));
    float dist=0.; float LFar=FAR; vec3 cp,fp; vec2 bb; vec4 C;
    float LOD=LODS;
    float LS=pow(2.,LOD);
    float ILS=pow(0.5,LOD);
    for (int i=0; i<72; i++) {
        if (dist>FAR) break;
        if (dist>LFar && LOD<LODS) {
            LOD=LOD+1.;
            LS*=2.;
            ILS*=0.5;
            fp=floor(cp*ILS)*LS;
            LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);
        }
        cp=p+d*dist;
        fp=floor(cp*ILS)*LS;
        C=((LOD==0.)?texture(iChannel0,(fp.xz+vec2(0.5,1.5))*IRES):
           texture(iChannel2,(fp.xz*ILS+vec2(LOD_OFF[int(LOD)]+0.5,0.5))*IRES));
        bb=box(p,IDir,vec3(fp.x,0.,fp.z),vec3(fp.x+LS,C.x,fp.z+LS));
        if ((bb.x>=0. && bb.y>bb.x) || Box(p-vec3(fp.x,0.,fp.z),vec3(LS,C.x,LS))<=0.) {
            if (LOD==0.) {
                return vec4(boxN(p,IDir,vec3(fp.x,0.,fp.z),vec3(fp.x+LS,C.x,fp.z+LS)),bb.x);
            } else if (LOD>0.) {
                LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);
                LOD-=1.;
                LS*=0.5;
                ILS*=2.;
                continue;
            }
        }
        dist+=boxfar2(cp.xz,IDir.xz,fp.xz,fp.xz+LS)+0.001;
    }
    return vec4(-1.);
}

// Function 2814
vec4 raymarch (vec3 ro, vec3 rd)
{
	for (int i=0; i<256; i++)
	{
		float t = map(ro);
		if ( t<0.001 ) return color(ro);
		ro+=t*rd;
	}
	return vec4(0.0);
}

// Function 2815
bool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)
{
    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);
    vec4 intersect = intersectSphere(cameraPos,cameraDir);
    if ( intersect.w > 0.)
    {
        normal = intersect.xyz;
        //normal = normalize(normal+perturb3(normal,.3,30.));
        return true;
    }
    return false;
}

// Function 2816
float rayMarch(Ray r, Sphere sphere) {
	float d0 = 0.;
    
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 p = r.origin + d0*r.direction;
        float dS = getDist(p, sphere);
        d0 += dS;
        
        if (dS < SURFACE_DIST || d0 > MAX_DIST)
            break;
    }
    
    return d0;
}

// Function 2817
float Intersect_Ray_Cube(vec3 rp, vec3 rd, vec3 cth, out vec2 t)
{	
	vec3 m = 1.0 / -rd;
	vec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);
	
	vec3 uf = (rp + o) * m;
	vec3 ub = (rp - o) * m;
	
	t.x = max(uf.x, max(uf.y, uf.z));
	t.y = min(ub.x, min(ub.y, ub.z));
	
	bool inside = t.x < 0.0 && t.y > 0.0;
    
	if(inside) {return 0.0;}
	
	return t.y < t.x ? -1.0 : (t.x > 0.0 ? 1.0 : -1.0);
}

// Function 2818
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 100; j ++) {
    d = ObjDf (ro + rd * dHit);
    if (d < 0.001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 2819
RayInfo RayStack_Get( int index )
{
	return rayStack[index];
    //if ( index < RAY_STACK_SIZE )
    //{
	//	return rayStack[index];
    //}
    //
    //RayInfo result;
    //RayInfo_Clear( result );
    //return result;
}

// Function 2820
vec3 gradNormal(int objId,vec3 p) {
	vec3 g=make_float3(
		dist(objId,p + make_float3(GRADIENT_DELTA, 0, 0)) - dist(objId,p - make_float3(GRADIENT_DELTA, 0, 0)),
		dist(objId,p + make_float3(0, GRADIENT_DELTA, 0)) - dist(objId,p - make_float3(0, GRADIENT_DELTA, 0)),
		dist(objId,p + make_float3(0, 0, GRADIENT_DELTA)) - dist(objId,p - make_float3(0, 0, GRADIENT_DELTA)));

    return normalize(g);
}

// Function 2821
vec3 Normal( vec3 pos )
{
	const vec2 delta = vec2(0,.01);
	vec3 grad;
	grad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );
	grad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );
	grad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );
	return normalize(grad);
}

// Function 2822
vec3 normal(vec3 p) {
     const vec2 NE = vec2(1e-3, 0.);
     return normalize(dfNormal(p)-vec3(dfNormal(p-NE.xyy), 
                      			dfNormal(p-NE.yxy), 
                      			dfNormal(p-NE.yyx)));
}

// Function 2823
vec3 getNormalExclusive(vec3 p)
{    
    vec2 e = vec2(P,0.);

    return safeNormalize(vec3(
        myObject(p+e.xyy)-myObject(p-e.xyy),
        myObject(p+e.yxy)-myObject(p-e.yxy),
        myObject(p+e.yyx)-myObject(p-e.yyx)
    ));
}

// Function 2824
vec3 CreateRayDir(const vec2 vFragCoord, const vec2 aCamRot)
{  
    float vAspectRatio = iResolution.x / iResolution.y;
    float vTan = tan(0.5 * radians(FOV));
    vec3 vRD = vec3(
        (2.0 * ((vFragCoord.x+0.5) / iResolution.x) - 1.0) * vTan * vAspectRatio,
        (1.0 - 2.0 * ((vFragCoord.y+0.5) / iResolution.y)) * vTan,
        -1.0);
    vRD = normalize(vRD);
   	mat3 vMatView = CreateCameraRotationMatrix(aCamRot);
    return vMatView * vRD;
}

// Function 2825
vec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {
    vec3 sd = rp+normal2(rp)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;
    
    //lighting
    vec3 reflDir = reflect(rd,norm);

    vec3 lightDif,lightSpec;
    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);

    return (1.-m.metallic)*lightDif*m.diffuse +
        	(.5+m.metallic*.5)*lightSpec*m.specular +
        	m.emissive ;
}

// Function 2826
vec3 Normal(vec3 position)
{
	vec3 offset = vec3(NORMAL_SMOOTHNESS, 0, 0);
    
    vec3 normal = vec3
    (
        Scene(position - offset.xyz) - Scene(position + offset.xyz),
        Scene(position - offset.zxy) - Scene(position + offset.zxy),
        Scene(position - offset.yzx) - Scene(position + offset.yzx)
    );
    
    return normalize(normal);
}

// Function 2827
vec3 ray_march(in vec3 ray_origin, in vec3 ray_direction)
{
    float total_distance_traveled = 0.0;
    const int NUMBER_OF_STEPS = 64;
    const float MINIMUM_HIT_DISTANCE = 0.001;
    const float MAXIMUM_TRACE_DISTANCE = 1000.0;

    for (int i = 0; i < NUMBER_OF_STEPS; ++i)
    {
        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;

		float distance_to_closest = map_the_world(current_position);

        if (distance_to_closest < MINIMUM_HIT_DISTANCE) 
        {
            vec3 normal = calculate_normal(current_position);
            
            vec3 light_positions[3];
            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));
            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));
            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));
            float light_intensities[3];
            light_intensities[0] = 0.8;
            light_intensities[1] = 0.4;
            light_intensities[2] = 0.7;
            vec3 direction_to_view = normalize(current_position - ray_origin);
            
            vec3 col = vec3(0.0);
            
            for (int j = 0; j < 3; j++)
            {
                vec3 direction_to_light = normalize(current_position - light_positions[j]);
                vec3 light_reflection_unit_vector =
                	 reflect(direction_to_light ,normal);                

                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            
                float ambient_intensity = 0.2;            
                float specular_intensity = 
                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 50.0);
                float backlight_specular_intensity =             
                    0.2* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); 
                float fresnel_base = 1.0 + dot(direction_to_view, normal);
                float fresnel_intensity = 0.10*pow(fresnel_base, 0.3);
                float fresnel_shadowing = pow(fresnel_base, 5.0);            
                float fresnel_supershadowing = pow(fresnel_base, 50.0);
                float attenuation =  pow(total_distance_traveled,2.0)/180.0;

                
            	vec3 colFromLight = vec3(0.0);
                colFromLight += vec3(0.89, 0.0, 0.0) * diffuse_intensity;
                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;
                colFromLight += vec3(1.0) * specular_intensity;            
                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            
                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;
                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;
                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing * col * col;
                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; 
               	colFromLight /= 1.2;
                colFromLight *= light_intensities[j];
                col += colFromLight;
            }
            return col;
        }


        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)
        {
            break;
        }
        total_distance_traveled += distance_to_closest;
    }
    return vec3(0.0);
}

// Function 2828
float SheetRay (vec3 ro, vec3 rd)
{
  vec3 r, q;
  vec2 g;
  float d, dMin, sz, szMax, szMin, grLen;
  bvec2 ilt;
  bool bkTrak;
  grLen = 0.92 * spLen;
  dMin = dstFar / (grLen * szFac);
  ro /= szFac;
  rd /= grLen;
  szMax = float (nBallE.x - 1);
  szMin = 1./32.;
  sz = szMax;
  g = vec2 (0.);
  bkTrak = false;
  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {
    if (sz == szMin) {
      r = GetR (g) - ro;
      q = cross (r, rd);
      if (dot (q, q) < sz * sz) {
        d = dot (r, rd);
        if (d < dMin) {
          dMin = d;
          qgHit = g;
        }
      }
      bkTrak = true;
    }
    q = cross (GetR (g + 0.5 * sz) - ro, rd);
    bkTrak = bkTrak || (dot (q, q) > sz * sz);
    if (bkTrak) {
      bkTrak = false;
      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));
      g.x += ilt.x ? sz : - sz;
      if (! ilt.x) {
        if (sz == 0.5 * szMax) break;
        g.y += ilt.y ? sz : - sz;
        if (! ilt.y) {
          sz *= 2.;
          if (sz == szMax) break;
          bkTrak = true;
        }
      }
    } else if (sz > szMin) sz *= 0.5;
  }
  return dMin * grLen * szFac;
}

// Function 2829
vec3 normal( in vec3 pos ){
    vec2 e = vec2(0.002, -0.002);
    return normalize(
        e.xyy * map(pos + e.xyy) + 
        e.yyx * map(pos + e.yyx) + 
        e.yxy * map(pos + e.yxy) + 
        e.xxx * map(pos + e.xxx));
}

// Function 2830
vec3 rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n);

    float s = 1e8;
    
    if (abs(dn) > 0.0001) {
        s = dot(p-o, n) / dn;
        s += float(s < 0.0) * 1e8;
    }
    
    return o + s*rd;
}

// Function 2831
vec3 calcNormal(vec3 pos)
{
  vec2 e = vec2(1,-1) * 0.002;
  return normalize(
    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ 
    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)
  );
}

// Function 2832
float rayMarchMushrooms(in vec3 iOrigin, in vec3 iRay) {
    
 	float t = 0.0;
    vec3 p = iOrigin;
    for (int i = 0; i < MAX_STEPS; i++) {
        p = iOrigin + t*iRay;
     	float sdist = allMushroomsSDF(p);
        t += sdist;
        if (abs(sdist) < EPSILON) {
            break;
        }
    }
    return t;
    
}

// Function 2833
Trace castRay(in Ray ray, float maxDistance){
    float dist = 0.01;
    float presicion = 0.001;
	vec3 p;
    MapValue mv;
    bool hit = false;
    for(int i=0; i<64; i++){
    	p = rayPoint(ray,dist);
       	mv = map(p);
         dist += 0.5*mv.signedDistance;
        if(mv.signedDistance < presicion)
        {
          hit = true; 
            break;
        } 
         if(dist>maxDistance) break;
       
    }
    return Trace(dist,p,p,ray,ray,mv.material,hit);
}

// Function 2834
vec4 ray_sphere(vec3 ro, vec3 rd, float R){
    float d = dot(-ro, rd);
    vec3 p = ro+d*rd;
    float s = R*R-dot(p, p);
    if(s < 0.0) return vec4(-1.0);
    float o = sqrt(s);
    float t = d - o;
    return vec4(normalize(ro+t*rd), t);
}

// Function 2835
void computeReflectivities(Material material, out Color3 p_L, out Color3 p_G, out float glossyExponent) {
	p_L = mix(material.color, Color3(0.0), material.metal);
	p_G = mix(Color3(0.04), material.color, material.metal);
	glossyExponent = exp2(material.smoothness * 14.0);
}

// Function 2836
vec3 calcNormal( in vec3 pos )
{
    vec2 eps = vec2(.001,0.0);
    return normalize( vec3(map(pos+eps.xyy).x - map(pos-eps.xyy).x,
                           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
                           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 2837
vec3 createRay(vec2 px, mat4 PInv, mat4 VInv)
{


    vec2 pxNDS = px*2. - 1.;
    vec3 rayNDS = vec3 (pxNDS,1.);

    vec4 rayClip = vec4 (rayNDS.xy, -1.0, 1.0);
    vec4 rayEye = PInv * rayClip;

    rayEye.w = 0.;

    vec3 rayWorld = (VInv * rayEye).xyz;
    return normalize (rayWorld);   
}

// Function 2838
vec3 getRayColor(Ray ray) {

    vec3 p =  ray.cp.p;
    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));
    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));
    vec3 col = getColor(ray,p);

    float q = exp(-d*ray.cp.dist);
    col = col*q+matColor*(1.-q);
    return col*ray.share;
}

// Function 2839
vec3 getNormal(vec3 p)
{
	vec3 n = vec3(
        sceneSDF(vec3(p.x - EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x + EPSILON, p.y, p.z)),
    	2. * EPSILON * sign(p.y),
        sceneSDF(vec3(p.x, p.y, p.z - EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z + EPSILON))
	);
    
    vec3 norm = normalize(p);
    n = mix(vec3(norm.x, 0., norm.y), normalize(n),
            smoothstep(0., 1., clamp(abs(p.y)/ 20., 0., 1.)));
    
    return normalize(n);
}

// Function 2840
vec2 castRay(in vec3 ro, in vec3 rd, in float cuttingPlane) {
    vec2 res = vec2(-1.0,-1.0);

    float tmin = 1.0;
    float tmax = 20.0;

    // raytrace floor plane
    float tp1 = (0.0 - ro.y) / rd.y;
    if( tp1>0.0 ) {
        tmax = min( tmax, tp1 );
        res = vec2( tp1, 1.0 );
    }
    
    // raymarch primitives   
    vec2 tb = iBox(ro - vec3(0,0.6,0), rd, vec3(1.2, 0.6, 0.6));
    if (tb.x < tb.y && tb.y > 0.0 && tb.x < tmax) {
        tmin = max(tb.x,tmin);
        tmax = min(tb.y,tmax);

        float t = tmin;
        for (int i = 0; i < 80 && t < tmax; i++) {
            vec2 h = map( ro+rd*t, cuttingPlane );
            if (abs(h.x) < (0.0001 * t)) { 
                res = vec2(t,h.y); 
                break;
            }
            t += h.x;
        }
    }
    
    return res;
}

// Function 2841
vec3 planeRay(vec3 p,vec3 o,vec3 d){d=normalize(d);
 const float aco3=acos(-1.)/3.;vec3 n=vec3(0,-1,0);
 float i=apos(  n              ,1.,o,d),//northern   
 j=apos(-vec3(r(n.xy, aco3),n.z),1.,o,d),//southeast
 k=apos(-vec3(r(n.xy,-aco3),n.z),1.,o,d);//southwest
 return o+d*min(min(i,j),k);
}

// Function 2842
vec3 computeNormalAt(vec3 pos)
{
    vec3 v = vec3(
    	implicitFunc(pos - vec3(DerivStep, 0., 0.)),
    	implicitFunc(pos - vec3(0., DerivStep, 0.)),
    	implicitFunc(pos - vec3(0., 0., DerivStep))
    );
    vec3 v2 = vec3(
    	implicitFunc(pos + vec3(DerivStep, 0., 0.)),
    	implicitFunc(pos + vec3(0., DerivStep, 0.)),
    	implicitFunc(pos + vec3(0., 0., DerivStep))
    );
    return normalize(v - v2);
}

// Function 2843
float IntersectRayWithPlane(vec3 ro, vec3 rd, vec3 planePoint, vec3 planeNorm) {
 	float denom = dot(planeNorm, rd);
    if (denom > 1e-6) { 
        vec3 p0l0 = planePoint - ro; 
        float t = dot(p0l0, planeNorm) / denom; 
        return t; // distance from ro to plane
    }
    
    return -1.;
}

// Function 2844
vec3 rayCast(vec3 rayDir, vec3 cameraOrigin)
{
    const int ITER = 100;
    float iterations = float(ITER);
	vec3 p = cameraOrigin;
    vec3 density = vec3(0.0);
    for(int i = 0; i < 70; i++)
	{
        p.x += sin(p.z*sinusSpaceDistortion.y)*sinusSpaceDistortion.x;
        p.y += sin(p.z*sinusSpaceDistortion.y + sinusSpaceDistortion.z)*sinusSpaceDistortion.x;
        p.xy *= rot(p.z*twist);
        float ifloat = float(i);
		float f = ifloat / iterations;
        vec3 c = mix(color1, color2, smoothstep(colorsPlacement.x, colorsPlacement.y, f));
        float clouds1 = noise(p + vec3(0.0,0.0,iTime*moveSpeed));
		float clouds2 = pow(clouds1, densityPow);
        float dfade = smoothstep(1.0, 0.0, length(p.xy*(fade+sin(iTime)*fadeVariation)));
		density += clouds1*clouds1*c*densityMultiplier2 + clouds2*dfade*densityMultiplier1*c;
		p = cameraOrigin + rayDir * f * viewDistance;
	}
    return density/iterations;
}

// Function 2845
float rayleigh_phase_func(float mu)
{
	return
	        3. * (1. + mu*mu)
	/ //------------------------
	           (16. * PI);
}

// Function 2846
vec2 fastCastRay( in vec3 ro, in vec3 rd, in float maxd )
{
	float precis = 0.001;
    float h=precis*2.0;
    float t = 0.0;
    float m = -1.0;
    for( int i=0; i<60; i++ )
    {
		if( abs(h)<precis || t>maxd ) break;  {
			t += h;
			vec2 res = fastMap( ro+rd*t );
			h = res.x;
			m = res.y;
		}
    }

    if( t>maxd ) m=-1.0;
    return vec2( t, m );
}

// Function 2847
bool RaySphereIntersection(Ray r, Sphere s, out HitInfo hitInfo)
{
	vec3 k = r.pos - s.pos;
    float b = dot(k, r.dir);
	float c = dot(k, k) - s.radius * s.radius;
	float d = b * b - c;
	 
	if(d < 0.0)
	{
		return false;
	}
		
	float sqrtfd = sqrt(d);

	float t1 = -b + sqrtfd;
	float t2 = -b - sqrtfd;

	float minT = min(t1,t2);
	float maxT = max(t1,t2);

	float t = (minT >= 0.0) ? minT : maxT;

	hitInfo.t = t;
	hitInfo.pos = PointFromRay(r, t);
	hitInfo.normal = (c < 0.0 ? -1.0 : 1.0) * normalize(hitInfo.pos - s.pos);
	hitInfo.mat = s.mat;
	
	return (t > 0.0);
}

// Function 2848
vec3 gradientNormalFast(vec3 p, float map_p) {
    return normalize(vec3(
        map_p - map(p - vec3(GRADIENT_DELTA, 0, 0)),
        map_p - map(p - vec3(0, GRADIENT_DELTA, 0)),
        map_p - map(p - vec3(0, 0, GRADIENT_DELTA))));
}

// Function 2849
vec4 raymarchTerrain( in vec3 ro, in vec3 rd )
{
	float maxd = 20.0;
    float precis = 0.0001;
	float h = 1.0;
	float t = 0.1;
	
	vec4 res = vec4(0.0);
	for( int i=0; i<200; i++ )
	{
		if( abs(h)<precis||t>maxd ) break;

		res = mapTerrain( ro+rd*t );
		h = res.w*0.08;
		t += h;
	}
	if( t>maxd ) t=-1.0;
	return vec4(res.xyz,t);
}

// Function 2850
vec3 normalEstimation(vec3 pos){
  vec3 xDir = vec3(MinDist, 0, 0);
  vec3 yDir = vec3(0, MinDist, 0);
  vec3 zDir = vec3(0, 0, MinDist);
  return normalize(vec3(distanceEstimation(pos + xDir),
	  					distanceEstimation(pos + yDir),
  						distanceEstimation(pos + zDir))
				 - vec3(distanceEstimation(pos)));
}

// Function 2851
vec3 normal(vec3 p)
{
    vec2 e = vec2(1,-1)*.01;
    
    return normalize(dist(p-e.yxx)*e.yxx+dist(p-e.xyx)*e.xyx+
    dist(p-e.xxy)*e.xxy+dist(p-e.y)*e.y);
}

// Function 2852
vec3 normal(vec3 pos) {
	vec3 e = vec3(0.0,0.01,0.0);
	
	return normalize(vec3(
			de(pos+e.yxx)-de(pos-e.yxx),
			de(pos+e.xyx)-de(pos-e.xyx),
			de(pos+e.xxy)-de(pos-e.xxy)
			)
		);	
}

// Function 2853
vec4 RayDir(vec2 pixPos,
            vec2 viewSizes,
            inout uint randVal,
            int frameCtr)
{
    viewSizes *= float(MAX_SPP_PER_AXIS);
    pixPos *= float(MAX_SPP_PER_AXIS);
    vec2 sampleXY = vec2(frameCtr % MAX_SPP_PER_AXIS,
                   		 frameCtr / MAX_SPP_PER_AXIS); // Offset the current ray within the sampling grid
    sampleXY += AAJitter(randVal); // Jitter the given offset
    pixPos += sampleXY; // Apply offset to the scaled pixel position
    vec3 dir = vec3(pixPos - (viewSizes / 2.0),
                	viewSizes.y / tan(1.62 / 2.0)); // Generate ray direction
    return vec4(normalize(dir), // Normalize
                BlackmanHarris(sampleXY)); // Generate filter value
}

// Function 2854
d2 fRay(c2 p){p.x.a=mix(0.,p.x.a,step(p.x.a,0.));
 d2 q=sd(p.x,p.y,p.z);return su(q,1.);}

// Function 2855
vec2 castRay( vec3 ro, vec3 rd)
{
	// variables used to control the marching process
    const int maxMarchCount = 300;
    float maxRayDistance = 20.0;
    float minPrecisionCheck = 0.001;
    
    float t = 0.0; // travelled distance by ray
    float id = -1.0; // object ID, default of -1 means background
    
    for(int i = 0; i < maxMarchCount; i++)
    {
        // get closest object to current ray position
        vec2 res = map(ro + rd*t);
        
        // stop itterating/marching once either we've past max ray length 
        // or
        // once we're close enough to an object (defined by the precision check variable)
       	if(t > maxRayDistance || res.x < minPrecisionCheck)
           break;
        
        // move ray forward by distance to closet object, see
        // http://http.developer.nvidia.com/GPUGems2/elementLinks/08_displacement_05.jpg
        t += res.x; 
        id = res.y;
    }
    
    // if ray goes beyond max distance, force ID back to background one
    if(t > maxRayDistance)
        id = -1.0;
    
    return vec2(t, id);
}

// Function 2856
vec3 eye_ray(vec3 eye, vec3 look_at, vec3 eye_up, float fov, vec2 fragCoord){
	// Do as a matrix?
	vec3 forward = normalize(look_at - eye);
	vec3 right = cross(forward, normalize(eye_up));
	vec3 up = cross(right, forward);
	
	vec2 clip = clip_coord(fragCoord);
	return normalize(forward + (clip.x*fov)*right + clip.y*up);
}

// Function 2857
float ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {
		float dist = map( origin + dir * depth );
		if ( dist < stop_threshold ) {
			return depth;
		}
		depth += dist * 0.3;
		if ( depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 2858
vec3 GetCameraRayDir(const in vec2 mUV, const in vec3 camPosition, const in vec3 camTarget)
{
	vec3 forwardVector = normalize(camTarget - camPosition);
	vec3 rightVector = normalize(cross(vec3(0.0, 1.0, 0.0), forwardVector));
	vec3 upVector = normalize(cross(forwardVector, rightVector));	
    
	vec3 camDirection = normalize(mUV.x * rightVector * FOV
                                  + mUV.y * upVector * FOV
                                  + forwardVector);

    
	sunPos = vec2(dot(sunDirection, rightVector), 
                  dot(sunDirection, upVector));
    
    #ifndef DEBUG_NO_RAIN
    	//Raining
    	#ifndef DEBUG_NO_WATERDROPLET
			float t = floor(mUV.x * MAX_DROPLET_NMBR);
            float r = Hash1D(t);
    
            //used for radius of droplet, smaller float == bigger drop
            float fRadiusSeed = fract(r * 40.0);
            float radius = fRadiusSeed * fRadiusSeed * 0.02 + 0.001;
    
            float fYpos = r * r - clamp(mod(iTime * radius * 2.0, 10.2) - 0.2, 0.0, 1.0);
            radius *= rainingValue;
            vec2 vPos = vec2((t + 0.5) * (1.0 / MAX_DROPLET_NMBR), fYpos * 3.0 - 1.0);
            vec2 vDelta = mUV - vPos;

            const float fInvMaxRadius = 1.0 / (0.02 + 0.001);
            vDelta.x /= (vDelta.y * fInvMaxRadius) * -0.15 + 1.85; // big droplets tear shaped

            vec2 vDeltaNorm = normalize(vDelta);
            float l = length(vDelta);
            if(l < radius)
            {		
                l = l / radius;

                float lz = sqrt(abs(1.0 - l * l));
                vec3 vNormal = l * vDeltaNorm.x * rightVector 
                               + l* vDeltaNorm.y * upVector 
                               - lz * forwardVector;
                vNormal = normalize(vNormal);
                camDirection = refract(camDirection, vNormal, 0.7);
            }
        #endif
    #endif
	return camDirection;
}

// Function 2859
vec3 getNormal(vec3 point, vec3 sphere, float s){
    float epsilon = 0.00004; // How far in the plane to grab height from to recalc normals
    // Convert the point into model coordinates.
    vec3 p = point - sphere;
    // Standard mapping of a point on a sphere to a UV
    float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / s / .5 
        	+ iTime * .1;
    float v = (.5 - asin(p.y) / 3.14159) / s / .5;
    
    // Get the height af (u,v), (u, v + epsilon), and (u + epsilon, v)
    // So that we can construct two vectors to cross product
    float d1 = texture( iChannel0,
                           vec2(u,v)).r;
    float d2 = texture( iChannel0,
                           vec2(u,v + epsilon)).r;
    float d3 = texture( iChannel0,
                           vec2(u + epsilon,v)).r;
    
    // Construct points we can generate the normal from.
    vec3 p1 = vec3(u, v, d1 * 0.1);
    vec3 p2 = vec3(u, v + epsilon, d2 * 0.1);
    vec3 p3 = vec3(u + epsilon, v, d3 * 0.1);
    
    // The normal for a un-displaced sphere
    vec3 sphereNorm = p;
    // A vector between a standard "up" vector and the normal for the displacement map
    vec3 planeNorm = vec3(0., 0., 1.) - normalize(cross((p3-p1), (p2 - p1)));
    
    return normalize(planeNorm + sphereNorm); // Return a corrected normal
}

// Function 2860
Ray genRay( in vec2 pixel, in float Xi1, in float Xi2 )
{
    Ray ray;
    
#ifdef OCULUS_VERSION
    vec2 displaySize = vec2( iResolution.x*0.5, iResolution.y );
    vec2 uv;
    
    if( pixel.x < displaySize.x ) {
    	ray.origin = camera.pos - camera.rotate[0]*0.2;
        uv = pixel/displaySize;
    } else {
        ray.origin = camera.pos + camera.rotate[0]*0.2;
        uv = vec2(pixel.x-displaySize.x,pixel.y)/displaySize;
    }
    
    uv = (uv*2.0 - 1.0)*vec2(displaySize.x/displaySize.y,1.);
    
    float fov = camera.fovV;
    float angle = fov/4.0;
    float a = sin(angle);
    
    uv *= a;
    
    if( length(uv) > 1.0 ) {
        Ray ray;
        ray.origin = vec3( 0.0, 0.0, 0.0 );
        ray.dir = vec3( 0.0, 0.0, 0.0 );
        return ray;
    }
    
    vec3 cameraDirInv = vec3( 0.0, 0.0, 1.0 );
    vec3 normal;
    normal.x = -uv.x;
    normal.y = -uv.y;
    normal.z = sqrt( 1.0 - (uv.x*uv.x + uv.y*uv.y) );
    
	ray.dir = camera.rotate*reflect( cameraDirInv, normal );

	return ray; 
#else
	vec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);
	vec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;
    
    if( camera.lensSize > EPSILON ) {
        vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );
        vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;
        vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];
        vec3 newBack = normalize(newPos - focusPoint);
        vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );
        vec3 newUp = cross( newBack, newRight );
        mat3 newRotate;
        newRotate[0] = newRight;
        newRotate[1] = newUp;
        newRotate[2] = newBack;


        ray.origin = newPos;
        ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    } else {
        ray.origin = camera.pos;
        ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));
    }

	return ray;
#endif
}

// Function 2861
vec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)
{
	vec3 localRay = normalize(rayDir);
	float sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);
	//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);
	sunIntensity = 0.2 / sunIntensity;
	sunIntensity = min(sunIntensity, 40000.0);
	return environmentSphereColor + sunCol * sunIntensity;
}

// Function 2862
float RAYMARCH_isosurface( vec3 o, vec3 d, float isoSurfaceValue)
{
    //Learned from Inigo Quilez DF ray marching :
    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
    //Original articles (interesting read) :
    //Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1989)
    //http://mathinfo.univ-reims.fr/IMG/pdf/hart94sphere.pdf
    //John C. Hart Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces (1994)
    //http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3825 p. 5.75-5.85
    
    const float tolerance = 0.0001;
    float t = 0.0;
    float dist = MAX_DIST;
    #if OVERSTEP_COMPENSATION
    for( int i=0; i<30; i++ )
    {
        dist = DF_composition( o+d*t ).d;
        dist -= isoSurfaceValue;
        
        if( abs(dist)<tolerance*100.0 ) break;
        t += dist;
    }
    
    t -= Z_REPEAT_DIST/2.0;
    
    for( int i=0; i<30; i++ )
    {
        dist = DF_composition( o+d*t ).d;
        dist -= isoSurfaceValue;
        
        if( abs(dist)<tolerance ) break;
        
        t += min(dist,Z_REPEAT_DIST/5.0);
    }
    #else
    for( int i=0; i<70; i++ )
    {
        dist = DF_composition( o+d*t ).d;
        dist -= isoSurfaceValue;
        
        if( abs(dist)<tolerance ) break;
        t += dist;
    }
    #endif
    
    return t;
}

// Function 2863
bool raySphere(vec3 o, vec3 d, vec3 c, float r, inout float t1, inout float t2){
    o -= c, d -= c;
    float C = dot(o,o)-r*r;
    float B = 2.*dot(o,d);
    float A = dot(d,d);
    float D2 = B*B - 4.*A*C;
    if(D2<0.) return false;
    float D = sqrt(D2);
    t1 = (-B - D)/(2.*A);
    t2 = (-B + D)/(2.*A);
    return true;
}

// Function 2864
vec4 raycast(vec3 rayOrigin, vec3 rayDirection) {
    vec4 hitResult = vec4(0.0, 0.0, 0.0, 0.0);
    int stepCount = 256;
    float maximumDistance = 20.0;
    float t = 0.0;
    for (int i = 0; i < stepCount; i++) {
        if (t > maximumDistance) {
            break;
        }
        vec3 currentPosition = rayOrigin + rayDirection * t;
        vec4 result = sdf(currentPosition);
        if (result.x < 0.001) {
            hitResult = vec4(t, result.y, 0.0, 0.0);
            break;
        }
        t += result.x;
    }
    return hitResult;
}

// Function 2865
vec3 calcNormal( in vec3 pos )
{    
  return normalize( vec3(MapPlane(pos+eps.xyy) - MapPlane(pos-eps.xyy), 0.5*2.0*eps.x, MapPlane(pos+eps.yyx) - MapPlane(pos-eps.yyx) ) );
}

// Function 2866
vec3 sampleReflectedEnvironment(in vec3 Wi, in float r, in float f0)
{
#if (USE_IBL)    
    float r2 = r * r;
    float samples = 0.0;
    vec3 u = perpendicularVector(Wi);
	vec3 v = cross(u, Wi);
    vec3 result = vec3(0.0);
    vec3 Wo = Wi;
    for (int i = 0; i < MAX_CUBEMAP_SAMPLES; ++i)
    {
        Wo = randomDirection(Wi, u, v, r2, Wo + result);
        vec3 H = normalize(Wi + Wo);
        float weight = microfacetWeight(r2, f0, dot(H, Wi), 1.0, dot(Wo, Wi));
        result += weight * texture(iChannel0, Wo).xyz;
        samples += weight;
	}    
    return result / samples;
	// */
#else
    return vec3(0.0);
#endif
}

// Function 2867
float pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}

// Function 2868
Ray createRay(vec3 origin, vec3 direction)
{
	Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

// Function 2869
float rayIntScalar(
    vec2 o1, vec2 d1,
    vec2 o2, vec2 d2
) {
    vec2 v = (o2 - o1);
    
    return abs(cross2(v, d2)) / abs(cross2(d1, d2));
}

// Function 2870
Ray makeRay(vec2 uv, in Camera camera){
#ifdef CIRCULAR_DITHER
    float radius = sqrt(0.5f * dither_amount * rand1());
    float angle = TWO_PI * rand1();
    vec2 dither = radius * vec2(cos(angle), sin(angle))/iResolution.xy;
#else
    vec2 dither = dither_amount * (0.5 - rand2())/iResolution.xy;
#endif

    vec3 direction = camera.front - 
        camera.right * (0.5 - uv.x + dither.x) * camera.plane.x - 
        camera.down * (0.5 - uv.y + dither.y) * camera.plane.y;
    
    return Ray(camera.position, normalize(direction));
}

// Function 2871
vec3 surfaceNormal(vec3 pos) {
 	vec3 delta = vec3(0.01, 0.0, 0.0);
    vec3 normal;
    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);
    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);
    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);
    return normalize(normal);
}

// Function 2872
vec3 calc_normal(in vec3 pos, in float dist)
{
	int tmp;

	float dfdx = calc_dist(pos + vec3(GRAD_DELTA, 0.0, 0.0), tmp) - dist;
	float dfdy = calc_dist(pos + vec3(0.0, GRAD_DELTA, 0.0), tmp) - dist;
	float dfdz = calc_dist(pos + vec3(0.0, 0.0, GRAD_DELTA), tmp) - dist;

	return normalize(vec3(dfdx, dfdy, dfdz));
}

// Function 2873
float scene_raycast_terrain( Ray ray, float wlevel,
                             inout float t0, inout vec3 r, int mode )
{
	bool submerged = length( ray.o ) - g_data.radius < wlevel;
    float t = 0., h = 0., alt = 0.;
    float lasth = 0., lastt = 0., lasta = 0.;
    vec4 tsmpl = vec4(0);
    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );
    float C0 = length( ray.o ) - g_data.radius;
    float C1 = dot( ray.o, ray.d ) / length( ray.o );
    float C2 = ( lensq( ray.o ) * lensq( ray.d ) - square( dot( ray.o, ray.d ) ) ) / ( length( ray.o ) * lensq( ray.o ) );
    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; ++i )
    {
        r = ray.o + t * ray.d;
        tsmpl = ts_sample( g_ts, iChannel1, r );
        lasta = alt;
        alt =
#if WITH_TRN_HIGHP_RAYCAST
            t < t_switch ? C0 + t * C1 + t * t * C2 :
#endif
        	length(r) - g_data.radius;
        lasth = h;
        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );
        if( h < 0. )
        {
            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );
        	r = ray.o + t * ray.d;
    		return t;
        }
        else
        if( submerged && alt >= wlevel )
        {
            if( t0 > 0. )
                break;
            t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );
			r = ray.o + t * ray.d;
            vec3 Z = normalize( r );
            vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );
            if( mode == 1 )
            {
	            r = normalize( simple_refract( ray.d, N ) );
            	break;
        	}
            ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );
            ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );
           	ray.o = r;
            t0 = t;
            t = 0.;
		#if WITH_TRN_HIGHP_RAYCAST
    		C0 = length( ray.o ) - g_data.radius;
    		C1 = dot( ray.o, ray.d ) / length( ray.o );
    		C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
		#endif
            alt = wlevel;
            h = wlevel - ts_sample( g_ts, iChannel1, r ).w;
        }
        lastt = t;
        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );
        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) )
        	break;
    }
    return SCN_ZFAR;
}

// Function 2874
vec4 castRay(vec3 eye, vec3 ray) {
    vec2 block = floor(eye.xy);
    vec3 ri = 1.0 / ray;
    vec3 rs = sign(ray);
    vec3 side = 0.5 + 0.5 * rs;
    vec2 ris = ri.xy * rs.xy;
    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;
    
    float beacon = 0.0;
    
    for (int i = 0; i < 200; ++i) {
        vec2 lo0 = vec2(block + 0.01);
        vec2 loX = vec2(0.1, 0.1);
        vec2 hi0 = vec2(block + 0.69);
        vec2 hiX = vec2(0.4, 0.4);
        float height = (0.5 + hash1(block)) * (2.0 + 4.0 * pow(noise1(0.1 * block), 2.5));
        
        float dist = 500.0;
        float face = 0.0;
        for (int j = 0; j < 3; ++j) {
            float top = height * (1.0 - 0.1 * float(j));
            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), 0.0);
            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);

            vec3 wall = mix(hi, lo, side);
            vec3 t = (wall - eye) * ri;

            vec3 dim = step(t.zxy, t) * step(t.yzx, t);            
            float maxT = dot(dim, t);
            float maxFace = 1.0 - dim.z;
            
            vec3 p = eye + maxT * ray;
            dim += step(lo, p) * step(p, hi);
            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {
                dist = maxT;
                face = maxFace;
            }
        }
        
        float prob = beaconProb * pow(height, 3.0);
        vec2 h = hash2(block);
        if (h.x < prob) {
            vec3 center = vec3(block + 0.5, height + 0.2);
            float t = dot(center - eye, ray);
            if (t < dist) {
                vec3 p = eye + t * ray;
               // float fog = (exp(-p.z / fogDistance) - exp(-eye.z / fogDistance)) / ray.z;
               // fog = exp(fogDensity * fog);

                t = distance(center, p);
                //fog *= smoothstep(1.0, 0.5, cos(tau * (beaconFreq * iTime + h.y)));
                //beacon += fog * pow(clamp(1.0 - 2.0 * t, 0.0, 1.0), 4.0);
            }
        }
        
        if (dist < 400.0) {
            return vec4(dist, beacon, face, 1.0);
        }

        float t = eye.z * ri.z;
        vec3 p = eye - t * ray;
        vec2 g = p.xy - block;
        if (g.x > 0.0 && g.x < 1.0 && g.y > 0.0 && g.y < 1.0) {
            return vec4(-t, beacon, 0.0, 1.0);
        }
        
        vec2 dim = step(dis.xy, dis.yx); 
        dis += dim * ris;
        block += dim * rs.xy;
    }
    
    if (ray.z < 0.0) {
        return vec4(-eye.z * ri.z, beacon, 0.0, 1.0);
    }

    return vec4(0.0, beacon, 0.0, 0.0);
}

// Function 2875
float ray_march(vec3 ro, vec3 rd) {
  float t = 0.0;
  for(int i = 0; i < 128; i++) {
    vec3 p = (ro + (t * rd));
    float d = map(p);
    if(d <= 0.0001) {
      return t;
    }
    t = (t + d);
    if(t > 10.0) {
      return -1.0;
    }
  }
  return -1.0;
}

// Function 2876
vec3 normal(in vec3 p) {
    vec3 eps = vec3(EPSILON, 0.0, 0.0);
    return normalize(vec3(
        	map(p + eps.xyy) - map(p - eps.xyy),
        	map(p + eps.yxy) - map(p - eps.yxy),
        	map(p + eps.yyx) - map(p - eps.yyx)
        ));
}

// Function 2877
vec3 normal(vec3 p)
{
	float c = scene(p).d;
	vec2 h = vec2(0.01, 0.0);
	return normalize(vec3(scene(p + h.xyy).d - c, 
						  scene(p + h.yxy).d - c, 
		                  scene(p + h.yyx).d - c));
}

// Function 2878
vec3 calcNormal( vec3 pos )
{
#if 0
    // original code
    const float eps = 0.0002;
    uint kk, kk2;
    vec3 nor = vec3(
      map( pos.x+eps, pos.y, pos.z, kk, kk2 ) - map( pos.x-eps, pos.y, pos.z, kk, kk2 ),
      map( pos.x, pos.y+eps, pos.z, kk, kk2 ) - map( pos.x, pos.y-eps, pos.z, kk, kk2 ),
      map( pos.x, pos.y, pos.z+eps, kk, kk2 ) - map( pos.x, pos.y, pos.z-eps, kk, kk2 ));
    return normalize(nor);
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        uint kk, kk2;
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0002*e, kk, kk2);
        if( n.x+n.y+n.z>100.0 ) break;
    }
    return normalize(n);
#endif    
}

// Function 2879
vec3 Normal( in vec3 pos )
{
	vec2 eps = vec2( 0.01, 0.0);
	vec3 nor = vec3(
	    MapToScene(pos+eps.xyy) - MapToScene(pos-eps.xyy),
	    MapToScene(pos+eps.yxy) - MapToScene(pos-eps.yxy),
	    MapToScene(pos+eps.yyx) - MapToScene(pos-eps.yyx) );
	return normalize(nor);
}

// Function 2880
vec3 getNormal(vec3 pos, float derivDist) {
	vec3 surfaceNormal;
	surfaceNormal.x = distanceField(vec3(pos.x + derivDist, pos.y, pos.z)) 
					- distanceField(vec3(pos.x - derivDist, pos.y, pos.z));
	surfaceNormal.y = distanceField(vec3(pos.x, pos.y + derivDist, pos.z)) 
					- distanceField(vec3(pos.x, pos.y - derivDist, pos.z));
	surfaceNormal.z = distanceField(vec3(pos.x, pos.y, pos.z + derivDist)) 
					- distanceField(vec3(pos.x, pos.y, pos.z - derivDist));
	return normalize(0.5 * surfaceNormal / derivDist);
}

// Function 2881
float TransObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 100; j ++) {
    d = TransObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.01 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2882
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
   
#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
	    float precis = 0.0005*t;
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 2883
float RaySphere(vec3 P, vec3 V, vec3 A, float r)
{
	return Q(dot(V,V),2.0*(dot(P,V)-(dot(A,V))),dot(A,A)+dot(P,P)-r*r-(2.0*(dot(A,P))));
}

// Function 2884
float getInvNormalizedBAP(BreakdownAnimationPhase bas, float id){
	if(id == bas.id)
        return 1.-bas.phase;
    else
        return step(bas.id, id);
}

// Function 2885
float castShadowRay(vec3 pos, vec3 dir, float time, float maxDist)
{
    float totalDist = 0.0;
    float distToSurface = distModel(pos + dir * 0.1, time);
    float maxShadow = 0.0;
    
    for(int i = 0; i < 50 ; ++i)
    {
        totalDist += distToSurface;
        vec3 currentPos = pos + dir * totalDist;
        distToSurface = distModel(currentPos, time);
        float shadowSmooth = mix(0.1, 0.7, smoothstep(0.1, 10.0, totalDist));
        float shadow = smoothstep(shadowSmooth, 0.0, distToSurface);
        shadow *= smoothstep(10.0, 8.0, totalDist);
        maxShadow = max(maxShadow, shadow);
        
        if(distToSurface < 0.00 || totalDist > maxDist)
        {
            return 1.0 - maxShadow;
        }
    }
    
    return  1.0 - maxShadow;
}

// Function 2886
vec3 raymarch_o354278(vec2 uv) {
    vec3 cam=vec3(1.250000000+sin(iTime*0.25)*0.5,1.400000000+cos(iTime*0.2)*0.5,1.500000000);
	vec3 lookat=vec3(0.000000000,0.000000000,0.000000000);
	vec3 ray=normalize(lookat-cam);
	vec3 cX=normalize(cross(vec3(0.0,-1.0,0.0),ray));
	vec3 cY=normalize(cross(cX,ray));
	vec3 rd = normalize(ray*1.000000000+cX*uv.x+cY*uv.y);
	vec3 ro = cam;
	
	float d=0.;
	vec3 p=vec3(0);
	vec2 dS=vec2(0);
	march_o354278(d,p,dS,ro,rd);
	
    vec3 color=vec3(0.0);
	vec3 objColor=(dS.y<0.5)?o354278_input_tex3d_a(p):o354278_input_tex3d_b(p);
	float fog=max(1.0-(d/50.0),0.0);
	vec3 light=normalize(vec3(0.950000000,1.200000000,0.400000000));
	if (d<50.0) {
	    vec3 n=normal_o354278(p);
		float l=clamp(dot(-light,-n),0.0,1.0);
		float r=clamp(dot(reflect(rd,-n),light),0.0,1.0);
		float cAO=calcAO_o354278(p,n);
		float shadow=calcSoftshadow_o354278(p,light,0.05,5.0);
		color=min(vec3(max(shadow,0.200000000)),max(l,0.200000000))*max(cAO,0.200000000)*objColor+pow(r,200.000000000)*0.850000000;
	} else {
	    color=o354278_p_SkyColor_gradient_fct(rd.y).xyz;
	}
    return color*(fog)+o354278_p_SkyColor_gradient_fct(rd.y).xyz*(1.0-fog);
}

// Function 2887
void camRay(vec2 uv, inout vec3 ray_o, inout vec3 ray_d)
{
    ray_o =
        cb(0) * vec3(0, 0, -22.5 + sin(TIME_S / 30.) * 12.) // Global z pan
      + cb(1) * vec3(
          vec2(-11., 4.) + vec2(2, 3) * mod(TIME_S, 100.) / 40.,
          -6.)                                             // Close outside dutch
      + cb(2) * vec3(-4.3, .4, -4.2 + SCENE_PROGRESS)      // Inside dutch
      + cb(3) * vec3(0, 0, -40. + TIME_S / 4.)             // Scene z pan
      + cb(12) * vec3(7.7 - SCENE_PROGRESS * 2., .75, -.7) // "Modified camera"
        ;

    uv -= .5;                                      // origin at center
    uv /= vec2(iResolution.y / iResolution.x, 1.); // fix aspect ratio
    ray_d = normalize(vec3(uv, .7));               // pull ray

    vec3 camRot =
        cb(2) * vec3(8. + SCENE_PROGRESS * 2., 1.7 + SCENE_PROGRESS, -4.)
        / 10.                          // Inside dutch
      + cb(12) * vec3(-1.2, -.52, .25) // "Modified camera"
        ;
    pR(ray_d.yz, camRot.y);
    pR(ray_d.xz, camRot.x);
    pR(ray_d.yx, camRot.z);
}

// Function 2888
float castRay2(vec3 ro,vec3 rd) 
{
    float precis = 3.;
    float h = 0.;
    float t = 2.;

    for(int i = 0; i < 90; i++) 
	{
		if(abs(h) > precis ) break;
		h = map(ro + rd * t);
		t-=h;
	}
	return t;
}

// Function 2889
vec3 calcNormal(vec3 pos)
{
    // Center sample
    float c = sdf(pos);
    vec2 eps_zero = vec2(0.001, 0.0);
    return normalize(vec3( sdf(pos + eps_zero.xyy), sdf(pos + eps_zero.yxy), sdf(pos + eps_zero.yyx) ) - c);
}

// Function 2890
vec3 findNormal(vec3 point) {
	vec3 normal;
	
	float ep = epsilon * .25;
	
	normal.x=distanceField(point+vec3(ep,0.0,0.0))-
			 distanceField(point-vec3(ep,0.0,0.0));
	normal.y=distanceField(point+vec3(0.0,ep,0.0))-
			 distanceField(point-vec3(0.0,ep,0.0));
	normal.z=distanceField(point+vec3(0.0,0.0,ep))-
			 distanceField(point-vec3(0.0,0.0,ep));
	
	return(normalize(normal));
}

// Function 2891
bool RaySphereIntersection(in vec3 ro, in vec3 rd, in vec3 c, in float r, out vec3 p0, out vec3 p1) {
    p0 = vec3(0.0);
    p1 = vec3(0.0);
    
   	vec3 oc = ro - c;
    float poc = dot(rd, oc);
    
    float sloc = dot(oc, oc);
    float test = poc*poc - sloc + r*r;
        
    if (test < 0.0) return false;
    
    float sqt = sqrt(test);
    float d0 = -poc - sqt;
    float d1 = -poc + sqt;
    
	p0 = ro + d0*rd;
    p1 = ro + d1*rd;
    return true;
}

// Function 2892
void getRays(inout Ray ray, out Ray r1, out Ray r2) {
     vec3 p = ray.cp.p;
    float cs = dot(ray.cp.normal, ray.rd);
    // simple approximation
    float fresnel = 1.0-abs(cs);
//	fresnel = mix(0.1, 1., 1.0-abs(cs));
    float r = ray.cp.mat - ID_FLOOR;
     vec3 normal = sign(cs)*ray.cp.normal;
    vec3 refr = refract(ray.rd, -normal, ray.eta);
    vec3 refl = reflect(ray.rd, ray.cp.normal);
    vec3 z = normal*DIST_EPSILON*2.;
    p += z;
    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);
    p -= 2.*z;
    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);
}

// Function 2893
vec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)
{
    vec3 camForward = normalize(camTarget - camPos);
    vec3 camRight = normalize(cross(vec3(0.,1.,0.), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));
    return normalize(uv.x * camRight + uv.y * camUp + camForward * 2.0);
}

// Function 2894
vec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {
	float t = startdist;

    // raymarch	
	vec4 sum = vec4( 0.0 );
	bool hit = false;
	vec3 col = bgc;
	
	for( int i=0; i<80; i++ ) {
		if( hit ) break;
		
		t += 8. + t/300.;
		vec3 pos = ro + t*rd;
		
		if( pos.y < terrainMap(pos) ) {
			hit = true;
		}		
	}
	if( hit ) {
		// binary search for hit		
		float dt = 4.+t/400.;
		t -= dt;
		
		vec3 pos = ro + t*rd;	
		t += (0.5 - step( pos.y , terrainMap(pos) )) * dt;		
		for( int j=0; j<2; j++ ) {
			pos = ro + t*rd;
			dt *= 0.5;
			t += (0.5 - step( pos.y , terrainMap(pos) )) * dt;
		}
		pos = ro + t*rd;
		
		vec3 dx = vec3( 100.*EPSILON, 0., 0. );
		vec3 dz = vec3( 0., 0., 100.*EPSILON );
		
		vec3 normal = vec3( 0., 0., 0. );
		normal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);
		normal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);
		normal.y = 1.;
		normal = normalize( normal );		

		col = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * 
				   vec3(1.,.9,0.6);
		
		float veg = 0.3*fbm(pos*0.2)+normal.y;
					
		if( veg > 0.75 ) {
			col = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;
		} else 
		if( veg > 0.66 ) {
			col = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;
		}
		col *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);
		
		vec3 brdf = col;
		
		float diff = clamp( dot( normal, -lig ), 0., 1.);
		
		col = brdf*diff*vec3(1.0,.6,0.1);
		col += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;
		col += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;
		
		dist = t;
		t -= pos.y*3.5;
		col = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );
		
	}
	return col;
}

// Function 2895
void RayStack_Reset()
{
    for ( int i=0; i<RAY_STACK_SIZE; i++)
    {
	    RayInfo_Clear( rayStack[i] );
    }
}

// Function 2896
vec4 length_normalize_r( vec3 x, vec3 r ) { vec3 s = x + r; float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec4( x, p ) * q; }

// Function 2897
vec4 ray(vec3 p, vec3 d)
{
    float k = min_distance;
    float nf = 1.0;
    vec4 c = vec4(0.0);
    float cr = 1.0;
    for (int j = 0; j < max_intersections; ++j)
    {
        for (int i = 0; i < maxsteps; ++i)
        {
            if (k > max_distance)
                return c + background(d) * cr;
            float ss = stepsize(p + d * k);
            if (f(p + d * (k + ss)) * nf < 0.0)
            {
                k += ss - min_stepsize * 0.5;
                k += f(p + d * k) / dot(d, fd(p + d * k));
                k += f(p + d * k) / dot(d, fd(p + d * k));
                p += d * k;
                
                vec3 n = -normalize(fd(p)) * nf;
                vec3 r = refract(d, n, nf > 0.0 ? 1.0 / N : N);

                if (nf < 0.0)
                {
                    float fa = k * 0.025;
                    c += vec4(0.5, 0.75, 1.0, 1.0) * fa * cr;
                    cr *= 1.0 - fa;
                }

                if (r == vec3(0.0))
                {
	                d = reflect(d, n);
                }
                else
                {
                    float f = nf > 0.0 ? 
                        fresnel(1.0, N, dot(-d, n)) : 
                    	fresnel(N, 1.0, dot(-d, n));
                    if (f > 0.5)
                    {
                        c += background(r) * (1.0 - f) * cr;
                        cr *= f;
                        d = reflect(d, n);
                    }
                    else
                    {                    
                        c += background(reflect(d, n)) * f * cr;
                        cr *= 1.0 - f;
                        d = r;
                        nf *= -1.0;
                    }
                }
                k = 0.0;
                break;
            }
            k += ss;
        }
    }
    return c + background(d) * cr;
}

// Function 2898
vec3 getNormal( in vec3 p ){

    vec2 e = vec2(0.5773,-0.5773)*0.001;
    return normalize( e.xyy*map(p+e.xyy ) + e.yyx*map(p+e.yyx ) + e.yxy*map(p+e.yxy ) + e.xxx*map(p+e.xxx ));
}

// Function 2899
vec3 HandleRay (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir, inout float hitTime)
{
    // calculate surface normal
    float tMin = RayIntersectAABoxMin(cellPos, rayPos, rayDir);
    float tMax = RayIntersectAABoxMax(cellPos, rayPos, rayDir);
    
    if( tMin>tMax && tMin > 0.0 )
    {
        hitTime = FLT_MAX;
        return vec3(1.0);
    }
   	if( tMin > hitTime )
    {
        hitTime = FLT_MAX;
        return vec3(0.0);        
    }
    
    vec3 frontCollisionPos = rayPos + rayDir*tMin;
    vec3 backCollisionPos = rayPos + rayDir*tMax;
    
    float tt = DoRootFinding(frontCollisionPos, backCollisionPos - frontCollisionPos);
    if( tt < 1.0 )
    {
        if( tt < 0.0 )
        {
            hitTime = tMin;
        	return vec3(1.0,0.0,0.0);
        }
        
        hitTime = mix(tMin,tMax, tt);
        return vec3(0.0,1.0,0.0);
    }
    hitTime = FLT_MAX;
    return vec3(1.0);
}

// Function 2900
vec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )
{
	Intersection intersection;
    return GetRayColour( vRayOrigin, vRayDir, intersection );
}

// Function 2901
void ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)
{
	if(t == tRoom.y)
	{            
		mref = vec2(0.0,0.0);
        normal =-normalForCube(hit, box0);   
        if(abs(normal.x)>0.0)
        { 
            mcol.xyz = vec3(0.95,0.95,0.95);
            mref = vec2(0.0,1.0);
        } 
         else if(normal.y>0.0)
        {
            vec3 tcol = texture(iChannel1,1.0-(hit.xz-vec2(1.5,1.5))/3.5).xyz;
            float s = tcol.y+0.1;//-d
            s = pow(s,3.0)*0.75+0.01;
            mref = vec2((s*0.5+0.1),pow(1.0-s,2.0));
            mcol.xyz = vec3(0.9);//tcol+0.4;
        } 
        else if(abs(normal.z)>0.0)
        {
            mcol.xyz = vec3(0.95,0.15,0.19);
            mref = vec2(0.0,1.0);
            
            if(normal.z<0.0)
			{
            	//cw = vec2(-0.4,0.1);
            	if(	all(lessThanEqual(hit.xy,vec2(-0.05,0.6)+cw)) &&
               		all(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+cw)) ||
               		all(lessThanEqual(hit.xy,vec2(0.7,0.6)+cw)) &&
               		all(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+cw)))
               		mcol = vec4(vec3(1.1),2.0);
			}
        }
	}     
	else   
	{
        	 if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
    	else if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}
        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}
        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}
        else if(id==13) {normal = normalforCylinder(hit, cylinder[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}
        else if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==22) {normal = normalForCube(hit, boxe[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}
        else if(id==23) {normal = normalForCube(hit, boxe[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}
        else if(id==24) {normal = normalForCube(hit, boxe[4]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}
        else if(id==25) {normal = normalForCube(hit, boxe[5]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}
        else if(id==26) {normal = normalForCube(hit, boxe[6]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}
        else if(id==27) {normal = normalForCube(hit, boxe[7]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.8,0.8);}
        else if(id==28) {normal = normalForCube(hit, boxe[8]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==29) {normal = normalForCube(hit, boxe[9]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==30) {normal = normalForCube(hit, boxe[10]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==31) {normal = normalForCube(hit, boxe[11]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==32) {normal = normalForCube(hit, boxe[12]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==33) {normal = normalForCube(hit, boxe[13]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}
        else if(id==34) {normal = normalForCube(hit, boxe[14]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.05,3.8);}
        
        if(id>19 && id<23)//material for dulap
        {
            vec2 uv = hit.yz;
            uv = abs(normal.y) > 0.0 ? hit.zx : uv;
            uv = abs(normal.z) > 0.0 ? hit.yx : uv; 
            mcol.xyz = texture(iChannel1,1.0-(uv - vec2(1.5,-1.0))/vec2(5.5,0.5)).xyz - vec3(0.35,0.2,0.2);
            mref = vec2(0.0,0.2);// transparent, glossines
            mcol.xyz = vec3(0.1,0.99,0.1);// color
            
            if(id==21)	normal = -normal;
        }
        
        if(id>26 && id<34)//masa scaun
        {
            mcol.xyz = vec3(0.9);
            mref = vec2(0.0,0.7);// transparent, glossines
            //if(id==27) mcol.xyz = vec3(0.9,0.9,0.9);// color
            
            if(id==21)	normal = -normal;
        }
        
        if(id==34)//calorifer
        {
            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);
            mref = vec2(0.0,0.0);
        }
    }  
}

// Function 2902
Ray sfCreateCameraRay(vec2 uv) {
    vec3 eye = vec3(0.0, 0.0, 5.0);
    vec3 center = vec3(0.0, 0.0, 0.0);
    vec3 up = vec3(0.0, 1.0, 0.0);
    float aspectRatio = iResolution.x / iResolution.y;
    float fovy = 45.0;
    
    float theta = fovy * FX_DEGREES_TO_RADIANS;
    float halfHeight = tan(theta / 2.0);
    float halfWidth = aspectRatio * halfHeight;
    float distanceToFocus = length(eye - center);
    vec3 w = normalize(eye - center);
    vec3 u = cross(up, w);
    vec3 v = cross(w, u);
    vec3 horizontal = 2.0 * distanceToFocus * halfWidth * u;
    vec3 vertical = 2.0 * distanceToFocus * halfHeight * v;
    vec3 lowerLeftCorner = eye
        - (distanceToFocus*halfWidth) * u
        - (distanceToFocus*halfHeight) * v
        - distanceToFocus * w;
    vec3 window = uv.s * horizontal + uv.t * vertical;
    return sfCreateRay(eye, lowerLeftCorner + window - eye);
}

// Function 2903
raymarchResult raymarch(vec3 direction, vec3 camera, float maxD, float outline){ //ray from camera to direction (extended into infinity)
    direction = normalize(direction);
    
    raymarchResult res;
    res.type = 0.;
    res.position = vec3(0.);
    
    float minH = 999.;
    float setI = (outline == 2. ? outlineSize + 1. : 0.3);
    
    for(float i = setI; i < maxD;){ //i = length of ray
        vec3 p = camera + i * direction;
    	mapResult hMap = map(p); //smallest distance from all objects to point
        float h = hMap.Md;
        if(h > minH && minH > MinDist && minH < MinDist + outlineSize && outline != 0.){ //if distance increases from smallest distance
            res.position = p;
            res.type = 2.;
            return(res);
        }
        minH = h;
        
        
    	if(h < MinDist){
            res.position = p;
            res.type = 1.;
			return(res); //successfully hit something at point "point"
        }
        i += h;
    }

    return(res);
}

// Function 2904
sRay setCameraRay( vec3 hp, vec3 i , vec2 fragCoord) {
    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio

    vec3 f   = normalize(i - hp);
    vec3 vUp = vec3(0.0, 1.0, 0.0);
    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;
    vvc.y /= fRatio;

    sRay ray;
    ray.ro = hp;
    vec3 r = normalize(cross(f, vUp));
    vUp    = cross(r, f);
    ray.rd = normalize( r * vvc.x + vUp * vvc.y + f);
    ray.sd = 0.0;
    ray.rl = MAX_DIST;
    return ray;
}

// Function 2905
vec3 GetBackgroundColorForRayGivenLightingData( vec3 seed, vec3 start, vec3 dir, vec3 shadowData CACHEARG )
{
    if ( dir.y >= 0.0 )
        return GetBackgroundColorForSky( start, dir );

    // intersect with ground plane
    float t = (GROUND_PLANE_HEIGHT - start.y) / dir.y;
    vec3 bgPos = start + dir * t;
    
    vec3 bgColor;
    float spotlightBrightness = GetFloorSpotlightBrightness( bgPos );
    if ( spotlightBrightness == 0.0 )
    {
        bgColor = vec3( 0.0 );
    }
    else
    {
        bgColor = GetFloorColor( bgPos.xz );
        bgColor *= spotlightBrightness;

        bgColor *= LIGHT_COLOR * shadowData.x + AMBIENT_LIGHT_FROM_ABOVE * shadowData.y + BLOB_EMISSION_LIGHT * shadowData.z;
    }
    
    bgColor = AddBackgroundFog( bgColor, start, dir, t, GetBrightnessForTime( blobTime ) );
    
    return bgColor;
}

// Function 2906
vec3 normal( vec3 p, const float eps ) {
    float d = world(p);
    vec2 e = vec2(eps, 0.);
    
    vec3 n;
    
    n.x = d - world(p-e.xyy);
    n.y = d - world(p-e.yxy);
    n.z = d - world(p-e.yyx);
    
    return normalize(n);
}

// Function 2907
vec3 calculateNormals(vec3 pos){
    /*
    vec2 eps = vec2(0.0, epsilon);
    vec3 n = normalize(vec3(
    map(pos + eps.yxx).x - map(pos - eps.yxx).x,
    map(pos + eps.xyx).x - map(pos - eps.xyx).x,
    map(pos + eps.xxy).x - map(pos - eps.xxy).x));
    return n;
	*/
	
    // by @iq
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=0; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e).x;
    }
    return normalize(n);
	
}

// Function 2908
float shadowray(vec3 pos) {
    if (!RENDER_SHADOWS)
        return 1.0;

    float res = 1.0;
    float t = 0.2;
    for (int i = 0; i < 50; i++) {
		float h = sdf(pos + -LIGHT_DIR * t).x;
        res = min(res, 16.0 * h / t);
        t += clamp(h, 0.05, 0.4);
        if (res < 0.05)
            break;
    }
    return clamp(res, 0.0, 1.0);
}

// Function 2909
bool rayIntersectsDisplacement( in Ray ray, out float t, out vec3 normal, out int iter ) {
    iter = 0;
    float t1, t2;
    if( rayAABBIntersection( ray, displacementVolume, t1, t2) ) {
       	vec3 hitpos1 = ray.origin + ray.dir*(t1+EPSILON);	//volume entry point
        vec3 hitpos2 = ray.origin + ray.dir*(t2-EPSILON);	//volume exit point
        
        //Convert position to parametric coordinates
        vec3 uvd1, uvd2;
        POS2UVH(displacementVolume,hitpos1,uvd1);
        POS2UVH(displacementVolume,hitpos2,uvd2);
        
        //pixel coordinates of projected entry and exit point
        vec3 p0 = uvd1*vec3(float(DISP_MAP_W),float(DISP_MAP_H),1.0);
        vec3 p1 = uvd2*vec3(float(DISP_MAP_W),float(DISP_MAP_H),1.0);
        
        if( processVoxelsOnLine(ray, p0, p1, t, normal) ) {
            iter = 1;
            return true;
        }
    }
    
    return false;
}

// Function 2910
bool sphere_raycast(sphere_t sphere, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)
{
	vec3 o = orig;
	vec3 d = dir;
	vec3 c = sphere.p;
	float r = sphere.radius;
    float rsq = r * r;
    mat3 rot_mat = sphere.r;
	
	bool isinside = false;

    vec3 o2c = c - o;
    float distsq = dot(o2c, o2c);
    float o2cdp = dot(o2c, d);
    float c2raysq = max(0., distsq - o2cdp * o2cdp);
    if(c2raysq > rsq) return false;
    float foo = sqrt(rsq - c2raysq);
    float dist1 = o2cdp - foo;
    float dist2 = o2cdp + foo;
    if(distsq < rsq) isinside = true;
	if(isinside && !isfrominside) return false;

    if(isinside || isfrominside) intersect_dist = dist2;
    else intersect_dist = dist1;
    
    if(!isfrominside && intersect_dist < 0.) return false;
    
	castpoint = o + d * intersect_dist;
    vec3 nor = (castpoint - c) / r;
    normal = nor;
    if(isfrominside) normal = -normal;
	isfrominside = isinside;
	
    vec3 uvn = nor * rot_mat;
	uv.x = (atan(uvn.z, uvn.x) / PI) * .5 + .5;
	uv.y = (atan(uvn.y, length(uvn.xz)) / PI) * .5 + .5;
    return true;
}

// Function 2911
void initray(out ray r,screen s,vec2 o){
	vec3 l=vec3(0.0,0.0,0.0);
	vec3 tmp=vec3(2.0,0.0,0.0);
	tmp*=rot_y((PI*s.m.y)/4.0-PI/8.0);
	tmp*=rot_z(2.0*PI*s.m.x);
	vec3 e=l+tmp;
	vec3 u=vec3(0.0,0.0,1.0);
	vec3 d=normalize(l-e);
	vec3 h=normalize(cross(d,u));
	vec3 v=normalize(cross(h,d));
	d*=rot(v,FOV*s.p.x+o.x/s.r.x);
	d*=rot(h,FOV*s.p.y+o.x/s.r.y);
	r=ray(vec4(0.0),e,d,vec3(0.0),s.t,0);
}

// Function 2912
MarchingPack rayC(Ray r,float index){
	//cast a ray w/ camera
    float t = 0.;
	float t1 = 0.1;
	vec3 pos; 
    	
	vec2 minDist = vec2(MAX_VALUE,-1);
	vec2 maxDist = vec2(-1,-1);
    
	float j;
    Properties prop ,propIndex;
    //for each object of the scene
	for(int i=1; i<=OBJ_NB ;i++){
		//test intersection btw ray and object
		j=float(i);
        vec2 dist = checkIntersection(r,getObject(j),j);
        
            
        if( dist.x >=0. && dist.y !=-1. && isOk(index,dist.y)){
        	if( dist.x < minDist.x){
            	minDist = dist;
            }
        }
        
    	
	}
	//compute pixel colour
    MarchingPack cp ;
    if(minDist.y == -1.){
    	cp = MarchingPack(minDist.x,minDist.y,false);
    }else{
    	cp = MarchingPack(minDist.x,minDist.y, true);
    }
    
    return cp;
}

// Function 2913
vec2 raycast( in vec3 ro, in vec3 rd )
{
	vec2 res = vec2(-1.0);

    // bounding volume    
    vec2 dis = iBox( ro, rd, vec3(1.0) ) ;
    if( dis.y<0.0 ) return res;

    // raymarch
    float t = dis.x;
	for( int i=0; i<256; i++ )
	{
        vec3 pos = ro + t*rd;
		vec2 h = map( pos );
        res.x = t;
        res.y = h.y;
        
		if( h.x<precis || t>dis.y ) break;
		t += h.x;
	}

	if( t>dis.y ) res = vec2(-1.0);
	return res;
}

// Function 2914
vec3 GetNormal(vec3 p) {
    float d = GetDist(p);
    vec2 e = vec2(0.01, 0.0);
    
    vec3 n = d - vec3(
        GetDist(p-e.xyy),
        GetDist(p-e.yxy),
        GetDist(p-e.yyx)
    );
    
    return normalize(n);
}

// Function 2915
vec4 rayCrystal4(vec3 rp, vec3 rd) {
    rp -= crystal4_pos;
    return rayCrystal4B(rp,rd);
}

// Function 2916
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 50; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.001 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 2917
vec3 getWaterNormal(vec3 p) {
	float d = getDistance(p).d;
    
    // use offset samples to compute normal
    vec2 e = vec2(.5, 0);
    vec3 n = d - vec3(
        getDistance(p-e.xyy).d,
        getDistance(p-e.yxy).d,
        getDistance(p-e.yyx).d);
    
    return normalize(n);
}

// Function 2918
RayTraceResult RayTraceCylinder(in Ray ray, vec3 pos, float radius, float height)
{
    RayTraceResult res;
    res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    
    //< Credits : [0]iq
    // intersect capped cylinder		
    vec3  ce = vec3( pos.x, 0.0, pos.z );
    vec3  rc = ray.org - ce;
    float a = dot( ray.dir.xz, ray.dir.xz );
    float b = dot( rc.xz, ray.dir.xz );
    float c = dot( rc.xz, rc.xz ) - radius;
    float h = b*b - a*c;
    if( h>=0.0 )
    {
        // cylinder			
        float t = (-b - sqrt( h ))/a;
        if( t>0.0 && (ray.org.y+t*ray.dir.y)<height )
        {
            res.t = t;
            res.pos = ray.org + ray.dir*t;
            res.nn = normalize(vec3(ce.x - res.pos.x, 0., ce.z - res.pos.z));
        }
        // cap			
        t = (height - ray.org.y)/ray.dir.y;
        if( t>0.0 && (t*t*a+2.0*t*b+c)<0.0 )
        {
            res.t = t;
            res.pos = ray.org + ray.dir*t;
            res.nn = vec3(0., 1., 0.);
        }
    }
    
    return res;
}

// Function 2919
RayResult raymarch(in vec3 ro, in vec3 rd)
{
    float t = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        vec3 p = ro + rd * t;
        SceneDist scene = map(p);
        if (scene.dist < MIN_DIST)
        {
            return RayResult(t, p, normal(p), scene.material);
        }
        t += scene.dist;
        if (t > MAX_DIST)
        {
            break;
        }
    }
    return RayResult(MAX_DIST, vec3(0.0), vec3(0.0), kMatNone);
}

// Function 2920
vec3 normal(vec3 rayPos)
{
    vec3 e = vec3(0.01, 0.0, 0.0);
    return normalize(vec3(scene(rayPos + e.xyy) - scene(rayPos - e.xyy),
                          scene(rayPos + e.yxy) - scene(rayPos - e.yxy),
                          scene(rayPos + e.yyx) - scene(rayPos - e.yyx)));
}

// Function 2921
Ray ComputeRay(in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )
{
    //< Credits [1]@TekF
    Ray res;
    
	vec2 c = vec2(cos(rotation.x),cos(rotation.y));
	vec4 s;
	s.xy = vec2(sin(rotation.x),sin(rotation.y));
	s.zw = -s.xy;

    // from view space
	res.dir.xy = fragCoord.xy - iResolution.xy*.5;
	res.dir.z = iResolution.y*zoom;
	res.dir = normalize(res.dir);
	vec3 localRay = res.dir;
	
	// rotate ray
	res.dir.yz = res.dir.yz*c.xx + res.dir.zy*s.zx;
	res.dir.xz = res.dir.xz*c.yy + res.dir.zx*s.yw;
	
	// position camera
	res.org = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);
    
    return res;
}

// Function 2922
ivec3 RayDirToXYFace(vec3 dir){
    
    if        (dir.x>max(abs(dir.y),abs(dir.z))){
        dir /= dir.x/512.;
        return ivec3(-dir.z+512.0, -dir.y+512., 0);
    } else if (dir.y>max(abs(dir.z),abs(dir.x))){
        dir /= dir.y/512.;
        return ivec3(dir.x+512., dir.z+512.,1);
    } else if (dir.z>max(abs(dir.x),abs(dir.y))){
        dir /= dir.z/512.;
        return ivec3(dir.x+512.,-dir.y+512.,2);
    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){
        dir /=-dir.x/512.;
        return ivec3(dir.z+512.,-dir.y+512.,3);
    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){
        dir /=-dir.y/512.;
        return ivec3(dir.x+512.,-dir.z+512.,4);
    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){
        dir /=-dir.z/512.;
        return ivec3(-dir.x+512.,-dir.y+512.,5);
    } else return ivec3(0,0,-1);
}

// Function 2923
bool rayMarch(vec3 eye, vec3 dir, float minDistance, float maxDistance,
              out float totDist, out bool isWater)
{
    totDist = minDistance;
    vec3 pos = eye;
	for (int i = 0; i < numMarches; i++)
    {
        pos = eye + totDist * dir;
        float dist = sceneSDF(pos, isWater);
        if (dist < epsilon)
        {
            return true;
        }
        else if (dist > maxDistance)
        {
            return false;
        }
        totDist += dist * .25;
    }
    
    return false;
}

// Function 2924
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                      e.yyx*map( pos + e.yyx ).x +
                      e.yxy*map( pos + e.yxy ).x +
                      e.xxx*map( pos + e.xxx ).x );
    /*
	vec3 eps = vec3( 0.0005, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
	*/
}

// Function 2925
Ray4Result rayCastWorld ( in World _world, in Ray4 _ray )
{
    return rayCastCube ( _world, _ray );
}

// Function 2926
vec2 castRay(vec3 pos, vec3 dir)
{    
    float tmin = 1.0;
    float tmax = 20.0;

#if 1
    float tp1 = (0.0 - pos.y)/dir.y; if (tp1 > 0.0) tmax = min(tmax, tp1);
    float tp2 = (1.6 - pos.y)/dir.y; if (tp2 > 0.0) { if (pos.y > 1.6) tmin = max(tmin, tp2);
                                                     else tmax = min(tmax, tp2); }
#endif
    
    float t = tmin;
    float m = -1.0;
    for (int i=0; i<64; i++)
    {
        float precis = 0.0005*t;
        vec2 res = map(pos + dir*t);
        if (res.x<precis || t>tmax) break;
        t += res.x;
        m = res.y;
    }
    
    if (t>tmax) m=-1.0;
    return vec2(t, m);
}

// Function 2927
vec3 raymarch(samplerCube s, vec3 ro, vec2 auv, vec3 lp, float dn, float fb, float fp, vec3 col)
{
    vec3 rd = getCamera(ro, vec3(auv, -0.45));
    float t = 0.0;
    float d = 0.0;
    vec3 color = vec3(0.0);
    for(int x = 0; x < MAX_STEPS_MARCH; x++)
    {
        vec3 pos = ro + t * rd;
        float d = length(pos) - SPHERE_RADIUS;
        if(d < 0.001)
        {
            vec3 n = normalize(pos);

            vec3 l = normalize(-lp - ro);
			vec3 v = normalize(pos - ro);
			vec3 r = normalize(reflect(-l, n));
            d = clamp(abs(ro.z - pos.z), 0.0, 1.0);
			float spec = 0.7 * clamp(pow(max(dot(r, v), 0.0), 128.0), 0.0, 1.0);
            float diff = dot(normalize(lp), n) * 0.4;
            
            vec3 a = texture(s, reflect(rd, n * dn)).rgb;
            vec3 col = mix(a, col, 0.70) + vec3(diff + spec);
            
            // like a Fresnel coefficient
            float fc = min(pow(distance(n, ro), fp) * 2.0, fb);
            
            col = mix(col, a, fc);
            return col;
        }
        
        t += d;
    }
    
    return texture(s, rd).rgb;
}

// Function 2928
vec3 normalUnpack(vec2 enc)
{
    vec3 n;
    n.xy = enc*2.0-1.0;
    n.z = sqrt(1.0-dot(n.xy, n.xy));
    return n;
}

// Function 2929
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<50; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 2930
vec3 calcNormal( in vec3 pos, in float time )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 0.00025;
    return normalize( e.xyy*map( pos + e.xyy*eps, time ).x + 
					  e.yyx*map( pos + e.yyx*eps, time ).x + 
					  e.yxy*map( pos + e.yxy*eps, time ).x + 
					  e.xxx*map( pos + e.xxx*eps, time ).x );
#else
    // klems's trick to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.0005*e,time).x;
    }
    return normalize(n);
#endif    
}

// Function 2931
vec4 GetNormal_Generic(vec4 p) {
    
    vec2 epsilon = vec2(0.001, 0);
    
    float d = GetDist(p);
    
    //Get the slope by subtracting nearby points from the point and normalizing their direction
    vec4 n = vec4(
        d - GetDist(p - epsilon.xyyy), //*.xyy and xyx are called a "swizzle", just makes it faster to write
        d - GetDist(p - epsilon.yxyy),
        d - GetDist(p - epsilon.yyxy),
        d - GetDist(p - epsilon.yyyx));
        
    return normalize(n);
}

// Function 2932
float parametric_normal_iteration(float t, vec2 uv){
	vec2 uv_to_p=parametric(t)-uv;
	vec2 tang=parametric_diff(t);

	float l_tang=dot(tang,tang);
	return t-factor*dot(tang,uv_to_p)/l_tang;
}

// Function 2933
void raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {
    // eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);
    eye = cameraTarget + vec3(0, 150, -850);
    ref = cameraTarget;
    
    float len = tan(3.14159 * 0.125) * distance(eye, ref);
    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));
    vec3 V = normalize(cross(H, eye - ref));
    V *= len;
    H *= len * iResolution.x / iResolution.y;
    vec3 p = ref + uv.x * H + uv.y * V;
    dir = normalize(p - eye);
}

// Function 2934
vec3 distance_normal(vec3 pos){
    float d = surface_distance(pos);
    return normalize(vec3(
    surface_distance(pos + vec3(eps,   0,   0)) - d,
    surface_distance(pos + vec3(  0, eps,   0)) - d,
    surface_distance(pos + vec3(  0,   0, eps)) - d
    ));
}

// Function 2935
float reflection (in vec3 ro, in vec3 rd, in float d)
{
    vec3 p = ro + d * rd;
    vec3 nor = normal (p, d*EPSILON);
    vec3 ref = normalize (reflect (rd, nor));
    float iter = .001;
    float r = 1.;
    for (int i = 0; i < MAX_ITER; ++i) {
    	float d = scene (p + nor *.01 + ref * iter).d;
        if (d <=.0) break;
        r *= saturate (d * 50.);
        iter += max (.0, d);
    }

    return saturate (r);
}

// Function 2936
vec3 calcNormal(vec3 p)
{
    vec3 e = vec3(0.001, 0.0, 0.0);
    vec3 n;
    n.x = map(p + e.xyy).x - map(p - e.xyy).x;
    n.y = map(p + e.yxy).x - map(p - e.yxy).x;
    n.z = map(p + e.yyx).x - map(p - e.yyx).x;
    return normalize(n);
}

// Function 2937
vec3 getNormal(vec3 p){
    const float d = EPS;
    return
    normalize
    (
      vec3
      (
        distanceFunction(p+vec3(d,0.0,0.0))-distanceFunction(p+vec3(-d,0.0,0.0)),
        distanceFunction(p+vec3(0.0,d,0.0))-distanceFunction(p+vec3(0.0,-d,0.0)),
        distanceFunction(p+vec3(0.0,0.0,d))-distanceFunction(p+vec3(0.0,0.0,-d))
      )
    );
}

// Function 2938
vec3 SceneNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.01, 0.0, 0.0 );
    vec3 nor = vec3(
        Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),
        Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),
        Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );
    return normalize( -nor );
}

// Function 2939
vec3 calcNormal(const vec3 pos, const float t )
{
    vec3 e = (PRECISION_FACTOR * t * .57) * vec3(1, -1, 0);
    return normalize
        (e.xyy*getDistance(pos + e.xyy) +
		 e.yyx*getDistance(pos + e.yyx) +
		 e.yxy*getDistance(pos + e.yxy) +
         e.xxx*getDistance(pos + e.xxx) );
}

// Function 2940
vec3 calcNormal(in vec3 pos)
{
vec3 eps=vec3(0.0001,0.0,0.0);
return normalize(vec3((f(pos+eps.xyy)-f(pos-eps.xyy)).x,(f(pos+eps.yxy)-f(pos-eps.yxy)).x,(f(pos+eps.yyx)-f(pos-eps.yyx)).x));
}

// Function 2941
float raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )
{
    float t = tmin;
	for( int i=0; i<256; i++ )
	{
        vec3 pos = ro + t*rd;
		float h = pos.y - mapTerrain( pos.xz );
		if( h<(0.002*t) || t>tmax ) break;
		t += 0.5*h;
	}

	return t;
}

// Function 2942
float rayCircle( vec2 p, vec2 d, vec2 center, float radius, float I )
{
    // ray-circle intersection
    if( dot(p-center,p-center) < radius*radius )
        return 0.;
    
    float t = dot(d, center-p);
    if( t < 0. )
        return 0.;
    
    return length(p+t*d - center) > radius ? 0. : circle( p, center, radius, I );
}

// Function 2943
bool marchRay(vec3 startPos, vec3 dir, out vec3 color) {
  vec3 p = startPos;
  bool checksteps = keypress(CHAR_Q);
  for (int i = 0; i < MAXSTEPS; i++) {
    assert(i < MAXSTEPS-1);
    if (checksteps) assert(i < 200);
    if (length(p) > MAX_DISTANCE) return false;
    float dist = sceneDf(p);
    if (dist <= MIN_DISTANCE) break;
    // Proceed cautiously when "close" to surface
    if (dist > limit) dist = dist-limit+slow;
    else dist = slow*dist;
    p += dist*dir;
  }
  vec3 baseColor = vec3(0.8);
  if (!keypress(CHAR_U)) baseColor = triplanar(normalize(p),sampler).xyz;
  if (keypress(CHAR_A)) {
    // Show axes
    float d = min(abs(p.x),min(abs(p.y),abs(p.z)));
    if (d < 0.02) baseColor = vec3(0.5,0,0);
  }
  color = processLighting(baseColor,dir,p);
  return true;
}

// Function 2944
bool rayTableIntersection( in Ray ray, in float distMin, in bool forShadowTest, inout SurfaceHitInfo hit, inout float nearestDist ) {
    SurfaceHitInfo currentHit;
    
    //intersect table
    float distToTable;
    bool hit_result = rayZPlaneIntersection( ray, table.pos, table.size, forShadowTest, distToTable, currentHit );
    if( hit_result && ( distToTable > distMin ) && ( distToTable < nearestDist ) ) {
        if(forShadowTest){
            return false;
        } else {
            hit = currentHit;
            hit.position_ = ray.origin + ray.dir * distToTable;
            hit.normal_   = vec3(0.0, 1.0, 0.0);
            hit.tangent_  = vec3(1.0, 0.0, 0.0);
            hit.mtl_id_ = SURFACE_ID_BASE+0;

            nearestDist = distToTable;
        }
    }
    /*
    //intersect frame
    float dist;
    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(table.size.x*0.5+1.0, 1.2, 0.0), vec2(2.0, table.size.y-4.0), forShadowTest, dist, currentHit );
    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {
        if(forShadowTest){
            return false;
        } else {
            hit = currentHit;
            hit.position_ = ray.origin + ray.dir * dist;
            //hit.normal_   = vec3(0.0, 1.0, 0.0);
            //hit.tangent_  = vec3(1.0, 0.0, 0.0);
            hit.mtl_id_ = SURFACE_ID_BASE+3;

            nearestDist = dist;
        }
    }
    
    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(-table.size.x*0.5-1.0, 1.2, 0.0), vec2(2.0, table.size.y-4.0), forShadowTest, dist, currentHit );
    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {
        if(forShadowTest){
            return false;
        } else {
            hit = currentHit;
            hit.position_ = ray.origin + ray.dir * dist;
            //hit.normal_   = vec3(0.0, 1.0, 0.0);
            //hit.tangent_  = vec3(1.0, 0.0, 0.0);
            hit.mtl_id_ = SURFACE_ID_BASE+3;

            nearestDist = dist;
        }
    }
    
    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(0.0, 1.2, -table.size.y*0.5-1.0), vec2(table.size.x-4.0, 2.0), forShadowTest, dist, currentHit );
    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {
        if(forShadowTest){
            return false;
        } else {
            hit = currentHit;
            hit.position_ = ray.origin + ray.dir * dist;
            //hit.normal_   = vec3(0.0, 1.0, 0.0);
            //hit.tangent_  = vec3(1.0, 0.0, 0.0);
            hit.mtl_id_ = SURFACE_ID_BASE+3;

            nearestDist = dist;
        }
    }
    
    hit_result = rayZPlaneIntersection( ray, table.pos + vec3(0.0, 1.2, table.size.y*0.5+1.0), vec2(table.size.x-4.0, 2.0), forShadowTest, dist, currentHit );
    if( hit_result && ( dist > distMin ) && ( dist < nearestDist ) ) {
        if(forShadowTest){
            return false;
        } else {
            hit = currentHit;
            hit.position_ = ray.origin + ray.dir * dist;
            hit.normal_   = vec3(0.0, 1.0, 0.0);
            hit.tangent_  = vec3(1.0, 0.0, 0.0);
            hit.mtl_id_ = SURFACE_ID_BASE+3;

            nearestDist = dist;
        }
    }*/
}

// Function 2945
vec3 reflection(vec3 p, vec3 rd ) {

    vec3 reflectDir = normalize(reflect(rd, normal));
    vec3 o = p + reflectDir * SURF_DIST *10.;
    float t = march( o , reflectDir);
    vec3 pt = o + t*reflectDir;
    vec3 reflected = light(pt,sun, vec3(1.,.0,.0),false ) ;

    return reflected;

}

// Function 2946
float pack_normal( vec3 a ) { uvec3 b = uvec3( round( 511. * a ) + 512. ) & 1023u; return uintBitsToFloat( ( b.x << 20u ) | ( b.y << 10u ) | b.z ); }

// Function 2947
RayHit rayCastBase(in Ray ray, in Scene scene){
    RayHit result = RayHit(fogColor, -ray.dir, maxDistance);
    result = selectClosest(result, rayVsPlane(ray, scene.plane));
    result = selectClosest(result, rayVsSphere(ray, scene.mainSphere));
    for(int i = 0; i < numMovingSpheres; i++){
    	result = selectClosest(result, rayVsSphere(ray, scene.spheres[i]));
    }
    return result;
}

// Function 2948
vec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )
{
    return sign(pos)*normalize(max(abs(pos)-siz,0.0));
    
}

// Function 2949
void surface2x3_perspective_ray(in surface2x3 surf, vec2 p,
	out surface2x1 slice) {
	float A = surf.c[0]; float B = surf.c[1]; float C = surf.c[2];
	float D = surf.c[3]; float E = surf.c[4]; float F = surf.c[5];
	float G = surf.c[6]; float H = surf.c[7]; float I = surf.c[8];
    float J = surf.c[9];

    slice[0] = (A*p.x + E)*p.x + (D*p.x + B*p.y + F)*p.y + C;
    slice[1] = G*p.x + H*p.y + I;
    slice[2] = J;    
}

// Function 2950
vec3 normal (vec3 p, vec4 c)
{
	vec3 N;
    vec4 qP = vec4 (p, .0);
	float gradX;
    float gradY;
    float gradZ;
	vec4 gx1 = qP - vec4 (VICINITY, .0, .0, .0);
	vec4 gx2 = qP + vec4 (VICINITY, .0, .0, .0);
    vec4 gy1 = qP - vec4 (.0, VICINITY, .0, .0);
    vec4 gy2 = qP + vec4 (.0, VICINITY, .0, .0);
    vec4 gz1 = qP - vec4 (.0, .0, VICINITY, .0);
    vec4 gz2 = qP + vec4 (.0, .0, VICINITY, .0);

    for (int i = 0; i < MAX_ITERATIONS; i++) {
		gx1 = qSquare (gx1) + c;
		gx2 = qSquare (gx2) + c;
		gy1 = qSquare (gy1) + c;
		gy2 = qSquare (gy2) + c;
		gz1 = qSquare (gz1) + c;
		gz2 = qSquare (gz2) + c;
	}

	gradX = length (gx2) - length (gx1);
	gradY = length (gy2) - length (gy1);
	gradZ = length (gz2) - length (gz1);
	N = normalize (vec3 (gradX, gradY, gradZ));
	return N;
}

// Function 2951
void marchRay(inout Ray ray, inout vec3 colour) {
    bool inside = false; // are we inside or outside the glass object
    vec3 impact = vec3(1); // This decreases each time the ray passes through glass, darkening colours

    vec3 startpoint = ray.origin;
    
#ifdef DEBUG   
vec3 debugColour = vec3(1, 0, 0);
#endif
    
    SDResult result;
    vec3 n;
    vec3 glassStartPos;
    
    //float glow = 0.0;
    
    for (int i=0; i<kMAXITERS; i++) {
        // Get distance to nearest surface
        result = sceneDist(ray);
        
        //glow += result.material == kGLOWMATERIAL ? 
        //    pow(max(0.0, (80.0 - result.d) * 0.0125), 4.0) * result.d * 0.01
        //    : 0.0;
        
        // Step half that distance along ray (helps reduce artefacts)
        float stepDistance = (inside ? abs(result.d) : result.d) * 0.65;
        ray.origin += ray.dir * stepDistance;
        //if (length(ray.origin) > 40.0) { break; }
        
        if (stepDistance < eps) {
            // colision
            // normal
            // Get the normal, then clamp the intersection to the surface
    		n = normal(ray);
            //clampToSurface(ray, stepDistance, n);
#ifdef DEBUG
//debugColour = n;
//break;
#endif
            
            if ( result.material == kFLOORMATERIAL ) {
                // ray hit floor
                
                // Add some noise to the normal, since this is pretending to be grit...
                vec3 randomNoise = texrand(ray.origin.xz * 0.4, 0.0);
                n = mix(n, normalize(vec3(randomNoise.x, 1, randomNoise.y)), randomNoise.z);
                
                // Colour is just grey with crappy fake lighting...
                colour += mix(
                    kFLOORCOLOUR, 
                    vec3(0), 
                    pow(max((-n.x+n.y) * 0.5, 0.0), 2.0)
                ) * impact;
                float o = occlusion(ray, n);
#ifdef DEBUG
debugColour = vec3(o);
break;
#endif
                colour *= o;
                impact *= 0.;
                break;
            }
            
            if (result.material == kGLOWMATERIAL) {
             	colour = mix(colour, kGLOWCOLOUR, impact);
                impact *= 0.;
                break;
            }
            
            // check what material it is...
            
            if (result.material == kMIRRORMATERIAL) {
                
                // handle interior glass / other intersecion
                if (inside) {
                     float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    				glassStartPos = ray.origin;
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
                }
                
                // it's a mirror, reflect the ray
                ray.dir = reflect(ray.dir, n);
                    
                // Step 2x epsilon into object along normal to ensure we're beyond the surface
                // (prevents multiple intersections with same surface)
                ray.origin += n * eps * 4.0;
                
                // Mix in the mirror colour
                colour += highlight(ray, n);
                impact *= kMIRRORCOLOUR;
                float o = occlusion(ray, n);
                impact *= o;
#ifdef DEBUG
debugColour = vec3(o);
break;
#endif
                
            } else {
                // glass material
            
                if (inside) {
                	// refract glass -> air
                	ray.dir = refract(ray.dir, -n, 1.0/kREFRACT);
                    
                    // Find out how much to tint (how far through the glass did we go?)
                    float glassTravelDist =  min(distance(glassStartPos, ray.origin) / 16.0, 1.);
    
                    // mix in the colour
                	impact *= mix(kGLASSCOLOUR, kGLASSCOLOUR * 0.1, glassTravelDist);
                    
#ifdef DEBUG
debugValue += glassTravelDist / 2.0;
#endif
      
                
              	} else {
               		// refract air -> glass
                	glassStartPos = ray.origin;
                    
              	  	// Mix the reflection in, according to the fresnel term
                	float fresnel = fresnelTerm(ray, n, 1.0);
                    fresnel = fresnel;
    				/*
                    colour = mix(
                    	colour, 
                    	texture(iChannel1, reflect(ray.dir, n)), 
                    	vec4(fresnel) * impact);
*/
                    colour = mix(
                        colour,
                        backgroundColour(ray, 0.0),
                        vec3(fresnel) * impact);
                	colour += n.x * 0.1;//highlight(ray, n);
                    impact *= 1.0 - fresnel;
    			
                	// refract the ray
            		ray.dir = refract(ray.dir, n, kREFRACT);
                    
#ifdef DEBUG
//debugValue += 0.5;
#endif
                }
            
            	// Step 2x epsilon into object along normal to ensure we're beyond the surface
                ray.origin += (inside ? n : -n) * eps * 2.0;
                
                // Flip in/out status
                inside = !inside;
            }
        }
        
        // increase epsilon
        eps += divergence * stepDistance;
    }
    
    // So far we've traced the ray and accumulated reflections, now we need to add the background.
   // colour += texture(iChannel0, ray.dir) * impact;
    ray.origin = startpoint;
    colour.rgb += backgroundColour(ray, 0.0) * impact; // + glow * kGLOWCOLOUR;
    
#ifdef DEBUG
//debugColour.rgb = ray.dir;
//debugColour = vec3(float(debugStep)/2.0);
colour = debugColour;
#endif
}

// Function 2952
vec2 Raycast( const in vec3 vOrigin, const in vec3 vDir )
{
	vec2 d = vec2(0.0, -1.0);
	float t = 0.01;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{
		d = GetSceneDistance(vOrigin + vDir * t);
		if(abs(d.x) < 0.001)
		{
			break;
		}
		t += d.x;
		if(t > 100.0)
		{
			break;
		}
	}
	
	return vec2(t, d.y);
}

// Function 2953
vec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {
    vec3 F = ref - eye;
    vec3 R = normalize(cross(F, vec3(0,1,0)));
    vec3 U = normalize(cross(R, F)); 
    
    vec3 V = U * length(F) * tan(FOVY * 0.5);
    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;
    
    vec3 p = ref + ndc.x * H + ndc.y * V;
    
    return normalize(p - eye);
}

// Function 2954
vec3 sphereNormal(in vec3 p,in vec3 center,in float radius){
	return normalize(vec3(
        sdfSphere(vec3(p.x+EPSILON,p.y,p.z),center,radius)-sdfSphere(vec3(p.x-EPSILON,p.y,p.z),center,radius),
        sdfSphere(vec3(p.x,p.y+EPSILON,p.z),center,radius)-sdfSphere(vec3(p.x,p.y-EPSILON,p.z),center,radius),
        sdfSphere(vec3(p.x,p.y,p.z+EPSILON),center,radius)-sdfSphere(vec3(p.x,p.y,p.z-EPSILON),center,radius)
    ));
}

// Function 2955
ray ray_rotate_y(const in ray r, const in float t) {
    ray rt = r;
    rt.origin = rotate_y(rt.origin, t);
    rt.direction = rotate_y(rt.direction, t);
    return rt;
}

// Function 2956
vec3 _calcNormal(in vec3 p){
  vec3 v=vec3(.001,0,map(p).d);
  return normalize(vec3(map(p+v.xyy).d-v.z,map(p+v.yxy).d-v.z,map(p+v.yyx).d-v.z));
}

// Function 2957
vec3 getNormal(vec3 p) {
    float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;
    float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;
    float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;
    return normalize(vec3(x, y, z));
}

// Function 2958
void raytraceHillTreeline(vec3 rayPt, vec3 rayDir, float treelineX, float treeGapZ, float offZ, float offY, float slopeY){
    
    if (rayDir.x < 0.0) treelineX *= -1.0;
    
    float groundY = 0.0;
    
    float rayGapStepsX = (treelineX-rayPt.x)/rayDir.x;
    float rayZ = rayPt.z + rayDir.z*rayGapStepsX;
    float treeZ = floor((rayZ-offZ)/treeGapZ)*treeGapZ + treeGapZ*0.5 + offZ;
    
    if (treeZ > 40.0) return;
    if (treeZ < -70.0) return;
    
    const float hillNearZ = 0.0;
    if (treeZ > hillNearZ) groundY = (treeZ-hillNearZ)*slopeY;
    
    groundY += offY;
    
    raytraceTree(rayPt,rayDir,vec3(treelineX,groundY,treeZ),
    	sin(treeZ+treelineX)*1.5,//yOff
        sin(treeZ*0.7+treelineX)*4.0,//heightOff
        sin(treeZ*0.85+treelineX)*1.0//widthOff
    );
    
    //#ifdef DRAW_CLIP_RAYTRACES
    //color.g += sin(treeZ*0.2)*0.1+0.5;
    //#endif
    
}

// Function 2959
vec3 calcNormal(in vec3 p)
{
   //define magic number... (not sure where this comes from)
   vec2 e= vec2(0.001,0.0);
   //translate the 2d vector to 3d?
   return normalize (vec3 
        (
        	map (p+e.xyy) - map(p-e.xyy),
            map (p+e.yxy) - map(p-e.yxy),
            map (p+e.yyx) - map(p-e.yyx)                           
        
        )
	);
}

// Function 2960
bool rayQuadIntersect( in Ray ray, vec3 v0, vec3 v1, vec3 v2, vec3 v3, out float t, out vec3 n ) {
    float tcurrent;
    t = 10e+10;
	
    //first triangle
    if ( rayIntersectsTriangle( ray.origin, ray.dir, v0, v1, v2, tcurrent) ) {
        t = tcurrent;
        n = getTriangleNormal(v0, v1, v2);
    }
    
    //second triangle
    if ( rayIntersectsTriangle( ray.origin, ray.dir, v0, v2, v3, tcurrent) ) {
        if(tcurrent<t) {
            t = tcurrent;
        	n = getTriangleNormal(v0, v2, v3);
        }
    }
    
    return (t < 10e+10);
}

// Function 2961
void raymarching( out vec4 fragColor, in vec3 prp, in vec3 scp){

  //Raymarching
  const vec3 e=vec3(0.1,0,0);
  float maxd=48.0; //Max depth

  vec2 s=vec2(0.1,0.0);
  vec3 c,p,n;

  float f=1.0;
  for(int i=0;i<128;i++){
    if (abs(s.x)<.001||f>maxd) break;
    f+=s.x;
    p=prp+scp*f;
    s=inObj(p);
  }
  
  if (f<maxd){
    if (s.y==0.0)
      c=obj0_c(p);
    else if (s.y==1.0)
      c=obj1_c(p);
    else
      c=obj2_c(p);
 
    n=objNormal(p);
    float b=abs(dot(n,normalize(prp-p)));
    vec3 objColor=b*c+pow(b,8.0);
  
    //reflect
    float f0=f;
    if (s.y==2.0){
      prp=p-0.02*scp;
      scp=reflect(scp,n);
      f=0.0;
      s=vec2(0.1,0.0);
      maxd=16.0;
      for(int i=0;i<64;i++){
        if (abs(s.x)<.01||f>maxd) break;
        f+=s.x;
        p=prp+scp*f;
        s=inObj(p);
      }
      if (f<maxd){
        if (s.y==0.0)
          c=obj0_c(p);
        else if (s.y==1.0)
          c=obj1_c(p);
        else
          c=obj2_c(p);
      
        n=objNormal(p);
        b=abs(dot(n,normalize(prp-p)));
        vec3 objColor2=b*c+pow(b,8.0);
        fragColor=vec4((objColor*0.8+objColor2*0.2)*(1.0-f0*.03),1.0);
      } else fragColor=vec4(objColor*0.8*(1.0-f0*.03),1.0);

    } else fragColor=vec4(objColor*(1.0-f0*.03),1.0);
    
  } else fragColor=vec4(0,0,0,1);

}

// Function 2962
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.002,0.0,0.0);

    float f = map(pos).x;
	return normalize( vec3(
           map(pos+eps.xyy).x - f,
           map(pos+eps.yxy).x - f,
           map(pos+eps.yyx).x - f ) );
}

// Function 2963
float rayShape(in Ray r, in Shape s, out vec3 p, out vec3 n)
{
    if (s.cls == SHAPE_SPHERE)
    {
        return raySphere(r, s, p, n);
    }
    else if (s.cls == SHAPE_BOX)
    {
        return rayBox(r, s, p, n);
    }
}

// Function 2964
vec3 calcNormal(vec3 p, int octaves) {
	const vec3 eps = vec3(0.002, 0.0, 0.0);
	return normalize( vec3(map(p+eps.xyy, octaves).x - map(p-eps.xyy, octaves).x,
			       map(p+eps.yxy, octaves).x - map(p-eps.yxy, octaves).x,
			       map(p+eps.yyx, octaves).x - map(p-eps.yyx, octaves).x) );
}

// Function 2965
vec2 RayMarch(in vec3 origin, in vec3 rayDirection, inout vec3 mtl)
{
    float material = -1.0;
    float t = 0.01;
	for(int i = 0; i < 64; ++i)
    {
        vec3 p = origin + rayDirection * t;
        vec2 hit = SdScene(p, mtl);
        if (hit.x < 0.001 * t || t > 50.0)
			break;
        t += hit.x;
        material = hit.y;
    }
    
    if (t > 50.0)
    {
     	material = -1.0;   
    }
    return vec2(t, material);
}

// Function 2966
v22 getRay(vec2 u//uU is not normalized
){u=(u-iR.xy*.5)/iR.y
 ;mat4 ct=q2m(tf(camA0),tf(camP0).xyz)
 ;mat3 m=m42Rot(ct) //;mat3 m=q2m(tf(camA0))
 ;vec3 rd=normalize(m*vec3(0,0,1)   //up
                   +(m*vec3(1,0,0)*u.x//right+forward...
                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)
 ;return v22(ct[3].xyz,rd);}

// Function 2967
RayTraceResult RayTraceHoledSphere(in Ray ray)
{
    RayTraceResult res = RayTraceSphere(ray, sphereCenter, sphereRadius);
    if (!HolePattern(res.pos, sphereCenter))
    {
        res.t = infinite; res.pos = vec3(0.); res.nn = vec3(1.,1.,1.);
    }
    
    return res;
}

// Function 2968
vec3 calcNormal( in vec3 pos, in float id, float ic, in vec3 cen )
{
	if( ic>2.5 ) return normalize(vec3(pos-cen));
	if( ic>1.5 ) return vec3(0.0,1.0,0.0);
	return normalize((pos-cen)*vec3(1.0,0.0,1.0));
}

// Function 2969
float cast_ray( in vec3 ro, in vec3 rd, in float to, in float tMax, out vec4 suvw )
{
	suvw = vec4(0.0);

	float t = to;
    for( int i=ZERO; i<512; i++ )
	{
        vec3 pos = ro + t*rd;
		float h = map( pos, suvw );
        if( abs(h)<(0.0005*t) || t>tMax) break;
        t += h*0.4;
	}
    return t;
}

// Function 2970
Ray newRay(vec3 origin, vec3 direction, vec3 attenuation) {
	// Create a default ray
	return Ray(origin, direction, origin, 0, vec3(0.0), attenuation);
}

// Function 2971
intersection RAYBOXINTERSECT(ray r, aabb box)
{
    intersection result;
    result.distance = rayboxintersect(r, box);
    //result.normal = -r.dir; // sky-sphere
    //if(result.distance < MAXDIST) result.normal = cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0);

    result.normal = mix(-r.dir, cubenormal(r.pos + r.dir * result.distance - (box.min + box.max) / 2.0), step(result.distance, MAXDIST));

    return result;
}

// Function 2972
bool castRay( const vec3 ro, const vec3 rd )
{
    const float delt = 1.0;
    const float mint = 0.0;
    const float maxt = 20.0;
    for( float t = mint; t < maxt; t += delt )
    {
        vec3 p = ro + rd*t;
        if( p.y < f( p.x, p.z ) )
        {
            return true;
        }
    }
    return false;
}

// Function 2973
float rayPlane(vec3 p, vec3 o, vec3 n, vec3 rd) {
    
    float dn = dot(rd, n);

    float s = 1e8;
    
    if (abs(dn) > 0.) {
        s = dot(p - o, n) / dn;
        s = s<0. ? 1e8 : s;
    }
    
    return s;//o + s*rd;
}

// Function 2974
vec3 GetSceneNormal(const in vec3 vPos)
{
    const float fDelta = 0.001;

    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);
    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);
    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);
	
    vec3 vOffset1 = vDir1 * fDelta;
    vec3 vOffset2 = vDir2 * fDelta;
    vec3 vOffset3 = vDir3 * fDelta;

    vec3 vPos1 = vPos + vOffset1;
    vec3 vPos2 = vPos + vOffset2;
    vec3 vPos3 = vPos + vOffset3;
 
    float f1 = GetSceneDistance( vPos1 );
    float f2 = GetSceneDistance( vPos2 );
    float f3 = GetSceneDistance( vPos3 );
    
    vPos1.y -= f1;
    vPos2.y -= f2;
    vPos3.y -= f3;
    
    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );
    
    return normalize( vNormal );
}

// Function 2975
bool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, 
                      out vec3 refracted) {
    float dt = dot(v, n);
    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);
    if (discriminant > 0.) {
        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);
        return true;
    } else { 
        return false;
    }
}

// Function 2976
float ct_normal_pi(
    in vec2 z
){
    float a = atan(z[1], z[0]);
    if (a < 0.0) a += 6.28318;
    a /= 6.28318;
    return a;
}

// Function 2977
vec3 calcNormal( in vec3 pos, mat3 rotMat )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy, rotMat) - map(pos-eps.xyy, rotMat),
	    map(pos+eps.yxy, rotMat) - map(pos-eps.yxy, rotMat),
	    map(pos+eps.yyx, rotMat) - map(pos-eps.yyx, rotMat) );
	return normalize(nor);
}

// Function 2978
float rayMarch( in vec3 origin, in vec3 direction ) {
    float total = .0;
    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {
        vec3 point = origin + direction * total;
                
        float current = sceneDistance( point );
        total += current;
        if ( total > RAY_MARCH_TOO_FAR || abs(current) < RAY_MARCH_CLOSE ) {
            break;
        }
    }
    return total;
}

// Function 2979
rayhit rayScene(vec3 rp, vec3 rd) {
    rayhit h;
	h.normal.w = VIEW_DISTANCE;
    
    //your custom scene code goes here
    
    #define wallmat() h.diffuse = vec4(.8,.8,.8,0);\
    h.metallic = 0.;h.opacity = 1.
    
    //floor
    rt(rayPlane(rp,rd,vec3(0,-1,0),vec3(0,1,0)),
    	wallmat();
    );
    
    //ceiling
    rt(rayPlane(rp,rd,vec3(0,1,0),vec3(0,-1,0)),
    	wallmat();
        //light emission
        vec2 hp = abs(rp.xz+rd.xz*s.w);
        h.diffuse.w = max(0.,(.3-max(hp.x,hp.y))*120.);
    );
    
    //back wall
    rt(rayPlane(rp,rd,vec3(0,0,1),vec3(0,0,-1)),
    	h.metallic = 1.;
        h.roughness = 0.001;
        h.specular = vec4(.95,.95,.95,0);
        h.opacity = 1.;
    );
    
    //red right wall
    rt(rayPlane(rp,rd,vec3(1,0,0),vec3(-1,0,0)),
    	h.diffuse = vec4(1,0,0,0);
        h.metallic = 0.;
        h.opacity = 1.;
    );
    
    //green left wall
    rt(rayPlane(rp,rd,vec3(-1,0,0),vec3(1,0,0)),
    	h.diffuse = vec4(0,1,0,0);
        h.metallic = 0.;
        h.opacity = 1.;
    );
    
    //raymarched volumetric cloud cube
    #define CUBE_POS vec3(.5,-.5,-.5)
    rtc(cloudCube(rp-CUBE_POS,rd),CUBE_POS,.5,
        h.metallic = 0.;
        h.diffuse = vec4(1.8,1.8,1.8,0);
        h.opacity = .4;
        h.refrIndex = 1.;
    );
    
    //chromatic refractive triangle prism
    #define PRISM_POS vec3(-.4,-.7,-.2)
    rtc(rayTriPrism(rp-PRISM_POS,rd),PRISM_POS,.5,
    	h.metallic = 1.;
        h.specular = vec4(1,1,1,0);
        h.opacity = 0.;
        CHROMA(h.refrIndex = 1.;,//r
               h.refrIndex = .9;,//g
               h.refrIndex = .8;);//b
    );
    
    return h;
}

// Function 2980
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
   

    float t = tmin;
    float m = -1.0;
    for( int i=0; i<64; i++ )
    {
	    float precis = 0.0005*t;
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 2981
void rayMarch()
{
    
}

// Function 2982
bool raymarch( Ray ray, out vec3 hitPos, out vec3 hitNrm )
{
	const int maxSteps = 128;
	const float hitThreshold = 0.0001;

	bool hit = false;
	hitPos = ray.org;

	vec3 pos = ray.org;

	for ( int i = 0; i < maxSteps; i++ )
	{
		float d = scene( pos );

		if ( d < hitThreshold )
		{
			hit = true;
			hitPos = pos;
			hitNrm = sceneNormal( pos, d );
			break;
		}
		pos += d * ray.dir;
	}
	return hit;
}

// Function 2983
vec3 getNormal (vec3 p) {
  vec2 e = .01 * vec2(-1., 1.);
  vec3 nor = e.xyy*map(p+e.xyy) +
    e.yxy*map(p+e.yxy) +
    e.yyx*map(p+e.yyx);// +
    //e.xxx*map(p+e.xxx); // comment to get white aura
    
  return normalize(nor);
}

// Function 2984
void raytrace_plane(
	vec4 plane_center,
	vec4 plane_normal,
	vec4 ray_origin,
	vec4 ray_direction,
	inout vec3 inout_ray_color,
	inout float inout_ray_depth)
{    
    // https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form
    float depth = dot((plane_center - ray_origin), plane_normal) / dot(ray_direction, plane_normal);
    
    if ((depth >= 0.0) &&
        (depth < inout_ray_depth))
    {
        vec4 intersection = (ray_origin + (ray_direction * depth));

        float diffuse_fraction = (1.0 * max(0.0, dot(plane_normal, s_light_direction)));
        float specular_fraction = 0.0; // (0.5 * pow(max(0.0, (-1.0 * dot(ray_direction, reflect((-1.0 * s_light_direction), normal)))), 40.0));
        
        vec3 surface_color = vec3(1.0);
        
        // Checkerboard
        if (true)
        {
            float fuzziness = (0.025 * depth);
            
            surface_color = 
                mix(
                	vec3(0.1),
                	vec3(0.9),
                	abs((smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.x)) + smoothstep(-fuzziness, fuzziness, cos(k_tau * intersection.z))) - 1.0));            
        }

        inout_ray_color = (surface_color * mix(s_light_ambient_color, vec3(1.0), min(1.0, (diffuse_fraction + specular_fraction))));
        inout_ray_depth = depth;
    }
}

// Function 2985
vec3 normalAt( vec3 pos )
{    
    const float eps = 0.001;
    float dist = calcDist( pos );
    return normalize( vec3( dist - calcDist( pos + vec3(eps,0,0) )
                          , dist - calcDist( pos + vec3(0,eps,0) )
                          , dist - calcDist( pos + vec3(0,0,eps) ) ) );
}

// Function 2986
vec4 getNormal(vec4 p) {
    float d = EPSILON;
    return normalize(vec4(
            surfaceSDF(p + vec4(d, 0.0, 0.0, 0.0)) - surfaceSDF(p),
            surfaceSDF(p + vec4(0.0, d, 0.0, 0.0)) - surfaceSDF(p),
            surfaceSDF(p + vec4(0.0, 0.0, d, 0.0)) - surfaceSDF(p),
            surfaceSDF(p + vec4(0.0, 0.0, 0.0, d)) - surfaceSDF(p)
        ));
    }

// Function 2987
vec3 CubemapNormal(in vec2 tile) 
{   
    float s = (2.0*square((tile.x + 1.0)*0.5) - 1.0);
    
    float x = square(tile.x) * square(tile.y + 1.0) * s;
    float y = square(tile.y) * s;
    float z = square(tile.x + 1.0) * square(tile.y + 1.0) * s;
 
    return vec3(x, y, z);
}

// Function 2988
float WaveRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  s = 0.;
  sLo = 0.;
  dHit = dstFar;
  for (int j = VAR_ZERO; j < 50; j ++) {
    p = ro + s * rd;
    h = p.y - WaveHt (p.xz);
    if (h < 0.) break;
    sLo = s;
    s += max (0.5, 1.3 * h) + 0.01 * s;
    if (s > dstFar) break;
  }
  if (h < 0.) {
    sHi = s;
    for (int j = VAR_ZERO; j < 5; j ++) {
      s = 0.5 * (sLo + sHi);
      p = ro + s * rd;
      if (p.y > WaveHt (p.xz)) sLo = s;
      else sHi = s;
    }
    dHit = sHi;
  }
  return dHit;
}

// Function 2989
vec3 normal(vec3 p) { return normalize(vec3(nax(p,e.xyy), nax(p,e.yxy), nax(p,e.yyx))); }

// Function 2990
vec2 raymarch_main_scene_normals(vec3 _p, float t)
{
    return scene_min(scene_base_sand(_p), scene_pyramids(_p));
}

// Function 2991
float GRayDens (vec3 ro, vec3 rd)
{
  vec3 p, q;
  float d, s, ds, sd, gDens;
  sd = 0.1 * smoothstep (0.6, 0.8, dot (rd, sunDir));
  gDens = 0.;
  if (sd > 0.) {
    p = ro + 100. * rd / max (rd.y, 0.05);
    ds = 5. / max (rd.y, 0.05);
    s = 0.;
    for (int j = 0; j < 16; j ++) {
      q = p + s * rd;
      gDens += sd * (1. - gDens) * smoothstep (0.8, 1., CloudDens (q, sunDir));
      s += ds;
      if (q.y > 400. || gDens > 0.95) break;
    }
  }
  return gDens;
}

// Function 2992
float ray_pln(in ray r, in vec3 p)
{
    return - dot(r.pos, p.xyz) / dot(r.dir, p.xyz);
}

// Function 2993
vec3 normal(vec3 p, float l){vec2 e=vec2(.1,0)
;return normalize(vec3
(l-gd(p-e.xyy)
,l-gd(p-e.yxy)
,l-gd(p-e.yyx)));}

// Function 2994
vec3 sceneNormal(vec3 pos)
{
	float distancePoint = scene(pos).x;
    float aepsilon = 0.01;
    float x = scene(pos + vec3(AEPSILON, 0.0, 0.0)).x;
    float y = scene(pos + vec3(0.0, AEPSILON, 0.0)).x;
    float z = scene(pos + vec3(0.0, 0.0, AEPSILON)).x;
	return normalize(vec3(x - distancePoint, y - distancePoint, z -distancePoint));
}

// Function 2995
vec3 getWaterNormal(vec3 p, float d) {
    return normalize(vec3(
        getWaterLevel(vec2(p.x-nEPS,p.z), d) - getWaterLevel(vec2(p.x+nEPS,p.z), d),
        2.0*nEPS,
        getWaterLevel(vec2(p.x,p.z-nEPS), d) - getWaterLevel(vec2(p.x,p.z+nEPS), d)
    ));
}

// Function 2996
vec2 raymarch(vec3 ro, vec3 rd, int iter) {
    float  t = 0.;
    float id = -1.;
    for(int i = 0; i < MAX_ITERATIONS; i++) {
        if(t >= FAR_PLANE || i >= iter) {
            id = -1.;
            break;
        }
        vec2 scn = dstScene(ro+rd*t);
        if(scn.x < EPSILON) {
            id = scn.y;
            break;
        }
        t += scn.x * .75;
    }
    return vec2(t,id);
}

// Function 2997
void rayTransp(inout v33 a,inout v33 b){vec3 s=a.b;a.b=b.a;b.a=s;}

// Function 2998
vec3 getNormal( in vec3 pos )
{
  float d = map(pos);
  vec3 eps = vec3( 0.001, 0.0, 0.0 );
  return normalize(vec3(d - map(pos-eps.xyy), 
                        d - map(pos-eps.yxy), 
                        d - map(pos-eps.yyx) ));
}

// Function 2999
vec4 MAP_REFLECTION_Scene(vec3 p, vec3 eye, int mode) { // Main Reflection Scene
	float fulldist = 9999.0;
    float dist = fulldist;
    vec3 color = DEFAULT_MESH_COLOR;
    vec3 n = mode == 1 ? GetNormalForReflection(p) : vec3(0.0);
    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);
    
    // Red Sphere
    {
        vec3 sphereColor = vec3(1.0, 0.0, 0.0);
        float sphereRadius = 1.0;
        vec3 spherePosition = vec3(0.0, 1.0, 0.0);
        float sphereDist = length(p-spherePosition)-sphereRadius;
        if (sphereDist < dist) {
            color = sphereColor*diff;
            dist = sphereDist;
        }
    }
    
    // Ocean
    {
        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);
        float oceanHeight = 0.0;
        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);
        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;
        if (oceanDist < dist) {
            color = oceanColor;
            dist = oceanDist;
        }
    }
    
    return vec4(color, dist);
}

// Function 3000
vec3 getNormal(in vec2 fragCoord) {
    vec3 val = vec3(0.0);
    for (int x = -3; x<=3; x++)
        for (int y = -3; y<=3; y++)
            val += texelFetch(iChannel1, ivec2(fragCoord)+ivec2(x, y), 0).xyz;
    return normalize(val);
}

// Function 3001
vec3 getNormal(vec3 p)
{    
    vec2 e = vec2(P,0.);

    return safeNormalize(vec3(
        scene(p+e.xyy)-scene(p-e.xyy),
        scene(p+e.yxy)-scene(p-e.yxy),
        scene(p+e.yyx)-scene(p-e.yyx)
    ));
}

// Function 3002
vec2 ray_march(in vec3 ro, in vec3 rd)
{
    float t = 0.0;
    float tmax = 120.0;
    const int smax = 200;
    float st = 0.0;
    
    for (int i = 0; i < smax; ++i)
    {
        vec3 p = ro + rd * t;
        float res = intersect(p);
        if (res < 0.001 || t > tmax)
            break;
        t += res * 0.5;
        st++;
    }
    
    if (t < tmax)
        return vec2(t, st / float(smax));
    else
        return vec2(-1.0, st / float(smax));
}

// Function 3003
bool cylinder_raycast(cylinder_t cylinder, vec3 orig, vec3 dir, out vec3 castpoint, out vec3 normal, out vec2 uv, out float intersect_dist, inout bool isfrominside)
{
	// mat3 minv = inverse(cylinder.r);
	vec3 local_orig = cylinder.r * (orig - cylinder.p);
	vec3 local_dir = cylinder.r * dir;
	float r = cylinder.radius;
	float rsq = r * r;
	float hh = cylinder.height / 2.;
	
	bool isinside = false;
	
	float ray_proj = dot(-local_orig.xz, normalize(local_dir.xz));
	float orig_to_axis_dist_sq = dot(local_orig.xz, local_orig.xz);
	float axis_to_ray_sq = max(0., orig_to_axis_dist_sq - ray_proj * ray_proj);
	if(axis_to_ray_sq > rsq) return false;
	float foo = sqrt(rsq - axis_to_ray_sq);
    float dist1 = ray_proj - foo;
    float dist2 = ray_proj + foo;
	if(orig_to_axis_dist_sq < rsq && abs(local_orig.y) <= hh) isinside = true;
	if(isinside && !isfrominside) return false;
	if(isfrominside) intersect_dist = dist2 / length(local_dir.xz);
	else intersect_dist = dist1 / length(local_dir.xz);
	
	vec3 local_cast = local_orig + local_dir * intersect_dist;
	vec3 local_normal = vec3(local_cast.xz, 0.).xzy / r * (isfrominside ? -1.:1.);
	
	if(abs(local_cast.y) > hh)
	{
		float plane1 = (local_orig.y - hh) / (-local_dir.y);
		float plane2 = (local_orig.y + hh) / (-local_dir.y);
        if(isfrominside) intersect_dist = max(plane1, plane2);
        else intersect_dist = min(plane1, plane2);
		local_normal = vec3(0, -sign(local_dir.y), 0);
		local_cast = local_orig + local_dir * intersect_dist;
		if(length(local_cast.xz) > r) return false;
		uv = (local_cast.xz + vec2(r)) / (r * 2.);
	}
	else
	{
		uv.x = (atan(local_normal.z, local_normal.x) / PI) * .5 + .5;
        uv.y = (local_cast.y + hh) / cylinder.height;
	}
	
	castpoint = orig + dir * intersect_dist;
	normal = local_normal * cylinder.r;
	isfrominside = isinside;

    return true;
}

// Function 3004
vec3 GetNormal( vec3 p )
{
    vec2 d = vec2(-1,1)*.001;
    return normalize(
            SDF(p+d.xxx)*d.xxx +
            SDF(p+d.yyx)*d.yyx +
            SDF(p+d.yxy)*d.yxy +
            SDF(p+d.xyy)*d.xyy
        );
}

// Function 3005
vec3 normal(vec3 p, float k)
{
    float m = map(p).x;
	vec2 e = vec2(0,k);
	return normalize(m-vec3(
		map(p - e.yxx).x,
		map(p - e.xyx).x,
		map(p - e.xxy).x
	));
}

// Function 3006
vec3 calcNormal( in vec3 pos )
{
#if 0
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=min(0,iFrame); i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+0.001*e).x;
    }
    return normalize(n);
#endif    
}

// Function 3007
Ray rayConstruct(in float3 origin,in float3 direction) 
{
    Ray r;
    r.o = origin;
    r.d = direction;
    return r;
}

// Function 3008
vec3 get_noisy_normal(vec3 normal, vec2 uv) {
    float noise_factor = pow(clamp(1.5 - abs(normal.z), 0.0, 1.0), 0.5) * 0.5;
	return normalize(normal + noise_factor * (sample_noise(iChannel0, uv).xyz - 0.5));
}

// Function 3009
vec3 calcNormal( in vec3 p, in vec4 c )
{
    vec4 z = vec4(p,0.0);

    // identity derivative
    mat4x4 J = mat4x4(1,0,0,0,  
                      0,1,0,0,  
                      0,0,1,0,  
                      0,0,0,1 );

  	for(int i=0; i<numIterations; i++)
    {
        // chain rule of jacobians (removed the 2 factor)
        J = J*mat4x4(z.x, -z.y, -z.z, -z.w, 
                     z.y,  z.x,  0.0,  0.0,
                     z.z,  0.0,  z.x,  0.0, 
                     z.w,  0.0,  0.0,  z.x);

        // z -> z2 + c
        z = qsqr(z) + c; 
        
        if(qlength2(z)>4.0) break;
    }

    return normalize( (J*z).xyz );
}

// Function 3010
float castRay( vec3 ro, vec3 rd )
{
	float t = 0.0;
	vec3 p;

	for ( int i = 0; i < 50; i++ )
	{
		p = ro + rd * t;
		float d = sdf( p );
		if ( d < 0.01 )
		{
			return t;
		}
		t += d;
	}

	return -1.0;
}

// Function 3011
vec3 getNormal(vec3 p, float value, mat3 rot) {
    vec3 n = vec3(field(rot*vec3(p.x+EPSILON,p.y,p.z)),
                  field(rot*vec3(p.x,p.y+EPSILON,p.z)),
                  field(rot*vec3(p.x,p.y,p.z+EPSILON)));
    return normalize(n - value);
}

// Function 3012
vec3 normal(in vec3 pos)
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy) - map(pos-eps.xyy),
	    map(pos+eps.yxy) - map(pos-eps.yxy),
	    map(pos+eps.yyx) - map(pos-eps.yyx) );
	return normalize(nor);
}

// Function 3013
void abstract_glassy_field_reflect(inout vec3 _2103, vec3 _2104, vec3 _2105)
{
    float _2121 = 2.0 * (((_2105.x * _2104.x) + (_2105.y * _2104.y)) + (_2105.z * _2104.z));
    vec3 _2129 = _240;
    _2129.x = _2121 * _2105.x;
    vec3 _2130 = _2129;
    _2130.y = _2121 * _2105.y;
    vec3 _2131 = _2130;
    _2131.z = _2121 * _2105.z;
    _2103.x = _2104.x - _2131.x;
    _2103.y = _2104.y - _2131.y;
    _2103.z = _2104.z - _2131.z;
}

// Function 3014
vec4 sdf_color_normal(vec3 pose, float dist, bool inside,inout vec3 nor)
{
    float pad = dist * 0.002;
    
    vec3 pos = pose;
    vec3 rot = pos;
    
    rot.xy -= vec2(0.36,-0.4);

    rot.xy = n_rotate(rot.xy,0.245);

    rot.xy += vec2(0.36,-0.4);
    
    if(dist * 0.001 > box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)))
        pos = rot;
            
    //use symetries
    
    // rotate by 90 segments
    vec3 pos_x  = abs(pos.x) < abs(pos.y)  ?  vec3(pos.y < 0.0 ? pos.x : -pos.x, abs(pos.y), pos.z)  :  vec3(pos.x < 0.0 ? -pos.y : pos.y, abs(pos.x), pos.z);
    
    
    //mirror x axis
    vec3 pos_xx = vec3(abs(pos_x.x), pos_x.y, pos_x.z);
    
    
    
    
    vec4 color = vec4(0.25,0.15,0.1,0.2);
    vec4 ns_scale = vec4(10,10,1,0.1) * vec4(pos,1.);
    
    
    
    if(inside)
    {
        
        vec3 ipos = pos;
        ipos.y -= 10.;
        ipos.z -= 0.14;
        
        if(pad > (length(ipos   + vec3( 0.00,   0, 1))-8.7)-0.3) color = vec4(3.,1.2,0.4,0.4);//all pylons
        
        
        if(pad > max(cheap_cyl(ipos          - vec3( 0.00,   0, 0.14),   2., 2.), - cheap_cyl(ipos    - vec3( 0.00, 0,0.74),   0.7, 2.))) color = vec4(0.25,0.15,0.1,1.);//console
        
        if(pad > pln(ipos          - vec3( 0.00,   0, 0.34),  vec3(0,0,1))) color = vec4(0.1);//inside floor
        
        
        if(pad > cheap_cyl(ipos          - vec3( 0.00,   0, 0.12),   5.7, 0.2)) color = vec4(3.,1.5,0.0,0.4);//stairs light
    }
    
    
    
    if(pad > box(pos    - vec3( 0.00, 0.00,1.00),  vec3(0.50,0.50,1.00)))   {color = vec4(0.05,0.20,0.30,0.10);ns_scale = vec4(400,400,10,0.15) * vec4(pos,1.);}//tardis blue
    //horizontal wood
    if(pad > box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//horizontal bars
    if(pad > box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//sign
    if(pad > box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.5);//base
    if(pad > box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.);//phone horizontal
    
    if(pad > box(pos_xx - vec3( 0.00, 0.46,1.55),  vec3(0.325,0.03,.04)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//sign
    
    
    
    float gly = 20.;
        
        gly = min(gly,show_text(pos_x.xz - vec2(-.11,1.55),ivec2(0x504f4c49, 0x43452020), 0.024));//"POLICE  "
        gly = min(gly,show_text(pos_x.xz - vec2(0.33,1.55),ivec2(0x424f5820, 0x20202020), 0.024));//"BOX     "
        gly = min(gly,show_text(pos_x.xz - vec2(0.08,1.565),ivec2(0x5055424c, 0x49432020), 0.01));//"PUBLIC  "
        gly = min(gly,show_text(pos_x.xz - vec2(.105,1.535),ivec2(0x43414c4c, 0x20202020), 0.01));//"CALL    "
        if(gly < 0.0)
            color = vec4(1);
    }
    if(pad > pln(pos    -vec3(0)                 ,vec3(0.00,0.00,1.00) ))   color = vec4(0.30,0.25,0.20,0.01);//floor
    if(pad > cheap_cyl(pos    - vec3( 0.00, 0.00, 1.91),  0.06, 0.05 ))   color = vec4(1);//light
    
    if(!inside)
    {
        if(pad > box(pos    - vec3(-0.19,-0.425, 0.97),  vec3(0.10,0.01,0.11)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//phone sign inside

            float gly = 20.;
            
            
            
            gly = min(gly,show_text(pos.xz - vec2(-.237,1.055),ivec2(0x504f4c49, 0x43452054), .006));//"POLICE T"
            gly = min(gly,show_text(pos.xz - vec2(-.142,1.055),ivec2(0x454c4550, 0x484f4e45), .006));//"ELEPHONE"
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.190,1.025),ivec2(0x46524545, 0x20464f52), .005));//"FREE FOR"
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.220,1.010),ivec2(0x55534520, 0x4f462050), .005));//"USE OF P"
            gly = min(gly,show_text(pos.xz - vec2(-.140,1.010),ivec2(0x55424c49, 0x43202020), .005));//"UBLIC   " 
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.235,0.985),ivec2(0x41445649, 0x43452026), .004));//"ADVICE &"
            gly = min(gly,show_text(pos.xz - vec2(-.160,0.985),ivec2(0x41535349, 0x5354414e), .004));//"ASSISTAN" 
            gly = min(gly,show_text(pos.xz - vec2(-.095,0.985),ivec2(0x43452020, 0x20202020), .004));//"CE      " 
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.247,0.970),ivec2(0x4f425441, 0x494e4142), .004));//"OBTAINAB" 
            gly = min(gly,show_text(pos.xz - vec2(-.182,0.970),ivec2(0x4c452049, 0x4d4d4544), .004));//"LE IMMED" 
            gly = min(gly,show_text(pos.xz - vec2(-.117,0.970),ivec2(0x49415445, 0x4c592020), .004));//"IATELY  " 
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.220,0.940),ivec2(0x4f464649, 0x43455253), .004));//"OFFICERS"
            gly = min(gly,show_text(pos.xz - vec2(-.150,0.940),ivec2(0x26204341, 0x52532020), .004));//"& CARS  "
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.190,0.925),ivec2(0x52455350, 0x4f4e4420), .004));//"RESPOND " 
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.205,0.910),ivec2(0x544f2041, 0x4c4c2043), .004));//"TO ALL C"
            gly = min(gly,show_text(pos.xz - vec2(-.140,0.910),ivec2(0x414c4c53, 0x20202020), .004));//"ALLS    "
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.215,0.885),ivec2(0x50554c4c, 0x20544f20), .006));//"PULL TO "
            gly = min(gly,show_text(pos.xz - vec2(-.115,0.885),ivec2(0x4f50454e, 0x20202020), .006));//"OPEN    "
            
            if(gly < 0.0)
                color = vec4(1);
        }
        
        if(pad > tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)))   color = vec4(0.5,0.5,0.5,1.);//phone handle
        
    
    }
    
        if(pad > cheap_cyl((pos    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005))   color = vec4(0.2,0.15,0.1,1.);//lock
    
    if(inside)
    {
        
        vec3 ipos = pos;
        ipos.y -= 10.;
        ipos.z -= 0.14;
        
        vec2 pl = n_polar(ipos.xy);
        
            
        vec3 tile = vec3(pl,ipos.z);
        
        
        tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;
        
        tile.xy = n_un_polar(tile.xy);
        
        tile.xz = map_hex(2.14*tile.xz) / 2.14;
        
        tile.y -= 7.8;
        
        
        
        
        if(pad > abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1) color = vec4(0.25,0.15,0.1,0.2);//dome
        
        vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);
            
        things.xy = n_un_polar(things.xy);
        
        things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));
        
        things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;
        
        
        things.xz = hex_tile(things.zx);
        
        
        if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)
        {
            if(pad > box(things,vec3(0.4,0.02,0.4))) color = vec4(0.4,0.4,2.0,0.6);//blue hex
            things -= vec3(0.,-0.12,0.6);
            if(pad > box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))) color = vec4(0.1,0.1,0.1,0.9);//hex surounding
        }
        
        vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);
        
        hex.x = abs(hex.x);

        if(pad > cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint
        if(pad > cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint
        
        if(pad > max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z)) color = vec4(3.,1.2,0.4,0.4);//console
        
        if(pad > cap(hex, vec3( 1.4, 3.,0.35), vec3( .30, 4.3,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light
        if(pad > cap(hex, vec3( 1.5, 2.6,0.35), vec3( .37, 0.65,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light
            
    }
    if(pad > box(pos    -vec3( 0.00, 0.00,0.84),  vec3(0.42,0.42,0.76)))   color = vec4(0.6,0.6,0.6,0.1);//tardis not inside inside
    if(pad > box(pos_xx -vec3(0.19,0.425,1.30),  vec3(0.13,0.005,0.15)))   {color = vec4(0.8,0.8,0.8,1.);ns_scale = vec4(0);}//window
    
    
    
    //"normal map"
    nor = normalize(nor +  ns_scale.w * (2.0 * vec3(noise3d2(ns_scale.xyz),0.5) - 1.0));

    
    
    return color;
}

// Function 3015
vec3 raymarch(Ray inputray)
{
    const float exposure = 1e-2;
    const float gamma = 2.2;
    const float intensity = 100.0;
    vec3 ambient = vec3(0.2, 0.3, 0.6) *6.0* intensity / gamma;

    vec3 prevcolour = vec3(0.0, 0.0, 0.0);
    vec3 colour = vec3(0.0, 0.0, 0.0);
    vec3 mask = vec3(1.0, 1.0, 1.0);
    vec3 fresnel = vec3(1.0, 1.0, 1.0);
    
    Ray ray=inputray;
        
    vec3 lightpos = g_light.pos;
    
    for (int i=0; i<REFLECT_ITERATIONS; i++)
    {
        Result result = raymarch_query(ray, 10.0);

        vec3 tolight = lightpos - result.pos;
        tolight = normalize(tolight);
                
        if (result.t > NOT_CLOSE)
        {
            vec3 spotlight = drawlights(ray)*3000.0;
            
//          ambient = texture(iChannel1, ray.dir).xyz*100.0;
            ambient = vec3(0.0);
//            ambient = environment(ray.dir);
                       
            colour += mask * (ambient + spotlight);                             
            break;
        }
        else
        {   
			prevcolour = result.mat.colour.rgb;
            
            vec3 r0 = result.mat.colour.rgb * result.mat.specular;
            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);
            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);
            mask *= fresnel;            
            
            vec3 possiblelighting = clamp(dot(result.normal, tolight), 0.0, 1.0) * g_light.colour
                    * result.mat.colour.rgb * result.mat.diffuse
                    * (1.0 - fresnel) * mask / fresnel;
            
            possiblelighting += environment(reflect(ray.dir, result.normal)) * dot(result.normal, -ray.dir)*0.35;
            
            float falloff = 1.0 - clamp(length(ray.pos)*0.1, 0.0, 1.0);
            possiblelighting *= falloff;
            
            if (length(possiblelighting) > 0.01f)
            {
                Ray shadowray = Ray(result.pos+result.normal*0.01, tolight);
                Result shadowresult = raymarch_query(shadowray, length(lightpos - result.pos)*0.9);
#ifdef SOFTSHADOWS                
                colour += possiblelighting*clamp(shadowresult.mint*4.0, 0.0, 1.0);
#else
                if (shadowresult.travelled >= length(lightpos - result.pos)*0.9)
                	colour += possiblelighting;
#endif
            }
            
            float falloff2 = 1.0 - clamp(length(ray.pos)*0.3, 0.0, 1.0);
            vec3 selfillum = result.mat.selfillum*result.mat.colour.rgb*40.0*clamp(dot(result.normal, -ray.dir), 0.0, 1.0);            
            colour += selfillum*falloff2;
            
            Ray reflectray;
            reflectray.pos = result.pos + result.normal*0.02f;
            reflectray.dir = reflect(ray.dir, result.normal);
            ray = reflectray;
        }
    }
        
    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    
    return colour;    
}

// Function 3016
float rayTetra(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 rd){
    
    vec3 n = normalize(cross(p0 - p1, p0 - p2));
    //vec3 pc = (p0 + p1 + p2)/3.;
    float t = rayPlane(p, p0, n, svRd);
    n = normalize(cross(p0 - p2, p0 - p3));
    //pc = (p0 + p2 + p3)/3.;
    t = min(t, rayPlane(p, p0, n, svRd));
    n = normalize(cross(p0 - p1, p0 - p3));
    //pc = (p0 + p1 + p3)/3.;
    t = min(t, rayPlane(p, p0, n, svRd));
    n = normalize(cross(p1 - p2, p1 - p3));
    //pc = (p1 + p2 + p3)/3.;
    t = min(t, rayPlane(p, p1, n, svRd)); 
    
    return t;//min(t, .5);
}

// Function 3017
vec3 getNormal(in vec3 p, float t) {
	const vec2 e = vec2(.001, 0);
    
    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),
    //map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
    
    // So, what's this mess then? Glad you asked. :) Apparently, if there's a break, things
    // won't get unrolled, so the idea is that this will cut down on the number of unrolled
    // map calls which can add to compile time... As to whether it works or not, I can't say,
    // but it seems to cut compile time down on my machine. If you know of something better,
    // feel free to let me know. In case it needs to be said, from a code perspective, I 
    // do not like this. :)
    float sgn = 1.;
    vec3 n = vec3(0);
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = min(iFrame, 0); i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 3018
vec3 calcNormal( vec3 pos )
{
    vec2 e = vec2(1., -1.) * PR;
    return normalize(e.xyy * map(pos + e.xyy).x + 
					 e.yyx * map(pos + e.yyx).x + 
					 e.yxy * map(pos + e.yxy).x + 
					 e.xxx * map(pos + e.xxx).x );
}

// Function 3019
float resolveRayLightIntersection(sphere sun){
	vec3 OC=sun.pos-camera;
	float P=dot(OC,ray);
	float d=sqrt(pow(length(OC),2.0)+pow(P,2.0));
	return 1./d;
	
}

// Function 3020
vec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)
{
    vec3 F = ref - eye;
    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));
    vec3 U = normalize(cross(R, F));

    vec3 V = U * length(F) * tan(FOVY * 0.5);
    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;

    vec3 p = ref + ndc.x * H + ndc.y * V;

    return normalize(p - eye);
}

// Function 3021
vec3 capNormal(in vec3 pos, in vec3 a, in vec3 b, in float r ) {
    vec3  ba = b - a, pa = pos - a;
    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);
    return (pa - h*ba)/r;
}

// Function 3022
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.02,0.0,0.0);
	return normalize( vec3(
           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),
           0.5*2.0*eps.x,
           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );

}

// Function 3023
vec2 march_ray(vec3 ray_origin, vec3 ray_direction, float tmax) {
	float t = 0.0;//current depth
    float m = 0.0;
    for( int i=0; i<256; i++ )
    {
        vec3 pos = ray_origin + t*ray_direction;
        //get dist to nearest surface
        vec2 h = map_the_world(pos);
        m = h.y;
        //if we hit something break
        if( h.x<0.0001 || t>tmax ) return vec2(t,m);
        //step forward
        t += h.x;
    }
    return vec2(t,m);
}

// Function 3024
vec4 BakeNormalTangentSpace(float theta, float phi) 
{   
    vec3 dir = vec3(sin(theta)*sin(phi), cos(phi), -sin(phi)*cos(theta));
    vec3 ro = dir*10.;	// The ray starts outside the models
    //vec3 ro = vec3(0.,0.,0.);
    Hit hP = RayMarchHighDetailModel(ro, -dir);
    Hit lP = RayMarchLowDetailModel(ro, -dir);

    vec3 N_ts; 
    mat3 M_ts_ws = mat3(lP.binormal,lP.tangent,lP.normal);
    N_ts = inverse(M_ts_ws)*hP.normal;
    return vec4(normalize(N_ts) * 0.5 + 0.5, .1);
}

// Function 3025
vec3 normal(vec3 p){
    vec2 e = vec2(0,0.01);
    float d = world(p);
    return normalize(
        vec3(
        	world(p + e.yxx) - d,
        	world(p + e.xyx) - d,
        	world(p + e.xxy) - d
            )
    );
}

// Function 3026
rayMarchHit GetRayMarchHit(vec3 position, float time) {
    rayMarchHit hit;
    #if defined(DEBUG_USE_SQUARE_DISTANCE)
    hit.distance = RAY_MAX_DISTANCE*RAY_MAX_DISTANCE;
    #else
    hit.distance = RAY_MAX_DISTANCE;
    #endif

    float newDistance = hit.distance;

    vec3 pBlockCenter = position + (0.5*blockSize);
    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0
    vec3 pBlockI = floor(pBlockCenter/blockSize);
    // fraction of distance withinteh grid, -0.5 to + 0.5
    vec3 pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;
    //wold position of the center of the grid, positionGI*blockSize
    vec3 pBlockWI = pBlockI*blockSize;
    // -0.5*blockSize to +0.5*blockSize
    vec3 pBlockWF = pBlockF*blockSize; 

    vec3 pCellWF = mod(pBlockWF+(gridSizeH),gridSize)-gridSizeH;

    //on north/south - -2.5 < mod(x,blockSize) < 2.5
    bool onNorthSouth = (pBlockWF.x >= -gridSizeH && pBlockWF.x <= gridSizeH && (pBlockWF.z < -gridSizeH || pBlockWF.z > gridSizeH) );
    bool onEastWest = (pBlockWF.z >= -gridSizeH && pBlockWF.z <= gridSizeH && (pBlockWF.x < -gridSizeH || pBlockWF.x > gridSizeH) );

    #if defined(DEBUG_RENDER_RAILS)
    //Road Main Beams
    //FIXME: the length of beams *0.8?!?!
    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));
    newDistance = min(newDistance,sdXAlignedCylinder(abs(pBlockWF.zyx)-vec3(2.0,1.0, roadLengthQ - gridSize*0.8 ), roadLength , 0.05 ));

    //Intersection Main Beams
    newDistance = min(newDistance,sdCircle( abs(pBlockWF.xz) - vec2(2.0,2.2), 0.05 ));
    newDistance = min(newDistance,sdCircle( abs(pBlockWF.zx) - vec2(2.0,2.2), 0.05 ));

    //dont crossbrase the road
    if (pBlockWF.y < -gridSizeH || pBlockWF.y > gridSizeH) {
        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));
        newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(2.0,1.5,2.2), vec3(0.0,0.0,2.2),  0.03));
    }

    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));
    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.z, pCellWF.y, pBlockWF.x)) , vec3(0.0,2.5,2.2), vec3(2.0,1.5,2.2), 0.03));

    if (onNorthSouth) {
        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));
        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));
    }

    if (onEastWest) {
        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(2.0,0.0,0), 0.03));
        newDistance = min(newDistance,sdCapsule( abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) , vec3(2.0,1.0,2.5), vec3(0.0,1.0,0), 0.03));
    }

    if (newDistance < hit.distance) {
        hit.origin = position;
        hit.distance = newDistance;
        hit.materialId = MAT_RAIL;
        hit.neon = vec3(0.0);
    }
    #endif

    // Lights
    newDistance = min(newDistance,sdCapsule( abs(vec3(pBlockWF.x, pCellWF.y, pBlockWF.z)) , vec3(2.2,1.25,2.0), vec3(2.0,1.25,2.2), 0.1));

    if (onNorthSouth) {
        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.x, pBlockWF.y, pCellWF.z)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));
    }

    if (onEastWest) {
        newDistance = min(newDistance,sdXAlignedCylinder(abs(vec3(pCellWF.z, pBlockWF.y, pCellWF.x)) -vec3(2.0,1.0,0.0), 0.4, 0.1 ));
    }

    if (newDistance < hit.distance) {
        hit.origin = position;
        hit.distance = newDistance;
        hit.materialId = MAT_NEON;
        hit.neon = roadLightColour*4.0;
    }

    //Buildings.
    //rework the grids so 0,0,0 is the center of the buildings
    pBlockCenter = position;// + vec3(0.0,blockSize*0.5,0.0);

    // position of the cube (-0.5*blockSize to +0.5*blockSize) > 0.0 to 1.0
    pBlockI = floor(pBlockCenter/blockSize);
    // fraction of distance withinteh grid, -0.5 to + 0.5
    pBlockF = ((pBlockCenter/blockSize)-pBlockI)-0.5;

    //wold position of the center of the grid, positionGI*blockSize
    pBlockWI = pBlockI*blockSize;
    // -0.5*blockSize to +0.5*blockSize
    pBlockWF = pBlockF*blockSize; 

    float floorCount=1.0;
    
    float blockHash = hash21(pBlockI.xz)*20.0;
    float buildingFloor = floor(position.y)+floor(blockHash);;
    float round = clamp(fract(blockHash)-0.5,0.05,0.5);
    
    for(float i=-floorCount;i<=floorCount;i++) {
		//pick a random point where the width and width-round are both within a single world space unit,
        //the texturing later snaps to the world grid and if the ends of hte window cross the boundy we get artifacts.
        float windowWigle=valueNoise1du(buildingFloor + i + blockHash)*2.0;
        float baseWidth=floor((roadLength-2.0-windowWigle)*0.5);
        float buildingfloorSize=baseWidth-map(fract(windowWigle)*(1.0-round*2.0), 0.0, 1.0, 0.01, 0.5)-round;
        newDistance = min(newDistance, sdBox(vec3(pBlockWF.x,fract(pBlockWF.y)-i,pBlockWF.z), vec3(buildingfloorSize,0.5-round,buildingfloorSize))-round);
    }

    if (newDistance < hit.distance) {
        hit.origin = position;
        hit.distance = newDistance;
        hit.materialId = MAT_WALL;
        hit.neon = vec3(0.0);
    }

    //Corners
    newDistance = min(newDistance, sdBox( abs(pBlockWF.xz)-(roadLength*0.5)+(gridSize*0.4), vec2(0.5) ) - 0.5 );

    //Mid Beams
    if (abs(pBlockWF.z) < (roadLength*0.5)) {
        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.x)-(roadLength*0.5)+(gridSize*0.2),pCellWF.z), vec2(0.375) ) - 0.125);
    }
    if (abs(pBlockWF.x) < (roadLength*0.5)) {
        newDistance = min(newDistance, sdBox( vec2(abs(pBlockWF.z)-(roadLength*0.5)+(gridSize*0.2),pCellWF.x), vec2(0.375) ) - 0.125);
    }
    if (newDistance < hit.distance) {
        hit.origin = position;
        hit.distance = newDistance;
        hit.materialId = MAT_SOLID;
        hit.neon = vec3(0.0);
    }

    return hit;
}

// Function 3027
float castRay(vec3 ro,vec3 rd,float maxt) 
{
    float precis = 0.001;
    float h = precis * 2.0;
    float t = 0.0;

	for(int i = 0; i < 130; i++) 
	{
        if(abs(h) < precis || t > maxt) break;
		h = map(ro + rd * t);
        t += h;
	}
    return t;
}

// Function 3028
vec3 GetNormal (vec3 p) 
{ 
    vec2 e = vec2(0.01, 0.0); 
    return normalize(vec3(
        map(p+e.xyy).x-map(p-e.xyy).x,
        map(p+e.yxy).x-map(p-e.yxy).x,
        map(p+e.yyx).x-map(p-e.yyx).x
        )); 
}

// Function 3029
float SurfRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, h, s, sLo, sHi;
  dHit = dstFar;
  if (rd.y < 0.) {
    s = - (ro.y - surfHt) / rd.y;
    sLo = s;
    for (int j = VAR_ZERO; j < 160; j ++) {
      p = ro + s * rd;
      h = p.y - SurfHt (p.xz);
      if (h < 0.) break;
      sLo = s;
      s += max (0.2, 0.4 * h);
      if (s > dstFar) break;
    }
    if (h < 0.) {
      sHi = s;
      for (int j = VAR_ZERO; j < 5; j ++) {
        s = 0.5 * (sLo + sHi);
        p = ro + s * rd;
        if (p.y > SurfHt (p.xz)) sLo = s;
        else sHi = s;
      }
      dHit = 0.5 * (sLo + sHi);
    }
  }
  return dHit;
}

// Function 3030
vec3 getNormal (vec3 p) {
    vec2 e = vec2(0.01, 0.0);
    float d = map(p);
    vec3 n = d - vec3( map(p-e.xyy) , map(p-e.yxy) , map(p-e.yyx) );
    return normalize(n);
}

// Function 3031
vec3 calcNormal_2_5(vec3 pos, float eps) {
  const vec3 v1 = vec3( 1.0,-1.0,-1.0);
  const vec3 v2 = vec3(-1.0,-1.0, 1.0);
  const vec3 v3 = vec3(-1.0, 1.0,-1.0);
  const vec3 v4 = vec3( 1.0, 1.0, 1.0);

  return normalize( v1 * geometry( pos + v1*eps ).x +
                    v2 * geometry( pos + v2*eps ).x +
                    v3 * geometry( pos + v3*eps ).x +
                    v4 * geometry( pos + v4*eps ).x );
}

// Function 3032
float raymarch_withphotons( vec3 o, vec3 target, float start_time, out vec4 objPos )
{
    return raymarch( o, target, start_time, 1., objPos );
}

// Function 3033
maybe_float get_distance_along_2d_line_to_ray(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in vec2 B
){
    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0
    vec2 D = B0 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 3034
vec3 transformForReflection(vec3 p, vec3 dir, vec3 refl) {
    float dist = sceneDist(p);

    return p + 2.0 * dist * (dir + refl);
}

// Function 3035
vec3 calcNormal( in vec3 pos )
{
    const float eps = 0.002;             // precision of the normal computation

    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

	return normalize( v1*doModel( pos + v1*eps ) + 
					  v2*doModel( pos + v2*eps ) + 
					  v3*doModel( pos + v3*eps ) + 
					  v4*doModel( pos + v4*eps ) );
}

// Function 3036
vec3 getNormal( in vec3 pos )
{
	// IQ
	vec2 e = vec2( 1.0,-1.0 ) * 0.001;
	return normalize( e.xyy*distFunc( pos + e.xyy ) +
	e.yyx*distFunc( pos + e.yyx ) +
	e.yxy*distFunc( pos + e.yxy ) +
	e.xxx*distFunc( pos + e.xxx ) );
}

// Function 3037
vec3 NormalBlend_Unity(vec3 n1, vec3 n2)
{
    // Unpack
	n1 = n1*2.0 - 1.0;
    n2 = n2*2.0 - 1.0;
    
    mat3 nBasis = mat3(vec3(n1.z, n1.y, -n1.x), // +90 degree rotation around y axis
        			   vec3(n1.x, n1.z, -n1.y), // -90 degree rotation around x axis
        			   vec3(n1.x, n1.y,  n1.z));
	
    return normalize(n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);
}

// Function 3038
float reflectionCoef(float cos_theta, float R0)
{
    return R0 + (1.0 - R0) * pow(1.0 - cos_theta, 5.0);
}

// Function 3039
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float  t = 0., //.05*texelFetch( iChannel0, px&255, 0 ).x; // jitter ray start
          dt = 0.,
         den = 0., _den, lut, dv;
    for(int i=0; i<150; i++) 
    {
        vec3 pos = ro + t*rd;
        if( pos.y < -3. || pos.y > 3. || sum.a > .99 ) break;
        _den = den; den = map(pos); // raw density
        if( abs(pos.x) > .5 )       // cut a slice 
        {
            for (float ofs=0.; ofs<7.; ofs++) 
            {
                dv = (ofs/3.5-1.)*.4; // draw 7 isovalues
                lut = LUTs( _den+dv, den+dv ); // shaped through transfer function
                if (lut>.01)          // not empty space
                { 
                    vec3  col = hue(ofs/8.);
                    col = mix( col , bgcol, 1.-exp(-.003*t*t) ); // fog
                    sum += (1.-sum.a) * vec4(col,1)* (lut* dt*3.); // blend. Original was improperly just den*.4;
            }  }  }
        t += dt = max(.05,.02*t);     // stepping
    }

    return sum; 
}

// Function 3040
vec3 computeSurfaceNormal(vec3 p)
{
    float d = distanceToScene(p);
    
    return normalize(vec3(
        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,
        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,
        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));
}

// Function 3041
vec3 trace_ray( in CAMERA_RAY cam, in vec2 screen_uv )
{
    vec3 color;
    
    if( cam.ray.y > 0.0 )
    {
        color = sky_color(cam);
    }
    else
    {
        vec3 pos = cam.eye;

        if( pos.y > GRASS_BLADE_HEIGHT )
        {
            pos += cam.ray*(pos.y - GRASS_BLADE_HEIGHT) / -cam.ray.y;
        }

        vec3 ray_step = cam.ray / -cam.ray.y * GRASS_FIELD_STEP;

        vec3 right = cam.right;

        vec3 final_color = vec3(0.0, 0.0, 0.0);
        int intersections = 0;
        float coverage = 0.0;

        for( int i=0; i<100 && intersections < 2; ++i )
        {
            for( float k=-2.0; k<=2.1; k += 1.0 )
            {
                if( test_grass_blade( cam, pos + right*k, color ))
                {
                    float dist_coverage_coef = 1.0 - min( length(pos - cam.eye) / 40.0, 1.0 )*0.7;

                    final_color += color; //*(1.0 - coverage)*dist_coverage_coef;
                    coverage = 1.0;

                    coverage += (1.0 - coverage)*0.9 *dist_coverage_coef;
                    intersections++;
                    break;
                }
            }

            if( pos.y < 0.0 ) break;
            pos += ray_step;        
        }

        if(intersections>0)
        {
            final_color *= 1.0/float(intersections);
        }

        final_color += ground_color(cam.eye, cam.ray )*(1.0 - coverage);

        // apply some fog
        float fog_coef = 1.0 - exp( -length(cam.eye - pos) * 0.002);
        final_color = mix( final_color, FOG_COLOR, fog_coef );
    
    	color = final_color;
    }
    return post_process( cam.ray, screen_uv, color );
}

// Function 3042
float MarchShadowRay(vec3 aSamplePos, vec3 aLightPos, float aRand)
{
    vec3 vRD = aLightPos - aSamplePos;
    float vMaxMarchDist = min(SHADOW_FAR, length(vRD));
    vRD = normalize(vRD);
    
    float vTrI = 1.0;
    
    float vNormRandStep = aRand * gcRcpShadowSteps;
    float vP = gcRcpShadowSteps;
    float vD = 0.0;
    float vNextD;
    
    for (int vN = 0; vN < SHADOW_STEPS; ++vN)
    {
        vNextD = pow(vP + vNormRandStep, SHADOW_EXP) * vMaxMarchDist;
        
        float vSS = vNextD - vD;
    	vec3 vPos = aSamplePos + vRD * vD;   

        vec2 vDens = VolumeDensity(vPos);
        float vSampleE = vDens.x + vDens.y;
        float vOpticalDepth = vSampleE * vSS;
        float vTr = exp(-vOpticalDepth);
        if (vPos.y >= 1.5)
        {
            vTr = 0.0;
        }
        
        vTrI *= vTr;
        if (vTrI < 0.00)
        {
            vTrI = 0.0;
            break;
        }
        vD = vNextD; 
        vP += gcRcpShadowSteps;
    }

    return vTrI;
}

// Function 3043
vec3 normal(const in vec3 p)
{  
	vec2 e = vec2(-1.0, 1.0)*0.001;   
	return normalize(e.yxx*f(p + e.yxx) + e.xxy*f(p + e.xxy) +
					 e.xyx*f(p + e.xyx) + e.yyy*f(p + e.yyy));
}

// Function 3044
vec3 calcNormal( vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 n = vec3(
			sdf( pos + eps.xyy ) - sdf( pos - eps.xyy ),
			sdf( pos + eps.yxy ) - sdf( pos - eps.yxy ),
			sdf( pos + eps.yyx ) - sdf( pos - eps.yyx ) );
	return normalize( n );
}

// Function 3045
vec3 NewRay(Cam cam, vec2 tc)
{
    tc.x *= cam.Aspect;

    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);
    
    vec3 dir = normalize(imgPos);

    return dir;
}

// Function 3046
vec3 calcNormal(in vec3 pos){vec3 eps=vec3(.0001,0,0);return normalize(vec3((f(pos+eps.xyy)-f(pos-eps.xyy)).x,(f(pos+eps.yxy)-f(pos-eps.yxy)).x,(f(pos+eps.yyx)-f(pos-eps.yyx)).x));}

// Function 3047
vec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )
{
    float t = tminmax.x;
    float dt = .02;
    //float dt = .2 - .195*cos(iTime*.05);//animated
    vec3 col= vec3(0.);
    vec3 c = vec3( 0.);
    for( int i=0; i<INNER_DEPTH; i++ )
	{
        t+=dt*exp(-2.*length(c));
        if(t>tminmax.y)break;
        //vec3 pos = ro+t*rd;
        vec3 pos = refract( ro, (ro+t*rd)/.7,-.012);
        c = map(pos);//map(ro+t*rd);               
        
        float gr= MILKY_LIGHT*0.013824/float(INNER_DEPTH);//.01*(2.0-float(i)/64.0);
        
        col = .995*col+ .09*c+vec3(gr);//vec3(c*c, c, c*c*c);//green	
        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue
    }    
    return col;
}

// Function 3048
vec3 BSDF_Oren_Nayar_Eval_Reflect(OrenNayarBsdf bsdf, vec3 vDir, vec3 wi, float pdf){
	if(dot(bsdf.nDir, wi) > 0.) {
		pdf = 0.5 * M_1_PI_F;
		return BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);
	}
	else {
		pdf = 0.0f;
		return vec3(0.);
	}
}

// Function 3049
vec3 GetNormal(vec3 p, float iTime)
{
    const vec2 delta = vec2(MIN_DIST, 0.);
    
    vec3 n = GetSceneDist(p, iTime) - vec3(
        GetSceneDist(p - delta.xyy, iTime),
        GetSceneDist(p - delta.yxy, iTime),
        GetSceneDist(p - delta.yyx, iTime)
    );
    
    return normalize(n);
}

// Function 3050
vec3 trace_reflection(vec3 origin, vec3 n_direction, inout float travelled_distance_in_air)
{
    vec3 point_of_intersection;
    vec3 reflection = trace_ray(origin, n_direction, point_of_intersection);       

    travelled_distance_in_air += distance(origin, point_of_intersection);
    reflection = apply_fog(reflection, travelled_distance_in_air,
                           fog_air_color, fog_air_extinction_coefficient);
    return(reflection);
}

// Function 3051
vec4 calcNormal( in vec4 pos ){
        	return normalize(vec4(
        	    map(pos+eps.xyyy).x - map(pos-eps.xyyy).x,
        	    map(pos+eps.yxyy).x - map(pos-eps.yxyy).x,
        	    map(pos+eps.yyxy).x - map(pos-eps.yyxy).x,
        		map(pos+eps.yyyx).x - map(pos-eps.yyyx).x
        	));
        }

// Function 3052
vec3 evaluateReflection(vec3 pos, vec3 normal)
{
    vec3 viewDir = normalize(cameraPos - pos);
    float nvDot = dot(normal, viewDir);
    vec3 lightDir = reflect(-viewDir, normal);
    
    float fresnel = evaluateSchlickFresnel(nvDot);
    float refl = mix(0.03, 1., fresnel);
    float roughness = 0.2;
    
    refl *= evaluateBeckmannGeometryShadowingSingleSide(nvDot, roughness);
    
    return refl * sampleBackground(lightDir).xyz;
}

// Function 3053
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(map(pos+eps.xyy) - map(pos-eps.xyy),
        			map(pos+eps.yxy) - map(pos-eps.yxy),
        			map(pos+eps.yyx) - map(pos-eps.yyx) );
	return normalize(nor);
}

// Function 3054
vec2 get_reflection_uv(vec3 p, vec3 n_reflection)
{
    const float reflection_distane = 1.0;
    
    p += n_reflection * reflection_distane;
    return(compute_uv(normalize(p - cubemap_origin)));
}

// Function 3055
float castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col )
{
    uv = vec2(0.);
    
    float rt = DIST_MAX;
    for( int i = 0; i < QUAD_COUNT; i++ )
    {
        vec2 uvi; float rti;
        if( rayQuadUV( ro, rd, quads[i].p, quads[i].n, quads[i].scl, uvi, rti ) 
          && rti < rt )
        {
            uv = quads[i].uv_c + (uvi-.5)*quads[i].uv_wh;
            col = GetColor(quads[i].col);
            rt = rti;
        }
    }
    
    return rt;
}

// Function 3056
vec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {
    vec2 m = vec2(-1.0, -1.0);
    vec2 res = vec2(tmin, -1.0);
    res.x = tmin;
	for( int i=0; i<NUM_STEPS; i++ )
	{
        m = mapRM(ro + res.x*rd);
		if( m.x<tmin || res.x>tmax ) break;
		res.x += 0.5*m.x*log(1.0+float(i));
        res.y = m.y;
	}
    if( res.x>tmax ) res.y=-1.0;
	return res;
}

// Function 3057
vec3 getnormal(vec3 p) {
  vec4 p4 = A*vec4(p,1);
  return normalize(eyesign*transpose(mat3x4(A))*grad(p4));
}

// Function 3058
vec3 getNormal(vec3 p){
    
    float d = map(p);
    vec2 e = vec2(0.001,0.);
    
    vec3 n = d - vec3(
            map(p-e.xyy),
            map(p-e.yxy),
            map(p-e.yyx));
            
    return normalize(n);
}

// Function 3059
vec3 ray_march(vec3 p, vec3 r)
{
    float td = 0.;
    int i;
    for(i = 0; i < MAX_MARCHES; i++)
    {
    	float de = map(p);
        if(de < rayfov*td || td > MAX_DIST)
        {
            break;
        }
        p += de*r;
        td += de;
    }
    vec3 col =sdcolor(p);
    if(td > MAX_DIST || i > MAX_MARCHES)
    {
        col = sky_color(r);
    }
    else
    {
        vec4 norm = calcNormal(p,MIN_DIST);
        p += r*(norm.w-rayfov*td);
        #ifdef SHADOWS
      		float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);
        #else
        	float shad = 1.;
        #endif
        
        col = lighting(vec4(col,0.), vec2(0.2,0.3), vec4(p, 0.), vec4(r, td), norm, shad);
    }
   
    return col;

}

// Function 3060
bool rayHitSphere( in vec3 ro, in vec3 rd, vec3 spC, float spR, out float dist, out vec3 norm )
{
	vec3 oc = ro - spC;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - spR * spR;
	float h = b*b - c;
	if( h < 0.0 ) return false;
	dist = -b - sqrt( h );
	if ( dist < 0.0 ) return false;
	norm = normalize( ro + rd * dist - spC );
	return true;
}

// Function 3061
Ray initRayToDirection(vec3 origin, vec3 direction) {
    Ray ray;

    // Init ray values
    ray.direction = direction;

    ray.origin = origin + ray.direction * EPSILON;
    ray.position = origin;

    return ray;
}

// Function 3062
int castRay(vec3 o, vec3 r, inout vec3 n, inout vec3 p)
{
    // Setup variables
    vec3 col = vec3(0.0);
    int rn = 0;
    
    // Initialise normal vector and distance
    n = vec3(0.0);
    float t = BIG_NUMBER;

    // Calculate intersection
    int i = intersect(o, r, t, n);
    
    // Setup the point
    p = o + r * t;
    
    // Return colour
    return i;
}

// Function 3063
vec3 getNormal(in vec3 p) {
    vec2 e = vec2(0.001, 0.0);
    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),
                          mapScene(p + e.yxy) - mapScene(p - e.yxy),
                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));
}

// Function 3064
vec3 ray_interpolation(Ray r, float t) 
{
 	return (r.origin + r.dir*t);   
}

// Function 3065
vec3 CubemapRayDir(in vec2 fragCoord) 
{
    vec2 t = fragCoord.xy*vec2(4.0, 2.0) / iResolution.xy;
    vec3 n = CubemapNormal(floor(t));
    
    float g = 4.0 / iResolution.x;
    float vo = iResolution.x*0.5 - iResolution.y;
    
    vec2 xzp = fract(min(vec2(4.0, 0.99999), fragCoord.xy * g));
    
    vec2 ypp = vec2(min(0.99999, fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));
    vec2 ypn = vec2(max(3.0,     fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));
    vec2 yp = fract(ypp * step(-0.5, n.y) + ypn * (1.0 - step(-0.5, n.y)));
    
    vec2 p = (xzp * (1.0 - abs(n.y)) + yp * abs(n.y)) - 0.5;
    
    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * abs(n.x);
    vec3 py = vec3(p.x*n.y, 0.5*n.y, -p.y) * abs(n.y);
    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);
    
   	vec3 rd = px + py + pz; 
    return normalize(rd);
}

// Function 3066
vec3 normal(in vec3 pos)
{
  vec3  eps = vec3(.0001,0.0,0.0);
  vec3 col;
  float ref;
  float trans;
  vec3 nor;
  vec3 absorb;
  nor.x = distanceField(pos+eps.xyy, col, ref, trans, absorb) - distanceField(pos-eps.xyy, col, ref, trans, absorb);
  nor.y = distanceField(pos+eps.yxy, col, ref, trans, absorb) - distanceField(pos-eps.yxy, col, ref, trans, absorb);
  nor.z = distanceField(pos+eps.yyx, col, ref, trans, absorb) - distanceField(pos-eps.yyx, col, ref, trans, absorb);
  return normalize(nor);
}

// Function 3067
vec3 ray_dir(float fov, vec2 size, vec2 pos) {
	vec2 xy = pos - size * 0.5;
	float cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);	
	float z = size.y * 0.5 * cot_half_fov;
	return normalize(vec3(xy, -z));
}

// Function 3068
vec4 raytraceBlackHole(inout vec3 worldVector){
    vec3 position = worldVector;
    
    bool hit = true;
    
    float schwarzchildradius = calculateSchwarzchildradius(mass);
    
    float d = 0.0;
    
    for (int i = 0; i < steps; ++i){
		float m = distFieldBlackHole(position);
        d += m;
        
        vec3 gravitationalDirection = normalize(position - circlePos);
        float gravity = calcGravity(mass, m);
        worldVector -= gravitationalDirection * gravity;
        worldVector = normalize(worldVector);
        
        if (m < schwarzchildradius) hit = false;
        if (d > 1e16) break;
        
        position += worldVector * (m - (schwarzchildradius * 0.999999));
    }
    
    return vec4(position, float(hit));
}

// Function 3069
bool rayAABBIntersection( in Ray ray, vec3 pmin, vec3 pmax, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    vec3 OMIN = ( pmin - ray.origin ) / ray.dir;
    vec3 OMAX = ( pmax - ray.origin ) / ray.dir;
    vec3 MAX = max ( OMAX, OMIN );
    vec3 MIN = min ( OMAX, OMIN );
    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );
    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );
    
    if ( t1 <= t ) {
        return false;
    } else {
        if( !forShadowTest ) {
            vec3 p = ray.origin + ray.dir*t;
            vec3 dim = pmax - pmin;

            if( EQUAL_FLT( p.x, pmin.x, EPSILON ) ) {
                isect.normal_  =  vec3( -1.0, 0.0, 0.0 );
                isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
                isect.uv_ = (p.zy - pmin.zy) / dim.zy;
            } else if( EQUAL_FLT( p.x, pmax.x, EPSILON ) ) {
                isect.normal_  =  vec3( 1.0, 0.0, 0.0 );
                isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
                isect.uv_ = (p.zy - pmin.zy) / dim.zy;
            } else if( EQUAL_FLT( p.y, pmin.y, EPSILON ) ) {
                isect.normal_  =  vec3( 0.0, -1.0, 0.0 );
                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
                isect.uv_ = (p.xz - pmin.xz) / dim.xz;
            } else if( EQUAL_FLT( p.y, pmax.y, EPSILON ) ) {
                isect.normal_ =  vec3( 0.0, 1.0, 0.0 );
                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
                isect.uv_ = (p.xz - pmin.xz) / dim.xz;
            } else if( EQUAL_FLT( p.z, pmin.z, EPSILON ) ) {
                isect.normal_  =  vec3( 0.0, 0.0, -1.0 );
                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
                isect.uv_ = (p.xy - pmin.xy) / dim.xy;
            } else if( EQUAL_FLT( p.z, pmax.z, EPSILON ) ) {
                isect.normal_  =  vec3( 0.0, 0.0, 1.0 );
                isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
                isect.uv_ = (p.xy - pmin.xy) / dim.xy;
            }
            isect.position_ = p;
            isect.uv_ /= 2.0;
        }

        return true;
    }
}

// Function 3070
vec3 SceneNormal(vec3 pos)
{
    vec2 eps = vec2(0.001, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy) - Scene(pos - eps.xyy),
                          Scene(pos + eps.yxy) - Scene(pos - eps.yxy),
                          Scene(pos + eps.yyx) - Scene(pos - eps.yyx)));
}

// Function 3071
vec3 shpere_get_normal(sphere_shape shpere, vec3 position)
{
    return normalize(position - shpere.position);
}

// Function 3072
vec3 normal3d(RayHit h)
{
  vec3 pos = h.pos;
  vec3 eps = vec3(.1,0.0,0.0);
  vec3 nor;
  float ref;
  nor.x = mapDistance(pos+eps.xyy).distanceRadius - mapDistance(pos-eps.xyy).distanceRadius;
  nor.y = mapDistance(pos+eps.yxy).distanceRadius - mapDistance(pos-eps.yxy).distanceRadius;
  nor.z = mapDistance(pos+eps.yyx).distanceRadius - mapDistance(pos-eps.yyx).distanceRadius;
  return -normalize(nor);
}

// Function 3073
float myNormalize(float val, float minval, float maxval){
	return (val - minval)/(maxval - minval);
}

// Function 3074
bool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, out float t, out SurfaceHitInfo isect ) {
	float phi;
	vec3 phit;
	float t0, t1;
    
	if (!iCylinder(r, radius, t0, t1))
		return false;

    if ( t1 < 0.0 )
        return false;
    
	t = t0;
    
	if (t0 < 0.0)
		t = t1;

	// Compute cylinder hit point and $\phi$
	phit = r.origin + r.dir*t;
	phi = atan(phit.y,phit.x);
    phi += PI;
    
	if (phi < 0.0)
        phi += TWO_PI;
 
	// Test cylinder intersection against clipping parameters
	if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {
		if (t == t1)
            return false;
		t = t1;
		// Compute cylinder hit point and $\phi$
		phit = r.origin + r.dir*t;
		phi = atan(phit.y,phit.x);
        phi += PI;

		if ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )
			return false;
	}
    
    isect.position_ = phit;
    isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );
    
	return true;
}

// Function 3075
vec3 seaGetNormal(const in vec3 p, const in float eps) {
    vec3 n;
    n.y = seaMapHigh(p);    
    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;
    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;
    n.y = eps;
    return normalize(n);
}

// Function 3076
Hit RayMarchLowDetailModel(vec3 ro, vec3 dir) 
{
    vec3 P = vec3(0.,0.,0.);
    float t = 0.;
    while(t < MAX_MARCHING_DISTANCE) 
    {
        P = ro + t*dir;
        Hit hit = SD_LowDetailModel(P);
        if((hit.d)<0.01) 
    	{
            hit.normal = normalLowDetailModel(P);
            hit.tangent = tangent(hit.normal);
            hit.binormal = normalize(cross(hit.normal, hit.tangent));
			return hit;
        }
        t+=hit.d;
    }
    return Hit(-1, MAX_MARCHING_DISTANCE,vec3(0.),vec3(0.),vec3(0.),vec3(0.));
}

// Function 3077
vec4 QuadRay(vec2 p, vec2 d, float CurrentLayer) {
    vec4 Info0=texture(iChannel0,vec2(SimRes+1.5,0.5)*IRES);
    vec2 IDir=1./d; float FAR,Ldist; float dist=0.;
    vec2 bb=box(p,IDir,vec2(0.5),vec2(SimRes-0.5));
    if (bb.x>0. && bb.y>bb.x) {
        FAR=bb.y;
    	dist=bb.x+0.01;
    } else
        return vec4(0.);
 	float LFar=FAR; vec2 cp,fp,lfp; vec4 C,LC;
    float LOD=LODS;
    float LS=pow(2.,LOD);
    float ILS=pow(0.5,LOD);
    //Layer ray tracing
    vec4 Color=vec4(0.);
    float CLayer=0.;
    bool INSIDE=false;
    for (int i=0; i<256; i++) {
        if (dist>FAR) break;
        if (dist>LFar && LOD<LODS) {
            LOD=LOD+1.;
            LS*=2.;
            ILS*=0.5;
            fp=floor(cp*ILS)*LS;
            LFar=boxfar(p,IDir,fp,fp+LS);
        }
        cp=p+d*dist;
        fp=floor(cp*ILS)*LS;
        C=((LOD==0.)?texture(iChannel0,(fp+0.5)*IRES):
           texture(iChannel1,(fp*ILS+vec2(SimRes*(1.-pow(0.5,LOD-1.)),0.)+0.5)*IRES));
        if ((!INSIDE && C.w>0.) || (INSIDE && C.w<1.)) {
            if ((!INSIDE && LOD==0.) || (INSIDE && LOD==0. && C.w==0.)) {
                if (CLayer==CurrentLayer) {
                    if (INSIDE) {
                        if (LC.x>1.) return vec4(LC.xyz-1.,Ldist);
                        else if (Info0.y>0.)
                            return vec4(texture(iChannel2,(fp+0.5)*IRES).xyz*LC.xyz,Ldist);
                        else return vec4(0.,0.,0.,Ldist);
                    } else {
                        if (C.x>1.) return vec4(C.xyz-1.,dist);
                        else if (Info0.y>0.)
                            return vec4(texture(iChannel2,(lfp+0.5)*IRES).xyz*C.xyz,dist); //Problem
                        else return vec4(0.,0.,0.,dist);
                    }
                }
                CLayer=CLayer+1.;
                INSIDE=!INSIDE;
                dist+=2.;
            } else if (LOD>0.) {
                LOD-=1.;
                LS*=0.5;
                ILS*=2.;
                LFar=boxfar(p,IDir,fp,fp+LS*2.);
                continue;
            }
        }
        Ldist=dist;
        dist+=boxfar(cp,IDir,fp,fp+LS)+0.001;
        LC=C;
        lfp=fp;
    }
    return vec4(SkyColor(d),RayFAR);
}

// Function 3078
float castRayAO( in vec3 ro, in vec3 rd)
{
    float tmin = 0.1;
    
    float t = tmin;
    float precis = 0.005;
    for( int i=0; i<MAXDEPTH; i++ )
    {
        float res = map( ro+rd*t );
        if( res<precis  ) 
        {
#if MINWEIGHTMODE>1
        return max(res, 0.0);
#elif MINWEIGHTMODE>0
        return 1. / max(t, 1.001);
#else
        return max(t, 0.0);
#endif
        }

        t += res;
    }
#if WEIGHTMODE>0
    return 1. / max(t, 0.001);
#else
    return 1. / max(t, 1.001);
#endif

}

// Function 3079
vec3 getNormal(vec3 p){
    vec3 n = vec3(0.0);
    int id;
    for(int i = ZERO; i < 4; i++){
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*getSDF(p+e*EPSILON, id);
    }
    return normalize(n);
}

// Function 3080
vec3 getNormal(vec3 p, float d)
{
    vec3 n;
    n.y = water(p);    
    n.x = water(p + vec3(d,0,0)) - n.y;
    n.z = water(p + vec3(0,0,d)) - n.y;
    n.y = d;
    return normalize(n);
}

// Function 3081
vec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {
    // dithering	
	float t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;
	
    // raymarch	
	vec4 sum = vec4( 0.0 );
	for( int i=0; i<64; i++ ) {
		if( sum.a > 0.99 || t > maxdist ) continue;
		
		vec3 pos = ro + t*rd;
		float a = cloudMap( pos, ani );

        // lighting	
		float dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);
		vec4 col = vec4( (1.+dif)*fgc, a );
		// fog		
	//	col.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );
		
		col.rgb *= col.a;
		sum = sum + col*(1.0 - sum.a);	

        // advance ray with LOD
		t += (0.03*CLOUDSCALE)+t*0.012;
	}

    // blend with background	
	sum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );
	
	return clamp( sum.xyz, 0.0, 1.0 );
}

// Function 3082
bool RayIntersectAABoxNormal (vec3 boxMin, vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)
{
    vec3 boxCenter = (boxMin+boxMax)*0.5;
	vec3 roo = rayPos - boxCenter;
    vec3 rad = (boxMax - boxMin)*0.5;

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),
                 min( min( t2.x, t2.y ), t2.z ) );
    
    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)
    if (time.x > maxTime)
        return false;
    
    // if time invalid or we hit from inside, bail out
    if (time.y < time.x || time.x < 0.0)
        return false;
	
    // calculate surface normal
    hitPos = rayPos + rayDir * time.x;   
    vec3 hitPosRelative = hitPos - boxCenter;
    vec3 hitPosRelativeAbs = abs(hitPosRelative);
    vec3 distToEdge = abs(hitPosRelativeAbs - rad);

    float closestDist = 1000.0;
    for(int axis = 0; axis < 3; ++axis)
    {
        if (distToEdge[axis] < closestDist)
        {
            closestDist = distToEdge[axis];
            normal = vec3(0.0);
            if (hitPosRelative[axis] < 0.0)
                normal[axis] = -1.0;
            else
                normal[axis] = 1.0;
        }
    }        

    // store the collision time as the new max time
    maxTime = time.x;
    return true;
}

// Function 3083
vec4 castRayUFO(in vec2 fragCoord) {
	vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;
    vec3 ray_orig = vec3(0.0, 0.5, -5.0);
	vec3 ray_dir = normalize(vec3(uv, 5.0));
    
    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;
    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));
    float ct = sin(wiggle);
    float st = cos(wiggle);
    mat3 twist = mat3(ct, 0.0, st,
                      0.0, 1.0, 0.0,
                      -st, 0.0, ct);
    ray_dir = twist * ray_dir;
    ray_orig = twist * ray_orig;
    wiggle = 0.1 * sin(iTime);
    ct = cos(wiggle);st = sin(wiggle);
    twist = mat3(ct, st, 0.0,
                 -st, ct, 0.0,
                 0.0, 0.0, 1.0);
    wiggle = 0.1 * sin(0.71 *iTime + 1.3);
    ct = cos(wiggle);st = sin(wiggle);
    twist *= mat3(1.0, 0.0, 0.0,
                  0.0, ct, st,
                 0.0, -st, ct);

    ray_dir = twist * ray_dir;
    ray_orig = twist * ray_orig;
    
    ray_orig = ray_orig - vec3(0.0, 0.2, 0.0) -
        sin(vec3(4.2, 1.2, 3.4) * iTime) * vec3(0.5, 0.1, 0.2);
    float closeness = MAX_DIST;
    float d = cast_to_vehicle2(ray_orig, ray_dir, closeness);
    
    vec3 ray_mul = vec3(1.0);
    if (d < MAX_DIST) {
        vec3 pt = ray_orig + d * ray_dir;
        float edginess = 0.0;
        ray_dir = get_bounce2(pt, ray_dir, edginess);
        ray_mul = mix(vec3(1.0, 0.9, 0.85), ray_mul, edginess);
    }

    vec3 thump = vec3(texture(iChannel0, vec2(0.0, 0.0)).r,
                      texture(iChannel0, vec2(0.5, 0.0)).r,
                      texture(iChannel0, vec2(1.0, 0.0)).r);
#if INTENSE_FLASH
    thump *= 0.5 + 0.75 * smoothstep(vec3(0.0), vec3(1.0), thump);
#else
    thump *= 0.85 + 0.15 * smoothstep(vec3(0.0), vec3(1.0), thump);
#endif
    float darken = 0.15 * (1.0 + 3.0 * smoothstep(1.5, 0.5, dot(thump, vec3(1.0))));
    return vec4(SKY_BRITE * darken * ray_mul * sky_color(ray_dir) +
                (0.25 + 1.75 * smoothstep(0.05, 0.8, thump))
                * falloff(closeness, 0.5), 1.0);
}

// Function 3084
void calcRayForPixel( in vec2 pix, in float fl, out vec3 resRo, out vec3 resRd )
{
	vec2 p = (2.0*pix-iResolution.xy) / iResolution.y;
	
    // camera movement	
	vec3 ro, ta;
	calcCamera( ro, ta );
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + fl*ww );
	
	resRo = ro;
	resRd = rd;
}

// Function 3085
bool VoxelRayCast(vec3 rp, vec3 rd, /**/ out vec3 vp, out vec3 n, out float t)
{
	vec3 pos = floor(rp);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 off = (-rp + (rs * 0.5 + 0.5)) * ri;

	vec3 mm = vec3(0.0);
    
	if(map(pos)) { t = 0.0; n = vec3(0.0); vp = pos; return true; }
    
	bool hit = false;
	for(int i = 0; i < 128; i++) 
	{        
        vec3 dis = pos * ri + off;

        mm = minmask(dis);
            
        pos += mm * rs;
        
		if(map(pos)) { hit = true; break; }
	}
	
    // intersect the cube	
    vec3 mini = (pos - rs) * ri + off;   
	t = max(mini.x, max(mini.y, mini.z));

	n = -mm * rs;
	vp = pos;

	return hit;
}

// Function 3086
vec2 castRay(in vec3 ro, in vec3 rd)
{
    float tmin = 1.0;
    float tmax = 20.0;
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<200; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( abs(res.x)<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 3087
vec4 GetNormalizedQuarticConstants(Spline s, FactorsOfP fp, vec3 p)
{
	vec4 ret;
	ret.x = s.quartic_a;
	ret.y = s.quartic_b;
	ret.z =	fp.G_1_plus_p_dot_G_1_p * s.oo_G_4;
	ret.w = fp.G_0_plus_p_dot_G_0_p * s.oo_G_4;
	return ret;
}

// Function 3088
vec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)
{   
    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);
    vec3 rayHitDiffuse = vec3(1.0);
    vec3 additiveColor = vec3(0.0);
    
    vec3 ret = vec3(0.0);
           
    // see if we've hit the platform and remember if we have
    vec2 uv;    
    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);
    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)
    {
        bestRayHitInfo = rayInfo;
        rayHitDiffuse = Checkerboard(uv);
    }
    
    // if we've hit the main object, and it's closer than the platform
    rayInfo = RayIntersectObject(rayPos, rayDir);
    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)
    {       
        // light the surface of the ball a bit
        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);
        
        // move the ray to the intersection point
        rayPos += rayDir * rayInfo.x;    
        
        // calculate how much to reflect or transmit (refract or diffuse)
        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);
        float refractMultiplier = 1.0 - reflectMultiplier;
        
        // get reflection color
        #if DO_REFLECTION
        	vec3 reflectDir = reflect(rayDir, rayInfo.yzw);
        	ret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;
        #endif
        
        // get refraction color
        #if DO_REFRACTION
        	vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);
        	ret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;
        #endif
        
        return ret + additiveColor;
    }
    // else we missed the object, so return either the skybox color, or the platform color, as appropriate
    else
    {
        if (bestRayHitInfo.x == 1000.0)    
            return texture(iChannel0, rayDir).rgb;
        else
        {
            // move the ray to the intersection point (so we can shadow) and light the pixel
        	rayPos += rayDir * bestRayHitInfo.x;    
            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    
        }
    }
}

// Function 3089
vec3 rayPoint(Ray r,float t) {
 	return r.origin +  t*r.direction;
}

// Function 3090
vec3 normal(vec3 p) {
    vec2 q = vec2(0., EPS);
    return normalize(vec3(mapH(p+q.yxx) - mapH(p-q.yxx),
                		  mapH(p+q.xyx) - mapH(p-q.xyx),
                		  mapH(p+q.xxy) - mapH(p-q.xxy)));
}

// Function 3091
float pReflect(inout vec3 p, vec3 planeNormal, float offset) 
{
	float t = dot(p, planeNormal)+offset;
	if (t < 0.) {
		p = p - (2.*t)*planeNormal;
	}
	return sgn(t);	//return sign(t); Changed in third version - wjb
}

// Function 3092
vec3 normalEstimation(vec3 pos){
  vec2 k = vec2(MinDist, 0);
  return normalize(vec3(sdf(pos + k.xyy) - sdf(pos - k.xyy),
	  					sdf(pos + k.yxy) - sdf(pos - k.yxy),
  						sdf(pos + k.yyx) - sdf(pos - k.yyx)));
}

// Function 3093
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.005,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy) - map(pos-eps.xyy),
           map(pos+eps.yxy) - map(pos-eps.yxy),
           map(pos+eps.yyx) - map(pos-eps.yyx) ) );
}

// Function 3094
vec3 Normal(vec3 p)
{
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*Scene(p+0.0005*e).x;
    }
    return normalize(n);
}

// Function 3095
vec3 normal (vec3 p)
{
    return normalize(vec3(
        dist3D(p + vec3(0.01,0,0)) - dist3D(p - vec3(0.01,0,0)),
        dist3D(p + vec3(0,0.01,0)) - dist3D(p - vec3(0,0.01,0)),
        dist3D(p + vec3(0,0,0.01)) - dist3D(p - vec3(0,0,0.01))
    ));
}

// Function 3096
float reflection(vec3 eye, vec3 rayPos, vec3 n, vec3 lightDir)
{
    float rVal = 0.0;  //reflection boolean value: 0 = miss, 1 = hit
    vec3 refVec = normalize(reflect(-eye, n)); //normalized reflection vector
    float rEPS = 0.01; //reflection EPSILON
    vec3 ro = rayPos + (n * rEPS);// starts marching slightly "above" our surface to lessen artifacts
    vec3 rd = refVec;
    float rDist; //initializing reflection distance value. This gets plugged into the scene function
    float rShadowVal = 1.0;
    for(int i = 0; i < 24; i++)
    {
        rDist = scene(ro);
        if(rDist < rEPS)
        {
            
          float rDiffuseVal = max(dot(normal(ro), lightDir), 0.0);
            if(rDiffuseVal > 0.0) //then we calculate reflection shadow ray
            {
              rShadowVal = shadow(ro, lightDir, normal(ro));
            }
            
            rVal = rDiffuseVal * rShadowVal;
            break;
        }
        ro += rd * rDist;
    }
        
    return rVal;
        
}

// Function 3097
vec2 sceneNormal(vec2 p) {
    float e = 0.00001;
    float dx = scene(p-vec2(e,0.0)) - scene(p+vec2(e,0.0));
    float dy = scene(p-vec2(0.0, e)) - scene(p+vec2(0.0,e));
    return normalize(vec2(dx,dy));
}

// Function 3098
vec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){
    float 	focal = .5;
    vec3 ww = normalize( camTarget - pos);
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;
    vec3 vv = cross(uu,ww);
	return normalize( st.x*uu + st.y*vv + focal*ww );
}

// Function 3099
vec3 UniformUnitShpereRay(float x1,float x2){
	float theta = PI * x1;
    float phi   = TWO_PI * x2;
    float sinTheta = sin(theta);
    return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cos(theta));
}

// Function 3100
Hit RayMarch(vec3 ro, vec3 rd, int bounce){
	float dO = 0.;
    Hit hit;
    
    int steps = MAX_STEPS;
    
    if(bounce > 0){
        steps /= bounce*4;
    }
    
    for(int i = 0; i < steps; i++){
        vec3 p = dO*rd+ro;
        hit = GetDist(p);
        dO += hit.d;
        if(hit.d < SURFACE_DIST || dO > MAX_DIST){
            break;
        }
    }
    return Hit(dO, hit.ID);
}

// Function 3101
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*precis;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
}

// Function 3102
vec3 normal(vec3 p) {
    /** Normal vector
    This is pretty inefficient since it needlessly computes colors.
    I don't really like it, but it works...
    */

    // The direction of the normal is given by the gradient of the
    // distance function (direction where distance increases fastest).
    return normalize(vec3(
        scene(vec3(p.x + DEPS, p.yz)).dist - scene(vec3(p.x - DEPS, p.yz)).dist,
        scene(vec3(p.x, p.y + DEPS, p.z)).dist - scene(vec3(p.x, p.y - DEPS, p.z)).dist,
        scene(vec3(p.xy, p.z + DEPS)).dist - scene(vec3(p.xy, p.z - DEPS)).dist
    ));
}

// Function 3103
bool MarchShadowRay( vec3 start, vec3 dir, out vec3 pos CACHEARG )
{
    // Same as MarchCameraRay except lower tolerances because artifacts will barely be noticeable,
    // and we don't care about hit pos being accurate.
    // Caller should check bounds because sometimes we want to call this when we already know we're inside the bounds.
    
    pos = start + dir * SHADOW_EPSILON;
    
    float prevMarchDist = SHADOW_EPSILON;
    float prevSurfaceDist = BlobDist( start CACHE );
    
    for ( int i = 0; i < MAX_SHADOW_RAYMARCH_STEPS; i++ )
    {
        float surfaceDist = BlobDist( pos CACHE );
        if ( surfaceDist <= EPSILON )
            return true;
        
        float gradientAlongRay = (prevSurfaceDist - surfaceDist) / prevMarchDist;
        float safeGradient = max( gradientAlongRay, MIN_GRADIENT_FOR_SHADOW_RAYS );
        
        float addDist = (surfaceDist + SHADOW_EPSILON) / safeGradient;
        prevMarchDist = addDist;
        
        prevSurfaceDist = surfaceDist;
        pos += dir * addDist;

        vec3 relPos = pos - BLOB_BOUNDING_CENTER;
        relPos *= BLOB_BOUNDING_SCALE;
        if ( dot( relPos, relPos ) > BLOB_BOUNDING_RADIUS_SQR )
            return false;
	}
    
    return true;
}

// Function 3104
vec4 castRay(vec3 ro, vec3 rd)
{
	gTexelSize    = 1. / iResolution.xy;
	gTexelRadius  = length(gTexelSize) ;
    
    float t   = kNearPlaneDist, stepLength = 0., prevRad = kFarPlaneDist, prevErr = kFarPlaneDist, err, k = 1.2;
    vec2  res = vec2(kFarPlaneDist, 0);
	int   r   = kMaxSteps;
    for (int i = 0; i < kMaxSteps; ++i)
    {
        if (i < 0) break;
        if (t >= kFarPlaneDist) break;
        res = map(ro + rd * t);
        bool  sor = (k > 1.) && ((prevRad + res.x) < stepLength);
        if (sor)
        {
            stepLength-= k * stepLength;
            k = 1.;            
        }        
        else
            stepLength = res.x * k;

        prevRad = res.x;
        err = res.x / t;
        if (!sor)
        {
            if (err < prevErr     ) { res.x = t; prevErr = err; }
            if (err < gTexelRadius) break;
        }
        t  += stepLength;
    }
    return vec4(t, res.xy, kMaxSteps - r);
}

// Function 3105
vec3 getBRDFray(vec3 n, float seed)
{
    float u = hash(78.233 + seed);
    float v = hash(10.873 + seed);

    float theta = 6.283185 * v; //2pi*v
    u = 2.0*u - 1.0;
    vec3 sph_point = vec3(sqrt(1.0 - u*u) * vec2(cos(theta), sin(theta)), u);

    return normalize(n + sph_point);
}

// Function 3106
vec3 getNormal(Camera c,vec3 pos, float index){
    vec3 n;
    if(index <= float(PLANE_NB)){
        n = normalize( getObject(index).xyz );
        if(dot(n,c.e) <0.){
            n = -n;
        }
    }else{
       	n = normalize( pos - getObject(index).xyz );
    }
    return n;
}

// Function 3107
vec2 sampleRay(vec3 ro, vec3 rd)
{
    vec2 energy = vec2(0);
    vec2 spectrum = vec2(1.);

    vec3 ln = normalize(cross(ls, lt));
    float lightArea = length(ls) * length(lt);

    for(int i = 0; i < 3; ++i)
    {
        vec3 n, p0, p1, uvw;
        vec2 res = traceScene(ro, rd, n, uvw);
        vec3 rp = ro + rd * res.x;
        
        if(res.x < 0. || res.x > 1e3)
            break;
        
        vec3 lrd = lambertNoTangent(n, vec2(rand(), rand()));
        
        if(res.y < .5)
        {
            // No intersection.
            break;
        }
        else if(res.y < 1.5)
        {
            // Diffuse box 1.
            if(rp.y > .999)
                spectrum *= .5;
            else
                spectrum *= mats;
            ro = rp + n * 1e-4;
            rd = lrd;
        }
        else if(res.y < 2.5)
        {
            // Diffuse box 2.
            spectrum *= mats.yx;
            ro = rp + n * 1e-4;
            rd = lrd;
        }
        else if(res.y < 3.5)
        {
            // Mirror box.
            spectrum *= .9;
            ro = rp + n * 1e-4;
            rd = reflect(rd, n);
        }
        
        
        if(res.y < 2.5)
        {
            // For diffuse materials, sample lights directly.
            energy += spectrum * sampleLight(rp, n) * lightRadiance * lightArea;
        }
        else
        {
            // Test for intersection with the parallelogram lightsource.
            float t = dot(lo - ro, ln) / dot(rd, ln);
            if(t > 0.)
            {
                vec3 rp = ro + rd * t;
                vec2 uv = vec2(dot(rp - lo, ls) / dot(ls, ls), dot(rp - lo, lt) / dot(lt, lt));
                if(abs(uv.x) < 1. && abs(uv.y) < 1.)
                {
                    energy += spectrum * lightRadiance;
                }
            }
        }
    }
    return energy;
}

// Function 3108
float castShadowRay( in vec3 ro, in vec3 rd )
{
	vec2 pos = floor(ro.xz);
	vec2 ri = 1.0/rd.xz;
	vec2 rs = sign(rd.xz);
	vec2 ris = ri*rs;
	vec2 dis = (pos-ro.xz+ 9.5 + rs*0.5) * ri;
	float t = -1.0;
	float res = 10.0;
	
    // first step we check noching	
	vec2 mm = step( dis.xy, dis.yx ); 
	dis += mm * ris;
    pos += mm * rs;
	
    // traverse regular grid (2D)	
	for( int i=0; i<6; i++ ) 
	{
		float ma = map(pos);
		
        // test capped cylinder		
		vec3  ce = vec3( pos.x+0.5, 0.0, pos.y+0.5 );
		vec3  rc = ro - ce;
		float a = dot( rd.xz, rd.xz );
		float b = dot( rc.xz, rd.xz );
		float c = dot( rc.xz, rc.xz ) - 0.009;
		float h = b*b - a*c;
		if( h>=0.0 )
		{
			float t = (-b - sqrt( h ))/a;
			if( (ro.y+t*rd.y)<ma )
			{
				res = 0.0;
    			break; 
			}
		}
		mm = step( dis.xy, dis.yx ); 
		dis += mm * ris;
        pos += mm * rs;
	}

	return res;
}

// Function 3109
float ObjRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 200; j ++) {
    p = ro + dHit * rd;
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    if (d < 0.0002 || dHit > dstFar) break;
  }
  return dHit;
}

// Function 3110
vec4 raymarch () {
  vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;
  float dither = rng(uv+fract(time));
  vec3 eye = vec3(0,5,-4.5);
  vec3 ray = getCamera(eye, uv);
  vec3 pos = eye;
  float shade = 0.;
  for (float i = 0.; i <= 1.; i += 1./STEPS) {
    float dist = map(pos);
		if (dist < VOLUME) {
			shade = 1.-i;
			break;
		}
    dist *= .5 + .1 * dither;
    pos += ray * dist;
  }

  vec4 color = vec4(shade);
  color *= getLight(pos, eye);
  color = smoothstep(.0, .5, color);
  color = sqrt(color);
  return color;
}

// Function 3111
vec3 normal(vec3 p) {
    vec2 h = vec2(0.001, 0.0);
    vec3 n = vec3(
        map(p + h.xyy).x - map(p - h.xyy).x,
        map(p + h.yxy).x - map(p - h.yxy).x,
        map(p + h.yyx).x - map(p - h.yyx).x
	);
    
    return normalize(n);
}

// Function 3112
vec3 getTriangleNormal(vec3 v0, vec3 v1, vec3 v2) {
    return normalize(cross(v1-v0,v2-v0));
}

// Function 3113
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    for(int i=0; i<N_OBJECTS; i++ ) {
        CHECK_OBJ( objects[i] );
    }
    return ( nearestDist < 1000.0 );
}

// Function 3114
vec3 calcNormal(vec3 p) {
 
    vec2 eps = vec2(.001,0.);
    vec3   n = vec3(dstScene(p + eps.xyy).dst - dstScene(p - eps.xyy).dst,
                   	dstScene(p + eps.yxy).dst - dstScene(p - eps.yxy).dst,
                   	dstScene(p + eps.yyx).dst - dstScene(p - eps.yyx).dst);
    return normalize(n);
    
}

// Function 3115
vec3 GetNormal1(vec3 hitPoint) {
    float ep = 0.0002;
#if 0    
    vec3 e=vec3(1e-2,0,0);
    float d = sceneWithGlassMaterials(hitPoint).x;
    return normalize(vec3(sceneWithGlassMaterials(hitPoint + e.xyy).x - d,
                          sceneWithGlassMaterials(hitPoint + e.yxy).x - d,
                          sceneWithGlassMaterials(hitPoint + e.yyx).x - d));
#else
    // inspired by iq who was inspired by klems
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);
        n += e*sceneWithGlassMaterials(hitPoint+e*ep).x;
    }
    return normalize(n);
#endif 
}

// Function 3116
vec3 refractionRay(in vec3 ori, in vec3 dir, in vec3 backColor, in vec3 pixColor, in float refractionRatio, inout float signInd, inout vec3 att) {
    for (float i = 0.0; i < 5.0; i++) {
        Hit icp = marching(ori, dir, signInd);
        vec3 interP = ori + icp.dist * dir; 
        vec3 nor = signInd * getNormal(interP);
        Material mat = getMaterial(icp.matIndex);
        if (icp.matIndex < 0) {
            pixColor += vec3(0.0); //mix(pixColor, backColor, att);
        } else {
            if (signInd > 0.0) { 
                vec3 localColor = getColor(ori, interP, nor, icp.matIndex, mat); 
                pixColor = mix(pixColor, localColor, att);
            }
            
            vec3 refractDir = refract(dir, nor, refractionRatio);
            vec3 reflectDir = reflect(dir, nor);
            
            if (dot(refractDir, refractDir) < EPSILON ) {
                //total internal reflection
                dir = reflectDir;
                ori = interP + dir * EPSILON;
                att *= mat.reflection;
            } else {
                //flip normal direction and refractionRatio for the next ray
                dir = refractDir;
                ori = interP + dir * EPSILON;
                signInd = -signInd;
                refractionRatio = 1.0/ refractionRatio;
                att *= mat.refraction; 
            } 
        }
    }
    return pixColor;
}

// Function 3117
vec2 raymarchVoxel(vec3 ro, vec3 rd, out vec3 nor) {
  vec3 pos = floor(ro);
  vec3 ri = 1.0 / rd;
  vec3 rs = sign(rd);
  vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;
  
  float res = -1.0;
  vec3 mm = vec3(0.0);
  
  for (int i = 0; i < 96; i++) {
    float k = voxelModel(pos);
    if (k > 0.5) {
      res = k;
      break;
    }
     
    mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);
		dis += mm * rs * ri;
    pos += mm * rs;
  }
  
  if (res < -0.5) {
    return vec2(-1.0);
  }
  
  nor = -mm * rs;
  
  vec3 vpos = pos;
  vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
  float t = max(mini.x, max(mini.y, mini.z));
  
  return vec2(t, 0.0);
}

// Function 3118
vec3 getNormal( vec3 p, int iter ) {
	//using noise derivative
	//not sure this code is correct
    vec3 value;
	value = fbmDerivative( p.xz, iter);
	if (value.x <= SEALEVEL) { return vec3(.0,1.0,.0); } //sea is flat
	float dfx=value.y;
	float dfz=value.z;
	
	return normalize(vec3( -value.y, 1.0, -value.z));
}

// Function 3119
vec2 castRay( in vec3 ro, in vec3 rd ) {

    const float precis = 0.001;   
    float h=dmin;

    float t = 0.0;
    float m = -1.0;

    for( int i=0; i<40; i++ ) {

        if( abs(h)<precis||t>dmax ) continue;//break;
        t += h;
        vec2 res = map( ro+rd*t );
        h = res.x;
        m = res.y;        
        
    }    

    if (t > dmax) {
        m = -1.0;
    }

    return vec2(t, m);

}

// Function 3120
Ray CastRay(Ray ray, float dist)
{
	return Ray(ray.origin + ray.direction * dist, ray.direction);
}

// Function 3121
vec2 ray_vs_sphere(vec3 p, vec3 dir, float r)
{
	float b = dot(p, dir);
	float c = dot(p, p) - r * r;

	float d = b * b - c;
	if (d < 0.0)
		return vec2(MAX, -MAX);
	d = sqrt(d);

	return vec2(-b - d, -b + d);
}

// Function 3122
vec3 calculate_normal(vec3 pos){
const float eps = 0.0001;
    vec4 n = vec4(0.0);
    for( int i=min(iFrame,0); i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        s[i] += eps;
        n[i] = map(s.xyz).x;
    }
    return normalize(n.xyz-n.w);
}

// Function 3123
vec3 calcNormal( in vec3 pos, in float time )
{
    const float eps = 0.001;
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + 
					  e.yyx*map( pos + e.yyx*eps,time,kk ).x + 
					  e.yxy*map( pos + e.yxy*eps,time,kk ).x + 
					  e.xxx*map( pos + e.xxx*eps,time,kk ).x );
#else
    vec4 n = vec4(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec4 s = vec4(pos, 0.0);
        float kk; vec3 kk2;
        s[i] += eps;
        n[i] = mapD(s.xyz, time).x;
      //if( n.x+n.y+n.z+n.w>100.0 ) break;
    }
    return normalize(n.xyz-n.w);
#endif   
}

// Function 3124
bool get_render_ray( int mode, vec2 sc, inout Ray ray )
{
    if( g_vrmode )
    {
        vec2 uv = ( sc + 1. ) / ATM_SUBSAMPLE;
        vec3 cc = ( mix( mix( unCorners[0], unCorners[1], uv.x ),
                         mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 );
        vec3 dir = cc * g_vrframe;
        if( dot( dir.yz, dir.yz ) >= 1.55 / g_game.camzoom * dir.x * dir.x )
            return false;
        dir.yz /= g_game.camzoom;
        cc = normalize( g_vrframe * dir );
        g_pixelscale = .25 * abs( dir.x * dFdx( dir.y / dir.x ) * dFdy( dir.z / dir.x ) );
        vec3 dp = unCorners[4].zxy * vec3( -1, 1, -1 ) / 1000.;
        ray.o = g_game.campos + g_game.camframe * dp;
        ray.d = g_game.camframe * cc;
    }
    else
    {
        vec2 ec = sc * vec2( 1, iResolution.y / iResolution.x );
        vec3 cc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) / g_game.camzoom, CAM_DISTORT ) ) );
        g_pixelscale = .25 * abs( cc.x * dFdx( cc.y / cc.x ) * dFdy( cc.z / cc.x ) );
        ray.o = g_game.campos;
        ray.d = g_game.camframe * cc;
    }
    return true;
}

// Function 3125
float DistRay(Ray r, vec3 p) {
	return length(p-ClosestPoint(r, p));
}

// Function 3126
void ray(C c, out R r, in vec2 fragCoord)
{
	vec2  uv = (fragCoord.xy / iResolution.xy * 2. - 1.)
			 * vec2(iResolution.x / iResolution.y, 1.);
	
	r.o = c.p;
	r.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(30. * RADIAN)));
	
	vec3 cd = c.t - c.p,
		 rz = normalize(cd),
		 rx = normalize(cross(rz, c.u)),
		 ry = normalize(cross(rx, rz));

	r.d = normalize(mat3(rx, ry, rz) * r.d);
}

// Function 3127
vec3 normal(vec3 p, vec4[5] sp)
{  
    vec2 e = vec2(-1., 1.)*0.005;
	return normalize(e.yxx*map(p + e.yxx, sp) + e.xxy*map(p + e.xxy, sp) + 
					 e.xyx*map(p + e.xyx, sp) + e.yyy*map(p + e.yyy, sp) );   
}

// Function 3128
vec3 refraction(vec3 v, vec3 normal, float n1, float n2) {
    if (dot(v, normal) < 0.0) {
        normal = -normal;
    }
    float cosA = dot(v, normal);
    float sinA = sqrt(1.0 - cosA * cosA);
    vec3 tang = normalize(v - cosA * normal);
    float sinB = sinA / n2 * n1;
    if (sinB >= 1.0)
    {
        return vec3(1000.0);
    }
    float cosB = sqrt(1.0 - sinB * sinB);
    return sinB * tang + cosB * normal;
}

// Function 3129
vec3 calcNormal_2_5(vec3 pos) {
  return calcNormal_2_5(pos, 0.002);
}

// Function 3130
void TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)
{
    vec2 uv;
    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   
    if (dot(rayInfo.yzw, rayDir) < 0.0)
    {
        if (rayInfo.x > rayMinMax.x)
        {
            rayMinMax.x = rayInfo.x;
            nearNormal = rayInfo.yzw;
        }
    }
    else
    {
        if (rayInfo.x < rayMinMax.y)
        {
            rayMinMax.y = rayInfo.x;
            farNormal = rayInfo.yzw;
        }
    }
}

// Function 3131
vec3 getNormal(vec3 p) {
    vec2 e = vec2(.0001, 0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
	));
}

// Function 3132
vec3 RayMarchScene(vec3 rayOrigin, inout rayIntersect rIntersec)
{
    float t = NEARCLIP;
    vec2 res = vec2(NEARCLIP, -1.0);
    
	for(int i=0; i < SCENE_SAMPLE; ++i)
	{
        vec3 pos = rayOrigin + t * rIntersec.rd;
        res = SceneDistance(pos);
        if(res.x < (EPSILON * t) || t > FARCLIP)
            break;
        t += res.x * 0.5;
	}
    
    vec3 pos = rayOrigin + t * rIntersec.rd;
    rIntersec.mPos = pos;
    rIntersec.dist = t;
	
    material mat;
    mat.albedo = vec3(244.0, 164.0, 96.0)/255.0;
    mat.reflectivity = 0.8;
    rIntersec.mat = mat;
    
    #if DEBUG_PASS == 0
        if (t > FARCLIP)
        {
            rIntersec.dist = FARCLIP;
            return GetSkybox(rayOrigin, rIntersec);
        }
        else
        {
            #ifndef DEBUG_NO_FOG
                float sundot = clamp(dot(rIntersec.rd, sunDirection), 0.0, 1.0);
            	vec3 sky = CheapSkyBox(rayOrigin, rIntersec);
            	ColorScene(rIntersec);
            
            	float fogFactor = EaseOutSine(rIntersec.dist / FARCLIP);
            	return mix(Shading(rayOrigin, rIntersec), sky, fogFactor);
            #else
            	ColorScene(rIntersec);
            	return Shading(rayOrigin, rIntersec);
            #endif
        }
    
    #elif DEBUG_PASS == 1
    	if(t < FARCLIP)
            ColorScene(rIntersec);
    	return rIntersec.nor;
    
    #elif DEBUG_PASS == 2
        if (t > FARCLIP)
            rIntersec.dist = FARCLIP;
        return vec3(rIntersec.dist) / FARCLIP;
    
    #elif DEBUG_PASS == 3
    	return rIntersec.mPos;
    
    #elif DEBUG_PASS == 4
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        float NdotL = clamp(dot(rIntersec.nor, sunLightPos), 0.0, 1.0);
        return vec3(NdotL);
    
    #elif DEBUG_PASS == 5
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        float NdotV = clamp(dot(rIntersec.nor, -rIntersec.rd), 0.0, 1.0);
        return vec3(NdotV);
    
    #elif DEBUG_PASS == 6
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);
        float NdotH = clamp(dot(rIntersec.nor, HalfAngleV), 0.0, 1.0);
        return vec3(NdotH);
    
    #elif DEBUG_PASS == 7
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);
        float VdotH = clamp(dot(-rIntersec.rd, HalfAngleV), 0.0, 1.0);
        return vec3(VdotH);
    
    #elif DEBUG_PASS == 8
    	if (t > FARCLIP)
        {
            rIntersec.dist = FARCLIP;
            return GetSkybox(rayOrigin, rIntersec);
        }
        else
	    	return CheapSkyBox(rayOrigin, rIntersec);
    
    #elif DEBUG_PASS == 9
    	if(t < FARCLIP)
            ColorScene(rIntersec);
    
    	vec3 amb = (abs(sun_Color.w - 1.0) * 0.03 + AMBIENT_POW) * AMBIENT_COLOR;
    	return amb;

    #elif DEBUG_PASS == 10
   		float shadow = SoftShadow(rIntersec.mPos + sunDirection);
    	return vec3(shadow);
    
    #endif
}

// Function 3133
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(0.0001, 0.0);
 	return normalize ( vec3(map(pos+e.xyy)-map(pos-e.xyy),
                           	map(pos+e.yxy)-map(pos-e.yxy),
                           	map(pos+e.yyx)-map(pos-e.yyx) ) );   
}

// Function 3134
vec3 calcNormal(in vec3 p) {
	const vec2 e = vec2(0.002, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 3135
vec4 calcNormal( in vec4 pos )
{
	return normalize(vec4(
	    map(pos+eps.xyyy).x - map(pos-eps.xyyy).x,
	    map(pos+eps.yxyy).x - map(pos-eps.yxyy).x,
	    map(pos+eps.yyxy).x - map(pos-eps.yyxy).x,
		map(pos+eps.yyyx).x - map(pos-eps.yyyx).x
	));
}

// Function 3136
Ray ray(vec3 o, vec3 d, vec3 c, float rr, float s) { return Ray(o,d,c,0.,0.,rr,s); }

// Function 3137
vec4 ray_scene(vec3 ro, vec3 rd, out int obj_id, out vec3 N){
    vec4 h;
    vec4 h1;
    ro /= 2.0;
    h1 = ray_grid(ro, rd, obj_id);
    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
        h = h1;
    }
    
    h1 = ray_sphere(ro, rd, 40.0);
    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
        h = h1;
        obj_id = 3;
    }
    h.w *= 2.0;
    N = h.xyz;
    return h;
}

// Function 3138
vec3 getNormal(vec3 p, float t){
    float e = t*MINDIST;
    vec2 h = vec2(1.,-1.)*.5773;
    return normalize( h.xyy*map( p + h.xyy*e, 0.).x + 
					  h.yyx*map( p + h.yyx*e, 0.).x + 
					  h.yxy*map( p + h.yxy*e, 0.).x + 
					  h.xxx*map( p + h.xxx*e, 0.).x );
}

// Function 3139
vec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {
    vec3 rand = cos(cos(p)*128.124+cos(p.yzx*16.234)*32.3245+cos(p.zxy*128.234)*5.4345);
    return normalize(d+rand*amount);
}

// Function 3140
vec3 getNormal(vec3 p){
    vec2 e = vec2(0.0035, -0.0035); 
    return normalize(
        e.xyy * map(p + e.xyy) + 
        e.yyx * map(p + e.yyx) + 
        e.yxy * map(p + e.yxy) + 
        e.xxx * map(p + e.xxx));
}

// Function 3141
float raymarching(
  in vec3 prp,
  in vec3 scp,
  in int maxite,
  in float precis,
  in float startf,
  in float maxd,
  out float objid)
{ 
  const vec3 e=vec3(0.1,0,0.0);
  vec2 s=vec2(startf,0.0);
  vec3 c,p,n;
  float f=startf;
  for(int i=0;i<256;i++){
    if (abs(s.x)<precis||f>maxd||i>maxite) break;
    f+=s.x;
    p=prp+scp*f;
    s=obj(p);
    objid=s.y;
  }
  if (f>maxd) objid=-1.0;
  return f;
}

// Function 3142
vec2 normal(vec2 p) {
    vec2 e = vec2(0.00001, 0);
    float x = lastMapValue;
    return normalize(vec2(map(p+e.xy)-x,
                          map(p+e.yx)-x));
}

// Function 3143
bool TraceTerrainReflection( vec3 origin, vec3 direction, int steps)
{
  float precis = 0.00, t = 0.0, dist = 0.0;
  vec3 rayPos;

  for ( int i=0; i<NO_UNROLL(steps); i++ )
  {
    rayPos =origin+direction*t; 
    dist = MapTerrainReflections( rayPos).x;
    precis = 0.006*t;

    if (dist<precis || t>400.0)
    {             
      return !(t>400.0);
    }

    t += dist;
  }

  return false;
}

// Function 3144
float ringRayNoise(vec3 ray,vec3 pos,float r,float size,mat3 mr,float anim)
{
  	float b = dot(ray,pos);
    vec3 pr=ray*b-pos;
       
    float c=length(pr);

    pr*=mr;
    
    pr=normalize(pr);
    
    float s=max(0.0,(1.0-size*abs(r-c)));
    
    float nd=noise4q(vec4(pr*1.0,-anim+c))*2.0;
    nd=pow(nd,2.0);
    float n=0.4;
    float ns=1.0;
    if (c>r) {
        n=noise4q(vec4(pr*10.0,-anim+c));
        ns=noise4q(vec4(pr*50.0,-anim*2.5+c*2.0))*2.0;
    }
    n=n*n*nd*ns;
    
    return pow(s,4.0)+s*s*n;
}

// Function 3145
vec3 calcNormalstage6(in vec3 p)
{
   vec2 e= vec2(0.001,0.0);
   return normalize (vec3 
        (
        	mapstage6 (p+e.xyy) - mapstage6(p-e.xyy),
            mapstage6 (p+e.yxy) - mapstage6(p-e.yxy),
            mapstage6 (p+e.yyx) - mapstage6(p-e.yyx)                            
        )
	);
}

// Function 3146
void Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)
{
    // focal length
   	float le = 2.0;
    
    // position camera
    ro=vec3(-40.0,0.0,0.0);
    
    // reset camera position
    // shadertoy initialize mouse pos at (0,0)
    if (m == vec2(0))
        m = vec2(0.9, 0.51);
    
    m = (m*2.0 - vec2(1.0))*3.0;
    m.y = clamp(-m.y, -PI_2 + 0.1, PI_2 - 0.1); // clamp camera y rotation

    ro = RotateY(m.y, ro);
    ro = RotateZ(m.x, ro);

    vec3 ww = normalize(-ro);
    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );
    vec3 vv = normalize( cross(uu,ww));

	rd = normalize( p.x*uu + p.y*vv + le*ww );
}

// Function 3147
float ray_scene_intersect(in vec3 pos, in vec3 dir, out vec3 normal, out bool hit_source)
{
	float tt = INF;

	// source
	vec3 n0;
	float t0 = ray_aabb_intersect(pos, dir, vec3(-0.2, -ROOM_SIZE/3.0, -0.2), vec3(0.2, ROOM_SIZE/3.0, 0.2), n0);
	if (t0 < tt) {
		tt = t0;
		normal = n0;
		hit_source = true;
	}

	// occluder
	vec3 n1;
	float t1 = ray_aabb_intersect(pos, dir, vec3(-0.5, -ROOM_SIZE/2.0, -0.5), vec3(0.5, ROOM_SIZE/2.0, -0.4), n1);
	if (t1 < tt) {
		tt = t1;
		normal = n1;
		hit_source = false;
	}

	if (tt < INF) return tt;

	// room
	hit_source = false;
	return ray_invaabb_intersect(pos, dir, vec3(-ROOM_SIZE, -ROOM_SIZE, -ROOM_SIZE), vec3(ROOM_SIZE, ROOM_SIZE, ROOM_SIZE + ROOM_EXTEND), normal);
}

// Function 3148
vec3 normalMap(vec3 p, vec3 n)
{
    float d = 0.005;
    float po = triplanarNoise(p,n);
	float px = triplanarNoise(p+vec3(d,0,0),n);
    float py = triplanarNoise(p+vec3(0,d,0),n);
	float pz = triplanarNoise(p+vec3(0,0,d),n);
    return normalize(vec3((px-po)/d,
                          (py-po)/d,
                          (pz-po)/d));
}

// Function 3149
vec3 MarchRay(vec3 orig, vec3 dir)
{
    vec3 mPos = orig;
    vec3 lPos = orig;
    for(int i = 0;i < 96;i++)
    {
        float dMap = Map(mPos);
        if(dMap < eps)
        {
            if(dMap < 0.0)
            {
                mPos = (lPos + mPos)*0.5;
            }
            else
            {
                break;
            }
        }
        else
        {
            lPos = mPos;
            mPos += dir*dMap;
        }
        
    }
    
    return mPos;
}

// Function 3150
vec4 scene_ocean_normal_and_lensing( vec3 r, float t, float h, float d, vec3 V, vec3 Z )
{
    vec3 A = normalize( V - Z * dot( V, Z ) );
    vec3 B = cross( A, Z );
    vec3 M = normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z, d ) );
    float dMdA = dot( A, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * A, d ) ) - M );
    float dMdB = dot( B, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * B, d ) ) - M );
    float lens = 1. + h / d * ( dMdA + dMdB );
    return vec4( M, 1. / max( FRACT_1_64, lens * lens ) );
}

// Function 3151
vec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)
{
    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);
    
    vec3 rayPos = startRayPos;
    vec3 rayDir = startRayDir;
       
    for (int i = 0; i <= c_numBounces; ++i)
    {
        SRayHitInfo hitInfo;
		hitInfo.hitAnObject = false;
        hitInfo.dist = c_superFar;
        
        // ray trace first, which also gives a maximum distance for ray marching
        RayTraceScene(rayPos, rayDir, hitInfo);
        RayMarchScene(rayPos, rayDir, hitInfo);
        
        if (!hitInfo.hitAnObject)
        {
            // handle ray misses
            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;
            break;
        }
                      
        // update the ray position
        rayPos += rayDir * hitInfo.dist;
               
        // get the material info if it was a ray marched object
        if (hitInfo.rayMarchedObject)
			hitInfo = TestSceneMarch(rayPos);       
                
		// add in emissive lighting
        ret += hitInfo.material.emissive * colorMultiplier;
        
        // figure out whether we are going to shoot out a specular or diffuse ray.
        // If neither, exit
        float diffuseLength = length(hitInfo.material.diffuse);        
        float specularLength = length(hitInfo.material.specular);
        if (diffuseLength + specularLength == 0.0f)
            break;
        float specularWeight = specularLength / (diffuseLength + specularLength);       
        float doSpecular = float(RandomFloat01(rngState) < specularWeight);
       
        // set up the next ray direction
        float roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);
        vec3 reflectDir = reflect(rayDir, hitInfo.normal);
        vec3 randomDir = RandomUnitVector(rngState);
        rayDir = normalize(mix(reflectDir, randomDir, roughness));
        
        if (dot(rayDir, hitInfo.normal) < 0.0f)
            rayDir *= -1.0f;        
        
        // move the ray away from the surface it hit a little bit
        rayPos += hitInfo.normal * c_rayPosNormalNudge;
        
        // Make all future light affected be modulated by either the diffuse or specular reflection color
        // depending on which we are doing.
        // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)
        float NdotL = dot(hitInfo.normal, rayDir);
        colorMultiplier *= mix(hitInfo.material.diffuse * NdotL, hitInfo.material.specular, doSpecular);        
    }
    
    return ret;
}

// Function 3152
vec3 getNormalOfSurface( in vec3 positionOfHit ){
    
	vec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );
    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );
    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );
    
   	float upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; 
    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; 
    
    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;
    
    
    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; 
    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; 
    
    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;
    
    
    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; 
    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; 
    
    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;
    
    
	vec3 normal = vec3(
         			tinyChangeInX,
        			tinyChangeInY,
        			tinyChangeInZ
    	 		  );
    
	return normalize(normal);
}

// Function 3153
float RayMarch(vec3 ro, vec3 rd, int PMaxSteps)
{   float t = 0.; 
    vec3 dS=vec3(9999.0,-1.0,-1.0);
    float marchCount = 0.0;
    vec3 p;
    
    #define DISTANCE_BIAS 0.75
    float minDist = 9999.0; 
    
    for(int i=0; i <= PMaxSteps; i++) 
    {  	p = ro + rd*t;
        dS = GetDist(p);
        t += dS.x;
        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)
            {mObj.hitbln = true; minDist = abs(t); break;}
        if(t>MAX_DIST)
            {mObj.hitbln = false;    minDist = t;    break; } 
        marchCount++;
    }
    mObj.dist = minDist;
    mObj.id_color = dS.y;
    mObj.marchCount=marchCount;
    mObj.id_material=dS.z;
    mObj.normal=GetNormal(p);
    mObj.phit=p;
    return t;
}

// Function 3154
vec3 GetNormal(vec3 p) {
	float d = GetDist(p).x;
    vec2 e = vec2(.001, 0);
    vec3 n = d - vec3(
        GetDist(p-e.xyy).x,
        GetDist(p-e.yxy).x,
        GetDist(p-e.yyx).x);
    return normalize(n);
}

// Function 3155
vec3 furNormal(vec3 pos, float density)
{
    vec2 uv;
    const float ep = 0.0000001;
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize( e.xyy*furDensity( pos + e.xyy*ep, uv ) + 
					  e.yyx*furDensity( pos + e.yyx*ep, uv ) + 
					  e.yxy*furDensity( pos + e.yxy*ep, uv ) + 
					  e.xxx*furDensity( pos + e.xxx*ep, uv ) );
}

// Function 3156
vec4 grayscaleMap(int minBrightness, int minValue, int maxValue, int value) {
    if (value < minValue || value > maxValue )
        //error
        return white;//white goes unnoticed
    int range = maxValue - minValue;
	float brightnessIncreasePerUnit;
	if (range > 0)
		brightnessIncreasePerUnit = float(255 - minBrightness)/float(range);
	else
		brightnessIncreasePerUnit = 0.;
    float brightness = (float(value - minValue)*brightnessIncreasePerUnit 
                        + float(minBrightness))/float(255);
	return vec4(brightness, brightness, brightness, 1);
}

// Function 3157
vec3 ray(vec3 ro , vec3 rd){
    float t = 0.0;
    vec3 h;
    for(int i = 0;i<500;i++){
	
    vec3 pos = ro+rd*t;
     h = map(pos);
    if(h.x<0.001) break;
    t+=h.x;
    if(t > 20.0) break;
    }
    if(t>20.0) t=-1.0;
     return vec3(t,h.y,h.z);
    
}

// Function 3158
bool rayAABBIntersection( in Ray ray, vec3 boxMin, vec3 boxMax, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    vec3 OMIN = ( boxMin - ray.origin ) / ray.dir;
    vec3 OMAX = ( boxMax - ray.origin ) / ray.dir;
    vec3 MAX = max ( OMAX, OMIN );
    vec3 MIN = min ( OMAX, OMIN );
    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );
    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );
    
    if ( t1 <= t )
        return false;
    
    if( !forShadowTest ) {
        isect.position_ = ray.origin + ray.dir*t;
        
        if( EQUAL_FLT( isect.position_.x, boxMin.x, EPSILON ) ) {
            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );
            isect.tangent_ 		= vec3( 0.0, 1.0, 0.0 );
            isect.uv_ = (isect.position_.yz - boxMin.yz)/(boxMax.yz - boxMin.yz);
        } else if( EQUAL_FLT( isect.position_.x, boxMax.x, EPSILON ) ) {
            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );
            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );
            isect.uv_ = (isect.position_.yz - boxMin.yz)/(boxMax.yz - boxMin.yz);
        } else if( EQUAL_FLT( isect.position_.y, boxMin.y, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_ = (isect.position_.xz - boxMin.xz)/(boxMax.xz - boxMin.xz);
        } else if( EQUAL_FLT( isect.position_.y, boxMax.y, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_ = (isect.position_.xz - boxMin.xz)/(boxMax.xz - boxMin.xz);
        } else if( EQUAL_FLT( isect.position_.z, boxMin.z, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_ = (isect.position_.xy - boxMin.xy)/(boxMax.xy - boxMin.xy);
        } else if( EQUAL_FLT( isect.position_.z, boxMax.z, EPSILON ) ) {
            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );
            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );
            isect.uv_ = (isect.position_.xy - boxMin.xy)/(boxMax.xy - boxMin.xy);
        }
        
        isect.uv_ /= 2.0;
    }
    
    return true;
}

// Function 3159
vec4 rayCast(vec3 ro, vec3 rd, float flag) {
    
    vec4 color = vec4(1.0,1.0,1.0,1.0);
 	vec4 color1 = vec4(0.0,1.0,0.2,1.0);
    vec4 color2 = vec4(0.0,0.2,1.0,1.0);
        
    float t = 0.0;
    const int N = 80; // iteration number
    for (int i = 0; i < N; i++) {
        vec3 p = ro+t*rd;
     	float d = distanceToObjects(p);
        if (d < 0.01) {
        	//color = mix(color1,color2,float(i)/float(N));
            if (flag < 0.0) {
                vec4 subColor = subRayCast(p-0.2*calculateNormal(p),-lightDirection);
                float b = 0.50;
                float c = 80.0*subColor.r;
                c = F(c);
                color = vec4(c,c,c,1.0);
            }
            else {
                color = 30.0*shade(p,calculateNormal(p));
            }
            break;
        }
        else {
            t += d;
        }
    }
    
    return min(color,1.0);
}

// Function 3160
vec2 normal(vec2 uv) {
	vec2 eps = vec2( 0.0005, 0.0 );
	return normalize(
		vec2(sdf(uv+eps.xy) - sdf(uv-eps.xy),
		     sdf(uv+eps.yx) - sdf(uv-eps.yx)));
}

// Function 3161
vec2 raySphere( vec3 ro, vec3 rd, float r ) {

    float b = dot(ro, rd);
    float c = dot(ro, ro) - r*r;
    float h = b*b  - c;
    
    if (h < 0.) return vec2(1000);
    
    h = sqrt(h);
    return vec2(-b-h, -b+h);
}

// Function 3162
float raycast( in vec3 rayOrigin, in vec3 rayDirection, in float searchLimit )
{
    float t = 0.0;
    for( int i = 0; i < 100; i++ )
    {
        vec3 position = rayOrigin + t * rayDirection;
        
        float hitObject = mapObjects(position); 

        if( hitObject < 0.001 )
           break;   
        
        t += hitObject;
        if( t > searchLimit )
           break;
    }   
    if( t > searchLimit )
        t = 0.0;
    return t;
}

// Function 3163
vec3 calcNormal( in vec3 pos )
{
	vec4 dummy;
    vec3 eps = vec3(EPSILON,0.0,0.0);
	return normalize( vec3( map(pos+eps.xyy,dummy).x - map(pos-eps.xyy,dummy).x, map(pos+eps.yxy,dummy).x - map(pos-eps.yxy,dummy).x, map(pos+eps.yyx,dummy).x - map(pos-eps.yyx,dummy).x) );
}

// Function 3164
vec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )
{
	vec4 sum = vec4(0);
	float dt = .01,
         den = 0., _den, lut,
           t = intersect_sphere( ro, rd, BS.xyz, BS.w );
    if ( t == -1. ) return vec4(0); // the ray misses the object 
    t += 1e-5;                      // start on bounding sphere
    
    for(int i=0; i<500; i++) {
        vec3 pos = ro + t*rd;
        if(   sum.a > .99               // end if opaque or...
           || length(pos-BS.xyz) > BS.w ) break; // ... exit bounding sphere
                                    // --- compute deltaInt-density
        lod = 1.*abs( pos.z - sin(4.*iTime) ); // *** tune Depth of Field $DOF ***
        dt = max(.01, .05*lod);     // *** use larger steps where $DOF blurry ***
        _den = den; den = map(pos); // raw density
        float _z = z;               // depth in object
        lut = LUTs( _den, den );    // shaped through transfer function
        if( lut > .0                // optim
          ) {                       // --- compute shading                  
#if 0                               // finite differences
            vec2 e = vec2(.3,0);
            vec3 n = normalize( vec3( map(pos+e.xyy) - den,
                                      map(pos+e.yxy) - den,
                                      map(pos+e.yyx) - den ) );
         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm
            float dif = clamp( -dot(n, sundir), 0., 1.);
#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm
         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction 
            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse
#endif
/*
            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse
                  col = vec3(.2 + dif);
            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog
*/            
            vec3 S = pos.x < 0. ? vec3(3,3,2) : vec3(2,3,3);
            vec3 col = exp(-S *(1.-z));                   // dark with shadow
         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));     // dark with depth
                   //      *  exp(- 1.5 *(1.-z));
            sum += (1.-min(1.,sum.a)) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;
        }
        t += dt;  // stepping
    }

    return sum; 
}

// Function 3165
vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.001,0.0,0.0);

	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

// Function 3166
vec3 mapRMNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapRMDetailed(pt).x;    
    normal.x = mapRMDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapRMDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 3167
vec3 RayMarch(vec3 ro, vec3 rd) {
	vec3 color = BACKGROUND_COLOR;
    float st = 0.0;
    vec3 p = vec3(0.0);
    
    for (int i = 0; i < MAX_STEPS; i++) {
    	p = ro + rd*st;
        vec4 mesh = MAP_Scene(p, ro, 0);
        
        // Scene Color
        if (mesh.w <= SURFACE_DISTANCE) {
            mesh = MAP_Scene(p, ro, 1);
            vec3 sceneColor = mesh.xyz;
        	
             if (st>=FOG_START) {
            	float nrmlz = st - FOG_START;
                nrmlz /= FOG_END - FOG_START;
                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));
            }
            
            color = sceneColor;
            break;
        }
        
        if (st >= MAX_RENDER_DISTANCE) {
        	break;
        }
        
        st += mesh.w;
    }
    
    // Sky(Background) Color
    if (st >= MAX_RENDER_DISTANCE) {
    	color = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));
    }
    
    return color;
}

// Function 3168
bool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, out float t, out SurfaceHitInfo isect ) {
    if ( ray.dir.z == 0.0 )
    	return false;
    
    t = ( -ray.origin.z ) / ray.dir.z;
    
    isect.position_ = ray.origin + ray.dir*t;
    isect.normal_ 	= vec3( 0.0, 0.0, 1.0 );
    return	(isect.position_.x > min_x) &&
       		(isect.position_.x < max_x) &&
      		(isect.position_.y > min_y) &&
      		(isect.position_.y < max_y);
}

// Function 3169
vec3 ray_trace(vec2 uv, vec2 ro, vec3 col){
    
    vec2 t_and_a = time_and_animation();
    //rays
    for(float i = 0.; i<fov; i += fov/float(RAY_N)){
    
        vec2 rd = vec2(1.,0.);//*rot(i-pi*sin(iTime/6.));
        vec2 bounce_ro = ro + vec2(0., i*5.);
        //bounces
        col = bounces(bounce_ro, rd, t_and_a.x, uv, col);
        }
        
    
    
    return col;
}

// Function 3170
bool raymarchW(out vec3 pos)
{
	float t = .0;
	float d =.0;
	int i = 0;
	do
	{
		d = map(ro + rd * t);
		t += d;
	} while (i++ < maxSteps && t < drawDist && d > epSI);

	pos = ro + rd * t;
	return (t < drawDist);
}

// Function 3171
bool castRay(Ray ray, out vec3 p, out vec3 normal, out Material material) {
    float t = FAR_PLANE;
    
    for (int i = 0; i < NUM_OBJECTS; ++i) {
        float t_ = castRayToSphere(ray, scene[i].sphere);
        
        if (t_ < t) {
            t = t_;
            
            p = ray.origin + t * ray.direction;
            normal = normalize(p - scene[i].sphere.center);
            material = scene[i].material;
         }
    }
    
    return (t < FAR_PLANE);
}

// Function 3172
vec3 normal(vec3 p, float k)
{
    float m = map(p);
	vec2 e = vec2(0,k);
	return normalize(m-vec3(
		map(p - e.yxx),
		map(p - e.xyx),
		map(p - e.xxy)
	));
}

// Function 3173
vec3 normal(in vec3 rp) {
    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),
                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),
                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));
}

// Function 3174
vec3 GetRay( vec3 dir, float zoom, vec2 uv )
{
	uv = uv - .5;
	uv.x *= iResolution.x/iResolution.y;
	
	dir = zoom*normalize(dir);
	vec3 right = normalize(cross(vec3(0,1,0),dir));
	vec3 up = normalize(cross(dir,right));
	
	return dir + right*uv.x + up*uv.y;
}

// Function 3175
vec3 raymarch(in vec3 from, in vec3 dir) 

{
	float ey=mod(t*.5,1.);
	float glow,eglow,ref,sphdist,totdist=glow=eglow=ref=sphdist=0.;
	vec2 d=vec2(1.,0.);
	vec3 p, col=vec3(0.);
	vec3 origdir=dir,origfrom=from,sphNorm;
	
    for (int i=0; i<RAY_STEPS; i++) {
		if (d.x>det && totdist<6.0) {
			p=from+totdist*dir;
			d=de(p);
			det=detail*(1.+totdist*60.)*(1.+ref*5.);
			totdist+=max(detail,d.x); 
			if (d.y<.5) glow+=max(0.,.02-d.x)/.02;
		}
	}
	vec3 ov=normalize(vec3(1.,.5,1.));
	vec3 sol=dir+lightdir;
    float l=pow(max(0.,dot(normalize(-dir*ov),normalize(lightdir*ov))),1.5)+sin(atan(sol.x,sol.y)*20.+length(from)*50.)*.0015;
    totdist=min(5.9,totdist);
    p=from+dir*(totdist-detail);
    vec3 backg=.4*(1.2-l)+LIGHT_COLOR*l*.75;
	backg*=AMBIENT_COLOR*(1.-max(0.2,dot(normalize(dir),vec3(0.,1.,0.)))*.2);
	float fondo=0.;
	vec3 pp=p*.5+sin(t*2.)*.5;
    for (int i=0; i<10; i++) {
        fondo+=clamp(0.,1.,textur(pp+dir*float(i)*.01))*max(0.,1.-exp(-.05*float(i)))*2.;
    }
    vec3 backg2=backg*(1.+fondo*(FLOOR_COLOR)*2.);
    if (d.x<.01) {
        vec3 norm=normal(p);
		col=mix(light(p-abs(d.x-det)*dir, dir, norm, d.y),backg,1.-exp(-.3*totdist*totdist)); 
		col = mix(col, backg2, 1.0-exp(-.02*pow(abs(totdist),2.)));
	} else { 
		col=backg2;
	}
	vec3 lglow=LIGHT_COLOR*pow(abs(l),30.)*.5;
    col+=glow*(.3+backg+lglow)*.007;
	col+=lglow*min(1.,totdist*totdist*.2)*1.5;
    
	return min(vec3(1.),col); 
}

// Function 3176
vec3 sphereNormal(vec3 coord, vec3 center){
	return normalize(coord-center);
}

// Function 3177
float opReflect ( inout float3 p, float3 plane_normal, float offset ) {
  float t = dot(p, plane_normal) + offset;
  if ( t < 0.0 )
    p = p - (2.0*t)*plane_normal;
  return sgn(t);
}

// Function 3178
Ray getCameraRay(vec2 offset) {
    vec3 origin = vec3(0.0, 2.5, 6.0);
    vec3 lookAt = vec3(0., 1.2, 0.);

    vec2 uv = (gl_FragCoord.xy + offset) / iResolution.xy - .5;
    uv.y *= iResolution.y / iResolution.x;

    vec3 iu = vec3(0., 1., 0.);

    vec3 iz = normalize( lookAt - origin );
    vec3 ix = normalize( cross(iz, iu) );
    vec3 iy = cross(ix, iz);

    vec3 direction = normalize( uv.x * ix + uv.y * iy + .85 * iz );

    return Ray(origin, direction);
}

// Function 3179
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 200; j ++) {
    d = ObjDf (ro + rd * dHit);
    if (d < 0.0002 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 3180
vec3 normal(in vec3 p) {
	const vec2 e = vec2(.001, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 3181
vec4 raymarch( inout vec3 p, inout vec3 dir, out int out_steps, out float dmin )
{
    int iter = 0;
	vec4 d;
	float rdt = 0.0;
    dmin = 100000.0;
	for ( int i=0; i<NUM_ITERATIONS; i++ )
	{
        iter += 1;
		d = scene( p );

        dmin = min( dmin, d.x );
        
		if ( (d.x < 0.0 ) || (rdt > FAR_CLIP) ) {
			break;
		}
		else
		{
			float dt = 0.01 + STEP_MULT * d.x; //note: constant-multiply to compensate for distorted space, actual dist < dist - could use gradient-approximation instead? (see iq)
			p += dir * dt;
			rdt += dt;
		}
	}

	out_steps = iter;
	return d;

}

// Function 3182
float traceRay(vec2 p, vec2 v) {
    float ts = 0.0;
    float light = 0.0;
    int bounces = 0;
    float t = 0.0;
    for (int i = 0 ; i < MAXSTEPS ; i++) {
        float dt = scene(p + v*t);
        if(dt < MINDISTANCE) { // hit object
            
            // check if passed light source
            light += getLight(p, v, t, ts);
            
            // reflect the ray
            p += v*t;
            v = reflect(v, sceneNormal(p));
            ts = t;
            t = MINDISTANCE; // reset distance along ray, but ensure dont collide with surface
            
            bounces++;
            if(bounces >= MAXBOUNCES) break;
        }
        t += dt;
    }
    if(bounces == 0) {
        // might still have passed light source
        light += getLight(p, v, t, ts);
    }
    return light;
}

// Function 3183
vec3 normal(vec3 p){
    mat3 e = mat3(0.001);
    return normalize(vec3(map(p+e[0]), map(p+e[1]), map(p+e[2])) - map(p));
}

// Function 3184
bool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {
    bool hitResult = false;
    float t;
    SurfaceHitInfo currentHit;

    //Convert ray to object space
    Ray rayLocal;
    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );

    if( obj.type_ == OBJ_PLANE ) {
        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_SPHERE ) {
        hitResult = raySphereIntersection( 	rayLocal, obj.params_[1], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_CYLINDER ) {
        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_AABB ) {
        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );
    } else if( obj.type_ == OBJ_DISK ) {
        hitResult = rayDiskIntersection( rayLocal, obj.params_[0], obj.params_[1], forShadowTest, t, currentHit );
    }

    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {
        //Convert results to world space
        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );

        dist = t;
        hit = currentHit;
        hit.mtl_id_ = obj.mtl_id_;
        
        return true;
    } else {
    	return false;
    }
}

// Function 3185
vec2 castRay(vec3 ro, vec3 rd)
    {
        if (gOpen > .5)
            gBoundsSize.yz = vec2(4, 30);

        vec2 res = vec2(10e8, -1),
             tb = iBox(ro - gBoundsPos, rd, gBoundsSize),
             h;

        float tmin =  .1,
              tmax = 90.,
              tp1 = -ro.y / rd.y,
              t;

        // raytrace floor plane
        if (tp1 > 0.)
        {
            tmax = min(tmax, tp1);
            res = vec2(tp1, 0);
        }    

        // raymarch primitives   
        if (tb.x < tb.y && tb.y > 0. && tb.x < tmax)
        {
            t = tmin = max(tb.x, tmin);
            if (gOpen < .5)
                res = opU(res, vec2(tb.y, 1));

            for (int i = O; i < 128 && t < min(tb.y, tmax); i++)
            {
                h = map(ro + rd * t);
                if (h.x < (.0001 * t))
                {
                    res = vec2(t, h.y);
                    break;
                }
                t += h.x;
            }
        }

        return res;
    }

// Function 3186
float pReflect(inout vec3 p, vec3 planeNormal, float offset) {
	float t = dot(p, planeNormal) + offset;
	if (t < 0.) {
		p = p - (2.*t)*planeNormal;
	}
	return sign(t);
}

// Function 3187
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = 0; j < 120; j ++) {
    d = ObjDf (ro + rd * dHit);
    if (d < 0.0005 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 3188
vec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)
{
    float l = hash12(uv)*.5;
    int i;
    vec2 d2;
    mist = 0.0;
    
    #ifdef OFF_LINE
    for (i = 0; i < 800; i++)
    #else
    for (i = 0; i < 300; i++)
    #endif
    {
        vec3 p = ro + rd * l;
        d2 = de(p);
        mist += smoothstep(.12,.03,d2.x);
        
        if (abs(d2.x) < .03 || l > 1000.0) break;
        #ifdef OFF_LINE
        l += d2.x*.5;
        #else
        l += d2.x*.85;
        #endif
	}
    mist = pow(mist, 3.) * .0001;
    return vec2(l, d2.y);
}

// Function 3189
vec3 rayToPixel(vec2 pixel) {
    pixel -= 0.5*iResolution.xy;
    return normalize(vec3(pixel.x, pixel.y, distToScreen));
}

// Function 3190
vec3 calcNormal( in vec3 pos, in float t, in float s )
{
    float precis = 0.001 * t;

    vec2 e = vec2(1.0,-1.0)*precis;
    return normalize( e.xyy*map( pos + e.xyy, s ) + 
					  e.yyx*map( pos + e.yyx, s ) + 
					  e.yxy*map( pos + e.yxy, s ) + 
                      e.xxx*map( pos + e.xxx, s ) );
}

// Function 3191
vec3 sphNormal( in vec3 pos, in vec4 sph )
{
    return (pos - sph.xyz)/sph.w;    
}

// Function 3192
vec3 normal(vec3 p) {
	float e = 0.0001;
	float f0 = total_distance(p);
	float fx = total_distance(vec3(p.x + e,p.y,p.z));
	float fy = total_distance(vec3(p.x,p.y + e,p.z));
	float fz = total_distance(vec3(p.x,p.y,p.z + e));
	return normalize(vec3(fx-f0,fy-f0,fz-f0));
}

// Function 3193
void RayMarchVolumetric(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, out vec3 absorption, inout uint rngState, in vec2 fragCoord)
{
    float searchDistance = hitInfo.hitAnObject ? min(hitInfo.dist, c_maxDistanceVolumetric) : c_maxDistanceVolumetric;
    float stepSize = searchDistance / float(c_numStepsVolumetric);

    // random starting offset up to a step size for each ray, to make up for lower step count ray marching.
    float t = RandomFloat01(rngState) * stepSize;
    
    float scatterRoll = RandomFloat01(rngState);
    float scatterCum = 1.0f;
    absorption = vec3(1.0f, 1.0f, 1.0f);
    vec3 emissive = vec3(0.0f, 0.0f, 0.0f);

    SRayVolumetricInfo volumetricInfo;
    bool scattered = false;
    
    for (int i = 0; i < c_numStepsVolumetric; ++i)
    {
		vec3 rayPos = startingRayPos + rayDir * t;
        TestSceneVolumetric(rayPos, volumetricInfo);  // we could maybe try averaging the volumetricInfo with the last step or something.
        
        float desiredScatter = scatterRoll / scatterCum;  // this is how much we need to multiply scatterCum by to get to scatterRoll
        
        scatterCum *= exp(-volumetricInfo.scatterProbability * stepSize);               
        if (scatterCum < scatterRoll)
        {
            float lastT = t - stepSize;
            
            // using inverted beer's law to find the time between steps to get the right scatter amount.
            // beer's law is   y = e^(-p*x)
            // inverted, it is x = 1/p * ln(1/y)
            float stepT = (1.0f / volumetricInfo.scatterProbability) * log(1.0f / desiredScatter);
            t = lastT + stepT;
            
            // absorption and emission over distance
            absorption *= exp(-volumetricInfo.absorption * stepT);
            emissive += volumetricInfo.emissive * stepT;
            
            scattered = true;
            break;
        }
        
        // absorption and emission over distance
        absorption *= exp(-volumetricInfo.absorption * stepSize);       
        emissive += volumetricInfo.emissive * stepSize;
        
        // go to next ray position
        t += stepSize;
    }
    
    if (!scattered)
    {
        // emissive over distance should happen even when there's no scattering
        hitInfo.material.emissive += emissive;
        return;
    }
    
    hitInfo.hitAnObject = true;
    hitInfo.objectPass = OBJECTPASS_RAYMARCHVOLUMETRIC;
    hitInfo.dist = t;
    
    // importance sample Henyey Greenstein phase function to get the next ray direction and put it in the normal.
    // http://www.pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Volume_Scattering.html
    // https://www.csie.ntu.edu.tw/~cyy/courses/rendering/09fall/lectures/handouts/chap17_volume_4up.pdf
    {
        float g = volumetricInfo.anisotropy;
        
        vec2 rand = vec2(RandomFloat01(rngState), RandomFloat01(rngState));
        
        float cosTheta;
		if (abs(g) < 1e-3)
    		cosTheta = 1.0f - 2.0f * rand.x;
		else
        {
    		float sqrTerm = (1.0f - g * g) /
                    		(1.0f - g + 2.0f * g * rand.x);
    		cosTheta = (1.0f + g * g - sqrTerm * sqrTerm) / (2.0f * g);
		}
        
        float sinTheta = sqrt(max(0.0f, 1.0f - cosTheta * cosTheta));
		float phi = c_twopi * rand.y;
		vec3 v1, v2;
		CoordinateSystem(rayDir, v1, v2);
		hitInfo.normal = SphericalDirection(sinTheta, cosTheta, phi, v1, v2, -rayDir);
    }
        
    hitInfo.material.diffuse = vec3(0.0f, 0.0f, 0.0f);
    hitInfo.material.specular = vec3(0.0f, 0.0f, 0.0f);
    hitInfo.material.roughness = 0.0f;
    hitInfo.material.emissive = emissive;
}

// Function 3194
vec3 combineNormals2(vec3 n0, vec3 n1) {
    n0 = n0 * 2.0 - 1.0;
    n1 = n1 * 2.0 - 1.0;    
	n0  = vec3(n0.xy * n1.z + n1.xy * n0.z, n0.z * n1.z);    
    return normalize(n0) * 0.5 + 0.5;
}

// Function 3195
void raytraceTree(vec3 rayPt, vec3 rayDir, vec3 treeOrigin, float yOff, float heightOff, float widthOff){
    
    treeOrigin.y += 6.0+yOff;
    
	vec2 aboveRayPt = rayPt.xz;
    vec2 aboveRayDir = normalize(rayDir.xz);
    vec2 aboveTreeOrigin = treeOrigin.xz;
    vec2 aboveTreeGap = aboveTreeOrigin-aboveRayPt;
    
    // test between cylinder ends
    
    float distToTree = length(aboveTreeGap);
    float stepLength = length(rayDir.xz);
    float stepsToTree = distToTree/stepLength;
    float yAtTree = rayPt.y + rayDir.y*stepsToTree;
    float coneBtmY = treeOrigin.y-12.0;
    float coneTopY = treeOrigin.y+20.0;//hook these up to the same property as actually determines the branches? :|
    if (yAtTree < coneBtmY) return;
    if (yAtTree > coneTopY) return;
    float coneFracY = (yAtTree - coneBtmY) / (coneTopY - coneBtmY);
    
    
    // test within cylinder radius
    const float coneTopRad = 2.0;
    const float coneBtmRad = 14.0;
    float treeHitzoneRadius = coneTopRad + (coneBtmRad-coneTopRad)*(1.0-coneFracY);
    float distToPointOnRayClosestToCenterOfTree = dot(aboveTreeGap,aboveRayDir)/length(aboveRayDir);
    if (distToPointOnRayClosestToCenterOfTree <= 0.0) return;//should consider radius of cylinder too, but won't matter for this scene
    vec2 pointOnRayClosestToCenterOfTree = aboveRayPt+aboveRayDir*distToPointOnRayClosestToCenterOfTree;
    float closestDistToTreeCenter = length(pointOnRayClosestToCenterOfTree-aboveTreeOrigin);
    if (closestDistToTreeCenter > treeHitzoneRadius) return;
    
    
    const float numShelves=11.0;
    for(float i=0.0; i<numShelves; i++){
        float branchFrac = i/numShelves;
        
        float windWaveOff = treeOrigin.x*-0.007;
        float windWaveAmt = timeToWindWaveAmt(iTime*1.5 + windWaveOff);
        windWaveAmt = 1.0 - pow( 1.0-windWaveAmt , 2.0 );
        const float windWaveMin = 0.2;
        windWaveAmt = windWaveAmt*(1.0-windWaveMin) + windWaveMin;
        
        float subWave = sin(iTime*3.0 + treeOrigin.x*-0.01 + branchFrac*1.2);
        subWave = subWave*0.5+0.5;
        subWave = 1.0-pow(1.0-subWave,2.0);
        
        float windWave = subWave*windWaveAmt*-0.04;
        
    	raytraceBranchShelf(rayPt, rayDir,
                            treeOrigin+vec3(0.0,1.0+(pow(1.0-branchFrac,0.6))*(13.0+heightOff),0.0),//height
                            branchStart+0.5+(9.0+widthOff)*branchFrac,//length
                            0.05+0.6*branchFrac + windWave,//pitch
                            3.0*branchFrac//yaw offset
                           );
    }
    
    
    float trunkRadius = -(yAtTree-(treeOrigin.y+8.0))*0.1;
    if (yAtTree < treeOrigin.y+10.0) {
        if (closestDistToTreeCenter < trunkRadius) {
            // this is utterly fudged, but it's close enough for such a tiny detail
            float trunkFracFudged = (1.0-pow((closestDistToTreeCenter/trunkRadius),3.0))*trunkRadius;
            float trunkDist = distToPointOnRayClosestToCenterOfTree - trunkFracFudged;
            if (trunkDist < nearestD) {
                nearestD = trunkDist;
            	color = vec3(0.15,0.10,0.00)*(trunkFracFudged+0.2);
            } else {
                #ifdef DRAW_CLIP_RAYTRACES
                color -= vec3(0.0,0.5,0.0);
                #endif
            }
        }
    }
    
    
    
    
    
    
    #ifdef DRAW_CLIP_RAYTRACES
    color = mix(color,vec3(0.0,1.0,0.0),0.1);
    #endif
}

// Function 3196
vec4 raymarch(vec3 start_point, vec3 direction, int steps, float max_dist) {
    vec3 position = start_point;
    
    float dist = 0.0;
    
    for (int i=0; i<steps; i++) {
        float df = map(position);
        
        float threshold = 0.002 * dist;
        float step_size = df * 0.9; // This helps because it isn't a true SDF
        
        if ((df < threshold)) {
            return vec4(position, dist / max_dist);
        }
        if  (dist > max_dist) {
            return vec4(position, 1.0);
        }
        dist += step_size;
        position += direction * step_size;
    }
    return vec4(position, dist/max_dist);
}

// Function 3197
vec3 getSurfaceNormal(sampler2D tex, vec2 coord)
{
	// Get the local difference in height about the coordinate given.
	vec2 localDiff = getLocalDiff(tex, coord);
	
	// Remember that the surface normal is a negative reciprocal of
	// the surface tangent (which is what the local difference really is).
	// This step does half that job, negating the local difference.
	localDiff *= -1.0;
	
	// Remember that this is to be stored in a pixel, so we have to
	// fit it to the range [0..1].
	localDiff = (localDiff/2.0)+.5;
	
	// In order to reciprocate the local difference in height--the difference
	// in essentially the Z direction of the material--we consider the localDiff
	// to be the horizontal terms of the normal vector. This leaves one thing
	// left to do.
	// We have to scale the Z term based on the magnitude of the height difference.
	// To do this we consider the normal vector to be the hypotenuse of a triangle,
	// with unit length 1. One side of the triangle is constrained to the XY plane,
	// and is the local height difference. This leaves the Z term easy to solve with
	// the pytheagorean theorem.
	float localDiffMag = length(localDiff);
	float z = sqrt(1.0-pow(localDiffMag, 2.0));
	
	return vec3(localDiff, z);
}

// Function 3198
vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        sceneSDF(vec3(p.x + epsilon, p.y, p.z)) - sceneSDF(vec3(p.x - epsilon, p.y, p.z)),
        sceneSDF(vec3(p.x, p.y + epsilon, p.z)) - sceneSDF(vec3(p.x, p.y - epsilon, p.z)),
        sceneSDF(vec3(p.x, p.y, p.z + epsilon)) - sceneSDF(vec3(p.x, p.y, p.z - epsilon))
    ));
}

// Function 3199
vec3 getNormal(in vec3 p, float t) {
	const vec2 e = vec2(.001, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), 
                          map(p + e.yxy) - map(p - e.yxy),	
                          map(p + e.yyx) - map(p - e.yyx)));
}

// Function 3200
float RayIntersectAABoxMin (in ivec3 cellPos, in vec3 rayPos, in vec3 rayDir)
{
    vec3 boxMid = vec3(cellPos)+vec3(0.5);
    
	vec3 roo = rayPos - boxMid;
    vec3 rad = vec3(0.5);

    vec3 m = 1.0/rayDir;
    vec3 n = m*roo;
    vec3 k = abs(m)*rad;
	
    vec3 t1 = -n - k;

    return max( max( t1.x, t1.y ), t1.z );
}

// Function 3201
vec3 normal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

// Function 3202
vec3 reflection(vec3 rro, vec3 rd, vec3 n, vec3 ro, float x)
{
    float my = iMouse.y > 0.0 ? iMouse.y/iResolution.y : 0.5;
    vec3 ang = vec3(noise3D(rro*1.1*x), noise3D(rro*1.2*x), noise3D(rro*1.3*x))*my;
	rd = normalize(reflect(rd,n)*rot(ang));
	vec3 res = vec3(1.0,1.0,0.8);
	float tmax = 10.0;
    float t = 0.1;
    vec3 rp = rro;
    vec4 d = vec4(res, 1.0);
	for(int i = 0; i<256; i++ )
	{
        if(t>=tmax) break;
		rp = rro+rd*t;
		d = map(rp);
		if(d.a < 0.001) 
		{		
			break;
		}
		t+=d.a;
	}
    if(d.a < 0.001) 
	{		
    	float ks = 0.5;
		float kd = 0.5;		
		float ka = 0.2;
        float a = 3.0;
		float aof = 5.0;
        float ss = 1.0;
			
		vec3 l = normalize(lp()-rp);          
		vec3 n = normal(rp);				
		vec3 v = normalize(ro-rp);
        vec3 h = normalize(l+v);		
			
		float illumination  = ka*ao(rp,n, aof) 				
							+ max(kd*dot(l,n),0.0)
                            + max(ks*pow(dot(n,h),a),0.0);
        
        #ifdef SHADOWS
        	illumination += ss*softShadow(rp, lp());
        #endif
        
		res = d.rgb*illumination;
	}
	return res;
}

// Function 3203
bool rayPlaneIntersection( Ray ray, Plane plane, out float t ){
    float dotVN = dot( ray.dir, plane.abcd.xyz );
   
    if ( abs( dotVN ) < EPSILON ) {
        return false;
    }
    
	t = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;
    
    return ( t > 0.0 );
}

// Function 3204
vec3 sceneNormalEdge(vec3 p, out float edge, float t)
{ 
	const float det = 0.02;
	vec3 e = vec3(0.0,det,0.0);

	float m;
	float d1=scene(p-e.yxx, m, t),d2=scene(p+e.yxx, m, t);
	float d3=scene(p-e.xyx, m, t),d4=scene(p+e.xyx, m, t);
	float d5=scene(p-e.xxy, m, t),d6=scene(p+e.xxy, m, t);
	float d=scene(p, m, t);
	
	edge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder
	//edge=min(1.0, pow(edge, 0.5)*20.0);
	edge *= 100.0;
	edge = clamp(0.0, 1.0, edge);
	return -normalize(vec3(d1-d2,d3-d4,d5-d6));
}

// Function 3205
float godRays(vec2 uv)
{
   	float ra =0.0;
	vec2 sunPos = vec2(dot( sunLight, camMat[0] ),dot( sunLight, camMat[1] ) )-vec2(0.05,-.15);
   	vec2 p = uv-sunPos;
    float add = hash12(uv*4000.)*.02;
    
    
 	for (float x = .1; x < 1.; x+=.02)
	{
		float z = max(textureLod(iChannel3,(sunPos+(p*(x+add))+1.)*.5, 0.).w, 300.0)-300.;
		ra+= z*x;
	}
   
    return ra*.00001;
}

// Function 3206
float castRay2(const vec3 ro, const vec3 rd, const float ret, out float resT) {
    
    float t2 = 0.0;
    float ret2 = ret;
    
    for (int i = 0; i < 256; i++) {
        vec3 p2 = ro + rd*t2;
        float h2 = map(p2);
        
        //h = min(h, h2);
        if (h2 > 0.0 && h2 < 0.01 && (ret == 0.0 || t2 < resT)) {
            resT = t2;
            ret2 = 1.0;
        }
        if (t2 >= 10.0) {
            break;
        }
        
        t2 += h2;
    }
    
    return ret2;
}

// Function 3207
vec3 ct_vfield_normal(
    in vec3 p,
    float npow
){
    vec3 g = vec3(0.0, 0.0, 0.0);
    
    const int imax = CT_N + 1;
    
    for (int i = 0; i < imax; ++i)
    {
        vec3 dif = g_vfp[i].p - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1] + dif[2] * dif[2];
        float mass = pow(sum, npow);
        
      	g[0] = g[0] + g_vfp[i].m * dif[0] / mass;
      	g[1] = g[1] + g_vfp[i].m * dif[1] / mass;
        g[2] = g[2] + g_vfp[i].m * dif[2] / mass;
    }
    
    return normalize(g);
}

// Function 3208
Result raymarch_query(Ray ray, float maxdist)
{
    float mint=TOO_FAR;
    float maxt=0.0;
	float travelled=0.0;
    for (int i=0; i<MARCH_ITERATIONS; i++)
    {
    	SDFResult res = sceneSDF(ray.pos);
        
      	maxt = max(maxt, res.dist);    
       	if (res.dist<maxt)    
        {
	        mint = min(mint, res.dist);            
        }
                
        ray.pos += res.dist*ray.dir; 
        travelled += res.dist;
        
        if (travelled>maxdist)
            break;
    }     
    
    Result result = resultSDF(ray.pos);
    result.mint = mint;
    result.travelled=travelled;
    return result;
}

// Function 3209
vec3 getNormal(vec3 p, float t){
    // method to prevent compiler inlining map
    float h = t * MIN_DIST;
    #define ZERO (min(iFrame,0))
    vec3 n = vec3(0.0);
    for(int i=ZERO; i<4; i++) {
        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);
        n += e*map(p+e*h).x;
    }
    return normalize(n);
    //original tetrahedron normal
    //float e = t*MIN_DIST;
    //vec2 h = vec2(1.,-1.)*.5773;
    //return normalize( h.xyy*map( p + h.xyy*e).x + 
	//				  h.yyx*map( p + h.yyx*e).x + 
	//				  h.yxy*map( p + h.yxy*e).x + 
	// 				  h.xxx*map( p + h.xxx*e).x );
}

// Function 3210
vec3 normalAt(vec3 p)
{
 float s=scene(p);
 vec2 e=vec2(0.01,0.0);
 return normalize(vec3(s-scene(p-e.xyy),
                  s-scene(p-e.yxy),
                  s-scene(p-e.yyx)));
}

// Function 3211
vec3 getNormal(vec3 p){
    vec2 ep = vec2(EP, 0);
    return normalize(vec3(
        sdf(p + ep.xyy) - sdf(p - ep.xyy),
        sdf(p + ep.yxy) - sdf(p - ep.yxy),
        sdf(p + ep.yyx) - sdf(p - ep.yyx)
        ));
}

// Function 3212
vec3 FastNormalFilter(sampler2D _tex,ivec2 iU,float strength){
	const ivec2 e = ivec2(1,0);
    float p00 = GetTextureLuminance(_tex,iU);
    float p10 = GetTextureLuminance(_tex,iU + e.xy);
    float p01 = GetTextureLuminance(_tex,iU + e.yx);
    /* Orgin calculate 
    vec3 ab = vec3(1.,0.,p10-p00);
    vec3 ac = vec3(0.,1.,p01-p00);
    vec3 n = cross(ab,ac);
    n.z *= (1.-strength);
    return normalize(n);
	*/
	vec2 dir = p00-vec2(p10,p01);
    return normalize(vec3(dir,1.-strength));
}

// Function 3213
vec3 normal(vec3 p) {
    const vec2 NE = vec2(1e-4, 0.);
    return normalize(scene(p,MIN_EPSILON).xxx-vec3(scene(p-NE.xyy,MIN_EPSILON).x,
                          scene(p-NE.yxy,MIN_EPSILON).x,
                          scene(p-NE.yyx,MIN_EPSILON).x));
}

// Function 3214
vec3 normal(in vec3 at) {
	vec2 e = vec2(.1, .0);
	return normalize(vec3(world(at+e.xyy, vec3(0.))-world(at, vec3(0.)),
		  world(at+e.yxy, vec3(0.))-world(at, vec3(0.)),
		  world(at+e.yyx, vec3(0.))-world(at, vec3(0.))));
}

// Function 3215
float rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) 
{
    //Same principle as lineLineIntersection() :
    //"How far is the plane"/"approach rate".
    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.
    return dot(po-o,pn)/dot(d,pn);
}

// Function 3216
bool rayDiskIntersection( in Ray ray, in float r2, in float R2, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {
    if ( IS_ZERO( ray.dir.z ) )
    	return false;
    
    t = ( -ray.origin.z ) / ray.dir.z;
    
    isect.position_ = ray.origin + ray.dir*t;
    
    float d2 = dot(isect.position_, isect.position_);
    
    if( d2 < r2 || d2 > R2 )
        return false;
    
    if( !forShadowTest ) {
        float R = sqrt(R2);
        isect.uv_.x 		= (isect.position_.x - R)/(2.0*R);
        isect.uv_.y 		= (isect.position_.y - R)/(2.0*R);
        isect.normal_ 		= vec3( 0.0, 0.0, 1.0 );
        isect.tangent_ 		= vec3( 1.0, 0.0, 0.0 );
    }
    
    return true;
}

// Function 3217
vec4 ray_march(in vec3 ray_origin, in vec3 ray_direction)
{
    float total_distance_traveled = 0.0;
    const int NUMBER_OF_STEPS = 64;
    const float MINIMUM_HIT_DISTANCE = 0.001;
    const float MAXIMUM_TRACE_DISTANCE = 1000.0;

    for (int i = 0; i < NUMBER_OF_STEPS; ++i)
    {
        vec3 current_position = ray_origin + total_distance_traveled * ray_direction;
		float distance_to_closest = distance_to_closest_object(current_position);
        if (distance_to_closest < MINIMUM_HIT_DISTANCE) 
        {
            vec3 normal = calculate_normal(current_position);
            
            vec3 light_positions[3];
            light_positions[0] = vec3(1.0+sin(iTime)*5.0, -3.0+3.0*cos(iTime/3.0), 4.0 + 1.0 *sin(iTime/5.0));
            light_positions[1] = vec3(1.0-sin(iTime/2.0)*2.0, -1.0-cos(iTime/2.0), 7.0 + 1.0 -sin(iTime/4.0));
            light_positions[2] = vec3(2.0-sin(iTime/2.0)*2.0, -5.0-sin(iTime/4.0), 2.0 + 1.0 -sin(iTime/1.0));
            vec3 light_intensities[3];
            light_intensities[0] = vec3(0.8, 0.4, 0.4);
            light_intensities[1] = vec3(0.04, 0.9, 0.2);
            light_intensities[2] = vec3(0.1, 0.2, 0.8);
            vec3 direction_to_view = normalize(current_position - ray_origin);float fresnel_base = 1.0 + dot(direction_to_view, normal);
            float fresnel_intensity = 0.04*pow(fresnel_base, 2.0);
            float fresnel_shadowing = pow(fresnel_base, 8.0);            
            float fresnel_supershadowing = pow(fresnel_base, 40.0);      
            float fresnel_antialiasing = 4.0*pow(fresnel_base, 8.0);
            float attenuation =  pow(total_distance_traveled,2.0)/150.0;
            
            vec3 col = vec3(0.0);
            
            for (int j = 0; j < 3; j++)
            {
                vec3 direction_to_light = normalize(current_position - light_positions[j]);
                vec3 light_reflection_unit_vector =
                	 reflect(direction_to_light ,normal);                

                float diffuse_intensity = 0.6*pow(max(0.0, dot(normal, direction_to_light)),5.0);            
                float ambient_intensity = 0.2;            
                float specular_intensity = 
                    1.15* pow(clamp(dot(direction_to_view, light_reflection_unit_vector), 0.0,1.0), 90.0);
                float backlight_specular_intensity =             
                    0.01* pow(clamp(dot(direction_to_light, light_reflection_unit_vector),0.0,1.0), 3.0); 
                
                
            	vec3 colFromLight = vec3(0.0);
                colFromLight += vec3(0.89, 0.35, 0.15) * diffuse_intensity;
                colFromLight += vec3(0.3, 0.1, 0.1) * ambient_intensity;
                colFromLight += vec3(1.0) * specular_intensity;            
                colFromLight += vec3(1.0,0.5,0.5) * backlight_specular_intensity;            
                colFromLight += vec3(1.0, 0.1, 0.2) * fresnel_intensity;
                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_shadowing ;
                colFromLight -= vec3(0.0, 1.0, 1.0) * fresnel_supershadowing ;
                colFromLight += vec3(.3, 0.1, 0.1) - attenuation ; 
               //	colFromLight *= 1.6;
               // colFromLight *= sqrt(light_intensities[j]);
                col += colFromLight;
            }
            return vec4(col, 1.0-fresnel_antialiasing);
        }

        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)
        {
            break;
        }
        total_distance_traveled += distance_to_closest;
    }
    return vec4(0.0);
}

// Function 3218
bool rayMarchTrans(vec3 startPos, vec3 direction, out float rayDist) {
    vec3 position = startPos ;
    bool intersected = false ;
    rayDist = 0.0 ;
    float delta = minPrimStepSize ;
    float precis = 0.0005 ;
    
    for (int i = 0 ; i < primNumSamples ; ++i) {
		if (isIntersectingSmokeShape(position,precis,delta)) {
            return true ;
        } else {
            precis = 0.00005 * rayDist ;
		    rayDist += delta ;
            position = (rayDist)*direction + startPos ;
        }
    }
    
    return false ;
}

// Function 3219
float3 Normal ( float3 p ) {
  float2 e = float2(1.0, -1.0)*0.001;
  return normalize(
                   e.xyy*Map(p + e.xyy).x +
                   e.yyx*Map(p + e.yyx).x +
                   e.yxy*Map(p + e.yxy).x +
                   e.xxx*Map(p + e.xxx).x);
}

// Function 3220
vec3 normal(vec3 sp)
{///had to adjust the normal cause I was getting these weird lines on edges.
    vec3 eps = vec3(.0014, 0.0, 0.0);
    
    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)
                       ,map(sp+eps.yxz) - map(sp-eps.yxz)
                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));
    
    
 return normal;   
}

// Function 3221
vec3 ReflectSpace( vec3 p )
{
    // mirror - to make interesting shapes and break up grid
    p.x = abs(p.x+7.)-7.;
    float aa = .5;
    p.xz = p.xz*cos(aa)+p.zx*sin(aa)*vec2(1,-1);
    p.x = abs(p.x+1.)-1.; aa = -.5; p.xz = p.xz*cos(aa)+p.zx*sin(aa)*vec2(1,-1);
    return p;
}

// Function 3222
vec3 getNormal(in vec3 p) {
	
    const vec2 e = vec2(.001, 0);
    
    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),	
    //                      m(p + e.yyx) - m(p - e.yyx)));
    
    // This mess is an attempt to speed up compiler time by contriving a break... It's 
    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.
    float sgn = 1.;
    float mp[6];
    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);
    for(int i = min(iFrame, 0); i<6; i++){
		mp[i] = map(p + sgn*e6[i/2]);
        sgn = -sgn;
        if(sgn>2.) break; // Fake conditional break;
    }
    
    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));
}

// Function 3223
float fakereflection(vec3 p, vec3 cam) {
  vec3 n = norm(p);
  vec3 inc = reflect(cam, n);
  float s1 = scene(p);
  float avg = 0.;
  float cum = 0.;
  
  for (int i = 0; i < 3; i++) {
    float stp = 0.045*(float(i)+1.);
    vec3 stped = p+inc*stp;
    vec3 n2 = norm(stped);
    stped = mapp(stped);
    float brt = min(length(stped),2.)/2.;
    avg += mix(0., mix(dot(n2,normalize(mapp(p)))*0.5+0.5,1.,brt*0.8), brt*0.3+0.7);//((s2-s1)/stp)*0.5+0.5
    cum += 1.;
  }
  return sharp(avg/cum*0.95);
}

// Function 3224
float ObjRay (vec3 ro, vec3 rd)
{
  const int nStep = 200;
  float dHit, d, s;
  dHit = 0.;
  s = 0.;
  for (int j = 0; j < nStep; j ++) {
    d = ObjDf (ro + dHit * rd);
    dHit += d;
    ++ s;
    if (d < 0.0003 || dHit > dstFar) break;
  }
  qnStep = s / float (nStep);
  return dHit;
}

// Function 3225
vec3 getRay(vec2 pos)
{
    mat3 rmat = getRot(angles);
    vec2 uv = FOV*(pos - R*0.5)/R.x;
    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);
}

// Function 3226
vec3 calcNormal( vec3 pos )
{
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e * SDF(pos+0.0005*e).x;
    }
    return normalize(n);
}

// Function 3227
float BldRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  if (rd.y < 0.) {
    dHit = - (ro.y - 9.) / rd.y;
    for (int j = VAR_ZERO; j < 320; j ++) {
      dstBld = dHit;
      d = BldDf (ro + dHit * rd);
      dHit += d;
      if (d < 0.001 || dHit > dstFar) break;
    }
  } else dHit = dstFar;
  return dHit;
}

// Function 3228
vec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) 
{
	vec3 rdd = rayDirection;
	vec3 roo = rayOrigin;

	// ray-box intersection
    vec3 m = 1.0/rdd;
    vec3 n = m*roo;
    vec3 k = abs(m)*boxHalfSizes;
	
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;

	float timeNear = max( max( t1.x, t1.y ), t1.z );
	float timeFar = min( min( t2.x, t2.y ), t2.z );
	
	if( timeNear > timeFar || timeFar < 0.0)
        return vec4(-1.0);

	vec3 normal = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);
    
	// texture coordinates 
	vec3 uaxis = vec3(1.0,0.0,0.0);
	vec3 vaxis = vec3(0.0,1.0,0.0);
	
	if (abs(normal.x) > 0.9)
	{
		uaxis = vec3(0.0,1.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);
	}
	else if (abs(normal.y) > 0.9)
	{
		uaxis = vec3(1.0,0.0,0.0);
		vaxis = vec3(0.0,0.0,1.0);		
	}
    
    vec3 relPoint = roo + rdd * timeNear;
    
	uv = vec2
	(
		dot(relPoint, uaxis) * 0.25,
		dot(relPoint, vaxis) * 0.25
	);    

	return vec4( timeNear, normal );
}

// Function 3229
vec3 randomRay(in vec3 p) {
    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));
    return rand;
}

// Function 3230
vec3 BlendNormal(vec3 normal){
	vec3 blending = abs(normal);
	blending = normalize(max(blending, 0.00001));
	blending /= vec3(blending.x + blending.y + blending.z);
	return blending;
}

// Function 3231
vec3 getNormal(in vec3 p) {
	const vec2 e = vec2(.001, 0);
	return normalize(
    vec3(map(p + e.xyy) - map(p - e.xyy), 
    map(p + e.yxy) - map(p - e.yxy),	
    map(p + e.yyx) - map(p - e.yyx)));
}

// Function 3232
vec3 ray(float fieldOfView, vec2 size, vec2 fragCoord) {
    vec2 xy = fragCoord - size / 2.0;
    float z = fieldOfView * size.y;
    return normalize(vec3(xy, -z));
}

// Function 3233
vec3 normal( in vec3 p )
{
    // Note the slightly increased sampling distance, to alleviate
    // artifacts due to hit point inaccuracies.
    vec2 e = vec2(0.0025, -0.0025); 
    return normalize(
        e.xyy * map(p + e.xyy) + 
        e.yyx * map(p + e.yyx) + 
        e.yxy * map(p + e.yxy) + 
        e.xxx * map(p + e.xxx));
}

// Function 3234
vec3 calcTreeNormal( in vec3 pos )
{    
  return normalize( vec3(MapTree(pos+eps.xyy) - MapTree(pos-eps.xyy), 0.5*2.0*eps.x, MapTree(pos+eps.yyx) - MapTree(pos-eps.yyx) ) );
}

// Function 3235
float CaveRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 300; j ++) {
    p = ro + dHit * rd;
    d = CaveDf (p);
    if (d < 0.001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 3236
vec3 calcNormal(in vec3 pos)
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 3237
vec3 ray_dir( float fov, vec2 size, vec2 pos ) {
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );	
	float z = size.y * 0.5 * cot_half_fov;	
	return normalize( vec3( xy, -z ) );
}

// Function 3238
vec2 ct_vfield_normal(
    in vec2 p,
    float npow
){
    float eps = 0.00001;
    vec2 g = vec2(eps, eps);
    
    const int imax = CT_N + 1;
    
    for (int i = 0; i < imax; ++i)
    {
        vec2 dif = g_vfp[i].p - p;
        float sum = dif[0] * dif[0] + dif[1] * dif[1];
        float mass = pow(sum, npow);
        if (mass == 0.0) mass = 0.00001;
        
      	g[0] = g[0] + g_vfp[i].m * dif[0] / mass;
      	g[1] = g[1] + g_vfp[i].m * dif[1] / mass;
    }
    
    return normalize(g);
}

// Function 3239
vec3 ComputeNormals(vec3 p)
{
    vec3 o;
    
    vec3 epsilonX = vec3(EPSILON, 0, 0);
    vec3 epsilonY = vec3(0, EPSILON, 0);
    vec3 epsilonZ = vec3(0, 0, EPSILON);
    
    // To estimate the normal in an axis, from a surface point, we move slightly
    // in that axis and get the changing in the distance to the surface itself.
    // If the change is 0 or really small it means the surface doesn't change in that
    // direction, so its normal in that point won't have that axis component.
    float reference = GetNearestShape(p).dist;
    o.x = GetNearestShape(p+epsilonX).dist- reference;
    o.y = GetNearestShape(p+epsilonY).dist - reference;
    o.z = GetNearestShape(p+epsilonZ).dist - reference;
    
    return normalize(o);
}

// Function 3240
float ObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 150; j ++) {
    d = ObjDf (ro + dHit * rd);
    if (d < 0.001 || dHit > dstFar) break;
    dHit += d;
  }
  return dHit;
}

// Function 3241
vec3 RayTrace(in vec2 fragCoord )
{
	vec3 camPos, camUp, camLookat;
	// ------------------- Set up the camera rays for ray marching --------------------
    // Map uv to [-1.0..1.0]
	vec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;
    uv /= 2.0;  // zoom in

#ifdef MANUAL_CAMERA
    // Camera up vector.
	camUp=vec3(0,1,0);

	// Camera lookat.
	camLookat=vec3(0,0.0,0);

    // debugging camera
    float mx=-iMouse.x/iResolution.x*PI*2.0;
	float my=iMouse.y/iResolution.y*3.14*0.95 + PI/2.0;
	camPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.0;
#else
    // Camera up vector.
	camUp=vec3(0,1,0);

	// Camera lookat.
	camLookat=vec3(0,0,0);

    float camSpeed = 0.5;
	float camRad = 6.25;
    float camAngle = sin(iTime*camSpeed)*0.5;
	camPos = vec3(sin(camAngle)*camRad, 0.0, -cos(camAngle)*camRad);
#endif

	// Camera setup for ray tracing / marching
	vec3 camVec=normalize(camLookat - camPos);
	vec3 sideNorm=normalize(cross(camUp, camVec));
	vec3 upNorm=cross(camVec, sideNorm);
	vec3 worldFacing=(camPos + camVec);
	vec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;
	vec3 rayVec = normalize(worldPix - camPos);

	// ----------------------------- Ray march the scene ------------------------------
	vec2 distAndMat;  // Distance and material
	float t = 0.05;
	const float maxDepth = 16.0; // farthest distance rays will travel
	vec3 pos = camPos;
    const float smallVal = 1.0 / 16384.0;
    // ray marching time
    for (int i = 0; i <160; i++)	// This is the count of the max times the ray actually marches.
    {
        // Step along the ray.
        pos = (camPos + rayVec * t);
        // This is _the_ function that defines the "distance field".
        // It's really what makes the scene geometry. The idea is that the
        // distance field returns the distance to the closest object, and then
        // we know we are safe to "march" along the ray by that much distance
        // without hitting anything. We repeat this until we get really close
        // and then break because we have effectively hit the object.
        distAndMat = DistanceToObject(pos);

        // move along the ray a safe amount
        t += distAndMat.x;
        // If we are very close to the object, let's call it a hit and exit this loop.
        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;
    }

	// --------------------------------------------------------------------------------
	// Now that we have done our ray marching, let's put some color on this geometry.
	vec3 finalColor = vec3(0.0);

	// If a ray actually hit the object, let's light it.
    if (t <= maxDepth)
	{
        // calculate the normal from the distance field. The distance field is a volume, so if you
        // sample the current point and neighboring points, you can use the difference to get
        // the normal. This is called a gradient.
        vec3 smallVec = vec3(1.0/4096.0, 0, 0);
        vec3 normalU = vec3(DistanceToObject(pos + smallVec.xyy).x - DistanceToObject(pos - smallVec.xyy).x,
                           DistanceToObject(pos + smallVec.yxy).x - DistanceToObject(pos - smallVec.yxy).x,
                           DistanceToObject(pos + smallVec.yyx).x - DistanceToObject(pos - smallVec.yyx).x)*0.5;
        // If the material says we are on the edge of the font, override the normal with the
        // font texture's gradient. This will give us smoother surfaces on the sides of the font's letters.
        if (distAndMat.y == 0.0) {
		    vec4 tx = SampleFontTex(pos.xy) - 0.5;
            // Put a small number in Z so it can't go to zero.
            normalU = -vec3(-tx.g, tx.b, 0.0001)*2.0*smallVec.x;
        }
        // It looks like ??texture filtering?? can sometimes take the normal to zero length.
        // Compensate so we don't divide by zero in the normalize function.
        normalU = normalU+0.000000001;
        vec3 normal = normalize(normalU);

        // ------ Calculate texture color  ------
        vec3 texColor = vec3(0.3,0.325,0.6)*0.5;
        if (distAndMat.y == 1.0) {
            // Make the "TexFont" word yellow
            if ((floor(pos.y+0.5) == 0.0) && (abs(floor(pos.x+0.5)) <= 3.5)) texColor = vec3(1.0,0.9,0.1);
        }

        // ------ Calculate lighting color ------
        // Sky color
        vec3 lightColor = (saturate(normal.y * 0.5 + 0.5)) * vec3(2.5);

        // Apply the light to the texture.
        finalColor = texColor * lightColor;

        // calculate the reflection vector for highlights
        vec3 ref = reflect(rayVec, normal);
        vec3 refColor = GetReflection(ref);
        refColor *= vec3(1.0, 0.5, 0.2)*2.5*dot(normal, -rayVec);
        finalColor += refColor;

        // debug visualize length of gradient of distance field to check distance field correctness
        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);
        //finalColor = normal * 0.5 + 0.5;
	}
    else
    {
        // Our ray trace hit nothing, so draw background.
        finalColor = GetReflection(rayVec);
    }

	// output the final color without gamma correction - will do gamma later.
	return vec3(clamp(finalColor, 0.0, 1.0));
}

// Function 3242
vec3 raymarch(vec2 uv) {
    vec3 col = vec3(0);
    
    vec3 s=vec3((curve(time, 0.7)-.5)*5.0,0,-150.0);
    vec3 t=vec3(0,0,0);
    
    s -= tunnel(s);
    t -= tunnel(t);
    
    vec3 cz=normalize(t-s);
    vec3 cx=normalize(cross(cz, vec3(sin(time*0.1)*0.1,1,0)));
    vec3 cy=normalize(cross(cz, cx));
    
    float fov = 0.3 + pulse(bpm*0.5,20.0)*0.2;
    vec3 r=normalize(uv.x*cx + uv.y*cy + fov*cz);
    
    float maxdist=300.0;
        
    vec3 p=s;
    float at=0.0;
    float dd=0.0;
    for(int i=0; i<200; ++i) {
        float d=map(p);
        if(d<0.001) {
            if(tra>0.5) {
                //vec3 n=getnorm(p);
                float didi = 1.0-length(p)/60.0;
                col += vec3(0.0002*float(i)*didi,0,0);
                d=0.2;
            } else {
                break;
            }
        }
        if(dd>maxdist) break;
        p+=r*d;
        dd+=d;
        at += (1.0-tra)*1.0/(1.0+d);
    }

    float fog = 1.0-clamp(dd/maxdist,0.0,1.0);
    
    vec3 n=getnorm(p);
    vec3 l=normalize(vec3(1,3,-2));
    vec3 h=normalize(l-r);
    float spec=max(0.0,dot(h,n));
    float fres=pow(1.0-abs(dot(r,n)), 3.0);
    
    vec3 col1 = vec3(0.7,0.8,0.6);
    vec3 col2 = vec3(0.8,0.8,0.5)*3.0;
    float iter = pow(abs(r.z), 7.0);
    vec3 atmocol = mix(col1, col2, iter);
    
    float ao=1.0;//getao(p,n,3.0) * getao(p,n,1.5) * 3.0;
    float sss=getsss(p,r,2.0) + getsss(p,r,10.0);
    
    float fade = fog * ao;
    col += (max(0.0,dot(n,l)) * .5+.5) * 0.7 * fade * atmocol * 0.2;
    col += max(0.0,dot(n,l)) * (0.3 + 0.6*pow(spec,4.0) + 0.9*pow(spec,30.0)) * fade * atmocol*0.7;
    col += pow(1.0-fog,5.0) * vec3(0.7,0.5,0.2);
    col += pow(oo*0.15,0.7)*vec3(0.5,0.7,0.3);
    
    col += pow(at*0.035,0.4) * atmocol;

    col += key(fract(length(p)*0.02)) * vec3(0.2,1.0,fract(trp.x*0.1)) * 10.0 * fog;
    col *= 1.8,

    col = tweakcolor(col);
    
    col *= 1.2-length(uv);
    
    return col;
}

// Function 3243
vec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)
{
    tc.x *= cam.Aspect;

    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;
    
    glp = cam.Right * llp.x + cam.Up * llp.y;
    
    vec3 dir = normalize(imgPos * S1 - glp);

    return dir;
}

// Function 3244
float castRayGlass( in vec3 ro, in vec3 rd ) {
    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );
    rd1 = rotateY( rd1, CLOCK_ROT_Y );

    float t = -1.;
    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);
    if (bb.y > 0.) {
        t = max(bb.x, 0.);
        float tmax = bb.y;
        for( int i=0; i<32; i++ ) {
            float precis = 0.0001;
            float res = mapGlass( p1+rd1*t );
            if( abs(res)<precis || t>tmax ) break; 
            t += res;
        }

        if( t>tmax ) t=-1.0;
    }
    return t;
}

// Function 3245
vec3 normal(in Ray ray) {
    vec2 eps = vec2(0.0001, 0);
    float baseDist = sceneDist(ray).d;
 	return normalize(vec3(
        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)).d - 
        sceneDist(Ray(ray.origin - eps.xyy, ray.dir)).d,
        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)).d -
        sceneDist(Ray(ray.origin - eps.yxy, ray.dir)).d,
        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)).d -
        sceneDist(Ray(ray.origin - eps.yyx, ray.dir)).d
        ));
}

// Function 3246
void normal(inout ray r){
	float d=dist(r);
	vec3 n=vec3(SAMPLE_RADIUS,0.0,0.0);
	ray r0=r;
	ray r1=r;
	ray r2=r;
	r0.p+=n.xyy;
	r1.p+=n.yxy;
	r2.p+=n.yyx;
	r.n=normalize(vec3(dist(r0)-d,dist(r1)-d,dist(r2)-d));
}

// Function 3247
vec3 sdfNormal(vec3 p)
{
    float s = sdf(p);
    vec3 eps = vec3(EPSILON_NORMAL, -EPSILON_NORMAL, 0.0);    
	float dX = s - sdf(p + eps.yzz);
	float dY = s - sdf(p + eps.zyz);
	float dZ = s - sdf(p + eps.zzy);
	return normalize(vec3(dX,dY,dZ));
}

// Function 3248
define ARRAY_PRINT( STATE, STYLE, CHAR_ARRAY ) { for (int i=0; i< NO_UNROLL( CHAR_ARRAY.length() ); i++) PrintCh( STATE, STYLE, CHAR_ARRAY[i] ); }

// Function 3249
bool rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, out float t){
	vec3 e1,e2,h,s,q;
	float a,f,u,v;
	e1 = v1-v0;
	e2 = v2-v0;

	h = cross(d,e2);
	a = dot(e1,h);

	if (a > -0.00001 && a < 0.00001)
		return false;

	f = 1.0 / a;
	s = p-v0;
	u = f * dot(s,h);

	if (u < 0.0 || u > 1.0)
		return false;

	q = cross(s,e1);
	v = f * dot(d,q);

	if (v < 0.0 || u + v > 1.0)
		return false;

	// at this stage we can compute t to find out where
	// the intersection point is on the line
	t = f * dot(e2,q);

	//uv = vec2(u, v);
	
	if (t > 0.00001) // ray intersection
		return true;

	// this means that there is a line intersection
	// but not a ray intersection
	return false;
}

// Function 3250
vec3 normal(vec3 P)
{
	vec2 eps = vec2(0.,0.001);
    return normalize(vec3(
        sdScene(P+eps.yxx).x - sdScene(P-eps.yxx).x, 
		sdScene(P+eps.xyx).x - sdScene(P-eps.xyx).x, 
        sdScene(P+eps.xxy).x - sdScene(P-eps.xxy).x));
}

// Function 3251
vec3 SphereTracedObjectNormal(in vec3 p)
{
	float eps = 0.0001;
	vec3 n;
	float v = SphereTracedObject(p);
	n.x = SphereTracedObject( vec3(p.x+eps, p.y, p.z) ) - v;
	n.y = SphereTracedObject( vec3(p.x, p.y+eps, p.z) ) - v;
	n.z = SphereTracedObject( vec3(p.x, p.y, p.z+eps) ) - v;
	return -normalize(n);
}

// Function 3252
bool MarchCameraRay( vec3 start, vec3 dir, out vec3 pos CACHEARG )
{
    vec3 boundsStart;
    if ( !RayHitsBlobBounds( start, dir, boundsStart ) )
	    return false;
    
    // assumes dir is normalized
    pos = boundsStart + dir * EPSILON;
    
    float prevMarchDist = EPSILON;
    float prevSurfaceDist = BlobDist( boundsStart CACHE );
    
    #if DEBUG_BOUNDS
    	if ( prevSurfaceDist <= 0.0 )
        {
            pos = boundsStart;
            return true;
        }
    #endif
    
    for ( int i = 0; i < MAX_RAYMARCH_STEPS; i++ )
    {
        float surfaceDist = BlobDist( pos CACHE );
        if ( surfaceDist <= EPSILON )
        {
            if ( surfaceDist < 0.0 )
            	pos = RefineSurfacePos( pos, dir, surfaceDist, prevSurfaceDist, prevMarchDist, EPSILON CACHE );
            return true;
        }
        
        // calculate the gradient of the function along the ray.
        // we're hoping that the gradient doesn't get suddenly steeper ahead of us.
        // to protect against that, we don't go lower than MIN_GRADIENT.
        // we want MIN_GRADIENT as low as possible without artifacts.
        float gradientAlongRay = (prevSurfaceDist - surfaceDist) / prevMarchDist;
        float safeGradient = max( gradientAlongRay, MIN_GRADIENT );
        
        float addDist = (surfaceDist + EPSILON) / safeGradient;
        prevMarchDist = addDist;
        
        prevSurfaceDist = surfaceDist;
        pos += dir * addDist;
        
        vec3 relPos = pos - BLOB_BOUNDING_CENTER;
        relPos *= BLOB_BOUNDING_SCALE;
        if ( dot( relPos, relPos ) > BLOB_BOUNDING_RADIUS_SQR )
            return false;
    }
    
    return true;
}

// Function 3253
vec3 calcnormal(vec3 p) {
  const vec2 e = vec2(0.001, 0.0);
  vec3 n = vec3(map(p + e.xyy) - map(p - e.xyy),
                map(p + e.yxy) - map(p - e.yxy),
                map(p + e.yyx) - map(p - e.yyx));
  return normalize(n);
}

// Function 3254
vec3 terrainCalcNormalMed( in vec3 pos, float t ) {
	float e = 0.005*t;
    vec2  eps = vec2(e,0.0);
    float h = terrainMed( pos.xz );
    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));
}

// Function 3255
seg rayseg(in ray r, in qdr q) {
	vec3 o = r.o - q.l;
    float a = dot(q.c.xyz, r.d * r.d),
    	  b = dot(q.c.xyz * 2., o * r.d),
    	  c = dot(q.c.xyz, o * o) + q.c.w;
    if (a != 0.) {
        float h = b * b - 4. * a * c;
        if (h < 0.) return nullSeg;
        h = sqrt(h);
        return seg(vec2(-b-h, -b+h) * (.5 / a), ivec2(q.d, -q.d));
    }
    return seg(vec2(-c / b), ivec2(q.d));
}

// Function 3256
Ray newRay(vec3 ro,vec3 rd){float tmin = .10;float tmax = 20.0;return Ray(ro,rd,tmin,tmax,0.,-1,false);}

// Function 3257
vec4 raymarch(vec3 eye, vec3 dir)
{
    vec3 info = vec3(0);
    float depth = 0.0, i;
    for (i=0.0; i<256.0 && depth<MAX_DIST; i++){
        vec3 p = eye + depth * dir;
        info = thing(p);
        if (abs(info.x) < EPSILON * depth)break;
        depth += info.x * remap(i,0.0,256.0,0.5,1.0);
    }
    return vec4(depth, info.yz, i/256.0);
}

// Function 3258
vec3 calcNormal(vec3 pos) 
{
	const vec3 eps = vec3(0.005, 0.0, 0.0);
                          
    return normalize(
        vec3(map(pos + eps).x - map(pos - eps).x,
             map(pos + eps.yxz).x - map(pos - eps.yxz).x,
             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) 
    );
}

// Function 3259
vec3 faceToRay(FaceInfo info)
{
    //info.id = [0=x+,1=x-, 2=y+,3=y-, 4=z+,5=z-]
    //fAxis   = [0.01;0.51; 1.01;1.51; 2.01;2.51]
    float eps = 0.01;              
    float fAxis = info.id/2.0+eps;
    bvec3 axis  = lessThan(abs(floor(fAxis)-vec3(0,1,2)),vec3(eps));
    vec3 camU = (axis.y)?vec3(0,0,1):vec3(0,1,0);
    vec3 camD = vec3(axis.x?1:0,axis.y?1:0,axis.z?1:0);
    vec3 camR = cross(axis.z?-camD:camD,camU);
    float axisSign = (fract(fAxis)<0.5)?1.:-1.;
    return  normalize(camR*(info.uv.x*2.-1.)
                     +camU*(info.uv.y*2.-1.)
                     +camD*axisSign);
}

// Function 3260
vec4 rayMarching(vec3 viewVec, vec3 eyePos, out bool isHit, out vec3 normal, float epsilon, out float AO)
{
	isHit = false;
	float depth = 0.1;

	int count = 0;

	vec3 endPoint;

	float radius = 1.0;
	vec3 c = vec3(10.0);

	int maxRayStep = 128;

	for(int i=0; i<maxRayStep; i++)
	{
		endPoint = eyePos + depth * viewVec;

		vec2 result = SDF( endPoint, eyePos, viewVec);

		float dist = result.x;

		if(dist < epsilon * depth) 
		{
			isHit = true;       

			normal = getSurfaceNormal(endPoint, epsilon, eyePos, viewVec);
			AO = getAO(endPoint, normal);

			return vec4(endPoint, result.y);
		}

		depth += dist * STEP_SIZE_SCALER;// + epsilon * log(float(i) + 1.0);

		if(depth >= MAX_RAYDISTANCE)
		{			
			return vec4(endPoint, -1.0);
		}
	}

	return vec4(endPoint, -1.0);
}

// Function 3261
vec3 getRay(vec2 uv, vec3 eye, vec3 up, vec3 right)
{
    float nearWidth = tan(fov/2.0) * near * 2.0;
    float nearHeight = iResolution.y/iResolution.x * nearWidth;
    vec3 front = normalize(cross(up, right));
    right = normalize(cross(front, up));
    vec3 p = eye + front * near + right * uv.x * nearWidth + up * uv.y * nearHeight;
    return normalize(p - eye);
}

// Function 3262
float ExObjRay (vec3 ro, vec3 rd)
{
  float dHit, d;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    d = ExObjDf (ro + dHit * rd);
    if (d < 0.0005 || dHit > dstFarEx) break;
    dHit += d;
  }
  return dHit;
}

// Function 3263
vec3 box_normal_from_point(vec3 point,vec3 box_extents)
{
    vec3 normal = vec3(0.0);
    float m = FAR;
    float d;

    d = abs(box_extents.x - abs(point.x));
    if (d < m)
    {
        m = d;
        normal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X
    }

    d = abs(box_extents.y - abs(point.y));
    if (d < m)
    {
        m = d;
        normal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y
    }

    d = abs(box_extents.z - abs(point.z));
    if (d < m)
    {
        m = d;
        normal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z
    }

    return normal;
}

// Function 3264
vec3 calcNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.25, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
}

// Function 3265
vec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )
{
    return sign(pos)*normalize(max(abs(pos)-siz,0.0));
}

// Function 3266
vec3 raymarch(SAMPLERTYPE sampler, vec3 ray_start, vec3 step, float max_dist)
{
	float step_dist = length(step);
	float dist = 0.0;
	vec3 color = vec3(0.0);
	vec3 sdt = vec3(1.0);

	vec3 p = ray_start;
	/*if (si.x <= 0) */{
		for (int i = 0; i < samples && dist < max_dist; i++, dist += step_dist, p += step) {

			// float r = d/2.0;
			vec3 p2 = p - spiral_origin;
			if (in_galaxy(p2)) {
				float lp2 = length(p2);

				float bulge_density = pow(max(2.0 - lp2/bulge.y, 0.0), bulge.z);
				float density = galaxy_density(sampler, p2, bulge_density, tweaks1.y, tweaks1.z);
				float clamped_density = clamp(density, 0.0, 1.0);
				float eps = tweaks2.y;
				float dif = clamp(
					(galaxy_density(sampler, p2 - eps*normalize(p2), bulge_density, tweaks1.y, tweaks1.z) - density) / eps,
					0.0, 1.0);

				sdt *= transmittance.xyz*(1.0 - clamped_density);
				// float clamped_bulge_density = clamp(bulge_density, 0.0, 1.0);
				float bulge_light_intensity = bulge.y*bulge.y * 2.0 * PI / (10.0 * lp2); //Roughly solid angle of bulge from p2's vantage point.

#ifdef BACK_TO_FRONT
				color =
					(
						color + //Color from previous steps
						mix(color_ramp(clamped_density * step_dist * 30.0), bulge_color * bulge_density, bulge_density) * tweaks2.z + //Emissivity
						bulge_light_intensity * tweaks2.x * dif*bulge_color //Diffuse lighting
					) *
					(vec3(1.0) - transmittance.xyz*clamped_density); //Attenuation
#else
				if (length(sdt) < 0.005) {
					// samples = i;
					// color = vec3(1.0, 0.0, 0.0);
					break;
				}
				color +=
					(
						mix(color_ramp(clamped_density * step_dist * 30.0), bulge_color * bulge_density, bulge_density) + //Emissivity
						bulge_light_intensity * tweaks2.x * dif*bulge_color //Diffuse lighting
					) * sdt; //Attenuation
#endif
			}
		}
	}
	return clamp(color * brightness, 0.0, 100000.0);
}

// Function 3267
float ray_marching( vec3 origin, vec3 dir, float start, float end ) {
	float depth = start;
	for ( int i = 0; i < max_iterations; i++ ) {
		float dist = dist_field( origin + dir * depth );
		if ( dist < stop_threshold ) {
			return depth;
		}
		depth += dist;
		if ( depth >= end) {
			return end;
		}
	}
	return end;
}

// Function 3268
vec3 shadeRay(lighting lit,vec3 end){
    vec3 normal=estimateNormal(end);
    vec3 phongShaded=phong(lit,normal,end)-0.2;
    return phongShaded;
}

// Function 3269
vec4 raymarch(vec3 p, vec3 d)
{
    float S = 0.0;
    float L = S;
    vec3 D = normalize(d);
    vec3 P = p+D*S;
    for(int i = 0;i<240;i++)
    {
        S = model(P);
        L += S;
        P += D*S;
        if ((L>MAX) || (S<PRE)) {break;}
    }
    return vec4(P,min(L/MAX,1.0));
}

// Function 3270
bool NeedsReflectionRays(in Material m)
{
    return (m.flags & MATERIAL_NEEDS_REFLECTION_RAYS) != 0;
}

// Function 3271
vec3 normalForCube(vec3 hit, Box cube)
{  
   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   
   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   
   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   
   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      
   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   
   else return vec3(0.0, 0.0, 1.0);   
}

// Function 3272
vec3 GetNormal(vec3 p)
{
    int dummy = 0;
    return 
    normalize(vec3(
		CombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),
		CombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),
		CombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)
		));
}

// Function 3273
Intersection RayPlane(Ray ray, Plane p)
{
	Intersection i;
	float num = p.d-dot(p.n, ray.o);
	float denom = dot(p.n, ray.dir);
	float t = num/denom;
	if(t > EPSILON)
	{
		i.p = ray.o + ray.dir * t;
		// hit rectangle?
		if ( i.p.x < -8.0 || i.p.x > 8.0 || i.p.z < 4.0 || i.p.z > 24.0 ) {
			// missed
			i.dist = ZMAX;
		} else {
			i.n = p.n;
			i.dist = t;
		}
	}
	else
	{
		// did not hit plane
		i.dist = ZMAX;
	}
	return i;
}

// Function 3274
vec3 randomHemiRay(in vec3 d, in vec3 p) {
    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));
    return rand*sign(dot(d,rand));
}

// Function 3275
vec3 calc_normal(in vec3 pos) {
    const float ep = 0.0001;
    vec2 e = vec2(1.0, -1.0) * 0.5773;
    return normalize(e.xyy * sdf(pos + e.xyy * ep) + 
                     e.yyx * sdf(pos + e.yyx * ep) + 
                     e.yxy * sdf(pos + e.yxy * ep) + 
                     e.xxx * sdf(pos + e.xxx * ep));
}

// Function 3276
vec3 computeNormal(vec3 pos) {
    vec3 epsilon = vec3(0.0, 0.001, 0.0);
    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),
                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),
                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));
}

// Function 3277
vec4 rayPlane(vec3 rp, vec3 rd, vec3 pos, vec3 normal) {
    float dst = dot(rp-pos,normal)/dot(rd,normal);
    if (dst < 0.) return vec4(normal,-dst);
    return NNO;
}

// Function 3278
vec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {
    specularBounce = false;
    
    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );
    if(  !matIsSpecular( m ) ) {
        return r;
    } else {
        specularBounce = true;
        
        float n1, n2, ndotr = dot(rd,n);
        
        if( ndotr > 0. ) {
            n1 = 1.0; 
            n2 = 1.5;
            n = -n;
        } else {
            n1 = 1.5;
            n2 = 1.0; 
        }
                
        float r0 = (n1-n2)/(n1+n2); r0 *= r0;
		float fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);
        
        vec3 ref =  refract( rd, n, n2/n1 );        
        if( ref == vec3(0) || hash1(seed) < fresnel ) {
            ref = reflect( rd, n );
        } 
        
        return ref;
	}
}

// Function 3279
vec3 calcray(vec3 campos, vec3 camtgt, vec3 camup, vec2 st) {
    vec3 camdir = normalize(camtgt - campos);
    vec3 camright = normalize(cross(camup, campos));
	camup = cross(camdir, camright);

    return normalize(camright * st.x + camup * st.y + camdir);
}

// Function 3280
vec4 castRay( in vec3 ro, in vec3 rd )
{
    const float precis = 0.001;
    float h = 1.0;

    float t = 0.1;
    float sid = -1.0;
	float dsp = 0.0;
	float ttt = 0.0;
    for( int i=0; i<128; i++ )
    {
	    vec4 res = map( ro+rd*t );
        if( abs(h)<(precis*t) || t>maxd ) break;
        h = res.x;
	    sid = res.y;
		dsp = res.z;
		ttt = res.w;
        t += min( h, 0.2 );
    }

    return vec4( t, sid, dsp, ttt );
}

// Function 3281
vec4 planeProjectNormalize(vec4 v, vec4 n){
    return normalize(v - n *dot(v, n));
}

// Function 3282
vec3 GetSceneNormal( const in vec3 vPos )
{
    const float fDelta = 0.000001;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetSceneDistance( vPos + vOffset1 ).x;
    float f2 = GetSceneDistance( vPos + vOffset2 ).x;
    float f3 = GetSceneDistance( vPos + vOffset3 ).x;
    float f4 = GetSceneDistance( vPos + vOffset4 ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 3283
Material NormalMaterial(vec3 albedo, int flags)
{
    return Material(albedo, vec3(0), flags);
}

// Function 3284
vec3 normal(in vec3 pos)
{
	vec2 e = vec2(1., -1.)*.5773*.0005;
	return normalize(e.xyy*de(pos + e.xyy) +
		e.yyx*de(pos + e.yyx) +
		e.yxy*de(pos + e.yxy) +
		e.xxx*de(pos + e.xxx));
}

// Function 3285
bool ray_vs_aabb(vec3 o, vec3 dir, vec3 bmin, vec3 bmax, inout vec2 e ) {
    vec3 a = ( bmin - o ) / dir;
    vec3 b = ( bmax - o ) / dir;
    
    vec3 s = min( a, b );
    vec3 t = max( a, b );
    
    e.x = max( max( s.x, s.y ), max( s.z, e.x ) );
    e.y = max( min( t.x, t.y ), max( t.z, e.y ) );
    
    return e.x < e.y;
}

// Function 3286
ray setupRay(vec2 uv, float k, float t) {

	mat3 rot = rotationXY( vec2( t*0.501, t*0.602 ) );
	ray r;
	r.light = vec3(0.0);
	r.transmit = vec3(1.0);
	r.p = rot * vec3(0.3, -2.0, -3.5);
	r.d = rot * normalize(vec3(uv.x, uv.y+0.75, 1.3));

	return r;
}

// Function 3287
void RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)
{
    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));
    
    float rayDistance = c_minimumRayHitTime;
    float lastRayDistance = c_minimumRayHitTime;
    
    float lastHitInfoDist = 0.0f;
    
    SRayHitInfo newHitInfo = oldHitInfo;
    newHitInfo.hitAnObject = false;
    
    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)
    {
        vec3 rayPos = startingRayPos + rayDistance * rayDir;
        
        newHitInfo = TestSceneMarch(rayPos);
        
        // these two lines are so that the material code goes away when the test functions are inlined
        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);
        newHitInfo.material = dummyMaterial;
        
        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;
        if (newHitInfo.hitAnObject)
            break;
        
        lastRayDistance = rayDistance;
        rayDistance += max(newHitInfo.dist, c_minStepDistance);

        lastHitInfoDist = newHitInfo.dist;
        
        if (rayDistance > oldHitInfo.dist)
            break;
    }
    
    if (newHitInfo.hitAnObject)
    {
		float refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);
        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);
        
        if (newHitInfo.dist < oldHitInfo.dist)
            oldHitInfo = newHitInfo;
    }
}

// Function 3288
vec3 calculate_normal(vec3 p)
{    
    float height_mod = 1.;
    float prec = 0.01;
    float xp = terrain(p.xz+vec2(prec,0.))*height_mod;
    float xm = terrain(p.xz-vec2(prec,0.))*height_mod;
    
    float zp = terrain(p.xz+vec2(0.,prec))*height_mod;
    float zm = terrain(p.xz-vec2(0.,prec))*height_mod;
    
    //vec3 dx = vec3(p.xz+vec2(0.001, 0.), xp) - vec3(p.xz-vec2(0.001,0.), xm);
    //vec3 dy = vec3(p.xz+vec2(0.,0.001), zp) - vec3(p.xz-vec2(0.,0.001), zm);
    
    vec3 dx = vec3(p.x+prec, xp, p.y) - vec3(p.x-prec, xm, p.y);
    vec3 dy = vec3(p.x, zp, p.y+prec) - vec3(p.x, zm, p.y-prec);
    
    return cross(normalize(dx), normalize(dy));
}

// Function 3289
vec3 reflectPG(vec3 x, vec3 l) {
    return x - (2.*hyperDot(x,l)/hyperDot(l,l))*l;
}

// Function 3290
void sampleArray( out float[25] vid, out float[25] dith, in vec2 uv, in vec2 po )
{
    int s = 0;
    
    for (int y = 0; y < 5; y++) {
        float v = uv.y + po.y * float(y);
        
        for (int x = 0; x < 5; x++, s++) {
            float rVid = texture(iChannel1, vec2(uv.x + po.x * float(x), v)).x;
            float rDith = texture(iChannel0, vec2(uv.x + po.x * float(x), v)).x;
            
            vid[s] = preProcessVid(rVid);
            dith[s] = ditherPotentialToDither(rDith);
        }
    }
}

// Function 3291
vec3 calcNormal(vec3 p)
{
  float e = 0.01;
  vec3 normal = vec3(sceneDf(vec3(p.x+e,p.y,p.z)) - sceneDf(vec3(p.x-e,p.y,p.z)),
                     sceneDf(vec3(p.x,p.y+e,p.z)) - sceneDf(vec3(p.x,p.y-e,p.z)),
                     sceneDf(vec3(p.x,p.y,p.z+e)) - sceneDf(vec3(p.x,p.y,p.z-e)));
  return normalize(normal);
}

// Function 3292
bool IntersectRayTriangle(const Ray r, vec3 v0,vec3 v1,vec3 v2, out vec3 n1, out float tout) 
{
    vec3 e0 = v1-v0, e1 = v2-v0;
    vec3 normal = cross(e0,e1);
    
    // ray vs plane    
    float t = (-dot(normal,r.m_Origin) + dot(normal,v0)) / dot(normal,r.m_Direction);
    
    // point inside triangle
    vec3 point = r.m_Origin + r.m_Direction * t;
    
    if(dot(normal, cross(e0,point-v0)) <= 0.0 ||
       dot(normal, cross(e1,v2-point)) <= 0.0 ||
       dot(normal, cross(v2-v1,point-v1)) <= 0.0) return false;   
    
    tout = t;
    n1 = normalize(normal);
    
	return true;
}

// Function 3293
vec3 getNormal(vec3 p) {
    vec3 n;
    n.x = map(vec3(p.x+EPSILON,p.y,p.z));
    n.y = map(vec3(p.x,p.y+EPSILON,p.z));
    n.z = map(vec3(p.x,p.y,p.z+EPSILON));
    return normalize(n-map(p));
}

// Function 3294
vec3 gray(float t, vec3 under, vec3 over)
{
    return underover(t, gray(t), under, over);
}

// Function 3295
vec4 rayTrace(vec3 pos, vec3 dir){
    for(int i = 0; i < 5; i++){ //to get to a distance inferior to MaxDist
        float dist = distanceEstimation(pos);
        pos += dist * dir;
        if(dist < MaxDist) break;
    }
    vec3 n;
    if(!trace(pos, dir, n))
        return vec4(backgroundColor(dir), 20.0);
    return vec4(directLight(pos, n)+ambientLight(pos), length(CamPos - pos));
}

// Function 3296
vec3 normal( in vec3 pos, in float d )
{
	vec2 eps = vec2( d *d* .003+.01, 0.0);
	vec3 nor = vec3(
	    map(pos+eps.xyy) - map(pos-eps.xyy),
	    map(pos+eps.yxy) - map(pos-eps.yxy),
	    map(pos+eps.yyx) - map(pos-eps.yyx) );
	return normalize(nor);
}

// Function 3297
float raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations
){dist = 0.0 + 110.1*hash1(gl_FragCoord.xy + time)
 ;float minStep = .01
 ;vec2 mapRes
 ;for (int i = 1; i <= MAX_RAYMARCH_ITER; i++
 ){p = ray_start + ray_dir * dist
  ;mapRes = map(p, ray_dir)
  ;if (mapRes.y < MIN_RAYMARCH_DELTA
  ){iterations = i
   ;return mapRes.x
   ;}
  ;dist += max(mapRes.y, minStep)
  ;}
 ;return -1.;}

// Function 3298
vec3 normal(vec3 pos) {
    
    float dx = dist(pos + EPS_VEC.xyy) - dist(pos - EPS_VEC.xyy);
    float dy = dist(pos + EPS_VEC.yxy) - dist(pos - EPS_VEC.yxy);
    float dz = dist(pos + EPS_VEC.yyx) - dist(pos - EPS_VEC.yyx);
    return normalize(vec3(dx,dy,dz));
}

// Function 3299
float intersectReflection( in vec3 ro, in vec3 rd ) {
	const float precis = 0.00125;
    float h = precis*2.0;
    float t = 0.;
        
    float d = -(ro.y)/rd.y;
    float maxdist = d>0.?d:500.;
    
	for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {
        h = map( ro+rd*t );
        if( h < precis ) {
            return t;
        } 
        t += h+0.01*t;
        if( t > maxdist ) {
            return maxdist;
        }
    }
    return -1.;
}

// Function 3300
vec3 computePixelRay( in vec2 p, out vec3 cameraPos )
{
    // camera orbits around explosion
	
    float camRadius = CAM_DIST;
	// use mouse x coord
	float a = iTime*CAM_ROTATION_SPEED;
    float b = CAM_TILT * sin(a * .014);
#ifndef SHADERTOY_APP
	if( iMouse.z > 0. )
    {
		a = iMouse.x;
#ifndef ALTERNATE_MOUSE
        b = iMouse.y/iResolution.y - 0.5;
#else
		b = 0.0;
#endif
    }
#endif
    float phi = b * 3.14;
    float camRadiusProjectedDown = camRadius * cos(phi);
	float theta = -(a-iResolution.x)/80.;
    float xoff = camRadiusProjectedDown * cos(theta);
    float zoff = camRadiusProjectedDown * sin(theta);
    float yoff = camRadius * sin(phi);
    cameraPos = vec3(xoff,yoff,zoff);
     
    // camera target
    vec3 target = vec3(0.);
     
    // camera frame
    vec3 fo = normalize(target-cameraPos);
    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));
    vec3 up = normalize(cross(fo,ri));
     
    // multiplier to emulate a fov control
    float fov = .5;
	
    // ray direction
    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);
	
	return rayDir;
}

// Function 3301
vec2 castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = float(num);
    
#if 0
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
	float precis = 0.002;
    float t = tmin;
    float m = -1.0;
    for( int i=0; i<500; i++ )
    {
	    vec2 res = map( ro+rd*t );
        if( res.x<precis || t>tmax ) break;
        t += res.x;
	    m = res.y;
    }

    if( t>tmax ) m=-1.0;
    return vec2( t, m );
}

// Function 3302
vec3 get_normal(int v) {
   int xyz = get_data(normals_offset, v);
   ivec3 XYZ = (ivec3(xyz) >> ivec3(0,10,20)) & ivec3(1023); 
   return vec3(-1) + vec3(XYZ) / 512.0;    
}

// Function 3303
vec3 calcNormal(vec3 pos) {
    float eps = 0.001;
	const vec3 v1 = vec3( 1.0,-1.0,-1.0);
	const vec3 v2 = vec3(-1.0,-1.0, 1.0);
	const vec3 v3 = vec3(-1.0, 1.0,-1.0);
	const vec3 v4 = vec3( 1.0, 1.0, 1.0);
	return normalize( v1 * map( pos + v1*eps ) +
    	              v2 * map( pos + v2*eps ) +
        	          v3 * map( pos + v3*eps ) +
            	      v4 * map( pos + v4*eps ) );
}

// Function 3304
vec3 getRayDirection(vec2 uv)
{
    vec2 mouseUV = getMouseUV();
    rayOrigin.yz *= rotation2d(mix(-PI/2.0, PI/2.0, mouseUV.y));
    rayOrigin.xz *= rotation2d(mix(-PI, PI, mouseUV.x));
    
    vec3 cameraForward = normalize(cameraTarget - rayOrigin);
    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));
    vec3 cameraUp = normalize(cross(cameraRight, cameraForward));
    
    vec3 rayDirection = normalize(uv.x * cameraRight + uv.y * cameraUp + cameraForward);
    return rayDirection;    
}

// Function 3305
vec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere, out vec2 uv)
{
	//get the vector from the center of this circle to where the ray begins.
	vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, rayDir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return vec4(-1.0);

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return vec4(-1.0);

	//ray now found to intersect sphere, compute smallest t value of intersection
    // NOTE: this will report a miss if ray starts inside the sphere.
	float collisionTime = -b - sqrt(discr);
    
    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz);
    
    // texture coordinates are just the angular part of spherical coordiantes of normal
    uv = vec2
	(
		atan(normal.z, normal.x),
		acos(normal.y)
	);
    
    return vec4 (collisionTime, normal);
}

// Function 3306
vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x + 
					  e.yyx*map( pos + e.yyx ).x + 
					  e.yxy*map( pos + e.yxy ).x + 
					  e.xxx*map( pos + e.xxx ).x );
    /*
	vec3 eps = vec3( 0.0005, 0.0, 0.0 );
	vec3 nor = vec3(
	    map(pos+eps.xyy).x - map(pos-eps.xyy).x,
	    map(pos+eps.yxy).x - map(pos-eps.yxy).x,
	    map(pos+eps.yyx).x - map(pos-eps.yyx).x );
	return normalize(nor);
	*/
}

// Function 3307
vec3 getNormal(vec3 p) {
	float d = getDist(p).x;
    vec2 e = vec2(.01, 0);
    
    vec3 n = d - vec3(
        getDist(p-e.xyy).x,
        getDist(p-e.yxy).x,
        getDist(p-e.yyx).x);
    
    return normalize(n);
}

// Function 3308
vec3 normal(in vec3 surface){
	vec2 offset = vec2(0.01,0.);
	vec3 nDir   = vec3(
		obj(surface + offset.xyy).x,
		obj(surface + offset.yxy).x,
		obj(surface + offset.yyx).x
	)-obj(surface).x;
	
	return normalize(nDir);
}

// Function 3309
vec3 ray_march(vec3 p, vec3 r)
{
    float td = 0.;
    int i;
    for(i = 0; i < MAX_MARCHES; i++)
    {
    	float de = map(p);
        if(de < rayfov*td || td > MAX_DIST)
        {
            break;
        }
        p += de*r;
        td += de;
    }
    vec3 col = vec3(0);
    if(td > MAX_DIST || i > MAX_MARCHES)
    {
        col = sky_color(r);
    }
    else
    {
        vec4 norm = calcNormal(p,MIN_DIST);
        //sampling color at the closest point
        col = sdcolor(p - norm.w*norm.xyz);
        p += r*(norm.w-rayfov*td);
        #ifdef SHADOWS
      		float shad = shadow_march(vec4(p+norm.xyz*0.05,0.), vec4(light,0.), 400.,0.03);
        #else
        	float shad = 1.;
        #endif
       
        col = lighting(vec4(col,0.), vec2(0.2,0.3), vec4(p, 0.), vec4(r, td), norm, shad);
    }
   
    return col;

}

// Function 3310
float castRay2Sun( vec3 startPosition, vec3 lookatDirection )  {
    float step = 0.03;
    float lastStep;
    float altitude = 0.0;
    float lastAltitude;
    float lastY;
    float walkStep = 0.0;
	float delta;
    vec3 p;
    lastStep=step;
    for( int i = 0; i < 20; i++ ) { // GLSL limitation: loop on int only
        p = startPosition + lookatDirection * walkStep;
        altitude = fbm( vec2(p.x, p.z) , HIGHITER);
		delta = p.y -  altitude;
		if( delta < .0){
			return float(i)/20.0; //penumbra is lighter when we are far from hill
        }
        walkStep += step;
        
    }
    return  1.0;   //no penumnra
}

// Function 3311
float rayleigh_phase_func(float mu){
    return 3.*(1.+mu*mu)/(16.*PI);
}

// Function 3312
vec3 normal(in vec3 p, float ef) {
	vec2 e = vec2(0.001*ef, 0);
	return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),	map(p + e.yyx) - map(p - e.yyx)));
}

// Function 3313
float RayLight(vec3 ro,vec3 rd)
{
    float dO=0.0;
    for(int i=0; i<MAX_STEPS; i++)
    {
        vec3 p=ro+rd*dO;
        float ds=GetDist(p);
        dO+=ds;
        if(MAX_DIST<dO || ds<SURF_DIST)
        break;
    }
    return dO;
}

// Function 3314
vec3 Normal(vec3 p){vec2 e=vec2(.01,0);return normalize(vec3(
 df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}

