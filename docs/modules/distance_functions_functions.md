# distance_functions_functions

**Category:** raymarching
**Type:** extracted

## Dependencies
texture_sampling, normal_mapping, lighting, raymarching

## Tags
texturing, animation, particles, lighting, color, audio, raymarching

## Code
```glsl
// Reusable Distance Functions Raymarching Functions
// Automatically extracted from raymarching/raytracing-related shaders

// Function 1
float map(vec3 p)
{
    
    // Positioning the rounded cubes a little off center, in order
    // to break up the space a little.
    //
    // "floor(p)" represents a unique number (ID) for each cube 
    // (based on its unique position). Take that number and produce 
    // a randomized 3D offset, then add it to it's regular position. 
    // Simple.
    float n = sin(dot(floor(p), vec3(27, 113, 57)));
    vec3 rnd = fract(vec3(2097152, 262144, 32768)*n)*.16 - .08;
    
    // Repeat factor. If irregularity isn't your thing, you can get 
    // rid of "rnd" to line things up again.
    p = fract(p + rnd) - .5;
    
    
    // Rounded spherical boxes. The following is made up, but kind of
    // makes sense. Box, minus a bit of sphericalness, gives you a 
    // rounded box. By the way, if we're splitting hairs, this is 
    // technically a bound rather than a distance function, but it 
    // works roughly the same way.
    p = abs(p); 
    return max(p.x, max(p.y, p.z)) - 0.25 + dot(p, p)*0.5;
    
    //return length(p) - 0.225; // Just spheres.
}

// Function 2
vec2 map(in vec3 pos) {
    vec2 planet = planetMap(pos);
    vec2 water = vec2(sdSphere(pos, SCALE*OCEAN), 10.0);
  
    vec2 res = opU(planet, water);
    return res;
}

// Function 3
float scene(vec3 p) {
  float d = 1e8;
  p -= a; // Centre on Wythoff point
  float dP = dot(p,P), dQ = dot(p,Q), dR = dot(p,R), dS = dot(p,S);
  d = min(d,length(p)-swidth); // The vertex
  d = min(d,max(dP,length(p-dP*P)-twidth)); // The four edges
  d = min(d,max(dQ,length(p-dQ*Q)-twidth));
  d = min(d,max(dR,length(p-dR*R)-twidth));
  d = min(d,max(dS,length(p-dS*S)-twidth));
  return d;
}

// Function 4
float distFromPlane(Plane plane, vec3 p) {
	return dot(plane.normal, p) + plane.offset;
}

// Function 5
vec2 sdmat_scene(vec3 p) {
    vec2 object = vec2(sd_object(p), OBJECT_MATERIAL);
    vec2 debug = vec2(sd_debug(p), DEBUG_MATERIAL);
    return object.x < debug.x ? object : debug;
}

// Function 6
float map_tunnel(vec3 pos)
{
    float tc = tunnel_curve(pos.z);
    float dc = dev_tunnel_curve(pos.z);
    pos.x-= tc;
    float zz = pos.z;
    pos.z = 0.;
    float a = atan(dc);
    pos.xz = rotateVec (pos.xz, a*0.5);
    pos.z = zz;
    
    pos.y-= tunnel_curve_y(pos.z);
    
    float tdf = (1. + 0.00007/(1.0011 + cos(tsf*pos.z)));
    float df = -length(pos.xy) + tubeRadius*tdf;
    //df = max(df, pos.y);

    return df;
}

// Function 7
float map(vec3 p){
 
    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.
    
     
	p = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.
    
    
    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.

    // It's an easy field to create, but not so great to hone in one. The "1.4" fudge factor
    // is there to get a little extra distance... Obtained by trial and error.
    return (n - 1.025)*1.33;
    
}

// Function 8
Scene makeScene(in SceneConfig sceneConfig){
    Scene scene;
    scene.plane = Plane(vec4(0.0, -1.7, 0.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0));
    scene.mainSphere = Sphere(vec4(0.0, 0.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0)); 
    
    for(int i = 0; i < numMovingSpheres; i++){
        vec4 pos = getOrbitPos(sceneConfig.spheres[i].orbit);
        scene.spheres[i].pos = pos;
        scene.spheres[i].color = sceneConfig.spheres[i].color;
        scene.spheres[i].radius = sceneConfig.spheres[i].radius;
    }
    scene.sunPos = getOrbitPos(sceneConfig.sunOrbit);
    return scene;
}

// Function 9
vec4 map( in vec3 p )
{
	float h = terrain( p.xz );
	float dis = displacement( 0.25*p*vec3(1.0,4.0,1.0) );
	dis *= 3.0;
	return vec4( (dis + p.y-h)*0.25, p.x, h, 0.0 );
}

// Function 10
float map(vec3 p)
{
    float radius = 0.1;
    
    // Transform coordinate space so spheres repeat
    //vec3 q = fract(p) * 2.0 - 1.0;
    vec3 q = fract(p)-0.5;

    // Signed distance of sphere
    return sphere(q, radius);
}

// Function 11
float de_scene(vec4 p) {
	float d = de_fractal(p);
	d = min(d, de_marble(p));
	d = min(d, de_flag(p));
	return d;
}

// Function 12
void Scene_Union( inout SceneResult a, in SceneResult b )
{
    if ( b.fDist < a.fDist )
    {
        a = b;
    }
}

// Function 13
float distTorus(vec3 pos, float r1, float r2, vec3 z)
{
    float pz = dot(pos,normalize(z));
    return length(vec2(length(pos-z*pz)-r1,pz))-r2;
}

// Function 14
float sphereSDF(sphere s,vec3 p){
	return length(s.p-p)-s.size;
}

// Function 15
SDFResult backgroundSDF( vec3 p )
{
    // floor at y=-1.0
    SDFResult res = planeSDF(Plane(vec3(0.0, -0.1, 0.0), vec3(0.0, 1.0, 0.0), TREES), p);
    // back wall at z=4.0
    //res = opAdd(res, boxSDF2(RoundBox(vec3(0.0, 0.0, 4.1), vec3(20.0, 20.0, 0.1), 0.0, BASIC), p));
    return res;
}

// Function 16
float ToroidalDistance (vec2 p0, vec2 p1)
{
    float dx = abs(p1.x - p0.x);
    float dy = abs(p1.y - p0.y);
 
    dx = min(dx, 1.0 - dx);
    dy = min(dy, 1.0 - dy);
 
    return dx*dx+dy*dy;
}

// Function 17
float planeSdf(vec3 p)
{
    return length(p.z);
}

// Function 18
vec4 map( vec3 pos, mat4 m)
{
    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;
    vec4 val1 = mapFloor( q.xyz );

    vec4 newCarPos = vec4(q.xyz + vec3( 0, -1, 0 ),1)*matRotateY(180.0*pi/180.0);
    vec4 val2 = vec4(0.5,0.5,0.5,CarBodyDisance(newCarPos.xyz ));

    vec4 val4 = combine ( val1, val2 );
    return val4;
}

// Function 19
float mapLight(vec3 p, vec3 origin) {
    float d = 1000.;
    for (int i=0; i<lightsCount; i++)  d = min(d, length(p - getLightPos(origin, i)) - 0.02);
    return d;
}

// Function 20
vec2 map(vec3 p) {
    vec2 res =vec2(1e5,0.);

    vec3 pp = p;
    
    if(ga4>0.) p.xz*=rot(ga4*PI/2.);
    if(ga5>0.) p.y+=ga5*cell;
    
    p.y=mod(p.y+hlf,cell)-hlf;
  
    vec4 P = vec4(p.xyz, 1.0);
    float spc = 6.;
    
    for(int j=0;j<2;j++) { 
        octa(P, 1.,1.,1.,1.); 
        P.xyz = abs(P.zxy)-spc;
    }
    vec3 q = P.xyz;

    q.x = abs(q.x)-spc;
    q.z = abs(q.z)-spc;

    vec3 fq = q;
    fq.x=abs(fq.x)-1.6;
    fq.y=abs(abs(fq.y)-.4)-.2;
    float mainbox = sdbox(q,vec3(1.25));
    float cutbox =  sdbox(vec3(q.xy,abs(q.z))-vec3(0,0 ,1.35),vec3(.65,.65,3.75 ));
    float frame = sdbox(fq,vec3(.1,.1,.75));

    mainbox = min(mainbox, frame);
    mainbox = max(mainbox, -cutbox);
    if(mainbox<res.x) res = vec2(mainbox/P.w,2.);

    float frame2 = sdframe(q,vec3(1.475),.225)-.0125;
    if(frame2<res.x) res = vec2(frame2/P.w,4.);

    float dv = .45+.25*sin(q.z*.75);
    float beams = length(q.xy)-dv;

    if(beams<res.x) {
        res = vec2(beams/P.w,3.);
        hit=pp+vec3(0,ga2*cell,0);
    }
    
    return res;
}

// Function 21
float Tonemap_Chen(float x) {
    // Cs = soft toe position
    // Ct = soft toe strength
    // Cl = soft shoulder position
    // Ce = hard shoulder position
    const float Cs = 5.9;
    const float Ct = 0.37;
    const float Cl = 0.517;
    const float Ce = 0.8;
    
    // Soft smoothstep toe
    float ts = x * smoothstep( 0.0, 1.0, x * Cs );
    float x1 = mix( x, ts, Ct );
    
    // Piecewise linear + reinhard soft shoulder.
    if ( x > Cl ) {
        x1 -= Cl;
        x1 = x1 / ( 1.0 + x1 ) + Cl;
    }
    
    // Linear + exponential hard shoulder for SDR.
    if ( x1 > Ce ) {
        float y = ( x1 - Ce ) / ( 1.0 - Ce );
        x1 = Ce + ( 1.0 - exp( -y ) ) * ( 1.0 - Ce );
    }
    
    return x1;
}

// Function 22
vec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)
{
	float white = 2.;
	float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
	float toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);
	color *= toneMappedLuma / luma;
//	color = pow(color, vec3(1. / 2.2));
	return color;
}

// Function 23
float SDF_Eye(vec3 p)
{
    // Do both left and right eye in a single call using sign(p.x)
	return length(Translate(p, vec3(0.4 * sign(p.x), 0.15, 0.8))) - 0.105;
}

// Function 24
vec3 tonemap (vec3 color) {
  vec3  hue = rgb_to_hue(color);
  float sat = rgb_to_sat(color);
  float lum = rgb_to_lum(color);

  // smooth-clamp
  sat = -log(exp(-sat*10.)+exp(-10.))/10.;

  /* tonemapping options:
       - desaturate when very bright
       - smooth-clamp brightness to a maximum that still
          allows some color variation                              */
  // sat = sat*(exp(-lum*lum*2.));
  // lum = .8*(1.-exp(-lum));

  color = lum*mix(vec3(1.),hue,sat);
  return color;
}

// Function 25
float beckmannDistribution(float HN)
{
    // roughness
    const float m = 2.0;
    const float m2 = m * m;
    
    float cos2 = HN * HN;
    float cos4 = cos2 * cos2;
    
    float num = exp((cos2 - 1.0) / (cos2 * m2));
    float den = pi * m2 * cos4;
    
    float k = num / den;
    
    return k;
}

// Function 26
float calc_dist_mushroom(in vec3 point, out int obj_id)
{
	const float sph_radius = 1.0;
	const float bigsph_radius = 50.0;

	const float sep = 5.6; //dist between 2 mushrooms
	const float hsep = sep / 2.0;
	vec2 cell_pt = floor((point.xz + vec2(hsep, hsep)) / sep) * sep;

	vec2 cell_pt2 = cell_pt * 7.32;
	vec2 cell_noise = vec2(noised(cell_pt2 + 3.48),
			noised(cell_pt2 + 25.72));
//	vec2 cell_noise = vec2(cnoise(cell_pt2 + 3.48),
//			cnoise(cell_pt2 + 25.72));
	vec3 scale = vec3(1.0, 1.0, 1.0);//vec3(cell_noise.x, cell_noise.y, cell_noise.x) *
	//	vec3(0.4, 0.6, 0.4) + vec3(1.0, 1.0, 1.0);
	vec2 xzoffs = cell_noise * (hsep - sph_radius * max(scale.x, scale.z));

	vec3 p = vec3(mod(point.x + hsep, sep) - hsep, point.y,
			mod(point.z + hsep, sep) - hsep) * scale;
	p.x += xzoffs.x;
	p.z += xzoffs.y;
	p.y -= ground_height(cell_pt - xzoffs);

	vec3 cap_pt = p * vec3(1.0, 1.5, 1.0);

	float dsph_small = sqrt(dot(cap_pt, cap_pt)) - sph_radius;
	vec3 bigsph_center = vec3(0.0, bigsph_radius - 0.2, 0.0);
	vec3 dvec = bigsph_center - cap_pt;
	float dsph_big = sqrt(dot(dvec, dvec)) - bigsph_radius;

	float stem_radius = 0.7;
	vec3 stem_center = vec3(0.0, -0.3, 0.0);
	float stem_scale = clamp((p.y - stem_center.y) / stem_radius + 2.0, 1.0, 3.0) * 1.1;
	vec3 stem_pt = p * vec3(stem_scale, 1.0, stem_scale);
	dvec = stem_center - stem_pt;
	float dist_stem = sqrt(dot(dvec, dvec)) - stem_radius;

	float dist;

	if(dsph_small > dsph_big) {
		obj_id = OBJ_MUSHROOM_TOP;
		dist = dsph_small;
	} else {
		obj_id = OBJ_MUSHROOM_BOTTOM;
		dist = dsph_big;
	}

	if(dist_stem < dist) {
		obj_id = OBJ_MUSHROOM_STEM;
		dist = dist_stem;
	}

	return dist;
}

// Function 27
float boxMap( sampler2D sam, in vec3 p, in vec3 n)
{
    p = p*vec3(.1, .03, .1);
    n = abs(n);
	float x = texture( sam, p.yz ).y;
	float y = texture( sam, p.zx ).y;
	float z = texture( sam, p.xy ).y;
	return (x*n.x + y*n.y + z*n.z)/(n.x+n.y+n.z);
}

// Function 28
float box_dist(vec2 p, vec4 b) {
    
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
    
}

// Function 29
float scene_primitive_cylinder( Ray ray, vec2 size, inout float t, inout vec3 N )
{
    float R = size.x;
    float omzz = max( 0., 1. - ray.d.z * ray.d.z );
    float ooomzz = 1. / omzz;
    float od = dot( ray.o.xy, ray.d.xy );
    float u = square( dot( ray.o.xy, perp( ray.d.xy ) ) ) * ooomzz;
    float v = max( 0., R * R - u );
    float to = -od * ooomzz - sqrt( v * ooomzz );
    float dz = ray.o.z + sign( ray.d.z ) * size.y;
    float tz = -dz / ray.d.z;
    if( u < R * R )
    {
        if( to >= 0. && to < t && abs( ray.o.z + ray.d.z * to ) < size.y )
        {
            t = to;
            N = vec3( normalize( ray.o.xy + t * ray.d.xy ), 0. );
        }
        vec2 xy = ray.o.xy + ray.d.xy * tz;
        if( tz >= 0. && tz < t && dot( xy, xy ) < R * R )
        {
            t = tz;
            N = sign( ray.o ) * UNIT_Z;
        }
    }
    float shadow = 1.;
    if( ( od < 0. || -sign( ray.d.z ) * ray.o.z >= size.y ) &&
                      sign( ray.d.z ) * ray.o.z < size.y * 0.95 )
    {
        float somzz = sqrt( omzz );
        float K = 2. * max( 0., max( to, tz ) * SCN_RAYCAST_SHADOW_UMBRA_INV );
        float u1 = sqrt( u );
        float u2 = ( od * ray.d.z * ooomzz - ray.o.z ) * somzz;
        float R2 = sqrt( v ) * abs( ray.d.z ) + size.y * somzz;
        shadow = 1. - aaa_interval( K, u1, 2. * R ) *
            aaa_interval( K, u2, 2. * R2 );
    }
    return shadow;
}

// Function 30
SDObject mapScene(vec3 p)
{
    SDObject earth=newSDObject(0,vec3(0.));
    SDObject moon=newSDObject(4,vec3(sin(iTime),0.,cos(iTime))*10.5);

        SDObject res=noSDObject();
    //   SDObject res=SDOMap(moon,ray);
    res= SDOMap(earth,p);
//	res= SDUnion(res,SDOMap(moon,p));
	return res;
}

// Function 31
vec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c, in vec2 d)
{
    float d0 = max(ip_control(uv, a, b, c, d), ip_aux(uv, a, b, c, d));
    float point = 0.;
    
#ifdef ANIMATED
    point = ip_point(uv, a, b, c, d);
#endif
    
    float d1 = ip_curve(uv, a, b, c, d);    
    float rs = max(d0, d1);
    
    return (point < .5)
        ? rs * (d0 > d1 ? COL0 : COL1)
        : point * COL3;
}

// Function 32
float3 BSDF_F ( float3 N, float3 wi, float3 wo, Material mat ) {
  if ( mat.transmittive > 0.0 ) {
    return IPI*mat.colour;
  }
    if (mat.diffuse == 0.0) { return mat.colour; }
  wi = -wi;

  float3 X, Y;
  Calculate_XY(N, X, Y);
  float3 H = normalize(wi+wo);

  float D, G, F;
  
  float k = mat.alpha*mat.alpha;

  D = k/(PI*pow((k-1.0)*sqr(dot(N, H))+1.0, 2.0));
  k = mat.alpha*sqrt(2.0*IPI);
  G = GTerm(N, wi, k)*GTerm(N, wo, k);
  F = mat.fresnel + (1.0-mat.fresnel)*pow(1.0 - dot(wi, H), 5.0);


  float3 refl = float3(G*D*F)/(4.0*dot(wi, N)*max(dot(wi, N), dot(H, N)));
  float diffuse = mat.diffuse;
  return diffuse*IPI*mat.colour + (1.0-diffuse)*refl*mat.colour;
}

// Function 33
float sdf(vec3 pose, bool inside)
{
    float d = box(pose - vec3( 0.00, 0.00, 1.00),  vec3(0.50,0.50,1.00));
    
    vec3 pos = pose;
    vec3 rot = pos;
    
    rot.xy -= vec2(0.36,-0.4);

    rot.xy = n_rotate(rot.xy,0.245);

    rot.xy += vec2(0.36,-0.4);
    
    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));
    
    if(door_box < 0.001)
        pos = rot;
        
        
    
    //use symetries:
        
        //mirror at axes
        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);
        
        //mirror at diagonals
        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;
        
    
    
    if(d < 0.2)
    {
        d = 1000.;
        
        
        if(pos.z > 1.55)
        {
            float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2
            roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope
            d = min(d,roof);
            
            d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base
            float tar_rad = length(pos.xy);
            d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole
            d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light
            d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof
        }
        else
        {
            if(door_box > 0.001)
                d = min(d,door_box+0.001);
        
            if(pos.z > 0.73)
            {
                d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar
                d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar
                
                
                d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window
                
                if(pos.y < -0.4)
                {
                    d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle
                    
                    d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical
                    d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal
                    
                    d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock
                }
                
                
            }
            else
            {
                float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base
                base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)
                d = min(d,base);
            }
            
            d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars
            
            
            d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels
            
            d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar
            
            d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar
            
            d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar
            d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar
        }
        
        d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign
        d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside
        
        d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole
        
        d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1
        
        if(inside)
            d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back
        
        d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door
        
        if(door_box < 0.001)
                d = max(d,door_box+0.001);
    }
    
    
    //interior
    if(inside)
    {
        vec3 ipos = pos;
        ipos.y -= 10.;
        
        ipos.z -= 0.14;
        
        vec2 pl = n_polar(ipos.xy);
        
        float bound_rad = length(ipos-vec3( 0.00, 0,1.));
        
        
        if(6. < bound_rad)
        {
            vec3 tile = vec3(pl,ipos.z);


            ////wall patern
            tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;

            tile.xy = n_un_polar(tile.xy);

            tile.xz = map_hex(2.14*tile.xz) / 2.14;

            tile.y -= 7.8;


            float ball = abs(sph(tile - vec3(0,5.80,0),4.))-0.01;
            float cutout = cheap_cyl((tile - vec3(cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout

            float ball2 = abs(sph(tile - vec3(0,-2.18,0),4.))-0.01;
            float cutout2 = cheap_cyl((tile - vec3(-cos(pi2/6.)*0.5,3.7,sin(pi2/6.)*0.5)).xzy    ,   .37, 10.);//cutout

            ball  = max(ball ,-cutout );
            ball2 = max(ball2,-cutout2);



            float deco = cheap_cyl((tile).xzy -vec3(0,0,-2.8)   ,   .37, 4.65);//hole

            deco = max(deco,-ball);
            deco = max(deco,-ball2);

            ////

            float dome = abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1;//dome
            dome = max(dome,-box(pos    - vec3( 0.00, 0.00,0.84),  vec3(0.43,.6,0.76)));


            dome = max(dome,-deco);

            d = min(d,dome+0.02);

            dome = max(dome,tile.z-0.41 );

            d = min(d,dome);

            d = min(d,pln(pos - vec3(0,0,9),vec3(0,0,-1)));//inside roof


            vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);

            things.xy = n_un_polar(things.xy);

            things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));



            things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;

            things.xz = hex_tile(things.zx);
            

            if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)
            {
                d = min(d, box(things,vec3(0.4,0.02,0.4)));//blue hex
                things -= vec3(0.,-0.12,0.6);
                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))+ 0.006+ 0.006*sin(things.z*100.));//hex surounding
            }
            else
            {
                things -= vec3(0.,-0.12,0.6);
                d = min(d, box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.0,0.2))+0.1);//sdf placeholder
            }

            d = min(d, pln(ipos    ,  vec3(0,0,1)));//floor
        }
        if(8.6 > bound_rad)
        {
            d = min(d, max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z));//console
            
            d = min(d, tor((ipos    - vec3( 0.00, 0, 1.0)).xzy,   vec2(1.6,0.05)));//console
            
            
            d = min(d, max(pl.y - 5.8, abs(ipos.z - 0.32) - 0.02));//stairs
            d = min(d, max(pl.y - 7.8, abs(ipos.z       ) - 0.16));//stairs
            d = min(d, max(pl.y - 5.7, abs(ipos.z       ) - 0.30));//stairs light
            
            
            vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);
            
            hex.x = abs(hex.x);
            
            d = min(d, cap(hex , vec3( 0.00, 1.62, 1.05), vec3( 0.00, 0.9 , 1.4),   0.05));//console_
            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 1.2 , 0.1),   0.2,0.3));//console_
            d = min(d, cop(hex , vec3( 0.00, 0.75, 0.6), vec3( 0.00, 0.7 , 0.9),   0.2,0.2));//console_
            d = min(d, max(pl.y - 1.0, abs(ipos.z - 1.43) - 0.03)); //upper console
            
            d = max(d,-max(pl.y - 0.7, abs(ipos.z - 0.74) - 2.0) );//console hole
            
            float p1 = cop(ipos, vec3( 0.00, 0.0,0.14), vec3( 0.00, 0.0,3.14),0.65, 0.40);//pylon
            float p2 = cop( hex, vec3( 0.00, 5.0,0.14), vec3( 0.00, 5.4,2.14), 0.6, 0.51);//suround pylon
            float p3 = cop( hex, vec3( 0.00, 5.4,2.14), vec3( 0.00, 4.0,3.94), 0.5, 0.41);//suround pylon
            float p4 = cop( hex, vec3( 0.00, 4.0,3.94), vec3( 0.00, 2.0,3.54), 0.4, 0.30);//suround pylon
            
            vec3 drr;
            
            if(min(min(d,p2),min(p3,p4)) > p1)
                drr = ipos;
                
            else if(min(d,min(p3,p4)) > p2)
                drr = vec3(hex.x+2., n_rotate(hex.yz, .04));
                
            else if(min(d,p4) > p3)
                drr = vec3(hex.x+2., n_rotate(hex.yz,-.10));
                
            else if(d > p4)
                drr = vec3(hex.x+2., n_rotate(hex.yz,-.28));
            
            float cr = 0.12 * noise3d2(vec3(10,10,1.)*drr).x;
            
            d = min(d, p1 + cr);//pylon
            d = min(d, p2 + cr);//suround pylon
            d = min(d, p3 + cr);//suround pylon
            d = min(d, p4 + cr);//suround pylon
            
            d = min(d, cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1);// pylon joint
            d = min(d, cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1);// pylon joint
            
        }
        
    }
     
    return (d);
}

// Function 34
void flowmap(
    float blend_cycle, float cycle_speed,
    float offset,
    vec2 flow, float flow_speed, vec2 flow_scale,
    vec2 uv_scale,
    vec2 base_uv,
    out float blend_factor,
    out vec2 ouv1, out vec2 ouv2)
{
    // Compute cycle, phases
	float half_cycle = blend_cycle * 0.5;

	float phase0 = mod(offset + iTime * cycle_speed, blend_cycle);
	float phase1 = mod(offset + iTime * cycle_speed + half_cycle, blend_cycle);

	// Blend factor to mix the two layers
	blend_factor = abs(half_cycle - phase0)/half_cycle;

	// Offset by halfCycle to improve the animation for color (for normalmap not absolutely necessary)
	phase0 -= half_cycle;
	phase1 -= half_cycle;

	// Multiply with scale to make flow speed independent from the uv scaling
	flow *= flow_speed * flow_scale;

	ouv1 = flow * phase0 + base_uv;
	ouv2 = flow * phase1 + base_uv;
}

// Function 35
float map(vec3 p,float t){
    float d;
    p=abs(p);
    p.y-=a(0.,t);
    p.x-=a(1.,t);
    p.z-=a(2.,t);
    p-=1.;
    
    return sdBox(p,vec3(1));
}

// Function 36
vec3 GetBumpMapNormal (vec2 uv, mat3 tangentSpace)
{    
	float delta = -1.0/512.0;
	float A = texture(iChannel1, uv + vec2(0.0, 0.0)).x;
	float B = texture(iChannel1, uv + vec2(delta, 0.0)).x;
    float C = texture(iChannel1, uv + vec2(0.0, delta)).x;    
    
	vec3 norm = normalize(vec3(A - B, A - C, 0.15));
	
	return normalize(tangentSpace * norm);
}

// Function 37
vec4 map(vec3 p){
    vec4 d0 = vec4(.9,.9,1.,plane(vec3(0.,1.,0.),p)+1.5);
    d0 = cun(d0,vec4(.9,.9,1.,plane(vec3(0.,0.,-1.),p)+10.));
    d0 = cun(d0,vec4(.9,.9,1.,box(vec3(1.,1.,1.),p-vec3(0.,-2.,0.))));
    
    p-=vec3(.0,-.3,.0);
    p.xy *= ro(sin(iTime)*.1);
    p.xz *= ro(iTime*.3);
    //vec4 d1 = vec4(1.,.8,.8,sponge(p-vec3(-.5,0.,-.5),3));
    //d1 = cmix(d1, vec4(.8,1.,.8,sphere(p)-1.8),.0);
    //vec4 d1 = vec4(1.,.8,.8,sphere(p-vec3(0.,-1.,0.))-1.);
    //vec4 d2 = vec4(.8,1.,.8,sponge(p-vec3(.5,.4,.5),3));
    vec4 d1 = vec4(.5,.5,.8,sphere(p)-.5);
    vec4 d2 = vec4(.7,.3,.7,disk(vec3(0.,0.,0.),vec3(0.,1.,0.),.9,p)-.02);
    vec4 d3 = vec4(.7,.3,.3,loop(vec3(0.,0.,0.),vec3(0.,1.,0.),.9,p)-.03);
    vec4 d4 = vec4(.3,.3,.6,loop(vec3(0.,.5,0.),vec3(0.,0.,1.),.15,p)-.06);


    p.xz=abs(p.xz);
    p.xz*=ro(pi/4.); 
    
    
    vec4 d5 = vec4(.3,.3,.5,capsule(vec3(0.,0.,0.),vec3(0.,-.55,.45),.1,.03,p));
    vec4 d6 = vec4(.3,.3,.3,sphere(p-vec3(0.,-.55,.45))-.06);
    d5 = cun(d5,d6);   
    
    return cun(d0,smix(smix(smix(d1,d4,.06),smix(d2,d3,.1),.2),d5,.05));
}

// Function 38
float colormap_blue(float x) {
    if (x < 0.0) {
        return 54.0 / 255.0;
    } else if (x < 7249.0 / 82979.0) {
        return (829.79 * x + 54.51) / 255.0;
    } else if (x < 20049.0 / 82979.0) {
        return 127.0 / 255.0;
    } else if (x < 327013.0 / 810990.0) {
        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;
    } else {
        return 1.0;
    }
}

// Function 39
float sdf_quarter2_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(pos.y, pos.x));
}

// Function 40
vec3 ToneMap_FilmicALU(vec3 color)
{
    color = max(vec3(0.0), color - 0.004);
    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);
    return color;
}

// Function 41
float rayDistance(Ray r,vec3 p){
    vec3 v = r.origin - p;
    return length(v - dot(v,r.direction)*r.direction);
}

// Function 42
float map(vec3 p){
     
    // The original uses a different coordinate system, so this is a quick hack
    // to enable me to drop in a "Z into the page" coordinate system.
    p = p.yzx; 
    
    // A gyroid-like perturbation to add to a plane. I'm doing it prior to the
    // wrapping the objects around the path, but there's no rule saying you can't
    // wrap this as well.
    float trSf = dot(sin(p*3.14159/16. - cos(p.yzx*3.14159/12.)), vec3(8));
 
    p.xy -= path(p.z); // Wrap the object (to follow) around the path.

   
    // Add the perturbation to the plane, then carve out a tunnel. I named the resultant object
    // "surr" for surroundings - I was in a hurry. :)
    float surr = smax(4. - length(p.xy*vec2(1, .75)), p.y - 4. + (.5 - trSf), 2.);
    float rail = max(abs(abs(p.x) - 4.) - 1., p.y + 2.); // Some rails for the path below.
    
    // Attaching the rails to the surroundings - instead of the path - for color reasons.
    surr = min(surr, rail); 
    
    // A windy path - Everything above a certain height is omitted.
    float path = max(abs(p.x) - 3.5, p.y + 4.); 

    objID = step(surr, path); // Object ID - Surrounding or path floor.

    return min(surr, path); // Return the minimum hit point.
 
}

// Function 43
float sceneSDF(vec3 samplePoint) {
    
   	float modu = 3.0;
    
    samplePoint = mod(samplePoint, modu);
    
    float result = sphereSDF(samplePoint, modu/2., .75);
    result = unionSDF(result, CappedCylinderSDF( samplePoint - modu/2., vec2(0.25,50.)));
    
    vec4 rot = rotationMatrix(vec3(1.,0.,0.), 90. * RADIANT) * vec4(samplePoint- modu/2.,1.);
   	result = unionSDF(result, CappedCylinderSDF( rot.xyz, vec2(0.25,50.)));
    
    rot = rotationMatrix(vec3(.0,0.,1.), 90. * RADIANT) * vec4(samplePoint- modu/2.,1.);
   	result = unionSDF(result, CappedCylinderSDF( rot.xyz, vec2(0.25,50.)));
    
    return result;
}

// Function 44
float map(vec3 p)
{
    float radius = 0.25;
    vec3 q = fract(p) * 1.5 - 0.5;
    
    return sphere(q, radius);
}

// Function 45
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn, ltDir;
  vec2 q;
  float dstObj, atten, dfSum, spSum, sh;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    dfSum = 0.;
    spSum = 0.;
    for (int k = 0; k < 2; k ++) {
      ltDir = ltPos[k] - ro;
      atten = 1. / (1. + 0.02 * dot (ltDir, ltDir));
      ltDir = normalize (ltDir);
      atten *= smoothstep (0.3, 0.5, dot (ltAx, - ltDir));
      dfSum += atten * max (dot (vn, ltDir), 0.);
      spSum += atten * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);
    }
    ltDir = normalize (0.5 * (ltPos[0] + ltPos[1]) - ro);
    sh = ObjSShadow (ro, ltDir, max (dstObj - 0.2, 0.));
    col4 = ObjCol (ro);
    col = (0.2 + 0.4 * sh * dfSum) * col4.rgb + 0.5 * col4.a * sh * spSum * vec3 (1., 1., 0.5);
    col *= ObjAO (ro, vn);
    col += vec3 (0.2, 0.2, 0.) * max (dot (- rd, vn), 0.) *
       (1. - smoothstep (0., 0.03, abs (dstObj - 0.5 * mod (tCur, 6.))));
    rd = reflect (rd, vn);
    q = smoothstep (0.15, 0.25, mod (512. * vec2 (atan (rd.x, rd.y), asin (rd.z)) / pi, 1.));
    col *= 0.95 + 0.05 * q.x * q.y;
    col *= mix (1., smoothstep (0., 1., Maxv3 (col)), 0.3);
  } else col = vec3 (0.15, 0.14, 0.14);
  return col;
}

// Function 46
float map( in vec3 p )
{
	// We have only one object in this scene, and it is a sphere of
    // radius 1.0
	return sdSphere(p, 1.0);	
}

// Function 47
float distanceToNearestSurface(vec3 p){
	float s = 1.0;
    vec3 d = abs(p) - vec3(s);
    return min(max(d.x, max(d.y,d.z)), 0.0)
        + length(max(d,0.0));
}

// Function 48
float GetDistIcosahedron(vec3 p) {
    // Icosahedron distance to a face
    vec3 q = p;
    q -= ICOMIDEDGE; // walking from center to an edge
     // rotation among the edge (X axis for the Dode) to align the face
    q.yz *= Rot(ICODIHEDRAL*.5); // smoothly folds the face on the X axis
    // draws a face, rounded at the corners
    float dIco = length(max(vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z), 0.))+min(q.z, 0.);
    dIco = abs(dIco-.025)-.05; // onioning and rounding
    // Circles are centered on the icosahedron's faces
    float dBigHole = length(q.xy - vec2(0.0,Y_TO_ICO_CENTER))-.16;
    dBigHole = abs(dBigHole)-.08;
    dBigHole = abs(dBigHole)-.04;
    dBigHole = abs(dBigHole)-.02;
    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico
    float dSmallHole = length( q.xy - mix(vec2(0.0,Y_TO_ICO_CENTER),vec2(X_TO_ICO_VERTEX,0.0),.63) ) - .07;
    dSmallHole = abs(dSmallHole)-.04;
    dSmallHole = abs(dSmallHole)-.02;
    // little chains of spheres on the edges
    float dEdges = length(q-vec3(round(q.x*20.0)/20.0,0.0,0.1))-.03;
    // Corners of the Ico
    q = p;
    q -= ICOVERTEX * 1.3; // distance from center to an edge
    q.xz *= Rot(DODEDIHEDRAL*.5); // smoothly folds the face on the Y axis
    float dCorners = length(q)-.04*(1.0+.5*sin(q.z*50.0));    
    // shaking mixing the distances
    float dist = dIco;
    dist = smax(dist,-dBigHole,.01);
    dist = smax(dist,-dSmallHole,.01);
    dist = smin(dist,dIco+.005,.01);
    dist = smin(dist,dCorners-.13,.1);
    dist = min(dist,dEdges);
    
    return dist;
}

// Function 49
float map(vec3 p )
{
    vec3 oldp = p;
    float iz =floor(p.z);
 float ix =floor(p.x);
   
    if(iz > 0. && iz < 20.)
    p.xz = mod(p.xz, 10.) -5.;
    
    p.xz*=rot(p.y*PI/5.);
    p.xz*=rot(iTime/2.);
   // oldp.xz*=rot(iTime);//thought I needed this for surf at end but no

    
    float cyl1 = length(p.xz + vec2(1.0,0.0)) - 0.2;// - ((surf(p*30.)/60.));//+sin(p.y*8.)/50.;
    float cyl2 = length(p.xz - vec2(1.0, 0.0)) - 0.2;// - ((surf(p*30.)/60.));//+sin(p.y*8.)/50.;
    
     p.y = mod(p.y,.4)-.2;
    float bar = max(length(p.yz) - 0.07, abs(p.x) - .9) ;//-surf(p*20.)/50.;
    
	
   // p.xz*=rot(iTime);
	float dna =  min(min(cyl1, bar), cyl2) ;//if I wanted the noise applied to everything
    
    //if I wanted to added another object
    ///float cell = length(p)-.1-surf(p*3.)/4.;
    //return min(dna, cell);
    
    return dna ;// 
    //before I just had 
    //return min(min(cyl1, bar), cyl2);
    
    //other cool things
    //return min(min(cyl1, bar), cyl2) - (1.0-abs(surf(oldp*3.)/50.));
    //return min(min(cyl1, bar), cyl2) - (abs(fbm(oldp.yy*4.)/5.));

}

// Function 50
float Tonemap_Unreal(float x) {
    // Unreal 3, Documentation: "Color Grading"
    // Adapted to be close to Tonemap_ACES, with similar range
    // Gamma 2.2 correction is baked in, don't use with sRGB conversion!
    return x / (x + 0.155) * 1.019;
}

// Function 51
vec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){
   
    const float eps = 0.001;
    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),
                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),
                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));
    
    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; 
            
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 52
float SDFland (vec3 p) {
    float PH = 6.;
    // float SDFp = p.y-cos(p.x*PI/2./10.)*3.;
    float SDFp = p.y-noise(p.x/5., p.z/5.)*10.+3.;
    return SDFp;
}

// Function 53
float ObjectsDF( vec3 p )
{
    return length( abs(p-vec3(0,-.5,.3))-vec3(1,0,0) )-.3;
}

// Function 54
float dist(Bezier3 B, vec2 p)
{
    vec2 a = B.B - B.A, b = B.A - B.B * 2.0 + B.C, c = a * 2.0, d = B.A - p;
    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      
    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);
    vec2 pos = B.A + (c + b*t.x)*t.x;
    float dis = length(pos - p);
    pos = B.A + (c + b*t.y)*t.y;
    dis = min(dis, length(pos - p));
    pos = B.A + (c + b*t.z)*t.z;
    dis = min(dis, length(pos - p));
    return dis;
}

// Function 55
vec2 scene_reeds(vec3 _p, float depth, float t)
{
    float cd = abs(length(_p.xz)-14.);
    float zo = 0.1*fbm_hash2D(1.*_p.xz);
    float h = 5.-4.8*(clamp(.9*(5.-cd), 0., 1.));
    vec2 rp = opRep(_p.xz, vec2(0.2));
    return scene_reed(vec3(rp-0.2+0.4*hash2D(0.1*_p.xz), _p.y+cd*h-.6+10.*zo).xzy, depth, zo, t+5.14*zo);
}

// Function 56
float sdf_k(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -6, 0), vec3(4, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -6, 0), vec3(4, -8, 0)));
    return t;
}

// Function 57
float polySDF(vec2 st, int V) { // 26
    st = st * 2. - 1.;
    float a = atan(st.x, st.y) + PI;
    float r = length(st);
    float v = TAU / float(V);
    return cos(floor(.5 + a / v) * v - a) * r;
}

// Function 58
float torussdf( vec3 pos )
{
    vec3 p = pos - vec3(sin(iTime) * 2., 0.8, sin(iTime / 2.) * 10.);
    vec2 q = vec2(length(p.yz)-outradius,p.x);
    return length(q)-inradius;
}

// Function 59
float sdfStar5( in vec2 p )
{
    const vec2 k1 = vec2(0.809016994375, -0.587785252292);
    const vec2 k2 = vec2(-k1.x,k1.y);
    p.x = abs(p.x);
    p -= 2.0*max(dot(k1,p),0.0)*k1;
    p -= 2.0*max(dot(k2,p),0.0)*k2;
    
    const vec2 k3 = vec2(0.951056516295,  0.309016994375);
    return dot( vec2(abs(p.x)-0.1,p.y), k3);
}

// Function 60
float map(vec3 p){
    vec3 zero=vec3(0.0,0.0,0.0);
    float p1=plane(p,vec3( 0.0,-1.0, 0.0),vec3( 0, 1, 0));
    float p2=plane(p,vec3( 0.0, 1.0, 0.0),vec3( 0,-1, 0));
    float p3=plane(p,vec3( 0.0, 0.0, 1.0),vec3( 0, 0,-1));
    float p4=plane(p,vec3( 0.0, 0.0,-1.0),vec3( 0, 0, 1));
    float p5=plane(p,vec3( 1.0, 0.0, 0.0),vec3(-1, 0, 0));
    float p6=plane(p,vec3(-1.0, 0.0, 0.0),vec3( 1, 0, 0));
    float c=opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);
    //carved cube
    //return opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);
    return carving(p);
}

// Function 61
float map(in vec3 p) 
{
		
	float d = p.y-.5*log(1.*pow(length(p.xz),1.)+0.2);
 	d = min(d,length(p)-0.4);
   	schein=(p-lightpos);
    pR(schein.zx,iMouse.x*-0.03+0.8);
    pR(schein.yz,iMouse.y*0.03-.5);
	float s= sdCone(schein,normalize(vec2(1,.9)))/length(schein*schein);
    scatter += max(-s,0.)*0.2;
   
    float f = length(p-lightpos)-0.1; 
    return min(f,d);
}

// Function 62
float mapDE(vec3 p)
{
    p -= drone.xyz;
    p = rot3DXY(p, droneRots.xy);

    float d = sphere(p, 10.0);
	vec3 v = p;
    v.xy = abs(v.xy);
    v.xy = rot2D(v.xy, -PI/6.2);
    // Cross pieces...
    d = sMin(d, roundedBox(v-vec3(0,0,-8), vec3(4.9, .3, .5), 1.), 1.2); 
    d = max(d, -roundedBox(v-vec3(0,0,-8.5), vec3(4.8, .3, 1.), 1.));
    
    // Centre cutout...
    //d = sMin(d, roundedBox(p-vec3(0,0,-8.5), vec3(1.3, 1.4, 1.5), .7), .4); 
    d = max(d,-roundedBox(p-vec3(0,0,-9.1), vec3(2., 1.5, 4.0), .7)); 
    // Inside...
    d = min(d, sphere(p, 8.8));
    d = max(d, roundedBox(p, vec3(6.5, 12, 12.0), .8)); 
    // Make back...
    d = sMin(d, prismFlip(p+ vec3(.0, -4.1, -8.1), vec2(7., 4.7) ), 1.);
    d = max(d, -prism(p + vec3(.0, 6.4, -11.4), vec2(8.0, 10.0) ));
    d = min(d, sphere(p+ vec3(.0, 5.6, -6.2), 3.0));
    
    // Eye locations../
    d = min(d, sphere(v+ vec3(-3.5, .0, 7.4), 1.1));
    
    v = p;
    v.x = abs(v.x);
    d = sMin(d, roundedBox(v+vec3(-4.2,-6.,-10.0), vec3(1.1, .1, 4.5), 1.), 2.4); 
    
    v =abs(p)-vec3(gunMovement.x, .0, 0.) ;
    v.x -= p.z*.1*gunMovement.y;
	float d2 = sphere(v, 10.0);
    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 12.0), .8)); 
    d = min(d2 ,d);
    d = min(d,roundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));
    d = min(d,roundedBox(v-vec3(5.5, .0, 5.), vec3(2.4, .1, .1), .4));

    v =vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);
    v.x -= p.z*.1*gunMovement.y;

    d = min(d, roundedBox(v-vec3(8., 2.8, -6.5), vec3(.3, 1., 3.), .2));
    d = min(d, roundedBox(v-vec3(8., 2.3, -10.), vec3(.2, .4, 1.2), .2));
    d = min(d, roundedBox(v-vec3(8., 3.4, -10.), vec3(.01, .01, 1.2), .4));
    d = max(d, -roundedBox(v-vec3(8., 3.4, -10.4), vec3(.01, .01, 1.2), .3));
    d = max(d, -roundedBox(v-vec3(8., 2.3, -10.4), vec3(.01, .01, 1.2), .3));
    
    d = min(d,  roundedBox(v-vec3(8.55, 0, -4.5), vec3(.4, .2, 1.), .4));
    d = max(d, -roundedBox(v-vec3(8.65, 0, -4.5), vec3(.0, .0, 2.), .34));
       
    return d;
}

// Function 63
vec3 GetReadMipMapUVW_Dir2(vec3 _uvw,vec3 _axis,float ID){
    ivec3 xyz = ID_xyz[int(dot(abs(_axis.yz),vec2(1,2)))];
	vec3 uv = vec3(_uvw[xyz.x],_uvw[xyz.y],_uvw[xyz.z]);
    float group_ID = floor((ID-=1.)/3.);
    float scale = exp2(group_ID-10.);
    float Bound = 1.-exp2(-group_ID);
    uv.xy = scale*(clamp(uv.xy,-Bound,Bound)+SCACLE_COEF[int(mod(ID,3.))])-1.;
    //f(x) = inverse(inverse(f(x)))
    uv = vec3(uv[xyz.x],uv[xyz.y],uv[xyz.z]);
    return normalize(uv + _axis);
}

// Function 64
vec4 draw_map(vec4 col, vec2 p)
{
    float h = map(p);
    
    col = blend(col, vec4(vec3(.7), smoothstep(0.01, 0., h)));
    col = blend(col, vec4(vec3(.0), smoothstep(0.01, 0., abs(h))));
    
	return col;
}

// Function 65
vec3 sdfRep(vec3 p, vec3 c)
{
    return mod(p, c) - 0.5 * c;
}

// Function 66
vec2 map_viewmodel(vec3 p)
{
    p -= g_entities.viewmodel.offset;
    float sq_dist = length_squared(p);
    if (sq_dist > sqr(32.))
        return bounding_sphere(sq_dist, 24., MATERIAL_SHOTGUN_BARREL);
    
    p = rotate(g_entities.viewmodel.rotation, p);
    
    const vec3
        BARREL_0	= vec3(0,    4, -4.375),
    	BARREL_1	= vec3(0, 13.5, -4.375),
    	FLASH_0		= vec3(0, 14.6, -4.375),
    	FLASH_1		= vec3(0, 16.1, -4.375),
    	BODY_0		= vec3(0,    2, -4.7),
    	BODY_1		= vec3(0,  7.5, -4.7),
        INDENT		= vec3(0,  7.5, -4.7),
		PUMP_0		= vec3(0,    9, -6.),
    	PUMP_1		= vec3(0, 12.9, -6.),
        PUMP_GROOVE	= vec3(0, 12.7, -6.)
	;
    
    vec2 body = vec2(sdf_capsule(p, BARREL_0, BARREL_1, .5), MATERIAL_SHOTGUN_BARREL);
    body.x = sdf_smin(body.x, sdf_capsule(p, BODY_0, BODY_1, .875), .05);
    body.x = sdf_smin(body.x, sdf_torus(p - INDENT, vec2(.7, .3)), .05);
    
    float attack = g_entities.viewmodel.attack;
    if (attack > 0.)
        body = sdf_union(body, vec2(sdf_capsule(p, FLASH_0, FLASH_1, .6, .2), MATERIAL_SHOTGUN_FLASH));

    const float GROOVE_SPACING = .675;
    vec2 pump = vec2(sdf_capsule(p, PUMP_0, PUMP_1, 1.4), MATERIAL_SHOTGUN_PUMP);
    p -= PUMP_GROOVE;
    p.y = fract(p.y * GROOVE_SPACING - .25) * (1./GROOVE_SPACING) - .5;
    pump.x = fOpDifferenceRound(pump.x, sdf_torus(p, vec2(1.3125, .375)), .125);
    
    return sdf_union(body, pump);
}

// Function 67
float terrainMapH( const in vec3 pos ) {
    float y = terrainHigh(pos.xz);
    float h = pos.y - y;
    return h;
}

// Function 68
vec4 getBitmapColor(in vec2 uv) {
    vec4 col = vec4(0);
    ivec2 fetch_pos = ivec2(uv * bitmap_size);
    if(fetch_pos.x >= 0 && fetch_pos.y >= 0
        && fetch_pos.x < int(bitmap_size.x) && fetch_pos.y < int(bitmap_size.y)) {
        int dct_row = fetch_pos.y / dct_pixels;
        int dct_col = fetch_pos.x / dct_pixels;

        int dct_values_per_row = dct_width * dct_cols;
        int dct_block_index = dct_row * dct_values_per_row + dct_col * dct_width;

        int pixel_x = fetch_pos.x % dct_pixels;
        int pixel_y = fetch_pos.y % dct_pixels;

        float idct = get_idct(dct_block_index, pixel_x, pixel_y);
        col = vec4((idct + 128.)/ 255.);
    }
    return col;
}

// Function 69
SceneResult SceneResult_Default()
{
    return SceneResult( MAX_PATH_LENGTH, -1, vec3(0) );
}

// Function 70
vec3 map( in vec3 p, in float dis, in float tre )
{
    // ground
    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;
    
	float l = 1.0;
    // fbm
    vec3 q = p;
    float t = 0.0;
	float s = 1.0;
    int ioct = int(clamp(11.0 - log2(dis),1.0,12.0));
    //const int ioct = 11;
    for( int i=0; i<ioct; i++ )
    {
        float n = noiseSDF(q)*s;
        n = smax(n,d-0.1*s,0.3*s);
        d = smin(d,n,0.3*s );
        t += d;
        //q = 2.0*m*q; // next octave
        q = m*(q*2.0+vec3(0.0,0.0,-t*2.0*s)*(1.0-float(i)/12.0));
        //s = 0.4*s*(1.0+0.015*float(i));
        s = 0.4*s*(1.0+0.0035*float(i*i));
    }
    
#if 1
    const float SC = 80.0;
    float ss = SC/120.0;
    if( t<0.2 )
    {
        vec3 w = p*SC;
        vec2 n = floor( w.xz );
        vec2 f = fract( w.xz );
        float d2 = 1.0;
        for( int j=0; j<=1; j++ )
        for( int i=0; i<=1; i++ )
        {
            vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));
            vec3  o = hash3( n + g );
            vec3  r = vec3(g.x-f.x+o.x,d*SC,g.y-f.y+o.y);
            if( treeDensity(vec3((n.x+g.x)/SC,p.y,(n.y+g.y)/SC),tre)<0.0 )
            {
                float k = sdEllipsoid(r,vec3(0.2,0.15+0.05*o.z,0.2));
                d2 = min(d2,k);
            }
        }
        d2 /= SC;

        float d3 = noiseSDF(ss*400.0*p*vec3(1.0,1.0,1.0))/(ss*400.0);
        d2 = smin(d2,smax(d3,d2-0.003,0.003),0.003);
        d3 = noiseSDF(d3*ss*400.0+ss*1700.0*p*vec3(1.0,2.0,1.0))/(ss*1700.0);
        d2 = smax(d2-0.0003,-d3,0.001);

        if( d2<d ) {d=d2; l=2.0; }
    }
#endif
        
    return vec3(d,t,l);
}

// Function 71
float mapstage9 (in vec3 p)
{
   
   vec3 q= mod (p+2.0,4.0) - 2.0;
   float d1 = length(q) - 1.0;   
   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; 
   float d2 = p.y + 1.0;
   float k = abs(sin (iTime))+1.5;
   float h= clamp (0.5 + 0.5 * (d1-d2)/k,0.0, 1.0);
   return mix (d1,d2, h) - k* h *(1.0-h);
}

// Function 72
float sdf_4(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(4, -4, 0)));
    t = min(t, sdf_quarter2_torus(pos, vec3(2, -2, 0)));
    return t;
}

// Function 73
vec3 mapGrass( in vec3 pos, float h, in vec3 cur )
{
    vec3 res = cur;
    
    float db = pos.y-2.6;
    
    if( db<cur.x && pos.z>-1.65 )
    {
        const float gf = 4.0;

        vec3 qos = pos * gf;

        vec2 n = floor( qos.xz );
        vec2 f = fract( qos.xz );
        for( int j=-2; j<=2; j++ )
        for( int i=-2; i<=2; i++ )
        {
            vec2  g = vec2( float(i), float(j) );

            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );

            if( ra2.x<0.73 ) continue;

            vec2  o = hash2( n + g );
            vec2  r = g - f + o;
            vec2 ra = hash2( n + g + vec2(11.0,37.0) );

            float gh = 2.0*(0.3+0.7*ra.x);

            float rosy = qos.y - h*gf;

            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );
            r.x -= 0.03*rosy*rosy;

            r.x *= 4.0;

            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);
            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );

            float gr = 0.3*sqrt(1.0-0.99*se.y);
            float d = se.x - gr;
            d /= 4.0;

            d /= gf;
            if( d<res.x )
            {
                res.x = d;
                res.y = MAT_GRASS;
                res.z = r.y;
            }
        }
    }
    
    return res;
}

// Function 74
float sphereSDF(vec3 p, float radius) { return length(p) - radius; }

// Function 75
float map(vec2 p)
{
    if(terrainMoving)
        p += iTime * vec2(0.1, 0.05);
    
    //  *** Choose the map function here ***
    return elevated(p);
}

// Function 76
float mapEnvLO(in vec3 rp)
{
    _mapRP = rp + getMapHeight(rp.x);
    g_fbm = fbmLO (abs(rp.xz) * ENV_P) * ENV_B;
    float d = groundDetail(_mapRP);
    rp.xy += g_fbm;
	
    return _mapEnv(rp);
}

// Function 77
void initScene() {
    float time = iTime;
    float frameSta = iTime;
    float frameEnd = frameSta + FRAME_TIME;
    
    //init lights
    float r = 0.1;
    spherelight[0] = Sphere( MTL_LIGHT_1, vec3( 2.0, 2.5, -4.0 ), r, r*r, r*r*4.0*PI );
   // r = 0.2;
    spherelight[1] = Sphere( MTL_LIGHT_2, vec3( -1.0, 3.5, -2.0 ), r, r*r, r*r*4.0*PI );

    //ground
    ground.abcd = vec4( 0.0, 1.0, 0.0, 1.0 );
    
    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;
    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;
    sphereGeometry = Sphere( MTL_WALL, vec3( xFactor*5.0, 1.0, -5.0-yFactor*4.0 ), 1.0, 1.0, 4.0*PI );
}

// Function 78
float rhombSDF(vec2 st) { // 17
    return max(triSDF(st), triSDF(vec2(st.x, 1. - st.y)));
}

// Function 79
float dist(vec2 p){
    
    

    //return length(p);
    
    // Square cross section.
    //p = abs(p);
    //return max(p.x, p.y);
    
    // Hexagonal cross section.
    //p = abs(p);
    //return max(p.x*.8660254 + p.y*.5, p.y);

    // Octagonal cross section.
    p = abs(p);
    return max(max(p.x, p.y), (p.x + p.y)*.7071);
    
    
    // Dodecahedral cross section.
    //p = abs(p);
    //vec2 p2 = p.xy*.8660254 + p.yx*.5;
    //return max(max(p2.x, p2.y), max(p.y, p.x)); 
    
    //const float pwr = 4.;
    //return pow( dot(pow(abs(p), vec2(pwr)), vec2(1)), 1./pwr);

    
}

// Function 80
vec4 map4(vec3 p, out float k) {
  vec4 p4 = inverseStereographic(p,k);
  // Do a one sided quaternion rotation, otherwise known
  // as a Clifford Translation, which seems appropriate.
  if (key(CHAR_R)) p4 = qmul(p4,quat);
  return p4;
}

// Function 81
float heightMap(vec2 x){
    float result = -2.0 * (bigWaveHeight + smallWaveHeight + 2.0 * rippleHeight);
    result += bigWaveHeight * sin(dot(x, bigWaveDir) / bigWaveLength 
                                   + bigWaveSpeed * iTime);
    result += smallWaveHeight * sin(dot(x, smallWaveDir) / smallWaveLength
                                   + smallWaveSpeed * iTime);
    result += ripples(x);
	return result;
}

// Function 82
float map( in vec3 pos ) {
	float d = pos.y;
    pos -= snoise(pos*0.15);
    vec3 q = pos-vec3(0.,5.,0.);
    pModPolar(q.xz, 6.);
    q -= vec3(30,0,0);
	d = fOpUnionRound(d, fBox(q,vec3(5.)),4.4);
    q = pos;
    pModPolar(q.xz,8.);
	d = fOpUnionRound(d, fBox(q,vec3(6.,20.,6.)),6.);
	return d;
}

// Function 83
float remap(float val, float OldMin, float OldMax, float NewMin, float NewMax){
    return (((val - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin;
}

// Function 84
SDFResult brushSDF( vec3 p )
{
    vec3 orig = vec3(0.8, -1.0, 1.2);        
    // handle
    SDFResult res = vertcapSDF(VertCap(vec3(-0.0, -0.0, .0)+orig, 0.75, 0.02, CHROM), p);
    res = opSmoothAdd(vertcapSDF(VertCap(vec3(0.0, 0.0, 0.0)+orig, 0.2, 0.1, CHROM), p), res, 0.01);
    return res;
}

// Function 85
vec3 ACESFilmicToneMapping(vec3 col){
	vec3 curr = Uncharted2Tonemap(col);
    const float ExposureBias = 2.0;
	curr *= ExposureBias;
    curr /= Uncharted2Tonemap(vec3(W));
    return LinearToGamma(curr);
}

// Function 86
vec4 tonemap(vec4 x)
{
   return ( (x * (kToneMapA * x + kToneMapC * kToneMapB) + kToneMapD * kToneMapE)  /
            (x * (kToneMapA * x + kToneMapB            ) + kToneMapD * kToneMapF)) -
            kToneMapE / kToneMapF;
}

// Function 87
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c, vn;
  vec2 s, w;
  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;
  bool isImg;
  pgSize = vec3 (3.2, 0.011, 1.8);
  tpCyc = 3.;
  tpWait = 4.;
  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :
     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));
  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));
  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);
  isImg = false;
  dstObj = ExObjRay (ro, rd);
  if (dstObj < dstFarEx) {
    ro += dstObj * rd;
    vn = ExObjNf (ro);
    nDotL = max (dot (vn, ltDirEx), 0.);
    if (idObj <= nPage) {
      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;
      c = HsvToRgb (vec3 ((idPage - 1.) / float (nPage), 0.3, 1.));
      s = pgSize.xz - abs (qHit.xz);
      col4 = vec4 (0.9, 0.9, 0.8, 0.2);
      if (qHit.y > 0.) {
        w = qHit.xz / pgSize.z;
        if (min (s.x, s.y) > 0.3) {
          isImg = true;
          ExMain (col, w);
        } else if (min (s.x, s.y) > 0.27) {
          col4 = vec4 (0.6 * c, 0.2);
        } else {
          col4 = vec4 (c, 0.2);
        }
      } else {
        col4 = vec4 (c, 0.2);
      }
    } else if (idObj == nPage + 1) {
      col4 = vec4 (0.9, 0.9, 0.95, 0.2);
      nDotL *= nDotL;
    }
    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);
    if (isImg) col *= 0.2 + 0.8 * sh;
    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);
  } else {
    col = vec3 (1., 1., 0.9) * (0.5 + 0.1 * rd.z);
  }
  return clamp (col, 0., 1.);
}

// Function 88
vec2 homerSDF(vec3 point) {
    float swingTime = 0.0;
    swingTime = PRECOMPUTEDTIME;
    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);
    vec3 p = translate(point, vec3(0.0,18.0+bounce, HOMERLIVESHERE));
    vec2 head = homersHeadSDF(p, swingTime);
    homerTorsoSDF(p, swingTime, head);
    homerBottomSDF(p, swingTime, head);
    homerArmsSDF(p, swingTime, head);
    return head;
}

// Function 89
float map(vec3 p){
    
	
	// Creating the repeat cubes, with slightly convex faces. Standard,
    // flat faced cubes don't capture the light quite as well.
   
    // Cube center offset, to create a bit of disorder, which breaks the
    // space up a little.
    vec3 o = hash33(floor(p))*0.2; 
    
    // 3D space repetition.
    p = fract(p + o)-.5; 
    
    // A bit of roundness. Used to give the cube faces a touch of convexity.
    float r = dot(p, p) - 0.21;
    
    // Max of abs(x), abs(y) and abs(z) minus a constant gives a cube.
    // Adding a little bit of "r," above, rounds off the surfaces a bit.
    p = abs(p); 
	return max(max(p.x, p.y), p.z)*.95 + r*0.05 - 0.21;
    
    
    // Alternative. Egg shapes... kind of.
    //float perturb = sin(p.x*10.)*sin(p.y*10.)*sin(p.z*10.);
	//p += hash33(floor(p))*.2;
	//return length(fract(p)-.5)-0.25 + perturb*0.05;
	
}

// Function 90
function generateSDF(text) {
	var length = measureText(text);
	var lines = [];
	lines.push("// SDF of the scene.");
	lines.push("float z_offset = float(" + (length / 2) + ");");
	lines.push("float sdf(in vec3 pos) {");
	lines.push("	float t = 1000.0;");
	lines.push("	vec3 offset = vec3(" + (-length / 2) + ", 4, " + Math.ceil(-length * 0.65) + ");");
	var x = 0;
	for (var i = 0; i < text.length; i++) {
		if (text[i] == ' ') {
			x += 3;
		} else {
			if (text[i] in widths) {
				lines.push("	t = min(t, sdf_" + text[i] + "(pos, vec3(" + x + ", 0, 0) + offset));");
				x += widths[text[i]];
				if (i != text.length - 1) {
					x += 2;
				}
			} else {
				console.error("Bad character '" + text[i] + "' at index " + i + " in string \"" + text + "\"");
			}
		}
	}
	lines.push("	return t;");
	lines.push("}");
	return lines.join('\n');
}

// Function 91
float distanceEstimation(vec3 pos, out vec3 diffuseColor, out vec3 emissionColor) {
    if(length(pos) > 2.5) return length(pos) - 2.0;
    vec3 z = pos;
    float dr = 1.0, r = 0.0, theta, phi;
    for (int i = 0; i < 8; i++) {
        r = length(z);
        if (r>2.0) break;
        dr =  pow( r, Power-1.0)*Power*dr + 1.0;
        theta = acos(z.z/r) * Power + ThetaShift;
        phi = atan(z.y,z.x) * Power;
        float sinTheta = sin(theta);
        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;
    }
    float val = abs(cos(theta/Power));
    diffuseColor = vec3(.0);
    emissionColor = vec3(.3, .5, .7)*6.0;
    if(val > .15) {
        diffuseColor = vec3(1.0);
        emissionColor *= .05 + (1.0-val)*.1;
    }
    return 0.5*log(r)*r/dr;
}

// Function 92
float dist_to_plot(vec2 p, vec2 fdf) {
    
  vec2 p0 = vec2(p.x, fdf.x);
  vec2 n = normalize(vec2(-fdf.y, 1));
  return abs(dot(p - p0, n));
    
}

// Function 93
float remap (float a, float b, float c, float d, float t) {
    return remap01 (a, b, t) * (d-c) + c;
}

// Function 94
vec4 distInvID(vec3 p)
{	vec3 pos=vec3(-.75,0,0);
	vec4 r=u(laptop_openID(at_pos(pos+vec3(0,-0.1,0),p),35.,.20),
             vec4(coconut(at_pos(pos+vec3(.5,0,0),p)),ID_WOOD,vec2(0)));
  
 	r=u(r, vec4(sscreen_bottle(at_pos(pos+vec3(1.0,0,0),p)),ID_BLACK,vec2(0)));  
    return r;
}

// Function 95
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstObj;
  pPos = 1.2 * vec3 (0., - (0.5 + 0.5 * sin (0.09 * 2. * pi * tCur)),
     (0.5 + 0.5 * sin (0.11 * 2. * pi * tCur)));
  rSep = 0.5 + 0.5 * sin (0.3 * 2. * pi * tCur);
  objType = int (idPage);
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (idObj == 1) {
      col4 = vec4 (1., 1., 0.2, 0.2);
    } else {
      if (abs (((idObj == 2) ? vn.y : vn.z)) < 0.99) col4 = vec4 (0.1);
      else col4 = (((idObj == 2) ? vec4 (1., 0.9, 1., 0.1) : vec4 (0.9, 1., 1., 0.1))) *
         (0.3 + 0.7 * smoothstep (-0.2, 0.2, sin (8. * pi * ObjTypeDst (ro)))) *
         (0.8 + 0.2 * smoothstep (0., 0.05, length (ro.yz - pPos.yz)));
    }
    col = col4.rgb * (0.2 + 0.7 * max (dot (vn, ltDir), 0.) +
       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.));
  } else {
    col = vec3 (0.9);
  }
  return col;
}

// Function 96
vec3 HDRmapping(vec3 color, float exposure)
{
	// Exposure tone mapping
    vec3 mapped = ACESFilm(color * exposure);
    // Gamma correction 
    return pow(mapped, vec3(1.0 / 2.2));
}

// Function 97
vec2 remap( vec2 t, vec2 a, vec2 b ) {
	return clamp( (t - a) / (b - a), 0.0, 1.0 );
}

// Function 98
vec3 getDistances( vec3 a, vec3 b, vec3 c ) {
    return vec3( getDistance( a ), getDistance( b ), getDistance( c ) );
}

// Function 99
float map(vec3 p)
{	
// 	tunnel    
	p.z+=(3.-sin(0.314*iTime+1.1));
	pR(p.zy,1.57);
	return  mix(length(p.xz)-.2,length(vec3(p.x,abs(p.y)-1.3,p.z))-.2,step(1.3,abs(p.y)))-0.1*noise(8.*p+0.4*bounce);
}

// Function 100
float mapGlass(in vec3 position)
{
    vec3 cylinderPosition = GLASS_BASE_POSITION - LAMP_ORIGIN;
    return sdfCone(position + cylinderPosition, vec3(0,0,0), vec3(0,GLASS_HEIGHT,0), 0.7, 0.25);
}

// Function 101
vec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)
{
	return b1+(t-a1)*(b2-b1)/(a2-a1);
}

// Function 102
uint spheremap_16( in vec3 nor )
{
    vec2 v = nor.xy*inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x8(v);
}

// Function 103
vec3 map(vec2 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (vec3((value.s+value.t)/2.0 )- min1) * (max2 - min2) / (max1 - min1);
}

// Function 104
float sdf_box(vec2 uv, vec2 mins, vec2 maxs)
{
    return sdf_centered_box(uv, (mins+maxs)*.5, (maxs-mins)*.5);
}

// Function 105
float scene(vec3 p){
    float plane1 = boxplane(p);
    
    vec3 x = normalize(vec3(-1,sqrt(2.0),1));
    vec3 y = normalize(vec3(-1,0,-1));
    vec3 z = normalize(vec3(-1,-sqrt(2.0),1));
    
    float plane2 = boxplane(mat3(x,y,z) * p);
    float plane3 = boxplane(mat3(-x,y,z) * p);
    
	return min(plane1,min(plane2,plane3));
}

// Function 106
float scene(vec3 pos, int parity, out int type) {
  float edgeradius = 0.02;
  float vertexradius = 0.05;
  float d = 1e8, d0;
  type = 0;
#if defined DRAWDUAL
  {
#if defined DRAWFACES
    d0 = d;
#if defined INEXACT
    d = min(d, (dot(pos,vertex)-1.0)/vertexlength-roundness); // vertex is face centre
#else
    d = min(d, triangleDistance(pos,da,db,dc)-roundness);
#endif    
    if (d < d0) type = parity%2 == 0 ? DFACE0 : DFACE1;
#endif
    // Draw an edge in the dual if the vertex isn't on that edge
    bool ba = bool(trilinear[0]);
    bool bb = bool(trilinear[1]);
    bool bc = bool(trilinear[2]);
#if defined DRAWEDGES
    d0 = d;
    if (alledges || ba) d = min(d,segment(pos,db1,dc1)-edgeradius);
    if (alledges || bb) d = min(d,segment(pos,dc1,da1)-edgeradius);
    if (alledges || bc) d = min(d,segment(pos,da1,db1)-edgeradius);
    if (d < d0) type = DEDGE;
#endif
#if defined DRAWVERTICES
    d0 = d;
    // The rules for vertex display are subtle, this works
    // with R = 2 (ie. angle between A and C is PI/2)
    // (Display a vertex if at least 1 edge to that vertex is
    // displayed, unless the angle at that vertex is PI/2, in
    // which case both edges must be displayed).
    if (alledges || bb || bc) d = min(d,distance(pos,da1)-vertexradius);
    if (alledges || (bc && ba)) d = min(d,distance(pos,db1)-vertexradius);
    if (alledges || ba || bb) d = min(d,distance(pos,dc1)-vertexradius);
    if (d < d0) type = DVERTEX;
#endif
  }
#endif
#if defined DRAWUNIFORM
  {
#if defined DRAWFACES
    d0 = d;
    int facenumber;
    d = min(d,faces(pos,facenumber)-roundness);
    if (d < d0) type = FACE0+facenumber;
#endif
#if defined DRAWEDGES
    d0 = d;
    d = min(d,segment(pos,vertex1,reflect(vertex1,A))-edgeradius);
    d = min(d,segment(pos,vertex1,reflect(vertex1,B))-edgeradius);
    d = min(d,segment(pos,vertex1,reflect(vertex1,C))-edgeradius);
    if (d < d0) type = EDGE;
#endif
#if defined DRAWVERTICES
    d0 = d;
    d = min(d,distance(pos,vertex1)-vertexradius);
    if (d < d0) type = VERTEX;
#endif
  }
#endif
  return d;
}

// Function 107
float map_balls(vec3 pos)
{
    float ball1 = map_ball(pos, getBallPos(0.), ballR);
    float ball2 = map_ball(pos, getBallPos(3.3), ballR);
    float ball3 = map_ball(pos, getBallPos(6.6), ballR);
    float ball4 = map_ball(pos, getBallPos(9.9), ballR);
    float ball5 = map_ball(pos, getBallPos(13.2), ballR);
    
    float b = min(min(min(min(ball1, ball2), ball3), ball4), ball5);
    
    #ifdef test_mode
    b = max(b, -pos.y);
    #endif
    
    return b;
}

// Function 108
vec2 map(vec3 r)
{    
	float tt = t * 2.;
	float ttt = tt / 2. + sin(tt) / 2.;
	obj = rotY(ttt) * rotX(0.6 + cos(tt) * 0.2);
	vec3 rb1 = obj * r;
	rb1.x += 20. * (ttt / 2. / PI) + 10.;
	
	rb1 *= rotX(rb1.z * 0.005);
	vec3 rbp1 = mod(rb1+10., 20.) - 10.;
	
	vec2 b1 = vec2(
		box(rbp1, vec3(2., 2., 2.)), BONE
	);

    return b1;
}

// Function 109
vec4 mapSphere( vec3 pos, float radius )
{
//	float DEP_VAL =sin(time) +2.;
	float dist = length(  pos ) - radius;//+ .2*sin(DEP_VAL *pos.x + sin(5.*time)) * sin(DEP_VAL *pos.y+ cos(6.*time)) * sin(DEP_VAL *pos.z+ sin(time));
	vec3 col = vec3( 1.0, .2, .2 );
	return  vec4( col, dist);
}

// Function 110
vec4 mapFloor ( vec3 pos )
{
	vec3 col1 = vec3( 1., 0., 0.);
	vec3 col2 = vec3( 0., 1., 0.);
	float val = sign( fract( .25*pos.x) -.5 ) * sign( fract( .25*pos.z) -.5 );
	vec3 col =mix( col1, col2, val );
	float dist = pos.y;
	return vec4( col, dist );
}

// Function 111
float sceneSDF(vec3 p,int iters) {
    p /= scale;


    float result = 0.0;
    float i = 1.0;
    //p *= 2.0;
    for(int k = 0; k < 6; k++){
        result -= min(-result,planet_surface(p*i))/(i*i);
        i *= -1.5;
        if(k == iters) break;
        //p *= -1.0001;
        //i /= 2.0;
        //i /= -3.0;
        //p *= 3.0;
        //i /= 3.0;
    }
    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));
    return (result-p.y*2.0)*scale/4.0;
}

// Function 112
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(8./iResolution.y, 0); 
    
    float f = bumpFunc(p, n); // Hit point function sample.
    
    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.
    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.
    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.
    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.
    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x*2.);
    
    
    // We may as well use the six measurements to obtain a rough curvature value while we're at it.
    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 113
float boxSDF( vec3 point, vec3 center, vec3 size ) {
    vec3 diff = abs( point - center ) - size;
    return max( diff.x, max( diff.y, diff.z ) );
}

// Function 114
float distanceField(vec3 p)
{
	//Rotate scene around y-axis
	vec3 rotP = rotate(p, vec3(0, mod(iTime*20.0, 360.0),0));
	rotP = rotate(rotP-vec3(0,-0.6,0), vec3(0, 45,55));
	

	float dPlane = distPlane(p, vec3(0,1,0), -2.0);
	float dFrac = distFrac(rotP);
	return min(dFrac, dPlane);
}

// Function 115
float Distance(vec2 pos, vec2 line)
{
    return abs(line.x * pos.x - pos.y + line.y) / sqrt(line.x * line.x + 1.0);
}

// Function 116
float rounded_cone_sdf( vec3 p, float r1, float r2, float h )
{
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 117
float getDistLead(vec3 pos)
{
    vec2 uv=(pos.xy*Res.x+Res)*.5/Res;
    vec4 c=textureLod(iChannel0,uv,0.);
    float d=c.z/Res.x*2.;
    //float sc=c.w/Res.x;
    // take mipmapped version of cell scale, so we dont get jumps when raymarching
    float sc=textureLod(iChannel0,uv,2.5).w/Res.x;
    d=sqrt(d*d+pos.z*pos.z)-sqrt(sc)/60.;
    //d=sqrt(d*d+pos.z*pos.z)-0.001;
    d=max(d,getDistBox(pos,vec3(Res/Res.x,0.01)));
    return d; 
}

// Function 118
float map(vec3 p) {
    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));
    
    float rot_x = iTime * 3.1415 * 0.2;
    float cx = cos(rot_x);
    float sx = sin(rot_x);
    
    float rot_z = iTime * 3.1415 * 0.125;
    float cz = cos(rot_z);
    float sz = sin(rot_z);
    
    p = vec3(
        p.x,
        p.y * cx - p.z * sx,
        p.z * cx + p.y * sx
    );
    
    p = vec3(
        p.x * cz - p.y * sz,
        p.y * cz + p.x * sz,
        p.z
    );
    
    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));
    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));
     
    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));
    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));
    
    return d;
}

// Function 119
float DistanceField( vec3 pos )
{
#ifdef BLOB
	float a = atan(pos.x,pos.z)+iTime*.5;
	pos.xz = length(pos.xz)*vec2(sin(a),cos(a));
	return .5*(length(pos)-2.0+(Noise(pos).x+Noise(pos*2.0+iTime*vec3(0,1.0,0)).x/2.0)*1.0);
#else
	// rotational symmettry
	const float slice = tau/12.0;
	float a = abs(fract(atan(pos.x,pos.z)/slice+iTime*2.5)-.5)*slice;
	pos.xz = length(pos.xz)*vec2(sin(a),cos(a));
	
	// symettry in y
	pos.y = abs(pos.y);
	
	return dot(pos,normalize(vec3(1,1,1))) - 1.0;
#endif
}

// Function 120
float starSDF(vec2 st, int V, float s) { // 28
    st = st * 4. - 2.;
    float a = atan(st.y, st.x) / TAU;
    float seg = a * float(V);
    a = ((floor(seg) + 0.5) / float(V) +
        mix(s, -s, step(.5, fract(seg))))
        * TAU;
    return abs(dot(vec2(cos(a), sin(a)), st));
}

// Function 121
float starSDF( vec3 point, vec3 center, float len, float thickness ) {
    vec3 a0 = vec3( +0.000 * len, +1.000 * len, center.z ); // @ r:+1.570 , d:90
    vec3 a1 = vec3( -0.952 * len, +0.309 * len, center.z ); // @ r:+2.827 , d:162
    vec3 a2 = vec3( -0.588 * len, -0.810 * len, center.z ); // @ r:+4.084 , d:234
    vec3 a3 = vec3( +0.587 * len, -0.810 * len, center.z ); // @ r:+5.340 , d:306
    vec3 a4 = vec3( +0.951 * len, +0.309 * len, center.z ); // @ r:+6.597 , d:378
    
    float d0 = starSegmentSDF( point, a0, center, thickness );
    float d1 = starSegmentSDF( point, a1, center, thickness );
    float d2 = starSegmentSDF( point, a2, center, thickness );
    float d3 = starSegmentSDF( point, a3, center, thickness );
    float d4 = starSegmentSDF( point, a4, center, thickness );

    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );
}

// Function 122
vec2 lens_distort_coords(vec2 input_coords){
	// Radial distortion. See https://docs.opencv.org/3.4.3/dc/dbb/tutorial_py_calibration.html
	// This code is based on modules/calib3d/src/undistort.cpp in the function
	// cvUndistortPointsInternal where they do an iterative undistort that compares the
	// real values with computed distorted ones. The changes are mostly to try make
	// it obvious to the GLSL compiler what we are doing in the hope it can optimize the
	// multiplies more effectively. This should be disassembled/tested at some point.
	float x = input_coords.x;
	float y = input_coords.y;
	
	float r2 = dot(input_coords, input_coords);  // u.u = |u|^2
	float r4 = r2 * r2;
	float r6 = r2 * r4;
	
	float a1 = 2.0 * x * y;
	float a2 = r2 + 2.0 * x * x;
	float a3 = r2 + 2.0 * y * y;
	float cdist = 1.0 + dot(lens_radial_distortion, vec3(r2, r4, r6));
	vec2 tangental_dist = vec2(
		dot(lens_tangental_distortion, vec2(a1, a2)),
		dot(lens_tangental_distortion, vec2(a3, a1))
	);
	vec2 distort_amt = vec2(cdist) + tangental_dist;

	return input_coords * distort_amt * lens_zoom_factor;
}

// Function 123
vec4 scene(vec3 p)
{
	// plane
	vec3 ft = floorTex(p.xz);
	float d = abs(p.y - 0.08 + height(p.xz) + 0.3 - 0.1*smoothstep(0.0, 0.5, ft.b));
	vec3 col = ft*2.4 - 0.5*abs(sin(p.x));
	return vec4(col, d);
}

// Function 124
vec3 map(vec3 p) {	
	
		p.y -= 900.;
        float uAngle = iTime * uSpeed;

		p *= rotY(uAngle);
		
		vec3 s = vec3(100000.0);
		s.x = min(min(min(min(min(min(min(min(s.x, head(p)), helmet(p)), body(p)), arms(p)), hands(p)), hips(p)), legs(p)), shoes(p));
		return s;	
	}

// Function 125
float remap01(float a, float b, float t)
{
    return sat((t - a) / (b - a));
}

// Function 126
float map(in vec3 p) {
    float d = dfPln(p, vec3(0,1,0), 0.);
    for (float i=0.; i<3.; i+=1.) {
        d = min(d, dfBox(p-vec3(i*1.01-0.025,.5,0), vec3(.42-i*.01), .09));
        d = min(d, dfBox(p-vec3(4.,.5,i), vec3(.4), .09));
        d = min(d, dfBox(p-vec3(4.,i+.5,4.), vec3(.4), .09));
    }
    d = min(d, dfBox(p-vec3(3.,.5,0.), vec3(.4), .09));
    d = min(d, dfBox(p-vec3(4.,.5,3.), vec3(.4), .09));
    d = min(d,max(min(dfBox(p-vec3(4.,3.5,4.), vec3(.4), .09),
                      dfBox(p-vec3(4.,4.5,4.), vec3(.4), .09)),
                      dfPln(p-vec3(4.,3.70,4.), normalize(vec3(-0.08,0.96,-1)), .1)));
    return d;
}

// Function 127
float BaublesSDF( vec3 pos, uint seed, float spacing, float radius, float power, float twist, float depth )
{
    // avoid looping over every bauble - find closest one from a handful of candidates, using a jittered grid
    float f = BaubleBoundsSDF(pos,depth);
    f -= radius;
    
    float margin = .1; // distance at which to start computing bauble SDFs - affects speed of marching (trial and error suggests .1 is fairly optimal)
    if ( f > margin ) return f;
    
	vec3 offset = spacing*(hash3(coord1(seed))-.5); // use a different grid for each set of baubles
    offset += PATTERN_SCROLL*iTime;
	pos += offset;

    // find closest centre point
    vec3 c = floor(pos/spacing);
    ivec3 ic = ivec3(c);
    c = (c+.5)*spacing; // centre of the grid square
    
    c += (spacing*.5 - radius /*- margin*/) * ( hash1(coord3(uvec3(ic+63356))^seed)*2. - 1. );
    
    // cull it if it's outside bounds
    if ( BaubleBoundsSDF(c-offset,depth) > 0. ) return margin; // could do max (margin, distance to grid cell edge)
    
//    float f = length(pos-c)-radius;
    vec3 v = pos-c;
    v.xz = v.xz*cos(v.y*twist) + v.zx*vec2(1,-1)*sin(v.y*twist);
    v = abs(v)/radius;
    f = (pow(dot(v,pow(v,vec3(power-1.))),1./power)-1.)*radius;
    return min( f, margin ); // don't return values > margin otherwise we'll overshoot in next cell!
}

// Function 128
float sdfUnion(in float a, in float b) {
	return min(a, b);   
}

// Function 129
RayHit RaymarchScene(in Ray ray)
{
    RayHit hit;
    
    hit.hit      = false;
    hit.material = 0.0;
    
    float sdf = FarClip;
    
    for(float depth = NearClip; depth < FarClip; )
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf < Epsilon)
        {
            hit.hit      = true;
            hit.surfPos  = pos;
            hit.surfNorm = Scene_Normal(pos);
            
            return hit;
        }
        
        depth += sdf;
    }
    
    return hit;
}

// Function 130
float map( in vec3 pos )
{
    return sdBoundingBox(pos, vec3(0.5,0.3,0.5), 0.025 );
}

// Function 131
void sampleCubemap(vec2 p, out float size, out bool inShape){
    vec4 t = T(p,0);
    inShape = t.x>0.5;
    size = t.g;
}

// Function 132
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn, ltDir;
  vec2 pb;
  float dHit, f, ltDist, atten, brt;
  int idObjT;
  dHit = ObjRay (ro, rd);
  if (dHit < dstFar) {
    ro += rd * dHit;
    idObjT = idObj;
    vn = ObjNf (ro);
    idObj = idObjT;
    ltDir = ltPos - ro;
    ltDist = length (ltDir);
    ltDir /= ltDist;
    atten = 1.2 * smoothstep (0.55, 0.65, dot (ltAx, - ltDir)) /
       pow (max (ltDist, 1.), 1.2);
    pb = abs (mod (ro.xz + vec2 (16., 0.), 2. * vec2 (16., 8.)) - vec2 (16., 8.));
    pb.x = abs (pb.x - 4.);
    brt = (ro.y < 2. && length (pb) < 0.7) ? 0.2 : 0.;
    if (idObj == idLt) {
      col = vec3 (1., 1., 0.3) * (0.9 - 0.1 * vn.y);
    } else if (idObj >= idDrBod) {
      col4 = DroneCol ();
      col = col4.xyz;
      if (col4.a >= 0.)
        col = col * (0.2 + 0.8 * atten * max (dot (ltDir, vn), 0.)) +
           atten * pow (max (dot (reflect (rd, vn), ltDir), 0.), 64.);
    } else {
      if (idObj == idBase) vn = TileFloor (ro, 150.);
      else if (idObj != idRail && idObj != idWire)
         vn = MengSurf (ro, vn, 150.);
      if (idObj != idWire) {
        vn = VaryNf (32. * ro, vn, 3.);
        col = 1.5 * mix (vec3 (0.1, 0.2, 0.25), vec3 (0.2, 0.1, 0.05),
           Fbm3 (3. * ro));
      } else col = vec3 (0.5, 0.5, 0.6);
      if (idObj == idBase) col *= TileFun (ro.xz);
      else if (bumpShd > 0.) col *= 0.7;
      col = col * (0.2 + 10. * atten * max (dot (ltDir, vn), 0.)) +
         2. * atten * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.);
      col = mix (col, vec3 (1., 1., 0.5), brt);
      col = mix (col, vec3 (0.6, 0., 0.) * (0.3 + 0.7 * Fbm1 (5. * tCur)),
         1. - smoothstep (-10., -4.2, ro.y));
    }
  } else col = vec3 (0.);
  f = dHit / dstFar;
  col = mix (col, 0.3 * vec3 (0.7, 0.9, 1.), smoothstep (0.4, 1., f * f));
  return col;
}

// Function 133
vec3 mapNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = map(pt).x;    
    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 134
float dist (vec3 U, vec4 A) {
	return length(U-A.xyz)-A.w;
}

// Function 135
float sdFluffTorus(vec3 p, vec2 s)
{
    float rad2 = s.y * 0.3;
    s.y -= rad2 * fbm(p*8.0);
    return sdTorus(p,s);
}

// Function 136
float sdf(vec3 a){vec3 dc,ec;return sdf(a,dc,ec);}

// Function 137
SSdfSample SdfBlobby(vec3 pos, float uRandom)
{
	const float gGgxAlpha = 1.0 / 64.0;
	const vec4 sphereBase = vec4(0.0, 0.0, 200.0, 50.0);

	SSdfSample sdf = SdfSphere(
						Sphere0(sphereBase, uRandom),
						MtlCreate(vec3(0.1, 0.8, 0.1) / 4.0, gGgxAlpha),
						pos);

	sdf = SdfSoftMin(
			sdf,
			SdfSphere(
				Sphere1(sphereBase, uRandom),
				MtlCreate(vec3(0.1, 0.3, 0.8) / 4.0, gGgxAlpha),
				pos),
			SSoftMinRadius01(uRandom));

	sdf = SdfSoftMin(
			sdf,
			SdfSphere(
				Sphere2(sphereBase, uRandom),
				MtlCreate(vec3(0.7, 0.05, 0.2) / 4.0, gGgxAlpha),
				pos),
			SSoftMinRadius12(uRandom));

	return sdf;
}

// Function 138
float map_box(in vec3 ro) {
  vec3 d = abs(b1.c - ro) - b1.s;
  return min(max(d.x,max(d.y,d.z)),0.) + length(max(d,0.));
}

// Function 139
int map_mode() {
    return (iMouse.w > 0.0) ? MAP_EQUIRECTANGULAR : MAP_FISHEYE;
}

// Function 140
float sceneSDF(vec3 pos) 
{
    float d = max(0., (length(pos.xz) - (ISLAND_RADIUS - FALLOFF_DIST)) / FALLOFF_DIST);
    float fact =  (-pow(d, 6.) + 1.);
    
    if (pos.y > 0.) 
    {
    	return fbm(pos.xz, 17. * fact, .085, 1.1, .25) + MID_HALF_THICKNESS;
    }
    else
    {
    	return fbm(pos.xz, -90. * fact, .125, 2.2, .1) - MID_HALF_THICKNESS;
    }
}

// Function 141
float GetDist(vec3 p)
{
    vec4 s = vec4(0,1,6,1);// (s.xyz)s.w
    float sphereDist = length(p-s.xyz)-s.w;// P
    float planeDist  = p.y;// P
    
    float d = min(sphereDist,planeDist);
    return d;
}

// Function 142
float mapDistance(const in vec3 point) {
  float tmpComb_35 = opUnionStairs(
      cullPlane(
          pMod(
              (
                  mat4(
                      1.0,0.0,0.0,0.0,
                      0.0,1.0,0.0,0.0,
                      0.0,0.0,1.0,0.0,
                      0.0,0.3,0.0,1.0
                  ) * vec4(point, 1.0)
              ).xyz, 
              vec3(-5.0,-5.0,-5.0)
          )
      ) * 1.0, 
      sdSphere(
          pMod(
              (
                  mat4(
                      1.0,0.0,0.0,0.0,
                      0.0,1.0,0.0,0.0,
                      0.0,0.0,1.0,0.0,
                      0.0,0.0,0.0,1.0
                  ) * vec4(point, 1.0)
              ).xyz, 
              vec3(5.0,5.0,5.0)
          ), 
          0.31
      ) * 1.0, 
      vec2(2.6,9.91)
  );
  float tmpComb_36 = opUnionColumns(
      tmpComb_35, 
      sdTorus(
          pMod(
              (
                  mat4(
                      1.0,0.0,0.0,0.0,
                      0.0,1.0,0.0,0.0,
                      0.0,0.0,1.0,0.0,
                      0.0,3.18 - mod(iTime + point.z, 10.0),0.0,1.0
                  ) * vec4(point, 1.0)
              ).xyz, 
              vec3(9.0,-13.0,9.0)
          ), 
          vec2(2.5,0.3)
      ) * 1.0, 
      vec2(12.16,10.0)
  );
  return tmpComb_36;
}

// Function 143
float distPlane(in vec3 p, vec4 n)
{
    return dot(p, n.xyz) * n.w;
}

// Function 144
vec3 scene_normal(vec3 pos, float d)
{
    return normalize(
		vec3(dst(vec3(pos.x + EPS, pos.y, pos.z)),
			 dst(vec3(pos.x, pos.y + EPS, pos.z)),
		 	 dst(vec3(pos.x, pos.y, pos.z + EPS))) - d);
}

// Function 145
void Scene_Trim( inout SceneResult a, const in SceneResult b )
{
    if ( a.fDist < -b.fDist )
    {
        a.fDist = -b.fDist;
    }
}

// Function 146
vec3 sceneNorm(vec3 p)
{
    vec3 e=vec3(1e-2,0,0);
    float d = sceneDist(p);
    return normalize(vec3(sceneDist(p + e.xyy) - d, sceneDist(p + e.yxy) - d,
                          sceneDist(p + e.yyx) - d));
}

// Function 147
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    for(int i=0; i<8; i++ ) {
        CHECK_OBJ( objects[i] );
    }
    return ( nearestDist < 1000.0 );
}

// Function 148
float dist_cube(vec3 p)
{

	return length(max(abs(p)-vec3(2.5,0.1,0.5),0.0))-0.1;
}

// Function 149
float map(in vec3 p)
{
     return mix(deTorusKnot(p), deMobius(p), step(5.0, mod(iTime, 8.0)));
}

// Function 150
RaycastHit raycastScene(const Ray ray) {

    RaycastHit sphere1 = intersectSphere(vec3(sin(iTime),0.,0.),.6,ray);
    RaycastHit plane = intersectPlane(vec3(0., -.6, 0.), vec3(0.,1.,0.),ray);
    
    if(sphere1.type > -1) {
     
        return sphere1;
        
    }
    
    return plane;
    
}

// Function 151
float mapLavaAndMetal(in vec3 position)
{
    for(int i = 0; i < NUM_SPHERE; i++ )
    {
        float oneHash = hash1(i);
        vec3 threeHash = hash3(i);
        
        float sphereRadius = clamp(oneHash, MIN_RADIUS, MAX_RADIUS);
        vec3 sphereSpawn = vec3( (threeHash * 2.0) - 1.0 ) * SPREAD;
        sphereSpawn.y = GLASS_BASE_POSITION.y + sphereRadius;
        vec3 topPoint = vec3(0.0f, -GLASS_HEIGHT + sphereRadius + 0.25, 0.0f);
        float timeline = easeInOutQuint((sin(iTime * oneHash * ANIMATION_SPEED) + 1.0f ) * 0.5f);
        sphereSpawn = mix(topPoint, sphereSpawn, timeline);
        
        vec3 spherePos = position + sphereSpawn - LAMP_ORIGIN;
        
        spheres[i] = sphere(spherePos, sphereRadius, timeline);
    }
    float currentMin = sdfSphere(spheres[0]);
    
    for(int i = 1; i < NUM_SPHERE; i++ )
    {
        currentMin = smoothMin(currentMin, sdfSphere(spheres[i]), BLEND_STRENGTH * spheres[i].height + 0.15);
    }

    float metalMin = mapMetal(position);
    possibleColor = LAVA_COLOR;
    if( metalMin < currentMin )
    {
        currentMin = metalMin;
        possibleColor = vec3(0.5);
    }

    return currentMin;
}

// Function 152
vec4 mapL(vec3 p)
{
	p.xy -= path(p.z);													// tunnel path
	
    // mix from displace of last section id with displace of current section id accroding to id range 
    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); 	// id range [0-1]
	
    p *= getRotZMat(p.z*0.05);
	
   	p = mod(p, 10.) - 5.;
    
    return vec4(abs(p.y)+2. - 1. + r * .9,p);
}

// Function 153
vec3 distanceRaySegment( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb )
{
	vec3 ba = pb - pa;
	vec3 oa = ro - pa;
	
	float oad  = dot( oa, rd );
	float dba  = dot( rd, ba );
	float baba = dot( ba, ba );
	float oaba = dot( oa, ba );
	
	vec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);
	
	th.x = max(   th.x, 0.0 );
	th.y = clamp( th.y, 0.0, 1.0 );
	
	vec3 p = pa + ba*th.y;
	vec3 q = ro + rd*th.x;
	
	return vec3( length( p-q ), th );
}

// Function 154
float sdfPlane(in vec3 p, in vec3 n, in float d)
{
    return dot(p, n) + d;
}

// Function 155
float distToSphere(Sphere s, vec3 inPos)
{
return length(inPos - s.pos) - s.r;
}

// Function 156
vec2 map( in vec2 uv )
{
    uv.x *= 5.0;
    uv.x += 0.01 * iTime;
    uv.y *= 15.0;
    return uv;
}

// Function 157
float distanceField(vec3 p, inout float m)
{
	float d = p.z;
	m = 1.0;
	
	float table = pRoundBox(vec3(0,0,-12) + p, vec3(14,6,0.5), 0.4);
	table = fIntersection(pSphere(vec3(0,0,-74) + p, 63.2), table);
	table = fUnion(pRoundBox( (vec3(9.0 + cos(p.z) * 0.3,4.0 + cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);
	table = fUnion(pRoundBox( (vec3(-9.0 - cos(p.z) * 0.3,4.0 + cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);
	table = fUnion(pRoundBox( (vec3(-9.0 - cos(p.z) * 0.3,-4.0 - cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);
	table = fUnion(pRoundBox( (vec3(9.0 + cos(p.z) * 0.3,-4.0 - cos(p.z) * 0.2,-6) + p) , vec3(1,1,6), 0.2), table);
	
	float sphere1 = pSphere(vec3(6,1,-16) + p, 3.0);
	
	fUnionMat(d, m, table, 2.0);
	fUnionMat(d, m, sphere1, 3.0);
	
	return d;	
}

// Function 158
float sdf(vec3 pos)
{    
  float d = MAX_FLT;
  d = floorSdf(pos);
  d = min(d, pillarsSdf(pos));
  d = min(d, ceilingSdf(pos));
  //d = min(d, debugPillarSdf(pos));
  vec4 light = getLightPos();
  d = min(d, sdSphere(pos - light.xyz, light.w));
  return d;
}

// Function 159
float terrainheightmap(vec3 p)
{
    return p.y+.75+5.*fbm(p.xz)+ 30.*perlin(p.xz*.025)+.1*fbm(10.*p.zx)+length(p.xz)/5.;
}

// Function 160
float mapHole(vec3 p) {
    float s = sdSphere(p-vec3(0.0, 0.0, 0.0), 4.0);
    return s * fract(p.y*0.5);
}

// Function 161
float treeSDF(vec2 pos, vec2 trunk) {
    vec3 h = hash3(trunk);
    float r = treeScale * (0.9 + 0.35 * h.z);
    trunk += treeScale * 0.5 * (h.xy - 0.5);
    float terrain = fbm1(terrainScaleInv * trunk);
    float plant = step(treeTerrainThresholdLow, terrain) * step(terrain, treeTerrainThresholdHigh);
    plant *= step(treeGrowthThreshold, fbm1(treeGrowthScaleInv * trunk + 100.0));
    return r - distance(pos, trunk) - 100.0 * (1.0 - plant);
}

// Function 162
Intersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)
{
    float t;
    int objId;
    march(eye, dir, t, objId, lightPos);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect, lightPos);
    vec3 lightDir = normalize(lightPos - isect);
    vec3 surfaceColor = computeMaterial(objId, isect, nor, lightDir, normalize(eye - isect));
    
    vec3 sdfColor = clamp(surfaceColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);
    return Intersection(t, sdfColor, isect, objId);
}

// Function 163
vec4 ray_scene(vec3 ro, vec3 rd, out int obj_id, out vec3 N){
    vec4 h;
    vec4 h1;
    ro /= 2.0;
    h1 = ray_grid(ro, rd, obj_id);
    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
        h = h1;
    }
    
    h1 = ray_sphere(ro, rd, 40.0);
    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){
        h = h1;
        obj_id = 3;
    }
    h.w *= 2.0;
    N = h.xyz;
    return h;
}

// Function 164
vec3 scene(vec2 uv, vec4 ms) {
    
	vec2 ci = vec2(.0);

    // drag your mouse to apply circle inversion
    if (ms.y != -2. && ms.w > -2.) {
        uv = inversion(uv,cos(radians(60.)));
        ci = ms.xy;
    }    

    // remap uv to appolonian packing
    vec3 uvApo = apollonian(uv-ci);
    
    float d = 6.2830/360.;
    float a = atan(uvApo.y,uvApo.x);
    float r = length(uvApo.xy);

    float circle = sdfCircle(uv,uv-uvApo.xy,uvApo.z);
	
    // background
	vec3 c = length(uv)*pal(.7)*.2;
    
    // drawing the clocks
    if (uvApo.z > .3) {
    	c = mix(c,pal(.75-r*.1)*.8,fill(circle+.02,.01,1.)); // clock 
    	c = mix(c,pal(.4+r*.1),stroke(circle+(uvApo.z*.03),uvApo.z*.01,.005,1.));// dial

        float h = stroke(mod(a+d*15.,d*30.)-d*15.,.02,0.01,1.);
    	c = mix(c,pal(.4+r*.1),h*stroke(circle+(uvApo.z*.16),uvApo.z*.25,.005,1.0));// hours

        float m = stroke(mod(a+d*15.,d*6.)-d*3.,.005,0.01,1.);
    	c = mix(c,pal(.45+r*.1),(1.-h)*m*stroke(circle+(uvApo.z*.15),uvApo.z*.1,.005,1.0));// minutes, 
    	
    	// needles rotation
    	vec2 uvrh = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z))*d*180.))*d*iTime*(1./uvApo.z*10.)-d*90.);
    	vec2 uvrm = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z)*4.)*d*180.))*d*iTime*(1./uvApo.z*120.)-d*90.);
    	// draw needles 
    	c = mix(c,pal(.85),stroke(sdfRect(uvrh+vec2(uvApo.z-(uvApo.z*.8),.0),uvApo.z*vec2(.4,.03)),uvApo.z*.01,0.005,1.));
    	c = mix(c,pal(.9),fill(sdfRect(uvrm+vec2(uvApo.z-(uvApo.z*.65),.0),uvApo.z*vec2(.5,.002)),0.005,1.));
    	c = mix(c,pal(.5+r*10.),fill(circle+uvApo.z-.02,0.005,1.)); // center
    // drawing the gears
    } else if (uvApo.z > .05) {
    	vec2 uvrg = uvApo.xy*uvRotate(sign(cos(hash(vec2(uvApo.z+2.))*d*180.))*d*iTime*(1./uvApo.z*20.));
        float g = stroke(mod(atan(uvrg.y,uvrg.x)+d*22.5,d*45.)-d*22.5,.3,.05,1.0);
        vec2 size = uvApo.z*vec2(.45,.08);
        c = mix(c,pal(.55-r*.6),fill(circle+g*(uvApo.z*.2)+.01,.001,1.)*fill(circle+(uvApo.z*.6),.005,.0));
        c = mix(c,pal(.55-r*.6),fill(min(sdfRect(uvrg,size.xy),sdfRect(uvrg,size.yx)),.005,1.));
    // drawing the screws
    } else { 
 	    vec2 size = uvApo.z * vec2(.5,.1);
 	    c = mix(c, pal(.85-(uvApo.z*2.)), fill(circle + 0.01,.007,1.));
 	    c = mix(c, pal(.8-(uvApo.z*3.)), fill(min(sdfRect(uvApo.xy,size.xy),sdfRect(uvApo.xy,size.yx)), .002, 1.));
    }
	return c;
}

// Function 165
float mapScene(in vec3 p) {
    return length(p) - 2.0;
}

// Function 166
vec2 SDFCageScene(vec3 r,int traceMode)
{
	float t=999999.0;
    vec3 origR=r;
	const float barDim=0.005;

    // paperplane
    if (traceMode==1)
    {
        r=r-vec3(0.0,0.0,-0.3+iTime-12.0);
    }
    else r=r-vec3(0.0,0.0,-0.3);
    float paperplane=sdPaperplane(r);
    t=min(t,paperplane);
    
    if ((t==paperplane)&&(traceMode==1)) return vec2(t,1.0);
    
    // floor
    r=origR;
    float floory=sdPlane(r-vec3(0.0,0.0,0.0),vec4(0.0,1.0,0.0,1.0));
    t=min(t,floory);
    
    // cage structure
    float base=sdRoundedCylinder(r-vec3(0.0,0.31,0.0),0.37,0.01,0.02);
	float minBase=sdRoundedCylinder(r-vec3(0.0,0.37,0.0),0.34,0.01,0.06);
    base=max(-minBase,base);
    t=min(t,base);
    float upperCircle=sdTorus(r-vec3(0.0,1.21,0.0),vec2(0.7,barDim));
    t=min(t,upperCircle);
    float lowerCircle=sdTorus(r-vec3(0.0,0.7,0.0),vec2(0.7,barDim));
    t=min(t,lowerCircle);
    float upperHang=sdVertTorus(r-vec3(0.0,1.98,0.0),vec2(0.08,0.01));
    t=min(t,upperHang);

    //

    r=origR;
	pModPolar(r.xz,12.0);
    
    float bar=sdVerticalCapsule(r-vec3(.7,.3,0.0),0.98,barDim);
    t=min(t,bar);
    
	float arc=sdCappedTorus(r-vec3(0.0,1.2,0.0),vec2(1.,.01),0.702,barDim);
    t=min(t,arc);
    
    if (t==paperplane) return vec2(t,1.0);
    if (t==bar) return vec2(t,3.0);
    if (t==arc) return vec2(t,3.0);
    if (t==upperCircle) return vec2(t,3.0);
    if (t==lowerCircle) return vec2(t,3.0);
    if (t==upperHang) return vec2(t,3.0);
    if (t==base) return vec2(t,4.0);
    if (t==floory) return vec2(t,5.0);
    
    return vec2(-1.0);
}

// Function 167
float map(vec3 p){
    
    //rotate ball
    p = rotateX(p,iMouse.y/100. + iTime/7.);
    p = rotateY(p,iMouse.x/100. + iTime/7.); 

    // animate noise
    float timeOffset = iTime/70.;
    
  	return noiseLayer(p+timeOffset) - dispOffset;  
}

// Function 168
vec3 tonemapACES( vec3 x )
{
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return (x*(a*x+b))/(x*(c*x+d)+e);
}

// Function 169
float circleSDF(vec2 st) {
    return length(st-.5)*2.;
}

// Function 170
float fogmap(in vec3 p, in float d)
{
    p += iTime * FOGMAP_SPEED * FOGMAP_DIR;
    return saturate(fogNoise(p * 0.05) * fogNoise(p * 0.1) * 0.5);
}

// Function 171
vec3 map(vec3 p)
{
    vec3 q;
    vec3 d = vec2(0, 1.).yxx;
	dmin(d, length(p+vec3(cos(0.1*iTime),sin(0.1*iTime),2.5+sin(0.5*iTime)))-.3, 1., .5); 
	dmin(d, length(p+vec3(cos(0.3*iTime),sin(0.3*iTime),2.5-sin(0.5*iTime)))-.3, 1.,-.5); 
    q=p;
    q.xy = vec2( (atan(q.x,q.y)+0.*sin(0.9*sqrt(dot(q.xy,q.xy))-0.5*iTime)),1.-length(q.xy));   
    dmin(d, .8-abs(q.y)-.6*noise(5.*q+0.1*iTime)-0.05*noise(40.*q-iTime), 0., 1.); 
	return d;

}

// Function 172
float GetDistanceBox(const in vec3 vPos, const in vec3 vDimension)
{
	return length(max(abs(vPos)-vDimension,0.0));
}

// Function 173
vec3 map_nrm(vec3 ro, int c) { 
    if (c == mtLight)	 return map_light_norm(ro);
    else if (c == mtSsph)return map_Ssph_norm(ro);
    else if (c == mtGsph)return map_Gsph_norm(ro);
    else if (c == mtBox) return map_box_norm(ro);
    else return vec3(0., 1., 0.);
}

// Function 174
float GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}

// Function 175
vec4 bufferCubemap(in sampler2D buffer, in vec2 bufferSize, in vec3 d) 
{
    bufferSize.y = min(bufferSize.y, bufferSize.x*0.66667 + 4.0);
    
    vec3 i = 1.0 / min(-d, d);
    vec3 p = d * -0.5 * max(max(i.x, i.y), i.z);
	vec3 n = sign(d) * step(i.yzx, i.xyz) * step(i.zxy, i.xyz);
    
	vec2 px = vec2(-p.z*n.x, p.y) * step(0.5, n.x)
              + vec2(-p.y, p.z*n.x) * step(n.x, -0.5);
    vec2 py = vec2(-p.x*n.y, -p.z) * abs(n.y);
    vec2 pz = vec2(p.x*n.z, p.y) * abs(n.z);
    
	vec2 t = vec2(abs(n.x) + 2.0*(step(n.y, -0.5) + step(n.z, -0.5)),
			      abs(n.y) + step(n.x, -0.5));
    
    vec2 uv = (vec2(t.x, 0.0) + (px + py + pz) + 0.5)
              * (bufferSize.y - 2.0) * 0.5/bufferSize;
    uv.y = abs(t.y - uv.y);
    
    return texture(buffer, uv, -100.0);
}

// Function 176
float map(vec3 p){
    
    // Wrap the tunnel (polar mapped hexagonal pylons) around the path.
    p.xy -= path(p.z);
    
    // Scaling along Z. Changing this value requires tile diameter, tile number and
    // tunnel width adjustments.
    const float zScale = 1.5;
    
    // Number of pylon segments spread around the tunnel. Actually, the final count is
    // twice this amount, due to rendering two pylons side by side. The other two are
    // rendered in front in the X direction.
    const float aNum = 8.;
    

    // Radius of the tunnel. The radial polar coordinate with be edged out by that amount.
    const float tunRad = 1.63;
    
    // Effectively the length of the blocks. Set to something deep enough to block out all
    // the light. Set it to something like ".1" to see thin tiles.
    const float blockRad = 1.;
    
    
    // Just an extra factor that controls random height.
    float rndFactor = .5;
    
    
    // Hexagonal block dimensions. Play around with them to see what they do.
    const vec3 wd = vec3(blockRad, .235*zScale, .235*zScale);
    
    // Holding vector for the cylindrical coordinates. 
    vec3 pC;
    
    // A cheap way to polar map a squarish tunnel. Simply mutate the the regular tunnel
    // wall positions a bit. If you warp things too much, the blocks will get too 
    // distorted, but this here isn't too noticeable.
    //vec2 mut = pow(abs(p.xy), vec2(4))*.125 + .875; // Etc.
    vec2 mut = p.xy*p.xy*.125 + .875;
    p.xy *= mut*vec2(1, 1.2);
    
    //p += sin(p*2. + cos(p.yzx*2.))*.1; // Adding bumps. Too much for this example.
    
    // Scaling Z... This gave me more trouble than I care to admit. Scale here, then
    // scale back when doing the repetition. Simple... now. :)
    p.z /= zScale;
    
    // Relative Z distances of the four tiles. The bit on the end belongs there, but
    // I can't remember why. Some kind of correction in order to get the get correct height
    // values for wall tiling... or something. I should write these things down. :D
    vec4 fPz = floor(vec4(0, .5, .25, .75) + p.z) - vec4(0, .5, .25, .75);
    

    // Angle and angular index.
    float a, ia;
    

    //// Hexagon 1.    
    // Standard polar mapping stuff.
    a = atan(p.y, p.x);
    ia = floor(a/TAU*aNum);
    rnd.x = hash21(vec2(ia, fPz.x));
    #ifdef RIGID_BLOCKS
    p.xy = rot2((ia + .5)*TAU/aNum)*p.xy;
    pC = vec3(p.xy, p.z);
    //pp = vec3(length(p.xy)*vec2(cos((ia + .5)*TAU/aNum), sin((ia + .5)*TAU/aNum)), p.z);
    #else
    p.xy = rot2(a)*p.xy;
    pC = vec3(p.xy, p.z); pC.y = convert(a, aNum);
    #endif
    // First entry when you perform: pp.x = mod(pp.x, rad) - rad/2.;
    pC.x -= tunRad - rnd.x*rndFactor + blockRad; // Base tunnel width.
    pC.z = (mod(pC.z, 1.) - .5)*zScale; // Repetition along the tunnel.
    
    sh.x = objectDetail(pC, wd, rnd.x, spike4.x); // The hexagon pylon object and spike.
    

    //// Hexagon 2.   
    rnd.y = hash21(vec2(ia + .5, fPz.y));
    #ifdef RIGID_BLOCKS    
    pC = vec3(p.xy, p.z + .5);
    #else
    pC = vec3(p.xy, p.z  + .5); pC.y = convert(a, aNum);
    #endif
    pC.x -= tunRad - rnd.y*rndFactor + blockRad; // Tunnel width.
    pC.z = (mod(pC.z, 1.) - .5)*zScale;
    
    sh.y = objectDetail(pC, wd, rnd.y, spike4.y);
    
    //p.xy = q.xy;
	//// Hexagon 3.  
    #ifdef RIGID_BLOCKS
    //p.xy = q.xy;
    p.xy = rot2(-(ia + .5)*TAU/aNum + 3.14159/aNum)*p.xy;
    #else
    p.xy = rot2(-a + 3.14159/aNum)*p.xy;
    #endif
    a = atan(p.y, p.x);
    ia = floor(a/TAU*aNum);
    
    rnd.z = hash21(vec2(ia, fPz.z));
    #ifdef RIGID_BLOCKS
    p.xy = rot2((ia + .5)*TAU/aNum)*p.xy;
    pC = vec3(p.xy, p.z + .25);
    #else
    p.xy = rot2(a)*p.xy;
    pC = vec3(p.xy, p.z + .25); pC.y = convert(a, aNum);
    #endif
    pC.x -= tunRad - rnd.z*rndFactor + blockRad; // Tunnel width.
    pC.z = (mod(pC.z, 1.) - .5)*zScale;
    sh.z = objectDetail(pC, wd, rnd.z, spike4.z);
   
  
	//// Hexagon 4. 
    rnd.w = hash21(vec2(ia + .5, fPz.w));
    #ifdef RIGID_BLOCKS
    pC = vec3(p.xy, p.z + .75);
    #else
    pC = vec3(p.xy, p.z + .75); pC.y = convert(a, aNum);
    #endif
    pC.x -= tunRad - rnd.w*rndFactor + blockRad; // Tunnel width.
    pC.z = (mod(pC.z, 1.) - .5)*zScale;
    sh.w = objectDetail(pC, wd, rnd.w, spike4.w);
    
    // Determining the minimum hexagon pylon distance, then returning it.
    vec2 hx2 = min(sh.xy, sh.zw);
    return min(hx2.x, hx2.y)*.85;
 
}

// Function 177
float sceneSDF(vec3 p) {
    float d = sphereSDF(p, 0.5);
    return d;
}

// Function 178
float map( in vec3 pos ,in vec3 rd,out vec2 uv)
{
    float time = mod(iTime,100.);
    float res = 1e10;
    vec3 gridFloor = floor(pos/gridSize);
    
    //if(gridFloor.z ==-3.)
    {
        
    vec3 gridNoise = hash(gridFloor.xz);
        
	vec3 primPos = (gridFloor*gridSize) + vec3(gridSize*0.5,0.,gridSize*0.5);
	primPos.y = 0.;
    

	//trans
	vec3 posLocal = (pos-primPos);
	//rot
    vec3 axis = gridNoise*2.-1.;
    axis. y = 0.;
	
	posLocal = rotate(posLocal, axis, sin(time+sin(pos.x))*0.4);
    posLocal = rotate(posLocal, vec3(0.,1.,0.), (gridNoise.x*2.-1.)*1.5 );
        
	//scale dist
    vec3 scale = vec3(gridNoise.xy*0.6+0.4,1.)*2.3;//max 2.5;
	//posLocal *= scale;

    vec2 uvP;
    float resP = sdBox(  posLocal, vec3(scale.xy*0.4,0.02) ,uvP );
    if(resP<res)
    {
        uv = uvP;
        vec4 color = texture(iChannel0,uv);
        
        if(length(color.rgb-vec3(0.05,0.61,0.15))>0.3)
			res = opU( res,  resP);
    }
    }
    
    /////////////////////
    vec3 gridFloorPos = gridFloor*gridSize;
	float maxstep = maxStep( pos , rd, gridFloorPos);
    res = min(maxstep,res);
    return res;
}

// Function 179
float map_neck(vec3 pos)
{
    #ifdef show_neck
    pos = rotateVec2(pos);
 
    pos+= vec3(0.018, -1.36, 0.03);
    vec3 pos5 = pos;
    pos5.y-= 0.335;
    pos.xz*=(1. + 0.35*pos.y);
    
    float c1 = sdCylinder(pos, vec2(0.155, 0.4));
    c1 = smin(sdCylinder(pos5, vec2(0.136, 0.053)), c1, 17.);
    float c2 = sdCylinder(pos, vec2(0.15, 0.42));
    c2 = smin(sdCylinder(pos5, vec2(0.136, 0.053)), c2, 17.);
    float df = max(c1, -c2);
 
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif   
    
    return df;
    #else
    return 10.;
    #endif
}

// Function 180
float DistanceField( vec3 pos )
{
	return DistanceField( pos, 10.0 );
}

// Function 181
Object map(vec3 p) {
    Object o = NewObject;
    

    o = omin(o, sdFloorA(p - vec3(0.,-0.14,0)), materials[0]);
    
    o = omin(o, sdWall(p - vec3(0.9,0.,0)), materials[0]);
    
    o = omin(o, -sdWall(p - vec3(-0.4,0.,0)), materials[0]);
    o = omin(o, sdWall(p - vec3(0.4,0.,0)), materials[0]);
    o = omin(o, sdBackWall(p - vec3(-0.0,0.0,4.1)), materials[0]);
    
    o = omax(o, -max(abs(p.x) - lineW, -p.y - 0.15), materials[1]); // hole in ground middle
    
    
    vec3 pSize = p;
    pSize.y -= 0.2;
    for (int i = 0;i < 4;i++) {
        pSize = abs(pSize);
        pSize.z -= 0.12;
    	pSize.yz *= rot(0.11);
    	pSize.yx *= rot(-0.5);
    }
    
    o = omax(o, -max(abs(pSize.y) - lineW, -100.), materials[4]); // hole in ground side

    pSize = p;
    
    for (int i = 0;i < 4;i++) {
        pSize = abs(pSize);
        pSize.y -= 0.2;
        pSize.yz *= rot(0.25*PI);
    }
    
    
    o = omax(o, -max(abs(pSize.y) - lineW, -100.), materials[4]); // hole in ground side 2
    
    // wall fixes
    o = omin(o, sdWall(p - vec3(0.41,0.,0)), materials[0]);
    o = omin(o, -sdWall(p + vec3(0.41,0.,0)), materials[0]);
    o = omin(o, sdFloorA(p - vec3(0.,-0.16,0)), materials[0]);
    o = omin(o, sdBackWall(p - vec3(-0.0,0.0,4.12)), materials[0]);
        
    
    
    o = omin(o,sdBallThingie(p - vec3(-0.0,-0.14,0.4), 0.05,  o));    
    
    

    
    vec3 pA = p - vec3(-0.2,-0.14,0.4);
    pA.z = pmod(pA.z + 0.5, ASIZE);
    pA.x = pmod(pA.x - ASIZE*0.126  , ASIZE*1.3);
    
    for (int i = 0; i < 3; i++){
        pA = abs(pA);
        pA.yz *= rot(0.125*PI);
        pA.z -= 0.45;
        pA.x -= 0.61;
    }
    Object oThingieA = sdThingieA(pA);
    o = omin(o,oThingieA); 
    
    o = omin(o,sdThingieB(p - vec3(0,0,0.4)));   // robothingies
    
    
    
    o.didHit = true;
    o.d *= 0.8;
    return o;
}

// Function 182
float remap01(float x, float _oldmin, float _oldmax)
{
 	return clamp((x-_oldmin)/(_oldmax-_oldmin), .0, 1.);
}

// Function 183
vec2 map1(vec3 pos)
{
    pos = rotateVec2(pos);

    vec2 obj;
    
    float ypos = getCylYPos();
    
    vec2 c1 = vec2(sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2 (cr, cl)), C1_OBJ);
    vec2 c2 = vec2(sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2 (cr, cl)), C2_OBJ);
    vec2 box = vec2(sdBox(pos - vec3(0., boxYPos, 0.), boxSize), BOX_OBJ);
    obj = opU(c1, c2);
    obj = opU(obj, box);
 
    //obj.x = max(obj.x, pos.z);

    return obj;
}

// Function 184
float map(vec3 p){
    
 
    p.xy -= path(p.z); // Wrap the passage around
    
    vec3 w = p; // Saving the position prior to mutation.
    
    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.
   
    
    float ground = p.y + 0.05 + dot(op, vec3(.222))*.13; // Ground plane, slightly perturbed.
 
    p += (op - .15)*.3; // Adding some triangular perturbation.
   
	p = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).
    
    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.51; // Spherize and add the canyon walls.
    
    return min(ground, canyon);

    
}

// Function 185
vec2 map(vec3 pos, bool hasBump)
{
    vec2 res;
    
    float hole = map_hole(pos, hasBump);
    
    #ifdef balls
    float ballss = map_balls(pos);
    res = opU(vec2(hole, HOLE_OBJ), vec2(ballss, BALL_OBJ));
    #else
    res = vec2(hole, HOLE_OBJ);
    #endif
    
    return res;
}

// Function 186
float sceneMap3D(vec3 pos) {
    float flr = FLOOR_SDF;
    float red_wall = RED_WALL_SDF;
    float green_wall = GREEN_WALL_SDF;
    float back_wall = BACK_WALL_SDF;
    float ceiling = CEILING_SDF;
    float tall_box = TALL_BOX_SDF;
    float small_box = SMALL_BOX_SDF;
    return min(back_wall, min(red_wall,
     min(green_wall, min(ceiling, min(flr, min(tall_box, small_box))))));
}

// Function 187
void sceneSetup( out vec3 ro, out vec3 ta, out float cr, out float fl,
                 out vec3 lig, out float tre, out float rtime,
                 in float time )
{
    if( time<10.0 )
    {
        rtime = time - 0.0;
        float an = 0.4-0.005*rtime;
        ta = vec3( an, 0.0-0.1, 0.0 );
        ro = ta + vec3( 1.0, 0.22+0.1, 0.0 );
        ta.y -= 0.05;
        fl = 2.5;
        cr = -0.05*sin(rtime*0.15);
        lig = normalize(vec3(-0.6,0.125,1.0));
        tre = 0.7;
    }
    else if( time<25.0 )
    {
        rtime = time - 10.0;
        float an = -0.23-0.003*rtime;
        ta = vec3( an, 0.0-0.1, 0.0 );
        ro = ta + vec3( 1.0, 0.22+0.1, 0.0 );
        ta.y -= 0.05;
        fl = 2.5;
        cr = -0.1*sin(rtime*0.1);
        lig = normalize(vec3(-0.6,0.125,1.0));
        tre = 0.0;
    }
    else if( time<35.0 )
    {
        rtime = time - 25.0;
        float an = -0.001*rtime+2.0;
        ro = 2.4*vec3( cos(an), 0.09, sin(an) );
        ta = vec3( 0.0, -0.3, 0.0 );
        fl = 3.5;
        cr = 0.0;
        lig = normalize(vec3(2.00,0.3,-0.26));        
        tre = 0.2;
    }
    else if( time<55.0 )
    {
        rtime = time - 35.0;
        float an = 0.01*rtime;
        ro = vec3( 3.0+cos(an), 0.22, 0.0+sin(an) );
        ta = vec3( 3.0, -0.05, 0.0 );
        ro.x -= 0.2;
        ta.x -= 0.2;
        ta.y += 0.1;
        ro.y += 0.1;
        ro.z -= 0.2;
        ta.z -= 0.2;
        fl = 6.0;
        cr = 0.0;
        lig = normalize(vec3(-0.7,0.125,-1.0));        
        tre = 0.1;
    }
    else if( time<65.0 )
    {
        rtime = time - 55.0;
    	float an = -0.002-0.0025*time;
    	ta = vec3( 1.5+an, -0.015,1.0 );
    	ro = ta + vec3( 1.0, 0.19, 0.0 );
    	fl = 4.0;
        cr = 0.02;
        lig = normalize(vec3(-0.4,0.15,0.8));
        tre = 0.35;
    }
    else
    {
    	rtime = time - 65.0;
        float an = -0.005*rtime;
        ro = 1.4*vec3( cos(an), 0.3, sin(an) );
        ta = vec3( 0.0, -0.2, ro.z );
        fl = 2.5;
        cr = 0.0;
        lig = normalize(vec3(1.0,0.1,-0.6));        
        tre = -1.0;
    }
}

// Function 188
float distf(vec3 p, inout float m)
{
	float d = 10000.0;
	m = 0.0;
	
	float grass1 = pBox(p+vec3(0,0,abs(cos(p.x)*cos(p.y))),vec3(12.2,12.2,1.2));
	grass1 = fIntersection(grass1,pRoundBox(p+vec3(0,0,1.5),vec3(11,11,0.5), 1.0));
	fUnionMat(d,m,grass1,2.0);
	
	float ground1 = pRoundBox(p+vec3(0,0,4.0),vec3(10.7,10.7,2.5),1.0);
	fUnionMat(d,m,ground1,3.0);
	
	vec2 blocks = pBlockBricks((mod(p/2.0,3.0)-0.5*3.0));
	float blockd = blocks.x;
	float blockm = blocks.y;
	
	const float blocksize = 2.95;
	float blocki = pBox(p-vec3(3,3,3),vec3(blocksize,blocksize,blocksize));
	blocki = fUnion(blocki, pBox(p-vec3(3,9,3),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,3,3),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(-9,3,9),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,-9,15),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,-9,9),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(-9,-9,3),vec3(blocksize,blocksize,blocksize)));
	
	blockd = fIntersection(blockd, blocki);
	
	fUnionMat(d,m,blockd,blockm);
	
	
	return d;
}

// Function 189
float sceneSDF(vec3 p) {
    vec3 brickSize = vec3(15.8, 9.6, 31.8);
    float brickBody = sdDifference(
        sdCube(p, brickSize),
        sdCube(p - vec3(0.0, -1.0, 0.0), brickSize - vec3(2.4, 0.0, 2.4))
        );
    float crossBeam = sdCube(p - vec3(0.0, 1.65-0.1, 0.0), vec3(13.8, 9.6-3.3, 0.8));
    float studs = sdUnion(
        sdUnion(
            sdUnion(
                sdStud(p, brickSize, 1.0, -3.0),
                sdStud(p, brickSize, 1.0, -1.0)
            ),
            sdUnion(
                sdStud(p, brickSize, 1.0, 1.0),
                sdStud(p, brickSize, 1.0, 3.0)
            )
        ),
        sdUnion(
            sdUnion(
                sdStud(p, brickSize, -1.0, -3.0),
                sdStud(p, brickSize, -1.0, -1.0)
            ),
            sdUnion(
                sdStud(p, brickSize, -1.0, 1.0),
                sdStud(p, brickSize, -1.0, 3.0)
            )
        )
    );
    float studHollows = sdUnion(
        sdUnion(
            sdUnion(
                sdStudHollow(p, brickSize, 1.0, -3.0),
                sdStudHollow(p, brickSize, 1.0, -1.0)
            ),
            sdUnion(
                sdStudHollow(p, brickSize, 1.0, 1.0),
                sdStudHollow(p, brickSize, 1.0, 3.0)
            )
        ),
        sdUnion(
            sdUnion(
                sdStudHollow(p, brickSize, -1.0, -3.0),
                sdStudHollow(p, brickSize, -1.0, -1.0)
            ),
            sdUnion(
                sdStudHollow(p, brickSize, -1.0, 1.0),
                sdStudHollow(p, brickSize, -1.0, 3.0)
            )
        )
    );
    float buttresses = sdUnion(
        sdUnion(
            sdUnion(
                sdUnion(
                    sdButtressX(p, brickSize, 1.0, -3.0),
                    sdButtressX(p, brickSize, 1.0, -1.0)
                ),
                sdUnion(
                    sdButtressX(p, brickSize, 1.0, 1.0),
                    sdButtressX(p, brickSize, 1.0, 3.0)
                )
            ),
            sdUnion(
                sdUnion(
                    sdButtressX(p, brickSize, -1.0, -3.0),
                    sdButtressX(p, brickSize, -1.0, -1.0)
                ),
                sdUnion(
                    sdButtressX(p, brickSize, -1.0, 1.0),
                    sdButtressX(p, brickSize, -1.0, 3.0)
                )
            )
        ),
        sdUnion(
            sdButtressZ(p, brickSize, 1.0),
            sdButtressZ(p, brickSize, -1.0)
        )
    );
    float supports = sdUnion(
        sdSupport(p, brickSize, 0.0),
        sdUnion(
            sdSupport(p, brickSize, -2.0),
            sdSupport(p, brickSize, 2.0)
        )
    );
    float supportHollows = sdUnion(
        sdSupportHollow(p, brickSize, 0.0),
        sdUnion(
            sdSupportHollow(p, brickSize, -2.0),
            sdSupportHollow(p, brickSize, 2.0)
        )
    );
    float brick = sdDifference(
        sdUnion(
            sdUnion(
                brickBody,
                crossBeam
            ),
            sdUnion(
                buttresses,
                supports
            )
        ),
        sdUnion(
            studHollows,
            supportHollows
        )
    );
    return sdUnion(brick, studs);
}

// Function 190
vec3 voronoiSphereMapping(vec3 n)
{
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
    float voroRatio = CELLS_DENSITY_DEFAULT;
	//if ( iMouse.z > 0. ) {voroRatio=iMouse.x/iResolution.x * CELLS_DENSITY_MAX;}
    return getVoronoi(voroRatio*uv);
}

// Function 191
void Map(vec2 uv, vec2 playerPos, inout vec3 col)
{
    //remap uv to local map uv
   uv.x = clamp(0.0, 1.0, 1.0 * uv.x - 0.7);
   uv.y = clamp(0.0, 1.0, 1.3 * uv.y - 0.2);
   if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0)
   {
     col= 0.3*col + 0.7*vec3(vec3(0.1,0.1,0.14));
     uv*=10.0;
     uv.x = 10.0 - uv.x;
     int cell = GetCell(uv);
     if(cell > 0)
     {
        col += vec3(0.4,0.0,0.0);
     }
     
     if(length(playerPos - uv)<0.25)
     {
        col = vec3(0.0,0.4,1.0);
     }
   } 
   

}

// Function 192
vec3 tonemapUncharted2(vec3 x, float exposure)
{
    vec3 whiteScale = vec3(1.0) / tonemapUncharted2Helper(vec3(W));
    vec3 color = tonemapUncharted2Helper(x * exposure * 12.0) / whiteScale;
    
	return pow(color, vec3(1.0 / 2.2));
}

// Function 193
vec3 sceneTransformFwd(vec3 p) {
    p = hyperTranslate(p, sceneWrap);
    p.xy = sceneRotate * p.xy;
    p = hyperTranslate(p, sceneCenter);
    return p;
}

// Function 194
float planetSDF( vec3 point ) {
    vec2 rot = point.xy + TRIG(1.,iTime*0.235);
    float n = 
        + 0.10 * noise( rot * 3. )
        + 0.03 * noise( rot * 9. )
        + 0.01 * noise( rot * 23. )
    ;
    return length(point) - 1.1 + 2.9 * n;
}

// Function 195
float scene(vec3 p)
{
    float d = 1e9;
    
    float fl=p.y+T+1.;
    
    // left beam
    d=min(d,sdBox(p+vec3(0,T,0),vec3(T,0,0)+1.));
    
    // vertical beam
	d=min(d,sdBox(p-vec3(T,0,0),vec3(0,T-2.,0)+1.));
    
    // the magic seam that moves over time so it's not in one place
    float plane = p.x+p.z-(T-2.)+fract(iTime)*(T*2.-6.);
    
    // back beam
    d=min(d, max(plane-1., sdBox(p+vec3(T,T,-T+1.),vec3(1.,1.,T))));
    
    // top beam
    d=min(d, max(-plane, sdBox(p-vec3(T,T,1.-T),vec3(1.,1.,T))));
    
    // intersect with a field of smaller boxes
    p=mod(p+vec3(1,1,1),2.)-1.;
    d = max(d,sdBox(p,vec3(.8)));
    
    d=min(d,fl);
    
    return d;
}

// Function 196
vec3 getDistRes() { return vec3(floor(pow(iResolution.x*iResolution.y,.33)-1.)); }

// Function 197
float dist( in vec3 p )
{
    vec3 f = fract(p);
    vec3 i = floor(p);
    // If the current voxel doesn't have a high enough
    // noise value we consider it empty.
    if(noise(i) < N_THRESH)
    {
        // Return the distance to the nearest wall of 
        // the current voxel, plus the distance past that
        // border to the cube on the other side.
        return -box(f-.5, vec3(.5+.5*(1.0-CUBE_SIZE.x)));
    }  	   
	else return box(f-.5, CUBE_SIZE*.5); // If this voxel is not empty, well...
}

// Function 198
float domainRemapping(float minInput, float maxInput, float minOutput, float maxOutput, float domain)
{
    //normalize domain (put it into the 0-1 range)
    float normalizedDomain = (domain - minInput) / (maxInput - minInput);
    
    //use lerp
    return minOutput * (1. - normalizedDomain) + maxOutput * normalizedDomain;
    
    //I found a new method today thay requires less calculations, very interesting!
    //return normalizedDomain * (maxOutput - minOutput) + minOutput;  
}

// Function 199
float sdf( vec3 pos, float t, out vec4 objPos )
{
    float d = ZFAR;
    
    float r = 1.;

    float stepR = 1.;
    
    vec3 c1 = vec3(.0,-0.5,0.);
    float d1 = stepR * length(pos-c1) - r;
    if( d1 < d )
    {
        objPos.xyz = c1;
        objPos.w = 1.;
        d = d1;
    }
    
    vec3 c2 = vec3(5.*cos(2.*t), sin(8.*t), 5.*sin(2.*t));
    float d2 = stepR * length(pos-c2) - r;
    if( d2 < d )
    {
        objPos.xyz = c2;
        objPos.w = 1.;
        d = d2;
    }

    vec3 c3 = vec3(0.,FLOORY,0.);
    vec3 n3 = vec3(0.,1.,0.);
    float d3 = abs(dot(pos-c3,n3));
    if( d3 < d )
    {
        objPos.xyz = c3;
        objPos.w = 5.;
        d = d3;
    }
    
    return d;
}

// Function 200
vec3 cosdistr(vec3 dir, float w)
{
    vec3 rand_dir = normalize(randn());
    vec3 norm_dir = normalize(rand_dir - dot(dir,rand_dir)*dir);
    float u = w*rand();
    return normalize(dir*sqrt(1. - u) + norm_dir*sqrt(u));
}

// Function 201
bool intersectScene(Ray R, float maxDist, inout Surfel surfel) {
    if (intersectSceneLoop(R, maxDist, surfel)) {
        const float eps = 0.03;
        
        float d = inf;
        scene(surfel.position, d, surfel.material);
        surfel.normal =
            normalize(Vector3(distanceEstimator(surfel.position + Vector3(eps, 0, 0)), 
                              distanceEstimator(surfel.position + Vector3(0, eps, 0)), 
                              distanceEstimator(surfel.position + Vector3(0, 0, eps))) - 
                              d);

        return true;
    } else {
        return false;
    }
}

// Function 202
float sdf_a(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));
    return t;
}

// Function 203
float segDist (in vec2 p, in vec2 a, in vec2 b) {
	p -= a;
	b -= a;
	return length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));
}

// Function 204
float map(vec3 p)
{
    p.x += sin(p.y*4.+time+sin(p.z))*0.15;
    float d = length(p)-1.;
    float st = sin(time*0.42)*.5+0.5; 
    const float frq = 10.;
    d += sin(p.x*frq + time*.3 + sin(p.z*frq+time*.5+sin(p.y*frq+time*.7)))*0.075*st;
    
    return d;
}

// Function 205
float sdfDifference( const float a, const float b)
{
    return max(a, -b);
}

// Function 206
vec2 Scene_GetDistance( vec3 vPos )
{
	vec2 vResult = vec2( MAX_DIST, 0.0 );

#if 0
    float fTunnelDist = 20.0 - length(vPos.xy);        
    if ( fTunnelDist < vResult.x )
    {
        vResult = vec2( fTunnelDist, atan(vPos.x, vPos.y) * 150.0 / (3.14 * 2.0) );
    }
	return vResult;
#else   
    float fFloorPlaneDist = 10.0 + vPos.y;
    if ( fFloorPlaneDist < vResult.x )
    {
        vResult = vec2( fFloorPlaneDist, vPos.x * 1.5 );
    }

    float fCeilPlaneDist = 18.6 - vPos.y;
    if ( fCeilPlaneDist < vResult.x )
    {
        vResult = vec2( fCeilPlaneDist, vPos.x * 1.5 );
    }
    
    float fTunnelDist = 20.0 - length(vPos.xy);        
    if ( fTunnelDist < vResult.x )
    {
        vResult = vec2( fTunnelDist, atan(vPos.x, vPos.y) * 150.0 / (3.14 * 2.0) );
    }

    vec3 vRailDomain = vPos;
    vRailDomain.x = abs( vRailDomain.x );
    
    float fRailDist = length(vRailDomain.xy - vec2(10.0, -9.0)) - 1.0;
    if ( fRailDist < vResult.x )
    {
        vResult = vec2( fRailDist, 0.0 );
    }

    float fSideRailDist = length(vRailDomain.xy - vec2(19.0, -1.5)) - 2.0;
    if ( fSideRailDist < vResult.x )
    {
        vResult = vec2( fSideRailDist, 0.0 );
    }
#endif    
        
    return vResult;
}

// Function 207
vec2 sceneWithGlassMaterials(vec3 point){
    vec3 kAdjustPt = point;
    kAdjustPt = translate(kAdjustPt, vec3(-0.25,0,0.05));
    vec2 kodos = kodosGlassSDF(kAdjustPt/CHARACTERSCALE);
    kodos.x = kodos.x * CHARACTERSCALE;
    return kodos;
}

// Function 208
float dist(vec3 pos)
{
    return mdist(pos).x;
}

// Function 209
float ConeTraceDist(vec3 beam_origin, vec3 beam_dir, float beam_radius, float iTime)
{
    float dist = 0.;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        float cap_radius = dist * beam_radius;
        
        vec3 p = beam_origin + beam_dir * dist;
        
        float nearest = GetSceneDist(p, iTime);

        if (nearest <= cap_radius)
        	break;

        dist += nearest - cap_radius;

        if (dist > MAX_DIST)
            break;
    }
    
    return dist;
}

// Function 210
float map(vec3 p, inout bool insideSphere, float time) {
    vec3 transformedPos = p;
    p = reverseTransform(p, time);

    float sphereDist = length(p-spherePos) - sphereRad;
    if (sphereDist < epsilon) {
        float bubblesDist = mapBubbles(p, transformedPos, time);
        if (bubblesDist < epsilon)  return insideSphere ? bubblesDist : sphereDist;
        else {
            insideSphere = true;
            return bubblesDist;
        }
    } else {
        insideSphere = false;
    }
    return sphereDist;
}

// Function 211
Result scene (in vec3 p)
{
    // floor
	float offset = -.25;
    float ground = p.y + offset;

    // repeat space and cause wave (phase)
	p.z += iTime;
	vec3 boxCenter = p;
	boxCenter.y -= .4;
	vec2 index = opRepeat2 (boxCenter.xz, vec2 (.205));
    float phase = iTime + sin(.5*index.x) + cos(.5*index.y);
    phase = mix (.0, phase, .5 + .5*sin (.5*iTime));

    // tile geometry
    boxCenter.y += .05*sin(2.*phase);
	boxCenter.yz *= r2d (20.*sin (phase));
	float box = udRoundBox (boxCenter, vec3 (.1, .01, .1), .005);
    float d = box;

    // assign material ids
    Result res = Result (.0, 0);
	res.d = min (d, ground);
    res.id = (res.d == ground) ? 1 : 2;
    return res;
}

// Function 212
float map(vec3 pos, int processedMaterial)
{
    float rDist = 0.; //0. if first operation is a SUB(), 1e10 otherwise
    maxGISize = 0.;
    rayObj = 0;
    
    vec4 worldSpace = vec4(pos,1);
    
    
    beginMaterial(0)
    SUB(box(worldSpace,vec3(0,0,0),vec3(10,2.5,10)));
    
    ADD(cylinderY(worldSpace,vec3(-6,0,-2.),0.1,3.));
    ADD(cylinderY(worldSpace,vec3(5,0,-2.),0.1,3.));
    endMaterial()
    
    vec4 cubeSpace = beginObj(o_myCube,worldSpace);
    //ADD(box(cubeSpace,vec3(0,0,0),vec3(1)));
    
    //cubeSpace.xz = abs(cubeSpace.xz);
    vec4 cubeChildrenSpace = cubeSpace;
    
    for (int i=0; i<4; i++)
    {
    	beginMaterial(i)
        ADD(sphere(cubeChildrenSpace,vec3(0,0,0),1.));
    	endMaterial()
        cubeChildrenSpace = abs(cubeChildrenSpace);
        cubeChildrenSpace = beginObj(o_myCubeChildren,cubeChildrenSpace);
    }
    
	vec4 blackHoleSpace = beginObj(o_blackHole,worldSpace);
    beginMaterial(8)
    ADD(sphere(blackHoleSpace,vec3(0,0,0),.5));
    endMaterial()
    
        
    vec4 tunnelSpace = beginObj(o_tunnel,worldSpace);
    beginMaterial(3)
    ADD(box(tunnelSpace,vec3(0,.5,0),vec3(.2,.1,1.5)));
    ADD(box(tunnelSpace,vec3(0,-.5,0),vec3(.2,.1,1.5)));
    endMaterial()
    
    vec4 tunnelDoorSpace = beginObj(o_tunnel_door,worldSpace);
    beginMaterial(4)
    ADD(box(tunnelDoorSpace,vec3(0,0,1.4),vec3(.2,.4,0.1)));
    ADD(box(tunnelDoorSpace,vec3(0,0,-1.4),vec3(.2,.4,0.1)));
    endMaterial()
        
    vec4 trainSpace = beginObj(o_train,worldSpace);
    beginMaterial(7)
    ADD(box(trainSpace,vec3(0,0,-.8),vec3(.1,.1,.18)));
    ADD(box(trainSpace,vec3(0,0,-.4),vec3(.1,.1,.18)));
    ADD(box(trainSpace,vec3(0,0,0),vec3(.1,.1,.18)));
    ADD(box(trainSpace,vec3(0,0,.4),vec3(.1,.1,.18)));
    ADD(box(trainSpace,vec3(0,0,.68),vec3(.1,.1,.06)));
    ADD(cylinderZ(trainSpace,vec3(0,.04,.8),.07,.18));
    endObj()
    endMaterial()
        
    float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)));
    float tmpGauss = length(blackHoleSpace.xz)-1.5;
    rDist = min(rDist,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))));
    temp *= rDist*pow(2.7,-(tmpGauss*tmpGauss)/(0.1));
    
    blackHoleAccretionDisk += (1.-blackHoleAccretionDisk)*temp * AccretionDisk;
        
    for(int L=0; L<3; L++)
    {
    	ADD(sphere(worldSpace,o_lights[L].pos,0.001));
        vec3 relPos = o_lights[L].pos-pos;
        o_lights[L].haloResult += rDist*(0.02/(dot(relPos,relPos)+0.01));
    }
        
    
        
    return rDist;
}

// Function 213
float remapTo01Clamped(float value, float start, float end)
{
	return clamp((value - start) / (end - start), 0.0, 1.0);
}

// Function 214
Hit mandelbulbSDF(vec3 p)
{
    float power = 8.;
    vec3 z = p;
    float dr = 1.;
    float r;
    vec3 c1 = vec3(.5, 1., 1.);
    vec3 c2 = vec3(0., 1., 0.) * .02;
    
    for (int i = 0; i < 15; i++)
    {
        r = length(z);
        if (r > 2.)
        {
            break;
        }
        float theta = acos(z.z / r) * power + iTime;
        float phi = atan(z.y/z.x) * power + iTime;
        float zr = pow(r, power);
        dr = pow(r, power - 1.) * power * dr + 1.;
        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
        z += p;
        c2 += c2;
    }
    return Hit(0.5 * log(r) * r / dr, c1 - c2);
}

// Function 215
vec4 tonemappingLUT(vec2 uv)
{
    vec3 ld = vec3(0.002);
    float linReference = 0.18;
    float logReference = 444.;
    float logGamma = 0.45;
    vec4 outColor = texture(iChannel0, uv);
    outColor.rgb = (log(0.4*outColor.rgb/linReference)/ld*logGamma + logReference)/1023.;
    outColor.rgb = clamp(outColor.rgb, 0., 1.);
    float FilmLutWidth = 256.;
    float Padding = .5/FilmLutWidth;
    outColor.r = texture(iChannel0, vec2( mix(Padding,1.-Padding,outColor.r), .5)).r;
    outColor.g = texture(iChannel0, vec2( mix(Padding,1.-Padding,outColor.g), .5)).r;
    outColor.b = texture(iChannel0, vec2( mix(Padding,1.-Padding,outColor.b), .5)).r;
    return outColor;
}

// Function 216
float sceneSDF(vec3 samplePoint) {
	return opDisplace(samplePoint);
}

// Function 217
float map(float value, float fromStart, float fromEnd, float toStart, float toEnd) {
	return toStart + (toEnd - toStart) * (value - fromStart) / (fromEnd - fromStart);   
}

// Function 218
float DebugSDF(float d)
{
    float aa = 0.005;
    float pattern1 = DebugSDFPattern(d, aa, aa);
    float pattern2 = DebugSDFPattern(d*2.0, aa*0.5, aa*2.0);
    float pattern10 = DebugSDFPattern(d*10.0, -aa*10.0, aa*20.0);
    float pattern50 = DebugSDFPattern(d*50.0, -aa*50.0, aa*100.0);
    return pattern1*pattern2*pattern10*pattern50;
}

// Function 219
float origin_distance(in vec4 q){
    //vec4 x  = qdiv(q-qj,c2q(c1)-qmul(q,qj));
    vec4 x = qmul(qinv(qmul(q,qj)-c2q(c1)),qj-q);
    return length(x);
}

// Function 220
float Tonemap_UC2( float x )
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;
}

// Function 221
float SDF_particle_wlink(vec3 p0, vec3 p, vec3 p1)
{
    particle point = get(fakech0, p0);
    float pde = length(point.pos.xyz - p) - point.vel.w;
    #ifdef LINKS
        if(length(point.pos.xyz - p1) < 3.)
        {
             pde = min(pde, sdCapsule(p, point.pos.xyz, p1, sphere_rad*0.2));
        }
    #endif
    return pde;
}

// Function 222
float sdScene(vec3 p)
{
    mat = matBlack;
    float d = 1e9;
    
    //d = min(d,sdSphere(p,T));
    
    float top = sdRoundedCylinder(p-vec3(0,10.7,0), 0.3*T, 0.1*T, 0.35*T);
    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,12.5,0), 0.25*T, 0.05*T, 0.15*T),0.2);
    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,15,0), 0.08*T, 0.05*T, 0.6*T),0.2);
    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.2,0), 0.1*T, 0.05*T, 0.25*T),0.2);
    top = fOpUnionRound(top,sdRoundedCylinder(p-vec3(0,16.7,0), 0.23*T, 0.15*T, 0.01),0.2);
    top = fOpUnionRound(top,sdRoundedCylinder(p.xzy-vec3(0,2.5,17.-p.z*p.z*0.03), 0.06*T, 0.05*T, 0.5*T),0.2);    
    
    float glass = min( 
    max(
    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),
    -sdSphere(p+vec3(0,6.7*T,0),6.0*T)),
    max(
    sdSphere(p*vec3(1.0,3.6/T,1.0)-vec3(0,0.75*3.6,0),1.7*T),
    2.0-p.y)
    );
    
    float tube = sdCylinder(p+vec3(0.,0.,sin(p.y/4.)-0.9), 0.15*T);
    //if (max(tube,glass) < d) {mat = matPipe;}  

    top = max(top,-glass);   
    glass = fOpUnionRound(glass,top,0.2);
    top = max(top,-glass);
    glass = max(glass,-tube);
    
    if (top < d) {mat = matPlastic;}
    d=min(d,top);
    
    if (glass < d) {
    /*if (abs(p.y)<2.7) mat = matPlastic;
    else mat = matLiquid;*/
        if (tube > glass) {
            mat = matLiquid;
        } else {
        if (p.y > 8.) {
            mat = matPlastic;
        } else {
            mat = matPipe;
        }
        }
    }
    d = min(d, glass);
    //vec3 q = opCheapBend(p);

    //d = min(d,max(tube,glass));

    /*float top = min(
    sdRoundedCylinder(p, 0.85*T, 0.2*T, 0.75*T),
    );*/
    //mat = matDiffuse;
    float fl= fPlane(p,vec3(0,1,0),4.);
       if (fl < d) {mat = matDiffuse;}
    d=min(d,fl);
    
    return inv*d;
}

// Function 223
vec3 envMap(vec3 p){
    
    p *= 5.;
    p.x += iTime/2.;
    
    float n3D2 = n3D(p*2.);
   
    // A bit of fBm.
    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;
    c = smoothstep(.4, 1., c); // Putting in some dark space.
    
    
    //p = pow(min(vec3(1.4, 1, 1)*c, 1.), vec3(1, 3, 16)); // Fire.
    p = vec3(c, c*c, c*c*c*c); // Orange tinge.
   
    p = mix(p, p.zyx, n3D2); // Mixing the color around.
    
    return p*p;

}

// Function 224
Hit map(in vec3 p){
    vec3 bp1 = p + vec3(0, 0, 0);
    bp1.xz *= Rot(iTime);
    bp1.xy *= Rot(iTime);
    
    vec3 cp = vec3(p);
    cp.yz *= Rot(90.);
    
    vec3 lp = p + vec3(.84, 0, 4);
    
    float plane0 = Plane(opRep(p, vec3(0,0,5.)), -1.);
    float building0 = leftBuilding(opRep(p + vec3(3, 0., 2.), vec3(0, 0, 4.)));
    float building1 = rightBuilding(opRep(p + vec3(-3., 0., 1.), vec3(0, 0, 6.)));
    float building2 = leftBuilding(opRep(p + vec3(2.9, 0., 0.), vec3(0, 0, 12.)));
    //float building3 = leftBuilding(p + vec3(3, 0., 4.5));
	//float building4 = rightBuilding(opRep((p + vec3(-3., 0., 0.)), vec3(0, 0, 4.)));
	//float building5 = rightBuilding(p + vec3(-3., 0., -3.));
    float lamp0 = lamp(opRep(lp + vec3(-2., 0, 0), vec3(0, 0, 12.)));
    float lampLight0 = lampLight(opRep(lp, vec3(0,0,12.)));
    float lamp1 = lamp(opRep(lp, vec3(0,0,12.)));
    float lampLight1 = lampLight(opRep(lp, vec3(0,0,12.)));
    float sidewalk0 = sidewalk(opRep(p + vec3(3., 1, 1), vec3(0,0,4.)));
    float sidewalk1 = sidewalk(opRep(p + vec3(-3.5, 1, 1), vec3(0,0,4.))); 
    float sidewalks = min(sidewalk0, sidewalk1);
    
    
    //float greenBuildings = min(building0, building1);
    //float redBuildings = min(building2, building3);
    //float blueBuildings = min(building4, building5);
    
    float shape0 = min(plane0, building0);
    float shape1 = min(shape0, building1);
    float shape2 = min(shape1, lamp1);
    float shape9 = min(shape2, lampLight1);
    float shape7 = min(shape9, sidewalks);
    float shape10 = min(shape7, building2);
    //float shape11 = min(shape10, building4);
    
    float result = shape10;
    Hit hit;
    hit.d = result;
    
    return hit;
}

// Function 225
float euclidean_line_dist(vec2 p, vec2 a, vec2 b){
    vec2 n = vec2(-(b-a).y, (b-a).x);
    return dot(n,p-a);
}

// Function 226
vec1 nmaps(vec1 x){ return x*2.-1.; }

// Function 227
vec3 BSDF_Oren_Nayar_Eval_Reflect(OrenNayarBsdf bsdf, vec3 vDir, vec3 wi, float pdf){
	if(dot(bsdf.nDir, wi) > 0.) {
		pdf = 0.5 * M_1_PI_F;
		return BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);
	}
	else {
		pdf = 0.0f;
		return vec3(0.);
	}
}

// Function 228
void BarrelDistortion( inout vec3 ray, float degree )
{
	ray.z /= degree;
	ray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye
	ray.z = degree*sqrt(ray.z);
}

// Function 229
vec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )
{
    //if(v1.x < v2.x) return v1; else return v2;
    return mix(v1, v2, step(v2.x, v1.x));
}

// Function 230
vec3 colormapCBY(float k, float krange) {
    vec3 c0 = vec3( 66.,245.,242.)/ 255.0; // color k < 0 cayen
    vec3 c2 = vec3(245.,242., 66.)/ 255.0; // color k > 0 yellow
    vec3 col = (k<0.)? c0:c2; col *= abs(atan(krange*k)/(0.5*3.14));
    return col;
}

// Function 231
void sceneCredits(vec2 uv, vec2 screenUv, out vec3 params)
{
	params = vec3(
		clamp(sin(uv.x*16. - 12.*uv.y - 2.*iBeat*sign(uv.y))*uv.y+.3,0.,1.),
		52,53
	);

	params.x = sin(mlength(uv)*15.+iBeat*2.*sign(uv.x*uv.y))*.5+.5;

	float cw = -cos((mod(iBeat-32.,64.)/32.)*PI);
	cw = min(cw * 3., 1.);
    
    // removed this because I can't put the credits texture on shadertoy
	//if(texture2D(texCreds,screenUv).r < .5 && hash2(gl_FragCoord.xy) < cw)
	//{
	//	params=vec3(0,39,39);
	//}
}

// Function 232
float map(vec3 p){
    
    // Wrap the scene around the path. This mutates the geometry,
    // but it's easier to implement. By the way, it's possible to
    // snap the geometry around the path, and I've done that in
    // other examples.
    p.xy -= path(p.z);
    
    // Twist the geometry along Z. It's cheap and visually effective.
    // Demosceners having been doing this for as long as I can remember.
    p.xy *= rot2(getTwist(p.z));

    
    // Turning one plane into two. It's an old trick.
    p.y = abs(p.y) - 1.25;
  
    // There are gaps between the pylons, so a floor needs to go in
    // to stop light from getting though.
    float fl = -p.y + .01;
    
    #ifdef PTH_INDPNT_GRD
    // Keep the blocks independent of the camera movement, but still 
    // twisting with warped space.
    p.xy += path(p.z);
    #endif
    
    // The extruded blocks.
    vec4 d4 = blocks(p);
    gID = d4.yzw; // Individual block ID.
    
    // Only alowing certain blocks to glow. We're including some 
    // animation in there as well.
    float rnd = hash21(gID.xy);
    //
    // Standard blinking lights animation.
    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);
    //gGlow.w = rnd>.05? 0. : 1.; // Static version.
 
 
    // Overall object ID.
    objID = fl<d4.x? 1. : 0.;
    
    // Combining the floor with the extruded blocks.
    return min(fl, d4.x);
 
}

// Function 233
float map( vec3 p )
{
    p.x *= 0.8;
    p *= 2.6;
    p.xyz += 1.000*sin(  2.0*p.yzx );
    //p.xyz -= 0.500*sin(  4.0*p.yzx );
    float d = length( p.xyz ) - 1.5;
	return d * 0.15;
}

// Function 234
vec2 linedist(vec2 p, vec2 a, vec2 b) {
  vec2 pa = p-a;
  float k = dot(p-a,b-a)/dot(b-a,b-a);
  float s = sign(dot(vec2(-pa.y,pa.x),b-a));
  float d = distance(p, mix(a,b,clamp(k,0.,1.)));
  return vec2(d,s);
}

// Function 235
vec2 reverse_mapping(vec2 Z,vec3 R, int seed){
    
    int p = int(R.x);
    int q = int(R.y);
    
    int x=int(Z.x);
    int y=int(Z.y);
    
    for(int i = 0; i < mapping_iters; i++){
        x = Zmod(x - IHash(y^seed)%p,p);
        y = Zmod(y - IHash(x^seed)%q,q);
    }
        
    return vec2(x,y)+.5;
}

// Function 236
vec3 lightmap(vec2 light) {
    light = 15. - light;
    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   
}

// Function 237
float pointRectDist(vec2 p, vec2 rectTL, vec2 rectBR)
{
  float dx = max(max(rectTL.x - p.x, 0.), p.x - rectBR.x);
  float dy = max(max(rectTL.y - p.y, 0.), p.y - rectBR.y);
  return max(dx, dy);
}

// Function 238
vec3 ShowScene (vec3 ro, vec3 rd)
{
  float eps = 0.01;
  vec4 col4;
  vec3 objCol, col, vn;
  float dstHit, dstGrnd, dstObj, dstPropel, f;
  int idObjT;
  vec3 roo = ro;
  dstHit = dstFar;
  dstGrnd = GrndRay (ro, rd);
  wSpan = 12.;
  engPos = vec3 (0.35 * wSpan, -0.2, -1.5);
  idObj = 0;
  dstObj = ObjRay (ro, rd);
  idObjT = idObj;
  dstPropel = TransObjRay (ro, rd);
  if (dstObj < dstPropel) dstPropel = dstFar;
  float refFac = 1.;
  if (dstGrnd < dstObj && ro.y + dstGrnd * rd.y < 0.) {
    float dw = - ro.y / rd.y;
    ro += dw * rd;
    rd = reflect (rd, WaterNf (ro, dw));
    ro += eps * rd;
    eps *= 1.01;
    dstGrnd = GrndRay (ro, rd);
    idObj = 0;
    dstObj = ObjRay (ro, rd);
    idObjT = idObj;
    refFac *= 0.6;
  }
  bool isGrnd = false;
  if (dstObj < dstGrnd) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    idObj = idObjT;
    objCol = ObjCol (ro, vn);
    if (idObj == 10) objCol = vec3 (0.2) + 0.5 * SkyCol (ro, reflect (rd, vn));
    float dif = max (dot (vn, sunDir), 0.);
    col = sunCol * objCol * (0.2 * (1. +
       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +
       max (0., dif) * ObjSShadow (ro, sunDir) *
       (dif + 0.5 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));
    dstHit = dstObj;
  } else {
    vec3 rp = ro + dstGrnd * rd;
    if (refFac < 1.) dstHit = length (rp - roo);
    else dstHit = dstGrnd;
    if (dstHit < dstFar) {
      ro = rp;
      isGrnd = true;
    } else {
      col = refFac * SkyCol (ro, rd);
    }
  }
  if (isGrnd) {
    vn = GrndNf (ro, dstHit);
    col4 = GrndCol (ro, vn);
    col = col4.xyz * refFac;
    float dif = max (dot (vn, sunDir), 0.);
    col *= sunCol * (0.2 * (1. +
       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +
       max (0., dif) * GrndSShadow (ro, sunDir) *
       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));
  }
  if (dstPropel < dstFar) col = 0.7 * col + 0.1 -
     0.04 * SmoothBump (1.5, 1.7, 0.02, length (qHitTransObj.xy));
  if (dstHit < dstFar) {
    f = dstHit / dstFar;
    col = mix (col, refFac * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));
  }
  col = sqrt (clamp (col, 0., 1.));
  return clamp (col, 0., 1.);
}

// Function 239
vec2 BrickSDFY(vec3 p)
{
#if 0	
	//bricks	
	vec3 r = p;
	r.x = Rep(r.x-brick_w,6.0*brick_w);
	vec2 d = BoxY(r,vec3(brick_w,1.,brick_w*3.));
	
	d = UY(d,BoxY(p,vec3(brick_w,5.,brick_w*3.)));
	d = SY(d,BoxY(p-vec3(0.,2.,0.),vec3(brick_w*2.,1.,brick_w*1.)));
#endif
	
#if 1	
	float h = 13.;
		
	p.x += brick_w;
	p.x = abs(p.x);
	
				//bastion		column	main	tower
	vec4 px = p.x - vec4(15.0, 	8.,		20., 	22.)*brick_w;
	vec4 py = vec4(p.y);// + vec4(0., 	0.,		0., 	0.);
	vec4 pz = p.z + vec4(0.0, 	1.,		28., 	21.)*brick_w;
	vec4 bx = 		vec4(5.,	2.,		8.,		6.)*brick_w;
	vec4 by = 		vec4(h,		19.,	h,		25.);
	vec4 bz = 		vec4(5.,	2.,		27.,	6.)*brick_w;	
		
	vec4 daY;
	vec4 da = Box4Y(px,py,pz,bx,by,bz,daY);
	
		px = p.x - vec4(15.0, 	20.,	17., 	22.)*brick_w;
	//	py = vec3(p.y);// + vec4(0., 	0.,		0., 	0.);
		pz = p.z + vec4(1.0, 	21.,	26., 	21.)*brick_w;
		bx = 		vec4(3.,	6.,		9.,		4.)*brick_w;
		by = 		vec4(h+2.,	13.,	h+2.,	11.);
		bz = 		vec4(4.,	2.,		23.,	7.)*brick_w;	
		
	vec4 dbY;
	vec4 db = Box4Y(px,py,pz,bx,by,bz,dbY);

	vec2 d = U4Y(da, daY);
	
	d = SY(d,vec2(db.x,dbY.x));
	d = SY(d,vec2(db.z,dbY.z));
	d = SY(d,vec2(db.w,dbY.w));

					  
	//bast+main - bast-main + tower - tower ? 
	d = SY( UY(vec2(da.x,daY.x),vec2(da.z,daY.z)), UY(vec2(db.x,dbY.x),vec2(db.z,dbY.z)) );
	d = UY(d, vec2(da.y,daY.y) );
			
	vec3 q;
	q.x = Rep(p.x+0.*brick_w,10.*brick_w);
	q.y = Rep(p.y-1.,8.);
	q.z = Rep(p.z-1.*brick_w,6.*brick_w);
	
		//front windows&crenels		side crenels 
	px = vec4(q.x,p.xxx) -  	vec4(0.0, 	23.,	22., 	22.)*brick_w;
	py = vec4(q.yy,p.yy) -  	vec4(0., 	0.,		18., 	18.);
	pz = vec4(p.z,q.z,p.zz) + 	vec4(1.0, 	2.,		21., 	21.)*brick_w;
	bx = 						vec4(1.,	7.,		7.,		4.)*brick_w;
	by = 						vec4(2.,	2.,		3.,		5.);
	bz = 						vec4(8.,	1.,		2.,		7.)*brick_w;	
	
	vec4 holesY;
	vec4 holes = Box4Y( px, py, pz, bx, by, bz, holesY );
		
	d = SY(d,vec2(holes.x,holesY.x));
	
	d = SY(d,vec2(holes.y,holesY.y));

	//add towers now to not cut holes in them!
	d = UY(d, SY(vec2(da.w,daY.w),vec2(db.w,dbY.w)));	

	d = SY( d, vec2(db.y,dbY.y) );
#ifdef MOAR_CSG	
	d = SY( d, vec2(holes.w,holesY.w) );
	d = SY( d, vec2(holes.z,holesY.z) );
#endif	
#endif	
	
	return d;
}

// Function 240
float distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)
{
    float w=w_mm*.001;
    float h=w*h_perc/100.;
    float d=10000.,d2;
    float rrim=rimD_inch*.5*.0254;
    d2=distTire(p, rrim+h, w, h, flatness );
    d=min(d,d2);
    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001*2.5;
    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );
    d=min(d,d2);
    return d;
}

// Function 241
float dist_to_line(vec2 pt1, vec2 pt2, vec2 testPt)
{
  vec2 lineDir = pt2 - pt1;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = pt1 - testPt;
  return abs(dot(normalize(perpDir), dirToPt1));
}

// Function 242
float dist(vec4 p, vec4 q) {
  // Make sure we stay in acos domain
  return acos(clamp(dot(p,q),-1.0,1.0));
}

// Function 243
MapHeight Map_GetAltitude( vec3 pos, int waterOctaves, bool detail )
{
    MapHeight mapHeight = Map_GetHeight( pos.xz, waterOctaves, detail );
    return MapHeight( pos.y - mapHeight.height, mapHeight.objectId );    
}

// Function 244
float map(vec3 p)
{
    p.z += .2;
    p += distort(p*distort(p))*.1;
    #ifdef audio
    trap = dot(sin(p), 1.-abs(p-PSD))*1.2;
    #else
    trap = dot(sin(p), 1.-abs(p))*1.2;
    #endif
    float d = -sdTorus(p, vec2(1., .7)) + distort(p)*.05;
    
    #ifdef rings
    p.y -= .2;
    for(int i = 0; i < 3; i++)
    {
        p.y += float(i)*.1;
        
    	d = min(d, sdTorus(p, vec2(.75, .01))-distort(p*float(i))*.01);
    }
    #endif
    
    return d;
}

// Function 245
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, colR;
  float dstObj;
  int idObjP;
  bool doRefl;
  rIn = 0.3;
  rBase = 2.8;
  rLoop = 6.;
  tCyc = 8.;
  armP = floor (mod (tCur / tCyc, nArm / 2.));
  sLoopV[0] = 1./3. + 100. * pow (1. - SmoothBump (0.25, 0.75, 0.22, mod (tCur / tCyc, 1.)), 2.);
  sLoopV[1] = 1./3. + 100.;
  for (int k = 0; k < 2; k ++) {
    aLoopV[k] = 0.25 * pi / sLoopV[k];
    arcLimV[k] = sin (aLoopV[k] + vec2 (0., 0.5 * pi));
  }
  szVeg = SmoothBump (0.25, 0.75, 0.2, mod (tCur / 10., 1.));
  HexVorInit ();
  doRefl = false;
  rBilGrnd = 25.;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    idObjP = idObj;
    ro += dstObj * rd;
    col4 = ObjCol (ro, rd, dstObj);
    if (col4.a >= 0. && idObjP != idVeg && idObjP != idGrnd) doRefl = true;
    col = col4.rgb;
  } else {
    col = SkyCol (ro, rd);
  }
  if (doRefl) {
    rd = reflect (rd, ObjNf (ro));
    ro += 0.01 * rd;
    rBilGrnd = 5.;
    dstObj = ObjRay (ro, rd);
    if (dstObj < dstFar) {
      ro += dstObj * rd;
      colR = ObjCol (ro, rd, dstObj).rgb;
    } else {
      colR = SkyCol (ro, rd);
    }
    col = mix (col, 0.9 * colR, 0.6);
  }
  return pow (clamp (col, 0., 1.), vec3 (0.8));
}

// Function 246
Result map (vec3 ro, vec3 rd) {
	// Test ray intersection with all objects - store closest result
	Result res = hitTest(ro, rd, sun);
	res = nearest(res, hitTest(ro, rd, planet));
	res = nearest(res, hitTest(ro, rd, moon1));
	res = nearest(res, hitTest(ro, rd, moon2));
	res = nearest(res, hitTest(ro, rd, moon3));
	// Store the hit position in world space
	res.position = ro + rd*res.depth;
	// Store the normal at the hit position
	res.normal = normalize(res.position - res.celestial.origin);
	return res;
}

// Function 247
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
#ifdef CUBEMAP_RENDER
    vec4 color = vec4(0.0);
    rayOri += vec3(10.0*cos(iTime/5.0)+50.0, 10.0, 10.0*sin(iTime/5.0));
    //Could probably do some better per-pixel noise for the cubemap.
	mainCommon(SAMPLER, iChannel1, iFrame, color, fragCoord, rayOri, rayDir);
#ifdef ACCUMULATE
    fragColor = mix(texture(iChannel3, rayDir), color, freshness);
#else
    fragColor = color;
#endif
#endif
}

// Function 248
float mapBlocks(vec3 p, out int obj) {
	float t1 = box(rotateY(p + vec3(-186, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5));
	float t2 = box(rotateY(p + vec3(-368.5, -165, -351.5), -0.30072115), vec3(87.02012, 165, 83.6675));
    obj = OBJ_SHORTBLOCK;
	if (t2 < t1) 
    {
        obj = OBJ_TALLBLOCK;
        t1 = t2;
    }
	return t1;
}

// Function 249
float remap01(float a, float b, float t) { return (t-a)/(b-a); }

// Function 250
vec3 sampleReflectionMap(vec3 sp, float lodBias){    
    vec3 color = SRGBtoLINEAR(textureLod(reflectTex, sp, lodBias).rgb);
    #if defined (HDR_FOR_POORS)
    	color *= 1.0 + 2.0*smoothstep(0.7, 1.0, dot(LUMA, color)); //HDR for poors
   	#endif
    return color;
}

// Function 251
float GetDist(vec3 p) {
    float pd = p.y;
    
    vec3 bp1 = p-vec3(5, 1.5, 0.0);
    vec3 bp2 = p-vec3(4, 1.5, 0.0);
    vec3 bp3 = p-vec3(0, 1.5, 0.0);
    vec3 bp4 = p-vec3(-4.5, 1.5, 0.0);
    bp1.yz *= rot(iTime * pi * 0.5);
    bp2.yz *= rot((iTime * pi * 0.5) + (pi * 0.5));
    bp3.xz *= rot((-iTime * pi * 0.125));
    
    float bd1 = sdTorus(bp1, vec2(1, 0.5));
    float bd2 = sdTorus(bp2, vec2(1, 0.5));
    float bd3 = dBox(bp3, vec3(1.0, 0.5, 1.0));
    float bd4 = sdCylinder(bp4, vec3(1.5, sin(iTime*3.141*0.25), 2.0), vec3(0.5, cos(iTime*3.141*0.25), -2.0), 0.5);
    float d = min(bd1, bd2);
    d = min(d, bd3);
    d = min(d, bd4);
    d = min(d, pd);
    
    return d;
}

// Function 252
float map(vec3 p){
    float d=de(p);
    p.xy+=path(p.z);
    d=max(d,.01-max(abs(p.x),abs(p.y)));
    p.y+=.01;
    d=min(d,max(abs(p.x)-.001,abs(p.y)-.001));
    return d;
}

// Function 253
float sdf_arc(vec2 pos, vec2 arc_pos, float r, float width, float angle_a, float angle_b)
{
    float donut1 = sdf_donut(pos, arc_pos, r, 0.14);
    float donut2 = sdf_donut(pos, arc_pos, r * 1.5, 0.15);
    float donut3 = sdf_donut(pos, arc_pos, r * 2.0, 0.16);
    float donut = min(min(donut1, donut2),donut3);
	float corner;
    
    if (mod(angle_b - angle_a, TAU) < PI) {
        corner = min(sdf_plane(pos, arc_pos, angle_a),
                    -sdf_plane(pos, arc_pos, angle_b));
    } else {
        corner = max(sdf_plane(pos, arc_pos, angle_a),
                    -sdf_plane(pos, arc_pos, angle_b));
    }
    
    corner += AA_THRESHOLD * (mod(angle_b - angle_a, TAU) / TAU);
    
    return max(donut, -corner);
}

// Function 254
float lineDist2D(vec2 a, vec2 b, vec2 p) {
    return lineDist2D(line2D(a, b), p);
}

// Function 255
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {
    if (iFrame <= 5) { // initial terrain
        vec3 p = 1.5 * rayDir;
        fragColor.x = 0.;
        for (float i = 0.; i < 5.; i++) {
            float c = craters(0.4 * pow(2.2, i) * p);
            float noise = 0.4 * exp(-3. * c) * FBM(10. * p);
            float w = clamp(3. * pow(0.4, i), 0., 1.);
            fragColor.x += w * (c + noise);
        }
        fragColor.x = pow(fragColor.x, 3.);
        fragColor.x = (5. - fragColor.x) / 15.;
        return;
    }
    
    // which cube face are we on?
    vec3 rayAbs = abs(rayDir);
    int face = rayAbs.x > rayAbs.y ? rayAbs.x > rayAbs.z ? 0 : 2 : rayAbs.y > rayAbs.z ? 1 : 2; // faceID
    if (rayDir[face] < 0.) face += 3;
    
    /* rotation matrix for projecting 2D coords onto the 3D cube
       the face IDs on the unrolled cube look like:
         1
       3 2 0 5
         4
    */
    mat3 faceMat;
    switch (face) {
    case 0: faceMat = rotY(PI/2.); break;
    case 1: faceMat = rotX(-PI/2.); break;
    case 2: faceMat = rotY(0.); break;
    case 3: faceMat = rotY(-PI/2.); break;
    case 4: faceMat = rotX(PI/2.); break;
    case 5: faceMat = rotY(PI); break;
    }
    
    mainImage(fragColor, fragCoord, faceMat);
    
    // seed extra river basins
    vec3 h = hash33(vec3(fragCoord, iFrame));
    if (h.x < 1e-5 && h.y < 1e-5) fragColor.x -= 0.2;
}

// Function 256
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    if( pos.x<-0.5 )
    {
    res = opU( res, vec2( opS(
                          sdRoundBox(  pos-vec3(-2.0,0.21, 1.0), vec3(0.15),0.05),
                          sdSphere(    pos-vec3(-2.0,0.21, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS(
                          sdTorus82(   pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
                          sdCylinder(  
                               opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    res = opU( res, vec2( 0.5*sdSphere(pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(45.0*pos.x)*sin(45.0*pos.y)*sin(45.0*pos.z), 65.0 ) );
    res = opU( res, vec2( 0.6*sdTorus(
                              opTwist( pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    res = opU( res, vec2( sdRoundCone( pos-vec3(-2.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );
    }
    if( pos.x>-2.5 && pos.x<0.5 )
    {
    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
    res = opU( res, vec2( sdOctahedron(pos-vec3(-1.0,0.15,-2.0), 0.35 ),37.0 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );
    }
    if( pos.x>-1.5 && pos.x<1.5 )
    {
    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
    res = opU( res, vec2( sdCappedCone(pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    }
    if( pos.x>-0.5 && pos.x<2.5 )
    {
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.30, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( sdRoundBox(  pos-vec3( 1.0,0.30, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-2.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );
    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
    }
    if( pos.x>0.5 )
    {
    res = opU( res, vec2( sdCylinder(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );
    res = opU( res, vec2( sdRoundCone( pos-vec3( 2.0,0.20,-2.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );
    }
    
    return res;
}

// Function 257
float mapWalls( vec3 p )
{
    float angle = atan(p.z, p.x);
    float d1 = sdSphere(p, ROOMSIZE);
    float d2 = (sin(angle*10.0)+1.0)*0.2;//((sin(angle*8.0)+1.0)*0.5)*0.1;
    float d3 = sin(p.y*2.0)*0.1;
    return max(max(-d1, d2), d3);//polsmax(max(-d1, d2), d3, 0.3);//d2+d3;
}

// Function 258
float map(vec3 p)
{
  vec3 cp = p;
  float dist = 1000.;

  float time = iTime * .25;
 p *= .36;
  p.zx *= rot(-time * .25);

  p.xz *= rot(p.z*1.1);

  for(float it = 0.; it < 2.; it += 1.)
{
  p.xz *= rot(sin(p.y + time + (fract(sin(it * 2369.)))) * PI / (it + 1.) * .5);

//  p.y += p.x * .125;
  p.zy *= rot(time+PI);
vec3 ap = max(vec3(0.),abs(p)) - 1.;
float cu = length(ap)-.5 + min(max(ap.x,max(ap.y,ap.z)), 0.);
  dist  =smin(dist, cu , .25);

}

  p = cp;
  p.xz *= rot(-time * .5);


  float rad = 5.;
  float wi = .5;
  float sph = length(p) - rad + wi /2.;

  dist = -smin(sph,-dist,.15);

  sph = length(p) - rad - wi /2.;

  dist = -smin(-sph,-dist,.15);

  sph = distance(cp, vec3(0.,0.,-5.)) - 2.;

  dist = -smin(sph,-dist,.3);

  return dist;
}

// Function 259
float GetHexSDF(in vec2 p)
{
  p = abs(p);
  return 0.5 - max(dot(p, hexRatio * 0.5), p.x);
}

// Function 260
float hmDist(in Ray ray) {
	float rh = ray.origin.y;
    float mp = texture(iChannel0, ray.origin.xz / 16.0, 10.0).r*4.;
    return rh - mp;
}

// Function 261
float mapX(vec2 p,  float s){

    return max(length(p)-s, min(abs(p.x-p.y), abs(p.x+p.y)));
}

// Function 262
void MapWall(in vec3 world_pos, out Obj obj)
{	
	float x_dist = 200.0 - abs(world_pos.x);
	float z_dist = 300.0 - abs(world_pos.z);
	float dist = min(x_dist, z_dist);
	if (dist <= EPSILON)
	{
		obj.m_obj_idx = 1;
	}
	obj.m_dist = dist;
}

// Function 263
vec2 GetDistOffset(vec2 uv, vec2 pxoffset)
{
    vec2 tocenter = uv.xy;
    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));
    
    float angle = length(tocenter.xy) * 2.221 * DISTORTION_BARREL;
    vec3 oldoffset = vec3(pxoffset, 0.);
    
    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset)
        * sin(angle) + prep * dot(prep, oldoffset) * (1. - cos(angle));
    
    return rotated.xy;
}

// Function 264
float distanceField(vec3 p) {
	float sphere = sdSphere(p - vec3(0.0, 0.0, 4.0), 2.0);
	float box = sdBox(p - vec3(0.0, 0.0, 4.0), vec3(3.5, 1.0, 1.0));
	float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));
	return join(carve(box, sphere), plane);
}

// Function 265
float mapid(vec3 p)
{
	float oid = 0.0;
    PLANEMAT;
    float r = PLANE;	// Return distance
    
    rotMat = rotationMatrix(vec3(0,1,sin(iTime*3.14159*0.01)*0.5), iTime*3.14159*0.5);
    float rn = min(r, BOX);
    r = mix(r, rn, step(r,rn));
    oid = mix(1.0, 0.0, step(r,rn));
    
    
    return oid;
}

// Function 266
float cylinderSDF(const in vec3 p, const in vec2 h) {
    return plateSDF(vec2(length(p.xy), p.z), h);
}

// Function 267
void scene(in vec3 x, out vec2 sdf)
{
    x.x += .3*iTime;
    x *= 2.;
    
    vec3 n;
    lfnoise(x.x*c.xx-iTime, n.x);
    lfnoise(2.*x.x*c.xx-iTime-1337., n.y);
    lfnoise(x.x*c.xx+2.*iTime-2337., n.z);

    x.yz += .1*vec2(cos(x.x), sin(x.x))*n.xy;
    
    mat3 RR;
    rot3((.6+.4*iScale)*1.3*mix(.2,1.5, .5+.5*n.x)*n.z * c.xyy, RR);
    x = RR * x;
    x.z = abs(x.z);
    
    float d, da, db;
    
    graf(x.xy, d);
    stroke(d+mix(.01,.04, iScale), mix(.01,.04, iScale), da);
    
    float v;
    vec2 ind;
    dvoronoi(12.*x.xy, v, ind);
    
    zextrude(x.z, -d, .1-.1*v, d);
    
	sdf = vec2(d,1.);
    float modsize = .025,
		y = mod(d-.3-.02*iTime,modsize)-.5*modsize,
        yi = (d-y)/modsize;
    
    float na;
    lfnoise(2.*yi*c.xx-.3*iTime, na);

    zextrude(x.z-.05*na, -y, mix(0.,.05+.05*na,iScale), d);
    stroke(d,.035,d);
    zextrude(x.z, -da, .25, da);
	add(sdf, vec2(da, 1.), sdf);
	
	lfnoise(5.*x.xy, da);
	    mfnoise(x.xy, 32., 422., .45, db);
        da = .5*(db+da);
		sdf.x -= .001*da;
        stroke(da, .1, da);
        sdf.x -=.005*da;
    add(sdf, vec2(d, 1.), sdf);
    add(sdf, vec2(x.z+.25,1.), sdf);
}

// Function 268
vec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {
	vec2 d0mM, d3mM;
	for (int i=0; i<SUBDIV; i++) { // iterative subdivision
		if (i >= n) continue;
		
		// construct the 2 sub- control polygons
		vec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),
			 P012  = .5*(P01+P12),  P123 = .5*(P12+P23),
			 P0123 = .5*(P012+P123); // is on the spline

		
		d0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1
		d3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2
		
		bool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);
		d0mM = abs(d0mM); d3mM=  abs(d3mM);
			
		if (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )
			return vec2(0.,float(i));    // draw skeleton
		float s;


		// inside one of the sub quadri
		if      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;
		else 
#if 1
		if (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer
		else if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer
			else // ambiguous
			  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method
#else
			if (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)
#endif
		
		if (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1
		else      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2
   	}
	
	if (n<0) // ambiguity found: switch to costly method
		return dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); 
	
  	return dist2quadri(pos, P0,P1,P2,P3);
}

// Function 269
vec2 distort (vec2 p) {
return p+(vec2(sin(p.x*104.0+offset)+cos(p.y*113.0+offset))*0.0015);
}

// Function 270
float map(vec3 p) {
	float s = length(p)-1.0;
	
	return s + snoise((p*10.0 + iTime)-0.8)*0.005;
}

// Function 271
vec2 sdf_normal(float sdf)
{
    vec2 n = vec2(dFdx(sdf), dFdy(sdf));
	float sqlen = dot(n, n);
    return n * ((sqlen > 0.) ? inversesqrt(sqlen) : 1.);
}

// Function 272
vec2 remap( vec2 a, vec2 b, vec2 v )
{
	return clamp( (v-a) / (b-a), vec2(0.0), vec2(1.0) );
}

// Function 273
float map( vec3 P, vec3 w, float s, inout vec3 n, inout int level)
{
    orb = vec3(0.0);
    orb2 = vec3(0.0);
    vec3 p1 = far;
    vec3 p2 = far;
    vec3 p3 = far;
    vec3 p4 = far;
    
    float t = longTime;
    float next = t;
    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o1, 2.0*o2, 2.0*o3, 2.0*lastPt(o3, o2, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);
    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o4, 2.0*o3, 2.0*lastPt(o3, o4, o2, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);
    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o3, 2.0*o4, 2.0*o1, 2.0*lastPt(o1, o4, o3, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);
    chooseTetra(P, w, p1, p2, p3, p4, 2.0*o2, 2.0*o1, 2.0*o4, 2.0*lastPt(o2, o4, o1, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,0.0,1.0), next);
	orb2 += orb;    
                
    vec3 v1 = p1;
    vec3 v2 = p2;
    vec3 v3 = p3;
    vec3 v4 = (p1 + p2)/2.0;
    vec3 v5 = (p2 + p3)/2.0;
    vec3 v6 = (p1 + p3)/2.0;
    vec3 v7 = lastPt(v4, v6, v5, 1.0);
  	
    if(t > 0.0) {
    	level = -1;
        return t;
    }
    for(int i=0; i <iters; i++) {
        t = next;
        chooseTetra(P, w, p1, p2, p3, p4, v4, v6, v1, lastPt(v1, v6, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);
        chooseTetra(P, w, p1, p2, p3, p4, v5, v3, v6, lastPt(v6, v3, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,1.0), next);
        chooseTetra(P, w, p1, p2, p3, p4, v2, v5, v4, lastPt(v4, v5, v2, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);
        chooseTetra(P, w, p1, p2, p3, p4, v4, v7, v6, lastPt(v6, v7, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(0.0,1.0,0.0), next);
        chooseTetra(P, w, p1, p2, p3, p4, v5, v6, v7, lastPt(v7, v6, v5, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,0.0,0.0), next);
        chooseTetra(P, w, p1, p2, p3, p4, v4, v5, v7, lastPt(v7, v5, v4, 0.5), t, n, 1.0/float(maxIters)*vec3(1.0,1.0,0.0), next);
        orb2 += orb;
        v1 = p1;
        v2 = p2;
        v3 = p3;
        v4 = (p1 + p2)/2.0;
        v5 = (p2 + p3)/2.0;
        v6 = (p1 + p3)/2.0;
        v7 = lastPt(v4, v6, v5, 1.0);
        if(t > 0.0) {
        	level = i;    
            return t;
        }
    }
    t = next - 0.01;
    
    //For anim
    v7 = lastPt(v4, v6, v5, height);
    orb2 -= orb;
    orb2 += orb*height;
    vec3 n1;
    float t1 = rayTriangle(P, w, n1, v1, v6, v4);
    if(t1 < t) {t = t1; n = n1;}
    t1 = rayTriangle(P, w, n1, v6, v3, v5);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v5, v2, v4);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v4, v6, v7);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v7, v6, v5);
    if(t1 < t) { t = t1; n = n1; }
    t1 = rayTriangle(P, w, n1, v7, v5, v4);
    if(t1 < t) { t = t1; n = n1; }
    level = iters;
	return t;
}

// Function 274
float map(vec3 p) {
  
  vec3 tp = p;
  tp.z += time*10.0;
  tp.y += sin(time*0.7)*5.0;
  float f = noise(tp.xz*0.08)*0.5;
  f += noise(tp.xz*0.16)*0.25;
  f += noise(tp.xz*0.32)*0.125;
  f = abs(f-0.5);
  float d2 = 8.0-tp.y + f*13.0;
  d2 *= 0.7;  
  
  
  p.yx *= rot(sin(time*0.7) * 0.3);
  p.yz *= rot(-0.7 + sin(time) * 0.3);
  
  
  p.y += sin(time*4.0 + 2.5 + abs(p.x)*0.4)*0.3;
  
  float d = wings(p);
  
  d = body(d, p);
  
  d = claws(d, p);
  
  
  d = min(d, d2);
  
  mat = abs(d-d2)<0.01?1.0:0.0;
  
  return d;
}

// Function 275
float dist_blob(vec3 pos) {
 	vec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;
    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;
    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;
    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;
    float l0 = length(v0) - .8;
    float l1 = length(v1) - .7;
    float l2 = length(v2) - .6;
    float l3 = length(v3) - .5;

    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);
    return 1. + 1./l0 + 1./l1;
}

// Function 276
void post_map_overlay( inout vec3 col, vec2 coord )
{
    coord = ( coord - g_overlayframe.xy ) * iResolution.xy / g_overlayframe.zw;
	map_position( col, coord );
    if( dot( g_game.mapmarker, g_game.mapmarker ) > 0. )
    	map_marker( col, coord );
    if( dot( g_game.waypoint, g_game.waypoint ) > 0. )
    	map_waypoint( col, coord );
    if( g_env.H == 0. ) 
    	map_orbit_track( col, coord );
}

// Function 277
vec2 sdScene(vec3 pos)
{
	vec2 result = vec2(sdPlaneNoDisplacement(pos, -.75), 2.);
    
    result = sdUnion(result, vec2(sdRect(pos, rect.a, rect.b, rect.c, rect.d), 0.));
    
    return result;
}

// Function 278
float map(vec2 p) {
    vec2 pos=p;
    float t=iTime;
    col+=fractal(p);
    vec2 p2=abs(.5-fract(p*8.+4.));
	float h=0.;
    h+=sin(length(p)+t);
    p=floor(p*2.+1.);
    float l=length(p2*p2);
    h+=(cos(p.x+t)+sin(p.y+t))*.5;
    h+=max(0.,5.-length(p-vec2(18.,0.)))*1.5;
    h+=max(0.,5.-length(p+vec2(18.,0.)))*1.5;
    p=p*2.+.2345;
    t*=.5;
    h+=(cos(p.x+t)+sin(p.y+t))*.3;
    return h;
}

// Function 279
float map(vec3 p){
    vec3 p1 = p;
    p1.y -= clamp(p.y, 0.0, 2.0);
    float d = max(length(p1 - vec3(-2.0, 0.0, 0.0)) - 1.0, length(max(abs(p - vec3(-2.0, 1.0, 0.0)) - vec3(1.0, 1.0, 1.0),0.0)));
    d = min(d, dot(p,vec3(0.0, 1.0, 0.0)) + 1.0);
    return d;
}

// Function 280
float map(vec3 p){   
    dstepf += 0.005;
    return smin(max(-ocutter(p), min(owater(p), oplanet(p))), okernel(p), 0.05);
}

// Function 281
float map(vec3 pos)
{
    float angle0 = atan(pos.x, pos.z);
    angle = angle0 + rot;
    float angle2 = angle + pos.y*1.1;
    angle3 = fract(5.*angle/pi) - 0.3;
    float angle4 = angle0*3. - iTime*2. - angle3 + 0.3;
    
    pos.xy = rotateVec(pos.xy, 0.15*smoothstep(40., 200., iTime)*cos(rot*2.));
    pos.zy = rotateVec(pos.zy, 0.15*smoothstep(40., 200., iTime)*sin(rot*2.));
    
    //pos.z+= 0.3*pos.y*sin(angle);
    return length(pos.xz)*0.9
                 *(0.8 - (0.43 + 0.05*(smoothstep(-0.9, 0.9, sin(24.*angle))))
                 *smoothstep(0.16, 0.08, abs(pos.y)))
                 + 0.2*smoothstep(0.21, 0.25, abs(pos.y))
                 - 0.5
                 - 0.045*sin(angle4)
                 *smoothstep(0.245, 0.19, length(vec2(angle3, 3.8*abs(pos.y - scrpos))))
                 *(1. + 0.4*smoothstep(0.06, 0.072, abs(angle3 - 0.16 + 2.8*abs(pos.y - scrpos + 0.06))))
                 - 0.8*smoothstep(0.58, 1.35, abs(pos.y))
                 *smoothstep(1.45, 1.27, abs(pos.y))
                 *abs(sin(angle2*6.5))
                 - 0.04*smoothstep(0.58, 0.62, abs(pos.y))*smoothstep(1.46, 1.42, abs(pos.y))
                 + 0.9*pow(abs(pos.y*0.36) + 1.*smoothstep(1.6, 2.3, abs(pos.y*1.01)), 2.6);
}

// Function 282
void sceneMatrix(vec2 screenUv, out vec3 params)
{
	float speed = hash(screenUv.x)*.5+.2;
	float y = fract(screenUv.y + speed*iBeat);
	params = vec3(.05/y,36,38);
}

// Function 283
float distToGround(vec3 inPos)
{
float y = -30.0; // ground height

return inPos.y - y;
}

// Function 284
float scene(vec3 p) {
  if (length(p) > 1.) return length(p)-.8;
  vec4 x=vec4(p,1),
    f00=sin(x*mat4(-1.74,-1.05,-1.82,2.64,-3.5,-4.23,2.91,-3.83,-.67,2.72,1.37,10.45,-1.46,-1.9,3.0,5.41)),
    f01=sin(x*mat4(-3.12,-3.3,1.11,-1.54,2.91,-2.94,.82,-9.88,.92,1.34,2.62,2.71,1.16,1.04,-1.25,-9.69)),
    f02=sin(x*mat4(3.42,-1.21,2.28,9.64,-2.02,1.15,1.83,-4.09,3.23,-.52,2.07,5.01,.52,-.6,3.35,.87)),
    f10=sin(mat4(-.99,.53,-.28,.66,.15,-.02,-.09,-.06,-.01,-.05,-.04,-.56,-.1,-.31,-.83,-.43)*f00+mat4(.15,.04,-.09,.21,.42,-.23,.02,.17,.23,.31,.6,.56,-.93,1.47,.0,-.48)*f01+mat4(.71,-.44,-.18,.43,-.6,.42,.45,.5,-.92,.35,-.72,-.44,.0,.76,-.31,-.05)*f02+vec4(-13.95,-3.14,5.36,-9.25)),
    f11=sin(mat4(-.54,-.75,-.21,-.24,-.38,.06,-.03,.55,.81,.51,-1.12,-.01,-.38,.11,-.02,.67)*f00+mat4(.11,.15,-.05,1.59,.04,-.23,-.18,-1.16,-.08,-.14,-.53,-.07,.23,-.36,-.4,-.15)*f01+mat4(.72,.28,-.18,-.61,.22,-.23,-.65,.28,.83,.41,.11,-.29,-.39,-.32,-.92,-.51)*f02+vec4(-4.81,6.95,9.26,-6.26)),
    f12=sin(mat4(.73,.76,-.2,-1.04,-.46,.18,.21,1.15,-.06,-.43,.94,.13,.37,-.67,.6,.11)*f00+mat4(.38,.4,.04,.88,-.27,-1.18,.03,-.33,.14,1.54,.69,1.17,.37,1.3,.26,-1.7)*f01+mat4(.33,.42,-.4,-.97,-.23,.84,.42,-.1,-.67,.39,-.84,-.62,.45,.69,.37,1.29)*f02+vec4(-4.38,5.86,13.65,-9.16)),
    f20=sin(mat4(-.39,.06,1.14,.07,-.06,-.82,.13,-.17,.19,-.79,-1.93,.11,-.39,-.02,-.48,-.05)*f10+mat4(-.51,-.77,-.35,-.02,.1,.47,-1.25,.08,-.1,-.3,1.4,.13,-.1,.21,-.59,.21)*f11+mat4(-.23,.03,-.68,-.08,.06,.15,1.01,-.11,-.27,-.01,-1.56,.02,-.34,.06,.51,.13)*f12+vec4(4.79,-5.84,7.28,4.74)),
    f21=sin(mat4(.18,.07,.29,-.19,.59,-.03,-.27,.18,.05,.16,.17,-.06,.14,.36,-.24,.0)*f10+mat4(-.38,-.24,-.07,.23,.11,.1,.04,.55,.3,-.2,-.09,.03,.12,.13,.05,.01)*f11+mat4(-.09,.19,.08,.15,.18,.06,-.08,-.03,-.26,-.09,.15,.17,-.06,.07,.14,.19)*f12+vec4(-7.29,1.85,-4.88,.69)),
    f22=sin(mat4(.32,-.19,.24,.29,.95,.0,.93,.07,1.3,-.76,-.57,-.45,.22,.87,-.6,.95)*f10+mat4(-.65,-.3,-.38,-.3,-.61,.58,-.78,1.04,-.32,-.06,.12,.59,-.94,-.06,-.04,-.07)*f11+mat4(.16,-.5,.46,1.24,.39,-.43,.28,-.91,-.76,-.98,-1.13,.27,-1.26,-.3,-.01,-.11)*f12+vec4(-6.24,1.26,-1.13,-13.77));
  return dot(vec4(-.18,.16,.02,-.4),f20)+dot(vec4(-.18,-.51,-.55,.39),f21)+dot(vec4(.03,.08,.11,.05),f22)+.28;
}

// Function 285
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 vn, col;
  float dstObj;
  dstObj = ObjRay (ro, rd);
  ro += rd * dstObj;
  if (length (ro.xz - vec2 (8., 0.)) > 50.) dstObj = dstFar;
  if (dstObj < dstFar) {
    vn = - normalize (sign (fcId) * FcVec (abs (fcId)));
    col = HsvToRgb (vec3 (mod (0.039 * cMid.y, 1.), 1., 1.));
    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +
       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);
    col = pow (clamp (col, 0., 1.), vec3 (0.5));
  } else {
    col = vec3 (0.9, 0.9, 1.) * (0.6 + 0.4 * rd.y);
  }
  return col;
}

// Function 286
float map(vec3 p) {
  float r = iMouse.z > 0.0 ? iMouse.x / 100.0 : iTime * 0.9;
  p.xz = mirror(p.xz, 4.);
  p.xz = rotate2D(p.xz, r);
  float d = sdBox(p, vec3(1));
  d = min(d, sdBox(p, vec3(0.1, 0.1, 3)));
  d = min(d, sdBox(p, vec3(3, 0.1, 0.1)));
  return d;
}

// Function 287
float SDFobj (vec3 p) {
    float arg = mod(iTime*2., 2.)/2.;
    float arg2 = mod(iTime, 10.)/10.;
    float par = arg2 < .5 ? arg2*2. : 1.-(arg2-.5)*2.;
    par = clamp((par-.5)*3.+.5, 0., 1.);
    par = smoothstep(0., 1., par)*.7;
    float SDFobjp = 1e4;
    // center
    SDFobjp = min(SDFobjp, length(p-vec3(0., 3., 0.))-.5 );
    // petal
    float p_yx = atan(p.y-3., p.x);
    float p_yxr = length(vec2(p.y-3., p.x));
    p_yx = mod(p_yx+arg*PI*2./6.-(p.y-3.)*par, PI*2./6.)-PI/6.;
    vec3 q = vec3(p_yxr*cos(p_yx), p_yxr*sin(p_yx), p.z);
    SDFobjp = min(SDFobjp, length(vec3(q.x/4.-.56, q.y*2., q.z*1.)-vec3(0., 0., 0.))-.5 );
    return SDFobjp;
}

// Function 288
vec2 distCar(vec3 p)
{
    //p.xy*=-1.;
    vec3 p0rot=p;
    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));
    float d=1000., d_mat=1001., mat=-1.;
    SET_PREV_MAT(BG);
    p*=2.;
    if(p.x<0.) p.x=-p.x;
    vec3 p0=p+vec3(0,0,.13);
//#define SIMPLE_CAR
#ifndef SIMPLE_CAR
    //d=min(d,length(p)-.5);
    p=p0+vec3(0,.1,0);
    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, 
                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, 
                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),
                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;
    p=p0-vec3(0,.5,.7);
    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.04+p.y*.07-p.y*p.y*.08+p.z*.0, 
                                       1.2-p.z*(.7-.4*step(0.,p.y)),
                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),
                               .33+.15*p.y )*.7;
    d=min(d,dcabin);
    // rear front screen
    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);
    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;
    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...
    float sy=step(0.,p.y);
    float dfrontscr=sdRoundRect( p.xz-vec2(0,-.12+sy*.1), vec2(RUMPFW*.4-sy*.2,.12-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;
    dfrontscr=max(dfrontscr,-(drumpf-.07));
    d=-smin(-d,dfrontscr,.03);
    //d+=rille(dfrontscr-.03,.007);
    // side screens
    p=p0-vec3(0,.23,.91);
    vec3 sidebox=vec3(2.,.35-(p.z+.3)*(.1+step(0.,p.z+.3)*.1),.065+p.y*.023-.05*p.y*p.y*step(0.,p.z))*2.;
    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;
#if 1
    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .1+.07*p.y )*.7;
    //p.z+=.25;
    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;
    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.79), sidebox.yz+vec2(0,.79), .08+.07*p.y )*.7;
#else
    // not sure if even making 2 rects at once is really faster...
    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;
    float dsidescr=dssdoor.x;
    float ddoor=dssdoor.y;
#endif
    ddoor-=.07;
    //p=p0-vec3(0,-2.05,.77)*1.;
    //p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));
    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;
    //float dhood   =sdRoundRect( p.yz,vec2(.9,2.),.18)*.7;
    float dhood1 =  dot(p0-vec3(0,-3.22,0),vec3(.28,-1,.28));
    float dhood2 =  -dot(p0-vec3(0,-1.35,0),vec3(.28,-1,.28));
    float dhood=max(dhood1,dhood2);
    d=-smin(-d,dsidescr,.05);
    //d=-smin(-d,abs(dsidescr-.03),.02);
    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);
    p=p0;
    p-=vec3(0,0,-.77);
    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);
    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);
    p.z+=dz1+dz2;
    p-=vec3(0,-.07,0);
    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,
    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),
    //                            .16 )*.7;
    
    #if 1
    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,
                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),
                                .16 )*.7;
    float ss=1.-smoothstep(-3.,-1.8,p.y);
    float fz0=p.z-dz1*(exp2(-ss*7.));
    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);
    dfender=max(dfender,-(fz0)*.7);
    //d=min(d,dfender);
    #endif
    
    SET_PREV_MAT(CARBODY);
    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);
    
    //drumpf = max(drumpf,-sdBox(pi+vec3(0,.12,0),vec3(2.,.05,.1))/1.4);

    //drumpf=max(drumpf,-sdRoundedCylinder((p0-PR).zxy,.8,.05,.5));
    float dfloorline=p0.z+0.7-.5*(.5-.5*cos((p0.y*1.-p0.y*p0.y*.1)*step(0.,-p0.y)));
    ddoor=-smin(-ddoor,dfloorline-.06,clamp(.15-.1*p0.y,0.01,.3));
    dhood=-smin(-dhood,dfloorline-.08,clamp(.25+.05*p0.y,0.01,.3));
    drumpf-=max(-dfloorline*.5-1.3*dfloorline*dfloorline,0.)*5.*clamp(((-p0.y-1.8)-.9*(-p0.y-1.8)*(-p0.y-1.8))*abs(-p0.y-1.8),0.,11.);
    //drumpf-=rille2(dfender,.02);

    drumpf+=rille(dhood,.005);

    dfloorline=smin(length((p0-PR-vec3(0,0,.15)).zy)-.75,dfloorline,.4);
    //drumpf-=.5*rille2(length((p0-PR-vec3(0,0,.15)).zy)-.75,.03);
    drumpf-=.5*rille2(dfloorline,.03)*smoothstep(-.05,.05,p0.y+3.1);
    
    //side stripe
    p=p0+vec3(0,.1,0);
    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));

    //drumpf+=min(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2+.02*smoothstep(2.8,2.9,-p.y),0.)/1.5; 
    //float dBigZ=length(vec2(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2,drumpf))-.01;
    float dBigZ=bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.085*(1.-smoothstep(2.55,2.6,abs(p0.y+.35)))+abs(drumpf);
    //drumpf+=dBigZ;
    
    // side lamelles
    vec3 pi = p0+vec3(0,-drumpf*2.-p0.z*.3,0)-vec3(0,-1.78,.3);
    drumpf = max(drumpf,-sdBox(pi-vec3(0,clamp(floor(pi.y/.12+.5)*.12,-1.08,0.34),0),vec3(2.,.047,.11))/1.4);
    
    drumpf+=rille(sdRoundRect(p0.yz-vec2(-2.05+(p0.z-.3)*.3,.3),vec2(.8,.15),.03),.005);
    
    drumpf=min(drumpf,dBigZ);
    
    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);
    d=smin(d,drumpf,.03);
    //d=-smin(-d,abs(ddoor),.01);
    //d-=clamp(abs(ddoor)-.005,-0.02,0.);
    d+=rille(ddoor,.005);
    //d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));
    //SET_PREV_MAT(TIRE);
    
    float z=p.z+.2;
    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );
    d=-smin(-d,dgrillhole,.04);
    float f=smoothstep(-3.,0.,p.y);
    //float d2 = -smin(-d,-dgrillhole+.15,.04)
    d=-smin(-d,-dgrillhole+.1+f*10.,.04);
    float newmtl=(dhood1<0.)?CARBODY:GRILL;
    SET_PREV_MAT(newmtl);
    //SET_PREV_MAT(TIRE);
    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);
    SET_PREV_MAT(GUMMI);
    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);
    SET_PREV_MAT(GRILL);

    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);
    p.x=mod(p.x+.005,.025)-.0125;
    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));
    SET_PREV_MAT(GRILL);

    p=p0-vec3(0,.7,.87-.2);
    d=max(d,-dcabin-.06);
    SET_PREV_MAT(INTERIOR);
    
#ifdef RENDER_GLASS
    // window glass
    //if(enable_glass)
    {
        d=min(d,dcabin+.035+(enable_glass?0.:1000.));
        SET_PREV_MAT(GLASS);
    }
#endif

#else // SIMPLE_CAR
    d=min(d,sdBox(p,vec3(2,5,1.)*.5));
    SET_PREV_MAT(GRILL);
#endif // SIMPLE_CAR

    p0-=vec3(0,0,.13);
    
    vec3 pf=p0-PF;
    vec3 pr=p0-PR;
    
    // check tire only once
    //bool rear = (dot(pr,pr)<dot(pf,pf));
    float rear = step(0.,p0rot.y);
    float left = step(0.,p0rot.x);
    float leftSgn=sign(p0rot.x);
    p=mix(pf,pr,rear); float siz=mix(WheelRadiusF,WheelRadiusR,rear);
    
    float axOffs=0.;
    vec4 axQuat=vec4(0,0,0,1);
#ifdef USE_SIMDATA
    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);
    // wheel offsets
    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);
    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);
    axQuat=mix(qf,qr,rear);
    p=transformVecByQuat(p+wo*2.,axQuat)-wo*2.;
    axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;
    p.z-=axOffs;
#endif

#if 1
    {
    // steering rotation of front wheels
    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));
#if 0
    p+=vec3(.07,0,0);
    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));
    p-=vec3(.07,0,0);
#else
    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??
    p=transformVecByQuat(p+vec3(.16,0,0),q)-vec3(.16,0,0);
#endif
    }
#endif

#ifdef USE_SIMDATA
    // wheel rotations
    float rot=WheelRot.x;
    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));
#endif

    d=min(d, distTire(p,siz));
    SET_PREV_MAT(TIRE);
    d=min(d, distRim(p,siz));
    SET_PREV_MAT(RIM);
    
    p=p0;
    float xx=p.x*p.x;
    //p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;
    //d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));
    p=p0-PF*vec3(0,1,1);
    // Frame
    d=min(d,sdRoundBox(p-vec3(.55+p.y*.1,0,.15)+vec3(0,0,1)*(p.y+.3)*(p.y+.3)*sign(-p.y)*.38, vec3(.06-p.y*p.y*.05,.7,.08-p.y*p.y*.05), .015 ));
    p=transformVecByQuat(p,axQuat);
    // Blattfeder (leaf spring)
    d=min(d,sdRoundBox(p+vec3(0,0,1)*p.x*p.x*.18*(1.-axOffs/.1), vec3(.8,.05,floor((.05-p.x*p.x*.035)/.008)*.008), .005 ));
    p.z-=axOffs;
    p.z+=.25*cos(p0.x*.8)-.15*fermi((p0.x-PF.x+.3)/.02);
    d=min(d,sdRoundBox(p, vec3(1.15,.02+.02*fermi((abs(p.z)-.03)/.002),.065-p.x*p.x*.015), .005 ));
    d=min(d,sdRoundedCylinder(p.xzy-vec3(+.9,0,0),.035,.005,.11));
    d=min(d,sdRoundedCylinder(p.xzy-vec3(+1.15,0,0),.035,.005,.11));
    d=max(d,-sdRoundedCylinder(p-vec3(floor(min(p.x,.8)/.1+.5)*.1,0,0),.03,.005,.11));
    //d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);
    //d=min(d,dDirLine(pf,vec3(-.42,.1,-.2),vec3(.05,1,-0.02),1.5)-.005+p0.y*.025);
    d=min(d,sdLine(p0-vec3(0,PF.yz),transformVecByQuat(vec3(-.42+PF.x,.1,-.2),inverseQuat(axQuat))+vec3(0,0,axOffs),
                      vec3(-.22+PF.x,2.,-.25)
                  )-.02+p0.y*.015);
    
    SET_PREV_MAT(CHASSIS);
    
    #if 0
    p=p0-vec3(.37,-1.57,0.1)*2.;
    float d1=1000.;
    d1=min(d1, length(p)-.11*2.1);
    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);
    d=min(d,d1);
    SET_PREV_MAT(HEADLIGHTS);
    #endif
    
    #ifdef RENDER_BBOX
    //if(enable_glass)
    {
        p=p0;
        //d=min(d,abs(sdRoundBox( p0rot-bbpos, bbsize*.5, .0)));
        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));
        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));
        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,-.06,-.11), vec3(ALLW*1.1,3.63,1.13)*.5, .0)));
        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,.33,.47), vec3(ALLW*.8,1.25,.7)*.5, .0)));
        SET_PREV_MAT(GLASS);
    }
    #endif
    
    return vec2(d*.5,mat);
}

// Function 289
float DistanceToQuadOrPlane(vec3 P, Object quad, bool isInfinitePlane)
{
	vec3 V = P - quad.pos;
	float vz = abs(dot(V, quad.quadNormal));
	if (!isInfinitePlane) {
		float ex = 1.0/length(quad.quadBasisX);
		float ey = 1.0/length(quad.quadBasisY);
		float vx = ex*max(0.0, abs(dot(V, quad.quadBasisX)) - 1.0);
		float vy = ey*max(0.0, abs(dot(V, quad.quadBasisY)) - 1.0);
		vz = length(vec3(vx, vy, vz));
	}
	return vz;
}

// Function 290
float TonemapCompressRangeFloat( float x, float t )
{
	return ( x < t ) ? x : t + TonemapCompressRangeNorm( (x-t) / (1.0f - t) ) * (1.0f - t);
}

// Function 291
float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired

    // bteitler: At a really far away distance along the ray, what is it's height relative
    // to the ocean in ONLY the Y direction?
    float hx = map(ori + dir * tx);
    
    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means
    // this pixel is pure sky.  Quit early and return the far distance constant.
    if(hx > 0.0) return tx;   

    // bteitler: hm starts out as the height of the camera position relative to ocean.
    float hm = map(ori + dir * tm); 
   
    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader
    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean
    // surface in the Y direction, but there could have been a peak at a very close point along the x and z 
    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field
    // as the march distance.  The author uses a trick to compensate for this.
    float tmid = 0.0;
    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water
        // bteitler: Move forward along ray in such a way that has the following properties:
        // 1. If our current height relative to ocean is higher, move forward more
        // 2. If the height relative to ocean floor very far along the ray is much lower
        //    below the ocean surface, move forward less
        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping
        // forward more without shooting under ocean, because the ocean is mostly level.
        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then 
        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore
        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk
        // of overshooting.
        tmid = mix(tm,tx, hm/(hm-hx));
        p = ori + dir * tmid; 
                  
    	float hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis

        if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now
            // bteitler: So instead of actually marching forward to cross the surface, we instead
            // assign our really far distance and height to be where we just evaluated that crossed the surface.
            // Next iteration will attempt to go forward more and is less likely to cross the boundary.
            // A naive implementation might have returned <tmid> immediately here, which
            // results in a much poorer / somewhat indeterministic quality rendering.
            tx = tmid;
            hx = hmid;
        } else {
            // Haven't hit surface yet, easy case, just march forward
            tm = tmid;
            hm = hmid;
        }
    }

    // bteitler: Return the distance, which should be really close to the height map without going under the ocean
    return tmid;
}

// Function 292
float map(vec3 p)
{
    
    vec3 cp = p;
    p.xy *= 2.;
    float r = iTime * .75;
    for(float i = 0.; i < 5.; ++i)
    {
        p = abs(p);
        p.x -= 1.;
        p.xy *= rot(r);
        p.xz *= rot(r * .75);
        p.yz *= rot(r * .5);
        r *= .9;   
    }
    
    float dist = max(p.x,max(p.y,p.z)) - 1.;
    
    p = abs(cp);
    
    float tunnel = max(p.x, p.y) - 15.;
    
//    dist = min(dist, -tunnel);
    
    return dist;
}

// Function 293
float sdf(in vec3 pos, out Surface surf) {
    float sSc = length(pos)-SceneRadius;
    float s = sdfIFS(pos * rotationMatrix(vec3(.5, .0, .0)*Pi), surf);
    return abs(sSc) > abs(s) || s > 0. ? s : sSc;
    
}

// Function 294
float Sdf(Object obj, vec3 marchingPosition){
    float dist = FAR_CLIP;
    switch(obj.type)
    {
        case OBJECT_TYPE_PLANE:
        	dist = SdfPlane(obj, marchingPosition);
        	break;
        case OBJECT_TYPE_AABB:
        	dist = SdfAABB(obj, marchingPosition); 
        	break;
        case OBJECT_TYPE_SPHERE:
        	dist = SdfSphere(obj, marchingPosition);
        	break;
        case OBJECT_TYPE_R_DODECA:
        	dist = 0.5 * SdfRDodeca(obj, marchingPosition);
        	break;
    };
    return dist;
}

// Function 295
float sdfPlane(in vec3 pos, in vec3 n) {
    return dot(pos, n);
}

// Function 296
float dist2( vec3 p)
{
    //return length(p)-1.;
    return length(vec2(length(p.xy)-1.,p.z))-.35;
}

// Function 297
float TorusSDF(vec3 p, vec2 radii)
{
	vec2 q = vec2(length(p.xz) - radii.x, p.y);
    return length(q) - radii.y;
}

// Function 298
vec2 scene(vec3 p) {
    // dummy float max and min
    vec2 res = vec2(10000., -10000.);
    float d = 0.;

    {
		float pl = sdPlane(p - vec3(0., 2., 0.), vec4(0., 1., 0., 2.));
        res = minMat(res, vec2(pl, MAT_FLOOR));
    }
    {
	    float s1 = sdElipsoid(p - vec3(0., .8, 0.), vec3(.5));        
        res = minMat(res, vec2(s1, MAT_SPHERE));
    }
    {
		float b1 = sdBox(p - vec3(1., .25, 0.), vec3(.2, .5, .2));
        res = minMat(res, vec2(b1, MAT_BOX));
    }
    {
		float b2 = sdBox(p - vec3(-1., .25, 0.), vec3(.2, .5, .2));
        res = minMat(res, vec2(b2, MAT_BOX));
    }

    return res;
}

// Function 299
float map2( in vec3 p, in float id )
{
    float w = 0.05 + 0.35*id;
    return length(max(abs(p)-0.5+w,0.0))-w+0.001;
}

// Function 300
vec2 mdist(vec3 pos)
{
    float m=1.;
    vec3 tpos=clamp(pos,-.95,.95);
    float d=(distTiled(tpos)-.02);
    d+=length(tpos-pos)*.5;
    float dp=d;
    d=min(d,pos.z-FloorZ);
    if (d<dp) m=2.;
    
    return vec2(d,m);
}

// Function 301
float sdf(vec3 p)
{
    return length(p) - 1.0;
}

// Function 302
float materialHeightMap( vec2 grooves, vec2 coord ) {
	return min( grooveHeight( grooves.x, 0.01, coord.x ), grooveHeight( grooves.y, 0.01, coord.y ));
}

// Function 303
float scene(vec3 p, float t) {
	float bigCube = tileCubeShell(p, t);
	float littleCube = marchingCubePath(p, t - 10.0);
	return min(bigCube, littleCube);
}

// Function 304
float sdf_line4(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AB = vert_A - vert_B;
    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.
    vec2 some_vector = vec2(sin(angle), sin(angle - asin(1.)));
    return -dot(uv, some_vector);  // Signed distance!
    //return abs(dot(uv, some_vector));  // Unsigned distance!
}

// Function 305
float font2d_dist(vec2 tpos, float size, vec2 offset) {

    float scl = 0.63/size;
      
    vec2 uv = tpos*scl;
    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);
    
    float k = texture(iChannel2, font_uv, -100.0).w + 1e-6;
    
    vec2 box = abs(uv)-0.5;
        
    return max(k-127.0/255.0, max(box.x, box.y))/scl;
    
}

// Function 306
float cloudssdf(vec3 p) {
  p.y += iTime*.2;
  float d1 = comp(p, normalize(vec3(1,2,5)), 0.5);
  p.y += iTime*.2;
  float d3 = comp(p*2., normalize(vec3(3,1,1)), 2.5)/2.;
  p.y += iTime*.2;
  float d4 = comp(p*3., normalize(vec3(4,-2,5)), 3.5)/3.;
  return (d1+d3+d4)/3.;
}

// Function 307
float map(in vec3 p)
{
	orbitTrap = vec4(10.0);
	d = sdPlane(p);

	vec3 c = vec3(2.0, 8.0, 2.0);
	vec3 q = mod(p-vec3(1.0,0.1*iTime,1.0),c)-0.5*c;
	float kali = Kalibox(rotYaxis(q,0.04*iTime));
	m = max(kali,-sdCylinder(p,vec3(0.0,0.0,0.30+0.1*sin(iTime*0.2))) );

	d = sminPoly (m, d, 0.04); 
   return d;
}

// Function 308
vec2 equiRemap(vec2 lonLat, vec2 delta) {
    vec3 v = lonLatToXYZ(lonLat);
	v = yRot(v,delta.x);
    v = xRot(v,delta.y);
    return xyzToLonLat(v);
}

// Function 309
float map(in vec3 p)
{
    float r =length(p);
    vec2 sph = vec2(acos(p.y/r), atan(p.x, p.z));
    
    matid = 1.;
    float d = r-1.; 
    d += sin(sph.y*7.)*0.02;
    d += sin(sph.y*20.)*0.002;
    float gbh = sin((sph.x+sph.y)*7.+0.5)*0.5+0.5;
    d += sin(sph.y*40.)*0.001*gbh;
    d += sin(sph.x*1.85+2.7)*0.3;
    
    //Leaves
    vec3 p2 = p;
    float rxz2 = dot(p.xz,p.xz);
    float rxz = sqrt(rxz2);
    rxz = exp2(rxz*6.-5.);
    p2.xz = foldPent(p2.xz);
    p2.y -= sqrt(rxz)*0.17 + sin(rxz*2.+p.z*p.x*10.)*0.05;
    float leaves = sbox(p2+vec3(0,-.92-smoothstep(-0.01,.05,rxz2)*0.05,0),vec3(.07- rxz*0.1,0.002+p2.x*0.15,0.8));
    leaves = smin(leaves, cyl(p+vec3(sin(p.y*3.5 + 0.8)*0.3 + 0.3,-1.1,0),vec2(.05,.25))); //Tail
    if (leaves < d)matid = 2.;
    d = min(d, leaves);
    
    float flor = p.y+.65;
    if (flor < d)matid = 0.;
    d = min(d, flor);
    return d;
}

// Function 310
vec4 depth_map(vec2 coord){
    return texture(iChannel0, coord/iResolution.xy);
}

// Function 311
float triangleDist(vec2 p, float radius)
{
  return max( abs(p.x) * 0.866025 + p.y * 0.5, -p.y) -radius * 0.5;
}

// Function 312
void SetupScene(float t) { time = t; }

// Function 313
vec3 mapCoord(vec2 uv)
{
	uv = (fract((uv + 1.) / 2.) - .5) * 2.;
    return vec3(-1., -uv.yx * vec2(1, 1));
}

// Function 314
vec3 colormap(float x
){//float s=sin(x*6.28)
 ;return vec3(1,vec2(-1,1)*sign(x))*.25+.25;}

// Function 315
float getLightSDF(vec3 p){
    float d = MAX_DIST;
    d = min(MAX_DIST, sphereSDF(p-getLightPosition(0), 0.2));
    d = min(d, sphereSDF(p-getLightPosition(1), 0.2));
    return d;
}

// Function 316
float sphereSdf(vec3 p, float r)
{
    p.z -= r;
    return length(p) - r;
}

// Function 317
vec4 map(vec3 p)
{
   	float scale = 12.;
    float dist = 0.;
    
    float x = 6.;
    float z = 6.;
    
    vec4 disp = displacement(p);
        
    float y = 1. - smoothstep(0., 1., disp.x) * scale;
    
    #ifdef USE_SPHERE_OR_BOX
        dist = osphere(p, +5.-y);
    #else    
        if ( p.y > 0. ) dist = obox(p, vec3(x,1.-y,z));
        else dist = obox(p, vec3(x,1.,z));
	#endif
    
    return vec4(dist, disp.yzw);
}

// Function 318
float sceneMap3D(vec3 pos)
{
    // find the smallest t value for marching
    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));

    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));
    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));
    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));
    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));
    t = min(t, box(rotateY(pos + vec3(-2, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5)));
    t = min(t, box(rotateY(pos + vec3(2, 1, 0.75), 17.5 * 3.14159 / 180.0), vec3(1.5, 1.5, 1.5)));

    return t;
}

// Function 319
float DistanceSqSecondDeriv(Spline s, FactorsOfP fp, vec3 p, float t)
{
	return t * (t * (t * (t * s.G_4 + s.G_3) + s.G_2) + fp.G_1_plus_p_dot_G_1_p) + fp.G_t_0;
}

// Function 320
vec2 raymarch_main_scene_normals(vec3 _p, float t)
{
    return scene_min(scene_base_sand(_p), scene_pyramids(_p));
}

// Function 321
Hit sceneSDF(vec3 p) {
    Hit rst;
    vec3 p1 = doTranslate(p, vec3(6.0, 3.1, -3.0));
    Hit is0 = Hit(sphereSDF(p1, 3.0), 2);
    p1 = doTranslate(p, vec3(-2.0, 2.1, 8.0));
    Hit is1 = Hit(sphereSDF(p1, 2.0 ), 2);
    p1 = doTranslate(p, vec3(3.0, 1.5 + 10.0 * abs(sin(2.0*iTime)), 1.0));
    Hit is2 = Hit(sphereSDF(p1, 1.5 ), 1);
    
   	/*
    Hit is3 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 0);
    Hit is4 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 0);
    Hit is5 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 0);
    Hit is6 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 0);
    Hit is7 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 0);
    Hit is8 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 0);
    */
    
    Hit outerBox = Hit(sdBox(p-vec3(0.0,25.0,0.0), vec3(25.0,25.0,25.0)), 0); 
    outerBox.dist = -outerBox.dist;
    
    p1 = doTranslate(p, vec3(0.0, 3.5, -1.0));
    Hit is9 = Hit(sdBox( p1, vec3(1.0, 3.0, 4.0)), 3);
    
    rst = unionSDF(is0, is1);
    rst = unionSDF(rst, is2);
    rst = unionSDF(rst, outerBox);
    /*
    rst = unionSDF(rst, is3);
    rst = unionSDF(rst, is4);
    rst = unionSDF(rst, is5);
    rst = unionSDF(rst, is6);
    rst = unionSDF(rst, is7);
    rst = unionSDF(rst, is8);
	*/
    rst = unionSDF(rst, is9);
    return rst;
}

// Function 322
vec3 sceneGrad(vec3 point) {
  float t = scene(point);
  return normalize(vec3(
    t - scene(point + epsi.xyy),
    t - scene(point + epsi.yxy),
    t - scene(point + epsi.yyx)));
}

// Function 323
float sdf_g(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    return t;
}

// Function 324
vec4 hueMap(int hueRange, int minValue, int maxValue, int value) {
    if (value < minValue || value > maxValue )
        //error
        return red;
    int range = maxValue - minValue;
	float hueIncreasePerUnit;
	if (range > 0)
		hueIncreasePerUnit = float(hueRange)/float(range);
	else
		hueIncreasePerUnit = 0.;
    float hue = (float(value - minValue)*hueIncreasePerUnit + float(255 - hueRange))/255.;
		hue = fract(hue + 1./6.);
		hue = 1. - hue;
	return vec4(hsv2rgb(vec3(hue, 1., 1.)), 1);
}

// Function 325
float scene(vec3 p) {
	vec3 point = vec3(abs(p.xy), p.z+0.04);
	if (length(point)>0.8) return 0.8;
	float scale = 3.5;
	point *= scale;
	point += sin(point.yzx*6.0)*0.005;

	// return bottle(p4b);
	vec3 mast = vec3(0.03, 0.0, 1.8);
	vec3 keel = vec3(0.0, 0.3, 0.0);
	vec3 port = vec3(0.0, 0.9, 0.7);
	vec3 port_bow = vec3(1.0, 0.0, 0.0);
	vec3 bow = vec3(1.9, 0.0, 1.2);
	vec3 mid = vec3(0.02, 0.5, 0.4);

	float tri1 = udTriangle(point, mast, mid, port_bow);
	float tri2 = udTriangle(point, port, keel, port_bow);
	float tri3 = udTriangle(point, port, bow, port_bow);

	return (min(min(tri2, tri3),tri1)-0.01+cos(p.x*8.0)*.005)/scale;
}

// Function 326
float SDF( vec3 p )
{
    return min(min(Mat1SDF(p),Mat2SDF(p)),Mat3SDF(p));
}

// Function 327
vec4 render_scene(vec3 pos, vec3 dir, vec3 light_dir) {
    
    // the color to use, w is the scene depth
    vec4 color = vec4(0.0, 0.0, 0.0, 1e12);
    
    // add a sun, if the angle between the ray direction and the light direction is small enough, color the pixels white
    color.xyz = vec3(dot(dir, light_dir) > 0.9998 ? 3.0 : 0.0);
    
    // get where the ray intersects the planet
    vec2 planet_intersect = ray_sphere_intersect(pos - PLANET_POS, dir, PLANET_RADIUS); 
    
    // if the ray hit the planet, set the max distance to that ray
    if (0.0 < planet_intersect.y) {
    	color.w = max(planet_intersect.x, 0.0);
        
        // sample position, where the pixel is
        vec3 sample_pos = pos + (dir * planet_intersect.x) - PLANET_POS;
        
        // and the surface normal
        vec3 surface_normal = normalize(sample_pos);
        
        // get the color of the sphere
        color.xyz = vec3(0.0, 0.25, 0.05); 
        
        // get wether this point is shadowed, + how much light scatters towards the camera according to the lommel-seelinger law
        vec3 N = surface_normal;
        vec3 V = -dir;
        vec3 L = light_dir;
        float dotNV = max(1e-6, dot(N, V));
        float dotNL = max(1e-6, dot(N, L));
        float shadow = dotNL / (dotNL + dotNV);
        
        // apply the shadow
        color.xyz *= shadow;
        
        // apply skylight
        color.xyz += clamp(skylight(sample_pos, surface_normal, light_dir, vec3(0.0)) * vec3(0.0, 0.25, 0.05), 0.0, 1.0);
    }
    
	return color;
}

// Function 328
void renderScene()
{
    minDistMaterial = 0.0;
    minDist = 1e30;
    minDistNormal = vec3(0.0,1.0,0.0);
    
    if (rayDir.y<0.0)
    {
        minDist = rayPos.y/-rayDir.y;
    }
    
    for(int i=1;i<(CUBECOUNT);i++)
    {
        if ( length(cross(getCubePos(i)-rayPos,rayDir))<3.0)
        {
    		renderCube(i);
        }
    }
}

// Function 329
vec3 heatMap(float greyValue) {   
	vec3 heat;      
    heat.r = smoothstep(0.5, 0.8, greyValue);
    if(greyValue >= 0.90) {
    	heat.r *= (1.1 - greyValue) * 5.0;
    }
	if(greyValue > 0.7) {
		heat.g = smoothstep(1.0, 0.7, greyValue);
	} else {
		heat.g = smoothstep(0.0, 0.7, greyValue);
    }    
	heat.b = smoothstep(1.0, 0.0, greyValue);          
    if(greyValue <= 0.3) {
    	heat.b *= greyValue / 0.3;     
    }
	return heat;
}

// Function 330
vec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )
{
    // project+fetch
    vec4 x = texture( s, p.yz );
    vec4 y = texture( s, p.zx );
    vec4 z = texture( s, p.xy );
    
    // blend factors
    vec3 w = pow( abs(n), vec3(k) );
    // blend and return
    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);
}

// Function 331
float SDF( vec3 pos )
{
    // multi fractal
    const float period = 1.6;
    float tt = fract(iTime/period /*+ texture(iChannel0,pos/20.).x /*break up the pattern - screws up texture filtering and I'm too lazy to fix/hide it*/);
    float t[2] = float[2]( tt*period, (tt-1.)*period );
    vec3 uvw = (pos-g_cloudCentre)/30.;
    float f[2] = float[2]( .0, .0 );

// applying flow to the whole SDF causes a "pulsing" - because we're displacing in a straight line so convex curves shrink
    for ( int i=0; i < 2; i++ )
    {
	    vec3 offset = Flow(pos)*t[i];
        vec3 u = uvw
//            +offset*.25; offset *= .0; // makes the loop more obvious but looks generally good
            +offset*.2; offset *= .2; // makes the loop more obvious but looks generally good
        f[i] += texture(iChannel0,offset+u*2.).x/2.;
        f[i] += texture(iChannel0,offset+u*4.).x/4.;
        f[i] += texture(iChannel0,offset+u*8.).x/8.;
        f[i] += texture(iChannel0,offset+u*16.).x/16.;
        f[i] += texture(iChannel0,offset+u*32.).x/32.;
    }
    
    float ff = mix( f[0], f[1], tt );// actually better with a longer fade imo smoothstep(.4,.6,tt) );
    //this doesn't help: const float p = 1.; float ff = pow( mix( pow(f[0],p), pow(f[1],p), tt ), 1./p );

/*this looks far worse
	f[0] *= smoothstep(1.,.5,tt);
    f[1] *= smoothstep(0.,.5,tt);
    const float p = 20.; float ff = pow( pow(f[0],p) + pow(f[1],p), 1./p );*/
//    float ff = max(f[0],f[1]);

    ff *= .5; // strength of clouds vs bounding shapes

//    float g = length(vec3(pos.yz,max(0.,abs(pos.x)-.5)))-1.2;
//    float g = length(pos.xz)-1.3-.5*abs(sin(pos.y*1.5-iTime));
//    g = min(g,length(pos-vec3(0,-2,0))-1.2);
//    float g = length(vec2(pos.y,length(pos.xz)-(.5+.5*sin(iTime*.31))*2.)) - 1.; // smoke ring!
//    float g = max(max(abs(pos.x),abs(pos.y)),abs(pos.z)) - 1.; // cube - even hard corners look soft!
    vec3 p = pos - g_cloudCentre;
    float bulge = 1.-exp2(-20.*g_blastTime);
    float g = length(vec2(p.y,length(p.xz)-1.*bulge))-1.;
    ff *= bulge; // smooth sphere to start
    
//    g = min(g,max(length(pos.xz)-.7,abs(pos.y-g_cloudCentre.y*.5)-g_cloudCentre.y*.5));
    
    // vertical column
    float h = length(pos.xz)-.7+.2*(g_cloudCentre.y-pos.y-1.2); // cylinder - slightly tapered to cone
    h = max(h, pos.y-g_cloudCentre.y); // cut off at top (inside cloud)
    h = max(h,(g_cloudCentre.y*1.25-4.-pos.y)*.3); // softer cut off at the bottom
    
    g = min(g,h);
    ff += g*.6;
    
//    ff += smoothstep(.9,1.,g_blastTime)*2.1;//1.*pow(g_blastTime,2.); // fade
    
    // hard cut at ground level
//    ff = max(ff,-pos.y);
    
    return ff;
}

// Function 332
float beckmannDistribution(float roughness, float NdotH)
{
    float NoH2 = NdotH*NdotH;
    float rg2 = roughness*roughness;
    float r1 = 1.0 / max(0.0001, 4.0 * rg2 * NoH2 * NoH2);
    float r2 = (NoH2 - 1.0) / (rg2 * NoH2);
    return r1 * exp(r2);
}

// Function 333
vec3 mapShadow( in vec3 pos )
{
    float h = terrain( pos.xz );
    float d = pos.y - h;
    vec3 res = vec3( d, MAT_GROUND, 0.0 );
    
    res = mapGrass(pos,h,res);
    res = mapMoss(pos,h,res);

    vec3 m1 =  pos - mushroomPos1;
    vec3 m2 = (pos - mushroomPos2).zyx;
    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;
	res = mapMushroom(m1, res);


    vec3 q = worldToLadyBug(pos);
    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;
    if( d3.x<res.x ) res = d3;

    return res;
}

// Function 334
float map_label(vec3 pos)
{
    #ifdef show_label
    pos = rotateVec2(pos);
    pos = label_pos(pos);

    float df = sdCylinder(pos, vec2(0.11, 0.0028));
    
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    
    return df;
    #else
    return 10.;
    #endif
}

// Function 335
Impact map(in vec3 pos)
{
    float terrainDistance = dTerrain(pos);
    vec3 terrainColour = texture(iChannel0, vec2( pos.x/10.0,pos.y/10.0)).xyz;

    terrainColour = vec3(abs(sin(pos.z*2.3)/PI),abs(sin(pos.z)/PI),abs(cos(pos.z*1.333))/PI);
    
    terrainColour = pow(terrainColour, vec3(1.8));
  
    Impact terrain = Impact(terrainDistance, 0.0, terrainColour, 0);
    
    //Light globe
    float lightRadius = light1.r;
	float lightDistance = dSphere( pos-light1.p, lightRadius );
    Impact light_p1 = Impact(lightDistance,light1.lum, light1.col, 0);
    Impact closest = getClosest(terrain,light_p1);
    
    return closest;
}

// Function 336
vec2 scene(vec3 p) { //get hit distance and material at position
	vec2 top = vec2(plane(vec3(0.0, 4.0, 0.0) - p, vec3(0.0, -1.0, 0.0)), 2.0);
	vec2 bottom = vec2(plane(vec3(0.0, 0.0, 0.0) - p, vec3(0.0, 1.0, 0.0)), 2.0);
	vec2 front = vec2(plane(vec3(0.0, 0.0, 10.0) - p, vec3(0.0, 0.0, -1.0)), 2.0);
	vec2 back = vec2(plane(vec3(0.0, 0.0, -2.0) - p, vec3(0.0, 0.0, 1.0)), 2.0);
	vec2 left = vec2(plane(vec3(-2.0, 0.0, 0.0) - p, vec3(1.0, 0.0, 0.0)), 3.0);
	vec2 right = vec2(plane(vec3(2.0, 0.0, 0.0) - p, vec3(-1.0, 0.0, 0.0)), 4.0);
	vec2 room = _union(_union(_union(top,bottom), _union(front,back)), _union(left,right));
	
	vec2 cuboid = vec2(box((vec4(vec3(0.75, 1.5, 0.5) - p, 1.0) * box_transform_inverse).xyz, vec3(0.7, 1.5, 0.7)), 5.0);
	vec2 ball = vec2(sphere(vec3(-1.0, 1.25, 0.25) - p, 0.7), 1.0);
	vec2 shapes = _union(cuboid, ball);
	
	vec2 lamp = vec2(box(vec3(0.0, 4.0, 0.0) - p, vec3(0.35, 0.01, 0.35)), 0.0);
    vec2 bulb = vec2(sphere(vec3(1.25, 0.1, 2.5) - p, 0.1), 0.0);
    vec2 lights = _union(lamp, bulb);
	
	return _union(_union(room, shapes), lights);
}

// Function 337
float sdf(vec2 p)
{
    float c1 = circle(p, 50.0);
    float c2 = circle(p - right * 50.0, 50.0);
    
    float s = 0.0;
    s = diff(c1, c2);
    s = square(p, 50.0);
    s = sum(triangle(p, PI / 5.0, 50.0), circle(p + up * 25.0, 50.0));
    
    return s;
}

// Function 338
float map(vec3 p) {
    return p.y - fbmM(p.xz);
}

// Function 339
float euclideanDistance(vec3 p1, vec3 p2) {
	float d1 = (p1.x - p2.x);
	float d2 = (p1.y - p2.y);
	float d3 = (p1.z - p2.z);
	return sqrt(pow(d1, 2.0) + pow(d2, 2.0) + pow(d3, 2.0));
}

// Function 340
float sdf_capsule(in vec3 pos, in vec3 a, in vec3 b) {
    vec3 pa = pos - a, ba = b - a;
    float h = clamp(dot(pa, ba) / dot(ba , ba), 0.0, 1.0);
    return length(pa - ba * h) - THICKNESS;
}

// Function 341
float DistanceToPlanet(vec3 eye, vec3 dir, float start, float end) {
    float old_dist;
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 cur_eye = eye + depth * dir;
        float dist = sphereSD(cur_eye);
        if (dist < EPSILON) {
            vec3 old_eye = eye - old_dist * dir;
			return depth - old_dist + old_dist * (old_dist - old_eye.y) / (cur_eye.y - old_eye.y - dist + old_dist);
        }
        depth += dist * 0.5;
        old_dist = dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 342
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){
   
    const vec2 e = vec2(0.001, 0);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
    
}

// Function 343
float sdScene(vec3 pos) {
    vec3 cubePos = rotation(pos - vec3(0.,1.,-3.5), vec3(0.,.5,0.5), iTime);
    distS[0] = sdSphere(pos-vec3(.5,.5,-5.), 1.);
    distS[1] = sdPlan(pos);
    distS[2] = sdBox(cubePos, vec3(.5,.6,.5));
    distS[3] = sdBox(pos - vec3(2.,0.,-3.), vec3(.5,.6,.5));
    int oid = 0;
    float d = distS[0];
    for(int i=1;i<=3;i++) {
        if(distS[i] < d) {
          oid = i;
          d = distS[i];
        }
    }
	return d;
}

// Function 344
float segmentDistance(vec2 v, vec2 w, vec2 p)
{
    float l2 = dot(w-v, w-v);
    if (l2 == 0.0) return distance(p, v);
    float t = max(0.0, min(1.0, dot(p-v, w-v)/l2));
    vec2 projection = v + t*(w-v);
    return distance(p, projection);
}

// Function 345
float word_map(vec2 uv, vec2 pos, int ascii, vec2 unit)
{
    return get_text(uv, pos, ascii, unit, iChannel3);
}

// Function 346
float map(vec3 p)
{
    p.xy += vec2(sin(p.z), cos(p.z)) * 0.25;
    
	vec3 q = fract(p) * 2.0 - 1.0;
    
    vec3 f = floor(p + 0.5);
    
    vec3 k = abs(normalize(q));
    
    float a = -sdBox(q, k+0.1);
    
    float b = -sphere(q, 1.3);
    
    float d = max(-b, a);
    
    float tt = 0.5+0.5*sin(p.z);
    float tr = mix(0.125, 1.0, tt);
    
    float c = sdBoxXY(p - 0.5, tr);
    
    return max(-c, d);
}

// Function 347
vec2 dist(vec3 p) {
    poly2 d = pa_map(pa_const(p.x),pa_const(p.y),pa_const(p.z));
    return vec2(d.a[0] / length(grad(p)),d.a[0]);
}

// Function 348
float euclideanDistance(vec2 p1, vec2 p2) {
	float d1 = (p1.x - p2.x);
	float d2 = (p1.y - p2.y);
	return sqrt(pow(d1, 2.0) + pow(d2, 2.0));
}

// Function 349
float sphere_sdf( vec3 p, float r)
{
  return length(p) - r;
}

// Function 350
float sDist( in vec3 p )
{
    float r = baseTunnel(p);
    r = max(r,-windowCutouts(p));
    return max(r,-windowScallops(p));
}

// Function 351
vec2 map(in vec4 pos)
{
    vec4 localPos = repetition(pos, vec4(4, 2, 5, 4));
    
    float distance = FAR;
    float distortedDistance = FAR;
    
    distance = min(distance, tesseract(localPos, 1.0));
    distance = max(distance, -hTorus(localPos, 0.5, 0.5));
    
    distance = min(distance, hCylinder(localPos, 0.05));
    distance = min(distance, hSphere(localPos-vec4(vec3(0.0), 1.0), 0.2));
    

    
    vec4 spos = 16.0*pos;
    distance += 0.01*(sin(spos.x)+sin(spos.y)+sin(spos.z)+sin(spos.w));
    distortedDistance = distance-0.01;
    
    distance = min(distance, pos.y+1.0);
    
    return vec2(distance, min(distortedDistance, distance));
}

// Function 352
Intersection sdf3D(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    // Set the light as a point light
    vec3 lightPos = vec3(0., 6., -3);

    vec3 lightDir = normalize(isect - lightPos);

    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));


    return Intersection(t, surfaceColor, isect, hitObj);
}

// Function 353
DF SDF(vec3 p, float Time) {
    DF df=DF(p.y-0.25,vec3(1.),1.);
    //Emissive plane
    vec3 ep=p; ep.yz=Rotate(ep.yz,Time*0.78*0.+0.78);
    MIN(df,DF(Box(p,vec3(0.125,5.,8.)),vec3(1.+mod(floor(ep.y)+floor(ep.z),2.)*2.)*vec3(0.2,1.,0.2)
              ,mod(floor(ep.y)+floor(ep.z),2.)+1.));
    
    //Diffuse plane
    MIN(df,DF(Box(p-vec3(0.,0.,7.75),vec3(8.,5.,0.25)),vec3(1.),1.));
    	MIN(df,DF(Box(p-vec3(2.5,2.,6.),vec3(2.,2.,2.)),vec3(1.),1.)); //Box p vgg
    //Lg roterande emissive object
    vec3 rp=p; rp.xz=Rotate(rp.xz-vec2(4.,4.),Time*0.75);
    MIN(df,DF(max(BoxC(rp,vec3(2.,1.,2.)),-BoxC(rp,vec3(1.5,8.,1.5))),vec3(1.,0.1,0.1)*3.,2.));
    
    //Modulation
    vec3 mp=p*12.;
    df.D+=(sin(mp.x)*sin(mp.y)*sin(mp.z))*0.015;
    
    //Spheres
    MIN(df,DF(length(vec3(fract(p.x)-0.5,p.y-0.55,fract(p.z)-0.5))-0.3,vec3(1.),
             ((mod(floor(p.x)+floor(p.z),2.)==1.)?1.:0.2)));
    //Glossy plane
    MIN(df,DF(Box(p,vec3(8.,5.,0.25)),vec3(1.),((mod(floor(p.y*1.)+floor(p.x*1.),2.)==1.)?0.1:0.25)));
    
    //Return
	return df;
}

// Function 354
float map5_value(vec2 p)
{
	float r = 0.;
    float s = 1.;
    float f = 1.;
    
    float w = 0.;
    for(int i = 0;i < 5;i++){
        r += s*noise_value(p*f); w += s;
        s /= 2.;
        f *= 2.;
    }
    return r/w;
}

// Function 355
void MapGoldObjs(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos;
	
	//wheel
	float re = MapCylinder((pos-vec3(-67.0, 3.0, 12.0)).xzy, 2.5, 5.0);
	float re_2 = MapCylinder((pos-vec3(67.0, 3.0, 12.0)).zxy, 2.5, 5.0);
	re = min(re, re_2);
	re_2 = MapCylinder((pos-vec3(30.0, 3.0, 155.0)).xzy, 2.5, 5.0);
	re = min(re, re_2);
	
	//pedal
	re_2 = MapBoxSim(pos - vec3(0.0,7.0,3.0), vec3(2.0, 0.5, 5.0));
	re = min(re, re_2);
	re_2 = MapBoxSim(pos - vec3(9.0,7.0,3.0), vec3(2.0, 0.5, 5.0));
	re = min(re, re_2);
	re_2 = MapBoxSim(pos - vec3(-9.0,7.0,3.0), vec3(2.0, 0.5, 5.0));
	re = min(re, re_2);
	
	//inner box
	re_2 = MapBoxSim(pos - vec3(0.0, 80.0, 18.0), vec3(70.0, 10.0, 14.0));
	re = min(re, re_2);
	
	//inner
	{
		vec3 pos_1 = pos -  vec3(0.0,85.0,0.0);
		float re_3 = MapPianoBodyShapeDist(-pos_1.x, pos_1.z);
		float re_2 = abs(pos_1.y) - 14.0;
		re_2 = Combine(re_3, re_2) + 10.0;
		
		float sinv = sin(-0.66);
		float cosv = cos(-0.66);
		pos_1.x -= 40.0;
		pos_1.z -=30.0;
		pos_1.xz = pos_1.xz * mat2(cosv, -sinv, sinv, cosv);
		re_3 = MapBox(pos_1, vec3(110.0,25.0,60.0));
		re_2 = Subtract(re_2, re_3);
		re_2 += 3.0;
		
		//line
		re_3 = MapBoxSim(pos - vec3(-59.0, 85.0, 27.0), vec3(1.0, 10.0, 23.0));
		re_2 = min(re_2, re_3);
		re_3 = MapBoxSim(pos - vec3(-30.0, 85.0, 40.0), vec3(1.0, 10.0, 36.0));
		re_2 = min(re_2, re_3);
		re_3 = MapBoxSim(pos - vec3(-4.0, 85.0, 50.0), vec3(1.0, 10.0, 46.0));
		re_2 = min(re_2, re_3);
		re_3 = MapBoxSim(pos - vec3(26.0, 85.0, 70.0), vec3(1.0, 10.0, 66.0));
		re_2 = min(re_2, re_3);
		re_3 = MapBoxSim(pos - vec3(62.0, 85.0, 75.0), vec3(1.0, 10.0, 71.0));
		re_2 = min(re_2, re_3);
		
		//hole
		re_3 = MapCylinder(pos - vec3(-42.0, 85.0, 60.0), 4.0, 10.0);
		re_2 = Subtract(re_2, re_3);
		re_3 = MapCylinder(pos - vec3(-17.0, 85.0, 82.0), 5.0, 10.0);
		re_2 = Subtract(re_2, re_3);
		re_3 = MapCylinder(pos - vec3(9.0, 85.0, 115.0), 6.0, 10.0);
		re_2 = Subtract(re_2, re_3);
		
		re = min(re, re_2);
	}
	
	if (re< EPSILON)
	{
		obj.m_obj_idx = 6;
	}
	obj.m_dist = re;
}

// Function 356
float distanceSq(vec2 a, vec2 b)
{
    return dot(a-b,a-b);
}

// Function 357
float sample_lightmap(vec3 camera_pos, vec3 dir, Options options, Intersection result)
{
    if (result.uv_axis == 3)
        return clamp(-dot(result.normal, ENTITY_LIGHT_DIR), ENTITY_MIN_LIGHT, 1.);
    if (result.plane == -1)
        return 1.;

    float unmapped_light = is_material_any_of(result.material, MATERIAL_MASK_LIQUID|MATERIAL_MASK_SKY) ? 1. : 0.;
    vec3 point = camera_pos + dir * result.t;
    vec2 offset = get_lightmap_offset(result.plane);
    if (any(lessThan(offset, LIGHTMAP_OFFSET)))
        return unmapped_light;

    vec2 uv = uv_map_axial(point, result.uv_axis);
#if LIGHTMAP_FILTER == 1 // snap to world texels
    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))
    	uv = floor(uv) + .5;
#endif
    uv = uv / LIGHTMAP_SCALE - offset;
    
#if LIGHTMAP_FILTER > 0
    uv -= .5;
#endif
    
    vec2 base = floor(uv);
    ivec2 addr = ivec2(base);
    if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y)
        return unmapped_light;
    
    uv -= base;
#if !LIGHTMAP_FILTER
    uv = vec2(0);
#endif
    
    float
        s00 = fetch_lightmap_texel(addr + ivec2(0,0)),
        s01 = fetch_lightmap_texel(addr + ivec2(0,1)),
        s10 = fetch_lightmap_texel(addr + ivec2(1,0)),
        s11 = fetch_lightmap_texel(addr + ivec2(1,1)),
        light = mix(mix(s00, s01, uv.y), mix(s10, s11, uv.y), uv.x);

#ifdef QUANTIZE_LIGHTMAP
    const float LEVELS = float(QUANTIZE_LIGHTMAP);
    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) && g_demo_stage != DEMO_STAGE_LIGHTING)
        light = floor(light * LEVELS + .5) * (1./LEVELS);
#endif
    
    return light;
}

// Function 358
float map( vec3 p )
{
	float f = cloudNoise(2.,p,-vec3(0.0,0.25,.125)*iTime);
	float den = sdBox(p,vec3(1.));
//    float den = sdTorus(p,vec2(1.2,.35)); //uncomment to use a torus instead
    den = smoothstep(-0.1,.25,den);
	den = -den-(sin(iTime*.3)+1.)*.3;
	return clamp( den +1.5* f, 0.0, 1.0 );
}

// Function 359
float sdistQuadConvex(vec2 a, vec2 b, vec2 c, vec2 d, vec2 pos)
{
    return max(  sdistLine(a, b, pos),
            max( sdistLine(b, c, pos),
             max(sdistLine(c, d, pos),
                 sdistLine(d, a, pos))));
}

// Function 360
float mapL(vec3 p) {
    return p.y - fbmL(p.xz);
}

// Function 361
float sdf_3(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));
    return t;
}

// Function 362
float find_edge_distance(vec3 p, int brush, int side)
{
    float dist = -1e8;
    
    if (brush < NUM_MAP_AXIAL_BRUSHES)
    {
        vec3[2] deltas;
        deltas[0] = get_axial_point(brush*2) - p;
        deltas[1] = p - get_axial_point(brush*2+1);
        int axis = side >> 1;
        int front = side & 1;
        for (int i=0; i<6; ++i)
            if (i != side)
            	dist = max(dist, deltas[1&~i][i>>1]);
    }
    else
    {
        int begin = get_nonaxial_brush_start(brush - NUM_MAP_AXIAL_BRUSHES);
        int end = get_nonaxial_brush_start(brush - (NUM_MAP_AXIAL_BRUSHES - 1));
        for (int i=begin; i<end; ++i)
        {
            if (i == begin + side)
                continue;
            vec4 plane = get_nonaxial_plane(i);
            dist = max(dist, dot(p, plane.xyz) + plane.w);
        }
    }
    
    return dist;
}

// Function 363
DemoScene get_demo_scene()
{
    return g_demo_scenes[g_demo_scene % g_demo_scenes.length()];
}

// Function 364
float dist_box( vec3 pos, vec3 size ) {
	return dist_roundbox( pos, size, 0.2);
    //return sdTorus( pos, vec2(size.x, size.x * 0.5));
}

// Function 365
float sceneSmooth(vec2 p, float r)
{
	float accum = sceneDistance(p);
	accum += sceneDistance(p + vec2(0.0, r));
	accum += sceneDistance(p + vec2(0.0, -r));
	accum += sceneDistance(p + vec2(r, 0.0));
	accum += sceneDistance(p + vec2(-r, 0.0));
	return accum; // / 5.0;
}

// Function 366
vec3 uv_map (vec4 p, vec4 n) {
    return n.x * p.yzw + n.y * p.xzw + n.z * p.xyw + n.w * p.xyz;
}

// Function 367
float MapPianoBodyShapeDist(in float x, in float y)
{
	if (y > 118.0)
	{//semi circle
		return sqrt((x+30.0)*(x+30.0)+(y-118.0)*(y-118.0)) - 45.0;
	}
	if (y>42.0)
	{
		//box
		float vx = -x - 75.0;
		//sin shape
		float sinv = sin(((y - 42.0)/76.0 + 0.5) * PI);
		sinv = x - (sinv*30.0 + 45.0);
		
		if (x<-30.0)
		{
			return vx;
		}
		return max(sinv, vx);
	}
	float xx = abs(x) - 75.0;
	return Combine(xx, 42.0-y);
}

// Function 368
float spinIconDist(vec2 pos, float size, bool flip, bool dim) {
    
    if (flip) { pos.y = -pos.y; }  
    pos.x = abs(pos.x);
        
    vec2 p0 = vec2(0, 0.2)*size;
    vec2 p1 = vec2(0.35, 0.2)*size;
    vec2 p2 = vec2(0.0, -0.2)*size;
    
    float d = max(lineDist2D(p0, p1, pos), 
                  lineDist2D(p1, p2, pos));
    
    if (dim) { 
        d = abs(d + 0.02*pqrSize) - 0.02*size;
    }
    
    return d;
       
}

// Function 369
float scene(vec3 a) {
   float mainWave;
   float zVal = fractalNoise(vec2(a.x - 5., a.z ), mainWave);
   return a.y + 0.2 + sin(zVal / 6.5);
}

// Function 370
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    
    int id = faceIdFromDir(rayDir);
    
    vec2 coord = fragCoord.xy;
    vec2 size = iResolution.xy;
    vec2 uv = coord / size;
    
    vec4 lastFrame = texture(iChannel0, rayDir);
    if (lastFrame.x != 0. && iFrame > 2) {
        fragColor = lastFrame;
    	return;
    }
    
    mat4 space = texToSpace(coord, id, size);
    vec4 result = vec4(0);
    
    for (int i = 0; i < 4; i++) {
    	result.x = map(space[i].xyz);
        result = result.yzwx;
    }
    
    fragColor = result;
}

// Function 371
float colormap_green(float x) {
    if (x < 20049.0 / 82979.0) {
        return 0.0;
    } else if (x < 327013.0 / 810990.0) {
        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;
    } else if (x <= 1.0) {
        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;
    } else {
        return 1.0;
    }
}

// Function 372
float distBox(vec3 p, vec3 pos, vec3 r) {
    
    return length(max(abs(pos - p) - r, 0.));
    
}

// Function 373
vec3 tonemapReinhard(vec3 color) {
  float l = czm_luminance(color);
  return color  * l / (l + 1.0);
}

// Function 374
float map( in vec3 p )
{
float t =  iTime*params.x;
vec4 bt = mod(vec4(t)+bullet_toff,2.0)*3.0/2.0;
#define FX_Bullets_ID (PRIM_SLOT_ID+3)
vec4 q=vec4(p,1.0);
dM_s(MAT_FX_BULLET, dBullet((mat4( 1.000,0.023,0.004,0.000,-0.002,-0.086,0.996,0.000,0.023,-0.996,-0.086,0.000,1.175,-1.224,-1.443,1.000)*q).xyz , vec2(0.035,7.310),bt.x));
z= oU(dBullet((mat4( 0.996,0.093,0.000,0.000,0.000,-0.000,1.000,0.000,0.093,-0.996,0.000,0.000,0.656,-1.295,-1.956,1.000)*q).xyz , vec2(0.035,7.310),bt.y) , z) ;
z= oU(dBullet((mat4( 1.000,-0.006,-0.000,0.000,0.000,-0.068,0.998,0.000,-0.006,-0.998,-0.068,0.000,1.150,-1.538,-1.645,1.000)*q).xyz , vec2(0.035,7.310),bt.z) , z) ;
dM_e();
return z;
}

// Function 375
float map(in vec3 p)
{
    Sphere s1;
    s1.position = vec3(4.0 * sin(iTime), 4.0 - 2.0 * cos(iTime * 0.5), 4.0);
    s1.radius = 1.0;
    Sphere s2;
    s2.position = vec3(2.0 * sin(iTime), 2.0 + cos(iTime * 0.5), 5.0);
    s2.radius = 1.0;
	float dToS1 = mapSphere(s1, p);
    float dToS2 = mapSphere(s2, p);
    float dToS = min(dToS1, dToS2);
    //float dToS = min(dToS, dToS1)
    return min(dToS, p.y - sin(p.x) * cos(p.z) * 0.4);
}

// Function 376
maybe_float get_distance_along_3d_line_nearest_to_line_segment(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B1
){
    vec3 B = normalize(B1 - B0);
    vec3 D = B0 - A0;
    // offset
    vec3 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B1 - B0));
}

// Function 377
vec2 map(vec3 p)
{  
    float dist = 0.;
    
    if (g.x<m.x ) 
   		dist = length(max(abs(p)-vec3(0.5),0.0)); // cube
    else
    	dist = length(p) - 1.; // sphere
    
    vec2 res = vec2(dist, 1);
    
    return res;
}

// Function 378
float map(in vec3 p) {
	return -cylinder(p, 2.5 + pow(fbm(p*3.0), 3.0) + 0.6*sin(p.z + sin(p.z*1.6+sin(p.y*2.8))));
}

// Function 379
vec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)
{
    //ok so I don't understand this technique yet.
    //I mean I can visualize getting the greyscale values from the texture 
    //at three points around the ref, based on the point and the normal.
    
    //usually if you want a gradient you
    //want to get the difference between the ref and points around it
    
    //we do this when we take the normal although in that cause we are 
    //getting distances. Here we imply distance by getting greyscale values.
    //the resulting gradient then cna be considered a normal because each of
    //it's components is a basis vector that is the slope between the 
    //the components of the ref and the point representing the change from that point
    //to a bit away.
    
    
    
    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps
    float ref = getGrey(triPlanar(tex, p, n));//reference value 
    
    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,
                     //eps.yxz means 0.,0.001, 0. "swizzling
                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,
                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;
    
    //so grad is the normal...then he does:
    grad -= n*dot(grad, n);//takes the dot of the surface normal 
    //and the texture normal (the gradient), so percentage of how similar they are
    //multplies by the surface normal again so scaling it by that percentage
    //and subtracting that from the gradient.
    //so the result is only the portion of the gradient that is not part of n??
    
    // and returning the surface normal + that gradient portion plus a bump factor
    //why???
    return normalize(n + grad*bumpfactor);
}

// Function 380
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 qtHit;
  vec3 objCol, col, vn, rHit;
  float dstHit, spec, c;
  int idObjT;
  idObj = -1;
  dstHit = ObjRay (ro, rd);
  if (idObj < 0) dstHit = dstFar;
  if (dstHit < dstFar) {
    ro += rd * dstHit;
    idObjT = idObj;
    vn = ObjNf (ro);
    idObj = idObjT;
    if (idObj == 1) {
      if (abs (ro.x) < (hbLen - 0.4) + 0.3 &&
         abs (ro.z) < 1.75 * (hbLen - 0.4) + 0.3) {
        objCol = vec3 (0.2, 0.3, 0.6);
        if (vn.y > 0.99) objCol *= 1. - 0.2 * Noisefv2 (100. * ro.xz);
        for (int n = 0; n < nBall; n ++) {
          c = length (ro.xz - pBall[n]);
          if (c < 0.5) {
            objCol *= 0.6 + 0.4 * smoothstep (0.2, 0.5, c);
            break;
          }
        }
        if (ro.y < -0.7) objCol *= 0.3;
        else if (ro.y > 0.) objCol *= 1.2;
        spec = 0.1;
      } else {
        objCol = vec3 (0.2, 0.07, 0.);
        spec = 0.4;
      }
    } else if (idObj == 2) {
      objCol = (qHit.z < 1.8) ? vec3 (0.5, 0.3, 0.) : vec3 (0.7, 0.7, 0.3);
      spec = 0.5;
    } else {
      if (idObj == 10) objCol = vec3 (1.);
      else {
        c = float (idObj - 11);
        objCol = HsvToRgb (vec3 (mod (c / float (nBall), 1.),
           1. - 0.3 * mod (c, 3.), 1. - 0.3 * mod (c, 2.)));
      }
      rHit.y = ro.y;
      for (int n = 0; n < nBall; n ++) {
        if (n == idObj - 10) {
          rHit.xz = ro.xz - pBall[n];
          qtHit = qtBall[n];
          break;
        }
      }
      objCol *= BallChqr (rHit, qtHit);
      spec = 0.5;
    }
    col = objCol * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +
       spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));
  } else col = vec3 (0.02, 0.1, 0.02) * clamp (2.7 + 3. * rd.y, 0., 1.);
  return pow (clamp (col, 0., 1.), vec3 (0.7));
}

// Function 381
float DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)
{
    float aa = dot(a,a);	float bc = dot(b,c);	float cc = dot(c,c);
    float ab = dot(a,b);	float bb = dot(b,b);   	float cx = dot(c,x);
    float ac = dot(a,c);	float bx = dot(b,x);
    float ax = dot(a,x);
           
    // Cubic coefficients
    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;
    // Quadratic coefficients
	float qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;
    // Linear coefficients
    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;
    // Constant terms
    float C = 4.0*(ab + ax - aa - bx);
    vec3 roots;
    vec4 coeffs = vec4(cu, qu, li, C);
    
    int nS = SolveCubic(coeffs, roots);  
    float t;

   	float Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));
    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));
    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));
    
    return min(Dist3, min(Dist1, Dist2));
}

// Function 382
float Scene(vec3 p)
{
	p = rotateY(rotateZ(p, time*.5341), time);
 	vec2 q = vec2(lengthN(p.xy, 1.3+sin(time*1.234)*.7),p.z);
 	return lengthN(q-6.3, 12.95)+2.4*sin(time*1.321)-2.4;
}

// Function 383
float map(in vec2 p) {
    vec2 uv = p / 4.0 * vec2(iResolution.y / iResolution.x, 1.0) + 0.5;
    return texture(iChannel0, uv).r; // abs(p.x - p.y) - 0.15; // Example of an ambiguous case (with CELL_SIZE = 0.3)
}

// Function 384
vec4 traceScene(vec3 ro, vec3 rd, out int objid)
{
    float mt = 1e3;
    vec3 normal;
    
    objid = 0;
    
    // Floor object
    if(rd.y < 0.)
    {
    	float floort = (0. - ro.y) / rd.y;
        vec2 uv = ro.xz + rd.xz * floort;
        if(floort > 0. && floort < mt && abs(uv.x) < 15. && abs(uv.y) < 15.)
        {
            mt = floort;
            normal = vec3(0, 1, 0);
            objid = 1;
        }
    }
    
    vec4 res;
    float sc = .52;
    
    vec2 wineglass_box_is = box(ro, rd, vec3(-1.6, 0., -1.6), vec3(1.6, 10, 1.6));
    
    if(wineglass_box_is.x < wineglass_box_is.y)
    {
        // Wineglass (outer)
        res = traceSurface(float[10](2.5, .1, .1, .1, .1, 1.1, 1.6, 1.5, 1.2, 1.), ro, rd, 8);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = res.yzw;
            objid = 2;
        }


        // Wineglass (inner)
        res = traceSurface(float[10](0., 0., 0., 0., 0., 1., 1.5, 1.4, 1.1, .9), ro, rd, 8);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = -res.yzw;
            objid = 3;
        }


        // Glass wine surface
        {
            float t = (6. - ro.y) / rd.y;
            if(t > 1e-3 && t < mt)
            {
                vec3 p = ro + rd * t;
                if(length(p.xz) < 1.45)
                {
                    mt = t;
                    normal = vec3(0, -1, 0);
                    objid = 3;
                }
            }
        }
    }
    
    vec3 bottle_pos = vec3(6,0,-2);
    vec2 winebottle_box_is = box((ro - bottle_pos), rd, vec3(-2, 0., -2), vec3(2, 15, 2));

    if(winebottle_box_is.x < winebottle_box_is.y)
    {
        // Wine bottle (outer)

        res = traceSurface(float[10](.9, 1., 1., 1., 1., 1., .6, .3, .3, .3), (ro - bottle_pos)  * sc, rd * sc, 8);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = res.yzw;
            objid = 4;
        }

        // Wine bottle (inner)
        res = traceSurface(float[10](.9 - .1, 1. - .1, 1. - .1, 1. - .1, 1. - .1, 1. - .1,
                                     .6 - .1, .3 - .1, .3 - .1, .3 - .1), (ro - bottle_pos)  * sc, rd * sc, 8);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = -res.yzw;
            objid = 5;
        }
    }
    
    vec3 vase_pos = vec3(5, 0, 7);
    vec2 vase_box_is = box((ro - vase_pos), rd, vec3(-3.5, 0., -3.5), vec3(3.5, 12, 3.5));

    if(vase_box_is.x < vase_box_is.y)
    {
        float sc = .45;

        // Water vase (outer)
        res = traceSurface(float[10](.1, 1.5, 1.5, 1.5, .5, .5, 1.6, 0., 0., 0.),
                           (ro - vase_pos)  * sc, rd * sc, 5);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = res.yzw;
            objid = 6;
        }


        // Water vase (inner)
        res = traceSurface(float[10](.1 - .1, 1.5 - .1, 1.5 - .1, 1.5 - .1, .5 - .1, .5 - .1, 1.6 - .1, 0., 0., 0.),
                           (ro - vase_pos)  * sc, rd * sc, 5);
        if(res.x > 1e-3 && res.x < mt)
        {
            mt = res.x;
            normal = -res.yzw;
            objid = 7;
        }

        // Vase water surface
        {
            float t = (2. - ro.y) / rd.y;
            if(t > 1e-3 && t < mt)
            {
                vec3 p = ro + rd * t;
                if(length(p.xz - vase_pos.xz) < 1.4 / sc)
                {
                    mt = t;
                    normal = vec3(0, -1, 0);
                    objid = 7;
                }
            }
        }
    }
    

    return vec4(mt, normal);
}

// Function 385
float distanceToFloor(float floorHeight,vec3 point) {
	return(point.y-floorHeight);
}

// Function 386
float scene(vec3 p)
{
	return min(tunnel(p),ribbon(p));
}

// Function 387
V_3 sdf_i3d(
        /**/V_3 _1_
        ,   V_3 _2_
        ,   F32 f_p
        ){
            return( _1_ + ( ( _2_ - _1_ )*f_p ) );
        }

// Function 388
vec2 map_5( in vec3 pos ) { // scene + ro + screen + march steps
    vec2 res = map_2(pos);
    
    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );
    for( int i=0; i<intersections.length(); i++ ){
        if (i <= MAX_MARCH_STEPS) {
	    	res = opU( res, vec2( sdSphere( pos-intersections[i],.1), (i==MAX_MARCH_STEPS)?2.:3. ) );
        }
    }
    
    return res;
}

// Function 389
float map(vec3 p)
{        
    float rad = .1*sin(p.y*1.75) + ((p.y>-3.6)?smoothstep(-3.,-3.6,p.y)*0.35+2.95:2.4);
    float res = min(sdCappedCylinder(p+vec3(0.,6.,0.),vec2(rad,3.)),sdSH(p,1.));
     
    
    if(p.y<-3.4)
    {
  	  	for(int i=0;i<25;i++)
   		{
	    	float cs = cos(float(i)/12.0*PI);
   	    	float sn = sin(float(i)/12.0*PI); 

    		res = max(res,-sdCylinder(p+vec3(cs*(rad),0.,sn*(rad)),vec3(0.,.0,.2)));    
    	}
    }    
    return res;
}

// Function 390
vec2 sphereMap(vec3 pos, float rad)
{
    return vec2(atan(pos.z, pos.x), acos(pos.y / rad));
}

// Function 391
float map(vec3 p) {
    //float bob = 0.1 * sin(iTime);
    float d = distance(p, vec3(-1, bob1, -5)) - 1.;     // sphere at (-1,0,5) with radius 1
    d = min(d, distance(p, vec3(2, bob2, -3)) - 1.);    // second sphere
    d = min(d, distance(p, vec3(-2, bob3, -2)) - 1.);   // and another
    /*
    vec2 coord = (p.xz + vec2(2.0, 5.0)) * 0.1;
    vec4 water = texture(iChannel1, coord);
    float h2 = water.z > 0.0 ? 0.2 * water.z : 0.1 * water.x;
    d -= h2;
	*/
    //float x = texture(iChannel3, p.xz).g;
    
    // horizontal plane at y = -1
    d = min(d, p.y + waterDepth);
    
    /*
    d = min(d, p.x + cubeSize);
    d = min(d, p.x - cubeSize);
    d = min(d, p.y + cubeSize);
    d = min(d, p.y - cubeSize);
    d = min(d, p.z + cubeSize);
    d = min(d, p.z - cubeSize);
	*/
    //d = min(d, 1.0 + map2(p));
    // d = min(d, p.y - terrain(p));
    return d;
}

// Function 392
float dist(vec3 p)
{
	p.x+=iTime;
	vec3 p2 = p;
	p2.z+=iTime*.5;
	p.z-=iTime*.5;
	
	//p & mp first set of spheres
	//p2 & mp2 seconds set of spheres
	
	float e = 0.0;
	vec2 mp = mod(p.xz+vec2(2.0-e*.5,1.0),vec2(4.0-e,2.0))-vec2(2.0-e*.5,1.0);
	vec2 mp2 = mod(p2.xz+vec2(4.0-e*.5,2.0),vec2(4.0-e,2.0))-vec2(2.0-e*.5,1.0);
	//vec2 dp = p.xz-mp;
	
	p.xz = mp;
	p.y+=2.0;
	
	vec3 a = vec3(mp,p.y);
	vec3 b = vec3(mp2,p.y);

	return sqrt(min(dot(a,a),dot(b,b)))-1.0;
}

// Function 393
ComplexMatrix2 M_mapRealsToLine(Complex L, Complex c, Complex R)
{
    return M_mapTripleToTriple(
        Complex(-1, 0), Complex(0, 0), Complex(1, 0),
        L, c, R);
}

// Function 394
float map(vec3 p, vec3 d, inout vtx co)
{
    //find closest vertex
    findClosest(p, co, 5);
 	
    float DE = distance(co.X, p) - 0.001;
    float a = 1. + 0.15*clamp(dot(normalize(p - co.X), d), -1., 0.);
    
    //compute sdf in this direction to the vertex
    int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);
    vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 2)));
    for(int i = 0; i < 5; i++)
    {
        DE = min(DE, sdObjID( p, toI(nb, i)));
    }
    
    return min(a*DE, p.z+0.5);
}

// Function 395
vec2 map(vec3 pos)
{
    float jelly = map_jelly(pos);
    float container = map_container(pos);
    float rods = map_rods(pos);
    vec2 res = opU(vec2(jelly, JELLY_OBJ), vec2(container, CONTAINER_OBJ));
    res = opU(res, vec2(rods, RODS_OBJ));
    res = opU(res, map_slime(pos));
    return res;
}

// Function 396
float sdf_o(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));
    return t;
}

// Function 397
float DistanceFunc (in vec3 p)
{
    p *= c_scale;
    
    vec3 fp = floor(p);
    ivec3 cellPos = ivec3(fp);
   
    vec4 A = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,0))),
              DistanceFunc_(vec3(cellPos+ivec3(1,0,0))),
	 		  DistanceFunc_(vec3(cellPos+ivec3(0,1,0))),
	 		  DistanceFunc_(vec3(cellPos+ivec3(1,1,0))));

    vec4 B = vec4(DistanceFunc_(vec3(cellPos+ivec3(0,0,1))),
              DistanceFunc_(vec3(cellPos+ivec3(1,0,1))),
	 		  DistanceFunc_(vec3(cellPos+ivec3(0,1,1))),
	 		  DistanceFunc_(vec3(cellPos+ivec3(1,1,1))));
    
    return CubicLERP(A,B,p-fp);
}

// Function 398
vec2 map(in vec3 p)
{
    vec3 q = p;
    return opU(vec2(sdBox(p, vec3(2., .01, 2.)), 0.), mushroom(q-vec3(0.,.65,0.)));
}

// Function 399
float map (vec2 p)
{
    float t = fract(iTime/20.)*20.;
    float t2 = fract(iTime/20.)*20.;
    float a = npolySDF(.3, ceil(t/4. + 1.), iTime/8., p);
    float b = npolySDF(.3, ceil(t2/4. + 2.), iTime/8., p);
    float d = mix(a,b, smoothstep(.4,.6,fract(iTime/4.)))
     + sin(iTime*2.)*.05 - .05;
    return d;
}

// Function 400
vec2 GetDist(vec3 p) {
    vec2 dm = sdRepBox(p-vec3(0.0,0.0-1.9,0.0));
    return dm;
}

// Function 401
float scenef(bit3d_coordinate l) {
	bit3d_shape shape;
	shape.portal = l.portal;
	scene(shape, l);
	return shape.surface;
}

// Function 402
vec4 put_text_drawmap(vec4 col, vec2 uv, vec2 pos, float scale)
{
	float unit = asp * scale * 0.1;
    float h = 0.;
    vec2 sc = vec2(unit, unit*0.8);
    
    // S
    h = max(h, word_map(uv, pos, 83, sc));
    // h
    h = max(h, word_map(uv, pos+vec2(unit*0.4, 0.), 104, sc));
    // o
    h = max(h, word_map(uv, pos+vec2(unit*0.8, 0.), 111, sc));
    // w
    h = max(h, word_map(uv, pos+vec2(unit*1.2, 0.), 119, sc));
    // M
    h = max(h, word_map(uv, pos+vec2(unit*2.0, 0.), 77, sc));
    // a
    h = max(h, word_map(uv, pos+vec2(unit*2.4, 0.), 97, sc));
    // p
    h = max(h, word_map(uv, pos+vec2(unit*2.8, 0.), 112, sc));
    
    
    col = mix(col, vec4(1.-vec3(h), 1.), h);
    
    return col;
}

// Function 403
float DistToLine(vec2 p, vec2 a, vec2 b)
{
 	vec2 pa = p - a;
    vec2 ba = b - a;
    
    float frac = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    
    return length(pa - (ba * frac));
}

// Function 404
vec3 jt_toneMap(vec3 x){
    float l = toLum(x);
    x = reinhard(x,l);
    float m = max(x.r,max(x.g,x.b));
    return min(lightAjust(x/m,m),x);
}

// Function 405
float map( in vec3 p ) {
    
	// folding input domain
    p = fold( p, 0.,    0.,  		   timedAngle( 6., 2., 0.25), false );
    p = fold( p, 0.,    0.,  		   timedAngle(10., 2., 0.25), true );
    p = fold( p, -0.25,  0., 		   timedAngle( 8., 2.,-0.25), false  );
    p = fold( p, -0.25,  0., 		   timedAngle(12., 2.,-0.25), true  );
    
    if( time < 6.  ) 
    	p = fold( p, -1.4, PI*0.25,  timedAngle( 4., 2., -0.8 ) , true );
    if( time < 4.  ) 
		p = fold( p, -1.4, -PI*0.25, timedAngle( 2., 2., -0.8 ) , false );
    
    // just one paper plane
    float d = sdBox( p, vec3( 1., PAPERHEIGHT, 1.4) );
    
    if( time >= 6.  ) { // clip the plane hack :(
        vec3 po = p + vec3( 1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );
        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );
    } 
    
    if( time >= 4.  ) { // clip the plane hack :(
        vec3 po = p + vec3( -1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );
        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );
    } 
    
	return d;
}

// Function 406
vec2 map_2( in vec3 pos ) { // scene + ro + screen
    vec2 res = map_0(pos);
            
    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );
    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));
    return res;
}

// Function 407
float distTorus(vec3 p, vec2 t)
{
  vec2 tpp = tPos;
  tpp.y *= sin(iTime * 0.3);
  vec2 q = vec2(length(p.xy - tpp) - t.x, p.z);
  return length(q - tPos) - t.y;
}

// Function 408
vec3 tonemapACES(in vec3 color) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
}

// Function 409
vec3 tonemapping(vec3 col) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((col*(a*col+b))/(col*(c*col+d)+e),0.,1.);
}

// Function 410
vec2 map(vec3 pos)
{
    //float roundness = .15;
  	//float rot = 1.;
	//vec2 k = vec2(0.0);
    //vec2 j = k-k;
    //float size = .5;
    
    //float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );
    //scale = 1.;
    
    vec2 x;
    //float iGlobalTim = iTime;
    vec3 p = vec3(pos.x, pos.y+0.2, pos.z);
    float d1;
    //Putting An Object:
    p = vec3(pos.x, pos.y+2., pos.z);
    #ifdef HIGHD
    p += fbm(p+iTime/4.)/4.;
    #endif
    #ifdef MEDIUMD
    p += texture(iChannel0, p.xz/16.+iTime/16.).r/8.;
    #endif
    x = vec2(sdPlane(p), 1.9);
    p = vec3(pos.x, pos.y+0.5, pos.z);
    //d1 = sdTorus(p, vec2(VoxelSize*8., VoxelSize));
    /*p = vec3(pos.x+21., pos.y+2.257+(sdPlane(p)/4.), pos.z-28.);
    p.xz *= rotate2d(32.);
    d1 = sdRoundBox(p, vec3(VoxelSize*32., VoxelSize*4., VoxelSize*56.), 0.05);
    x = blend(vec2(d1, 1.1), x, 0.11);*/
    /*
	p = vec3(pos.x-21., pos.y+2.257, pos.z-28.);
    p.xz *= rotate2d(15.);
    p += fbm(p)/4.;
    d1 = sdRoundBox(p, vec3(VoxelSize*3., VoxelSize*4., VoxelSize*6.), 0.05);
    x = blend(vec2(d1, 1.1), x, 0.11);
	*/
    p = vec3(pos.x-10., pos.y+2.257, pos.z-10.);
    p.xz *= rotate2d(-15.);
    p.xy *= rotate2d(0.01);
    p += fbm(p)/4.;
    d1 = sdRoundBox(p, vec3(VoxelSize*20., VoxelSize*4., VoxelSize*20.), 0.05);
    x = blend(vec2(d1, 1.1), x, 0.11);
    
    //p = vec3(pos.x-5., pos.y+2.257, pos.z+1.);
    //p.xy *= rotate2d(-15.);
    //p += fbm(p)/4.;
//d1 = sdHexPrism(p, vec2(VoxelSize*12.,VoxelSize*6.));
    //x = blend(vec2(d1, 1.1), x, 0.11);
    
    /*
    p = vec3(pos.x+8., pos.y+2.257, pos.z+10.);
    p.zy *= rotate2d(3.141592/2.);
    p += fbm(p)/4.;
    d1 = sdHexPrism(p, vec2(VoxelSize*18.,VoxelSize*30.));
    x = blend(vec2(d1, 1.1), x, 0.11);
*/


    return x;
    
}

// Function 411
vec2 mapTheWorld( vec3 currentRayPosition ){


  vec2 result;
    
  vec2 balloon = sdfBalloon( currentRayPosition );
  vec2 box     = sdfBox( currentRayPosition );
        
  result = whichThingAmICloserTo( balloon , box );
    
  return result;


}

// Function 412
float sdf_O(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    return t;
}

// Function 413
vec2 scene( vec3 pos )
{  
    vec3 cp = vec3( 2.0 );
    vec3 f = worley( pos - vec3(  0.0, 1.0,  0.0  ), cp );
    
    vec2 dm = computeVisibility( 
        vec2( sdPlane( pos ), 1.0 ),
        vec2( sdDisplacementSphere( pos - vec3( -5.0, 1.0, -2.0 ), f, cp, 0 ), 2.0 ) );
    
    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  -2.5, 1.0, -1.0 ), f, cp, 1 ), 3.0 ) );
    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  0.0, 1.0,  0.0 ), f, cp, 2 ), 4.0 ) );
    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 2.5, 1.0, -1.0 ), f, cp, 3 ), 3.0 ) );
    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 5.0, 1.0, -2.0 ), f, cp, 4 ), 2.0 ) );
    //vec2 dm = vec2( sdSphere( pos, 1.0 ), 1.0 );
    return dm;
}

// Function 414
void scene2D( out vec4 fragColor, in vec2 fragCoord )
{
     // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;
	vec2 muv = iMouse.xy/iResolution.xy;
   	vec4 map = texture(iChannel1, uv);
    // Output to screen
    
    float mode = get_ctrl_mode(iChannel1);
    float radius = get_radius(iChannel1);
    vec3 pickRGB = get_color(iChannel1);
    float is_ui = get_ui(iChannel1);
    float override = get_override(iChannel1);
    //float shape = get_shape(iChannel1);
    float blend = get_blend_factor(iChannel1);
    float gradient_func = get_gradient_func(iChannel1);
    float brush = get_brush_type(iChannel1);
    vec4 texParams = get_texture_params(iChannel1);
    float texIdx = texParams.w;
    float stexIdx = texParams.z;
    float texAlpha = texParams.x;
    //float defaultCol = get_default_draw_color(iChannel1);
    float mainMenuVal = get_main_menu_val(iChannel1);
    float stars = get_stars(iChannel1);
    bool hide_ui = get_hide_ui(iChannel1);
    
    float col_block = get_color_block(iChannel1);
    
    float m_in_mode = iMouse.w*float(in_zone(muv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, 1.));
    
    int   menu_option = getIValue(mainMenuVal, MENU_OPT_NUM);
    
    vec4 appl_button = verticalRadioButton(uv, SELECTION_MODE_MIN, SELECTION_MODE_MAX, mode, 5.);
    vec4 rad_slider = slider(uv, SELECTION_RADIUS_MIN, SELECTION_RADIUS_MAX, 1., radius);
    vec4 col_a_slider = slider(uv, SELECTION_COLOR_A_MIN, SELECTION_COLOR_A_MAX, 1., pickRGB.r);
    vec4 col_b_slider = slider(uv, SELECTION_COLOR_B_MIN, SELECTION_COLOR_B_MAX, 1., pickRGB.g);
    vec4 col_c_slider = slider(uv, SELECTION_COLOR_C_MIN, SELECTION_COLOR_C_MAX, 1., pickRGB.b);
    vec4 override_button = verticalRadioButton(uv, SELECTION_OVERRIDE_MIN, SELECTION_OVERRIDE_MAX, override, BLEND_OPER_NUM);
    //vec4 shape_button = verticalRadioButton(uv, SELECTION_SHAPE_MIN, SELECTION_SHAPE_MAX, shape, 2.);
    vec4 blend_factor = slider(uv, SELECTION_BLEND_FACTOR_MIN, SELECTION_BLEND_FACTOR_MAX, 1., blend);
    vec4 fade_button = verticalRadioButton(uv, SELECTION_FADE_MIN, SELECTION_FADE_MAX, gradient_func, 7.);
    vec4 brush_button = slider(uv, SELECTION_BRUSH_MIN, SELECTION_BRUSH_MAX, 1., brush);
    vec4 texture_selection = verticalRadioButton(uv, SELECTION_TEXTURE_MIN, SELECTION_TEXTURE_MAX, texIdx, TEXTURES_NUM);
    vec4 secondary_texture_select = verticalRadioButton(uv, SELECTION_SECONDARY_TEXTURE_MIN, SELECTION_SECONDARY_TEXTURE_MAX, stexIdx, TEXTURES_NUM);
    vec4 tex_alpha_select = slider(uv, SELECTION_TEXTURE_ALPHA_MIN, SELECTION_TEXTURE_ALPHA_MAX, 1., texAlpha);
    vec4 main_menu_select = mainMenuButton(uv, SELECTION_MAIN_MENU_MIN, SELECTION_MAIN_MENU_MAX, mainMenuVal, 4.);
    vec4 stars_select = horizontalRadioButton(uv, SELECTION_STARS_MIN, SELECTION_STARS_MAX, stars, 2.);
    vec4 func_color = functionPlot(uv, vec2(0.02, 0.15), vec2(0.14, 0.32), gradient_func);
    vec4 hide_b_color = checkButton(uv, SELECTION_HIDE_UI_MIN, SELECTION_HIDE_UI_MAX, hide_ui);
   	vec4 load_tex_color = checkButton(uv, SELECTION_LOAD_TEXTURE_MIN, SELECTION_LOAD_TEXTURE_MAX, get_load_texture(iChannel1));
    //vec4 def_tex_color = horizontalRadioButton(uv, SELECTION_DEF_DRAW_COLOR_MIN, SELECTION_DEF_DRAW_COLOR_MAX, defaultCol, 2.);
    vec4 col_block_color = verticalRadioButton(uv, SELECTION_COLOR_BLOCK_MIN, SELECTION_COLOR_BLOCK_MAX, col_block, 2.);
    
    // text
    vec4 tcol;
    
    vec2 minMain, maxMain, minSecond, maxSecond;
    
    float i_main = getTextureIndex(texIdx);
    float i_second = getTextureIndex(stexIdx);
    
    getTexBBox(i_main, minMain, maxMain);
    getTexBBox(i_second, minSecond, maxSecond);
    
    vec4 fromUv = vec4(0., 0., 1., 1.);
   	vec4 toUv = vec4(minMain, maxMain);
    vec2 tuv = convertUv(uv, fromUv, toUv);
    
    vec4 stoUv = vec4(minSecond, maxSecond);
    vec2 stuv = convertUv(uv, fromUv, stoUv);

    vec3 col;
    vec3 sccol;
    vec3 main = texture(iChannel2, tuv).xyz;
    vec3 secondary = texture(iChannel2, stuv).xyz;
    
    if (int(i_main) != int(i_second))
    {
        sccol = mix(secondary, main, texAlpha);
    }
    else
    {
        sccol = main;
    }
    
    if (in_zone(mode, APPL_3D) || (in_zone(mode, APPL_UI) && menu_option == MENU_OPT_3D))
    {
        vec4 col3D;
        vec4 status;
        status.x = 1. - stars;
        scene3D(col3D, fragCoord, status);
        sccol = col3D.xyz;
    }
    else if (in_zone(mode, APPL_TEXTURES))
    {
        sccol = texture(iChannel2, uv).xyz;
    }
    
    if (in_zone(mode, APPL_UI) && uv.x <= SELECTION_MAIN_MENU_MAX.x + 0.015)
    {
        col = mix(vec3(0.132), sccol, 0.25);
    }
    else
    {
        col = sccol;
    }
    
    if (hide_ui == false)
    {
        vec3 grad_col_a_slider = mix(col_a_slider.zxx, col_a_slider.zzz, float(int(i_main) != DIFFUSE_MAP));
        vec3 grad_col_b_slider = mix(col_b_slider.xzx, col_b_slider.zzz, float(int(i_main) != DIFFUSE_MAP));
        vec3 slideCol; // color of sliders;
        
        col = mix(col, appl_button.xyz, appl_button.w);
        col = mix(col, vec3(0.7, 0.6, 0.1)*rad_slider.x + rad_slider.zzz, 
                  float(menu_option == MENU_OPT_TOOLS) * is_ui*rad_slider.w);
        col = mix(col, grad_col_a_slider, float(menu_option == MENU_OPT_COLOR) * is_ui*col_a_slider.w);
        col = mix(col, grad_col_b_slider, float(menu_option == MENU_OPT_COLOR) * is_ui*col_b_slider.w * float(int(i_main) == DIFFUSE_MAP));
        col = mix(col, col_c_slider.xxz, float(menu_option == MENU_OPT_COLOR) * is_ui*col_c_slider.w * float(int(i_main) == DIFFUSE_MAP));
        col = mix(col, override_button.z*vec3(.9, .6, .1), float(menu_option == MENU_OPT_TOOLS) * is_ui*override_button.w);
        //col = mix(col, shape_button.xyz, float(menu_option == MENU_OPT_TOOLS) * is_ui*shape_button.w);
        col = mix(col, vec3(0.1, 0.8, 0.5)*blend_factor.x + vec3(0.9, .1, 0.3)*blend_factor.z, 
                  float(menu_option == MENU_OPT_TOOLS) * is_ui*blend_factor.w);
        col = mix(col, fade_button.z*vec3(.05, .23, .45), float(menu_option == MENU_OPT_TOOLS) * is_ui*fade_button.w);
        col = mix(col, brush_button.xzz, float(menu_option == MENU_OPT_TOOLS) * is_ui*brush_button.w);
        col = mix(col, texture_selection.yzx, float(menu_option == MENU_OPT_TEXTURE) * is_ui*texture_selection.w);
        col = mix(col, secondary_texture_select.zxx, float(menu_option == MENU_OPT_TEXTURE) * is_ui*secondary_texture_select.w);
        col = mix(col, vec3(0.3, 0.7, 0.9)*tex_alpha_select.x + tex_alpha_select.zxz, float(menu_option == MENU_OPT_TEXTURE) * is_ui*tex_alpha_select.w);
        col = mix(col, func_color.zzx, float(menu_option == MENU_OPT_TOOLS) * is_ui*func_color.w);
        col = mix(col, 
                  main_menu_select.x*vec3(0.15) +
                  main_menu_select.y*vec3(0.1) +
                  main_menu_select.z*vec3(0.51, 0.5, 0.52) +
                  main_menu_select.z*main_menu_select.w*vec3(.41, -0.33, -0.46), is_ui*(main_menu_select.x + main_menu_select.y));

        col = mix(col, stars_select.xyz, is_ui*float(menu_option == MENU_OPT_3D)*stars_select.w);
        col = mix(col, hide_b_color.yyy, float(in_zone(mode, APPL_TEXTURES)) * hide_b_color.w), 
		col = mix(col, load_tex_color.xxx*.11 - load_tex_color.zzz*.15 + load_tex_color.yyy,
                  is_ui*float(menu_option == MENU_OPT_TEXTURE)*load_tex_color.w);
       // col = mix(col, step(.5, defaultCol)*def_tex_color.zzz + def_tex_color.yyy, is_ui*float(menu_option == MENU_OPT_COLOR) * def_tex_color.w);
        col = mix(col, col_block_color.xyz, float(menu_option == MENU_OPT_TOOLS) * is_ui * col_block_color.w * float(int(i_main) != int(i_second)));
        
        tcol += drawMode(uv, mode);
        tcol += drawOperation(uv, override);
        tcol += drawTextureValues(uv, mode, menu_option, vec2(texIdx, stexIdx));
        tcol += drawSliderText(uv, mode, menu_option, int(i_main));
        tcol += drawRelativeToSecondary(uv, bool(is_ui) && menu_option == MENU_OPT_TOOLS && int(i_main) != int(i_second) && col_block > 0.5);
        vec4 rcol = drawRadius(uv, mode, radius, pickRGB, brush, gradient_func);
        col = mix(col, rcol.xyz, rcol.w);

        if (m_in_mode < 0.5)
        {
            col += drawModeRadius(uv, mode, radius).xyz;
        }
        
        col += tcol.xyz;
    }

    col = clamp(col, 0., 1.);
    
    fragColor = vec4(col,1.0);
}

// Function 415
vec2 scene_reed(vec3 _p, float depth, float o, float t)
{
    _p = opCheapBend(_p, -.08*(.5*(1.+sin(10.*t)))+o);
    float d = (sdVerticalCapsule( _p, 1.5, 0.01 ));
 	return vec2(d, MATERIAL_REED);
}

// Function 416
float distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3, float dz, out vec2 uv)
{
    float d = 10000.0;
    float rnd =getRand01Sph(p1+p2+p3).x;
    float rnd2=getRand01Sph(p1+p2+p3).y;
    // random rotation of torus-start-edges
    /*if      (rnd>.75) { vec3 d=p1; p1=p2; p2=d; }
    else if (rnd>.50) { vec3 d=p1; p1=p3; p3=d; }
    else if (rnd>.25) { vec3 d=p2; p2=p3; p3=d; }*/

    if(dot(cross(p2-p1,p3-p1),p1)>0.) { vec3 dummy=p2; p2=p3; p3=dummy; }
    
    vec3 p4 = p1*(1.-dz);
    vec3 p5 = p2*(1.-dz);
    vec3 p6 = p3*(1.-dz);
    
    float r,r1,r2,fact,ang,fullAng;
    vec3 n = normalize(cross(p2-p1,p3-p1));
    // point to normal distance on triangle
    vec3 pos2 = pos-dot(pos-p1,n)*n;
    
    // torus segments:
    // actually i have to fade from one torus into another
    // because not all triangles are equilateral
    float angRad=0., factTan=0.;
    vec3 v1,v2,v3,v4,v5,v6;
    for(int i=0; i<3 ;i++)
    {
        if(i==0) { v1=p1; v2=p2; v3=p3; v4=p4; v5=p5; v6=p6; }
        if(i==1) { v1=p2; v2=p3; v3=p1; v4=p5; v5=p6; v6=p4; }
        if(i==2) { v1=p3; v2=p1; v3=p2; v4=p6; v5=p4; v6=p5; }
        float rndv1=getRand01Sph(v1).x;
        float rndv2=getRand01Sph(v2).x;
        float rndv3=getRand01Sph(v3).x;
        
        // v1 is always the center axis of the torus
        // some circles randomly cw/ccw
        if(rndv1>0.5)
        {
            vec3 dummy;
            dummy=v2; v2=v3; v3=dummy;
            dummy=v5; v5=v6; v6=dummy;
        }

        // logic xor ^^ wont work on all platforms so using (integer sum)&1
        // start of arc
        float up1=mod(float(1
         + ((rndv1>0.5)?1:0)  // put cw up and ccw down
         + ((rndv1>0.5 && rndv3>0.5 && rndv1>rndv3)?1:0) // from cw take the one down that has the smaller randvalue in its center (unique)
         + ((rndv1<0.5 && rndv2<0.5 && rndv1>rndv2)?1:0) // from ccw take the one up that has the smaller randvalue in its center (unique)
         + ((rndv1<0.5 && rndv2>0.5)?1:0)                // xchg the ones who meet from different rot dirs (one cw other ccw)
         + ((rndv1>0.5 && rndv3<0.5)?1:0)                // xchg the ones who meet from different rot dirs (one cw other ccw)
         ),2.);
        
        // end of arc
        float up2=mod(float(1
         + ((rndv1>0.5)?1:0)  // put cw up and ccw down
         + ((rndv1>0.5 && rndv2>0.5 && rndv1>rndv2)?1:0) // from cw take the one down that has the smaller randvalue in its center (unique)
         + ((rndv1<0.5 && rndv3<0.5 && rndv1>rndv3)?1:0) // from ccw take the one up that has the smaller randvalue in its center (unique)
         ),2.);
        
        
        vec3 n = normalize(cross(v2-v1,v3-v1));
        vec3 pos2 = pos-dot(pos-v1,n)*n;
    	ang = calcAngle(cross(pos,v1),cross(v2,v1));
    	fullAng = calcAngle(cross(v3,v1),cross(v2,v1));
    	fact = ang/fullAng;
        float factUD = mix(up1,up2,fact);
        /*if(rnd2>.25) {
            if(i==0) factUD=1.;
            if(i==1) factUD=0.;
        }*/
    	r1 = .5*mix(length(v2-v1),length(v5-v4),up1);
    	r2 = .5*mix(length(v3-v1),length(v6-v4),up2);
    	vec3 posS=mix(.5*(v2+v1),.5*(v5+v4),up1);
    	vec3 posE=mix(.5*(v3+v1),.5*(v6+v4),up2);
    	vec3 posSPrj=dot(posS,normalize(v1))*normalize(v1);
    	vec3 posEPrj=dot(posE,normalize(v1))*normalize(v1);
        /*if(rndv1>0.5)
        {
            vec3 dummy;
            dummy=posS;    posS=posE;       posE=dummy;
            dummy=posSPrj; posSPrj=posEPrj; posEPrj=dummy;
        }*/
    	//r1 = length(posS-posSPrj);
    	//r2 = length(posE-posEPrj);
    	r=mix(r1,r2,fact);
    	//r=r1;
        float ang2;
        float dold=d;
		//d=min(d,distTorus(pos-mixSq(v1,v4,factUD)*sqrt(1.-r*r),r,.11*r,v1,ang2));
		// the factor factUD/3.2 is kind of phenomenological (tuned it by hand -
		// ...didnt quite find the time to make a theoretical aproach)
		d=min(d,distTorus((pos-mixSq(v1,v4,factUD)*sqrt(1.-r*r))*(1.-dz*factUD/3.2),r,.11*r,v1,ang2));
		//d=min(d,distTorus(pos-mixSq(posSPrj,posEPrj,fact),r1,.11*r1,v1,ang2));
		if(rndv1>0.) ang2=2.*PI-ang2;
		// rotate radial angle to point outwards (radial to the whole structure) so that uv's match between segments
		// ...again the angle (=58.) was determined by hand - a theoretical approach would be nice, 
		// because this way it only works only for the icosahedron, not for higher subdivisions
		ang2=mod(ang2+58.*PI/180.+10.*PI,2.*PI);
		// we mirror the radial uv (might be a bit more complicated to get a full circle uv here)
		if(ang2>PI) ang2=2.*PI-ang2;
		angRad =(d!=dold)?ang2:angRad;
		factTan=(d!=dold)?fact:factTan;
        //d-=(tri01(ang*50.*.25)+tri01(ang2*12.*.25))*.004*r;
    }
    uv=vec2(factTan,fract(angRad/PI));
    // snake skin pattern
    #ifdef SNAKE_SKIN
    #ifndef UV_ONLY
    d-=(abs(sin((factTan*20.+.3*20.*iTime)*2.*PI)+cos(angRad*12.)))*.0015*r;
    #endif
    #endif
    return d;
}

// Function 417
float scene(vec3 p) {
    if (length(p) > 1.) return length(p)-.8;
vec4 f0_0=sin(p.y*vec4(.1092,-.7487,-.3145,2.0425)+p.z*vec4(-1.1557,-3.8362,.4454,3.7463)+p.x*vec4(-.1078,-1.2005,.3838,.3697)+vec4(-2.6188,-4.4628,-1.6874,-6.2460));
vec4 f0_1=sin(p.y*vec4(2.8164,-1.6708,-3.8982,-1.2813)+p.z*vec4(3.6428,4.3387,-3.5679,-2.0770)+p.x*vec4(3.2024,.6757,.2961,-3.3966)+vec4(-1.6055,-4.8136,-3.4581,5.1315));
vec4 f0_2=sin(p.y*vec4(4.5015,-1.7450,4.4780,-1.3733)+p.z*vec4(1.6196,1.6529,-2.1594,2.5309)+p.x*vec4(3.1566,2.2963,4.6800,-2.6905)+vec4(1.3524,3.2559,4.9643,1.2707));
vec4 f0_3=sin(p.y*vec4(2.9692,1.9674,.2758,-3.0875)+p.z*vec4(.2048,-2.6904,2.4808,-.3322)+p.x*vec4(-.1545,-2.8370,-3.2862,-1.0485)+vec4(-5.3331,-2.0173,-2.1306,-2.2581));
vec4 f0_4=sin(p.y*vec4(.2801,3.1750,1.9983,-.6504)+p.z*vec4(-3.4846,4.2435,-2.6852,2.9521)+p.x*vec4(.2830,.6538,1.4488,-3.5361)+vec4(3.2712,4.3837,-3.7523,-5.9050));
vec4 f0_5=sin(p.y*vec4(1.5156,.8251,-3.7127,4.3026)+p.z*vec4(1.5247,-2.8745,1.3346,.4280)+p.x*vec4(-.5255,-.9554,2.6246,2.3955)+vec4(-3.5040,-3.3669,3.3133,-1.6692));
vec4 f0_6=sin(p.y*vec4(3.8214,1.9387,-3.9698,-3.6987)+p.z*vec4(-1.1331,-.7003,-3.3304,.8020)+p.x*vec4(-2.0487,4.0014,3.8898,-1.3204)+vec4(7.2148,-7.4848,-4.8330,3.7660));
vec4 f0_7=sin(p.y*vec4(-2.1693,.1222,2.7208,1.1521)+p.z*vec4(3.1330,2.0367,.6314,1.7677)+p.x*vec4(3.6626,-4.0452,-3.8386,2.6906)+vec4(3.7536,-1.6404,-3.3159,5.1378));
vec4 f1_0=sin(mat4(-.0934,-.1321,.1311,.3430,.0609,-.1446,.1960,-.2395,.4618,-.1530,.0753,.5231,-.0849,-.2256,-.0453,.3310)*f0_0+
    mat4(-.0021,.1751,.1124,.4126,.0447,-.2162,-.3264,-.0713,.1542,.1023,-.1984,.2524,.2163,-.1956,.0450,-.2194)*f0_1+
    mat4(-.2299,.0495,-.1112,-.2321,.3471,-.1658,.2008,-.3290,-.0068,.0278,-.4366,-.1483,.1057,.2634,.1433,-.1973)*f0_2+
    mat4(-.1318,.1920,.3427,.3366,.0716,-.3128,-.0697,.4434,.1608,.2227,.3934,-.2151,.0034,.2298,-.0156,-.1826)*f0_3+
    mat4(.2363,.2496,.5539,.3959,.2436,.4798,.0566,-.0174,-.1434,.3167,.3002,.3567,.5419,.2511,.2545,.0431)*f0_4+
    mat4(.0972,.4349,-.3668,-.0428,.0575,-.2601,.0436,-.0504,-.2617,-.2466,-.0569,.1403,-.1538,.1846,.0230,-.7905)*f0_5+
    mat4(.2717,.1939,.0817,.3303,.1663,-.4076,.1389,-.2333,.1979,-.1859,-.0204,-.2133,-.3463,-.0463,.3258,.2277)*f0_6+
    mat4(.3549,.1179,-.0725,.0558,-.3282,-.3345,-.1642,-.0879,.0524,.0110,.1236,.6130,-.0872,-.3758,.1223,.0189)*f0_7+
    vec4(.2388,1.9781,-.1326,-1.0604))/1.00+f0_0;
vec4 f1_1=sin(mat4(-.2932,.0451,.0494,-.0486,.0732,.2343,.1352,-.0198,-.1335,.1046,-.1242,-.0997,-.4383,.0821,-.1328,.0585)*f0_0+
    mat4(.0545,.1238,-.2811,.0986,-.3478,-.0319,.2516,-.0405,.1403,.3401,-.0169,-.2229,-.1080,.2194,-.2530,.2007)*f0_1+
    mat4(.0515,.1422,.0102,-.1845,.2952,.4669,-.0000,.0824,.0007,.0192,.1869,.0445,-.1476,-.2739,-.5803,.2401)*f0_2+
    mat4(.2994,-.0397,.1641,-.0096,-.4417,-.0117,-.1132,-.0076,-.2786,-.2076,.1435,.0841,-.2899,.1607,.3819,.2646)*f0_3+
    mat4(-.5137,.0840,-.3384,.1024,.4198,.1865,.2015,-.1186,.0881,.2643,-.3897,.3309,-.0717,.1203,-.3314,.3403)*f0_4+
    mat4(.2194,.0201,-.2843,-.2713,-.0591,.2572,-.1345,.2762,-.2773,-.1474,-.1270,-.0191,-.1730,.2925,.3167,.2298)*f0_5+
    mat4(.1365,.0811,-.0534,.3265,-.5876,.2629,.2386,.3225,-.4695,.4592,-.1618,.0039,.1974,.1793,.1924,-.1282)*f0_6+
    mat4(-.3755,-.6696,.1087,-.2952,-.2505,-.4240,.1782,.2847,.2719,-.2773,.2565,-.5038,-.1304,.0722,-.0448,-.0685)*f0_7+
    vec4(-2.2740,1.4383,.1442,-2.0410))/1.00+f0_1;
vec4 f1_2=sin(mat4(.1033,.2406,.2861,.0521,-.2352,-.2274,-.3890,.3208,-.0282,-.1254,.2446,.0209,.0307,.1077,.4498,-.1085)*f0_0+
    mat4(.3988,-.2359,.2063,-.2263,.2061,-.2878,-.0959,.1838,-.0283,-.3399,.0864,.2279,-.4467,.2740,-.5571,.2184)*f0_1+
    mat4(-.0378,-.0005,-.0397,-.3042,-.2388,-.3041,.2866,-.1304,.4693,-.2517,.4689,.2009,-.0928,.2362,.1011,.3387)*f0_2+
    mat4(.1668,-.1409,.1247,-.3595,-.1071,-.0129,-.0132,.0029,-.1461,-.1029,.0719,.0708,-.0175,.0565,.3968,.1348)*f0_3+
    mat4(-.0179,.0218,.1020,-.1638,.2006,-.2602,.3527,.4315,-.0546,.2688,.1032,.0777,.4574,-.1600,-.2421,-.4365)*f0_4+
    mat4(.2042,-.2131,-.4816,.1556,-.2700,.1252,.0825,-.0154,.2409,-.1213,.6356,.1989,-.2966,.3006,-.1809,.1622)*f0_5+
    mat4(.2345,.0100,.3430,.0306,.2308,.1301,.2328,.2321,-.3767,.0299,-.2849,.2045,.4039,-.0542,.0666,.1177)*f0_6+
    mat4(.4448,-.1643,.0388,-.1001,.5765,-.0438,.4452,-.3100,.7494,-.2194,.0715,.1881,-.0322,.2635,-.0357,.0748)*f0_7+
    vec4(-.7773,1.2396,-.3497,1.2757))/1.00+f0_2;
vec4 f1_3=sin(mat4(.3510,.3383,-.2777,-.1389,.0694,-.1372,-.1622,.0486,-.0640,.4514,-.1131,.0924,.2453,-.0800,-.1341,.0512)*f0_0+
    mat4(.3245,-.2268,-.1605,-.3458,-.1793,-.1092,-.0625,-.2240,.0526,-.1333,-.1015,-.1291,.2782,.3941,-.0475,-.2889)*f0_1+
    mat4(.2551,-.0574,.2290,.2013,.5053,-.1687,.1171,-.2891,-.0041,-.0081,.0258,-.2379,-.2823,.0104,-.0012,.2064)*f0_2+
    mat4(.2676,.0364,.3279,-.4058,-.1793,-.1067,.0881,-.0175,.0655,-.0375,-.2510,-.1476,.0382,-.4236,-.1005,.0967)*f0_3+
    mat4(.2776,-.0916,-.5421,-.1234,-.1943,.1273,.0837,.0335,-.1464,.2822,.0550,.0821,-.3237,-.2094,.2695,-.1833)*f0_4+
    mat4(-.4761,.0742,-.2680,.8828,.3887,.1906,-.2085,.1108,.3904,.0031,.3813,.4271,-.0258,-.2299,-.2563,.4208)*f0_5+
    mat4(-.2035,-.1005,-.0747,-.6706,-.2610,-.5596,-.4047,.1058,-.0179,-.3303,-.1957,-.1869,-.3556,-.6029,-.0359,-.0118)*f0_6+
    mat4(.0291,-.1114,.0191,.0984,.3647,.0793,.3472,-.1353,.0100,-.2198,-.1690,-.3072,-.1947,.1001,-.2900,.1721)*f0_7+
    vec4(1.9116,1.0750,-.4068,-2.1228))/1.00+f0_3;
vec4 f1_4=sin(mat4(-.2296,-.3272,.0211,-.1144,.0147,-.1395,.3283,-.2611,-.3142,-.1718,.0757,.0973,-.0405,-.0559,-.2664,-.0185)*f0_0+
    mat4(-.1901,.0103,-.3291,.2704,.2102,-.1912,.1882,-.0950,-.3494,.0954,-.1380,-.1726,-.1069,.2222,-.3178,.4209)*f0_1+
    mat4(-.1783,-.1467,.1041,-.2225,.3571,.0110,-.2747,.3191,.2233,.1376,-.3836,.1693,.0710,-.2117,.0627,.1336)*f0_2+
    mat4(-.1069,-.0622,-.0013,-.6153,-.4794,.1899,-.2955,-.0942,-.0920,.1060,-.1774,-.4969,-.1224,.2979,-.1096,-.0073)*f0_3+
    mat4(-.1983,.2243,-.2938,-.2014,-.0267,-.1167,-.0515,-.0903,-.1190,.0716,.1112,.0968,.2247,.2606,-.5354,.4380)*f0_4+
    mat4(-.1709,-.2402,.0879,-.0001,-.3353,.2954,.4218,-.3403,-.1442,-.1252,-.1978,-.0735,.0740,-.1911,.2151,.5266)*f0_5+
    mat4(.0871,-.0291,-.3506,-.0252,.3055,.3880,-.1328,-.0669,-.4279,-.2595,-.2460,.3071,.0380,-.1753,-.2905,-.2441)*f0_6+
    mat4(.0161,.0680,-.1726,.2151,.7725,-.0405,.1366,-.0519,-.4706,-.0252,-.2557,.0661,-.1236,.2125,-.2438,-.5259)*f0_7+
    vec4(1.4475,.6085,-.5514,.1777))/1.00+f0_4;
vec4 f1_5=sin(mat4(.0205,-.0183,.1328,-.1067,-.5483,.1628,.2634,.0808,-.1189,.3466,-.0042,-.3868,.1520,.1052,-.1507,-.1669)*f0_0+
    mat4(-.0913,-.1991,-.0897,-.1785,-.3816,.0086,-.1041,-.2664,.2038,-.1269,.0704,.1203,.2697,-.1339,.2788,-.2456)*f0_1+
    mat4(-.0413,.1183,.1240,.3050,.3495,-.4988,.7434,-.0311,.0183,-.0108,.0140,-.3839,-.1642,.3231,-.0456,.0542)*f0_2+
    mat4(-.0267,.0817,.4499,.1539,.3526,.0784,.1238,-.1910,.0390,.1609,-.0284,-.0554,-.0239,-.1441,.2604,.3880)*f0_3+
    mat4(.1047,.0922,-.0668,-.0725,.0188,.0946,-.0638,-.1070,-.0433,.0320,-.0546,.2112,.1082,-.1656,.0979,-.0051)*f0_4+
    mat4(-.1296,-.2415,.0001,.0746,-.1099,.2417,.1975,-.1401,-.0810,-.2079,.3166,-.1772,.1303,.0955,-.2343,.6816)*f0_5+
    mat4(.2971,.1991,-.0163,-.3062,-.0119,-.1572,-.3243,.4315,-.1137,-.0583,.3693,.0568,-.0138,-.0406,.3020,.3069)*f0_6+
    mat4(.0061,-.0348,-.0111,.1863,.1949,-.1910,-.1509,-.1075,.1820,.1141,-.0766,-.4091,-.0499,-.1988,-.0794,-.2755)*f0_7+
    vec4(.9340,-.8766,-1.1458,-1.5558))/1.00+f0_5;
vec4 f1_6=sin(mat4(.1207,.2592,.4301,.2096,.0400,.0310,.2325,-.5025,.2225,-.2925,.3733,-.1440,.3582,-.0787,-.1809,.1871)*f0_0+
    mat4(-.2288,-.3594,-.0212,.0366,.1425,-.0255,-.0265,-.1448,-.2615,-.3525,.2919,-.1416,-.2559,.4709,.3257,.0270)*f0_1+
    mat4(-.1922,-.6488,-.1464,.0779,-.2115,.2322,.2027,-.1216,-.0704,.2799,.3047,-.1303,-.1109,-.0162,.0902,.4393)*f0_2+
    mat4(.2565,.0662,.2153,-.1111,-.2404,.6380,.1597,-.2127,.1301,-.0994,.1059,-.3312,.4630,-.0148,-.0967,-.4474)*f0_3+
    mat4(-.1679,-.2165,-.0095,.1261,-.0706,-.1625,-.2325,-.4460,.2835,-.1769,-.2335,.1866,-.2963,-.3007,-.4882,.1966)*f0_4+
    mat4(-.1252,-.2666,.0778,-.2164,.1340,-.0982,.1527,-.1778,.1103,.6122,.5330,-.0621,.0978,-.1899,-.6111,-.0816)*f0_5+
    mat4(-.5425,-.1223,.3745,-.0710,.4646,-.3335,-.1014,-.0799,.1193,-.1399,-.3193,.3637,.3569,.3373,.1963,.2066)*f0_6+
    mat4(-.1182,-.0178,.1120,-.3647,.1216,-.2405,.1054,-.0741,-.1793,.1629,.0632,-.6340,.0972,.0452,.1786,-.0195)*f0_7+
    vec4(-1.4663,2.4973,1.4860,-1.6765))/1.00+f0_6;
vec4 f1_7=sin(mat4(.1914,-.3903,.1680,-.0505,.1929,.1026,.0456,-.1042,.0837,.3249,.3369,-.2963,-.2506,.3420,.0906,.2226)*f0_0+
    mat4(-.0060,-.3297,.3163,-.1330,-.3632,-.2987,.2399,.0639,-.1292,-.0474,-.1969,-.0085,-.1041,.4037,.2398,-.0016)*f0_1+
    mat4(.1100,-.1501,.1212,-.1309,-.3860,.2001,.0276,.0156,.0962,-.0614,.0094,.2834,-.3096,-.0437,.1198,-.0023)*f0_2+
    mat4(-.0090,.1006,.1413,.2542,.4481,-.0426,.5269,-.2917,.1837,-.0052,.1379,.1787,-.2482,-.1742,-.2475,-.0576)*f0_3+
    mat4(-.2082,-.0015,-.0807,-.1833,.0108,.2608,.0197,-.1061,-.2986,-.1271,.1388,.1702,.0275,.3765,-.2614,.0512)*f0_4+
    mat4(-.1558,-.1395,.0482,-.5358,.2387,.3506,.0410,-.1838,.0609,.0232,.1573,-.1898,-.2027,.1205,.0405,.2675)*f0_5+
    mat4(-.4114,.1523,-.2689,.6871,.1781,-.0021,-.3350,.4177,.0637,-.3082,-.1686,-.2570,.2995,.1335,.1208,-.0002)*f0_6+
    mat4(.1386,.0613,-.0328,-.2808,-.1560,.2993,-.0253,.1052,.3197,-.2069,.3371,-.1767,-.1485,-.0106,.2229,.1204)*f0_7+
    vec4(.7439,-.0478,1.8581,-.1715))/1.00+f0_7;
vec4 f2_0=sin(mat4(.4182,.1332,.1456,.3590,-.1229,-.4860,.0381,-.3463,-.1867,-.2296,.4237,.4578,-.1803,.2436,-.1069,-.7139)*f1_0+
    mat4(.0522,.0579,-.4002,-.3063,-.1776,-.2811,-.1020,.1971,.1945,-.0758,.3065,-.2684,.4463,-.1295,.1526,.4071)*f1_1+
    mat4(-.2210,.3157,-.3217,-.3122,.0306,.2667,.0082,-.0151,.0371,.2884,.1209,-.1305,.0622,-.6592,.1946,.0397)*f1_2+
    mat4(-.3252,.1867,-.1001,-.1372,.0315,-.5640,.0388,.0815,-.2083,.3387,-.4508,.1312,-.4947,-.0399,-.3036,.1720)*f1_3+
    mat4(-.5676,.2780,-.3098,-.5403,-.2186,-.2314,-.0014,-.1039,-.1922,.6274,.0300,-.8498,.1845,.6007,-.5124,.2429)*f1_4+
    mat4(-.0562,-.4910,-.4237,-.4000,.1496,-.1526,.2338,-.0874,-.2106,.3931,.0976,.2744,-.1049,-.2123,-.1232,.1235)*f1_5+
    mat4(.2477,.4698,.6102,-.4041,.2148,-.0215,-.1688,.5304,-.0846,.1254,.1556,.2659,-.3553,.2785,.1771,-.0792)*f1_6+
    mat4(-.1192,.0868,.3087,-.2625,-.3080,.2357,-.3466,.2121,.1745,-.1621,-.1070,-.2351,-.2100,-.4621,-.4016,.0032)*f1_7+
    vec4(-1.4220,-1.8161,-1.1157,-.7946))/1.41+f1_0;
vec4 f2_1=sin(mat4(.2863,-.3264,.2168,.1994,-.1380,-.2455,-.3398,.3120,-.3024,.2108,.0235,.0475,-.1724,-.1263,-.0317,-.2091)*f1_0+
    mat4(-.1320,.1963,-.1676,-.1104,-.3497,-.1129,-.2144,.1424,.2276,.2332,.1756,-.3497,.0889,.1965,-.1364,.3666)*f1_1+
    mat4(.1656,-.3892,.2380,-.4567,.5590,-.4673,-.1819,-.1375,-.0206,.1215,-.0916,-.0247,.4065,.4623,-.0355,.2796)*f1_2+
    mat4(.3030,.1777,-.0307,-.2387,-.0001,-.2001,.0687,.3839,-.3808,-.0703,.1761,-.0629,-.3711,.2258,.2638,.2379)*f1_3+
    mat4(.0134,.2312,.3900,.1038,-.3374,.0248,-.2315,.2222,-.3335,.2970,.2466,.0353,.1722,-.1117,.4204,-.2758)*f1_4+
    mat4(-.0641,.0787,-.0334,-.2449,.2267,-.2993,-.1197,.0284,-.6316,-.0374,.0654,-.1786,-.2995,.3246,.3189,.0360)*f1_5+
    mat4(.5705,-.4085,-.1961,-.3436,.3977,.4124,-.3529,.4366,.2383,-.1773,-.0106,.3370,-.2338,.2144,.1985,-.4199)*f1_6+
    mat4(-.0641,-.2819,.3172,.0240,-.1308,.2173,-.1785,.2600,.5436,.2713,-.0821,-.0607,-.1221,.3457,.1732,-.0117)*f1_7+
    vec4(-.3965,-1.0897,-2.2474,.6968))/1.41+f1_1;
vec4 f2_2=sin(mat4(.0472,-.0400,-.1822,-.0968,-.1491,-.1114,-.2553,-.2677,-.0260,.3329,-.1840,-.0300,.1444,-.1375,-.3190,.2843)*f1_0+
    mat4(.2395,-.0755,.3117,.0443,-.2219,.0686,.1937,.1171,-.0994,-.1058,-.0122,.1278,-.0639,-.0696,-.3259,-.2619)*f1_1+
    mat4(.1064,.2582,-.1982,-.2738,-.4197,.5780,-.1547,-.0729,.3479,.1693,-.1787,.3594,-.2454,.2317,.1921,-.3782)*f1_2+
    mat4(-.0312,-.1196,-.2628,.0087,-.1582,-.1701,.2420,.1586,.1559,.3237,-.2705,-.1310,.1194,.4038,.0471,-.0392)*f1_3+
    mat4(-.2899,.0635,-.1728,.2339,.1227,.2300,.3259,.2395,.2740,-.3589,.0463,-.1713,.0515,.2916,.1385,.1560)*f1_4+
    mat4(.2040,.2826,.2911,.1797,-.0240,-.2059,.2807,.1042,-.1960,.2139,-.4975,-.1052,.0738,.2267,-.0186,-.1352)*f1_5+
    mat4(-.1516,.3722,-.2781,.1542,-.3754,.0877,-.2358,-.1362,-.3588,-.0664,.0499,-.1363,.1704,.1210,-.1256,.1651)*f1_6+
    mat4(.0778,-.2458,-.1198,-.2079,-.0744,.1480,-.0071,.1170,.0840,-.2907,-.0155,.2515,-.3603,-.1451,-.0803,-.2152)*f1_7+
    vec4(-.0137,1.8646,-.1886,1.3529))/1.41+f1_2;
vec4 f2_3=sin(mat4(.2799,.0311,-.1566,.1753,-.0066,-.0278,.3610,-.1491,.4723,.0108,-.2441,.2740,-.0431,-.3060,.4060,-.0093)*f1_0+
    mat4(-.2758,.1986,.0900,-.0156,.1992,.1157,.4091,-.1006,.1152,.0936,-.0972,-.0932,.1001,.1531,.2223,.1229)*f1_1+
    mat4(-.1761,-.0668,.2531,-.5969,.5083,.3391,.0329,.0394,-.5108,-.0475,.1226,-.6901,-.3810,.2587,.0134,-.2186)*f1_2+
    mat4(.3353,.0394,-.1849,.3203,.1205,.2012,.6494,-.0564,-.0891,-.1594,.4516,.1856,-.0725,-.2354,-.4072,.3137)*f1_3+
    mat4(-.3830,-.4299,.3065,-.1372,-.0580,-.1029,-.2183,.6106,-.2468,-.2763,-.0719,.0134,-.3273,-.0662,-.3148,-.2576)*f1_4+
    mat4(-.1814,.2503,.2340,-.0367,-.2121,-.1992,.4911,.0190,-.3486,-.0399,.3613,.5524,-.2854,-.2390,.0967,-.4394)*f1_5+
    mat4(.1507,-.1419,-.3367,-.1484,-.2877,.1267,-.6417,-.1760,.0979,.3338,-.5463,-.3676,-.3418,-.2698,.0544,.0134)*f1_6+
    mat4(-.0266,-.1425,.0241,-.1249,-.2648,-.4071,-.0431,-.2355,.1417,.3060,-.0978,-.4351,.3160,-.5225,-.2552,.3531)*f1_7+
    vec4(1.8275,.0580,-.5466,1.4786))/1.41+f1_3;
vec4 f2_4=sin(mat4(.1746,.0957,-.2066,-.1603,-.4014,-.1479,.4109,-.1728,.3192,.0821,.1666,-.3202,-.0987,.1237,-.0543,-.0856)*f1_0+
    mat4(-.1727,-.0026,-.1570,.0179,-.1785,-.0058,.0157,-.0845,.0276,-.0755,-.5901,-.0820,.4554,-.2349,.0894,.1244)*f1_1+
    mat4(-.2295,-.1110,.4449,.0372,-.0712,.2068,.1204,.3757,-.4439,.0531,-.1836,.0555,-.3117,-.1801,-.4327,-.2483)*f1_2+
    mat4(.0463,.1021,-.1079,-.2372,-.1625,.1134,.3066,.0022,-.1075,-.1377,.2458,-.1658,-.1560,.1690,-.0936,-.0637)*f1_3+
    mat4(.1582,.4317,-.1064,.2832,-.1349,.2106,-.1651,-.1000,.1806,-.0670,-.2971,-.0977,-.0603,.0127,-.0236,.0984)*f1_4+
    mat4(-.3728,.0547,-.5659,-.0165,.2617,-.0336,.0297,.1128,-.3701,-.2217,.1497,-.2795,.2678,-.0275,.2230,.2185)*f1_5+
    mat4(-.2085,-.0716,-.0761,-.4247,-.3128,-.1967,-.3252,.2833,.1285,.1225,.2183,.1684,-.3532,-.0422,-.2019,.1488)*f1_6+
    mat4(.1418,-.1073,.3806,.0102,.0525,.1732,-.1511,.2633,.0284,-.0870,-.2041,-.0931,.1620,.1923,-.0499,.3008)*f1_7+
    vec4(-.1349,1.0521,-1.7979,.2089))/1.41+f1_4;
vec4 f2_5=sin(mat4(.4533,.3386,.1017,-.1335,-.2207,-.0756,-.0385,.1608,-.0298,-.1184,-.0624,.1228,-.1050,-.2214,-.2313,.4074)*f1_0+
    mat4(-.0289,.0016,-.2037,.2335,-.1737,-.2545,-.3202,-.0937,.1538,.1024,-.1054,.1926,.5224,.1017,.2533,.1736)*f1_1+
    mat4(.1702,-.0539,-.3957,.4119,.0677,-.0884,-.4015,-.4150,.1188,.0222,-.1469,.1161,-.0407,.0700,-.2492,.0734)*f1_2+
    mat4(-.5535,-.1166,-.4168,-.1204,.0461,.3923,.2887,.2812,.2454,-.3190,.1452,.2392,-.1134,.3451,-.0026,.3660)*f1_3+
    mat4(-.0909,.1504,-.4813,.2124,.1232,-.1785,-.1829,.1195,-.1980,-.0576,-.0093,.3417,.0498,-.2314,-.0240,.1897)*f1_4+
    mat4(-.4515,.1000,.3670,-.2068,-.1310,-.1276,.3238,.1248,.2264,-.1227,.1531,.1104,.5808,.0483,.1787,.1127)*f1_5+
    mat4(-.1263,.2581,-.2122,.5993,.1090,.3535,-.0708,-.2158,-.4753,.2062,-.0755,-.8191,.1853,-.0391,-.0818,.3689)*f1_6+
    mat4(-.1588,-.4503,.0626,.0482,.1253,.1425,-.4140,-.0067,.0700,-.0426,.0963,-.0441,-.1686,-.1110,-.3168,.4427)*f1_7+
    vec4(2.2147,-1.7227,-.3088,-1.1331))/1.41+f1_5;
vec4 f2_6=sin(mat4(-.0008,.0330,-.0333,.2745,-.0871,-.6135,.0734,.2999,.1561,-.0360,-.2697,-.0761,.2738,.1409,.3361,.2414)*f1_0+
    mat4(.2594,-.1807,.3105,-.2049,-.2331,.2027,-.2281,-.3727,.0728,-.1648,.2359,-.3755,.3987,-.0777,.1873,.2892)*f1_1+
    mat4(-.0235,.1510,.5777,-.0815,-.1928,-.1758,-.0239,-.1490,.2213,.2282,.2782,-.3906,-.0213,-.5825,.1965,-.5994)*f1_2+
    mat4(-.2033,.1473,-.2922,.1104,-.0189,-.3616,.2379,.0539,.2384,.1392,.1632,-.1954,.6096,-.2192,-.1472,-.2769)*f1_3+
    mat4(-.2974,.2028,-.1128,.0813,-.1526,-.0028,-.1686,-.0451,.3557,.2741,.3285,.2518,.3536,.2780,-.1937,.2454)*f1_4+
    mat4(-.4937,.1756,-.1535,-.3936,.2241,.3537,.0015,-.1264,.5740,.0587,-.0237,-.0800,.3431,-.1992,.3443,.2349)*f1_5+
    mat4(.4255,-.3016,.1230,.3302,-.0327,.2003,-.4925,-.2795,-.4906,.1638,-.6365,-.5219,.0490,.2018,.3960,-.1266)*f1_6+
    mat4(.1831,.1639,.2025,.3404,-.5479,.1719,.0780,-.0353,-.0510,-.2046,-.1178,.0117,-.1707,.1545,.2708,-.1771)*f1_7+
    vec4(2.0413,-.8035,1.7061,-1.8694))/1.41+f1_6;
vec4 f2_7=sin(mat4(-.2355,-.1696,-.1964,-.1450,-.2621,.0600,.0757,-.3024,-.0948,-.0628,.4821,.2096,.0744,.3602,.2433,.2356)*f1_0+
    mat4(.2131,.2139,-.2805,.2256,.3685,-.3415,.3168,-.4724,.1007,-.1040,-.1148,-.0918,-.1840,-.0254,-.2924,.1012)*f1_1+
    mat4(.0838,-.3899,-.2678,.2901,.2906,-.1406,-.3356,-.2748,-.0653,.1979,-.2365,.3282,.2821,.1409,.3160,.2368)*f1_2+
    mat4(-.1988,.1861,.2920,.2512,-.4404,.2064,-.0344,.1098,-.1506,-.2387,-.3768,.0449,-.0791,.0002,.1391,.1670)*f1_3+
    mat4(-.1548,-.3231,.0811,-.3357,-.0927,-.1571,.1942,-.0170,.2303,-.1807,-.0618,-.0442,-.1144,-.0182,-.1247,-.3328)*f1_4+
    mat4(-.3430,.1920,.1773,-.3588,-.1417,.1338,.4685,-.0125,-.2312,-.1929,.2315,.2000,-.1442,.0704,-.2057,.3263)*f1_5+
    mat4(.1565,-.3663,-.3861,.2778,-.1360,-.4939,.1754,-.4649,.1150,.0544,-.2320,-.6401,.1734,.1488,.1139,-.2595)*f1_6+
    mat4(-.1019,.0091,-.4281,.1973,.0169,-.3304,.4714,.1163,.0174,-.4290,-.1358,.2060,.1906,-.3259,.0731,-.1211)*f1_7+
    vec4(1.6535,-2.2802,-1.3987,-1.7983))/1.41+f1_7;
vec4 f3_0=sin(mat4(.3313,-.1841,.3076,.2377,-.1798,-.6317,.2219,.6616,.0005,.1156,-.1094,.3746,-.1807,-.1598,-.5170,-.3575)*f2_0+
    mat4(-.1253,.3167,.1927,-.1863,.0386,-.2879,.4010,.2496,.1327,-.3388,-.5408,-.0915,.3682,.0492,-.5315,-.0189)*f2_1+
    mat4(-.0564,.6727,.2439,-.1873,.1333,-.1097,.6097,.5876,.1857,.0290,.1743,-.1566,.1238,.0765,.2272,.5760)*f2_2+
    mat4(.3657,-.0846,.2929,-.2310,-.1914,-.3431,.3726,.6302,-.1160,.5878,.3163,.1489,-.3111,.1022,-.0676,-.4609)*f2_3+
    mat4(-.1546,.0826,.3142,.0952,-.0605,.0752,.1836,-.1446,.2698,-.1439,-.0159,-.5126,.2482,.2438,.6618,.1412)*f2_4+
    mat4(.2095,-.4662,.1453,.5210,-.4186,.5051,.1556,-.1102,.2140,-.1540,.3752,.3613,.2990,.1859,-.0623,-.4596)*f2_5+
    mat4(.0792,-.0105,-.2283,-.5180,-.0729,-.4423,.5378,.6082,-.0114,-.6165,-.0880,.5712,-.2888,.2076,.1328,.2251)*f2_6+
    mat4(-.2767,-.0881,.3580,.2271,.1308,-.4237,-.0418,-.1558,.1085,-.3250,-.0945,-.7507,-.2518,.1338,-.2712,-.2905)*f2_7+
    vec4(-.3471,-1.4760,-1.4786,1.0043))/1.73+f2_0;
vec4 f3_1=sin(mat4(-.1723,.1866,-.0127,.5451,-.4235,-.3342,-.1475,.0001,.2341,-.2384,-.1406,.1409,.1936,-.0105,-.0182,-.3813)*f2_0+
    mat4(.0866,.0578,-.1961,.1672,-.4473,.1252,.2544,.4695,-.0338,.0790,.0650,-.0299,-.2212,-.1319,-.2443,-.4194)*f2_1+
    mat4(-.4518,-.0255,-.2765,.2270,.2395,-.3907,-.0187,.0381,.1958,.0194,-.1527,.0909,.3251,-.1308,.1844,-.1145)*f2_2+
    mat4(.0584,.0492,.3092,.0220,.1201,.6789,.1620,.1114,-.0981,.4132,-.2116,-.0303,-.2571,.0112,.0988,.3005)*f2_3+
    mat4(.1278,.5819,-.1352,-.1129,.1503,.2717,-.1265,.2813,.3433,-.0470,.4334,-.1592,-.3047,-.1614,.2810,.4897)*f2_4+
    mat4(-.4714,.4669,-.1320,.8070,.2246,-.5671,.2866,.1289,.1262,-.2041,.0030,.2841,.0571,.0027,.1893,-.1165)*f2_5+
    mat4(.3718,-.3138,-.1271,-.4907,-.0888,-.0123,.4729,.2096,-.3311,-.4946,.2016,.3721,-.1402,-.0505,-.1029,.4489)*f2_6+
    mat4(.2357,.2603,-.0445,.0612,-.0166,-.0786,-.0061,-.2286,.1058,.2424,-.1443,-.2388,.0850,.0345,-.0521,-.3858)*f2_7+
    vec4(-2.0658,-1.2382,1.2312,.4206))/1.73+f2_1;
vec4 f3_2=sin(mat4(-.1616,.3366,.4292,.0487,.2497,-.2058,.3590,-.1700,-.2400,.0313,.2781,-.1880,-.4977,.0138,.5493,.3087)*f2_0+
    mat4(-.2624,.2923,.1567,-.2346,.3242,-.2256,-.3513,.0360,.4967,-.0183,-.1632,-.4336,.5340,.1413,.2452,.3208)*f2_1+
    mat4(-.1375,-.2965,-.0387,.2818,-.2448,.1328,.0107,-.0825,.0515,-.0039,-.1513,-.2703,.0609,-.0708,-.2218,.2052)*f2_2+
    mat4(-.3253,.1901,.2105,-.2744,.1807,-.1245,-.2013,-.0749,.0943,.1579,-.0589,.4592,.1834,-.0459,.6927,.2324)*f2_3+
    mat4(.3287,-.3438,-.2194,.3184,-.1365,-.4789,-.1043,.2573,-.7663,-.1945,.1061,-.1714,-.3742,-.1184,.3276,.0127)*f2_4+
    mat4(-.1694,-.5151,.0905,-.2014,.3350,-.0691,-.2301,.0823,-.2899,.1256,.1540,.1148,-.0025,-.1452,-.2052,.4201)*f2_5+
    mat4(-.2101,-.1062,.0996,.3371,-.0826,-.0501,-.7140,-.1264,.0469,-.1337,-.4247,-.4009,.0927,-.1139,.3719,.0133)*f2_6+
    mat4(.0046,-.1804,.6768,.1963,.1487,-.1041,.0090,-.1911,.1104,-.3759,-.0945,-.2140,-.2301,-.1189,-.2323,.0952)*f2_7+
    vec4(1.6769,-2.1215,-1.0699,1.3432))/1.73+f2_2;
vec4 f3_3=sin(mat4(.0178,.4514,.0317,.4479,-.1408,.5057,.4208,.0789,.1065,.1670,.0565,-.2373,.5855,.1719,.0593,.3088)*f2_0+
    mat4(.2609,.3126,.1307,.0918,.0074,.0997,-.1180,.6880,.3105,-.0952,.4314,.2324,-.1188,-.3203,.0964,-.2887)*f2_1+
    mat4(.1459,.0103,-.2341,-.0684,-.1289,.1822,-.2500,.2978,-.0472,-.0637,-.2412,-.2612,-.1080,-.1523,-.1418,.1442)*f2_2+
    mat4(.1802,.0658,.1326,.3739,.4867,-.4339,-.1930,-.1134,-.1478,-.0175,-.5720,-.2858,-.0118,.0428,.0614,-.6860)*f2_3+
    mat4(.3019,-.4082,-.1629,-.1589,.1943,-.0694,-.1943,-.3523,.0170,.3200,.0943,-.0632,-.0836,.4103,-.0884,.1640)*f2_4+
    mat4(-.0288,.0282,-.0323,.1237,.2276,.1456,.0929,-.0725,-.2728,.1669,-.2172,.0716,.0269,.0361,-.3623,-.0536)*f2_5+
    mat4(-.0021,.3076,-.3485,-.3356,-.3856,-.3993,-.0638,-.0775,-.3594,-.2090,.9989,.2148,.0506,.1401,.3775,.0792)*f2_6+
    mat4(-.3611,.0341,-.2071,-.1726,-.4017,-.3025,-.1761,-.0614,.3971,-.1015,-.0128,.5525,.0405,.2531,-.3758,.0119)*f2_7+
    vec4(-1.3478,-1.2236,-.0489,.7284))/1.73+f2_3;
vec4 f3_4=sin(mat4(-.4635,-.2221,.0685,-.0898,-.0439,.0841,.3123,-.6493,-.1861,-.1191,.0815,.1626,.3225,-.0846,-.3400,.4344)*f2_0+
    mat4(.3915,.2044,.2974,.0393,-.5798,-.0300,-.1992,.2109,-.0314,.0434,-.0389,-.0097,-.2094,-.4741,.3139,-.2301)*f2_1+
    mat4(.1016,.1555,-.3086,.4107,.1091,.0190,-.1192,-.2992,.2740,-.0794,.0725,.4889,-.2486,.2591,.3303,-.2122)*f2_2+
    mat4(.1925,-.1152,.1434,.1558,.0019,-.2005,.0537,-.3515,.1942,.1978,-.6411,.4338,.1553,.0490,-.0330,.4171)*f2_3+
    mat4(-.0271,-.0336,-.1033,.1969,-.4232,-.3326,.4287,-.0886,.2253,.0710,.2220,.1155,.1375,-.3497,-.1147,-.5716)*f2_4+
    mat4(-.1670,-.1146,-.2052,-.0273,-.0213,-.0933,-.2196,.2513,.3803,-.0373,-.4268,-.2988,-.1099,-.5135,-.2589,.3012)*f2_5+
    mat4(.1136,-.2360,.1964,.2271,-.1871,-.1881,-.3268,.1972,-.9328,-.0881,.0081,-.7798,-.0789,-.0960,-.3694,.3582)*f2_6+
    mat4(.7142,-.0456,.2433,.0342,.1336,-.0005,.3548,-.0976,-.3094,-.0500,-.0583,-.0692,.0436,.0778,-.0380,.0887)*f2_7+
    vec4(1.0589,1.0816,-1.0344,-1.1224))/1.73+f2_4;
vec4 f3_5=sin(mat4(-.4004,-.3502,-.0204,-.3227,-.5428,-.5908,.0445,-.3453,.2356,.2817,.3513,-.0254,.4475,.3949,-.1122,-.1443)*f2_0+
    mat4(.2132,.2733,-.0179,.3328,-.3607,.0089,.5432,.3088,.2094,.0738,.2165,.0584,-.4659,-.0249,-.1016,-.4296)*f2_1+
    mat4(.2319,.1478,.3617,.1117,-.4556,.1955,-.2478,-.1879,-.1423,-.3040,.3377,.0144,-.2357,-.0853,.6082,.1429)*f2_2+
    mat4(-.2593,-.2611,.4395,.1667,.0345,.4901,.2487,-.0026,.2734,.3280,.2801,-.1466,-.1307,.2232,-.0522,.0347)*f2_3+
    mat4(.2109,.2951,-.2957,.1386,.1645,.1131,-.1915,.3866,.4850,-.2991,.0639,.2355,-.5015,-.3986,-.2466,.3612)*f2_4+
    mat4(.0062,.0509,.0772,.3626,.5153,-.1371,.2233,.2494,-.2444,-.1014,-.0814,-.6159,-.3593,.3973,.0696,-.6129)*f2_5+
    mat4(.1700,.5207,.0077,-.5223,.2301,-.7926,-.7060,.3677,.3496,-.5222,.0122,.6564,-.3784,.2008,-.3941,-.0405)*f2_6+
    mat4(-.1868,-.5801,-.1395,.2059,-.0566,-.5420,-.2554,.1393,.3148,-.2406,.0932,.1999,.0948,.0171,.0434,-.1427)*f2_7+
    vec4(-.8419,1.0133,-.3166,1.1585))/1.73+f2_5;
vec4 f3_6=sin(mat4(.2596,.4705,.2017,.0878,-.0321,-.4016,-.0193,-.1033,-.2191,.2252,.1664,.1261,-.2416,-.3472,-.3263,-.3813)*f2_0+
    mat4(.1430,.0861,-.0082,-.2653,-.3999,.1613,-.0187,.1095,-.1713,-.1831,.1330,.2832,-.1151,.0090,.2317,.2045)*f2_1+
    mat4(.0121,.4542,-.4168,-.0409,.1061,-.3375,.1501,.1363,.5040,-.0811,-.2425,-.2758,.0822,.1525,-.0555,.2423)*f2_2+
    mat4(.1775,.2501,-.0533,.2462,-.0305,-.1620,-.0340,-.0714,-.0252,.4231,-.5005,-.0600,.3435,.0447,-.2122,-.1718)*f2_3+
    mat4(.0790,.0893,-.0186,-.3093,-.0760,-.4034,.2561,-.1662,-.0656,.0480,.4209,.3327,.1387,-.2579,.1161,.4230)*f2_4+
    mat4(-.1999,-.2232,.3051,-.3174,-.1544,-.0719,.0605,.4185,.1008,-.2156,-.1013,.1413,.4051,.3386,-.5506,.0611)*f2_5+
    mat4(.0426,-.4160,-.0739,-.2679,-.2484,.3400,.3564,.2983,-.1825,-.3116,.7870,.0105,.2455,.3194,-.2629,-.0640)*f2_6+
    mat4(.2841,-.0713,-.1810,-.2342,-.2679,-.3895,.1499,.6543,.2553,-.1275,-.2124,-.2141,.2464,-.0263,-.0670,-.5636)*f2_7+
    vec4(-.0921,.5849,1.7013,-2.2406))/1.73+f2_6;
vec4 f3_7=sin(mat4(.0764,-.0809,.1392,.2444,.1820,.1992,.0672,-.2931,-.0643,-.0229,-.5270,.0312,.2049,-.2348,-.1522,.2559)*f2_0+
    mat4(.2012,-.2825,.2911,.2128,.0938,-.3346,.6047,-.1499,-.1410,.1568,-.1053,-.2598,.4599,-.0755,-.0742,.0193)*f2_1+
    mat4(-.0426,-.2334,-.0064,.5097,-.3124,-.2356,.6008,-.2849,.3583,.0817,.0969,.1261,.3197,-.0464,.4738,.0764)*f2_2+
    mat4(-.2466,.4000,.4111,-.1223,.1203,-.4611,-.1533,-.1658,.1741,.3227,-.0968,.5904,-.1858,-.0582,.4446,.2579)*f2_3+
    mat4(-.2821,-.2132,.3315,-.1621,-.3167,.1570,.1036,-.1609,.2522,-.3390,.5042,.1325,.2831,-.3424,.6945,.1522)*f2_4+
    mat4(-.3970,-.3284,-.0116,-.2421,-.1450,-.3287,.1463,-.3426,.1198,.2187,.0056,.3327,.4287,.4806,.1142,.5354)*f2_5+
    mat4(-.0434,-.1038,.4422,.3366,-.3362,-.0272,.3478,-.7946,.1070,-.0914,.5159,-.5441,-.1468,.2812,-.3413,.0532)*f2_6+
    mat4(-.1015,.0236,.2663,.1431,-.1551,-.0236,.4655,-.2337,-.0781,.2885,.3162,-.0215,.2074,-.2164,.0870,.2447)*f2_7+
    vec4(-1.2349,1.8927,1.5608,-.5357))/1.73+f2_7;
vec4 f4_0=sin(mat4(.0685,-.0992,-.2379,-.2541,.4421,.1318,-.3002,-.0013,.2662,.1698,.1148,-.1883,.1460,-.1760,.4026,-.2311)*f3_0+
    mat4(.3529,.2049,.2316,-.0529,.0365,-.2361,.0915,-.1178,-.0440,.0203,-.6988,-.3796,-.2470,-.2345,-.4532,-.0154)*f3_1+
    mat4(.1608,.1073,-.0105,.0677,-.2864,.2599,.0346,-.0225,.5556,-.1665,-.0445,-.5627,-.5389,.3547,-.1059,.2502)*f3_2+
    mat4(.3549,-.0868,.2041,-.2457,-.2059,-.1682,.3622,-.2000,-.0116,.1123,.5120,-.1157,-.5492,-.2497,-.2800,.1469)*f3_3+
    mat4(.2886,-.0431,1.0755,.1927,-.4227,-.1982,.1989,.3397,.3508,-.4416,-.0425,-.1648,.4239,-.0297,-.1805,.0099)*f3_4+
    mat4(.1265,-.4994,.1493,.2996,-.6675,.0183,-.8657,.0477,-.3071,.2976,.0615,.0163,.3178,.0701,.1461,-.3896)*f3_5+
    mat4(.1736,.0211,.2793,-.0076,-.0670,.2490,.3345,.2259,-.2239,-.0806,-.1767,.2879,-.2545,-.1230,-.1879,-.1380)*f3_6+
    mat4(-.0811,-.0532,.1647,.1432,.1346,-.0062,.0610,-.1691,.1814,-.0378,-.1847,.3233,.1793,-.1283,-.0794,-.1277)*f3_7+
    vec4(-.3748,1.4850,-.1442,2.0950))/2.00+f3_0;
vec4 f4_1=sin(mat4(-.1097,-.2323,-.2906,-.1909,-.0064,.1931,.4827,-.1663,.2429,-.2563,.1072,.3541,-.1999,-.3519,.1067,-.0551)*f3_0+
    mat4(-.1226,-.0473,-.0421,.0517,-.1115,.1763,.0986,.1210,-.0048,.2720,.2342,-.2702,.0019,-.3227,.1437,-.1874)*f3_1+
    mat4(-.4877,-.3436,-.1203,-.3744,.1374,.0064,.1345,-.1722,.3255,-.1328,.1772,-.0208,.0702,-.1063,.0074,-.0726)*f3_2+
    mat4(.1427,.3036,.0406,.0017,-.2286,.1422,-.1555,.5061,-.6929,-.4683,-.5378,-.2687,.1987,.2292,-.5625,.0272)*f3_3+
    mat4(.0013,.4324,.2466,.2439,.1841,-.2456,-.1339,.3629,.0653,.2448,-.3693,-.2166,-.1590,.6671,.3712,-.0940)*f3_4+
    mat4(.2850,.3993,-.1993,-.2816,-.0501,-.1085,-.4346,.3850,-.0069,-.3122,.3110,.1021,-.0556,-.4736,-.1344,.1801)*f3_5+
    mat4(.1152,-.1842,-.4665,.1002,.5129,-.0220,.3191,-.2161,.1146,.5258,.4816,.2020,.4244,.3290,-.0730,.2637)*f3_6+
    mat4(.0018,.0908,.3465,-.1767,.0287,-.0713,.1546,-.2080,-.0062,-.1526,.1251,.0673,.0098,-.3652,-.2910,.0591)*f3_7+
    vec4(-.0909,.3834,-.6202,-2.0921))/2.00+f3_1;
vec4 f4_2=sin(mat4(-.1580,.0246,.0724,-.2580,-.2265,.4805,-.0076,-.4017,-.0288,.5293,.1361,.1221,.1193,-.1093,-.2100,.4984)*f3_0+
    mat4(.1205,.3699,-.2547,-.1525,-.3167,.1543,.0508,-.1685,-.3853,-.4167,-.0772,.2433,-.2778,-.4514,-.3598,.0256)*f3_1+
    mat4(.2165,-.5708,-.1225,.6359,-.0196,-.3408,-.1344,.0374,.2027,-.1455,-.3109,.1173,-.2504,-.1025,.0167,-.0160)*f3_2+
    mat4(.0730,.2413,-.1955,.4909,.3224,-.0673,.2187,-.1187,.3256,-.8367,.2877,.3416,.2664,-.0278,.0543,-.0248)*f3_3+
    mat4(.1484,.2378,.0961,-.1283,-.0614,.0543,.4125,.0939,.2009,.5211,-.4274,.0563,-.2553,.1613,-.0989,-.3284)*f3_4+
    mat4(.4502,-.1128,.1657,-.3077,-.2045,-.7328,-.1371,.5274,-.0187,.1249,.1491,-.1242,-.1482,-.7631,-.1660,.9512)*f3_5+
    mat4(-.3189,-.1201,-.1126,.3099,-.5746,.1268,.0445,-1.1566,-.6448,.2324,.7315,-1.2800,-.3185,.3252,.1649,.1933)*f3_6+
    mat4(.0104,.1225,-.2245,.1080,.3704,.3344,.0088,-.2742,-.3712,-.1547,.4362,.5554,.1157,-.1694,.0089,.9086)*f3_7+
    vec4(-.8892,.8779,-.4697,1.9587))/2.00+f3_2;
vec4 f4_3=sin(mat4(-.0802,.1722,.2679,.2300,.4107,.3706,-.3573,.6639,.1743,.1002,-.0261,-.1630,.0547,-.0634,.2979,-.2978)*f3_0+
    mat4(-.0241,-.1199,-.1730,.2785,.0815,.2011,-.2467,.1969,.0655,-.3376,.0543,-.1551,.0533,.1042,-.1208,.0992)*f3_1+
    mat4(-.1320,-.1362,.4412,-.6213,.3930,-.0721,.0607,.1951,.4713,.0906,-.0534,-.0614,-.0806,.0615,-.0520,.6064)*f3_2+
    mat4(-.1201,-.1491,.1292,-.1638,-.2848,.0803,-.1442,-.0287,-.1298,-.2733,-.0686,-1.0184,.0924,-.0212,.1017,-.0052)*f3_3+
    mat4(.1723,-.0910,.1380,.6802,.0107,.0356,-.0215,.1558,-.0397,-.0731,.0550,-.1274,-.3522,.0713,.1975,.9979)*f3_4+
    mat4(-.2804,-.4170,-.3145,.3403,.1460,-.1558,-.1950,-.1722,-.1029,-.0377,-.0144,.7175,.0912,-.0176,.1221,-.9883)*f3_5+
    mat4(.6918,-.0316,.2925,.2412,-.4671,.3612,-.2582,.8618,-.0721,.1434,-.0271,1.0480,.0404,.0311,.0303,.4519)*f3_6+
    mat4(-.3385,.0465,.1816,-.3032,.3224,.1457,-.0552,1.0258,-.2806,.0315,-.0161,-.7755,.2725,.0345,.2134,-.9027)*f3_7+
    vec4(-1.4437,.1703,-.3098,.0644))/2.00+f3_3;
vec4 f4_4=sin(mat4(.6193,-.2249,.1266,-.1096,.2222,-.2270,-.3161,.0071,.0115,.3823,.2637,-.2357,.1914,-.3196,-.1619,-.2764)*f3_0+
    mat4(-.0032,.1639,.1317,-.0896,.3548,.3146,-.0123,-.1361,.1400,.1070,-.3276,-.2347,-.3916,-.3520,.4510,-.4206)*f3_1+
    mat4(-.7120,.8260,.1411,-.3398,.1218,-.1188,.0253,-.3272,-.0950,-.3276,.0652,-.3986,-.0618,.3721,-.4107,.4498)*f3_2+
    mat4(.5747,-.0760,.2488,-.2208,-.1830,.2537,-.1012,.2851,-.3231,.0020,.1727,-.1151,-.0445,.1152,.3434,.4066)*f3_3+
    mat4(.3581,-.0389,.1824,.5137,-.0676,.2645,-.0288,-.1361,-.0209,-.2940,-.3649,-.0927,.4479,-.1282,.3849,-.0210)*f3_4+
    mat4(.2720,.2695,.4482,.5917,-.4696,-.2739,.1325,-.3302,-.0881,-.1094,.0356,.1672,-.9246,.0141,-.1072,-.6061)*f3_5+
    mat4(-.0343,-.0902,-.2274,-.2431,.6883,-.5968,-.3917,.6311,.8665,-.0314,.2341,.7961,.1318,.2416,.4424,-.3257)*f3_6+
    mat4(-.5181,.1305,.3601,-.0264,.0972,-.0253,-.1423,.4558,-.5689,-.1397,-.0019,.1094,-.5614,-.1857,.0971,-.4560)*f3_7+
    vec4(-2.0198,-1.5131,1.0783,-1.5657))/2.00+f3_4;
vec4 f4_5=sin(mat4(-.1989,.1481,.0574,.5245,.2220,-.2811,.1067,-.4864,.0685,-.5098,-.0947,-.1041,-.4419,.1618,-.1981,-.3380)*f3_0+
    mat4(.3034,.3681,-.0696,-.3327,-.2312,-.1720,-.0936,.4599,.1817,-.1507,.0783,.2172,-.3878,-.0992,-1.0474,-.5587)*f3_1+
    mat4(-.1382,.2060,.0124,-.0659,-.1176,-.0275,.2347,-.2354,.3047,-.0588,-.1683,.2179,-.1220,-.0611,.0960,-.2389)*f3_2+
    mat4(.3624,.3454,.1111,-.1121,-.2387,.3645,-.3210,-.5434,-.3458,.7840,-.0779,.3160,.2192,-.0527,.1198,.0073)*f3_3+
    mat4(-.1838,-.3534,-.2527,.2915,-.3795,-.1320,-.0664,-.1338,.1982,-.1791,.2175,-.1660,-.2336,-.2536,.4282,-.4972)*f3_4+
    mat4(-.1958,.3972,.2464,.0523,-.4596,-.0862,-.0040,-.4176,-.2901,-.4012,-.0207,-.5263,-.5818,-.2068,-.4139,-.3518)*f3_5+
    mat4(-.4126,-.1417,.3597,-.3179,.4391,-.3970,.3838,.0306,.1662,-.5261,.0985,-.0127,.3323,-.3801,-.1230,.3302)*f3_6+
    mat4(.1284,-.3923,.1990,-.0561,.3863,-.3285,-.2413,.1576,-.5225,-.3138,.0713,-.0583,-.3868,.2907,.0799,-.0480)*f3_7+
    vec4(.5860,-.5990,-.5505,1.1821))/2.00+f3_5;
vec4 f4_6=sin(mat4(.2321,.1621,-.3651,-.2694,-.6645,.2153,.2277,-.6142,.2135,.0115,-.3847,.0869,.1532,-.0723,-.3240,.2334)*f3_0+
    mat4(-.2085,-.1940,.1098,-.0385,-.1266,-.0528,-.3401,-.0218,.0957,-.0256,-.2299,-.3978,.0394,-.2278,-.0825,-.1549)*f3_1+
    mat4(.2401,-.3105,-.2951,.0197,.1510,.2058,-.2256,-.1836,.2494,-.0018,-.1313,.4018,-.2442,.0812,.0717,-.3181)*f3_2+
    mat4(.3523,.2400,-.1386,.2813,-.6287,.0747,-.2247,.0854,.3410,.2721,-.1178,.3122,-.2854,-.3637,-.2680,.2632)*f3_3+
    mat4(-.1202,-.3841,-.3473,-.4211,-.0329,-.3370,.3544,.0985,-.2934,.2479,.0209,-.1138,-.3719,-.0481,-.1569,-.7915)*f3_4+
    mat4(-.2213,-.1722,-.1417,-.4752,-.4173,-.5678,-.0031,-.0696,-.2666,-.3222,-.0452,-.0805,.1441,-.1454,-.3577,.2580)*f3_5+
    mat4(.0939,-.0437,.1267,.3422,-.2207,.0172,.2980,-.0215,-.1308,.0736,.2396,-.9393,-.2944,.2069,.0339,-.0427)*f3_6+
    mat4(-.0621,.1991,-.3169,-.1812,-.1790,-.2106,-.1572,.2181,-.0100,.3618,.0799,.2393,.2920,.1658,.3061,.2907)*f3_7+
    vec4(-.2625,-1.4989,.7955,1.5886))/2.00+f3_6;
vec4 f4_7=sin(mat4(.2543,-.1533,.2777,.0166,-.1510,.0524,.1045,-.5661,.3572,.1318,.3224,-.5189,-.4252,-.3339,.1787,.0743)*f3_0+
    mat4(.0547,-.1086,-.1678,.4333,.0863,.2854,.0588,-.0709,-.1633,-.0749,.1940,-.4371,.2386,.0260,.3362,-.3165)*f3_1+
    mat4(-.2138,.1389,.3307,.5422,.3765,-.2048,.2390,.2260,-.0504,.0551,-.1408,.1114,-.0905,-.3137,-.0518,.0832)*f3_2+
    mat4(-.2088,.1063,.1070,.5126,.1586,-.6203,-.3025,.3793,.4055,.3309,.2383,.5919,.2645,-.3142,.1780,-.1222)*f3_3+
    mat4(.0080,.2118,.2081,.0343,-.0603,.4277,-.2558,-.2181,.1100,.3773,.0035,-.2298,-.0824,.0717,.2931,-.4361)*f3_4+
    mat4(-.0599,.0984,-.1637,-.1743,.2338,.1167,.5644,1.0358,-.0123,-.5109,.3911,-.1812,-.3466,-.2109,.0915,.6180)*f3_5+
    mat4(-.3112,.2823,-.0485,-.3696,.3775,-.2741,-.2640,-.6429,.2082,.0347,.2540,-1.7387,-.3030,-.0923,-.0786,-.3787)*f3_6+
    mat4(-.1924,.4559,.0845,-.3586,-.2576,-.0140,-.2509,-.4056,-.5921,.0438,-.1886,-.2035,-.3892,.3233,-.4221,.3723)*f3_7+
    vec4(1.9150,.7264,.4524,-.3275))/2.00+f3_7;
return dot(f4_0,vec4(-.0277,.0214,.0123,-.0280))+
    dot(f4_1,vec4(.0218,.0333,.0405,-.0353))+
    dot(f4_2,vec4(-.0329,.0398,.0225,.0420))+
    dot(f4_3,vec4(-.0187,.0131,-.0143,.0240))+
    dot(f4_4,vec4(-.0212,.0147,.0106,.0399))+
    dot(f4_5,vec4(.0331,-.0329,-.0268,-.0320))+
    dot(f4_6,vec4(-.0350,-.0220,.0323,.0215))+
    dot(f4_7,vec4(.0442,.0346,-.0244,.0186))+
    -0.045;
}

// Function 418
Model map( vec3 p ){
    return model(p);
}

// Function 419
float map(in vec3 rp, inout AA aa, bool useAA)
{
    float gt = iTime * 0.9;
    float t = sin(gt + rp.x * 1.2) * 0.5;
    t += sin(gt + rp.z * 1.4) * 0.5;
    t *= 0.5;
    
    vec2 off = rot2d(vec3(0.0, 5.0, 0.0), rp.y * 20.0* t);
    rp.x -= off.x * 0.04;
    rp.y -= off.y * 0.005;
    vec2 uv = rp.xz * 6.5;
    
    
	// path
    float s1 = 1.0 - smoothstep(rp.x + sin(rp.z * 3.0) * 0.1 + sin(rp.z * 5.0) * 0.12, -0.4, 0.);
    float s2 = 1.0 - smoothstep(rp.x - sin(rp.z * 4.4) * 0.1 + sin(rp.z * 14.0) * 0.04, 0.4, -0.);
    rp.y += (s1 + s2) * 0.03;
    
	vec4 col = texture(iChannel0, uv, -100.0);
    float h = col.r;
    
    if(useAA)
    {
        rotate(aa, h);
        h = avg(aa);
    }
    
    h *= mix(texture(iChannel0, uv * 0.025).r + 0., 1.0, 0.7);
    h *= H;
    warpedRp = rp;
    return rp.y - h;
}

// Function 420
vec4 map( vec3 pos, mat4 m)
{
    vec4 q = vec4(pos+vec3(0,0,-80.0),1.0)*m;

    vec3 bodyColor = vec3(0.2,0.9,0.4);

    vec4 rotatedPos1 = (q+vec4( 0, 0, 0, 1.0));

    vec4 val1 = vec4(bodyColor,sdCustomEllipsoid(rotatedPos1.xyz ));

    return val1;
}

// Function 421
float map(vec2 p) {
    id = 0;
    float t = iTime / 20.;
    float ljs = 0.6; // lissajous size for lights
    
    // Cutted box
    float size = 1.1;
    vec2 modp = mod(1.1*p, 1.0) - 0.5;
    float d = sdCuttedBox(rot(PI/4.)*size*p) / size;
    
    // Mouse
    vec2 lightPos = vec2(0.55,0);
    if(LDOWN) lightPos = (2.*iMouse.xy-R)/R.y;

    // Light 1
    float circle = sdCircle(p - lightPos, 0.1);
    if(circle < d) {
        id = 1;
    }
    d = min(d, circle);
    
    // Light 2
    float circle2 = sdCircle(p + lightPos, 0.1);
    if(circle2 < d) {
        id = 2;
    }
    d = min(d, circle2);
    
    // Horse shoe
    vec2 absX = p;
    absX.x = abs(absX.x);
    absX.x = -absX.x;
    
    float a = PI/2.;
    float b = -0.6;
    vec2 ra = vec2(cos(a), sin(a));
    vec2 rb = vec2(cos(b), sin(b));
    float arc = sdArc(absX - vec2(-0.5*R.x/R.y + 0.1, 0), ra, rb, 0.8, 0.05);
    if(arc < d) {
        id = 0;
    }
    d = min(d, arc);
    
    lastMapValue = d;
    return d;
}

// Function 422
SDFResult bathSDF( vec3 p )
{
    SDFResult res = SDFResult(TOO_FAR, MAGEN);   
    vec3 orig = vec3(3.75, -1.0, 0.2);        

    vec3 centre = vec3(0.0, 0.5, 0.0)+orig;
    const float radius = 2.3;
    if (length(p-centre) < radius) 
    {   
        // pedestal
        res = roundboxSDF(RoundBox(vec3(0.0, 0.5, 0.0)+orig, vec3(0.55, 0.5, 1.0), 0.1, WHITE), p);    
    }
    return res;
}

// Function 423
float mapH( in vec3 pos, in float time )
{
    float y = terrainHigh(pos.xz);
        
    float h = pos.y - y;
    
    float sph = tubesH( pos, time );
    float k = 60.0;
    float w = clamp( 0.5 + 0.5*(h-sph)/k, 0.0, 1.0 );
    h = mix( h, sph, w ) - k*w*(1.0-w);

    return h;
}

// Function 424
float Tonemap_Lottes(float x) {
    // Lottes 2016, "Advanced Techniques and Optimization of HDR Color Pipelines"
    const float a = 1.6;
    const float d = 0.977;
    const float hdrMax = 8.0;
    const float midIn = 0.18;
    const float midOut = 0.267;

    // Can be precomputed
    const float b =
        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /
        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);
    const float c =
        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /
        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);

    return pow(x, a) / (pow(x, a * d) * b + c);
}

// Function 425
vec3 remap_noclamp( float a, float b, vec3 v )
{
	return (v-vec3(a,a,a)) / (b-a);
}

// Function 426
mat4 findIntersectionScene(Ray ray)
{
    mat4 hit;
    hit[0].z = -1.0;
    
    for(int i=0;i<TRIANGLE_NUM;i++)
    {
        mat4 hitProp = findIntersection(ray,sceneTriangle[i]);
        if((hitProp[0].z < hit[0].z || hit[0].z < 0.0) && hitProp[0].z > 0.0)
        {
            hit = hitProp;
        }
    }
    return hit;
}

// Function 427
vec4 map( in vec3 p )
{
    vec3 r = p; p.y += 0.6;
    // invert space
    p = -4.0*p/dot(p,p);
    // twist space
    float an = -1.0*sin(0.1*iTime + length(p.xz) + p.y);
    float co = cos(an);
    float si = sin(an);
    p.xz = mat2(co,-si,si,co)*p.xz;
    
    // distort
    p.xz += -1.0 + 2.0*noise( p*1.1 );
    // pattern
    float f;
    vec3 q = p*0.85                     - vec3(0.0,1.0,0.0)*iTime*0.12;
    f  = 0.50000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime*0.12;
    f += 0.25000*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime*0.12;
    f += 0.12500*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime*0.12;
    f += 0.06250*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime*0.12;
    f += 0.04000*noise( q ); q = q*2.00 - vec3(0.0,1.0,0.0)*iTime*0.12;
    float den = clamp( (-r.y-0.6 + 4.0*f)*1.2, 0.0, 1.0 );
    vec3 col = 1.2*mix( vec3(1.0,0.8,0.6), 0.9*vec3(0.3,0.2,0.35), den ) ;
    col += 0.05*sin(0.05*q);
    col *= 1.0 - 0.8*smoothstep(0.6,1.0,sin(0.7*q.x)*sin(0.7*q.y)*sin(0.7*q.z))*vec3(0.6,1.0,0.8);
    col *= 1.0 + 1.0*smoothstep(0.5,1.0,1.0-length( (fract(q.xz*0.12)-0.5)/0.5 ))*vec3(1.0,0.9,0.8);
    col = mix( vec3(0.8,0.32,0.2), col, clamp( (r.y+0.1)/1.5, 0.0, 1.0 ) );
    return vec4( col, den );
}

// Function 428
float sdfUnion( const float a, const float b )
{
    return min(a, b);
}

// Function 429
vec4 SceneCol (vec3 ro, vec3 vn)
{
  vec4 col4;
  if (isCol) {
    if (idObj == idRail) col4 = vec4 (0.7, 0.7, 0.7, 0.2);
    else if (idObj == idRbase) col4 = vec4 (mix (vec3 (0.25, 0.25, 0.27),
       vec3 (0.32, 0.32, 0.34), smoothstep (0.6, 0.9, Noisefv2 (512. * ro.xz))), 0.1);
    else if (idObj == idXingV) col4 = vec4 (0.7, 0.8, 0.7, 0.3);
    else if (idObj == idXingB) col4 = mix (vec4 (1., 0., 0., 1.),
       vec4 (1.), step (0.5, mod (10. * qHit.x, 1.)));
    else if (idObj == idPlatB) col4 = mix (vec4 (0.2, 0.2, 0.22, 0.1),
       vec4 (0.25, 0.25, 0.2, 0.1), Noisefv2 (1024. * ro.xz));
    else if (idObj == idPlatU) col4 = vec4 (0.5, 0.3, 0.1, 0.2) *
       BrickShd (50. * ro, vn);
    else if (idObj == idSig) col4 = sigStop ? vec4 (1., 0., 0., -1.) : vec4 (0., 1., 0., -1.);
    else if (idObj == idSigV) col4 = vec4 (0.7, 0.7, 0.8, 0.1);
    else if (idObj == idTun) col4 = vec4 (0.7, 0.3, 0.1, 0.05) *
       (1. - 0.4 * Noisefv2 (vec2 (512. * (1. + atan (qHit.y, qHit.x) / pi), 128. * qHit.z)));
    else if (idObj == idTree) col4 = vec4 (0., 0.4, 0., 0.) *
       (1. - 0.5 * Noisefv2 (vec2 (64. * (1. + atan (qHit.x, qHit.z) / pi), 128. * qHit.y)));
    else if (idObj == idTrunk) col4 = vec4 (0.3, 0.1, 0., 0.02) *
       (1. - 0.3 * Noisefv2 (vec2 (32. * (1. + atan (qHit.x, qHit.z) / pi), 64. * qHit.y)));
  } else {
    if (idObj == idRail) col4.rgb = vec3 (0.6);
    else if (idObj == idRbase) col4.rgb = vec3 (0.4);
    else if (idObj == idXingV) col4.rgb = vec3 (0.7);
    else if (idObj == idXingB) col4.rgb = vec3 (0.9);
    else if (idObj == idPlatB) col4.rgb = vec3 (0.3);
    else if (idObj == idPlatU) col4.rgb = vec3 (0.4);
    else if (idObj == idSig) col4.rgb = vec3 (1.);
    else if (idObj == idSigV) col4.rgb = vec3 (0.7);
    else if (idObj == idTun) col4.rgb = vec3 (0.5);
    else if (idObj == idTree) col4.rgb = vec3 (0.3);
    else if (idObj == idTrunk) col4.rgb = vec3 (0.2);
    col4.a = 0.;
  }
  return col4;
}

// Function 430
float DistanceField( vec3 pos, float dist )
{
	vec3 v = Voronoi(pos.xz);
	vec2 r = Rand(v.xy*4.0); // per-building seed
	
	float f = (.2+.3*r.y-v.z)*.5; //.7071; // correct for max gradient of voronoi x+z distance calc
	
	// random height
	float h = r.x; // v.xy is position of cell centre, use it as random seed
	h = mix(.2,2.0,pow(h,2.0));
	h = pos.y-h;

	// we get precision problems caused by the discontinuity in height
	// so clamp it near to the surface and then apply a plane at max height	
	h = max( min( h, .008*dist ), pos.y-2.0 );

//	f = max( f, h );
	if ( f > 0.0 && h > 0.0 )
		f = sqrt(f*f+h*h); // better distance computation, to reduce errors
	else
		f = max(f,h);
	
	f = min( f, pos.y ); // ground plane
	
	return f;
}

// Function 431
vec4 scene() {
    
	float d = trace();
    
    if (d < viewDist) {
        return colorMap();
    }
    
	return vec4(0.0);
}

// Function 432
void InitScene()
{
    LM_RES = .75*iResolution.y;
    
    // current lightmap packing:
    //         ___
    //        | T |
    //     ___|___|___
    //    | L | B | R |
    //    |___|___|___|
    //Box +XYZ| F |
    //    -X Z|___|
    //
    
    // block - first because a hit on this is likely to be closer than background walls,
    // so only compute local frame etc once
    vec3 bc = vec3(0.,-3.5,0.);
    quads[ 0] = Quad( bc+vec3(0.,0.,-1.5),	vec3(0.,0.,-1.),	vec2(3.),	vec2(2.5/9.,.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 1] = Quad( bc+vec3(1.5,0.,0.),	vec3(1.,0.,0.),		vec2(3.),	vec2(.5/9.,1.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 2] = Quad( bc+vec3(-1.5,0.,0.),	vec3(-1.,0.,0.),	vec2(3.),	vec2(.5/9.,.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 3] = Quad( bc+vec3(0.,1.5,0.),	vec3(0.,1.,0.),		vec2(3.),	vec2(1.5/9.,1.5/6.),vec2(1./9.,1./6.),	3 );
    quads[ 4] = Quad( bc+vec3(0.,0.,1.5),	vec3(0.,0.,1.),		vec2(3.),	vec2(2.5/9.,1.5/6.),vec2(1./9.,1./6.),	3 );
    
    // floor
    quads[ 5] = Quad(	vec3(0.,-5.,0.),	vec3(0.,1.,0.),		vec2(10.),	vec2(0.5,1./6.),	vec2(1./3.,1./3.),	0 );
    // back
    quads[ 6] = Quad(	vec3(0.,0.,5.),		vec3(0.,0.,-1.),	vec2(10.),	vec2(0.5,.5),		vec2(1./3.,1./3.),	0 );
    // ceil
    quads[ 7] = Quad(	vec3(0.,5.,0.),		vec3(0.,-1.,0.),	vec2(10.),	vec2(0.5,5./6.),	vec2(1./3.,1./3.),	0 );
    // left wall
    quads[ 8] = Quad(	vec3(-5.,0.,0.),	vec3(1.,0.,0.),		vec2(10.),	vec2(1./6.,.5),		vec2(1./3.,1./3.),	1 );
    // right wall
    quads[ 9] = Quad(	vec3(5.,0.,0.),		vec3(-1.,0.,0.),	vec2(10.),	vec2(5./6.,.5),		vec2(1./3.,1./3.),	2 );
    // front
    //quads[10] = Quad(	vec3(1000.,0.,-5.),	vec3(0.,0.,1.),		vec2(0.),	vec2(100./6.,.5),	vec2(1./3.,1./3.),	0 );
    
    // bring in by a FULL pixel on each edge to stop lerping into the lightmap for another quad
    for( int i = 0; i < QUAD_COUNT; i++ )
    {
        quads[i].uv_wh -= 3./LM_RES;
    }
}

// Function 433
float distBox(vec3 p, vec3 b)
{
	return length(max(abs(p)-b, 0.0));
}

// Function 434
float heightMap( in vec2 p ) { 

    // The stone texture is tileable, or repeatable, which means the pattern is slightly
    // repetitive, but not too bad, all things considered. Note that the offscreen buffer 
    // doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].
    return texture(iChannel0, fract(p/2.), -100.).w;

}

// Function 435
Hit map(vec3 p) {
	if (inFluid)
		return Hit(bblz(p), 1);

	Hit h = Hit(abs(p.y + 18.5), 5);
	minH(h, tubez(p));
	minH(h, Hit(140. - length(p.xz), 6));

	return h;
}

// Function 436
float distChainCircle(vec3 p, float RR, int numh, float R, float r, float lh)
{
    float ang0=atan(p.y,p.x);
    float dang=PI2/float(numh)/2.;
    float fidx=floor(ang0/dang);
    float angi =(fidx+0.)*dang;
    float angi2=(fidx+1.)*dang;
    vec3 pi =vec3(cos(angi -vec2(0,PIH))*RR,0);
    vec3 pi2=vec3(cos(angi2-vec2(0,PIH))*RR,0);
    float d=10000.;
    d=min(d,distChainSeg(rotX(PIH*(fidx+0.),rotZ(-(angi +PIH),p-pi )),R,r,lh));
    d=min(d,distChainSeg(rotX(PIH*(fidx+1.),rotZ(-(angi2+PIH),p-pi2)),R,r,lh));
    return d;
}

// Function 437
float sdf(vec3 position,out vec3 diffuseColor,out vec3 emissionColor
){diffuseColor=vec3(1.)
 ;emissionColor=vec3(0.)
 ;float Scale=2.25
 ;float Radius=.25
 ;mat3 Rotation
 ;float time=15.
 ;Rotation=rotationMatrix(vec3(time,time*.7,time*.4)*.2)
 ;Scale+=sin(time*.5)*.25
 ;Radius+=cos(time)*.25
 ;vec4 scalevec=vec4(Scale,Scale,Scale,abs(Scale))/Radius
 ;float C1=abs(Scale-1.0),C2=pow(abs(Scale),float(1-/*iterations*/7))
 ;vec4 p=vec4(position.xyz*Rotation,1.0),p0=p
 ;for(int i=0;i<7;i++
 ){p.xyz=clamp(p.xyz,-1.,1.)*2.-p.xyz
  ;p.xyzw*=sat(max(Radius/dot(p.xyz,p.xyz),Radius))
  ;if(i<3)p.xyz*=Rotation
  ;p.xyzw=p*scalevec+p0;}
 /*
 ;diffuseColor=fract(p0.x)<.1 ? vec3(.2): vec3(1.)
 ;emissionColor=fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.)
 */
 ;return(length(p.xyz)-C1)/p.w-C2;}

// Function 438
vec3 TonemapFilmicALU(vec3 x)
{
    vec3 c = max(vec3(0.0), x - 0.004);
    return (c * (c * 6.2 + 0.5)) / (c * (c * 6.2 + 1.7) + 0.06);
}

// Function 439
vec2 GetDist(vec3 p)
{    
    //distance to sphere = distance to center of sphere minus radius
    //y-pos and radius vary over time in some sin/cos pattern
	vec4 sphere = vec4(0, 1.0, 6, 1.0);
    sphere.y += 1.0 * cos(iTime/2.0);
    sphere.w += abs(sin(iTime / 3.0));
    float dS = length(p - sphere.xyz) - sphere.w;
    
    //displace the body of the sphere according to the x-position and the time
    dS += 0.2 * sin(sin(iTime/3.0)*7.0*p.x) * cos(iTime);
    
    //distance to ground plane is just height of camera due to our simple scene
    float dP = p.y + 0.01 * sin(p.x * 5.0 + iTime);
    
	//the object that is closest, wins
    vec2 retval = vec2(0);
    if (dP < dS)
        retval.x = IS_FLOOR;
    else
        retval.x = IS_OBJECT;
    
    //mix the two distances with an intensity that depends on how close they are
    float k = 0.5;
    float h = clamp(0.5 + 0.5*(dP-dS)/k, 0.0, 1.0);
    retval.y = mix(dP, dS, h) - k*h*(1.0-h);
    
    return retval;
}

// Function 440
float map(vec3 p)
{	
	float f=1.0;
    for (int i=0; i<maxballs; i++)
    {
        vec3 pos = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,0.)).xyz;
    	f = min (f,sphere(p,pos));
    }
    
    f= min(f,p.y+0.9); //plane
return f;
}

// Function 441
float dist2D(in vec2 p){

    // Other tube shapes to try.
    /*
    p = abs(p);
    return max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.
    return max(p.x, p.y); // Square.
    return (p.x + p.y)*.7071; // Diamond.
    return max(p.x*.8660254 + p.y*.5, p.y); // Hexagon.
    */
    
    return length(p); // Round cylinder.
    
}

// Function 442
vec3 i_spheremap_32( uint data )
{
    vec2 v = unpackSnorm2x16(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 443
vec3 TonemapCompressRangeFloat3( vec3 x, float t )
{
	x.r = TonemapCompressRangeFloat( x.r, t );
	x.g = TonemapCompressRangeFloat( x.g, t );
	x.b = TonemapCompressRangeFloat( x.b, t );
	return x;
}

// Function 444
bool map(vec3 p)
{
    p += 0.5;
    vec3 b = abs(p);
    
    bool r;
    
    r =      b.x < 8.0;
    r = r && b.y < 8.0;
    r = r && b.z < 8.0;
    
    r = r && !(b.x < 7.0 && b.y < 7.0 && p.z > -7.0);
   
    r = r || (p.x > 1.0 && p.x < 5.0 && p.z > 1.0 && p.z < 5.0 && p.y > -8.0 && p.y < -3.0);
    r = r || (p.x >-5.0 && p.x <-1.0 && p.z > -5.0 && p.z <-1.0 && p.y > -8.0 && p.y < 0.0);
    
    float ws = 2.0;
    //if(p.y > 7.0 && b.x < ws && b.z < ws) r = false;
    
    return r;
}

// Function 445
vec3 UE3TonemapInv(vec3 color)
{
    return (color * -0.155) / (max(color, 0.01) - 1.019);
}

// Function 446
SDFResult planeSDF2( Plane plane, vec3 p )
{
    float ly = dot((p-plane.pos), plane.norm);
    vec3 local = p - (plane.pos + plane.norm*ly);
    
    float ridgex = mod(local.x, 1.0)-0.5;
    float ridgey = mod(local.y, 1.0)-0.5;
    float ridgez = mod(local.z, 1.0)-0.5;
    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;
    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;
    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;
    
    return SDFResult(ly - ridgex - ridgey - ridgez, plane.matindex);
}

// Function 447
float sdfUnion(float a, float b) {
  return min(a, b);
}

// Function 448
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 vn4;
  vec3 col, vn;
  float dstObj, sh, ao, f, fr, a, s, w;
  int idObjT;
  bool isSand;
  isSand = false;
  pgRnd = 17.11 * idPage;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    idObjT = idObj;
    sh = ObjSShadow (ro, sunDir);
    if (idObjT == 1) {
      ao = ObjAO (ro, vn);
      vn = VaryNf (32. * ro, vn, 0.5);
      sh = min (sh, ao);
      col = vec3 (1., 0.9, 0.7);
      col *= 0.8 + 0.2 * Fbm3 (32. * ro);
      col = (col * (ao * 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +
         0.05 * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.));
    } else if (idObjT == 2) {
      isSand = true;
    }
  } else if (rd.y < 0.) {
    f = 0.1 * tCur;
    ro += (- ro.y / rd.y) * rd;
    a = atan (ro.z, - ro.x) / (2. * pi) + 0.5;
    fr = mix (Fbm1 (pgRnd + 32. * a), Fbm1 (pgRnd + 32. * (a - 1.)), a);
    s = SmoothBump (0.25, 0.75, 0.25, mod (f + 0.4, 1.));
    w = length (ro.xz) - (grRad + 0.2 + mix (16. * fr, 16. + 3. * fr, s));
    if (w < 0.) {
      vn = vec3 (0., 1., 0.);
      sh = 1.;
      isSand = true;
    } else {
      w = 0.02 * w + f;
      col = mix (mix (vec3 (0.2, 0.3, 1.), vec3 (0.2, 0.3, 1.) + vec3 (0.6, 0.5, 0.),
         Fbm2 (2048. * vec2 (w, fr)) * SmoothBump (0.4, 0.6, 0.01, mod (w, 1.))), vec3 (0.2, 0.3, 1.),
         smoothstep (-0.1, 0., rd.y));
    }
  } else {
    col = BgCol (rd);
  }
  if (isSand) col = SandCol (ro, rd, vn, sh);
  return clamp (col, 0., 1.);
}

// Function 449
float dist_plan( vec3 pos, vec4 plan )
{
    return dot(pos, plan.xyz) + plan.w;
}

// Function 450
float map(vec3 p, vec2 uv){
  return sphere(p,uv);
  }

// Function 451
float map3(vec3 p) {
    float cubeSize = 10.0;
    vec3 b = vec3(cubeSize);
    float d = length(max(abs(p)-b,0.0));
    return d;
}

// Function 452
vec3 map( in vec3 p )
{
    vec3 res = temple(p);
    
    {
        float h = terrain( p.xz );
        float m = p.y - h;
        m *= 0.35;
        if( m<res.x ) res = vec3( m, 2.0, 0.0 );
    }
    

    {
        float w = p.y + 25.0;
        if( w<res.x ) res = vec3(w,3.0, 0.0 );
    }

    return res;
}

// Function 453
float ldist(in vec4 l,in vec2 p) { 
  vec2 lo = (l.zw - l.xy);
  float l2 = dot(lo, lo);
  float t = dot(p - l.xy, lo)/l2;
  
  if (l2 < 0.0 || t < 0.0001) {
    return length(p - l.xy);
  }
  if ( t > 1.0 ) {
    return length(p - l.zw);
  }
  return length(p - (l.xy + t * lo)); 
}

// Function 454
vec2 map(vec2 pos, Slide slides[SLIDE_COUNT]) {
    float dist = 100.0;
    float hit = -1.0;
    for (int i = 0; i < SLIDE_COUNT; ++i) {
     	float thisDist = boxDistance(pos, slides[i].pos, slides[i].normal, vec2(0.2, 0.01));
        if (thisDist < dist) {
         	hit = float(i);
            dist = thisDist;
        }
    }
    return vec2(dist, hit);
}

// Function 455
float map(vec3 p){
    
   
    //float sf = cellTile(p*.25); // Cellular layer.
    //sf = smoothstep(-.1, .5, sf);
    

    // Trancendental gyroid functions and a function to perturb
    // the tunnel. For comparisson, I included a rough triangle
    // function equivalent option.
    #if 1
    vec3 q = p*3.1415926;
    float cav = dot(cos(q/2.), sin(q.yzx/2.5)); // Gyroid one.
    float cav2 = dot(cos(q/6.5), sin(q.yzx/4.5)); // Gyroid two.
    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.
    
    // Transendental function to perturb the walls.
    float n = dot(sin(q/3. + cos(q.yzx/6.)), vec3(.166));
    //float n = (-cellTile(p*.125) + .5)*.5;
    #else
    vec3 q = p/2.;
    float cav = dot(triC(q/2.), triS(q.yzx/2.5)); // Triangular gyroid one.
	float cav2 = dot(triC(q/6.5), -triS(q.yzx/4.5)); // Triangular gyroid two.
    cav = smin(cav, cav2/2., 2.); // Smoothly combine the gyroids.
    
    // Triangular function to perturb the walls.
    float n = dot(triS(q/3. + triC(q.yzx/6.)), vec3(.166));
    //float n = (-cellTile(p*.125) + .5)*.5;
	#endif

    // Wrap the tunnel around the camera path.
    p.xy -= path(p.z);
    

    // Smoothly combining the wrapped cylinder with the gyroids, then 
    // adding a bit of perturbation on the walls.
    n = smax((2.25 - dist2D(p.xy)), (-cav - .75), 1.) +  n;// - sf*.375;
    
    // Return the distance value for the scene. Sinusoids aren't that great
    // to hone in on, so some ray shortening is a necessary evil.
    return n*.75;
 
}

// Function 456
float scene_Old(vec3 pos)
{
    return min( cube(pos, vec3(10.0, 0.0, 10.0), vec3(3.0, 3.0, 3.0)),
        	min( 
        		sphere(pos, vec3(0.0, 0.0, 5.0), 4.0),
                sphere(pos, vec3(-15, 0.0, 5.0), 1.0) 
              ));
}

// Function 457
void initScene() {
	scene[0] = Sphere(vec3(0, 1, 0), 1.0, Material(LAMB, vec3(0, 0.9, 0.05), 0.0));
    scene[1] = Sphere(vec3(0, 1, 2.5), 1.0, Material(METAL, vec3(0.9, 0.9, 0.9), 0.01));
    scene[2] = Sphere(vec3(0, 1, -2.5), 1.0, Material(DIEL, vec3(0, 0, 0), 1.5));
    scene[3] = Sphere(vec3(0, 1, -2.5), -0.92, Material(DIEL, vec3(0.9, 0.9, 0.9), 1.5));
    scene[4] = Sphere(vec3(0, -1e3, 0), 1e3, Material(METAL, vec3(0.7, 0.75, 0.8), 0.4));
}

// Function 458
vec2 distort( vec2 uv, float t, vec2 min_distort, vec2 max_distort )
{
    vec2 dist = mix( min_distort, max_distort, t );
    //return radialdistort( uv, 2.0 * dist );
    //return barrelDistortion( uv, 1.75 * dist ); //distortion at center
    return brownConradyDistortion( uv, 75.0 * dist.x );
}

// Function 459
float colormap_red(float x) {
    if (x < 0.0) {
        return 54.0 / 255.0;
    } else if (x < 20049.0 / 82979.0) {
        return (829.79 * x + 54.51) / 255.0;
    } else {
        return 1.0;
    }
}

// Function 460
void projectCubemapOnSHCoefficients()
{
    #define SAMPLES 8
    
    float invN = 1.0/float(SAMPLES);
    for (int xx = 0; xx < SAMPLES; ++xx)
        for (int yy = 0; yy < SAMPLES; ++yy)
        {
            vec2 r = (vec2(float(xx), float(yy)) +
                      hash(vec2(float(xx), float(yy)))) * invN;
            //float theta = 2.0 * acos(sqrt(1.0 - r.x)); // This is as in 'Robin Green SH the gritty details' doc
            float theta = acos(1.0 - 2.0 * r.x);
            float phi = 2.0 * PI * r.y;
            vec3 dir = vec3(sin(theta)*cos(phi),
                            cos(theta),
                            sin(theta)*sin(phi));
            
            vec3 texcol = texture(iChannel0, dir).rgb;
            #if PERFORMANCE==1
			SHCoefs[0] += y00 (dir.xzy) * texcol;
			SHCoefs[1] += y11_(dir.xzy) * texcol;
			SHCoefs[2] += y10 (dir.xzy) * texcol;
			SHCoefs[3] += y11 (dir.xzy) * texcol;
			SHCoefs[4] += y22_(dir.xzy) * texcol;
			SHCoefs[5] += y21_(dir.xzy) * texcol;
			SHCoefs[6] += y20 (dir.xzy) * texcol;
			SHCoefs[7] += y21 (dir.xzy) * texcol;
			SHCoefs[8] += y22 (dir.xzy) * texcol;
            #else
            for (int l = 0; l < 3; ++l)
                for (int m = -l; m <= l; ++m)
                {
                    int index = l*(l+1)+m;
                    SHCoefs[index] += SH(dir.xzy, l, m) * texcol;
                }
            #endif
        }
    
    // divide result by weight and total number of samples
    float factor = 4.0 * PI / float(SAMPLES * SAMPLES);
    for (int i = 0; i < 9; ++i)
    {
        SHCoefs[i] = SHCoefs[i] * factor;
    }
}

// Function 461
vec2 shortestPathStepDist(vec4 uvs)
{
    vec2 stepDist = uvs.zw - uvs.xy;
    
    // Modulo range [-0.5, +0.5]
    stepDist = fract(stepDist + 0.5) - 0.5;
    return stepDist;
}

// Function 462
float distCappedCylinder(vec3 p, vec2 h)
{
    vec2 d = abs(vec2(length(p.xz), p.y)) - h;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 463
float sdf_E(vec2 uv)
{
    float sdf_r = sdf_centered_box(uv, vec2(.66, .6), vec2(.1, .3));
    sdf_r = sdf_exclude(sdf_r, sdf_disk(uv, vec2(.58, .6), .25));
    sdf_r = sdf_exclude(sdf_r, sdf_centered_box(uv, vec2(.33, .6), vec2(.25, .35)));
    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.55, .6), vec2(.2, .15), vec2(-.5,.3));
    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .33), vec2(.3, .57), vec2(-.5, .15), vec2(-.75, .2)));
    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.65, .6), vec2(.2, .35)));
    sdf = sdf_union(sdf, sdf_r);
    float t = linear_step(.4, .5, uv.x);
    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.4, .6), vec2(.1, mix(.03, .01, t))));
    return sdf;
}

// Function 464
vec3 map(vec3 p)
{
	float
		a=.5*iTime*cb(11),
		n0 = noise(73.*p+a),
		n1 = noise(10.*p+a+a),
		n2 = noise(2.*p+a)-.5,
		n3 = noise(.4*p+a)-.5,
		h;
	float
		wn1 = .2*n0+n1,
		wn2 = sat(10.*n2),
		wn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);
	float wallnoise = wn1*(.02+wn2),
        	eclipse=sat(5.*sprog-3.)*cb(7);
	vec3 d = vec3(1, 0, 0), q, t;

	dmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,
		(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*
		(1.3-length((p-7.*lpos3).xz))*cb(4)	// enl
		))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),		// ebase,
		0.); 		// common sky


	h = mix(.05*n0+.07*n1+.3*n2+n3,					// terrain
		.002*n0+.04*n1+.2*n2+.4*n3, cb(11));	// water
	if( cb(3)==0. )
		dmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);	// forrest floor
	else if( cb(2)==0. )
		dmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);	// terrain
	else
		dmin(d, .6+p.y-(wn1/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);	// rocks



	h = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);
	h*=2.*(n0-.2)*h;
	if( cb(3)==0. )
		if( cb(2)==0. )
		{
			// trees
			q=rep(abs(p)-1.6, 3.2);
			q.y = abs(p.y)-3.;
			dmin(d,
				max(p.y-3.5+wn2, vines(
					q,
					.1*wn1+.5+10./pow(1.+.95*q.y*q.y, 1.5)
				) -
					mix(.02+.08*wn1, -.1, (.55+p.y/3.)*sat(-15.-p.z))
				), .9, .0);
		}
		else {
			// city
			q=p;
			q.xz=rep(q-3., 6.).xz;

			dmin(d,
				(max(
					min(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),
					length(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y/10.-.25)
				)-h), .7, 0.);
		}


		q=p;
		q.y-=1.5*n0*sprog*cb(15);
		if( camz<30. )
			if( cb(2)==0. )
				// circle
				if( cb(4)==0. )
					dmin(d,
						length(vec2(q.z, length(q.xy)-.5))-.025,
						2.5, -.3);
				else
					dmin(d,
						length(q)-.6,
						1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),
						.0);
			else
				// glowing triangle/square
				if( cb(4)==0. )
					for( float i=0.; i<.99; i+=1./(3.+cb(3)) ) {
						t=q;
						pR(t.xy, i);
						t.y -= .3+.22*cb(3);
						dmin(d,
							max(length(t.yz)-.025, abs(t.x)-.532),
							2.5, -.3);
					}
				else
				{
					pR(q.xz, .05);
					q.y -= .5;
					dmin(d,
						max(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),
						1.4, .0);
				}


		// destruction
		vec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);
		h = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));
		d.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));

		return d;
}

// Function 465
vec3 map_extends()
{
    return vec3(1.0, .5, 1.0);
}

// Function 466
vec2 GetSceneDistance( in vec3 vPos )
{
	float fTrap = kFarClip;
	
	float fTotalScale = 1.0;
	for(int i=0; i<kIFSIterations; i++)
	{	
		vPos.xyz = abs(vPos.xyz);
		vPos *= fScale;
		fTotalScale *= fScale;
		vPos += vOffset;
		vPos.xyz = (vPos.xyz) * m;
		
		float fCurrDist = length(vPos.xyz) * fTotalScale;
		//float fCurrDist = max(max(vPos.x, vPos.y), vPos.z) * fTotalScale;
		//float fCurrDist = dot(vPos.xyz, vPos.xyz);// * fTotalScale;		
		fTrap = min(fTrap, fCurrDist);
	}

	float l = length(vPos.xyz) / fTotalScale;
	
	float fDist = l - 0.1;
	return vec2(fDist, fTrap);
}

// Function 467
float dDistance_Cheap( in vec2 v )
{
    float d0 = sdSegment_Cheap( v, p0, p1, t0, t1 );
    float d1 = sdSegment_Cheap( v, p1, p2, t1, t2 );
    float d2 = sdSegment_Cheap( v, p2, p3, t2, t3 );
    float d3 = sdSegment_Cheap( v, p3, p4, t3, t4 );
    float d4 = sdSegment_Cheap( v, p4, p5, t4, t5 );
    float d5 = sdSegment_Cheap( v, p5, p6, t5, t6 );
    float d6 = sdSegment_Cheap( v, p6, p7, t6, t7 );
    float d7 = sdSegment_Cheap( v, p7, p0, t7, t0 );

    return min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7)))))));
}

// Function 468
Camera CreateScene()
{    
    Camera cam;
	cam.sensorSize = 0.024;
	cam.focalLength = 0.035;
	cam.fstop = 3.5;
	cam.focusDist = 7.0;
    
    cam.orbitPoint = vec3(0.0, 2.0, 0.0);
    cam.orbitDist = 4.3;
    
	sceneSpheres[0] = Sphere(vec3(0,0,0), 15.0, Material(vec3(10.0,13.0,16.0), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));
	sceneSpheres[1] = Sphere(vec3(3.0,0.8,-3.0), 0.8, Material(vec3(0.0,0.0,0.0), 0.3, vec3(1.0,0.7655,0.336), 1.0, MAT_COMMON));
	sceneSpheres[2] = Sphere(vec3(4,1.0,-4), 1.0, Material(vec3(0.99,0.01,0.01), 0.5, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    
    sceneSpheres[3] = Sphere(vec3(1.5,1.0,1.0), 1.0, Material(vec3(0.8,0.99,0.95), 0.2, DIELECTRIC_SPEC, 1.33, MAT_REFRACT));    
	sceneSpheres[4] = Sphere(vec3(-4,0.5,1), 0.5, Material(vec3(70,15,6), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));	
    sceneSpheres[5] = Sphere(vec3(4,0.8,-2), 0.8, Material(vec3(0.9,0.3,0.7), 0.9, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
	sceneSpheres[6] = Sphere(vec3(4,0.7,0), 0.7, Material(vec3(0.99,0.1,0.01), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
	sceneSpheres[7] = Sphere(vec3(-4,0.8,-1.4), 0.8, Material(vec3(0.1,0.99,0.01), 0.8, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    
    sceneSpheres[8] = Sphere(vec3(-3.5,1,-3), 1.0, Material(vec3(0.1,0.1,1.0), 0.3, DIELECTRIC_SPEC, 1.2, MAT_REFRACT));	
    sceneSpheres[9] = Sphere(vec3(2.5,0.6,-4.2), 0.6, Material(vec3(0.0,0.0,0.0), 0.4, vec3(0.6724,0.6373,0.5855), 1.0, MAT_COMMON));
    sceneSpheres[10] = Sphere(vec3(-3.5,1,3), 1.0, Material(vec3(1.0,0.1,0.5), 0.5, DIELECTRIC_SPEC, 1.2, MAT_REFRACT));
    sceneSpheres[11] = Sphere(vec3(-1,0.7,-0.7), 0.7, Material(vec3(0,0,0), 0.5, vec3(1.0,0.7655,0.336), 1.0, MAT_COMMON));
	
	sceneBoxes[0] = Box(vec3(5.49,2.5,0), vec3(0.5,2.5,5), Material(vec3(0.8,0.9,0.1), 0.9, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));
    sceneBoxes[1] = Box(vec3(-5.49,2.5,0), vec3(0.5,2.5,5), Material(vec3(0.9,0.1,0.4), 0.9, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));
    sceneBoxes[2] = Box(vec3(0,2.5,5.5), vec3(5,2.5,0.5), Material(vec3(0.1,0.9,0.4), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    sceneBoxes[3] = Box(vec3(0,2.5,-5.5), vec3(5,2.5,0.5), Material(vec3(0.1,0.4,0.9), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    sceneBoxes[4] = Box(vec3(0,-0.49,0), vec3(5,0.5,5), Material(vec3(0.7,0.7,0.7), 0.3, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));
    sceneBoxes[5] = Box(vec3(2.5,5.5,0), vec3(4.0,0.5,5), Material(vec3(0.8,0.8,0.8), 0.9, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    
    sceneBoxes[6] = Box(vec3(4.5,2.5,0), vec3(0.2,0.2,2.2), Material(vec3(100,50,35), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));
    sceneBoxes[7] = Box(vec3(4.0,1.0,1.5), vec3(0.5,1.0,0.5), Material(vec3(1.0,0.2,0.01), 0.35, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    sceneBoxes[8] = Box(vec3(3.0,2.0,3.5), vec3(0.5,2.0,0.5), Material(vec3(0.2,0.02,1.0), 0.6, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    sceneBoxes[9] = Box(vec3(-4,2.0,4.8), vec3(0.2,1.0,0.2), Material(vec3(10,10,50), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));
    sceneBoxes[10] = Box(vec3(-3,2.0,-4.5), vec3(0.8,2.0,0.3), Material(vec3(0,0,0), 0.35, vec3(0.913, 0.921, 0.925), 1.0, MAT_COMMON));
	sceneBoxes[11] = Box(vec3(0,0.7,-4), vec3(0.8,0.7,0.5), Material(vec3(0,0,0), 0.5, vec3(0.955, 0.637, 0.538), 1.0, MAT_COMMON));	
    sceneBoxes[12] = Box(vec3(-1.3,2.5,-1.5), vec3(0.1,2.5,0.1), Material(vec3(0.5,1.0,0.2), 0.7, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    sceneBoxes[13] = Box(vec3(-1.3,2.5,1.5), vec3(0.1,2.5,0.1), Material(vec3(1.0,0.6,0.2), 0.7, DIELECTRIC_SPEC, 1.0, MAT_COMMON));
    
    return cam;
}

// Function 469
float sdf_flame_segment2(vec2 uv, vec2 size, vec3 waves)
{
    float width = mix(size.x*.005, size.x*.5, smoothen(around(size.y*.5, size.y*.5, uv.y)));
    float h = linear_step(0., size.y, uv.y);
    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));
}

// Function 470
float Blade_SDF(in vec3 point)
{
	float blade = Box_SDF(point, vec3(0.55, 0.025, 6.0));  // Plain old box to carve away
    float zwave = sin(point.z * 15.0) * 0.005;
    float edges = min(TriPrism1_SDF(Repeat(point, vec3(1.0, 0.0, 0.0)), vec2(0.175 + zwave * 0.5, 6.1)),                // Edge near guard
                  min(TriPrism0_SDF(RotY(Translate(point, vec3(1.1, 0.0, 0.0)), 2.95), vec2(0.2 + zwave, 6.1)),         // Point right edge
                  min(TriPrism0_SDF(RotY(Translate(point, vec3(-1.1, 0.0, 0.0)), -2.95), vec2(0.2 + zwave, 6.1)),       // Point left edge
                  min(TriPrism1_SDF(RotY(Translate(point, vec3(-0.5, 0.0, -1.0)), 0.025), vec2(0.2 + zwave, 6.1)),      // Mid left edge
                      TriPrism1_SDF(RotY(Translate(point, vec3(0.5, 0.0, -1.0)), -0.025), vec2(0.2 + zwave, 6.1))))));  // Mid right edge
    
    float fuller = Fuller_SDF(Translate(point, vec3(0.0, 0.165, 1.9)), vec3(0.05 + zwave, 0.05, 3.9));  // Groove inset in middle
    
    blade = Subtraction(fuller, Subtraction(edges, blade));
    
    return blade;
}

// Function 471
RayHit RayTraceScene(vec3 camPos, vec3 rayVec, const in int maxIter, bool cinematicHack)
{
    RayHit ray = Bike(camPos, rayVec, bikeAPos, bikeAAngle, 1.0);
    if (!cinematicHack) {
        ray = Union(ray, Bike(camPos, rayVec, bikeBPos, bikeBAngle, 5.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -1.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -2.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -3.0), 0.0));
        //ray = Union(ray, Bike(camPos, rayVec, bikeAPos + vec3(0.0, 0.0, -4.0), 0.0));

        vec3 posI;
        RayHit voxels = MarchOneRay(camPos, rayVec, posI, maxIter);
        ray = Union(ray,voxels);

        // I/O Tower
        ray = Union(ray, BoxIntersect(camPos, rayVec, vec3(iotower.x, 0.25, iotower.y), vec3(0.5, 256.0, 0.5), 9.0));
    }
    return ray;
}

// Function 472
vec3 doBumpMap( in vec3 pos, in vec3 nor, float amount )
{
    float e = 0.001;
    float b = 0.01;
    
	float ref = fbm( 48.0*pos, nor );
    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;

	amount *= 0.2 + 0.8*smoothstep( 0.3, 0.45, fbm(4.0*pos,nor) );

	vec3 tgrad = gra - nor * dot ( nor , gra );
    return normalize ( nor - amount*tgrad );
}

// Function 473
float map(float v, float low1, float high1, float low2, float high2) {
	return (v-low1)/(high1-low1)*(high2-low2);
}

// Function 474
float map(vec3 p)
{
    float i = texture(iChannel0, vec2(0.1, 0.5)).x;
    
    float h = 1.8;
    float grid = 1.3;
    
    vec3 g = ceil(p / grid);
    
    float rxz = rand(g.xz) * i;
    
    p = -abs(p);
    
    float d1 = p.y + h + rxz;
    float d2 = p.x + h * 0.6;
    
    vec3 q = Repeat(p, vec3(grid));
    float dc = sdCylinder(q, vec3(0.1, 0.0, .5));
    return max(max(d1, dc), d2);
}

// Function 475
float sdframe( vec3 p, vec3 b, float e ) {
  p = abs(p  )-b;
  vec3 q = abs(p+e)-e;
  return min(min(
      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),
      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),
      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));
}

// Function 476
float RenderScene(vec3 position, out float distance)
{
	float noise = Turbulence(position * NoiseFrequency + Animation*iTime, 0.1, 1.5, 0.03) * NoiseAmplitude;
	noise = saturate(abs(noise));
	distance = SphereDist(position) - noise;
	return noise;
}

// Function 477
float sceneDistance(vec3 point, float worldTime) {
    float center = (floor(point.z * 1.8) + 0.5) / 1.8;
    float neighborCenter = center + ((point.z < center) ? -1.0 : 1.0);

    float me = partDistance(point - vec3(0.0, 0.0, center), 3.14159 * floor(center), worldTime);
    float neighbor = boxDistance(point, vec3(0.0, 0.6, neighborCenter), vec3(0.6, 1.2, 0.70));
    float partComposite = min(me, neighbor);
    
    float container = boxDistance(point, vec3(0.0, 0.6, 0.56), vec3(1.0, 1.4, 1.1));
    return opSmoothIntersection(partComposite, container, 0.02);
}

// Function 478
float SphereDistance(vec3 point, vec3 center, float radius){
  point.z = modA(point.z);point.x = modA(point.x);
  return fSphere(point-center,radius);}

// Function 479
float unionSDF(float distA, float distB) {
    return min(distA, distB);
}

// Function 480
Hit sdf(vec3 p) {
    float t = sin(-HALF_PI + iTime * 0.15) * 0.5 + 0.5;
    float t2 = sin(-HALF_PI + iTime * 0.3) * 0.5 + 0.5;
    
    Hit torusHit = torusSdf(p, vec2(SPHERE_R, t2 + 0.3));
    Hit sphereHit = sphereSdf(p, SPHERE_POS, SPHERE_R);
    
    float distBlend = mix(sphereHit.dist, torusHit.dist, t);
    
    float displacement = 
        snoise(vec2(p.x * 0.82, iTime * 0.35)) *
        snoise(vec2(p.y * 0.81, iTime * 0.3)) *
        snoise(vec2(p.z * 0.83, iTime * 0.25)) *
        0.8 * t2;
    
    distBlend -= displacement;
    
    Hit hit;
    hit.dist = distBlend;
    hit.color = mix(sphereHit.color, torusHit.color, t);
    return hit;
}

// Function 481
vec2 sdSceneNormal(vec3 pos)
{
	return vec2(sdPlane(pos, -.75), 1.);
}

// Function 482
float dist_to_plot(vec2 p, vec2 fdf) {
    
    vec2 p0 = vec2(p.x, fdf.x);
    vec2 n = normalize(vec2(-fdf.y, 1));
    return abs(dot(p - p0, n));
    
}

// Function 483
Intersection shortestDistanceToSurface(Ray ray, float start, float end) 
{
    Intersection res = Intersection(start, vec3(0.0), obj_null);
    
    vec3 p;
    RC rc; //repeated coordinates
    
    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++) 
    {
        p = ray.origin + res.t * ray.dir;
        float sceneBB_Dist = sdBox( p, sceneBBsize );

        if (sceneBB_Dist<EPSILON)
        {
            #if( SINGLE < 1 )
            	rc = pModGrid(p, jellySpacing);
            	rc.p += 100.0f*N3(rc.id);
            	Intersection intersection = sceneSDF(rc.p);
            #else
            	Intersection intersection = sceneSDF(p);
            #endif
            if (intersection.t < EPSILON) 
            {
                res.color = intersection.color;
                res.objHit = intersection.objHit;
                return res;
            }
            res.t += intersection.t;
            if (res.t >= end) 
            {
                return res;
            }     
        }
        else
        {
            res.t = end + 1.0f;
            return res;
        }
    }
    return res;
}

// Function 484
vec4 mapColor(vec3 c){
  Shape taft = Building(c);
  return taft.color;
}

// Function 485
poly2 pa_map(poly2 f) {
    float wf = mix(0.0,0.3,sin(iTime)*0.5+0.5);
    float wu = mix(1.0,0.0,cos(iTime*0.2)*0.5+0.5);

#if 0
    f = pa_add(pa_mul(f,0.85),wf);

    f = pa_abs(f);
    f = pa_mul(f, -1.0);
    f = pa_add(f, 0.5);
    f = pa_add(f, mix(-0.8,0.3,wu));
    f = pa_abs(f);
    f = pa_add(f, -0.2);
    f = pa_abs(f);
    f = pa_add(f, -0.1);
#endif
#if 0
    poly2 a = pa_add(pa_mul(f,0.9),0.1);
    poly2 b = pa_add(pa_mul(f,-0.2),0.3);
    
    f = pa_smin2(a,b,0.1);
    
    //f.w = max(a.w,b.w);
    
    f = pa_add(f,wf-0.5);
    //f = pa_abs(f);
    f = pa_add(f,0.2);
#endif
#if 0
    poly2 x = pa_add(pa_mul(f, 0.44721),0.2);
    poly2 y = pa_add(pa_mul(f, 0.89443),-0.3);
    
    //f = pa_add(pa_abs(x),pa_abs(y));
    
    f = pa_add(pa_pow2(x),pa_pow2(y));
    //f = pa_sqrt(f);
    f = pa_add(f,-0.9+wf);
    f = pa_mul(f, -0.5);
    f = pa_abs(f);
    f = pa_add(f, -0.3);
#endif
#if 0
    
    poly2 a = pa_pow2(f);
    a = pa_add(a, -0.2);

    poly2 b = pa_pow2(pa_add(f, -0.5));
    b = pa_add(b, -0.2);
    b = pa_unm(b);
    
    f = pa_smin(a,b,0.1);
    
    f = pa_add(f, mix(-0.5,0.5,wu));
    
    
#endif
#if 1
    // rotating cube with subtracted sphere
    poly2 x = pa_const(0.0);
    poly2 y = f;
	poly2 z = pa_const(0.45);
    
    float a = iTime*0.1;
    float s = sin(a);
    float c = cos(a);
    
    poly2 rz = pa_sub(pa_mul(c, z),pa_mul(s, y));
    poly2 ry = pa_add(pa_mul(s, z),pa_mul(c, y));
    
    // cube
    poly2 cube = pa_sub(pa_max(pa_abs(x),pa_max(pa_abs(ry),pa_abs(rz))),0.5);
    
    // sphere
    poly2 sphere = pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(ry)),pa_pow2(pa_sub(rz,0.5))),0.25*0.25);
    
    // subtract sphere from cube
    f = pa_max(cube, pa_unm(sphere));
    
    
#endif
    
    //f = pa_ipol(f, vec2(-1.0, 0.0), vec2(1.0, 1.0), -0.5);
    
    return f;
}

// Function 486
float map(vec3 p)
{
    vec3 q = p;

    pMod3(q, vec3(cos(iTime)*0.1, tan(iTime), sin(iTime)));
    pMod3(q, vec3(1., 0., 0.));
    //
    
    pMod1(p.x, 1.);
    
    float s1 = sphere(p, 0.5); 
    float s2 = sphere(q, 0.5);
    float s3 = sphere(q, 0.7);
    
    float disp = 0.5 * (abs(cos(p.x*10.)) *
                       abs(cos(p.y*10.)) *
                       abs(cos(p.z*10.)) );
    	//s1 += disp;
    	s1 -= disp;
    	
    
    
  	float df1 = min(s1, s2); // Union
    float df2 = max(s1, s2); // Intersection
    float df3 = max(s1, -s3); // Difference
    
    return sin(df2 + df1)*df3;
}

// Function 487
float distance2border(vec3 p)
{
    vec3 a = vec3(size3d - 1.) - p;
    return min(minv(p),minv(a)) + 1.;
}

// Function 488
vec2 sdf(vec3 p){
   vec3 pp = p;

   pp = pp - vec3(1.+sin(iTime*wspeedmod*2.)*.02,.7,.0);
   float head = sdBox(pp,vec3(.5,.4,.5));
   vec3 ppp = pp - vec3(.7,-.1,.0);
   float beak = sdBox(ppp,vec3(.2,.08,.2));
   pp.z = abs(pp.z);
   pp = pp - vec3(.5,.2,.3);
   float eyes = sdBox(pp,vec3(.1,.1,.1));
   
   vec2 h = opU(vec2(eyes,1.0),opU(vec2(beak,2.0),vec2(head,3.0)));

   pp = p;
   rot(pp.xz,-sin(iTime*wspeedmod)*.1);
   float body = sdBox(pp,vec3(1.,.6,.8));
   pp = pp - vec3(-1.1+sin(iTime*wspeedmod*2.)*.02,.7,.0);
   rot(pp.xz,sin(iTime*wspeedmod)*.1);
   float tail = sdBox(pp,vec3(.4,.1,.6));
   body = min(tail,body); 
   vec2 b = opU(vec2(body,3.0),h);
   
   pp = p;
   rot(pp.xy,sin(iTime*wspeedmod)*wstridemod);
   pp = pp - vec3(0.,-1.,lspread);
   float lleg = sdBox(pp,vec3(.1,llength,.2));
   lleg = min(lleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));
   
   pp = p;
   rot(pp.xy,-sin(iTime*wspeedmod)*wstridemod);
   pp = pp - vec3(0.,-1.,-lspread);
   float rleg = sdBox(pp,vec3(.1,llength,.2));
   rleg = min(rleg,sdBox(pp-vec3(.2,-llength,.0),vec3(.4,.1,.2)));
   float legs = min(lleg,rleg);
   
   return opU(vec2(legs,2.0),b);

}

// Function 489
float sceneIntersect(vec3 ro, vec3 rd, out vec3 normal)
{
    float t = 0.;
    float t0 = 0.;
    vec3 boxC = vec3(0);
    int i;
    vec3 p;
    const int ITER = 40;
    vec3 buildingC, buildingSize;
    vec3 _; // Dummy variable
    for(i=0; i<ITER; i++)
    {
        // Intersect building in current box
        getCurrentBuilding(ro, boxC, buildingC, buildingSize);
    	t = boxIntersect(ro-buildingC,
                         rd, buildingSize, normal, _).x;
        
        // Intersect current box itself
        float t1 = boxIntersect(ro-boxC, rd, blockSize, _, _).y;
        
        // Also intersect a floor plane and a sky plane
        float tfloor = -(ro.z-FLOOR)/rd.z;
        if(tfloor < 0.) tfloor = 1e5;
        float tsky = -(ro.z - 20.)/rd.z;
        if(tsky < 0.) tsky = 1e5;
        
        if(t > 0. && t < t1 && t < tfloor)
        {
            // We hit the building!
        	//p = ro+t*rd;
            return t0+t;
            break;
        }
        else if(tfloor > 0. && tfloor < t1)
        {
            // We hit the floor!
            //p = ro+tfloor*rd;
            return T_MAX;
            normal = vec3(0,0,1);
            return t0+tfloor;
        }
        else if(tsky > 0. && tsky < t1)
        {
            // We hit the ceiling!
            return T_MAX;
        }
        // We hit nothing : march to the next cell
        ro += (t1+0.001)*rd;
        t0 += t1;
        p = ro+t1*rd;
        continue;
    }
    return T_MAX;
}

// Function 490
vec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )
{
	vec3 vResultColor = vec3(0.0);
            
	SceneResult firstTraceResult;
    
    float fStartDist = 0.0f;
    float fMaxDist = 10.0f;
    
    vec3 vRemaining = vec3(1.0);
    
	for( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )
    {
    	SceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );

        if ( iPassIndex == 0 )
        {
            firstTraceResult = traceResult;
        }
        
        vec3 vColor = vec3(0);
        vec3 vReflectAmount = vec3(0);
        
		if( traceResult.iObjectId < 0 )
		{
            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;
        }
        else
        {
            
            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );
            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );
                
            // calculate reflectance (Fresnel)
			vReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );
			
			vColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); 
            
            vec3 vReflectRayOrigin = surfaceInfo.vPos;
            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );
            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); 

            vColor += surfaceLighting.vSpecular * vReflectAmount;            

			vColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );
			vColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );
            
            vRayOrigin = vReflectRayOrigin;
            vRayDir = vReflectRayDir;
        }
        
        vResultColor += vColor * vRemaining;
        vRemaining *= vReflectAmount;        
    }
 
    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );
}

// Function 491
vec2 map2ds(vec2 z)
{
  // animation specific hacks
  if (min(abs(z.x),abs(z.y)) < epsilon) return z;  
  
  vec2  z2  = z*z;
  float d   = z2.x+z2.y;
  float uv  = z.x*z.y;
  float suv = sgn(uv)*(1.0/sqrt(2.0));
  float b   = d-4.*uv*uv;
  float s   = suv*sqrt(d-sgn(b)*sqrt(d*abs(b)));
    
  z += epsilon;
  
  return vec2(s/z.y, s/z.x);
}

// Function 492
vec3 toneMapping(vec3 color)
{
    float A = 0.15;
    float B = 0.50;
    float C = 0.10;
    float D = 0.20;
    float E = 0.02;
    float F = 0.30;
    float W = 11.2;
    float GAMMA_CORRECTION_OUT = 1.0 / 2.2;
    color *= exposure;
    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
    return pow(abs(color / white), vec3(GAMMA_CORRECTION_OUT, GAMMA_CORRECTION_OUT, GAMMA_CORRECTION_OUT));
}

// Function 493
float map(vec3 pt) {
    return perlin(pt);
}

// Function 494
vec4 texMapCh(samplerCube tx, vec3 p){
    
    p *= dims;
    int ch = (int(p.x*4.)&3);
    p = mod(floor(p), dims);
    float offset = dot(p, vec3(1, dims.x, dims.x*dims.y));
    vec2 uv = mod(floor(offset/vec2(1, cubemapRes.x)), cubemapRes);
    // It's important to snap to the pixel centers. The people complaining about
    // seam line problems are probably not doing this.
    uv = fract((uv + .5)/cubemapRes) - .5;
    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];
    
}

// Function 495
vec3 GetSceneColourSimple( const in C_Ray ray )
{
	C_HitInfo intersection;
	Raymarch(ray, intersection, 16.0, 32);
			     
	vec3 cScene;
       
	if(intersection.vObjectId.x < 0.5)
	{
		cScene = GetSkyGradient(ray.vDir);
	}
	else
	{
		C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);
		vec3 vNormal = GetSceneNormal(intersection.vPos);
      
		// use sky gradient instead of reflection
		vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));
      
		// apply lighting
		cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );
	}
       
	ApplyAtmosphere(cScene, ray, intersection);
       
	return cScene;
}

// Function 496
vec2 gScene(vec2 p, float e)
{
    return vec2(dScene(p+vec2(e,0)), dScene(p+vec2(0,e))) 
         - vec2(dScene(p-vec2(e,0)), dScene(p-vec2(0,e))); // / 2. / e;
}

// Function 497
float distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )
{
	vec2 e0 = p1 - p0;
	vec2 e1 = p2 - p1;
	vec2 e2 = p0 - p2;

	vec2 v0 = p - p0;
	vec2 v1 = p - p1;
	vec2 v2 = p - p2;

	vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
	vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
	vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    
    float s = sign( e0.x*e2.y - e0.y*e2.x );
    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),
                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),
                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));

	return -sqrt(d.x)*sign(d.y);
}

// Function 498
float mapTheWorld(in vec3 p) {
    float displacement = sin(5.0 * p.x) * cos(5.0 * p.y) * sin(5.0 * p.z) * 0.25;

    float barrel = sdRoundBox(p + vec3(0.0, -0.5, 0.0), vec3(0.1, 0.1, 1.0), 0.06);

    vec3 barrelTipPos = rotateX(PI * 0.5) * p + vec3(0.0, -1.15, -0.55);
    float barrelTipInner = sdCappedCylinder(barrelTipPos, vec2(0.0675, 2.0));
    float tri = sdTriPrism(rotateZ(PI * 0.25) * rotateY(PI * 0.5) * p + vec3(-0.28, -1.1, 0.0), vec2(0.28, 0.28), 0.5);

    float x = sdRoundBox(p + vec3(0.0,-0.2,-0.24), vec3(0.01,0.1,0.1), 0.01);

    barrel = max(barrel, -tri);
    barrel = max(barrel, -barrelTipInner);
    barrel = min(barrel, x);

    vec3 handlePos = rotateX(PI * 0.04) * p + vec3(0.0, 0.0, -0.6);
    float handle = sdRoundBox(handlePos, vec3(0.1, 0.5, 0.25), 0.05);

    float trigger = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.05, 0.2, 0.2), 0.025);
    float triggerHole = sdRoundBox(p + vec3(0.0, -0.3, -0.1), vec3(0.1, 0.14, 0.14), 0.025);

    trigger = max(trigger, -triggerHole);

    float sight = sdTriPrism(p + vec3(0.0, -0.65, 0.65), vec2(0.01, 0.4), 0.1);

    return min(sight, smoothMin(barrel, min(handle, trigger), 0.2));
}

// Function 499
float sphereDist(float3 p, float4 sphere)
{
    return length(p - sphere.xyz) - sphere.w;
}

// Function 500
float mapWater(vec3 p) {
    return sdPlane(p)+heightMapWater(p, iTime);
}

// Function 501
vec2 map(vec3 pos) 
{
    float dist = 10.; 
    dist = opU(dist, fractal(pos));
    dist = smin(dist, fPlane(pos,vec3(0.0,1.0,0.0),10.), 4.6);
    return vec2(dist, 0.);
}

// Function 502
vec4 get_lightmap_tile(int index)
{
    ivec2 addr = ivec2(ADDR_RANGE_LMAP_TILES.xy);
    addr.x += index & 127;
    addr.y += index >> 7;
    return texelFetch(SETTINGS_CHANNEL, addr, 0);
}

// Function 503
float dist(Circle c, vec2 p)
{
    return abs(length(c.ctr-p)-c.rad);
}

// Function 504
void scene3D(out vec4 fragColor, in vec2 fragCoord, in vec4 _status)
{
    vec2 uv = fragCoord/iResolution.xy;
    vec2 ouv = uv;
    float ratio = iResolution.x / iResolution.y;
    uv.x *= ratio;
    vec3 col = vec3(0.);
    vec3 o = vec3(0., 0., 1.75);
    vec3 d = normalize(vec3(-1. + 2.*(uv-vec2(0.4, 0.)), -1.));
    
    mat3 mx, my;
    
    o = get_cam_location(iChannel1);
    
    d = camera(o, d, get_target_vector(iChannel1), 
              get_up_vector(iChannel1));
    
    float mu = dot(d, normalize(vec3(1., 1., 1.)));
    float phaseR = 3./(16.*PI)*(1.+mu*mu);
    float atm_step = 0.1;
    
    float t;
    float eps = trace(o, d, t);
    
    vec3 light = -d;
    
    if (eps < 0.001)
    {
        vec3 p = o + d*t;
        
        vec3 norm = getCentralDiff(o, d, t);
        
        vec2 tuv;
        tuv.x = atan(p.z , p.x)/PI2 + .5;
        tuv.y = .5 + asin(p.y/1.)/PI;
        tuv = clamp(tuv, 0.001, 0.999);
        //tuv.y = SEL_ZONE_Y + (1. - SEL_ZONE_Y)*tuv.y;
        
        vec2 tex = normToTextureUv(tuv, 0., iResolution.xy);
        vec2 ltex = normToTextureUv(tuv, 2., iResolution.xy);
        
        vec3 tcol = texture(iChannel2, tex).xyz;
        float texSpec = texture(iChannel2, ltex).r;
        //float texShine = texture(iChannel2, ltex).g;
        
        float I = dot(light, norm);
        
        vec3 rfl = reflect(light, norm);
        float spec = clamp(dot(rfl, d), 0., 1.);
        col = clamp(0.05*tcol + 0.85*tcol*I + texSpec*pow(spec, 32.), 0., 1.);
    }
    else if (_status.x > 0.5)
    {
        vec2 offset = 10.*get_accumulated_move(iChannel1);
        col = vec3(stars(uv, vec2(.5*ratio, .5), offset));
    }
    
    
    fragColor = vec4(col.xyz, 1.);
}

// Function 505
float sdf(vec3 position, out vec3 diffuseColor, out vec3 emissionColor){
    diffuseColor = vec3(1.);
    emissionColor = vec3(0.);
    float Scale = 2.25;
    float Radius = .25;
    mat3 Rotation;
    
    float time = 15.;
    
    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);
    Scale += sin(time*.5)*.25;
    Radius += cos(time) *.25;
    
	vec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;
	float C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1- /*iterations*/7));
	vec4 p = vec4(position.xyz*Rotation, 1.0), p0 = p;
	for (int i = 0; i<7; i++) {
    	p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    	p.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);
        if(i < 3) p.xyz *= Rotation;
    	p.xyzw = p*scalevec + p0;
	}
    /*diffuseColor = fract(p0.x)<.1 ? vec3(.2) : vec3(1.);
    emissionColor = fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.);*/
	return (length(p.xyz) - C1) / p.w - C2;
}

// Function 506
vec3 scene(vec3 p, vec3 r, vec3 light) {
  vec3 background = vec3(1,1,0.75);
  vec3 color = background;
  vec3 amin = vec3(1e8,0,0);
  float radius2 = 4.0; // Bounding sphere radius
  for (int i = -N; i <= N; i++) {
    for (int j = -N; j <= N; j++) {
      for (int k = -N; k <= N; k++) {
        vec3 centre = 4.0*vec3(i,j,k);
        if (checksphere(p,r,centre,radius2)) {
          int index = (i+N)+(2*N+1)*(j+N+(2*N+1)*(k+N));
          //assert(index >= 0);
          //assert(index < (2*N+1)*(2*N+1)*(2*N+1));
          rhombic(p,r,centre,index,amin);
        }
      }
    }
  }
  if (hitindex >= 0) {
    hitnormal = normalize(hitnormal);
    color = getcolor(hitindex);
    //color *= texture(iChannel0,amin.yz).xyz;
    color *= 0.4+0.6*(max(0.0,dot(hitnormal,light)));
    if (!key(CHAR_F)) color = mix(background,color,max(0.0,maxdist-amin.x)/maxdist);
  }
  return color;
}

// Function 507
float remap(float x, float low1, float high1, float low2, float high2){
	return low2 + (x - low1) * (high2 - low2) / (high1 - low1);
}

// Function 508
vec3 ToneMapFilmic_Hejl2015(vec3 hdr) 
{
    vec4 vh = vec4(hdr, TONEMAP_WHITE_POINT);
    vec4 va = 1.425 * vh + 0.05;
    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;
    return vf.rgb / vf.www;
}

// Function 509
vec3 filmicToneMapping(vec3 color)
{
	color = max(vec3(0.), color - vec3(0.004));
	color = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);


    // May be very wrong? :))))
    color = toGamma(color, 1./3.0);
    color = toGamma(color, gamma);
    
	return color;
}

// Function 510
float dist( in vec2 a, in vec2 b ) {
    float dx = a.x - b.x;
    float dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}

// Function 511
float map(in vec3 pos)
{
    float d = 1e10;
    

    // sphere
    {
    vec3 q = pos - vec3(-3.0,0.0,-1.0);
    d = min( d, sdSphere( q.yzx, 0.4 ) );
    }
    
    // double onion sphere
    {
    vec3 q = pos - vec3(-3.0,0.0,1.0);
    d = min( d, onion(onion( sdSphere( q.yzx, 0.4 ), 0.05 ), 0.02) );
    }

    // cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,-1.0);
    d = min( d, sdCappedCylinder( q, vec2(0.4,0.2) ) );
    }
    
    // single onion cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,1.0);
    d = min( d, onion( sdCappedCylinder( q, vec2(0.4,0.2) ), 0.03) );
    }

    // torus
    {
    vec3 q = pos - vec3(1.0,0.0,-1.0);
    d = min( d, sdTorus( q, vec2(0.4,0.1) ) );
    }
    
    // single onion torus
    {
    vec3 q = pos - vec3(1.0,0.0,1.0);
    d = min( d, onion( sdTorus( q, vec2(0.4,0.1) ), 0.03) );
    }

    // torus
    {
    vec3 q = pos - vec3(3.0,0.0,-1.0);
    d = min( d, sdTorus( q.xzy, vec2(0.5,0.2) ) );
    }
    
    // triple onion torus
    {
    vec3 q = pos - vec3(3.0,0.0,1.0);
    d = min( d, onion(onion(onion(sdTorus( q.xzy, vec2(0.5,0.2) ), 0.08), 0.04), 0.02) );
    }

    // cut it all in half so we can see the interiors
    d = max( d, pos.y );
    
    return d;
}

// Function 512
float trn_detailmap( vec3 pos )
{
    return 1. + .10 * texturenoise( pos / .01 ).x +
        .12 * texturenoise( pos / .003 ).x +
        .15 * texturenoise( pos / .001 ).x +
        .17 * texturenoise( pos / .0003 ).x;
}

// Function 513
float GetDistanceWineGlass( vec3 vPos )
{
    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);
    
    vec2 vSphOrigin = vec2(0,2.0);
    vec2 vSphPos = vPos2 - vSphOrigin;
    
    vec2 vClosest = vSphPos;
    
    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;
    vClosest = normalize(vClosest) * 0.6;
    
    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;
    
    vec2 vStemClosest = vPos2;
    vStemClosest.x = 0.0;    
    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);
    
    float fStemRadius = vStemClosest.y - 0.5;
    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;
    
    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;
    
    
    vec2 norm = normalize( vec2( 0.4, 1.0 ) );
    vec2 vBaseClosest = vPos2;
    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.1), norm ) - 0.2;
    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); 

    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);
    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);
    
    fDistance = max( fDistance, vSphPos.y - 0.5 );
        
    return fDistance;
}

// Function 514
float sdfDensity(vec3 p)
{
    p.y += 3.75;    
    p.xz *= mix(1.0, 1.25, saturate(p.y * .6));
    float d = fBox(p, vec3(2.65, 1., 2.65));    
    float tx = (sin((p.x+ iTime) * 4.0) * .5 + .5) + (sin((p.z+ iTime*3.0) * 4.0) * .5 + .5);
    
    float density = saturate(1.0 - d * .9);    
    density *= tx * pow(length(p.xz) * .3, 12.0) * smoothstep(0.0, 1.0, p.y);
    
    return density + max(0.0, 5.0 - length(p.xz)) * .0025;
}

// Function 515
float scene(vec3 p)
{
    float d=-1e5;
    p=p.xzy;

    d=max(d,2.0-cuboid(p,vec3(-3020.00,-2984.00,64.00),vec3(2996.00,3032.00,5504.00))); // Name=Brush1244
    d=min(d,mountains(p));

    // Name=Brush1247
    d=min(d,cuboid(p,vec3(-432.00,-864.00,800.00),vec3(1232.00,416.00,1880.00))); // Name=Brush852
    d=max(d,2.0-cuboid(p,vec3(-416.00,-848.00,1856.00),vec3(1216.00,400.00,1880.00))); // Name=Brush856
    d=min(d,cuboid(p,vec3(-304.00,-736.00,1856.00),vec3(1104.00,288.00,2208.00))); // Name=Brush858
    d=min(d,cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00))); // Name=Brush854
    d=min(d,cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00))); // Name=Brush860
    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 2406.554199,dot(p,vec3(-0.941742,0.000000,0.336336)) - 477.866821);
     d=max(d,2.0-max(pls,cuboid(p,vec3(472.00,-992.00,1696.00),vec3(552.00,-864.00,2144.00)))); // Name=Brush82
    }
    { float pls=max(dot(p,vec3(0.941742,0.000000,0.336336)) - 1653.160645,dot(p,vec3(-0.941742,0.000000,0.336336)) - 1231.260254);
     d=max(d,2.0-max(pls,cuboid(p,vec3(72.00,-992.00,1696.00),vec3(152.00,-864.00,2144.00)))); // Name=Brush84
    }
    d=min(d,cuboid(p,vec3(-1128.00,-608.00,1248.00),vec3(-360.00,160.00,1472.00))); // Name=Brush86
    d=min(d,cuboid(p,vec3(-1896.00,-608.00,672.00),vec3(-1128.00,16.00,1152.00))); // Name=Brush88
    d=max(d,2.0-cuboid(p,vec3(-1880.00,-592.00,1120.00),vec3(-1368.00, 0.00,1152.00))); // Name=Brush90
    d=max(d,2.0-cuboid(p,vec3(-1112.00,-592.00,1440.00),vec3(-440.00,144.00,1472.00))); // Name=Brush92
    d=min(d,cuboid(p,vec3(-1752.00,-480.00,1120.00),vec3(-1368.00,-96.00,1376.00))); // Name=Brush94
    d=min(d,cuboid(p,vec3(-1160.00,-640.00,672.00),vec3(-1000.00,-480.00,1568.00))); // Name=Brush113
    d=min(d,cuboid(p,vec3(-1160.00,32.00,672.00),vec3(-1000.00,192.00,1568.00))); // Name=Brush105
    d=min(d,cuboid(p,vec3(-424.00,288.00,672.00),vec3(1256.00,736.00,2208.00))); // Name=Brush106
    d=max(d,2.0-cuboid(p,vec3(-408.00,288.00,1856.00),vec3(-296.00,400.00,2016.00))); // Name=Brush107
    d=max(d,2.0-cuboid(p,vec3(1112.00,288.00,1856.00),vec3(1224.00,400.00,2016.00))); // Name=Brush108
    d=max(d,2.0-cuboid(p,vec3(-232.00,-672.00,1856.00),vec3(1048.00,288.00,2208.00))); // Name=Brush118
    d=min(d,cuboid(p,vec3(-808.00,-416.00,1440.00),vec3(-424.00,-32.00,1880.00))); // Name=Brush109
    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2313.337891,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.897705,max(dot(p,vec3(0.847998,-0.000000,-0.529999)) - -1960.569824,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543457)));
     d=min(d,max(pls,cuboid(p,vec3(-76.00,-1072.00,2208.00),vec3(284.00,-592.00,2400.00)))); // Name=Brush120
    }
    { float pls=max(dot(p,vec3(-0.847999,0.000000,-0.529998)) - -2991.736328,max(dot(p,vec3(-0.000001,-0.768222,-0.640184)) - -1302.898071,max(dot(p,vec3(0.847999,-0.000000,-0.529998)) - -1282.169800,dot(p,vec3(-0.000000,0.768221,-0.640184)) - -3859.543701)));
     d=min(d,max(pls,cuboid(p,vec3(324.00,-1072.00,2208.00),vec3(684.00,-592.00,2400.00)))); // Name=Brush121
    }
    d=min(d,cuboid(p,vec3(224.00,-936.00,1920.00),vec3(384.00,-912.00,1952.00))); // Name=Brush122
    d=min(d,cuboid(p,vec3(408.00,-480.00,1856.00),vec3(1112.00,736.00,2720.00))); // Name=Brush123
    d=max(d,2.0-cuboid(p,vec3(-64.00,-1056.00,2360.00),vec3(272.00,-608.00,2400.00))); // Name=Brush124
    d=max(d,2.0-cuboid(p,vec3(336.00,-1056.00,2360.00),vec3(672.00,-608.00,2400.00))); // Name=Brush125
    d=min(d,cuboid(p,vec3(472.00,-592.00,2304.00),vec3(600.00,-480.00,2400.00))); // Name=Brush126
    d=max(d,2.0-cuboid(p,vec3(488.00,-608.00,2360.00),vec3(584.00,-480.00,2400.00))); // Name=Brush127
    d=min(d,cuboid(p,vec3(284.00,-864.00,2304.00),vec3(324.00,-736.00,2400.00))); // Name=Brush128
    d=max(d,2.0-cuboid(p,vec3(272.00,-848.00,2360.00),vec3(336.00,-752.00,2400.00))); // Name=Brush129
    d=max(d,2.0-cuboid(p,vec3(72.00,-1072.00,2360.00),vec3(136.00,-1056.00,2400.00))); // Name=Brush130
    d=max(d,2.0-cuboid(p,vec3(472.00,-1072.00,2360.00),vec3(536.00,-1056.00,2400.00))); // Name=Brush131
    { float pls=max(dot(p,vec3(0.664365,0.000000,0.747409)) - 3130.480957,dot(p,vec3(-0.664365,0.000000,0.747409)) - 2322.613525);
     d=max(d,2.0-max(pls,cuboid(p,vec3(232.00,-944.00,1568.00),vec3(376.00,-720.00,1824.00)))); // Name=Brush132
    }
    d=max(d,2.0-cuboid(p,vec3(24.00,-720.00,1568.00),vec3(600.00,-544.00,1824.00))); // Name=Brush39
    d=max(d,2.0-cuboid(p,vec3(488.00,-480.00,2360.00),vec3(584.00,-464.00,2504.00))); // Name=Brush40
    d=max(d,2.0-cuboid(p,vec3(424.00,-464.00,2360.00),vec3(984.00,-192.00,2688.00))); // Name=Brush41
    d=max(d,2.0-cuboid(p,vec3(424.00,288.00,2208.00),vec3(760.00,720.00,2688.00))); // Name=Brush46
    d=max(d,2.0-cuboid(p,vec3(408.00,552.00,2208.00),vec3(424.00,680.00,2336.00))); // Name=Brush93
    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,2192.00),vec3(408.00,720.00,2208.00))); // Name=Brush49
    d=max(d,2.0-cuboid(p,vec3(280.00,288.00,2192.00),vec3(408.00,304.00,2208.00))); // Name=Brush50
    { float pls=dot(p,vec3(0.000000,0.316228,0.948683)) - 4690.290527;
     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(632.00,600.00,2376.00)))); // Name=Brush53
    }
    { float pls=dot(p,vec3(-0.406138,0.000000,0.913812)) - 3651.997070;
     d=min(d,max(pls,cuboid(p,vec3(472.00,600.00,2208.00),vec3(616.00,720.00,2272.00)))); // Name=Brush54
    }
    d=min(d,cuboid(p,vec3(616.00,480.00,2208.00),vec3(760.00,720.00,2272.00))); // Name=Brush55
    d=min(d,cuboid(p,vec3(616.00,352.00,2208.00),vec3(760.00,416.00,2272.00))); // Name=Brush56

    // Name=Brush58
    d=min(d,tower(p.xzy));

    { float pls=dot(p,vec3(0.000000,0.307820,0.951445)) - 4668.122559;
     d=min(d,max(pls,cuboid(p,vec3(616.00,288.00,2272.00),vec3(760.00,560.00,2360.00)))); // Name=Brush65
    }
    d=min(d,cuboid(p,vec3(-496.00,-2136.00,672.00),vec3(592.00,-1688.00,1584.00))); // Name=Brush66
    d=max(d,2.0-cuboid(p,vec3(80.00,-1704.00,1448.00),vec3(144.00,-1688.00,1512.00))); // Name=Brush69
    d=max(d,2.0-cuboid(p,vec3(-176.00,-1704.00,1448.00),vec3(-112.00,-1688.00,1512.00))); // Name=Brush70
    d=max(d,2.0-cuboid(p,vec3(-432.00,-1704.00,1448.00),vec3(-368.00,-1688.00,1512.00))); // Name=Brush71

    // Name=Brush72
    d=min(d,smallerTower(p.xzy));

    { float pls=max(dot(p,vec3(-0.707107,0.000000,-0.707106)) - 531.747742,max(dot(p,vec3(-0.000001,-0.707107,-0.707106)) - -1267.131348,max(dot(p,vec3(0.707107,-0.000000,-0.707106)) - -3880.601807,dot(p,vec3(-0.000000,0.707107,-0.707107)) - -2081.721680)));
     d=min(d,max(pls,cuboid(p,vec3(-1848.00,-576.00,1376.00),vec3(-1272.00, 0.00,1568.00)))); // Name=Brush73
    }
    d=max(d,2.0-cuboid(p,vec3(-1831.53,-559.53,1536.00),vec3(-1288.47,-16.47,1568.00))); // Name=Brush866
    d=min(d,cuboid(p,vec3(-1368.00,-352.00,1120.00),vec3(-1112.00,-96.00,1568.00))); // Name=Brush864
    { float pls=dot(p,vec3(-0.316228,0.000000,-0.948683)) - -2028.916870;
     d=max(d,2.0-max(pls,cuboid(p,vec3(-1368.00,-328.00,1440.00),vec3(-1112.00,-120.00,1568.00)))); // Name=Brush76
    }
    d=min(d,cuboid(p,vec3(152.00,-560.00,1568.00),vec3(176.00,-544.00,1824.00))); // Name=Brush95
    d=min(d,cuboid(p,vec3(448.00,-560.00,1568.00),vec3(472.00,-544.00,1824.00))); // Name=Brush97
    d=min(d,cuboid(p,vec3(176.00,-544.00,1568.00),vec3(448.00,-536.00,1824.00))); // Name=Brush99
    d=min(d,cuboid(p,vec3(232.00,-804.00,1706.00),vec3(376.00,-796.00,1718.00))); // Name=Brush155
    { float pls=max(dot(p,vec3(0.000000,-0.470588,0.882353)) - 3512.470703,dot(p,vec3(0.000000,0.454709,-0.890640)) - -3531.819092);
     d=min(d,max(pls,cuboid(p,vec3(-232.00,48.00,2016.00),vec3(264.00,288.00,2144.00)))); // Name=Brush159
    }
    d=max(d,2.0-cuboid(p,vec3(-616.00,-400.00,1856.00),vec3(-408.00,-48.00,1880.00))); // Name=Brush167
    d=min(d,cuboid(p,vec3(-664.00,-288.00,1856.00),vec3(-520.00,-160.00,2048.00))); // Name=Brush168
    d=max(d,2.0-cuboid(p,vec3(-664.00,-256.00,1856.00),vec3(-520.00,-192.00,2016.00))); // Name=Brush169
    { float pls=max(dot(p,vec3(0.229039,0.000000,-0.973417)) - -3312.824951,dot(p,vec3(-0.229039,0.000000,0.973417)) - 3530.870605);
     d=max(d,2.0-max(pls,cuboid(p,vec3(-1384.00,-328.00,1376.00),vec3(-1112.00,-240.00,1552.00)))); // Name=Brush265
    }
    d=max(d,2.0-cuboid(p,vec3(-408.00,304.00,1856.00),vec3(1240.00,416.00,2016.00))); // Name=Brush323
    d=min(d,cuboid(p,vec3(-1384.00,-352.00,1505.50),vec3(-1309.00,-240.00,1568.00))); // Name=Brush353
    { float pls=dot(p,vec3(-0.311770,0.000000,-0.950157)) - -2045.926514;
     d=max(d,2.0-max(pls,cuboid(p,vec3(-1400.00,-240.00,1525.50),vec3(-1368.00,-120.00,1536.00)))); // Name=Brush355
    }
    d=max(d,2.0-cuboid(p,vec3(88.00,-608.00,2360.00),vec3(152.00,-592.00,2400.00))); // Name=Brush360
    d=max(d,2.0-cuboid(p,vec3(384.00,-896.00,1568.00),vec3(392.00,-864.00,1584.00))); // Name=Brush523
    d=max(d,2.0-cuboid(p,vec3(232.00,-896.00,1568.00),vec3(240.00,-864.00,1584.00))); // Name=Brush524
    // Name=Brush784
    // Name=Brush785
    d=min(d,cuboid(p,vec3(224.00,-1824.00,688.00),vec3(384.00,-864.00,1584.00))); // Name=Brush851
    { float pls=max(dot(p,vec3(0.000000,0.576682,0.816969)) - 741.234497,dot(p,vec3(0.000000,-0.576682,0.816969)) - 3859.928955);
     d=max(d,2.0-max(pls,cuboid(p,vec3(224.00,-1488.00,736.00),vec3(384.00,-1216.00,1408.00)))); // Name=Brush853
    }
    d=min(d,cuboid(p,vec3(216.00,-1488.00,688.00),vec3(392.00,-1442.00,1312.00))); // Name=Brush855
    { float pls=max(dot(p,vec3(0.000000,0.536233,-0.844070)) - -3762.050537,dot(p,vec3(0.000000,-0.576683,0.816968)) - 3859.932861);
     d=min(d,max(pls,cuboid(p,vec3(216.00,-1488.00,1312.00),vec3(392.00,-1352.00,1408.00)))); // Name=Brush857
    }
    { float pls=max(dot(p,vec3(0.000000,-0.536233,-0.844070)) - -862.103333,dot(p,vec3(0.000000,0.576683,0.816968)) - 741.230042);
     d=min(d,max(pls,cuboid(p,vec3(216.00,-1352.00,1312.00),vec3(392.00,-1216.00,1408.00)))); // Name=Brush859
    }
    d=min(d,cuboid(p,vec3(216.00,-1262.00,688.00),vec3(392.00,-1216.00,1312.00))); // Name=Brush861
    d=max(d,2.0-cuboid(p,vec3(232.00,-1824.00,1568.00),vec3(376.00,-864.00,1584.00))); // Name=Brush865
    d=max(d,2.0-cuboid(p,vec3(-480.00,-2112.00,1568.00),vec3(576.00,-1704.00,1584.00))); // Name=Brush867
    d=min(d,cuboid(p,vec3(376.00,-1728.00,1376.00),vec3(456.00,-1648.00,1632.00))); // Name=Brush67
    d=min(d,cuboid(p,vec3(152.00,-1728.00,1376.00),vec3(232.00,-1648.00,1632.00))); // Name=Brush68
    d=min(d,cuboid(p,vec3(224.00,-1448.00,872.00),vec3(384.00,-1256.00,928.00))); // Name=Brush1140
    { float pls=max(dot(p,vec3(-0.832049,0.000000,0.554702)) - 2658.138916,dot(p,vec3(0.832049,0.000000,0.554702)) - 5187.567871);
     d=max(d,2.0-max(pls,cuboid(p,vec3(728.00,-416.00,3392.00),vec3(792.00,-384.00,3536.00)))); // Name=Brush1229
    }
    { float pls=dot(p,vec3(-0.707107,0.000000,-0.707107)) - -1448.154785;
     d=min(d,max(pls,cuboid(p,vec3(-544.00,-592.00,1440.00),vec3(-416.00,-400.00,1696.00)))); // Name=Brush57
    }
    d=max(d,2.0-cuboid(p,vec3(-544.00,-544.00,1440.00),vec3(-400.00,-416.00,1552.00))); // Name=Brush60
    { float pls=dot(p,vec3(0.000000,-0.780869,-0.624695)) - -1214.406372;
     d=min(d,max(pls,cuboid(p,vec3(-432.00,-464.00,1492.00),vec3(-352.00,-416.00,1552.00)))); // Name=Brush63
    }
    { float pls=dot(p,vec3(0.000000,0.780869,-0.624695)) - -2713.674805;
     d=min(d,max(pls,cuboid(p,vec3(-432.00,-544.00,1492.00),vec3(-352.00,-496.00,1552.00)))); // Name=Brush74
    }
    { float pls=max(dot(p,vec3(-0.975610,-0.000000,0.219512)) - 282.536896,max(dot(p,vec3(0.871576,0.000000,0.490261)) - 2339.308105,max(dot(p,vec3(-0.800001,-0.000000,0.599999)) - 1638.397461,dot(p,vec3(-0.284087,0.000000,0.958798)) - 3174.972900)));
     d=max(d,2.0-max(pls,cuboid(p,vec3(208.00,-2848.00,1568.00),vec3(400.00,-2112.00,1760.00)))); // Name=Brush465
    }
    // Name=Brush869
    // Name=Brush862
    d=min(d,cuboid(p,vec3(-844.00,-228.00,2664.00),vec3(-836.00,-220.00,2920.00))); // Name=Brush100
    d=min(d,cuboid(p,vec3(1220.00,-860.00,1856.00),vec3(1228.00,-852.00,2112.00))); // Name=Brush10
    // Name=Brush1175
    // Name=Brush111
    // Name=Brush114
    // Name=Brush115
    // Name=Brush116
    // Name=Brush117
    // Name=Brush119
    d=min(d,cuboid(p,vec3(408.00,-480.00,2720.00),vec3(424.00,736.00,2752.00))); // Name=Brush110
    d=min(d,cuboid(p,vec3(1096.00,-480.00,2720.00),vec3(1112.00,736.00,2752.00))); // Name=Brush112
    d=min(d,cuboid(p,vec3(424.00,720.00,2720.00),vec3(1096.00,736.00,2752.00))); // Name=Brush42
    d=min(d,cuboid(p,vec3(424.00,-480.00,2720.00),vec3(1096.00,-464.00,2752.00))); // Name=Brush43
    // Name=Brush101
    { float pls=dot(p,vec3(0.000000,-0.430730,0.902481)) - 3708.376465;
     d=min(d,max(pls,cuboid(p,vec3(280.00,-416.00,1856.00),vec3(408.00,288.00,2192.00)))); // Name=Brush51
    }
    { float pls=dot(p,vec3(0.000000,-0.431455,0.902134)) - 3735.306152;
     d=min(d,max(pls,cuboid(p,vec3(264.00,-448.00,1856.00),vec3(280.00,288.00,2208.00)))); // Name=Brush52
    }
    // Name=Brush1
    d=min(d,cuboid(p,vec3(188.00,-1692.00,1408.00),vec3(196.00,-1684.00,1664.00))); // Name=Brush9
    d=min(d,cuboid(p,vec3(412.00,-1692.00,1408.00),vec3(420.00,-1684.00,1664.00))); // Name=Brush44
    d=max(d,2.0-cuboid(p,vec3(1096.00,520.00,2736.00),vec3(1112.00,648.00,2752.00))); // Name=Brush91
    { float pls=max(dot(p,vec3(-0.195090,0.980785,0.000000)) - 668.334656,max(dot(p,vec3(0.195090,-0.980785,0.000000)) - -604.334656,max(dot(p,vec3(0.980785,0.195091,-0.000000)) - 2393.832764,dot(p,vec3(-0.980785,-0.195091,0.000000)) - -2361.832764)));
     d=min(d,max(pls,cuboid(p,vec3(1093.03,526.75,2736.00),vec3(1114.97,561.25,2752.00)))); // Name=Brush61
    }
    d=min(d,cuboid(p,vec3(1069.26,618.11,2719.03),vec3(1106.74,645.89,2752.97))); // Name=Brush64
    { float pls=max(dot(p,vec3(-0.471398,0.881921,0.000000)) - 73.059395,max(dot(p,vec3(0.471398,-0.881921,0.000000)) - -9.059571,max(dot(p,vec3(0.881922,0.471395,-0.000000)) - 2450.862061,dot(p,vec3(-0.881922,-0.471395,0.000000)) - -2418.862305)));
     d=min(d,max(pls,cuboid(p,vec3(1049.40,574.12,2720.00),vec3(1078.60,609.88,2736.00)))); // Name=Brush75
    }
    // Name=Brush78
    // Name=Brush80
    d=max(d,2.0-cuboid(p,vec3(800.00,720.00,2736.00),vec3(928.00,736.00,2752.00))); // Name=Brush83
    { float pls=max(dot(p,vec3(-0.773011,0.634392,0.000000)) - -355.351471,max(dot(p,vec3(0.773011,-0.634392,0.000000)) - 419.351379,max(dot(p,vec3(0.634392,0.773011,-0.000000)) - 2217.433838,dot(p,vec3(-0.634392,-0.773011,0.000000)) - -2185.433838)));
     d=min(d,max(pls,cuboid(p,vec3(830.56,711.67,2736.00),vec3(865.44,744.33,2752.00)))); // Name=Brush85
    }
    { float pls=max(dot(p,vec3(-0.923879,-0.382685,0.000000)) - -2156.288574,max(dot(p,vec3(0.923879,0.382685,-0.000000)) - 2220.288574,max(dot(p,vec3(-0.382683,0.923880,0.000000)) - 616.273071,dot(p,vec3(0.382683,-0.923880,0.000000)) - -584.272949)));
     d=min(d,max(pls,cuboid(p,vec3(878.16,682.49,2720.00),vec3(913.84,709.51,2736.00)))); // Name=Brush87
    }
    { float pls=max(dot(p,vec3(-0.509803,0.000000,0.860291)) - 2943.598877,max(dot(p,vec3(0.947492,0.000000,0.319779)) - -100.432518,max(dot(p,vec3(-0.975610,0.000000,-0.219512)) - 888.975403,dot(p,vec3(-0.970143,0.000000,0.242536)) - 1967.017944)));
     d=max(d,2.0-max(pls,cuboid(p,vec3(-720.00,1632.00,1104.00),vec3(-464.00,1888.00,1360.00)))); // Name=Brush259
    }
    d=min(d,cuboid(p,vec3(-720.00,1696.00,1104.00),vec3(-568.00,1888.00,1164.00))); // Name=Brush402
    d=min(d,cuboid(p,vec3(-720.00,1696.00,1164.00),vec3(-568.00,1712.00,1180.00))); // Name=Brush467
    d=min(d,cuboid(p,vec3(-584.00,1816.00,1164.00),vec3(-568.00,1888.00,1180.00))); // Name=Brush469
    d=min(d,cuboid(p,vec3(-720.00,1712.00,1164.00),vec3(-704.00,1888.00,1180.00))); // Name=Brush470
    { float pls=dot(p,vec3(-0.355995,0.000000,0.934488)) - 3215.349365;
     d=min(d,max(pls,cuboid(p,vec3(-736.00, 4.00,1440.00),vec3(-568.00,108.00,1504.00)))); // Name=Brush48
    }
    d=max(d,2.0-cuboid(p,vec3(-702.67,1888.00,1164.00),vec3(-576.00,2176.00,1284.00))); // Name=Brush2
    // Name=Brush133

    d=min(d,p.z-1400.0);

    return d;
}

// Function 516
float line_dist(vec2 uv, const vec2 p0, vec2 p1){
	vec2 tang=p1-p0;
	vec2 nor=normalize(vec2(tang.y,-tang.x));

	if(dot(tang,uv)<dot(tang,p0)){
		return distance(p0,uv);
	}
	else if(dot(tang,uv)>dot(tang,p1)){
		return distance(p1,uv);
	}
	else{
		return dot(nor,uv)-dot(nor,p0);
	}
}

// Function 517
float cylinderSDF( vec3 p, vec3 c )
{
  return length(p.xz-c.xy)-c.z;
}

// Function 518
float GetFlowDistance( const vec2 vPos )
{
    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );
}

// Function 519
float dist2obj(vec3 p, in object o)
{
    return udTriangle(p, o.a, o.b, o.c) - 0.003;
}

// Function 520
float heightmap(vec2 uv)
{
    return (texture(iChannel0, uv.yx / 256.).r - .1) * 2.;
}

// Function 521
float getDist2Plane(vec3 camPos, vec3 ray) {
    float ang = getAngle(vec3(0.0, - 1.0, 0.0), ray);
    float dist = abs(camPos.y);
    if (hitPlane(camPos, ray) < 0.0) {
        return dist / cos(ang);
    } else {
        return INFTY;
    }
}

// Function 522
vec3 sample_grad_dist(vec2 uv, float font_size) {
    
    vec3 grad_dist = (textureLod(iChannel0, uv, 0.).yzw - FONT_TEX_BIAS) * font_size;

    grad_dist.y = -grad_dist.y;
    grad_dist.xy = normalize(grad_dist.xy + 1e-5);
    
    return grad_dist;
    
}

// Function 523
float Map( vec3 p )
{
	float scale = 1.0;
	
	for( int i=0; i < 12;i++ )
	{
		p = 2.0*clamp(p, -CSize, CSize) - p;
		float r2 = dot(p,p);
		float k = max((1.1)/(r2), .03);
		p     *= k;
		scale *= k;
	}
	float l = length(p.xy);
	float rxy = l - 4.0;
	float n = l * p.z;
	rxy = max(rxy, -(n) / (length(p))-.1);
	return (rxy) / abs(scale);
}

// Function 524
vec4 map(vec3 p)
{
    vec4 sd = opU( sdFractal(p.xzy - vec3(14,0,0), FRACTAL_ITER, vec2(35,35),  iFracScale),
                   sdFractal(p.xzy - vec3(0,-30,-60), 5.,  vec2(100,100),  iFracScale*0.5));
    return sd;
}

// Function 525
float sdfPlane(vec3 pos, vec3 p, vec4 n){
  p = pos - p;
  n = normalize(n);
  return dot(p,n.xyz) + n.w;
}

// Function 526
float mapSeedNoLight(vec2 f)
{
    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);
    return length((floor(seedCoord)-floor(f)))-seedColor.z*circSizeMult*iResolution.x;
}

// Function 527
void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 d )
{
    if ( max(d.x, max(d.y,d.z)) != d.z ) return; // we want only face 1 
    
    //U -= .5;
    if (iFrame==0) { O = vec4(0); return; }
    vec2 R = iResolution.xy, I;
                                                // --- set multigrid LOD
  //int n = max(0, int( log2(R.y) -4. - log2(float(1+iFrame/60/2)) ));
    int n = max(0, int( log2(R.y) -2. - float(iFrame/60) )); // what is optimum duration per level ?
  //n = 3;
    U =       U / float(1<<n); I = floor(U);
    R = floor(R / float(1<<n));
    
    O = T(U,0,0, n);                            
                                                // --- Laplacian solver. 
 // vec4 D = (   T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) - 4.*O ) / 4.;
 // vec4 D = (   T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) // higher orders: https://en.wikipedia.org/wiki/Discrete_Laplace_operator
 //            + T(U,1,1,n) + T(U,-1,1,n) + T(U,1,-1,n) + T(U,-1,-1,n)
 //             - 8.*O ) / 8.;
    vec4 D = ( 2.*( T(U,1,0,n) + T(U,-1,0,n) + T(U,0, 1,n) + T(U, 0,-1,n) )
               +    T(U,1,1,n) + T(U,-1,1,n) + T(U,1,-1,n) + T(U,-1,-1,n)
               - 12.*O ) / 12.;
    O += D;  // apparently stable even with coef 1
    
                                                // --- set border constraints
#if 0
    O =  I.y==0. || I.y==R.y-1. ? vec4(I.x/(R.x-1.)) 
       : I.x==0. ? vec4(0) : I.x==R.x-1. ? vec4(1)
       : O;
#else
    O =  I.x==0. ? vec4(1,0,0,1) : I.x==R.x-1. ? vec4(0,1,0,1)
       : I.y==0. ? vec4(0,0,1,1) : I.y==R.y-1. ? vec4(1,1,1,1)
       : O;
#endif
                                                // --- mouse paint
    vec2 M = texelFetch(iChannel1,ivec2(0),0).xy;   // get normalized mouse position
    if ( length(M)>.1 && length(I/R-M)<.1) O = vec4(I.x/R.x > M.x);
}

// Function 528
void init_scene() {

    // Light Sphere
	material lightSurface;
	lightSurface.albedo = vec3(1.0);
	lightSurface.emission = vec3(70.0);
	lightSurface.roughness =1.0;
	lightSurface.specular = 1.0;
	lightSurface.metalness = 1.0;
    spheres[0] = Sphere(vec3(0.0, 5.8, 1.0), 4.1, lightSurface);
    // Light Sphere 2
    lightSurface.emission = vec3(10.0);
    spheres[8] = Sphere(vec3(4.0, 0.4, 0.7), 0.3, lightSurface);

    
    // Diffuse sphere
	material diffuseSurface;
	diffuseSurface.albedo = vec3(0.1, 0.1 ,0.10);
	diffuseSurface.emission = vec3(0.0);
	diffuseSurface.roughness = 0.9;
	diffuseSurface.specular = 0.1;
	diffuseSurface.metalness = 0.0;
    spheres[1] = Sphere(vec3(1.3, -0.5, -2.2), 1.0, diffuseSurface);
    spheres[5] = Sphere(vec3(-3.3, 0.8, -1.0), 0.5, diffuseSurface);

    // Metal sphere
	material metalSurface;
	metalSurface.albedo = vec3(0.5, 0.5 ,0.5);
	metalSurface.emission = vec3(0.0);
	metalSurface.roughness = 1.0;
	metalSurface.specular = 1.0;
	metalSurface.metalness = 1.0;
    spheres[2] = Sphere(vec3(-3.0, -0.7, -0.8), 0.5, metalSurface);
    spheres[11] = Sphere(vec3(0.0, -0.7, -0.8), 0.5, metalSurface);
    spheres[12] = Sphere(vec3(4.0, -0.7, -0.8), 0.5, diffuseSurface);

    // Magenta metal sphere
	metalSurface.albedo = vec3(1.0, 0.1 ,1.0);
    spheres[3] = Sphere(vec3(-2.0, 0.3, -1.8), 0.5, metalSurface);
    spheres[7] = Sphere(vec3(2.8, 0.6, 0.5), 0.7, metalSurface);

    // Cyan metal spheres
	metalSurface.albedo = vec3(0.2, 1.0 ,1.0);
    spheres[4] = Sphere(vec3(-0.7, 0.7, -1.8), 0.5, metalSurface);
    spheres[6] = Sphere(vec3(-0.7, -0.7, -1.3), 0.4, metalSurface);
    spheres[10] = Sphere(vec3(0.7, 0.7, -1.3), 0.3, metalSurface);
    spheres[13] = Sphere(vec3(3.5, 0.7, 2.3), 0.3, metalSurface);
    spheres[14] = Sphere(vec3(-2.7, 0.4, 2.6), 0.2, metalSurface);

    // Yellow metal sphere
	metalSurface.albedo = vec3(1.0, 1.0 ,0.1);
    spheres[9] = Sphere(vec3(-3.5, 0.8, 2.0), 0.4, metalSurface);


    // Room material
	material roomSurface;
	roomSurface.albedo = vec3(0.8);
	roomSurface.emission = vec3(0.0);
	roomSurface.roughness = 1.0;
	roomSurface.specular = 0.0;
	roomSurface.metalness = 0.0;
    
	// Floor
    planes[0] = Plane(vec3(0.0, -1.5, 0.0), vec3(0,1,0), roomSurface);

	// Ceiling
    planes[1] = Plane(vec3(0.0, 2.0, 0.0), vec3(0.0,-1.0,0.0), roomSurface);
                     
    // Back wall            
    planes[2] = Plane(vec3(0, 0, -5), vec3(0,0,1.0), roomSurface);
      
    // Left wall (red)
	roomSurface.albedo = vec3(0.95, 0, 0);
    planes[3] = Plane(vec3(-5, 0.0, 0.0), vec3(1.0,0.0,0.5), roomSurface);
    
    // Right wall (green)
	roomSurface.albedo = vec3(0.0, 0.95, 0);
    planes[4] = Plane(vec3(5.0, 0.0, 0.0), vec3(-1.0,0,0.5), roomSurface);


}

// Function 529
maybe_float get_distance_along_3d_line_to_circle(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 N,
    in float r
){
    // intersection(plane, sphere)
    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);
    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));
}

// Function 530
vec4 nmaps(vec4 x){ return x*2.-1.; }

// Function 531
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 objCol;
  vec3 col, vn, ltVec;
  vec2 rq;
  float dstObj, dstSmk, d, reflFac, f;
  dstSmk = SmkBallHit (ro, rd);
  if (dstSmk < dstFar) vnSmk = VaryNf (32. * (ro + dstSmk * rd), vnSmk, 2.);
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += rd * dstObj;
    vn = ObjNf (ro);
    tunWl = (idObj == idTun) ? step (tunRad - 0.1 * trkWid,
       length (vec2 (length (ro.xz) - trkRad, ro.y - tunUp))) : 0.;
    if (idObj == idGrnd) objCol = GrndCol (ro, vn);
    else objCol = SceneCol (ro);
    if (idObj == idGrnd) vn = VaryNf (vec3 (4., 2., 4.) * ro, vn, 1.);
    else if (idObj == idRbase || idObj == idSlp || idObj == idVia) vn = VaryNf (64. * ro, vn, 1.);
    else if (idObj == idTun) vn = VaryNf (16. * ro, vn, 2.);
    col = objCol.rgb;
    if (objCol.a >= 0.) {
      if (ro.z - 0.3 * ro.y > 2.2 && tunWl == 0. && idObj != idGrnd && idObj != idVia) {
        if (idObj == idEng || idObj == idCar) {
          col *= 0.2 + (0.07 + 0.13 * max (vn.y, 0.)) * (1. - smoothstep (4., 6., dstObj));
          if (idObj == idEng && qHit.y > -1. && vn.y > 0.2 || idObj == idCar && qHit.y > -1.) {
            rq = ro.xz + (tunRad - 0.1 * trkWid - ro.y) * reflect (rd, vn).xz;
            if (abs (length (rq) - trkRad) < 0.2 * trkWid && abs (mod (32. *
               atan (rq.y, rq.x) / (2. * pi), 1.) - 0.125) < 0.04) col = mix (col, vec3 (0.8, 0.8, 0.4), 0.2);
          }
        } else {
          if (idObj != idTun) col *= 0.4 + 0.3 * max (vn.y, 0.);
          ltVec = vec3 (TrackPath (trDir * (trMov + 12. * szFac / trkRad)), 0.5 * szFac).xzy - ro;
          f = length (ltVec);
          col *= 0.3 + (0.7 + 0.5 * max (dot (vn, ltVec), 0.) / f) / (1. + 0.8 * pow (f, 1.5));
        }
      } else {
        col = col * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +
           objCol.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);
        if (abs (length (ro.xz) - trkRad) < 1.2 * trkWid && (idObj == idRbase || idObj == idSlp ||
           idObj == idRail)) {
          for (int k = 0; k < MAX_CAR; k ++) {
            if (k == nCar) break;
            if ((pi - abs (mod (atan (- ro.x, ro.z) + pi - trDir * (trMov - (float (k) * 6.4 +
               ((k > 0) ? 0.3 : 0.)) * szFac / trkRad), 2. * pi) - pi)) * trkRad < 0.615) {
              col *= 0.7;
              break;
            }
          }
        }
        reflFac = 0.;
        if (idObj == idEng && abs (abs (qHit.x) - 0.5) < 0.37 && abs (qHit.y - 1.1) < 0.17 ||
           idObj == idCar && (abs (qHit.y - 0.6) < 0.55 && (abs (qHit.x) < 0.45 ||
           abs (abs (qHit.z) - 1.2) < 1.))) reflFac = 0.8;
        else if (idObj == idEng || idObj == idFun || idObj == idCar || idObj == idRail) reflFac = 0.1;
        if (reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, reflect (rd, vn)), reflFac);
        if (idObj == idGrnd) col +=
          256. * pow (clamp (0.5 + 0.5 * dot (sunDir, reflect (rd, vn)), 0., 1.), 16.) *
           pow (1. - 0.6 * abs (dot (normalize (sunDir - rd), VaryNf (1024. * ro, vn, 2.))), 8.);
      }
    }
  } else col = BgCol (ro, rd);
  if (dstSmk < min (dstObj, dstFar))  col = mix (col, vec3 (0.8, 0.8, 0.75) *
     (0.5 + 0.5 * max (dot (vnSmk, sunDir), 0.)), 0.85);
  return clamp (col, 0., 1.);
}

// Function 532
float GetDist(vec3 p) {
    const float nShapes = 5.;
    float timeLine = fract(T*0.1/nShapes)*nShapes;
    p.zx *= Rot(T);
    p = opIcosahedron(p);
    float z = smoothstep(0.0,0.05,1.0-cos(timeLine*6.28));
    float d = 1e10;
    if ( timeLine < 1.0 ) {
        d = GetDistDodecahedron(p/z)*z;
    } else if ( timeLine < 2.0 ) {
        d = GetDistIcosahedron(p/z)*z;
    } else if ( timeLine < 3.0 ) {
        d = GetDistSmallStellatedDodecahedron(p/z)*z;
    } else if ( timeLine < 4.0 ) {
        d = GreatDodecahedron(p/z)*z;
        } else d = GreatStellatedDodecahedron(p/z)*z;
    return d;
}

// Function 533
float glyph_dist(in vec2 pt)
{
    float angle = atan(pt.y, pt.x) - iTime * 0.1;
    float len = length(pt);
    float rad = 1.0 - len;
    
    float theta = angle + sin(iTime - len * 10.0) * 0.2;
    
    return rad - abs(sin(theta * 2.5)) * 0.6;
}

// Function 534
MapResult map_cube(vec3 position)
{
	MapResult result;
	result.material.color = vec3(1.0, 0.5, 0.2);
	
	float cube = length(max(abs(position) - vec3(1.2), 0.0)) - 0.1;
	
	float sphere = length(position) - 1.6 - (0.1 + sin(iTime) * 0.2);
	
	float d = max(cube, -sphere);
		
	result.dist = d;
	return result;
}

// Function 535
vec3 colormap(float t) {
    return .5 + .5*cos(TWOPI*( t + vec3(0.0,0.1,0.2) ));
}

// Function 536
vec3 map_box_rgb(vec3 ro, vec3 rd, vec3 nrm) {
    //sample Ssphere
    vec3 smp = normalize(ro - Ssphere.xyz),
         rotnrm = rotateXY(smp, vec2(0., iTime*.5)),
         col = tex(iChannel0, rotnrm).rgb;
	//sample light
    float lightcontrib = max(0., dot(normalize(light.xyz - ro), nrm)),
          ssphcontrib = max(0., dot(-smp, nrm));
    return col*col*ssphcontrib + lightCol*lightcontrib*brightness;
}

// Function 537
float map(vec3 p) {

	p.x = mod(p.x, 2.+4.)-2.;
    p.z = mod(p.z-iTime*8., 1.+2.)-1.;
    

    float s = length(p)-.5;
    float pl = p.y-.1;
    
    float pr = sdHexPrism(p,vec2(1.4,.3));
p.y-=sin(iTime*2.)*6.+sin(iTime)*5.;
    float tr = sdTorus(vec3(.0,10.,.0)-p,vec2(1.6,.3));
    float fin = min(pr,s);
    fin = min(fin,pl);
	fin = min(tr,fin);
    return fin;
    
}

// Function 538
float distPlaneBump(vec3 samplePos, vec3 planeNormal, float planeHeight, sampler2D image, float scale)
{
	float bump = 0.0;
	float dist = dot(samplePos, normalize(planeNormal)) + planeHeight;
	if(dist < GROUND_BUMP_FACTOR*2.0)
		bump = texture(image, samplePos.xz*scale).r*GROUND_BUMP_FACTOR;
	return (dist-GROUND_BUMP_FACTOR)+bump;
}

// Function 539
float distanceField(vec3 p) {
    //vec3 rotation = rotate(p, iTime * 0.2);
    //rotation = rotate(rotation.zxy, iTime * 0.4);
    //vec3 repeated = repeat(p, vec3(1.));
    float d1 = torus(p, vec2(.3, .1));
    return d1;
}

// Function 540
float dist(vec3 p) {
    return 0.385*mandelbulb(p);
}

// Function 541
float sdfUnion(float d1, float d2, int d1_id, int d2_id ,out int objectHit) {
    if (d1 < d2) {
        objectHit = d1_id;
        return d1;
    }
    objectHit = d2_id;
    return d2;
}

// Function 542
vec2 Map( vec2 uv )
{
    int n = 4; // lower = cheaper
    float a = 1.275;
    float s = 4.1;
    
    // adjust our view
    //uv *= exp(-sin(iTime/3.)+1.);
    //uv += vec2(.618,.382)*.1*iTime;
    float scale = 3.;
	uv /= scale * pow(s,float(n)); // mul by all the scales we'll accumulate in the loop
    uv = Rot(uv,.5-a);
    
	for ( int i=0; i < n; i++ )
    {
        //uv += -.07;
        uv *= s;
	    uv = Rot(uv,a);
        uv = Wrap(uv);
    }
    
    vec2 d = Buildings( uv ); // .5/.0 look okay, other values mess up roads (but .05 gives thick & thin roads
    d.x *= scale;
    return d;
}

// Function 543
float Fuller_SDF(in vec3 p, in vec3 b)
{
    // Modified rounded box that gets thinner and shallower as z decreases
    float zmod = p.z * 0.005;
    return length(max(abs(p) - vec3(b.x + zmod * 1.5, b.y, b.z), 0.0)) - (0.1 + zmod * 0.75);
}

// Function 544
float PlaneDist( const in vec3 vPos, const in vec4 vPlane )
{
    return dot(vPlane.xyz, vPos) - vPlane.w;
}

// Function 545
float mapTotal( in vec3 pos )
{
    float d1 = mapArlo( pos ).x;
    float d2 = mapTerrain( pos, length(pos) ).x;
    return min(d1,d2);
}

// Function 546
float filmicTonemap(float x)
{
    x = max(0.0, x - 0.004);
    float gammaColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    return pow(gammaColor, 2.2);
    //return gammaColor;
}

// Function 547
vec4 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )
{	
    vec4 vResult = vec4(0);
    
	float t = minDist;
	const int kRaymarchMaxIter = 128;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
        float epsilon = 0.0001 * t;
		vResult = Scene_GetDistance( vRayOrigin + vRayDir * t );
        if ( abs(vResult.x) < epsilon )
		{
			break;
		}
                        
        if ( t > maxDist )
        {
	        t = maxDist;
            break;
        }               
        
        t += vResult.x;
	}
    
    vResult.x = t;
    
    return vResult;
}

// Function 548
float GetPrismDist( vec2 vUV )
{    
    float fD1 = dot( vUV, vPrismN1 ) + fPrismD1;
    float fD2 = dot( vUV, vPrismN2 ) + fPrismD2;
    float fD3 = dot( vUV, vPrismN3 ) + fPrismD3;
                       
    return max(max( fD1, fD2 ), fD3);
}

// Function 549
vec4 mapDistanceColor(const in vec3 point) {
    vec4 tmpPrim_22 = vec4(
        cullPlane(
            pMod(
                (
                    mat4(
                        1.0,0.0,0.0,0.0,
                        0.0,1.0,0.0,0.0,
                        0.0,0.0,1.0,0.0,
                        0.0,0.3,0.0,1.0
                    ) * vec4(point, 1.0)
                ).xyz, 
                vec3(-5.0,-5.0,-5.0)
            )
        ) * 1.0, 
        vec3(0.1) * (mod(floor(100.0 * point.y), 2.0)) + 0.1
    );
    vec4 tmpPrim_23 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), 0.31) * 1.0, vec3(0.98921875,0.98921875,1.0));
    vec4 tmpComb_31 = opUnionStairs(tmpPrim_22, tmpPrim_23, vec2(2.6,9.91));
    vec4 tmpPrim_24 = vec4(sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,3.186491012573242,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(9.0,-3.0,9.0)), vec2(2.5,0.3)) * 1.0, vec3(0.98921875,0.98921875,1.0));
    vec4 tmpComb_32 = tmpComb_31;
    vec4 tmpComb_33 = opUnionColumns(tmpComb_32, tmpPrim_24, vec2(2.16,10.0));
return tmpComb_33;
}

// Function 550
vec3 mapP( vec3 p )
{
    p.xyz += .050*sin(  8.*p.zxy)*grow.x;
    p.xyz += 0.0850*sin(  12.0*p.yzx+ sin(iTime*4.)*1.8)*grow.y;
    p.xyz += 0.05*sin(  5.0*p.yzx+ cos(iTime*4.)*1.8 )*grow.z;
    p.xyz += 0.060*sin( 4.0*p.yzx)*grow.w;
    return p;
}

// Function 551
vec2 scene_pyramids(vec3 _p)
{
    return scene_min(
            scene_min(scene_pyramid(_p-vec3(10., 2., 35.), 16.), scene_pyramid(_p-vec3(-10., 2., 40.), 12.))
                , scene_pyramid(_p-vec3(-30., 2., 65.), 8.)
            );
}

// Function 552
float DistBox(in vec3 p, in vec3 dimensions)
{
	return length(max(abs(p) - dimensions,0.0)); 
}

// Function 553
float map(vec3 p)
{

  vec3 cp = p;

  vec3 pid = RID(p, 80.);
  p = REP(p, 80.);
  p.xy *= rot(pid.z * .5);
  p.zy *= rot(pid.x * .5);
  p.xz *= rot(pid.y * .5);

  p.z -= time;

  p.y += 2.;
  p.xy *= rot(p.z * .1);
  p.y -= 2.;

  p.xy *= rot(time * .05);

  float dist = 1000.;

  p *= 2.;
  float r = 6.;

  vec3 id = RID(p, r);
  p = REP(p , r);


  float nois = noise(id);
  float t = time * (nois + .2); ;

  p.xz *= rot(t);
  p.xy *= rot(t * .5);
  p.yz *= rot(t * .25);
  dist = solid(p, nois) *.25;

  dist = max(dist, length(id.xy) - 2.);

  return dist;
}

// Function 554
float map(vec3 p)
{
 	float dist = 1000.;
    
	p.xz *= rot(sin(iTime * .1));
 	p.yz *= rot(PI * .5);
    
  vec3 cp = p; 
    
  vec3 pageBox = vec3(4.,.025,4. * iResolution.y / iResolution.x);

  float ins = smoothstep(-.125,.125,p.x);
  float angle = -open;
  p.xy *= rot(angle * ins - angle *.5);
    
    
  float page = sdBox(p, pageBox);  

  ADD(page);

  if(page < .01)
  {
    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;

    if(p.y < 0.)
    { 
      puv.z = 1.;
    }
    else
    {
      if(p.x < 0.)
      {
        puv.z = 2.;
        puv.x = -puv.x + 2.;
      }
      else
      {
        puv.z = 6.;
        puv.x *= -1.;
      }
    }
  }

  p = cp;
    
  p.y -= .02;
  angle -= (sin(time * .5) * .7 + .8);
  
  p.xy *= rot(angle * ins - angle *.5);
  page = sdBox(p, pageBox);  
  ADD(page);

  if(page < .01)
  {
    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;

    if(p.y < 0.)
    { 
      if(p.x < 0.)
      {
        puv.z = 2.;
        puv.x = puv.x + 1.;
      }
      else
      {
        puv.z = 6.;
        puv.x =puv.x -1.;
      }
    }
    else
    {
      if(p.x < 0.)
      {
        puv.z = 3.;
        puv.x = puv.x  - 1.;
      }
      else
      {
        puv.z = 5.;
        puv.x = -puv.x  + 3.;
      }
    }
  }


  p = cp;
  p.y -= .02;
  angle -= (sin(time * .25) * .7 + .8);
  
  p.xy *= rot(angle * ins - angle *.5);
  page = sdBox(p, pageBox);  


  ADD(page);
  if(page < .01)
  {
    puv.xy = (p.xz / pageBox.xz ) * .5 + .5;
    if(p.y < 0.)
    { 
      if(p.x < 0.)
      {
        puv.z = 3.;
        puv.x *= -1.;
      }
      else
      {
        puv.z = 5.;
        puv.x = puv.x +2.;
      }
    }
    else
    {
      puv.z = 4.;
        puv.x = puv.x +2.;
    }
  }
  
  return dist;
}

// Function 555
vec3 iqCubemap(in vec2 q, in vec2 mo) {
    vec2 p = -1.0 + 2.0 * q;
    p.x *= iResolution.x / iResolution.y;
	
    // camera
	float an1 = -6.2831 * (mo.x + 0.25);
	float an2 = clamp( (1.0-mo.y) * 2.0, 0.0, 2.0 );
    vec3 ro = 2.5 * normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));
    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);
    vec3 uu = normalize(cross( vec3(0.0, -1.0, 0.0), ww ));
    vec3 vv = normalize(cross(ww, uu));
    return normalize( p.x * uu + p.y * vv + 1.4 * ww );
}

// Function 556
vec3 distance_field_normal(in vec3 pos) {
    const float eps = 0.1;
    float d  = signed_distance(pos);
    float nx = signed_distance(pos + vec3(eps, 0.0, 0.0)) - d;
    float ny = signed_distance(pos + vec3(0.0, eps, 0.0)) - d;
    float nz = signed_distance(pos + vec3(0.0, 0.0, eps)) - d;
    return normalize(vec3(nx, ny, nz));
}

// Function 557
float SphereDistance(in vec4 sphere, in vec3 point)
{
    return length(point - sphere.xyz) - sphere.w;
}

// Function 558
vec2 sdf_emboss(float sdf, float bevel, vec2 light_dir)
{
    float mask = sdf_mask(sdf);
    bevel = clamp(1. + sdf/bevel, 0., 1.);
    return vec2(mask * (.5 + sqrt(bevel) * dot(sdf_normal(sdf), light_dir)), mask);
}

// Function 559
float dist2box(vec2 p, float a){
	p=abs(p)-vec2(a);
	return max(p.x,p.y);
}

// Function 560
vec3 envMap(vec3 rd, vec3 normal) {
    vec3 r = reflect(rd, normal);
    vec3 texel = texture(cubeMap, r).rgb;
    return texel;
}

// Function 561
float sdfGlass(vec3 p, state s) {
    float etchDepth = 0.0; // Can sample from e.g. cubemap here for some texture
    return sdfInterval(0.0, GLASS_THICKNESS - etchDepth, sdfContainer(p, s));
}

// Function 562
vec3 sceneNormal(vec3 p) {
    vec3 v1 = vec3(1.0, -1.0, -1.0);
    vec3 v2 = vec3(-1.0, -1.0, 1.0);
    vec3 v3 = vec3(-1.0, 1.0, -1.0);
    vec3 v4 = vec3(1.0, 1.0, 1.0);
    return normalize(
        v1 * sceneSDF(p + v1*EPSILON).x +
        v2 * sceneSDF(p + v2*EPSILON).x +
        v3 * sceneSDF(p + v3*EPSILON).x +
        v4 * sceneSDF(p + v4*EPSILON).x
    );
}

// Function 563
float Scene( vec3 p )
{   
    p.z += cos( p.y * 0.2 + iTime ) * 0.11;
    p.x += sin( p.y * 5.0 + iTime ) * 0.05;    
    p.y += sin( iTime * 0.51 ) * 0.1;
    
    Rotate( p.yz, 0.45 + sin( iTime * 0.53 ) * 0.11 );
    Rotate( p.xz, 0.12 + sin( iTime * 0.79 ) * 0.09 );
    
    vec3 t = p;
    RepeatAngle( t.xz, 8.0 );
    float ret = Tentacle( t );

    p.z += 0.2;
    p.x += 0.2;
        
    float body = Sphere( p - vec3( -0.0, -0.3, 0.0 ), 0.6 );
    
    t = p;    
    t.x *= 1.0 - t.y * 0.4;
    body = UnionRound( body, Sphere( t - vec3( -0.2, 0.5, 0.4 ), 0.8 ), 0.3 ); 
    
    body += Displace( 0.02, 10.0, p );
    body += textureLod( iChannel0, vec2( p.xy * 0.5 ), 0. ).x * 0.01;
   
    ret = UnionRound( ret, body, 0.05 );   
    
    ret = SubstractRound( ret, Sphere( p - vec3( 0.1, -1.0, 0.2 ), 0.4 ), 0.1 );        
    
	return ret;
}

// Function 564
float scene(vec2 uv){
	float color = background(uv);
    
    //vec4 limboChar2 = limbo_char2(uv);
   // color = mix(color, limboChar2.x, limboChar2.a);
    
    vec4 limboChar = limbo_char(uv);
    color = mix(color, limboChar.x, limboChar.a); // change alpha here later to make the background visible
    vec2 terrainColor = terrain(uv);
	color = mix(color, terrainColor.x, terrainColor.y);
	
    vec2 foregroundColor = foreground(uv);
	color = mix(color, foregroundColor.x, foregroundColor.y);
	return color;
}

// Function 565
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 vn, col, q;
  float dstObj, sh;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += rd * dstObj;
    vn = ObjNf (ro);
    if (idObj == 1) {
      q = ro;
      q.xy -= vec2 (0.4);
      q.xy = Rot2D (q.xy, -0.2 * pi);
      if (q.x < -0.03) vn = VaryNf (10. * q, vn, 0.1);
      col = mix ((q.x < 0.) ? mix (vec3 (0.6, 0.3, 0.), vec3 (0.3, 0.1, 0.),
         0.5 * Fbm3 (2. * ro)) : vec3 (0.1), vec3 (0.7, 0.6, 0.),
         SmoothBump (-0.03, 0.03, 0.01, q.x));
      sh = ObjSShadow (ro, ltDir);
      col = col * (0.2 + sh * (0.1 * max (vn.y, 0.) +
         0.8 * max (dot (vn, ltDir), 0.))) +
         0.5 * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 8.);
    } else if (idObj == 2) {
      col = mix (vec3 (0.7, 0., 0.) * smoothstep (0.1, 1.5, Fbm1 (0.5 * tCur)),
         vec3 (0.1, 0.01, 0.01), clamp (Fbm2 (30. * ro.xz) - 0.3, 0., 1.));
    }
  } else col = vec3 (0.9, 0.8, 0.6);
  return pow (clamp (col, 0., 1.), vec3 (0.7));
}

// Function 566
float sdfEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

// Function 567
vec2 MapSpheres(vec3 rayPoint)
{
    float a = SDFSphere(rayPoint + vec3(+0.3, 1.6, -1.7), 0.5);
    float b = SDFSphere(rayPoint + vec3(-1.0, 1.3, -4.0), 0.8);
    
    return vec2(min(a, b), TYPE_SPHERE);
}

// Function 568
vec4 TraceHeightmap(vec3 p, vec3 d, vec2 NEARFAR, float PixSize, float IPixSize, float TRES, vec2 uvOff,
                    float StartLOD, samplerCube Cube) {
    //Tracing a heightmap
        //NEAR mste ocks vara en parameter = max(0.,bb.x)
    vec3 IDir=1./d; vec3 SD=sign(d);
    float dist=NEARFAR.x; float FAR=NEARFAR.y; float LFar=FAR; vec2 bb,bMin,bMax,t2;
    vec3 cp,fp; vec4 C;
    float LOD=StartLOD;
    float LS=pow(2.,LOD)*PixSize;
    float ILS=pow(0.5,LOD)*IPixSize;
    for (int i=0; i<72; i++) {
        if (dist>FAR) break;
        if (dist>LFar && LOD<StartLOD) {
            LOD=LOD+1.;
            LS*=2.;
            ILS*=0.5;
            fp=floor(cp*ILS)*LS;
            LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);
        }
        cp=p+d*dist;
        fp=floor(cp*ILS)*LS;
        C=texture(Cube,vec3(-1.,(vec2(fp.x*ILS+TRES+2.*TRES
                        *(1.-ILS*PixSize),fp.z*ILS)+uvOff)*I1024*2.-1.).yxz);
        if (box(p,IDir,vec3(fp.x,0.,fp.z),vec3(LS,C.x,LS),bb)) {
            if (LOD==0.) {
                //return bb.xxxx;
                C=texture(Cube,vec3(-1.,(fp.xz*ILS+uvOff)*I1024*2.-1.).yxz);
                vec4 nds; vec4 nd=vec4(0.,0.,0.,10000.);
                //Improved geometry quality
                if ((C.x-C.w)*(C.x-C.w)>(C.y-C.z)*(C.y-C.z)) {
                    if (Triangle(p,d,vec3(fp.x,C.x,fp.z),vec3(fp.x,C.y,fp.z+PixSize)
                                ,vec3(fp.x+PixSize,C.z,fp.z),nds)) nd=nds;
                    if (Triangle(p,d,vec3(fp.x+PixSize,C.z,fp.z),vec3(fp.x,C.y,fp.z+PixSize)
                                ,vec3(fp.x+PixSize,C.w,fp.z+PixSize),nds)) nd=((nds.w<nd.w)?nds:nd);
                } else {
                    if (Triangle(p,d,vec3(fp.x,C.x,fp.z),vec3(fp.x,C.y,fp.z+PixSize)
                                ,vec3(fp.x+PixSize,C.w,fp.z+PixSize),nds)) nd=nds;
                    if (Triangle(p,d,vec3(fp.x,C.x,fp.z),vec3(fp.x+PixSize,C.w,fp.z+PixSize)
                                ,vec3(fp.x+PixSize,C.z,fp.z),nds)) nd=((nds.w<nd.w)?nds:nd);
                }
                if (nd.w<1000.) return vec4(normalize(nd.xyz),nd.w);
            } else if (LOD>0.) {
                LFar=boxfar2(p.xz,IDir.xz,fp.xz,fp.xz+LS);
                LOD-=1.;
                LS*=0.5;
                ILS*=2.;
                continue;
            }
        }
        bMin=(fp.xz-p.xz)*IDir.xz;
        bMax=(fp.xz+LS-p.xz)*IDir.xz;
        t2=max(bMin,bMax);
        dist=min(t2.x,t2.y)+0.001;
        //fp.xz+=((t2.x<t2.y)?vec2(SD.x*LS,0.):vec2(0.,SD.z*LS));
    }
    return vec4(0.,0.,0.,10000.);
}

// Function 569
vec3 ParallaxMapping(in vec3 position, inout vec3 normal, in float d, in int toggle)
{
    vec3 toBox = -position - BoxCenter;
    vec3 uvBoxSize = vec3(BoxSize.x, 3.5, BoxSize.z);

    vec2 textureCoords = (abs(normal.x) == 1.0) ? (toBox.zy / uvBoxSize.zy) : vec2(0.0);
    textureCoords += (abs(normal.y) == 1.0) ? (toBox.xz / uvBoxSize.xz) : vec2(0.0);
    textureCoords += (abs(normal.z) == 1.0) ? (toBox.xy / uvBoxSize.xy) : vec2(0.0);
    textureCoords = (textureCoords * 0.5 + 0.5) + vec2(0.0, 0.5);   
    
    float height = SampleTexture(textureCoords);
    
    vec3 tangent = normalize(dFdy(textureCoords).y * dFdx(position) - dFdx(textureCoords).y * dFdy(position));
    vec3 temp = cross(normal, tangent);
    tangent = cross(temp, normal);
    tangent = normalize(tangent);
    vec3 binormal = cross(-tangent, normal);
     
    vec3 viewTangentSpace = normalize(gCameraPosition - position) * mat3(tangent, binormal, normal);
   
    const float scale = 0.04;
    const float bias = 0.02; 
	vec2 textureOffset = (viewTangentSpace.xy * (height * scale - bias)) / viewTangentSpace.z;
    
    // Steep Parallax Mapping and POM
    const float numberOfSamples = 10.0;
	const float stepSize = 1.0 / numberOfSamples;
	vec2 deltaOffset = textureOffset / numberOfSamples;
	float currentLayerDepth = 0.0;
    float currentDepth = 0.0;       
    
    if ((toggle == 3) || (toggle == 4))  // Steep Parallax Mapping or POM
    {   
        for(float i = 0.0; i <= numberOfSamples; ++i)
        {
            currentDepth -= stepSize;           
        	textureCoords += deltaOffset;
            height = SampleTexture(textureCoords);
            
            if(currentDepth < height) 
            {	
                break;
            }
        }
        
        if (toggle == 4) // POM
        {
            vec2 previousTextureCoords = textureCoords - deltaOffset;
            float collisionDepth = height - currentDepth;
            float previousDepth = SampleTexture(previousTextureCoords) - currentDepth - stepSize;

            float weight = collisionDepth / (collisionDepth - previousDepth);
            textureCoords = mix(textureCoords, previousTextureCoords, weight);    
            height = SampleTexture(textureCoords);
        }
    }
    else if(toggle == 2) // Parallax Mapping  
    {
        textureCoords = textureCoords + textureOffset; 
        height = SampleTexture(textureCoords);
    }

    // Final Display
    if((toggle >= 1) && (toggle <= 4))
    {
        normal = CalculateNormalMapNormal(textureCoords, height, normal, tangent, binormal);        
    }
    return SampleTexture(textureCoords) * vec3(0.85, 0.85, 1.0);
}

// Function 570
vec3 cahcyDistributionCumulativeDistributionFunction(
 vec3 x,
 vec3 locationParameter,
 vec3 scaleParameter){
  return 1./pi*atan((x-locationParameter,)/scaleParameter)+.5
;}

// Function 571
vec2 cubemap(vec3 p, vec3 n){
    //Maps position, normal-> texture coordinate.
    //n=1,0,0: just y and z
    //This isn't a particularly nice way to do things, but it works.
    n=abs(n);
    if(n.x>n.y && n.x>n.z){
        return p.yz;
    }else if(n.y>n.x && n.y>n.z){
        return p.xz;
    }else{
        return p.xy;
    }
}

// Function 572
float SDF (vec3 p)
{
    float g = gems(p);
    float b = background(p);
    float w = water(p);
    float d = min(g,min(b, w));
    // tricks learned during YX stream
    if (d == b) mat = 1;
    if (d == g) mat = 2;
    if (d == w) mat = 3; 
    return d;
}

// Function 573
float map(vec3 p, int id)
{
    if(id == 0) return length(p.xz) - 1.;
    if(id == 1) return abs(p.y + 1.2);
    if(id == 2) return abs(p.y - 2.2);
    if(id == 3) return length(p-lp) - .1;
    if(id == 4) return abs(p.z - 5.);
    if(id == 5) return abs(p.z + 5.);
    if(id == 6) return abs(p.x - 5.);
    if(id == 7) return abs(p.x + 5.);
    return MAX;
}

// Function 574
Scene drawScene(vec3 ro, vec3 rd) {
    
    float mint = FAR;
    float bft = 0.0;
    vec3 minn = vec3(0.0);
    float id = 0.0;
    
    float ft = planeIntersection(ro, rd, fn, fo);
    if (ft > 0.0) {
        mint = ft;
        minn = fn;
        id = FLOOR;
    }
    
    vec2 st = sphIntersect(ro, rd, sphere);
    if (st.x > 0.0 && st.x < mint) {
        
        vec3 rp = ro + rd * st.x;
   
        mint = st.x;
        bft = st.y;
        minn = sphNormal(rp, sphere);
        id = SPHERE;
    }
    
    return Scene(mint, minn, id, bft);
}

// Function 575
vec4 scene() {
    
    float scal = 0.0,dist = 0.0;
    
    for (int i = 0; i < maxIter; i++) {
        
        rayPos = startRayPos+startRayDir*scal;
        
        dist = distMap();
        if (dist <= EPILSON) {
            return colorMap();
        }
        
        scal += dist;
        if (scal > viewDist) {
            break;
        }
        
    }
    
	return vec4(0.0);
}

// Function 576
float opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)
{
    vec3 q;
	q = min(p,mod(p+.5*c,c)-.5*c); // less than 0
    q = max(q,p-(lim-vec3(1.0))*c); // more than limit
    return scene1(q);
}

// Function 577
vec3 boxmap(vec3 p, vec3 n) {
	n = pow(abs(n), vec3(32));
	vec3 tx = tex1(p.yz);
	vec3 ty = tex2(p.zx);
	vec3 tz = tex3(p.xy);
	return (tx*n.x + ty * n.y + tz * n.z) / (n.x + n.y + n.z);
}

// Function 578
float distanceestimator(vec3 rayposition){
    float sphere = distance(rayposition, vec3(0.0))-0.25;
    float plane = distance(rayposition, vec3(rayposition.x, -0.35, rayposition.z))-0.1;
    return min(sphere, plane);
}

// Function 579
vec4 getBitmapColor( in vec2 uv )
{
        return getColorFromPalette( getPaletteIndex( uv ) );
}

// Function 580
float heightMap( vec3 coord ) {

    float n = abs( snoise( coord ) );

    n += 0.25   * abs( snoise( coord * 2.0 ) );
    n += 0.25   * abs( snoise( coord * 4.0 ) );
    n += 0.125  * abs( snoise( coord * 8.0 ) );
    n += 0.0625 * abs( snoise( coord * 16.0 ) );

    return n;

}

// Function 581
float map(vec3 p) {
  float d1 = sphere(p, vec3(.1, sin(iTime*.9)*.2, 0.), .13);
  float d2 = sphere(p, vec3(-.1, cos(iTime)*.15, 0.), .1);
  float d3 = sphere(p, vec3(0., sin(iTime*.7)*.12, .1), .08);
  float d4 = plane(p, vec3(0., 1., 0.), .2);
  float r = length(p.xz);
  float c = exp(-1.5 * r * r);
  d4 += .03 * cos((r - iTime * .35) * 20.) * c * (1. - c*c*c*c*c);
  float s1 = smin(smin(d1, d2, .07), d3, .07);
  return smin(s1, d4, .2);
}

// Function 582
vec3 sky_map (vec3 d) {
    return vec3(0., 0., 100./255.);
}

// Function 583
float DistanceToSphere(vec3 P, Object sphere)
{
	vec3 V = P - sphere.pos;
	return length(V) - sphere.radius;
}

// Function 584
float map( vec3 q ) {                                 // 3D model of Regent Street
    q += vec3(-182,2,2);
    float l = length(q.xz),
    t = min( c1 = l-160.,                             // right facade
             c0 = 184.-l );                           // left facade
    t = min( t, max( l-170., 16.-q.y ));              // top of right facade
 
    t = min(t, max( length(q.xz+vec2(174.1,40))-1.4 , abs(q.y)-1.8 ) ); // bus
    t = min(t, max( length(q.xz+vec2(165,40))-.9 , abs(q.y)-1.45 ) );   // car
    t = min(t, max( length(q.xz+vec2(169.5,25))-.24 , abs(q.y)-1. ) );   // pole
    t = min( t, s = q.y);                             // floor
    t = max( t, q.z -2. );                            // front plane
    return t;
}

// Function 585
float map(vec3 p) {
  vec3 temp;
  return mapWDists(p, temp);
}

// Function 586
float SceneSDF(vec3 p){
    //p = rotateY(iTime * 0.2) * p;
    float smallest = 5.;
    float d = 100.;
    vec3 xyz = fract(p);  // point within a grid cell
    xyz.y = p.y;  // we want the absolute y position in the grid cell for correctly calculating notches
    vec2 id = floor(p.xz);  // the grid cell we are in
    
    for(float y=-1.; y <= 1.; y++) {  // look at the neighboring cells
        for(float x=-1.; x <= 1.; x++) {  // to see which cell has a point that is the closest to our pixel
            vec2 off = vec2(x, y);
            vec2 coord = id+off;
            vec2 n = N22(id+off);
            
            // calculate the point, then add the offset to it
            // so that the point is moved into its own grid cell
            // this is the origin for the purposes of this grid cell (i.e. the place where the bamboo trunk is centered)
            // and xyz is the pixel where we are, so we measure from xyz->point since we want to know dist from point->origin
            vec2 point = off+n;
            
            // dist between Voronoi point and current pixel RELATIVE TO GRID
            // because the point is created relative to the grid
            // so there won't be any Voronois if uv goes too far from the origin
            vec3 gridCenter = vec3(xyz.x-point.x,xyz.y,xyz.z-point.y);
            
            d = bamboo(vec3(gridCenter),20.,.05);
            d = min(d,leaves(gridCenter,21.9,20.));
            
            smallest = (d < smallest) ? d : smallest;
        }
    }
    return smallest;
}

// Function 587
float map(vec3 p){

    // Twist the scene about the Z-axis. It's an old trick. Put simply, you're
    // taking a boring scene object and making it more interesting by twisting it. :)
    p.xy *= rot(p.z*ZTWIST);
    
    // Produce a repeat object. In this case, just a simple lattice variation.
    float d =  lattice(p); 
    
    // Bound the lattice on the outside by a boxed column (max(abs(x), abs(y)) - size) 
    // and smoothly combine it with the lattice. Note that I've perturbed it a little 
    // by the lattice result (d*.5) in order to add some variation. Pretty simple.
    p = abs(p);
    d = sminP(d, -max(p.x, p.y) + 1.5 - d*.5, .25);
     
    return d*.7;
}

// Function 588
Object sdf (vec4 p) {
    return omin(
        Object(stone, hypersphere(p-vec4(0., sin(iTime), 0., sin(iTime)), 0.5)), 
        omin(
            Object(stone, hypersphere(p-vec4(sin(iTime)*0.5, 0., cos(iTime)*0.5, 0.), 0.3)),
            omin(
                Object(carpet, sdBox(p-vec4(0.5, -0.7, 0.5, 0.3), vec4(0.3))),
                Object(carpet, hyperplaneBounded(p, -1., 3.))
        		//Object(carpet, hyperplane(p, -1.) - 0.1*length(sin(p*3.)))
            )
        )
    );
}

// Function 589
vec3 plane_quadratic_dist(vec2 n, float coeffs[6]) {
    float A = coeffs[0]; float B = coeffs[1]; float C = coeffs[2];
    float D = coeffs[3]; float E = coeffs[4]; float F = coeffs[5];
    float K = n.x;
	float L = n.y;
    float AB = A*B;
    float BC = B*C;
    float AD = A*D;
    float DE = D*E;
    float EE = E*E;
    float BK = B*K;
    float AL = A*L;
    float EL = E*L;
    // if det is 0, there is no maximum we could fit the plane to
    float det = 4.0*AB - EE;
    // +-q yields the plane we are interested in
    // nice to know: setting q=0 returns the center of the surface
	float q = sqrt((C*(BC - DE) + AD*D - F*det)/((BK - EL)*K + AL*L));
    float dx = 2.0*BC - DE;
    float dy = 2.0*AD - C*E;
    float x = ((EL - 2.0*BK)*q - dx)/det;
    float y = ((E*K - 2.0*AL)*q - dy)/det;
    float w = -dot(n,vec2(x,y));
	return vec3(x,y,w);
}

// Function 590
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;
    
    return normalize( vNormal );
}

// Function 591
float distanceField(vec3 point)
{   
    vec3 moddedPoint = domainMod(point);
    
    float roadDist		= AABox(roadPt1, roadPt2, moddedPoint);
    float distSphere 	= sphereDist(sphere, moddedPoint);
    float distCylinder 	= cylinderDist(cylinderPos, cylinderSize, moddedPoint);
    float distPlane		= planeDist(plane, point);
    float minDist		= MAX_DIST;
    minDist 			= min(distSphere, distCylinder);    
    minDist 			= min(minDist, distPlane);
    minDist 			= min(minDist, roadDist);
   	return minDist;
}

// Function 592
float sdfCone(vec3 p, vec3 a, vec3 b, float ra, float rb)
{
    float rba  = rb-ra;
    float baba = dot(b-a,b-a);
    float papa = dot(p-a,p-a);
    float paba = dot(p-a,b-a)/baba;
    float x = sqrt( papa - paba*paba*baba );
    float cax = max(0.0,x-((paba<0.5)?ra:rb));
    float cay = abs(paba-0.5)-0.5;
    float k = rba*rba + baba;
    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );
    float cbx = x-ra - f*rba;
    float cby = paba - f;
    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;
    return s*sqrt( min(cax*cax + cay*cay*baba,
                       cbx*cbx + cby*cby*baba) );
}

// Function 593
vec3 Tonemap( const in vec3 cCol )
{ 
    vec3 vResult = 1.0 -exp2(-cCol);

    return vResult;
}

// Function 594
vec3 MapColor(vec3 srgb)
{
    #if MODE == 0
    return srgb * sRGBtoAP1;
    #else
    return srgb;
    #endif
}

// Function 595
float map( in vec3 pos, in float sample1 )
{
    vec2 delta = (pos.xz - sph1.xz);
    vec2 r = delta;//mix( delta, fract(delta), sample1 );
    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));
    return pos.y - h;
}

// Function 596
float pillarsSdf(vec3 pos)
{
  const float repeat = 12.0;
  opRepeat(pos.x, repeat);
  opRepeat(pos.z, repeat);

  float d = MAX_FLT;
  float pillar = sdBox(pos, vec3(1.0, 5.0, 1.0));
  float base = sdBox(pos, vec3(1.5, 0.5, 1.5));  
  float top = sdBox(pos - vec3(0.0, 4.5, 0.0), vec3(1.25, 0.2, 1.25));
  d = opUnionStairs(pillar, base, 0.5, 3.0);
  d = opUnionStairs(d, top, 0.3, 2.0);
  return d;
}

// Function 597
float sdfSphere(vec3 coord, vec3 center, float radius){ 
    return distance(coord,center) - radius; 
}

// Function 598
float map(vec3 p){
    p = mod(p, 4.) - 2.0;
    float t = iTime;
    
    float bmp = sin(p.x*BUMP_AMOUNT-t)* sin(p.y*BUMP_AMOUNT+t)* sin(p.z*BUMP_AMOUNT-t*1.5);
    bmp*=.025;
    
    
    return (lengthN(p,8.) - 0.75)+bmp;
}

// Function 599
RaycastHit raycastScene(const Ray ray) {

    float time = iTime;
    if(iMouse.z > 0.) time = 6.5 * (iMouse.x / iResolution.x);
    
    float x = sin(time) / 2.;
    float nx = tan(time) / 2.;
    return intersectSphere(vec3(nx,x,0.),.6,ray);
    
}

// Function 600
SDFRes substractSDF(SDFRes f1, SDFRes f2 )
{
    float t = substract(f1.d, f2.d);
    return SDFRes(t, (t < f2.d) ? f1.m : f2.m, 0.0, 0.0);
}

// Function 601
SDResult sceneDist(in Ray ray) {
    SDResult result;
    
    float floorDist = ray.origin.y;
    
    vec3 p = ray.origin;
    float t = iTime;//mod(iTime, kPI);
    
	p += vec3(
		sin(p.z * 1.55 + t) + sin(p.z * 1.34 + t),
		0.,
		sin(p.x * 1.34 + t) + sin(p.x * 1.55 + t)
	) * .5;

	vec3 mp = p;
    mp.xz = mod(p.xz, 1.);
    
        
	ray.origin = vec3(mp.x, mp.y + (sin(p.z * kPI) * sin(p.x * kPI)) * 0.25, 0.5);
	float s1 = boxDist(
        ray, 
        Box(
            vec3(0.5), 
            vec3(0.2), 
            0.02
        ));
    
    ray.origin = vec3(0.5, mp.y + (sin(p.x * kPI) * -sin(p.z * kPI)) * 0.25, mp.z);
	float s2 = boxDist(
        ray, 
        Box(
            vec3(0.5),
            vec3(0.0),
            0.15
            ));
	
    result.d = unionOp(s1, s2);
    
    result.d = unionOp(result.d, floorDist);
    
    result.material = result.d == floorDist ? kFLOORMATERIAL : kMIRRORMATERIAL;
    
    return result;
}

// Function 602
vec3 uncharted2ToneMapping(vec3 x){
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 603
float sphereSdf(vec3 pos) {
    float scale = mix(0.25, 1.0, 0.0);
    return length((pos - SPHERE.center)) - SPHERE.radius;
}

// Function 604
float cylinder_dist(vec3 q) {
	vec3 qp;
	q.z += 0.3 * sin(q.y + q.x);
	q.x += 0.3 * cos(q.y + q.x);
	qp.x = negmod(q.x, 2.0);
	qp.y = negmod(q.y, 2.0);
	qp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;
 
  return length(qp.xz)- 0.1 + max(0.01 * (q.y + 5.0 * sin(q.z + q.x)), 0.0);
}

// Function 605
vec2 map_0( in vec3 pos ) { // basic scene
    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),
	                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );
    res = opU( res, vec2( sdSphere(    pos-vec3(2,0,-3),1.), 65. ) );
    res = opU( res, vec2( sdSphere(    pos-vec3(-2,0,-2),1.),41. ) );
        
    return res;
}

// Function 606
vec2 map( vec3 p )
{
	p.y -= 1.8;
    
	p.x = abs(p.x);

	vec3 q = p;
	q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);
	q.y *= 1.05;
	q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );
    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );
	float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );
	float fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;
    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );
	float am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );
	float fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;
    q.y += -0.05+0.05*length(q.x);
	
	float d1 = length( q ) - 0.9 + fo + fo2;
    vec2 res = vec2( d1, 1.0 );

	// arms
	vec2 h = sdSegment( vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1), p );
	float d2 = h.x - 0.07;
	res.x = smin( res.x, d2, 0.03 );
	h = sdSegment( vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1), p );
	d2 = h.x - 0.07 + h.y*0.02;
	res.x = smin( res.x, d2, 0.06 );
	
	// hands
	if( p.y<-1.0 )
	{
    float fa = sin(3.0*iTime);
	h = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0), p );
	d2 = h.x - 0.03;
	res.x = smin( res.x, d2, 0.01 );
	h = sdSegment( vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa, p );
	d2 = h.x - 0.03 + 0.01*h.y;
	res.x = smin( res.x, d2, 0.02 );
	h = sdSegment( vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1), p );
	d2 = h.x - 0.03;
	res.x = smin( res.x, d2, 0.02 );
	h = sdSegment( vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa, p );
	d2 = h.x - 0.03 + 0.01*h.y;
	res.x = smin( res.x, d2, 0.02 );
	h = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2), p );
	d2 = h.x - 0.03;
	res.x = smin( res.x, d2, 0.03 );
	h = sdSegment( vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa, p );
	d2 = h.x - 0.03 + 0.01*h.y;
	res.x = smin( res.x, d2, 0.03 );
	h = sdSegment( vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2), p );
	d2 = h.x - 0.04 + 0.01*h.y;
	res.x = smin( res.x, d2, 0.05 );
	h = sdSegment( vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa, p );
	d2 = h.x - 0.03 + 0.01*h.y;
	res.x = smin( res.x, d2, 0.03 );
	}
	
	// legs
	if( p.y<0.0 )
	{
	h = sdSegment( vec3(0.5,-0.5,0.0), vec3(0.6,-1.2,0.1), p );
	d2 = h.x - 0.14 + h.y*0.08;
	res.x = smin( res.x, d2, 0.06 );
	h = sdSegment( vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0), p );
	d2 = h.x - 0.06;
	res.x = smin( res.x, d2, 0.06 );
	}

    // feet
	if( p.y<-1.5 )
	{
	h = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4), p );
	d2 = h.x - 0.09 + 0.02*h.y;
	res.x = smin( res.x, d2, 0.06 );
	h = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35), p );
	d2 = h.x - 0.08 + 0.02*h.y;
	res.x = smin( res.x, d2, 0.06 );
	h = sdSegment( vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2), p );
	d2 = h.x - 0.07 + 0.02*h.y;
	res.x = smin( res.x, d2, 0.06 );
	}
	
	// horns
	vec3 hp = p - vec3(0.25,0.7,0.0);
    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;
    hp.x += 0.8*hp.y*hp.y;
    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );
	//d4 *= 0.9;
	if( d4<res.x ) res = vec2( d4, 3.0 );

    
	// eyes
	float d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;
	if( d3<res.x ) res = vec2( d3, 2.0 );

	// mouth
	float mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)/1.2 ) -0.3/1.2;
	float of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);
	mo = max( mo, -q.y-0.35-of );

	float li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );
	res.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );
	
	if( -mo > res.x )
		res = vec2( -mo, 4.0 );

    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));

    // teeth	
	if( p.x<0.3 )
	{
    p.x = mod( p.x, 0.16 )-0.08;	
    float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;
	if( d5<res.x )
		res = vec2( d5, 2.0 );
	}
	
	return vec2(res.x*0.8,res.y);
}

// Function 607
float sdfGrid(vec3 p, vec3 cellSize, vec3 gridHalfLength) {
  vec3 pg = floor(p / cellSize) * cellSize;

  vec3 center = pg + cellSize * 0.5;

  float d = sdfBox2d(p.xz - center.xz, gridHalfLength.xz);
  d = min(d, sdfBox2d(p.xy - center.xy, gridHalfLength.xy));
  d = min(d, sdfBox2d(p.yz - center.yz, gridHalfLength.yz));
  return d;
}

// Function 608
float planeSDF(vec3 p, vec4 n)
{
  // n must be normalized
  return dot(p,n.xyz) + n.w;
}

// Function 609
vec3 sceneNorm(vec3 rp)
{
	vec3 e=vec3(1e-3,0.0,0.0);
	float d0=s(rp);
	return normalize(vec3(s(rp+e)-d0,s(rp+e.yxy)-d0,s(rp+e.yyx)-d0));
}

// Function 610
SDFResult wallsSDF( vec3 p )
{
    // floor
    SDFResult res = boxSDF2(RoundBox(vec3(0.0, -1.1, 0.0), vec3(7.0, 0.1, 2.0), 0.0, TILES), p);
    // back
    res = opAdd(boxSDF2(RoundBox(vec3(0.0, 1.0, 3.5), vec3(7.0, 3.0, 2.0), 0.0, TILES), p), res);          
#ifdef SIDEWALLR
    // RHS
    res = opAdd(boxSDF2(RoundBox(vec3(4.6, 1.0, 0.0), vec3(0.1, 2.0, 1.5), 0.0, TILES), p), res);              
#endif //SIDEWALLR
#ifdef SIDEWALLL
    // LHS
    res = opAdd(boxSDF2(RoundBox(vec3(-1.6, 1.0, 0.0), vec3(0.1, 2.0, 1.5), 0.0, TILES), p), res);          
#endif //SIDEWALLL
    
#ifdef ENCLOSED
    res = opAdd(planeSDF2(Plane(vec3(0.0, 0.0, -3.5), vec3(0.0, 0.0, 1.0), TILES), p), res);          
    res = opAdd(planeSDF2(Plane(vec3(0.0, 3.0, 0.0), vec3(0.0, -1.0, 0.0), TILES), p), res);          
#endif //ENCLOSED
    
#ifdef LIGHTBULB    
    res = opAdd(lightSDF(p), res);
#endif //LIGHTBULB
    
#ifdef MRSPOO
    // recess
    res = opSmoothSub(roundboxSDF(RoundBox(vec3(2.0, 2.0, 2.5), vec3(1.1, 1.1, 1.0), 0.05, SIERP), p), res, 0.05);          
#endif //MRSPOO
        
    return res;
}

// Function 611
float sdfSphere(sphere s)
{
    return length(s.position) - s.radius;
}

// Function 612
vec4 sdScene(const vec3 p ,const bool human)
{	
    vec4 r=sdRoom(p);
    if(human)
    {
        
        
 		 float z=sdHuman(p);
        if(fatty>0.)
	        z=mix(z,smin(z,sdFat(p)),fatty);
        if(pompom>0.)
        {
        z=smin(z,sdTrail(p,LHAND,10,pompom));
        z=smin(z,sdTrail(p,RHAND,10,pompom));
        }
       // here there are space for experimentations :D
      //  for(time_offset=0;time_offset<2;time_offset++)
       //     z=min(z,sdHuman(p));
        
     //    r=floormix?oMix(r,vec4(z,ID_MIX,p.xy)) :
        r=oU(r,vec4(z,ID_SKIN,p.xy)) ;
    }
	return r;
}

// Function 613
float digitBitmaps(const in int x) {
	return x==0?961198.0:x==1?279620.0:x==2?953902.0:x==3?953998.0:x==4?700040.0:x==5?929422.0:x==6?929454.0:x==7?952456.0:x==8?962222.0:x==9?962184.0:0.0;
}

// Function 614
vec4 map_flow(vec2 fragCoord) {
    float mbar = climate(fragCoord, PASS3).x;
    vec4 r = WARM;
    r = mix(r, vec4(1), smoothstep(1000., 1012., floor(mbar)));
    r = mix(r, COOL, smoothstep(1012., 1024., floor(mbar)));
    
    vec2 p = fragCoord * MAP_RES / iResolution.xy;
    if (p.x < 1.) p.x = 1.;
    vec2 uv = p / iResolution.xy;
    vec2 v = texture(iChannel1, uv + PASS4).xy;
    
    vec4 c = texture(iChannel2, fragCoord/iResolution.xy);
    float flow = (c.x > 0.) ? 1. : c.y;
    flow *= clamp(length(v), 0., 1.);
    
    vec4 fragColor = map_land(fragCoord, false);
    fragColor = mix(fragColor, r, 0.5 * flow);
    return fragColor;
}

// Function 615
float coneSDF( vec3 p, vec2 c )
{
    float q = length(p.xz);
    return dot(c,vec2(q,p.y));
}

// Function 616
float map(vec3 p)
{
	float r, rr, rrr, bod; // r is return value, other floats are intermediary distances

    vec3 pp = p; // old p
    p.zyx = (fract(p.zyx*.025)-.5)*20.; // repeat space
    vec3 idp = floor(((pp.zyx*.025)-.0)*1.)*200.; // get id of each cell

    // use ids to rotate differently in each cell space
    rot(p.yx,  ie*sin(idp.z+iTime*-.5)*.3333);
    p += vec3(-3., 4., -2.0)*.3333; // add some vector, don't forget to not displace over cell boundary
    rot(p.zx,  ie*sin(idp.y+iTime*.25)*1.25 +1.57);
    p += -vec3(3., 2., -2.0)*.3333;
    rot(p.yz,  ie*sin(idp.x-iTime*2./3.)*1.333 +1.57*2.);
    p += vec3(3., 2., -2.0)*.3333;
    pp.y=p.y; // store repeated space y value in ppp.y var
    float idb = step(pp.y, .0); // if y > 0 then 1 else 0, I use this to color bottom/top sphere differently
    p.y = abs(p.y)-2.1; // create symmetry on y axis of the repeated space
    rr = length(vec3(p.x, pp.y, p.z))-5.5; // create a ball
    
    rr = max(rr
             ,
            pp.y+1.5 // cut the ball and keep the top part
            );

    rr = max(rr
             ,
            -(max(abs(p.x), max(abs(pp.y+2.2), abs(p.z+1.) ) )-2.25) // dig a cube into the ball
            );
    
    rr = abs(rr)+.0751; // make the ball transparent
    
    bod = body(p); // create bodies
    r = bod;
    r = min(r, rr);

	// Create the bottom sphere part
    rrr = max( -(pp.y) + sin(length(p.xz+vec2(.0,2.1))*5.+iTime*10.)*.25 // cut with waves centered on foot
              ,
              length(vec3(p.x, pp.y, p.z) )-5.3 // ball distance
             );
    rrr = abs(rrr)+.10751; // make it transparent
    r = min(r, rrr);
    
    float ball = length(vec3(p.x, abs(pp.y)-2., p.z+.25))-.25; // this is the ball between hands
    ball = abs(ball)+.01251; // make it transparent
    r = min(r, ball);
    
    // here is coloring
    // ids of repeated space are also used for coloring
    
    // wavy sphere color
    h += (vec3(.09, .475, .607) )/max(.05, rrr*rrr*3. );
    // cubicle sphere color
    h += (1.-vec3(.3+-.205*(mod(idp.x-1.5, 3.)+0.0), .425+-.06125*(mod(idp.y-1.5, 3.)+0.0), .3+idb*.25+-.125*(mod(idp.z-1.5, 3.)+0.0)))/max(.05, rr*rr*3. + .61*.0);
    // body color
    h += (1.-vec3(.32681-idb*.25, .25+-.5*idb, .3))/max(.05, bod*bod*400. + .01);
    // little hand spheres color
    h += (vec3(.25, .25+.2*idb, .25))/max(.01, ball*ball*.051+.01);
    return r;
}

// Function 617
vec4
map( in vec3 pos )
{
    #if 0
    float r = 1.1;
    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );
    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );
    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;
    pos.x = mirror( pos.x / r ) * r;
    pos.y = mirror( pos.y / r ) * r;
    #else
    vec3 color = ORANGE_RGB;
    #endif

    float sr = 0.5;
    float sd = 0.5;
    vec4 res = vec4(1e38, sky_color);
    #if 0
    res = union_op( vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ), color ),
                    vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ), color ) );
    res = union_op( vec4( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ), color ), res );
    #endif
    
    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ), vec3(1.0) ), res );
    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ), vec3(1.0,0.0,0.0) ), res );
    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ), vec3(0.0,1.0,0.0) ), res );
    res = union_op( vec4( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ), vec3(0.0,0.0,1.0) ), res );
    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ), color ), res );
    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ), color ), res );
    res = union_op( vec4( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ), color ), res );
    res = union_op( vec4( plane_sd( pos ), vec3(0.7 + 0.3 * mod(floor(pos.x)+floor(pos.y),2.0)) ), res);
	return res;
}

// Function 618
float scene(vec4 pos4) {
  float d = 1e8;
  if (dofold) {
    pos4 = fract(pos4);
    pos4 = min(pos4,1.0-pos4);
  }
  type = 0;
  // Distance from edges - these appear as points, usually
  d = min(d,length(pos4.xyz) - ewidth);
  d = min(d,length(pos4.yzw) - ewidth);
  d = min(d,length(pos4.zwx) - ewidth);
  d = min(d,length(pos4.wxy) - ewidth);
  // Distance from faces - these appear as lines, usually
  if (dofaces) {
    d = min(d,length(pos4.xy) - fwidth);
    d = min(d,length(pos4.yz) - fwidth);
    d = min(d,length(pos4.zx) - fwidth);
    d = min(d,length(pos4.xw) - fwidth);
    d = min(d,length(pos4.yw) - fwidth);
    d = min(d,length(pos4.zw) - fwidth);
  }
  if (dopoints) {
    float k = length(pos4) - pwidth;
    if (k < d) { type = 1; d = k; }
  }
  return d;
}

// Function 619
void RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
{
    // floor
    {
    	SMaterial material;
        material.diffuse = vec3(0.5f, 0.5f, 0.5f);
        material.specular = vec3(0.3f, 0.3f, 0.3f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), 0.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = floor(intersectPos.xz / 20.0f);
            float shade = mix(0.2f, 0.6f, mod(uv.x + uv.y, 2.0f));
            material.roughness = mix(0.02f, 0.2f, mod(uv.x + uv.y, 2.0f));
            hitInfo.material.diffuse = vec3(shade, shade, shade);
        }
    }
    
    // walls
    {
    	SMaterial material;
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
        
        vec3 offset = vec3(0.0f, 80.0f, -80.0f);
        vec3 scale = vec3(80.0f, 80.0f, 1.0f);
        vec3 A = vec3( 1.0f,  1.0f, 0.0f) * scale + offset;
        vec3 B = vec3(-1.0f,  1.0f, 0.0f) * scale + offset;
        vec3 C = vec3(-1.0f, -1.0f, 0.0f) * scale + offset;
        vec3 D = vec3( 1.0f, -1.0f, 0.0f) * scale + offset;
        
        // back wall
		material.diffuse = vec3(0.9f, 0.9f, 0.9f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.xyz, B.xyz, C.xyz, D.xyz, material);
        
        // left wall
        material.diffuse = vec3(0.9f, 0.1f, 0.1f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx, B.zyx, C.zyx, D.zyx, material);
        
        // right wall
        material.diffuse = vec3(0.1f, 0.9f, 0.1f);
        vec3 multiplier = vec3(-1.0f, 1.0f, 1.0f);
        TestQuadTrace(rayPos, rayDir, hitInfo, A.zyx * multiplier, B.zyx * multiplier, C.zyx * multiplier, D.zyx * multiplier, material);
    }
    
    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2
    
        // shadow casting ball
        {
            SMaterial material;
            material.diffuse = vec3(0.9f, 0.9f, 0.9f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.0f, 0.0f, 0.0f);
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4( 0.0f, 40.0f, -30.0f, 15.0f), material);
        }

        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        
        }        
    
    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2 || SCENE == SCENE_MULTIFOG || SCENE == SCENE_ORGANICFOG
    
        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 80.0f, -30.0f, 5.0f), material);        
        }  
    
    #elif SCENE == SCENE_EMISSION
    
    	// none!
    
    #elif SCENE == SCENE_LIGHTINFOG1 || SCENE == SCENE_LIGHTINFOG2
    
        // light source
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;

            material.emissive = vec3(0.9f, 0.9f, 0.4f) * 100.0f;
            TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, -30.0f, 5.0f), material);        
        }     
    
    #endif
}

// Function 620
float remap01(float a, float b, float t) {
	return sat((t-a)/(b-a));
}

// Function 621
float sdf_shadow(float sdf, float size, vec2 light_dir)
{
    vec2 n = sdf_normal(sdf);
    float thresh = size * max(abs(dFdx(sdf)), abs(dFdy(sdf)));
    float mask = clamp(sdf/thresh, 0., 1.);
    return clamp(1. - sdf/size, 0., 1.) * clamp(-dot(light_dir, n), 0., 1.) * mask;
}

// Function 622
float map( vec2 p ) 
{
	float f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;
	
	f *= sqrt( textureLod( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0, 0.0 ).x );
	return 22.0*f;
}

// Function 623
float map2( in vec3 p )
{
	vec3 q = p - vec3(0.0,0.1,1.0)*iTime;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q );;
	return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

// Function 624
float distLine(vec2 a, vec2 b){
    
	b = a - b;
	float h = clamp(dot(a, b) / dot(b, b), 0., 1.);
    return length(a - b*h);
}

// Function 625
vec2 map( vec3 p )
{

    vec2 res;
    res.y = mapCarbonite( p-vec3(0.,1.,2.) ).y;
  
    res.x = sdPrisonBox(p);

    
  // res.y = res.x;
	return vec2(res.x*0.28,res.y);
}

// Function 626
float map(in vec3 p)
{
    
	vec3 q = p;
    //R2d(q.xy, iTime);R2d(q.zy, iTime); 
    q.z-=2.*sin(iTime);
    #define mk(_v,_m)(pow(dot(pow(_v,vec3(_m)),vec3(1)), 1./_m))
	float t =  mk(abs(q), max(1.,mod(floor(4.*iTime), 5.)) ) - 1.;
	t = min(t, 1.5+dot(p, vec3(0, 1, 0)) + (sin(p.x * .55) * sin(3.*iTime-.5*p.z)));
    return t; 
}

// Function 627
void setupScene(vec2 res) {
        
    const float diam = 2.0;
        
    theResolution = res;

    float rmax = max(res.x, res.y);
    float rmin = min(res.x, res.y);

    float csize = (rmin * 0.98);
    
    insetSize = 0.5*(rmax - csize);

    if (res.x > res.y) {
        insetBox = vec4(0.5*insetSize);
        textCenter = vec2(0.5*insetSize, 0.5*res.y);
    } else {
        insetBox = vec4(res-vec2(0.5*insetSize), vec2(0.5*insetSize));
        textCenter = vec2(0.5*res.x, res.y-0.5*insetSize);
    }

    iconCenter = vec2(0.5*insetSize, res.y-0.5*insetSize);
    
    textSize = insetSize * 0.2;
        
    px = diam / csize;
    pointSize = max(0.025, 4.0 * px);
    perpSize = textSize * px;
    
    iconSize = insetSize * 0.08;

}

// Function 628
vec3 sceneColor(in vec4 point){
    vec3 color = vec3(1.0, 1.0, 1.0);
    vec3 colorPos = fract(point.xyz);// - vec3(0.5, 0.5, 0.5));
    color.xyz = step(vec3(0.5), colorPos);
    return color;
}

// Function 629
vec4 map( in vec3 p )
{
	float d = 0.01- p.y;

	float f= fbm( p*1.0 - vec3(.4,0.3,-0.3)*time);
	d += 4.0 * f;

	d = clamp( d, 0.0, 1.0 );
	
	vec4 res = vec4( d );
	res.w = pow(res.y, .1);

	res.xyz = mix( .7*vec3(1.0,0.4,0.2), vec3(0.2,0.0,0.2), res.y * 1.);
	res.xyz = res.xyz + pow(abs(.95-f), 26.0) * 1.85;
	return res;
}

// Function 630
float map(vec2 x) {
    float a = iTime * 0.2;
    vec2 p = vec2(cos(a),sin(a)) * vec2(0.8,0.3);
    
    float d1 = length(x - p) - 0.5;
    float d2 = length(x - p + vec2(0.2,0.5)) - 0.5;
    return max(d1, -d2);
}

// Function 631
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 objCol, col, roo, vn, vnw;
  float dstHit, refl, sh, a, f;
  int idObjT;
  refl = 1.;
  idObj = -1;
  roo = ro;
  dstHit = ObjRay (ro, rd);
  if (dstHit < dstFar && idObj == idWat) {
    ro += rd * dstHit;
    vn = ObjNf (ro);
    vec2 u = ro.xz;
    float s = length (u);
    u /= s;
    u *= cos (20. * s - 5. * tCur) * (1. - s / 5.);
    vn = normalize (vec3 (u.x, 50., u.y));
    rd = reflect (rd, vn);
    ro += 0.01 * rd;
    refl *= 0.9;
    idObj = -1;
    dstHit = ObjRay (ro, rd);
  }
  if (dstHit < dstFar) {
    ro += rd * dstHit;
    idObjT = idObj;
    vn = ObjNf (ro);
    idObj = idObjT;
    if (idObj == idCol) {
      a = 0.5 - mod (20. * (atan (qHit.x, qHit.z) / (2. * pi) + 0.5), 1.);
      vn.xz = Rot2D (vn.xz, -0.15 * pi * sin (pi * a));
    }
    if (idObj == idBase) {
      objCol = vec3 (0.6, 0.6, 0.5);
      if (vn.y > 0.99) {
        if (abs (abs (qHit.x) - 3.7) < 3. && abs (abs (qHit.z) - 4.7) < 4.) {
	  objCol = mix (vec3 (0.2, 0.5, 0.2), vec3 (0.3, 0.8, 0.2),
             Noisefv2 (qHit.xz * 41.)) * (0.5 + 0.5 * Noisefv2 (qHit.zx * 57.));
	} else {
          objCol *= ChqPat (qHit * vec3 (3., 1., 3.), dstHit);
          vn = ChqNorm (qHit * vec3 (3., 1., 3.), vn);
          vn = VaryNf (10. * qHit, vn, 2.);
	}
      } else {
        vn = VaryNf (20. * qHit, vn, 5.);
      }
    } else if (idObj == idTop || idObj == idIWall) {
      objCol = vec3 (0.6, 0.6, 0.5);
      vn = VaryNf (20. * qHit, vn, 2.);
    } else if (idObj == idOWall) {
      objCol = vec3 (0.6, 0.57, 0.6);
      vn = VaryNf (20. * qHit, vn, 5.);
    } else if (idObj == idLatt) {
      objCol = vec3 (0.6, 0.6, 0.5);
      vn = VaryNf (5. * qHit, vn, 1.);
    } else if (idObj == idRing) {
      objCol = vec3 (0.9, 0.7, 0.4);
      vn = VaryNf (20. * qHit, vn, 1.);
    } else if (idObj == idCol) {
      objCol = vec3 (0.9, 0.7, 0.6);
      vn = VaryNf (20. * qHit, vn, 1.);
    } else if (idObj >= idBrnch && idObj < idFlwr + 4) {
      if (idObj < idFlwr) {
	objCol = mix (vec3 (0.3, 0.7, 0.3), vec3 (0.5, 0.3, 0.1),
           smoothstep (0.02, 0.05, trAge));
	objCol *= (0.7 + 0.3 * clamp (0.7 + 0.6 * cos (11. * qHit.y), 0., 1.));
	a = mod (20. * (atan (qHit.z, qHit.x) / (2. * pi) + 0.5), 1.);
	vn.xz = Rot2D (vn.xz, 0.5 * sin (pi * a));
	vn = VaryNf (50. * ro, vn, 5. * smoothstep (0.03, 0.08, trAge));
      } else {
	objCol = HsvToRgb (vec3 (0.35 * max (0.05 * float (idObj - idFlwr) +
           1. - 1.2 * trBloom, 0.),
	   0.05 + 0.95 * smoothstep (0.15, 0.2, trBloom), 1.)); 
	if (idObj == idFlwr + 3) objCol = mix (vec3 (1., 0., 0.), objCol,
	   smoothstep (0.05, 0.2, trBloom));
	objCol = mix (objCol, vec3 (0.5, 0.3, 0.1), smoothstep (0.9, 1., trBloom));
      }
      objCol = mix (objCol, vec3 (0.8), smoothstep (0.93, 0.98, trAge));
    }
    sh = ObjSShadow (ro, sunDir);
  } else {
    if (rd.y < 0.) {
      sh = 0.7 + 0.3 * ObjSShadow (ro - rd * ro.y / rd.y, sunDir);
    } else sh = 1.;
  }
  if (dstHit < dstFar) {
    col = refl * objCol * (0.3 +
       0.7 * max (dot (vn, sunDir), 0.) * (0.5 + 0.5 * sh) +
       0.3 * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.));
  } else col = sh * BgCol (ro, rd);
  return clamp (col, 0., 1.);
}

// Function 632
float getDist2Scene(vec3 camPos, vec3 ray) {
    return min(getDist2Plane(camPos, ray), getDist2Sphere(camPos, ray));
}

// Function 633
vec4 map( in vec3 p )
{
	float d = 0.1 + .5 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;

    vec3 q = p;
    float f = 0.0;
    
    
    f  = 0.6000*noise( q ); q = q*2.12;
    f += 0.3500*noise( q ); q = q*1.744;
    f += 0.2050*noise( q ); q = q*1.81;
    f += 0.0925*noise( q );// q = q*2.005;
    f += 0.01215*noise( q ); 
   
    d += 3.55 * f;

    d = clamp( d, 0.0, 1.0 );
    
    vec4 res = vec4( d );
    
    vec3 col = 1.15 * vec3(1.0,0.95,0.8);
    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);
    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );
    
    return res;
}

// Function 634
float map(vec3 p) {
  float d = Polyhedron(p);
  if (slice) d = max(d,dot(p,planes[0].n)-1.01);
  return d;
}

// Function 635
vec2 map(vec3 pos)
{
    //id is the material identificator (or in short the surface color)
    float id = 0.0;
    
    //floor
    float flr = pos.y + 1.0;
    
    pos = opRep(pos, vec3(2.0,1000.0,1000.0));
    
    //hollow cube with hole in a roof
    float cube = sdBox(pos, vec3(4.0, .5,0.5));
    float bigCube = sdBox(pos + vec3(0.0,49.4,0.0), vec3(50.0));
    
    vec3 rotPos = pos;
    rotPos.y -= .5;
    rotPos.yz *= rot(90.0);
    float roofHole = sdBox(rotPos, vec3(0.2,0.2,0.5));
    
    cube = max(-cube, bigCube);
    cube = max(-roofHole, cube);
    
    return vec2(cube, id);
}

// Function 636
float dDistance_Expensive( in vec2 v )
{
    float d0 = sdSegment_Expensive( v, p0, p1, t0, t1 );
    float d1 = sdSegment_Expensive( v, p1, p2, t1, t2 );
    float d2 = sdSegment_Expensive( v, p2, p3, t2, t3 );
    float d3 = sdSegment_Expensive( v, p3, p4, t3, t4 );
    float d4 = sdSegment_Expensive( v, p4, p5, t4, t5 );
    float d5 = sdSegment_Expensive( v, p5, p6, t5, t6 );
    float d6 = sdSegment_Expensive( v, p6, p7, t6, t7 );
    float d7 = sdSegment_Expensive( v, p7, p0, t7, t0 );

    return min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7)))))));
}

// Function 637
float fisheyeMapping(in vec3 uvw, out vec2 texCoords)
{
  float phi = atan(length(uvw.xy),abs(uvw.z));
  float r =  phi / PI * 2.0 / (-0.667 + 1.0);
  if ((r > 1.0) || (r <= 0.0)) return -1.0;
  float theta = atan(uvw.x,uvw.y);
  texCoords.s = fract(0.5 * (1.0 + r* sin(theta)));
  texCoords.t = fract(0.5 * (1.0 + r * cos(theta)));
  return 1.0;
}

// Function 638
float map(vec3 pos, bool nofloor)
{
    vec2 d = vec2(2. + 0.55*sin(iTime*1.2), 0.); 
    float s1 = 1./pow(obj(pos + vec3(rotateVec(d, 0.), 0.)), 2.);
    float s2 = 1./pow(obj(pos + vec3(rotateVec(d, 2./3.*pi), 0.)), 2.);
    float s3 = 1./pow(obj(pos + vec3(rotateVec(d, 4./3.*pi), 0.)), 2.);
    if (nofloor)
        return 1. - (s1 + s2 + s3)*2.;
    else   
        return min(1. - (s1 + s2 + s3)*2., floorm(pos));
}

// Function 639
vec2 map_to_origin(vec2 a, vec2 p){
    if(a == vec2(0.0)){
        return p;
    } else {
        return comp_div(comp_mul(a, conj(a)-conj(p)), comp_mul(conj(a), comp_mul(a, conj(p)) - vec2(1.0, 0.0)));
    }
}

// Function 640
float getCloudDist( vec3 p, coordsys_t b, vec4 cloud_animation_params, sampler2D aChannel0 )
{
	float aTime = cloud_animation_params.w;
	
	float lod = 0.0;

	float r = length( p );
	float ph = r - earth_radius;
	vec3 n = p; // / r; // we don't need normalize, because we project
	n = vec3( dot( n, b.x ),
			  dot( n, b.y ),
			  dot( n, b.z ) );
	p.xy = ( 8. * 1000000.0 ) * ( n.xy / n.z ); // cube projection centered on b
	p.xy += cloud_animation_params.xy;
	vec2 uv = p.xy * ( 1.0 / cloud_tex_world_size );

	vec4 n1 = textureLod( aChannel0, uv + aTime * ( 0.004 * cloud_animation_params.z ), lod );
	vec4 n2 = textureLod( aChannel0, uv * ( 1.0 / 8. ) + ( aTime * 0.0017 * cloud_animation_params.z ), lod );
	float h = saturate( ( 1.0 * n1.x * 0.3 +
						  1.0 * n1.y * 0.5 +
						  1.0 * n2.z * 1.3 - 0.05 ) ); // saturating here should make no difference, if it does it means h range is wrong

	float h1 = mix( mix( cloud_start, cloud_end, 0.3 ), cloud_end, h );
	float h2 = mix( mix( cloud_start, cloud_end, 0.2 ), cloud_start, h );
	float d1 = ph - h1;
	float d2 = h2 - ph;
	float dist = opI( d1, d2 );
	return dist;
}

// Function 641
float coneSDF(vec3 p, float height, float radius) {
    // c must be normalized
    vec2 c = normalize(vec2(height, radius));
    p.y -= height;
    float q = length(p.xz);
    float cone = dot(c,vec2(q,p.y));
    float plane = planeSDF(p, vec4(0.0, 1.0, 0.0, height));

    return max(-plane,cone);
}

// Function 642
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)
{
    /**
	 * Fast edge detection from nimitz at https://www.shadertoy.com/view/4s2XRd
     */
    float mindist=end;
    bool edge = false;
    
    float depth = start;
    vec3 point;
    
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        
        point = eye + depth * marchingDirection;
        float dist = sceneSDF(point);
        
        /*if(!edge)
        {
        	mindist = min(mindist, dist);
        }*/
        
        if (dist < EPSILON) 
        {
			break;
        }
        
        depth += dist;
        
        if (depth >= end)
		{
            depth = end;
            break;
        }
    }
    return depth;
}

// Function 643
vec4 mapToRGB(float value)
{
    // Color map generated with ColorBrewer
    // http://colorbrewer2.org/#type=sequential&scheme=YlGnBu&n=9
    const vec4[] colors = vec4[](
        vec4(255.0, 255.0, 217.0, 255.0) / 255.0,
        vec4(237.0, 248.0, 177.0, 255.0) / 255.0,
        vec4(199.0, 233.0, 180.0, 255.0) / 255.0,
        vec4(127.0, 205.0, 187.0, 255.0) / 255.0,
        vec4(65.0, 182.0, 196.0, 255.0) / 255.0,
        vec4(29.0, 145.0, 192.0, 255.0) / 255.0,
        vec4(34.0, 94.0, 168.0, 255.0) / 255.0,
        vec4(37.0, 52.0, 148.0, 255.0) / 255.0,
        vec4(8.0, 29.0, 88.0, 255.0) / 255.0);
    
    int intervals = colors.length() - 1;
    
    float t = clamp(value, 0.0, 1.0) * float(intervals);
    int interval = clamp(int(t), 0, intervals);

    if (value == -1.0)
    {
        return vec4(1.0, 0.5, 0.5, 1.0);
    }

#ifdef DISCRETE_TRAFO
    t = smoothstep(0.48, 0.52, fract(t));
#else
    t = fract(t);
#endif
    
	return mix(colors[interval], colors[interval + 1], t);
}

// Function 644
vec3 sceneNorm (vec3 p)
{
    float gradD = 0.01;
    float gradX = scene (p + vec3 ( gradD, 0.0, 0.0)) - scene (p - vec3 ( gradD, 0.0, 0.0));
    float gradY = scene (p + vec3 ( 0.0, gradD, 0.0)) - scene (p - vec3 ( 0.0, gradD, 0.0));
    float gradZ = scene (p + vec3 ( 0.0, 0.0, gradD)) - scene (p - vec3 ( 0.0, 0.0, gradD));

    return normalize (vec3 (gradX, gradY, gradZ));
}

// Function 645
Hit map(vec3 p) {
    float mindist = MAX_DIST;
    float dist = MAX_DIST;
    float d = MAX_DIST;
    vec3 material_pos;
    int material = 0;

    p.xz = rotate2d(p.xz, -PI*2.0/4.0);
    material_pos = p;

    float rocket_height = 50.0;
    float rocket_radius = 4.5;
    float nose_height = 12.0;
    float topnose_radius = 1.0;
    float base_height = (rocket_height - nose_height);

    { // base
        float d = sd_capped_cylinder_up(p, base_height, rocket_radius); // cylynder
        dist = min(dist,d);
    }
    
    { // nose
        vec3 q = p;
        q.y -= base_height;
        float r = topnose_radius;
        float h = nose_height - r;
        float Rl = rocket_radius;
        float R = (Rl*Rl + h*h - r*r) / (2.0*(Rl-r));
        float hl = (h*r)/(R-r);
        float oR = R - Rl;
        float d = sd_torus(q, -oR, R);
        d = max(d, -q.y);
        d = max(d,  q.y-(h+hl));
        dist = min(dist, d);
        d = sd_sphere(q - vec3(0.0,h,0.0), r);
        dist = min(dist ,d);
    }

    { // nose fin
        float fin_roundness = 0.15;
        float fin_height = 50.2;
        float fin_halfwidth = 0.2  - fin_roundness;
        float fin_angle = PI*(8.0/36.0);
        float fin_halfsize = 5.5 - fin_roundness;
        float fin_topcut = 0.4;
        float fin_smoothness = 0.3;
        float fin_baseheight = 1.2;
        vec2 fin_offs = vec2(sin(fin_angle), cos(fin_angle)) * fin_halfsize*2.0;
        vec2 finbase_halfsize = vec2(fin_offs.x, fin_baseheight);
        float fin_baseoffset = -fin_offs.y - fin_baseheight;
        vec3 q = p;
        q.x = abs(q.x);
        q.y -= fin_height;
        vec3 qr = q;
        qr.xy = rotate2d(qr.xy, fin_angle);
        qr.xy += fin_halfsize;
        d = sd_box(qr, vec3(fin_halfsize, fin_halfsize, fin_halfwidth));
        d = max(d, q.y + fin_topcut);
        d = max(d,-q.y - fin_offs.y);
        float dbox = sd_box(q - vec3(0.0,fin_baseoffset,0.0), vec3(finbase_halfsize, fin_halfwidth));
        d = min(d, dbox);
        dist = smin(dist, d, fin_smoothness) - fin_roundness;
    }

    { // tail fin
        float fin_roundness = 0.25;
        float fin_height = 29.3;
        float fin_halfwidth = 0.3  - fin_roundness;
        float fin_angle = PI*(5.0/36.0);
        float fin_halfsize = 13.0 - fin_roundness;
        float fin_topcut = 0.4;
        float fin_smoothness = 0.3;
        float fin_baseheight = 3.0;
        vec2 fin_offs = vec2(sin(fin_angle), cos(fin_angle)) * fin_halfsize*2.0;
        vec2 finbase_halfsize = vec2(fin_offs.x, fin_baseheight);
        float fin_baseoffset = -fin_offs.y - fin_baseheight;
        vec3 q = p;
        q.x = abs(q.x);
        q.y -= fin_height;
        vec3 qr = q;
        qr.xy = rotate2d(qr.xy, fin_angle);
        qr.xy += fin_halfsize;
        d = sd_box(qr, vec3(fin_halfsize, fin_halfsize, fin_halfwidth));
        d = max(d, q.y + fin_topcut);
        d = max(d,-q.y - fin_offs.y);
        float dbox = sd_box(q - vec3(0.0,fin_baseoffset,0.0), vec3(finbase_halfsize, fin_halfwidth));
        d = min(d, dbox);
        dist = smin(dist, d, fin_smoothness) - fin_roundness;
    }

    { // tail columns
        float size = 4.5;
        float roundness = 0.5;
        float width = 0.0;
        float height = 6.0;
        float angle = PI*(1.0/12.0);
        vec3 q = p;

        q.xz = abs(q.xz);
        q.y = q.y - clamp(q.y - (size - size*(1.0-tan(angle))*cos(angle)), -height, height);
        q.y -= size;
        q.xz = rotate2d(q.xz, PI/4.0);
        q.xy = rotate2d(q.xy, angle);
        d = sd_box(q, vec3(size, size, width)) - roundness;
        dist = smin(dist, d, 2.0);
        dist = max(dist, -p.y);
    }

    // back distortion
    {
        float level = 1.0-smoothstep(0.35, 0.3, p.z);
        dist += sin(p.x*15.0)*sin(p.y*15.0)*sin(p.z*15.0)*0.01*level;
    }

    
    check_hit(MATERIAL_BODY);


    return Hit(mindist, material, material_pos);
}

// Function 646
float map(vec3 pos) {
    
    float scale = .55;
    vec3 spacesize = vec3(3.,4.,2.2);
    float distFromCam = length(pos)*0.4;
	vec3 originalPos = pos;

    // Divide the space into cells
    pos.xyz = mod(pos.xyz, spacesize) - spacesize*0.5;

    vec3 p = pos;
	vec2 mouse = vec2(0.7, 1.05) + mousePos;

    float cube = 1e20;
    float res = cube;
    vec3 displacement = vec3(-1., -.5, -2.)*0.75;

    for (int i = 0; i < 8; i++) {
        p.xyz = abs(p.xyz);

        float phase = clock+float(i)*0.25+distFromCam*2.;
        vec2 dispAnim = vec2( sin(phase), cos(phase))*0.025; 

        displacement.yz += dispAnim;
        
        p += displacement * scale;

        phase = clock+float(i)*0.5 + distFromCam;
        pR(p.xz,-distFromCam+mouse.y+float(i)+sin(phase)*.05);
        pR(p.zy,distFromCam+mouse.x+float(i)+cos(phase)*.075);  
   
		scale *= 0.6;
        
        float octa = fIcosahedron(p,scale);
      
        res = min(res,octa);    
    }

    // Animate the pos of the icosahedron
	originalPos.y += cos(length(pos.xz)*4.+clock)*0.015;
	originalPos+=vec3(1.5,1.1,-1.2);
    pR(originalPos.xy, .2+sin(clock)*0.2);
    pR(originalPos.xz,-iTime);
    
    // Smooth min blend the fractal terrain with itself with a param around zero to give it a scaling effect
    res = smin(res, res, -0.025+ sin(-0.5+clock-length(vec3(pos.x*0.5,pos.y*0.9,pos.z))*12.)*0.05);
    res = smin(res, fIcosahedron(originalPos,.2), 0.1);

    return res;
}

// Function 647
vec2 map(vec3 p)
{
    float hm = map_terrain(p);
    //return vec2(min(map_trees(p), hm), TYPE_GRASS);
    vec3 ptrees = p;
    p.y = hm;
    return opMin(
        	vec2(hm, TYPE_GRASS),
        	vec2(map_trees(p*2.0), TYPE_TREE));
}

// Function 648
vec3 colormapPhi(float t) {
    return pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );
}

// Function 649
vec4 map_temp(vec2 fragCoord) {
    float height = MAP_HEIGHT(buf(fragCoord).z);
    float temp0 = climate(fragCoord, PASS3).z;
    float temp = temp0 - mix(4., 3., smoothstep(WARMING_START_TIME, WARMING_END_TIME, iTime)) * height;
    temp = floor(temp/2.)*2.;
    vec4 r = COOL;
    r = mix(r, vec4(1), smoothstep(-20.,  0., temp));
    r = mix(r, WARM,    smoothstep(  0., 25., temp));
    vec4 fragColor = map_land(fragCoord, false);
    fragColor = mix(fragColor, r, 0.35);
    return fragColor;
}

// Function 650
float getDist4( float z, vec4 d, vec4 h )
{
	vec4 v = vec4( z ) - h;
	return opU( opU( opI( v.x, d.x ), opI( v.y, d.y ) ),
				opU( opI( v.z, d.z ), opI( v.w, d.w ) ) );
}

// Function 651
float scene(vec3 p)
{
    vec3 sp = p + vec3(1,3,2);

    return min(
        max(
            max(
                sdBox(p, vec3(1.)),
                -sdBox(p,vec3(.9))
            ),
            abs(mod(length(sp)-iTime*.2,.2)-.1)-.01
        ),
        length(p)-.8
    );
}

// Function 652
vec2 minDist(vec2 mind, float i, float d)
{
   return min(mind, d);
}

// Function 653
float sphereSDF(vec3 samplePoint) {
	return length(samplePoint) - abs(sin(iTime * 1.) * 0.05 + 0.05 + 0.7);
}

// Function 654
float endlessFloorMap() {
    return abs(-10.0-rayPos.y);
}

// Function 655
float GetDist(vec3 p) {
    p = transform(p);
        
    float s = 10.798;
    float t = 0.03;
    float b = 0.3;
    float m = 0.5;
    
    float s1 = 1.345 + ((sin(iTime* 0.01) * 0.5) + 0.5);
    float g1 = sdGyroid(p, s1, 0.03, 1.5);
    
    for (int i = 0; i < GYROID_DETAILS; i++) {
        if (i <= 1) g1 -= sdGyroid(p, s, t, b) * m;
        else g1 += sdGyroid(p, s, t, b) * m;
        s *= 1.75;
        m *= 0.75;
    }
    
    float d = g1 * 0.7;
   	
    return d;
}

// Function 656
vec3 sampleBSDF(float objId,vec3 p,vec3 n)
{
	vec3 dir=uniformHemisphere(rnd(),rnd());
	return l2w(dir,n);
}

// Function 657
float map(vec3 p) {
    return p.y + texture(iChannel0, p.xz/20.).r*2. + texture(iChannel0, p.xz/200.).r*20.;
}

// Function 658
float dist(vec3 pos) {
    return dist_gasket(pos);
}

// Function 659
float getDist(vec3 light, vec2 coord)
{
	return distance(light, vec3(coord, 0.0));
}

// Function 660
float sdFace2(vec3 p) {
    float fiz = mod(p.z, 2.0*HALF_INNER_DIAM);
    vec3 pArch = vec3( abs(fiz-HALF_INNER_DIAM), p.y, abs(p.x) );
    float dArch = sdArchB(HALF_INNER_DIAM, HALF_WIDTH, pArch);

    return dArch;
}

// Function 661
float sceneSDE(vec3 p) {
    float h = p.y;
    float angle1 = iTime;
    float angle2 = iTime * 1.6;
    p.yz *= rot(angle1);
    p.xz *= rot(angle2);
    return min(cylinder(1.,1.,p), h+2.);
}

// Function 662
float distLineSeg(vec2 a, vec2 b, vec2 pos)
{
    float proj = dot(pos - a, b - a) / dot(b - a, b - a);
    vec2 posNearest = mix(a, b, clamp(proj, 0.0, 1.0));
    return length(pos - posNearest);
}

// Function 663
vec4 sampleNormalMap(vec3 N) 
{
    float u = 1.-(atan(N.x, N.z)+PI)/(2.*PI);
	float v = (acos(N.y)/PI);	// 1.- becouse the coordinates origin is in the bottom-left, but I backed from top-left
    return texture(iChannel0, vec2(u, v));   
}

// Function 664
float planeSDF(vec3 pos)
{
    // Bottom plane
    return pos.z+0.4;
}

// Function 665
float DistanceField( vec3 pos )
{
	return min( min( min(
			Foliage( pos ),
			Water( pos ) ),
			Solid( pos ) ),
			Lights( pos )
		);
}

// Function 666
vec2 map_6( in vec3 pos ) { // scene + ro + rd + intersection + normal
    vec2 res = map_2(pos);
    
    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),3. ) );
    res = opU( res, vec2( sdCapsule(    pos, USER_INTERSECT + intersectionNormal, USER_INTERSECT,.025),2. ) );
    
    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );
    return res;
}

// Function 667
float scene(vec3 p)
{
   float tunnel0 = max(-p.y, length(max(vec2(0.0), vec2(-abs(p.z) + 2.0, max(length(p.xy) - 2.0, 0.9 - length(p.xy))))) - 0.03);
   return min(tunnel0, processionOfCubes(p));
}

// Function 668
float distFunc(vec3 p)
{
    float d1 = distSphere(p - sphere1Pos, sphere1Rad);
    return d1;
}

// Function 669
float sdf_sphere(vec3 p, float r)
{
    return length(p) - r;
}

// Function 670
vec3 mapMoss( in vec3 pos, float h, vec3 cur)
{
    vec3 res = cur;

    float db = pos.y-2.2;
    if( db<res.x )
    {
    const float gf = 2.0;
    
    vec3 qos = pos * gf;
    vec2 n = floor( qos.xz );
    vec2 f = fract( qos.xz );

    for( int k=0; k<2; k++ )
    {
        for( int j=-1; j<=1; j++ )
        for( int i=-1; i<=1; i++ )
        {
            vec2  g = vec2( float(i), float(j) );
            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));
            vec2  r = g - f + o;

            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );
            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );

            float mh = 0.5 + 1.0*ra2.y;
            vec3 ros = qos - vec3(0.0,h*gf,0.0);

            vec3 rr = vec3(r.x,ros.y,r.y);

            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );

            rr.xz += 0.5*(-1.0+2.0*ra2);
            vec2 se  = sdLineOri( rr, vec3(0.0,gf*mh,0.0) );
            float sey = se.y;
            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));

            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);

            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );
            float cc = cos(an);
            float ss = sin(an);
            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;

            pp.xz = abs(pp.xz);
            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; 
            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );
            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;
            float d2 = se2.x - (0.02 + 0.03*se2.y);

            d2 = max( d2, (rr.y-0.83*gf*mh) );
            d = smin( d, d2, 0.05 );

            d /= gf;
            d *= 0.9;
            if( d<res.x )
            {
                res.x = d;
                res.y = MAT_MOSS;
                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);
                float e = clamp((pos.y - h)/1.0,0.0,1.0);
                res.z *= 0.02 + 0.98*e*e;
                
                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;
            }
        }
    }

    }
    
    return res;
}

// Function 671
float partDistance(vec3 point, float initialAngle, float worldTime) {
    point = vec3(point.x, abs(point.z) - 0.1, point.y);
    vec3 flattenedPoint = vec3(point.x, 0.0, point.z);
    
    float smoothing = 0.02;
    
    float radiusA = 0.3;
    float radiusB = 0.15;
    float size = 0.38;
    float camAngle = getCamAngle(initialAngle, worldTime);
    vec3 rotatedPoint = erot(flattenedPoint, vec3(0.0, 1.0, 0.0), camAngle);
    float dist = roundConeDistance(rotatedPoint, radiusA, radiusB, size);
    
    const float height = 0.1;
    float halfHeight = height / 2.0;
    float container = boxDistance(point, vec3(0.0, halfHeight, 0.0), vec3(2.0, halfHeight, 2.0));
    dist = opSmoothIntersection(dist, container, smoothing);
    
    vec3 postPoint = point - vec3(0.0, 0.15, 0.0);
    float post = smoothCylinderDistance(postPoint, 0.1, 0.093, smoothing);
    dist = opSmoothUnion(dist, post, 0.01);
    
    vec3 camAttachment = erot(vec3(0.0, 0.0, 0.38), vec3(0.0, -1.0, 0.0), camAngle);

    vec3 jointPoint = point - camAttachment;
    float joint = smoothCylinderDistance(jointPoint, 0.075, 0.093, smoothing);
    dist = opSmoothUnion(dist, joint, 0.005);
    
    float rodX = 0.5;
    float rodLength = 1.0;
    
    vec3 rodEnd = vec3(0.0, 0.0, rodLength + camAttachment.z - 0.1);
    vec3 rodPoint = vec3(point.x, 0.0, point.z);
    float rod = segmentDistance(rodPoint, camAttachment, rodEnd) - 0.1;
    float rodContainer = boxDistance(point, vec3(0.0, -height, 0.0), vec3(2.0, halfHeight, 2.0));
    vec3 rodBasePoint = point - camAttachment - vec3(0.0, -height, 0.0);
    float rodBase = smoothCylinderDistance(rodBasePoint, halfHeight, 0.2, smoothing);
    float rodComposite = opSmoothUnion(
        opSmoothIntersection(rod, rodContainer, smoothing),
        rodBase,
        0.075
    );
    dist = min(dist, rodComposite);
    
    vec3 headPoint = vec3(point.x, point.z - camAttachment.z - rodLength, point.y + 0.1);
    float head = smoothCylinderDistance(headPoint, 0.25, 0.25, smoothing);
    
    vec3 skirtPoint = point - vec3(0.0, 0.0, camAttachment.z + 0.65);
    float skirtCut = cylinderDistance(skirtPoint, 0.25, 0.2);

    vec3 wristPoint = point - vec3(0.0, 0.15, camAttachment.z + 0.95);
    float wristCut = cylinderDistance(wristPoint, 0.1, 0.05);
    
    float headCuts = min(skirtCut, wristCut);
    float headComposite = opSmoothSubtraction(headCuts, head, 0.01);
    dist = min(dist, headComposite);
    
    return dist;
}

// Function 672
vec4 Scene_GetDistance( vec3 vPos )
{
	vec4 vResult = vec4( MAX_DIST, 0.0, 0.0, 0.0 );

    vec2 vWallUV = vec2(vPos.y, -vPos.x) * 1.5;
    vec4 vWallResult = vec4( -vPos.z + 5.0, vWallUV, 0.0 );
    
    if ( vWallResult.x < vResult.x )
    {
        vResult = vWallResult;
    }

	vec4 vPillarResult = Scene_Pillar( vPos );
    
    if ( vPillarResult.x < vResult.x )
    {
        vResult = vPillarResult;
    }
    
	vec4 vSphereResult = Scene_SphereA( vPos );
    
    if ( vSphereResult.x < vResult.x )
    {
        vResult = vSphereResult;
    }

    return vResult;
}

// Function 673
vec2 map(vec3 ro, vec3 p) {
    float r = sqrt(pow(BALL_RADIUS,2.0)-pow(p.y-ro.y,2.0));
    float vCoord = smoothstep(0.0,BALL_RADIUS/2.0,abs(ro.y-p.y));
    float horizontal = step(0.5,0.5+0.5*sin(15.0*(ro.y-p.y)));
    float vertical = step(0.5,0.5+0.5*sin(15.0*(ro.x-p.x+iTime)));
    float color = horizontal*vertical;
    horizontal = 1.0-step(0.5,0.5+0.5*sin(15.0*(ro.y-p.y)));
    vertical = 1.0-step(0.5,0.5+0.5*sin(15.0*(ro.x-p.x+iTime)));
    color += horizontal*vertical;
    vec2 dist = vec2(boingBall(ro-p,BALL_RADIUS), color);
    return dist;
}

// Function 674
float sdf_apply_light(float sdf, vec2 dir)
{
    vec2 grad = normalize(vec2(dFdx(sdf), dFdy(sdf)));
    return dot(dir, grad);
}

// Function 675
sHit map( in vec3 p )
{    
    //vec3 c = vec3(0.5, 0.5, 0.5);
    //vec3 q = (mod(p,c)-0.5*c)*rotmat;
    vec3 q = p*rotmat;
    
    //some animation
    q = q / vec3(pow(1.0 + 0.25*sin(PI*fract(iTime*BPM/SEC_PER_MIN)),2.0));
        
    float mouth = sdTriPrism(zrotate(PI)*q+vec3(-0.866025, -0.5, 0.0), vec2(1.0, 1.5)); //TODO: should be wedge with 50deg edge?
    
    float eyes = opU(sdSphere(q+vec3(0.5,-0.5,0.5), 4.5/14.0),sdSphere(q+vec3(0.5,-0.5,-0.5), 4.5/14.0));
    float head = opS(eyes, opS(mouth, sdSphere(q, 1.0)));
    float teeth = opI(mouth, sdSphere(q, 0.95));

    vec3 ear_p = opCheapBend(q, 0.1); //this causes a strange artifact in soft shadows on my laptop but not my PC?
    //not sure how to fix it but I like the curved ears too much to remove it
    float ear_angle = 70.0 * PI/180.0;
    vec2 ear_size = vec2(0.9,0.1);
    float ears_center = opU(sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)
                     ,sdCappedCylinder(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));
    float ears_edge = opU(sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, -1.1), ear_size)
                     ,sdTorus(zrotate(ear_angle)*ear_p+vec3(-1.1, 0.0, 1.1), ear_size));
    float ears = opS(head, opU(ears_center,ears_edge));
    
    float walls = opU(sdPlane(p + vec3(0.0, 0.0, 4.0), normalize(vec4(0.0, 0.0, 1.0, 1.0)))
                      ,sdPlane(p + vec3(0.0, 4.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 1.0)))) + 0.001;
    
    float result = 1e10;
    result = opU(result, head);
    result = opU(result, teeth);
    result = opU(result, eyes);
    result = opU(result, ears);
    result = opU(result, walls);
    
    sHit hit;
    hit.d = result;
    if(result == head || result == ears)
        hit.material = mat_red;
    else
        hit.material = mat_white;
        
    return hit;
}

// Function 676
vec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )
{
    float theta = atan(vRayDir.x, vRayDir.y);
    vec2 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );
    float fDist = vScene.x;
	vec3 vPos = vRayOrigin + vRayDir * fDist;
	
    vec3 vNormal = Scene_GetNormal( vPos );
    vec2 vUV = vScene.yx * vec2(0.1, 0.05); 
    
    if ( fDist > 350.0 )
    {
        vUV = vec2(0);
    }   

#ifdef REVERSE_DIRECTION
    vUV.y = 1.0 - vUV.y;
#endif    
    
    vec3 vTex = MotionTexture(vUV + 0.25);
    
    vTex = vTex * vTex;
    float t = fDist * fDist;
    float fFog = 1.0 - exp2( -t * 0.00005 );
    vec3 vFogColor = vec3(0.0);
    vec3 vResult = mix( vTex, vFogColor, fFog );
    
    return sqrt(vResult);
}

// Function 677
float map(vec3 pos) {
  int type;
  return map(pos,type);
}

// Function 678
void IntersectScene(vec3 origin, vec3 direction) {
    float t = 0.;
    for (int ii = 0; ii < MAX_STEPS; ++ii) {
        vec3 pos = origin + direction * t;
        vec4 dd = d(pos);
        if (dd.x < MARCH_EPSILON) {
            if (t < MAX_T) {
				intersectionNormal = calcNormal(pos);
            	intersectionPoint = pos;
                intersectionT = t;
                intersectionColor = dd.yzw;
            }
            break;
        }
        t += dd.x;
    }
}

// Function 679
void CubeMapToSH2(out mat3 shR, out mat3 shG, out mat3 shB) {
    // Initialise sh to 0
    shR = mat3(0.0);
    shG = mat3(0.0);
    shB = mat3(0.0);
    
    vec2 ts = vec2(textureSize(reflectTex, 0));
    float maxMipMap = log2(max(ts.x, ts.y));
    float lodBias = maxMipMap-7.0;
    

    for (int i=0; i < ENV_SMPL_NUM; ++i) {
        vec3 sp = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));
        vec3 color = sampleReflectionMap(sp, lodBias);

        mat3 sh = shEvaluate(sp);
        shR = shAdd(shR, shScale(sh, color.r));
        shG = shAdd(shG, shScale(sh, color.g));
        shB = shAdd(shB, shScale(sh, color.b));            
    }

    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)
    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);
    shR = shScale(shR, shFactor );
    shG = shScale(shG, shFactor );
    shB = shScale(shB, shFactor );
}

// Function 680
float sphereSDF(vec3 samplePoint) {
    vec3 position = vec3(2,0,2);
    vec3 position2 = samplePoint - position;
    return length(position2) - 1.0;
}

// Function 681
float particleDistance(int i)
{
    return distance(p, sc(texel(ch0, i2xy(ivec3(i, 0, 0))).xy));
}

// Function 682
Hit GetDist(vec3 p){
    Hit dWalls = Walls(p);
    Hit dSideDoors = SideDoors(p);
    Hit dFloor = Floor(p);
    Hit dCeiling = Ceiling(p);
    Hit dWindow = Window(p);
    
    float ball = fSphere(p - vec3(0.65, 0.5, 4.0), 0.5);
    Hit dBalls = Hit(
        ball,
        99
    );
    
    return OpUnionHit(
        OpUnionHit(
            OpUnionHit(dWalls, dSideDoors),
            OpUnionHit(dCeiling, dFloor)
        ),
        OpUnionHit(dWindow, dBalls)
    );
}

// Function 683
int idSDF (vec3 p) {
    if (SDFobj(p) < SDFfloor(p)) {
        return 1;
    }
    return 0;
}

// Function 684
SDFResult sceneSDF(vec3 p )
{
    SDFResult res = backgroundSDF(p);   
    res = opSmoothAdd( res, testSDF(p), 0.5 );
	return res;
}

// Function 685
void sceneRedSDF(vec2 uv, out vec3 params)
{
	// biggest hack in the prod ;D
	float moontoggle = iBeat > 256. ? 0. : 10000.;
	vec3 dir = normalize(vec3(uv.xy, 1.));
	dir.xy=rotate(dir.xy,-iBeat*0.15);
	dir.zx=rotate(dir.zx,-iBeat*0.15);
	vec3 ray=vec3(1.,1.,iBeat);
	float t=0.0;
	float k = 0.;
	for(int i=0;i<32;i++)
	{
		k=min(sdGrid(ray+dir*t),sdGrid(ray+dir*t+1.5)+moontoggle);
		t+=k*0.75;
	}
	vec3 hit=ray+dir*t;
	vec2 h=vec2(-0.002,0.);
	vec3 n=normalize(vec3(
		min(sdGrid(hit+h.xyy),sdGrid(hit+h.xyy+1.5)+moontoggle),
		min(sdGrid(hit+h.yxy),sdGrid(hit+h.yxy+1.5)+moontoggle),
		min(sdGrid(hit+h.yyx),sdGrid(hit+h.yyx+1.5)+moontoggle)
	));
	float distanc = length(hit-ray);
	float attenDist = 12.0;
	float atten = max(0.0, attenDist-distanc)/attenDist;
	vec3 light = ray;
	float color = atten * dot(n, normalize(hit-light));
	params.x = clamp(color*1.5,0.,1.);
	params.yz = sdGrid(hit+1.5)+moontoggle < .1 ? rangeHalfMoon : rangeReds;
}

// Function 686
float SphereDistance(vec3 localPos, float radius) {
	return length(localPos) - radius;
}

// Function 687
float SDF (vec3 p) {
    float SDFp = 1e40;
    SDFp = min(SDFp, SDFobj(p));
    SDFp = min(SDFp, SDFfloor(p));
    return SDFp;
}

// Function 688
bool mapX0(vec3 p, bool doOpenTop, bool doOpenTopFully)
{    
    bool r;
    
    r =      (p.x >= -8.0 && p.x < 8.0);
    r = r && (p.y >= -8.0 && p.y < 8.0);
    r = r && (p.z >= -8.0 && p.z < 8.0);      
    
    {
        bool a;
        a =      (p.x >= -7.0 && p.x < 7.0);
    	a = a && (p.y >= -7.0 && p.y < (doOpenTopFully ? 8.0 : 7.0));
    	a = a && (p.z >= -7.0 && p.z < 7.0); 
        
        r = r && !a;
    }
    
    {
        bool a;
        a =      (p.x >= -7.0 && p.x < 3.0);
    	a = a && (p.y >= -7.0 && p.y < 7.0);
    	a = a && (p.z == -3.0); 
        
        r = r || a;
    }
    
    {
        bool a;
        a =      (p.x >= -3.0 && p.x < 7.0);
    	a = a && (p.y >= -7.0 && p.y < 7.0);
    	a = a && (p.z == 2.0); 
        
        r = r || a;
    }
    
    {
        bool a;
        a =      (p.x >=  3.0 && p.x < 7.0);
    	a = a && (p.y >= -7.0 && p.y < 7.0);
    	a = a && (p.z == 7.0); 
        
        r = r && !a;
    }
    
    if(doOpenTop)
    {
        bool a;
        a =      (p.x >= -7.0 && p.x < 7.0);
    	a = a && (p.y == 7.0);
    	a = a && (p.z >= -7.0 && p.z < -3.0); 
        
        r = r && !a;
    }
    
    return r;
}

// Function 689
float sphereSDF(vec3 p, float r)
{
    return length(p) - r;
}

// Function 690
vec3 envMap(vec3 p){
    
    p *= 3.;
    //p.xz += iTime*.5;
    
    float n3D2 = noise3D(p*3.);
   
    // A bit of fBm.
    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;
    c = smoothstep(.25, 1., c); // Putting in some dark space.
    
    p = vec3(c, c*c, c*c*c); // Bluish tinge.
    
    return mix(p, p.zyx, n3D2*.25 + .75); // Mixing in a bit of purple.

}

// Function 691
float terrainMap( const in vec3 pos ) {
	return pos.y - terrainMed(pos.xz);  
}

// Function 692
float dist(vec2 a, vec2 b) {
 
    float x = sqr(a.x - b.x);
    float y = sqr(a.y - b.y);
    return sqrt(x + y);
    
}

// Function 693
float OceanDistanceField( vec3 pos )
{
	return pos.y - Waves(pos);
}

// Function 694
vec2 map(vec3 p) {
    float d = mBg(p) * inside;
    float e = p.z + 25.;
    p.z += 17.;
    p.y -= .4;
    float hs = 10.;
    float h = mce(p / hs) * hs;
    vec2 m = vec2(e, 1.);    
    if (h < m.x) {
        m = vec2(h, 2.);
    }
    #ifndef REFRACT
    	if (inside == -1.) return m;
    #endif
    if (d < m.x) {
        m = vec2(d, 0.);
    }
    return m;
}

// Function 695
float map( in vec3 p )
{
    
	float d = cylinder(p.xzy,vec3(0.0),4.75,1.0);
    
    p.yz*=rot(3.14*0.5);
    
    
    p = Folding(p);
    p += .05;
    
    vec3 pos1 = p;
    pos1.x = abs(p.x);
    vec3 pos2 = p;
    
    p.xy = abs(p.xy);
    
    
	float sdf = 0.;
    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));
	sdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));
	sdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));
    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));
    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));
    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));
    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));

    vec3 b1 = p;
	b1.xy -= vec2(0.22,0.08);
    b1 = abs(b1);
    float XYsize =  max(0.0,.5*p.z-0.02);
    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);
    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));
    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));
    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));
	sdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));
    b1.xy *= 0.56;
    b1 = abs(b1-0.02);
	sdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));

    vec3 b0 = pos1;
    b0.xy -= 0.08;
	b0=abs(b0);
    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));
    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));
	sdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));
	sdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));
    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); 
    b0.xy = abs(b0.xy);
    b0.xy -= 0.02;
    b0.xy = abs(b0.xy);
    b0 -= vec3(0.01,0.01,0.02);
    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));
    b0*=noise;
    sdf = min(sdf,sphere(b0,vec3(0.),0.007));
    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));

    vec3 b2 = p;
    b2.xy -= 0.22;
    b2 = abs(b2);
	sdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));
	sdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));
	sdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));
	sdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));
	sdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));
	sdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));
	sdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));
	sdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));
	sdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));

    vec3 b3 = pos2;
    b3.xy -=  vec2(0.08,0.-0.08);
    b3 = abs(b3);
	sdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));
    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));
    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));
    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));
    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));
    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));
    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));
    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));
    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));
	sdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));
    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));

    vec3 b4 = pos2;
    b4.xy -= vec2(0.08,0.-0.22);
    b4 = abs(b4);
    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));
    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));
    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));
	sdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));
    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));
    vec3 cone = b4;
    vec3 stairs = b4;
    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));
    cone.xy += (cone.z-0.021);
    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));
    stairs.xy += floor(stairs.z * 800.0)/800.0;
	sdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));

    vec3 b5 = pos2;
    b5.xy -= vec2(-0.08,0.-0.22);
	b5 = abs(b5);
    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));
	sdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));
	sdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));
	sdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));
	sdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));
	sdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));
	sdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));
    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));
	sdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));

    sdf = max(sdf,d);
    
    return sdf;
}

// Function 696
float distFlatSphere( vec3 p, float s )
{
	return length(p)-s;
}

// Function 697
float map(in vec3 p) {
	float res = 0.;
    vec3 c = p;
	for (int i = 0; i < 3; ++i) {
        p = modifier*abs(p)/dot(p,p) -modifier*clump;
        p.yz= csqr(p.yz);
        res += exp(-contrast * abs(dot(p,c)));
	}
	return res;
}

// Function 698
float ufoSDF( vec3 point, vec3 center, float angle, float len ) {
    vec2 o = vec2( cos( angle ), sin( angle ) );    
    vec3 p = vec3( center.xy + len * o, center.z );
    
    float h = projectVector( p, center, point ) ;
    vec3 q = p + .45 * h * normalize( point -  p );
    
    return ( length( point - q ) - len );
}

// Function 699
float map(vec3 p) {
    p -= OFFSET;
    p /= SCALE;
   	return sdSkull(p);
	return length(p) - .45;
}

// Function 700
float SDF(vec3 p)
{
	return time < 24. ? smin(tubes(p), smin(pool(p), min(ball(p), cage(p)), 2.), 1.5) :
		min(min(ring(p), min(cage(p), ball(p))), smin(tubes(p), smin(pool(p), balls(p), 2.), 1.5));
}

// Function 701
float map(vec3 pos)
{
	vec3 rpos = fract(pos) * 2.0 - 1.0;
    
    float tl = length(rpos);
    float tv = acos(rpos.z/tl);
    float tu = atan(rpos.y,rpos.x);
    
    float bump = texture(iChannel1, vec2(tv,tu)*0.5).x*2.0-1.0;
    
	float d = sdSphere(rpos, 1.2+bump*0.005);
    
    vec2 ts = vec2(0.6,0.05);
    
    float td = 1000.0;
    
    vec3 ro = rpos;
    
    float rad = 0.1 + bump * 0.003;
    
    float ta = sdHexPrism(ro, vec2(rad, 1000.0));
    
    float tb = sdHexPrism(ro*yrot(PI*0.5), vec2(rad, 1000.0));
    
    float tc = sdHexPrism(ro*xrot(PI*0.5), vec2(rad, 1000.0));
    
    d = min(-d, min(min(ta,tb),tc));
    
    return d;
}

// Function 702
float map(vec3 p)
{
    vec3 v = vec3(3,22,3);
    vec3 i = floor((p + v / 2.) / v );
    vec3 o = vec3(0, alt(i), 0);
    vec3 q = mod(p + o + v / 2., v) - v / 2.0;
    float r = step(abs(i.y), 1.5);
    return sdSphere(q, r * 1.1);
}

// Function 703
float scene(vec3 p) {
    p -= vec3(0.0,4.0,0.0);
    float dist = 10000.0;
    for (int i = 0; i < 6; i++) {
        dist = min(dist, spring(p, i));
        dist = min(dist, profileSphere(vec2(p.x, 0.1+profileForIndex((p.yz+vec2(0.0,2.8))*0.4, i)), 0.1));
        p += vec3(0.0,1.5,0.0);
    }
        
    return dist;
}

// Function 704
vec2 map( in vec3 p )
{
    vec2 res = vec2(1000.0,-1.0);

	// terrain
	float h = terrain( p.xz );
	float dd = (p.y - h);
		

	res = vec2( 0.75*dd, 0.0 );

    // bridge
	float dis = bridge( p );
	//if( dis<res.x ) res = vec2( dis, 1.0 );
	res = smin( res, vec2(dis,1.0) );
	
    // water
    dis = p.y - (-2.0);	
	if( dis<res.x ) res = vec2( dis, 2.0 );

    // trees	
	dis = 0.7*trees(p,h);
	if( dis<res.x ) res = vec2( dis, 0.0 );

    return res;
}

// Function 705
vec2 map (in vec3 pos, float sg) {

 	vec2 res = vec2(1000.,-1.);
	pos.xy*=r2(T*.2);
    
    float k = 8.0/dot(pos,pos); 
    pos *= k;

    pos.xz+= 12.5;
    pos.z+=T*12.5;
    float hght = 20.;
    float size = 26.;
    vec3 id =floor((pos + size*0.5)/size);
    float hs = hash21(id.xz)+.1;
	float ff = (hght*hs);
   
    if (hs>.7) {
        ff += ga1;
    } else if(hs>.6) {
        ff += ga2;
    } else if(hs>.5) {
        ff += ga3;
    } else if(hs>.4){
        ff += ga4;
    } else if(hs>.3){
        ff += ga5;
    } else if(hs>.2){
        ff += ga6;
    } else if(hs>.1){
    	ff += ga4-ga3;
    } else {
        ff += ga2-ga1;
    } 

    
    float zid = hs>.6?T*ff:-(T*ff);
    vec3 q = pos-vec3(0.,zid, 0. );

	pMod(q,vec3(size,hght,size));
    pModPolar(q.xz,4.);
	pMirrorOctant(q.zy, vec2(2.15, 3.), ff);

    float d1 = gragtail(q,zid,3);
    if(d1<res.x )  res = vec2(d1,3.);

    float mul = 1.0/k;
    res.x *=  mul / 1.36;
 	return res;
}

// Function 706
float map(vec2 p) {
    float d0 = length(p) - 0.5;
    float d1 = length(p + vec2(-0.25,0.0)) - 0.3;
    float d2 = length(p + vec2(0.0, 0.5)) - 0.2;
    return max(min(d0,d2), -d1);
}

// Function 707
float cloudDist(vec3 rp) {
    float ff = float(iFrame)/33.33333;
    for (float x = 1.; x < 4.; x += x) rp += cos(rp.yzx*100./x+ff)*x*.01;
    return length(max(abs(rp)-.3,0.))+VOLUME(0.2);
}

// Function 708
float map_Gsph(vec3 ro) {
    return distance(ro, Gsphere.xyz) - Gsphere.w;
}

// Function 709
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, inout float ref){


    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.
    const vec2 e = vec2(0.001, 0);
    
    // It'd be nice to have elegant looking code, but in reality, it's all about 
    // hacks. The cube moves in relation to the rest of the scene, and needs 
    // to have it's relative position tracked for texturing purposes... 
    // And the relative sample offsets, it would appear... That's just painful. 
    // Not all coding is fun. :)
    vec3 v0 = e.xyy;
    vec3 v1 = e.yxy;
    vec3 v2 = e.yyx;
   
    if(svObjID==1){
    
        p = svTxP;
        
        if(abs(svPiv.x)>.01){
             v0.xy = svMat*v0.xy;
             v1.xy = svMat*v1.xy;
             v2.xy = svMat*v2.xy;
        }
        else {
             v0.yz = svMat*v0.yz;
             v1.yz = svMat*v1.yz;
             v2.yz = svMat*v2.yz;
        }  
       
        // Overall rotation.
        v0.xy = rot2(mod(lTotDist.x, 2.)*PI)*v0.xy;
        v0.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v0.yz;    
        v1.xy = rot2(mod(lTotDist.x, 2.)*PI)*v1.xy;
        v1.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v1.yz;    
        v2.xy = rot2(mod(lTotDist.x, 2.)*PI)*v2.xy;
        v2.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v2.yz;
        
    }
    
     
    
    // Gradient vector: vec3(df/dx, df/dy, df/dz);
    ref = bumpSurf3D(p, nor); // The reference value is returned for later use.
    vec3 grad = (vec3(bumpSurf3D(p - v0, nor),
                      bumpSurf3D(p - v1, nor),
                      bumpSurf3D(p - v2, nor)) - ref)/e.x; 
    
    /*
    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.
    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),
                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),
                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;
    */
       
    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind 
    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.
    grad -= nor*dot(nor, grad);          
         
    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.
    return normalize(nor + grad*bumpfactor);
	
}

// Function 710
float map(vec3 p)
{ return sdf(rotate(p, iTime) / SDF_SCALE) * SDF_SCALE; }

// Function 711
float seaMapHigh(const in vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        
    	d = seaOctave((uv+SEA_TIME)*freq,choppy);
    	d += seaOctave((uv-SEA_TIME)*freq,choppy);
        h += d * amp;        
    	uv *= sea_octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 712
float map(vec3 p)
{	

	p.z+=(3.-sin(0.314*iTime+1.1));
	pR(p.xz,bounce*.03);
    pR(p.yx,bounce*.4);
    float a = sdBox(p,vec3(.2,.5,1.))-0.02*bounce-(clamp(-100.*sin(.31415*iTime),0.,1.))*0.002*noise(20.*p+bounce); 
    float b = max(a,-sdBox(p-vec3(0,0.65,0),vec3(0.5,0.5,.1)));
    return max(b,-sdBox(p+vec3(0,0.65,0),vec3(0.5,0.5,.1)));
}

// Function 713
float map(vec3 p) {
  return (length(p) - 0.6);
}

// Function 714
float dist3(vec3 p, float r1, float r2){
    
    // See the comments in the "dist" function.
    
    // This is the same as the two functions above, but the smaller cogs cross a boundary line
    // and directional polarity has to be considered.
    float dir = p.x < 0.? -1. : 1.;
    
    p.x = abs(p.x);
    vec3 q2 = p;
    p.xy *= rot2(mod(iTime/1.2*dir + 3.14159/12., 6.2831/12.) + 5.*6.2831/12.); // + 5.*3.14159/12.
    
    
    float a = atan(p.y, abs(p.x)); // Note the "abs" call.
    
    r1 *= (.9 + p.z);
    
    vec3 q = p;
   
    float ia = floor(a/6.2831*12.) + .5;
    q.xy = rot2(ia*6.2831/12.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.
    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.
    q.xy = abs(q.xy);
    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);
    float d2 = max(spike, abs(q.z) - r2);

    
    q = q2; 
    q.xy *= rot2(mod(iTime/1.2*dir, 6.2831/6.) + 2.*6.2831/6.);
    a = atan(q.y, abs(q.x));
    ia = floor(a/6.2831*6.) + .5;
    q.xy = rot2(ia*6.2831/6.)*q.xy;
    sph = max(max(abs(q.x), abs(q.y)) - .02, abs(q.z - .07) - .06);
    //sph = max(length(q.xy) - .02, abs(q.z - .07) - .06);
    q = abs(q + vec3(r1/2., 0, -.07));
    spokes = max(q.x - r1/2. + .02, max(max(q.y - .04, q.z - .015), (q.y + q.z)*.7071 - .02));
    
    
    p = abs(p);
    float d = length(p.xy);
    float di = abs(d  -  r1 + .1/2.) - .05/2.;
    d = abs(d  -  r1 + .075/2.) - .075/2.;
    d = min(max(d , p.z - r2), max(di , p.z - r2 - .007));
    
    return min(d, d2);
    
}

// Function 715
vec3 distCull( in vec3 fg, in vec3 bg, in float dist )
{
    return mix(fg, bg, pow(dist/MAX_DEPTH,16.0));
}

// Function 716
vec4 scene_intersections(vec2 A1, vec2 B1, inout int id){

    float A,B,C,D,E,F,s,t,temp_s,temp_t;
    vec2 pointOnLine, temp_pointOnLine;
    
    s = -1.;
    t = -1.;
    pointOnLine = vec2(0.);
    
    //assuming more than one line we would get 
    //a new A2 B2 each round
    for(int i = 0; i < Seg_N; i++){
    
        vec2 A2 = segmentList[i].A;
        vec2 B2 = segmentList[i].B;
        
        B = B2.x-A2.x;
        A = B1.x-A1.x;

        E = B2.y-A2.y;
        D = B1.y-A1.y;

        C = A1.x-A2.x;
        F = A1.y-A2.y;

        temp_s = (B*F-C*E)/(A*E-D*B);
        temp_t = (A*F-D*C)/(A*E-D*B);
        
        if((temp_s >= 0. && temp_s <= 1.) && (temp_t >= 0. && temp_t <= 1.)){
            
            s = temp_s;
            t = temp_t;
            pointOnLine = vec2(A2.x + t*(B2.x-A2.x), A2.y + t*(B2.y-A2.y));   
            id = segmentList[i].id;
            
        }
        
      }
       
   return vec4(s, t, pointOnLine);
}

// Function 717
void mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )
{
    if(rayDir.x<abs(rayDir.y)||rayDir.x<abs(rayDir.z)) return;
    vec2 major = floor(I.yx/32.);
    vec2 minor = floor(mod(I.yx,vec2(32.)));
    vec4 A = texelFetch(iChannel0, ivec2(minor),0);
    vec4 B = texelFetch(iChannel0, ivec2(major),0);
    vec2 D = A.xy-B.xy;
    if(length(D)>1.){
        
    	//O.xy = 2e3*normalize(D)/ dot(D,D);
    	O.xy = 1e2*D/ dot(D,D);
    } else {
        O.xy = vec2(0.);
    }
    
}

// Function 718
float distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {
    h = dot(p-ro,rd);
    return length(p-ro-rd*h);
}

// Function 719
float map( in vec3 p, out vec4 resColor )
{
    vec3 w = p;
    float m = dot(w,w);

    vec4 trap = vec4(abs(w),m);
	float dz = 1.0;
    
    
	for( int i=0; i<4; i++ )
    {
#if 0
        float m2 = m*m;
        float m4 = m2*m2;
		dz = 8.0*sqrt(m4*m2*m)*dz + 1.0;

        float x = w.x; float x2 = x*x; float x4 = x2*x2;
        float y = w.y; float y2 = y*y; float y4 = y2*y2;
        float z = w.z; float z2 = z*z; float z4 = z2*z2;

        float k3 = x2 + z2;
        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );
        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;
        float k4 = x2 - y2 + z2;

        w.x = p.x +  64.0*x*y*z*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;
        w.y = p.y + -16.0*y2*k3*k4*k4 + k1*k1;
        w.z = p.z +  -8.0*y*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;
#else
        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;
		//dz = 8.0*pow(m,3.5)*dz + 1.0;
        
        float r = length(w);
        float b = 8.0*acos( w.y/r);
        float a = 8.0*atan( w.x, w.z );
        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );
#endif        
        
        trap = min( trap, vec4(abs(w),m) );

        m = dot(w,w);
		if( m > 256.0 )
            break;
    }

    resColor = vec4(m,trap.yzw);

    return 0.25*log(m)*sqrt(m)/dz;
}

// Function 720
float BulbGlassDist( vec3 vPos )
{
    float fSphereDist = length( vPos ) - 1.0;
    float fCylinderDist = length( vPos.xz ) - 0.5;
    fCylinderDist = max( fCylinderDist, -vPos.y );
    float fGlassDist = smin( fSphereDist, fCylinderDist, 0.5 );
    fGlassDist = max( fGlassDist, vPos.y - 1.5);
    return fGlassDist;
}

// Function 721
SDFResult vertcapSDF( VertCap cap, vec3 p )
{
    p -= cap.pos;
    p.y -= clamp( p.y, 0.0, cap.height );
    return SDFResult(length( p ) - cap.radius, cap.matindex);
}

// Function 722
float map(vec3 p) {

    #ifdef DEBUG
        if (p.x < 0.) {
            hitDebugTorus = true;
            return fTorus(p.xzy, 1., 1.4145);
        }
    #endif

    float k;
    vec4 p4 = inverseStereographic(p,k);

    // The inside-out rotation puts the torus at a different
    // orientation, so rotate to point it at back in the same
    // direction
    pR(p4.zy, time * -PI / 2.);

    // Rotate in 4D, turning the torus inside-out
    pR(p4.xw, time * -PI / 2.);

    vec2 uv;
    float d = fTorus(p4, uv);
    modelUv = uv;

    #ifdef DEBUG
        d = fixDistance(d, k);
        return d;
    #endif

    // Recreate domain to be wrapped around the torus surface
    // xy = surface / face, z = depth / distance
    float uvScale = 2.25; // Magic number that makes xy distances the same scale as z distances
    p = vec3(uv * uvScale, d);

    // Draw some repeated circles

    float n = 10.;
    float repeat = uvScale / n;

    p.xy += repeat / 2.;
    pMod2(p.xy, vec2(repeat));

    d = length(p.xy) - repeat * .4;
    d = smax(d, abs(p.z) - .013, .01);

    d = fixDistance(d, k);

    return d;
}

// Function 723
float sdfUnion_s(float a, float b, float k)
{
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);

    return mix(b, a, h) - k * h * (1.0 - h);
}

// Function 724
RMResult map(vec3 p)
{
    float d = FAR;
    float id = -1.;
    
    {// board
        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// rook
		p += vec3(1., 0., 1.);
        float r = 0.4 + (pow(1. - p.y, 2.) / 8.);
        float d0 = sdCappedCylinder(1., r, p);
        vec3 p1 = p - vec3(0., 1.15, 0.);
        float d1 = sdCappedCylinder(0.13, 0.52, p1) - 0.01;
        d0 = smin(d0, d1, 0.15);
        vec3 p2 = p - vec3(0., 1.25, 0.);
        float d2 = sdCappedCylinder(0.1, 0.32, p2) - 0.08;
        float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;
        float l = length(vec2(p2.x, p2.z));
        p2 = vec3(l * cos(a), p2.y, l * sin(a));
        d2 = smin(d2, sdBox(vec3(0.65, 0.1, 0.06), p2), 0.02);
        d0 = smax(d0, -d2, 0.03);
        vec3 p3 = p - vec3(0., 0.935, 0.);
        float d3 = sdEllipsoid(vec3(0.45, 0.1, 0.45), p3);
        d0 = smin(d0, d3, 0.02);
        vec3 p4 = p - vec3(0., -1., 0.);
        float d4 = sdTorus(vec2(0.5, 0.45), p4);
        d4 = max(d4, -sdHPlane(0., p4));
        d0 = smin(d0, d4, 0.05);
        float d5 = sdEllipsoid(vec3(0.8, 0.08, 0.8), p - vec3(0., -0.55, 0.));
        d0 = smin(d0, d5, 0.05);
		float d6 = sdTorus(vec2(0.66, 0.01), p - vec3(0., -0.45, 0.));
        d0 = smax(d0, -d6, 0.05);
		float d7 = sdTorus(vec2(0.63, 0.01), p - vec3(0., -0.38, 0.));
        d0 = smax(d0, -d7, 0.05);
        if (d0 < d)
        {
            d = d0;
            id = 1.5;
        }
    }
    
    return RMResult(d, id);
}

// Function 725
float lineDistance(in vec2 M, vec2 P1, vec2 P2) {
    float x1 = P1.x, y1 = P1.y;
    float x2 = P2.x, y2 = P2.y;
    float x0 = M.x, y0 = M.y;
    float numer = abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1);
    float denom = length(P2 - P1);
    return numer / denom;
}

// Function 726
float scene(vec3 p){
  MATERIAL = getMaterial();
  
  vec3 pp = p;
  
  float n = noise(p*(sqrt(5.0)*0.5 + 0.5)*2.5+iTime*0.25)*0.15;
  
  //HEAD & HAIR
  vec3 head_offset = vec3(0.0, 1.0, 0.0);
  float head = fSphere(pp-head_offset, 0.45);
  
  pp -= vec3(0.0, 1.1, -0.3);
  pR(pp.yz, PI*0.25);
  float hair = fEllipsoid(pp, vec3(0.63, 0.74, 0.4));
  pp -= vec3(0.0, 0.5, 0.1);
  pR(pp.yz, -PI*0.1);
  hair = opSmoothUnion(hair, fEllipsoid(pp-vec3(0.0, 0.0, 0.1), vec3(0.53, 0.2, 0.2)), 0.25);
  hair -= n;
  pp = p;
  
  //FACE
  //EYES
  pp -= vec3(0.0, 0.95, 0.45);
  pp.x = abs(pp.x)-0.15;
  float socket = fEllipsoid(pp, vec3(0.05, 0.03, 0.05));
  float eye = fEllipsoid(pp-vec3(0.0, 0.0, -0.08), vec3(0.05, 0.015, 0.05));
  head = opSmoothSubtraction(socket, head, 0.09);
  pp = p;
  
  //NOSE
  pp -= head_offset;
  float nose = fEllipsoid(pp-vec3(0.0, -0.18, 0.4), vec3(0.03, 0.035, 0.02));
  head = opSmoothUnion(nose, head, 0.1);
  pp = p;
  
  //LIPS
  pp -= head_offset;
  pp.x = abs(pp.x)-0.02;
  float lips = fEllipsoid(pp-vec3(0.0, -0.27, 0.33), vec3(0.08, 0.06, 0.02));
  pp = p;
  
  //NECK
  float neck = fCapsule(pp, 0.15, 1.0);
  head = opSmoothUnion(neck, head, 0.05);
  
  
  //TORSO
  vec3 torso_offset = vec3(0.0, -0.2, 0.0);
  float torso = fEllipsoid(pp-torso_offset, vec3(0.65, 0.7, 0.5));
  torso_offset = vec3(0.0, -1.4, 0.0);
  torso = opSmoothUnion(torso, fEllipsoid(pp-torso_offset, vec3(0.75, 1.25, 0.66)), 0.05);
  
  //SKIRT
  n = noise(p*3.0 + iTime*0.5)*0.1;
  vec3 skirt_offset = vec3(0.0, -2.5, 0.0);
  float skirt = fCone(pp-skirt_offset, 1.2, 2.9);
  skirt -=n;
  
  //SHOULDERS
  pR(pp.xy, PI*0.5);
  vec3 shoulder_offset = vec3(0.2, 0.0, 0.0);
  float shoulders = fCapsule(pp-shoulder_offset, 0.25, 0.54);
  
  pp.y = abs(pp.y)-1.0;
  pR(pp.xy, PI*0.2);
  
  //ARMS
  float arms = fCapsule(pp-vec3(0.01, 0.0, 0.0), 0.19, 0.3);
  pR(pp.xy, -PI*0.5);
  pR(pp.yz, -PI*0.2);
  float hands = fCapsule(pp-vec3(-0.4, -0.5, 0.0), 0.16, 0.4);
  arms = opSmoothUnion(arms, hands, 0.12);
  
  
  //MATERIALS
  if((head < torso && head < skirt && head < shoulders && head < arms && head < hair && head < eye && head < lips) ||
    (arms < head && arms < skirt && arms < shoulders && arms < torso && arms < hair && arms < eye && arms < lips)){
    MATERIAL = getSkin();
  }
  else if(hair < head && hair < torso && hair < skirt && hair < shoulders && hair < arms && hair < eye && hair < lips){
    MATERIAL = getHair();
  }
  else if(eye < head && eye < hair && eye < torso && eye < skirt && eye < shoulders && eye < arms && eye < lips){
    MATERIAL = getEye();
  }
  else if(lips < head && lips < hair && lips < eye && lips < torso && lips < skirt && lips < shoulders && lips < arms){
    MATERIAL = getLips();
  }
  
  glow += vec3(0.2, 0.8, 0.8) * 0.02 / (0.05 + abs(hair));
  
  head = min(head, hair);
  head = opSmoothUnion(head, eye, 0.02);
  head = opSmoothUnion(lips, head, 0.01);
  
  torso = opSmoothUnion(torso, head, 0.01);
  torso = opSmoothUnion(torso, skirt, 0.25);
  torso = opSmoothUnion(torso, shoulders, 0.2);
  torso = opSmoothUnion(torso, arms, 0.14);
  
  return torso;
}

// Function 727
float scene2(vec2 p) {
    p = rot(iTime)*(p-vec2(0.4,0.));
    float ln = linedist(p, vec2(0.,.1), vec2(0.,-.1))-0.05;
    float bx = box(p, vec2(.1));
    return mix(ln, bx, smoothstep(-.2,.2,sin(iTime*0.5)));
}

// Function 728
vec3 nmaps(vec3 x){ return x*2.-1.; }

// Function 729
float map (vec3 pos) {
  float chilly = noise(pos * 2.);
  float salty = fbm(pos*20.);
  
  pos.z -= salty*.04;
  salty = smoothstep(.3, 1., salty);
  pos.z += salty*.04;
  pos.xy -= (chilly*2.-1.) * .2;
    
  vec3 p = pos;
  vec2 cell = vec2(1., .5);
  vec2 id = floor(p.xz/cell);
  p.xy *= rot(id.y * .5);
  p.y += sin(p.x + .5);
  p.xz = repeat(p.xz, cell);
    
  vec3 pp = p;
  moda(p.yz, 5.0);
  p.y -= .1;
  float scene = length(p.yz)-.02;
    
  vec3 ppp = pos;
  pp.xz *= rot(pp.y * 5.);
  ppp = repeat(ppp, .1);
  moda(pp.xz, 3.0);
  pp.x -= .04 + .02*sin(pp.y*5.);
  scene = smoothmin(length(pp.xz)-.01, scene, .2);

  p = pos;
  p.xy *= rot(-p.z);
  moda(p.xy, 8.0);
  p.x -= .7;
  p.xy *= rot(p.z*8.);
  p.xy = abs(p.xy)-.02;
  scene = smoothmin(scene, length(p.xy)-.005, .2);

  return scene;
}

// Function 730
float scene(vec3 p) {
    return min(min(dist(p.xy),dist(p.yz)),dist(p.zx)) - 0.05;
}

// Function 731
float map(in vec3 p){
   
   
    vec4 d;
    
    
    // Back wall.
    
    // Perturbing things a bit.
    vec3 q = p + sin(p*2. - cos(p.zxy*3.5))*.1;
    
    // Grabbing the 2D surface value from the second face of the cubemap.
    float sf2D = surfFunc2D(q);
    
    // Combining the 2D Voronoi value above with an extrusion process to creat some netting.
    d.z = smax(abs(-q.z + 6. - .5) - .05, (sf2D/2. - .025), .02);
    //d.z = -(length(q - vec3(0, 0, -(12. - 6.))) - 12.) + (.5 - sf2D)*.5;
    
    // The back plane itself -- created with a bit of extrusion and addition. 
    d.w = -q.z + 6.;
    float top = (.5 - smoothstep(0., .35, sf2D - .025));
    d.w = smin(d.w, smax(abs(d.w) - .75, -(sf2D/2. - .025 - .04), .02) + top*.1, .02);
    
    
    // The celluar geometric ball object.
    
    // Rotate the object.
    q = rotObj(p);
    // Perturb it a bit.
    q += sin(q*3. - cos(q.yzx*5.))*.05;

    // Retrieve the 3D surface value. Note (in the function) that the 3D value has been 
    // normalized. That way, everything points toward the center.
    float sf3D = surfFunc3D(q);
    
    
    // Adding a small top portion.
    top = (.5 - smoothstep(0., .35, sf3D - .025));
    
    d.x = length(q) - 1.; // The warped spherical base.
    
    // The gold, metallic spikey ball surface -- created via an extrusion process
    d.y = smin(d.x + .1, smax(d.x - .2, -(sf3D/2.-.025 - .06), .02) + top*.05, .1);
    
    // The spherical netting with holes -- created via an extrusion process.
    d.x = smax(abs(d.x) - .025, sf3D/2.-.025, .01);
    
    
    
    // Store the individual object values for sorting later. Sorting multiple objects
    // inside a raymarching loop probably isn't the best idea. :)
    objID = d;
    
    // Return the minimum object in the scene.
    return min(min(d.x, d.y), min(d.z, d.w));
}

// Function 732
bool intersectSceneFromOutside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)
{
	intersectObjFromOutside(ro, rd, tmax, oDis, oNor, outter);
    float d2;
    vec3  n2;
    intersectObjFromInside(ro, rd, tmax, d2, n2, inner);
    if(d2 < oDis)
    {
        oDis = d2;
        oNor = n2;
    }
    return oDis < tmax;
}

// Function 733
float BlobDist( vec3 pos CACHEARG )
{
    // base sphere
    vec3 sphereRelPos = WorldPosToBlobSpherePos( pos );
    float dist = length( sphereRelPos ) - BLOB_RADIUS;
    
    // minus a smaller sphere under the base sphere
    float smallSphereDist = length( sphereRelPos - vec3( 0.0, -5.0, 0.0 ) ) - BLOB_RADIUS * 0.7;
    dist = smax( dist, -smallSphereDist, BLOB_RADIUS * 0.8 );
    
    // stand
    vec3 standPos = pos;
    standPos.y = max( standPos.y, 0.0 );
    standPos.z *= 1.3;
    
    float aboveGroundAmount = pos.y - GROUND_PLANE_HEIGHT;

    float angle = aboveGroundAmount * (-1.5 * PI / (BLOB_ORIGIN.y - GROUND_PLANE_HEIGHT));
    vec2 sincos = vec2( cos( angle ), sin( angle ) );
    standPos.xz = standPos.xx * sincos + standPos.zz * vec2( -sincos.y, sincos.x );
    
    standPos.x += aboveGroundAmount * 0.4; // slant a bit
    
    float standThickness = 5.0 / (aboveGroundAmount * 1.0 + 1.0);
    float standDist = length( standPos ) - standThickness;
    standDist *= 6.0; // make stronger so the noise function can't change it as much
    
    dist = smin( dist, standDist, 4.0 );
    
    #if NOISE_IN_BLOB_SHAPE
    // noise
    vec3 noisePos = sphereRelPos;
    noisePos = Droop( noisePos );
    noisePos = BlobSpherePosToWorldPos( noisePos );
    noisePos *= 0.9;
    noisePos.y += blobTime * 0.2; // gradually translate downward
    float noise = Noise3D( vec4( noisePos, blobTime * NOISE_CHANGE_RATE ) CACHE ) * 3.5;
    
    dist += noise * smoothstep( 0.0, 4.0, aboveGroundAmount );
    #endif
    
    // disappear at ground plane height
    float nearGroundFrac = max( (1.0 - aboveGroundAmount) / 1.0, 0.0 );
    nearGroundFrac *= nearGroundFrac;
    nearGroundFrac *= nearGroundFrac;
    //nearGroundFrac *= nearGroundFrac;
    dist += nearGroundFrac * 8.0;
    dist = smax( dist, aboveGroundAmount * -6.0, 6.0);
    
    return dist;
}

// Function 734
float map(vec3 p){
    vec3 pn = p;
    p.x = mod(p.x, 3.0)-1.5;
    p.z = mod(p.z*0.2+p.x, 3.0)-1.5;
    p.y += (pn.x*sin(iTime*0.2))*0.2;
    
    p += 0.0001*cross(pn.zyx,p*sin(iTime));
    
    return length(p) - 1.5*abs(cos(iTime*0.2))+0.7*sin(pn.x*pn.z*0.000001);
}

// Function 735
float distFunc(vec3 p)
{
    float s = 4.0;
    float d1 = distCylinderXY(p, vec3(0.0, 0.0, s));
    float d2 = distCylinderXY(p, vec3(0.0, 0.0, s - 0.2));
    float d3 = distCappedCylinder(trans(p, 4.0), vec2(1.0, 3.5));
	//return d3;
    return max(max(d1, -d2), -d3);
}

// Function 736
float mapHand( const vec3 pos, const float w, const float l, const float r ) {
    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);
    d = min(d, length(pos.xz) - (.03+r));
    return max(d, abs(pos.y)-.005);
}

// Function 737
float uSDF(float s1, float s2) { return min(s1, s2);}

// Function 738
vec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k, in float LOD)
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz, LOD);
  vec4 y = textureLod( sam, p.zx, LOD);
  vec4 z = textureLod( sam, p.xy, LOD);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 739
float distSquaredCylinder( vec3 p, vec3 d, float r)
{
	return max(length(max((abs(p.xz)-d.xz),0.0))-r,abs(p.y)-d.y);
}

// Function 740
vec3 GetEnvMap(vec3 rayDir, vec3 sunDir)
{
    // fade the sky color, multiply sunset dimming
    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;
    // make clouds - just a horizontal plane with noise
    float n = noise2d(rayDir.xz/rayDir.y*1.0);
    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;
    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;
    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;
    n = pow(abs(n), 3.0);
    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance
    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));

    // add the sun
    finalColor += GetSunColorSmall(rayDir, sunDir);
    return finalColor;
}

// Function 741
float orbSDF(in vec3 iPoint, in vec3 iPosition, in float iRadius) {
    
    // An orb is a simple sphere    
	return length(iPoint - iPosition) - iRadius;   
    
}

// Function 742
float debugPillarSdf(vec3 pos)
{
  opRepeat(pos.x, 12.0);
  float c0 = sdCylinderY(pos, vec3(6.0, 6.0, LIGHT_RADIUS * 0.1));
  //float c1 = sdCylinderY(pos, vec3(0.0, 6.0 + LIGHT_RADIUS, LIGHT_RADIUS * 0.1));
  return c0;
}

// Function 743
float Mat3SDF( vec3 p )
{
    // floor
    return -abs(p.y-1.)-(-2.);
}

// Function 744
maybe_vec2 get_distances_along_3d_line_to_capsule(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r
){
    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);
    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);
    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);
    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);
    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);
    return capsule;
}

// Function 745
float map(vec3 p )
{
 // if (abs(p.x) < 1.) return 0.;             // slice
	vec3 q = p - vec3(0,.1,1)*iTime;
	float f = 0., s=.5;
    for (int i=0; i< 5; i++ , s/= 2. )
        f += s* noise( q ), q *= 2.;

	return clamp( 1.5 - p.y - 2. + 1.75*f, 0., 1. ); // why not just max(0.,) ?
}

// Function 746
vec2 SDFSeaScene(vec3 r)
{
	float t=999999.0;

    float seaplane=sdSeaBox(r,vec4(0.0,1.0,0.0,1.0));
    t=min(t,seaplane);

    vec3 curpoint;
    curpoint.x=0.0;
    if (iTime<65.0) curpoint.y=0.0;
    else curpoint.y=1.5;
    if (iTime<60.0) curpoint.z=8.0+iTime*10.0;
    else if (iTime<65.0) curpoint.z=-58.0+iTime*10.0;
    else curpoint.z=iTime*10.0;
    r=r-vec3(curpoint.x,curpoint.y,curpoint.z);

    float paperplane=sdPaperplane(r);
    t=min(t,paperplane);
    
    if (t==paperplane) return vec2(t,1.0);
    if (t==seaplane) return vec2(t,2.0);
    
    return vec2(-1.0);    
}

// Function 747
float map(vec3 p, bool trick) {
    mat3 rot = euler(-tick/3.*PI.z,tick/5.*PI.z,0.0);
    float d = dfPln(p, vec3(0,1,0), 0.);
    p = trans(p);
    d = min(d, dfDdc((p+vec3(sin(tick/8.*PI.z)*10.,0.,cos(tick/16.*PI.z)*8.))*rot, 1.5));
    d = min(d, dfDdc((p+vec3(cos(tick/16.*PI.z+PI.x)*8.,sin(tick/8.*PI.z+PI.y)*8.,0.))*rot, 1.));
    d = min(d, dfBox(p-t.zxy, r.xyy, r.z));
    d = min(d, dfBox(p-t.zyy, r.xyy, r.z));
    d = min(d, dfBox(p-t.xzx, r.yxy, r.z));
    d = min(d, dfBox(p-t.yzx, r.yxy, r.z));
    d = min(d, dfBox(p-t.xzy, r.yxy, r.z));
    d = min(d, dfBox(p-t.yzy, r.yxy, r.z));
    d = min(d, dfBox(p-t.yxz, r.yyx, r.z));
    d = min(d, dfBox(p-t.yyz, r.yyx, r.z));
    if (trick) {
        d = min(d, dfBox(p-t.zxx, r.xyy, r.z));
        d = min(d, dfBox(p-t.zyx, r.xyy, r.z));
        d = min(d, dfBox(p-t.xxz, r.yyx, r.z));
        d = min(d, dfBox(p-t.xyz, r.yyx, r.z));
    }
    return d;
}

// Function 748
float map(vec3 p)
{
    float time = iTime+0.2;
    p.z -= 1.5;
    
    float twist = 0.5+sin(fract(time*0.4)*TAU)*0.5;
    twist *= p.y * 1.5;
    p.xz *= rotate(twist+fract(time*0.26)*TAU);
    
    float dist = NewSymbol(p.xy);
    
    float dep = 0.02;
    vec2 e = vec2( dist, abs(p.z) - dep );
    dist = min(max(e.x,e.y),0.0) + length(max(e,0.0));
    dist -= 0.01;
    return dist;
}

// Function 749
float distTanCurveTor(vec3 pos, vec3 p1, vec3 p2, vec3 t1, vec3 t2, vec3 p0, float parity, float sc,inout vec2 uv)
{
    vec3 bx=p1-p0;
    vec3 bz=normalize(p0);
    vec3 by=normalize(cross(bz,bx));
    bx = cross(by,bz);
 
    vec3 c = p0+bz*(dot((p1+p2)*.5-p0,bz));
    
    vec3 d20  = p2-c;
    float ddz = dot(d20,bz);
    d20 -= bz*ddz;
    d20 = normalize(d20);
    /*vec3 d10  = p1-c;
    float ddz2 = dot(d10,bz);
    d10 -= bz*ddz2;
    d10 = normalize(d10);*/
    vec3 dpos = normalize(pos-dot(pos,bz)*bz);
    
    float ang   = abs(atan((dot(cross(bx,dpos),bz)),dot(bx,dpos)));
    float ang12 = abs(atan((dot(cross(bx,d20), bz)),dot(bx,d20)));
    
    float fact = ang/ang12;
    
    float r1 = length(p1-c+bz*ddz);
    float r2 = length(p2-c-bz*ddz);
    float r  = mix(r1,r2,fact);
    
    float ampl = mix(dot(t1,p1),dot(t2,p2),fact);

    float af=floor(ang12/PI2*6.+.5)*PI2/6./ang12;  // scale to next multifold of 60 degree
    
    vec3 npos=normalize(pos);
    
    float d=10000.;
    #if 1

    //vec3 pr=(pos-p0)*mat3(bx,by,bz);
    //return distCircle(pr+vec3(0,0,1)*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.)),r);
    //d = distCircleN(pos-p0+bz*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.)),p0,r);
    
    //vec3 z=normalize(pos);
    pos+=bz*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));
    float zang=ang*sign(ampl)*af*6.*max(1.,floor((r1+r2)/sc*2.5))-iTime*3.;
    float zang0=zang;
    for(int i=min(iFrame,0);i<3;i++)
    {
        vec2 cs=.025*sc*vec2(.5,1)*cos(zang*vec2(2,1)+vec2(0,-PI2*.1666))*vec2(1,parity);
        //vec3 dpos=cs.x*normalize(pos)+cs.y*normalize(p0-pos-dot(p0-pos,pos)*pos/dot(pos,pos));
        vec3 dpos=cs.x*npos+cs.y*normalize(p0-dot(p0,npos)*npos);
        float dold=d;
        float aang;
        d = min(d,distCircleNnAng(pos-c+dpos,bz,r,aang));
        //if(d<dold) d+=.00035*(texture(iChannel0,vec2(.5,.08*rang)).x-.5);
        if(d<dold) uv=fract(vec2(zang0,aang*2.)/PI2);
        zang+=PI2*.66666;
    }
    
    #else 
    
    vec3 pr=(pos-c);
    //pi=bz*(.55*r*r*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));
    vec3 p = vec3(cos(-ang-vec2(0,PI2/4.))*r,0);
    p-=vec3(0,0,1)*(.1*r*ang12*ampl*sin(fact*PI2)+ddz*(1.-fact*2.));
    p=mat3(bx,by,bz)*p;
    float zang=ang*sign(ampl)*af*6.*max(1.,floor((r1+r2)/sc*2.5))-iTime*3.;
    for(int i=0;i<3;i++)
    {
        vec2 cs=.025*sc*vec2(.5,1)*cos(zang*vec2(2,1)+vec2(0,-PI2*.1666))*vec2(1,parity);
        vec3 dpos=cs.x*npos+cs.y*normalize(p0-dot(p0,npos)*npos);
        d=min(d,length(p+dpos-pr));
        zang+=PI2*.66666;
    }
    
    //d=length(pr-p);
    
    #endif

    //d+=cs.y;
    
    #ifdef SHOW_FLOW
    if(ang<0.0) ang+=PI2;
    float af=floor(ang12/PI2*6.+.5)*PI2/6./ang12;  // scale to next multifold of 60 degree
    d+=.007*sin(ang*sign(ampl)*af*6.*floor((r1+r2)*8.)+iTime*3.);
    #endif
    
    return d;    
}

// Function 750
float GlyphSDF(vec2 p, float char)
{
    // Convert glyph to appropriate char index in the char texture and compute distance to it
	p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;
	return 2. * (texture(iChannel0, p / 16. + fract(vec2(char, 15. - floor(char / 16.)) / 16.)).w - 127. / 255.);
}

// Function 751
vec2 map(vec3 pos)
{
 
  vec2 scene = vec2(.5 * sdSkull(pos, .35), 39.);
  
  return scene;     
}

// Function 752
float dist(vec3 p)
{
    float l = pow(dot(p.xz,p.xz),.8);
    float ripple = p.y+.8+.4*sin(l*3.-iTime+.5)/(1.+l);
    
    float h1 = -sin(iTime);
    float h2 = cos(iTime+.1);
    float drop = length(p+vec3(0,1.2,0)*h1)-.4;
    drop = smin(drop,length(p+vec3(.1,.8,0)*h2)-.2);
    return smin(ripple,drop);
}

// Function 753
float mapH(vec3 p) {
    return - p.z + .1 * (t2d(p.xy).a - .015*pow(t2d(p.xy).r, .125));
}

// Function 754
vec4 DrawMap( vec2 vTexCoord )
{
    if ( vTexCoord.y < 0.0 )
    {
        return vec4(0,0,0,1);
    }    
        
    float fScale = 10.0;
        
    vec2 vPixelWorldPos = vTexCoord;    
    vPixelWorldPos -= vec2(200, 150); 
    vPixelWorldPos *= fScale;
    vPixelWorldPos += vec2(1056, -3616);
    
    fScale *= 1.1;
    
    //for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)
    for(int iSectorIndex=0; iSectorIndex < g_mapInfo.iSectorCount; iSectorIndex++)
    {
        //if ( iSectorIndex > g_mapInfo.iSectorCount )
          //  break;

        Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );

        /*if ( Map_PointInSector( vPixelWorldPos, sector ) )
{
vResult = vec3(1,0,0);
}*/


        for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)
        {
            SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        

            vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );

            float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );
            fProj = clamp( fProj, 0.0, sideDef.fLength );

            vec2 vClosest = sideDef.vA + vSideDir * fProj;
            float fDist = length( vClosest - vPixelWorldPos );

            if (fDist < fScale * .5 )
            {
                if ( sideDef.iNextSector != SECTOR_NONE )
                {
                    return vec4(1,1,0,1);
                }
                else
                {
                    return vec4(1,0,0,1);
                }
            }
        }			
    }
        
    return vec4(0.0);
    
}

// Function 755
float sdfSquare(vec2 pnt, vec2 center, float shortRadius) {
  vec2 v = pnt - center;
  float ret = -kLargeFloat;
  ret = max(ret,  v.x - shortRadius);
  ret = max(ret, -v.x - shortRadius);
  ret = max(ret,  v.y - shortRadius);
  ret = max(ret, -v.y - shortRadius);
  return ret;
}

// Function 756
vec2 SDF( vec3 p, vec3 ro, vec3 rd )
{
  vec2 result;

  float upDown = sin(iTime * 0.00173) * 0.5;

  vec3 pos = p;

  result = Duck(pos, ro, rd);
    
  if(PUREDUCK < 0.5)
  {
      result = opU(result, stage(p - vec3(0.0, -42.8, 0.0), ro, rd));
      result = opU(result, SunMoon(p - vec3(0.0, -42.8, -10.0), ro, rd));      
  }
    
  return result;
}

// Function 757
float scene(vec3 p)
{
	float d1 = length(p.xz);
	float d2 = length(p.xz-vec2(1.,0.));
	float h; 
	
	// main shape
	h =  .4*sin(5.*d1-time       )/(.4+d1*d1)
	   + .4*sin(5.*d2-.71234*time)/(.4+d2*d2);

	// add details
	vec3 pp = 15.*p+4.*time*vec3(.5,.4,.8);
	float n;
	if (p.y-h < .2) n = fbm(pp); // details only if close
	else n = 0.; //.5*noise(pp); // detail approx
	_h = h; _n = n; _d=d1;
	h += .2*n; 
	
	return  .1*max(p.y-h,0.);
		// length(advfbm(10.*p.xy));
}

// Function 758
float heightMap(vec3 p, float s) {
    float h = 0.0;
    float a = s;
    float f = FLOOR_TEXTURE_FREQ;
    for(int i=0;i<5;++i) {
        vec3 hm = textureLod(iChannel0, p.xz*f, 0.0).rgb;
        float avg = 1.0-0.33*(hm.r+hm.g+hm.b);
        h += avg*a;
        a *= 0.22;
        //f *= 1.9;
    }
    return h-textureLod(iChannel0, p.xz, 0.0).r*0.02+cos(p.x)*0.02+p.z*0.03*log(length(p));
}

// Function 759
float mapVoxel(in vec3 p) {
    //data=-.3;

    p=fract(p/minsize);
    //p= sign(p-.5)*sqrt(p-.5)+.5;
    return mix( mix(mix(v[0],v[1],p.x),mix(v[2],v[3],p.x),p.y),
                mix(mix(v[4],v[5],p.x),mix(v[6],v[7],p.x),p.y),  
            p.z) ;       

}

// Function 760
float sceneSDF(vec3 samplePoint) {
    float d = 1000.;
    
	mat4 timeRotation = rotate(4. * iTime, normalize(vec3(-1, -1.5, 0)));
    samplePoint = (timeRotation * vec4(samplePoint, 1)).xyz;
    
    for (int i = 0; i < 8; ++i) {
		float randA = 5. * (rand(vec2(float(i), 0.))- .5);
        float randX = rand(vec2(float(i), 1.)) - .5;
        float randY = rand(vec2(float(i), 2.)) - .5;
        float randZ = rand(vec2(float(i), 3.)) - .5;
        float sphere_radius = .2;
        float freq = 1.;//3. + 5. * rand(vec2(float(i), 3.));
        float phase = radians(360.) * rand(vec2(float(i), 5.));
        float smin_k = 5. + 1.5 * sin(iTime);

	    mat4 axisRotation = rotate(randA, normalize(vec3(randX, randY, randZ)));
	    d = smin(d, sphereSDF((axisRotation * vec4(samplePoint, 1) + vec4(.9*sin(freq * iTime + phase), 0, 0, 1)).xyz, sphere_radius), smin_k);
	}

    return d;
}

// Function 761
float map(in vec3 position) {
  return -sdTorus(position, ringRadius, pipeRadius);
}

// Function 762
float distfunc(vec3 pos)
{
    return BoxCross(pos);
}

// Function 763
float sceneSDF(vec3 p) {
    return coneSDF(p, vec2(sqrt(3.0)*0.5, 0.5));
}

// Function 764
float mapt( in vec3 p, float time )
{
	//vec3 q = p - vec3(0.0,0.1,1.0)*iTime;
    
    // Add a vortex!
    vec3 q0 = p;
    vec3 vcenter = vec3(0); // Vortex center
    vec3 axis = vec3(0,1,0); // Vortex axis (should be normalized)
    float r0 = 2.0; // Radius at which velocity is maximal
    float h = dot(q0-vcenter, axis);
    float r2 = dot(q0-vcenter,q0-vcenter) - h*h; // Distance of p from the axis
    float theta = time/(r0*r0 + r2); // Rotation angle
    q0 = vcenter + rot(q0-vcenter, axis, theta);
    vec3 q = q0;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q ); q = q*2.01;
    f += 0.06250*noise( q );
	return clamp( 1.5 - q0.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

// Function 765
float HexEdgeDist (vec2 p)
{
  p = abs (p);
  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);
}

// Function 766
float scene(vec3 p) {
    vec3 q = p - vec3(-10.0, 1.0, -4.);
    vec3 s = vec3(q);
    //q.xz = mod(q.xz + 1.0 , 2.0) - 1.0;

    q.xz = opRepLim(q.xz, 2.0, vec2(1.0, 1.0), vec2(8.0, 4.0));
    vec3 qq = vec3(q.x, abs(q.y - 2.0) - 2.0, q.z);
    float d = plane(p, vec3(0.0, 1.0, 0.0), 0.1);
    d = min(d, cyl(q, 0.4));
    d = min(d, box(qq, vec3(0.6, 0.1, 0.6)));
    d = max(d, - box(s - vec3(9.0, 0.0, 5.0), vec3(6.0, 4.0, 2.0)));

    vec3 f = s - vec3(0.0, - 0.1, 0.0);
    f.y = abs(f.y- 2.)-2.2;
    vec3 sz = vec3(0.95, 0.01, 0.95);
    f.xz = opRepLim(f.xz, 2., vec2(1.0, 1.0), vec2(8, 4.0));
    d = min(d, box(f, sz - 0.1) - 0.2);

    vec3 g = s - vec3(-3.0, - 0.6, - 3.0);
    vec3 gsz = vec3(1.5, 0.2, 1.5);
    g.xz = opRepLim(g.xz, 3.0, vec2(1.0, 1.0), vec2(7.0, 4.0));
    d = min(d, box(g, gsz - 0.2) - 0.2);

    return d ;
}

// Function 767
float sdf_QUAKE(vec2 uv)
{
    uv.x *= .9375;
    float sdf						   = sdf_Q_top(uv);
    uv.x -= .875;	sdf = sdf_union(sdf, sdf_U(uv));
    uv.x -= .8125;	sdf = sdf_union(sdf, sdf_A(uv));
    uv.x -= 1.0625;	sdf = sdf_union(sdf, sdf_K(uv));
    uv.x -= .625;	sdf = sdf_union(sdf, sdf_E(uv));
    return sdf;
}

// Function 768
float torusSDF(vec3 p, vec2 t)
{
	vec2 q = vec2(length(p.xz)-t.x,p.y);
	return length(q)-t.y;
}

// Function 769
vec2 mapTerrain( vec3 p, float t )
{
    float h = -2.0+0.03;

    h += 5.0*textureImproved( iChannel2, iChannelResolution[2].xy, 0.0004*p.xz, 0.0004*t*drddx.xz, 0.0004*t*drddy.xz ).x;
    
    float di = smoothstep(100.0,500.0,length(p.xz) );
    h += 2.0*di;
    h *= 1.0 + 3.0*di;

	const float stonesClip = 100.0;
    if( (p.y-h)<0.5 && t<stonesClip )
    {
        float at = 1.0-smoothstep( stonesClip/2.0, stonesClip, t );
        float gr = textureGrad( iChannel2, 0.004*p.xz, 0.004*t*drddx.xz, 0.004*t*drddy.xz ).x;
        float pi = textureGrad( iChannel0, 0.400*p.xz, 0.400*t*drddx.xz, 0.400*t*drddy.xz ).x;
            
        gr = smoothstep( 0.2, 0.3, gr-pi*0.3+0.15 );
        h += at*(1.0-gr)*0.15*pi;
        h += at*0.1*textureGrad( iChannel2, 0.04*p.xz, 0.04*t*drddx.xz, 0.04*t*drddy.xz ).x;
    }


    float d = 0.8*(p.y-h);
    
    return vec2(d,2.0);
}

// Function 770
float scene(vec3 p)
{
 p=mod(p,5.0)-2.5;
 vec3 sPos=vec3(0.0,0.0,0.0);
 return length(p-sPos)-1.0;
}

// Function 771
float bsdfPdf(vec3 w,vec3 n)
{
    return dot(w,n)>0.?INV_2PI:0.;
}

// Function 772
float planeSDF(vec3 p, vec3 n)
{
    return length(p) * dot(normalize(p), n);
}

// Function 773
vec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )
{
    return mix(v2, v1, step(v2.x,v1.x));
}

// Function 774
float sphere_sdf(vec3 query_point, float sphere_radius) {
    float l = length(query_point);
    float df = l - sphere_radius;
    
    return df;
}

// Function 775
float cone_sdf(in vec3 loc) {
    float cone_length = 
        abs(loc.x) + length(loc.yz);
	cone_length = 0.7 * (cone_length - 1.5);

	return cone_length;
}

// Function 776
void configMap() {
 
    gPosMain      = vec3(0.0, 0.3, 0.0);
    
    gTablePos     = vec3(0.0, -0.4, 0.0);
    
    float tableMod = smoothstep(1.0, -2.0, gCamPos.y - gTablePos.y);
    gTableRad     = 0.9;
    gTableThick   = 0.01 + 0.6 * tableMod;
    gTablePos.y   += 0.6 * tableMod;
    gTableHoleRad = (gTableRad - gBevels * 2.0) * tableMod;
}

// Function 777
float remap(float a, float b, float c, float d, float t)
{
    return sat(((t - a) / (b - a)) * (d - c) + c);
}

// Function 778
SceneResult Scene_GearsSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    float fTime = 0.0f;
    
    
    SceneResult resultFloor;
    
    resultFloor.fDist = vPos.y;
    resultFloor.vUVW = vec3(vPos.zxy * 0.1);
    resultFloor.iObjectId = MAT_TEXTURED_FLOOR;

            
    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );            	
    
    float fRepeatX = 3.5;
	vec2 vChainTile;
	vec2 vRepeat = vec2(fRepeatX, 8.0);
	vec3 vRepeatDomain = DomainRepeatXZGetTile(vPos, vRepeat, vChainTile);
			
    float fGearDist = 1000.0;
    {
		vec3 vGearDomain1 = DomainRepeatXZ(vPos+vec3(0.0, 0.0, 4.0), vRepeat);
        vGearDomain1.y -= 0.4;
		vGearDomain1 = RotateY( vGearDomain1, fTime);		
        
	    SceneResult resultGearA;

        resultGearA.fDist = GetDistanceGear(vGearDomain1);
        resultGearA.vUVW = vec3(vGearDomain1.zxy * 0.1);
        resultGearA.iObjectId = MAT_GEAR;    
        
    	SceneResult_Combine( resultInside, resultOutside, resultGearA, insideObjId );            	
        
        
		vec3 vGearDomain2 = DomainRepeatXZ(vPos+vec3(fRepeatX * 0.5, 0.0, 4.0), vRepeat);
        vGearDomain2.y -= 0.43;
        vGearDomain2.z += 1.0;
		vGearDomain2 = RotateY( vGearDomain2, -fTime + (2.0 * PI / 32.0) + 0.18);
        
	    SceneResult resultGearB;

        resultGearB.fDist = GetDistanceGear(vGearDomain2);
        resultGearB.vUVW = vec3(vGearDomain2.zxy * 0.1);
        resultGearB.iObjectId = MAT_GEAR;    
        
    	SceneResult_Combine( resultInside, resultOutside, resultGearB, insideObjId );            	
        
		
	}
    
  	SceneResult sph1result;
    
    vec3 vSph1Pos =  vPos - vec3(0,3,0);
    sph1result.fDist = length(vSph1Pos) - 1.0;
    sph1result.vUVW = vec3(vPos);
    sph1result.iObjectId = MAT_EMISSIVE_LIGHT;
    
    SceneResult_Combine( resultInside, resultOutside, sph1result, insideObjId );    
    
    

    return SceneResult_Union( resultInside, resultOutside );
}

// Function 779
Model map( vec3 p ){
    p /= modelScale;
    boundsThreshold = .1 / modelScale;
    Model model = iteratedModel(p);
    model.dist *= modelScale;
    return model;
}

// Function 780
vec3 envMap(vec3 p){
    
    p *= 3.;
    
    float n3D2 = noise3D(p*3.);
   
    // A bit of fBm.
    float c = noise3D(p)*.57 + noise3D(p*2.)*.28 + noise3D(p*4.)*.15;
    c = smoothstep(.25, 1., c); // Putting in some dark space.
    
    p = vec3(c, c*c, c*c*c); // Bluish tinge.
    
    return mix(p, p.zyx, n3D2*.5 + .5); // Mixing in a bit of purple.

}

// Function 781
vec3 GetSceneNormal( const in vec3 vPos )
{
    const float fDelta = 0.001;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetSceneDistance( vPos + vOffset1 ).x;
    float f2 = GetSceneDistance( vPos + vOffset2 ).x;
    float f3 = GetSceneDistance( vPos + vOffset3 ).x;
    float f4 = GetSceneDistance( vPos + vOffset4 ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 782
vec4 DebugSDFPatternColor(float d)
{
	float offset = sign(d)*0.3;
    vec4 nearColor = vec4(0.4 + offset, 0.35, 0.4 - offset, 1.0);
    vec4 farColor = vec4(0.55 + offset, 0.65, 0.55 - offset, 1.0);
    return mix(nearColor, farColor, clamp(abs(d*10.0), 0.0, 1.0));
}

// Function 783
float signedDistanceSphere(in vec2 position, float radius ) { return length(position)-radius; }

// Function 784
float dist(vec3 p)
{
    // Oh yeah that nesting right there I'm the king of tiny wings collectables.
	return min(min(min(min(min(pillars(p),wires(p)),bollards(p)),pipes(p)),rafters(p)), garage(p));
}

// Function 785
float rmap(vec2 uv, RSet2 rs) {
    return RAND(map(uv, rs.q, rs.l), rs.r);
}

// Function 786
vec3 doBumpMapBrick(in vec3 p, in vec3 nor, float bumpfactor){
	vec3 n = abs(nor);
    const vec2 e = vec2(0.001, 0);
    float ref = bumpSurf3D(p, nor);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, n), bumpSurf3D(p - e.yxy, n), bumpSurf3D(p - e.yyx, n) )-ref)/e.x;                     
    grad -= nor*dot(nor, grad);                            
    return normalize( nor + grad*bumpfactor );
	
}

// Function 787
vec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {
// distance meter function. needs a bit more than just the distance
// to estimate the zoom level that it paints at.
//
// if you have real opengl, you can additionally use derivatives (dFdx, dFdy)
// to detect discontinuities, i had to strip that for webgl
//
// visualizing the magnitude of the gradient is also useful
	float idealGridDistance = 20.0/ rayLength* pow(abs(rayDir.y),0.8);
	float nearestBase = floor(log(idealGridDistance)/ log(10.));
	float relativeDist = abs(dist/ camHeight);

	float largerDistance = pow(10.0,nearestBase+ 1.);
	float smallerDistance = pow(10.0,nearestBase);

	vec3 col = fusionHDR(log(1.+ relativeDist));
	col = max(vec3(0.),col);
	if((dist)< 0.) {
		col = col.grb* 3.;
	}

	float l0 = (pow(0.5+ 0.5* cos(dist* PI* 2.* smallerDistance),10.0));
	float l1 = (pow(0.5+ 0.5* cos(dist* PI* 2.* largerDistance),10.0));

	float x = fract(log(idealGridDistance)/ log(10.));
	l0 = mix(l0,0.,smoothstep(0.5,1.0,x));
	l1 = mix(0.,l1,smoothstep(0.0,0.5,x));

	col.rgb *= 0.1+ 0.9* (1.- l0)* (1.- l1);
	return col;
}

// Function 788
float getDistanceAtt ( vec3 unormalizedLightVector , float invSqrAttRadius )
{
	float sqrDist = dot ( unormalizedLightVector , unormalizedLightVector );
	float attenuation = 1.0 / (max ( sqrDist , epsilon*epsilon) );
	attenuation *= smoothDistanceAtt ( sqrDist , invSqrAttRadius );
	return attenuation ;
}

// Function 789
float vertEdgeDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {
 
    // Get difference on integer hex grid
    vec3 cell_diff = prev_cell - hit_cell;
    
    // Normal direction across cell boundary
    vec2 n = CART_FROM_HEX(cell_diff.xy);
    
    // Perpendicular vector, scaled to correct length to check corners
    vec2 np = vec2(-n.y, n.x) * 0.5 / hex_factor;
        
    // Coordinates of cell center
    vec3 cell_pos = prev_cell * cell_size;
    
    // We only care about difference from center when measuring distances
    p -= cell_pos;
    
    // These are "rotation" matrices that rotate directions on the
    // integer hex grid.  
    const mat2 M0 = mat2(0.5, 0.75, -1.0, 0.5);
    const mat2 M1 = mat2(0.5, -0.75, 1.0, 0.5);
    
    // Get directions to left and right neighbors, along with sign
    // for perpendicular to normal
    vec3 h[2];
    h[0] = vec3(M0 * cell_diff.xy, 1.0);
    h[1] = vec3(M1 * cell_diff.xy, -1.0);
    
    // Initialize distance to large value
    float rval = 1e5;
    
    // For each neighbor direction
    for (int i=0; i<2; ++i) {
        
        // Check below and above on grid
        for (float d=-1.0; d<=1.0; d+=2.0) {
            
            // Get the neighbor cell
            vec3 neighbor_cell = hit_cell + vec3(h[i].xy, d);
            vec3 neighbor_pos = neighbor_cell * cell_size;
            
            // If it's occupied
            if (map(neighbor_pos/resolution) < 0.0) {
                
                // Get corner with this neighbor                  
                vec3 corner = 0.5*(vec3(np*h[i].z, cell_height*d) - cell_diff*cell_size);
                
                // Check distance to corner
                rval = min(rval, length(p - corner));
                
            }
        }
    }
    
    return rval;

}

// Function 790
SDFResult roundboxSDF( RoundBox box, vec3 p )
{
    p -= box.pos;
    vec3 d = abs(p) - box.dimensions;
    SDFResult res;
    res.dist = length(max(d,0.0)) - box.radius + min(max(d.x,max(d.y,d.z)),0.0);
    res.matindex = box.matindex;
    return res;
}

// Function 791
vec3 calcNormalmapBeach( in vec3 pos, in float ep )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*mapBeach(pos+e.xyy*ep) + 
					 e.yyx*mapBeach(pos+e.yyx*ep) + 
					 e.yxy*mapBeach(pos+e.yxy*ep) + 
					 e.xxx*mapBeach(pos+e.xxx*ep) );
}

// Function 792
float map(vec3 p) {
    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));
    
    float rot_x = iTime * 3.1415 * 0.2;
    float cx = cos(rot_x);
    float sx = sin(rot_x);
    
    float rot_z = iTime * 3.1415 * 0.125;
    float cz = cos(rot_z);
    float sz = sin(rot_z);
    
    p = vec3(
        p.x,
        p.y * cx - p.z * sx,
        p.z * cx + p.y * sx
    );
    
    p = vec3(
        p.x * cz - p.y * sz,
        p.y * cz + p.x * sz,
        p.z
    );
    
    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));
    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));
 
    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));
    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));
    
    return d;
}

// Function 793
TraceSubsceneResult traceMinecraftSubscene(Minecraft mine, vec3 orig, vec3 dir)
{
    TraceSubsceneResult res;
    
    TraceResult tMineCube = traceCube(mine.subscene, orig, dir);
    res.globalTrace = tMineCube;
    if (tMineCube.hit) {
        vec3 minePos = toMinePos(mine, tMineCube, orig, dir);
        res.subTrace = traceMinecraftGrass(mine, minePos, dir);
        res.sumDist = tMineCube.dist + res.subTrace.dist / 
                (mine.size / mine.subscene.size);
        
        res.subTrace.hit = res.subTrace.hit && isMinecraftNoise(mine, res, orig, dir);
    }
    
    res.hit = res.globalTrace.hit && res.subTrace.hit;
    
    return res;
}

// Function 794
vec3 ToneMapFilmicALU(vec3 color){
    color = max(vec3(0.),color-0.004);
    color = (color*(6.2*color+0.5))/(color*(6.2*color+1.7)+0.06);
    return color;
}

// Function 795
float sdf_T(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));
    return t;
}

// Function 796
vec2 map(vec2 value, vec2 min1, vec2 max1, vec2 min2, vec2 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// Function 797
vec4 scene(vec2 u,vec2 m
){float dist=1e9;
 ;vec3 color=vec3(0)
 ;AddObj(dist,color,boxSDF(u-vec2(-3,1),vec2(1,1)),vec3(.6,.8,1.))
 ;AddObj(dist,color,length(u-vec2(3,1))- 1.,vec3(1,.9,.8))
 ;AddObj(dist,color,length(u-vec2(.3*sin(iTime),-2))- 0.5,vec3(0,.1,0))
 ;AddObj(dist,color,boxSDF(u-m,vec2(1.5,0.1)),vec3(.3,.1,.1))
 ;return vec4(color,dist);}

// Function 798
float rhombusSdf(vec3 p, float la, float lb) {
    p = abs(p);
    vec2 b = vec2(la, lb);
    float f = clamp((ndot(b, b - 2.0 * p.xy)) / dot(b, b), -1.0, 1.0);
	vec2 q = vec2(length(p.xy - 0.5 * b * vec2(1.0 - f, 1.0 + f)) * sign(p.x * b.y + p.y * b.x - b.x * b.y), p.z);
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));
}

// Function 799
float sceneMap3D(vec3 pos, vec3 lightPos)
{
    // platform box
    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));
    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));

    // body cone
    float b1 = sdCone(rotateX(rotateY(pos + coneBody, -0.5),0.3), vec2(sin(145.), cos(145.)), 6.);
    // party hat
    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);
    // head
    float b3 = sdSphere(pos + headSphere, 1.5);
    float b4 = sdSphere(pos + scarfSphere, 1.6);
    
    // legs
    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));
    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));
    
    //mountains
    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));
    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));
	float m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));
    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));
    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));
	float n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));   
    
    // floor
    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));
     
    // moon
    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);
    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);
    float s3 = opSubtraction(s2, s1);
    
    //lilypads
    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime), 0.), 2.3, 0.1);
    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1);
    
    //stairs
    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));
    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));
    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));
    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));
    
    float min = min(s3, min(t2, min(b1, min(b0, 
                min(b2, min(b3, min(b4, min(b5, 
                min(b6, min(m1, min(m2, min(m3, 
                min(n1, min(n2, min(n3, min(b7, 
                min(l0, min(l1, min(s0, min(s4, 
                min(s5, s6)))))))))))))))))))));
    
    return min;
}

// Function 800
float map(vec3 p) {
    float b = sdPlane(p);
    float c = dGlass(p);
    return min(b, c);
}

// Function 801
vec2 map( vec3 p, bool autoMode, float choice )
{	
	vec2 closest = vec2( 0.0 );
	if ( autoMode )
    {
        choice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;
    }

	//========================================================
	if ( choice < 1.0 )	// DIAMOND CUT CUBE
	{
		p.yz = rot( p.yz, iTime * 0.23 );
		p.xz = rot( p.xz, iTime * 0.19 );
		p.xy = rot( p.xy, iTime * 0.17 );
	
		pMirror( p.x, 3.0 );
		pMirror( p.y, 3.0 );
		pMirror( p.z, 3.0 );
		
		pMirror( p.x, 3.0 );
		pMirror( p.y, 3.0 );
		pMirror( p.z, 3.0 );
		
		pMirror( p.x, 3.0 );
		pMirror( p.y, 3.0 );
		pMirror( p.z, 3.0 );
		
		pMirror( p.x, 3.0 );
		pMirror( p.y, 3.0 );
		pMirror( p.z, 3.0 );
		
		pMirror( p.x, 3.0 );
		pMirror( p.y, 3.0 );
		pMirror( p.z, 3.0 );
		
		p = sim( p, 48.0 );
	
		float objID = 1.0;
		vec2 obj1 = vec2( diamondCutoutCube( p, 3.0 ), objID );
	
		closest = obj1;	
	
	} // end else if ( choice < 1.0 )
	//========================================================	
	else if ( choice < 2.0 )	// BLUE BALL BLOCK
	{
		p.yz = rot( p.yz, iTime * 0.13 );
		p.xz = rot( p.xz, iTime * 0.11 );
		p.xy = rot( p.xy, iTime * 0.17 );
	
		pMirrorOctant( p.xy, vec2( 3.0 + 2.0 * cos( iTime * 0.07 ) ) );
		pMirror( p.x, 5.0 );
		pMirror( p.z, 5.0 );
		pMirrorOctant( p.yz, vec2( 6.0 + 5.5 * sin( iTime * 0.13 ) ) );
			
		p.yz = rotsim( p.yz, 6.0 );
		p.z -= 6.0 + 5.5 * sin( iTime * 0.11);
		
		pMirrorOctant( p.xz, vec2( 4.0 ) );
		
		p = sim( p, 55.0 );	
	
		p.x -= 2.0;
		
		float objID = 2.0;
		vec2 obj1 = vec2( diamondCutoutCube( p, 3.0 ), objID );
	
		objID = 3.0;
		vec2 obj2 = vec2( sdSphere( p, 1.5 ), objID );
		
		closest = obj1.s < obj2.s ? obj1 : obj2;
				
	} // end else if ( choice < 2.0 )
	//========================================================	
	else if ( choice < 3.0 )	// METALMORPHIC_1
	{
		p.yz = rot( p.yz, iTime * 0.07 );
		p.xz = rot( p.xz, iTime * 0.11 );
		p.xy = rot( p.xy, iTime * 0.13 );
	
		pMirrorOctant( p.xy, vec2( 3.0 ) );
		pMirrorOctant( p.xz, vec2( 3.0 ) );
		
		p.xy = rotsim( p.xy, 2.0 );
		p.y -= 1.1;
		
		p.xz = rotsim( p.xz, 2.0 );
		p.z -= 1.1;
		
		p.yz = rotsim( p.yz, 2.0 );
		p.z -= 1.1;
	
		pMirrorOctant( p.xy, vec2( 0.25 ) );
		pMirrorOctant( p.yz, vec2( 0.25 ) );
		pMirrorOctant( p.xz, vec2( 0.25 ) );
		
		p.xz = rot( p.xz, iTime * 0.29 );
		p.yz = rot( p.yz, iTime * 0.31 );
		p.xy = rot( p.xy, iTime * 0.23 );
	
		p -= 0.35;
		
		float objID = 4.0;
		vec2 obj1 = vec2( octahedron( p, 1.0 ), objID );
	
		objID = 5.0;
		vec2 obj2 = vec2( sdSphere( p, 0.625 ), objID );
		
		closest = obj1.s < obj2.s ? obj1 : obj2;
		
	} // end else if ( choice < 3.0 )
	//========================================================	
	else if ( choice < 4.0 )	// METALMORPHIC_2
	{
		p.yz = rot( p.yz, iTime * 0.01 );
		p.xz = rot( p.xz, iTime * 0.03 );
		p.xy = rot( p.xy, iTime * 0.02 );

		p.xz = rotsim( p.xz, 3.0 );
		p.z -= 1.8;
		
		p.yz = rotsim( p.yz, 6.0 );
		p.z -= 3.6;
	
		pMirrorOctant( p.xz, vec2( 1.0 ) );
		p.x -= 2.5;
		pMirror( p.x, 1.0 );
		p.z -= 2.5;
		pMirror( p.z, 1.0 );
		p.xy -= 0.5;
	
		pMirrorOctant( p.yz, vec2( 0.5 ) );
		p.x -= 2.0;
		pMirrorOctant( p.xy, vec2( 1.0 ) );
		p.y += 1.5;
		pMirrorOctant( p.xz, vec2( 0.25 ) );
		p.y -= 1.25;
	
		// Rotation of the outer octahedron
		p.xz = rot( p.xz, iTime * 0.13 );
		p.yz = rot( p.yz, iTime * 0.19 );
		p.xy = rot( p.xy, iTime * 0.17 );		
		float objID = 6.0,
		      scale = 2.75 - 2.0 * sin( iTime * 0.1 ),
		      d1 = octahedron( p, 1.0 * scale ),
		      d2 = sdSphere( p, 0.675 * scale );			
		vec2 obj1 = vec2( max( d1, -d2 ), objID );
        
		objID = 7.0;
		// Rotation of the inner octahedron
		p.xz = rot( p.xz, iTime * 0.29 ); //67
		p.yz = rot( p.yz, iTime * 0.31 ); //59
		p.xy = rot( p.xy, iTime * 0.23 ); //61
	
		float d3 = octahedron( p, 0.65 * scale ),
		      d4 = sdBox( p, vec3( 0.325 * scale ) );
		vec2 obj2 = vec2( max( d3, -d4 ), objID );
        
        closest = obj1.s < obj2.s ? obj1 : obj2;
	        
	} // end else if ( choice < 4.0 )
	//========================================================	
	else if ( choice < 5.0 )	// METALMORPHIC_3
	{
		p.yz = rot( p.yz, iTime * 0.05 );
		p.xz = rot( p.xz, iTime * 0.07 );
		p.xy = rot( p.xy, iTime * 0.03 );
	
		pMirrorOctant( p.xy, vec2( 3.0 ) );
		pMirrorOctant( p.xz, vec2( 3.0 ) );
		
		p.xy = rotsim( p.xy, 2.0 );
		p.y -= 1.1;
		
		p.xz = rotsim( p.xz, 2.0 );
		p.z -= 1.1;
		
		p.yz = rotsim( p.yz, 2.0 );
		p.z -= 1.1;
	
		pMirrorOctant( p.xy, vec2( 0.25 ) );
		pMirrorOctant( p.yz, vec2( 0.25 ) );
		pMirrorOctant( p.xz, vec2( 0.25 ) );
		
		// Rotation of the outer octahedron
		p.xz = rot( p.xz, iTime * 0.13 );
		p.yz = rot( p.yz, iTime * 0.19 );
		p.xy = rot( p.xy, iTime * 0.17 );
		
		float objID = 8.0,
		      scale = 2.75 - 2.0 * sin( iTime * 0.1 ),
		      d1 = octahedron( p, 1.0 * scale ),
		      d2 = sdSphere( p, 0.675 * scale );
		      		
		vec2 obj1 = vec2( max( d1, -d2 ), objID );
	
		objID = 9.0;
		// Rotation of the inner octahedron
		p.xz = rot( p.xz, iTime * 0.29 ); //67
		p.yz = rot( p.yz, iTime * 0.31 ); //59
		p.xy = rot( p.xy, iTime * 0.23 ); //61
	
		float d3 = octahedron( p, 0.65 * scale ),
		      d4 = sdBox( p, vec3( 0.325 * scale ) );
		vec2 obj2 = vec2( max( d3, -d4 ), objID );
		
		closest = obj1.s < obj2.s ? obj1 : obj2;	        
		
	} // end else if ( choice < 5.0 )
	//========================================================	
	else if ( choice < 6.0 )	// METALMORPHIC_4
	{
		p.yz = rot( p.yz, iTime * 0.11 );
		p.xz = rot( p.xz, iTime * 0.17 );
		p.xy = rot( p.xy, iTime * 0.13 );

		p.x -= 1.5 * sin( iTime * 0.23 );
		pReflect( p, vec3( 1.0, 0.0, 0.0 ), 1.5 );
		p.y -= 1.5 * sin( iTime * 0.19 );
		pReflect( p, vec3( 0.0, 1.0, 0.0 ), 1.5 );
		p.z -= 1.5 * sin( iTime * 0.13 );
		pReflect( p, vec3( 0.0, 0.0, 1.0 ), 1.5 );
		
		pMirror( p.x, 1.25 * sin( iTime * 0.07 ) );
		pMirror( p.y, 1.25 * sin( iTime * 0.11 ) );
		pMirror( p.z, 1.25 * sin( iTime * 0.17 ) );
	
		p.x -= 0.01;
		pReflect( p, vec3( 1.0, 0.0, 0.0 ), 1.5 );
		p.y -= 0.01;
		pReflect( p, vec3( 0.0, 1.0, 0.0 ), 1.5 );
		p.z -= 0.01;
		pReflect( p, vec3( 0.0, 0.0, 1.0 ), 1.5 );
		
		pMirror( p.x, 1.25 * abs( sin( iTime * -0.07 ) ) );
		pMirror( p.y, 1.25 * abs( sin( iTime * -0.11 ) ) );
		pMirror( p.z, 1.25 * abs( sin( iTime * -0.17 ) ) );
	
		p.xz = rotsim( p.xz, 3.0 );
		p.z -= sin( iTime * 0.31 );
		p.xy = rotsim( p.xy, 4.0 );
		p.y -= abs( sin( iTime * 0.47 ) );
		p.yz = rotsim( p.yz, 3.0 );
		p.z -= 1.0;
				
		p.xy = rot( p.xy, iTime * -0.31);
		p.yz = rot( p.yz, iTime * -0.37);
		p.xz = rot( p.xz, iTime * -0.29);
		float objID = 10.0,
		      d1 = octahedron( p, 1.0 ),
		      d2 = sdBox( p, vec3( 2.0, 0.25, 0.25 ) ),
		      d3 = sdBox( p, vec3( 0.25, 2.0, 0.25 ) ),
		      d4 = sdBox( p, vec3( 0.25, 0.25, 2.0 ) );
		vec2 obj1 = vec2( max( max( max( d1, -d2 ), -d3 ), -d4 ), objID );
		
		objID = 11.0;
		vec2 obj2 = vec2( sdSphere( p - vec3( 1.0 * sin( iTime ), 
		                                      0.0, 0.0 ), 0.225 ), objID );	
		objID = 12.0;
		vec2 obj3 = vec2( sdSphere( p - vec3( 0.0, 1.0 * sin( iTime + 
		                             PI * 0.33 ), 0.0 ),  0.225 ), objID );			                                                          
		objID = 13.0;
		vec2 obj4 = vec2( sdSphere( p - vec3( 0.0, 0.0, 1.0 * 
		               sin( iTime + PI * 0.66 ) ),  0.225 ), objID );
		                                                          
		closest = obj1.s < obj2.s ? obj1 : obj2;
		closest = closest.s < obj3.s ? closest : obj3;
		closest = closest.s < obj4.s ? closest : obj4;

	} // end else if ( choice < 6.0 )
	//========================================================	
		
	return closest;	
}

// Function 802
float3 TonemapWithWeight(float3 c, float w) { return c*w; }

// Function 803
float neighborDist(vec3 prev_cell, vec3 hit_cell, vec3 p) {
            
    // Get cell center position
    vec3 cell_pos = prev_cell * cell_size;
    
    // Only care about distances relative to center
    p -= cell_pos;
    
    // Cancel out some multiplication that will happen down below
    p.z *= 2.0/cell_height;
    
    // Set up four neighbors and distances to walls
    vec4 h[4];
    
    h[0] = vec4(0.0,  1.0, 0.0, 1.0);
    h[1] = vec4(1.0,  0.5, 0.0, 1.0);
    h[2] = vec4(1.0, -0.5, 0.0, 1.0);
    h[3] = vec4(0.0,  0.0, 0.5, 0.5*cell_height);
    
    // Initialize return value to large number
    float rval = 1e5;
   
    // For each neighbor direction...
    for (int i=0; i<4; ++i) {
        
        // ...and its opposite direction
        for (float s=-1.0; s<=1.0; s+=2.0) {
            
            // Get the neighbor integer grid coords
            vec3 neighbor_cell = prev_cell + 2.0*s*h[i].xyz;
            
            // Ignore the one we already know is occupied
            if (neighbor_cell != hit_cell) {
                
                // Get neighbor center position
                vec3 neighbor_pos = neighbor_cell * cell_size;
                
                // If occupied...
                if (map(neighbor_pos/resolution) < 0.0) {
                
                    // Get normal
                    vec3 n = s * h[i].xyz * cell_size;
                    
                    // Update using distance to neighbor along normal
                    rval = min(rval, h[i].w - dot(n, p));
                
                }   
            }
        }
    }
    
    // Return minimum distance
    return rval;
    
}

// Function 804
float SDF(vec3 pos)
{
    float dist = 10000.0;
    
    pos += vec3(sin((pos.z+ iTime) * 8.0) * 0.025,
                sin((pos.x+ iTime) * 8.0) * 0.025,
                sin((pos.y + iTime) * 8.0) * 0.025);
    
    
    for (float i = 0.0; i < 8.0; i++)
    {
        vec3 center = vec3(sin(iTime * (0.5 + mod(i * 3.12, 1.3)) + 12.0) * 1.2,
                        sin(iTime * (0.5 + mod(i * 6.45, 1.45))  + 56.12),
                        sin(iTime * (0.5 + mod(i * 32.1, 0.8))  + 456.4) + 1.0);
        
       dist = smin(dist, sdSphere(pos, center, 0.7), 0.3);
    }
 
	return dist;
}

// Function 805
vec3 sample_map(float x, float w) {
    float q0 = map(x - w);
    float q1 = map(x);
    float q2 = map(x + w);
    return vec3((q0+q1)*0.5,q1,(q1+q2)*0.5);
}

// Function 806
float distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, bool scene) {
	
    float depth = start;
    
    float dist;
    
    for (int i = 0; i < MAX_STEPS; i++){
    
        if(scene){
            dist = getSDF(cameraPos + depth * rayDir);
        }else{
            dist = getLightSDF(cameraPos + depth * rayDir);
        }
        
        if (dist < EPSILON){ return depth; }
        
        depth += dist;
        
        if (depth >= end){ return end; }
    }
    
    return depth;
}

// Function 807
float MapEsmPod(vec3 p)
{
  float dist = fCylinder( p, 0.15, 1.0);   
  checkPos =  p- vec3(0, 0, -1.0);
  pModInterval1(checkPos.z, 2.0, .0, 1.0);
  return min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));
}

// Function 808
float signDistanceSphere(vec3 pos, vec3 sphereCenter, float s_r)
{
	return length(sphereCenter - pos) - s_r; 
}

// Function 809
SceneResult SceneResult_Subtract( SceneResult a, SceneResult b )
{
    b.fDist = -b.fDist;
    if ( a.fDist < b.fDist )
    {
        return b;
    }
    
    return a;
}

// Function 810
float capSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight, in float iTiltingAngle) {
    
    // We first apply the inverse of the slight tilting rotation we want to the point
    
    float c = cos(0.3*iTiltingAngle);
    float s = sin(0.5*iTiltingAngle);
    
    mat3 tiltingMatrix = transpose(mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0)));   

    vec3 tiltedPoint = tiltingMatrix*iPoint;
    
    // A cap is a smooth union between a rounded cone and a flattened half sphere
    
    float coneSdf = roundedConeSDF(tiltedPoint - vec3(iPosition.x, iStemHeight, iPosition.y), 0.2*iRadius, 0.4*iRadius, 2.0*iStemHeight);
    
    float sphereSdf = length(tiltedPoint - vec3(iPosition.x, 0.01*iStemHeight, iPosition.y)) - iRadius;

    float d = smoothUnion(coneSdf, sphereSdf, 2.0);
    
    // We apply a small displacement on the surface of the cap
    
    vec2 normalizedPoint = normalize(tiltedPoint.xz - iPosition);
    float cosTheta = normalizedPoint.x;
    float sinTheta = normalizedPoint.y;
    float theta = acos(cosTheta)*sign(sinTheta);
  
    d -= max(0.0, 0.38*abs(cos(8.0*theta) - 0.5) - 0.5);
    d = max(d, iStemHeight - tiltedPoint.y);
    
    return d;
    
}

// Function 811
float barrel_distort_rate( float ec2, float a ) { return ( a + 1. + a * ec2 ) / square( a + 1. - a * ec2 ); }

// Function 812
HitInfo intersectScene(Ray r, Sphere s[SN], float tmin, float tmax)
{
    HitInfo info;
    info.dist = -tmax;
    int idx = 0;
    for(int i=0;i<SN;++i)
    {
        float t = intersect(r, s[i]);
        if(t>tmin && t<abs(info.dist))
        {
            info.dist = t;
            idx = i;
        }
    }
    float t = info.dist;
    info = computeInfo(r.o+r.d*t, s[idx]);
    info.index = idx;
    info.dist = t;    
    return info;
}

// Function 813
float TorusSDF(vec3 samplePoint, vec2 dimensions)
{
	return length( vec2(length(samplePoint.xz)-dimensions.x,samplePoint.y) )-dimensions.y;
}

// Function 814
float fixDistance(float d, float k) {
    float sn = sign(d);
    d = abs(d);
    d = d / k * 1.82;
    d += 1.;
    d = pow(d, .5);
    d -= 1.;
    d *= 5./3.;
    d *= sn;
    return d;
}

// Function 815
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )
{
    vec3 color = vec3(0); 
    
	#define SSAMPLES 1
	for (int i = 0; i < SSAMPLES; i++) {
		color += rm(ro, rd, iTime+float(i)); 
	}
	color /= float(SSAMPLES);
	    
    // Output to cubemap
    color = mix(color, texture(iChannel0, rd).xyz, 0.99); 
    fragColor = vec4(color,1.0);
}

// Function 816
float distScene(in vec3 pos, out int object, out float colorVariation){
    
    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;
    pos.xz = rot(0.25 * iTime) * pos.xz;
    pos.y += 0.2;
    
    float f = noise(100. * pos);
    float sf = smoothstep(0.4, 0.5, f);
    
    //floor
    float dist = pos.y;
    object = 0;
    colorVariation = 0.;
    
    //pot
    vec3 p = pos;
    p.y -= 0.155;
    float distPot = length(p) - 0.2;
    distPot = smoothmax(distPot, p.y - 0.097, 0.01);
    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);
    distPot = max(distPot, -(p.y + 0.15));
    dist = min(dist, distPot);
    
    if(dist == distPot){
        object = 1;
        float angle = atan(p.z, p.x);
        colorVariation = 0.9 * smoothstep(0.2, 0.35, 0.5 * sin(3. * sin(20. * angle)) + 0.4 * (f - 0.5)) + 0.1 * sf;
    }
    
    //ground
    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);
    dist = min(dist, distGround);
    
    if(dist == distGround){
        object = 2;
        colorVariation = 0.;
    }
    
	//plant
    p = pos;
    p.y -= 0.2;
    float distPlant = 100.;
    float anim = 0.05 * (0.5 + 0.5 * sin(5. * iTime));
    float leafAngle = 1.2;
    float offset = 0.01;
    float size = 0.2;
    float leafRot = 2. * PI / PHI;
    float leafColor, lc, d;
    
    for(float i = 0.; i < NB_LEAVES; i++){
        p.xz = rot(leafRot) * p.xz;
        leafAngle *= 0.92;
        size *= 1.04;
        offset += 0.002;
        d = distLeaf(p - vec3(offset, 0., 0.), leafAngle + anim, size, lc);
        distPlant = min(distPlant, d); 
        if(d == distPlant) leafColor = lc;
    }
    dist = min(dist, distPlant);
    
    if(dist == distPlant){
        object = 3;
        colorVariation = 0.8 * smoothstep(0.75, 0., leafColor + 0.4 * f) + 0.2 * sf;
    }
               
    return dist;

}

// Function 817
bool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )
{
    float t = 1. + Hash12(fragCoord.xy)*5.;
	float oldT = 0.0;
	float delta = 0.0;
	bool fin = false;
	bool res = false;
	vec2 distances;
	for( int j=0; j< 150; j++ )
	{
		if (fin || t > 240.0) break;
		vec3 p = rO + t*rD;
		//if (t > 240.0 || p.y > 195.0) break;
		float h = Map(p); // ...Get this positions height mapping.
		// Are we inside, and close enough to fudge a hit?...
		if( h < 0.5)
		{
			fin = true;
			distances = vec2(oldT, t);
			break;
		}
		// Delta ray advance - a fudge between the height returned
		// and the distance already travelled.
		// It's a really fiddly compromise between speed and accuracy
		// Too large a step and the tops of ridges get missed.
		delta = max(0.01, 0.3*h) + (t*0.0065);
		oldT = t;
		t += delta;
	}
	if (fin) resT = BinarySubdivision(rO, rD, distances);

	return fin;
}

// Function 818
float sdfVerticalCapsule( vec3 p, float h, float r, mat4 t )
{
  p = vec3(t * vec4(p, 1));
  p.y -= clamp( p.y, 0.0, h );
  return length( p ) - r;
}

// Function 819
float Scene(vec3 p)
{
    float d = 1000.0;
    
    vec3 pm = vec3(mod(p.xy,vec2(QUAD_SIZE)),p.z);
    
    vec2 uv = floor(p.xy/QUAD_SIZE);
    
    d = sdVQuad(pm - vec3(0,0,1.0), Height(uv+vec2(0,0)),Height(uv+vec2(0,1)),Height(uv+vec2(1,1)),Height(uv+vec2(1,0)));
    
    d = opU(d, -sdSphere(p,12.0));
    
	return d;
}

// Function 820
float manhattanDistance(float p1, float p2) {
	float d1 = abs(p1 - p2);
	return d1;
}

// Function 821
vec3 colormap(float t) {
    return PAL(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));
}

// Function 822
float heightMapWater(vec3 p, float t)
{
    float h = 0.0;
    vec3 op = p;
    #ifdef FLOOD
    float w = (-p.z+sin(TIME*WAVES_SPEED))*FLOOD_AMP;
    #endif
    float a = WATER_AMP;
    float f = WATER_FREQ;
    float T = TIME(t)*WATER_SPEED;
    //h = 0.2*(-1.0+fbm_hash(p.xz+TIME)+fbm_hash(p.xz-TIME)); 
    for(int i = 0;i < 3; ++i)
    {
//     e((2ikn)/N   )
        float ffta = 1.0;//exp((-2.0*3.14*float(i)*(f*length(p)+T))/6.0);
    	h = a*(-1.0+fbm2Dsimple(f*p.xz+T)+fbm2Dsimple(f*p.xz-T))*ffta; 
        a*= 0.8;
        f *= 1.2;
    }
    //for(int i=0;i<5;++i) {
    //}
    #ifdef WAVES
    h+= wave(op,
             mix(0.05, 0.9, min(1.0, max(0.0,p.z)/3.2)),
             T*5.0)*clamp(h, 0.2, 0.6);
        //*gaussianNoise(op.xz*0.1+T);
    #endif
    #ifdef FLOOD
    return h+w;
    #else
    return h;
    #endif 
}

// Function 823
float heartSDF(vec2 st) { // 34
    st -= vec2(.5, .8);
    float r = length(st) * 5.;
    st = normalize(st);
    return r -
        ((st.y * pow(abs(st.x), 0.67)) /
        (st.y + 1.5) - 2. * st.y + 1.26);
}

// Function 824
vec2 lightMap( vec3 pos ){

    
   float dist =length( pos - lightPos ) - .3;
    
    return vec2( dist , 4. );
    
}

// Function 825
float sdf_window_flame(vec2 uv)
{
    bool left = uv.x < .5;
    float sdf = uv.y - 1.;
    uv.y -= .95;
    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, -.02), vec2(.4, 1.9), vec3(.11, 1., .0)));
    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .21)-vec2(-.13, 0.), vec2(.3, 1.2), vec3(.08, 1.2, .95)));
	sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .0)-vec2(.31, 0.), vec2(.3, 1.4), vec3(.1, 1.2, .55)));
    
    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, left ? .3 : -.3) - (left ? vec2(-.28, 0.) : vec2(.37, -.1)),
                                           vec2(.2, left ? .31 : .35), vec3(left ? -.03 : .03, 1., .5)));
    
    sdf = sdf_union(sdf, sdf_flame_segment2(uv - (left ? vec2(-.35, 1.25) : vec2(.17, 1.5)), vec2(.11, left ? .4 : .35),
                                            vec3(-.02, 1., .5)));
    sdf = sdf_union(sdf, sdf_flame_segment2(skew(uv-vec2(.35, 1.35), -.0), vec2(.11, .24), vec3(.02, 1., .5)));
    return sdf;
}

// Function 826
float mapGlass( in vec3 pos ) {
    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );
}

// Function 827
bool intersectSceneLoop(Ray R, float maxDist, inout Surfel surfel) {
    const int maxIterations = 250;
    const float closeEnough = 0.001;
    const float minStep = closeEnough;
    float closest = inf;
    float tForClosest = 0.0;
    float t = closeEnough * 2.0;
    
    for (int i = 0; i < maxIterations; ++i) {
        surfel.position = R.direction * t + R.origin;

        float dt = inf;
        scene(surfel.position, dt);
        if (dt < closest) {            
	        closest = dt;
            tForClosest = t;            
        }
        
        if (dt < closeEnough) {
            return true;
        } else {
	        t += max(dt, minStep);
            if (t > maxDist) {
                return false;
            }
        }
    }
    

    // "Screen space" optimization from Mercury for shading a reasonable
    // point in the event of failure due to iteration count
    if (closest < closeEnough * 4.0) {
        surfel.position = R.direction * tForClosest + R.origin;
        return true;
    }
    
    return false;
}

// Function 828
float mapSand(vec3 p) {
    return sdPlane(p-vec3(0.0, -0.8-p.z*0.05, 0.0))-0.2;
}

// Function 829
float mapDistance(const in vec3 point) {
  float tmpComb_408 = opUnion(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-2.41)), vec2(1.49,0.26)) * 1.0);
float tmpComb_409 = tmpComb_408;
float tmpComb_410 = opSubStairs(tmpComb_409, sdTorus(pMod((mat4(1.0101120471954346,0.28705546259880066,0.0,0.0,-0.28705546259880066,1.0101120471954346,0.0,0.0,0.0,0.0,1.0501081943511963,0.0,0.06102079153060913,-0.21472446620464325,-0.2601988911628723,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.36,0.5)) * 0.9522828440977849, vec2(0.17,1.69));
float tmpComb_411 = tmpComb_410;
float tmpComb_412 = opUnionStairs(tmpComb_411, sdEllipsoid(pMod((mat4(0.25112131237983704,-0.2825120985507965,-0.9258104562759399,0.0,0.7474100589752197,0.6643630266189575,4.644800100095381e-9,0.0,0.6150742173194885,-0.6919600367546082,0.3779881000518799,0.0,0.362551212310791,-0.4078710079193115,0.268617182970047,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.5,1.52,0.5)) * 1.0000000012999473, vec2(0.84,1.62));
float tmpComb_413 = tmpComb_412;
float tmpComb_414 = opUnionRound(tmpComb_413, sdTorus(pMod((mat4(0.5727498531341553,0.8041792511940002,-0.15891283750534058,0.0,-0.8191083073616028,0.5539072751998901,-0.14915919303894043,0.0,-0.03192776069045067,0.21559768915176392,0.9759598970413208,0.0,0.701280951499939,-0.5455323457717896,0.421924889087677,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.09,0.07)) * 0.9999999171907704, 0.14);
float tmpComb_415 = tmpComb_414;
float tmpComb_416 = opSubColumns(tmpComb_415, sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,0.9679820537567139,-0.25101903080940247,0.0,0.0,0.25101903080940247,0.9679820537567139,0.0,0.4602626860141754,-1.420561671257019,0.592455267906189,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.71,0.4,1.0)) * 1.0, vec2(0.17,7.97));
return tmpComb_416;
}

// Function 830
float MapMissile(vec3 p)
{
  float d= fCylinder( p, 0.70, 1.7);
  if (d<1.0)
  {
    missileDist = min(missileDist, fCylinder( p, 0.12, 1.2));   
    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); 

    checkPos = p;  
    pR(checkPos.xy, 0.785);
    checkPos.xy = pModPolar(checkPos.xy, 4.0);

    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));
    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));
    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));
    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));
  }
  return missileDist;
}

// Function 831
vec3 SphereMap( vec2 uv )
{
    return vec3( sin((uv.xx+vec2(0,.25))*6.283185)*2.*sqrt(uv.y*(1.-uv.y)), uv.y*2.-1. );
}

// Function 832
float map(in vec3 p)
{
    float sph0 = sphere(p - spheres[0].offsetRadius.xyz, spheres[0].offsetRadius.w);
    float sph1 = sphere(p - spheres[1].offsetRadius.xyz, spheres[1].offsetRadius.w);
    float sph2 = sphere(p - spheres[2].offsetRadius.xyz, spheres[2].offsetRadius.w);
    float sph3 = sphere(p - spheres[3].offsetRadius.xyz, spheres[3].offsetRadius.w);
    sph0 = min(sph0, min(sph1, min(sph2, sph3)));
    float bottom_plane = plane(p, vec3(0.0, 1.0, 0.0), 0.5);
    return min(sph0, bottom_plane);
}

// Function 833
float distPlane( vec3 p, vec3 n, float y )
{
	return dot(p-vec3(0,y,0),n);
}

// Function 834
float MapBoat(vec3 p)
{
  p=TranslateBoat(p);
  // AABB
  if (sdBox(p+vec3(0., 0., .50), vec3(1.7, 1.0, 4.))>1.) return 10000.;

  // hull exterior  
  float centerDist =length(p.x-0.);    
  float centerAdd = 0.07*-smoothstep(0.04, 0.1, centerDist);
  float frontDist = max(0.01, 1.3-max(0., (0.25*(0.15*pow(length(p.z-0.), 2.)))));
  float widthAdd =mix(0.06*(floor(((p.y+frontDist) + 0.15)/0.3)), 0., step(2., length(0.-p.y)));

  float d= fCylinder( p, 1.45+widthAdd, 1.3+centerAdd+widthAdd);  
  d =min(d, sdEllipsoid( p- vec3(0, 0, 1.250), vec3(1.45+widthAdd, 1.465+centerAdd, 1.+centerAdd+widthAdd))); 
  d =min(d, sdEllipsoid( p- vec3(0, 0, -1.20), vec3(1.45+widthAdd, 1.465+centerAdd, 3.+centerAdd+widthAdd))); 

  // hull cutouts
  d= max(d, -fCylinder( p- vec3(0, 0.25, -0.10), 1.3+widthAdd, 1.4));  
  d =max(d, -max(sdEllipsoid( p- vec3(0, 0.05, -.60), vec3(1.25+widthAdd, 1.2, 3.40)),-sdBox(p-vec3(0.,0.,4.), vec3(3., 10., 3.1)))); 

  // cut of the to part of the hull to make the boat open

  d=max(d, -sdBox(p-vec3(0., 1.05+centerAdd, 0.), vec3(10., frontDist, 14.)));

  // seats
  return min(d, min(sdBox(p-vec3(0., -0.5, 0.9), vec3(1.3, 0.055, 0.35)), sdBox(p-vec3(0., -0.5, 0.9-2.2), vec3(1.3, 0.055, 0.35))));
}

// Function 835
float SampleShadowMap(in vec3 point, in float shadowMapBias)
{
	const float shadowMapMaxDistance = 23.0;
    
    float shadow = 1.0;
    
    vec3 pointToLight = point - gLightPosition;
    float distanceToLight = length(pointToLight);
    
    vec2 shadowCoords = CalculateShadowMapUV(gLightViewMatrix, point, (iResolution.x / iResolution.y));
    
    if((shadowCoords.x > EPSILON && shadowCoords.y > EPSILON) && (shadowCoords.x < (1.0 - EPSILON) && shadowCoords.y < (1.0 - EPSILON)))
    {
#if POISSON_SAMPLING        
        for(int i = 0; i < 4; ++i)
        {
            const float poissonDiskSpread = 0.00125;
            float shadowMap = SampleShadowMap(shadowCoords + (SamplePoissonDisk(i) * poissonDiskSpread));
            
            float shadowMapDistance = (shadowMap * shadowMapMaxDistance);

            if(shadowMapDistance < (distanceToLight - shadowMapBias))
            {
                shadow -= 0.25;
            }   
        }
#else
        float shadowMap = SampleShadowMap(shadowCoords);
        float shadowMapDistance = (shadowMap * shadowMapMaxDistance);

        if(shadowMapDistance < (distanceToLight - shadowMapBias))
        {
            shadow = 0.0;
        }     
#endif
    }
    return shadow;
}

// Function 836
float map(vec3 pos){
    float d = min(1.,cube  (pos-vec3(0.,-0.5, 0.),vec3(3.5,0.05,3.5),0.01));
    return d;
}

// Function 837
vec2 SceneNormal(vec2 p, float h, out float d)
{
    vec2 n = vec2(
          Scene(p + vec2(h,0))
        , Scene(p + vec2(0,h))
      ) - (d = Scene(p));
    if (dot(n,n) < 1e-7) n = vec2(0,1);
    else n = normalize(n);
    return n;
}

// Function 838
vec4 MapTerrain( vec3 p)
{       
  float boatDist= 10000.;
  float bridgeDist=10000.;
  treeDist = 10000.;
  float water=0.;
  float height = GetTerrainHeight(p); 
  float tHeight=mix(height, 4., smoothstep(12., 1.98, length(p.xz-vec3(-143, 0., 292).xz))); 
  float boulderHeight = GetBoulderHeight(p.xz, height);
  float stoneHeight = GetStoneHeight(p.xz, tHeight);
  tHeight+= mix(stoneHeight, 0., step(0.1, boulderHeight));

  tHeight= mix(tHeight-.20, tHeight*1.4, smoothstep(0.0, 0.25, tHeight));

  if (tHeight>0.)
  {
    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;

    tHeight+=boulderHeight;
      
                   #ifdef TREES   
      vec3 treePos = p-vec3(0.,tHeight+2.,0.);
      vec2 mm = floor( treePos.xz/8.0 );	
	treePos.xz = mod( treePos.xz, 8.0 ) - 4.0;
      
      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);
      
      if(treeHeight>0.05)
      {
          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));
                     treeDist+=(noise(p*1.26)*.6285);
         treeDist+=(noise(p*3.26)*.395);
           treeDist+=(noise(p*6.26)*.09825);
      }
    #endif
      
    #ifdef GRASS
      tHeight+=GetFoliageHeight(p, height, stoneHeight, boulderHeight);
    #endif

  } else
  {
    water = GetWaterWave(p);
  }

    
  #ifdef BRIDGE
    bridgeDist=MapBridge(p);    
  #endif
    #ifdef BOAT
    boatDist=MapBoat(p);
  #endif
    
    return vec4(min(treeDist,min(min(boatDist, bridgeDist), p.y -  max(tHeight, -water*0.05))), boatDist, bridgeDist, height);
}

// Function 839
float getDist(vec3 samplePos)
{
	return min(distBox(samplePos, BOX_POS, BOX_DIM), 
			   distBox(samplePos, vec3(0.0, -5.0, 0.0), vec3(4.0, 4.0, 4.0)));
}

// Function 840
vec3 sceneNormal( in vec3 point ) {
    return normalize( sceneDistance( point ).x - vec3(
        sceneDistance( point - RAY_EPSILON.xyy ).x,
        sceneDistance( point - RAY_EPSILON.yxy ).x,
        sceneDistance( point - RAY_EPSILON.yyx ).x
    ));
}

// Function 841
float map(vec4 uv, mat4 q, vec4 l) {
    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));
}

// Function 842
float sdf(in vec3 pos) {");
	lines.push("	float t = 1000.0;");
	lines.push("	vec3 offset = vec3(" + (-length / 2) + ", 4, " + Math.ceil(-length * 0.65) + ");");
	var x = 0;
	for (var i = 0; i < text.length; i++) {
		if (text[i] == ' ') {
			x += 3;
		} else {
			if (text[i] in widths) {
				lines.push("	t = min(t, sdf_" + text[i] + "(pos, vec3(" + x + ", 0, 0) + offset));");
				x += widths[text[i]];
				if (i != text.length - 1) {
					x += 2;
				}
			} else {
				console.error("Bad character '" + text[i] + "' at index " + i + " in string \"" + text + "\"");
			}
		}
	}
	lines.push("	return t;");
	lines.push("}

// Function 843
traceData finalmap(vec3 point){
    
        //shape finding functions:
        dSphere = sphere(point*iSphereScale, rad);

        dCone.l = ConeD(point,0.4,0.2);

        //dTexMarch.p = texture2D(sTD2DInputs[0],fract(point.xy*0.1)).rgb;
        //dTexMarch.l=length(dTexMarch.p);

        traceData fout;
        //fout.l= pSmoothMin(dCone.l,dSphere.l,0.5);
        fout.l= dSphere.l;
        

        float least = min(dCone.l,dSphere.l);
       // return fout;
       //return pSmoothMin(dCone.l,dSphere.l,0.1);
       return fout;
}

// Function 844
float map(in vec3 p)
{
    const float r = 1.0;
    float x = r * sin(iTime);
    float z = r * cos(iTime);
    
    vec3 c = vec3(x, 1, z);
    vec3 v = vec3(z, 0,-x) * 2.;
    float d = length(p - c) - 0.5;
    float d2 = sdCapsule(p, c, c - v * 0.2, 0.5);
    if (d < -0.2 || d2 > 0.3) return min(d, d2);
   
    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;
    d = length(p - c);
    if (d < 0.5) return d - 0.5;

    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;
    d = length(p - c);
    if (d < 0.5) return d - 0.5;
    
    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;
    d = length(p - c);
    if (d < 0.5) return d - 0.5;
    
    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;
    d = length(p - c);
    return d - 0.5;
}

// Function 845
vec3 envMap(vec3 p){
    
    p *= 2.;
    p.xz += iTime*.5;
    
    float n3D2 = n3D(p*2.);
   
    // A bit of fBm.
    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;
    c = smoothstep(0.5, 1., c); // Putting in some dark space.
    
    p = vec3(c*c*c*c, c*c, c); // Bluish tinge.
    
    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.

}

// Function 846
float SQSDF(vec2 p,vec2 b){
    vec2 d=abs(p)-b;
    return min(max(d.x,d.y),0.)+length(max(d,vec2(0)));
}

// Function 847
vec3 RomBinDaHouseToneMapping(vec3 color)
{
    color = exp( -1.0 / ( 2.72*color + 0.15 ) );
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 848
float sdfCircle(vec2 p) {
    return length(p) - 1.0;
}

// Function 849
float cubeDist2( vec3 pos, float radius)
{
    return Mylength( pos ) - radius;
}

// Function 850
float map(vec3 p){
    
    // Back wall
    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;
     
    // Truchet object and animated metallic balls: This is just a
    // standard 2D animated Truchet with an extruded factor. If you're
    // not sure how it works, myself and others have plenty of 
    // animated Truchet examples on Shadertoy to refer to.
    //
    // Grid construction: Cell ID and local cell coordinates.
    const vec2 GSCALE = vec2(1./3.);
    const vec2 sc = 1./GSCALE, hsc = .5/sc;    
    vec2 iq = floor(p.xy*sc) + .5;    
    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;
    
    // Flip random cells. This effectively rotates random cells,
    // but in a cheaper way.
    float rnd = hash21(iq + .37);
    if(rnd<.5) q.y = -q.y;
      
    // Circles on opposite square vertices.
    vec2 d2 = vec2(length(q - hsc), length(q + hsc));
    // Using the above to obtain the closest arc.
    float crv = abs(min(d2.x, d2.y) - hsc.x);
    
    // Flipping the direction on alternate squares so that the animation
    // flows in the right directions -- It's a standard move that I've
    // explained in other examples.  
    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;
    // Using repeat polar coordinates to create the moving metallic balls.
    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);
    pp *= rot2(iTime*dir); // Animation occurs here.
    float a = atan(pp.y, pp.x); // Polar angle.
    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.
    // Polar coordinate.
    vec2 qr = rot2(a*6.2831853)*pp; 
    qr.x -= hsc.x;
     
    // Ridges, for testing purposes.
    //crv += clamp(cos(a*16. + dir*iTime)*2., 0., 1.)*.003;
    
    // A rounded square Truchet tube. Look up the torus formula, if you're
    // not sure about this. However, essentially, you place the rounded curve
    // bit in one vector position and the Z depth in the other, etc. Trust me,
    // it's not hard. :)
    float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .05;
    //float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .02), vec2(.05, .05), .035);
    
    
 
    // Metallic elements, which includes the joins, metal ball joints
    // and the tracks they're propogating along. This operation needs to be
    // performed prior to hollowing out the tubes. See below.
    q = abs(abs(q) - .5/sc);
    float mtl = min(q.x, q.y) - .01;
    mtl = max(max(mtl, tr - .015), -(tr - .005));
    
    // Adding in the railing.
    float rail = tr + .035 + .01;
    

    // 3D ball position.
    vec3 bq = vec3(qr,  p.z + .05/2. + .02);
    //float ball = max(length(bq.zx) - .02, abs(bq.y) - .03);
    float ball = length(bq) - .02; // Ball.
    //ball = abs(ball + .005) - .005; // Hollow out.
    
    float mtl2 = ball;//max(ball, -(rail - .0025));
    mtl = min(mtl, rail);
    
    // Hollowing out the Truchet tubing. If you don't do this, it can cause
    // refraction issues, but I wanted the tubes to be hollow anyway.
    tr = max(tr, -(tr + .01 + .01));

    // Debug: Take out the glass tubing.
    //tr += 1e5;
    
    // Storing the object ID.
    vObjID = vec4(wall, tr, mtl, mtl2);
    
    // Returning the closest object.
    return min(min(wall, tr), min(mtl, mtl2));
 
}

// Function 851
void sceneMap3D(vec3 pos, out float t, out int obj)
{
    // Initialize to back wall sdf
    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));
    obj = IDBackWall;

    float t2;
    // Check left wall
    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)
    {
        t = t2;
        obj = IDLeftWall;
    }
    // Check right wall
    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)
    {
        t = t2;
        obj = IDRightWall;
    }
    // Check top ceiling wall
    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)
    {
        t = t2;
        obj = IDCeilingWall;
    }
    // Check floor wall
    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)
    {
        t = t2;
        obj = IDFloorWall;
    }
    // Check for long cube
    if((t2 = box(rotateY(pos + vec3(-2, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5))) < t)
    {
        t = t2;
        obj = IDLongCube;
    }
    // Check of short cube
    if((t2 = box(rotateY(pos + vec3(2, 1, 0.75), 17.5 * 3.14159 / 180.0), vec3(1.5, 1.5, 1.5))) < t)
    {
        t = t2;
        obj = IDShortCube;
    }
}

// Function 852
float Tonemap_ACES(float x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// Function 853
vec2 sdFbm( in vec3 p, float d )
{
    const mat3 m = mat3( 0.00,  0.80,  0.60, 
                        -0.80,  0.36, -0.48,
                        -0.60, -0.48,  0.64 );
    float t = 0.0;
	float s = 1.0;
    for( int i=0; i<7; i++ )
    {
        float n = s*sdBase(p);
    	d = smax( d, -n, 0.2*s );
        t += d;
        p = 2.0*m*p;
        s = 0.5*s;
    }
    
    return vec2(d,t);
}

// Function 854
vec3 color_dist_mix(vec3 bg, vec3 fg, float dist, float alpha) {
    float d = smoothstep(0.0, 0.75, dist); 
    return mix(bg, fg, alpha*(1.0-d));
}

// Function 855
float GetDistanceGear( const in vec3 vPos )
{
	float fOuterCylinder = length(vPos.xz) - 1.05;
	if(fOuterCylinder > 0.5)
	{
		return fOuterCylinder;
	}
	
	vec3 vToothDomain = DomainRotateSymmetry(vPos, 16.0);
	vToothDomain.xz = abs(vToothDomain.xz);
	float fGearDist = dot(vToothDomain.xz,normalize(vec2(1.0, 0.55))) - 0.55;
	float fSlabDist = abs(vPos.y + 0.1) - 0.15;
	
	vec3 vHoleDomain = abs(vPos);
	vHoleDomain -= 0.4;
	float fHoleDist = length(vHoleDomain.xz) - 0.3;
    
    fHoleDist = max( fHoleDist, length(vPos.xz) - 0.65);
	
	float fBarDist =vToothDomain.z - 0.15;
	fBarDist = max(vPos.y - 0.1, fBarDist);
	
	float fResult = fGearDist;
	fResult = max(fResult, fSlabDist);
	fResult = max(fResult, fOuterCylinder);
	fResult = max(fResult, -fHoleDist);
    
    fResult = max(fResult, vToothDomain.y + vToothDomain.z * 0.25 - 0.25);    
    fResult = max(fResult, -max( length(vPos.xz) - 0.75, -vPos.y - 0.01 ) );
    
	fResult = min(fResult, fBarDist);
	return fResult;
}

// Function 856
vec3 Tonemap(in vec3 p){
    return (p*(2.5*p+0.1))/(p*(2.4*p+0.6)+0.2);
}

// Function 857
float map_table(vec3 pos, bool btext)
{
    #ifdef show_table
    pos = rotateVec2(pos);
    #ifdef show_plate
    pos.y+= 1.129 + plateThickness*2.;
    #else
    pos.y+= 1.115;
    #endif
    
    float df = sdCylinder(pos, vec2(5., 0.2));
    return df;
    #else
    return 10.;
    #endif
}

// Function 858
vec3 firstTorusKnotLineSqDistanceMinimumInside(Ray ray, TorusKnotParameters tkp)
{
    int sections = 3*int(max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 0.008/(max(tkp.kq,tkp.kp)-0.75);
    const int maxIterations = 100;//50
    
    float minDist;
    float bestT;
    bool found = false;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        bool failed = false;
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotLineSqDistanceDerivative(t, ray, tkp);
            
            if(abs(dt) < 0.1)break;
            
            t -= lerningRate*dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                failed = true;
                break;
            }
        }
        if(failed)continue;
        
        float lineSqDist = torusKnotLineSqDistance(t, ray, tkp);
        
        if(lineSqDist <= sq(tkp.r3))
        {
            float distAlongD = dot(torusKnot(t, tkp) - ray.ro, ray.rd);

            if(!found || distAlongD < minDist)
            {
                minDist = distAlongD;
                bestT = t;
            }
            
            found = true;
        }
    }
    
    return vec3(bestT, minDist, found ? 1. : 0.);
}

// Function 859
SceneResult Scene_SmoothSubtract( SceneResult a, SceneResult b, float k )
{    
    float fA = a.fDist;
    float fB = -b.fDist;        
    
    float fC = -smin( -fA, -fB, k );
    
    a.fDist = fC;
    b.fDist = fC;
    
    if ( fA < (fB + k) )
    {        
        return b;
    }
    
    return a;
}

// Function 860
float dist_field(vec3 pos) {
    float ret = length(pos) - r;
    return ret;
}

// Function 861
float computeDistance(vec2 uv, vec2 dir, float theshold, int step, int size)
{
    float d = 0.;
    for (int i = 1; i < size; i+=step)
    {
		float val = grayscale(texture(iChannel0, vec2(uv) + float(i) * dir).rgb);
        if(val <= theshold) 
            break;
        
        d += 1.0;
    }
    return d * float(step);
}

// Function 862
float map( vec3 p )
{

    return 0.5 - length( p ) * fbm( p + TWA );

}

// Function 863
float dist(vec3 p)
{
    return min(sphereSlime(p), bgSphereSlimes(p));
}

// Function 864
float mapTerrain(vec3 p, float s) {
    float hm = heightMap(p, s);
    return sdPlane(p-vec3(0.0, -0.25-p.z*0.05, 0.0))+hm;
}

// Function 865
vec2 Scene(vec3 p)
{
    vec2 d = vec2(MAX_DIST, SKYDOME);
    
    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);
    
    d = opS(dfRiver(p, RIVER), d);
    
	return d;
}

// Function 866
SDFResult planeSDF( Plane plane, vec3 p )
{
    return SDFResult(dot(plane.norm, p) - dot(plane.pos, plane.norm), plane.matindex);
}

// Function 867
float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}

// Function 868
float distLine(vec2 p, vec2 A, vec2 B){
    vec2 AB = B-A;
  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);
  vec2 P3 = A + (B-A)*t;
  return length(P3-p);
}

// Function 869
vec2 Scene(vec3 p)
{
    vec2 d = vec2(MAX_DIST, SKYDOME);
    
    d = opU(sdPlane(p, normalize(vec4(heightmapNormal(p.xy),-1, 0)), FLOOR), d);
    
	return d;
}

// Function 870
vec3 Uncharted2ToneMapping(vec3 color) {
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 2.;
	color *= exposure;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
	return color;
}

// Function 871
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){
   
    const vec2 e = vec2(EPS, 0);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
    
}

// Function 872
vec3 uv_unmap(vec2 uv, vec4 plane, int axis)
{
    switch (axis)
    {
        case 0: return vec3(-(plane.w + dot(plane.yz, uv)) / plane.x, uv.x, uv.y);
        case 1: return vec3(uv.x, -(plane.w + dot(plane.xz, uv)) / plane.y, uv.y);
        case 2: return vec3(uv.x, uv.y, -(plane.w + dot(plane.xy, uv)) / plane.z);
        default:
        	return vec3(0);
    }
}

// Function 873
void mainCubemap( out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    //if ( iFrame > 1 ) discard;
    
	// i was planning to do a complicated volumetric cloud thing here but fake ones look fine.

    // Ray direction as color
    vec3 col;/* = mix( vec3(.5,.7,1), vec3(2), smoothstep(.3, 1., cloudSDF(rayDir*vec3(15,30,15)) ) );
    col = mix( col, vec3(.2,.1,0), smoothstep(.3, 1., cloudSDF(rayDir*vec3(15,33,15)) ) );
    
    col = mix( col, vec3(.3,.35,.4), smoothstep( .0, -.02, rayDir.y ) );*/

	col = GetFogColour(rayDir);
	col = mix( col, vec3(100,8,.8), smoothstep(.99994,.99997,dot(rayDir,sunDir)) );//pow(max(0.,dot(rayDir,sunDir)),20000.) );
    
    // Output to cubemap
    fragColour = vec4(col,1.0);
}

// Function 874
bool distanceEstimator(Sphere s, Point3 X, inout float distance, inout Material material) {
    float t = length(X - s.center) - s.radius;
    bool closer = (t < distance);
       
    distance = closer ? t : distance;
    
    if (closer) {
	    material = s.material;
    }
    return closer;
}

// Function 875
float polDist(vec2 p){

    return length(p);
    
    /*
    // Square cross section.
    p = abs(p);
    return max(p.x, p.y);
	*/
    
    /*
    // Hexagonal cross section.
    //p = abs(p);
    //return max(p.x*.8660254 + p.y*.5, p.y);
	*/

    /*
    // Octagonal cross section.
    p = abs(p);
    return max(max(p.x, p.y), (p.x + p.y)*.7071);
    */
    
    /*
    // Dodecahedral cross section.
    p = abs(p);
    vec2 p2 = p.xy*.8660254 + p.yx*.5;
    return max(max(p2.x, p2.y), max(p.y, p.x));
    */
}

// Function 876
float sdf_sphere(vec3 pXp0, float radius)
{
 	return length((pXp0)) - radius;   
}

// Function 877
float crossSDF(vec2 st, float s) { // 11
    vec2 size = vec2(0.25, s);
    return min(rectSDF(st, size.xy), rectSDF(st, size.yx));
}

// Function 878
vec3 colormapBWR(float k, float krange) {
    // color k < 0 blue
    vec3 c0 = vec3(0.0, 66.0, 157.0) / 255.0;
    // color k == 0 white
    vec3 c1 = vec3(255.0, 255.0, 224.0) / 255.0;
    // color k > 0 red
    vec3 c2 = vec3(147.0, 0.0, 58.0) / 255.0;
    vec3 col;
    // range in which to show the curvature values inbetween
    float b = abs(0.);
    if (k < 0.0) {
      col = mix(c0, c1, smoothstep(-krange, -b, k));
    } else {
      col = mix(c1, c2, smoothstep(b, krange, k));}
    return col;
}

// Function 879
vec3 InvTonemap(const TonemapParams tc, vec3 y)
{
	vec3 inv_toe = - tc.mToe.x / (y - tc.mToe.z) - tc.mToe.y;
	vec3 inv_mid = (y - tc.mMid.y) / tc.mMid.x;
	vec3 inv_shoulder = - tc.mShoulder.x / (y - tc.mShoulder.z) - tc.mShoulder.y;

	vec3 result = mix(inv_toe, inv_mid, step(tc.mBy.x, y));
	result = mix(result, inv_shoulder, step(tc.mBy.y, y));
	return result;
}

// Function 880
vec2 map(in vec3 p) {
	R(p.xz, iMouse.x*.008*pi+iTime*.3);
    return dfGalaxy(p, clamp(10.*sliderVal.x,.9,10.), sliderVal.y, sliderVal.z);
}

// Function 881
vec2 sdScene(vec3 P) 
{    
    float d = MAX_VIEW_DISTANCE;
    for(int i=0; i<10; i++) 
    {
    	//d = min(d, sdSphere(P+state.enemies[i], 0.2));
    }
   	
    return vec2(d, 1.0);
}

// Function 882
SceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )
{
    SceneResult resultScreen;
#if 1
    vec3 vScreenClosest;
    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);
    vec2 vCurveScreenDomain = vScreenDomain.xy;
    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );
    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;
    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;
    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );
    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        
    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;
    //resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    
#endif    
    
#if 0
    vec3 vScreenClosest;
    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);
    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;
    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    
    resultScreen.fDist = max(fRoundDist, fSphereDist);
#endif    
    
    resultScreen.vUVW.xy = (vScreenDomain.xy / vScreenWH) * 0.5 + 0.5f;
	resultScreen.iObjectId = MAT_SCREEN;
    return resultScreen;
}

// Function 883
float map_plate(vec3 pos)
{
    #ifdef show_plate
    pos = rotateVec2(pos);
    pos.y+= 0.971 + plateThickness;
    
    float l = length(pos.xz)/plateSize;
    pos.y-= 0.13*smoothstep(0.58, 0.75, l);
    pos.y-= 0.05*smoothstep(0.7, 1.1, l);
    pos.y-= 0.06*smoothstep(-1., 0.6, cos(l*3.));
    pos.y/= (1. + 0.45*smoothstep(0.96, 1.02, l));
    float df = sdCylinder(pos, vec2(plateSize*1.1, plateThickness*1.03));
    df = SoftMaximum(df, sdCylinder(pos, vec2(plateSize, plateThickness*2.)), 55.);
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif   
    return df;
    #else
    return 10.;
    #endif
}

// Function 884
vec3 colormapIQ(float t){
    //vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );
   	// nice blue
    vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );
    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );
    
    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );
    
    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );
    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );
    //vec3 col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );
    
    return col;
}

// Function 885
float brushdist(Brush brush, vec2 p) {
    float t = iSphere(vec3(0.0), ray_rd, brush.sph);
    if (t < 0.0) {
    	return 1000.0 - t;
    } else {
        return t;
    }
}

// Function 886
vec3 light_distr(vec3 p)
{
    return vec3(1,1,1) * (4.*step(-light_sphere.w, -length(p - light_sphere.xyz)));
}

// Function 887
float sdfEye(vec3 p, mat4 t) {
    p = vec3(t * vec4(p, 1));
    if (p.y < (2. - 2.*(sin(4.*iTime) + 1.))){
    	return length(p) - 1.;
    }
    else 
        return 34134.2;
}

// Function 888
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );

  vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y/20.0, 0.0, 1.0);
  ;
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  float shadow=1.; 
  #ifdef SHADOWS
    shadow = SoftShadow(origin+((rayDir*rayHit.depth)*0.988), sunPos);
  #endif

    lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85)*shadow;
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);
  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00)*shadow;

  return clamp(lightTot, 0., 10.)*sunColor;
}

// Function 889
float distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //e = capped [0,1] orthogonal projection of ap on ab
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 890
void MapPianoBody(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos;
	
	//backfoot
	float re = Map2Box(pos - vec3(30.0, 40.0, 155.0), vec2(15.0,3.2), vec2(3.0,3.0), 35.0);
	
	//foot1
	float re_2 = Map2Box(pos - vec3(-67.0, 40.0, 12.0), vec2(5.0,12.5), vec2(3.0,3.0), 35.0);
	re = min(re, re_2);
	//foot2
	re_2 = Map2Box(pos - vec3(67.0, 40.0, 12.0), vec2(5.0,12.5), vec2(3.0,3.0), 35.0);
	re = min(re, re_2);
	
	//pedal box
	re_2 = MapBoxSim(pos - vec3(0.0, 10.0, 12.0), vec3(14.0,5.0,5.0));
	re = min(re, re_2);
	//pedal box2
	re_2 = Map2Box(pos - vec3(0.0, 42.5, 14.0), vec2(14.0,4.0), vec2(5.0,2.0), 35.0);
	re = min(re, re_2);
	
	//keyboard bottom
	re_2 = MapBoxSim(pos - vec3(0.0, 74.5, -9.0), vec3(75.0, 4.5, 9.0));
	re = min(re, re_2);
	
	//keyboard two side
	re_2 = MapBoxSim(pos - vec3(68.0, 77.0, -9.0), vec3(7.0, 7.0, 9.0));
	re = min(re, re_2);
	re_2 = MapBoxSim(pos - vec3(-70.0, 77.0, -9.0), vec3(5.0, 7.0, 9.0));
	re = min(re, re_2);
	
	{//open cover
		vec3 pos_trans = pos + vec3(-75, -99.0, 0.0);
		float angle = abs(fract((iTime +0.05)*0.05)-0.5);
		float sinv = sin(angle);
		float cosv = cos(angle);
		pos_trans.xy = pos_trans.xy * mat2(cosv, -sinv, sinv, cosv);
		pos_trans.x += 75.0;
		re_2 = MapCover0(pos_trans);
		re = min(re, re_2);
		
		re_2 = MapBoxSim(pos_trans - vec3(0.0, 3.0, 63.0), vec3(75.0, 1.0, 21.0));
		re = min(re, re_2);
	}
	
	{
		vec3 pos_temp = pos - vec3(0.0,83.0,21.0);
		float x = abs(pos_temp.x) - 75.0;
		float y = abs(pos_temp.y) - 13.0;
		float z = abs(pos_temp.z) - 21.0;
		z = Combine(x,z);//use to cal color
		if (pos_temp.z>0.0 && pos_temp.z<22.0)
		{
			z = x;
		}
		z = abs(z + 4.0) - 4.0;
		re_2 = Combine(z, y);
		re = min(re, re_2);
		
		pos_temp = pos - vec3(0.0,83.0,0.0);
		y = MapPianoBodyShapeDist(-pos_temp.x, pos_temp.z);//use to cal color
		if (pos_temp.z >40.0 && pos_temp.z<44.0)
		{
			y = abs(pos_temp.x) - 75.0;
		}
		y = abs(y + 4.0) - 4.0;
		z = abs(pos_temp.y) - 13.0;
		re_2 = Combine(y, z);
		re = min(re, re_2);
	
		if (re <= EPSILON)
		{
			obj.m_obj_idx = 2;
		}
	}
	obj.m_dist = re;
}

// Function 891
SceneResult Scene_GetComputer( vec3 vPos )
{
    SceneResult resultComputer;
    resultComputer.vUVW = vPos.xzy;
	
    float fXSectionStart = -0.2;
    float fXSectionLength = 0.15;
    float fXSectionT = clamp( (vPos.z - fXSectionStart) / fXSectionLength, 0.0, 1.0);
    float fXSectionR1 = 0.03;
    float fXSectionR2 = 0.05;
    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );
    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;
    
    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );
    vec2 vToPos = vPos.yz - vXSectionCentre;
    float l = length( vToPos );
    if ( l > fXSectionR ) l = fXSectionR;
    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;
    //float fXSectionDist = length( vXSectionClosest ) - fXSectionR;
    
    float x = max( abs( vPos.x ) - 0.2f, 0.0 );

    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;
    //resultComputer.fDist = x;
        
    resultComputer.iObjectId = MAT_TV_CASING;
/*
    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);
    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 / fXSectionLength;
    float fDomainRepeatScale = 0.02;
    if ( fract(vKeyPos.z * 0.5 / fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;
    vec2 vKeyIndex = round(vKeyPos.xz / fDomainRepeatScale);
    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );
    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );
    //vKeyPos.xz = (fract( vKeyPos.xz / fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;
    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);
    vKeyPos.xz /= 0.7 + vKeyPos.y;
    SceneResult resultKey;    
    resultKey.vUVW = vPos.xzy;
    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );
    resultKey.iObjectId = MAT_TV_TRIM;
    Scene_Union( resultComputer, resultKey );
*/    
    return resultComputer;
}

// Function 892
float map(vec3 p, int num){
    //float d = length(p-vec3(0.0,0.0,1.0)) - 0.25;
    float d =  loaddist;
    if(num == 0){
        d = sdBox(p - vec3(0.0,0.0,0.2), vec3(0.3,0.3,0.3));
    }
    if(num == 1){
        d = sdBox(p - vec3(0.2,0.05,-0.4), vec3(0.2,0.15,0.2));
    }
    if(num == 2){
    	d = sdPlane(p - vec3(0.0, -2.0, 0.0), vec4(0.0, 1.0, 0.0, 0.0));
    }
	return d;
}

// Function 893
vec4 DebugSDFColor(float d)
{
    return DebugSDF(d)*DebugSDFPatternColor(d);
}

// Function 894
float SDF_Moon(vec3 point, inout RayHit hit)
{
    float sdf = FarClip;
    
    point = RotX(point, PI * -0.15 * HEAD_TILT);
    
    float moonSDF    = SDF_MoonBody(point);
    float eyesSDF    = SDF_Eye(point);
    float socketsSDF = SDF_EyeSocket(point);
    float noseSDF    = SDF_Nose(point);
    float mouthSDF   = SDF_Mouth(point);
    float teethSDF   = SDF_Teeth(point, mouthSDF);
    
    // If we have intersected either sockets/mouth AND have hit the moon (we are in a cut out)
    AssignM(min(socketsSDF, mouthSDF) + moonSDF * 2.0, MAT_Socket);
    AssignM(eyesSDF, MAT_Eye);
    AssignM(teethSDF, MAT_Teeth);
    
    sdf = Subtraction(socketsSDF, moonSDF);
    sdf = SUnion(sdf, eyesSDF, 0.05);
    sdf = SUnion(sdf, noseSDF, 0.05);
    sdf = Subtraction(mouthSDF, sdf);
    sdf = min(sdf, teethSDF);
    
    return sdf;
}

// Function 895
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, cRefl;
  float dstObj, s, r, sh;
  dstObj = ObjRay (ro, rd);
  cRefl = vec3 (1.);
  if (dstObj < dstFar && idObj == 1) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (ro.y < 0.41 - (bCylHt - 1.75)) {
      r = length (ro.xz);
      s = 0.001 * sin (2. * pi * (4. * r - 0.5 * tCur)) / (r * r);
      vn.y = 1. - abs (s);
      vn.xz = - sign (s) * sqrt (1. - vn.y * vn.y) * ro.xz / r;
      vn = VaryNf (8. * ro + 0.2 * tCur * vec3 (0., 0., 1.), vn, 0.05);
    } else cRefl *= vec3 (1., 0.95, 1.);
    rd = reflect (rd, vn);
    ro += 0.01 * rd;
    dstObj = ObjRay (ro, rd);
  }
  if (dstObj < dstFar && idObj == 1) {
    cRefl *= vec3 (1., 0.95, 1.);
    ro += dstObj * rd;
    vn = ObjNf (ro);
    rd = reflect (rd, vn);
    ro += 0.01 * rd;
    dstObj = ObjRay (ro, rd);
  }
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (idObj == 1) col = SkyCol (ro, reflect (rd, vn));
    else if (idObj == 2) {
      col = vec3 (0.6, 0.5, 0.5) * (1. - 0.2 * SmoothBump (0.45, 0.55, 0.03,
         mod (32. * atan (ro.z, - ro.x) / pi, 1.)));
      vn = VaryNf (32. * ro, vn, 1.);
      sh = ObjSShadow (ro, sunDir);
      col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);
    }
  } else {
    col = BgCol (ro, rd);
  }
  col *= cRefl;
  return clamp (col, 0., 1.);
}

// Function 896
float distSquaredCylinder( vec3 p, vec3 d, float r)
{
	return max(length(max((abs(p.xz)-(d.xz-r)),0.0))-r,abs(p.y)-d.y);
}

// Function 897
float scene(vec3 p)
{
	//float d = scene1(p);
    //float d = scene2(p);
    float d4 = scene4(p);
    float d5 = scene5(p);
    float d45 = opU(d4,d5);
    float dtunnel = scenetunnel(p);
    float drails = scenerails(p);
    float d = opU(opU(d45,drails),dtunnel);
    //float d = opU(d45,drails);
    return d;
}

// Function 898
vec2 map(vec3 pos, bool btext)
{
    vec2 res;

    float candle = map_candle(pos);
    float wick = map_wick(pos);
    float flame = map_flame(pos);
    float table = map_table(pos, btext);
    float plate = map_plate(pos);

    res = vec2(candle, CANDLE_OBJ);
    res = opU(vec2(wick, WICK_OBJ), res);
    res = opU(vec2(flame, FLAME_OBJ), res);
    res = opU(res, vec2(table, TABLE_OBJ));
    res = opU(res, vec2(plate, PLATE_OBJ));

    return res;
}

// Function 899
float map(vec3 p)
{    
	bool f;
    float d = boundingBox( p, vec3( 1.0, 1.0, 0.35 ), f );
    if ( f )
    { 
        for ( int i = 0; i < 16; i++ )
    	{
			Mesh m = genMesh( i );
    		d = min( triangleDE( p, m.a, m.b, m.c ), d );
    	}
        d -= 0.001;
    }
    return d; 
}

// Function 900
float sdfIntersection( const float a, const float b )
{
    return max(a, b);
}

// Function 901
vec3 remap( float a, float b, vec3 v ) {
    //return (v-a) / (b-a);
	return clamp( (v-vec3(a)) / vec3(b-a), 0.0, 1.0 );
}

// Function 902
float OceanDistanceFieldDetail( vec3 pos )
{
	return pos.y - WavesDetail(pos);
}

// Function 903
vec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = texture( sam, p.yz );
  vec4 y = texture( sam, p.zx );
  vec4 z = texture( sam, p.xy );
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 904
float mapQ(vec3 p){
  float s = 0.5;
  for(float i = 1.; i < MAX_LEVEL; i++){
    s *= 2.;
    
    //if we don't pass the random check, add max to index so we break
    i += step( hash13(floor(p * s)), 0.5 ) * MAX_LEVEL;
  }
  return s;
}

// Function 905
float sceneDist(vec2 p)
{
	float c = circleDist(		translate(p, vec2(100, 250)), 40.0);
	float b1 =  boxDist(		translate(p, vec2(200, 250)), vec2(40, 40), 	0.0);
	float b2 =  boxDist(		translate(p, vec2(300, 250)), vec2(40, 40), 	10.0);
	float l = lineDist(			p, 			 vec2(370, 220),  vec2(430, 280),	10.0);
	float t1 = triangleDist(	translate(p, vec2(500, 210)), 80.0, 			80.0);
	float t2 = triangleDist(	rotateCW(translate(p, vec2(600, 250)), iTime), 40.0);
	
	float m = 	merge(c, b1);
	m = 		merge(m, b2);
	m = 		merge(m, l);
	m = 		merge(m, t1);
	m = 		merge(m, t2);
	
	float b3 = boxDist(		translate(p, vec2(100, sin(iTime * 3.0 + 1.0) * 40.0 + 100.0)), 
					   		vec2(40, 15), 	0.0);
	float c2 = circleDist(	translate(p, vec2(100, 100)),	30.0);
	float s = substract(b3, c2);
	
	float b4 = boxDist(		translate(p, vec2(200, sin(iTime * 3.0 + 2.0) * 40.0 + 100.0)), 
					   		vec2(40, 15), 	0.0);
	float c3 = circleDist(	translate(p, vec2(200, 100)), 	30.0);
	float i = intersect(b4, c3);
	
	float b5 = boxDist(		translate(p, vec2(300, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), 
					   		vec2(40, 15), 	0.0);
	float c4 = circleDist(	translate(p, vec2(300, 100)), 	30.0);
	float a = merge(b5, c4);
	
	float b6 = boxDist(		translate(p, vec2(400, 100)),	vec2(40, 15), 	0.0);
	float c5 = circleDist(	translate(p, vec2(400, 100)), 	30.0);
	float sm = smoothMerge(b6, c5, 10.0);
	
	float sc = semiCircleDist(translate(p, vec2(500,100)), 40.0, 90.0, 10.0);
    
    float b7 = boxDist(		translate(p, vec2(600, sin(iTime * 3.0 + 3.0) * 40.0 + 100.0)), 
					   		vec2(40, 15), 	0.0);
	float c6 = circleDist(	translate(p, vec2(600, 100)), 	30.0);
	float e = mergeExclude(b7, c6);
    
	m = merge(m, s);
	m = merge(m, i);
	m = merge(m, a);
	m = merge(m, sm);
	m = merge(m, sc);
    m = merge(m, e);
	
	return m;
}

// Function 906
float scene(vec3 p)
{
    vec3 rot =
        vec3(2.140, 2.512, .753)
      + cb(13) * vec3(8.22, 16.63, 1.5 + TIME_S * .138) // Anim 1
      + cb(14) * vec3(0, .07, 0) * TIME_S               // Anim 2
        ;

    pModPolar(p.xy, 6.);
    pMirror(p.y, 2.);
    pMirror(p.x, 2.);
    pMirror(p.z, 2.);
    pMirror(p.x, 0.);
    pMirror(p.y, 0.);
    pR(p.xz, rot.x);
    pR(p.yz, rot.y);
    pR(p.xy, rot.z);
    pMirror(p.y, 2.);
    pMirror(p.x, 2.);
    pMirror(p.z, 2.);
    pModPolar(p.xy, 9.);
    p -= vec3(1.634, .017, .510);
    return fBox(p, vec3(.735, 1.446, .541));
}

// Function 907
float distSphere(vec3 pos, float r)
{
	return length(pos)-r;
}

// Function 908
Model map( vec3 p ){
    mat3 m = modelRotation();
    p *= m;  
    #ifndef LOOP
    	pR(p.xz, time * PI/16.);
    #endif
    Model model = geodesicModel(p);
    return model;
}

// Function 909
float DistRay(ray r, vec3 p){
	return length(p - ClosestPoint(r, p));
}

// Function 910
vec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {
	if (SHOW_COSTLY) return vec2(8.);
	float d = 1e5;
	for (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision
		
		// construct the 2 sub- control polygons
		vec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),
			 P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),
			 P0123 = mix(P012,P123,x); // is on the spline
		vec2 D = P0123-pos;
		d = min(d, dot(D,D));
	}
	d = sqrt(d);
	return vec2(d);
}

// Function 911
float map(in vec3 p, out int m)
{
  float d1 = weird(p, m);
  return d1;
}

// Function 912
float sea_geometry_map(vec3 p) 
{
    #if WATER_TYPE == WAVES_WATER
    vec2 uv = p.xz * vec2(0.85, 1.0);
	
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    
    float d = 0.0;
    float h = 0.0;    
    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) 
    {   
		#if FANTASY_WATER_PATH
        if (uv.x > UV_START_X && uv.x < UV_END_X)
	   	{
			continue;
	   	}
		#endif

    	d =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);
    	d += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy);
        h += d * amp; 
	    
		freq *= SEA_GEOMETRY_FREQ_MUL; 
		amp  *= SEA_GEOMETRY_AMPLITUDE_MUL;
	    
        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);
	    
		uv *= octave_matrix; 
    }
    return p.y - h;
    #else
    return p.y;
    #endif
}

// Function 913
vec3 sampleBSDF(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                	in vec3 wi,
                  	in Material mtl,
                  	in bool useMIS,
                  	in int strataCount,
                  	in int strataIndex,
                	out vec3 wo,
                	out float brdfPdfW,
                	out vec3 fr,
                	out bool hitRes,
                	out SurfaceHitInfo hit,
               		out float spec) {
    vec3 Lo = vec3(0.0);
    for(int i=0; i<DL_SAMPLES; i++){
        float Xi1 = rnd();
        float Xi2 = rnd();
        float strataSize = 1.0 / float(strataCount);
        Xi2 = strataSize * (float(strataIndex) + Xi2);
        fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW, spec);
        
        //fr = eval(mtl, ng, ns, wi, wo);

        float dotNWo = dot(wo, ns);
        //Continue if sampled direction is under surface
        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {
            Ray shadowRay = Ray(x, wo);

            //abstractLight* pLight = 0;
            float cosAtLight = 1.0;
            float distanceToLight = -1.0;
            vec3 Li = vec3(0.0);

            {
                float distToHit;

                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {
                    if(hit.mtl_id_>=LIGHT_ID_BASE) {
                        distanceToLight = distToHit;
                        cosAtLight = dot(hit.normal_, -wo);
                        if(cosAtLight > 0.0) {
                            Li = getRadiance(hit.uv_);
                            //Li = lights[0].color_*lights[0].intensity_;
                        }
                    } else {
                        hitRes = true;
                    }
                } else {
                    hitRes = false;
                    //TODO check for infinite lights
                }
            }

            if (distanceToLight>0.0) {
                if (cosAtLight > 0.0) {
                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;

                    if (useMIS/* && !(mtl->isSingular())*/) {
                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);
                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );
                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;

                        contribution *= misWeight(brdfPdfW, lightPdfW);
                    }

                    Lo += contribution;
                }
            }
        }
    }

    return Lo*(1.0/float(DL_SAMPLES));
}

// Function 914
vec2 map(in vec3 l, in pln p) {
    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));
}

// Function 915
float scene(vec3 p)
{
    _d = 1e10;
    
    _dplanes = sdDistancePlanes(p);
    _dgrid = min(sdAxes(p),sdGrid(p));
    _darrow = sdNormalArrow(p);
    _dobject = _ignore == 3 ? 1e10 : myObject(p);

    _d = min(_d, _dplanes);
    _d = min(_d, _dgrid);
    _d = min(_d, _darrow);
    _d = min(_d, _dobject);

    return _d;
}

// Function 916
vec3 sampleScene(vec2 ro) {
    vec3 fcol = vec3(0);
    
    for(float i=0.; i < LIGHT_SAMPLES; i++) {
    
        float r = (random(ro + i) + i) / LIGHT_SAMPLES * PI * 2.0;

        vec2 rd = vec2(cos(r), sin(r));
        float t = trace(ro, rd);
        vec3 col = vec3(0.);
        
        if(t < 20.) {
            vec2 p = ro + t * rd;
            
            if(materials[id].light) {
                // hit a light
                col = materials[id].emissive * materials[id].intensity;
            }
            else {
                if(t < 0.0001) {
                    // inside object (not light)
                    col = texture(iChannel0, ro * 1.2).rrr;
                }
                else {
                    // hit object; calculate reflection
                    vec2 nor = normal(p);
                    vec2 refl = reflect(rd, nor);
                    int matId = id;
                    float k = trace(p + refl * 0.001, refl);
                    if(k < 20.) {
                        // hit light
                        if(materials[id].light) {
                            col = materials[id].emissive * materials[id].intensity * materials[matId].diffuse;
                        }
                        else {
                            // hit material; calculate second reflection
                            vec2 p2 = p + refl*0.001 + k*refl;
                            nor = normal(p2);
                            refl = reflect(refl, nor);
                            int matId2 = id;
                            float j = trace(p + refl * 0.001, refl);
                            if(k < 20. && materials[id].light) {
                                // hit light
                                col = materials[id].emissive * materials[id].intensity 
                                                             * materials[matId].diffuse;
                            }
                        }
                    }
                }
            }
        }
        else col = vec3(0.3); // ambient
        fcol += col;
    }
    
    return fcol / LIGHT_SAMPLES;
}

// Function 917
float dist3D (vec3 p)
{
    float inflate = .5+.5*sin(iTime);
    return extrudeDist(dist(p.xz), .05, p.y)-inflate*.05;
}

// Function 918
vec2 map(vec3 p, int octaves) {
	float dMin = 28.0;
	float d;
	float mID = -1.0;
	
	// Mountains
	float h = terrain(p.xz, octaves);
	h += smoothstep(0.0, 1.1, h);
    h += smoothstep(-0.1, 1.0, p.y)*0.6;
	d = p.y - h;
	if (d<dMin) { 
		dMin = d;
		mID = 0.0;
	}
	// Sand dunes
	if (h<0.5) {
		float s = 0.3 * terrainSand(p.xz*0.2, octaves);
		d = p.y -0.35 + s;	
		if (d<dMin) { 
			dMin = d;
			mID = 1.0;
		}
	}
	return vec2(dMin, mID);
}

// Function 919
float sdf_F(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(4, 0, 0)));
    return t;
}

// Function 920
float sceneSDF(vec3 samplePoint) {
    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;
    float cubeDist = cubeSDF(samplePoint);
    return intersectSDF(cubeDist, sphereDist);
}

// Function 921
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(1,1,0),vec2(0.2,0.5)),50.0));
    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(-1,1,0),vec2(0.2,0.5)),50.0));
    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(1,-1,0),vec2(0.2,0.5)),50.0));
    res = opU(res, vec2(sdHexPrism(vec3(pos.xzy)-vec3(-1,-1,0),vec2(0.2,0.5)),50.0));

    return res;
}

// Function 922
vec2 map(float t){//from iq's shader https://www.shadertoy.com/view/Xlf3zl
	return 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));
}

// Function 923
vec2 map( in vec3 pos, float time )  
{
    float id = 0.;
    float sphere = sdSphere(pos, 0.5);
    float plane = pos.y + 0.5;
    
    if(plane < sphere) {
    	id = 1.;    
    }
    
    float d = min(sphere, plane);
    
    return vec2(d, id);
}

// Function 924
void mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )
{
  //O = vec4(.5+.5*D,0); U = U/1024. - 1./vec2(4,8); O -= .01/dot(U,U); return;
  //int f = faceID(D); O = vec4(f&1,f&2,f&4,0); return;
 
    U *= 2./iResolution.xy;
    int v = ( int(U.x)+2*int(U.y) + 4*faceID(D) + iFrame*24 ) % 264;

    O = vec4( equal( ivec4( 255.* texture(iChannel0, fract(U))),
                     ivec4( v ) ) );
}

// Function 925
float map( vec3 p, float s )
{
	float scale = 1.0;

	orb = vec4(1000.0); 
	
	for( int i=0; i<8;i++ )
	{
		p = -1.0 + 2.0*fract(0.5*p+0.5);

		float r2 = dot(p,p);
		
        orb = min( orb, vec4(abs(p),r2) );
		
		float k = s/r2;
		p     *= k;
		scale *= k;
	}
	
	return 0.25*abs(p.y)/scale;
}

// Function 926
void rotateSceneTenDegrees(int f) {
    theta += float(f)/5.0 * 3.1415/45.0;
    //theta = 0.0;
    for (int i=0; i<6; i++) {
        // rotate each child sphere about y-axis 
        // through the center of the large one
        vec3 v1 = spheres[i+1].center - spheres[0].center;
        vec3 axis = normalize(vec3(0.0, spheres[0].radius, 0.0));
        vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));
        spheres[i+1].center = newv + spheres[0].center;
    }
}

// Function 927
float map_simple(vec3 pos)
{   
    float angle = 2.*pi*iMouse.x/iResolution.x;
    float angle2 = -2.*pi*iMouse.y/iResolution.y;
    
    vec3 posr = pos;
    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));
    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); 
    
    float d = 1.05;
    float s = atan(posr.y, posr.x);
    
    vec3 flatvec = vec3(cos(s), sin(s), 1.444);
    vec3 flatvec2 = vec3(cos(s), sin(s), -1.072);
     
    float d1 = dot(flatvec, posr) - d;                        // Crown
    d1 = max(dot(flatvec2, posr) - d, d1);                    // Pavillon
    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.35, d1);         // Table
    return d1;
}

// Function 928
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 roo, rdo, col, vn, ltDir;
  float dstHit;
  int idObjT;
  ltDir = normalize (vec3 (0.5, 1., -0.5));
  idObj = -1;
  roo = ro;
  dstHit = ObjRay (ro, rd);
  idObjT = idObj;
  if (dstHit < dstFar) {
    ro += dstHit * rd;
    vn = ObjNf (ro);
    if (idObjT == 1) {
      col = mix (vec3 (1., 1., 0.), vec3 (1., 1., 0.8),
	 clamp (1.2 * length (ro) / bxSize, 0., 1.));
      col = col * clamp (1. - 1.5 * qnStep * qnStep, 0.3, 1.);
    }
    col = col * (0.2 +
       0.6 * max (dot (vn, ltDir), 0.)) +
       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);
  } else {
    col = vec3 (0., 0., 0.1);
    rdo = rd;
    rdo += vec3 (1.);
    for (int j = 0; j < 10; j ++)
       rdo = 11. * abs (rdo) / dot (rdo, rdo) - 3.;
    col += min (1., 1.5e-6 * pow (min (16., length (rdo)), 5.)) *
       vec3 (0.7, 0.6, 0.6);
  }
  col = mix (col, vec3 (1., 0.5, 0.3), GlowCol (roo, rd, dstHit));
  return clamp (col, 0., 1.);
}

// Function 929
vec2 texNormalMap(in vec2 uv)
{
    vec2 s = 1.0/heightMapResolution.xy;
    
    float p = texture(heightMap, uv).x;
    float h1 = texture(heightMap, uv + s * vec2(textureOffset,0)).x;
    float v1 = texture(heightMap, uv + s * vec2(0,textureOffset)).x;
       
   	return (p - vec2(h1, v1));
}

// Function 930
vec2 segDistance(vec3 pos, vec3 start, vec3 end, float radius) {
    // thanks to iq
    vec3 a = pos - start;
    vec3 b = end - start;
   	float prod = dot(a, b);
    float norm = prod / dot(b,b);
    norm = clamp(norm, 0.0, 1.0);
    vec3 segPos = start * (1.0 - norm) + end * norm;
    return vec2(length(pos - segPos) - radius, norm);
}

// Function 931
float sceneSDF(vec3 p){
    return unionSDF(floorSDF(p),tetrahedron(p));
}

// Function 932
vec2 mapScene(vec3 pos)
{
    vec2 a = vec2(i_kFar), b = vec2(i_kFar);

    float q = floor(mod(iTime*.20, 4.));
    
    b = vec2(max(-sdBox(pos-vec3(0,4,0), vec3(5)), sdBox(pos, vec3(100))), 8); MIN(a, b);
    b = vec2(sdBox(pos+vec3(0,.99,0), vec3(100,.01,100)), 0); MIN(a, b);
    b = vec2(sdBox(pos+vec3(0,0,4.99), vec3(5,5,.01)), 2); MIN(a, b);
    
    pos.y+= .5;
    vec2 c = pMod2(pos.xz, vec2(1, 3));
    pR(pos.xz, hashi(ivec2(c))*.25);
    b = vec2(sdChair(pos), 0); MIN(a, b);
    
    return	a;
}

// Function 933
float torusSDF_multi2( vec3 p, float r, float thickness ){
  vec2 q = vec2(length(p.xz)-r,p.y);
    vec2 qq = fract(q) * 2. - 1.;
  return length(qq)- thickness;
}

// Function 934
void initScene() {
    float time = 100.0;//iTime;
    
    //create lights
    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);
    
    //Create materials
    createMaterial(vec3(0.6, 1.0, 0.6), -1, vec3(0.5, 1.0, 0.5), 0.15, -1, 0.6, -1, 2, 1.0, materials[0]);
    createMaterial(vec3(1.0, 1.0, 1.0), 0, vec3(1.0, 1.0, 1.0), 0.0, 0, 0.2, -1, 0, 2.0, materials[1]);
    createMaterial(vec3(0.3, 0.5, 1.0), 1, vec3(1.0, 1.0, 1.0), 0.0, 1, 0.4, 1, 1, 1.0, materials[2]);
    createMaterial(vec3(0.5, 0.5, 0.5), -1, vec3(0.9, 0.9, 1.0), 0.03, 2, 1.0, -1, -1, 1.0, materials[3]);
    createMaterial(vec3(1.0, 1.0, 1.0), 2, vec3(1.0, 1.0, 1.0), 0.0, 2, 0.4, 2, 2, 1.0, materials[4]);
    
    //init lights
    float r = 1.0;
    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;
    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;
    float x = xFactor*7.0;
    float z = -3.0-yFactor*5.0;
    float a = -1.2+sin(time*0.23);
    mat4 trans = createCS(	vec3(x, 5.0+sin(time), z),
                          	vec3(0.0, sin(a), cos(a)),
                  			vec3(1.0, 0.0, 0.0));
#ifdef SPHERE_LIGHT
    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );
#else
    createPlane(trans, -2.0, -1.0, 2.0, 1.0, LIGHT_ID_BASE+0, objects[0]);
#endif
    
    
    //plane 1
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 5.0, -10.0, 1.0 ));
    createPlane(trans, -10.0, -2.0, 10.0, 4.0, SURFACE_ID_BASE+1, objects[1]);
   
    //plane 2
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, -1.0, 0.0 ),
                    vec4( 0.0, -1.0, 0.0, 0.0 ),
                    vec4( 0.0, -1.0, -4.0, 1.0 ));
    createPlane(trans, -10.0, -4.0, 10.0, 2.0, SURFACE_ID_BASE+1, objects[2]);
 
    //Cylinder
    trans = mat4(	vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( -0.0, 3.0, -6.0, 1.0 ));
    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );
    
    //sphere 1
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 1.5, -0.3, -2.0, 1.0 ));

    createSphere(trans, 0.7, SURFACE_ID_BASE+2, objects[4] );
    
    //sphere 2
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 0.0, -4.5, 1.0 ));

    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );
    
    //box
    trans = createCS(	vec3(-1.5, -1.0, -3.0),
                     	vec3(0.0, 1.0, 0.0),
                     	vec3(0.2, 0.0, -0.7));
    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), SURFACE_ID_BASE+0, objects[6]);
    
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 3.5, 0.5, -4.2, 1.0 ));

    createSphere(trans, 1.5, SURFACE_ID_BASE+4, objects[7] );
    /*
    //torus
    trans = createCS(	vec3(3.0, 1.0, -4.0),
                        vec3(-0.5, 0.0, 0.5),
                  	    vec3(1.0, 0.0, 0.0));
    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/
}

// Function 935
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(2./iResolution.y, 0); 
    
    float f = bumpFunction(p); // Hit point function sample.
    
    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.
    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.
    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.
    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.
    float fz2 = bumpFunction(p + e.yyx);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 936
vec3 CubemapRayDir(in vec2 fragCoord) 
{
    vec2 t = fragCoord.xy*vec2(4.0, 2.0) / iResolution.xy;
    vec3 n = CubemapNormal(floor(t));
    
    float g = 4.0 / iResolution.x;
    float vo = iResolution.x*0.5 - iResolution.y;
    
    vec2 xzp = fract(min(vec2(4.0, 0.99999), fragCoord.xy * g));
    
    vec2 ypp = vec2(min(0.99999, fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));
    vec2 ypn = vec2(max(3.0,     fragCoord.x * g), max(1.0, (fragCoord.y + vo) * g));
    vec2 yp = fract(ypp * step(-0.5, n.y) + ypn * (1.0 - step(-0.5, n.y)));
    
    vec2 p = (xzp * (1.0 - abs(n.y)) + yp * abs(n.y)) - 0.5;
    
    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * abs(n.x);
    vec3 py = vec3(p.x*n.y, 0.5*n.y, -p.y) * abs(n.y);
    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);
    
   	vec3 rd = px + py + pz; 
    return normalize(rd);
}

// Function 937
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    const vec2 e = vec2(0.001, 0);
    float ref = bumpSurf3D(p, nor);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),
                      bumpSurf3D(p - e.yxy, nor),
                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     
          
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 938
float map(in vec3 _rp)
{
    _rp -= g_shipPos;
    _rp = _rp * g_shipRotation;
    _rp = _rp * g_model_correction;
    g_rp_polar = polar(_rp.xz);
    g_hitp_local = _rp;
    
    // ship shape is made by repeating the space in pie-shape fashion
    vec2 rp_polar_real = polar(_rp.xz);
	vec2 rp_polar = abs(rp_polar_real);
    
    _rp.xz = repeatPolarAngle(rp_polar, slice);
    
    float m = sdBox( _rp, vec3(0.05, 0.0035, 0.05) * 4.0);
    float m3 = sdBox((_rp + vec3(-0.15, -0.015, 0.)), vec3(0.005, 0.015, 0.012) * vec3(6.0, 4.0, 10.0));
    
    // 2 boxes mixed gives nicer shape
	m = mix(m, m3, 0.1);
    // mixing with a sphere for a rounded shape
    m = mix(m, length(_rp - vec3(0.0, 0.05, 0.)) - .2, 0.2);
	return m;
}

// Function 939
float map( vec3 p ) {
  p -= vec3(
    cellPos,
    (
      0.4 * cellHash.x
      + 0.2 * ( cellPos.x + cellPos.y ) - 8.2
    )
  );

  return max(
    sdbox( p, step( cellHash.y, 0.9 ) * vec2(
      0.5 * cellSize - 1.0 / 64.0,
      8
    ).xxy ),
    -sdbox( p, step( cellHash.y, 0.4 ) * vec2(
      0.5 * cellSize - 3.0 / 64.0,
      9
    ).xxy )
  );
}

// Function 940
float map(vec3 p) {
  
  p += tunnel(p);
  
  float d1 = part1(p);
  float d2 = part2(p);
  
  vec3 p2 = p;
  p2.z = repeat(p2.z, 120.);
  float mi = box(p2, vec3(100,100,34));
  
  // mix part 1 and part 2
  d1 = max(d1, -mi);
  d1 = min(d1, max(d2, mi));
  
  // enter hatch
  float cc = abs(cyl(p.xy,11.))-2.;
  cc = max(cc, abs(mi)-1.);
  d1 = min(d1, cc);
  
  //d1 = d2; // tmp
  
  // light position
  p.z = repeat(p.z, 67.);
  vec3 relp = lpos-p;
  float dl = length(relp)-0.5;
  light += 1.0/(0.2+dl*dl);
  d1 = min(d1, dl);
  d1 = min(d1, max(-relp.y,length(relp.xz)-0.3));
  
  
  tmpo = max(tmpo, -mi);
  blue += 0.7/(0.2+abs(tmpo));
  
  water = (d1 == d2) ? 0. : 1.;
  
  d1 *= 0.7;
  
  return d1;
  
}

// Function 941
vec2 GetDistanceMirrorStand( const in vec3 vPos )
{
	float fDistanceOuter = GetDistanceBox(vPos - vec3(0.0, 1.5, 0.0), vMirrorStandSize + vec3(fMirrorStandWidth));
	float fDistanceInner = GetDistanceBox(vPos - vec3(0.0, 1.5 + fMirrorStandWidth * 2.0, 0.0), vMirrorStandSize + vec3(0.0, fMirrorStandWidth ,1.0));
		
	float fDistance = max(fDistanceOuter, -fDistanceInner);

	return vec2(fDistance, kMaterialWood);
}

// Function 942
float scene(vec3 p) {
   //pR45(p.xz);
   pR(p.xz, touch.x*0.01); //time);
   pR(p.yz, touch.y*0.01);
   float sc, sc2, sc3, sc4, sc5;
   vec3 p2 = p, p3 = p;
   //p2.y+=cos(time);
   
   float decayExp = fract(time*4.0)*fract(time);
   decayExp = pow(decayExp,3.0);
   float decayExp2 = fract(time*1.125);
   decayExp = pow(decayExp,2.0);
   
   pMirrorOctant(p2.yz, vec2(decayExp*0.250,-decayExp2*0.25));
   pModPolar(p2.yz, 6.0);
   p2 += v3(0.0, cos(time)*0.25, 0.0);
   sc = piston(p2);
   sc2 = nut(p);
   //sc /= fCylinder(p2, 0.25, 0.5);
   //sc2 = fCylinder(p2+v3(0.25, 0.0, 0.0), 0.125, 0.5);
   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);
   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);
   pR(p3.xy, 1.5);
   sc4 = fCylinder(p3, 0.25, 0.05);
   sc5 = fOpEngrave( sc3, sc4, 0.25);
   p*= 2.0;
   vec3 p4 = pMod3(p,v3(1.0,2.0,0.50));
   float sco = fOpPipe(sc3, fBox(p,abs(fract(p2))), 0.01);//0.1);
   sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);


return sco;
}

// Function 943
float MapCylinder(in vec3 pos, in float r, in float half_h)
{
	float y = abs(pos.y) - half_h;
	float rr = length(pos.xz) - r;
	return Combine(y, rr);
}

// Function 944
vec4 scene (vec3 pos){
    float a1 = distance(vec3(0.,0.,0.),
                        vec3((noise(pos*mix(0.2,2.,noise(pos+vec3(58.36,21.365,128.32)))))))
        -0.3;
    float a2 = distance(vec3(0.,0.,0.),
                        vec3((noise(pos*mix(0.2,2.,noise(pos+vec3(657.32,914.32,11.32)))))))
        -0.3;
    float a3 = min(a1,a2);
    float a4 = distance(vec3(0.), vec3(m(pos)))-mix(0.,mix(0.,0.3,noise(pos*0.2)),
                                                    noise(pos*4.+vec3(26.32,99.35,785.3)));
    float a5 = distance(vec3(0.), vec3(m(pos+vec3(12.326,654.32,98.32))))-mix(0.,mix(0.,0.2,noise(pos*0.2)),
                                                    noise(pos*4.+vec3(2657.32,94.32,17.32)));
    float a7 = min(a4,a5);
    float a6 = min(a7,a3);
    float b2 =sph(pos,4.);
    float b3 = max(a6,-b2);
    vec3 mask = vec3(step(a1,a2),smoothstep(0.,1.,a5),step(a3,a7));
    vec4 resu = vec4(mask,b3);
    return resu;
}

// Function 945
float distancePixel(vec2 p,vec4 h//prevu,hit
){if(min(iR.xy,p)!=p && max(vec2(0.),p)!=p)return MaxDist
 ;vec4 prevPos=texture(iChannel2,p/iR.xy)
 ;Camera cam=getCam(iTime,iMouse,iR)
 ;return length(prevPos-h);}

// Function 946
vec2 map( in vec3 pos ) {
    vec2 res = opU( vec2( sdPlane( pos), 3.0 ),
	                vec2( udBox( pos+vec3(0.0, 9.0, 85.0), vec3( 200., 10.0, 100. ) ), 1. ) );

	res = opU( res, vec2( udBox( pos+vec3(0.0, 20.0, 75.0), vec3( 200., 10.0, 100. ) ), 1. ) );
 	res = opU( res, vec2( udBox( pos+vec3(0.0, 6.5, -15.0), vec3( 200., 10.0, 0.25 ) ), 1. ) );

	res = opU( res, vec2( udBox( pos+vec3( 220.0, 14.0, 0.0), vec3( 100., 10.0, 200. ) ), 1. ) );
		
	res = opU( res, vec2( udBox( (pos+vec3(3.20, -4.95, -5.55)), vec3( 0.55, 0.9, 0.01 ) ), 2. ) );
	res = opU( res, vec2( sdCylinderXZ( vec3(mod(pos.x+8., 16.)-8., pos.y+10., pos.z-24.), vec2( 0.4, 1.5)), 1.) );

	if( pos.z > 20. ) {
		return res;
	}
	
	res = opU( res, vec2( objPrentenTentoonstelling( vec3(mod(pos.x+40.,80.)-40., pos.y, mod(pos.z+40.,80.)-40.) ), 1. ) );
	
	pos += vec3(3.25, -4.60, -5.55);
	res = opU( res, vec2( opI(
		udBox( vec3(mod(pos.x+0.8, 1.6)-0.8, pos.y, pos.z), vec3( 0.7, 0.9, 0.1 ) ),
		udBox( pos-vec3(3.25, -4.60, -5.55), vec3( 5.5, 5.5, 8.5 ) )
		), 4. ) );
	pos -= vec3(3.25, -4.60, -5.55);
	
	pos += vec3( 15.5, 8., 10.);
	res = opU( res, vec2( objB1( vec3(mod(pos.x+27.,54.)-27., pos.y, mod(pos.z+50.,100.)-50.) ), 1. ) );
	pos += vec3( 20.5, -8., 5.);
	res = opU( res, vec2( objB2( vec3(mod(pos.x+23.,46.)-23., pos.y, mod(pos.z+35.,70.)-35.) ), 1. ) );
	pos += vec3( 20., -10., 10.);
	res = opU( res, vec2( objB1( vec3(mod(pos.x+77.,144.)-77., pos.y, mod(pos.z+66.,132.)-66.) ), 1. ) );
		
	return res;
}

// Function 947
vec3 sdfGrad(in vec3 p, in float e) {
	float a = sdf(p+vec3(e,e,e));
	float b = sdf(p+vec3(e,-e,-e));
	float c = sdf(p+vec3(-e,e,-e));
	float d = sdf(p+vec3(-e,-e,e));
	return (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);
}

// Function 948
float beckmannDistribution(float roughness, float NdotH)
{
    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));
    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);
    return r1 * exp(r2);
}

// Function 949
vec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS ) {
    vec3 Lo = vec3( 0.0 );
    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);
    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);
    
    for( int i=0; i<BSDF_SAMPLES; i++ ) {
        //Generate direction proportional to bsdf
        vec3 bsdfDir;
        float bsdfPdfW;
        float Xi1 = rnd();
        float Xi2 = rnd();
        float strataSize = 1.0 / float(BSDF_SAMPLES);
        Xi2 = strataSize * (float(i) + Xi2);
        float brdf;
        
        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {
            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );
            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );
        } else {
            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );
            brdf = evaluateLambertian( n, bsdfDir );
        }
        
        float dotNWi = dot( bsdfDir, n );

        //Continue if sampled direction is under surface
        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){
            //calculate light visibility
            RaySurfaceHit newHit;
            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {
                //Get hit light Info
                vec3 Li;
                Sphere lightSphere;
                getLightInfo( newHit.obj_id, lightSphere, Li );

                //Read light info
                float weight = 1.0;
				float lightPdfW;
                if ( useMIS ) {
                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );
                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);
                    weight = misWeight( bsdfPdfW, lightPdfW );
                }

                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;
            }
        }
    }

    return Lo*bsdfSamplingPdf;
}

// Function 950
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
}

// Function 951
vec3 renderScene( vec2 p, vec3 ro, vec3 ta ) {
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0.0 );
    // ray direction
    vec3 rd = ca * normalize( vec3(p.xy,1.0) );
    // render	
    vec3 col = render( ro, rd );
    
    return col;
}

// Function 952
vec2 sample_dist_smart(vec2 uv, float font_size) {
        
#ifdef HIGH_QUALITY
    const int nstep = 4;
    const float w[4] = float[4](1., 2., 2., 1.);
#else
    const int nstep = 3;
    const float w[3] = float[3](1., 2., 1.);
#endif
    
    vec2  dsum = vec2(0.);
    float wsum = 0.;
    
    for (int i=0; i<nstep; ++i) {
        
        float ui = float(i)/float(nstep-1);
                
        for (int j=0; j<nstep; ++j) {
            
            float uj = float(j)/float(nstep-1);
            
            vec2 delta = (-1.  + 2.*vec2(ui,uj))/TEX_RES;
            
            vec3 grad_dist = sample_grad_dist(uv-delta, font_size);
            vec2 pdelta = delta * GLYPHS_PER_UV * font_size;
            
            float dline = grad_dist.z + dot(grad_dist.xy, pdelta);
               
            float wij = w[i]*w[j];
            
            dsum += wij * vec2(dline, grad_dist.z);
            wsum += wij;

        }
    }
    
    return dsum / wsum;
    
}

// Function 953
float mapChain (vec3 p) {
    float scene = 1.;
    
    // number of chain
    float count = 21.;
    
    // size of chain
    vec2 size = vec2(.1,.02);
    
    // first set of chains
    float torus = sdTorus(posChain(p,count).yxz,size);
    scene = smin(scene, torus,.1);
    
    // second set of chains
    p.xz *= rot(PI/count);
    scene = min(scene, sdTorus(posChain(p,count).xyz,size));
    return scene;
}

// Function 954
float CubeSDF(vec3 p, vec3 s) {   
    vec3 d = abs(p) - s;   
    float insideDistance  = min(max(d.x, max(d.y, d.z)), 0.0);
    float outsideDistance = length(max(d, 0.0));   
    return insideDistance + outsideDistance;
}

// Function 955
float map(vec3 pos)
{
    vec2 d = vec2(2. + 0.55*sin(iTime*1.2), 0.); 
    float s1 = 1./pow(obj(pos + vec3(rotateVec(d, 0.), 0.)), 2.);
    float s2 = 1./pow(obj(pos + vec3(rotateVec(d, 2./3.*pi), 0.)), 2.);
    float s3 = 1./pow(obj(pos + vec3(rotateVec(d, 4./3.*pi), 0.)), 2.);
    return min(1. - (s1 + s2 + s3)*2., floorm(pos));
}

// Function 956
float remap  ( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

// Function 957
float sceneSDF(vec3 p,float anim) {
    p = p/scale;
    p += twist(p);
    float grass_scale = 20.0;
    float result = planet_surface(p,grass_scale);
    for(float i = 2.0; i < 4.0; i++){
    	grass_scale *= 1.5;
        result = min(result,planet_surface(p,grass_scale));
    }

    return min(result,length(p)-30000.0)*scale + length(p/4000.0);
}

// Function 958
float distanceToScene(vec3 cameraPos, vec3 rayDir, float start, float end, out int id) {
	
    //Start at a predefined distance from the camera in the ray direction
    float depth = start;
    
    //Variable that tracks the distance to the scene 
    //at the current ray endpoint
    float dist;
    
    //For a set number of steps
    for (int i = ZERO; i < MAX_STEPS; i++) {
        
        //Get the sdf value at the ray endpoint, giving the maximum 
        //safe distance we can travel in any direction without hitting a surface
        dist = getSDF(cameraPos + depth * rayDir, id);
        
        //If it is small enough, we have hit a surface
        //Return the depth that the ray travelled through the scene
        if (dist < EPSILON){
            return depth;
        }
        
        //Else, march the ray by the sdf value
        depth += dist;
        
        //Test if we have left the scene
        if (depth >= end){
            id = -1;
            return end;
        }
    }

    return depth;
}

// Function 959
SceneResult Scene_GetDistanceBulb( vec3 vPos )
{
    SceneResult result;
    
    result.fDist = BulbGlassDist( vPos );
    
    float fGlassThickness = 0.005;
    
    result.fDist = abs( result.fDist + fGlassThickness ) - fGlassThickness;
    
    result.vUVW = vec3(vPos);
    result.iObjectId = MAT_COLORLESS_GLASS;            

    return result;
}

// Function 960
float scene(vec2 p)
{
    return min(
        max(max(length(p-vec2(1,0))-.3,-length(p-vec2(.8,0))+.15),-abs(p.y)+.05),
        min(
            sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),
            sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))
       )
    );
}

// Function 961
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    CHECK_OBJ( objects[0] )
    CHECK_OBJ( objects[1] )
    CHECK_OBJ( objects[2] )
    CHECK_OBJ( objects[3] )
    CHECK_OBJ( objects[4] )
    CHECK_OBJ( objects[5] )
    CHECK_OBJ( objects[6] )
    CHECK_OBJ( objects[7] )
    
    return ( nearestDist < 1000.0 );
}

// Function 962
float water_map( vec2 p, float height )
{
	vec2 p2 = p*large_wavesize;
	vec2 shift1 = 0.001*vec2( time*160.0*2.0, time*120.0*2.0 );
	vec2 shift2 = 0.001*vec2( time*190.0*2.0, -time*130.0*2.0 );
	
	// coarse crossing 'ocean' waves...
	float f = 0.6000*seaNoise( p );
	
	f += 0.2500*seaNoise( p*m );
	f += 0.1666*seaNoise( p*m*m );
	
	float wave = sin(p2.x * 0.622 + p2.y * 0.622 + shift2.x * 4.269) * large_waveheight * f * height * height;
	
	p *= small_wavesize;
	f = 0.;
	
	float amp = 1.0, s = .5;
	
	for (int i=0; i<9; i++)
	{ 
		p = m*p*.947; 
		f -= amp*abs(sin((seaNoise( p+shift1*s )-.5)*2.));
		amp = amp*.59; s*=-1.329; 
	}
 
	return wave+f*small_waveheight;
}

// Function 963
float rayBisectDist(vec3 p, vec3 d, vec3 a, vec3 b)
{
    vec3 n = b - a;
    float D = length(n);
    float cosnd = dot(n, d)/D; //ray plane normal angle cosine
    float l = D*.5 - dot(p - a, n)/D;
    float t = l/cosnd; //ray parameter
    return (cosnd>0.)?t:1e10;
}

// Function 964
float distLine(vec2 p, vec2 a, vec2 b){
	vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
    return length(pa - ba*t);
}

// Function 965
float dist_circle(vec2 p, float r)
{
	return length(p) - r;
}

// Function 966
vec2 map(vec3 p, vec3 rd) {
	vec2 res = spin(p ,rd, 1.0);
	res = un(ground(p - vec3(0, 0, 0)), res);
 	return res;
}

// Function 967
float seaMap(const in vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        
    	d = seaOctave((uv+SEA_TIME)*freq,choppy);
    	d += seaOctave((uv-SEA_TIME)*freq,choppy);
        h += d * amp;        
    	uv *= sea_octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 968
ivec2 cross_distribution(int i)
{
    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );
}

// Function 969
float boxSDF( vec3 p, vec3 sizes ){
  vec3 q = abs(p) - sizes;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 970
vec3 depth_map(vec2 coord){
    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;
}

// Function 971
float map2(vec3 p, vec3 div) {
 
    #if USE_3D_VOLUME
    	float d = mapdist(p, div);
    #else
    	float d = map(p, time);
    #endif
    
    d=max(d, limit(p));
    d=smin(d, background(p), 0.2);
    return d;
}

// Function 972
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, bgCol;
  vec2 b, g;
  float dstGrnd, dstSheet, spec, rad, f, gRot, a;
  bool doRefl;
  bgCol = BgCol (ro, rd);
  dstSheet = (SheetSilHit (ro, rd) < dstFar) ? SheetRay (ro, rd) : dstFar;
  dstGrnd = GrndRay (ro, rd);
  if (min (dstGrnd, 1.01 * dstSheet) < dstFar) {
    doRefl = false;
    if (dstSheet < dstGrnd) {
      vn = SheetNf ();
      col = vec3 (0.9, 0.9, 1.);
      rad = 0.5 * float (nBallE - 1);
      b = Rot2D (qgHit - vec2 (rad), 0.75 * pi) / rad;
      a = atan (b.y, - b.x) / pi;
      if (abs (mod (6. * (a + 1.) + 0.5, 1.) - 0.5) < 0.03 &&
         abs (length (b) - 0.95) < 0.05 || abs (6. * a) < 0.03 &&
         abs (length (b) - 0.9) < 0.1) col = vec3 (0.1, 0.1, 1.);
      col = mix (vec3 (0.1, 0.1, 1.), col, 
         0.8 + 0.2 * SmoothBump (0.15, 0.85, 0.02, mod (rad * length (b), 1.)));
      col = mix (col, vec3 (0.1, 0.1, 1.), smoothstep (0.96, 0.97, length (b)));
      gRot = todCur * 2. * pi / (12. * 3600.);
      g = Rot2D (b, gRot - pi);
      g.x -= 0.25;
      f = length (max (abs (g) - vec2 (0.3, 0.02 * (0.6 - 0.4 * g.x / 0.3)), 0.));
      col = mix (col, vec3 (1., 1., 0.) * (1. - 0.4 * step (0.01, f)), step (f, 0.02));
      gRot *= 12.;
      g = Rot2D (b, gRot - pi);
      g.x -= 0.35;
      f = length (max (abs (g) - vec2 (0.4, 0.013 * (0.6 - 0.4 * g.x / 0.4)), 0.));
      col = mix (col, vec3 (0., 1., 0.) * (1. - 0.4 * step (0.01, f)), step (f, 0.02));
      gRot *= 60.;
      g = Rot2D (b, gRot - pi);
      g.x -= 0.4;
      f = length (max (abs (g) - vec2 (0.46, 0.007 * (0.6 - 0.4 * g.x / 0.46)), 0.));
      col = mix (col, vec3 (1., 0., 0.) * (1. - 0.4 * step (0.01, f)), step (f, 0.02));
      col = mix (vec3 (0.1, 0.1, 0.2), col, smoothstep (0.007, 0.013, length (b)));
      spec = 0.3;
      doRefl = true;
    } else if (dstGrnd < dstFar) {
      ro += dstGrnd * rd;
      vn = GrndNf (ro);
      f = 1. - clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.);
      vn = VaryNf (4. * ro, vn, 4. * f * f);
      col = 2. * mix (vec3 (0.2, 0.4, 0.), vec3 (0.1, 0.3, 0.), f) *
         (1. - 0.1 * Noisefv2 (64. * ro.xz));
      col *= (1. - 0.2 * SmoothBump (0.46, 0.54, 0.02, mod (1.5 * GrndHt (ro.xz), 1.))) *
         GrndAO (ro);
      spec = 0.;
    }
    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +
       spec * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);
    if (doRefl) col = mix (col, BgCol (ro, reflect (rd, vn)), 0.4);
    col = mix (col, bgCol, clamp (4. * min (dstSheet, dstGrnd) / dstFar - 3., 0., 1.));
  } else col = bgCol;
  return clamp (col, 0., 1.);
}

// Function 973
float GetDist(vec3 p){
    
    float g1 = sdGyroid(p, 10., .03, 1.);
    float g2 = sdGyroid(p, 10.76, .03, .3);
    float g3 = sdGyroid(p, 20.76, .03, .3);
    float g4 = sdGyroid(p, 35.76, .03, .3);
    float g5 = sdGyroid(p, 60.76, .03, .3);
    float g6 = sdGyroid(p, 110.76, .03, .3);
    g1 -= g2*.4;
    g1 -= g3*.3;
    g1 += g4*.2;
    g1 += g5*.2;
    g1 += g6*.3;
    vec2 uv = vec2(sin(p.x*4.)*.5+.5,cos(p.z*3.)*.5+.5);
    float disp = texture(iChannel0,uv).r;
    g1-=disp*.05*sin(iTime);
    float box = dBox(p, vec3(5));
    float d = max(g1,box);

    return d;
}

// Function 974
vec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, 
         const bool watchIntersect, const bool pencilIntersect ) {
    //--- table
    vec2 res = vec2(sdPlane(pos), MAT_TABLE);
    
    // chain
    if (pos.z > 1.1) {
        float h = smoothstep(3., -.4, pos.z)*.74 + .045;
        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;
        if (dChain0 < 0.1) {
            dChain0 = 10.;
            float pth1z = floor(pos.z*5.);
            if (pth1z > 5.) {
            	float pth21 = floor(pos.z*5.);
	            float pth1 = hash1(pth21);
    	        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);
        	    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));
            	dChain0 = sdTorus(pt1, vec2(.071, .02)); 
            }
            
            float pth2z = floor(pos.z*5. + .5);
            float pth2 = hash1(pth2z); 
            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);
            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));
            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          
        }
        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);
    }
    //--- pencil
    if (pencilIntersect) {
        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));
        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);
        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);
        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);
        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);

        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);
        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);
        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);
        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);

        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));
        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);
    }
    
    //--- watch
    if (watchIntersect) {
        float dDial = sdCylinder(p1, vec2(1.05,.13));
        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);

        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));
        if (dC < res.x) res = vec2(dC, MAT_METAL_1);
        
        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   
        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));
        if(bb < 0.5) {
            float a = atan(p1.y, p1.x);
            float c = abs(fract(a*3.1415)-.5);
            float d = min(abs(p1.z-1.3), .02);
            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));
        } 
        dM = opU(dM, bb);
         
        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));
        float rr = min(abs(p1.z-1.26), .2);
        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));
       
        p1.y = abs(p1.y);
        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));
        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));
        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);
        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));
        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));
        if (dM < res.x) res = vec2(dM, MAT_METAL_0);

        // minutes hand
        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);
        if (dMin < res.x) res = vec2(dMin, MAT_HAND);
        // hours hand
        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);
        if (dHour < res.x) res = vec2(dHour, MAT_HAND);
        // seconds hand
        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);
        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);
    }
    
    return res;
}

// Function 975
vec3 PBR_HDRremap(vec3 c)
{
    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);
    return mix(c,1.3*vec3(4.5,3.5,3.0),fHDR);
}

// Function 976
vec2 map( in vec3 pos )
{
    vec2 plane = vec2( sdPlane( pos), 1.0 ), res;
    
    res = opU( plane, sdBPTScene( pos ) );
        
    return res;
}

// Function 977
float torusKnotSqDistanceDerivative(float t, vec3 p, TorusKnotParameters tkp)
{
    return 2.*dot(torusKnot(t, tkp) - p, torusKnotDerivative(t, tkp));
}

// Function 978
vec2 map( vec3 pos )
{
    float t = iTime * 0.4;
    float tMod = fract( t );

    vec2 plane = vec2( abs( pos.y + 1.0 ), 0.0 );

    float pyramidSize = tMod * 1.16;
    vec2 pyramidBottom = sdPyramid( pos + vec3( 3.0, 1.0 - pyramidSize * 0.5, -2.0 ),
                              vec2( pyramidSize ) );
    vec2 pyramidTop = sdPyramid( pos + vec3( 3.0, 0.4 - pyramidSize * 1.7, -2.0 ),
                              vec2( 1.16 - pyramidSize ) );

    float wormOffset = tMod * -2.0;
    wormOffset += ( wormOffset <= -1.0 ) ? 2.0 : 0.0;
    wormOffset /= SQRT_2;
    vec3 wormPos = pos + vec3( 0.0 + wormOffset, 1.0, -4.0 + wormOffset );
    pR45( wormPos.xz );
    pR( wormPos.xy, tMod * TWO_PI );
    vec2 worm = sdWorm( wormPos, vec2( 1.0, 0.5 ) );

    vec3 pearlPos = pos - vec3( 3.0, 0.0, 2.0 );
    pR( pearlPos.xz, tMod * TWO_PI );
    vec2 pearl = sdPearl( pearlPos );

    float cloudSpeed = ( tMod * -8.0 ) * SQRT_2;
    vec3 cloudPos = pos - vec3( 4.0 + cloudSpeed, 3.0, 0.0 + cloudSpeed );
    pR45( cloudPos.xz );
    cloudPos.xz = opRep( cloudPos.xz, vec2( 8.0 ) , vec2( 0.0 ), vec2( 0.0 ) );
    vec2 cloud = sdCloud( cloudPos );

    vec2 res = opU( pyramidBottom,
               opU( pyramidTop,
               opU( worm,
               opU( pearl,
               opU( cloud, plane ) ) ) ) );

    vec2 cube = sdSmokingCube( pos, tMod, res.x );

    return opU( cube, res );
}

// Function 979
vec2 map(vec3 p)
{
    // results container
    vec2 res;    
    
    // define objects
    	// sphere 1
    	// sphere: radius, orbit radius, orbit speed, orbit offset, position
    float sR = 1.359997;
    float sOR = 2.666662;
    float sOS = 0.85;
    vec3 sOO = vec3(2.66662,0.0,0.0);
    vec3 sP = p - (sOO + vec3(sOR*cos(sOS*iTime),sOR*sin(sOS*iTime),0.0));
    vec2 sphere_1 = vec2( sdSphere(sP,sR), 1.0 );
		
    	//	torus 1    
    vec2 torusSpecs = vec2(1.6, 0.613333);
    float twistSpeed = 0.35;
    float twistPower = 5.0*sin(twistSpeed * iTime);
    	// to twist the torus (or any object), we actually distort p/space (domain) itself,
    	// this then gives us a distorted view of the object
    vec3 torusPos = vec3(0.0);
    vec3 distortedP = opTwist(p - torusPos, twistPower, 0.0) ;
        // 	domain distortion correction:
        // 	needed to find this by hand, inversely proportional to domain deformation
    float ddc = 0.25;
    vec2 torus_1 = vec2(ddc * sdTorus(distortedP, torusSpecs), 2.0);
    
    // combine and blend objects
    res = opU( sphere_1, torus_1 );
    res.x = opBlend( sphere_1.x, torus_1.x );    
    //res.x = torus_1.x;
    
    return res;
}

// Function 980
float scene(vec2 p) {
    
    float staticD = sdBox(p, tile(vec2(2.)),tile(vec2(2.)));
    
    staticD = opUnion(staticD, sdBox(p, tile(vec2(17., 3.)),tile(vec2(3.,1.))));
    staticD = opUnion(staticD, sdBox(p, tile(vec2(19., 1.)),tile(vec2(2.,3.))));
    
    //island
    staticD = opUnionRound(staticD, sdBox(p, mix(tile(vec2(5., 1.)),tile(vec2(16., 1.)),sin(iTime)/2.+0.5),tile(vec2(2.,1.))),float(REALTWIDTH));
    
    //globs
    staticD = opUnionRound(staticD, sdCircle(p, mix(tile(vec2(16., 3.)),tile(vec2(16., 7.)),sin(iTime)/2.+0.5), float(REALTWIDTH)), TWIDTH);
    staticD = opUnionRound(staticD, sdCircle(p, mix(tile(vec2(19., 2.)),tile(vec2(19., 7.)),cos(iTime)/2.+0.5), float(REALTWIDTH)), TWIDTH);
    
    staticD = opSubtract(staticD, sdCircle(p, iMouse.xy, TWIDTH*2.));
    
    return staticD;
}

// Function 981
float GetDistanceBox( const in vec3 vPos, const in vec3 vDimension )
{
	vec3 vDist = abs(vPos) - vDimension;
  	float fDistance =  min(max(vDist.x,max(vDist.y,vDist.z)),0.0) + length(max(vDist,0.0));

	return fDistance;	
}

// Function 982
void DrawScene(inout vec3 color, AppState s, vec2 p)
{
    vec2 mo = iMouse.xy/iResolution.xy;    
	   
    gBoxPos = vec3(8.0 * (s.playerCell + fract(2.0 * s.timeAccumulated)), 0.0, 0.0);
    
    float arm = mix(4.0, 8.0, s.paceScale );
    
	vec3 gOrig = gBoxPos;
   
#ifdef DEBUG
    gOrig += vec3(
        arm*cos(6.0*mo.x),
        0.0 + 4.0*mo.y,
        arm*sin(6.0*mo.x)
    );
#else
	vec3 gameOffset = vec3(
        arm*cos(1.0*3.14 + 0.1 * sin(0.5*iTime)),
        1.5 + 0.5 * s.paceScale,
        arm*sin(1.0*3.14 + 0.1 * sin(0.5*iTime))
    );
    vec3 failOffset = vec3(
        4.0*cos(0.1*iTime),
        1.5,
        4.0*sin(0.1*iTime)
    );
    
    gOrig += mix(
        gameOffset,
        mix(
            gameOffset,
            failOffset,
            smoothstep(0.0, 2.0, iTime - s.timeFailed)
        ),
        step(s.stateID, GS_SPLASH - 0.1)
    );

#endif
    
    gOrig.y += fbm3(100.0*gOrig) * 0.1 * s.paceScale;
    
    vec3 gLookat = gBoxPos + vec3( 0.0, 0.1, 0.0 );	
     
    mat3 ca = setCamera( gOrig, gLookat, 0.0);
    float fov = mix(2.2, 4.0, s.paceScale );
    vec3 dir = ca * normalize( vec3(vec2(p.x, p.y), fov) );
        
    MC hit = MR(gOrig, dir);
    
    vec3 shade = Shade(hit, dir, gOrig );
    vec3 bloom = SceneBloom();                
    color = 2.5 * shade + bloom;
    
    //particles
    float angle = atan(dir.z, dir.y)/(atan(iTime)-1.*1.*PI);
    angle -= floor(angle);
    float rad = length(vec2(dir.x * 0.02, dir.z));
 
    if (s.isFailed < 0.5)
    {
        float timeScale = mix(20.0, 50.0, s.paceScale);
        float dist3Scale = mix(100.0, 25.0, s.paceScale);
        float opacityScale = mix(0.2, 1.0, s.paceScale);

        float angleFract = fract(angle*10.5);
        float angleRnd = floor(angle*180.);
        float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);
        float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);
        float t = iTime*timeScale+angleRnd1*1000.;
        float radDist = sqrt(angleRnd2+.1);
        float adist = radDist/rad*.2;
        float dist = (t*.2+adist);
        dist = abs(fract(dist/20.)-.5);

        color += opacityScale * max(0.0,.7-dist*dist3Scale/adist)*(0.5-abs(angleFract-.5))*1./adist/radDist;        
    }
    
    // score counter text    
    if (s.isFailed < 0.5)
    {
        vec2 p1 = p;
        p1 *= 7.0;
        p1 -= vec2(-1.0, 5.5);
        p1 -= vec2(-0.5 * ceil(log2(s.score)/log2(10.0)), 0.0);
        p1 *= mix( 0.9, 1.0, abs(sin(2.0 * 3.14 * iTime)) * step(s.isFailed, 0.5) );
        color += PrintInt(p1, s.score);
    }
}

// Function 983
vec3 remap(vec3 co){
    // Remaps the given location to be within [-2,2] in x and [-1.1, 1.1] in y
    return vec3(
        mod(co.x-2.0,4.0)-2.0,
        mod(co.y-1.1,2.2)-1.1,
        co.z);
}

// Function 984
void RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
{
    // floor
    {
    	SMaterial material;
        material.diffuse = vec3(0.1f, 0.1f, 0.1f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.02f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), -5.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = intersectPos.xz;
                        
            uv = fract(uv / 75.0f);
            
            float dist = min(abs(uv.x - 0.5), abs(uv.y - 0.5));
            dist = step(dist, 0.005f);
                       
            float len2d = (cos(intersectPos.x * 0.01530f + intersectPos.y * 0.06320f) + 1.0f) / 2.5f;
            
            vec3 brightPurple = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f));
            brightPurple = mix(brightPurple, vec3(0.0625f, 0.0f, 1.0f), len2d);
            
            vec3 darkPurple = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));
            
            hitInfo.material.emissive = mix(darkPurple, brightPurple, dist);
            hitInfo.material.specular = mix(vec3(0.33f, 0.33f, 0.33f), vec3(0.0f, 0.0f, 0.0f), dist);
        }
    }
    
    // reflective balls
    {
    	SMaterial material;
        material.diffuse = vec3(0.5f, 0.5f, 0.5f);
        material.specular = vec3(1.0f, 1.0f, 1.0f);
        material.roughness = 0.035f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
    	TestSphereTrace(rayPos, rayDir, hitInfo, vec4(20.0f, 5.0f, -20.0f, 10.0f), material);
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-60.0f, 0.0f, 20.0f, 10.0f), material);
        
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 5.0f,  -65.0f, 10.0f), material);
        
        
        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(15.0f, -3.0f, 65.0f, 2.0f), material);
    }
    
    // Cylinders with mountain cutouts - draw front to back
    {
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo,  284.0f, 700.0f, 50.0f);
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1337.0f, 800.0f, 150.0f);
        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1932.0f, 900.0f, 250.0f);
	}
    
    // dark sun with gradient
    {
    	SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = vec3(0.0f, 0.0f, 0.0f);
        
        SRayHitInfo oldHitInfo = hitInfo;
        
    	if (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 0.0f, -1.0f)), -1000.0f), material))
        {
            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;
            vec2 uv = intersectPos.xy;
            
            int stripe = int((-uv.y + 500.0f) / 50.0f);
            if (stripe > 1)
                stripe = (stripe-1) % 2;
            else
                stripe = 0;
            
            if (length(uv) > 500.0f)
            {
                hitInfo = oldHitInfo;
            }
            else if (stripe == 1)
            {
                hitInfo.material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));
            }
            else
            {
                vec3 topColor = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f));
                vec3 bottomColor = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));

                float lerp = clamp((uv.y - 100.0f) / 400.0f, 0.0f, 1.0f);
                lerp = Bias(lerp, 0.05);
                hitInfo.material.emissive = mix(bottomColor, topColor, lerp);
            }
        }
    }
    
    // ringed planet
    {
        // planet
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.0f, 0.0f, 0.0f);
            if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 500.0f, -1200.0f, 200.0f), material))
            {
                // TODO: gradient: yellow to red, then red to purple?
                vec3 intersectPos = rayPos + rayDir * hitInfo.dist;

                float lerpTop = clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);
                float lerpMiddle = 1.0f - clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);
                float lerpBottom = clamp((intersectPos.y - 500.0f) / -200.0f, 0.0f, 1.0f);
                
                lerpTop = Bias(lerpTop, 0.1f);
                lerpMiddle = Bias(lerpMiddle, 0.9f);
                lerpBottom = Bias(lerpBottom, 0.1f);

                vec3 color = vec3(1.0f, 1.0f, 0.0f) * lerpTop;
                color += vec3(1.0f, 0.0f, 0.0f) * lerpMiddle;
                color += vec3(1.0f, 0.0f, 1.0f) * lerpBottom;

                hitInfo.material.emissive = color;
            }
        }
        
        // ring
        {
            SMaterial material;
            material.diffuse = vec3(0.0f, 0.0f, 0.0f);
            material.specular = vec3(0.0f, 0.0f, 0.0f);
            material.roughness = 0.0f;
            material.emissive = vec3(0.8f, 0.0f, 1.0f);// * 2.0f;// * 0.1f;

            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 300.0f, 10.0f, material);
            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 350.0f, 10.0f, material);
            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 375.0f, 10.0f, material);
        }
    }
    
    // sky dome
    {
    	SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));
    	if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 0.0f, 2000.0f), material))
        {
            const float c_skyStarCells = 45.0f;
            
            // convert the hit position to polar, but percentages from 0 to 1.
            // make the pole at the horizon to hide the distortion that would be in the sky otherwise.
            vec3 hitPos = (rayPos + rayDir * hitInfo.dist).yzx;
            float theta = (atan(hitPos.y, hitPos.x) + c_pi) / c_twopi;
            float phi = (atan(sqrt(hitPos.x*hitPos.x + hitPos.y*hitPos.y), hitPos.z) + c_pi) / c_twopi;

            // figure out what cell we are in and the offset in that cell
            vec2 cellIndex = vec2(floor(theta * c_skyStarCells), floor(phi * c_skyStarCells));
            vec2 cellUV = vec2(fract(theta * c_skyStarCells), fract(phi * c_skyStarCells));

            // make a star at a random place in the cell
            float starRadius = hash12(cellIndex) * 0.1f + 0.07f;
			vec2 starPos = hash22(cellIndex) * (1.0f - starRadius * 2.0f) + starRadius;
            float dist = sdStar(starPos - cellUV, starRadius, 4, 3.75f);
            
            dist *= pow(length(starPos - cellUV) / starRadius, 10.0f);
                       
            float value = step(dist, 0.0f);
			value *= pow(1.0f - clamp(length(starPos - cellUV) / starRadius, 0.0f, 1.0f), 3.0f);
                        
            hitInfo.material.emissive = mix(material.emissive, vec3(1.0f, 1.0f, 1.0f), value);            
        }
    }
}

// Function 985
float distanceEstimation(inout DistanceEstimation d) {
    ivec3 c = cell(d.p);
    float d2 = length(mod(d.p + 2.5, vec3(5.0)) - 2.5) - 1.0;
    if(length(vec3(c)) < 0.5) {
        d.l = length(d.p) - 1.0;
        d.s = normalize(d.p);
        vec3 S = abs(d.s);
        //float x = max(S.x, max(S.y, S.z));
        //S = d.s / x;
        vec2 uv = vec2(acos(S.z) / PI, atan(S.y, S.x) / PI2);
        //if(S.x > 0.999999)
        //    uv = (S.yz + 1.0) / 6.0;
        //if(S.x < -0.999999)
        //    uv = (-S.yz + 1.0) / 6.0 + vec2(0.0, 1.0 / 3.0);
        //if(S.y > 0.999999)
        //    uv = (S.zx + 1.0) / 6.0 + vec2(1.0 / 3.0, 0.0);
        //if(S.y < -0.999999)
        //    uv = (-S.zx + 1.0) / 6.0 + vec2(1.0 / 3.0, 1.0 / 3.0);
        //if(S.z > 0.999999)
        //    uv = (S.xy + 1.0) / 6.0 + vec2(2.0 / 3.0, 0.0);
        //if(S.z < -0.999999)
        //    uv = (-S.xy + 1.0) / 6.0 + vec2(2.0 / 3.0, 1.0 / 3.0);
        //float displacement = fbm(uv) * 0.5;
        float displacement = bicubic(uv);
        displacement *= 0.0625;
        displacement *= 0.5;
        //displacement *= 4.0;
        //displacement *= 0.0;
        d.s *= 1.0 + displacement;
        d.l -= displacement;
        d.m = MAIN_MAT;
        return d.l;
    }
    else {
        vec3 C = vec3(c) * CELL_WIDTH;
        d.l = length(d.p - C);
        d.s = normalize(d.p - C) + C;
        d.l = d2;
        d.s = normalize(d.p) + d.p - mod(d.p + 2.5, vec3(5.0)) - 2.5;
        d.m = SPHERE_MAT;
        return d.l;
    }
}

// Function 986
vec2 map_flame(vec3 p)
{
    const float scale = 1.;
    p *= 1./scale;

    p.z += 6.;
    
    float loop = g_entities.flame.loop;
    float angle_jitter = hash(g_entities.flame.loop) * 360.;

    vec3 ofs = vec3(-.5, -.5, 0);
    vec3 p1 = rotate(p, angle_jitter + p.z * (360./16.)) + ofs;
    float dist = sdf_cone(p1, 2.5, 16.);

    ofs = vec3(-1, -1, -2);
    p1 = rotate(p, angle_jitter + 180. - p.z * (360./32.)) + ofs;
    dist = sdf_smin(dist, sdf_cone(p1, 1.75, 10.), 1.);
    
    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 4), 2.5, 1.), 3.);

    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));
    p1 = vec3(loop_rotation * p.xy, p.z - 2.);
    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2,  2, mix(8., 20., loop)), .25));
    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2,  1, mix(12., 22., fract(loop + .3))), .25));
    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1, -2, mix(10., 16., fract(loop + .6))), .25));

    return vec2(dist*scale, MATERIAL_FLAME);
}

// Function 987
float sdFibonacciHemisphere(vec3 p) {
    float d = sqdFibonacciPoint(p, NUM_SAMPLES, 0);
    for (int i = 1; i < NUM_SAMPLES; ++i) {
        d = min(d,sqdFibonacciPoint(p, NUM_SAMPLES, i));
    }
    
    d = sqrt(d) - 1.0;
	return max(d, -p.z);    
}

// Function 988
vec3 renderScene(vec3 camPos, vec3 camDir) 
{                                
    Shading shading = intersect(camPos, camDir);
    
    float reflectMultiplier = fresnelAmount(REFRACTIVE_INDEX_OUTSIDE, shading.refractiveIndex,
                                            shading.intersection.normal, camDir);
    float refractMultiplier = 1.0 - reflectMultiplier;
  
    // Get the reflected color
    vec3 reflectedCol = vec3(0.0);
    if (shading.mirror)
    {
        vec3 reflectDir = reflect(camDir, shading.intersection.normal);
        Shading reflected = intersect(shading.intersection.position + reflectDir*0.01, reflectDir);
        reflectedCol = reflected.color * reflectMultiplier;
    }
    
    // If the object isn't transparent return, otherwise bounce the reflected ray inside
    // the box to get the refracted color.
    if (!shading.transparent) 
        return shading.color + reflectedCol;
    
    vec3 refractedCol = getInternalColor(shading.intersection.position, shading.intersection.normal,
                                         camDir, shading.refractiveIndex, shading.absorbance);
    refractedCol *= refractMultiplier;
   
   return shading.color + reflectedCol + refractedCol;
}

// Function 989
float lineDistance(vec2 a, vec2 b, vec2 p) {
    vec2 pa = p-a;
    vec2 ba = b-a;
	float t = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);
    return length(pa-ba*t);
}

// Function 990
float distanceEstimation(vec3 pos) {
	vec3 diffuseColor, emissionColor;
	return distanceEstimation(pos, diffuseColor, emissionColor);
}

// Function 991
vec4 planeDistance(vec3 pos, vec3 center, vec3 normal) {
    vec3 delta = pos - center;
    float dist = dot(delta, normal);
    vec3 surface = pos - normal * dist;
    return vec4(surface, dist);
}

// Function 992
float PommelCarve_SDF(in vec3 p, in vec3 c)
{
    vec2 q = vec2( length(p.xz), p.y );
    
    float d1 = -q.y-c.z;
    float d2 = max( dot(q,c.xy), q.y);
    
    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);
}

// Function 993
float dist( in vec3 p )
{
    float r = baseTunnel(p);
    r = min(r,ceiling(p));
    r = max(r,-windowCutouts(p));
    r = max(r,-windowScallops(p));
    r = min(r,cauldrons(p));
    r = min(r,windowPanes(p));
    r = min(r,yourPathEndsHere(p));
    return min(r,candles(p));
}

// Function 994
float DistanceField( vec3 p )
{
	return DistanceField( p, 0.0 );
}

// Function 995
float map(vec3 p, inout int matID, vec3 playerPos, bool drawPlayer, bool drawRefractive) {
    float res = FLT_MAX;
    
#if (SCENE == 0) || (SCENE > 3)
    // spheres
    vec3 cen = vec3(0.0, 1.5, 0.0);
    vec3 d = 0.5*normalize(vec3(1.0, 0, -1.0));
    vec3 s = 0.4*vec3(0.0, sin(iTime), 0.0);
    vec3 c = 0.4*vec3(0.0, cos(iTime), 0.0);
    float disp = 0.03*sin(20.0*p.x+iTime)*sin(40.0*p.y+iTime)*sin(60.0*p.z+iTime);
    disp *= (1.0 - smoothstep(-0.25, 0.25, cos(iTime/2.0)));
    propose(res, matID, sphere(p-cen, 0.3)+disp, 3);
    propose(res, matID, sphere(p-(cen+d.xyx+s), 0.15), 1);
    propose(res, matID, sphere(p-(cen+d.xyz+c), 0.15), 1);
    propose(res, matID, sphere(p-(cen+0.5*(-s.yxy)+0.5*vec3(0.0,1.0,0.0)), 0.15), 1);
    
    // refractive spheres
    if (drawRefractive) {
        propose(res, matID, sphere(p-(cen+d.zyz-s), 0.15), 2);
    	propose(res, matID, sphere(p-(cen+d.zyx-c), 0.15), 2);
    	propose(res, matID, sphere(p-(cen+0.5*(s.yxy)+0.5*vec3(0.0,-1.0,0.0)), 0.15), 2);
    }
    
    // reflective cylinder
    propose(res, matID, cylinder(p-vec3(0), 4.0, .15), 1);

#elif (SCENE == 1)
    //temple    
    float pillars = intersectionDist(cylinder(p-vec3(-50.0, 2.5, 0.0), 8.0, 2.5),
                                     cylinder(repeat(p-vec3(0.0,2.5,0.0), vec3(5,0,5)), 0.25, 2.5));    
    float temple = subtractionDist(sphere(p-vec3(-50.0, 0.0, 0.0), 10.0),
                                   cylinder(p-vec3(-50.0, 2.3, 0.0), 11.0, 2.5));
    propose(res, matID, blend(pillars, temple, 1.4), 6); 

#elif (SCENE == 2)
    if (drawRefractive) {
        // blob arm        
        float arm = cylinder(p-vec3(-50.0, 0.201, 0.0), 5.0, 0.1);
        for (int i = 0; i < 11; i++) {
            arm = blend(arm, sphere(p-vec3(-50.0+4.0*float(i)/10.0*cos(float(i+1)+iTime), i+1,
                                           4.0*float(i)/10.0*sin(float(i+1)+iTime)),
                                    float(10-i)/20.0 + 0.1), 1.0-float(i)/15.0);
        }
        propose(res, matID, arm, 2);
    }
    
#elif (SCENE == 3)
    // HORSE
    float blendStep = step(texture(iChannel1, vec2(KEY_H, 0.25)).x, 0.5);
    
    float foot1 = roundedBox(rY(p-vec3(0.0,0.249,0.0), -45.0), vec3(0.11,0.09,0.12), 0.05);
    float ankle1 = cylinder(rX(rY(p-vec3(-0.15,0.75,-0.15), -50.0), 15.0), 0.09, 0.4);
    float leg1 = cylinder(rX(rY(p-vec3(-0.05,1.65,0.03), 145.0), 35.0), 0.12, 0.6);
    float thigh1 = cylinder(rX(rY(p-vec3(-0.05,2.35,0.13), 75.0), -25.0), 0.3, 0.4);
    float fullleg1 = blend(foot1, ankle1, 0.5*blendStep);
    fullleg1 = blend(fullleg1, leg1, 0.5*blendStep);
    fullleg1 = blend(fullleg1, thigh1, 0.7*blendStep);
     
    float foot2 = roundedBox(rY(p-vec3(0.0-1.5,0.249,0.0+2.0), -25.0), vec3(0.11,0.09,0.12), 0.05);
    float ankle2 = cylinder(rX(rY(p-vec3(-0.15-1.5,0.69,-0.35+2.0), -20.0), 35.0), 0.09, 0.4);
    float leg2 = cylinder(rX(rY(p-vec3(-0.05-1.5,1.59,-0.37+2.0), 145.0), 45.0), 0.12, 0.6);
    float thigh2 = cylinder(rX(rY(p-vec3(-0.05-1.5,2.29,-0.27+2.0), -180.0), -25.0), 0.3, 0.4);
    float fullleg2 = blend(foot2, ankle2, 0.5*blendStep);
    fullleg2 = blend(fullleg2, leg2, 0.5*blendStep);
    fullleg2 = blend(fullleg2, thigh2, 0.7*blendStep);
    
    float bod = cylinder(rX(rY(p-vec3(-0.15-0.25,3.5,-0.35+1.75), -40.0), -45.0), 0.7, 1.0);
    float lowerhalf = blend(fullleg1, bod, 1.3*blendStep);
    lowerhalf = blend(lowerhalf, fullleg2, 1.3*blendStep);
    
    float bod2 = cylinder(rX(rY(p-vec3(-0.4+0.7,5.0,1.4+0.8), -40.0), -10.0), 0.5, 0.8);
    float lowerhalf2 = blend(lowerhalf, bod2, 1.4*blendStep);
    
    float uparm1 = cylinder(rX(rY(p-vec3(-0.05+1.5,4.9,0.53+1.3), 115.0), 70.0), 0.12, 0.75);
    float wrist1 = cylinder(rX(rY(p-vec3(-0.05+2.2,4.45,0.53+1.7), 115.0), -10.0), 0.1, 0.6);
    float hand1 = roundedBox(rX(rY(p-vec3(-0.05+2.15,3.95,0.53+1.65), 115.0), 80.0), vec3(0.11,0.09,0.12), 0.05);    
    float lowerhalf3 = blend(uparm1, lowerhalf2, 1.3*blendStep);
    lowerhalf3 = blend(lowerhalf3, wrist1, 0.5*blendStep);
    lowerhalf3 = blend(lowerhalf3, hand1, 0.4*blendStep);
    
    float uparm2 = cylinder(rX(rY(p-vec3(-0.05,4.9,0.53+2.8), -25.0), -70.0), 0.12, 0.75);
    float wrist2 = cylinder(rX(rY(p-vec3(-0.05+0.3,4.45,0.53+3.5), -25.0), 10.0), 0.1, 0.6);
    float hand2 = roundedBox(rX(rY(p-vec3(-0.05+0.25,3.95,0.53+3.45), -25.0), -80.0), vec3(0.11,0.09,0.12), 0.05);
    lowerhalf3 = blend(uparm2, lowerhalf3, 1.3*blendStep);
    lowerhalf3 = blend(lowerhalf3, wrist2, 0.5*blendStep);
    lowerhalf3 = blend(lowerhalf3, hand2, 0.4*blendStep);
    
    float neck = cylinder(rX(rY(p-vec3(-0.4+0.7,6.3,1.4+0.8), -40.0), 5.0), 0.4, 0.6);
    lowerhalf3 = blend(neck, lowerhalf3, 0.7*blendStep);
    
    float head = roundedBox(rX(rY(p-vec3(-0.4+1.1,7.2,1.4+1.2), -40.0), -15.0), vec3(0.2,0.2,0.65), 0.2);
    float horse = blend(head, lowerhalf3, 0.7*blendStep);
    
    float tail = cylinder(rX(rY(p-vec3(-0.15-1.25,3.5,-0.35+0.75), -40.0), 45.0), 0.15, 0.8);
    
    propose(res, matID, blend(horse, tail, 0.5*blendStep), 1);

#endif

    // ground plane
    propose(res, matID, plane(p-vec3(0.0,-1.0,0.0)), 4);
    
    // rounded box grid    
    vec3 v = repeat(p, vec3(GRID_SIZE,0.0,GRID_SIZE));
    vec3 f = p - v;
    float h = 30.0*perlinNoise2D(f.xz, 0.01, 1.0, 2, 37);
    h *= clamp(exp((dot(f.xz,f.xz) - 102.0*102.0)/20000.0)-1.0, 0.0, 1.0);
	propose(res, matID, roundedBox(v, vec3(0.7*GRID_SIZE/2.0,max(0.0, h),0.7*GRID_SIZE/2.0), 0.1), 4);
    
    // player
    if (drawPlayer) {
        propose(res, matID, sphere(p-playerPos, 0.25), 5);
    }
    
    return res;
}

// Function 996
vec3 SceneNormal( in vec3 pos, mat3 localToWorld )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor = vec3(
	    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),
	    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),
	    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );
	return normalize( -nor );
}

// Function 997
bool raytraceScene(in Ray ray, out vec3 position, out vec3 normal, out Material mat)
{
    float t;
    bool intersected = false;
    
    float tmpT; 
    vec3 tmpPos, tmpNorm;
    
    if (intersectsQuad(ray, lightQuad, tmpT, tmpPos, tmpNorm)) {
        t = tmpT;
        position = tmpPos;
        normal = tmpNorm;
        mat = materials[0];
        intersected = true;
    }
    
    for (int i = 0; i < INF_PLANES_NB; i++) {
        if (intersectsInfinitePlane(ray, boxPlanes[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {
        	t = tmpT;
        	position = tmpPos;
        	normal = tmpNorm;
        	mat = materials[i + 1];
        	intersected = true;
    	}
    }
    
    if (max(max(abs(position.x), abs(position.y)), abs(position.z)) > 2.0 + 0.001) 
        return false;
    
    for (int i = 0; i < SPHERES_NB; i++) {
        if (intersectsSphere(ray, spheres[i], tmpT, tmpPos, tmpNorm) && !(intersected && tmpT >= t)) {
        	t = tmpT;
        	position = tmpPos;
        	normal = tmpNorm;
        	mat = materials[i + INF_PLANES_NB + 1];
        	intersected = true;
    	}
    }
    
    return intersected;
}

// Function 998
float distCylinderBump( vec3 pos, vec3 properties, sampler2D image, float scale)
{
	// Add in a bit of positional variation.
	pos.xz += sin(pos.zx)*.25;
	
	// Mod the position along the XZ plane for repetition.
	pos.xz = mod(pos.xz,TREE_REP.xz);
	
	// Bring the location back to the center of the modded domain.
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	// Create a variable to store potential bump.
	float bump = 0.0;
	
	// Find the distance from the point to the object
	// accounting for minimum bump height.
	float dist = length(pos.xz-properties.xy)-properties.z;
	
	// If it's less than the maximum bump height we need to figure
	// out the specific distance to the object including proper bump.
	if(dist < FEATURE_BUMP_FACTOR*2.0)
	{
		// Get a general okay flat-surface normal.
		vec2 normal = normalize(pos.xz-properties.xy);
		
		// Get the bumpheight by sampling the red channel of a texture.
		bump = tex3D(pos*scale+pos, vec3(normal.x, 0.0, normal.y), image).r*FEATURE_BUMP_FACTOR;
	}
	return dist-bump;
}

// Function 999
RayHit RaymarchScene(in Ray ray)
{
    RayHit hit;
    
    hit.hit      = false;
    hit.material = 0.0;
    
    float sdf   = FarClip;
    int   steps = 0;
    
    for(float depth = NearClip; (depth < FarClip) && (steps < MarchSteps); ++steps)
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf < Epsilon)
        {
            hit.hit      = true;
            hit.surfPos  = pos;
            hit.surfNorm = Scene_Normal(pos);
            
            return hit;
        }
        
        depth += sdf;
    }
    
    return hit;
}

// Function 1000
Model map(vec3 p) {
    pR(p.xy, .39 * PI * 2. + time * PI * 2. * 2./3.);

    float scale = focalLength;
    p *= scale;
    Model model = fModel(p);
    model.dist /= scale;
    return model;
}

// Function 1001
void Entity_MapSpawn( inout Entity entity, int iSpawnIndex )
{   
    Entity_Clear( entity );
    
    vec4 vData0 = ReadMapData( MAP_CHANNEL, ivec2(128, iSpawnIndex) );
    vec4 vData1 = ReadMapData( MAP_CHANNEL, ivec2(129, iSpawnIndex) );
    
    if ( dot(vData0.zw, vData0.zw) > 0.0 )
    {
        entity.iType = int(vData0.x);
        entity.iSubType = int(vData0.y);
        entity.vPos.xz = vData0.zw;
        entity.vPos.y = 0.0;
        entity.fYaw = radians( 90. - vData1.x );

        entity.iSectorId = Map_SeekSector( MAP_CHANNEL, g_mapInfo, entity.vPos.xz );    

        Sector sector = Map_ReadSector( MAP_CHANNEL, entity.iSectorId );

        entity.vPos.y = sector.fFloorHeight;
        
        if ( entity.iType == ENTITY_TYPE_PLAYER )
        {
            entity.fHealth = 100.0;
        }
        if ( entity.iType == ENTITY_TYPE_ENEMY )
        {
            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )
            {
	            entity.fHealth = 20.0;
            }
            else
            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )
            {
	            entity.fHealth = 30.0;
            }
            else
            if ( entity.iSubType == ENTITY_SUB_TYPE_ENEMY_IMP )
            {
	            entity.fHealth = 60.0;
            }
        }
        if ( entity.iType == ENTITY_TYPE_BARREL )
        {
            entity.fHealth = 20.0;
        }        
        if ( entity.iType == ENTITY_TYPE_DOOR )
        {        
	        entity.fTarget = sector.fFloorHeight;
        }
        if ( entity.iType == ENTITY_TYPE_PLATFORM )
        {        
            entity.vPos.y = sector.fFloorHeight;
            entity.vPos.xz = vData1.zw; // trigger location
	        entity.fTarget = sector.fFloorHeight;
        }
    }
    else
    {
        entity.iType = ENTITY_TYPE_NONE;
    }
}

// Function 1002
float heightMap( vec3 pos ) {
	float n = noise( vec2(0.0,4.2)+pos.xz*0.14 );
	return 9.*(n-0.7);
}

// Function 1003
vec3 PBR_HDRremap(vec3 c)
{
    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);
    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);
    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);
    return mix(cRedSky,cBlueSky,SKY_COLOR);
}

// Function 1004
vec2 barrelDistortion(vec2 uv, float k)
{
  float rd = length(uv);    
  float ru = rd * (1.0 + k * rd * rd);
  uv /= rd;
  uv *= ru;
  return uv;
}

// Function 1005
float remap( float x, float a, float b ) { return clamp( ( x - a ) / ( b - a ), 0., 1. ); }

// Function 1006
float dist(vec3 pos) {
	//pos = mod(pos, 50.);
    float t = time();
    return _dist(pos, t);
}

// Function 1007
float sceneDist(in Ray ray) {
    // Rotate the cube by rotating the ray...
    ray.origin.xy = R(ray.origin.xy, iTime * 0.55);
    ray.origin.xz = R(ray.origin.xz, iTime * 0.34);
    
    // A box, a smaller box, and a sphere...
    Box b0 = Box(vec3(0, 0, 0), vec3(4), 0.4);
    Box b1 = Box(vec3(0, 0, 0), vec3(3), 0.3);
    Sphere s0 = Sphere(vec3(0, 0, 0), 1.3);
    
    // get the distance to each
    float distToB0 = boxDist(ray, b0);
    float distToB1 = boxDist(ray, b1);
 	float distToS0 = sphereDist(ray, s0);
    
    //Find the neares of the sphere, and box0 minus box1.
    return min(max(distToB0, -distToB1), distToS0);
}

// Function 1008
float orig_cyl_sdf(in highp vec3 point) {
    vec3 cyl_dir =
        vec3(sin(iTime) * cos(3.3 * iTime),
             sin(3.3*iTime),
             cos(iTime) * cos(3.3 * iTime));
	vec3 rel = point - cyl_center;
    float along = dot(rel, cyl_dir);
    vec3 across = rel - cyl_dir * along;
    return length(max(vec2(length(across) - cyl_rad + curve_rad,
                  	       abs(along) - 0.5 * cyl_length + curve_rad),
                     0.0)) - curve_rad;
}

// Function 1009
float map_candle(vec3 pos)
{
    #ifdef show_candle
    pos = rotateVec2(pos);
    pos.y+= 0.644;
    float rc = sdTorus82(pos, vec2(0.23, 0.27));
    float cs = length(pos*vec3(1. + burnPos*0.4, 1., 1. + burnPos*0.4) - vec3(0., 0.65 - burnPos, 0.)) - 0.45;
    float df = SoftMaximum(rc, -cs, 150.);
    
    df+= 0.011*noise(pos*6.);
    df+= 0.0004*noise(pos*70.)*smoothstep(0.25, 0.3, length(pos.xz));
    
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    return df;
    #else
    return 10.;
    #endif   
}

// Function 1010
float GetDistanceToNearestSurface(vec3 point)
{
    float distanceToSphere = length(point-SPHERE_POSITION)-SPHERE_RADIUS;
    float distanceToPlane = point.y - PLANE_POSITION_Y;
    float distanceToNearestSurface = min(distanceToSphere, distanceToPlane);
    return distanceToNearestSurface;
}

// Function 1011
vec3 sampleEnvMap(vec3 rd, float lod)
{
    vec2 uv = vec2(atan(rd.z,rd.x),acos(rd.y));
    uv = fract(uv/vec2(2.0*PI,PI));
    
    vec3 col = vec3(0.,0.05*cos(uv.x)+0.05, .1*sin(uv.y)+.1)*1.;
    
    float r = (1.-pow(lod,.5))*1000.+5.;
    col += vec3(1.)* clamp( pow(1.-roundBox(uv-vec2(.5), vec2(.05,.05),.01),r), 0., 1.);
    col += vec3(1.)* clamp( pow(1.-roundBox(uv-vec2(.67,.5), vec2(.05,.05),.01),r), 0., 1.);
    col += vec3(1.)* clamp( pow(1.-roundBox(uv-vec2(.67,.67), vec2(.05,.05),.01),r), 0., 1.);
    col += vec3(1.)* clamp( pow(1.-roundBox(uv-vec2(.5,.67), vec2(.05,.05),.01),r), 0., 1.);
    col += vec3(1.,.5,.1)*2. * clamp( pow(1.-roundBox(uv-vec2(.3,.7), vec2(.01,.01),.2),r), 0., 1.);
    
    return min(col*(1.-lod*.8),vec3(1.));
}

// Function 1012
vec4 map(vec3 pos, out float k) {
  vec4 p4 = iproj(pos,k);
  if (dorotate4) {
  	p4 = qmul(ql,p4);
  	p4 = qmul(p4,qr);
  }
  p4 = fold(p4);
  return p4;
}

// Function 1013
DF_out map( in vec3 pos )
{
    float dist = opU( sdPlane(     pos-vec3( -1.4) ),
	                sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ) );
    dist = opU( dist, udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ) );
	dist = opU( dist, sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ) );
	dist = opU( dist, sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ) );
	dist = opU( dist, sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.10,0.20) ) );
	dist = opU( dist, sdTorus88(   pos-vec3(-1.0,0.25, 1.0), vec2(0.20,0.05) ) );
    dist = opU( dist, opSmoothSubtract(
	                      udRoundBox(  pos-vec3(-1.0,0.2, 0.0), vec3(0.15),0.05),
	                      sdSphere(    pos-vec3(-1.0,0.2, 0.0), 0.25)) );
    dist = opU( dist, sdBox(       pos-vec3( 0.0,0.20,-1.0), vec3(0.25)) );
	dist = opU( dist, 0.5*sdTorus( opTwist(pos-vec3( 1.0,0.25, 0.0)),vec2(0.15,0.02)) );

    DF_out outData;
    outData.d = dist-ISOVALUE;
    outData.matID = MATERIALID_ICE_OUTER;
    return outData;
}

// Function 1014
vec3 doBumpMap( in vec3 pos, in vec3 nor )
    {
        float e = 0.0015;
        float b = 0.1;
        
        float ref = fbm( pos, nor );
        vec3 gra = b*vec3( fbm( vec3(pos.x+e, pos.y, pos.z),nor)-ref,
                            fbm( vec3(pos.x, pos.y+e, pos.z),nor)-ref,
                            fbm( vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;
        
        vec3 tgrad = gra - nor * dot ( nor , gra );
        return normalize ( nor - tgrad );
    }

// Function 1015
float glyph_dist(in vec2 pt) {
	float angle = atan(pt.y, pt.x)- spin0* 2.0* PI;
	return glyph_dist2(pt, angle);
}

// Function 1016
vec3 Tonemap(vec3 color)
{
    #if TONEMAP_TYPE == LINEAR_TONEMAP
    color *= vec3(TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP
    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == REINHARD_TONEMAP
    color *= TONEMAP_EXPOSURE;
    color = color / (1.0 + color);
    #endif
    #if TONEMAP_TYPE == REINHARD2_TONEMAP
    color *= TONEMAP_EXPOSURE;
    color = (color * (1.0 + color / (LDR_WHITE * LDR_WHITE))) / (1.0 + color);
    #endif
    #if TONEMAP_TYPE == FILMIC_HEJL2015
    color *= TONEMAP_EXPOSURE;
    color = linearTo_sRGB(ToneMapFilmic_Hejl2015(TONEMAP_EXPOSURE_BIAS * color));
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2    
    color *= TONEMAP_EXPOSURE;
    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);
    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));
    color = tonemapedColor * whiteScale;
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP_ACES
    color *= TONEMAP_EXPOSURE;
    vec3 tonemapedColor = TonemapACESFilm(TONEMAP_EXPOSURE_BIAS * color);
    vec3 whiteScale = 1.0 / TonemapACESFilm(vec3(W));
    color = tonemapedColor * whiteScale;
    #endif
   
    return color;
}

// Function 1017
SceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )
{	
    SceneResult result;
    result.fDist = 0.0;
    result.vUVW = vec3(0.0);
    result.iObjectId = -1;
    
	float t = minDist;
	const int kRaymarchMaxIter = 128;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
        float epsilon = 0.0001 * t;
		result = Scene_GetDistance( vRayOrigin + vRayDir * t );
        if ( abs(result.fDist) < epsilon )
		{
			break;
		}
                        
        if ( t > maxDist )
        {
            result.iObjectId = -1;
	        t = maxDist;
            break;
        }       
        
        if ( result.fDist > 1.0 )
        {
            result.iObjectId = -1;            
        }    
        
        t += result.fDist;        
	}
    
    result.fDist = t;


    return result;
}

// Function 1018
vec2 mapHead( vec3 p )
{
    p.x = abs(p.x);
    
    vec3 q = p;
	q.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);
	q.y *= 1.05;
	q.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );
    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );
	float am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );
	float fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;
    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );
	float am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );
	float fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;
    q.y += -0.05+0.05*length(q.x);
	
    float sco = 0.45;// scale du pourtour de l'oeil
	float d1 = length( q ) - 0.9 + fo*sco + fo2*sco;// le body
    vec2 res = vec2( d1, 1.);

    // eyes - oeil
	float d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;
    res.x = smin(res.x, d3, 0.01); // smooth entre l'oeil et le pourtour
    
	// mouth - bouche (four)
	float mo = length( (q-vec3(0.0,-0.35,1.))*vec3(1.0,1.2,0.25)/1.2 ) -0.3/1.2;
	float of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);
	mo = max( mo, -q.y-0.35-of );

	float li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );
	res.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );
	
    if( -mo > res.x ) res = vec2( -mo, 0.5 );

    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));

    // teeth - dents
	if( p.x<0.3 )
	{
        p.x = mod( p.x, 0.16 )-0.08;	
        float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;
        res.x = smin(res.x, d5, 0.02); // smooth entre l'oeil et le pourtour
    }
	
    // fond de mouth
    float d2 = length( q ) - 0.8;
    res.x = smin(res.x, d2, 0.16);
    
	return res.xy;
}

// Function 1019
float sdf_sphere(vec3 pXp0, float radius)
{
    return (length(pXp0) - (radius));
}

// Function 1020
float distEllipsoid(vec3 p, vec3 r){
    float lg = length(p /(r * r));
	return (length(p / r) - 1.) * (length(p / r)) / lg;
}

// Function 1021
vec2 scene(vec3 p) {
    return box(p,vec3(.5,.5,.5),.5);
}

// Function 1022
float LineDist(vec3 a, vec3 b, vec3 p) {
	return length(cross(b-a, p-a))/length(p-a);
}

// Function 1023
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, c;
  vec2 q, fq, dq;
  float dstObj;
  int hInd;
  bool s;
  gSize = 8;  //(4,8,16,32)
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    col = vec3 (1., 0.8, 0.2);
    if (vn.y > 0.1) {
      if (ro.y < 0.01) col *= 0.5;
      q = float (gSize) * (0.5 * ro.xz + 0.5);
      fq = floor (q);
      dq = q - fq - 0.5;
      if (length (dq) < 0.28) {
        hInd = HilXy2D (ivec2 (fq), gSize);
        s = (floor (mod (2. * tCur, float (gSize * gSize))) == float (hInd));
        col = mix ((s ? vec3 (0.3, 0.7, 1.) : col), (s ? vec3 (0.) : vec3 (0., 0.7, 0.)),
           smoothstep (0.05, 0.1, ShowInt (dq - vec2 (((gSize < 16) ? 0.1 : 0.2), -0.1),
           (s ? 1.1 : 1.) * vec2 (0.5, 0.2), 4., float (hInd + 1))));
      }
    }
    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +
       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
  } else {
    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));
  }
  return clamp (col, 0., 1.);
}

// Function 1024
sdv scene(highp vec3 p)
{
    sdv sphere;
    sphere.idx = IDX_SPHERE;

	vec3 c = vec3(0.0,0.0,0.0);
	float r = 24.0 + 0.5*(sin(0.05*p.x*p.y+iTime*5.0));
	sphere.d = length(p-c) - r;
	
    return sphere;
}

// Function 1025
float sdf(in vec3 pos) {
	float t = 1000.0;
	vec3 offset = vec3(-24, 4, 0);
	t = min(t, sdf_C(pos, vec3(0, 0, 0) + offset));
	t = min(t, sdf_o(pos, vec3(6, 0, 0) + offset));
	t = min(t, sdf_b(pos, vec3(12, 0, 0) + offset));
	t = min(t, sdf_a(pos, vec3(18, 0, 0) + offset));
	t = min(t, sdf_l(pos, vec3(24, 0, 0) + offset));
	t = min(t, sdf_t(pos, vec3(26, 0, 0) + offset));
	t = min(t, sdf_X(pos, vec3(32, 0, 0) + offset));
	t = min(t, sdf_I(pos, vec3(38, 0, 0) + offset));
	t = min(t, sdf_I(pos, vec3(44, 0, 0) + offset));
	return t;
}

// Function 1026
float dist(vec3 pos)
{
    return fract(iTime*.1)<.5?distCar(pos):distTor(pos);
}

// Function 1027
float SphereSDF(vec3 point, float rad) {
    return length(point) - rad;
}

// Function 1028
float waterHeightMap( vec2 pos, float time ) {
	vec2 posm = 0.01*pos * m2;
	posm.x += 0.001*time;
	float f = fbm( vec3( posm*1.9, time*0.01 ));
	float height = 0.5+0.1*f;
	height += 0.05*sin( posm.x*6.0 + 10.0*f );
	
	float h1 = 1.*mapTerrain( vec3(pos.x, -2.0, pos.y ) );
	float h2 = 1.*mapTerrain( vec3(pos.x, -1.5, pos.y ) );
	float h = min(h1,h2);
	height += 0.25*sin( 4.*h-(time+0.8*noise( pos.xy*2. ))*6. )/(1.5*h1+1.0);
	
	return  height;
}

// Function 1029
float Tonemapping(float x ){
    
    float calc;
    
    calc = ((x*(shoulderStrenght*x + linearAngle*linearStrenght) + toeStrenght*toeNumerator)/(x*(shoulderStrenght*x+linearStrenght)+toeStrenght* toeDenominator))- toeNumerator/ toeDenominator;                        
    
    return calc;    
}

// Function 1030
vec2 scene(vec3 p, float e) {
    #define add(m) if (odst < sr.x) sr = vec2(odst, m);
    #define sub(m) if (-odst > sr.x) sr = vec2(-odst, m);
    #define intersect(m) if (odst > sr.x) sr = vec2(odst, m);
    
    //mirror box
    vec2 sr = vec2(-sdBox(p,vec3(10.)), 0.);
    
    //white box light
    float odst = udBox(p-vec3(8.,2.,-3.), vec3(1.));
    add(1.)
    
    //yellow sphere light
    odst = length(p)-1.;
    add(2.)
        
    //glass sphere
    odst = abs(length(p-vec3(-3.,4.,0.))-2.)-0.01;
    odst = transparency(odst,0.9);
    add(0.)
    
    return sr;
}

// Function 1031
vec2 getDistM(vec3 pos)
{
    float m=-1.;
    float d=10000.;
    float dp;
    vec3 rpos=pos+.005*(getRandSm(pos.xy*20.).xyz-.5);
    dp=d; d=min(d,getDistGlass(pos)); m=(d<dp)?0.:m;
    dp=d; d=min(d,getDistLead(pos));  m=(d<dp)?1.:m;
    dp=d; d=min(d,getDistFrame(rpos)); m=(d<dp)?1.:m;
    return vec2(d,m);
}

// Function 1032
float map(vec3 p) {
    mapmat = 0.0;
    mapp = p;
    float nz = floor(p.z / 3.0 + 0.5);
    float pz = (fract(p.z / 3.0) - 0.5) * 3.0;
    float qz = (fract(p.z / 3.0 + 0.5) - 0.5) * 3.0;
    float ww = max(abs(p.x) - 0.35, p.y + 2.0);
	float w = wall(vec3(abs(p.x) - 2.5, p.y, pz));
    float d = w;
    if (ww < d) {
        d = ww;
        mapmat = 3.0;
    }
    float t = top(vec3(p.x, p.y, qz));
    if (t < d) {
        mapmat = 2.0;
        d = t;
    }
    for (int i = -1; i <= 1; ++i) {
        float qzi = qz + float(i) * 3.0;
        float nzi = nz - float(i);
        vec3 rp = vec3(p.x, p.y, qzi);
        p.y -= 3.5;
        float st = 3.141592 * 0.75 + iTime * 3.141592 * 0.5;
    	p.xy *= rot(cos(st + nzi * 3.141592 / 4.0));
    	p.y += 3.5;
    	float s = swing(rp);
        if (s < d) {
            mapp = rp + vec3(0.0, 0.0, nzi);
            d = s;
            mapmat = 1.0;
        }
    }
    return d;
}

// Function 1033
float map(in vec2 xz)
{   
    vec2 p = floor(xz*A)/A;
    vec2 q = floor((xz)*B)/B;
    vec2 r = floor((xz)*C)/C;
    
    vec2 f = 1.5-abs(fract(p*G2)-.5)-abs(fract(q*G2)-.5)-abs(fract(r*G2)-.5);
    f=smoothstep(.9,1.8,f);
    float c = 1.5*(f.x+f.y);
    
    float Hp = c*Hsh2(p), Hq = c*Hsh2(q), Hr = c*Hsh2(r);
    float Pp = step(.6,Hp), Pq = step(.6,Hq), Pr = step(.5,Hr);
    
    float tex = 1.*Hp*Pp + .5*Hq*Pq +.3*Hr*Pr;	  
    hitScale = Pp + 2.5*Pq + 5.*Pr;
    
    return tex;
}

// Function 1034
float map(vec2 xz)
{
	xz += noise(xz);
	vec2 a = 1.0 - abs(sin(xz));
	vec2 b = abs(cos(xz));
	return pow(dot(a, b) * length(cos(xz)), 0.5) + pow(sin(xz.x), 1.0) + pow(cos(xz.y), 1.0);
}

// Function 1035
vec4 mapTrees( in vec3 pos, in vec3 rd )
{
    vec3  col = vec3(0.0);	
	float den = 1.0;

	float kklake = textureLod( iChannel0, 0.001*pos.zx, 0.0).x;
	float isLake = smoothstep( 0.7, 0.71, kklake );
	
	if( pos.y>1.0 || pos.y<0.0 ) 
	{
		den = 0.0;
	}
	else
	{
		
		float h = pos.y;
		float e = envelope( pos );
		float r = clamp(h/e,0.0,1.0);
		
        den = smoothstep( r, 1.0, textureLod(iChannel0, pos.xz*0.15, 0.0).x );
        
		den *= 1.0-0.95*clamp( (r-0.75)/(1.0-0.75) ,0.0,1.0);
		
        float id = textureLod( iChannel0, pos.xz, 0.0).x;
        float oc = pow( r, 2.0 );

		vec3  nor = calcNormal( pos );
		vec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );
		float amb = 0.5 + 0.5*nor.y;
		
		float w = (2.8-pos.y)/lig.y;
		float c = fbm( (pos+w*lig)*0.35 );
		c = smoothstep( 0.38, 0.6, c );
		dif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );
			
		vec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;

		vec3 mate = 0.6*vec3(0.5,0.5,0.1);
		mate += 0.3*textureLod( iChannel1, 0.1*pos.xz, 0.0 ).zyx;
		
		col = brdf * mate;

		den *= 1.0-isLake;
	}

	return vec4( col, den );
}

// Function 1036
float scene_obj_runway_centerline( mat2 K, vec2 uv, vec2 size )
{
    float l = floor( size.x / 60. - 1.5 ) * 60.;
    return aaa_stipple( Linfinity( K[0] ), uv.x, 60., .5 ) *
        aaa_box( K, uv, vec2( l, .7 ), vec2( 0 ) );
}

// Function 1037
float distBox( vec3 p, vec3 b )
{
  	return length(max(abs(p)-b,0.0));
}

// Function 1038
void TestSceneVolumetric(in vec3 rayPos, out SRayVolumetricInfo info)
{   
    info.scatterProbability = 0.0f;
    info.anisotropy = 0.0f;
    info.emissive = vec3(0.0f, 0.0f, 0.0f);
    info.absorption = vec3(0.0f, 0.0f, 0.0f);
    
    #if SCENE == SCENE_FOG1 || SCENE == SCENE_FOG2
    
    	float dist = BoxDistance(vec3(0.0f, 25.0f, -30.0f), vec3(60.0f, 25.0f, 30.0f), 0.0f, rayPos);
    	info.scatterProbability = step(dist, 0.01f) * 0.02f;
    
    	#if (SCENE == SCENE_FOG2)
    		if (rayPos.x > 0.0f)
                info.anisotropy = 0.5f;
    		else
                info.anisotropy = -0.5f;
        #endif
    
    #elif SCENE == SCENE_ABSORPTION1 || SCENE == SCENE_ABSORPTION2
    	if (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)
        {
            #if SCENE == SCENE_ABSORPTION1
            	info.scatterProbability = 0.1f;
            #endif
            info.absorption = vec3(0.0f, 0.4f, 0.9f) * 0.1;
        }
    
    	if (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)
        {
            info.scatterProbability = 0.1f;
        }
    
    #elif SCENE == SCENE_EMISSION
    	if (step(SphereDistance(vec4( -25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)
        {
           	info.scatterProbability = 0.1f;
            info.emissive = vec3(0.0f, 0.4f, 0.9f) * 0.05f;
        }
    
    	if (step(SphereDistance(vec4( 25.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)
        {
            info.scatterProbability = 0.1f;
        }
    
    #elif SCENE == SCENE_LIGHTINFOG1
    
    	if (step(SphereDistance(vec4( 0.0f, 40.0f, -30.0f, 20.0f), rayPos), 0.01f) > 0.0f)
        {
           	info.scatterProbability = 0.1f;            
            info.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f;
        }
    
    #elif SCENE == SCENE_LIGHTINFOG2
    
 		float dist = length(rayPos - vec3(0.0f, 40.0f, -30.0f));

        float fogAmount = smoothstep(25.0f, 15.0f, dist);
    	info.scatterProbability = fogAmount * 0.1f;
    	info.absorption = vec3(1.0f, 1.0f, 1.0f) * 0.05f * fogAmount;
    
    #elif SCENE == SCENE_MULTIFOG
    
    	float weight = 0.0f;
    
    	if (BezierDistance(rayPos, vec3(10.0f, 0.0f, -30.0f), vec3(10.0f, 40.0f, -30.0f), vec3(50.0f, 50.0f, -30.0f), 7.0f) < 0.0f)
        {
            weight += 1.0f;
            info.scatterProbability += 0.2f;
        }
    
    	if (BezierDistance(rayPos, vec3(-50.0f, 40.0f, 0.0f), vec3(-10.0f, 50.0f, 10.0f), vec3(0.0f, 0.0f, 10.0f), 7.0f) < 0.0f)
        {
            weight += 1.0f;
            info.scatterProbability += 0.05f;
            info.absorption = vec3(0.1f, 0.1f, 0.05f) * 2.0f;
        }    
    
    	if (BezierDistance(rayPos, vec3(-40.0f, 0.0f, -40.0f), vec3(-40.0f, 40.0f, -20.0f), vec3(-20.0f, 60.0f, 0.0f), 7.0f) < 0.0f)
        {
            weight += 1.0f;
            info.scatterProbability += 0.1f;
            info.emissive = vec3(1.0f, 1.0f, 0.125f) * 0.1f;
        }
        
    	if (BoxDistance(vec3(30.0f, 10.0f, -20.0f), vec3(15.0f, 10.0f, 15.0f), 5.0f, rayPos) < 0.0f)
        {
            weight += 1.0f;
            info.absorption = vec3(0.1f, 0.4f, 0.9f) * 0.25f;
        }
    
    	if (weight > 0.0f)
        {
            info.scatterProbability /= weight;
            info.absorption /= weight;
            info.emissive /= weight;
        }
    #elif SCENE == SCENE_ORGANICFOG
    
    	float density = noise((rayPos + vec3(10.0f, 0.0f, 0.0f)) / 25.0f);
    	const float threshold = 0.6f;
    
    	density = clamp((density - threshold) / (1.0f - threshold), 0.0f, 1.0f);
    	info.scatterProbability = density * 0.075f;
    #endif
}

// Function 1039
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    
    
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );
    
    //Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 1.0, 5.8), vec3(1,1,1) );
    
    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
    // AO
    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;
    
    return surfaceLighting;
}

// Function 1040
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.
    const vec2 e = vec2(.001, 0); 
    
    // Gradient vector: vec3(df/dx, df/dy, df/dz);
    float ref = bumpSurf3D(p, nor);
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),
                      bumpSurf3D(p - e.yxy, nor),
                      bumpSurf3D(p - e.yyx, nor)) - ref)/e.x; 
    
    /*
    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.
    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),
                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),
                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;
    */
       
    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind 
    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.
    grad -= nor*dot(nor, grad);          
         
    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.
    return normalize(nor + grad*bumpfactor);
	
}

// Function 1041
float scene(vec3 p) {
    if (length(p) > 1.) return length(p)-.8;
vec4 f0_0=sin(p.y*vec4(-1.1405,1.1760,1.2857,-2.1564)+p.z*vec4(-1.6142,-3.6948,-1.8810,3.0428)+p.x*vec4(-4.2162,1.6138,-2.1348,-.5009)+vec4(-8.0215,3.3005,-4.9939,-2.6610));
vec4 f0_1=sin(p.y*vec4(-1.6745,-2.8987,1.0796,-.4005)+p.z*vec4(4.1790,-3.0860,-3.7136,1.0541)+p.x*vec4(2.6095,-3.9927,1.3629,-3.9242)+vec4(7.5805,3.0794,1.7210,-4.7592));
vec4 f0_2=sin(p.y*vec4(-1.1690,2.6507,-2.5833,-.7952)+p.z*vec4(-2.1702,-1.9758,.1388,-2.5661)+p.x*vec4(2.8543,4.1530,-2.3108,-.9129)+vec4(.7631,-5.4116,-4.4417,6.5267));
vec4 f0_3=sin(p.y*vec4(.3317,.5146,3.3117,.9610)+p.z*vec4(-.1146,.1291,1.1622,.3476)+p.x*vec4(2.3463,-2.7041,-2.2209,3.6268)+vec4(5.6731,-4.7358,2.7893,-7.1612));
vec4 f0_4=sin(p.y*vec4(-3.8313,-3.2312,4.0638,-4.1941)+p.z*vec4(2.3208,-1.6267,-1.2708,3.5948)+p.x*vec4(-.2369,.5631,-.7758,1.7456)+vec4(4.5843,1.3243,-8.2270,7.8213));
vec4 f0_5=sin(p.y*vec4(-3.3688,3.2369,3.0260,2.5458)+p.z*vec4(3.7649,4.3277,-1.3795,-2.2266)+p.x*vec4(-.1241,1.5201,4.4127,-3.6465)+vec4(6.5967,5.1530,-7.6662,.6203));
vec4 f1_0=sin(mat4(.4283,.0182,.5332,.0540,-.2346,.0960,-.1881,.0555,.2758,-.2231,-.4479,.2886,.4426,.2823,-.3488,.0299)*f0_0+
    mat4(.1593,.1936,.2623,-.7297,.2478,.0291,.4403,.1618,.0097,-.0680,.0739,-.0924,-.3928,.4232,.2813,-.2751)*f0_1+
    mat4(-.8969,-.2549,.2126,.2545,-.0137,-.2497,.4449,.6357,.6508,.1802,.2930,.5183,.2969,.3053,-.3403,.3291)*f0_2+
    mat4(-.7413,-.3361,.3778,-.0318,.4063,.1229,.5541,.2476,-.8308,.2848,-.0984,-.1254,-.1721,-.0862,-.2333,.5118)*f0_3+
    mat4(.0400,.3863,.1261,-.2855,-.0789,.4047,-.1773,.4571,-.2735,-.4307,-.4558,.1324,-.3745,-.0340,-.2384,.2797)*f0_4+
    mat4(.3168,.6159,-.1358,.2209,.0596,.0468,-.0349,.0606,.0723,.2396,-.0949,-.2042,.2258,.3127,.4203,-.7138)*f0_5+
    vec4(-.3935,-1.2879,-3.0636,2.8746))/1.00+f0_0;
vec4 f1_1=sin(mat4(.2404,.2137,.4911,.2350,-.2768,-.3869,-.6949,-.1394,-.5911,-.4592,.3455,-.2965,.3846,.4321,.4655,-.2737)*f0_0+
    mat4(.1943,.0581,.2987,.1255,.1294,-.0569,.3473,.0824,-.3558,.2081,-.1165,-.2984,-.1351,-.0961,-.3273,-.0740)*f0_1+
    mat4(.4798,-.4114,-.2765,-.0956,.4051,-.0828,.3566,-.2902,-.1369,.2391,.0414,-.0202,.4755,.1570,.0453,-.0350)*f0_2+
    mat4(.0034,-.3040,.0966,.1394,-.0596,.1715,.3755,.2095,-.0389,.2416,-.4348,.3523,.1106,-.5070,-.2783,-.5900)*f0_3+
    mat4(.4393,.4704,-.1185,-.2027,.1559,-.0161,-.7020,.3401,-.0329,-.1101,-.2233,.5765,-.1210,-.3687,.2232,-.0947)*f0_4+
    mat4(.1414,-.2183,.5306,.1045,.0847,.4032,.0373,.0557,.0837,.4058,.3312,-.1917,-.4103,.4489,-.0458,-.2355)*f0_5+
    vec4(.7373,.2061,-1.9233,1.3916))/1.00+f0_1;
vec4 f1_2=sin(mat4(-.3258,.1353,-.5998,-.0546,-.3110,-.0632,-.2792,-.0728,.1467,-.0446,.5993,.5235,.2560,-.1797,-.2506,-.2415)*f0_0+
    mat4(.1154,-.4482,-.1964,.0812,.1196,-.2067,-.2043,.1711,.1562,-.1892,.1119,.0628,.2184,-.5889,-.0066,.1210)*f0_1+
    mat4(-.1876,.3781,-.5209,-.4353,.0354,.1592,-.4752,.0808,.5745,.2097,.4002,.2874,.3446,-.0306,-.2091,.0462)*f0_2+
    mat4(.0831,.0176,.3844,-.1191,.1301,.1722,-.3390,.0924,-.2368,-.3423,.2648,-.1552,-.0805,.2499,-.1025,-.6498)*f0_3+
    mat4(-.3108,-.2391,-.1317,-.4019,.0505,.4596,.5610,-.3690,.1749,-.2221,.4036,.1886,.2317,.2628,.2346,-.3888)*f0_4+
    mat4(-.3807,.2370,-.3637,-.0114,.2697,.3157,.2821,-.3275,.2776,.2074,.7315,-.5274,.2212,-.1343,.1926,.4157)*f0_5+
    vec4(-.5634,3.0945,2.1514,.5819))/1.00+f0_2;
vec4 f1_3=sin(mat4(.2322,.2288,.0503,-.1497,.2671,.0152,-.6257,-.2133,-.2370,-.1625,-.2606,.3965,-.0863,-.2658,-.5606,.2290)*f0_0+
    mat4(.0737,.2728,.3821,.4612,-.2312,.0992,-.0190,.1686,.3150,-.1361,-.4138,.4684,-.1349,.1479,.2156,-.2543)*f0_1+
    mat4(.0990,-.5684,.6348,-.3352,.3581,.1000,.1026,-.1389,-.2395,.2756,.3680,-.0288,-.4819,-.3938,-.3472,-.3838)*f0_2+
    mat4(.0981,.1473,.0306,.0048,.4243,.4736,.3676,.1385,-.3010,.0703,-.0248,-.1841,-.2167,-.2414,.3576,.2105)*f0_3+
    mat4(-.1007,.0874,.0111,-.5404,-.3333,.1131,.9492,.5615,-.0251,-.2502,-.0752,.0679,.1919,-.2333,.2773,.0613)*f0_4+
    mat4(-.0899,-.0367,.1378,.0896,-.0785,-.2133,.0624,-.2813,-.0831,-.2130,-.2175,.1092,-.0421,.0080,-.6586,.3733)*f0_5+
    vec4(-1.4891,-.6801,1.9186,-2.7150))/1.00+f0_3;
vec4 f1_4=sin(mat4(.0889,-.1463,.4438,-.4469,-.4225,-.0207,-.0054,.0468,-.4142,.1697,-.4245,-.6603,-.2907,.0017,.3382,.3685)*f0_0+
    mat4(-.1015,.1425,.0357,.2562,-.1381,.0196,.1697,-.4572,.1317,-.1572,.1803,.1498,.4495,.3801,.5033,-.1387)*f0_1+
    mat4(-.5385,.3839,.1829,-.1837,-.2158,.3991,-.0564,.1084,.3708,-.1995,.5937,-.1388,.2912,.0370,.4859,.3851)*f0_2+
    mat4(-.3379,.1068,-.3437,.1064,-.2266,-.1004,.4889,.3333,-.5013,-.1040,-.5713,.0189,-.2741,.3557,-.4767,.4575)*f0_3+
    mat4(.4023,-.0471,-.5898,.3296,-.1395,-.1659,.3625,.4129,-.2640,-.5264,.8246,.3607,-.3476,.1076,-.0521,-.1226)*f0_4+
    mat4(-.2420,-.1435,-.3602,.0014,.0274,.1435,.3942,.1281,-.2225,-.1567,.0066,-.0859,-.2016,.2456,-.4468,.3226)*f0_5+
    vec4(-.2000,-1.3997,-2.1226,.9784))/1.00+f0_4;
vec4 f1_5=sin(mat4(.3970,-.0700,.0088,-.3769,-.3805,.2062,.3198,.0001,.0358,.4662,.1860,-.2147,.1421,-.0042,-.0531,.2439)*f0_0+
    mat4(.1147,-.2132,.3631,.2525,-.2267,-.0317,.0508,-.6767,.3219,.2937,-.3602,-.1908,-.5073,.2450,-.1174,-.4200)*f0_1+
    mat4(-.5108,-.7364,-.4623,-.5500,.3217,-.2504,-.7220,-.6085,.0486,.1562,.0659,.0956,.0491,.0593,-.1767,.5219)*f0_2+
    mat4(-.0658,.7926,-.3584,-.2188,-.1685,.3776,.4966,.0836,-.4346,.1745,-.4379,-.1422,-.2569,-.1465,.1528,-.2879)*f0_3+
    mat4(.2083,-.2885,.0664,.3189,-.4236,-.1626,.5725,-.0780,-.1195,-.7710,-.2820,.6491,.4428,-.1771,.2408,.4136)*f0_4+
    mat4(.1187,-.1239,-.1038,.2935,.0523,-.3224,.1298,-.0204,.4071,.1830,-.4513,.4001,.2575,.4154,-.1242,-.1355)*f0_5+
    vec4(1.1119,.6284,1.4638,-1.9741))/1.00+f0_5;
vec4 f2_0=sin(mat4(-.7476,-.1512,.3080,-.0518,-.1526,.7593,.4186,-.0252,.2402,-.0990,-.0299,.0941,-.1616,-.0831,.1996,-.4646)*f1_0+
    mat4(-.3382,-.4718,.1786,.1919,.0752,-.2019,.1398,-.5919,-.0061,.0239,-.1130,.1397,.1847,.2366,-.6435,.2706)*f1_1+
    mat4(.2061,.2028,-.0383,.1267,.4751,.3278,-.0123,-.3128,-.1276,-.2990,.0700,.4875,-.2132,-.3835,-.0098,-.4057)*f1_2+
    mat4(.0427,.7227,-.2976,-.1341,-.3731,-.0410,.4150,-.1766,-.6085,-.3676,-.0448,.1699,.3741,.1241,.1318,-.3834)*f1_3+
    mat4(-.1281,-.2315,-.0942,.5387,.6134,.4121,.0679,-.3293,.3324,-.0404,-.1638,.1273,-.3847,.0111,.4315,-.0408)*f1_4+
    mat4(-.5511,-.4837,-.0846,.3745,-.0130,.1282,.2273,.4512,-.2767,-.2228,.3446,.3432,.1902,-.3868,.1270,-.2049)*f1_5+
    vec4(2.6898,-.3244,2.0565,-2.3141))/1.41+f1_0;
vec4 f2_1=sin(mat4(-.1512,.2711,-.1104,.1992,.1918,.2944,.6676,.1148,-.8442,-.3381,.3191,.2327,-.1993,.0403,.2573,-.0745)*f1_0+
    mat4(.4533,.5307,-.0403,.0607,-.1723,.0917,.1157,.0253,.0560,.1484,-.0593,-.1993,.4877,.1215,-.0625,-.0989)*f1_1+
    mat4(-.0188,.1648,.0009,.1781,-.4379,-.1470,.1297,-.0972,.0033,.0855,-.2943,.2497,-.0923,.4017,.3527,-.4016)*f1_2+
    mat4(-.1575,.1430,.0484,.2227,-.1279,-.1169,-.1836,.2063,.2645,.6292,-.1794,-.1575,-.2973,.1234,-.1290,.4870)*f1_3+
    mat4(.2762,-.0376,.2889,.2072,-.3314,-.3850,-.0265,.3790,.4006,-.4586,-.1992,.0816,-.0893,.2061,.0110,-.5390)*f1_4+
    mat4(-.2337,.6043,.1270,.0673,-.3859,.3229,-.3137,.0167,.5843,.1215,.2581,.0153,.0665,.1436,.1446,-.0920)*f1_5+
    vec4(.9082,.1214,1.4633,2.8008))/1.41+f1_1;
vec4 f2_2=sin(mat4(-.3828,-.0706,-.1898,-.2981,-.0273,.2794,-.3240,-.0618,-.1908,-.4748,-.1554,.2195,.0841,-.1597,-.4302,.1904)*f1_0+
    mat4(-.3488,.2210,-.0576,.3080,.3314,-.2857,.1262,-.0667,-.0881,-.3204,-.0971,.1079,.0290,.1824,.0076,-.3239)*f1_1+
    mat4(-.4216,-.3578,-.2444,-.1458,.0995,-.1588,.1547,.0809,-.2430,.5579,.2154,-.1848,-.0435,.2232,-.5482,.1449)*f1_2+
    mat4(-.2870,-.4095,.5798,-.1675,-.4569,-.1501,.1047,-.2987,-.3069,.6830,-.5784,.0658,.1756,-.1002,-.1165,.0195)*f1_3+
    mat4(.0911,.1823,-.1248,.0121,.0720,-.3593,-.0082,-.2584,.1134,-.0082,-.0921,.0706,.0567,.1607,-.1352,-.1468)*f1_4+
    mat4(-.4233,-.5088,.0110,-.2302,-.0793,.3303,-.1943,-.2227,-.0031,.2844,-.1248,.0380,.2147,-.0645,.2131,.0747)*f1_5+
    vec4(-1.8416,2.9403,-.6392,-1.5377))/1.41+f1_2;
vec4 f2_3=sin(mat4(-.3284,-.0344,-.2446,.3482,.3785,.2395,-.3987,-.5290,-.5285,.2529,.4058,.3430,.0184,.0831,.1462,-.0181)*f1_0+
    mat4(.2067,-.4757,.0358,.1747,-.3760,.1504,-.1688,-.2903,-.1189,-.0841,.2082,-.2681,-.0966,.2234,.2865,.1299)*f1_1+
    mat4(-.2397,.6295,-.1517,.2200,.3800,.2542,-.3478,-.2221,.4703,-.2264,.0437,.4949,.0069,.0189,.1994,.1025)*f1_2+
    mat4(-.5775,-.0097,.1982,-.6734,.0265,-.1944,.1032,.1858,.4024,-.3728,.5513,.5587,.1949,.1583,.5918,.4059)*f1_3+
    mat4(.3968,.0912,.4684,.2598,-.1597,.3542,.0057,-.0031,-.4975,.1690,.3321,.0570,.1208,-.2731,.4664,.3044)*f1_4+
    mat4(-.1344,.0908,.5367,-.3595,.5749,-.2264,-.2164,.7811,.5142,-.2481,.1690,.6487,-.2733,.0082,.3073,-.2884)*f1_5+
    vec4(2.1952,.1416,2.0763,-.2666))/1.41+f1_3;
vec4 f2_4=sin(mat4(.5867,.1084,-.3888,-.7437,-.0411,.0453,-.4360,-.1674,-.1572,.2306,.0619,.2986,.5459,-.0554,.8014,-.6426)*f1_0+
    mat4(.4036,-.2598,-.4398,.3322,-.3773,.2222,-.0115,.5663,-.1857,-.6525,.2277,.1871,-.3222,.2736,-.4254,-.1257)*f1_1+
    mat4(.0314,.0419,.3031,-.2152,-.1060,-.4683,.0308,.0329,1.0827,-.3068,-.4914,-.6944,.0512,-.5530,-.2647,.6937)*f1_2+
    mat4(-.0259,-.0822,-.1682,.3606,.8088,.3526,-.1553,-.3577,1.3533,-.0449,.0708,-.4184,.2020,.2685,.0336,.0636)*f1_3+
    mat4(1.0073,.1952,-.3111,-.3199,-.1227,.0360,1.0460,-.4279,.0085,-.3509,-.5348,.5289,.5783,-.3530,-.1584,-.7851)*f1_4+
    mat4(.3731,-.4806,-.1226,-.0438,.5776,.0596,-.7368,-.3683,.4283,-.3049,-.1540,.4872,-.2504,.2702,-.2418,-.0124)*f1_5+
    vec4(1.0460,-.7609,-2.6136,1.7412))/1.41+f1_4;
vec4 f2_5=sin(mat4(.0206,-.1916,.3615,-.1659,.1648,-.2299,-.1039,-.2046,.1742,.6134,-.0394,-.2142,-.0560,.4014,-.3397,-.0218)*f1_0+
    mat4(.4030,-.0171,-.5419,-.1809,-.2173,.1619,.2130,.4290,-.3837,.4710,.1555,.3157,-.2684,.6031,.4861,.0961)*f1_1+
    mat4(.2709,.4967,.6131,.3472,-.2004,.0379,.4512,-.1495,.3167,-.3547,-.1208,.0464,.0229,-.2151,-.4797,.5806)*f1_2+
    mat4(.0644,-.7797,-.6199,.0489,.1586,-.0999,.2995,.3767,.1271,-.6964,-.3474,.1706,-.3235,.3332,-.6006,-.2708)*f1_3+
    mat4(.3736,-.5805,-.8545,.4102,.4190,.6573,.3400,.5236,.2362,.3213,-.0080,.4325,-.4875,-.2194,-.4284,-.4324)*f1_4+
    mat4(-.6019,.4234,-.0551,-.3841,.5159,-.7246,-.5670,.2715,-.1963,-.1422,-.1472,-.1825,-.1229,.5466,.1769,-.2313)*f1_5+
    vec4(2.3196,-.4360,-.6900,-.8132))/1.41+f1_5;
vec4 f3_0=sin(mat4(-.5579,1.3101,-.4695,.2828,.0787,-.0961,-.3525,-.5318,-.0997,.6600,-.1396,.6494,.4997,-.3140,.5802,.0319)*f2_0+
    mat4(-.4792,-.4421,.1052,.1660,.3382,.2075,.3630,.3631,.1838,.6143,-.1399,-.2465,-.2589,.4299,-.4456,.0937)*f2_1+
    mat4(-.5273,.0413,.4123,.2149,.2962,-.5134,.4068,-.2666,-.2524,-.1862,.0053,.3725,.1653,-.2569,.3187,-.1401)*f2_2+
    mat4(-.2795,-.7765,.1561,-.0157,-.5101,.4763,-.2073,.6251,-.1524,-.4631,.1321,-.0577,.2601,.1246,.3625,.1741)*f2_3+
    mat4(-.7595,-1.0753,-.1062,-.3118,-.4030,-.1255,.1851,.3952,-.1828,.5075,-.4244,-.4543,.0777,.5249,-.1330,.2601)*f2_4+
    mat4(.1103,-.0809,.4848,.8048,-.4218,-.1034,-.0854,-.0101,.1650,.5752,-.0955,.8972,.2932,.1352,-.2050,-.2736)*f2_5+
    vec4(-.5803,-2.2796,1.8558,-2.1928))/1.73+f2_0;
vec4 f3_1=sin(mat4(-.1701,.0715,.6682,.6901,.1899,.6150,-.4114,-.6737,-.6088,.4367,.0412,.6845,-.4655,.1296,-.1796,.3806)*f2_0+
    mat4(-.0154,-.3797,-.5231,-.4007,-.2943,.0393,-.2630,.0612,.0030,.6002,-.6594,.4744,.3566,.1060,.5724,-.4538)*f2_1+
    mat4(-.7308,.0065,.1867,.2402,-.2761,-.3315,-.3979,.3206,-.5998,-.3101,.1033,.0996,-.1005,.0116,.4866,-.0806)*f2_2+
    mat4(-.2362,-.3564,.5576,-.1515,-.1673,.4134,-.4159,-.2098,.1843,.1361,-.4072,.7149,.4603,-.0537,-.2983,.1770)*f2_3+
    mat4(-.1203,-.0858,-.1197,.2894,-.2578,.2790,-.0687,-.0156,.4650,.4792,-.3554,-.3058,.4087,.5727,.3059,-.3743)*f2_4+
    mat4(.3603,-.4230,.3266,.2797,-.6443,.4882,.1038,.2348,.0830,.0114,.2969,.1153,-.0827,-.1836,-.2541,.3836)*f2_5+
    vec4(-1.3221,2.3931,.1386,-.4358))/1.73+f2_1;
vec4 f3_2=sin(mat4(-.2984,.9361,-.4965,.4934,.8901,-.2692,.2627,.1331,.0306,.5504,.0950,-.2044,-.5674,-.0827,.4890,.0888)*f2_0+
    mat4(-.0309,-.1783,.1285,.1018,-.6561,.3033,-.3128,-.1962,-.3187,.2721,.2465,.2069,-.0929,-.4486,.0533,.4301)*f2_1+
    mat4(.6094,.3260,.0924,.2739,.8089,-.4134,.2734,-.5275,.3755,-.3839,-.4528,-.3476,-.2863,-.7052,.0424,.1695)*f2_2+
    mat4(1.3079,-.7847,-.1620,-.3525,-1.2070,.8570,.0372,-.1725,-.0091,-.1153,-.1257,-.0472,-1.2006,.1178,.2554,.2007)*f2_3+
    mat4(1.1689,-.8032,.3481,.3992,-.1648,.0159,.8135,-.7356,-.4871,.1758,-.0342,.1652,-.7809,.2302,-.3997,-.2953)*f2_4+
    mat4(-.8927,.0210,.0586,-.2247,.8452,-.4174,-.4407,.0466,-.8509,.5526,-.0873,-.2954,-.0756,.1924,-.0194,.1312)*f2_5+
    vec4(1.6865,-2.1835,.4587,-2.6469))/1.73+f2_2;
vec4 f3_3=sin(mat4(.4390,-.4103,.1745,.6960,-.2662,-.8931,.6693,-.2409,-.4103,.2679,.2690,.0936,.4968,-.3329,.2855,-.0871)*f2_0+
    mat4(-.0231,.7836,-.1714,.3489,-.7215,.0184,.5462,-.0510,.2714,.8855,-.5149,.1400,.6539,.9522,.1646,.0576)*f2_1+
    mat4(.0529,-.1013,.7117,.3552,-.3714,.3185,.0963,.0242,.3325,.3086,.0689,.2264,-.0772,-.3834,-.1785,-.4543)*f2_2+
    mat4(-.0567,.0722,-.3264,-.2579,-.2114,-.2502,-.1859,.2839,.3084,.3888,.1262,.1273,.7690,.2780,.3842,-.2156)*f2_3+
    mat4(.2122,.1122,-.2625,.1190,-.7342,.1912,-.0874,-.3581,-.0335,-.2309,.0696,-.1469,.1320,-.0154,.3271,.2947)*f2_4+
    mat4(-.2962,.1927,-.4254,-.0605,.0607,-.4551,-.0723,-.3585,-.2539,.3514,-.4468,.1805,-.0339,.2503,.3102,.4332)*f2_5+
    vec4(1.9112,2.9841,-1.7244,.7379))/1.73+f2_3;
vec4 f3_4=sin(mat4(-.4379,-1.0623,.3081,.2389,.4325,.4483,-.1957,-.0928,.4565,-1.2847,-.7522,-.1213,.0918,.2194,-.1253,.3754)*f2_0+
    mat4(.7189,.2090,.2487,.4036,.1111,-.7672,-.5462,-.0505,.3691,.2164,.5671,-.6547,-.0210,.5157,.6893,-.4124)*f2_1+
    mat4(.4372,-.3423,-.4577,-.2213,.3092,.9729,-.0625,-.4263,-.0637,.3170,.1468,-.9859,-.1708,.4735,.2395,.4159)*f2_2+
    mat4(.0168,1.4777,.0056,-.3475,.3949,-1.4235,.2247,.7943,-.3335,1.2025,.2387,-.7363,-.0325,-.8510,-.4534,.4023)*f2_3+
    mat4(-.2163,1.5628,-.4146,-.0790,-.0151,-.9676,-.0404,-.3481,-.2829,-.4287,.3071,-.1027,.0956,-.2499,.6447,-.5348)*f2_4+
    mat4(-.0372,-.5469,.1173,-.0969,-.1760,.3727,.0610,-.5726,-.2185,-.1747,-.0911,.0553,.1506,-.3185,-.4991,-.1389)*f2_5+
    vec4(.0536,-2.0249,.5932,-.4759))/1.73+f2_4;
vec4 f3_5=sin(mat4(-.3650,-.4724,.4515,-.1794,.2276,.0227,.1208,.0158,.0980,-.1774,.6257,.5810,.2214,-.1252,-.7460,-.3124)*f2_0+
    mat4(.0039,.4478,.4631,-.2739,.7019,-.5154,-.0598,-.0822,.3901,.4001,-.3618,.7851,-.1460,-.0603,-.3426,.2344)*f2_1+
    mat4(-.5802,-.0878,-.3130,-.2578,-.8871,.7493,-.1037,-.5671,-.2257,.2380,-.0577,.0498,-.0372,.1800,.2026,-.3215)*f2_2+
    mat4(-.6840,.5784,-.1951,-.1349,.5031,.1899,.5149,1.1500,-.1624,.5718,-.0109,-.4735,.5503,-.0052,.3117,-.4614)*f2_3+
    mat4(-.7935,.6748,.1929,-.5100,.0483,-.2770,.4352,.6686,-.0390,-.5990,-.1360,.0279,-.0228,.0720,-.2516,.1471)*f2_4+
    mat4(.4111,.2605,-.2683,-.7513,-.8241,.3183,.0436,.0472,.0647,.0005,.8183,-.4727,.6502,-.1617,-.4478,.3644)*f2_5+
    vec4(.3259,-1.0914,.2229,-2.5857))/1.73+f2_5;
return dot(f3_0,vec4(.0675,-.0395,.0591,-.0347))+
    dot(f3_1,vec4(.0397,.0425,.0325,.0570))+
    dot(f3_2,vec4(-.0475,-.0479,-.0427,-.0508))+
    dot(f3_3,vec4(-.0675,-.0469,-.0205,.0463))+
    dot(f3_4,vec4(-.0391,-.0325,.0287,.0326))+
    dot(f3_5,vec4(.0430,-.0297,.0152,.0168))+
    -0.162;
}

// Function 1042
float map(vec3 p, float time)
{
    vec3 q = fract(p) * 2.0 - 1.0;
    
    // length of the point minus the radius of the sphere...
    float radius = 0.25;
    
    // spheres get bigger and smaller depending on time
    radius = (sin(time)*.05 + .1);
    
    return length(q) - radius;  //0.25;
}

// Function 1043
float mapSpell (vec3 p) {
    float scene = 1.;
    float a = atan(p.z,p.x);
    float l = length(p);
    float lw = getLocalWave(a);
    
    // warping space into cylinder
    p.z = l-1.+.1*lw;
    
    // torsade effect
    p.yz *= rot(t+a*2.);
    
    // long cube shape
    scene = min(scene, sdBox(p, vec3(10.,vec2(.25-.1*lw))));
    
    // long cylinder cutting the box (intersection difference)
    scene = max(scene, -sdCylinder(p.zy, .3-.2*lw));
    return scene;
}

// Function 1044
float boxSDF(vec2 p,vec2 s
){vec2 r=abs(p)-s
 ;return min(max(r.x,r.y),0.)+length(max(r,vec2(0)));}

// Function 1045
float sdf_scene(vec3 p, vec3 ro) {
  float sh = sdf_sh(L,M, 5.0, vec3(0.0, 0.0, 0.0), p, ro);
  return sh;
}

// Function 1046
vec3 GetDist(vec3 p  ) 
{	vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;
	float planeDist1 = p.y+0.0;  //piso inf
   
    res =opU3(res, vec3(planeDist1,1.0,-1.0)); //inf
    p.y=p.y-25.0;
    
    vec3 mn1= MoverNave(p);
    res =opU3(res, mn1); 
    
    float alto=25.0;
    float sb1= sdBox( p-vec3(0.0,0.0,90.0), vec3(100.0,alto,100.0) );
    float sb2= sdBox( p-vec3(0.0,1.0,-1.0), vec3(25.0,alto,10.0) );
    float sb3= sdBox( p-vec3(20.0,1.0,0.0), vec3(15.0,alto,45.0) );
    
    p=rotate_y( p-vec3(43.0,1.0,70.0), radians(135.0));
    float sb4= sdBox( p, vec3(10.0,alto,45.0) );
    
    
    float dif=differenceSDF(sb1, sb2);
    dif=differenceSDF(dif, sb3);
    dif=differenceSDF(dif, sb4);
    
    res =opU3(res, vec3(dif,100.0,-1.0)); //inf
    return res;
}

// Function 1047
float remap(float a, float b, float c, float d, float t) {
	return sat((t-a) / (b-a)) * (d-c) + c;
}

// Function 1048
vec2 scene(in vec3 p)	
{
	vec2 d = vec2(1000.0, 0); 
	d = min2(d, vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(6,2,8),3.0));	
	d = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(5,1,7),3.0));	
	d = max2(d, vec2(-1,1)*sdbox(p-vec3(0,-2,0), vec3(2,2,2),3.0));	
    return d; 
}

// Function 1049
float bumpmap(vec2 uv)
{
    float b1 = bumpMapParams1.x*(1.0 - texture(iChannel0, (uv + iTime*bumpMapParams1.zw)*bumpMapParams1.y).x);
    float b2 = bumpMapParams2.x*(1.0-texture(iChannel0, (uv + iTime*bumpMapParams2.zw)*bumpMapParams2.x).x);
    return b1+b2;
}

// Function 1050
float sdfMandel(vec3 p, float power)
{
    vec3 z = p;
    float dr = 1.0;
    float r;
    
    for (int i = 0; i < 16; i++)
    {
        r = length(z);
        
        if (r > 2.0)
            break;
        
        float theta = acos(z.z / r) * power;
        float phi = atan(z.y / z.x) * power;
        float zr = pow(r, power);
        
        dr = pow(r, power - 1.0) * power * dr + 1.0;
        
        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
        z += p;
    }
    
    return 0.5 * log(r) * r / dr;
}

// Function 1051
SSdfSample SdfSphere(vec4 sphere, SMaterial mtl, vec3 pos)
{
	vec3 posSphere = sphere.xyz;
	float sRadius = sphere.w;

	SSdfSample sdf;
	sdf.m_s = length(pos - posSphere) - sRadius;
	sdf.m_mtl = mtl;
	return sdf;
}

// Function 1052
float distanceToNearestSurface(vec3 p){
    vec3 q = vec3(mod(p.x, 3.0) - 1.5, p.yz);
	float s = 1.0;
    vec3 d = abs(q) - vec3(s);
    return min(max(d.x, max(d.y,d.z)), 0.0)
        + length(max(d,0.0));
}

// Function 1053
float GetDistSmallStellatedDodecahedron(vec3 p) {
    float zoom = 0.70;
    float dist = 1e10;
    p /= zoom;
    float dStella,dBase;
    {
        vec3 q = p;
        q -= ICOMIDEDGE; // walking from center to an edge
        q.zx *= Rot(DODEDIHEDRAL*.5); 
        // draws a face, rounded at the corners
        // Derived from IQ's orented box to get a rounded oridented edge 
        vec2 border = vec2(X_TO_DODE_CENTER/cos(DODEDIHEDRAL),Y_TO_DODE_VERTEX);
        float l = length(border);
        vec2  d = vec2(border.x,-border.y)/l;
        vec2 e = q.xy;
        e.y -= border.y; // from Dode vertex
        e = mat2(d.x,-d.y,d.y,d.x)*e;   // rotation
        e = vec2(abs(e.x-l*.5)-l*.5,e.y); // to center
        dStella = length(max(vec3(e.xy,q.z), 0.))+min(q.z, 0.);
        dist = dStella-.1;
        float dHorseShoe = sdHorseshoe(q.yx-vec2(0.0,0.4),vec2(sin(0.45),cos(0.45)),.14,vec2(.04));
        dist = smax(dist,-dHorseShoe,.02); 
        dist = min(dist,dStella-.05); 
        float pen = clamp(q.x-l*.55,0.0,0.48);
        dist = dist - 0.01*smoothstep(-0.3,0.9,sin(pen*3.14*20.));
        
    }
    {
        vec3 q = p;
        q.z -= 1.15; 
        dBase = q.z;
        q.yz *= Rot(ICODIHEDRAL*.5); 
        dBase = smax(dBase,q.z-.13,.01);
        dist = smin(dist,dBase,.01);
    }
    return dist * zoom;
}

// Function 1054
float map( const in vec3 p, const in vec3 id) {
    float d = rock(p, id) + fbm3(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;
    return d;
}

// Function 1055
float map(vec3 p){
    return serpinski(p)-0.0135;
}

// Function 1056
vec3 rayCastScene(in Ray originalRay, in Scene scene){
    const vec3 ambientColor = vec3(0.2, 0.2, 0.2);
    vec3 finalColor = vec3(0.0);
    
    Ray curRay = originalRay;
    float baseFogDist = 0.0;
  	float subRayMultiplier = 1.0;
    
    for (int i = 0; i < maxSurfaceHits; i++){    
    	RayHit curHit = rayCastBase(curRay, scene);

    	float rayDot = clamp(dot(-curRay.dir, curHit.n), 0.0, 1.0);
   		float fresnSimple = 1.0 - rayDot;
    	fresnSimple = mix(0.1, 1.0, fresnSimple * fresnSimple);
        //fresnSimple = 0.5;    
    
    	vec3 baseColor = curHit.color;
    	vec4 worldPos = curHit.dist * curRay.dir + curRay.start;
    	vec4 worldNormal = curHit.n;
    
    	float lightFactor = getLightFactor(scene.sunPos, worldPos, worldNormal, scene);
        
        vec3 curFinalColor = vec3(0.0);
        curFinalColor += baseColor * ambientColor;
        curFinalColor += baseColor * lightFactor;
        curFinalColor = applyFog(curFinalColor, curHit.dist + baseFogDist);
            
        finalColor = mix(finalColor, curFinalColor, subRayMultiplier);
    	//finalColor += addedLight * subRayMultiplier;
        
    	const float bounceBias = 0.001;
    	vec4 reflected = reflect(curRay.dir, curHit.n);
    	vec4 curPos = curRay.start + curRay.dir * curHit.dist;
    	Ray nextRay = Ray(curPos + reflected * bounceBias, reflected);            
        baseFogDist += curHit.dist + bounceBias;
        
        subRayMultiplier *= fresnSimple;
        curRay = nextRay;
        //break;
    }
    
    return finalColor;
    //return applyFog(finalColor, curHit.dist);
}

// Function 1057
float mapWalls(vec3 p ) {
    float s = sdSphere(p, ROOMSIZE*1.8);//+-voronoi3D(p);
    return polsmax(opDisplaceWallsHorizontal(p, s), opDisplaceWallsVertical(p, s), 1.1);
}

// Function 1058
maybe_float get_distance_along_2d_line_to_line_segment(
    in vec2 A0,
    in vec2 A,
    in vec2 B1,
    in vec2 B2
){
    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|
    vec2 B = normalize(B2 - B1);
    vec2 D = B1 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && 0. < xA && xA < length(B2 - B1));
}

// Function 1059
float sdf_id(vec2 uv)
{
    float d = .06*sdf_ellipse(uv, vec2(.52, .38), vec2(.26, .28));
    d = sdf_exclude(d, .02*sdf_ellipse(uv, vec2(.57, .39), vec2(.12, .18)));
    d = sdf_union(d, sdf_centered_box(uv, vec2(.75, .51), vec2(.09, .30)));
    d = sdf_union(d, sdf_centered_box(uv, vec2(.80, .80), vec2(.04, .10)));
    d = sdf_smin(d, sdf_centered_box(uv, vec2(.78, .15), vec2(.12, .05)), .05);
    d = sdf_smin(d, sdf_centered_box(uv, vec2(.66, .81), vec2(.10, .05)), .05);
    float i = sdf_centered_box(uv, vec2(.25, .40), vec2(.09, .23));
    i = sdf_union(i, sdf_disk(uv, vec2(.24, .79), .09));
    i = sdf_smin(i, sdf_centered_box(uv, vec2(.25, .15), vec2(.15, .05)), .05);
    i = sdf_smin(i, sdf_centered_box(uv, vec2(.20, .60), vec2(.10, .03)), .05);
    return sdf_exclude(sdf_union(i, d), sdf_intersection(i, d));
}

// Function 1060
float dotsCubeSDF(vec3 p)
{
    float dotsSDF_value = sphereSDF(p, (floor(p*SPHERES_DENSITY) + 0.5) /SPHERES_DENSITY, SPHERES_RADIUS);
        
	return max(cubeSDF(p), dotsSDF_value);   
}

// Function 1061
float Scene(in vec3 p, out int which)
{	
    float d = 1000.0, f;
	
	for (int i =0; i < 3; i++)
	{
		vec3 pos = p-balls[i];

		// Squish it...
		pos.xz /= squish[i];
		pos.y *= squish[i];
		f = deBall(pos, radius[i]);
		if (f < d)
		{
			d = f;
			which = i;
		}
	}
	
	f = deQBert(p - QbertPos);
	if (f < d)
	{
		d = f;
		which = 4;
	}

	f = deQBertEyes(p - QbertPos);
	if (f < d)
	{
		d = f;
		which = 5;
	}

    return d;
}

// Function 1062
float snowMap(vec3 p)
{
    vec3 q = fract(p) * 2.0 - 1.0;
    
    // length of the point minus the radius of the sphere...
    float radius = 0.25;
    
    // spheres get bigger and smaller depending on time
    radius = SNOW_INTENSITY;

    return length(q) - radius;  //0.25;
}

// Function 1063
float sdf( vec3 p )
{
	float d = 99999.0;
	vec3 t = vec3( 12923.73 + iTime );
	for ( int i = 0; i < kNumSpheres; i++ )
	{
		vec3 ps = vec3( 3.0 ) * cos( t * hash3( float( i ) ) );
		float ds = sphere( p - ps, mix( 0.7, 1.1, hash1( float( i ) ) ) );
		d = smin( d, ds, 0.85 );
	}
	return d;
}

// Function 1064
float DisplayShadowMap(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)
{
    // Determine our camera info
    Ray cameraRay = Ray(cameraPosition, cameraDirection); 
    return Intersect(cameraRay);
}

// Function 1065
float sdf_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return length(q) - torus.y;
}

// Function 1066
float map(vec3 p){
    
    // Back wall
    float wall = -p.z + .01; // Thick wall: abs(p.z - .2) - .21;
     
    // Truchet object and animated metallic balls: This is just a
    // standard 2D animated Truchet with an extruded factor. If you're
    // not sure how it works, myself and others have plenty of 
    // animated Truchet examples on Shadertoy to refer to.
    //
    // Grid construction: Cell ID and local cell coordinates.
    const vec2 sc = 1./GSCALE, hsc = .5/sc;    
    vec2 iq = floor(p.xy*sc) + .5;    
    vec2 q = p.xy - iq/sc; // Equivalent to: mod(p.xy, 1./sc) - .5/sc;
    
    // Flip random cells. This effectively rotates random cells,
    // but in a cheaper way.
    float rnd = hash21(iq + .37);
    if(rnd<.5) q.y = -q.y;
      
    // Circles on opposite square vertices.
    vec2 d2 = vec2(length(q - hsc), length(q + hsc));
    // Using the above to obtain the closest arc.
    float crv = abs( min(d2.x, d2.y) - hsc.x);
    
    // Flipping the direction on alternate squares so that the animation
    // flows in the right directions -- It's a standard move that I've
    // explained in other examples.  
    float dir = mod(iq.x + iq.y, 2.)<.5? -1. : 1.;
    // Using repeat polar coordinates to create the moving metallic balls.
    vec2 pp = d2.x<d2.y? vec2(q - hsc) : vec2(q + hsc);
    pp *= rot2(iTime*dir); // Animation occurs here.
    float a = -atan(pp.y, pp.x); // Polar angle.
    a = (floor(a/6.2831853*8.) + .5)/8.; // Repeat central angular cell position.
    // Polar coordinate.
    vec2 qr = rot2(-a*6.2831853)*pp; 
    qr.x -= hsc.x;
     
    // Ridges, for testing purposes.
    //crv += clamp(cos(a*16. + dir*iTime*3.)*2., 0., 1.)*.003;
    
    // A rounded square Truchet tube. Look up the tourus formula, if you're
    // not sure about this. However, essentially, you place the rounded curve
    // bit in on vector position and the Z depth in the other, etc. Trust me,
    // it's not hard. :)
    //float tr = length(vec2(crv, (p.z) + .05/2. + .02)) - .05;
    float tr = sBoxS(vec2(crv, (p.z) + .05/2. + .01), vec2(.035, .035), .01);
    
    // 3D ball position.
    vec3 bq = vec3(qr,  p.z + .05/2. + .01);
    //float ball = max(length(bq.zx) - .05, abs(bq.y) - .06);
    float ball = length(bq) - .015; // Ball.
    ball = min(tr + .03, ball); // Adding in the railing.
    
    // Hollowing out the Truchet tubing. If you don't do this, it can cause
    // refraction issues, but I wanted the tubes to be hollow anyway.
    tr = max(tr, -(tr + .01));
 
    // Metallic elements, which includes the joins, metal ball joints
    // and the tracks they're propogating along.
    q = abs(abs(q) - .5/sc);
    float mtl = min(q.x, q.y) - .01;
    mtl = max(max(mtl, tr - .015), -(tr - .005));
    
    // Adding the balls. I should probably give them their own ID, but this 
    // involves less work, and I'm always up for that. :D
    mtl = min(mtl, ball);
    
    // Storing the object ID.
    vObjID = vec4(wall, tr, mtl, 1e5);
    
    // Returning the closest object.
    return min(min(wall, tr), mtl);
 
}

// Function 1067
float dstScene(vec3 p) {
    return min(dstFace(p, 1.), p.y + 1.);
}

// Function 1068
vec4 boxmap(sampler2D t, in vec3 p, vec3 n, in float k ) {
    vec3 m = pow( abs(p), vec3(k) );
	vec4 x = texture(t, p.yz);
	vec4 y = texture(t, p.zx);
	vec4 z = texture(t, p.xy);
	return (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);
}

// Function 1069
vec3 Uncharted2Tonemap(vec3 x){
   	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 1070
float map(in vec3 ro, in vec3 rd){ 
    return min(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5),
               min(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), 
                   min(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),
                       min(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),
                           min(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),
                              asphere(ro,rd,vec3(3.,3.,3.),0.2))))));
}

// Function 1071
float DistanceField( vec3 p, float t )
{
	return
			min(min(min(
				Sphere(p,vec3(0,.48,0),.1),
				Oct(p,vec3(0,.2,0),.2)),
				CubeFrame(p,vec3(0,-.05,0),.3)),
				Sphere(p,vec3(0,-.6,0),.4));

	// spiral candle
/*	p.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);
	return max(
				max( p.y-.5, -p.y-1.),
				(min(
					max(abs(p.x),abs(p.z)),
					max(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0)
				)-.15)*.8);*/
}

// Function 1072
float sdScene(vec3 pos) {
 	return min(sdFloor(pos),sdSphere(pos, vec3(0.,0.5,-3.), .5));
}

// Function 1073
float sdf_box(vec3 p, vec3 center, vec3 half_bound)
{
    p = abs(p - center) - half_bound;
    return max3(p.x, p.y, p.z);
}

// Function 1074
shapeResult scene(vec3 at) {
    return add(
        sphere(vec3(30.0, 30.0, 30.0)
				#ifdef RANDOM_BALL_OFFSETS
					+ sin(floor(at.x / 60.0) * 2.0 + floor(at.y / 60.0) * 3.1 + floor(at.z / 60.0) * 4.6) * 16.0
				#endif
			, 5.0, MATERIAL_MIRROR, mod(at, 60.0)), 
        plane(terrainDetailed(at), MATERIAL_SAND, at.y)
    );
}

// Function 1075
float mapShell(in vec3 p0) {
    p0 -= vec3(1.3, 0, 0);
    vec3 p = p0;

    const float b = 0.17;

    float r = length(p.xy);
    float a = mix(0.0, 0.8, smoothstep(0.0, 1.0, 0.5*(r-0.6)));
    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;
    float t = atan(p.y, p.x);
 
    float n = (log(r)/b-t)/(2.0*PI);
    n = min(n, 0.0);

    float n0 = floor(n), n1 = ceil(n);
    float x0 = exp(b*(t+2.0*PI*n0));
    float x1 = exp(b*(t+2.0*PI*n1));
    float r0 = 1.0*x0;
    float r1 = 1.0*x1;

    float h0 = p.z + 0.4*(x0-1.0);
    float h1 = p.z + 0.4*(x1-1.0);
    float d0 = length(vec2(x0-r,h0)) - r0;
    float d1 = length(vec2(x1-r,h1)) - r1;

    float d, dx, dy;
    if (d0 < 0.0) d = d0, dx = x0-r, dy = h0;
    else if (d1 < 0.0 && d1<-d0) d = -d0, dx = x0-r, dy = h0;
    else if (d1 < 0.0) d = d1, dx = x1-r, dy = h1;
    else if (d0 < d1) d = d0, dx = x0-r, dy = h0;
    else d = d1, dx = x1-r, dy = h1;

    d += 0.002*r*sin(40.*t);
    d += 0.002*r*sin(40.*atan(dy,dx));

    d = abs(d)-0.1*r;
    d = max(d, p0.x);
    return d;
}

// Function 1076
Intersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj, lightPos);
    
    if(t == -1.0) {
        return Intersection(t, vec3(0.0, 0.0, 0.0), vec3(eye + 1000.0 * dir), -1);
    }

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    vec3 lightDir = normalize(lightPos - isect);
    
    vec3 material = computeMaterial(hitObj);

    float lambert = dot(normalize(lightPos - isect), nor) + 0.5;
   
    vec3 sdfColor = material * lambert;
    
    return Intersection(t, sdfColor, isect, hitObj);
}

// Function 1077
float sdf_mask(float sdf)
{
    float px = max(abs(dFdx(sdf)), abs(dFdy(sdf)));
    return sdf_mask(sdf, px);
}

// Function 1078
vec3 SceneNormal(vec3 p, float h, out float d)
{
    vec3 n = vec3(
          Scene(p + vec3(h,0,0))
        , Scene(p + vec3(0,h,0))
        , Scene(p + vec3(0,0,h))
      ) - (d = Scene(p));
    if (dot(n,n) < 1e-7) n = vec3(0,1,0);
    else n = normalize(n);
    return n;
}

// Function 1079
float map0(in vec3 p, bool tree, bool landscape) {
    float res = 1000.;
    if (tree)      res = min(res, mapTree0(p));
    if (landscape) res = min(res, sdLandscape(p));
	return res;
}

// Function 1080
float sdf(vec3 position){
    float Scale = 2.25;
    float Radius = .25;
    int Iterations = 6;
    mat3 Rotation;
    
    //float time = 75.;
    float time = 104.;
    //float time = 120.;
    
    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);
    Scale += sin(time*.5)*.25;
    Radius += cos(time) *.25;
    
    position *= Rotation;
	vec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;
	float C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));
	vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);
	for (int i=0; i< Iterations; i++) {
    	p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    	p.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);
        if(i < 3) p.xyz *= Rotation;
    	p.xyzw = p*scalevec + p0;
	}
	return (length(p.xyz) - C1) / p.w - C2;
}

// Function 1081
float sdf_line5(vec2 uv, vec2 vert_A, vec2 vert_B) {
    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!
    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B
    vec2 dvec_AB_rotated = dvec_AB.yx;  // Rotate by pi/2 radians, by "hand"
    dvec_AB_rotated.y *= -1.;           // Rotate by pi/2 radians, by "hand"
    float vector_projection_AP_ABr_snorm = dot(dvec_AP, normalize(dvec_AB_rotated));  // This is the signed-norm of the vector-projection of dvec_AP to dvec_AB_rotated
    return vector_projection_AP_ABr_snorm;  // And such signed-norm ends up being the signed distance we're after!
}

// Function 1082
vec2 map(vec3 pos)
{
    float tunnel = map_tunnel(pos);
    vec2 res = vec2(tunnel, TUNNEL_OBJ);
    #ifdef show_water
    float water = map_water(pos);
    if (traceWater)
       res = opU(res, vec2(water, WATER_OBJ));
    #endif
    float lamps = map_lamps(pos);
    #ifdef show_lamps
    res = opU(res, vec2(lamps, LAMPS_OBJ));
    #endif

    return res;
}

// Function 1083
float Scene(vec2 uv)
{
	float d = -sdRect(res/2.0 - 0.05, uv);
    
    vec2 rp = Rep2(uv, vec2(0.2));
    
    d = opU(sdCircle(0.02, rp), d);
    
    rp = Rep1(uv, 0.2);
    
    d = opU(sdRect(vec2(0.005,0.1), rp), d);
    
    d = opS(sdBox(0.2, uv), d);
    
    d = opU(sdRing(0.08, 0.09, uv), d);
    
    d = opS(sdRect(vec2(0.11,0.03), uv * Rotate(iTime)), d);
    
    return d;
}

// Function 1084
float sdfSphere(vec3 center, vec3 pos, float rad) {
	float dist = length(center - pos) - rad;
    
    return dist;
}

// Function 1085
float map( in vec3 pos )
{
    return sdRhombus(pos, 0.6, 0.2, 0.02, 0.02 ) - 0.01;
}

// Function 1086
vec2 map( vec3 q )
{
    float td = 0.03 * texCube( iChannel0, q, 0.25).x;
	return vec2(length(q - vec3(0.0, 0.22, 0.0)) - 2.25  + td, td);
}

// Function 1087
SRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir, int panel, in vec2 pixelPos)
{
    SRayHitInfo hitInfo;
    hitInfo.dist = c_rayMaxDist;
    
    // get a screen space random number to use for stochastic transparency
    float rng;
    {
        int frame = 0;
        #if ANIMATE_NOISE
            frame = iFrame % 64;
        #endif    
        if ((panel%3) == 0)
        {
            // white noise
            rng = hash13(vec3(pixelPos, float(frame)));
        }
        else if ((panel%3) == 1)    
        {
            // blue noise
            rng = texture(iChannel1, pixelPos / 1024.0f).r;
            rng = fract(rng + c_goldenRatioConjugate * float(frame));
        }
        else // if ((panel%3) == 2)
        {
            // interleaved gradient noise
            rng = InterleavedGradientNoise(pixelPos, frame);
        }
    }

    // the floor
    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))
    {
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        vec2 uv = hitPos.xz / 100.0f;
        float shade = mix(0.8f, 0.4f, checkersGradTriangle(uv));
        hitInfo.diffuse = vec3(shade, shade, shade);
    }
        
    // some floating spheres
	SRayHitInfo oldHitInfo;
    
    oldHitInfo = hitInfo;
    if (RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f)))
    {
        float alpha = 0.2f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f)))
    {
        float alpha = 0.4f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f)))
    {
        float alpha = 0.6f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 30.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f)))
    {
        float alpha = 0.8f;
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        
    
    oldHitInfo = hitInfo;
    if(RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 30.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f)))
    {
        float alpha = clamp((sin(float(iFrame % 120) / 120.0f * 2.0f * c_pi) * 0.75f + 0.5f), 0.0f, 1.0f);
        if (rng > alpha)
            hitInfo = oldHitInfo;
    }        

    
    return hitInfo;
}

// Function 1088
float map(vec3 p){
    //instancing:
    // you transform the space so it's a repeating coordinate system
    vec3 q = fract(p) * 2.0 -1.0;
    
  	//sphere map function is the length of the point minus the radius
    //it's negative on the inside of the sphere and positive on the outside and 0 on the surface.
    float radius = sphere_size;
 	return length(q) - radius;   
}

// Function 1089
float map (in vec3 p)
{
	float d = mandelbulb (p, 8. + 8.*(.5 + .5*cos(iTime)), 4., 8);
    return d;
}

// Function 1090
float Map( in vec3 p )
{
	vec3 q = vec3(abs(p.x),p.y,p.z); 
	
	return  min(
			   DistWalls(vec3(q.x,abs(q.y),abs(q.z))),
			   min(DistBox(q-vec3(0.0,-10.0,10.0),vec3(10.0)),DistBox(q-vec3(15.0,-15.0,0.0),vec3(10.0)))
			   );
}

// Function 1091
float SDF_particle(vec3 p0, vec3 p)
{
    particle point = get(fakech0, p0);
    return length(point.pos.xyz - p) - point.vel.w;
}

// Function 1092
float geometryDistance(vec3 p, rObj o) {
    if(o.gID == 1)
        return g1_plane(p, o);
    else if(o.gID == 2)
        return g2_sphere(p, o);
    return 100.0;
}

// Function 1093
float sdf_line0(vec2 uv, vec2 vert_A, vec2 vert_B){
    float delta_y = vert_B.y - vert_A.y;
    float delta_x = vert_B.x - vert_A.x;
    float slope = delta_y / delta_x;  // Slope of the line given 2 vertices on the line
    float y_intersect = vert_A.y - slope * vert_A.x;  // This is the y-coordinate of the point (0,y) in R2 that is also in the line

    // There's many representations for a line. This is just one of them:  ax + by + c = 0.
    // Namely, a line on the plane R2 is the set of all points (x,y) in R2 that satisfy
    // the equation  ax + by + c = 0.
    // The letters `a`, `b`, and `c` are real numbers, and they encode information
    // about the slope of the line and the points it passes through!
    float coeff_a = slope;
    float coeff_b = -1.;
    float coeff_c = y_intersect;
    float norm = sqrt(coeff_a * coeff_a + coeff_b * coeff_b);
    float standard_form = coeff_a * uv.x + coeff_b * uv.y + coeff_c;

    // Why does this end up being the signed distance to our line? I'm not sure, yet!
    // But I stole the idea from Chapter 1 of
    // https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000&context=facpub
    return standard_form / norm;
}

// Function 1094
vec2 Scene(vec3 p, float shadow)
{
    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));
    absp -= vec3(0.0, 0.0, 40.0);
    
    float result = FarClip;
    
    float steps     = min(Steps(absp), Steps(RotY(absp + vec3(-12.0, -3.4, -20.0), PI * 1.5)));
    float base      = Base(absp);
    float walls     = Walls(absp);
    float hallway   = Hallway(absp);
    
    result = min(result, steps);
    result = min(result, base);
    result = min(result, walls);
    result = max(result, -hallway);
    
    if(shadow > 0.5)
    {
        // Add a circle shadow for the user
        result = min(result, length(p - Camera_GetPosition()) - 1.0);
    }
    
    if(p.y < result)
    {
        return vec2(p.y, 0.0);
    }
    
    return vec2(result, 1.0);
}

// Function 1095
vec2 dist2(vec3 p)
{
	vec2 f1 = terra(p);
	vec2 f2 = water(p);
	return vec2(min(f1.x,f2.x),f1.y+f2.y);
}

// Function 1096
float3 TonemapInvert(float3 c) { return c; }

// Function 1097
float mapDamageHigh( vec3 p ) {
    float d = map( p );
    
    float p1 = noise( p*2.3 );
    float p2 = noise( p*5.3 );
    
    float n = max( max( 1.-abs(p.z*.01), 0. )*
                   max( 1.-abs(p.y*.2-1.2), 0. ) *
                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);
    
    if( p.y < .1 ) {
        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);
    }
    
    if( abs(n) > 0.0 ) {
        n += noise( p*11.) * .05;
        n += noise( p*23.) * .03;
    }
    
	return d + n;
}

// Function 1098
float dist(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)
{
    t = clamp(t, 0., 1.);
    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);
}

// Function 1099
float map( const in vec3 p ) {
	vec3 pd = p;
    float d;
    
    pd.x = abs( pd.x );
    pd.z *= -sign( p.x );
    
    float ch = hash( floor( (pd.z+18.*time)/40. ) );
    float lh = hash( floor( pd.z/13. ) );
    
    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );
    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );
    
    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );
    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );
    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );
   
    if( lh > 0.5 ) {
	    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );
    }
    
    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );
	d = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); 
    
    d = opS( d, -(p.x+8.) );
    d = opU( d, pd.y );

    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );
    
    // car
    if( ch > 0.75 ) {
        pdc.x += (ch-0.75)*4.;
	    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );
	    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );

        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );
 	}
    
    d = opU( d, 13.-pd.x );
    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );
    d = opU( d, dL );
    
	return d;
}

// Function 1100
float distancePixel(vec2 prevFragCoord, vec4 hit){
    if(  min(iResolution.xy, prevFragCoord) != prevFragCoord
      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MaxDist;
    vec4 prevPos = texture(iChannel2, prevFragCoord/iResolution.xy);
    Camera cam = getCam(iTime);
    return length(prevPos-hit);
}

// Function 1101
vec4 calcCloudHeightMap_bufA( vec2 fragCoord, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel0, sampler2D aChannel1 )
{
	int calculate_bufA_every_frame = 0;

	bool resized = ( aResolution != texelFetch( aChannel1, ivec2( aResolution.xy ) - ivec2( 1, 1 ), 0 ).xyz ); // check the resolution we think we have (should have been written in the top right pixel of bufB)

	if ( !resized && ( calculate_bufA_every_frame == 0 ) && aFrame > 2 ) return texture( aChannel0, fragCoord.xy / aResolution.xy ); // reuse

	vec2 uv = fragCoord.xy / aResolution.xy;
	vec4 tex = vec4( 0.0 );
	 // s must be integer
	{ float s =  8.; tex.x = alligator6_12( uv.xy * s, s ); }
	{ float s =  4.; tex.y = alligator6_12( uv.xy * s, s ); }
	{ float s = 10.; tex.z = alligator6_12( uv.xy * s, s ); }
	return tex;
}

// Function 1102
float mapTrees( in vec3 pos, out vec4 suvw, out float info )
{
    float dis;
	
	//-----------------------------
	// terrain
	float h = terrain( pos.xz );
	float mindist = pos.y - h;

	float t = treeBase( pos.xz );
	float treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);
	suvw = vec4( 0.0, 0.0, 0.0, treeOcc );

	// grass
	vec2 gd = grassDistr(pos.xz);
	float hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );
	float g = 0.2*hi * (gd.x * gd.y);
    mindist -= g;

	suvw.w *= mix( smoothstep( 0.5, 1.0, hi ), 1.0, 1.0-gd.x );
	suvw.w *= 0.2 + 0.8*clamp( 2.0*abs(gd.x-0.5), 0.0, 1.0 );
	
	//-----------------------------
	// trees
	{
	float chsca = 0.2;
	vec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );
	float y = chos.y;
	float r = length( chos.xz );
		
	float ss = exp(-40.0*y*y);
	float dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );
	float sh = 0.08 + (0.1+0.25*ss)*dd;
		
    dis = (r - sh)/chsca;
	if( dis<mindist )
	{
		mindist = dis;
		suvw.x = 1.0;
		suvw.y = y;
		suvw.z = smoothstep( 0.0, 1.0, dd );
		suvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);
		info = atan( chos.x, chos.z );
	}		
		
    }
        return mindist * 0.5;

}

// Function 1103
vec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)
{
    vec3 finalColor = GetEnvMap(rayDir, sunDir);

    // Make a skyscraper skyline reflection.
    float radial = atan(rayDir.z, rayDir.x)*4.0;
    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);
    radial *= 4.0;
    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;
    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);
    float vert = sign(sin(radial*32.0))*0.5+0.5;
    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;
    mask = saturate(mask + (1.0-hor*vert)*0.05);
    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);

	return finalColor;
}

// Function 1104
vec2 mapToScreen (in vec2 p)
{
    vec2 res = p;
    res = res * 2. - 1.;
    res.x *= iResolution.x / iResolution.y;
    
    return res;
}

// Function 1105
float get_distance(vec3 pos) {
    return pos.z - get_height(pos.xy);
}

// Function 1106
vec4 spheresdf(vec3 pos) {
    vec3 center = vec3(-3, 0, 1.5);
    float d = length(pos - center);
    vec3 norm = (pos - center) / d;
    return vec4(norm, d - 1.0);
}

// Function 1107
vec4 map(vec3 p)
{
	p.xy -= path(p.z);													// tunnel path
	
    // mix from displace of last section id with displace of current section id accroding to id range 
    float r = mix(displace(p, lid), displace(p, cid), fract(cid)); 	// id range [0-1]
	
    p *= getRotZMat(p.z*0.05);
	
    p = mod(p, 10.) - 5.;
    
    return vec4(abs(p.y)+2. - 1. + r, p);
}

// Function 1108
vec4 map2(vec3 pos)
{
    return mapRaw(pos);
}

// Function 1109
vec3 FilmicTonemapping(vec3 x)
{
	return ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;
}

// Function 1110
vec4 fake_cubemap(in vec3 in_dir) {
    vec3 dir = in_dir / max(abs(in_dir.z), max(abs(in_dir.x), abs(in_dir.y)));
    vec4 colz = texture(iChannel0, 0.5 + 0.5 * dir.z * dir.xy);
    vec4 colx = texture(iChannel0, 0.5 + 0.5 * dir.x * dir.yz);
    vec4 coly = texture(iChannel0, 0.5 + 0.5 * dir.y * dir.zx);
    
	vec3 weights = smoothstep(vec3(0.9), vec3(1.0), abs(dir));
    
    return (weights.x * colx + weights.y * coly + weights.z * colz) / dot(vec3(1.0), weights);
}

// Function 1111
vec4 MAP_REFLECTION_Scene(vec3 p, vec3 eye, int mode) { // Main Reflection Scene
	float fulldist = 9999.0;
    float dist = fulldist;
    vec3 color = DEFAULT_MESH_COLOR;
    vec3 n = mode == 1 ? GetNormalForReflection(p) : vec3(0.0);
    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);
    
    // Red Sphere
    {
        vec3 sphereColor = vec3(1.0, 0.0, 0.0);
        float sphereRadius = 1.0;
        vec3 spherePosition = vec3(0.0, 1.0, 0.0);
        float sphereDist = length(p-spherePosition)-sphereRadius;
        if (sphereDist < dist) {
            color = sphereColor*diff;
            dist = sphereDist;
        }
    }
    
    // Ocean
    {
        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);
        float oceanHeight = 0.0;
        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);
        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;
        if (oceanDist < dist) {
            color = oceanColor;
            dist = oceanDist;
        }
    }
    
    return vec4(color, dist);
}

// Function 1112
float SDF_Teeth(vec3 p, float mouthSDF)
{
    // Slide the teeth up/down as the mouth opens...
    float yoff = 0.045 * clamp(TimeRatio() * 4.0, 0.0, 1.0) * 2.0;
    
    // Repeat the teeth. Pull them back slightly as they get away from x=0.0
    vec3 tp = Translate(p, vec3(0.0, -0.275, 0.925 - abs(p.x) * 0.35));
    tp = Repeat(tp, vec3(0.165, 0.15 + yoff, 0.0));
    
    // The vertical gap between teeth is at y=-0.275
    // This sharpens the teeth slightly as they near the space between rows.
    float r = mix(1.0, 0.0, clamp(abs(p.y + 0.275) / 0.5, 0.0, 1.0)) * 0.085;
    
    float teeth = udRoundBox(
        tp,
        vec3(
            0.12 - r, 
            0.0425, 
            0.025),
        0.02);
    
    return max(mouthSDF, teeth);
}

// Function 1113
float planeSDF(vec3 p, vec4 plane) { return dot(p, plane.xyz) + plane.w; }

// Function 1114
void scene2D( out vec4 fragColor, in vec2 fragCoord )
{
    fragColor = vec4(0.0,0.0,1.0,1.0);
    vec2 uv = fragCoord/iResolution.xy;
    vec2 muv = iMouse.xy/iResolution.xy;
    
    vec4 incol = texture(iChannel0, uv);
    float colored = 0.;
    
    bool isPath = bool(incol.w);
    bool isCurrent = bool(incol.z);
    
    vec3 pickRGB = get_color(iChannel0);
    float override = get_override(iChannel0);
    bool click = iMouse.w > 0.5;
    float blend_factor = get_blend_factor(iChannel0);
    float fade = get_gradient_func(iChannel0);
    
    vec2 minMain, maxMain;

    getTexBBox(getTextureIndex(get_texture_index(iChannel0)), minMain, maxMain);

    vec4 fromUv = vec4(0., SEL_ZONE_Y, 1., 1.);
    vec4 toUv = vec4(minMain, maxMain);
    vec2 tuv = convertUv(uv, fromUv, toUv);

    vec4 ccol = texture(iChannel1, uv);
    vec4 switchCol = texture(iChannel2, tuv);
    float radius = RADIUS_COEFF*get_radius(iChannel0);
    
    //float defaultCol = get_default_draw_color(iChannel0);
    
    vec4 texParams = get_texture_params(iChannel0);
    float texIdx = texParams.w;
    float stexIdx = texParams.z;
    
    float i_main = getTextureIndex(texIdx);
    float i_second = getTextureIndex(stexIdx);
    
    bool block = false;
    
    if ((i_main) != (i_second) && get_color_block(iChannel0) > 0.5)
    {
        vec2 minSecond, maxSecond;
        getTexBBox(i_second, minSecond, maxSecond);
    	vec4 stoUv = vec4(minSecond, maxSecond);
        vec2 stuv = convertUv(uv, fromUv, stoUv);
        vec2 mstuv = convertUv(muv, fromUv, stoUv);
        
        vec4 muvcol = texture(iChannel2, mstuv);
        vec4 uvcol = texture(iChannel2, stuv);
        
        vec4 dv = abs(muvcol - uvcol);
        
        block = step(0.01, max(dv.x, max(dv.y, dv.z))) > 0.5;
    }
    
    vec3 col;
    
    if (get_load_texture(iChannel0) || !texture_store(iChannel0))
    {
        col = switchCol.rgb;
        colored = switchCol.w;
    }
    else if (isPath && isCurrent && block)
    {
        col = ccol.rgb;
        colored = ccol.w;
    }
    else if (isPath && ccol.w < 0.5 && click && isCurrent && getIValue(override, BLEND_OPER_NUM) != BLEND_OPER_SMOOTH)
    {
        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_FIRST)
    {
        col.rgb = ccol.rgb;
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_SECOND)
    {
        
        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MIX && click)
    {
        col.rgb = mix(ccol.rgb, fadeColor(pickRGB, fade, radius, muv, uv), blend_factor);
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MAX && click)
    {
        col.rgb = max(ccol.xyz, fadeColor(pickRGB, fade, radius, muv, uv));
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_MIN && click)
    {
        col.rgb = min(ccol.rgb, fadeColor(pickRGB, fade, radius, muv, uv));
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_BIN && click)
    {
        col.rgb = fadeColor(pickRGB, fade, radius, muv, uv);
        //colored = 1.;
    }
    else if (isPath && ccol.w > 0.5 && isCurrent && getIValue(override, BLEND_OPER_NUM) == BLEND_OPER_SMOOTH && click)
    {
        vec3 ncol = vec3(0.);
        ivec2 nr = ivec2(mod(fragCoord + vec2(1., 0.), iResolution.xy));
        ivec2 nl = ivec2(mod(fragCoord - vec2(1., 0.), iResolution.xy));
        ivec2 nu = ivec2(fragCoord + vec2(0., 1.));
        ivec2 nd = ivec2(fragCoord - vec2(0., 1.));
        
        float wr = step(.5, iResolution.x - float(nr.x));
        float wl = step(-.5, float(nl.x));
        float wu = step(.5, iResolution.y - float(nu.y));
        float wd = step(.5, float(nd.y) - ceil(SEL_ZONE_Y*iResolution.y));
        
        vec4 cr = texelFetch(iChannel1, nr, 0);
        vec4 cl = texelFetch(iChannel1, nl, 0);
        vec4 cu = texelFetch(iChannel1, nu, 0);
        vec4 cd = texelFetch(iChannel1, nd, 0);
        
        float nnum = 0.;
        if (wr > 0.5 && cr.w > 0.5)
        {
            ncol += cr.rgb;
            nnum += 1.;
        }
        if (wd > 0.5 && cd.w > 0.5)
        {
            ncol += cd.rgb;
            nnum += 1.;
        }
        if (wl > 0.5 && cl.w > 0.5)
        {
            ncol += cl.rgb;
            nnum += 1.;
        }
        if (wu > 0.5 && cl.w > 0.5)
        {
            ncol += cu.rgb;
            nnum += 1.;
        }
        
        ncol /= nnum;
        
        if (length(ncol - ccol.rgb) > blend_factor*0.1)
        {
            col.rgb = ncol;
        }
        else
        {
            col = ccol.rgb;
        }
        colored = 1.;
    }
    else if (isPath && ccol.w > 0.5)
    {
        col.xyz = ccol.xyz;
        colored = 1.;
    }
    else if (!isPath)
    {
        col.xyz = vec3(0.);
    }
    
    if (get_control_zone(uv) > 0.5) // ctrl zone.
    {
        col.xyz = vec3(0.0);
    }
    
    fragColor = vec4(col.xyz, colored);
}

// Function 1115
float getPlaneDist(vec3 p) {
    //plane is at y = 0, so 
    //y component is the distance
	return p.y;
}

// Function 1116
vec3 DrawMap( vec2 vPixelCoord, vec2 vResolution )
{
    vec3 vResult = vec3(0.0);
    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 31.0);
    
    float fScale = 5.0;
    
    vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;

    MapInfo mapInfo = ReadMapInfo( MAP_CHANNEL );
    
    //if ( Key_IsToggled( KEY_TAB ) )
    {
        for(int iSectorIndex=0; iSectorIndex<mapInfo.iSectorCount; iSectorIndex++)
        {
            Sector sector = Map_ReadSector( MAP_CHANNEL, iSectorIndex );
            
            /*if ( Map_PointInSector( vPixelWorldPos, sector ) )
            {
                vResult = vec3(1,0,0);
            }*/
            

            for(int iSideDefIndex=0; iSideDefIndex<sector.iSideDefCount; iSideDefIndex++)
            {
                SideDef sideDef = Map_ReadSideDefInfo( MAP_CHANNEL, iSectorIndex, iSideDefIndex );                        

                vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );

                float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );
                fProj = clamp( fProj, 0.0, sideDef.fLength );
                
                vec2 vClosest = sideDef.vA + vSideDir * fProj;
                float fDist = length( vClosest - vPixelWorldPos );
                
                if (fDist < fScale * .5 )
                {
                    if ( sideDef.iNextSector != SECTOR_NONE )
                    {
	                    vResult = vec3(1,1,0);
                    }
                    else
                    {
	                    vResult = vec3(1,0,0);
                    }
                }
            }			
        }
    }    
    
    return vResult;
}

// Function 1117
float get_distance_along_2d_line_nearest_to_point(
    in vec2 A0,
    in vec2 A,
    in vec2 B0
){
    return dot(B0 - A0, A);
}

// Function 1118
float get_mipmap_level(vec2 uv) {
    vec2 dx = dFdx(uv);
    vec2 dy = dFdy(uv);
    return 0.5 * log2(min(dot(dx, dx), dot(dy, dy)));
}

// Function 1119
vec3 map_Gsph_norm(vec3 ro) {
    return normalize(ro - Gsphere.xyz);
}

// Function 1120
float sdf_e(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4.5, 0), vec3(4, -4.5, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4.5, 0), vec3(4, -4, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));
    return t;
}

// Function 1121
float sdf_i(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -0.5, 0)));
    return t;
}

// Function 1122
float dist_horizontal_line( vec3 p)
{
  return length(vec2(length(p.xy)-1.0,p.z));
}

// Function 1123
float distToExitPlanet(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;
    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);
}

// Function 1124
vec4 map(vec3 rp)
{
	vec4 d = vec4(0.0);
	  
    vec3 bgCol = vec3(0.125,0.125,0.125);
    
    #ifdef ENABLEWAVE
    float waveF = texture(iChannel0, vec2((rp.x+1.8)/3.6, 0.75)).r;
    float waveDist = udBox(rp-vec3(0.0,-waveF*WAVEAMP+WAVEAMP/2.0,0.25), vec3(1.8,0.02,0.001));
    vec4 wave = vec4(vec3(0.3), waveDist);
    #endif
    
    float backWallDist = udBox(rp-vec3(0.0,0.0,0.75), vec3(1.8, 1.1, 0.5));
    vec4 backWall = vec4(bgCol, backWallDist);
    
    float edgeLeftDist = udBox(rp-vec3(1.9,0.0,0.3725), vec3(0.1,1.1,1.0));
    vec4 edgeLeft = vec4(bgCol, edgeLeftDist);
    
    float edgeRightDist = udBox(rp-vec3(-1.9,0.0,0.3725), vec3(0.1,1.1,1.0));
    vec4 edgeRight = vec4(bgCol, edgeRightDist);
    
    float edgeTopDist = udBox(rp-vec3(0.0,1.2,0.3725), vec3(2.0,0.1,1.0));
    vec4 edgeTop = vec4(bgCol,edgeTopDist);
    
    float edgeBotDist = udBox(rp-vec3(0.0,-1.2,0.3725), vec3(2.0,0.1,1.0));
    vec4 edgeBot = vec4(bgCol,edgeBotDist);
    
    d = edgeLeft.a > backWall.a ? backWall : edgeLeft;
    d = edgeRight.a > d.a ? d : edgeRight;
    d = edgeTop.a > d.a ? d : edgeTop;
    d = edgeBot.a > d.a ? d : edgeBot;
    
    #ifdef ENABLEWAVE
    d = wave.a > d.a ? d : wave;
    #endif   

    return d;
    
}

// Function 1125
vec2 sceneDistance( in vec3 point, in float dizzy ) {
    vec2 d = vec2( RAY_MARCH_TOO_FAR, 0. );
 
    float g = ground( point );
    
    d = which( d, tree( point, dizzy ) );
    d = which( d, vec2( point.y + g , GROUND ) );
    
    float snow = noise( point * 1.2357 );
    d = which( d, vec2( point.y + g + snow , SNOW ) );
    
    return d;
}

// Function 1126
float sdf_X(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(0, -8, 0)));
    return t;
}

// Function 1127
float boxDistance(vec3 pos, vec3 center, vec3 scale) {
    vec3 localPos = pos - center;
    vec3 boxPos = clamp(localPos, -scale*0.5, scale*0.5);
    return length(pos - boxPos - center);
}

// Function 1128
bool scene(Point3 X, inout float distance, inout Material material) {
    bool hit = false;
    
    // Union of two spheres:
    hit = distanceEstimator(box, X, distance, material) || hit;
    hit = distanceEstimator(sphere2, X, distance, material) || hit;
    return hit;
}

// Function 1129
float sphereDist(vec4 sphere, vec3 point)
{
    return length(point - sphere.xyz) - sphere.w;
}

// Function 1130
float SDFSine( in vec2 coords )
{
    float v = sin(coords.x) - coords.y;
    vec2  g = vec2(cos(coords.x), -1);
    return abs(v)/length(g);
}

// Function 1131
float occlusionMap(in vec2 uv) {
    vec2 occlusionLoc = iMouse.xy/iResolution.xy;
    if (iMouse.w < 1.) {
        occlusionLoc = vec2(sin(iTime*.6)*.2+.5,cos(iTime*.76)*.2+.5);
    }    
    float d = length(max(abs(uv-occlusionLoc)-vec2(occlusionSize),0.));
    d = max(-(length(mod(uv-occlusionLoc,occlusionSize*.5)-occlusionSize*.25)-occlusionSize.x*.5),d);
    return floor(1.03-d);
}

// Function 1132
float dstScene(vec3 p) {
    float h = texture(iChannel1,p.xz).x * .01;
    float d = p.y - h;
   	return d;
}

// Function 1133
float scene_d(vec3 p)
{
    //float d = length(p)-1.;
    //float d = ngon_d(rot2d(p.xy-vec2(0,-1), radians(90.+10.*iTime)), 5, .5);
    //vec3 axis = vec3(0,0,1);
    //float d = ngon_d(rot3d(p, axis, radians(90.+10.*iTime)), 5, .5);
    //float d = ngon_d(rot3d(p-vec3(1,-1,1), axis, radians(90.+10.*iTime)), 5, .5);
    vec3 pp = rot3d(p,vec3(0,1,0), iTime);
    float d = dodeca(pp, 1.);
    d = min(d, p.y+4.); // ground plane
    //d = min(d, length(p.yz)-0.05); // x axis
    d = min(d, length(p.xz)-0.05); // y axis
    //d = min(d, length(p.xy)-0.05); // z axis
    return d;
}

// Function 1134
float distanceFromLineSegment(vec2 p, vec2 start, vec2 end) {
    float len = length(start - end);
	float l2 = len * len; 
	if (l2 == 0.0f) return length(p - start);   
	float t = max(0.0f, min(1.0f, dot(p - start, end - start) / l2));
	vec2 projection = start + t * (end - start);
	return length(p - projection);
}

// Function 1135
float map(vec3 p){
vec3 ps = p;
vec3 pf = p ;
vec3 pt = p;
float l1 = 100.;
vec3 bs = vec3(0.,-3.5,0.);
float ta = mix(1.5,.3,smoothstep(0.,8.,abs(p.y)));
float ft = fract(iTime*0.5);
float t = sin(sin(iTime*0.1)*0.1*pow(mix(ft,1.-ft,step(0.5,fract(iTime*0.25))),1.5))*sin(iTime*0.1)*180.;
p.xy *= rot(p.y*sin(iTime)*0.2);
p.xz *= rot(p.y*sin(iTime+0.5)*0.2);
vec3 p2 = p;
vec3 p3 = p;
float l2 = 1000.;float l3 = 1000.;
p2.xz *= rot(3.14);
for(int i = 0 ; i <5 ; i++){
float ip = float(i);
vec3 v0 = vec3(sin(ip-1.+t),sin(ip-1.+t),cos(ip-1.+t)*0.5)*2.;
vec3 v1 = vec3(sin(ip+t),sin(ip+t),cos(ip +t)*0.5)*2.;
bs +=vec3(0.,1.5,0.);
v0 +=bs-vec3(0.,0.75,0.);
v1 += bs+vec3(0.,0.75,0.);
l1 = min(l1,cap(p,v0,v1)-ta);
l1 = min(l1,cap(p2,v0,v1)-ta*0.5);
l1 = min(l1,cap(p3,v0,v1)-ta*0.25);
l3 = min(l3,length(ps+v0*vec3(2.,1.,2.))-0.3);
}
zb = 1.;
float r1 =  min(l1,l2);
float r2 = r1-hs(p)*0.003;
float r3 = min(r2,l3);
float s = dot(ps,vec3(0.,1.,0.))+4.;

if(r2<min(s,l3)){zb = 0.;}
return min(r3,s);}

// Function 1136
vec4 map(vec3 p) {
    vec4 res = vec4(1e10, 0.0, 0.0, 0.0);
    {
    res = opU(res, vec4(sdSphere(p, 1.0),vec3(0.0)));
    }
    return res;
}

// Function 1137
float map_detailed(vec3 p, float SEA_TIME) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_FRAGMENT; i++) {        
    	d = sea_octave((uv+SEA_TIME)*freq,choppy);
    	d += sea_octave((uv-SEA_TIME)*freq,choppy);
        h += d * amp;        
    	uv *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 1138
float distRim(vec3 p, float r)
{
    r*=.6;
    vec3 p0=p;
    p.x=abs(p.x);
    //p.yz=(p.y>p.z)?p.zy:p.yz; // only first 1/8 segment
    p=p.zxy;
    float d=1000.;
    d=min(d,sdRoundedCylinder(p,r,.01,.6*r));
    p-=vec3(0,.6*r,0);
    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.6*r),.015);
    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.8*r),.015);
    float d_i=sdRoundedCylinder(p,.77*r,.01,1.9*r);
    d=-smin(-d,d_i,.015);
    
    float d2=length(p0-vec3(-r*.6,0,0))-r*1.05;
    d2=max(d2,d_i);
    d2=-smin(-d2,sdRoundedCylinder(p,.4*r,.01,.8*r),.1);
    d2=abs(d2)-.005;
    d2=max(d2,-p0.x);

    float mang,ang;
    float ang0 = atan(p.z,p.x);
    float dang=PI2/5.;
    mang=mod(ang0,dang);
    ang=ang0-mang+dang*.5;

    d2=-smin(-d2,(length(p.xz-.95*r*cos(ang-vec2(0,1.57)))-.25*r),.01);
    d=min(d,d2);
    dang=PI2/5.;
    mang=mod(ang0,dang);
    ang=ang0-mang+dang*.5;
    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.3*r*cos(ang-vec2(0,1.57)))-.05*r)));
    d=min(d,sdRoundedCylinder(p-vec3(0,-.23,0),.1*r,.01,.25));
    float l=length(p0.zx);
    d=min(d,sdRoundedCylinder(p0.zxy-vec3(0,-.06,0),.7*r,.02,.05-.015*fermi((length(p.xz)-.6*r)/.003)));
    return d;
}

// Function 1139
float get_dist_to_next(float box_size, vec3 current, vec3 dir) {
    // get the local point in  the box
	vec3 local = fract(current / box_size);
    // get the box position
    vec3 box = floor(current / box_size);
    // trace to box boundary
    vec3 m = 1.0 / dir;
    vec3 n = m*(local-vec3(0.5));
    vec3 k = abs(m);
    vec3 t = k - n;
    float dist = min(min(t.x, t.y), t.z) + 0.0001;
    // transform to global space again
    return dist*box_size;
}

// Function 1140
vec3 map( in vec3 p )
{
    vec3 res = vec3(length(p-gVerts[0]),0.0,0.0);

    
    //   2---3
    //  /   /|
    // 6---7 |
    // |   | 1
    // 4---5/
    
    vec3 tmp;
    tmp = sdBilinearPatch(p, gVerts[0], gVerts[2], gVerts[3], gVerts[1]); if( tmp.x<res.x ) res = tmp;
    tmp = sdBilinearPatch(p, gVerts[7], gVerts[6], gVerts[4], gVerts[5]); if( tmp.x<res.x ) res = tmp;
    tmp = sdBilinearPatch(p, gVerts[0], gVerts[1], gVerts[5], gVerts[4]); if( tmp.x<res.x ) res = tmp;
    tmp = sdBilinearPatch(p, gVerts[2], gVerts[6], gVerts[7], gVerts[3]); if( tmp.x<res.x ) res = tmp;
    tmp = sdBilinearPatch(p, gVerts[0], gVerts[4], gVerts[6], gVerts[2]); if( tmp.x<res.x ) res = tmp;
    tmp = sdBilinearPatch(p, gVerts[1], gVerts[3], gVerts[7], gVerts[5]); if( tmp.x<res.x ) res = tmp;
    
    res.x -= kRoundness; // round it a bit
    return res;
}

// Function 1141
float PlaneSDF(vec3 p, float y)
{
    return p.y+y;
}

// Function 1142
void MapWhiteKeys(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos - vec3(-2.0, 80.5, -7.5);
	float re = MapBoxSim(pos, vec3(63.0, 1.5, 7.5));
	if (re <= EPSILON)
	{
		obj.m_obj_idx = 3;
	}
	obj.m_dist = re;
}

// Function 1143
float fSDF(vec3 posWS, bool doVolumetric, out vec4 material)
{
    float minDist = kMaxDist;
    
    vec2 groundUv = posWS.xz + oz.xx*3.0;
    float groundNormalisedDisp = 0.0;
    if(posWS.y < 0.3)
    {
        groundNormalisedDisp = textureLod(iChannel2, groundUv * 0.05, 0.0).r;
    }
    
    float fireD;
    vec4 campfireLogsMaterial;
    float campfireLogsD = fCampfireLogs(posWS, doVolumetric, campfireLogsMaterial, fireD);
    if(campfireLogsD < minDist)
    {
        minDist = campfireLogsD;
        material = campfireLogsMaterial;
    }
    
    
    vec4 campfireRocksMaterial;
    float campfireRocksD = fCampfireRocks(posWS, campfireRocksMaterial);
    //Add some extra noise to the rocks distance
    campfireRocksD -= groundNormalisedDisp * 0.02;
    if(campfireRocksD < minDist)
    {
        minDist = campfireRocksD;
        material = campfireRocksMaterial;
    }
    
    vec4 coalsMaterial;
    float coalsD = fCoals(posWS, coalsMaterial);
    //Fatten the coals using the ground displacement texture to randomize their shape
    coalsD -= groundNormalisedDisp * 0.035; 
   	if(coalsD < minDist)
    {
        minDist = coalsD;
        material = coalsMaterial;
        material.y = fireD + (material.y  - 0.5)*0.5;
    }
    
    //Ground plane
    float groundDisp = groundNormalisedDisp * 0.05;
    float groundD = posWS.y - groundDisp;

    if(groundD < minDist)
    {
	    material.x = kMatGround;
    	material.yz = groundUv;
    	float ambientVis = 0.99 * linearstep(0.0, 0.1, campfireRocksD);
        
    	vec2 uv = material.yz;
        material.w = groundNormalisedDisp;
        
        //Pack the ambient and the material in W
        material.w = floor(material.w * 256.0) + ambientVis;
        minDist = groundD;
    }    
    
    return minDist;
}

// Function 1144
vec3 mapRMWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapWaterDetailed(pt);    
    normal.x = mapWaterDetailed(vec3(pt.x+e,pt.y,pt.z)) - normal.y;
    normal.z = mapWaterDetailed(vec3(pt.x,pt.y,pt.z+e)) - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 1145
SceneResult Scene_GetDistance( vec3 vPos, int insideObjId )
{
#if TEST_TUBES_SCENE
    return Scene_TubesSceneGetDistance( vPos, insideObjId );
#elif GEARS_SCENE
    return Scene_GearsSceneGetDistance( vPos, insideObjId );
#elif PIPELINE_SCENE    
    return Scene_PipelineSceneGetDistance( vPos, insideObjId );
#elif LIGHT_BULB_SCENE
    vPos.x = -vPos.x;
    vPos.z = -vPos.z;
    vPos -= vec3(-1,1.5,3);
    return Scene_LightBulbSceneGetDistance( vPos, insideObjId );
#else
    return Scene_TestSceneGetDistance( vPos, insideObjId );
#endif
}

// Function 1146
mat3 traceScene( vec3 ro, vec3 rd) {
    //sphere intersection
    vec3 oc = ro - sphere.xyz;
    float c = dot( oc, oc ) - sphere.w*sphere.w;
    float bs = dot( oc, rd );
    float hs = sqrt(bs*bs - c);
    float sphereDepth = zfar;
    if (hs > 0.) {
        if (bs < 0.) sphereDepth = -bs - hs;
    }
    //now the light
    oc = ro - light.xyz;
    c = dot( oc, oc ) - light.w*light.w;
    float bl = dot( oc, rd );
    float hl = sqrt(bl*bl - c);
    float lightDepth = zfar;
    if (hl > 0.) {
        if (bl < 0.) lightDepth = -bl - hl;
    }
    //plane intersection
    float planeAng = dot(plane[1], rd);
    float planeDepth = dot(plane[1], plane[0] - ro) / planeAng;
    if (planeDepth < 0. || planeDepth > zfar) planeDepth = zfar;
    
    //depth test
    if (sphereDepth < planeDepth && sphereDepth < lightDepth) {
        vec3 sloc = ro+rd*sphereDepth;
        return mat3(sloc,
                   (sloc-sphere.xyz) / sphere.w,
                   vec3(max(0., sphereDepth), hs/sphere.w, mtSphere));
    } else if (planeDepth < sphereDepth && planeDepth < lightDepth) {
		return mat3(ro+rd*planeDepth,
                    plane[1],
                    vec3(max(0., planeDepth), planeAng+1.+plane[2].x, mtGround));
    } else if (lightDepth < planeDepth && lightDepth < sphereDepth) {
        vec3 sloc = ro+rd*lightDepth;
        return mat3(sloc,
                    sloc / light.w,
                    vec3(max(0., lightDepth), light.w, mtLight));
    } else {
        return mat3(vec3(map(rd * (0.3+0.1*sin(iTime*0.1)))), vec3(rd), vec3(zfar, zfar, 0.));
    }
}

// Function 1147
vec3 map(vec3 p) {
	vec3 pp = p;
	
	//ground
	float k = plane(pp, 0.7);
	
	//PYRAMID
	pp = mod(-abs(p), 1.0) - 0.5;
	
	float tim = iTime * 4.0 + sin(iTime * 3.0) * 2.0;
	for(int e = 0 ; e < 6; e++) {
		//rotate
		if( floor(float(e) / 2.0) > 0.0 ) tim = -tim;
		vec3 ppp = pp;
		ppp.xz = rot(ppp.xz, tim * 0.3 + ceil(p.z) / (1.5));
		k = min(k, max(ppp.y - 0.07 * float(e), hexp(ppp.xz, vec2(0.48 - 0.08 * float(e)))) );
	}
	return vec3(pp.xz, k);
}

// Function 1148
float SDFobj (vec3 p) {
    float SDFobjp = 1e4;
    SDFobjp = length(p-vec3(0., 2., 0.))-2.;
    vec3 q = vec3(abs(p.x), abs(p.y-1.), abs(p.z));
    // rigid (/slightly discontinuous)
    // return max(max(p.x, p.y), p.z)-1.;
    // new rounded some help from iq
    float w = 1.;
    float l = 1.;
    float h = 1.;
    q = vec3(max(q.x-w, 0.), max(q.y-h, 0.), max(q.z-l, 0.));
    SDFobjp = length(q)-.115;
    SDFobjp = max(SDFobjp, mix(0., 3.6, .5+.5*sin(iTime*.5))-length(p-vec3(1., 2., -1.)) );
    return SDFobjp;
}

// Function 1149
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = DE(eye + depth * marchingDirection);
        if (dist < EPSILON) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 1150
void sceneMap3D(vec3 pos, out float t, out int obj) {
    t = cube(pos, longCube.transform);
    obj = CUBE_1_ID;
    
    float t2;
    if((t2 = SPHERE_2_SDF) < t) {
        t = t2;
        obj = SPHERE_2_ID;
    }
}

// Function 1151
vec2 distortUV(vec2 uv) {
    float r = length (uv);
    uv = normalize(uv) * pow(r, mix(1.0,0.025, g_speed));
    
    r = length (uv);
    float rr = r*r;
    float k1 = mix(-0.2, 0.0, g_speed);
    float k2 = mix(-0.1, 0.0, g_speed);
    
    return uv * (1.0 + k1*rr + k2*rr*rr);
}

// Function 1152
float distanceFunction (vec3 p) 
{
  float       bf= cubeA(p);
  bf = blend (bf, cubeB(p));
  bf = blend (bf, ballC(p));
  bf = blend (bf, ballD(p));
  bf = blend (bf, torusA(p));
  return bf;
}

// Function 1153
SDFResult pooSDF( vec3 p, AnimObj obj, int matindex )
{   
    p-=obj.pos;	// p from world space into local space
    SDFResult res = SDFResult(TOO_FAR, MAGEN);

    if (length(p-obj.centre) < obj.radius)
    {   
        p /= obj.scale;
        
        // poop
        res = torusSDF2(Torus(vec3(0.0, 0.2, 0.0), 0.5, 0.2, matindex), p);      
        res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.2, 1.05, 0.1), 0.08, matindex), p), res, 0.01);
        res = opSmoothAdd(torusSDF(Torus(vec3(0.0, 0.8, 0.0), 0.1, 0.2, matindex), p), res, 0.2);      
        res = opSmoothAdd(torusSDF(Torus(vec3(0.0, 0.5, 0.0), 0.3, 0.2, matindex), p), res, 0.1);      
#ifdef EYESOCKETS
        // eye sockets        
        res = opSmoothSub(sphereSDF(Sphere(vec3(0.15, 0.6, -0.5), 0.15, matindex), p), res, 0.1);      
        res = opSmoothSub(sphereSDF(Sphere(vec3(-0.15, 0.6, -0.5), 0.15, matindex), p), res, 0.1);      
#endif //EYESOCKETS
#ifdef ROUGH        
        res -= clamp(noise(p*10.0), 0.0, 0.5)*0.005;
#endif        
        res = opSmoothAdd(eyeSDF(p), res, 0.01); 
    }
    return res;
}

// Function 1154
float RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)
{
	float bL = length(lE-lS);
	vec3 bD = (lE-lS)/bL;
	vec3 tD = lS-rP;
	float aDb = dot(rD,bD);
	float aDt = dot(rD,tD);
	float bDt = dot(bD,tD);
	float u = (aDt-bDt*aDb)/(1.-aDb*aDb);
	float v = max(min(u*aDb-bDt,bL),0.);
	u = max(min(v*aDb+aDt,1e6),0.);
	return length((rP+rD*u)-(lS+bD*v));
}

// Function 1155
float map(vec3 uv, mat3 q, vec3 l) {
    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));
}

// Function 1156
vec2 planetMap(in vec3 p) 
{
    p = planetSpin()*p;
    
    // Noises
    float pn1 = noise3(p/32.0);
    float pn2 = noise3(p*(2.1/32.0));
    float pn3 = noise3(p*(4.2/32.0));
    
    // Perlin FBM
    float pf1 = pn1 + 0.5*pn2 + 0.25*pn3;
    
    // Ridged multi fractal
    float rmf = 0.0;
    float signal = 0.0;
    signal = pow(1.0-abs(pn2), 2.0); rmf += signal;
    signal = pow((1.0-abs(pn3)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.5*signal;
    
#ifdef ENABLE_DETAILS
    float pn4 = noise3(p*(8.82/32.0));
    float pn5 = noise3(p*(18.522/32.0));
    float pn6 = noise3(p*(38.8962/32.0));
    
    pf1 += 0.125*pn4 + 0.0625*pn5 + 0.03125*pn6;
    
    signal = pow((1.0-abs(pn4)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.25*signal;
    signal = pow((1.0-abs(pn5)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.125*signal;
    signal = pow((1.0-abs(pn6)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.06125*signal;
#endif
    
    float d = 0.0;
    float mat = 1.0;
    d += ATMOSPHERE_HEIGHT/4.0 * pf1;
    float land = clamp(d/(ATMOSPHERE_HEIGHT/4.0), 0.0, 1.0);
    
    // Mountain
    float mn = 2.5*rmf;
    float mountainMask = smoothstep(0.55, 1.0, clamp(abs(0.925-pn2), 0.0, 1.0))*land;
    
    mat = mix(mat, 2.0, smoothstep(0.0, 0.5, mountainMask));
    d += mix(0.0, mn, mountainMask);
    
    return vec2(sdSphere(p, SEA_LEVEL+d), mat);
}

// Function 1157
SphericalHarmonics CubeMapToRadianceSH() {
    // Initialise sh to 0
    SphericalHarmonics shRadiance = shZero();

    vec2 ts = vec2(textureSize(reflectTex, 0));
    float maxMipMap = log2(max(ts.x, ts.y));

    float lodBias = maxMipMap - 5.0;
    

    for (int i=0; i < ENV_SMPL_NUM; ++i) {
        vec3 direction = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));
        vec3 radiance = sampleReflectionMap(direction, lodBias);
        shAddWeighted(shRadiance, shEvaluate(direction), radiance);
    }

    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)
    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);
    shScale(shRadiance, vec3(shFactor));

    return shRadiance;
}

// Function 1158
float scene_obj_runway_threshold_markers( mat2 K, vec2 uv, vec2 size )
{
    uv = abs( uv ) - size / 2. + vec2( 30, size.y / 4. );
    float w = floor( size.y / 9. ) * 3.;
    return aaa_stipple( Linfinity( K[1] ), uv.y - fract( w / 6. ) * 3., 3., .5 ) *
        aaa_box( K, uv, vec2( 30., w ), vec2( 0 ) );
}

// Function 1159
float map( vec3 p )
{
	vec3 q = vec3( length(p.xz)-2.0, p.y, mod(0.1*iTime + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );

    float d1 = length(p) - 1.0;
    float d2 = length(q) - 0.2;
	
	return min(d1,d2);
}

// Function 1160
float scene(in float t, in float w, in float s){
    return clamp(t - w, 0.0, s) / s;  
}

// Function 1161
float mapScene(in vec3 p) {
    float c = cos(iTime), s = sin(iTime);
    p.xz *= mat2(c, -s, s, c);
    return sdNeuralGuy(p);
}

// Function 1162
float getDist(vec3 p, Sphere sphere) {
    return sphereSDF(p, sphere);
}

// Function 1163
vec3 filmicTonemapping(in vec3 color)
{
	return ((color*(kShoulderStrength*color+kLinearAngle*kLinearStrength)+kToeStrength*kToeNumerator) /
 			(color*(kShoulderStrength*color+kLinearStrength)+kToeStrength*kToeDenominator))-kToeNumerator/kToeDenominator;
}

// Function 1164
float MapBird( vec3 p )
{
	float d;
/*    vec3 post = vec3( p.x,p.y,p.z);
    
    p.xz = Rot2(p.xz,  zoomTurn.x);
	vec3 o = p;
    
    p.y-=body.z;
    p.yz = Rot2(p.yz, body.x);
    // Body 
    d = RoundBox(p-vec3(0.0, -1.4,-.3),vec3(.3+.1*animParts.x, .0, .1+.3*animParts.x), .123);
    d = sMin(d, Sphere(p-vec3(0.0, -.25,0.0), 1.33), 1.);
    
	//Wings...    
	vec3 p2 = p;
    p2.x = abs(p2.x);
    d = sMin(d,Segment(p2,vec3(1.3, 0.2,.2), vec3(1.5+body.y, -.5,-1.6), .2, .2), .4);
  
   
    // Tail...
    d = sMin(d,Segment(p2,vec3(.6, -.5, -1.5), vec3(.15, -1.2, -8.0), .2, .2), 2.4);
    
    // Rotate head..
    p.xy = Rot2(p.xy, animParts.y);
   	p.zy = Rot2(p.zy, animParts.z);
   
    // Head...
    d = sMin(d, Sphere(p-vec3(0.0, 1.,1.4), .8), 1.0);
    //animParts.w = .1;
    // Beak...
    d = sMin(d,Segment(p-vec3(0.0, 1.,2.5),vec3(0.0, 0.0,-.4), vec3(.0, animParts.w*.2,.15), .1, .096), .72);
    d = sMin(d,Segment(p-vec3(0.0, 1.05,2.5),vec3(0.0, -animParts.w*.25,-1.5), vec3(.0, -animParts.w,.16), .1, .1), .805);
    // Eyes...
    p.x = abs(p.x);
    d = min(d, Sphere(p-vec3(.35, 1.1,2.05), .11));
    // Post...
	d = min(d, Cylinder(post-vec3(0.2, -12.0, .4), vec2(1.8, 8.5)- fbm(post*5.0)*.1));
    // Legs...
    o.x = abs(o.x);
    o.y-=body.w;
    d = min(d, Segment(o,vec3(0.5, -2.+body.z+body.w,-.5), vec3(.8, -3.5,0.5), .09, .1));
    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.8, -3.5,1.2), .04, .04));
    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(1.4, -3.5,0.8), .04, .04));
    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.1, -3.5,0.8), .04, .04));
*/
    return d;
}

// Function 1165
float remap(float minInput, float maxInput, float minOutput, float maxOutput, float domain)
{
    //return minOutput * (1 - remap01) + maxOutput * remap01;
    return remap01(minInput, maxInput, domain) * (maxOutput - minOutput) + minOutput;
}

// Function 1166
float DistanceCapsule( vec3 vPos, vec3 vP0, vec3 vP1, float r )
{
	vec3 pa = vPos - vP0;
	vec3 ba = vP1 - vP0;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	
	return length( pa - ba*h ) - r;    
}

// Function 1167
t_object eval_scene(vec3 p) {   
    float bot = p.y + 3.;
    
	float surf = p.y;
    surf += 15. * mod(perlin_noise3(.01 * p - vec3(time_ * .5) ), 5.) - 12.5;
	surf += .5*perlin_noise3(.2*p - time_*6.);
    
    const int scene_size = 2;
    float objs[scene_size];
    objs[0] = bot;
    objs[1] = surf;
    
    float d = objs[0]; int id=0;
    for(int i = 0; i < scene_size; i++) {
        if(objs[i] < d) {
            d = objs[i];
        	id = i;
        }
    }
        
    return t_object(id, d);
}

// Function 1168
float map(vec3 p)
{
    return p.y-(terrain(p.zx*0.07))*2.7-1.;
}

// Function 1169
float torus_sdf(in vec3 p) {
	vec2 to_centerline =
        vec2(abs(length(p.xz) - tor_rad1), p.y);
    return length(to_centerline) - tor_rad2;
}

// Function 1170
getDistResult getDist(vec3 p) {
    float size = GRID_SIZE;
    vec3 nuv = p * size + vec3(0., 0., iTime * speed);
    vec2 uv = fract(nuv).xz;
    vec2 id = floor(nuv).xz;

    vec2 lv = uv;

    float bl = getHeight(id);
    float br = getHeight(id + vec2(1., 0.));
    float b = mix(bl, br, lv.x);

    float tl = getHeight(id + vec2(0., 1.));
    float tr = getHeight(id + vec2(1., 1.));
    float t = mix(tl, tr, lv.x);

    float height = mix(b,t, lv.y);

    float O = bl;
    float R = br;
    float T = getHeight(id + vec2(0. -1.));
    float B = tl;
    float L = getHeight(id + vec2(-1., 0));

    vec3 n = vec3(2.*(R-L), 2.*(B-T), -4.);


    float d = sdPlane(p, -.5 + 0.3*height);

    float db = -p.z + MAX_DISTANCE*.4;
    d = min(d, db);

    getDistResult result;

    result.distanceTo = d;
    result.material = MATERIAL_PLANE;
    result.planeHeight = height;
    result.planeNormal = normalize(n);

    if (d == db) {
        result.material = MATERIAL_BACK;
    }

    return result;
}

// Function 1171
float waterSDF (vec3 p) {
    return p.y+7.;
}

// Function 1172
vec3 map( in vec3 pos ) {

	vec2 fpos = fract( pos.xz ); 
	vec2 ipos = floor( pos.xz );
		
    float f = 0.0;	
	float id = hash( ipos.x + ipos.y*57.0 );
	f  = freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 );
	f += freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 );
	f += freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 );
	f += freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 );
	f = pow( clamp( f*0.75, 0.0, 1.0 ), 2.0 );
    float h = 0.5 + 3.0*f;
	float dis = dbox( vec3(fpos.x-0.5,pos.y-0.5*h,fpos.y-0.5), vec3(0.3,h*0.5,0.3), 0.15 );

    return vec3( dis,id, f );
}

// Function 1173
vec4 sceneDistance(vec2 p, inout vec4 fragColor)
{
    float modTime = 4.;
    modTime = mod((iTime-4.),maxTime);
    
    vec2 gumP = tX(p, vec2(-0.3, 0.0));
    if (modTime > 8.) {
        isGumballWalking = false;
        gumP = tX(p, vec2(-0.2, 0.0));
        bothHighFiving = true;
    } else {
        gumP = tX(p, vec2(-1.+(modTime/100.)*10., 0.0));
    }
    
    gumball(gumP, fragColor, modTime);
    
    return fragColor;
}

// Function 1174
vec2 map(vec3 p)
{
    // wall
    vec3 wp = vec3(5.0, 0.0, 0.0);
    vec3 ws = vec3(.2, 5.0, 5.0);
    float w = sdBox(abs(p) - wp, ws);
    w = min(w, sdBox(abs(p) - wp.zyx, ws.zyx));
    //w = min(w, sdBox(p - vec3(0.0, 4.4, 0.0), vec3(5.0, 0.2, 5.0))); // Ceiling

    w = opSmoothSubtraction(sdBox(p - vec3(2.0, 2.6, 5.0), vec3(0.8, 1.1, 1.0)), w, .03);
    vec2 wall = vec2(w, 1.0);
    
    // window
    float wi = sdBox(abs(abs(p) - vec3(1.95, 2.6, 4.95)) - vec3(0.78, 0.0, 0.0), vec3(0.05, 1.1, 0.19));
    wi = min(wi, sdBox(p - vec3(1.95, 1.5, 4.9), vec3(1.0, 0.1, 0.4))) - .02;
    
    wi = min(wi, sdBox(p - vec3(1.95, 2.6, 4.9), vec3(0.8, 0.07, 0.07)));
	wi = min(wi, sdBox(p - vec3(2.65, 3.2, 4.9), vec3(0.07, 0.57, 0.07)));
    
    wi = min(wi, sdBox(p - vec3(1.95, 3.15, 4.9), vec3(0.8, 0.02, 0.02)));
    
    wi = min(wi, sdBox(p - vec3(2.12, 3.2, 4.9), vec3(0.02, 0.57, 0.02)));
    wi = min(wi, sdBox(p - vec3(1.7, 3.2, 4.9), vec3(0.02, 0.57, 0.02)));
    
    // floor wooden things
    wi = min(wi, sdBox(p - vec3(1.95, 0.0, 4.92), vec3(3.0, 0.13, 0.17)));
    wi = min(wi, sdBox(p - vec3(4.92, 0.0, 1.9), vec3(0.17, 0.13, 3.0)));
    
    vec2 window = vec2(wi - 0.01, 3.0);
    
    // curtains
    float c = MAX_DIST + 1.0;
#ifdef TRANSLUCENT_CURTAIN
    if (int(p.x * 10000.0) % 100 != 0 && int(p.y * 10000.0) % 100 != 0)
#endif
    {
        
    	vec3 cp = p - vec3(1.31, 3.0, 4.68);
        cp -= vec3(0.0, 0.01 + sin(p.x * 10.0 + iTime) * .02, 0.024) * sin(p.x * 15.0 + oTime * .5) * noise(p.xy * 2.5 + oTime) * 2.5;
        //cp += vec3(0.0, 0.0, 0.02) * (pow((4.3 - p.y) * 0.9, 4.1)) * .01;
        cp -= vec3(-0.01, 0.0, 0.036) * sin(p.y * 6.0 + oTime * 1.4) * (pow((4.8 - p.y) * 0.9, 4.1)) * .06;
        //cp += noise(p.xy * 2.0 + oTime) * .09 * (1.3 - p.x) / 0.6;
        //cp += abs(noise(p.xy * 1.0 + oTime) * 0.14 * (3.0 - p.y) / 1.0) * vec3(1.0, 1.0, 0.0);
        c = sdBox(cp, vec3(0.62, 1.0, 0.015)) - .050;
    }
    vec2 curtain = vec2(c, 4.0);
    
    // tree trunk
    vec3 ttp = p - vec3(-2.10, 2.0, 8.0);
    ttp.xy += pow((ttp.y + 2.9), 4.6) * -.0001 * (sin(noise(vec2(oTime * 0.442, oTime * .552))) + 1.0);
    float tt = sdCappedCylinder(ttp, 0.02, 3.0);
    
    // floor
    float f = dot(p, vec3(0.0, 1.0, 0.0));
    vec2 flo = vec2(min(f, tt), 2.0);
    
    return closest(closest(closest(wall, flo), window), curtain);
}

// Function 1175
SurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult, int iInsideObject )
{
    SurfaceInfo surfaceInfo;
    
    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);
    
    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos, iInsideObject ); 
    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;
    surfaceInfo.vAlbedo = vec3(1.0);
    surfaceInfo.vR0 = vec3( 0.01 );
    surfaceInfo.fSmoothness = 1.0;
    surfaceInfo.vEmissive = vec3( 0.0 );
    
    surfaceInfo.fTransparency = 0.0;
    surfaceInfo.fRefractiveIndex = 1.0;
        
    if ( traceResult.iObjectId == MAT_DEFAULT )
    {
    	surfaceInfo.vR0 = vec3( 0.02 );
	    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 0.5, 0.0 ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
                        
    	surfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);
        
        surfaceInfo.vAlbedo *= 0.25;
        
        /*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;
        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;
        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);
        surfaceInfo.fSmoothness = 0.0;*/
        
        //surfaceInfo.vR0 = vec3(clamp(surfaceInfo.vAlbedo.r - surfaceInfo.vPos.x, 0.0, 1.0));
        
        float fDist = length( surfaceInfo.vPos.xz );
        
        float fCheckerAmount = clamp( 1.0 - fDist * 0.1 + surfaceInfo.vAlbedo.r * 0.5, 0.0, 1.0);
        
        vec3 vChecker;
        float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);
        if ( fChecker > 0.0 )
        {
            vChecker = vec3(1.0);
        }
        else
        {
            vChecker = vec3(0.1);
        }
                
        surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vChecker, fCheckerAmount);
        surfaceInfo.vR0 = mix(surfaceInfo.vR0, vec3(0.1), fCheckerAmount);
        surfaceInfo.fSmoothness =  mix(surfaceInfo.fSmoothness, 1.0, fCheckerAmount);
        
    }

  /*  if ( traceResult.fObjectId == MAT_STEEL )
    {
	    surfaceInfo.vAlbedo = texture( iChannel2, traceResult.vUVW.xz ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        
    	surfaceInfo.fSmoothness = surfaceInfo.vAlbedo.r;//clamp( surfaceInfo.vAlbedo.r, 0.0, 1.0);                
        
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * 0.5;
                        
    	surfaceInfo.vR0 = vec3( surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 0.8 );

        vec3 vDirt = texture( iChannel3, traceResult.vUVW.xz ).rgb;
        vDirt = vDirt * vDirt;
        surfaceInfo.vAlbedo = vDirt * ( 1.0 - surfaceInfo.vAlbedo.r) * 0.1;//mix( surfaceInfo.vAlbedo, vDirt, 1.0 - surfaceInfo.vAlbedo.r );
        
    }*/
    
    if ( traceResult.iObjectId == MAT_GLOSS_PAINT )
    {
        //float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);
        float fStripe = step( fract( dot( traceResult.vUVW * 5.0, vec3(1.0, 0.2, 0.4) ) ), 0.5 );
        if ( fStripe > 0.0 )
        {
	        surfaceInfo.vAlbedo = vec3(0.1, 0.05, 1.0);
        }
        else
        {
	        surfaceInfo.vAlbedo = vec3(1.0, 0.05, 0.1);
        }        
    }
    
    
    if ( traceResult.iObjectId == MAT_GLASS )
    {
    	surfaceInfo.vR0 = vec3( 0.02 );

        vec3 vAlbedo;
        vAlbedo = textureLod( iChannel3, traceResult.vUVW.xy * 2.0, 0.0 ).rgb;
        vAlbedo = vAlbedo * vAlbedo;
        vAlbedo *= vec3(1.0, 0.1, 0.5);
                
        surfaceInfo.vAlbedo = vAlbedo;
        
    	//surfaceInfo.fSmoothness = 0.9;//clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);
    	surfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * 2.0, 0.0, 0.9);

        surfaceInfo.fTransparency = clamp( surfaceInfo.vPos.y * 5.0 + surfaceInfo.vAlbedo.g * 3.0, 0.0, 1.0);

        if ( surfaceInfo.vPos.x < 0.0 || surfaceInfo.vPos.z < 0.0 )
        {
        	surfaceInfo.vAlbedo = vec3(0.0);                
    		surfaceInfo.fSmoothness = 0.9;
            surfaceInfo.fTransparency = 1.0 - vAlbedo.g * 0.2;
        }
        
        surfaceInfo.fRefractiveIndex = 1.5;
        
        
        float fLipStickDist = length(surfaceInfo.vPos - vec3(0.3, 3.1, -2.9)) - 1.0;
        if ( fLipStickDist < 0.0 )
        {            
            surfaceInfo.fTransparency = clamp(1.0 +fLipStickDist * 2.0- vAlbedo.r, 0.0, 1.0);
            surfaceInfo.vAlbedo = vec3(0.5,0,0) * (1.0 - surfaceInfo.fTransparency);
        }
        
        /*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;
        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;
        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);
        surfaceInfo.fSmoothness = 0.0;*/
    }

    if ( traceResult.iObjectId == MAT_WINE )
    {
    	surfaceInfo.vR0 = vec3( 0.02 );
        surfaceInfo.vAlbedo = vec3(0.0);
                
    	surfaceInfo.fSmoothness = 0.9;
        
        surfaceInfo.fTransparency = 1.0;
        surfaceInfo.fRefractiveIndex = 1.3;        
        
        /*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;
        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;
        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);
        surfaceInfo.fSmoothness = 0.0;*/
    }
    
    if ( traceResult.iObjectId == iInsideObject )
    {
		surfaceInfo.fRefractiveIndex = 1.0;            
    }
    
    return surfaceInfo;
}

// Function 1176
float DistanceBetweenARectAndaPoint2D(vec2 p, vec2 rp, vec2 v)
{
   
    vec2 v1 = rp - p;
    
    vec3 cp = cross(vec3(v,0),vec3(v1,0));
    
    return length(cp)/length(v);
}

// Function 1177
float map(vec3 p){
    vec3 c = vec3(10.0);
    vec3 q = mod(p, c) - 0.5*c;
    q.y = p.y;
    
    float circle = length(q- vec3(0.0, 3.0, 0.0)) - 2.5;
    float circle2 = length(q- vec3(0.0, -1.0, 0.0)) - 2.3;
    float box = sdBox(q, vec3(2.0, 5.0, 2.0));
    float plane = fplane(p);
    float scene0 = min( max(-(min(circle, circle2)), box), plane);
    return min(scene0, length(p - vec3(0.0, 10.0, 20.0)) - 6.0);
}

// Function 1178
vec3 RayMarchScene(vec3 rayOrigin, inout rayIntersect rIntersec)
{
    float t = NEARCLIP;
    vec2 res = vec2(NEARCLIP, -1.0);
    
	for(int i=0; i < SCENE_SAMPLE; ++i)
	{
        vec3 pos = rayOrigin + t * rIntersec.rd;
        res = SceneDistance(pos);
        if(res.x < (EPSILON * t) || t > FARCLIP)
            break;
        t += res.x * 0.5;
	}
    
    vec3 pos = rayOrigin + t * rIntersec.rd;
    rIntersec.mPos = pos;
    rIntersec.dist = t;
	
    material mat;
    mat.albedo = vec3(244.0, 164.0, 96.0)/255.0;
    mat.reflectivity = 0.8;
    rIntersec.mat = mat;
    
    #if DEBUG_PASS == 0
        if (t > FARCLIP)
        {
            rIntersec.dist = FARCLIP;
            return GetSkybox(rayOrigin, rIntersec);
        }
        else
        {
            #ifndef DEBUG_NO_FOG
                float sundot = clamp(dot(rIntersec.rd, sunDirection), 0.0, 1.0);
            	vec3 sky = CheapSkyBox(rayOrigin, rIntersec);
            	ColorScene(rIntersec);
            
            	float fogFactor = EaseOutSine(rIntersec.dist / FARCLIP);
            	return mix(Shading(rayOrigin, rIntersec), sky, fogFactor);
            #else
            	ColorScene(rIntersec);
            	return Shading(rayOrigin, rIntersec);
            #endif
        }
    
    #elif DEBUG_PASS == 1
    	if(t < FARCLIP)
            ColorScene(rIntersec);
    	return rIntersec.nor;
    
    #elif DEBUG_PASS == 2
        if (t > FARCLIP)
            rIntersec.dist = FARCLIP;
        return vec3(rIntersec.dist) / FARCLIP;
    
    #elif DEBUG_PASS == 3
    	return rIntersec.mPos;
    
    #elif DEBUG_PASS == 4
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        float NdotL = clamp(dot(rIntersec.nor, sunLightPos), 0.0, 1.0);
        return vec3(NdotL);
    
    #elif DEBUG_PASS == 5
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        float NdotV = clamp(dot(rIntersec.nor, -rIntersec.rd), 0.0, 1.0);
        return vec3(NdotV);
    
    #elif DEBUG_PASS == 6
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);
        float NdotH = clamp(dot(rIntersec.nor, HalfAngleV), 0.0, 1.0);
        return vec3(NdotH);
    
    #elif DEBUG_PASS == 7
    	if(t < FARCLIP)
            ColorScene(rIntersec);
        vec3 sunLightPos = normalize(sunDirection);
        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);
        float VdotH = clamp(dot(-rIntersec.rd, HalfAngleV), 0.0, 1.0);
        return vec3(VdotH);
    
    #elif DEBUG_PASS == 8
    	if (t > FARCLIP)
        {
            rIntersec.dist = FARCLIP;
            return GetSkybox(rayOrigin, rIntersec);
        }
        else
	    	return CheapSkyBox(rayOrigin, rIntersec);
    
    #elif DEBUG_PASS == 9
    	if(t < FARCLIP)
            ColorScene(rIntersec);
    
    	vec3 amb = (abs(sun_Color.w - 1.0) * 0.03 + AMBIENT_POW) * AMBIENT_COLOR;
    	return amb;

    #elif DEBUG_PASS == 10
   		float shadow = SoftShadow(rIntersec.mPos + sunDirection);
    	return vec3(shadow);
    
    #endif
}

// Function 1179
vec3 scene(vec2 uv){

    // Grid cell ID. Used to color the spheres. In this case, white or red.
    vec2 id = mod(floor(uv), 5./2.);
    
    // Partition space (the 2D canvas) into squares.
    uv = fract(uv) - .5;

	
    // Draw a lit, raytraced sphere in each grid cell. From here it's just boring
    // intersection and lighting stuff.
    
    
	// Ray origin, unit ray and light.
	vec3 ro = vec3(0, 0, -2.4);
	vec3 rd = normalize( vec3(uv, 1.));
    vec3 lp = ro + vec3(cos(iTime), sin(iTime), 0)*4.;
	
	// Sphere intersection.
	float t = trace( ro, rd );
    
	
	// Dark background.
	vec3 col = vec3(1, .04, .1)*0.003 + length(hash22(uv + 7.31))*.005;
    
	if (t>0.){
	
        
        // Surface point.
    	vec3 p = ro + rd*t;
    	
        // Normal.
    	vec3 n = normalize(p);
        
        // Point light.
        vec3 ld = lp - p;
        float lDist = max(length(ld), 0.001);
        ld /= lDist;
        
        float diff = max(dot(ld, n), 0.); // Diffuse.
        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.); // Specular.
        
        // Adding a sinusoidal pattern.
        float c = dot(sin(p*8. - cos(p.zxy*8. + 3.14159 + iTime)), vec3(.166)) + .5;
        float f = c*6.;
        c = clamp(sin(c*3.14159*6.)*2., 0., 1.);
        c = sqrt(c*.75+.25);
        vec3 oCol = vec3(c); // Coloring the object white.
        
        // Coloring the object red, based on ID.
        if(id.x>1.25) oCol *= vec3(1, .04, .1);
        
	
        // Adding some fake environment mapping. Not that great, but it gives
        // a slight reflective sheen.
        p = reflect(rd, n)*.35;
        c = dot(sin(p*8. - cos(p.zxy*8. + 3.14159)), vec3(.166)) + .5;
        f = c*6.;
        c = clamp(sin(c*3.14159*6.)*2., 0., 1.);
        c = sqrt(c*.75+.25);
        vec3 rCol = vec3(min(c*1.5, 1.), pow(c, 3.), pow(c, 16.)); // Reflective color.
        
        // Producing the final lit color.
        vec3 sCol = oCol*(diff*diff + .5) + vec3(.5, .7, 1)*spec*2. + rCol*.05;
       
        // Applying attenuation.
        sCol *= 1.5/(1. + lDist*.25 + lDist*lDist*.05);

        // Simple trick to antialias the edges of a raytraced sphere.
        float edge = max(dot(-rd, n), 0.);
    	edge = smoothstep(0., .35, edge); // Hardcoding. A bit lazy.
        // Taper between the sphere edge and the background.
        col = mix(col, min(sCol, 1.), edge); 
        
	}
    

	
    // Clamp and perform some rough gamma correction.
	return sqrt(clamp(col, 0., 1.));
}

// Function 1180
float triSDF(vec2 st) { // 16
    st = (2. * st - 1.) * 2.;
    return max(abs(st.x) * 0.866025 + st.y * .5, -st.y * .5);
}

// Function 1181
vec3 getSceneColor(vec3 ro, vec3 rd) {
    // Raymarch.
    vec3 p;
    float d = 0.009;
    MarchData h;
    for (float steps = -0.1; steps < MAX_STEPS; steps++) {
        p = ro + rd * d;
        h = map(p);
        if (abs(h.d) < MIN_DIST * d)
            break;
        if (d > MAX_DIST)
            return vec3(-0.1); // Distance limit reached - Stop.
        d += h.d; // No hit, so keep marching.
    }
    // Lighting.
    float g = glow;
    return applyLighting(p, rd, d, h) + fireShock() * 0.2 + g;
}

// Function 1182
float map_supports(vec3 pos)
{
    vec3 mpos1 = pos.yxz;
    vec3 mpos2 = mpos1;
    mpos2.yz = rotateVec(mpos2.yz, 2.*pi/3.);
    vec3 mpos3 = mpos1;
    mpos3.yz = rotateVec(mpos3.yz, 4.*pi/3.);
    return min(min(min(min(sdCylinder(pos - vec3(0., 1., 0.), vec2(0.45, 0.35)),                    // Socket
                           sdCylinder(pos - vec3(0., 1.4, 0.), vec2(0.08, 1.4))),                   // Cable
                           sdCylinder(mpos1 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x))),  // Suport 1/3
                           sdCylinder(mpos2 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x))),  // Suport 1/3
                           sdCylinder(mpos3 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x)));  // Suport 1/3
}

// Function 1183
float mapTerrain( vec2 p) {

    vec2 uv =  p  / 300. *SLOPE;
  	float n = .1  +max(fbm(uv * 1.2 ) - .2, 0.); 
    n =  n * n * (3. - 2. * n);  
    //n*= (.3 + snoise(p/120.)); //islands
    //n= mix(n, .4,snoise(p/120.)); //plains
    return floor(clamp( n*MOUNTAIN_LEVEL,1.,MOUNTAIN_LEVEL));

}

// Function 1184
float scene(vec3 r) {
	return plasma(r);
}

// Function 1185
vec4 map(in vec3 p)
{
    p.z += 0.2*iTime;
	vec4 d1 = fbmd( p );
    d1.x -= 0.37;
	d1.x *= 0.7;
    d1.yzw = normalize(d1.yzw);

    // clip to box
//    vec4 d2 = sdBox( p, vec3(1.5) );
//    return (d1.x>d2.x) ? d1 : d2;
    return d1;
}

// Function 1186
float map( vec3 c ) 
{
	vec3 p = c + 0.5;
	
	float h = textureLod( iChannel0, fract(p.xz/iChannelResolution[0].xy), 0.0 ).x;
    
    float dm = 1e10;
    for( int i=0; i<25; i++ )
    {
        vec2 pa = path( 60.0*float(i)/25.0 ).xz;
        dm = min( dm, length2(pa-p.xz) );
    }
    
    float isc = step( sqrt(dm), 5.0 );
    
    h = -10.0 + 16.0*h - 6.0*isc;//*(0.2 + h*2.0);
    
    h += 10.0*smoothstep( 0.9,0.91,textureLod( iChannel2, 0.25*fract(p.xz/iChannelResolution[2].xy), 0.0 ).x)*(1.0-isc);
    
    
	return step( p.y, h );
}

// Function 1187
float scene( in vec3 ro, in vec3 rd, out float d )
{
    const float T_MAX = 999999.;
	const float T_MIN = 0.001;
    
    float idx = -1.;
    d = T_MAX;
    
    for( int i = 0; i != nSP; ++i )
    {
        float t = 0.;
        float h = sp_solve( ro, rd, sp_defs[i].xyz, sp_defs[i].w, T_MIN, t );
        float valid = step( T_MIN, t ); // make sure the hit point is positive
        
        h *= valid;
        t = mix( T_MAX, t, h ); // no hit or negative hit == T_MAX
        
        idx = mix( float( i ), idx, step( d, t ) );
        d = min( d, t );
    }
    
    return idx;
}

// Function 1188
vec3 eMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.25;
    rd *= 3.;
    
    //vec3 tx = tex3D(iChannel0, rd/3., sn);
    //float c = dot(tx*tx, vec3(.299, .587, .114));
    
    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.
    
    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.
    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.
    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25 + .25); 
    
}

// Function 1189
vec3 scene(vec3 ro, vec3 rd){
  float t=DE(ro)*rnd,d,px=1.0/iResolution.x;
  for(int i=0;i<99;i++){
    t+=d=DE(ro+rd*t);
    if(t>10.0 || d<px*t)break;
  }
  vec3 L=normalize(vec3(0.4,0.025,0.5));
  vec3 col=sky(rd,L),sgl=glw;
  if(d<px*t*5.0){
    mcol=vec3(0.001);
    vec3 so=ro+rd*t;
    vec3 N=normal(so,d);
    vec3 scol=mcol*0.25;
    float dif=0.5+0.5*dot(N,L);
    float vis=clamp(dot(N,-rd),0.05,1.0);
    float fr=pow(1.-vis,5.0);
    float shad=ShadAO(so,L);
    col=(scol*dif+fr*sky(reflect(rd,N),L))*shad;
  }
  col+=sgl;
  return col;
}

// Function 1190
vec2 map0sd(vec2 z)
{

  float s = inversesqrt(dot(z,z)+epsilon);
  float m = s*max(abs(z.x),abs(z.y));
 
  return m*z;
}

// Function 1191
float dist(Segment s, vec2 p)
{
	vec2 pa = p-s.A, ba = s.B-s.A;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h );
    
}

// Function 1192
float distance2_point_line(in vec3 point, in vec3 origin, in vec3 direction) {
    vec3 a = point - origin;
    vec3 h = a - dot(a, direction) * direction;
    return dot(h, h);
}

// Function 1193
float roundConeDistance(vec3 point, float radiusA, float radiusB, float height) {
    vec2 q = vec2(length(point.xy), point.z);

    float b = (radiusA - radiusB) / height;
    float a = sqrt(1.0 - b * b);
    float k = dot(q, vec2(-b, a));

    if (k < 0.0) return length(q) - radiusA;
    if (k > a * height) return length(q - vec2(0.0, height)) - radiusB;

    return dot(q, vec2(a, b)) - radiusA;
}

// Function 1194
float scene(vec3 p, float t) {
    //  rotate + bob around
    p += vec3(cos(2. * t), sin(.5 * t), sin(t));
    float theta = .9 * t;
    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,
                    0., 1., 0., 0.,
                    -sin(theta), 0., cos(theta), 0.,
                    0., 0., 0., 1.);
    p = vec3(rot * vec4(p, 0.));
    
    return box(p, vec3(.5));
}

// Function 1195
float map(vec3 p)
{
    vec3 g = p;
    vec3 gid = floor(p/20.);
    //movement
    p.z -= hash(floor(p.x/c+1.))*(time*12.+92.);
    p.y -= hash(floor(p.z/c+1.))*(time*3.+89.);
    
    vec3 iq = floor(p/c);
    vec3 q  = fract(p/c)*c-ch; //a bit faster than "mod(p,c)-ch;"
   
    matid = dot(iq,vec3(1,11,101));
    
    float rn = hash13(iq);
   	float d = dBox(q); //Base distance is cell exit distance
    
    q.xz *= mm2(time*2.+iq.x);
    q.xy *= mm2(time*0.6+iq.y);
    
    if (rn >= scr3)
        d = min(d,length(q)-sz);
    else if (rn >= scr2)
        d = min(d,tetra(q,sz));
    else if (rn >= scr)
        d = min(d,dot(abs(q),vec3(0.57735))-sz);
    
    //columns
    g.xy *= mm2(-gid.z*.4);
    g.xz = mod(g.xz,20.)-10.;
    float clm = slength(g.zx)-2.;
    if (clm < d) matid = 1.;
    d = min(d,clm);
        
    return d;    
}

// Function 1196
void sceneRainbowPlasma(vec2 uv, vec2 screenUv, out vec3 params)
{
	float b = iBeat * .25;
	float scale = cos(b)*.5+1.;
	uv *= scale;
	params.x = fract(length(sin(rotate(uv*5.,b)))/sqrt(2.)+b);
	params.yz = rangeRainbow;
	
	if(iBeat >= 95.5
	||(iBeat >= 95. && screenUv.x < .83)
	||(iBeat >= 94.5 && screenUv.x < .67)
	||(iBeat >= 93.5 && screenUv.x < .5)
	||(iBeat >= 92.5 && screenUv.x < .33)
	||(iBeat >= 92. && screenUv.x < .17))
		params.yz = rangeBlack;
}

// Function 1197
vec3 ApplyTonemap( const in vec3 vLinear )
{
	const float kExposure = 1.0;
	
	return 1.0 - exp2(vLinear * -kExposure);	
}

// Function 1198
float Scene( vec3 p )
{
    float a = p.x;
    p.x = -p.y;
    p.y = a;
    
    Rotate( p.yz, iTime );    
    
    // sphere
    float ret = Sphere( p, 0.6 );
    for ( float i = -5.0; i < 6.0; ++i )
    {
        float theta   = ( i / 6.0 ) * MATH_PI * 0.5;
        float boxNum  = 12.0;
        float radius  = cos( theta ) * 0.7;
        float boxSize = abs( radius ) * 0.12;
        float boxOffset = -sin( theta ) * 0.7;
                
        Rotate( p.yz, MATH_PI / ( 2.0 * boxNum ) );
        
        vec3 t = p;		
		float boxLen = 0.15 + sin( iTime * 2.0 ) * 0.1;        
    	t = p + vec3( boxOffset, 0.0, 0.0 );
    	RepeatAngle( t.yz, boxNum );
    	t.y -= radius;
        Rotate( t.xy, -theta );
    	ret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );
        
		t = p;
		boxLen = 0.15 + sin( iTime * 3.0 ) * 0.1;        
		Rotate( p.yz, MATH_PI / boxNum );
    	t = p + vec3( boxOffset, 0.0, 0.0 );
    	RepeatAngle( t.yz, boxNum );
    	t.y -= radius;
        Rotate( t.xy, -theta );
    	ret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );
    }
    
    // debris
    vec3 t = p;
    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );
    t.z = abs( t.z );
    t -= vec3( 0.8, 1.0, 1.0 );
    Rotate( t.xz, iTime );    
	Rotate( t.xy, -0.25 );
    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );
    
    Rotate( p.xy, 0.1 * iTime );
    Rotate( p.yz, MATH_PI * 0.25 );
    t = p;
    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );
    t.z = abs( t.z );
    t -= vec3( 0.8, 1.0, 1.0 );
    Rotate( t.xz, iTime );    
	Rotate( t.xy, -0.25 );    
    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );    

	return ret;
}

// Function 1199
float level_distance(vec3 p) {
	float t = iTime;
	float floor_dist = sd_floor(op_rep(p + vec3(0,-1,0), vec3(0,4.6,0)));
	floor_dist += cos(t*0.5)*0.2*cos(p.x)*cos(p.z);

	vec3 p_rep = op_rep(p+vec3(3,-1,3), vec3(5,0,5.95));
	float dome_osc = cos(t*2.0)*0.01;
	float dome = -sd_sphere(p_rep, 3.0) + dome_osc;
	dome = min(dome,
		sd_torus_yz(op_rep(p+vec3(0.5,-1,0), vec3(5,0,0)),
					vec2(1.6+dome_osc*3.0, 0.1)));

	float r = min(floor_dist, dome);
	r = min(r, sd_box(p, vec3(0.5,1,0.5)));
	r = min(r, sd_box(p+vec3(0,-0.5,0), vec3(0.25,1,0.25)));

	r = min(r, sd_capsule(p, vec3(-0.5,0,0.25), vec3(-0.5,1,-0.25), 0.2));

	r = min(r, sd_torus_xz(p+vec3(0,cos(t)*0.4-0.2,0), vec2(0.8, 0.1)));
	r = min(r, sd_torus_xz(p+vec3(0,sin(t*0.1)*0.2-0.2,0), vec2(1.0, 0.1)));
	return r;
}

// Function 1200
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4, vn4;
  vec3 p, col, c, bgCol, vn;
  float dstObj, s, sh;
  bool isBg, isLit;
  rTube = 0.3;
  rBase = 1.8;
  rLoop = 5.;
  dstObj = ObjRay (ro, rd);
  isBg = false;
  isLit = false;
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    p = ro;
    gId = PixToHex (p.xz / hgSize);
    SetObjConf ();
    p.xz -= HexToPix (gId * hgSize);
    c = HsvToRgb (vec3 (mod (37.3 * hVal, 1.), 0.2, 1.));
    if (idObj == idArm) {
      col4 = vec4 (0.9, 0.9, 1., 0.);
    } else if (idObj == idArmE) {
      if (armId == armUp) col4 = vec4 (0.7 + 0.3 * sin (5. * tLoc), 0., 0., -1.);
      else col4 = vec4 (c, 0.);
    } else if (idObj == idCylL) {
      col4 = vec4 (0.8 * c, 0.);
    } else if (idObj == idCylU) {
      col4 = vec4 (c, 0.);
      s = length (p.xz) - rTube - 0.2;
      if (s < 0.) {
        if (s < -0.1) col4 = vec4 (vec3 (0.6 + 0.4 * sin (5. * tLoc), 0., 0.), -1.);
        else col4.rgb *= 0.7;
      }
    } else if (idObj == idBub) {
      col4 = vec4 (mix (vec3 (1.2), BgCol (reflect (rd, vn)), 0.5), -1.);
    }
    if (col4.a >= 0.) isLit = true;
  } else if (rd.y < 0. && (- ro.y / rd.y) < dstFar) {
    dstObj = - ro.y / rd.y;
    ro += dstObj * rd;
    col4 = mix (vec4 (0.3, 0.4, 0.3, 0.), vec4 (0.2, 0.3, 0.3, 0.),
       0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (4. * ro.xz))) * (1. +
       0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));
    vn4 = RippleNorm (0.1 * ro.xz, vec3 (0., 1., 0.), 6.);
    vn = VaryNf (2. * ro, vn4.xyz, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));
    col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);
    isLit = true;
  } else isBg = true;
  bgCol = BgCol (rd);
  if (isBg) {
    col = bgCol;
  } else {
    if (isLit) {
      sh = min (ObjSShadow (ro, ltDir), 1. - 0.2 * smoothstep (0.4, 0.6,
         Fbm2 (0.1 * ro.xz + 0.2 * tCur)));
      col = col4.rgb * (0.3 * bgCol + 0.7 * sh * max (dot (vn, ltDir), 0.));
    } else {
      col = col4.rgb * (0.3 + 0.7 * max (- dot (vn, rd), 0.));
    }
    col = mix (col, bgCol, smoothstep (0.3, 1., dstObj / dstFar));
  }
  col = pow (clamp (col, 0., 1.), vec3 (1.1, 1.1, 0.9));
  return clamp (col, 0., 1.);
}

// Function 1201
vec2 map( vec3 pos ){

  //mat4 rot = rotateX(.5 + uTime * .3 ) * rotateZ( .3 + uTime * .2 );

  //vec3 nPos = (rot * vec4( pos , 1. )).xyz;

  vec2 res = vec2(subCube(pos) , 1.);

  return res;

}

// Function 1202
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
    
    //HEAD
    //Animate Head
    //vec3  lHeadPos = (rotation(Z_AXIS, M_PI * sin(iTime * 5.0) * 0.1 + 0.2) * (pos - vec3(0.0, 0.7, -0.02))) - vec3(0.0, 0.7, 0.0);
    
    vec3  lHeadPos = rotation(Z_AXIS, M_PI * -0.1) * (pos - vec3(-0.15, 1.4, -0.02));
    float lHeadBox = sdBox( pos-vec3( -0.05, 1.1, -0.1), vec3(0.3,0.35,0.35) );
    if(res.x > lHeadBox)
    {
        //res = opU( res, vec2( lHeadBox, 4.0) );

        float lHead = sdEllipsoid( lHeadPos, vec3( 0.23, 0.7, 0.25));
        float lHeadCutter = sdBox(lHeadPos - vec3(0.0, 0.36, 0.0), vec3( 0.28, 0.6, 0.32));
              lHead = fOpIntersectionRound(lHead, -lHeadCutter, 0.04);

        //Morro
        float lHead2 = sdEllipsoid(  (lHeadPos - vec3(0.0, -0.28, -0.18)), vec3( 0.20, 0.08, 0.22));
              lHead = opSmoothUnion(lHead, lHead2, 0.12);

        //Zona Ojos
        float lHead3 = sdRoundedCappedCone( (lHeadPos - vec3(0.0, -0.152, 0.0)), vec3(0.12, 0.2, 0.125) * 0.4, 0.09);
        float lHeadEyeZoneCutter = sdEllipsoid( lHeadPos - vec3(0.0, -0.15, -0.2), vec3( 0.4, 0.07, 0.1));
              lHead3 = fOpIntersectionRound(lHead3, -lHeadEyeZoneCutter, 0.1);
              lHead = opSmoothUnion(lHead, lHead3, 0.08);
              lHead = fOpIntersectionRound(lHead, -sdSphere(opMirrorX(lHeadPos) - vec3(0.053, -0.13, -0.07), 0.053), 0.015);

        //Zona Boca
        float lHeadMouthCutter = sdRoundedCappedCone( rotation(X_AXIS, 0.4)  * (lHeadPos - vec3(0.0, -0.4, -0.2)), vec3(0.1, 0.05, 0.5) * 0.29, 0.08);
              lHeadMouthCutter = min(lHeadMouthCutter, sdRoundedCappedCone( (lHeadPos - vec3(0.0, -0.45, -0.0)), vec3(0.35, 0.06, 0.3) * 0.45, 0.04));
              lHead = fOpIntersectionRound(lHead, -lHeadMouthCutter, 0.04);

        //Teeth
        float lTeeth = sdRoundBox(rotation(Z_AXIS, -0.00) * (lHeadPos - vec3(0.0, -0.3, -0.3)), vec3(0.045, 0.026, 0.001), 0.04);
              lHead = min(lHead, lTeeth);
        res = opU( res, vec2( lHead, 3.0) );

        //Eyes
        float lEyes = sdSphere(opMirrorX(lHeadPos) - vec3(0.053, -0.13, -0.07), 0.052);
        res = opU( res, vec2( lEyes, 5.0) );

        //Inner shadows
        float 	lInnerShadows = sdSphere(opMirrorX(lHeadPos) - vec3(0.053, -0.13, -0.07), 0.061);
                lInnerShadows = min(lInnerShadows, sdRoundedCappedCone( (lHeadPos - vec3(0.0, -0.45, -0.0)), vec3(0.35, 0.06, 0.3) * 0.45, 0.04));
        lInnerShadows = max(lInnerShadows, lHead) - 0.001;
        res = opU( res, vec2( lInnerShadows, 8.0) );
        
            //Face Hair
        float lEyeBrows = sdRoundedCappedCone( (opMirrorX(lHeadPos) - vec3(0.07, -0.07, -0.08)), vec3(0.08, 0.3, 0.2) * 0.15, 0.02);
              lEyeBrows = max(lEyeBrows, -sdRoundedCappedCone( (opMirrorX(lHeadPos) - vec3(0.07, -0.085, -0.13)), vec3(0.11, 0.45, 0.29) * 0.2, 0.01));
              lEyeBrows = max(lHead, lEyeBrows);
        res = opU( res, vec2( lEyeBrows, 4.0) );

        //Carrot
        vec3 lCarrotPos =  rotation(X_AXIS, M_PI * -0.5) * ((lHeadPos * vec3(1.0, 0.9, 0.7)) - vec3(0.0, -0.18, -0.3));
        float lCarrot = sdRoundCone(lCarrotPos, 0.01, 0.04, 0.21 );
        if(res.x > lCarrot)
        {
            vec3 lNoise = GrNoiseIq((pos) * iResolution.x * 0.015);
            lCarrot += (clamp(abs(sin(lCarrotPos.y * 200.0)), 0.8, 1.0)) * 0.0011 * (lNoise.x +  lNoise.y) ;
        }
        res = opU( res, vec2( lCarrot, 7.0) );
        //END HEAD
    }
        
    float lHeadSticksBox = sdBox( pos-vec3( -0.1, 1.65, 0.0), vec3(0.3,0.3,0.22) );
    float lHeadSticks = 1e10;
    if(res.x > lHeadSticksBox)
    {
        
        //Head Sticks
        vec4 lHair1Bezier = sdBezier( vec3(0.0), vec3(0.06,0.2,0.0), vec3(0.14,0.26,0.0), lHeadPos - vec3( 0.01 , -0.1, 0.0) );
        vec4 lHair1_2Bezier = sdBezier( vec3(0.0), vec3(0.06,0.0,0.0), vec3(0.08,-0.03,0.0), lHeadPos - vec3( 0.10 , 0.1, 0.0) );
        vec4 lHair2Bezier = sdBezier( vec3(0.0), vec3(0.0,0.35,0.05), vec3(0.2,0.4,0.1), lHeadPos - vec3( 0.00 , -0.1, 0.01) );
        vec4 lHair3Bezier = sdBezier( vec3(0.0), vec3(0.0,0.28,0.0), vec3(-0.12,0.3,0.0), lHeadPos - vec3(-0.01 , -0.1, 0.0) );
        lHeadSticks = lHair1Bezier.x - 0.006;
        lHeadSticks = min(lHeadSticks, lHair1_2Bezier.x - 0.006);
        lHeadSticks = min(lHeadSticks, lHair2Bezier.x - 0.006);
        lHeadSticks = min(lHeadSticks, lHair3Bezier.x - 0.006);
    }
	
	//BODY
    float lBodyBox = sdBox( pos-vec3( -0.2, 0.4, 0.0), vec3(0.4,0.4,0.3) );
    if(res.x > lBodyBox)
    {
    
        //res = opU( res, vec2( lBodyBox, 4.0) );

        //Feet
        float lFeet = sdRoundedCappedCone( pos - vec3(-0.02, 0.06, 0.0) , vec3(0.04, 0.11, 0.09) * 0.3, 0.08);
              lFeet = min(lFeet, sdRoundedCappedCone( rotation(Z_AXIS, M_PI * 0.5) * (pos - vec3(-0.43, 0.40, 0.0)) , vec3(0.04, 0.11, 0.09) * 0.2, 0.08));

        float lBody = sdRoundedCappedCone( rotation(Z_AXIS, M_PI * 0.23) * (pos - vec3(-0.13, 0.35, 0.0)) , vec3(0.04, 0.12, 0.09) * 0.6, 0.19);
              lBody = min(lBody, sdRoundedCappedCone( rotation(Z_AXIS, M_PI * 0.1) * (pos - vec3(0.0, 0.6, 0.0)) , vec3(0.04, 0.1, 0.07) * 0.35, 0.15));
              lBody = min(lBody, lFeet);

        //Snow Body
        res = opU( res, vec2( lBody, 3.0) );

        //Black Spheres
        float 	lBlackSpheres = sdEllipsoid(rotation(X_AXIS, -0.2) * (pos - vec3(0.0, 0.66, -0.16)), vec3(0.05, 0.05, 0.04));
                lBlackSpheres = min(lBlackSpheres, sdEllipsoid(rotation(X_AXIS, -0.2) * (pos - vec3(-0.1, 0.42, -0.23)), vec3(0.05, 0.05, 0.04)));
                lBlackSpheres = min(lBlackSpheres, sdEllipsoid(rotation(X_AXIS, 0.2) * (pos - vec3(-0.2, 0.32, -0.24)), vec3(0.05, 0.05, 0.04)));	
        if(res.x > lBlackSpheres )
        {
            vec3 lNoise = GrNoiseIq((pos) * iResolution.x * 0.04);
            lBlackSpheres += lNoise.y*lNoise.x*0.0022;
            res = opU( res, vec2( lBlackSpheres, 4.0) );
        }
    }

    //Arms
    float lArms = sdCappedCone( rotation(Z_AXIS, M_PI * 0.28) * (opMirrorX(pos) - vec3(0.23, 0.75, 0.0)), 0.14, 0.015, 0.01 ); //vec2(0.013, 0.2)
          lArms = opSmoothUnion(lArms, sdCappedCone( rotation(Z_AXIS, M_PI * 0.22) * (opMirrorX(pos) - vec3(0.405, 0.92, 0.0)), 0.11, 0.01, 0.008 ), 0.005); //vec2(0.013, 0.2)
    
    float lHandsBoxes = sdBox( opMirrorX(pos) - vec3(0.5, 1.0, 0.0), vec3(0.06,0.07,0.05) );
    if(res.x > lHandsBoxes)
    {
		 //Fingers
        lArms = opSmoothUnion(lArms,  sdCapsule( (opMirrorX(pos) - vec3(0.47, 1.0, 0.0)), vec3( 0.03,  0.07, 0.0), 	vec3( 0.0, 0.0, 0.0), 0.005), 0.006);
        lArms = opSmoothUnion(lArms,  sdCapsule( (opMirrorX(pos) - vec3(0.47, 1.0, 0.0)), vec3( 0.06, 0.06, 0.0), 	vec3( 0.0, 0.0, 0.0), 0.005), 0.006);
        lArms = opSmoothUnion(lArms,  sdCapsule( (opMirrorX(pos) - vec3(0.47, 1.0, 0.0)), vec3( 0.07, 0.02, 0.0), 	vec3( 0.0, 0.0, 0.0), 0.005), 0.006);
        //Little Finger
        lArms = opSmoothUnion(lArms,  sdCapsule( (opMirrorX(pos) - vec3(0.46, 0.976, 0.0)), vec3( -0.01,  0.04, 0.0), 	vec3( 0.0, 0.0, 0.0), 0.005), 0.006);
    }
    
    //END BODY
	//float lArms = 1e10;
    //float lHeadSticks = 1e10;
    //Wood perturbations
    float lWood = min(lArms, lHeadSticks);
    if(res.x > lWood )
    {
        vec3 lNoise = GrNoiseIq((pos) * iResolution.x * 0.015);
        lWood += mix(0.0, 0.5, lNoise.y*lNoise.x)*0.005;
   		res = opU( res, vec2( lWood, 6.0) );
    }

    //Debug reference
    //float lFront = sdSphere(pos - vec3(0.0, 0.66, -0.5), 0.08);
    //res = opU( res, vec2( lFront, 4.0) );
    return res;
}

// Function 1203
float Scene( vec3 pos )
{
    float f = Sphere(vec3(0,1,-1),1.,pos);
    
    // ripply sphere (*.8 to keep SDF gradient <= 1.0)
    f = min(f,Sphere(vec3(1,-1,-1),1.,pos)*.8 + sin(pos.y*20.+iTime*3.)*.03);

    f = min(f,Superellipsoid(vec3(0,0,1),.7,1./(.5+.48*sin(iTime*1.3)),pos));
    
    // cut a circular chunk out of the scene
    f = max(f,-Sphere(vec3(0,0,-.5),1.,pos));
    
    // this sphere is combined after the cut-out sphere, so it doesn't get cut
    f = min(f,Sphere(vec3(-1,-1,-1),.8,pos));

	// floor
    f = min(f,Sphere(vec3(0,-20,0),18.,pos));
    
    return f;
}

// Function 1204
float GetSceneDist(vec3 p, float iTime)
{
    float dist = MAX_DIST;

    float voronoi_scale = cos(iTime / 6.) * 5. + 2.;

    { // Left side, center distance
        vec3 c = vec3(-1.1, 0, MOVE_SPHERES ? cos(iTime / 3. + (PI / 2. * 3.)) * 1.4 : 0.);
        float sphere_dist = SphereDist(p, c, 1.);
        float inner_sphere_dist = SphereDist(p, c, 0.92);
        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);
        
        // optimization
        if (hollow_sphere_dist <= MIN_DIST * 2.)
        {
          vec3 voronoi_color; // not used
          float voronoi_dist = VoronoiDist(p * voronoi_scale, 0.4, voronoi_color);
          voronoi_dist /= voronoi_scale;

          dist = min(dist, max(voronoi_dist, hollow_sphere_dist));
        }
        else
        {
            dist = min(dist, hollow_sphere_dist);
        }
    }

    { // Right side, edge distance
        vec3 c = vec3(1.1, 0, MOVE_SPHERES ? cos(iTime / 3. + PI / 2.) * 1.4 : 0.);
        float sphere_dist = SphereDist(p, c, 1.);
        float inner_sphere_dist = SphereDist(p, c, 0.92);
        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);

        if (hollow_sphere_dist <= MIN_DIST * 2.)
        {
            vec3 voronoi_color; // not used
            float voronoi_dist = VoronoiEdgeDist(p * voronoi_scale, 0.08, voronoi_color);
            voronoi_dist /= voronoi_scale;

            dist = min(dist, max(voronoi_dist, hollow_sphere_dist));
        }
        else
        {
            dist = min(dist, hollow_sphere_dist);
        }
    }

    return dist;
}

// Function 1205
float sdf_quarter0_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(-pos.y, pos.x));
}

// Function 1206
float allOrbsSDF(in vec3 iPoint) {
    
    float d = orbSDF(iPoint, orbPosition0, 0.15);
    d = min(d, orbSDF(iPoint, orbPosition1, 0.1));
    d = min(d, orbSDF(iPoint, orbPosition2, 0.05));
    d = min(d, orbSDF(iPoint, orbPosition3, 0.1));
    return d;
    
}

// Function 1207
float sceneSDF(vec3 p) {
    p /= scale;
    float result = 1.1+dunes(p/100.0,10.0)+max(max(planet_surface(p),cave(p)),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));
    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));
    return result*scale;
}

// Function 1208
float MapRocks(vec3 p)
{
  GetRockRotation(p);
  vec3 checkPos = p;
  checkPos.xz = pModPolar(checkPos.xz, 230.0);
  checkPos-=vec3(124, 0., 0.);
  pModInterval1(checkPos.x, 6., 0., 4.);
  return sdSphere(checkPos, pow(0.5+noise(p*0.44), 2.)*1.5);
}

// Function 1209
float sdfIntersect(float a, float b) {
  return max(a, b);
}

// Function 1210
vec2 getDist(vec3 origin)
{
    float sd = MAX_DIST;
    float id = 0.0;
    float las = laser(origin);
    float box = -box(vec3(1, 0.6, 6), vec3(0), origin);
    
    if (las < sd)
    {
        sd = las;
        id = 1.0;
    }
    
    if (box < sd)
    {
        sd = box;
        id = 2.0;
    }
    
    return vec2(sd, id);
}

// Function 1211
float distanceToSegment(vec2 p, vec2 v, vec2 w)
{
    return sqrt(distanceToSegmentSquared(p,v,w));
}

// Function 1212
vec4 MarchMap(inout Ray ray) {//total, min, steps, mat
	vec4 dist = vec4(0, MARCH_maxl, 0, 0);//total, min, steps, mat
    vec2 d = vec2(1, 0);
    
    for (int i = 0; i < MARCH_itr; i++) {
        if (!(d.x > MARCH_eps && dist.x < MARCH_maxl)) break;
    	d = Map(ray.pos);
        dist.x += d.x;
        if (dist.y > d.x)
            dist.yw = d;
        dist.z++;
        
        ray.pos += d.x*ray.vel;
    }
    dist.x = min(dist.x, MARCH_maxl);
	return dist/MARCH_norm.yyzw;
}

// Function 1213
vec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz ,0.);
  vec4 y = textureLod( sam, p.zx ,0.);
  vec4 z = textureLod( sam, p.xy ,0.);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1214
float map( in vec3 pos )
{
    const float GEO_SPHERE_RAD = 0.5;
    return length(pos)-GEO_SPHERE_RAD;
}

// Function 1215
vec2 sdf_union(vec2 a, vec2 b)
{
    return (a.x < b.x) ? a : b;
}

// Function 1216
float dist(vec3 p)
{
    float d=1e3;

    vec3 p2=p;
    float s=1.;
    for(int i=0;i<4;++i)
    {
        p2.xz=abs(p2.xz);   
        float cl=max(max(p2.x,p2.z),dot(p2.xz,normalize(vec2(1))));
        float r=20.;
        cl=min(cl-r+1.,max(box(vec3(p2.x,mod(p2.y,10.)-5.,p2.z),vec3(0),vec3(r,6.,r)),cl-r));
        cl=max(cl,p2.y-50.+float(i)*80.);
        if(i==3)cl=max(cl,p.y+25.);
        cl/=s;
        if(i==2)cl=max(cl,dot(p.yz-vec2(0,25),normalize(vec2(1))));
        d=min(d,cl);
        p2*=2.;
        p2.xz=mod(p2.xz,100.)-50.;
        s*=2.;
    }

    p2=abs(p-vec3(74,0,-35));
    float cl=max(max(p2.x,p2.z),dot(p2.xz,normalize(vec2(1))))-6.;
    d=min(d,cl);

    p2=p;

    d=min(d,distance(p,vec3(0,50,0))-14.);

    {
        vec3 p2=p;
        p2.xz=mod(p2.xz,10.)-5.;
        p2.xz=abs(p2.xz);
        d=min(d,p.y+52.+max(p2.x,p2.z));
    }

    {
        vec3 p2=p;
        p2.xz=mod(p2.xz,80.)-40.;
        p2.xz=abs(p2.xz);
        d=min(d,p.y+41.+max(p2.x,p2.z));
    }

    d=min(d,max(p.y+15.,p.z+60.));

    d=min(d,max(box(p,vec3(0,-70,0),vec3(31)), -box(p,vec3(0,-25,0),vec3(20))));

    d=min(d,box(p,vec3(0,30,19),vec3(15,9,2)));

    d=max(d,box(p,vec3(0),vec3(85,64,67)));


    p2=p;
    for(int i=0;i<4;++i)
    {
        vec3 p3=p2;
        p2.y-=cos(float(i)*9.)*23.;
        p3.xz=min(p3.xz,1.);
        float rr=distance(p3.xz,normalize(p3.xz)*27.)-5.;
        d=min(d,max(rr,abs(p3.y)-2.));
        p2.xz=p2.zx*vec2(1,-1);
    }

    d=max(d,box(p,vec3(0),vec3(85,64,67)+40.));


    return d;
}

// Function 1217
float distanceField(vec3 p) {
	float sphere1 = sdSphere(p - vec3( 1.50, -1.0, 1.20), 1.8);
    float sphere2 = sdSphere(p - vec3(-1.00,  0.0, 0.80), 1.8);
    float sphere3 = sdSphere(p - vec3(0.50,  0.5, 0.80), 0.8);
	float box = sdBox(p - vec3(0.0, 0.0, 0.0), vec3(3.5, 2.0, 1.0));
	float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));
	return join(carve(carve(carve(box, sphere1), sphere2), sphere3), plane);
}

// Function 1218
vec2 Scene(vec3 p)
{
    vec2 d = vec2(MAX_DIST, SKYDOME);
    
    d = opU(d, sdPlane(p, vec4(0, 0,-1, 0), FLOOR));
    
    d = opU(d, sdMaze(p, WALLS));
    
	return d;
}

// Function 1219
float map2( in vec3 p )
{
    float h = terrain2(p.xz);


    float ss = 0.03;
    float hh = h*ss;
    float fh = fract(hh);
    float ih = floor(hh);
    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );
    h = (ih+fh)/ss;

    return p.y - h;
}

// Function 1220
ctx scene_warp(ctx cx) {
    
    cx = scene(cx);
   	float d = cx.distance_;
    
    vec3 p = cx.point;

    //cloud shape deform
    if (cx.deformAmount > 0.0) {
        #define ldst d
        for (int i = 1; i < 4; i++) {
            float pfi = pow(float(i),2.)*cx.deformScale,
                	dmx = mix(1.,ldst+cos((p.x+p.y+p.z)/pfi)*pfi,cx.deformRoughness);
            ldst -= abs(cos(p.x/pfi+cos(26.2348+dmx*(p.y*.39)/pfi)*4.)*
                     cos(p.y/pfi+cos(29.8937+dmx*(p.z*.37)/pfi)*4.)*
                     cos(p.z/pfi+cos(14.972+dmx*(p.x*.41)/pfi)*4.))*pfi*cx.deformAmount;
        }
    }
    
    cx = scenePlain(cx);
    cx.distance_ = max(skipDelta, min(d,cx.distance_));
    return cx;
}

// Function 1221
float o349467_input_sdf_b(vec3 p) {
    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);
}

// Function 1222
void traceScene( inout vec4 pos, inout vec4 dir, out vec4 colour,
                 out vec3 pureColour, out vec3 transfer, out vec3 atmos, out vec4 normal,
                 float time, float noise )
{    
    float nxDist   = 99999.0;
    vec4  nxColour = vec4(0., 0., 0., 0.);
    vec4  nxNormal = vec4(0., 0., 0., 0.);
    
    if (dir.x < 0.) {
        tracePlanar( pos.x+1., -dir.x, vec4(0.2, 0.9, 0.2, 0.0), vec4(1., 0., 0., 0.),
                     nxDist, nxColour, nxNormal );
    }
    else {
        tracePlanar( pos.x-1., -dir.x, vec4(0.9, 0.2, 0.2, 0.0), vec4(-1., 0., 0., 0.),
                     nxDist, nxColour, nxNormal );
    }
    if (dir.y < 0.) {
        tracePlanar( pos.y+1., -dir.y, vec4(0.8, 0.79, 0.78, 0.85), vec4(0., 1., 0., 0.),
                     nxDist, nxColour, nxNormal );
    }
    else {
        tracePlanar( pos.y-1., -dir.y, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., -1., 0., 0),
                     nxDist, nxColour, nxNormal );
    }
    if (dir.z < 0.) {
        tracePlanar( pos.z+1., -dir.z, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., 0., 1., 0.),
                     nxDist, nxColour, nxNormal );
    }
    else {
        tracePlanar( pos.z-1., -dir.z, vec4(0.8, 0.79, 0.78, 0.0), vec4(0., 0., -1., 0.),
                     nxDist, nxColour, nxNormal );
    }
    if (dir.w < 0.) {
        tracePlanar( pos.w+1., -dir.w, vec4(0.28, 0.29, 0.78, .5), vec4(0., 0., 0., 1.),
                     nxDist, nxColour, nxNormal );
    }
    else {
        tracePlanar( pos.w-1., -dir.w, vec4(0.9, 0.9, 0.0, 0.5), vec4(0., 0., 0., -1.),
                     nxDist, nxColour, nxNormal );
    }
    
    traceObjects(pos, dir, nxDist, nxColour, nxNormal, time); 
    
    vec4 lightPos = vec4(0, 0.8, 0., -0.8);
    
    traceSphere(pos - lightPos, dir, .1, vec4(10., 10.0, 10.0, -1.0),
                nxDist, nxColour, nxNormal);

    pos += dir * nxDist;
    
    if (pos.y <= -0.99999) {
        float check = (floor(mod(pos.x * 5., 2.)) == floor(mod(pos.z * 5., 2.))) ? 1. : 0.;
        check = mod(pos.w * 5., 2.) < 1. ? (1. - check) : check;
                      
        nxColour.xyz *= vec3(0.2, 0.1, 0.05) * check + vec3(0.9, 0.87, 0.85) * (1. - check);
        
        nxColour.w *= 1. - (1. - check * 0.7);
        
        float tileA = mod((0.5 + pos.x) * 5., 1.);
        float tileB = mod((0.5 + pos.z) * 5., 1.);
        float tileC = mod((0.5 + pos.w) * 5., 1.);
        
        float fade  = max(0., 1. - (min(abs(0.5 - tileC), min(abs(0.5 - tileA), abs(0.5 - tileB)))) * 17.);
        fade = min(1., fade * 4.);
        
        nxNormal.x -= (-.5 + tileA * 1.) * max(0., 1. - abs(0.5 - tileA) * 5.);
        nxNormal.z -= (-.5 + tileB * 1.) * max(0., 1. - abs(0.5 - tileB) * 5.);
        nxNormal.w -= (-.5 + tileC * 1.) * max(0., 1. - abs(0.5 - tileC) * 5.);
        
        nxColour = nxColour * (1. - fade) + vec4(0.9, 0.9, 0.9, .0) * fade;
        
        nxNormal = normalize(nxNormal);
    }
    if (pos.z <= -0.999999) {
        //nxColour.xyz = vec3(999.);
        
        vec3 norm = texture(iChannel2, pos.xyw * 2.5).xyz;
        
        nxNormal.xyw += (-.5 + norm * .5);
        nxNormal = normalize(nxNormal);
    }
    
    vec4 lightDir = lightPos - pos;
    float lightDist = length(lightDir);
    lightDir /= lightDist;
    float lightEff = max(0., dot(lightDir, nxNormal));
    
    float lightTstDist = 9999.;
    vec4 dummy;
    
    vec4 ref = nxNormal * max(0., dot(nxNormal, dir));
    ref += (dir - ref);
    
    float spec = pow(max(0., dot(ref, lightDir)), 1. - dot(nxNormal, dir) * 2.);
    
    traceObjects(pos, lightDir, lightTstDist, dummy, dummy, time);
    if (lightTstDist < lightDist || dot(nxNormal, lightDir) < 0.0) {
        lightEff *= 0.;
        spec *= 0.;
    }
    
    float atmosWeight = 1.;
    
    float atmosStep = (nxDist / 17.0);
    float atmosNoise = noise / 17.0;
    for (int i = 0; i < 16; i++) {
        vec4 tmpPos = pos - dir * (float(i) * atmosStep) + atmosNoise;

        lightDir = normalize(lightPos - tmpPos);

        float lightTstDist = 9999.;
        vec4 dummy;

        traceObjects(tmpPos, lightDir, lightTstDist, dummy, dummy, time);
        if (lightTstDist < lightDist) {
            atmosWeight -= 1. / 16.;
        }
    }
    
    vec3 lighCol = vec3(8.0, 7.9, 6.6) * 3.;
    
    float lightAng = 0.5 - (0.4 * acos(lightDir.y) / 3.1415);
    
    lighCol *= texelFetch(iChannel1, ivec2(lightAng, .5), 0).xxx;
    
    pureColour = nxColour.xyz;
    colour.xyz = pureColour * lightEff * pow(0.33, lightDist) * lighCol;
    colour.xyz += lighCol * pow(0.33, lightDist) * spec * 1.;
    colour.w = nxColour.w;
    
    if (nxColour.w < 0.) {
        colour = vec4(lighCol.x, lighCol.y, lighCol.z, 0.);
    }
    
    normal = nxNormal;
    
    //pureColour.x = 1. / nxDist;
    
    atmos    = 1. - pow(vec3(0.8, 0.85, 0.9), vec3(nxDist*2.));
    transfer = pow(vec3(0.8, 0.85, 0.9), vec3(nxDist*2.));
    
    
    atmos *= atmosWeight;
}

// Function 1223
vec4 cubesdf(vec3 pos) {
    float xp = pos.x - 3.;
    float xm = 1. - pos.x;
    float yp = pos.y - 1.;
    float ym = -1. - pos.y;
    float zp = pos.z - 4. + 1.*sin(iTime);
    float zm = 2. -1.*sin(iTime) - pos.z;
    vec3 norm = vec3(1, 0, 0) * exp(xp*WEIGHT) + vec3(-1, 0, 0) * exp(xm*WEIGHT) + vec3(0, 1, 0) * exp(yp*WEIGHT) + vec3(0, -1, 0) * exp(ym*WEIGHT) + vec3(0, 0, 1) * exp(zp*WEIGHT) + vec3(0, 0, -1) * exp(zm*WEIGHT);
    float d = max(xp, xm);
    d = max(d, yp);
    d = max(d, ym);
    d = max(d, zp);
    d = max(d, zm);
    return vec4(normalize(norm), d);
}

// Function 1224
RayTraceSceneResult RayTraceScene(in Ray ray, bool bIgnoreDummyLight)
{
    const int nbObj = 3 + cylinderCount;
    RayTraceResult obj[nbObj];
    
    obj[0] = RayTraceHoledSphereDoubleSize(ray);
    obj[1] = RayTraceRoom(ray);
    obj[2] = RayTraceSphere(ray, lightPos, .3);
    
    if (bIgnoreDummyLight)
    {
        obj[2].t = infinite;
    }
    
    for (int c = 0; c < cylinderCount; ++c)
    {
    	obj[c+3] =  RayTraceCylinder(ray, cylinderData[c].xyz, cylinderRadius, cylinderData[c].w);
    }
    
    float minT = infinite;
   	RayTraceSceneResult res; res.emissive = vec3(0.); res.color = vec3(0.);
    int hitI = 0;
    for (int i = 0; i < nbObj; ++i)
    {
        if (minT > obj[i].t)
        {
           	res.hit = obj[i];
            minT = obj[i].t;
            hitI = 0;
        }
    }
    
    if (hitI == 2) //Dummy light
    {
        res.emissive = (ComputeLightPattern(normalize(lightPos - obj[2].pos)) + 0.2);
        res.emissive *= 64.0;
    }
    else
    {
        res.color = colorWhite;
    }
    
    return res;
}

// Function 1225
float distToLine(vec2 A, vec2 B, vec2 p){
    
    vec2 PA = p - A;
    vec2 BA = B - A;
    float d = dot(PA,BA);
    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt
    vec2 normal = PA - BA*t;
    return length(normal);

}

// Function 1226
float boxDist(vec2 p, vec2 size, float radius)
{
	size -= vec2(radius);
	vec2 d = abs(p) - size;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

// Function 1227
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    float eps = EPSILON;
    int iters = 0;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = sceneSDF(eye + depth * marchingDirection,iters);
        if (dist < eps*(depth+1.0)) {
			if(iters < 2){
                iters += 1;
                eps /= 2.0;
            }
            else
            return depth;
        }
        depth += dist;
        //eps *= 1.01;
        //eps *= 1.01;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 1228
mat3 combinedDistance(vec3 pos) {
	float dist;
    float material;
    vec3 shadingParameters;
   
    vec4 ground = planeDistance(pos, vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0));
    dist = ground.w;
    material = float(MATERIAL_FLOOR);
    shadingParameters.xy = ground.xz;
    
    float side = pos.x < 0.0 ? 1.0 : -1.0;
    vec4 wall = planeDistance(pos, vec3(-3.0*side,0.0,0.0), vec3(1.0*side,0.0,0.0));
    if (wall.w < dist) {
        dist = wall.w;
        material = float(MATERIAL_WALL);
        shadingParameters.xy = wall.zy;
    }

    float modPos = floor(pos.z/5.0+0.5);
    vec3 screen = rectDistance(pos, vec3(-2.9*side, 1.0, modPos*5.0), vec3(-1.0*side,0.0,0.0), 1.0);
    if (screen.x < dist) {
        dist = screen.x;
        float screenIndex = abs(modPos) + side;
        material = floor(mod(screenIndex, float(PICTURE_COUNT)));
        material += float(MATERIAL_PICTURE_FIRST);
        shadingParameters.xy = screen.yz;
    }

    vec3 frame = rectDistance(pos, vec3(-2.95*side, 1.0, modPos*5.0), vec3(-1.0*side,0.0,0.0), 1.2);
    if (frame.x < dist) {
        dist = frame.x;
        material = float(MATERIAL_FLOOR);
        shadingParameters.xy = frame.yz;
    }

    float timberHeight = 10.0;
    float modTimberPos = floor(pos.z/10.0+0.5);
    float timber = boxDistance(pos, vec3(-3.0*side,0.0,2.5+modTimberPos*10.0), vec3(1.0, timberHeight, 0.5));
    if (timber < dist) {
        dist = timber;
        material = float(MATERIAL_FLOOR);
    }
    
    float timberHigh = boxDistance(pos, vec3(-3.0*side,timberHeight/2.0,pos.z), vec3(1.0, 1.0, 0.5));
    if (timberHigh < dist) {
        dist = timberHigh;
        material = float(MATERIAL_FLOOR);
    }
    
    vec3 carpet = rectDistance(pos, vec3(0.0, -0.99, pos.z), vec3(0.0, -1.0, 0.0), 1.0);
    if (carpet.x < dist) {
        dist = carpet.x;
        material = float(MATERIAL_CARPET);
    }
                      
    return mat3(dist, material, 0.0,
                shadingParameters.x, shadingParameters.y, shadingParameters.z,
                0.0, 0.0, 0.0);
}

// Function 1229
float map4( in vec3 p )
{
	vec3 q = p - vec3(0.0,0.1,1.0)*iTime;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q ); q = q*2.01;
    f += 0.06250*noise( q );
	return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

// Function 1230
float get_distance(vec3 point) {
	float bump = 0.0;
	float elevation = -1.0;
	
	if ( length(point) < R + bump_factor) {
		bump = bump_factor * texture3d(iChannel1, point, normalize(-point), 0.5).r;
	}
	return min(
		length(point) - R + bump,
		dot(point, vec3(0.0, 1.0, 0.0)) - elevation
	);
}

// Function 1231
float GetDist(vec3 p) {
    float pd = p.y;
    
    vec3 bp1 = p-vec3(5, 1.5, 0.0);
    vec3 bp2 = p-vec3(4, 1.5, 0.0);
    vec3 bp3 = p-vec3(0, 1.5, 0.0);
    vec3 bp4 = p-vec3(-4.5, 1.5, 0.0);
    bp1.yz *= rot(iTime*3.141*0.5);
    bp2.yz *= rot((iTime*3.141*0.5)+(3.141*0.5));
    bp3.xz *= rot((-iTime*3.141*0.125));
    
    float bd1 = sdTorus(bp1, vec2(1, 0.5));
    float bd2 = sdTorus(bp2, vec2(1, 0.5));
    float bd3 = dBox(bp3, vec3(1.0, 0.5, 1.0));
    float bd4 = sdCapsule(bp4, vec3(1.5, sin(iTime*3.141*0.25), 2.0), vec3(0.5, cos(iTime*3.141*0.25), -2.0), 0.5);
    float d = min(bd1, bd2);
    d = min(d, bd3);
    d = min(d, bd4);
    d = min(d, pd);
    
    return d;
}

// Function 1232
HitQuery intersect_scene(Ray ray, Scene scene) { 
    HitQuery neareast_hit = no_hit;
    
    // find nearest intersected object in the scene (no need for shadow ray)
    for (int i = 0 ; i < nb_emiters ; i++) {
        
        // test intersection with current object
        HitQuery sphere_hit = intersect_sphere(ray, scene.emiters[i]);
        
        // if the object is not intersected, go to next one
        if (sphere_hit.material == none) {
            continue;
        }
        
        // if closer, set as current hit
        if (sphere_hit.t <= neareast_hit.t) {
            neareast_hit = sphere_hit;
        }
        
    }
    
    // find nearest intersected object in the scene (no need for shadow ray)
    for (int i = 0 ; i < nb_objects ; i++) {
        
        // test intersection with current object
        HitQuery sphere_hit = intersect_sphere(ray, scene.objects[i]);
        
        // if the object is not intersected, go to next one
        if (sphere_hit.material == none) {
            continue;
        }
        
        // if closer, set as current hit
        if (sphere_hit.t <= neareast_hit.t) {
            neareast_hit = sphere_hit;
        }
        
    }
    return neareast_hit;
    
}

// Function 1233
float differenceSDF(float distA, float distB)
	{ return max(distA, -distB);}

// Function 1234
float differenceSDF(float distA, float distB) 
{
    return max(distA, -distB);
}

// Function 1235
float sceneDistance(vec3 p, inout int material){
    
    float distance = 9999.9;
    material = 0;
    
    
    
    hardAdd(material,distance,1,
    	-obj_cylForever(p.xz, vec2(0.0),bgDist)
    );
    
    
    const float outlineRad = 0.02;
    vec2 healthSize = vec2(0.25,0.3)/2.0;
    if (abs(p.x)<healthModX*2.0) {
        
        vec3 healthP = p;
        healthP.y -= 0.85;
        
        healthP.x = mod(healthP.x,healthModX);
        healthP.x -= healthModX/2.0;
        
        vec3 healthFrameP = healthP;
        healthFrameP.y = abs(healthFrameP.y);
        healthFrameP.x = abs(healthFrameP.x);
        
        
        const float boxThickness = 0.03;
        hardAdd(material,distance,3,
			obj_box(healthFrameP,vec3(0.0,0.0,healthDist-boxThickness+0.01),vec3(healthSize.xy,boxThickness),0.0)
		);
        
        const float healthInset = 0.01;
        smoothSubtract(distance,
            obj_box(healthP,vec3(0.05,-0.075,healthDist),vec3(0.075,0.125,healthInset),0.0),
        	0.01
        );

        
        hardAdd(material,distance,2,
            obj_quartertorus(healthFrameP,vec3(healthSize.xy,healthDist),vec2(outlineRad,outlineRad-0.001))
        );
        
        
        
        vec3 wheelP = healthP;
        wheelP.x -= 0.05;
        wheelP.x = abs(wheelP.x);


        wheelP.y += 0.05;
        wheelP.y = abs(wheelP.y);

        hardAdd(material,distance,2,
        	obj_cylinder(wheelP,vec3(0.0,0.05,healthDist-healthInset),vec2(0.05,0.025),0.0075)
        );
        hardAdd(material,distance,2,
        	obj_cylinder(wheelP,vec3(0.05,0.05,healthDist-healthInset),vec2(0.05,0.025),0.0075)
        );

    }
    
    vec3 statusP = p;
    statusP.y -= 2.1;
    statusP.y = abs(statusP.y);
    
    statusP.x += 0.6;
    statusP.x = abs(statusP.x);
    
    const float statusW = 1.2;
    const float statusH = 0.3;
    const float statusDist = -3.0;
    const float innerRad = 0.025;
    
    hardAdd(material,distance,2,
    	obj_quartertorus(statusP,vec3(statusW,statusH,statusDist),vec2(innerRad*2.0,innerRad))
    );
    hardAdd(material,distance,4,
    	obj_box(statusP,vec3(0.0,0.0,statusDist-0.005),vec3(statusW+innerRad,statusH+innerRad,0.01),0.0)
    );
    
    
    
    
    float ufoHeight = enemyHeight+sin(iTime*2.5)*0.02;
    obj_ufo(p,vec3(-enemyOffX,ufoHeight,enemyDist),0.05,material,distance);
    
    
    
    
    const float foppyWidth = 0.1;
    float foppyBob = pow(1.0-(sin(iTime*4.0)*0.5+0.5),1.1);
    float foppyHeight = enemyHeight+0.3 + foppyBob*0.03;
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX+foppyWidth,foppyHeight,enemyDist),0.2)
	);
    smoothAdd(distance,
    	obj_ball(p,vec3(enemyOffX-foppyWidth,foppyHeight,enemyDist),0.2),
	0.3);
    
    float legOff = 0.25 - foppyBob*0.02;
    float legSize = 0.09 - foppyBob*0.01;
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX-legOff,enemyHeight+0.1,enemyDist+0.2),legSize)
	);
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX+legOff,enemyHeight+0.08,enemyDist-0.1),legSize)
	);
    
    
    vec3 foppyEyeP = p;
    foppyEyeP.x -= enemyOffX-0.05;
    foppyEyeP.x = abs(foppyEyeP.x);
    
    hardAdd(material,distance,8,
    	obj_ball(foppyEyeP,vec3(0.1,foppyHeight+0.07,enemyDist+0.26),0.015)
	);
    
    
    
    return distance;
    
}

// Function 1236
float BaublesSDF( vec3 pos, uint seed, float spacing, float radius )
{
    // avoid looping over every bauble - find closest one from a handful of candidates, using a jittered grid
    float f = BaubleBoundsSDF(pos);
    f -= radius;
    
    float margin = .1; // distance at which to start computing bauble SDFs - affects speed of marching (trial and error suggests .1 is fairly optimal)
    if ( f > margin ) return f;
    
	vec3 offset = spacing*(hash3(coord1(seed))-.5); // use a different grid for each set of baubles
    offset += PATTERN_SCROLL*iTime;
	pos += offset;

    // find closest centre point
    vec3 c = floor(pos/spacing);
    ivec3 ic = ivec3(c);
    c = (c+.5)*spacing; // centre of the grid square
    
    c += (spacing*.5 - radius /*- margin*/) * ( hash1(coord3(uvec3(ic+63356))^seed)*2. - 1. );
    
    // cull it if it's outside bounds
    if ( BaubleBoundsSDF(c-offset) > 0. ) return margin; // could do max (margin, distance to grid cell edge)
    
    return min( length(pos-c)-radius, margin ); // don't return values > margin otherwise we'll overshoot in next cell!
}

// Function 1237
float sphereSDF(vec3 p) {
    return length(p) - 1.0 - (uv(p, normalize(p), iChannel1).r * 0.1);
}

// Function 1238
float map004(vec2 c)
{
    c.x *= -1.;
    c -= vec2(0.9, -0.8);
    
	float h;
    
    vec2 z = vec2(0.);
    vec2 dz = vec2(0.);
    float m = 0.;
    
    for(int i = 0; i < 20;++i)
    {
        if(m > 1024.)
            break;
        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);
        z = cx_pow2(z) + c;
        
        m = dot(z,z);
    }
    
    float d = 0.5*sqrt(m/dot(dz,dz))*log(m);

    return d*0.8;
}

// Function 1239
float map(in vec3 p, out vec3 col, bool req_color) {
    vec3 shell_col;
    float shell_d = mapShell(p.yzx, shell_col, req_color);  // call mapShell
    float beach_d = p.z+1.5;  // beach surface: z=-1.5
    beach_d += 0.001*sin(20.0*p.x)*sin(20.0*p.y) + 0.0005*(sin(51.0*p.x)+sin(50.0*p.y));  // deform the surface of the beach
    vec3 beach_col = vec3(0.95,0.8,0.5);  // color of the beach
    float d = min(shell_d, beach_d);  // final signed distance
    if (d==shell_d) col = shell_col;  // closer to nautilus shell
    else col = beach_col;  // closer to beach
    return d;
}

// Function 1240
float map(in vec2 p) {
    vec2 h = exp(-(p*p*0.5));
    return scmin.y + 0.1 + hash2(p).x * 0.5 
        + texture(iChannel0, vec2(hash2(p).x, 0.0)).r*2.0 + h.x*h.y*0.5;
}

// Function 1241
float dist_cell(vec3 pos) {
 	vec3 v0 = vec3(sin(iTime/3.), 0., cos(iTime)) - pos;
    vec3 v1 = vec3(-sin(iTime), 0., -cos(iTime)) - pos;
    vec3 v2 = vec3(0., cos(iTime), sin(iTime/2.)) - pos;
    vec3 v3 = vec3(sin(iTime), cos(iTime), sin(iTime)) - pos;
    float l0 = length(v0) - 1.8;
    float l1 = length(v1) - 1.7;
    float l2 = length(v2) - 1.6;
    float l3 = length(v3) - 1.5;

    return opSmoothUnion(opSmoothUnion(opSmoothUnion(l0, l1, .4), l2, 0.4), l3, 0.4);
    return 1. + 1./l0 + 1./l1;
}

// Function 1242
float boxSDF(vec3 p, vec3 b) {
    vec3 d = abs(p) - b;
    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 1243
float get_distance(vec2 uv)
{
    // Fix the aspect ratio:
    uv.x *= 2.0;
    
    // Small adjustment to create a hole at the top.
    // This should be baked into the texture.
    float y_scale = smoothstep(0.8, 1.0, uv.y);
    return(depth_offset - texture(iChannel1, uv).r * depth_scale + y_scale);
}

// Function 1244
float map(vec3 p, int num){
    //float d = length(p-vec3(0.0,0.0,1.0)) - 0.25;
    float d =  loaddist;
    if(num == 0){
        d = sdBox(p - vec3(0.0,0.0,0.2), vec3(0.3,0.3,0.3));
    }
    if(num == 1){
        d = sdBox(p - vec3(0.2,0.05,-0.4), vec3(0.2,0.15,0.2));
    }
	return d;
}

// Function 1245
float map (vec3 pos) {
  float scene = 1000.;
  float wallThin = .2;
  float wallRadius = 8.;
  float wallOffset = .2;
  float wallCount = 10.;
  float floorThin = .1;
  float stairRadius = 5.;
  float stairHeight = .4;
  float stairCount = 40.;
  float stairDepth = .31;
  float bookCount = 100.;
  float bookRadius = 9.5;
  float bookSpace = 1.75;
  vec3 bookSize = vec3(1.,.2,.2);
  vec3 panelSize = vec3(.03,.2,.7);
  vec2 cell = vec2(1.4,3.);
  float paperRadius = 4.;
  vec3 paperSize = vec3(.3,.01,.4);
  vec3 p;

  // move it
  pos.y += time;

  // twist it
  // pos.xz *= rot(pos.y*.05+time*.1);
  // pos.xz += normalize(pos.xz) * sin(pos.y*.5+time);

  // holes
  float holeWall = sDist(pos.xz, wallRadius);
  float holeStair = sDist(pos.xz, stairRadius);

  // walls
  p = pos;
  amod(p.xz, wallCount);
  p.x -= wallRadius;
  scene = min(scene, max(-p.x, abs(p.z)-wallThin));
  scene = max(scene, -sDist(pos.xz, wallRadius-wallOffset));

  // floors
  p = pos;
  p.y = repeat(p.y, cell.y);
  float disk = max(sDist(p.xz, 1000.), abs(p.y)-floorThin);
  disk = max(disk, -sDist(pos.xz, wallRadius));
  scene = min(scene, disk);

  // stairs
  p = pos;
  float stairIndex = amod(p.xz, stairCount);
  p.y -= stairIndex*stairHeight;
  p.y = repeat(p.y, stairCount*stairHeight);
  float stair = sdBox(p, vec3(100,stairHeight,stairDepth));
  scene = min(scene, max(stair, max(holeWall, -holeStair)));
  p = pos;
  p.xz *= rot(PI/stairCount);
  stairIndex = amod(p.xz, stairCount);
  p.y -= stairIndex*stairHeight;
  p.y = repeat(p.y, stairCount*stairHeight);
  stair = sdBox(p, vec3(100,stairHeight,stairDepth));
  scene = min(scene, max(stair, max(holeWall, -holeStair)));
  p = pos;
  p.y += stairHeight*.5;
  p.y -= stairHeight*stairCount*atan(p.z,p.x)/TAU;
  p.y = repeat(p.y, stairCount*stairHeight);
  scene = min(scene, max(max(sDist(p.xz, wallRadius), abs(p.y)-stairHeight), -holeStair));

  // books
  p = pos;
  p.y -= cell.y*.5;
  vec2 seed = vec2(floor(p.y/cell.y), 0);
  p.y = repeat(p.y, cell.y);
  p.xz *= rot(PI/wallCount);
  seed.y += amod(p.xz, wallCount)/10.;
  seed.y += floor(p.z/(bookSize.z*bookSpace));
  p.z = repeat(p.z, bookSize.z*bookSpace);
  float salt = rng(seed);
  bookSize.x *= .5+.5*salt;
  bookSize.y += salt;
  bookSize.z *= .5+.5*salt;
  p.x -= bookRadius + wallOffset;
  p.x += cos(p.z*2.) - bookSize.x - salt * .25;
  p.x += .01*smoothstep(.99,1.,sin(p.y*(1.+10.*salt)));
  scene = min(scene, max(sdBox(p, vec3(bookSize.x,100.,bookSize.z)), p.y-bookSize.y));

  // panel
  p = pos;
  p.y = repeat(p.y, cell.y);
  p.xz *= rot(PI/wallCount);
  amod(p.xz, wallCount);
  p.x -= wallRadius;
  float panel = sdBox(p, panelSize);
  float pz = p.z;
  p.z = repeat(p.z, .2+.3*salt);
  panel = min(panel, max(sdBox(p, vec3(.1,.1,.04)), abs(pz)-panelSize.z*.8));
  scene = min(scene, panel);

  // papers
  p = pos;
  p.y -= stairHeight;
  p.y += time*2.;
  p.xz *= rot(PI/stairCount);
  float ry = 8.;
  float iy = floor(p.y/ry);
  salt = rng(vec2(iy));
  float a = iy;
  p.xz -= vec2(cos(a),sin(a))*paperRadius;
  p.y = repeat(p.y, ry);
  p.xy *= rot(p.z);
  p.xz *= rot(PI/4.+salt+time);
  scene = min(scene, sdBox(p, paperSize));

  return scene;
}

// Function 1246
float dist( vec3 ws )		
{
	
	
	vec4 f = func( ws ) ;	
	
	float dist = f.x / length(f.yzw);
	
	return dist; 
	
}

// Function 1247
float dist2(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); }

// Function 1248
float map( vec3 p ) 
{
	p *= rotXY(vec2(0.5,10.6));
	p.y += sin(p.z*0.1+time)*(3.+sin(time)*1.);
	p.y += sin(p.x*0.5+time)*(3.+sin(time)*1.);
	return length(p.y)-2.;
}

// Function 1249
vec4 map(vec3 p)
{
   	float scale = 3.;
    float dist = 0.;
    
    float x = 6.;
    float z = 6.;
    
    vec4 disp = displacement(p);
        
    float y = 1. - smoothstep(0., 1., disp.x) * scale;
    
    #ifdef USE_SPHERE_OR_BOX
        dist = osphere(p, +5.-y);
    #else    
        if ( p.y > 0. ) dist = obox(p, vec3(x,1.-y,z));
        else dist = obox(p, vec3(x,1.,z));
	#endif
    
    return vec4(dist, disp.yzw);
}

// Function 1250
vec2 map_3( in vec3 pos ) { // scene + ro + rd + intersection
    vec2 res = map_2(pos);
    
    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),2. ) );
    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),2. ) );
    
    return res;
}

// Function 1251
vec4 getHeightMap(vec2 U) 
{
    vec2 s = (MAP_DIMENSION-0.5)/iResolution.xy;
    
    // Scale U
    U*=0.05*s;
    
    if(mod(U.x, 2.0*s.x) > 1.0*s.x) U.x = 1.0*s.x-(mod(U.x,1.0*s.x));
    else U.x = mod(U.x,1.0*s.x);
    if(mod(U.y, 2.0*s.y) > 1.0*s.y) U.y = 1.0*s.y-(mod(U.y,1.0*s.y));
    else U.y = mod(U.y,1.0*s.y);

    return texture(iChannel2, U); 
}

// Function 1252
float map_s(vec3 pos)
{
    vec3 posr = rotateVec2(pos);
    posr.y-= 0.45;
    return sdCylinder(posr, lampsize*vec2(1.2, 1.37));
}

// Function 1253
float mapArloSimple( vec3 p )
{

    // body
    vec3 q = p;
    float co = cos(0.2);
    float si = sin(0.2);
    q.xy = mat2(co,si,-si,co)*q.xy;
    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );
    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );
    float d = smin( d1, d2, 0.4 );
    
    // tail
    {
    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );
    float tr = 0.3 - 0.25*b.y;
    float d3 = b.x - tr;
    d = smin( d, d3, 0.2 );
    }
    
    // neck
    {
    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );
    float tr = 0.35 - 0.23*b.y;
    float d3 = b.x - tr;
    d = smin( d, d3, 0.15 );
    //d = min(d,d3);
	}


    float dn;
    // front-left leg
    {
    vec2 d3 = legSimple( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );
    d = smin(d,d3.x,0.2);
    dn = d3.y;
    }
    // back-left leg
    {
    vec2 d3 = legSimple( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    // front-right leg
    {
    vec2 d3 = legSimple( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    // back-right leg
    {
    vec2 d3 = legSimple( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    
    
    // head
    vec3 s = vec3(p.xy,abs(p.z));
    {
    vec2 l = sdLine( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );
    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));
        
    // mouth
    //l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );
    vec3 mp = p-vec3(-2.7,2.16,0.0);
    l = sdLine( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );
        
    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      
    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );
    d4 = smax( d4, d5, 0.03 );
    
        
    d3 = smin( d3, d4, 0.1 );

        
    // mouth bottom
    {
    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );
    float tr = 0.11 + 0.02*b.y;
    d4 = b.x - tr;
    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );
    }
        
    // brows    
    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );
    float tr = 0.035 - 0.025*b.y;
    d4 = b.x - tr;
    d3 = smin( d3, d4, 0.025 );

    d = smin( d, d3, 0.01 );
    }
    
    return min(d,dn);
}

// Function 1254
Intersection sdf3D(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    
    vec3 material = computeMaterial(hitObj, isect, nor);
   
    float shadowCoefficient = shadow(isect, 0.1) * 1.2;
	vec3 overallColor = material * (lambertColor(isect, nor) * shadowCoefficient + 0.1);
    

    #ifdef FIVE_TAP
    float ao = fiveTapAO(isect, nor, FIVETAP_K);
    overallColor *= ao;
    #endif
    
    vec3 sdfColor = overallColor;
    return Intersection(t, sdfColor, isect, hitObj);
}

// Function 1255
float scene1(vec3 pr)
{
    //vec3 pr = p;
    //pr.x += 4.0;
    //pr.xy *= rot(iTime*.5);
    pr.xz *= rot(1.57);
    sceneCol = fract(pr*8.0);
    float d1 = sdBox(pr,vec3(.5,1.0,1.5));
    //float d1 = sdBox(pr,vec3(.25,.5,.75));
    //float d2 = sdSphere(p,1.0); // p or pr, it's a sphere
    pr.xy *= rot(1.57);
	float d2 = sdCappedCylinder(pr,vec2(.50,12));
    //float d3 = sdTorus(pr,vec2(1.0,.25));
    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));
    //return opU(d1,d2);
    //return opI(d1,d2);
    return opS(d1,d2);
    //return opS(d2,d1);
    //return d1;
    //return d2;
    //return d3;
    //return d4;
}

// Function 1256
vec4 map_rivers(vec2 fragCoord) {
    vec4 fragColor = map_land(fragCoord, true);
    float flow = buf(fragCoord).w;
    fragColor.rgb = mix(fragColor.rgb, .6 + .6 * cos(2.*PI * fract(flow) + vec3(0,23,21)),
                        clamp(0.15 * log(floor(flow)), 0., 1.));
    return fragColor;
}

// Function 1257
vec4 map(vec3 p)
{
   	float scale = 3.;
    float dist = 0.;
    
    float x = 6.;
    float z = 6.;
    
    vec4 disp = displacement(p);
        
    float y = 1. - smoothstep(0., 1., disp.x) * scale;
    
    #ifdef USE_SPHERE_OR_BOX
    	#ifdef POSITIVE_DISPLACE
        	dist = osphere(p, +5.-y);
    	#else
        	dist = osphere(p, +3.+y);
    	#endif
    #else    
        #ifdef POSITIVE_DISPLACE
        	if ( p.y > 0. ) dist = obox(p, vec3(x,1.-y,z));
        	else dist = obox(p, vec3(x,1.,z));
    	#else
        	if ( p.y > 0. ) dist = obox(p, vec3(x,y,z));
        	else dist = obox(p, vec3(x,1.,z));
    	#endif
	#endif
    
    return vec4(dist, disp.yzw);
}

// Function 1258
vec3 heightmapNormal(vec2 uv) {
	float xdiff = heightmap(uv) - heightmap(uv+epsi.xy);
	float ydiff = heightmap(uv) - heightmap(uv+epsi.yx);
	return normalize(cross(vec3(epsi.yx, -xdiff), vec3(epsi.xy, -ydiff)));
}

// Function 1259
vec3 tube2Map(vec3 p) {
	p.xz *= rot(.4);
	p.x -= 30.;
	p.y += 9.5;
	p.yz *= rot(1.57);
	return p;
}

// Function 1260
vec2 map( vec3 p, float camtime )
{
  vec2 ret = vec2(min(
                        // repeatedSphere(p, vec3(2.0), 0.25),
                        // repeatedBox(p, vec3(0.811), 0.071, 0.031)  ),
                        repeatedBox(p, vec3(1.2), 0.071, 0.031),
                        max( repeatedGrid(p, vec3(1.2), 0.0271),
                             repeatedBox(p+0.05,  vec3(0.1), 0.015, 0.0035)
                           )
                        //repeatedBox(p, vec3(0.524), 0.041, 0.017)
                ), 1.0);

  attributedUnion(ret, repeatedCone(vec3(p.x, p.y, p.z - camtime), 
                                    vec3(1.611, 1.9, 5.0), 
                                    normalize(vec2(1.0, 0.3))), 
                       2.0);

  attributedUnion(ret, max( repeatedSphere(p+0.25, vec3(2.0), 0.25),
                            repeatedSphere(p, vec3(0.1), 0.046)
                          ), 3.0);

  attributedIntersection(ret, -sdSphere(p - camo, 0.03), -1.0);
  return ret;
}

// Function 1261
float sphereDist(vec3 p) {
    float sphere = length(p) - 1.;
	return sphere;
}

// Function 1262
float map(in vec3 m, out int material) {

    float dist1 = length(m - sphere_center) - sphere_radius;
    
    vec2 madrid = vec2(40.4167754, -3.7037902);
    vec2 paris = vec2(48.8580082,2.294257);
    vec2 newyork = vec2(40.712784, -74.005941);
    
    vec2 plt = vec2(paris*M_PI/180.0);
    vec3 p3D = vec3(0,0,0) + latLonTo3D(plt) * 2.0;
    
    float zoom = texelFetch(iChannel1, ivec2(0.0,0.0),0).x;
    float ray = 0.0001 + (1.0 - (5.0 - zoom)/3.0) * (0.05 - 0.0001);

    
    float dist2 = length(m-p3D) - ray;

    if (zoom < 2.001 || dist1 < dist2) {
        material = 1;
        return dist1;
    } else {
        material = 2;
        return dist2;
    }

    return dist1;
}

// Function 1263
vec3 sdfRep(vec3 p, vec3 grid, vec3 l)
{
    vec3 c = grid;
    return p-c*clamp(round(p/c),-l,l);
}

// Function 1264
Object map(vec3 pos)
{
    Object o;
    o.difVal = 1.0;
    o.dist = 1000.0;
    o.normEps = 0.00001;
    o.color = vec3(0);
    
    float yOff = 0.05*sin(5.0*iTime);
    vec3 offset = vec3(0, yOff, 0);
    
    //ground
    /*vec3 boardPos = pos;
    boardPos.z = mod(boardPos.z, 10.0);
    boardPos.x = mod(boardPos.x, 12.0);
	float dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);
    if(dBoard < o.dist)
    {
        o.dist = dBoard;
        o.difVal = 0.9;
        
        //checker board
        vec3 col;
        float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);

        col = vec3(1.0);
        col *= (round(step((modi)*sin(pos.x*1.0*PI), 0.0)));
        
        o.color = col;
        o.specVal = 200.0;
        o.specKs = 0.5;
    }*/
    
    vec3 objPos = pos - vec3(0, 1.5, 0);
    float ang = PI/4.0;
    vec2 objPosXZ = mat2(cos(ang), -sin(ang), sin(ang), cos(ang)) * objPos.xz;
    objPos = vec3(objPosXZ.x, objPos.y, objPosXZ.y);
    
    float dCube = sdRoundBox(objPos, vec3(0.5), 0.1);
    float dSphere = sdSphere(objPos, 1.0);
    float dElip = sdEllipsoid(objPos, vec3(0.5, 1.0, 0.5));
    //float dCube1 = sdRound
    
    float mixVal = (1.0+sin((PI*(iTime + 0.1)) / 3.0));
        
    float dMix = mix(dSphere, dCube, mixVal) * step(mixVal, 1.0001)
        		 + mix(dCube, dElip, mixVal - 1.0) * step(mixVal, 2.0) * step(1.0, mixVal);
    if(dMix < o.dist){
        o.dist = dMix;
        o.color = vec3(113.0 / 255.0, 55.0/255.0, 225.0/255.0);
        o.specVal = 55.0;
        o.specKs = 1.0;
    }
        
    
    return o;
}

// Function 1265
float DistanceToTerrain(in vec3 p)
{
#ifdef DISTANCE_FIELD
	return p.y - texelFetch(iChannel0, ivec2(p.xz+gameGridCenter),0).x;
#else
	return texelFetch(iChannel0, ivec2(p.xz+gameGridCenter),0).x;
#endif
}

// Function 1266
float map(vec3 p)
{
    float d = 1e+31;
    
    d = min(d, p.y + .5);
    d = min(d, box(p) - .499);
    
    p.xz = amod(p.xz, TAU/8.);
    d = min(d, length(p - vec2(0, 2).yxx) - .5);
    
	return d;
}

// Function 1267
float map2 (vec3 p){
float s = dot(p,vec3(0.,1.,0.))+4.;
return s;
}

// Function 1268
vec2 distM(vec3 p)
{
    float d=1000., mat=-1., d_mat=d;
    
    if(enable_car)
    {
        vec2 dm=distCarM(carTrafo(p)*vec3(1,-1,1));
        d=dm.x; mat=dm.y; d_mat=d;
    }
    
    if(enable_terr)
    {
        d=min(d,distTerr(p));
    }
    
    SET_PREV_MAT(FLOOR);
    
    //#define DEBUG
    #ifdef DEBUG
    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;
    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;
    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);
    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);
    SET_PREV_MAT(DBG_GREEN);
    #endif
    
    return vec2(d,mat);
}

// Function 1269
float boxSDF(vec3 p, vec3 bb) {
    vec3 d = abs(p) - bb;
	return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf
}

// Function 1270
float dfunc_icon_dist(vec2 p, float sz, int style) {
    
    if (style == 0) {
        
        return length(p) - sz;
        
    } else if (style == 5 || style == 6) {

		p.y = abs(p.y);
        
        vec2 vp = p*vec2(1, 0.9);
        float d = abs(length((vp - vec2(0, 0.6*sz))) - 0.5*sz) - 0.06*sz;
        
        float q = length(p - vec2(0, min(p.y, 0.4*sz)))-0.06*sz;
        float r = box_dist(p, vec4(0, 0, 0.35, 0.7)*sz);
                    
        if (style == 6) {
        
            q = min(q, box_dist(p, vec4(0, 2.0, 0.06, 0.46)*sz));
            q = min(q, box_dist(p, vec4(-0.5, 2.4, 0.56, 0.06)*sz));
            
        }
                
        return min(q, max(d, -r));
        
    }
    
    p += vec2(0, 0.15*sz);
    
    sz *= 0.9;
    
    const float k = 0.8660254037844387;
    
    p.x = abs(p.x);
    
    vec2 m0 = vec2(0, sz);
    vec2 m1 = vec2(k*sz, -0.5*sz);
    vec2 m2 = vec2(0, -0.5*sz);
    
    vec2 d_ls = min(dline_seg(p, m0, m1),
                    dline_seg(p, m1, m2));
    
    float d_point = min(length(p - m0), length(p - m1));
    
    if (style == 1) {
        return -d_ls.x - 0.5;
    } else if (style == 2) {
        return min(d_point - 0.25*sz, abs(d_ls.y)-0.08*sz);
    } else if (style == 3) {
        return abs(d_ls.x)-0.15*sz;
    } else {
        return min(min(d_ls.y, d_point) - 0.35*sz, -d_ls.x);    
    }
    
}

// Function 1271
vec3 sceneNormal( vec3 pos, float d )
{
    float eps = 0.0001;
    vec3 n;
	
    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;
    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;
    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;
	
    return normalize(n);
}

// Function 1272
vec2 planetMap(in vec3 p)
{p=planetSpin()*p
;float pn1=noise3(p/32.)
;float pn2=noise3(p*(2.1/32.))
;float pn3=noise3(p*(4.2/32.))//3 noises
;float pf1=pn1+.5*pn2+.25*pn3//united to a 3 octave noise
//Ridged multi fractal
;float s=pow((1.-abs(pn3)),2.),ss=sat(s*1.5)
,r=pow(1.-abs(pn2),2.)+.5*s*ss
#ifdef ENABLE_DETAILS
,pn4=noise3(p*8.82/32.)
,pn5=noise3(p*18.522/32.)
,pn6=noise3(p*38.8962/32.)
;pf1+=(pn4+pn5/2.+pn6/4.)/8.
;r+=pow((1.-abs(pn4)),2.)*ss/4.
;r+=pow((1.-abs(pn5)),2.)*ss/8.
;r+=pow((1.-abs(pn6)),2.)*ss/16.
#endif
// Mountain
;float mm=smoothstep(.55,1.,sat(abs(.925-pn2)))*sat(pf1)//land
,ma=mix(1.,2.,smoothstep(0.,.5,mm)) 
;s=ATMOSPHERE_HEIGHT/4.*pf1+mix(.0,2.5*r,mm)
;return vec2(length(p)-SEA_LEVEL-s,ma);}

// Function 1273
vec2 map(vec2 z)
{
  vec2 m; 
  int  i = methodId;
    
  if (!vizSquare) {  
    if     (i == 0) { m = map0sd(z); }
    else if(i == 1) { m = map1sd(z); }
    else if(i == 2) { m = map2sd(z); }
    else if(i == 3) { m = map3sd(z); }
  } else {
    if     (i == 0) { m = map0ds(z); }
    else if(i == 1) { m = map1ds(z); }
    else if(i == 2) { m = map2ds(z); }
    else if(i == 3) { m = map3ds(z); }
  }
  return m;
}

// Function 1274
float map_floor(vec3 pos)
{
    return pos.y + 1.5;   
}

// Function 1275
vec2 map(vec3 rp){
    float d = 999.;
    float hmat = -1.;
    
    rp.xy *= rot(rp.z*.15);
    rp.xz *= rot(rp.z*.17);
    
    rp.z += iTime;
    
    vec3 b = vec3(0., 0., .7);
    vec3 rpr = mod(rp, b)-b*.5;
   
    d = min(d, sdRbox(rpr, vec3(1.25, .15, .3)));
    cd(d, .0, hmat);
    
    rpr = mod(rp-vec3(.6, 0.07, .35), b)-b*0.5;
    
    if( ((int(round(rp.z/.7))%7)&3)!=0 )// Iq's fix
    	d = min(d, sdRbox(rpr, vec3(.65, .2, .05)));
    
    cd(d, 1., hmat);
    
    rpr = mod(rp-vec3(1.9, 0., .0), b)-b*.5;
    
    return vec2(d, hmat);
}

// Function 1276
vec4 sdFractal(vec3 p, float itr, vec2 cell, float sc)
{
    p.xz = p.xz+cell*0.5;
    vec2 cell_i = floor(p.xz/cell);
    p.xz = mod(p.xz, cell) -  cell*0.5;
    float box = sdBox(p.xzy, vec3(cell.xy*0.35,1000.));
    vec3 dp = ((length(cell_i)==0.)?iFracShift:iFracShift*0.9+3.*hash31(dot(cell_i,vec2(1.,sqrt(2.)))));
    float scale = 1.;
    vec3 orbit =  vec3(0.);
    vec3 col = vec3(0.);
    float norm = 0.;
    
    vec2 angl = (cell_i)*0.05 + vec2(iFracAng1,iFracAng2);
    float s1 = sin(angl.x), c1 = cos(angl.x);
    float s2 = sin(angl.y), c2 = cos(angl.y);

	for (float i = 0.; i < itr; i++) 
    {
		p = abs(p);
		rotZ(p, s1, c1);
		mengerFold(p);
		rotX(p, s2, c2);
        scale *= sc;
		p = p*sc + dp;
    	orbit = max(orbit, sin(.9*p*iFracCol));
	}
	return vec4(clamp(1.-0.8*orbit,0.,1.),max(sdBox(p, vec3(6.0))/scale, box));
}

// Function 1277
vec2 raymarch_main_scene(vec3 _p, float t)
{
    vec2 sand = scene_base_sand(_p);
    #if defined(ENABLE_HD_SAND_DEPTH)
    sand.x = max(sand.x, -(length(_p-vec3(30., 10., 140.))-90.));
    #else
    sand.x = max(sand.x, -(length(_p-vec3(-20., 2., 53.))-16.));
    #endif
    #if defined(ENABLE_REEDS)
 	return scene_min(scene_reeds(_p-vec3(1., 0., -3.), sand.x, t), scene_min(sand, scene_pyramids(_p)));
    #else
        return scene_min(sand, scene_pyramids(_p));
    #endif
}

// Function 1278
float map(vec3 p){
    return length(p) - 1.; //min(s, s2);
}

// Function 1279
float sdfSphere(vec3 p, mat4 t) {
    p = vec3(t * vec4(p, 1));
    return length(p) - 1.;
}

// Function 1280
bool intersectScene(vec3 p, vec3 dir,out Hit h)
{
    Hit ht;
    h.t = INF;
    bool hit = false;
    Sphere s1 = Sphere(vec3(0.,0.,0.), 1.);
    
    
    Box b1 = makeBox(vec3(0.,-2.,0.),vec3(20.,0.5,20.));
    Box b2 = makeBox(vec3(-3.,0.,0.), vec3(1.,1.,1.));
    
    if(intersectSphere(s1,p,dir,ht))
    {
     	h = ht;  
        hit = true;
    }
    if(intersectAABB(b1,p,dir,ht) && ht.t < h.t)
    {
     	h = ht;  
        hit = true;
    }
     if(intersectAABB(b2,p,dir,ht) && ht.t < h.t)
    {
     	h = ht;  
        hit = true;
    }
    
    return hit;
    
}

// Function 1281
float remap(float value, float low1,float high1, float low2,float high2,bool c){float r=low2 + (value - low1) * (high2 - low2) / (high1 - low1);return c?clamp(r,min(low2,high2),max(low2,high2)):r;}

// Function 1282
float map(in vec3 ro, in vec3 rd){ 
    return min(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5),
               min(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), 
                   min(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),
                       min(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),
                           min(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),
                              min(asphere(ro,rd,vec3(3.,3.,3.),0.2),
                                 asphere(ro, rd, vec3(-3.,-3.,-3.), 0.2)))))));
}

// Function 1283
maybe_float get_distance_along_2d_line_to_line(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in vec2 B
){
    vec2 D = B0 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    return maybe_float(
        length(R) / dot(B, normalize(-R)), 
        abs(abs(dot(A, B)) - 1.f) > 0.f
    );
}

// Function 1284
float scene(vec3 p)
{
	vec2 mouse = iMouse.xy / iResolution.xy;
	mouse = mouse * 2.0 -1.0;
	mouse.x *=  iResolution.x / iResolution.y;
	
	if(mouse.x  < -0.99 && mouse.y < -0.99)
		mouse  = vec2(-0.7,0.2);
	
	p.yz = rotate(p.yz, -mouse.y * 2.0);	
	p.xz = rotate(p.xz, -mouse.x * 2.0);
	
	float ayz = atan(p.y, p.z);
	float azx = atan(p.z, p.x);	
	float axy = atan(p.x, p.y);	
	float l = length(p);
	
	return length(p) - 1.0 + 0.1 * pow(texture( iChannel0, -1.0 * p ).y,0.15);
}

// Function 1285
float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1e8;    
    float hx = mapWater(ori + dir * tx, ITER_GEOMETRY, true);
    if(hx > 0.0) return tx;   
    float hm = mapWater(ori + dir * tm, ITER_GEOMETRY, true);    
    float tmid = 0.0;
    for(int i = 0; i < 8; i++)
    {
        tmid = mix(tm,tx, hm/(hm-hx));                   
        p = ori + dir * tmid;                   
    	float hmid = mapWater(p, ITER_GEOMETRY, true);
		if(hmid < 0.0)
        {
        	tx = tmid;
            hx = hmid;
        } else
        {
            tm = tmid;
            hm = hmid;
        }
    }
    return tmid;
}

// Function 1286
vec2 dstScene(vec3 p) {
    vec3 q = rotateGun(p);
	vec2 scn = vec2(sdCappedCylinder(q, vec2(.4,1.4))-0.02, 0.);
    scn = dstUnion(scn, vec2(sdTorus(q, vec2(.45,.1)), 0.));
    scn = dstUnion(scn, vec2(sdTorus(q+vec3(0.,1.,0.), vec2(.45,.1)), 0.));
    scn = dstSmin(scn, udRoundBox(q+vec3(0.,-.7,.5),vec3(.1,.2,.01),.2), .1);
    scn = dstSub(scn, sdCappedCylinder(q-vec3(0.,.2,0.), vec2(.3,1.3))-.02);
    q.yz = rot2D(q.yz, -45.);
    scn = dstSmin(scn, udRoundBox(q-vec3(0.,-1.6,.9), vec3(.1,.4,.1), .2), .1);
    return scn;
}

// Function 1287
float map(vec3 p)
{	
	pR(p.yx,bounce*.4);
    pR(p.zx,iTime*.3);
	return min(max(sdBox(p,vec3(2.5, 2.5, 0))-.3,-sdBox(p,vec3(1.2, 1.2, 1))+.5)-0.003*noise(55.*p),length(p)-1.6+0.3*noise(3.5*p-.5*iTime));
}

// Function 1288
float map(float value, float min1, float max1, float min2, float max2) {
    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;
}

// Function 1289
float map( in vec3 p )
{
	float d = -box(p-vec3(0.,10.,0.),vec3(10.));
	d = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(4.,5.,6.)), vec3(3.,5.,3.)) );
	d = min(d, box(rotate(vec3(0.,1.,0.), 0.)*(p-vec3(-4.,2.,0.)), vec3(2.)) );
	d = max(d, -p.z-9.);
	
	return d;
}

// Function 1290
float sample_dist_local_bilateral(vec2 uv, float font_size) {
    
    const int nstep = 4;  
    const float spos  = 0.95;
    const float sdist = 5e-3;
    const float k_ctr = 0.25;
    
    float bump = float((nstep + 1) % 2)*0.5;
    const int ngrid = nstep*nstep;
        
    ivec2 st = ivec2(floor(uv*TEX_RES + bump));
    vec2 uv0 = (vec2(st) + 0.5)/TEX_RES;
    vec2 duv0 = uv - uv0;
    
    float dists[ngrid];
    float wpos[ngrid];
    
    float dctr = 0.0;
    
    for (int i=0; i<nstep; ++i) {
        int di = i - nstep/2;
        for (int j=0; j<nstep; ++j) {            
            int dj = j - nstep/2;
            
            vec3 grad_dist = fetch_grad_dist(st + ivec2(di, dj));
            
            vec2 uvdelta = duv0 - vec2(di, dj) / TEX_RES;                        
            
            vec2 tdelta = uvdelta * TEX_RES;           
            
            vec2 pdelta = uvdelta * GLYPHS_PER_UV;            
            
            float dline = grad_dist.z + dot(grad_dist.xy, pdelta);
            
            vec2 w = max(vec2(0.0), 1.0 - abs(tdelta));

            dctr += w.x*w.y*mix(grad_dist.z, dline, k_ctr);
                        
            int idx = nstep*i + j;
            dists[idx] = dline;
            wpos[idx] = dot(tdelta, tdelta);
            
        }
    }                
    
    float dsum = 0.0;
    float wsum = 0.0;
    
    for (int i=0; i<nstep; ++i) {
        for (int j=0; j<nstep; ++j) {
            int idx = nstep*i + j;
            float ddist = dists[idx] - dctr;
            float wij = exp(-wpos[idx]/(2.0*spos*spos) + 
                            -ddist*ddist/(2.0*sdist*sdist));
            dsum += wij * dists[idx];
            wsum += wij;
        }
    }
        
    return font_size*dsum/wsum;
    
}

// Function 1291
float starshipSdf(vec3 pos) {
    const float totalLength = tankLength + noseLength;
    pos.x += 0.5 * totalLength;

    vec2 p = vec2(length(pos.yz), pos.x);
    float body = tankSdf(p);
    body = min(body, noseSdf(p));
    
    vec3 q = pos;
    q.x -= totalLength - frontFinCenter;
    float fins = rhombusSdf(q, frontFinAngle, frontFinWidth);

    const float frontFinHalf = 0.5 * frontFinLength;
    q.x += frontFinHalf;
    fins = min(fins, rectangleSdf(q, frontFinHalf, frontFinWidth));

    q = pos;
    q.x -= aftFinLength;
    fins = min(fins, rhombusSdf(q, aftFinAngle, aftFinWidth));

    const float aftFinHalf = 0.5 * aftFinLength;
    q.x += aftFinHalf;
    fins = min(fins, rectangleSdf(q, aftFinHalf, aftFinWidth));
    
    fins -= finThickness;
    float h = clamp(0.5 + 0.5 * (body - fins) / finSmooth, 0.0, 1.0);
    return mix(body, fins, h) - finSmooth * h * (1.0 - h);
}

// Function 1292
Hit intersectScene(Ray r)
{
    Sphere s = Sphere(1., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));
    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));

    Hit hit = noHit;
    compare(hit, intersectPlane(p, r));
    compare(hit, intersectSphere(s, r));
    return hit;
}

// Function 1293
vec3 Tonemap(vec3 color)
{
    color = Reinhard(color);
    color = pow(abs(color), vec3(1.0 / Gamma));
    
    return color;
}

// Function 1294
float sdf_C(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));
    return t;
}

// Function 1295
vec2 RAYMARCH_distanceField( vec3 o, vec3 dir)
{
    //From Inigo Quilez DF ray marching :
    //http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm
    float tmax = GEO_MAX_DIST;
    float t = 0.0;
    float dist = GEO_MAX_DIST;
    for( int i=0; i<50; i++ )
    {
	    dist = DF_composition( o+dir*t ).d;
        if( abs(dist)<0.0001 || t>GEO_MAX_DIST ) break;
        t += dist;
    }
    
    return vec2( t, dist );
}

// Function 1296
vec3 envMap(vec3 rd, vec3 n){
    
    vec3 col = tpl(iChannel1, rd*4., n);
    return smoothstep(0., 1., col);
}

// Function 1297
ctx scene(ctx i) {
    vec3 rp = i.point;
    
    //floor
    i.distance_ = abs(rp.y)-6.;
    i.color = vec3(0.95);
    i.density = 1.;
    i.deformAmount = 0.;
    i.deformScale = .1;
    i.deformRoughness = 0.15;
    i.fluff = 0.0;
    i.emission = 0.0;
    
    //courtyard walls
    float cwalls = max(rp.y-20., abs(length(rp.xz)-30.)-2.);
    if (cwalls < i.distance_) {
        i.distance_ = cwalls;
    }
    
    //sphere examples
    vec3 lp = vec3(rp.y-8., mod(abs(rp.xz),8.)-4.).yxz;
    float sexp = max(-(cwalls-11.), length(lp)-3.);
    if (sexp < i.distance_) {
        i.distance_ = sexp;
        
        float id = floor(rp.x/8.)*4.+floor(rp.z/8.)*128.;
        i.density = pow(fract(abs(id)/6.)*.9+0.1,2.2);
        i.deformAmount = fract(abs(id)/4.+.2985)*.25;
        i.color = vec3(cos(id/2.),sin(id/8.+.6934),-cos(id/8.+1.295))*.5+.5;
    }
    
    return i;
}

// Function 1298
float SDFBox(vec3 point, vec3 size)
{
    vec3 d = abs(point) - size;
    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 1299
float dist_circle(vec2 p, float r)
{
    //
    // Calculates the (signed) distance to a circle
    //
	return length(p) - r;
}

// Function 1300
float beckmannDistribution(float HN)
{
    // roughness
    const float m = 0.5;
    const float m2 = m * m;
    
    float cos2 = HN * HN;
    float cos4 = cos2 * cos2;
    
    float num = exp((cos2 - 1.0) / (cos2 * m2));
    float den = pi * m2 * cos4;
    
    float k = num / den;
    
    return k;
}

// Function 1301
float map(vec3 p){
    
	// Height map to perturb the flat plane. On a side note, I'll usually keep the
    // surface function within a zero to one range, which means I can use it later
    // for a bit of shading, etc. Of course, I could cut things down a bit, but at
    // the expense of confusion elsewhere... if that makes any sense. :)
    float sf = surfFunc(p);

    // Add the height map to the plane.
    return p.y + (.5-sf)*DUNE_SIZE; 
}

// Function 1302
float distance_to_closest_object(in vec3 p)
{
    
    float sphere_0 = distance_from_sphere(p, vec3(-0.5 + cos(iTime), -0.5+cos(iTime), sin(iTime)), 2.0);    
    float sphere_1= distance_from_sphere(p, vec3(.5+ sin(iTime), 0.5 + sin(iTime), cos(iTime)), 2.0);
    
    float displacement0 = sin(-3.0  * p.x) * sin(1.5 *  p.y) * sin(2.0 * p.z) * 0.25;
    float displacement1 = cos(3.0 *   p.x) * cos(1.5 *  p.y) * cos(2.0 * p.z) * 0.5;

    return smin(sphere_0 + displacement0, sphere_1 + displacement1, .7);
   // return smin(sphere_0, sphere_1, .7);  //switch with this for simple spheres instead
}

// Function 1303
vec3 GetSceneNormal( const in vec3 vPos )
{
    const float fDelta = 0.000001;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetSceneDistance( vPos + vOffset1 ).x;
    float f2 = GetSceneDistance( vPos + vOffset2 ).x;
    float f3 = GetSceneDistance( vPos + vOffset3 ).x;
    float f4 = GetSceneDistance( vPos + vOffset4 ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 1304
float sdf_h(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));
    return t;
}

// Function 1305
int  mapTerrain( vec2 p) {

    vec2 uv =  p  / 300.;
  	float n = .1  +max(fbm(uv * 1.2 ) - .2, 0.); 
    n =  n * n * (3. - 2. * n);  
    //n*= (.3 + snoise(p/120.)); //islands
    //n= mix(n, .4,snoise(p/120.)); //plains
    return int(clamp( n*MOUNTAIN_LEVEL,1.,MOUNTAIN_LEVEL));

}

// Function 1306
void setup_scene(float tim)
{
    tim *= .5;

    for(int i=0; i<ptcnt; ++i) 
    {
        float t = tim + float(i)*1.7;
        
        // Simple animation of spheres:
        pt[i].x = cos(t)*.15;
        pt[i].y = sin(t*1.1)*.5;
        
        // Put 6 sphere in front (lens) and 6 in the back:
        pt[i].z = ((i<frontcnt)?frontdist:backdist) + cos(t*2.1);
    }
}

// Function 1307
float DistLine(vec2 p, vec2 a, vec2 b) {
	vec2 pa = p-a;
	vec2 ba = b-a;
	float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
	return length(pa - ba * t);
}

// Function 1308
vec3 Tonemap( vec3 x )
{
    return TonemapCompressRangeFloat3( x, 0.6 );
}

// Function 1309
vec4 Scene_SphereA( vec3 vPos )
{
    float xPos = -0.5;
    //flost xPos = -0.5 * sin(iTime)
    vec3 vSphereDomain = vPos - vec3( xPos, 0.0, 2.0 );
    float fSphereRadius = 0.4;
    float fSphereDist = length( vSphereDomain ) - fSphereRadius;
    vec3 vSphereDir = vSphereDomain / fSphereRadius;
    //vec2 vSphereUV = vec2( vSphereDir.y, atan( vSphereDir.z, vSphereDir.x )) * 2.0;
    // Sphere UV code from 	wj
    vec2 vSphereUV = vec2(acos(vSphereDir.y / length(vSphereDir)), atan( vSphereDir.z, vSphereDir.x ))*2.0 ;
    vec4 vSphereResult = vec4( fSphereDist, vSphereUV, 2.0 );    
    
    return vSphereResult;
}

// Function 1310
float SDFCircle( in vec2 coords )
{
    float v = coords.x * coords.x + coords.y * coords.y - 5.0;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return abs(v)/length(g); 
}

// Function 1311
float sdf_U(vec2 uv)
{
    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.58, .6), vec2(.25, .35), vec2(-.7,.3));
    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .34), vec2(.3, .58), vec2(-.5, .35), vec2(-.75, .2)));
    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .3), vec2(.04, .15)));
    return sdf;
}

// Function 1312
float mapElephantSimple( vec3 p )
{
    p.x -= -0.5;
	p.y -= 2.4;
    
    // head
    float d = sdEllipsoid( p, vec3(0.0,0.0,0.0), vec3(0.55,0.55,0.35) );


    // body
    {
    float co = cos(0.4);
    float si = sin(0.4);
    vec3 w = p;
    w.xy = mat2(co,si,-si,co)*w.xy;

    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );
	d = smin(d, d4, 0.2 );

    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );
	d = smin(d, d4, 0.1 );

    }
    vec3 q = vec3( p.xy, abs(p.z) );

    // back-left leg
    {
    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0, 1.0 );
    d = smin(d,d3,0.1);
    }

    
    // front-left leg
    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0, 1.0 );
    d = smin(d,d3,0.15);
    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0, 1.0 );
    d = smin(d,d3,0.15);
    
    return d;
}

// Function 1313
bool raySceneIntersection( 	in Ray ray,
                          	in float distMin,
                          	out RaySurfaceHit hit ) {
    hit.obj_id = -1;
    hit.dist = 1000.0;
    hit.E = ray.dir*(-1.0);
    
    //check lights
    for( int i1=0; i1<LIGHT_COUNT; i1++ ){
        float dist;
        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {
            hit.dist = dist;
          	vec3 hitpos = ray.origin + ray.dir*hit.dist;
    		hit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);
    		hit.mtl_id = 4 + i1;
            hit.obj_id = i1;
        }
    }
    
    //check walls
    for( int i=0; i<WALL_COUNT; i++ ){
        float dist;
        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){
            hit.dist = dist;
//            hit.pos = ray.origin + ray.dir*hit.dist;
    		hit.N = walls[i].abcd.xyz;
    		hit.mtl_id = 0;
            hit.obj_id = LIGHT_COUNT + i;
        }
    }
    
#ifdef SHOW_PLANES
    //check planes
    for( int i=0; i<PLANE_COUNT; i++ ){
        float dist;
        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){
            vec3 hitPos = ray.origin + ray.dir*dist;
            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {
                hit.dist = dist;
//                hit.pos = hitPos;
                hit.N = planes[i].abcd.xyz;
                hit.mtl_id = 1+i;
                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;
            }        
        }
    }
#endif
    
    return ( hit.obj_id != -1 );
}

// Function 1314
float sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;
    return d;
}

// Function 1315
float map(vec3 p) {

  float rep = 10.0;
  p.y -= max(0.0,abs(p.x)-10.0)*0.3;
  p.x = (fract(p.x/rep-0.5)-0.5)*rep;
  
  p += tunnel(p);

  vec3 rp = p;
  float boxrep = 10.0;
  rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;

  vec3 rp2 = p;
  float boxrep2 = 1.0;
  rp2.x=abs(rp2.x)-0.4;
  rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;

  float b = box(rp + vec3(0,-9,0), vec3(0.6,10.5,0.6));
  vec3 rp3 = rp + vec3(0,1.5,0);
  rp3.xy *= rot(PI*0.3);
  rp3.yz *= rot(PI*0.3);
  float b2 = box(rp3, vec3(0.7));
  b2 = max(b2, p.y+1.5);
  b = min(b, b2);

  

  float st = stair(p, 0.1, 0.4);
  float st2 = stair(p + vec3(0,0.7,0), 0.6, 0.4);

  b = max(b, -st2);

  float c = box(rp2 + vec3(0,0.3,0), vec3(0.05,0.3,0.2));
  rp2.y = abs(rp2.y + 0.43)-0.1;
  c = min(c, box(rp2, vec3(0.03,0.03,1.0)));
  
  

  return min(c,min(b, st));
}

// Function 1316
float mapScene(in vec3 p) {
    vec3 q = abs(p) - 2.5;
    float box1 = max(abs(max(q.x, max(q.y, q.z))) - 0.05, p.z - 2.0);

    p.xz *= Rotate(30.0);
    p -= vec3(0.25, -1.0, -2.0);
    q = abs(p) - vec3(0.75, 1.5, 0.75);
    float box2 = max(q.x, max(q.y, q.z));

    p -= vec3(0.8, -0.7, 2.0);
    p.xz *= Rotate(-55.0);
    q = abs(p) - 0.8;
    float box3 = max(q.x, max(q.y, q.z));

    p.y -= 1.3;
    float sphere1 = length(p) - 0.5;

    p -= vec3(-2.0, -1.0, 1.5);
    float sphere2 = length(p) - 1.0;

    return min(box1, min(box2, min(box3, min(sphere1, sphere2))));
}

// Function 1317
float map( vec3 p, float t )
{
    float s = 1.0;
    p = deform( p, t, s );
    return shape( p ) * s;
}

// Function 1318
float dist_field( vec3 pos ) {
	vec3 p;
    float d;
    
    d=999.9;
    p=pos;
        
     p.zx *= rotate(iTime);
  	 p.yx *= rotate(iTime * 0.5);

   	
   
    float  distToCapsule =sdCylinder( p, vec2(1.0,1.0) );
    float  distToCapsule2 =sdCylinder( p.yzx, vec2(1.0,2.0) );
    d= unionSDF(distToCapsule,distToCapsule2);
    
    //d=distToCapsule;
    
    
    
  float s = 1.0;
  for (int m = 0; m < 4; m++) {
    vec3 a = mod(p * s, 2.0) - 1.0;
    s *= 3.0;
    vec3 r = 1.0 - 3.0 * abs(a);
    float c = sdCross(r) / s;
    d = max(d, c);
  }

  return d;
                        
    
		
	// union     : min( d0,  d1 )
	// intersect : max( d0,  d1 )
	// subtract  : max( d1, -d0 )
	//return max( d1, -d0 );
}

// Function 1319
vec4 scene(vec2 p) {
    vec3 cnA = vec3(85., 20., 90.);
    vec3 cnC = vec3(85., -30., -50.);
    vec3 cpA = vec3(75., 65., -20.);
    vec3 cpC = vec3(75., -30., 50.);
    Curve cur;
    cur.cnA = cnA;
    cur.cnC = cnC;
    cur.cpA = cpA;
    cur.cpC = cpC;
    cur.bA = 0.1;
    cur.bB = -0.1;
    cur.bC = 0.1;
    cur.A = vec2(-1.2, -0.6);
    cur.B = vec2(0.0, 1.4);
    cur.C = vec2(1.3, -0.4);
    vec4 res = pde_curve(p, cur);
    return res;
}

// Function 1320
float distanceEstimator(Point3 X) {
    float d = inf;
    Material ignoreMaterial;
    scene(X, d, ignoreMaterial, false);
    return d;
}

// Function 1321
vec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)
{
	return b1+(t-a1)*(b2-b1)/(a2-a1);
}

// Function 1322
poly2 pa_map(vec3 ro, vec3 rd, float t) {
    poly2 dt = pa_init(t);
    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));
    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));
    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));
    return pa_map(x,y,z);
}

// Function 1323
float SDF( in vec2 coords )
{
    float v = F(coords);
    float slope = dFdx(v) / dFdx(coords.x);
    return abs(v)/length(vec2(slope, -1.0));
}

// Function 1324
float estDistToTrn(vec3 p, float d) {
    return (p.y - getElevation(p.xz, d))*(d*0.015+0.35);
}

// Function 1325
float lineDist2D(vec3 l, vec2 p) {
    float s = length(l.xy);
    return (dot(l.xy, p) + l.z)/s;
}

// Function 1326
float distanceField(vec3 p) {
	float result;
	vec2 polarXY = rectToPolar(vec2(abs(p.x), p.y));
	
	//float heightOffset = 0.05 * texture(iChannel0, 0.06 * p.xz).r + 0.03 * square(p.x);
	float heightOffset = -0.02 * betterTextureSample256(iChannel0, 0.09 * p.xz).r + 0.06 * betterTextureSample256(iChannel0, 0.015 * p.xz).g + 0.03 * square(p.x);
	float ground = sdPlane(vec3(p.x, p.y - heightOffset, p.z), vec4(0.0, 1.0, 0.0, 2.1))  / 1.05;
	float tunnel = -sdInfCyl(p.xy, 4.0);
	
	float ringSupport = sd2Planes(vec3(p.xy, mod(p.z, 0.5) - 0.25), vec4(0.0, 0.0, -1.0, 0.05));
	ringSupport = carve(ringSupport, sdInfCyl(p.xy, 3.85));
	
	float linearSupport = sdWedge(vec2(polarXY.x, mod(polarXY.y, PI / 10.0) - PI / 20.0), 0.015);
	linearSupport = carve(linearSupport, sdInfCyl(p.xy, 3.90));
	
	float railroadTie = sdBox(vec3(p.xy, mod(p.z, 0.5) - 0.25) - vec3(0.0, -2.1, 0.0), vec3(1.3, 0.1, 0.10));
	
	float rail = sdInfBox(vec2(abs(p.x), p.y) - vec2(0.812, -1.9), vec2(0.05, 0.1));
	
	float wireOffset = 0.1 * wireFunc(p.z + 4.0 * step(p.x, 0.0), 2.0 * PI);
	float wirePos = 0.0;
	wirePos = wireOffset + round((polarXY.y - wireOffset) / 0.05) * 0.05;
	wirePos = clamp(wirePos, 0.2 + wireOffset - 0.05, 0.2 + wireOffset + 0.05);
	
	float wire = sdInfCylPolar(vec2(polarXY.x, polarXY.y), vec3(3.75, wirePos, 0.05));
	wire /= 1.05;
	
	result = join(tunnel, ground);
	result = join(result, ringSupport);
	result = join(result, linearSupport);
	result = join(result, railroadTie);
	result = join(result, rail);
	result = join(result, wire);
	return result;
}

// Function 1327
float scene(vec3 pos) {
	return pos.y - fbm(pos * 0.006) * 80.0 + 55.0;
}

// Function 1328
float dirBisectDist(vec3 d, vec3 a, vec3 b, float G)
{
    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine
    return (cosnd>0.)?(distance(a,b)*.5)*max(1./cosnd - G, 1.):1e10;
}

// Function 1329
void homerBottomSDF(vec3 p, float swingTime, inout vec2 head) {
    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);
    vec3 pantsPoint = translate(p, vec3(0.0,-20.0 + bounce, 2.0));
    vec2 bottom = vec2(sdSphere(pantsPoint, 9.5), BLUEPANTS);
    vec2 bottomSlice = vec2(sdPlane(translate(pantsPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);
    
    diff(bottom, bottomSlice);
    
    vec3 lP = pantsPoint;
    
    lP.yz = rotate(lP.yz, PI * swingTime * -0.15);
    
    vec3 leftLegTopPoint = translate(lP, vec3(-4.5,-15, 0));
    makeALeg(lP, leftLegTopPoint, swingTime, bottom);
    
    vec3 rP = pantsPoint;
    
    float swingTimeOld = swingTime;
    swingTime = -PRECOMPUTEDTIME;
    rP.yz = rotate(rP.yz, 3.141592657 * swingTime * -0.15);
    
    vec3 rightLegTopPoint = translate(rP, vec3(4.5,-15, 0));
    makeALeg(rP, rightLegTopPoint, swingTime, bottom);
    
    vec3 leftCapPoint = translate(lP, vec3(leftLegTopPoint.x + lP.x,-27, 0));
    makeAShoe(leftCapPoint, swingTimeOld, bottom, false);
    vec3 rightCapPoint = translate(rP, vec3(rightLegTopPoint.x + rP.x,-27, 0));
    makeAShoe(rightCapPoint, swingTime, bottom, true);
    add(head, bottom);
}

// Function 1330
void setupScene()
{
    float time = getTime();
    
    // LIGHTS
    lights[0].p = vec3(
        0.0 + sin(time) * 0.75,
        0.4,
        2.0 + cos(time) * 0.75
    );
    lights[0].r = 0.2;
    lights[0].radiance = vec3(50.0 / PI);
    lights[0].idx = 0;
    
    lights[1].p = vec3(
        0.04,
        0.0 + sin(time * 0.66 + 1.0) * 0.4,
        2.0 + cos(time * 0.66 + 1.0) * 0.4
    );
    lights[1].r = 0.1;
    lights[1].radiance = vec3(5.0, 20.0, 5.0) / PI;
    lights[1].idx = 1;
    
    // PLANES

    // BOTTOM
    planes[0].p = vec3(0.0, -0.8, 0.0);
    planes[0].n = vec3(0.0, 1.0, 0.0);
    planes[0].m.c = vec3(0.5, 0.5, 0.5);
    
    // TOP
    planes[1].p = vec3(0.0, 1.0, 0.0);
    planes[1].n = vec3(0.0, -1.0, 0.0);
    planes[1].m.c = vec3(0.5, 0.5, 0.5);
    
    // LEFT (RED)
    planes[2].p = vec3(-1.3, 0.0, 0.0);
    planes[2].n = vec3(1.0, 0.0, 0.0);
    planes[2].m.c = vec3(0.8, 0.05, 0.05);
    
    // RIGHT (BLUE)
    planes[3].p = vec3(1.3, 0.0, 0.0);
    planes[3].n = vec3(-1.0, 0.0, 0.0);
    planes[3].m.c = vec3(0.05, 0.05, 0.8);
    
    // BACK
    planes[4].p = vec3(0.0, 0.0, 4.0);
    planes[4].n = vec3(0.0, 0.0, -1.0);
    planes[4].m.c = vec3(0.5, 0.5, 0.5);
    
    // SPHERES
    spheres[0].p = vec3(0.6, -0.399, 1.9);
    spheres[0].r = 0.4;
    spheres[0].m.c = vec3(-2.0, 1.5, 0.0);
    
    spheres[1].p = vec3(-0.5, -0.399, 2.33);
    spheres[1].r = 0.4;
    spheres[1].m.c = vec3(-1.0, 0.0, 0.0);
}

// Function 1331
float boxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return length(max(d,0.)) + min(max(d.x,max(d.y,d.z)),0.);
}

// Function 1332
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    vec3 p = pos;
    {
        
    	// Weapon space
        vec3 oldP = p;
        
        mat3 rotS = mat3(rotationMatrix(vec3(0,0,1), -0.35));
        
        vec3 p = rotS * p;
    
    	vec2 espada =  vec2(sdBox(p + vec3(0.042, 0 , 0), vec3(0.212,2.5,0.025)),7.8);
        espada = opSmoothUnion(espada, vec2(sdCapsule(p, vec3(0,2.5,0), vec3(0,3.12,0), 0.03), 2), 0.1);
        
        

        
        
        //p = mat3(rotationMatrix(vec3(0,0,1), -0.35)) * (oldP - vec3(0.245*3.,2.02,0.05));
        
        
        p = rotS * (oldP) - vec3(0,2.25,0); 
        espada = opU(espada, vec2(sdBox(p, vec3(0.11,0.3,0.082)),8.1));
        
        //p = mat3(rotationMatrix(vec3(0,0,1), -0.35)) * (oldP - vec3(0.261*3.3,2.35,0.05));
        
        
        p = rotS * (oldP) - vec3(0,2.35,0); 
        espada = opS(vec2(sdSphere(p, 0.10),2), espada);
        
        p = rotS * (oldP) - vec3(0,2.05,0); 
        espada = opS(vec2(sdSphere(p, 0.10),3), espada);
        
        p = rotS * (oldP) - vec3(0,2.05,0.03); 
        espada = opU(vec2(sdSphere(p, 0.055),3), espada);
        
        p = rotS * (oldP) - vec3(0,2.51,0);
        espada = opSmoothUnion(vec2(sdBox(p, vec3(0.33,0.025,0.122)),4), espada, 0.05);
        
        p = rotS * (oldP) - vec3(0,2.65,0);
        espada = opSmoothUnion(vec2(sdBox(p, vec3(0.33,0.025,0.122)),4), espada, 0.05);
        
        p = rotS * (oldP) - vec3(0,3.24,0);
        espada = opU(vec2(sdCylinder(p, vec2(0.06, 0.04)),7.8), espada);
        
        
        p = rotS * (oldP) - vec3(0,2.58,0.15); 
        espada = opU(vec2(sdSphere(p, .0335),4.), espada);
        
        p = rotS * (oldP) - vec3(0.15,2.58,0.15); 
        espada = opU(vec2(sdSphere(p, .0335),4.), espada);
        
        p = rotS * (oldP) - vec3(-0.15,2.58,0.15); 
        espada = opU(vec2(sdSphere(p, .0335),4.), espada);
        
        
        
        
        
        p = rotS * (oldP) - vec3(0,2.59,0);
        espada = opSmoothUnion(espada, vec2(sdBox(p, vec3(0.255,0.06,0.12)),4), 0.05);
        
        // Mango
        p = rotS * (oldP);
        float t = cos(mod(sqrt(oldP.x*oldP.x + oldP.y*oldP.y*5.), 0.02) *3.14 * 70.);
        espada = opU(vec2(sdCapsule(p, vec3(0,2.75,0), vec3(0,3.22,0), 0.037) + t*0.001, 5), espada);
        
        // Quitar punta espada
        p = mat3(rotationMatrix(vec3(0,0,1), -0.98)) * (oldP) - vec3(0.15,0.17,0);
        espada = opS(vec2(sdBox(p, vec3(0.23,.4,0.282)),5.9), espada);
        
        
        p = rotS * (oldP) - vec3(0.2,1.42,0); 
        espada = opU(vec2(sdBox(p, vec3(0.10,1.05,0.008)),5.9), espada);
        
        p = mat3(rotationMatrix(vec3(0,0,1), -0.95)) * (oldP - vec3(-0.335,-0.223,0)) ; 
        espada = opSmoothUnion( espada, vec2(sdBox(p, vec3(0.044,0.87,0.008)),5.9),.049);
        
        
        
        
    	res = opU(espada,res);

    }
    
    
    return res;


}

// Function 1333
vec3 envMap(vec3 rd, vec3 n){
    
    return tex3D(iChannel0, rd, n);
}

// Function 1334
vec3 roboTonemap(vec3 c){
    return c/sqrt(1.+c*c);
}

// Function 1335
float heightmap(vec2 uv)
{
    	uv /= 25.0;
        float factor = 1.5;
    	float col = 0.0;
        for(int i=0;i<6;i++)
        {
            uv *= -factor*factor;
            uv += sin(uv.yx/factor)/factor;
            col += (sin(uv.x-uv.y+col)+cos(uv.y-uv.x+col));
        }
    return -col/2.0;
}

// Function 1336
float map( in vec3 p, out vec4 muvw )
{
    float resT = 1000.0;
    vec4  resM = vec4(-1.0);

    vec3 mati = vec3(0.0);

	float dis = suelo( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(1.0,mati); }

	dis = pared( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(5.0,mati); }

	dis = jarron( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(4.0,mati); }

	dis = mantelito( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(9.0,mati); }

	dis = melon( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(2.0,mati); }

	dis = manzana( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(3.0,mati); }

	dis = lemon( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(6.0,mati); }

	dis = botella( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(7.0,mati); }

	dis = uvas( p, mati );
	if( dis<resT ) { resT=dis; resM=vec4(8.0,mati); }

    muvw = resM;
    return resT;
}

// Function 1337
vec2 scene_min(vec2 a, vec2 b)
{
    return a.x<b.x?a:b;
}

// Function 1338
float rectSDF(vec2 st, vec2 s) { // 10
    st = st * 2. - 1.;
    return max(abs(st.x / s.x), abs(st.y / s.y));
}

// Function 1339
float map( vec2 p ) 
{
	float f = textureLod( iChannel0, p/iChannelResolution[0].xy, 0.0 ).x;
	
	f *= sqrt( textureLod( iChannel2, (0.9*p + 20.0*gAnimTime)/2056.0, 0.0 ).x );
	return 200.0*f;
}

// Function 1340
float map_jelly(vec3 pos)
{
    vec2 hmp = getJellyMPos(pos);
    float hm = 0.8*getJellyBump(hmp)*smoothstep(0.95, 0.7, abs(pos.x/6.))*smoothstep(1., 0.8, abs(pos.y/2.5));
    float posz2 = pow(abs(pos.z), 1.9) + 0.04;
    //float res = max(sdBox(pos, vec3(7., 2.5, 2.)), 1.1*posz2*smoothstep(0., 0.2, hm) - hm + 0.16) + smoothstep(0., 2.5, abs(pos.z));
    float res = 1.1*posz2*smoothstep(0., 0.2, hm) - hm + 0.1 + smoothstep(0.0, 2.25, abs(pos.z));
    return res;
}

// Function 1341
float sdf_line1(vec2 uv, vec2 vert_A, vec2 vert_B){
    float slope = (vert_B.y - vert_A.y) / (vert_B.x - vert_A.y);
    float standard_form = slope * uv.x - uv.y + vert_A.y - slope * vert_A.x;
    float norm = sqrt(slope * slope + 1.);
    return standard_form / norm;
}

// Function 1342
Shape map(vec3 c){
  Shape lobby = LincolnLobby(c);
  return lobby;
}

// Function 1343
float distCyl( vec3 p, float r, float h )
{
  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1344
Cam setupSceneCamera()
{
    float targetDistance = 10.5;
    vec3 cam_tgt = vec3(0,0,-3.0);
    Cam cam = CAM_lookAt(cam_tgt, -0.2, targetDistance, -0.75+iTime*0.1);
    if(iMouse.xz != vec2(0.0,0.0) && ( iMouse.x > iResolution.x/4.0 || iMouse.y > iResolution.y/4.0) ) //Mouse button down : user control
    {
    	cam = CAM_mouseLookAt(cam_tgt, targetDistance);
    }
    return cam;
}

// Function 1345
float sdf(vec3 p){
    float flr = fPlane(p, vec3(0.0, 1.0, 0.0), 2.0);
    float ball = fSphere(p-vec3(0.0, 2.0, 0.0), 1.5);
    
    vec3 disp = vec3(20.0, 0.0, 0.0);
    vec3 pp = p;
    
    float index = pModPolar(pp.xz, disp.x);
    pp -= disp;
    pMod2(pp.xz, vec2(5.0, 4.0));
    float box = fBox(pp, vec3(1.0, 1.5, 1.0));
    float sphere = fSphere(pp-vec3(0.0, 1.0, 0.0), 1.0);
    
    float field = fOpEngrave(box, sphere, 0.5);
    
    return fOpUnionColumns(flr, fOpUnionColumns(field, ball, 0.5, 3.0), 1.0, 4.0);
}

// Function 1346
float distToPlane(vec3 o, vec3 d, vec3 p, vec3 n)
{
    return dot(o - p, n) / dot(n, -d);
}

// Function 1347
float map(vec3 p) {
    float res = sdBox(opRep(p, vec3(11.0, 0.0, 11.0)), vec3(3.0, 8.0, 3.0));
    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.0, 5.0), vec3(0.0, 0.0, 10.0)), vec3(1.0, 0.2, 5.0)));
    res = opU(res, sdBox(opRep(p + vec3(0.0, -4.3, 0.0), vec3(0.0, 0.0, 4.0)), vec3(0.1, 0.05, 0.8)));
    res = opU(res, p.y);
    
	return res;
}

// Function 1348
vec2 map( in vec3 pos )
{
    float s = 3.0;
    vec2 res = opU( vec2( sdPlane(pos), 1.0 ),
	           opU( vec2( sdSphere(pos-vec3(0.5864523963,0.0812291239,0.8045468825)*s, 0.3 ), 365.0 ), 
               opU( vec2( sdSphere(pos-vec3(0.4332892644,0.8688174619,0.9864079606)*s, 0.6 ), 300.0 ), 
               opU( vec2( sdSphere(pos-vec3(0.4042982001,0.2754675470,0.4787041755)*s, 0.25 ), 20.0 ), 
               opU( vec2( sdSphere(pos-vec3(0.7886073712,0.3325804610,0.0883206339)*s, 0.4 ), 78.0 ), 
               opU( vec2( sdSphere(pos-vec3(0.5443106183,0.8455826224,0.2311476150)*s, 0.4 ), 9421.0 ), 
                    vec2( sdSphere(pos-vec3(0.7178148587,0.9618010959,0.4239931090)*s, 0.4 ), 45.0 )
               ))))));
    return res;
}

// Function 1349
float DistanceToQuad(vec3 P, Object quad)
{
	return DistanceToQuadOrPlane(P, quad, false);
}

// Function 1350
float BaseHeightmap( vec2 uv )
{
    uv *= 0.00001;
        
#ifdef BICUBIC
    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy); 
	float noise = texture_bicubic( iChannel0, uv, texelSize ).x;
#else
    float noise = texture( iChannel0, uv ).x;
#endif
    return noise;
}

// Function 1351
float planedist(in vec3 point, in vec3 norm) {

    return dot(point, norm) - norm.y;

}

// Function 1352
float MapBody(in vec3 pos)
{
	float re = MapPianoBodyShapeDist(-pos.x, pos.z);
	float re_2 = abs(pos.y) - 15.0;
	return Combine(re, re_2);
}

// Function 1353
float vehicle_sdf(in vec3 loc) {
    float c = cone_sdf(loc);
    float p = -loc.y;
    float b = -loc.x + 0.2;
    float shell = s_max(c, b, 0.6);
    float back = s_max(cyl_sdf(loc), p, 0.1);
    shell = s_min(shell, back, 0.4);
    shell = s_max(shell,  p, 0.2);
    
    const vec3 eye1 = vec3(0.7, 0.3, 0.3);
    const vec3 eye2 = vec3(0.7, 0.3, -0.3);
    
    return shell 
        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy - vec2(0.42, 0.0)))
        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy + vec2(0.42, 0.0)))
        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye1))
        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye2))
        - 0.1 * smoothstep(0.2, -0.0, loc.y) * (1.0 + 0.2 * smoothstep(0.4, 0.6, abs(loc.z)));
}

// Function 1354
float map_light(vec3 ro) {
    return distance(ro, light.xyz) - light.w;
}

// Function 1355
float ufoSDF( vec3 point, vec3 center, float angle, float len ) {
    vec2 o = vec2( cos( angle ), sin( angle ) );    
    vec3 p = vec3( center.xy + len * o, center.z );
    
    float h = VECTOR_PROJECTION( p, center, point );
    //h = clamp( h, 0.6, 1. ); // <-- fun
    h = clamp( h, 0.1, 1. );
    
    vec3 q = mix( 
        p + h * ( center - p ),
        p - h * ( center - p ) * 2.5,
        step(.8,h)
    );
    
    float r = len * pow(h,1.85) * 1.3;
    r += 0.023 * (1.-step(0.6,h)+step(.9,h));
    r += 0.2*h;
    
    return length( point - q ) - r ;
}

// Function 1356
float sdf1(in vec2 p) {
    float c = cos(iTime), s = sin(iTime);
    p += vec2(s, s * c) * 0.4 + vec2(0.4, 0.0);
    Rotate(p, iTime);
    return sdBox(p, vec2(0.25 + 0.125 * s, 0.1 + 0.075 * c));
}

// Function 1357
Intersection sdf3D(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    // Set the light as a point light
    vec3 lightPos = vec3(0., 6., -1.5);
    
    vec3 lightDir = normalize(isect - lightPos);

    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));


    return Intersection(t, surfaceColor, isect, hitObj);
}

// Function 1358
vec4 map_plates(vec2 fragCoord) {
    vec2 p = fragCoord;
    float q = buf(p).x;
    float uplift = buf(p).y;
    vec4 r = vec4(0,0,0,1);
    r.rgb = (q < 0.) ? vec3(1) : .6 + .6 * cos(2.*PI*q + vec3(0,23,21));
    vec4 fragColor = map_land(fragCoord, false);
    fragColor = r * (5. * fragColor + 3. * clamp(2. * uplift - 1., 0., 1.) + 0.05);
    return fragColor;
}

// Function 1359
vec2 map( in vec3 pos )
{
    pos =(opRep(pos,vec3(3.,3.,3.)));
   pos.xy = kale(pos.xy,pi/6.,pi*1.4+cos(iTime)*.1,0.);
    pos.xz = kale(pos.xz,pi/6.,pi*1.4+sin(iTime)*.1,0.);
    
    float size = .5;
    float r = f(pos,size,1.);  
    
    for(float i = 0.; i<LOOPS;i++){
        pos+=vec3(size*(sin(iTime)*.5+1.5),0.,0.);
        size*=(cos(iTime*2.)*.3+.5);
        r = f(pos,size,r);
    }
    return vec2(r,1.0);
}

// Function 1360
float Guard_SDF(in vec3 point)
{
    vec3 tpoint = Translate(point, vec3(0.0, 0.025, 5.625));
    vec3 bounds = vec3(2.9, 0.12, 0.19);
    
    float guard = length(max(abs(
                             vec3(
                                 tpoint.x,
                                 tpoint.y,
                                 tpoint.z - (cos(abs(tpoint.x)) * 0.515))) -   // Note to self: this is the line causing the normal glitch
                             vec3(
                                 bounds.x, 
                                 bounds.y - (abs(tpoint.x) * 0.065),      // Guard gets thinner as we go along the width (x)
                                 bounds.z - sin(abs(tpoint.x)) * 0.125),  // Adjust z-thickness along the width (x) of the guard
                             0.0));
    
    return guard;
}

// Function 1361
float map(vec2 xz)
{
	xz += noise(xz);
	vec2 a = 1.0 - abs(sin(xz));
	vec2 b = abs(cos(xz));
	return pow(dot(a, b), 0.5);
}

// Function 1362
float map(vec3 p)
{
    float time = TIME * .2;
	vec3 cp = p;
    
    p.xy *= rot(time);
    p.yz *= rot(time * .5);
    p.xz *= rot(time * .25);
    float dist  = sdIcosahedron(p, 1.7 );
    if(dist < .01)
        m = 1;
    p = cp;
    p.y = abs(p.y);
    p.xy *= rot(PHI);
    p.yz *= rot(PHI);
    p.xz *= rot(PHI);
    
    float outer = sdIcosahedron(p , 10.);  
    if(outer < .01 && m != 1)
        m = 2;
    
    dist = min(dist, -outer);
    
    
    return dist;
}

// Function 1363
vec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )
{
	Intersection primaryInt;
    RaymarchScene( vRayOrigin, vRayDir, primaryInt );

     float fFogDistance = 0.0;
    vec3 vResult = vec3( 0.0 );
    
    float fSunDotV = dot(GetSunDir(), vRayDir);    

    if ( primaryInt.m_objId == OBJ_ID_SKY )
    {
        vResult = GetSkyColour( vRayDir );
        fFogDistance = k_fFarClip;
    }
    else
    {
        Intersection waterInt;
        TraceWater( vRayOrigin, vRayDir, waterInt );

        vec3 vReflectRayOrigin;
        vec3 vSpecNormal;
        vec3 vTransmitLight;

        Surface specSurface;
        vec3 vSpecularLight = vec3(0.0);

    #ifdef ENABLE_WATER
        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );
        vec2 vFlowRate = vFlowRateAndFoam.xy;
        #ifdef ENABLE_FOAM
        float fFoam = vFlowRateAndFoam.z;
        float fFoamScale = 1.5;
        float fFoamOffset = 0.2;
        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );
        fFoam = fFoam * fFoam * 0.5;
        #else
        float fFoam = 0.0;
        #endif            

        float fWaterFoamTex = 1.0;
        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );
        
        if( vRayDir.y < -0.01 )
        {
            // lie about the water intersection depth
            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);
        }
        
        if( waterInt.m_dist < primaryInt.m_dist )
        {
            fFogDistance = waterInt.m_dist;
            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;

            vReflectRayOrigin = waterInt.m_pos;
            vSpecNormal = vWaterNormal;

            vec3 vRefractRayOrigin = waterInt.m_pos;
            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );

            Intersection refractInt;
            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); // note : dont need sky

            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );
            fFoam *= 1.0 - fEdgeAlpha;
            
            // add extra extinction for the light travelling to the point underwater
            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );

            specSurface.m_pos = waterInt.m_pos;
            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam
            specSurface.m_albedo = vec3(1.0);
            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );

            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));
  			float fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);
            float fGlossFactor = exp2( -fFilterWidth * 0.3 );
            specSurface.m_gloss = 0.99 * fGlossFactor;            
            specSurface.m_specScale = 1.0;
            
            vec3 vSurfaceDiffuse = vec3(0.0);

            float fSunShadow = 1.0;
        #ifdef ENABLE_WATER_RECEIVE_SHADOW
            fSunShadow = GetSunShadow( waterInt.m_pos );
        #endif
            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);
            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);

            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);
            vTransmitLight = vRefractLight.rgb;
            vTransmitLight += vInscatter;
            vTransmitLight *= vExtinction;   


    #ifdef ENABLE_FOAM
            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));
            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );
            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);
    #endif
        }
        else
    #endif // #ifdef ENABLE_WATER
        {
            fFogDistance = primaryInt.m_dist;

            Surface primarySurface;
            GetSurfaceInfo( primaryInt, primarySurface );

            vSpecNormal = primarySurface.m_normal;
            vReflectRayOrigin = primaryInt.m_pos;
            
            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);
            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );
            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );

            vTransmitLight = vec3(0.0);
            float fSunShadow = 1.0;
       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW
            fSunShadow = GetSunShadow( primaryInt.m_pos );
       #endif
            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);
            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);
            vTransmitLight *= primarySurface.m_albedo;
            specSurface = primarySurface;
        }

        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );
        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );

        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );
        
        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );

        vSpecularLight += vReflectLight;
        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );
    }
    
    
    if ( fFogDistance >= k_fFarClip )
    {
        fFogDistance = 100.0;
        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;
    }    
    
    vec3 vFogColour = GetSkyColour(vRayDir);
    
    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );
    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );
    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);
    
    return vResult;
}

// Function 1364
vec3 CubemapNormal(in vec2 tile) 
{   
    float s = (2.0*square((tile.x + 1.0)*0.5) - 1.0);
    
    float x = square(tile.x) * square(tile.y + 1.0) * s;
    float y = square(tile.y) * s;
    float z = square(tile.x + 1.0) * square(tile.y + 1.0) * s;
 
    return vec3(x, y, z);
}

// Function 1365
float obstacleDist(vec3 p)
{
    //// car
    return distCar((p*vec3(1,-1,1)-vec3(0,0,-.2))*1.8)/1.8;
    ////// sphere
    //float d=length(p)-.35;
    //// cylinder
    //float d=length(p.yz)-.35;
    //// plane
    float d=sdRoundBox( transformVecByQuat(p-vec3(0,0,-0.1),axAng2Quat(vec3(1,0,0),.6)), vec3(.45,.45,.05), 0.02 );
    //d=max(d,p.y);
    return d;
}

// Function 1366
vec2 sceneDistance( in vec3 point ) {
    return sceneDistance( point, .0 );
}

// Function 1367
MarchResult raymarchScene(in vec3 ro, in vec3 rd, out vec4 scattering, in vec2 fragCoord)
{
    float tmin = 0.0;
    float tmax = 50.0;
    float t = tmin;
    float prevt = t;
    float d = 0.0, eps = 0.0;
    float prevd = d;
    float density = 0.0;
    float transmittance = 1.0;
    float stp = 0.0;
    vec3 inscatteredLight = vec3(0.0);
    vec3 inscatteredLightFromEquiAngularSampling = vec3(0.0);
    MarchResult result;
    int stepsEquiAngularSampling = 0;
    
    for (int i = 0; i < 300; ++i)
    {
        eps = t * 0.001;
        vec3 p = ro + t * rd;    
          
        density = (densityVoumetricFog(p * 253.0));
        integrateVolumetricFog(p, rd, density, stp, transmittance, inscatteredLight, fragCoord);
        if (stepsEquiAngularSampling < 32)
        {
            float u = rand(rand(fragCoord.x * iResolution.y + fragCoord.y + d * 1.5) + iTime + 1234.32598);
            float v = rand(rand(fragCoord.y * iResolution.x + fragCoord.x + d * 2.5) + iTime * 2.0 + 6234.32598);
            vec3 lightPos;
            vec3 lightCol;
            sampleAreaLight(vec2(u, v), lightPos, lightCol);

            float x0 = rand(rand(fragCoord.y * iResolution.y + fragCoord.x + d * 3.5 + iTime) + 236526.436346);
            // --- equi-angular sampling
            float DT = dot(lightPos - ro, rd);
            float D = length(ro + DT * rd - lightPos);
            float tha = atan(0.0 - DT, D);
            float thb = atan(length(tmax - ro) - DT, D);
            float tsampled = D * tan(mix(tha, thb, x0));
            float pdf = D / ((thb - tha) * (D * D + tsampled * tsampled));
            float x = DT + tsampled;
            vec3 sampledPos = ro + x * rd;
            
        	float densityFromSampledPos = (densityVoumetricFog(sampledPos * 253.0));
        	integrateVolumetricFogFromSampledPosition(sampledPos, rd, densityFromSampledPos, x, inscatteredLightFromEquiAngularSampling, lightPos, lightCol, pdf); 
        	stepsEquiAngularSampling++;        
        }
        
        SceneData res = intersectTerrain(p.xz);
        float h = res.sdf;
        d = p.y - h;
        
        vec3 prot = getRotation() * (p - AreaLightPosition);
        SceneData lightPlane = intersectBox(prot, AreaLightSize);
        SceneData terrain;
        terrain.sdf = d;
        terrain.materialID = res.materialID;
        SceneData scene = unite(terrain, lightPlane);
        d = scene.sdf;
        result.materialID = scene.materialID;
        if (d < eps)
            break;        
        
        stp = d * 0.32;
        prevt = t;
        prevd = d;
        t += stp;
        if (t > tmax)
            break;
    }
    if (t > tmax)
        t = -1.0;
    else
        t = mix(prevt, t, d/prevd);
    
    inscatteredLightFromEquiAngularSampling *= 1.0 / float(stepsEquiAngularSampling); 
    scattering = vec4(inscatteredLight + inscatteredLightFromEquiAngularSampling, transmittance);
    result.t = t;
    return result;
}

// Function 1368
float map_hole(vec3 pos, bool hasBump)
{  
    #ifdef bump
    if (hasBump)
    {
       vec3 pos2 = vec3(pos.yx, 0.);
       pos.z+= bumpHeight*polarNoise2N(pos2);
    }
    #endif     
    
    float d = pos.z + holeFunct(pos.yx, holeWidth);
    #ifdef test_mode
    d = max(d, -pos.y);
    #endif
    
    return d;
}

// Function 1369
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{	    
    int faceID = CubeFaceCoords(rayDir);
    if(faceID!=0 && faceID!=5) discard;
    
    vec2 uv = fract(fragCoord/1024.*vec2(1, -1) );  
    if(faceID==0) mainImage_A(fragColor,uv*cubemapRes); 
    else if(faceID==5)  mainImage_C(fragColor,uv*cubemapRes);
     
}

// Function 1370
vec2 scene_sdf(vec3 p){
    vec2 curr = bishop_sdf(p, vec3(-2.,0,5), WHITE, 0.35);
    vec2 bishop_1 = bishop_sdf(p, vec3(2.,0,5), WHITE, 0.35);
    vec2 pawn_1 = pawn(p, 0.009 , 3.50, vec3(-4.,-0.0009, 6), BLACK, 0.2);
    vec2 king = king_sdf(p, vec3(0, 0, 4.5), BLACK, 0.4);
    vec2 plane = vec2(floor_sdf(p), 2); 
    vec2 pawn_2 = pawn(p, 0.009 , 3.50, vec3(4.,-0.0009, 6), BLACK, 0.2);
    //vec2 wall = vec2(wall_sdf(p), 2);
    
    
    curr = opUnionVec2(curr, pawn_1);
    curr = opUnionVec2(curr, pawn_2);
    curr = opUnionVec2(curr, bishop_1);
    curr = opUnionVec2(curr, king);
    curr = opUnionVec2(curr, plane);
    //curr = opUnionVec2(curr, wall);
    
    return curr;
}

// Function 1371
float map_smooth(vec3 pos)
{
    return smin(map_slime(pos).x, 0.95*map_ns(pos).x, clamp(0., 1., 1. + clamp(0.1*pos.y, -0.3, 1.) - 0.7*smoothstep(2., 6.5, 0.17*pow(abs(pos.x), 2.) + 6.*smoothstep(0.3, 2.3, abs(pos.z)))));
    //return min(map_slime(pos).x, 0.9*map_ns(pos).x);
}

// Function 1372
Intersection sdf3D(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    
    vec3 sdfColor = vec3(0., 0., 0.);
    // Sample a few points in the hemisphere around n at p
    vec3 tdire, bdire;
    // Make a tangent and bitangent vector
    coordinateSystem(nor, tdire, bdire);
    for(int i = 0; i < GLOBAL_SAMPLES; ++i) {
        // Generate a pair of random [0, 1] floats
        vec2 xi = random2(isect + float(i) * 203.1);
        // vec2 xi = vec2(1., 0.);
        // Convert the xi pair to a vector in the hemisphere
        xi.y = pow(xi.y, 2.);
        float len = sqrt(xi.y);
        float rx = len * cos(6.2831 * xi.x);
        float ry = len * sin(6.2831 * xi.x);
        float rz = sqrt(1.0 - xi.y); // z = sqrt(1 - x*x - y*y)
        vec3 dir2 = vec3(rx * tdire + ry * bdire + rz * nor);
        float t2;
        int hitObj2;
        isect += dir2 * 0.01;
        march(isect, dir2, t2, hitObj2);
        vec3 isect2 = isect + t2 * dir2;
        vec3 nor2 = computeNormal(isect2);
    
        vec3 material2 = computeMaterial(hitObj2, isect2, nor2);
        float shadowCoefficient = 1.f;
        vec3 overallColor2 = material2 * (lambertColor(isect2, nor2) * shadowCoefficient + 0.1);
        sdfColor += overallColor2;
    }
    sdfColor /= float(GLOBAL_SAMPLES);
    
    return Intersection(t, sdfColor, isect, hitObj);
}

// Function 1373
float distributionAnisotropic(float NoH, vec3 h, vec3 t, vec3 b, float at, float ab) {
    float ToH = dot(t, h);
    float BoH = dot(b, h);
    float a2 = at * ab;
    vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
    float v2 = dot(v, v);
    float w2 = a2 / v2;
    return a2 * w2 * w2 * (1.0 / PI);
}

// Function 1374
vec3 map(vec3 p) {
    
    vec3 
        obj = vec3(FAR, -1.0, 0.0),
        obj2 = obj;
    
    vec3 orgP = p;
    
    float mat = 0.;
    
    obj = vec3(
        fBox(p, vec3(1.25, 1.25, INFINITY)),
        7.,
        0.
    );
    
    pModPolar(p.yx, 8.);
    
    obj2 = vec3(
        fBox(p, vec3(1.8, .9, INFINITY)),
        8.0,
        0.
    );
    
    obj = opS2(obj, obj2);
    
    p = orgP;
    p.z += 3. + t * 4.;
    
    obj2 = vec3(
        fSphere(p + sin(t) / 3., 0.1),
        6.0,
        0.0
    );
    
    p = orgP;
    obj = opU2(obj, obj2);
    
    float mp = pModPolar(p.yx, 24.);
    float rz = pModInterval1(p.z, 1.0, -INFINITY, INFINITY);
    
    p.y += -.9;
  
    obj2 = vec3(
        fSphere(p, 0.1 + sin(mp * 8. + rz + t * 5.) / 8.),
        ceil(mod(sin(rz) * 10., 4.)),
        0.
    );    
    
    obj = opU2(obj, obj2);
    
    return obj;
}

// Function 1375
float map(vec3 p){
    
    
    float d =  columns(p); // Repeat columns.
    
    float fl = p.y + 2.5; // Floor.

    p = abs(p);
    
    d = sminP(d, -(p.y - 2.5 - d*.75), 1.5); // Add a smooth ceiling.
    
    d = min(d, -(p.x - 5.85)); // Add the Walls.
    
    d = sminP(d, fl, .25); // Smoothly combine the floor.
     
    return d*.75;
}

// Function 1376
float minimizeDistance(float t, vec3 p, TorusKnotParameters tkp)
{
    float lerningRate = 0.01/max(tkp.kq,tkp.kp);
	const int maxIterations = 30;
    
    for(int i = 0; i < maxIterations; i++)
    {
        float dt = torusKnotSqDistanceDerivative(t, p, tkp);
        
        if(abs(dt) < 0.001)
            break;
        
        t -= lerningRate*dt;
    }
    
    return t;
}

// Function 1377
vec3 TonemapProcess( vec3 c )
{
    float YOrig = GetBT709Luminance( c );
    
    // Sort of hue preserving tonemap by scaling the original color by the original and tonempped luminance
    float YNew = GetBT709Luminance( whitePreservingLumaBasedReinhardToneMapping( c ) );
    vec3 result = c * YNew / YOrig;
    
    float desaturated = GetBT709Luminance( result );
        
	// Stylistic desaturate based on luminance - we want pure primary red to desaturate _slightly_ when bright
	float sdrDesaturateSpeed = 0.2f;
	float stylisticDesaturate = TonemapFloat( YOrig * sdrDesaturateSpeed );
    
    
	float stylisticDesaturateScale = 0.8f; // never fully desaturate bright colors
	stylisticDesaturate *= stylisticDesaturateScale;    
    
    result = mix( result, vec3(desaturated), stylisticDesaturate );
    
    return result;
}

// Function 1378
float map( in vec3 pos ) {
	float d = 1000000.;
	vec3 q;
	float t = mod(iTime*2.,1.);
	for(int i=-1; i < 10; i++){
		float ii = float(i);
        float y = -.1+(-ii-t)*.2;
        y += .2*t*smoothstep(8.,9.,ii);
		q = pos+vec3(0.,y,0.);
        vec3 c = vec3(2.,0.,2.);
        q = mod(q,c)-0.5*c;
        float size = 1.-ii*.1-t*.1;
		d = min(sdBox(q, vec3(size,.1,size)),d);
	}
	d = min(d,sdGround(pos));
	return d;
}

// Function 1379
float sceneSDF(vec3 p){
	return sceneSDF(p,1.0);
}

// Function 1380
vec2 distM(vec3 p)
{
    float d=1000., mat=-1., d_mat=d;
    
    if(enable_car)
    {
        vec2 dm=distCar(carTrafo(p));
        d=dm.x; mat=dm.y; d_mat=d;
    }
    
    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;
    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;
    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;
    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;
    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;
    float rm=r3.y*1.+r4.y*.5+r5.y*.25;
    float rm2=r3.z*.7+r4.z*.5;
    float pp=dot(p.xy,p.xy)/(200.*200.);

    d=min(d,p.z
    +.66
    -hTerr(p)
    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035
    );
    SET_PREV_MAT(FLOOR);
    
    //#define DEBUG
    #ifdef DEBUG
    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;
    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;
    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);
    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);
    SET_PREV_MAT(DBG_GREEN);
    #endif
    
    return vec2(d,mat);
}

// Function 1381
vec4 map(vec3 p)
{
   	float scale = 1.;
    float box = 0.;
    
    float x = 8.;
    float z = x*iResolution.y/iResolution.x;
    
    vec4 disp = displacement(p+vec3(x,1.,z));
    
    float y = disp.x*scale;
    
    if ( p.y > 0. ) box = obox(p, vec3(x,y,z));
    else box = obox(p, vec3(x,1.,z));
	
    return vec4(box, disp.yzw);
}

// Function 1382
float GetDist(vec3 p) {
    return sdBox(p, vec3(BOX_SIZE));
}

// Function 1383
vec2 forward_mapping(vec2 Z,vec3 R, int seed){
    int p = int(R.x);
    int q = int(R.y);
    
    int x=int(Z.x);
    int y=int(Z.y);
    
    for(int i = 0; i < mapping_iters; i++){
        x = Zmod(x + IHash(y^seed)%p,p);
        y = Zmod(y + IHash(x^seed)%q,q);
    }
        
    return vec2(x,y)+.5;
    
}

// Function 1384
float GetDist(vec3 p) {
    float pd = p.y;
    
    vec3 bp1 = p-vec3(5, 1.5, 0.0);
    vec3 bp2 = p-vec3(4, 1.5, 0.0);
    vec3 bp3 = p-vec3(0, 1.5, 0.0);
    vec3 bp4 = p-vec3(-4.5, 1.5, 0.0);
    bp1.yz *= Rot(iTime*3.141*0.5);
    bp2.yz *= Rot((iTime*3.141*0.5)+(3.141*0.5));
    bp3.xz *= Rot((-iTime*3.141*0.125));
    
    float bd1 = sdTorus(bp1, vec2(1, 0.5));
    float bd2 = sdTorus(bp2, vec2(1, 0.5));
    float bd3 = dBox(bp3, vec3(1.0, 0.5, 1.0));
    float bd4 = sdCapsule(bp4, vec3(1.5, sin(iTime*3.141*0.25), 2.0), vec3(0.5, cos(iTime*3.141*0.25), -2.0), 0.5);
    float d = min(bd1, bd2);
    d = min(d, bd3);
    d = min(d, bd4);
    d = min(d, pd);
    
    return d;
}

// Function 1385
float sdf_D(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_quarter1_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    return t;
}

// Function 1386
float ceilingSdf(vec3 pos)
{ 
  pos -= vec3(6.0, 5.0, 6.0);
  float b = sdPlane(pos, vec4(0.0, -1.0, 0.0, 0.0)); 
  const float repeat = 12.0;
  opRepeat(pos.x, repeat);
  opRepeat(pos.z, repeat);
  float cz = sdCylinderZ(pos, vec3(0.0, 0.0, 5.0));
  float cx = sdCylinderX(pos, vec3(0.0, 0.0, 5.0));
  float c = min(cz, cx);   
  return opSubtraction(c, b);
}

// Function 1387
float remap(float a, float b, float t) {
    return (t - a) / (b - a);
}

// Function 1388
float dist0(vec4 p, vec4 q, vec4 r) {
  vec4 t = closest(p,q,r);
  t = normalize(t);
  return dist(p,t);
}

// Function 1389
SceneData map(vec3 p)
{
    p.z -= 9.0;
    SceneData front = SceneData(box(p + vec3(0.0, 0.0, -3.0), vec3(3.1, 3.1, 0.1)), kWallMat);
    SceneData back = SceneData(box(p + vec3(0.0, 0.0, 12.2), vec3(3.1, 3.1, 0.1)), kBlueMat);
    SceneData left = SceneData(box(p + vec3(3.0, 0.0, 0.0), vec3(0.1, 3.1, 14.02)), kRedMat);
    SceneData right = SceneData(box(p + vec3(-3.0, 0.0, 0.0), vec3(0.1, 3.1, 14.02)), kGreenMat);
    SceneData bottom = SceneData(box(p + vec3(0.0, 3.0, 0.0), vec3(3.1, 0.1, 14.0)), kWallMat);
    SceneData top = SceneData(box(p + vec3(0.0, -2.8, 0.0), vec3(3.1, 0.02, 14.0)), kWallMat);
    SceneData topLight = SceneData(box(p + vec3(0.0, -3.75, 2.0), vec3(1.0, 1.0, 1.0)), kEmissiveMat);
    
    vec3 p1 = p + vec3(1.0, 1.0, -0.9);
    vec3 p2 = p + vec3(-1.0, 2.0, 1.75);
    
    p1.xz *= rot(0.4);
    p2.xz *= rot(-0.4);
    
    SceneData boxes = SceneData(
        min(
            box(p1, vec3(0.8, 2.0, 0.8)),
            box(p2, vec3(0.8, 1.0, 0.8))
        )
    , kBoxMat);
    
    SceneData sphere = SceneData(
        length(p + vec3(1.0, 2.0, 1.0)) - 1.0,
        kSphereMat
    );
    
    SceneData scene = opOR(front, left);
    scene = opOR(scene, topLight);
    scene = opOR(scene, back);
    scene = opOR(scene, right);
    scene = opOR(scene, bottom);
    scene = opOR(scene, top);
    scene = opOR(scene, boxes);
    scene = opOR(scene, sphere);
    
    return scene;
}

// Function 1390
float seaGeometryMap(vec3 p) 
{
    #if WATER_TYPE == WAVES_WATER
    vec2 uv = p.xz * vec2(0.85, 1.0);
	
    float freq 	 = SEA_FREQ;
    float amp 	 = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    
    float d = 0.0;
    float h = 0.0;    
    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) 
    {   
		#if FANTASY_WATER_PATH
        if (uv.x > UV_START_X && uv.x < UV_END_X)
	   	{
			continue;
	   	}
		#endif

    	d =  seaOctave((uv + SEA_CURRENT_TIME) * freq, choppy);
    	d += seaOctave((uv - SEA_CURRENT_TIME) * freq, choppy);
        h += d * amp; 
	    
		freq *= SEA_GEOMETRY_FREQ_MUL; 
		amp  *= SEA_GEOMETRY_AMPLITUDE_MUL;
	    
        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);
	    
		uv *= octaveMatrix; 
    }
    return p.y - h;
    #else
    return p.y;
    #endif
}

// Function 1391
float map(in vec3 p)
{
    vec3 fp = fold(p) - vec3(0.,0.,1.275);
    float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);
    
    if (solidType == 1)
    {
	  d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;
      d += tri(fp.y*5.)*0.04;
      d *= 0.9;
	}
    else if (solidType == 2)
    {
	  d *= 0.7;
      d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;
      d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;
      d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;
    }
	else if (solidType == 3)
	{
      d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;
      d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;
    }
	else if (solidType == 4)
      d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;
	else
    {
      d = smax(d+.2, -(d+cos(fp.z*13.+cos(fp.x*18.*fp.y*2.)+2.1)*0.5-0.5))*.8;
	  d += tri(fp.x*3.+fp.z*6.)*0.1+tri(fp.x*fp.y*4.+time*0.2)*0.1-0.17;
      d *= 0.5;
    }
    
    return d*0.25;
}

// Function 1392
vec3 ascene(in vec3 ro, in vec3 rd){
    float t = map(ro,rd);
    vec3 col = vec3(0);
    if (t==1000.0){col = vec3(0.5);} //if a "miss" is returned, set pixel to 50% grey
    
    else {
        vec3 loc = t*rd+ro;
        loc = loc*0.5;
        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));
    }
    return col;
}

// Function 1393
vec3 map_Gsph_ray(vec3 ro, vec3 rd, vec3 nrm) {
	return refract(rd, nrm, 0.85);
}

// Function 1394
vec3 linearToneMapping(vec3 color)
{
    float exposure = 1.;
    color = clamp(exposure * color, 0., 1.);
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 1395
vec2 map(in vec3 pos)
{
    vec2 res = vec2(sdPlane(pos, 0.0), 1.0);

    //res = opU2(res, vec2(sdCylinderY(pos - vec3(0,0.6,0), vec2(0.5, 0.5)), 2.0));
    //res = opU2(res, vec2(sdCylinderZ(pos - vec3(0,0.6,0), vec2(0.5, 0.5)), 2.0));
    //res = opU2(res, vec2(sdCircleRound(pos - vec3(0,0.6,0), 0.5, 0.1, 0.1), 128.0));
    //res = opU2(res, vec2(sdHeartOrigin(pos - vec3(0,0.6,0), false), 128.0));
    res = opU2(res, vec2(sdObject(pos), 128.0));
    
    // More accuracy (substepping)
    res.x *= 0.5;
    
    return res;
}

// Function 1396
TraceResult Map_Trace( sampler2D mapSampler, MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, int iSectorId, float fMaxDist )
{
    TraceResult result;
    
    result.iTexture = 0u;
    result.vTexture = vec3(0.0);
    result.fDist = 0.0;
    result.fLightLevel = 0.0;
    result.iSector = SECTOR_NONE;
    
    while(true)
    {
        if ( iSectorId == SECTOR_NONE )
        {
            break;
        }
        
        Sector sector = Map_ReadSector( mapSampler, iSectorId );
        
        TraceSectorState sectorState;
        sectorState.iNextSector = SECTOR_NONE;        
        sectorState.fEnterDist = result.fDist;
        sectorState.bNoUpper = false;
        result.fDist = fMaxDist;
        result.iSector = iSectorId;
        
        for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( sector.iSideDefCount); iSideDefIndex++)
        {
            SideDef sideDef = Map_ReadSideDefInfo( mapSampler, iSectorId, iSideDefIndex );                        

            TraceSideDef( mapSampler, vRayOrigin, vRayDir, result, sectorState, sector, sideDef );
        }

        // Test floor / ceiling
        if ( sectorState.fExitY < sector.fFloorHeight )
        {
            result.fDist = (sector.fFloorHeight - vRayOrigin.y) / vRayDir.y;
            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;
            result.vTexture.st = vec2( vFloorPos.xz );
            result.iTexture = sector.iFloorTexture;
            result.fLightLevel = 0.0;
            sectorState.iNextSector = SECTOR_NONE;
        }
        else
        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )
        {
            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) / vRayDir.y;
            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;
            result.vTexture.st = vec2( vCeilingPos.xz );
            result.iTexture = sector.iCeilingTexture;
            result.fLightLevel = 0.0;
            sectorState.iNextSector = SECTOR_NONE;
        }        

        iSectorId = sectorState.iNextSector;
    }
    
    if ( result.iTexture == 1u )
        result.fDist = FAR_CLIP;
    
    return result;
}

// Function 1397
float remap01(float a, float b, float t) {
    return sat((t-a)/(b-a));
}

// Function 1398
float dist (vec2 p)
{
    return (texture(iChannel1, p/5.).a - .5)/32.*5.;
}

// Function 1399
float map_detailed(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec3 uvt = vec3(p.xz, SEA_TIME); uvt.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_FRAGMENT; i++) {        
    	d = sea_octave((uvt)*freq,choppy);
    	d += sea_octave((uvt)*freq,choppy);
        h += d * amp;        
    	uvt.xy*= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 1400
vec2 GetDistanceCandlestick( const in vec3 vPos )
{
	vec2 vProfilePos = vec2( length(vPos.xz), vPos.y );

	float fTop = 2.0;
	float fBottom = 0.0;
	
	float fOutside = -1.0;
	
	float fDist = vProfilePos.x;	
	float fVerticalPos = vProfilePos.y;
	
	if(fVerticalPos > fTop)
	{
		fVerticalPos = fTop;
		fOutside = 1.0;
	}

	if(fVerticalPos < fBottom)
	{
		fVerticalPos = fBottom;		
		fOutside = 1.0;
	}

	float t = fVerticalPos;
	float a = 3.14 * 2.0;
	float b = 0.15;
	float fHorizontalPos = 0.4 + sin(t * a) * b;
	float fHorizontalPosDelta = (cos(t * a) * a * b) / a;
	
	float fHorizontalDist = vProfilePos.x - fHorizontalPos;
	
	if(fOutside > 0.0)
	{
		vec2 vClosest = vec2(min(fHorizontalPos, vProfilePos.x), fVerticalPos);
		
		fDist = length(vClosest - vProfilePos);		
	}
	else
	{
		
		if(fHorizontalDist > 0.0)
		{
			fOutside = 1.0;
		}

		if(fOutside < 0.0)
		{		
			float fTopDist = fTop - fVerticalPos;
			float fBottomDist = fVerticalPos - fBottom;
			fDist = min(fTopDist, fBottomDist);
			fDist = min(fDist, -fHorizontalDist);
		}
		else
		{
			fDist = fHorizontalDist / sqrt(1.0 + fHorizontalPosDelta * fHorizontalPosDelta);	
		}
	}
	
	float fBevel = 0.1;
	float fStickDistance = fOutside * fDist -fBevel;
	
	float fBaseTop = 0.1;
	float fBaseRadius = 1.0;
	vec2 vBaseClosest = vProfilePos;
	vBaseClosest.y = min(vBaseClosest.y, fBaseTop);
	vBaseClosest.x = min(vBaseClosest.x, fBaseRadius);

	float fBaseDistance = length(vProfilePos - vBaseClosest) - fBevel;
	
	return vec2( min(fStickDistance, fBaseDistance), kMaterialGold);
}

// Function 1401
vec3 map( in vec3 p )
{
    vec3 p00 = p - vec3( 0.00, 3.0, 0.0);
	vec3 p01 = p - vec3(-1.25, 2.0, 0.0);
	vec3 p02 = p - vec3( 0.00, 2.0, 0.0);
	vec3 p03 = p - vec3( 1.25, 2.0, 0.0);
	vec3 p04 = p - vec3(-2.50, 0.5, 0.0);
	vec3 p05 = p - vec3(-1.25, 0.5, 0.0);
	vec3 p06 = p - vec3( 0.00, 0.5, 0.0);
	vec3 p07 = p - vec3( 1.25, 0.5, 0.0);
	vec3 p08 = p - vec3( 2.50, 0.5, 0.0);
	vec3 p09 = p - vec3(-3.75,-1.0, 0.0);
	vec3 p10 = p - vec3(-2.50,-1.0, 0.0);
	vec3 p11 = p - vec3(-1.25,-1.0, 0.0);
	vec3 p12 = p - vec3( 0.00,-1.0, 0.0);
	vec3 p13 = p - vec3( 1.25,-1.0, 0.0);
	vec3 p14 = p - vec3( 2.50,-1.0, 0.0);
	vec3 p15 = p - vec3( 3.75,-1.0, 0.0);
	
    vec3 p16 = p - vec3(-5.00,-2.7, 0.0);
    vec3 p17 = p - vec3(-3.75,-2.7, 0.0);
    vec3 p18 = p - vec3(-2.50,-2.7, 0.0);
    vec3 p19 = p - vec3(-1.25,-2.7, 0.0);
    vec3 p20 = p - vec3( 0.00,-2.7, 0.0);
    vec3 p21 = p - vec3( 1.25,-2.7, 0.0);
    vec3 p22 = p - vec3( 2.50,-2.7, 0.0);
    vec3 p23 = p - vec3( 3.75,-2.7, 0.0);
    vec3 p24 = p - vec3( 5.00,-2.7, 0.0);
	
	float r, d; vec3 n, s, res;
	
    #ifdef SHOW_SPHERES
	#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))
	#else
	#define SHAPE (vec3(d-abs(r), sign(r),d))
	#endif
	d=length(p00); n=p00/d; r = SH_0_0( n ); s = SHAPE; res = s;
	d=length(p01); n=p01/d; r = SH_1_0( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p02); n=p02/d; r = SH_1_1( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p03); n=p03/d; r = SH_1_2( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p04); n=p04/d; r = SH_2_0( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p05); n=p05/d; r = SH_2_1( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p06); n=p06/d; r = SH_2_2( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p07); n=p07/d; r = SH_2_3( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p08); n=p08/d; r = SH_2_4( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p09); n=p09/d; r = SH_3_0( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p10); n=p10/d; r = SH_3_1( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p11); n=p11/d; r = SH_3_2( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p12); n=p12/d; r = SH_3_3( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p13); n=p13/d; r = SH_3_4( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p14); n=p14/d; r = SH_3_5( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p15); n=p15/d; r = SH_3_6( n ); s = SHAPE; if( s.x<res.x ) res=s;
    
	d=length(p16); n=p16/d; r = SH_4_0( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p17); n=p17/d; r = SH_4_1( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p18); n=p18/d; r = SH_4_2( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p19); n=p19/d; r = SH_4_3( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p20); n=p20/d; r = SH_4_4( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p21); n=p21/d; r = SH_4_5( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p22); n=p22/d; r = SH_4_6( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p23); n=p23/d; r = SH_4_7( n ); s = SHAPE; if( s.x<res.x ) res=s;
	d=length(p24); n=p24/d; r = SH_4_8( n ); s = SHAPE; if( s.x<res.x ) res=s;
	
	return vec3( res.x, 0.5+0.5*res.y, res.z );
}

// Function 1402
vec3 colorSdf(float t) {
  float r = .385+.619*t+.238*cos(4.903*t-2.61);
  float g = -5.491+.959*t+6.089*cos(.968*t-.329);
  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);
  return clamp(vec3(r, g, b), 0.0, 1.0);
}

// Function 1403
float DistanceField( vec3 pos )
{
	return (RippleHeight(pos.xy)-pos.z)*.5;
}

// Function 1404
bool scene(Point3 X, inout float distance) {
    Material ignoreMaterial;
    return scene(X, distance, ignoreMaterial, true); 
}

// Function 1405
float sdf_ellipsoid(vec3 p, vec3 r)
{
    return (length(p/r) - 1.) / min3(r.x, r.y, r.z);
}

// Function 1406
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4, db4;
  vec3 col, vn, qHitEx;
  vec2 qBlk, q, sq;
  float dstObj, dstExObj, sh, r;
  int idObjEx;
  bool isBg;
  SetConf ();
  szFac = 0.5;
  pgSize = vec3 (15., 0.1, 10.);
  isBg = false;
  isSh = false;
  dstExObj = ExObjRay (ro, rd);
  idObjEx = idObj;
  qHitEx = qHit;
  dstObj = ObjRay (ro, rd);
  db4 = BlkHit (ro - vec3 (0., -2.6, -4.), rd, pgSize);
  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {
    if (dstObj < dstExObj) {
      ro += dstObj * rd;
      vn = ObjNf (ro);
      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);
      col4 = ObjCol (vn);
    } else {
      ro += dstExObj * rd;
      vn = ExObjNf (ro);
      if (idObjEx == idPen) {
        r = length (qHit.xy);
        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));
        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.), col4, step (0.18, r));
        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.2), col4, step (qHitEx.z, 4.5));
      } else if (idObjEx == idFrm) {
        col4 = vec4 (0.4, 0.5, 0.6, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));
      }
    }
  } else if (db4.x < dstFar) {
    ro += db4.x * rd;
    vn = db4.yzw;
    q = ro.xz - vec2 (0., -4.);
    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {
      sq = sign (q);
      col = (sq.x < 0. || sq.y < 0.) ? SkMain (q - 0.5 * sq * pgSize.xz,
         sq.y + 1. + 0.5 * (sq.x + 1.)) : vec3 (1.);
      if (Minv3 (col) > 0.95) {
        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));
        col = mix (vec3 (0.6, 0.8, 0.9), vec3 (1.), min (q.x, q.y));
      }
    } else {
      col = vec3 (1.) * (0.8 + 0.2 * step (0.5, vn.y));
      sh = 1.;
    }
  } else {
    isBg = true;
  }
  if (! isBg) {
    isSh = true;
    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));
    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {
      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);
      col += col4.a * vec3 (0.5) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
         SmoothBump (0.25, 0.75, 0.05, qBlk.y));
    } else {
      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);
    }
  } else {
    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);
    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +
       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.1, qBlk.y));
  }
  return clamp (col, 0., 1.);
}

// Function 1407
float map_flame(vec3 pos, bool turb)
{
   vec3 pos0 = pos;    
    
   if (turb)
   {
      vec3 q = pos*fts;       
       
      float n = 0.1*noise(q*1.9);
      q.xy = rotateVec(-q.xy, pos.z*n);
      q.yz = rotateVec(-q.yz, pos.x*n);
      q.zx = rotateVec(-q.zx, pos.y*n);
        
      q*= vec3(1., 1.5, 1.);
      q+= vec3(ft, 0., 0.);
      q.x+= 0.5*pos.x*noise(q + vec3(30., 40., 50. + ft));
      q.y+= 0.5*pos.x*noise(q + vec3(10., 30. + ft, 20.));
      q.z+= 0.5*pos.x*noise(q + vec3(20., 60. - ft, 40. - ft));
 
      float dn = dnf;
      pos.x+= dn*noise(q + vec3(12., 3.+ ft, 16. - ft)) - dn/2.;
      pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;
      pos.z+= dn*noise(q + vec3(8. + ft*0.3, 22., 9.)) - dn/2.;
   }
   pos.x = abs(pos.x);
    
   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;
   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);
   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2((turb?0.45:0.58) + 0.32*cos(pos.x*pi/e), e)));
    
   if (turb)
   {
     c = mix (c, 0.3*c -0.9*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.3, e - r2 - l, -pos0.x));
     c*= (1. + 0.6*smoothstep(e - r2 - l - 1., e - r2 - l, pos0.x)); 
   }
   return c;
}

// Function 1408
float scene (in vec3 p)
{
    vec2 offset = 1. * vec2 (cos (iTime), sin (iTime));
    vec2 offset2 = -1. * vec2 (cos (6.28+iTime), sin (6.28+iTime));
    float warp = .2 + .05 * (.5 + .5 * cos (25.*p.y + 8.*iTime));
    float sphere = sdSphere (p + vec3 (-offset.x, .0+offset.y, .0), .2 + warp);

    vec3 w = (p + vec3 (-offset2.x, -.125+offset2.y, .0));
    opBend (w, 42.5 * cos (3.*iTime));
    float dt = sdSphere (w, .65);
    float dp = displace (w);
    float thing = dt + dp;
    thing = min (thing, sphere);
 
    
    p.xz *= r2d (-12.*iTime);
    p.yx *= r2d (8.*iTime);
    vec3 p1 = p + vec3 (.355);
    p1 = opRepeat3 (p1, .325);
    float boxes = udBox (p1, vec3 (.15), .03);
    float cutBox = sdBox (p, vec3 (2.7), .05);
    float wallBox = sdBox (p, vec3 (2.8), .05);

    return opUnion (thing, opUnion (-wallBox, opSubtract (cutBox, boxes)));
}

// Function 1409
float sdistTri(vec2 a, vec2 b, vec2 c, vec2 pos)
{
    return max( sdistLine(a, b, pos),
            max(sdistLine(b, c, pos),
                sdistLine(c, a, pos)));
}

// Function 1410
float GetBoatTopDistance( vec3 vPos )
{
    return length( vPos - vec3(0,-10,1)) - 10.0-.7;
}

// Function 1411
float torDist(vec2 p){
    
    return length(p);
    
    /*
    // Hexagon arcs.
    p = abs(p);
    return max(p.x*.8660254 + p.y*.5, p.y);
    */
    
    /*
    // Dodecahedral arcs.
    p = abs(p);
    vec2 p2 = p.xy*.8660254 + p.yx*.5;
    return max(max(p2.x, p2.y), max(p.y, p.x));
    */

      
    
}

// Function 1412
float DistributionTerm( float roughness, float ndoth )
{
	float m2	= roughness * roughness;
	float d		= ( ndoth * m2 - ndoth ) * ndoth + 1.0;
	return m2 / ( d * d * MATH_PI );
}

// Function 1413
vec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){
   
    const float eps = 0.001;
    float ref = getGrey(tex3D(tex,  p , nor));                 
    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,
                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,
                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;
             
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 1414
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn, vnn, bgCol;
  float dstObj, dstSurf, sh;
  bgCol = BgCol (rd);
  dstObj = BallHit (ro, rd);
  dstSurf = SurfRay (ro, rd);
  if (min (dstObj, dstSurf) < dstFar) {
    if (dstObj < dstSurf) {
      ro += dstObj * rd;
      vn = vnObj;
      col4 = vec4 (HsvToRgb (vec3 (float (idBall) / float (nBall), 0.8, BallChqr (idBall, vn))), 0.3);
    } else if (dstSurf < dstFar) {
      ro += dstSurf * rd;
      vn = SurfNf (ro);
      vnn = vn;
      vn = VaryNf (4. * ro, vn, max (0.1, 4. - 4. * dstSurf / dstFar));
      col = mix (vec3 (0.6, 0.55, 0.55), vec3 (0.55, 0.6, 0.55), smoothstep (0., 0.05, ro.y));
      col4 = mix (vec4 (col, 0.), vec4 (0.8, 0.8, 0.9, 0.2), step (0.995, dot (vn, vnn)));
      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +
         col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
    }
    sh = BallHitSh (ro + 0.01 * ltDir, ltDir, 10.);
    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn.xz, normalize (ltDir.xz)), 0.) + 
       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
    col = mix (col, bgCol, 1. - min (1., exp2 (4. * (1. - 1.6 * min (dstObj, dstSurf) / dstFar))));
    
  } else col = bgCol;
  return clamp (col, 0., 1.);
}

// Function 1415
vec3 colormapTerrainStone(float h) {
    return mix(vec3(0.4), vec3(0.7,0.6,0.5), h);
}

// Function 1416
float MapTerrain( vec3 p)
{   
  float terrainHeight = GetTerrainHeight(p);   
  terrainHeight= mix(terrainHeight+GetStoneHeight(p, terrainHeight), terrainHeight, smoothstep(0., 1.5, terrainHeight));
  terrainHeight= mix(terrainHeight+(textureLod(iChannel1, (p.xz+planePos.xz)*0.0015, 0.).x*max(0., -0.3+(.5*terrainHeight))), terrainHeight, smoothstep(1.2, 12.5, terrainHeight));

  terrainHeight= mix(terrainHeight-0.30, terrainHeight, smoothstep(-0.5, 0.25, terrainHeight));
  float water=0.;
  if (terrainHeight<=0.)
  {   
    water = (-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(-iTime*0.4, iTime*0.25))*2.60, WATER_LOD))));
    water*=(-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(iTime*.3, -iTime*0.25))*2.90), WATER_LOD)));
  }
  return   p.y -  max((terrainHeight+GetTreeHeight(p, terrainHeight)), -water*0.04);
}

// Function 1417
float sdf_p(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -8, 0)));
    return t;
}

// Function 1418
float sdf_mask(vec3 p) {
	p.x = abs(p.x) - .28;

	p.xz *= r2d(.56);
	p.xy *= r2d(-.01);

	return sdf_crystal(p, 3.);
}

// Function 1419
float getSDF(vec3 p){

    vec3 l = vec3(1,0,1);
    return sphereSDF(p-CELL*clamp(round(p/CELL),-l,l), radius);
}

// Function 1420
vec3 scene_shade(vec3 p, vec3 n, L l, M m, C c)
{
	return l.d * m.d * dot(n, normalize(l.p - p))
		+ l.s * m.s * pow(clamp(dot(normalize(reflect(l.p - p, n)), normalize(p - c.p)), 0., 1.), m.e);
}

// Function 1421
SceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist, int iInsideObject )
{	
    SceneResult result;
    result.fDist = 0.0;
    result.vUVW = vec3(0.0);
    result.iObjectId = -1;
    
	float t = minDist;
	const int kRaymarchMaxIter = 96;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
		result = Scene_GetDistance( vRayOrigin + vRayDir * t, iInsideObject );
        t += result.fDist;

        if ( abs(result.fDist) < 0.001 )
		{
			break;
		}		

        if ( ( iInsideObject == -1 ) && (abs(result.fDist) > 0.1) )
        {
            result.iObjectId = -1;
        }
        
        if ( t > maxDist )
        {
            result.iObjectId = -1;
	        t = maxDist;
            break;
        }        
	}
    
    result.fDist = t;


    return result;
}

// Function 1422
vec2 distID( in vec3 p )
{
    return u(vec2(plane(p),ID_PLANE), vec2(sdBox(mod(p,2.)-1.,vec3(.3)),ID_BOX));
    /* E.g.
	vec2 closest = u(vec2(yourObjectA(p), ID_YOUR_OBJ_A),
			         vec2(yourObjectB(p), ID_YOUR_OBJ_B);
		 closest = u(closest, vec2(plane(p), ID_PLANE);
	*/
}

// Function 1423
float map2(vec2 p) {
    return crossSection(p+ vec2(-2., -0.25));
}

// Function 1424
float sdf_d(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));
    return t;
}

// Function 1425
float sdf_c(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));
    return t;
}

// Function 1426
vec2 barrelDistortion(vec2 coord, float amt) {
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc);
	//return coord + cc * (dist*dist)  * amt;
	return coord + cc * dist * amt;

    }

// Function 1427
maybe_vec2 get_distances_along_3d_line_to_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r
){
    vec3 B = normalize(B2 - B1);
    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);
    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);
    float a_in = min(a1.value, a2.value);
    float a_out = max(a1.value, a2.value);
    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);
    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);
    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);
    // TODO: do we need this line?
    float entrance = max(tube.value.y,  a_in);
    float exit     = min(tube.value.x, a_out);
    return maybe_vec2( 
        vec2(entrance, exit), 
        tube.exists && entrance < exit
    );
}

// Function 1428
float map_lampg(vec3 pos)
{
    vec2 hmp = getLampMPos(pos);
    float hm = 0.5*getLampBump(hmp)*
               smoothstep(1.12, 0.93, length(pos.y)/lampsize.y)*
               smoothstep(0.91, 0.97, length(pos.xz)/lampsize.x);
    return opS(sdCylinder(pos, lampsize), sdCylinder(pos, lampsize*vec2(0.86, 1.5))) - hm;
}

// Function 1429
float mapDrop( in vec3 p )
{
    p -= vec3(-0.26,0.25,-0.02);
    p.x -= 2.5*p.y*p.y;
    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );
}

// Function 1430
vec3 seaHeightMap(vec3 dir) 
{
    vec3 p = vec3(0.0);
    float x = 1000.0;
	
    if (sea_geometry_map(SEA_ORI + dir * x) > 0.0)
    {
		return p;
    }
    
    float mid = 0.0;
    float m = 0.0;
    float heightMiddle = 0.0;
    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) 
    {	    
		mid = mix(m, x, 0.5); 
        p = SEA_ORI + dir * mid;                   
    	heightMiddle = sea_geometry_map(p);
		if (heightMiddle < 0.0) 
		{
            x = mid;
        } 
		else 
		{
            m = mid;
        }
    }
	
    return p;
}

// Function 1431
float GetDistDodecahedron(vec3 p) {
    // Dodecahedron distance to a face
    vec3 q = p;
    q -= ICOMIDEDGE; // walking from center to an edge
     // rotation among the edge (Y axis for the Dode) to align the face
    q.xz *= Rot(DODEDIHEDRAL*.5); // smoothly folds the face on the Y axis
    // draws a face, rounded at the corners
    float dDode = length(max(vec3(-q.x,q.y - Y_TO_DODE_VERTEX,q.z), 0.))+min(q.z, 0.);
    dDode = abs(dDode-.025)-.05; // onioning and rounding
    // Holes are centered on the dodecaheron's faces center
    float dHole = length( vec2(q.x - X_TO_DODE_CENTER,q.y) ) - .3;    
    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico
    float dSmallHole = length( q.xy-mix(vec2(0.0,Y_TO_DODE_VERTEX),vec2(X_TO_DODE_CENTER,0.0),.3) ) - .07;
    dSmallHole = abs(dSmallHole)-.030;
    dSmallHole = abs(dSmallHole)-.020;
    // Spheres on the vertices (dodecahedron's vectrices are icosahedron face's centers)
    float dCorners = length(p - ICOMIDFACE * 1.24)-.12;    
    // blobby cross picked from IQ's magic box
    float dBlobbyCross = sdBlobbyCross(vec2(q.x-X_TO_DODE_CENTER*.2,q.y)*13.0,0.80)/13.0-.03;
    // shaking mixing the distances
    float dist = dDode;
    dist = smax(dist,-dSmallHole,.01);
    dist = smax(dist,-dHole,.02);
    dist = smax(dist,-dBlobbyCross,.01);
    dist = smin(dist,dDode+.005,.02);
    dist = smax(dist,-(dHole+.1),.04);
    dist = smin(dist,dCorners,.07);
    return dist;
}

// Function 1432
vec3 tonemap(vec3 color)
{
   const float A = 2.51;
   const float B = 0.03;
   const float C = 2.43;
   const float D = 0.59;
   const float E = 0.14;
   return (color * (A * color + B)) / (color * (C * color + D) + E);
}

// Function 1433
vec3 bsdf (in vec3 rd, in Result res) {
    // specular - brdf - not correct yet
    if (material[res.id].doesReflect) {
        vec3 ref = normalize (reflect (rd, res.normal));
        if (material[res.id].reflAmount < rand ()) {
			return ref;
        } else {
			return cosineDirection (ref);
        }
    }

    // transparent - btdf - wip
    if (material[res.id].doesRefract) {
        return normalize (refract (rd,
                                   res.normal,
                                   material[res.id].ior));
    }

    // diffuse - brdf
	return cosineDirection (res.normal);
}

// Function 1434
float getDist2Sphere(vec3 camPos, vec3 ray) {
    float ang = getAngle( - camPos, ray);
    float dist = length( - camPos);
    if (hitSphere(camPos, ray) < 0.0) {
        return dist * cos(ang) - sqrt(pow(dist * cos(ang), 2.0) - pow(dist, 2.0) + pow(sphereSize, 2.0));
    } else {
        return INFTY;
    }
}

// Function 1435
vec3 renderScene( ray r ) {
	float hit = 0.0;
    sdf e;
    float t = 0.0;
    for ( t = 0.001; t < 30.0; ){
    	e = estimate( r.o + r.d * t );
        if( e.d < 0.001 ){
        	hit = 1.0;
            break;
        }
        t += e.d;
    } 
    vec3 out_col = mix( vec3(0.0), shadeWater( r, t ), e.id );
    out_col = applyFog( out_col, r, t );
    return out_col;
}

// Function 1436
float shortestDistanceToSpheres(Ray ray) {

    float depth = MIN_DIST;// distance marched 
    //start raymarching loop
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        //distance from sphere
        float dist = spheresSDF(ray.origin + depth * ray.direction);
        //hit a sphere
        if (dist < EPSILON) {
            return depth;
        }
        depth += dist;
        //didnt hit a sphere
        if (depth >= MAX_DIST_SHADOW) {
            return MAX_DIST_SHADOW;
        }
    }
    return MAX_DIST_SHADOW;
}

// Function 1437
float SDFwater (vec3 p) {
	// return p.y+(sin((p.x+p.z)/2.)+sin((p.x+p.z)/2.+iTime*5.))/4.+.5;
    return p.y;
}

// Function 1438
void setup_scene()
{
    float t0 = tim*.5;
    for(int i=0; i<ptcnt; ++i) 
    {
        float t = t0 + float(i)*1.7;
        
        // Simple animation of spheres:
        pt[i].x = cos(t)*.5;
        pt[i].y = sin(t*1.1)*.5;
        
        // Put 6 sphere in front (lens) and 6 in the back:
        pt[i].z = ((i*2<ptcnt)?4.0:16.0) + cos(t*2.1);
    }
}

// Function 1439
vec4 GetHeatMap(float value, float max_value)
{
	return GetHeatMap(min(value / max_value, 1.0f));
}

// Function 1440
vec2 map( vec3 pos)
{
    float roundness = .15;
  	float rot = 1.;
	float k = .05;
    float size = .5;
    
    float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );
    scale = 1.;
    
    vec2 x;
    float h = 3.5;
    vec3 p = vec3(pos.x, pos.y, pos.z);
    float d1;
    float pl = sdPlane(p);
    x = vec2(sdPlane(p),1.0);
    for(float i = 1.; i < 10.; i++)
    {
        p = vec3(pos.x+sin(i/5.), pos.y-i/10., pos.z+3.+cos(i/5.)); // Position: Add For Negative, Subtract For Positive.
        p.xz *= rotate2d(i/5.);
        d1 = sdBox(p, vec3(0.75, 0.2, 0.9));
        x = opU(vec2(d1, 5.0), x);
    }
    p = vec3(pos.x, pos.y-.6, pos.z+3.); // Position: Add For Negative, Subtract For Positive.
    d1 = sdCapsule(p, vec3(.5, -1., 0.0), vec3(.5, 1., 0.), 0.5);
    x = blend(vec2(d1, 1.5), x, 0.1);
    p = vec3(pos.x-1., pos.y, pos.z+1.);
    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));
    x = opU(vec2(d1, 1.7), x);
    p = vec3(pos.x-1., pos.y, pos.z-5.);
    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));
    x = opU(vec2(d1, 1.7), x);
    p = vec3(pos.x+3., pos.y, pos.z+1.);
    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));
    x = opU(vec2(d1, 1.7), x);
    p = vec3(pos.x+3., pos.y, pos.z-5.);
    d1 = sdBox(p, vec3(0.3, clamp(p.y, 0.0, 3.0), .3));
    x = opU(vec2(d1, 1.7), x);
    p = vec3(pos.x, pos.y, pos.z+1.);
    d1 = sdBox(p, vec3(clamp(p.x, 2., 3.)+3., clamp(p.y, 0.79, 0.799), clamp(p.z, 1.9, 6.9)));
    x = opU(vec2(d1, 1.5), x);
    p = vec3(pos.x, pos.y-4.3, pos.z+1.);
    d1 = sdBox(p, vec3(clamp(p.x, 2., 3.6)+3., clamp(p.y, 1.21, 1.219), clamp(p.z, 1.9, 6.9)));
    x = opU(vec2(d1, 1.6), x);
    p = vec3(pos.x, pos.y-3.3, pos.z);
    d1 = sdBox(p, vec3(clamp(p.x,0., 0.6), clamp(p.y, 0.71, 0.719), clamp(p.z, 0.45, 0.7)));
    x = opU(vec2(d1, 1.1), x);
    return x;
    
}

// Function 1441
vec3 debugDistance(float d, vec3 color)
{
    float iso =
        smoothstep(0.92, 0.98, abs(fract(d) * 2. - 1.)) +
        smoothstep(0.8, 0.95, abs(fract(5.*d) * 2. - 1.))*0.5;
    return mix(vec3(1.), color, iso)* mix(0.8, 1., float(d > 0.)) * smoothstep(0.02,0.06, abs(d));
}

// Function 1442
vec2 GetDistanceShadowCasters( const in vec3 vPos )
{
	vec2 vResult = vec2(1000.0, -1.0);

	vec3 vCandlestickLocalPos = vPos - vCandlestickPos;	

	vec2 vCandlestick = GetDistanceCandlestick(vCandlestickLocalPos);
	if(vCandlestick.x < vResult.x)
	{
		vResult = vCandlestick;
	}
	
	vec2 vSphere = GetDistanceSphere(vPos);
	if(vSphere.x < vResult.x)
	{
		vResult = vSphere;
	}
	
	
	vec3 vPapereLocalPos = RotateY(vPos, g_PaperRotSin, g_PaperRotCos);
	
	vec2 vPaper = GetDistancePaper(vPapereLocalPos);
	if(vPaper.x < vResult.x)
	{
		vResult = vPaper;
	}

	
	#ifdef ENABLE_MIRROR
	
	vec3 vMirrorLocalPos = vPos - vec3(0.0, 0.0, 3.5);
	vMirrorLocalPos = RotateY(vMirrorLocalPos, g_MirrorRotSin, g_MirrorRotCos);
	
	vec2 vMirrorStand = GetDistanceMirrorStand(vMirrorLocalPos);
	if(vMirrorStand.x < vResult.x)
	{
		vResult = vMirrorStand;
	}
	
	
	vec3 vMirrorPaneLocalPos = vMirrorLocalPos - vec3(0.0, 2.7, 0.0);	
	vMirrorPaneLocalPos = RotateX(vMirrorPaneLocalPos, g_MirrorTiltSin, g_MirrorTiltCos);
	
	vec2 vMirror = GetDistanceMirror(vMirrorPaneLocalPos);
	if(vMirror.x < vResult.x)
	{
		vResult = vMirror;
	}
	#endif	

	return vResult;
}

// Function 1443
vec2 remap( in vec2 p ) {
    // flip coordinates so they're easier to work with
    // we'll flip them back before returning it
    float sig = p.x > 0.0 ? +1.0: -1.0;
    p.x = abs(p.x);
    // go to polar coordinates
    float theta = 0.0;
    float radius = 0.0;
    // do the bottom part
    float botPos = atan(p.x, -p.y) / (PI*0.5+CONE_THETA);
    if (botPos < 1.0) {
        theta = (botPos * CONE_LBOT) / CONE_L;
        radius = length(p);
    } else {
        // do the flat part
        float pos = dot(p, CONE_CSLOPE);
        float flatPos = pos / CONE_LFLAT;
        if (flatPos < 1.0) {
            theta = (CONE_LBOT + flatPos*CONE_LFLAT) / CONE_L;
            radius = dot(p, CONE_SLOPE);
        } else {
            // do the top part
            p.y -= CONE_HEIGHT;
            float topPos = (atan(p.y, p.x) - CONE_THETA) / (PI*0.5-CONE_THETA);
            theta = (CONE_LBOT + CONE_LFLAT + topPos*CONE_LTOP) / CONE_L;
            radius = length(p) + (1.0 - CONE_RADIUS);
        }
    }
    // squeeze the angle toward the top of the broccoli
    theta *= theta;
    // go back to cartesian, flip the sign and return
    theta = theta * sig * PI;
    return vec2(sin(theta), -cos(theta))*radius;
}

// Function 1444
Hit map(vec3 p)
{
    mat3 rot = rotMat3(vec3(1., 0., -0.5), iTime/4.);
    return mandelbulbSDF(rot * p);
}

// Function 1445
float getDistance(vec4 point){
    	return sdSphere(point, 25.);
}

// Function 1446
float sdf_modern_nail(vec2 uv, vec2 top, vec2 size)
{
    const float head_flat_frac = .025;
    const float head_round_frac = .05;
    const float body_thickness = .5;

    float h = clamp((top.y - uv.y) / size.y, 0., 1.);
    float w = (h < head_flat_frac) ? 1. :
        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :
    	h > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;
    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));
}

// Function 1447
float dist(Grid g, vec2 p)
{
    vec2 d = mod(p,g.inter);
    d = min(d, g.inter-d);
    return min(d.x, d.y);
    
    //bvec2 l = greaterThan(mod(p,g.inter*2.),vec2(g.inter));
    //return all(l)||all(not(l)) ? 1. : 0.;
}

// Function 1448
float heightMap(in vec2 p) { 
    
    p *= 3.;
    
	// Hexagonal coordinates.
    vec2 h = vec2(p.x + p.y*.57735, p.y*1.1547);
    
    // Closest hexagon center.
    vec2 f = fract(h); h -= f;
    float c = fract((h.x + h.y)/3.);
    h =  c<.666 ?   c<.333 ?  h  :  h + 1.  :  h  + step(f.yx, f); 

    p -= vec2(h.x - h.y*.5, h.y*.8660254);
    
    // Rotate (flip, in this case) random hexagons. Otherwise, you'd have a bunch of circles only.
    // Note that "h" is unique to each hexagon, so we can use it as the random ID.
    c = fract(cos(dot(h, vec2(41, 289)))*43758.5453); // Reusing "c."
    p -= p*step(c, .5)*2.; // Equivalent to: if (c<.5) p *= -1.;
    
    // Minimum squared distance to neighbors. Taking the square root after comparing, for speed.
    // Three partitions need to be checked due to the flipping process.
    p -= vec2(-1, 0);
    c = dot(p, p); // Reusing "c" again.
    p -= vec2(1.5, .8660254);
    c = min(c, dot(p, p));
    p -= vec2(0, -1.73205);
    c = min(c, dot(p, p));
    
    return sqrt(c);
    
    // Wrapping the values - or folding the values over (abs(c-.5)*2., cos(c*6.283*1.), etc) - to produce 
    // the nicely lined-up, wavy patterns. I"m perfoming this step in the "map" function. It has to do 
    // with coloring and so forth.
    //c = sqrt(c);
    //c = cos(c*6.283*1.) + cos(c*6.283*2.);
    //return (clamp(c*.6+.5, 0., 1.));

}

// Function 1449
vec4 mapRaw(vec3 pos)
{
    vec4 res = vec4(1000, 0, 0, 0);
    
    union(res, -box(pos - vec3(0,2,0), vec3(6,2,10)));
    sect(res, -box(pos - vec3(16,2,0), vec3(6,2,10)));
    sect(res, -box(pos - vec3(8,1,-5), vec3(3,1,1)));
    sect(res, -box(pos - vec3(8,1,5), vec3(3,1,1)));
    
    union(res, sphere(pos - vec3(0,1,-4), 1.0));
    union(res, box(pos - vec3(-3,1,4), vec3(1,1,1)));
    union(res, box(pos - vec3(-3,1,7), vec3(3,1,3)));
    
    vec3 steps = pos - vec3(-3,0.9,1.0);
    float offset = floor(steps.z/1.0+0.5)*1.0;
    vec4 rstep = box(vec3(steps.x, steps.y - 0.5*offset - 0.1*(steps.z-offset), steps.z-offset), vec3(1,0.1,0.2));
    
    steps.z += 0.5;
    offset = floor(steps.z/1.0+0.5)*1.0;
    union(rstep, box(steps - vec3(0, 0.5*(offset-0.5) + 0.0*(steps.z-offset), offset), vec3(1,0.1,0.2)));
    
    steps.z -= 0.5;
    sect(rstep, box(steps, vec3(1,1,2)));
    
    rstep.x *= 0.9;
    union(res, rstep);
    
    if (loaded)
    {
        if (warpColor != 2)
        {
            vec3 delta = (pos - p1.pos) * warp1;
            delta.z *= 2.0;
            vec4 warpRes = vec4(length(vec2(delta.x, length(delta.yz)-0.9))-0.1, vec3(0.0));
         	union(res, warpRes);
            //union();
            if (length(delta) < 1.0)
            {
                res = warpRes;
                if (delta.x < 0.0)
                {
            		delta.z/=2.0;
                    mappos = (warp2 * delta) + p2.pos;
                    mapdir = warp2 * mapdir * warp1;
                    warpColor = 1;
                }
            }
            //union(res, sphere(delta, 1.0));
        }
        if (warpColor != 1)
        {
            vec3 delta = (pos - p2.pos) * warp2;
            delta.z *= 2.0;
            vec4 warpRes = vec4(length(vec2(delta.x, length(delta.yz)-0.9))-0.1, vec3(0.0));
            union(res, warpRes);
            if (length(delta) < 1.0)
            {
                res = warpRes;
                if (length(delta) < 1.0 && delta.x > 0.0)
                {
            		delta.z/=2.0;
                    mappos = (warp1 * delta) + p1.pos;
                    mapdir = warp1 * mapdir * warp2;
                    warpColor = 2;
                }
            }
            //union(res, sphere(delta, 1.0));
        }
        //union(res, sphere(pos - p1.pos, 0.1));
        //union(res, sphere(pos - p2.pos, 1.0));
    }
    
    return res;
}

// Function 1450
float drawScene(vec3 p)
{	int id;
    return drawScene(p,id);
}

// Function 1451
geometry map(vec3 p) {
    
    vec3 bp = p;
    
    p.z = mod(p.z, 30.) - 65.;

    pMirrorOctant(p.zy, vec2(110., 15.));        
	pMirrorOctant(p.xy, vec2(20.,  12.));        
    
    vec3 floor_p = p;

    pR(p.xz, -1.5);
        
    p.x += 1.5;
   
    float pM = pModPolar(p.zx, 4.);

    pMirrorOctant(p.xy, vec2(12.1, 8.)) ;
    pMirrorOctant(p.xz, vec2(12.5, 64.));
    
    p.x += 10.;
    p.yx += 3.;

    geometry obj;
    
    obj = DE(p);
    obj.material = vec2(1., 0.);

    return obj;
}

// Function 1452
vec2 map(vec3 p) {
	p.y -= 6.5;
	p = Rotation * p;

	return vec2(udRoundBox(p, vec3(CubeLength), 0.5), MAT_ICE_CUBE);
}

// Function 1453
float distCylinderXZ(vec3 p, vec3 c)
{
    return length(p.xz - c.xy) - c.z;
}

// Function 1454
float map( in vec3 p )
{
	float d = p.y;
	vec3 pp = p;
	ill = 0.;
	
	//mirrors
	p = abs(p);
	p = rotate(vec3(-1.,0.,0.),40.)*p;
	p = abs(p);
	p = rotate(vec3(0.,1.,0.),45.)*p;
	p = abs(p);
	
	//make a branch of cubes
	for(int i=0; i<15; i++)
	{
		p -= vec3(.25);
		p = rotate( normalize( vec3(.5, .25, 1.0 ) ), 20.+pp.x+pp.y+pp.z )*p;
		
		
		float size = cos(float(i)/20.*PI*2.-impulsTime);
		float dbox = box( p, vec3( (1.1-float(i)/20.)*.25 + pow(size*.4+.4,10.) ) );
	
		if( dbox < d)
		{
			d = dbox;
			ill = pow(size*.5+.5, 10.);
		}
	
	}
	//add another one iteration with a sphere
	p -= vec3(.25);
	p = rotate( normalize( vec3(.5, .25, 1.0 ) ), 20.+pp.x+pp.y+pp.z )*p;
	d = min(d, sphere(p,.25) );
	
	return d;
}

// Function 1455
float sceneSDF(vec3 p, out bool isWater) 
{
    vec3 biome = mapBiome(p);
    isWater = false;
    p = planetRotation * p;
    vec3 surfaceLocation = normalize(p);
    float freq = 1.5;
    float mult = 1. - biome.r * .075 + biome.b * .045;
    float dullness = .2 + biome.r * .2;
    
    float elevation = calcInitialDisplacement(p * freq, dullness) * mult;
    elevation *= planetRadius;
    
    if (elevation < .7) 
    {
        elevation = .7 - pow(.7 - elevation, .25) * fbm1(surfaceLocation * 4. + iTime / 4.) * .2;
        isWater = true;
    }
    
    return (length(p) - elevation) * .8;
}

// Function 1456
float BuildingsDistance(in vec3 position){
  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),
	         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}

// Function 1457
float smoothCylinderDistance(vec3 point, float height, float radius, float smoothing) {
    return cylinderDistance(point, height - smoothing, radius - smoothing) - smoothing;
}

// Function 1458
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){
   
    const vec2 e = vec2(0.002, 1);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.399, 0.687, 0.214)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.399, 0.687, 0.214)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
    
}

// Function 1459
float map (vec3 p)
{
	float a = box(p,vec3(0.0),vec3(1000));
	float b = sphere(p,vec3(0.0),300.0);
	return max(-b,a);
}

// Function 1460
float map(vec3 pos, int processedMaterial
){float o = 0. //0. if first operation is a SUB(), 1e10 otherwise
 ;maxGISize = 0.
 ;rayObj = 0
 ;vec4 w = vec4(pos,1)//worldSpace
 ;beginMaterial(0)
 ;SUB(box(w,vec3(0,0,0),vec3(10,2.5,10)))
 ;ADD(cylinderY(w,vec3(-6,0,-2.),0.1,3.))
 ;ADD(cylinderY(w,vec3(5,0,-2.),0.1,3.))
 ;endMaterial()
     
     
 ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color
 ;//ADD(box(c,vec3(0,0,0),vec3(1)))
 ;//c.xz = abs(c.xz)
 ;for(int i=0;i<4;i++
 ){beginMaterial(i)
  ;ADD(sphere(c,vec3(0,0,0),1.))
  ;endMaterial()
  ;c=abs(c)
  ;c=beginObj(oCubeChil,c);}
 ;vec4 blackHoleSpace = beginObj(oBlackHole,w)
 ;beginMaterial(8)
 ;ADD(sphere(blackHoleSpace,vec3(0,0,0),.5))
 ;endMaterial()
 ;vec4 tunnelSpace = beginObj(oTunnel,w)
 ;beginMaterial(3)
 ;ADD(box(tunnelSpace,vec3(0,.5,0),vec3(.2,.1,1.5)))
 ;ADD(box(tunnelSpace,vec3(0,-.5,0),vec3(.2,.1,1.5)))
 ;endMaterial()
 ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)
 ;beginMaterial(4)
 ;ADD(box(tunnelDoorSpace,vec3(0,0,1.4),vec3(.2,.4,0.1)))
 ;ADD(box(tunnelDoorSpace,vec3(0,0,-1.4),vec3(.2,.4,0.1)))
 ;endMaterial()
 ;vec4 trainSpace = beginObj(oTrain,w)
 ;beginMaterial(7)
 ;ADD(box(trainSpace,vec3(0,0,-.8),vec3(.1,.1,.18)))
 ;ADD(box(trainSpace,vec3(0,0,-.4),vec3(.1,.1,.18)))
 ;ADD(box(trainSpace,vec3(0,0,0),vec3(.1,.1,.18)))
 ;ADD(box(trainSpace,vec3(0,0,.4),vec3(.1,.1,.18)))
 ;ADD(box(trainSpace,vec3(0,0,.68),vec3(.1,.1,.06)))
 ;ADD(cylinderZ(trainSpace,vec3(0,.04,.8),.07,.18))
 ;endObj()
 ;endMaterial()
 ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))
 ;float tmpGauss = length(blackHoleSpace.xz)-1.5
 ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))
 ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)
 ;vma+=(1.-vma)*temp*AccretionDisk
 ;for(int L=0; L<3; L++
 ){
  ;ADD(sphere(w,oliPos[L]
              //o_lights[L].b
              ,0.001))
  ;
  ;vec3 relPos = oliPos[L]-pos//o_lights[L].b
  ;oliHal[L]//o_lights[L].haloResult 
      += o*(0.02/(dot(relPos,relPos)+0.01))
  ;}
 ;return o;}

// Function 1461
float scene(vec3 p)
{
    float dl = dlight(p)
        , ds = distance(p, vec3(-1,.7,0))-.7
        , dp = p.y;
    return min(dl,min(ds, dp));
}

// Function 1462
float map(vec3 point)
{
    if(MODE == 0)
    {
        // instancing
        // transform the space into repeating coordinate system
    	vec3 q = fract(point) * 2.0 - RANGE * (1.0 - smoothstep(0.0, iResolution.x, iMouse.x));
        // length of point minus radius
        return length(q) - RANGE * (1.0 - smoothstep(0.0, iResolution.y, iMouse.y));
    }
    // Basic sphere
    else
    {
        return length(point) - 5.0 * smoothstep(0.0, iResolution.x, iMouse.x);
    }
}

// Function 1463
float sceneSDF(vec3 p) {
    float sdf = MAX_DIST;
    float a = max(sphereSDF(p-vec3(2.0,0.0,0.0),1.0),boxSDF((p-vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.0));
    float b = coneSDF(p-vec3(2.0,0.0,0.0),1.4,0.6);;
    float c = morph(b,a,(1.0+sin(iTime))*0.5);
    sdf = min(sdf,c);
    a = min(sdf,boxSDF(rotateZ(p.y*cos(iTime))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));
    b = min(sdf,boxSDF(rotateY(p.y+sin(iTime*2.0))*(p+vec3(2.0,0.0,0.0)),vec3(1.4,1.4,1.4),0.2));
    c = morph(a,b,(1.0+sin(iTime))*0.5);
    sdf = min(sdf,c);
    a = boxSDF(p,vec3(1.4,1.4,1.4),0.0);
    b = cylSDF(p,1.4,0.6);
    c = morph(a,b,(1.0+sin(iTime))*0.5);
    sdf = min(sdf,c);
    return sdf;
}

// Function 1464
float tut_map(vec3 p) {
    float d = distance(p, vec3(-1, 0, -5)) - 1.;
    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);
    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);
    d = min(d, p.y + 1.);
    return d;
}

// Function 1465
vec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )
{
	vec3 vResultColor = vec3(0.0);
            
	SceneResult firstTraceResult;
    
    float fStartDist = 0.0f;
    float fMaxDist = kMaxTraceDist;
    
    vec3 vRemaining = vec3(1.0);
    
	for( int iPassIndex=0; iPassIndex < 2; iPassIndex++ )
    {
    	SceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );

        if ( iPassIndex == 0 )
        {
            firstTraceResult = traceResult;
        }
        
        vec3 vColor = vec3(0);
        vec3 vReflectAmount = vec3(0);
        
		if( traceResult.iObjectId < 0 )
		{
            bool bDrawSun = (iPassIndex == 0);
            vColor = Env_GetSkyColor( vRayOrigin, vRayDir, bDrawSun ).rgb;
            float fDist = abs(length(vRayDir.xz) * 20.0 / vRayDir.y);
			vColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, fDist );
        }
        else
        {
            
            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );
            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );
                
            // calculate reflectance (Fresnel)
			vReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fGloss );
			
			vColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); 
            
            vec3 vReflectRayOrigin = surfaceInfo.vPos;
                        
            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );

            
            {
                float alpha2 = SpecParamFromGloss(surfaceInfo.fGloss);
                
                vec2 vRand = hash23( vRayOrigin + vRayDir + iTime );

                vec3 N = surfaceInfo.vBumpNormal;
                vec3 V = -vRayDir;
                vec3 H = ImportanceSampleGGX( vRand, N, alpha2 );        

				vReflectRayDir = reflect( -V, H );                
            }
			
            
            
            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); 

            vColor += surfaceLighting.vSpecular * vReflectAmount;            

			vColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );
			vColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );
            
            vRayOrigin = vReflectRayOrigin;
            vRayDir = vReflectRayDir;
        }
        
        vResultColor += vColor * vRemaining;
        vRemaining *= vReflectAmount;        
    }
 
    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );
}

// Function 1466
f1 handSdf(f3 p, f1 thickAdded, f4 r1, f1 r2)
{
	p.z-=9.;
    f1 pl = (palm(p) - thickAdded) * .7;
    f1 fing = fingers(p + f3(0, .4, 0), r1, r2);
    
    pl = smin(pl, fing, 1.);
    
    return pl;
}

// Function 1467
float remap01 (float a, float b, float t) {
    return (t-a) / (b-a);
}

// Function 1468
float sdf_amount(in vec2 uv, in vec4 params) {
    vec2 ball_loc = sin(params.xy * 0.4 * iTime + params.z);
    return length(ball_loc - uv) - params.w - 0.05;
}

// Function 1469
float sphereSDF(vec3 pos)
{
    // Repeating pattern of spheres
    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);
    turned = 6.0*round(turned/6.0);
    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;
    /*pos.x -= 3.*round(pos.x/3.);
    if(pos.y>-1.5)
        pos.y -= 3.*round(pos.y/3.);
	*/
    pos.xy -= turned.xy;
    return length(pos-vec3(0.,0.,1.))-1.;
}

// Function 1470
bool minDist(vec3 ro, vec3 rd, out HitInfo hit)
{
    vec2 res = vec2(1.);
    hit.t = MAX_DIST;
    hit.color=vec4(bgcol.rgb,0.);
    bool result = false;
    
    vec4 verts_local [4]=verts;
    verts_local[0].xyz+=vec3(pos_x,pos_y,pos_z);
    verts_local[1].xyz+=vec3(pos_x,pos_y,pos_z);
    verts_local[2].xyz+=vec3(pos_x,pos_y,pos_z);
    verts_local[3].xyz+=vec3(pos_x,pos_y,pos_z);

    GroundIntersectMin(ro, rd, result, hit);
    
    vec3 box=vec3(pos_x,pos_y,pos_z);
    float angle=0.5;
    
    ParallelogramIntersectMin(ro, rd, verts_local[1].xyz, verts_local[2].xyz, verts_local[0].xyz, result, hit,OBJ_WALL);
    float refresh=texelFetch(iChannel0,ivec2(iResolution.xy-1.),0).a;
    if(refresh>=-1.5)BoxIntersectMin(ro, rd,vec3(.75),box,angle,result, hit, false);
    BoxIntersectMin(ro, rd,vec3(.75),box,angle,result, hit, true);
    
    return result;
}

// Function 1471
float remap(float a, float b, float c, float d, float t){
    return remap01(a, b, t) * (d-c) + c;
}

// Function 1472
float CurvatureMap( vec2 p, float r ){
	const float q = 4.0; // sample quality
	float s = r/q;
	float H = HeightMap(p)*2.0;
	float v = 0.0;
	vec2 o;
	for( o.x = -q; o.x < q; o.x++ )
	for( o.y = -q; o.y < q; o.y++ ){
		float c = Curve(p, o*s);
		v += (H + c) * ((r-length(o*s)) / r);
	}
	return v/(q*q);
}

// Function 1473
void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){
    
    
    //float a = mod(float(iFrame), 8.)*3.14159/4.;// + rot2(a)*vec2(0, .5)
    // UV coordinates.
    //
    // For whatever reason (which I'd love expained), the Y coordinates flip each
    // frame if I don't negate the coordinates here -- I'm assuming this is internal, 
    // a VFlip thing, or there's something I'm missing. If there are experts out there, 
    // any feedback would be welcome. :)
    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));
    
    gSc = 1.;
 
    // Pixel storage.
    vec4 col;
   
    // Initial conditions -- Performed upon initiation.
    if(abs(tx(uv).w - iResolution.y)>.001){
    
        // Initial conditions: Fill each channel in each cell with some random values.
        col = vec4(hash21(uv), hash21(uv + .17), hash21(uv + .23), 1.);
        col.w = iResolution.y;
    }
    else {
    
        // A very rough BelousovZhabotinsky reaction approximation -- Feel free to look
        // up the process in detail, but it's similar to many reaction diffusion like
        // examples: Start off with an initial solution in the form of noise in one or 
        // some of the channels, use filters to blur it over time to similute dispersion,
        // then mix the result with the previous frame. In this case, we can simulate 
        // non-equilibrium by sprinkling in extra noise for volatility... As mentioned,
        // there are others on the net and on Shadertoy who can give you more detail, but
        // that's the general gist of it.
        
        // Thinking a little outside the box, it's possible to use a much cheaper 
        // radial boundary blur with a larger radius to mickick a larger block blur. 
        // It doesn't work in all situations, but it works well enough here.
        vec4 val = bTxCir(uv, 5.); // 12 Taps.
        val = mix(val, tx(uv), 1./25.); // Adding the center pixel.
        //vec4 val = bTx(uv, 7); // Box blur: 49 taps -- Requires rescaling.
        
        //#if 0
        // Alternate, simpler equation.
        //col = clamp(tx(uv) + .08*(val.zxyw - val.yzxw), 0., 1.);
        //#else
        float reactionRate = val.x*val.y*val.z; // Self explanitory.
        //float reactionRate = smoothstep(0., 1., val.x*val.y*val.z); 

        // Producing the new value: For an explanation, you can look up the chemical
        // reaction it pertains to and the mathematical translation which is pretty
        // interesting. From a visual perspective, however, it's just a cute calculus 
        // based equation that produces a cool pattern over time.
        vec4 res = val - reactionRate + val*(val.yzxw - val.zxyw);
        //vec4 params = vec4(1, 1, 1, 0);//
        //vec4 res = val - reactionRate + val*(params*val.yzxw - params.zxyw*val.zxyw);
        
        
 

        // Adding some volatile noise to the system. 
        vec3 t = vec3(1.01, 1.07, 1.03)*fract(iTime);
        vec4 ns = vec4(hash21(uv + .6 + t.x), hash21(uv + .2 + t.y), hash21(uv + .7 + t.z), 0);
        
        // Mixing the new value and noise with the old value. 
        col = mix(tx(uv), res*(.9 + ns*.3), .2);
        //#endif
        
 
        // Using the fourth channel to store resolution.
        col.w = iResolution.y;
    
    }
    
    // Recording the new value and clamping it to a certain range.
    fragColor = vec4(clamp(col.xyz, -1., 1.), iResolution.y);
}

// Function 1474
float bsdfPdf(const in vec3 wi, const in vec3 wo, const in vec3 X, const in vec3 Y, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    float pdfDiffuse = pdfLambertianReflection(wi, wo, interaction.normal);
    float pdfMicrofacet = pdfMicrofacetAniso(wi, wo, X, Y, interaction, material);
    float pdfClearCoat = pdfClearCoat(wi, wo, interaction, material);;
    return (pdfDiffuse + pdfMicrofacet + pdfClearCoat)/3.;
}

// Function 1475
Hit intersect_scene(vec3 origin, vec3 direction) {

  // sphere is at origin with a radius of 1
  // For a better explanation of this:
  // https://www.geogebra.org/3d/uxv5kfum
  vec3 ray_to_sphere = origin;
  float projection = dot(direction, -origin);
  float disk_radius =
      1. + projection * projection - dot(ray_to_sphere, ray_to_sphere);
  if (disk_radius > 0.) {
    float interval = min(projection + disk_radius, projection - disk_radius);
    vec3 sphere_p = origin + direction * interval;
    return Hit(true, sphere_p, normalize(sphere_p));
  }
  return Hit(false, vec3(0.), vec3(0.));
}

// Function 1476
vec2 polarMap(vec2 uv, float inner) {

    uv = vec2(0.5) - uv;
    
    float px = 1.0 - fract(atan(uv.y, uv.x) / M_TWO_PI + 0.25);
    float py = (sqrt(uv.x * uv.x + uv.y * uv.y) * (1.0 + inner * 2.0) - inner) * 2.0;
    
    return vec2(px, py);
}

// Function 1477
float trn_detailmapLod( vec3 pos, float scale )
{
    float lod = log2( scale / 0.001 );
    return 1. + .10 * texturenoiseLod( pos / .01, lod - 3.322 ).x +
        .12 * texturenoiseLod( pos / .003, lod - 1.585 ).x +
        .15 * texturenoiseLod( pos / .001, lod ).x +
        .17 * texturenoiseLod( pos / .0003, lod + 1.585 ).x;
}

// Function 1478
int IntersectScene(Ray ray, int ignoreObjId)
{
	float t_unused;
	Object obj_unused;
	return IntersectScene(ray, ignoreObjId, t_unused, obj_unused);
}

// Function 1479
vec3 mapp(vec3 p) {
  for (int i = 0; i < 8; i++) {
    vec3 off = spherecords(rand3(2.4*cos(float(i))).xy);
    vec3 rot = rand3(5.1*float(i));
    vec3 ax = spherecords(rot.xy);
    off = erot(off, ax, iTime*0.1);
    float offscale = 1. + sin(iTime*0.5);
    p+=off*offscale;
    p -= min(dot(off,p),0.)*off*2.; 
    p-=off*offscale;
  }
  return p;
}

// Function 1480
vec3 cmap(float t) {
    //vec3 speed = vec3(.3, .562*t, .55) * 3. * 3.141;
    //vec3 mult  = vec3(1.);
    //vec3 bias  = vec3(-.1, .1, .9);
    //vec3 shft  = vec3(.7, .35, .2) * 6.282;
    //vec3 c = cos(speed*t+shft) * mult + bias;
    
    t = (t - .1) / .9;
    vec3 cc[6];
    cc[0] = vec3(0.980, 0.952, 0.819);
    cc[1] = vec3(0.849, 0.658, 0.249);
    cc[2] = vec3(0.933, 0.401, 0.149);
    cc[5] = vec3(0.656, 0.849, 0.933);
    cc[4] = vec3(0.590, 0.684, 0.997);
    cc[3] = vec3(0.411, 0.476, 0.591);
    int i = int(t*6.);
    int j = int(t*6.+1.) % 6;
    //int h = int(t*6.-1.) % 6;
    //if ((t*6.-1.) < 0.) h = 6;
    vec3 c = vec3(0.);
    float tt = 1.-fract(t*6.);
    //c  = mix(cc[h], cc[i], fract(t*6.)) * (1.-tt); 
    c += mix(cc[i], cc[j], fract(t*6.));// * tt;
    
    return c;
}

// Function 1481
bool intersectSceneLoop(Ray R, float minDist, float maxDist, inout Surfel surfel) {
    const int maxIterations = 75;
    
    // Making this too large causes bad results because we use
    // screen-space derivatives for normal estimation.
    
    const float closeEnough = 0.0011;
    const float minStep = closeEnough;
    float closest = inf;
    float tForClosest = 0.0;
    float t = minDist;
    
    for (int i = 0; i < maxIterations; ++i) {
        surfel.position = R.direction * t + R.origin;

        float dt = inf;
        scene(surfel.position, dt);
        if (dt < closest) {            
	        closest = dt;
            tForClosest = t;            
        }
        
        t += max(dt, minStep);
        if (dt < closeEnough) {
            return true;
        } else if (t > maxDist) {
            return false;
        }
    }    

    // "Screen space" optimization from Mercury for shading a reasonable
    // point in the event of failure due to iteration count
    if (closest < closeEnough * 5.0) {
        surfel.position = R.direction * tForClosest + R.origin;
        return true;
    }
    
    return false;
}

// Function 1482
bool raySceneIntersection(in Ray ray, in Scene scene, inout Intersection inter){
    for(uint i = 0u ; i < scene.nbSpheres ; ++i){
    	raySphereIntersection(ray, scene.spheres[i], inter, int(i));
    }
    for(uint i = 0u ; i < scene.nbTriangles ; ++i){
    	rayTriangleIntersection(ray, scene.triangles[i], inter, int(i));
    }
    return inter.hit;
}

// Function 1483
float map(vec3 p)
{    
    // Sphere radius
    float sphereSize = 0.4;
    
    // Transform coordinate space so spheres repeat
    vec3 q = fract(p * 1.5) * 2.5 - 1.2;
    
     int tx = int(q.x);
    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; 
	fft *= 2.5;
    // Signed distance of sphere
    float s = sphere(q, sphereSize);
    
    float d = 0.4 * (sin(q.x*6.*fft) * sin(q.y*5.*fft) * sin(q.z*4.*fft) );
    
    float rot = iTime;    
    p *= vec3(cos(rot),-sin(rot),sin(rot));
    //return s +wave;
    return s+d;
}

// Function 1484
float sphereSdf(vec3 p, float r) 
{
    p.z -= r;
    return length(p) - r;
}

// Function 1485
float sceneSDF(vec3 samplePoint) {
    
	float plane = planeSdf( samplePoint );
    float sphere = sphereSdf( samplePoint, .75 );
    float combined = unionSDF( sphere, plane );
    return combined;
}

// Function 1486
float estimateDist_dn(in float y, vec2 f)
{
    return abs(y - f.x)/length(vec2(1.0, f.y));
}

// Function 1487
float UnionSDF(float distA, float distB) {
    return min(distA, distB);
}

// Function 1488
float draw_scene(vec3 p)
	{
	float tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);
	float tunnel1_p=2.0;
	float tunnel1_w=tunnel1_p*0.225;
	float tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;	// tunnel1
	float tunnel2_p=2.0;
	float tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);
	float tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;	// tunnel2
	float hole1_p=1.0;
	float hole1_w=hole1_p*0.5;
	float hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;	// hole1
	float hole2_p=0.25;
	float hole2_w=hole2_p*0.375;
	float hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;	// hole2
	float hole3_p=0.5;
	float hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);
	float hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;	// hole3
	float tube_m=0.075*sin(PI*p.z*1.0);
	float tube_p=0.5+tube_m;
	float tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);
	float tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;			// tube
	float bubble_p=0.05;
	float bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);
	float bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;	// bubble
	return max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);
	}

// Function 1489
void BarrelDistortion( inout vec3 ray, float degree )
{
	// would love to get some disperson on this, but that means more rays
	ray.z /= degree;
	ray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye
	ray.z = degree*sqrt(ray.z);
}

// Function 1490
float cloud_map(vec3 pt)
{
    // move the clouds over time
	vec3 q = pt - vec3(1.0, 0.1, 0.0) * iTime;
	float f;
    f =  0.50000 * noise(q); q = q * 2.02;
    f += 0.25000 * noise(q); q = q * 2.03;
    f += 0.12500 * noise(q); q = q * 2.01;
    f += 0.06250 * noise(q); q = q * 2.02;
    f += 0.03125 * noise(q);
	return clamp(1.5 - pt.y - 2.0 + (1.75 * f), 0.0, 1.0);
}

// Function 1491
float stemSDF(in vec3 iPoint, vec2 iPosition, in float iRadius, in float iStemHeight) {
	
    // The stem is a capped cylinder with a varying radius    
    float d = length(iPoint.xz - iPosition) - iRadius*(1.0 + 0.05*cos(2.0*iPoint.y + iPoint.z));
    d = max(d, -iStemHeight + abs(iPoint.y));
    return d;
    
}

// Function 1492
float scenerails(vec3 p)
{
    p.y -=1.9;
    vec3 pd = deform_torus(p);
	//float tor0 = sdTorus(pd,vec2(8.5,.1));
	float tor1 = sdTorus(pd,vec2(9.5,.1));
	float tor2 = sdTorus(pd,vec2(10.5,.1));
	//float tor3 = sdTorus(pd,vec2(11.5,.1));
    //float tors = opU(opU(opU(tor0,tor1),tor2),tor3);
    float tors = opU(tor1,tor2);
    return tors;
}

// Function 1493
float DistanceFunc_ (in vec3 p)
{
    ivec3 cellPos = ivec3(floor(p));
    
    vec4 A = vec4(snoise(vec3(cellPos+ivec3(0,0,0))),
              snoise(vec3(cellPos+ivec3(1,0,0))),
	 		  snoise(vec3(cellPos+ivec3(0,1,0))),
	 		  snoise(vec3(cellPos+ivec3(1,1,0))));

    vec4 B = vec4(snoise(vec3(cellPos+ivec3(0,0,1))),
              snoise(vec3(cellPos+ivec3(1,0,1))),
	 		  snoise(vec3(cellPos+ivec3(0,1,1))),
	 		  snoise(vec3(cellPos+ivec3(1,1,1))));

    return CubicLERP(A,B, p - vec3(cellPos));
}

// Function 1494
Obj getDistance(vec3 p) {	
       
    float height = fbm(vec2(p.x, p.z) + (iTime/3.), 2);
    float waterDist = p.y - height;
    
    Obj obj = Obj(WATER, waterDist, p);
    
    return obj;
}

// Function 1495
float wireDistance(vec3 p) {
  float h = -abs(cos(p.x*3.14159/2.0))*0.05-0.07;
  float d = 1.0;
  for (int i=0;i<3;i++) {
    h+= sin(p.x+float(i)*17.49)*0.03;
  d = min(sdCapsule(postPos(p), vec3(-2.0, h+float(i)*0.1, .0), vec3(2.0, h+float(i)*0.1, .0), 0.002), d);
  }
  return d;
}

// Function 1496
float sceneSdf1(vec3 p)
{
    float horosphereEuclideanRadius = 0.9;
    if(!apply)
    {
        // The horosphere as a plane will be at the height of
        // its north pole inverted in the unit sphere.
        float height = 1.0 / ( 2.0 * horosphereEuclideanRadius );
        return planeSdf(p, height);
    }

    float plane_dist = planeSdf(p);
    float sphere_dist = sphereSdf(p, horosphereEuclideanRadius);
    return min(plane_dist, sphere_dist);
}

// Function 1497
float map(vec3 p)
{
    
    int tx = int(p.x);
    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; 
	fft *= 3.3;
    
    float radius = 0.4;
    float d = .11 * (sin(p.x*6.4*fft) * sin(p.y*6.*fft) * sin(p.z*8.*fft) );
    return sphere(p, radius + d);
}

// Function 1498
float map_flame_s(vec3 pos)
{
   vec3 pos0 = pos;    
    
   vec3 q = pos*0.6;
   q*= vec3(1., 1.5, 1.);
   q+= vec3(ft, 0., 0.);
   float dn = 0.5*(dnf - dnx*pos.x);
   pos.x+= dn*noise(q + vec3(12., 3. + ft, 16.)) - dn/2.;
   pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;
   pos.z+= dn*noise(q + vec3(8., 22., 9.)) - dn/2.;
   
   pos.x = abs(pos.x);
    
   float c = length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) - r3*f2;
   c = min(c, length(pos - vec3(0., h*2. + r2, 0.)) - r3*1.35);
   c = max(c, sdCylinder(pos.yxz - vec3(h*2. + r2, 0., 0.), vec2(0.58 + 0.32*cos(pos.x*pi/e), e)));

   c = mix (c, 0.6*c -0.3*smoothstep(0.7, 0.3, length(pos0.yz - vec2(h*2. + r2, 0.))), smoothstep(e - r2 - l - 1.2, e - r2 - l, -pos0.x)); 
    
   return c;
}

// Function 1499
vec3 simulate_lightmap_distortion(vec3 surface_point)
{
    surface_point = floor(surface_point);
    surface_point *= 1./LIGHTMAP_SCALE;
    vec3 f = fract(surface_point + .5);
    return (surface_point + f - smoothen(f)) * LIGHTMAP_SCALE;
}

// Function 1500
float starSegmentSDF( vec3 point, vec3 a, float thickness ) {
    float h = clamp( dot( point - a, - a ) / dot( a, a ), 0., 1. );
    vec3 q = a - a * h;
    //h = pow( h, 0.7 ) * .8;      
    return length( point - q ) - thickness * h;
}

// Function 1501
float distToLineSquare(vec2 p1, vec2 p2, vec2 p, float thickness)
{
	p -= p1;
	vec2 lineVector = p2-p1;
		
	float angle = -atan(lineVector.y,lineVector.x);
	p = rotate(p,angle);
	
	float dx = 0.0;
	if(p.x<0.0)
		dx = abs(p.x);
	else if(p.x>length(lineVector))
		dx = abs(p.x) - length(lineVector);
		
	return thickness/(dx+abs(p.y));
}

// Function 1502
float	scene(vec3 p)
{  
    float	var;
    float	mind = 1e5;
    
    // overall object placement
    p.z += 25.;
    rotate(p.xz, 1.57-.5*iTime );
    rotate(p.yz, 1.57-.5*iTime );
    
    var = atan(p.x,p.y);
    vec2 q = vec2( ( length(p.xy) )-9.,p.z);
    float ttwists=0.75;
    rotate(q, var*ttwists+iTime*0.4);	
    
    vec2 oq = q ;
    
    q = abs(q)-vec2(3.,3.)-sin(q)*7.; // add some twists

    float twist= 3.3;	// twists the "blue" strands
    float s= iTime*1.;   // add "movement speed" to the "blue" strands 
    if (oq.x < q.x && oq.y > q.y){
    	rotate(q, ( (var*twist)+s)*3.14+s);
    }else{
        rotate(q, ( 0.28-(var*twist)+s)*3.14+s);
    }
    
    float	oldvar = var;
    ret_col = 1.-vec3(.350, .2, .3);
    
    q=q*0.2;

    mind = length(q)+.5+1.05*(length(fract(q*.5*(3.+3.*sin(oldvar*1. - iTime*1.)) )-.5)-1.215);
    // only the coloring:   
    h -= vec3(-3.20,.20,1.0)*vec3(1.)*.0025/(.051+(mind-sin(oldvar*1. - iTime*2. + 3.14)*.125 )*(mind-sin(oldvar*1. - iTime*2. + 3.14)*.125 ) );
    h -= vec3(1.20,-.50,-.50)*vec3(1.)*.025/(.501+(mind-sin(oldvar*1. - iTime*2.)*.5 )*(mind-sin(oldvar*1. - iTime*2.)*.5 ) );
    h += vec3(.25, .4, .5)*.0025/(.021+mind*mind);

    // add some music feedback
    float f= texture(iChannel0, vec2(8. * 0.18, 0.0)).x * 0.3 + 0.05;
    h+= f*.1 - 0.005;
    
    return (mind);
}

// Function 1503
vec3 visualize_dist(vec2 uv, float dist)
{
	const float scale = 0.3;
	vec3 col = vec3(dist, 0.0, -dist) * scale;

	float line = float(abs(dist) < 0.01);

	return col + vec3(0.0, line * 0.5, 0.0);
}

// Function 1504
vec3 envMap(vec3 p){
    
    p *= 3.;
    p.y += iTime;
    
    float n3D2 = n3D(p*2.);
   
    // A bit of fBm.
    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;
    c = smoothstep(.4, 1., c); // Putting in some dark space.
    
    p = vec3(c, c*c, c*c*c); // Redish tinge.
    
    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.

}

// Function 1505
vec2 map(in vec3 pos) {
    vec2 res = vec2( 1e10, 0.0 );
 
         if (gShape1 == DISK)   res = opU( res, vec2( sdCylinder( pos, c0, c0+.001*n0, r0  ) - ep0, ID_SHAPE_1 ) );
    else if (gShape1 == CAPS)   res = opU( res, vec2( sdCapsule( pos, seg00, seg01, ep0  ), ID_SHAPE_1 ) );
    else if (gShape1 == SPHERE) res = opU( res, vec2( length(pos-c0)-r0, ID_SHAPE_1 ) ); 
    else if (gShape1 == POLY)   res = opU( res, vec2( udPoly(pos, poly0)-ep0, ID_SHAPE_1 ) ); 

         if (gShape2 == DISK)   res = opU( res, vec2( sdCylinder( pos, c1, c1+.001*n1, r1  ) - ep1, ID_SHAPE_2 ) );
    else if (gShape2 == CAPS)   res = opU( res, vec2( sdCapsule( pos, seg10, seg11, ep1  ), ID_SHAPE_2 ) );
    else if (gShape2 == SPHERE) res = opU( res, vec2( length(pos-c1)-r1, ID_SHAPE_2 ) );
    else if (gShape2 == POLY)   res = opU( res, vec2( udPoly(pos, poly1)-ep1, ID_SHAPE_2 ) );
       
    // Link
    res = opU( res, vec2( length( pos-pt0)- 0.04 , ID_LINK ) );
    res = opU( res, vec2( length( pos-pt1)- 0.04, ID_LINK ) );
    res = opU( res, vec2( sdCapsule( pos,pt0, pt1, 0.01  ), ID_LINK ) );
    
#ifdef DEBUG    

        res = opU( res, vec2( sdSphere( pos-pt3, 0.03 ), ID_DEBUG ) );
        res = opU( res, vec2( sdCapsule( pos, pt2, pt3, 0.03  ), ID_DEBUG ) );
        res = opU( res, vec2( sdCapsule( pos, pt4, pt5, 0.03  ), ID_DEBUG ) );
    
    
#endif

    return res;
}

// Function 1506
float mapDistance(const in vec3 point) {
  float tmpComb_250 = opUnionRound(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), 0.4) * 1.0, 1.0);
float tmpComb_251 = tmpComb_250;
float tmpComb_252 = opUnionRound(tmpComb_251, sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(iTime * -5.0,-5.0,-5.0)), vec4(0.2,0.4,0.8,0.1)) * 1.0, 1.0);
float tmpComb_253 = tmpComb_252;
float tmpComb_254 = opUnionRound(tmpComb_253, sdTorus(pMod((mat4(sin(iTime / 5.0)*-1.4235779345035553,0.0,0.0,0.0,0.0,0.4235779345035553,0.0,0.0,0.0,0.0,0.4235779345035553,0.0,0.0,-0.18355792760849,-0.6719846725463867,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(0.4,0.05)) * 2.3608405590057373, 1.0);
float tmpComb_255 = tmpComb_254;
float tmpComb_256 = opUnionRound(tmpComb_255, sdBox(pMod((mat4(0.05644333362579346,0.017791423946619034,-0.998214066028595,0.0,-0.025665316730737686,0.9995034337043762,0.016363179311156273,0.0,0.9980428218841553,0.02469668537378311,0.05687381699681282,0.0,0.10439714044332504,-1.5119545459747314,-0.07225281745195389,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec4(0.2,0.4,0.8,0.1)) * 1.000033005974318, 1.0);
float tmpComb_257 = tmpComb_256;
float tmpComb_258 = opUnionStairs(tmpComb_257, sdEllipsoid(pMod((mat4(17.42844581604004,0.0,0.0,0.0,0.0,-0.573193371295929,-17.419015884399414,0.0,0.0,17.419015884399414,-0.573193371295929,0.0,0.0,-26.98288345336914,-12.640543937683105,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.2,0.4,0.8)) * 0.057377465069293976, vec2(0.79,3.0));
return tmpComb_258;
}

// Function 1507
float getHeightMap(vec2 U) 
{
    return heighMap(U)*1.5;
    // Scale U
    U*=0.05;
    
    // Map is mirrerd and repeated
    if(mod(U.x, 2.0) > 1.0) U.x = 1.0-fract(U).x;
    else U.x = fract(U.x);
    if(mod(U.y, 2.0) > 1.0) U.y = 1.0-fract(U).y;
    else U.y = fract(U.y);

    //return texture(iChannel0, U).w*2.0; 
}

// Function 1508
float GetDistSqFromLineSegmentToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)
{
	float t = GetPositionAlongLineSegmentNearestToPoint(line_segment_a, line_segment_b, point);

	vec2 to_nearest = point - mix(line_segment_a, line_segment_b, t);

	return dot(to_nearest, to_nearest);
}

// Function 1509
float GetDistanceScene( const in vec3 vPos )
{   
	float fResult = 1000.0;
	
	float fFloorDist = vPos.y + 3.2;	
	fResult = min(fResult, fFloorDist);
	
	
	vec3 vBuilding1Pos = vec3(58.8, 0.0, 50.0);
	const float fBuilding1Radius = 50.0;
	vec3 vBuilding1Offset = vBuilding1Pos - vPos;
	float fBuilding1Dist = length(vBuilding1Offset.xz) - fBuilding1Radius;
	
	fResult = min(fResult, fBuilding1Dist);
	
	
	
	vec3 vBuilding2Pos = vec3(60.0, 0.0, 55.0);
	const float fBuilding2Radius = 100.0;
	vec3 vBuilding2Offset = vBuilding2Pos - vPos;
	float fBuilding2Dist = length(vBuilding2Offset.xz) - fBuilding2Radius;
	
	fBuilding2Dist = max(vBuilding2Offset.z - 16.0, -fBuilding2Dist); // back only
	
	fResult = min(fResult, fBuilding2Dist);

	
	vec3 vBollardDomain = vPos;
	vBollardDomain -= vec3(1.0, -2.0, 13.5);
	vBollardDomain = RotateY(vBollardDomain, sin(0.6), cos(0.6));
	float fBollardDist = GetDistanceBox(vBollardDomain, vec3(0.2, 1.3, 0.2));
		
	fResult = min(fResult, fBollardDist);

	
	vec3 vFenceDomain = vPos;
	vFenceDomain -= vec3(-5.5, -2.5, 7.0);
	vFenceDomain = RotateY(vFenceDomain, sin(1.0), cos(1.0));
	float fFenceDist = GetDistanceBox(vFenceDomain, vec3(0.5, 1.2, 0.2));
		
	fResult = min(fResult, fFenceDist);
	
	

	vec3 vCabDomain = vPos;
	vCabDomain -= vec3(-1.4, -1.5,29.5);
	vCabDomain = RotateY(vCabDomain, sin(0.01), cos(0.01));
	float fCabDist = GetDistanceBox(vCabDomain, vec3(1.2, 1.5, 3.0));
		
	fResult = min(fResult, fCabDist);
	
		
	vec3 vBusDomain = vPos;
	vBusDomain -= vec3(-15.25, -2.0, 30.0);
	vBusDomain = RotateY(vBusDomain, sin(0.3), cos(0.3));
	float fBusDist = GetDistanceBox(vBusDomain, vec3(1.0, 3.0, 3.0));
		
	fResult = min(fResult, fBusDist);
	
		
	vec3 vBusShelter = vPos;
	vBusShelter -= vec3(7.5, -2.0, 30.0);
	vBusShelter = RotateY(vBusShelter, sin(0.3), cos(0.3));
	float fBusShelterDist = GetDistanceBox(vBusShelter, vec3(1.0, 5.0, 2.0));
		
	fResult = min(fResult, fBusShelterDist);
	
	vec3 vRailings = vPos;
	vRailings -= vec3(12.0, -2.0, 18.0);
	vRailings = RotateY(vRailings, sin(0.3), cos(0.3));
	float fRailings = GetDistanceBox(vRailings, vec3(1.0, 1.0, 2.0));
		
	fResult = min(fResult, fRailings);
		
	
	vec3 vCentralPavement = vPos;
	vCentralPavement -= vec3(5.3, -3.0, 8.0);
	vCentralPavement = RotateY(vCentralPavement, sin(0.6), cos(0.6));
	float fCentralPavementDist = GetDistanceBox(vCentralPavement, vec3(0.8, 0.2, 8.0));
		
	fResult = min(fResult, fCentralPavementDist);
	

	
	return fResult;
}

// Function 1510
vec4 scene(vec3 ro, vec3 rd){
	float t=0.0,d,od=1.0;
	for(int i=0;i<ITERS;i++){
		t+=d=DE(ro+rd*t);
		if(d<0.0001 || t>3.0)break;
		od=d;
	}
	t=min(t,3.0);
	vec3 col=sky(rd);
	if(d<0.1){
		float dif=1.0-clamp(d/od,0.0,0.8);
		vec3 so=ro+rd*t;
		vec3 scol=vec3(0.0);
		if(id==0){
			float c=track_val(so.xz);
			vec3 grnd=vec3(0.3+10.0*so.y,1.0,0.7-12.0*so.y)+texture(iChannel1,so.xz*0.1).rgb*0.3;
			if(rd.y<0.0){
				float tmax=-ro.y/rd.y;
				so.xz=ro.xz+rd.xz*tmax;
			}
			vec3 trk=vec3(0.4)+texture(iChannel1,so.xz).rgb*0.1;
			trk = mix(trk, vec3(1.0), clamp(dot(normalize(finishDir), normalize(so.xz)) * 10000.0 - 9999.0, 0.0, 1.0));
			scol=mix(trk,grnd,clamp(c*20.0,0.0,1.0));
			d=DEC(scar);
			scol*=clamp(0.3+d*100.0,0.0,1.0);
		}else{
			scol=car_color_from_index(id).rgb;
			CarCol(scar,d,scol);
		}
		scol*=dif;
		col=mix(scol,col,t/3.0);
	}
	return vec4(col*1.5,1.0);
}

// Function 1511
float mapSphere(in Sphere s, in vec3 p)
{
    return length(p - s.position) - s.radius;   
}

// Function 1512
float map(in vec3 pos)
{
    vec3 q = pos;
    float d = -sdTorus( q.xzy, vec2(Radius1,Radius2) ) ;
    
    return d;
}

// Function 1513
vec2 sdf(vec3 p)
{
    vec2 d = vec2(50.0, 0.0);
    
    float bounds = length(p + vec3(0.0, 3.0, 0.0)) - 5.0;
    
    if(bounds < .5)
    {
        vec3 lidP = lidAnimation(p);
            
    	d = opU(d, vec2(ribbon(lidP), RIBBON_MATERIAL));
        d = opU(d, vec2(ribbon(rotateY(lidP, .5)), RIBBON_MATERIAL));        
		
        d = opU(d, vec2(centerRibbon(rotateY(lidP, 1.87)), RIBBON_MATERIAL));
        
        d = opU(d, vec2(strap(rotateY(lidP, -.3)), RIBBON_MATERIAL));
        d = opU(d, vec2(strap(rotateY(lidP, 1.23)), RIBBON_MATERIAL));
        
    	d = opU(d, vec2(mech(p), RIBBON_MATERIAL));
        d = opU(d, vec2(mechGold(p), GOLD_MATERIAL));
        d = opU(d, vec2(mechInner(p), METAL_MATERIAL));      

        d = opU(d, vec2(mainBox(p), BOX_MATERIAL));
        d = opU(d, vec2(boxLid(lidP), BOX_MATERIAL));
        
        d = opU(d, vec2(lidStraps(lidP), RIBBON_MATERIAL));
        
    }
    else
    {
        d.x = min(d.x, bounds);
    }
    
    d = opU(d, vec2(p.y + 5.7, GROUND_MATERIAL));

	return d;
}

// Function 1514
float sdfCircle(vec2 uv, float r) { return length(uv)-r; }

// Function 1515
vec3 voronoiSphereMapping(vec3 n){
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
   	return getVoronoi(1.5*uv);}

// Function 1516
v2 debugDist(v0 u){v2 r
 //;u*=pi *100.
 ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.
 ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.
 ;r = mix(r,v2(0),sat(abs(u)))// falloff
 ;return r;}

// Function 1517
vec4 map( in vec2 pos )
{    
  vec4 dis_col = vec4(1e20,0.0,0.0,0.0);

  // data copied and transformed from https://www.shadertoy.com/view/XdKGDW
  sdLine(dis_col,pos,vec2( 0.032566, 0.636419),vec2(-0.140558, 0.554919),vec3(0.802,0.563,0.443),vec3(0.865,0.792,0.690));
  sdLine(dis_col,pos,vec2( 0.157917, 0.667506),vec2( 0.032586, 0.636408),vec3(0.824,0.575,0.453),vec3(0.869,0.804,0.702));
  sdLine(dis_col,pos,vec2( 0.292774, 0.683634),vec2( 0.157637, 0.667307),vec3(0.849,0.600,0.467),vec3(0.871,0.804,0.702));
  sdLine(dis_col,pos,vec2( 0.462459, 0.681116),vec2( 0.293026, 0.683576),vec3(0.890,0.647,0.488),vec3(0.871,0.804,0.700));
  sdLine(dis_col,pos,vec2( 0.532097, 0.663221),vec2( 0.462281, 0.681257),vec3(0.931,0.692,0.510),vec3(0.871,0.804,0.698));
  sdLine(dis_col,pos,vec2( 0.679623, 0.589789),vec2( 0.532148, 0.663353),vec3(0.951,0.712,0.518),vec3(0.871,0.804,0.698));
  sdLine(dis_col,pos,vec2( 0.737901, 0.539194),vec2( 0.680024, 0.589419),vec3(0.951,0.712,0.512),vec3(0.871,0.804,0.698));
  sdLine(dis_col,pos,vec2( 0.816252, 0.438381),vec2( 0.737331, 0.539616),vec3(0.933,0.700,0.502),vec3(0.871,0.804,0.696));
  sdLine(dis_col,pos,vec2( 0.855568, 0.362220),vec2( 0.816666, 0.437574),vec3(0.920,0.684,0.486),vec3(0.871,0.802,0.694));
  sdLine(dis_col,pos,vec2( 0.914063, 0.195570),vec2( 0.855412, 0.362903),vec3(0.904,0.667,0.467),vec3(0.871,0.800,0.694));
  sdLine(dis_col,pos,vec2( 0.906394,-0.050806),vec2( 0.914184, 0.195399),vec3(0.876,0.637,0.437),vec3(0.871,0.800,0.692));
  sdLine(dis_col,pos,vec2( 0.847684,-0.254043),vec2( 0.906304,-0.051022),vec3(0.841,0.600,0.402),vec3(0.871,0.800,0.688));
  sdLine(dis_col,pos,vec2( 0.753134,-0.419097),vec2( 0.847548,-0.253827),vec3(0.808,0.571,0.373),vec3(0.871,0.798,0.686));
  sdLine(dis_col,pos,vec2( 0.655326,-0.537575),vec2( 0.752991,-0.419390),vec3(0.796,0.557,0.357),vec3(0.871,0.796,0.686),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686));
  sdLine(dis_col,pos,vec2( 0.589686,-0.601779),vec2( 0.655427,-0.537635),vec3(0.698,0.439,0.271),vec3(0.871,0.796,0.686),vec3(0.592,0.298,0.149),vec3(0.871,0.796,0.686));
  sdLine(dis_col,pos,vec2( 0.485769,-0.673529),vec2( 0.589993,-0.601259),vec3(0.553,0.269,0.131),vec3(0.871,0.796,0.684));
  sdLine(dis_col,pos,vec2( 0.420683,-0.695361),vec2( 0.485736,-0.673833),vec3(0.506,0.247,0.124),vec3(0.876,0.806,0.692));
  sdLine(dis_col,pos,vec2( 0.289074,-0.705976),vec2( 0.420341,-0.695230),vec3(0.482,0.275,0.155),vec3(0.876,0.806,0.692));
  sdLine(dis_col,pos,vec2( 0.261794,-0.694878),vec2( 0.289218,-0.706199),vec3(0.459,0.284,0.173),vec3(0.871,0.796,0.680));
  sdLine(dis_col,pos,vec2( 0.234336,-0.652438),vec2( 0.261805,-0.694874),vec3(0.443,0.249,0.153),vec3(0.871,0.796,0.678));
  sdLine(dis_col,pos,vec2( 0.229172,-0.613117),vec2( 0.234298,-0.652477),vec3(0.420,0.184,0.116),vec3(0.871,0.796,0.678));
  sdLine(dis_col,pos,vec2( 0.211059,-0.573956),vec2( 0.229373,-0.612721),vec3(0.404,0.145,0.094),vec3(0.871,0.796,0.678),vec3(0.384,0.090,0.059),vec3(0.631,0.506,0.447));
  sdLine(dis_col,pos,vec2( 0.794264, 0.332819),vec2( 0.820637, 0.237829),vec3(0.961,0.525,0.318),vec3(0.941,0.394,0.175));
  sdLine(dis_col,pos,vec2( 0.791799, 0.406427),vec2( 0.794099, 0.333239),vec3(0.967,0.565,0.365),vec3(0.941,0.388,0.163));
  sdLine(dis_col,pos,vec2( 0.773116, 0.456365),vec2( 0.791677, 0.406208),vec3(0.973,0.596,0.406),vec3(0.941,0.382,0.153));
  sdLine(dis_col,pos,vec2( 0.691214, 0.542967),vec2( 0.772875, 0.456604),vec3(0.980,0.631,0.455),vec3(0.941,0.375,0.139));
  sdLine(dis_col,pos,vec2( 0.584748, 0.612130),vec2( 0.691856, 0.543066),vec3(0.988,0.675,0.510),vec3(0.941,0.367,0.124));
  sdLine(dis_col,pos,vec2( 0.523270, 0.633009),vec2( 0.583850, 0.612122),vec3(0.994,0.702,0.543),vec3(0.941,0.361,0.114));
  sdLine(dis_col,pos,vec2( 0.416081, 0.649827),vec2( 0.523622, 0.632948),vec3(0.996,0.710,0.553),vec3(0.941,0.357,0.110),vec3(0.965,0.596,0.420),vec3(0.941,0.353,0.094));
  sdLine(dis_col,pos,vec2( 0.328754, 0.652317),vec2( 0.416523, 0.649811),vec3(0.955,0.573,0.390),vec3(0.941,0.349,0.090));
  sdLine(dis_col,pos,vec2( 0.152437, 0.628754),vec2( 0.328509, 0.652168),vec3(0.945,0.549,0.361),vec3(0.941,0.345,0.086),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192));
  sdLine(dis_col,pos,vec2(-0.058755, 0.562422),vec2( 0.152170, 0.628817),vec3(0.918,0.671,0.486),vec3(0.929,0.404,0.192),vec3(0.847,0.643,0.471),vec3(0.910,0.478,0.325));
  sdLine(dis_col,pos,vec2(-0.152258, 0.413501),vec2(-0.073990, 0.418056),vec3(0.322,0.165,0.318),vec3(0.839,0.357,0.294),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400));
  sdLine(dis_col,pos,vec2(-0.166656, 0.426903),vec2(-0.152256, 0.413325),vec3(0.325,0.161,0.341),vec3(0.875,0.427,0.400),vec3(0.329,0.157,0.361),vec3(0.929,0.510,0.518));
  sdLine(dis_col,pos,vec2(-0.150301, 0.459101),vec2(-0.167019, 0.427044),vec3(0.327,0.155,0.355),vec3(0.902,0.504,0.522));
  sdLine(dis_col,pos,vec2(-0.118651, 0.485569),vec2(-0.150151, 0.459146),vec3(0.322,0.151,0.329),vec3(0.892,0.510,0.522));
  sdLine(dis_col,pos,vec2(-0.002352, 0.524810),vec2(-0.118560, 0.485419),vec3(0.302,0.141,0.253),vec3(0.918,0.525,0.484));
  sdLine(dis_col,pos,vec2( 0.031055, 0.523623),vec2(-0.002648, 0.525035),vec3(0.329,0.161,0.216),vec3(0.927,0.531,0.443));
  sdLine(dis_col,pos,vec2( 0.698487, 0.039536),vec2( 0.691611,-0.011391),vec3(0.241,0.084,0.069),vec3(0.894,0.271,0.043));
  sdLine(dis_col,pos,vec2( 0.719461, 0.087611),vec2( 0.698093, 0.039144),vec3(0.208,0.076,0.112),vec3(0.892,0.271,0.041));
  sdLine(dis_col,pos,vec2( 0.756735, 0.118077),vec2( 0.719793, 0.087918),vec3(0.180,0.078,0.149),vec3(0.890,0.271,0.037));
  sdLine(dis_col,pos,vec2( 0.781480, 0.121070),vec2( 0.756822, 0.117813),vec3(0.208,0.100,0.151),vec3(0.890,0.271,0.035));
  sdLine(dis_col,pos,vec2( 0.801014, 0.097611),vec2( 0.781005, 0.120993),vec3(0.220,0.114,0.149),vec3(0.888,0.269,0.033));
  sdLine(dis_col,pos,vec2( 0.823724, 0.024839),vec2( 0.801409, 0.097493),vec3(0.210,0.129,0.149),vec3(0.886,0.267,0.029));
  sdLine(dis_col,pos,vec2( 0.823815,-0.104922),vec2( 0.823541, 0.024940),vec3(0.247,0.180,0.135),vec3(0.882,0.265,0.024));
  sdLine(dis_col,pos,vec2( 0.812986,-0.134971),vec2( 0.823897,-0.104904),vec3(0.275,0.206,0.120),vec3(0.878,0.263,0.018));
  sdLine(dis_col,pos,vec2( 0.781477,-0.159956),vec2( 0.813047,-0.134843),vec3(0.275,0.182,0.102),vec3(0.876,0.263,0.014));
  sdLine(dis_col,pos,vec2( 0.742899,-0.136473),vec2( 0.781414,-0.160083),vec3(0.273,0.161,0.084),vec3(0.873,0.261,0.010));
  sdLine(dis_col,pos,vec2( 0.707845,-0.099381),vec2( 0.742671,-0.136282),vec3(0.278,0.145,0.071),vec3(0.871,0.259,0.006));
  sdLine(dis_col,pos,vec2( 0.692791,-0.057184),vec2( 0.707941,-0.099276),vec3(0.278,0.127,0.057),vec3(0.869,0.259,0.002));
  sdLine(dis_col,pos,vec2( 0.691497,-0.011596),vec2( 0.692977,-0.057240),vec3(0.269,0.114,0.049),vec3(0.859,0.257,0.000));
  sdLine(dis_col,pos,vec2( 0.649558,-0.424193),vec2( 0.570243,-0.515577),vec3(0.394,0.220,0.129),vec3(0.763,0.245,0.125));
  sdLine(dis_col,pos,vec2( 0.691564,-0.410217),vec2( 0.649794,-0.424293),vec3(0.408,0.216,0.118),vec3(0.800,0.247,0.122),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176));
  sdLine(dis_col,pos,vec2( 0.696625,-0.423080),vec2( 0.691171,-0.410166),vec3(0.635,0.341,0.208),vec3(0.773,0.318,0.176),vec3(0.569,0.345,0.220),vec3(0.749,0.416,0.251));
  sdLine(dis_col,pos,vec2( 0.689415,-0.442915),vec2( 0.697144,-0.422830),vec3(0.529,0.343,0.227),vec3(0.729,0.441,0.273));
  sdLine(dis_col,pos,vec2( 0.593770,-0.551001),vec2( 0.689147,-0.443398),vec3(0.441,0.322,0.225),vec3(0.688,0.429,0.271));
  sdLine(dis_col,pos,vec2( 0.555892,-0.565232),vec2( 0.593883,-0.550881),vec3(0.431,0.282,0.198),vec3(0.665,0.351,0.220));
  sdLine(dis_col,pos,vec2( 0.551358,-0.559085),vec2( 0.555731,-0.565064),vec3(0.471,0.263,0.180),vec3(0.663,0.310,0.192),vec3(0.345,0.263,0.192),vec3(0.659,0.271,0.169));
  sdLine(dis_col,pos,vec2( 0.570349,-0.515707),vec2( 0.551420,-0.559235),vec3(0.343,0.257,0.188),vec3(0.661,0.257,0.157));
  sdLine(dis_col,pos,vec2( 0.139656, 0.051930),vec2( 0.125174,-0.011939),vec3(0.212,0.176,0.188),vec3(0.773,0.251,0.153),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290));
  sdLine(dis_col,pos,vec2( 0.156524, 0.072534),vec2( 0.139337, 0.052148),vec3(0.322,0.298,0.314),vec3(0.831,0.376,0.290),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447));
  sdLine(dis_col,pos,vec2( 0.207624, 0.092959),vec2( 0.156443, 0.072549),vec3(0.455,0.388,0.420),vec3(0.863,0.510,0.447),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588));
  sdLine(dis_col,pos,vec2( 0.277523, 0.089856),vec2( 0.208031, 0.092954),vec3(0.608,0.612,0.635),vec3(0.902,0.635,0.588),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753));
  sdLine(dis_col,pos,vec2( 0.342574, 0.060277),vec2( 0.277521, 0.089925),vec3(0.792,0.820,0.851),vec3(0.945,0.776,0.753),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910));
  sdLine(dis_col,pos,vec2( 0.395896, 0.011487),vec2( 0.342325, 0.060273),vec3(0.851,0.867,0.894),vec3(0.988,0.914,0.910),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769));
  sdLine(dis_col,pos,vec2( 0.426593,-0.056929),vec2( 0.395983, 0.010998),vec3(0.816,0.769,0.788),vec3(0.973,0.792,0.769),vec3(0.784,0.690,0.702),vec3(0.953,0.675,0.624));
  sdLine(dis_col,pos,vec2( 0.429756,-0.097479),vec2( 0.426646,-0.056343),vec3(0.784,0.690,0.702),vec3(0.955,0.676,0.627));
  sdLine(dis_col,pos,vec2( 0.211977, 0.039860),vec2( 0.152329, 0.066394),vec3(0.251,0.255,0.322),vec3(0.573,0.522,0.557),vec3(0.239,0.251,0.325),vec3(0.612,0.620,0.655));
  sdLine(dis_col,pos,vec2( 0.253875,-0.009396),vec2( 0.212258, 0.039555),vec3(0.224,0.235,0.298),vec3(0.627,0.651,0.694));
  sdLine(dis_col,pos,vec2( 0.304442,-0.112422),vec2( 0.254010,-0.009088),vec3(0.190,0.196,0.251),vec3(0.629,0.653,0.704));
  sdLine(dis_col,pos,vec2( 0.333171,-0.133931),vec2( 0.303949,-0.112429),vec3(0.178,0.169,0.220),vec3(0.612,0.620,0.671));
  sdLine(dis_col,pos,vec2( 0.374078,-0.127448),vec2( 0.333105,-0.133826),vec3(0.222,0.190,0.220),vec3(0.629,0.629,0.675));
  sdLine(dis_col,pos,vec2( 0.429594,-0.097757),vec2( 0.374129,-0.127644),vec3(0.278,0.229,0.237),vec3(0.678,0.659,0.694));
  sdLine(dis_col,pos,vec2( 0.128499,-0.076818),vec2( 0.113227,-0.128679),vec3(0.131,0.071,0.118),vec3(0.986,0.927,0.737));
  sdLine(dis_col,pos,vec2( 0.214776,-0.207363),vec2( 0.168035,-0.203218),vec3(0.982,0.796,0.496),vec3(0.124,0.039,0.092));
  sdLine(dis_col,pos,vec2( 0.238606,-0.218984),vec2( 0.215027,-0.207500),vec3(0.990,0.782,0.447),vec3(0.153,0.033,0.057));
  sdLine(dis_col,pos,vec2( 0.252587,-0.370868),vec2( 0.218651,-0.371118),vec3(0.441,0.100,0.059),vec3(0.845,0.380,0.137));
  sdLine(dis_col,pos,vec2( 0.276234,-0.360153),vec2( 0.252950,-0.370523),vec3(0.496,0.124,0.057),vec3(0.847,0.412,0.163));
  sdLine(dis_col,pos,vec2( 0.296842,-0.316514),vec2( 0.275936,-0.360588),vec3(0.533,0.141,0.055),vec3(0.847,0.431,0.180),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271));
  sdLine(dis_col,pos,vec2( 0.296875,-0.238281),vec2( 0.296875,-0.316406),vec3(0.643,0.192,0.051),vec3(0.910,0.561,0.271),vec3(0.741,0.239,0.047),vec3(0.953,0.678,0.357));
  sdLine(dis_col,pos,vec2(-0.018745,-0.009492),vec2(-0.023346,-0.023500),vec3(0.984,0.665,0.482),vec3(0.824,0.235,0.180));
  sdLine(dis_col,pos,vec2( 0.004475, 0.004419),vec2(-0.019006,-0.009652),vec3(0.976,0.686,0.506),vec3(0.798,0.210,0.153));
  sdLine(dis_col,pos,vec2( 0.078024,-0.000098),vec2( 0.004545, 0.004548),vec3(0.935,0.696,0.480),vec3(0.792,0.229,0.122));
  sdLine(dis_col,pos,vec2( 0.129006,-0.035229),vec2( 0.078225,-0.000073),vec3(0.902,0.686,0.447),vec3(0.788,0.243,0.102),vec3(0.937,0.769,0.545),vec3(0.769,0.255,0.059));
  sdLine(dis_col,pos,vec2( 0.214680,-0.370938),vec2( 0.167824,-0.202999),vec3(0.263,0.220,0.243),vec3(0.941,0.643,0.373));
  sdLine(dis_col,pos,vec2( 0.117434,-0.128738),vec2(-0.023211,-0.023293),vec3(0.718,0.698,0.690),vec3(0.984,0.867,0.718));
  sdLine(dis_col,pos,vec2(-0.027606,-0.023401),vec2(-0.250232, 0.058604),vec3(0.369,0.376,0.439),vec3(0.824,0.357,0.349));
  sdLine(dis_col,pos,vec2( 0.224314,-0.490840),vec2( 0.214794,-0.371444),vec3(0.110,0.076,0.102),vec3(0.553,0.102,0.061));
  sdLine(dis_col,pos,vec2( 0.210828,-0.578506),vec2( 0.224257,-0.490867),vec3(0.118,0.094,0.114),vec3(0.467,0.108,0.084));
  sdLine(dis_col,pos,vec2(-0.738216, 0.577331),vec2(-0.835883, 0.550764),vec3(0.647,0.639,0.914),vec3(0.859,0.780,0.682));
  sdLine(dis_col,pos,vec2(-0.428590, 0.601696),vec2(-0.738185, 0.577395),vec3(0.698,0.680,0.884),vec3(0.865,0.778,0.667));
  sdLine(dis_col,pos,vec2(-0.257866, 0.593737),vec2(-0.428754, 0.601618),vec3(0.763,0.733,0.845),vec3(0.876,0.775,0.645));
  sdLine(dis_col,pos,vec2(-0.136723, 0.554703),vec2(-0.257809, 0.593759),vec3(0.808,0.769,0.820),vec3(0.878,0.775,0.657));
  sdLine(dis_col,pos,vec2(-0.910838, 0.948616),vec2(-0.980469, 0.968751),vec3(0.782,0.753,0.910),vec3(0.486,0.422,0.769));
  sdLine(dis_col,pos,vec2(-0.849120, 0.905236),vec2(-0.910830, 0.948608),vec3(0.771,0.741,0.908),vec3(0.494,0.431,0.773));
  sdLine(dis_col,pos,vec2(-0.805151, 0.844085),vec2(-0.849092, 0.905222),vec3(0.751,0.724,0.904),vec3(0.494,0.431,0.773));
  sdLine(dis_col,pos,vec2(-0.792960, 0.808567),vec2(-0.805191, 0.844089),vec3(0.741,0.714,0.902),vec3(0.494,0.431,0.773));
  sdLine(dis_col,pos,vec2(-0.660730, 0.350115),vec2(-0.687380, 0.324080),vec3(0.569,0.539,0.929),vec3(0.625,0.612,0.963));
  sdLine(dis_col,pos,vec2(-0.581342, 0.390737),vec2(-0.660931, 0.350300),vec3(0.610,0.565,0.941),vec3(0.671,0.641,0.963));
  sdLine(dis_col,pos,vec2(-0.519169, 0.405706),vec2(-0.581260, 0.390541),vec3(0.653,0.590,0.953),vec3(0.722,0.671,0.963));
  sdLine(dis_col,pos,vec2(-0.325640, 0.410142),vec2(-0.519014, 0.405733),vec3(0.708,0.624,0.969),vec3(0.784,0.706,0.965));
  sdLine(dis_col,pos,vec2(-0.265662, 0.386779),vec2(-0.325886, 0.410329),vec3(0.767,0.661,0.982),vec3(0.847,0.741,0.965));
  sdLine(dis_col,pos,vec2(-0.890704, 0.394153),vec2(-0.996080, 0.374882),vec3(0.576,0.569,0.918),vec3(0.635,0.637,0.951));
  sdLine(dis_col,pos,vec2(-0.808329, 0.393799),vec2(-0.890754, 0.394278),vec3(0.575,0.569,0.922),vec3(0.635,0.635,0.955));
  sdLine(dis_col,pos,vec2(-0.746093, 0.374902),vec2(-0.808295, 0.393687),vec3(0.573,0.569,0.924),vec3(0.635,0.629,0.961));
  sdLine(dis_col,pos,vec2(-0.691314, 0.328133),vec2(-0.746006, 0.375002),vec3(0.571,0.569,0.927),vec3(0.635,0.624,0.969));
  sdLine(dis_col,pos,vec2(-0.713022, 0.223982),vec2(-0.699215, 0.078105),vec3(0.443,0.404,0.831),vec3(0.490,0.471,0.855),vec3(0.486,0.455,0.871),vec3(0.576,0.573,0.929));
  sdLine(dis_col,pos,vec2(-0.687633, 0.328193),vec2(-0.713148, 0.224068),vec3(0.502,0.473,0.884),vec3(0.590,0.586,0.943));
  sdLine(dis_col,pos,vec2(-0.962077,-0.021061),vec2(-0.984470,-0.062241),vec3(0.567,0.553,0.914),vec3(0.506,0.502,0.843));
  sdLine(dis_col,pos,vec2(-0.929730, 0.012170),vec2(-0.962095,-0.021151),vec3(0.563,0.543,0.914),vec3(0.508,0.514,0.829));
  sdLine(dis_col,pos,vec2(-0.842855, 0.056023),vec2(-0.929597, 0.011852),vec3(0.555,0.527,0.914),vec3(0.506,0.522,0.804));
  sdLine(dis_col,pos,vec2(-0.740058, 0.072302),vec2(-0.842912, 0.056291),vec3(0.549,0.518,0.914),vec3(0.502,0.522,0.788),vec3(0.537,0.498,0.914),vec3(0.431,0.412,0.788));
  sdLine(dis_col,pos,vec2(-0.648617, 0.066357),vec2(-0.739962, 0.072359),vec3(0.531,0.486,0.912),vec3(0.406,0.369,0.786));
  sdLine(dis_col,pos,vec2(-0.599562, 0.052212),vec2(-0.648693, 0.066421),vec3(0.522,0.465,0.912),vec3(0.390,0.339,0.776));
  sdLine(dis_col,pos,vec2(-0.523674,-0.011767),vec2(-0.599782, 0.051913),vec3(0.510,0.443,0.912),vec3(0.416,0.371,0.761));
  sdLine(dis_col,pos,vec2(-0.216909, 0.467215),vec2(-0.261703, 0.386747),vec3(0.943,0.525,0.555),vec3(0.851,0.796,0.924));
  sdLine(dis_col,pos,vec2(-0.140684, 0.554868),vec2(-0.216981, 0.467356),vec3(0.898,0.506,0.527),vec3(0.851,0.786,0.865));
  sdLine(dis_col,pos,vec2(-0.294609, 0.328762),vec2(-0.320297, 0.253955),vec3(0.945,0.480,0.496),vec3(0.655,0.545,0.908));
  sdLine(dis_col,pos,vec2(-0.261515, 0.386675),vec2(-0.294411, 0.328660),vec3(0.953,0.482,0.498),vec3(0.678,0.576,0.945),vec3(0.953,0.482,0.494),vec3(0.776,0.694,0.961));
  sdLine(dis_col,pos,vec2(-0.320312, 0.152344),vec2(-0.320312, 0.250000),vec3(0.227,0.159,0.249),vec3(0.892,0.455,0.476));
  sdLine(dis_col,pos,vec2(-0.285102, 0.093592),vec2(-0.320160, 0.152217),vec3(0.194,0.129,0.220),vec3(0.878,0.441,0.463));
  sdLine(dis_col,pos,vec2(-0.249821, 0.058499),vec2(-0.285083, 0.093620),vec3(0.206,0.137,0.220),vec3(0.861,0.422,0.445));
  sdLine(dis_col,pos,vec2(-0.370886, 0.200884),vec2(-0.296881, 0.058849),vec3(0.210,0.208,0.296),vec3(0.506,0.441,0.829));
  sdLine(dis_col,pos,vec2(-0.371080, 0.218669),vec2(-0.370863, 0.200571),vec3(0.216,0.208,0.275),vec3(0.539,0.473,0.853));
  sdLine(dis_col,pos,vec2(-0.320338, 0.250030),vec2(-0.371125, 0.218779),vec3(0.214,0.182,0.245),vec3(0.573,0.504,0.873));
  sdLine(dis_col,pos,vec2(-0.318397, 0.038871),vec2(-0.296987, 0.058686),vec3(0.408,0.345,0.751),vec3(0.235,0.243,0.371));
  sdLine(dis_col,pos,vec2(-0.335799, 0.000126),vec2(-0.318147, 0.038906),vec3(0.394,0.337,0.686),vec3(0.225,0.229,0.355));
  sdLine(dis_col,pos,vec2(-0.457045, 0.015479),vec2(-0.343771, 0.003763),vec3(0.404,0.341,0.757),vec3(0.714,0.702,0.792),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510));
  sdLine(dis_col,pos,vec2(-0.524601,-0.011832),vec2(-0.457157, 0.015632),vec3(0.427,0.369,0.796),vec3(0.478,0.443,0.510),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741));
  sdLine(dis_col,pos,vec2(-0.567845,-0.048929),vec2(-0.524475,-0.011939),vec3(0.475,0.424,0.792),vec3(0.627,0.596,0.741),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647));
  sdLine(dis_col,pos,vec2(-0.687512,-0.202819),vec2(-0.567697,-0.048786),vec3(0.545,0.490,0.871),vec3(0.522,0.490,0.647),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710));
  sdLine(dis_col,pos,vec2(-0.738370,-0.246033),vec2(-0.687782,-0.202852),vec3(0.749,0.706,0.980),vec3(0.702,0.651,0.710),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337));
  sdLine(dis_col,pos,vec2(-0.819820,-0.267858),vec2(-0.738322,-0.246131),vec3(0.690,0.651,0.929),vec3(0.259,0.235,0.337),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416));
  sdLine(dis_col,pos,vec2(-0.925652,-0.360953),vec2(-0.819489,-0.267857),vec3(0.631,0.604,0.933),vec3(0.380,0.333,0.416),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333));
  sdLine(dis_col,pos,vec2(-0.924077,-0.382938),vec2(-0.926012,-0.360824),vec3(0.525,0.502,0.808),vec3(0.243,0.188,0.333),vec3(0.506,0.478,0.733),vec3(0.541,0.486,0.631));
  sdLine(dis_col,pos,vec2(-0.908709,-0.396678),vec2(-0.923914,-0.383129),vec3(0.502,0.473,0.714),vec3(0.524,0.476,0.637));
  sdLine(dis_col,pos,vec2(-0.877801,-0.327818),vec2(-0.908834,-0.396482),vec3(0.498,0.467,0.694),vec3(0.506,0.467,0.643),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659));
  sdLine(dis_col,pos,vec2(-0.850665,-0.306523),vec2(-0.877737,-0.328046),vec3(0.584,0.565,0.894),vec3(0.490,0.439,0.659),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439));
  sdLine(dis_col,pos,vec2(-0.842943,-0.336355),vec2(-0.850644,-0.306423),vec3(0.553,0.510,0.765),vec3(0.329,0.278,0.439),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643));
  sdLine(dis_col,pos,vec2(-0.646520,-0.253453),vec2(-0.842985,-0.336477),vec3(0.518,0.478,0.761),vec3(0.537,0.494,0.643),vec3(0.671,0.620,0.957),vec3(0.467,0.392,0.565));
  sdLine(dis_col,pos,vec2(-0.613162,-0.227037),vec2(-0.646645,-0.253104),vec3(0.651,0.602,0.945),vec3(0.469,0.398,0.555));
  sdLine(dis_col,pos,vec2(-0.561901,-0.162148),vec2(-0.613081,-0.227201),vec3(0.594,0.549,0.910),vec3(0.476,0.429,0.539));
  sdLine(dis_col,pos,vec2(-0.500240,-0.050707),vec2(-0.562155,-0.162105),vec3(0.557,0.514,0.886),vec3(0.482,0.455,0.533),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369));
  sdLine(dis_col,pos,vec2(-0.464788,-0.030266),vec2(-0.500093,-0.050719),vec3(0.443,0.408,0.812),vec3(0.286,0.267,0.369),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267));
  sdLine(dis_col,pos,vec2(-0.439427,-0.045861),vec2(-0.464616,-0.030239),vec3(0.408,0.376,0.780),vec3(0.157,0.114,0.267),vec3(0.455,0.427,0.784),vec3(0.416,0.353,0.435));
  sdLine(dis_col,pos,vec2(-0.421871,-0.081990),vec2(-0.439501,-0.045912),vec3(0.443,0.418,0.773),vec3(0.404,0.369,0.437));
  sdLine(dis_col,pos,vec2(-0.386711,-0.105557),vec2(-0.421868,-0.082119),vec3(0.431,0.408,0.761),vec3(0.392,0.384,0.439),vec3(0.357,0.349,0.655),vec3(0.376,0.427,0.447));
  sdLine(dis_col,pos,vec2(-0.339923, 0.003866),vec2(-0.386802,-0.101587),vec3(0.200,0.196,0.267),vec3(0.345,0.333,0.365));
  sdLine(dis_col,pos,vec2(-0.407061,-0.201258),vec2(-0.386665,-0.105627),vec3(0.361,0.341,0.624),vec3(0.792,0.812,0.751));
  sdLine(dis_col,pos,vec2(-0.403323,-0.268221),vec2(-0.406911,-0.201492),vec3(0.363,0.329,0.606),vec3(0.771,0.769,0.724));
  sdLine(dis_col,pos,vec2(-0.390770,-0.273672),vec2(-0.403673,-0.268054),vec3(0.384,0.333,0.643),vec3(0.771,0.749,0.704));
  sdLine(dis_col,pos,vec2(-0.345881,-0.060745),vec2(-0.386656,-0.101656),vec3(0.776,0.835,0.784),vec3(0.361,0.400,0.427),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227));
  sdLine(dis_col,pos,vec2(-0.328983,-0.056141),vec2(-0.345818,-0.060743),vec3(0.792,0.839,0.780),vec3(0.145,0.176,0.227),vec3(0.808,0.847,0.780),vec3(0.220,0.251,0.310));
  sdLine(dis_col,pos,vec2(-0.252749,-0.126588),vec2(-0.329397,-0.055845),vec3(0.837,0.859,0.775),vec3(0.227,0.247,0.306));
  sdLine(dis_col,pos,vec2(-0.230481,-0.160125),vec2(-0.252484,-0.126757),vec3(0.867,0.871,0.769),vec3(0.235,0.243,0.302),vec3(0.859,0.851,0.749),vec3(0.161,0.153,0.204));
  sdLine(dis_col,pos,vec2(-0.226341,-0.219167),vec2(-0.230372,-0.160222),vec3(0.882,0.869,0.757),vec3(0.151,0.133,0.180));
  sdLine(dis_col,pos,vec2(-0.277439,-0.343654),vec2(-0.226534,-0.219015),vec3(0.906,0.886,0.765),vec3(0.141,0.114,0.157),vec3(0.929,0.898,0.761),vec3(0.251,0.212,0.239));
  sdLine(dis_col,pos,vec2(-0.331270,-0.274257),vec2(-0.390414,-0.273335),vec3(0.076,0.061,0.096),vec3(0.808,0.780,0.714));
  sdLine(dis_col,pos,vec2(-0.307108,-0.285553),vec2(-0.331497,-0.274239),vec3(0.075,0.059,0.094),vec3(0.829,0.806,0.718));
  sdLine(dis_col,pos,vec2(-0.285269,-0.316297),vec2(-0.307202,-0.285572),vec3(0.075,0.059,0.094),vec3(0.835,0.820,0.722));
  sdLine(dis_col,pos,vec2(-0.277101,-0.348165),vec2(-0.284918,-0.316904),vec3(0.075,0.059,0.094),vec3(0.831,0.820,0.722),vec3(0.086,0.063,0.102),vec3(0.620,0.584,0.522));
  sdLine(dis_col,pos,vec2( 0.191818,-0.655109),vec2( 0.210666,-0.574643),vec3(0.137,0.122,0.129),vec3(0.729,0.608,0.541),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616));
  sdLine(dis_col,pos,vec2( 0.177802,-0.664657),vec2( 0.191779,-0.655002),vec3(0.145,0.133,0.133),vec3(0.804,0.737,0.616),vec3(0.063,0.059,0.075),vec3(0.796,0.753,0.620));
  sdLine(dis_col,pos,vec2( 0.168515,-0.738957),vec2( 0.178126,-0.664256),vec3(0.096,0.092,0.100),vec3(0.812,0.759,0.625));
  sdLine(dis_col,pos,vec2( 0.155592,-0.752345),vec2( 0.168584,-0.738793),vec3(0.104,0.100,0.102),vec3(0.824,0.757,0.627));
  sdLine(dis_col,pos,vec2( 0.132513,-0.757861),vec2( 0.155207,-0.752647),vec3(0.073,0.069,0.073),vec3(0.820,0.747,0.624));
  sdLine(dis_col,pos,vec2( 0.086261,-0.759725),vec2(-0.023197,-0.695559),vec3(0.157,0.141,0.184),vec3(0.063,0.055,0.067),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055));
  sdLine(dis_col,pos,vec2( 0.132843,-0.757744),vec2( 0.086059,-0.759407),vec3(0.286,0.275,0.325),vec3(0.055,0.043,0.055),vec3(0.761,0.722,0.522),vec3(0.059,0.043,0.059));
  sdLine(dis_col,pos,vec2(-0.008536,-0.523957),vec2(-0.113095,-0.546922),vec3(0.761,0.722,0.522),vec3(0.051,0.033,0.051));
  sdLine(dis_col,pos,vec2( 0.028417,-0.535309),vec2(-0.008810,-0.523762),vec3(0.792,0.767,0.563),vec3(0.055,0.041,0.057));
  sdLine(dis_col,pos,vec2( 0.049655,-0.559962),vec2( 0.028517,-0.535386),vec3(0.798,0.782,0.580),vec3(0.076,0.065,0.073));
  sdLine(dis_col,pos,vec2( 0.071714,-0.659300),vec2( 0.049649,-0.559687),vec3(0.771,0.751,0.557),vec3(0.082,0.073,0.080));
  sdLine(dis_col,pos,vec2( 0.062107,-0.673453),vec2( 0.072068,-0.659420),vec3(0.731,0.704,0.520),vec3(0.088,0.080,0.088));
  sdLine(dis_col,pos,vec2(-0.019664,-0.695497),vec2( 0.061596,-0.673865),vec3(0.722,0.694,0.514),vec3(0.090,0.082,0.090),vec3(0.722,0.690,0.502),vec3(0.220,0.216,0.180));
  sdLine(dis_col,pos,vec2(-0.103143,-0.577233),vec2(-0.113704,-0.546335),vec3(0.078,0.063,0.094),vec3(0.669,0.586,0.406));
  sdLine(dis_col,pos,vec2(-0.128872,-0.656514),vec2(-0.102680,-0.578043),vec3(0.078,0.063,0.094),vec3(0.643,0.573,0.396),vec3(0.078,0.063,0.094),vec3(0.545,0.506,0.349));
  sdLine(dis_col,pos,vec2(-0.110341,-0.684318),vec2(-0.132708,-0.656415),vec3(0.090,0.076,0.129),vec3(0.712,0.680,0.494));
  sdLine(dis_col,pos,vec2(-0.065097,-0.698489),vec2(-0.110606,-0.684138),vec3(0.106,0.094,0.133),vec3(0.712,0.680,0.494));
  sdLine(dis_col,pos,vec2(-0.023516,-0.695404),vec2(-0.065017,-0.698593),vec3(0.124,0.112,0.137),vec3(0.718,0.686,0.498));
  sdLine(dis_col,pos,vec2(-0.356409,-0.396602),vec2(-0.363344,-0.417840),vec3(0.667,0.684,0.514),vec3(0.086,0.073,0.102));
  sdLine(dis_col,pos,vec2(-0.329514,-0.372734),vec2(-0.356301,-0.396902),vec3(0.678,0.694,0.525),vec3(0.098,0.086,0.110),vec3(0.796,0.792,0.624),vec3(0.075,0.059,0.094));
  sdLine(dis_col,pos,vec2(-0.304495,-0.384405),vec2(-0.329372,-0.372760),vec3(0.794,0.786,0.625),vec3(0.073,0.055,0.094));
  sdLine(dis_col,pos,vec2(-0.304686,-0.445287),vec2(-0.304686,-0.384176),vec3(0.792,0.780,0.627),vec3(0.071,0.051,0.094),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094));
  sdLine(dis_col,pos,vec2(-0.329703,-0.471680),vec2(-0.304762,-0.445327),vec3(0.678,0.667,0.541),vec3(0.071,0.047,0.094),vec3(0.533,0.522,0.427),vec3(0.071,0.051,0.094));
  sdLine(dis_col,pos,vec2(-0.352235,-0.461623),vec2(-0.329757,-0.471344),vec3(0.504,0.494,0.406),vec3(0.071,0.051,0.094));
  sdLine(dis_col,pos,vec2(-0.363307,-0.418071),vec2(-0.352136,-0.462043),vec3(0.475,0.467,0.384),vec3(0.071,0.051,0.094),vec3(0.561,0.565,0.439),vec3(0.129,0.118,0.137));
  sdLine(dis_col,pos,vec2(-0.276110,-0.521710),vec2(-0.289045,-0.550497),vec3(0.641,0.637,0.478),vec3(0.035,0.033,0.063));
  sdLine(dis_col,pos,vec2(-0.258075,-0.516729),vec2(-0.275890,-0.521970),vec3(0.684,0.682,0.514),vec3(0.047,0.045,0.075));
  sdLine(dis_col,pos,vec2(-0.206378,-0.541564),vec2(-0.258683,-0.516738),vec3(0.706,0.706,0.529),vec3(0.047,0.047,0.078),vec3(0.792,0.788,0.600),vec3(0.051,0.055,0.063));
  sdLine(dis_col,pos,vec2(-0.187895,-0.563812),vec2(-0.206382,-0.541493),vec3(0.757,0.753,0.576),vec3(0.063,0.057,0.078));
  sdLine(dis_col,pos,vec2(-0.189739,-0.573083),vec2(-0.187133,-0.563528),vec3(0.735,0.731,0.561),vec3(0.075,0.059,0.094));
  sdLine(dis_col,pos,vec2(-0.251815,-0.589992),vec2(-0.189995,-0.573544),vec3(0.749,0.745,0.569),vec3(0.075,0.059,0.094),vec3(0.498,0.502,0.345),vec3(0.075,0.063,0.098));
  sdLine(dis_col,pos,vec2(-0.272446,-0.579505),vec2(-0.251715,-0.590033),vec3(0.514,0.518,0.363),vec3(0.075,0.063,0.098));
  sdLine(dis_col,pos,vec2(-0.289115,-0.550792),vec2(-0.272717,-0.579388),vec3(0.549,0.551,0.398),vec3(0.086,0.075,0.106));
  sdLine(dis_col,pos,vec2(-0.192736,-0.469520),vec2(-0.277483,-0.347082),vec3(0.108,0.076,0.120),vec3(0.065,0.057,0.090));
  sdLine(dis_col,pos,vec2(-0.113128,-0.547007),vec2(-0.192449,-0.470244),vec3(0.080,0.045,0.080),vec3(0.063,0.047,0.073));
  sdLine(dis_col,pos,vec2(-0.399689,-0.363777),vec2(-0.390465,-0.273580),vec3(0.355,0.292,0.675),vec3(0.088,0.075,0.112));
  sdLine(dis_col,pos,vec2(-0.414173,-0.390763),vec2(-0.399958,-0.363772),vec3(0.347,0.288,0.651),vec3(0.090,0.075,0.110));
  sdLine(dis_col,pos,vec2( 0.402104,-0.164371),vec2( 0.429754,-0.097640),vec3(0.237,0.182,0.180),vec3(0.784,0.296,0.143));
  sdLine(dis_col,pos,vec2( 0.366996,-0.206976),vec2( 0.401848,-0.164337),vec3(0.210,0.145,0.145),vec3(0.778,0.304,0.147));
  sdLine(dis_col,pos,vec2( 0.296913,-0.238165),vec2( 0.367225,-0.206912),vec3(0.194,0.118,0.120),vec3(0.743,0.304,0.149));
  sdLine(dis_col,pos,vec2( 0.167900,-0.203204),vec2( 0.113213,-0.128975),vec3(0.706,0.690,0.678),vec3(0.145,0.110,0.157));
  sdLine(dis_col,pos,vec2( 0.454448,-0.085567),vec2( 0.429490,-0.097974),vec3(0.898,0.478,0.357),vec3(0.945,0.643,0.580));
  sdLine(dis_col,pos,vec2( 0.501070,-0.040927),vec2( 0.454701,-0.085293),vec3(0.898,0.475,0.349),vec3(0.941,0.631,0.561),vec3(0.902,0.439,0.278),vec3(0.910,0.525,0.416));
  sdLine(dis_col,pos,vec2( 0.536751, 0.019080),vec2( 0.501035,-0.040870),vec3(0.904,0.425,0.247),vec3(0.902,0.502,0.384));
  sdLine(dis_col,pos,vec2( 0.554739, 0.081950),vec2( 0.536789, 0.018991),vec3(0.906,0.412,0.216),vec3(0.900,0.508,0.390));
  sdLine(dis_col,pos,vec2( 0.535861, 0.166934),vec2( 0.554677, 0.082064),vec3(0.906,0.412,0.216),vec3(0.906,0.537,0.427),vec3(0.906,0.416,0.224),vec3(0.925,0.647,0.557));
  sdLine(dis_col,pos,vec2( 0.419826, 0.338301),vec2( 0.535615, 0.166647),vec3(0.906,0.414,0.220),vec3(0.920,0.614,0.524));
  sdLine(dis_col,pos,vec2( 0.406078, 0.390921),vec2( 0.419883, 0.338831),vec3(0.906,0.412,0.216),vec3(0.910,0.565,0.473));
  sdLine(dis_col,pos,vec2( 0.146477, 0.567224),vec2( 0.031189, 0.523314),vec3(0.863,0.475,0.404),vec3(0.963,0.447,0.278));
  sdLine(dis_col,pos,vec2( 0.238636, 0.574102),vec2( 0.146891, 0.567233),vec3(0.869,0.484,0.425),vec3(0.957,0.427,0.241));
  sdLine(dis_col,pos,vec2( 0.276654, 0.562718),vec2( 0.238421, 0.574198),vec3(0.876,0.496,0.445),vec3(0.949,0.400,0.192));
  sdLine(dis_col,pos,vec2( 0.328054, 0.527362),vec2( 0.276439, 0.562762),vec3(0.880,0.508,0.463),vec3(0.939,0.382,0.165));
  sdLine(dis_col,pos,vec2( 0.407058, 0.213498),vec2( 0.371072, 0.195345),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));
  sdLine(dis_col,pos,vec2( 0.458303, 0.213407),vec2( 0.407282, 0.213566),vec3(0.988,0.973,0.969),vec3(0.992,0.855,0.831));
  sdLine(dis_col,pos,vec2( 0.481278, 0.196816),vec2( 0.457990, 0.213665),vec3(0.988,0.973,0.967),vec3(0.992,0.855,0.829));
  sdLine(dis_col,pos,vec2( 0.499009, 0.163011),vec2( 0.481392, 0.196333),vec3(0.988,0.973,0.965),vec3(0.992,0.855,0.827));
  sdLine(dis_col,pos,vec2( 0.503604, 0.090461),vec2( 0.499073, 0.163192),vec3(0.988,0.971,0.965),vec3(0.990,0.855,0.827));
  sdLine(dis_col,pos,vec2( 0.489446, 0.076448),vec2( 0.503554, 0.090238),vec3(0.988,0.969,0.963),vec3(0.986,0.847,0.816));
  sdLine(dis_col,pos,vec2( 0.443782, 0.062339),vec2( 0.489220, 0.076528),vec3(0.986,0.969,0.961),vec3(0.986,0.845,0.814));
  sdLine(dis_col,pos,vec2( 0.378683, 0.066466),vec2( 0.443770, 0.062469),vec3(0.984,0.969,0.959),vec3(0.988,0.851,0.822));
  sdLine(dis_col,pos,vec2( 0.339578, 0.097522),vec2( 0.378706, 0.066500),vec3(0.984,0.967,0.957),vec3(0.986,0.851,0.820));
  sdLine(dis_col,pos,vec2( 0.329906, 0.140698),vec2( 0.339788, 0.097651),vec3(0.984,0.965,0.955),vec3(0.984,0.851,0.818));
  sdLine(dis_col,pos,vec2( 0.349815, 0.180720),vec2( 0.329907, 0.140407),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));
  sdLine(dis_col,pos,vec2( 0.371027, 0.195457),vec2( 0.349730, 0.180934),vec3(0.984,0.965,0.953),vec3(0.982,0.849,0.814));
  sdLine(dis_col,pos,vec2(-0.117425, 0.341220),vec2(-0.074257, 0.417986),vec3(0.847,0.318,0.216),vec3(0.794,0.425,0.357));
  sdLine(dis_col,pos,vec2(-0.131058, 0.286069),vec2(-0.117280, 0.341245),vec3(0.847,0.318,0.216),vec3(0.814,0.429,0.355));
  sdLine(dis_col,pos,vec2(-0.120979, 0.239269),vec2(-0.131229, 0.286301),vec3(0.847,0.318,0.216),vec3(0.831,0.435,0.355));
  sdLine(dis_col,pos,vec2(-0.094915, 0.195662),vec2(-0.120748, 0.238869),vec3(0.853,0.308,0.194),vec3(0.847,0.439,0.355));
  sdLine(dis_col,pos,vec2(-0.058454, 0.163892),vec2(-0.094941, 0.195621),vec3(0.861,0.296,0.171),vec3(0.861,0.439,0.351));
  sdLine(dis_col,pos,vec2( 0.096154, 0.101755),vec2(-0.058568, 0.164000),vec3(0.855,0.304,0.188),vec3(0.884,0.443,0.349));
  sdLine(dis_col,pos,vec2( 0.148627, 0.066296),vec2( 0.096309, 0.101713),vec3(0.845,0.316,0.214),vec3(0.906,0.447,0.349));
  sdLine(dis_col,pos,vec2( 0.238337,-0.218583),vec2( 0.296931,-0.238114),vec3(0.188,0.059,0.055),vec3(0.941,0.714,0.384));
  sdLine(dis_col,pos,vec2( 0.356732, 0.495659),vec2( 0.328217, 0.527093),vec3(0.475,0.510,0.604),vec3(0.418,0.445,0.533));
  sdLine(dis_col,pos,vec2( 0.406416, 0.390930),vec2( 0.356795, 0.496206),vec3(0.475,0.510,0.604),vec3(0.398,0.414,0.496));
  sdLine(dis_col,pos,vec2( 0.351847, 0.563942),vec2( 0.328272, 0.527247),vec3(0.439,0.475,0.569),vec3(0.725,0.459,0.408),vec3(0.443,0.475,0.569),vec3(0.882,0.420,0.259));
  sdLine(dis_col,pos,vec2( 0.386954, 0.567493),vec2( 0.352309, 0.564131),vec3(0.431,0.453,0.537),vec3(0.884,0.416,0.247));
  sdLine(dis_col,pos,vec2( 0.434360, 0.555848),vec2( 0.386390, 0.567397),vec3(0.420,0.431,0.506),vec3(0.886,0.412,0.235),vec3(0.361,0.341,0.396),vec3(0.882,0.416,0.247));
  sdLine(dis_col,pos,vec2( 0.481493, 0.527439),vec2( 0.434614, 0.555661),vec3(0.376,0.353,0.406),vec3(0.882,0.416,0.247));
  sdLine(dis_col,pos,vec2( 0.556668, 0.460958),vec2( 0.481472, 0.527483),vec3(0.392,0.365,0.416),vec3(0.882,0.416,0.247),vec3(0.522,0.502,0.557),vec3(0.882,0.412,0.247));
  sdLine(dis_col,pos,vec2( 0.568077, 0.433950),vec2( 0.556441, 0.461051),vec3(0.524,0.506,0.563),vec3(0.880,0.414,0.247));
  sdLine(dis_col,pos,vec2( 0.550912, 0.394412),vec2( 0.568131, 0.433870),vec3(0.494,0.480,0.541),vec3(0.880,0.416,0.247));
  sdLine(dis_col,pos,vec2( 0.490768, 0.382274),vec2( 0.550937, 0.394469),vec3(0.422,0.425,0.496),vec3(0.882,0.416,0.247));
  sdLine(dis_col,pos,vec2( 0.406039, 0.390810),vec2( 0.490402, 0.382519),vec3(0.375,0.382,0.457),vec3(0.882,0.418,0.253));
  sdLine(dis_col,pos,vec2( 0.330744, 0.478846),vec2( 0.328238, 0.527133),vec3(0.908,0.586,0.498),vec3(0.475,0.510,0.604));
  sdLine(dis_col,pos,vec2( 0.365538, 0.422127),vec2( 0.330688, 0.479010),vec3(0.910,0.588,0.498),vec3(0.475,0.510,0.604));
  sdLine(dis_col,pos,vec2( 0.406309, 0.390576),vec2( 0.365537, 0.422123),vec3(0.910,0.588,0.498),vec3(0.475,0.502,0.592));
  sdLine(dis_col,pos,vec2( 0.037170, 0.502175),vec2( 0.031325, 0.523294),vec3(0.357,0.220,0.255),vec3(0.725,0.404,0.349),vec3(0.357,0.220,0.255),vec3(0.914,0.506,0.408));
  sdLine(dis_col,pos,vec2( 0.009112, 0.456598),vec2( 0.036991, 0.502416),vec3(0.357,0.220,0.255),vec3(0.900,0.484,0.404));
  sdLine(dis_col,pos,vec2(-0.014264, 0.437994),vec2( 0.009264, 0.456398),vec3(0.357,0.220,0.255),vec3(0.882,0.457,0.398));
  sdLine(dis_col,pos,vec2(-0.074384, 0.418060),vec2(-0.014479, 0.438192),vec3(0.357,0.220,0.255),vec3(0.873,0.443,0.394));
  sdLine(dis_col,pos,vec2(-0.034865, 0.469095),vec2(-0.074326, 0.418051),vec3(0.357,0.220,0.255),vec3(0.325,0.153,0.310));
  sdLine(dis_col,pos,vec2( 0.031160, 0.519567),vec2(-0.034850, 0.469051),vec3(0.357,0.220,0.255),vec3(0.312,0.147,0.269));
  sdLine(dis_col,pos,vec2(-0.476788,-0.270699),vec2(-0.413803,-0.390958),vec3(0.400,0.333,0.724),vec3(0.529,0.406,0.447));
  sdLine(dis_col,pos,vec2(-0.515771,-0.226315),vec2(-0.477190,-0.270110),vec3(0.439,0.367,0.784),vec3(0.571,0.437,0.476));
  sdLine(dis_col,pos,vec2(-0.548925,-0.216192),vec2(-0.515512,-0.226748),vec3(0.475,0.408,0.808),vec3(0.588,0.451,0.490),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416));
  sdLine(dis_col,pos,vec2(-0.563920,-0.221379),vec2(-0.548931,-0.216115),vec3(0.580,0.529,0.878),vec3(0.404,0.282,0.416),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702));
  sdLine(dis_col,pos,vec2(-0.487346,-0.300005),vec2(-0.564121,-0.221089),vec3(0.671,0.635,0.937),vec3(0.533,0.455,0.702),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561));
  sdLine(dis_col,pos,vec2(-0.456709,-0.351242),vec2(-0.487322,-0.300058),vec3(0.502,0.459,0.749),vec3(0.522,0.392,0.561),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471));
  sdLine(dis_col,pos,vec2(-0.437438,-0.426111),vec2(-0.456570,-0.351699),vec3(0.396,0.349,0.639),vec3(0.412,0.290,0.471),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596));
  sdLine(dis_col,pos,vec2(-0.426103,-0.437341),vec2(-0.437819,-0.425625),vec3(0.294,0.243,0.537),vec3(0.553,0.475,0.596),vec3(0.380,0.345,0.600),vec3(0.659,0.600,0.761));
  sdLine(dis_col,pos,vec2(-0.137942,-0.735671),vec2(-0.234693,-0.652174),vec3(0.390,0.329,0.331),vec3(0.078,0.075,0.145));
  sdLine(dis_col,pos,vec2(-0.101453,-0.787596),vec2(-0.137531,-0.736006),vec3(0.376,0.318,0.302),vec3(0.067,0.067,0.141),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137));
  sdLine(dis_col,pos,vec2(-0.093467,-0.816814),vec2(-0.101262,-0.787835),vec3(0.729,0.698,0.671),vec3(0.051,0.055,0.137),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141));
  sdLine(dis_col,pos,vec2(-0.101072,-0.835520),vec2(-0.094078,-0.816636),vec3(0.592,0.549,0.522),vec3(0.059,0.059,0.141),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145));
  sdLine(dis_col,pos,vec2(-0.120105,-0.842187),vec2(-0.100815,-0.835333),vec3(0.427,0.369,0.341),vec3(0.067,0.067,0.145),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192));
  sdLine(dis_col,pos,vec2(-0.139116,-0.832593),vec2(-0.120099,-0.842135),vec3(0.541,0.467,0.439),vec3(0.129,0.129,0.192),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298));
  sdLine(dis_col,pos,vec2(-0.182775,-0.748898),vec2(-0.139277,-0.832422),vec3(0.651,0.561,0.541),vec3(0.220,0.212,0.298),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529));
  sdLine(dis_col,pos,vec2(-0.242482,-0.691315),vec2(-0.182860,-0.748982),vec3(0.176,0.090,0.090),vec3(0.329,0.290,0.529),vec3(0.376,0.247,0.227),vec3(0.247,0.212,0.412));
  sdLine(dis_col,pos,vec2(-0.376186,-0.507215),vec2(-0.414107,-0.390583),vec3(0.341,0.347,0.365),vec3(0.071,0.061,0.108));
  sdLine(dis_col,pos,vec2(-0.334872,-0.560660),vec2(-0.375961,-0.507315),vec3(0.347,0.353,0.337),vec3(0.061,0.051,0.096));
  sdLine(dis_col,pos,vec2(-0.234322,-0.652779),vec2(-0.334981,-0.561046),vec3(0.333,0.337,0.322),vec3(0.059,0.047,0.090),vec3(0.251,0.251,0.255),vec3(0.067,0.063,0.098));
  sdLine(dis_col,pos,vec2(-0.443668,-0.478495),vec2(-0.425835,-0.437392),vec3(0.365,0.322,0.592),vec3(0.392,0.392,0.510),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365));
  sdLine(dis_col,pos,vec2(-0.439128,-0.529675),vec2(-0.443433,-0.478735),vec3(0.353,0.310,0.580),vec3(0.235,0.227,0.365),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200));
  sdLine(dis_col,pos,vec2(-0.375449,-0.627070),vec2(-0.439486,-0.529481),vec3(0.282,0.275,0.471),vec3(0.110,0.106,0.200),vec3(0.361,0.314,0.592),vec3(0.110,0.102,0.133));
  sdLine(dis_col,pos,vec2(-0.332113,-0.645086),vec2(-0.375323,-0.626910),vec3(0.361,0.314,0.592),vec3(0.131,0.122,0.145));
  sdLine(dis_col,pos,vec2(-0.265559,-0.648265),vec2(-0.332002,-0.645122),vec3(0.361,0.314,0.592),vec3(0.165,0.153,0.165));
  sdLine(dis_col,pos,vec2( 0.205231,-0.817938),vec2( 0.109033,-0.765411),vec3(0.429,0.459,0.576),vec3(0.820,0.737,0.624));
  sdLine(dis_col,pos,vec2( 0.293818,-0.895384),vec2( 0.205808,-0.818524),vec3(0.447,0.478,0.592),vec3(0.820,0.737,0.624),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624));
  sdLine(dis_col,pos,vec2( 0.354093,-0.996256),vec2( 0.293952,-0.895611),vec3(0.529,0.557,0.659),vec3(0.820,0.737,0.624),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624));
  sdLine(dis_col,pos,vec2( 0.367427,-1.054936),vec2( 0.353965,-0.995872),vec3(0.612,0.635,0.722),vec3(0.820,0.737,0.624),vec3(0.725,0.690,0.663),vec3(0.816,0.737,0.624));
  sdLine(dis_col,pos,vec2(-0.954948,-0.473706),vec2(-0.984357,-0.410454),vec3(0.161,0.147,0.363),vec3(0.398,0.363,0.714));
  sdLine(dis_col,pos,vec2(-0.903811,-0.638807),vec2(-0.954931,-0.473614),vec3(0.153,0.141,0.349),vec3(0.404,0.369,0.718),vec3(0.067,0.063,0.188),vec3(0.420,0.392,0.722));
  sdLine(dis_col,pos,vec2(-0.875055,-0.699107),vec2(-0.903928,-0.638463),vec3(0.073,0.069,0.202),vec3(0.408,0.380,0.702));
  sdLine(dis_col,pos,vec2(-0.629447,-0.956558),vec2(-0.687403,-0.870736),vec3(0.029,0.029,0.135),vec3(0.120,0.114,0.286));
  sdLine(dis_col,pos,vec2(-0.605535,-1.023209),vec2(-0.629620,-0.956694),vec3(0.029,0.029,0.125),vec3(0.096,0.096,0.247));
  sdLine(dis_col,pos,vec2(-0.265320,-0.663013),vec2(-0.242156,-0.691406),vec3(0.216,0.129,0.125),vec3(0.361,0.310,0.592),vec3(0.325,0.267,0.251),vec3(0.361,0.310,0.592));
  sdLine(dis_col,pos,vec2(-0.265459,-0.648465),vec2(-0.265186,-0.663040),vec3(0.355,0.298,0.288),vec3(0.355,0.306,0.580));
  sdLine(dis_col,pos,vec2(-0.630864,-0.893412),vec2(-0.687487,-0.870996),vec3(0.125,0.112,0.275),vec3(0.259,0.253,0.482));
  sdLine(dis_col,pos,vec2(-0.586520,-0.885655),vec2(-0.630843,-0.893310),vec3(0.108,0.092,0.233),vec3(0.208,0.206,0.418));
  sdLine(dis_col,pos,vec2(-0.487897,-0.819075),vec2(-0.586679,-0.885778),vec3(0.104,0.088,0.218),vec3(0.176,0.176,0.375));
  sdLine(dis_col,pos,vec2(-0.300556,-0.770950),vec2(-0.487735,-0.819175),vec3(0.098,0.082,0.188),vec3(0.188,0.182,0.373));
  sdLine(dis_col,pos,vec2(-0.274553,-0.751048),vec2(-0.300678,-0.771091),vec3(0.094,0.078,0.163),vec3(0.202,0.188,0.363));
  sdLine(dis_col,pos,vec2(-0.242248,-0.691634),vec2(-0.274548,-0.751130),vec3(0.090,0.075,0.147),vec3(0.216,0.196,0.359));
  sdLine(dis_col,pos,vec2(-0.800847,-0.800581),vec2(-0.875072,-0.699008),vec3(0.069,0.057,0.225),vec3(0.351,0.331,0.616));
  sdLine(dis_col,pos,vec2(-0.687515,-0.871181),vec2(-0.800804,-0.800859),vec3(0.055,0.049,0.192),vec3(0.331,0.316,0.584));
  sdLine(dis_col,pos,vec2(-0.727078, 0.837400),vec2(-0.792967, 0.812525),vec3(0.851,0.773,0.682),vec3(0.453,0.390,0.737));
  sdLine(dis_col,pos,vec2(-0.657094, 0.890944),vec2(-0.727080, 0.837365),vec3(0.859,0.780,0.682),vec3(0.475,0.412,0.759));
  sdLine(dis_col,pos,vec2(-0.603768, 0.961718),vec2(-0.657083, 0.890933),vec3(0.857,0.780,0.682),vec3(0.508,0.445,0.794));
  sdLine(dis_col,pos,vec2(-0.589831, 0.999997),vec2(-0.603747, 0.961733),vec3(0.857,0.780,0.682),vec3(0.527,0.467,0.816));
  sdLine(dis_col,pos,vec2(-0.902586, 0.451620),vec2(-0.836020, 0.550739),vec3(0.569,0.553,0.867),vec3(0.618,0.624,0.949));
  sdLine(dis_col,pos,vec2(-0.958157, 0.411244),vec2(-0.902331, 0.451519),vec3(0.506,0.494,0.859),vec3(0.637,0.647,0.957));
  sdLine(dis_col,pos,vec2(-0.988291, 0.406328),vec2(-0.958317, 0.411469),vec3(0.465,0.453,0.851),vec3(0.649,0.663,0.961));
  sdLine(dis_col,pos,vec2(-0.790561, 0.737649),vec2(-0.792976, 0.808576),vec3(0.722,0.694,0.898),vec3(0.859,0.788,0.661));
  sdLine(dis_col,pos,vec2(-0.835941, 0.550741),vec2(-0.790568, 0.737610),vec3(0.708,0.680,0.892),vec3(0.849,0.778,0.680));
  sdLine(dis_col,pos,vec2( 0.124987,-0.012010),vec2( 0.128540,-0.077336),vec3(0.153,0.094,0.125),vec3(0.980,0.929,0.725),vec3(0.082,0.039,0.075),vec3(0.773,0.251,0.153));

  return dis_col;
}

// Function 1518
vec4 BufferCubemap(in sampler2D buffer, in float bufferAspect, in vec3 d) 
{
    vec3 t = 1.0 / min(-d, d);
    vec3 p = d*(-0.5 * max(max(t.x, t.y), t.z));
    
    vec3 n = -sign(d) * step(t.yzx, t.xyz) * step(t.zxy, t.xyz);
    
    vec2 px = vec2(p.z*n.x, p.y) * abs(n.x);
    vec2 py = vec2(-p.x*n.y, -p.z) * abs(n.y);
    vec2 pz = vec2(-p.x*n.z, p.y) * abs(n.z);

    float tx = (step(0.5, n.z)*2.0 + abs(n.x) 
                 + step(0.5, n.x)*2.0) * (1.0 - abs(n.y))
        			+ step(0.5, n.y)*3.0 * abs(n.y);
    
	float ty = (1.0 - (2.0 - 4.0/bufferAspect)) * abs(n.y);
    
    vec2 uv = (vec2(tx, ty) + (px + py + pz) + 0.5) 
        		* vec2(0.25, bufferAspect*0.25);
    
    return texture(buffer, uv, -100.0);
}

// Function 1519
SceneResult Scene_GetDistance( const vec3 vPos )
{
    vec3 vWeaponPos = vPos;
    
    if ( g_playerEnt.fHealth <= 0.0 )
    {    
        float fDeathFall = 0.0;

        // Death
        if( g_playerEnt.fHealth <= 0.0 )
        {
            fDeathFall = 1.0 - (g_playerEnt.fTimer / 1.5);
        }

    	vWeaponPos.y += fDeathFall * 5.0;
    }        
    
    
    if ( g_playerEnt.fUseWeapon == 2.0 )
    {
	    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 5.0 ;
        
        float fDist = Segment( vWeaponPos, vec3(0,-1.0,2.5), vec3(0, -5, 25), .2, 0.2 );
        float fDist2 =  Segment( vWeaponPos, vec3(0, -4.5, 23), vec3(0, -4.5, 25), .1, 0.1 );
        fDist = min( fDist, fDist2 );
        return SceneResult( fDist, MAT_SHOTGUN, vec3(0.0) );    
    }
    
    // pistol
    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 10.0 ;
    
    float fDist = Segment( vWeaponPos, vec3(0,-0.8,0), vec3(0, -5, 20), .1, 0.1 );
	return SceneResult( fDist, MAT_PISTOL, vec3(0.0) );    
    
    //return SceneResult( length(vPos - vec3(0.0, 1.0, 5.0)) - 0.5, MAT_SHOTGUN, vec3(0.0) );
}

// Function 1520
float getDistFrame(vec3 pos)
{
    vec2 asp=Res/Res.x;
    float d=1000.; float d1=1000.;
    d=min(d,abs(getDistBox(pos,vec3(asp+FRAME_D*2.,10000.))));
    d1=min(d1,sqrt(d*d+pos.z*pos.z)-.01);
    d=abs(getDistBox(pos,vec3(asp,10000.)));
    vec3 s; vec2 o1;
    o1 = asp+vec2(-.3333, FRAME_D); s=vec3(.3333,FRAME_D,10000.);
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1, 1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1, 1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1,-1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1,-1),0),s)));
    o1 = asp+vec2( FRAME_D,-.5*asp.y); s=vec3(FRAME_D,.5*asp.y,10000.);
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1, 1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2( 1,-1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1, 1),0),s)));
    d=min(d,abs(getDistBox(pos+vec3( o1*vec2(-1,-1),0),s)));
    d1=min(d1,sqrt(d*d+pos.z*pos.z)-.0055);
    return d1;
}

// Function 1521
float scene(vec3 p)
{
    //return length(p) - 5.0; // sphere
    vec2 q = vec2(length(p.xy) - 5.0, p.z); return length(q) - 4.0; // torus
}

// Function 1522
Dist distScene(vec3 p) {
 
    float time = mod(iTime, LENGTH);
    float x    = time / LENGTH;
    
    float deathStar = distDeathStar(p);
    return Dist(deathStar, 0);
    //float droid     = distDroid(p, vec3(0., 0., -6.), .3);
    
    //float dist = min(deathStar, droid);
    //return Dist(dist, dist == deathStar ? 0 : 1);
    
}

// Function 1523
vec4 map( in vec3 pos, in vec3 cam )
{
    vec4 res = vec4( 1e10, 0.0, 1.0, 0.0 );
    
    /*
	// TODO: Sparks
	float mt = iTime;
    float ut = mt*TAU;
    float dh = 1.0 - mt;
    float bn = 0.5;
    vec3 capPos = pos - vec3(mt, abs(cos(mt*TAU))*dh*max(((1.0-floor(mt/0.25))),bn), 1.0);
    mt += 0.05;
    ut = mt*TAU;
    dh = 1.0 - mt;
    vec3 capPos2 = pos - vec3(mt, abs(cos(mt*TAU))*dh*max(((1.0-floor(mt/0.25))),bn), 1.0);
    vec4 capSD = sdCapsule( vec3(0.0,0.0,0.0), capPos, capPos2, 0.005 );
    capSD.y = 201.0;
    res = opU( capSD, res);*/
    
    const float num_monitors = 3.0;
	float angleY = TAU / 10.0;
    float angleX = angleY / 2.0;
    const float num_stacks = 2.0;
    for(int i = 0; i < int(num_monitors * num_stacks); ++i)
    {
        int k = i / int(num_monitors);
        vec3 posMon = vec3(abs(pos.x), pos.y, abs(pos.z));
        vec3 signPos = vec3(sign(pos.x), 1.0, sign(pos.z));

        float cur_angle = angleY*float((i+1)%3);
        mat3 rotY = mat3(vec3(cos(cur_angle), 0.0, -sin(cur_angle)),
                         vec3(0.0, 		  1.0, 0.0),
                         vec3(sin(cur_angle),  0.0, cos(cur_angle) ));
        posMon *= rotY;
        posMon -= vec3(0.0, 0.55 + float(k)*0.5, 1.5);
        cur_angle = angleX*float(k+1);
        mat3 rotX = mat3(vec3(1.0, 0.0,      0.0),
                         vec3(0.0, cos(cur_angle), -sin(cur_angle)),
                         vec3(0.0, sin(cur_angle), cos(cur_angle) ));
        posMon *= rotX;
		
        vec4 mon = sdOldMonitor(posMon, signPos, float(i)*3.0);
        if(mon.y > 199.5 && mon.y < 210.5)
        {
            mon.y = 200.0 + float(i);
        }
		res = opU( mon, res);
    }
   	
    return res;
}

// Function 1524
vec3 uv_unmap(vec2 uv, vec4 plane)
{
    return uv_unmap(uv, plane, dominant_axis(plane.xyz));
}

// Function 1525
float tScene(vec2 o, vec2 d, int it)
{
    float h = 9., t = 0.;
    while (it-- > 0 && abs(h) > 1e-4 * t)
        t += (h = dScene(o + d * t)) * .9;
    return min(t, 1e3);
}

// Function 1526
vec4 orbitDist(int seed, vec2 p, sampler2D ch){
    float col = 0.5;//Hash(seed);
    float d = 1e9;
    
    vec3 z = vec3(rand4(seed).zw*2.-1.,0);
    float j = 0.0;
    for(j = 0.0;  j < mIters; j++) {
        iter(z,col,seed,ch);
        d = min(d,length(z.xy-center-vec2(1,-1)*p/scale)*scale);
    }
    return vec4(get_pallete(col), d);
    
}

// Function 1527
float distSphere(vec3 pos)
{
    vec3 spp = spPos;
    spp.y *= sin(iTime);
    return length(pos - spp) - size;
}

// Function 1528
vec2 map_large_flame(vec3 p)
{
    const float scale = 2.;
    p *= 1./scale;
    p.z += 6.;

    float loop = g_entities.flame.loop;
    float angle_jitter = hash(g_entities.flame.loop) * 360.;

    vec3 ofs = vec3(-.5, -.5, 0.);
    vec3 p1 = rotate(p, angle_jitter + p.z * (360./16.)) + ofs;
    float dist = sdf_cone(p1, 2., 14.);
    
    ofs = vec3(1., 1., 0.);
    p1 = rotate(p, angle_jitter + p.z * (360./32.)) + ofs;
    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);

    ofs = vec3(-.75, -.75, -1.5);
    p1 = rotate(p, angle_jitter + 180. - p.z * (360./32.)) + ofs;
    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);

    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 5), 3.25, 1.5), 2.);

    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));
    p1 = vec3(loop_rotation * p.xy, p.z);
    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2, 2, mix(8., 20., loop)), .25));
    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2, 1, mix(12., 22., fract(loop + .3))), .25));
    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1,-2, mix(10., 16., fract(loop + .6))), .25));

    return vec2(dist*scale, MATERIAL_FLAME);
}

// Function 1529
void setScene() {
	setCube(0.0, cubePos0, cubeDir0);
	setCube(1.0, cubePos1, cubeDir1);
	setCube(2.0, cubePos2, cubeDir2);
	setCube(3.0, cubePos3, cubeDir3);
	setCube(4.0, cubePos4, cubeDir4);
}

// Function 1530
float mapAndCap(in float value, in float istart, in float istop, in float ostart, in float ostop) {
    float v = map(value, istart, istop, ostart, ostop);
    v = max( min(ostart,ostop), v);
    v = min( max(ostart,ostop), v);
    return v;
}

// Function 1531
vec2 map3sd(vec2 z)
{
  vec2 z2 = 0.5*z*z;
  return vec2(sqrt(1.0-z2.y)*z.x, sqrt(1.0-z2.x)*z.y);
}

// Function 1532
vec2 map(vec3 p) 
{
    vec2 nr = near(body(p - vec3(0,-22.5,1.2)),neck(p));
    nr = near(nr,pickups(p - vec3(0,-21.7,0.6)));
    nr = near(nr,bridge(p - vec3(0,-25.5,0.24)));
    nr = near(nr,tuners(p - vec3(-0.2,4.,0.48)));
    nr = near(nr,selector(p - vec3(3.8,-23.5,-.1)));
    nr = near(nr,knob(p - vec3(3.5,-25.5,-0.0)));
    nr = near(nr,strings(p));    
    nr = near(nr,tree(p - vec3(0.5,3,0.46)));
    nr = near(nr,strap(p - vec3(0.,-32.,1.2)));
    p.xy *= rot(-.5);
    nr = near(nr,strap(p - vec3(2.7,-13.4,1.2)));
    return nr;
}

// Function 1533
vec3 map_box_pm(vec3 ro, float d) {
    return vec3(0.);
}

// Function 1534
float BallSDF( vec3 pos )
{
    return length(pos-ballPos)-ballRad;
}

// Function 1535
vec3 envMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.25;
    rd *= 3.;
    
    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.
    
    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.
    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25+.25); 
    
}

// Function 1536
Hit sphereSDF(vec3 p, Sphere s)
{
    return Hit(length(p - s.center) - s.radius, s.color);
}

// Function 1537
void intersectScene(
	vec3 rayOrigin,
	vec3 rayDir,
	inout float rayT,
	inout vec3 geomNormal)
{
    float z = 1.0;
    float xfactor = .75;
    float yfactor = 1.0;
    
    for (int stepIndex = 0; stepIndex < BALL_AMOUNT; ++stepIndex)
    {	
        float xtime = time + float(stepIndex)*142.;
        float posx = sin(xtime/(2.0+sin(hash(float(stepIndex*1342)))));
        float posy = cos(xtime/(2.0+sin(hash(float(stepIndex*3234)))));
        float posz = tan(xtime/(2.0+tan(hash(float(stepIndex*2323)))))/3.;
		intersectSphere(rayOrigin, rayDir, vec3( posx/xfactor, posy, z+posz), 0.2*(2.0+sin((float(stepIndex*1342))))/2., rayT, geomNormal);
    }
}

// Function 1538
vec3 TonemapFloat3( vec3 x )
{
    vec3 r;
    r.x = TonemapFloat( x.x );
    r.y = TonemapFloat( x.y );
    r.z = TonemapFloat( x.z );
    
    return r;
}

// Function 1539
SceneResult Scene_Subtract( SceneResult a, SceneResult b )
{
    if ( a.fDist < -b.fDist )
    {
        b.fDist = -b.fDist;
        return b;
    }
    
    return a;
}

// Function 1540
void homerArmsSDF(vec3 p, float swingTime, inout vec2 head) {
    vec3 leftArmPoint = translate(p, vec3(-6,-13,0));
    leftArmPoint.xy = rotate(leftArmPoint.xy, PI * 0.25);
    leftArmPoint.yz = rotate(leftArmPoint.yz, PI * PRECOMPUTEDTIME * -0.15);
    
    vec2 leftArm = makeAnArm(leftArmPoint);
    
    add(head, leftArm);
    
    vec3 rightArmPoint = translate(p, vec3(7,-13,2));
    rightArmPoint.xy = rotate(rightArmPoint.xy, PI * 0.05);
    
    rightArmPoint.yz = rotate(rightArmPoint.yz, PI * PRECOMPUTEDTIME * 0.5);
    
    vec2 rightArm = makeAnArm(rightArmPoint);
    
    add(head, rightArm);
}

// Function 1541
float crossSDF(vec2 st, float s)
{
    vec2 size = vec2(.25,s);
    return min(rectSDF(st,size.xy), rectSDF(st,size.yx));
}

// Function 1542
float distSphere( vec3 p, float s )
{
    // Standard UV wrapping for a sphere
    float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / s / .5;
    float v = (.5 - asin(p.y) / 3.14159) / s / .5;
    float disp = texture( iChannel0,
                           vec2(u,v)).r;
    
    // The exponential smooths out the displacement so we don't have crazy looking poles
	return length(p)-s - (disp * 0.1 * (s / .5) * exp(1. - abs(p.y))/exp(1.));
}

// Function 1543
geometry map(vec3 p) {
    vec3 bp = p;
    
    geometry box, s;
    
    float nn = n(vec3(p.x * abs(.01 ), p.z * 0.01, 0.)) * (max(4., abs(p.x * .01)));
    //nn = min(nn, 8.);
    nn *= smoothstep(0., 1., iTime) / 2.;
    nn *= smoothstep(0., 1., abs(p.x) * .002);
    
    nn *= sin(p.x * .004);

    p.y += 71.;
    p.y *= .46;
    p.y -= mix(0., 50., nn);

    s.dist = fBox(p, vec3(1e9, .2, 1e9));
    s.color = vec4(0.0, 0., .0,0.);
    
    s.specular = .5;
    s.diffuse = 1.5;
    s.materialIndex = 0.;
    s.glow = 0.;
    
    bp.x += 175.;
    
    vec2 gr = pMod2(bp.xz, vec2(800.));
    
    bp += rand(gr.xyy) * 200.;
    
    box = s;
    box.color = vec4[](
        vec4(1., 0., 0., 0.),
        vec4(0., 0.8, 1., 0.)
    )[int(floor(rand(gr.xyx) + .5))];
    
    box.diffuse = 1.;
    box.specular = 0.0;
    box.materialIndex = 1.;
    box.dist = fBox(bp, vec3(20., 3320., 20.));
    box.glow = 1.;
    
    s = geoU(s, box);   
    
    return s; 
}

// Function 1544
float sdf_9(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_torus(pos, vec3(2, -2, 0)));
	t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));
    return t;
}

// Function 1545
float MapMountains(in vec3 p)
{       
  return p.y -  GetMountainHeight(p);
}

// Function 1546
float mapstage8 (in vec3 p)
{
   
   vec3 q= mod (p+2.0,4.0) - 2.0;
   float d1 = length(q) - 1.0;   
   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; 
   float d2 = p.y + 1.0;
   
   //size of transition between blending area
   //orginal uses a constant but thought its more illustrative with a animation
   float k = abs(sin (iTime));
   
   //determine blending area is distance between two objects
   float h= clamp (0.5 + 0.5 * (d1-d2)/k,0.0, 1.0);
    
   //mix the two values together based on the blending variable
   //the second half of the code seems to increase speead??
   return mix (d1,d2, h) - k* h *(1.0-h);
}

// Function 1547
float planeSDF(vec3 p) {
    vec3 position = vec3(0,-2,0);
    vec3 position2 = p - position;
    
    vec3 d = abs(position2) - vec3(5.0, 0.1, 5.0);

    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);

    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 1548
float scene(vec3 p)
{
	return min(100.-length(p) , abs(flame(p)) );
}

// Function 1549
float map(in vec3 p)
{
	orbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;
	return NewMenger(p);
}

// Function 1550
float hyperDistPG(vec3 u, vec3 v) {
    return asinh(hyperDot(u, v));
}

// Function 1551
vec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir, out float fSceneDistance )
{
	Intersection primaryInt;
    RaymarchScene( vRayOrigin, vRayDir, primaryInt );

     float fFogDistance = 0.0;
    vec3 vResult = vec3( 0.0 );
    
    float fSunDotV = dot(GetSunDir(), vRayDir);    

    if ( primaryInt.m_objId == OBJ_ID_SKY )
    {
        vResult = GetSkyColour( vRayDir, 1.0 );
        fFogDistance = k_fFarClip;
    }
    else
    {
        Intersection waterInt;
        TraceWater( vRayOrigin, vRayDir, waterInt );

        vec3 vReflectRayOrigin;
        vec3 vSpecNormal;
        vec3 vTransmitLight;

        Surface specSurface;
        vec3 vSpecularLight = vec3(0.0);

    #ifdef ENABLE_WATER
        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );
        vec2 vFlowRate = vFlowRateAndFoam.xy;
        #ifdef ENABLE_FOAM
        float fFoam = vFlowRateAndFoam.z;
        float fFoamScale = 1.5;
        float fFoamOffset = 0.2;
        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );
        fFoam = fFoam * fFoam * 0.5;
        #else
        float fFoam = 0.0;
        #endif            

        float fWaterFoamTex = 1.0;
        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );
        
        if( vRayDir.y < -0.01 )
        {
            // lie about the water intersection depth
            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) / vRayDir.y);
        }
        
        if( waterInt.m_dist < primaryInt.m_dist )
        {
            fFogDistance = waterInt.m_dist;
            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;

            vReflectRayOrigin = waterInt.m_pos;
            vSpecNormal = vWaterNormal;

            vec3 vRefractRayOrigin = waterInt.m_pos;
            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );

            Intersection refractInt;
            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); // note : dont need sky

            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );
            fFoam *= 1.0 - fEdgeAlpha;
            
            // add extra extinction for the light travelling to the point underwater
            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );

            specSurface.m_pos = waterInt.m_pos;
            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); // would rather have SSS for foam
            specSurface.m_albedo = vec3(1.0);
            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );

            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));
  			float fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);
            float fGlossFactor = exp2( -fFilterWidth * 0.3 );
            specSurface.m_gloss = 0.99 * fGlossFactor;            
            specSurface.m_specScale = 1.0;
            
            vec3 vSurfaceDiffuse = vec3(0.0);

            float fSunShadow = 1.0;
        #ifdef ENABLE_WATER_RECEIVE_SHADOW
            fSunShadow = GetSunShadow( waterInt.m_pos );
        #endif
            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);
            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);

            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);
            vTransmitLight = vRefractLight.rgb;
            vTransmitLight += vInscatter;
            vTransmitLight *= vExtinction;   


    #ifdef ENABLE_FOAM
            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);// * (1.0 - fWaterFoamTex));
            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );
            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);
    #endif
        }
        else
    #endif // #ifdef ENABLE_WATER
        {
            fFogDistance = primaryInt.m_dist;

            Surface primarySurface;
            GetSurfaceInfo( primaryInt, primarySurface );

            vSpecNormal = primarySurface.m_normal;
            vReflectRayOrigin = primaryInt.m_pos;
            
            primarySurface.m_gloss = clamp( 0.9 - (primarySurface.m_albedo.g - primarySurface.m_albedo.r) * 5.0, 0.0, 1.0);

            float fWaterLine = 0.08;
            float fWetness = clamp( 1.0 - (vReflectRayOrigin.y + 0.04) / fWaterLine , 0.0, 1.0);
            primarySurface.m_gloss = mix( primarySurface.m_gloss, 0.95, fWetness );
            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );
            
            //primarySurface.m_albedo = mix( primarySurface.m_albedo, vec3(1.0, 0.0, 0.0), fWetness );

            
            vTransmitLight = vec3(0.0);
            float fSunShadow = 1.0;
       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW
            fSunShadow = GetSunShadow( primaryInt.m_pos );
       #endif
            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);
            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);
            vTransmitLight *= primarySurface.m_albedo;
            specSurface = primarySurface;
        }

        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );
        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );

        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );
        
        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );

        vSpecularLight += vReflectLight;
        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );
    }
    

    float fCloudScale = 0.0;
    if ( fFogDistance >= k_fFarClip )
    {
        fFogDistance = 100.0;
        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;
        fCloudScale = 1.0;
    }    
    
    vec3 vFogColour = GetSkyColour(vRayDir, fCloudScale);    
    
    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );
    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );
    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);
    
    fSceneDistance = fFogDistance;
    
    return vResult;
}

// Function 1552
vec2 sceneK(vec3 start,vec3 end,vec3 dir)
{
    float dist = 0.0;
    dist = scene(start);
    
    //vec3 gs = calcGradient(start);
    //vec3 ge = calcGradient(end);
    //vec3 gs = calcGradientCheap(start,dist);
    //vec3 ge = calcGradientCheap(end,dist);
    //float fds = abs(dot(gs,dir));
    //float fde = abs(dot(ge,dir));
    float fds = calcGradientDirAbs(start, dir);
    float fde = calcGradientDirAbs(end, dir);

    float lam = max(fds,fde);
    
    
    return vec2(lam,dist);
}

// Function 1553
void initScene(int cubei)
{
        if (cubei==0) // static floor
        {
            pos = vec3(0,-1,5);
            vel = vec3(0.,0.,0.);
            rotvel = vec3(0.,0.,0.);
            quat = vec4(0.0,0.0,0.0,1.0);
            return;
        }
    
    
    	cubei--;
        float cubeif = float(cubei);
    	int div = 5;
    	vec3 ro = vec3(0.,PI*(float(cubei)*2.0)/float(div),0.);
    	pos = rotateAxis(ro,   vec3(0.0,1.0+float(cubei/div)*2.0,2.5));
    
        quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);
    
        vel = vec3(-0.00,0.0,0.00);
        rotvel = vec3(cubeif*-0.001*cos(float(iFrame)),0.0,cubeif*-0.001); // randomize start setup
    
    	if (cubei==CUBECOUNT-2) // thrown cube
        {
            pos = vec3(16.,2.0,-1.0+sin(float(iFrame)*1.2)); // randomize 
            vel = vec3(-0.37,0.14+sin(float(iFrame))*0.03,0.0);
        }
        
}

// Function 1554
float manhattanDistance(vec3 p1, vec3 p2) {
	float d1 = abs(p1.x - p2.x);
	float d2 = abs(p1.y - p2.y);
	float d3 = abs(p1.z - p2.z);
	return d1 + d2 + d3;
}

// Function 1555
Obj getDist(vec3 p) 
{    
    float boxDist = sdBox(p-vec3(-3, 2, -12), vec3(3, 4, 3));
    float boxDist2 = sdBox(p-vec3(-14, 2, 0), vec3(3, 4, 3));    
    float boxDist3 = sdBox(p-vec3(-3, 2, 12), vec3(3, 4, 3));  
    float mengerSpongeDist = sdMengerSponge(p - vec3(10,2, 0));
       
    float height = -2.;
    float planeDist = p.y - height;
   
    Obj obj = Obj(GROUND, planeDist, p, vec3(0.));
    if (boxDist < planeDist)
        obj = Obj(BOX, boxDist, p, vec3(0.));
    
    if (boxDist2 < planeDist && boxDist2 < obj.dist)
        obj = Obj(BOX2, boxDist2, p, vec3(0.));
    
    if (boxDist3 < planeDist && boxDist3 < obj.dist)
        obj = Obj(BOX3, boxDist3, p, vec3(0.));
    
    if (mengerSpongeDist < planeDist && mengerSpongeDist < obj.dist)
        obj = Obj(MENGERSPONGE, mengerSpongeDist, p, vec3(0.));

    return obj;
}

// Function 1556
float scene(vec3 p)
{
    float retVal =  opRep (p, vec3 (2.0), vec3 (1.0));
    float retVal1 = max (retVal, -p.x + 1.0);
    float retVal2 = max (retVal, p.x + 1.0);
    float retVal3 = max (retVal, -p.y + 1.0);
    float retVal4 = max (retVal, p.y + 1.0);
    return min (min (retVal3, retVal4), min (retVal1, retVal2));
}

// Function 1557
vec4 dist_grid(vec3 pos) {
    vec3 dp1 = abs(fract(pos+0.5)-0.5);
    vec3 dp2 = vec3(
        min(dp1.x,dp1.y),
        max(dp1.x,dp1.y), 
        dp1.z);
    vec3 dp3 = vec3(
        dp2.x,
        max(dp2.y,dp2.z), 
        min(dp2.y,dp2.z));
    float dist = length(max(vec2(0.00,0.00),vec2(dp3.x,dp3.z) -0.03)) - 0.01;
    return vec4(dp3, dist);
}

// Function 1558
float sphereSDF(vec3 p) {
    return length(p) - 1.0;
}

// Function 1559
vec2 map( in vec3 pos ) {
    float d = length(pos);
    float fft = 0.8*texture(iChannel0, vec2((d/32.0),0.3) )[0];	
	return vec2(mandel3D(pos*1.5,fft),fft);
}

// Function 1560
vec3 map_Ssph_norm(vec3 ro) { 
    return normalize(ro - Ssphere.xyz); 
}

// Function 1561
void reinhardTonemap(inout vec3 color
){color *= 8.0
 ;//color  = max0(color - 0.005)
 ;color  = color / (1.0 + color) * 1.08
 ;float luminance = dot(color, vec3(0.2125, 0.7154, 0.0721))
 ;color = mix(vec3(luminance), color, 1.0);}

// Function 1562
vec4 depth_map(vec2 coord){
    return texture(iChannel1, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale));
}

// Function 1563
vec2 kodosGlassSDF(vec3 point) {
    float swingTime = 0.0;
    swingTime = PRECOMPUTEDKODOSTIME;
    
    vec3 kodosPoint = translate(point, vec3(4.,4,KODOSLIVEHERE));
    vec3 headPoint = translate(kodosPoint, vec3(0,0,0));
    vec2 dome = vec2(sdRoundCone( headPoint, 12., 14.0, 19.0), 8.0);
    vec2 domeSlice = vec2(sdPlane(translate(kodosPoint, vec3(0,-4,0)), normalize(vec4(0,1,0,1))), KODOSGREEN);
    diff(dome, domeSlice);
    vec3 pointyBitPoint = translate(kodosPoint, vec3(0,35,0));
    vec2 pointyBit = vec2(sdCappedCone(pointyBitPoint, 4., 2.5, 0.0), 8.0);
    add(dome, pointyBit);
    return dome;
}

// Function 1564
float map(vec3 p) {
  float k;
  vec4 p4 = map4(p,k);
  float R = sqrt(TRATIO.x*TRATIO.x/dot(TRATIO,TRATIO));
  float d = fTorus(p4,R);
  return d/k;
}

// Function 1565
vec3 doBumpMap( in vec3 pos, in vec3 nor )
{
    const float e = 0.001;
    const float b = 0.005;
    
	float ref = roundcube( 7.0*pos, nor );
    vec3 gra = -b*vec3( roundcube(7.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,
                        roundcube(7.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,
                        roundcube(7.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;
	
	vec3 tgrad = gra - nor*dot(nor,gra);
    
    return normalize( nor-tgrad );
}

// Function 1566
mat4 scene(vec3 raydir, vec3 offset, float time)
{
 	const int NUMSPHERES = 6; // Cannot be greater than 6, sphere[] below hardcodes 6 indices 
    const float rate = 0.1;
	vec4 spheres[NUMSPHERES];
    vec4 fronthits[NUMSPHERES];
    vec4 backhits[NUMSPHERES];
    vec2 hitdp[NUMSPHERES];
    
    spheres[0] = vec4( VX*sin(1.0*rate*time)+DX, sVX*sin(0.1*rate*time)+sDX, 0.0, RADIUS);
    spheres[1] = vec4(-VX*sin(1.2*rate*time)-DX, sVX*sin(0.12*rate*time)+sDX, sVX*sin(0.11*rate*time)+sDX, RADIUS);
    spheres[2] = vec4(-sVX*sin(0.1*rate*time)+sDX, VX*sin(1.1*rate*time)+DX,  0.0, RADIUS);
    spheres[3] = vec4(sVX*sin(0.11*rate*time)+sDX, -VX*sin(1.5*rate*time)-DX, 0.0, RADIUS);
    spheres[4] = vec4(sVX*sin(0.09*rate*time)+sDX, 0.0, VX*sin(1.3*rate*time)+DX, RADIUS);
    spheres[5] = vec4(sVX*sin(0.1*rate*time)+sDX, 0.0, -VX*sin(0.8*rate*time)-DX, RADIUS);
    vec4 minfronthit = vec4(0.0, 0.0, 0.0, MAX_DEPTH);
    vec4 avgfronthit = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 minbackhit = vec4(0.0, 0.0, 0.0, -MAX_DEPTH);
    vec4 avgbackhit = vec4(0.0, 0.0, 0.0, 0.0);
    float count = 0.0;
    float backcount = 0.0;
    for(int i = 0; i < NUMSPHERES; i++) {
  		hitdp[i] = sphere(raydir, offset, spheres[i]);
        
    	vec3 frontpos = hitdp[i].x*raydir + offset;
    	vec3 backpos = hitdp[i].y*raydir + offset;
    	fronthits[i] = vec4(normalize(frontpos - spheres[i].xyz), hitdp[i].x);
    	backhits[i] = vec4(normalize(spheres[i].xyz - backpos), hitdp[i].y);
        
        if(fronthits[i].w > 0.0) {    
            if(count < 1.0) {
                avgfronthit = fronthits[i];
                count = 1.0;
            }
            else {
                if(abs(fronthits[i].w - avgfronthit.w) < THRESH_DEPTH) {
                	count += 1.0;
            		avgfronthit += fronthits[i];
                }
                else if(fronthits[i].w < minfronthit.w) {
                    count = 1.0;
                    avgfronthit = fronthits[i];
                }
            }
            
            if(fronthits[i].w < minfronthit.w) {
            	minfronthit = fronthits[i];
            }
        }
        
        if(backhits[i].w > 0.0) {
            if(backcount < 1.0) {
                avgbackhit = backhits[i];
                backcount = 1.0;
            }
            else {
                if(abs(backhits[i].w - avgbackhit.w) < THRESH_DEPTH) {
                	backcount += 1.0;
            		avgbackhit += backhits[i];
                }
                else if(backhits[i].w > minbackhit.w) {
                    backcount = 1.0;
                    avgbackhit = backhits[i];
                }
            }
            
            if(backhits[i].w > minbackhit.w) {
            	minbackhit = backhits[i];
            }
        }
    }
    
    mat4 rval = mat4(vec4(0.0, 0.0, 0.0, -1.0),
                     vec4(0.0, 0.0, 0.0, -1.0),
                     vec4(0.0, 0.0, 0.0, -1.0),
                     vec4(0.0, 0.0, 0.0, -1.0));
    if(count > 0.01 ) {
        if(count < 1.1) {
            rval[0] = vec4(normalize(minfronthit.xyz),minfronthit.w);
        }
        else {
            // smooth the transition between spheres
        	avgfronthit.xyz = normalize(avgfronthit.xyz);
        	avgfronthit.w = avgfronthit.w/count;
            float tt = min(1.0, (avgfronthit.w - minfronthit.w)/(0.4*THRESH_DEPTH));
            vec4 rfronthit = tt*minfronthit + (1.0-tt)*avgfronthit;
            rval[0] = vec4(normalize(rfronthit.xyz),rfronthit.w);
        }
    }
    
    if(backcount > 0.01 ) {
        if(backcount < 1.1) {
            rval[1] = vec4(normalize(minbackhit.xyz),minbackhit.w);
        }
        else {
            // smooth the transition between spheres
        	avgbackhit.xyz = normalize(avgbackhit.xyz);
        	avgbackhit.w = avgbackhit.w/backcount;
            float tt = min(1.0, (minbackhit.w - avgbackhit.w)/(0.4*THRESH_DEPTH));
            vec4 rbackhit = tt*minbackhit + (1.0-tt)*avgbackhit;
            rval[1] = vec4(normalize(rbackhit.xyz),rbackhit.w);
        }
    }
    
    return rval;
}

// Function 1567
vec3 ToneMapping(vec3 color) {

    color = Gamma(color,1.0);

    #if TONEMAP_MODE == TONEMAP_FILMIC
        color = Filmic(color);
    #elif TONEMAP_MODE == TONEMAP_REINHARD
        color = Reinhard(color);
    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD
        color = FilmicReinhard(color);
    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2
        color = Uncharted2(color);
    #elif TONEMAP_MODE == TONEMAP_ACES
        color = ACESFitted(color);
    #endif

    color = clamp(LinearToSRGB(color), 0.0, 1.0);

    return color;
}

// Function 1568
int getMap( vec3 pos ) {	
	vec3 posf = floor( (pos - vec3(32.))  );
    
	float n = posf.x + posf.y*517.0 + 1313.0*posf.z;
    float h = hash(n);
	
	if( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.16 ) ) - 0.8  ) {
        return 0;
	}	
	
	return int( hash( n * 465.233 ) * 16. );
}

// Function 1569
void map_position( inout vec3 col, vec2 coord )
{
    float shape = 0.;
    mat2 I = mat2(1);
    vec2 s0 = mc2sc( gs_map_project( g_game, g_vehicle.localr ) );
    float sr = dot( g_vehicle.localB[0], normalize( g_vehicle.localr ) );

    if( abs( sr ) < .9995 )
    {
        // arrow if heading is defined
        vec2 s1 = mc2sc( gs_map_project( g_game, g_vehicle.localr + g_vehicle.localB[0] ) );
        vec2 ds = normalize( s1 - s0 );
        mat2 M = mat2( ds, perp( ds ) );
        vec2 a = s0 + M * vec2( +6, 0 );
        vec2 b = s0 + M * vec2( -6, -4 );
        vec2 c = s0 + M * vec2( -6, +4 );
        shape = max( shape, aaa_line( I, coord, a, b, 1. ) );
        shape = max( shape, aaa_line( I, coord, b, c, 1. ) );
        shape = max( shape, aaa_line( I, coord, c, a, 1. ) );
    }
    else
    if( sr < 0. )
        // cross if downwards
        shape = max( aaa_line( I, coord, s0 - 5., s0 + 5., 1. ),
                     aaa_line( I, coord, s0 + vec2( +5, -5 ), s0 + vec2( -5, +5 ), 1. ) );
    else
        // ring if upwards
        shape = aaa_ring( I, coord - s0, 10., 1. );

	float phase = .25 + .75 * step( .5, fract( iTime ) );
    col += vec3( 1, .5, .0 ) * shape * phase;
}

// Function 1570
vec2 map(vec3 pos)
{

    float bluesphere = length(vec3(sin(iTime*2.)*1.5,cos(iTime/2.)*2.+.75,cos(iTime*2.)*1.5)-pos)-.25;    
    float redsphere = length(vec3(cos(iTime*2.)*1.5,sin(iTime/2.)*2.+.75,sin(iTime*2.)*1.5)-pos)-.25;

    float ico = sdIcosDodecaStar(vec3(.0,1.+sin(iTime/3.),.0)-pos,1.);
    float plane = pos.y+1.5;    

    // columns           
    vec3 colpos = pos;
    float qa = pModPolar(colpos.xz,numrep+4.);
    colpos.x-=2.4;
    float column = sdCylinder(vec3(0)-colpos, vec3(.145));
    float columnbox = sdBox(vec3(0.,0.6,0)-colpos,vec3(1.5,2.5,1.5));
    float columns = max(column,columnbox);

    //gates: block, then hole
    vec3 boxpos = pos;
    float q = pModPolar(boxpos.xz,numrep);
    boxpos.x-=5.;
    float box = sdRoundBox(boxpos,vec3(.7,3.,1.2),.24);    

    vec3 cypos = pos;
    cypos.y /= 10.;
    cypos.yz = r(cypos.yz,PI/2.);
    cypos.xz = r(cypos.xz,PI/2.);
    cypos.yz = r(cypos.yz,.5);

    q = pModPolar(cypos.yz,numrep);
    cypos.x-=.055;
    cypos.z+=.44;
    cypos.z/=6.5;

    float cyhole = sdCylinder(vec3(0.,0.,.0)+cypos,vec3(.0,.1,.21));
    float gates = max(-cyhole,box);
    float doorway = min(cyhole,box);
    doorway = min(doorway, columns);

    //SDF+matID
    vec2 scene = vec2(10.);
    scene = vec2(smoothMin(scene.x,bluesphere,0.4), scene.x<bluesphere ? scene.y:2.);
    scene = vec2(smoothMin(scene.x,ico,0.4), scene.x<ico ? scene.y:3.);
    scene = vec2(smoothMin(scene.x,redsphere,0.4), scene.x<redsphere ? scene.y:4.);
    scene = vec2(smoothMin(scene.x,plane,.4),scene.x<plane ? scene.y:1.);
    scene = vec2(smoothMin(scene.x,columns,.84),scene.x<columns? scene.y:5.);
    scene = vec2(min(scene.x,gates),scene.x<gates ? scene.y:5.);
    return scene;
}

// Function 1571
float mapDist(vec3 c){
  Shape taft = Building(c);
  return taft.dist;
}

// Function 1572
float fMaterialSDF(float dist, vec4 material)
{
    if(abs(material.x - kMatWoodLog) < 0.1)
    {
        vec2 uv = material.yz;
        float bark = textureLod(iChannel1, uv * 0.05, 0.0).r;
        bark += 0.5 * textureLod(iChannel1, uv * 0.1, 0.0).r;
        float isBark = step(-0.5, uv.y);
        dist -= bark*(0.025*isBark + 0.005);
    }
    else if(abs(material.x - kMatRock) < 0.1)
    {
        vec2 uv = material.yz;
        float rock = textureLod(iChannel1, uv * 0.04, 0.0).r;
        dist -= rock*0.02;
    }
    else if(abs(material.x - kMatCoals) < 0.1)
    {
        vec2 uv = material.zw;
        float disp = textureLod(iChannel1, uv * 0.04, 0.0).r;
        dist -= disp*0.05;
    }
    else if(abs(material.x - kMatGround) < 0.1)
    {
        float groundMat = floor(material.w)/256.0;
    	vec2 uv = material.yz;
        float disp = 0.0;
        disp += 0.25*textureLod(iChannel2, uv * 0.25, 0.0).r;
        disp += 0.15*textureLod(iChannel2, uv * 0.45, 0.0).r;
        dist -= disp * 0.1 * (1.0 - groundMat);
        
        float rock = textureLod(iChannel1, uv * vec2(0.25, 0.1), 0.0).r;
        dist -= rock*0.025*groundMat;
    }
    
    return dist;
}

// Function 1573
float distCylinderXY(vec3 p, vec3 c)
{
    return length(p.xy - c.xy) - c.z;
}

// Function 1574
void sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)
{
    t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));
    float t2;
    obj = 0; // 0 is center sphere
    if((t2 = sphere(pos, 2.0, greenSpherePos)) < t) {
        t = t2;
        obj = 1;
    }
    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {
        t = t2;
        obj = 3;
    }
}

// Function 1575
float map(in float value, in float istart, in float istop, in float ostart, in float ostop) {
    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
}

// Function 1576
vec2 sceneMap(vec3 p, vec3 dir)
	{
		#ifdef SINGLE_UNIT
        	const float bidx = 43578.4534;
			return vec2(getUnitDistance(bidx, p), 1.0+abs(bidx));
		#else 
        #ifdef MULTI_SIMPLE
        	vec3	m0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;
        	vec3	v = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;
			float	bidx0 = blockHash(v);
       		
        	return vec2(getUnitDistance(bidx0, m0), 1.0+abs(bidx0));
        
        	/*vec3	m0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;
        	vec3	block = floor(p/volumeSide) + vec3(24.32, 32.4324, 63.6548);
        	return vec2(getUnitDistance(block, m0), 1.0);*/
        #else
        #ifdef FAST_METHOD
        	vec3	m0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,
                	m1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,
					m2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,
					m3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,
					m4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,
					m5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,
					m6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,			
					m7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;	
        	vec3	v = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;
            float	bidx0 = blockHash(v);
        	float 	d = min(getUnitDistance(bidx0, m0),
						min(getUnitDistanceSimple(m1),
						min(getUnitDistanceSimple(m2),
						min(getUnitDistanceSimple(m3),
						min(getUnitDistanceSimple(m4),
						min(getUnitDistanceSimple(m5),
						min(getUnitDistanceSimple(m6),
							getUnitDistanceSimple(m7) )))))));
        	return vec2(d, 1.0+abs(bidx0));
        #else
			vec3	m0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,
					m1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,
					m2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,
					m3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,
					m4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,
					m5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,
					m6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,			
					m7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;	
			vec3	v = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;
			float	bidx0 = blockHash(v),
					bidx1 = blockHash(v + vec3(sign(dir.x), 0.0, 0.0)),
					bidx2 = blockHash(v + vec3(0.0, sign(dir.y), 0.0)),
					bidx3 = blockHash(v + vec3(0.0, 0.0, sign(dir.z))),
					bidx4 = blockHash(v + vec3(sign(dir.x), sign(dir.y), 0.0)),
					bidx5 = blockHash(v + vec3(0.0, sign(dir.y), sign(dir.z))),
					bidx6 = blockHash(v + vec3(sign(dir.x), 0.0, sign(dir.z))),			
					bidx7 = blockHash(v + vec3(sign(dir.x), sign(dir.y), sign(dir.z)));		
			float 	d = min(getUnitDistance(bidx0, m0),
						min(getUnitDistance(bidx1, m1),
						min(getUnitDistance(bidx2, m2),
						min(getUnitDistance(bidx3, m3),
						min(getUnitDistance(bidx4, m4),
						min(getUnitDistance(bidx5, m5),
						min(getUnitDistance(bidx6, m6),
							getUnitDistance(bidx7, m7) )))))));
        	/*vec3	m0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,
					m1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,
					m2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,
					m3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,
					m4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,
					m5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,
					m6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,			
					m7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;	
			vec3	v = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0,
        			block1 = v + vec3(sign(dir.x), 0.0, 0.0),
					block2 = v + vec3(0.0, sign(dir.y), 0.0),
					block3 = v + vec3(0.0, 0.0, sign(dir.z)),
					block4 = v + vec3(sign(dir.x), sign(dir.y), 0.0),
					block5 = v + vec3(0.0, sign(dir.y), sign(dir.z)),
					block6 = v + vec3(sign(dir.x), 0.0, sign(dir.z)),			
					block7 = v + vec3(sign(dir.x), sign(dir.y), sign(dir.z));
        	float 	d = min(getUnitDistance(v, m0),
						min(getUnitDistance(block1, m1),
						min(getUnitDistance(block2, m2),
						min(getUnitDistance(block3, m3),
						min(getUnitDistance(block4, m4),
						min(getUnitDistance(block5, m5),
						min(getUnitDistance(block6, m6),
							getUnitDistance(block7, m7) )))))));*/
			return vec2(d, 1.0+abs(bidx0));
        #endif
		#endif
        #endif
	}

// Function 1577
float noiseDist(vec3 p) {
	p = p / NoiseScale;
	return (FBM(p) - NoiseIsoline) * NoiseScale;
}

// Function 1578
vec3 ascene(in vec3 ro, in vec3 rd){
    float t = map(ro,rd);
    vec3 col = vec3(0);
    if (t==1000.0){col +=0.5;}
    
    else {
        vec3 loc = t*rd+ro;
        loc = loc*0.5;
        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));
    }
    return col;
}

// Function 1579
float Distance(vec3 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, float r)
{
	vec2 pos=Position(p.z,a,b,c,d);	
	float radius=max(5.0,r+sin(p.z*e.x)*e.y)/10000.0;
	return radius/dot(p.xy-pos,p.xy-pos);
}

// Function 1580
vec2 map(vec3 p, float sol) {
	vec2 res = vec2(MAXDIST,-1.);
    vec3 q = p-vec3(0,0,T*speed);
	float df = fbmd(q*2.25,oct);//turn up or down depending on system (octaves)
    df -= .65; // amount of decay
    float dt = df*.03;
    float f = q.y-.05;
    if(f<res.x) res = vec2(f,1.);
    
	float xd= pMod1(q.z,50.);
    float yd= pMod1(q.x,50.);
    pModPolar(q.zx,6.);
    pMirrorOctant(q.zx,vec2(12., 5.));  
    pMirrorOctant(q.xz,vec2(5.,15));   
  	q.x = - abs(q.x)+2.;
    
    float id= pMod1(q.z,2.);
   
    float wall = fBox(q,vec3(.25,5.,5.));
    wall = max(wall,df/1.15);
    wall = min(fBox(q+vec3(1.5,0.,0.),vec3(.25,.2,5.)),wall);
    wall = min(fBox(q+vec3(2.,0.,0.),vec3(.5,.1,5.)),wall);

    vec3 qb = vec3(q.x,q.y,mod(fract(q.z)+.5,1.)-.5);
    wall = min(fBox(qb+vec3(1.5,0.,0.),vec3(.05,1.2,.05)),wall);

    float lits = length(qb+vec3(1.5,-1.35,0.))-.05;
    if (lits<res.x && sol==1.) {
        res = vec2(lits,6.);
    	glow += .0025/(.000005+lits*lits);
    }
    
    vec3 qr = q;
    float roof = fBox(qr-vec3(2.75,4.5,0.),vec3(3.,.1,5.));
    vec3 q2 = q;
    q2.z = abs(q2.z)+.6;

    float window = fBox(q2-vec3(0,.99,0),vec3(.4,1.,1.));
    window=min(fCyl(q2.zyx-vec3(0,1.99,0.),1.,.4),window);

    float tip = fBox(q2-vec3(0,5.,0),vec3(.08,.25,.8));
    tip=min(fCyl(q2.zyx-vec3(0,5.24,0.),.8,.08),tip);
    roof = min(tip,roof);
    
    float mainwall = fOpDifferenceStairs(wall,window,.25,3.);
    float building = fOpUnionStairs(mainwall,roof,.25,3.)-dt;

    if(building<res.x) res = vec2(building,2.);
    
    return res;
}

// Function 1581
vec2 homersHeadSDF(vec3 p, float swingTime) {
    vec2 head = vec2(sdVerticalCapsule(p,5.0,5.0), HOMERYELLOW);
    
    float leftEyeSpacing = -1.5;
    
    float eyeSize = 1.8;
    
    vec3 origP = p;
    
    vec3 eyePt = p;
    eyePt.x = abs(eyePt.x);
    eyePt = translate(eyePt, vec3(0,-1.5,-1.6));
    eyePt.yz = rotate(eyePt.yz, PI * -0.15);
    vec2 eyes = vec2(sdSphere(translate(eyePt, vec3(abs(leftEyeSpacing),2.5,-4)), eyeSize), WHITEASMYSOUL);
    
    p.x = -abs(p.x);
    
    vec2 leftTopEyelid = vec2(sdSphere(translate(p, vec3(leftEyeSpacing,2.5,-4)), eyeSize+.1), HOMERYELLOW);
    vec2 leftBottomEyelid = vec2(sdSphere(translate(p, vec3(leftEyeSpacing,2.5,-4)), eyeSize+.1), HOMERYELLOW);
    
    vec3 pupilP = eyePt;
    vec2 pupils = vec2(sdSphere(translate(pupilP, vec3(abs(leftEyeSpacing)+0.15,2.15+(swingTime*0.05),-5.3)), 0.5), BLACKASNIGHT);
    
    vec3 eyeSlicePoint = translate(p, vec3(0,3.5,0));
    eyeSlicePoint.yz = rotate(eyeSlicePoint.yz, PI * abs(PRECOMPUTEDBLINKTIME) * -0.25);
    vec2 pln = vec2(sdPlane(eyeSlicePoint, normalize(vec4(0,1,0,1))),1.0);
    
    diff(leftTopEyelid,pln);
    
    vec3 eyeSlicePointB = translate(p, vec3(leftEyeSpacing,1.5,-2));
    eyeSlicePointB.yz = rotate(eyeSlicePointB.yz, PI * abs(PRECOMPUTEDBLINKTIME) * 0.5);
    vec2 plnB = vec2(sdPlane(eyeSlicePointB, normalize(vec4(0,-1,0,1))),1.0);
    
    diff(leftBottomEyelid,plnB);
    
    vec2 nose = vec2(sdCapsule(p, vec3(0.0,1.0,0.0), vec3(0.0,1.0,-6.5), 1.0), HOMERYELLOW);
    
    vec3 neckP = translate(p, vec3(0,-3,1));
    neckP.yz = rotate(neckP.yz, PI * -0.95);
    vec2 neck = vec2(sdRoundCone(neckP, 3.0, 3.5, 5.0), HOMERYELLOW);
    
    // hair
    vec3 a = translate(p, vec3(0,8,-1));
    vec3 b = translate(p, vec3(0,8,1));
    vec2 reset = p.yz;
    
    a.yz = rotate(a.yz, PI * 0.5);
    b.yz = rotate(b.yz, PI * 0.5);
    
    // Top Hairs
    vec2 d5 = vec2(sdTorus(a, vec2(2.75,0.3)), BLACKASNIGHT);
    vec2 d6 = vec2(sdTorus(b, vec2(2.75,0.3)), BLACKASNIGHT);
    
    vec2 lefttEyeBrow = vec2(sdTorus(translate(p, vec3(-1.6,4.5,-4)), vec2(1,0.5)), HOMERYELLOW);
    
    vec2 beard = vec2(sdSphere(translate(p, vec3(0,-2,-3)), 3.5), BROWNBEARD);
    
    vec3 mouthPoint1 = translate(p, vec3(0,-3,-4.0));
    mouthPoint1.yz = rotate(mouthPoint1.yz, PI * 0.15);
    vec2 d11 = vec2(sdTorus(mouthPoint1, vec2(2,0.5)), BROWNBEARD);
    
    beard =  vec2(opSmoothUnion(beard.x, d11.x, 0.25), BROWNBEARD);
    
    vec3 mouthPoint2 = translate(p, vec3(0,-2.15,-4.25));
    mouthPoint2.yz = rotate(mouthPoint2.yz, PI * 0.05);
    vec2 d12 = vec2(sdTorus(mouthPoint2, vec2(2.1,0.7)), BROWNBEARD);
    
    beard =  vec2(opSmoothUnion(beard.x, d12.x, 0.75), BROWNBEARD);
    
    vec3 mouthPoint3 = translate(p, vec3(0,-3.5,-4.25));
    mouthPoint3.yz = rotate(mouthPoint3.yz, PI * 0.05);
    vec2 cylMouth = vec2(sdTorus(mouthPoint3, vec2(2.1,0.7)), BLACKASNIGHT);
    
    vec3 earPoint1 = translate(p, vec3(-5,2,0));
    earPoint1.xy = rotate(earPoint1.xy, PI * 0.5);
    earPoint1.yz = rotate(earPoint1.yz, PI * -0.15);
    earPoint1.x *= 0.75;
    vec2 leftEar = vec2(sdTorus(earPoint1, vec2(0.75,0.4)), HOMERYELLOW);
    
    vec3 sidehairP = p;
    vec2 d15 = vec2(sdCapsule(sidehairP, vec3(-5,6,-1), vec3(-4.75,4,-2), 0.25), BLACKASNIGHT);
    vec2 d16 = vec2(sdCapsule(sidehairP, vec3(-5,6,-1), vec3(-5,4,0), 0.25), BLACKASNIGHT);
    vec2 d17 = vec2(sdCapsule(sidehairP, vec3(-5,6,1), vec3(-5,4,0), 0.25), BLACKASNIGHT);
    vec2 d18 = vec2(sdCapsule(sidehairP, vec3(-5,6,1), vec3(-5,4,2), 0.25), BLACKASNIGHT);
    
    
    // Yellow Parts first
    head = vec2(opSmoothUnion(head.x, lefttEyeBrow.x, 0.75), HOMERYELLOW);
    head = vec2(opSmoothUnion(head.x, neck.x, 1.0), HOMERYELLOW);
    
    
    add(head, nose);
    add(head, eyes);
    
    add(head, d5);
    add(head, d6);
    
    vec3 mouthPoint = p;
    
    mouthPoint = translate(p, vec3(0,-3.5,-5));
    mouthPoint.yz = rotate(mouthPoint.yz, PI * 0.05);
    vec2 openMouth = vec2(sdCappedCylinder(mouthPoint, vec2(3,0.5)), BLACKASNIGHT);
    
    vec3 teethPoint = p;
    teethPoint = translate(p, vec3(0,-3.5,-5));
    teethPoint.yz = rotate(teethPoint.yz, PI * 0.1);
    vec2 teethTop = vec2(sdCappedCylinder(translate(teethPoint, vec3(0,0.85,1.75)), vec2(2.5,0.5)), WHITEASMYSOUL);
    vec2 teethBottom = vec2(sdCappedCylinder(translate(teethPoint, vec3(0,-0.75,2)), vec2(2,0.25)), WHITEASMYSOUL);
    
    vec2 slicePln = vec2(sdPlane(translate(mouthPoint, vec3(0,0,-1)), normalize(vec4(0,0,-1,1))), BLACKASNIGHT);
    diff(openMouth,slicePln);
    
    vec3 mouthPointA = mouthPoint;
    mouthPointA.xy = rotate(mouthPointA.xy, PI * 0.5);
    
    vec2 openMouthA = vec2(sdCappedCylinder(mouthPointA, vec2(0.75+ swingTime * 0.10, 3)), BLACKASNIGHT);
    add(openMouth, openMouthA);
    
    beard = vec2(opSmoothSubtraction(openMouth.x, beard.x, 0.8), BROWNBEARD);
    
    vec3 tonguePoint = translate(p, vec3(0,-3.75,-4.5));
    tonguePoint.x *= .5;
    tonguePoint.yz = rotate(tonguePoint.yz, PI * -0.5);
    
    vec2 tongue = vec2(sdRoundCone(tonguePoint, 0.25, 0.5, 1.75), TONGUERED);
    
    vec2 subHole = vec2(sdSphere(translate(p, vec3(0,-2.75,-2.85)), 2.25), BLACKASNIGHT);
    
    vec2 hollowHole = vec2(sdSphere(translate(p, vec3(0,-2.75,-2.75)), 2.25), BLACKASNIGHT);
    vec2 slicePlnH = vec2(sdPlane(translate(p, vec3(0,0,-3.2)), normalize(vec4(0,0,1,1))), BLACKASNIGHT);
    
    diff(hollowHole, slicePlnH);
    
    hollowHole = vec2(opOnion(hollowHole.x,0.05), BLACKASNIGHT);
    
    diff(beard, subHole);
    
    add(beard, tongue);
    add(beard, hollowHole);
    
    add(beard, teethTop);
    add(beard, teethBottom);
    
    add(head, beard);
    
    // ears
    add(head, leftEar);
    
    // hairs
    add(head, d15);
    add(head, d16);
    add(head, d17);
    add(head, d18);
    
    add(head, leftTopEyelid);
    add(head, leftBottomEyelid);
    
    add(head, pupils);
    
    return head;
}

// Function 1582
vec2 map(vec3 p) {
    float d1 = sdTerrain(p);
    float d2 = sdEarth(p);
    
    return d1 < d2 ? vec2(d1, 1.0) : vec2(d2, 2.0);
}

// Function 1583
Surface map(in vec3 p){
  float t = exp(cos(phase/2.0)*5.0)*0.001;
  float isGlass = sign(p.x) * 0.5 + 0.5; // glass=1, mirror=0
  vec3 rr = vec3(isGlass*1.8),
       rl = vec3(rr2rl(rr.x)),
       col = vec3(0),
       tc = vec3(1.0,0.2,0.2)*isGlass;
  return near(
    Surface(dfFreeDSBC(vec3(abs(p.x)-2.7,p.y-2.0,p.z)*_pmat(vec3(phase/32.0,0.0,0.5*PI)), 1.6, 0.1), col, tc, rl, rr),
    Surface(sdChain(foXZCircle((p-vec3(0,2,0))*_pmat(vec3(0,sin(phase/32.0)*P2,phase/32.0)),30.6,6.0), 0.35, 0.1+t, 0.1+t), 
            vec3(0), vec3(1.0), rl, rr)
  );
}

// Function 1584
float map(vec2 fragCoord) {
    return MAP_HEIGHT(texture(iChannel0, fragCoord/iResolution.xy).z);
}

// Function 1585
vec2 dist(vec3 pos, out vec3 fuckyPos, out float minBox, out float minSphere, out vec3 adjusted) {
    
    mat4 mat = rotationMatrix(vec3(-0.3,1,0),PI/2.0*iTime);
    
    fuckyPos = pos;
        
    //rotatedPos += vec3(0,650,0);
    //rotatedPos += vec3(0,0,-200);

    vec3 spherePos = fuckyPos - vec3(300,0,400);
    minSphere = sdSphere(spherePos,140.0);
    float per = 0.04;
    minSphere += sin(per*spherePos.x)*sin(per*spherePos.y)*sin(per*spherePos.z)*40.0*cos(iTime*8.0);
    float minPlane = sdPlane(fuckyPos-vec3(0,-180,0), normalize(vec4(0,1,0,0)));


    adjusted = (vec4(fuckyPos-vec3(140,0,250),1) * mat).rgb;
    minBox = sdBox(adjusted, vec3(40, 40, 60));
    adjusted = (vec4(fuckyPos-vec3(140,-50,250),1) * mat).rgb;
    float minSphere2 = sdSphere(adjusted, 50.0);
    minBox = opS(minSphere2, minBox);

    float minBoxSphere = smin(minBox, minSphere, 64.0);

    mat4 matt = rotationMatrix(vec3(0,1,0),fuckyPos.y*(0.02 + cos(iTime/1.0)*0.02));
    adjusted = (vec4(fuckyPos-vec3(-300,-80,100),1) * matt).rgb;
    float minTower = sdBox(adjusted, vec3(40,300,40));
    minTower += sin(0.01*adjusted.x)*cos(0.2*adjusted.y)*cos(0.0005*adjusted.y*adjusted.x)*30.0;
    float minDist = min(min(minTower, minBoxSphere), minPlane);
    
    int check = 0;
    if(minPlane < THRESH) {
        check = 1;
    }
    else if(minBoxSphere < THRESH) {
        check = 2;
    }
    else if(minTower < THRESH) {
        check = 3;
    }
    
    return vec2(minDist,check);
}

// Function 1586
float distPlane(vec3 pos, vec4 n)
{
    return dot(pos, n.xyz) + n.w;
}

// Function 1587
vec3 map_light_norm(vec3 ro) { 
    return normalize(ro - light.xyz);
}

// Function 1588
float starSegmentSDF( vec3 point, vec3 a, vec3 center, float thickness ) {
    float h = VECTOR_PROJECTION( a, center, point );
    vec3 q = a + ( center - a ) * h;
    h = pow( h, 0.7 ) * .8;      
    return length( point - q ) - thickness * h;
}

// Function 1589
float SceneRay (vec3 ro, vec3 rd)
{
  vec3 p;
  float dHit, d, eps;
  eps = 0.0001;
  dHit = 0.;
  for (int j = VAR_ZERO; j < 120; j ++) {
    p = ro + dHit * rd;
    d = SceneDf (ro + dHit * rd);
    dHit += d;
    if (d < eps || dHit > dstFar || p.y < 0.) break;
  }
  if (d >= eps) dHit = dstFar;
  return dHit;
}

// Function 1590
float sdf_chickenscratch(vec2 uv, vec2 mins, vec2 maxs, float thickness)
{
    uv -= mins;
    maxs -= mins;
    
    vec2 p0, p1, p2, p3;
    if (uv.x < maxs.x*.375)
    {
        p0 = vec2(0.);
        p1 = vec2(.3, 1.);
        p2 = vec2(.3, 0.);
        p3 = vec2(.09, .28);
    }
    else
    {
        p0 = vec2(.45, 0.);
        p1 = vec2(.45, 1.);
        p2 = vec2(.75, 0.);
        p3 = p0;
    }
    p0 *= maxs;
    p1 *= maxs;
    p2 *= maxs;
    p3 *= maxs;

    float dist = line_sqdist(uv, p0, p1);
    dist = min(dist, line_sqdist(uv, p1, p2));
    dist = min(dist, line_sqdist(uv, p2, p3));

    #define LINE(a, b) line_sqdist(uv, maxs*a, maxs*b)
    
    dist = min(dist, LINE(vec2(.65, 1.), vec2(.95, 0.)));
    dist = min(dist, LINE(vec2(.85, 1.), vec2(.65, .65)));

	#undef LINE
    
    return sqrt(dist) + thickness * -.5;
}

// Function 1591
void _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_map_abstract_glassy_field_envMap_closure_0_(inout vec3 _402, vec3 _403)
{
    for_r_unsafe_fn _405;
    _402.x = abstract_glassy_field_envMap_closure_0_(_405, _403.x);
    _402.y = abstract_glassy_field_envMap_closure_0_(_405, _403.y);
    _402.z = abstract_glassy_field_envMap_closure_0_(_405, _403.z);
}

// Function 1592
int intersectscene(vec3 p, vec3 r, out vec3 n) {
  return intersectcone(p,r,n);
}

// Function 1593
vec3 eMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.25;
    rd *= 3.;
    
    //vec3 tx = tex3D(iChannel0, rd/3., sn);
    //float c = dot(tx*tx, vec3(.299, .587, .114));
    
    float c = fBm3D(rd);
    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.
    
    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.
    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.
    vec3 col = pow(vec3(1.5, 1, 1)*c, vec3(1, 2.5, 12)).zyx; // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25 + .25); 
    
}

// Function 1594
vec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)
{
	float t = .05 + 0.05 * texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy).y;
	vec3 p = vec3(0.0);
    float oldT = 0.0;
    bool hit = false;
    float glow = 0.0;
    vec2 dist;
	for( int j=0; j < 100; j++ )
	{
		if (t > 12.0) break;
        p = rO + t*rD;
       
		float h = Map(p);
        
		if(h  <0.0005)
		{
            dist = vec2(oldT, t);
            hit = true;
            break;
        }
       	glow += clamp(.05-h, 0.0, .4);
        oldT = t;
      	t +=  h + t*0.001;
 	}
    if (!hit)
        t = 1000.0;
    else       t = BinarySubdivision(rO, rD, dist);
    return vec2(t, clamp(glow*.25, 0.0, 1.0));

}

// Function 1595
vec3 getCubeMap(vec2 inUV)
{
	vec3 samplePos = vec3(0.0f);
	
	// Crude statement to visualize different cube map faces based on UV coordinates
	int x = int(floor(inUV.x / 0.25f));
	int y = int(floor(inUV.y / (1.0 / 3.0))); 
	if (y == 1) {
		vec2 uv = vec2(inUV.x * 4.0f, (inUV.y - 1.0/3.0) * 3.0);
		uv = 2.0 * vec2(uv.x - float(x) * 1.0, uv.y) - 1.0;
		switch (x) {
			case 0:	// NEGATIVE_X
				samplePos = vec3(-1.0f, uv.y, uv.x);
				break;
			case 1: // POSITIVE_Z				
				samplePos = vec3(uv.x, uv.y, 1.0f);
				break;
			case 2: // POSITIVE_X
				samplePos = vec3(1.0, uv.y, -uv.x);
				break;				
			case 3: // NEGATIVE_Z
				samplePos = vec3(-uv.x, uv.y, -1.0f);
				break;
		}
	} else {
		if (x == 1) { 
			vec2 uv = vec2((inUV.x - 0.25) * 4.0, (inUV.y - float(y) / 3.0) * 3.0);
			uv = 2.0 * uv - 1.0;
			switch (y) {
				case 0: // NEGATIVE_Y
					samplePos = vec3(uv.x, -1.0f, uv.y);
					break;
				case 2: // POSITIVE_Y
					samplePos = vec3(uv.x, 1.0f, -uv.y);
					break;
			}
		}
	}

	return samplePos;  
}

// Function 1596
float sceneDistance(vec3 p, inout int material){
    
    float distance = 9999.9;
    material = 0;
    
    
    
    hardAdd(material,distance,1,
    	-obj_cylForever(p.xz, vec2(0.0),bgDist)
    );
    
    
    const float outlineRad = 0.02;
    float healthModX = 0.35;
    vec2 healthSize = vec2(0.25,0.35)/2.0;
    if (abs(p.x)<healthModX*2.0) {
        
        vec3 healthP = p;
        healthP.y -= statusHeight;
        
        healthP.x = mod(healthP.x,healthModX);
        healthP.x -= healthModX/2.0;
        
        vec3 healthFrameP = healthP;
        healthFrameP.y = abs(healthFrameP.y);
        healthFrameP.x = abs(healthFrameP.x);
        
        
        const float boxThickness = 0.03;
        hardAdd(material,distance,3,
			obj_box(healthFrameP,vec3(0.0,0.0,statusDist-boxThickness+0.01),vec3(healthSize.xy,boxThickness),0.0)
		);
        
        const float healthInset = 0.01;
        smoothSubtract(distance,
            obj_box(healthP,vec3(0.05,-0.1,statusDist),vec3(0.075,0.125,healthInset),0.0),
        	0.01
        );

        
        hardAdd(material,distance,2,
            obj_quartertorus(healthFrameP,vec3(healthSize.xy,statusDist),vec2(outlineRad,outlineRad-0.001))
        );
        
        
        
        vec3 wheelP = healthP;
        wheelP.x -= 0.05;
        wheelP.x = abs(wheelP.x);


        wheelP.y += 0.075;
        wheelP.y = abs(wheelP.y);

        hardAdd(material,distance,2,
        	obj_cylinder(wheelP,vec3(0.0,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)
        );
        hardAdd(material,distance,2,
        	obj_cylinder(wheelP,vec3(0.05,0.05,statusDist-healthInset),vec2(0.05,0.025),0.0075)
        );

    }
    
    vec3 statusP = p;
    statusP.y -= statusHeight+1.0;
    statusP.y = abs(statusP.y);
    
    statusP.x += 0.25;
    statusP.x = abs(statusP.x);
    
    hardAdd(material,distance,2,
    	obj_quartertorus(statusP,vec3(0.4,0.1,statusDist),vec2(0.02,0.01))
    );
    hardAdd(material,distance,4,
    	obj_box(statusP,vec3(0.0,0.0,statusDist-0.005),vec3(0.41,0.12,0.01),0.0)
    );
    
    
    
    
    float ufoHeight = enemyHeight+sin(iTime*2.5)*0.02;
    
    vec3 ufoRotP = p;
    
    vec3 ufoBodyP = ufoRotP;
    ufoBodyP.y -= ufoHeight+0.3;
    ufoBodyP.y = abs(ufoBodyP.y);
    
    hardAdd(material,distance,5,
		obj_ball(ufoBodyP,vec3(-enemyOffX,-1.0,enemyDist),1.1)
	);
    smoothAdd(distance,
		obj_ball(ufoBodyP,vec3(-enemyOffX,0.03,enemyDist),0.2),
    0.1);
    
    vec3 ufoEyeP = ufoRotP;
    ufoEyeP.x -= -enemyOffX+0.05;
    ufoEyeP.x = abs(ufoEyeP.x);
    
    hardAdd(material,distance,6,
		obj_ball(ufoEyeP,vec3(0.045,ufoHeight+0.41,enemyDist+0.25),0.025)
	);
    
    
    
    
    const float foppyWidth = 0.1;
    float foppyBob = pow(1.0-(sin(iTime*4.0)*0.5+0.5),1.1);
    float foppyHeight = enemyHeight+0.3 + foppyBob*0.03;
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX+foppyWidth,foppyHeight,enemyDist),0.2)
	);
    smoothAdd(distance,
    	obj_ball(p,vec3(enemyOffX-foppyWidth,foppyHeight,enemyDist),0.2),
	0.3);
    
    float legOff = 0.25 - foppyBob*0.02;
    float legSize = 0.09 - foppyBob*0.01;
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX-legOff,enemyHeight+0.1,enemyDist+0.2),legSize)
	);
    hardAdd(material,distance,7,
    	obj_ball(p,vec3(enemyOffX+legOff,enemyHeight+0.08,enemyDist-0.1),legSize)
	);
    
    
    vec3 foppyEyeP = p;
    foppyEyeP.x -= enemyOffX-0.05;
    foppyEyeP.x = abs(foppyEyeP.x);
    
    hardAdd(material,distance,8,
    	obj_ball(foppyEyeP,vec3(0.1,foppyHeight+0.07,enemyDist+0.26),0.015)
	);
    
    
    
    return distance;
    
}

// Function 1597
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 flmCol, col, vn;
  float dstHit, dstGrnd, dstFbHit, fIntens, f;
  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);
  fIntens = (dstFbHit < dstFar) ? FBallLum (ro, rd, dstFbHit) : 0.;
  dstHit = dstFar;
  dstGrnd = GrndRay (ro, rd);
  if (dstGrnd < dstFar) {
    ro += dstGrnd * rd;
    vn = VaryNf (1.2 * ro, GrndNf (ro, dstHit), 1.);
    col = (mix (vec3 (0.2, 0.4, 0.1), vec3 (0., 0.5, 0.),
       clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.))) *
       (0.1 + max (0., max (dot (vn, sunDir), 0.))) +
       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.);
    f = dstGrnd / dstFar;
    f *= f;
    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));
  } else col = SkyCol (ro, rd);
  if (dstFbHit < dstFar) {
    ro += rd * dstFbHit;
    rd = reflect (rd, qnHit);
    col = 0.9 * col + 0.08 + 0.25 * max (dot (qnHit, sunDir), 0.) * (1. +
       4. * pow (max (0., dot (sunDir, rd)), 128.));
  }
  f = clamp (0.7 * fIntens, 0., 1.);
  f *= f;
  flmCol = 1.5 * (0.7 + 0.3 * Noiseff (20. * tCur)) *
     mix (vec3 (1., 0.1, 0.1), vec3 (1., 1., 0.5), f * f);
  col = mix (col, flmCol, min (1.2 * fIntens * fIntens, 1.));
  if (dstFbHit < dstFar) {
    dstGrnd = GrndRay (ro, rd);
    col = mix (col, ((dstGrnd < dstFar) ? vec3 (0.1, 0.3, 0.1) :
       SkyCol (ro, rd)), pow (1. - abs (dot (rd, qnHit)), 3.));
  }
  return sqrt (clamp (col, 0., 1.));
}

// Function 1598
float sdfCircle(vec2 uv, vec2 c, float r) { return length(uv-c)-r; }

// Function 1599
vec4 map( vec3 p )
{
	float den = 0.2 - p.y;

    // invert space	
	p = -7.0*p/dot(p,p);

    // twist space	
	float co = cos(den - 0.25*iTime);
	float si = sin(den - 0.25*iTime);
	p.xz = mat2(co,-si,si,co)*p.xz;

    // smoke	
	float f;
	vec3 q = p                          - vec3(0.0,1.0,0.0)*iTime;;
    f  = 0.50000*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.25000*noise( q ); q = q*2.03 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.12500*noise( q ); q = q*2.01 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.06250*noise( q ); q = q*2.02 - vec3(0.0,1.0,0.0)*iTime;
    f += 0.03125*noise( q );

	den = clamp( den + 4.0*f, 0.0, 1.0 );
	
	vec3 col = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), den ) + 0.05*sin(p);
	
	return vec4( col, den );
}

// Function 1600
float MapMissile(vec3 p, Missile missile)
{
  float d= fCylinder( p, 0.70, 1.7);
  if (d<1.0)
  {
    d = fCylinder( p, 0.12, 1.2);   
    d =min(d, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); 

    checkPos = p;  
    pR(checkPos.xy, 0.785);
    checkPos.xy = pModPolar(checkPos.xy, 4.0);

    d=min(d, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));
    d=min(d, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));
    d = max(d, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));
    d = max(d, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));
  }
  return d;
}

// Function 1601
float dist_bulb(vec3 pos) {
	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
	for (float i = 0.; i < Iterations ; i+=1.) {
		r = length(z);
		if (r>2.) break;
		
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan(z.y,z.x);
		dr =  pow( r, Power-1.0)*Power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow( r,Power);
		theta = theta*Power;
		phi = phi*Power;
		
		// convert back to cartesian coordinates
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return 0.5*log(r)*r/dr;
}

// Function 1602
float distBox(vec3 p, vec3 pos, vec3 r) {
 
    return length(max(abs(pos - p)-r, 0.));
    
}

// Function 1603
float octaSDF( vec3 center, float size){
    center = abs(center);
    return (center.x + center.y + center.z - size)*0.57735027;
}

// Function 1604
float dstScene(vec3 p) {
    vec3  n = normalize(p);
    vec2 uv = asin(n.xy)/PI+.5;
    float h = texture(iChannel0,uv).x*.1;
	return length(p)-(6300.+(1250.*h));
}

// Function 1605
float map( float value, float oldMin, float oldMax, float newMin, float newMax ) 
{
    return newMin + (newMax - newMin) * (value - oldMin) / (oldMax - oldMin);
}

// Function 1606
void mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )
{
  //O = vec4(.5+.5*D,0); U = U/1024. - 1./vec2(4,8); O -= .01/dot(U,U); return;
  //int f = faceID(D); O = vec4(f&1,f&2,f&4,0); return;
 
    O = vec4( equal( ivec4( 255.* texture(iChannel0, U/iResolution.xy)),
                     ivec4( ( faceID(D) + iFrame*6 ) % 258 ) ) );
}

// Function 1607
SDFResult eyeSDF( vec3 p )
{
#ifdef EYESOCKETS    
	const float eyeoffset=0.0;        
#else
	const float eyeoffset=-0.1;    
#endif
    SDFResult res = sphereSDF(Sphere(vec3(0.15, 0.6, eyeoffset-0.31), 0.12, EYEWH), p);
    res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.15, 0.6, eyeoffset-0.31), 0.12, EYEWH), p), res, 0.01);      
    res = opSmoothAdd(sphereSDF(Sphere(vec3(0.15, 0.6, eyeoffset-0.41), 0.06, EYEBL), p), res, 0.01); 
    res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.15, 0.6, eyeoffset-0.41), 0.06, EYEBL), p), res, 0.01);      
    return res;    
}

// Function 1608
float MapCloud( vec3 p)
{
  return GetHorizon(p) - max(-3., (1.3*GetCloudHeight(p)));
}

// Function 1609
float distID( in vec3 p )
{
    // Since the window cutout subfields exist WITHIN the base tunnel and ceiling,
    // we have to make sure negative values don't get into the comparison. Using
    // abs() instead of max() has the added benefit of biasing towards those cutout
    // bits.
	vec2 closest = u(vec2(abs(ceiling(p))+EPSILON, ID_CEILING),
			         vec2(abs(baseTunnel(p)), mix(ID_GROUND,ID_WALLS,step(.1,p.y))));
		 closest = u(closest, vec2(abs(windowCutouts(p)), mix(ID_CUTOUT,ID_CUTCEIL,step(8.425,p.y))));
         closest = u(closest, vec2(abs(windowScallops(p)),ID_CUTOUT));
    	 closest = u(closest, vec2(cauldrons(p), ID_CAULDR));
    	 closest = u(closest, vec2(candles(p), ID_CANDLES));
    	 closest = u(closest, vec2(windowPanes(p), ID_WINDOW));
    	 closest = u(closest, vec2(yourPathEndsHere(p), ID_END));
    return closest.t;

}

// Function 1610
void _glam_f32_vec2_Vec2_as_rustoy_std_Vec2Ext_map_texread_Uniforms_main_image_closure_0_(inout vec2 _134, vec2 _135)
{
    for_r_unsafe_fn _137;
    _134.x = _texread_Uniforms_main_image_closure_0_(_137, _135.x);
    _134.y = _texread_Uniforms_main_image_closure_0_(_137, _135.y);
}

// Function 1611
float map(vec3 p) {
    
    float scale = 1.;
    float s = .2;
    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;
    float rx = sin(iTime * .33) * .2;

    if (iMouse.z > 0. && iMouse.w > 0.) {
        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;
    	rx = (.5 - iMouse.y / iResolution.y) * PI / 2.;
        scale = 2.;
    }
    
    pR(p.yz, rx);
    pR(p.xz, ry);
    
    p /= scale;
   	return mHead(p) * scale;
}

// Function 1612
vec2 mapRM(vec3 p) {
    vec2 d = vec2(-1.0, -1.0);
    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);
    d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));
    d = opU(d, vec2(mapWater(p-vec3(0.0, WATER_LEVEL, 0.0)), TYPE_WATER));
    //d = opU(d, vec2(sdBox(p-BOATPOS, vec3(1.0, 1.0, 1.0)), TYPE_BOAT));
    return d;
}

// Function 1613
float scene(vec3 p)
{
    float t=floor(iTime*4.);
	float r1 = noise(t+.1);
	float r2 = noise(t+.2);
	float r3 = noise(t+.3);
	float r4 = noise(t+.4);
	float r5 = noise(t+.5);
	float r6 = noise(t+.6);
	float r7 = noise(t+.7);
	float r8 = noise(t+.8);
	return min8(
        sdBox(p+vec3( .2, .2, .2),vec3(r1)),
        sdBox(p+vec3( .2, .2,-.2),vec3(r2)),
        sdBox(p+vec3( .2,-.2, .2),vec3(r3)),
        sdBox(p+vec3( .2,-.2,-.2),vec3(r4)),
        sdBox(p+vec3(-.2, .2, .2),vec3(r5)),
        sdBox(p+vec3(-.2, .2,-.2),vec3(r6)),
        sdBox(p+vec3(-.2,-.2, .2),vec3(r7)),
        sdBox(p+vec3(-.2,-.2,-.2),vec3(r8))
    );
    
    return max(
        sdBox(p,vec3(.5)),
        -min3(
            sdBox(p,vec3(.6,.3,.3)),
            sdBox(p,vec3(.3,.6,.3)),
            sdBox(p,vec3(.3,.3,.6))
        )
    );
}

// Function 1614
vec2 map( in vec4 pos ) {
    vec2 res = vec2(99999.,0);

#ifdef DRAWAXES
//	pos.xy *= mat2(c2,-s2,s2,c2);
	
	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(10.,0.,0.,0.), 0.05  ), 31.9 ) );
	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,10.,0.,0.), 0.05  ), 41.9 ) );
	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,10.,0.), 0.05  ), 51.9 ) );
	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,0.,10.), 0.05  ), 61.9 ) );
#else
	res = vec2(sdPlane(pos),1.);
#endif
    res = opU( res, vec2(sdCubicalCylinder(pos-vec4(-.5,.3, -.8, .1), vec3(.2,.3,.2)), 60.9 ) );
    res = opU( res, vec2(sdDuoCylinder( pos-vec4(-.2,.3, -.2, -.1), vec2(.2,.3) ), 53.9 ) );


	res = opU( res, vec2( sdTesseract(       pos-vec4( 1.0,0.25, 0.1, 0.2), vec4(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundTesseract(  pos-vec4( 1.0,0.25, 1.0, 0.0), vec4(0.15), 0.1 ), 41.0 ) );
	res = opU( res, vec2( sdCapsule(   pos,vec4(-1.3,0.20,-0.1, -.3), vec4(-1.0,0.20,0.2,1.5), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdCylinder(  pos-vec4( 1.0,0.30,-1.0, -.5), vec2(0.1,0.2) ), 4.0 ) );
	//res = opU( res, vec2( sdCone(      pos-vec4( 1.0,0.30,-1.0, 0.10), vec2(0.1,0.4) ), 4.0 ) );
	
	float d = 2.;
	pos.w = mod(pos.w,d)-.5*d;
   
      res = opU( res, vec2( sdSphere(pos-vec4( 0.0,0.25, 0.0, 0.25), 0.25 ), 46.9 ) );
  //  res = opU( res, vec2( sdEllipsoid(pos-vec4( 0.0,0.25, 0.0, 0.25), vec4(.25,.1,.15,.3) ), 46.9 ) );

	return res;
}

// Function 1615
vec3 scene( in vec2 p) {
    
    vec2 offset = vec2(1.3,-.6);
    
    vec3 c = vec3(.9) * length(p+offset) + fbm2(p*20.0+20.0)*.0025; 
    
    	 c = clamp(c,.0,.2) / length(p+offset) - fbm2(p+vec2(iTime*.01,0))*.025;

    float stars = (1.0 - clamp(0.0, 0.025, r*10.0) * 40.0) * .4 * (p.y * 3.0 + 1.0) * (.25 + fbm2(p*200.0)) * ceil(p.y);
    
    c = max(c, stars);
    
    c = max(c,mountain(p, offset));
    
    c = max(c,mountain(p+vec2(-0.4,0.1), offset+vec2(-0.4,0.1)));
    
    c = max(c,mountain(p+vec2(-0.55,0.2), offset+vec2(-0.55,0.2)));
    
    return c;
}

// Function 1616
float distanceToSphere(vec4 sphere,vec3 point) {
	return(length(point-sphere.xyz)-sphere.w);
}

// Function 1617
float GetDist(vec3 p) {
    p.xz *= rot(iTime*.2);
    float d = 2.0*sdRhombicDodecahedron(p/2.0);
    // Computing the scale of the triangle from the width of the rhombic faces
    float edge = 1.0/sin(r/2.0)*.5;  // length of the edge of the rhombus 
    float scale = edge*cos(PI/2.0-r); // base of the equilateral triangle
    for (int i=0 ; i <= 3 ; i++) {
        vec3 q = p;
        q.z -= 1.0;
        q.y -= 1.0;
        q.zy *= rot(3.1415/4.0);
        q.zx *= rot(acos(1./3.)/2.0); 
        float id;
        q = opModPolar(q,sqrt(2.0),3.0,id);
        q.z -= 20.0*smoothstep(-0.2,0.2,cos(iTime*PI*.05-id*.02+float(i)*0.3));
        d = min(d,sdPiece(q/scale)*scale);
        p.xy *= rot90;
    }
    // The Bigwings's effect is supposed to work only with convex shapes
    // The result may be look strange for that.
    d+= .1 * S(.6,1.0,sin(iTime*.2));
    return d;
}

// Function 1618
raysample GetDist(vec3 p) 
{
    //	Reset Distance & Material
    raysample d = raysample(MAX_DIST, p, 0, vec3(1));
    
    //	Do Spheres
    for (int i=0; i<S.length(); i++) 
    {
        float dS = sdSphere(p-S[i].center, S[i].radius);
        if (dS < d.dist) {
            d.dist = dS;
            d.material = S[i].material;
        }
    }
    
    //	Do Planes
    for (int i=0; i<P.length(); i++) 
    {
        float dP = sdPlane(p, P[i].normal);
        if  (dP < d.dist) {
            d.dist = dP;
            d.material = P[i].material;
        }
    }
    
    return d;
}

// Function 1619
rayhit rayScene(vec3 rp, vec3 rd) {
    rayhit h;
	h.normal.w = VIEW_DISTANCE;

    //container, floor, ceiling and walls
    rt(rayBox(rp,rd,vec3(0),vec3(4,1,4)),
        h.diffuse = vec4(.8,.8,.8,0);
    	h.metallic = 0.;
        h.opacity = 1.;
       
        vec3 hp = rp+rd*s.w;
        if (hp.y > .99) {
       		//light emission
            hp.xz = abs(abs(hp.xz)-1.);
       	    h.diffuse.w = max(0.,(.5-max(hp.x,hp.z))*100.)*(.02+pow(max(0.,dot(rd,vec3(0,1,0))),10.)*.98);
        } else if (max(abs(hp.x),abs(hp.z)) > 3.99) {
         	//normal mapped voronoi walls
            vec2 tc = (vec2(dot(hp.zx,s.xz),hp.y)+10.)*70.;
            float bdst = voronoiWall(tc);
            tc = normalize(vec2(voronoiWall(tc+vec2(.01,0)),voronoiWall(tc+vec2(0,.01)))-bdst)*-.3;
            h.normal.xyz = normalize(h.normal.xyz+vec3(tc.x*h.normal.z,tc.y,tc.x*h.normal.x));
            h.diffuse = vec4(.3,.45,.52,0);
            h.specular = vec4(.76,.82,.83,0);
            h.metallic = .4;
            h.roughness = .08;
        }
    );
    
    //crystal pedestals
    #define pedestal(pos) rt(rayBox(rp,rd,pos,vec3(.2,.3,.2)),\
    h.diffuse = vec4(.1,.1,.1,0);\
    h.specular = vec4(.1,.1,.1,0);\
    h.metallic = .7;\
    h.roughness = .001;\
    h.opacity = 1.;);
    
    pedestal(vec3(1,-.5,1));
    pedestal(vec3(-1,-.5,1));
    pedestal(vec3(1,-.5,-1));
    pedestal(vec3(-1,-.5,-1));

    //flip refraction index inside crystal
    #define RFLIP(df,cp) if (df(rp+rd*s.w-cp) < EPSILON) {h.refrIndex = 1./h.refrIndex;}
    
    //crystal 1 clear with little refraction
    rtc(rayCrystal1(rp,rd),crystal1_pos,.4,
       h.specular = vec4(.9,.99,.92,0);
       h.roughness = 0.;
       h.metallic = 1.;
       h.opacity = 0.03;
       h.refrIndex = .92;
    );
    
    //crystal 2 rough bright green
    rtc(rayCrystal2(rp,rd),crystal2_pos,.4,
       h.specular = vec4(.1,.99,.1,0);
       h.roughness = 0.02;
       h.metallic = 1.;
       h.opacity = .2;
       h.refrIndex = .7;
       RFLIP(crystal2,crystal2_pos);
    );
    
    //crystal 3 blueish purple
    rtc(rayCrystal3(rp,rd),crystal3_pos,.4,
       h.specular = vec4(.6,.2,.99,0);
       h.roughness = 0.005;
       h.metallic = 1.;
       h.opacity = .3;
       h.refrIndex = .95;
       RFLIP(crystal3,crystal3_pos);
    );
    
    //crystal 4 yellow
    rtc(rayCrystal4(rp,rd),crystal4_pos,.4,
       h.specular = vec4(1,1,0.,0);
       h.roughness = 0.;
       h.metallic = 1.;
       h.opacity = 0.1;
       h.refrIndex = .6;
       RFLIP(crystal4,crystal4_pos);
    );
    
    return h;
}

// Function 1620
float scene(vec3 p) {
    p = asin(sin(p+1.));
    return length(p)-1.;
}

// Function 1621
vec3 tonemap(vec3 x){return mapu(x,2.51*x+.06,.14,x,.59+2.43*x);}

// Function 1622
Dst dstScene(vec3 p) {
 
    Dst dst = dstPillar(p, vec3(0.), vec3(.5,2.,.5));
    dst = dstMin(dst, dstFloor(p, -2.));
    
    return dst;
    
}

// Function 1623
float remap(float a1, float a2 ,float b1, float b2, float t)
{
	return b1+(t-a1)*(b2-b1)/(a2-a1);
}

// Function 1624
float brushdist(Brush brush, vec2 p) {
    p -= brush.p;
    vec2 cs = vec2(sin(-brush.a),cos(-brush.a));
    p = vec2(
        dot(p, vec2(cs.y, -cs.x)),
        dot(p, cs)
        );
    return sdBox(p, brush.s);
}

// Function 1625
float distSphere(vec3 p, float radius)
{
    //if point is outside the radius it will return +ve
    // else it will return -ve value
    return length(p) - radius;
}

// Function 1626
vec3 i_Tonemap_ACES(vec3 x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
     return min(vec3(1.0), max(vec3(0.0), ((x / (a / x - b)) * max(x / (c / x - d) - e, vec3(0.001)))));
}

// Function 1627
float LineDist(vec2 a, vec2 b, vec2 p) {
	vec2 ab=b-a, ap=p-a;
    float h = dot(ab, ap)/dot(ab, ab);
    float d = length(ap - ab * h);
    float s = sign(ab.x * ap.y - ab.y * ap.x);
    return d*s;
}

// Function 1628
vec2 uv_map_axial(vec3 pos, int axis)
{
    return (axis==0) ? pos.yz : (axis==1) ? pos.xz : pos.xy;
}

// Function 1629
vec3 triPlanarMapCatRom(sampler2D inTexture, float contrast, vec3 normal, vec3 position, vec2 texResolution)
{
    vec3 signs = sign(normal);
    
    vec3 xTex = SampleTextureCatmullRom(inTexture, (position).yz, texResolution, 0.0, 0).rgb;
    vec3 yTex = SampleTextureCatmullRom(inTexture, (position).xz, texResolution, 0.0, 0).rgb;
    vec3 zTex = SampleTextureCatmullRom(inTexture, -(position).xy, texResolution, 0.0, 0).rgb;
    
    vec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);
    weights /= max(max(weights.x, weights.y), weights.z);
    float sharpening = 10.0;
    weights = pow(weights, vec3(sharpening, sharpening, sharpening));
    weights /= dot(weights, vec3(1.0, 1.0, 1.0));
  
    return clamp(vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z), vec3(0), vec3(1));
}

// Function 1630
gia1 map(gia1x3 p) {
    //return gia_sub(gia_length(p), 0.5);
   
    float a = iTime * 0.1;
    float c = cos(a);
    float s = sin(a);
    gia1x3 rp = gia1x3(
        gia_add(gia_mul(p.x, c), gia_mul(p.y, s)),
        gia_add(gia_mul(p.x, s), gia_mul(p.y, -c)),
        p.z
    );
    
    gia1 s1 = gia_sub(gia_length(gia_add(p, vec3(0.0,-0.5,0.0))),0.2);
    
    gia1x3 w = gia_abs(rp);
    gia1 s2 = gia_sub(gia_max(gia_max(w.x, gia_add(w.y,0.45)), w.z),0.5);
    
    return gia_min(s2,s1);
}

// Function 1631
float vLogToLinScene( float x)
{
float cutInv = 0.181;
float b = 0.00873;
float c = 0.241514;
float d = 0.598206;
if (x <= cutInv)
return (x - 0.125) / 5.6;
else
return pow(10.0, (x - d) / c) - b;
}

// Function 1632
float distanceToObjects(vec3 p) {
    float d1 = distanceToSphere(p,0.5);
	float d2 = distanceToGroundPlane(p);
    
    return min(d1,d2);
}

// Function 1633
float bisectorDistance(vec3 p, vec3 a, vec3 b) {
    vec3 n1 = cross(a,b);
    vec3 n2 = normalize(cross(n1, 0.5*(normalize(a)+normalize(b))));
    return abs(dot(p, n2));             
}

// Function 1634
float sdfAnulus(vec2 pnt, vec2 center, float radius1, float radius2) {
  return sdfMinus(
    sdfCircle(pnt, center, radius2),
    sdfCircle(pnt, center, radius1));
}

// Function 1635
float sceneIntersection(in vec3 ro,in vec3 rd, out vec3 inter, out vec3 normal, out vec3 color, in float dist)
{
    float mint = dist;
    inter = vec3(0);
    normal = vec3(0);
    color = vec3(0);
   	// Spheres
    for(int i = 0 ; i < nbSphere ; i++)
    {
        vec2 p2d = rotate(float(i) * tau / float(nbSphere) + iTime * 0.2, 0.8);
		vec3 pos = vec3(p2d.x, ballRadius, p2d.y);
    

        float t = sphIntersect( ro, rd, pos, ballRadius).x;
        if(t > 0. && t < mint)
        {
            mint = t;
            inter = (ro + mint * rd);
            normal = normalize(inter - pos);
            color = vec3(1, 0, 0);
        }     
    }

    // Floor
    {
        float aspecRatio = iResolution.x / iResolution.y;  
        vec3 boxNormal;
    	float t = boxIntersection(ro, rd, vec3(aspecRatio,0.1,1), vec3(0,-0.1,0),boxNormal).x;
        if(t > 0. && t < mint)
        {
            mint = t;
            inter = (ro + mint * rd);
			normal = boxNormal;
            ivec2 tileId = ivec2(vec2(inter.x, inter.z) * 3. + 100.);
            color = ((tileId.x & 1) ^ (tileId.y & 1)) == 0 ? vec3(0.3) : vec3(0.15);  
        }       
    }
	return mint;
}

// Function 1636
vec4 scene(inout vec4 p, inout vec4 ray, float vignette) {
	//Trace the ray
	vec4 d_s_td_m = ray_march(p, ray, 1.0f);
	float d = d_s_td_m.x;
	float s = d_s_td_m.y;
	float td = d_s_td_m.z;

	//Determine the color for this pixel
	vec4 col = vec4(0.0);
	float min_dist = max(FOVperPixel*td, MIN_DIST);
	if (d < min_dist) {
		//Get the surface normal
		vec3 n = calcNormal(p, min_dist*0.5);
		
		//find closest surface point, without this we get weird coloring artifacts
		p.xyz -= n*d;

		//Get coloring
		#if FILTERING_ENABLE
			//sample direction 1, the cross product between the ray and the surface normal, should be parallel to the surface
			vec3 s1 = normalize(cross(ray.xyz, n));
			//sample direction 2, the cross product between s1 and the surface normal
			vec3 s2 = cross(s1, n);
			//get filtered color
			vec4 orig_col = clamp(smoothColor(p, s1, s2, min_dist*0.5), 0.0, 1.0);
		#else
			vec4 orig_col = clamp(COL(p), 0.0, 1.0);
		#endif
		col.w = orig_col.w;

		//Get if this point is in shadow
		float k = 1.0;
		#if SHADOWS_ENABLED
			vec4 light_pt = p;
			light_pt.xyz += n * MIN_DIST * 100.0;
			vec4 rm = ray_march(light_pt, vec4(LIGHT_DIRECTION, 0.0), SHADOW_SHARPNESS);
			k = rm.w * min(rm.z, 1.0);
		#endif

		//Get specular
		#if SPECULAR_HIGHLIGHT > 0
			vec3 reflected = ray.xyz - 2.0*dot(ray.xyz, n) * n;
			float specular = max(dot(reflected, LIGHT_DIRECTION), 0.0);
			specular = pow(specular, float(SPECULAR_HIGHLIGHT));
			col.xyz += specular * LIGHT_COLOR * (k * SPECULAR_MULT);
		#endif

		//Get diffuse lighting
		#if DIFFUSE_ENHANCED_ENABLED
			k = min(k, SHADOW_DARKNESS * 0.5 * (dot(n, LIGHT_DIRECTION) - 1.0) + 1.0);
		#elif DIFFUSE_ENABLED
			k = min(k, dot(n, LIGHT_DIRECTION));
		#endif

		//Don't make shadows entirely dark
		k = max(k, 1.0 - SHADOW_DARKNESS);
		col.xyz += orig_col.xyz * LIGHT_COLOR * k;

		//Add small amount of ambient occlusion
		float a = 1.0 / (1.0 + s * AMBIENT_OCCLUSION_STRENGTH);
		col.xyz += (1.0 - a) * AMBIENT_OCCLUSION_COLOR_DELTA;

		//Add fog effects
		#if FOG_ENABLED
			a = td / MAX_DIST;
			col.xyz = (1.0 - a) * col.xyz + a * BACKGROUND_COLOR;
		#endif

		//Return normal through ray
		ray = vec4(n, 0.0);
	} else {
		//Ray missed, start with solid background color
		col.xyz += BACKGROUND_COLOR;

		col.xyz *= vignette;
		//Background specular
		#if SUN_ENABLED
			float sun_spec = dot(ray.xyz, LIGHT_DIRECTION) - 1.0 + SUN_SIZE;
			sun_spec = min(exp(sun_spec * SUN_SHARPNESS / SUN_SIZE), 1.0);
			col.xyz += LIGHT_COLOR * sun_spec;
		#endif
	}

	return col;
}

// Function 1637
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, w;
  vec2 b;
  float dstBall, dstObj, dstSheet, spec;
  dstBall = BBallHit (ro, rd, dstFar);
  rdSign = sign (rd);
  dstObj = ObjRay (ro, rd);
  dstSheet = SheetRay (ro, rd);
  if (min (min (dstBall, dstObj), dstSheet) < dstFar) {
    if (dstSheet < min (dstBall, dstObj)) {
      vn = SheetNf ();
      ro += rd * dstSheet;
      if (dot (rd, vn) < 0.) {
        col = vec3 (1., 0.6, 0.6);
      } else {
        col = vec3 (0.7, 1., 0.7);
        vn = - vn;
      }
      col = mix (col, vec3 (1., 1., 0.), 0.5 *
         smoothstep (0.2, 0.4, length (mod (0.125 * (qgHit + 0.5), vec2 (1.)) - 0.5)));
      b = abs (abs (0.5 * bGrid - qgHit) - 0.5 * bGrid);
      if (min (b.x, b.y) < 0.2) col = vec3 (0.7, 0.7, 0.2);
      spec = 0.1;
      col *= (1. - 0.3 * Fbm2 (0.5 * qgHit));
    } else if (dstBall < dstObj) {
      vn = vnBall;
      col = vec3 (0.4, 0.4, 0.7);
      spec = 0.1;
    } else if (dstObj < dstFar) {
      ro += rd * dstObj;
      vn = ObjNf (ro);
      if (idObj == 1) {
        w = smoothstep (0., 0.1, abs (fract (6. * ro / hbLen + 0.5) - 0.5));
        col = vec3 (mix (vec3 (0.4, 0.5, 0.4), vec3 (0.5, 0.5, 0.4),
           dot (abs (vn) * w.yzx * w.zxy, vec3 (1.))));
      } else if (idObj == 2) col = vec3 (0.4, 0.5, 0.4);
      spec = 0.2;
    }
    col = col * (0.4 + 0.6 * max (dot (vn, ltDir), 0.)) +
       spec * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);
  } else col = vec3 (0.);
  return clamp (col, 0., 1.);
}

// Function 1638
vec4 distfunc(vec3 pos)
{
    vec3 repPos = opRep(pos, vec3(4.0, 1.0, 4.0));
    vec2 sinPos = sin((pos.z * pi / 8.0) + vec2(0.0, pi)) * 1.75;
    vec3 repPosSin = opRep(pos.xxz + vec3(sinPos.x, sinPos.y, 0.0), vec3(4.0, 4.0, 0.0));
    
    float cylinders = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.5));
    float s = sin(iTime*3.0 + floor(pos.z*0.25));
    float cutCylinders1 = sdBox(vec3(pos.x, pos.y, repPos.z), vec3(100.0, clamp(s, 0.025, 0.75), 1.0));
    float cutCylinders2 = sdBox(vec3(repPos.x, pos.y, repPos.z), vec3(0.035, 100.0, 10.0));
    float cuttedCylinders = max(-cutCylinders2, max(-cutCylinders1, cylinders));
    
    float innerCylinders = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.15));
    float tubes1 = sdCylinder(vec3(repPosSin.x, 0.0, pos.y - 0.85), vec3(0.0, 0.0, 0.025));
    float tubes2 = sdCylinder(vec3(repPosSin.y, 0.0, pos.y + 0.85), vec3(0.0, 0.0, 0.025));
    float tubes = min(tubes1, tubes2);  
    float lightsGeom = min(tubes, innerCylinders);
    
    float resultCylinders = min(cuttedCylinders, lightsGeom);
    
    float spheres = sdSphere(vec3(repPos.x, pos.y, repPos.z), (s*0.5+0.5)*1.5);
    float light = min(tubes, spheres);
    
    vec2 planeMod = abs(fract(pos.xx * vec2(0.25, 4.0) + 0.5) * 4.0 - 2.0) - 1.0;
    float planeMod2 = clamp(planeMod.y, -0.02, 0.02) * min(0.0, planeMod.x);
    float cylindersCutPlane = sdCylinder(vec3(repPos.x, pos.y, repPos.z), vec3(0.0, 0.0, 0.6));
    float spheresCutPlane = sdSphere(vec3(repPos.x, pos.y, repPos.z), 1.3);
    
    float plane = 1.0 - abs(pos.y + clamp(planeMod.x, -0.04, 0.04) + planeMod2);
    float t = tunnel(pos.xzy * vec3(1.0, 1.0, 3.0), vec3(0.0, 0.0, 8.5));
    float cutTunnel = sdBox(vec3(pos.x, pos.y, repPos.z), vec3(100.0, 100.0, 0.1));
    plane = min(max(-cutTunnel, t), max(-spheresCutPlane, max(-cylindersCutPlane, plane)));
    
    float dist = min(resultCylinders, plane);
    float occ = min(cuttedCylinders, plane);
    
    float id = 0.0;
    
    if(lightsGeom < epsilon)
    {
       id = 1.0; 
    }
    
	return vec4(dist, id, light, occ);
}

// Function 1639
vec3 seaHeightMap(vec3 dir) 
{
    vec3 p = vec3(0.0);
    float x = 1000.0;
	
    if (sea_geometry_map(SEA_ORI + dir * x) > 0.0)
    {
		return p;
    }
    
    float mid = 0.0;
    float m = 0.0;
    float heightMiddle = 0.0;
    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) 
    {
		mid = mix(m, x, 0.5); 
        p = SEA_ORI + dir * mid;                   
    	heightMiddle = sea_geometry_map(p);
		if (heightMiddle < 0.0) 
		{
            x = mid;
        } 
		else 
		{
            m = mid;
        }
    }
	
    return p;
}

// Function 1640
vec2 scene(vec3 position)
{
    /*
	This function generates a distance to the given position
	The distance is the closest point in the world to that position
	*/
    // to move the sphere one unit forward, we must subtract that translation from the world position
    vec3 translate = vec3(0.0, -0.5, 1.0);
    float distance = sdSphere(position - translate, 0.5);
	float materialID = 1.0;
    
    translate = vec3(0.0, 0.5, 1.0);
    // A power of raymarching is tiling, we can modify the position in any way we want
    // leaving the shape as is, creating various results
    // So let's tile in X with a sine wave offset in Y!
    vec3 sphere_pos = position - translate;
    // Because our sphere starts at 0 just tiling it would cut it in half, with
    // the other half on the other side of the tile. SO instead we offset it by 0.5
    // then tile it so it stays in tact and then do -0.5 to restore the original position.
    // When tiling by any tile size, offset your position by half the tile size like this!
    sphere_pos.x = fract(sphere_pos.x + 0.5) - 0.5; // fract() is mod(v, 1.0) or in mathemathical terms x % 1.0
    sphere_pos.z = fmod(sphere_pos.z + 1.0, 2.0) - 1.0; // example without fract
    // now let's animate the height!
    sphere_pos.y += sin(position.x + iTime) * 0.35; //add time to animate, multiply by samll number to reduce amplitude
    sphere_pos.y += cos(position.z + iTime);
    float distance2 = sdSphere(sphere_pos, 0.25);
	float materialID2 = 2.0; // the second sphere should have another colour
    
    // to combine two objects we use the minimum distance
    if(distance2 < distance)
    {
		distance = distance2;
        materialID = materialID2;
    }
    
    // we return a vec2 packing the distance and material of the closes object together
    return vec2(distance, materialID);
}

// Function 1641
float subtractionDist(float d1, float d2) {
    return max(d1, -d2);
}

// Function 1642
vec4 scene(vec3 pos, float t)
{    
    float density = fbm(4.0*pos);
    
    float rad = length(pos);
    density -= 0.1 + rad * (1.0 - 0.2 * t);
   
    density = clamp(density, 0.0, 1.0);
    density *= (1.0 - smoothstep(0.5, 1.0, rad));
    
    return vec4(getColor(rad, density), density);
}

// Function 1643
maybe_float get_distance_along_3d_line_to_triangle(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in vec3 B3
){
    // intersection(face plane, edge plane, edge plane, edge plane)
    vec3 B0 = (B1 + B2 + B3) / 3.;
    vec3 N = normalize(cross(B1 - B2, B2 - B3));
    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);
    vec3 At = A0 + A * t.value;
    vec3 B2B1hat = normalize(B2 - B1);
    vec3 B3B2hat = normalize(B3 - B2);
    vec3 B1B3hat = normalize(B1 - B3);
    return maybe_float(t.value, 
        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) && 
        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) && 
        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)
    );
}

// Function 1644
vec3 distmarch( vec3 ro, vec3 rd, float maxd )
{
    
    float dist = 6.;
    float t = 0.;
    float material = 0.;
    float heat = 0.;
    for (int i=0; i < DISTMARCH_STEPS; i++) 
    {
        if (( abs(dist) < EPSILON || t > maxd) && material >= 0. ) 
            continue;

        t += dist;
        vec3 dfresult = scenedf( ro + t * rd, rd );
        dist = dfresult.x;
        material = dfresult.y;
        heat = dfresult.z;
    }

    if( t > maxd ) material = -1.0; 
    return vec3( t, material, heat );
}

// Function 1645
float HeightMap( vec2 p ){
	return texture(iChannel0, p).x;
}

// Function 1646
float SDF1(vec3 p) {
    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;
    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));
}

// Function 1647
float SDF( vec3 pos )
{
    float thickness = .02;
    const int n = 50;
    float f = 1e20;
    for ( int i=0; i < n; i++ ) // can make this faster by using pos.z as an index, but then need to have bounds on adjacent rings
    {
        float fi = (float(i)+.5)/float(n);
        float a = 6.283*(fi*.5-.25);
        float h = sin(a);
        float r = cos(a);
        
        float sliceAngle = -iTime*1.618 + (fi-.5)*6.283*(1.8*cos(iTime*.6) + 49.*smoothstep(.5,1.,-cos(iTime*.1)));
        vec2 slice = vec2(cos(sliceAngle),sin(sliceAngle));
        
        f = min( f,
                max(
                    Torus( pos-vec3(0,0,h), r, thickness),
                    dot(pos.xy,slice) // plane
                )
            );
        
        // add sphere end caps
        vec3 end = vec3( slice.y*r, -slice.x*r, h );
        f = min( f, length(pos - end) - thickness );
        end.xy = -end.xy;
        f = min( f, length(pos - end) - thickness );
    }
    
    return f;
}

// Function 1648
float llamelMap(in vec3 p) {
	const vec3 rt=vec3(0.0,0.0,1.0);	
	p.y += 0.25*llamelScale;
    p.xz -= 0.5*llamelScale;
    p.xz = vec2(-p.z, p.x);
    vec3 pori = p;
        
    p /= llamelScale;
    
	vec2 c=floor(p.xz);
	p.xz=fract(p.xz)-vec2(0.5);
    p.y -= p.x*.04*llamelScale;
	float sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;

    float b=0.83-abs(p.z);
	float a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);
	vec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);
	float dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));
	p.y-=0.03;
	float dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;
	a=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;
	j0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);
	float dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);
	dB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));
	a=max(abs(p.z),p.y)+0.05;
	return max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);
}

// Function 1649
float polarDist(vec2 v1, vec2 v2) { 
	//Formula ripped from 
	//http://math.ucsd.edu/~wgarner/math4c/derivations/distance/distancepolar.htm
	return sqrt(v1.x * v1.x + v2.x * v2.x - 2.0 * v1.x * v2.x * cos(v1.y - v2.y));
}

// Function 1650
float iqsVoronoiDistanceInefficient( vec2 x ) {
    float minDist = 1.0;
    
    vec2 mb;
    vec2 mr;
    
    vec2 a, b;
    
    vec2 res = vec2(8.0);
    for(float i = 0.0; i < 100.0; ++i) {
        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);
        vec2 particlePos = texture(iChannel0, bufB_UV).xy;
        
        vec2 r = particlePos - x;
        float dist = dot(r, r);
        
        if(dist < res.x) {
            res.y = dist;
            mr = r;
            a = r;
        }
        else if(dist < res.y) {
            res.y = dist;
            b = r;
        }
    }
    
    /*
    for(float i = 0.0; i < 100.0; ++i) {
        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);
        vec2 particlePos = texture(iChannel0, bufB_UV).xy;
        vec2 r = particlePos - x;
        float dist = dot(0.5 * (mr + r), normalize(r - mr));
        res = min(res, dist);
    }

    return res;
	*/
    return dot(0.5 * (a + b), normalize(b - a));
}

// Function 1651
float distline(float x,float o)
{
	float i = floor(x);
	float f = fract(x);
    f = f*f*(3.0-2.0*f);
	float m = .91456789+o*0.345678;
	float a = fract(i*m+0.5678);//rnd(vec2(i,o));
	float b = fract((i+1.)*m+0.5678);//rnd(vec2(i+1.,o));
	return mix(a,b,f);
}

// Function 1652
vec3 intersect_scene( ray_t ray )
{
    vec3 endCol = vec3(0);
    vec3 specMod = vec3(1);
    intersection_t bestI;
    intersection_t ht;
    ray_t r = ray;
    for( int j = 0; j < MAX_BOUNCES; j++)
    {
        bestI.t = INFINITY;
        // Intersect geometry, finding closest point
#ifdef DRAW_SPHERES
        for(int i = 0; i < NUM_SPHERES; i++)
        {
            ht = sphere_intersect( spheres[ i ], r );
            if( ht.t < bestI.t ) { bestI = ht; }
        }
#endif
#ifdef DRAW_ROOM
        for( int i = 0; i < NUM_PLANES; i++)
        {
            ht = plane_intersect( planes[ i ], r );
            if( ht.t < bestI.t ) { bestI = ht; }
        }
#endif
        // Quit if we don't hit anything
        if( bestI.t == INFINITY ) { break; }
     	hit = 1.0;
        
        // Shade
        endCol += specMod*intersection_shade( bestI );
        specMod *= bestI.mat.ks; // Keep track of specular intensity of each reflection
        
        // Reflect ray about normal
        r.o = bestI.hitpt + bestI.normal * EPSILON;
        r.d = reflect( r.d, bestI.normal );        
    }
    
    return endCol;
}

// Function 1653
vec3 vehicle_sdf_grad(in vec3 loc) {
    float dist = vehicle_sdf(perturb(loc));
    const float del = 0.01;
    return vec3(vehicle_sdf(perturb(loc + vec3(del, 0.0, 0.0))) - dist,
                vehicle_sdf(perturb(loc + vec3(0.0, del, 0.0))) - dist,
                vehicle_sdf(perturb(loc + vec3(0.0, 0.0, del))) - dist) / del;
}

// Function 1654
float dist(vec3 pos, bool smth)
{
    pos+=.00015*getRand(pos*1.3).xyz*4.;
    pos+=.00006*getRand(pos*3.).xyz*4.;
    pos+=.00040*getRand(pos*.5).xyz*4.;
    vec3 p1,p2,p3;
    float d = 10000.;
    
    // sphere in the middle
	d=min(d,distSphere(pos,.9));
    
    // start with an icosahedron subdivided once
    getIcosaTri(pos, p1, p2, p3);
    getTriSubDiv(pos, p1, p2, p3);
    // always sort by X, then Y, then Z - to get a unique order of the edges
    //sortXYZ(p1,p2,p3);
    float r0=.02;
    d=min(d,distTruchet(pos, p1,p2,p3,r0,smth));
    
    float sc = 1.;
    // subdivide again for another detail
    getTriSubDiv(pos,p1,p2,p3);
    //sortXYZ(p1,p2,p3);
	sc = 1./.97;
    d=min(d,distTruchet(pos*sc, p1,p2,p3,r0/2.,smth)/sc);
    
    // subdivide again for another detail
	getTriSubDiv(pos,p1,p2,p3);
    //sortXYZ(p1,p2,p3);
    sc = 1./.96;
    d=min(d,distTruchet(pos*sc, p1,p2,p3,r0/4.,smth)/sc);
    
    return d;
}

// Function 1655
vec2 nmaps(vec2 x){ return x*2.-1.; }

// Function 1656
void sceneCube(vec2 fragCoord, vec2 uv, out vec3 params)
{
	vec3 dir = normalize(vec3(uv.x, uv.y, 1.));
	vec3 ray=vec3(0,0,-5.);
	float t=0.0;
	float k = 0.;
	for(int i=0;i<32;i++)
	{
		k=sdCube(ray+dir*t);
		t+=k*0.75;
	}
	vec3 hit=ray+dir*t;
	vec2 h=vec2(-0.002,0.0);
	vec3 n=normalize(vec3(sdCube(hit+h.xyy),sdCube(hit+h.yxy),sdCube(hit+h.yyx)));
	float color = .0;
	params = vec3(0,rangeBlack);
	if(abs(k)<.001)
	{
		vec2 range = rangeSkintone;
		if(iBeat >= 158.) {
			range = hash12(floor(iBeat*4.))*63.;
		}
		vec3 light = vec3(-.5,-.5,1);
		color = max(0.,dot(n,normalize(light)));
		params = vec3(
			color*color + hash2(fragCoord.xy)*.3,
			range
		);
	}
}

// Function 1657
void init_scene() {

    // Light Sphere
	material lightSurface;
	lightSurface.albedo = vec3(1.0);
	lightSurface.emission = vec3(70.0);
	lightSurface.roughness =1.0;
	lightSurface.specular = 1.0;
	lightSurface.metalness = 1.0;
    spheres[0] = Sphere(vec3(0.0, 6.8, -2.0), 4.1, lightSurface);
    
    // Diffuse sphere
	material diffuseSurface;
	diffuseSurface.albedo = vec3(0.1, 0.1 ,0.10);
	diffuseSurface.emission = vec3(0.0);
	diffuseSurface.roughness = 0.9;
	diffuseSurface.specular = 0.1;
	diffuseSurface.metalness = 0.0;
    spheres[1] = Sphere(vec3(1.3, -1.5, -2.2), 1.5, diffuseSurface);
           
    // Metal sphere
	material metalSurface;
	metalSurface.albedo = vec3(0.5, 0.5 ,0.5);
	metalSurface.emission = vec3(0.0);
	metalSurface.roughness = 1.0;
	metalSurface.specular = 1.0;
	metalSurface.metalness = 1.0;
    spheres[2] = Sphere(vec3(0.0, -2.3, -0.8), 0.7, metalSurface);
    
    // Magenta metal sphere
	metalSurface.albedo = vec3(1.0, 0.1 ,1.0);
    spheres[3] = Sphere(vec3(-2.0, 1.3, -1.8), 0.9, metalSurface);
    
    // Cyan metal sphere
	metalSurface.albedo = vec3(0.2, 1.0 ,1.0);
    spheres[4] = Sphere(vec3(-1.5, -2.3, -3.0), 0.6, metalSurface);
   
    // Room material
	material roomSurface;
	roomSurface.albedo = vec3(0.8);
	roomSurface.emission = vec3(0.0);
	roomSurface.roughness = 1.0;
	roomSurface.specular = 0.0;
	roomSurface.metalness = 0.0;
    
	// Floor
    planes[0] = Plane(vec3(0.0, -3.0, 0.0), vec3(0,1,0), roomSurface);

	// Ceiling
    planes[1] = Plane(vec3(0.0, 3.0, 0.0), vec3(0.0,-1.0,0.0), roomSurface);
                     
    // Back wall            
    planes[2] = Plane(vec3(0, 0, -5), vec3(0,0,1.0), roomSurface);
                      
    // Left wall (red)
	roomSurface.albedo = vec3(0.95, 0, 0);
    planes[3] = Plane(vec3(-3, 0.0, 0.0), vec3(1.0,0.0,0.0), roomSurface);
    
    // Right wall (green)
	roomSurface.albedo = vec3(0.0, 0.95, 0);
    planes[4] = Plane(vec3(3.0, 0.0, 0.0), vec3(-1.0,0,0), roomSurface);
}

// Function 1658
vec2 distanceZ( in vec3 p )
{
	vec3 q1 = vec3(p.xy,p.z + 0.2); 
	q1.x *= sign(q1.y);
	q1.y = abs(q1.y) - 0.3;
	q1.x += 0.5*q1.y;
	q1.y /= (0.5*q1.x+1.0);
	
	// Commented code: Only one box, but the space is too distorted -> more artifacts
	//q1.y *= mix(1.0,0.2,max(-sign(q1.y),0.0)*max(-sign(q1.x),0.0)) / (0.5*q1.x+1.0);
	//float dist = udBox(q1,vec3(0.3,0.1,0.1)); 
	
	float dist = min(distBox(q1,vec3(0.3,0.1,0.1)),distBox(q1 + vec3(0.15,0.2,0.0),vec3(0.15,0.3,0.1)));
	
	return vec2(dist,2.0);
}

// Function 1659
vec4 map(vec4 r0)
{  vec3 p=r0.xyz ;
 
float myTime= iTime*2.1 ;
 
 
  mdt[] v4= mdt[]  ( 
    mdt(vec3( 1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)), 
      mdt(vec3(13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.+0.5)*3.,vec3(10,10,11)),
    mdt(vec3(20,-15,-20)+walkbob(myTime/2.+0.5)*8.+swing(myTime/2.+0.0)*20.+sway(myTime/4. )*2.,vec3(7,7,7)), 
      mdt(vec3(15,  1,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(5,6,4)),
    mdt(vec3(22, -10,-81)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(8,7,5)),
      mdt(vec3(25,-20,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*8.,vec3(4,6,4)));
  mdt[] v5= mdt[]  ( 
    mdt(vec3(  -1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)),
      mdt(vec3(-13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.)*3.,vec3(10,10,11)),
    mdt(vec3(-20,-15,-20)+walkbob(myTime/2.)*8.+swing(myTime/2.+0.5)*20.+sway(myTime/4. +0.5)*2.,vec3(7,7,7)),
      mdt(vec3(-15,  1,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(5,6,4)),
    mdt(vec3(-22, -10,-81)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(8,7,5)),
      mdt(vec3(-25,-20,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*8.,vec3(4,6,4))); 

 
 
 
 
 // make a few points
float d1=1000000000.;
float d2=d1;
float d3=d1;
float d4=d1;
float d5=d1;
 
 for( int i=0; i<5; i++ ){
  d1= synmin(d1,conecapsule( p -walkbob(myTime)*6.+swing(myTime/2.+0.5)*2.
                            +vec3(0,-4,0)+sway(myTime/4.+0.5)*2.
                            ,  v1[i].pos , v1[i+1].pos ,v1[i].scale,v1[i+1].scale ),2.);
  d2= synmin(d2,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime+0.25)*2.,  v2[i].pos , v2[i+1].pos ,v2[i].scale,v2[i+1].scale ),1.);
  d3= synmin(d3,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime-0.25)*2.,  v3[i].pos , v3[i+1].pos ,v3[i].scale,v3[i+1].scale ),1.);
  d4= synmin(d4,conecapsule( p,  v4[i].pos , v4[i+1].pos ,v4[i].scale,v4[i+1].scale ),1.);
  d5= synmin(d5,conecapsule( p,  v5[i].pos , v5[i+1].pos ,v5[i].scale,v5[i+1].scale ),1.);
 }
 float d=synmin(d1,min(  min(d3,d2), smin(d4,d5,1.0)),3.0);
 float z=p.z+93.;
  
 float c1= mod( 
        mod (floor(p.x/30.),2.)+
        mod (floor(p.y/30.),2.)+
        mod (floor(p.z/30.),2.) ,2.);
 vec3 c2= vec3(0.9,  0.9, 0.8);
 vec3 c= d<z?c2:vec3(c1);
 return vec4(min(d,z) ,c)
               ;

 }

// Function 1660
float sdfIFS(vec3 z, out Surface surf){
    
	float scale = 2.;
    int Iterations = 16;
    mat3 rot = rotationMatrix(vec3(.5)*Pi);
    
    vec3 n1 = normalize(vec3(1., 1., -1.));
    vec3 n2 = normalize(vec3(1., -1., -1.));
    //vec3 n3 = normalize(vec3(1., -1., 1.));
    
    vec3 ot = vec3(1.);
    for(int i = 0; i < Iterations; i++) {
        fold(z, vec3(-.0), n1);
        fold(z, vec3(-.25), n2);
        //fold(z, vec3(-.25), n3);
        n1 *= rot;
        z = z*scale - sign(z)*(scale-1.0);
        ot = min(abs(z), ot);
    }
    surf = Surface(true, 1.0, .1, vec3(0.), vec3(.8));
    if(ot.r >= .75) surf = Surface(false, 1., .0, ot.ggb*30.*vec3(12., 2., .5), vec3(0.1));
    return length(z) * pow(scale, float(-Iterations));
}

// Function 1661
float sceneSDF(vec3 p){
    p /= scale;
    float result = planet(p);
    float scale = 1.0;
    for(int i = 0; i < 4; i++){
        scale *= 1.07;
        //p = -p.yzx;
        float t1 = iTime*scale*3.0;
        p += scale*(p+5000.0*vec3(sin(t1),cos(t1),0));

		result = min(result,planet(p));
    }
    return result;
}

// Function 1662
void scene(in vec3 x, out vec2 sdf)
{
    x.y = mix(x.y, -x.y, step(150., iTime));
    x.y += mix(.2,-.2,step(150., iTime))*iTime;
    
    dvoronoi(1.5*x.xy, v, vind);
    
    vec3 y = vec3(vind/1.5-x.xy,x.z);
    
    float n, n2;
    
    lfnoise(c.xx-.3*iTime+vind*3., n);
    lfnoise(5.*x.z*c.xx-iTime-vind*4., n2);
    n2 *= .2;
    
    mat2 RR = mat2(cos(n2), sin(n2), -sin(n2), cos(n2));
    vec2 a = x.xy;
    x.xy = RR * x.xy;
    rand(vind, r1);
    float r2;
    rand(vind -1336., r2);
    
    float phi = atan(y.y, y.x),
        dp = pi/24.,
        phii = mod(phi, dp)-.5*dp,
        pa = phi - phii, 
        R1 = .05,
        R2 = mix(.4,.25,1.-r2);
    
    R2 = mix(R1, R2, .5+.5*n2);
    
    float r0;
    rand(pa*c.xx, r0);
    r0 = mix(r0,.5+.5*n,.5);
    
    dspline3(y, vec3(1.4*R1*cos(pa), 1.4*R1*sin(pa), -.5), vec3(R1*cos(pa), R1*sin(pa), .1*r1), vec3(mix(R1,R2,.5)*cos(pa), mix(R1,R2,.5)*sin(pa), .1*r1), sdf.x);
    float da;
    dspline3(y, vec3(mix(R1,R2,.5)*cos(pa), mix(R1,R2,.5)*sin(pa), .1*r1), vec3(R2*cos(pa), R2*sin(pa), .1*r1), vec3(R2*cos(pa), R2*sin(pa), .1-.4*r0), da);
    sdf.x = min(sdf.x, da);
    stroke(sdf.x, .25*mix(.02,.05, .5+.5*n2), sdf.x);
    sdf.y = 2.;
    
    add(sdf, vec2(length(y-vec3(R2*cos(pa), R2*sin(pa), .1-.4*r0))-.01, 3.), sdf);
    
    float fa;
    lfnoise(4.*a,  fa);
    dvoronoi(a,fn, vind2); 
    fa = x.z+.4+.1*mix((v+fn),fa,.5);
    add(sdf, vec2(fa,4.), sdf);
    smoothmin(sdf.x, fa, .1, sdf.x);
}

// Function 1663
float sceneHigh(vec3 pos) {
	return pos.y - fbmHigh(pos * 0.006) * 80.0 + 65.0;
}

// Function 1664
vec4 scene1( vec3 p )
{
	vec4 d = vec4( FAR_CLIP, 0.0, 0.0, -1.0 ); //note: background

	vec3 cyl_pos = vec3( 0, -10, 0 );
	float cyl_scl = 10.0;
	float cyl_r = 0.1;
	vec4 crr = cylinder_radialrepeat( (p-cyl_pos)/cyl_scl, cyl_r*0.5 );
	crr.x *= cyl_scl;

    return crr;
}

// Function 1665
float sdf_G(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(4, -4, 0)));
    return t;
}

// Function 1666
float Map( vec3 p )
{
	p = p.xzy;
	float scale = 1.1;
	for( int i=0; i < 8;i++ )
	{
		p = 2.0*clamp(p, -CSize, CSize) - p;
		float r2 = dot(p,p);
        //float r2 = dot(p,p+sin(p.z*.3)); //Alternate fractal
		float k = max((2.)/(r2), .5);
		p     *= k;
		scale *= k;
	}
	float l = length(p.xy);
	float rxy = l - 1.0;
	float n = l * p.z;
	rxy = max(rxy, (n) / 8.);
	return (rxy) / abs(scale);
}

// Function 1667
float map(vec3 p)
{

    vec3 q = p;

    float rep = 0.1;
        
    vec3 c = vec3(rep);
    p.z = mod(p.z,c.z)-0.5*c.z;

    
    vec3 p_s;
        
    float bars = 1000.0;
    float inner = 1000.0;
    int sides = 4;
    float angle = 3.1415 * 0.5;
    
    float blockID = floor(q.z / rep) + iTime * 0.2;
    
    for ( int i = 0; i < sides; i ++)
    {
        
        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));
        
        
        
        float cutout = 10000.;
        vec2 line = vec2(0.3, 0.01);
        p_s = p_s.yxz + vec3(
            sin(blockID * 3.0)* 0.5 + 0.3 ,
            0.0,
            0.0);
         
        p_s = p_s * rotationMatrix(vec3(0.0, 0.0, 1.0),  sin(blockID/3.0 ));
      // 	p_s = p_s * vec3(3.0, 1.0, 1.0);

        cutout = sdTorus88(p_s, line);
        
        inner = min(inner, cutout); 
        
        

    }

        
    
    float result = inner;  
    return result;
}

// Function 1668
vec3 map(vec3 pos){
	
    vec3 d1 = cartBoy(pos);
    vec2 bri = waves(pos);
    if(bri.x<d1.x) {d1.y = bri.y; d1.x = bri.x;}
    else{
    d1= d1;
    }
    vec2 cart = cartun(pos);
    if(cart.x<d1.x) {d1.y = cart.y; d1.x = cart.x;}
    else{
    d1= d1;
    }
    float d2 = pos.y+0.2;
    
    return (d2<d1.x) ? vec3(d2,0.0,0.0):d1;
	
}

// Function 1669
float SphereSDF(vec3 p, float r) {
    return length(p) - r;
}

// Function 1670
int maptmp(int id, int midg) {
#endif
    int nBits = 8;
    ivec4 pixeldata = loadat(id, midg);
    int itt = (id / 24) / 4; //data pixel id 0-2
    int jtt = (id - itt * 24 * 4) / 24; //component in data pizel id 0-3
    int ott = (id - itt * 24 * 4 - jtt * 24) / 8; //component in unpacked value 0-2
    int ttt = (id - itt * 24 * 4 - jtt * 24 - ott * 8); //bit after int2bit 0-7
    ivec3 val = decodeval16(pixeldata[jtt]);
    int n = val[ott];
    for (int i = 0; i < nBits; ++i, n /= 2) {
        if (i == ttt) {
            if ((n % 2) == 0)return 0;
            else return 1;
            //switch + return does not work on windows(Angle)
            /*switch (n % 2) {
               case 0:return 0;break;
               case 1:return 1;break;
            }*/
        }
    }
    return 0;
}

// Function 1671
float signedDistanceHorizontal( in vec2 position ) { return position.y; }

// Function 1672
float sdf_half2_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, pos.x);
}

// Function 1673
float terrainMap( const in vec3 p ) {
	return (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;
}

// Function 1674
vec3 doBumpMap(vec2 uv, vec3 nor, float bumpfactor)
{
   
    const float eps = 0.001;
    float ref = bumpmap(uv); 
    
    vec3 grad = vec3(bumpmap(vec2(uv.x-eps, uv.y))-ref, 0.0, bumpmap(vec2(uv.x, uv.y-eps))-ref); 
             
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
}

// Function 1675
void sceneMap3D(vec3 pos, out float t, out int obj)
{
    float minT = 10000.0;
    obj = -1;
    for(int i = 0; i < primitives.length(); i = i + 1)
    {
        if(primitives[i].primitiveId == SQUARE_PLANE)
        {
            vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));
            float maxOffset = max(max(abs(primitives[i].transform.trans.x), 
                                      abs(primitives[i].transform.trans.y)), 
                                      abs(primitives[i].transform.trans.z));
            curNor.w = maxOffset;
        	t = squarePlane(pos, curNor);
        }
        else if(primitives[i].primitiveId == CUBE)
        {
        	t = cube(pos, primitives[i].transform);
        }
        
       
        
        if(t < minT)
        {
        	minT = t;
            obj = i;
        }
    }
   
    t = minT;
}

// Function 1676
float sceneLum(vec3 p)
{
    return sceneLumSphere (p); // <--- Change this to try different ones...
}

// Function 1677
bool Map_PointInSector( sampler2D mapSampler, vec2 vPos, Sector sector )
{
    float fInOutTest = 0.0;
    
    for(int iSideDefIndex=0; iSideDefIndex< NO_UNROLL( sector.iSideDefCount ); iSideDefIndex++)
    {        
        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );
        
        vec2 vPosToA = sideDef.vA - vPos;
        vec2 vPosToB = sideDef.vB - vPos;
        
        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )
        	continue;
        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )
        	continue;               
        
        float fCross = Cross2d( vPosToA, vPosToB );
        if ( vPosToA.y > vPosToB.y )
            fCross = -fCross;
        if ( fCross < 0.0 )
        {
            fInOutTest++;
        }        
    }
    
    return mod( fInOutTest, 2.0 ) >= 1.0;    
}

// Function 1678
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){
    float factor = pow(abs(rayDir.y), .5)*sign(rayDir.y)*.5+.5;
	vec3 col = vec3(.4, .6, .9) * factor + vec3(1.2) * (1.0-factor);
    fragColor = vec4(col, 1.0);
}

// Function 1679
float sdf(vec3 p)
{
  vec3 q = abs(p) - vec3(2.);
  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);
}

// Function 1680
float distanceToSegment( in vec2 p, in vec2 a, in vec2 b )
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	
	return length( pa - ba*h );
}

// Function 1681
vec2 scene_base_sand(vec3 _p)
{
 	return vec2(_p.y
    -(
    #if defined(ENABLE_HD_SAND_DEPTH)
        .2*_p.z*fbm_hash3D(_p*.02)+remap01(_p.z, -40., 40.)*voronoi3D(.2*_p)
    #else
        .2*_p.z*fbm_hash2D(_p.xz*.02)+remap01(_p.z, -40., 40.)*voronoi2D(.2*_p.xz)
    #endif
    )
    , MATERIAL_SAND);
}

// Function 1682
float AnaliticalDistSpark(in vec3 ro, in vec3 rd, vec3 point, float distThreshold)
{
	float lambda = dot(-(ro - point),rd);
	float dist = length((ro+rd*lambda)-point);
	return mix(9999.0,dist,step(-1.0,lambda)*step(lambda,distThreshold+1.0)); 
}

// Function 1683
float map(vec3 p)
{
    // distort the scene
    tTwist(p, _twist);
    
    // repeat the scene along x and z axis
    tRepeat2(p.xz, vec2(.7, 1.));
    
    // mirror along x
    p.x = abs(p.x);
    
    // lower everything by .5
    p.y += .5;
    
    // add the wall
    float d = abs(p.z) - .15;
    
    // carve out the window
    float w = opU(sdCircle(p.xy - vec2(0, .75), .25), sdRect(p.xy - vec2(0, .375), vec2(.25, .375)));
    d = opS(d, w);
    
    // make space for the columns
    d = opS(d, sdRect(p.xy - vec2(0,.35), vec2(.45,.3)));
    
    // add the colums
    d = opU(d, sdCircle(p.xz - vec2(.35, 0), .075));
    
    // mirror along z
    p.z = abs(p.z);
    
    // remove extra wall at the column base and top
    d = opS(d, sdRect(p.yz - vec2(.6, .5), vec2(.6,.4)));
    
    // add the ceiling and the floor
    d = opU(d, -abs(p.y - .5) + .8);
    return d;
}

// Function 1684
vec4 map(in vec2 p, in vec2 dir) {
    vec3 v = voronoi(p*2.0, dir)*0.5;
    return vec4(v, disp(v.yz));
}

// Function 1685
float map(in vec3 p) {
    vec3 q = mod(p+2.0, 4.0) - 2.0;
	float d0 = length(q) - 1.0;
    d0 += 0.1 * sin(10.0 * p.x) * sin(10.0 * p.y + 10.0 * iTime) * sin(10.0 * p.z);
    float d1 = p.y + 1.0;
    
    float k = 1.225;
    float h = clamp(0.5 + 0.5 * (d0 - d1)/k, 0.0, 1.0);
    return mix(d0, d1, h) - k * h * (1.0 -h);
}

// Function 1686
float calc_dist(in vec3 point, out int obj_id)
{
	int mush_id;
	float mush_dist = calc_dist_mushroom(point, mush_id);

	int ground_id;
	float ground_dist = calc_dist_ground(point, ground_id);

	float dist = ground_dist;
	obj_id = ground_id;

	if (mush_dist < dist) {
		obj_id = mush_id;
		dist = mush_dist;
	}

	return dist;
}

// Function 1687
float getDistance(vec3 p) {
    return min(planeSDF(p, vec4(0., 1., 0., - 1.)), teaPotSDF(p - vec3(0., 0., 3.)));
}

// Function 1688
vec2 map(in vec3 l, in sph s) {
    vec3 n = nrm(l, s);
    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);
}

// Function 1689
SceneResult Scene_GetDistance( const vec3 vPos, const int iInsideObject )
{
    SceneResult result;
    
    vec3 vWineGlassPos = vec3(0.0, 0.0, -2.0);
    vec3 vBowlPos = vec3(1.0, 0.0, 1.0 );

	result.fDist = vPos.y;
    result.vUVW = vPos;
	result.iObjectId = MAT_DEFAULT;

        
    SceneResult sphereResult1;
    
    
    vec3 vSphere1Pos = vBowlPos + vec3(0.4, 0.5, 0.2);
    sphereResult1.vUVW = vPos - vSphere1Pos;
    sphereResult1.fDist = min( result.fDist, length(vPos - vSphere1Pos) - 0.4);
	sphereResult1.iObjectId = MAT_GLOSS_PAINT;
    Scene_Union( result, sphereResult1 );    
    

    vec3 vSphere2Pos = vec3(2.2, 0.5, -0.9);
    SceneResult sphereResult2;
    sphereResult2.vUVW = (vPos - vSphere2Pos).zyx;
	sphereResult2.fDist = length(vPos - vSphere2Pos) - 0.5;
	sphereResult2.iObjectId = MAT_GLOSS_PAINT;
    Scene_Union( result, sphereResult2 );
    
    if ( result.fDist > 10.0 )
    {
        result.iObjectId = MAT_SKY;
    }
    
    SceneResult wineResult;
    wineResult.vUVW = vPos;
	wineResult.iObjectId = MAT_WINE;    
    wineResult.fDist = GetDistanceWine( vPos - vWineGlassPos );
    
    
    float fRadius = 1.0;
    float fHeight = 1.0;
    
    SceneResult glassResult;
    glassResult.iObjectId = MAT_GLASS;
    glassResult.fDist = length(vPos - vec3(-2.0,fHeight,1.0)) - fRadius;
    
    glassResult.fDist = min(glassResult.fDist, GetDistanceBowl( vPos - vBowlPos));
        
    glassResult.vUVW = vPos.xzy;
    glassResult.fDist = min( glassResult.fDist, GetDistanceWineGlass(vPos - vWineGlassPos ) );    

    //glassResult.fDist = min( glassResult.fDist, GetDistanceMug(vPos - vec3(-2.0, 1.0, -2.0) ) );    

    Scene_Trim( wineResult, glassResult );
    wineResult.fDist -= 0.0001;
    
    if ( iInsideObject == MAT_GLASS )
    {
        glassResult.fDist = -glassResult.fDist;
    }

    if ( iInsideObject == MAT_WINE )
    {
        wineResult.fDist = -wineResult.fDist;
    }
        
    Scene_Union( result, glassResult );
    Scene_Union( result, wineResult );
    
    return result;
}

// Function 1690
bool traceSceneShadow(vec3 ro, vec3 rd)
{
    vec3 p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);
    vec2 b = box(ro, rd, p,q);

    if(b.x > 0. && b.x < b.y)
    {
        return false;
    }

    float a = 3.9;
    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));   

    ro.xz *= m;
    rd.xz *= m;

    ro.xy *= m;
    rd.xy *= m;

    ro.yz *= m;
    rd.yz *= m;

    p = vec3(-.26), q = vec3(.26);
    b = box(ro, rd, p, q);

    if(b.x > 0. && b.x < b.y)
    {
        return false;
    }

    return true;
}

// Function 1691
vec3 scene(vec2 uv, vec2 ms) {
	
    // the ray origin will be the mouse position
	vec2 ro = ms;
	// and the ray direction will point a coordinate (.0,.5)
    float a = atan(ro.y-.5,ro.x)+radians(180.);
	vec2 rd = vec2(cos(a),sin(a));
	
    // setting the color of the background
	vec3 color = vec3(.0,.0,.3)*fill(abs(-uv.y+uv.x),4.,1.);
    
    // a few variables to set up the triangular prism
	float triSdf = sdfMap(uv);
	float triMsk = fill(triSdf,.05,1.);
	float prism = (1.-abs(triSdf)*10.)*(1.-triMsk);	
	
    // shooting the ray in positive space until it hits the prism.
	vec2 hit = shootRay(ro,rd,1.);
    // coloring the initial white light ray
	color = mix(color,vec3(1.),fill(sdfSegment(uv,ro,hit),.05,.0));
	
    // when the ray hits the prism it will get refracted.
    // each wavelength of light has a different refractive indice
    // so I shoot 9 rays, each with a different indice and wavelength
	for (int i=1; i<10; i++) {
        
        // calculate the refractive indice. 
        // I just spread light around 1.52 the value for common glass.
		float f = float(i) * 0.05;
		float ridx = 1.30 + f;
		vec2 rdir = rd;
        
        // calculate the direction of the refraction
		rdir = refraction(normal(hit), rdir, 1./ridx);
        // and use it to shoot a ray in negative space inside the prism
		vec2 hit2 = shootRay(hit,rdir,-1.);
        
        // when the ray hits the other side of the prism, it will get refracted
        // again, but this time I invert the normal, because I'm in negative space
        // an invert the indice because the light is going from glass to vacuum.
		rdir = refraction(-normal(hit2), rdir, ridx/1.);
        // for the last part I don't need to shoot a ray, because it will 
        // not hit anything, so I just send away it far enough...
		vec2 hit3 = hit2+rdir*5.;//shootRay(hit2,rdir,1.);

        // coloring the ray inside the prism with it's pectrum
		float glassRay = (1.-triMsk)*fill(sdfSegment(uv,hit,hit2),.1,.0);
		color = clamp(color+spectrum(700.-f*600.)*glassRay*.5 ,.0,1.); 
		
        // coloring the ray outside the prism with it's spectrum
		float lightRay = triMsk*fill(sdfSegment(uv,hit2,hit3),.15,.0);
		color = clamp(color+spectrum(700.-f*600.)*lightRay,.0,1.);
	}
    
	// the prism
    color = mix(color,vec3(.7,.7,.9),prism);

	return color;
}

// Function 1692
void distCheck(float newDist, inout float minDist, int newMaterial, inout int minMaterial)
{
    if (newDist < minDist)
    {
    	minDist = newDist;
        minMaterial = newMaterial;
    }
}

// Function 1693
float map(vec3 p){
    vec3 zero=vec3(0.0,0.0,0.0);
    float p1=plane(p,vec3( 0.0,-1.0, 0.0),vec3( 0, 1, 0));
    float p2=plane(p,vec3( 0.0, 1.0, 0.0),vec3( 0,-1, 0));
    float p3=plane(p,vec3( 0.0, 0.0, 1.0),vec3( 0, 0,-1));
    float p4=plane(p,vec3( 0.0, 0.0,-1.0),vec3( 0, 0, 1));
    float p5=plane(p,vec3( 1.0, 0.0, 0.0),vec3(-1, 0, 0));
    float p6=plane(p,vec3(-1.0, 0.0, 0.0),vec3( 1, 0, 0));
    float c=opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);
    //carved cube
    //return opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);
    float pc=plane(p,vec3(0.0, 0.0, -1.0),vec3( 0, 0,1));
    return opU(pc,coneContour(p));
}

// Function 1694
vec3 map_Gsph_pm(vec3 ro) { 
    return vec3(0.);
}

// Function 1695
float map(vec3 p) 
{
   #ifdef ROTATION
   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
   #endif
   p.y+=4.1;
   return Nebulae(p) + fbm(p*50.+iTime);
}

// Function 1696
float Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )
{
    float fOcclusion = 0.0;
    float fScale = 1.0;
    for( int i=0; i<5; i++ )
    {
        float fOffsetDist = 0.001 + 0.15*float(i)/4.0;
        vec3 vAOPos = vDir * fOffsetDist + vPos;
        float fDist = Scene_GetDistance( vAOPos ).fDist;
        fOcclusion = max( fOcclusion, (fOffsetDist - fDist) * fScale / fOffsetDist );
        fScale *= 0.8;
    }
    
    float fAO = clamp( 1.0 - fOcclusion, 0.0, 1.0 );
    
    //return fAO;
    return sqrt(fAO);
}

// Function 1697
float remap(float a, float b, float c, float d, float t) {
	return ((t-a) / (b-a)) * (d-c) + c;
}

// Function 1698
float remap(float val, float im, float ix, float om, float ox)
{
    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);
}

// Function 1699
vec4 map(vec3 p) {   
    
    
    vec4 res = vec4(getBuildingColor(p), sdBox(opRep(p, vec3(15.0, 0.0, 15.0)), vec3(3.0, 15., 3.0)));
    res = opU(res, vec4(getRoadColor(p),sdBox(opRep(p, vec3(0.0, 0.0, 1.0)), vec3(3.0, .25, 5.0))));    
    
    // vec3 lp = p + (p.x > 0. ? vec3(0., 0., 2.5) : vec3(0.));
    vec3 lp = p;
    lp = lp + (abs(lp.x) > 10. ? vec3(0., -100., 0.): vec3(0.));
    float lh = 0.5;
    res = opU(res, vec4(vec3(1., 0., 0.),sdBox(opRep(lp + vec3(0., -lh, 0.), vec3(7.5, 0.0, 5.0)), vec3(.05, .20, .05))));    
    res = opU(res, vec4(vec3(0.5, .5, .5),sdBox(opRep(lp, vec3(7.5, 0.0, 5.0)), vec3(.05, lh, .05))));           
    
    res = opU(res, vec4(GROUND_COL,p.y));
    
	return res;
}

// Function 1700
Sector Map_ReadSector( sampler2D mapSampler, int iSectorId )
{
    Sector sector;
    
    sector.iSectorId = iSectorId;
    
    ivec2 vAddress = GetSectorAddress( iSectorId );
    
    vec4 vData0 = ReadMapData(mapSampler, vAddress);
    vAddress.x += 1;


    vec4 vData1 = ReadMapData(mapSampler, vAddress);
    vAddress.x += 1;

    sector.fLightLevel = vData0.x;
    sector.iSideDefCount = int(vData0.y);

    sector.fFloorHeight = vData1.x;
    sector.fCeilingHeight = vData1.y;
    sector.iFloorTexture = uint(vData1.z);
    sector.iCeilingTexture = uint(vData1.w);
    
    return sector;
}

// Function 1701
float rmDist(vec3 rayStart, vec3 rayDir, float minDist)
{
    float totalDist = minDist;
    float dist;
    float stepBias;
    
    for(int i = 0; i < MAX_STEPS; ++i)
    {   
        stepBias = 1.0;
        dist = distanceField(rayStart + rayDir * totalDist);
        totalDist += dist * stepBias;
        if(dist <= MIN_DIST)
        {
            return totalDist;
        }
        
        if(totalDist >= MAX_DIST)
        {
            return MAX_DIST;  
        }        
    }      
        
    return totalDist;    
}

// Function 1702
vec4 colormap(float x) {
    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);
}

// Function 1703
float boxDistance(vec3 point, vec3 position, vec3 extents) {
    vec3 adjustedPoint = point - position;
    vec3 p = abs(adjustedPoint) - extents;
    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);
}

// Function 1704
float mapWater(vec3 p, int steps, bool cube) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;
    const float SEA_SPEED = 0.8;
    const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);
    float seaTime = (1.0 + iTime * SEA_SPEED);
    for(int i = 0; i < steps; i++)
    {        
    	d = sea_octave((uv+seaTime)*freq,choppy);
    	d += sea_octave((uv-seaTime)*freq,choppy);
        h += d * amp;        
    	uv *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    if(!cube)
        return p.y -h;
    
    return p.y - h - 0.2*exp(-max(0.0, 23.0*map(p)));
}

// Function 1705
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    // Ray direction as color
    vec3 col = 0.5 + 0.5*rayDir;

    // Output to cubemap
    fragColor = vec4(col,1.0);
}

// Function 1706
vec2 map(vec3 p) {
  attr = max(0.0, (6.0 - (length(p + vec3(0., 0., 1.0-tt*2.5)) - 6.0)));

  vec3 q = p;
  vec2 a = vec2(length(q - vec3(0., 0., 10. + tt*2.5)) - 2.5, 2.0);

  q = p;
  q.z = mod(q.z - 1.0, 11.0);
  q = abs(q) - vec3(0., 6., 11.);
  for (int i=0; i<6; i++) {
    q = abs(q) - vec3(2.0, 0.0, 0.5);
    //q.xz *= rot2(radians(i*5));
    q.xy *= rot2(radians(4.+float(i)*1.5));
  }

  vec2 b = rails(q);

  a = (a.x < b.x) ? a : b;

  float s = sin(tt*.5)*2.0 +  + 1.5;
  float ss = cos(tt*.5)*2.0 +  + 1.5;
  q = abs(q) - vec3(s, ss*2.0, 0.);
  b = rails(q);

  a = (a.x < b.x) ? a : b;

  q = p;
  q.yz *= rot2(radians(90.0));
  b = vec2(spiral(q), 1.0);

  a = (a.x < b.x) ? a : b;

  return a;
}

// Function 1707
float map(in vec3 pos)
{
    float negCircle = length(pos) - 1.37;
    float cube = length(max(abs(pos) - 0.95, 0.0)) - 0.05;
    float shape = mix(max(-negCircle, cube), cube, 0.5 + sin(iTime * 0.4) * 0.5);;
    
    float roof = dot(pos, vec3(0.0, -1.0, 0.0)) + 2.0 + sin(pos.x * 35.0) * 0.005;
    float ground = dot(pos, vec3(0.0, 1.0, 0.0)) + 1.0;
    float backWall = dot(pos, vec3(0.1, 0.0, -1.0)) + 6.5;
    float frontWall = dot(pos, vec3(0.1, 0.0, 1.0)) + 6.5;
    
    vec3 repeatPos = mod(pos + vec3(0.0, -0.05, 0.0), 2.0) - 0.5 * 2.0;
    float pillars = length(max(abs(repeatPos) - 0.15, 0.0)) - 0.05;
    pillars = max(-(dot(pos, vec3(0.0, -1.0, 0.0)) + 0.5), pillars);
    
    return min(min(min(min(min(shape, roof), ground), backWall), frontWall), pillars);
}

// Function 1708
float map(vec3 rp) {
    
    float msd = FAR;
    for (int i = 0; i < 16; i++) {    
       rp = abs(rp) / dot(rp, rp) - .25;  
       msd = min(msd, sdBox(rp, 1.0 - rp, vec3(1.0)));
    }
    
    return msd;
}

// Function 1709
float dist(HalfPlane r, vec2 p)
{
    return (dot(r.dir, p-r.org)/dot(r.dir, r.dir));
}

// Function 1710
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    if (iFrame < 60)
    {
        vec3 rd = rayDir;
        // the direction and color of the sun
        vec3 sun_col = vec3(1., 0.9, 0.6);
        //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));
        vec3 sun_dir = normalize(vec3(0., 0.75, -1.));

        // using triplanar mapping to map the stars texture onto the sky
        vec3 col = pow(TriplannarStarsTexture(rd * 5., rd), vec3(4.));
        col = mix(col, sun_col * 1.2, pow(max(dot(sun_dir, rd), 0.), 200.));

        fragColor = vec4(col, 1.0);
    }
    else
    {
        // not doing the math to calculate things like this after frame 60 to give better preformace
        fragColor = texture(iChannel0, rayDir);
    }
}

// Function 1711
float minkowskiDistance(float p1, float p2, float power) {
	float d1 = pow(abs(p1 - p2), power);
	return pow(d1, 1.0 / power);
}

// Function 1712
vec4 put_text_map(vec4 col, vec2 uv, vec2 pos, float scale)
{
	float unit = asp * scale * 0.1;
    float h = 0.;
    vec2 sc = vec2(unit, unit*0.8);
    
    // M
    h = max(h, word_map(uv, pos, 77, sc));
    // a
    h = max(h, word_map(uv, pos+vec2(unit*0.35, 0.), 97, sc));
    // p
    h = max(h, word_map(uv, pos+vec2(unit*0.7, 0.), 112, sc));
    
    col = mix(col, vec4(1.-vec3(h), 1.), h);
    
    return col;
}

// Function 1713
vec2 RedBrickSDFY(vec3 p)
{
	vec2 d = BoxY(p+vec3(1.*brick_w,-1./3.,-11.*brick_w),vec3(6.*brick_w,2./3.,14.*brick_w));
	p.x = abs(p.x+1.*brick_w);
	d = UY(d, BoxY(p-vec3(5.*brick_w,1.,0.),vec3(brick_w*1.,2.,brick_w*3.) ));
	return d;
}

// Function 1714
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    return ( Scene_Trace( vRayOrigin, vRayDir, 0.001, fLightDist ).fDist < fLightDist ? 0.0 : 1.0);
    /*
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    */
}

// Function 1715
void drawSDF(inout vec3 col, vec3 pcol, float d, float r){

    float psize = 1.0/iResolution.y;

    d = ((d-r/zoom*psize*1024.0)*zoom);

    col = mix(pcol,col,smoothstep(-psize,psize,d));
}

// Function 1716
float segment_distance(vec2 p, vec2 p1, vec2 p2) {
    vec2 center = (p1 + p2) * 0.5;
    float len = length(p2 - p1);
    vec2 dir = (p2 - p1) / len;
    vec2 rel_p = p - center;
    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));
    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;
    return max(dist1, dist2);
}

// Function 1717
float opRepLimit_sceneT(vec3 p,vec3 c,vec3 lim)
{
    vec3 q;
	q = min(p,mod(p+.5*c,c)-.5*c); // less than 0
    q = max(q,p-(lim-vec3(1.0))*c); // more than limit
    return sceneT(q);
}

// Function 1718
vec3 simpleReinhardToneMapping(vec3 color)
{
	float exposure = 1.5;
	color *= exposure/(1. + color / exposure);
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 1719
bool Map(vec2 coord, int level)
{
    int x = int(coord.x);
    int y = int(coord.y);
    
    if(level == 0) return false;
    
    if(y < 0 || y >= LEVEL_HEIGHT) return false;
    if(x < 0 || x >= LEVEL_WIDTH) return true;
    
    level = ModLevel(level);
    
    
    return textureLod(iChannel0, (vec2(x + level*LEVEL_WIDTH, y+LEVEL_START_Y) + 0.5) / iChannelResolution[0].xy, 0.0).x > 0.5;
}

// Function 1720
vec3 Uncharted2Tonemap(vec3 x) {
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 1721
float signedDistanceToLine(vec2 p, vec2 n,vec2 c) {
 	// the line passes point c and has n as its normal
    return dot(p-c,n);
}

// Function 1722
float heightMap(vec2 p) {
	
    float height = valueNoise(p * HSCALE) * VSCALE;
    height = floor(height / STEPHEIGHT) * STEPHEIGHT;
    return height;
    
}

// Function 1723
float sdFloor(vec3 pos) {
	return pos.y;
}

// Function 1724
float map_glass_int(vec3 pos)
{
    float s1 = length(pos*vec3(1., 0.95, 1.) + vec3(0., -0.1, 0.)) - 0.3;
    s1 = mix(s1, length(pos.xz) - 0.34 + pos.y*0.3, smoothstep(-0.15, 0.28, pos.y));
    float dt = 0.004 * smoothstep(0.368, 0.38, pos.y);
    float s2 = s1 + 0.005 + dt + 0.05*smoothstep(-0.02, -0.33, pos.y);
    
    return s2;
}

// Function 1725
float map(vec3 p){
    
    vec2 pth = path(p.z);
    
    float sf = surfFunc(p); // Surface perturbation.

    // The terrain base layer.
    float ter = p.y - 3. + dot(sin(p*3.14159/18. - cos(p.yzx*3.14159/18.)), vec3(3)); // 6. smoothing factor.
    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.

    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.

    p.xy -= pth; // Wrap the tunnel around the path.

    float n = 1.5 - length(p.xy*vec2(.5, 1)); // The tunnel to bore through the rock.
    n = smax(n + (.5 - sf)*1.5, ter + (.5 - sf)*3., 6.); // Smoothly boring the tunnel through the terrain.
    n = smax(n, -max(abs(p.x) - 1.75, abs(p.y + 1.5) - 1.5), .5); // Clearing away the rock around the stairs.
 
    // Object ID.
    objID = step(n, st); // Either the physical path or the surrounds.
    
    return min(n, st)*.866; // Return the minimum hit point.
 
}

// Function 1726
vec2 map(vec3 p)
{
    p -= path(p.z);
    vec2 rz = vec2(0);
    vec3 bg = vec3(0.,0.,-15.);
    vec3 en = vec3(0.,0.,1.);
    
    const float pw = 0.15;
    
    rz.xy = 		 vec2(helix(p, bg, en, vec4(pw,    4.,   1., 3.1415))-tk, 1.05);
    rz.xy = opU(rz, vec2(helix(p, bg, en, vec4(pw,    4.,   1., 0.))-tk, 3.2) );
    rz = opU(rz, vec2(helix(p, bg, en, vec4(0.003, 100., 20.,1.))-tk, 2.) );
    rz = opU(rz, vec2(helix(p, bg, en, vec4(0.07,  2., 1.,  0.))-tk, 5.) );
    
    return rz;
}

// Function 1727
float sdf_U(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));
    return t;
}

// Function 1728
vec2 sdBPTScene( vec3 pos ) {

    float t = iTime;
    
    // xmas tree
    vec2 res = sdSphereLine_8( pos, vec3(0,0,0), vec3(0,1.125,0), 0.25, 0.1, 111., 111. );
    
    // train
    res = opU( res, sdTrain( pos ) );
    
    // jumping kids
   	res = opU( res, sdKid( pos, sdJumpingKidPath( vec3(1,0,0), t, 0.2 ), 0.5, 150. ) ); // kid-1
   	res = opU( res, sdKid( pos, sdJumpingKidPath( vec3(-1,0,0), -t, 0.2 ), 0.5, 210. ) ); // kid-2
    
    // watching parents
   	res = opU( res, sdParent( pos, vec3(0.25,0,-1), 0.75, 160. ) ); // parent-1
   	res = opU( res, sdParent( pos, vec3(-0.25,0,-1), 0.75 + sin(t) * 0.05, 120. ) ); // parent-2

    return res;
    
}

// Function 1729
float sdf(vec2 p) {
    return texture(iChannel0, worldToUV(p)).x;
}

// Function 1730
vec4 normalMap(vec2 uv) { return heightToNormal(normalChannel, normalSampling, uv, normalStrength); }

// Function 1731
bool map0(vec3 p)
{
    p += 0.5;
    vec3 b = abs(p);
    
    bool r;
    
    r =      b.x < 4.0;
    r = r && b.y < 4.0;
    r = r && b.z < 4.0;
    
    r = r && (b.x > 2.0 || b.y > 2.0);
    r = r && (b.z > 2.0 || b.y > 2.0);
    r = r && (b.x > 2.0 || b.z > 2.0);    
    
    return r;
}

// Function 1732
float GetDist(vec3 p){
    // some test object
    vec4 sphere = vec4(0,1,6,1);
    
    // distance to sphere
    //--------------------------------
    // distance to center of sphere: 
    // length(sphere position - camera position)
    // distance to outside of the sphere:
    // length(sphere position - camera position) - sphere radius
   // float ds = length(p-sphere.xyz)-sphere.w;
    
    //distance to floor (plane)
    //this is just height of the origin point passed
    float xMov = pow(sin((p.x*20. + iTime*pow(sin(iTime*.0001),5.))),8.)*.2;
    float zMov = pow(cos((p.z*20. + iTime*pow(cos(iTime*.0001),5.))),8.)*.3;
    float dp =p.y;
   
    // cylinder distance
    float offX = 2.;
    float offY = 0.;
    float offZ = 0.;
    float cyld2 = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);
    
    vec2 uv3 = vec2(atan(p.x-offX,p.z-offZ)/(3.14159*2.),p.y/5.)+.5;
    // cylinder distance
    offX = 0.;
    offY = 0.;
    offZ = 0.;
    float cyld = sdCylinder(p, vec3(0,0,0), vec3(0,2,0), 0.5, offX, offY, offZ);
    //displacement map for cylinder
    //uv for pillar
    vec2 uv = vec2(atan(p.x,p.z)/(3.14159*2.),p.y/5.)+.5;
    //uv for ground
    vec2 uv2 = vec2(p.x/10.,p.z/10.)+.5;
    
    
    
    float disp = texture(iChannel1,uv).r;
    float gDisp = texture(iChannel1,uv2).r;
    float disp3 = texture(iChannel1,uv3).r;

    float d = cyld;
    disp *= smoothstep(2.,1.8,abs(p.y));
    disp3 *= smoothstep(2.,1.8,abs(p.y));
    float disp2 = sin(p.y*4.)*cos(p.x*4.);
    //disp -= disp2*.6;
    d-=disp*.3;
    dp -= gDisp*.5;

    d = min(dp,d);
    
    
    cyld2-=disp3*.3;
    d = min(cyld2,d);
    return d;
}

// Function 1733
vec3 fresnelTermApprox(vec3 toEye, vec3 halfVec)
{
    vec3 minVal = vec3(0.005);
    return minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);
}

// Function 1734
vec3 inv_Tonemap_ACES(vec3 x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
   return (-0.59 * x + 0.03 - sqrt(-1.0127 * x*x + 1.3702 * x + 0.0009)) / (2.0 * (2.43*x - 2.51));
}

// Function 1735
SceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )
{	
    SceneResult result;
    result.fDist = 0.0;
    result.vUVW = vec3(0.0);
    result.iObjectId = -1;
    
	float t = minDist;
	const int kRaymarchMaxIter = 128;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
        float epsilon = 0.0005 * t;
		result = Scene_GetDistance( vRayOrigin + vRayDir * t );
        if ( abs(result.fDist) < epsilon )
		{
			break;
		}
                        
        if ( t > maxDist )
        {
            result.iObjectId = -1;
	        t = maxDist;
            break;
        }       
        
        if ( result.fDist > 1.0 )
        {
            result.iObjectId = -1;            
        }    
        
        t += result.fDist;        
	}
    
    result.fDist = t;


    return result;
}

// Function 1736
float map(in vec3 pos, float time ){
    return GetRayMarchHit(pos, time).distance;
}

// Function 1737
vec3 calcSceneColorDerivative(in vec3 vCamPos, in vec3 vRayDir)
{
	float d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);
	if (vRayDir.y > 0.)
	{
		return skyColor(vRayDir);
	}
	else
	{
		vec3 vHitPos = vCamPos + vRayDir * d;
		float fD = derivative(vHitPos.xz);
		return clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - fD), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);
	}
}

// Function 1738
float SDF_Clocktown(vec3 point)
{
    float sdf = FarClip;
    
    vec3 rp = RotY(point, PI * 0.5);
    
    float groundSDF     = length(point - vec3(0.0, -19.15, 0.0)) - 17.0;
    float towerBaseSDF  = udRoundBox(rp - vec3(0.0, -1.9, 0.0), vec3(0.075, 0.5, 0.075), 0.01);
    float towerBallSDF  = length(point - vec3(0.0, -1.31, 0.0)) - 0.095;
    float towerClockSDF = length(point - vec3(0.0, -1.525, 0.0)) - 0.125;
    float towerSDF      = min(towerBaseSDF, min(towerClockSDF, towerBallSDF));
    float wallsSDF      = udRoundBox(rp - vec3(0.0, -2.2, 0.0), vec3(0.1, 0.5, 0.85), 0.005);
    
    sdf = min(wallsSDF, min(towerSDF, groundSDF));
    
    return sdf;
}

// Function 1739
vec3 map( in vec3 pos )
{
	vec2  p = fract( pos.xz ); 
    vec3  m = mapH( pos.xz );
	float d = dbox( vec3(p.x-0.5,pos.y-0.5*m.x,p.y-0.5), vec3(0.3,m.x*0.5,0.3), 0.1 );
    return vec3( d, m.yz );
}

// Function 1740
float sdfTorus(in vec3 p, in vec2 torusDimensions)
{
    vec2 q = vec2(length(p.xz) - torusDimensions.x, p.y);
    return length(q) - torusDimensions.y;
}

// Function 1741
float scene(vec3 p) {
  float scale=1.3;
  id = floor(p.xy/scale);
  p.xy = (fract(p.xy/scale)-0.5)*scale;
  erot(p,vec3(0,0,1),acos(-1.)*0.25);
  return (length(vec3(length(p.xy)-2.41, length(p.yz), length(p.zx))+0.8)-2.)/sqrt(2.);
}

// Function 1742
vec3 aces_tonemap(vec3 color){	
	mat3 m1 = mat3(
        0.59719, 0.07600, 0.02840,
        0.35458, 0.90834, 0.13383,
        0.04823, 0.01566, 0.83777
	);
	mat3 m2 = mat3(
        1.60475, -0.10208, -0.00327,
        -0.53108,  1.10813, -0.07276,
        -0.07367, -0.00605,  1.07602
	);
	vec3 v = m1 * color;    
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));	
}

// Function 1743
float UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab
    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)
    //The clamp provides the line seg limits. e is therefore the "capped orthogogal projection", and length(p-e) is dist.
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 1744
float map( vec3 p ) {
    float zorig = p.z;
    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);
    
    float x = p.x*2., y = p.y-0.8, z = p.z;
    float d =  -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) );

	d = opS( d, sdBox( p, vec3( 2.5, 2., 5.75 ) )  ); 
    d = opU( d, sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ) );
    d = opU( d, sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ) ); 
    d = opU( d, sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ) );
    
    d = opU( d, 2.2-p.y );
    float l = distance( p.xz, dropPosition );
	p.y += 0.003*sin(40.*l-6.*time)*exp(-4.*l);
    
    d = opU( d, p.y+2.03 );  
    d = opU( d,  sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2) );
    
    if( getSectorId(zorig).y > 0.75 ) {
        d = opS( d,  sdCylinder( vec3(p.x, p.y-9., p.z), vec2(1.5,10.) ) );

        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);
        d = opU( d, sdBox( pr, vec3(3.0,0.1,0.1) ) );
        d = opU( d, sdBox( pr, vec3(0.1,0.1,3.0) ) );
    } 
#ifdef SPHERE
    d = opU( d,  sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2) );
#endif    
	return d;
}

// Function 1745
float sdfUnion(float d0, float d1)
{
    return min(d0, d1);
}

// Function 1746
vec3 jodieReinhardTonemap(vec3 c){
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

// Function 1747
float waterHeightMap( vec2 pos ) {
	vec2 posm = 0.02*pos * m2;
	posm.x += 0.001*time;
	float f = fbm( vec3( posm*1.9, time*0.01 ));
	float height = 0.5+0.1*f;
	height += 0.05*sin( posm.x*6.0 + 10.0*f );
	
	return  height;
}

// Function 1748
vec3 Uncharted2ToneMapping(vec3 color)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 0.012;
	color *= exposure;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 1749
float MapRearWing(vec3 p)
{
  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5, 0.017, 1.3)); 
  if (wing2<0.15) //Bounding Box test
  {
    // cutouts
    checkPos = p-vec3(3.0, 0.0, -5.9);
    pR(checkPos.xz, -0.5);
    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); 

    checkPos = p-vec3(0.0, 0.0, -4.9);
    pR(checkPos.xz, -0.5);
    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);

    checkPos = p-vec3(3.0, 0.0, -11.70);
    pR(checkPos.xz, -0.05);
    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); 

    checkPos = p-vec3(4.30, 0.0, -11.80);
    pR(checkPos.xz, 1.15);
    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);
  }
  return wing2;
}

// Function 1750
vec3 colormapTerrainGrass(float h) {
    return mix(vec3(0.3, 0.2, 0.1), vec3(0.3, 0.6, 0.2), h);
}

// Function 1751
vec2 map( in vec3 pos )
{
    const float ra = 0.9;
    const float rb = 0.25;

    // compute closest point to gPoint on the surace of the capsule
    vec3 closestPoint = closestPointToTorus(gPoint, ra, rb );
    
    // point
    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );
    
    // closest point
    {
    float d = sdSphere( pos, closestPoint, 0.06 );
    if( d<res.x ) res = vec2( d, 4.0 );
    }
    
    // torus    
    {
    float d = sdTorus( pos, ra, rb );
    if( d<res.x ) res =  vec2( d, 5.0 );
    }

    // segment
    {
    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );
    if( d<res.x ) res =  vec2( d, 4.0 );
    }
    
    return res;
}

// Function 1752
float sdf_cbox(in vec3 p, in float l)
{
    float fmax = 10000000.0;
    float b0 = sdf_sbox(p, vec3(fmax, l, l));
    float b1 = sdf_sbox(p, vec3(l, fmax, l));
    float b2 = sdf_sbox(p, vec3(l, l, fmax));
    return min(b0, min(b1, b2));
}

// Function 1753
float sphere_dist(vec3 q) {
	vec3 qp;
	q.x += 0.5 * cos(q.z * 0.1) + 0.5 * sin(q.x * 0.1) + 0.3 * sin(q.y + q.x);
    q.y += 0.5 * sin(q.z) + 0.5 * cos(q.x);
    q.z += 0.5 * sin(q.y * 0.1) + 0.5 * cos(q.x * 0.1) + 0.3 * cos(q.y + q.x);
	qp.x = negmod(q.x, 2.0);
	qp.y = negmod(q.y, 2.0);
	qp.z = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;
	return length(qp) - 1.0
		+  0.1 * sin(q.x * 5.0 + 2.0 * q.z + 3.0 * q.y + time)
		+ 0.1 * cos(q.x * 2.3 + 4.1 * q.z + 1.8 * q.y + time*1.7)
		 + max(0.1 * (q.y + 5.0 * sin(q.z + q.x) + 1.0), 0.0);
}

// Function 1754
float mapWater( vec3 p ) {
  return p.z + 0.04 * cyclicNoise( p, vec3( 1 ), 2.0 );
}

// Function 1755
float map(vec3 p){
    
    float PosX, PosY;
    PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);
    PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;
    
    p.z+=1.;
    float cs = cos(PosX), si = sin(PosX);
    //p.xy = mat2(cs, si, -si, cs)*p.xy;
    p.xz = mat2(cs, si, -si, cs)*p.xz;
    cs = cos(PosY), si = sin(PosY);
    p.yz = mat2(cs, si, -si, cs)*p.yz;
    
    
	p*=0.6;
    
    p.y-=0.2;
    

    
    vec3 sp = p;
    float k = length(sp*vec3(1., 0.95, 0.9)) - 0.5;
    float alle = k;
    
    //schadel unten schneiden
    sp = p;
    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;
    alle = smax(alle, -k, 0.09);
    
    
    //schadel seite
    sp = p;
    sp.x = abs(sp.x) - 0.65;
    k = length(sp - vec3(0., -0.05, -0.28)) - 0.3;
    alle = smax(alle, -k, 0.09);

    
    
    
    //oben augen knochen
    sp = p;
    k = knochen(p, vec3(0., 
                        0. + cos(abs(sp.x)*8. + 5.)*0.05 - 0.04 , 
                        -0.48 - cos(abs(sp.x)*8. + 5.8)*0.05), 
                vec3(0.12, 0.005, 0.005), 
                0., 0., 0., 0.14, 0.04);
    alle = smin(alle, k, 0.09);

    
    //oberest knochen
    sp = p;
    k = knochen(p, vec3(0., 0.15, -0.22), vec3(0.005, 0.005, 0.25), 
                -0.5, 0., 0., 0.28, 0.03);
    alle = smin(alle, k, 0.09);
    
    //augen seit knochen
    sp = p;
    k = knochen(p, vec3(0., -0.15 , -0.48), vec3(0.005, 0.08, 0.02), 
                0.0, 0.0, 0.1, 0.3, 0.01);
    alle = smin(alle, k, 0.07);
    
    //wangen knochen vor
    sp = p;
    k = knochen(p, vec3(0., -0.3, -0.45), vec3(0.13, 0.06, 0.05), 
                -0.3, -0.1, -0.2, 0.15, 0.03);
    alle = smin(alle, k, 0.1);
    
    //wangen knochen seit
    sp = p;
    k = knochen(p, vec3(0., -0.33, -0.32), 
                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), 
                0., 0.1, 0., 0.32 + cos(sp.z*8. + 2.)*0.09, 
                0.03 + cos(sp.z*8. + 4.7)*0.015);
    alle = smin(alle, k, 0.05);
    
    float zahnNum = 12.;
    //cyl oben
    sp = p - vec3(0., -0.43, -0.4);
    k = sdCappedCylinder(sp, 0.17
                         + cos(sp.y*12. -5.3)*0.05
                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01
                         , 0.06 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02);
    alle = smin(alle, k, 0.08);
    
    //oben zhan
    sp = p - vec3(0.0, -0.51, -0.41);
    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!
	sp.xz*=mat2(cs, si, -si, cs);
    k = sdCircleCircle(sp*5.4, 24, 1.);
    float zahn = k;
    
    
    

    //augen loche
    sp = p;
    sp.x = abs(sp.x) - 0.16;
    float loche = length(sp - vec3(0., -0.14, -0.4)) - 0.16;
    alle = smax(alle, -loche, 0.07);
    
    //gluende augen
    //sp = p;
    //sp.x = abs(sp.x) - 0.16;
    //float augen = length(sp - vec3(0., -0.22, -.65)) - 0.04;
    //alle = min(alle, augen);
    
    //nase
    sp = p;
    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), 
                -0.3, 0., 0.3, 0., 0.04);
    alle = smin(alle, k, 0.07);
    
    //nase scheiden
    sp = p;
    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), 
                -0.35, 0., 0.3, 0., 0.03);
    alle = smax(alle, -k, 0.04);
    
    //nase linie
    sp = p;
    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), 
                -0.35, 0., 0., 0., 0.005);
    alle = smin(alle, k, 0.03);
    
    //KEIFER / JAW
    
    PosY = 0.4;
    cs = cos(PosY), si = sin(PosY);
    p.yz = mat2(cs, si, -si, cs)*p.yz;
    p.y-=0.08;
    //wangen knochen zu keifer
    sp = p;
    k = knochen(p, vec3(0., -0.54, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), 
                vec3(0.001, 0.14, 0.1), 
                0.0, -0.45, -0.25, 0.32, 0.01);
    alle = smin(alle, k, 0.05);
    
    //keifer
    sp = p;
    k = knochen(p, vec3(0., -0.69, -0.34), vec3(0.012, 0.04, 0.22), 
                -0.3, -0.5, 0., 0.22, 0.03);
    alle = smin(alle, k, 0.09);
    
    //kinn
    sp = p;
    k = knochen(p, vec3(0., -0.74, -0.53), vec3(0.05, 0.04, 0.015), 
                0., 0., 0., 0., 0.03);
    alle = smin(alle, k, 0.09);
    
    
    //cyl unten
    sp = p - vec3(0., -0.68, -0.42);
    k = sdCappedCylinder(sp, 0.15
                         + cos(sp.y*12. - 1.5)*0.03
                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01
                         , 0.08 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);
    alle = smin(alle, k, 0.06);
    
  
    //unten zahn
    sp = p - vec3(0.0, -0.58, -0.4);
    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!
	sp.xz*=mat2(cs, si, -si, cs);
    
    k = sdCircleCircle(sp*5.6, 24, -1.);
    zahn = min(zahn, k);
    
    objID = vec4(zahn-0.05, alle, 0, 0);
    alle =  smin(zahn,alle, 0.09);
    
    float ball_of_subtraction = length(p-vec3(0., -0.32, -0.2))-0.34;
    alle = max(alle, -ball_of_subtraction);
    
    //if(min(augen, alle) == augen){
    alle = min(alle, snake(p));
    alle += fpn(p*100.+iTime*10.) * (0.03+0.03*sin(iTime));
    
    glow += abs(max(0.0001,(0.0001/(0.0075*pow((alle),.7 - 0.2*sin(iTime))))));//* (.5-augen*1.5);
    //}
    return alle;
}

// Function 1756
vec4 MipMap(vec3 pos) {
    return (texture(iChannel0,PosToVt(pos))
    +texture(iChannel0,PosToVt(pos+vec3(0.,0.,IRES)))
    +texture(iChannel0,PosToVt(pos+vec3(0.,IRES,0.)))
    +texture(iChannel0,PosToVt(pos+vec3(0.,IRES,IRES)))
    +texture(iChannel0,PosToVt(pos+vec3(IRES,0.,0.)))
    +texture(iChannel0,PosToVt(pos+vec3(IRES,0.,IRES)))
    +texture(iChannel0,PosToVt(pos+vec3(IRES,IRES,0.)))
    +texture(iChannel0,PosToVt(pos+vec3(IRES,IRES,IRES))))*0.125;
}

// Function 1757
float dist(vec2 z) {
    vec2 r = vec2(z.x-0.5, min(z.y,1.0-z.y));
    return sqrt(dot(r,r));
}

// Function 1758
void homerTorsoSDF(vec3 p, float swingTime, inout vec2 head) {
    float bounce = (clamp(swingTime,0.0,-1.0) * 0.75);
    vec3 collarPoint = translate(p, vec3(0,-8,1.75));
    
    vec2 collar = vec2(onion(sdCappedCone(collarPoint, 3.0, 5.5, 3.5), 0.03), WHITEASMYSOUL);
    vec2 collarTopSlice = vec2(sdPlane(translate(collarPoint, vec3(0,-0.5,0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);
    vec2 collarBottomSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);
    
    diff(collar, collarTopSlice);
    diff(collar, collarBottomSlice);
    
    vec2 collarInside = vec2(onion(sdCappedCone(collarPoint, 3.0, 3.5, 4.25), 0.03), WHITEASMYSOUL);
    vec2 collarInsideTopSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);
    vec2 collarInsideBottomSlice = vec2(sdPlane(translate(collarPoint, vec3(0,0,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);
    
    diff(collarInside, collarInsideTopSlice);
    diff(collarInside, collarInsideBottomSlice);
    
    vec2 frontPiece = vec2(sdCappedCone(translate(collarPoint, vec3(0,0,-5)), 3.0, 3.0, 2.0), WHITEASMYSOUL);
    
    vec2 frontPieceInside = vec2(sdCappedCone(translate(collarPoint, vec3(0,2,-4)), 3.0, 0.0, 5.0), WHITEASMYSOUL);
    
    diff(collar, frontPiece);
    add(head, collar);
    
    diff(collarInside, frontPieceInside);
    
    vec2 bodyTop = vec2(sdCappedCone(translate(p, vec3(0,-12,2)), 2.6, 6.0, 4.), WHITEASMYSOUL);
    
    collarInside = vec2(opSmoothUnion(collarInside.x, bodyTop.x, 1.0), WHITEASMYSOUL);
    
    vec3 tummyPoint = translate(p, vec3(0,-22,2));
    vec2 tummy = vec2(sdRoundCone(tummyPoint, 10.0-bounce, 3.0, 8.0), WHITEASMYSOUL);
    collarInside = vec2(opSmoothUnion(collarInside.x, tummy.x, 1.0), WHITEASMYSOUL);
    
    vec2 tummySlice = vec2(sdPlane(translate(collarPoint, vec3(0.0,-13.0+bounce,0.0)), normalize(vec4(0,1,0,1))), WHITEASMYSOUL);
    diff(collarInside, tummySlice);
    
    add(head, collarInside);
}

// Function 1759
float SmoothMinSDF( float a, float b, float smoothFactor )
{
    float h = max( smoothFactor-abs(a-b), 0.0 )/smoothFactor;
    return min( a, b ) - h*h*h*smoothFactor*(1.0/6.0);
}

// Function 1760
void hitScene()
{
startObj();
plane(float(0),float(1),float(0),float(-7));
plane(float(1),float(0),float(0),float(-180));
plane(float(0),float(0),float(-1),float(-180));
plane(float(-1),float(0),float(0),float(-180));
plane(float(0),float(-1),float(0),float(1));
plane(float(0),float(0),float(1),float(-180));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(-31));
plane(float(0),float(-0.624695),float(-0.780869),float(-27.3304));
plane(float(-1),float(0),float(0),float(-31));
plane(float(0),float(-1),float(0),float(-5));
plane(float(0),float(-0.624695),float(0.780869),float(-27.3304));
endObj();

#ifndef SIMPLESCENE
    
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(-53));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(37));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(-35));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(19));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(-17));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(1));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(1));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(-17));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(19));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(-35));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(1),float(0),float(0),float(37));
plane(float(0),float(0),float(-1),float(-54.5));
plane(float(-1),float(0),float(0),float(-53));
plane(float(0),float(-1),float(0),float(-7));
plane(float(0),float(0),float(1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(-53));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(37));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(-35));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(19));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(-17));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(0.999998));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(0.999998));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(-17));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(19));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(-35));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-4.37114e-008),float(0),float(1),float(37));
plane(float(1),float(0),float(4.37114e-008),float(-54.5));
plane(float(4.37114e-008),float(0),float(-1),float(-53));
plane(float(-0),float(-1),float(0),float(-7));
plane(float(-1),float(0),float(-4.37114e-008),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(-53));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(37));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(-35));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(19));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(-17));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(1));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(1));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(-17));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(19));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(-35));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-1));
plane(float(-1),float(0),float(-8.74228e-008),float(37));
plane(float(-8.74228e-008),float(0),float(1),float(-54.5));
plane(float(1),float(0),float(8.74228e-008),float(-53));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(8.74228e-008),float(0),float(-1),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(-53));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(37));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(-35));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(19));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(-17));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(1));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(1));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(-17));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(19));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(-35));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(1),float(0),float(-0.999998));
plane(float(-4.64912e-007),float(0),float(-1),float(37));
plane(float(-1),float(0),float(4.64912e-007),float(-54.5));
plane(float(4.64912e-007),float(0),float(1),float(-53));
plane(float(0),float(-1),float(-0),float(-7));
plane(float(1),float(0),float(-4.64912e-007),float(53.5));
endObj();
startObj();
plane(float(0),float(0.707107),float(-0.707107),float(-15.7564));
plane(float(1),float(0),float(0),float(-2.6));
plane(float(0),float(-0.707107),float(-0.707107),float(-23.0774));
plane(float(-1),float(0),float(0),float(-2.6));
plane(float(0),float(-0.707107),float(0.707107),float(15.3564));
plane(float(0),float(0.707107),float(0.707107),float(22.1774));
endObj();
startObj();
plane(float(0.14234),float(0.707107),float(-0.692632),float(-15.7563));
plane(float(0.97953),float(0),float(0.201299),float(-2.6));
plane(float(0.14234),float(-0.707107),float(-0.692632),float(-23.0774));
plane(float(-0.97953),float(0),float(-0.201299),float(-2.6));
plane(float(-0.14234),float(-0.707107),float(0.692632),float(15.3564));
plane(float(-0.14234),float(0.707107),float(0.692632),float(22.1774));
endObj();
startObj();
plane(float(0.278852),float(0.707107),float(-0.649801),float(-15.7564));
plane(float(0.918958),float(0),float(0.394356),float(-2.6));
plane(float(0.278852),float(-0.707107),float(-0.649801),float(-23.0774));
plane(float(-0.918958),float(0),float(-0.394356),float(-2.6));
plane(float(-0.278852),float(-0.707107),float(0.649801),float(15.3564));
plane(float(-0.278852),float(0.707107),float(0.649801),float(22.1774));
endObj();
startObj();
plane(float(0.403948),float(0.707107),float(-0.580367),float(-15.7563));
plane(float(0.820764),float(0),float(0.571268),float(-2.6));
plane(float(0.403948),float(-0.707107),float(-0.580367),float(-23.0774));
plane(float(-0.820764),float(0),float(-0.571268),float(-2.6));
plane(float(-0.403948),float(-0.707107),float(0.580367),float(15.3563));
plane(float(-0.403948),float(0.707107),float(0.580367),float(22.1774));
endObj();
startObj();
plane(float(0.512506),float(0.707107),float(-0.487173),float(-15.7564));
plane(float(0.688967),float(0),float(0.724793),float(-2.6));
plane(float(0.512506),float(-0.707107),float(-0.487173),float(-23.0774));
plane(float(-0.688967),float(0),float(-0.724793),float(-2.6));
plane(float(-0.512506),float(-0.707107),float(0.487173),float(15.3564));
plane(float(-0.512506),float(0.707107),float(0.487173),float(22.1774));
endObj();
startObj();
plane(float(0.600082),float(0.707107),float(-0.374034),float(-15.7564));
plane(float(0.528964),float(0),float(0.848644),float(-2.6));
plane(float(0.600082),float(-0.707107),float(-0.374034),float(-23.0774));
plane(float(-0.528964),float(0),float(-0.848644),float(-2.6));
plane(float(-0.600082),float(-0.707107),float(0.374034),float(15.3564));
plane(float(-0.600082),float(0.707107),float(0.374034),float(22.1774));
endObj();
startObj();
plane(float(0.663091),float(0.707107),float(-0.245582),float(-15.7564));
plane(float(0.347305),float(0),float(0.937752),float(-2.6));
plane(float(0.663091),float(-0.707107),float(-0.245582),float(-23.0774));
plane(float(-0.347305),float(0),float(-0.937752),float(-2.6));
plane(float(-0.663091),float(-0.707107),float(0.245582),float(15.3564));
plane(float(-0.663091),float(0.707107),float(0.245582),float(22.1774));
endObj();
startObj();
plane(float(0.698953),float(0.707107),float(-0.107076),float(-15.7564));
plane(float(0.151428),float(0),float(0.988468),float(-2.6));
plane(float(0.698953),float(-0.707107),float(-0.107076),float(-23.0774));
plane(float(-0.151428),float(0),float(-0.988468),float(-2.6));
plane(float(-0.698953),float(-0.707107),float(0.107076),float(15.3564));
plane(float(-0.698953),float(0.707107),float(0.107076),float(22.1774));
endObj();
startObj();
plane(float(0.706199),float(0.707107),float(0.0358143),float(-15.7564));
plane(float(-0.0506491),float(0),float(0.998717),float(-2.6));
plane(float(0.706199),float(-0.707107),float(0.0358143),float(-23.0774));
plane(float(0.0506491),float(0),float(-0.998717),float(-2.6));
plane(float(-0.706199),float(-0.707107),float(-0.0358143),float(15.3564));
plane(float(-0.706199),float(0.707107),float(-0.0358143),float(22.1774));
endObj();
startObj();
plane(float(0.684534),float(0.707107),float(0.177238),float(-15.7564));
plane(float(-0.250653),float(0),float(0.968077),float(-2.6));
plane(float(0.684534),float(-0.707107),float(0.177238),float(-23.0774));
plane(float(0.250653),float(0),float(-0.968077),float(-2.6));
plane(float(-0.684534),float(-0.707107),float(-0.177238),float(15.3564));
plane(float(-0.684534),float(0.707107),float(-0.177238),float(22.1774));
endObj();
startObj();
plane(float(0.634844),float(0.707107),float(0.311406),float(-15.7564));
plane(float(-0.440394),float(0),float(0.897805),float(-2.6));
plane(float(0.634844),float(-0.707107),float(0.311406),float(-23.0774));
plane(float(0.440394),float(0),float(-0.897805),float(-2.6));
plane(float(-0.634844),float(-0.707107),float(-0.311406),float(15.3564));
plane(float(-0.634844),float(0.707107),float(-0.311406),float(22.1774));
endObj();
startObj();
plane(float(0.559163),float(0.707107),float(0.432824),float(-15.7563));
plane(float(-0.612106),float(0),float(0.790776),float(-2.6));
plane(float(0.559163),float(-0.707107),float(0.432824),float(-23.0774));
plane(float(0.612106),float(0),float(-0.790776),float(-2.6));
plane(float(-0.559163),float(-0.707107),float(-0.432824),float(15.3563));
plane(float(-0.559163),float(0.707107),float(-0.432824),float(22.1774));
endObj();
startObj();
plane(float(0.46059),float(0.707107),float(0.536523),float(-15.7564));
plane(float(-0.758758),float(0),float(0.651373),float(-2.6));
plane(float(0.46059),float(-0.707107),float(0.536523),float(-23.0774));
plane(float(0.758758),float(0),float(-0.651373),float(-2.6));
plane(float(-0.46059),float(-0.707107),float(-0.536523),float(15.3564));
plane(float(-0.46059),float(0.707107),float(-0.536523),float(22.1774));
endObj();
startObj();
plane(float(0.34316),float(0.707107),float(0.618256),float(-15.7563));
plane(float(-0.874347),float(0),float(0.485302),float(-2.6));
plane(float(0.34316),float(-0.707107),float(0.618256),float(-23.0774));
plane(float(0.874347),float(0),float(-0.485302),float(-2.6));
plane(float(-0.34316),float(-0.707107),float(-0.618256),float(15.3563));
plane(float(-0.34316),float(0.707107),float(-0.618256),float(22.1774));
endObj();
startObj();
plane(float(0.211682),float(0.707107),float(0.674679),float(-15.7564));
plane(float(-0.954139),float(0),float(0.299363),float(-2.6));
plane(float(0.211681),float(-0.707107),float(0.674678),float(-23.0774));
plane(float(0.954139),float(0),float(-0.299363),float(-2.6));
plane(float(-0.211682),float(-0.707107),float(-0.674679),float(15.3564));
plane(float(-0.211681),float(0.707107),float(-0.674678),float(22.1774));
endObj();
startObj();
plane(float(0.0715369),float(0.707107),float(0.703479),float(-15.7563));
plane(float(-0.994869),float(0),float(0.101168),float(-2.6));
plane(float(0.0715369),float(-0.707107),float(0.703479),float(-23.0774));
plane(float(0.994869),float(0),float(-0.101168),float(-2.6));
plane(float(-0.0715369),float(-0.707107),float(-0.703479),float(15.3563));
plane(float(-0.0715369),float(0.707107),float(-0.703479),float(22.1774));
endObj();
startObj();
plane(float(-0.0715367),float(0.707107),float(0.703479),float(-15.7563));
plane(float(-0.994869),float(0),float(-0.101168),float(-2.6));
plane(float(-0.0715367),float(-0.707107),float(0.703479),float(-23.0774));
plane(float(0.994869),float(0),float(0.101168),float(-2.6));
plane(float(0.0715367),float(-0.707107),float(-0.703479),float(15.3563));
plane(float(0.0715367),float(0.707107),float(-0.703479),float(22.1774));
endObj();
startObj();
plane(float(-0.211682),float(0.707107),float(0.674678),float(-15.7564));
plane(float(-0.954139),float(0),float(-0.299363),float(-2.6));
plane(float(-0.211682),float(-0.707107),float(0.674678),float(-23.0774));
plane(float(0.954139),float(0),float(0.299363),float(-2.6));
plane(float(0.211682),float(-0.707107),float(-0.674678),float(15.3564));
plane(float(0.211682),float(0.707107),float(-0.674678),float(22.1774));
endObj();
startObj();
plane(float(-0.34316),float(0.707107),float(0.618257),float(-15.7564));
plane(float(-0.874347),float(0),float(-0.485302),float(-2.6));
plane(float(-0.34316),float(-0.707107),float(0.618256),float(-23.0774));
plane(float(0.874347),float(0),float(0.485302),float(-2.6));
plane(float(0.34316),float(-0.707107),float(-0.618257),float(15.3564));
plane(float(0.34316),float(0.707107),float(-0.618256),float(22.1774));
endObj();
startObj();
plane(float(-0.46059),float(0.707107),float(0.536523),float(-15.7564));
plane(float(-0.758758),float(0),float(-0.651372),float(-2.6));
plane(float(-0.46059),float(-0.707107),float(0.536523),float(-23.0774));
plane(float(0.758758),float(0),float(0.651372),float(-2.6));
plane(float(0.46059),float(-0.707107),float(-0.536523),float(15.3564));
plane(float(0.46059),float(0.707107),float(-0.536523),float(22.1774));
endObj();
startObj();
plane(float(-0.559163),float(0.707107),float(0.432824),float(-15.7563));
plane(float(-0.612106),float(0),float(-0.790776),float(-2.6));
plane(float(-0.559163),float(-0.707107),float(0.432824),float(-23.0774));
plane(float(0.612106),float(0),float(0.790776),float(-2.6));
plane(float(0.559163),float(-0.707107),float(-0.432824),float(15.3563));
plane(float(0.559163),float(0.707107),float(-0.432824),float(22.1774));
endObj();
startObj();
plane(float(-0.634844),float(0.707107),float(0.311406),float(-15.7564));
plane(float(-0.440394),float(0),float(-0.897804),float(-2.6));
plane(float(-0.634844),float(-0.707107),float(0.311406),float(-23.0774));
plane(float(0.440394),float(0),float(0.897804),float(-2.6));
plane(float(0.634844),float(-0.707107),float(-0.311406),float(15.3564));
plane(float(0.634844),float(0.707107),float(-0.311406),float(22.1774));
endObj();
startObj();
plane(float(-0.684534),float(0.707107),float(0.177238),float(-15.7564));
plane(float(-0.250653),float(0),float(-0.968077),float(-2.6));
plane(float(-0.684534),float(-0.707107),float(0.177238),float(-23.0774));
plane(float(0.250653),float(0),float(0.968077),float(-2.6));
plane(float(0.684534),float(-0.707107),float(-0.177238),float(15.3564));
plane(float(0.684534),float(0.707107),float(-0.177238),float(22.1774));
endObj();
startObj();
plane(float(-0.706199),float(0.707107),float(0.0358149),float(-15.7564));
plane(float(-0.0506499),float(0),float(-0.998717),float(-2.6));
plane(float(-0.706199),float(-0.707107),float(0.0358149),float(-23.0774));
plane(float(0.0506499),float(0),float(0.998717),float(-2.6));
plane(float(0.706199),float(-0.707107),float(-0.0358149),float(15.3564));
plane(float(0.706199),float(0.707107),float(-0.0358149),float(22.1774));
endObj();
startObj();
plane(float(-0.698953),float(0.707107),float(-0.107075),float(-15.7564));
plane(float(0.151428),float(0),float(-0.988468),float(-2.6));
plane(float(-0.698953),float(-0.707107),float(-0.107075),float(-23.0774));
plane(float(-0.151428),float(0),float(0.988468),float(-2.6));
plane(float(0.698953),float(-0.707107),float(0.107075),float(15.3564));
plane(float(0.698953),float(0.707107),float(0.107075),float(22.1774));
endObj();
startObj();
plane(float(-0.663091),float(0.707107),float(-0.245582),float(-15.7564));
plane(float(0.347305),float(0),float(-0.937752),float(-2.6));
plane(float(-0.663091),float(-0.707107),float(-0.245582),float(-23.0774));
plane(float(-0.347305),float(0),float(0.937752),float(-2.6));
plane(float(0.663091),float(-0.707107),float(0.245582),float(15.3564));
plane(float(0.663091),float(0.707107),float(0.245582),float(22.1774));
endObj();
startObj();
plane(float(-0.600082),float(0.707107),float(-0.374034),float(-15.7564));
plane(float(0.528964),float(0),float(-0.848644),float(-2.6));
plane(float(-0.600082),float(-0.707107),float(-0.374034),float(-23.0774));
plane(float(-0.528964),float(0),float(0.848644),float(-2.6));
plane(float(0.600082),float(-0.707107),float(0.374034),float(15.3564));
plane(float(0.600082),float(0.707107),float(0.374034),float(22.1774));
endObj();
startObj();
plane(float(-0.512506),float(0.707107),float(-0.487173),float(-15.7564));
plane(float(0.688967),float(0),float(-0.724793),float(-2.6));
plane(float(-0.512506),float(-0.707107),float(-0.487173),float(-23.0774));
plane(float(-0.688967),float(0),float(0.724793),float(-2.6));
plane(float(0.512506),float(-0.707107),float(0.487173),float(15.3564));
plane(float(0.512506),float(0.707107),float(0.487173),float(22.1774));
endObj();
startObj();
plane(float(-0.403947),float(0.707107),float(-0.580368),float(-15.7564));
plane(float(0.820764),float(0),float(-0.571268),float(-2.6));
plane(float(-0.403947),float(-0.707107),float(-0.580368),float(-23.0774));
plane(float(-0.820764),float(0),float(0.571268),float(-2.6));
plane(float(0.403947),float(-0.707107),float(0.580368),float(15.3564));
plane(float(0.403947),float(0.707107),float(0.580368),float(22.1774));
endObj();
startObj();
plane(float(-0.278852),float(0.707107),float(-0.649801),float(-15.7564));
plane(float(0.918958),float(0),float(-0.394356),float(-2.6));
plane(float(-0.278852),float(-0.707107),float(-0.649801),float(-23.0774));
plane(float(-0.918958),float(0),float(0.394356),float(-2.6));
plane(float(0.278852),float(-0.707107),float(0.649801),float(15.3564));
plane(float(0.278852),float(0.707107),float(0.649801),float(22.1774));
endObj();
startObj();
plane(float(-0.14234),float(0.707107),float(-0.692632),float(-15.7564));
plane(float(0.97953),float(0),float(-0.201299),float(-2.6));
plane(float(-0.14234),float(-0.707107),float(-0.692632),float(-23.0774));
plane(float(-0.97953),float(0),float(0.201299),float(-2.6));
plane(float(0.14234),float(-0.707107),float(0.692632),float(15.3564));
plane(float(0.14234),float(0.707107),float(0.692632),float(22.1774));
endObj();
    
    #endif
    
startObj();
plane(float(0.383867),float(0.920614),float(-0.0715337),float(13.6711));
plane(float(0.888832),float(-0.389385),float(-0.241572),float(-7.57762));
plane(float(-0.250248),float(0.0291498),float(-0.967743),float(3.81964));
plane(float(-0.888832),float(0.389385),float(0.241572),float(1.97762));
plane(float(-0.383867),float(-0.920614),float(0.0715337),float(-18.0711));
plane(float(0.250248),float(-0.0291498),float(0.967743),float(-7.81964));
endObj();
startObj();
plane(float(0.410012),float(0.900413),float(-0.14542),float(18.3884));
plane(float(0.838925),float(-0.434866),float(-0.327257),float(-7.87907));
plane(float(-0.357905),float(0.0121831),float(-0.933679),float(3.68534));
plane(float(-0.838925),float(0.434866),float(0.327257),float(2.47907));
plane(float(-0.410012),float(-0.900413),float(0.14542),float(-22.7884));
plane(float(0.357905),float(-0.0121831),float(0.933679),float(-6.68534));
endObj();
startObj();
plane(float(0.0244033),float(0.939602),float(-0.341399),float(24.3099));
plane(float(0.844816),float(-0.201969),float(-0.495474),float(0.19967));
plane(float(-0.534501),float(-0.276328),float(-0.798719),float(-4.15355));
plane(float(-0.844816),float(0.201969),float(0.495474),float(-2.59967));
plane(float(-0.0244033),float(-0.939602),float(0.341399),float(-27.3099));
plane(float(0.534501),float(0.276328),float(0.798719),float(1.75355));
endObj();
startObj();
plane(float(0.317596),float(0.945882),float(0.0666309),float(6.54595));
plane(float(0.676376),float(-0.176735),float(-0.715038),float(2.07443));
plane(float(-0.664566),float(0.272161),float(-0.695903),float(0.841951));
plane(float(-0.676376),float(0.176735),float(0.715038),float(-4.47443));
plane(float(-0.317596),float(-0.945882),float(-0.0666309),float(-7.94595));
plane(float(0.664566),float(-0.272161),float(0.695903),float(-4.84195));
endObj();
startObj();
plane(float(0.2856),float(0.864013),float(0.414626),float(5.54048));
plane(float(0.783863),float(0.0383015),float(-0.619751),float(3.89471));
plane(float(-0.551354),float(0.502011),float(-0.666329),float(4.75963));
plane(float(-0.783863),float(-0.0383015),float(0.619751),float(-5.89471));
plane(float(-0.2856),float(-0.864013),float(-0.414626),float(-10.1405));
plane(float(0.551354),float(-0.502011),float(0.666329),float(-6.75963));
endObj();
startObj();
plane(float(-0.571276),float(0.468744),float(-0.673739),float(4.78791));
plane(float(0.775637),float(0.0399012),float(-0.629917),float(3.75132));
plane(float(-0.268386),float(-0.882433),float(-0.38637),float(-11.7256));
plane(float(-0.775637),float(-0.0399012),float(0.629917),float(-6.15132));
plane(float(0.571276),float(-0.468744),float(0.673739),float(-10.7879));
plane(float(0.268386),float(0.882433),float(0.38637),float(9.32558));
endObj();
startObj();
plane(float(0.308545),float(0.928811),float(-0.205206),float(6.03705));
plane(float(0.918407),float(-0.347056),float(-0.18995),float(-7.52246));
plane(float(-0.247645),float(-0.129855),float(-0.960109),float(6.22725));
plane(float(-0.918407),float(0.347056),float(0.18995),float(5.12246));
plane(float(-0.308545),float(-0.928811),float(0.205206),float(-7.43705));
plane(float(0.247645),float(0.129855),float(0.960109),float(-10.2273));
endObj();
startObj();
plane(float(0.431007),float(0.77232),float(0.466642),float(-0.784515));
plane(float(0.899674),float(-0.40759),float(-0.156386),float(-8.04544));
plane(float(0.0694185),float(0.48723),float(-0.870511),float(10.6768));
plane(float(-0.899674),float(0.40759),float(0.156386),float(6.04544));
plane(float(-0.431007),float(-0.77232),float(-0.466642),float(-3.81548));
plane(float(-0.0694185),float(-0.48723),float(0.870511),float(-12.6768));
endObj();
startObj();
plane(float(0.430124),float(0.77742),float(0.458924),float(3.62615));
plane(float(0.900341),float(-0.406668),float(-0.154942),float(-8.18314));
plane(float(0.066175),float(0.479833),float(-0.874861),float(10.4767));
plane(float(-0.900341),float(0.406668),float(0.154942),float(5.78314));
plane(float(-0.430124),float(-0.77742),float(-0.458924),float(-9.62614));
plane(float(-0.066175),float(-0.479833),float(0.874861),float(-12.8767));
endObj();
startObj();
plane(float(0.976008),float(0.210468),float(0.0557845),float(9.03892));
plane(float(0.173523),float(-0.906622),float(0.384613),float(-21.4466));
plane(float(0.131524),float(-0.365706),float(-0.921391),float(-1.29409));
plane(float(-0.173523),float(0.906622),float(-0.384613),float(17.6466));
plane(float(-0.976008),float(-0.210468),float(-0.0557845),float(-10.6389));
plane(float(-0.131524),float(0.365706),float(0.921391),float(-0.905906));
endObj();
startObj();
plane(float(0.961897),float(0.266605),float(0.0606273),float(10.5645));
plane(float(0.213293),float(-0.870442),float(0.443663),float(-17.4709));
plane(float(0.171056),float(-0.413827),float(-0.89414),float(-1.59577));
plane(float(-0.213293),float(0.870442),float(-0.443663),float(13.6709));
plane(float(-0.961897),float(-0.266605),float(-0.0606273),float(-11.9645));
plane(float(-0.171056),float(0.413827),float(0.89414),float(-0.00423229));
endObj();
startObj();
plane(float(0.960554),float(0.270338),float(0.0652159),float(11.1644));
plane(float(0.214924),float(-0.870481),float(0.4428),float(-14.306));
plane(float(0.176475),float(-0.411317),float(-0.894246),float(-2.16547));
plane(float(-0.214924),float(0.870481),float(-0.4428),float(11.506));
plane(float(-0.960554),float(-0.270338),float(-0.0652159),float(-11.7644));
plane(float(-0.176475),float(0.411317),float(0.894246),float(-0.0345296));
endObj();
startObj();
plane(float(-0.624082),float(0.264051),float(-0.73539),float(9.30376));
plane(float(-0.276092),float(-0.954977),float(-0.108594),float(-25.9317));
plane(float(-0.730955),float(0.135264),float(0.668887),float(-1.63207));
plane(float(0.276092),float(0.954977),float(0.108594),float(22.1317));
plane(float(0.624082),float(-0.264051),float(0.73539),float(-10.9038));
plane(float(0.730955),float(-0.135264),float(-0.668887),float(-0.567926));
endObj();
startObj();
plane(float(-0.682675),float(0.247512),float(-0.687526),float(8.86892));
plane(float(-0.730557),float(-0.211166),float(0.649381),float(-13.1815));
plane(float(0.0155472),float(0.945593),float(0.32498),float(23.4904));
plane(float(0.730557),float(0.211166),float(-0.649381),float(9.38148));
plane(float(0.682675),float(-0.247512),float(0.687526),float(-10.2689));
plane(float(-0.0155472),float(-0.945593),float(-0.32498),float(-25.0904));
endObj();
startObj();
plane(float(-0.873077),float(0.112964),float(-0.474316),float(3.26787));
plane(float(-0.487496),float(-0.220571),float(0.844805),float(-16.0544));
plane(float(-0.00918784),float(0.968807),float(0.247645),float(24.6254));
plane(float(0.487496),float(0.220571),float(-0.844805),float(13.2544));
plane(float(0.873077),float(-0.112964),float(0.474316),float(-3.86787));
plane(float(0.00918784),float(-0.968807),float(-0.247645),float(-26.8254));
endObj();
startObj();
plane(float(-0.404842),float(0.606909),float(-0.683934),float(5.27828));
plane(float(-0.684773),float(-0.696909),float(-0.213084),float(-15.3175));
plane(float(-0.605962),float(0.382074),float(0.697732),float(8.24442));
plane(float(0.684773),float(0.696909),float(0.213084),float(9.71747));
plane(float(0.404842),float(-0.606909),float(0.683934),float(-9.67828));
plane(float(0.605962),float(-0.382074),float(-0.697732),float(-12.2444));
endObj();
startObj();
plane(float(-0.452925),float(0.488078),float(-0.746082),float(7.57183));
plane(float(-0.568503),float(-0.802743),float(-0.180023),float(-17.2584));
plane(float(-0.686777),float(0.342613),float(0.641056),float(8.03015));
plane(float(0.568503),float(0.802743),float(0.180023),float(11.8584));
plane(float(0.452925),float(-0.488078),float(0.746082),float(-11.9718));
plane(float(0.686777),float(-0.342613),float(-0.641056),float(-11.0301));
endObj();
startObj();
plane(float(-0.461995),float(0.359991),float(-0.810535),float(9.89887));
plane(float(-0.563642),float(-0.82479),float(-0.0450535),float(-16.3138));
plane(float(-0.68474),float(0.436037),float(0.583955),float(10.3887));
plane(float(0.563642),float(0.82479),float(0.0450535),float(13.9138));
plane(float(0.461995),float(-0.359991),float(0.810535),float(-12.8989));
plane(float(0.68474),float(-0.436037),float(-0.583955),float(-12.7887));
endObj();
startObj();
plane(float(-0.229404),float(0.943796),float(-0.237957),float(3.09395));
plane(float(-0.801951),float(-0.321821),float(-0.503295),float(-7.96747));
plane(float(-0.551588),float(0.0753718),float(0.830705),float(6.67326));
plane(float(0.801951),float(0.321821),float(0.503295),float(5.56747));
plane(float(0.229404),float(-0.943796),float(0.237957),float(-4.49395));
plane(float(0.551588),float(-0.0753718),float(-0.830705),float(-10.6733));
endObj();
startObj();
plane(float(0.027272),float(0.850179),float(-0.525786),float(0.363057));
plane(float(-0.829585),float(-0.274208),float(-0.486414),float(-7.19111));
plane(float(-0.557714),float(0.44945),float(0.697818),float(10.0393));
plane(float(0.829585),float(0.274208),float(0.486414),float(5.19111));
plane(float(-0.027272),float(-0.850179),float(0.525786),float(-4.96306));
plane(float(0.557714),float(-0.44945),float(-0.697818),float(-12.0393));
endObj();
startObj();
plane(float(0.0315713),float(0.850039),float(-0.525773),float(4.45892));
plane(float(-0.827359),float(-0.272915),float(-0.490913),float(-7.29927));
plane(float(-0.560786),float(0.450501),float(0.694671),float(9.93876));
plane(float(0.827359),float(0.272915),float(0.490913),float(4.89927));
plane(float(-0.0315713),float(-0.850039),float(0.525773),float(-10.4589));
plane(float(0.560786),float(-0.450501),float(-0.694671),float(-12.3388));
endObj();
startObj();
plane(float(-0.238607),float(0.948859),float(-0.206721),float(5.0063));
plane(float(-0.925974),float(-0.286449),float(-0.246008),float(-9.61538));
plane(float(-0.292642),float(0.132719),float(0.946967),float(5.18016));
plane(float(0.925974),float(0.286449),float(0.246008),float(7.21538));
plane(float(0.238607),float(-0.948859),float(0.206721),float(-6.4063));
plane(float(0.292642),float(-0.132719),float(-0.946967),float(-9.18016));
endObj();
startObj();
plane(float(-0.0642616),float(0.693782),float(-0.717312),float(0.19417));
plane(float(-0.916354),float(-0.325665),float(-0.232889),float(-9.60213));
plane(float(-0.395177),float(0.642347),float(0.656678),float(9.36128));
plane(float(0.916354),float(0.325665),float(0.232889),float(7.60213));
plane(float(0.0642616),float(-0.693782),float(0.717312),float(-4.79417));
plane(float(0.395177),float(-0.642347),float(-0.656678),float(-11.3613));
endObj();
startObj();
plane(float(-0.389552),float(0.86323),float(0.321068),float(11.009));
plane(float(-0.916381),float(-0.328395),float(-0.228916),float(-9.34267));
plane(float(-0.0921705),float(-0.383395),float(0.918974),float(-1.85287));
plane(float(0.916381),float(0.328395),float(0.228916),float(6.94267));
plane(float(0.389552),float(-0.86323),float(-0.321068),float(-17.009));
plane(float(0.0921705),float(0.383395),float(-0.918974),float(-0.547131));
endObj();
startObj();
plane(float(-0.645844),float(-0.299967),float(-0.702072),float(-2.19144));
plane(float(0.0185584),float(-0.925478),float(0.378348),float(-17.4355));
plane(float(-0.763244),float(0.231324),float(0.603281),float(6.82795));
plane(float(-0.0185584),float(0.925478),float(-0.378348),float(13.6355));
plane(float(0.645844),float(0.299967),float(0.702072),float(0.591437));
plane(float(0.763244),float(-0.231324),float(-0.603281),float(-9.02795));
endObj();
startObj();
plane(float(-0.645418),float(-0.301008),float(-0.702018),float(-1.66032));
plane(float(0.710315),float(-0.574482),float(-0.406722),float(-13.3649));
plane(float(-0.28087),float(-0.76116),float(0.584592),float(-10.4127));
plane(float(-0.710315),float(0.574482),float(0.406722),float(9.56492));
plane(float(0.645418),float(0.301008),float(0.702018),float(0.260324));
plane(float(0.28087),float(0.76116),float(-0.584592),float(8.81268));
endObj();
startObj();
plane(float(-0.645393),float(-0.300652),float(-0.702194),float(-1.09708));
plane(float(0.710365),float(-0.574181),float(-0.40706),float(-10.2036));
plane(float(-0.280803),float(-0.761527),float(0.584145),float(-10.7954));
plane(float(-0.710365),float(0.574181),float(0.40706),float(7.40363));
plane(float(0.645393),float(0.300652),float(0.702194),float(0.497081));
plane(float(0.280803),float(0.761527),float(-0.584145),float(8.59543));
endObj();
startObj();
plane(float(-0.292915),float(0.856285),float(-0.425414),float(19.431));
plane(float(-0.0743665),float(-0.463985),float(-0.882716),float(-14.5232));
plane(float(-0.953242),float(-0.226924),float(0.199587),float(-4.58119));
plane(float(0.0743665),float(0.463985),float(0.882716),float(10.7232));
plane(float(0.292915),float(-0.856285),float(0.425414),float(-21.031));
plane(float(0.953242),float(0.226924),float(-0.199587),float(2.38119));
endObj();
startObj();
plane(float(-0.291207),float(0.849913),float(-0.439144),float(19.5069));
plane(float(-0.131189),float(-0.49018),float(-0.861692),float(-18.375));
plane(float(-0.947622),float(-0.193319),float(0.254243),float(-2.90308));
plane(float(0.131189),float(0.49018),float(0.861692),float(14.575));
plane(float(0.291207),float(-0.849913),float(0.439144),float(-20.9069));
plane(float(0.947622),float(0.193319),float(-0.254243),float(1.30308));
endObj();
startObj();
plane(float(-0.291411),float(0.84869),float(-0.441367),float(19.8991));
plane(float(-0.131462),float(-0.492544),float(-0.860301),float(-20.5335));
plane(float(-0.947522),float(-0.192678),float(0.255103),float(-3.27395));
plane(float(0.131462),float(0.492544),float(0.860301),float(17.7335));
plane(float(0.291411),float(-0.84869),float(0.441367),float(-20.4991));
plane(float(0.947522),float(0.192678),float(-0.255103),float(1.07395));
endObj();
    
}

// Function 1761
float sdfLens(vec2 p, float width, float height)
{
    float d = 1.0 / width - width / 4.0;
    float r = width / 2.0 + d;
    
    p = abs(p);

    float b = sqrt(r * r - d * d);
    vec4 par = p.xyxy - vec4(0.0, b, -d, 0.0);
    return (par.y * d > p.x * b) ? length(par.xy) : length(par.zw) - r;
}

// Function 1762
float sdScene(vec3 p) {
    return sdFoot(p);
}

// Function 1763
float sphereSDF(vec3 p, Sphere s) {
    return length(p - s.c) - s.r;
}

// Function 1764
RMResult map(vec3 p, float time)
{
    float d = FAR;
    float id = -1.;
            
    {// board
        float d0 = sdBoard(p);
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// chess pieces
        // turns
        time = mod(time, 10. * TURN_DURATION);    
        float move1w, move1b, move2w, move2b, move3w, move3b, move4w, checkmate, backToStart;
        backToStart = clamp(time - 9. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION;
        move1w =    clamp(time - 0. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move1b =    clamp(time - 1. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move2w =    clamp(time - 2. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move2b =    clamp(time - 3. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move3w =    clamp(time - 4. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move3b =    clamp(time - 5. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        move4w =    clamp(time - 6. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        checkmate = clamp(time - 7. * TURN_DURATION, 0., MOVE_DURATION) / MOVE_DURATION - backToStart;
        
        // static pieces
        vec3 p0 = vec3(-abs(p.x), p.y, -abs(p.z));
        float d0 = sdRook(p0 + vec3(3.5, 0., 3.5) * BOARD_UNIT);
        d0 = min(d0, sdKnight(vec3(-abs(p.x), p.yz) + vec3(2.5, 0., 3.5) * BOARD_UNIT));
        d0 = min(d0, sdBishop(vec3(-p.x, p.y, -abs(p.z)) + vec3(1.5, 0., 3.5) * BOARD_UNIT));
        vec3 p1 = vec3(p.xy, -abs(p.z));
        float sdVanish = sdBox(vec3(0.5 * BOARD_UNIT, 2.2, 0.5 * BOARD_UNIT),
                              p - vec3(-0.5 * BOARD_UNIT, 1., 3.5 * BOARD_UNIT));
        sdVanish = max(sdVanish, - (noise(p) - 0.5 + checkmate));
        float sdKing = sdKing(p1 + vec3(0.5, 0., 3.5) * BOARD_UNIT);
        sdKing = max(sdKing, -sdVanish);
        d0 = min(d0, sdKing);
        // static pawns
        float c = BOARD_UNIT;
        float l = 3.;
        vec3 p2 = vec3(-p.x, p.y, -abs(p.z)) + vec3(-0.5, 0., 2.5) * BOARD_UNIT;
        p2.x = p2.x - c * clamp(round(p2.x / c), -l-1., l) - (c + p2.x) * 0.5 * (sign(p2.x + 0.5 * c) + sign(0.5 * c - p2.x));
        sdVanish = sdBox(vec3(0.5 * BOARD_UNIT, 2.2, 0.5 * BOARD_UNIT),
                         p - vec3(-1.5 * BOARD_UNIT, 1., 2.5 * BOARD_UNIT));
        sdVanish = max(sdVanish, - (noise(p) - 0.5 + move4w));
        float sdStaticPawns = max(sdPawn(p2), - sdVanish);
        d0 = min(d0, sdStaticPawns);

        // moving pawns
        vec3 origPawn = vec3(0.5, 0., 2.5) * BOARD_UNIT;
        vec3 destPawn = vec3(0.5, 0., 0.5) * BOARD_UNIT;
        vec3 p3 = vec3(-p.x,
                       p.y,
                       abs(p.z
                           - 0.5 * mix(0., origPawn.z - destPawn.z, move1w)
                           + 0.5 * mix(0., origPawn.z - destPawn.z, move1b)));
        p3.xy -= mix(origPawn, destPawn, move1w).xy;
        p3.z -= origPawn.z + 0.5 * mix(0., destPawn.z - origPawn.z, move1w);
        p3.z -= 0.5 * mix(0., destPawn.z - origPawn.z, move1b);
        d0 = min(d0, sdPawn(p3));
        // moving queen
        vec3 origQueen  = vec3(-0.5, 0.,  3.5) * BOARD_UNIT;
        vec3 destQueen  = vec3(3.5 , 0., -0.5) * BOARD_UNIT;
        vec3 origQueen2 = destQueen;
        vec3 destQueen2 = vec3(1.5 , 0., -2.5) * BOARD_UNIT;
        vec3 moveQueen = mix(vec3(0.), origQueen  - destQueen , move2w)
                       + mix(vec3(0.), origQueen2 - destQueen2, move4w);
        float z4sym = p.z - 0.5 * moveQueen.z;
        vec3 p4 = vec3(p.xy, -abs(z4sym));
        p4 += vec3(-0.5, 0., 3.5) * BOARD_UNIT;
        p4 -= 0.5 * vec3(moveQueen.x * (1. - sign(z4sym)), 0., moveQueen.z);
        float dQueen = sdQueen(p4);
        // moving knights
        vec3 origKnight = vec3(-2.5, 0., -3.5) * BOARD_UNIT;
        vec3 destKnight = vec3(-1.5, 0., -1.5) * BOARD_UNIT;
        vec3 p5 = vec3(-abs(p.x), p.y, -p.z);
        vec3 knightMove = vec3(mix(0., destKnight.x - origKnight.x, move2b),
                               8. * move2b * (1. - move2b),
                               mix(0., destKnight.z - origKnight.z, move2b))
                          * 0.5 * (1. + sign(p.x));
        knightMove += vec3(mix(0., destKnight.x - origKnight.x, move3b),
                           8. * move3b * (1. - move3b),
                           mix(0., destKnight.z - origKnight.z, move3b))
                      * 0.5 * (1. - sign(p.x));
        p5 -= origKnight + knightMove;
        mat3 rotMove = rot(vec2(0., PI * (move2b * (1. + sign(p.x))
                                        + move3b * (1. - sign(p.x)))));
        p5 = rotMove * p5;
        float dKnight = sdKnight(p5);
        d0 = min(d0, dKnight);
        // moving bishop
        vec3 origBishop = vec3(1.5, 0., -3.5) * BOARD_UNIT;
        vec3 destBishop = vec3(-1.5, 0., -.5) * BOARD_UNIT;
        vec3 p6 = vec3(-p.x, p.y, -abs(p.z));
        vec3 bishopMove = mix(vec3(0.), destBishop - origBishop, move3w);
        p6 -= origBishop + 0.5 * bishopMove * (1. - sign(p.z));
        d0 = min(d0, sdBishop(p6));
                
        if (d0 < d || dQueen < d)
        {
            if (d0 < dQueen){
                d = d0;
                if (p.z < 0.)
                {
                    // white pieces id
                    id = 1.5;
                }
                else
                {
                    // black pieces id
                    id = 2.5;
                }
            }
            else 
            {
                d = dQueen;
                
                if (p.z < 3. * BOARD_UNIT)
                {
                    // white pieces id
                    id = 1.5;
                }
                else
                {
                    // black pieces id
                    id = 2.5;
                }
            }
        }
    }
    return RMResult(d, id);
}

// Function 1765
vec3 draw_distance(float d, vec2 p) {
  float t = clamp(d * 0.85, 0.0, 1.0);
  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);

  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);
  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);
  float d2 = abs(1.0 - draw_line(d).x);
  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));

  grad -= rim;
  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));

  return grad;
}

// Function 1766
vec3 envMap(vec3 p){
    
    p *= 4.;
    p.y += iTime;
    
    float n3D2 = n3D(p*2.);
   
    // A bit of fBm.
    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;
    c = smoothstep(.45, 1., c); // Putting in some dark space.
    
    p = vec3(c*c*c, c*c, c); // Blueish tinge.
    
    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.

}

// Function 1767
vec3 sdfTwist(vec3 p, float a)
{
    float c = cos(a * p.y);
    float s = sin(a * p.y);
    mat2 m = mat2(c, -s, s, c);

    return vec3(m * p.xz, p.y);
}

// Function 1768
vec2 barrelDistortion( vec2 p, vec2 amt )
{
    p = 2.0 * p - 1.0;

    /*
    const float maxBarrelPower = 5.0;
	//note: http://glsl.heroku.com/e#3290.7 , copied from Little Grasshopper
    float theta  = atan(p.y, p.x);
    vec2 radius = vec2( length(p) );
    radius = pow(radius, 1.0 + maxBarrelPower * amt);
    p.x = radius.x * cos(theta);
    p.y = radius.y * sin(theta);

	/*/
    // much faster version
    //const float maxBarrelPower = 5.0;
    //float radius = length(p);
    float maxBarrelPower = sqrt(5.0);
    float radius = dot(p,p); //faster but doesn't match above accurately
    p *= pow(vec2(radius), maxBarrelPower * amt);
	/* */

    return p * 0.5 + 0.5;
}

// Function 1769
vec4 map( vec3 p )
{
	p.x += 0.1*sin( 3.0*p.y );
	
	float rr = length(p.xz);
	float ma = 0.0;
	vec2 uv = vec2(0.0);
	
	float d1 = rr - 1.5;
    if( d1<1.8 )
	{
		
		float siz = 6.0;
		vec3 x = p*siz + 0.5;
		vec3 xi = floor( x );
		vec3 xf = fract( x );

		vec2 d3 = vec2( 1000.0, 0.0 );
		for( int k=-1; k<=1; k++ )
        for( int j=-1; j<=1; j++ )
        for( int i=-1; i<=1; i++ )
        {
            vec3 b = vec3( float(i), float(j), float(k) );
			vec3 c = xi + b;
			
			float ic = dot(c.xz,c.xz)/(siz*siz);
			
			float re = 1.5;
			
			if( ic>(1.0*1.0) && ic < (re*re) )
			{
            vec3 r = b - xf + 0.5 + 0.4*(-1.0+2.0*hash3( c ));
			//vec3 r = c + 0.5 - x;

			vec3 ww = normalize( vec3(c.x,0.0,c.z) );
			ww.y += 1.0; ww = normalize(ww);
            ww += 0.25 * (-1.0+2.0*hash3( c+123.123 ));
				
			vec3 uu = normalize( cross( ww, vec3(0.0,1.0,0.0) ) );
			vec3 vv = normalize( cross( uu, ww ) );
			r = mat3(  uu.x, vv.x, ww.x,
					   uu.y, vv.y, ww.y,
					   uu.z, vv.z, ww.z )*r;
            float s = 0.75 + 0.5*hash1( c+167.7 );				
			float d = shape(r,s)/siz;
            if( d < d3.x )
            {
                d3 = vec2( d, 1.0 );
				ma = hash1( c.yzx+712.1 );
				uv = r.xy;
            }
			}
        }
		d1 = mix( rr-1.5, d3.x, d3.y );
	}
	
	d1 = min( d1, rr - 1.0 );

    return vec4(d1, ma, uv );
	
}

// Function 1770
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 objCol;
  vec3 col, vn, w;
  float dstBall, dstCyl, dstHit;
  dstBall = BallHit (ro, rd, dstFar);
  dstCyl = CylHit (ro, rd, dstBall);
  rdSign = sign (rd);
  dstHit = ObjRay (ro, rd);
  if (min (dstBall, dstCyl) < min (dstHit, dstFar)) {
    if (dstCyl < dstBall) {
      col = vec3 (0.5, 0.5, 0.6);
      vn = vnCyl;
    } else {
      col = vec3 (HsvToRgb (vec3 (mod (float (5 * idBall) / float (nBall), 1.),
         1., 1.)));
      vn = vnBall;
    }
    col = col * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +
       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);
  } else if (dstHit < dstFar) {
    ro += rd * dstHit;
    vn = ObjNf (ro);
    if (idObj == 1) {
      w = smoothstep (0., 0.1, abs (fract (1.95 * ro + 0.5) - 0.5));
      objCol = vec4 (mix (vec3 (0.4, 0.4, 1.), vec3 (0.5, 0.5, 0.2),
         dot (abs (vn) * w.yzx * w.zxy, vec3 (1.))), 0.4);
    } else if (idObj == 2) objCol = vec4 (0.4, 0.4, 1., 0.4);
    col = objCol.rgb * (0.4 + 0.6 * max (dot (vn, ltDir), 0.)) +
       objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);
  } else col = vec3 (0., 0.1, 0.);
  return pow (clamp (col, 0., 1.), vec3 (0.7));
}

// Function 1771
vec2 map( in vec3 pos )
{
	vec2 sphere		= vec2( length( pos - spherePos ) - sphereRad, 2.0 );

	vec3 pa			= pos - tubeStart;
	vec3 ba			= tubeEnd - tubeStart;
	vec2 tube		= vec2( length( pa - ba * clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 ) ) - tubeRad, 2.0 );
	float bump		= 0.0;
	
	#ifndef DISABLE_NORMALS
	bump			= texture( iChannel0, pos.xz * 6.0 ).x * 0.002;
	#endif
	
	vec2 res		= vec2( pos.y + bump, 1.0 );
	res				= ( res.x < sphere.x ) ? res : sphere;
	res				= ( res.x < tube.x ) ? res : tube;
	
    return res;
}

// Function 1772
float sphereSDF(vec3 p, float size) {
    return length(p) - size;
}

// Function 1773
float distGrid( in vec3 p)
{
	float d = sdBox(mod(p,.25)-.125,vec3(.125));
    
    return d;
	
}

// Function 1774
float mapHeightHQ(in vec3 rp)
{
    float bottom = mapBottom(rp);
    float limit = smoothstep(45., 80., abs(rp.x)) * 3.;
    bottom -= (0.4 * smoothstep(0.2, 0.5, noise(rp.xz * .13))) * limit;
    bottom += (0.3 * smoothstep(0.1, 0.5, noise(rp.xz * .33))) * limit;
    return rp.y - bottom;
}

// Function 1775
vec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi ) {
    vec3 Lo = vec3( 0.0 );
    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);
    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);
    
    for( int i=0; i<BSDF_SAMPLES; i++ ) {
        //Generate direction proportional to bsdf
        vec3 bsdfDir;
        float bsdfPdfW;
        float Xi1 = xi.x;//rnd();
        float Xi2 = xi.y;//rnd();
        float strataSize = 1.0 / float(BSDF_SAMPLES);
        Xi2 = strataSize * (float(i) + Xi2);
        float brdf;
        
        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {
            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );
            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );
        } else {
            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );
            brdf = evaluateLambertian( n, bsdfDir );
        }
        
        float dotNWi = dot( bsdfDir, n );

        //Continue if sampled direction is under surface
        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){
            //calculate light visibility
            RaySurfaceHit newHit;
            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {
                //Get hit light Info
                vec3 Li;
                Sphere lightSphere;
                getLightInfo( newHit.obj_id, lightSphere, Li );

                //Read light info
                float weight = 1.0;
				float lightPdfW;
                if ( useMIS ) {
                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );
                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);
                    weight = misWeight( bsdfPdfW, lightPdfW );
                }

                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;
            }
        }
    }

    return Lo*bsdfSamplingPdf;
}

// Function 1776
float mapFloor(vec3 p) {
    p.y += 7.0;
    float p1 = sdPlane(p);
    float angle = atan(p.z, p.x);
    float h = sin(angle*10.0)*0.8-0.0;
    h = min(h, sin(length(p.xz)*10.0)*0.3-0.0);
    float d1 = mapHole(p, angle);
    float res = max( -d1, h);
    d1 = sdBox(p-vec3(0.0, -4.0, 0.0), vec3(6.8, 6.8, 6.8));
    return p1+polsmin(res, d1, 4.0);
}

// Function 1777
void sceneMap3D(vec3 pos, out float t, out int obj)
{
    // Initialize to back wall sdf
    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));
    obj = IDBackWall;

    float t2;
    // Check left wall
    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)
    {
        t = t2;
        obj = IDLeftWall;
    }
    // Check right wall
    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)
    {
        t = t2;
        obj = IDRightWall;
    }
    // Check top ceiling wall
    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)
    {
        t = t2;
        obj = IDCeilingWall;
    }
    // Check floor wall
    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)
    {
        t = t2;
        obj = IDFloorWall;
    }
    // Check for long cube
    if((t2 = box(rotateY(pos + vec3(0, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5))) < t)
    {
        t = t2;
        obj = IDLongCube;
    }
    // Check for sphere
    if((t2 = sphere(pos, 1.3, vec3(-3.5 * sin(iTime), 0.6 + 2.0 * cos(iTime), 3.5 * cos(iTime)))) < t)
    {
        t = t2;
        obj = IDSphere;
    }
}

// Function 1778
float mapTex(samplerCube tex, vec3 p, vec2 size) {
    #ifdef MIRROR
        p.x = clamp(p.x, -.95, .95);
    #endif
    vec2 sub = texSubdivisions;
    float zRange = sub.x * sub.y * 4. * 6. - 1.;
    float z = p.z * .5 + .5;
    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;
    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;
    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);
    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);
    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];
    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];
    return mix(a, b, range(zFloor, zCeil, p.z));
}

// Function 1779
vec2 map(vec3 p) {
    
    vec2 sphereObj =  vec2(sdSphere(p - lights[0].position, lights[0].radius), LIGHT_ID);    
    vec2 oldObj = sphereObj;
    
   	vec2 resultObj = sphereObj;

    vec2 newObj =  vec2(sdSphere(p - spheres[1].p, spheres[1].r), SPHERE_ID1);
    resultObj = opU(resultObj, newObj);
    newObj =  vec2(sdSphere(p - spheres[2].p, spheres[2].r), SPHERE_ID2);
    resultObj = opU(resultObj, newObj);
    newObj =  vec2(sdSphere(p - spheres[3].p, spheres[3].r), SPHERE_ID3);
    resultObj = opU(resultObj, newObj);
    newObj =  vec2(sdSphere(p - spheres[4].p, spheres[4].r), SPHERE_ID4);
    resultObj = opU(resultObj, newObj);
    newObj =  vec2(sdSphere(p - spheres[5].p, spheres[5].r), SPHERE_ID5);
    resultObj = opU(resultObj, newObj);
    newObj =  vec2(sdSphere(p - spheres[6].p, spheres[6].r), SPHERE_ID6);
    resultObj = opU(resultObj, newObj);
	newObj =  vec2(sdPlane(p - planes[0].p, planes[0].n), FLOOR_ID);
   	resultObj = opU(resultObj, newObj);
    
    return resultObj;
}

// Function 1780
float minimum_distance( in vec2 a, in vec2 b, in vec2 p ){
    vec2 pa = p - a, ba = b - a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

// Function 1781
vec4 map(vec3 q3){
    q3.xz*=r2(T*.22); 
    // Scaling and Vars
    const float scale = 2./HEX_SCALE;
	const vec2 l = vec2(scale*1.732/2., scale);
	const vec2 s = l*2.;
    float d = 1e5;
    vec2 p, ip;
    // IDs and Center Points
    vec2 id = vec2(0);
    vec2 cntr = vec2(0);
    const vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l + vec2(0., l.y), -l, vec2(l.x, -l.y) + vec2(0., l.y));
    // which pass you're on
    float boxID = 0.; 
    for(int i = 0; i<4; i++){
        // Block center.
        cntr = ps4[i]/2.;
        // Local coordinates.
        p = q3.xz - cntr;
        ip = floor(p/s) + .5; // Local tile ID.
        p -= (ip)*s; // New local position.
        // Correct positional individual tile ID.
        vec2 idi = (ip)*s + cntr;
        //float hx=hash2(idi*.5);
        float hx=distance(idi,vec2(.0));
        float th = sampleFreq(.01+hx*.0021)*45.;
        th = abs(th*14.999)/15.*.15; 
        // make shape
        vec3 p3 = vec3(p.x,q3.y,p.y);
        float sp = length(p3-vec3(0.,th,0.))-((th*.12));
        if(sp<d){
            d = sp;
         	id = idi;
            boxID = float(i);
            mid = 2.;
        }   
    }
    // Return the distance, position-base ID and box ID.
    return vec4(d/1.7, id, boxID);
}

// Function 1782
vec3 reinhardTonemap(vec3 c){
    return c/(c+1.);
}

// Function 1783
vec3 triPlanarMap(sampler2D inTexture, float contrast, vec3 normal, vec3 position)
{
    vec3 xTex = textureLod(inTexture, (position).yz, 0.0).rgb;
    vec3 yTex = textureLod(inTexture, (position).xz, 0.0).rgb;
    vec3 zTex = textureLod(inTexture, -(position).xy, 0.0).rgb;
    vec3 weights = normalize(abs(pow(normal.xyz, vec3(contrast))));
    
    return vec3(xTex*weights.x + yTex*weights.y + zTex*weights.z);
}

// Function 1784
vec3 bumpMap(vec3 st){
    vec3 sp = st;
    vec2 eps = vec2(4./iResolution.y, 0.);
    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.
    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.
    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.

	const float bumpFactor = 0.1;
    fx = (fx-f)/eps.x; // Change in X
    fy = (fy-f)/eps.x; // Change in Y.
    return vec3(fx,fy,0.)*bumpFactor;
}

// Function 1785
vec3 InvTonemap(vec3 color)
{
    color = pow(abs(color), vec3(Gamma));
    color = ReinhardInv(color);
    
    return color;
}

// Function 1786
float mapTerrain( in vec3 pos )
{
	return pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));
}

// Function 1787
float rectSDF(vec2 st, vec2 s)
{
    return max(abs(st.x/s.x),abs(st.y/s.y));
}

// Function 1788
float TreeBoundsSDF( vec3 pos )
{
    // just a cone
    float r = length(pos.xz);
    return max(//max(
        dot( vec2(pos.y-7.,r), normalize(vec2(.3,1)) ),
        //pos.y-7.), // something goes wrong with the cone SDF?
        -pos.y+1.8+r*.6
        );
}

// Function 1789
vec3 envMap(vec3 rd, vec3 n){
    
    //vec3 col2 = tex3D(iChannel1, rd/4., n).zyx;//*(1.-lod*.8)
    //return smoothstep(.0, 1., col2*2.);
    

    // I got myself a little turned around here, but I think texture size
    // manipulation has to be performed at this level, if you want the angular
    // polar coordinates to wrap... Not sure though... It'll do. :)
    rd /= 4.; 
    
    vec2 uv = vec2(atan(rd.y, rd.x)/6.283, acos(rd.z)/3.14159);
    uv = fract(uv);
   
    vec3 col = texture(iChannel1, uv).zyx;//*(1.-lod*.8)
    return smoothstep(.1, 1., col*col*2.);
    
}

// Function 1790
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstObj, dstGrnd, sh;
  bool isSky, isGrnd, isWat, doSh;
  isSky = false;
  isGrnd = false;
  isWat = false;
  doSh = false;
  tWav = 0.4 * tCur;
  dstObj = ObjRay (ro, rd);
  dstGrnd = dstFar;
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    if (idObj != 7) {
      gId = PixToHex (ro.xz / hgSize);
      vn = ObjNf (ro);
      if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);
    }
    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?
       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.1, 0.1, 0.15, 0.1);
    else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);
    else if (idObj == 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);
    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);
    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);
    else if (idObj == 6) col4 = vec4 (0.15, 0.15, 0.2, 0.1);
    else if (idObj == 7) isGrnd = true;
    doSh = true;
  } else if (rd.y < 0.) {
    dstGrnd = GrndRay (ro, rd);
    ro += dstGrnd * rd;
    if (ro.y < 0.) isWat = true;
    else isGrnd = true;
  } else isSky = true;
  if (! isSky) {
    if (isWat) {
      ro += (- ro.y / rd.y) * rd;
      rd = reflect (rd, VaryNf (0.5 * ro + vec3 (0.1 * tCur, 0., 0.1 * tCur), vec3 (0., 1., 0.), 0.1));
      col = 0.9 * SkyHzCol (ro, rd);
    } else {
      if (isGrnd) {
        col4 = vec4 (vec3 (0.95, 0.95, 1.) * min (0.9 + 0.2 * Fbm2 (ro.xz), 1.), 0.1);
        vn = VaryNf (ro, vec3 (0., 1., 0.), 0.3);
        doSh = (min (dstGrnd, dstObj) < dstFar);
      }
      if (isNite) {
        if (isGrnd || idObj != 3) col = col4.rgb * vec3 (0.15, 0.3, 0.2) * (0.2 + 0.8 * max (0., vn.y));
        else col = vec3 (0.7, 0., 0.) * max (- dot (vn, rd), 0.);
      } else {
        sh = doSh ? ObjSShadow (ro, sunDir) : 1.;
        col = col4.rgb * (0.3 + 0.2 * max (dot (normalize (vec3 (vn.x, 0., vn.z)), - sunDir), 0.) +
           0.6 * sh * max (dot (vn, sunDir), 0.)) +
           col4.a * smoothstep (0.8, 1., sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
      }
    }
    col = mix (col, vec3 (0.9) * (isNite ? 0.8 * vec3 (0.15, 0.3, 0.2) : vec3 (1.)),
       smoothstep (0.3, 1., min (dstGrnd, dstObj) / dstFar));
  } else col = SkyHzCol (ro, rd);
  return pow (clamp (col, 0., 1.), vec3 (0.9));
}

// Function 1791
vec3 sampleBSDF(	in vec3 x,
                  	in mat3 trans,
                  	in mat3 inv_trans,
                  	in vec3 ng,
                	in vec3 wi,
                  	in Material mtl,
                  	in bool useMIS,
                	out BrdfSamplingResult brdfres,
                	out bool hitRes,
                	out SurfaceHitInfo hit) {
    vec3 Lo = vec3(0.0);
    
    brdfres = mtlSample(mtl, ng, wi, rnd2() );
    
    //Continue if sampled direction is under surface
    if ((dot(brdfres.f,brdfres.f)>0.0) && (brdfres.pdf > 0.0)) {
        
        Ray shadowRay = Ray(x + (trans * ng) * EPSILON, trans * brdfres.w);

        float cosAtLight = 1.0;
        float distanceToLight = -1.0;
        vec3 Li = vec3(0.0);

        {
            float distToHit;

            if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {
                if(hit.mtl_id_>=LIGHT_ID_BASE) {
                    distanceToLight = distToHit;
                    cosAtLight = dot(hit.normal_, -shadowRay.dir);
                    if(cosAtLight > 0.0) {
                        Li = getRadiance(hit.uv_);
                        //Li = lights[0].color_*lights[0].intensity_;
                    }
                } else {
                    hitRes = true;
                }
            } else {
                hitRes = false;
                //TODO check for infinite lights
            }
        }

        if (distanceToLight>0.0) {
            if (cosAtLight > 0.0) {
                vec3 contribution = (Li * brdfres.f * brdfres.w.z) / brdfres.pdf;

                if (!brdfres.isDelta ) {
                    float lightPdfW = sampleLightSourcePdf( x, shadowRay.dir, distanceToLight, cosAtLight );
 
                    contribution *= misWeight(brdfres.pdf, lightPdfW);
                }

                Lo += contribution;
            }
        }
    }

    return Lo;
}

// Function 1792
float DistanceToObject(vec3 p)
{
	float final = p.y + 4.5;
    final -= SpiralNoiseC(p.xyz);	// mid-range noise
    final += SpiralNoiseC(p.zxy*0.123+100.0)*3.0;	// large scale terrain features
    final -= SpiralNoise3D(p);	// more large scale features, but 3d, so not just a height map.
    final -= SpiralNoise3D(p*49.0)*0.0625*0.125;	// small scale noise for variation
	final = min(final, length(p) - 1.99);	// sphere in center
    final = min(final, p.y + waterLevel);	// water
	//final = min(final, length(p-camLookat) - 0.3);
    return final;
}

// Function 1793
vec2 sdfBox( vec3 currentRayPosition ){
  
  // First we define our box position
  vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );
    
  // than we define our box dimensions using x , y and z
  vec3 boxSize = vec3( .4 , .3 , .2 );
    
  // Here we get the 'adjusted ray position' which is just
  // writing the point of the ray as if the origin of the 
  // space was where the box was positioned, instead of
  // at 0,0,0 . AKA the difference between the vectors in
  // vector format.
  vec3 adjustedRayPosition = currentRayPosition - boxPosition;
    
  // finally we get the distance to the box surface.
  // I don't get this part very much, but I bet Inigo does!
  // Thanks for making code for us IQ !
  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;
  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); 
  float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );
  
  // Finally we build the full box information, by giving it an ID
  float boxID = 2.;
    	
  // And there we have it! A fully described box!
  vec2 box = vec2( distanceToBoxSurface,  boxID );
    
  return box;
    
}

// Function 1794
float get_dist_ray_point(Ray ray, vec3 point)
{
    float t = (dot(ray.dir, point - ray.pos)/dot(ray.dir, ray.dir));
    
    if (t > 0.0)
    {
        return length(point - (ray.pos + t * ray.dir));
    }
    
    return length(point - ray.pos);
}

// Function 1795
float AirplaneSDF( vec2 p, vec2 airplanePos, vec2 airplaneDir, float airplaneScale )
{    
	p -= airplanePos;
    airplaneDir *= airplaneScale;
    p = vec2( dot( p, vec2( airplaneDir.y, -airplaneDir.x ) ), dot( p, airplaneDir ) );
    
    float body = Rectangle( p + vec2( 0.0, -40.0 ), vec2( 6.0, 10.0 ) );
	body = Union( body, Ellipsoid( p + vec2( 0.0, -70.0 ), vec2( 6.0, 25.0 ) ) );
    body = Union( body, Ellipsoid( p + vec2( 0.0, -20.0 ), vec2( 6.0, 25.0 ) ) );
    
    vec2 t = p;
    t.x = abs( t.x );
	t += vec2( -20.0, -45.0 );
    float engine = Line( t, 15.0, 5.0 );
    t += vec2( -15.0, 10.0 );
    engine = Union( engine, Line( t, 15.0, 5.0 ) );
    
    t = p;
    t.x = abs( t.x );
    t.y -= 0.0;
    float wing = dot( t, normalize( vec2( 0.1, 0.12 ) ) ) - 55.0;
    wing = Substract( wing, dot( t, normalize( vec2( 0.1, 0.2 ) ) ) - 42.0 );
	wing = Substract( wing, -t.x + 50.0 );
    
    t = p;
    t.x = abs( t.x );
    t.y += 44.0;    
    float tail = dot( t + vec2( 0.0, 6.0 ), normalize( vec2( 0.1, 0.12 ) ) ) - 50.0;
    tail = Substract( tail, dot( t, normalize( vec2( 0.1, 0.5 ) ) ) - 40.0 );
	tail = Substract( tail, -t.x + 20.0 );
    
    float ret = Union( Union( Union( body, engine ), wing ), tail );
    return ret;
}

// Function 1796
void BarrelDistortion( inout vec3 ray, float degree )
{
	ray.z /= degree;
	ray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );
	ray.z = degree*sqrt(ray.z);
}

// Function 1797
float diffSDF(float a,float b){
	return max(a,-b);
}

// Function 1798
float map(vec3 p) 
{
    R(p.xy, iTime * .25);
    R(p.yz, iTime * .25);
    p = 1.001 * abs(fract(p * sin(.1)) - .5);
    p = smoothstep(0.21, 1., 6.28 * p * p); //p *= p * 6.28318;
    return length( p -  k( mod(iTime, .5), 0.51 ) ) - 1.;
}

// Function 1799
float map(in vec2 p) {
    p.x -= path(p.y);
    float h = pow(abs(p.x) + 0.1, 4.0)*0.1;
    return clamp(h, 0.0, 30.0) - hash(p)*0.5;
}

// Function 1800
float HammersleyDistribution(uint bits) 
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

// Function 1801
float Font_DecodeBitmap( vec2 vCoord, ivec3 vCharacter )
{
    vCoord = floor( vCoord );

    int iRow = int(vCoord.y) - 1;
    int iCol = int(vCoord.x) - 1;
    
    if ( iRow < 0 || iRow >= 6 ) return 0.0;
    if ( iCol < 0 || iCol >= 7 ) return 0.0;
    
    int iRowBits = 0;
        
   	if ( iRow == 0 ) 			iRowBits = vCharacter.x;
    else  if ( iRow == 1 ) 		iRowBits = vCharacter.x / 128;
    else  if ( iRow == 2 ) 		iRowBits = vCharacter.x / 16384;
    else  if ( iRow == 3 ) 		iRowBits = vCharacter.y;
    else  if ( iRow == 4 ) 		iRowBits = vCharacter.y / 128;
    else 						iRowBits = vCharacter.y / 16384;
      
    return (iRowBits & (1 << iCol )) == 0 ? 0.0 : 1.0;
}

// Function 1802
vec3 pwc_tonemap(vec3 c)
{
    c = m1 * c;
    vec3 tmp = vec3(pwc(c.r), pwc(c.g), pwc(c.b));
    
    c = m2 * tmp;
    
    return pow(clamp(c, 0.0, 1.0), vec3(1.0 / 2.2));
}

// Function 1803
vec3 PBR_HDRremap(vec3 c)
{
    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);
    //vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);
    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);
    return cBlueSky;//mix(cRedSky,cBlueSky,SKY_COLOR);
}

// Function 1804
float landMap(vec3 p) {
    return p.z - texture(iChannel0, fract(p.xy)).r;
}

// Function 1805
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 ltDir, col, vn;
  float dstHit;
  dstHit = ObjRay (ro, rd);
  ltDir = normalize (vec3 (0.2, 1., -0.2));
  col = vec3 (clamp (0.5 + 1.5 * rd.y, 0., 1.));
  if (dstHit < dstFar) {
    ro += dstHit * rd;
    vn = ObjNf (ro);
    col = HsvToRgb (vec3 (min (length (ro) / 5., 1.), 1.,
       max (0., 1. - 0.5 * qStep * qStep)));
    col = col * (0.3 +
       0.7 * max (dot (vn, ltDir), 0.)) +
       0.3 * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);
    col = clamp (col, 0., 1.);
  }
  return col;
}

// Function 1806
float mapFloor(vec3 p) {
    #define FREQ_RAINURES 5.0
    #define AMP_RAINURES 0.2
    p.y += 7.0;
    float p1 = sdPlane(p);
    float angle = atan(p.z, p.x);
    float h = sin(angle*10.0)*0.8-0.0;
    h = min(h, sin(length(p.xz)*FREQ_RAINURES)*AMP_RAINURES-0.0);
    float d1 = mapHole(p);
    float res = max( -d1, h);
    d1 = sdBox(p-vec3(0.0, -4.0, 0.0), vec3(6.8, 6.8, 6.8));
    return p1+polsmin(res, d1, 4.0);
}

// Function 1807
float line_distance(vec2 p, vec2 p1, vec2 p2) {
    vec2 center = (p1 + p2) * 0.5;
    float len = length(p2 - p1);
    vec2 dir = (p2 - p1) / len;
    vec2 rel_p = p - center;
    return dot(rel_p, vec2(dir.y, -dir.x));
}

// Function 1808
float boxSDF(vec3 p, vec3 size) {
    vec3 d = abs(p) - (size / 2.0);
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 1809
float scene(vec3 p)
{
    float diff=scenediff(p);
    float lite=scenelite(p);
    m=(lite<diff)?1:0;
    return min(lite,diff);
}

// Function 1810
vec3 i_spheremap_24( uint data )
{
    vec2 v = unpackSnorm2x12(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 1811
float DistanceEstimator( vec3 point ) {
    
    float dist = min(boxLine(point, 0.), boxLine(point, 2.5));

    return min(dist, sdPlane(point));
}

// Function 1812
vec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )
{
	//if(v1.x < v2.x) return v1; else return v2;
	return mix(v1, v2, step(v2.x, v1.x));
}

// Function 1813
float dist(vec3 p){
    vec3 pp = repeat(p, vec3(2.0));
    
    return sphere(pp, 0.17);
}

// Function 1814
float coneSdf(vec3 p)
{
    float t = 1.0;
    if(apply)
    {
        t = applyMobius(p);
        p = normalize(p);
    }
    float q = length(p.xy);
    return dot(coneAngle, vec2(q, -p.z)) * t;
}

// Function 1815
float dist_vertical_line( vec3 p)
{
  return length(vec2(length(p.xz)-1.0,p.y));
}

// Function 1816
float distanceEstimation(vec3 pos) {
    if(length(pos) > 1.5) return length(pos) - 1.2;
    vec3 z = pos;
    float dr = 1.0, r = 0.0, theta, phi;
    for (int i = 0; i < 8; i++) {
        r = length(z);
        if (r>1.5) break;
        dr =  pow( r, Power-1.0)*Power*dr + 1.0;
        theta = acos(z.z/r) * Power + ThetaShift;
        phi = atan(z.y,z.x) * Power + PhiShift;
        float sinTheta = sin(theta);
        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;
    }
    return 0.5*log(r)*r/dr;
}

// Function 1817
float geodesicDist(vec3 l, vec2 p) {
	if (l.z > 0.0) {
		return length(p-l.xy) - sqrt(l.z);
	} else {
		return dot(normalize(l.xy), p);
	}
}

// Function 1818
vec3 Tonemap_ACES(vec3 x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// Function 1819
float power_dist(vec2 uv, float power) { //Spike to circle to round square
    return length(pow(abs(uv),vec2(power)))*power;
}

// Function 1820
vec2 DistortUV( vec2 vUV, float f )
{
    vUV -= 0.5;

    float fScale = 0.0005;
    
    float r1 = 1. + f * fScale;
    
    vec3 v = vec3(vUV, sqrt( r1 * r1 - dot(vUV, vUV) ) );
    
    v = normalize(v);
    vUV = v.xy;
    
    
    vUV += 0.5;
    
    return vUV;
}

// Function 1821
float map(in vec3 p)
{
    return min(s0(p), pl(p));
}

// Function 1822
float TerrainDistance( in vec3 p)
{
  return p.y + GetTerrainHeight(vec2(p.xz)+scroll);
}

// Function 1823
float DressDF( vec3 p )
{
    //return max( abs(p.y)-1.0, length(p.xz)-.5 ); // vaguely dress shaped
    
    return length( max(vec3(.0),abs(p)-vec3(0,.5,0)) )-.5 + sin(p.y*8.0)*.3/8.0 + sin(p.x*17.0+sin(p.y*8.0))*.2/17.0;
}

// Function 1824
float extrudeDist (float d, float w, float y)
{
    return length(vec2(max(d, 0.), y - clamp(y, -w, w)))
        + min(max(d, abs(y)-w), 0.);
}

// Function 1825
float objDist(vec2 p, float pH, float r, float ht, inout float id, float dir){
    
    // Neon light height: Four levels, plus the height is divided by two.
    const float s = 1./16.; //1./4./2.*.5; 

    // Main hexagon pylon.
    float h1 = hexPylon(p, pH, r, ht);
    
    #ifdef ADD_DETAIL_GROOVE
    // I like this extra detail, but it was a little too expensive.
	h1 = max(h1, -hexPylon(p, pH + ht, r - .06, s/4.)); // Extra detail.
    #endif
    
    #ifdef ADD_DETAIL_BOLT
    // An alternative extra detail. Also a little on the expensive side.
    h1 = min(h1, hexPylon(p, pH, .1, ht + s/4.)); // Extra detail.
    #endif

    
    
    // Thin hexagon slab -- sitting just below the top of the main hexagon. It's
    // lit differently to represent the neon portion.
    float h2 = hexPylon(p, pH + ht - s, r + .01, s/3.);
    
     
    // Opens a space around the neon lit hexagon. Used, if the radius of "h2" is
    // less that "h1," which isn't the case here.
    //h1 = smax(h1, -(abs(pH + ht - s) - s/3.), .015);
    
    // Identifying the main hexagon pylon or the neon lit portion.
    id = h1<h2? 0. : 1.;
    
    // Return the closest object.
    return min(h1, h2);
    
}

// Function 1826
vec2 map(vec3 p)
{   
    float d = terrain(p) + p.y - 0.4;
    
    //bounding box
    #ifdef BOUNDED
    d = max(d, sdBox(p + vec3(0,-1.25,0), vec3(2.4,2.3,2.4)));
    #endif

    vec2 rez = dUnion(vec2(d, 1.), vec2(rocket(p),2.));
    rez = dUnion(rez, tank(p));
    
    //crates
    p.xz = foldTri(p.xz+vec2(0.4,0.45))+0.27;
    float crates = sdBox(p + vec3(0.,.71,.0), vec3(0.042, 0.04, 0.037));
    
    rez = dUnion(rez, vec2(crates, 5.));
    
    return rez;
}

// Function 1827
vec3 SphereMap(vec3 vert) {
    vec3 inormal = normalize(vert);
    float ndist = length(inormal);
    float ncross = atan(inormal.x, inormal.z);
    float ncross2 = atan(length(inormal.xz), inormal.y);
    vec2 ncase = vec2(ncross, ncross2)/vec2(-maxAng, -maxAng);
    vec4 wmap = texture(iChannel0, ncase+0.5);
    return wmap.rgb;
}

// Function 1828
float distfunc(vec3 pos)
{
	vec3 cellpos=fract(pos);
	vec3 gridpos=floor(pos);

	float rnd=rand(gridpos);

	if(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));
	else if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));
	else if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));
	else if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));
	else if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,1.0-cellpos.z));
	else if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,1.0-cellpos.z));
	else if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,1.0-cellpos.z));
	else  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,1.0-cellpos.z));
}

// Function 1829
void abstract_glassy_field_envMap(inout vec3 _2082, sampler2D _2083, vec3 _2084, vec3 _2085)
{
    vec3 _2097 = _240;
    _2097.x = _2084.x * 4.0;
    vec3 _2098 = _2097;
    _2098.y = _2084.y * 4.0;
    vec3 _2099 = _2098;
    _2099.z = _2084.z * 4.0;
    vec3 _2088 = _2099;
    vec3 _2089 = _2085;
    vec3 _2087;
    abstract_glassy_field_tpl(_2087, _2083, _2088, _2089);
    _glam_f32_vec3a_Vec3A_as_rustoy_std_Vec3Ext_map_abstract_glassy_field_envMap_closure_0_(_2082, _2087);
}

// Function 1830
float approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {
    b0 -= p;
    b1 -= p;
    b2 -= p;
	float t = get_distance_vector(b0, b1, b2);

    float l0 = bezlen(b0,b1,b2,t);
        
        
        
        
//        length(mix(mix(b0,b1,t),mix(b1,b2,t),t));
#if 0
    for(int  i=0;i<4;i++)
    {
    	vec2 f = mix(mix(b0,b1,t),mix(b1,b2,t),t);
    	vec2 d = 2.0*(1.0-t)*(b1-b0)+2.0*t*(b2-b1);
        float sqlf = dot(f,f);
    	float sqld = dot(d,d);
    
    	t = t - f/d;
    }
    float ln = length(mix(mix(b0,b1,t),mix(b1,b2,t),t));
#endif

    return l0; // = ()
}

// Function 1831
float Scene(in vec3 pos, in vec3 dir, out vec3 normal)
{
   float tmin = 1e3;
    
    pos+=dir*0.0001; //just to avoid self intersections

   vec4 sph = vec4( cos( .5* iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(0.,1.2,0.0), 1.0 );
   float t2 = sphIntersect( pos, dir, sph );        
   if( t2>0.0 && t2<tmin )
   {
       tmin = t2;
       vec3 pos = pos + tmin*dir;
       normal = normalize( pos - sph.xyz );
   }      
    
   t2 = iPlane( pos, dir );
   if( t2>0.0 && t2<tmin )
   {
       tmin = t2;
       normal = vec3(0.0,1.0,0.0);
   }    
    
    
    return tmin;    
}

// Function 1832
float reinhardTonemap(float x)
{
    x = (x / (x + 1.0));
    return x;
}

// Function 1833
vec2 equirectangularMap(vec3 dir) {
	vec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));
 	return longlat/vec2(2.0*PI,PI);
}

// Function 1834
float boxDist(in Ray ray, in Box box) {
    vec3 dist = abs(ray.origin - box.pos) - (box.size * 0.5);
    vec3 cDist = max(dist, 0.0);
    return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(cDist) - box.radius;
}

// Function 1835
Impact map(in vec3 pos)
{
    //Sphere1
	float sphereRadius = 0.5;
	float sphereDistance = dSphere( pos-vec3( -1.5, -1.0, 2.5), sphereRadius );
	vec3 sphereColour = vec3(1.0, 1.0, 0.8);
    Impact sphere1_p = Impact(sphereDistance,0.0,sphereColour,0);
    
    //Sphere2
	sphereRadius = 0.5;
	sphereDistance = dSphere( pos-vec3( 2.0, 1.0, 2.0), sphereRadius );
	sphereColour = vec3(1.0, 1.0, 0.8);
    Impact sphere2_p = Impact(sphereDistance,0.0,sphereColour,0);
    
    //Box 1
    vec3 boxSize = vec3(0.2,2.0,2.0);
    vec3 boxPosition = vec3(1.5,-2.0, 5.0);
    float boxDistance = dBox(pos-boxPosition, boxSize);
    vec3 boxColour = vec3(1.0, 1.0, 0.8);   
   	Impact box1_p = Impact(boxDistance, 0.0, boxColour,0); 
    
    //Room
    vec3 roomSize = vec3(5.0,3.0,5.0);
    vec3 roomPosition = vec3(0.0,0.0, 1.0);
    float roomDistance = dInvertedBox(pos-roomPosition, roomSize);
    
    //Room colour, fancy or regular
    //vec3 roomColour = vec3(pow(abs(pos)*0.1,vec3(2.0)) );//+tex.rgb*0.3; 
    vec3 roomColour =vec3(0.8,0.8,0.8);
    if (pos.x > roomSize.x-0.01) roomColour = vec3(1.0,0.0,0.0);
    if (pos.x < - roomSize.x+0.01) roomColour = vec3(0.0,0.0,1.0);
    if (pos.y > roomSize.y-0.01) roomColour = vec3(1.0,0.6,0.2);
    if (pos.y < - roomSize.y+0.01) roomColour = vec3(0.0,1.0,0.2);
    Impact room_p = Impact(roomDistance, 0.0, roomColour, 0);
    
    //Light globe
    float lightRadius = light.r;
	float lightDistance = dSphere( pos-light.p, lightRadius );
	
    Impact light_p = Impact(lightDistance,light.lum, light.col, 0);
    
  
    Impact closest = getClosest(box1_p,sphere1_p);
    closest= getClosest(closest,sphere2_p); 
    closest= getClosest(closest,room_p); 
    closest= getClosest(closest,light_p); 
      
    return closest;
}

// Function 1836
float map(vec2 p)
{
	//return sin(atan(p.y, p.x)*5.0+length(p)*8.0);
	//return sin(atan(p.y, p.x)*8.0)-sin(length(p)*8.0);
	//return sin(p.x*8.0)*cos(p.y*8.0);
	//return sin(p.x*8.0);
	return sin(atan(p.y, p.x)+length(p)*8.0);
	//return -p.x;
}

// Function 1837
float voxelDistance(vec3 pos) {
	vec3 p = floor(pos); //integer coordinates
	pos = mod(pos, 1.0);
	const vec3 o = vec3(0, 1.0, -1.0); //for swizzling
	
	float faceX = min(zeroToOne(pos.x * getVoxel(p + o.zxx)), zeroToOne((1.0 - pos.x) * getVoxel(p + o.yxx)));
	float faceY = min(zeroToOne(pos.y * getVoxel(p + o.xzx)), zeroToOne((1.0 - pos.y) * getVoxel(p + o.xyx)));
	float faceZ = min(zeroToOne(pos.y * getVoxel(p + o.xxz)), zeroToOne((1.0 - pos.z) * getVoxel(p + o.xxz)));
	float face = min(faceX, min(faceY, faceZ));
	
	//float edgeX1 = 
	return 0.0;
	
}

// Function 1838
vec2 scene( vec3 ro, vec3 rd )
{
    float t = 0.01;
    for ( int i = 0; i < 100; i++ )
    {
        vec3 pos = ro + t * rd;
        vec2 res = map( pos );
        if ( res.x < 0.01 )
        {
            return vec2( t, res.y );
        }
        t += res.x;
    }
    return vec2( -1.0 );
}

// Function 1839
float scene(vec3 p)
{
	vec2 cir = circuit(p);
	return exp(-100.0 * cir.y) + pow(cir.x * 1.8 * (sin(p.z * 10.0 + iTime * -5.0 + cir.x * 10.0) * 0.5 + 0.5), 8.0);
}

// Function 1840
float distance_point_line(in vec3 point, in vec3 origin, in vec3 direction) {
    return sqrt(distance2_point_line(point, origin, direction));
}

// Function 1841
vec3 normalMap(vec3 p, vec3 n)
{
    float d = 0.005;
    float po = triplanarNoise(p,n);
	float px = triplanarNoise(p+vec3(d,0,0),n);
    float py = triplanarNoise(p+vec3(0,d,0),n);
	float pz = triplanarNoise(p+vec3(0,0,d),n);
    return normalize(vec3((px-po)/d,
                          (py-po)/d,
                          (pz-po)/d));
}

// Function 1842
vec4 sceneDistance(vec2 p, inout vec4 fragColor)
{
    float modTime = 4.;
    modTime = mod((iTime-4.),maxTime);
    bg(p, fragColor);
    
    return fragColor;
}

// Function 1843
float map( vec3 p )
{
    
    vec3 q = fract(p) * max(2.0,float(p)) - 1.0;
    return length(q) - 0.5;
    
}

// Function 1844
dfObject map(in vec3 p) {
    
    dfObject res;
    
    // bottom
    res = dfObject(
                    sdPlaneY(p), 
                    Material(vec3(0.), vec3(0.), MAT_CHECKER)
                );
    
    // big sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p-vec3(0.0, 1.0, 0.0), 0.55),
                        Material(vec3(0.9, 0.7, 0.3), vec3(0.), MAT_DIFF)
                    )
                  );
    // shiny sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p - vec3(1.55, 0.5, 1.0), 0.5),
                        Material(vec3(1.0), vec3(0.), MAT_SPEC)
                    )
                  );
    
    // small marble
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p - vec3(-1.1, 0.2, 0.2), 0.2),
                        Material(vec3(0.1, 0.17, 0.08), vec3(0.), MAT_SPEC)
                    )
                  );
    
    
    // cube
    res = dfUnion(res,
                  	dfObject(
                        sdBox(p - vec3(-1.5, 0.6, 1.5), vec3(0.4)),
                        Material(vec3(0.7), vec3(0.), MAT_DIFF)
                    )
                  );
    
    
    
        
    // right wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneX(p - vec3(-3., 0., 0.)),
                        Material(vec3(1.0, 0.0, 0.0), vec3(0.), MAT_DIFF)
                    )
                  );
    // left wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneX(p - vec3(3., 0., 0.)),
                        Material(vec3(0.0, 0.0, 1.0), vec3(0.), MAT_DIFF)
                    )
                  );
    
    // top wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneY(p - vec3(0.0, 3.0, 0.0)),
                        Material(vec3(1.0), vec3(40.), MAT_DIFF)
                    )
                  );
    
    // back wall
	res = dfUnion(res,
                  	dfObject(
                        sdPlaneZ(p - vec3(0.0, 0.0, 3.0)),
                        Material(vec3(1.0), vec3(0.), MAT_DIFF)
                    )
                  );
    
    // back wall behind cam
	res = dfUnion(res,
                  	dfObject(
                        sdPlaneZ(p - vec3(0.0, 0.0, -3.0)),
                        Material(vec3(0.0), vec3(0.), MAT_DIFF)
                    )
                  );
    //res = dfUnion(res, vec2(sdTorus(p - vec3(-0.3, 1.8, 0), vec2(0.6, 0.1)), 200.9)); // 30.9
    
    // back wall
    
    return res;
}

// Function 1845
vec2 map (in vec3 p) {
    vec2 res = vec2(MAX_DIST,0.);
    
    vec3 dp = p;
    
    p.y+= .2;
    p.z+= M.z>0.?.75:1.75;
   
    // movin domain 1 rep but using px to move the ID's
    // as if the domain is continious helps make the refraction
    // stay pretty as things get messy with larger time variables 
    // used for distance
    float px = p.x-(ga2*s);
    p.x-=ga1*s;
    float id = floor((px+hf)/s);

    p.x=mod(p.x+hf,s)-hf;
    p.yz*=rx;
    p.xz*=ry;

    float hs = hash21(vec2(id,1.));
    vec2 f = sdform(p,hs);
    float c = octa(p,3.);
    
    f.x= hs>.85?max(f.x,c):max(-f.x,c);
    if(f.x<res.x) {
        res = f;
    }

    float d = box(dp,vec3(9),.00);
    d=max(d,-box(dp,vec3(5.5,4.,5.5),.001));
    d=max(d,-box(dp,vec3(9.5,3.,4.5),.25));
    d=max(d,-box(dp,vec3(4.5,3.,9.5),.25));
    if(d<res.x) {
        res = vec2(d,14.);
    }

    return res;
}

// Function 1846
vec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)
{   
    mediump float rq = r*r;
    mediump vec3 dist = ray*far;
    
    mediump vec3 norm = vec3(0.0,0.0,1.0);
    mediump float invn = 1.0/dot(norm,ray);
    mediump float depthi = depth;
    if (invn<0.0) depthi =- depthi;
    mediump float ds = 2.0*depthi*invn;
    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;
    mediump vec3 op1 = r1+norm*depthi;
    mediump float len1 = dot(op1,op1);
    mediump vec3 r2 = r1+ray*ds;
    mediump vec3 op2 = r2-norm*depthi;
    mediump float len2 = dot(op2,op2);
    
    mediump vec3 n = normalize(cross(ray,norm));
    mediump float mind = dot(pos,n);
    mediump vec3 n2 = cross(ray,n);
    mediump float d = dot(n2,pos)/dot(n2,norm);
    mediump float invd = 0.2/depth;
    
    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))
    {        
        mediump vec3 r3 = r2;
        mediump float len = len1;
        if (len>=rq) {
        	mediump vec3 n3 = cross(norm,n);
        	mediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));
            mediump vec3 dt = ray/a;
        	r1 =- d*norm-mind*n-dt;
            if (len2>=rq) {
                r2 =- d*norm-mind*n+dt;
            }
            ds = dot(r2-r1,ray);
        }
        ds = (abs(ds)+0.1)/(iterations);
        ds = mix(depth,ds,0.2);
        if (ds>0.01) ds=0.01;
        mediump float ir = 0.35/r;
        r *= zoom;
        ray = ray*ds*5.0;
        for (float m=0.0; m<iterations; m+=1.0) {
            if (m>=iteratorc) break;
           	mediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));
            lowp vec2 c3 = abs(r1.xy/l);
            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);
			mediump float g = l+c3.x*c3.x; //*1.047197551;
			l *= zoom;
            mediump float h = l-r-0.1;
            l = pow(l,powr)+0.1;
          	h = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636
            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;
            r1 += ray*h;
            ray*=0.99;
        }
        if (abs(r1.z)<depth+0.01) dist=r1+pos;
    }
    return dist;
}

// Function 1847
float distanceToGroundPlane(vec3 p) {
     return p.y+0.5;   
}

// Function 1848
float MapTailFlap(vec3 p, float mirrored)
{
  p.z+=0.3;
  pR(p.xz, rudderAngle*(-1.*mirrored)); 
  p.z-=0.3;

  float tailFlap =sdBox(p- vec3(0., -0.04, -.42), vec3(0.025, .45, .30));

  // tailFlap front cutout
  checkPos = p- vec3(0., 0., 1.15);
  pR(checkPos.yz, 1.32);
  tailFlap=max(tailFlap, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));

  // tailFlap rear cutout
  checkPos = p- vec3(0., 0, -2.75);  
  pR(checkPos.yz, -0.15);
  tailFlap=fOpIntersectionRound(tailFlap, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);

  checkPos = p- vec3(0., 0., -.65);
  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.25, 0), vec3(0.06, 0.05, 0.15)));
  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.10, 0), vec3(0.06, 0.05, 0.15)));

  return tailFlap;
}

// Function 1849
intersection_info 	scene(ray r,float ignore_obj, float exit_value)
{
    intersection_info inf;
    inf.dist_id = vec2(INF,ignore_obj);
    
    //spheres
    if(intersect_sphere(inf,1.0,r.point,r.dir,vec3(-4.0,5.5,0.0),3.0) > exit_value) return inf;
    if(intersect_sphere(inf,2.0,r.point,r.dir,vec3(-4.0,12.0,0.0),2.0) > exit_value) return inf;
    
    //boxes
    if(intersect_box(inf,3.0,r.point,r.dir,vec3(-70.0),vec3(70.0,70.0,-2.0)) > exit_value) return inf;
    if(intersect_box(inf,4.0,r.point,r.dir,vec3(-3.0,-4.0,-2.0),vec3(2.0,2.0,5.0)) > exit_value) return inf;
    if(intersect_box(inf,5.0,r.point,r.dir,vec3(-4.2,-3.5,1.0),vec3(-3.0,-2.5,4.0)) > exit_value) return inf;
    if(intersect_box(inf,6.0,r.point,r.dir,vec3(-3.0,2.0,-4.0),vec3(-2.0,3.5,0.0)) > exit_value) return inf;
    
    if(intersect_box(inf,7.0,r.point,r.dir,vec3(7.0,4.0,-4.0),vec3(9.0,9.0,1.0)) > exit_value) return inf;
    if(intersect_box(inf,8.0,r.point,r.dir,vec3(7.0,-4.0,-1.5),vec3(12.0,0.0,2.0)) > exit_value) return inf;
    
    if(intersect_box(inf,9.0,r.point,r.dir,vec3(12.0,12.0,-4.0),vec3(13.0,13.0,10.0)) > exit_value) return inf;
    
    if(intersect_box(inf,10.0,r.point,r.dir,vec3(-30.0,-30.0,-4.0),vec3(30.0,-13.0,5.0)) > exit_value) return inf;
    
    
    
    return inf;
}

// Function 1850
vec3 normap(vec3 nor,vec3 pos,float i)
{
    if(i==1.)
        return normalize(nor+.1*vec3(fbm(40.*pos),fbm(40.*pos+10.),fbm(40.*pos+20.)));
    if(i==2.)
        return  normalize(nor+.15*texture(iChannel1,vec2(pos.y+pos.x,atan(pos.x,pos.z))).rgb);
    if(i==3.)
        return normalize(nor+.25*texture(iChannel1,vec2(pos.y+pos.x,atan(pos.x,pos.z))).rgb);
    if(i==4.)
        return normalize(nor+.2*vec3(fbm(20.*pos),fbm(20.*pos+10.),fbm(20.*pos+20.)));
    if(i==5.)
        return normalize(nor+.3*cos(200.*pos)*cos(200.*pos)); 
    return nor;
}

// Function 1851
float blobDistance(vec3 p){
    
    float distance = 9999.9;
    const float blobRad = 0.09;
    
    hardAdd(distance, obj_ball(p, objCenter+blobBallPos(0.0), blobRad) );
    for(float i=1.0; i<8.0; i+=1.0){
    	smoothAdd(distance, obj_ball(p, objCenter+blobBallPos(i), blobRad) , 0.08);
    }
    
    
    
    
    
    
    return distance;
    
}

// Function 1852
float Tonemapping(float x ){    
    float calc;
    calc = ((x*(shoulderStrenght*x + linearAngle*linearStrenght) + toeStrenght*toeNumerator)/(x*(shoulderStrenght*x+linearStrenght)+toeStrenght* toeDenominator))- toeNumerator/ toeDenominator;                        
    return calc;    
}

// Function 1853
vec4 map( in vec3 p )
{
    vec4 d1 = vec4( sdSeaBed(p), 0.0 );
	vec4 d2 = vec4( sdFish(p), 1.0 ); 
    return (d2.x<d1.x)?d2:d1;
}

// Function 1854
float dist_field( vec3 pos ) {
	// ...add objects here...
	
	// object 0 : sphere
	//float d0 = dist_sphere( pos, 2.6 );
	
	// object 1 : cube
	float d1 = dist_box( pos, vec3( 2.0 ) * boxSize );
		/*
    float d2 = dist_plan( pos, vec4(-camd.xyz,0.0));
    d2 += smoothstep(0.1,0.5,sin(d1*4.0-iTime*0.4));
    
    
    float d2b = dist_plan( pos, vec4(-camd.xyz,0.0));
    d2b += smoothstep(0.1,0.5,sin(d1*4.0-iTime*0.4))*0.9;
    
    
    float dband = max(d2,d2b);
	// union     : min( d0,  d1 )
	// intersect : max( d0,  d1 )
	// subtract  : max( d1, -d0 )
	return min(d1, d2);
*/
    return d1;//max(d1,-d0);
}

// Function 1855
vec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){
	float depth = start;
	vec3 pos = eye;
    for(int i = 0; i < 255; i++){
        vec3 pos = eye + depth * marchingDirection;
        //if(pos.y >= 30.) break;
    	float dist = SceneSDF(pos);
        if( dist <= EPSILON){
            return vec4(pos,depth);
        }
        depth += dist;
        if(depth >= end){
            pos = eye + depth * marchingDirection;
        	return vec4(pos,end);
        }
    }
    return vec4(pos,end);
}

// Function 1856
vec2 map(vec3 p){
  vec2 d = vec2(10e3);
  

  
  float tMod = mpow(sin(iTime*0.2),5.);
  
  for (float i = 0.; i < 7.; i++) {
    p.x -= 2. + ( smoothstep(1.,0.,iTime*0.1) * 5.  ) ; // TODO: smoothstep this from beggining of shader
    
    p.y -= 0.7;
    
    p.xy *= rot(0.6*pi + timeMod());
    p.zy *= rot(0.3*pi );
    p = abs(p);
    
  }
  
  
  d = dmin(d, sdMainGeom(p));
 
  return d;
}

// Function 1857
float map( in vec3 p )
{
    float plane = p.y + 0.5 + 0.025*(sin(p.x*10.0+sin(p.z*14.0))+cos(p.z*10.0+sin(p.x*20.0)));
    plane = max(plane, length(p + vec3(0.0,0.5,0.0)) - 3.0);
    
    float d1 = length(p) - size;
    
    float d2 = max(p.y + p.x/2.0, p.y - p.x/2.0);
    
    float d3 = length(p) - size * 0.85;
    
    float d4 = length(p - vec3(0.0, 0.25*cos(iTime)-0.25, 0.0)) - size * 0.25*cos(iTime*1.2);

    float hem = max(d1,d2);
    
    float bow = max(hem, -d3);
    
    float metabowl = smin(d4, bow, 8.0);
    metabowl *= 0.5;
    
    return min(metabowl, plane);
}

// Function 1858
vec3 SampleNormalMap(in vec2 uv, in float height)
{
    const float strength = 40.0;    
    float d0 = SampleTexture(uv.xy);
    float dX = SampleTexture(uv.xy - vec2(EPSILON, 0.0));
    float dY = SampleTexture(uv.xy - vec2(0.0, EPSILON));
    return normalize(vec3((dX - d0) * strength, (dY - d0) * strength, 1.0));
}

// Function 1859
vec2 mapBlocks(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations
	vec2 res = vec2(OBJ_SHORTBLOCK, sdBox(rotateY(p + vec3(-186, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5)));
	vec2 obj1 = vec2(OBJ_TALLBLOCK, sdBox(rotateY(p + vec3(-368.5, -165, -351.5), -0.30072115), vec3(87.02012, 165, 83.6675)));
	if (obj1.y < res.y) res = obj1;
	return res;
}

// Function 1860
float fogmap(in vec3 p, in float d)
{
    p.x += time*1.5;
    p.z += sin(p.x*.5);
    return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,.7,p.y));
}

// Function 1861
vec3 GetSceneNormal(const in vec3 vPos)
{
    const float fDelta = 0.001;

    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);
    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);
    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);
	
    vec3 vOffset1 = vDir1 * fDelta;
    vec3 vOffset2 = vDir2 * fDelta;
    vec3 vOffset3 = vDir3 * fDelta;

    vec3 vPos1 = vPos + vOffset1;
    vec3 vPos2 = vPos + vOffset2;
    vec3 vPos3 = vPos + vOffset3;
 
    float f1 = GetSceneDistance( vPos1 );
    float f2 = GetSceneDistance( vPos2 );
    float f3 = GetSceneDistance( vPos3 );
    
    vPos1.y -= f1;
    vPos2.y -= f2;
    vPos3.y -= f3;
    
    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );
    
    return normalize( vNormal );
}

// Function 1862
vec2 map( in vec4 pos ) {
                vec2 res = vec2(99999.,0);
            
                 #ifdef DRAWAXES
                 //	pos.xy *= mat2(c2,-s2,s2,c2);
                 	
                 	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(10.,0.,0.,0.), 0.05  ), 31.9 ) );
                 	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,10.,0.,0.), 0.05  ), 41.9 ) );
                 	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,10.,0.), 0.05  ), 51.9 ) );
                 	res = opU( res, vec2( sdCapsule(   pos,vec4(0), vec4(0.,0.,0.,10.), 0.05  ), 61.9 ) );
                 #else
                 	res = vec2(sdPlane(pos),1.);
                 #endif
                 
                    res = opU( res, vec2(sdCubicalCylinder(pos-vec4(-.5,.3, -.8, .1), vec3(.2,.3,.2)), 60.9 ) );
                    res = opU( res, vec2(sdDuoCylinder( pos-vec4(-.2,.3, -.2, -.1), vec2(.2,.3) ), 53.9 ) );
                    
                    
            	    res = opU( res, vec2( sdTesseract(       pos-vec4( 1.0,0.25, 0.1, 0.2), vec4(0.25) ), 3.0 ) );
                    
            	    res = opU( res, vec2( sdCapsule(   pos,vec4(-1.3,0.20,-0.1, -.3), vec4(-1.0,0.20,0.2,1.5), 0.1  ), 31.9 ) );
            	    res = opU( res, vec2( sdCylinder(  pos-vec4( 1.0,0.30,-1.0, -.5), vec2(0.1,0.2) ), 4.0 ) );
            	//res = opU( res, vec2( sdCone(      pos-vec4( 1.0,0.30,-1.0, 0.10), vec2(0.1,0.4) ), 4.0 ) );
            	
            	
            	vec4 posPeriodicSphere=pos; 
                 float d=2.0;
                 posPeriodicSphere.w = mod(pos.w,d)-.5*d;
                  res = opU( res, vec2( sdSphere(posPeriodicSphere-vec4( 0.0,0.25, 0.0, 0.25), 0.25 ), 46.9 ) );
              //  res = opU( res, vec2( sdEllipsoid(pos-vec4( 0.0,0.25, 0.0, 0.25), vec4(.25,.1,.15,.3) ), 46.9 ) );
              
                vec4 posPeriodicRoundTesseract=pos; 
                   
                   posPeriodicRoundTesseract = mod(pos,d)-.5*d;
                    res = opU( res, vec2( udRoundTesseract(  posPeriodicRoundTesseract-vec4( 1.0,0.25, 1.0, 0.0), vec4(0.15), 0.1 ), 41.0 ) );
                    
            	     return res;
            }

// Function 1863
float sdf_line2(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AP = uv - vert_A;      // Displacement vector from vert_A to our current pixel!
    vec2 dvec_AB = vert_B - vert_A;  // Displacement vector from vert_A to vert_B
    // The vector-projection of vector X to vector Y is a scalar multiple of vector Y.
    vec2 vector_projection_AP_AB = dvec_AB * (dot(dvec_AP, dvec_AB) / dot(dvec_AB, dvec_AB));
    vec2 dvec_uv_vproj_AP_AB = uv - vector_projection_AP_AB;
    return sign(dvec_uv_vproj_AP_AB.x * dvec_AB.y) * length(dvec_uv_vproj_AP_AB);  // This is the (signed) distance!
}

// Function 1864
float groundDistance(vec3 p, inout int material){
    
    float distance = 9999.9;
    material = 0;
    
    
    
    hardAdd(material,distance,1,
    	obj_box(p, vec3(0.0,-50.0,-23.0),
		vec3(70.0,50.0,55.0),
		40.0) );
    
    smoothAdd(distance,
		obj_box(p, vec3(0.0,-12.0,-75.0),
        vec3(58.0,32.0,36.0),
        30.0), 30.0 );
    
    smoothAdd(distance,
        obj_box(p, vec3(0.0,roadGroundY-20.0,64.0),
        vec3(roadW,20.0,100.0),
        20.0), 15.0 );
    
    distance += sin( p.x*0.4 + sin(p.x*0.2) + sin(p.z*0.5)*0.75 )*0.2;
    distance += sin( p.z*0.4 + sin(p.z*0.2) + sin(p.x*0.5)*0.75 )*0.2;
    
    smoothSubtract(distance,
		obj_box(p, vec3(0.0,roadGroundY+4.9,roadZ),
        vec3(roadW,6.0,12.0),
        4.0), 1.0 );
    
    hardAdd(material,distance,3,
    	obj_box(p, vec3(0.0,roadGroundY-3.1,roadZ),
        vec3(roadW,2.1,12.0),
        0.0) );
    
    
    
    
    
    return distance;
    
}

// Function 1865
float sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)
{
    vec2 dir0 = p1 - p0;
	vec2 dir1 = coord - p0;
	float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);
	return (length(dir1 - dir0 * h) - width * 0.5);
}

// Function 1866
float map(in vec3 pos)
{
	return length(pos)-1.;   
}

// Function 1867
vec2 grassDistr( in vec2 pos )
{
	float f = fbm( pos );
    return vec2( smoothstep( 0.45, 0.55, f ), smoothstep(0.4, 0.75, f) );
}

// Function 1868
vec4 findQuarticMinDistance(vec3 Q, float offset, float fYDirectionDevisor, float cylinderRadius, vec3 rd, vec3 ro)
{
	rd.y /= fYDirectionDevisor;
	ro.y += fYDirectionDevisor * 0.5;
	ro.y -= offset;
	ro.y /= fYDirectionDevisor;
	float near;
	float far;
	findCylinderNearFar(ro, rd, cylinderRadius + 1e-3, vec2(-1e-3, 1. + 1e-3), near, far);
	if (far < 1e-3 || near > far)
	{
		return vec4(0.,0.,0.,1e5);
	}
	near = max(0., near);
	ro += rd * near;
	// Equation solution here: perbloksgaard.dk/research/RayDistanceToBezierCylinder.jpg
	float A = Q.x * Q.x * rd.y * rd.y * rd.y * rd.y;
	float B = 2. * Q.x * rd.y * rd.y * rd.y * (2. * Q.x * ro.y + Q.y);
	float C = rd.y * rd.y * (6. * Q.x * ro.y * (Q.x * ro.y + Q.y) + 2. * Q.x * Q.z + Q.y * Q.y) - rd.x * rd.x - rd.z * rd.z;
	float D = rd.y * (ro.y * (Q.x * (4. * Q.x * ro.y * ro.y + 6. * Q.y * ro.y + 4. * Q.z) + 2. * Q.y * Q.y) + 2. * Q.y * Q.z) - 2. * (rd.x * ro.x + rd.z * ro.z);
	float E = ro.y * (Q.x * ro.y * (Q.x * ro.y * ro.y + 2. * Q.y * ro.y + 2. * Q.z) + Q.y * (Q.y * ro.y + 2. * Q.z)) + Q.z * Q.z - ro.x * ro.x - ro.z * ro.z;
	vec4 roots = findQuarticRoots(vec4(D, C, B, A) / E);
	float l = 1. / max(roots.x, max(roots.y, max(roots.z, roots.w)));
	if ((l > 1e-3) && l < (far - near))
	{
		vec3 w = ro + rd * l;
		vec3 q = vec3(normalize(w.xz) * (Q.y + Q.x * w.y * 2.), 1.);
		return vec4(vec3(w.x*q.z,-w.x*q.x-w.z*q.y, w.z*q.z), near + l);
	}
	return vec4(0.,0.,0.,1e5);
}

// Function 1869
vec4 boxmap( sampler2D sam, in vec3 p, in vec3 n )
{
    vec3 m = n*n; m=m*m; m=m*m;
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 1870
float dstScene(vec3 p) {
    
    vec3 pos = vec3(0.,.25,0.);
   	vec3 r = pos - p;
    float a = length(r) - 1.;
    
    r.yz = rot2D(r.yz, 45.);
    vec2 t = vec2(.75,.2);
    vec2 q  = vec2(length(r.xz) - t.x, r.y);
    float b = length(q) - t.y;
    
    float d = abs(sin(iTime * .75));
    if(iMouse.z > 0.) d = iMouse.y/iResolution.y;
    float f = mix(a, b, d);
    
    float tm = iTime;
    if(iMouse.z > 0.) tm = (iMouse.x/iResolution.x)*5.;
    
    pos = vec3(sin(tm), cos(tm * .5) * .5, 0.);
    f = smin(f, length(max(abs(pos - p) - vec3(.3),0.)) - .25, .8);
    f = min(f, p.y + 1.);
    
    return f;
    
}

// Function 1871
void initScene(out Sphere[numSpheres] spheres, out Box[numBoxes] boxes){
    
    spheres[0] = newSphere(vec3(0.0, 0.0, 200.0), 10.0, vec3(1.0, 0.1, 0.1), true, true);
    spheres[1] = newSphere(vec3(20.0, 0.0, 200.0), 5.0, vec3(0.1, 1.0, 0.1), true, true);
    spheres[2] = newSphere(vec3(-20.0, 0.0, 200.0), 5.0, vec3(0.1, 0.1, 1.0), true, true);
    spheres[3] = newSphere(vec3(0.0, 20.0, 200.0), 5.0, vec3(0.5, 0.5, 0.5), true, true);
    spheres[4] = newSphere(vec3(0.0, -20.0, 200.0), 5.0, vec3(1.0, 1.1, 0.1), true, true);
    spheres[5] = newSphere(vec3(sin(iTime) * 39.0, cos(iTime) * 39.0, 180.0), 1.0, vec3(1.0, 1.0, 1.0), false, false);
    spheres[6] = newSphere(vec3(sin(iTime) * 39.0, 0.0, 180.0 + cos(iTime) * 39.0), 1.0, vec3(1.0, 1.0, 1.0), false, false);
    
    boxes[0] = newBox(vec3(0.0, -50.0, 0.0), vec3(500.0, 10.0, 500.0), vec3(0.4, 1.0, 0.4), true, true);
    boxes[1] = newBox(vec3(0.0, -35, 200.0), vec3(10.0, 5, 10.0), vec3(1, 1, 1), true, true);
    boxes[2] = newBox(vec3 (sin(iTime * 1.2) * 50.0, -30, (cos(iTime * 2.4) * 50.0) + 200.0), vec3(5.0, 10.0, 5.0), vec3(1.0, 0.1, 0.75), true, true);
}

// Function 1872
vec3 tonemapReinhard(vec3 color, float exposure)
{
    color *= exposure * 1.5;
    
    float L = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
    float tonemapped = (L * (1.0 + L / (2.2 * 2.2))) / (L + 1.0);
    
    color *= tonemapped / L;
    return pow(color, vec3(1.0 / 2.2));
}

// Function 1873
float o354278_input_sdf_a(vec3 p) {
vec3 o354283_0_1_color3d = vec3(o354283_fct(((p)).xyz));

vec3 n=normal_o354282((p));
float o354282_0_in = o354282_input_in1((p)+((n*(o354283_0_1_color3d-0.5))*0.134000000));float o354282_0_1_sdf3d = max(o354282_input_in1((p))-0.134000000,o354282_0_in/((0.134000000+0.2)*10.0));

return o354282_0_1_sdf3d;
}

// Function 1874
vec2 mapTerrainH( vec3 p )
{
    float h = -2.5;
    h -= 1.5*sin( 5.0 + 0.2*p.z);
    h += 1.5*sin( 0.0 - 0.05*p.x - 0.05*p.z);
    float g = h;
    h += 0.1*(textureLod( iChannel0, 0.1*p.xz, 0.0 ).x);

    float d1 = 0.2*(p.y-h);
        
    vec2 res = vec2( d1, 1.0 );
    
#if 1   
    if( -p.z>11.0 )
    {
    float ss = 4.0;
    vec3 q = p;
    vec2 id = floor( (q.xz+0.5*ss)/ss );
    q.xz = mod( q.xz+0.5*ss, ss ) - 0.5*ss;
    

    float r1 = hash(121.11*id.x+id.y*117.4);
    float r2 = hash( 71.72*id.x+id.y* 61.9);
    float r3 = hash( 31.74*id.x+id.y*317.1);
    mat4 rm = matRotate( vec3(1.0*r1,313.13*r2,0.2) );
    
    vec3 r = (rm*vec4(q,0.0)).xyz;
    r.y -= g + 0.25;
    
    float d2 = 0.8*udRoundBox( r, vec3(2.,0.01+0.2*r3,0.1+0.5*r3), 0.002 );
    res.x = min( d1, d2 );
    }
#endif
        
    return res;
}

// Function 1875
float map( vec3 p )
{
    return length(p) - 1.0;
}

// Function 1876
vec4 map( vec3 p )
{
	vec3 q = vec3( abs(p.x), p.yz );

    // head and body
	float d1;
    d1 =          sdSegment(     vec3(0.0,1.8,0.0), vec3(0.0,0.7,0.0), p ).x - 0.5;
    d1 = opU( d1, sdCone(      p-vec3(0.0,2.8,0.0), vec3( normalize(vec2(0.9,0.1)), 0.5 ) ) );
    d1 = opS( d1, sdCylinder( (p-vec3(0.0,1.0,0.4)).zxy, vec2(0.2,1.0) ) );
    d1 = opU( d1, sdCylinder( (p-vec3(0.0,-0.32,0.0)), vec2(0.93,0.7) ) );
    d1 = opU( d1, sdCone(     (p-vec3(2.2,1.7,1.0))*vec3(1.0,-1.0,-1.0), vec3( normalize(vec2(0.8,0.4)), 0.5 ) ) );
    
    // neck and fingers    
    vec3 d3;
    d3 =          vec3( udRoundBox( p-vec3(0.0,1.55,0.30), vec3(0.35,0.1,0.3)-0.03, 0.12 ), 1.0, 5.0 );
    d3 = opS( d3, vec3( udRoundBox( p-vec3(0.0,1.55,0.35), vec3(0.35,0.1,0.5)-0.04, 0.10 ), 0.0, 5.0) );
    d3 = opU( d3, vec3( sdCone(     p-vec3(0.0,1.08,0.00), vec3(0.60,0.8,0.7) ), 1.0, 6.0) );
    d3 = opU( d3, vec3( sdSphere(   p-vec3(0.0,2.70,0.00), 0.08 ), 1.0, 7.0) );
    d3 = opU( d3, vec3( sdSphere(   p-vec3(0.0,2.20,0.00), 0.15 ), 1.0, 8.0) );
    d3 = opU( d3, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.2,2.35,0.8), q ).x - 0.08, 0.8,  9.0) );
	d3 = opU( d3, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.4,2.35,1.2), q ).x - 0.08, 0.8, 10.0) );
	d3 = opU( d3, vec3( sdSegment( vec3(2.2,2.10,1.0), vec3(2.0,2.35,1.2), q ).x - 0.08, 0.8, 11.0) );
    d3 = opU( d3, vec3( sdSegment( vec3(2.2,2.35,0.8), vec3(2.2,2.40,0.8), q ).x - 0.08, 0.8,  9.0) );
	d3 = opU( d3, vec3( sdSegment( vec3(2.4,2.35,1.2), vec3(2.4,2.50,1.1), q ).x - 0.08, 0.8, 10.0) );
	d3 = opU( d3, vec3( sdSegment( vec3(2.0,2.35,1.2), vec3(2.0,2.50,1.1), q ).x - 0.08, 0.8, 11.0) );

    // eyes and mouth
    vec3 d2;
    d2 =          vec3( sdSphere(   p-vec3( 0.18,1.55,0.48), 0.18           ), 1.0, 12.0 );
    d2 = opU( d2, vec3( sdSphere(   p-vec3(-0.18,1.55,0.48), 0.18           ), 1.0, 13.0 ) );
    d2 = opU( d2, vec3( sdCylinder( p-vec3( 0.00,1.00,0.00), vec2(0.47,0.4) ), 1.0, 14.0 ) );

    // arms
    vec3 d4;
    d4 =          vec3( sdSphere( q-vec3( 0.88,0.15,0.0), 0.19 ), 0.0, 15.0 );
    d4 = opU( d4, vec3( sdBezier( vec3(0.9,0.15,0.0), vec3(2.0,-0.5,0.0), vec3(2.2,2.0,1.0), q, 0.13 ), 16.0) );
    
    vec4             res = vec4( d1,  1.0, 0.0, 0.0 );
    if( d2.x<res.x ) res = vec4( d2.x,2.0, d2.yz );
    if( d3.x<res.x ) res = vec4( d3.x,3.0, d3.yz );
    if( d4.x<res.x ) res = vec4( d4.x,0.0, d4.yz );


    return res;
}

// Function 1877
vec3 map( vec3 p )
{
    // --- Exported by RaySupremeDF.com
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    vec3 gResult1, gResult2;
    gResult1 = vec3( 1000000, -2, -1 );
    tp=p;
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 399.741, 399.741, 399.741 ), 0.0 ) ) - 0.259, 0, 0 ) );
    tp=p;
    tp.y = tp.y + -19.0000;
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 84.000, 3.000, 3.000 ), 0.0 ) ) - 16.000);
    res=opU( res, gResult1 );
    tp=p;
    tp = tp + vec3(-2.0000,-2.0000,-4.0000);
    res=opU( res, vec3( length( tp ) - 1.000, 1, 3 ) );
    tp=p;
    tp = tp + vec3(4.0000,-1.5000,-4.0000);
    res=opU( res, vec3( length( tp ) - 0.300, 1, 4 ) );
    gResult1 = vec3( 1000000, -2, -1 );
    gResult2 = vec3( 1000000, -2, -1 );
    tp=p;
    tp.x = tp.x + -0.3542;
    tp /= vec3( 1.300, 1.300, 1.300 );
    gResult2=opU( gResult2, vec3( sdCylinder( tp, vec2( 1.000, 0.030) ), 3, 5 ) );
    tp=p;
    tp.xy = tp.xy + vec2(-0.3542,-0.1300);
    tp /= vec3( 1.300, 1.300, 1.300 );
#if (DISPLACEMENT == 1)
    vec3 bumpNormal; Material bumpMaterial;
    material0( p, bumpNormal, 0., bumpMaterial );   
    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) )- bumpMaterial.bump/50., 2, 6 ), 16.7396 );
 #else
    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) ), 2, 6 ), 16.7396 );    
 #endif
    tp=p;
    tp.xy = tp.xy + vec2(-0.3542,-0.1560);
    tp /= vec3( 1.300, 1.300, 1.300 );
    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.700, 0.040) ));
    gResult1=opU( gResult1, gResult2 );
    gResult2 = vec3( 1000000, -2, -1 );
    tp=p;
    mat=mat4(0.3323,-0.1160,-0.9360,0.0000
    ,0.3295,0.9442,0.0000,0.0000
    ,0.8838,-0.3084,0.3519,0.0000
    ,-0.4378,-0.8764,0.3315,1.0000);
    tp=(mat * vec4(tp, 1.0)).xyz;
    tp /= vec3( 1.495, 1.495, 1.495 );
#if (DISPLACEMENT == 1)    
    material0( p, bumpNormal, 0., bumpMaterial );
    gResult2=opU( gResult2, vec3( length( tp ) - 0.600- bumpMaterial.bump/50., 2, 9 ) );
#else
    gResult2=opU( gResult2, vec3( length( tp ) - 0.600, 2, 9 ) );
#endif
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.3472,-1.4950,-2.3441);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, length( tp ) - 1.280);
    tp=p;
    mat=mat4(0.8400,0.0942,-0.5344,0.0000
    ,-0.0000,0.9848,0.1736,0.0000
    ,0.5426,-0.1459,0.8272,0.0000
    ,-0.2975,-0.9904,0.0205,1.0000);
    tp=(mat * vec4(tp, 1.0)).xyz;
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.630, 0.030) ));
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.2975,-0.9717,0.1922);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, length( tp ) - 0.550);
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.2975,-0.9717,0.1922);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2=opU( gResult2, vec3( length( tp ) - 0.520, 0, 13 ) );
    gResult1=opU( gResult1, gResult2 );
    res=opU( res, gResult1 );
    return res;
}

// Function 1878
float DistanceToBoxBack(in vec3 dir, out int side)
{ 
    
	// Don't need 'tmax' as we're inside the box looking for the back.
	vec3 invDir = 40.0/dir;

	float tx1 = (-40. - dir.x)*invDir.x;
	float tx2 = ( 40. - dir.x)*invDir.x;
	float tmin = min(tx1, tx2); side =1;
	
	float ty1 = (-40. - dir.y)*invDir.y;
	float ty2 = ( 40. - dir.y)*invDir.y;
    
    float m =  min(ty1, ty2);
	if (tmin < m)
    	{tmin = m; side = 2;}
        

	float tz1 = (-40. - dir.z)*invDir.z;
	float tz2 = (40. - dir.z)*invDir.z;
	m = min(tz1, tz2);
   	if (tmin < m)
	    {tmin =  m; side = 0;}

	return tmin;
}

// Function 1879
float opRepLimitCenter_sceneT(vec3 p,vec3 c,vec3 lim)
{
    vec3 lm1 = lim-vec3(1.0);
    p += c*.5*lm1;
    vec3 q;
	q = min(p,mod(p+.5*c,c)-.5*c); // less than 0
    q = max(q,p-(lim-vec3(1.0))*c); // more than limit
    return sceneT(q);
}

// Function 1880
HD map(f3 p)
{
    f4 noiseVec = fbmd(p * 2.);
    f4 noiseVec2 = fbmd(p * 5.);
    HD scene;
    scene.D = 50.;
    f3 p0 = p - f3(0., -1.4, -4.),p1,ap,neckp,e2p,hp,eyp;
    p0.xy = mul(p0.xy, rot(-0.85));

    /* ================ */
    /* =Feto Ingeniero= */
    /* ================ */
    p1 = p0 + f3(0.1, 0.1, 0);
    f1 fetoSDF = LN(p1 - f3(0, 0.3, 0)) - 0.25,fetoEyesSDF,fetoSphereSDF,alienHeadSDF,
    alienHeadBlend,alienEyesHolesSDF,alienEyesHolesSDF2,alienHandSDF,alienEyesSDF;
    fetoSDF = smin(fetoSDF, LN(p1 - f3(0.1, 0.3, 0)) - 0.25, 0.1);
    fetoSDF = smin(fetoSDF, LN(p1 - f3(-0.1, 0.12, 0)) - 0.2, 0.1);
    //fetoSDF = smin(fetoSDF, LN(p1 - f3(-0.12, 0.0, 0)) - 0.15, 0.1);
    fetoSDF = smin(fetoSDF, LN(p1 - f3(-0.04, -0.1, 0)) - 0.15, 0.2);
    fetoSDF = smin(fetoSDF, LN(p1 - f3(0.1, -0.2, 0)) - 0.23, 0.2);
    //fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, -0.19), f3(0, 0, 0), f3(0.15, 0.1, -0.1), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, -0.19) - f3(0.15, 0.1, -0.1), f3(0, 0, 0), f3(0.10, -0.1, 0.0), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, -0.19) - f3(0.15, 0.1, -0.1) - f3(0.10, -0.1, 0.0), f3(0, 0, 0), f3(0.05, 0.05, 0.0), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, 0.19), f3(0, 0, 0), f3(0.15, 0.1, 0.1), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, 0.19) - f3(0.15, 0.1, 0.1), f3(0, 0, 0), f3(0.10, -0.1, 0.0), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(0.1, -0.24, 0.19) - f3(0.15, 0.1, 0.1) - f3(0.10, -0.1, 0.0), f3(0, 0, 0), f3(0.05, 0.05, 0.0), 0.05), 0.03);
   //fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(-0, -0.01, -0.19), f3(0, 0, 0), f3(0.1, -0.03, -0.1), 0.05), 0.03);
   // fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(-0, -0.01, -0.19)-f3(0.1, -0.03, -0.1), f3(0, 0, 0), f3(0.15, 0.03, 0.05), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(-0, -0.01, 0.19), f3(0, 0, 0), f3(0.1, -0.03, 0.1), 0.05), 0.03);
    fetoSDF = smin(fetoSDF, sdCapsule(p1 - f3(-0, -0.01, 0.19)-f3(0.1, -0.03, 0.1), f3(0, 0, 0), f3(0.15, 0.03, -0.05), 0.05), 0.03);
    fetoEyesSDF = LN(abs(p1 - f3(0.18, 0.14, 0)) - f3(0, 0, 0.18)) - 0.02;
    fetoEyesSDF = M(fetoEyesSDF, LN(abs(p1 - f3(0.12, 0.14, 0)) - f3(0, 0, 0.2)) - 0.02);
    fetoEyesSDF = M(fetoEyesSDF, LN(abs(p1 - f3(0.15, 0.17, 0)) - f3(0, 0, 0.22)) - 0.02);
    HD fetoInner = HD( fetoSDF+0.08, f3(1.1, 0.1, 0.1)*0.5, 0., 0., 0., 0., 0., false );
    HD feto = HD( (abs(fetoSDF)-0.005)*0.5, f3(1, 0.8, .8)*1.2, 0., 0., 0.7, 1.2, 150., false );
    HD fetoEyes = HD( fetoEyesSDF, f3(1, 0.8, 0.8)*1.9, 0., 0., 0.0, 0.0, 0., true );
    scene = opUnion(scene, fetoInner);
    scene = opUnion(scene, feto);
    scene = opUnion(scene, fetoEyes);
    /* ================ */

    /* ================ */
    /* = Feto Esfera == */
    /* ================ */
    fetoSphereSDF = length(p0) - 0.76;
    HD fetoSphere = HD( (abs(fetoSphereSDF) - 0.01)*0.5, f3(0.93, .9, 1)*1.2, 1., 1000., 0.8, 1.3, 9000., false );
    scene = opUnion(scene, fetoSphere);
    /* ================ */

    /* ================ */
    /* == Alien Head == */
    /* ================ */
    ap = p * f3(1, 0.8, 0.9);
    ap -= f3(0, 0, 0.8);
    ap.xy = mul(ap.xy, rot(0.4));
    alienHeadSDF = LN(ap) - 2.;
    alienHeadBlend = 0.8;
    alienHeadSDF = smin(alienHeadSDF, LN((abs(ap) - f3(1.7, 0, 0))*f3(0.9, 1, 1.8)) - 0.5, 0.1);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, LN((abs(ap-f3(0, 0, -0.1)) - f3(2.0, 0, 0))*f3(0.2,1,1.2)) - 0.2, 0.1);
    alienHeadSDF = smin(alienHeadSDF, LN((ap + f3(0, 1.9, 1.1)) * f3(0.8, 1, 1)) - 0.6, alienHeadBlend);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, (LN(abs(ap + f3(0, 2.2, 0.6)) - f3(2.5, 0, 0)) - 1.6), 0.8);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, LN(ap + f3(0, 1.7,-1.6)) - 1.4, 0.8);
    neckp = ap;
    neckp.xy = mul(neckp.xy, rot(-0.6));
    float eyeHoleSize = 0.15;
    alienHeadSDF = smin(alienHeadSDF, sdCapsule(neckp - f3(0.9, 0, 0.5), f3(0, 0, 0), f3(0, -5, 1), 0.5), 1.5);
    alienEyesHolesSDF = LN(abs(ap - f3(0, -0.4, -1.6)) - f3(1, 0, 0)) - eyeHoleSize;
    alienEyesHolesSDF = M(alienEyesHolesSDF, LN((ap - f3(0.9, -0.7, -1.4)) - f3(0.2, 0, 0)) - eyeHoleSize);
    alienEyesHolesSDF = M(alienEyesHolesSDF, LN((ap - f3(0.55, -0.7, -1.67)) - f3(0.2, 0, 0)) - eyeHoleSize);
    alienEyesHolesSDF = M(alienEyesHolesSDF, LN((ap - f3(-1, -0.7, -1.67)) - f3(0.2, 0, 0)) - eyeHoleSize);
    alienEyesHolesSDF = M(alienEyesHolesSDF, LN((ap - f3(-1.3, -0.7, -1.4)) - f3(0.2, 0, 0)) - eyeHoleSize);
    alienEyesHolesSDF = fOpDifferenceRound(alienEyesHolesSDF, (alienEyesHolesSDF+.005), 0.1);
    alienHeadSDF = smin(alienHeadSDF, alienEyesHolesSDF, 0.1);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, (LN(abs(ap + f3(0, 1.6, 1.9))*f3(2.8,0.2,0.01)-f3(0.12, 0, 0)) - 0.1),0.05);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, (LN(abs(ap + f3(0, 1.65, 1.9))*f3(2.8,0.5,0.01)-f3(0.4, 0, 0)) - 0.1),0.2);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, (LN(abs(ap + f3(0, 1.7, 1.9))*f3(2.8,0.9,0.01)-f3(0.7, 0, 0)) - 0.1),0.2);
    
    e2p = f3(1, 1, 0.4);
    alienEyesHolesSDF2 = LN((abs(ap - f3(0, -0.4, -1.6)) - f3(1, 0, 0))*e2p) - eyeHoleSize;
    alienEyesHolesSDF2 = M(alienEyesHolesSDF2, LN(((ap - f3(0.9, -0.7, -1.4)) - f3(0.2, 0, 0))*e2p) - eyeHoleSize);
    alienEyesHolesSDF2 = M(alienEyesHolesSDF2, LN(((ap - f3(0.6, -0.7, -1.67)) - f3(0.2, 0, 0))*e2p) - eyeHoleSize);
    alienEyesHolesSDF2 = M(alienEyesHolesSDF2, LN(((ap - f3(-1, -0.7, -1.67)) - f3(0.2, 0, 0))*e2p) - eyeHoleSize);
    alienEyesHolesSDF2 = M(alienEyesHolesSDF2, LN(((ap - f3(-1.3, -0.7, -1.4)) - f3(0.2, 0, 0))*e2p) - eyeHoleSize);
    alienHeadSDF = fOpDifferenceRound(alienHeadSDF, alienEyesHolesSDF2, .1);

    hp = ap;
    hp.xy = mul(hp.xy, rot(-.4));
    hp -= f3(0, 0.1, -1);
    alienHandSDF = sdCapsule(hp - f3(0, -4, -4), f3(0, 0, .25), f3(0, .5, 0), .07);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(0, -4, -4) - f3(0, .7, 0), f3(0, 0, 0), f3(0, .5, 0), .07), .23);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(0, -4, -4) - f3(0, 1.4, 0), f3(0, 0, 0), f3(0, .5, .1), .07), .23);

    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(0.8, -4, -4), f3(-0.1, 0, 0.25), f3(0, .5, 0), .07), .23);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(0.8, -4, -4) - f3(0, 0.7, 0), f3(0, 0, 0), f3(0, .5, .1), .07), .23);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(0.8, -4, -4) - f3(0, 1.4, 0.1), f3(0, 0, 0), f3(0, .25, .5), .07), .23);
  
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(-.8, -4, -2.3), f3(-.1, 0, -.25), f3(0, .5, 0), .07), .23);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(-.8, -4, -2.3) - f3(0, .7, 0), f3(0, 0, 0), f3(0, .5, -.1), .07), .23);
    alienHandSDF = smin(alienHandSDF, sdCapsule(hp - f3(-.8, -4, -2.3) - f3(0, 1.4, -0.14), f3(0, 0, 0), f3(0, .25, -.2), .07), .23);

    HD alienHeadInner = HD( alienHeadSDF+.08, f3(0.8,1,0.8)*(.4-noiseVec2.y*.6), 0., 0., 0., 0., 0., false );
    HD alienHead = HD( (abs(alienHeadSDF-noiseVec.x*.08-noiseVec2.x*0.03) - .02) * .5,f3(1, 0.8, 0.75), .68, 1000., .75, 1.8, 0.5, false );
    scene = opUnion(scene, alienHeadInner);
    scene = opUnion(scene, alienHead);
    alienHeadInner.D = (alienHandSDF)+0.005;
    alienHead.D = abs(alienHandSDF-noiseVec.x*.08-noiseVec2.x*0.04) - 0.01;
    scene = opUnion(scene, alienHeadInner);
    scene = opUnion(scene, alienHead);
     /* ================ */

    /* ================ */
    /* == Alien Eyes == */
    eyp = p+f3(0, .2, -.64);
    eyp.xy = mul(eyp.xy, rot(.5));

    alienEyesSDF = LN((abs(eyp - f3(0, -.4, -1.6)) - f3(1, 0, 0))) - .16;
    alienEyesSDF = M(alienEyesSDF, LN(((eyp - f3(0.9, -0.7, -1.4)) - f3(.2, 0, 0))) - .16);
    alienEyesSDF = M(alienEyesSDF, LN(((eyp - f3(0.6, -0.7, -1.67)) - f3(.2, 0, 0))) - .16);
    alienEyesSDF = M(alienEyesSDF, LN(((eyp - f3(-1.1, -0.7, -1.67)) - f3(.2, 0, 0))) - .16);
    alienEyesSDF = M(alienEyesSDF, LN(((eyp - f3(-1.4, -0.67, -1.4)) - f3(.2, 0, 0))) - .16);
    HD alienEyesInner = HD( alienEyesSDF+.08, f3(0,0,0), 1., 1000., 0., 0., 0., false );
    HD alienEyes = HD( abs(alienEyesSDF)-.01, f3(1, 1, 1), 1., 1000., .8, 1.3, 10., false );
    scene = opUnion(scene, alienEyes);
    scene = opUnion(scene, alienEyesInner);
    /* ================ */
    
    /* ================ */
    /* ===== Light ==== */
    /* ================ */
    HD light = HD( sdBox((p) + f3(5, 5, 18), f3(10, 15, .1)), f3(1, 1, 1)*2.5, 0., 0., 0., 0., 0., true );
    HD light2 = HD( sdBox((p) + f3(-22, -10, -28), f3(25, 10, .1)), f3(1, .5, 1)*2., 0., 0., 0., 0., 0., true );
    scene = opUnion(scene, light);
    scene = opUnion(scene, light2);
    /* ================ */
    return scene;
}

// Function 1881
vec4 map( vec3 pos)
{
	return cubes(pos);
}

// Function 1882
float dist_func_floor(vec3 p)
{
	return dot(p,vec3(0.0,1.0,0.0))+1.0;
}

// Function 1883
float sdf(vec3 p, bool detail)
{
    vec3 oP = p;
    vec3 wP = p;
    
    pR(wP.xy, .714);
    p -= vec3(.0, -.2, .4);
    
    vec3 rightP = p;
    pR(rightP.xy, .6);
    float rightCloud = length(rightP - vec3(-.5, -1.1, 2.3)) - 1.15;
    rightCloud = min(rightCloud, length(rightP * vec3(1.0, 1.0, .45) - vec3(-.5, -1.5, 1.3)) - 1.45);
    
    
    float farClouds = length(p - vec3(6.5, 1., 0.5)) - 3.5;    
    farClouds = min(farClouds, length(p - vec3(4.0, 3.5, 0.5)) - 1.5); //
    
    // Left far
    farClouds = min(farClouds, length(p - vec3(3., 1.7, -5.5)) - 3.25);    
    farClouds = min(farClouds, length(p - vec3(.5, -.1, -5.5)) - 1.45);
    
    pR(p.yz, .1);
    float lowerClouds = p.y + 3.8 - smoothstep(-1.0, -5.0, p.z) * 3.5;
    
    vec2 index = pMod2(oP.xz, vec2(1.65));
    lowerClouds = min(lowerClouds, p.y + 1.5);
    
    float clouds = min(min(rightCloud, lowerClouds), farClouds);
    
    vec3 noiseScale = vec3(.65, 1.0, .85) * CLOUD_BASE_FREQ;
    vec4 noise = vec4(0.0);
    
    // Bound the noise
    if(detail && clouds < .06)
    {
        noise = WorleyFractal(wP * noiseScale, CLOUD_FREQ_RATIO, CLOUD_ITERATIONS);    
        noise = pow(noise, vec4(1.3));
    }
    
    return clouds + dot(noise, noise) * .06;
}

// Function 1884
float starSDF_old( vec3 point, vec3 center, float len, float thickness ) {
    const int count = 5;
    float d = RAY_MARCH_TOO_FAR;
    for ( int i = 0 ; i < count ; i++ ) {
        float angle = PI2 * float( i ) / float( count ) + PI2 / float ( count ) * 0.25;
        vec3 a = vec3( center.xy + TRIG(len, angle), center.z );
        float h = VECTOR_PROJECTION( a, center, point );
        vec3 q = a + ( center - a ) * h;
        h = pow( h, 0.7 ) * .8;
        d = min( d, length( point - q ) - thickness * h );
    }
    
    return d;
}

// Function 1885
float getDistance(vec3 rayPos, vec3 rayDir) {
	float rayDist = 0.0;
	float totalDist = 0.0;
	for (int i = 0; i < 64; i++) {
		rayDist = distanceField(rayPos);
		if (rayDist < 0.01) break;
		rayPos += rayDist * rayDir;
		totalDist += rayDist;
	}
	return totalDist;
}

// Function 1886
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(3./iResolution.y, 0); 
    
    float f = bumpFunction(p); // Hit point function sample.
    
    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.
    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.
    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.
    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.
    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 1887
float simpleBitmap(float data, float w, float h, vec2 bitCoord) {
    // 0..1.0
    float x = floor(bitCoord.x / (1.0 / w));
    float y = floor(bitCoord.y / (1.0 / h));
     
    float i = y * w + x;
    
    float datum = float(data) / pow(2.0, i);

    datum = mod(datum, 2.0);
        
    return floor(datum);
}

// Function 1888
void mainCubemap( out vec4 C, in vec2 U, in vec3 pos, in vec3 dir ){
    
    if(iFrame >= 3){
        C.rgb = texture(iChannel0,dir).rgb;
        return;
    }
    if(iFrame == 1){
        vec3 ro = vec3(100, 0.0, 400.0);
        C.rgb = render(vec3(ro.x,  terrainH( ro.xz) + 11.0*SC, ro.z),dir);
    }
    else if(iFrame == 2){
        vec3 axis = getAxis(dir);
        vec3 uv = GetUVW(axis,dir);
        vec3 MipDir = GetMipMapUVW_Dir2(uv,axis);
        float roughness = max((30.-ID)/ID_Range.z,0.);
        
        C.rgb = PrefilterEnvMap(roughness,MipDir);
    }
    
}

// Function 1889
float llamelMapSMin(const in float a,const in float b,const in float k){
    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);
}

// Function 1890
float distMap(vec3 r) {
    float cubeLen = length(max(abs(r)-maxSize,0.0));
    
    if (cubeLen <= prec) {
        vec3 rIn = r;
        rIn += texture(iChannel2,normalize(rIn)).xyz*6.0;
        return min(prec,length(max(abs(rIn)-size,0.0)));
    }
    
    return cubeLen;
}

// Function 1891
float map_obj(vec3 pos)
{
    float angle = mod(iTime*.2, 2.*pi);
    vec3 posr = vec3(pos.x*cos(angle) + pos.z*sin(angle), pos.y, pos.x*sin(angle) - pos.z*cos(angle));
    float theta = atan(posr.x, posr.z);
    hfh = smoothstep(0.15, 1.05, getBlurredTexture(vec2(theta, posr.y)/pi))*(1. - smoothstep(0.85, 1.38, abs(posr.y)));
    //hfh = getBlurredTexture(vec2(theta, posr.y)/pi);
    return length(pos) - 1.35 - 0.3*hfh;
    //return pow(1.1-sqrt(pow(posr.x, 2.)+pow(posr.y, 2.)), 2.) + pow(posr.z, 2.) - 0.05 - 0.27*hfh;
    //return length(pos) - 1.35;
}

// Function 1892
float sdf(vec3 p){
    float sphere = fractal(p);
    float plane = sdPlane(p, vec4(0,1,0, 2));
    return min(sphere, plane);
}

// Function 1893
float sceneOcclusion(vec3 point, vec3 normal, float worldTime) {
    float dist = 0.04;
    float occlusion = 1.0;
    for (int index = 0; index < 3; index += 1) {
        occlusion = min(occlusion, sceneDistance(point + dist * normal, worldTime) / dist);
        dist *= 0.8;
    }

    return max(occlusion, 0.05);
}

// Function 1894
float distFromSphere(Sphere s, vec3 p) {
 	return distance(repeat(p),s.position)-s.radius;  
}

// Function 1895
RMResult map(vec3 p)
{
    float d = FAR;
    float id = -1.;
    
    {// board
        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// knight
		p += vec3(1., 0., 1.);
        p.x = abs(p.x);
        // body
        vec3 p0 = rot(vec2(0., -0.32)) * (p - vec3(0., 0.25, 0.)) + vec3(0., 0., 0.15);
        float rx = 0.4 + 0.3 * smoothstep(0.4, -1., p0.y);
        float rz = 0.8 - 0.3 * smoothstep(-1., 1., p0.y);
        float d0 = sdEllipsoid(vec3(rx, 1.3, rz), p0);
        vec3 p1 = p - vec3(0., -1., 0.);
        float d1 = sdTorus(vec2(0.43, 0.5), p1);
        d1 = max(d1, -sdHPlane(0., p1));
        d0 = smin(d0, d1, 0.2);
        vec3 p2 = p - vec3(0., -0.45, 0.);
        float d2 = sdEllipsoid(vec3(0.66, 0.1, 0.78), p2);
        d0 = smin(d0, d2, 0.03);
        // head
        vec3 p3 = rot(vec2(0., 0.3)) * (p - vec3(0., 1.3, 0.));
        rx = 0.35 - 0.12 * smoothstep(-0.3, 0.5, p3.y);
        float d3 = sdEllipsoid(vec3(rx, 0.45, 0.75), p3);
        // head/chin
        d3 = smax(d3, -sdCappedCylinder(0.4, 0.25, (p3 - vec3(0., -0.42, 0.33)).yxz), 0.2);
        // head/mouth
        d3 = smax(d3, -sdCappedCylinder(0.4, 0.05, (p3 - vec3(0., 0., 0.7)).yxz), 0.1);
        d0 = smin(d0, d3, 0.15);
        // head/eyes
        vec3 p4 = p - vec3(0.23, 1.55, 0.);
        float d4 = sdEllipsoid(vec3(0.1, 0.05 + 0.04 * smoothstep(0.1, -0.1, p4.z), 0.1), p4);
        d0 = smax(d0, -d4, 0.08);
        // head/mane
        vec3 p5 = p - vec3(0., 0.8, 0.);
        float freq = 5.7;
        float notch = atan(p5.y, p5.z);
        notch = fract(freq * notch);
        notch = pow(notch, 2.);
        notch = 4. * notch * (1. - notch);
        float d5 = sdBezier(p, vec3(0., 1.72 ,  0.2 ),
                                vec3(0., 2.25 , -1.25),
                                vec3(0., -0.2, -0.7)) - 0.075 - 0.025 * notch;
        d0 = smin(d0, d5, 0.04);
        // head/nostrils
        vec3 p6 = rot(vec2(0., -0.6)) * (p - vec3(0.11, 1.33, 0.65));
        float rxz = 0.035 + 0.035 * smoothstep(-0.1, 0.1, p6.y);
        float d6 = sdEllipsoid(vec3(rxz, 0.07, rxz), p6);
        d0 = smax(d0, -d6, 0.02);
        // notches
        vec3 p7 = rot(vec2(0., -0.25))
                * rot(vec2(0.8, 0.))
                * (p - vec3(0.47, 0.2, -0.28));
        float d7 = sdEllipsoid(vec3(0.05,
                                    0.3 + 0.4  * smoothstep(-0.1, 0.1, p7.y),
                                    0.05 - 0.025 * smoothstep(-0.1, 0.8, p7.y)), p7);
        d0 = smax(d0, -d7, 0.02);
        vec3 p8 = rot(vec2(0., -0.35))
                * rot(vec2(0.6, 0.))
                * (p - vec3(0.485, 0.2, -0.08));
        float d8 = sdEllipsoid(vec3(0.05,
                                    0.3 + 0.4  * smoothstep(-0.1, 0.1, p8.y),
                                    0.05 - 0.025 * smoothstep(-0.1, 0.8, p8.y)), p8);
        d0 = smax(d0, -d8, 0.02);        
        if (d0 < d)
        {
            d = d0;
            id = 1.5;
        }
    }    
    return RMResult(d, id);
}

// Function 1896
float map(vec3 p)
{
    objHit.emit = vec3(0);
    objHit.metallic = .0;
    
    float d = 1e+31;
    
    dmin(d, min( max(1.8-box(p*rz(.6)), 1.-p.z), min(3.2-box(p.xy), p.z+4.5)));
    if(dmin(d, length(p)-.5))objHit.metallic = .9;
    
    /*for(int i=0; i < ps.length()-1; i++)
    {
        vec3 glow = vec3(0); glow[i%3] = 1.;
        //vec3 dlt = .2 * normalize(ps[i+1] - ps[i]);
        vec3 p1 = ps[i], p2 = ps[i+1];
        if(dmin(d, line(p, p1, p2)-.06 ))objHit.emit = 16. * glow;
    }*/
    
    vec3 pipes = vec3(0);
    for(int i=0; i < ps.length()-1; i++)
    {
        vec3 p1 = ps[i], p2 = ps[i+1];
        pipes[i%3] = line(p, p1, p2)-.06;
    }
    float mp = -sbox(-pipes);
    if(dmin(d, mp))objHit.emit = vec3(lessThan(pipes, vec3(mp+.001)));
    
    
	return d;
}

// Function 1897
float dist(vec2 p_0,vec2 p_1,vec2 p_2,vec2 x,float t)
{
    return length(x-pow(1.-t,2.)*p_0-2.*(1.-t)*t*p_1-t*t*p_2);
}

// Function 1898
float map(vec3 p, vec4[5] sp)
{
    float d = 100.;
    
    for (int i=0; i<5; i++)
    {
    	d = min(length(p-sp[i].xyz)-sp[i].w, d);
    }
    
    float box = - sbox(p, vec3(2.2,2.2,2.2));
    box = pow(box, 3.); //Cube is a hard surface, increase the distance metric
    d = min(d, box);
    
    return d;
}

// Function 1899
float sphereDistance(vec3 rayPosition, vec3 spherePosition, float sphereRadius)
{
    float d = length(rayPosition - spherePosition) - sphereRadius;
    return d;
}

// Function 1900
float distRing(vec3 p, vec2 r){
  vec2 t = vec2(length(p.xz)-r.x,p.y);
  return length(t)-r.y;
}

// Function 1901
vec3 TriMap(vec3 unitCoord,
            vec3 normal)
{
    #ifdef DISTORT
        vec3 t = texture(iChannel1, abs(unitCoord.xy)).rgb;
		vec2 uvX = mix(unitCoord.yz, unitCoord.zy, t.x);
        vec2 uvY = mix(unitCoord.xz, unitCoord.zx, t.y);
        vec2 uvZ = mix(unitCoord.xy, unitCoord.yx, t.z);
    	mat3x3 triKrn = mat3x3(texture(iChannel0, refl(uvX, AUTO_TILE)).rgb,
                           	   texture(iChannel0, refl(uvY, AUTO_TILE)).rgb,
                           	   texture(iChannel0, refl(uvY, AUTO_TILE)).rgb);
    #else
        mat3x3 triKrn = mat3x3(texture(iChannel0, refl(unitCoord.yz, AUTO_TILE)).rgb,
                           	   texture(iChannel0, refl(unitCoord.xz, AUTO_TILE)).rgb,
                           	   texture(iChannel0, refl(unitCoord.xy, AUTO_TILE)).rgb);
    #endif    
    return (triKrn * abs(normal));
}

// Function 1902
vec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)
{
    //all hard coded numbers depend on the 'r's
    
    int sections = int(2.*max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 1.5/(max(tkp.kq,tkp.kp));
    const int maxIterations = 50;//50
    
    float minDist;
    float bestT;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotSqDistanceDerivative(t, p, tkp);
            dt *= lerningRate;
            
            if(abs(dt) < 0.001)
            {
                float sqDist = torusKnotSqDistance(t, p, tkp);
        
                if(sqDist <= sq(tkp.r3))
                {
                    return vec3(t, sqDist, 1.);
                }
                
                break;
            }
            
            t -= dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                break;
            }
        }
    }
    
    return vec3(0.);
}

// Function 1903
float surface_distance(vec3 pos){
    float radius = sphere_radius;
    
    radius -= fbm(pos.xyz) * radius;
    return length(pos) - radius;
}

// Function 1904
vec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )
{
    outMat = 1.0;

    vec3 oriPos = pos;
    
    // head deformation and transformation
    pos.y /= 1.04;
    vec3 opos;
    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );
    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );
    pos.x *= 1.04;
    pos.y /= 1.02;
    uvw = pos;

    // symmetric coord systems (sharp, and smooth)
    vec3 qos = vec3(abs(pos.x),pos.yz);
    vec3 sos = vec3(sqrt(qos.x*qos.x+0.0005),pos.yz);
    
    // head
    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );
    
    // jaw
    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);
	mos.yz = rot(mos.yz,0.1*animData.z);
	float d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),
                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),
                 	  0.43+sclamp(mos.y*0.5,-0.5,0.2),
                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));
        
    // mouth hole
    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);
    
    // lower lip    
    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), 
                      vec3(0,0.01,0.61),
                      vec3(0.094+0.01*animData.z,0.015,0.61),
                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));
    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);
    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);
    d = smin(d,d2,0.19);

    // chicks
    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);
    
    // who needs ears
    
    // eye sockets
    vec3 eos = sos-vec3(0.3,-0.04,0.7);
    eos.xz = rot(eos.xz,-0.2);
    eos.xy = rot(eos.xy,0.3);
    eos.yz = rot(eos.yz,-0.2);
    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );
	d = smax( d, -d2, 0.15 );

    eos = sos-vec3(0.32,-0.08,0.8);
    eos.xz = rot(eos.xz,-0.4);
    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );
    d = smax( d, -d2, 0.05 );

    vec3 oos = qos - vec3(0.25,-0.06,0.42);
    
    // eyelid
    d2 = sdSphere( oos, 0.4 );
    oos.xz = rot(oos.xz, -0.2);
    oos.xy = rot(oos.xy, 0.2);
    vec3 tos = oos;        
    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);

    //eyebags
    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);
    tos.yz = rot(tos.yz,0.8);
    tos.xy = rot(tos.xy,-0.2);
	d = smin( d, sdTorus(tos,0.29,0.01), 0.03 );
    
    // eyelids
    eos = qos - vec3(0.33,-0.07,0.53);
    eos.xy = rot(eos.xy, 0.2);
    eos.yz = rot(eos.yz,0.35-0.25*animData.x);
    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );
    d = smin( d, d2, 0.012 );

	// eyelashes
	oos.x -= 0.01;
    float xx = clamp( oos.x+0.17,0.0,1.0);
    float ra = 0.35 + 0.1*sqrt(xx/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));
    float rc = 0.18/(1.0-0.7*smoothstep(0.15,0.5,animData.x));
    oos.y -= -0.18 - (rc-0.18)/1.8;
    d2 = (1.0/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;
    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;
    
    // nose
    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);
    eos.yz = rot(eos.yz,-0.23);
    float h = smoothstep(0.0,0.26,-eos.y);
    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;
    eos.x = sqrt(eos.x*eos.x + 0.001);
    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );
    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );
    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        
    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );
    d = smin(d,d2,0.05-0.03*h);
    
    // mouth
    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);
    tos = eos-vec3(0.0,-0.13,0.06);
    tos.yz = rot(tos.yz,0.2);
    float dTeeth = sdTorus(tos,0.15,0.015);
    eos.yz = rot(eos.yz,-0.5);
    eos.x /= 1.04;

    // nose-to-upperlip connection
    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;
    d2 = max(d2,-(eos.z-0.03));
    d = smin(d,d2,0.05);

    // upper lip
    eos.x = abs(eos.x);
    b = sdBezier(eos, vec3(0.00,-0.22,0.17),
                      vec3(0.08,-0.22,0.17),
                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));
    d2 = length(b.zw/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);
    d = smin(d,d2,0.02);
    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))
                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));

    // valley under nose
    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );
    d2 = se.x-0.03-0.06*se.y;
    d = smax(d,-d2,0.04);
    isLip *= smoothstep(0.01,0.03,d2);

    // neck
    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );
    d2 = se.x - 0.38;

    // shoulders
    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );
    d2 = smin(d2,se.x-0.21,0.1);
    d = smin(d,d2,0.4);
        
    // register eyelases now
    vec4 res = vec4( d, isLip, 0, 0 );
    if( deyelashes<res.x )
    {
        res.x = deyelashes*0.8;
        res.yzw = vec3(0.0,1.0,0.0);
    }
    // register teeth now
    if( dTeeth<res.x )
    {
        res.x = dTeeth;
        outMat = 5.0;
    }
 
    // eyes
	pos.x /=1.05;        
    eos = qos-vec3(0.25,-0.06,0.42);
    d2 = sdSphere(eos,0.4);
    if( d2<res.x ) 
    { 
        res.x = d2;
     	outMat = 2.0;
        uvw = pos;
    }
        
    // hair
    {
        vec2 occ_id, tmp;
		qos = pos; qos.x=abs(pos.x);

        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), 
                               vec3( 0.95, 0.7,0.85), 
                               vec3( 0.4,-1.45,0.95),
                               -0.9,occ_id);

        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), 
                                vec3(-1.0, 0.4,0.2), 
                                vec3(-0.6,-1.4,0.7),
                                0.6,tmp);
        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}

        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), 
                           vec3( 1.0, 0.5,0.45), 
                           vec3( 0.4,-1.45,0.55),
                           -0.2,tmp);
        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}
    

        pres.x *= 0.8;
        if( pres.x<res.x )
        {
            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );
            uvw = pres.yzw;
            outMat = 4.0;
        }
    }

    // hoodie
    vec4 tmp = sdHoodie( opos );
    if( tmp.x<res.x )
    {
        res.x = tmp.x;
        outMat = 3.0;
        uvw  = tmp.yzw;
    }

    return res;
}

// Function 1905
vec3 Tonemap_ACES(vec3 x) {
    return vec3(Tonemap_ACES(x.r),Tonemap_ACES(x.g),Tonemap_ACES(x.b));
}

// Function 1906
ctx scene_warp(ctx cx) {
    
    cx = scene(cx);
   	float d = cx.distance_;
    
    vec3 p = cx.point;

    //cloud shape deform
    if (cx.deformAmount > 0.0) {
	#define ldst d
    for (int i = 1; i < 4; i++) {
        float pfi = pow(float(i),2.)*cx.deformScale;
        ldst += abs(cos(p.x/pfi+cos(26.2348+ldst*cx.deformRoughness*p.z/pfi+(p.y*.39)/pfi)*4.)*
     		     cos(p.y/pfi+cos(29.8937+ldst*cx.deformRoughness*p.x/pfi+(p.z*.37)/pfi)*4.)*
       		     cos(p.z/pfi+cos(14.972+ldst*cx.deformRoughness*p.y/pfi+(p.x*.41)/pfi)*4.))*pfi*(cx.deformAmount/cx.deformScale);
    }
    }
    
    cx.distance_ = max(skipDelta, d);
    return cx;
}

// Function 1907
float distTerr(vec3 p)
{
    vec3 p2=p*.0001;
    vec4 noise = vec4(0);
    float sc;
    sc=1.; 
    for(int i=0;i<3;i++)
    {
        noise += (myRandInterpol(p2.xy*sc)-.5)/sc;
        noise += (myRandInterpol(p2.yz*sc)-.5)/sc;
        noise += (myRandInterpol(p2.zx*sc)-.5)/sc;
        sc*=2.;
    }
    noise += abs(myRandInterpol(p2.xy*sc*5.)-.5)/sc/5.;
    noise += abs(myRandInterpol(p2.yz*sc*5.)-.5)/sc/5.;
    noise += abs(myRandInterpol(p2.zx*sc*5.)-.5)/sc/5.;
    
    #if   defined(CHAIN_WORLD)
    return distChainCircle(p+noise.xyz*10.,200., 6, 60.,20.,20.);
    #elif defined(TORUS2_WORLD)
    return min(distTorus(p+noise.xyz*10.,100.,40.),distTorus((p-vec3(100,0,0)).zxy+noise.xyz*10.,100.,40.));
    #elif defined(TORUS_WORLD)
    return distTorus(p+noise.xyz*10.,100.,40.);
    #elif defined(HOLLOW_SPHERE_WORLD)
    return -length(p+noise.xyz*10.)+100.;
    #elif defined(SPHERE_WORLD)
    return length(p+noise.xyz*10.)-60.;
    #elif defined(PLANE_WORLD)
    return dot(p+noise.xyz*10.,normalize(vec3(1,.5,.7)));
    #elif defined(HOLLOW_TORUS)
    return -distTorus(p+noise.xyz*10.,100.,40.);
    #else
    return p.z+noise.x;
    #endif
}

// Function 1908
float scene(vec3 p)
{
        return min(100.-length(p) , abs(flame(p)) );
}

// Function 1909
float dist_gasket(vec3 z) {  
    vec3 z0 = z;
    float r;
    int n = 0;
    while (n < divisions) {
       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1
       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2
       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3	
       z = z*scale - vec3(1.,1.,1.)*(scale-1.0);
       n++;
    }
    
    float retval = (length(z) ) * pow(scale, -float(n));
    //retval = min(retval, length(z0) - 0.3);
    
    //Render the clicked pivot point:
    //retval = min(retval, length(z0-get_vec_val(PIVOT))-0.03);
    return retval;
}

// Function 1910
float distanceToSegment( in vec2 p, in vec2 a, in vec2 b ) 
{
    //Iq's function (I use this for smooth lines)
	vec2 pa = p-a;
	vec2 ba = b-a;
	float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
	return length( pa - ba*h );
}

// Function 1911
float mapBeach( in vec3 p )
{
    float d = dot(p,bnor)-2.8;
    
    vec2 w = vec2(0.0);
    vec2 s = vec2(0.5);
    vec2 t = vec2(0.0);
	
    vec2 q = p.xz*1.25;
    q += 1.0*cos( 0.3*q.yx );
    for( int i=0; i<7;i++ )
    {
        float n = 0.5 + 0.5*noise(q);
		w += s*vec2(1.0-almostIdentity(abs(-1.0+2.0*n),0.1,0.05 ),n);
		t += s;
        q = mat2(1.6,1.2,-1.2,1.6)*q;
		s *= vec2(0.3,0.5);
    }
	w /= t;

	float f = w.x + w.y*0.4;
    
    float wet = 1.0-smoothstep(-16.0, -10.0, p.z );
    
    return d - 0.15*mix(f, (1.0-f)*0.1, wet );
}

// Function 1912
vec2 map(vec3 p) {
    float D = 0.0, T = 0.0;
    // floor & walls
    /*float fl = mapFloor(p);
    float w = mapWalls(p);
    D = polsmin(fl, w, 1.0);
    T = fl==D?0.0:1.0;*/
    // the hanger one
    /*float d3 = mapThing(p);
    D = min(D, d3);
    T = d3==D?2.0:T;*/
    // alien
    float d4 = mapAlien(p-EGGPOS);
    /*D = min(D, d4);
    T = d4==D?3.0:T;*/
   	D = d4;
    T = 3.0;
    return vec2(D, T);
}

// Function 1913
vec3 envMap(vec3 p){
    
    p *= 6.;
    p.y += iTime;
    
    float n3D2 = n3D(p*2.);
   
    // A bit of fBm.
    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;
    c = smoothstep(.45, 1., c); // Putting in some dark space.
    
    p = vec3(c, c*c, c*c*c*c); // Bluish tinge.
    
    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.

}

// Function 1914
float getSphereDistance( vec3 p, float r )
{
	return max( 0.0, length(p)-r );
//	return length(p)-r;
}

// Function 1915
void SmoothCubeMapHorizon(inout vec3 c, const vec3 cm, float d)
{
    float m = exp(-d*d*.001);
    c = mix(cm, c, m);
}

// Function 1916
float remap01(float a, float b, float t){
 	return (t-a) / (b-a);   
}

// Function 1917
float map(in vec3 rp)
{
    float h = textureSpherical(iChannel0, planetRotatedVec(rp), .6).r;
    h = smoothstep(0.1, 1.0, h);
    h*=H*.5;
    return  length(rp) - (SHELL+h);
}

// Function 1918
SDFResult toiletSDF( vec3 p )
{
    SDFResult res = SDFResult(TOO_FAR, MAGEN);    
    vec3 orig = vec3(0.0, -1.0, 1.0);        

    vec3 centre = vec3(0.1, 1.0, 0.0)+orig;
    const float radius = 1.3;
    if (length(p-centre) < radius) 
    {   
        // pedestal
        res = roundboxSDF(RoundBox(vec3(0.0, 0.2, 0.0)+orig, vec3(0.2, 0.5, 0.2), 0.1, WHITE), p);
        // bowl and lid
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.6, -0.1)+orig, vec3(0.5, 0.2, 0.3), 0.05, WHITE), p), res, 0.1);
        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 0.78, -0.1)+orig, vec3(0.5, 0.000002, 0.3), 0.05, WHITE), p), res, 0.001);
        // reservoir
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.4, 0.5)+orig, vec3(0.5, 0.5, 0.1), 0.05, WHITE), p), res, 0.1);
        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 1.8, 0.5)+orig, vec3(0.5, 0.000002, 0.1), 0.05, WHITE), p), res, 0.001);
        // base
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.0, 0.0)+orig, vec3(0.3, 0.05, 0.35), 0.05, WHITE), p), res, 0.1);
#ifdef STUFF2
        // button & brush
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.93, 0.5)+orig, vec3(0.05, 0.02, 0.05), 0.05, WHITE), p), res, 0.01);
        res = opSmoothAdd(brushSDF(p), res, 0.1);
#endif //STUFF2
    }
    return res;
}

// Function 1919
float roundedConeSDF(in vec3 iPoint, in float iSmallRadius, in float iBigRadius, in float iHeight) {
    
    vec2 q = vec2(length(iPoint.xz), iPoint.y);
    
    float b = (iBigRadius - iSmallRadius)/iHeight;
    float a = sqrt(1.0 - b*b);
    float k = dot(q, vec2(-b, a));

    if (k < 0.0) return length(q) - iBigRadius;
    if (k > a*iHeight) return length(q - vec2(0.0, iHeight)) - iSmallRadius;

    return dot(q, vec2(a, b)) - iBigRadius;
    
}

// Function 1920
float sdFloor(vec3 pos) {
 	return pos.y;
}

// Function 1921
float mapScene(in vec3 p, in float bounce, in float stretch) {
    p.y /= stretch;
    p.y -= bounce;
    return sdStanfordBunny(p - vec3(-0.5, 0.5, 0.0), 3.0);
}

// Function 1922
vec2 scene(in vec3 position) {
    vec2 scene = opUnion(
          vec2(sdPlane(position), 1.0),
          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)
    );
    return scene;
}

// Function 1923
float TriPrism0_SDF(in vec3 p, in vec2 e)
{
	vec3 q = abs(p);
    return max(q.z - e.y, max(q.x * 0.366025 + p.y * 0.5, -p.y) - e.x * 0.5);
}

// Function 1924
vec3 map_box_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return reflect(rd, nrm);
}

// Function 1925
vec2 Scene(vec3 pos)
{
	return vec2(ShaderBall(pos));
}

// Function 1926
vec2 sdform(in vec3 pos, float hs) {
    vec4 P = vec4(pos.xzy, 1.);
    float orbits = .0;
    for(int i = 0; i < 3; i++) {
        orbits = max(length(P.xz)*.075,orbits);
        bet(P, 4.25-hs, 3.-hs, .55);
        
        if(hs>.5) {
            tet(P, 1.5+hs, 1.5, 1.5, 1.5);
        }else{
            tet(P, 1.5-hs, 1.+hs, 1.5, 1.5);
        }
    }
  
    float ln = .9*(abs(P.z)-15.)/P.w;
    
    return vec2(ln,orbits);
}

// Function 1927
vec2 map( vec3 pos ) {
	float s = 2.0;
	float ct = coolThing( pos/s, 1.7)*s;
    float peana = sdCappedCylinder(pos+vec3(0.0,8.0,0.0),vec2(10.0,1.0));
    if( peana > ct)
        return vec2(ct,0.0);
    else
    	return vec2(peana,1.0);
}

// Function 1928
float toneMap(float c)
{
    switch (method) {
  	  case 0: // to sRGB gamma via filmic-like Reinhard-esque combination approximation
	    c = c / (c + .1667); // actually cancelled out the gamma correction!  Probably cheaper than even sRGB approx by itself.
		break; 	// considering I can't tell the difference, using full ACES+sRGB together seems quite wasteful computationally.
  	  case 1: // ACES+sRGB, which I approximated above
	    c = ((c*(2.51*c+.03))/(c*(2.43*c+.59)+.14));
	    c = pow(c, 1./2.2); // to sRGBish gamut
	    break;
  	  default: // sRGB by itself
	    c = pow(c, 1./2.2);
        break;
    }
    return c;
}

// Function 1929
float scene(vec3 p) {
    if (length(p) > 1.) return length(p)-.8;
vec4 f0_0=sin(p.y*vec4(.8492,-3.1536,4.2514,-2.5443)+p.z*vec4(2.0303,-2.6018,-.2758,.7154)+p.x*vec4(1.2334,-2.7103,-2.0685,.2913)+vec4(8.2323,.7743,-7.1299,-1.8285));
vec4 f0_1=sin(p.y*vec4(2.1637,1.1794,-.5900,-3.1059)+p.z*vec4(-3.6854,.0824,1.1433,3.1549)+p.x*vec4(2.9993,-2.4728,-3.2950,-2.3026)+vec4(7.8344,7.0982,1.5609,-6.9444));
vec4 f0_2=sin(p.y*vec4(2.7085,-.0694,-1.4490,-1.3753)+p.z*vec4(-1.6991,-1.0108,-1.4092,-2.4201)+p.x*vec4(.6893,-1.5291,-3.3328,3.9221)+vec4(6.2188,.5368,-1.5975,-8.2845));
vec4 f0_3=sin(p.y*vec4(-3.5305,-2.8488,3.1625,-1.3753)+p.z*vec4(-.3045,-2.8575,-3.7523,-3.3139)+p.x*vec4(2.9020,-1.8811,.8204,-2.8186)+vec4(-3.3321,-1.1910,6.0313,4.6544));
vec4 f0_4=sin(p.y*vec4(-.8159,-.0311,3.7440,-1.8225)+p.z*vec4(3.7890,-2.9560,3.9464,-.3521)+p.x*vec4(-4.0974,.2942,-2.6997,2.9319)+vec4(-5.3754,5.8587,7.3798,-5.3308));
vec4 f0_5=sin(p.y*vec4(.1891,-2.6589,1.7235,3.1446)+p.z*vec4(3.6162,2.6861,1.7175,-2.5797)+p.x*vec4(-4.2137,1.7879,1.6982,-2.5067)+vec4(6.9776,8.2737,5.0327,-6.8911));
vec4 f1_0=sin(mat4(-.4580,-.3591,-.2458,-.7723,-.4684,.1794,-.0774,.0707,.0963,-.3527,-.2931,.0823,-.4707,-.1198,-.1699,-.0028)*f0_0+
    mat4(-.6387,.0965,.1119,.0369,-.1827,.0761,-.4077,-.3708,.5845,.1853,.3939,-.2916,-.7471,.2621,-.3722,-.0335)*f0_1+
    mat4(-.2305,.1100,-.5388,-.4042,-.5499,.2220,.1158,.4419,.8336,-.2037,-.1127,-.2849,-.1972,.5653,.0601,.3877)*f0_2+
    mat4(-.1586,.0873,.2125,.0324,-.4838,.8431,-.1811,-.7007,.1127,-.2808,-.2237,.2380,-.0507,-.0127,.3203,-.1578)*f0_3+
    mat4(-.2425,.1650,.0394,-.0723,-.2488,-.4288,-.0929,.0764,.0111,.1365,-.0250,-.0358,.2158,.6068,.4613,-.1824)*f0_4+
    mat4(-.2719,-.2084,-.0606,-.1048,-.1194,-.5983,.2191,-.4768,-.0091,.2867,-.3471,.2759,.2746,.4422,-.0788,-.1719)*f0_5+
    vec4(-1.1601,.5299,-.4378,.9026))/1.00+f0_0;
vec4 f1_1=sin(mat4(.5062,-.4534,.0559,-.1254,.0690,-.0408,.0116,-.1550,.2808,-.2661,-.3033,-.2412,-.4988,-.0269,.0018,-.2127)*f0_0+
    mat4(.6238,-.0637,.0762,-.2859,-.3781,.2471,.5238,-.4009,.0110,.3775,-.0360,.0424,.4594,-.0024,.0225,-.6443)*f0_1+
    mat4(.1892,-.1313,-.1736,-.5698,-.4082,.3731,-.5478,.4749,-.4338,.3774,-.2732,.4114,-.2886,.1701,-.0440,-.3256)*f0_2+
    mat4(-.2854,.2050,.2492,-.3566,.1414,.2293,-.3188,-.2672,-.1124,.3396,.0055,.4521,.5054,-.1283,-.1135,-.5348)*f0_3+
    mat4(-.3760,.2989,-.1789,.2557,.2399,-.6459,-.3775,.1709,-.0433,-.0980,-.0313,.3756,.6284,-.3899,-.0856,-.0783)*f0_4+
    mat4(-.0025,.1410,.0952,.1477,.0660,.0624,.0743,-.1663,-.1933,.2924,-.2988,.6986,.0736,.1034,-.0694,.0121)*f0_5+
    vec4(2.2564,1.2602,-.4925,.2218))/1.00+f0_1;
vec4 f1_2=sin(mat4(-.4401,-.3026,.0227,.1415,-.2492,.0738,-.3186,.9295,.1619,.2663,.0957,-.1673,-.2081,.0025,.3243,.3319)*f0_0+
    mat4(-.4203,.3659,.3905,-.1523,-.0023,.0747,-.5057,-.0260,.2742,.2248,.2472,-.3317,-.1277,-.0292,-.2564,-.3361)*f0_1+
    mat4(-.4158,.7305,-.7553,-.3931,-.1338,-.1459,.1116,.2605,.0181,-.0307,.3358,-.2385,-.1403,.3447,-.7076,-.4122)*f0_2+
    mat4(.1874,.3984,.0733,-.4968,-.5643,.3676,-.2994,.0719,-.0354,-.1701,.3066,.2194,-.3608,.3860,-.7113,.0587)*f0_3+
    mat4(.0995,.3485,-.3206,.2706,-.2510,-.1898,.1470,-.1533,.0282,.1463,-.2167,.1259,-.3989,.0412,-.3654,.2205)*f0_4+
    mat4(-.1051,.1175,-.2125,-.2052,.0743,.4249,.2884,.1587,.1687,.1844,.5628,.3804,-.0165,.1374,-.0620,.6649)*f0_5+
    vec4(.8299,.3346,1.9768,-.2290))/1.00+f0_2;
vec4 f1_3=sin(mat4(-.0949,.2352,-.0752,.2184,.1637,-.2041,-.1961,.4540,-.0427,.1923,.1093,.1543,.1447,-.2237,-.1430,.5119)*f0_0+
    mat4(-.1044,-.1089,.1748,-.1808,-.6169,.0072,-.2089,-.2005,-.4437,-.1568,-.0632,.2834,.7249,-.0745,-.2137,.4346)*f0_1+
    mat4(-.2787,-.0280,.1788,.4294,.1005,-.2995,-.1773,-.5533,-.6840,-.1035,-.0848,.2626,.2076,.2397,.2994,-.3702)*f0_2+
    mat4(-.1988,-.2248,-.0634,.1309,-.1593,.2817,-.5118,.3122,.4537,-.2462,.0094,.0468,.0103,-.2185,-.3683,.3952)*f0_3+
    mat4(-.0323,-.2954,.0896,-.1814,-.1697,-.2709,.0173,-.0095,-.0648,-.0294,.1244,-.1709,.5009,.1065,-.1984,-.0619)*f0_4+
    mat4(.1121,.0948,-.1159,-.1787,.1001,.2101,-.1895,-.1386,-.0169,.2297,.0504,.1761,.4173,-.1880,-.1604,-.1343)*f0_5+
    vec4(-2.3796,2.1204,-1.3265,-2.0990))/1.00+f0_3;
vec4 f1_4=sin(mat4(-.1173,-.0086,-.1638,.0874,.1568,-.0614,.0250,.5144,-.3971,.1971,.0916,-.1922,-.1976,-.1462,.0360,-.5170)*f0_0+
    mat4(-.0545,-.4532,.3809,.0364,.1839,.2455,.1499,-.5448,.0455,.2235,-.1757,-.0502,-.4128,-.0836,.1797,.2501)*f0_1+
    mat4(-.5005,.5680,-.0334,.1458,.4098,.6234,-.1801,.2116,-.2571,.8072,.0991,-.0312,.4996,-.1413,-.2944,.6564)*f0_2+
    mat4(.2226,.0369,.1292,-.4306,.4484,-.1363,.1214,.0977,.1514,.0191,.2961,.0282,.3591,-.3719,-.0422,.1681)*f0_3+
    mat4(-.0765,.0323,-.1163,-.0258,-.2152,-.1764,.0355,-.1135,.1124,-.0271,-.0338,.6661,.0069,-.2052,-.2571,.1726)*f0_4+
    mat4(.2477,-.1941,.0263,.3586,.7080,-.2954,.0446,.3193,-.3413,.1220,.1603,.4147,-.3961,-.2685,-.0134,.5242)*f0_5+
    vec4(-1.9690,-2.0433,-2.1038,.5665))/1.00+f0_4;
vec4 f1_5=sin(mat4(-.5888,.0037,-.1493,-.4660,-.3044,.3332,-.2052,.1175,-.2343,-.0941,.1692,-.0891,.1491,-.0332,.2833,.2458)*f0_0+
    mat4(.0784,.2676,-.2020,-.2411,-.1333,-.1154,.1847,.2442,.3955,.2428,-.2283,.1718,-.4057,-.2134,-.2670,.2937)*f0_1+
    mat4(-.3168,-.3787,.1858,.0724,.3125,.2058,.2569,.2424,.0881,-.2949,-.2564,-.0694,.0164,-.0384,.4766,.2163)*f0_2+
    mat4(.0710,.2149,-.3981,.1491,-.4004,.0871,-.4029,.2981,.5039,.0432,.2059,.0846,-.3547,-.3554,-.3770,-.3855)*f0_3+
    mat4(-.1528,-.0439,.1485,.2239,.0045,-.2379,.0340,-.0844,.3762,.1915,.1721,.2707,.3165,-.5013,.4390,-.1853)*f0_4+
    mat4(-.3867,.2769,-.0838,-.2804,.5560,.2478,.7377,.0265,.1205,.1780,-.2092,.1915,-.1012,-.2299,.4956,.1346)*f0_5+
    vec4(-.2941,1.7317,-1.1038,2.2876))/1.00+f0_5;
vec4 f2_0=sin(mat4(-.0522,.5138,-.0900,-.2040,.2550,.8599,-.5263,.1611,-.4182,-.0008,-.5171,-.5176,.2867,.2992,-.3244,-.3121)*f1_0+
    mat4(-.3275,-.0448,.2108,.6352,-.4221,-.1788,.3204,.8966,.3556,.1856,.2491,-.4446,.0253,.5647,.1699,.2624)*f1_1+
    mat4(-.7077,.8153,-.0659,-.1346,-.4776,.7336,-.3527,-.1274,-.0395,.7140,.5397,.6400,.3088,.3493,.6563,.2562)*f1_2+
    mat4(-.4112,.2368,-.3259,.0312,.3326,.3846,-.1377,-.0859,.3805,-.6316,-.3325,-.2191,.4008,-.2040,.2446,-.0542)*f1_3+
    mat4(-.2776,.6583,-.1233,.0789,-.5844,.9975,.1644,.5170,.3126,-.5971,.7574,.2651,-.4322,-.5979,-.3646,-.2537)*f1_4+
    mat4(.4180,.3118,.5762,.0217,.4996,.6601,-.4363,.1124,-.1731,.9978,.4948,.0859,.1247,-.0852,-.0094,-.3074)*f1_5+
    vec4(-.5564,.4538,-.5834,-.3345))/1.41+f1_0;
vec4 f2_1=sin(mat4(.1809,.1194,.8741,-.4402,.4410,.2212,.8835,-.6453,.3458,-.3824,.1327,.0902,-.2926,.2484,-.3067,-.1225)*f1_0+
    mat4(-.2542,.0368,-.4391,.2098,-.1046,.3827,-.3644,.0248,-.5124,.4207,.1866,-.1901,.1711,.0435,.2286,.0733)*f1_1+
    mat4(-.1395,-.5283,-.3573,-.2013,.5058,-.1620,-.1637,-.3688,-.0961,-.0179,.4244,-.1639,1.0688,-.2210,-.0849,.2363)*f1_2+
    mat4(.0244,.5470,.1783,-.2540,-.2083,.0825,-.4470,.0946,-.0161,-.1693,.5090,-.5754,-.1939,.2268,-.2708,.3402)*f1_3+
    mat4(.3091,-.2567,.1460,.1030,.4530,.0705,.5209,-.5854,.1578,-.4835,.1141,.0751,-.5655,-.3546,-.5853,.2299)*f1_4+
    mat4(.3429,-.3937,.4304,-.1933,.1821,-.5243,.3037,-.1521,-.3790,-.2177,.6741,-.2862,.3516,-.2026,-.0849,-.2023)*f1_5+
    vec4(-2.0182,.5772,1.4044,2.1393))/1.41+f1_1;
vec4 f2_2=sin(mat4(-.5077,-.4142,.2708,.3081,-.6767,-.4811,.4291,-.0672,-.5041,.2150,.3125,-.2161,-.6413,-.3245,-.0524,-.2983)*f1_0+
    mat4(-.2407,-.5879,-.2966,.2056,.0649,-.5576,-.5009,-.0698,.4031,-.3684,.0056,-.2824,-.4777,-.7021,.4408,-.1383)*f1_1+
    mat4(-.2794,-.5652,-.0038,.1481,.0199,-.2712,-.2220,-.4349,-.0248,-.9646,-.3325,.3309,.1804,.0158,.1826,-.4807)*f1_2+
    mat4(-.4443,-.2897,.2314,.4056,-.5744,-.3758,-.4904,-.1823,-.0158,.3052,-.2436,.0334,.4746,.1673,.3041,-.3414)*f1_3+
    mat4(-.1371,.0742,.3638,.5218,.7119,-.7504,.0206,-.0930,.0112,-.0965,-.2709,.3288,.5057,1.2219,-.7094,-.0810)*f1_4+
    mat4(-.0083,-.4413,.1369,-.1555,-.7499,-.3262,.2408,.5089,.2438,.1859,.6687,.4159,-.2968,-.3286,-.5170,-.3279)*f1_5+
    vec4(-1.8856,1.5024,-2.8512,-.3744))/1.41+f1_2;
vec4 f2_3=sin(mat4(1.2399,.1631,-.4531,.1906,1.8745,.3440,.1115,.2580,.8242,-.0553,-.7853,.0271,.4777,.2145,.2358,-.2908)*f1_0+
    mat4(.2972,.1495,.1459,.2982,-.2873,.4552,-.5219,.1638,-.0986,-.0457,-.0788,.7854,.5313,.3866,-.6354,-.1472)*f1_1+
    mat4(.6113,.0395,-.3419,.6074,.1651,-.4138,.1476,-.0156,.1489,.3491,-.5215,1.0861,-.0476,.3061,.6594,.0527)*f1_2+
    mat4(-.0443,-.3457,-.2717,.2713,-.2162,-.0557,-.4465,-.0147,-.2044,-.0393,.2003,.1617,.6544,.3789,.3576,.2094)*f1_3+
    mat4(-.0916,-.3850,-.2481,.1611,-.0042,.2985,-.1898,.0848,.3283,-.0043,.3993,.3080,-1.5710,-.2324,.2511,-.6316)*f1_4+
    mat4(.8262,.4201,-.3914,.0550,.8984,.5615,.0745,.2815,.4997,-.3894,.1098,.2730,.3448,.1469,.5688,-.1453)*f1_5+
    vec4(-.2235,.2605,.5247,1.3310))/1.41+f1_3;
vec4 f2_4=sin(mat4(-.5574,-.2438,-.6280,.6851,-.0486,-.0124,.0624,.7448,.0523,.2830,.2307,-.5110,-.0492,.1000,.1749,.4584)*f1_0+
    mat4(-.7541,.2490,.5311,-.2586,.0516,.1387,.1324,.5100,.2034,-.4428,-.0576,-.5620,-.6683,.3471,-.4841,.1482)*f1_1+
    mat4(-.4280,.3313,.1148,.3440,-.2536,-.4068,.4173,.4168,-.1324,-.6707,.1307,.5240,-.5838,-.1244,.3252,-.0168)*f1_2+
    mat4(.1040,-.7364,-.6550,.2508,.4113,.1831,.5180,.1322,.3674,.1983,-.5105,-.5664,.3346,.2571,-.2393,-.1656)*f1_3+
    mat4(-.0501,.0677,.1875,-.3256,.1911,-.0706,-.5060,-.1132,-.8338,.4796,-.2428,-.1871,.0571,.3844,.1191,-.8371)*f1_4+
    mat4(-.4982,-.1125,-.1938,.9975,-.4641,-.2440,.4490,.5749,-.2811,-.4488,-.7785,.4198,-.3752,.3485,.0646,-.0372)*f1_5+
    vec4(.2451,-2.7481,1.6170,2.7030))/1.41+f1_4;
vec4 f2_5=sin(mat4(-.5416,.1581,.1109,-.1575,-.1176,.0102,.0321,-.3840,-.0201,.2303,.8922,.4582,.4632,.1763,.1207,-.4809)*f1_0+
    mat4(.3073,.4923,.3689,-.2218,.1937,-.1456,-.6348,-.0421,-.5541,.1119,.0108,-.0817,-.0295,.5413,.1032,-.0510)*f1_1+
    mat4(.1145,.1946,-.0029,-.1022,.1982,.0201,.1337,-.0567,.0051,-.1692,.2642,-.1504,-.5321,-.1657,.2836,-.6068)*f1_2+
    mat4(-.6588,.1687,-.1320,-.1531,.3751,-.4534,-.6667,.4604,.0680,-.4678,-.0213,-.2293,-.2008,.1564,.1174,-.0282)*f1_3+
    mat4(.2706,.1628,.3384,-.0827,-.5909,.0290,-.1427,-.6185,.3517,.3706,-.0748,-.2378,.2287,-.5105,-.3715,.1601)*f1_4+
    mat4(-.2761,.5620,-.1432,-.4194,.2091,-.0878,-.1639,-.7371,-.3619,-.0485,.5911,.0672,-.1087,.2749,-.3186,-.0562)*f1_5+
    vec4(1.9430,1.5850,-.4730,1.9014))/1.41+f1_5;
vec4 f3_0=sin(mat4(.2007,.0618,-.0220,-.7388,.1409,1.2192,.0593,-.7798,.0911,.4274,-.0096,-.6169,.1536,-.3472,.3440,-.3277)*f2_0+
    mat4(-.2100,-.2354,.4322,-.6668,-.2674,-.1906,-.2812,.0904,-.2747,-.5220,-.1945,.5501,-.4535,.3777,-.1429,-.6704)*f2_1+
    mat4(.3746,-.0909,-.3018,.0196,-.4701,.7244,-.0673,-.5587,.4863,.3420,-.0909,-1.0957,-.7724,.0927,-.2213,-.1709)*f2_2+
    mat4(.1928,-.6222,.1538,1.0166,-.1972,.2724,-.2347,.0524,.4114,-.1728,.3652,.7044,.5539,-.3122,.0561,-.0631)*f2_3+
    mat4(-.5886,-.1030,.2825,.3391,.3774,.1824,.1478,.2044,.4657,.3389,.4348,-.2773,.0069,-.5947,.1091,.9238)*f2_4+
    mat4(.1958,.5155,.2794,-.9993,.5927,.3713,.0967,.0166,-.1539,.3186,-.0380,-.1857,.4631,.4401,.5337,-.3898)*f2_5+
    vec4(1.9893,.8645,-1.4119,2.8486))/1.73+f2_0;
vec4 f3_1=sin(mat4(.1104,-.3447,.2655,.4982,.4419,-.2617,-.0498,-.3696,-.1561,-.2668,.8191,.2826,.2961,-.3773,.2588,.3373)*f2_0+
    mat4(.6862,-.0627,.4938,.6880,.5989,.2134,-.6080,-.6415,-.1003,1.0786,-.0152,-.0982,.1867,-.1114,-.2293,.4147)*f2_1+
    mat4(.1726,.2518,.7151,.0228,-.1362,.3352,-.7119,.2925,-.2686,.0798,.1185,.6655,-.3559,.2566,.4520,-.1860)*f2_2+
    mat4(-.3171,-.0583,.0016,-.1027,.4489,.1912,-.0557,.2452,-.4275,.3881,.0427,-.1960,.1632,-.0783,.1403,.5006)*f2_3+
    mat4(.0813,.3805,.3390,.3408,-.3449,-.6171,-.0545,-.0001,-.5404,-.1215,-.2123,.1113,-.4064,.4591,.0108,.0405)*f2_4+
    mat4(.1169,-.7242,-.2335,.0465,.7025,.0055,-.0758,.0635,-.3642,-.5353,.5487,.0209,.3908,.4558,-.5248,.0546)*f2_5+
    vec4(.3422,-1.7922,1.0598,.3482))/1.73+f2_1;
vec4 f3_2=sin(mat4(.2349,-.6517,-.1259,-.4556,.2578,.5178,-.6482,.4802,1.1230,-.5294,-.3671,.1878,-.2001,.0374,-.0554,.2286)*f2_0+
    mat4(.1674,-.5603,.1656,.0567,-.3943,.0649,-.1802,-.1209,-.1440,.0141,.3102,-.0797,.3413,.2230,-.1278,.3889)*f2_1+
    mat4(1.8272,.1541,.2337,-.0095,-.4193,-.6876,.4774,.4338,.1961,-.1404,-.2387,.1968,.8442,.0991,.1291,.3290)*f2_2+
    mat4(-.1199,.4082,.4789,.2691,-.1935,.0344,-.0147,-.5080,-.3039,.4404,-.0279,.1535,.6905,-.1188,-.1131,.2814)*f2_3+
    mat4(-.0284,-.2919,-.1578,-.1254,.0922,-.1007,-.2364,.3043,-.3625,-.6060,-.1828,.4089,-.2301,1.2275,.4786,.0091)*f2_4+
    mat4(.0162,-.1108,-.5261,.2127,-.2708,.3115,.1231,-.1766,-.2043,.3421,-.4441,-.0574,.2832,-.4080,.1936,-.5364)*f2_5+
    vec4(1.3987,.0160,.7507,-.7974))/1.73+f2_2;
vec4 f3_3=sin(mat4(-.0778,-.1509,-.2268,.9344,.0677,.5805,-.8326,1.0738,.2009,.3705,-.4457,.6048,-.1400,-.3697,-.5035,.4933)*f2_0+
    mat4(.2169,.3269,-.0746,.1201,.0791,.0114,.0206,.1545,-.2629,-.1248,.5481,-.8177,-.1561,.0681,-.0150,.3439)*f2_1+
    mat4(.2138,.3844,-.3090,.0741,.1385,.4405,.2029,-.4589,.4596,.5381,.0465,.2362,.3048,.6627,-.4239,-.3463)*f2_2+
    mat4(.1723,-.8027,-.0347,-.1695,.3260,.1486,.0896,.6103,-.0013,.2985,.3479,-.6133,-.2496,-.6317,.4013,.4711)*f2_3+
    mat4(-.5099,-.4188,.5125,-.3464,-.3791,.2073,-.7667,.7063,-.4004,-.1388,.2130,.3167,.1130,.2000,.3347,-.8300)*f2_4+
    mat4(.4484,.1285,-.2463,.5717,-.0044,.4693,.0008,.1456,-.1677,.1174,.6092,.5239,.1347,.1279,.0775,.6546)*f2_5+
    vec4(-.9035,-1.5196,-.7785,-.0125))/1.73+f2_3;
vec4 f3_4=sin(mat4(.3304,-.8994,-.4839,.4736,.0486,-.9699,.0285,-.1045,-.1216,.2780,-.7396,-.1372,-.2484,-.0911,-.1853,-.0819)*f2_0+
    mat4(.2069,-.3092,-.4124,-.1983,-.2677,.0712,.2682,.1226,.0149,-.0401,.4273,.6750,-.0024,-.1839,-.4116,-.1584)*f2_1+
    mat4(.2000,.1654,.4919,.1594,-.4273,.6193,-.6226,-.3760,.7886,.3578,-.4967,-.4694,.0595,1.2477,-.3629,.0441)*f2_2+
    mat4(.4713,-.1136,.8300,.2571,.5826,.1809,-.7185,.1629,-.1892,.3205,.6238,-.2458,.6573,-.7626,.3358,.6278)*f2_3+
    mat4(-.0569,-.4071,.6056,-.2143,.0050,-.7672,.0685,.2976,.5013,-.5485,.0275,-.2951,-.5145,.7914,.6168,-.1952)*f2_4+
    mat4(1.0848,-.0590,-.6325,-.3758,-.3727,.5307,-.2305,.0600,-.2103,-.3392,.2469,.2512,.5764,-.3839,.3681,-.1133)*f2_5+
    vec4(-2.0616,-.0237,2.2640,.4176))/1.73+f2_4;
vec4 f3_5=sin(mat4(.3557,.3146,-.6437,-.2685,.2421,-.0071,-.1016,-.0506,.6434,-.0866,-.1555,-.2972,.2422,-.0429,-.4653,-.3587)*f2_0+
    mat4(.5265,-.2937,-.3850,-.7797,.2863,.0180,.4691,.3151,-.6624,.4976,.4985,.1544,-.2337,-.0839,-.5113,-.2102)*f2_1+
    mat4(.6782,-.0824,.4690,.4908,.4257,-.4245,-.1256,.8856,.4779,-.2520,-.3748,.1989,.3917,.2946,.2704,-.1324)*f2_2+
    mat4(-.5988,.3658,-.0877,-.5959,-.1287,-.5297,.2109,-.1274,-.4820,.2704,-.1191,.1644,-.3760,.2106,-.0316,-.4539)*f2_3+
    mat4(-.2109,-.1110,-.2144,-.0249,-.2984,.2375,.1232,-.3942,-.2331,-.1023,-.4335,-.4542,-.0517,-.3889,-.3136,.2895)*f2_4+
    mat4(.3102,-.5298,-.1159,-.4290,.1718,-.6593,-.3391,.0445,.3194,.2787,-.4793,-.6946,-.2077,-.4295,-.0361,.1649)*f2_5+
    vec4(1.9255,-1.1158,-1.8128,-.1840))/1.73+f2_5;
float d= dot(f3_0,vec4(.0347,-.0107,-.0543,.0644))+
    dot(f3_1,vec4(-.0170,-.0194,-.0619,.0196))+
    dot(f3_2,vec4(.0314,-.0260,.0487,-.0289))+
    dot(f3_3,vec4(.0033,.0437,-.0341,.0535))+
    dot(f3_4,vec4(-.0195,-.0475,-.0601,-.0310))+
    dot(f3_5,vec4(-.0372,.0297,-.0336,.0382))+
    -0.122;
    return max(d, length(p-vec3(0,0,.25))-1.);
}

// Function 1930
vec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)
{
	vec2 TexelSize = MipBias/iChannelResolution[0].xy;
    
    vec3  Color = texture(Tex, Coord, MipBias).rgb;
    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    

    Color = Color/9.0;
    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);
    return 1.0-(1.0-Screen)*saturate(1.0-Highlight*Intensity);
}

// Function 1931
float font2d_dist(vec2 tpos, float size, vec2 offset) {

    float scl = 0.63/size;
    vec2 uv = tpos*scl;
    vec2 font_uv = (uv+vec2(0.5, 0.5)+offset)*(1.0/16.0);
    
    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;
    
    vec2 dist = abs(uv + vec2(0.0, 0.05)) - vec2(0.4);
    float b = max(dist.x, dist.y);
        
    return max(k-0.5 + 1.0/256.0, b)/scl;
    
}

// Function 1932
float distToSurface(Camera c, out vec3 ip, out float id) {
    float depth = NEAR;
    for (int i=0; i<MAXSTEPS; i++) {
        ip = c.pos + c.dir * depth;
        vec2 distToScene = sceneSDF(ip);
        id = distToScene.y;
        if (distToScene.x < EPSILON) {
            return depth;
        }
        depth += distToScene.x;
        if (depth >= FAR) {
            return FAR;
        }
    }
    return depth;
}

// Function 1933
float starDist(in vec2 off) {
    
    vec2 starST = st - vec2(0.500,0.460)+off;
    
    starST = starST*(1.+1.176*abs(sin(atan(starST.x,starST.y)*2.5+iTime*0.9040)));
    starST = abs(starST);
    
    return length(starST);
}

// Function 1934
vec2 map(vec3 pos)
{
    vec3 cp = vec3(0.0,0.0,0.0);
    
    vec2 res = opU(vec2(sdPlane(pos - vec3(0.0,0.0,0.0) + cp),1.0),
                   vec2(sdSphere(pos - vec3(0.0,0.5,0.0) + cp,0.5),46.9));
    
    float b = opBlend(udBox(pos - vec3(1.0,0.5,0.0) + cp,vec3(0.5,0.5,0.5)),
                      sdSphere(pos - vec3(1.0,0.5,0.0) + cp,0.5),(sin(iTime)+1.0)/2.0);
    res = opU(res, vec2(b,78.5));
    
    b = opI(udBox(pos - vec3(-1.0,0.5 * (sin(iTime)+1.0)/2.0,0.0) + cp,vec3(0.5,0.5,0.5)),
            sdSphere(pos - vec3(-1.0,0.5,0.0) + cp,0.5));
    res = opU(res, vec2(b,129.8));
    
    b = opS(sdSphere(pos - vec3(-1.0,0.5,-1.0) + cp,0.5),
            udBox(pos - vec3(-1.0,0.5 * (sin(iTime))/1.0,-1.0) + cp,vec3(0.5,0.5,0.5)));
    res = opU(res, vec2(b,22.4));
    
    return res;
}

// Function 1935
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c1, c2, vn;
  float dstObj, dstGrnd, dstPropel, f, dif, sh, bk;
  int idObjT;
  dstGrnd = GrndRay (ro, rd);
  dstPropel = TransObjRay (ro, rd);
  idObj = -1;
  dstObj = ObjRay (ro, rd);
  if (idObj < 0) dstObj = dstFar;
  if (min (dstObj, dstGrnd) < dstPropel) dstPropel = dstFar;
  if (dstObj < dstGrnd) {
    ro += dstObj * rd;
    idObjT = idObj;
    vn = ObjNf (ro);
    idObj = idObjT;
    col4 = FlyerCol (flyerMat[0] * vn); // [0]!
    if (idObj == 256 + idWing || idObj == 256 + idHstab) {
      vn.yz = Rot2D (vn.yz, -0.6 * qHit.z / fusLen);
      vn = VaryNf (100. * ro, vn, 0.05);
    } else if (idObj == 256 + idFin) {
      vn.xz = Rot2D (vn.xz, -0.6 * qHit.z / fusLen);
    }
    dif = max (dot (vn, sunDir), 0.);
    sh = ObjSShadow (ro, sunDir);
    bk = max (dot (vn.xz, - normalize (sunDir.xz)), 0.);
    col = col4.rgb * (0.2 + 0.2 * bk + 0.6 * sh * max (0., dif)) +
       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);
    col = sqrt (clamp (col, 0., 1.));
  } else if (dstGrnd < dstFar) {
    ro += dstGrnd * rd;
    vn = VaryNf (3.2 * ro, GrndNf (ro, dstGrnd), 1.5);
    col = GrndCol (ro, vn);
    sh = GrndSShadow (ro, sunDir);
    bk = max (dot (vn.xz, - normalize (sunDir.xz)), 0.);
    col *= (0.7 + 0.3 * sh) * (0.2 + 0.4 * bk +
       0.7 * max (0., max (dot (vn, sunDir), 0.)));
    f = dstGrnd / dstFar;
    f *= f;
    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));
  } else col = SkyCol (ro, rd);
  if (dstPropel < dstFar) col = vec3 (0.1) * (1. -
     0.3 * SmoothBump (0.25, 0.27, 0.006,
     length (qHitTransObj.xy) / fusLen)) + 0.7 * col;
  return clamp (col, 0., 1.);
}

// Function 1936
float semiCircleDist(vec2 p, float radius, float angle, float width)
{
  width /= 2.0;
  radius -= width;
  return substract(pie(p, angle + sin(iTime)*55.), 
                       abs(length(p) - radius) - width);
}

// Function 1937
vec2 GetDistanceCandle( const in vec3 vPos )
{
	vec2 vProfilePos = vec2( length(vPos.xz), vPos.y );
	
	float fDistance = vProfilePos.x - 0.2;
		
	float fDistanceTop = GetDistanceWaxTop(vPos);
	
	if(fDistanceTop > fDistance)
	{
		fDistance = fDistanceTop;
	}
	
	return vec2(fDistance, kMaterialWax);
}

// Function 1938
vec3 normalMap( in vec2 pos )
{
	pos *= 2.0;
	
	float v = texture( iChannel3, 0.015*pos ).x;
	vec3 nor = vec3( texture( iChannel3, 0.015*pos+vec2(1.0/1024.0,0.0)).x - v,
	                 1.0/16.0,
	                 texture( iChannel3, 0.015*pos+vec2(0.0,1.0/1024.0)).x - v );
	nor.xz *= -1.0;
	return normalize( nor );
}

// Function 1939
float map(vec3 p)
{
    float d0=dot(sin(p),cos(p.yzx))  +.3 * dot(sin(p*3.),cos(p.yzx*3.));
    float d2=length(p)-9.;
    float d=smax(-d0,d2,3.);   
    return clamp(d,-.5,+.5);
}

// Function 1940
vec2 map(in vec3 pos, out float rad) {

    
    float minDist = 10000000.0;
    float xStep = MAX_ORBIT_DIST / float(NumSpheres);
    float maxRadius = (xStep * 2.0 / 2.0);
    float zPos = 3.0;
    float yPos = 0.0;
    
    float distFromCenter = length(pos.xy);
    
    //if(distFromCenter > MAX_ORBIT_DIST + maxRadius) {distFromCenter = MAX_ORBIT_DIST;}
    
    float sphereNum = distFromCenter / xStep;
    
    //optimizations, no loops, only calculate nearest 2 spheres
    //distinct orbits should keep there from ever being 3 all in mutual contact
    
    //get the closest two spheres by radius from origin
    float sphere0 = floor(sphereNum);
    if(sphere0 > float(NumSpheres) ) {sphere0 = float(NumSpheres);}
    float sphere1 = ceil(sphereNum);
    if(sphere1 > float(NumSpheres) ) {sphere1 = float(NumSpheres);}
    
    //get relevant info about each sphere
    float rotDir0 = mod(sphere0, 2.0);
    float rotDeg0 = fract( (sphere0 + 1.0) * SPEED * iTime) * TWOPI;
    mat2  rotAmt0 = rotate(rotDeg0);
	float sampX0  = sphere0 / float(NumSpheres);
    float amp0    = texture(iChannel0, vec2(sampX0, 0.25)).x;
    float xDist0   = sphere0 * xStep + 0.01;
    if(rotDir0 == 1.0) {xDist0 = -xDist0;}
    vec3 spherePos0 = vec3(vec2(0. + xDist0, yPos) * rotAmt0, zPos);
    float rad0  = amp0 * pow(1.01,sphere0)* maxRadius + 0.01;
    float dist0 = sdfSphere(spherePos0, pos, rad0);
    
    float rotDir1 = mod(sphere1, 2.0);
    float rotDeg1 = fract( (sphere1 + 1.0) * SPEED * iTime) * TWOPI;
    mat2  rotAmt1 = rotate(rotDeg1);
	float sampX1  = sphere1 / float(NumSpheres);
    float amp1    = texture(iChannel0, vec2(sampX1, 0.25)).x;
    float xDist1  = sphere1 * xStep + 0.01;
    if(rotDir1 == 1.0) {xDist1 = -xDist1;}
    vec3 spherePos1 = vec3(vec2(0. + xDist1, yPos) * rotAmt1, zPos);
    float rad1 =  amp1 * pow(1.01,sphere1)* maxRadius + 0.01;
    float dist1 = sdfSphere(spherePos1, pos, rad1);
    
    rad = rad0 / maxRadius;
    
    minDist = smin(minDist, dist0, 0.04);
    
    if(dist1 < minDist) {rad = rad1 / maxRadius;}
    minDist = smin(minDist, dist1, 0.04);
    
    
    /*
    for(int i = 0; i < NumSpheres; i++) {
        float rotDir = mod(float(i), 2.0);
        float rotDeg =fract( (float(i) + 1.0) * SPEED * iTime) * TWOPI;
        //rotDeg = rotDeg + (TWOPI / float(NumSpheres));
        //if(rotDir == 1.0) {rotDeg = -rotDeg;}
        mat2 rotAmt = rotate(rotDeg);
        float xDist = float(i) * xStep + 0.01;
        if(rotDir == 1.0) {xDist = -xDist;}
        vec3 spherePos = vec3(vec2(0. + xDist, yPos) * rotAmt, zPos);
		float sampX = float(i) / float(NumSpheres);
        float amp = texture(iChannel0, vec2(sampX, 0.25)).x;
        float dist = sdfSphere(spherePos, pos, amp * pow(1.01,float(i))* maxRadius + 0.01);
        if(dist < minDist) { rad = (amp * pow(1.01,float(i))* maxRadius + 0.01) / maxRadius;}
        minDist = smin(minDist, dist, 0.04);
    }
    */
    return vec2(1.0, minDist);
}

// Function 1941
float map(vec3 p)
{
    float a = iTime;
    float c, s; vec3 q = p;
	c = cos(a); s = sin(a);
	p.y = c * q.y - s * q.z;
	p.z = s * q.y + c * q.z;
    
    q = p;
	c = cos(a); s = sin(a);
	p.x = c * q.x - s * q.z;
	p.z = s * q.x + c * q.z;
    
    vec3 d = abs(p) - vec3(.5);
	return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 1942
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn;
  float dstObj, sh;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);
    if (idObj == 1) col = (ro.z < -0.6 || ro.z < 0. && length (vec2 (abs (ro.x), ro.y) -
       vec2 (0.3, 2.)) < 0.2) ? vec3 (0.9) : vec3 (0.1, 0.1, 0.15);
    else if (idObj == 2) col = vec3 (1., 0.8, 0.2);
    else if (idObj == 3) col = vec3 (0.05, 0.1, 0.05);
    else if (idObj == 4) col = vec3 (0.8, 0.8, 0.);
    else if (idObj == 5) col = vec3 (0.9, 0.9, 0.);
    else if (idObj == 6) col = vec3 (0.15, 0.15, 0.2);
    sh = ObjSShadow (ro, ltDir);
    col = col * (0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.)) +
       0.2 * smoothstep (0.9, 1., sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
  } else col = vec3 (0.6, 0.6, 1.);
  return clamp (col, 0., 1.);
}

// Function 1943
vec3 sdfNormal(vec3 p, float epsilon, bool detail)
{
    vec3 normal = vec3(0.0);
    float s = sdf(p, detail);
    
    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, detail) - s;
    }
    
    return normalize(normal);
}

// Function 1944
float sdf( vec3 p )
{
    return
        min(min(min(min(min(
        	max(max(max(
                length(p)-1.,
                .3 - length((p-vec3(.5,0,0)).xz)),
                .3 - length((p-vec3(-.25,0,-.5)).xz)),
                dot(p,normalize(vec3(-1,0,-2)))-.4 + .003*sin(p.y*100.)
            ),
            max(max(
                length(p-vec3(0,-.5,1.2))-.5,
                .45-length(p-vec3(0,-.5,1.2))),
                dot(p-vec3(0,-.5,1.2),normalize(vec3(1,2,-3)))
            )),
            length(p-vec3(0,-.5,1.2))-.3),
			max(
                length(p.xz)-.5,
                p.y+.9
            )),
            max(
                length((p-vec3(-.25,0,-.5)).xz) - .22,
                dot(p,normalize(vec3(-1,4,-2)))-.95
            )),
            p.y + 1.
        );
}

// Function 1945
float CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}

// Function 1946
float Map(in vec3 p)
{
	float h = Terrain(p.xz);
    return p.y - h;
}

// Function 1947
float sceneSDF(vec3 samplePoint) {
    
    float sine = 1.+(cos(2.*iTime)+1.);
    
    float cubeSDF_value1 = dotsCubeSDF(samplePoint*2. + vec3(SQRT3*0.5,SQRT3*0.5,SQRT3*0.5		)
                                  		* sine)*0.5;
    float cubeSDF_value2 = dotsCubeSDF(samplePoint*2. + vec3(-SQRT3*0.5,SQRT3*0.5,SQRT3*0.5		)
                                  		* sine)*0.5;
    float cubeSDF_value3 = dotsCubeSDF(samplePoint*2. + vec3(SQRT3*0.5,-SQRT3*0.5,SQRT3*0.5		)
                                  		* sine)*0.5;
    float cubeSDF_value4 = dotsCubeSDF(samplePoint*2. + vec3(SQRT3*0.5,SQRT3*0.5,-SQRT3*0.5		)
                                  		* sine)*0.5;
    float cubeSDF_value5 = dotsCubeSDF(samplePoint*2. + vec3(-SQRT3*0.5,-SQRT3*0.5,SQRT3*0.5	)
                                  		* sine)*0.5;
    float cubeSDF_value6 = dotsCubeSDF(samplePoint*2. + vec3(SQRT3*0.5,-SQRT3*0.5,-SQRT3*0.5	)
                                  		* sine)*0.5;
    float cubeSDF_value7 = dotsCubeSDF(samplePoint*2. + vec3(-SQRT3*0.5,SQRT3*0.5,-SQRT3*0.5	)
                                  		* sine)*0.5;
    float cubeSDF_value8 = dotsCubeSDF(samplePoint*2. + vec3(-SQRT3*0.5,-SQRT3*0.5,-SQRT3*0.5	)
                                  		* sine)*0.5;
    
    float cubesSDF_value = 
        min(
            min(
                min(
                    min(
                        min(
                            min(
                                min(cubeSDF_value1,
                                    cubeSDF_value2),
                                cubeSDF_value3),
                            cubeSDF_value4),
                        cubeSDF_value5),
                    cubeSDF_value6),
                cubeSDF_value7),
            cubeSDF_value8);
    
    //float cubeSDF_value = cubeSDF(samplePoint);
    
    //float sphereSDF_value = sphereSDF(samplePoint, vec3(0.), SQRT3*(1.-(sin(2.*iTime)+1.)*0.2));
    float sphereSDF_value = sphereSDF(samplePoint +displace(samplePoint),
                                      vec3(0.),
                                      SQRT3*(1.-pow(cos(2.*iTime)+1.,1.5)*0.2));
    
    //float shapeSDF_value = mix(cubesSDF_value, sphereSDF_value, 0.1*abs(sin(8.*iTime)));
    
    //float dotsShapeSDF_value = mix(shapeSDF_value, dotsSDF_value, 0.25+0.4*abs(cos(4.*iTime)));
    
    //float dotsCubesSDF_value = max(cubesSDF_value, dotsSDF_value);
    
    float dotsShapeSDF_value = smin(cubesSDF_value, sphereSDF_value, 0.3);
    //float dotsShapeSDF_value = max(cubesSDF_value, sphereSDF_value);
    
    return dotsShapeSDF_value;

    
}

// Function 1948
float dist(in vec2 p, in vec2 b){
    
    // Just in case the shape directive is accidentally commented out.
    #ifdef SHAPE
    
    #if SHAPE == 0
    // Slightly rounded square.
    return sBoxS(p, b, sqrt(b.x)*.1);
    #elif SHAPE == 1
    // Circle.
    return length(p) - b.x*1.05;
    #else
    // Octagon, of sorts.
    p = abs(p);
    return max(max(p.x, p.y), (p.x + p.y)*.7071 - b.x/6.) - b.x;
    #endif
    
    #else
    return sBoxS(p, b, sqrt(b.x)*.1);
    #endif
}

// Function 1949
float map(vec3 p)
{	
return fBlob(p*0.3+1.8*sin(iTime));//-0.001*fbm(13.6*p);
}

// Function 1950
float map_the_world(in vec3 world_point)
{
    
 //   float sphere_0 = distance_from_sphere(p, vec3(-0.4 + cos(iTime), 0.0, 0.0), 1.5);    
 //   float sphere_1= distance_from_sphere(p, vec3(2.4 + sin(iTime), 1.0, 1.5), 1.5);
 //   float sphere_2= distance_from_sphere(p, vec3(-0.0 + cos(iTime+1.57), 2.0,3.0),1.5);
      
    float sphere_0 = distance_from_sphere(world_point, vec3(-0.4, 0.0, 0.0), 1.5);    
    float sphere_1= distance_from_sphere(world_point, vec3(2.4, 1.0, 1.0), 1.5);
    float sphere_2= distance_from_sphere(world_point, vec3(-0.0, 2.0,2.0),1.5);
    
    return min(min(sphere_0, sphere_1), sphere_2);
}

// Function 1951
float manhatanDistance(vec2 pointA, vec2 pointB)
{
    return abs(pointA.x - pointB.x) + abs(pointA.y - pointB.y);
}

// Function 1952
float sceneSDF(vec3 p) {
    float sp_a = sphereSDF(p, Sphere(vec3(0., 0., 0.), 0.28, vec3(1., 1., 1.)));
    float box = boxSDF(p + vec3(0.,.3, 0.), vec3(0.5, 0.1, 0.5));

    float obj = min(sp_a, box);
    return obj;
}

// Function 1953
vec3 ToneMap_Uncharted2(vec3 color)
{
    float A = 0.15; // 0.22
	float B = 0.50; // 0.30
	float C = 0.10;
	float D = 0.20;
	float E = 0.02; // 0.01
	float F = 0.30;
	float W = 11.2;
    
    vec4 x = vec4(color, W);
    x = ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
	return sRGMGamma(x.xyz / x.w);
}

// Function 1954
vec4 sceneDistance(vec2 p, inout vec4 fragColor)
{
    float modTime = 4.;
    modTime = mod((iTime-4.),maxTime);
    
    vec2 darwinP = tX(p, vec2(0.5, -0.01));
    if (modTime > 8.) {
        isDarwinWalking = false;
        darwinP = tX(p, vec2(0.2, -0.01));
        bothHighFiving = true;
    } else {
        darwinP = tX(p, vec2(1.-(modTime/100.)*10., -0.01));
    }
    
    darwin(darwinP, fragColor, modTime);
    
    if (modTime > 9.6) {
        float percentIncrease = clamp((modTime-10.)/1.4, 0.0001, 1.);
        float percent = 12.*percentIncrease;
        vec2 star = vec2(sdfStar5(tX(p, vec2(-0.01, -0.01))/percent)*percent, 22.0);
        draw(p, star, fragColor);
    }
    
    return fragColor;
}

// Function 1955
vec3 trn_ripplemapLod( vec3 pos, float scale )
{
    float lod = log2( scale / 0.001 );
    return .20 * texturenoiseLod( pos / .01, lod - 3.322 ).xyz +
        .30 * texturenoiseLod( pos / .003, lod - 1.585 ).xyz +
        .30 * texturenoiseLod( pos / .001, lod ).xyz +
        .20 * texturenoiseLod( pos / .0003, lod + 1.585 ).xyz;
}

// Function 1956
float scene (vec3 p)
{
    float parkingWalls = min (min (parkingWall1 (p), parkingWall2 (p)), min (parkingWall3 (p), text (p)));
	return min (min (parkingFloor(p), parkingCeil(p)), parkingWalls);
}

// Function 1957
SceneResult Scene_GetDistance( const vec3 vPos )
{
    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );
        
	if ( g_scene.bCharacter )
    {
	    result = Scene_Union( result, Character_GetDistance( vPos ) );
    }

    {
/*        float fDist = Segment( vPos, vec3(-10,10,0), vec3(13, 10, 0), 1., 1. );
        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    

        float fDist2 = Segment( vPos, vec3(-12,6,0), vec3(-4, 10, 0), 2., 1. );
        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );    */
        
        vec3 vStart = g_scene.vWeaponStart;
        vec3 vDir = g_scene.vWeaponDir;
        float fDist = Segment( vPos, vStart, vStart + vDir * 23.0, 1., 1. );
        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    

        float fDist2 = Segment( vPos, vStart + vDir * -2. + vec3(0,-4,0), vStart + vDir * 6., 2., 1. );
        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );
    }
    
    if ( g_scene.bArmor )
    {        
	    result = Scene_Union( result, Armor_GetDistance( vPos ) );
    }
    
    return result;
}

// Function 1958
float map(vec3 p){
    
    // One layer of noise at isolevel "0.3" - I have no idea whether that's the
    // correct terminology. :)
    return noise3D(p*2.) - .3;
    
    // Two layers. The texture based 3D algorithm does this with ease, even on
    // slower machines, but the function based one starts having trouble. 
    // By the way, you need to load up the correct noise texture with the correct 
    // "vFlip" setting, if you wish to use this.
    //return noise3DTex(p*2.)*.66 + noise3DTex(p*4.)*.34 - .4;
	
}

// Function 1959
vec2 map( in vec3 pos )
{
    float size = 3.5;
    #ifdef BOX
    float res = qbox(pos,size);
    #else
     float res = sphere(pos,size);
    #endif
    pos+=size;
    
    float t = iTime;
    for(float i = 0.0; i<loops;i++){
        size /= 3.0;
        
        float b = box(opRep(pos,vec3(size*6.,size*6.,0)),vec3(size,size,10.));
        res = opS(res,b);
        b = box(opRep(pos,vec3(size*6.,0.,size*6.)),vec3(size,10.,size));
        res = opS(res,b);
        b = box(opRep(pos,vec3(0.,size*6.,size*6.)),vec3(10.,size,size));
        res = opS(res,b);
    }
	
    return vec2(res,1.0);
}

// Function 1960
float sea_fragment_map(vec3 p) 
{
    vec2 uv = p.xz * vec2(0.85, 1.0); 
    
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;  
    float choppy = SEA_CHOPPY;
	
    float d = 0.0;
    float h = 0.0;    
    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) 
    {	    
    	d =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);
		d += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy); 
		h += d * amp;
	
		freq *= SEA_FREQ_MUL; 
		amp  *= SEA_AMPLITUDE_MUL;
	
		choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);
	
		uv *= octave_matrix;
    }
    return p.y - h;
}

// Function 1961
float distFunc( vec3 point )
{
	//	parameters
	int circleTiles = 64;
	float radius = 4.;
	vec3 cubeSize = vec3(0.1);

	//	distance to floor plane
	float planeDist = sdPlane(point);

	//	distances to the cube circles
	float cubesCircleBigDist = cubeCircle(point, radius, circleTiles, cubeSize);
	float cubesCircleSmallDist = cubeCircle(point, radius/2., circleTiles/2, cubeSize);

	//	black cube in the center
	point.y -= 1.0;
	rotateAxis(point.yz, radians(45.0));
	rotateAxis(point.xy, PI/4.);
	float boxDist = fBox( point, 5.*cubeSize*afFrequencies[1] );

	//	return closest object
	return min(min(min(cubesCircleBigDist, boxDist), cubesCircleSmallDist), planeDist);
}

// Function 1962
vec3 map( in vec3 p )
{
	vec3 q = p;
	q.xz = -q.xz;
	q*=starTrans.w;
	q-=starTrans.xyz;
	
	vec2 distStar = distanceStar(q);
	vec2 distZ = distanceZ(q);
	vec2 distMarker = distanceMarker(p);
	
	vec2 res = distStar.xy;
	if (distZ.x < res.x) res = distZ;
	if (distMarker.x < res.x) res = distMarker;
	
	return vec3(res,distZ.x); // we need the distance to the Z in order to compute glow 
}

// Function 1963
vec2 sampleScene(vec3 p, vec3 n)
{
    vec2 energy = vec2(0);

    vec3 ln = normalize(cross(ls, lt));
    float lightArea = length(ls) * length(lt);
    int count = 1;
    for(int i = 0; i < count; ++i)
    {
        vec3 ro = p + n * 1e-4;
        vec3 rd = lambertNoTangent(n, vec2(rand(), rand()));

        energy += sampleRay(ro, rd);
        energy += sampleLight(ro, n) * lightRadiance * lightArea;
    }

    energy /= float(count);
    return energy;
}

// Function 1964
vec4 col_scene(vec4 p) {
	vec4 col = col_fractal(p);
	vec4 col_f = col_flag(p);
	if (col_f.w < col.w) { col = col_f; }
	vec4 col_m = col_marble(p);
	if (col_m.w < col.w) {
		return vec4(col_m.xyz, 1.0);
	}
	return vec4(col.xyz, 0.0);
}

// Function 1965
float Map(in vec3 p)
{
	float h = Terrain(p.xz);
		

	float ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;
	treeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;
	treeCol = Trees(p.xz);
	h += treeCol;
	
    return p.y - h;
}

// Function 1966
float distField(vec2 p){
    
    // Cell ID and local cell coordinates.
    vec2 ip = floor(p) + .5;
    p -= ip;
    
    // Some random numbers.
    float rnd = hash21(ip + .37);
    float rnd2 = hash21(ip + .23);
    float rnd3 = hash21(ip + .72);
 
    
    // Cell boundary.
    float bound = sBox(p, vec2(.5)); 
    
    
    float d = 1e5; // Distance field.
    
    // Random 90 degree cell rotation.
    p *= rot2(floor(rnd*64.)*3.14159/2.);
    
     
    // Just adding a tiny hole to draw the eye to the... No idea why artists do 
    // this kind of thing, but it enables them to double the price, so it's
    // definitely worth the two second effort. :)
    float hole = 1e5;
    
    
    #ifdef LINE_TRUCHET
    
    // Three tiled Truchet pattern consisting of arc, straight line 
    // and dotted tiles.
    
    // Four corner circles.
    vec2 q = abs(p);
    float cir = min(length(q - vec2(0, .5)), length(q - vec2(.5, 0)));
    
    if(rnd3<.75){
        if(rnd2<.65){
            d = abs(min(length(p - .5), length(p + .5)) -.5) - .5/3.;
            
        }
        else {
            p = abs(p) - .5/3.;
            d = min(max(p.x, -(p.y - .5/8.)), p.y);
        }
        
    }
    else {
        // Four dots in the empty squares to complete the pattern.
        d = cir - .5/3.;
    }
    
    // Corner holes.
    hole = cir -.05;
    
    #else
    // Very common quarter arc and triangle Truchet pattern, which is a 
    // favorite amongst the abstract art crowd.
    if(rnd3<.75){;
        
        // Corner holes.
        hole = length(p - .325) - .05;
                 
        if(rnd2<.5){
            // Corner quarter circle... Well, it's a full one,
            // but it gets cut off at the grid boundaries.
            d = length(p - .5) - 1.;
        }
        else {
            // A corner diamond, but we'll only see the triangular part.
            p = abs(p - .5);
            d = abs(p.x + p.y)/sqrt(2.) - .7071;
        }
    }
    #endif
    
    #ifdef HOLES
    d = max(d, -hole);
    #endif
    
    // Cap to the cell boundaries. Sometimes, you have to do this
    // to stop rendering out of bounds, or if you wish to include
    // boundary lines in the rendering.
    //
    return max(d, bound);
}

// Function 1967
vec3 SampleScene(vec3 marchingPosition, vec3 rayDirection){
    // Unique light source
	vec3 lightDirection = normalize(vec3(-1., 1., -1.));
    vec3 color;
    RayPayLoad rayResult = RayMarch(marchingPosition, rayDirection, 0.);
    if (rayResult.hitScene){
        // Shading
        Material matOfClosestObj = rayResult.obj.material;
        bool useShadows = true;
        // main directional light
        LightSampleResult lightSample = SampleLight(rayResult.hitPosition, rayResult.normal, -rayDirection, lightDirection, vec3(10.), matOfClosestObj, useShadows);
        color = lightSample.contrib;
        // bounce light
        float bounce = clamp(dot(rayResult.normal, vec3(0.,-1., 0.)), 0., 1.);
        color += bounce * vec3(0.2, 0.6, 0.9) * 0.2;
        // ambiant
        color += rayResult.obj.material.diffuse * 0.1;
        // point light
        vec3 lightPos = vec3(.5, 2. * pow(0.5 + 0.5 * sin(2. * iTime), 2.), 3.);
        vec3 toEye = normalize(marchingPosition - rayResult.hitPosition);
        vec3 reflectionDir = 2. * dot(toEye, rayResult.normal) * rayResult.normal - toEye;
        RayPayLoad reflectRay = RayMarch(rayResult.hitPosition, reflectionDir, rayResult.marchedDistance);
	    vec3 reflColor = texture(iChannel0, reflectionDir).xyz;
        if (reflectRay.hitScene){
	        vec3 reflColor = reflectRay.obj.material.diffuse;
        }
        float reflectCoef = matOfClosestObj.reflectivity;
        if (rayResult.obj.type == OBJECT_TYPE_PLANE){
            reflectCoef = smoothstep(reflectCoef, 0.95, rayResult.marchedDistance / 100.);
        }  
        return mix(color, reflColor, reflectCoef);
    }
    return texture(iChannel0, rayDirection).xyz;
}

// Function 1968
float atmos_dist(in float dir_y) {
	// r^2 * dir_x^2 + (earth_rad + r *dir_y)^2 =
    // (atmos_thick + earth_rad)^2
    // r^2 * (dir_x^2 + dir_y^2) + 
    // r * 2.0 * dir_y * earth_rad +
    // earth_rad^2 -
    // (atmos_thick + earth_rad)^2 = 0.0
    // -------------------------------
    // r^2 * (dir_x^2 + dir_y^2) + 
    // r * 2.0 * dir_y * earth_rad -
    // atmos_thick^2 -
    // 2.0 * atmos_thick * earth_rad = 0.0
    // -------------------------------
    //r = (-b + sqrt(b^2 - 4ac)) / (2a)
    // a = 1.0
    // b = 2.0 * dir_y * earth_rad
	// c = -atmos_thick^2 - 2.0 * atmos_thick * earth_rad
    // r approx 
    // -dir_y*earth_rad + sqrt(dir_y^2+1.005)*earth_rad
    float b = 2.0 * dir_y * earth_rad;
    float c = -atmos_thick * atmos_thick - 2.0 * atmos_thick * earth_rad;
    return 0.5 * (sqrt(b * b - 4.0 * c) - b);
}

// Function 1969
DistId map(vec3 pos) {
    // Draw floor
    DistId res = DistId(sdPlane(pos, vec3(0,1,0), -.5), 0);
    // Draw marbles
    int n = int(iTime / dt);
    for (int i = -3; i < 3; i++) {
        if (n - i < 0) break;
        int ni = (n - i) % NUM_NOTES;
        float ti = iTime - float(n - i)*dt - DELAY;
        for (int ch = 0; ch < NUM_CHANNELS; ch++) {
            //int note = (4*(ch-1) + 79) * int(ni % 2==0);
            int note = getNote(ch, ni);
            if (note > 0) {
                float x = float(note - 79);
                float y = ti < 0. ? -10.*ti*(ti+3.) : -10.*ti*(ti-1.);
                float z = ti < 0. ? 0. : 10.*ti;
                res = opUnion(res, DistId(sdSphere(pos - vec3(x,y,z), .5), 1));
            }
        }
    }
    return res;
}

// Function 1970
float MicrofacetDistribution(vec3 halfVec, vec3 normal, float roughness)
{
    float alpha = roughness * roughness;
    float dotNH = dot(normal, halfVec);
    float f = (dotNH * alpha - dotNH) * dotNH + 1.;
    return alpha / (PI * f * f);
}

// Function 1971
float sdf(vec3 position){
    vec3 dc, ec;
    return sdf(position, dc, ec);
}

// Function 1972
float dist(vec3 p){
    vec3 pp = p;
    float scale = 2.0;
    float offset = 12.0;
    
    int n = 0;
    for(int i= 0; i < ITERATIONS; ++i){
        ++n;
        if(pp.x+pp.y < 0.0){
            pp.xy = -pp.yx;
        }
        if(pp.x+pp.z < 0.0){
            pp.xz = -pp.zx;
        }
        if(pp.y+pp.z < 0.0){
            pp.zy = -pp.yz;
        }
        pp = pp*scale-offset*(scale-1.0);
        
    }
    return length(pp)*pow(scale, -float(n));
}

// Function 1973
vec4 icosahedronAxisDistance(vec3 p) {
    vec3 iv = icosahedronVertex(p);
    vec3 originalIv = iv;

    vec3 pn = normalize(p);
    pModIcosahedron(pn);
    pModIcosahedron(iv);

    float boundryDist = dot(pn, vec3(1, 0, 0));
    float boundryMax = dot(iv, vec3(1, 0, 0));
    boundryDist /= boundryMax;

    float roundDist = length(iv - pn);
    float roundMax = length(iv - vec3(0, 0, 1.));
    roundDist /= roundMax;
    roundDist = -roundDist + 1.;

    float blend = 1. - boundryDist;
	blend = pow(blend, 6.);
    
    float dist = mix(roundDist, boundryDist, blend);

    return vec4(originalIv, dist);
}

// Function 1974
void scene(in vec3 x, out vec2 sdf)
{
    sdf.y = 1.;
    mfnoise(x.xy, 1., 400., .45, sdf.x);
    stroke(sdf.x, .5, sdf.x);
    sdf.x = x.z+.05*smoothstep(.35,.45,.5+.5*sdf.x)+.1*sdf.x;
    
    if(x.z>-.05)
    {
        float n2;
        mfnoise(x.xy, 30., 500., .47, n2);
        vec2 sda = vec2(x.z+.05+.01*n2, 1.);
        add(sdf, sda, sdf);
    }
    
    float R = .07+.1*sdf.x, dis;
    lfnoise(.5*x.y*c.xx, dis);
    vec2 sdb;
    vec2 ya = abs(x.xz-.4*dis*c.xy)+.045*c.yx - .065*c.xy;
    zextrude(x.y, -length(ya)+R, 1.e4, sdb.x);
    float da;
    stroke(sdb.x, .003, da);
    sdb.y = 2.;
    
    vec2 ind;
    float phi = atan(ya.y, ya.x);
    dhexagonpattern(vec2(56.,12.)*vec2(x.y, phi), dis, ind);
    stroke(dis, .2, dis);
    stroke(sdb.x, .003*step(dis,0.), sdb.x);
	sdf.x = max(sdf.x,-da);
    add(sdf, sdb, sdf);
    
    // Add guard objects for debugging
    float dr = .1;
    vec3 y = mod(x,dr)-.5*dr;
    float guard = -length(max(abs(y)-vec3(.5*dr*c.xx, .6),0.));
    guard = abs(guard)+dr*.1;
    sdf.x = min(sdf.x, guard);
}

// Function 1975
vec2 intersectSDF(vec2 dist0, vec2 dist1) {
    return dist0.x > dist1.x? dist0 : dist1;
}

// Function 1976
float remap (float x, float a, float b, float c, float d) 
{
	return (x-a)/(b-a)*(d-c) + c; 
}

// Function 1977
vec3 nmap(vec2 t, sampler2D tx, float str)
{
	float d=1.0/1024.0;

	float xy=texture(tx,t).x;
	float x2=texture(tx,t+vec2(d,0)).x;
	float y2=texture(tx,t+vec2(0,d)).x;
	
	float s=(1.0-str)*1.2;
	s*=s;
	s*=s;
	
	return normalize(vec3(x2-xy,y2-xy,s/8.0));
}

// Function 1978
float map(float x) {
    x += sin(iTime * 0.3) * 0.5;
    return max(-pow(x, 2.0)+0.3, abs(x) - 0.5) - 0.2;
}

// Function 1979
float SDF( vec3 pos )
{
	pos = FoldSpace(pos);
    
    return min(min(min(min(
        	TreeSDF(pos),
        	Baubles1(pos)),
        	Baubles2(pos)),
        	Baubles3(pos)),
        	Ground(pos));
}

// Function 1980
float map(vec3 p, mat3 rotMat)
{
	//float r = sdPlane(p - vec3(0,-1.5,0));	// Return distance
    float r = 1000.0;
	
    #define GS 0.1
    //mat3 rotMat = rotationMatrix(vec3(1,1,0), iTime);
    vec3 boxmod = mix(mod(p+vec3(GS),vec3(GS*2.0))-vec3(GS), p, step(0.55, sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,.5))) );
    //vec3 boxmod = mod(p+vec3(GS),vec3(GS*2.0))-vec3(GS);
    vec3 sizemod = mix(vec3(clamp(0.3-sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,0.5))*0.6, 0.0, GS) ), vec3(0), step(0.6, sdTorus(rotMat*stepround(p, vec3(GS)), vec2(2,.5))) );
    
    r = min(r, sdBox(boxmod, sizemod));
    return r;
}

// Function 1981
float rhombus_sdf(vec3 p, float la, float lb, float h, float ra)
{
    p = abs(p);
    vec2 b = vec2(la,lb);
    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );
    vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);
    return min(max(q.x,q.y),0.0) + length(max(q,0.0));
}

// Function 1982
Intersection unionSDF(Intersection A, Intersection B, float k) 
{
    float h = clamp( 0.5+0.5*(B.t-A.t)/k, 0.0, 1.0 );
    
    Intersection result;
    result.objHit = obj_mix;
    result.t = min(A.t, B.t);
    result.color = mix(B.color, A.color, h );
    return result;
}

// Function 1983
float rectangleSdf(vec3 p, float x, float y) {
    vec3 q = abs(p) - vec3(x, y, 0.0);
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Function 1984
float MapCover0(in vec3 pos)
{
	float re = MapPianoBodyShapeDist(-pos.x, pos.z);
	float re_2 = abs(pos.y) - 1.0;
	return Combine(re, re_2);
}

// Function 1985
float mapTest(vec3 p) {
    vec3 r = vec3(1.5,1.0,0.6);
    float k1 = length(p/r);
    float k2 = length(p/(r*r));
    return k1*(k1-1.0)/k2+0.1*sign(p.x+p.y+p.z);
}

// Function 1986
float sdf_line6(vec2 st, vec2 vert_a, vec2 vert_b){
    vec2 dvec_ap = st - vert_a;      // Displacement vector from vert_a to our current pixel!
    vec2 dvec_ab = vert_b - vert_a;  // Displacement vector from vert_a to vert_b
	vec2 direction = normalize(dvec_ab);  // We find a direction vector, which has unit norm by definition!
    return crossnorm_product(dvec_ap, direction);  // Ah, the mighty cross-norm product!
    //return crossnorm_product(dvec_ap, direction) / dot_product(dvec_ab, dvec_ab);  // I thought this would work, but it doesn't: AA is all messed up!
}

// Function 1987
vec3 BSDF_Oren_Nayar_GetIntensity(OrenNayarBsdf bsdf,vec3 n,vec3 v,vec3 l){
	float nl = max(dot(n, l), 0.);
	float nv = max(dot(n, v), 0.);
	float t = max(dot(l, v),0.) - nl * nv;
	if(t > 0.)
		t /= max(nl, nv) + INFINITY_MIN;
	float is = nl * (bsdf.a + bsdf.b * 0.1);
	return vec3(is);
}

// Function 1988
float sdfCylinder( vec3 p, vec2 h, mat4 t )
{
  p = vec3(t * vec4(p, 1));
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 1989
void gs_leave_map_mode( inout GameState gs )
{
    gs.switches &= ~GS_TRMAP;
    gs.mouselook = UNIT_X;
    gs.camzoom = 1.;
}

// Function 1990
float scene(vec3 p) {
  if (length(p) > 1.) return length(p)-.8;
  vec4 x=vec4(p,1),
    f00=sin(x*mat4(-2.8642,-.3379,-2.7027,-5.4688,-1.2987,1.5014,1.0576,-6.3755,.7673,4.3832,3.2235,-.1419,-.5399,3.9891,-4.0487,-2.6106)),
    f01=sin(x*mat4(-2.772,-.0207,1.3157,1.7662,.6899,1.2744,-1.1519,-.3993,-1.2571,-.402,-.7132,6.3622,3.1684,.0554,-.6135,-3.4258)),
    f02=sin(x*mat4(-1.4567,.096,3.5553,-9.4925,-3.1877,2.3829,-.9296,7.8893,-1.7056,-5.1025,-2.6482,8.9126,-.1828,-2.8303,-.5539,-11.0871)),
    f10=sin(mat4(.4505,1.5956,-.5472,-.3042,.0412,-.4421,-.493,.194,-.1884,-.5303,-.0601,.3374,-.1071,-.8499,.4856,.0535)*f00+mat4(.3647,-.5556,.7278,.5633,.3605,-1.1965,-.4925,-.6503,1.0365,1.9559,-1.1097,.0894,-.7398,-2.4927,.3003,.339)*f01+mat4(.6043,1.7006,.2699,-.2991,-.0221,-.5937,-1.1459,.4695,.1447,1.0216,.26,.0676,-.2637,-.7581,.0961,.7648)*f02+vec4(9.3643,12.644,12.7916,-10.6382)),
    f11=sin(mat4(.4995,.2089,.869,-.2955,1.4301,-.7122,-.5325,-.0552,-.0959,-.2575,.0183,.1338,-.0385,-.4212,-.2172,.0994)*f00+mat4(-.5923,.2933,.1271,.4928,.8332,.4304,-.7817,-.2401,-1.5708,-1.917,-1.228,.81,-1.0397,-1.6977,.7658,-.5163)*f01+mat4(.2709,-.0061,.5283,-.3079,-.1526,-.1579,-.6409,-.1957,.2534,-.0729,.2598,.0093,1.171,.2339,-.3809,.559)*f02+vec4(-6.8914,-2.9636,-3.2778,-2.3064)),
    f12=sin(mat4(.0305,-.3372,-.355,.2315,-.149,1.221,-.4418,.7355,.1737,-.3972,.3842,-.3561,.0686,-.075,.2276,-.0161)*f00+mat4(.5679,-.7478,1.098,.0993,-.0613,-2.4503,-.0569,-.9271,-1.021,-1.3387,-1.2279,.4993,.1773,-1.0917,-1.802,.3367)*f01+mat4(-.1461,.0849,-.4143,.2184,.2791,-.1917,.1059,.0833,-.1315,.6855,-.1264,.0316,.5576,2.3021,.4269,.8209)*f02+vec4(-12.5297,3.8575,6.2879,9.5278)),
    f20=sin(mat4(.133,-.6265,-.0216,.0542,.093,.145,-.027,.0309,.3214,-.3055,.0133,-.1147,1.4847,.5457,.0075,.0053)*f10+mat4(.6192,.0035,.0501,-.0739,.1744,-.5027,.0387,-.1821,-.2192,.205,.1413,-.0658,.9722,.991,-.1047,.6978)*f11+mat4(1.7267,-1.2397,.1122,.1598,.0819,-.244,-.0037,-.1173,.8199,-.6478,-.0694,-.1619,.1533,-.3345,.0655,-.3539)*f12+vec4(-7.9092,5.1766,4.5882,8.3004)),
    f21=sin(mat4(.1021,.0101,-.0185,1.0375,.0596,.0494,-.0118,.0942,-.0556,.0801,-.0112,.5744,.2268,-.0342,.0146,-.4924)*f10+mat4(-.0556,-.129,-.0085,.4135,.1273,-.1065,-.0131,.002,-.0047,.0157,.1296,.2725,.1126,-.826,.0374,.5895)*f11+mat4(.0459,1.0457,.069,-1.1166,.1201,.014,-.0485,-.0489,.066,.2508,-.0746,-.0383,-.0403,-.6942,-.0686,-.0057)*f12+vec4(-1.6497,-10.4325,4.7085,-1.6826)),
    f22=sin(mat4(-.1911,-.0237,-1.476,-.073,.073,.0244,.3973,-.2509,-.2895,-.0223,-.19,-.1969,1.1299,.0048,-.5468,-.6813)*f10+mat4(.1136,-.036,-.1436,.189,-.5279,.0146,-.8551,.2745,-.1213,.0329,1.1563,-.0467,.7639,.0305,.894,1.0886)*f11+mat4(-.0467,.0323,-2.0777,.0347,-.1369,.0214,-.1325,.6409,-.5975,-.0022,-.8642,-.2585,-.1572,.0014,-.5712,.2296)*f12+vec4(10.825,-7.8502,11.7483,4.7934));
  return dot(vec4(.0496,.1725,-.5204,.3128),f20)+dot(vec4(-.2354,.2206,-.4434,-.0918),f21)+dot(vec4(-.2325,-.6963,-.0407,-.0404),f22)-1.9558;
}

// Function 1991
float facedist(vec4 p, vec4 q) {
  assert(eq(length(p),1.0));
  assert(eq(length(q),1.0));
  vec4 p0 = p - dot(p,q)*q;
  assert(eq(dot(p0,q),0.0));
  assert(eq(dot(p-p0,q),length(p-p0)));
  p0 = normalize(p0);
  assert(dot(p,p0) >= 0.0);
  float t = dist(p,p0);
  assert(t == t);
  return t;
}

// Function 1992
float torusSDFx( vec3 p, float r, float thickness ){
  vec2 q = abs(vec2(length(p.xz)-r,p.y)) - .2;
  return abs(length(q))- thickness;
}

// Function 1993
float unionSDF(float a,float b){
    return min(a,b);
}

// Function 1994
MapTraceResult Map_Trace( vec3 rayOrigin, vec3 rayDir, int waterOctaves, bool detail )
{
    MapTraceResult result = MapTraceResult( -1., -1 );
    //if ( rayDir.y > 0.0f )
    //{
        //return -1.0f;
    //}
        
    float minT;
    vec3 minPos;
    float minH;
    
    float maxT = 0.0f;
    vec3 maxPos = rayOrigin + rayDir * maxT;
	MapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );
    float maxH = mapHeight.height;    
    result.dist = maxT;    
    result.objectId = mapHeight.objectId;  

    float yMax = 2.0f;
    float yMin = -8.0f;
    
    yMax = min( yMax, rayOrigin.y );
    
    int maxIterA = 16;
    
    //float traceStep = 1.0;
    
    for( int iter = 1; iter <= maxIterA; iter++ )
    {
        minT = maxT;
        minH = maxH;

        float fr = float(iter) / float(maxIterA);
        float y = yMax + (yMin - yMax) * fr;
        
        maxT = (y - rayOrigin.y) / rayDir.y;               
        
        maxPos = rayOrigin + rayDir * maxT;
		MapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );
        maxH = mapHeight.height;
        
        result.dist = maxT;
	    result.objectId = mapHeight.objectId;  
                
        if ( maxH < 0.0 )
        {
            break;
        }        
    }    
    
    
    int maxIterB = 11;
    
    for( int iter = 0; iter < maxIterB; iter++ )
    {
        float midT = (minT + maxT) * 0.5f;        
        //float midT = mix( minT, maxT, ( (maxH + minH) * 0.5 - minH ) / (maxH-minH) );
        
        vec3 midPos = rayOrigin + rayDir * midT;
		MapHeight mapHeight = Map_GetAltitude( midPos, waterOctaves, detail );
        float midH = mapHeight.height;
        
        if ( midH < 0.0f )
        {
            maxT = midT;
            maxH = midH;
            result.dist = maxT;
		    result.objectId = mapHeight.objectId;  
        }
        else
        {
            minT = midT;
            minH = midH;
        }      
        
        if ( abs( minH - maxH ) < 0.001)
        {
            break;
        }
    }
    
    return result;
}

// Function 1995
vec2 map( in vec3 pos )
{  
    vec3 facePos = vec3(0.0,0.5,0.0);
    float face = sdEllipsoid(pos - facePos, vec3(0.4,0.5,0.4));
    
    vec3 nosePos = vec3(0.0,0.5,0.4);
    float nose = opBlend(pos, sdEllipsoid(pos - nosePos, vec3(0.1,0.05,0.05)),0.25);
    
    vec3 ear1Pos = vec3(-0.37, 0.6, 0.1);
    float ear1 = sdEllipsoid(pos - ear1Pos, vec3(0.1,0.1,0.05));

    vec3 ear2Pos = vec3(0.37, 0.6, 0.1);
    float ear2 = sdEllipsoid(pos - ear2Pos, vec3(0.1,0.1,0.05));
    
    vec3 eye1Pos = vec3(-0.1,0.65,0.325);
    float eye1 = sdEllipsoid(pos - eye1Pos, vec3(0.05,0.1,0.05));

    vec3 eye2Pos = vec3(0.1,0.65,0.325);
    float eye2 = sdEllipsoid(pos - eye2Pos, vec3(0.05,0.1,0.05));

    vec3 mouthPos = vec3(0.0,0.25,0.28);
    float mouth = sdEllipsoid(pos - mouthPos, vec3(0.1,abs(sin(iTime*4.0))*0.05,0.1));
    
    vec3 hatPos = vec3(0.0, 1.05, 0.0);
    float hat = sdCone(pos - hatPos, 0.22, 0.3, 0.0);
    
    vec3 hatBobblePos = vec3(0.0,1.2,0.0);
    float hatBobble = sdFluffBall(pos - hatBobblePos, 0.1);
    
    vec3 hatRingPos = vec3(0.0,0.8,0.0);
    float hatRing = sdFluffTorus(pos - hatRingPos,vec2(0.3,0.1));
    
    face = opSubtraction(mouth,face);
    
    vec2 res = vec2(sdPlane(pos), 1.0);
	res = opU(vec2(face,2.0), res);
    res = opU(vec2(nose,2.0), res);
    res = opU(vec2(ear1, 2.0), res);
    res = opU(vec2(ear2, 2.0), res);
    res = opU(vec2(eye1,3.0), res);
    res = opU(vec2(eye2,3.0), res);
    res = opU(vec2(hat, 4.0), res);
    res = opU(vec2(hatBobble,3.0), res);
    res = opU(vec2(hatRing, 3.0), res);
    
    //res = vec2(sdFluffTorus(pos - facePos,vec2(0.5,0.1)),3.0);
    
    
    return res;
}

// Function 1996
vec3 normalmap(vec2 p) {
    vec2 e = vec2(1e-3, 0);
    return normalize(vec3(
        heightmap(p - e.xy) - heightmap(p + e.xy),
        heightmap(p - e.yx) - heightmap(p + e.yx),
        2. * e.x));
}

// Function 1997
vec2 calcLineDist(vec3 pos, vec3 v)
{
    vec2 rval;
    rval.x = dot(pos,v)/dot(v,v);
    rval.y = length(pos-rval.x*v);
    return rval;
}

// Function 1998
void setup_scene()
{
}

// Function 1999
vec3 sceneTrace(Ray r,uint tracePathSeed)
{  
    vec3 throughput=vec3(1);
    vec3 col=vec3(0);
    for(uint i=0u;i<RayJumpTimes;++i)
    {
        Hit h=rayCast(r);
        if(h.id<0) break;
        col+=h.mat.emission*throughput;
        r.o=h.pos+h.nml*MinDist;
        vec3 randomRayDir=normalize(h.nml+randomUnitVec3(tracePathSeed+i));
        vec3 specularRayDir=reflect(r.d,h.nml);
        specularRayDir=normalize(mix(specularRayDir,randomRayDir,h.mat.roughness));
        float isSpecular=step(hashf(tracePathSeed+i*2u),h.mat.specularPercent);
        r.d=mix(randomRayDir,specularRayDir,isSpecular);
        throughput*=mix(h.mat.albedo,h.mat.specularCol,isSpecular);
        //Russian Roulette
        float aliveP=max3(throughput);
        if(hashf(tracePathSeed+i-100u)>aliveP)
            break;
        throughput/=aliveP;
    }   
    return col;
}

// Function 2000
float floorSDF(vec3 p){
    return p.y+1.0;
}

// Function 2001
float map ( vec3 v ) {
    float stn = length(v-vec3(0,1,0))-(2.+length(atan(v*sin(v))));
    
    return stn;
}

// Function 2002
float map(in vec3 p){
   
    // A few small bumps to put on the surface.
    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));
    
    // Perturbing the surface slightly, prior to construction.
    p += sin(p*8. + 3.14159)*.1;
    
    // The main surface. A weird, molecular looking lattice.
    float n = dot(sin(p*2.), cos(p.yzx*2.));
    
 	// Clamping the surface value, and adding the bumps.
    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;
    return (min(n, 0.) + 1.1)/1.1 + bump;
    
}

// Function 2003
float distance_sq(
	vec2 point_one,
	vec2 point_two)
{
    vec2 delta = (point_two - point_one);
    
	return dot(delta, delta);
}

// Function 2004
float map_floor(vec3 pos, bool btext)
{
    float h=0.;
    #ifdef smooth_floor_bump
    #ifdef bumpmaps
   	h = texture(iChannel3, fract(woodSize*pos.xz)).x;
    #endif
    return pos.y - flpos - (btext?0.01*h:0.);
    #else
    #ifdef bumpmaps
    h = texture(iChannel0, woodSize*pos.xz).x;
    return pos.y - flpos - (btext?0.007*h:0.);
    #endif
    #endif
    #ifndef bumpmaps
    return pos.y - flpos;
    #endif
}

// Function 2005
vec2 distCarM(vec3 p) {return vec2(distCar(p),1.); }

// Function 2006
float map(vec3 pos, vec3 lPos, float time)
{
    float rayDist = 0.;
    
    //pos = Spherize(pos);
    
    pos = FractalSpace(pos,time);
    pos.xy += .05;
    
    vec3 pos1 = pos;
    pos1.x = abs(pos.x);
    vec3 pos2 = pos;
    
    pos.xyz = abs(pos.xyz);
    pos.z -= .01;
    
    
    //ground
    rayDist = box(pos,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));
    //roads
    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));
    rayDist = max(rayDist,-box(pos,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));
    
    rayDist = max(rayDist,-box(pos,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));
    rayDist = max(rayDist,-box(pos,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));
    //big building
    vec3 b2 = pos;
    b2.xy -= 0.22;
    //b2.xy -= vec2(0.22,-0.08);
    b2 = abs(b2);
    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.05,0.1)));
    rayDist = min(rayDist,box(b2,vec3(0.,0.,0.05),vec3(0.04,0.04,0.1)));
    //rayDist = min(rayDist,box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));
    
    //Paris building
    vec3 b1 = pos;
    b1.xy -= vec2(0.22,0.08);
    b1 = abs(b1);
    float XYsize =  max(0.,.5*pos.z-0.02);
    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.01);
    rayDist = min(rayDist,box(b1,vec3(0.,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));
    rayDist = max(rayDist,-box(b1,vec3(0.0,0.0,0.05),vec3(0.02+XYsize,0.02+XYsize,0.05)));
    
    rayDist = min(rayDist,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.008)));
    rayDist = min(rayDist,box(b1,vec3(0.04,0.01,0.05),vec3(0.005,0.001,0.008)));
    
    b1.xy *= 0.56;
    b1 = abs(b1-0.02);
    rayDist = max(rayDist,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));
    
    //Garden walls
    vec3 b0 = pos1;
    b0.xy -= 0.08;
    rayDist = min(rayDist,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));
    rayDist = max(rayDist,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));
    
    //Garden trees
    float noise = 1.+0.1*length(sin(pos*2000.0))+0.2*length(sin(pos*900.0)); 
    
    b0.xy = abs(b0.xy);
    b0.xy -= 0.02;
    b0.xy = abs(b0.xy);
    b0 -= vec3(0.01,0.01,0.02);
    rayDist = min(rayDist,cylinder(b0,vec3(0.,0.,-0.01),0.001,0.006));
    b0*=noise;
    rayDist = min(rayDist,sphere(b0,vec3(0.),0.008));

    
    //parking
    vec3 b3 = pos2;
    b3.xy -= vec2(0.08,0.-0.08);
    b3 = abs(b3);
    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.033),vec3(0.05,0.05,0.033)));
    rayDist = max(rayDist,-box(b3,vec3(0.,0.0,0.064),vec3(0.049,0.049,0.006)));
    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));
    rayDist = min(rayDist,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));
    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.033),vec3(0.01,0.051,0.003)));
    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.033),vec3(0.051,0.01,0.003)));
    rayDist = max(rayDist,-box(b3,vec3(0.022,0.,0.053),vec3(0.01,0.051,0.003)));
    rayDist = max(rayDist,-box(b3,vec3(0.,0.022,0.053),vec3(0.051,0.01,0.003)));
    
    //square
    vec3 b4 = pos2;
    b4.xy -= vec2(0.08,0.-0.22);
    b4 = abs(b4);
    rayDist = min(rayDist,box(b4,vec3(0.,0.,0.003),vec3(0.05,0.05,0.003)));
    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));
    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.051,0.01,0.004)));
    rayDist = max(rayDist,-box(b4,vec3(0.,0.,0.004),vec3(0.01,0.051,0.004)));
    
    vec3 cone = b4;
    vec3 stairs = b4;
    
    rayDist = min(rayDist,cylinder(b4,vec3(0.,0.,0.015),0.015,0.006));
    
    cone.xy += (cone.z-0.021);
    rayDist = min(rayDist,cylinder(cone,vec3(0.,0.,0.027),0.015,0.006));
    
    stairs.xy += floor(stairs.z * 800.0)/800.0;
    rayDist = min(rayDist,box(stairs,vec3(0.018,0.018,0.0),vec3(0.01,0.01,0.01)));
    rayDist = min(rayDist,box(stairs,vec3(0.00,0.0,0.01),vec3(0.01,0.01,0.02)));
    
    
    //Business building
    vec3 b5 = pos2;
    b5.xy -= vec2(-0.08,0.-0.22);
    b5.xy *= 1.+2.0*floor(b5.z * 50.0)/50.0;
    b5.xy *= rz2(b5.z);
    rayDist = min(rayDist,box(b5,vec3(0.,0.,0.15),vec3(0.05,0.05,0.15)));
    
    
    //Bird
    if (displayBird && length(lPos) < 2.)
    {
        lPos *= 0.1;
        lPos.x *= 2.0;
        float rep = 0.002;
        lPos.x = rep-abs(abs(lPos.x)-rep);
        
        float flap = sin(time*40.0+lPos.x*600.0);

        float feathers = -lPos.y*4000.;
        lPos.z += abs(mod((feathers),1.)-0.5)*0.2*lPos.z;
        feathers = -lPos.x*2000.;
        lPos.z += abs(mod((feathers),1.)-0.5)*0.2*lPos.z;

        //lPos.x = abs(lPos.x);
        lPos.x *= pow(abs(lPos.x*500.),2.);
        lPos.xz *= rz2(-.5);
        lPos.y += flap*0.0004;
        //lPos.yz *= rz2(sin(time*0.5)*0.1);
        //lPos.xy *= 1.+abs(lPos.z*1.);
        //lPos.z *= pow(abs(lPos.z),0.2);
        lPos.z -= 0.001;
        lPos.yz += 0.003;
        rep = -0.0001;
        //lPos.z += mod((-pos.y*50.),1.)*0.0005;
        lPos.y = rep-abs(abs(lPos.y)-rep);

        //lPos.z = mod(lPos.z*10000.,1.)/10000.;
        //
        //0.5-smoothstep(0.,0.002,abs(lPos.z*0.1))
        float size = 0.0005;// * (length(sin(pos*20.0))+0.2*length(sin(pos*50.0)));
        rayDist = min(rayDist,sphere(lPos,vec3(0.002,0,lPos.z),size*((1.-pow(abs(lPos.z*200.),2.)))));
    }
    
    fog = pos.z;
    
    return rayDist;
}

// Function 2007
float DistanceSqFirstDeriv(Spline s, FactorsOfP fp, vec3 p, float t)
{
	return t * (t * (t * (t * (t * s.F_5 + s.F_4) + s.F_3) + fp.F_t_2) + fp.F_t_1) + fp.F_t_0;
}

// Function 2008
float doDistance(in vec2 fragCoord, vec2 colorUV) {
    vec2 res2 = iResolution.xy;
    float t = 1.0; //(sin(iTime) + 1.0) / 2.0 + 0.1;
    fragCoord = ((fragCoord / res2 - 0.5) * t + 0.5) * res2;
    //vec2 res2 = vec2(256.0);
    //vec3 col = vec3(0.0);
    vec2 powerOfTwoRes = getRes(res2);
    //vec2 res = res2;
    vec2 uv = floor(fragCoord / res2 * powerOfTwoRes);
    ivec2 div = maxDiv(powerOfTwoRes);
    //vec2 colorUV = fragCoord / iResolution.xy;
    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);
    int m = int(res2.x * res2.y);
    
	//fragColor *= 0.0;
    int uvIndex = toIndex(uv, powerOfTwoRes);
    //uvIndex = m / 2;
    vec4 frcol = vec4(0.0);
    int index3 = binarySearchLeftMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);
    int index4 = binarySearchRightMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);
    //int index3 = binarySearchLeftMost(n, iFrame, res, fragCoord, fragColor);
    //return;
    //index3 = binarySearchLeftMost(n, 0, res);
    
    mRet mret = getM(index3, res2, powerOfTwoRes);
    int foundIndex = mret.Am;
    vec4 v = mret.v;
    float d = distance(colorUV, v.xy);
    
    int j = 0;
    int a = min(index3, index4);
    int b = max(index3, index4);
    for (int j = 0; j < 1; j++) {
        int i = a + j;
        mRet mret = getM(i, res2, powerOfTwoRes);
        int foundIndex = mret.Am;
        vec4 v = mret.v;
        d = min(d, distance(colorUV, v.xy));
    }
        
    float ret = index3 < 0 ? -1.0 : d;
    return ret;
}

// Function 2009
vec3 spheresdf( vec3 p, 
                vec3 rdir ) 
{
    float dist = 10.;

    vec3 cellCoords = ceil(p / CELLBOX_SIZE);
    vec4 nextCellOffset = vec4(sign(rdir), 0.);
            
    // Look into this cell to check distance to that sphere and then
    // check the distance to the spheres for the next cells to see if
    // they are closer, we can guess the "next" cells by just looking
    // at the sign of the ray dir (so we don't check all 27 possible
    // cells - 9x9x9 grid).  This limits it down just to checking 8
    // possible cells.

    // XXX: we could limit this to 4 cell checks if we trace the 
    // ray through the 8 potential cells and only test the cells 
    // through which the ray passes.

    // 1. current cell
    vec3 result = spheredf( p, cellCoords );

    // 2. neighbor in the x direction of the ray
    vec3 neighborResult = spheredf(p, cellCoords + nextCellOffset.xww);    
    // DEBRANCHED - equivalent to
    // if (neighborResult.x < result.x) { result = neighborResult; }
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 3. neighbor in the y direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyw);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 4. neighbor in the z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wwz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));
    
    // 5. neighbor in the x-y direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyw);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 6. neighbor in the y-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    // 7. neighbor in the x-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xwz);
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));
        
    // 8. neighbor in the x-y-z direction of the ray
    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyz);    
    result = mix(result, neighborResult, 
                 step(neighborResult.x, result.x));

    return result;
}

// Function 2010
vec3 hableTonemap(vec3 x)
{
    float a = .15;
    float b = .5;
    float c = .1;
    float d = .2;
    float e = .02;
    float f = .3;

    return ((x * (x * a + c * b) + d * e) / (x * (x * a + b) + d * f)) - e / f;
}

// Function 2011
float branchDistance(vec3 p, inout int material){
    
    
    float distance = 9999.9;
    material = 0;
    
    const float snowR = 0.2;
    vec3 cylMiddle = vec3((branchStart+branchEnd)*0.5,0.0,0.0);
    vec2 cylSize = vec2(0.0,(branchEnd-branchStart)*0.5-snowR);
    
    const float leavesR = 0.2;
    
    const float branchLeavesBelow = -0.2;
    const vec3 subBranchOff = vec3(0.0,branchLeavesBelow,0.0);
    
    hardAdd(material,distance,1, obj_cylinder(p, cylMiddle, cylSize, snowR) );
    
    const float subBranchGap = 0.5;//total space before wrap
    const float subBranchStride = subBranchGap-snowR*2.0;//branch size allowing for rounded ends
    
    const vec3 subBranchStart = vec3(snowR,0.0,0.0);
    const vec3 subBranchLength = vec3(subBranchStride,-0.8,0.8);
    
    if ( (p.x < branchEnd) && (p.x > branchStart) ) {
        
        float branchX = (floor((branchEnd-p.x)/subBranchGap)*subBranchGap);//step
    	vec3 modP = vec3(mod(branchEnd-p.x,subBranchGap),p.y,abs(p.z));
        
        float unit = (branchX/(branchEnd-branchStart));
        float subBranchAmt = sin(unit*PI);
        
        vec3 subBranchSnowEnd = subBranchStart+subBranchLength*subBranchAmt;
        vec3 subBranchLeafEnd = subBranchStart+subBranchLength*(subBranchAmt + 0.2);
        
        smoothAdd(distance, obj_roundline(modP,subBranchSnowEnd,subBranchStart,snowR), 0.2);
        hardAdd(material,distance,2, obj_roundline(modP,subBranchLeafEnd+subBranchOff,subBranchStart+subBranchOff,leavesR) );
        
    }
    
    hardAdd(material,distance,2, obj_cylinder(p, cylMiddle+vec3(0.0,branchLeavesBelow,0.0), cylSize, leavesR) );
    
    return distance;
    
    
}

// Function 2012
float map( in vec3 p )
{
    float scale = 10.;
    float t = iTime/scale;
    // Repeat animation to avoid over-winding the vortes
    float m1 = mapt(p, scale*fract(t)+4.);
    float m2 = mapt(p, scale*fract(t+0.5)+4.);
    // Smoothly mix between two evaluations to avoid jumps
    float proportion = 2.*abs(fract(t)-0.5);
    float m = mix(sqrt(m1),sqrt(m2),proportion);
    return m*m;
}

// Function 2013
float treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )
{
    oHei = 1.0;
    oDis = 0.1;
    oMat = 0.0;
        
    float base = terrainMap(p.xz).x; 
    
    float d = 10.0;
    vec2 n = floor( p.xz );
    vec2 f = fract( p.xz );
    for( int j=0; j<=1; j++ )
    for( int i=0; i<=1; i++ )
    {
        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));
        vec2  o = hash2( n + g );
        vec2  v = hash2( n + g + vec2(13.1,71.7) );
        vec2  r = g - f + o;

        float height = kMaxTreeHeight * (0.4+0.8*v.x);
        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);
        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);
        float k = sdEllipsoidY( q, vec2(width,0.5*height) );

        if( k<d )
        { 
            d = k;
            //oMat = hash1(o); //fract(o.x*7.0 + o.y*15.0);
            oMat = o.x*7.0 + o.y*15.0;
            oHei = (p.y - base)/height;
            oHei *= 0.5 + 0.5*length(q) / width;
        }
    }
    oMat = fract(oMat);

    // distort ellipsoids to make them look like trees (works only in the distance really)
    #ifdef LOWQUALITY
    if( rt<350.0 )
    #else
    if( rt<500.0 )
    #endif
    {
        float s = fbm_4( p*3.0 );
        s = s*s;
        oDis = s;
        #ifdef LOWQUALITY
        float att = 1.0-smoothstep(150.0,350.0,rt);
        #else
        float att = 1.0-smoothstep(200.0,500.0,rt);
        #endif
        d += 2.0*s*att*att;
    }
    
    return d;
}

// Function 2014
vec2 mapBlocks(vec3 p, vec3 ray_dir//use ray_dir for some optimizations
){vec2 res=vec2(OBJ_SHORTBLOCK, sdBox(rotateY(p + (vec3(mouse.x *2.0-1.0, -mouse.y, 0.0)) * 310.0 + vec3(-186, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5)));
 ;vec2 obj1=vec2(OBJ_TALLBLOCK, sdBox(rotateY(p +vec3(-368.5,-165,-351.5),-.30072115), vec3(87.02012, 165, 83.6675)));
 ;if (obj1.y < res.y) res = obj1
 ;return res;}

// Function 2015
float LineDist(float ax,float ay, float bx,float by, vec2 p) {
    return LineDist(vec2(ax, ay), vec2(bx, by), p);
}

// Function 2016
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  vec2 vf;
  float dstObj, sh;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    vf = vec2 (0.);
    if (idObj == 1 || idObj == 6) vf = vec2 (64., 0.3);
    else if (idObj == 7) vf = vec2 (16., 4.);
    if (vf.x > 0.) {
      vn.xz = Rot2D (vn.xz, plRot);
      vn = VaryNf (vf.x * qHit, vn, vf.y);
      vn.xz = Rot2D (vn.xz, - plRot);
    }
    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?
       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.2, 0.2, 0.25, 0.1);
    else if (idObj == 2) col4 = (qHit.z > -0.3) ? vec4 (1., 0.8, 0.2, 0.2) : vec4 (0.3, 0.7, 1., 0.);
    else if (idObj == 3) col4 = vec4 (0.15, 0.3, 0.1, 0.3);
    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);
    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);
    else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);
    else if (idObj == 7) col4 = vec4 (0.7, 0.7, 0.75, 0.);
    sh = (idObj == 7) ? ObjSShadow (ro, ltDir) : 1.;
    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
  } else {
    col = StarPat (rd, 32.);
  }
  return clamp (col, 0., 1.);
}

// Function 2017
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    {
      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )
    {
    // more primitives
    res = opU( res, vec2( sdBoundingBox( pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );
	res = opU( res, vec2( sdTorus(      (pos-vec3( 0.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 25.0 ) );
	res = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );
    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )
    {
    // more primitives
	res = opU( res, vec2( sdCappedTorus((pos-vec3( 1.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 8.5) );
    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );
    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );
    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )
    {
    // more primitives
	res = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );
	res = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );
    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );
    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );
	res = opU( res, vec2( sdRhombus(   (pos-vec3(-1.0,0.34, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )
    {
    // more primitives
    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );
    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.15,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );
	res = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.10,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );
    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );
    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );
    }
    
    return res;
}

// Function 2018
float sceneSDF(vec3 p) {
    vec3 p0 = p;
    p /= scale;
    float jungle1 = jungle(p,(length(p)-planet_size)/100.0);
    float planet_surface = 1.1+length(p)-planet_size;
    //float result = SDF1(p/1000.0+SDF1(p/1000.0));
    float result = min(jungle1,planet_surface);
    
    
    return result*scale;
}

// Function 2019
float scene(vec3 p) {
  p.z += sin(iTime);
  p = erot(p, vec3(0,1,0), cos(iTime)*.2);
  beamm = 0.9*(linedist(p, vec3(0), vec3(0,0,-10))-.3-sin(p.z*3.+iTime*4.)*.05 - sin(iTime)*.2);
  locl = p;
  vec3 p2 =p;
  p2.z = sqrt(p2.z*p2.z+0.02);
  p2.z+=3.;
  vec3 p3 =p;
  p3.z = sqrt(p3.z*p3.z+0.02);
  p3.z+=8.1;
  body = length(p2)-3.8;
  body += smoothstep(0.8,.9,sin(atan(p2.x,p2.y)*10.))*.02;
  body += smoothstep(0.9,1.,sin(atan(p2.x,p2.y)*45.))*.003;
  rm=length(p3)-8.525;
  body = smin(body, rm,.01);
  float hat = length(p-vec3(0,0,0.8))-0.7;
  return min(min(body,hat), beamm);
}

// Function 2020
float mapVol2(vec3 p, in float spd)
{
    p *= 1.3;
    float f = smoothstep(0.2, 1.0, 1.3-(p.y+length(p.xz)*0.4));
    p.y *= .05;
    p.y += time*1.7;
    float d = triNoise3d(p*1.1,spd);
    d = clamp(d-0.15, 0.0, 0.75);
    d *= d*d*d*d*47.;
   	d *= f;
    
    return d;
}

// Function 2021
float distFilter(float v)
{
    return smoothstep(3. / iResolution.y, 0., v);
}

// Function 2022
vec2 map( in vec3 pos )
{
      
    return vec2( flower(pos, 0.750), 5.1 + (sin(iTime)/2.)) ;
    
}

// Function 2023
float distBox( vec3 p, vec3 halfSize)
{
    vec3 q = abs(p) - halfSize;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2024
float PointDistance(vec2 a, vec2 b)
{
    float x = a.x - b.x;
    float y = a.y - b.y;
    return sqrt((x * x) + (y * y));
}

// Function 2025
vec3 sampleReflectionMap(vec3 sp, float lodBias){
    #ifdef LOD_BIAS
    	lodBias = LOD_BIAS;
    #endif
    vec3 color = SRGBtoLINEAR(textureLod(iChannel0, sp, lodBias).rgb);
    #if defined (HDR_FOR_POORS)
    	//color *= 1.0 + 2.0*smoothstep(hdrThreshold, 1.0, dot(LUMA, color)); //HDR for poors
    	color = InvTM(color, hdrThreshold);
   	#endif
    return color;
}

// Function 2026
float distance_field(vec3 co) {
    float rad = clamp(co.z * 0.05 + 0.45, 0.1, 0.3);
    //float rad = 0.45;
    co = mod(co, vec3(1.0)) - 0.5;
    //co = (co - clamp(round(co), -5.0, 5.0));
    //return sphere_sdf(co, rad);
    
    return sdRoundBox(co, vec3(rad, rad, 0.3), 0.1);
}

// Function 2027
float distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {
    h = dot(p-ro,rd);
    return length(p-ro-rd*h);
	//return length(cross(p-ro,rd));
}

// Function 2028
vec4 mapD( in vec3 pos, in float time )
{
    float matID;
    vec3 uvw;
    vec4 h = map(pos, time, matID, uvw);
    
    if( matID<1.5 ) // skin
    {
        // pores
        float d = fbm1(iChannel0,120.0*uvw);
        h.x += 0.0015*d*d;
    }
    else if( matID>3.5 && matID<4.5 ) // hair
    {
        // some random displacement to evoke hairs
        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;
    	h.x -= 0.02*te;
    }    
    return h;
}

// Function 2029
float SDFfloor (vec3 p) {
    return p.y+0.;
}

// Function 2030
vec3 fetch_grad_dist(ivec2 uv, float font_size) {
    
    vec3 grad_dist = (texelFetch(iChannel0, uv, 0).yzw - TEX_BIAS) * font_size;
    
    grad_dist.y = -grad_dist.y;
    
    grad_dist.xy = normalize(grad_dist.xy + 1e-5);
    
    return grad_dist;
    
}

// Function 2031
bool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )
{
    float t = 5.;
	float oldT = 0.0;
	float delta = 0.;
	vec2 h = vec2(1.0, 1.0);
	bool hit = false;
	for( int j=0; j < 70; j++ )
	{
	    vec3 p = rO + t*rD;
		h = Map(p); // ...Get this position's height mapping.

		// Are we inside, and close enough to fudge a hit?...
		if( h.x < 0.05)
		{
			hit = true;
            break;
		}
	        
		delta = h.x + (t*0.03);
		oldT = t;
		t += delta;
	}
    type = h.y;
    resT = BinarySubdivision(rO, rD, t, oldT);
	return hit;
}

// Function 2032
float mapDamageHigh( vec3 p ) {
    float d = map( p );
    
    float p1 = noise( p*2.3 );
    float p2 = noise( p*5.3 );
    
    float n = max( max( 1.-abs(p.z*.01), 0. )*
                   max( 1.-abs(p.y*.2-1.2), 0. ) *
                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);
  
    float ne = 0.;
    ne += smoothstep( -0.7, 0., -distance( p, ep1.xyz ) );
    ne += smoothstep( -0.7, 0., -distance( p, ep2.xyz ) );
    ne += smoothstep( -0.7, 0., -distance( p, ep3.xyz ) );
    ne += smoothstep( -0.7, 0., -distance( p, ep4.xyz ) );
    ne += smoothstep( -0.7, 0., -distance( p, ep5.xyz ) );
    
    n += .5 * max((ne - p2 ),0.) * ne;
  
    if( p.y < .1 ) {
        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);
    }
    
    if( abs(n) > 0.0 ) {
        n += noise( p*11.) * .05;
        n += noise( p*23.) * .03;
    }
    
	return d + n;
}

// Function 2033
float map( in vec3 p, out vec4 color, const in bool doColor )
{
    float lp = length(p);
    float dmin = lp-1.0;
    
    
    float pp = 0.5+0.5*sin(60.0*lp); pp *= pp; pp *= pp; pp *= pp; pp *= pp;
    dmin = min(dmin,p.y+1.0+0.02*pp);
    
    

    color = vec4(0.4,0.5,0.3,1.0)*0.9;
    
    float s = 1.0;
    
    //dmin = min( dmin,lp-2.15 );
    
    for( int i=0; i<2; i++ )
    {
        float h = float(i)/float(2-1);
        
        // Trick. Do not check the 2x2 neighbors, just snap to the
        // closest point. This is wrong and produces discontinuities
        // in the march, but it's okeish for the purposes of this shader
        vec4 fibo = inverseSF(normalize(p), 65.0+35.0*h);
        
        // snap
        p -= fibo.xyz;
        
        // orient to surface
        p *= makeBase(normalize( fibo.xyz + 0.08*sin(fibo.y + 2.0*iTime + vec3(0.0,2.0,4.0))));

        // scale
        float scale = 7.0 + 3.0*sin(111.0*fibo.w);
        if( i==0 ) scale += 4.0*(1.0-smoothstep(-0.5,-0.4,fibo.y));
        scale *= 1.0 + 3.0*smoothstep(0.9,1.0,cos(0.25*iTime + fibo.w*141.7));
        p *= scale;
        
        // translate and deform
        p.z -= 2.3 + length(p.xy)*1.1*abs(sin(fibo.w*212.1));

        //-----
        
        s *= scale;
		// distance to line segment/capsule 
        float d = length( p - vec3(0.0,0.0,clamp(p.z,-6.0,0.0)) ) - 0.1;
        d /= s;

        if( d<dmin )
        {
            if( doColor )
            {
                color.w *= smoothstep(0.0, 5.0/s, dmin-d);
                if( i==0 ) color = vec4(0.4,0.5,0.4,1.0);
                color.xyz += 0.3*(1.0-0.45*h)*sin(fibo.w*211.0+vec3(0.0,1.0,2.0));
                color.xyz = max(color.xyz,0.0);
            }
            dmin = d;
        }
        else
        {
          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));
        }
    }
    
    return dmin;
}

// Function 2034
vec2 map(vec3 pos)
{
    vec2  a = vec2(kFarPlaneDist - 40., 0.), b = a;
    
vec3 rotpos=pos;
    rotpos.x += (length(mod(iTime, 4.)-2.)-1.)*3.;
    rotpos.y -= -1.+abs(sin(iTime*5.))*1.5;
rotpos=opRot(rotpos.xyz,-kPi*.5+sin(iTime)*.3);
rotpos=opRot(rotpos.zyx,iTime);
rotpos=opRot(rotpos.yzx,kPi+sin(iTime+.3)*.2);

    
    b = vec2(sdSphere(rotpos, 2.0), 1.); MIN(a, b);
    b = vec2(sdCappedCylinder(rotpos+vec3(0,-2,0), vec2(.3, .3)), 2.); MIN(a,b);
    b = vec2(sdTorus(rotpos.xzy+vec3(0,0,-2.5), vec2(.4, .02)), 2.); MIN(a, b);
	return a;
}

// Function 2035
vec3 tonemap(vec3 c)
{
    return c/(c+vec3(0.6));
}

// Function 2036
vec3 GetMipMapUVW_Dir2(vec3 _uvw,vec3 _axis){
    ivec3 xyz = ID_xyz[int(dot(abs(_axis.yz),vec2(1,2)))];
	vec3 uv = vec3(_uvw[xyz.x],_uvw[xyz.y],_uvw[xyz.z]);
    uv.xy = floor((uv.xy+1.)*512.);
    vec2 a = ceil(log2(uv.xy+1.));
	float max_a = max(a.x,a.y);
    float scale = exp2(max_a-1.);
    vec2 B = step((a.x+a.y)/2.,a);
    ID = max_a*3.-3. + B.y*2. + B.x;
    uv.xy = ((uv.xy+0.5)/scale - B - 0.5)*2.;
    uv = vec3(uv[xyz.x],uv[xyz.y],uv[xyz.z]);
    return normalize(uv+_axis);
}

// Function 2037
void Scene_Subtract( inout SceneResult a, in SceneResult b )
{
    if ( a.fDist < -b.fDist )
    {
        a.fDist = -b.fDist;
        a.iObjectId = b.iObjectId;
        a.vUVW = b.vUVW;
    }
}

// Function 2038
SDFResult torusSDF2( Torus torus, vec3 p )
{
    p -= torus.pos;
    
    const float scale = 0.05;
    float topdiff = clamp((0.1 - p.y), 0.0, scale);
    float botdiff = clamp((p.y - ((p.x*p.x*2.0)-scale)), 0.0, scale);
    
    if ( topdiff>0.0 && botdiff>0.0 )
    {
        float v = min(topdiff, botdiff)/scale;
        v = 3.0*v*v - 2.0*v*v*v;
        p.z-=v*scale*0.5;
    }
    
	vec2 q = vec2(length(p.xz)-torus.ring,p.y);
	return SDFResult(length(q)-torus.radius, torus.matindex);
}

// Function 2039
vec2 spheremapPack(vec3 n)
{
    float p = sqrt(n.z * 8.0 + 8.0);
    vec2 normal = n.xy / p + 0.5;
    return normal;
}

// Function 2040
void SceneInit(out Scene s)
{
    // Setup camera
    s.cam.pos 	  = vec3(0);
    s.cam.forward = vec3(0,0,1);
    s.cam.right   = normalize(cross(vec3(0, 1, 0), s.cam.forward));
    s.cam.up      = normalize(cross(s.cam.forward, s.cam.right));
    s.cam.fPersp  = 2.0;

    // Moving Directional Light
    /*Light dirLight;
	dirLight.type      = 0;
    dirLight.pos       = vec3(0);
    dirLight.dir       = normalize(vec3(sin(iTime*.5), cos(iTime*.25)-1.0, 1));
    dirLight.color 	   = vec3(1);
    dirLight.range     = MAX_DISTANCE;
    dirLight.intensity = .0;

    s.lights[0] = dirLight;*/
    
    // Orange Point Light
    Light pLight;
    pLight.type      = POINT;
    pLight.dir 		 = vec3(0);
    pLight.color  	 = VERMILION;
    pLight.range 	 = 7.5;
    pLight.intensity = 1.0;
    pLight.pos       = vec3(0,2,6) +
        			   vec3(5.*sin(1.5*iTime), 0, 5.*cos(1.5*iTime));
    s.lights[0] = pLight;
    
    // Teal point Light
    Light pLight2;
    pLight2.type      = POINT;
    pLight2.dir       = vec3(0);
    pLight2.color  	  = TEAL;
    pLight2.range 	  = 7.5;
    pLight2.intensity = 1.0;
    pLight2.pos       = vec3(0,2,6) +
        			    vec3(5.*sin(iTime+180.), 0, 5.*cos(iTime+180.));
    s.lights[1] = pLight2;
    
    // Floor plane
    Shape plane;
    plane.blendType = NO_OP;
    plane.type      = FLOOR_PLANE;
    plane.pos       = vec3(0);
    plane.rot       = ComputeRotationMatrix(0., 0., 0.);
    plane.color     = vec4(0);
    plane.normal    = vec4(0, 1, 0, 2);
    plane.glossy    = .25;
    plane.texID     = 0;
    
    s.objects[0] = plane;
    
    // Red Box
    Shape box;
    box.blendType = NO_OP;
    box.type      = BOX;
    box.pos       = vec3(-3, -1.35, 6);
    box.scale     = vec3(.75);
    box.rot       = ComputeRotationMatrix(0., 90., 0.);
    box.color     = vec4(RED, 1);
    box.glossy    = 0.;
    box.texID     = 1;

    s.objects[1] = box;
    
    // Green Ball
    Shape ball;
    ball.blendType = BLEND;
    ball.type      = SPHERE;
    ball.pos       = vec3(0, -1, 6);
    ball.radii     = vec2(1, 0);
    ball.rot       = ComputeRotationMatrix(0., 0., 0.);
    ball.color     = vec4(GREEN, 1);
    ball.glossy    = 1.0;
    ball.blendStrength = .5;
    ball.texID     = 0;

    s.objects[2] = ball;
   
    // Blue Torus
    Shape torus;
    torus.blendType = NO_OP;
    torus.type      = TORUS;
    torus.pos       = vec3(2.75, -1, 6);
    torus.radii     = vec2(.75, .25);
    torus.rot       = ComputeRotationMatrix(cos(iTime), sin(iTime), 0.);
    torus.color     = vec4(BLUE, 1);
    torus.glossy    = .5;

    s.objects[3] = torus;

    return;
}

// Function 2041
Thing scene(vec3 p) {
    float ry = 15.;
    float y = -ry * .90;

    float sr = 3.;
    vec3 so = vec3(0., y-ry+sr + ry*(sin(iTime)+1.)/8., 0.);
    Thing result = Thing(
        distance(p, so) - sr,
        // Striped ball coloring
        (mod(floor(atan(p.z - so.z, p.x - so.x) * 5.), 2.) == 0.)?
            vec3(1., 0.5, 0.) : vec3(0., 0.5, 0.),
        0.
    );

    float foc = 2. * ry - sr;
    float a = 1. / 4. / foc;
    addThing(result, Thing(
        max(p.y, min(paraboloid(p, a, y-ry), paraboloid(p, -a, y+ry))),
        // Checkerboard pattern coloring
        (mod(floor(p.x * 0.1) + floor(p.z * 0.1), 2.) == 0.)?
            vec3(0., 0.2, 0.5) : vec3(0., 0., 0.5),
        0.8
    ));

    return result;
}

// Function 2042
float chebyshevDistance(vec3 p1, vec3 p2) {
	float d1 = abs(p1.x - p2.x);
	float d2 = abs(p1.y - p2.y);
	float d3 = abs(p1.z - p2.z);
	return max(d1, max(d2, d3));
}

// Function 2043
float map(vec3 p){
    for( int i = 0; i<8; ++i){
        float t = iTime*0.2;
        p.xz =rotate(p.xz,t);
        p.xy =rotate(p.xy,t*1.89);
        p.xz = abs(p.xz);
        p.xz-=.5;
	}
	return dot(sign(p),p)/5.;
}

// Function 2044
vec2 terrainMap( in vec2 p )
{
    const float sca = 0.0010;
    const float amp = 300.0;

    p *= sca;
    float e = fbm_9( p + vec2(1.0,-2.0) );
    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); // flag high-slope areas (-0.25, 0.0)
    e = e + 0.15*smoothstep( -0.08, -0.01, e );
    e *= amp;
    return vec2(e,a);
}

// Function 2045
float map( in vec3 pos )
{
    // testing 'wavelet' noise...
    float nx = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0), iTime*3., 1.15)*1.9;
    float nz = WaveletNoise(pos*0.1+vec3(0.0,iTime,0.0) + 10.0, iTime*3., 1.15)*1.9;
    vec3 p2 = pos;
    p2.x += nx;
    p2.z += nz;
    float d1 = sdCylinder(p2,vec2(4.0,HEIGHT))-1.0;
    d1 = smax(d1-sin(iTime*7.0+pos.y*0.4)*1.1,d1,-3.0);
    
        // sphere cut
        float rad = fract(iTime*0.1)*70.0;
        float rad2 = clamp(rad,0.0,18.0);
        float sphere1 = length(pos-vec3(0.0,HEIGHT+4.0-rad,0.0))-rad2;
        float sphere2 = length(pos-vec3(0.0,((HEIGHT*2.0)+HEIGHT+4.0-rad),0.0))-rad2;	//rad;
        sphere1 = min(sphere1,sphere2);
        d1 = smax(d1,sphere1,4.0);
    _col = vec3(0.15,0.45,0.05);
    pos.y = abs(pos.y);
    vec3 p = pos;
    
    d1*=0.85;
    
    float d2 = sdCylinder(p-vec3(0.0,HEIGHT+2.0,0.0),vec2(10.5,0.5))-1.4;
    d1 = sminCol(d2,d1,2.0,_col,vec3(0.05,0.15,0.4));
    return d1;
}

// Function 2046
float sdf_smin(float a, float b, float k)
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return mix( b, a, h ) - k*h*(1.0-h);
}

// Function 2047
vec3 mapRMNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapRMDetailed(pt).x;    
    normal.x = mapRMDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapRMDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 2048
float polDist(vec2 p){
    
    
	// Standard circular length.
    return length(p);
    
    // More options, but since we're using cylindrical mapping, a lot wouldn't 
    // really work, unless you rewrote the texture mapping to match.
    
    
    // A hacky arch-like variation.
    //return mix(length(p), min(length(p), max(abs(p.x), abs(p.y + 2.5 - .5) + 1.)), .5);

    // Square cross section.
    //p = abs(p);
    //return max(p.x, p.y);
    
    // Hexagonal cross section.
    //p = abs(p);
    //return max(p.x*.8660254 + p.y*.5, p.y);

    // Octagonal cross section.
    //p = abs(p);
    //return max(max(p.x, p.y), (p.x + p.y)*.7071);
    
    
    // Dodecahedral cross section.
    //p = abs(p);
    //vec2 p2 = p.xy*.8660254 + p.yx*.5;
    //return max(max(p2.x, p2.y), max(p.y, p.x)); 
    
    
    //const float pwr = 4.;
    //return pow( dot(pow(abs(p), vec2(pwr)), vec2(1)), 1./pwr);

    
}

// Function 2049
float map(vec3 p) {
	return p.y + (0.5 + waveHeight1 + waveHeight2 + waveHeight3) 
		+ snoise(vec2(p.x + iTime * 0.4, p.z + iTime * 0.6)) * waveHeight1
		+ snoise(vec2(p.x * 1.6 - iTime * 0.4, p.z * 1.7 - iTime * 0.6)) * waveHeight2
	  	+ snoise(vec2(p.x * 6.6 - iTime * 1.0, p.z * 2.7 + iTime * 1.176)) * waveHeight3;
}

// Function 2050
float mapShell( in vec3 p, out vec4 matInfo ) 
{
    
    const float sc = 1.0/1.0;
    p -= vec3(0.05,0.12,-0.09);    

    p *= sc;

    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,
                   0.7738444477, -0.6034162289, 0.1924931824,
                   0.0081370606,  0.3133626215, 0.9495986813) * p;

    const float b = 0.1759;
    
    float r = length( q.xy );
    float t = atan( q.y, q.x );
 
    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/
    float n = (log(r)/b - t)/(2.0*pi);

    float nm = (log(0.11)/b-t)/(2.0*pi);

    n = min(n,nm);
    
    float ni = floor( n );
    
    float r1 = exp( b * (t + 2.0*pi*ni));
    float r2 = r1 * 3.019863;
    
    //-------

    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;
    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;
    
    float d, dx, dy;
    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }
    else        { d = d2; dx=r2-r; dy=h2; }


    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;
    d += 0.002*di;
    
    matInfo = vec4(dx,dy,r/0.4,t/pi);

    vec3 s = q;
    q = q - vec3(0.34,-0.1,0.03);
    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;
    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);
    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );

    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );
    
    return d/sc;
}

// Function 2051
float sdf_rounded_cylinder( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 2052
vec2 getCloudDensityAndDistance( vec3 p, coordsys_t b, vec4 cloud_animation_params, sampler2D aChannel0 )
{
	float dist = getCloudDist( p, b, cloud_animation_params, aChannel0 );
	float density = ( dist > 0.0 ? 0.0 : exp_decay( max( -dist, 0.0 ) * cloud_sharpness ) * cloud_density ); // also: beta_c
//	float density = step( dist, 0.0 ); // little visual different and a little bit faster
	return vec2( density, dist );
}

// Function 2053
vec3 tonemap( vec3 linearRGB, vec2 position )
{
    const float limitHardness = 1.5;
    
    vec3 okl = vec3(0.0);
    if(position.x < 0.0)
    {
        okl = rgb_to_oklab(linearRGB);
    }
    else
    {
        okl = rgb_to_aces(linearRGB);
    }
    
    // Limit luminance.
    /*okl.x = okl.x / pow(pow(okl.x, limitHardness) + 1., 1./limitHardness);
    
    // Limit magnitude of chrominance.
    {
        float mag = length(okl.yz);
        float magAfter = mag;
        magAfter *= 4.;
        magAfter = magAfter / pow(pow(magAfter, limitHardness) + 1., 1./limitHardness);
        magAfter /= 4.;
        okl.yz *= magAfter/mag;
    }*/
    
    if(position.x < 0.0)
    {
        linearRGB = oklab_to_rgb(okl);
    }
    else
    {
        linearRGB = aces_to_rgb(okl);
    }

    // Try to keep the resulting value within the RGB gamut while
    // preserving chrominance and compensating for negative clipping.
    {

        {
            // Compensate for negative clipping.
            float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
            linearRGB = max(vec3(0), linearRGB);
            float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
            linearRGB *= lumBefore/lumAfter;
            
            // Keep the resulting value within the RGB gamut.
            linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));
        }
        

    }
        
  
    return Srgb3(linearRGB);
}

// Function 2054
vec3 SceneBloom()
{
    return vec3( 1.0, 0.2, 0.1 ) * 1.0 * vec3( exp( -gCarLampDist * 0.5 ) );
}

// Function 2055
float SDF (vec3 p) {
    p.x = mod(p.x+25., 50.)-25.;
    float x = max(abs(p.x+sin(p.z/5.)*5.)-2., 0.);
    // float SDFp = p.y+2.+(x > .5 ? x/2. : x*x/2.);
    float SDFp = p.y+2.+x;
    SDFp = min(SDFp, waterSDF(p));
    float PI = 3.1415926;
    float SPHSDFp = length(vec3(p.x-4., p.y-1., mod(p.z, PI*2.)-PI))-1.;
    SDFp = min(SDFp, SPHSDFp);
    return SDFp;
}

// Function 2056
float map_bottle(vec3 pos)
{
    if (!traceGlass)
        return 10.;
    pos = rotateVec2(pos);
    pos+= vec3(0.02, 0.56, 0.03);
    pos*= 1.25;
    
    float intb = map_bottle_int(pos);
    float extb = map_bottle_ext(pos);
    float df = max(extb, -intb);
    df = SoftMaximum(df, pos.y - 2.98, 120.);

    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    
    return df;
}

// Function 2057
vec3 CalculateNormalMapNormal(in vec2 uv, in float height, in vec3 normal, in vec3 tangent, in vec3 binormal)
{   
    vec3 normalMap = SampleNormalMap(uv, height).rgb;
	return normalize((normal * normalMap.b) + (binormal * normalMap.g) + (tangent * normalMap.r));
}

// Function 2058
float planeSDF(vec3 p) {
    return p.y;
}

// Function 2059
vec3 cubemap(vec3 rd) {
	vec3 col = texture(iChannel0, rd).rgb;
	return pow(col, vec3(gamma));
}

// Function 2060
float make_depthmap (vec3 color)
{
	return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// Function 2061
float sdf_core(vec3 p, float scale) {
	vec3 fp = fold(p * scale);
	float dist = dot(fp, normalize(sign(fp))) - .4 - sin(fp.y*.8)*1.8 - sin(fp.y*.7)*1.;
	dist += min(fp.x*8., sin(fp.y*.1));

	fp = fold(fp) - vec3(-.45, 6.7, -.1);
	fp = fold(fp) - vec3(-.3, 8.7, -0.9);
	fp = fold(fp) - vec3(0, .02, 0);
	dist += sin(fp.y*.2)*8.;
	dist *= .4;

	return dist / scale;
}

// Function 2062
float fogSdf(vec3 pos) {
    return length(pos) - 0.5;
}

// Function 2063
vec2 GetDistanceSphere( const in vec3 vPos )
{
	float fDistance = length(vPos - vec3(1.3, 0.75, 1.0)) - 0.75;

	return vec2(fDistance, kMaterialChrome);
}

// Function 2064
float signedDistanceVertical  ( in vec2 position ) { return position.x; }

// Function 2065
float map(vec3 p) {

    return trigNoise3D(p*0.5);
    
    // Three layers of noise, for comparison.
    //p += iTime;
    //return pn(p*.75)*0.57 + pn(p*1.875)*0.28 + pn(p*4.6875)*0.15;
}

// Function 2066
vec3 scene_object_color( vec3 r, mat2x3 Kr, float t, float r0, vec3 N, vec3 V, vec3 albedo,
                         bool submerged, int index )
{
    float h = length( r ) - r0;
    vec3 Z = normalize( r );
    vec3 skyL = texelFetch( iChannel2, ivec2( iResolution.x - 6., int( iResolution.y ) / 2 + 2 * index ), 0 ).xyz;
    vec3 skyR = texelFetch( iChannel2, ivec2( iResolution.x - 4., int( iResolution.y ) / 2 + 2 * index ), 0 ).xyz;
    vec4 skyZ = texelFetch( iChannel2, ivec2( iResolution.x - 2., int( iResolution.y ) / 2 + 2 * index ), 0 );
    vec3 TL = atm_transmittance( Z * max( g_data.radius, length( r ) ), g_env.L, g_atm, true );
    vec3 F = g_env.sunlight;
    vec3 L = g_env.L;
    if( submerged )
    {
        float d = max( 0.001, -.25 * h );
        vec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );
        F = F * M.w;
        F = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );
        L = normalize( -simple_refract( -L, Z ) );
    }
    F *= ts_shadow_sample( g_ts, iChannel1, r ) * TL * skyZ.w;
    float objshadow = scene_raycast_object_shadows( Ray( r, L ) );
    float slope = length( N / dot( N, Z ) - Z );
    vec3 ground = trn_albedo( r, 4. * h, h, slope, Z.z, false ) * ( F * dot( L, Z ) + skyZ.xyz );
    if( submerged )
    {
        skyZ.xyz = .75 * skyZ.xyz + .125 * skyL + .125 * skyR;
        skyL = .125 * skyL + .375 * ( skyZ.xyz + ground );
        skyR = .125 * skyR + .375 * ( skyZ.xyz + ground );
    }
    return scene_object_lighting( albedo, N, L, V, Z, F * objshadow, skyZ.xyz, skyL, skyR, ground );
}

// Function 2067
float dist(vec3 pos)
{
    return dist(pos,true);
}

// Function 2068
float GetDist(vec3 p){
    // some test object
    vec4 sphere = vec4(0,1,6,1);
    
    // distance to sphere
    //--------------------------------
    // distance to center of sphere: 
    // length(sphere position - camera position)
    // distance to outside of the sphere:
    // length(sphere position - camera position) - sphere radius
    float ds = length(p-sphere.xyz)-sphere.w;
    
    //distance to floor (plane)
    //this is just height of the origin point passed
    float dp = p.y;
    
    //capsule distance
    float cd = sdCapsule(p, vec3(2,0.5,6), vec3(2,1.5,6), 0.5);
    
    //torus distance
    float td = sdTorus(p-vec3(-3,0.5,6), vec2(.5,.3));
    
    //box distance
    float bd = dBox(p-vec3(-2,0.5,8),vec3(0.5));
    
    // cylinder distance
    float cyld = sdCylinder(p, vec3(1, .3, 5), vec3(4, 0.3, 6), .3);
    
    //choose the closest of the two
    float d = min(ds,dp);
    d = min(cd,d);
    d = min(d,td);
    d = min(bd,d);
    d = min(cyld,d);
    return d;
}

// Function 2069
void sceneCamera(
    in vec3 iResolution,
    in vec2 fragCoord,
    in float iTime,
    out vec3 camPos,
    out vec3 nvCamDir
) {
    float t = mod(iTime, 16.0);
    float angS = smoothstep(1.,3.,t) + smoothstep(5.,7.,t) + smoothstep(9.,11.,t) + smoothstep(13.,15.,t);
    float ang = 0.2 + angS*PI_OVER_2;
    float radS = smoothstep(1.,3.,t) - smoothstep(9.,11.,t);
    float rad = mix(0.6, 0.9, radS);
    camPos = (rad+0.05*cos(iTime*0.5))*vec3(sin(ang), 0.5+0.05*sin(iTime*0.5), cos(ang));

    vec3 camTarget = vec3(0.0);
    vec3 nvCamFw = normalize(camTarget - camPos);

    vec2 uv = fragCoord / iResolution.xy;
    vec4 clip = vec4(uv * 2.0 - 1.0, 1.0, 1.0);

    vec3 nvCamFixedUp = vec3(0.0, 1.0, 0.0);
    vec4 world = getClipToWorld(iResolution, nvCamFw, nvCamFixedUp) * clip;
    nvCamDir = normalize(world.xyz / world.w);
}

// Function 2070
vec2 king_sdf(vec3 point,vec3 offset, float color, float scale){
    vec3 p = point/scale;
    vec3 KING_POS = offset/scale;
    float base = bishop_base(p-vec3(KING_POS.x, KING_POS.y + 0.5, KING_POS.z));
   
    float shaft = king_shaft(p - vec3(KING_POS.x, KING_POS.y + 1.0, KING_POS.z));
    float head = king_tip(p-vec3(KING_POS.x, KING_POS.y + 5.5, KING_POS.z));
    return vec2(opSmoothUnion(opSmoothUnion(base, shaft,.65),head,0.5)*scale, color);
}

// Function 2071
vec4 cubemap( sampler2D sam, in vec3 d )
{
    vec3 n = abs(d);
    vec3 s = dFdx(d);
    vec3 t = dFdy(d);
    // intersect cube
         if(n.x>n.y && n.x>n.z) {d=d.xyz;s=s.xyz;t=t.xyz;}
    else if(n.y>n.x && n.y>n.z) {d=d.yzx;s=s.yzx;t=t.yzx;}
    else                        {d=d.zxy;s=s.zxy;t=t.zxy;}
    // project into face
    vec2 q = d.yz/d.x;
    // undistort in the edges
    q *= 1.25 - 0.25*q*q;
    // sample
    // TODO: the derivatives below are wrong, apply chain rule thx
    return textureGrad( sam,  0.5*q + 0.5,
                              0.5*(s.yz-q*s.x)/d.x,
                              0.5*(t.yz-q*t.x)/d.x );
}

// Function 2072
vec2 map(vec3 p) {
    // the tunnel distance estimate was taken from Shane's (https://www.shadertoy.com/view/MlXSWX)
    vec2 tun = abs(p.xy - path(p.z))*vec2(.4, .4);
    vec2 t = vec2(1. - max(tun.x, tun.y), 0.0);
    
    vec3 bp = boxPos(p, 2.5, 0.0);
    vec3 bp2 = boxPos(p, 2.5, 0.1);
    bp2.z += 0.5;
    
    bp.xy += path(bp.z);
    bp2.xy += path(bp2.z);
    
    vec2 s = vec2(min(len(p - bp2, 1.0) - .3, dSegment(p, bp, bp2, .04)), 1.0);
    
    vec2 o = vec2(dObstacles(p, 2.5), 2.0);
    
    return opU(t, opU(s, o));
}

// Function 2073
vec3 ShowScene (vec3 ro, vec3 rd, vec3 bgCol)
{
  vec4 col4;
  vec3 col, vn;
  float dstObj, ao;
  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *
     sin (8. * pi * tCur);
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (idObj == idFlr) col4 = (vn.y > -0.99) ? vec4 (0.9, 0.85, 0.85, 0.1) :
       vec4 (1., 0.3, 0., 0.2);
    else if (idObj == idBal) col4 = vec4 (0.6, 0.3, 0.1, 0.2);
    else if (idObj == idLBld) col4 = (abs (qHit.x) < 3.8 && abs (qHit.z) < 0.8) ?
       vec4 (0., 0., 0.4, 0.) : vec4 (0.85, 0.8, 0.8, 0.2);
    else if (idObj == idLad) col4 = vec4 (0.95, 0.95, 1., 0.2);
    else if (idObj == idGrnd) col4 = vec4 (0.7, 0.8, 0.7, 0.1) *
       (1. - 0.2 * abs (dot (floor (mod (0.75 * qHit.xz, 2.)), vec2 (1., -1.))));
    else if (idObj == idWal) col4 = vec4 (0.7, 0.7, 0.8, 0.1);
    else if (idObj == idPil) col4 = vec4 (1., 0.8, 0.2, 0.1);
    else if (idObj == idStr) col4 = (abs (qHit.x) > 0.85) ? vec4 (0.9, 0.85, 0.85, 0.2) :
       vec4 (0.6, 0.7, 0.6, 0.1);
    else if (idObj == idRf) col4 = vec4 (1., 0.3, 0., 0.2);
    else if (idObj == idFrz) col4 = vec4 (0.9, 0.5, 0., 0.2);
    else if (idObj > idPen) col4 = PengCol (ro);
    if (idObj == idLBld || idObj == idFlr || idObj == idWal) vn = VaryNf (16. * ro, vn, 0.5);
    ao = (idObj != idLad) ? ObjAO (ro, vn) : 1.;
    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +
       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
    col *= ao;
  } else {
    col = bgCol;
  }
  return pow (clamp (col, 0., 1.), vec3 (0.9));
}

// Function 2074
vec3 distort( in vec2 p )
{
    for( float i = 0.0; i < distort_iterations; ++i )
    {
        p += field( p ) / distort_iterations;
    }
    vec3 s = 2.5 * texture( iChannel0, vec2( 0.0, p.y * tex_scale ) ).xyz;

    return fbm( p, 0.0 ) * s;
}

// Function 2075
vec3 SceneNormal(vec3 p, float h, out float d, int izero)
{
    vec3 n, o = vec3(0,0,h);
    vec4 s;
    for (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))
        s[i] = Scene(p + o).d;        
    n = s.yzw - (d = s.x);
    if (dot(n,n) < 1e-7) n = vec3(0,1,0);
    else n = normalize(n);
    return n;
}

// Function 2076
vec3 sceneColor(vec2 uv, float worldTime) {
    // Thanks to BigWIngs for their mouse input stuff.
    vec2 mouse = iMouse.x > 20.0 && iMouse.y > 20.0
        ? iMouse.xy / iResolution.xy
        : vec2(0.40, 0.50);

    vec3 initialOrigin = vec3(0.0, 3.0, -3.0);
    initialOrigin.yz *= rotate(-mouse.y * 3.14 + 1.0);
    initialOrigin.xz *= rotate(-mouse.x * 6.2831);

    vec3 initialDirection = cameraRay(uv, initialOrigin, vec3(0.0, 0.55, 0.6), 1.45);
    
    vec3 origin = initialOrigin;
    vec3 direction = initialDirection;
    
    float bounce;
    vec3 color = vec3(1.0);
    TraceResult result;
    for (bounce = 0.0; bounce < maximumBounces; bounce += 1.0) {
        TraceResult result = sceneTrace(origin, direction, worldTime);
        
        if (!result.hit) {
            color = color * skyColor(result.incoming) * 2.0;
            break;
        }
        
        vec3 normal = sceneNormal(result.point, worldTime);
        
        // Apply AO to our first hit.
        if (bounce == 0.0) {
            color = color * sceneOcclusion(result.point, normal, worldTime);
        }

        color = color * 0.5;
        
        direction = reflect(direction, normal);
        origin = result.point + direction * 0.001;
    }
    
    if (bounce == maximumBounces) {
        return color * skyColor(direction);
    }

    return color;
}

// Function 2077
vec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale, float lod)
{
    p *= scale;
    
    return  (textureLod(tex,p.xy,lod).rgb*n.z*n.z
            +textureLod(tex,p.zy,lod).rgb*n.x*n.x
            +textureLod(tex,p.xz,lod).rgb*n.y*n.y);
}

// Function 2078
float distanceToShape(vec3 pos, vec3 dir, mat3 modelMatrix)
{
    float tot = 0.;
    for(int i = 0; i < NUM_MARCHES; i++) {
        float dist = sceneSDF(pos, modelMatrix);
        if (dist < EPSILON || tot > MAX_DISTANCE) {
        	return tot;
        }
        
        tot += dist;
        pos += dir * dist;
    }
    return MAX_DISTANCE;
}

// Function 2079
vec3 Scene_GetNormal( const in vec3 vPos, int insideObjId )
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos, insideObjId ).fDist * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos, insideObjId ).fDist * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos, insideObjId ).fDist * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos, insideObjId ).fDist * e.yyy;
    
    return normalize( vNormal );
}

// Function 2080
float mandelbox_dist(vec3 pos) {
    vec4 p = vec4(pos, 1.0), p0 = p;
    float minRad2 = 0.25;
    vec4 scale = vec4(2.0) / minRad2;
    float absScalem1 = abs(2.0 - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));
    for (int i=0; i<20; i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
        p = p * scale + p0;
    }
    return ((length(p.xyz)*(5.0*sin(iTime/4.0)) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Function 2081
vec2 map( vec3 pos , float io ){  
    vec2 idx =vec2(1.);
   
    vec2 crystal = prism( pos, prismSize );
    vec2 flow = goo( pos   );
    
    if( io > 0. ){
    
    	return opU( crystal , flow);
         
        
    }else{
        
        crystal.x = -crystal.x;
        return opU( flow , crystal );
      
        
    }
    

    
}

// Function 2082
float conoSDF( vec3 point, vec3 center, float len, float thickness, float angle ) {
    vec2 o = len * vec2( cos( angle ), sin( angle ) );
    vec3 a = vec3( center.xy + o, center.z );
        
    float h = projectVector( a, center, point );  
    vec3 q = a + ( center -a ) * h;
       
    h = pow( h, 0.7 ); // fatten up a bit...
    h *= 0.8; // little smaller...

    return length( point - q ) - thickness * h;
}

// Function 2083
float unionSDF(float distA, float distB)
	{ return min(distA, distB);}

// Function 2084
vec3 distPos(vec3 p)
{
    float lmin=min(FRes.x,min(FRes.y,FRes.z));
    return (p-.5*FRes)/(lmin*.5);
}

// Function 2085
bool raySceneIntersection( in Ray ray, in float distMin, out RayHit hit, out int objId, out float dist ) {
    float nearest_dist = 10000.0;
    
    //check lights
    for( int i=0; i<LIGHT_COUNT; i++ ) {
        float distToLight;
        if( raySphereIntersection( ray, spherelight[i], distToLight ) && (distToLight > distMin) && ( distToLight < nearest_dist ) ) {
            nearest_dist = distToLight;

            hit.pos = ray.origin + ray.dir*nearest_dist;
            hit.normal = normalize(hit.pos - spherelight[i].pos);
            hit.materialId = i;
            objId = i;
        }
    }
    
    //check sphere
    float distToSphere;
    if( raySphereIntersection( ray, sphereGeometry, distToSphere ) && (distToSphere > distMin) && ( distToSphere < nearest_dist ) ) {
        nearest_dist = distToSphere;

        hit.pos = ray.origin + ray.dir*nearest_dist;
        hit.normal = normalize(hit.pos - sphereGeometry.pos);
        
        vec3 n = normalize( vec3( hit.normal.x, 0.0, hit.normal.z ) );
        float u = acos( dot( vec3(1.0, 0.0, 0.0), n ) )/PI;
        float v = acos( dot( vec3(0.0, 1.0, 0.0), hit.normal ) )/PI;
        
        hit.uv = vec2( u, v );
        
        hit.materialId = MTL_SPHERE;
        objId = 2;
    }
    
    //check ground
    float distToPlane;
    if( rayPlaneIntersection( ray, ground, distToPlane ) && (distToPlane > distMin) && (distToPlane < nearest_dist ) ){
        nearest_dist = distToPlane;

        hit.pos = ray.origin + ray.dir*nearest_dist;
        hit.normal = ground.abcd.xyz;
        float uvScale = 2.0;
        hit.uv = vec2( abs( mod( hit.pos.x, uvScale )/uvScale ), abs( mod(hit.pos.z, uvScale)/uvScale ) );
        hit.materialId = MTL_WALL;
        objId = 3;
    }
    
    dist = nearest_dist;
    if( nearest_dist < 1000.0 ) {
    	hit.E = ray.dir*(-1.0);
        return true;
    } else {
    	return false;
    }
}

// Function 2086
void drawSDF(inout vec3 col, vec3 pcol, float d, float r)
{
    float psize = 1.0/iResolution.y;

    d = (d - r/zoom*psize*vRes.y) * zoom;

    col = mix(pcol, col, smoothstep(-psize,psize,d));
}

// Function 2087
float mapstage7 (in vec3 p)
{
   //modulo the position to effectively repeat the shape (infinitely)
   vec3 q= mod (p+2.0,4.0) - 2.0;
   //d1 now tests against q rather than p
   float d1 = length(q) - 1.0;   
   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; 
   float d2 = p.y + 1.0;
   return min (d1,d2);
}

// Function 2088
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 vc;
  vec3 vn, col;
  float dstObj, dstTun, dFac, bh, s, spec, att;
#if ! USE_TEX
  HexVorInit ();
#endif
  dstTun = TunRay (ro, rd);
  dstObj = ObjRay (ro, rd);
  if (min (dstTun, dstObj) < dstFar) {
    if (dstTun < dstObj) {
      ro += rd * dstTun;
      vn = TunNf (ro);
      dFac = (1. - smoothstep (0.3, 0.5, dstTun / dstFar));
      ro.xy -= TrackPath (ro.z).xy;
      if (idObj == idWal) {
        vn = VaryNf (8. * ro, vn, 8. * dFac * dFac * (1. - 0.5 * smoothstep (0.7, 1., - vn.y)));
        s = Fbm3 (32. * ro);
        col = mix (vec3 (0.4, 0.4, 0.45), vec3 (0.5, 0.4, 0.3), smoothstep (0.4, 0.5, s));
        spec = 0.01;
      } else if (idObj == idFlr) {
        s = dFac * (1. - smoothstep (-0.2, -0.1, dot (rd, vn)));
        vn = RippleNorm (ro.zx, vn, 4. * s);
        vn = VaryNf (16. * ro, vn, s);
        col = vec3 (0.5, 0.3, 0.1) * (1. - 0.2 * smoothstep (0.4, 0.85,
           length (vec2 (ro.x, mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep)) / radTun));
        spec = 0.01;
      }
    } else {
      ro += rd * dstObj;
      vn = ObjNf (ro);
      spec = 0.1;
      if (idObj == idLmp) {
        col = vec3 (1., 1., 0.7) * 0.5 * (1. - vn.y);
        spec = -1.;
      } else if (idObj == idLmpH) {
        col = vec3 (0.6, 0.4, 0.1);
        spec = 0.;
      } else if (idObj == idDrBod) {
        col = vec3 (0.9, 0.7, 0.3) * (1. - 0.3 * smoothstep (0.4, 0.85,
           abs (mod (ro.z + lmpSep, 2. * lmpSep) - lmpSep) / radTun));
        spec = 0.3;
      } else if (idObj == idDrLamp) {
        col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.), step (0., sin (10. * tCur)));
        spec = -1.;
      } else if (idObj == idDrCam) {
        col = vec3 (0.1);
        spec = 0.3;
      }
    }
    if (spec >= 0.) col = col * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.) +
       spec * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));
    s = min (dstTun, dstObj);
    att = SmoothMin (350. / pow (s, 2.), 1., 0.5) * (1. - smoothstep (60., 70., s));
    col *= att;
  } else col = vec3 (0.);
  return clamp (mix (col, vec3 (col.b), 0.2) * mix (1., smoothstep (0., 1.,
     Maxv3 (col)), 0.2), 0., 1.);
}

// Function 2089
vec4 Scene(in vec3 rO, in vec3 rD)
{
    //float t = 0.0;
	float t = 20.0 * texture(iChannel0, coord.xy / iChannelResolution[0].xy).y;
	float alpha;
	vec4 normal = vec4(0.0);
	vec3 p = vec3(0.0);
	float oldT = 0.0;
	for( int j=0; j < 105; j++ )
	{
		if (normal.w >= .8 || t > 1400.0) break;
		p = rO + t*rD;
		float sphereR = SphereRadius(t);
		float h = Map(p);
		if( h < sphereR)
		{
			// Accumulate the normals...
			//vec3 nor = GetNormal(rO + BinarySubdivision(rO, rD, t, oldT, sphereR) * rD, sphereR);
			vec3 nor = GetNormal(p, sphereR);
			alpha = (1.0 - normal.w) * ((sphereR-h) / sphereR);
			normal += vec4(nor * alpha, alpha);
		}
		oldT = t;
		t +=  h*.5 + t * .003;
	}
	normal.xyz = normalize(normal.xyz);
	// Scale the alpha up to 1.0...
	normal.w = clamp(normal.w * (1.0 / .8), 0.0, 1.0);
	// Fog...   :)
	normal.w /= 1.0+(smoothstep(300.0, 1400.0, t) * 2.0);
	return normal;
}

// Function 2090
vec2 map(in vec3 pos) {
  // Ring planet.
  vec3 rp = (pos - vec3(0.0, 0.25, 1.6)) * rot3(0.5, 0.1, 0.0);
  vec2 res = vec2(sdSphere(rp, 0.25), 1.5 + rp.y);
  res = opU(res, vec2(sdDiscRing(rp, vec3(0.55, 0.33, 0.003)), 2.0 + length(rp.xz)));

  // Sun.
  //res = opU(res, vec2(sdSphere(pos - SUN_POS, 2.5), 3));

  // Close planet.
  res = opU(res, vec2(sdSphere(pos - CLOSE_PLANET_POS, 1.3), 4));

  // Space station.
  vec3 pos2 = (pos - vec3(0.35, -0.7, -0.45)) * rot3(0.0, 0.3 * iTime, 0.1);
  res = opU(res, vec2(sdCapsule(pos2, vec3(0.0, -0.25, 0.0), vec3(0.0, 0.25, 0.0), 0.03), 5));
  res = opU(res, vec2(sdCapsule(pos2, vec3(0.0, 0.0, -0.22), vec3(0.0, 0.0, 0.22), 0.02), 6));
  float arcpos = atan(pos2.z, pos2.x) * 0.95492965855;
  res = opU(res, vec2(sdDiscRing(pos2, vec3(0.25, 0.2, 0.02)), (fract(arcpos - 0.1) < 0.8) ? 6 : 7));

  return res;
}

// Function 2091
float map(vec4 p, float size) {

  float spd = 0.6;
  
  p.yz *= rot(time*0.05);
  p.xw *= rot(time * spd);
  p.yw *= rot(time*0.2*spd);
  p.xw *= rot(time*0.7*spd);
  p.zw *= rot(time*0.3*spd);
  
  //p.xz *= rot(time*0.2);

#if SPHERE_GRID
  // grid inside a sphere
  float d = sph(p, 2.0);

  vec4 rp2 = rep(p, vec4(1.0));

  //float size = 0.24;
  size*=0.55;
  float c = box2(rp2.xz, size);
  c = min(c, box2(rp2.xy, size));
  c = min(c, box2(rp2.yz, size));
  c = min(c, box2(rp2.xw, size));
  c = min(c, box2(rp2.yw, size));
  c = min(c, box2(rp2.zw, size));
  d = max(d, -c);
#else
    
  // tesseract
  float d = box(p, 1.0);

  vec4 rp = p;//rep(op, vec4(0.4));
  //float size = 0.95;
  float c = box2(rp.xz, size);
  c = min(c, box2(rp.xy, size));
  c = min(c, box2(rp.yz, size));
  c = min(c, box2(rp.xw, size));
  c = min(c, box2(rp.yw, size));
  c = min(c, box2(rp.zw, size));

  d = max(d, -c);

#endif
  
  return d;
}

// Function 2092
float drawScene(vec3 p, out int id)
{
    vec3 position = p + vec3(-1.5,-1.,-3.+2.*sin(iTime));
    float dt = 	sdSphere(position,.5);
    id = 0;
    float d;
    
    position = p + vec3(2.5*sin(iTime),-2.5,0.);
    vec3 ppp = (rotate(PI*.25+.25*sin(iTime),vec3(1.,0.,0.)) * vec4(position,1.)).xyz;
    d = sdTorus( ppp, vec2(1.,.2) );
    if( d < dt )
    {
        dt = d; 
        id = 1;
    }

    position = p + vec3(3.*cos(iTime),-1.0,0.);
    d = udBox( position,vec3(.5) );
    if( d < dt )
    {
        dt = d; 
        id = 2;
    }

    position = p + vec3(2.,-.7,-2.5);
    d = sdEllipsoid( position, vec3(.3,1.5,1.) );
    if( d < dt )
    {
        dt = d; 
        id = 3;
    }

    // floor
    position = p + vec3(0.,1,0.);
    d = udBox( position,vec3(10.,.0,10.5) );
	//    d = sdPlane(position);
    if( d < dt )
    {
        dt = d; 
        id = 4;
    }
    
    // wall
    position = p + vec3(0.,0.,1.7);
    d = udBox( position,vec3(10.,10.0,0.5) );
	//    d = sdPlane(position);
    if( d < dt )
    {
        dt = d; 
        id = 4;
    }


    
	return dt;
}

// Function 2093
float sdFace0(vec3 p) {
    float fiz = mod(p.z, 2.0*HALF_OUTER_DIAM);
    vec3 pArch = vec3( abs(fiz-HALF_OUTER_DIAM), p.y, abs(p.x) );
    float dArch = sdArchA(HALF_OUTER_DIAM, HALF_WIDTH, pArch);

    return dArch;
}

// Function 2094
float sphereSDF (vec3 p, float r) {
  return length(p) - r;
}

// Function 2095
SDFResult lightSDF( vec3 p )
{
    float cablelen = g_lightpivot.y - g_lightpos.y;
    vec3 vecY = g_light.pos - g_lightpivot;
    vecY = normalize(vecY);
        
    SDFResult res = vertcapSDF2(VertCap(g_lightpivot, cablelen-0.1, 0.005, WHITE), vecY, p);
    return res;
}

// Function 2096
Object map(vec3 p) {
    Object o = NewObject;
    

    //o = omin(o, sdFloorA(p - vec3(0.,-0.14,0)), materials[0]);
    
    //o = omin(o, sdWall(p - vec3(0.9,0.,0)), materials[0]);
    
    ////o = omin(o, -sdWall(p - vec3(-0.4,0.,0)), materials[0]);
    //o = omin(o, sdWall(p - vec3(0.4,0.,0)), materials[1]);
    //o = omin(o, sdSphere(p - vec3(-.6,0.4,0.6), 0.2), materials[0]);
    
    o = omin(o, sdJulia(p - vec3(-0.0,0.0,0.1)).d, materials[2]);
    //p.xz *= rot(0.1);
    p.y += 1.7;
    o = omin(o, sdJulia(p - vec3(4.,6.0,2.)).d, materials[2]);
    
    
    o.didHit = true;
    o.d *= 0.8;
    return o;
}

// Function 2097
vec3 map1(in vec3 pos) {
    vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.49,-0.4), vec2(0.3,0.5))), ID_GLASS_WALL, ETA);
    res = opU(res, vec3(sdSphere(pos-vec3(0.,0.31,0.4),0.3),ID_GLASS_WALL, ETA));
  //  res = opU(res, vec3(sdTorus(pos.yxz-vec3(0.3,0.,-0.7),vec2(0.2,0.1)),ID_GLASS_WALL, ETA));
    res.x =abs(res.x);
   
 	return res;
}

// Function 2098
vec3 shade_scene( vec3 ip, vec3 ro, vec3 rd )
{
    vec3 lpos = 4. * vec3(0., 1., 0.);
    vec3 n = surface_normal( ip );
    vec3 ldir = normalize(lpos - ip);
    
    float s = soft_shadow( ip, ldir, .02, 10., 10.);
    float ao = ambient_occ( ip, n );
    
    float mody = mod(4. * ip.y, 1.);
    float stripes = step(length(ip.xz), 14.) * (smoothstep(0., .05, mody) - smoothstep(.5, .55, mody));
    vec3 scol =  mix(vec3(.5, .6, 1.), vec3(.2, .2, .4), stripes);

    float falloff = pow(max(0., 1. - length(lpos - ip)/19.), 2.);

    vec3 diff = 5. * scol * max(0., dot(ldir, n));
    vec3 spec = vec3(2.) * pow(max(0., dot(ldir, reflect(rd, n))), 8.);
    vec3 amb = scol * .8 * (1. - ao);
    vec3 bnc = scol * .6 * pow(ip.y + 1.3,2.) * max(0., dot(n, normalize(ro - ip + vec3(0., -8., 0.))));
    
    return falloff * (s * (diff + spec) + 
           		      (amb + bnc));
}

// Function 2099
float sdf_QUAKE(vec2 uv)
{
    uv /= 28.;
    uv.y -= 4.;
    uv.x -= .0625;
    
    float sdf						   = sdf_Q_top(uv);
    uv.y += .875;   sdf = sdf_union(sdf, sdf_U(uv));
    uv.y += .75;	sdf = sdf_union(sdf, sdf_A(uv));
    uv.y += .75;	sdf = sdf_union(sdf, sdf_K(uv - vec2(.2, 0)));
    uv.y += .8125;	sdf = sdf_union(sdf, sdf_E(uv));
    
    sdf *= 28.;
    uv += sin(uv.yx * TAU) * (5./28.);
    sdf = sdf_union(sdf, 28. * (.75 - around(.3, .25, smooth_weyl_noise(2. + uv * 3.24))));
    return sdf_exclude(sdf, (uv.y - .15) * 28.);
}

// Function 2100
vec3 DrawMap(vec2 pixelCoord, float offset, vec3 color)
{
    if(offset < float(LEVEL_HEIGHT_IN_PIXELS)*.5)
    {
        int ioffset = int(offset);
        
        // vec3 PrintStr(vec2 fragCoord, int x, int y, int str, vec3 color, vec3 inputColor)
        color = PrintStr(pixelCoord, 1*8, 25*8+ioffset, STR_BEGINNING0, vec3(1), color);
        color = PrintStr(pixelCoord, 2*8, 23*8+ioffset, STR_BEGINNING1, vec3(1), color);
        color = PrintStr(pixelCoord, 6*8, 21*8+ioffset, STR_BEGINNING2, vec3(1), color);
        color = PrintStr(pixelCoord, 4*8, 19*8+ioffset, STR_BEGINNING3, vec3(1), color);
        color = PrintStr(pixelCoord, 9*8, 16*8+ioffset, STR_BEGINNING4, vec3(1), color);
    }
    
    int level = int(offset - pixelCoord.y + float(LEVEL_HEIGHT_IN_PIXELS)) / LEVEL_HEIGHT_IN_PIXELS;
    level = ModLevel(level);
    pixelCoord.y = mod(pixelCoord.y - offset, float(LEVEL_HEIGHT_IN_PIXELS));
                    
    vec2 tileCoord = floor((pixelCoord + 0.5) / TILE_SIZE);
    vec2 tileOffset = (pixelCoord - tileCoord*TILE_SIZE);
    tileOffset.y = (TILE_SIZE - 1.0) - tileOffset.y;
    
    
    
    
    int tile = level;
    if(Map(tileCoord, level))
    {
        color = Tile(tileOffset, tile);
    }
    else
    {
        //TODO: optimize this!
        vec3 color0, color1;
        TileShadowColors(tile, color0, color1);
        bool left = Map(tileCoord+vec2(-1,0), level);
        bool up = Map(tileCoord+vec2(0,1), level);
        bool upleft = Map(tileCoord+vec2(-1,1), level);
        if(upleft && left && up && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)
        	color = (tileOffset.x < tileOffset.y)?color0:color1;
        else if(upleft && left && tileOffset.x < SHADOW_WIDTH)
        	color = color0;// now is the beginning...
        else if(upleft && up && tileOffset.y < SHADOW_WIDTH)
        	color = color1;
        else if(upleft && tileOffset.x < SHADOW_WIDTH && tileOffset.y < SHADOW_WIDTH)
        	color = (tileOffset.x < tileOffset.y)?color1:color0;
        else if(left && tileOffset.x < SHADOW_WIDTH)
            color = (tileOffset.x < tileOffset.y)?color0:vec3(0);
        else if(up && tileOffset.y < SHADOW_WIDTH)
            color = (tileOffset.x < tileOffset.y)?vec3(0):color1;
    }
    return color;
}

// Function 2101
float dist2Vertex(vec4 z, float r){
	float ca=dot(z,p), sa=0.5*length(p-z)*length(p+z);//sqrt(1.-ca*ca);//
	return DD(ca,sa,r)-VRadius;
}

// Function 2102
vec3 GetSceneLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{                
  vec3 reflectDir = reflect( rayDir, normal );
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y/20.0, 0.0, 1.0);

  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  float fre = pow( 1.0-abs(dot( normal, rayDir )), 4.0 );
  fre = mix( .03, 1.0, fre );   

  vec3 reflection = vec3(1.0);
  vec3 lightTot = vec3(0.0);

  lightTot += 1.15*dif*vec3(1.00, 0.90, 0.85);
  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;    
  lightTot= mix(lightTot, reflection, fre );
  lightTot += 0.70*skylight*vec3(0.70, 0.70, 0.85);
  lightTot += 1.30*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*amb*vec3(0.80, 0.90, 0.95);  
  return clamp(lightTot, 0., 10.);
}

// Function 2103
float sceneSDF(vec3 samplePoint) {
    // Rotate entire scene 
    samplePoint = (rotateY(iTime / 2.0) * vec4(samplePoint, 1.0)).xyz;
    // Box distortions 
    float boxX = 0.2;
    float boxY = 1.5;
    float boxZ = 1.5; 
    vec3 wallPoint = (rotateX(iTime) * vec4(samplePoint, 1.0)).xyz;
    float sphereShapeChange = 0.5 * sin(2.0 * iTime) + 0.5;
    float sphere = sphereSDF(samplePoint / sphereShapeChange) * sphereShapeChange;
    float wall = ubox(wallPoint / vec3(boxX, boxY, boxZ)) * min(boxX, min(boxY, boxZ));
	float hole = differenceSDF(wall, sphere);
    float ball = sphereSDF((samplePoint + vec3(2.0 * sin(iTime - 3.14 / 4.0), 0.0, 0.0))/ 0.5) * 0.5;
    return unionSDF(hole, ball);
	//return hole;
}

// Function 2104
float distSnow(vec3 pos)
{
	return min(smin(distPlaneBump(pos, GROUND_NORMAL, GROUND_HEIGHT, SNOW_BUMP, SNOW_TEX_SCALE), 
					   distCapsule(pos, SNOW_BOTTOM, SNOW_TOP, SNOW_RAD, SNOW_BUMP, SNOW_TEX_SCALE), SMIN_FACTOR), 
			distCylinderBump(pos, TREE_SNOW_PROP, TREE_SNOW_BUMP, SNOW_TEX_SCALE));
}

// Function 2105
float mapn(vec3 p, vec3 div) {
    #if USE_3D_VOLUME_NORMAL
    	float d = map2(p, div);
    #else
    	float d = map(p, time);
    #endif
    
    d=max(d, limit(p));
    d=smin(d, background(p), 0.2);
    return d;
}

// Function 2106
float calculateDistance(in vec3 p, out vec3 color) {
    float height = texture(iChannel1, vec2(p.xz+iTime)*0.05 ).r;
    color = height+vec3(1.0);  
    float finalDistance = 10000000.;
    finalDistance = min(finalDistance, udBox( p-vec3(0.0,-2.0+height*0.1+sin(p.x*0.6+iTime)*0.1,0.0), vec3(30.,0.7,30.0) ) );
    float dist1 = palkki(p,color);
    if(dist1 < finalDistance){
        finalDistance = dist1;
        color = vec3(5.0,0.0,0.0);
    }
    return finalDistance;
}

// Function 2107
vec2 mapTree(in vec3 p) {
	float 
        a = mix(.045,.001,clpOld)*p.y*cos(jGlobalTime*10.), // (life < OLD_TREE ? 22. : mix(22.,1.,clamp(life- OLD_TREE,0.,1.)))); 
	    c = cos(a),
        s = sin(a);
    p.xz *= mat2(c,-s,s,c);
	p.y *= (1.05+ mix(.04*cos(jGlobalTime/4.*6.28+.8), 0., clpOld));
	return sdTree(p);
}

// Function 2108
float sceneSDF(vec3 samplePoint) {
    float minDis1 = cubeSDF(samplePoint);
    float minDis2 = sphereSDF(samplePoint);
    float minDis3 = planeSDF(samplePoint);
    return min(min(minDis1, minDis2),minDis3);
}

// Function 2109
vec2 GetDistanceFloor( const in vec3 vPos )
{
	return vec2(vPos.y, kMaterialWood);
}

// Function 2110
void drawMap(inout vec4 c, vec2 fragCoord)
{
    if (iResolution.x < 420.)
        return;
    
    // show map memory.
    ivec2 ifc = ivec2(fragCoord/4.);
    if (ifc.x > 0 && ifc.x < SX && ifc.y > 0 &&ifc.y < SY)  
        c = mix(c, textureBase ( iChannel0, ifc), .5 );
    
}

// Function 2111
float map2(vec3 p)
{
    p = objmov(p);
    return length(p)-1.3;
}

// Function 2112
float sdf_plane(vec2 pos, vec2 plane_pos, float angle) {
    pos -= plane_pos;
    return (sin(angle) * pos.y - cos(angle) * pos.x);
}

// Function 2113
float scene(vec3 p){
    float yFactor = p.y;
    float time = iTime * 2.;
    vec2 cntr = vec2(fbm1x(yFactor, time), fbm1x(yFactor + 78.233, time))
          	  * smoothstep(-1., 2., yFactor);
    if(layer() > 3)
    	p.xz -= cntr;
    
    float rad = 1.;
    if(layer() > 2)
    	rad = smoothstep(2.5, -2., p.y);
    float ang = atan(p.x, p.z) + fbm1x(p.y, iTime);
    float n = noised(vec2(ang * 8./6.2831, p.y - iTime * 3.)) * .75;
    
    if(layer() > 4)
        rad -= n * rad;
    
    float cyl = sdCylinder(p, vec2(rad, 2.));
    if(layer() < 2)
        return cyl;
    
    float sphereRad = 1.;
    if(layer() > 4)
        sphereRad -= 1. + n * smoothstep(-1., 0., p.y + 2.);
    float sphere = length(p + vec3(0., 2., 0.)) - sphereRad;
    return min(cyl, sphere);
}

// Function 2114
float sdf_line(vec2 uv, vec2 a, vec2 b, float thickness)
{
    vec2 ab = b-a;
    vec2 ap = uv-a;
    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);
    return length(uv - (ab*t + a)) - thickness*.5;
}

// Function 2115
SSdfSample SdfScene(vec3 pos, float uRandom)
{
	SSdfSample sdf = SdfBlobby(pos, uRandom);

	// Try to keep from penetrating the ground plane
	// BB Causes issues with shadows, better solution?

	sdf.m_s += max(0.0, max(20.0 - pos.z, 100.0 / max(pos.z, 1e-6)));

	// And g_zMax

	sdf.m_s += max(0.0, max(20.0 - (g_zMax - pos.z), 100.0 / max(g_zMax - pos.z, 1e-6)));

	return sdf;
}

// Function 2116
float capsulesdf(vec3 pos, vec3 a, vec3 b) {
    vec3 dir = b - a;
    vec3 view = pos - a;
    float h = clamp(dot(dir, view) / dot(dir, dir), 0., 1.);
    return length(view - h * dir) - radius;
}

// Function 2117
vec3 DoBumpMap(const in vec3 p, const in vec3 nor, const in float bumpfactor, const in float dist)
    {
        const vec2 e = vec2(0.001, 0); 

        float ref = BumpSurf3D(p, dist);
        vec3 grad = (vec3(BumpSurf3D(p - e.xyy, dist),
                          BumpSurf3D(p - e.yxy, dist),
                          BumpSurf3D(p - e.yyx, dist)) - ref)/e.x; 

        grad -= nor*dot(nor, grad);          
        return normalize(nor + grad*bumpfactor);
    }

// Function 2118
float unToneMap(float c)
{
    switch (method) {
  	  case 0: // via inverse filmic-like Reinhard-esque combination approximation
        c = c/(6.-6.*c);
		break;
      case 1: // inverse ACES+sRGB
        c = pow(c, 2.2); // from sRGBish gamut
        c = -(sqrt((-10127.*c+13702.)*c+9.)+59.*c-3.) / (486.*c-502.); // inverse ACES according to Maxima
	    break;
      default: // just un-sRGB
        c = pow(c, 2.2);
        break;
    }
    return c;
}

// Function 2119
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    rstate = uvec2(fragCoord.xy) + uint(iFrame) / 6U * 4096U;

    // Project ray direction on to the unit cube.
    vec3 absRayDir = abs(rayDir);
    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));

    // Get the index of the current face being rendered.
    int faceIndex = 0;

    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)
    {
        faceIndex = 2;
    }
    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)
    {
        faceIndex = 4;
    }

    if(rayDir[faceIndex / 2] > 0.)
        faceIndex |= 1;

    // Sample previous result.
    fragColor = textureLod(iChannel0, rayDir,0.);

    // Skip this face if it's not the one chosen for this frame.
    if(faceIndex != (iFrame % 6))
        return;

    // Render for only one of the boxes per frame, as an extra speedup.
    if((iFrame / 12 & 1) == 0)
    {
        vec3 p = vec3(-1), q = vec3(1);
        vec3 samplePoint = (p + q) / 2. + (q - p) * rayDir / 2.;
        vec3 sampleNormal = boxNormal(samplePoint, p, q);
        fragColor.rg += sampleScene(samplePoint, -sampleNormal);
    }
    else
    {
        vec3 p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);
        vec3 samplePoint = (p + q) / 2. + (q - p) * rayDir / 2.;
        vec3 sampleNormal = boxNormal(samplePoint, p, q);
        fragColor.ba += sampleScene(samplePoint, sampleNormal);
    }

}

// Function 2120
float mapSeed(vec2 f)
{
    return min(LIGHT_DIST2, mapSeedNoLight(f));
}

// Function 2121
float PointSegDistance2(vec2 p, vec2 p0, vec2 p1)
{
    vec2 d = p1 - p0;
    
    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);

    vec2 proj = (1.0-t)*p0 + t*p1;
    
    return dot(proj-p, proj-p);
}

// Function 2122
vec3 distanceMeter(float dist, float rayLength, vec3 rayDir, float camHeight) {
    float idealGridDistance = 20.0/rayLength*pow(abs(rayDir.y),0.8);
    float nearestBase = floor(log(idealGridDistance)/log(10.));
    float relativeDist = abs(dist/camHeight);
    
    float largerDistance = pow(10.0,nearestBase+1.);
    float smallerDistance = pow(10.0,nearestBase);

   
    vec3 col = fusionHDR(log(1.+relativeDist));
    col = max(vec3(0.),col);
    if (sign(dist) < 0.) {
        col = col.grb*3.;
    }

    float l0 = (pow(0.5+0.5*cos(dist*PI*2.*smallerDistance),10.0));
    float l1 = (pow(0.5+0.5*cos(dist*PI*2.*largerDistance),10.0));
    
    float x = fract(log(idealGridDistance)/log(10.));
    l0 = mix(l0,0.,smoothstep(0.5,1.0,x));
    l1 = mix(0.,l1,smoothstep(0.0,0.5,x));

    col.rgb *= 0.1+0.9*(1.-l0)*(1.-l1);
    return col;
}

// Function 2123
vec3 tone_map(in Fragment fragment, float luma)
{
    fragment.color = exp(-1.0 / (2.72 * fragment.color + 0.15));
    fragment.color = pow(fragment.color, vec3(1.0 / (fragment.gamma * luma)));
    return fragment.color;
}

// Function 2124
vec3 diceSDF (vec3 p) {
    float iceSDFp = iceSDF(p);
    // return normalize(
    //     vec3(
    //         iceSDF(vec3(p.x+1e-3, p.y, p.z))-iceSDFp,
    //         iceSDF(vec3(p.x, p.y+1e-3, p.z))-iceSDFp,
    //         iceSDF(vec3(p.x, p.y, p.z+1e-3))-iceSDFp
    //     )
    // );
    // ;P
    return vec3(0., 1., 0.);
}

// Function 2125
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{        
  vec3 reflectDir = reflect( rayDir, normal );

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);  
  dif *= SoftShadow( shadowPos, sunPos);
  skylight *=SoftShadow(shadowPos, reflectDir);

  vec3 lightTot = vec3(0.0);

    
    
  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);
      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);
  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));
}

// Function 2126
SceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )
{
    if ( a.fDist > b.fDist )
    {
        return a;
    }
    return b;
}

// Function 2127
void MapBodySoundboard(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos -  vec3(0.0,80.0,-10.0);
	float re_3 = MapPianoBodyShapeDist(-pos.x, pos.z);
	float re_2 = abs(pos.y) - 6.0;
	float re = Combine(re_3, re_2) + 4.0;
	
	if (re< EPSILON)
	{
		obj.m_obj_idx = 5;
	}
	obj.m_dist = re;
}

// Function 2128
void InitScene()
{
    vec3 sceneCenter = vec3(0,0,0);
    float sceneRadius = 20.0;
    for (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {
        boxes[i].localToWorld = MakeOrthoBasis(randV(rand2()));
        boxes[i].center = sceneCenter + sceneRadius*randV(rand2());
        boxes[i].extent = mix(vec3(2), vec3(4), rand3());
		boxes[i].roundRadius = 1.0;
        boxes[i].albedo = mix(vec3(0.7), vec3(0.9), rand3());
    }
}

// Function 2129
void SceneInit(out Scene s)
{
    // Setup camera
    s.cam.pos 	  = vec3(0);
    s.cam.forward = vec3(0,0,1);
    s.cam.right   = normalize(cross(vec3(0, 1, 0), s.cam.forward));
    s.cam.up      = normalize(cross(s.cam.forward, s.cam.right));
    s.cam.fPersp  = 2.0;
    
	// Floor
    Shape boxFloor;
    boxFloor.ID  		= FLOOR;
    boxFloor.snellIndex = 3.;
    boxFloor.isEmissive = false;
    boxFloor.blendType  = NO_OP;
    boxFloor.type	    = BOX;
    boxFloor.pos  	    = vec3(0, -2.6, 5);
    boxFloor.scale      = vec3(5, .1, 5);
    boxFloor.color      = vec4(WHITE, 1);
    boxFloor.glossy     = .0;

    s.objects[FLOOR] = boxFloor;
    
    // Right Wall
    Shape rWall;
    rWall.ID		 = RIGHT_WALL;
    rWall.snellIndex = 3.;
    rWall.isEmissive = false;
    rWall.blendType  = NO_OP;
    rWall.type       = BOX;
    rWall.pos        = vec3(3, 0, 5);
    rWall.scale      = vec3(.1, 5, 5);
    rWall.color      = vec4(GREEN, 1);
    rWall.glossy     = .0;
    
    s.objects[RIGHT_WALL] = rWall;

    // Left Wall
    Shape lWall;
    lWall.ID		 = LEFT_WALL;
    lWall.snellIndex = 3.;
    lWall.isEmissive = false;
    lWall.blendType  = NO_OP;
    lWall.type       = BOX;
    lWall.pos        = vec3(-3, 0, 5);
    lWall.scale      = vec3(.1, 5, 5);
    lWall.color      = vec4(RED, 1);
    lWall.glossy     = .0;
    
    s.objects[LEFT_WALL] = lWall;
    
    // Back Wall
    Shape bWall;
    bWall.ID		 = BACK_WALL;
    bWall.snellIndex = 3.;
    bWall.isEmissive = false;
    bWall.blendType  = NO_OP;
    bWall.type       = BOX;
    bWall.pos        = vec3(0, 0, 10);
    bWall.scale      = vec3(5, 5, .1);
    bWall.color      = vec4(TEAL, 1);
    bWall.glossy     = .0;
    
    s.objects[BACK_WALL] = bWall;
    
    // Ceiling
    Shape ceiling;
    ceiling.ID		   = CEILING;
    ceiling.snellIndex = 3.;
    ceiling.isEmissive = false;
    ceiling.blendType  = NO_OP;
    ceiling.type	   = BOX;
    ceiling.pos        = vec3(0, 4.1, 5);
    ceiling.scale      = vec3(5, .1, 5);
    ceiling.color      = vec4(WHITE, 1);
    ceiling.glossy     = .0;
    
    s.objects[CEILING] = ceiling;
    
    // Surface light
    Shape sLight;
    sLight.ID		  = SURFACE_LIGHT;
    sLight.snellIndex = 3.;
    sLight.isEmissive = true;
    sLight.blendType  = NO_OP;
    sLight.type	      = BOX;
    sLight.pos        = vec3(0, 3.9, 7.5);
    sLight.scale      = vec3(.75, .1, .75);
    sLight.color      = vec4(WHITE, 1);
    sLight.glossy     = .0;
    
    s.objects[SURFACE_LIGHT] = sLight;
    
    // Moving Ball
    Shape ball;
    ball.ID			= BALL_01;
    ball.snellIndex = 1.5;
    ball.isEmissive = false;
    ball.blendType  = BLEND;
    ball.blendStrength = .25;
    ball.type       = SPHERE;
    ball.pos        = vec3(sin(iTime),-1.35*sin(iTime*0.5), 5.+sin(2.*iTime));
    ball.radii      = vec2(.7,0);
    ball.color      = vec4(1,1,1,0); // For transparent materials, it is the absortion
    ball.glossy     = .1;
    
    s.objects[BALL_01] = ball;
    
    // Middle Ball
    Shape ball2;
    ball2.ID		 = BALL_02;
    ball2.snellIndex = 1.5;
    ball2.isEmissive = false;
    ball2.blendType  = BLEND;
    ball2.blendStrength = .25;
    ball2.type       = SPHERE;
    ball2.pos        = vec3(0,0,4);
    ball2.radii      = vec2(.5,0);
    ball2.color      = vec4(1,1,1,0);
    ball2.glossy     = 0.1;
    
    s.objects[BALL_02] = ball2;
    
    return;
}

// Function 2130
float spinIconDist(vec2 pos, float size, bool flip, bool dim) {
    
    if (flip) { pos.y = -pos.y; }  
    pos.x = abs(pos.x);
    
    vec2 p0 = vec2(0, -0.7)*textSize;
    vec2 p1 = vec2(0.35, -0.7)*textSize;
    vec2 p2 = vec2(0.0, -1.1)*textSize;
    
    float d = max(lineDist2D(p0, p1, pos), 
                  lineDist2D(p1, p2, pos));
    
    if (dim) { 
        d = abs(d + 0.02*textSize) - 0.02*textSize;
    }
    
    return d;
       
}

// Function 2131
float map(vec3 p) {
    float radius = texture(iChannel0, vec2(hash(floor(p)), .25)).x * .99 + .01;
    return length(fract(p) - .5) - .25 * radius;
}

// Function 2132
vec4 cubemap( sampler2D sam, in vec3 d )
{
    // intersect cube
    vec3 n = abs(d);
    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: 
             (n.y>n.x && n.y>n.z) ? d.yzx:
                                    d.zxy;
    // project into face
    vec2 q = v.yz/v.x;
    // undistort in the edges
    q *= 1.25 - 0.25*q*q;
    // sample
    return texture( sam, 0.5+0.5*q );
}

// Function 2133
vec3 unToneMap(vec3 crgb, float exposure)
{
    vec3 c = crgb * toneMap(exposure);
    for (int i = 3; i-- > 0; ) c[i] = unToneMap(c[i]);
    return c;
}

// Function 2134
vec2 scene(vec3 pos) {
  vec2 res = vec2(sdZuul(pos), 29.);
  #ifdef FLOOR
  float plane = sdPlane(pos + vec3(.0, 1., .0));
  // Does not work well, but tries to remove the floor when under it...
  if (plane > .0)
    res = opU(res, vec2(plane, 1.));
  #endif
  #ifdef MONSTER
  vec4 c = 0.45*cos(vec4(0.5,3.9,1.4,1.1) + (iTime*1.5)*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);
  res = opU(res, vec2(juliaQ(pos + vec3(.0, .13, .0), c), 49.));
  #endif
  return res;
}

// Function 2135
float map(in vec3 p){
   

	// Partial anti-warping solution, based on Gaz's "Square Sin Curve" shader below:
    // https://www.shadertoy.com/view/MscGzf
    //
    // As you could imagine, tunnels (columns) get a little warped when you bend them. Countering 
    // that by taking the curvature into account helps quite a bit. Unfortunately, it slows things 
    // down, so isn't being used here, which is a shame, because I like it a lot more. Anyway, if 
    // you can spare the cycles, it gives the tunnel's "X" and "Y" (width and height) dimensions a 
    // little more consistency.
    //vec2 g = (path(p.z + 0.01) - path(p.z - 0.01))/0.02;
    //g = cos(atan(g));
    
    
    // "Windy Tunnels 101" - Use "Z" to perturb the "XY" plane. If you're not sure how it'd done,
    // I have a few tunnel examples where I explain the process.
    p.xy -= path(p.z);
    
    //p.xy *= g; // See the anti-warping explanation above.


    // A bit of tubing, using a combination of repeat objects.
    float tube = tubing(p);
    
    
    // Again a little expensive, but it's a surprisingly effective way to bump the tunnel walls.
    // This is a variation, but you can thank "aeikick" for this little snippet. :)
    //vec3 u = p;
    //p.x -= sign(u.x)*(texture(iChannel0, u.yz/8.).x - .0)*.03;//-.2;
	//p.y -= sign(u.y)*(texture(iChannel0, u.xz/8.).x - .0)*.03;  

    
    // The walls. I have another Menger example, if you'd like to look into that more closely.
    float walls = Menger(p);
    // Simpler alternatives.
    //float walls = 1. - max(abs(p.x), abs(p.y));
    //float walls = 1.25 - lengthN(p.xy, 4.0);
    
    // The curved screens. Kind of worth the effort, but not really. Fine details always overcomplicate 
    // things, not to mention, halve the frame rate. :) Anyway, it's basically repeated square box-related 
    // stuff... Add this, take that, etc. Fiddly, hacky, not all that interesting, and probably not the
    // best way to do it. Chipping away at a cylinder might raymarch better. 
    //
    p += vec3(sign(p.x)*(-.11 + (sin(p.z*3.14159*2. + 1.57/1.))*.05), 0., 0.); // Screen curve, and repositioning.
    vec3 q = abs(mod(p + vec3(.0, .5, 0.), vec3(1., 1., 2.)) - vec3(.5, .5, 1.)); // Repeat space.
    float screen = max(max(q.y, q.z) - .22, q.x-.05); // Box.
    screen = max(screen, max(abs(p.x) - .5, abs(p.y) - .22)); // Chopping off anything outside the tunnel... Kind of.
    
    // Object ID: Equivalent to: if(tube<walls)objID=2; else objID = 1.; //etc.
    //
    // By the way, if you need to identify multiple objects, you're better off doing it in a seperate pass, 
    // after the raymarching function. Having multiple "if" statements in a distance field equation can slow 
    // things down considerably. Alternatively, there's the "vec2 objA = vec2(objectADist, objAID)" option 
    // that many are fond of. It seems to be slower on my machines, but seems to work well enough.
    objID = 1. + step(tube, walls) + step(screen, tube)*step(screen, walls)*2.;
   

    // Returning the minimum of the three objects.
    return min(min(tube, walls), screen);
    
/*    
    //Two object combinations. Spoils the illusion, but helps visualize things.

    //objID = 2. + step(screen, tube);
    //return min(tube, screen); 
        
        
    //objID = 1. + step(tube, walls);
    //return min(tube, walls);        
        
    objID = 1. + step(screen, walls)*2.;
    return min(screen, walls);    
*/     
    
    
}

// Function 2136
float map(vec3 rp)
{
    vec3 pos = rp - vec3(iTime * 0.5, 0.0, 6.0); 
    vec3 pos3 = rp - vec3(0.0, -0.2, 5.7); 
    
    vec3 b = vec3(0.4, 0.0, 0.0);
 
    pos = mod(pos, b)-0.5 * b;
    pos3 = mod(pos3, b)-0.5 * b;
    
    float res = sdBox(pos, vec3(0.1, 1.7, 0.2));
	
    res = opU(res, pos.y + 0.3);
    res = opU(res, sdBox(pos3, vec3(4.0, 0.7, 1.0)));
    res = opU(res, -pos.y + 2.6);
   
    return res;
}

// Function 2137
vec4 scene(vec3 ro,vec3 rd)
{
	vec3 p = vec3(0.0);
	const float r = 1.0;
	float t;
    
    if(rd.y >= -0.1){
        vec3 col = sun_color * sun(rd) + max(0., 1. - sun(rd)) * sky_color;
        return vec4(col,1.0);
    }
    
	vec3 hit = ro + rd * intersectPlane(ro, rd, vec3(0., 1, 0.), vec3(0., 1., 0.));
	
	vec4 c = vec4(0.0);

	// ray-march into volume
	for(int i=0; i<furLayers; i++) {
		vec4 sampleCol;
		vec2 uv;
		sampleCol.a = furDensity(hit, uv);
		if (sampleCol.a > 0.0) {
			sampleCol.rgb = getColor(hit, hit - CAMERA_ORIGIN);

			// pre-multiply alpha
			sampleCol.rgb *= sampleCol.a;
			c = c + sampleCol*(1.0 - c.a);
			if (c.a > 0.95) break;
		}
			
		hit += rd*rayStep;
	}
    
    return mix(c, vec4(sky_color, 1.), min(pow(length(hit - CAMERA_ORIGIN), 2.) / visibility, 1.));
	
	return c;
}

// Function 2138
vec3 exposureToneMapping(float exposure, vec3 hdrColor) 
{    return vec3(1.0) - exp(-hdrColor * exposure);  }

// Function 2139
float mazeDist(vec3 p)
{
    vec3 cp=fract(p)-vec3(.5),acp=abs(cp);
    float r=acos(-1.)*2./8.;
    vec2 p2=(p.xz-.5)*mat2(cos(r),sin(r),sin(r),-cos(r))*length(vec2(1));
    vec2 c=floor(p2),f=fract(p.xz);
    float a=step(.5,noise(c));
    float s=.1;
    if(a>.5)
        return acp.x-s;
    return acp.z-s;
}

// Function 2140
float3 Tonemap(float3 c) { return c; }

// Function 2141
SceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )
{	
    SceneResult result;
    result.fDist = 0.0;
    result.vUVW = vec3(0.0);
    result.fObjectId = 0.0;
    
	float t = 0.1;
	const int kRaymarchMaxIter = 128;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
		result = Scene_GetDistance( vRayOrigin + vRayDir * t );		
        t += result.fDist;

        if ( abs(result.fDist) < 0.001 )
		{
			break;
		}		
        if ( t > maxDist )
        {
            result.fObjectId = -1.0;
	        t = maxDist;
            break;
        }
	}
    
    result.fDist = t;

    return result;
}

// Function 2142
float dist_torus(vec3 pos) {
	vec3 n = vec3(sin(iTime), sin(iTime), cos(iTime));
    float r = 2.0;
    vec3 on_circle = normalize(cross(n, cross(pos, n))) * r;
    return length(on_circle-pos) - .5;
}

// Function 2143
vec3 map( in vec3 pos )
{
    vec3 res = mapShadow(pos);
        
    res = mapCrapInTheAir(pos, res);

    return res;
}

// Function 2144
float map(vec3 p) {
    return opSU(scene(p), sdSphere(p - _ballPos, _ballSize), .15);
}

// Function 2145
float boxSDF(vec3 p, vec3 boxDim) {
    vec3 q = abs(p) - boxDim;
    return length(max(q, 0.0)) + min(maxComp(q), 0.0);
}

// Function 2146
vec4 map(in vec3 p)
{
    float dtp = dot(p,p);
	p = .5*p/(dtp + .2);
    p.xz = rot(p.xz, p.y*2.5);
    p.xy = rot(p.xz, p.y*2.);
    
    float dtp2 = dot(p, p);
    p = (mo.y + .6)*3.*p/(dtp2 - 5.);
    float r = clamp(fbm(p, dtp*0.1)*1.5-dtp*(.35-sin(time*0.3)*0.15), 0. ,1.);
    vec4 col = vec4(.5,1.7,.5,.96)*r;
    
    float grd = clamp((dtp+.7)*0.4,0.,1.);
    col.b += grd*.6;
    col.r -= grd*.5;    
    vec3 lv = mix(p,vec3(0.3),2.);
    grd = clamp((col.w - fbm(p+lv*.05,1.))*2., 0.01, 1.5 );
    col.rgb *= vec3(.5, 0.4, .6)*grd + vec3(4.,0.,.4);
    col.a *= clamp(dtp*2.-1.,0.,1.)*0.07+0.87;
    
    return col;
}

// Function 2147
vec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)
{
    float white = 2.;
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
    float toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);
    color *= toneMappedLuma / luma;
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 2148
vec3 sdfNormal(vec3 p, float epsilon, float d, bool detail)
{
    vec3 normal = vec3(0.0);

    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, detail) - d;
    }
    
    return normalize(normal);
}

// Function 2149
float cubeSDF(vec3 p) {
    vec3 position = vec3(-2,0,-2);
    vec3 position2 = p - position;
    
    vec3 d = abs(position2) - vec3(1.0, 1.0, 1.0);

    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);

    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 2150
float teaPotBody2D_SDF(in vec2 p) {
    float d = 1e10;
    d = min (d, sdUnevenCapsule( simX(p), vec2(0.7, -0.3), vec2(0.6, 0.35), 0.3, 0.26 ));
    d = min(d, sdBox(p, vec2(0.6, 0.5) ) - 0.1);
    d = min(d, sdSegment(p, vec2(-0.5,0.55), vec2(0.5, 0.55)) - 0.08);
    d = sminCubic(d, sdUnevenCapsule( p, vec2(-0.12, 0.72), vec2(0.12, 0.70), 0.10, 0.10 ), 0.01);
    return d; 
}

// Function 2151
vec4 map( vec3 p, vec2 ani )
{
	vec3 r = p;
	
	float h = (0.7+0.3*ani.x) * noise( 0.76*r.xz );
	r.y -= h;
	
	float den = -(r.y + 2.5);
	r +=  0.2*vec3(0.0,0.0,1.0)*ani.y;
		
	vec3 q = 2.5*r*vec3(1.0,1.0,0.15)    + vec3(1.0,1.0,1.0)*ani.y*0.15;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani.y*0.15;
    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani.y*0.15;
    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani.y*0.15;
    q.z *= 4.0;
    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani.y*0.15;
    f += 0.03125*noise( q );
	
    float es = 	1.0-clamp( (r.y+1.0)/0.26,0.0,1.0);
    f += f*(1.0-f)*0.6*sin(q.z)*es;	
	den = clamp( den + 4.4*f, 0.0, 1.0 );

    // color	
	vec3 col = mix( vec3(0.2,0.3,0.3), vec3(1.0,1.0,1.0), clamp( (r.y+2.5)/3.0,0.0,1.0) );
    col = mix( col, 3.0*vec3(1.0,1.1,1.20)*(0.2+0.8*ani.x), es );
	col *= mix( vec3(0.1,0.32,0.38), vec3(1.05,0.95,0.75), f*1.2 );
    col = col*(0.8-0.5*ani.x) + ani.x*2.0*smoothstep(0.75,0.86,sin(10.0*ani.y+2.0*r.z + r.x*10.0))*smoothstep(0.6,0.8,f)*vec3(1.0,0.8,0.5)*smoothstep( 0.7, 0.9, noise(q.yx) );
	
	return vec4( col, den );
}

// Function 2152
vec3 map(vec3 p) {
		p.y -= elevation;
		p *= rotY(rotation);
		float s = (length(p) - r) - 0.12 * sin(6. * p.x) * cos(6. * p.y)* sin(6. * p.z);
		return vec3(s * 0.5);	
	}

// Function 2153
float map(vec3 p) {
    mat4 rot = Rot4X(iTime);
    vec4 rotated = rot * vec4(p, 1.0);
    float torus = sdTorus(rotated.xyz, vec2(0.3, 0.1), vec3(0.0, 0.1, 0.0));
    float sphere = sdSphere(p, vec3(cos(iTime), 0.0, sin(iTime)), 0.5);
    float plane = sdPlane(p);
    
    
    
    return min(torus, plane);
}

// Function 2154
vec2 map(float t)
{
    return 0.85*cos( t + vec2(0.0,1.0) )*(0.6+0.4*cos(t*7.0+vec2(0.0,1.0)));
}

// Function 2155
vec3 tonemapACES( vec3 x )
{
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"	        
    const float a = 3.51;
    const float b = 0.04;
    const float c = 3.43;
    const float d = 0.69;
    const float e = 0.24;
    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );
}

// Function 2156
vec3 calcNormalmap( in vec3 pos, in float ep )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*map(pos+e.xyy*ep).x + 
					 e.yyx*map(pos+e.yyx*ep).x + 
					 e.yxy*map(pos+e.yxy*ep).x + 
					 e.xxx*map(pos+e.xxx*ep).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*ep).x;
    }
    return normalize(n);
#endif    
    
}

// Function 2157
Hit Scene(vec3 p)
{
    float dp = p.y // ground plane +Y
    , r = 1. // ball radius
    , or = .5 // other radius
    , db = dsphere(p - vec3(0,r,0), r) // non-moving ball above origin
    , dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)) // large box for testing collision
    , dc = dseg(p, vec3(-10,or,0), vec3(-10,1.+or,0)) - or // capsule
    ;
    dc = min(dc, dseg(p, vec3(10,or+.25,5), vec3(10,or+.25,-5)) - or);
    Hit h; // = Hit(3.4e38, mSky);
    h = Hit(dp, mGray);
    if (h.d > db) h = Hit(db, mRed);
    if (h.d > dx) h = Hit(dx, mGreen);
    if (h.d > dc) h = Hit(dc, mBlue);
    return h;
}

// Function 2158
float terrainDist(vec3 p, vec2 rayDir)
{
    return p.z - getTerrainNoise(p.xy, NOISE_LAYERS);
}

// Function 2159
float Map(  vec3 p)
{
  float  d=100000.0;
  checkPos = p;
  winDist=dekoDist=steelDist=100000.0;

  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(4.0, 12.45));
  if(d<1.0)
  {
  
  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));
  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));
  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));
  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));
  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));

  // lamp
  d=min(d, sdSphere(p-vec3(0., 4.9, 0), 0.3));
  d=min(d, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));

  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, 5.8, 0), vec2(inRad, .15)));                  
  dekoDist =min(dekoDist, sdTorus(p-vec3(0.0, 4., 0), vec2(inRad, .11)));
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -0.6, 0), vec2(radius+0.15, .15)));
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -1.65, 0), vec2(radius+0.08, .15))); 
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.7, 0), radius+0.14, .30));
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.85, 0), radius+0.18, .18));
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.1, 0), radius+0.22, .18));
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -9., 0), vec2(radius+0.6, .25))); 
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -11.30, 0.), vec2(2.42, 0.25)));     

  // lower border
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.35, 0), vec2(radius+0.25, .15)));

  // deko and windows steel top
  checkPos.xz = pModPolar(p.xz, 12.0);
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42)));
  steelDist=min(steelDist, sdCapsule(checkPos-vec3(inRad-0.06, 4.2, 0), vec3(0, 0., 0), vec3(0, 1.45, 0), 0.02));
  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));
  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);

  // top
  dekoDist=min(dekoDist, sdCappedCylinder(p-vec3(0.0, 6.2, 0), vec2(inRad, .45)));
  dekoDist=min(dekoDist, sdSphere(p-vec3(0., 6.5, 0), 1.10));
  steelDist=min(steelDist, sdCappedCylinder(p-vec3(0.0, 7.5, 0), vec2(0.5, .45)));
  steelDist=min(steelDist, sdSphere(p-vec3(0., 7.9, 0), 0.45));
  steelDist=min(steelDist, sdSphere(p-vec3(0., 8.4, 0), 0.10));   
     
  vec3 pp = p-vec3(0.0, 4.4, 0);
  pModInterval1(pp.y,0.4,0.0,2.);          
  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));
      
  pp = p-vec3(0.0, 3.55, 0);
  pModInterval1(pp.y,0.15,0.0,3.);          
  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, .025)));

  // upper decoration
  checkPos.xz = pModPolar(p.xz, 6.0);
  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));

  // windows cutouts   
  checkPos.xz = pModPolar(p.xz, 6.0);   
  d=max(d, -sdBox(checkPos-vec3(2.20, 1.17, 0.), vec3(3.25, 0.7, 0.4))); 
  checkPos.xz = pModPolar(p.xz, 5.0); 
  pp = checkPos-vec3(2.50, -6.83, 0.);
  pModInterval1(pp.y,3.5,0.0,1.);         
  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  

  // upper windows   
  checkPos.xz = pModPolar(p.xz, 6.0);   
  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); 

  // middle windows (upper deco)
  checkPos.xz = pModPolar(p.xz, 5.0); 
  dekoDist=min(dekoDist, sdBox(checkPos-vec3(2.10, -2.44, 0.0), vec3(0.3, 0.4, 0.12)));   
  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(checkPos-vec3(2.40, -2.04, 0.0), 0.21, 0.63), .03); 
  dekoDist = max(dekoDist, -fCylinder(checkPos-vec3(2.50, -2.62, 0.0), 0.51, 0.63));
  
  // middle and lower windows      
   pp = checkPos-vec3(2.78, -8.0, 0.);
  float m=pModInterval1(pp.y, 3.5,0.,1.);
  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.),vec3(0.28,0.0, 0.),m)));   

  // make tower hollow
  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));

  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -15.2, 0), vec2(2.5, .75))); 
  dekoDist=min(dekoDist, sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.7, 1.4, 0.4)));    
  dekoDist=min(dekoDist, fCylinder(p-vec3(-0., -13., 2.5), 0.7, 0.4)); 

  // create door opening    
  float doorOpening = min(sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.6, 1.3, 4.6)), fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));

  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));

  checkPos.xz = pModPolar(p.xz, 8.0);
  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    
  checkPos.xz = pModPolar(p.xz, 16.0);
  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    

  d=max(d, -sdBox(p-vec3(-0., -14.3, 2.7), vec3(0.6, 1.3, 4.6)));    
  d=max(d, -fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));    

  // door   
  d=min(d, sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4))); 
    
  // door cutout     
  pp = p-vec3(-0.28, -13.3, 2.4);
  pModInterval1(pp.x, 0.56,0.,1.);     
  d=max(d, -sdBox(pp, vec3(0.25, 0.25, 0.08)));   
  pp = p-vec3(-0.28, -14.1, 2.4);
  pModInterval1(pp.x, 0.56,0.,1.);     
  d=max(d, -sdBox(pp, vec3(0.25, 0.4, 0.08))); 

  dekoDist=max(dekoDist, -sdBox(p-vec3(-0., -16.2, 0), vec3(6.6, 1.3, 8.6)));  
  }
    
  
  // railing (platform) 
  checkPos.xz = pModPolar(p.xz, 32.0);   
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   
  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));
  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));
  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));
  checkPos.xz = pModPolar(p.xz, 7.0); 
  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  
  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));   
  steelDist=max(steelDist, -sdBox(p-vec3(0.0, -16.05, 0), vec3(16.6, 1.2, 16.6)));  
    
  return  min(d, min(steelDist, min(dekoDist, winDist)));
}

// Function 2160
float map(vec3 p) {
    
    // Time factor.
    vec3 t = vec3(1, .5, .25)*iTime;

    
    // Two base layers of low fregency noise to shape the clouds. It's been contracted in the Y
    // direction, since a lot clouds seem to look that way.
    float mainLayer = n3D(p*vec3(.4, 1, .4))*.66 + n3D(p*vec3(.4, 1, .4)*2.*.8)*.34 - .0;    
    
    // Three layers of higher frequency noise to add detail.
    float detailLayer = n3D(p*3. + t)*.57 +  n3D(p*6.015 + t*2.)*.28 +  n3D(p*12.01 + t*4.)*.15 - .0;
    // Two layers, if you're computer can't handle three.
	//float detailLayer = n3D(p*3. + t)*.8 +  n3D(p*12. + t*4.)*.2;

    // Higher weighting is given to the base layers than the detailed ones.
    float clouds = mainLayer*.84 + detailLayer*.16;
    
    
    #if (ARRANGEMENT != 3)
    // Mapping the hole or plane around the path.
    p.xy -= path(p.z);
    #endif
    
    
    // Between cloud layers.
    #if (ARRANGEMENT == 0) // Layered.
    //return smax(tn, -abs(p.y) + 1.1 + (clouds - .5), .5) + (clouds - .5);
    return smax(clouds, -length(p.xy*vec2(1./32., 1.)) + 1.1 + (clouds - .5), .5) + (clouds - .5);
    #elif (ARRANGEMENT == 1) // Path - Tunnel in disguise.
    // Mapping the hole around the path.
    return smax((clouds - .25)*2., -smax(abs(p.x) - .5, abs(p.y) - .5, 1.), 2.);
    #elif (ARRANGEMENT == 2) // Path - Tunnel in disguise.
    // Between layers, but with fluffier clouds.
    return smax(clouds - .075, -length(p.xy*vec2(1./32., 1.)) + 1.1 + (clouds - .5), .5) + (clouds - .5)*.35;
    #else // The clouds only.
    return (clouds - .25)*2.; 
    //return tn; // Fluffier, but blurrier.
    #endif
   
   


}

// Function 2161
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(9./iResolution.y, 1); 
    
    float f = bumpFunc(p, n); // Hit point function sample.
    
    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.
    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.
    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.
    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.
    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*3.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 7.*f);
    edge = smoothstep(1., 2., edge/e.x*3.);
    
    
    // We may as well use the six measurements to obtain a rough curvature value while we're at it.
    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 2162
float sceneDistanceFunction(vec3 p, inout vec4 orbitTrap)
{
    return map(p, orbitTrap);
}

// Function 2163
void tonemap(inout vec3 color)
{
    #if TONEMAP_TYPE == LINEAR_TONEMAP
    color *= vec3(TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP
    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == REINHARD_TONEMAP
    color *= TONEMAP_EXPOSURE;
    color = color / (1.0 + color);
    #endif
    #if TONEMAP_TYPE == REINHARD2_TONEMAP
    color *= TONEMAP_EXPOSURE;
    color = (color * (1.0 + color / (LDR_WHITE * LDR_WHITE))) / (1.0 + color);
    #endif
    #if TONEMAP_TYPE == FILMIC_HEJL2015
    color *= TONEMAP_EXPOSURE;
    color = linearTo_sRGB(TonemapFilmic_Hejl2015(TONEMAP_EXPOSURE_BIAS * color));
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2    
    color *= TONEMAP_EXPOSURE;
    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);
    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));
    color = tonemapedColor * whiteScale;
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP_ACES
    color *= TONEMAP_EXPOSURE;
    vec3 tonemapedColor = TonemapACESFilm(TONEMAP_EXPOSURE_BIAS * color);
    vec3 whiteScale = 1.0 / TonemapACESFilm(vec3(W));
    color = tonemapedColor * whiteScale;
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP_ALU
    color *= TONEMAP_EXPOSURE;
    color = TonemapFilmicALU(color);
    #endif
}

// Function 2164
float map(float value, float Imin, float Imax, float Omin, float Omax) 
{  
  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);
}

// Function 2165
float distSphere(vec3 p, vec3 pos, float radius) {

    return length(pos - p) - radius;
    
}

// Function 2166
vec3 lightmap_to_world(vec2 fragCoord, int plane_index)
{
    fragCoord += get_lightmap_offset(plane_index);
    vec4 plane = get_plane(plane_index);
    return uv_unmap(fragCoord * LIGHTMAP_SCALE, plane) + plane.xyz * LIGHTMAP_HEIGHT_OFFSET;
}

// Function 2167
bool mapX(vec3 p, bool doOpenTopFully)
{
   //return mapX0(vec3(p.x, p.y, -p.z+7.0));
   return mapX0(vec3(p.x, p.y,  p.z+8.0), true,  doOpenTopFully) || 
          mapX0(vec3(p.x, p.y, -p.z+7.0), false, doOpenTopFully);
}

// Function 2168
float sdistLine(vec2 a, vec2 b, vec2 pos)
{
    return dot(pos - a, normalize(ortho(b - a)));
}

// Function 2169
float sphere_sdf(in highp vec3 point) {
    vec3 sphere_center =
        vec3(0.9 * sin(0.6 * iTime),
             0.9 * cos(1.1 * iTime),
             -1.0);
	return length(point - sphere_center) - sphere_rad;
}

// Function 2170
vec4 scene(vec4 p) {
    //floor
    vec4 s = vec4(0., 0., 0., max(p.y,0.));
    
    //sphere
    float d = max(0., length(p.xyz-vec3(0,2,0))-1.);
    vec3 sl = vec3(max(0., sin(iTime)));//flashing sphere emissive
    join(d,sl);
    
    d = max(0., length(p.xyz-vec3(sin(iTime*.43),.5,cos(iTime*.4))*3.)-1.);
    sl = vec3(max(0., sin(iTime*1.23+3.1)));
    join(d,sl);
    
    return s;
}

// Function 2171
float dist_tolus(vec3 p,vec2 r)
{   
    vec2 d= vec2(length(p.xy) - r.x, p.z);
    return length(d) - r.y;
}

// Function 2172
vec4 mapLotsOfSpheres( vec3 pos)
{
	vec3 col = vec3(.3, .8, .2 );
	const float radius=6.0;
	float dist = length( mod( pos+15., 30.)-15.) -radius;
	return vec4( col, dist);
}

// Function 2173
vec3 sceneNormal(in vec3 pos, in float t )
{
    float eps = 0.0001;
    vec3 n;
    float m;
    float d = scene(pos, m, t);
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z), m, t ) - d;
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z), m, t ) - d;
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps), m, t ) - d;
    return normalize(n);
}

// Function 2174
float map_plate(vec3 pos)
{
    #ifdef show_plate
    pos = rotateVec2(pos);
    pos.y+= 1.07 + plateThickness;

    float a = atan(pos.x, pos.z)/(2.*pi);
    float c = pow(abs(smoothstep(-0.02, 1.02, fract(a*6.)) - 0.5), 8.);
    pos.xz/= 1.1 - 23.*c*smoothstep(0.45, 0.58, length(pos.xz)/plateSize) - 0.06*smoothstep(1.3, 2.5, 1. + sin((a + 0.125)*12.*pi));
    float l = length(pos.xz)/plateSize;
    pos.y-= 0.13*smoothstep(0.58, 0.75, l);
    pos.y-= 0.05*smoothstep(0.7, 1.1, l);
    pos.y-= 0.07*smoothstep(-1., 0.6, cos(l*3.));
    pos.y/= (1. + 0.45*smoothstep(0.96, 1.02, l));
    float df = sdCylinder(pos, vec2(plateSize*1.1, plateThickness*1.03));
    df = SoftMaximum(df, sdCylinder(pos, vec2(plateSize, plateThickness*2.)), 55.);
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif   
    return df;
    #else
    return 10.;
    #endif
}

// Function 2175
float distanceSqr(vec3 a, vec3 b) {
	vec3 k = a - b;
	return dot(k, k);
}

// Function 2176
vec4 map(vec3 pos)
{
    warpColor = 0;
    
    return mapRaw(pos);
}

// Function 2177
void BarrelDistortion(inout vec3 r,float d){//rey,degree
;r.z/=d;
;r.z=r.z*r.z-dot(r.xy,r.xy)//fisheye-lens
;r.z=d*sqrt(r.z);}

// Function 2178
float getdist(vec3 p){return min(boxSDF(qrot(vec3(0,1,0),p,45. * iTime),vec3(1)),p.y+2.);}

// Function 2179
float distToLine(vec2 A, vec2 B, vec2 p){
    
    vec2 PA = p - A;
    vec2 BA = B - A;
    float d = dot(PA,BA);
    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt
    vec2 normal = PA - BA*t;
    return length(normal);
}

// Function 2180
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 vn, col;
  float dstObj, sh;
  bool isBg;
  cylLen = sphGap * 0.5 * (float (nSphObj / 5) - 1.) - 0.1;
  cylRad = sphGap * sphOff + 0.35;
  isBg = false;
  dstObj = ObjHit (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = qnHit;
  } else {
    ro += ((0.5 - ro.y) / rd.y) * rd;
    vn = vec3 (0., 1., 0.);
    isBg = true;
  }
  sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 40.);
  if (! isBg) col = ObjCol (rd, vn, sh);
  else col = BgCol (ro, vn, sh);
  if (isBg && rd.y < 0.) {
    rd = reflect (rd, vn);
    ro += 0.01 * rd;
    dstObj = ObjHit (ro, rd);
    if (dstObj < dstFar) {
      ro += dstObj * rd;
      vn = qnHit;
      col = mix (col, ObjCol (rd, vn, 1.), 0.3);
    }
  }
  return clamp (col, 0., 1.);
}

// Function 2181
float map0(vec3 U) {
    float d = length(U), r = ( 1.+ 4.*float((N+1)/2) ) *1.26;
    if (d > 2.*r) return d-r;                 // bounding sphere
    mat2  R = mat2( sin(.5*iTime+vec4(0,33,11,0)) );

    for (int k=0; k< N*N*N; k++) {            // complex group. Stub: grid of groups
        vec3 C = vec3( k%N -N/2, k/N%N -N/2, k/(N*N) -N/2) *4.;
        C -= U;
        C.xz *= R, C.yz *= R;                 // rotation
        d = min(d, map1(C));
    } 
    return d;
}

// Function 2182
float distanceToMandelbrot( in vec2 c )
{
    #if 1
    {
        float c2 = dot(c, c);
        // skip computation inside M1 - http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm
        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;
        // skip computation inside M2 - http://iquilezles.org/www/articles/mset_2bulb/mset2bulb.htm
        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;
    }
    #endif

    // iterate
    float di =  1.0;
    vec2 z  = vec2(0.0);
    float m2 = 0.0;
    vec2 dz = vec2(0.0);
    for( int i=0; i<300; i++ )
    {
        if( m2>1024.0 ) { di=0.0; break; }

		// Z' -> 2ZZ' + 1
        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);
			
        // Z -> Z + c			
        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;
			
        m2 = dot(z,z);
    }

    // distance	
	// d(c) = |Z|log|Z|/|Z'|
	float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));
    if( di>0.5 ) d=0.0;
	
    return d;
}

// Function 2183
vec2 map( in vec3 pos) {
	vec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);
	//vec2 bush =  foliage(pos);
    //res=res.x<bush.x?res:bush;
    
 	return res;
}

// Function 2184
float distsq(vec3 p, vec3 q) {
    vec3 pq = q - p;
    return dot(pq, pq);
}

// Function 2185
endif
map( in vec3 pos )
{
    #if 0
    float r = 1.1;
    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );
    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );
    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;
    pos.x = mirror( pos.x / r ) * r;
    pos.y = mirror( pos.y / r ) * r;
    #else
    vec3 color = ORANGE_RGB;
    #endif
    
    MPt res;
    #if INDEXED_MATERIALS
    res.x = 1e38;
    #else
    res.distance = 1e38;
    #endif
    
    #if !INDEXED_MATERIALS
    Material plastic_m;
    plastic_m.color = vec3(1.0);
    plastic_m.diffuse_reflection  = 1.0;
    plastic_m.specular_reflection = 1.0;
    plastic_m.ambient_reflection  = 1.0;
    plastic_m.shininess           = 15.0;

    Material floor_m;
    plastic_m.color = vec3(1.0);
    floor_m.diffuse_reflection  = 1.0;
    floor_m.specular_reflection = 0.2;
    floor_m.ambient_reflection  = 0.5;
    floor_m.shininess           = 1.0;

    Material orange_m = plastic_m;
    orange_m.color = ORANGE_RGB;
    
    Material red_m = plastic_m;
    red_m.color = vec3(1.0,0.0,0.0);
    Material green_m = plastic_m;
    green_m.color = vec3(0.0,1.0,0.0);
    Material blue_m = plastic_m;
    blue_m.color = vec3(0.0,0.0,1.0);
    #endif

    float sr = 0.5;
    float sd = 0.5;
    #if 0
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),
                          orange_mat ),
	      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),
                          orange_mat ) );
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),
               orange_mat ),
          res );
    #endif
    
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_RED
                        #else
                        red_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_GREEN
                        #else
                        green_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_BLUE
                        #else
                        blue_m
                        #endif
                       ),res );
    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );
    res = union_op( MPt( plane_sd( pos ),
                        #if INDEXED_MATERIALS
                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m
                        #else
                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )
                        #endif
                       ),
                    res );


    res =
       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )
                        #endif
                       ),
                    res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,iTime), at_pos(vec3(2.0,6.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,iTime*TAU/7.0), at_pos(vec3(2.0,10.0,2.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,iTime*TAU/7.0), at_pos(vec3(2.0,12.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),
                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        vec3(1.0,1.0,-1.0) *
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op(
          intersect_op(
             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
             intersect_op(
                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                ),
                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                )
             )
          ),
          res );
    
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(iTime * TAU / 4.0) ), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(iTime*TAU/4.0,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
	return res;
}

// Function 2186
vec3 rectDistance(vec3 pos, vec3 center, vec3 normal, float size) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    if (abs(dot(up, normal)) > 0.9) {
        up = vec3(0.0, 0.0, 1.0);
    }
    vec3 left = normalize(cross(up, normal));
    up = normalize(cross(normal, left));
    
    vec3 localPos = pos - center;
    
	float u = clamp(dot(localPos, up), -size, size);
    float v = clamp(dot(localPos, left), -size, size);
    
    vec3 clampPos = center + up * u + left * v;
    
    return vec3(length(clampPos - pos), v/size, u/size);
}

// Function 2187
float SDF( vec3 pos, bool includeDynamic )
{
    const float maxgrad = 1.; // steepest gradient the noise can output (not sure this is still true)

    // flatten a green around the hole
    float noise = GetNoise(pos);
    noise = mix( noise, GetNoise(holePos), pow( smoothstep(8.,2.,length(pos-holePos) ), 2. ) );
    
    float f = (pos.y + noise)/sqrt(1.+maxgrad*maxgrad); // normalize so 3D gradient is <= 1.0 at all points
    
    if ( includeDynamic )
    {
        f = min(f,BallSDF(pos));
    }

    // add hole to the SDF:
    f = max(f,HoleSDF(pos));
    
    return f;
}

// Function 2188
float mapD( in vec3 pos, in float time )
{
    float matID; vec3 kk2;
    float d = map(pos,time,matID,kk2).x;
    
    if( matID<1.5 ) // water
    {
        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);
        g = g*g;
    	float f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);
        d -= g*12.0*(0.5+0.5*f*g*2.0);
    }
    else if( matID<2.5 ) // bridge
    {
    	d -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));
    }
    else if( matID<4.5 ) // ground
    {
    	float dis = fbm1(iChannel0,0.1*pos);
    	d -= 3.0*dis;
    }
    
    return d;
}

// Function 2189
float distanceEstimation(vec3 pos){
    int placeHolder;
    return distanceEstimation(pos, placeHolder);
}

// Function 2190
float map( vec3 p )
{
    vec3 w = p;
    vec3 q = p;

    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;
    
    float d = (p.y-terrainH(p.xz));
    d=d*min(max(abs(d),0.001)*1000.0,0.125);
    //d=d*d*10.0;

    
   return d;
}

// Function 2191
float planeSDF(vec3 p, vec3 n, float h) { return dot(p,n) - h;  }

// Function 2192
float scene(vec3 p)
{	
	return .1-length(p)*.05+fbm(p*.3);
}

// Function 2193
vec2 map(vec3 pos, bool btext)
{
    vec2 res = opU(vec2(map_floor (pos, btext)                                                            , FLOOR_OBJ),
                   vec2(map_tablet(pos, tabPos, vec3(tabWidth, tabHeight, 0.1), 5., tabletRounding, btext), TABLET_OBJ));
    #ifdef spheres
    res = opU(res, vec2(map_spheres(pos, vec3(.0, 0.45, 2.9), 1.7, 0.45)                                        , SPHERES_OBJ));
    #endif
    return res;
}

// Function 2194
vec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)
{
    vec3 res = cur;
    
    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));
    pos.xz = mod(pos.xz+2.0,4.0)-2.0;
    float dm = 1e10;
    for( int i=0; i<4; i++ )
    {
        vec3 o = vec3(0.0,3.2,0.0);
        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));
        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));
        float d = length2(pos - o);
        dm = min(d,dm);
    }
    dm = sqrt(dm)-0.02;
    
    if( dm<res.x )
        res = vec3( dm,MAT_CITA,0);
    
    return res;
}

// Function 2195
vec3 mipMapBloom(vec3 Screen, in sampler2D Tex, in vec2 Coord, in float MipBias)
{
	vec2 TexelSize = MipBias/iChannelResolution[0].xy;
    
    vec3  Color = texture(Tex, Coord, MipBias).rgb;
    Color += texture(Tex, Coord + vec2(TexelSize.x,0.0), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,0.0), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(0.0,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(0.0,-TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(TexelSize.x,-TexelSize.y), MipBias).rgb;    	
    Color += texture(Tex, Coord + vec2(-TexelSize.x,-TexelSize.y), MipBias).rgb;    

    Color = Color/9.0;
    vec3 Highlight = clamp(Color-Threshold,0.0,1.0)*1.0/(1.0-Threshold);
    return saturate(1.0-(1.0-Screen)*(1.0-Highlight*Intensity));
}

// Function 2196
vec4 map_co2(vec2 fragCoord) {
    vec2 uv = fragCoord / iResolution.xy;
    float ppmv = 377. + 3. * texture(iChannel2, uv).z;
    vec4 fragColor = vec4(0);
    fragColor = mix(fragColor, vec4(0.10, 0.11, 0.22, 1), smoothstep(377., 379., ppmv));
    fragColor = mix(fragColor, vec4(0.10, 0.40, 0.36, 1), smoothstep(379., 381., ppmv));
    fragColor = mix(fragColor, vec4(0.58, 0.48, 0.08, 1), smoothstep(381., 383., ppmv));
    fragColor = mix(fragColor, vec4(0.43, 0.14, 0.09, 1), smoothstep(383., 385., ppmv));
    fragColor = mix(fragColor, vec4(0.25, 0.09, 0.21, 1), smoothstep(385., 387., ppmv));
    return fragColor;
}

// Function 2197
vec4 MAP_DETAILED_Scene(vec3 p) { // Detailed Main Secene
	float fulldist = 9999.0;
    float dist = fulldist;
    vec3 color = DEFAULT_MESH_COLOR;
    
    // Red Sphere
    {
        vec3 sphereColor = vec3(1.0, 0.0, 0.0);
        float sphereRadius = 1.0;
        vec3 spherePosition = vec3(0.0, 1.0, 0.0);
        float sphereDist = length(p-spherePosition)-sphereRadius;
        if (sphereDist < dist) {
            color = sphereColor;
            dist = sphereDist;
        }
    }
    
    // Ocean
    {
        vec3 oceanColor = vec3(1.0);
        float oceanHeight = 0.0;
        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 5, 1.0);
        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;
        if (oceanDist < dist) {
            color = oceanColor;
            dist = oceanDist;
        }
    }
    
    return vec4(color, dist);
}

// Function 2198
float map(vec3 p)
{
    p*= 1.5;
	p = objmov(p);
    float d = length(p)-1.;
    d -= trids(p*1.2)*.7;
    return d/1.5;
}

// Function 2199
vec4 terrainMapD( in vec2 p )
{
	const float sca = 0.0010;
    const float amp = 300.0;
    p *= sca;
    vec3 e = fbmd_9( p + vec2(1.0,-2.0) );
    vec2 c = smoothstepd( -0.08, -0.01, e.x );
	e.x = e.x + 0.15*c.x;
	e.yz = e.yz + 0.15*c.y*e.yz;    
    e.x *= amp;
    e.yz *= amp*sca;
    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );
}

// Function 2200
vec4 ReadMapData( sampler2D mapSampler, ivec2 address )
{
    return LoadVec4( mapSampler, address );
}

// Function 2201
vec3 ndist( vec3 Z, float k, vec3 dZ )
{
    float b = dot( Z, dZ );
    return normalize( Z * square( 1. - k + k * b ) + k * ( dZ - Z * b ) );
}

// Function 2202
float map002(vec2 p)
{
	float h;
    h = circle(p, vec2(0., -asp*1.7), asp*1.5);
    h = min(h, box(p, vec2(0., 0.15), vec2(asp*0.3,0.2)));
    return h;
}

// Function 2203
vec2 map1sd(vec2 z)
{
#if 1
  float phi,r;
  float a = z.x;
  float b = z.y;
  
  if (a*a > b*b) {
    r = a;
    phi = (PI/4.)*(b/a);
  } else {
    r = b;
    phi = (PI/2.0) - (PI/4.0)*(a/(b+epsilon));
  }
  return vec2( r*cos(phi), r*sin(phi) );
#else
  float u,v,m,t;
    
  if (abs(z.x) > abs(z.y)) {
    m = z.x;
	t = (PI/4.0)*z.y/z.x;
    v = sin(t);
    u = sqrt(1.0-v*v);     // or cos(t)
  }
  else {
    m = z.y;
    t = (PI/4.0)*z.y*z.x/(z.x*z.x+epsilon);
	//t = (PI/4.0)*z.x/z.y;
    //t = z.y != 0.0 ? t : 0.0;
    u = sin(t);
    v = sqrt(1.0-u*u);    // or cos(t)
  }
    
  return vec2(m*u, m*v);

#endif
}

// Function 2204
Hit planeSdf(vec3 p) {
    const float PLANE_Y =/ 0.0;
    Hit hit;
    hit.dist = p.y - PLANE_Y;
    hit.color = vec3(0.55);
    return hit;
}

// Function 2205
vec2 map(vec3 p) {
    float D = 0.0, T = 0.0;
    // floor & walls
    float fl = mapFloor(p);
    float w = mapWalls(p);
    #ifdef NEWWALLS
    D = min(fl, -w);
    #else
    D = polsmin(fl, w, 1.0);
    #endif
    T = fl==D?0.0:1.0;
    // the hanger one
    float d3 = mapThing(p);
    D = polsmin(D, d3, 0.2);
    T = d3==D?2.0:T;
    // webs
    float d4 = mapWeb(p, 0.785398, 3.141592);
    D = polsmin(D, d4, 0.2);
    T = d4==D?2.0:T;
    d4 = mapWeb(p - vec3(0.0, 4.0, 0.0), -0.785398, -0.987993/*-3.141592*/);
    D = polsmin(D, d4, 0.2);
    T = d4==D?2.0:T;
    // the egg
    float d5 = mapEgg(p-EGGPOS);
    D = polsmin(D, d5, 1.1);
    T = d5==D?3.0:T;
    return vec2(D, T);
}

// Function 2206
vec4 cloudsMap( in vec3 pos )
{
    vec4 n = fbmd_8(pos*0.003*vec3(0.6,1.0,0.6)-vec3(0.1,1.9,2.8));
    vec2 h  =  smoothstepd( -60.0, 10.0, pos.y ) -  smoothstepd( 10.0, 500.0, pos.y );
    h.x = 2.0*n.x + h.x - 1.3;
    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0)  );
}

// Function 2207
float sceneSDF(in vec3 iPoint) {
    
    float d = min(allMushroomsSDF(iPoint), allOrbsSDF(iPoint));
    d = min(d, groundSDF(iPoint));
    return d;
    
}

// Function 2208
float sdf_sh(int l, int m, float scale, vec3 sh_position, vec3 ray_position, vec3 ro) {
  vec3 p = (ray_position - sh_position);
  float pr = length(p);
  float theta = atan(sqrt(p.x*p.x + p.y*p.y)/p.z);
  float phi = PI+atan(p.x, p.y);
  
  float fr = scale*abs(SH(l, m, theta, phi));
   
  vec3 delta = ray_position - fr*normalize(p);
  if(dot(delta, p) < 0.0) {
      return -length(delta);
  }
  else {
      return length(delta);
  }
}

// Function 2209
float PrCapsDf (vec3 p, float r, float h)
{
  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;
}

// Function 2210
float scene(vec2 p) {
    float d1 = scircle(p, c_pos, 0.04);
    float d2 = box(p, vec2(0.2, 0.2), vec2(0.2, 0.04));
    float d3 = ucircle(p, s_pos, 0.5);
    
    return min(d1,min(d2, d3));
}

// Function 2211
vec2 map(vec3 rp) {
    
    vec2 msd = vec2(FAR, 0);
    for (int i = 0; i < 10; i++) {  
        //this is so sensitive
       float c = 0.3;// + sin(T * 0.2) * 0.1; //clamp(0.3 + sin(T * 0.4) * 0.06, 0.24, 0.32); //0.1 - 0.3
       float q = 1.0 + sin(T) * 0.1;  //1.6 + sin((T - PI)  * 0.1) * 0.4; // 3.6 - 1.0
       rp = abs(rp) / dot(rp, rp) - c;
       rp.xy *= rot(float(i));
       msd = near(msd, vec2(sdBox(rp, q - rp, vec3(1.0)), i)); 
    }
    
    return msd;
}

// Function 2212
float remap(float value, float inputMin, float inputMax, float outputMin, float outputMax)
{
    return (value - inputMin) * ((outputMax - outputMin) / (inputMax - inputMin)) + outputMin;
}

// Function 2213
vec2 map( vec3 p, float time, int i, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4 ) {
#endif
    time *= .2;
    vec2 t = trig( time );
    float d = .11 + abs( t.x * .22 );
    
    d *= .8;
    
    vec3 goal = d  * t.xyx;
    goal.z = d * sin( time + 1. );
    
    #ifdef DISARMING
        return jointed( p, goal, p0, p1, p2 );
    #else
        return jointed( p, goal, p0, p1, p2, p3, p4 );
    #endif
}

// Function 2214
float man_dist(in vec2 center_a, in vec2 center_b, in vec2 p, out vec2 gradient){
    //remember, balls in the L1 norm are octohedrons

    vec2 midp = avg(center_a, center_b);
    vec2 min_c = min(center_a, center_b);
    vec2 max_c = max(center_a, center_b);
    
    //find the largest bounding box axis between the two centers
    vec2 cm_dir = (min_c - max_c) * (min_c - max_c);
    float max_axis = vmax(cm_dir);     
    int max_comp = max_axis == cm_dir.x ? 0 : 1;
    
      
    //define the diagonal source pos
    vec2 edge = center_a;
    edge[max_comp] = center_b[max_comp];
    edge = normalize(edge - center_a);
    float cc = dot(midp - center_a, edge);
    vec2 new_p =  center_a + edge * cc;
    float l = length(new_p - midp);
    
    vec2 diag_p_0 = new_p + edge * l;
    
    //define the diagonal destination pos
    edge = center_b;
    edge[max_comp] = center_a[max_comp];

    edge = normalize(edge - center_b);
    cc = dot(midp - center_b, edge);
    new_p =  center_b + edge * cc;
    l = length(new_p - midp);
    
    vec2 diag_p_1 = new_p + edge * l;
    
    
    //define the direction of the two axis aligned planes
    int min_comp = 1 - max_comp;
    
    vec2 dir_a = min_comp == 0 ? vec2(1., 0.) : vec2(0., 1.);
    vec2 dir_b = dir_a;

    float a_sign =  diag_p_0[min_comp] == max_c[min_comp] ? 1. : -1.;
    dir_a *= a_sign;
    dir_b *= a_sign * -1.;
    
    //get the projection distance to the axis aligned planes
    float a_dist = dot(p - diag_p_0, dir_a);
    float b_dist = dot(p - diag_p_1, dir_b);
    
    //get the distance to the diagonal
    vec2 diag = (diag_p_1 - diag_p_0);
    
    float diag_l =  dot2(diag);
    float diag_dist = dot(p - diag_p_0, diag) / diag_l;
    
    //project our current pos onto the diagonal
    //make sure you clamp it to just that edge
    vec2 proj_diag = diag_p_0 + diag * clamp(diag_dist, 0., 1.);
    vec2 proj_a = diag_p_0 + dir_a *  max(a_dist, 0.);
    vec2 proj_b = diag_p_1 + dir_b * max(b_dist, 0.);
    
    //find the distance to the projected point on the planes
    float a_p_dist = length(proj_a - p );
    float b_p_dist = length(proj_b - p );
    
    float p_diag_dist = length(proj_diag - p) ;
    
    float min_dist = min(p_diag_dist, min(a_p_dist, b_p_dist));
    
    //this branching is not needed if you dont want shading normals
    if(min_dist == p_diag_dist){
        gradient = proj_diag - p;
    }else if(min_dist == a_p_dist){
        gradient = proj_a - p;
    }else{
        gradient = proj_b - p;
    }
    

    //find the minimum of all the distances
    return min_dist;
    
}

// Function 2215
vec4 texMapSmoothCh(samplerCube tx, vec3 p){

    // Voxel corner helper vector.
	const vec3 e = vec3(0, 1, 1./4.);

    // Technically, this will center things, but it's relative, and not necessary here.
    //p -= .5/dimsVox.x;
    
    p *= dimsVox;
    vec3 ip = floor(p);
    p -= ip;

    
    int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  //int(mod(ip.x, 4.))
    ip.x /= 4.;

    vec4 c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch), txChSm(tx, ip + e.zxx, chNxt), p.x),
                     mix(txChSm(tx, ip + e.xyx, ch), txChSm(tx, ip + e.zyx, chNxt), p.x), p.y),
                 mix(mix(txChSm(tx, ip + e.xxy, ch), txChSm(tx, ip + e.zxy, chNxt), p.x),
                     mix(txChSm(tx, ip + e.xyy, ch), txChSm(tx, ip + e.zyy, chNxt), p.x), p.y), p.z);

 
 	/*   
    // For fun, I tried a straight up average. It didn't work. :)
    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +
             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +
             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +
             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;
 	*/
    
    return c;

}

// Function 2216
float mapstage4 (in vec3 p)
{
   float d1 = length(p) - 1.0;
   //d2 defines a distance from a plane
   float d2 = p.y + 1.0;
   //return the closest 
   return min (d1,d2);
}

// Function 2217
vec2 dstScene(vec3 p) {
    vec2 dst = vec2(MAX_DIST,-1.);
    // moon
    vec3 moonNorm  = normalize(p - moonPos);
    float moonSurf = getMoonHeight(moonNorm);
    dst = dstMin(dst, length(p-moonPos)-moonSize-moonSurf, 0.);
    // earth
    dst = dstMin(dst, length(p-vec3(0.,500.,-1500.))-300., 1.);
    // end scene
    return dst;
}

// Function 2218
vec2 QueryDistanceField( in vec3 pos, in int IntersectFlags )
{    
    // Hacky way of trying to speed up the marching when the ray is far past the 
    // close-up geometry
    float approxCameraDist = length(pos.xz);
    bool farFromCamera = approxCameraDist > 500.0;
    
    vec2 res = vec2(99999.0f, 0);
    float noise = fbm_4(pos / 5.0);
    if((IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)
    {
        // Spamming a bunch of instanced trees with enough interval difference to fake a random
        // assortment of trees in the background
        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 30, -400.0), vec2(0.8, 0.2), 40.0 , vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));
        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 50, -400.0), vec2(0.8, 0.2), 60.0 , vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));
        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(0, 70, -400.0), vec2(0.8, 0.2), 150.0, vec3(10, 0, 1), noise), DISTANT_TREE_MATERIAL_ID));

        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 30, 0.0), vec2(0.8, 0.2), 40.0 , vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));
        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 50, 0.0), vec2(0.8, 0.2), 60.0 , vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));
        res = opU(res, vec2(DistantTreeGridIntersect(pos, vec3(-450, 70, 0.0), vec2(0.8, 0.2), 150.0, vec3(1, 0, 10), noise), DISTANT_TREE_MATERIAL_ID));

    }
    
    if(!farFromCamera && (IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)
    {
        res = opU(res, vec2(TreeTrunkIntersect(pos, vec3(0, 50, -5.0), vec2(0.95, 0.05)), TREE_MATERIAL_ID));
        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(0, 30, -5.0), 25.0, 10.0, 0.0, noise), LEAF_MATERIAL_ID));    
        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(35, 30, -45.0), 50.0, 16.0, 0.0, noise), LEAF_MATERIAL_ID));    
        res = opU(res, vec2(TreeTrunkIntersect(pos, vec3(88, 50, -5.0), vec2(0.95, 0.05)), TREE_MATERIAL_ID));
        res = opU(res, vec2(DetailedTreeIntersect(pos, vec3(88, 30, -5.0), 30.0, 12.0, 0.0, noise), LEAF_MATERIAL_ID));    
    }
    
    if((IntersectFlags & SKIP_GROUND_PLANE_INTERSECT_FLAG) == 0)
    {
		res = opU(res, vec2( snowLandscape(pos), SNOW_MATERIAL_ID ));
    }

    res = opU(res, vec2(SphereIntersect(pos, CabinLamp.Position, CabinLamp.Radius), CABIN_LAMP_MATERIAL_ID));
    
    // Cabin
    if(!farFromCamera && (IntersectFlags & SKIP_CABIN_INTERSECT_FLAG) == 0)
    {
        vec3 PatioDimensions = vec3(CabinDimensions.x, 1, PatioOffset / 2.0);
        // Main room
        res = opU(res, vec2(CabinBoxIntersect(pos, CabinOrigin, CabinDimensions), WOOD_MATERIAL_ID));
        
        vec3 DoorDimensions = vec3(2.0, 7.0, 0.3);
        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, 0, CabinDimensions.z), DoorDimensions), WOOD_MATERIAL_ID));

        vec3 WindowDimensions = vec3(3.0, 2.5, 0.3);
        float WindowYOffset = 5.0;
        
        for(int i = 0; i < NUM_CABIN_WINDOWS; i++)
        {
            res = opU(res, vec2(BoxIntersect(pos, GetWindow(int(i)).Position, GetWindow(int(i)).Dimension), CABIN_WINDOW_MATERIAL_CUSTOM_BASE_ID + i));
        }
        
        res = opU(res, vec2(CabinPillarIntersect(pos), WOOD_MATERIAL_ID));
        res = opU(res, vec2(CabinRailingIntersect(pos), WOOD_MATERIAL_ID));
		
        // Patio roof
        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, CabinDimensions.y, PatioOffset / 2.0), PatioDimensions), WOOD_MATERIAL_ID));
 
        // Patio deck
        vec3 DeckDimensions = vec3(CabinDimensions.x, 5, PatioOffset / 2.0);
        res = opU(res, vec2(BoxIntersect(pos, CabinOrigin + vec3(0, -3.5, PatioOffset / 2.0), PatioDimensions), WOOD_MATERIAL_ID));

        float roofAngle = PI / 4.5;
        float atticRoofAngle = PI / 3.6;
        float CabinRoofHeight = CabinDimensions.z * 0.55;
        vec3 CabinRoofOrigin = CabinOrigin + vec3(0, CabinDimensions.y + 2.0, 0);

        if((IntersectFlags & SHADOW_INTERSECT_FLAG) == 0)
        {
        	res = opU(res, vec2(ZAlignedCabinRoof(pos, CabinRoofOrigin, vec2(CabinRoofHeight * 0.7, CabinDimensions.z), atticRoofAngle), WOOD_MATERIAL_ID));
        	res = opU(res, vec2(XAlignedCabinRoof(pos, CabinRoofOrigin, vec2(CabinRoofHeight, CabinDimensions.x), roofAngle), WOOD_MATERIAL_ID));
        }
        
		float yOffset = snowMicroDisplacement(pos) - 1.3;
        float unionMergeFactor = 1.25;
        // Roof snow
        res = opU(res, vec2(
            opSmoothUnion(
                opSmoothUnion(
                    // Patio roof snow
                    BoxIntersect(pos, CabinOrigin + vec3(0, CabinDimensions.y + yOffset, PatioOffset / 2.0), PatioDimensions * 0.98), 
                    // Main roof snow
                    XAlignedTriPrism(pos, CabinRoofOrigin + vec3(0, yOffset + 1.0, 0),  vec2(CabinRoofHeight, CabinDimensions.x) * 0.98, roofAngle),
                    unionMergeFactor),
                // Cabin attic room roof snow
                ZAlignedTriPrism(pos, CabinRoofOrigin + vec3(0, yOffset + 1.15, 0), 0.98 * vec2(CabinRoofHeight * 0.7, CabinDimensions.z),  atticRoofAngle),
                unionMergeFactor), 
            ROOF_SNOW_MATERIAL_ID));
    }

    return res;
}

// Function 2219
float scene(vec3 p)
{
	vec3 a=vec3(0,0,18.9),b=vec3(1.1,2,20);
	float diff=-min(sdBox(p+a,b),sdBox(p+a.zyx,b.zyx));
	float lite=sdBox(p+vec3(3,0,0),vec3(1,2,1));
	m=lite<diff;
	return min(lite,diff);
}

// Function 2220
vec4 scene(vec2 uv, float t)
{
	return circle(uv, vec2(0, sin(t * 16.0) * (sin(t) * 0.5 + 0.5) * 0.5), 0.2);
}

// Function 2221
mapResult map(vec3 p){
    mapResult m;
    int minS = findIndexShortestSphere(p);
    int minP = findIndexShortestPlane(p);
    int minB = findIndexShortestBox(p);
    m.Md = min(spheres[minS].dist,planes[minP].dist);
    m.Md = min(m.Md, boxes[minB].dist);
    m.minS = minS;
    m.minP = minP;
    m.minB = minB;
    return m;
}

// Function 2222
float sdf_I(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));
    return t;
}

// Function 2223
vec2 distfunc(vec3 pos, vec3 lightPos)
{
    pos.xy *= rot(pos.z*sin(iTime*twistSpeed)*twistAmount);
    vec2 squares = calcSquares(pos.xz*squareSize + vec2(0.0, iTime*scrollSpeed), lightPos);
    //Simplified calcule thanks to Shane's advice
    //float p1 = sdPlane(pos - vec3(0.0, squares.x, 0.0), normalize(vec4(0.0,1.0,0.0,0.2)));
    //float p2 = sdPlane(pos + vec3(0.0, squares.x, 0.0), normalize(vec4(0.0,-1.0,0.0,0.2)));
    
    return vec2(0.2 - abs(pos.y) - squares.x, squares.y);
}

// Function 2224
vec2 mapOpaque( vec3 p, out vec4 matInfo )
{
    matInfo = vec4(0.0);
    
    //--------------
    vec2 res = snail( p, matInfo );
   
     
    //---------------
    vec4 tmpMatInfo;
    float d4 = mapShell( p, tmpMatInfo );    
    //if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }
    //res = vec2(d4, 2.0);
    //---------------
    
    // plant
    //vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );
    //d4 = b3.x;
    //d4 -= 0.04 - 0.02*b3.y;
    //if( d4<res.x  ) { res = vec2(d4,3.0); }
    
    //----------------------------
    
    float d5 = mapLeaf( p );
    if( d5<res.x ) res = vec2(d5,4.0);
        
    return res;
}

// Function 2225
float MAT_remap_angle_probability(float x_01)
{
    //cos(jitter) is used to alter probabilty distribution : 
    //it remaps an evenly distributed function into another 
    //one where closer angles are more probable, and wider
    //angles are less probable.
    return (1.0-cos(x_01*PI/2.0));
}

// Function 2226
vec3 toneMap( vec3 color, float exposure )
{
    return pow( exposure * color, vec3( 1., 1., 1. ) / TONE_MAP_GAMMA );
}

// Function 2227
float sdf(vec2 uv) {

    int variation = int(mod(floor(iTime / 10.), 4.));
    
    float pulse = 0.5 + sin(((iTime / 5.) - 0.25) * 3.141 * 2.) * 0.5;
    
    float a;
    float obj1 = 0.;
    float obj2 = 0.;
    
    // Some static arc values.
    float ta1 = 2.;
    float tb1 = 2.;
    float rb1 = 0.05;
    float size1 = 1.;
    
    float ta2 = 3.141;
    float tb2 = 1.;
    float rb2 = 0.1;
    float size2 = .5;
    
    vec2 arcPosition1 = vec2(.75,0.);
    vec2 arcPosition2 = vec2(.5,0.);
    
    float radius1 = 0.15;
    vec2 position1 = vec2(0., -0.2);
    
    float radius2 = 0.8;
    vec2 position2 = vec2(0., 0.4);
    
    switch (variation) {
        case 0:

            obj1 = sdCircle(uv - position2, radius2);    
            obj2 = sdCircle(uv - position1, radius1); 
            
            a = 0.22;
            
            break;
            
        case 1:
            obj1 = sdCircle(uv - position2, radius2); 
            obj2 = sdArc(uv - arcPosition1,vec2(sin(ta1),cos(ta1)),vec2(sin(tb1),cos(tb1)), size1, rb1);  
            
            a = 0.14;
            
            break;
            
        case 2:
            obj1 = sdArc(uv - arcPosition1,vec2(sin(ta1),cos(ta1)),vec2(sin(tb1),cos(tb1)), size1, rb1);  
            obj2 = sdArc(uv - arcPosition2,vec2(sin(ta2),cos(ta2)),vec2(sin(tb2),cos(tb2)), size2, rb2);
            
            // a = 0.09;
            a = 0.3;
            
            break;
            
        case 3:


            obj1 = sdBox(uv - position1, vec2(0.5, 0.5)); 
            obj2 = sdCircle(uv - position2, radius2); 
            
            a = 0.09;
            
            break;
    }
    
    return mix(obj1, obj2, pulse) - a * (1. - (2. * abs(pulse - 0.5)));
}

// Function 2228
float map(vec4 p) {
    
    
    
    //vec4 p2 = abs(mod(p,4.0)-2.0)-1.0;
    //return box(p2,0.5);
    vec4 p2 = mod(p,2.0)-1.0;
    vec4 floorpos = floor(p*0.5);
    float len = 1e10;
    
    //the truchet flipping
    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0;
    //orientation.yz = vec2(1.0);
    
    //actually flipping the truchet
    vec4 p3 = p2*orientation;
    
    //positions relative to truchet centers
    
    float x = 1.0;
    
    vec4[4] truchet = vec4[4] (
        vec4(p3.xy+vec2(+1,-1),p3.zw),// +x +y
        vec4(p3.xz+vec2(-1,-1),p3.yw),// +x    +z
        vec4(p3.yw+vec2(+1,-1),p3.xz),//    +y    +w
        vec4(p3.zw+vec2(+1,+1),p3.xy) //       +z +w
    );
    
    //finding distance to truchet
    len = min(min(min(
        torus2(truchet[0],vec2(1.0,0.05)),
        torus2(truchet[1],vec2(1.0,0.05))),
        torus2(truchet[2],vec2(1.0,0.05))),
        torus2(truchet[3],vec2(1.0,0.05)));
    
    return len;
}

// Function 2229
float scene(vec3 p)
{	
    float d;
    //d = box(p, vec3(1.0));
    //p.z += sin(time)*1.5;
    //d = diff( d, sphere(p, sin(time*0.5)*1.5) );
	
    //d = sphere(p, 1.0);	
    d = sphere(p, sin(iTime)*0.5+0.5);

    vec3 pr = p - vec3(1.5, 0.0, 0.0);
    pr = rotateX(pr, iTime);
    pr = rotateY(pr, iTime*0.3);	
    d= _union(d, diff(box(pr , vec3(0.6)), sphere(pr, 0.7)) );

    //d = _union(d, sdCone(p + vec3(1.5, -0.5, 0.0), vec2(1.0, 0.5)));
    pr = p + vec3(1.5, 0.0, 0.0);
    pr = rotateX(pr, iTime);
    d = _union(d, sdTorus(pr, vec2(0.5, 0.25)));
	
    d = _union(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, -1.0, 0.0)) );
    return d;
}

// Function 2230
vec4 getBitmapColor( in vec2 uv )
{
	return getColorFromPalette( getPaletteIndex( uv ) );
}

// Function 2231
vec3 map( in vec3 p )
{
	vec3 q = vec3( 4.0*fract(0.5+p.x/4.0)-2.0, p.y, 4.0*fract(0.5+p.z/4.0)-2.0 );
	vec2 id = floor( 0.5+p.xz/4.0 );
    q.xz += 0.5*(-1.0+2.0*vec2(hash(id.x+113.0*id.y),hash(13.0*id.x+57.0*id.y)));
	q.y -= 0.5;
	float d1 = length(q) - 1.0;

	float d2 = p.y;
    d1 = min( d1, d2 );
	d1 = min( d1, length(q.xz)-0.1 );
#if 0
    return vec3( d1, 1.0, 0.0 );
#else
	float h = 0.5+0.5*clamp(1.0-p.y,0.0,1.0);
	//p.y += 0.2*iTime;
	vec3 v = voronoi(2.0*p);
	float f = clamp( 3.5*(v.y-v.x), 0.0, 1.0 );
	d1 -= 0.2*f*h;
	
    return vec3( 0.5*d1, mix(1.0,f,h), v.z );
#endif	
}

// Function 2232
float BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)
{
    point -= boxPos;
    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P
    
    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c
    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU
    vec3 q = abs(point) - boxRadius;
    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;
}

// Function 2233
float map( in vec3 p )
{
	return sdMetaBalls( p );
}

// Function 2234
vec4 GetDistanceScene(const in vec3 vPos)
{
	vec4 vResult = vec4(10000.0, 0.0, 0.0, 0.0);
	vec3 ct_domain = vPos;
	ct_domain.y -= 4.0;
	vec4 vDistChaosTrendLogo = GetDistanceChaosTrendLogo(ct_domain);
	vResult = DistCombineUnion(vResult, vDistChaosTrendLogo);
	
	vec4 vDistFloor = vec4(vPos.y + 1.0, 0.01, vPos.xz);
	vResult = DistCombineUnion(vResult, vDistFloor);
	
	#ifdef ENABLE_TEST_CYLINDER
	vec3 cyldomain = vPos;
	cyldomain.y -= 3.5;
	vec4 cyldist = GetDistanceCylinderMaterialSelectorZ(cyldomain, 0.5, 8.0);		
	vResult = DistCombineUnion(vResult, cyldist);	
	#endif
	return vResult;
}

// Function 2235
float map_ball(vec3 pos)
{
    float snow = snowThicknessFactor*snowThickness(pos);
    float df = length(pos) - ballRadius - snow;
    
    #ifdef show_gold
    #ifdef gold_bump
    vec3 pos2 = pos + 0.1*noise(pos*12.);
    df+= goldBump*(1. - snowValue(pos))*smoothstep(goldTreshold + 0.15, goldTreshold + 0.01, sin(noisePattern(pos2)*goldFrequency));
    #endif
    #endif
    
    return df;
}

// Function 2236
float distCylinder( vec3 pos, vec3 properties )
{
	pos.xz += sin(pos.zx)*.25;
	pos.xz = mod(pos.xz,TREE_REP.xz);
	pos.xz -= vec2(TREE_REP.xz*.5);
	
	return length(pos.xz-properties.xy)-properties.z;
}

// Function 2237
float buildSDF(vec2 st){
    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);    
    float center = length((st-vec2(0.5))*aspect);
    float noisevalue = noise((st+vec2(0.,iTime*0.85))*5.*aspect) + noise((st+vec2(0.,iTime*0.253))*9.*aspect)*0.25;
    return smoothstep(1.3,0.,center)*0.1+noisevalue*-0.4+(st.y-0.5)*0.1;
}

// Function 2238
vec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )
{
	vec3 vResultColor = vec3(0.0);
            
	SceneResult firstTraceResult;
    
    int stackCurrent = 0;
    int stackEnd = 1;
    
    RayStack_Reset();
        
    rayStack[0].vRayOrigin = vInRayOrigin;
    rayStack[0].vRayDir = vInRayDir;
    rayStack[0].fStartDist = 0.0;
    rayStack[0].fLengthRemaining = kMaxTraceDist;
    rayStack[0].fRefractiveIndex = 1.0;
    rayStack[0].vAmount = vec3(1.0);
    rayStack[0].iChild0 = -1;
    rayStack[0].iChild1 = -1;       
           
	for( int iPassIndex=0; iPassIndex < RAY_STACK_SIZE; iPassIndex++ )
	{	                
        if ( stackCurrent >= RAY_STACK_SIZE )
            break;
        
        RayInfo rayInfo = RayStack_Get( stackCurrent );
        
        if ( rayInfo.fLengthRemaining <= 0.0 )
            continue;
        
        rayInfo.iChild0 = -1;
        rayInfo.iChild1 = -1;
        
    	SceneResult traceResult = Scene_Trace( rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fStartDist, rayInfo.fLengthRemaining, rayInfo.iObjectId );
        
        rayInfo.fDist = traceResult.fDist;
        
        //if ( iPassIndex == 0 )
        //{
          //  firstTraceResult = traceResult;
        //}
        
		rayInfo.vColor = vec3(0.0);
		vec3 vReflectance = vec3(1.0);

		if( traceResult.iObjectId < 0 )
		{
            rayInfo.vColor = Env_GetSkyColor( rayInfo.vRayOrigin, rayInfo.vRayDir ).rgb;
        }
        else
        {
            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( rayInfo.vRayOrigin, rayInfo.vRayDir, traceResult, rayInfo.iObjectId );
            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( rayInfo.vRayDir, surfaceInfo );
                
            // calculate reflectance (Fresnel)
            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -rayInfo.vRayDir ), 0.0, 1.0);
			vReflectance = Light_GetFresnel( -rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );
			
			rayInfo.vColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectance); 
            
			vec3 vReflectAmount = vReflectance;                
            vec3 vTranmitAmount = vec3(1.0) - vReflectance;
            vTranmitAmount *= surfaceInfo.fTransparency;
            
            bool doReflection = true;
            
            // superhack
            //if ( false )
            if ( surfaceInfo.fTransparency > 0.0 )
            {                
                vec3 vTestAmount = vTranmitAmount * rayInfo.vAmount;
                
                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )
                {
                    RayInfo refractRayInfo;

                    refractRayInfo.vAmount = vTranmitAmount;
                    refractRayInfo.vRayOrigin = surfaceInfo.vPos;
                    refractRayInfo.iObjectId = traceResult.iObjectId;
                                        
					refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, rayInfo.fRefractiveIndex / surfaceInfo.fRefractiveIndex );
                    if ( traceResult.iObjectId == rayInfo.iObjectId )
                    {
                        refractRayInfo.iObjectId = -1;
                    }                    
                    /*
                    if ( (rayInfo.fObjectId != -1.) && (traceResult.fObjectId == rayInfo.fObjectId) )
                    {
                        refractRayInfo.fObjectId = -1.;
                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.fRefractiveIndex );
                    }
                    else
                    {
                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, 1.0 / surfaceInfo.fRefractiveIndex );
                    }*/
                    
                    if ( length( refractRayInfo.vRayDir ) > 0.0 )
                    {
                        refractRayInfo.vRayDir = normalize(refractRayInfo.vRayDir);
                        //refractRayInfo.vRayDir.xz *= -1.0;
                        refractRayInfo.fStartDist = abs(0.1 / dot( refractRayInfo.vRayDir, surfaceInfo.vNormal ));            
                        refractRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                
                        refractRayInfo.fDist = 1.0 - rayInfo.fDist;
                        refractRayInfo.fRefractiveIndex = surfaceInfo.fRefractiveIndex;

                        rayInfo.iChild1 = stackEnd;

                        //if ( stackEnd < RAY_STACK_SIZE )
                        {
                            rayInfo.vColor *= 1.0 - surfaceInfo.fTransparency;        
                            refractRayInfo.vAmount *= surfaceInfo.fTransparency;
                        }
                        RayStack_Set( stackEnd, refractRayInfo );                        
                        stackEnd++;
                        
                        doReflection = false;
                    }
                    else
                    {
                        vReflectAmount += vTranmitAmount;
                    }
                }
            }
                        
            // Reflect Ray
            if ( doReflection )
            {
                vec3 vTestAmount = vReflectAmount * rayInfo.vAmount;
                
                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )
                {                
                    RayInfo reflectRayInfo;

                    reflectRayInfo.vAmount = vReflectAmount;
                    reflectRayInfo.vRayOrigin = surfaceInfo.vPos;
                    reflectRayInfo.vRayDir = normalize( reflect( rayInfo.vRayDir, surfaceInfo.vBumpNormal ) );
                    reflectRayInfo.iObjectId = rayInfo.iObjectId;
                    reflectRayInfo.fStartDist = abs(0.01 / dot( reflectRayInfo.vRayDir, surfaceInfo.vNormal ));            
                    reflectRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                
                    reflectRayInfo.fRefractiveIndex = rayInfo.fRefractiveIndex;

                    rayInfo.iChild0 = stackEnd;

                    RayStack_Set( stackEnd, reflectRayInfo );
                    stackEnd++;
                }
            }
            
            rayInfo.vColor += surfaceLighting.vSpecular * vReflectance;            
        }
        
		RayStack_Set( stackCurrent, rayInfo );
                
        stackCurrent++;
    }
        
	for( int iStackPos=(RAY_STACK_SIZE-1); iStackPos >= 0; iStackPos-- )
	{	    
        RayInfo rayInfo = RayStack_Get( iStackPos );

        if ( rayInfo.fLengthRemaining <= 0.0 )
            continue;

        // Accumulate colors from child rays
        
        if ( rayInfo.iChild0 >= 0 )
        {
	        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild0 );
            if ( childRayInfo.fDist > 0.0 )
            {
            	rayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;
            }
        }

        if ( rayInfo.iChild1 >= 0 )
        {
	        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild1 );
            if ( childRayInfo.fDist > 0.0 )
            {
	            rayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;
            }
        }
        
		rayInfo.vColor = Env_ApplyAtmosphere( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist, rayInfo.iObjectId );
		rayInfo.vColor = FX_Apply( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist );
            
		RayStack_Set( iStackPos, rayInfo );        
    }    
    
    if ( firstTraceResult.iObjectId >= MAT_FG_BEGIN )
    {
        firstTraceResult.fDist = -firstTraceResult.fDist;
    }
        
    return vec4( rayStack[0].vColor, rayStack[0].fDist );
}

// Function 2239
vec3 sceneNormal(vec3 at) {
    return normalize(vec3(
        scene(at + NORMAL_OFFSET.xyy).distance - scene(at - NORMAL_OFFSET.xyy).distance,
        scene(at + NORMAL_OFFSET.yxy).distance - scene(at - NORMAL_OFFSET.yxy).distance,
        scene(at + NORMAL_OFFSET.yyx).distance - scene(at - NORMAL_OFFSET.yyx).distance
    ));
}

// Function 2240
maybe_float get_distance_along_line_to_union(
    in maybe_float shape1,
    in maybe_float shape2
) {
    return maybe_float(
        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),
        shape1.exists || shape2.exists
    );
}

// Function 2241
vec3 GetSceneColour( const in C_Ray ray )
{                                                           
	C_HitInfo intersection;
	Raymarch(ray, intersection, 30.0, 256);
		     
	vec3 cScene;
	
	if(intersection.vObjectId.x < 0.001)
	{
		cScene = GetSkyGradient(ray.vDir);
	}
	else
	{
		C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);
		
		vec3 vNormal = GetSceneNormal(intersection.vPos);
	
		vec3 cReflection;
		#ifdef ENABLE_REFLECTIONS	
		{
			// get colour from reflected ray
			float fSepration = 0.05;
			C_Ray reflectRay;
			reflectRay.vDir = reflect(ray.vDir, vNormal);
			reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;
									       
			cReflection = GetSceneColourSimple(reflectRay);                                                                          
		}
		#else
		cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                               
		#endif
		// apply lighting
		cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );
	}
	
	ApplyAtmosphere(cScene, ray, intersection);
	
	return cScene;
}

// Function 2242
vec3 trn_normalmapLod( vec3 pos, float scale )
{
    float lod = log2( scale / 0.001 );
    return .15 * texturenoiseLod( pos / 0.01, lod - 3.322 ).xyz +
        .35 * texturenoiseLod( pos / 0.003, lod - 1.585 ).xyz +
        .35 * texturenoiseLod( pos / 0.001, lod ).xyz +
        .15 * texturenoiseLod( pos / 0.0003, lod + 1.585 ).xyz;
}

// Function 2243
float map( in vec3 pos )
{
    float rad =  (1.0/(3.141*2.0)*20.0);
    vec3 dp = vec3(pos.z, atan(pos.x, pos.y) * rad, rad-length(pos.xy));    
    float d1 = sdCylinder(dp,vec2(0.8,HEIGHT))-0.5;
    float t = iTime*1.35;
    float n1 = noise(dp+vec3(0.0,t*1.0,0.0),1.0,3.57,.83);
    float n2 = noise(dp+vec3(sin(t*.2)*2.0,t*1.5,0.0), 1.5, 4.47, 1.43);
    float n3 = noise(dp+vec3(0.0,t*2.0,0.0), 2.0, 1.87,3.13);
    n1 = smin(n1,n2,4.);
    n1 = smin(n1,n3,4.);
  	d1 = smax(n1,d1,4.);
    
    n3 = noise(pos+vec3(0.0,t*2.0,0.0),1.0,3.57,1.83)*2.0;
    float disp = (sin(pos.z*1.3+t*1.1+pos.x*0.4)+cos(n3+t*1.3+pos.z*1.5+sin(t*2.2+pos.x*1.25)))*0.1;
    
    float d2 = dot(pos,vec3(0.0,1.0,0.0)) + 1.5+disp;   
    //d1 = smin(d1,d2,1.2);
    
    vec3 goo = hsv2rgb(vec3(t*0.2+dp.y*0.075,0.85,0.9));
    
    d1 = sminCol(d1,d2,1.2,vec3(0.025,0.2,0.75),goo);
    
    return d1*0.75;
}

// Function 2244
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstBoid, dstObj;
  dstBoid = BoidHit (ro, rd);
  dstObj = ObjRay (ro, rd);
  if (min (dstObj, dstBoid) < dstFar) {
    if (dstBoid < min (dstObj, dstFar)) {
      ro += rd * dstBoid;
      col4 = BoidCol ();
      vn = qnHit;
    } else if (dstObj < dstFar) {
      ro += rd * dstObj;
      col4 = vec4 (0.8, 0.8, 0.9, 0.1);
      vn = VaryNf (32. * ro, ObjNf (ro), 0.5);
    }
    col = col4.rgb * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +
       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
  } else col = BgCol (ro, rd);
  return clamp (col, 0., 1.);
}

// Function 2245
float sdf_K(vec2 uv)
{
	float sdf = sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2));
	sdf = sdf_disk(uv, vec2(.17, .17), .5);
	sdf = sdf_exclude(sdf, sdf_disk(uv, vec2(.1, -.05), .6));
    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(-.32, .3), vec2(.4, .8)));
    sdf = sdf_union(sdf, sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2)));
	sdf = sdf_union(sdf, sdf_seriffed_box(skew(uv+vec2(.25,-.3),-1.3), vec2(.1, .3), vec2(mix(.25, .01, linear_step(.5, 1., uv.y)), .3), vec2(0.,.3), vec2(.5,.3)));
    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .1), vec2(.4, .2)));
    return sdf;
}

// Function 2246
float sdfCore(vec3 p)
{
	return length(p-vec3(0.0,.1,0.0)) - 1.395;
}

// Function 2247
float planeDist(vec4 plane, vec3 point)
{
    
	return abs(dot(plane, vec4(point, 1.0)));
}

// Function 2248
float mapH( in vec3 pos )
{

    float d1 = pos.y-terrainHeight(pos)*3.;
    
    
    return d1;//smin( d1, d2, 1.0 );
}

// Function 2249
vec3 map(vec3 p){
    vec2 a = vec2(1);
    vec2 b = vec2(1);
    float c = 0.;
    float t = 10. * -sin(0.5*iTime)*sin(-iTime)*sin(iTime);

    float size = 0.062; //Thickness of spiral curls
    float scale = size-0.01 ; //Space between spiral curls
    
    float expand = 0.04; //Corner Rounding Amount 

    float m2 = size*6.0; //Repetition Sizes
    float m = pi*scale; //Repetition Sizes
    
    float ltime = 10.; //How often the spirals rolls repeat
    
    //Move everything upwards so it stays in frame
    p.y-=(t/ltime)*size*6.;
    
    //small offset for framing
    p.x-=3.; 
    
    float width = 0.5; //Lane Width
    float count = 6.; //Number of spirals (x2)
    
    float modwidth = width*2.0+0.04+0.06;
    
    float id3 = idlim(p.z,modwidth,-count,count);
    t+=h11(id3*0.76)*8.0;
    p.z = lim(p.z,modwidth,-count,count);
    
    #ifdef FUN_MODE
        scale+=(sin(t)*0.5+0.5)*0.05;
        m = pi*scale;
    #endif
    
    float to = t;
    vec3 po = p;

    //float id = 0.;

    //Spiral 1
    float stack = -floor(t/ltime);
    float id2 = idlim2(p.y,m2,stack);
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    a.x = spiral(p.xy,t,m,scale,size,expand);
    //a.y = id2*3.-2.;
    c = a.x;
    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal
    
    //Spiral 2
    p = po;
    t = to;
    p.y+=size*2.0;
    t-=ltime/3.0;
    stack = -floor(t/ltime);
    id2 = idlim2(p.y,m2,stack);
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    
    b.x = spiral(p.xy,t,m,scale,size,expand);
    //b.y = id2*3.-1.;
    c = min(c,b.x);
    a=(a.x<b.x)?a:b;
    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal
    
    //Spiral 3
    p = po;
    t = to;
    p.y+=size*4.0;
    t-=2.*ltime/3.0;
    stack = -floor(t/ltime);
    id2 = idlim2(p.y,m2,stack);    
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    b.x = spiral(p.xy,t,m,scale,size,expand);
    //b.y = id2*3.;
    c = min(c,b.x);
    a=(a.x<b.x)?a:b;
    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal
    
    
    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;
    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand;
    
    //Intersection distance to plane between each lane
    b.x = diplane(po ,vec3(modwidth), rdg); //Artifact Removal
    b.y = 0.;
    
    //a.y-=10.0;
    //a.y+=h11(id3);
    
    a=(a.x<b.x)?a:b; //Artifact Removal
    
    return vec3(a,c);
}

// Function 2250
vec2 scene(in vec3 position) {


    vec3 p=position;
    p-=vec3(0.0,-0.5,0.0);
    p/=vec3(0.5);
    float star=sdStar(p)*0.3;
    p-=vec3(0.0,0.0,1.0);
    float sphere=sdShere(p)*0.3;
    p-=vec3(0.0,3.0,-4.3);
    p*=rotate_x(1.5);
    float torus=box (p)*0.3;
  
    star=min(star,sphere);
    star=min(star,torus);
  
    
   
   
    vec2 scene = opUnion(
          vec2(sdPlane(position), 1.0),
          vec2(star, 12.0)
    );
    return scene;
}

// Function 2251
vec2 map( vec3 p, out vec3 matInfo )
{
    vec2 res = vec2(p.y+2.2-1.0);
    
    // bounding volume for big elephant
    //float b2 = length(p-vec3(0.5,1.7,0.0))-2.1;
	//if( b2<res.x )    
    {
        res = mapElephant( p, matInfo );
    }
    
    // bounding volume for small elephant
    float bb = length(p-vec3(-0.4,0.5,-0.8))-1.3;
    if( bb<res.x )
    {
        vec3 mi2;
        vec2 tmp = mapSmallElephant( p, mi2 );
        if( tmp.x<res.x ) { res=tmp; matInfo=mi2; }
    }
    
    return res;
}

// Function 2252
vec2 map( vec3 p )
{
    // table
    vec2 d2 = vec2( p.y+0.55, 2.0 );

    // apple
    p.y -= 0.75*pow(dot(p.xz,p.xz),0.2);
    vec2 d1 = vec2( length(p) - 1.0, 1.0 );

    // union    
    return (d2.x<d1.x) ? d2 : d1; 
}

// Function 2253
float map(mediump vec2 rad)
{
    float a;
    if (res<0.0015) {
    	//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;
        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));
    } else if (res<0.005) {
        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);
        //a = texture(iChannel0,rad*0.3).x;
        a = noise2(rad.xy*20.6);
        //if (a1<a) a=a1;
    } else a = noise2(rad.xy*10.3);
    return (a-0.5);
}

// Function 2254
vec2 bumpmap(in vec3 p, in vec3 n, in float id)
{
    // The garage floor and ceiling have their own reflectivities.
    if(id == ID_GARAGE)
    {
        // The floor is bumpy, with some smoother spots where puddles are.
        if(n.y > 0.8)
        {
            vec2 bumpy = .5*vec2(fbm(p, n),fbm(-p, n)) - .25;
			vec2 smth = vec2(0.);
        	return mix(bumpy,smth,step(.6, fbm(.005*p, n)));
        }
        // The ceiling is bumpy everywhere, but not shiny everywhere, as
        // handled in the reflectivity function.
        else if(n.y < -.8)
            return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;
        else return vec2(0.);
    }
    // The pipes are smoothish.
    else if(id == ID_PIPES)
    {
		p *= .1;
        return .25*vec2(n3D(p, n),n3D(-p, n)) - .125;
    }
    else return vec2(0.);
}

// Function 2255
bool distanceEstimator(RoundBox s, Point3 X, inout float distance, inout Material material) {
 	vec3 q = abs(X - s.center) - s.radius + s.round;
  	float t = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0) - s.round;    
    
    bool closer = (t < distance);
    
    distance = closer ? t : distance;
    
    if (closer) {
	    material = s.material;
    }
    return closer;
}

// Function 2256
bool intersect_scene(const in Ray r, out float t, out int idx, out Ray hit, out bool inside)
{
	t = INFINITY;
    idx = -1;
    for (int i = 0; i < SPHERE_COUNT; i++){
        float n_t = intersect_sphere(r, spheres[i]);
        if (n_t > 0. && n_t < t){
     		t = n_t;
            idx = i;
        }
    }
    if  (t == INFINITY){
        return false;
    }
    else{
		hit.o = r.o +  r.d  * t; //this point might be beneath the surface of the sphere
        hit.d = normalize(hit.o - spheres[idx].p);
        inside = distance(r.o, spheres[idx].p) <= spheres[idx].r;
        hit.d *= inside ? -1. : 1.; //flip the normal if inside the sphere
        //hit.o += hit.d * 0.1; //make sure the point does not go through
        return true;
    }
}

// Function 2257
float sdf_A(vec2 uv)
{
    float h = linear_step(.3, .9, uv.y);
	float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(mix(.7, .01, h), .6), vec2(0.,.3), vec2(.2,.3));
    h = linear_step(.1, .65, uv.y);
	sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.45, .1), vec2(mix(.7, .01, h), .55), vec2(0.,.3), vec2(0.,.3)));
    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.45, .47), vec2(.18, .02)));
    return sdf;
}

// Function 2258
vec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )
{
    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}

// Function 2259
vec3 GetSceneColourPrimary( const in C_Ray ray )
{                                                          
    C_HitInfo intersection;
    Raymarch(ray, intersection, 256, kTransparency);
                
    vec3 cScene;

    if(intersection.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;
        
        surface.vNormal = GetSceneNormal(intersection.vPos, kTransparency);

        C_Material material = GetObjectMaterial(intersection);

        surface.cReflection = GetReflection(ray, intersection, surface);

        if(material.fTransparency > 0.0)
        {    
            surface.cTransmission = GetTransmission(ray, intersection, surface, material);
        }

        // apply lighting
        cScene = ShadeSurface(ray, intersection, surface, material);
    }

    ApplyAtmosphere(cScene, ray, intersection);

    return cScene;
}

// Function 2260
float map( in vec3 pos )
{
    pos *= cubeForm;
    pos.y += Yelevation;
    
    pos.y += 3.66;
    pos.z += 0.4;
    pos *= 0.35;
        
    float res = udRoundBox(  pos-vec3( 0.0,1.25, 0.0), vec3(0.15), 0.01 );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.25, 0.0), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.25, 0.33), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.25, 0.33), vec3(0.15), 0.01 ) );
    
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.58, 0.0), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.0,1.58, 0.33), vec3(0.15), 0.01 ) );
    res = min( res, udRoundBox(  pos-vec3( 0.33,1.58, 0.0), vec3(0.15), 0.01 ) ); 
    return res;
}

// Function 2261
vec3 uncharted2ToneMapping(vec3 x){
	
		
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 2262
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c, vn;
  vec2 s, w;
  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;
  bool isImg;
  pgSize = vec3 (3.2, 0.011, 1.8);
  tpCyc = 3.;
  tpWait = 4.;
  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :
     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));
  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));
  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);
  isImg = false;
  dstObj = ExObjRay (ro, rd);
  if (dstObj < dstFarEx) {
    ro += dstObj * rd;
    vn = ExObjNf (ro);
    nDotL = max (dot (vn, ltDirEx), 0.);
    if (idObj <= nPage) {
      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;
      c = (idPage > 1.) ? vec3 (0.8, 0.8, 0.9) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz)) :
         vec3 (0.1, 0.1, 0.6);
      col4 = vec4 (c, 0.2);
      s = pgSize.xz - abs (qHit.xz);
      if (qHit.y > 0.) {
        w = qHit.xz / pgSize.z;
        if (min (s.x, s.y) > 0.3) {
          isImg = true;
          ExMain (col, w);
        } else if (idPage > 1. && min (s.x, s.y) > 0.27) {
          col4 = vec4 (0.6 * c, 0.2);
        } else {
          col4 = vec4 (c, 0.2);
        }
      }
    } else if (idObj == nPage + 1) {
      col4 = vec4 (0.9, 0.9, 0.8, 0.2);
      nDotL *= nDotL;
    }
    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);
    if (isImg) col *= 0.2 + 0.8 * sh;
    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);
  } else {
    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);
  }
  return clamp (col, 0., 1.);
}

// Function 2263
float map( vec3 pos ){
    
    
    
    vec3 p2 = vec3(1.0*cos(-0.3*time),1.4*sin(time)*cos(-0.4*time),1.7*sin(time)*sin(-0.3*time));
    float d2 = sdSphere( pos-p2, 0.2);
    vec3 p3 = vec3(1.4*sin(0.3*time),0.2,-1.6*sin(0.3*time+0.3));
    float d3 = sdSphere( pos-p3, 0.2);
    vec3 p4 = vec3(0);
    float d4 = sdSphere( pos-p4, 0.2);
    float d00 = sdUnion_s(d2,d3,0.2);
    
    float d0 = sdUnion_s(d00,d4,0.2);

    vec3 pol = carToPol(pos);
    
    float d1 = sdSphere( pos, 1.0 );
    float wave = 0.07*sin(20.*(pol.y));
    d1 = opOnion(d1+wave, 0.001);
    
    return sdUnion_s(d1,d0,0.3);
    
}

// Function 2264
vec2 polarMap(vec2 uv, float shift, float inner) {

    uv = vec2(0.5) - uv;
    
    
    float px = 1.0 - fract(atan(uv.y, uv.x) / 6.28 + 0.25) + shift;
    float py = (sqrt(uv.x * uv.x + uv.y * uv.y) * (1.0 + inner * 2.0) - inner) * 2.0;
    
    return vec2(px, py);
}

// Function 2265
Object map(vec3 p)
{
    Object o;
    o.color = vec3(0);
    o.difVal = 1.0;
    o.specVal = 50.0;
    o.specKs = 0.01;
    
    o.dist = 1000.0;
    o.normEps = 0.001;
    
    float it;
    float len;
    
    float minD = 1000.0;
    vec3 minXYZ = vec3(minD);
    float angBox = 0.0;
    
    vec3 Offset = vec3(0,0,-0.1);
    
    
    p.yz = mat2(cos(PI/2.0), -sin(PI/2.0), sin(PI/2.0), cos(PI/2.0))*p.yz;
    p.y = -1.+mod(p.y, 4.0);
    p.x = -3.0 + mod(p.x, 13.5);

    vec3 or = p;
    vec3 ap = p + 1.0;
    vec3 CSize = vec3(1.,1,1.3);
    //vec3 CSize = vec3(4.4,2.0,0.5);
    //vec3 CSize = vec3(2.0,1.0,0.3);
    float Size = 1.;
    float DEoffset = 0.;
    float DEfactor = 1.5;
    vec3 C = vec3(-0.62,-0.015,-0.025);
    //vec3 C = vec3(-0.8,0.1,0.2);
    //vec3 C = vec3(-0.04,0.14,-0.5);
    vec4 orbitTrap = vec4(1000);
    
    for(int i=0; i < ITERATIONS; i++){
		if(ap == p) break;
        ap=p;
		p=2.*clamp(p, -CSize, CSize)-p;
      
		float r2=dot(p,p);
		orbitTrap = min(orbitTrap, abs(vec4(p,r2)));
		float k=max(Size/r2,1.);
		p*=k;DEfactor*=k;
      
		p+=C;
        orbitTrap = min(orbitTrap, abs(vec4(p,dot(p,p))));
        minD = min(minD, length(p-or));
        minXYZ = min(minXYZ, abs(p - or));
	}
    
    float dist = abs(0.5*abs(p.z-Offset.z)/DEfactor-DEoffset);

    if(dist < o.dist){
    	o.dist = dist;
        o.specVal = 10.0;
        o.specKs = 0.5;
        //o.color = vec3(.1, .533, .631)*orbitTrap.x + vec3(0.0,0.3,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;
        o.color = vec3(.718, .533, .431)*orbitTrap.x + vec3(0.2,0.1,0)*orbitTrap.w;// + vec3(0.3)*minXYZ.y;
    	//o.color = mix(vec3(0.6, 0.4, 0.2), vec3(0.1)*0.4, fbm(pos*500.0));
    }    
    return o;
}

// Function 2266
PathColor TraceScene( vec3 vRayOrigin, vec3 vRayDir, WaveInfo wave, inout uint seed )
{
    float fPathLength = MAX_PATH_LENGTH;
    float fStartDist = 0.0;
    
    int MAX_PATH_ITER = 10;
    
    PathColor cResult = PathColor_Zero();    
    PathColor cRemaining = PathColor_One();
        
    int insideObjId = -1;
    Medium medium;
    
    SceneResult initResult = Scene_GetDistance( vRayOrigin, -1 );
    if ( initResult.fDist <= 0.0 )
    {
    	insideObjId = initResult.iObjectId;
    }
	
    medium = Scene_GetMedium( wave, insideObjId );
    

    for( int pathIter = 0; pathIter < NO_UNROLL(MAX_PATH_ITER); pathIter++ )
    {
        SceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fPathLength, insideObjId );
                
#if SCATTERING     
        
        // scattering 
        float fRandomScatter = FRand( seed );
        
        // probability of scattering per unit distance
        float pDensity = medium.fScatteringDensity;

        float fLifeTime = ScatteringRayLifetime( pDensity, fRandomScatter );
        if ( traceResult.fDist > fLifeTime )
        {
            traceResult.fDist = fLifeTime;
	        fPathLength -= traceResult.fDist;
            
            // Scattering
            
            // Todo - phase function...
            vRayOrigin = vRayOrigin + vRayDir * fLifeTime;
            vRayDir = normalize( vRayDir + 0.1 * PointOnSphereUniform( seed ));
            if ( FRand( seed ) < 0.5 )
            {
                 vRayDir = -vRayDir;
            }
            vRayDir = PointOnSphereUniform( seed );
            //vRemaining *= vec3(0.5, 0.8, 0.9);  
            
            continue;
        }        
#endif        
      
#if ABSORPTION
        // absorption
        float fODist = clamp(traceResult.fDist, 0.0, MAX_PATH_LENGTH );
#if SPECTRAL
        float fTemp = exp( medium.cAbsorb.fIntensity * -fODist );
        PathColor cExtinction = PathColor( fTemp );
#endif      
#if RGB
        vec3 vTemp = exp( medium.cAbsorb.vRGB * -fODist );
        PathColor cExtinction = PathColor( vTemp );
#endif
        cRemaining = ColorScale( cRemaining, cExtinction );
        
#endif        
        fPathLength -= traceResult.fDist;
        
        if ( traceResult.iObjectId < 0 )
        {
            PathColor cEnv = SampleEnvironment( wave, vRayDir );
            cResult = ColorAdd( cResult, ColorScale( cEnv, cRemaining ) );
                        
            break;
        }
        
        int newInsideObjId = insideObjId;
        
        int from = insideObjId;
        int to = traceResult.iObjectId;                
        if ( insideObjId == traceResult.iObjectId )
        {
            to = -1;
        }        
        
        SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, wave, traceResult, insideObjId );        

        float fFromRefractiveIndex = medium.fRefractiveIndex;
        
	    medium = Scene_GetMedium( wave, to );
        
        // hit something
        vRayOrigin = surfaceInfo.vPos;

		PathColor cFresnel = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.cR0, surfaceInfo.fGloss );

        bool bFresnel = false;
        {
	        float fRand = FRand(seed);
            #if SPECTRAL    
            bFresnel = cFresnel.fIntensity > fRand;
        #endif

        #if RGB
            
		if ( cFresnel.vRGB.x == cFresnel.vRGB.y && cFresnel.vRGB.x == cFresnel.vRGB.z && cFresnel.vRGB.y == cFresnel.vRGB.z )
        {
            bFresnel = cFresnel.vRGB[0] > fRand;
        }
        else
        {
            float fBase = fRand * 2.9999;
            int iChannel = int( floor( fBase ) );
            float fRand2 = fBase - float(iChannel);
            bFresnel = cFresnel.vRGB[iChannel] > fRand2;
            
            vec3 scale = vec3(0);
            scale[iChannel] = 3.0f;
            cRemaining.vRGB *= scale;
        }
        #endif             
        }

        vec2 uniformSamplePos = FRand2( seed );        

        float alpha2 = SpecParamFromGloss(surfaceInfo.fGloss);

        vec3 N = surfaceInfo.vBumpNormal;
        vec3 V = -vRayDir;
        vec3 H = ImportanceSampleGGX( uniformSamplePos, N, alpha2 );        
        
        float fToRefractiveIndex = medium.fRefractiveIndex;

       	// Hack - use GGX for refraction "gloss"
        vec3 vRefract = refract( -V, H, fFromRefractiveIndex / fToRefractiveIndex );
        
        if ( length( vRefract ) <= 0.0 )
        {
            bFresnel = true;
        }
        
        if ( bFresnel )
        {
            vRayDir = reflect( -V, H );
        }
        else
        {
            cResult = ColorAdd( cResult, ColorScale( surfaceInfo.cEmissive, cRemaining ) );
            
#if TRANSPARENCY            
            // transparency
            float fTransparency = surfaceInfo.fTransparency;
            if ( FRand( seed ) < fTransparency )
            {                                
				vRayDir = vRefract;
                newInsideObjId = to;                
            }
			else
#endif                
            {
                // diffuse...                
                vRayDir = PointOnHemisphereCosine( seed, surfaceInfo.vNormal );
                cRemaining = ColorScale( cRemaining, ColorScale_sRGB( wave, surfaceInfo.vAlbedo ) );
            }
        }
        
        insideObjId = newInsideObjId;
        
        fStartDist = 0.1 / abs(dot( vRayDir, surfaceInfo.vNormal )); 
        
        if ( ColorIntensity( cRemaining ) < 0.005 )
        {
            break;
        }
    }
    
    return cResult;
}

// Function 2267
vec3 get_color_heatmap(ivec3 tpl, vec4 data){
    vec3 col=vec3(0.);
    for(int i=0;i<3;i++){
        if(tpl[i]>=0){
            uvec4 tdata=decodeval32(floatBitsToUint(data[tpl[i]/4]));
            col[i]=float(tdata[tpl[i]%4])/256.;
        }
    }
    return col;
}

// Function 2268
float Pommel_SDF(in vec3 point)
{
    vec3  tpoint = Translate(point, vec3(0.0, 0.025, 8.75));
    vec3  bounds = vec3(0.08, 0.01, 0.35);
    float radius = 0.075;
    
    float pommel = length(max(abs(
                            vec3(
                                tpoint.x, 
                                tpoint.y, 
                                tpoint.z)) - 
                            vec3(
                                bounds.x,
                                bounds.y, 
                                bounds.z), 
                            0.0)) - (radius + (sin(tpoint.z) * 0.15));
    
    tpoint = Translate(tpoint, vec3(0.0, 0.0, 0.0));
    tpoint = Repeat(tpoint, vec3(0.75, 0.1, 0.0));
    tpoint = RotX(tpoint, 1.57);
    
    float carve = PommelCarve_SDF(tpoint, vec3(0.8, 0.75, 0.5));
    
    pommel = Subtraction(carve, pommel);
    
    return pommel;
}

// Function 2269
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 10.0 ),
	                vec2( sdSphere(    pos-vec3( 0.0,-.25, 0.0), 0.15 ), 46.9 ) );
    
    float numsq = float(num*num);
    for(int i = 0; i < num; i+=1)
    {
        float j = float(i)+1.0;
        float theta = pi*cos(j*iTime/10.0);
        float r = 3.75-3.75*(j*j/numsq);
            
        float c = 24.0;
        //float c = 1.0;
        res = opU( res,
              vec2( sdSphere( pos-vec3( j/2.0, 
                                       4.0 - r*cos(theta), 
                                       r*sin(theta)), 
                             0.25 ), c ) );
        /*
        if (sticks == 1)
        {
        res = opU( res, 
                  vec2( sdCapsule(pos,
                  	vec3(float(j)/2.0, 4.0, 0.0),
                  	vec3(float(j)/2.0, 4.0 - r*cos(theta), 
                                       r*sin(theta)), 0.01
                  ), 1.0));
        }
		*/
    }
    
    return res;
}

// Function 2270
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;
    
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    
}

// Function 2271
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    {
      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )
    {
    
    res = opU( res, vec2( sdTetrahedron( pos-vec3( 0.0, 0.3, 0.0), 0.25 ), 16.9 ) );
    res = opU( res, vec2( sdTet2(      (pos-vec3( 0.0,0.30, 1.0)).xzy, .25 ), 25.0 ) );
	res = opU( res, vec2( sdIsoTet(        pos-vec3( 0.0,0.15,-1.0), 0.25 ), 55.0 ) );
    res = opU( res, vec2( tetrahedronPlanes(  pos-vec3( 0.0,0.25,-2.0), 0.25 ), 33.67 ) );
    
    res = opU( res, vec2( sdTetrahedronIq(  pos-vec3( 1.0, 0.3, 1. ), 3.0,  .01 ), 49.13 ) );
    res = opU( res, vec2( sdTetrahedronPyramid(  (pos -vec3( 1.0, 0.5, -1.0 )) / .3 ) * .3, 39.13 ) );
	res = opU( res, vec2( sdTetrahedronInTetSpace((pos-vec3( 1.0, 0.40, -0.0)), 0.25, 0.0), 18.5) );
    res = opU( res, vec2( sdTetrahedronFrame(pos-vec3( 1.0, 0.35, -2.), .25), 3.0 ) - .02 );
    
	/*
    /**/
    }

    // bounding box
    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x && false )
    {
    // more primitives
    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );
    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x && false )
    {
    // more primitives
	res = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );
	res = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );
    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );
    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );
	res = opU( res, vec2( sdRhombus(   (pos-vec3(-1.0,0.34, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );
    }

    // bounding box
    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x && false )
    {
    // more primitives
    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );
    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.15,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );
	res = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.10,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );
    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );
    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );
    }
    
    return res;
}

// Function 2272
vec3 distribution(vec2 x, vec2 p, float K)
{
    vec4 aabb0 = vec4(p - 0.5, p + 0.5);
    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);
    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));
    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass
    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive
    float m = size.x*size.y/(K*K); //relative amount
    //if any of the dimensions are 0 then the mass is 0
    return vec3(center, m);
}

// Function 2273
vec3 PrefilterEnvMap( float Roughness,vec3 Dir ) { 
	vec3 N = Dir; 
	vec3 V = Dir;
	vec3 PrefilteredColor = vec3(0.);
    float TotalWeight = 0.;
	const uint NumSamples = 1024u; 
	for( uint i = 0u; i < NumSamples; i++ ) { 
		vec2 Xi = Hammersley( i, NumSamples ); 
		vec3 H = ImportanceSampleGGX( Xi, N, Roughness); 
		vec3 L = reflect(-V,H);//2. * dot( V, H ) * H - V;
		float NoL = dot( N, L ); 
		if( NoL > 0. ) { 
			PrefilteredColor += texture(Cubemap_Texture,L).rgb * NoL; 
			TotalWeight += NoL; 
		}
	}
	return PrefilteredColor / TotalWeight;
}

// Function 2274
float distToClouds(vec3 inPos)
{
float y = 1000.0; // ceiling height

return y - inPos.y;
}

// Function 2275
float map( vec3 p )
{
	p *= rotXY(vec2(time*0.6,time*.9));
		
	float d1 = length(p)-20.;
	float d2 = length(max(abs(p)-16., 0.));
	
	return max(d2, -d1);	
}

// Function 2276
float coneSDF(vec3 p, float h, float r) {
    float r2 = ((h/2.0)-p.y)/h;
    r2 *= r;
    r2 = clamp(r2,0.0,r);
    return cylSDF(p,h,r2);
}

// Function 2277
Hit unionSDF(Hit d1, Hit d2) 
{
    if (d1.dist < d2.dist) {
        return d1;
    } else {
        return d2;
    }  
}

// Function 2278
maybe_float get_distance_along_2d_line_to_ray(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in vec2 B
){
    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0
    vec2 D = B0 - A0;
    // offset
    vec2 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 2279
float sdf_W(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(6, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(8, 0, 0), vec3(8, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));
    return t;
}

// Function 2280
vec3 map(in vec3 p) {
	
	float res = 0.;
	
    vec3 c = p;
	for (int i = 0; i < DETAIL; ++i) {
        p =.7*abs(p)/dot(p,p) -.7;
        p.yz= csqr(p.yz);
        p=p.zxy;
        res += exp(-19. * abs(dot(p,c)))+.02;
        
	}
	return res*COLOR_CONTRAST*0.013*(normalize(p)+(1.0-OPACITY_OF_COLOR)*vec3(1.0));
}

// Function 2281
float calcLoadDist_C(vec2 iResolutionxy) {
    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); 
    float gridSize = min(chunks.x, chunks.y);    
    return floor((gridSize - 1.) / 2.);
}

// Function 2282
vec3 mapGrad(vec3 p) {
    const float e = 0.001;
	float a = mapDist(p+vec3(e,e,e));
	float b = mapDist(p+vec3(e,-e,-e));
	float c = mapDist(p+vec3(-e,e,-e));
	float d = mapDist(p+vec3(-e,-e,e));
	return (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);
}

// Function 2283
float map(vec3 p)
{
//	super waves
    if (efx_==0) return fField0(p);
//	pyramid carpet
    if (efx_==1) return fField1(p);	
//	wormhole tunnel  
    if (efx_==2) p=p.xzy;  
//  fancy tunnel
    if (efx_==3) {p=p.xzy;p.z-=iTime; p+=(sin(p*1.9+iTime)+sin(p.yzx+iTime*2.2))*.11;}

    p.xy = vec2( (atan(p.x,p.y)+1.5*sin(0.9*sqrt(dot(p.xy,p.xy))-0.5*iTime))*1.0187,1.-length(p.xy));
	return fField1(p);
    
}

// Function 2284
vec2 dist(int objId,vec3 p,vec3 ray_dir)
{
	float d=scene_scale;
	float isvirtual=0.;
	
	// wall box
	if(objId==OBJ_WALL)
	{
		vec3 b=make_float3(550.*0.5);
		vec3 q=p-b;
        if(q.z<-b.z-EPS) // get to -z face first
		{
			d=-sdBox(q,b,ray_dir);
			isvirtual=1.;
		}
		else
		{
			d=-sdBox(make_float3(q.xy,q.z+b.z),make_float3(b.xy,2.*b.z),ray_dir);
		}
	}
	// short box
	else if(objId==OBJ_SBOX)
	{
		vec3 q=sbox_w2o*(p-sbox_center);		
		d=udBox(q,sbox_halfsize,ray_dir);
	}
	// tall box
	else if(objId==OBJ_TBOX)
	{
		vec3 q=tbox_w2o*(p-tbox_center);		
		d=udBox(q,tbox_halfsize,ray_dir);
	}		
	// light
	else if(objId==OBJ_LIGHT)
	{
		vec3 q=p-light_center;
		d=-sign(q.y)*udBox(q,light_halfsize,ray_dir);
	}
    
	return make_float2(d,isvirtual);
}

// Function 2285
bool map1(vec3 p)
{
    float o = 2.0; 
    
    return map0(p + vec3( -o, 0.0, 0.0)) != 
           map0(p + vec3(  o, 0.0, 0.0)) != 
           map0(p + vec3(0.0,  -o, 0.0)) != 
           map0(p + vec3(0.0,   o, 0.0)) != 
           map0(p + vec3(0.0, 0.0,  -o)) != 
           map0(p + vec3(0.0, 0.0,   o));
}

// Function 2286
vec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, 
         const bool watchIntersect, const bool pencilIntersect ) {
    //--- table
    vec2 res = vec2(sdPlane(pos), MAT_TABLE);
    
    // chain
    if (pos.z > 1.1) {
        float h = smoothstep(3., -.4, pos.z)*.74 + .045;
        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;
        if (dChain0 < 0.1) {
            dChain0 = 10.;
            float pth1z = floor(pos.z*5.);
            if (pth1z > 5.) {
	            float pth1 = hash11(floor(pos.z*5.));
    	        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);
        	    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));
            	dChain0 = sdTorus(pt1, vec2(.071, .02)); 
            }
            
            float pth2z = floor(pos.z*5. + .5);
            float pth2 = hash11(pth2z); 
            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);
            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));
            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          
        }
        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);
    }
    //--- pencil
    if (pencilIntersect) {
        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));
        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);
        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);
        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);
        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);

        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);
        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);
        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);
        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);

        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));
        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);
    }
    
    //--- watch
    if (watchIntersect) {
        float dDial = sdCylinder(p1, vec2(1.05,.13));
        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);

        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));
        if (dC < res.x) res = vec2(dC, MAT_METAL_1);
        
        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   
        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));
        if(bb < 0.5) {
            float a = atan(p1.y, p1.x);
            float c = abs(fract(a*3.1415)-.5);
            float d = min(abs(p1.z-1.3), .02);
            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));
        } 
        dM = opU(dM, bb);
         
        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));
        float rr = min(abs(p1.z-1.26), .2);
        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));
       
        p1.y = abs(p1.y);
        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));
        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));
        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);
        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));
        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));
        if (dM < res.x) res = vec2(dM, MAT_METAL_0);

        // minutes hand
        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);
        if (dMin < res.x) res = vec2(dMin, MAT_HAND);
        // hours hand
        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);
        if (dHour < res.x) res = vec2(dHour, MAT_HAND);
        // seconds hand
        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);
        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);
    }
    
    return res;
}

// Function 2287
float torusSDF_melt( vec3 p, float r, float thickness ){
  vec2 q = fract(.3 * vec2(length(p.xz)-r,p.y));
  return length(q)- thickness;
}

// Function 2288
Intersection sdf3D(vec3 dir, vec3 eye, vec2 uv)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect, LIGHT_POS);
    
    vec3 material = computeMaterial(hitObj, isect, nor, uv);
    
    vec3 warmDir = rotateY(normalize(vec3(0.5, 0.75, 1.0)), sin(iTime * 0.5));
    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));

    float warmDot = max(0.0, dot(nor, warmDir));
    float coolDot = max(0.0, dot(nor, coolDir));

    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);
    overallColor += coolDot * vec3(0.05, 0.15, 0.4);
    overallColor *= material;
    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);
    if (overallColor.x < 0.1 && overallColor.x > 0.045) {overallColor += vec3(0.07, 0.0, 0.07);}
    
    vec3 sdfColor = overallColor + vec3(0.03);
    
    return Intersection(t, sdfColor, isect, hitObj);
}

// Function 2289
float map (vec3 p)
{
	vec2 u = floor(p.xz*0.005*64.0)/64.0;
	float h = hash(u);
	h = p.y - 8.0 * h * h;
	return max( min( h, 0.2), p.y-8.0 );
}

// Function 2290
float map(vec3 p )
{
 // if (abs(p.x) < .5) return 0.;             // slice
	vec3 q = p - vec3(0,.1,1)*iTime;
	float f = 0., s=.5;
    for (int i=0; i< 5; i++ , s/= 2. )
        f += s* noise( q ), q *= 2.;

    f =  1.5 - p.y - 2. + 1.75*f;
    f*= smoothstep(.45,.55,abs(p.x));         // derivable slice
    return f;                        
 // return clamp( f, 0., 1. ); // why not just max(0.,) ?
}

// Function 2291
float groundDistance(vec3 p, inout int mat){
 float distance = 9999.9;
 mat=0;
 hardAdd(mat,distance,1,dBox(p, vec3(0,-50,-23),vec3(70,50,55),40.) );
 distance=smoothAdd(dBox(p,vec3(0,-12,-75),vec3(58,32,36),30.),distance,30.);
 distance=smoothAdd(dBox(p,vec3(0,roadGroundY-20.,64),vec3(roadW,20,100),20.),distance,15.);
 distance+=sin(p.x*.4+sin(p.x*.2)+sin(p.z*.5)*.75)*.2;
 distance+=sin(p.z*.4+sin(p.z*.2)+sin(p.x*.5)*.75)*.2;
 distance=smoothSub(dBox(p,vec3(0,roadGroundY+4.9,roadZ),vec3(roadW,6,12),4.),distance,1.);
 hardAdd(mat,distance,3,dBox(p, vec3(0,roadGroundY-3.1,roadZ),vec3(roadW,2.1,12),.0) );
 return distance;}

// Function 2292
vec2 GetDistanceMirror( const in vec3 vPos )
{
	vec2 vResult = GetDistanceMirrorFrame(vPos);
	
	vec2 vGlass = GetDistanceMirrorGlass(vPos);
	
	if(vGlass.x < vResult.x)
	{
		vResult = vGlass;
	}
		
	return vResult;
}

// Function 2293
float mapdist(vec3 p, vec3 div) {
 
    p=clamp((p/3.0)*0.5+0.5,0.0,0.999);
    float idz1 = floor((p.z+0.0001)*div.x*div.y)/div.x;
    vec2 uvz1 = vec2(fract(idz1),floor(idz1)/div.y);
    vec2 uv1 = p.xy/div.xy+uvz1;
    float idz2 = floor((p.z+0.0001)*div.x*div.y+1.0)/div.x;
    vec2 uvz2 = vec2(fract(idz2),floor(idz2)/div.y);
    vec2 uv2 = p.xy/div.xy+uvz2;
    
    float d1 = texture(iChannel0, uv1).r;
    float d2 = texture(iChannel0, uv2).r;
    
    return mix(d1, d2, fract((p.z+0.0001)*div.x*div.y));
}

// Function 2294
float _mapEnv(in vec3 rp)
{
    rp.z += getPathOffset(rp.x);
    float sgnZ = rp.z > 0.0 ? 1.0 : -1.0;
    
    float sx2 = sin(rp.x * 0.25);
    float sx3 = sin(rp.x * 0.0125);
    ///////////////
    // tilt of valley
    float tilt = (-.2 + smoothstep(-.5, .5, sx3)); 
    g_shadowSharpness = clamp(tilt, 0.025, 0.26); // hack to get shadows look good
    // curves on layers
    float c = sx3 + sx2 * 0.5 + sin(rp.x) * sgnZ * 0.15;
    rp.y += c;
    // layers
    float fy = fract(rp.y / layerSize);
    float l =  floor(rp.y / layerSize) * tilt + smoothstep( 0.0, 0.85, fy) * tilt;
    rp.z = min(0.0, -abs(rp.z) - valleyWidth + l);
    
    // negative space inside
    float m = 0.006 * dot(rp.zy, rp.zy) - .5;
    m = max(-m, sdBox(_mapRP, vec3(10000.0, -c + 5., 10000.0)));
    m = smin(m, sdBox(_mapRP + vec3(0.0, 1.0, 0.0),vec3(20000.0, 1.0, 20000.0)), .2);
	return m;        
}

// Function 2295
float map_wick(vec3 pos)
{
    #ifdef show_candle
    pos = rotateVec2(pos);
    pos.y+= 0.345 + burnPos;
    pos.z*= 1.6;
    float dy = pow(abs(pos.y + 0.1), 3.);
    pos.xz-= dy*vec2(5., 12.);
    
    float df = sdCylinder(pos, vec2(0.018, 0.1));

    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    return df;
    #else
    return 10.;
    #endif
}

// Function 2296
float Map( in vec3 p )
{
	float h = Terrain( p.xz, -100.0 );
	float  turb =Turbulence( p * vec3(1.0, 1., 1.0)*.05 ) * 25.3;
	return p.y-h+turb;
}

// Function 2297
vec2 mapMat(vec3 p){
    vec2 cubeMap = vec2(-length(p) + 4.0, 1.0);
    vec2 mirrorSphere = vec2(length(p - vec3(cos(iTime / 2.0), 0.0, sin(iTime / 2.0))) - 0.25, 2.0);
    return vecMin(cubeMap, mirrorSphere);
}

// Function 2298
float DistanceEstimator(inout distanceestimation d) {
    vec2 uv = fract(d.p.xy * 0.25/S)*S;
    float displacement = 0.0;
    #define SIMPLE
    #ifdef SIMPLE
    vec2 res0 = iChannelResolution[0].xy;
    uv *= res0;
    vec2 luv = floor(uv);
    vec2 fuv = fract(uv);
    #ifdef CURVE
    #undef CURVE
    #endif
    #define CURVE(h) curve3(h)
    vec4 X = CURVE(vec4(
        1.0 - fuv.x,
        fuv.x,
        1.0 - fuv.x,
        fuv.x
    ));
    vec4 Y = CURVE(vec4(
        1.0 - fuv.y,
        1.0 - fuv.y,
        fuv.y,
        fuv.y
    ));
    vec4 F = X * Y;
    displacement += texture(iChannel0, Mod(luv / res0, 1.0)).x * F.x;
    displacement += texture(iChannel0, Mod((luv + i2) / res0, 1.0)).x * F.y;
    displacement += texture(iChannel0, Mod((luv + j2) / res0, 1.0)).x * F.z;
    displacement += texture(iChannel0, Mod((luv + 1.0) / res0, 1.0)).x * F.w;
    #else
    float t = iTime * 2.;
    int s = int(floor(t));
    for(int i = 0; i < NUMPOINTS; i++) {
        int n = s - i;
        vec3 point = vec3(
            randab(sqrt(2.)*float(n))*S,
            t - float(n)
        );
        float d = distance(uv, point.xy);
        for(float ix = -1.; ix < 1.5; ix++)
            for(float iy = -1.; iy < 1.5; iy++) {
                d = min(d, distance(uv + vec2(ix,iy)*S, point.xy));
            }
        float l = point.z - 20. * d;
        float amplitude = clamp(
            (2. - l) * l * exp(1. - l),
            0., 1.
        ) * clamp(1. - d / .5, 0., 1.);
        displacement += cos(10. * l) * amplitude;
    }
    displacement = displacement * .5 + .5;
    #endif
    displacement *= .05;
    d.s = vec3(d.p.xy, displacement);
    d.l = d.p.z - displacement;
    return d.l;
}

// Function 2299
vec2 map(vec3 p)
{
    vec2 d1 = vec2(fruitShape(p), 1.0);
    vec2 d2 = vec2(floorShape(p), 2.0);
    d1 = d2.x < d1.x ? d2 : d1;
    return d1;
}

// Function 2300
vec2 barrel_distort_inv( vec2 ec, float a ) { float ec2 = dot( ec, ec ); float u = a * ( a + 1. ) * ec2; return u < 1. / 4096. ? ec * ( a + 1. ) : ec / ( 2. * a * ec2 ) * ( sqrt( 4. * u + 1. ) - 1. ); }

// Function 2301
float mapHand(in vec3 p) {
    float sph = length(p) - .1;
    if (sph > .1) return sph; //  bounding sphere
    
    const float s = 1.175;
    float d = udRoundBox(p, vec3(.0175/s + p.y * (.25/s), .035/s + p.x * (.2/s), 0.), .01);
    d = smin(d, min(sdCapsule(p, vec3(.025, .0475, 0)/s, vec3(.028, .08, .02)/s, .01/s, .0075/s), 
                    sdCapsule(p, vec3(.028, .08, .02)/s, vec3(.03, 0.1, .06)/s, .0075/s, .007/s)), .0057);
    d = smin(d, min(sdCapsule(p, vec3(.01, .0425, 0)/s, vec3(.008, .07, .025)/s, .009/s, .0075/s), 
                    sdCapsule(p, vec3(.008, .07, .025)/s, vec3(.008, .085, .065)/s, .0075/s, .007/s)), .0057);
    d = smin(d, min(sdCapsule(p, vec3(-.01, .04, 0)/s, vec3(-.012, .065, .028)/s, .009/s, .0075/s), 
                    sdCapsule(p, vec3(-.012, .065, .028)/s, vec3(-.012, .07, .055)/s, .0075/s, .007/s)), .0057);
    d = smin(d, min(sdCapsule(p, vec3(-.025, .035, 0)/s, vec3(-.027, .058, .03)/s, .009/s, .0075/s), 
                    sdCapsule(p, vec3(-.027, .058, .03)/s, vec3(-.028, .06, .05)/s, .0075/s, .007/s)), .0057);
    return d;
}

// Function 2302
float scene (in vec3 p) {
	float t = 2.*iTime;
    vec3 pBottom = p;
    pBottom.x += 3.*iTime;
    float bottom = pBottom.y + 1. + .25*fbm(pBottom.xz, 4);

    float t4 = 2. * iTime;
    float t5 = 2.5 * iTime;
    float t6 = 1.75 * iTime;
    float t7 = 2.5 * iTime;
    float r1 = .1 + .3 * (.5 + .5 * sin (2.*t4));
    float r2 = .1 + .25 * (.5 + .5 * sin (3.*t5));
    float r3 = .1 + .3 * (.5 + .5 * sin (4.*t6));
    float r4 = .1 + .25 * (.5 + .5 * sin (5.*t7));

    float t1 = 1.5 * iTime;
    float t2 = 2. * iTime;
    float t3 = 2.5 * iTime;
    vec3 offset1 = vec3 (-.1*cos(t1), .1, -.2*sin(t2));
    vec3 offset2 = vec3 (.2, .2*cos(t2), .3*sin(t3));
    vec3 offset3 = vec3 (-.2*cos(t3), -.2*sin(t3), .3);
    vec3 offset4 = vec3 (.1, -.4*cos(t2), .4*sin(t2));
    vec3 offset5 = vec3 (.4*cos(t1), -.2, .3*sin(t1));
    vec3 offset6 = vec3 (-.2*cos(t3), -.4, -.4*sin(t1));
    vec3 offset7 = vec3 (.3*sin(t2), -.6*cos(t2), .6);
    vec3 offset8 = vec3 (-.3, .5*sin(t3), -.4*cos(t1));

    float ball1 = sdSphere (p + offset1, r4);
    float ball2 = sdSphere (p + offset2, r2);
    float metaBalls = opCombine (ball1, ball2, r1);

    ball1 = sdSphere (p + offset3, r1);
    ball2 = sdSphere (p + offset4, r3);
    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);

    ball1 = sdSphere (p + offset5, r3);
    ball2 = sdSphere (p + offset6, r2);
    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);

    ball1 = sdSphere (p + offset7, r3);
    ball2 = sdSphere (p + offset8, r4);
    metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);

    vec3 pTop = p;
    float top = -(pTop.y - 3.);

    return min (metaBalls, min (bottom, top));
}

// Function 2303
vec2 map(vec2 z)
{
  return z;  // identity
}

// Function 2304
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4, vn4;
  vec3 col, vn, vno, vnb, rob[2], rdb[2], bgCol, ltVec, roo, row, vnw;
  vec2 lbDist, ws;
  float dstObj, dstObjO, dstCave, dstGrnd, dstWat, sh, atten, wkFac, s;
  bool waterRefl;
  dstObj = ObjRay (ro, rd);
#if ALL_PG || INCAVE
  if (inEnv && inCave) {
    dstCave = CaveRay (ro, rd);
    if (dstCave < min (dstObj, dstFar)) {
      dstObj = dstCave;
      idObj = idCav;
    }
  }
#endif
#if ALL_PG || UNWAT  
  if (inEnv && unWat) {
    dstGrnd = (rd.y < 0.) ? GrndRay (ro, rd) : dstFar;
    if (dstGrnd < min (dstObj, dstFar)) {
      dstObj = dstGrnd;
      idObj = idGrnd;
    }
  }
#endif
  sh = 1.;
  atten = 1.;
  if (bmOn) {
    rob[0] = ro;
    rdb[0] = rd;
  }
  if (inEnv && unWat) {
#if ALL_PG || UNWAT  
    if (dstObj < dstFar) {
      if (idObj == idGrnd) {
        ro += dstObj * rd;
        col4 = mix (vec4 (0.4, 0.3, 0.3, 0.), vec4 (0.3, 0.3, 0.2, 0.),
           0.3 + 0.4 * smoothstep (0.4, 0.6, Fbm2 (2. * ro.xz))) * (1. +
           0.2 * smoothstep (0.3, 0.7, Fbm2 (0.5 * ro.xz)));
        vn = GrndNf (ro);
        vno = vec3 (0., 1., 0.);
        if (vn.y > 0.85) {
          vn4 = RippleNorm (0.25 * ro.xz, vn, 8. * (1. - smoothstep (-0.4, -0.2, dot (rd, vn))));
          vn = vn4.xyz;
          col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w);
        }
        vn = VaryNf (4. * ro, vn, 4. - 3.5 * smoothstep (0.2, 0.5, dstObj / dstFar));
        ws = ro.xz - sbPos.xz;
        ws = Rot2D (ws, sbRot);
        sh = 0.6 + 0.4 * smoothstep (-0.2, 0.8, length (ws -
           vec2 (0., clamp (ws.y, - sbLen, sbLen))) -
           1.2 * (1. - 0.9 * smoothstep (0.4, 1.1, ws.y / sbLen)) *
           (1. - 0.85 * smoothstep (0.6, 1.1, - ws.y / sbLen)));
#if ALL_PG || INCAVE
        if (inCave) sh = min (sh, min (CaveSShadow (ro, vec3 (0., 1., 0.)), 
           0.5 + 0.5 * CaveAO (ro, vec3 (0., 1., 0.))));
#endif
        col = col4.rgb * (0.3 + 0.7 * sh * max (dot (vn, sunDir), 0.));
        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (- dstObj / dstFar));
        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));
      } else if (idObj == idCav) {
#if ALL_PG || INCAVE
        ro += dstObj * rd;
        vn = CaveNf (ro);
        vno = vn;
        col = vec3 (0.4, 0.4, 0.4);
        col *= mix (vec3 (0.5, 0.5, 1.), vec3 (1.), exp (-4. * dstObj / dstFar));
        vn = VaryNf (ro, vn, 12.);
        col *= (0.2 + 0.8 * max (dot (vn, sunDir), 0.) +
           0.5 * pow (max (dot (reflect (sunDir, vn), rd), 0.0), 128.));
        col = mix (col, UnwCol (rd) + WatShd (rd), 0.1 + 0.9 * smoothstep (0.3, 0.8, dstObj / dstFar));
#endif
      } else {
        ro += dstObj * rd;
        vn = ObjNf (ro);
        vno = vn;
        col4 = NautColN (ro, vn);
        sh = ObjSShadow (ro, vec3 (0., 1., 0.));
        if (col4.a >= 0.) {
          col = col4.rgb * (0.5 + 0.5 * sh * max (vn.y, 0.) + 0.2 * UnwCol (rd));
          col *= vec3 (0.7, 0.9, 1.);
        } else {
          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));
        }
      }
      col += 0.2 * step (0.95, sh) * TurbLt (0.02 * ro, abs (vno), 0.2 * tCur) *
         (1. - smoothstep (0.5, 0.8, dstObj / dstFar)) * smoothstep (-0.2, -0.1, vno.y);
    } else {
      col = UnwCol (rd) + WatShd (rd);
    }
#endif
  } else if (! inEnv || inEnv && ! unWat) {
#if ALL_PG || ! UNWAT
    roo = ro;
    dstObjO = dstObj;
    bgCol = (abs (rd.y) < 0.5) ? vec3 (0.05, 0.05, 0.1) : vec3 (0.01);
    waterRefl = false;
    if (inEnv && inCave) {
#if ALL_PG || INCAVE
      if (rd.y < 0. && ro.y + rd.y * dstObj < 0.) {
        dstWat = - ro.y / rd.y;
        waterRefl = (dstWat < min (dstObj, dstFar) && ro.y + rd.y * dstWat < 0.001);
      } else {
        dstWat = dstFar;
      }
#endif
    } else if (inEnv && ! inCave) {
#if ALL_PG || ! INCAVE
      dstWat = WaveRay (ro, rd);
      waterRefl = (dstWat < min (dstFar, dstObj));
#endif
    }
    if (waterRefl) {
      ro += dstWat * rd;
      row = ro;
#if ALL_PG || INCAVE
      if (inCave) vnw = VaryNf (0.2 * ro, vec3 (0., 1., 0.), 0.1);
#endif
#if ALL_PG || ! INCAVE
      if (! inCave) vnw = WaveNf (ro, dstWat);
#endif
      wkFac = WakeFac (row);
      if (wkFac > 0.) vnw = VaryNf (8. * row, vnw, 16. * wkFac);
      rd = reflect (rd, vnw);
      ro += 0.01 * rd;
      dstObj = ObjRay (ro, rd);
#if ALL_PG || INCAVE
      if (inCave) {
        dstCave = CaveRay (ro, rd);
        if (dstCave < min (dstObj, dstFar)) {
          dstObj = dstCave;
          idObj = idCav;
        }
      }
#endif
      if (bmOn) {
        rob[1] = ro;
        rdb[1] = rd;
      }
    }
    if (inEnv && inCave) {
#if ALL_PG || INCAVE
      if (dstObj < dstFar) {
        ro += dstObj * rd;
        ltVec = roo + ltPos - ro;
        s = length (ltVec);
        atten = (1. - smoothstep (0.1, 0.6, s / dstFar)) / (1. + 0.002 * pow (s, 1.5));
        ltVec /= s;
        if (idObj == idCav) {
          vn = CaveNf (ro);
          col4 = vec4 (mix (vec3 (0.55, 0.5, 0.5), vec3 (0.3, 0.4, 0.2),
             smoothstep (0.5, 0.8, vn.y)), 0.5);
          sh = min (CaveSShadow (ro, ltVec), CaveAO (ro, vn));
          vn = VaryNf (ro, vn, 12.);
        } else {
          vn = ObjNf (ro);
          col4 = NautColN (ro, vn);
          sh = ObjSShadow (ro, ltVec);
        }
        if (col4.a >= 0.) col = col4.rgb * sh * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +
           col4.a * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);
        else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));
        col = mix (col, bgCol, smoothstep (0.45, 0.99, dstObj / dstFar)) * atten;
      } else col = bgCol;
      if (waterRefl) col = mix (vec3 (0.1, 0.2, 0.3) * (0.2 + 0.8 * atten), col, 0.5);
#endif
    } else if (inEnv && ! inCave) {
#if ALL_PG || ! INCAVE
      if (dstObj < min (dstWat, dstFar)) {
        ro += dstObj * rd;
        vn = ObjNf (ro);
        col4 = NautColN (ro, vn);
        sh = isDark ? 1. : ObjSShadow (ro, sunDir);
        if (col4.a >= 0.) {
          col = col4.rgb * (0.3 + 0.2 * max (- dot (vn, sunDir), 0.) +
             0.7 * sh * max (dot (vn, sunDir), 0.)) +
             col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);
        } else {
          col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));
        }
      } else {
        col = SkyHrzCol (rd);
      }
      if (waterRefl) col *= 0.6;
      if (isDark) col *= 0.8;
#endif
    } else if (! inEnv) {
      if (dstObj < dstFar) {
        ro += dstObj * rd;
        vn = ObjNf (ro);
        col4 = NautColN (ro, vn);
        col4.rgb = vec3 (1.) * pow (Maxv3 (col4.rgb), 0.7);
#if ISBOOK
        col4.rgb *= vec3 (0.8, 0.8, 0.85);
#else
        col4.rgb *= mix (vec3 (0.8, 1., 1.), vec3 (1., 1., 0.8), - dot (vn, rd));
#endif
      if (col4.a < 0.) col4.a = 0.2;
        s = max (dot (vn, sunDir), 0.);
        col = col4.rgb * (0.2 + 0.8 * s * s) +
           2. * col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);
      } else {
        col = vec3 (0., 0., 0.5);
      }
    }
#if ALL_PG || ! UNWAT
    if (inEnv && waterRefl && wkFac > 0.) {
      s = Fbm3 (16. * row);
      if (inCave) col = mix (col, vec3 (0.7), 4. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));
      else col = mix (col, vec3 (0.9), 8. * wkFac * clamp (0.1 + 0.5 * s, 0., 1.));
    }
#endif
#if ALL_PG || ! UNWAT && ! INCAVE
    if (inEnv && waterRefl && ! inCave) {
      col = mix (col, vec3 (0.7), pow (clamp (2.8 * WaveHt (row.xz) +
         0.5 * Fbm3 (32. * row), 0., 1.), 8.));
    }
#endif
#endif
  }
  if (inEnv && bmOn) {
    lbDist = LBeamRay (rob[0], rdb[0]);
    if (unWat) {
#if ALL_PG || UNWAT
      vnb = LBeamNf (rob[0] + lbDist.x * rdb[0]);
      if (lbDist.x < min (dstObj, dstFar))
         col = mix (col, vec3 (1., 1., 1.), 0.5 * (1. - lbDist.y) * (0.7 - 0.3 * dot (vnb, rd)));
#endif
    }
    if (! unWat) {
#if ALL_PG || ! UNWAT
      if (lbDist.x < min (min (dstObjO, dstWat), dstFar))
         col = mix (col, vec3 (1., 1., 0.7), 0.7 * (1. - lbDist.y));
      if (waterRefl) {
        lbDist = LBeamRay (rob[1], rdb[1]);
        if (lbDist.x < min (min (dstObj, dstWat), dstFar))
           col = mix (col, vec3 (0.8, 1., 0.7), 0.4 * (1. - lbDist.y));
      }
#endif
    }
  }
  return pow (clamp (col, 0., 1.), vec3 (0.9));
}

// Function 2305
vec3 getSceneColor(vec2 uv)
{
    return texture(iChannel0, uv).rgb;
}

// Function 2306
float map(vec3 p)
{
    return min(min(box(p+vec3(+1.0,0.0,0.0)), cylinder(p+vec3(-1.0,0.0,0.0))), halfspace(p));
    //return min(min(box(p+vec3(+1.0,0.0,0.0)), sphere(p+vec3(-1.0,0.0,0.0))), halfspace(p));
    //return box(p);
}

// Function 2307
vec4 traceScene(in Camera cam, vec2 seed, float lastB) {
	vec3 startPos = cam.pos;
	vec4 result = vec4(0);

	int maxI = int(float(MAXRAYS) * lastB);
    float rayCount = 0.0;
    float t = iTime;// - iTimeDelta;
    
#ifdef FIXEDFRAMETIME
    float tStep = FRAMETIME / float(maxI);
#else
    float tStep = iTimeDelta / float(maxI);
#endif
	for (int i=0; i<MAXRAYS; i++) {
		if (i==maxI) break;
		Ray r = cam.ray;
        rayCount++;
        t += tStep;

        vec3 rr = (vec3(nrand(seed), nrand(seed.yx), nrand(seed.xx)) * 2. -1.) * divergence*2.0;
        r.dir += rr;
		r.dir = normalize(r.dir);
        
		vec4 impact = vec4(BRIGHTNESS);
		seed++;

		for (int j=0; j<MAXBOUNCES; j++) {
			SceneResult test = intersectScene(r, t);
#ifdef DEBUG
return vec4((test.dist)) / 100.0;
#endif
			if (test.col.a > 0.0) { 
				result += test.col * impact * test.col.a;
				break;
			}
				
			impact *= test.col;
                
			r.origin += r.dir * test.dist;
				
			r.origin += test.normal * 0.1;
                    
            vec3 rs = r.origin + seed.x;
			vec3 random = vec3(
				nrand(rs.xy),
				nrand(rs.yz),
				nrand(rs.zx)
			)*2. - 1.;
				
			float fresnel = clamp(dot(r.dir, test.normal)+1.0, 0., 1.0) * test.gloss;
			
			test.ref = mix(test.ref, 1.0, fresnel);
            
            vec3 matte = normalize(test.normal * SQRT2 + random);
            
			vec3 refl = reflect(r.dir, test.normal);
			vec3 newDir = mix(
				matte,
				refl,
				test.ref
			);
			float s = step(fresnel, nrand(seed));
			r.dir = //newDir;
				
			normalize(newDir * s + refl * (1.-s));
            
        }
    }
    return result / rayCount;// / (float(MAXRAYS));
}

// Function 2308
float dist(vec3 p){
    float sphere = distance(p, vec3(0, 0, 7)) -1.;
    float sphere2 = distance(p, vec3(.9, .4, 6.2)) - .5;
    float plane = p.y+1.;
    return min(plane,min(sphere,sphere2));
}

// Function 2309
float dstScene(vec3 p) {
 
    return dstJCVD(p, -1.);
    
}

// Function 2310
vec2 ConeDistances ( in Cone cone, in vec3 p, in vec3 v )
{
    // Convert to standard form A(d^2) + Bd + C = 0
    float t0 = v.z * cone.Zs;
    float t1 = cone.Zo + p.z*cone.Zs;
    float A = (v.x*v.x + v.y*v.y - t0*t0);
    float B = 2.0*(p.x*v.x + p.y*v.y - v.z*cone.Zs*t1);
    float C = (p.x*p.x + p.y*p.y - t1*t1);

	// Then solve, paying attention to numerical stability as shown in
	// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm
	// x1 = (-B-sgn(B)*sqrt(B^2-4AC))/2A
    // x2 = C/(Ax1)
    float discriminant = B*B-4.0*A*C;
	if ( discriminant < 0.0 )
    {
        return vec2(-1.0,-1.0);
    }
	float d1 = (-B-sign(B)*sqrt(discriminant))/(2.0*A);
    float d2 = C/(A*d1);
    vec2 res = vec2(d1, d2);
	return res;
}

// Function 2311
float colorDistAccurate(vec4 c1, vec4 c2){
	vec4 c = c1 - c2;
    float y = c.r * 0.2124681075446384 + c.g * 0.4169973963260294 + c.b * 0.08137907133969426;
  	float i = c.r * 0.3258860837850668 - c.g * 0.14992193838645426 - c.b * 0.17596414539861255;
  	float q = c.r * 0.0935501584120867 - c.g * 0.23119531908149002 + c.b * 0.13764516066940333;
  	return y*y + i*i + q*q;
}

// Function 2312
void renderScene(inout Ray primaryRay, out vec4 fragColor){
    const vec3 lightDir = normalize(vec3(1, 1, 1));
    const int max_depth = 10;
    
    fragColor = vec4(1.0);
    HitRecord hitRecord;    
    Ray ray = primaryRay;
    
    float attenuation = 1.0;
    float fuzzy = 0.1;
    
    for(int i = 0; i < max_depth; i++){

        vec4 pathColor;
        if(intersectScene(ray, pathColor, hitRecord) == false){
            //fragColor *= pathColor;
            break;
        }

        fragColor *= attenuation * pathColor;
        
        Ray nextRay;
             if(hitRecord.mat_id == 0)  {} // reserved for background material
        else if(hitRecord.mat_id == 1)  scatter_lambertian(ray, hitRecord, nextRay);
        else if(hitRecord.mat_id == 2)  scatter_metalic(ray, hitRecord, fuzzy, nextRay);
        else if(hitRecord.mat_id == 3)  scatter_dielectric(ray, hitRecord, 3.0, nextRay);
        ray = nextRay;
    }
}

// Function 2313
vec2 getDist(vec3 p)
{
    // input data
    vec3 pos1 = vec3(0.0);
    vec3 pos2 = vec3(0.0);
    pos1.xz = g_posVel1.xy;
    pos2.xz = g_posVel2.xy;

    vec3 posDelayed1 = vec3(0.0);
    vec3 posDelayed2 = vec3(0.0);
    posDelayed1.xz = g_data1.xy;
    posDelayed2.xz = g_data2.xy;

    // build characters
    vec2 dCharacter1 = buildCharacter(p, pos1 + START_POS_PL_1, 
                                      posDelayed1.xyz - pos1.xyz,
                                      g_special1,
                                      2.3,
                                      g_data1.w,
                                      BREATH_SPEED, 
                                      0.0, MAT_BODY_1, MAT_EYES_1, MAT_EYES_SOCKETS_1);

    vec2 dCharacter2 = buildCharacter(p, pos2 + START_POS_PL_2, 
                                      posDelayed2.xyz - pos2.xyz,
                                      g_special2,
                                      2.1,
                                      g_data2.w, 
                                      1.2 * BREATH_SPEED, 
                                      0.8, MAT_BODY_2, MAT_EYES_2, MAT_EYES_SOCKETS_2);
    
    // build scene
    vec2 dFinal = vec2(100000.0);
    dFinal = opSmoothUnionV2(dFinal, dCharacter1, 0.3);
    dFinal = opSmoothUnionV2(dFinal, dCharacter2, 0.3);
    
    vec2 dFloor = vec2(p.y, MAT_FLOOR);
    dFinal = opSmoothUnionV2(dFinal, dFloor, 0.0);//0.3);
    
    return dFinal;
}

// Function 2314
void addScene(inout vec3 col, vec3 c, float de, float width)
{
	col = mix(c, col, smoothstep(0.0, width, de));    
}

// Function 2315
float map( in vec3 pos ) {
    float d1 = shapeBall(pos);
    float d2 = shapeTable(pos);
    float d3 = shapeSupport(pos);
   
    return min( d1, min(d2, d3) );
}

// Function 2316
float map(vec3 p, inout object co)
{
    return min(findClosest(p, co, 32), p.z+0.5);
}

// Function 2317
vec3 TonemapFilmic_Hejl2015(vec3 hdr) 
{
    vec4 vh = vec4(hdr, TONEMAP_WHITE_POINT);
    vec4 va = 1.425 * vh + 0.05;
    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;
    return vf.rgb / vf.www;
}

// Function 2318
float decor_icon_dist(vec2 p, float sz, int style) {
    
    float s = sign(p.x*p.y);
    
    p = abs(p);
    
    vec2 a = vec2(0, sz);
    vec2 b = vec2(sz, 0);
    
    float l = dline(p, a, b);
    float c = length( p - (p.x > p.y ? b : a)*0.8 );
    
    if (style == 0) {
        return c - 0.2*sz;
    } else if (style == 1) {
        return abs(l + 0.04*sz) - 0.08*sz;
    } else if (style == 2) {
        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;
    } else {
        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);
        
    }
    
}

// Function 2319
vec2 map(vec3 pos)
{
    vec2 t = vec2(0.0,0.0);
    
    // ground
    t.x = pos.y;
    
    // poto
    vec3 potop = pos + vec3(2., -0.5, 3.0);
    potop = opRep(potop, vec3(4.0, 0.0, 6.0));
    float prep = sdCappedCylinder(potop, .5, .3);
    float pp = opI(prep, sdBox(pos+vec3(0.0), vec3(7.0, 5.0, 10.0)));
    vec2 poto = vec2(pp, 1.0);
    
    // *****
    // monster
    // head
    vec3 headp = pos + vec3(sin(iTime), -3., -5.0);
    float randShape = sin(pos.y*10.+iTime)*.05;
    vec3 headpFX = headp;
    headpFX.xz += randShape;
    float head = sdSphere(headpFX, 1.0);
    // eyes
    vec3 eyep = headp + vec3(0.5, -0.05, -1.0);
    eyep.y *= .5;
    float eye = sdSphere(eyep, .05);
    eyep = headp + vec3(-0.5, -0.05, -1.0);
    eyep.y *= .5;
    eye = opU(eye, sdSphere(eyep, .05));
    // legs
    int legpartnumber = 10;
    float legSize = .1;
    float legsmoothsize = .55;
    float leg1 = sdLeg(pos + vec3(2.0, -1.0, -9.0), headp+vec3(.5, .5,-.5), legpartnumber, legSize, legsmoothsize);
    float leg2 = sdLeg(pos + vec3(-2.0, -1.0, -9.0), headp+vec3(-.5,.5,-.5), legpartnumber, legSize, legsmoothsize);
    float leg3 = sdLeg(pos + vec3(2.0, -1.0, -3.0), headp+vec3(.5, .5,-.5), legpartnumber, legSize, legsmoothsize);
    float leg4 = sdLeg(pos + vec3(-2.0, -1.0, -3.0), headp+vec3(-.5,.5,-.5), legpartnumber, legSize, legsmoothsize);
    
    vec2 monster = vec2(head, 2.0);
    vec2 eyes = vec2(eye, 3.0);
    vec2 legs1 = vec2(leg1, 2.0);
    vec2 legs2 = vec2(leg2, 2.0);
    vec2 legs3 = vec2(leg3, 2.0);
    vec2 legs4 = vec2(leg4, 2.0);
    
    // merge
    t = opU2(t, poto);
    t = opU2(t, monster);
    t = opU2(t, eyes);
    t = opU2(t, legs1);
    t = opU2(t, legs2);
    t = opU2(t, legs3);
    t = opU2(t, legs4);
    
    return t;
}

// Function 2320
float mapBetweenSpheres(in Sphere s1, in Sphere s2, in vec3 p)
{
	return abs((length(p - s1.position) - s1.radius)-(length(p - s2.position) - s2.radius)) - 0.5;   
}

// Function 2321
float sdf(vec3 p, bool detail)
{
    p.y -= 0.15;
    
    float radius = 1.3;
    
    // Early out
    if(p.y > 0.0)
	    return 10.0;
    
    if(detail)
    {
        radius -= pattern(p + vec3(0.0, 0.15, 0.0)).z * .02;
    }
    
    // A bit squashed
    float core = length(p*vec3(1.0, 1.05, 1.0)) - radius;
    
    return min(core, scaffold(p));
}

// Function 2322
float distf(vec3 p)
{
	float d = 100000.0;
	
	fUnion(d, pRoundBox(vec3(0,0,10) + p, vec3(11,11,1), 1.0));
	fUnion(d, pRoundBox(vec3(0,0,-2) + p, vec3(5,5,12), 1.0));
	fUnion(d, pSphere(vec3(10,10,0) + p, 8.0));
	fUnion(d, pTorus(vec3(-10,-12,0) + p, vec2(9,5)));
	fUnion(d, pCapsule(p, vec3(-15,15,10), vec3(15,-15,-5), 1.5));
	fUnion(d, -pSphere(p, 80.0));
	
	return d;
}

// Function 2323
float dist_box( vec3 pos, vec3 size ) {
    
	return length( max( abs( pos ) - size, 0.0 ) );
}

// Function 2324
vec3 sdFish( vec3 p )
{
    vec3 res = vec3( 1000.0, 0.0, 0.0 );

	p -= fishPos;
	
	if( dot(p,p)>16.0 ) return vec3(5.0);

	p *= vec3(1.2,0.8,1.2);
	vec3 q = p;
	
    vec3 a = vec3(0.0,0.0,0.0);
	
    
    a.x -= 0.25*sin(8.0*0.2*fishTime);
	vec3 oa = a;

	float or = 0.0;
	float th = 0.0;
	float hm = 0.0;

	#define NUMI 7
	#define NUMF 7.0
	vec3 p1 = a; vec3 d1=vec3(0.0);
	vec3 p2 = a; vec3 d2=vec3(0.0);
	vec3 mp = a;
	for( int i=0; i<NUMI; i++ )
	{	
		float ih = float(i)/NUMF;
		
		float an = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fishTime);
		float ll = 0.26;
		if( i==(NUMI-1) ) ll=0.4;
		vec3 b = a + ll*vec3(sin(an), 0.0, cos(an))*(16.0/NUMF);
		
		vec2 dis = sd2Segment( a, b, p );

		if( dis.x<res.x ) {res=vec3(dis.x,ih+dis.y/NUMF,0.0); mp=a+(b-a)*dis.y; }
		
		if( i==1 ) { p1=a; d1 = b-a; }
		
		a = b;
	}
	float h = res.y;
	float ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;

	// tail
	p.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));
    p.z += 0.08*(1.0-clamp(abs(p.y)/0.075,0.0,1.0))*(1.0-smoothstep( 0.0,0.1,1.0-h));
	res.x = 0.75 * (distance(p,mp) - ra);
	
	// mouth
	float d3 = 0.75*(length( (p - oa)*vec3(0.5,2.0,1.0) )-0.12);
	res.x = max( -d3, res.x );
	
	// upper central fin
	float fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);
	fh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;
	d3 = length(p.xz-mp.xz) - 0.01;
    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );
	d3 = max( d3, -p.y - 0.0 );
	res.x = min( res.x, d3 );
	
	// fins
	d1.xz = normalize(d1.xz);

	float flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fishTime);
    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));
	mat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );
	vec3 sq = p-p1;
	sq.xz = mm*sq.xz;
	sq.y += 0.2;
	sq.x += -0.15;
	float d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;
	d = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );
    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );
	res.x = smin( d, res.x, 0.05 );

	sq = p-p1;
	sq.xz = mm*sq.xz;
	sq.y += 0.2;
	sq.x += 0.15;
	d = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;
	d = 0.5*max( d, sdBox( sq, vec3(1.0,1.0,0.01) ) );
    if( d<res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );
	res.x = smin( d, res.x, 0.05 );

	return res;

}

// Function 2325
vec2 map( vec3 p )
{
	vec3 op = p;
	{
	float an = 0.35;
	float co = cos( an );
	float si = sin( an );
	mat2  ma = mat2( co, -si, si, co );
	p.xy = ma*p.xy;
	}
	
	p.y -= 4.0;

    float d = length( (p-vec3(0.0,-0.1,0.0))*vec3(1.0,3.0,1.0)) - 0.4;
	vec2 res = vec2( d/3.0, 1.0 );
	

	if( p.y>0.0 )
	{

	// palito
	vec3 pp = p;
		
		//vec3 q = p - vec3(0.0,-0.25,0.0);
		vec3 q = (p-vec3(0.0,-0.15,0.0))*vec3(1.0,1.5,1.0);
		pp.y = length(q);
		#if 1
		pp.x = 0.35*0.5*atan( q.x, q.z );
		pp.z = 0.35*acos( q.y/length(q) );
		#else
		//pp.xz *= 1.0 + 2.0*length(p.xz)/(0.5+p.y);
		pp.xz -= normalize(pp.xz) * p.y * 0.5;
		
		#endif
	
	pp.xz = (mod(20.0*(pp.xz+0.5),1.0) - 0.5)/20.0;
	
		
		float hh = 0.0;
	vec2 h = sdSegment( vec3(0,0.0,0.0), vec3(0.0,0.5+hh,0.0), pp );
	float sr = 0.01 + 0.001*smoothstep( 0.9,0.99,h.y );
	d = h.x - sr;
	d *= 0.5;
	res.x = smin( d, res.x );
	}

	p.xz = abs(p.xz);

	
	for( int i=0; i<4; i++ )
	{
		float an = 6.2831*float(i)/14.0;
		float id = an;
		float co = cos( an );
		float si = sin( an );
		mat2  ma = mat2( co, -si, si, co );

		vec2  r = ma*p.xz;//-vec2(1.0,0.0));
		vec3  q = vec3( r.x, p.y, r.y );

		an = 0.02*sin(10.0*an);

		co = cos(0.2+an);
		si = sin(0.2+an);
		q.xy = mat2( co, -si, si, co )*q.xy;

		float ss = 1.0 + 0.1*sin(171.0*an);
		q.x *= ss;
		q.x -= 1.0;
		q.y -= 0.15*q.x*(1.0-q.x);
		
        float ra = 1.0 - 0.3*sin(1.57*q.x);
		d = 0.05*(length( q*vec3(1.0,20.0,4.0*ra) ) - 1.0*0.8);
		
        if( d<res.x ) res = vec2( d, 2.0 );
	}
	
	{
    p = op;	
	float an = 0.35*clamp( p.y/3.8, 0.0, 1.0 );
	float co = cos( an );
	float si = sin( an );
	mat2  ma = mat2( co, -si, si, co );
	p.xy = ma*p.xy;

	vec2 h = sdSegment( vec3(0,0.0,0.0), vec3(0.0,4.0-0.2,0.0), p );
	d = h.x - 0.07;
    if( d<res.x ) res = vec2( d, 3.0 );
	}

	return res;
}

// Function 2326
float heightMap(vec3 p){
    
    id =0;
    float c = Voronoi(p.xy*4.); // The fiery bit.
    
    // For lower values, reverse the surface direction, smooth, then
    // give it an ID value of one. Ie: this is the black web-like
    // portion of the surface.
    if (c<.07) {c = smoothstep(0.7, 1., 1.-c)*.2; id = 1; }

    return c;
}

// Function 2327
Hit intersectScene(Ray r)
{
    vec3 axis1 = randomVector(floor(iTime));
    vec3 axis2 = randomVector(floor(iTime+1.));
    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));
    float translation = 4.*abs(2.*fract(iTime/8.)-1.) - 2.;

    Sphere s = Sphere(1., vec3(1., 1., 0.), Material(vec3(0.5), 0.04));
    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.5, 0.4, 0.3), 0.04));
    Cone c = Cone(0.95, 2., vec3(translation, 2., 1.), -axis, Material(vec3(1., 0., 0.), 0.02));

    Hit hit = noHit;
    compare(hit, intersectPlane(p, r));
    compare(hit, intersectSphere(s, r));
    compare(hit, intersectCone(c, r));
    return hit;
}

// Function 2328
vec2 nmapu(vec2 x){ return x*.5+.5; }

// Function 2329
int maptmp(int id, int midg) {
    if (!once_AA)retv_AA = maptmpAA(id, midg);
    once_AA = true;
    return retv_AA;
}

// Function 2330
float sdfIntersection( float d1, float d2 ) { return max(d1,d2); }

// Function 2331
vec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf){
   
    const vec2 e = vec2(0.001, 0);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
    
}

// Function 2332
vec3 makeScene(vec3 rayOr,vec3 rayDir, vec3 sphPos) {
   
  
    Primitive sph1, plane1, sph2, sph3, sph4, sph5; //Spheres
    sph3.size = .18;  //setting sphere size
    sph3.pos =sphPos + vec3(0., 0., sph3.size);	//sphere position
    
    sph1.size = .08;
    sph1.pos = vec3(sph3.pos.x-(sph1.size+sph3.size)*1.02,sph3.pos.y, sph1.size-.001);
    sph2.size =.18;
    sph2.pos = vec3(sph3.pos.x+(sph3.size+sph2.size)*1.02,sph3.pos.y, sph3.size-.001);
    sph1.specular = sph2.specular = sph3.specular = .5;    //specular reflection values for spheres
    
    plane1.pos = vec3(vec2(sph3.pos.xy), sph1.pos.z - sph1.size+.005); //plane position
    plane1.normal = normalize(vec3(0., 0., .1)); //plane surface normal
    plane1.size = 1.;  //plane's side length
    
    Primitive prims[NUM_PRIMS];
    
    prims[0] = plane1; //adding primitives into an array
    prims[1] = sph1;
    prims[2] = sph2;
    prims[3] = sph3;    
    //prims[4] = sph4;
    //prims[5] = sph5;
       
    
  
    Primitive rayPrim = processRayIntersect(rayOr, rayDir, prims, 0.); //perform camera ray intersection check on all primitives
																	   //rayPrim is the primitive that was first intersected by the
																	   //camera ray
    Light lights[NUM_LIGHTS]; //lights array
    lights[0].pos = vec3(sph2.pos.x, sph2.pos.y+.9, .9);//pos of light1;
    lights[0].col = vec3(.1, .4, .2)*2.; //set light color
    lights[1].pos =  vec3(-.8, .3, .4);
    lights[1].col = vec3(.4, .1, .1)*3.;
    lights[2].pos = vec3(1.8, .2, .5);
    lights[2].col = vec3(.2, .1, .4)*4.;
    lights[3].pos = vec3(.5, .2, 7.2);
    lights[3].col = vec3(.3, .3, .8);
    Primitive lightPrim;
    vec3 finalCol = vec3(0.,0.,0.); //initialize final pixel color to zero vector
    vec3 lRefl;	//
    float str;
    for(int i=0;i<NUM_LIGHTS;i++) {
        lightPrim = processRayIntersect(lights[i].pos
                        , normalize(rayPrim.intersecPoint - lights[i].pos), prims, .001); //check if a light ray from this light
														//reaches the point intersected by the camera ray and set lightPrim
														//as the primitive first intersected by the light ray
        if(lightPrim.id == plane1.id) { //if the light ray towards the primitive intersection point intersects the plane
										
        finalCol+= lightPrim.id==rayPrim.id?max(dot(rayPrim.normal //if the ray from the light and the ray from the camera intersect																	
               , normalize( -(rayPrim.intersecPoint) + lights[i].pos))	//the aame primitive, calculate diffuse shading color value for the
               *lights[i].col*.4, 0.):vec3(0., 0., 0.);					//current light and add it to the pixel color
            
        }
        else { //if the light ray didn't intersect the plane
        lRefl = reflect(rayPrim.intersecPoint - lights[i].pos //calculate the reflection vector at the intersected surface
                            , rayPrim.normal);				  //point for the light ray
        str = max((-1.*dot(normalize(lRefl), rayDir)-rayPrim.specular), 0.0) *5.; //calculate specular reflection value
																				  //for the light ray
												
        finalCol += mix(finalCol,                  //if the light ray and the camera ray hit the same point,		
                       lightPrim.id==rayPrim.id?   //add the light value vector to the final pixel color
                        str*lights[i].col		   //else add a zero vector
            :vec3(0., 0., 0.)
                        , .9 );
       }
    }

    
    return finalCol;	//return the final pixel color
    
    
}

// Function 2333
float mapLeafWaterDrops( in vec3 p )
{
    p -= vec3(-1.8,0.6,-0.75);
    vec3 s = p;
    p = mat3(0.671212, 0.366685, -0.644218,
            -0.479426, 0.877583,  0.000000,
             0.565354, 0.308854,  0.764842)*p;
  
    vec3 q = p;
    p.y += 0.2*exp(-abs(2.0*p.z) );
    
    //---------------
    
    float r = clamp((p.x+2.0)/4.0,0.0,1.0);
    r = r*(1.0-r)*(1.0-r)*6.0;
    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );
    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );
    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );
    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );
    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );

    d3 = max( d3, p.y-0.01);
    
    float d = min( min(d1,d4), min(d2,d3) );
    
    return d;
}

// Function 2334
float simpleBitmap(float data, vec2 s, vec2 bitCoord) {
    // 0..1.0
    float x = floor(bitCoord.x * s.x);
    float y = floor(bitCoord.y * s.y);
     
    float i = y * s.x + x;
    
    float datum = float(data) / pow(2.0, i);

    datum = mod(datum, 2.0);
        
    return floor(datum);
}

// Function 2335
float Scene(vec3 p)
{
    float d = MAX_DIST;
    
    vec3 pm = vec3(mod(p.xy, vec2(QUAD_SIZE)), p.z);
    
    vec2 uv = floor(p.xy / QUAD_SIZE);
    
    float v0 = Height(uv + vec2(0, 0));
    float v1 = Height(uv + vec2(0, 1));
    float v2 = Height(uv + vec2(1, 1));
    float v3 = Height(uv + vec2(1, 0));
    
    d = sdVQuad(pm - vec3(0.0 ,0.0, 0.0), v0, v1, v2, v3);
    
    d = opU(d, -sdSphere(p, MAX_DIST - 1.0));
    
	return d;
}

// Function 2336
float sdf_quarter3_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(pos.y, -pos.x));
}

// Function 2337
vec4 save_map() {
    int exidx = index_idx();
#ifdef debug
    //show that pixels on "screen edge" is okey (where pixel line go to next line on heigh)
    if (exidx >= int(iResolution.x) / 3)if (((exidx) % (int(iResolution.x) / 3)) == 0)return vec4(0xffffff);
#endif
    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;
    vec4 retc = vec4(0.);
    for (int i = 0 + alp; i < 4; i++) {
        ivec3 packme = ivec3(bits2Int(imidx * 4 * 24 + i * 24), bits2Int(imidx * 4 * 24 + i * 24 + 8), bits2Int(imidx * 4 * 24 + i * 24 + 16));
        retc[i] = float(encodeval16(packme));
    }
    return retc;
}

// Function 2338
float calcDist( vec3 pos )
{    
    float dist = 1e9;
    
    dist = min( dist, sdRoundedIcosahedron ( pos - vec3(0.,0.,3.), 0.6, 0.6 ) );
    dist = min( dist, sdIcosahedronEdges   ( pos - vec3(3.,0.,3.), 1.0, 0.1 ) );
    dist = min( dist, sdRoundedDodecahedron( pos - vec3(0.,0.,0.), 0.6, 0.6 ) );
    dist = min( dist, sdDodecahedronEdges  ( pos - vec3(3.,0.,0.), 1.0, 0.1 ) );
        
    // sphere at vertex, edge center, face center
    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B))							   , 0.15 ) );
    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B)*.5 + vec3(B,0,A)*.5)		   , 0.07 ) );
    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(3.,-3.,0) ) - (vec3(0,A,B)*(1./3.) + vec3(0,0,A)*(2./3.)), 0.03 ) );
            
    // morph between an icosahedron and dodecahedron
    // (just move a sphere from the icosahedron vertex to middle of the face)
    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(0,-3.,0) ) - mix(ICOVERTEX, ICOMIDFACE, sin(iTime)*.5+.5), 0.10 ) );    
    
    //// soccer ball vertices (truncated icosahedron)
    dist = min( dist, sdSphere( opIcosahedron( pos - vec3(0,-3.,3.) ) - mix(ICOVERTEX, ICOMIDEDGE, .66), 0.10 ) );    

    //// 20 dodecahedrons arranged at dodecahedron vertices:
    //dist = sdRoundedDodecahedron( opIcosahedron( pos ) - ICOMIDFACE*3., 0.5, 0.3 );
        
    //// 12 icosahedrons arranged at icosahedron vertices:
    //dist = sdRoundedIcosahedron( opIcosahedron( pos ) - ICOVERTEX*2., 0.5, 0.3 );
    
    ////12 sets of 12 icosahedrons
    //dist = sdRoundedIcosahedron( opIcosahedron( opIcosahedron( pos ) - ICOVERTEX*2.6 ) - ICOVERTEX*.6, 0.15, 0.1 );   
        
    //12 sets of 12 sets of 12 icosahedrons
    if ( iMouse.w > 0. )
    {
        vec2 m = iMouse.xy/iResolution.xy;
    	dist = sdRoundedIcosahedron( opIcosahedron( opIcosahedron( opIcosahedron( pos ) - ICOVERTEX*12.*m.y ) - ICOVERTEX*5.*m.x ) - ICOVERTEX*.4, 0.1, 0.16 );   
    }

    return dist;
}

// Function 2339
vec3 map(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// Function 2340
float map( in vec3 pos, float time )
{
    // take a 3D slice
    vec4 p = vec4(pos,0.5*sin(time*0.513));
    
    // rotate 3D point into 4D
	vec4 q1 = normalize( cos( 0.2*time*vec4(1.0,1.7,1.1,1.5) + vec4(0.0,1.0,5.0,4.0) ) );
	vec4 q2 = normalize( cos( 0.2*time*vec4(1.9,1.7,1.4,1.3) + vec4(3.0,2.0,6.0,5.0) ) );
    p = q2m(q2)*p*q2m(q1);
    
    // 4D box
    return sdBox( p, vec4(0.8,0.5,0.7,0.2) )- 0.03;
}

// Function 2341
SDObject SDOMap(in SDObject o,vec3 p)
{
  //  o.ray=ray;
  //  o.ray.ro+=o.pos;
    //o.d=iSphere(o.ray.ro,o.ray.rd);
    o.d=sdSphere(o.mpos=p-o.pos,1.);
    return o;
}

// Function 2342
float Scene(vec3 position)
{
    float map = -Sphere(24.0, position);
    
    float animTime = mod(iTime, 10.0);
    
    float xScale = smoothstep(1.0, 1.5, animTime) - smoothstep(6.0, 6.5, animTime);  
    float zScale = smoothstep(2.0, 2.5, animTime) - smoothstep(7.0, 7.5, animTime);
    float yScale = smoothstep(3.0, 3.5, animTime) - smoothstep(8.0, 8.5, animTime);
    
    for(int i = -1; i <= 1;i++)
    {
        for(int j = -1; j <= 1;j++)
        {
            for(int k = -1; k <= 1;k++)
            {
                vec3 offset = vec3(i,j,k) * 2.0;
                
                offset.x *= 1.0 + xScale;
                offset.y *= 1.0 + yScale;
                offset.z *= 1.0 + zScale;
                
    			map = Union(map, Box(1.0, position + offset));
        	}
        }
    }
    
    return map;
}

// Function 2343
vec3 mapMoss( in vec3 pos, float h, vec3 cur)
{
    vec3 res = cur;

    float db = pos.y-2.2;
    if( db<res.x )
    {
    const float gf = 2.0;
    
    vec3 qos = pos * gf;
    vec2 n = floor( qos.xz );
    vec2 f = fract( qos.xz );

    for( int k=ZERO; k<2; k++ )
    {
        for( int j=-1; j<=1; j++ )
        for( int i=-1; i<=1; i++ )
        {
            vec2  g = vec2( float(i), float(j) );
            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));
            vec2  r = g - f + o;

            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );
            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );

            float mh = 0.5 + 1.0*ra2.y;
            vec3 ros = qos - vec3(0.0,h*gf,0.0);

            vec3 rr = vec3(r.x,ros.y,r.y);

            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );

            rr.xz += 0.5*(-1.0+2.0*ra2);
            vec2 se  = sdLineOriY( rr, gf*mh );
            float sey = se.y;
            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));

            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);

            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );
            float cc = cos(an);
            float ss = sin(an);
            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;

            pp.xz = abs(pp.xz);
            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; 
            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );
            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;
            float d2 = se2.x - (0.02 + 0.03*se2.y);

            d2 = max( d2, (rr.y-0.83*gf*mh) );
            d = smin( d, d2, 0.05 );

            d /= gf;
            d *= 0.9;
            if( d<res.x )
            {
                res.x = d;
                res.y = MAT_MOSS;
                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);
                float e = clamp((pos.y - h)/1.0,0.0,1.0);
                res.z *= 0.02 + 0.98*e*e;
                
                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;
            }
        }
    }

    }
    
    return res;
}

// Function 2344
float distanceField(in vec3 p) 
{
  	float s = 8.; // spacing
  	float d = cos(p.x*0.05);
  	float rs = 0.25 * iTime+ d; // rotating speed
  	vec2 pos; // yz
  
  	float a = rs+d;  
  	pos = s*vec2( sin(a) , cos(a));

  	float r = 2.5;
  	float res;
	
  	// a simple cylinder would go like this :  length(p.yz+pos)-r  
  	// here is 4 cylinders with displacements :

  	float ssf =  ss(0.,1.,p.y*2.) * sin(p.x+iTime);
  	float w = fbm(p)*2.;

  	res = 
		( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;

  	a = rs+PI*1.0+d;
  	pos = s*vec2(sin(a),cos(a));
  	float res2 =
	  	( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;
	
	a = rs+PI*0.50+d;
  	pos = s*vec2(sin(a),cos(a));
  	float res3 =
		( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;
	
  	a = rs+PI*1.50+d;
  	pos = s*vec2(sin(a),cos(a));
  	float res4 =
		( length(p.yz+pos+w*0.3*abs(p.x/10.)+sin(p.x/2.+iTime))-r ) - ssf;

  	res = min(res,res4);
  	res = min(res,res3);
  	res = min(res,res2);
  	return res;
}

// Function 2345
SceneResult Scene_GetDistance( vec3 vPos )
{
    SceneResult result;
    
	//result.fDist = vPos.y;
    float fBenchBevel = 0.01;
    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );
    result.vUVW = vPos;
	result.iObjectId = MAT_DEFAULT;        
    
    vec3 vSetPos = vec3(0.0, 0.0, 0.0);
    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);
    
    //vPos.x = fract( vPos.x - 0.5) - 0.5;
    
    vec2 vScreenWH = vec2(4.0, 3.0) / 25.0;

    SceneResult resultSet;
    resultSet.vUVW = vPos.xzy;
	resultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );
    resultSet.iObjectId = MAT_TV_CASING;
    Scene_Union( result, resultSet );

    SceneResult resultSetRecess;
    resultSetRecess.vUVW = vPos.xzy;
    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );
    resultSetRecess.iObjectId = MAT_TV_TRIM;
	Scene_Subtract( result, resultSetRecess );
    
    SceneResult resultSetBase;
    resultSetBase.vUVW = vPos.xzy;
    float fBaseBevel = 0.03;
	resultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );
    resultSetBase.iObjectId = MAT_TV_CASING;
    Scene_Union( result, resultSetBase );

	SceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );
    Scene_Union( result, resultScreen );    
    
    //SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );
    //Scene_Union( result, resultComputer );

    SceneResult resultSphere;
    resultSet.vUVW = vPos.xzy;
	resultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;
    resultSet.iObjectId = MAT_CHROME;
    Scene_Union( result, resultSet );    
    
    return result;
}

// Function 2346
vec2 map( in vec3 p )
{
    vec4 z = vec4( p, 0.0 );
    float dz2 = 1.0;
	float m2  = 0.0;
    float n   = 0.0;
    #ifdef TRAPS
    float o   = 1e10;
    #endif
    
    for( int i=0; i<kNumIte; i++ ) 
	{
        // z' = 3z -> |z'| = 9|z|
		dz2 *= 9.0*qLength2(qSquare(z));
        
        // z = z + c		
		z = qCube( z ) + kC;
        
        // stop under divergence		
        m2 = qLength2(z);		

        // orbit trapping : https://iquilezles.org/www/articles/orbittraps3d/orbittraps3d.htm
        #ifdef TRAPS
        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );
        #endif
        
        // exit condition
        if( m2>256.0 ) break;				 
		n += 1.0;
	}
   
	// sdf(z) = log|z||z|/|dz| : https://iquilezles.org/www/articles/distancefractals/distancefractals.htm
	float d = 0.25*log(m2)*sqrt(m2/dz2);
    
    #ifdef TRAPS
    d = min(o,d);
    #endif
    #ifdef CUT
    d = max(d, p.y);
    #endif
    
	return vec2(d,n);        
}

// Function 2347
vec2 scene_pyramid(vec3 _p, float h)
{
    float htop = h*.25;
    float topPy = sdOctahedron(_p-vec3(0., h-htop*.8, 0.), htop);
    _p.y = 0.5*floor(2.*_p.y);
    float d = sdOctahedron(_p, h);
    return scene_min(vec2(d, MATERIAL_PYRAMID), vec2(topPy, MATERIAL_GOLD));
}

// Function 2348
float BaubleBoundsSDF( vec3 pos )
{
    return abs(TreeBoundsSDF(pos))-.3; // half the width of the area bauble centres can be placed in
}

// Function 2349
float sphereSDF(vec3 p, float radius) {
    return length(p) - radius;
}

// Function 2350
vec3 ToneMap(in vec3 c, float maxc)
{
#if HDR_DETECTOR
    if (c.r > maxc || c.g > maxc || c.b > maxc) {
    	return vec3(1.0, 0.0, 0.0);
    } else if (c.r < 0.0 || c.g < 0.0 || c.b < 0.0) {
    	return vec3(0.0, 1.0, 0.0);
    }
#endif
   	float v = max(c.r, max(c.g, c.b));
    return c / (1.0 + v / maxc);
}

// Function 2351
float scene(vec3 p){
    return sphereCopies(p);
}

// Function 2352
SceneResult SceneResult_Union( SceneResult a, SceneResult b )
{
    if ( b.fDist < a.fDist )
    {
        return b;
    }
    return a;
}

// Function 2353
float planeSdf(vec3 p, float planeOffset)
{
    return length(p.z) - planeOffset;
}

// Function 2354
maybe_vec2 get_distances_along_line_to_intersection(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.f;
    float y  = shape1.exists && shape2.exists ? min(shape1.value.y,  shape2.value.y ) : 0.f;
    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);
}

// Function 2355
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {
    if (iFrame > 1) discard;
    fragColor -= fragColor;
    fragColor.x = height(rayDir);
    fragColor.gba = normal(rayDir);
}

// Function 2356
float map (vec3 p) {
	return dist(p, s3d(iChannel1,p));
}

// Function 2357
vec3 GetEnvMapF(vec3 rayDir) {
    // Make sure this texture is set to the "Forest" cubemap.
    vec3 tex = texture(iChannel1, rayDir).xyz;
    tex = tex * tex;  // gamma correct - gamma 2.0
	// Make light come from the +z, -x corner. That's what it looks like is happening in the pic.
    // Yellowish sunset color.
    vec3 light = vec3(1.0, 0.7, 0.5)*((rayDir.z-rayDir.x)*0.3536+0.5);
    vec3 texp = pow(tex, vec3(14.0));
    light *= texp;  // Masked into the existing texture's sky
    return (tex + light*3.0);
}

// Function 2358
float distribution(vec3 n, vec3 h, float roughness){
    float a_2 = roughness*roughness;
	return a_2/(PI*pow(pow(dot_c(n, h), 2.0) * (a_2 - 1.0) + 1.0, 2.0));
}

// Function 2359
float unionSDF(float distA, float distB) {
    float k = .5;
    return smin(distA, distB, k);
}

// Function 2360
float NormalDistributionRand( inout uint seed )
{
    // https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform
    
    float U1 = FRand(seed);
    float U2 = FRand(seed);
    
    return sqrt( -2.0 * log( U1 ) ) * cos( TAU * U2 );
}

// Function 2361
float dista(vec3 ro, vec3 rd, vec3 p) {
	return length(cross(p-ro,rd));
}

// Function 2362
vec2 map(vec3 p) {
    p.y += 1.0;
	vec2 res = vec2(sdPlane(p), M_FLOOR);
	p.y -= AppleRadius;
    

	vec2 obj = vec2(sdApple(p, AppleRadius), M_APPLE);
	res = min2(res, obj);

	return res;
}

// Function 2363
float remappedNoise(in vec3 p){
	return .5 + .5 * (noise(p)/.6);
}

// Function 2364
float map(vec3 p) {
  
  p = rep(p, 80.0);
  
  float t=time*0.3 + 95.0;
  
  vec3 p1 = kifs(p, t * 0.1, t);
  vec3 p2 = kifs(p+vec3(2,0,0), t * 0.13+37.241, t);
  vec3 p3 = kifs(p+vec3(0,2,0), t * 0.17+27.74, t);
  
  float d1 = box(p1, vec3(5,3,7));
  float d2 = min(box(p2, vec3(5,10,2)), length(p2.xy)-1.0);
  float d3 = box(p3, vec3(5,2,3));
  
  
  d1 = abs(d1-9.0)-12.0;
  d1 = abs(d1)-1.5;
  
  d2 = abs(d2-8.0)-12.0;
  d2 = abs(d2)-2.0;
  
  
  //float d = length(vec2(d1,d2))-1.0;
  float d4 = max(abs(d1)-0.2,abs(d2)-0.7);
  float d5 = max(abs(d2)-0.2,abs(d3)-0.6);
  
  vec3 p4 = rep(p2, 1.0);
  float d6 = box(p4, vec3(0.4));
  
  float h=sin(p.x*0.1)*0.5 + sin(p.y*0.3)*0.7 + sin(p.z*0.7);
  
  /*
  d4 -= min(0,d6*h*0.7);
  d5 += d6*h*0.6;
  */
  float d7 = max(d4, d5)-0.1;
  d4 = smin(d4, d6*h*2.0, -0.5);
  d5 = smin(d5, -d6*h*1.0-0.5, -1.5);
  d5 = min(d5, d7);
    
  //d = min(d,d1+0.5);
  //d = min(d,d2+0.5);
  
  float d = min(d4, d5);
  //d *= 0.6;
  return d;
}

// Function 2365
vec4 EuclidDist(vec3 c, vec3[NUM_COLORS] pal)
{
    int idx = 0;
    float nd = distance(c, pal[0]);

    for(int i = 1; i < NUM_COLORS; i++)
    {
        float d = distance(c, pal[i]);
        
        if(d < nd)
        {
            nd = d;
            idx = i;
        }
    }

    // older GPUs/drivers require constant array indexing, so can't use idx directly
    if(idx == 0)  return vec4(pal[0], 1.);
    if(idx == 1)  return vec4(pal[1], 1.);
    if(idx == 2)  return vec4(pal[2], 1.);
    if(idx == 3)  return vec4(pal[3], 1.);
    if(idx == 4)  return vec4(pal[4], 1.);
    if(idx == 5)  return vec4(pal[5], 1.);
    if(idx == 6)  return vec4(pal[6], 1.);
    if(idx == 7)  return vec4(pal[7], 1.);
    if(idx == 8)  return vec4(pal[8], 1.);
    if(idx == 9)  return vec4(pal[9], 1.);
    if(idx == 10) return vec4(pal[10], 1.);
    if(idx == 11) return vec4(pal[11], 1.);
    if(idx == 12) return vec4(pal[12], 1.);
    if(idx == 13) return vec4(pal[13], 1.);
    if(idx == 14) return vec4(pal[14], 1.);
    return vec4(pal[15], 1.);

    // sleek but not guaranteed to work on older GPUs!
    //return vec4(pal[idx], 1.);
}

// Function 2366
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = sceneSDF(eye + depth * marchingDirection);
        if (dist < EPSILON) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 2367
float minkowskiDistance(vec3 p1, vec3 p2, float power) {
	float d1 = pow(abs(p1.x - p2.x), power);
	float d2 = pow(abs(p1.y - p2.y), power);
	float d3 = pow(abs(p1.z - p2.z), power);
	return pow(d1 + d2 + d3, 1.0 / power);
}

// Function 2368
float map(vec3 p){
    return p.y*0.07 + (fbm(p*0.3)-0.1) + sin(p.x*0.24 + sin(p.z*.01)*7.)*0.22+0.15 + sin(p.z*0.08)*0.05;
}

// Function 2369
float sdFloorA (vec3 p){
    return p.y;
}

// Function 2370
Distance distance(vec3 p)
{   
    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); 
    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); 
    
    d = add(d, Distance(box(p - vec3(0.0, 0.32, 0.0), vec3(0.36, 0.02, 0.36)), vec3(0.2, 0.3, 0.6))); 
    
    return d;
}

// Function 2371
vec3 bumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)
{
    const vec2 e = vec2(0.001, 0);
    
    mat3 m = mat3( triPlanarProj(tx, p - e.xyy, n), triPlanarProj(tx, p - e.yxy, n), triPlanarProj(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m;
    g = (g - dot(triPlanarProj(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf );
    
}

// Function 2372
SDFRes blendSDF(SDFRes f1, SDFRes f2, float k)
{
    // Branching a lot :( Needs more work
    
   	SDFRes closest  = f1;
    SDFRes furthest = f2;
	
	float diff = float(f1.d > f2.d);
    
	closest.d =  mix(f1.d, f2.d,   diff);
	closest.m =  mix(f1.m, f2.m,   diff);
	closest.m2 = mix(f1.m2, f2.m2, diff);
	closest.b =  mix(f1.b, f2.b,   diff);
	
	furthest.d =  mix(f2.d, f1.d,   diff);
	furthest.m =  mix(f2.m, f1.m,   diff);
	furthest.m2 = mix(f2.m2, f1.m2, diff);
	furthest.b =  mix(f2.b, f1.b,   diff);
    
	// Dominant materials
	float mf1 = mix(closest.m2, closest.m, float(closest.b < 0.5));
	float mf2 = mix(furthest.m2, furthest.m, float(furthest.b < 0.5));
    
    // New distance
    float t  = smin(f1.d, f2.d, k);
    
    // New blend
    float bnew = getBlend(f1.d, f2.d);
    float b = max(closest.b, bnew);
    float bhigher = float(b > bnew);

	float m  = mix(mf1, closest.m,  bhigher);
	float m2 = mix(mf2, closest.m2, bhigher);
    
    return SDFRes(t, m, m2, b);
}

// Function 2373
vec3 do_bumpmap(vec3 p, vec3 n, float bumpfactor) {
	const float eps = .001;
	float ref = luma(tex3D(p, n));
	vec3 grad = vec3(
		luma(tex3D(vec3(p.x - eps, p.y, p.z), n)) - ref,
		luma(tex3D(vec3(p.x, p.y - eps, p.z), n)) - ref,
		luma(tex3D(vec3(p.x, p.y, p.z - eps), n)) - ref) / eps;

	grad -= n * dot(n, grad);
	return normalize(n + grad * bumpfactor);
}

// Function 2374
uint spheremap_24( in vec3 nor )
{
    vec2 v = nor.xy*inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x12(v);
}

// Function 2375
RMResult map(vec3 p)
{
    float d = FAR;
    float id = -1.;
    
    {// board
        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p + vec3(0., 1.5, 0.));
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// pawn
		p += vec3(1., 0., 1.);
        float d0 = sdCappedCylinder(1., 0.15 + (pow(1. - p.y, 2.) / 6.), p);
        float d1 = sdSphere(vec3(0., 1., 0.), 0.3, p);
        d0 = smin(d0, d1, 0.05);
        float d2 = sdEllipsoid(vec3(0.25, 0.1, 0.25), p - vec3(0., 0.7, 0.));
        d0 = smin(d0, d2, 0.05);
        vec3 q = p - vec3(0., -1., 0.);
        float d3 = sdTorus(vec2(0.5, 0.36), q);
        d3 = max(d3, -sdHPlane(0., q));
        d0 = smin(d0, d3, 0.05);
        float d4 = sdEllipsoid(vec3(0.65, 0.05, 0.65), p - vec3(0., -0.6, 0.));
        d0 = smin(d0, d4, 0.05);
		float d5 = sdTorus(vec2(0.5, 0.01), p - vec3(0., -0.52, 0.));
        d0 = smax(d0, -d5, 0.1);
		float d6 = sdTorus(vec2(0.47, 0.01), p - vec3(0., -0.43, 0.));
        d0 = smax(d0, -d6, 0.1);
        if (d0 < d)
        {
            d = d0;
            id = 1.5;
        }
    }
    
    return RMResult(d, id);
}

// Function 2376
float iceSDF (vec3 p) {
    // return length(p-vec3(0., 1., 5.))-2.;
    return p.y;
}

// Function 2377
vec3 jodieReinhardTonemap(vec3 c){
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

// Function 2378
float map(vec3 p)
{	
	if (scene_idx>9&&scene_idx<14) 
    {
		float a = sdBox(p,vec3(1.2,1.5,2.))-0.1;
    	pR(p.yz,0.2*time);
    	return max(a,-sdBox(p,vec3(0.9,0.5,.1))+0.04);
    }
    float displace = 0.001*noise(15.*p+time); 
    if (scene_idx == 8 || scene_idx == 9) displace = 0.005*noise(10.*p+time)+0.005*sin(10.*p.x+3.*time)+0.002*sin(14.*p.y+4.*time); //!!!!!!!!!!!!!!!
    if (scene_idx < 4 || (scene_idx > 5 && scene_idx < 10)) return sdBox(p,vec3(1.,1.,1.))-0.4+displace; // box ///////////// vec3 1.1.1
    return length(p)-2.0+0.5*noise(1.5*p-0.02*time);     
}

// Function 2379
vec3 sampleBSDF(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                	in vec3 wi,
                	in float time,
                  	in Material mtl,
                	out vec3 wo,
                	out float brdfPdfW,
                	out vec3 fr,
                	out bool hitRes,
                	out SurfaceHitInfo hit) {
    vec3 Lo = vec3(0.0);
    float Xi1 = rnd();
    float Xi2 = rnd();
    fr = mtlSample(mtl, ng, ns, wi, Xi1, Xi2, wo, brdfPdfW);

    //fr = eval(mtl, ng, ns, wi, wo);

    float dotNWo = dot(wo, ns);
    //Continue if sampled direction is under surface
    if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {
        Ray shadowRay = Ray(x + ng*EPSILON, wo, time);

        //abstractLight* pLight = 0;
        float cosAtLight = 1.0;
        float distanceToLight = -1.0;
        vec3 Li = vec3(0.0);

        float distToHit;

        if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {
            if(hit.mtl_id_>=LIGHT_ID_BASE) {
                distanceToLight = distToHit;
                cosAtLight = dot(hit.normal_, -wo);
                if(cosAtLight > 0.0) {
                    Li = getRadiance(hit.uv_);
                    //Li = lights[0].color_*lights[0].intensity_;
                }
            } else {
                hitRes = true;
            }
        } else {
            hitRes = false;
            //TODO check for infinite lights
        }

        if (distanceToLight>0.0) {
            if (cosAtLight > 0.0) {
                Lo += ((Li * fr * dotNWo) / brdfPdfW) * misWeight(brdfPdfW, sampleLightSourcePdf(x, ns, wi, distanceToLight, cosAtLight));
            }
        }
    }

    return Lo;
}

// Function 2380
float exSDF(vec2 p){
	float d=SQSDF(p-vec2(0.,-.85),vec2(.6,.05))-.2;
    d=min(d,SQSDF(p-vec2(.9,-.6),vec2(.04,.4))-.1);
    d=min(d,SQSDF(p-vec2(-.9,-.6),vec2(.04,.4))-.1);
    return min(d,SQSDF(p-vec2(0.,-.85),vec2(.5,.03))-.2);
}

// Function 2381
float scene(vec3 p) {
    float size = 1.;
    float d = -2.;
    
    for (int i = 0; i < 5; ++i) {
        
        // scale and repeat the cross SDF, then intersect with the calculated distance
        size *= 3.;
        vec3 q = p * size;
        tRepeat3(q, vec3(3));
    	d = opI(d, sdCross(q, vec3(.5)) / size);
    }
    
    // add the floor
    d = opU(d, p.y + .169);
    return d;
}

// Function 2382
float sdf_sbox(in vec3 p, in vec3 l)
{
  vec3 d = abs(p) - l;
  return min(max(d.x, max(d.y, d.z)), length(max(d, 0.0)));
}

// Function 2383
float sample_dist_gaussian(vec2 uv, float font_size) {

    float dsum = 0.;
    float wsum = 0.;
    
    const int nstep = 3;
    
    const float w[3] = float[3](1., 2., 1.);
    
    for (int i=0; i<nstep; ++i) {
        for (int j=0; j<nstep; ++j) {
            
            vec2 delta = vec2(float(i-1), float(j-1))/TEX_RES;
            
            float dist = sample_grad_dist(uv-delta, font_size).z;
            float wij = w[i]*w[j];
            
            dsum += wij * dist;
            wsum += wij;

        }
    }
    
    return dsum / wsum;
}

// Function 2384
vec4 scene(vec3 ro,vec3 rd)
{
	vec3 p = vec3(0.0);
	const float r = 1.0;
	float t;				  
	bool hit = intersectSphere(ro - p, rd, r, t);
	
	vec4 c = vec4(0.0);
	if (hit) {
		vec3 pos = ro + rd*t;

		// ray-march into volume
		for(int i=0; i<furLayers; i++) {
			vec4 sampleCol;
			vec2 uv;
			sampleCol.a = furDensity(pos, uv);
			if (sampleCol.a > 0.0) {
				sampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);

				// pre-multiply alpha
				sampleCol.rgb *= sampleCol.a;
				c = c + sampleCol*(1.0 - c.a);
				if (c.a > 0.95) break;
			}
			
			pos += rd*rayStep;
		}
	}
	
	return c;
}

// Function 2385
float sdf(vec3 p, bool detail)
{   
    float d = 10.0;
    p.y -= 1.7;
    
    for(int i = 0; i < 3; ++i)
    {
        pR(p.xz, .65);
        vec3 towerP = p;
        
        float index = pModPolar(towerP.xz, 12.0);
        float h1 = hash11(index * 487.01);
		
        towerP.xy += vec2(-mix(.75, .9, h1), h1*h1);
        d = min(d, Tower(towerP, .2 + h1*h1 * .2, 0.5, detail));
    }
    
    d = max(d, -p.y - .35);
    p.y = 2.1 * (p.y - .9);
    
    float w = 0.0;
    
    // Bound the noise a bit
    if(length(p) < 2.0)
    	w = WorleyFractal(p * vec3(1.0, 4.0, 1.0), 1.85, detail ? 4 : 3);
    
    // Face it towards us 
    pR(p.xz, -.8);
    pR(p.yz, .5);
    
    float tree = length(p) - 1.4 + smoothstep(.35, -.2, p.y) * .5; 
    tree += w * .25;
    
    d = min(d, tree);
    
    return d;
}

// Function 2386
float mushroomSDF(in vec3 iPoint, vec2 iPosition, in float iStemRadius, in float iStemHeight, in float iCapRadius, in float iTiltingAngle) {
    
    float d = min(stemSDF(iPoint, iPosition, iStemRadius, iStemHeight),
				capSDF(iPoint, iPosition, iCapRadius, iStemHeight, iTiltingAngle));
    return d;
    
}

// Function 2387
vec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)
{
    
   
    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps
    float ref = getGrey(triPlanar(tex, p, n));//reference value 
    
    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,
                     //eps.yxz means 0.,0.001, 0. "swizzling
                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,
                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;
    
    //so grad is the normal...then he does:
    grad -= n*dot(grad, n);//takes the dot of the surface normal 

    return normalize(n + grad*bumpfactor);
}

// Function 2388
mat3 sample_map(vec2 x, float w) {
    float q00 = map(x + vec2(-w,-w));
    float q10 = map(x + vec2( 0,-w));
    float q20 = map(x + vec2( w,-w));
    float q01 = map(x + vec2(-w, 0));
    float q11 = map(x + vec2( 0, 0));
    float q21 = map(x + vec2( w, 0));
    float q02 = map(x + vec2(-w, w));
    float q12 = map(x + vec2( 0, w));
    float q22 = map(x + vec2( w, w));
    return mat3(
		(q00 + q10 + q01 + q11) / 4.0, // 00
        (q11 + q10) / 2.0,  // 10
        (q10 + q20 + q11 + q21) / 4.0, // 20
        (q11 + q01) / 2.0, // 01
        q11, // 11
        (q11 + q21) / 2.0, // 21
        (q01 + q11 + q02 + q12) / 4.0, // 02
        (q11 + q12) / 2.0, // 12
        (q11 + q21 + q12 + q22) / 4.0 // 22
    );// * w;
}

// Function 2389
float scene(vec3 p)
{
	p *= iTime;
	vec3 pz = p;
	for(int i = 0; i < 10; i ++)
	{
		vec3 cp = vec3(p.x, -p.y, -p.z);
		p = p + pz / dot(p, p) + julia;
		p = p * scale * 0.3;
	}
	return pow(max(length(p), 0.0), 0.8);
}

// Function 2390
t_object eval_scene(vec3 p) {
    vec3 q = p;
    float s = length(q - .6*perlin_noise3(q+time_) ) - 3.;
    
    
    float pl = p.y+3.;

    const int scene_size = 2;
    float objs[scene_size];
    objs[0] = s;
	objs[1] = _union_stairs(pl, s, 1., 4.1);
    
    float d = objs[0]; int id=0;
    for(int i = 0; i < scene_size; i++) {
        if(objs[i] < d) {
            d = objs[i];
        	id = i;
        }
    }
        
    return t_object(id, d);
}

// Function 2391
float unionSDF(float distA, float distB) 
{
    return min(distA, distB);
}

// Function 2392
vec2 uvmap(vec2 uv)
{
    return ( 2.*uv - iResolution.xy) /iResolution.y;
}

// Function 2393
Hit scene(vec3 pos)
{
	Hit totalHit;
	totalHit.dist = 9000.;
	/*for (float i = 0.; i < 5.; i+=1.)
	{
		vec3 p = pos;
		float tof = time + i*0.5;
		p = vec3(p.x*sin(tof) + p.z*cos(tof), 
					   p.y,
					   p.x*cos(tof) - p.z*sin(tof));
		p += vec3(4.,0.,0.);
		
		tof*=1.3*i;
		p = vec3(p.x*sin(tof) + p.z*cos(tof), 
					   p.y,
					   p.x*cos(tof) - p.z*sin(tof));
		
		Hit h = Hit(box(p, vec3(.4,20.,.2)),i);
		totalHit = hitUnion(h,totalHit);
	}*/
	float i = 0.;
	Hit h;
	vec3 p;
	float tof;
	// Unrolling the loop seems to make it work on my windows machine
	LOOP_BODY //each loop iteration evaluates a box distance function
	LOOP_BODY	
	LOOP_BODY	
	LOOP_BODY	
	LOOP_BODY
	return totalHit;
}

// Function 2394
vec3 Tonemap(vec3 color,float gamma,float luma){
    vec3 c = exp(-1.0 / (2.72 * color + 0.15));
    c = pow(c, vec3(1.0 / (gamma * luma)));
    return c;
}

// Function 2395
float getDist(vec3 p){
    mat3 xr = mat3(1,         0,          0,
                   0,cos(iTime),-sin(iTime),
                   0,sin(iTime), cos(iTime));
    xr *= xr;
    vec3 pos = vec3(sin(iTime),0,cos(iTime))*xr*vec3(2,1.5,2) + vec3(0,0,2);
    vec3 dir = QLookAt(p - pos,pos,vec3(0,0,2));
    return min(length(p - vec3(0,0,2))-1.,boxSDF(dir,vec3(1,1,1e-2)));
}

// Function 2396
float LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {
    // Don't let it get more round than circular.
    rounded = min(thick.y, rounded);
    // midpoint
    vec2 mid = (pB + pA) * 0.5;
    // vector from point A to B
    vec2 delta = pB - pA;
    // Distance between endpoints
    float lenD = length(delta);
    // unit vector pointing in the line's direction
    vec2 unit = delta / lenD;
    // Check for when line endpoints are the same
    if (lenD < 0.0001) unit = vec2(1.0, 0.0);	// if pA and pB are same
    // Perpendicular vector to unit - also length 1.0
    vec2 perp = unit.yx * vec2(-1.0, 1.0);
    // position along line from midpoint
    float dpx = dot(unit, uv - mid);
    // distance away from line at a right angle
    float dpy = dot(perp, uv - mid);
    // Make a distance function that is 0 at the transition from black to white
    float disty = abs(dpy) - thick.y + rounded;
    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;

    // Too tired to remember what this does. Something like rounded endpoints for distance function.
    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;
    dist = min(dist, max(distx, disty));

    // This is for animated dashed lines. Delete if you don't like dashes.
    //float dashScale = 2.0*thick.y;
    // Make a distance function for the dashes
    //float dash = (repeat(dpx/dashScale + iTime)-0.5)*dashScale;
    // Combine this distance function with the line's.
    //dist = max(dist, dash-(1.0-dashOn*1.0)*10000.0);

    return dist;
}

// Function 2397
vec2 mapTerrain( in vec3 p ) {	
	vec2 buildingInfo = getBuildingInfo( p );
	vec4 buildingParams = getBuildingParams( buildingInfo.x );
	
	vec3 pos = p;
	pos.x += getXoffset( pos.z );
	pos.x = -abs( pos.x );
	
	vec2 res = vec2( udBox( vec3(pos.x+30., pos.y, pos.z) , vec3( 20., 0.25, 99999. ) ), 1.); // ground
	
	float z = buildingInfo.y;
	float zcenter = mod(pos.z+10.,20.)-10.;

#ifdef SHOW_BRIDGES
	res = opU( res, vec2( baseBridge( vec3( pos.x, pos.y,  mod(pos.z+60.,120.)-70.) ), 8. ) ); // bridge
#endif
		
	res =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-6.0, zcenter) , 0.5 ), 3. ) ); // light	
	res =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter+0.6) , 0.35 ), 3. ) ); // light	
	res =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter-0.6) , 0.35 ), 3. ) ); // light
	
	res =  opU( res, vec2( sdCylinderXZ( vec3( pos.x+11.5, pos.y, zcenter), vec2( 0.1, 6.0) ), 4.)); // 
						  
	pos += vec3( 28.75+buildingParams.y, 2.5, 0.);		
	res =  opU( res, vec2( baseBuilding( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 2. ) );

#ifdef SHOW_ORNAMENTS
	res = mix( res, opU( res, vec2( baseBalcony( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 9. ) ), buildingParams.w );
#endif
	
#ifdef SHOW_GALLERY
	pos.x += -8.75-GALLERYINSET;		
	res = mix( res, opU( res, vec2( baseGallery( vec3( pos.x, pos.y, zcenter) ), 5. ) ), buildingParams.z );
#endif	
									  
	return vec2( min( res.x,  11.-zcenter ), res.y );
}

// Function 2398
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn;
  float dstObj;
  col = BgCol (rd);
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    if (dot (rd, vn) < -0.001) col = BgCol (reflect (rd, vn));
    if (idObj == 1) col *= vec3 (1., 1., 0.9) * (0.95 + 0.05 * cos (8. * pi * qHit.z));
    else if (idObj == 2) col *= vec3 (1., 0.9, 0.9) * mix (1., 0.95 +
       0.05 * cos (16. * atan (qHit.z, - qHit.x)), step (abs (qHit.y), 1.44));
  }
  return clamp (col, 0., 1.);
}

// Function 2399
float hexprismSDF(vec3 p, vec2 h) {
    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);
    p = abs(p);
    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;
    vec2 d = vec2(
       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),
       p.z-h.y );
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 2400
float GetDist(vec3 p) {
    float glowDist,objID,dC;
    return GetDist(p,objID,glowDist,dC);
}

// Function 2401
float Tonemap_Uchimura(float x) {
    const float P = 1.0;  // max display brightness
    const float a = 1.0;  // contrast
    const float m = 0.22; // linear section start
    const float l = 0.4;  // linear section length
    const float c = 1.33; // black
    const float b = 0.0;  // pedestal
    return Tonemap_Uchimura(x, P, a, m, l, c, b);
}

// Function 2402
vec3 voronoiSphereMapping(vec3 n){
	vec2 uv=vec2(atan(n.x,n.z),acos(n.y));
    return getVoronoi(1.5*uv);}

// Function 2403
float sdf(vec3 position, float time){
    float Scale = 5.5 + sin(time*0.25)*1.75;
    float Radius = .45;// + cos(time*1.5)*0.2;
    int Iterations = 4;
    mat3 Rotation;
    
    time *= 0.25;
    //float time = 75.;
    //float time = 104.;
    //float time = 120.;
    
    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);
    Scale += sin(time*.5)*.25;
    Radius += cos(time) *.25;
    
    position *= Rotation;
	vec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;
	float C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));
	vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);
	for (int i=0; i< Iterations; i++) {
    	p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    	p.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);
        if(i < 3) p.xyz *= Rotation;
    	p.xyzw = p*scalevec + p0;
	}
	return (length(p.xyz) - C1) / p.w - C2;
}

// Function 2404
float asteroidMap( const in vec3 p, const in vec3 id) {
    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;
    return d;
}

// Function 2405
float scene(float t, vec3 ro, vec3 rd, inout vec3 nml, inout vec3 mat, float dist)
{
	dist = sphere(ro, rd, vec3(0.0), 1.0, vec3(0.5, 0.8, 1.0), nml, mat, dist);
	dist = sphere(ro, rd, 
				  vec3(sin(t*3.0)*3.0, cos(t*3.0)*3.0, cos(t)*8.0), 
				  1.5, vec3(1.0, 0.8, 1.0), 
				  nml, mat, dist);
	dist = sphere(ro, rd, 
				  vec3(sin(t*3.0)*-3.0, cos(t*3.0)*-3.0, sin(t)*8.0), 
				  1.5, vec3(0.5, 0.8, 0.5), 
				  nml, mat, dist);
	return dist;
}

// Function 2406
float QueryVolumetricDistanceField( in vec3 pos)
{    
    // Fuse a bunch of spheres, slap on some fbm noise, 
    // merge it with ground plane to get some ground fog 
    // and viola! Big cloudy thingy!
    vec3 fbmCoord = (pos + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;
    float sdfValue = sdSphere(pos, vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), 5.6);
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), 5.6), 3.0f);
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(5.0 * sin(iTime), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(0, 0.4, 0)), 22.0);
    return sdfValue;
}

// Function 2407
float DistributionGGX(vec3 N, vec3 H, float a) {
    // N, normal of the surface
    // H, halfway vector
    // a, surface roughness
    
    // We are doing our approximations based on the Trowbridge-Reits GGX:
    float a2 = a*a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float nom = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
	
    // The normal distribution function returns a value indicating how much o the surface's
    // microfacets are aligned to the incoming halfway vector.
    return nom / denom;
}

// Function 2408
float map(vec3 p)
{
    float radius = 0.; // or change to 0.1 for carpet like look
    vec3 q = fract(p*=2.5) * 1.5 - 0.5;
    
    return sphere(q, radius);
}

// Function 2409
float sdf_L(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_quarter2_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -8, 0), vec3(4, -8, 0)));
    return t;
}

// Function 2410
float dist_to_sun_visible(in vec3 ray_dir, in vec3 sun_dir) {
    if (false && ray_dir.y < 0.0) {
        return earth_rad;
    }
    if (sun_dir.y > 0.0) {
        return 1.0;
    }
    // e_z = sun_dir
    vec3 e_y = normalize(vec3(0.0, 1.0, 0.0) - sun_dir.y * sun_dir);
    vec3 e_x = normalize(cross(e_y, sun_dir));

    vec2 start_xy = earth_rad * vec2(e_x.y, e_y.y);
    vec2 ray_xy = vec2(dot(e_x,ray_dir), dot(e_y, ray_dir)); // do not normalize
    
    // (start_xy + d * ray_xy) ^2 = earth_rad^2
    // dot(start_xy, start_xy) - earth_rad^2 +
    // 2.0 * d * dot(start_xy, ray_xy) +
    // d^2 * dot(ray_xy, ray_xy) = 0.0
    
    float a = dot(ray_xy, ray_xy);
    float b = 2.0 * dot(start_xy, ray_xy);
    float c = dot(start_xy, start_xy) - earth_rad * earth_rad;
    
    return abs((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a));
    
}

// Function 2411
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstObj, s;
  sRot = sin (0.1 * pi * (floor (0.2 * tCur) + smoothstep (0., 0.2, mod (0.2 * tCur, 1.))) +
     vec2 (0.5 * pi, 0.));
  sclVar = 38. - 29. * SmoothBump (0.18, 0.75, 0.15, mod (0.05 * tCur, 1.));
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    s = float (qLev) / float (nLev);
    col = HueToRgb (mod (qHue, 1.)) * (0.2 + 0.8 * s) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +
      0.5 * s * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
  } else col = mix (vec3 (1., 1., 0.5), vec3 (0., 0., 0.3 * (0.7 + 0.3 * rd.y)),
     smoothstep (0.0035, 0.004, length (SphFib (rd, 8192.).yzw - rd)));
  return col;
}

// Function 2412
float getDistance (in vec3 p, out vec4 q) {

	// Global deformation
	p += vec3 (2.0 * sin (p.z * 0.2 + iTime * 2.0), sin (p.z * 0.1 + iTime), 0.0);

	// Cylinder
	q.xyz = p;
	q.w = -1.0;
	float d = fixDistance (-cylinderZ (q.xyz, 4.0) + 0.5 * sin (atan (q.y, q.x) * 6.0) * sin (q.z), 0.4, 0.8);

	// Twisted boxes
	vec3 q_;
	q_.xy = mod (p.xy, 5.0) - 0.5 * 5.0;
	q_.z = mod (p.z, 12.0) - 0.5 * 12.0;	
	q_ = twistZ (q_, 1.0, iTime);
	float d_ = fixDistance (box (q_, vec3 (0.6, 0.6, 1.5), 0.3), 0.4, 0.8);
	if (d_ < d) {
		q.xyz = q_;
		d = d_;
	}

	// Rotating spheres
	q_ = p;
	q_.z += 12.0;
	q_ = vRotateZ (q_, sin (iTime * 4.0));
	q_.xy = mod (q_.xy, 4.5) - 0.5 * 4.5;
	q_.z = mod (q_.z, 24.0) - 0.5 * 24.0;
	d_ = sphere (q_, 0.5);
	if (d_ < d) {
		q.xyz = q_;
		d = d_;
	}

	// Torus
	q_ = p;
	q_.z = mod (q_.z + 12.0, 24.0) - 0.5 * 24.0;
	d_ = torusZ (q_, 3.5, 0.4);
	if (d_ < d) {
		q.xyz = q_;
		d = d_;
	}

	// Flow of boxes and spheres
	#ifdef FLOW
	q_ = p;
	q_.z += iTime * 20.0;
	const float spacing = 0.5;
	const float stepCount = 3.0;
	const float period = spacing * stepCount;
	for (float step = 0.0; step < stepCount; ++step) {
		float k1 = floor (q_.z / period + 0.5);
 		float k2 = k1 * stepCount + step;
		vec3 qq = q_ - vec3 (0.4 * sin (k2), 0.4 * sin (k2 * 13.0), period * k1);
		if (mod (k2, 2.0) > 0.5) {
			d_ = box (vRotateZ (qq, k2), vec3 (0.08), 0.01);
		} else {
			d_ = sphere (qq, 0.08);
		}
		if (d_ < d) {
			q.xyz = qq;
			q.w = 1.0;
			d = d_;
		}
		q_.z += spacing;
	}
	#endif

	// Final distance
	return d;
}

// Function 2413
float map01(float a, float b, float t) {
	return clamp((t-a)/(b-a), 0., 1.);
}

// Function 2414
float sceneSDF(vec3 p) {
    p /= scale;
	float result = 0.0;
    float i = 1.0;
    for(int k = 0; k < 4; k++){
        result += craters(p,i)/i;
        i *= 2.0;
    }
    return (result+sphere(p,planet_size))*scale/10.0;
}

// Function 2415
float getSphereDist(vec3 p) {
    float sphere = length(p) - 1.;
	return sphere;
}

// Function 2416
vec4 map(vec3 rp)
{
	vec4 d;
	vec4 sp = vec4( vec3(0.68, 0.9, 0.40), sphere(rp, vec3(1.0,0.0,0.0), 1.0) );
    vec4 sp2 = vec4( vec3(0.68, 0.1, 0.40), sphere(rp, vec3(1.0,2.0,0.0), 1.0) );
    vec4 cb = vec4( vec3(0.17,0.46,1.0), cube(rp+vec3(2.1,-1.0,0.0), vec3(2.0), 0.0) );
	vec4 py = vec4( vec3(0.7,0.35,0.1), rp.y+1.0 );
	d = (sp.a < py.a) ? sp : py;
    d = (d.a < sp2.a) ? d : sp2;
    d = (d.a < cb.a) ? d : cb;
	return d;
}

// Function 2417
float dist(Ray r, vec2 p)
{
    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));
    
    
    float t = dot(r.dir, p-r.org);
    t = max(t, 0.);
    return length(getPt(r, t) - p);
}

// Function 2418
vec3 fetch_grad_dist(ivec2 uv) {
    
    vec3 grad_dist = (texelFetch(iChannel0, uv, 0).yzw - TEX_BIAS);

    grad_dist.y = -grad_dist.y;
    grad_dist.xy = normalize(grad_dist.xy + 1e-5);
    
    return grad_dist;
    
}

// Function 2419
float sphereSDF(vec3 samplePoint, float p, float s) {
    return length(samplePoint - p) - s;
}

// Function 2420
vec2 map_torch_handle(vec3 p)
{
    p = rotate(p, 45.);
    float dist = sdf_box(p, vec3(0, 0, -17), vec3(1, 1, 10));
    dist = sdf_smin(dist, sdf_box(p, vec3(0, 0, -9), vec3(2, 2, 3)), 3.);
    vec2 wood = vec2(dist, MATERIAL_WIZWOOD1_5);
    dist = sdf_box(p, vec3(0, 0, p.z > -20.5 ? -14.5 : -26.5), vec3(1.25, 1.25, .75));
    return sdf_union(wood, vec2(dist, MATERIAL_WIZMET1_1));
}

// Function 2421
float scene(vec3 point) {
    vec2 m = iMouse.xy/iResolution.xy;
    float depth = 0.5;
    if (iMouse.z >= 0.0) {
        depth = 0.1+m.y*0.9;
    }
    float nd = length(point.xy);
    nd = 1.2-nd*1.2;
    vec2 hoz = tex( point );
    vec4 t = visualizer(point);
    nd -= t.r*depth;
    return nd;
}

// Function 2422
float distMap() {
	return rayPos.y-getHeight(rayPos.xz*0.01);
}

// Function 2423
vec3 sceneLight(in float iTime) {
    return vec3(6.0, 7.8, -6.0);
}

// Function 2424
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
    
    //get rock displacement
    vec2 uv = vec2(pos.z*.4, pos.y*.4);
    float disp = texture(iChannel0,uv).r;
    
    vec2 uv2 = vec2(pos.x*.1, pos.z*.1);
    float disp2 = texture(iChannel0,uv2).r;
    
    vec2 uv3 = vec2(pos.x*.3, pos.z*.3);
    float disp3 = texture(iChannel1,uv3).r;
    
    
    
    
    //add floor to scene
    vec2 floorP = vec2(pos.y,20.);
    //apply rocky displacement to floor
    floorP.x-=disp2*.1;
    res = opU(floorP,res);
    
    //wall
    vec2 wall= sdBox( pos-vec3(0,1,0), vec3(.5,1,10) );
    wall.x-=disp*.3;
    //cut hole in wall for door
    vec2 wallMask = sdCapsule(pos, vec3(0,-.5,0), vec3(0,.7,0), 1. );
    wall.x = differenceSDF(wall.x, wallMask.x);
    res = opU(wall,res);
     
    //path
    vec3 nP = pos;
    nP.z += sin(nP.x *.4);
    vec2 path = sdBox( nP-vec3(0,0,-.1), vec3(10.,.1,1.3) );
    path.x-=disp2*.2;
    path.y = 26.;
    res = opU(path,res);
    
    //gate
    vec2 bars = sdCylinder(pos, vec3(.5,0,0), vec3(.5,2,0), .01);
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.1), vec3(.5,2,-.1), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.2), vec3(.5,2,-.2), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.3), vec3(.5,2,-.3), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.4), vec3(.5,2,-.4), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.5), vec3(.5,2,-.5), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.6), vec3(.5,2,-.6), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.7), vec3(.5,2,-.7), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,-.8), vec3(.5,2,-.8), .01)));
    
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.1), vec3(.5,2,.1), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.2), vec3(.5,2,.2), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.3), vec3(.5,2,.3), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.4), vec3(.5,2,.4), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.5), vec3(.5,2,.5), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.6), vec3(.5,2,.6), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.7), vec3(.5,2,.7), .01)));
    bars =abs(opU(bars,sdCylinder(pos, vec3(.5,0,.8), vec3(.5,2,.8), .01)));
    
    res = opU(bars,res);
    
    //plants
   /* vec3 pPos = pos-vec3(1.3,0,1.3);
    pPos.xz *= Rot(iTime);
    pPos.xz -= sin(pPos.y*4.+.4)*.4+.4;
    
    vec2 bush = sdCylinder( pPos, vec2(.01-.01*pPos.y,.3) );
    bush.y = 90.;
    res = opU(bush,res);*/
    
    vec2 grass = vec2(pos.y,90.);
    grass.x-=disp3*.1;
    res = opU(grass,res);
    
    //flag
     //add flag
    vec3 flagP = pos - vec3(1.,0,1);
    vec2 pole = sdCylinder(flagP, vec2(.01,1.4) );
    res = opU(pole,res);
    //add cloth
    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);
    vec2 cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );
    cloth.y = 91.;
    //cloth.x -=disp3*.03;
    res = opU(cloth,res);
    
    //second flag
    flagP.xz *= Rot(3.145);
    flagP = flagP - vec3(0,0,3);
    pole = sdCylinder(flagP, vec2(.01,1.4) );
    res = opU(pole,res);
    //add cloth
    flagP.x += (sin(flagP.z + iTime*5.)*.1) * smoothstep(.1,1.1,flagP.z);
    cloth = sdBox( flagP-vec3(0,1.1,0.5), vec3(.01,.3,.5) );
    cloth.y = 91.;
    res = opU(cloth,res);
    
    //guardian
    vec2 guard = sdSphere( pos-vec3(2,1,0), 0.2);
    guard = smin(guard,sdSphere( pos-vec3(2,.6,0), 0.3),.3);
    vec2 guardMask = sdCapsule(pos, vec3(2.1,1.1,.05), vec3(2.1,1.1,-.1), .2 );
    guard = max(-guardMask, guard);
    
    //add arms
    //shoulder
    vec2 arms = sdSphere( pos-vec3(2.18,1.,0.25 + sin(iTime)*.01), 0.13);
    guard = smin(guard,arms,.1);
    guard.y = 100.;
    //arm
    vec2 arm = sdCapsule(nP, vec3(2.18,1,1.), vec3(2.2,.8+ sin(iTime)*.01,1.2), .08 );
    
    
    vec2 hand = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,0.4),.04);
    arm = smin(arm,hand,.4);
    arm.y = 26.;
    res = opU(arm,res);
    
    //left
    //shoulder
    vec2 armsL = sdSphere( pos-vec3(2.18,1.+ sin(iTime)*.01,-0.25), 0.13);
    guard = smin(guard,armsL,.1);
    guard.y = 100.;
    //arm
    vec2 armL = sdCapsule(nP, vec3(2.18,1,.48), vec3(2.2,.8+ sin(iTime)*.01,.38), .08 );
    vec2 handL = sdSphere( pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07),.04);
    armL = smin(armL,handL,.4);
    armL.y = 26.;
    res = opU(armL,res);
    //spear
    vec2 spear = sdCylinder(pos-vec3(2.5,.8+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec2(.01,.5) );
    vec3 bladeP = pos;
    bladeP.x -= sin(bladeP.y*4.-.2);
    vec2 blade = sdBox( bladeP-vec3(3.5,1.3+ sin(iTime)*.01,-0.4+cos(iTime)*.07), vec3(.1,.1,.014*(1./(pos.y*4.))) );
    res = opU(spear,res);
    blade.y = 26.;
     res = opU(blade,res);
    //head
    vec3 headPos = pos;
    headPos.y -= sin(iTime)*.05+.05;
    vec2 head = sdSphere( headPos-vec3(2.13,1.13,0), 0.2);
    head = smin(guard,head,.04);
    head.y = 100.;
    res = opU(head,res);
    
    //helmet
    vec2 helmet = sdSphere( headPos-vec3(2.13,1.13,0), 0.22);
    head = sdSphere( headPos-vec3(2.13,1.13,0), 0.15);
    helmet.x = max(helmet.x,-head.x);
    vec2 helmetM = sdBox( headPos-vec3(02.2,0.85,0), vec3(.3,.2,.3) );
    
    helmet.x = max(helmet.x,-helmetM.x);
   
    vec2 helmetM2 = sdBox( headPos-vec3(02.2,0.85,0), vec3(.4,.4,.01 *headPos.y*2.) );
    helmet.x = max(helmet.x,-helmetM2.x);
    
    vec2 helmetM3 = sdBox( headPos-vec3(02.17,1.2,0), vec3(.2,.01 * abs(headPos.z)*40.+.01,.1));
    helmet.x = max(helmet.x,-helmetM3.x);
    helmet.y = 26.;
    res = opU(helmet,res);
    return res;
}

// Function 2425
float map( in vec3 p )
{
    // the height of the terrain at the location's xz plane
    float h = terrain(p.xz);

    // some sort of postprocessing of the height here
    // to give it more jagged edges

    // not sure how it really works yet
    float ss = 0.03;
    float hh = h*ss;
    // scale the height down a lot, decompose it into its fractional
    // and whole parts
    float fh = fract(hh);
    float ih = floor(hh);
    // transform fh by pushing it up towards its sqrt
    // by some amount depending on the height of the terrain you're at
    // fh corresponds to a height of ~33 in the terrain
    // the effect of this is that regularly at 33 pixel intervals,
    // the middle area of the interval gets pushed up towards the top
    // this creates more of a plateau effect which is more realistic
    // of actual terrain
    fh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );
    
    // reconstruct h with the new fractional part
    h = (ih+fh)/ss;

    return p.y - h;
}

// Function 2426
vec2 mapOpaque( vec3 p, out vec4 matInfo )
{
    matInfo = vec4(0.0);
    
   	//--------------
    vec2 res = mapSnail( p, matInfo );
    
    //---------------
    vec4 tmpMatInfo;
    float d4 = mapShell( p, tmpMatInfo );    
    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }

    //---------------
    
    // plant
    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );
    d4 = b3.x;
    d4 -= 0.04 - 0.02*b3.y;
    if( d4<res.x  ) { res = vec2(d4,3.0); }
	
	//----------------------------
    
    float d5 = mapLeaf( p );
    if( d5<res.x ) res = vec2(d5,4.0);
        
    return res;
}

// Function 2427
vec3 lightmap(in vec2 light) {
    light = 15. - light;
	if(load(_torch).r>0.5) light.t=13.;
    
    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   

}

// Function 2428
mat mapScene(in vec3 l) { }

// Function 2429
vec4 point_distance(int id, float r)
{
    vec4 X = model*rotat*ppos(id);
    float cd = sphere_intersection(ray, vec3(0), vec4(X.xyz,r));
    if(cd > 0.)
    {
        return vec4((imat*vec4(cd*ray,1.)).xyz, zrange(cd));
    }
    else
    {
        return vec4(vec3(1e10), 1.+abs(cd));
    }
}

// Function 2430
vec3 vehicle_sdf2_grad(in vec3 loc) {
    float dist = vehicle_sdf2(perturb2(loc));
    const float del = 0.01;
    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,
                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,
                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;
}

// Function 2431
float surface2x2_maxnorm_distance(in surface2x2 surf0, vec2 p) {
    surface2x2 surf;
    surface2x2_offset(surf0, -p, surf);
	float XX = surf.c[0]; float YY = surf.c[1]; float XY = surf.c[2];
	float X = surf.c[3]; float Y = surf.c[4]; float C = surf.c[5];
    
    float q = XX + YY;
    vec2 diagxy = abs(surface2x1_roots(q + XY, X + Y, C));
	vec2 diagyx = abs(surface2x1_roots(q - XY, X - Y, C));

	float c2c2 = XY*XY;
    float YY4 = YY*4.0;
    float XX4 = XX*4.0;
    vec2 planex = surface2x1_roots(
        XX*YY4 - c2c2, 
        X*YY4 - 2.0*XY*Y, 
        C*YY4 - Y*Y);
    vec2 planey = surface2x1_roots(
        YY*XX4 - c2c2,
    	Y*XX4 - 2.0*XY*X,
    	C*XX4 - X*X);
    
    float neg_rcp_2_c0 = -0.5 / XX;
    float neg_rcp_2_c1 = -0.5 / YY;
    
    vec2 p0 = vec2(planex[0], (XY*planex[0] + Y) * neg_rcp_2_c1);
    vec2 p1 = vec2(planex[1], (XY*planex[1] + Y) * neg_rcp_2_c1);
    vec2 p2 = vec2((XY*planey[0] + X) * neg_rcp_2_c0, planey[0]);
    vec2 p3 = vec2((XY*planey[1] + X) * neg_rcp_2_c0, planey[1]);
    
    float h1 = min(diagxy.x, diagxy.y);
    float h2 = min(diagyx.x, diagyx.y);
    float hx = min(maxlength(p0),maxlength(p1));
    float hy = min(maxlength(p2),maxlength(p3));
    
    return min(min(h1,h2),min(hx,hy)) * sign(C);
}

// Function 2432
float sdf(vec3 p)
{
	float sd = p.y;
    
    
	sd = smin(sd, de(p), 60.0);
    //sd = min(sd, length(p)-1.0-rmf(p+time*0.01, 8.0, 1.8, coneR)*0.06);
    sd -= rmf(p*8.0+2.0)*0.015;       // ceiling
    
    return sd;
}

// Function 2433
float map(vec3 p){
    	p = abs(mod(p, 3.) - 1.5); // Repeat space.
    	return min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.; // Void Cube.
	}

// Function 2434
void map_marker( inout vec3 col, vec2 coord )
{
	mat2 I = mat2(1);
    float shape = 0.;
    vec2 s = mc2sc( gs_map_project( g_game, g_game.mapmarker ) );
    shape = max( shape, aaa_hline( I, coord, s - vec2( 6, 0 ), 12., 1. ) );
    shape = max( shape, aaa_vline( I, coord, s - vec2( 0, 6 ), 12., 1. ) );
    col += vec3( 1, .5, .0 ) * shape;
}

// Function 2435
float map(vec3 p) {
	float d = noiseDist(p);
    p.xy -= path(p.z);
	float d2 = length(p.xy) - TunnelRadius;
    
	d = smax(/*.25*st*/d, -d2, TunnelSmoothFactor);
#ifdef OUT
    vec3 pnor = vec3(0., 1., 0.);
    d = smax(d, dot(p, pnor) - 1.2, 2.);
#endif
    
    p.z -= t + .5;
    id_t = d;
    //d = min(d, length(p) - .1);
    d = min(d, (length(p)-.1)+ st*0.03 * cos( 50.0 * p.x ) * sin( 50.0 * p.y)
                             * sin(50.0 * p.z));
    id_t = (id_t != d)? 1. : 0. ;
	return d;
}

// Function 2436
vec3 map(in vec3 pos) {
    vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );
	return opU(res, OBJECT_MAP_FUNCTION(pos));    
}

// Function 2437
float map(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    // bteitler: Compose our wave noise generation ("sea_octave") with different frequencies
    // and offsets to achieve a final height map that looks like an ocean.  Likely lots
    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:
    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20
    // which should give you an idea of what is going.  You don't need to graph this function because it
    // appears to your left :)
    float d, h = 0.0;    
    for(int i = 0; i < ITER_GEOMETRY; i++) {
        // bteitler: start out with our 2D symmetric wave at the current frequency
    	d = sea_octave((uv+SEA_TIME)*freq,choppy);
        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance
    	d += sea_octave((uv-SEA_TIME)*freq,choppy);

        h += d * amp; // bteitler: Bump our height by the current wave function
        
        // bteitler: "Twist" our domain input into a different space based on a permutation matrix
        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly
        // it is responsible for the realistic assymetry since the domain is shiftly differently.
        // This is likely the most important parameter for wave topology.
    	uv *= octave_m;
        
        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)
        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail
        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes
        // the "waves within waves" have different looking shapes, not just frequency and offset
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 2438
vec3 sdfNormal(vec3 p, float epsilon, Ray ray)
{
    vec3 normal = vec3(0.0);

    for(int axis = 0; axis < 3; ++axis)
    {
        vec3 offset = vec3(0.0);
        offset[axis] = epsilon;
        normal[axis] = sdf(p + offset, ray) - sdf(p - offset, ray);
    }
    
    return normalize(normal);
}

// Function 2439
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float old_dist;
    float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        vec3 cur_eye = eye + depth * marchingDirection;
        float dist = sceneSDF(cur_eye);
        if (dist < EPSILON) {
            vec3 old_eye = eye - old_dist * marchingDirection;
			return depth - old_dist + old_dist * (old_dist - old_eye.y) / (cur_eye.y - old_eye.y - dist + old_dist);
        }
        depth += dist * 0.5;
        old_dist = dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 2440
float map(vec3 p){
    
    p.xy -= camPath(p.z).xy; // Perturb the object around the camera path.
   
	p = cos(p*.1575 + sin(p.zxy*.4375)); // 3D sinusoidal mutation.
    
    // Spherize. The result is some mutated, spherical blob-like shapes.
    float n = dot(p, p); 
    
    p = sin(p*3.+cos(p.yzx*3.)); // Finer bumps. Subtle.
    
    return (n - p.x*p.y*p.z*.35 - .9)*1.33; // Combine, and we're done.
    
}

// Function 2441
vec3 map(vec3 p)
{
    vec3 d = vec2(0, 1e+31).yxx;
    
    float jiggle = .16 * pow(2.*fract(TAU*float(iFrame))-1., 3.);
    
    dmin(d, 2.3-abs(p.x), 1., 0.); 
    dmin(d, jiggle+length(p.xz)-.4, 2., .4);
    dmin(d, 4.-length(p.xz), 1., 0.);
    
    vec3 q = p * ry(TAU/16.);
    q = vec3(amod(q.xz, TAU/8.), p.y) + .5;
    q = abs(q-round(q));
    
    dmin(d, min(min(box(q.xy), box(q.xz)),box(q.yz))-.05, .1, 0.);
    dmin(d, box(q)-.055, 2., -1.);
    
	return d;
}

// Function 2442
vec3 laser_heatmap( float u ) { float r = 0.5; vec3 c = vec3( smoothbump( r * float( 2.0 ), r, u ) ); c.g += smoothbump( r * float( 1.0 ), r, u ); return c; }

// Function 2443
vec2 map( vec3 p ){  
    
    vec2 res = vec2(model(p) ,1.); 
    
    return res;
}

// Function 2444
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    //Note: Think in vec3 variables that ends with xxxxPos as bones.
    
#if defined(SHOW_HEAD) && (SHOW_HEAD == 1)
    //----- HEAD -----
    vec3 lHeadStart = rotation(Y_AXIS, 0.2) *  rotation(X_AXIS, -0.12) * (pos - vec3(0.0, 0.53, -0.00));
    float lHeadBox = sdBox( lHeadStart - vec3(0.0, 0.06, 0.2), vec3(0.32,0.24,0.34) );
    //res = opU( res, vec2( lHeadBox, 4.0) );
    if(res.x > lHeadBox)
    {
        
        
                //Main Head
        float   lHead = sdEllipsoid( rotation(X_AXIS, 0.4) * (lHeadStart), vec3(0.17, 0.14, 0.19));
                lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, 0.11, 0.00), vec3(0.15, 0.11, 0.14)), 0.1);
                //Nouse
                //lHead = opSmoothUnion(lHead, sdCapsule(lHeadStart - vec3(0.0, 0.04, -0.16), vec3(0.0, 0.0, 0.0),  vec3(0.0, -0.01, -0.04), 0.025), 0.005);
        		lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, 0.02, -0.15), vec3(0.012, 0.012, 0.05)), 0.04);
                //Ears
        vec3	lEarsPos = rotation(Z_AXIS, -0.4) * rotation(Y_AXIS, 0.4) * (opMirrorX(lHeadStart) - vec3(0.2, 0.018, 0.02));
        float 	lEars = sdEllipsoid( lEarsPos, vec3(0.13, 0.044, 0.03));
        		//inner
                lEars = fOpIntersectionRound(lEars, -sdEllipsoid( rotation(Y_AXIS, -0.24) * lEarsPos - vec3(0.0, 0.0, -0.013), vec3(0.07, 0.018, 0.018)), 0.015);
        		//punta
        		float lPuntaCutter = sdEllipsoid( lEarsPos - vec3(0.13, -0.055, 0.0), vec3(0.05, 0.026, 0.04));
        		lEars = fOpIntersectionRound(lEars, -lPuntaCutter, 0.06);

        lHead = opSmoothUnion(lHead, lEars, 0.02);
        res = opU( res, vec2( lHead, 2.0) );
        //res = opU( res, vec2( lPuntaCutter, 4.0) );

        //Eyes
        float lEyes = sdEllipsoid(rotation(Z_AXIS, 0.05) * (opMirrorX(lHeadStart) - vec3(0.055, 0.08, -0.165)),  vec3(0.0195, 0.05, 0.02));
        lEyes = max(lEyes, lHead);
        res = opU( res, vec2( lEyes, 4.0) );
        
        mat3 lRotZEB = rotation(Z_AXIS, -0.2);
        
        float lEyeBrows = sdEllipsoid(lRotZEB * (opMirrorX(lHeadStart) - vec3(0.06, 0.115, -0.14)),  vec3(0.036, 0.012, 0.03));
              lEyeBrows = fOpIntersectionRound(lEyeBrows, -sdEllipsoid(lRotZEB * (opMirrorX(lHeadStart) - vec3(0.058, 0.103, -0.14)), vec3(0.036, 0.011, 0.03)), 0.003);
        	  lEyeBrows = max(lEyeBrows, lHead);
        res = opU( res, vec2( lEyeBrows, 5.0) );
		
        float lMouthBox = sdBox( lHeadStart-vec3(0.0, -0.05, -0.15), vec3(0.12,0.05,0.05) );
        if(res.x > lMouthBox)
        {
        	//Mouth
            float 	lMouth = sdEllipsoid(lHeadStart - vec3(0.0, -0.056, -0.17),  vec3(0.045, 0.03, 0.04));
                    lMouth = fOpIntersectionRound(lMouth, -sdEllipsoid(lHeadStart - vec3(0.0, -0.064, -0.17),  vec3(0.05, 0.03, 0.05)), 0.008);
                    lMouth = max(lMouth, lHead);
            res = opU( res, vec2( lMouth, 4.0) );
        }
        
		
        //Hair
        {
            float 	lHair = 1e10;
            		//Cogorote
            		lHair = min(lHair, sdEllipsoid(lHeadStart - vec3(0.0, 0.08, 0.05), vec3(0.19, 0.18, 0.17)));
            		
            		//Right bulto
                    lHair = min(lHair, sdEllipsoid(rotation(Y_AXIS, -0.4) * rotation(Z_AXIS, 0.3) * (lHeadStart - vec3(0.06, 0.2, -0.05)),  vec3(0.16, 0.07, 0.13)));
            
            		//Right back bulto
            		lHair = min(lHair,  sdEllipsoid(rotation(Y_AXIS, -0.4) * rotation(Z_AXIS, 0.5) * (lHeadStart - vec3(0.12, 0.15, -0.00)),  vec3(0.1, 0.07, 0.1)));
            
                    //Left bulto
                    lHair = min(lHair, sdEllipsoid(rotation(Y_AXIS, -0.4) * rotation(Z_AXIS, -1.0) *  (lHeadStart - vec3(-0.12, 0.16, -0.03)),  vec3(0.1, 0.07, 0.1)));
            
            		//Patillas Left
                    lHair = min(lHair, sdEllipsoid(rotation(Z_AXIS, (lHeadStart.y - 0.18) * -2.5) *  (lHeadStart - vec3(-0.19, 0.0, -0.03)),  vec3(0.03, 0.1, 0.03)));
            
            		//Patillas Right
                    lHair = min(lHair, sdEllipsoid(rotation(Z_AXIS, (lHeadStart.y - 0.18) * 1.1) *  (lHeadStart - vec3(0.19, 0.0, -0.03)),  vec3(0.03, 0.12, 0.03)));
            		
            		//Hair Back
                    lHair = opSmoothUnion(lHair, sdEllipsoid(  (lHeadStart - vec3(0.1, -0.005, 0.12)),  vec3(0.06, 0.14, 0.05)), 0.03);
            		lHair = opSmoothUnion(lHair, sdEllipsoid(  (lHeadStart - vec3(0.0, -0.01, 0.13)),  vec3(0.06, 0.14, 0.05)), 0.03);
            		lHair = opSmoothUnion(lHair, sdEllipsoid(  (lHeadStart - vec3(-0.1, -0.005, 0.12)),  vec3(0.06, 0.14, 0.05)), 0.03);
            
            res = opU( res, vec2( lHair, 7.0) );
            //res = opU( res, vec2( lHairCutter, 4.0) );
        }
        
        #if defined(SHOW_CAP) && (SHOW_CAP == 1)
        //CAP
        float lCapCutter = sdEllipsoid(lHeadStart - vec3(0.0, -0.31, -0.53), vec3(0.7, 0.8, 0.7));
        lCapCutter = min(lCapCutter, sdEllipsoid(lHeadStart - vec3(0.0, 0.31, -0.8), vec3(0.3, 0.3, 0.3)));
        mat3  lCapRot = rotation(X_AXIS, pow(abs(lHeadStart.z), 2.2) * -0.9);
        float lCap = sdEllipsoid( lCapRot * (lHeadStart - vec3(0.0, 0.09, -0.16)), vec3(0.23, 0.2, 0.65));
        lCap = fOpIntersectionRound(lCap, - lCapCutter, 0.02);

        res = opU( res, vec2( lCap, 3.0) );

        float lBandCutter = sdEllipsoid(  rotation(X_AXIS, 0.5) * (lHeadStart - vec3(0.0, 0.11, 0.38)), vec3(0.5, 0.8, 0.25));
        float lCapBand = (lCap - 0.01);
        lCapBand = fOpIntersectionRound(lCapBand, -lBandCutter, 0.01);
        res = opU( res, vec2( lCapBand, 6.0) );

        //res = opU( res, vec2( lCapCutter, 4.0) );
        #endif // SHOW_CAP  

        
    }
    //----- END HEAD ------

  
#endif // SHOW_HEAD
    
 
    vec3 lPosMirrorX = opMirrorX(pos);
    
#if defined(SHOW_BODY) && (SHOW_BODY == 1)
    //----- BOTTOM BODY ------
    float lBottomBox = sdBox( pos-vec3( 0.0, 0.05, -0.05), vec3(0.18,0.06,0.12) );
    //res = opU( res, vec2( lBottomBox, 5.0) );
    if(res.x > lBottomBox)
    {
        //Shoes
        //float lShoes = sdEllipsoid( lPosMirrorX - vec3(0.06, -0.0025, -0.05), vec3(0.045 , 0.04, 0.12));
        {
            vec3 lRightFootPos = rotation(Y_AXIS, 0.2) * (pos - vec3(0.09, 0.0, -0.03));
            float 	lShoes = sdCone( rotation(Z_AXIS, -0.2) * lRightFootPos, vec3(0.0), vec3(0.0, 0.06, 0.0), 0.04, 0.042);
                  	lShoes = opSmoothUnion(lShoes, sdEllipsoid( lRightFootPos - vec3(0.0, 0.008, -0.07), vec3(0.045 , 0.04, 0.048)), 0.05);
                  //lShoes = opSmoothUnion(lShoes, sdEllipsoid( pos - vec3(0.06, -0.001,  0.02), vec3(0.02 , 0.018, 0.015)), 0.08);
            res = opU( res, vec2( lShoes, 5.0) );
            
            //Legs
            float lLegs = sdCone( rotation(Z_AXIS, -0.2) * lRightFootPos - vec3(0.0, 0.04, 0.0), vec3(0.0), vec3(0.0, 0.06, 0.0), 0.038, 0.035);
            res = opU( res, vec2( lLegs, 8.0) );
        }
        {
            
            vec3 lLeftFootPos = rotation(Y_AXIS, -1.2) * (pos - vec3(-0.06, 0.0, -0.03));
            float 	lShoes = sdCone( lLeftFootPos, vec3(0.0), vec3(0.0, 0.06, 0.0), 0.04, 0.042);
            		lShoes = opSmoothUnion(lShoes, sdEllipsoid( lLeftFootPos - vec3(0.0, 0.008, -0.07), vec3(0.045 , 0.04, 0.048)), 0.05);
            //lShoes = opSmoothUnion(lShoes, sdEllipsoid( pos - vec3(-0.06, -0.001,  0.02), vec3(0.02 , 0.018, 0.015)), 0.08);
        	res = opU( res, vec2( lShoes, 5.0) );
			
            //Legs
            float lLegs = sdCone( lLeftFootPos - vec3(0.0, 0.04, 0.0), vec3(0.0), vec3(0.0, 0.06, 0.0), 0.038, 0.035);
            res = opU( res, vec2( lLegs, 8.0) );
        }
    }
    //----- END BOTTOM BODY ------
    
    //----- MIDDLE BODY ------
    float lMiddleBox = sdBox( pos-vec3( 0.0, 0.25, -0.03), vec3(0.22,0.16,0.12) );
    //res = opU( res, vec2( lMiddleBox, 5.0) );
    if(res.x > lMiddleBox)
    {
        
        //Shoulders Cutter
        float lkShouldersCutterFactor = 0.019;
        float lShouldersCutter = sdCappedTorus( (pos -  vec3(0.0, 0.155, -0.03)), vec2(0.065, 0.09), 0.42, 0.2 );
        //fOpIntersectionRound(COSA, -lShouldersCutter, 0.01 );
        //res = opU( res, vec2( lShouldersCutter, 4.0) );
        
        //Torso
        vec3 lTorsoPos =  pos - vec3(0.0, -0.06, -0.03);
        float 	lTorso = sdEllipsoid( lTorsoPos - vec3(0.0, 0.02, 0.0), vec3(0.14, 0.45, 0.11));
        		lTorso = opSmoothUnion( lTorso, sdEllipsoid( lTorsoPos - vec3(0.0, 0.13, 0.0), vec3(0.145, 0.1, 0.115)), 0.02); //falda
        		lTorso = opSmoothUnion( lTorso, sdEllipsoid( lTorsoPos - vec3(0.0, 0.265, -0.055), vec3(0.06, 0.08, 0.035)), 0.04); //barriguita
        float lTorsoCutter = sdBox(lTorsoPos - vec3( 0.0, -0.14 , 0.0), vec3(0.3,0.3,0.3)); //+ lVariance.x * 0.5
              lTorso = fOpIntersectionRound(lTorso, -lTorsoCutter, 0.01 );
        //float lTorso = sdCone( lTorsoPos, vec3(0.0), vec3(0.0, 0.22, 0.0), 0.14, 0.06);
              //Mangas
        //res = opU( res, vec2( lTorso, 3.0) );
        
        float lCinturaCutter = sdTorus( lTorsoPos -  vec3(0.0, 0.23, 0.01), vec2(0.165, 0.008) );
        float 	lTorso2 = fOpIntersectionRound(lTorso, -lCinturaCutter, 0.07 );
        		lTorso2 = fOpIntersectionRound(lTorso2, -lShouldersCutter, lkShouldersCutterFactor );
      
        res = opU( res, vec2( lTorso2, 3.0) );
        
        vec3 	lMangasPos = rotation(X_AXIS, pos.x * -2.2) * rotation(Z_AXIS,-0.6) * (opMirrorX(lTorsoPos) - vec3(0.09, 0.35, 0.0));
        float 	lMangas = sdEllipsoid( lMangasPos,vec3(0.04, 0.09, 0.03));
              	//lMangas = max(lMangas, -sdCone( rotation(Z_AXIS,-0.4) * (opMirrorX(lTorsoPos) - vec3(0.15, 0.22, 0.0)), vec3(0.0), vec3(0.0, 0.1, 0.0), 0.04, 0.04));		
        		lMangas = fOpIntersectionRound(lMangas, -lShouldersCutter, lkShouldersCutterFactor );
        
        		//WARNING: THIS WAS DISCOVERED BY ACCIDENT, CONE WITH 0 HEIGHT DISTORTS THE ELLIPSOID LIKE AN ARM
        		//The result is innacurated compared to original image but is better than just blending a cone with the ellipsoid
        		//lMangas = opSmoothUnion(lMangas, sdCone( (lMangasPos - vec3(0.0, -0.075, 0.0)), vec3(0.0), vec3(0.0, 0.01, 0.0), 0.028, 0.022), 0.02);
        		//Real shirt cuff
        		lMangas = opSmoothUnion(lMangas, sdCone( (lMangasPos - vec3(0.0, -0.106, 0.0)), vec3(0.0), vec3(0.0, 0.045, 0.0), 0.032, 0.019), 0.03);
		res = opU( res, vec2( lMangas, 5.0) );
        

        //res = opU( res, vec2( lCinturaCutter, 4.0) );
        float lUnMirror = (pos.x < 0.0) ? 1.0 : -1.0;
        //Arms
        float 	lArms = sdCone( lMangasPos - vec3(0.0, -0.12, 0.0), vec3(0.0), vec3(0.0, 0.03, 0.0), 0.022, 0.02);
				lArms = opSmoothUnion(lArms, sdSphere(opMirrorX(lTorsoPos) - vec3(0.16, 0.245, lUnMirror * 0.045), 0.036 ), 0.02);
        res = opU( res, vec2( lArms, 2.0) );
    	
        
		//Belt
        float 	lBeltCutter = sdBox(lTorsoPos - vec3( 0.0, -0.09 , 0.0), vec3(0.3,0.3,0.3));
        		lBeltCutter = min(lBeltCutter, sdBox(lTorsoPos - vec3( 0.0, 0.56 , 0.0), vec3(0.3,0.3,0.3)));
        	
        float lBelt = fOpIntersectionRound((lTorso - 0.0006), -lBeltCutter, 0.004);
        res = opU( res, vec2( lBelt, 5.0) );
        
        //Ebilla
        vec3    lEbillaPos = (lTorsoPos - vec3( 0.0, 0.235 , -0.085)); //rotation(X_AXIS, -0.05)
        float 	lEbilla = sdBox( lEbillaPos , vec3(0.036,0.02,0.015) );
        		lEbilla -= 0.005;
        		lEbilla = max(lEbilla, -sdBox( lEbillaPos , vec3(0.032,0.017,0.04) ));
        		
        res = opU( res, vec2( lEbilla, 10.0) );
        
        //TOOD: plunge breast zone (fOpIntersectionRound with sphere should be enough)
        
        //Breast
        float lBreast = sdCylinder( pos - vec3(0.0, 0.35, -0.04), vec2(0.05, 0.1) );
        lBreast = max(lBreast, lTorso2) - 0.0001;
        //Neck
        lBreast = opSmoothUnion(lBreast, sdCylinder( pos - vec3(0.0, 0.38, -0.03), vec2(0.03, 0.02) ), 0.01);
        res = opU( res, vec2( lBreast, 2.0) );
        
    }
    //----- END MIDDLE BODY ------
#endif
    
    //----- SWORD & SHIELD ------
    
#if defined(SHOW_SWORD) && (SHOW_SWORD == 1)
    //Sword
    vec3 lSwordPos = rotation(Y_AXIS, M_PI * -0.28) * rotation(X_AXIS, M_PI * 0.5) * rotation(Y_AXIS, M_PI * -0.2) * (pos - vec3(-0.146, 0.175, 0.02));    
    float 	lSwordBox = sdBox( lSwordPos-vec3( 0.0, 0.16, 0.0), vec3(0.1,0.28,0.04) );
    //res = opU( res, vec2( lSwordBox, 5.0) );
    if(res.x > lSwordBox)
    {

        
        //HANDLE
        //vec3 lSwordPos =  pos - vec3(-0.5, 0.5, 0.0);
        float	lSword = sdCylinder( lSwordPos - vec3(0.0, 0.02, 0.0), vec2(0.018, 0.05) );
        		lSword = min( lSword, sdSphere( lSwordPos - vec3(0.0, -0.05, 0.0), 0.028 ));
        
        //GUARDA
        vec3	lGuardPos = lSwordPos - vec3(0.0, 0.08, 0.0);
        		lSword = min( lSword, sdRoundBox(lGuardPos, vec3(0.05, 0.014, 0.014), 0.006));
        vec3 	lGuardSidesPos = rotation(Z_AXIS, -0.5) * (opMirrorX(lGuardPos) - vec3(0.05, 0.002, 0.0));
        float 	lRedution = abs(lGuardPos.x) < 0.05 ? 0.0 : (abs(lGuardPos.x) - 0.05) * 0.12;
        		lSword = min( lSword, sdRoundBox(lGuardSidesPos - vec3(0.015, 0.0, 0.0), 
                                                 vec3(0.02, 0.014  - lRedution , 0.014  - lRedution), 
                                                 0.006));
        
        //TOOD: try to do guard with a lSwordPos.x altered rotation matrix
        res = opU( res, vec2( lSword, 5.0) );
        
        //METAL
        //vec3 lElongate = opElongate(lSwordPos - vec3(0.0, 0.1, 0.0), vec3(0.028, 0.0, 0.0));
        //float lMetal = sdCylinder( lElongate , vec2(0.008, 0.01) );
        
        float lMetalCutter1 = sdBox(lSwordPos - vec3(0.0, 0.1, 0.0), vec3(0.034, 0.009, 0.008));
        float lMetal = sdEllipsoid( lSwordPos - vec3(0.0, 0.1, 0.0) , vec3(0.033, 0.08, 0.008) );
        lMetal = max(lMetal, lMetalCutter1);
        
        
        //HOJA
        //vec3 lElongateHoja = opElongate(lSwordPos - vec3(0.0, 0.2, 0.0), vec3(0.02, 0.08, 0.0));
        vec3 lHojaPos = lSwordPos - vec3(0.0, 0.22, 0.0);
        //lMetal = min( lMetal, sdOctahedron(lHojaPos * vec3(1.0, lHojaPos.y < 0.0 ? 0.25 : 1.0, 2.5), 0.08));
        float 	lHoja = sdCone( lHojaPos - vec3(0.0, 0.159, 0.0), 0.04, 0.05, 0.0002 );
         		lHoja = min(lHoja, sdCone( lHojaPos, 0.12, 0.029, 0.05 ));
        float	lReducerZHoja = abs(lHojaPos.x * 0.08);
         		lReducerZHoja += (abs(lHojaPos.y) > 0.12) ? (abs(lHojaPos.y) - 0.12) * 0.05  : 0.0;
        		lHoja = max(lHoja, sdBox( lHojaPos, vec3(0.05, 0.3, max(0.0005, 0.004 - lReducerZHoja))));
        
        float 	lAbatanador = sdRoundedCylinder( opMirrorZ(lHojaPos) - vec3(0.0, -0.01, 0.012), 0.005, 0.05, 0.1 );
        		lHoja = max(lHoja, -lAbatanador);
        lMetal = min(lMetal, lHoja);
        
        res = opU( res, vec2( lMetal, 9.0) );
        
        //res = opU( res, vec2( lAbatanador, 4.0) );
    }
#endif
    
#if defined(SHOW_SHIELD) && (SHOW_SHIELD == 1)
    //SHIELD
    vec3 	lShieldPos =  rotation(X_AXIS, M_PI * -0.05) * rotation(Y_AXIS, M_PI * 0.18)  * (pos - vec3(0.2, 0.2, -0.15)) * 0.74;
    float 	lShieldBox = sdBox( lShieldPos-vec3( 0.0, 0.04, 0.0), vec3(0.16,0.16,0.1) );
    //res = opU( res, vec2( lShieldBox, 5.0) );
    if(res.x > lShieldBox)
    {
        		lShieldPos = opMirrorX(lShieldPos);
        float 	lShieldCutter = sdBox(lShieldPos, vec3(0.14, 0.18, 0.024));
        float   lInnerShieldCutter = lShieldCutter;
        	  	lShieldCutter = fOpIntersectionRound(lShieldCutter, -sdSphere(lShieldPos - vec3(0.47, 0.94, 0.0),  0.9), 0.01);
        		lInnerShieldCutter = fOpIntersectionRound(lShieldCutter, -sdSphere(lShieldPos - vec3(0.47, 0.91, 0.0),  0.9), 0.01);
        //float 
        float 	lShield = sdEllipsoid(lShieldPos - vec3(-0.05, 0.1, 0.0), vec3(0.19, 0.22, 0.024));
        		lShield = max(lShield, lShieldCutter);
        
        //INNER
        float 	lInnerShield = sdEllipsoid(lShieldPos - vec3(-0.05, 0.1, -0.01), vec3(0.16, 0.19, 0.024));	
        		lInnerShield = max(lInnerShield, lInnerShieldCutter);
        		lInnerShield = fOpIntersectionRound(lInnerShield, -lShield, 0.004) - 0.005;
       float	lShield2 = max(lShield, -lInnerShield);
        		lInnerShield = max(max(lInnerShield, lShield2 + 0.0009) - 0.0011, lShield);
        		
        //DECORATIONS
        vec3	lConeSize = vec3(0.02, 0.03, 0.018);
		float	lMetalDecorations = sdCone( (lShieldPos - vec3(0.0, -0.07, 0.0)), lConeSize.x, lConeSize.y, lConeSize.z);
        
        		lMetalDecorations = min(lMetalDecorations, sdCone((rotation(Z_AXIS, -1.0) * lShieldPos - vec3(0.02, -0.076, 0.0)), lConeSize.x, lConeSize.y, lConeSize.z));
        		lMetalDecorations = min(lMetalDecorations, sdCone(rotation(Z_AXIS, -2.0) * lShieldPos - vec3(0.028, -0.125, 0.0), lConeSize.x, lConeSize.y, lConeSize.z));
        		lMetalDecorations = min(lMetalDecorations, sdCone(rotation(X_AXIS, -0.2) * (lShieldPos - vec3(0.0, 0.125, 0.0)), 0.02, 0.02, 0.04));
        
        		lMetalDecorations = max(lMetalDecorations, lShield);
        		
        		//Spheres
        		lMetalDecorations = min(lMetalDecorations, sdSphere(lShieldPos - vec3(0.000, -0.080, -0.005), 0.011));
        		lMetalDecorations = min(lMetalDecorations, sdSphere(lShieldPos - vec3(0.070, -0.020, -0.005), 0.011));
        		lMetalDecorations = min(lMetalDecorations, sdSphere(lShieldPos - vec3(0.110,  0.080, -0.007), 0.011));
        		lMetalDecorations = min(lMetalDecorations, sdSphere(lShieldPos - vec3(0.000,  0.140, -0.017), 0.011));
        
        		//lMetalDecorations = min(lMetalDecorations, lInnerShield);
        		//lShield -= 0.01;
    
        float 	lTriforce = sdCone( (lShieldPos - vec3(0.0, 0.09, -0.018)), 0.013, 0.016, 0.0001);
        		lTriforce = min(lTriforce, sdCone( (lShieldPos - vec3(0.016, 0.064, -0.018)), 0.013, 0.016, 0.0001)); 
        		lTriforce = max(lTriforce, lInnerShield - 0.0025);
		
        float	lBird = sdBox( rotation(Z_AXIS, -0.5) * (lShieldPos - vec3(-0.005, 0.026, -0.018)), vec3(0.013, 0.016, 0.04));
        		lBird = min(lBird, sdBox( rotation(Z_AXIS,  0.3) * (lShieldPos - vec3(-0.008, -0.026, -0.018)), vec3(0.013, 0.025, 0.04)));
        vec3 	lBirdBallPos = (lShieldPos - vec3(0.0, 0.02, -0.0));
        		lBird = min(lBird, 
                            max( sdSphere(lBirdBallPos, 0.037), 
                                -sdSphere(lBirdBallPos -vec3(0.0, 0.007, 0.0), 0.034)));
        		lBird = min(lBird, sdBox( rotation(Z_AXIS,  0.1) * (lShieldPos - vec3(0.046, 0.025, -0.018)), vec3(0.018, 0.0035 + (lShieldPos.x * 0.1), 0.04)));
        		lBird = min(lBird, sdBox( rotation(Z_AXIS,  0.3) * (lShieldPos - vec3(0.04, 0.008, -0.018)), vec3(0.015, 0.003 + (lShieldPos.x * 0.08), 0.04)));
        
        		lBird = min(lBird, sdBox( rotation(Z_AXIS,  0.7) * (lShieldPos - vec3(0.032, -0.003, -0.018)), vec3(0.013, 0.002 + (lShieldPos.x * 0.06), 0.04)));
        
        		lBird = max(lBird, lInnerShield - 0.0025);
        
        float   lRays = sdCone( rotation(Z_AXIS,  -0.2 - pow(lShieldPos.x * 5.5, 0.8)) * (lShieldPos - vec3(0.04, 0.08, -0.018)), 0.033, 0.01, 0.001);
            
            	lRays = max(lRays, lInnerShield - 0.0025);
        
        //HANDLE        
        float lHandle = sdTorus( rotation(Z_AXIS, M_PI * 0.5) * (lShieldPos - vec3(0.0, 0.0, 0.02)), vec2(0.03, 0.008) );
              lHandle = max(lHandle, length(lShieldPos - vec3(0.0, 0.0, 0.07)) - 0.08);
        lShield2 = min(lShield2, lHandle);
        
        res = opU( res, vec2( lShield2, 9.0) );
        res = opU( res, vec2( lInnerShield, 11.0) );
        res = opU( res, vec2( lMetalDecorations, 9.0) );
        res = opU( res, vec2( lTriforce, 10.0) );
        res = opU( res, vec2( lBird, 12.0) );
        res = opU( res, vec2( lRays, 9.0) );
    }
#endif
    //----- END SWORD & SHIELD ------
    
    //Debug reference
    //float lFront = sdSphere(pos - vec3(0.0, 0.66, -0.5), 0.08);
    //res = opU( res, vec2( lFront, 4.0) );
    return res;
}

// Function 2445
maybe_float get_distance_along_3d_line_nearest_to_line(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B
){
    vec3 D = B0 - A0;
    // offset
    vec3 C = normalize(cross(B, A));
    // cross
    vec3 R = D - dot(D, A) * A - dot(D, C) * C;
    // rejection
    return maybe_float(
        length(R) / -dot(B, normalize(R)), 
        abs(abs(dot(A, B)) - 1.f) > 0.f
    );
}

// Function 2446
float torusDist(vec3 pos, float R, float r)
{
    return length(vec2(length(pos.xy)-R,pos.z))-r;
}

// Function 2447
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    
    
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );
    
    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );
    
    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
    // AO
    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;
    
    return surfaceLighting;
}

// Function 2448
float sphereSDF(vec3 p, float r) {
    return length(p) - r;
}

// Function 2449
vec4 distUV(vec3 pos)
{
    //pos+=.00015*getRand(pos*1.3).xyz*4.;
    //pos+=.00006*getRand(pos*3.).xyz*4.;
    //pos+=.00040*getRand(pos*.5).xyz*4.;
    vec3 p1,p2,p3;
    float d = 10000.;
    
    // sphere in the middle
	//d=min(d,distSphere(pos,.79));
    
    // start with an icosahedron subdivided once
    getIcosaTri(pos, p1, p2, p3);
    //getTriSubDiv(pos, p1, p2, p3);
    // always sort by X, then Y, then Z - to get a unique order of the edges
    sortXYZ(p1,p2,p3);
    vec2 uv;
    d=min(d,distTruchet(pos, p1,p2,p3,.2,uv));
    
    return vec4(d,uv,0);
}

// Function 2450
float sceneSDF(vec3 p) {
    return min(planeSDF(p), sphereSDF(p));
}

// Function 2451
vec3 tonemap(vec3 colour)
{
    float luminance = max(0.0001, luminance(colour));
    vec3 normalisedColour = colour / luminance;
    
    vec3 tonemapColour;
    tonemapColour.r = tonemapOp(colour.r);
    tonemapColour.g = tonemapOp(colour.g);
    tonemapColour.b = tonemapOp(colour.b);
    float tonemappedLuminance = tonemapOp(luminance);
    
    return mix(tonemappedLuminance * normalisedColour, tonemapColour, min(1.0, 0.5*luminance));
}

// Function 2452
float map(in vec3 p)
{
    float d = length(p - vec3(0, 1, 0));
    if (abs(d - 0.5) > 0.2)
    {
        // early quit for optimization.
        return d - 0.5;
    }

    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;
    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;
    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;
    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;
    d = length(p - vec3(0, 1, 0)) - 0.5;
    return d;
}

// Function 2453
float sdf(vec3 position, out vec3 diffuseColor, out vec3 emissionColor){
    diffuseColor = vec3(1.);
    emissionColor = vec3(0.);
    float Scale = 2.25;
    float Radius = .25;
    int Iterations = 6;
    mat3 Rotation;
    
    float time = 104.;
    
    Rotation = rotationMatrix(vec3(time, time*.7, time*.4)*.2);
    Scale += sin(time*.5)*.25;
    Radius += cos(time) *.25;
    
	vec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;
	float C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));
	vec4 p = vec4(position.xyz*Rotation, 1.0), p0 = p;
	for (int i=0; i< Iterations; i++) {
    	p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    	p.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);
        if(i < 3) p.xyz *= Rotation;
    	p.xyzw = p*scalevec + p0;
	}
    diffuseColor = fract(p0.x)<.1 ? vec3(0.) : vec3(1.);
    emissionColor = fract(p0.x)<.1 ? (normalize(p.xyz)*.5+.5)*10. : vec3(0.);
	return (length(p.xyz) - C1) / p.w - C2;
}

// Function 2454
float boxDist(vec2 p){
    vec2 d = abs(p)-1.0;
    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);
}

// Function 2455
float CombineSDF(vec3 p, inout int closest)
{
      vec3 ps = p;

    
      vec3 sph1Pos = ps + vec3(14.0, -8.0 + 6.0 * sin(iTime * 0.63), 0.0);
                               
      float sd = SphereSDF(sph1Pos, 5.0); 
    
      vec3 sph2Pos = ps + vec3(-14.0, -8.0 + 6.0 * cos(iTime * 0.63), 0.0);
      float sph2 = SphereSDF(sph2Pos, 5.0); 
      float interT = smoothstep(0.0, 1.0, abs(sin(iTime * EXCHANGE_SPEED)));
      vec3 torPos = mix(sph1Pos, sph2Pos, interT);//interT * sph1Pos + (1.0 - interT) * sph2Pos;
      float sph3 = TorusSDF(torPos, 7.0, 2.0);
    
      sd = smin(sd, sph2, 5.0); 
      sd = smin(sph3, sd, 5.0); 
      float pd =  PlaneSDF(p, 5.2);   
    
      float fin = min(sd, pd);
      closest = OBJECT1;
      if(fin == pd)
      { 
          closest = FLOOR_PLANE;
      }
      return fin;
}

// Function 2456
float angdist(vec2 sp1, vec2 sp2)
{
    float sinTheta1 = sqrt(1.0 - sp1.y * sp1.y);
    float sinTheta2 = sqrt(1.0 - sp2.y * sp2.y);
    return acos(sp1.y * sp2.y + sinTheta1 * sinTheta2 * cos(sp2.x - sp1.x));
}

// Function 2457
float sceneSDF(vec3 p) {
    float final = 0.0;
    
    float palmo_low = sdEllipsoid(p, vec3(0.42, 0.42, 0.15));
    float palmo_up = sdEllipsoid(p - vec3(0.0,0.15,0.0), vec3(0.45, 0.4, 0.2));
    final = palmo_low;
    
    float thumb = sdVerticalCapsule(
        rotateZ(-1.1) * (p - vec3(0.2,0.0,0.)),
        0.5,
        0.1
    );
    final = opSmoothUnion(thumb, final, 0.15);
    
    float pinky = sdVerticalCapsule(
        rotateZ(0.30) * (p - vec3(-0.33, 0., 0.0)),
        0.52,
        0.08
    );
    final = opSmoothUnion(pinky, final, 0.05);

    float ring = sdVerticalCapsule(
        rotateZ(0.15) * (p - vec3(-0.215,0.335,0.0)), 
        0.5, 
        0.09
    );
    final = opSmoothUnion(ring, final, 0.05);
    
    float middle = sdVerticalCapsule(p - vec3(0.0,0.45,0.0), 0.6, 0.09);
    final = opSmoothUnion(middle, final, 0.08);
    
    float index = sdVerticalCapsule(
        rotateZ(-0.1) * (p - vec3(0.22,0.3,0.0)),
        0.6,
        0.09
    );
    final = opSmoothUnion(index, final, 0.1);
    


    return final;
}

// Function 2458
vec3 scenecol(vec3 p) 
{
    float r = dlight(p);
    if (r < .005) return clite; // bright yellow/white
    if (p.y > 3.) return csky; // sky ambient
    return vec3(.0); // dim gray/black - non-emissive
}

// Function 2459
vec3 Uncharted2ToneMapping(vec3 color)
{
    float A = 0.15;
    float B = 0.50;
    float C = 0.10;
    float D = 0.20;
    float E = 0.02;
    float F = 0.30;
    float W = 11.2;
    float exposure = 2.;
    color *= exposure;
    color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
    float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
    color /= white;
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 2460
float GetSceneDistance( const vec3 vPos )
{
    return vPos.y - GetTerrainHeight( vPos );
}

// Function 2461
float map(vec3 p)
{
    PLANEMAT;
	float r = PLANE;	// Return distance
    
    BOXMAT;
    r = min(r, BOX);
    
    return r;
}

// Function 2462
float sceneDist(vec3 p)
{
   const int num_spheres = 32;

   float sd = 1e3;


   for(int i = 0; i < num_spheres; ++i)
   {
      float r = 0.22 * sqrt(float(i));
      vec3 p2 = rotateX(cos(time + float(i) * 0.2) * 0.15, p);
      float cd = -sphere(p2 + vec3(0.0, -0.9, 0.0), 1.3);
      sd = min(sd, max(abs(sphere(p2, r)), cd) - 1e-3);
   }

   return sd;
}

// Function 2463
vec3 adjust_out_of_gamut_remap(vec3 c)
{
    const float BEGIN_SPILL = 0.5;
    const float END_SPILL = 1.0;
    const float MAX_SPILL = 0.8; //note: <=1
    
    float lum = dot(c, vec3(1.0/3.0));
    //return mix( c, vec3(lum), min(lum,1.0));
    
    float t = (lum-BEGIN_SPILL) / (END_SPILL-BEGIN_SPILL);
    t = clamp( t, 0.0, 1.0 );
    //t = smoothstep( 0.0, 1.0, t );
    t = min(t, MAX_SPILL); //t *= MAX_SPILL;
    
    return mix( c, vec3(lum), t );
}

// Function 2464
float map (in vec3 p)
{
   float d1 = length(p) - 1.2;
   return d1;
}

// Function 2465
vec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )
{
    // tetrahedron normal
    const float fDelta = 0.025;

    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;
    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;
    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;
    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;

    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

    return normalize( vNormal );
}

// Function 2466
float terrain_distance(in vec3 at) {
	return min(1.+at.y,at.y - terrain_height(at));
}

// Function 2467
float map(float value,float min1,float max1,float min2,float max2){
    return min2+(value-min1)*(max2-min2)/(max1-min1);
}

// Function 2468
void initScene() {
	
    int count = 0;
    float radius = 0.55;
    spheres[count++] = Sphere(0.24, vec3(0.,2.5, 0.5));

    float x = -3.;
    float y = 1.;

    for( int i=0; i < 6; ++i ) {
        spheres[count++] = Sphere(radius, vec3(x, y, 0.));
        x += 2.2 * radius;
    }
    
    planes[0] = Plane(vec3(0.,0.85,0.), vec4(0.,1.,0., 1.));
    
    lights[0] = LightInfo(Le, spheres[0].p, vec3(0.), 0.4, LIGHT_TYPE_SPHERE, true);
    lights[1] = LightInfo(sunLe, vec3(0.), normalize(SUN_DIRECTION), 0., LIGHT_TYPE_SUN, true);

}

// Function 2469
float map( in vec3 p )
{
    return p.y - terrain(p.xz);
}

// Function 2470
float map(vec3 rayPos)
{
	int tempHitMaterial;
    return map(rayPos, tempHitMaterial);
}

// Function 2471
vec2 map( vec3 p )
{
    // animation
    float atime = iTime+12.0;
    vec2 o = floor( 0.5 + p.xz/50.0  );
    float o1 = hash( o.x*57.0 + 12.1234*o.y );
    float f = sin( 1.0 + (2.0*atime + 31.2*o1)/2.0 );
    p.y -= 2.0*(atime + f*f);
    p = mod( (p+25.0)/50.0, 1.0 )*50.0-25.0;
    if( abs(o.x)>0.5 )  p += (-1.0 + 2.0*o1)*10.0;
    mat3 roma = rotationMat(axis, 0.34 + 0.07*sin(31.2*o1+2.0*atime + 0.1*p.y) );
    // modeling
	for( int i=0; i<16; i++ )
	{
        p = roma*abs(p);
        p.y-= 1.0;
    }
	float d = length(p*vec3(1.0,0.1,1.0))-0.75;
    float h = 0.5 + p.z;
    return vec2( d, h );
}

// Function 2472
vec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering
;float g=gd(o)*s*.5
,t=g,ao=1.
,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.
;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 "smallest values"
 ;for(int i=0;i<iterRm;i++
 ){//start.raymarch
 ;g=gd(o+d*t)
 ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))
       //=(g<min(f*t,ao)&&ts.w<.0);
       //=(g<f*t&&g<ao&&ts.w<.0);
 ;if(ps //PushSmall, we remember 4*2 smallest values for AO.
 ){gs=vec4(abs(g),gs.xyz)
  ;ts=vec4(t,ts.xyz);
 ;}
 ;t+=g
 ;ao=g
 ;if(t>zFar||g<eps)break;//raymarch loop break
 ;}//end__.raymarch loop 
 ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall
 ;vec3 c=Backdrop(d)
     //;return c;
 ;vec3 fcol=c
 ;for(int i=0;i<4;i++ //some AA supersampling shit in here?
 ){//ts and ps values get processed for "occlusion"
  //oh looks like this is just nearSurface() surface stuff.      
  ;if(ts.x<.0)break
  ;float px=f*ts.x
  ;vec3 so=o+d*ts.x
  ;vec4 mcol=vec4(.0)
  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))
  ;vec3 ve=vec3(px,0,0)
  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal
  ;float d1=gd1(so,mcol)
  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.
  //above begs to be inversesqrt?
  ;vec3 spc=mcol.rgb*0.14//specular set to material
  #ifdef doShade
  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)
  #endif
        //near distance can skip fog.
  #ifdef doFog
  ;spc=fog(ts.x,spc,fcol);
  #else 
  //;spc=fog(ts.x,spc,fcol);
  #endif  
  ;c=mix(spc,c,sat(gs.x/px))
  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix
 ;}
//;if(c!=c)c=vec3(1,0,0);//if(NaN)
;return sat(c*2.)
;}

// Function 2473
vec2 map( in vec3 pos )
{
   // float sound = texture(iChannel0,vec2(0.0,0.0)).x*3.0;
    float eh =  iTime + 55.0;
    float time = eh;//iTime + 35.0;
    float freq = smoothWave(time*5.0, 10.0);
    float amp = smoothWave((time+ 8238.0)*0.14, 0.5);
    float power = smoothWave((time+ 1238.0)*0.33, 5.0)+1.0;
    //apply global warp
     pos = NormalSinPowWarpTest(pos, freq, amp,power);
    
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
	res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
	res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
	res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
	res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
	res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
	res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );

    res = opU( res, vec2( opS(
		             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
	                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS(
		             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
	                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,
											  pos.y,
											  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),
									     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
	res = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 
					                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 
                                       65.0 ) );
	res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );

    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );

    res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
        
   	res.x *= .48;
    return res;
}

// Function 2474
vec3 map( vec3 pos )
{
pos /= SC;

    // floor
    vec2 id = floor((pos.xz+0.1)/0.2 );
    float h = 0.012 + 0.008*sin(id.x*2313.12+id.y*3231.219);
    vec3 ros = vec3( mod(pos.x+0.1,0.2)-0.1, pos.y, mod(pos.z+0.1,0.2)-0.1 );
    vec3 res = vec3( udBox( ros, vec3(0.096,h,0.096)-0.005 )-0.005, 0.0, 0.0 );

    // ceilin
	float x = fract( pos.x+128.0 ) - 0.5;
	float z = fract( pos.z+128.0 ) - 0.5;
    float y = (1.0 - pos.y)*0.6;// + 0.1;
    float dis = 0.4 - smin(sqrt(y*y+x*x),sqrt(y*y+z*z),0.01);
    float dsp = abs(sin(31.416*pos.y)*sin(31.416*pos.x)*sin(31.416*pos.z));
    dis -= 0.02*dsp;

	dis = max( dis, y );
    if( dis<res.x )
    {
        res = vec3(dis,1.0,dsp);
    }

    // columns
	vec2 fc = fract( pos.xz+128.5 ) - 0.5;
	vec3 dis2 = column( fc.x, pos.y, fc.y );
    if( dis2.x<res.x )
    {
        res = dis2;
    }
    
    fc = fract( pos.xz+128.5 )-0.5;
    dis = length(vec3(fc.x,pos.y,fc.y)-vec3(0.0,-0.565,0.0))-0.6;
    dis -= texture(iChannel0,1.5*pos.xz).x*0.02;
    if( dis<res.x ) res=vec3(dis,4.0,1.0);
    
    
    #if 1
    dis = monster( pos );
    if( dis<res.x )
    {   
        res=vec3(dis,7.0,1.0);
    }
    #endif
    
	res.x*=SC;
    return res;
}

// Function 2475
vec3 dist_hyperbola(vec2 p, float a, float c)
{
    //
    // Calculates the (unsigned) distance to a hyperbola (in canonical form)
    // with foci on the x-axis
    // 
    
    //
    // EXPLANATION/DERIVATION:
    //
    
    //
	// Given a canonical hyperbola with foci (c, 0) and vertices (a, 0), then
	// 
	//     (x/a) - (y/b) = 1
	// 
	// holds for any point (x,y) on the hyperbola, where b = c - a.
    // 
    // A possible parametrization of the right branch of this curve is 
    //
    //     P(t) = (x(t), y(t)), 
    //
    // where
    //
    //     x(t) = a cosh(t)
    //     y(t) = b sinh(t)
    //
    // since
    //
    //     cosh(t) - sinh(t) = 1.
    //
    
    //
    // The distance between a point p = (x,y) and the curve P(t) is found by 
    // calculating the value of t such that the distance between P(t) and p 
    // is minimized, or symbolically:
    //
    //     d/dt |P(t) - p| = 0
    // 
    // The absolute value isn't convenient to work with, so we'll work with the
    // square instead, which has the same solution for t:
    //
    //     d/dt |P(t) - p| = 0
    //
    // This is convenient form, because we can work with the dot product
    //
    //     f(t) = |P(t) - p| = dot(P(t) - p, P(t) - p)
    // 
    
    //
    // When differentiating, using the chain rule, we get 
    // 
    //     d/dt (P(t) - p) = 2 (P(t) - p) * d/dt (P(t) - p)) = 0
    //
    // or
    //
    //     (P(t) - p) * dP/dt = 0
    //
    // where the * represents a dot product, since we're working with vectors.
    //
    
    // 
    // Differentiating x(t) and y(t) gives
    //
    //     dx/dt = d/dt cosh(t) = sinh(t)
    //     dy/dt = d/dt sinh(t) = cosh(t)
    //
    // such that
    //
    //     dP/dt = (a sinh(t), b cosh(t))
    //
    
    //
    // We end up with
    //
    //     (a cosh(t) - x)*(a sinh(t)) + (b sinh(t) - y)*(b cosh(t)) = 0
    //
    // where p = (x,y) has been used. Simplifying, we get
    //
    //     a cosh(t) sinh(t) + b sinh(t) cosh(t) - a x sinh(t) - b y cosh(t) = 0
    //
    // and, by collecting terms and reordering, we get
    //
    //     f'(t) = g(t) = cosh(t) sinh(t) - A sinh(t) - B cosh(t) 
    //
    // where 
    //
    //     A = a x /(a + b)
    //     B = b y /(a + b)
    //
    
    //
    // This expression might have analytical roots, but these are most likely not very nice
    // to calculate or work with, as it's equivalent to solving a quartic polynomial. 
    // Instead we attempt a numerical solution, hoping that it converges rather quickly 
    // and consistently. 
    //
    
    //
    // We will use a standard Newton-Rhapson iterative scheme for root solving:
    //
    // Given a function g(x) = 0, and an initial guess x_0, then by applying the following
    // iterative scheme,
    //
    //     x_{n+1} = x_n - f(x_n)/f'(x_n)
    // 
    // we should converge to a root as long as the function g(x) is sufficiently "nice".
    //
    
    //
    // By choosing the initial guess t_0 well, we can (hopefully) be guaranteed to reach the 
    // global minimum, thereby finding the value of t such that the distance is minimized.
    //
    
    // 
    // At this point we have everything we need, so let's go:
    //
    
    
    //
    // CALCULATIONS:
    //
    
    // Helper quantities
    float a2 = a*a;
    float c2 = c*c;
    float b2 = c2 - a2;
    float b = sqrt(b2);
    
    float A = a*p.x/(a2 + b2);
    float B = b*p.y/(a2 + b2);
    
    // try t = 0 as initial guess, this could/should most likely be improved
    float t = 0.0;
    //float t = p.y;
    //float t = 1.0*length(p)*sign(p.y);
    
    // iterate
    int i;
    for (i = 0; i < 1000;i++) {
        float ch = cosh(t);
        float sh = sinh(t);
        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);
        t = t - dt;
        if (abs(dt) < 1.0e-3) break; // until sufficiently close to solution
    }
    
    // calculate closest point
    vec2 P = vec2(a*cosh(t), b*sinh(t));
    
    // return distance, iteration count and parameter
    return vec3(length(P - p), float(i), t);
}

// Function 2476
vec4 colorMap() {
    if (rayPos.y <= -9.8) {//ground
        return texture(iChannel1,rayPos.xz*0.1);
    }
    
    
    //cube
    vec4 samp = texture(iChannel2,normalize(rayPos));
    return samp*0.3+
        samp*max(0.0,dot(lightDir,distMapNormal(rayPos)));
}

// Function 2477
vec4 GetHeatMap(float weight)
{
	// [Source]: https://www.shadertoy.com/view/llKGWG
	
	// Modulate the red component.
	float r = smoothstep(0.5f, 0.8f, weight);
	if (weight >= 0.90f)
	{
		r *= (1.1f - weight) * 5.0f;
	}
	
	// Modulate the green component.
	float g = 0.0f;
	if (weight > 0.7f)
	{
		g = smoothstep(1.0f, 0.7f, weight);
	}
	else
	{
		g = smoothstep(0.0f, 0.7f, weight);
	}
	
	// Modulate the blue component.
	float b = smoothstep(1.0f, 0.0f, weight);
	if (weight <= 0.3f)
	{
		b *= weight / 0.3f;
	}

	return vec4(r, g, b, 1.0f);
}

// Function 2478
float sd_Scene( vec3 p, int lod, float t, Ray ray )
{
	float d1 = FLT_MAX;
	float d2 = FLT_MAX;
#ifdef PRIMITIVES
// was for simple check lighting (need disable shadow hacks)
	d1 = opU( sd_bounds_range( p, -vec3( 1. ), vec3( 1. ) ), length( p - vec3( 0., 3., 0. ) ) - 1. );
#endif
#ifdef SORT_OF_MOON
	d2 = sd_DeathStarTrench( p, lod, t, ray );
#endif
	return opU( d1, d2 );
}

// Function 2479
float TreeSDF( vec3 pos )
{
    float bounds = TreeBoundsSDF(pos);
    
    pos += PATTERN_SCROLL*iTime;
	TreeSpace ts = GetTreeSpace(pos);

	float branchRand = hash1(coord2(uvec2(ts.branchGrid+0x10000)));
    float branchEndLength = .3*(branchRand-.5);
    
    return
        min(
            max(
                min(
                    min(
                        // twig
                        length(ts.twig.xy)-.005,
                        // needle
                        length( vec3( ts.needle.xy, max(0.,ts.needle.z-.05) ) ) - .003
                    ),
                    // branch
                    max(
                    	(length(ts.branch.xy
                               + .004*sin(vec2(0,6.283/4.)+ts.branch.z*6.283/.1) // spiral wobble
                              )-.01)*.9,
                    	bounds - branchEndLength - .2 // trim branches shorter than twigs
                    )
            	),
            	// branch length (with rounded tip to clip twigs nicely)
                length( vec3(ts.branch.xy,max(0.,bounds
                                              -branchEndLength  // this seems to cause more floating twigs (or more obvious ones)
                                             )) )-.3
            ),
            max(
                // trunk
                length(pos.xz)-.03,
                bounds  // this will give a sharp point - better to just chop it - but might not show it
            )
        )*.7; // the helical distortion bends the SDF, so gradient can get higher than 1:1
}

// Function 2480
void mainCubemap( out vec4 fragColor,  in vec2 fragCoord, 
                  in vec3  fragRayOri, in vec3 fragRayDir )
{
    // cache
    if( iFrame>1 )
    {
        discard;
    }
    
    //---------------------------------
    
    // dome    
    vec3 col = vec3(0.5,0.7,0.8) - max(0.0,fragRayDir.y)*0.4;
    
    // sun
    float s = pow( clamp( dot(fragRayDir,sundir),0.0,1.0),32.0 );
    col += s*vec3(1.0,0.7,0.4)*3.0;

    // ground
    float t = (-5.0-fragRayOri.y)/fragRayDir.y;
    if( t>0.0 )
    {
        vec3 pos = fragRayOri + t*fragRayDir;
        
        vec3 gcol = vec3(0.2,0.1,0.08)*0.9;
        
        float f = 0.50*noise( pos );
              f+= 0.25*noise( pos*1.9 );
        gcol *= 0.5 + 0.5*f;

        col = mix( gcol, col, 1.0-exp(-0.0005*t) );
    }


    // clouds
    vec4 res = raymarch( fragRayOri, fragRayDir, col );
    col = col*(1.0-res.w) + res.xyz;

    
    fragColor = vec4( col, 1.0 );
}

// Function 2481
float sdFace3(vec3 p) {
    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );
    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);
    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);

    return min(dI, dO);
}

// Function 2482
float mapy(vec3 p) 
{
	p.x = mod(p.x+1.,2.) - 1.0;
	vec4 q = vec4(p,1.);
	vec4 o = q;
	
for(int i = 0; i < 10; i++) {
		pR(q.yz,1.55);
		q.xyz = clamp(q.xyz, -fl, fl)*2. - q.xyz;
		float r = dot(q.xyz, q.xyz);
		q *= clamp(max(md/r, .6), 0.0, 1.);
		q = (3./md)*q-o;

	}

	return (length(q.xyz))/q.w-0.005;
}

// Function 2483
float SDFSphere(vec3 point, float radius)
{
    return length(point) - radius;
}

// Function 2484
float sceneDist(vec3 p) {
	float planeDist = getPlaneDist(p);
    
    //sphere
    vec3 spherePos = p;
    
 	//translate
    spherePos -= vec3(2,1,8);
    
    //translate y direction (wobble)
    spherePos.y += sin(iTime * 2.) * .4;
    
 	//scale (squash 50% in y dir)
    spherePos *= vec3(1,1.5,1);
    
    float sphereDist = getSphereDist(spherePos);
    
    //cube
    vec3 cubePos = p;
    
    //translate
    cubePos -= vec3(-2,1,8);
    //rotate on y axis
    cubePos.xz *= rotate(-iTime); 
    
    float cubeDist = getCubeDist(cubePos);
    
    //find the minimum distance of all objects
    float dist = min(cubeDist, sphereDist);
    dist = min(dist, planeDist);
    
    return dist;
}

// Function 2485
vec2 map(in vec3 pos) {
    const float f0 = .075;
    const float f1 = .2;
    const float f2 = .275;
    
    vec3 ph = pos;
    
    if (pos.x < 0.) {
        ph += vec3(.11, -.135, .2);
        ph = mat3(-0.8674127459526062, -0.49060970544815063, 0.08304927498102188, 0.22917310893535614, -0.5420454144477844, -0.8084964156150818, 0.4416726529598236, -0.6822674870491028, 0.5826116800308228) * ph;
    } else {
        ph.x = -ph.x;
        ph += vec3(.075, -.09, .125);
        ph = mat3(-0.6703562140464783, -0.7417424321174622, 0.020991835743188858, 0.36215442419052124, -0.3517296612262726, -0.8632093667984009, 0.6476624608039856, -0.5710554718971252, 0.5044094920158386) * ph;
    }
    
    float dh = mapHand(ph);
    
    //  right arm
    float d = sdCapsuleF(pos, vec3(0.13, 0.535, -.036), vec3(.09, 0.292, -0.1), .035, .025, f1);
    d = smin(d, sdCapsuleF(pos, vec3(.08, 0.29, -0.1), vec3(-.09, 0.15, -0.17), .03, .02, f0), .0051);
    if (pos.x < 0.) d = smin(d, dh, .015);
    
    //  left arm
    float d1 = sdCapsuleF(pos, vec3(-0.12, 0.56, .02), vec3(-0.11, 0.325, -.045), .035, .025, f1);
    d1 = smin(d1, sdCapsuleF(pos, vec3(-0.11, 0.315, -.05), vec3(.07, .08, -0.11), .024, .022, f2), .005);
    if (pos.x > 0.) d1 = smin(d1, dh, .015);
    d = min(d1, d);
    
    //  body
    vec3 bp1 = pos;
    bp1 += vec3(0, -.44, -.027);
    bp1 = mat3(0.9761762022972107, 0.033977385610342026, 0.2143024057149887, -0.07553963363170624, 0.9790945649147034, 0.18885889649391174, -0.20340539515018463, -0.20054790377616882, 0.9583353996276855) * bp1;
    float db = udRoundBox(bp1, vec3(.07 + bp1.y*.3, 0.135 -abs(bp1.x)*0.2, 0.), .04);
    
    vec3 bp2 = pos;
    bp2 += vec3(-.032, -.235, -.06);
    bp2 = mat3(0.8958174586296082, -0.37155669927597046, 0.24383758008480072, 0.3379548490047455, 0.9258314967155457, 0.16918234527111053, -0.28861331939697266, -0.0691504031419754, 0.9549453258514404) * bp2;
    db = smin(db, udRoundBox(bp2, vec3(.065 - bp2.y*.25, 0.1, .02 -bp2.y*.13), .04), .03);
    
    db = smin(db, sdCapsule(pos, vec3(0.11, 0.5, -.032), vec3(.05, 0.52, -.015), .04, .035), .01);
    db = smin(db, sdCapsule(pos, vec3(.01, 0.4, -.01), vec3(.01, 0.7, .0), .045, .04), .02);
    
    vec3 bp3 = pos;
    bp3 += vec3(-.005, -.48, .018);
    bp3 = mat3(0.9800665974617004, 0.05107402056455612, 0.19199204444885254, 0, 0.9663899540901184, -0.2570805549621582, -0.19866932928562164, 0.2519560754299164, 0.9471265077590942) * bp3;
    db = smin(db, udRoundBox(bp3, vec3(.056 + bp3.y*.23 , .06, 0.), .04), .01);
    
    d = smin(d, db, .01);
    
    //  right leg
    float d2 = sdCapsuleF(pos, vec3(0.152, 0.15, .05), vec3(-.03, 0.43, -.08), .071, .055, f2);
    d2 = smin(d2, sdCapsuleF(pos, vec3(0.14, .08, .05), vec3(-.01, 0.23, -.02), .05, .02, f1), .075);
    d = min(d, d2);
    float d3 = sdCapsuleF(pos, vec3(-.03, 0.43, -.084), vec3(.055, .04, -.04), .053, .02, f0);
    d3 = smin(d3, sdCapsuleF(pos, vec3(-.0, 0.35, -.05), vec3(.025, 0.2, -.03), .04, .02, f2), .05);
    d = min(d, d3);
    
    //  left leg
    d = min(d, sdCapsuleF(pos, vec3(-.02, 0.12, 0.1), vec3(-0.145, .08, -0.17), .07, .055, f2));
    float d4 = sdCapsuleF(pos, vec3(-0.145, .08, -0.17), vec3(0.205, .02, -0.09), .05, .0185, f0);
    d4 = smin(d4, sdCapsuleF(pos, vec3(-.05, .085, -0.145), vec3(.05, .03, -.09), .035, .03, f2), .0075);
    
    //  right feet
    float d6 = distance(pos, vec3(.0, .0, -0.1)) -.1; //  bounding sphere
    if(d6 < 0.1) {
        d = min(d, sdCapsule(pos, vec3(.03, .03, -.08), vec3(.031, .01, -0.146), .015, .005));
        d = min(d, sdCapsule(pos, vec3(.02, .03, -.08), vec3(.018, .01, -0.1505), .015, .006));
        d = min(d, sdCapsule(pos, vec3(.00, .03, -.08), vec3(.005, .01, -0.1525), .015, .007));
        d = min(d, sdCapsule(pos, vec3(-.01, .03, -.08), vec3(-.014, .01, -0.1575), .015, .01));
    } else {
        d = min(d6, d);
    }
    
    //  left feet
    float d5 = distance(pos, vec3(0.25, .025, -0.1)) -.12; //  bounding sphere
    if(d5 < 0.1) {
        d5 = sdCapsule(pos, vec3(0.2, .035, -.075), vec3(0.3, .01, -.09), .035, .02);
        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.1, .01, -0.10), .015, .02), .02);
        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.355, .034, -0.10), .015, .01), .005);
        d5 = min(d5, sdCapsule(pos, vec3(0.31, .022, -.0875), vec3(0.335, .022, -.09), .02, .01));
    }
    d4 = smin(d4, d5, .025);
    d = min(d, d4);
    
    //  hair
    vec3 hp = pos;
    hp.x += smoothstep(.55, .45, pos.y)*.035;
    hp.z *= 1.9 - .8 * pos.y;
    hp.yz -= 2.*pos.x*pos.x;
    float h = sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(-.02, 0.415, .0), .094, .085);
    h = smin(h, sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(.06, 0.705, -.05), .085, .095), .02);
    h = max(-(pos.y - abs(fract(pos.x*90.) -.5)*0.1 -.14 - smoothstep(-0.2, 0.1, pos.x)*.5), h);
    
    return (h < d) ? vec2(h, HAIR) : vec2(d, BODY);
}

// Function 2486
vec2 Scene(vec3 p)
{	
    p = vec3(p.x, p.z, -p.y); // Coord fix
    
    vec2 d = vec2(MAX_DIST, SKYDOME);    
	vec3 pEnv = p;
    d = opU(d, sdPlane(pEnv, vec4(0, 0,-1, 0), FLOOR));
                  
	vec3 boxSize = vec3(0.6*vec2(0.9, 0.6), 0.2);
    vec3 boxSizeObs = boxSize;
    boxSizeObs.z *= 5.0;

    { // obstacles 
        vec3 pObs = p - gBoxPos;		
        float c = pModInterval1(pObs.x, 8.0*boxSize.x, -5.0, 10.0);   
        float cellID = gS.playerCell + c;        
		float cellState = GetCellState(cellID, gS.seed);                

        if (cellState == CS_EMPTY_LANE)
			pObs.y = -1.0;
        else
			pObs.y -= mix( -1.0, 1.0, step(cellState, CS_LEFT_LANE - 0.1));

        pObs.y += fbm3(vec3(100000.0*cellID)) * 0.5;       
        d = opU(d, vec2( Car(vec3(pObs.x, -pObs.z, pObs.y) -vec3(0.0, 0.3, 0.0), CAR2), CAR2 )); 
    }   
	
    { // player        
        vec3 pBox = p - gBoxPos - vec3(0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5, 0.0);
        pBox.y += fbm3(vec3(100000.0*gS.playerCell)) * 0.2;
    	d = opU(d, vec2( Car(vec3(pBox.x, -pBox.z, pBox.y) -vec3(0.0, 0.3, 0.0), CAR), CAR )); 
    }
    
	return d;
}

// Function 2487
float chebyshevDistance(float p1, float p2) {
	float d1 = abs(p1 - p2);
	return d1;
}

// Function 2488
void present_scene(out vec4 fragColor, vec2 fragCoord, Options options)
{
    fragCoord /= g_downscale;
    vec2 actual_res = ceil(iResolution.xy / g_downscale);

    // cover up our viewmodel lighting hack
    bool is_ground_sample = is_inside(fragCoord, iResolution.xy - 1.) > 0.;
    if (is_ground_sample)
        fragCoord.x--;

    vec4 camera_pos = load(ADDR_CAM_POS);
    vec3 lava_delta = abs(camera_pos.xyz - clamp(camera_pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1]));
    float lava_dist = max3(lava_delta.x, lava_delta.y, lava_delta.z);
    if (lava_dist <= 0.) 
    {
        fragCoord += sin(iTime + 32. * (fragCoord/actual_res).yx) * actual_res * (1./192.);
        fragCoord = clamp(fragCoord, vec2(.5), actual_res - .5);
    }

    fragColor = texelFetch(PRESENT_CHANNEL, ivec2(fragCoord), 0);
    
    if (test_flag(options.flags, OPTION_FLAG_MOTION_BLUR))
    	apply_motion_blur(fragColor, fragCoord, camera_pos);

    fragColor.rgb = linear_to_gamma(fragColor.rgb);
}

// Function 2489
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 vn4;
  vec3 col, vn;
  float dstGrnd, f, spec, sh, dFac;
  dstGrnd = GrndRay (ro, rd);
  if (dstGrnd < dstFar) {
    ro += dstGrnd * rd;
    vn = GrndNf (ro, dstGrnd);
    f = 0.2 + 0.6 * smoothstep (0.7, 1.1, 2. * Fbm2s (16. * ro.xz));
    col = mix (mix (vec3 (0.75, 0.5, 0.1), vec3 (0.65, 0.4, 0.1), f),
       mix (vec3 (1., 0.8, 0.5), vec3 (0.9, 0.7, 0.4), f), smoothstep (1., 3., ro.y));
    col = mix (vec3 (0.7, 0.6, 0.4), col, smoothstep (0.2, 0.5, vn.y));
    spec = mix (0.05, 0.1, smoothstep (2., 3., ro.y));
    dFac = 1. - smoothstep (0.3, 0.4, dstGrnd / dstFar);
    if (dFac > 0. && vn.y > 0.85) {
      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.85, 0.9, vn.y) * dFac;
      vn4 = RippleNorm (ro.xz, vn, 6. * f);
      vn = vn4.xyz;
      col *= mix (1., 0.9 + 0.1 * smoothstep (0.1, 0.3, vn4.w), f);
    }
    if (dFac > 0.) vn = VaryNf (8. * ro, vn, dFac);
    sh = 0.3 + 0.7 * smoothstep (0.3, 0.7, Fbm2 (0.1 * ro.xz + 1.3 * tCur));
    col *= 0.2 + sh * (0.1 * vn.y + 0.7 * max (0., dot (vn, sunDir)) +
       0.1 * max (0., dot (vn, normalize (vec3 (- sunDir.xz, 0.)).xzy))) +
       spec * sh * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);
    col *= 0.8 + 0.2 * dFac;
    col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));
  } else col = SkyCol (ro, rd);
  return clamp (col, 0., 1.);
}

// Function 2490
float distanceField(vec3 p, float t, sphere s, float seed)
{
	p -= s.c;

	float rnd = rand(seed*100.0);
	t += rnd;
	t *= mix(2.0,8.0,rnd);
	t *= sign(rand(seed*20.0)-0.5);

	rnd = rand(seed*200.0);
	float rot = p.y-s.r*0.2;
	p = rotateX(p, PI*(rnd-0.5)*0.4 + sin(t)*rot*2.0);
	p = rotateZ(p, PI*(rnd-0.5)*0.2 + cos(t)*rot);
	p = rotateY(p, t);
	vec3 op = p;
	
	p.y *= 0.8;
	p.xz *= 1.1;
	float body = distSphere(p,s.r*0.5);
	
	p = op;
	p.y -= s.r*0.06;
	rot = pow(p.x,2.0)*10.0;
	p = rotateZ(p, rot*sin(t*2.0));
	p = rotateY(p, rot*cos(t*2.0));
	p.x *= 0.8;
	p.yz *= 3.0;
	float arms = distSphere(p,s.r*0.5);
	
	p = op;
	p.y -= s.r*0.2;
	p.z += s.r*0.4;
	p.x *= 2.0;
	float mouth = distSphere(p,s.r*0.1);
	
	p = op;
	p.yz += s.r*vec2(-0.3,0.3);
	vec3 o = s.r*vec3(0.2,0.0,0.0);
	float eyes = min(distSphere(p+o,s.r*0.1), distSphere(p-o,s.r*0.1));
	
	float d = smin(body,arms,0.008);
	d = max(d, -mouth);
	d = max(d, -eyes);
	return d;
}

// Function 2491
vec3 Uncharted2Tonemap(vec3 x)
{
   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

// Function 2492
float TreeBoundsSDF( vec3 pos )
{
    // just a cone
    pos.y -= 4.;
    return dot( vec2(pos.y,length(pos.xz)), normalize(vec2(.3,1)) );
}

// Function 2493
float SceneDistance(vec3 pos) {
    float dummy;
    return SceneDistance(pos, dummy);
}

// Function 2494
MapHeight Map_GetHeight( vec2 mapPos, int waterOctaves, bool detail )
{
    float groudHeight = Terrain_GetHeight( iChannelRockTexture, mapPos, detail, false );
    MapHeight result = MapHeight( groudHeight, 0 );
    
    if ( waterOctaves > 0 )
    {
        float waterHeight = Water_GetHeight(mapPos, waterOctaves, iTime );
        if (waterHeight > result.height )
        {
            result.height = waterHeight;
            result.objectId = 1;
        }
    }
    
    return result;
}

// Function 2495
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    
    for(int i=0; i<N_OBJECTS; i++ ) {
        CHECK_OBJ( objects[i] );
    }
    return ( nearestDist < 1000.0 );
}

// Function 2496
vec3 SceneNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.01, 0.0, 0.0 );
	vec3 normal = vec3(
	    Scene( pos + eps.xyy ).x - Scene( pos - eps.xyy ).x,
	    Scene( pos + eps.yxy ).x - Scene( pos - eps.yxy ).x,
	    Scene( pos + eps.yyx ).x - Scene( pos - eps.yyx ).x );
	return normalize( normal );
}

// Function 2497
vec4 mapScene(in vec3 p) {
    float csz = 0.6 + 0.5 * sin(iTime); // Cell size
    float shape = sdShape(p);

    vec3 c = floor(p / csz) * csz;

    vec3 ldb_p = c;                       // (l)eft,  (d)own, (b)ack  cell corner
    vec3 rdb_p = c + vec3(csz, 0.0, 0.0); // (r)ight, (d)own, (b)ack  cell corner
    vec3 lub_p = c + vec3(0.0, csz, 0.0); // (l)eft,  (u)p,   (b)ack  cell corner
    vec3 rub_p = c + vec3(csz, csz, 0.0); // (r)ight, (u)p,   (b)ack  cell corner
    vec3 ldf_p = c + vec3(0.0, 0.0, csz); // (l)eft,  (d)own, (f)ront cell corner
    vec3 rdf_p = c + vec3(csz, 0.0, csz); // (r)ight, (d)own, (f)ront cell corner
    vec3 luf_p = c + vec3(0.0, csz, csz); // (l)eft,  (u)p,   (f)ront cell corner
    vec3 ruf_p = c + csz;                 // (r)ight, (u)p,   (f)ront cell corner

    float ldb = sdShape(ldb_p); // Distance field sample at cell corner ldb_p
    float rdb = sdShape(rdb_p); // Distance field sample at cell corner rdb_p
    float lub = sdShape(lub_p); // Distance field sample at cell corner lub_p
    float rub = sdShape(rub_p); // Distance field sample at cell corner rub_p
    float ldf = sdShape(ldf_p); // Distance field sample at cell corner ldf_p
    float rdf = sdShape(rdf_p); // Distance field sample at cell corner rdf_p
    float luf = sdShape(luf_p); // Distance field sample at cell corner luf_p
    float ruf = sdShape(ruf_p); // Distance field sample at cell corner ruf_p

    float i = 1000000.0;

    // Checking all the cell edges for intersection and then calculating the intersection point
    if (checkEdge(lub, luf)) i = min(i, length(p - vertexInterp(lub_p, luf_p, lub, luf)) - 0.1);
    if (checkEdge(luf, ruf)) i = min(i, length(p - vertexInterp(luf_p, ruf_p, luf, ruf)) - 0.1);
    if (checkEdge(ruf, rub)) i = min(i, length(p - vertexInterp(ruf_p, rub_p, ruf, rub)) - 0.1);
    if (checkEdge(rub, lub)) i = min(i, length(p - vertexInterp(rub_p, lub_p, rub, lub)) - 0.1);
    if (checkEdge(lub, ldb)) i = min(i, length(p - vertexInterp(lub_p, ldb_p, lub, ldb)) - 0.1);
    if (checkEdge(luf, ldf)) i = min(i, length(p - vertexInterp(luf_p, ldf_p, luf, ldf)) - 0.1);
    if (checkEdge(ruf, rdf)) i = min(i, length(p - vertexInterp(ruf_p, rdf_p, ruf, rdf)) - 0.1);
    if (checkEdge(rub, rdb)) i = min(i, length(p - vertexInterp(rub_p, rdb_p, rub, rdb)) - 0.1);
    if (checkEdge(ldb, ldf)) i = min(i, length(p - vertexInterp(ldb_p, ldf_p, ldb, ldf)) - 0.1);
    if (checkEdge(ldf, rdf)) i = min(i, length(p - vertexInterp(ldf_p, rdf_p, ldf, rdf)) - 0.1);
    if (checkEdge(rdf, rdb)) i = min(i, length(p - vertexInterp(rdf_p, rdb_p, rdf, rdb)) - 0.1);
    if (checkEdge(rdb, ldb)) i = min(i, length(p - vertexInterp(rdb_p, ldb_p, rdb, ldb)) - 0.1);

    return shape < i ? vec4(shape, 1.0, 1.0, 0.0) : vec4(i, 0.5, 0.5, 0.5);
}

// Function 2498
vec3 map( in vec3 p ) {
        float sr = 1.0;  // sphere radius
        vec3 box = vec3(3.5,1.7,0.3);
        float rbox = 0.1;
        float id = 1.0;  // 3 = floor, 2 wall, 1 sphere

        // Sphere
        float distS = length(p + vec3( sin(iTime * 0.21) * 3.0,0.3,cos(iTime * 0.21) * 3.0))-sr;
        
        // First wall
        float distQ = length(max(abs(p)-box,0.0))-rbox;
        // Cuboid moved 2.0 to the right (2on wall)
        float distQ2 = length(max(abs(p + vec3(-2.0,.0,2.0)) - vec3(0.3,1.7,3.5), 0.0))-rbox;

        // Window in the wall
        vec3 d = abs(p) - vec3(0.5,0.8,1.0);
        float distQ3 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));

        // External wall (parcel limit) without ceiling
        vec3 d2 = vec3(10.0,2.0,10.0) - abs(p);
        float distQ4 = max( min( d2.x,  d2.z ), -d2.y );

        // Column
        float distCol = length(max(abs(p + vec3(2.5,.0,4.5)) - vec3(0.3,1.7,0.3), 0.0))-rbox;


        float distTot = min( min( distS, distQ), distQ2 );
        distTot = max( -distQ3,distTot );
        distTot = min( distCol,distTot );
        distTot = min( distTot, distQ4 );

        if (distS > distTot) {
            id = 2.0;
        }

        float distP = p.y + 1.6;

        if (distP < distTot) {
            id = 3.0;
        }

        distTot = min(distP, distTot);

        return vec3(distTot, id, 0.0 );
    }

// Function 2499
float dist(vec3 pos)
{
    return distTor(pos);
}

// Function 2500
vec2 map(vec3 pos)
{
    vec2 fpos = fract(pos.xz); 
	vec2 ipos = floor(pos.xz);
    
    float rid = hash21(ipos) + 0.5;

    return vec2(fCapsule(vec3(fpos.x - 0.5, pos.y, fpos.y - 0.5), vec3(0.0, 0.0, 0.0), vec3(0.0, HEIGHT, 0.0), 0.1), rid);
}

// Function 2501
float map(float a, float b, float t) {return a + t * (b - a); }

// Function 2502
float map(vec2 p){
	float color = 0.0;
	for(int i=0;i<10;i++){
	color+=cos(50.0*distance(vec2(rnd(i),rnd(20-i)),p))*0.01;
	}
	//color+=cos(distance(vec2(0.0,0.0),p)*50.0+iTime)*0.01;
    color+=sin(acos(distance(vec2(0.0,0.0)/2.,p)*2.))*10.0;
return color*0.1;}

// Function 2503
float remap_11to01(float a)
{
    return a * 0.5 + 0.5;
}

// Function 2504
float Map(vec3 p)
{
    float d = -sdSphere(p,200.0);
    
    float Rcr = module*(Zsp+Zmp)/2.0; //Center distance
    
    vec3 pSph = p * rotate(csAng);
    vec3 pMPA = (p - vec3(Rcr,0,0)) * rotate(vec3(-mPA+90.,0,2.0*mRA));
    vec3 pMPB = (p - vec3(0,Rcr,0)) * rotate(vec3(0,mPB+90.,2.0*mRB+90.));
    
    d = opU(d, sdCSGear(pSph, Zsp, module));   
    d = opU(d, sdMonopoleGear(pMPA, Zsp, Zmp, module, module*12.0));
    d = opU(d, sdMonopoleGear(pMPB, Zsp, Zmp, module, module*12.0));
    
    return d;
}

// Function 2505
float spiralSDF(vec2 st, float t) { // 47
    st -= .5;
    float r = dot(st, st);
    float a = atan(st.y, st.x);
    return abs(sin(fract(log(r) * t + a * 0.159)));
}

// Function 2506
float cubeDist( vec3 pos, float radius)
{
    return udBox( pos, vec3(radius)) -.6;
}

// Function 2507
vec4 map_sat(vec2 fragCoord) {
    vec2 p = fragCoord;
    vec2 uv = p / iResolution.xy;
    float y = buf(p).z;
    float lat = 180. * uv.y - 90.;
    float lon = 360. * uv.x - 180.;
    float height = MAP_HEIGHT(y);
    vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);
    float light = cos(atan(grad.y, grad.x) + 0.25*PI);
    float illum = 0.75 + 0.25 * light * clamp(log(1. + length(grad)), 0., 1.);
    float clouds = 1.;
    
    vec4 ocean = mix(vec4(0.01, 0.02, 0.08, 1), vec4(0.11, 0.28, 0.51, 1), y / OCEAN_DEPTH);
    
    if ((SLOWING_START_TIME < iTime && iTime < STORY_END_TIME) || keypress(KeyS)) {
        vec3 q = fromlatlon(lat, lon);
        vec2 ngrad = normalize(grad);
        vec3 orient = normalize(fromlatlon(lat - ngrad.y, lon - ngrad.x) - q);
        vec3 normal = normalize(mix(q, orient, 0.25 * clamp(log(1. + length(grad)), 0., 1.)));
        vec3 sun = sun_pos(iTime);
        float m = smoothstep(-1., 0., iTime - DAYNIGHT_START_TIME);
        illum = clamp(mix(illum, dot(normal, sun), m), 0., 1.);
        clouds *= mix(1., dot(q, sun), m);
        ocean *= mix(1., dot(q, sun), m);
    }
    
    float temp0 = climate(p, PASS3).z;
    float temp = temp0 - mix(4., 3., smoothstep(WARMING_START_TIME, WARMING_END_TIME, iTime)) * height;
    
    // dry land
    vec3 dry = vec3(0.89, 0.9, 0.89);
    dry = mix(dry, vec3(0.11, 0.10, 0.05), smoothstep(-10., 0., temp));
    dry = mix(dry, vec3(1.00, 0.96, 0.71), smoothstep( 0., 20., temp));
    dry = mix(dry, vec3(0.81, 0.48, 0.31), smoothstep(20., 30., temp));

    // vegetation
    vec3 veg = vec3(0.89, 0.9, 0.89);
    veg = mix(veg, vec3(0.56, 0.49, 0.28), smoothstep(-10., 0., temp));
    veg = mix(veg, vec3(0.18, 0.34, 0.04), smoothstep( 0., 20., temp));
    veg = mix(veg, vec3(0.05, 0.23, 0.04), smoothstep(20., 30., temp));

    float moisture = texture(iChannel3, uv).w;
    vec4 land = vec4(0,0,0,1);
    land.rgb = mix(dry, veg, plant_growth(moisture, temp));
    //land.rgb = mix(dry, veg, moisture/5.);
    land.rgb *= illum;
    if (iTime < LAND_END_TIME) {
        float c = (15. - y) / 3.5;
        float heat = clamp(2. / pow(iTime + 1., 2.), 0., 1.);
        vec4 rock = mix(vec4(0.58, 0.57, 0.55, 1), vec4(0.15, 0.13, 0.1, 1), smoothstep(0., 3., c));
        rock *= light * clamp(0.2 * length(grad), 0., 1.);
        rock += 5. * c * heat * vec4(1., 0.15, 0.05, 1.);
        land = mix(rock, land, smoothstep(LAND_START_TIME, LAND_END_TIME, iTime));
    }
    vec4 r = vec4(0,0,0,1);
    if (y < OCEAN_DEPTH && iTime > OCEAN_START_TIME) {
        r = mix(land, ocean, smoothstep(0., 2., iTime - OCEAN_START_TIME));
    } else {
        r = land;
    }
    
    float vapour = texture(iChannel2, uv).w;
    r.rgb = mix(r.rgb, vec3(1), 0.3 * clouds * log(1. + vapour) * smoothstep(0., LAND_END_TIME, iTime));
    return r;
}

// Function 2508
vec3 RgbTonemap(vec3 rgbLinear)
{
	// Desaturate with luminance

	float gLuminance = GLuminance(rgbLinear);
	rgbLinear = mix(rgbLinear, vec3(gLuminance), GSqr(saturate((gLuminance - 1.0) / 1.0)));

	// Hejl/Burgess-Dawson approx to Hable operator; includes sRGB conversion

	vec3 rgbT = max(vec3(0.0), rgbLinear - 0.004);
	vec3 rgbSrgb = (rgbT * (6.2 * rgbT + 0.5)) / (rgbT * (6.2 * rgbT + 1.7) + 0.06);

	return rgbSrgb;
}

// Function 2509
float distanceToBlobs(vec2 p, out vec3 color)
{
    //Blob movement range.
    float mvtAmplitude = 0.15;
    
    //Randomized positions.
    vec2 blob1pos = vec2(-0.250, -0.020)+randomizePos(vec2(0.35,0.45)*mvtAmplitude,iTime*1.50);
	vec2 blob2pos = vec2( 0.050,  0.100)+randomizePos(vec2(0.60,0.10)*mvtAmplitude,iTime*1.23);
	vec2 blob3pos = vec2( 0.150, -0.100)+randomizePos(vec2(0.70,0.35)*mvtAmplitude,iTime*1.86);
    
    //Distance from pixel "p" to each blobs
	float d1 = length(p-blob1pos);
    float d2 = length(p-blob2pos);
    float d3 = length(p-blob3pos);
    
    //Merge distances, return the distorted distance field to the closest blob.
    float distTotBlob = mergeBlobs(d1,d2,d3);
    
    //Compute color, approximating the contribution of each one of the 3 blobs.
    color = computeColor(d1,d2,d3);
        
    return abs(distTotBlob);
}

// Function 2510
float distToExitAtmosphere(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_R * A_R;
    return max(-r * mu + sqrt(max(discriminant, 0.)), 0.);
}

// Function 2511
float Scene(vec2 p)
{
    vec2 f;
    ivec2 i = voxid(p);
    if (!isVoxel(i)) {
        return 3.4e38; // HACK simply ignore neighbors in 2D
        //float dmin = 3.4e38;
        // basic 3x3 kerning, inefficient
        // allows shapes to butt right up
        // against the edge of their cells
        // without causing neighboring cell
        // signed distance artifacts.
        // the per-tile coloration isn't
        // considered here though FIXME
        // so we couldn't get away with poofing
        // them much anyway.  And without
        // any other need for it, in 2D, this
        // loop is really just unnecessary.
        //for (int y = -1; y <= 1; ++y)
        //    for (int x = -1; x <= 1; ++x)
        //        dmin = min(dmin, dlod(i+ivec2(x,y), p-vec2(x,y)));
        //return dmin;
    }
	f = p - voxpos(i); // relative to closest cell
    int id = ComputeHitId(i);
    return shape(f, id);
}

// Function 2512
float sceneSDF(vec3 p) {
    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));
    p.y *= 1.0;
    return (-p.y+20.0-heightmap(p.xz))*scale/2.0;
}

// Function 2513
float SDF (vec3 p) {
    return min(iceSDF(p), steelSDF(p));
}

// Function 2514
vec2 sphDistances( vec3 ro, vec3 rd, vec4 sph )
{
    vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;
    return vec2( d, -b-sqrt(max(h,0.0)) );
}

// Function 2515
rtIntersection rayTraceScene(vec3 ro,vec3 rd)
{
    float maxt=10000.0;
    rtIntersection noResult=rtIntersection(-1.0,vec3(0.0),vec3(0.0),0);

    rtIntersection resultSphere;
    if (intersectSphere(.3,vec3(0.0,.3,4.5+5.0*sin(iTime/2.0)),ro,rd,resultSphere))
    {
        maxt=resultSphere.dist;
        resultSphere.material=0;
    }

    rtIntersection resultSphere2;
    if (intersectSphere(0.23,vec3(.8*sin(iTime),.2,-1.*cos(iTime)),ro,rd,resultSphere2))
    {
        maxt=min(maxt,resultSphere2.dist);
        resultSphere2.material=3;
    }

    rtIntersection resultSphere3;
    if (intersectSphere(.2,vec3(cos(iTime),.2,-0.25),ro,rd,resultSphere3))
    {
       	maxt=min(maxt,resultSphere3.dist);
        resultSphere3.material=1;
    }
    
    rtIntersection resultPlane;
    if (intersectPlane(vec3(0.0,1.0,0.0),ro,rd,resultPlane))
    {
        maxt=min(maxt,resultPlane.dist);
        resultPlane.material=2;
    }

    rtIntersection resultPlane2; // Up
    if (intersectPlane(vec3(0.0,-1.0,0.0),ro-vec3(0.0,2.0,0.0),rd,resultPlane2))
    {
        maxt=min(maxt,resultPlane2.dist);
        resultPlane2.material=2;
    }

    rtIntersection resultPlane3;
    if (intersectPlane(vec3(1.0,0.0,0.0),ro-vec3(-1.2,0.0,0.0),rd,resultPlane3))
    {
        maxt=min(maxt,resultPlane3.dist);
        resultPlane3.material=2;
    }

    rtIntersection resultPlane4;
    if (intersectPlane(vec3(-1.0,0.0,0.0),ro-vec3(1.2,0.0,0.0),rd,resultPlane4))
    {
        maxt=min(maxt,resultPlane4.dist);
        resultPlane4.material=2;
    }

    const int numBoxes=4;
    rtIntersection resultBoxes[numBoxes];
    float boxDist[numBoxes];
    if (iTime>=(60.0/globalTempo)*32.)
    {
        for (int b=0;b<numBoxes;b++)
        {
            float x=0.2;//float(b)*0.1;
            float y=1.9;//mod(float(b)*234.0,4.0);
            vec3 dimensions=vec3(1.5,.1,2.2);

            if (b==2)
            {
                x=.5;
                dimensions=vec3(0.2,2.1,2.2);
            }

            if (b==0)
            {
                x=-0.1;
                dimensions=vec3(0.2,2.1,2.2);
            }

            vec3 resNormal;
            boxDist[b]=intersect_box(ro-vec3(-.7+x*4.0,y,-64.0+mod(32.0*iTime+float(b)*32.0,128.0)),rd,resNormal,
                                     dimensions);
            if (boxDist[b]!=INFINITY)
            {
                maxt=min(maxt,boxDist[b]);
                resultBoxes[b].material=b+4;
                resultBoxes[b].dist=boxDist[b];
                resultBoxes[b].normal=resNormal;
            }
        }
    }
    
    if (maxt==resultSphere.dist) return resultSphere;
    if (maxt==resultSphere2.dist) return resultSphere2;
    if (maxt==resultSphere3.dist) return resultSphere3;
    if (maxt==resultPlane.dist) return resultPlane;
    if (maxt==resultPlane2.dist) return resultPlane2;
    if (maxt==resultPlane3.dist) return resultPlane3;
    if (maxt==resultPlane4.dist) return resultPlane4;
    
    if (iTime>=(60.0/globalTempo)*32.)
    {
        for (int b=0;b<numBoxes;b++)
        {
            if (maxt==boxDist[b]) return resultBoxes[b];
        }
    }
        
    return noResult;
}

// Function 2516
vec2 map( in vec3 p )
{
    // monster
    vec2 res = sdMonster( p );

    // terrain
	float d2 = 0.5*(p.y - terrain(p.xz));
	if( d2<res.x ) res=vec2(d2,2.0);
	
	return res;
}

// Function 2517
float mapWeb( vec3 p, float t, float tb)
{
    /*float t = 3.14/4.0;
    float tb = 3.14;*/
    float ct = cos(t);
    float st = sin(t);
    float ctb = cos(20.0*tb);
    float stb = sin(20.0*tb);
    p.y -= 5.0;
    mat2 b = mat2(ctb, -stb,stb, ctb);
    p.xy = p.xy*b;
    p =p*mat3(
        1.0, 0.0, 0.0,
        0.0, ct, -st,
        0.0, st, ct);
    return sdCapsule(p, vec3(0.0, 20.0, 0.0), vec3(0.0, 00.0, 0.0), 0.3);
}

// Function 2518
vec3 envmap(vec3 p)
{
    vec3 nc=vec3(step(fract(atan(p.y+p.z,p.x)*1.),.1))*.2;
    for(int i=0;i<10;++i)
        nc=mix(nc,vec3(.5+.5*cos(float(i)/3.))*2.,smoothstep(0.,.01,
                                                             dot(normalize(vec3(cos(float(i)*7.5),sin(float(i)*2.),cos(float(i)*3.)+.5)),
                                                                 normalize(p))-
                                                             mix(.8,1.,pow(.5+.5*cos(float(i)*5.),.5))));
    return (nc+.1)+pow(length(cos(p*10.)),2.)*.1;
}

// Function 2519
vec2 sceneSDF(vec3 p) {
    float deg = 90.0;
    float sr = 2.0;
    float lr = 2.0;
    float SR = 1.8;
    float LR = 1.5;
    float spheres[12];
    float vTime = iTime;
    
    float id = 1.0;
    for (int i = 0; i < 4; i ++) {
        float dx = SR * cos(90.0 * id * PI / 180.0);
        float dz = SR * sin(90.0 * id * PI / 180.0);
        vec3 v = vec3(p.x + dx, p.y, p.z + dz);
        spheres[i] = sphereSDF(v, sr);
        id += 1.0;
    }
    spheres[4] = sphereSDF(vec3(p.x, p.y + LR, p.z), lr);
    spheres[5] = sphereSDF(vec3(p.x, p.y - LR, p.z), lr);
    
    
    
    float torus[3];
    float t_ry = 0.1;
    float t_rxl = 16.0;
    float t_rxs = 12.0;
    float alpha0 = vTime;
    float alpha1 = vTime + 90.0 * PI / 180.0;
    torus[0] = sdTorus( rotX(p, alpha0), vec2(t_rxl, t_ry) );
    torus[1] = sdTorus( rotZ(p, alpha0), vec2(t_rxs, t_ry) );
    torus[2] = sdTorus( rotZ(p, alpha1), vec2(t_rxs, t_ry) );
    
    float ssr = 0.3;
    spheres[6] = sphereSDF(vec3(p.x, p.y - t_rxl * sin(alpha0), p.z + t_rxl * cos(alpha0)), ssr);
    spheres[7] = sphereSDF(vec3(p.x, p.y + t_rxl * sin(alpha0), p.z - t_rxl * cos(alpha0)), ssr);
    spheres[8] = sphereSDF(vec3(p.x - t_rxl, p.y, p.z), ssr);
    spheres[9] = sphereSDF(vec3(p.x + t_rxl, p.y, p.z), ssr);
    
    spheres[10] = sphereSDF(vec3(p.x - t_rxs * cos(alpha0), p.y - t_rxs* sin(alpha0), p.z), ssr);
    spheres[11] = sphereSDF(vec3(p.x - t_rxs * cos(alpha1), p.y - t_rxs* sin(alpha1), p.z), ssr);
    
    float objId = 0.0;
    //horizontal spheres
    vec2 combined = unionSDF(vec2(spheres[0], objId), vec2(spheres[1], objId));
    combined = unionSDF(combined, vec2(spheres[2], objId));
    combined = unionSDF(combined, vec2(spheres[3], objId));
    
    //lower sphere
    objId++;
    combined = unionSDF(combined, vec2(spheres[4], objId));
    
    //upper sphere
    objId++;
    combined = unionSDF(combined, vec2(spheres[5], objId));
    
    //small spheres
    objId++;
    combined = unionSDF(combined, vec2(spheres[6], objId));
    combined = unionSDF(combined, vec2(spheres[7], objId));
    combined = unionSDF(combined, vec2(spheres[8], objId));
    combined = unionSDF(combined, vec2(spheres[9], objId));
    combined = unionSDF(combined, vec2(spheres[10], objId));
    combined = unionSDF(combined, vec2(spheres[11], objId));
    
    //large tortus
    objId++;
    combined = unionSDF(combined, vec2(torus[0], objId));
    
    //small tortus
    objId++;
    combined = unionSDF(combined, vec2(torus[1], objId));
    combined = unionSDF(combined, vec2(torus[2], objId));
    
  
    
   return combined;
}

// Function 2520
void InitScene()
{
    // current lightmap packing:
    //         ___
    //        | T |
    //     ___|___|___
    //    | L | B | R |
    //    |___|___|___|
    //Box +XYZ| F |
    //    -X Z|___|
    //
    
    // block - first because a hit on this is likely to be closer than background walls,
    // so only compute local frame etc once
    vec3 bc = vec3(0.,-3.5,0.);
    quads[ 0] = Quad( bc+vec3(0.,0.,-1.5),	vec3(0.,0.,-1.),	vec2(3.),	vec2(2.5/9.,.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 1] = Quad( bc+vec3(1.5,0.,0.),	vec3(1.,0.,0.),		vec2(3.),	vec2(.5/9.,1.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 2] = Quad( bc+vec3(-1.5,0.,0.),	vec3(-1.,0.,0.),	vec2(3.),	vec2(.5/9.,.5/6.),	vec2(1./9.,1./6.),	3 );
    quads[ 3] = Quad( bc+vec3(0.,1.5,0.),	vec3(0.,1.,0.),		vec2(3.),	vec2(1.5/9.,1.5/6.),vec2(1./9.,1./6.),	3 );
    quads[ 4] = Quad( bc+vec3(0.,0.,1.5),	vec3(0.,0.,1.),		vec2(3.),	vec2(2.5/9.,1.5/6.),vec2(1./9.,1./6.),	3 );
    
    // floor
    quads[ 5] = Quad(	vec3(0.,-5.,0.),	vec3(0.,1.,0.),		vec2(10.),	vec2(0.5,1./6.),	vec2(1./3.,1./3.),	0 );
    // back
    quads[ 6] = Quad(	vec3(0.,0.,5.),		vec3(0.,0.,-1.),	vec2(10.),	vec2(0.5,.5),		vec2(1./3.,1./3.),	0 );
    // ceil
    quads[ 7] = Quad(	vec3(0.,5.,0.),		vec3(0.,-1.,0.),	vec2(10.),	vec2(0.5,5./6.),	vec2(1./3.,1./3.),	0 );
    // left wall
    quads[ 8] = Quad(	vec3(-5.,0.,0.),	vec3(1.,0.,0.),		vec2(10.),	vec2(1./6.,.5),		vec2(1./3.,1./3.),	1 );
    // right wall
    quads[ 9] = Quad(	vec3(5.,0.,0.),		vec3(-1.,0.,0.),	vec2(10.),	vec2(5./6.,.5),		vec2(1./3.,1./3.),	2 );
    // front
    //quads[10] = Quad(	vec3(1000.,0.,-5.),	vec3(0.,0.,1.),		vec2(0.),	vec2(100./6.,.5),	vec2(1./3.,1./3.),	0 );
    
    // bring in by HALF a pixel on each edge to stop lerping into the lightmap for another quad
    for( int i = 0; i < QUAD_COUNT; i++ )
    {
        quads[i].uv_wh -= 1./LM_RES;
    }
}

// Function 2521
vec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
    vec3 m = pow( abs(n), vec3(k) );
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 2522
float heighMap(vec2 U)
{
    float value = fbm(U);    
    
    U/=2.;
    float v2 = turbulence(0.2*U)-0.1;
  	
    value = clamp(((v2 - value) + 0.3)*2.0,-10.0,1.0);
    if(value <= 0.05 && value > -0.40) value = 0.05 * smoothstep(-0.15, 0.06, value);
    else if(value < -0.4) value = 0.1*smoothstep(-0.4, -0.6, value);
    
    return value;    
}

// Function 2523
float shadowMap3D(vec3 pos)
{
    float t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));
    t = min(t, sphere(pos, 2.0, greenSpherePos));
    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));
    return t;
}

// Function 2524
vec3 scene_color(vec3 p){ // Disjoint function so you only evaluate colors once
	float d = 1e10;
	
	vec3 col = vec3(0.0);
	
	if (ground < d){
		col = ground_color;
		d = ground;
	}
	
	if (box1 < d){
		col = box1_color;
		d = box1;
	}
	
	if (box2 < d){
		col = box2_color;
		d = box2;
	}
	
	if (box3 < d){
		////////////////////////
        float aspect = iResolution.x/iResolution.y;

		vec4 tex =  texture(iChannel0, mod(p.xy * 0.15 * vec2(1.0, aspect), 1.0));
		col = box3_color + (tex*tex + tex*0.5).xyz; // Higher Contrast!
		d = box3;
	}
	
	if (box4 < d){
		col = box4_color;
		d = box4;
	}
	
	if (sphere1 < d){
		col = sphere1_color;
		d = sphere1;
	}
	
	if (sphere2 < d){
		col = sphere2_color;
		d = sphere2;
	}
	
	if (torus < d){
		col = torus_color;
		d = torus;
	}
	
	return col;
}

// Function 2525
float planeSDF(vec3 p, vec4 plane) { return dot(p - plane.w, plane.xyz); }

// Function 2526
float sdf(vec3 p, Ray camera)
{
    p = GetGliderTransform(p, camera);
    p.xyz = p.xzy;
    
    vec3 backP = p;
    vec3 frontP = p;
    vec3 bottomP = p;
    
    float wind =  mix(.9,1.0, sin((p.x+iTime)*40.0));
    
    p.y *= 1.3;
    p.y += smoothstep(-.1, .75, p.y) * abs(sin(p.x * 90.0)) * .2;
    p.z += abs(p.x) * wind * -.4;
    
    float d = sdTriPrism(p, vec2(.1, .0));
    
    backP.y -= .12;
    backP.y *= -1.0;
    backP.z -= abs(backP.x) * .2 + wind * .01 - .01;
    d = min(d, sdTriPrism(backP, vec2(.02, .0)));
    
    bottomP.xyz = bottomP.xzy;
    bottomP.zy += vec2(-.025, .015);
    float r = smoothstep(.025, -.07, bottomP.z);
    d = min(d, sdRoundedCylinder(bottomP, .03 * r, .005, .01));
    
	return d * .5;
}

// Function 2527
float map(vec3 p) {
    float k = 0.5 * 2.0;
	vec3 q = (fract((p - vec3(0.25, 0.0, 0.25))/ k) - 0.5) * k;
    vec3 s = vec3(q.x, p.y, q.z);
    float d = udRoundBox(s, vec3(0.1, 1.0, 0.1), 0.05);
    
    k = 0.5;
    q = (fract(p / k) - 0.5) * k;
    s = vec3(q.x, abs(p.y) - 1.5, q.z);
    float g = udRoundBox(s, vec3(0.17, 0.5, 0.17), 0.2);
    
    float sq = sqrt(0.5);
    vec3 u = p;
    u.xz *= mat2(sq, sq, -sq, sq);
    d = max(d, -sdBoxXY(u, vec3(0.8, 1.0, 0.8)));
    
    return smin(d, g, 16.0);
}

// Function 2528
void construct_scene(inout Scene scene, inout vec3 Le, uint scene_idx)
{
    if (scene_idx==0u) /* First scene: Some spheres */
    {
        Le = vec3(1.0);
        
        int mat_idx;
        mat_idx = add(scene, create_mirror(vec3(1.0, 0.3, 0.1)));
        add(scene, 
            Sphere(vec3(0,0,0), 1.0, mat_idx)
        );
        
        mat_idx = add(scene, create_Lambertian(vec3(0.8)));
        add(scene, 
            Sphere(vec3(0,-101, 0), 100.0, mat_idx)
        );

        mat_idx = add(scene, create_Lambertian(vec3(0.3, 1.0, 0.0)));
        add(scene, 
            Sphere(vec3(1,3,-1), 1.7, mat_idx)
        );
    }
    else /* Second scene: Cornell Box */
    {
        Le = vec3(0.05);
        int mat_idx;
        /* Cornell box */
        float scale = 8.0;
        vec3 cb_offset = vec3(0);
        vec3 dim = scale*vec3(1.3, 1.7, 1.0);
        vec3 v1,e1,e2;
        vec3 col;

        /* back wall */
        v1 = 0.5*vec3(-dim.x, -dim.y, dim.z);
        e1 = vec3(dim.x, 0, 0);
        e2 = vec3(0, dim.y, 0);
        col = vec3(0.5, 0.5, 0.2);

        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* left wall */
        v1 = -0.5*dim;
        e1 = vec3(0,0,dim.z);
        e2 = vec3(0,dim.y,0);
        col = vec3(1.0, 0.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* right wall */
        v1 = 0.5*vec3(dim.x, -dim.y, -dim.z);
        e1 = vec3(0,0,dim.z);
        e2 = vec3(0,dim.y,0);
        col = vec3(0.1, 0.1, 1.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* top wall */
        v1 = 0.5*vec3(-dim.x, dim.y, -dim.z);
        e1 = vec3(0,0,dim.z);
        e2 = vec3(dim.x,0,0);
        col = vec3(0.0, 1.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        //float flicker_speed = 0.0;
        //scene.materials[mat_idx].Le = vec3((1.0+sin(flicker_speed*iTime))*vec2(1.0),0.0);
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* bottom wall */
        v1 = -0.5*dim;
        e1 = vec3(0,0,dim.z);
        e2 = vec3(dim.x,0,0);
        col = vec3(1.0, 1.0, 1.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );
        
        /* lamp */
        float lamp_scale = 0.5;
        v1 = 0.5*vec3(-lamp_scale*dim.x, dim.y*0.98, -lamp_scale*dim.z);
        e1 = lamp_scale*vec3(0,0,dim.z);
        e2 = lamp_scale*vec3(dim.x,0,0);
        col = vec3(0.0, 0.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        scene.materials[mat_idx].Le = vec3(5.0);
        /*add(scene, 
            Sphere(
                vec3(0), 3.0, 
                mat_idx
            )
        );*/
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );
        
    }
}

// Function 2529
float lineDist(vec2 p, vec2 start, vec2 end, float width)
{
  vec2 dir = start - end;
  float lngth = length(dir);
  dir /= lngth;
  vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;
  return length( (start - p) - proj ) - (width / 2.0);
}

// Function 2530
vec2 MapEllipDisk(vec2 p) {
    vec2 v = 2.0 * p - 1.0;
    return v * sqrt(1. - 0.5 * v.yx * v.yx);
}

// Function 2531
Model map(vec3 p) {
    //vec2 im = iMouse.xy / iResolution.xy;     
    vec2 im = vec2(.43,.43);
    pR(p.yz, (.5 - im.y) * PI);
    pR(p.xz, (.5 - im.x) * PI * 2.5);
    
    p.y += .6;
    p.xz -= vec2(-1,1) * .4;
    
    float d = p.y + .25;    
    d = smin(d, length(p - vec3(.6,-2.5,-.7)) - 2.5, .6);
    d = smin(d, length(p - vec3(-.3,-.5,.5)) - .5, .4);

    float d2 = sdCrystalField(p);

    float df = pow(d2 + .333, .5) * 1.5;
    float ripple = 7.;    
    d += cos(max(df, 0.) * ripple * PI * 2.) * .015;

    Model m = Model(d, 2);
    Model m2 = Model(d2 * invert, 1);
    
    if (m2.d < m.d) {
        m = m2;
    }

    return m;
}

// Function 2532
vec2 ComputeLightmapUV(Object obj, vec3 V, sampler2D lightmapSampler)
{
    vec2 lightmapUV = vec2(-1);
    vec2 lightmapResInv = 1.0/vec2(textureSize(lightmapSampler, 0)); // we could pass this in ..
    if (IsQuad(obj)) {
        vec2 st;
        st.x = dot(V, obj.quadBasisX);
        st.y = dot(V, obj.quadBasisY);
        vec2 uv = st*0.5 + vec2(0.5); // [0..1]
        vec4 atlasBounds = obj.lightmapBounds;
        atlasBounds.zw -= atlasBounds.xy; // width, height
        if (float(LIGHTMAP_QUAD_INSET) < 0.5) { // don't sample outside the lightmap bounds (if we are filtering)
            vec2 uvmin = vec2(0.5)/atlasBounds.zw;
            vec2 uvmax = vec2(1) - uvmin;
            uv = clamp(uv, uvmin, uvmax);
        }
        atlasBounds *= lightmapResInv.xyxy;
        lightmapUV = atlasBounds.xy + atlasBounds.zw*uv;
    } else {
        int faceRow;
        int faceCol;
        vec2 facePos;
        vec3 Va = abs(V);
        float Vamax = max(max(Va.x, Va.y), Va.z);
        if (Vamax == Va.x) {
            faceCol = 0;
            faceRow = V.x < 0.0 ? 1 : 0;
            facePos = V.yz/Va.x;
        } else if (Vamax == Va.y) {
            faceCol = 1;
            faceRow = V.y < 0.0 ? 1 : 0;
            facePos = V.zx/Va.y;
        } else { // Vamax == Va.z
            faceCol = 2;
            faceRow = V.z < 0.0 ? 1 : 0;
            facePos = V.xy/Va.z;
        }
        vec2 faceUV = facePos*0.5 + vec2(0.5); // [0..1]
        float faceRes = GetLightmapSphereFaceRes(obj);
        vec2 faceBoundsMin = vec2(faceCol + 0, faceRow + 0)*faceRes + vec2(LIGHTMAP_SPHERE_FACE_INSET);
        vec2 faceBoundsMax = vec2(faceCol + 1, faceRow + 1)*faceRes - vec2(LIGHTMAP_SPHERE_FACE_INSET);
        vec2 uv = obj.lightmapBounds.xy + faceBoundsMin + (faceBoundsMax - faceBoundsMin)*faceUV;
        lightmapUV = uv*lightmapResInv;
    }
    return lightmapUV;
}

// Function 2533
vec3 robobo1221sTonemap(vec3 x){
    return x / sqrt(x*x + 1.0);
}

// Function 2534
vec3 distribSphere(vec2 uv)
{
    uv = fract(uv);
    uv.y = uv.y * 2. - 1.;
    return vec3(sqrt(max(0., 1. - uv.y*uv.y))
                * sin(vec2(.5*pi, 0) + uv.x * 2.*pi)
                , uv.y);
}

// Function 2535
vec2 map( vec3 p, float t )
{

    // ground
    vec3 s = p;
    s.y -= 0.1*sin( 0.25*p.z + 0.5*sin(0.25*p.x) );    
    s.y += 0.1*cos( 0.25*p.z + 0.5*cos(0.25*p.x) );        
    
    vec3 dpdx = t*drddx;
    vec3 dpdy = t*drddy;
    

    vec3 dsdx = dpdx - 0.1*cos( 0.25*p.z + 0.5*sin(0.25*p.x) )*(0.25*dpdx.z + 0.5*cos(0.25*p.x)*dpdx.x );
    vec3 dsdy = dpdy + 0.1*sin( 0.25*p.z + 0.5*cos(0.25*p.x) )*(0.25*dpdx.z - 0.5*sin(0.25*p.x)*dpdx.x );

    float d2 = s.y - 0.17;
    if( d2<2.0 )
    {
    d2 += 0.06*textureGrad( iChannel2, 0.15*s.xz, 0.15*dsdx.xz, 0.15*dsdy.xz ).x;
        
    d2 -= 1.5*pow(textureGrad( iChannel3, 0.01*s.xz,  0.01*dsdx.xz/256.0, 0.01*dsdy.xz/256.0 ).x,0.35) - 0.8;
    //d2 -= 1.5*pow(textureImproved( iChannel3, 0.01*s.xz,  0.01*dsdx.xz/256.0, 0.01*dsdy.xz/256.0 ).x,0.35) - 0.8;
            
    }
    d2 *= 0.8;
    vec2 res = vec2(d2,1.0);
    
    
    // mushroom
    vec3 d = vec3(0.0,0.95,0.0);
    vec3 q = p - d;
   
    float bb = length(q+vec3(0.0,0.3,0.0))-0.8;
    if( bb<0.0 )
    {
        // animate
        //float an = 0.5 + 0.5*cos(2.0*iTime + 9.0* p.y);
        //q.xz *= 1.1 - an*0.2*(1.0-smoothstep( 0.0, 0.6, abs(q.y+0.1) ));

        // stem
        float h = clamp(q.y+1.0,0.0,1.0);
        vec3 o = 0.12 * sin( h*3.0 + vec3(0.0,2.0,4.0) );
        o = o*4.0*h*(1.0-h) * h;
        float d1 = sdSegment( q + vec3(0.0,1.0,0.0) - o*vec3(1.0,0.0,1.0), vec3(0.0,0.0,0.0), vec3(0.0,1.0,0.0) ).x;
        d1 -= 0.04;
        d1 -= 0.1*exp(-16.0*h);

        float d3 = head( q );

        // mix head and stem
        d1 = smin( d1, d3, 0.2 );
        d1 *= 0.75;
        vec2 res2 = vec2(d1,0.0);


        // balls
        float ff = 10.0;
        vec3 id = floor(q*ff);
        vec3 wr = (id*2.0 + 1.0)/(2.0*ff);
        //wr += (-1.0+2.0*hash3(id)) * 0.2/ff;
        if( head2( wr )<0.0 )
        {
        vec3 r = (fract(q*ff) - 0.5)/ff;
        //r += (-1.0+2.0*hash3(id)) * 0.2/ff;
        float d5 = (length(r)-0.03);
        //vec3 n = abs(normalize(wr));
        //float d5 = sdEllipsoid( r, vec3(0.0), vec3(0.03) );
        if( d5<res2.x ) res2 = vec2(d5,2.0);
        }
        res = smin( res, res2, 0.1 );
    }
    else
    {
       res = min(res,vec2( bb+0.1, 2.0 ));
    }
    
#if 1
    vec2 pid = floor( (p.xz+2.0)/4.0 );
    p.xz = mod(p.xz+2.0,4.0)-2.0;
    if( dot(pid,pid)>0.5 )
    {
        p.xz += 1.0*(-1.0+2.0*hash2( vec2(313.1*pid.x + 171.4*pid.y,331.8*pid.x + 153.4*pid.y) ));
        float d3 = sdSphere(p,vec4(0.0,0.0,0.0,0.8));
        for( int i=0; i<6; i++ )
        {
            vec3 sc = -1.0+2.0*hash3( pid.x + pid.y*13.1 + float(i) + vec3(0.0,2.0,4.0) );
            sc.y = sqrt(abs(sc.y));
            sc = normalize(sc);
            float ss = 0.7 - 0.1*sin(pid.y + float(i)*13.1);
            vec4 pp = vec4(-sc,ss);
            d3 = smax( d3, -dot(vec4(p,1.0),pp), 0.02 );
        }
        d3 -= 0.1*sqrt(textureGrad( iChannel2, 0.1*s.zy, 0.1*dsdx.zy, 0.1*dsdy.zy ).x);
        if( d3<res.x  ) res = vec2(d3,3.0);
    }    
#endif
    
    return res;
}

// Function 2536
float groundSDF(in vec3 iPoint) {
    
    // Using a texture as a height map to roughen up the ground    
    float height = texture(iChannel1, (iPoint.xz + vec2(10.0))*0.2).x;
    return iPoint.y + 1.1 + 0.1*height;
    
}

// Function 2537
vec2 map(vec3 pos, float time)
{
	vec3 floorpos = pos;
	floorpos.y -= height(pos);
	vec2 res = vec2(floorpos.y+1.+mud(pos),0.);

	if (floorpos.y<4.) {
		float cut = -floorpos.y-0.;
		vec2 fieldscale = pos.xz*.004;
		vec2 fieldindex = floor(fieldscale);
		vec2 fieldpos = fract(fieldscale);
		float fieldtype = mod(fieldindex.x+fieldindex.y,3.);
		cut += fieldtype;
		cut = mix(-floorpos.y-1.1,cut,step(.05,fieldpos.x)*step(.05,fieldpos.y));
		vec3 opos = pos;
		pos.y -= gridheight(pos);
		float b = obj2(pos,opos,fieldtype);
#ifdef DENSER_FIELD
		b = min(b,obj2(pos+2.5,opos+2.5,.5));
		b = min(b,obj2(pos+5.3,opos+5.3,.3));
#endif
		b = max(b,-cut);
		if (b<res.x) {
			res.x = b;
			res.y = 5.+fieldtype;
		}
		if (b>3.) res.y=4.;
	} else {
		res.y = 4.;
	}
		
	
	return res;
}

// Function 2538
vec2 SceneDistance(const in vec3 mPos)
{
    #ifndef DEBUG_NO_TERRAIN
    	return vec2(mPos.y - TerrainDisplacement(mPos.xz), 1.0);
    #else
    // Unsigned distance plane
    	return vec2(mPos.y - WATER_HEIGHT, 0.0);
	#endif
}

// Function 2539
TraceResult sceneTrace(vec3 origin, vec3 direction, float worldTime) {
  bool hit = false;
  vec3 testPoint;

  float time = 0.0;
  float tfar = 6.0;
  vec2 bounds = boxIntersect(origin - vec3(0.0, 0.45, 0.55), direction, vec3(0.6, 1.2, 1.15));
  if (bounds.x < bounds.y && bounds.y > 0.0) {
      time = max(time, bounds.x);
      tfar = min(tfar, bounds.y);

      for (int i = 0; i < 128; i += 1) {
          testPoint = origin + direction * time;
          float dist = sceneDistance(testPoint, worldTime);
          if (dist < 0.0001) {
              hit = true;
              break;
          }

          time += dist;
          if(time > tfar) { break; }
      }
  }

  return TraceResult(hit, testPoint, direction);
}

// Function 2540
float sdf(in vec3 p)
{
	vec3 sp, tp, rp;
	float mul;
	tile(p, sp, tp, rp, mul);
	
	// surface
	float spheres = abs(rp.x) - 0.012;
	float leaves = max(spheres, max(-rp.y, rp.z));
	leaves = max(leaves, vcut-sp.y);
	spheres = max(spheres, vcut-sp.y+1.07);
	float ret = min(leaves, spheres);

	// intercals
	vec3 pi = rp;
	pi.x += interpos;
	float interS = abs(pi.x) - 0.02;
	float interL = max(interS, max(-rp.y, rp.z));
	interL = max(interL, vcut-sp.y+2.);
	interS = max(interS, vcut-sp.y+3.);
	ret = min(ret, min(interL, interS));

	// outline
	float ol = abs(rp.y) - radius*0.8;
	ol = min(ol, abs(rp.z) - radius*0.8);
	// cut out
	ret = max(ret, -ol);

	return ret * mul / shorten;
}

// Function 2541
vec3 distortion_noise(vec3 p, float t)
{
    const int octave = -1;

    vec3 i = floor(p);
    vec3 f = fract(p);

    vec3 u = smoothstep(0.0, 1.0, f);

    vec2 h0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xy;
    vec2 h1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xy;
    vec2 h2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xy;
    vec2 h3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xy;
    vec2 h4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xy;
    vec2 h5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xy;
    vec2 h6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xy;
    vec2 h7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xy;

    /* // Not Spherically Uniform
    vec3 v0 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+0.0, octave) ).xyz;
    vec3 v1 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+0.0, octave) ).xyz;
    vec3 v2 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+0.0, octave) ).xyz;
    vec3 v3 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+0.0, octave) ).xyz;
    vec3 v4 = hash44( vec4(i.x+0.0, i.y+0.0, i.z+1.0, octave) ).xyz;
    vec3 v5 = hash44( vec4(i.x+1.0, i.y+0.0, i.z+1.0, octave) ).xyz;
    vec3 v6 = hash44( vec4(i.x+0.0, i.y+1.0, i.z+1.0, octave) ).xyz;
    vec3 v7 = hash44( vec4(i.x+1.0, i.y+1.0, i.z+1.0, octave) ).xyz;
    */

    vec2 r0 = vec2( 2.0*pi*h0.x, acos(2.0*h0.y-1.0) );
    vec2 r1 = vec2( 2.0*pi*h1.x, acos(2.0*h1.y-1.0) );
    vec2 r2 = vec2( 2.0*pi*h2.x, acos(2.0*h2.y-1.0) );
    vec2 r3 = vec2( 2.0*pi*h3.x, acos(2.0*h3.y-1.0) );
    vec2 r4 = vec2( 2.0*pi*h4.x, acos(2.0*h4.y-1.0) );
    vec2 r5 = vec2( 2.0*pi*h5.x, acos(2.0*h5.y-1.0) );
    vec2 r6 = vec2( 2.0*pi*h6.x, acos(2.0*h6.y-1.0) );
    vec2 r7 = vec2( 2.0*pi*h7.x, acos(2.0*h7.y-1.0) );

    vec2 s0 = sin(r0), c0 = cos(r0);
    vec2 s1 = sin(r1), c1 = cos(r1);
    vec2 s2 = sin(r2), c2 = cos(r2);
    vec2 s3 = sin(r3), c3 = cos(r3);
    vec2 s4 = sin(r4), c4 = cos(r4);
    vec2 s5 = sin(r5), c5 = cos(r5);
    vec2 s6 = sin(r6), c6 = cos(r6);
    vec2 s7 = sin(r7), c7 = cos(r7);

    vec3 v0 = vec3(c0.x*s0.y, s0.x*s0.y, c0.y);
    vec3 v1 = vec3(c1.x*s1.y, s1.x*s1.y, c1.y);
    vec3 v2 = vec3(c2.x*s2.y, s2.x*s2.y, c2.y);
    vec3 v3 = vec3(c3.x*s3.y, s3.x*s3.y, c3.y);
    vec3 v4 = vec3(c4.x*s4.y, s4.x*s4.y, c4.y);
    vec3 v5 = vec3(c5.x*s5.y, s5.x*s5.y, c5.y);
    vec3 v6 = vec3(c6.x*s6.y, s6.x*s6.y, c6.y);
    vec3 v7 = vec3(c7.x*s7.y, s7.x*s7.y, c7.y);

    /*
    v0 = vec3(rotate(v0.xz, t), v0.y).xzy;
    v1 = vec3(rotate(v1.xz, t), v1.y).xzy;
    v2 = vec3(rotate(v2.xz, t), v2.y).xzy;
    v3 = vec3(rotate(v3.xz, t), v3.y).xzy;
    v4 = vec3(rotate(v4.xz, t), v4.y).xzy;
    v5 = vec3(rotate(v5.xz, t), v5.y).xzy;
    v6 = vec3(rotate(v6.xz, t), v6.y).xzy;
    v7 = vec3(rotate(v7.xz, t), v7.y).xzy;
    */

    v0 = vec3(rotate(v0.xy, t), v0.z);
    v1 = vec3(rotate(v1.xy, t), v1.z);
    v2 = vec3(rotate(v2.xy, t), v2.z);
    v3 = vec3(rotate(v3.xy, t), v3.z);
    v4 = vec3(rotate(v4.xy, t), v4.z);
    v5 = vec3(rotate(v5.xy, t), v5.z);
    v6 = vec3(rotate(v6.xy, t), v6.z);
    v7 = vec3(rotate(v7.xy, t), v7.z);

    return mix(mix(mix(v0, v1, u.x), mix(v2, v3, u.x), u.y), mix(mix(v4, v5, u.x), mix(v6, v7, u.x), u.y), u.z);
}

// Function 2542
float scene(vec3 p){
	float d = 1e10;
	
	ground = sdPlane(p - ground_pos, vec4(0., 1., 0., 0.));
	box1 = sdBox(p - box1_pos, box1_dim);
	box2 = sdBox(p - box2_pos, box2_dim);
	box3 = sdBox(p - box3_pos, box3_dim);
	box4 = curtain(p - box4_pos, box4_dim);
	sphere1 = sdSphere(p - sphere1_pos, sphere1_radius);
	sphere2 = sdSphere(p - sphere2_pos, sphere2_radius);
	torus = sdTorus(p - torus_pos, torus_dim);
	
	d = min(d, ground);
	d = min(d, box1);
	d = min(d, box2);
	d = min(d, box3);
	d = min(d, box4);
	d = min(d, sphere1);
	d = min(d, sphere2);
	d = min(d, torus);
	
	return d;
}

// Function 2543
float segmentDistance(vec2 p, vec2 a, vec2 b, out float h)
{
	vec2 ap = p - a;
	vec2 ab = b - a;
	h = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);
	return length(ap - ab * h);
}

// Function 2544
SideDef Map_ReadSideDefInfo( sampler2D mapSampler, int iSectorId, int iSideDefIndex )
{
    SideDef sideDef;
    
    ivec2 vAddress = GetSideDefAddress( iSectorId, iSideDefIndex );
    
    vec4 vData0 = ReadMapData(mapSampler, vAddress);
    vAddress.x += 1;

    sideDef.vA = vData0.xy;
    sideDef.vB = vData0.zw;
    
    vec4 vData1 = ReadMapData(mapSampler, vAddress);
    vAddress.x += 1;

    sideDef.fLength = vData1.x;
    sideDef.fLightLevel = vData1.y;    
    sideDef.iMiddleTexture = uint(vData1.z);
    sideDef.iNextSector = int(vData1.w);
    
    vec4 vData2 = ReadMapData(mapSampler, vAddress);
    sideDef.iLowerTexture = uint(vData2.x);
    sideDef.iUpperTexture = uint(vData2.y);
    sideDef.fFlags = vData2.z;
    
    return sideDef;
}

// Function 2545
float sceneSDF(vec3 samplePoint) {
	return opRep(samplePoint, vec3(3.0, 3.0, 3.0));
}

// Function 2546
float distfunc(vec3 pos)
{
	vec3 npos = pos;
    float s1 = sphere(npos, 1.5
					  +ss(pos.y*3.0+iTime*10.0,0.05)
					  +ss(pos.x*3.0+iTime*10.0,0.1)
					 );
	
	// movement amplitude for all blobs
	// same formula as camera shake (should make them global I guess)
	float amp = ss(iTime*3.0,2.0);
	
	
	// Note that the x coords are all pushed towards the cam (by pow'ing the sin on x)
	// No point twiddling blobs where we can't see them
	npos = pos-amp*vec3(pow(sin(iTime*1.7),2.0),cos(iTime*3.0),sin(iTime));
	float s2 = sphere(npos, 0.2+ss(iTime*0.45,0.6));
	
	npos = pos-amp*vec3(pow(sin(iTime*-1.3),2.0),cos(iTime*0.3)*0.7,sin(iTime*1.1));
	float s3 = sphere(npos, 0.2+ss(iTime*1.945,0.6));
	
	npos = pos-amp*vec3(pow(sin(iTime*0.3),2.0),cos(iTime*-1.9),sin(iTime*0.7));
	float s4 = sphere(npos, 0.2+ss(iTime*2.3,0.6));
	
	float smoother = 8.0;
	//mix the blobby
	return smin(smin(smin(s1,s2,smoother),s3,smoother),s4,smoother);
}

// Function 2547
float teaPotSDF(vec3 p) {
    vec2 handleB = sdBezier(p - vec3(1.4, -0.3, 0.0)/ 1.2, vec3(0.0), vec3(1.2, 0.9, 0.0), vec3(-0.2, 0.8, 0.0));
    float radiusHandle = 0.1 * ( cos(PI * (handleB.y + 0.5)) / 2.0 + 1.0);
    float handle = handleB.x - radiusHandle;
    float body = teaPotBody2D_SDF(revolutionOp(p/1.5, 0.0));
    vec2 frontB = sdBezier( p - vec3(-1.3, 0.0, 0.0), vec3(0.0), vec3(-0.5, 0.0, 0.0), vec3(-0.5, 0.6, 0.0));
    float radiusFront = 0.3 - 0.2*frontB.y;
    float frontbezier = frontB.x - radiusFront;
    float frontCaps = capsuleSDF(p, vec3(-1.8, 0.5, 0.0), vec3(-2.0, 0.65, 0.0), 0.11);
    vec3 planeN = normalize(vec3(-0.2, -1.0, 0.0));
    float frontPlane = planeSDF(p, vec4(planeN, 0.25));
    float front = sminCubic(frontbezier, frontCaps, 0.4);
    front = onionOp(front, 0.02);
    front = sSubOp(frontPlane, front, 0.01);
    return sminCubic(sminCubic(handle, body, 0.01), front, 0.4) /1.5;
}

// Function 2548
float BaubleBoundsSDF( vec3 pos, float depth )
{
    return abs(TreeBoundsSDF(pos)+depth)-.3; // half the width of the area bauble centres can be placed in
}

// Function 2549
float mapSea(vec3 P, vec3 up)
{
    P-=EARTHPOS;
    float b = length(P)-EARTHRADIUS;

    b += waves(0.001*P, up, iTime);
    
    return b;
}

// Function 2550
float2 Map ( in vec3 O ) {
  float3 o=O, ori=O;
  float2 res = float2(999.0);

  // opRotate(O.xz, t*0.05);
  O += vec3(0.0, 0.0, 1.5);
  float blah = -log(exp(-4.0*sdHexagonCircumcircle(O, vec2(0.5, 1.0))) +
                    exp(-1.0*sdSphere(O, 1.0)));;
  blah += dot(texture(iChannel0, O.xz),
              texture(iChannel0, O.zy))*0.05;
  Union(res, blah*0.25, 1.0);
  blah = sdSphere(O - vec3(1.8, 0.2, 2.5), 1.5);
  Union(res, blah*0.5, 1.5);
  opRotate(O.xy, PI/2.0 - PI/4.0);
  blah = sdBox(O - vec3(0.0, -0.8, 2.5),
                   float3(1.25, 0.5, 0.8));
  blah += length(texture(iChannel1, O.xz))*0.1;
  Union(res, blah*0.5, 2.0);

  O=ori;
  blah = sdSphere(O-vec3(0.0, 1.0, 0.0), 1.0);
  //Union(res, sdShell(blah, 0.005)*0.5, 4.0);
  float s = sdShell(sdSphere(O, 10.0), 0.01)*0.5;
  Union(res, s, 7.0);
  O=ori;
  float2 uv = float2(O.x, O.z);
  O.y += length(texture(iChannel0, uv*0.1).xyz)*0.05;
  float d = sdPlane(O, float3(0.0, 1.0, 0.0), 1.0);
  Union(res, d, 7.5);
    
 // O=ori;
  O.y += sin(O.x*2.0)*0.2f + cos((25.32f+O.x)*42.0f)*0.01f;
  Union(res, sdPlane(O, vec3(0.0, 1.0, 0.0), 0.5), 7.7);
    
  //-----------light--------
  for ( int i = 0; i != LIGHTS_LEN; ++ i ) {
    O = inverse(Look_At(lights[i].N))*(ori-lights[i].ori);
    Union(res, sdBox(O, float3(0.01, lights[i].radius)), 100.0+float(i));
  }
  //----
  return res;
}

// Function 2551
float plotDistance(vec2 U,vec2 m,vec2 a,vec2 b,vec2 c){
 vec2 p=U/iResolution.x;p=vec2(p.x*8.-1.,p.y*32.-2.);
 float w=p.y-dd(a-m+(2.*(b-a)+(a-b*2.+c)*p.x)*p.x);
 return smoothstep(fwidth(w),.0,abs(w));}

// Function 2552
float scene(vec3 p, out float m, float t)
{
#if 0
    // duplicate
    p += vec3(-4.0, 0.0, -4.0);
    p.xz = mod(p.xz, 8.0);
    p -= vec3(4.0, 0.0, 4.0);
#endif	
		
    float d;
    m = 3.0;	// material

    p += vec3(2.0, 1.0, 0.0);
    p = p * 100.0;

    d = sdPlane(p, vec4(0, 1, 0, 0)); 

    d = _union(d, front_tire(p,t), m, 0.0);
    if (t > 2.0) d = _union(d, front_axle(p), m, 2.0);
    if (t > 3.0) d = _union(d, front_hub(p), m, 1.0);
	
    d = _union(d, rear_tire(p,t),m, 0.0);
    if (t > 6.0) d = _union(d, rear_axle(p), m, 2.0);
    if (t > 7.0) d = _union(d, rear_hub(p), m, 1.0);
	
    if (t > 8.0) d = _union(d, upper_body(p,t), m, 0.0);
    if (t > 10.0) d = _union(d, lower_body(p), m, 0.0);	
	
    if (t > 11.0) d = _union(d, cone(p, vec3(293.0,85.0,0.0), 60.0, vec3(219.0,85.0,0.0), 26.5), m, 2.0);
	
    if (t > 12.0) d = _union(d, window(p,t), m, 1.0);

	if (t > 14.0) d = _union(d, jetwall(p), m, 4.0);
	
	
    d /= 100.0;

    return d;
}

// Function 2553
float dirBisectDist(vec3 d, vec3 a, vec3 b, float dist)
{
    float cosnd = dot(normalize(b - a), d); //ray plane normal angle cosine
    return (cosnd>0.)?(dist*.5)/cosnd:1e10;
}

// Function 2554
float map(vec3 p )
{
	vec3 q = p - vec3(0,.1,1);
	float f = 0., s=.5;
    for (int i=0; i< 5; i++ , s/= 2. )
        f += s* noise( q ), q *= 2.;

	return max(1.+ .5*p.y +3.*f, 0.);
}

// Function 2555
vec3 sdfNormal(vec3 p, float epsilon)
{
    vec3 eps = vec3(epsilon, -epsilon, 0.0);
    
	float dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);
	float dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);
	float dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); 

	return normalize(vec3(dX,dY,dZ));
}

// Function 2556
vec3 scene( in vec2 pos )
{
    vec4 background = vec4(0.0);
    vec4 l1 = layerMoon(pos); 
    vec4 l2 = motes(pos);
    vec4 l3 = layerElders(pos);

    vec3 color = mix(background.xyz, l1.xyz, l1.w);
    color = mix(color, l2.xyz, l2.w); 
    color = mix(color, l3.xyz, l3.w); 
    return color;
}

// Function 2557
vec3 tonemap(vec3 linear, float scale) {
	vec3 x = linear * scale;
	x = max(vec3(0), x - 0.004);
	vec3 pre_gamma = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);
    vec3 post_gamma = pow(pre_gamma, vec3(1.0/2.2));
	return post_gamma;
}

// Function 2558
float SDF_Nose(vec3 p)
{ 
    float nose = DispBox(
        RotY(RotX(Translate(p, vec3(0.0, 0.35, 0.7)), PI * 0.25), PI * 0.25),
        vec3(0.115, 0.485, 0.115), 
        0.05 - (p.y) * 0.1);
    
    return nose;
}

// Function 2559
vec2 map(in vec3 p)                                                             
{                                   
    //float d = torus(p, vec2(0.5, 0.2), 
    //              2.0 + 8.0 * (1.0 + sin(iTime)), 
    //              2.0 + 8.0 * (1.0 + sin(iTime)));
    
    float d1 = torus(p, vec2(0.5, 0.2), 2.0, 2.0);
	float d = d1;
	
    vec2 res = vec2(d, 1.0);                                                     
                                                                                
    return res;                                                                  
}

// Function 2560
void updateScene(float t) {
    //init lights
    t *= 4.0;

    float moveSize = 0.7;
    float a = 0.0;
    float speed = 2.0;
    float val;
    
    //1
    val = a+t*speed;    
    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //2
    val = a+t*speed;    
    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //3
    val = a+t*speed;    
    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //4
    val = a+t*speed;    
    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);
    a += 0.4;
}

// Function 2561
vec2 map7(vec3 pos) {
	pos.xz = rotate(pos.xz, iTime*2.);
    pos.xy = rotate(pos.xy, -iTime*2.);

    float s = roomWidth * 0.3 + sin(iTime*2.)*0.01;
	float dist = fIcosahedron(pos, s);
    float identifier = abs(pos.y);
    vec2 res = vec2(dist, identifier);

    return res;
}

// Function 2562
float mapGnd(in vec3 p){return .5*texture(iChannel3, GS*p.xz).r +.2*texture(iChannel3, 2.*GS*p.xz).r;}

// Function 2563
vec3 SceneNf (vec3 p)
{
  vec4 v;
  vec2 e;
  e = vec2 (0.001, -0.001);
  v = vec4 (- SceneDf (p + e.xxx), SceneDf (p + e.xyy), SceneDf (p + e.yxy), SceneDf (p + e.yyx));
  return normalize (2. * v.yzw - dot (v, vec4 (1.)));
}

// Function 2564
V_4 sdf_RenderScene( RWC_AND_RWN rwC_AND_rwN )
        {
            I32 o_k = I32( 1 );
            V_4 c4d = THE_COLOR_OF_EMPTY_SPACE ;

            V_3 rwN = rwC_AND_rwN.rwN; 
            V_3 rwC = rwC_AND_rwN.rwC;

            V_3 xyz = rwC;
            F32 xyz_TDF_rwC=(0.0);
            /** xyz_total_distance_from_rwC **/
         
            VOX_000
            vox_000; 

            VOX_MAR vox_mar;

            //:dis_nex: Distance To NEXT voxel.
            //:dis_sur: Distance To Surface Geometry inside
            //:     the current voxel. In world coords.
            vox_000.vod.dis_nex =( 0.0 );  
        //: vox_000.vod.dis_sur =( 0.0 );  

            //:Voxels will be thought of as 3D tiles:
            vox_000.voc.has     = uint( 0 ); // :1: //
            vox_000.voc.val     = uint( 0 ); // :2: //
            vox_000.voc.til_d3d =  int( 0 ); // :3: //
            vox_000.voc.t_x     =  int( 0 ); // :4: //
            vox_000.voc.t_y     =  int( 0 ); // :5: //
            vox_000.voc.t_z     =  int( 0 ); // :6: //

            //:RAY_MARCH_LOOP:-----------------------://
            /** #ABOUT_RAY_MARCH_LOOP# **/

                //:(RayMarch)March to VOXEL:
                for( int i = 0; i < MAX_STE ; i++ ){

                    //:March by distance to next voxel:
                    
                    //:Point_Normal_Form_To_Get:xyz
                    //:#DISTANCE_IS_NOT_CUMULATIVE#
                    rwN=normalize(rwN); //:TEMP_DEBUG
                    xyz =  xyz + ( rwN * (D_N+0.0) );; 
                //: xyz =  xyz + ( rwN * -8.0 );

                    /** B4 : GET_vox_000_USE_xyz_rwN **/
                    xyz_TDF_rwC += D_N;
                    if( xyz_TDF_rwC > MAX_DIS ){break;};
                
                    //:@WHATVOX@://
                        vox_000 = 
                    GET_vox_000_USE_xyz_rwN( 
                                    xyz,rwN );;

                    //:if( D_N <= 0.0 we have trouble )
                    F32 MF3=intBitsToFloat(0x7f7fFFFF);
                    if( 0.0 - 666.0 == D_N ){

                        /** Exit On Error            **/
                        /** #DIST_NEXT_NEVER_ZERO#   **/
                        c4d=PIX_ERR(ERR_003,c4d,o_k--);
                        break;

                    }else
                    if( vox_000.vod.dis_nex <= 0.0 ){
                        //:PULSING:ORANGE:VIA:POS_COS:
                        F32 p_c=((cos(iTime)+1.0)/2.0);
                        c4d=V_4(V_3(1,0.5,0)*p_c,1.0);
                        break;
                    }else
                    if( D_N == MF3 /** MaxFloat32 **/ ){
                        F32 p_c=((cos(iTime)+1.0)/2.0);
                        c4d=V_4(V_3(1,0.5,1)*p_c,1.0);
                        break;
                    }else
                    if( isinf( D_N ) ){
                        c4d=u32_CTO_c4d(U32( 
                                    0xE0E0E0FF ));
                    };;

                    //:If voxel is not empty, ray march
                    //:inside of the voxel.
                    #define _0_ U32( 0 ) //:#########://

                    if( HAS > _0_ && _0_ == VAL ){

                        //:EMPTY_TILE_INSIDE_MAP_BOUNDS:
                        c4d=u32_CTO_c4d(U32( 
                                    0x003300FF ));

                    }else
                    if( _0_ == HAS ){

                        //:OUT_OF_MAP_BOUNDS:
                    //  c4d=u32_CTO_c4d(U32( 
                    //              0x330011FF ));
    
                        xyz_TDF_rwC=(length(xyz - rwC));
                        F32 per=(xyz_TDF_rwC / MAX_DIS);
                        F32 inv=( 1.0 - per );

                        c4d=V_4( V_3(1)*(inv) , 1.0 );

                    }else
                    if( HAS > _0_ && VAL > _0_  ){
    
                        vox_mar =(
                        sdf_MarchIntoVoxel(
                            vox_000,xyz,rwN
                        ));;
                        
                        /*[FIX]: ALWAYS RETURNS EXIT */
                        if( vox_mar.exit >= U32(1) ){
                        
                            //: c4d=( u32_CTO_c4d( 
                            //: vox_000.voc.val ) );;

                            c4d =( vox_000_CTO_c4d(
                                   vox_000         ));;
                        
                            break;
                        };;

                    }else{

                        //:SHOULD_NEVER_EXECUTE:
                        c4d=V_4(1,0,0,1);

                    };;

                    #undef  _0_  //:#################://

                    /** Don't move the ray anywhere  **/
                    /** We are going to slice into   **/
                    /** whatever voxels the camera   **/
                    /** plane passes through.        **/
                    if( CFG_SLICE_RENDER >= 1 ){ 
                        break; 
                    };;

                };;

            //:-----------------------:RAY_MARCH_LOOP://


            if( CFG_SLICE_RENDER >= 1 ){

                //:Layer value, 1 or 0
                int lay = I32_MOD( T_Z, 2 );
                
                //:#MODULO_CHECKER_PATTERN#://
                int chk =(  
                    I32_MOD( //:<<<<<<<<<<<<<<:SET_003
                        I32_MOD( T_Y, 2 )   //:SET_YYY
                    +   I32_MOD( T_X, 2 )   //:SET_XXX
                    ,                 2
                    )
                );;
            
                if(   0 != 0
                || ( lay < 0 )
                || ( lay > 1 )
                || ( chk < 0 || chk > 1 )
                || ( HAS > uint(1)      )
                ){
                    //: _0x010101_ & _0x101010_
                    c4d=PIX_ERR(ERR_001,c4d,o_k--);
                };;

               
                F32 M =( 255.0); //:Max RGB value.
                F32 X =( 1.0  ); //:FOR_DEBUGGING_COLORS
             //:F32 ...........;    Replace with "_" 
             //:F32 ...........;    when done debugging.
                F32 a =( 1.0  ); //:ALPHA
                F32 _ =( 0.0  );
                F32 g =( F32(0x33)/M ); //:DARK-GREY
                F32 G =( F32(0x38)/M );
                F32 w =( F32(0xE5)/M ); //:WHITE-GREY
                F32 W =( F32(0xF2)/M );

                V_4 _0x333333_ =V_4(g,g,g,a);
                V_4 _0x383838_ =V_4(G,G,G,a);
                V_4 _0xE5E5E5_ =V_4(w,w,w,a);
                V_4 _0xF2F2F2_ =V_4(W,W,W,a);
                V_4 _0x003300_ =V_4(_,g,_,a);
                V_4 _0x003800_ =V_4(_,G,_,a);
                V_4 _0x00E500_ =V_4(_,w,_,a);
                V_4 _0x00F200_ =V_4(_,W,_,a);

                V_4 tab_000[8]=V_4[8](
                    //:OUT OF BOUNDS:       //:HAS?
                    _0x333333_ , _0x383838_ //:LAY0
                   ,_0xE5E5E5_ , _0xF2F2F2_ //:LAY1
                //: |   CHK0   |     CHK1   |::::::::://
                                   
                    //:IN BOUNDS:           //:HAS?
                   ,_0x003300_ , _0x003800_ //:LAY0
                   ,_0x00E500_ , _0x00F200_ //:LAY1
                //: |   CHK0   |     CHK1   |::::::::://
                );;
                
                I32 pik = (
                   (4 * ( HAS >= uint(1) ? 1 : 0 ))
                +  (2 * lay ) //: LAY0 -or- LAY1
                +  (1 * chk ) //: CHK0 -or- CHK1
                );;

                if( pik < 0 || pik >= 8 ){
                    c4d=PIX_ERR(ERR_002,c4d,o_k--);
                };;
                
                //:TODO: Why is not rendering as
                //:      checker?
                if( 1 == o_k ){
                    c4d = tab_000[ pik ];
                };;

            }else{
                //:DEBUG ONLY.
                //:c4d=V_4(1,1,1,1);
            };;

            return( c4d );
        }

// Function 2565
float distTire(vec3 p, float r, float w, float h, float flatness)
{
    float l=length(p.xy);
    //p=abs(p);
    float d=1000.;
    // outer sphere
    float rfl=r*(1.+flatness);
    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);
    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);
    //d=min(d,l-rz);
    float ang = atan(p.x,p.y);
    p.z+=cos(ang*64.)*w*.01*smoothstep(.87*r,1.*r,l);
    // main torus
    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);
    //d=max(d,-l+r*.61);
    float w_l=sqrt(w*w-h*h); // w_laufflaeche
    float dz=.243*w_l;
    float zfr=mod(p.z,dz);
    float z=p.z-zfr+dz*.5;
    // rillen
    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);
    // rim radius
    d=max(d,-(l-(r-h)));
    return d;
}

// Function 2566
vec4 mapLotsOfCubes( vec3 pos)
{
	vec3 col = vec3(.3, .8, .2 );
	const float radius=6.0;
	float dist = Mylength( mod( pos+8., 16.)-8.) -radius;
	return vec4( col, dist);
}

// Function 2567
vec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )
{
    
    xy.x = clamp(xy.x,-1.,2.);
    xy.y = clamp(xy.y,0.,1.);
    
    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);
    float px = round(xy.x*dimensions.x)/dimensions.x;
    float py = floor(xy.y*dimensions.y)/dimensions.y;
    vec2 offset =   vec2(xy.x,           xy.y-py)
                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));
    float d = 2.*abs(offset.x)+1.*abs(offset.y);
    
    return vec2(d,s);
}

// Function 2568
float sdf( in vec3 p, out vec3 norm ) {
    vec3 f = mod(p, CELL_SIZE);
    norm = normalize(f - vec3(CELL_SIZE / 2.0));
    return distance(f, vec3(CELL_SIZE / 2.0)) - RADIUS;
}

// Function 2569
void ray_march_scene(Ray r, float k, inout vec3 c)
{
    float uniform_step = k;
    float jit = 1.;
    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));
   
    float t_gen = 1.;

    float param_t = intersect_sphere(r, m.pos, RADIUS);
    if(param_t <= -1.)
        return;
    vec3 p = ray_interpolation(r, k*jit);        
     
    //rgb transparency               
    
    vec3 t_acc = vec3(1.);	// accumulated parameters for transparency
    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );
    
    for(int s = 10; s <110; s++)
    {               
        float dist_dist = dot(p-cam.pos, p-cam.pos);
        float dist_center = length(m.pos-cam.pos);
        vec3 center = p-m.pos;

        float d = length(center)-RADIUS-.5-jit*k;
        float size = length(center)/RADIUS;

        if(sdf_rounded_cylinder( center, 1.20, 0.2, 5. ) < 0.)
        {
            
            #if COLOR            
            #if ANIM      
            	anim = iTime/5.;
            
            #endif
            
            
            float n = fbm( ( 
                (p)/( clamp(0., RADIUS+1., length(center)) + cos(PI-Psnoise(p/(30.)) )- 1./size*anim) //shockwave stuff
            			) )  ;; ;
            // 1./size is the speed of the wave propgation 
            /////////////////////

            float mask = smoothstep(0.,
                                   	70.*RADIUS,
                                    RADIUS/length(center));

            
            //Optical density/depth : dens for density
            float dens = ( clamp( mask,
                               	  0.,
                                  1.) *n);
                        
           if(length(p-cam.pos) >(dist_center+m.radius) 
              )//|| (k*dens  < -9.9))
        	{
         	break;
        	}
            //How colors (rgb) are absorbed at point p in the current iteration
            //k is the step size          
             vec3 rgb_t = exp(-vec3(
                		k * 25. * f(p.x) * dens, 
                      	k * 10. * dens,
              	      	k * 15. * f(p.z) * dens ));    
                
    		//blending
   			c += t_acc*vec3(1.)*(1.-rgb_t);
                        t_acc *= (rgb_t);           

            #endif
        }

        //if it will never be in the shape anymore, return;        
        
        p += r.dir*k;

        k = uniform_step;
    }
    

    //c =float(s)/vec3(50,150,20); return;

    #if COLOR

    #else
    c = vec3(t_gen); return;
    #endif
}

// Function 2570
float map(vec2 uv)
{
    uv.x += rand(uv.y) * 0.006;// some distortion in x axis
    return sdColumn(uv, left, right);
}

// Function 2571
float SegDist (vec2 p, vec2 v1, vec2 v2)
{
  vec2 a, b;
  float s;
  a = p - v1;
  b = v2 - v1;
  s = length (b);
  b = (s > 0.) ? b / s : vec2 (0.);
  return length (a - clamp (dot (a, b), 0., s) * b);
}

// Function 2572
vec2 map(float t) {
    poly2 f = pa_map(pa_init(t));
    return vec2(f.a[0], nextevent(f));
}

// Function 2573
float chebyshevDistance(vec2 p1, vec2 p2) {
	float d1 = abs(p1.x - p2.x);
	float d2 = abs(p1.y - p2.y);
	return max(d1, d2);
}

// Function 2574
maybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r
){
    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center
    // see closest-approach-between-line-and-cylinder-visualized.scad
    // implementation shamelessly copied from Inigo: 
    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    vec3 D = A0 - B0;
    float BA = dot(B, A);
    float BD = dot(B, D);
    float a = 1.0 - BA * BA;
    float b = dot(D, A) - BD * BA;
    float c = dot(D, D) - BD * BD - r * r;
    float h = sqrt(max(b * b - a * c, 0.f));
    return maybe_vec2(
        vec2((-b + h) / a, (-b - h) / a), 
        h > 0.0
    );
}

// Function 2575
vec3 sceneNormal(vec3 pos )
{
    float eps = 0.0001;
    vec3 n;
#if 0
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - scene( vec3(pos.x, pos.y-eps, pos.z) );
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );
#else
    float d = scene(pos);
    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;
    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;
    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;
#endif
    return normalize(n);
}

// Function 2576
float planeSDF(vec3 samplePoint, Plane plane) {
    return dot( plane.normal , samplePoint - plane.center);
}

// Function 2577
float map (vec3 pos) {
    float scene = 1000.;
    
    // ground and ceiling
    float bump = texture(iChannel0, pos.xz*.1).r;
    float ground = 2. - bump*.1;
    scene = min(scene, pos.y+ground);
    scene = min(scene, -(pos.y-ground));
    
    // spell geometry 1
    vec3 p = pos;
    p.y += sin(atan(p.z,p.x)*10.)*3.; // change numbers to get new distortion
    p.xz *= rot(p.y*.2-iTime);
    p = anim1(p);
    p.x = length(p.xyz)-3.;
    scene = smin(scene, tubes(p), .5);
    scene = smin(scene, disks(p), .5);
    
    // spell geometry 2
    p = pos;
    p.y += sin(atan(p.z,p.x)*3.)*2.; // change numbers to get new distortion
    p = anim2(p);
    p.xz *= rot(p.y+iTime);
    p.x = length(p.xyz)-3.;
    scene = smin(scene, tubes(p), .3);
    scene = smin(scene, disks(p), .3);
    
    return scene;
}

// Function 2578
float sdFloor(vec3 p) {
    float bh = textureLod(iChannel0, p.xz * rot(1.1) * 0.01, 2.5).r * 6.5;
	     bh += textureLod(iChannel0, (p.xz + vec2(12.3, 23.4)) * rot(0.5) * 0.02, 0.0).r * 1.2;
    bh /= 2.5;
    return p.y + 6.0 - bh;
}

// Function 2579
MarchData map(vec3 p) {
	MarchData result = sdCup(p);
	result.d = min(result.d, sdSaucer(p));
	result = minResult(result, sdPlane(p));
	float d,
	      gnd = length(p.y + 1.7);
	if (flash > 0.) {
		d = max(length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * .08) - vec2(.5, 0)), p.y - .7);
		glow += .001 / (.01 + 2. * d * d);
		if (d < result.d) result.d = d;
	}

	if (gnd < result.d) {
		result.d = gnd;
		result.mat = vec3(.2);
	}

	if (!hideCloud) {
		d = sdCloud(p);
		if (d < result.d) {
			result.d = d * .7;
			result.isCloud = true;
		}
	}

	return result;
}

// Function 2580
vec3 colormapBBR(float k, float krange) {
    vec3 c0 = vec3(0.0, 66.0, 157.0)/ 255.0; // color k < 0 blue
    vec3 c2 = vec3(147.0, 0.0, 58.0)/ 255.0; // color k > 0 red
    vec3 col = (k<0.)? c0:c2; col *= abs(atan(krange*k)/(0.5*3.14));
    return col;
}

// Function 2581
void addScene(inout vec3 col, vec3 c, float de)
{
	col = mix(c, col, smoothstep(0.0, 2.5/iResolution.x, de));    
}

// Function 2582
vec3 jet_colormap(float v)
{
    return vec3(base(v - 0.5),base(v),base(v + 0.5));
}

// Function 2583
float map(vec3 p) {
    #if METHOD == 1
    	float r=sphere(p,1.3);
   	#endif
    #if METHOD == 2
    	float r=box(p,vec3(0.25));
    #endif
    
    return r;
}

// Function 2584
float get_distance(vec3 point) {
	float bump = 0.0;
	float elevation = -1.0;
	
	if ( length(point) < R + bump_factor) {
		bump = bump_factor * texture3d(iChannel1, point, normalize(-point), 0.5).r;
	}	
	
	vec3 ball_point = point;
	
	return length(ball_point) - R + bump;
		//dot(point, vec3(0.0, 1.0, 0.0)) - elevation,
		
}

// Function 2585
float scene (vec3 o, vec3 d) {
    float intSphere = sphere(o, d);
    float intPlane = plane(o, d);
    float inter = min(intPlane, intSphere);
    return inter;
}

// Function 2586
float calcLoadDist(vec2 iResolutionxy) {
    vec2  chunks = floor(iResolutionxy / packedChunkSize); 
    float gridSize = min(chunks.x, chunks.y);    
    return floor((gridSize - 1.) / 2.);
}

// Function 2587
float map(vec3 p) {
    
    
    // Gaz's path correction. Very handy.
    vec2 pth = path(p.z);
    vec2 dp = (path(p.z + .1) - pth)/.1; // Incremental path diffence.
    vec2 a = cos(atan(dp)); 
    // Wrapping a tunnel around the path.
    float tun = length((p.xy - pth)*a);
    
    
    
    // Obtaining the distanc field values from the 3D data packed into
    // the cube map face. These have been smoothly interpolated.
    vec3 tx3D = texMapSmooth(iChannel0, p/3.).xyz;
    // Using this will show you why interpolation is necessary.
    //vec3 tx3D = tMap(iChannel0, p/3.).xyz;
    
    // The main surface. Just a couple of gradient noise layers. This is used
    // as a magnetic base to wrap the asteroids around.
    float main = (tx3D.x - .55)/2.;
    
    // Calling the function again, but at a higher resolution, for the other
    // surfaces, which consist of very expensive rounded Voronoi.
    tx3D = texMapSmooth(iChannel0, p*2.).xyz;
    
    // Saving the higher resolution gradient noise to add some glow. I patched
    // this in at the last minute.
    glow3 = tx3D;

    
    // Attaching the asteroid field to the gradient surface. Basically, the 
    // rocks group together in the denser regions. With doing this, you'd 
    // end up with a constant density mass of rocks.
    main = smax(main, -(tx3D.z + .05)/6., .17);
    
    // Adding a heavy layer of gradient noise bumps to each rock.
    main += (abs(tx3D.x - .5)*2. - .15)*.04;
   
    // Smoothly running the tunnel through the center, to give the camera
    // something to move through -- Otherwise, it'd bump into rocks. Getting 
    // a tunnel to run through a group of rocks without warping them was 
    // only possilbe because of the way the rocks have been constructed.
    return smax(main, -tun, .25);
    
}

// Function 2588
float hyperDistPP(vec3 u, vec3 v) {
    return acosh(max(1.0, -hyperDot(u, v)));
}

// Function 2589
vec4 scene(vec3 ro, vec3 rd, vec4 ids){
	Hit H; H.t=maxDepth; H.id=0.0; H.n=vec3(0.0);
	vec4 idsave=ids;
	for(int i=0;i<4;i++){
		if(ids.x>-1.0){
			float fid=float(i)*4.0;
			vec2 id=vec2(mod(ids.x,40.0),floor(ids.x/40.0))-vec2(20.0);
			vec3 p1=getParticle(id);
			vec3 p2=getParticle(id+vec2(1.0,0.0));
			vec3 p3=getParticle(id+vec2(0.0,1.0));
			iTri(ro,rd,p1,p2,p3,fid++,H);
			vec3 p4=getParticle(id+vec2(-1.0,0.0));
			iTri(ro,rd,p1,p3,p4,fid++,H);
			p3=getParticle(id+vec2(0.0,-1.0));
			iTri(ro,rd,p1,p4,p3,fid++,H);
			iTri(ro,rd,p1,p3,p2,fid++,H);
			ids=ids.yzwx;
		}
	}
	ids=idsave;
	vec4 col=vec4(0.0,0.0,0.0,1.0);
	if(H.t<maxDepth){
		float fid=floor(H.id*0.25);
		for(int i=0;i<4;i++)if(float(i)<fid)ids=ids.yzwx;
		vec2 idn[3];
		idn[0]=vec2(mod(ids.x,40.0),floor(ids.x/40.0))-vec2(20.0);
		vec2 o2=vec2(1.0,0.0),o3=vec2(0.0,1.0);
		fid=mod(H.id,4.0);
		if(fid>0.5)o2=vec2(-1.0,0.0);
		if(fid>1.5)o3=vec2(0.0,-1.0);
		if(fid>2.5)o2=vec2(1.0,0.0);
		idn[1]=idn[0]+o2;idn[2]=idn[0]+o3;
		vec3 N[3],P[3];
		
		//now recalc the normals for each vertex in the triangle we hit
		for(int i=0;i<3;i++){
			vec2 id=idn[i];
			H.n=vec3(0.0);
			vec3 p1=getParticle(id);P[i]=p1;
			vec3 p2=getParticle(id+vec2(1.0,0.0));
			vec3 p3=getParticle(id+vec2(0.0,1.0));
			TriN(p1,p2,p3,H);
			vec3 p4=getParticle(id+vec2(-1.0,0.0));
			TriN(p1,p3,p4,H);
			p3=getParticle(id+vec2(0.0,-1.0));
			TriN(p1,p4,p3,H);
			TriN(p1,p3,p2,H);
			N[i]=normalize(H.n);
		}
		vec3 n=TriNS(P[0],P[1],P[2],ro+rd*H.t);
		n=normalize(N[0]*n.x+N[1]*n.y+N[2]*n.z);
		vec3 L=normalize(vec3(0.3,1.0,0.6));
		vec3 scol=vec3(1.0,0.7,0.4)*abs(dot(n,L));
		col=vec4(scol,1.0);
	}
	return col;
}

// Function 2590
float sampleCubeMap(float i, vec3 rd) {
	vec3 col = textureLod(iChannel0, rd * vec3(1.0,-1.0,1.0), 0.0).xyz; 
    return dot(texCubeSampleWeights(i), col);
}

// Function 2591
vec4 scene_ocean_normal_and_lensing( vec3 r, float t, float h, float d, vec3 V, vec3 Z )
{
    vec3 A = normalize( V - Z * dot( V, Z ) );
    vec3 B = cross( A, Z );
    vec3 M = normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z, d ) );
    float dMdA = dot( A, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * A, d ) ) - M );
    float dMdB = dot( B, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * B, d ) ) - M );
    float lens = 1. + h / d * ( dMdA + dMdB );
    return vec4( M, 1. / max( FRACT_1_64, lens * lens ) );
}

// Function 2592
vec2 map( vec3 p )
{

    vec2 sp = vec2( sph( p, 1.0 ), 0.0 );
    vec2 pla = vec2( pla( p ), 1.0 );
    /*if( sp.x < pla.x ) pla = sp;
    return pla;*/
    return sp;
    
}

// Function 2593
SDFResult sphereSDF2(Sphere sphere, vec3 p) 
{
    vec3 delta = sphere.pos - p;
    delta.xz += delta.y*delta.y*delta.y*10.0;
    return SDFResult(length(delta) - sphere.radius, sphere.matindex);
}

// Function 2594
float map (in vec3 p) {
    vec3 pBottom = p;
    vec3 pTop = p;

    float r1 = .1 + .3 * (.5 + .5 * sin (2. * iTime));
    float r2 = .15 + .2 * (.5 + .5 * sin (3. * iTime));
    float r3 = .2 + .2 * (.5 + .5 * sin (4. * iTime));
    float r4 = .25 + .1 * (.5 + .5 * sin (5. * iTime));

    float t = 2. * iTime;
    vec3 offset1 = vec3 (-.1*cos(t), .1, -.2*sin(t));
    vec3 offset2 = vec3 (.2, .2*cos(t), .3*sin(t));
    vec3 offset3 = vec3 (-.2*cos(t), -.2*sin(t), .3);
    vec3 offset4 = vec3 (.1, -.4*cos(t), .4*sin(t));
    vec3 offset5 = vec3 (.4*cos(t), -.2, .3*sin(t));
    vec3 offset6 = vec3 (-.2*cos(t), -.4, -.4*sin(t));
    vec3 offset7 = vec3 (.3*sin(t), -.6*cos(t), .6);
    vec3 offset8 = vec3 (-.3, .5*sin(t), -.4*cos(t));

    float ball1 = sdSphere (p + offset1, r4);
    float ball2 = sdSphere (p + offset2, r2);
	float metaBalls = opCombine (ball1, ball2, r1);

    ball1 = sdSphere (p + offset3, r1);
    ball2 = sdSphere (p + offset4, r3);
	metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r2);

    ball1 = sdSphere (p + offset5, r3);
    ball2 = sdSphere (p + offset6, r2);
	metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r3);

    ball1 = sdSphere (p + offset7, r3);
    ball2 = sdSphere (p + offset8, r4);
	metaBalls = opCombine (metaBalls, opCombine (ball1, ball2, .2), r4);

    pBottom.yz *= r2d(90.);
    vec2 cellBottom = opRepeat2 (pBottom.yx, vec2 (.75));

    pTop.yz *= r2d(270.);
    vec2 cellTop = opRepeat2 (pTop.yx, vec2 (.75));

    float hexBottom = sdHexPrism (pBottom + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellBottom.y)*cos(cellBottom.x)));
    float hexTop = sdHexPrism (pTop + vec3 (.0, .0, -3.), vec2 (.25, .75 + .2 * sin(cellTop.y)*cos(cellTop.x)));

    return min (metaBalls, min (hexBottom, hexTop));
}

// Function 2595
float scene(vec3 pos)
{
    float t = iTime;
    
    float p = torus(pos + vec3(0.0,3.0,0.0));
	float b = sphere(0.5*(pos + vec3(cos(t*0.5),sin(t*0.3),0.0)));
    float s1 = box(2.0*(pos + 3.0 * vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7))))/2.0;
    float s2 = box(2.0*(pos + 3.0 * vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3))))/2.0;
    float s3 = box(2.0*(pos + 3.0 * vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1))))/2.0;
    float s4 = box(2.0*(pos + 3.0 * vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7))))/2.0;
    float s5 = box(2.0*(pos + 3.0 * vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9))))/2.0;
    
    return blob7(p, b, s1, s2, s3, s4, s5);
}

// Function 2596
vec3 scene(vec2 p)
{
	vec3 col = vec3(0.0);
	
	// Camera rotation.
	mat3 cam = rotateXMat(cos(time * 0.2) * 0.5) * rotateYMat(time * 0.3);

	vec3 ro = cam * (vec3(0.0, 0.7, 2.9 + cos(time * 2.0) * 0.3));
	vec3 rd = cam * (vec3(p, -1.0));
	
	vec2 hipp = vec2(0.0, cos(time * 10.0) * 0.1);
	float theight = 1.0;
	vec3 tdir = normalize(vec3(-0.1, 1.0, sin(time * 4.0) * 0.1));
	vec3 n;
	
	float fl = -1.5;
	float t = 1e3;
	
	// Floor.
	{
		float i = (fl - ro.y) / rd.y;
		if(i > 0.0)
			t = min(t, i);
	}
	
	// First leg.
	{
		float wc = fract(time * wc_scale);
		float l0 = 0.8;
		float l1 = 1.0;
		vec2 e = vec2((0.6 - pyramid(wc)) * wc_step, fl + circ(wc * 2.0) * 0.3 * step(0.5, wc)) - hipp;
		vec2 m = solve(e, l0, l1, 1.0);
		
		cylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.1, mat3(1), t, n, vec3(hipp, ld));
		cylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.1, mat3(1), t, n, vec3(hipp + m, ld));
	}
	
	// Second leg.
	{
		float wc = fract(time * wc_scale + 0.5);
		float l0 = 0.8;
		float l1 = 1.0;
		vec2 e = vec2((0.6 - pyramid(wc)) * wc_step, fl + circ(wc * 2.0) * 0.3 * step(0.5, wc)) - hipp;
		vec2 m = solve(e, l0, l1, 1.0);
		
		cylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.1, mat3(1), t, n, vec3(hipp, -ld));
		cylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.1, mat3(1), t, n, vec3(hipp + m, -ld));
	}
	
	// First arm.
	{
		float wc = fract(time * wc_scale);
		float l0 = 0.5;
		float l1 = 0.7;
		vec2 e = vec2((sin(wc * 3.1415926 * 2.0) * 0.5) + 0.1, -0.9) - hipp;
		vec2 m = solve(e, l0, l1, -1.0);
		vec3 ofs = vec3(hipp, ad) + tdir * theight;
		mat3 x = rotateYMat(aa);
		
		cylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.08, x, t, n, ofs);
		cylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.08, x, t, n, ofs + vec3(m, 0.0));
	}
	
	// Second arm.
	{
		float wc = fract(time * wc_scale + 0.5);
		float l0 = 0.5;
		float l1 = 0.7;
		vec2 e = vec2((sin(wc * 3.1415926 * 2.0) * 0.5) + 0.1, -0.9) - hipp;
		vec2 m = solve(e, l0, l1, -1.0);
		vec3 ofs = vec3(hipp, -ad) + tdir * theight;
		mat3 x = rotateYMat(-aa);
		
		cylinder(ro, rd, normalize(vec3(m, 0.0)), 0.0, l0, 0.08, x, t, n, ofs);
		cylinder(ro, rd, normalize(vec3(e - m, 0.0)), 0.0, l1, 0.08, x, t, n, ofs + vec3(m, 0.0));
	}
	
	// Torso.
	cylinder(ro, rd, tdir, 0.0, theight, 0.2, mat3(1), t, n, vec3(hipp, 0.0));
	
	// Shoulders.
	cylinder(ro, rd, tdir, 0.2, theight + 0.1, 0.32, mat3(1), t, n, vec3(hipp, 0.0));
	
	// Head.
	cylinder(ro, rd, tdir, theight + 0.1, theight + 0.5, 0.2, mat3(1), t, n, vec3(hipp, 0.0));
	
	if(t>1e2)
		return 0.75 * mix(vec3(0.0), vec3(0.18, 0.1, 0.11) * 0.5, rd.y + 0.2) *
				(vec3(1.0) + 0.1 * pow(texture(iChannel1, rd).rgb, vec3(4.0)));
	
	// Perform the shading.
	vec3 rp = ro + rd * t;
	
	if(rp.y < fl + 1e-2)
	{
		col = floorTexture(rp.xz);

#if APPLY_FAKE_FLOOR_GLOW
		// (fake)glow
		mat3 tcam = transpose(cam);
		
		for(int iy = 0; iy < 8; iy += 1)
			for(int ix = 0; ix < 8; ix += 1)
			{
				vec3 op=vec3(0.5 + float(ix - 4) * 2.0 - mod(time * wc_scale * 2.0 * wc_step, 2.0),
							 	fl, 0.5 + float(iy - 4) * 2.0);
				vec3 vp=tcam * (op - ro);
				if(vp.z < 0.0)
				{
					vec2 pp=vp.xy / -vp.z;
					col += vec3(1.0 - smoothstep(0.0,0.3,pow(distance(p,pp), 0.7))) *
									pow(floorTexture(op.xz) * 1.6,vec3(1.5));
				}
			}
#endif
		
	}
	else
	{
		// Apply reflection.
		vec3 r = normalize(reflect(rd, n));
		
		col = texture(iChannel0, r).rgb * 0.2 + vec3(0.01);
		
		{
			float i = (fl - rp.y) / r.y;
			if(i > 0.0)
				col += floorTexture(rp.xz + r.xz * i) * 1.2;
		}
	}
	
	col *= 2.0;
	
	vec3 rpn = normalize(rp - vec3(sin(time * 1.4) * 3.0, 2.0, cos(time) * 3.0));
	
	float u = atan(rpn.z, rpn.x);
	float v = acos(rpn.y);
	
	float fu = fract(u * 8.0 / 3.1415926);
	float fv = fract(v * 6.0);
	
	float iu = floor(u * 8.0 / 3.1415926);
	float iv = floor(v * 6.0);
	
	col += (1.0 - smoothstep(0.3, 0.32, distance(vec2(fu, fv), vec2(0.5)))) * 0.1 *
		mix(vec3(1.0,1.0,0.4) * 0.02, vec3(1.0,0.5,0.4),
			pow(0.5 + 0.5 * cos(iu + iv * 10.0 + time * 3.0), 50.0)) * step(iv, 16.0);
	
	return col;
}

// Function 2597
float sdfPlane(vec3 p){
    return p.y +1.5;
}

// Function 2598
float sdf(vec3 x)
{
	//http://www.johndcook.com/blog/2010/01/13/soft-maximum/
	float sum = 0.0;
	DO_BLOBS( sum += exp( k*(b.w - length(x-b.xyz)) ) )
	return log( sum ) / k;	
}

// Function 2599
float MapTerrainSimple( vec3 p)
{
  float terrainHeight = GetTerrainHeight(p);   
  return  p.y - max((terrainHeight+GetTreeHeight(p, terrainHeight)), 0.);
}

// Function 2600
void MapBlackKeys(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos - vec3(-2.0, 82.75, -5.0);
	float re = MapBoxSim(pos, vec3(63.0, 0.75, 5.0));
	
	if (re <= EPSILON)
	{
		float x = clamp(pos.x/126.0 + 0.5, 0.0, 1.0);//0--1
		if (x<0.03175)//high pitch clamp
		{
			re = max(re, (0.03175-x)*126.0);
		}
		else if (x> 0.984)//low pitch clamp
		{
			re = max(re, (1.0-x)*126.0);
		}
		else
		{
			x = clamp(x-0.02, 0.0,1.0);
			x = fract(x*7.4285714285714285714285714285714);//group num
			if (x<0.1)//#A -- B
				re = max(re, (0.1-x)*7.4285714285714285714285714285714);
			else if (x>0.8861)//C---#C
				re = max(re, (x -0.8861)*7.4285714285714285714285714285714);
			else if (x>0.16 && x < 0.2476)//#G -- #A
				re = max(re, (0.2038-abs(x-0.2038))*7.4285714285714285714285714285714);
			else if (x>0.3343 && x< 0.395)//#F --- #G
				re = max(re, (0.36465-abs(x-0.36465))*7.4285714285714285714285714285714);
			else if (x>0.4817 && x< 0.6408)//#D -- #F
				re = max(re, (0.56125-abs(x-0.56125))*7.4285714285714285714285714285714);
			else if (x>0.7452 && x< 0.8159)//#C-- #D
				re = max(re, (0.78055-abs(x-0.78055))*7.4285714285714285714285714285714);
		}
	}
	
	if (re <= EPSILON)
	{
		obj.m_obj_idx = 4;
	}
	obj.m_dist = re;
}

// Function 2601
float SDF(in vec3 p)
{
    return p.y - textureLod(iChannel0, (p.xz + 50.0) / 150.0, 0.5).r * 0.7;
}

// Function 2602
float Map(  vec3 p)
{

  p.y-=21.25;
  float  d=100000.0;
  vec3 checkPos = p;
  winDist=dekoDist=steelDist=lampDist=doorDist = 100000.0;
  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(3.20, 12.45));
  if (d>.2) return d;

  float noiseScale=(1.+(0.01*abs(noise(p*22.))));
  float noiseScale2=(1.+(0.03*abs(noise(p*13.))));

  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));

  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius*noiseScale, 1.80));
  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4*noiseScale, 1.7*noiseScale));
  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8*noiseScale, 2.6*noiseScale));

  // roof /////////////////
  dekoDist=min(dekoDist, sdConeSection(p-vec3(0., 6.7, 0), 0.40, 1.2, 0.8)); 

  checkPos = p;
  checkPos.xz = pModPolar(checkPos.xz, 26.0);   
  checkPos-=vec3(1.2, 6.7, 0);
  pR(checkPos.xy, 0.5);

  dekoDist=fOpUnionChamfer(dekoDist, sdCappedCylinder(checkPos, vec2(0.08, 0.47)), 0.1); // roof

  steelDist=min(steelDist, sdSphere(p-vec3(0., 6.6, 0), 1.05));    
  vec3 pp = p-vec3(0., 8., 0);
  float m = pModInterval1(pp.y, -0.14, 0.0, 2.);         
  steelDist=min(steelDist, sdSphere(pp, 0.20+(0.12*m)));   
  steelDist = fOpUnionChamfer(steelDist, sdCapsule(p-vec3(0., 8., 0), vec3(0, 0., 0), vec3(0, 1.0, 0), 0.013), 0.1);

  checkPos = p;
  // deko and windows steel top
  checkPos.xz = pModPolar(p.xz, 12.0);
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42))); // top railing
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(inRad-0.06, 4.4, 0), vec2(0.02, 1.45))); // window grid
  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));
  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);
  // top window grid
  pp = p-vec3(0.0, 4.4, 0);
  pModInterval1(pp.y, 0.4, 0.0, 2.);          
  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));  

  // top railing
  pp = p-vec3(0.0, 3.55, 0);
  m = pModInterval1(pp.y, 0.15, 0.0, 3.);          
  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, mix(0.02, .035, step(3., m)))));

  #ifdef HIGH_QUALITY  
  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));
  // lamp
  lampDist = sdEllipsoid(p-vec3(0., 4.9, 0), vec3(0.5, 0.6, 0.5)*(1.+abs(0.1*cos(p.y*50.))));
  lampDist = min(lampDist, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));    
  d=min(d, lampDist);
  #endif
    
  // tower "rings"
  pp = p-vec3(0.0, 4., 0);
  m = pModInterval1(pp.y, 1.8, 0.0, 1.);  
  dekoDist=min(dekoDist, sdTorus(pp, vec2(inRad, mix(.11, 0.15, step(1., m)))));                  

  // upper "rings"
  pp = p-vec3(0.0, -0.6, 0);
  m = pModInterval1(pp.y, -1.05, 0.0, 1.);   
  dekoDist=min(dekoDist, sdTorus(pp, vec2(mix(radius+0.15, radius+0.08, step(1., m)), 0.15)));                  


  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));
  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  

  // upper decoration
  pp = p-vec3(0.0, 2.7, 0);     
  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.10, .30)); pp.y-=.15;
  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.28, 0.18)); pp.y-=.15;
  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.46, 0.18));
  checkPos.xz = pModPolar(p.xz, 6.0);
  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));

  // middle and lower "rings"
  pp = p-vec3(0.0, -9., 0);
  m = pModInterval1(pp.y, -2.3, 0.0, 1.);    
  dekoDist=min(dekoDist, sdTorus(pp, vec2( mix( radius+0.6, 2.42, step(1., m)), .25))); 

  #ifdef HIGH_QUALITY
  // windows cutouts   
  checkPos.xz = pModPolar(p.xz, 6.0);   
  d=max(d, -sdBox(checkPos-vec3(2.20, 1.07, 0.), vec3(3.25, 0.6, 0.4))); 
  checkPos.xz = pModPolar(p.xz, 5.0); 
  pp = checkPos-vec3(2.50, -6.83, 0.);
  pModInterval1(pp.y, 3.5, 0.0, 1.);         
  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  
  #endif

  // upper windows   
  checkPos.xz = pModPolar(p.xz, 6.0);   
  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); 

  // small windows  (upper deco)
  checkPos.xz = pModPolar(p.xz, 5.0); 

  pp = checkPos-vec3(2.10, -2.44, 0.0);
  m=pModInterval1(pp.y, -3.5, 0., 1.);

  pp-=mix(vec3(0.), vec3(0.28, 0.0, 0.), m);
  dekoDist=min(dekoDist, sdBox(pp, vec3(0.3, 0.4, 0.12)));   
  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(pp+vec3(-.30, -0.4, 0.0), 0.21, 0.63), .03); 
  dekoDist = max(dekoDist, -fCylinder(pp+vec3(-.40, .22, 0.0), 0.51, 0.63));  
  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.26 - (m*3.55), 0), vec2(radius+0.25, .15)*(1.0+(m*0.14))));

  // small windows  
  pp = checkPos-vec3(2.82, -8.0, 0.);
  m=pModInterval1(pp.y, 3.5, 0., 1.);
  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.), vec3(0.28, 0.0, 0.), m)));   

  #ifdef HIGH_QUALITY
  // make tower hollow
  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));
  #endif
    
  dekoDist=min(dekoDist, sdTorus(p-vec3(0., -15.2, 0), vec2(2.5, .75*noiseScale2))); 
  
  dekoDist=min(dekoDist, fCylinder(p-vec3(-0.05, -12.95, 2.25), 0.7, 0.5)); 

  // create door opening    
  float doorOpening = min(sdBox(p-vec3(-0.05, -13.9, 2.5), vec3(1.3, 1.4, 4.6)), fCylinder(p-vec3(-0.05, -12.75, 2.5), 0.6, 4.6));

  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));

  checkPos.xz = pModPolar(p.xz, 8.0);
  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    
  checkPos.xz = pModPolar(p.xz, 16.0);
  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    

  d=max(d, -sdBox(p-vec3(-0., -14., 2.7), vec3(0.6, 1.3, 4.6)));    
  d=max(d, -fCylinder(p-vec3(-0., -12.7, 2.5), 0.6, 4.6));    

  // door   
  doorDist =sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4)); 

  // door cutout     
  pp = p-vec3(-0.28, -13., 2.4);
  pModInterval1(pp.x, 0.46, 0., 1.);     
  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.25, 0.08)));   
  pp = p-vec3(-0.28, -13.8, 2.4);   
  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); pp.x-=0.46;
  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); 

  pp = p-vec3(-0., -15.20, 3.30);
  pp.z+=0.3; pp.y-=0.15;
  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  
  pp.z+=0.3; pp.y-=0.15;
  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  
      pp.z+=0.3; pp.y-=0.15;
  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  
  d=min(d, steelDist);
  d=min(d, dekoDist);
  d=min(d, winDist);
  d=min(d, doorDist);
  return  d;
}

// Function 2603
float map(vec3 pos)
{
    float t = 0.0;
    
    t = SuitUp(pos);
    t = min(t, head(pos));
    
    return t;
}

// Function 2604
float mapTerrain( in vec3 pos )
{
	return pos.y - envelope(pos);
}

// Function 2605
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 objCol;
  vec3 col, vn, ltDirUp;
  vec2 w, iw;
  float dstBlk, dstSph, c, sh, dstFloor, dstBack;
  bool isBg, isBlk;
  isBg = false;
  isBlk = false;
  ltDirUp = vec3 (0., -1., 0.);
  dstSph = SphHit (ro, rd);
  dstBlk = BlkHit (ro, rd);
  dstFloor = (rd.y < 0.) ? - (ro.y + 1.4 * spRad) / rd.y : dstFar;
  dstBack = (rd.z > 0.) ? (- ro.z + 1.4 * spRad) / rd.z : dstFar;
  if (dstBlk < dstFar) {
    ro += rd * dstBlk;
    vn = vnBlk;
    c = float (idBlk) / float (nBlock);
    objCol = (max (abs (qBlk.x), abs (qBlk.y)) > 0.7) ? vec4 (1.) :
       vec4 (HsvToRgb (vec3 (c, 1. - 0.3 * mod (4. * c, 1.),
       1. - 0.4 * mod (7. * c, 1.))), 0.5);
    isBlk = true;
  } else if (min (dstBack, dstFloor) < dstFar) {
    if (dstBack < dstFloor) {
      ro += dstBack * rd;
      w = 0.25 * ro.xy * vec2 (1., 2.);
      iw = floor (w);
      if (2. * floor (iw.y / 2.) != iw.y) w.x += 0.5;
      w = smoothstep (0.03, 0.05, abs (fract (w + 0.5) - 0.5));
      objCol = vec4 ((1. - 0.4 * w.x * w.y) * vec3 (0.6, 0.65, 0.6), 0.2);
      vn = vec3 (0., 0., -1.);
    } else if (dstFloor < dstFar) {
      ro += dstFloor * rd;
      objCol = vec4 (mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1),
         Fbm2 (ro.xz * vec2 (1., 0.1))), 0.1) *
         (0.5 + 0.5 * smoothstep (0.05, 0.1, mod (ro.x, 4.)));
      vn = vec3 (0., 1., 0.);
    } else isBg = true;
  } else isBg = true;
  if (isBg) col = vec3 (0., 0., 0.1);
  else {
    sh = min (BlkHitSh (ro + 0.01 * ltDir, ltDir, 100.),
       0.7 + 0.3 * SphHitSh (ro + 0.01 * ltDir, ltDir, 100.));
    col = objCol.rgb * (0.1 + 0.9 * sh * max (dot (vn, ltDir), 0.)) +
       0.5 * objCol.a * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);
    if (isBlk) {
      sh = BlkHitSh (vec3 (0., - 1.1 * spRad, 0.), ltDirUp, 100.);
      col += objCol.rgb * (0.3 * sh * max (dot (vn, ltDirUp), 0.)) +
         0.3 * objCol.a * sh * pow (max (0., dot (ltDirUp, reflect (rd, vn))), 64.);
    }
  }
  if (dstSph < dstFar) {
    col = mix (col, vec3 (0.15), pow (1. - abs (dot (rd, vnSph)), 4.));
    col += 0.01 + 0.07 * max (dot (vnSph, ltDir), 0.) +
       0.1 * pow (max (0., dot (ltDir, reflect (rd, vnSph))), 32.) +
       0.06 * max (dot (vnSph, ltDirUp), 0.) +
       0.08 * pow (max (0., dot (ltDirUp, reflect (rd, vnSph))), 32.);
  }

  return clamp (col, 0., 1.);
}

// Function 2606
void initScene() {
    // Feel free to change materials, positions and sizes...
    
    // Front and back walls
    scene[0] = Object(Sphere(vec3(0.0, 1.2, 1e3 + 2.5), 1e3), materials[MAT_WARMLIGHT]);
    scene[1] = Object(Sphere(vec3(0.0, 1.2, -1e3 - 2.5), 1e3), materials[MAT_METAL]);
    // Left and right walls
    scene[2] = Object(Sphere(vec3(-1e3 - 1.5, 0., 0.), 1e3), materials[MAT_COPPER]);
    scene[3] = Object(Sphere(vec3(1e3 + 1.5, 0., 0.), 1e3), materials[MAT_GOLD]);
    // Ceiling and floor
    scene[4] = Object(Sphere(vec3(0.0, 1e3 + 2.4, 0.), 1e3), materials[MAT_CERAMIC]);
    scene[5] = Object(Sphere(vec3(0.0, -1e3, 0.), 1e3), materials[MAT_SILVER]);
    // Objects
    scene[6] = Object(Sphere(vec3(-0.75, 0.51, 1.3), 0.5), materials[MAT_METAL]);
    scene[7] = Object(Sphere(vec3(0.75, 0.51, 0.3), 0.5), materials[MAT_WATER]);
    // Top light and blocking sphere to avoid Peter Panning
//    scene[8] = Object(Sphere(vec3(0.0, 20. + 2.3925, 0.), 20.), materials[MAT_TOPLAMP]);
//    scene[9] = Object(Sphere(vec3(0.0, 40. + 2.4075, 0.), 40.), materials[MAT_BLACKHOLE]);
}

// Function 2607
vec3 bsdfEvaluate(const in vec3 wi, const in vec3 wo, const in vec3 X, const in vec3 Y, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    if( !sameHemiSphere(wo, wi, interaction.normal) )
        return vec3(0.);
    
	float NdotL = dot(interaction.normal, wo);
    float NdotV = dot(interaction.normal, wi);
    
    if (NdotL < 0. || NdotV < 0.) return vec3(0.);

    vec3 H = normalize(wo+wi);
    float NdotH = dot(interaction.normal,H);
    float LdotH = dot(wo,H);
    
    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH, material);
    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH, material);
    vec3 glossy = disneyMicrofacetAnisotropic(NdotL, NdotV, NdotH, LdotH, wi, wo, H, X, Y, material);
    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH, material);
    vec3 sheen = disneySheen(LdotH, material);
    
    return ( mix(diffuse, subSurface, material.subsurface) + sheen ) * (1. - material.metallic) + glossy + clearCoat;
}

// Function 2608
Object map(vec3 pos)
{
    Object o;
    o.difVal = 1.0;
    
    o.dist = 1000.0;
    o.normEps = 0.001;
    o.color = vec3(0);
    
    //float ang = PI/2.0;
    float fracAng = iTime/12.0;
    vec3 objPos = pos - vec3(0.0, -0.0, 0.0); 
    
     objPos.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * objPos.xz;
    float dSphere = sdSphere(objPos, 5.0);

    if(dSphere < o.dist){
        o.dist = dSphere;
        o.color = mix(vec3(0, 0.2, 0.9)*fbm(objPos/2.0), vec3(.1, .3, .15)*fbm(objPos*1.5), step(0.5, fbm(objPos*1.5)));
        o.specVal = 8.0;
        o.specKs = 0.01;
    }
    
    float size = 1.0;
    //float angFrac = PI/6.0;
    vec3 posFracOff = vec3(9, 0.0, 10.);
    
    vec3 posFrac = objPos - posFracOff;
    float dDist;
    float minDist;

	
    dDist = sdSphere(posFrac, size);
    
    float scale = 2.7;
    vec3 p = objPos/scale;
    float modi;
    
    for(float x=0.0; x < ITERATIONS; x++)
    {        
        modi =(p.x * p.z) / abs(p.x * p.z);
        fracAng *= modi;
        p.x = abs(p.x);
        p.z = abs(p.z);
        p = p * scale;

        p -= posFracOff;
        p.xz = mat2(cos(fracAng), sin(fracAng), -sin(fracAng), cos(fracAng)) * p.xz;
      
        float newDDist = sdSphere(p, 1.5) / pow(scale, x);
        
        //newDDist /= size;
        dSphere = min(dSphere, newDDist);
        if(dSphere < o.dist){
            o.dist = dSphere;
            
            float d;
            float minDist = 10000.0;
            vec3 minPt;
            vec3 len = (p);
            vec3 len1 = p - posFracOff;
            vec2 id;
            
            float angZ = atan(len.z, len.x);
            float angY =atan(len.y,len.x);
            
            float scale = 20.0;
            float yScale = 24.0;
            
            angZ *= scale;
            id.x = floor(angZ/PI);
            id.y = floor(p.y*yScale / PI);
            
            id += vec2(x*modi);
  
            float dVor, minDVor;
            vec3 vor;
            vec2 minId;
            
            float ang1 = -id.x*PI / scale;
            vec3 orig = vec3(0, id.y * PI / yScale, 0);
            float angRise = asin(orig.y / 1.5);
            vec3 origBase = vec3(1.5, 0, 0);
            origBase.xy = mat2(cos(angRise), sin(angRise), -sin(angRise), cos(angRise)) * origBase.xy;
            origBase.xz = mat2(cos(ang1), -sin(ang1), sin(ang1), cos(ang1)) * origBase.xz;
            orig.xz = origBase.xz;
            
            
            minDVor = 1000.0;
            minId = id;
            for(float x=-1.0; x<=1.0; x++)
            {
                for(float y=-1.0; y<=1.0; y++)
                {
                    vec2 off = vec2(x,y);
                    vec2 idOff = id+off;
                    if(idOff.x == scale)
                        idOff.x = -scale;
                    if(idOff.x == -(scale+1.))
                        idOff.x = scale-1.;
                    
                    float ang1Off = -idOff.x*PI / scale;
                    vec3 origOff = vec3(0, idOff.y * PI / yScale, 0);
                    float angRiseOff = asin(origOff.y / 1.5);
                    vec3 origBaseOff = vec3(1.5, 0, 0);
                    origBaseOff.xy = mat2(cos(angRiseOff), sin(angRiseOff), -sin(angRiseOff), cos(angRiseOff)) * origBaseOff.xy;
                    origBaseOff.xz = mat2(cos(ang1Off), -sin(ang1Off), sin(ang1Off), cos(ang1Off)) * origBaseOff.xz;
                    origOff.xz = origBaseOff.xz;

                    vec2 rotsOff = random(idOff, vec2(2.*PI/(scale + (scale)), 0), vec2(0, 0));
                    vor.xz = mat2(cos(-rotsOff.x), -sin(-rotsOff.x), sin(-rotsOff.x), cos(-rotsOff.x)) * origOff.xz;
                    vor.y = origOff.y;
                    
                    dVor = length(p - vor);
                    if(dVor < minDVor)
                    {
                     	minDVor = dVor;
                        minId = idOff;
                    }
                }
        	}
            
            vec3 posId = vec3(minId, 1);
            o.color = mix(vec3(0.1, 0.1, 0.055)*fbm(posId/5.0), vec3(0.3, 0.15, 0.066)*fbm(posId/2.0), 
                          step(posId.y, (yScale/2.0)-2.0) * step(0.5, fbm(posId/5.0)));

            o.specVal = 8.0;
            o.specKs = 0.01;
    	}
    }
    
    
    return o;
}

// Function 2609
float map( in vec3 pos )
{
    
    float d1 = pos.y-terrainHeight(pos)*2.;
    return d1;//smin( d1, d2, 1.0 );
}

// Function 2610
vec3 cmap(float W) {
    vec3 C;
    C.x = .5+.5*cos(pi*W);
    C.y = .5+.5*cos(pi*4.*W);
    C.z = .5+.5*cos(pi*2.*W);
    return C;
  }

// Function 2611
vec4 readMapTex(vec2 pos) {
 	return textureLod(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy, 0.0);   
}

// Function 2612
void InitScene()
{
    // 64 seconds per cycle
    // offset range [0, 64)
    float time_offset = mod(iTime, duration_1);
    float time_rate = time_offset / duration_1;

    // camera position
    float theta = getTheta(time_offset) / 180.0 * PI;
    float phi = getPhi(time_offset) / 180.0 * PI;

    // Position the camera.
    cam_pos = global_center + vec3(
        camera_distance * sin(phi) * cos(theta),
        camera_distance * cos(phi),
        camera_distance * sin(phi) * sin(theta)
    );
    cam_lookat = global_center;
    cam_up_vec = vec3( 0.0, 1.0, 0.0 );

    // Horizontal plane.
    Plane[0].A = 0.0;
    Plane[0].B = 1.0;
    Plane[0].C = 0.0;
    Plane[0].D = 0.0;
    Plane[0].materialID = 0;

    // Vertical plane.
    Plane[1].A = 0.0;
    Plane[1].B = 0.0;
    Plane[1].C = 1.0;
    Plane[1].D = 2.0;
    Plane[1].materialID = 6;

    // rotate position
    float sphere_offset = mod(time_offset, duration_sphere);
    float sphere_rate = sphere_offset / duration_sphere;

    // first session, 32 seconds
    if (time_offset >= 0.0 && time_offset <= 32.0) {
        // four main balls
        // sphere 0, move along z axis
        Sphere[0].center = vec3( 
        global_center.x, 
        y_sphere_0(time_offset) - sphere_radius_1, 
        global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI) );
        Sphere[0].radius = sphere_radius_1;
        // visible only in first session
        Sphere[0].visible = (time_offset >= 0.0 && time_offset <= 32.0);
        Sphere[0].materialID = 9;

        // sphere 1, move along x axis
        Sphere[1].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 90.0 / 180.0 * PI), 
            y_sphere_1(time_offset) - sphere_radius_1, 
            global_center.z );
        Sphere[1].radius = sphere_radius_1;
        Sphere[1].visible = (time_offset >= 4.0 && time_offset <= 32.0);
        Sphere[1].materialID = 10;

        // sphere 2, move along [z - x = 0] line
        Sphere[2].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0), 
            y_sphere_2(time_offset) - sphere_radius_1,  
            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0));
        Sphere[2].radius = sphere_radius_1;
        Sphere[2].visible = (time_offset >= 8.0 && time_offset <= 32.0);
        Sphere[2].materialID = 10;

        // sphere 3, move along [z + x = 0] line 
        Sphere[3].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0), 
            y_sphere_3(time_offset) - sphere_radius_1,  
            global_center.z - track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0));
        Sphere[3].radius = sphere_radius_1;
        Sphere[3].visible = (time_offset >= 12.0 && time_offset <= 32.0);
        Sphere[3].materialID = 10;

        // four assistant balls
        // sphere 4, the same motion as sphere 0, located below sphere 0
        Sphere[4].center = vec3( 
            global_center.x, 
            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2, 
            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI) );
        Sphere[4].radius = sphere_radius_2;
        Sphere[4].visible = (time_offset >= 20.0 && time_offset <= 32.0);
        Sphere[4].materialID = 10;

        // sphere 5, the same motion as sphere 1, located below sphere 1
        Sphere[5].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 90.0 / 180.0 * PI), 
            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2, 
            global_center.z );
        Sphere[5].radius = sphere_radius_2;
        Sphere[5].visible = (time_offset >= 20.0 && time_offset <= 32.0);
        Sphere[5].materialID = 9;

        // sphere 6, the same motion as sphere 2, located below sphere 2
        Sphere[6].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0), 
            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2,  
            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0));
        Sphere[6].radius = sphere_radius_2;
        Sphere[6].visible = (time_offset >= 20.0 && time_offset <= 32.0);
        Sphere[6].materialID = 9;

        // sphere 7, the same motion as sphere 3, located below sphere 3
        Sphere[7].center = vec3( 
            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0), 
            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2,  
            global_center.z - track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0));
        Sphere[7].radius = sphere_radius_2;
        Sphere[7].visible = (time_offset >= 20.0 && time_offset <= 32.0);
        Sphere[7].materialID = 9;

        // track 0, along z axis
        Box[0].corner1 = vec3(
            global_center.x - track_W / 2.0, 
            y_track_0(time_offset) - track_H - 2.0 * sphere_radius_1, 
            global_center.z - track_L / 2.0);
        Box[0].corner2 = vec3(
            global_center.x + track_W / 2.0, 
            y_track_0(time_offset) - 2.0 * sphere_radius_1, 
            global_center.z + track_L / 2.0);
        Box[0].angle = 0.0;
        Box[0].visible = (time_offset >= 0.0 && time_offset <= 18.0);
        Box[0].materialID = 5;

        // track 1, along x axis
        Box[1].corner1 = vec3(
            global_center.x - track_L / 2.0, 
            y_track_1(time_offset) - track_H - 2.0 * sphere_radius_1, 
            global_center.z - track_W / 2.0);
        Box[1].corner2 = vec3(
            global_center.x + track_L / 2.0, 
            y_track_1(time_offset) - 2.0 * sphere_radius_1, 
            global_center.z + track_W / 2.0);
        Box[1].angle = 0.0;
        Box[1].visible = (time_offset >= 4.0 && time_offset <= 18.0);
        Box[1].materialID = 5;

        // track 2, along [z - x = 0] line
        Box[2].corner1 = vec3(
            global_center.x + (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0), 
            y_track_2(time_offset) - track_H - 2.0 * sphere_radius_1, 
            global_center.z - (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0));
        Box[2].corner2 = vec3(
            global_center.x - (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0), 
            y_track_2(time_offset) - 2.0 * sphere_radius_1, 
            global_center.z + (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0));
        Box[2].angle = 45.0 / 180.0 * PI;
        Box[2].visible = (time_offset >= 8.0 && time_offset <= 18.0);
        Box[2].materialID = 5;
        
        // track 3, along [z + x = 0] line
        Box[3].corner1 = vec3(
            global_center.x + (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0), 
            y_track_3(time_offset) - track_H - 2.0 * sphere_radius_1, 
            global_center.z + (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0));
        Box[3].corner2 = vec3(
            global_center.x - (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0), 
            y_track_3(time_offset) - 2.0 * sphere_radius_1, 
            global_center.z - (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0));
        Box[3].angle = -45.0 / 180.0 * PI;
        Box[3].visible = (time_offset >= 12.0 && time_offset <= 18.0);
        Box[3].materialID = 5;

        // long thin flagpole
        Box[4].corner1 = vec3(
            global_center.x + track_L / 4.0 * cos(sphere_rate * 2.0 * PI) - pole_L / 2.0, 
            y_pole(time_offset) - pole_H, 
            global_center.z + track_L / 4.0 * sin(sphere_rate * 2.0 * PI) - pole_W / 2.0);
        Box[4].corner2 = vec3(
            global_center.x + track_L / 4.0 * cos(sphere_rate * 2.0 * PI) + pole_L / 2.0, 
            y_pole(time_offset), 
            global_center.z + track_L / 4.0 * sin(sphere_rate * 2.0 * PI) + pole_W / 2.0);
        Box[4].angle = 0.0;
        Box[4].visible = (time_offset >= 20.0 && time_offset <= 32.0);
        Box[4].materialID = 5;
    }

    // second session
    else if (time_offset >= 32.0 && time_offset <= 64.0) {
        // balls on tree, combined together
        // like a new-moon shape
        float ball_x[NUM_TREE_BALL];
        float ball_y[NUM_TREE_BALL];
        float ball_z[NUM_TREE_BALL];
        // all balls are rotating with 4 seconds cycle
        float theta_offset = mod(time_offset, ball_period) / ball_period * 2.0 * PI;

        for (int i = 0 ; i < NUM_TREE_BALL ; i++) {
            // get catesian coordinates     
            ball_x[i] = ball_distance * sin(ball_phi[i]) * cos(ball_theta[i] + theta_offset);
            ball_y[i] = ball_distance * cos(ball_phi[i]);
            ball_z[i] = ball_distance * sin(ball_phi[i]) * sin(ball_theta[i] + theta_offset);
        }
        
        // ball 8, the first top-right ball of the new-moon
        Sphere[8].center = tree_ball_center + vec3(
            ball_x[0],
            ball_y[0] - tree_H + y_tree(time_offset),
            ball_z[0]
        );
        Sphere[8].radius = ball_radius_3;
        Sphere[8].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Sphere[8].materialID = 9;

        // ball 9, the second top-right ball of the new-moon
        Sphere[9].center = tree_ball_center + vec3(
            ball_x[1],
            ball_y[1] - tree_H + y_tree(time_offset),
            ball_z[1]
        );
        Sphere[9].radius = ball_radius_2;
        Sphere[9].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Sphere[9].materialID = 10;
        
        // ball 10, at the center, the biggest ball
        Sphere[10].center = tree_ball_center + vec3(
            ball_x[2],
            ball_y[2] - tree_H + y_tree(time_offset),
            ball_z[2]
        );
        Sphere[10].radius = ball_radius_1;
        Sphere[10].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Sphere[10].materialID = 9;
        
        // ball 11, the second down-left ball of the new-moon
        Sphere[11].center = tree_ball_center + vec3(
            ball_x[3],
            ball_y[3] - tree_H + y_tree(time_offset),
            ball_z[3]
        );
        Sphere[11].radius = ball_radius_2;
        Sphere[11].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Sphere[11].materialID = 10;
        
        // ball 12, the first down-left ball of the new-moon
        Sphere[12].center = tree_ball_center + vec3(
            ball_x[4],
            ball_y[4] - tree_H + y_tree(time_offset),
            ball_z[4]
        );
        Sphere[12].radius = ball_radius_3;
        Sphere[12].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Sphere[12].materialID = 9;

        // tree trunk 1, the left lower one
        Box[5].corner1 = vec3(
            global_center.x - tree_distance / 2.0 - tree_W, 
            y_tree(time_offset) - tree_H, 
            global_center.z - tree_W / 2.0);
        Box[5].corner2 = vec3(
            global_center.x - tree_distance / 2.0, 
            y_tree(time_offset) - tree_diff, 
            global_center.z + tree_W / 2.0);
        Box[5].angle = 0.0;
        Box[5].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Box[5].materialID = 5;

        // tree trunk 2, the right higher one
        Box[6].corner1 = vec3(
            global_center.x + tree_distance / 2.0, 
            y_tree(time_offset) - tree_H, 
            global_center.z - tree_W / 2.0);
        Box[6].corner2 = vec3(
            global_center.x + tree_distance / 2.0 + tree_W, 
            y_tree(time_offset), 
            global_center.z + tree_W / 2.0);
        Box[6].angle = 0.0;
        Box[6].visible = (time_offset >= 32.0 && time_offset <= 64.0);
        Box[6].materialID = 5;
    }
    
    // Silver material.
    Material[0].k_d = vec3( 0.4, 0.4, 0.4 );
    Material[0].k_a = 0.2 * Material[0].k_d;
    Material[0].k_r = 2.0 * Material[0].k_d;
    Material[0].k_rg = 0.5 * Material[0].k_r;
    Material[0].n = 64.0;

    // red ball
    Material[1].k_d = vec3( 1.0, 0.0, 1.0 );
    Material[1].k_a = 0.2 * Material[1].k_d;
    Material[1].k_r = vec3(1.0, 1.0, 1.0);
    Material[1].k_rg = 0.5 * Material[1].k_r;
    Material[1].n = 128.0;

    // blue ball
    Material[2].k_d = vec3( 0.1176, 0.5647, 1.0 );
    Material[2].k_a = 0.2 * Material[2].k_d;
    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[2].k_rg = 0.5 * Material[2].k_r;
    Material[2].n = 128.0;

    // light floor
    Material[3].k_d = vec3( 0.6, 0.6, 0.6 );
    Material[3].k_a = 0.2 * Material[3].k_d;
    Material[3].k_r = 2.0 * Material[3].k_d;
    Material[3].k_rg = 0.5 * Material[3].k_r;
    Material[3].n = 64.0;

    // orange ball
    Material[4].k_d = vec3( 1.0, 0.647, 0.0 );
    Material[4].k_a = 0.2 * Material[4].k_d;
    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[4].k_rg = 0.5 * Material[4].k_r;
    Material[4].n = 128.0;

    // box track
    Material[5].k_d = vec3( 1.0, 1.0, 1.0 );
    Material[5].k_a = 0.2 * Material[3].k_d;
    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[5].k_rg = 0.5 * Material[3].k_r;
    Material[5].n = 128.0;

    // mirror
    Material[6].k_d = vec3( 0.3, 0.3, 0.3 );
    Material[6].k_a = 0.2 * Material[0].k_d;
    Material[6].k_r = 2.0 * Material[0].k_d;
    Material[6].k_rg = 0.5 * Material[0].k_r;
    Material[6].n = 64.0;

    // fire brick
    Material[7].k_d = vec3( 1.0, 0.1882, 0.1882 );
    Material[7].k_a = 0.2 * Material[4].k_d;
    Material[7].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[7].k_rg = 0.5 * Material[4].k_r;
    Material[7].n = 128.0;

    // to store galaxy
    Material[8].k_d = vec3( 0.0, 0.0, 0.0 );
    Material[8].k_a = 0.2 * Material[0].k_d;
    Material[8].k_r = 2.0 * Material[0].k_d;
    Material[8].k_rg = 0.5 * Material[0].k_r;
    Material[8].n = 64.0;

    // yellow ball
    Material[9].k_d = vec3( 1.0, 1.0, 0.0 );
    Material[9].k_a = 0.2 * Material[4].k_d;
    Material[9].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[9].k_rg = 0.5 * Material[4].k_r;
    Material[9].n = 128.0;

    // light yellow ball
    Material[10].k_d = vec3( 1.0, 1.0, 0.8784 );
    Material[10].k_a = 0.2 * Material[4].k_d;
    Material[10].k_r = vec3( 1.0, 1.0, 1.0 );
    Material[10].k_rg = 0.5 * Material[4].k_r;
    Material[10].n = 128.0;

    // Light 0.
    Light[0].position = vec3( 16.0 + 4.0 * sin(time_rate * 16.0 * PI), 18.0, 15.0);
    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );
    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );

    // Light 1.
    // Light[1].position = vec3( -4.0, 20.0, 3.0 );
    // Light[1].I_a = vec3( 0.1, 0.1, 0.1 );
    // Light[1].I_source = vec3( 0.8, 0.8, 0.8 );
}

// Function 2613
float getDistance (in vec3 p) {
	p = mRotate (vec3 (iTime)) * p;

	float topCut = p.y - 1.0;
	float angleStep = PI / (iMouse.z < 0.5 ? 8.0 : 2.0 + floor (18.0 * iMouse.x / iResolution.x));
	float angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));
	vec3 q = vRotateY (p, angle);
	float topA = dot (q, normalTopA) - 2.0;
	float topC = dot (q, normalTopC) - 1.5;
	float bottomA = dot (q, normalBottomA) - 1.7;
	q = vRotateY (p, -angleStep * 0.5);
	angle = angleStep * floor (atan (q.x, q.z) / angleStep);
	q = vRotateY (p, angle);
	float topB = dot (q, normalTopB) - 1.85;
	float bottomB = dot (q, normalBottomB) - 1.9;

	return max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));
}

// Function 2614
vec2 map(vec3 ro) {
    
    //beveled cubes
    vec2 disp = vec2(1., 0.);
    float d = bevcube(ro);
    d = min(d, bevcube(ro + disp.xyy));
    d = min(d, bevcube(ro - disp.xyy));
    d = min(d, bevcube(ro + disp.yyx));
    d = min(d, bevcube(ro - disp.yyx));
    d = min(d, bevcube(ro - disp.yxy));
    
    float d2 = min(d, length(ro + vec3(0., 10., 0.)) - 9.6);
    if (d2 < d) {
        return vec2(d2, 2.0);
    } else {
    	return vec2(d, 1.0);
    }
}

// Function 2615
float fetch_distance(in vec3 uv)
{   
    float t0 = tT;
    vec2 x0 = uv.xy * (0.25*PI)/(uv.z);
    
    vec2 c = (x0 - t0) - floor(x0 - t0);
    
    vec4 y0;
    y0.xy = abs(c * 2.0f - 1.0f);
    y0.zw = abs(c * 2.0f - 1.0f) * 1.0f / (0.5f + pow((2.0f*PI) - uv.x, 2.0f));
    
    vec2 j = abs(vec2(sin(t0), cos(t0)));
    
    vec4 a;
    a.xy = j.y + y0.xy * j.x;
    a.zw = -j.x + y0.xy * j.y;
    
    vec4 b;
    b.xy = j.y + y0.zw * j.x;
    b.zw = -j.x + y0.zw * j.y;
     
    a *= uv.z;
    b *= uv.z; 
    
    vec2 y1 = (b.xy - a.zw) + (b.zw - a.xy);
    
    return length(y1 - y0.xy) - length(y1 - y0.zw);
}

// Function 2616
float sdf_u(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    return t;
}

// Function 2617
void shadeScene(inout vec3 o,bool Refl,float id,in vec3 p,float l,in vec3 n,vec2 uv,in vec3 amb,vec3 sun,in vec3 dir)
{
		
    if(id==ID_BLACK) 
    	o= amb*vec3(.3);
     if(id==ID_WOOD) 
    	o= amb*vec3(.6,.3,.1)*texture(iChannel2,uv*3.).rgb;
	if(id==ID_LAPTOPSCR)
    {
        if ( scene.gameState.w == 0. )
        {
            o-=o;
        } else
        {
        	o= vec3(uv.yx,0.5+0.5*sin(iTime));//*amb*texture(iChannel2,uv*2.).x;
        }
    }
    
    if ( id == ID_SSCREEN )
    {
        o = vec3(1,1,0)*amb;
    }
    
    if(id==ID_BAF_TW)
    {
     float n = noise(vec3(uv,.1*iTime)),
          v = sin(6.28*10.*n);
  	  v = smoothstep(0.,1., .7*abs(v)/fwidth(v));
    n = floor(n*20.)/20.;
	o = v * (.5+.5*cos(12.*n+vec3(0,2.1,-2.1))) * amb;
    } else
    if(id==ID_MPA_TW)
    {	vec2 i= floor(uv*60.);
        o=tan(dot(i,i)*.6+sin(iDate.wwx))*amb;
    }
    if(id==ID_MPAL)
    {
    	// scene.gameState.y ==1. => ho la crema
        
        vec3 r = reflect(dir,n);
    	vec3 specular = pow(max(dot(r,sun),0.0),350.0)*sunColor(sun);
    	o= (amb+specular*scene.gameState.y)*vec3(.6,.4,.4);
    }
    
     if(id==ID_PALM) 
    	o= amb*vec3(0.2,.6,.2);
    
    if(id == ID_OCEAN)
    {
     
        o = water(uv).xyz*amb;
    }
    if ( id == ID_BAFRYCE )
    {
        o = vec3(1.)*amb;
    }
    if(id==ID_COCONUT)
    {
    	o= vec3(.54,0.2,.1)*amb;
    }
}

// Function 2618
sHit mapRefl( in vec3 pos )
{
    sHit sRes = createHit( 1e10, -1.0, pos );

    vec2 bent = getBent();
    vec3 p0 = pos;    
    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;
    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;
   
    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;
    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    
    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );
    pPlayer.xz *= rot(  0.2 * bent.x );
    pPlayer.yz *= rot( -0.2 * bent.y );
    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);
    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);
    pPlayer.y += 0.05;
	sRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );

    p0.z *= 0.5;
    p0.z += g_S.playerPos.y;      
    
    vec3 p0Mod = p0;
    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;
                
    float playerCellID = floor( g_S.playerPos.y );
   
    // COIN start
    float cellID = floor( p0.z + 0.5 );
    
    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    
    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins
    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start
    float cellCoinCol = floor( 3.0 * cellCoinRND );
    
    if ( cellCoinRND >= 0.0 )
    {
        vec3 pCoin = p0Mod; 
        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );
        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );
        pCoin -= coinOffset;
        pCoin.z *= 2.0;
        pCoin.xz *= rot( 10.0 * iTime );
                
        if ( cellID > playerCellID )
            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );
    }    
       
    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving
    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );
    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start
    float cellObsCol = floor( 3.0 * cellObsRND );

    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )
    {            
        vec3 obstacleOffset = vec3(
            -0.5 + cellObsCol,  
             0.2,
             0.0
        );

        p0Mod -= obstacleOffset;
        p0Mod.z *= 2.0;
        p0Mod.xz *= rot( -0.5 * PI );
        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );
    }

    return sRes;
}

// Function 2619
vec4 map( vec3 pos)
{
	vec4 ret = mapFloor( pos );

	vec4 res = combine( ret, StrangeSphere(pos));
	return res;
}

// Function 2620
float tonemapOp(float v)
{
    v = pow(v, 2.0);
    v = v / (1.0 + v);
    return pow(v, 1.0/2.0) * 1.02;
}

// Function 2621
float map(vec3 p, float t) {
    float globalScale = 1.0;
    p/=globalScale;
    p+=vec3(0,0,0);
    
#if SIMPLE_HEAD
    
 vec3 TPos_0=mirror(p-vec3(0, 0, 0));

  float res = smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0, 0, 0), vec3(0, 0.8981191, -0.2021628), 0.65, 0.8194701),
 caps(TPos_0, vec3(0, 0.885, -0.359), vec3(0, 0.6657753, -0.8952476), 0.90), 0.3),
 sph(TPos_0-vec3(0, 1.058, -0.7920001), 0.86), 0.3),
 conecaps(TPos_0, vec3(0, -1.343, -1.035), vec3(0, -0.01590037, -1.035), 0.65, 0.4129604), 0.3),
 conecaps(TPos_0, vec3(0.448, 0.493, 0.413), vec3(0.0964303, 0.4929999, 0.6215981), 0.25, 0.07000001), 0.3),
 conecaps(TPos_0, vec3(0, 0.731, 0.899), vec3(0, 0.9994185, 0.6862392), 0.08, -0.04511364), 0.3),
 conecaps(TPos_0, vec3(0, -0.388, 0.524), vec3(0, 0.2982672, 0.6916121), 0.36, 0.1544515), 0.3),
 conecaps(TPos_0, vec3(0, -1.4863, -0.585), vec3(0, -0.4297584, -0.1084773), 0.28, 0.1755086), 0.3);
    
#else
 vec3 TPos_0=mirror(p-vec3(0, 0, 0));

  float res = min(smax(smin(sph(p-vec3(-0.014, 0.87, -0.641), 1.20),
 sph(p-vec3(0.031, 1.05, -0.291), 0.89), 0.2),
 smin(smin(smin(conecaps(p, vec3(0.06, 1.785, -0.043), vec3(-0.06637037, 1.56574, 0.3384626), 0.15, 0.04923537),
 conecaps(p, vec3(0.197, 1.788, 0.109), vec3(0.4121402, 1.385284, 0.392923), 0.12, 0.03994529), 0.1),
 conecaps(p, vec3(-0.147, 1.735, 0.115), vec3(-0.5633237, 1.244842, 0.6771756), 0.12, -0.01053677), 0.1),
 conecaps(p, vec3(0.373, 1.719, 0.078), vec3(0.7583238, 1.083739, 0.3566932), 0.11, 0.002208568), 0.1), 0.1),
 min(smax(smin(sph(TPos_0-vec3(-0.014, 0.87, -0.641), 1.20),
 sph(TPos_0-vec3(0.031, 0.237, -1.288), 0.68), 0.2),
 smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0.18, 1.84, 0), vec3(0.9947872, 1.059192, 0), 0.20, 0.080608),
 conecaps(TPos_0, vec3(0.457, 1.778, -0.233), vec3(1.218826, 0.6229788, -0.233), 0.20, 0.06851683), 0.1),
 conecaps(TPos_0, vec3(0.475, 1.751, -0.502), vec3(1.163649, 0.834214, -0.5103351), 0.20, 0.06247119), 0.1),
 conecaps(TPos_0, vec3(0.501, 1.644, -0.687), vec3(1.324742, 0.4498808, -0.815752), 0.20, 0.0), 0.1),
 conecaps(TPos_0, vec3(0.438, 1.681, -0.818), vec3(1.25843, 0.5285492, -1.07989), 0.20, 0.05239521), 0.1),
 conecaps(TPos_0, vec3(0.4150705, 1.692155, -0.892), vec3(0.977915, 0.8010392, -1.295309), 0.20, 0.080608), 0.1),
 conecaps(TPos_0, vec3(0.4665176, 1.612289, -1.137529), vec3(0.9487399, 0.3972942, -1.591065), 0.20, 0.06851687), 0.1),
 conecaps(TPos_0, vec3(0.3073766, 1.580032, -1.345637), vec3(0.6488477, 0.554816, -1.729217), 0.20, 0.0624712), 0.1),
 conecaps(TPos_0, vec3(0.2050478, 1.472336, -1.527339), vec3(0.5545081, 0.120172, -1.940346), 0.20, 0.0), 0.1),
 conecaps(TPos_0, vec3(0.1044063, 1.466208, -1.451), vec3(0.2097557, 0.2754359, -2.251505), 0.20, 0.05239522), 0.1),
 conecaps(TPos_0, vec3(0.87, 0.82, -0.9), vec3(0.4488406, -0.6502159, -0.9097424), 0.20, -0.03828883), 0.1),
 conecaps(TPos_0, vec3(0.828, 0.657, -1.139), vec3(0.3844372, -0.6142089, -1.146863), 0.20, -0.0463496), 0.1),
 conecaps(TPos_0, vec3(0.873, 0.646, -1.581), vec3(0.1269265, -0.3829435, -1.104255), 0.20, 0.09471444), 0.1),
 conecaps(TPos_0, vec3(0.441, 0.689, -1.627), vec3(0.3258284, -0.4353262, -1.433523), 0.20, 0.06247126), 0.1),
 conecaps(TPos_0, vec3(0.258, 0.693, -1.761), vec3(0.02478147, -0.7067026, -1.433148), 0.20, 0.0), 0.1),
 conecaps(TPos_0, vec3(0, 0.874, -1.885), vec3(0, -0.5986498, -1.709854), 0.20, 0.008060798), 0.1),
 conecaps(TPos_0, vec3(0.842, 0.572, -0.745), vec3(0.6800996, -0.4511317, -0.438101), 0.14, -0.0270476), 0.1),
 conecaps(TPos_0, vec3(0.208, 1.842, -0.244), vec3(0.583753, 1.851966, -1.308072), 0.20, 0.080608), 0.1),
 conecaps(TPos_0, vec3(0.098, 1.844, -0.505), vec3(0.3196597, 1.71843, -1.604381), 0.20, 0.080608), 0.1),
 conecaps(TPos_0, vec3(0, 1.844, -0.84), vec3(0, 1.584119, -1.938181), 0.20, 0.08060801), 0.1), 0.1),
 smax(smin(smax(smin(smin(smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0, 0, 0), vec3(0, 0.8981191, -0.2021628), 0.65, 0.8194701),
 caps(TPos_0, vec3(0, 0.885, -0.359), vec3(0, 0.6657753, -0.8952476), 0.90), 0.3),
 sph(TPos_0-vec3(0, 1.058, -0.7920001), 0.86), 0.3),
 conecaps(TPos_0, vec3(0, -1.343, -1.035), vec3(0, -0.01590037, -1.035), 0.65, 0.4129604), 0.3),
 conecaps(TPos_0, vec3(0.448, 0.493, 0.413), vec3(0.0964303, 0.4929999, 0.6215981), 0.25, 0.07000001), 0.3),
 conecaps(TPos_0, vec3(0, 0.731, 0.899), vec3(0, 0.9994185, 0.6862392), 0.08, -0.04511364), 0.3),
 conecaps(TPos_0, vec3(0, -0.388, 0.524), vec3(0, 0.2982672, 0.6916121), 0.36, 0.1544515), 0.3),
 conecaps(TPos_0, vec3(0.793, 0.575, -0.45), vec3(0.9685718, 0.8660991, -0.5075423), 0.18, 0.07538141), 0.3),
 conecaps(TPos_0, vec3(0.651, -1.4863, -0.585), vec3(0.4176198, -0.006287336, -1.020103), 0.28, -0.2256553), 0.3),
 conecaps(TPos_0, vec3(0, -1.4863, -0.585), vec3(0, -0.4297584, -0.1084773), 0.28, 0.1755086), 0.3),
 -min(min(min(min(conecaps(TPos_0, vec3(0.39, 1.001, 0.687), vec3(0.760278, 1.001, 0.4733404), 0.25, 0.0725),
 conecaps(TPos_0, vec3(0.063, -0.031, 0.736), vec3(0.3386817, -0.03100006, 0.5769249), 0.19, 0.05397813)),
 conecaps(TPos_0, vec3(-0.014, -0.095, 0.604), vec3(0.2963244, -0.09500001, 0.4122402), 0.24, 0.06858408)),
 caps(TPos_0, vec3(0.149, -0.406, 0.994), vec3(0.01727781, -0.406, 0.994), 0.13)),
 conecaps(TPos_0, vec3(0.986, 0.769, -0.405), vec3(0.9680421, 0.520758, -0.405), 0.15, 0.04220953)), 0.1),
 smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smax(caps(TPos_0, vec3(0.143, 1.041, 0.541), vec3(0.4671654, 1.005373, 0.3770713), 0.07),
 -conecaps(TPos_0, vec3(0.274, 0.946, 0.563), vec3(0.4998161, 0.9211818, 0.448806), 0.10, 0.06821328), 0.02),
 smax(smax(caps(TPos_0, vec3(0.175, 0.877, 0.58), vec3(0.5016567, 0.8574979, 0.4183209), 0.07),
 -conecaps(TPos_0, vec3(0.239, 0.967, 0.568), vec3(0.5910456, 1.022967, 0.4102298), 0.07, 0.04818002), 0.04),
 -conecaps(TPos_0, vec3(0.408, 0.945, 0.483), vec3(0.06001997, 0.9721231, 0.6565917), 0.07, 0.04818002), 0.04), 0.05),
 conecaps(TPos_0, vec3(0.41, 0.757, 0.531), vec3(0.07579309, 0.8708386, 0.6575592), 0.08, -0.02930647), 0.05),
 conecaps(TPos_0, vec3(0.855, 0.689, -0.37), vec3(0.837042, 0.4407571, -0.37), 0.15, 0.04220968), 0.05),
 smin(sph(TPos_0-vec3(0, 0.718, 0.877), 0.10),
 conecaps(TPos_0, vec3(0.1, 0.677, 0.783), vec3(-0.05059213, 0.9789532, 0.6192493), 0.08, -0.02930725), 0.05), 0.05),
 conecaps(TPos_0, vec3(0.051, -0.267, 0.751), vec3(0.0411847, -0.1742215, 0.7390867), 0.06, 0.02549449), 0.05),
 conecaps(TPos_0, vec3(0.13, -0.257, 0.691), vec3(0.1219919, -0.1634887, 0.6848335), 0.06, 0.025494), 0.05),
 conecaps(TPos_0, vec3(0.198, -0.22, 0.608), vec3(0.1968478, -0.1176157, 0.6248499), 0.06, 0.015782), 0.05),
 conecaps(TPos_0, vec3(0.04392957, 0.1199243, 0.7371331), vec3(0.04759543, 0.03143565, 0.7688017), 0.06, 0.02549401), 0.05),
 conecaps(TPos_0, vec3(0.094312, 0.12868, 0.65904), vec3(0.1271792, 0.01363337, 0.6877561), 0.06, 0.02549402), 0.05),
 conecaps(TPos_0, vec3(0.1845542, 0.105525, 0.5969098), vec3(0.1959237, 0.002555117, 0.6028855), 0.06, 0.01578201), 0.05),
 smax(sph(TPos_0-vec3(0.28, 0.937, 0.422), 0.12),
 -sph(TPos_0-vec3(0.391, 0.937, 0.672), 0.17), 0.03), 0.05), 0.05),
 -caps(TPos_0, vec3(0.092, 0.6, 0.822), vec3(0.03096008, 0.7223915, 0.7556266), 0.02), 0.05)));
#endif
    //res = min(res, pln(p-vec3(0,-3,0), vec3(0,1,0)));
    
    return res*globalScale;
}

// Function 2622
float distanceLinePoint(vec3 point, vec3 lineOrigin, vec3 lineDirection)
{
    return length(cross(point - lineOrigin, lineDirection)) / length(lineDirection);

}

// Function 2623
maybe_float get_distance_along_3d_line_to_infinite_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float cosb
){
    vec3 D = A0 - B0;
    float a = dot(A, B) * dot(A, B) - cosb * cosb;
    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);
    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;
    float det = b * b - 4. * a * c;
    if (det < 0.)
    {
        return maybe_float(0.f, false);
    }

    det = sqrt(det);
    float t1 = (-b - det) / (2. * a);
    float t2 = (-b + det) / (2. * a);
    // This is a bit messy; there ought to be a more elegant solution.
    float t = t1;
    if (t < 0. || t2 > 0. && t2 < t)
    {
        t = t2;
    }
    else {
        t = t1;
    }

    vec3 cp = A0 + t * A - B0;
    float h = dot(cp, B);
    return maybe_float(t, t > 0. && h > 0.);
}

// Function 2624
float map(vec3 p){
    float disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;
	return length(p)-1.+disp;}

// Function 2625
Intersection sdf3D(vec3 dir, vec3 eye) {
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect);
    isect = isect + 0.01 * nor;
    //vec3 lightDir = normalize(lightPos - isect);
    
    vec3 lightDir = normalize(pointLight.transform.trans - isect);
    
    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));
    
    float ao = fiveTapAO(isect, nor, FIVETAP_K);
    
    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));
    
    return Intersection(t, surfaceColor, isect, hitObj, nor);
}

// Function 2626
float mapThing( vec3 p)
{
    p = RotXV3(p, 4.71);
    float T = -voronoi3D(p);
    return T+sdCone(p, vec2(1.0, 0.1));
}

// Function 2627
vec3 map( vec3 p, vec4 c )
{
    vec4 z = vec4( p, 0.2 );
	
	float m2 = 0.0;
	vec2  t = vec2( 1e10 );

	float dz2 = 1.0;
	for( int i=0; i<10; i++ ) 
	{
        // |dz| = |3z|
		dz2 *= 9.0*lengthSquared(qSquare(z));
        
		// z = z^3 + c		
		z = qCube( z ) + c;
		
        // stop under divergence		
        m2 = dot(z, z);		
        if( m2>10000.0 ) break;				 

        // orbit trapping ( |z| and z_x  )
		t = min( t, vec2( m2, abs(z.x)) );

	}

	// distance estimator: d(z) = 0.5log|z||z|/|dz|   (see http://iquilezles.org/www/articles/distancefractals/distancefractals.htm)
	float d = 0.25 * log(m2) * sqrt(m2/dz2 );

	return vec3( d, t );
}

// Function 2628
vec3 scene_color_lerp(vec3 p){
	vec3 col;
	float d = 1e10;
	
	float ground_weight = 0.0;
	float box1_weight = 0.0;
	float box2_weight = 0.0;
	float box3_weight = 0.0;
	float box4_weight = 0.0;
	float sphere1_weight = 0.0;
	float sphere2_weight = 0.0;
	float torus_weight = 0.0;
	
	#define epsmod 0.0105
	#define GI 0.7

	// Conditions to prevent self illumination
	if (ground > epsmod + ground_pos.y) ground_weight = GI/(ground + 1.5);
	if (box1 > epsmod) box1_weight = GI/(box1 + 1.0);
	if (box2 > epsmod) box2_weight = GI/(box2 + 1.0);
	if (box3 > epsmod) box3_weight = GI/(box3 + 1.0);
	if (box4 > epsmod) box4_weight = GI/(box4 + 1.0);
	if (sphere1 > epsmod) sphere1_weight = GI/(sphere1 + 1.0);
	if (sphere2 > epsmod) sphere2_weight = GI/(sphere2 + 1.0);
	if (torus > epsmod) torus_weight = GI/(torus + 1.0);
	
	col =
		ground_color  * ground_weight  + 
		box1_color * box1_weight + 
		box2_color * box2_weight + 
		box3_color * box3_weight + 
		box4_color * box4_weight* 2.0 + 
		sphere1_color * sphere1_weight + 
		sphere2_color * sphere2_weight + 
		torus_color * torus_weight;
	
	return col*col*col*0.15;
}

// Function 2629
float map(vec3 pos)
{     
    float angle = 2.*pi*iMouse.x/iResolution.x;
    float angle2 = -2.*pi*iMouse.y/iResolution.y;
    
    vec3 posr = pos;
    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));
    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle));
    
    float d = 0.94;
    float b = 0.5;

    float af2 = 4./pi;
    float s = atan(posr.y, posr.x);
    float sf = floor(s*af2 + b)/af2;
    float sf2 = floor(s*af2)/af2;
    
    vec3 flatvec = vec3(cos(sf), sin(sf), 1.444);
    vec3 flatvec2 = vec3(cos(sf), sin(sf), -1.072);
    vec3 flatvec3 = vec3(cos(s), sin(s), 0);
    float csf1 = cos(sf + 0.21);
    float csf2 = cos(sf - 0.21);
    float ssf1 = sin(sf + 0.21);
    float ssf2 = sin(sf - 0.21);
    vec3 flatvec4 = vec3(csf1, ssf1, -1.02);
    vec3 flatvec5 = vec3(csf2, ssf2, -1.02);
    vec3 flatvec6 = vec3(csf2, ssf2, 1.03);
    vec3 flatvec7 = vec3(csf1, ssf1, 1.03);
    vec3 flatvec8 = vec3(cos(sf2 + 0.393), sin(sf2 + 0.393), 2.21);
     
    float d1 = dot(flatvec, posr) - d;                           // Crown, bezel facets
    d1 = max(dot(flatvec2, posr) - d, d1);                       // Pavillon, pavillon facets
    d1 = max(dot(vec3(0., 0., 1.), posr) - 0.3, d1);             // Table
    d1 = max(dot(vec3(0., 0., -1.), posr) - 0.865, d1);          // Cutlet
    d1 = max(dot(flatvec3, posr) - 0.911, d1);                   // Girdle
    d1 = max(dot(flatvec4, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets
    d1 = max(dot(flatvec5, posr) - 0.9193, d1);                  // Pavillon, lower-girdle facets
    d1 = max(dot(flatvec6, posr) - 0.912, d1);                   // Crown, upper-girdle facets
    d1 = max(dot(flatvec7, posr) - 0.912, d1);                   // Crown, upper-girdle facets
    d1 = max(dot(flatvec8, posr) - 1.131, d1);                   // Crown, star facets
    return d1;
}

// Function 2630
Intersection sdf3D(vec3 dir, vec3 eye)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj);

    vec3 isect = eye + t * dir;
    vec3 nor = normalize(computeNormal(isect));
    vec3 lightDir = normalize(lightPos - isect);
    
    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));
    
    return Intersection(t, surfaceColor, isect, hitObj);
}

// Function 2631
float distfunc(vec3 pos, vec4 o1) {
	return sphere(pos - o1.xyz, o1.w);
}

// Function 2632
float abstract_glassy_field_envMap_closure_0_(for_r_unsafe_fn _444, float _445)
{
    return shared_smoothstep(0.0, 1.0, _445);
}

// Function 2633
vec2 getDistortion(in float LRValue, in float isFunctionForRightEye, in vec2 uv) {
	//sample at c,r or -c,r depending on which eye (LRValue) and which the function was designed for (isFunctionForRightEye)
    float lrx = uv.x * LRValue * isFunctionForRightEye;
    float x2 = lrx * lrx, x3 = x2 * lrx, x4 = x3 * lrx,
          y2 = uv.y * uv.y, y3 = y2 * uv.y, y4 = y3 * uv.y;
    vec2 res = vec2(lrx, uv.y) - distort(lrx, x2, x3, x4, uv.y, y2, y3, y4);
    res.x *= LRValue * isFunctionForRightEye;
    //texCoords are c, r from -1 to 1
    return vec2(uv.x, uv.y) + res;
}

// Function 2634
void sceneDualCircles2(vec2 uv, out vec3 params)
{
	vec3 p=stereographic(uv*3.);

	p.xz=mod(rotate(p.xz,iBeat*.5),1.)-.5;

	params= vec3(
		sign(p.x*p.y*p.z),
		vec2(29,31)
	);
}

// Function 2635
void CubeMapToSH2(out mat3 shR, out mat3 shG, out mat3 shB) {
    // Initialise sh to 0
    shR = mat3(0.0);
    shG = mat3(0.0);
    shB = mat3(0.0);
    
    vec2 ts = vec2(textureSize(iChannel0, 0));
    float maxMipMap = log2(max(ts.x, ts.y));
    float lodBias = maxMipMap-6.0;
    

    for (int i=0; i < ENV_SMPL_NUM; ++i) {
        vec3 rayDir = SpherePoints_GoldenAngle(float(i), float(ENV_SMPL_NUM));
        vec3 color = sampleReflectionMap(rayDir, lodBias);

        mat3 sh = shEvaluate(rayDir);
        shR = shAdd(shR, shScale(sh, color.r));
        shG = shAdd(shG, shScale(sh, color.g));
        shB = shAdd(shB, shScale(sh, color.b));            
    }

    // integrating over a sphere so each sample has a weight of 4*PI/samplecount (uniform solid angle, for each sample)
    float shFactor = 4.0 * PI / float(ENV_SMPL_NUM);
    shR = shScale(shR, shFactor );
    shG = shScale(shG, shFactor );
    shB = shScale(shB, shFactor );
}

// Function 2636
float sdf(vec3 p)
{
    return fCylinder(p, 2., .19);
}

// Function 2637
vec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)
{
	vec3 eps=vec3(1.0/resolution,0.0);
	vec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),
					 length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));
	
	return norm;
}

// Function 2638
float cubeSDF2(vec3 p, vec3 b) {
    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z
    // So if all components of d are negative, then p is inside the unit cube
    vec3 d = abs(p) - b;
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 2639
float map_bottle_int(vec3 pos)
{
    const float th = 0.045;

    #ifdef bumped_glass
    pos+= getBottleBump(pos);
    #endif
    
    vec3 pos2 = pos;
    float p = 1. - 4.8*pow(smoothstep(0.47, 1.74, pos.y), 1.3);
    pos2.xz/=(1. + 0.16*pos.y*p);
    vec3 pos3 = pos;
    pos3.y-= 0.74;
    pos3.y*= 1.65;
    vec3 pos4 = pos;
    pos4.y-= 2.1;
    pos4.xz*=(1. + 0.3*pos4.y);
    vec3 pos6 = pos;
    pos6.y+= 1.64;
    pos6.y*= 0.38;
    vec3 pos8 = pos.zxy + vec3(1.15, 0, -0.7);

    pos-= vec3(0., th, 0.);
    
    float df = sdCylinder(pos2, vec2(0.83 - th, 1.35));
    df = smin(sdCylinder(pos4, vec2(0.2 - th*0.75, 0.93)), df, 5.);
    df = SoftMaximum(df, -pos.y - 0.55 + th, 20.);
    df = SoftMaximum(df, -length(pos6) + 0.56 + th*0.9 - 0.5*pos.y*pos.y*pos.y, 60.);
    #ifdef bottle_inset
    df = SoftMaximum(df, -sdCylinder(pos8, vec2(0.76, 1.)), 8.);
    #endif
    
    return df; 
}

// Function 2640
float sdf_n(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));
    return t;
}

// Function 2641
void updateScene() {
    vec3 pos1 	= vec3( 2.0, 2.5 + sin(frameSta*0.15)*1.74, -4.0 + sin(frameSta*0.3)*2.734 );
    vec3 pos2 	= vec3( 2.0, 2.5 + sin(frameEnd*0.15)*1.74, -4.0 + sin(frameEnd*0.3)*2.734 );
    spherelight[0].pos = mix( pos1, pos2, rnd() );
    
    float y1	= 1.0 + sin(frameSta*0.7123);
    float y2 	= 1.0 + sin(frameEnd*0.7123);
    sphereGeometry.pos.y = mix( y1, y2, rnd() );
}

// Function 2642
float circleSDFSD(vec2 S, vec2 C,float r, float smoothness)
{
    // Sample coordinates relative to circle center.
    float _x = S.x - C.x; float _y = S.y - C.y;
    
    // Signed distance of squares.
    float sds = _x * _x + _y *_y - r * r;
    
    float ss = smoothness * smoothness;
    
    // Smoothstep interpolation.
    return smoothstep(-ss, ss, sds);
    //return smoothstep(-ss, ss, sds * sds); // outline
}

// Function 2643
vec3 map4(in vec3 pos) {
    
    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);
    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); 
    res.x =abs(res.x);
	return res;
}

// Function 2644
float distTree(vec3 pos)
{
	return distCylinderBump(pos, TREE_PROP, TREE_BUMP, TREE_TEX_SCALE);
}

// Function 2645
float map(vec3 p){
    
    vec2 pth = path(p.z);
    
    float sf = surfFunc(p); // Surface perturbation.

    // The terrain base layer.
    float ter = p.y - 4. + dot(sin(p*4.14159/28. - cos(p.yzx*4.14159/28.)), vec3(4)); // 6. smoothing factor.
    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.

    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.

    p.xy -= pth; // Wrap the tunnel around the path.

    float n = 2.5 - length(p.xy*vec2(.6, 2)); // The tunnel to bore through the rock.
    n = smax(n + (.6 - sf)*2.5, ter + (.6 - sf)*4., 7.); // Smoothly boring the tunnel through the terrain.
    n = smax(n, -max(abs(p.x) - 2.75, abs(p.y + 2.5) - 2.5), .6); // Clearing away the rock around the stairs.
 
    // Object ID.
    objID = step(n, st); // Either the physical path or the surrounds.
    
    return min(n, st)*.966; // Return the minimum hit point.
 
}

// Function 2646
float map( in vec3 pos, out float occ )
{
    pos.yz -= 1.0;
    
    vec3 dd = fract(1024.0+pos) - 0.5;
	float dis = length(dd) - 0.09;

	float disp = noise3f( 4.0*pos, 0 );
	dis += 0.8*disp;
	occ = clamp(-1.5*disp, 0.0, 1.0);

    if( dis<0.25 )
    {
	vec2 cel = celular( 16.0*pos );
	float disp2 = clamp(cel.y - cel.x, 0.0, 1.0);
	dis -= 1.0*disp2;
	occ *= clamp(disp2*12.0,0.0,1.0);
    }

    return dis;
}

// Function 2647
vec4 map( in vec3 pos, float atime )
{
    hsha = 1.0;
    
    float t1 = fract(atime);
    float t4 = abs(fract(atime*0.5)-0.5)/0.5;

    float p = 4.0*t1*(1.0-t1);
    float pp = 4.0*(1.0-2.0*t1); // derivative of p

    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),
                     pow(p,2.0-p) + 0.1,
                     floor(atime) + pow(t1,0.7) -1.0 );

    // body
    vec2 uu = normalize(vec2( 1.0, -pp ));
    vec2 vv = vec2(-uu.y, uu.x);
    
    float sy = 0.5 + 0.5*p;
    float compress = 1.0-smoothstep(0.0,0.4,p);
    sy = sy*(1.0-compress) + compress;
    float sz = 1.0/sy;

    vec3 q = pos - cen;
    float rot = -0.25*(-1.0 + 2.0*t4);
    float rc = cos(rot);
    float rs = sin(rot);
    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;
    vec3 r = q;
	href = q.y;
    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );
    
    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );

    if( res.x-1.0 < pos.y ) // bounding volume
	{
    float t2 = fract(atime+0.8);
    float p2 = 0.5-0.5*cos(6.2831*t2);
    r.z += 0.05-0.2*p2;
    r.y += 0.2*sy-0.2;
    vec3 sq = vec3( abs(r.x), r.yz );

	// head
    vec3 h = r;
    float hr = sin(0.791*atime);
    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));
    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;
    vec3 hq = vec3( abs(h.x), h.yz );
   	float d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );
	float d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );
	d = smin( d, d2, 0.1 );
    res.x = smin( res.x, d, 0.1 );
    
    // belly wrinkles
    {
    float yy = r.y-0.02-2.5*r.x*r.x;
    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));
    }
        
    // arms
    {
    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );
    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );
    }
        
    // ears
    {
    float t3 = fract(atime+0.9);
    float p3 = 4.0*t3*(1.0-t3);
    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );
    res.xz = smin( res.xz, ear, 0.01 );
    }
    
    // mouth
    {
   	d = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );
    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);
    res.x = smax( res.x, -d, 0.03 );
    }

	// legs
    {
    float t6 = cos(6.2831*(atime*0.5+0.25));
    float ccc = cos(1.57*t6*sign(r.x));
    float sss = sin(1.57*t6*sign(r.x));
	vec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;
    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );
    res.xz = smin( res.xz, legs, 0.07 );
    }
        
    // eye
    {
    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);
    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);
    res.x = smin( res.x, eyeball, 0.03 );
    
    vec3 cq = hq-vec3(0.1,0.34,0.08);
    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;
    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );
    res.x = smin( res.x, d, 0.03 );

    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));
    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));
    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));
    }
	}
    
    // ground
    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));
    float t5f = fract(atime+0.05);
    float t5i = floor(atime+0.05); 
    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;
    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );
    
    float k = length(pos.xz-bcen);
    float tt = t5f*15.0-6.2831 - k*3.0;
    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);
    float d = pos.y - fh;
    
    // bubbles
    {
    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);
    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );
    float fid = id.x*11.1 + id.y*31.7;
    float fy = fract(fid*1.312+atime*0.1);
    float y = -1.0+4.0*fy;
    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);
    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    
    float siz = 4.0*fy*(1.0-fy);
    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );
    
    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));
    d2 *= 0.6;
    d2 = min(d2,2.0);
    d = smin( d, d2, 0.32 );
    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }
    }

    // candy
    {
    float fs = 5.0;
    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );
    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );
    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);
    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );
    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);
    float fid = id.x*0.143 + id.y*0.372;
    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);
    d = sdSphere( vp, 0.35*ra )/fs;
    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);
    }
    
    return res;
}

// Function 2648
float CheckSceneForIntersection(in vec3 p)
{
    float planeT = sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0));
    
    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));
    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale);
    float torusT = sdfTorus(p + curvePoint, vec2(2.0, 0.5));

    return GetClosestIntersection(planeT, torusT);
}

// Function 2649
vec3 map( vec3 p )
{
    float time = iTime*1.0;
    
    vec2  id = floor( (p.xz+1.0)/2.0 );
    float ph = hash(id+113.1);
    float ve = hash(id);

    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;
    p.xz += 0.5*cos( 2.0*ve*time + (p.y+ph)*vec2(0.53,0.32) - vec2(1.57,0.0) );

    vec3 p1 = p; p1.xz += 0.15*sincos(p.y-ve*time*ve+0.0);
    vec3 p2 = p; p2.xz += 0.15*sincos(p.y-ve*time*ve+2.0);
    vec3 p3 = p; p3.xz += 0.15*sincos(p.y-ve*time*ve+4.0);
    
    vec2 h1 = sdCylinder( p1 );
    vec2 h2 = sdCylinder( p2 );
    vec2 h3 = sdCylinder( p3 );

    return opU( opU( vec3(h1.x-0.15*(0.8+0.2*sin(200.0*h1.y)), ve + 0.000, h1.y), 
                     vec3(h2.x-0.15*(0.8+0.2*sin(200.0*h2.y)), ve + 0.015, h2.y) ), 
                     vec3(h3.x-0.15*(0.8+0.2*sin(200.0*h3.y)), ve + 0.030, h3.y) );

}

// Function 2650
float sdistanceToBall(vec2 p, Ball B) {
    if (B.isplane) {
        float k = dot(vec3(p, 1), vec3(B.cen, B.r));
        return k;
    }
    else {
        float k = length(p - B.cen) - B.r;
        return B.invert ? -k : k;
    }
}

// Function 2651
float remap(float x, float a, float b, float c, float d)
{
    return (((x - a) / (b - a)) * (d - c)) + c;
}

// Function 2652
float map(in vec3 pos)
{
    float d = 1e10;
    
    
    float an = sin(iTime);

    // opUnion
    {
    vec3 q = pos - vec3(-2.0,0.0,-1.3);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opUnion(d1,d2);
    d = min( d, dt );
  	}
    
    // opSmoothUnion
    {
    vec3 q = pos - vec3(-2.0,0.0,1.0);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opSmoothUnion(d1,d2, 0.25);
    d = min( d, dt );
    }


    // opSubtraction
    {
    vec3 q = pos - vec3(0.0,0.0,-1.3);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opSubtraction(d1,d2);
    d = min( d, dt );
    }

    // opSmoothSubtraction
    {
    vec3 q = pos - vec3(0.0,0.0,1.0);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opSmoothSubtraction(d1,d2, 0.25);
    d = min( d, dt );
    }

    // opIntersection
    {
    vec3 q = pos - vec3(2.0,0.0,-1.3);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q, vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opIntersection(d1,d2);
    d = min( d, dt );
    }
    
    // opSmoothIntersection
    {
    vec3 q = pos - vec3(2.0,0.0,1.0);
    float d1 = sdSphere( q-vec3(0.0,0.5+0.3*an,0.0), 0.55 );
    float d2 = sdRoundBox(q-vec3(0.0,0.5,0.0), vec3(0.6,0.2,0.7), 0.1 ); 
    float dt = opSmoothIntersection(d1,d2, 0.25);
    d = min( d, dt );
    }

    return d;
}

// Function 2653
float floorSdf(vec3 pos)
{
  opRepeat(pos.x, 1.0);
  opRepeat(pos.z, 1.0);
  return sdRoundBox(pos, vec3(0.45, 0.2, 0.45), 0.05);
}

// Function 2654
float distanceToSegmentSquared(vec2 p, vec2 LA, vec2 LB)
{
    //distance of line segment
    float l2 = lengthSquared(LA,LB);
    //If line segment is 0 length, just get difference with first endpoint
    if (l2 == 0.0) 
        return lengthSquared(p, LA);
    
    //Vector representation of L
    vec2 v = LB - LA;
    vec2 w = p - LA;
    
    //t is percentage along line L point p falls
    float t = dot(w,v) / l2;  
    t = clamp(t,0.0,1.0);
    
    //projection of p onto v,w is nearest point
    vec2 nearestPoint = vec2(LA.x + t * v.x, LA.y + t * v.y);
    
    //Distance between p and projectedpoint
    return lengthSquared(p, nearestPoint);
}

// Function 2655
float DistributionGGX (in vec3 N, in vec3 H, in float roughness)
{
    float a2     = roughness * roughness;
    float NdotH  = max (dot (N, H), .0);
    float NdotH2 = NdotH * NdotH;

    float nom    = a2;
    float denom  = (NdotH2 * (a2 - 1.) + 1.);
    denom        = PI * denom * denom;

    return nom / denom;
}

// Function 2656
maybe_vec2 get_distances_along_3d_line_to_ring(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float ro,
    in float ri
){
    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);
    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);
    maybe_vec2 ring  = get_distances_along_line_to_negation(outer, inner);
    return ring;
}

// Function 2657
float torusSDF(vec3 p, float smallRadius, float largeRadius) {
	return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;
}

// Function 2658
float map(vec3 p)
{
  for (int i=0;i<5;i++) {
    p.xy *= rot(time * 0.43);
    if (mod(time, 2.) < 1.)
      p.yz *= rot(time * 0.32);
    p.xz *= rot(time * 0.24);
    p = abs(p);
    p -= 5.-float(i)+sin(time);
  }
  return cube(p);
}

// Function 2659
float map(vec3 p){
    p.z+=iTime*0.5;
    //push away the height to make a road.
    float wav=(sin(p.x*0.25+4.4))*0.5
        + texture(iChannel0,p.xz*0.5).x*0.007;  
    float h = dot(sin(p - cos(p.zyx)),vec3(0.03));
    p*=0.65;
    h += dot(sin(p- cos(p.yzx*2.5)),vec3(0.05));
     //-0.35 ~ 0.52 can flatten the ground and top surface 
    return p.y + smoothstep(-0.35,0.52,h-wav);   
}

// Function 2660
float map( in vec3 p, float di)
{
  
    // Grab texture based on 3D coordinate mixing...
 	float te = textureLod(iChannel1, p.xz*.0017 + p.xy * 0.0019-p.zy*.0017, di).y*80.0;
    // Make a wibbly wobbly sin/cos dot product..
    float h = dot(sin(p*.019),(cos(p.zxy*.017)))*100.;
    
    // Rock Plateaus...
    float g = p.y*.33 + textureLod(iChannel1, p.xz*.0003, 4.).x*40.0;
    float c = 60.0;
    g /= c;
    float s = fract(g);
    g = floor(g)*c+pow(s, 20.)*c;
    // Add them all together...
    float d =  h+te + g;
    //...Then subtract the camera tunnel...
    vec2 o = cameraPath(p.z).xy;
    p.xy -= o;
    float tunnel = 40. - length(p.xy); 
     
    d = sMax(d, tunnel, 140.);

    return d;
}

// Function 2661
vec2 map( vec3 pos ){  
    
   	vec2 res = vec2(length( pos ) - 1. , 0.0 );
    
   	return res;
    
}

// Function 2662
float sdf_capsule(vec3 p, vec3 a, vec3 b, float radius_a, float radius_b)
{
    vec3 ab = b - a;
    vec3 ap = p - a;
    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);
    return sdf_sphere(p - mix(a, b, t), mix(radius_a, radius_b, t));
}

// Function 2663
vec3 map_Gsph_rgb(vec3 ro, vec3 rd, vec3 nrm) { 
    return .5*(Gsphere.z - ro.zzz);
}

// Function 2664
vec3 map(vec3 p, bool flag)
{
	float wallnoise = (noise(83.*p)+noise(17.*p))*noise(7.*p);
	vec3 d = vec3(1, 0, 0);

	float sd1 = length(p+lpos1)-.4;
	float sd2 = length(p+lpos2)-.4;
	float waves = 0.;
	if( iTime > 48./sp) waves=0.03;						
	dmin(d, 1.49+kk*2.5-abs(p.x+0.01*wallnoise), .99-0.5*wallnoise, 0.); 
	if( kk>0. ) {
		dmin(d, 1.2+p.y, pattern(p.xz)-.6*wallnoise, 0.); 	

		dmin(d,
			max(vines(p+vec3(0, 0, 2), .5+5./(1.+p.x*p.x*2.), iTime)-.02,
				max(
					abs(p.x)-3.,
					3.5-(iTime-77.)*.25+max(iTime-192./sp, 0.)*2.+sin(p.y*20.)*sin(p.z*10.) - abs(p.x)
				)
			),.1, .2);

		vec3 q=p.yxz;
		q.z=fract(q.z/3.-.2)*3.-1.5;
		q.y=abs(q.y)-3.5;
		q.x -= 6.;
		dmin(d,vines(q, 1.3+20./(1.+q.x*q.x*.45), 0.)-.05,.1, .2);
	}
	else {
		dmin(d, .8-waves*sin(8.*p.z+time)*sin(6.*p.x+1.6*time+sin(2.*p.z))+p.y, .25, waves);
		dmin(d, 0.75-p.z, .8*sin(20.*p.x), 0.); 	
		dmin(d, 0.8-p.y, pattern(p.xz)-.6*wallnoise, 0.); 	
	}
	float amp = 0.;
	if( iTime > 96./sp &&fract(iTime*sp/4.)<=0.75+kk )  amp=abs(sin(20.*p.z));
	if( iTime>96./sp && flag && fract(iTime*sp/4.)<=0.75+kk )
	{
		scatter += max(-(sd1-1.2), 0.)*.06*vec3(0, 1, 1); 
		scatter += max(-(sd2-1.2), 0.)*.06*vec3(2, 1, 0);
	}

	if( iTime>32./sp )
	{
		dmin(d,sd1,.07+amp,-1.);
		dmin(d,sd2,.07+amp,1.); 
	}

	vec3 q = abs(p);
	if (iTime>24./sp&&fract(iTime*sp/8.)>=0.924-kk&&(iTime<60./sp||iTime>64./sp))
	{
		q.x -= 1.49+kk*2.4;
		q.y -= .4+.4*sin(time)*(1.-kk)+kk*.4;
		dmin(d, length(q.xy)-.015, 2., -.4);
	}

	if( iTime>64./sp)
		if( iTime<192./sp)
		{
			q=p+vec3(0, 0, 2.);
			pR(q.xy, 0.33*time);
			pR(q.xz, 0.4*time);
			float rb=sdRoundBox(q, vec3(.48), .08);
			dmin(d, rb, -.7+1.9*abs(sin(10.*q.x+10.*q.y)), 0.);
		}
		else
			dmin(d, length(p+vec3(0, 0, 2))-.5, .07+amp, 0.);
	return d;
}

// Function 2665
SceneResult Character_GetDistance( vec3 vPos )
{
    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );


    vec3 vLeftLeg = LegDist( vPos, g_scene.pose.leftLeg );
    vec3 vRightLeg = LegDist( vPos, g_scene.pose.rightLeg );
    vec3 vLeftArm = ArmDist( vPos, g_scene.pose.leftArm );
    vec3 vRightArm = ArmDist( vPos, g_scene.pose.rightArm );
    vec3 vTorsoDist = TorsoDistance( 
        vPos,
        g_scene.pose.leftLeg.vHip, 
        g_scene.pose.rightLeg.vHip,
        g_scene.pose.leftArm.vShoulder,
        g_scene.pose.rightArm.vShoulder,
    	g_scene.charDef.fShoulder, g_scene.charDef.fHip);
        
    vTorsoDist.y += 1.0;
    vLeftArm.y += 2.0;
    vRightArm.y += 2.0;            
    vLeftArm.z += 1.0;
    vLeftLeg.z += 1.0;
        
    vec3 vLimbDist = vec3(10000.0);
    vLimbDist = BodyCombine3( vLimbDist, vLeftLeg );
    vLimbDist = BodyCombine3( vLimbDist, vRightLeg );
    vLimbDist = BodyCombine3( vLimbDist, vLeftArm );
    vLimbDist = BodyCombine3( vLimbDist, vRightArm );        
    vec3 vCharacterDist = BodyCombine3( vLimbDist, vTorsoDist );

    //vCharacterDist.x -= fbm( vLimbDist.xy * 10., 0.9 ) * 2.0;
    
    float fNeckSize = 1.0;
    float fNeckLen = 3.0;

    vec3 vNeckBase = (g_scene.pose.leftArm.vShoulder + g_scene.pose.rightArm.vShoulder) * 0.5;
    vec3 vNeckTop = vNeckBase + g_scene.pose.vHeadUp * fNeckLen;
    vec3 vNeckDist = Segment3( vPos, vNeckBase, vNeckTop, fNeckSize, fNeckSize );
    
    float fHead1 = g_scene.charDef.fHead1;
    float fHead2 = g_scene.charDef.fHead2;
    float fHeadTop = 6.0;
    float fHeadChin = 2.0;
    
    vec3 vHeadBase = vNeckBase + g_scene.pose.vHeadUp * ( fHeadChin + fHead2);
    vec3 vHead2 = vHeadBase  + g_scene.pose.vHeadFd * (fHead2 * .5);
    vec3 vHead1 = vHeadBase + g_scene.pose.vHeadUp * (fHeadTop - fHead1);
    
    vec3 vHeadDist = Segment3( vPos, vHead1, vHead2, fHead1, fHead2 );
    vHeadDist = SmoothMin3( vHeadDist, vNeckDist, 0.5 );

    vec3 vNosePos = vHead1 + g_scene.pose.vHeadFd * fHead1 * 1.2 - g_scene.pose.vHeadUp * 1.5;
    float fNoseDist = length( vPos - vNosePos ) - 1.;
    vHeadDist.x = min( vHeadDist.x, fNoseDist ); // keep material


    vec3 vEyePerp = normalize( cross(g_scene.pose.vHeadFd, g_scene.pose.vHeadUp) );

    vec3 vEyePos1 = vHead1 + g_scene.pose.vHeadFd * fHead1 + vEyePerp * 1.5;
    float fEyeDist1 = length( vPos - vEyePos1 ) - 1.;

    vec3 vEyePos2 = vHead1 + g_scene.pose.vHeadFd * fHead1 - vEyePerp * 1.5;
    float fEyeDist2 = length( vPos - vEyePos2 ) - 1.;
    
    float fEyeDist = min( fEyeDist1, fEyeDist2 );
        
    vHeadDist.x = max( vHeadDist.x, -(fEyeDist - 0.2) );
    
    
    //vCharacterDist = BodyCombine3( vCharacterDist, vHeadDist );
    result = Scene_Union( result, SceneResult( vHeadDist.x, MAT_HEAD, vHeadDist.yzz ) );    
    
    
    
    result = Scene_Union( result, SceneResult( fEyeDist, MAT_EYE, g_scene.charDef.vCol ) );    
        
    result = Scene_Union( result, SceneResult( vCharacterDist.x, MAT_CHARACTER, vCharacterDist.yzz ) );    

         
    return result;
}

// Function 2666
HitInfo map(vec3 p)
{
    SurfaceAxis surfInfo = computeSurfaceVectors(p.xz);
	float dSurf = dot((p-surfInfo.pos),surfInfo.normal);
    
    Cell probeCell = repeat(p.xz, vec2(CELL_SIZE));
    p.xz = probeCell.localSample;
    SurfaceAxis surfAxis = computeSurfaceVectors(probeCell.center);
    vec3 pAxis = vec3(0,surfAxis.pos.y,0);
        
    float d1 = distanceToLineSeg3D(p,pAxis+surfAxis.normal *AXIS_LEN,pAxis-surfAxis.normal *AXIS_LEN)-AXIS_WIDTH;
    float d2 = distanceToLineSeg3D(p,pAxis+surfAxis.tangent*AXIS_LEN,pAxis-surfAxis.tangent*AXIS_LEN)-AXIS_WIDTH;
    float d3 = distanceToLineSeg3D(p,pAxis+surfAxis.binormal*AXIS_LEN,pAxis-surfAxis.binormal*AXIS_LEN)-AXIS_WIDTH;
    float dAxis = min(min(d1,d2),d3); 
    
    HitInfo info;
    info.d = min(dSurf,dAxis);
    info.matID = (dSurf<dAxis)?MAT_GROUND:MAT_AXIS;    
    return info;
}

// Function 2667
float map(vec3 p)
{
    vec3 q = p;

    //pMod3(q, vec3(0.75, 1., 0.8));
    pMod3(q, vec3(.905, .785, 0.5));
   
    
    pMod1(p.x, 1.);
    
    float s1 = sphere(p, 0.25); 
    float s2 = sphere(q, 0.5);
    float s3 = sphere(q, 0.7);
    
    float disp = 0.5 * (abs(sin(p.x*20.)) *
                       abs(cos(p.y*10.)) *
                       abs(sin(p.z*20.)) );
    	s1 += disp;
    	//s1 -= disp;
    	
    
    
  	float df1 = min(s1, -s2+.075); // Union
    float df2 = max(s1, s2); // Intersection
    float df3 = max(s1, -s3); // Difference
    
    return df1;
}

// Function 2668
vec2 GetDist(vec3 p){
    vec3 hPos = p;
    hPos.y += pow(sin(iTime),2.)*.1;
    hPos.xz *= Rot(.1*sin(.001*iTime/cos(iTime)));
    //head
    vec2 res = vec2(length(hPos-vec3(0,cos(abs(p.x+3.14159))+.5,0))-0.5,1);
    vec2 ears = vec2(sdCylinder(hPos-vec3(0,-.5,0), vec3(-.6,0,0), vec3(.6,0,0), .1),1);
    res = colMin(res,ears);
    vec2 antennaBase = vec2(sdCylinder(hPos-vec3(0,-.5,0), vec3(-.55,0,0), vec3(.55,0,0), .2),1);
    res = colMin(res,antennaBase);
    vec2 antR = vec2(dBox(hPos-vec3(-.54,0,0), vec3(.005,.5,.2-(sin(p.y*p.y*.6)))),1);
    res = colMin(res,antR);
    vec2 antL = vec2(dBox(hPos-vec3(.54,0,0), vec3(.005,.5,.2-(sin(p.y*p.y*.6)))),1);
    res = colMin(res,antL);
    
    //eyes
    float blink = sin(iTime)*.04;
    vec3 rotP = hPos-vec3(0,-.4,-0.3);
    rotP.yz *= Rot(3.1415/2.);
    vec2 sock = vec2(sdRhombus(rotP, .3, .1-blink, .2, .001),2);
    
    rotP = hPos-vec3(0,-.4,-0.4);
    rotP.yz *= Rot(3.1415/2.);
    vec2 sockM = vec2(sdRhombus(rotP, .2, .08-blink, .2, .001),2);
    sock.x = opSmoothSubtraction(sockM.x,sock.x, .01);
    res = colMin(res,sock);
    
    vec2 eye = vec2(sdRhombus(rotP, .1, .05-blink, .1, .001),3);
    
    res = colMin(res,eye);
    
    //body
    vec3 bPos = p;
    bPos.y += cos(0.001*iTime/sin(iTime))*.01;
    vec2 body = vec2(length(bPos-vec3(0,5.*cos(abs(p.x+3.14159))+3.2,0))-0.5,1);
    res = colMin(res,body);
    return res;
}

// Function 2669
float roundBoxSDF(vec3 p, vec3 boxDim, float radius) {
  return boxSDF(p, boxDim) - radius;
}

// Function 2670
float distanceToMirrors(vec2 p) {
    float d = abs(sdistanceToBall(p, coclusters[0]));
    
    if (length(p) > 1.) p /= L2(p);
    for (int k = 1; k < 4; k++) {
         d = min(d, abs(sdistanceToBall(p, coclusters[k])));
    }
    return d;
}

// Function 2671
vec2 mapWithTerrain( vec3 p, out vec3 matInfo )
{
    vec2 res = map(p,matInfo);
        
    //--------------------
    // terrain
    float h = 2.1+0.1;
    float d2 = p.y + h;
    if( d2<res.x ) res = vec2( d2, 3.0 );
    
    return res;
}

// Function 2672
float sceneMap3D(vec3 pos) {
    float flr = FLOOR_SDF;
    float red_wall = RED_WALL_SDF;
    float green_wall = GREEN_WALL_SDF;
    float back_wall = BACK_WALL_SDF;
    float ceiling = CEILING_SDF;
    float tall_box = TALL_BOX_SDF;
    float small_box = SMALL_BOX_SDF;
    return min(back_wall, min(red_wall, min(green_wall, min(ceiling, min(flr, min(tall_box, small_box))))));

}

// Function 2673
float map(vec3 p){
    float d=10000.0;

	vec3 p5=p-vec3(10,11,-26);
	d=min(d, box(p5,vec3(20,10,15)));
	p5+=vec3(-4,6,-10.5);
	d=max(d, -box(p5,vec3(10,5,4)));
	p5+=vec3(5.5,0,13.5);
	d=max(d, -box(p5,vec3(7,10,9)));
	
    d=min(d, path(p));
    
    // close house
	d=min(d, max(hou1(p),p.z+9.5+blend*1.));

	// duplicated house but farer for visual trickery
	vec3 p3 = p-cz*35.;
	d=min(d, max(hou1(p3),-p.z-1.5));
    
    // left part
	p3+=vec3(1.5,0,1);
	vec3 p4=p3;
	p4.y=max(0.,-p4.y);
	d=max(d, 3.-length(p4.xy+vec2(-19,0)));
	d=min(d, box(p3+vec3(-20,-5,3),vec3(5,4,5)));
	d=max(d, -box(p3+vec3(-20,-1,3),vec3(4,1,4)));
		
	// arc 2
	vec3 p2=p+vec3(-7,0,0);
	p2.y=max(0.,-p2.y);
	d=max(d, -max(length(p2.xy)-2., abs(p2.z)-18.));
	
	d=min(d,wheel(p));

	float limw = -13.-p.y+blend*8.;
	d=min(d,max(water(p),limw));
	d=min(d,water(p-cz*31.2));

	d=min(d, back(p));
	d=min(d, fore(p));

	// Bottom part
    p5+=vec3(2.5,2,-14);
	d=min(d, box(p5,vec3(15,1,4)));
	p5+=vec3(1.5,1.25,0);
	d=min(d, stair(p5.zyx*vec3(-1.2,1.2,1), 0.35, 0.5, 2.));
	p5+=vec3(2.5,-1.25,7);
	d=min(d, stair(p5.zyx*vec3(-1,1,1), 0.25, 2.0, 2.));

    d=min(d, -p.y+50.);
    
    return d;
}

// Function 2674
vec2 distlogic(vec2 v,vec2 v1){
return abs(v1.r-v.r)< // if distances are
             0.00001*  // closer than some fugde factor
             max(max(v1.r,v.r),1.) // that gets a little larger further out but never below 1
             ?(v1.g>v.g?v1:v): //select most positive side
    		v1.r<=v.r?v1:v; // or the common case;
}

// Function 2675
float mapCam(vec3 p)
{
    float d;
    p.xz *= .3;

    d = smoothstep( 0.1, .7, textureLod(iChannel1, p.xz*.00015+.1, 0.).y)*4.0;
    d += smoothstep( 0.,.8, textureLod(iChannel2, p.xz*.0002+.4, 0.).y)*3.;
    d += smoothstep( 0.,.6, textureLod(iChannel2, p.xz*.0004+.2, 0.).y)*1.5;
    d =  max(d*d*8.0-20., 0.0);

    return (p.y +80.0 - d);
}

// Function 2676
float scene( vec3 pos )
{
	vec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d
	vec4 sphere = vec4(  0.0, 0.5, 0.0, 1.5 ); // xyz, r
	vec4 rboxDim = vec4( 2.0, 2.0, 0.5, 0.25 );
	vec4 rboxPos = vec4( 0.0, 0.5, 0.0, 1.0 );
	
	
	float dPlane = sdPlane( pos, plane );
	
	//d = opU( d, sdSphere( translate( pos, sphere1.xyz ), sphere1.w ) );
	//d = opU( d, sdSphere( translate( pos, sphere2.xyz ), sphere2.w ) );
	float dSphere = sdSphere( translate( pos, sphere.xyz ), sphere.w );
	float dRbox = udRoundBox( translate( pos, rboxPos.xyz ), rboxDim.xyz, rboxDim.w );
	
	return opU( dPlane, opS( dSphere, dRbox ) );
}

// Function 2677
float sdf(vec3 p)
{
    return min(length(p)-1.0, length(p-vec3(0.141, 0.1, 0.9))-0.2) - rmf(p, 512.0, 2.0)*0.00025;
}

// Function 2678
vec3 Uncharted2ToneMapping(vec3 color) {
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 2.;
	color *= exposure;
	color = ((color* (A* color+ C* B)+ D* E)/ (color* (A* color+ B)+ D* F))- E/ F;
	float white = ((W* (A* W+ C* B)+ D* E)/ (W* (A* W+ B)+ D* F))- E/ F;
	color /= white;
	return color;
}

// Function 2679
Model map(vec3 p) {
    #ifdef VISUALISE_CLOSEST
		return visualiseClosest(p);
   	#endif
    
    float phase = iTime * PI * 2. / 8. - .5;
    float lead = mix(1., 8., sin(phase) * .5 + .5);
    float radius = mix(0.001, 1.8, cos(phase) * .5 + .5);

    vec3 helix = closestHelix(p, lead, radius);
    float d = length(p - helix) - .5;
    
    vec3 hp = helixCoordinates(p, helix, lead, radius);
	vec2 uv = vec2(hp.x, atan(hp.y, hp.z) / PI / 2.);
    
    return Model(d, uv, 0);
}

// Function 2680
float GetDistanceWine( vec3 vPos )
{
    vec3 vLocalPos = vPos;
    vLocalPos.y -= 2.0;
    
    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);
    
    vec2 vSphOrigin = vec2(0);
    vec2 vSphPos = vPos2 - vSphOrigin;   
    
    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;
    
    vec3 vWaterNormal = vec3(0,1,0);
    
    float fTime = 0.0;
    
    vWaterNormal.x = sin( fTime * 5.0) * 0.01;
    vWaterNormal.z = cos( fTime * 5.0) * 0.01;
    
    vWaterNormal = normalize( vWaterNormal );
    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;
        
    return max( fBowlDistance, fWaterLevel );
}

// Function 2681
float GetDistanceBowl( vec3 vPos )
{    
    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);
    
    vec2 vSphOrigin = vec2(0,1.0 - 0.3 + 0.03);
    vec2 vSphPos = vPos2 - vSphOrigin;
    
    vec2 vClosest = vSphPos;
    
    if ( vClosest.y > 0.1 ) vClosest.y = 0.1;
    if ( vClosest.y < -0.7 ) vClosest.y = -0.7;
    
    float r = sqrt( 1.0 - vClosest.y * vClosest.y);    
    vClosest.x = r;        
    
    float fBowlDistance = distance( vClosest, vSphPos );   
    
    vClosest = vSphPos;
    vClosest.y = -0.7;    
    r = sqrt( 1.0 - vClosest.y * vClosest.y);    
    vClosest.x = min( vClosest.x, r ); 
    
    float fBaseDistance = distance( vClosest, vSphPos );
    
    fBowlDistance = min( fBowlDistance, fBaseDistance );   
    
    return fBowlDistance- 0.03;
}

// Function 2682
float map (in vec3 p) {
    float sdf = opRepSphere(p, vec3(0.3));
    sdf = smin(sdf, opRepTorus(p, vec3(0.4), vec2(0.08, 0.05)), 0.02);
    sdf = smin(sdf, opRepEllipsoid(p, vec3(0.26), vec3(0.03, 0.03, 0.08)), 0.02);
    sdf = smin(sdf, opRepTriPrism(p, vec3(0.13), vec2(0.02, 0.02)), 0.04);
    return sdf;
}

// Function 2683
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 646.9 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.3, 1.0), vec3(0.15), 0.1 ), 541.0 ) );
	res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 425.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.20,-0.1), vec3(-1.0,0.20,0.2), 0.1  ), 331.9 ) );
	res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),250.0 ) );
	res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),143.0 ) );

    return res;
}

// Function 2684
vec3 jodieReinhardTonemap(vec3 c)
{
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);

    return mix(c / (l + 1.0), tc, tc);
}

// Function 2685
float distribution(vec3 n, vec3 h, float roughness){
    float a_2 = roughness*roughness;
	return a_2/(PI*pow(pow(dot_c(n, h),2.0) * (a_2 - 1.0) + 1.0, 2.0));
}

// Function 2686
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    // Project ray direction on to the unit cube.
    vec3 absRayDir = abs(rayDir);
    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));
    
    // Get the index of the current face being rendered.
    
    int faceIndex = 0;

    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)
    {
        faceIndex = 2;
    }
    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)
    {
        faceIndex = 4;
    }

    if(rayDir[faceIndex / 2] > 0.)
        faceIndex |= 1;

    fragColor = vec4(0);
    
    vec2 uv = fragCoord.xy / 1024.;

    const float overlap = .1;

    if(faceIndex == 0)
    {

       uv *= 1. + overlap;
        
        vec2 ouv = uv;

        // Calculate a height map.

        //uv = abs(uv - .5) * 1.5;

        for(int i = 0; i < 120; ++i)
        {
            uv -= sin(uv.yx * 16. + iTime / 3.) * .007 + .01;
            uv.x -= .001;
        }

        uv = fract(uv * 5.5) - .5;

        fragColor.r = (1. - smoothstep(-.1, .7, length(uv)-.1));

        fragColor.r += texture(iChannel0, uv).r * .1;
        fragColor.r += texture(iChannel0, uv * 2.).r * .05;

        fragColor.r += texture(iChannel0, ouv * 2.).r * .005;
        fragColor.r += texture(iChannel0, ouv * 3.).r * .01;

        fragColor.r *= sin(ouv.x * 3.1416 * 2. + 1. * sin(ouv.y * 3.14159 * 2. - iTime / 2.))*.7 + .75;

        fragColor.r += textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 70. + .5, 0.).r * .2;
        fragColor.r -= textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 100., 0.).r * .08;

        float z = textureLod(iChannel0, ouv / 4., 0.).r * 6.;

        fragColor.r += pow(max(0., 1. - fragColor.r), 5.) *
                textureLod(iChannel1, ouv * 2. - vec2(1,0)*iTime / 70. + .5, 0.).r * .1 * (.5 + .5 * cos(z + iTime * 15.));

        fragColor.r = clamp(fragColor.r*.9, 0., 1.);

        // Calculate colour.

        fragColor.gba = textureLod(iChannel2, uv / 7., 1.).rgb * mix(vec3(1), textureLod(iChannel2, uv * 2., 1.).bgr, .5);
    }
    else if(faceIndex == 1)
    {

        fragColor = vec4(0);

        float wsum = 0.;
                
        for(int y = -1; y <= +1; ++y)
            for(int x = -1; x <= +1; ++x)
            {
                vec2 uv2 = uv * 2. - 1. + vec2(x, y) * 2.;
                float mask = 1. - smoothstep(0., overlap, length(max(abs(uv2)-vec2(1.), 0.)));
        		fragColor += textureLod(iChannel3, mapCoord(uv2 * 1. / (1. + overlap * 2.)), 0.) * mask;
                wsum += mask;
            }
        
        fragColor /= wsum;

    }
}

// Function 2687
float floor_sdf(vec3 p){
    vec4 plane = vec4(0, 1, 0, 0);
    return dot(p, plane.xyz) - plane.w;
}

// Function 2688
vec2 map(vec3 p) {
    float d = length(p) - 4.;
	return vec2(d, 1.);
}

// Function 2689
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(2./iResolution.y, 0); 
    
    float f = bumpFunction(p); // Hit point function sample.
    
    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.
    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.
    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.
    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.
    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 2690
vec2 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )
{	
    vec2 vResult = vec2(0, 0);
    
	float t = minDist;
	const int kRaymarchMaxIter = 64;
	for(int i=0; i<kRaymarchMaxIter; i++)
	{		
        float epsilon = 0.0001 * t;
		vResult = Scene_GetDistance( vRayOrigin + vRayDir * t );
        if ( abs(vResult.x) < epsilon )
		{
			break;
		}
                        
        if ( t > maxDist )
        {
	        t = maxDist;
            break;
        }               
        
        t += vResult.x;
	}
    
    vResult.x = t;
    
    return vResult;
}

// Function 2691
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    const vec2 e = vec2(.001, 0);
    float ref = bumpSurf3D(p);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),
                      bumpSurf3D(p - e.yxy),
                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     
          
    grad -= nor*dot(nor, grad);          
                      
    return normalize(nor + grad*bumpfactor);
	
}

// Function 2692
float squaredDistanceBetween(vec2 uv1, vec2 uv2)
{
    vec2 delta = uv1 - uv2;
    float dist = (delta.x * delta.x) + (delta.y * delta.y);
    return dist;
}

// Function 2693
float sdf_donut(vec2 pos, vec2 donut_pos, float donut_r, float donut_width) {
	return max(sdf_circle(pos, donut_pos, donut_r + donut_width),
              -sdf_circle(pos, donut_pos, donut_r - donut_width));    
}

// Function 2694
vec2 RayLineDist(vec3 ro, vec3 rd, vec3 a, vec3 b) {
    
    b -= a;
    vec3 rdb = cross(rd,b);
    vec3 rop2 = a-ro;
    
	float t1 = dot( cross(rop2, b), rdb ); 
    float t2 = dot( cross(rop2, rd), rdb );
    
    return vec2(t1, t2) / dot(rdb, rdb);
}

// Function 2695
SG DistributionTermSG(in vec3 direction, in float roughness)
{
    SG distribution;
    distribution.Axis = direction;
    float m2 = roughness * roughness;
    distribution.Sharpness = 2.0 / m2;
    distribution.Amplitude = vec3(1.0f / (3.141592 * m2)); 
    return distribution;
}

// Function 2696
float map(vec4 p) {
  vec4 temp;
  return mapWDists(p, temp);
}

// Function 2697
float map(in float val, in float startIn, in float endIn, in float startOut, in float endOut)
{
    float norm = (val - startIn) / (endIn - startIn);
    return norm * (endOut - startOut) + startOut;
}

// Function 2698
float sdfCircle(vec2 center, float radius, vec2 coord )
{
    vec2 offset = coord - center;
    
    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;
}

// Function 2699
float map(vec3 q){
        
		vec3 p; float d = 0.;
        
        // One Void Cube.
    	p = abs(mod(q, 3.) - 1.5);
    	d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1.);

        // Subdividing into more Void Cubes.    
    	p = abs(mod(q, 1.) - 0.5); // Dividing above by 3.
    	d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3.);
        
        // And so on.
    	p = abs(mod(q, 1./3.) - 0.5/3.); // Dividing above by 3.
    	d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3./3.);
        
		// Continue on in this manner. For more levels, you'll want to loop it. There's
		// a commented out example in the code somewhere. Also, you can experiment with 
		// the code to create more interesting variants.

		return d;
	}

// Function 2700
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)
{
    const vec2 e = vec2(0.001, 0);
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
}

// Function 2701
vec4 mapping(float dist, float min, float max, mat4 LUT, vec4 LUT_DIST){	
	
	float distLut = (dist - min) / max;
	int i1;
	for(int i=0;i <NB_LUT;++i){
		if(distLut < LUT_DIST[i+1]){i1 = i;break;}
	}
	vec4 col1,col2;
	float mixVal;
	if		(i1 == 0){
		col1 = LUT[0];col2 = LUT[1];
		mixVal = (distLut - LUT_DIST[0]) / (LUT_DIST[1] - LUT_DIST[0]);
	}else if(i1 == 1){
		col1 = LUT[1];col2 = LUT[2];
		mixVal = (distLut - LUT_DIST[1]) / (LUT_DIST[2] - LUT_DIST[1]);
	}else{
		col1 = LUT[2];col2 = LUT[3];
		mixVal = (distLut - LUT_DIST[2]) / (LUT_DIST[3] - LUT_DIST[2]);
	}
	
	
	//return vec4(mixVal);
	return mix(col1,col2,mixVal);
	
}

// Function 2702
vec2 scene(in vec3 point)
{
    // To make the sphere move along with the camera, for now it has the same speed added to it plus an offset
    // Z is depth in this case ;)
    // For some reason, the shape is off center if set to 0.0 ? 
    vec2 pyramid = vec2(sdPryamid4(point - vec3(0.05, sin(iTime*PI)+4.0, iTime*20.0+1.0), vec3(0.65,0.33,1.0)), PYRAMID);


    // FOR TESTING ONLY
    //vec2 sphere1 = vec2(sdSphere(point-vec3(0.0, sin(iTime*PI)+4.0, iTime*20.0+15.0), 8.0), PYRAMID);

    float mountainsHeight = mix(1.0, smoothstep(-.05, 1., iqnoise(point.xz*.75, 1.0, 1.0)*.25), saturate(abs(point.x)-3.0));
    vec2 mountainsGround = vec2(sdPlane2(point, vec4(0.0, mountainsHeight, 0.0, 0.0)), FLOOR);

    vec2 result = opU(mountainsGround, pyramid);

    return result;
}

// Function 2703
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    const vec2 e = vec2(2.201, 0);
    float ref = bumpSurf3D(p, nor);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),
                      bumpSurf3D(p - e.yxy, nor),
                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     
          
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 2704
void initscene()
{
    box0.min = vec3(-2.0, -1.2, -2.0);//room
   	box0.max = vec3( 2.0,  1.2,  2.0);
    
    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);

    float h = sin(time*3.0)*0.03;
    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;
    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu
   	sfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde
   	sfere[2].center_radius = vec4(sinr, h+0.1,cosr,    0.123);//albastru
    
    vec3 center = vec3(0.8,-0.8,-1.6); 
    cylinder[0].c = vec3( 0.55,0.0, 0.25) + center;
    cylinder[0].r = 0.04;
    cylinder[0].h = 0.4;
    
    cylinder[1].c = vec3( 0.55,0.0,-0.25) + center;
    cylinder[1].r = 0.04;
    cylinder[1].h = 0.4;
    
    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;
    cylinder[2].r = 0.04;
    cylinder[2].h = 0.4;
    
    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;
    cylinder[3].r = 0.04;
    cylinder[3].h = 0.4;

   	center = vec3(-1.55,-0.2, 0.5);
    cub = vec3(0.0, 0.0, 0.0) + center;//corp dulap
    lcub = vec3(0.4, 1.0, 0.8);    
   	boxe[0].min = cub - lcub;
   	boxe[0].max = cub + lcub;
    
   	cub = vec3(0.5, 0.0, +0.0) + center;//fanta
   	lcub = vec3(0.12, 0.98, 0.01);
   	boxe[1].min = cub - lcub;
   	boxe[1].max = cub + lcub;
    
   	cub = vec3(0.02, 0.99, 0.0) + center;//plafon
   	lcub = vec3(0.43, 0.015, 0.85);
   	boxe[2].min = cub - lcub;
   	boxe[2].max = cub + lcub;   
    
   	cub = vec3( 0.380, 0.0, 0.385) + center;//oglinda dreapta
   	lcub = vec3(0.03, 0.77, 0.18);    
   	boxe[3].min = cub - lcub;
   	boxe[3].max = cub + lcub;
    
   	cub = vec3(0.385, 0.0, -0.385) + center;//oglinda stanga
   	lcub = vec3(0.03, 0.77, 0.18);
   	boxe[4].min = cub - lcub;
   	boxe[4].max = cub + lcub;

   	cub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta
   	lcub = vec3(0.021, 0.1, 0.01);
   	boxe[5].min = cub - lcub;
   	boxe[5].max = cub + lcub;

   	cub = vec3(0.41, 0.0, -0.06) + center;//maner stanga
   	lcub = vec3(0.021, 0.1, 0.01);
   	boxe[6].min = cub - lcub;
   	boxe[6].max = cub + lcub;

   /*	cub = vec3(0.0, 0.0, 0.0) + center;//bbox
   	lcub = vec3(0.47, 1.2, 0.87);
   	boxe[7].min = cub - lcub;
   	boxe[7].max = cub + lcub;*/
//dulap

//birou
	center = vec3(0.8,-0.8,-1.6);
   	cub = vec3( 0.0, 0.4, 0.0) + center;//tablie
   	lcub = vec3(0.65, 0.015, 0.35);
   	boxe[7].min = cub - lcub;
   	boxe[7].max = cub + lcub;

//scaun
   	cub = vec3(-0.0, 0.1, 0.5) + center;//tablie
   	lcub = vec3(0.25, 0.015, 0.25);
   	boxe[8].min = cub - lcub;
   	boxe[8].max = cub + lcub;

   	cub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata
   	lcub = vec3(0.03, 0.25, 0.03);
   	boxe[9].min = cub - lcub;
   	boxe[9].max = cub + lcub;

   	cub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata
   	lcub = vec3(0.03, 0.25, 0.03);
   	boxe[10].min = cub - lcub;
   	boxe[10].max = cub + lcub;

   	cub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate
   	lcub = vec3(0.03, 0.60, 0.03);
   	boxe[11].min = cub - lcub;
   	boxe[11].max = cub + lcub;

   	cub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate
   	lcub = vec3(0.03, 0.60, 0.03);
   	boxe[12].min = cub - lcub;
   	boxe[12].max = cub + lcub;

   	cub = vec3(-0.0, 0.6,  0.74) + center;//spatar
   	lcub = vec3(0.25, 0.10, 0.01);
   	boxe[13].min = cub - lcub;
   	boxe[13].max = cub + lcub;
    
    cub = vec3(-0.4,-0.87,  1.9) ;//calorifer
   	lcub = vec3(0.55, 0.3, 0.06);
   	boxe[14].min = cub - lcub;
   	boxe[14].max = cub + lcub;
}

// Function 2705
float SceneViz(in vec3 pos, in vec3 dir)
{
    vec3 normal;
    float res = Scene(pos, dir, normal);
    return res!=1e3?1.:0.;//step(0.0,res);    
}

// Function 2706
bool scene(Point3 X, inout float distance, inout Material material, const bool shadow) { 
    Material planetMaterial;
    
    // Move to the planet's reference frame (ideally, we'd just trace in the 
    // planet's reference frame and avoid these operations per distance
    // function evaluation, but this makes it easy to integrate with a
    // standard framework)
    X = planetRotation * (X - planetCenter);
    Point3 surfaceLocation = normalize(X);
    
    // Compute t = distance estimator to the planet surface using a spherical height field, 
    // in which elevation = radial distance
    //
	// Estimate *conservative* distance as always less than that to the bounding sphere
    // (i.e., push down). Work on range [0, 1], and then scale by planet radius at the end
    
	float mountain = clamp(1.0 - fbm6(surfaceLocation * 4.0) + (max(abs(surfaceLocation.y) - 0.6, 0.0)) * 0.03, 0.0, 1.0);
    mountain = pow3(mountain) * 0.25 + 0.8;
    
    const float water = 0.85;
    float elevation = mountain;    
    
    Vector3 normal = normalize(cross(dFdx(surfaceLocation * mountain), dFdy(surfaceLocation * mountain)));
    
    // Don't pay for fine details in the shadow tracing pass
	if (! shadow) {
        if (elevation < water) {
            float relativeWaterDepth = min(1.0, (water - mountain) * 30.0);
            const float waveMagnitude = 0.0014;
            const float waveLength = 0.01;

            // Create waves. Shallow-water waves conform to coasts. Deep-water waves follow global wind patterns.
            const Color3 shallowWaterColor = Color3(0.4, 1.0, 1.9);
            // How much the waves conform to beaches
            const float shallowWaveRefraction = 4.0;        
            float shallowWavePhase = (surfaceLocation.y - mountain * shallowWaveRefraction) * (1.0 / waveLength);

            const Color3 deepWaterColor = Color3(0, 0.1, 0.7);
            float deepWavePhase    = (atan(surfaceLocation.z, surfaceLocation.x) + noise(surfaceLocation * 15.0) * 0.075) * (1.5 / waveLength);

            // This is like a lerp, but it gives a large middle region in which both wave types are active at nearly full magnitude
            float wave =  (cos(shallowWavePhase + time * 1.5) * sqrt(1.0 - relativeWaterDepth) + 
                           cos(deepWavePhase + time * 2.0) * 2.5 * (1.0 - abs(surfaceLocation.y)) * square(relativeWaterDepth)) *
                waveMagnitude;

            elevation = water + wave;

            // Set material, making deep water darker
            planetMaterial = Material(mix(shallowWaterColor, deepWaterColor, pow(relativeWaterDepth, 0.4)), 0.5 * relativeWaterDepth, 0.7);

            // Lighten polar water color
            planetMaterial.color = mix(planetMaterial.color, Color3(0.7, 1.0, 1.2), square(clamp((abs(surfaceLocation.y) - 0.65) * 3.0, 0.0, 1.0)));            
        } else {
            float materialNoise = noise(surfaceLocation * 200.0);

            float slope = clamp(2.0 * (1.0 - dot(normal, surfaceLocation)), 0.0, 1.0);

            bool iceCap     = abs(surfaceLocation.y) + materialNoise * 0.2 > 0.98; 
            bool rock       = (elevation + materialNoise * 0.1 > 0.94) || (slope > 0.3);
            bool mountainTop = (elevation + materialNoise * 0.05 - slope * 0.05) > (planetMaxRadius * 0.92);

            // Beach
            bool sand        = (elevation < water + 0.006) && (noise(surfaceLocation * 8.0) > 0.3);

            // Equatorial desert
            sand = sand || (elevation < 0.89) && 
                (noise(surfaceLocation * 1.5) * 0.15 + noise(surfaceLocation * 73.0) * 0.25 > abs(surfaceLocation.y));

            if (rock) {
                // Rock
                planetMaterial = ROCK;
            } else {
                // Trees
                planetMaterial = TREE;
            }

            if (iceCap || mountainTop) {
                // Ice (allow to slightly exceed physical conservation in the blue channel
                // to simulate subsurface effects)
                planetMaterial = ICE;
            } else if (! rock && sand) {
                planetMaterial = SAND;
            } else if (! rock && (iResolution.x > 420.0)) {
                // High frequency bumps for trees when in medium resolution
                elevation += noise(surfaceLocation * 150.0) * 0.02;
            }

            // Add high-frequency material detail
            if (! sand && ! iceCap) {
                planetMaterial.color *= mix(noise(surfaceLocation * 256.0), 1.0, 0.4);
            }

        }
    }
        
    elevation *= planetMaxRadius;
    
    float sampleElevation = length(X);
    float t = sampleElevation - elevation;
    
    // Be a little more conservative because a radial heightfield is not a great
    // distance estimator.
    t *= 0.8;
        
    // Compute output variables
    bool closer = (t < distance);       
    distance = closer ? t : distance;    
    if (closer) { material = planetMaterial; }
    return closer;    
}

// Function 2707
vec3 map( vec3 p )
{
	vec3 headp = transformHead( p );
	vec3 headq = vec3( abs(headp.x), headp.yz );

    // head
	float d = sdEllipsoid( headp, vec3(0.0,0.015,-0.06 ),vec3(0.33,0.365,0.34) );
	d = smax(d,-sdEllipsoid( vec3( almostIdentity( headq.x, 0.03, 0.01 ), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);
    //d = smax(d,-sdEllipsoid( vec3( sqrt(headq.x*headq.x+0.0001), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);
	d = smin(d,sdEllipsoid( headp, vec3(0.0,-0.165,0.13),vec3(0.22,0.15,0.145)), 0.01 );
	d = smin(d,sdEllipsoid( headp, vec3(0.01,-0.2,0.17),vec3(0.12,0.115,0.105)), 0.01 );
	d = smin(d,sdEllipsoid( headq, vec3(0.1,-0.103,0.09),vec3(0.175,0.146,0.18) ), 0.02);

    
    // nose
	vec3 n = headp-vec3(0.0,0.1,0.23);
	n.x -= n.y*n.y*0.18;
	n.yz = mat2(0.98,0.198997,-0.198997,0.98)*n.yz;
	d = smin( d, sdCone( n, vec2(0.01733,-0.13) ), 0.03);
	n.yz -= vec2(-0.102975, 0.004600);
	vec3 m = vec3(abs(n.x),n.yz);
	float na = sdCone( n, vec2(0.527,-0.85) );
	na = smax( na, sdSphere(n,vec3(0.0,-0.03,-0.04),0.1), 0.015 );
	na = smin( na, sdEllipsoid(m, vec3(0.038,-0.085,0.0),vec3(0.027)), 0.016 );
	na = smin( na, sdEllipsoid(m, vec3(0.0,-0.11,-0.01), vec3(0.02,0.02,0.02)), 0.02 );
	na = smax(na,-sdEllipsoid(m, vec3(0.033,-0.09,0.008),vec3(0.01,0.02,0.009)*1.5), 0.008 );
	d = smin( d, na, 0.01);

    // mouth
	vec3 bocap = headp-vec3(-0.006,-0.026,0.22);
	vec3 bocap3 = bocap;
	bocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;
	vec3 bocap2 = bocap;
	bocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;
	float  labioa = sdCone(bocap, vec2(0.219,-0.18) );
	labioa = smax( labioa, sdEllipsoid(bocap,vec3(0.0,0.1,-0.15), vec3(0.22,0.35,0.34)), 0.02 );
	d = smin( d, labioa, 0.015 );
	d = smax( d, -sdCapsule( bocap, vec3(0.0,-0.077,0.115),vec3(0.0,-0.09,0.135), 0.013 ), 0.01 );
	bocap2.y -= min(bocap2.x*bocap2.x*4.0,0.04);
	d = smax( d, -sdEllipsoid(bocap2,vec3(0.0,-0.172,0.15), vec3(0.09+0.008*sign(bocap.x),0.017,0.25)), 0.01 );		
	vec4 b = sdBezier( corner1, center, corner2, bocap );
	d = smin(d,b.x - 0.0075*sqrt(4.0*b.y*(1.0-b.y)), 0.005);

    // ears
	vec3 earq = headq - vec3(0.34,-0.04,0.02);
	earq.xy = mat2(0.9,0.436,-0.436,0.9)*earq.xy;
	earq.xz = mat2(0.8,0.6,-0.6,0.8)*earq.xz;
	float ear = sdEllipsoid( earq, vec3(0.0),vec3(0.08,0.12,0.09) );
	ear = smax( ear, (abs(earq.z)-0.016), 0.01 );
	ear = smin( ear, sdSphere(earq,vec3(0.015,0.0,-0.03),0.04), 0.02);        
	ear = smax( ear, -0.8*sdEllipsoid( earq, vec3(0.0,0.022,0.02),vec3(0.06,0.08,0.027) ),0.01 );
	ear = smax( ear, -sdEllipsoid( earq, vec3(-0.01,-0.01,0.01),vec3(0.04,0.04,0.05) ), 0.01 );
	d = smin(d,ear, 0.015);
    
    
    // eye sockets
	d = smax(d,-sdEllipsoid( headq, vec3(0.1+eyeOff,0.03,0.11),vec3(0.105,max(0.0,0.12-0.2*headq.x),0.115)+0.01),0.01 );
	b = sdBezier( vec3(0.053+eyeOff,0.017,0.225), vec3(0.12+eyeOff,-0.02,0.255), vec3(0.18+eyeOff,0.02,0.205), headq-vec3(0.0,0.03-0.04,0.0) );
	d = smin(d,b.x - 0.003*b.y*(1.0-b.y)*4.0,0.012);

    // chin fold
	n = (headp-vec3(0.14,-0.16,0.297));
	n.xy = mat2(0.8,0.6,-0.6,0.8)*n.xy;
	d = smax(d, -sdEllipsoid( n,  vec3(0.0), vec3(0.096,0.01,0.03)), 0.007);
	
    // neck/body
	{
	vec3 q = vec3( abs(p.x), p.yz );
	d = smin( d, sdCapsule( p, vec4(0.0,-0.1,-0.1,0.1), vec4(0.0,-0.6,-0.1, 0.12 )).x, 0.05 );
	d = smin( d, sdCapsule( q, vec3(0.0,-0.62,-0.08), vec3(0.24,-0.71,0.02-0.1), 0.16 ), 0.05 );        
	d = smin( d, sdCapsule( q, vec4(0.046,-0.555,0.05,0.01), vec4(0.250,-0.55,-0.035,-0.02) ).x, 0.03 );
	}
    
	vec3 res = vec3(d,1.0,1.0);
    

    // eyes
	m = headq - vec3(0.0021,0.0,0.019);
	d = sdEllipsoid( m, vec3(0.1+eyeOff,0.03,0.11),vec3(0.105,0.09,0.1) );
	d = smax(d,-sdEllipsoid( headq, vec3(0.102+eyeOff+0.004*sign(headp.x)*1.8,0.03+0.004*1.8,0.28),vec3(0.07) ),0.001);
	if( d<res.x ) res = vec3(d,2.0,1.0);

    // teeth
	{
	bocap3 = bocap3 - vec3(0.01,-0.055,0.04);
	bocap3.xz = mat2x2(0.99,0.141,-0.141,0.99)*bocap3.xz;
	d = sdCappedCylinder( bocap3.xzy, vec2(0.11,0.01) );
	vec3 dd = bocap3;
	dd.x = mod(dd.x+0.0075,0.015)-0.0075;
	float sp = sdBox( dd-vec3(0.0,-0.1,0.0), vec3(0.0004,0.018,0.015) );
	d = smax(d,-sp,0.003);
	d = max( d, dot(bocap3.xy,vec2(-0.707,0.707))+0.05 );
	if( d<res.x ) res = vec3(d,8.0,1.0);
	}

	
	// eyebrows
	b = sdBezier( vec3(0.035,0.16,0.0), vec3(0.1,0.18,-0.02), vec3(0.2,0.12,-0.1), 
	(headq-vec3(0.0,0.0,0.25))*vec3(1.0,1.0,2.0) );
	d = b.x - 0.01*sqrt(clamp(1.0-b.y,0.0,0.9));
	float fr = (sign(b.w)*headq.x*0.436+0.9*headq.y);
	float cp = cos(1300.0*fr);
	cp -= 0.5*cos(600.0*fr); 
	cp += 0.3*cos(330.0*fr);
	cp *= clamp(1.0-3.0*headq.x,0.0,0.8);
	d -= cp*0.0017;
	d/=1.5;
	if( d<res.x ) { res = vec3(d,3.0,0.4);}

    // hair
	//if( p.x>-0.4 && p.y>-0.1) // +10%
	{
		float hh = 0.27 - headp.y;

		float ss = sign(headp.x);

		vec3 pelop = headp;
		pelop.x += (1.0-hh)*0.007*cos(pelop.y*30.0);
		vec3 peloq = vec3( abs(pelop.x), pelop.yz );
		
		vec3 ta = vec3(0.0);
		float vc = 0.0;

		{
		const vec3 p0a = vec3(0.05,0.3,0.15);
		const vec3 p0b = vec3(0.18,0.17,0.22);
		const vec3 p0c = vec3(0.1,0.2,0.23);
		vec4 b = sdBezier( p0a, p0c, p0b, pelop );
		float d1 = b.x - 0.06*(1.0-0.9*b.y);
		d = d1; ta = p0b - p0a; vc = b.y;
		}
		{
		const vec4 p1a = vec4(-0.04,0.26,0.15,0.075);
		const vec4 p1c = vec4(0.02,0.2,0.24,0.015);
		vec2 b = sdCapsule(pelop, p1a, p1c );
		float d1 = b.x;
		if( d1<d ) { d=d1; ta = (p1a.xyz-p1c.xyz)*vec3(ss,1.0,1.0); vc = b.y;}
		}
		{
		const vec4 p2a = vec4(0.16,0.25,0.14,0.07);
		vec4 p2b = vec4(0.185+0.025*ss,0.14,0.23-0.02*ss,0.006);
		vec2 b = sdCapsule(peloq, p2a, p2b );
		float d1 = b.x;
		if( d1<d ) { d=d1; ta = p2b.xyz-p2a.xyz; vc = b.y;}
		}
		{
		const vec3 p3a = vec3(0.205,0.20,0.14);
		vec3 p3b = vec3(0.255+0.01*ss,0.05,0.17);
		vec3 p3c = vec3(0.21+0.01*ss,0.15,0.18);
		vec4 b = sdBezier( p3a, p3c, p3b, peloq );
		float d1 = b.x - 0.06*(1.0-0.9*b.y);
		if( d1<d ) { d=d1; ta = p3b-p3a; vc = b.y;}
		}
		{
		const vec4 p4a = vec4(0.24,0.16,0.11,0.06);
		vec4 p4b = vec4(0.285,-0.04,0.14,0.006);
		vec2 b = sdCapsule(peloq, p4a, p4b );
		float d1 = b.x;
		if( d1<d ) { d=d1; ta = p4b.xyz-p4a.xyz; vc = b.y; }
		}
		{
		const vec4 p5a = vec4(0.275,0.12,0.07,0.06);
		vec4 p5b = vec4(0.295,-0.09,0.1,0.006);
		vec2 b = sdCapsule(peloq, p5a, p5b );
		float d1 = b.x;
		if( d1<d ) { d=d1; ta = p5b.xyz-p5a.xyz; vc = b.y; }
		}

		
		{
		vec3 vv = normalize(vec3(ta.z*ta.z+ta.y*ta.y, -ta.x*ta.y, -ta.x*ta.z) );
		float ps  = dot(peloq,vv);
		d -= 0.003*sin(300.0*ps);
		d -= 0.008*(-1.0+2.0*textureGood( iChannel0, vec2(1024.0*ps,vc*5.12) ));
		}
		
		if( d<res.x ) res = vec3(d,3.0,vc);
	}

    // eyelashes
	{
	vec3 cp;
	vec4 b = sdBezier2(  vec3(0.0525+0.0025*sign(headp.x)+eyeOff,0.063, 0.225), 
			vec3(0.120+eyeOff,0.135, 0.215), vec3(0.1825+eyeOff+0.0025*sign(headp.x),0.050, 0.200), 
			headq, cp );
	float ls = 4.0*b.y*sqrt(1.0-b.y);
	d = b.x - 0.002*ls;
	d += 0.001*ls*sin(headq.x*300.0-headq.y*300.0)*step(cp.y,headq.y);
	d += 0.001*ls*sin(headq.x*1000.0-headq.y*1000.0)*step(cp.y,headq.y);
	if( d<res.x ) { res = vec3(d,3.0,0.35);}
    }
	

    // hat
    {
	vec3 hatp = transformHat( headp );
	d = sdEllipsoidXY2Z( hatp, vec3(0.36,0.38,0.365) );
	d = abs(d+0.003)-0.003;
	d = smax(d,-0.065-hatp.y,0.006);
	float gb = abs(hatp.x)-hatp.z-0.0975;
	d -= 0.002*sqrt(clamp(abs(gb)/0.015,0.0,1.0)) - 0.002;
	hatp.y += 0.1;
	float p1 = abs(sin(600.0*hatp.x+hatp.y*200.0));
	float p2 = abs(cos(150.0*hatp.z)*sin(150.0*hatp.y));
	p2 *= smoothstep(0.01,0.02,hatp.y-0.035);
	d -= 0.0005*mix(p1,2.0*p2,smoothstep(0.0,0.01,gb));
	if( d<res.x ) res = vec3(d,4.0,1.0);
	vec3 vp = hatp - vec3(0.0,0.19,0.0);
	vp.yz = mat2(0.8,-0.6,0.6,0.8)*vp.yz;
	vp.y -= 0.2*sqrt(clamp(1.0-vp.x*vp.x/0.115,0.0,1.0))-0.1;
	d = 0.8*sdEllipsoid( vp, vec3(0.0,0.0,0.25),vec3(0.3,0.04,0.35) );
	if( d<res.x ) res = vec3(d,5.0,1.0);
    }	
	
	
	return res;
}

// Function 2708
vec3 UE3Tonemap(vec3 color)
{
    return color / (color + 0.155) * 1.019;
}

// Function 2709
vec3 Scene_Normal(vec3 p, float r, inout RayHit hit)
{
    vec2 e = vec2(1.0, -1.0);
    
    vec2 r0 = Scene_SDF(p + e.xyy, hit);
    vec2 r1 = Scene_SDF(p + e.yyx, hit);
    vec2 r2 = Scene_SDF(p + e.yxy, hit);
    vec2 r3 = Scene_SDF(p + e.xxx, hit);
    
    vec3 norm = e.xyy * mix(r0.x, r0.y, r) + 
                e.yyx * mix(r1.x, r1.y, r) + 
                e.yxy * mix(r2.x, r2.y, r) + 
                e.xxx * mix(r3.x, r3.y, r);
    
    return normalize(norm);
}

// Function 2710
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
	res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
	res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
	res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
	res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
	res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
	res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
	res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opI( sdBox(    pos-vec3( 2.0,0.2, 1.0), vec3(0.20)),
	                           sdSphere( pos-vec3( 2.0,0.2, 1.0), 0.25)), 113.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
	                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
	                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    // distance deformation (knobbly sphere):
	res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 )
                           + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)
                         , 65.0 ) );
    
	res = opU( res, vec2( 0.5*sdTorus( opTwist(    pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
	res = opU( res, vec2( 0.3*sdTorus( opCheapBend(pos-vec3( 2.0,0.25,-1.0)),vec2(0.20,0.05)), 46.7 ) );

    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
    // scaled primitive:
    const float scale = .4;
    res = opU( res, vec2( sdSphere((pos - vec3(-2.0, 0.25, -2.0))/scale, 0.25)*scale, 70. ) );
    
    res = opU( res, vec2( opBlend( sdBox(      pos-vec3( 2.0,0.25, 0.0), vec3(.15,.05,.15) ),
                                   sdCylinder( pos-vec3( 2.0,0.25, 0.0), vec2(0.04,0.2))), 75. ) );
    return res;
}

// Function 2711
void calcSceneSlow(in Camera cam,in vec2 fragCoord,out float3 col,out float4 debug_col)
{
    float nx = iResolution.x;
    float ny = iResolution.y;
    const int ns = kNumSamplesSlow;
    
	col = float3(0.0);
    debug_col = float4(0.0);
#ifndef FORCE_DEBUG_RAY_FROM_THE_SIDE    
    Ray r_debug = cameraGetRay(cam,(iMouse.xy+float2(0.5))/iResolution.xy);
#else
 	Ray r_debug = rayConstruct(float3(-2.0,0.0,-1.0),float3(1.0,-0.252,0.0));   
#endif    
    
    for(int s = 0;s < ns; ++s)
    {
    	float2 uv = float2(fragCoord.x+rand(),fragCoord.y+rand())/float2(nx,ny);
        Ray r = cameraGetRay(cam,uv);
       	

        col += color(r);
#ifdef DEBUG_RAY        
        debug_col += debug_trace(r_debug,r);
#endif      
    }
    col/=float(ns); 
}

// Function 2712
vec4 map( in vec3 pos, float atime )
{
    hsha = 1.0;
    
    float t1 = fract(atime);
    float t4 = abs(fract(atime*0.5)-0.5)/0.5;

    float p = 4.0*t1*(1.0-t1);
    float pp = 4.0*(1.0-2.0*t1); // derivative of p

    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),
                     pow(p,2.0-p) + 0.1,
                     floor(atime) + pow(t1,0.7) -1.0 );

    // body
    vec2 uu = normalize(vec2( 1.0, -pp ));
    vec2 vv = vec2(-uu.y, uu.x);
    
    float sy = 0.5 + 0.5*p;
    float compress = 1.0-smoothstep(0.0,0.4,p);
    sy = sy*(1.0-compress) + compress;
    float sz = 1.0/sy;

    vec3 q = pos - cen;
    float rot = -0.25*(-1.0 + 2.0*t4);
    float rc = cos(rot);
    float rs = sin(rot);
    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;
    vec3 r = q;
	href = q.y;
    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );
    
    vec4 res = vec4( sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) ), 2.0, 0.0, 1.0 );

    if( res.x-1.0 < pos.y ) // bounding volume
	{
    float t2 = fract(atime+0.8);
    float p2 = 0.5-0.5*cos(6.2831*t2);
    r.z += 0.05-0.2*p2;
    r.y += 0.2*sy-0.2;
    vec3 sq = vec3( abs(r.x), r.yz );

	// head
    vec3 h = r;
    float hr = sin(0.791*atime);
    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));
    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;
    vec3 hq = vec3( abs(h.x), h.yz );
   	float d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );
	float d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );
	d = smin( d, d2, 0.1 );
    res.x = smin( res.x, d, 0.1 );
    
    // belly wrinkles
    {
    float yy = r.y-0.02-2.5*r.x*r.x;
    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));
    }
        
    // arms
    {
    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );
    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );
    }
        
    // ears
    {
    float t3 = fract(atime+0.9);
    float p3 = 4.0*t3*(1.0-t3);
    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );
    res.xz = smin( res.xz, ear, 0.01 );
    }
    
    // mouth
    {
   	d = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );
    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);
    res.x = smax( res.x, -d, 0.03 );
    }

	// legs
    {
    float t6 = cos(6.2831*(atime*0.5+0.25));
    float ccc = cos(1.57*t6*sign(r.x));
    float sss = sin(1.57*t6*sign(r.x));
	vec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1/sy;
    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );
    res.xz = smin( res.xz, legs, 0.07 );
    }
        
    // eye
    {
    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);
    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);
    res.x = smin( res.x, eyeball, 0.03 );
    
    vec3 cq = hq-vec3(0.1,0.34,0.08);
    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;
    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );
    res.x = smin( res.x, d, 0.03 );

    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));
    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));
    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));
    }
	}
    
    // ground
    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));
    float t5f = fract(atime+0.05);
    float t5i = floor(atime+0.05); 
    float bt4 = abs(fract(t5i*0.5)-0.5)/0.5;
    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );
    
    float k = length(pos.xz-bcen);
    float tt = t5f*15.0-6.2831 - k*3.0;
    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)/2.0)*smoothstep(0.0,0.01,t5f);
    float d = pos.y - fh;
    
    // bubbles
    {
    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);
    vec2 id = vec2( floor(pos.x/3.0), floor((pos.z+1.5)/3.0) );
    float fid = id.x*11.1 + id.y*31.7;
    float fy = fract(fid*1.312+atime*0.1);
    float y = -1.0+4.0*fy;
    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);
    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    
    float siz = 4.0*fy*(1.0-fy);
    siz = siz - 0.25f + pow(texture(iChannel0, vec2(0.1, .25)).r, 3.0f) * 1.0f;
    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );
    
    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));
    d2 *= 0.6;
    d2 = min(d2,2.0);
    d = smin( d, d2, 0.32 );
    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }
    }

    // candy
    {
    float fs = 5.0;
    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );
    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );
    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);
    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );
    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);
    float fid = id.x*0.143 + id.y*0.372;
    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);
    ra *= pow(texture(iChannel0, vec2(id.x, .25)).r, 3.0f) * 2.0f;
    d = sdSphere( vp, 0.35*ra)/fs;
    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);
    }
    
    return res;
}

// Function 2713
float distance_from_sphere(in vec3 world_point, in vec3 sphere_center, float radius)
{
    return length(world_point - sphere_center) - radius;
}

// Function 2714
G map(vec3 p) {

    vec3 bp = p;

    p.x += mf1;
    p.x = mod(p.x, 120.);

	pmm2(p.yz, vec2(30.));

    vec2 c =  pmo(p.zy, vec2(50. , 50. ));

    pmo(p.xz, vec2(13., 4. + mf2));

    pR(p.xz, -0.1);

    p.z += 19.;
    p.yx += 4.;
	p.x -= 18. + mf2;

    G obj;

    obj = DE(p, 4.5 - mf2);
    pR(p.xz, .4);

    p.x += 2.9;
    p.z += 9.;

    obj.dist = smin(
        obj.dist - .1,
        DE(p.zyx, 2.).dist - 1. ,
        .21
    );

    obj.mat = vec2(1., 0.);
    obj.space = p;

    p = bp;

    G obj2;
    // mix sphere with box
    obj2.dist = mix(
        fb(p, vec3(sr - 4.)),
        fsh(p, sr),
        cth
    );

    obj2.mat = vec2(2., 0.);
    obj2.space = p;

    obj = io(obj, obj2);

    return obj;
}

// Function 2715
float SceneDistance(vec3 pos, out float layer) {
    if (pos.x < 0.0) {
        return 1.0;
    }
    
    float planetNumber = floor((pos.x) / 2.0) + START_PLANET;
    
    vec3 planetPos = pos;
    planetPos.x = mod(planetPos.x, 2.0) - 1.0;
    float rotationSpeed = mix(-1.0, 1.0, fract(planetNumber / 2.3));
    planetPos.xz = Rotate(planetPos.xz, rotationSpeed * iTime);
    
    float terrainDetail = mix(0.1, 5.5, Rand(planetNumber + 0.16));
    float layerHeight = mix(0.005, 0.05, Rand(planetNumber + 0.55));
    float layerCount = floor(mix(3.5, 20.5, Rand(planetNumber + 0.36)));
    float noiseValue = 0.5 * noise((normalize(planetPos) + planetNumber) * terrainDetail) + 0.5;
    layer = floor(noiseValue * layerCount);
	
	float baseSize = mix(0.2, 0.4, Rand(planetNumber + 0.28));
    float d1 = SphereDistance(planetPos, baseSize + (layer - 1.0) * layerHeight);
    float d2 = SphereDistance(planetPos, baseSize + layer * layerHeight);
    
    float layerTransition = smoothstep(0.0, 0.3, fract(noiseValue * layerCount) + 0.06);
    return mix(d1, d2, layerTransition);
}

// Function 2716
float map(vec3 pos)
{
    vec2 hmp = getImageMPos(pos);
    float hm = 0.05*getImageBump(hmp);
    return udRoundBox(pos, vec3(5., 3.4, 0.1), 0.25) - hm;
}

// Function 2717
float distBox( in vec3 p, in vec3 b )
{
  return length(max(abs(p)-b,0.0));
}

// Function 2718
float map5_value1(vec3 p)
{
	float r = 0.;
    float s = 1.;
    float f = 1.;
    
    float w = 0.;
    for(int i = 0;i < 5;i++){
        r += s*noise_value1(p*f); w += s;
        s /= 2.;
        f *= 2.;
    }
    return r/w;
}

// Function 2719
float sceneSDF(vec3 point) {
    const mat4 scene_mat = mat4(
       0.5, 0., 0., 0.,
       0., 0.5, 0., 0.,
       0., 0., 0.5, 0.,
       0., 0.5, 0., 1.
    );
    float result = MAX_DIST;
    
     for (int i = 0; i < PYRAMIDS; i++) {
        mat4 modelMtx = mat4(
           1., 0., 0., 0.,
           0., 1., 0., 0.,
           0., 0., 1., 0.,
           0., 0., 0., 1.
        ) * scene_mat;
        
        for (int ii = POWER - 1; ii >= 0; ii--) {
            float loc_order = floor(mod(float(i), pow(5., float(ii + 1))) / pow(5., float(ii)));
            float isMiddle = floor(loc_order / 4.);
            float angle = HALF_HALF_PI + HALF_PI * loc_order;
            float r = sqrt(0.5);
            float y = -isMiddle;
            float x = (1. - isMiddle) * cos(angle) * r;
            float z = (1. - isMiddle) * sin(angle) * r;
            
        
            modelMtx = mat4(
               2., 0., 0., 0.,
               0., 2., 0., 0.,
               0., 0., 2., 0.,
               x, y, z, 1.
            ) * modelMtx;
        }
        
       result = min(result, sdPyramid(vec3(modelMtx * vec4(point, 1.)), 1.) / modelMtx[0][0]);
    }

    return result;
}

// Function 2720
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4, dc4;
  vec3 col, vn, q;
  float dstObj, dstSheet, s, flSize;
  szFac = 4. / float (nBallE.y - 1);
  flSize = szFac * 0.5 * float (nBallE.y + 1);
  q = ro;
  q.y -= - 2. * flSize;
  dc4 = CylHit (q, rd, 0.06, 3. * flSize + 0.2);
  dstObj = dc4.x;
  q = ro;
  q.x -= 2. * flSize + 0.06;
  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;
  if (min (dstSheet, dstObj) < dstFar) {
    if (dstSheet < dstObj) {
      vn = SheetNf ();
      s = sign (dot (rd, vn));
      if (s > 0.) vn = - vn;
      col4 = vec4 (SheetCol (s), 0.);
    } else {
      ro += dstObj * rd;
      vn = dc4.yzw;
      col4 = vec4 (0.9, 0.9, 0.95, 0.1);
      if (abs (ro.y) < flSize + 0.1) col4 *= (0.5 + 0.5 * smoothstep (0.05, 0.1,
         abs (mod (4. * (ro.y + 0.02) / flSize + 0.5, 1.) - 0.5)));
    }
    col = col4.rgb * (0.5 + 0.5 * max (dot (vn, sunDirEx), 0.)) +
       col4.a * pow (max (dot (reflect (sunDirEx, vn), rd), 0.), 32.);
  } else col = ExBgCol (rd);
  return clamp (col, 0., 1.);
}

// Function 2721
float GetDist(vec3 p){
    vec4 s = vec4(0,3.,6.,1);
    float sphereDist = length(p-s.xyz)-s.w;
    float planeDist = p.y;
   
    //bounce from left to right 
    //float xDis = mix(-1.5,1.5,sin(iTime));
    float td = sdTorus(p-vec3(1.),vec2(2.,.25));//vec3(3.,2.,8)

  /***  
    float cd = sdCapsule(p, vec3(0,1,6), vec3(1,2,6),.2);
    float cd1 = sdCapsule(p, vec3(0,2,6), vec3(1,2,6),.5);
    float cd2 = sdCapsule(p, vec3(0,3,6), vec3(1,2,6),.2);
    float cd3 = sdCapsule(p, vec3(1,2,6), vec3(1.5,2,6),.2);
    float bd = dBox(p-vec3(0.,2.,8),vec3(.8));
    float cyld = sdCylinder(p, vec3(0,.3,3), vec3(3,1,5),.2);
  ***/
    
    float d = min(td,planeDist);
    
    return d; 
    
}

// Function 2722
vec3 castScene( vec3 p, vec3 v, out vec3 normal, float time )
{
	float speedTime = time * SPEED;
	int halfSpheresCount = SPHERES_COUNT / 2;
	vec3 pos = vec3(CAST_DISTANCE);
	
	float h = CAST_DISTANCE;
	float newH;
	normal = vec3(0, 0, 0);
	
	for( int x = 0; x < SPHERES_COUNT; ++x )
	{
		for( int y = 0; y < SPHERES_COUNT; ++y )
		{	
			float cosT = cos(speedTime + float(y));
			
			vec3  baseCenter = vec3(cosT, cosT * mult, cosT );
			
			for( int z = 0; z < SPHERES_COUNT; ++z )
			{
				
				vec3 center = baseCenter + vec3( mult * float(z - halfSpheresCount), 
												 mult * float(y - halfSpheresCount), 
												 mult * float(x - halfSpheresCount) );
				
				newH = rayCastSphere( center, SPHERE_RADIUS, p, v );
				
				if( newH < h && newH > 0.0 )
				{
					h = newH;
					pos = p + v * h;
					normal = getNormal( center, pos );
				}
			}
		}
	}
		
	return pos;
}

// Function 2723
float edgedistance(vec3 pos, vec3 X) {
  return length(pos-dot(pos,X)*X);
}

// Function 2724
vec3 SceneNormal(vec3 pos) {
	const float DX = 0.004;
	const vec3 dx = vec3(DX, 0.0, 0.0);
    const vec3 dy = vec3(0.0, DX, 0.0);
    const vec3 dz = vec3(0.0, 0.0, DX);
    return normalize(vec3(
        SceneDistance(pos + dx) - SceneDistance(pos - dx),
        SceneDistance(pos + dy) - SceneDistance(pos - dy),
        SceneDistance(pos + dz) - SceneDistance(pos - dz)
    ));
}

// Function 2725
float distanceSq(vec3 v1, vec3 v2) {
    vec3 d = v1 - v2;
    return dot(d, d);
}

// Function 2726
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    if ( iFrame > 120 )
        discard;
    fragColor = textureLod( iChannel0, rayDir, 0.0 );
    fragColor = fragColor * fragColor;
    float kEnvmapExposure = 0.999;
    fragColor = -log2(1.0 - fragColor * kEnvmapExposure);    
    return;
}

// Function 2727
vec4 scene(vec3 p)
{
	float tunnelRadius = 0.38;
	float numCells = 8.0;
	
	float d, d1;
	vec3 q = p;
	
	vec3 col = vec3(0.1, 0.7, 1.0);
	d = 10000.0;
	
 	// tunnel
	#if 1
	vec2 uv = vec2((atan(p.y, p.x) + 3.14159265) / 6.283185307, -time*0.6 + p.z*0.4);
	Cell cell = Cells(uv, numCells, bumpTunnel);
	q.xy *= 1.0 + cell.d*0.1;
	d = max(length(q.xy) - tunnelRadius+0.01,-(length(q.xy) - tunnelRadius));
	if (openTunnel) d = max(-sdBox(p-vec3(-1.2, 0.0, 0.0), vec3(1.0, 1.0, 10.0)), d);
	float m = sampleMusic() * (1.0+smoothstep(0.4, 0.6, sampleMusic(cell.hash.x * cell.hash.y, 4.0)));
	vec3 c = m*vec3(cell.hash.x*0.9, cell.hash.y*0.3, 0.11)*cell.d;
	col = mix(col, c, smoothstep(0.1, 0.0, d));
	#endif
	
	// letter boxes
	#if 1
	float ltime = mod(time, 10.0);
	
	if (boxSymbol > 0.0)
	{
		for(int i = 0; i < 25; i++)
		{
			vec3 pos;
			
			if (boxSymbol < 1.1) // random boxes
			{
				ltime = time*3.0 + float(i)*20.134;
				
				float r = rand(float(i)*20.33);
				float z = -6.0+mod(ltime*(r + 0.5), 15.0);
				
				if (!openTunnel && z > 2.0) continue;
				
				pos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);
				d1 = sdBox(p-pos,  vec3(0.009)); // ugly boxes
				if (d1 < d)
				{
					d = d1;
					col = vec3(0.1, 0.6, 0.9)*(r+0.2);
				}
			}
			else // symbol mode
			{
				float z = 0.5+0.2*tan(-time - float(i)*0.04);
				if (z > 1.0) continue;
				
				vec3 shift = min(z-0.5, 0.0) * vec3(0.08*sin(time + 0.2*float(i)), 0.08*cos(time + 0.4 * float(i)), 0.0);
				pos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);
				d1 = sdBox(p-pos-shift,  vec3(0.009)); // ugly boxes
				if (d1 < d)
				{
					float lv = pattern(boxSymbol, (p.xy-shift.xy)*6.2); 
					d = d1;
					if (lv > 0.5) col = vec3(0.216, 0.106, 0.173);
					else col = vec3(0.820, 0.839, 0.906);
				}
			}
		}
	}
	#endif
	return vec4(col, d);
}

// Function 2728
float remap(float a,float b ,float c, float d,float v){
	return ((v-a)/(b-a))*(d-c)+ c;
}

// Function 2729
float mapWaterDetailed(vec3 p) {
    return sdPlane(p)+heightMapWaterDetailed(p, iTime);
}

// Function 2730
float SdfAABB(Object obj, vec3 pos){
    vec3 q = abs(pos - obj.pos) - obj.scale;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

// Function 2731
float map_rods(vec3 pos)
{
    pos.y+= 0.1;
    for (int i = 0; i < 7; ++i)
    {
    	pos.x=abs(pos.x);
    	pos.x-=0.61;
    }
    return sdCylinder(pos, vec2(0.13, 2.75));   
}

// Function 2732
vec3 sdForest( in vec3 pos, float tmin )
{
    float shid = 0.0;
    
    const float per = 200.0;
    
    pos -= vec3(120.0,-16.0,-600.0);
        
    vec3 vos = pos/per;
    vec3 ip = floor(vos);
    vec3 fp = fract(vos);
    
    bool hit = false;
    float d = tmin;
    float occ = 1.0;
    
    for( int j=0; j<=1; j++ )
    for( int i=0; i<=1; i++ )
    {
        vec2 of = vec2(i,j);
        ivec2 tid = ivec2(ip.xz + of );
        tid.y = min(tid.y,-0);
        
        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;
        
        vec3 rf =  hash3( uint(treeId) )-0.5;
        
        vec3 ros = vec3( (float(tid.x)+rf.x)*per,
                         0.0,
                         (float(tid.y)+rf.y)*per );


        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );
        hei *= (tid.y==0) ? 1.0 : 1.5;
          
        hei *= 275.0;

        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);
        if( d2<d)
        {
            d = d2;
            hit = false;
        }
        
        if( d2-150.0>d ) continue;
        
        vec2 qos = pos.xz - ros.xz;
        float an = atan(qos.x,qos.y);
        float ra = length(qos);
        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);

        
        // trick - only evalute 4 closest of the 10 cones
        int segid = int(floor(16.0*(pos.y-ros.y)/hei));
        for( uint k=ZEROU; k<4u; k++ )
        {
            uint rk = uint( min(max(segid+int(k),5),15) );
            
            float h = float(rk)/15.0;
            
            vec3 ran = hash3( treeId*24u+rk );
            
            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);

            ros.y = h*hei;
            
            float hh = 0.5 + 0.5*(1.0-h);
            float ww = 0.1 + 0.9*(1.0-h);
            hh *= 0.7+0.2*ran.x;
            ww *= 0.9+0.2*ran.y;
            hh *= 1.0+0.2*vv;
            
            vec2 rrr = vec2( ra, pos.y-ros.y );
            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));
            float d2 = tmp.x-mix(1.0,vv,tmp.y);
            if( d2<d )
            {
                hit = true;
                d = d2;
                shid = rf.z;
                occ = tmp.y * clamp(ra/100.0+h,0.0,1.0);
            }
        }
    }
    
    if( hit )
    {
        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));
        d -= 8.0*dis-4.0;
        //occ = dis;
    }
    
	return vec3(d,shid,occ);
}

// Function 2733
Hit torusSdf(vec3 p, vec2 dims) {
    Hit hit;
    vec2 q = vec2(length(p.zy) - dims.x, p.x);

    hit.dist = length(q) - dims.y;
    hit.color = vec3(1.0);
    
    return hit;
}

// Function 2734
float PrCapsDf (vec3 p, float r, float h)
{
  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;
}

// Function 2735
float distToAnalyticDerivatives(vec2 p)
{
    const float TAN_LEN = 0.05; //The segment (tangent) half-length
    float imageHeight = iResolution.y/iResolution.x;
    
    //Conversion factor from computation space to image space (Horizontal & Vert)
    vec2 imgScaling = vec2(1.0/HORIZONTAL_UNITS,imageHeight/VERTICAL_UNITS);
    
    //px = position (uv.x) at which the derivative is evaluated.
    float px = 0.5; //0.5 = image center
    if(iMouse.z > 0.1)
    {
        px = iMouse.x/iResolution.x;
    }
    float x = getDomainValue(px);
    
    vec2 V_Dx[COUNT];
    V_Dx[0] = vec2(F(x),dF(x));
    V_Dx[1] = vec2(G(x),dG(x));
    V_Dx[2] = vec2(H(x),dH(x));
    V_Dx[3] = vec2(Func4(x),dFunc4(x));
    V_Dx[4] = vec2(Func5(x),dFunc5(x));
    
    float minDist = INFINITY;
    for(int i=0; i < COUNT; ++i)
    {
        //Signal height, image space [0-imageHeight]
        float signalHeight = imgScaling.y*float(COUNT-1-i);
        
        //Computation space value and tangent
        float functionValue = V_Dx[i].x; //f(x)
        vec2 functionTan    = vec2(1.0,V_Dx[i].y); //vec2 = [dx,df'(x)], in other words, the variation of f(x) per unit of x
        
        //Image space value and tangent
        vec2 imageValue = vec2(px,signalHeight+functionValue*imgScaling.y);
        vec2 imageTangent = normalize(functionTan*imgScaling)*TAN_LEN;
                                
    	minDist = min(minDist,distanceToLineSeg(p,imageValue-imageTangent,imageValue+imageTangent));
    }
	return minDist;
}

// Function 2736
SDObject mapScene(vec3 p,int ignore,bool solo)
{
    vec3 testcol=vec3(1.,0.5,0.25);
    SDObject gr=newSDObject(1,Material(1,testcol.ggg,Reflectivity(.001,0.5),0.,0.),SDPrim(1,vec3(0.,0.,0.),vec3(0.),vec3(1.),1.,vec3(0.)));
    SDObject cu2=newSDObject(2,Material(3,testcol.gbb,Reflectivity(.70,.50),0.5,0.),SDPrim(3, vec3(2.,1.,2.6), vec3(0.,0.,0.), vec3(1.), (1.),vec3(0.)));
    SDObject cu=newSDObject(3,Material(3,testcol.bgb,Reflectivity(.70,.50),0.5,0.),SDPrim(2,vec3(-2.,1.,2.6),vec3(0.,0.,0.),vec3(1.),(1.),vec3(0.)));


    #ifdef ANIMATE_TABLET
    float tanim=0.5-0.5*cos(remap(iTime,0.,1.,0.,1.,true)*PI);
    #else
    #define tanim 1.
    #endif
    SDObject tablet=mapTablet(p,
                              mix(vec3(0.,1.,-1.),vec3(0.),tanim),
                              mix(vec3(1.4,1.4*-2.,0),vec3(1.4,0.,0.),tanim),tanim,ignore,solo);

    SDObject res= NoSDObject;
    res= SDUnion(res,SDOMap(gr,p),ignore,solo);	
    res= SDUnion(res,tablet,ignore,solo);	
    res= SDUnion(res,SDOMap(cu2,p),ignore,solo);
    res= SDUnion(res,SDOMap(cu,p),ignore,solo);

    return res;
}

// Function 2737
vec3 mapNormal(vec3 p,float d) {
    mat3 k = mat3( p, p, p ) - mat3( NEAR );// * d );
    return normalize(map(p).x - vec3(map(k[0]).x,map(k[1]).x,map(k[2]).x) );
}

// Function 2738
float map(vec3 p){
	rot3(p,vec3(1,2,3),iTime);
	return (fract(iTime*.2)<.5)?icosa(p,1.):dodec(p,1.);
}

// Function 2739
vec3 lambert_distrib(in vec3 n, in vec2 uv)
{
    //tangent coordinate system
    vec3 x, y; 
    if (dot(n, vec3(0,1,0)) > 0.99)
    {
        y = normalize(cross(n, vec3(1, 0, 0)));
        x = cross(y, n);
    }	else
    {
        x = normalize(cross(vec3(0, 1, 0), n));
        y = cross(n, x);
    }
    
    float theta = 3.1415926 * 2.0 * uv.x;
    float r = sqrt(uv.y); // uniform distribution in area instead of distance, 
    					  // hence the square root (a = pi*r^2)
    
    vec2 disk_p = vec2(cos(theta), sin(theta)) * r;
    vec3 p = disk_p.x * x + disk_p.y * y + n * sqrt(1.0 - r*r);
    return normalize(p);
}

// Function 2740
float dist(vec2 p0, vec2 p1)
{
    return length(p1-p0);
}

// Function 2741
float sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {
    return dot(p - planePoint, nvPlaneN);
}

// Function 2742
vec3 trn_ripplemapLod( vec3 pos, float scale )
{
    float lod = log2( scale / 0.001 );
    return .20 * texturenoiseLod( pos / .01, lod - 3.322 ).xyz +
           .30 * texturenoiseLod( pos / .003, lod - 1.585 ).xyz +
           .30 * texturenoiseLod( pos / .001, lod ).xyz +
           .20 * texturenoiseLod( pos / .0003, lod + 1.585 ).xyz;
}

// Function 2743
vec3 mapLadyBug( vec3 p, float curmin )
{
    
    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;
    if( db>curmin ) return vec3(10000.0,0.0,0.0);
    
    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );
    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );
    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );
  	dBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );
  	dBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );

    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );

    // --------
    vec3 hc = vec3(0.0,0.1,0.8);
    vec3 ph = rotateX(p-hc,0.5);
    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );
    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );
    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );

    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );
    
    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq

    // -------------
    
    vec3 k1 = vec3(0.42,-0.05,0.92);
    vec3 k2 = vec3(0.49,-0.2,1.05);
    float dLegs = 10.0;

    float sx = sign(p.x);
    p.x = abs(p.x);
    for( int k=0; k<3; k++ )
    {   
        vec3 q = p;
        q.y -= min(sx,0.0)*0.1;
        if( k==0) q += vec3( 0.0,0.11,0.0);
        if( k==1) q += vec3(-0.3,0.1,0.2);
        if( k==2) q += vec3(-0.3,0.1,0.6);
        
        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );
        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);
        dLegs = min(dLegs,se.x);

        se = sdLine( q, k1, k2 );
        se.x -= 0.01 + 0.01*se.y;
        dLegs = min(dLegs,se.x);

        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );
        se.x -= 0.02 - 0.01*se.y;
        dLegs = min(dLegs,se.x);
    }
    
    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);


    return res;
}

// Function 2744
float mapTree0(in vec3 p) {
	float 
        a = mix(.045,.001,clpOld)*p.y*cos(jGlobalTime*10.), // (life < OLD_TREE ? 22. : mix(22.,1.,clamp(life- OLD_TREE,0.,1.)))); 
	    c = cos(a),
        s = sin(a);
    p.xz *= mat2(c,-s,s,c);
	p.y *= (1.05+ mix(.04*cos(jGlobalTime/4.*6.28+.8), 0., clpOld));
	return sdTree0(p);
}

// Function 2745
float bisectDist(vec3 p, vec3 a, vec3 b)
{
    return distance(a,b)*0.5 - dot(p - a, normalize(b - a));
}

// Function 2746
vec3 map_Ssph_rgb(vec3 ro, vec3 rd, vec3 nrm) {
    return map_Ssph_pm(ro, rd);
}

// Function 2747
float MapTree( vec3 p)
{  
  float terrainHeight = GetTerrainHeight(p);
  float treeHeight =GetTreeHeight(p, terrainHeight);

  // get terrain height at position and tree height onto that
  return  p.y - terrainHeight-treeHeight;
}

// Function 2748
bool Material_bsdf(IntersectInfo isectInfo, Ray wo, out Ray wi, out vec3 attenuation)
{
    int materialType = isectInfo.materialType;

    if(materialType == LAMBERT)
    {
        vec3 target = isectInfo.p + isectInfo.normal + random_in_unit_sphere();

        wi.origin = isectInfo.p;
        wi.direction = target - isectInfo.p;

        attenuation = isectInfo.albedo;

        return true;
    }
    else
    if(materialType == METAL)
    {
        float fuzz = isectInfo.fuzz;

        vec3 reflected = reflect(normalize(wo.direction), isectInfo.normal);

        wi.origin = isectInfo.p;
        wi.direction = reflected + fuzz * random_in_unit_sphere();

        attenuation = isectInfo.albedo;

        return (dot(wi.direction, isectInfo.normal) > 0.0f);
    }
    else
    if(materialType == DIELECTRIC)
    {
        vec3 outward_normal;
        vec3 reflected = reflect(wo.direction, isectInfo.normal);

        float ni_over_nt;

        attenuation = vec3(1.0f, 1.0f, 1.0f);
        vec3 refracted;
        float reflect_prob;
        float cosine;

        float rafractionIndex = isectInfo.refractionIndex;

        if (dot(wo.direction, isectInfo.normal) > 0.0f)
        {
            outward_normal = -isectInfo.normal;
            ni_over_nt = rafractionIndex;
           
            cosine = dot(wo.direction, isectInfo.normal) / length(wo.direction);
            cosine = sqrt(1.0f - rafractionIndex * rafractionIndex * (1.0f - cosine * cosine));
        }
        else
        {
            outward_normal = isectInfo.normal;
            ni_over_nt = 1.0f / rafractionIndex;
            cosine = -dot(wo.direction, isectInfo.normal) / length(wo.direction);
        }
        if (refractVec(wo.direction, outward_normal, ni_over_nt, refracted))
            reflect_prob = schlick(cosine, rafractionIndex);
        else
            reflect_prob = 1.0f;
        if (rand2D() < reflect_prob)
        {
            wi.origin = isectInfo.p;
            wi.direction = reflected;
        }
        else
        {
            wi.origin = isectInfo.p;
            wi.direction = refracted;
        }

        return true;
    }

    return false;
}

// Function 2749
void process_text_map_markers( int i, inout int N,
                          	   inout vec4 params, inout uvec4 phrase, inout vec4 argv,
                               GameState gs )
{
    if( i == N )
    {
        params = vec4( g_textres.x / 2. - CW(19.,15.) / 2., g_textres.y / 6., 1, 15 );
        phrase = uvec4( 0x102020fb, 0x206b6d20, 0x20202012, 12 );
        float ls = 2. * g_textres.x / g_textres.y * CW(19.,15.) / g_textres.x * g_data.radius / gs.camzoom;
        argv.x = ls;
    }
    N++;
    float x = g_textres.x - 160.;
    float y = g_textres.y - 24.;
    if( gs.waypoint != ZERO )
    {
        vec4 loc = navb( gs.waypoint, ZERO );
        switch( i - N )
        {
        case 0: params = vec4( x, y,       1, 12 ); phrase = uvec4( 0xa7000000, 0, 0, 1 ); break;
        case 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;
        case 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;
        case 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - g_data.radius; break;
        }
        N += 4;
        y -= 80.;
    }
    if( gs.mapmarker != ZERO )
    {
        vec4 loc = navb( gs.mapmarker, ZERO );
        switch( i - N )
        {
        case 0: params = vec4( x, y,       1, 12 ); phrase = uvec4( 0x4d61726b, 0x65720000, 0, 6 ); break;
        case 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;
        case 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;
        case 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - g_data.radius; break;
        }
        N += 4;
    }
}

// Function 2750
void init_scene()
{
    spheres[0] = sphere(vec3(0, 0.5, 0), 0.5, 
                    material(vec3(0.95), vec3(0)));
	spheres[1] = sphere(vec3(3.5, 2.8, -0.5), 1.0, 
                    material(vec3(0.95), vec3(2)));
    planes[0] = plane(vec3(0), vec3(0,1,0), 
                      material(vec3(0.95, 0.55, 0.2), vec3(0)));
}

// Function 2751
vec3 map(vec3 p //time,uv, m.x==WCurrent m.y=RAYON
){vec4 m;
 ;float t=iTime
 ;m.x=WCurrent
 ;m.y=RAYON
 // ;float chubby=mix(0.,.4,abs(p.x)) //silly bot not useless
 ;float chubby=mix(0.,.2,cos(t)*.5+.5)                    //interior roundness
 ;vec3 d=sdTesserac(p)+vec3(chubby,0.,0.)//+vec3(chubby,0,0)
 ;d=miX(d,unicorn(p,m,chubby))
 ;//d.y=0.//anti.seizute from rapid flickering (cone is often close to a singularity, as it has a division)
 ;//d=miX(d,vec3(box(vec4(p,WCurrent)*B, vec4(.5-m.y*.5)-chubby),-1,m.x))  
 ;//d=miX(d,vec3(length(vec4(p,m.x)*B)-.5-chubby2,-1,m.x      ))//sphere  
 ;//d=miX(d,vec3(sdCubinder(vec4(p,m.x)*B,vec3(.5-m.y*.5)-chubby),-1,m.x))
 ;//d=miX(d,vec3(cylinderDuo(vec4(p,m.x)*B,vec2(.5-m.y*.5)-chubby),-1,m.x))
 ;return d-chubby//+vec3(chubby,0.,0.)
     ;}

// Function 2752
float sdf_f(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(2, -2, 0), vec3(2, -8, 0)));
    t = min(t, sdf_quarter0_torus(pos, vec3(4, -2, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4.5, 0), vec3(4, -4.5, 0)));
    return t;
}

// Function 2753
float scene_next_feature(float t) {
    vec4 regs;
    for (int i = 0; i < NUM_CSG_OPS; ++i) {
        CSG_OP op = csg_ops[i];
        int opcode = op[0];
        float d = get_reg(regs, op[1]);
        float src;
        if (op[2] < 0) {
            src = get_reg(regs, op[2]);
        } else {
            src = interval_edge(get_brush_interval(op[2]), t);
        }
        if (opcode == op_or) {
            d = min(d, src);
        } else if (opcode == op_and) {
            d = max(d, src);
        } else if (opcode == op_and_not) {
            d = max(d, -src);
        } else if (opcode == op_set) {
            d = src;
        }
        set_reg(regs, op[1], d);
    }
    return regs[0];
}

// Function 2754
vec3 ToneMapFilmicALU(vec3 x)
{
    x *= 0.665;
    
   #if 0
    x = max(vec3(0.0), x - 0.004f);
    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    
    x = sRGB_InvEOTF(x);
   #else
    x = max(vec3(0.0), x);
    x = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    
    x = pow(x, vec3(2.2));// using gamma instead of sRGB_InvEOTF + without x - 0.004f looks about the same
   #endif
    
    return x;
}

// Function 2755
vec4 earthHeightmap(vec2 p) {

    uint v = 0u;
	v = p.y == 99. ? 0u : v;
	v = p.y == 98. ? 0u : v;
	v = p.y == 97. ? 0u : v;
	v = p.y == 96. ? 0u : v;
	v = p.y == 95. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 555814912u : (p.x < 64. ? 286335794u : (p.x < 72. ? 1114113u : (p.x < 80. ? 572588048u : (p.x < 88. ? 1114402u : 0u))))))))))) : v;
	v = p.y == 94. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 268435456u : (p.x < 56. ? 536870946u : (p.x < 64. ? 74291u : (p.x < 72. ? 858988816u : (p.x < 80. ? 860107571u : (p.x < 88. ? 286401059u : (p.x < 96. ? 17u : (p.x < 104. ? 0u : (p.x < 112. ? 268435456u : (p.x < 120. ? 272u : 0u))))))))))))))) : v;
	v = p.y == 93. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 823197952u : (p.x < 64. ? 572588050u : (p.x < 72. ? 1145320226u : (p.x < 80. ? 1145390148u : (p.x < 88. ? 322122564u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 1052672u : 0u)))))))))))))) : v;
	v = p.y == 92. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 268435456u : (p.x < 56. ? 554766336u : (p.x < 64. ? 553648128u : (p.x < 72. ? 1127359026u : (p.x < 80. ? 1431655748u : (p.x < 88. ? 38028356u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 16u : (p.x < 152. ? 0u : (p.x < 160. ? 16777216u : 0u)))))))))))))))))))) : v;
	v = p.y == 91. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 33624064u : (p.x < 64. ? 0u : (p.x < 72. ? 857735168u : (p.x < 80. ? 1432769860u : (p.x < 88. ? 860111957u : (p.x < 96. ? 1u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 69632u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 16u : 0u)))))))))))))))))))) : v;
	v = p.y == 90. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 268435456u : (p.x < 56. ? 17825792u : (p.x < 64. ? 1u : (p.x < 72. ? 838860800u : (p.x < 80. ? 1717986644u : (p.x < 88. ? 19088726u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 256u : (p.x < 144. ? 0u : (p.x < 152. ? 16u : 0u))))))))))))))))))) : v;
	v = p.y == 89. ? (p.x < 8. ? 1u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 17895424u : (p.x < 48. ? 268435456u : (p.x < 56. ? 0u : (p.x < 64. ? 8464u : (p.x < 72. ? 268435456u : (p.x < 80. ? 1717916739u : (p.x < 88. ? 270611814u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 286261248u : (p.x < 168. ? 17u : (p.x < 176. ? 4369u : 0u)))))))))))))))))))))) : v;
	v = p.y == 88. ? (p.x < 8. ? 0u : (p.x < 16. ? 69888u : (p.x < 24. ? 19018256u : (p.x < 32. ? 1048576u : (p.x < 40. ? 2u : (p.x < 48. ? 0u : (p.x < 56. ? 1048576u : (p.x < 64. ? 2166784u : (p.x < 72. ? 16777216u : (p.x < 80. ? 1717916722u : (p.x < 88. ? 3425365u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 536870912u : (p.x < 120. ? 273u : (p.x < 128. ? 0u : (p.x < 136. ? 16777216u : (p.x < 144. ? 0u : (p.x < 152. ? 553648128u : (p.x < 160. ? 285282850u : (p.x < 168. ? 16777489u : (p.x < 176. ? 286335232u : (p.x < 184. ? 273u : (p.x < 192. ? 285212672u : 17825792u)))))))))))))))))))))))) : v;
	v = p.y == 87. ? (p.x < 8. ? 1u : (p.x < 16. ? 572592384u : (p.x < 24. ? 286331170u : (p.x < 32. ? 286261249u : (p.x < 40. ? 17891601u : (p.x < 48. ? 0u : (p.x < 56. ? 1114385u : (p.x < 64. ? 571473920u : (p.x < 72. ? 285212672u : (p.x < 80. ? 1700090930u : (p.x < 88. ? 4u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 304152576u : (p.x < 120. ? 1118224u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 1u : (p.x < 152. ? 286261248u : (p.x < 160. ? 286265890u : (p.x < 168. ? 286265617u : (p.x < 176. ? 16921104u : (p.x < 184. ? 16781601u : (p.x < 192. ? 285282304u : 571544097u)))))))))))))))))))))))) : v;
	v = p.y == 86. ? (p.x < 8. ? 65536u : (p.x < 16. ? 285217041u : (p.x < 24. ? 571544081u : (p.x < 32. ? 286265873u : (p.x < 40. ? 286331136u : (p.x < 48. ? 268435473u : (p.x < 56. ? 17u : (p.x < 64. ? 1048576u : (p.x < 72. ? 536870913u : (p.x < 80. ? 19158338u : (p.x < 88. ? 0u : (p.x < 96. ? 4384u : (p.x < 104. ? 0u : (p.x < 112. ? 17960960u : (p.x < 120. ? 65536u : (p.x < 128. ? 0u : (p.x < 136. ? 16777216u : (p.x < 144. ? 0u : (p.x < 152. ? 286261248u : (p.x < 160. ? 286331153u : (p.x < 168. ? 1118481u : (p.x < 176. ? 572666368u : (p.x < 184. ? 19014450u : (p.x < 192. ? 572592145u : 274u)))))))))))))))))))))))) : v;
	v = p.y == 85. ? (p.x < 8. ? 0u : (p.x < 16. ? 285212672u : (p.x < 24. ? 555880993u : (p.x < 32. ? 288568098u : (p.x < 40. ? 286331153u : (p.x < 48. ? 4113u : (p.x < 56. ? 0u : (p.x < 64. ? 554762240u : (p.x < 72. ? 0u : (p.x < 80. ? 283970u : (p.x < 88. ? 0u : (p.x < 96. ? 32u : (p.x < 104. ? 0u : (p.x < 112. ? 17899520u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 65536u : (p.x < 144. ? 0u : (p.x < 152. ? 286261248u : (p.x < 160. ? 286331153u : (p.x < 168. ? 4369u : (p.x < 176. ? 572592128u : (p.x < 184. ? 305275442u : (p.x < 192. ? 304222480u : 65537u)))))))))))))))))))))))) : v;
	v = p.y == 84. ? (p.x < 8. ? 0u : (p.x < 16. ? 318767104u : (p.x < 24. ? 842211888u : (p.x < 32. ? 53682738u : (p.x < 40. ? 286261280u : (p.x < 48. ? 69905u : (p.x < 56. ? 0u : (p.x < 64. ? 272u : (p.x < 72. ? 0u : (p.x < 80. ? 17456u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 268435456u : (p.x < 112. ? 74275u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 65536u : (p.x < 144. ? 0u : (p.x < 152. ? 285212672u : (p.x < 160. ? 286331153u : (p.x < 168. ? 285217041u : (p.x < 176. ? 4369u : (p.x < 184. ? 572732466u : (p.x < 192. ? 269558290u : 74256u)))))))))))))))))))))))) : v;
	v = p.y == 83. ? (p.x < 8. ? 0u : (p.x < 16. ? 34676736u : (p.x < 24. ? 590413857u : (p.x < 32. ? 304230947u : (p.x < 40. ? 285282577u : (p.x < 48. ? 1118481u : (p.x < 56. ? 0u : (p.x < 64. ? 4096u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 268435456u : (p.x < 112. ? 4371u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 65536u : (p.x < 144. ? 0u : (p.x < 152. ? 285212672u : (p.x < 160. ? 286331153u : (p.x < 168. ? 286331153u : (p.x < 176. ? 269553937u : (p.x < 184. ? 286331426u : (p.x < 192. ? 18u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 82. ? (p.x < 8. ? 0u : (p.x < 16. ? 1048576u : (p.x < 24. ? 0u : (p.x < 32. ? 589505056u : (p.x < 40. ? 285217041u : (p.x < 48. ? 69905u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 2u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 268435456u : (p.x < 112. ? 1u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 65552u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 286331153u : (p.x < 168. ? 286401041u : (p.x < 176. ? 286331426u : (p.x < 184. ? 34u : (p.x < 192. ? 2097152u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 81. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 842211584u : (p.x < 40. ? 286401058u : (p.x < 48. ? 1118481u : (p.x < 56. ? 0u : (p.x < 64. ? 286331136u : (p.x < 72. ? 1u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 16u : (p.x < 112. ? 0u : (p.x < 120. ? 16777216u : (p.x < 128. ? 0u : (p.x < 136. ? 1114112u : (p.x < 144. ? 0u : (p.x < 152. ? 268435456u : (p.x < 160. ? 286331153u : (p.x < 168. ? 589509410u : (p.x < 176. ? 287449634u : (p.x < 184. ? 2u : (p.x < 192. ? 1179648u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 80. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 572657664u : (p.x < 40. ? 571548195u : (p.x < 48. ? 69905u : (p.x < 56. ? 0u : (p.x < 64. ? 286331136u : (p.x < 72. ? 17u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 256u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 1114112u : (p.x < 144. ? 0u : (p.x < 152. ? 555810816u : (p.x < 160. ? 554766882u : (p.x < 168. ? 572666418u : (p.x < 176. ? 18944274u : (p.x < 184. ? 0u : (p.x < 192. ? 2170880u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 79. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 589365504u : (p.x < 40. ? 287449907u : (p.x < 48. ? 285282577u : (p.x < 56. ? 17u : (p.x < 64. ? 286331152u : (p.x < 72. ? 4113u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 1u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 1118464u : (p.x < 144. ? 272u : (p.x < 152. ? 287379456u : (p.x < 160. ? 303121202u : (p.x < 168. ? 304226866u : (p.x < 176. ? 303108369u : (p.x < 184. ? 1u : (p.x < 192. ? 4096u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 78. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 1126170624u : (p.x < 40. ? 572736306u : (p.x < 48. ? 286265873u : (p.x < 56. ? 4369u : (p.x < 64. ? 286331152u : (p.x < 72. ? 273u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 268435473u : (p.x < 120. ? 1u : (p.x < 128. ? 1u : (p.x < 136. ? 17895424u : (p.x < 144. ? 1118481u : (p.x < 152. ? 843264528u : (p.x < 160. ? 590627634u : (p.x < 168. ? 555885090u : (p.x < 176. ? 319881234u : (p.x < 184. ? 17u : 0u))))))))))))))))))))))) : v;
	v = p.y == 77. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 285212672u : (p.x < 40. ? 572732194u : (p.x < 48. ? 286331170u : (p.x < 56. ? 268505361u : (p.x < 64. ? 1118481u : (p.x < 72. ? 65536u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 268435456u : (p.x < 112. ? 303108368u : (p.x < 120. ? 4369u : (p.x < 128. ? 0u : (p.x < 136. ? 69632u : (p.x < 144. ? 304156944u : (p.x < 152. ? 861155601u : (p.x < 160. ? 573781043u : (p.x < 168. ? 571548211u : (p.x < 176. ? 18874641u : (p.x < 184. ? 17u : 0u))))))))))))))))))))))) : v;
	v = p.y == 76. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 805306368u : (p.x < 40. ? 573710882u : (p.x < 48. ? 286331426u : (p.x < 56. ? 286261265u : (p.x < 64. ? 17961233u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 285212672u : (p.x < 112. ? 16917026u : (p.x < 120. ? 288u : (p.x < 128. ? 0u : (p.x < 136. ? 65536u : (p.x < 144. ? 555880721u : (p.x < 152. ? 1160843553u : (p.x < 160. ? 841176387u : (p.x < 168. ? 571613747u : (p.x < 176. ? 268505344u : (p.x < 184. ? 2u : 0u))))))))))))))))))))))) : v;
	v = p.y == 75. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 268435456u : (p.x < 40. ? 591667970u : (p.x < 48. ? 286335522u : (p.x < 56. ? 4369u : (p.x < 64. ? 1114385u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 555810816u : (p.x < 112. ? 66083u : (p.x < 120. ? 529u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 286331136u : (p.x < 152. ? 857805585u : (p.x < 160. ? 859059012u : (p.x < 168. ? 304226851u : (p.x < 176. ? 537919488u : 0u)))))))))))))))))))))) : v;
	v = p.y == 74. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 1161048883u : (p.x < 48. ? 286335797u : (p.x < 56. ? 268501009u : (p.x < 64. ? 69888u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 537919488u : (p.x < 112. ? 304087313u : (p.x < 120. ? 0u : (p.x < 128. ? 8704u : (p.x < 136. ? 0u : (p.x < 144. ? 824250640u : (p.x < 152. ? 839984705u : (p.x < 160. ? 858927921u : (p.x < 168. ? 20062754u : (p.x < 176. ? 16847104u : (p.x < 184. ? 4096u : 0u))))))))))))))))))))))) : v;
	v = p.y == 73. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 536870912u : (p.x < 40. ? 1160983347u : (p.x < 48. ? 286401332u : (p.x < 56. ? 1114385u : (p.x < 64. ? 4369u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 268435456u : (p.x < 104. ? 1249826u : (p.x < 112. ? 553660416u : (p.x < 120. ? 18u : (p.x < 128. ? 38993920u : (p.x < 136. ? 268435456u : (p.x < 144. ? 1400267025u : (p.x < 152. ? 304309880u : (p.x < 160. ? 573711154u : (p.x < 168. ? 288568098u : (p.x < 176. ? 8720u : (p.x < 184. ? 4096u : 0u))))))))))))))))))))))) : v;
	v = p.y == 72. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 536870912u : (p.x < 40. ? 1160983347u : (p.x < 48. ? 286401348u : (p.x < 56. ? 286326785u : (p.x < 64. ? 17u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 268435456u : (p.x < 104. ? 12834u : (p.x < 112. ? 805371904u : (p.x < 120. ? 590413824u : (p.x < 128. ? 3425330u : (p.x < 136. ? 0u : (p.x < 144. ? 1198657809u : (p.x < 152. ? 572662306u : (p.x < 160. ? 590488370u : (p.x < 168. ? 17965858u : (p.x < 176. ? 4881u : 0u)))))))))))))))))))))) : v;
	v = p.y == 71. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 268435456u : (p.x < 40. ? 1128547136u : (p.x < 48. ? 286401366u : (p.x < 56. ? 537919488u : (p.x < 64. ? 1u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 8737u : (p.x < 112. ? 0u : (p.x < 120. ? 841158658u : (p.x < 128. ? 36979492u : (p.x < 136. ? 4096u : (p.x < 144. ? 596145249u : (p.x < 152. ? 1735533090u : (p.x < 160. ? 859072630u : (p.x < 168. ? 4899u : (p.x < 176. ? 256u : 0u)))))))))))))))))))))) : v;
	v = p.y == 70. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 858927872u : (p.x < 48. ? 286335844u : (p.x < 56. ? 303104001u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 268435984u : (p.x < 112. ? 0u : (p.x < 120. ? 34799617u : (p.x < 128. ? 590483730u : (p.x < 136. ? 286466560u : (p.x < 144. ? 2022203665u : (p.x < 152. ? 1753781299u : (p.x < 160. ? 878012245u : (p.x < 168. ? 803u : (p.x < 176. ? 4096u : (p.x < 184. ? 49u : 0u))))))))))))))))))))))) : v;
	v = p.y == 69. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 1127354912u : (p.x < 48. ? 17900083u : (p.x < 56. ? 2166784u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 841093136u : (p.x < 112. ? 2u : (p.x < 120. ? 16777216u : (p.x < 128. ? 1142947857u : (p.x < 136. ? 842146338u : (p.x < 144. ? 2558874726u : (p.x < 152. ? 2576980377u : (p.x < 160. ? 862423176u : (p.x < 168. ? 275u : (p.x < 176. ? 285212672u : (p.x < 184. ? 1u : 0u))))))))))))))))))))))) : v;
	v = p.y == 68. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 839974912u : (p.x < 48. ? 1123139u : (p.x < 56. ? 65536u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 19079986u : (p.x < 112. ? 16u : (p.x < 120. ? 0u : (p.x < 128. ? 1107300642u : (p.x < 136. ? 1110647588u : (p.x < 144. ? 2571183460u : (p.x < 152. ? 2576980377u : (p.x < 160. ? 595036297u : (p.x < 168. ? 34u : 0u))))))))))))))))))))) : v;
	v = p.y == 67. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 856694784u : (p.x < 48. ? 1122866u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 268435456u : (p.x < 104. ? 17900069u : (p.x < 112. ? 4368u : (p.x < 120. ? 268435456u : (p.x < 128. ? 268440097u : (p.x < 136. ? 555823925u : (p.x < 144. ? 2164261698u : (p.x < 152. ? 2576980377u : (p.x < 160. ? 292063368u : (p.x < 168. ? 51u : 0u))))))))))))))))))))) : v;
	v = p.y == 66. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 838926336u : (p.x < 48. ? 70196u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 536870912u : (p.x < 104. ? 286331153u : (p.x < 112. ? 1118481u : (p.x < 120. ? 286261248u : (p.x < 128. ? 1118738u : (p.x < 136. ? 825316146u : (p.x < 144. ? 268435986u : (p.x < 152. ? 2560203091u : (p.x < 160. ? 286820488u : (p.x < 168. ? 17825826u : 0u))))))))))))))))))))) : v;
	v = p.y == 65. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 536870912u : (p.x < 48. ? 9012u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286261248u : (p.x < 104. ? 286331153u : (p.x < 112. ? 17895697u : (p.x < 120. ? 1048576u : (p.x < 128. ? 17900066u : (p.x < 136. ? 321991200u : (p.x < 144. ? 17891347u : (p.x < 152. ? 2560115200u : (p.x < 160. ? 573994274u : (p.x < 168. ? 35651602u : 0u))))))))))))))))))))) : v;
	v = p.y == 64. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 78404u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286261248u : (p.x < 104. ? 571543825u : (p.x < 112. ? 286331426u : (p.x < 120. ? 17895696u : (p.x < 128. ? 18948640u : (p.x < 136. ? 554762240u : (p.x < 144. ? 17829905u : (p.x < 152. ? 0u : (p.x < 160. ? 591614738u : (p.x < 168. ? 1118498u : 0u))))))))))))))))))))) : v;
	v = p.y == 63. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 279632u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286326784u : (p.x < 104. ? 571543825u : (p.x < 112. ? 286331442u : (p.x < 120. ? 269554193u : (p.x < 128. ? 19014160u : (p.x < 136. ? 0u : (p.x < 144. ? 286326784u : (p.x < 152. ? 4113u : (p.x < 160. ? 573780752u : (p.x < 168. ? 805376273u : 0u))))))))))))))))))))) : v;
	v = p.y == 62. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 148496u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286330880u : (p.x < 104. ? 571543553u : (p.x < 112. ? 572662306u : (p.x < 120. ? 553652753u : (p.x < 128. ? 19014144u : (p.x < 136. ? 65536u : (p.x < 144. ? 286261248u : (p.x < 152. ? 268439825u : (p.x < 160. ? 20066833u : (p.x < 168. ? 16u : 0u))))))))))))))))))))) : v;
	v = p.y == 61. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 1327872u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 269484032u : (p.x < 104. ? 286331152u : (p.x < 112. ? 321982737u : (p.x < 120. ? 554766625u : (p.x < 128. ? 287449601u : (p.x < 136. ? 0u : (p.x < 144. ? 286261248u : (p.x < 152. ? 17u : (p.x < 160. ? 19014160u : 0u)))))))))))))))))))) : v;
	v = p.y == 60. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 4464896u : (p.x < 56. ? 0u : (p.x < 64. ? 196608u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286261248u : (p.x < 104. ? 286331153u : (p.x < 112. ? 286331154u : (p.x < 120. ? 286331169u : (p.x < 128. ? 287522818u : (p.x < 136. ? 17u : (p.x < 144. ? 287309824u : (p.x < 152. ? 272u : (p.x < 160. ? 2167297u : (p.x < 168. ? 1u : 0u))))))))))))))))))))) : v;
	v = p.y == 59. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 338755584u : (p.x < 56. ? 3u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 17825792u : (p.x < 104. ? 286327057u : (p.x < 112. ? 268505361u : (p.x < 120. ? 286331170u : (p.x < 128. ? 572784657u : (p.x < 136. ? 290u : (p.x < 144. ? 287309824u : (p.x < 152. ? 0u : (p.x < 160. ? 65792u : (p.x < 168. ? 268435456u : 0u))))))))))))))))))))) : v;
	v = p.y == 58. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 139569u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 285212672u : (p.x < 104. ? 286331153u : (p.x < 112. ? 286331153u : (p.x < 120. ? 286331426u : (p.x < 128. ? 858062914u : (p.x < 136. ? 1u : (p.x < 144. ? 17825792u : (p.x < 152. ? 0u : (p.x < 160. ? 536936704u : (p.x < 168. ? 268435456u : 0u))))))))))))))))))))) : v;
	v = p.y == 57. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 65792u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 268435456u : (p.x < 104. ? 285282577u : (p.x < 112. ? 286265617u : (p.x < 120. ? 286331442u : (p.x < 128. ? 1245234u : (p.x < 136. ? 0u : (p.x < 144. ? 570425344u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 1u : 0u))))))))))))))))))))) : v;
	v = p.y == 56. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286261248u : (p.x < 104. ? 269488401u : (p.x < 112. ? 286331153u : (p.x < 120. ? 287445282u : (p.x < 128. ? 4675u : (p.x < 136. ? 0u : (p.x < 144. ? 301989888u : (p.x < 152. ? 0u : (p.x < 160. ? 1048576u : (p.x < 168. ? 1u : 0u))))))))))))))))))))) : v;
	v = p.y == 55. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 3145728u : (p.x < 64. ? 287322112u : (p.x < 72. ? 2u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 286261248u : (p.x < 104. ? 269484305u : (p.x < 112. ? 286331154u : (p.x < 120. ? 823202065u : (p.x < 128. ? 572662340u : 0u)))))))))))))))) : v;
	v = p.y == 54. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 143360u : (p.x < 72. ? 16u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 285212672u : (p.x < 104. ? 285278481u : (p.x < 112. ? 286331392u : (p.x < 120. ? 823202082u : (p.x < 128. ? 304227123u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 33u : 0u)))))))))))))))))))))) : v;
	v = p.y == 53. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 536887568u : (p.x < 72. ? 273u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 268435456u : (p.x < 104. ? 0u : (p.x < 112. ? 286401056u : (p.x < 120. ? 554766609u : (p.x < 128. ? 1118803u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 16u : 0u)))))))))))))))))))))) : v;
	v = p.y == 52. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 838861088u : (p.x < 72. ? 290u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286335232u : (p.x < 120. ? 303173905u : (p.x < 128. ? 1184306u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 65552u : (p.x < 168. ? 1179648u : 0u))))))))))))))))))))) : v;
	v = p.y == 51. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 4928u : (p.x < 72. ? 17891346u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286331136u : (p.x < 120. ? 572662033u : (p.x < 128. ? 4370u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 256u : (p.x < 168. ? 65536u : 0u))))))))))))))))))))) : v;
	v = p.y == 50. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 536875026u : (p.x < 72. ? 1118208u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286331136u : (p.x < 120. ? 1110581521u : (p.x < 128. ? 19u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 4096u : (p.x < 168. ? 268574720u : 0u))))))))))))))))))))) : v;
	v = p.y == 49. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 23u : (p.x < 72. ? 17825792u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286331136u : (p.x < 120. ? 1110647057u : (p.x < 128. ? 20u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 16777472u : (p.x < 176. ? 1048576u : 0u)))))))))))))))))))))) : v;
	v = p.y == 48. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 3u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286331136u : (p.x < 120. ? 842211601u : (p.x < 128. ? 19u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 131072u : (p.x < 168. ? 318767104u : (p.x < 176. ? 16777216u : (p.x < 184. ? 17u : 0u))))))))))))))))))))))) : v;
	v = p.y == 47. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 268435456u : (p.x < 64. ? 1u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 286330880u : (p.x < 120. ? 857874705u : (p.x < 128. ? 19u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 2097152u : (p.x < 168. ? 16777216u : (p.x < 176. ? 0u : (p.x < 184. ? 322u : (p.x < 192. ? 1u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 46. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 20u : (p.x < 72. ? 285212672u : (p.x < 80. ? 286331153u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 304222208u : (p.x < 120. ? 590484001u : (p.x < 128. ? 3u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 3350528u : (p.x < 192. ? 256u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 45. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 23u : (p.x < 72. ? 286326784u : (p.x < 80. ? 554766592u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 572653568u : (p.x < 120. ? 860037666u : (p.x < 128. ? 1u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 1052944u : (p.x < 176. ? 0u : (p.x < 184. ? 3145728u : 0u))))))))))))))))))))))) : v;
	v = p.y == 44. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 70000u : (p.x < 72. ? 286261248u : (p.x < 80. ? 17895697u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 572653568u : (p.x < 120. ? 590557986u : (p.x < 128. ? 17u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 16777216u : 0u))))))))))))))))))))))) : v;
	v = p.y == 43. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 1120384u : (p.x < 72. ? 286331152u : (p.x < 80. ? 17961489u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 590544896u : (p.x < 120. ? 573711154u : (p.x < 128. ? 17u : 0u)))))))))))))))) : v;
	v = p.y == 42. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 1538048u : (p.x < 72. ? 286331136u : (p.x < 80. ? 2232865u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 858988544u : (p.x < 120. ? 571683618u : (p.x < 128. ? 268435474u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 1048576u : (p.x < 184. ? 4096u : 0u))))))))))))))))))))))) : v;
	v = p.y == 41. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 311001600u : (p.x < 72. ? 287379472u : (p.x < 80. ? 1184289u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 590491648u : (p.x < 120. ? 287449634u : (p.x < 128. ? 268435474u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 256u : 0u)))))))))))))))))))))) : v;
	v = p.y == 40. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 948109312u : (p.x < 72. ? 554696977u : (p.x < 80. ? 1122594u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 572661760u : (p.x < 120. ? 19010338u : (p.x < 128. ? 34603008u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 17891600u : (p.x < 184. ? 65536u : 0u))))))))))))))))))))))) : v;
	v = p.y == 39. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 2004877312u : (p.x < 72. ? 286261523u : (p.x < 80. ? 74273u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 572661760u : (p.x < 120. ? 20062754u : (p.x < 128. ? 52428800u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 286331136u : (p.x < 184. ? 69633u : 0u))))))))))))))))))))))) : v;
	v = p.y == 38. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 1731198976u : (p.x < 72. ? 286326802u : (p.x < 80. ? 139809u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 590479360u : (p.x < 120. ? 17969698u : (p.x < 128. ? 35651584u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 268435456u : (p.x < 176. ? 286331152u : (p.x < 184. ? 17895440u : (p.x < 192. ? 268435456u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 37. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 2033188864u : (p.x < 72. ? 286261249u : (p.x < 80. ? 70177u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 590479360u : (p.x < 120. ? 1122850u : (p.x < 128. ? 2228224u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 287309824u : (p.x < 176. ? 286396689u : (p.x < 184. ? 16842769u : 0u))))))))))))))))))))))) : v;
	v = p.y == 36. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 2000683008u : (p.x < 72. ? 286261249u : (p.x < 80. ? 2u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 573636608u : (p.x < 120. ? 1192482u : (p.x < 128. ? 1114112u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 286326784u : (p.x < 176. ? 286335249u : (p.x < 184. ? 269549568u : 0u))))))))))))))))))))))) : v;
	v = p.y == 35. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 1197473792u : (p.x < 72. ? 571473920u : (p.x < 80. ? 2u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 573636608u : (p.x < 120. ? 1258274u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 286326784u : (p.x < 176. ? 17965329u : (p.x < 184. ? 286326784u : (p.x < 192. ? 1u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 34. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 595591168u : (p.x < 72. ? 553648128u : (p.x < 80. ? 3u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 572522496u : (p.x < 120. ? 2306867u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 286326784u : (p.x < 176. ? 17895697u : (p.x < 184. ? 268435456u : (p.x < 192. ? 1u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 33. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 326172672u : (p.x < 72. ? 1u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 570425344u : (p.x < 120. ? 213794u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 286326784u : (p.x < 176. ? 4369u : (p.x < 184. ? 268435472u : (p.x < 192. ? 2u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 32. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 21102592u : (p.x < 72. ? 16777217u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 553648128u : (p.x < 120. ? 13107u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 286261248u : (p.x < 176. ? 1u : (p.x < 184. ? 286261248u : (p.x < 192. ? 1u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 31. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 557973504u : (p.x < 72. ? 1u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 536870912u : (p.x < 120. ? 274u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 17825792u : (p.x < 176. ? 1u : (p.x < 184. ? 554696704u : 0u))))))))))))))))))))))) : v;
	v = p.y == 30. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 288423936u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 285212672u : 0u))))))))))))))))))))))) : v;
	v = p.y == 29. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 288555008u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 35655680u : 0u))))))))))))))))))))))) : v;
	v = p.y == 28. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 18022400u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 0u : (p.x < 192. ? 0u : 34603008u)))))))))))))))))))))))) : v;
	v = p.y == 27. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 19070976u : 0u)))))))) : v;
	v = p.y == 26. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 36831232u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 1048576u : (p.x < 192. ? 0u : 69632u)))))))))))))))))))))))) : v;
	v = p.y == 25. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 287444992u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 0u : (p.x < 192. ? 0u : 512u)))))))))))))))))))))))) : v;
	v = p.y == 24. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 1187840u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 0u : (p.x < 152. ? 0u : (p.x < 160. ? 0u : (p.x < 168. ? 0u : (p.x < 176. ? 0u : (p.x < 184. ? 0u : (p.x < 192. ? 0u : 256u)))))))))))))))))))))))) : v;
	v = p.y == 23. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 2236416u : 0u)))))))) : v;
	v = p.y == 22. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 69888u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 0u : (p.x < 136. ? 0u : (p.x < 144. ? 256u : 0u)))))))))))))))))) : v;
	v = p.y == 21. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 69632u : 0u)))))))) : v;
	v = p.y == 20. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 4096u : 0u)))))))) : v;
	v = p.y == 19. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 17825792u : 0u)))))))) : v;
	v = p.y == 18. ? 0u : v;
	v = p.y == 17. ? 0u : v;
	v = p.y == 16. ? 0u : v;
	v = p.y == 15. ? 0u : v;
	v = p.y == 14. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 4352u : 0u))))))))) : v;
	v = p.y == 13. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 0u : (p.x < 72. ? 2u : 0u))))))))) : v;
	v = p.y == 12. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 285212672u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 0u : (p.x < 128. ? 268435456u : (p.x < 136. ? 1122866u : (p.x < 144. ? 0u : (p.x < 152. ? 857870336u : (p.x < 160. ? 858993459u : (p.x < 168. ? 554766883u : (p.x < 176. ? 858989106u : (p.x < 184. ? 9011u : 0u))))))))))))))))))))))) : v;
	v = p.y == 11. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 805437440u : (p.x < 72. ? 2u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 0u : (p.x < 112. ? 0u : (p.x < 120. ? 16777216u : (p.x < 128. ? 876884480u : (p.x < 136. ? 1145328964u : (p.x < 144. ? 536870947u : (p.x < 152. ? 1413760067u : (p.x < 160. ? 1146373461u : (p.x < 168. ? 1145324612u : (p.x < 176. ? 1163150404u : (p.x < 184. ? 590558276u : (p.x < 192. ? 546u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 10. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 807403520u : (p.x < 72. ? 36u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 0u : (p.x < 104. ? 554696704u : (p.x < 112. ? 287449634u : (p.x < 120. ? 857870353u : (p.x < 128. ? 1431585588u : (p.x < 136. ? 1146447461u : (p.x < 144. ? 1144127507u : (p.x < 152. ? 1717917013u : (p.x < 160. ? 1431660134u : (p.x < 168. ? 1431655765u : (p.x < 176. ? 1431725669u : (p.x < 184. ? 1145324629u : (p.x < 192. ? 588530739u : 3u)))))))))))))))))))))))) : v;
	v = p.y == 9. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 0u : (p.x < 48. ? 0u : (p.x < 56. ? 0u : (p.x < 64. ? 805306368u : (p.x < 72. ? 35u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 839909376u : (p.x < 104. ? 1716794180u : (p.x < 112. ? 1432774246u : (p.x < 120. ? 1431590501u : (p.x < 128. ? 1717986917u : (p.x < 136. ? 860182118u : (p.x < 144. ? 1412641281u : (p.x < 152. ? 2004313701u : (p.x < 160. ? 1718056823u : (p.x < 168. ? 1717986918u : (p.x < 176. ? 1449551462u : (p.x < 184. ? 1145328981u : (p.x < 192. ? 1128547396u : 35u)))))))))))))))))))))))) : v;
	v = p.y == 8. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 0u : (p.x < 32. ? 0u : (p.x < 40. ? 16847120u : (p.x < 48. ? 572522496u : (p.x < 56. ? 573780770u : (p.x < 64. ? 875770402u : (p.x < 72. ? 2u : (p.x < 80. ? 0u : (p.x < 88. ? 0u : (p.x < 96. ? 1412571392u : (p.x < 104. ? 1716938069u : (p.x < 112. ? 2004318070u : (p.x < 120. ? 2004318071u : (p.x < 128. ? 2004318071u : (p.x < 136. ? 876893798u : (p.x < 144. ? 1430537011u : (p.x < 152. ? 2004318054u : (p.x < 160. ? 1735882615u : (p.x < 168. ? 1717986918u : (p.x < 176. ? 1449551462u : (p.x < 184. ? 1431655765u : (p.x < 192. ? 20132932u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 7. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 858923008u : (p.x < 32. ? 1145324612u : (p.x < 40. ? 573780804u : (p.x < 48. ? 572662306u : (p.x < 56. ? 572662579u : (p.x < 64. ? 69632u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 857800704u : (p.x < 96. ? 1145320243u : (p.x < 104. ? 1717917013u : (p.x < 112. ? 2004318054u : (p.x < 120. ? 2004318071u : (p.x < 128. ? 2004318071u : (p.x < 136. ? 1431725671u : (p.x < 144. ? 1700091221u : (p.x < 152. ? 2004318054u : (p.x < 160. ? 2004318071u : (p.x < 168. ? 1717987191u : (p.x < 176. ? 1432774246u : (p.x < 184. ? 1431655765u : (p.x < 192. ? 2376772u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 6. ? (p.x < 8. ? 0u : (p.x < 16. ? 553648128u : (p.x < 24. ? 841097762u : (p.x < 32. ? 858993459u : (p.x < 40. ? 858993459u : (p.x < 48. ? 858993459u : (p.x < 56. ? 285496115u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 0u : (p.x < 88. ? 571613729u : (p.x < 96. ? 1145254707u : (p.x < 104. ? 1431655492u : (p.x < 112. ? 2003199589u : (p.x < 120. ? 2004318071u : (p.x < 128. ? 2004318071u : (p.x < 136. ? 2004318071u : (p.x < 144. ? 2004318071u : (p.x < 152. ? 2004318071u : (p.x < 160. ? 2004318071u : (p.x < 168. ? 1717991287u : (p.x < 176. ? 1431725670u : (p.x < 184. ? 1146443093u : (p.x < 192. ? 338904132u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 5. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 286326784u : (p.x < 32. ? 858989089u : (p.x < 40. ? 1127428915u : (p.x < 48. ? 1145324612u : (p.x < 56. ? 305345604u : (p.x < 64. ? 0u : (p.x < 72. ? 0u : (p.x < 80. ? 4369u : (p.x < 88. ? 554762240u : (p.x < 96. ? 1144206114u : (p.x < 104. ? 1431585860u : (p.x < 112. ? 1717986645u : (p.x < 120. ? 2004318054u : (p.x < 128. ? 2004318071u : (p.x < 136. ? 2004318071u : (p.x < 144. ? 2290644855u : (p.x < 152. ? 2004322440u : (p.x < 160. ? 2004318071u : (p.x < 168. ? 1717987191u : (p.x < 176. ? 1431660134u : (p.x < 184. ? 1145324613u : (p.x < 192. ? 78643u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 4. ? (p.x < 8. ? 0u : (p.x < 16. ? 268435456u : (p.x < 24. ? 286331153u : (p.x < 32. ? 572662033u : (p.x < 40. ? 858993186u : (p.x < 48. ? 1145324612u : (p.x < 56. ? 573780788u : (p.x < 64. ? 1118481u : (p.x < 72. ? 0u : (p.x < 80. ? 571473920u : (p.x < 88. ? 858993442u : (p.x < 96. ? 1145320243u : (p.x < 104. ? 1145324612u : (p.x < 112. ? 1431655765u : (p.x < 120. ? 1717986901u : (p.x < 128. ? 2004318071u : (p.x < 136. ? 2272753527u : (p.x < 144. ? 2290649224u : (p.x < 152. ? 2004318088u : (p.x < 160. ? 2004318071u : (p.x < 168. ? 1717986919u : (p.x < 176. ? 1431655766u : (p.x < 184. ? 1145324613u : (p.x < 192. ? 19088452u : 0u)))))))))))))))))))))))) : v;
	v = p.y == 3. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 286327056u : (p.x < 32. ? 572657937u : (p.x < 40. ? 858993442u : (p.x < 48. ? 1145324611u : (p.x < 56. ? 858993460u : (p.x < 64. ? 304226851u : (p.x < 72. ? 858918913u : (p.x < 80. ? 858989090u : (p.x < 88. ? 1127428915u : (p.x < 96. ? 1145324612u : (p.x < 104. ? 1431651396u : (p.x < 112. ? 1431655765u : (p.x < 120. ? 1717982549u : (p.x < 128. ? 2004318054u : (p.x < 136. ? 2004318071u : (p.x < 144. ? 2004318071u : (p.x < 152. ? 2004318071u : (p.x < 160. ? 1719105399u : (p.x < 168. ? 1717986918u : (p.x < 176. ? 1431655782u : (p.x < 184. ? 1431655765u : (p.x < 192. ? 877937732u : 4675u)))))))))))))))))))))))) : v;
	v = p.y == 2. ? (p.x < 8. ? 1179997253u : (p.x < 16. ? 1118499u : (p.x < 24. ? 571543825u : (p.x < 32. ? 1144205858u : (p.x < 40. ? 1145324612u : (p.x < 48. ? 1145324612u : (p.x < 56. ? 858993476u : (p.x < 64. ? 858993459u : (p.x < 72. ? 858993459u : (p.x < 80. ? 1144206131u : (p.x < 88. ? 1145324612u : (p.x < 96. ? 1431655492u : (p.x < 104. ? 1431655765u : (p.x < 112. ? 1431655765u : (p.x < 120. ? 1717982549u : (p.x < 128. ? 1986422374u : (p.x < 136. ? 2004318071u : (p.x < 144. ? 2004318071u : (p.x < 152. ? 2004318071u : (p.x < 160. ? 1717986918u : (p.x < 168. ? 1717986918u : (p.x < 176. ? 1717986918u : (p.x < 184. ? 1431655766u : (p.x < 192. ? 1414878549u : 1431651397u)))))))))))))))))))))))) : v;
	v = p.y == 1. ? (p.x < 8. ? 1432774246u : (p.x < 16. ? 1431655765u : (p.x < 24. ? 1431655765u : (p.x < 32. ? 1431655765u : (p.x < 40. ? 1431655765u : (p.x < 48. ? 1146443093u : (p.x < 56. ? 1145324612u : (p.x < 64. ? 1145324868u : (p.x < 72. ? 1145324612u : (p.x < 80. ? 1145324612u : (p.x < 88. ? 1162101828u : (p.x < 96. ? 1431655765u : (p.x < 104. ? 1431655765u : (p.x < 112. ? 1431655765u : (p.x < 120. ? 1700091221u : 1717986918u))))))))))))))) : v;
	v = p.y == 0. ? (p.x < 8. ? 1717986918u : (p.x < 16. ? 1717986918u : (p.x < 24. ? 1717986918u : (p.x < 32. ? 1431656038u : (p.x < 40. ? 1431721301u : (p.x < 48. ? 1431655765u : (p.x < 56. ? 1431655765u : (p.x < 64. ? 1431655765u : (p.x < 72. ? 1431655765u : (p.x < 80. ? 1431655765u : (p.x < 88. ? 1431655765u : (p.x < 96. ? 1431655765u : (p.x < 104. ? 1431655765u : (p.x < 112. ? 1431655765u : (p.x < 120. ? 1431655765u : (p.x < 128. ? 1717986917u : 1717986918u)))))))))))))))) : v;
    v = p.x >= 0. && p.x < 200. ? v : 0u;

    float i = float((v >> uint(4. * p.x)) & 15u);
    vec3 color = vec3(0.0039);
    color = i == 1. ? vec3(0.067) : color;
    color = i == 2. ? vec3(0.13) : color;
    color = i == 3. ? vec3(0.23) : color;
    color = i == 4. ? vec3(0.33) : color;
    color = i == 5. ? vec3(0.4) : color;
    color = i == 6. ? vec3(0.44) : color;
    color = i == 7. ? vec3(0.51) : color;
    color = i == 8. ? vec3(0.6) : color;
    color = i == 9. ? vec3(0.69) : color;
    
    return vec4(color, 1.0);
}

// Function 2756
sHit map( in vec3 pos )
{
    sHit sRes = createHit( 1e10, 0.0, pos );

	// player, in place in fact
    vec2 bent = getBent();
    
    // game
    vec3 p0 = pos;    
    // bending    
    p0.x -= 1.4 * sin( 0.06 * p0.z * PI ) * bent.x;
    p0.y += 1.4 * sin( 0.06 * p0.z * PI ) * bent.y;
   
    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );
    
    pPlayer.xz *= rot(  0.3 * bent.x );
    pPlayer.yz *= rot( -0.3 * bent.y );
    // sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); // debug collider
    
	float rotY = -.3 * g_S.isPressedLeft + .3 * g_S.isPressedRight;
    float rotX = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;    
    pPlayer.xz *= rot( -0.02 * PI * bent.y + rotY -0.6 * PI );
    pPlayer.yz *= rot( -0.02 * PI * bent.x + rotX );
    // pPlayer.yz *= rot( -10.0*iTime ); // mothman
    pPlayer.y += 0.05;    
    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );
	sRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );
    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );
    
    vec3 pEnv = p0;
    pEnv.z += 3.0 * g_S.playerPos.y;
    pEnv.x -= 0.6;
    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -2, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );
    
    p0.z *= 0.6;
    p0.z += g_S.playerPos.y;
    
    vec3 p0Mod = p0;
    p0Mod.z = mod( p0.z + 0.6, 2.0 ) - 0.6;
                
    float playerCellID = floor( g_S.playerPos.y );
   
    // COIN start
    float cellID = floor( p0.z + 0.5 );
    
    float cellCoinRND = hash11( cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving    
    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); // gaps in coin placing: 2 gaps, 2 coins
    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); // head start
    float cellCoinCol = floor( 3.0 * cellCoinRND );
    
    if (cellCoinRND >= 0.0)
    {
        vec3 pCoin = p0Mod; 
        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );
        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );
        pCoin -= coinOffset;
        pCoin.z *= 2.0;
        pCoin.xz *= rot( 10.0 * iTime );
                
        if ( cellID > playerCellID )
            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );
        
        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )
        	sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );
    }    
       
    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); // skip rnd obstacle every second cell to make room for driving
    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );
    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); // head start
    float cellObsCol = floor( 3.0 * cellObsRND );

    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )
    {            
        vec3 obstacleOffset = vec3(
            -0.5 + cellObsCol,  
             0.2,
             0.0
        );

        // sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); // debug colider
        p0Mod -= obstacleOffset;
        p0Mod.z *= 2.0;
        p0Mod.xz *= rot( -0.5 * PI );
        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );
        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );
        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );
    }

    return sRes;
}

// Function 2757
vec2 map(vec3 rp){
    vec2 dis = vec2(50.0);

  
   dis = comp(dis,vec2(plane(rp-vec3(0,-1,0)).xy ));
  
  // dis = comp(dis,vec2(sphere(rp - vec3(lp),0.1),2.0));
      //dis = comp(dis,vec2(sphere(rp - vec3(lp2),0.1),2.0));
    
    
    
  
   
   

    
    rp+=vec3(0.8,0.5,-0.5);
    dis = comp(dis,vec2(sdApple(rp - vec3(0.0,0.0,-0.0),0.5),0.1));
    
  
    
  
    return dis;
}

// Function 2758
vec4 scene(vec2 p) {

    // Camera
    // ---------------------------
    vec3 camPos = 4.0 * vec3(cos(iTime*0.2), 0.0, sin(iTime*0.2));
    camPos += vec3(0.0, 0.75 + 0.5*cos(iTime*0.5), 0.0);
    vec3 lookTarget = vec3(0.0);

    vec3 movement = vec3(2.0, 0.0, -iTime*2.0);
    camPos += movement;
    lookTarget += movement;

    vec3 nvCamFw = normalize(lookTarget - camPos);

    mat4 clipToWorld = getClipToWorld(IMAGE_ASPECT_WIDTH_OVER_HEIGHT, nvCamFw);
    vec3 nvCamDir = nvDirFromClip(clipToWorld, p);

    // Portal geometry
    // ---------------------------
    float a = subrectSize();

    vec3 nv00 = nvDirFromClip(clipToWorld, vec2(-a,-a));
    vec3 nv10 = nvDirFromClip(clipToWorld, vec2( a,-a));
    vec3 nv01 = nvDirFromClip(clipToWorld, vec2(-a, a));
    vec3 nv11 = nvDirFromClip(clipToWorld, vec2( a, a));

    float minY = -PLANE_DEPTH + 2.5*BOUNDARY_RADIUS;
    float tL = hitPlane(vec3(0.0,  minY, 0.0),  NV_PLANE_N, camPos, nv00);
    float tU = hitPlane(vec3(0.0, -minY, 0.0), -NV_PLANE_N, camPos, nv01);
    float tPortal = min(12.0, min(
        mix(MAX_DIST, tL, step(0.0, tL)),
        mix(MAX_DIST, tU, step(0.0, tU))
    ));

    vec3 q00 = camPos + tPortal*nv00;
    vec3 q10 = camPos + tPortal*nv10;
    vec3 q01 = camPos + tPortal*nv01;
    vec3 q11 = camPos + tPortal*nv11;

    vec3 portalVX = normalize(q10 - q00);
    vec3 portalVY = normalize(q01 - q00);
    vec3 portalVZ = cross(portalVX, portalVY);

    q00 += BOUNDARY_RADIUS * ( -portalVX - portalVY );
    q10 += BOUNDARY_RADIUS * (  portalVX - portalVY );
    q01 += BOUNDARY_RADIUS * ( -portalVX + portalVY );
    q11 += BOUNDARY_RADIUS * (  portalVX + portalVY );

    // Light placement
    // ---------------------------
    vec3 lightPos = 0.5*(q01 + q11) + 1.0*portalVY + 5.0*portalVZ;

    // Render scene
    // ---------------------------
    vec3 sceneColor = vec3(0.0);

    float didHitPortal;
    vec3 hitPos;
    hitObject(camPos, nvCamDir, q00,q10,q11,q01, didHitPortal, hitPos);

    if (didHitPortal > 0.5) {

        vec3 n = normalQuadBoundary(q00,q10,q11,q01, hitPos);
        vec3 nvRefl = normalize(reflect( hitPos-camPos, n ));

        vec3 diffuse;
        vec3 specular;
        computeLighting(
            0.2, 0.8, 20.0,
            vec3(1.0), 0.4*vec3(1.0, 0.5, 1.0),
            n, normalize(lightPos - hitPos), normalize(camPos - hitPos),
            diffuse, specular
        );
        vec3 matColor = diffuse + specular;

        vec3 terrainColor;
        terrainAndSky(
            hitPos, nvRefl, lightPos, POM_QUALITY_REFL,
            q00,q10,q11,q01,
            terrainColor
        );

        sceneColor = matColor + 0.8*terrainColor;

    } else {

        terrainAndSky(
            camPos, nvCamDir, lightPos, POM_QUALITY,
            q00,q10,q11,q01,
            sceneColor
        );

    }

    return vec4(clamp(sceneColor, 0.0, 1.0), 1.0);
}

// Function 2759
float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

// Function 2760
float dist(vec2 p, vec2 b){
    
    //return sdBox(p, b);
    
    p = abs(p);
    p -= b;
    return smax(p.x, p.y, .125);
    
}

// Function 2761
vec3 scene(vec3 p)
{
    p.z += iTime*50.0;
    
    vec3 d = MAX_VEC;
    float n = fbm21Tex(p.xz*0.025);
    d = min3(d, vec3(.0,n, 
        p.y + n*7.0
    ));
    
    
    vec3 cp = p;
    cp.z -= 400.0;
    float c = pMod(cp.z, 400.0);
    cp.x += mod(c, 2.0) == 0.0 ? 60.0 : -30.0;
    
    cp.y += 10.0;
    d = min3(d, vec3(.0,.0, column(cp, 50.0, 4.0)));
    d = min3(d, vec3(1.,.0, length(vec3(cp.x,cp.y-57.0,cp.z)) - 4.0));
    
    vec3 cbp = p;
    cbp.y -= 10.0;
    return d;
}

// Function 2762
mat cmap(in ray r, in hit h) {
    vec3 f = tex(iChannel0, r.d).rgb*1.5;
    return mat(
    	vec3(0.),
        f, //gamma correct
    	vec2(0.), //not applicable
        vec2(0.), //not implemented
        -1., 0., _cmap.d);
}

// Function 2763
float scene (vec3 p)
{
   //return udBox(cos(p)*0.1);
   return sphere(cos(p)*1.0);
   //return sphere(p);
}

// Function 2764
float intersectSDF(float a,float b){
	return max(a,b);
}

// Function 2765
vec4 DistanceToBoundaryAndColor(vec2 p)
{
    vec4 ret = vec4(10000.0, 0.0, 0.0, 0.0);
    
    #if SCENE == 1 || SCENE == 2
    {
        float dist = -(length(p) - 0.4);
        if (dist > -0.01)
        {
        	float angle = atan(p.y, p.x);
            if (angle < 0.0)
                angle += c_pi * 2.0;
            
            #if SCENE == 2
                float percent = angle / (2.0 * c_pi);
            	float shade = sin(angle * 10.0);
            	vec3 color = smoothRainbow(percent) * shade;
            #else
            	float shade = sin(angle * 10.0);
            	vec3 color = vec3(shade, shade, shade);           
            #endif
        	ret.x = dist;
        	ret.yzw = color;
        }
        else
        {
            ret = vec4(0.0, 0.8, 0.8, 0.8);
        }
        
    }
    #elif SCENE == 3
    {
    	LineTest(p, vec2(0.0, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);
    	LineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);
    	LineTest(p, vec2(-0.3, 0.2), vec2(0.0, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);
    }
    #elif SCENE == 4
    {
    	LineTest(p, vec2(0.3, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);
    	LineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);
    	LineTest(p, vec2(-0.3, 0.2), vec2(-0.3, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);
    }    
    #elif SCENE == 5
    {
        CircleTest(p, vec3(0.0, -0.2, 0.03), vec3(1.0, 0.0, 0.0), ret);
        CircleTest(p, vec3(0.3, 0.2, 0.03), vec3(0.0, 1.0, 0.0), ret);
        CircleTest(p, vec3(-0.3, 0.2, 0.03), vec3(0.0, 0.0, 1.0), ret);

        LineTest(p, vec2(-0.7, 0.4), vec2(-0.7, -0.4), vec3(0.0, 0.0, 0.0), vec3(0.8, 0.8, 0.8), ret); 
        LineTest(p, vec2( 0.7, 0.4), vec2( 0.7, -0.4), vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), ret); 
    }
    #endif
    
    return ret;
}

// Function 2766
vec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )
{
	return mix(v2, v1, step(v2.x,v1.x));
}

// Function 2767
float mapLeaf( in vec3 p )
{
    p -= vec3(-1.8,0.6,-0.75);
    
    p = mat3(0.671212, 0.366685, -0.644218,
            -0.479426, 0.877583,  0.000000,
             0.565354, 0.308854,  0.764842)*p;
 
    p.y += 0.2*exp(-abs(2.0*p.z) );
    
    
    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);// + 1.0*sin(5.0*p.x)*sin(5.0*p.z);
    float rr = sin( ph );
    rr = rr*rr;    
    rr = rr*rr;    
    p.y += 0.005*rr;
    
    float r = clamp((p.x+2.0)/4.0,0.0,1.0);
    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;
    
    rr = sin( ph*2.0 );
    rr = rr*rr;    
    rr *= 0.5+0.5*sin( p.x*12.0 );

    float ri = 0.035*rr;
    
    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );

    float d2 = p.y-0.02;
    d = smax( d, -d2, 0.02 );
    
    return d;
}

// Function 2768
vec4 Map(vec3 coord)
{
    // Lock sphere to the origin
    // Also displace surface for active cells
    float dist = length(coord) - SPHERE_RADIUS;
    
    // Define color variable
    vec3 rgb = vec3(0.0, 0.0, 0.0);
    
    // Consider per-ray cylinder extension at random angles; should
    // produce pretty noise-driven latticework
    
    // Project sphere surface onto the plane
    float A = 4.0 * 3.14159 * (SPHERE_RADIUS * SPHERE_RADIUS);
    #if PROJ_TYPE == 0
    // Uses a modified stereographic projection: 
    // https://wikipedia.org/Stereographic_projection
    vec2 uv = vec2(coord.x / (SPHERE_RADIUS - coord.y), // Change axes here for cool image effects
                   coord.z / (SPHERE_RADIUS - coord.y)) / A;    
    
    // Align projection to the center of buffer-A
    uv += vec2(0.5, 0.5);
    
    #else
    // Uses orthographic projection through (x, y)
    // Simple translation is used to map the close hemisphere (-z)
    // onto a second circle adjacent to the circle mapped for the
    // far hemisphere (+z)
    vec2 uv = vec2((coord.x / SPHERE_RADIUS) / 4.0, 
                   (coord.y / SPHERE_RADIUS) / 4.0);
    if (coord.z < 0.0)
    {
     	uv.x += 0.5;   
    }
    
    // Align projection to the left half of buffer-A
    uv += vec2(0.25, 0.5);

    #endif
        
    // Cache cell status for the given texture coordinates
    rgb = textureLod(iChannel0, uv, 0.0).xyz;
    
    #if PROJ_TYPE == 1
    #ifdef CLEAN_ORTHO
    float circDist = length(vec2(coord.x / SPHERE_RADIUS, 
                    			 coord.y / SPHERE_RADIUS));
    float thresh = CLEAN_ORTHO_THRESH;
    vec3 baseRGB = rgb;
    rgb *= mix(rgb, rgb * 0.0, (circDist - thresh) / (1.0 - thresh)) / CLEAN_ORTHO_GRAD;
    rgb = min(rgb, baseRGB);
    #endif
    #endif
    
    // Return a scaled distance + a color
    return vec4(dist, rgb);
}

// Function 2769
float quad_dist(vec2 uv, vec2 p[5], float scl) {
    
    float d_quad = 1e5;
    
    for (int i=0; i<4; ++i) {
        d_quad = min(d_quad, length(uv-p[i])/scl-3.0);
        d_quad = min(d_quad, seg_dist(p[i+1]-p[i], uv-p[i])/scl-0.5);
    }
    
    return d_quad;
    
}

// Function 2770
float	scene(vec3 p)
{
	float scale = 1.0;
    float r2,k;
    a = cos( .8*(p.z *.5) +t*1.5);
    p.y+=-.5;
    p.x+=.5;
    rotate(p.yx, (a) );
    ss = p;
    for( int i=0; i<5; i++ )
	{
        p.xyz = 1.0 - 2.0*fract(0.5*p.xyz+0.5);
        p*=1.12;
		r2 = sdTorus(p, vec2(.21,.12) );
        if(r2 > 5./float(i) )
            break;
		k = 1./(r2);
		p     *= k;
		scale *= k;
	}
	ss=p*(fract(ss)+.5);
    #ifndef	SEE_ALL
    return (-.085*(1.-sin(t))+0.25*(abs(p.x))/scale);
    #else
    return (-.085*(1.-sin(t))+0.25*(abs(p.x)+length(fract(ss.xz)-.5 )*.25)/scale);
    #endif
}

// Function 2771
float map( in vec3 pos )
{
    return sdCylinder(pos, vec3(-0.2,-0.3,-0.1), vec3(0.3,0.3,0.4), 0.2 );
}

// Function 2772
float scene(vec3 p) {
  if (length(p) > 1.) return length(p)-.8;
  vec4 x=vec4(p,1),
    f00=sin(x*mat4(-.3868,-.3093,-3.6954,2.4484,2.9302,4.8617,-3.207,6.3733,2.2207,1.2229,.7529,6.8923,-3.1901,-.3837,1.5075,5.9402)),
    f01=sin(x*mat4(2.227,-4.2235,3.1825,-2.8738,2.8828,1.0962,-1.0205,-3.9004,.2729,2.2675,.3552,2.3156,2.8468,-1.5383,.3601,1.8656)),
    f02=sin(x*mat4(-3.8048,3.5553,.9229,-3.1861,1.1408,3.0575,-1.336,.4931,2.197,2.0008,2.779,5.4465,-3.4189,1.3219,-2.3883,6.8088)),
    f03=sin(x*mat4(1.5257,-1.055,2.9919,7.808,-1.137,2.9138,2.1236,7.3404,.7918,3.7754,3.0364,-5.4108,-1.8087,-2.2495,3.7229,-9.2978)),
    f10=sin(mat4(-1.6913,-.0959,.2735,-.3904,-.651,-.1255,.0583,-.0941,1.6139,.2921,1.8381,-.0908,.0618,.757,.1365,.4802)*f00+mat4(.9295,.0218,-.5439,.0632,.0274,-1.3497,1.2804,.1204,-.6763,-1.4529,.3309,-.5857,-1.304,.0965,-.1969,-1.0102)*f01+mat4(-.6822,-.9195,.0293,-.0609,.0599,.7242,-.4774,-.0324,-1.7268,1.272,-.8667,-.5048,-.496,.1862,-.7332,.7009)*f02+mat4(-.3983,.5965,.6669,-.0951,1.6562,.2926,-.7816,.6021,-1.0151,.3827,-.6505,-.3546,1.3494,-.4042,-.4411,.0519)*f03+vec4(5.716,10.3182,10.2066,-8.9917)),
    f11=sin(mat4(.284,-.7388,.1601,-.2715,.2325,-.3568,.0246,.0194,.2836,.1522,1.4394,1.2751,-.1915,.2514,-.6674,.0318)*f00+mat4(.0967,-.5026,-.2551,.3242,-.0561,-.1559,1.0709,-1.2348,-.7734,-.0243,-.9091,.3451,.5743,.2138,-1.0541,.1954)*f01+mat4(-.3602,.4102,-.8794,.2368,-.2009,-.1606,-.9775,.5528,.4353,.8922,.0377,-.0896,-1.2281,-.5368,-1.3074,.0029)*f02+mat4(-.0411,.476,-2.6588,.6194,.7807,.1155,-1.6035,-.451,-.2309,-.1062,.0774,.2069,-.5881,.4376,1.1162,-.0273)*f03+vec4(3.7295,9.7756,12.0655,-3.3911)),
    f12=sin(mat4(.0837,-1.3587,.1994,-.2044,.032,-.3337,.1394,.2447,-.5279,1.0545,.7045,-.2983,.3696,-1.0726,-.5732,-.8808)*f00+mat4(-.073,-.6024,.0176,.3368,-.6668,2.3095,.6353,-.8166,-.4683,.9371,.7021,-.0215,-.3795,-.9897,.2481,-.5512)*f01+mat4(.0322,-.5374,.1498,.0323,-.15,-.1114,.1717,.1475,.3255,.0496,.0523,-.0843,.054,.3394,.0607,.2032)*f02+mat4(-.1398,.6035,-.4696,-.3387,-.2222,1.1782,.5465,-.4398,.1523,.1476,-.2336,.0552,-.0015,-.0994,-.4187,-.0455)*f03+vec4(10.0163,-5.5725,-7.7328,-4.833)),
    f13=sin(mat4(.6007,-.0013,-1.1219,1.423,.1146,.1131,.2523,-.5636,-.8499,-.6252,.1626,-.0608,1.4198,.0452,-1.2241,-.0682)*f00+mat4(-.3574,.1441,.4606,-.0096,.6046,2.165,-.9807,.3567,1.4935,.786,-.7735,-1.4983,.4994,-.1076,.2014,.6609)*f01+mat4(-.4584,.5424,-1.3716,-.2497,-.8609,-.6586,1.288,-.0419,.8555,-.1137,-.2837,-.6799,.7374,.3189,.0137,.4288)*f02+mat4(-.5342,-1.1562,1.116,-.6443,-.6292,-.0923,-1.1424,.0341,.4876,-.1602,-.9543,-.0979,-.6852,.5463,-1.2446,.0356)*f03+vec4(8.5916,-9.2282,-8.0499,5.671)),
    f20=sin(mat4(-.0383,.0365,-.0323,-.0883,.0615,.0232,-.1156,-.2517,-.0023,.0654,.1224,.1084,.0294,-.0633,-.6738,-.0164)*f10+mat4(-.0069,.1218,.2183,-.0724,.0842,-.0751,.4163,.1254,-.0483,.1346,.0443,-.0909,-.0138,-.115,.5339,.098)*f11+mat4(-.0699,-.149,-.2859,-.1033,-.0912,.0744,-.1005,.0462,-.0197,.2144,-.2707,.287,-.0595,-.0447,.1011,.2324)*f12+mat4(.0445,-.0098,.0714,.0006,.0235,-.0973,.1593,-.0058,.0822,-.0386,.0648,.1923,-.0867,.0194,.208,-.1175)*f13+vec4(-10.9812,-1.4774,5.7156,4.8039)),
    f21=sin(mat4(.0269,.091,.1355,-.1044,.0683,-.008,1.9334,.0958,-.1325,.0407,-.0578,-.083,.2514,.1306,1.197,-.0389)*f10+mat4(-.3938,.0217,1.6895,.1827,-.4492,.1132,-.9866,.2759,-.1462,.0492,.3724,-.0193,.2356,.0516,-.2753,-.3186)*f11+mat4(-1.1359,-.0996,-1.2912,-.4479,-.0688,-.0394,-.7566,.3698,.4597,.018,.8762,-.3677,-.539,.0613,.1883,1.3663)*f12+mat4(-.3314,.0288,1.6371,.2062,.2072,-.01,-.8698,-.0249,.031,.0309,-1.5668,.1693,-.1224,.0,1.8259,.0147)*f13+vec4(6.9884,-7.8324,-6.8888,.7151)),
    f22=sin(mat4(.0497,.0173,-.2473,.1465,-.1452,-.0051,.4827,-.0739,-.0196,-.0076,.7819,-.0322,.287,-.0049,-1.1028,-.0765)*f10+mat4(.3765,-.0324,.2596,-.0458,.1575,.0063,-.9675,-.066,.0179,-.0239,-.4353,-.006,-.0894,-.0064,-.3605,-.2824)*f11+mat4(.7928,.0088,-.5974,-.0483,-.0998,.007,-.6523,-.1151,1.0574,-.0151,2.0772,-.0529,-.055,-.0233,1.7622,-.1077)*f12+mat4(-.092,.0096,.4234,-.1044,.0454,.0071,.7878,-.1829,.0397,.0057,.1408,-.0573,-.2548,-.0136,-.0841,-.1139)*f13+vec4(.2837,-10.9884,-4.3891,7.8282)),
    f23=sin(mat4(-.2772,.053,-.0167,-.0061,-.0517,.0541,.0491,-.0474,.602,.0258,.1042,-.0461,-.5157,.0125,-.1683,-.0265)*f10+mat4(1.1976,-.1604,.0561,.0152,.8858,-.3835,-.0771,-.0165,.572,.0173,.0348,-.0433,-.4598,.2862,-.1717,.0711)*f11+mat4(2.2106,.2621,-1.0351,.051,.3927,-.3109,-.0869,-.017,-.592,.2738,.6449,.0666,.21,-1.2345,.0981,.1052)*f12+mat4(.7805,-.1584,-.0148,-.0712,-.2046,.1745,-.0914,.0503,-.3447,-.0956,-.0533,.0906,.0917,.1735,.036,.0148)*f13+vec4(2.2706,-.5216,5.4374,1.5639));
  return dot(vec4(-.4188,-.2921,.133,.2109),f20)+dot(vec4(.1279,.4421,.0036,-.1403),f21)+dot(vec4(-.1165,.33,-.0084,.1608),f22)+dot(vec4(-.0173,-.2252,.2478,.3179),f23)+.4407;
}

// Function 2773
vec3 GetSceneColourSecondary( const in C_Ray ray )
{
    C_HitInfo hitInfo;
    Raymarch(ray, hitInfo, 32, kNoTransparency);
                        
    vec3 cScene;

    if(hitInfo.vObjectId.x < 0.5)
    {
        cScene = GetSkyGradient(ray.vDir);
    }
    else
    {
        C_Surface surface;        
        surface.vNormal = GetSceneNormal(hitInfo.vPos, kNoTransparency);

        C_Material material = GetObjectMaterial(hitInfo);

        // use sky gradient instead of reflection
        surface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));
        
        material.fTransparency = 0.0;

        // apply lighting
        cScene = ShadeSurface(ray, hitInfo, surface, material);
    }

    ApplyAtmosphere(cScene, ray, hitInfo);

    return cScene;
}

// Function 2774
float verticalDistance(vec2 p, vec2 p0, vec2 p1)
{
    if(p.x < min(p0.x, p1.x) || p.x > max(p0.x, p1.x))
        return 100000000.0*sign(p1.x-p0.x);
    
    float h = p.x-p0.x;
    float slope = (p1.y-p0.y)/(p1.x-p0.x);
    float l = p.y-h*slope - p0.y;
    
    return l*sign(p1.x-p0.x);
}

// Function 2775
vec2 map(in vec3 l, in box b) {
	mat3 o = mat3(v30, nrm(l, b) + eps, v30);
    basis(o[1], o[0], o[2]);
    vec3 r = l * o;
    return r.xz;
}

// Function 2776
vec2 distModuleObject(in vec3 p)
{
	p.y -= MODULE_HEIGHT;
	return vec2(distSquaredCylinder(p,vec3(MODULE_SIZE,MODULE_HEIGHT,MODULE_SIZE),MODULE_RADIUS),3.0);
}

// Function 2777
float map(vec3 p) {
    return min(max(-sdSphere(p, 7.5 * scale), sdBox(p, vec3(6.0) * scale)), -sdSphere(p, 25.0 * scale));
    //return max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));
}

// Function 2778
vec2 DistanceToObject(vec3 p)
{
    float dist = 1000000.0;
    float currentThick = 8.0;
    float harmonicTime = spinTime*0.125*3.14159*4.0;
    // make 15 discs inside each other
    for (int i = 0; i < 15; i++)
    {
        dist = min(dist, Disc(p, currentThick));
        p = RotateX(p, harmonicTime);
        p = RotateZ(p, harmonicTime);
        // scale down a level
        currentThick *= thickSpace;
    }
    vec2 distMat = vec2(dist, 0.0);
    // ball in center
    distMat = matMin(distMat, vec2(length(p) - 0.45, 6.0));
    return distMat;
}

// Function 2779
float GetDist(vec3 p,out float objID, out float glowDist, out float dC ) {
    p.xz *= Rot(T*.1);
    p.xy *= Rot(-sin(T*.1)*.5);
    glowDist = 1e10;
    objID = 1.0;
    float extands = S(0.8,-0.8,cos(T*.1));
    extands*= extands;
    float spacing = 0.7*extands,
        tmin = 0.0,
        tmax = 2.0;
    vec2 uv;
    float d = 1e10;
    dC = abs(p.y)-0.5;
    if ( dC < SURF_DIST ) {
        float dSpiral = spiralUV(p.xz,1.0,spacing,tmin,tmax,uv);
        dC = abs(dSpiral);
        if ( dSpiral < SURF_DIST ) {
            vec3 q = vec3(uv.x, p.y, uv.y ); // spiral UV space
            d = decoratedStick(q-vec3(.5,0.,0.),objID,glowDist);
        } 
    }
    return d;
}

// Function 2780
float scene(vec3 p) {
    return min(sphere(p), ground(p));
}

// Function 2781
vec3 map(in vec3 p)
{
    vec3 d = vec3(p.z+.25 ,-1,0);
    
    vec2 c =p.xy/9. + vec2(.5); 
    vec4 m =  texture(iChannel0,c);   
    if(any(greaterThan(c,R.xy)) || any(lessThan(c,vec2(0)))) m= vec4(.2);
    d=mmin(d,vec3(opExtrussion( p -vec3(0,0,.1), m.x*4., 0.2 ),m.w,m.z));
    d=mmin(d,vec3(opExtrussion( p, m.y*4., 0.4 ),m.w,m.z));
    
    return d;
}

// Function 2782
float PrTorusDf (vec3 p, float ri, float rc)
{
  vec2 q = vec2 (length (p.xy) - rc, p.z);
  return length (q) - ri;
}

// Function 2783
float heightmap(vec2 p)
{
 	float o = textureLod(iChannel1,(p)*0.0036,0.0).x;
    return 1.-o;
}

// Function 2784
float map(vec3 p) {
  vec3 n; vec2 uv; // Don't need these here - hopefully get optimized away.
  return polyhedron(p,n,uv);
}

// Function 2785
float map(vec3 p) {
    float d = _house <= 0. ? 5. : sdHouse(p) + .1  - _house * .1;
    if (_boat > 0.) d = opU(d, sdBoat(p) + .1  - _boat * .1);
    if (_spaceship > 0.) d = opU(d, sdSpaceship(p) + .1  - _spaceship * .1);
    if (_atmosphere > 0.) d = opU(d, sdAtmosphere(p) + .1 - _atmosphere * .1);
    
    //return d;
    float s = 1.;
    for (int i = 0; i < 4; ++i) {
        tFan(p.xz, 10.);
        p = abs(p);
        p -= _kifsOffset;
        
        p *= _kifsRot;
        s *= 2.;
    }
    
    return opSU(d, sdBox(p * s, vec3(s / 17.)) / s, .1);
}

// Function 2786
vec4 point_distance(int id, float r)
{
    vec4 X = ppos(id);
    float cd = sphere_intersection(ray, cpos, vec4(X.xyz,r));
    if(cd > 0.)
    {
        return vec4(cpos + cd*ray, zrange(cd));
    }
    else
    {
        return vec4(cpos + 1e8*ray, 1.+abs(cd));
    }
}

// Function 2787
float GetDistanceWineGlass( vec3 vPos )
{
    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);
    
    vec2 vSphOrigin = vec2(0,2.0);
    vec2 vSphPos = vPos2 - vSphOrigin;
    
    vec2 vClosest = vSphPos;
    
    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;
    vClosest = normalize(vClosest) * 0.6;
    
    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;
    
    vec2 vStemClosest = vPos2;
    vStemClosest.x = 0.0;    
    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);
    
    float fStemRadius = vStemClosest.y - 0.5;
    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;
    
    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;
        
    vec2 norm = normalize( vec2( 0.4, 1.0 ) );
    vec2 vBaseClosest = vPos2;
    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.025), norm ) - 0.2;
    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); 

    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);
    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);
    
    fDistance = max( fDistance, vSphPos.y - 0.5 );
        
    return fDistance;
}

// Function 2788
vec4 tonemapping(vec4 x)
{
    return ((x*(SHOULDER_STRENGTH*x+LINEAR_ANGLE*LINEAR_STRENGTH)+TOE_STRENGTH*TOE_NUMERATOR)/
            (x*(SHOULDER_STRENGTH*x+LINEAR_STRENGTH)+TOE_STRENGTH*TOE_DENOMINATOR)) - TOE_ANGLE;
}

// Function 2789
vec4 GetDistanceChaosTrendLogo(const in vec3 vPos)
{
	//initialize with material '4' and x/y UV plane
	vec4 vResult = vec4(10000.0, 4, vPos.x, vPos.y);
	//work out which cylinder segment vPos is in	
	float r =  SelectSegment(vPos, 8.0);
	//and rotate the arrow domain accordingly
	vec3 vChaosArrowDomain = RotateZ(vPos, r );
	//shift outwards from centre
	vChaosArrowDomain.y -=3.5;		
	float arrowDist = dChaosArrow(vChaosArrowDomain);					
	vResult.x = DistCombineUnion(vResult.x, arrowDist);	
	//remove inner cylinder
	float cyldist = GetDistanceCylinderZ(vPos, 1.4);	
	vResult.x = DistCombineSubtract(vResult.x, cyldist);	
	return vResult;
}

// Function 2790
vec3 CubeMap( sampler2D sam, in vec3 d )
{
    vec3 n = abs(d);

#if 0
    // sort components (small to big)    
    float mi = min(min(n.x,n.y),n.z);
    float ma = max(max(n.x,n.y),n.z);
    vec3 o = vec3( mi, n.x+n.y+n.z-mi-ma, ma );
    return texture( sam, .1*o.xy/o.z ).xyz;
#else
    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: 
              (n.y>n.x && n.y>n.z) ? d.zx/d.y:
                                     d.xy/d.z;
    return texture( sam, uv ).xyz;
    
#endif    
}

// Function 2791
float distanceToRect(vec3 rectExtents,vec3 rectCenter,vec3 point) {
	vec3 tPoint = point-rectCenter;
	return(length(max(abs(tPoint)-rectExtents,0.0)));
}

// Function 2792
float torusKnotSqDistance(float t, vec3 p, TorusKnotParameters tkp)
{
    return sq(torusKnot(t, tkp) - p);
}

// Function 2793
float sdfMinus(float a, float b) {
  return max(a, -b);
}

// Function 2794
float Scene( vec3 pos )
{
    float f = Sphere(vec3(-1,-1,0),1.,pos);
    f = min(f,Sphere(vec3(1,-1,0),1.,pos));
    f = min(f,Sphere(vec3(0,1,0),1.,pos));
    return f;
}

// Function 2795
vec3 color_tonemap_aces(vec3 col) {
  return clamp(((col * ((2.51 * col) + 0.03)) / ((col * ((2.43 * col) + 0.59)) + 0.14)), 0.0, 1.0);
}

// Function 2796
float DistanceField( vec3 pos )
{
	vec3 v = Voronoi(pos.xz);
	vec2 r = Rand(v.xy*4.0); // per-building seed
	
	float f = (.2+.3*r.y-v.z)*.5; //.7071; // correct for max gradient of voronoi x+z distance calc
	
	// random height
	float h = r.x; // v.xy is position of cell centre, use it as random seed
	h = mix(.2,2.0,pow(h,2.0));
	h = pos.y-h;

	// we get precision problems caused by the discontinuity in height
	// so clamp it near to the surface and then apply a plane at max height	
	h = max( min( h, .08 ), pos.y-2.0 );

//	f = max( f, h );
	if ( f > 0.0 && h > 0.0 )
		f = sqrt(f*f+h*h); // better distance computation, to reduce errors
	else
		f = max(f,h);
	
	f = min( f, pos.y ); // ground plane
	
	return f;
}

// Function 2797
vec2 map0ds(vec2 z)
{

  float s = length(z);
  float m = s/(max(abs(z.x),abs(z.y))+epsilon);
  return m*z;
}

// Function 2798
float wall_sdf(vec3 p){
    vec4 plane = vec4(0, 0, -1, -9.0);
    return dot(p, plane.xyz) - plane.w;
}

// Function 2799
void sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)
{   
    // platform
    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));
    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));
    
    // body cone
    float b1 = sdCone(rotateX(rotateY(pos + coneBody,-0.5),0.3), vec2(sin(145.), cos(145.)), 6.);
    // party hat
    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);
    // head
    float b3 = sdSphere(pos + headSphere, 1.5);
    float b4 = sdSphere(pos + scarfSphere, 1.6);
    // legs
    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));
    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));
    
    // floor    
    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));
    
    //mountains
    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));
    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));
	float m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));
    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));
    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));
	float n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));
    
    // moon 
    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);
    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);
    float s3 = opSubtraction(s2, s1);
    
    //lilypads
    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime),0.), 2.3, .1);
    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1); 
    
    //stairs
    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));
    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));
    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));
    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));
    
    obj = 0; 
	float min = min(s3, min(t2, min(b1, min(b0, 
               	min(b2, min(b3, min(b4, min(b5,
                min(b6, min(m1, min(m2, min(m3, 
                min(n1, min(n2, min(n3, min(b7, 
                min(l0, min(l1, min(s0, min(s4, 
                min(s5, s6)))))))))))))))))))));    
    t = min;
    if (min == t2) {obj = 3;}
    else if (min == b0 || min == s0 || min == s4
            || min == s5 || min == s6) {obj = 0;}
    else if (min == b4) {obj = 1;}
    else if (min == m1 || min == n1) {obj = 4;}
    else if (min == m2 || min == n2) {obj = 6;}
    else if (min == m3 || min == n3) {obj = 5;}
    else if (min == b7) {obj = 7;}
    else if (min == l0 || min == l1) {obj = 8;}
    else {obj = 2;}
   	
}

// Function 2800
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstAst, dstFlyer, dstEng, refFac;
  dstEng = FlyerEngRay (ro, rd);
  dstFlyer = FlyerRay (ro, rd);
  if (dstFlyer < dstEng) dstEng = dstFar;
  dstAst = AstRay (ro, rd);
  if (dstFlyer < min (dstAst, dstFar)) {
    ro += rd * dstFlyer;
    vn = FlyerNf (ro);
    col4 = FlyerCol ();
    col = col4.rgb;
    refFac = 0.;
    if (col4.a >= 0.) {
      col = col * (0.2 + 0.1 * max (dot (vn, - ltDir), 0.) + 0.7 * max (dot (vn, ltDir), 0.)) +
         col4.a *  pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
      refFac = 0.5;
    } else if (col4.a == -1.) refFac = 0.9;
    if (refFac > 0.) {
      rd = reflect (rd, vn);
      ro += 0.01 * rd;
      dstAst = AstRay (ro, rd);
      col = mix (col, AstCol (ro, rd, dstAst), refFac);
    }
  } else col = AstCol (ro, rd, dstAst);
  if (dstEng < min (dstAst, dstFar)) col = mix (col, vec3 (1., 0.5, 0.1), 0.7);
  return pow (clamp (col, 0., 1.), vec3 (0.9));
}

// Function 2801
SSdfSample SdfSoftMin(SSdfSample sdf0, SSdfSample sdf1, float sRadiusBlend)
{
#if MM_SOFT_MIN
	float gT = max(sRadiusBlend - abs(sdf0.m_s - sdf1.m_s), 0.0);
	float s = min(sdf0.m_s, sdf1.m_s) - gT * gT * 0.25 / sRadiusBlend;
#else
	float gK = 0.25 * sRadiusBlend;
	float sMin = min(sdf0.m_s, sdf1.m_s);
	float sMax = max(sdf0.m_s, sdf1.m_s);
	float s = sMin - gK * log2(exp2((sMin - sMax) / gK) + 1.0);
#endif
	float dS0 = sdf0.m_s - s;
	float dS1 = sdf1.m_s - s;
	float u = dS0 / (dS1 + dS0);
	SSdfSample sdf;
	sdf.m_s = s;
	sdf.m_mtl = MtlLerp(sdf0.m_mtl, sdf1.m_mtl, u);
	return sdf;
}

// Function 2802
float map(vec3 p)
{
    vec4 tt = vec4(iTime*0.03,iTime*0.07,iTime*0.5,iTime*0.75) * TAU;
	p.xz *= rotate(tt.x);
    p.zy *= rotate(tt.y);
    return sdBumpedSphere(p);
}

// Function 2803
float differenceSDF(float distA, float distB) { return max(distA, -distB); }

// Function 2804
vec3 tonemapping(vec3 color, float exposure)
{
	color *= exposure;
    
    float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.10;
	float E = 0.015;
	float F = 0.40;
	float W = 11.2;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
    
    return color;
}

// Function 2805
bool RayTraceScene(Ray ray, out HitInfo hitInfo)
{
    hitInfo.t = MAX_RAY_DISTANCE;
	
	bool isHit = false;
	for (int i = 0; i < SCENE_SPHERE_COUNT; i++) 
    {
		HitInfo tempInfo;
		if(RaySphereIntersection(ray, sceneSpheres[i], tempInfo))
		{
			if(hitInfo.t > tempInfo.t)
			{
				isHit = true;
				hitInfo = tempInfo;
			}
		}
	}
	
	for (int i = 0; i < SCENE_BOX_COUNT; i++) 
    {
		HitInfo tempInfo;
		if(RayBoxIntersection(ray, sceneBoxes[i], tempInfo))
		{
			if(hitInfo.t > tempInfo.t)
			{
				isHit = true;
				hitInfo = tempInfo;
			}
		}
	}
	
	return isHit;
}

// Function 2806
float mapLeafWaterDrops( in vec3 p )
{
    p -= vec3(-1.8,0.6,-0.75);
    vec3 s = p;
    p = mat3(0.671212, 0.366685, -0.644218,
            -0.479426, 0.877583,  0.000000,
             0.565354, 0.308854,  0.764842)*p;
  
    vec3 q = p;
    p.y += 0.2*exp(-abs(2.0*p.z) );
    
    //---------------
    
    float r = clamp((p.x+2.0)/4.0,0.0,1.0);
    r = r*(1.0-r)*(1.0-r)*6.0;
    float d0 = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r) );
    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );
    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );
    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );
    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );

    d3 = max( d3, p.y-0.01);
    
    return min( min(d1,d4), min(d2,d3) );
}

// Function 2807
float sphereSDF(vec2 p, float size) {
	return length(p) - size;
}

// Function 2808
float disttoline(vec2 a, vec2 b, vec2 p) {
 	return abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) 
        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   
}

// Function 2809
vec2 distanceMarker( in vec3 p ) 
{
	vec3 q = p - vec3(0.0,-1.0,0.2);
	return vec2(distSquaredCylinder( q, vec3(0.5,0.005,0.75),0.1 ),3.0);
}

// Function 2810
float dist( vec3 p,bool Refl)
{
 
    float f = (p.y+1.25);
   
    // NOTE(theGiallo): coconuts
    vec3 scp = vec3(0,.07,1.2), cp = scp;
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
    cp.xz += vec2(.2,0.13);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
    cp.xz += vec2(.02,0.33);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
    cp.xz += vec2(-.32,-0.2);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
	    
    f=min(f,coconut(at_pos(scene.objs[int(OBJ_V_COCONUT)-1].xyz,p)) + 1e37 * scene.objs[int(OBJ_V_COCONUT)-1].w );
    
   f= min(f, sscreen_bottle( at_pos( scene.objs[int(OBJ_V_SSCREEN)-1].xyz, p ) ) + 1e37 * scene.objs[int(OBJ_V_SSCREEN)-1].w);                    // boat
    {
        vec3 mp = scene.mpallin.xyz;
    	float dmp = distance(p,mp);
    	f = min(f,dmp);
    	if ( dmp < 2. )
    	{
	    	f=min(f,mpallin(p));
	    }
    }
    {
        vec3 b = scene.bafryce.xyz;
    	float db = distance(p,b);
    	f = min(f,db);
    	if ( db < 2. )
    	{
    		f=min(f,bafryce(p));
	    }
    }
    if (  scene.objs[0].w == 0.0 )
    {
        vec3 lp = scene.objs[0].xyz;
    	float dlp = distance(p,lp);
    	f = min(f,dlp);
    	if ( dlp < 1. )
    	{
    		f=min(f,laptop_open(at_pos(scene.objs[0].xyz,p),.45,0.5));
	    }
    }
    //f = min( f, capped_cylindery_sd( vec2(island_r,100), at_pos(island_center+vec3(0,-100,0),p) ) );
    f = min( f, capped_cone_as_intersections_sd( 20., island_r + 100., island_r, at_pos(island_center+vec3(0,-20.,0), p ).xzy ) );
   // float di=texture(iChannel1,vec2(atan(p.x-island_center.x,p.z-island_center.z),p.y)).x*.5;
    f = min( f, capped_cone_as_intersections_sd( 200., island_r - 50., 20., at_pos(island_center+vec3(0,0,0), p ).xzy ) );
    f = min( f, palm(p) );
    
    f = min(f, little_table(at_pos(vec3(10.,0.5,10.),p))  );
  if ( scene.boat.w == 0.0 )
    {
        f=min(f, GetBoatDistance(at_pos(scene.boat.xyz,p)).fDist);
    }
    
    f=min(f,towel(at_pos(vec3( 17, 0, 10),p),90.));
    f=min(f,towel(at_pos(scene.mpallin.xyz-vec3(0.,.15,0.),p),0.));
    return f;
}

// Function 2811
float distanceEstimation(vec3 pos) {
    
    pos.y = -pos.y;
    
    float r = length(pos);
    vec3 z = pos;
    vec3 c = pos;
	float dr = 1.0, theta, phi;
	for (int i = 0; i < 6; i++) {
		r = length(z);
		if (r>SceneRadius) break;
		theta = acos(z.y/r);
		phi = atan(z.z,z.x);
		dr =  pow( r, Power-1.0)*Power*dr + 1.0;
		theta *= Power + ThetaShift;
		phi *= Power + PhiShift;
		z = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + c;
	}
	return 0.5*log(r)*r/dr;
}

// Function 2812
float lmap(vec2 p)
{
	//return length(p);
	//return atan(p.y, p.x)/6.28 + length(p);
	//return atan(p.y, p.x)/6.28 - length(p);
	//return abs(mod(p.x,0.1)-0.05) + p.y;
	return abs(mod(p.y,0.1)-0.05) + p.x;
	//return p.x;
}

// Function 2813
float sdf_N(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, -8, 0)));
    return t;
}

// Function 2814
vec2 map(vec3 p) {
    vec3 v = mod(p,13.)-13./2.-vec3(0,4,0);
	vec2 sv = vec2(length(v)-2., 0.);
    vec2 pv = vec2(p.y+2., 1.);
    return ((sv.x<pv.x)?sv:pv);
}

// Function 2815
float mapCam(vec3 p)
{
    float d;
    p.xz *= .3;



    d = smoothstep( 0.1, .7, texture(iChannel1, p.xz*.00015+.1, -99.).y)*4.0;
    d += smoothstep( 0.,.8, texture(iChannel2, p.xz*.0002+.4, -99.).y)*3.;
    d += smoothstep( 0.,.6, texture(iChannel2, p.xz*.0004+.2, -99.).y)*1.5;
    d =  max(d*d*8.0-20., 0.0);

    return (p.y +80.0 - d);
}

// Function 2816
SDFRes map(in vec3 pos )
{   
    SDFRes plane = SDFRes( sdWaves(  pos - vec3(0.0, 0.0, 0.0) ), 1.0, 0.0 ,0.0);
    
    SDFRes dist = SDFRes( sdSphere( pos - vec3( -0.2,0.5, -0.4 + sin(iTime)*2.0), 0.7 ), 200.0, 0.0, 0.0);
    
    #ifdef BLEND
    dist = blendSDF( dist, SDFRes( sdSphere( pos - vec3( 0.6,0.5, -0.4), 0.5 ), 245.0, 0.0, 0.0), BLEND_AMOUNT );
    #else
    dist = addSDF( dist, SDFRes( sdSphere( pos - vec3( 0.6,0.5, -0.4), 0.5 ), 245.0, 0.0, 0.0) );
    #endif
    
    #ifdef BLEND    
    dist = blendSDF( dist, SDFRes( sdTorus( pos-vec3( 0.0,0.5+ sin(iTime*0.4), 1.0), vec2(0.5, 0.2) ), 40.6, 0.0, 0.0 ), BLEND_AMOUNT);
    #else    
    dist = addSDF( dist, SDFRes( sdTorus( pos-vec3( 0.0,0.5+ sin(iTime*0.4), 1.0), vec2(0.5, 0.2) ), 40.6, 0.0, 0.0 ));
    #endif    
    
    #ifdef BLEND
    dist = blendSDF(dist, plane, BLEND_AMOUNT);
    #else
    dist = addSDF(dist, plane);
    #endif
    
    return dist;
}

// Function 2817
float scene(vec3 p) {
    //sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if (length(p) > 1.) {
        return length(p)-.8;
    }
    p.y = -p.y;
    //neural networks can be really compact... when they want to be
    vec4 f0_0=sin(p.y*vec4(-.36,3.91,-3.69,4.22)+p.z*vec4(2.66,2.44,3.63,.17)+p.x*vec4(4.17,-3.60,2.72,3.83)+vec4(-4.46,5.05,5.55,3.40));
    vec4 f0_1=sin(p.y*vec4(-1.06,.99,2.93,-2.01)+p.z*vec4(4.36,4.04,-3.04,3.80)+p.x*vec4(1.44,-.18,-3.28,3.02)+vec4(-4.20,-1.99,-6.45,-7.70));
    vec4 f0_2=sin(p.y*vec4(1.32,-2.91,-3.22,2.16)+p.z*vec4(.47,1.89,4.12,-3.69)+p.x*vec4(1.70,2.75,-3.95,2.05)+vec4(7.41,7.30,-3.35,4.89));
    vec4 f0_3=sin(p.y*vec4(-.10,-1.56,3.64,-3.34)+p.z*vec4(-3.91,-1.39,-3.21,-1.08)+p.x*vec4(3.88,1.33,-1.01,2.47)+vec4(-.38,-7.95,-1.31,2.00));
    vec4 f0_4=sin(p.y*vec4(2.73,-4.30,3.91,3.05)+p.z*vec4(4.31,4.08,3.19,-.84)+p.x*vec4(2.73,2.84,-2.84,-.57)+vec4(.31,-3.00,-4.98,4.69));
    vec4 f0_5=sin(p.y*vec4(1.47,-1.32,-1.36,-1.11)+p.z*vec4(-.58,-.16,4.40,.07)+p.x*vec4(1.70,.12,3.56,2.22)+vec4(-3.33,-3.22,.81,6.42));
    vec4 f0_6=sin(p.y*vec4(2.95,-2.96,2.12,-3.19)+p.z*vec4(-2.98,-.25,-3.79,-2.67)+p.x*vec4(.03,2.63,-.60,3.66)+vec4(-5.86,-5.04,-.64,6.42));
    vec4 f0_7=sin(p.y*vec4(.33,-2.89,-2.13,-.34)+p.z*vec4(-3.16,.97,3.91,1.84)+p.x*vec4(-.42,-3.11,-.39,-4.40)+vec4(6.18,-7.99,-1.16,-3.38));
    vec4 f1_0=sin(mat4(.24,-.06,.27,-.20,.24,-.25,.19,-.28,-.18,.34,.14,-.09,.25,-.19,.17,-.30)*f0_0+
        mat4(.00,.19,-.04,.08,-.02,-.20,.07,-.16,-.27,-.18,-.37,-.21,-.19,-.15,.15,.07)*f0_1+
        mat4(.19,.03,-.25,.39,-.02,-.15,.03,.23,.09,.02,.07,-.05,-.20,.25,-.19,-.34)*f0_2+
        mat4(-.27,-.31,-.05,-.15,-.02,-.04,-.12,.01,.20,-.33,-.15,-.07,-.05,.04,-.77,.15)*f0_3+
        mat4(.17,.10,-.14,-.21,.30,.04,-.23,-.11,.11,-.13,.33,-.17,.11,.03,-.32,-.38)*f0_4+
        mat4(.01,-.17,.16,-.02,.02,.22,-.11,.09,.00,-.01,.28,.02,.11,.20,.40,-.26)*f0_5+
        mat4(-.33,.07,.20,-.08,-.22,.22,.07,.19,.27,-.32,-.23,-.08,.13,-.22,-.10,.01)*f0_6+
        mat4(.01,-.22,.35,-.00,.19,.28,-.04,-.46,-.31,-.05,.24,-.24,-.30,-.33,-.01,.00)*f0_7+
        vec4(-2.22,-.05,-.81,-.60))/1.0+f0_0;
    vec4 f1_1=sin(mat4(.18,.12,.28,.64,.07,-.11,-.02,.11,-.33,-.50,-.14,-.11,-.57,-.17,.05,.15)*f0_0+
        mat4(-.23,-.10,-.32,-.20,-.13,.24,.26,.23,-.18,.06,-.26,.39,-.12,.35,.04,.20)*f0_1+
        mat4(.10,-.12,.14,.34,-.12,.04,.39,-.19,.25,.24,-.29,-.31,.11,.12,.07,-.20)*f0_2+
        mat4(-.03,.08,-.17,-.16,.14,-.18,-.25,.06,-.08,.35,-.02,.33,.31,.09,-.10,-.10)*f0_3+
        mat4(.14,-.36,-.12,-.67,.08,.04,.11,.19,.22,.43,-.21,-.21,-.11,.40,-.32,.25)*f0_4+
        mat4(-.04,.13,-.01,.23,.29,.31,-.15,.08,-.30,-.24,-.38,-.16,-.25,-.40,.21,.06)*f0_5+
        mat4(.29,-.13,.14,.09,.40,-.22,.24,-.43,.23,.42,-.07,.16,.04,-.20,.26,-.16)*f0_6+
        mat4(-.03,.20,-.15,.34,-.27,-.20,.00,-.45,.05,.39,-.16,-.24,.25,.04,-.17,-.12)*f0_7+
        vec4(1.74,-1.39,-.15,-.86))/1.0+f0_1;
    vec4 f1_2=sin(mat4(-.54,.29,.36,.34,-.01,-.05,-.28,.16,.30,.25,-.34,.05,.21,.06,-.16,-.22)*f0_0+
        mat4(.05,.31,-.43,.30,.21,-.25,-.05,-.04,-.33,-.06,.65,-.27,-.15,-.17,-.07,.19)*f0_1+
        mat4(-.42,-.11,-.04,.29,-.06,-.26,.06,.21,-.12,.36,-.31,-.20,-.38,-.11,.20,-.19)*f0_2+
        mat4(-.04,.28,.20,.33,.17,.12,-.48,-.04,-.34,-.24,-.01,-.09,-.20,.13,.47,-.28)*f0_3+
        mat4(.23,.17,.37,.11,-.30,-.22,.42,-.20,.08,-.03,.36,-.40,.02,-.36,.13,-.04)*f0_4+
        mat4(.01,.33,-.26,.16,-.21,-.21,.43,.01,.34,-.09,-.05,.12,.19,-.15,.34,.31)*f0_5+
        mat4(-.43,.16,.22,-.14,-.12,.11,.27,.13,-.16,.08,.22,-.54,.19,-.02,-.32,.15)*f0_6+
        mat4(-.38,-.25,.33,-.25,-.25,-.64,.30,-.23,.20,-.01,.25,.03,-.07,.47,-.02,-.11)*f0_7+
        vec4(-1.57,1.30,1.31,-.69))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.04,-.21,-.27,-.16,.38,.03,-.12,-.03,.32,.18,.27,-.25,-.43,.50,-.35,.13)*f0_0+
        mat4(.37,.17,-.20,-.04,.40,-.59,.20,.39,.05,.14,-.17,-.20,.16,.18,.21,-.07)*f0_1+
        mat4(.12,-.25,.40,-.46,-.36,-.16,-.11,.09,.26,-.48,.00,-.28,-.36,.21,-.11,-.01)*f0_2+
        mat4(.13,-.20,-.06,-.25,.14,.29,-.31,.24,-.04,.29,.05,.16,-.18,.07,.28,-.28)*f0_3+
        mat4(-.19,-.12,.33,-.12,.03,.32,-.03,.08,-.56,.19,.25,.08,.01,.32,.05,.14)*f0_4+
        mat4(.55,-.02,.21,.13,-.26,.41,.02,-.29,.12,-.17,-.16,-.04,-.58,.10,.05,.20)*f0_5+
        mat4(-.03,-.14,.13,.13,-.16,.19,.02,.09,-.34,.09,.02,.01,-.01,-.20,-.09,.13)*f0_6+
        mat4(.19,-.19,-.17,.04,-.57,.08,.18,.32,.02,-.01,-.29,-.22,.22,.11,-.02,.04)*f0_7+
        vec4(-2.23,.27,-.36,.14))/1.0+f0_3;
    vec4 f1_4=sin(mat4(-.22,-.17,.03,.13,.20,.35,-.18,-.10,-.13,.31,-.29,.17,-.23,.23,.47,-.01)*f0_0+
        mat4(.34,.19,.04,-.14,-.09,.48,.24,-.27,-.19,.29,-.06,.12,.16,-.18,.27,.06)*f0_1+
        mat4(-.17,-.25,-.30,-.38,.15,-.18,.16,-.12,.21,-.18,.18,-.19,.25,.30,.11,.27)*f0_2+
        mat4(.29,-.15,-.06,.07,-.19,-.00,.13,.14,.36,.11,.42,.21,.25,-.21,-.28,-.03)*f0_3+
        mat4(.69,-.28,-.19,.01,-.03,-.05,-.09,-.02,-.01,.15,-.06,.02,.15,.24,.04,-.15)*f0_4+
        mat4(-.26,.02,.21,-.45,.11,-.08,.14,.36,.19,-.32,-.05,-.17,.40,-.06,.12,-.01)*f0_5+
        mat4(-.06,.39,-.00,.02,-.16,.09,-.18,-.20,.36,.32,-.07,.19,.12,-.26,-.10,.29)*f0_6+
        mat4(-.38,.38,.16,-.04,.32,.04,-.08,.07,.34,.13,-.04,.08,.25,-.26,-.13,.02)*f0_7+
        vec4(-.71,-1.58,-2.04,-.56))/1.0+f0_4;
    vec4 f1_5=sin(mat4(.19,.20,-.43,-.12,.07,-.08,-.22,.18,.34,-.31,.29,.18,.16,.01,-.25,.13)*f0_0+
        mat4(.25,.00,.02,-.13,-.14,.31,.30,.20,.22,-.11,.04,-.23,.17,-.19,-.18,-.16)*f0_1+
        mat4(.30,.20,.13,-.43,.07,.03,.29,-.07,.36,.01,-.27,.24,-.35,-.15,.25,-.22)*f0_2+
        mat4(-.02,-.04,.01,.25,.04,-.24,-.09,.38,.16,.14,.15,-.06,.33,.17,.11,-.04)*f0_3+
        mat4(-.14,.05,.42,-.09,.13,-.04,.02,.20,-.02,-.29,-.46,.04,-.06,.08,-.19,.33)*f0_4+
        mat4(.14,-.29,.08,-.31,-.20,.09,-.08,-.14,.01,.05,.18,-.08,-.39,-.04,.16,.20)*f0_5+
        mat4(.00,-.01,-.26,.04,.05,.30,.12,-.18,.08,.44,-.05,-.40,.07,.48,-.11,.19)*f0_6+
        mat4(.15,.13,-.13,.03,-.26,-.25,.01,-.32,-.26,-.16,-.09,-.04,-.06,-.37,-.25,.26)*f0_7+
        vec4(-.39,1.49,-.68,-1.91))/1.0+f0_5;
    vec4 f1_6=sin(mat4(.50,-.02,-.69,.07,.06,-.07,-.06,-.12,-.25,-.01,.36,-.01,-.10,.17,.35,-.60)*f0_0+
        mat4(.31,.07,-.18,-.35,.66,.17,-.34,-.07,-.15,.39,-.14,.14,-.16,-.15,.18,-.03)*f0_1+
        mat4(-.11,.14,.21,-.07,.16,-.33,-.24,.08,-.12,.06,-.20,-.20,.21,-.23,-.21,.24)*f0_2+
        mat4(.06,-.27,-.25,.11,.11,.24,-.18,.25,.28,-.24,-.13,-.17,-.22,-.39,-.23,.46)*f0_3+
        mat4(-.61,.14,.33,.63,.22,-.01,-.29,.20,-.46,-.10,.36,.46,.29,.01,.08,-.34)*f0_4+
        mat4(.33,.33,-.26,-.02,-.48,-.13,-.03,-.28,-.03,-.26,.16,.22,.31,.04,-.28,-.09)*f0_5+
        mat4(-.13,-.04,-.25,.22,-.45,.01,.19,.28,.36,-.27,-.22,-.05,-.12,-.05,.01,.34)*f0_6+
        mat4(-.06,.11,.20,-.00,.06,.01,.30,.16,-.17,.03,.20,-.05,-.21,-.27,-.35,.09)*f0_7+
        vec4(1.97,2.24,-1.04,-1.98))/1.0+f0_6;
    vec4 f1_7=sin(mat4(.14,.48,-.15,-.37,.21,.26,-.16,-.14,-.17,.04,.35,.27,-.30,-.34,.26,-.18)*f0_0+
        mat4(.13,-.13,-.46,-.43,-.02,.54,-.21,.03,.39,-.14,.23,-.00,.30,-.12,-.04,-.02)*f0_1+
        mat4(.01,-.02,-.32,.13,.23,.01,-.22,-.16,.15,-.17,-.23,.00,-.45,.15,-.09,-.49)*f0_2+
        mat4(.23,.10,-.10,.41,.16,.34,-.47,.18,-.12,.03,-.15,-.20,-.19,-.37,.08,-.03)*f0_3+
        mat4(-.29,-.26,.17,.08,-.19,.05,.11,-.01,-.15,-.27,.26,-.20,-.25,-.40,-.22,-.17)*f0_4+
        mat4(.37,-.14,.25,.31,.30,-.25,.15,-.35,-.09,-.13,-.07,.11,-.15,.17,-.29,.27)*f0_5+
        mat4(-.16,.04,-.17,-.11,.23,.15,-.25,.01,.22,.16,.08,-.26,.41,-.14,-.17,.17)*f0_6+
        mat4(-.15,-.03,-.29,-.06,-.68,-.18,.22,-.45,.25,-.12,-.11,-.27,.10,.24,.13,-.18)*f0_7+
        vec4(-.06,-.40,1.48,-1.43))/1.0+f0_7;
    vec4 f2_0=sin(mat4(.31,.34,.12,.13,-.10,.27,-.33,-.21,-.19,.27,-.03,.13,.18,-.29,-.25,-.03)*f1_0+
        mat4(.21,-.36,-.45,.11,.00,.05,-.36,-.32,-.06,.24,.21,.07,-.14,.15,-.22,.31)*f1_1+
        mat4(.32,-.14,-.17,.21,.17,.09,-.15,-.26,-.13,.12,.27,-.35,.21,.11,-.15,-.13)*f1_2+
        mat4(-.25,-.08,.01,.37,-.27,.17,.04,-.21,-.03,-.16,.14,.08,-.13,-.04,.33,-.27)*f1_3+
        mat4(-.02,.18,.03,-.32,.06,-.20,.06,.05,-.05,.26,.15,-.15,-.14,-.22,-.05,.18)*f1_4+
        mat4(.16,-.05,-.31,-.07,.27,.15,-.08,.39,.19,.14,-.28,-.06,-.33,.03,.04,-.16)*f1_5+
        mat4(.13,-.20,-.09,-.06,-.14,.15,.16,.14,-.29,-.32,.17,.07,.29,.32,.22,-.09)*f1_6+
        mat4(-.20,-.04,.18,.10,.28,.31,-.14,-.24,.17,-.15,-.03,.16,.34,-.31,.30,-.14)*f1_7+
        vec4(-.75,-.96,1.04,1.19))/1.4+f1_0;
    vec4 f2_1=sin(mat4(.05,-.44,-.16,-.17,.03,.19,-.28,.36,-.18,-.10,.31,-.06,.19,.14,-.13,.08)*f1_0+
        mat4(-.46,-.46,-.42,-.13,.08,.06,-.22,-.10,.41,-.47,.11,.15,-.14,.37,.13,.43)*f1_1+
        mat4(.40,.35,.25,.51,-.21,.06,-.28,.35,-.08,-.39,.02,.19,-.21,-.25,.00,.34)*f1_2+
        mat4(.60,.17,-.03,.45,-.39,-.29,.01,.03,.24,.50,.28,.12,.06,-.54,-.06,.36)*f1_3+
        mat4(.41,-.07,.25,.34,.18,.18,-.18,.30,.31,.47,-.01,.28,-.02,.12,-.17,-.30)*f1_4+
        mat4(.20,-.40,-.04,-.54,-.16,.22,-.05,.10,-.02,.28,-.49,.21,.17,-.16,.02,.24)*f1_5+
        mat4(-.03,.06,-.01,.25,-.22,-.18,-.17,-.01,.01,.03,-.07,-.02,.36,.23,-.26,.52)*f1_6+
        mat4(.28,.09,.25,-.02,.11,-.10,-.21,.07,.29,.11,.06,-.30,-.22,-.43,-.07,-.44)*f1_7+
        vec4(-1.37,-1.80,-.48,-2.17))/1.4+f1_1;
    vec4 f2_2=sin(mat4(.17,.06,.09,.15,-.07,-.21,-.27,.19,-.00,-.30,.03,-.02,-.19,.29,.05,-.06)*f1_0+
        mat4(-.17,-.31,-.06,-.12,-.23,-.63,.02,-.33,.23,.31,.07,.33,-.08,-.83,-.49,.21)*f1_1+
        mat4(.07,.79,.27,.06,.05,.44,.10,.08,-.15,.26,-.18,-.04,.37,-.02,.30,-.19)*f1_2+
        mat4(-.08,.46,.09,-.03,-.09,-.44,-.01,.33,.08,.10,-.06,-.13,-.22,.54,.08,.26)*f1_3+
        mat4(-.16,-.17,-.23,.32,-.03,-.15,.38,.03,-.15,.15,.43,-.45,.20,-.12,.23,.23)*f1_4+
        mat4(.49,-.44,.29,.40,-.29,-.08,-.39,.16,.06,-.36,.01,-.21,-.02,.20,.21,.17)*f1_5+
        mat4(.03,-.07,-.08,-.12,.13,-.19,.06,-.17,.44,.94,.38,.39,-.11,.18,.18,.09)*f1_6+
        mat4(-.05,.26,.01,-.06,.15,.30,-.06,.25,-.06,-.06,-.30,.41,.25,-.22,.04,.10)*f1_7+
        vec4(-.45,-.38,1.48,-1.50))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.14,.23,.30,.17,.04,.06,.20,-.36,-.16,.15,-.05,-.20,-.10,.04,.01,-.19)*f1_0+
        mat4(-.19,.13,-.06,-.20,.34,-.24,-.20,.37,-.25,.01,.00,-.14,.32,-.14,-.39,-.08)*f1_1+
        mat4(.12,.15,.02,-.26,-.09,-.13,.32,-.20,.12,-.09,-.08,.13,-.11,.20,.03,-.09)*f1_2+
        mat4(-.29,-.02,.03,.13,.01,.34,.26,.01,.46,-.25,-.31,-.01,.13,-.27,.03,-.05)*f1_3+
        mat4(.21,.15,-.73,.01,.06,.34,.05,-.03,.20,.34,-.08,-.19,-.09,.02,-.04,.33)*f1_4+
        mat4(-.07,-.02,.15,-.07,-.28,.39,-.09,.03,.35,.08,-.05,-.05,.34,.12,-.01,.22)*f1_5+
        mat4(-.28,.25,.31,.15,.09,-.13,-.46,-.12,-.42,-.30,.28,.20,.20,.33,-.25,-.10)*f1_6+
        mat4(.45,-.04,.43,.41,.14,-.03,.27,.32,-.06,-.07,-.26,.02,.13,.11,-.14,.20)*f1_7+
        vec4(-2.16,-1.49,-1.83,.87))/1.4+f1_3;
    vec4 f2_4=sin(mat4(-.31,.13,.18,.04,.16,.34,-.03,-.10,.26,-.24,.17,-.09,-.25,-.23,.13,.07)*f1_0+
        mat4(.51,-.22,.40,.07,.51,-.33,.06,.23,-.08,-.31,.23,.01,.42,.44,-.09,.09)*f1_1+
        mat4(-.35,.29,-.01,-.17,.13,-.06,-.22,-.34,.12,-.19,.04,-.12,.24,-.05,-.07,.02)*f1_2+
        mat4(.26,.39,-.17,-.25,-.21,.10,.26,.24,-.14,.02,-.11,-.20,.24,-.01,-.14,-.20)*f1_3+
        mat4(.22,.54,-.11,.09,.39,.19,-.03,.03,.34,.02,-.06,-.33,.01,.12,.33,.11)*f1_4+
        mat4(-.19,.15,-.10,.17,-.00,.16,-.43,-.02,.48,-.09,.18,.08,.59,.03,-.10,.05)*f1_5+
        mat4(.10,-.38,-.04,.40,-.18,-.01,-.08,-.11,-.64,-.37,.29,.19,.43,.22,-.11,-.04)*f1_6+
        mat4(.07,-.34,-.11,.40,.10,.01,.30,.27,-.06,.35,-.36,.07,-.04,.12,.28,.18)*f1_7+
        vec4(-.80,1.64,-.76,.72))/1.4+f1_4;
    vec4 f2_5=sin(mat4(.01,.04,-.06,-.02,-.31,.10,.24,-.08,.35,.10,.35,.05,.10,-.06,-.04,.11)*f1_0+
        mat4(.21,.43,.57,-.10,.38,.18,-.14,-.21,-.19,.18,-.39,.07,.17,.27,.42,.29)*f1_1+
        mat4(-.33,-.60,-.18,-.04,.01,.32,.01,-.08,.03,-.19,.08,.16,-.55,.16,-.44,-.27)*f1_2+
        mat4(-.02,-.18,-.20,.30,.05,-.12,-.24,-.29,-.10,.07,.01,.11,-.33,.15,-.38,-.21)*f1_3+
        mat4(.05,-.19,.22,.11,-.35,.24,-.05,.03,-.23,.35,-.32,.15,.18,.31,.16,-.12)*f1_4+
        mat4(.13,-.23,.06,.42,.16,.27,.48,.33,.08,-.13,-.29,-.01,-.09,-.02,.03,.23)*f1_5+
        mat4(-.42,-.02,-.09,-.25,.08,.16,.11,.22,-.37,-.05,.14,-.23,.08,.15,-.02,.16)*f1_6+
        mat4(-.22,.18,-.20,.03,-.57,-.30,.03,-.19,.29,.14,.38,.23,.06,.18,-.03,-.05)*f1_7+
        vec4(.92,1.27,.72,-1.02))/1.4+f1_5;
    vec4 f2_6=sin(mat4(.05,.50,.23,.09,.09,.20,-.14,-.19,-.13,-.04,-.15,.22,-.05,.13,-.04,.49)*f1_0+
        mat4(.41,.09,-.21,.54,-.10,.24,.21,.46,-.21,-.01,-.29,-.27,.34,-.08,.29,-.22)*f1_1+
        mat4(.40,-.28,-.47,-.25,.20,-.08,-.31,-.50,-.48,.42,-.08,.19,-.24,.27,.13,.13)*f1_2+
        mat4(.04,.41,.10,-.09,-.12,.41,.07,.30,.33,-.04,-.10,-.17,-.09,.00,.24,.04)*f1_3+
        mat4(-.05,-.09,.27,-.17,-.13,.01,-.05,.01,-.23,-.02,.32,-.25,-.26,.15,-.20,-.19)*f1_4+
        mat4(.15,.23,.02,.12,.21,-.44,.16,-.30,-.12,.16,-.06,.03,.11,-.21,-.25,.01)*f1_5+
        mat4(-.38,.50,.13,.50,-.27,.11,-.25,.08,-.24,.16,.04,-.52,.03,.13,.08,-.30)*f1_6+
        mat4(-.06,.29,-.07,.25,-.22,.21,.04,.10,.21,-.31,-.00,-.29,-.39,-.08,.07,.20)*f1_7+
        vec4(-1.72,-.71,-1.40,.83))/1.4+f1_6;
    vec4 f2_7=sin(mat4(-.09,-.29,-.24,-.26,.33,-.33,.39,.13,-.06,-.17,.24,-.26,.23,.09,.21,-.08)*f1_0+
        mat4(.50,.11,.17,.13,.40,-.03,.22,-.14,.22,.31,.26,-.16,.34,-.18,.29,.26)*f1_1+
        mat4(-.04,.33,-.26,-.18,.16,-.12,.34,-.02,.11,-.11,-.25,-.26,.27,.54,-.03,-.45)*f1_2+
        mat4(-.05,.08,.16,.03,-.25,-.07,-.16,.15,.32,.01,-.03,.29,-.09,-.07,.24,.24)*f1_3+
        mat4(.04,-.14,-.03,.30,-.02,.08,.05,.14,-.27,-.19,.47,.03,-.02,.17,.04,.03)*f1_4+
        mat4(-.09,.14,-.39,-.30,-.42,-.31,.11,.09,-.02,.28,.32,-.25,.36,-.06,.18,.12)*f1_5+
        mat4(.11,.36,-.07,-.47,-.23,.11,-.19,.14,-.18,.16,-.34,-.13,.18,.09,.32,.12)*f1_6+
        mat4(-.05,.05,-.34,-.23,.04,.08,-.29,-.15,-.37,-.05,.17,.44,-.38,-.28,-.06,.32)*f1_7+
        vec4(.89,-.88,-.86,1.29))/1.4+f1_7;
    vec4 f3_0=sin(mat4(-.25,-.17,-.39,-.08,.27,.19,.12,.14,.28,.02,-.27,-.09,-.41,.06,.22,-.31)*f2_0+
        mat4(-.09,-.21,-.44,-.11,-.08,-.14,-.06,.07,.19,.13,-.11,.22,.35,-.46,.27,.16)*f2_1+
        mat4(.41,-.01,-.14,-.12,.02,.04,-.17,.33,-.07,-.04,.13,.53,.46,.02,-.01,.13)*f2_2+
        mat4(.09,.09,.05,-.31,-.09,.28,.05,-.17,.28,.10,.14,.11,.07,-.08,.18,-.26)*f2_3+
        mat4(-.01,-.08,.44,.26,-.21,-.04,.06,-.16,.39,.22,-.20,.25,.05,.06,-.19,-.17)*f2_4+
        mat4(-.19,-.06,.12,-.34,-.26,-.28,-.16,.35,-.06,-.09,.06,.09,-.20,-.21,-.26,-.05)*f2_5+
        mat4(-.00,.14,-.02,.24,-.00,-.11,-.18,.33,-.03,.15,.10,-.11,.28,-.26,.31,-.04)*f2_6+
        mat4(.22,-.26,-.09,-.12,.17,-.32,.13,.30,.19,.14,.02,-.30,.25,-.09,.03,-.13)*f2_7+
        vec4(.23,-1.25,-1.21,.23))/1.7+f2_0;
    vec4 f3_1=sin(mat4(-.16,-.30,-.08,-.12,.11,-.18,.27,.24,-.07,.29,.12,-.13,-.01,.05,-.06,-.30)*f2_0+
        mat4(.11,.21,.37,-.09,-.09,.07,-.10,-.11,-.10,-.25,.22,-.02,.13,-.34,.35,.10)*f2_1+
        mat4(.05,-.05,.20,-.25,.19,-.48,.10,.03,.11,.23,.02,-.15,-.02,-.40,.50,-.04)*f2_2+
        mat4(-.45,-.08,.35,.08,-.19,-.16,.27,.08,-.43,.09,.03,.06,.06,.09,-.03,.06)*f2_3+
        mat4(.00,-.16,.22,.14,.08,.44,.22,.04,-.01,.45,.03,.41,-.30,.06,-.07,.16)*f2_4+
        mat4(-.16,.29,-.23,.07,.23,-.01,.33,.04,-.15,.16,.02,-.16,.08,-.33,.18,.14)*f2_5+
        mat4(.21,.21,-.27,.08,.26,-.08,.32,-.18,-.19,.29,-.23,.02,-.19,.30,.23,.43)*f2_6+
        mat4(-.24,.41,-.27,-.18,.11,-.24,.00,-.06,.26,.35,.01,-.16,-.09,.23,.14,.03)*f2_7+
        vec4(.75,.13,-1.05,2.00))/1.7+f2_1;
    vec4 f3_2=sin(mat4(-.23,-.30,.01,-.13,-.21,-.06,-.12,-.04,.03,.14,-.30,-.24,.03,.31,.20,.14)*f2_0+
        mat4(.04,.16,.45,.22,-.49,-.12,.32,-.33,-.12,.03,.06,.05,-.11,-.65,.07,.17)*f2_1+
        mat4(.56,-.07,.14,.05,-.06,.33,-.06,.49,-.35,.10,-.31,.09,-.30,-.18,-.35,-.03)*f2_2+
        mat4(.35,.04,.13,.39,-.17,-.07,-.50,.02,.24,-.02,.21,.14,.19,.23,-.05,.05)*f2_3+
        mat4(-.12,-.11,-.58,-.25,-.03,-.00,-.15,.47,.01,-.24,.16,.27,-.16,-.07,-.05,.03)*f2_4+
        mat4(.11,.35,.12,.10,.05,-.14,.01,.23,-.02,.07,.17,.11,-.27,.05,.36,.18)*f2_5+
        mat4(-.25,-.60,-.32,-.05,-.23,-.07,-.19,.03,-.11,-.14,.12,-.20,-.53,-.09,-.29,.44)*f2_6+
        mat4(-.02,-.09,-.36,-.46,-.16,.08,-.26,-.09,.15,.18,.51,.47,-.13,-.48,.51,.09)*f2_7+
        vec4(1.98,.39,-.47,1.49))/1.7+f2_2;
    vec4 f3_3=sin(mat4(.06,.09,.19,.31,-.21,.19,-.18,-.26,-.17,-.36,.19,-.39,-.09,-.37,-.12,.28)*f2_0+
        mat4(.42,.56,-.40,.60,-.05,.13,-.25,.18,.02,.17,-.14,.01,-.43,.61,-.17,.49)*f2_1+
        mat4(.23,-.42,.27,.46,-.33,.04,.06,-.13,-.39,-.21,.25,-.19,-.10,.00,.24,.14)*f2_2+
        mat4(.18,-.18,-.16,.15,-.02,.07,-.01,-.02,.13,.37,.56,.18,-.07,-.17,.35,-.21)*f2_3+
        mat4(-.15,.36,-.11,-.20,.37,.38,.31,-.16,-.04,-.04,-.06,.04,.23,-.34,.01,.29)*f2_4+
        mat4(.31,.02,.14,.27,.06,.18,-.21,.03,-.32,.46,-.16,.14,-.14,.36,-.27,.23)*f2_5+
        mat4(.05,-.40,.16,-.28,-.17,.08,.22,-.02,.17,-.13,-.27,.30,-.44,.66,.19,-.04)*f2_6+
        mat4(.25,-.11,-.25,-.55,.08,.09,-.18,-.08,.02,.00,.20,-.20,.30,.44,-.29,.46)*f2_7+
        vec4(.70,1.07,.01,-1.23))/1.7+f2_3;
    vec4 f3_4=sin(mat4(-.17,-.15,.12,.28,-.46,.34,.31,.42,-.24,.45,.10,-.06,.16,.47,.07,-.34)*f2_0+
        mat4(-.35,-.09,.20,-.29,.46,-.07,-.26,-.07,-.22,-.20,-.03,-.09,-.66,.34,-.21,.01)*f2_1+
        mat4(-.26,-.23,.33,.03,.19,-.45,-.27,-.10,.43,-.15,-.21,.30,.28,.27,.26,.22)*f2_2+
        mat4(-.07,.28,.32,-.22,.23,-.39,.17,.07,-.23,-.09,-.23,-.02,-.10,-.11,.08,.22)*f2_3+
        mat4(-.28,-.10,.18,.26,-.27,.03,.24,-.44,-.26,.38,-.01,.02,.15,-.18,-.33,-.01)*f2_4+
        mat4(-.24,.16,.22,-.34,-.34,.08,-.02,-.32,-.26,.10,-.03,-.34,-.15,-.04,.05,-.29)*f2_5+
        mat4(.57,.31,-.10,.52,.31,.02,-.26,.46,.25,-.46,-.22,.08,-.36,.31,.18,.13)*f2_6+
        mat4(.10,.04,.27,-.13,.27,-.14,-.09,.30,.26,-.19,-.18,-.00,-.30,-.25,-.03,-.47)*f2_7+
        vec4(-.08,.24,-.37,-.53))/1.7+f2_4;
    vec4 f3_5=sin(mat4(.13,.05,-.11,.11,.21,.11,-.40,-.02,.02,.31,.12,.14,.06,.25,.39,.16)*f2_0+
        mat4(.11,.16,-.06,.11,-.04,-.08,.05,-.13,.02,.30,-.05,-.15,-.09,-.27,-.42,-.16)*f2_1+
        mat4(.30,-.24,-.18,-.06,-.36,-.07,.01,-.67,-.01,.14,-.09,.03,-.18,-.13,-.22,-.08)*f2_2+
        mat4(-.11,-.09,.31,.36,-.23,-.16,.00,.07,.48,-.28,-.34,.04,-.23,-.13,-.18,-.15)*f2_3+
        mat4(-.22,-.07,-.36,-.19,-.09,.22,.02,.23,.18,.22,.16,.29,-.06,-.19,.39,-.20)*f2_4+
        mat4(-.05,.35,.26,.33,-.26,-.00,-.34,-.06,.13,-.24,-.25,-.27,-.07,.03,-.34,-.28)*f2_5+
        mat4(.15,.01,.03,.20,.31,.24,.18,-.03,.09,-.23,.31,-.05,-.13,-.22,-.28,-.07)*f2_6+
        mat4(-.27,.11,.16,.35,-.18,-.25,.35,-.18,.30,.17,-.12,-.23,.12,.03,-.01,.04)*f2_7+
        vec4(.96,-1.20,-1.14,-1.00))/1.7+f2_5;
    vec4 f3_6=sin(mat4(.22,-.36,.21,-.35,-.24,.22,.17,-.28,-.06,-.15,-.20,.07,.15,-.26,-.16,.13)*f2_0+
        mat4(.14,-.19,.37,-.01,.25,.32,-.10,-.19,.21,.39,-.26,-.29,.16,.00,.63,.51)*f2_1+
        mat4(.18,-.04,.11,-.23,.04,.28,.14,.00,-.04,.03,.04,.10,.24,.51,-.07,.20)*f2_2+
        mat4(-.14,.08,.01,.12,-.12,-.16,-.32,-.04,.00,-.10,.17,.45,.16,.18,.07,.37)*f2_3+
        mat4(.18,-.32,-.01,.12,-.32,-.28,.04,.10,.01,.21,.12,-.05,.04,.17,-.30,.11)*f2_4+
        mat4(-.28,.08,-.39,.22,.11,-.15,-.05,.14,-.02,-.15,.08,.02,-.32,.36,.22,-.09)*f2_5+
        mat4(.13,.31,-.19,.27,-.10,.06,-.21,.01,.07,.11,.17,.34,.15,.09,.19,.18)*f2_6+
        mat4(-.02,-.23,-.07,-.01,.34,.29,.02,-.17,-.08,-.04,.11,.23,-.11,-.44,-.07,-.44)*f2_7+
        vec4(-1.22,1.17,-1.00,.20))/1.7+f2_6;
    vec4 f3_7=sin(mat4(-.14,-.11,-.12,.12,-.14,.21,.11,-.03,.04,.39,.18,-.07,.06,-.18,.00,-.17)*f2_0+
        mat4(.23,.18,-.08,-.40,-.01,.39,-.26,.13,.03,.23,-.28,.06,-.07,.45,.28,.01)*f2_1+
        mat4(.14,.18,-.06,-.15,.07,-.22,-.24,.36,.04,-.21,-.05,.29,.09,.14,-.09,.25)*f2_2+
        mat4(-.13,-.39,.18,-.04,.07,-.45,-.08,.30,-.43,.30,.14,-.34,-.25,.28,.04,.04)*f2_3+
        mat4(.13,.26,-.03,.55,.18,.43,-.18,-.03,.34,-.16,.16,-.14,.01,-.02,-.08,-.01)*f2_4+
        mat4(.45,.15,-.20,-.34,.31,.09,.01,-.22,-.27,.22,.19,-.20,.37,.02,.08,-.03)*f2_5+
        mat4(.19,-.47,.24,.33,.01,-.20,.15,.01,.22,-.03,.22,-.15,.02,.07,.08,.14)*f2_6+
        mat4(-.23,.06,-.22,-.09,.16,-.05,.19,.05,-.42,-.31,-.31,-.38,.08,.05,-.16,-.15)*f2_7+
        vec4(-.23,1.33,-1.81,.90))/1.7+f2_7;
    vec4 f4_0=sin(mat4(.01,.04,-.20,-.10,-.04,-.06,.10,.07,-.19,-.03,.17,-.26,-.40,-.14,-.21,.30)*f3_0+
        mat4(-.54,.00,-.02,-.07,-.13,.38,-.32,.32,-.43,-.10,-.35,.38,.24,.24,-.10,-.11)*f3_1+
        mat4(.14,-.19,.02,.16,.11,.13,.38,-.14,.31,-.19,.25,-.67,-.44,.04,-.03,-.47)*f3_2+
        mat4(-.05,.08,.01,.30,.04,.25,.39,-.37,.02,-.36,.12,.39,.56,-.05,-.10,-.20)*f3_3+
        mat4(.40,.14,-.11,-.60,.34,.15,.03,-.39,-.04,-.05,-.26,-.18,-.14,-.25,.16,-.22)*f3_4+
        mat4(.08,-.16,-.23,.31,.39,-.09,-.14,-.10,-.55,.10,.09,.39,-.04,.22,.01,.61)*f3_5+
        mat4(.35,.15,-.10,-.34,.22,-.09,.02,-.41,-.36,.04,.06,.35,-.13,.10,-.02,-.02)*f3_6+
        mat4(-.37,.14,.04,-.41,-.34,.30,.18,-.32,-.04,-.06,-.26,.46,-.70,.07,-.17,.28)*f3_7+
        vec4(.12,-.45,-.01,-1.54))/2.0+f3_0;
    vec4 f4_1=sin(mat4(.33,-.00,.47,-.21,-.01,.01,.27,-.33,-.02,-.07,.05,-.05,-.44,-.08,-.50,-.18)*f3_0+
        mat4(.26,-.00,-.19,-.21,.00,-.10,.18,-.23,-.16,.15,.20,.18,-.35,-.23,.53,.09)*f3_1+
        mat4(-.11,.05,-.06,-.13,.11,.55,-.10,-.20,-.08,.47,.18,.37,-.04,.30,.51,-.16)*f3_2+
        mat4(.14,-.34,-.20,-.07,-.21,.27,.49,-.21,-.18,-.54,.06,.02,.10,.11,.13,-.16)*f3_3+
        mat4(.08,.34,.19,-.24,-.30,-.26,.42,-.12,-.10,-.20,-.14,-.15,-.18,-.07,-.09,.19)*f3_4+
        mat4(-.28,-.56,.21,.12,.11,.07,-.18,.41,-.02,-.07,.33,-.30,.03,.11,.37,.03)*f3_5+
        mat4(-.19,.08,-.52,-.12,.15,.41,-.02,.40,-.07,-.30,.03,.02,-.12,.13,.18,-.33)*f3_6+
        mat4(.24,-.10,-.21,.12,.29,.17,.38,-.08,-.21,-.07,.09,.12,.22,-.30,.18,-.01)*f3_7+
        vec4(-.92,-.70,-.39,-.30))/2.0+f3_1;
    vec4 f4_2=sin(mat4(.34,-.02,-.18,.27,.36,-.43,.22,-.06,.62,-.21,-.14,.18,-.33,.12,-.21,.06)*f3_0+
        mat4(-.18,.01,.27,.20,-.50,-.10,-.15,.13,-.10,-.30,-.22,.01,.53,-.05,-.24,.13)*f3_1+
        mat4(.11,.31,-.18,.13,-.63,-.59,.08,-.07,.18,-.55,.01,-.09,-.43,-.21,-.24,.09)*f3_2+
        mat4(-.31,.41,.17,-.02,.29,-.40,.35,-.43,.11,.55,.08,-.12,.01,-.34,-.20,-.15)*f3_3+
        mat4(.45,-.21,-.19,-.26,.62,-.06,.08,.36,.69,-.01,-.22,-.10,-.33,.16,-.11,-.29)*f3_4+
        mat4(-.18,.41,.33,-.16,-.22,-.42,.26,-.44,-.21,.51,-.22,.14,-.69,.18,.18,.21)*f3_5+
        mat4(.00,.07,-.15,-.10,.02,-.49,-.24,-.28,.25,.29,-.24,.13,.81,-.20,.06,.40)*f3_6+
        mat4(.22,.27,.06,.17,.23,-.34,.08,.22,.05,.20,.23,-.06,-.21,.69,-.15,.59)*f3_7+
        vec4(1.56,-.72,1.94,-.17))/2.0+f3_2;
    vec4 f4_3=sin(mat4(.13,.24,.07,.17,-.05,.08,.13,.23,-.12,-.18,.01,-.01,.20,.02,.29,-.08)*f3_0+
        mat4(-.24,-.03,.12,-.23,.55,.19,.21,.01,.24,-.43,-.04,.11,-.08,-.10,.02,.14)*f3_1+
        mat4(-.05,.02,.03,.09,.14,-.09,-.60,.09,-.11,-.27,-.12,.45,-.52,-.05,-.08,-.00)*f3_2+
        mat4(-.17,-.25,-.08,.12,-.03,.31,.23,.25,.30,.26,.23,.05,.43,.37,.18,.21)*f3_3+
        mat4(.03,-.18,-.14,.30,.15,-.09,.31,.32,-.38,-.07,.49,.01,-.25,-.28,-.02,-.14)*f3_4+
        mat4(.34,.24,.34,-.15,.15,.19,.19,.17,-.19,-.30,.22,-.39,.66,.39,.48,.11)*f3_5+
        mat4(-.50,-.02,-.01,-.11,-.54,-.09,.10,-.02,.07,-.04,.22,-.01,-.31,-.00,.09,.01)*f3_6+
        mat4(-.27,.31,.23,.09,-.21,-.38,.21,.05,-.05,.34,-.11,-.15,-.23,-.04,.42,-.01)*f3_7+
        vec4(.53,-1.43,-.37,-1.15))/2.0+f3_3;
    vec4 f4_4=sin(mat4(.16,.29,-.21,-.25,-.03,.26,.24,-.41,.18,.04,.11,-.07,.49,-.14,.17,.47)*f3_0+
        mat4(.19,-.24,.23,-.01,.06,.06,.71,.05,-.09,.06,-.05,-.18,.55,.24,-.10,-.95)*f3_1+
        mat4(.43,.12,-.30,-.07,-.54,-.00,-.09,.37,-.66,.04,-.42,.01,-.35,-.02,.03,-.02)*f3_2+
        mat4(.11,.29,-.03,.24,-.68,.03,.07,-.23,.38,-.01,-.33,-.12,.13,.23,-.14,.35)*f3_3+
        mat4(-.74,.08,-.04,-.37,-.06,.28,.16,-.59,-.06,.37,-.36,-.11,.01,.00,-.05,.24)*f3_4+
        mat4(.55,-.31,.45,.08,-.29,-.14,.10,.15,.24,-.22,-.03,.03,.13,-.29,-.17,.11)*f3_5+
        mat4(-.48,.16,-.23,.45,-.27,-.07,-.02,.14,.47,.17,-.14,.02,-.20,.00,-.40,-.66)*f3_6+
        mat4(-.35,-.56,.14,.30,-.35,.02,.07,-.11,.27,.01,-.32,-.17,.69,-.21,.22,.39)*f3_7+
        vec4(2.07,-1.26,-1.56,-.64))/2.0+f3_4;
    vec4 f4_5=sin(mat4(.47,.13,.16,.03,.27,-.16,.22,-.18,.33,.24,-.12,.44,.22,.06,.07,-.17)*f3_0+
        mat4(-.05,.04,.30,.10,.15,.30,-.23,-.26,-.07,.09,.27,.05,-.20,.05,.15,.12)*f3_1+
        mat4(-.51,-.03,-.09,.18,-.39,.27,.36,-.35,.03,-.07,-.21,-.08,.35,-.26,.09,-.23)*f3_2+
        mat4(.24,-.35,.03,.33,-.22,.11,-.21,-.23,-.21,-.10,.29,.31,.17,-.07,-.31,-.18)*f3_3+
        mat4(-.17,-.35,-.02,-.02,-.22,-.34,.21,.09,-.31,-.19,.20,.32,-.13,-.25,-.26,-.06)*f3_4+
        mat4(.04,.22,.14,.20,-.23,-.00,-.15,-.01,.30,-.09,.52,.09,.45,.21,.25,-.31)*f3_5+
        mat4(-.15,.19,-.65,-.11,-.04,.01,-.29,-.03,-.34,-.13,.28,.21,.02,.30,.36,.30)*f3_6+
        mat4(-.11,-.09,-.33,.53,-.15,-.34,.19,-.24,.10,.28,.10,-.03,-.25,.30,.21,.55)*f3_7+
        vec4(-1.41,-.90,.92,-.08))/2.0+f3_5;
    vec4 f4_6=sin(mat4(.30,-.15,.38,.17,-.14,.13,-.18,-.14,.05,.02,.09,.35,-.09,.15,-.34,.19)*f3_0+
        mat4(-.01,.40,-.35,-.02,-.16,-.49,-.48,-.10,-.00,.34,.17,.14,.03,-.16,-.06,.04)*f3_1+
        mat4(-.05,.11,-.16,-.23,.13,-.16,-.20,-.23,.22,.32,.56,.50,-.01,.21,-.10,-.04)*f3_2+
        mat4(.23,-.15,-.22,-.00,-.29,-.01,-.06,.32,.18,-.15,-.08,.08,.00,.35,.12,.08)*f3_3+
        mat4(.07,.14,.09,.22,.11,.11,.45,-.16,.12,.16,-.27,-.06,-.16,.21,.02,.05)*f3_4+
        mat4(.04,.02,-.53,.08,-.45,.04,-.30,-.16,.19,.11,-.04,.07,.14,-.10,-.51,-.23)*f3_5+
        mat4(.16,.24,-.02,.04,-.25,-.28,.28,-.09,.38,-.16,-.46,-.07,.88,-.47,-.40,.10)*f3_6+
        mat4(-.22,.03,.12,.23,.10,.14,-.15,-.06,.10,-.28,.10,-.05,-.47,-.13,.09,.01)*f3_7+
        vec4(.84,-1.33,1.65,.47))/2.0+f3_6;
    vec4 f4_7=sin(mat4(-.29,.06,.06,.03,-.17,.38,-.21,-.36,.19,.21,.12,-.43,.24,-.13,.15,.63)*f3_0+
        mat4(.46,.09,-.10,.12,-.24,.03,-.05,.14,.38,.21,-.09,.10,-.25,.30,.22,-.38)*f3_1+
        mat4(.23,.16,.40,.48,-.26,-.29,.13,-.12,-.34,.10,-.08,-.69,.11,.04,-.11,-.43)*f3_2+
        mat4(-.09,.47,.00,.19,.08,-.38,.18,-.69,.09,.30,.09,.24,-.15,.37,-.08,-.27)*f3_3+
        mat4(-.17,-.13,-.31,-.41,.03,.39,-.09,.22,.16,.35,.14,-.11,-.29,-.53,.17,-.16)*f3_4+
        mat4(-.13,-.36,.20,.31,-.41,-.35,.25,.06,.26,-.34,.05,.18,.21,-.16,.22,.12)*f3_5+
        mat4(.23,.01,-.51,.10,-.10,-.02,.21,-.11,.10,.29,-.27,-.16,-.34,.71,.09,-.26)*f3_6+
        mat4(.16,-.36,.01,-.21,-.21,.30,-.32,.11,-.11,-.01,-.23,-.14,.21,-.37,-.20,.46)*f3_7+
        vec4(.17,1.06,-.47,-.56))/2.0+f3_7;
    vec4 f5_0=sin(mat4(-.23,-.01,-.19,-.00,.07,.33,-.13,.16,.23,.21,.10,.28,.84,.33,-.07,-.49)*f4_0+
        mat4(.13,-.30,.08,-.20,.16,-.05,.10,-.28,.43,.41,.21,-.23,-.25,.37,.12,-.16)*f4_1+
        mat4(-.08,-.33,.19,.06,.02,-.38,-.26,.20,-.34,-.39,-.34,.06,.14,.31,-.04,-.13)*f4_2+
        mat4(.43,-.05,.03,.17,-.03,.29,-.18,.44,.17,.06,-.14,-.15,.27,-.17,-.34,.17)*f4_3+
        mat4(-.25,-.09,.63,.43,.45,-.04,.04,.19,.36,.35,.02,.03,-.03,-.13,-.07,.04)*f4_4+
        mat4(.14,.17,.25,.09,-.08,-.01,-.04,.26,.10,-.11,.16,-.31,-.07,.10,-.15,-.16)*f4_5+
        mat4(-.11,.32,.15,-.23,-.08,-.05,-.07,.11,-.14,.27,-.15,-.11,.22,-.28,-.15,-.08)*f4_6+
        mat4(.18,-.49,-.38,.04,-.35,.24,-.24,-.38,.24,.25,.09,.29,.66,.17,-.41,-.46)*f4_7+
        vec4(.64,-.50,1.60,-1.73))/2.2+f4_0;
    vec4 f5_1=sin(mat4(.13,-.21,.52,.28,-.26,.20,.35,.09,-.20,.11,-.36,-.22,-.35,.02,.60,-.11)*f4_0+
        mat4(.23,-.09,-.07,.10,.11,-.02,.30,-.48,.25,.04,.27,-.62,.05,.52,.21,-.08)*f4_1+
        mat4(-.22,-.24,-.20,.25,.29,.40,.14,.11,.22,.06,.10,.11,.21,-.08,.01,-.05)*f4_2+
        mat4(-.06,-.26,.28,-.23,-.08,-.29,.09,.18,-.12,-.06,-.02,.14,.01,.64,.06,-.06)*f4_3+
        mat4(.27,-.09,-.51,.48,-.13,-.14,.07,-.10,-.25,-.07,.15,.44,.05,-.22,-.28,.34)*f4_4+
        mat4(-.08,-.41,.39,-.03,.10,-.26,-.34,-.14,.16,.06,.06,-.26,-.01,.19,.08,-.33)*f4_5+
        mat4(.19,.05,.07,-.09,.14,-.41,.06,.03,-.31,.03,.20,.10,-.43,.37,-.17,.38)*f4_6+
        mat4(-.07,-.41,-.35,-.26,.33,.12,.63,.15,-.16,.01,-.40,.10,.10,-.11,-.14,.03)*f4_7+
        vec4(.33,-.29,-.38,.02))/2.2+f4_1;
    vec4 f5_2=sin(mat4(-.40,-.32,.28,-.40,.35,.02,.23,-.04,-.03,.14,.31,-.27,-.33,-1.01,-.34,-.16)*f4_0+
        mat4(.31,-.42,.11,-.13,-.26,-.51,-.35,-.45,-.24,-.35,-.09,-.11,-.12,-.19,-.16,.26)*f4_1+
        mat4(.18,.40,.45,.06,.21,.24,-.09,.50,.12,-.11,.20,-.04,-.11,-.39,-.34,-.29)*f4_2+
        mat4(-.26,.15,-.27,.03,.46,.02,.16,-.38,-.24,-.25,-.13,-.26,.08,.29,.07,-.25)*f4_3+
        mat4(.26,.93,.62,.24,.05,.18,-.21,.24,-.05,-.03,.01,-.04,.46,.49,.22,.02)*f4_4+
        mat4(.18,-.10,-.47,.11,.14,.20,.15,.44,-.07,-.24,.30,-.12,-.14,-.30,-.19,-.33)*f4_5+
        mat4(-.13,-.63,-.18,-.05,-.02,.67,.10,-.09,.13,-.18,.07,-.52,-.04,.05,-.32,-.14)*f4_6+
        mat4(.26,.06,.04,-.37,-.37,-.16,-.25,-.18,-.05,.41,.02,.04,-.14,-.32,-.03,-.07)*f4_7+
        vec4(.01,.00,-1.25,.87))/2.2+f4_2;
    vec4 f5_3=sin(mat4(-.38,.20,-.10,.02,-.25,.18,.32,.14,.45,-.04,.13,.33,-.26,-.23,-.36,-.64)*f4_0+
        mat4(1.09,-.06,.18,.23,-.22,-.34,.21,-.22,-.01,-.16,-.09,-.49,-.13,.24,-.19,-.15)*f4_1+
        mat4(.36,.09,.26,.46,.37,.18,.19,.38,-.16,-.26,.27,.34,-.37,.09,.30,-.35)*f4_2+
        mat4(.35,-.11,.21,.20,-.15,.03,-.35,.52,-.37,-.05,-.06,-.27,.21,.00,.04,.20)*f4_3+
        mat4(.65,.32,.07,.79,.46,.21,.28,.49,-.13,-.26,-.30,.09,.54,-.15,-.12,.61)*f4_4+
        mat4(.20,-.08,-.21,-.16,.04,-.23,.14,.38,.07,-.02,-.12,-.39,-.12,.14,-.24,-.46)*f4_5+
        mat4(-.18,.20,.37,-.27,.09,-.30,.01,.37,.18,.09,.35,-.14,.13,.31,.41,.29)*f4_6+
        mat4(-.22,-.14,-.34,-.14,-.76,.24,.12,-.24,.09,-.13,-.19,-.09,-.15,.05,-.31,-.78)*f4_7+
        vec4(.64,-1.60,1.17,-1.50))/2.2+f4_3;
    vec4 f5_4=sin(mat4(.31,.59,-.26,.16,.05,-.02,-.22,.26,-.25,-.00,-.15,-.02,.21,.79,.30,.45)*f4_0+
        mat4(-.18,.06,-.24,.17,.33,.12,.07,-.22,-.26,.27,-.15,.03,.39,.20,-.01,-.15)*f4_1+
        mat4(-.35,-.40,-.25,-.61,-.03,-.48,-.21,-.31,.31,.01,.35,.02,.08,.12,.04,.55)*f4_2+
        mat4(-.47,.04,.44,.16,-.41,-.00,-.26,-.00,.39,.57,.09,.25,-.24,-.06,-.08,-.15)*f4_3+
        mat4(-.60,-.81,-.09,-.78,-.21,.02,-.17,-.05,.13,.19,.18,-.21,-.37,-.57,.07,-.22)*f4_4+
        mat4(.09,.52,.08,.05,.19,-.29,.01,-.39,-.09,.34,-.32,.10,.18,.14,-.24,.30)*f4_5+
        mat4(.22,.56,.17,.48,.15,.15,-.04,-.30,.27,.19,-.05,-.15,-.18,-.59,.50,.09)*f4_6+
        mat4(-.27,-.08,.53,.21,.32,.29,-.17,.29,-.18,.13,-.04,.03,.09,.46,.21,.23)*f4_7+
        vec4(1.63,-1.72,1.93,2.00))/2.2+f4_4;
    vec4 f5_5=sin(mat4(.13,-.07,.21,-.17,.26,-.14,-.11,.09,.45,.07,-.25,.15,-.12,.12,.39,-.54)*f4_0+
        mat4(-.11,-.02,-.07,.23,.14,.35,.47,-.38,.06,.56,.24,-.31,-.06,-.03,.04,-.06)*f4_1+
        mat4(.20,-.14,-.47,.53,.28,-.08,-.16,.72,-.14,-.35,-.10,.34,.13,.14,.05,-.28)*f4_2+
        mat4(.17,-.06,.10,.18,.13,-.11,-.24,.57,.52,.07,.01,-.30,.13,-.38,-.24,.24)*f4_3+
        mat4(.12,-.26,-.40,1.04,.15,-.02,-.21,.51,.46,.19,-.21,.08,-.05,.14,-.63,1.08)*f4_4+
        mat4(.18,-.13,-.26,-.28,-.07,-.33,.15,-.01,.13,.04,.35,-.18,-.23,.32,.43,-.87)*f4_5+
        mat4(-.16,-.19,.20,-.18,.07,-.05,-.04,.37,-.06,-.19,-.02,-.12,-.02,.21,-.16,.52)*f4_6+
        mat4(-.40,.16,.00,.07,.33,-.08,-.03,-.46,.05,-.19,.31,-.14,-.03,.29,.45,-.63)*f4_7+
        vec4(.60,.40,-.34,1.19))/2.2+f4_5;
    vec4 f5_6=sin(mat4(.01,-.12,-.34,-.17,.13,.02,-.39,-.40,.26,-.03,.31,.01,.51,.36,.10,.55)*f4_0+
        mat4(.15,-.04,.14,.43,-.04,.25,.12,.09,-.30,-.10,-.39,-.32,-.26,-.01,-.37,-.10)*f4_1+
        mat4(-.14,-.77,.63,.07,-.10,.30,.23,.14,.09,.60,.04,-.09,.36,-.03,.15,-.24)*f4_2+
        mat4(-.25,.06,-.17,.52,.03,-.23,.47,.05,.18,-.09,-.32,-.09,-.04,.05,-.23,-.12)*f4_3+
        mat4(-.08,.54,.57,.33,-.21,.59,.23,.38,-.26,-.76,-.47,-.25,-.41,-.06,.18,.16)*f4_4+
        mat4(-.10,.25,-.31,.18,.00,-.05,-.22,.45,.32,.08,.07,.70,-.17,.78,-.11,-.37)*f4_5+
        mat4(-.24,.18,-.17,-.36,-.02,.28,.22,.46,.13,-.43,-.39,-.33,-.03,-.28,.14,.10)*f4_6+
        mat4(-.02,.14,.01,-.09,.19,-.12,-.32,-.09,-.50,-.10,.02,-.23,.26,.58,.42,.40)*f4_7+
        vec4(-1.28,1.50,1.33,-1.03))/2.2+f4_6;
    vec4 f5_7=sin(mat4(.43,.36,.17,-.20,-.34,.30,-.05,.16,-.04,-.08,-.06,.00,.54,.05,-.14,-.79)*f4_0+
        mat4(-.15,-.02,-.16,-.19,.09,.61,-.44,-.45,-.22,.08,-.16,-.33,.03,.19,-.36,-.07)*f4_1+
        mat4(-.42,-.17,.08,.58,-.26,-.23,.36,.56,-.02,-.13,-.20,.25,.14,.28,.08,-.22)*f4_2+
        mat4(.05,-.25,.18,.05,-.03,-.16,.50,.27,.28,-.11,-.15,-.41,.04,.09,.18,.25)*f4_3+
        mat4(-.32,.15,.01,1.00,-.22,-.08,-.02,.33,.24,-.13,.35,.02,-.12,-.21,.17,.57)*f4_4+
        mat4(-.08,.36,-.04,-.40,-.10,-.46,-.20,.18,.05,-.18,.18,-.01,.17,.32,.05,-.20)*f4_5+
        mat4(.28,.13,-.20,-.15,.19,.18,.21,.20,.29,.11,.23,-.27,-.02,-.13,.12,-.05)*f4_6+
        mat4(.24,-.45,.01,.17,-.18,.18,.20,-.46,.03,.06,-.22,-.01,.36,-.20,-.25,-.48)*f4_7+
        vec4(-.87,.99,-1.68,.86))/2.2+f4_7;
    vec4 f6_0=sin(mat4(-.11,-.16,-.08,-.14,-.43,-.26,.18,-.22,.12,.32,.20,.16,.39,-.41,-.76,.48)*f5_0+
        mat4(.42,-.07,-.04,.35,-.42,-.28,-.34,-.13,-.11,-.48,-.10,.25,-.14,.18,.21,-.01)*f5_1+
        mat4(-.05,.02,.59,-.21,-.09,.07,.39,-.40,-.37,.35,.38,-.35,-.20,-.20,-.29,.17)*f5_2+
        mat4(.56,-.35,.32,.26,-.29,.04,.10,-.12,-.29,-.05,-.13,.20,.15,.02,.29,-.54)*f5_3+
        mat4(.06,.24,.65,-.25,.08,.00,.36,-.30,-.19,-.42,.50,-.09,-.11,-.03,.49,-.24)*f5_4+
        mat4(.16,.07,.29,.36,.20,.07,.31,.36,-.08,-.01,-.41,.40,-.15,-.18,-.89,.54)*f5_5+
        mat4(-.10,.16,.05,-.21,.33,.13,-.12,.21,-.48,-.30,-.14,.04,.04,.12,-.02,.37)*f5_6+
        mat4(.36,-.69,-.26,.22,-.40,-.08,-.05,.01,.32,-.11,-.10,.05,.34,-.39,-.30,.83)*f5_7+
        vec4(2.05,1.37,.22,-.66))/2.4+f5_0;
    vec4 f6_1=sin(mat4(.02,-.27,-.37,.17,-.10,-.11,-.21,-.10,-.30,-.10,.08,-.34,.81,-.07,.02,.71)*f5_0+
        mat4(-.06,.02,-.05,.03,.50,-.19,.14,.04,.11,.06,-.31,.08,-.25,.34,-.09,.08)*f5_1+
        mat4(-.65,.61,.06,-.65,-.53,.40,-.07,-.20,-.39,-.05,.48,-.45,.04,-.32,.07,-.09)*f5_2+
        mat4(-.58,.47,.03,-.35,.07,-.20,.12,-.19,.00,.15,-.17,.15,-.17,.13,.06,-.12)*f5_3+
        mat4(-.70,.59,.04,-.72,-.45,.40,-.04,-.45,-.35,.10,-.04,-.27,-.50,.13,.13,-.23)*f5_4+
        mat4(.28,.05,.11,.17,.08,-.17,-.23,-.17,.43,-.27,-.31,.47,.73,-.64,-.34,.86)*f5_5+
        mat4(.12,-.21,-.19,.37,-.58,-.26,-.11,-.43,.61,-.16,.17,.03,-.34,-.09,-.28,-.45)*f5_6+
        mat4(.11,-.13,-.14,-.15,.28,.00,-.00,.28,-.26,.05,-.28,-.00,.68,-.42,-.24,.89)*f5_7+
        vec4(-.26,1.81,.08,-.78))/2.4+f5_1;
    vec4 f6_2=sin(mat4(.01,-.03,-.23,.16,.31,-.16,-.36,.17,-.26,.09,.19,-.46,.17,-.23,.35,.24)*f5_0+
        mat4(.10,-.19,-.32,.39,.45,.08,.24,-.06,.06,-.40,.22,.24,-.19,-.07,.13,-.25)*f5_1+
        mat4(-.36,.11,-.24,-.20,.02,-.26,-.62,.13,-.29,.38,.03,-.25,-.04,-.30,.39,.18)*f5_2+
        mat4(-.19,.09,.16,-.39,-.13,.01,.01,.03,.02,.18,.24,.03,-.25,.14,-.02,-.21)*f5_3+
        mat4(-.37,.10,-.18,-.30,-.20,.09,-.27,-.56,-.16,-.21,.01,.00,-.29,.25,-.29,-.50)*f5_4+
        mat4(.16,.03,.20,-.03,.18,.08,.06,-.10,-.01,-.47,.15,.27,.46,-.45,.14,.30)*f5_5+
        mat4(.28,-.20,-.06,-.04,-.34,-.03,.26,-.22,.06,-.22,.05,.02,.12,.12,.17,-.29)*f5_6+
        mat4(.26,-.15,.46,.04,-.09,.05,.00,.09,-.46,.19,-.11,-.13,.27,-.28,.79,.82)*f5_7+
        vec4(1.81,-.15,-.93,-.04))/2.4+f5_2;
    vec4 f6_3=sin(mat4(-.31,.32,.30,-.70,.09,.06,.21,.05,-.16,-.44,-.34,.15,-.49,.12,.71,-.72)*f5_0+
        mat4(.18,.19,-.20,-.01,-.05,.30,.14,-.40,-.17,.37,.48,-.07,.10,.02,-.32,-.11)*f5_1+
        mat4(.23,-.28,-.54,.65,.34,-.27,-.95,.43,-.19,.19,-.11,-.35,-.02,-.13,.45,-.19)*f5_2+
        mat4(.41,-.14,-.46,.40,.33,.10,-.19,-.07,-.41,-.03,.50,.08,.12,-.54,-.78,.64)*f5_3+
        mat4(.40,-.93,-1.05,.62,.03,-.44,-.72,.20,.16,.11,-.22,.52,.16,-.21,-.82,.43)*f5_4+
        mat4(-.29,.17,.07,-.15,.17,-.02,-.23,-.00,.02,.31,.48,-.09,-.47,.53,1.34,-.69)*f5_5+
        mat4(-.24,.03,.53,-.24,.04,-.13,-.08,.21,-.27,.08,.51,-.63,-.15,.18,-.28,.09)*f5_6+
        mat4(-.15,.21,.17,-.31,.15,.21,.27,-.31,.16,.12,-.34,.24,-.39,.67,1.19,-.87)*f5_7+
        vec4(1.19,.75,-.43,1.05))/2.4+f5_3;
    vec4 f6_4=sin(mat4(-.31,-.44,-.37,-.03,.04,-.15,.09,-.23,-.18,.44,.58,.53,-.80,.37,-.90,-.66)*f5_0+
        mat4(-.15,.11,-.02,.09,-.16,.07,-.43,-.23,-.09,-.02,-.49,-.36,.27,-.02,.20,.40)*f5_1+
        mat4(.50,.01,.74,.25,.31,.02,1.05,-.21,.38,-.20,.29,.02,-.53,-.17,-.30,.12)*f5_2+
        mat4(.46,-.10,.45,-.08,.47,-.04,.29,.21,-.41,-.03,-.64,.03,.49,.18,.73,.10)*f5_3+
        mat4(.52,-.15,1.24,.33,.44,.27,.91,.21,.18,-.22,.53,.19,.48,-.03,.97,-.03)*f5_4+
        mat4(-.05,-.25,-.09,.26,.07,-.17,.09,.05,-.55,.02,-.67,-.42,-.95,-.54,-1.53,-.44)*f5_5+
        mat4(-.03,.02,-.48,-.23,-.06,.04,.25,.08,-.50,-.21,-.66,-.34,.04,.32,.52,.37)*f5_6+
        mat4(.00,-.29,-.19,.34,-.10,.16,-.31,.09,-.03,.06,.19,-.03,-.62,-.08,-1.31,-.83)*f5_7+
        vec4(.22,1.33,1.39,-1.35))/2.4+f5_4;
    vec4 f6_5=sin(mat4(-.22,-.06,-.19,-.06,-.55,-.47,.16,.01,-.25,-.01,.41,-.40,.15,-.07,-.91,.01)*f5_0+
        mat4(.25,.29,-.28,.19,.02,-.57,.14,.18,-.04,.43,.27,.37,.15,-.09,.18,.01)*f5_1+
        mat4(.25,.62,.02,-.22,-.33,-.30,.48,-.21,-.20,-.21,.37,-.19,-.16,.14,.14,-.02)*f5_2+
        mat4(.30,.55,-.16,-.77,.07,-.04,-.16,-.15,.32,.23,-.53,.02,-.06,-.52,.34,-.37)*f5_3+
        mat4(-.35,.38,.71,-.52,.10,.28,.43,-.39,.28,.28,.06,.03,-.17,-.01,.01,-.38)*f5_4+
        mat4(.12,-.03,-.36,.17,.18,-.05,-.16,.21,-.17,.21,-.32,.20,.12,.31,-.19,.49)*f5_5+
        mat4(-.37,-.05,.09,.12,.10,.01,.07,-.20,.01,-.32,-.31,.04,-.20,-.05,-.02,-.38)*f5_6+
        mat4(.32,.09,-.17,.19,-.30,-.15,.28,.12,.33,-.15,-.20,-.13,.64,.25,-.83,.57)*f5_7+
        vec4(-.45,.30,1.30,.01))/2.4+f5_5;
    vec4 f6_6=sin(mat4(.50,.07,.04,-.31,.42,.26,-.07,.11,-.19,.36,-.44,.15,.18,-.52,.46,-.34)*f5_0+
        mat4(-.10,-.12,.31,.09,.17,.29,-.04,.03,-.07,-.62,-.13,-.34,-.14,.34,-.30,-.00)*f5_1+
        mat4(-.11,-.24,-.30,.21,-.28,-.03,.01,.59,.00,.18,-.45,.17,.16,-.47,.26,-.34)*f5_2+
        mat4(-.57,-.31,-.20,.63,.09,.02,.27,.17,.04,-.06,.31,.06,-.21,.41,-.59,.23)*f5_3+
        mat4(-.16,-.43,-.18,.67,-.49,.08,-.33,.15,.17,-.22,-.25,-.28,.06,-.06,-.15,.41)*f5_4+
        mat4(-.04,-.03,.09,.16,-.09,.27,-.24,.19,.04,-.13,.30,-.14,.50,-.66,.43,-.68)*f5_5+
        mat4(.30,-.02,.10,-.59,-.00,.42,.11,-.17,.20,-.10,.37,-.01,-.42,.19,-.09,.29)*f5_6+
        mat4(.40,-.49,.06,.27,.30,-.02,.25,-.06,-.13,.24,.19,-.07,.53,-.38,.20,-.65)*f5_7+
        vec4(.16,-.30,1.82,.75))/2.4+f5_6;
    vec4 f6_7=sin(mat4(-.16,.40,-.33,.55,-.16,.32,-.04,-.09,-.09,.06,.01,.01,-.15,.12,-.05,.34)*f5_0+
        mat4(-.01,.45,-.28,.04,-.16,.15,.16,.12,-.28,-.10,.19,.33,-.12,-.41,.14,-.09)*f5_1+
        mat4(.15,.11,.43,-.11,.25,.50,.52,-.30,.38,-.17,-.17,-.13,-.15,-.53,-.12,.29)*f5_2+
        mat4(.38,.35,.12,.10,.11,-.06,-.06,-.28,.22,.42,.16,.21,.02,.17,.54,.37)*f5_3+
        mat4(.17,.01,-.06,-.03,.06,-.19,.38,-.18,-.14,.22,-.03,.06,-.14,.22,.06,-.36)*f5_4+
        mat4(.28,-.09,-.00,.01,-.06,-.04,-.12,.03,.21,.34,-.21,.37,-.33,.10,-.35,.54)*f5_5+
        mat4(-.13,-.38,-.09,.44,-.16,.03,-.47,-.09,-.14,.03,.25,.38,.40,-.15,.27,-.15)*f5_6+
        mat4(-.10,-.18,-.06,.14,-.24,-.08,-.01,.13,-.10,.29,.35,.30,-.31,.09,-.21,.69)*f5_7+
        vec4(1.51,.86,-.69,.35))/2.4+f5_7;
    float return_val1 = dot(f6_0,vec4(-.04,-.02,.05,-.06))+
        dot(f6_1,vec4(.05,.02,.00,.04))+
        dot(f6_2,vec4(.02,.01,-.03,-.02))+
        dot(f6_3,vec4(.02,-.02,-.03,.03))+
        dot(f6_4,vec4(.03,.03,-.03,.02))+
        dot(f6_5,vec4(-.03,-.03,-.04,-.03))+
        dot(f6_6,vec4(-.03,.01,-.04,.03))+
        dot(f6_7,vec4(-.04,-.03,-.02,-.04))+
        -0.058* sin(iTime);
        
        // comment this line out to view averaged version
        return return_val1;
        
        p.y = -p.y;
    //neural networks can be really compact... when they want to be
    vec4 ff0_0=sin(p.y*vec4(-.36,3.91,-3.69,4.22)+p.z*vec4(2.66,2.44,3.63,.17)+p.x*vec4(4.17,-3.60,2.72,3.83)+vec4(-4.46,5.05,5.55,3.40));
    vec4 ff0_1=sin(p.y*vec4(-1.06,.99,2.93,-2.01)+p.z*vec4(4.36,4.04,-3.04,3.80)+p.x*vec4(1.44,-.18,-3.28,3.02)+vec4(-4.20,-1.99,-6.45,-7.70));
    vec4 ff0_2=sin(p.y*vec4(1.32,-2.91,-3.22,2.16)+p.z*vec4(.47,1.89,4.12,-3.69)+p.x*vec4(1.70,2.75,-3.95,2.05)+vec4(7.41,7.30,-3.35,4.89));
    vec4 ff0_3=sin(p.y*vec4(-.10,-1.56,3.64,-3.34)+p.z*vec4(-3.91,-1.39,-3.21,-1.08)+p.x*vec4(3.88,1.33,-1.01,2.47)+vec4(-.38,-7.95,-1.31,2.00));
    vec4 ff0_4=sin(p.y*vec4(2.73,-4.30,3.91,3.05)+p.z*vec4(4.31,4.08,3.19,-.84)+p.x*vec4(2.73,2.84,-2.84,-.57)+vec4(.31,-3.00,-4.98,4.69));
    vec4 ff0_5=sin(p.y*vec4(1.47,-1.32,-1.36,-1.11)+p.z*vec4(-.58,-.16,4.40,.07)+p.x*vec4(1.70,.12,3.56,2.22)+vec4(-3.33,-3.22,.81,6.42));
    vec4 ff0_6=sin(p.y*vec4(2.95,-2.96,2.12,-3.19)+p.z*vec4(-2.98,-.25,-3.79,-2.67)+p.x*vec4(.03,2.63,-.60,3.66)+vec4(-5.86,-5.04,-.64,6.42));
    vec4 ff0_7=sin(p.y*vec4(.33,-2.89,-2.13,-.34)+p.z*vec4(-3.16,.97,3.91,1.84)+p.x*vec4(-.42,-3.11,-.39,-4.40)+vec4(6.18,-7.99,-1.16,-3.38));
    vec4 ff1_0=sin(mat4(.24,-.06,.27,-.20,.24,-.25,.19,-.28,-.18,.34,.14,-.09,.25,-.19,.17,-.30)*ff0_0+
        mat4(.00,.19,-.04,.08,-.02,-.20,.07,-.16,-.27,-.18,-.37,-.21,-.19,-.15,.15,.07)*ff0_1+
        mat4(.19,.03,-.25,.39,-.02,-.15,.03,.23,.09,.02,.07,-.05,-.20,.25,-.19,-.34)*ff0_2+
        mat4(-.27,-.31,-.05,-.15,-.02,-.04,-.12,.01,.20,-.33,-.15,-.07,-.05,.04,-.77,.15)*ff0_3+
        mat4(.17,.10,-.14,-.21,.30,.04,-.23,-.11,.11,-.13,.33,-.17,.11,.03,-.32,-.38)*ff0_4+
        mat4(.01,-.17,.16,-.02,.02,.22,-.11,.09,.00,-.01,.28,.02,.11,.20,.40,-.26)*ff0_5+
        mat4(-.33,.07,.20,-.08,-.22,.22,.07,.19,.27,-.32,-.23,-.08,.13,-.22,-.10,.01)*ff0_6+
        mat4(.01,-.22,.35,-.00,.19,.28,-.04,-.46,-.31,-.05,.24,-.24,-.30,-.33,-.01,.00)*ff0_7+
        vec4(-2.22,-.05,-.81,-.60))/1.0+ff0_0;
    vec4 ff1_1=sin(mat4(.18,.12,.28,.64,.07,-.11,-.02,.11,-.33,-.50,-.14,-.11,-.57,-.17,.05,.15)*ff0_0+
        mat4(-.23,-.10,-.32,-.20,-.13,.24,.26,.23,-.18,.06,-.26,.39,-.12,.35,.04,.20)*ff0_1+
        mat4(.10,-.12,.14,.34,-.12,.04,.39,-.19,.25,.24,-.29,-.31,.11,.12,.07,-.20)*ff0_2+
        mat4(-.03,.08,-.17,-.16,.14,-.18,-.25,.06,-.08,.35,-.02,.33,.31,.09,-.10,-.10)*ff0_3+
        mat4(.14,-.36,-.12,-.67,.08,.04,.11,.19,.22,.43,-.21,-.21,-.11,.40,-.32,.25)*ff0_4+
        mat4(-.04,.13,-.01,.23,.29,.31,-.15,.08,-.30,-.24,-.38,-.16,-.25,-.40,.21,.06)*ff0_5+
        mat4(.29,-.13,.14,.09,.40,-.22,.24,-.43,.23,.42,-.07,.16,.04,-.20,.26,-.16)*ff0_6+
        mat4(-.03,.20,-.15,.34,-.27,-.20,.00,-.45,.05,.39,-.16,-.24,.25,.04,-.17,-.12)*ff0_7+
        vec4(1.74,-1.39,-.15,-.86))/1.0+ff0_1;
    vec4 ff1_2=sin(mat4(-.54,.29,.36,.34,-.01,-.05,-.28,.16,.30,.25,-.34,.05,.21,.06,-.16,-.22)*ff0_0+
        mat4(.05,.31,-.43,.30,.21,-.25,-.05,-.04,-.33,-.06,.65,-.27,-.15,-.17,-.07,.19)*ff0_1+
        mat4(-.42,-.11,-.04,.29,-.06,-.26,.06,.21,-.12,.36,-.31,-.20,-.38,-.11,.20,-.19)*ff0_2+
        mat4(-.04,.28,.20,.33,.17,.12,-.48,-.04,-.34,-.24,-.01,-.09,-.20,.13,.47,-.28)*ff0_3+
        mat4(.23,.17,.37,.11,-.30,-.22,.42,-.20,.08,-.03,.36,-.40,.02,-.36,.13,-.04)*ff0_4+
        mat4(.01,.33,-.26,.16,-.21,-.21,.43,.01,.34,-.09,-.05,.12,.19,-.15,.34,.31)*ff0_5+
        mat4(-.43,.16,.22,-.14,-.12,.11,.27,.13,-.16,.08,.22,-.54,.19,-.02,-.32,.15)*ff0_6+
        mat4(-.38,-.25,.33,-.25,-.25,-.64,.30,-.23,.20,-.01,.25,.03,-.07,.47,-.02,-.11)*ff0_7+
        vec4(-1.57,1.30,1.31,-.69))/1.0+ff0_2;
    vec4 ff1_3=sin(mat4(-.04,-.21,-.27,-.16,.38,.03,-.12,-.03,.32,.18,.27,-.25,-.43,.50,-.35,.13)*ff0_0+
        mat4(.37,.17,-.20,-.04,.40,-.59,.20,.39,.05,.14,-.17,-.20,.16,.18,.21,-.07)*ff0_1+
        mat4(.12,-.25,.40,-.46,-.36,-.16,-.11,.09,.26,-.48,.00,-.28,-.36,.21,-.11,-.01)*ff0_2+
        mat4(.13,-.20,-.06,-.25,.14,.29,-.31,.24,-.04,.29,.05,.16,-.18,.07,.28,-.28)*ff0_3+
        mat4(-.19,-.12,.33,-.12,.03,.32,-.03,.08,-.56,.19,.25,.08,.01,.32,.05,.14)*ff0_4+
        mat4(.55,-.02,.21,.13,-.26,.41,.02,-.29,.12,-.17,-.16,-.04,-.58,.10,.05,.20)*ff0_5+
        mat4(-.03,-.14,.13,.13,-.16,.19,.02,.09,-.34,.09,.02,.01,-.01,-.20,-.09,.13)*ff0_6+
        mat4(.19,-.19,-.17,.04,-.57,.08,.18,.32,.02,-.01,-.29,-.22,.22,.11,-.02,.04)*ff0_7+
        vec4(-2.23,.27,-.36,.14))/1.0+ff0_3;
    vec4 ff1_4=sin(mat4(-.22,-.17,.03,.13,.20,.35,-.18,-.10,-.13,.31,-.29,.17,-.23,.23,.47,-.01)*ff0_0+
        mat4(.34,.19,.04,-.14,-.09,.48,.24,-.27,-.19,.29,-.06,.12,.16,-.18,.27,.06)*ff0_1+
        mat4(-.17,-.25,-.30,-.38,.15,-.18,.16,-.12,.21,-.18,.18,-.19,.25,.30,.11,.27)*ff0_2+
        mat4(.29,-.15,-.06,.07,-.19,-.00,.13,.14,.36,.11,.42,.21,.25,-.21,-.28,-.03)*ff0_3+
        mat4(.69,-.28,-.19,.01,-.03,-.05,-.09,-.02,-.01,.15,-.06,.02,.15,.24,.04,-.15)*ff0_4+
        mat4(-.26,.02,.21,-.45,.11,-.08,.14,.36,.19,-.32,-.05,-.17,.40,-.06,.12,-.01)*ff0_5+
        mat4(-.06,.39,-.00,.02,-.16,.09,-.18,-.20,.36,.32,-.07,.19,.12,-.26,-.10,.29)*ff0_6+
        mat4(-.38,.38,.16,-.04,.32,.04,-.08,.07,.34,.13,-.04,.08,.25,-.26,-.13,.02)*ff0_7+
        vec4(-.71,-1.58,-2.04,-.56))/1.0+ff0_4;
    vec4 ff1_5=sin(mat4(.19,.20,-.43,-.12,.07,-.08,-.22,.18,.34,-.31,.29,.18,.16,.01,-.25,.13)*ff0_0+
        mat4(.25,.00,.02,-.13,-.14,.31,.30,.20,.22,-.11,.04,-.23,.17,-.19,-.18,-.16)*ff0_1+
        mat4(.30,.20,.13,-.43,.07,.03,.29,-.07,.36,.01,-.27,.24,-.35,-.15,.25,-.22)*ff0_2+
        mat4(-.02,-.04,.01,.25,.04,-.24,-.09,.38,.16,.14,.15,-.06,.33,.17,.11,-.04)*ff0_3+
        mat4(-.14,.05,.42,-.09,.13,-.04,.02,.20,-.02,-.29,-.46,.04,-.06,.08,-.19,.33)*ff0_4+
        mat4(.14,-.29,.08,-.31,-.20,.09,-.08,-.14,.01,.05,.18,-.08,-.39,-.04,.16,.20)*ff0_5+
        mat4(.00,-.01,-.26,.04,.05,.30,.12,-.18,.08,.44,-.05,-.40,.07,.48,-.11,.19)*ff0_6+
        mat4(.15,.13,-.13,.03,-.26,-.25,.01,-.32,-.26,-.16,-.09,-.04,-.06,-.37,-.25,.26)*ff0_7+
        vec4(-.39,1.49,-.68,-1.91))/1.0+ff0_5;
    vec4 ff1_6=sin(mat4(.50,-.02,-.69,.07,.06,-.07,-.06,-.12,-.25,-.01,.36,-.01,-.10,.17,.35,-.60)*ff0_0+
        mat4(.31,.07,-.18,-.35,.66,.17,-.34,-.07,-.15,.39,-.14,.14,-.16,-.15,.18,-.03)*ff0_1+
        mat4(-.11,.14,.21,-.07,.16,-.33,-.24,.08,-.12,.06,-.20,-.20,.21,-.23,-.21,.24)*ff0_2+
        mat4(.06,-.27,-.25,.11,.11,.24,-.18,.25,.28,-.24,-.13,-.17,-.22,-.39,-.23,.46)*ff0_3+
        mat4(-.61,.14,.33,.63,.22,-.01,-.29,.20,-.46,-.10,.36,.46,.29,.01,.08,-.34)*ff0_4+
        mat4(.33,.33,-.26,-.02,-.48,-.13,-.03,-.28,-.03,-.26,.16,.22,.31,.04,-.28,-.09)*ff0_5+
        mat4(-.13,-.04,-.25,.22,-.45,.01,.19,.28,.36,-.27,-.22,-.05,-.12,-.05,.01,.34)*ff0_6+
        mat4(-.06,.11,.20,-.00,.06,.01,.30,.16,-.17,.03,.20,-.05,-.21,-.27,-.35,.09)*ff0_7+
        vec4(1.97,2.24,-1.04,-1.98))/1.0+ff0_6;
    vec4 ff1_7=sin(mat4(.14,.48,-.15,-.37,.21,.26,-.16,-.14,-.17,.04,.35,.27,-.30,-.34,.26,-.18)*ff0_0+
        mat4(.13,-.13,-.46,-.43,-.02,.54,-.21,.03,.39,-.14,.23,-.00,.30,-.12,-.04,-.02)*ff0_1+
        mat4(.01,-.02,-.32,.13,.23,.01,-.22,-.16,.15,-.17,-.23,.00,-.45,.15,-.09,-.49)*ff0_2+
        mat4(.23,.10,-.10,.41,.16,.34,-.47,.18,-.12,.03,-.15,-.20,-.19,-.37,.08,-.03)*ff0_3+
        mat4(-.29,-.26,.17,.08,-.19,.05,.11,-.01,-.15,-.27,.26,-.20,-.25,-.40,-.22,-.17)*ff0_4+
        mat4(.37,-.14,.25,.31,.30,-.25,.15,-.35,-.09,-.13,-.07,.11,-.15,.17,-.29,.27)*ff0_5+
        mat4(-.16,.04,-.17,-.11,.23,.15,-.25,.01,.22,.16,.08,-.26,.41,-.14,-.17,.17)*ff0_6+
        mat4(-.15,-.03,-.29,-.06,-.68,-.18,.22,-.45,.25,-.12,-.11,-.27,.10,.24,.13,-.18)*ff0_7+
        vec4(-.06,-.40,1.48,-1.43))/1.0+ff0_7;
    vec4 ff2_0=sin(mat4(.31,.34,.12,.13,-.10,.27,-.33,-.21,-.19,.27,-.03,.13,.18,-.29,-.25,-.03)*ff1_0+
        mat4(.21,-.36,-.45,.11,.00,.05,-.36,-.32,-.06,.24,.21,.07,-.14,.15,-.22,.31)*ff1_1+
        mat4(.32,-.14,-.17,.21,.17,.09,-.15,-.26,-.13,.12,.27,-.35,.21,.11,-.15,-.13)*ff1_2+
        mat4(-.25,-.08,.01,.37,-.27,.17,.04,-.21,-.03,-.16,.14,.08,-.13,-.04,.33,-.27)*ff1_3+
        mat4(-.02,.18,.03,-.32,.06,-.20,.06,.05,-.05,.26,.15,-.15,-.14,-.22,-.05,.18)*ff1_4+
        mat4(.16,-.05,-.31,-.07,.27,.15,-.08,.39,.19,.14,-.28,-.06,-.33,.03,.04,-.16)*ff1_5+
        mat4(.13,-.20,-.09,-.06,-.14,.15,.16,.14,-.29,-.32,.17,.07,.29,.32,.22,-.09)*ff1_6+
        mat4(-.20,-.04,.18,.10,.28,.31,-.14,-.24,.17,-.15,-.03,.16,.34,-.31,.30,-.14)*ff1_7+
        vec4(-.75,-.96,1.04,1.19))/1.4+ff1_0;
    vec4 ff2_1=sin(mat4(.05,-.44,-.16,-.17,.03,.19,-.28,.36,-.18,-.10,.31,-.06,.19,.14,-.13,.08)*ff1_0+
        mat4(-.46,-.46,-.42,-.13,.08,.06,-.22,-.10,.41,-.47,.11,.15,-.14,.37,.13,.43)*ff1_1+
        mat4(.40,.35,.25,.51,-.21,.06,-.28,.35,-.08,-.39,.02,.19,-.21,-.25,.00,.34)*ff1_2+
        mat4(.60,.17,-.03,.45,-.39,-.29,.01,.03,.24,.50,.28,.12,.06,-.54,-.06,.36)*ff1_3+
        mat4(.41,-.07,.25,.34,.18,.18,-.18,.30,.31,.47,-.01,.28,-.02,.12,-.17,-.30)*ff1_4+
        mat4(.20,-.40,-.04,-.54,-.16,.22,-.05,.10,-.02,.28,-.49,.21,.17,-.16,.02,.24)*ff1_5+
        mat4(-.03,.06,-.01,.25,-.22,-.18,-.17,-.01,.01,.03,-.07,-.02,.36,.23,-.26,.52)*ff1_6+
        mat4(.28,.09,.25,-.02,.11,-.10,-.21,.07,.29,.11,.06,-.30,-.22,-.43,-.07,-.44)*ff1_7+
        vec4(-1.37,-1.80,-.48,-2.17))/1.4+ff1_1;
    vec4 ff2_2=sin(mat4(.17,.06,.09,.15,-.07,-.21,-.27,.19,-.00,-.30,.03,-.02,-.19,.29,.05,-.06)*ff1_0+
        mat4(-.17,-.31,-.06,-.12,-.23,-.63,.02,-.33,.23,.31,.07,.33,-.08,-.83,-.49,.21)*ff1_1+
        mat4(.07,.79,.27,.06,.05,.44,.10,.08,-.15,.26,-.18,-.04,.37,-.02,.30,-.19)*ff1_2+
        mat4(-.08,.46,.09,-.03,-.09,-.44,-.01,.33,.08,.10,-.06,-.13,-.22,.54,.08,.26)*ff1_3+
        mat4(-.16,-.17,-.23,.32,-.03,-.15,.38,.03,-.15,.15,.43,-.45,.20,-.12,.23,.23)*ff1_4+
        mat4(.49,-.44,.29,.40,-.29,-.08,-.39,.16,.06,-.36,.01,-.21,-.02,.20,.21,.17)*ff1_5+
        mat4(.03,-.07,-.08,-.12,.13,-.19,.06,-.17,.44,.94,.38,.39,-.11,.18,.18,.09)*ff1_6+
        mat4(-.05,.26,.01,-.06,.15,.30,-.06,.25,-.06,-.06,-.30,.41,.25,-.22,.04,.10)*ff1_7+
        vec4(-.45,-.38,1.48,-1.50))/1.4+ff1_2;
    vec4 ff2_3=sin(mat4(.14,.23,.30,.17,.04,.06,.20,-.36,-.16,.15,-.05,-.20,-.10,.04,.01,-.19)*ff1_0+
        mat4(-.19,.13,-.06,-.20,.34,-.24,-.20,.37,-.25,.01,.00,-.14,.32,-.14,-.39,-.08)*ff1_1+
        mat4(.12,.15,.02,-.26,-.09,-.13,.32,-.20,.12,-.09,-.08,.13,-.11,.20,.03,-.09)*ff1_2+
        mat4(-.29,-.02,.03,.13,.01,.34,.26,.01,.46,-.25,-.31,-.01,.13,-.27,.03,-.05)*ff1_3+
        mat4(.21,.15,-.73,.01,.06,.34,.05,-.03,.20,.34,-.08,-.19,-.09,.02,-.04,.33)*ff1_4+
        mat4(-.07,-.02,.15,-.07,-.28,.39,-.09,.03,.35,.08,-.05,-.05,.34,.12,-.01,.22)*ff1_5+
        mat4(-.28,.25,.31,.15,.09,-.13,-.46,-.12,-.42,-.30,.28,.20,.20,.33,-.25,-.10)*ff1_6+
        mat4(.45,-.04,.43,.41,.14,-.03,.27,.32,-.06,-.07,-.26,.02,.13,.11,-.14,.20)*ff1_7+
        vec4(-2.16,-1.49,-1.83,.87))/1.4+ff1_3;
    vec4 ff2_4=sin(mat4(-.31,.13,.18,.04,.16,.34,-.03,-.10,.26,-.24,.17,-.09,-.25,-.23,.13,.07)*ff1_0+
        mat4(.51,-.22,.40,.07,.51,-.33,.06,.23,-.08,-.31,.23,.01,.42,.44,-.09,.09)*ff1_1+
        mat4(-.35,.29,-.01,-.17,.13,-.06,-.22,-.34,.12,-.19,.04,-.12,.24,-.05,-.07,.02)*ff1_2+
        mat4(.26,.39,-.17,-.25,-.21,.10,.26,.24,-.14,.02,-.11,-.20,.24,-.01,-.14,-.20)*ff1_3+
        mat4(.22,.54,-.11,.09,.39,.19,-.03,.03,.34,.02,-.06,-.33,.01,.12,.33,.11)*ff1_4+
        mat4(-.19,.15,-.10,.17,-.00,.16,-.43,-.02,.48,-.09,.18,.08,.59,.03,-.10,.05)*ff1_5+
        mat4(.10,-.38,-.04,.40,-.18,-.01,-.08,-.11,-.64,-.37,.29,.19,.43,.22,-.11,-.04)*ff1_6+
        mat4(.07,-.34,-.11,.40,.10,.01,.30,.27,-.06,.35,-.36,.07,-.04,.12,.28,.18)*ff1_7+
        vec4(-.80,1.64,-.76,.72))/1.4+ff1_4;
    vec4 ff2_5=sin(mat4(.01,.04,-.06,-.02,-.31,.10,.24,-.08,.35,.10,.35,.05,.10,-.06,-.04,.11)*ff1_0+
        mat4(.21,.43,.57,-.10,.38,.18,-.14,-.21,-.19,.18,-.39,.07,.17,.27,.42,.29)*ff1_1+
        mat4(-.33,-.60,-.18,-.04,.01,.32,.01,-.08,.03,-.19,.08,.16,-.55,.16,-.44,-.27)*ff1_2+
        mat4(-.02,-.18,-.20,.30,.05,-.12,-.24,-.29,-.10,.07,.01,.11,-.33,.15,-.38,-.21)*ff1_3+
        mat4(.05,-.19,.22,.11,-.35,.24,-.05,.03,-.23,.35,-.32,.15,.18,.31,.16,-.12)*ff1_4+
        mat4(.13,-.23,.06,.42,.16,.27,.48,.33,.08,-.13,-.29,-.01,-.09,-.02,.03,.23)*ff1_5+
        mat4(-.42,-.02,-.09,-.25,.08,.16,.11,.22,-.37,-.05,.14,-.23,.08,.15,-.02,.16)*ff1_6+
        mat4(-.22,.18,-.20,.03,-.57,-.30,.03,-.19,.29,.14,.38,.23,.06,.18,-.03,-.05)*ff1_7+
        vec4(.92,1.27,.72,-1.02))/1.4+ff1_5;
    vec4 ff2_6=sin(mat4(.05,.50,.23,.09,.09,.20,-.14,-.19,-.13,-.04,-.15,.22,-.05,.13,-.04,.49)*ff1_0+
        mat4(.41,.09,-.21,.54,-.10,.24,.21,.46,-.21,-.01,-.29,-.27,.34,-.08,.29,-.22)*ff1_1+
        mat4(.40,-.28,-.47,-.25,.20,-.08,-.31,-.50,-.48,.42,-.08,.19,-.24,.27,.13,.13)*ff1_2+
        mat4(.04,.41,.10,-.09,-.12,.41,.07,.30,.33,-.04,-.10,-.17,-.09,.00,.24,.04)*ff1_3+
        mat4(-.05,-.09,.27,-.17,-.13,.01,-.05,.01,-.23,-.02,.32,-.25,-.26,.15,-.20,-.19)*ff1_4+
        mat4(.15,.23,.02,.12,.21,-.44,.16,-.30,-.12,.16,-.06,.03,.11,-.21,-.25,.01)*ff1_5+
        mat4(-.38,.50,.13,.50,-.27,.11,-.25,.08,-.24,.16,.04,-.52,.03,.13,.08,-.30)*ff1_6+
        mat4(-.06,.29,-.07,.25,-.22,.21,.04,.10,.21,-.31,-.00,-.29,-.39,-.08,.07,.20)*ff1_7+
        vec4(-1.72,-.71,-1.40,.83))/1.4+ff1_6;
    vec4 ff2_7=sin(mat4(-.09,-.29,-.24,-.26,.33,-.33,.39,.13,-.06,-.17,.24,-.26,.23,.09,.21,-.08)*ff1_0+
        mat4(.50,.11,.17,.13,.40,-.03,.22,-.14,.22,.31,.26,-.16,.34,-.18,.29,.26)*ff1_1+
        mat4(-.04,.33,-.26,-.18,.16,-.12,.34,-.02,.11,-.11,-.25,-.26,.27,.54,-.03,-.45)*ff1_2+
        mat4(-.05,.08,.16,.03,-.25,-.07,-.16,.15,.32,.01,-.03,.29,-.09,-.07,.24,.24)*ff1_3+
        mat4(.04,-.14,-.03,.30,-.02,.08,.05,.14,-.27,-.19,.47,.03,-.02,.17,.04,.03)*ff1_4+
        mat4(-.09,.14,-.39,-.30,-.42,-.31,.11,.09,-.02,.28,.32,-.25,.36,-.06,.18,.12)*ff1_5+
        mat4(.11,.36,-.07,-.47,-.23,.11,-.19,.14,-.18,.16,-.34,-.13,.18,.09,.32,.12)*ff1_6+
        mat4(-.05,.05,-.34,-.23,.04,.08,-.29,-.15,-.37,-.05,.17,.44,-.38,-.28,-.06,.32)*ff1_7+
        vec4(.89,-.88,-.86,1.29))/1.4+ff1_7;
    vec4 ff3_0=sin(mat4(-.25,-.17,-.39,-.08,.27,.19,.12,.14,.28,.02,-.27,-.09,-.41,.06,.22,-.31)*ff2_0+
        mat4(-.09,-.21,-.44,-.11,-.08,-.14,-.06,.07,.19,.13,-.11,.22,.35,-.46,.27,.16)*ff2_1+
        mat4(.41,-.01,-.14,-.12,.02,.04,-.17,.33,-.07,-.04,.13,.53,.46,.02,-.01,.13)*ff2_2+
        mat4(.09,.09,.05,-.31,-.09,.28,.05,-.17,.28,.10,.14,.11,.07,-.08,.18,-.26)*ff2_3+
        mat4(-.01,-.08,.44,.26,-.21,-.04,.06,-.16,.39,.22,-.20,.25,.05,.06,-.19,-.17)*ff2_4+
        mat4(-.19,-.06,.12,-.34,-.26,-.28,-.16,.35,-.06,-.09,.06,.09,-.20,-.21,-.26,-.05)*ff2_5+
        mat4(-.00,.14,-.02,.24,-.00,-.11,-.18,.33,-.03,.15,.10,-.11,.28,-.26,.31,-.04)*ff2_6+
        mat4(.22,-.26,-.09,-.12,.17,-.32,.13,.30,.19,.14,.02,-.30,.25,-.09,.03,-.13)*ff2_7+
        vec4(.23,-1.25,-1.21,.23))/1.7+ff2_0;
    vec4 ff3_1=sin(mat4(-.16,-.30,-.08,-.12,.11,-.18,.27,.24,-.07,.29,.12,-.13,-.01,.05,-.06,-.30)*ff2_0+
        mat4(.11,.21,.37,-.09,-.09,.07,-.10,-.11,-.10,-.25,.22,-.02,.13,-.34,.35,.10)*ff2_1+
        mat4(.05,-.05,.20,-.25,.19,-.48,.10,.03,.11,.23,.02,-.15,-.02,-.40,.50,-.04)*ff2_2+
        mat4(-.45,-.08,.35,.08,-.19,-.16,.27,.08,-.43,.09,.03,.06,.06,.09,-.03,.06)*ff2_3+
        mat4(.00,-.16,.22,.14,.08,.44,.22,.04,-.01,.45,.03,.41,-.30,.06,-.07,.16)*ff2_4+
        mat4(-.16,.29,-.23,.07,.23,-.01,.33,.04,-.15,.16,.02,-.16,.08,-.33,.18,.14)*ff2_5+
        mat4(.21,.21,-.27,.08,.26,-.08,.32,-.18,-.19,.29,-.23,.02,-.19,.30,.23,.43)*ff2_6+
        mat4(-.24,.41,-.27,-.18,.11,-.24,.00,-.06,.26,.35,.01,-.16,-.09,.23,.14,.03)*ff2_7+
        vec4(.75,.13,-1.05,2.00))/1.7+ff2_1;
    vec4 ff3_2=sin(mat4(-.23,-.30,.01,-.13,-.21,-.06,-.12,-.04,.03,.14,-.30,-.24,.03,.31,.20,.14)*ff2_0+
        mat4(.04,.16,.45,.22,-.49,-.12,.32,-.33,-.12,.03,.06,.05,-.11,-.65,.07,.17)*ff2_1+
        mat4(.56,-.07,.14,.05,-.06,.33,-.06,.49,-.35,.10,-.31,.09,-.30,-.18,-.35,-.03)*ff2_2+
        mat4(.35,.04,.13,.39,-.17,-.07,-.50,.02,.24,-.02,.21,.14,.19,.23,-.05,.05)*ff2_3+
        mat4(-.12,-.11,-.58,-.25,-.03,-.00,-.15,.47,.01,-.24,.16,.27,-.16,-.07,-.05,.03)*ff2_4+
        mat4(.11,.35,.12,.10,.05,-.14,.01,.23,-.02,.07,.17,.11,-.27,.05,.36,.18)*ff2_5+
        mat4(-.25,-.60,-.32,-.05,-.23,-.07,-.19,.03,-.11,-.14,.12,-.20,-.53,-.09,-.29,.44)*ff2_6+
        mat4(-.02,-.09,-.36,-.46,-.16,.08,-.26,-.09,.15,.18,.51,.47,-.13,-.48,.51,.09)*ff2_7+
        vec4(1.98,.39,-.47,1.49))/1.7+ff2_2;
    vec4 ff3_3=sin(mat4(.06,.09,.19,.31,-.21,.19,-.18,-.26,-.17,-.36,.19,-.39,-.09,-.37,-.12,.28)*ff2_0+
        mat4(.42,.56,-.40,.60,-.05,.13,-.25,.18,.02,.17,-.14,.01,-.43,.61,-.17,.49)*ff2_1+
        mat4(.23,-.42,.27,.46,-.33,.04,.06,-.13,-.39,-.21,.25,-.19,-.10,.00,.24,.14)*ff2_2+
        mat4(.18,-.18,-.16,.15,-.02,.07,-.01,-.02,.13,.37,.56,.18,-.07,-.17,.35,-.21)*ff2_3+
        mat4(-.15,.36,-.11,-.20,.37,.38,.31,-.16,-.04,-.04,-.06,.04,.23,-.34,.01,.29)*ff2_4+
        mat4(.31,.02,.14,.27,.06,.18,-.21,.03,-.32,.46,-.16,.14,-.14,.36,-.27,.23)*ff2_5+
        mat4(.05,-.40,.16,-.28,-.17,.08,.22,-.02,.17,-.13,-.27,.30,-.44,.66,.19,-.04)*ff2_6+
        mat4(.25,-.11,-.25,-.55,.08,.09,-.18,-.08,.02,.00,.20,-.20,.30,.44,-.29,.46)*ff2_7+
        vec4(.70,1.07,.01,-1.23))/1.7+ff2_3;
    vec4 ff3_4=sin(mat4(-.17,-.15,.12,.28,-.46,.34,.31,.42,-.24,.45,.10,-.06,.16,.47,.07,-.34)*ff2_0+
        mat4(-.35,-.09,.20,-.29,.46,-.07,-.26,-.07,-.22,-.20,-.03,-.09,-.66,.34,-.21,.01)*ff2_1+
        mat4(-.26,-.23,.33,.03,.19,-.45,-.27,-.10,.43,-.15,-.21,.30,.28,.27,.26,.22)*ff2_2+
        mat4(-.07,.28,.32,-.22,.23,-.39,.17,.07,-.23,-.09,-.23,-.02,-.10,-.11,.08,.22)*ff2_3+
        mat4(-.28,-.10,.18,.26,-.27,.03,.24,-.44,-.26,.38,-.01,.02,.15,-.18,-.33,-.01)*ff2_4+
        mat4(-.24,.16,.22,-.34,-.34,.08,-.02,-.32,-.26,.10,-.03,-.34,-.15,-.04,.05,-.29)*ff2_5+
        mat4(.57,.31,-.10,.52,.31,.02,-.26,.46,.25,-.46,-.22,.08,-.36,.31,.18,.13)*ff2_6+
        mat4(.10,.04,.27,-.13,.27,-.14,-.09,.30,.26,-.19,-.18,-.00,-.30,-.25,-.03,-.47)*ff2_7+
        vec4(-.08,.24,-.37,-.53))/1.7+ff2_4;
    vec4 ff3_5=sin(mat4(.13,.05,-.11,.11,.21,.11,-.40,-.02,.02,.31,.12,.14,.06,.25,.39,.16)*ff2_0+
        mat4(.11,.16,-.06,.11,-.04,-.08,.05,-.13,.02,.30,-.05,-.15,-.09,-.27,-.42,-.16)*ff2_1+
        mat4(.30,-.24,-.18,-.06,-.36,-.07,.01,-.67,-.01,.14,-.09,.03,-.18,-.13,-.22,-.08)*ff2_2+
        mat4(-.11,-.09,.31,.36,-.23,-.16,.00,.07,.48,-.28,-.34,.04,-.23,-.13,-.18,-.15)*ff2_3+
        mat4(-.22,-.07,-.36,-.19,-.09,.22,.02,.23,.18,.22,.16,.29,-.06,-.19,.39,-.20)*ff2_4+
        mat4(-.05,.35,.26,.33,-.26,-.00,-.34,-.06,.13,-.24,-.25,-.27,-.07,.03,-.34,-.28)*ff2_5+
        mat4(.15,.01,.03,.20,.31,.24,.18,-.03,.09,-.23,.31,-.05,-.13,-.22,-.28,-.07)*ff2_6+
        mat4(-.27,.11,.16,.35,-.18,-.25,.35,-.18,.30,.17,-.12,-.23,.12,.03,-.01,.04)*ff2_7+
        vec4(.96,-1.20,-1.14,-1.00))/1.7+ff2_5;
    vec4 ff3_6=sin(mat4(.22,-.36,.21,-.35,-.24,.22,.17,-.28,-.06,-.15,-.20,.07,.15,-.26,-.16,.13)*ff2_0+
        mat4(.14,-.19,.37,-.01,.25,.32,-.10,-.19,.21,.39,-.26,-.29,.16,.00,.63,.51)*ff2_1+
        mat4(.18,-.04,.11,-.23,.04,.28,.14,.00,-.04,.03,.04,.10,.24,.51,-.07,.20)*ff2_2+
        mat4(-.14,.08,.01,.12,-.12,-.16,-.32,-.04,.00,-.10,.17,.45,.16,.18,.07,.37)*ff2_3+
        mat4(.18,-.32,-.01,.12,-.32,-.28,.04,.10,.01,.21,.12,-.05,.04,.17,-.30,.11)*ff2_4+
        mat4(-.28,.08,-.39,.22,.11,-.15,-.05,.14,-.02,-.15,.08,.02,-.32,.36,.22,-.09)*ff2_5+
        mat4(.13,.31,-.19,.27,-.10,.06,-.21,.01,.07,.11,.17,.34,.15,.09,.19,.18)*ff2_6+
        mat4(-.02,-.23,-.07,-.01,.34,.29,.02,-.17,-.08,-.04,.11,.23,-.11,-.44,-.07,-.44)*ff2_7+
        vec4(-1.22,1.17,-1.00,.20))/1.7+ff2_6;
    vec4 ff3_7=sin(mat4(-.14,-.11,-.12,.12,-.14,.21,.11,-.03,.04,.39,.18,-.07,.06,-.18,.00,-.17)*ff2_0+
        mat4(.23,.18,-.08,-.40,-.01,.39,-.26,.13,.03,.23,-.28,.06,-.07,.45,.28,.01)*ff2_1+
        mat4(.14,.18,-.06,-.15,.07,-.22,-.24,.36,.04,-.21,-.05,.29,.09,.14,-.09,.25)*ff2_2+
        mat4(-.13,-.39,.18,-.04,.07,-.45,-.08,.30,-.43,.30,.14,-.34,-.25,.28,.04,.04)*ff2_3+
        mat4(.13,.26,-.03,.55,.18,.43,-.18,-.03,.34,-.16,.16,-.14,.01,-.02,-.08,-.01)*ff2_4+
        mat4(.45,.15,-.20,-.34,.31,.09,.01,-.22,-.27,.22,.19,-.20,.37,.02,.08,-.03)*ff2_5+
        mat4(.19,-.47,.24,.33,.01,-.20,.15,.01,.22,-.03,.22,-.15,.02,.07,.08,.14)*ff2_6+
        mat4(-.23,.06,-.22,-.09,.16,-.05,.19,.05,-.42,-.31,-.31,-.38,.08,.05,-.16,-.15)*ff2_7+
        vec4(-.23,1.33,-1.81,.90))/1.7+ff2_7;
    vec4 ff4_0=sin(mat4(.01,.04,-.20,-.10,-.04,-.06,.10,.07,-.19,-.03,.17,-.26,-.40,-.14,-.21,.30)*ff3_0+
        mat4(-.54,.00,-.02,-.07,-.13,.38,-.32,.32,-.43,-.10,-.35,.38,.24,.24,-.10,-.11)*ff3_1+
        mat4(.14,-.19,.02,.16,.11,.13,.38,-.14,.31,-.19,.25,-.67,-.44,.04,-.03,-.47)*ff3_2+
        mat4(-.05,.08,.01,.30,.04,.25,.39,-.37,.02,-.36,.12,.39,.56,-.05,-.10,-.20)*ff3_3+
        mat4(.40,.14,-.11,-.60,.34,.15,.03,-.39,-.04,-.05,-.26,-.18,-.14,-.25,.16,-.22)*ff3_4+
        mat4(.08,-.16,-.23,.31,.39,-.09,-.14,-.10,-.55,.10,.09,.39,-.04,.22,.01,.61)*ff3_5+
        mat4(.35,.15,-.10,-.34,.22,-.09,.02,-.41,-.36,.04,.06,.35,-.13,.10,-.02,-.02)*ff3_6+
        mat4(-.37,.14,.04,-.41,-.34,.30,.18,-.32,-.04,-.06,-.26,.46,-.70,.07,-.17,.28)*ff3_7+
        vec4(.12,-.45,-.01,-1.54))/2.0+ff3_0;
    vec4 ff4_1=sin(mat4(.33,-.00,.47,-.21,-.01,.01,.27,-.33,-.02,-.07,.05,-.05,-.44,-.08,-.50,-.18)*ff3_0+
        mat4(.26,-.00,-.19,-.21,.00,-.10,.18,-.23,-.16,.15,.20,.18,-.35,-.23,.53,.09)*ff3_1+
        mat4(-.11,.05,-.06,-.13,.11,.55,-.10,-.20,-.08,.47,.18,.37,-.04,.30,.51,-.16)*ff3_2+
        mat4(.14,-.34,-.20,-.07,-.21,.27,.49,-.21,-.18,-.54,.06,.02,.10,.11,.13,-.16)*ff3_3+
        mat4(.08,.34,.19,-.24,-.30,-.26,.42,-.12,-.10,-.20,-.14,-.15,-.18,-.07,-.09,.19)*ff3_4+
        mat4(-.28,-.56,.21,.12,.11,.07,-.18,.41,-.02,-.07,.33,-.30,.03,.11,.37,.03)*ff3_5+
        mat4(-.19,.08,-.52,-.12,.15,.41,-.02,.40,-.07,-.30,.03,.02,-.12,.13,.18,-.33)*ff3_6+
        mat4(.24,-.10,-.21,.12,.29,.17,.38,-.08,-.21,-.07,.09,.12,.22,-.30,.18,-.01)*ff3_7+
        vec4(-.92,-.70,-.39,-.30))/2.0+ff3_1;
    vec4 ff4_2=sin(mat4(.34,-.02,-.18,.27,.36,-.43,.22,-.06,.62,-.21,-.14,.18,-.33,.12,-.21,.06)*ff3_0+
        mat4(-.18,.01,.27,.20,-.50,-.10,-.15,.13,-.10,-.30,-.22,.01,.53,-.05,-.24,.13)*ff3_1+
        mat4(.11,.31,-.18,.13,-.63,-.59,.08,-.07,.18,-.55,.01,-.09,-.43,-.21,-.24,.09)*ff3_2+
        mat4(-.31,.41,.17,-.02,.29,-.40,.35,-.43,.11,.55,.08,-.12,.01,-.34,-.20,-.15)*ff3_3+
        mat4(.45,-.21,-.19,-.26,.62,-.06,.08,.36,.69,-.01,-.22,-.10,-.33,.16,-.11,-.29)*ff3_4+
        mat4(-.18,.41,.33,-.16,-.22,-.42,.26,-.44,-.21,.51,-.22,.14,-.69,.18,.18,.21)*ff3_5+
        mat4(.00,.07,-.15,-.10,.02,-.49,-.24,-.28,.25,.29,-.24,.13,.81,-.20,.06,.40)*ff3_6+
        mat4(.22,.27,.06,.17,.23,-.34,.08,.22,.05,.20,.23,-.06,-.21,.69,-.15,.59)*ff3_7+
        vec4(1.56,-.72,1.94,-.17))/2.0+ff3_2;
    vec4 ff4_3=sin(mat4(.13,.24,.07,.17,-.05,.08,.13,.23,-.12,-.18,.01,-.01,.20,.02,.29,-.08)*ff3_0+
        mat4(-.24,-.03,.12,-.23,.55,.19,.21,.01,.24,-.43,-.04,.11,-.08,-.10,.02,.14)*ff3_1+
        mat4(-.05,.02,.03,.09,.14,-.09,-.60,.09,-.11,-.27,-.12,.45,-.52,-.05,-.08,-.00)*ff3_2+
        mat4(-.17,-.25,-.08,.12,-.03,.31,.23,.25,.30,.26,.23,.05,.43,.37,.18,.21)*ff3_3+
        mat4(.03,-.18,-.14,.30,.15,-.09,.31,.32,-.38,-.07,.49,.01,-.25,-.28,-.02,-.14)*ff3_4+
        mat4(.34,.24,.34,-.15,.15,.19,.19,.17,-.19,-.30,.22,-.39,.66,.39,.48,.11)*ff3_5+
        mat4(-.50,-.02,-.01,-.11,-.54,-.09,.10,-.02,.07,-.04,.22,-.01,-.31,-.00,.09,.01)*ff3_6+
        mat4(-.27,.31,.23,.09,-.21,-.38,.21,.05,-.05,.34,-.11,-.15,-.23,-.04,.42,-.01)*ff3_7+
        vec4(.53,-1.43,-.37,-1.15))/2.0+ff3_3;
    vec4 ff4_4=sin(mat4(.16,.29,-.21,-.25,-.03,.26,.24,-.41,.18,.04,.11,-.07,.49,-.14,.17,.47)*ff3_0+
        mat4(.19,-.24,.23,-.01,.06,.06,.71,.05,-.09,.06,-.05,-.18,.55,.24,-.10,-.95)*ff3_1+
        mat4(.43,.12,-.30,-.07,-.54,-.00,-.09,.37,-.66,.04,-.42,.01,-.35,-.02,.03,-.02)*ff3_2+
        mat4(.11,.29,-.03,.24,-.68,.03,.07,-.23,.38,-.01,-.33,-.12,.13,.23,-.14,.35)*ff3_3+
        mat4(-.74,.08,-.04,-.37,-.06,.28,.16,-.59,-.06,.37,-.36,-.11,.01,.00,-.05,.24)*ff3_4+
        mat4(.55,-.31,.45,.08,-.29,-.14,.10,.15,.24,-.22,-.03,.03,.13,-.29,-.17,.11)*ff3_5+
        mat4(-.48,.16,-.23,.45,-.27,-.07,-.02,.14,.47,.17,-.14,.02,-.20,.00,-.40,-.66)*ff3_6+
        mat4(-.35,-.56,.14,.30,-.35,.02,.07,-.11,.27,.01,-.32,-.17,.69,-.21,.22,.39)*ff3_7+
        vec4(2.07,-1.26,-1.56,-.64))/2.0+ff3_4;
    vec4 ff4_5=sin(mat4(.47,.13,.16,.03,.27,-.16,.22,-.18,.33,.24,-.12,.44,.22,.06,.07,-.17)*ff3_0+
        mat4(-.05,.04,.30,.10,.15,.30,-.23,-.26,-.07,.09,.27,.05,-.20,.05,.15,.12)*ff3_1+
        mat4(-.51,-.03,-.09,.18,-.39,.27,.36,-.35,.03,-.07,-.21,-.08,.35,-.26,.09,-.23)*ff3_2+
        mat4(.24,-.35,.03,.33,-.22,.11,-.21,-.23,-.21,-.10,.29,.31,.17,-.07,-.31,-.18)*ff3_3+
        mat4(-.17,-.35,-.02,-.02,-.22,-.34,.21,.09,-.31,-.19,.20,.32,-.13,-.25,-.26,-.06)*ff3_4+
        mat4(.04,.22,.14,.20,-.23,-.00,-.15,-.01,.30,-.09,.52,.09,.45,.21,.25,-.31)*ff3_5+
        mat4(-.15,.19,-.65,-.11,-.04,.01,-.29,-.03,-.34,-.13,.28,.21,.02,.30,.36,.30)*ff3_6+
        mat4(-.11,-.09,-.33,.53,-.15,-.34,.19,-.24,.10,.28,.10,-.03,-.25,.30,.21,.55)*ff3_7+
        vec4(-1.41,-.90,.92,-.08))/2.0+ff3_5;
    vec4 ff4_6=sin(mat4(.30,-.15,.38,.17,-.14,.13,-.18,-.14,.05,.02,.09,.35,-.09,.15,-.34,.19)*ff3_0+
        mat4(-.01,.40,-.35,-.02,-.16,-.49,-.48,-.10,-.00,.34,.17,.14,.03,-.16,-.06,.04)*ff3_1+
        mat4(-.05,.11,-.16,-.23,.13,-.16,-.20,-.23,.22,.32,.56,.50,-.01,.21,-.10,-.04)*ff3_2+
        mat4(.23,-.15,-.22,-.00,-.29,-.01,-.06,.32,.18,-.15,-.08,.08,.00,.35,.12,.08)*ff3_3+
        mat4(.07,.14,.09,.22,.11,.11,.45,-.16,.12,.16,-.27,-.06,-.16,.21,.02,.05)*ff3_4+
        mat4(.04,.02,-.53,.08,-.45,.04,-.30,-.16,.19,.11,-.04,.07,.14,-.10,-.51,-.23)*ff3_5+
        mat4(.16,.24,-.02,.04,-.25,-.28,.28,-.09,.38,-.16,-.46,-.07,.88,-.47,-.40,.10)*ff3_6+
        mat4(-.22,.03,.12,.23,.10,.14,-.15,-.06,.10,-.28,.10,-.05,-.47,-.13,.09,.01)*ff3_7+
        vec4(.84,-1.33,1.65,.47))/2.0+ff3_6;
    vec4 ff4_7=sin(mat4(-.29,.06,.06,.03,-.17,.38,-.21,-.36,.19,.21,.12,-.43,.24,-.13,.15,.63)*ff3_0+
        mat4(.46,.09,-.10,.12,-.24,.03,-.05,.14,.38,.21,-.09,.10,-.25,.30,.22,-.38)*ff3_1+
        mat4(.23,.16,.40,.48,-.26,-.29,.13,-.12,-.34,.10,-.08,-.69,.11,.04,-.11,-.43)*ff3_2+
        mat4(-.09,.47,.00,.19,.08,-.38,.18,-.69,.09,.30,.09,.24,-.15,.37,-.08,-.27)*ff3_3+
        mat4(-.17,-.13,-.31,-.41,.03,.39,-.09,.22,.16,.35,.14,-.11,-.29,-.53,.17,-.16)*ff3_4+
        mat4(-.13,-.36,.20,.31,-.41,-.35,.25,.06,.26,-.34,.05,.18,.21,-.16,.22,.12)*ff3_5+
        mat4(.23,.01,-.51,.10,-.10,-.02,.21,-.11,.10,.29,-.27,-.16,-.34,.71,.09,-.26)*ff3_6+
        mat4(.16,-.36,.01,-.21,-.21,.30,-.32,.11,-.11,-.01,-.23,-.14,.21,-.37,-.20,.46)*ff3_7+
        vec4(.17,1.06,-.47,-.56))/2.0+ff3_7;
    vec4 ff5_0=sin(mat4(-.23,-.01,-.19,-.00,.07,.33,-.13,.16,.23,.21,.10,.28,.84,.33,-.07,-.49)*ff4_0+
        mat4(.13,-.30,.08,-.20,.16,-.05,.10,-.28,.43,.41,.21,-.23,-.25,.37,.12,-.16)*ff4_1+
        mat4(-.08,-.33,.19,.06,.02,-.38,-.26,.20,-.34,-.39,-.34,.06,.14,.31,-.04,-.13)*ff4_2+
        mat4(.43,-.05,.03,.17,-.03,.29,-.18,.44,.17,.06,-.14,-.15,.27,-.17,-.34,.17)*ff4_3+
        mat4(-.25,-.09,.63,.43,.45,-.04,.04,.19,.36,.35,.02,.03,-.03,-.13,-.07,.04)*ff4_4+
        mat4(.14,.17,.25,.09,-.08,-.01,-.04,.26,.10,-.11,.16,-.31,-.07,.10,-.15,-.16)*ff4_5+
        mat4(-.11,.32,.15,-.23,-.08,-.05,-.07,.11,-.14,.27,-.15,-.11,.22,-.28,-.15,-.08)*ff4_6+
        mat4(.18,-.49,-.38,.04,-.35,.24,-.24,-.38,.24,.25,.09,.29,.66,.17,-.41,-.46)*ff4_7+
        vec4(.64,-.50,1.60,-1.73))/2.2+ff4_0;
    vec4 ff5_1=sin(mat4(.13,-.21,.52,.28,-.26,.20,.35,.09,-.20,.11,-.36,-.22,-.35,.02,.60,-.11)*ff4_0+
        mat4(.23,-.09,-.07,.10,.11,-.02,.30,-.48,.25,.04,.27,-.62,.05,.52,.21,-.08)*ff4_1+
        mat4(-.22,-.24,-.20,.25,.29,.40,.14,.11,.22,.06,.10,.11,.21,-.08,.01,-.05)*ff4_2+
        mat4(-.06,-.26,.28,-.23,-.08,-.29,.09,.18,-.12,-.06,-.02,.14,.01,.64,.06,-.06)*ff4_3+
        mat4(.27,-.09,-.51,.48,-.13,-.14,.07,-.10,-.25,-.07,.15,.44,.05,-.22,-.28,.34)*ff4_4+
        mat4(-.08,-.41,.39,-.03,.10,-.26,-.34,-.14,.16,.06,.06,-.26,-.01,.19,.08,-.33)*ff4_5+
        mat4(.19,.05,.07,-.09,.14,-.41,.06,.03,-.31,.03,.20,.10,-.43,.37,-.17,.38)*ff4_6+
        mat4(-.07,-.41,-.35,-.26,.33,.12,.63,.15,-.16,.01,-.40,.10,.10,-.11,-.14,.03)*ff4_7+
        vec4(.33,-.29,-.38,.02))/2.2+ff4_1;
    vec4 ff5_2=sin(mat4(-.40,-.32,.28,-.40,.35,.02,.23,-.04,-.03,.14,.31,-.27,-.33,-1.01,-.34,-.16)*ff4_0+
        mat4(.31,-.42,.11,-.13,-.26,-.51,-.35,-.45,-.24,-.35,-.09,-.11,-.12,-.19,-.16,.26)*ff4_1+
        mat4(.18,.40,.45,.06,.21,.24,-.09,.50,.12,-.11,.20,-.04,-.11,-.39,-.34,-.29)*ff4_2+
        mat4(-.26,.15,-.27,.03,.46,.02,.16,-.38,-.24,-.25,-.13,-.26,.08,.29,.07,-.25)*ff4_3+
        mat4(.26,.93,.62,.24,.05,.18,-.21,.24,-.05,-.03,.01,-.04,.46,.49,.22,.02)*ff4_4+
        mat4(.18,-.10,-.47,.11,.14,.20,.15,.44,-.07,-.24,.30,-.12,-.14,-.30,-.19,-.33)*ff4_5+
        mat4(-.13,-.63,-.18,-.05,-.02,.67,.10,-.09,.13,-.18,.07,-.52,-.04,.05,-.32,-.14)*ff4_6+
        mat4(.26,.06,.04,-.37,-.37,-.16,-.25,-.18,-.05,.41,.02,.04,-.14,-.32,-.03,-.07)*ff4_7+
        vec4(.01,.00,-1.25,.87))/2.2+ff4_2;
    vec4 ff5_3=sin(mat4(-.38,.20,-.10,.02,-.25,.18,.32,.14,.45,-.04,.13,.33,-.26,-.23,-.36,-.64)*ff4_0+
        mat4(1.09,-.06,.18,.23,-.22,-.34,.21,-.22,-.01,-.16,-.09,-.49,-.13,.24,-.19,-.15)*ff4_1+
        mat4(.36,.09,.26,.46,.37,.18,.19,.38,-.16,-.26,.27,.34,-.37,.09,.30,-.35)*ff4_2+
        mat4(.35,-.11,.21,.20,-.15,.03,-.35,.52,-.37,-.05,-.06,-.27,.21,.00,.04,.20)*ff4_3+
        mat4(.65,.32,.07,.79,.46,.21,.28,.49,-.13,-.26,-.30,.09,.54,-.15,-.12,.61)*ff4_4+
        mat4(.20,-.08,-.21,-.16,.04,-.23,.14,.38,.07,-.02,-.12,-.39,-.12,.14,-.24,-.46)*ff4_5+
        mat4(-.18,.20,.37,-.27,.09,-.30,.01,.37,.18,.09,.35,-.14,.13,.31,.41,.29)*ff4_6+
        mat4(-.22,-.14,-.34,-.14,-.76,.24,.12,-.24,.09,-.13,-.19,-.09,-.15,.05,-.31,-.78)*ff4_7+
        vec4(.64,-1.60,1.17,-1.50))/2.2+ff4_3;
    vec4 ff5_4=sin(mat4(.31,.59,-.26,.16,.05,-.02,-.22,.26,-.25,-.00,-.15,-.02,.21,.79,.30,.45)*ff4_0+
        mat4(-.18,.06,-.24,.17,.33,.12,.07,-.22,-.26,.27,-.15,.03,.39,.20,-.01,-.15)*ff4_1+
        mat4(-.35,-.40,-.25,-.61,-.03,-.48,-.21,-.31,.31,.01,.35,.02,.08,.12,.04,.55)*ff4_2+
        mat4(-.47,.04,.44,.16,-.41,-.00,-.26,-.00,.39,.57,.09,.25,-.24,-.06,-.08,-.15)*ff4_3+
        mat4(-.60,-.81,-.09,-.78,-.21,.02,-.17,-.05,.13,.19,.18,-.21,-.37,-.57,.07,-.22)*ff4_4+
        mat4(.09,.52,.08,.05,.19,-.29,.01,-.39,-.09,.34,-.32,.10,.18,.14,-.24,.30)*ff4_5+
        mat4(.22,.56,.17,.48,.15,.15,-.04,-.30,.27,.19,-.05,-.15,-.18,-.59,.50,.09)*ff4_6+
        mat4(-.27,-.08,.53,.21,.32,.29,-.17,.29,-.18,.13,-.04,.03,.09,.46,.21,.23)*ff4_7+
        vec4(1.63,-1.72,1.93,2.00))/2.2+ff4_4;
    vec4 ff5_5=sin(mat4(.13,-.07,.21,-.17,.26,-.14,-.11,.09,.45,.07,-.25,.15,-.12,.12,.39,-.54)*ff4_0+
        mat4(-.11,-.02,-.07,.23,.14,.35,.47,-.38,.06,.56,.24,-.31,-.06,-.03,.04,-.06)*ff4_1+
        mat4(.20,-.14,-.47,.53,.28,-.08,-.16,.72,-.14,-.35,-.10,.34,.13,.14,.05,-.28)*ff4_2+
        mat4(.17,-.06,.10,.18,.13,-.11,-.24,.57,.52,.07,.01,-.30,.13,-.38,-.24,.24)*ff4_3+
        mat4(.12,-.26,-.40,1.04,.15,-.02,-.21,.51,.46,.19,-.21,.08,-.05,.14,-.63,1.08)*ff4_4+
        mat4(.18,-.13,-.26,-.28,-.07,-.33,.15,-.01,.13,.04,.35,-.18,-.23,.32,.43,-.87)*ff4_5+
        mat4(-.16,-.19,.20,-.18,.07,-.05,-.04,.37,-.06,-.19,-.02,-.12,-.02,.21,-.16,.52)*ff4_6+
        mat4(-.40,.16,.00,.07,.33,-.08,-.03,-.46,.05,-.19,.31,-.14,-.03,.29,.45,-.63)*ff4_7+
        vec4(.60,.40,-.34,1.19))/2.2+ff4_5;
    vec4 ff5_6=sin(mat4(.01,-.12,-.34,-.17,.13,.02,-.39,-.40,.26,-.03,.31,.01,.51,.36,.10,.55)*ff4_0+
        mat4(.15,-.04,.14,.43,-.04,.25,.12,.09,-.30,-.10,-.39,-.32,-.26,-.01,-.37,-.10)*ff4_1+
        mat4(-.14,-.77,.63,.07,-.10,.30,.23,.14,.09,.60,.04,-.09,.36,-.03,.15,-.24)*ff4_2+
        mat4(-.25,.06,-.17,.52,.03,-.23,.47,.05,.18,-.09,-.32,-.09,-.04,.05,-.23,-.12)*ff4_3+
        mat4(-.08,.54,.57,.33,-.21,.59,.23,.38,-.26,-.76,-.47,-.25,-.41,-.06,.18,.16)*ff4_4+
        mat4(-.10,.25,-.31,.18,.00,-.05,-.22,.45,.32,.08,.07,.70,-.17,.78,-.11,-.37)*ff4_5+
        mat4(-.24,.18,-.17,-.36,-.02,.28,.22,.46,.13,-.43,-.39,-.33,-.03,-.28,.14,.10)*ff4_6+
        mat4(-.02,.14,.01,-.09,.19,-.12,-.32,-.09,-.50,-.10,.02,-.23,.26,.58,.42,.40)*ff4_7+
        vec4(-1.28,1.50,1.33,-1.03))/2.2+ff4_6;
    vec4 ff5_7=sin(mat4(.43,.36,.17,-.20,-.34,.30,-.05,.16,-.04,-.08,-.06,.00,.54,.05,-.14,-.79)*ff4_0+
        mat4(-.15,-.02,-.16,-.19,.09,.61,-.44,-.45,-.22,.08,-.16,-.33,.03,.19,-.36,-.07)*ff4_1+
        mat4(-.42,-.17,.08,.58,-.26,-.23,.36,.56,-.02,-.13,-.20,.25,.14,.28,.08,-.22)*ff4_2+
        mat4(.05,-.25,.18,.05,-.03,-.16,.50,.27,.28,-.11,-.15,-.41,.04,.09,.18,.25)*ff4_3+
        mat4(-.32,.15,.01,1.00,-.22,-.08,-.02,.33,.24,-.13,.35,.02,-.12,-.21,.17,.57)*ff4_4+
        mat4(-.08,.36,-.04,-.40,-.10,-.46,-.20,.18,.05,-.18,.18,-.01,.17,.32,.05,-.20)*ff4_5+
        mat4(.28,.13,-.20,-.15,.19,.18,.21,.20,.29,.11,.23,-.27,-.02,-.13,.12,-.05)*ff4_6+
        mat4(.24,-.45,.01,.17,-.18,.18,.20,-.46,.03,.06,-.22,-.01,.36,-.20,-.25,-.48)*ff4_7+
        vec4(-.87,.99,-1.68,.86))/2.2+ff4_7;
    vec4 ff6_0=sin(mat4(-.11,-.16,-.08,-.14,-.43,-.26,.18,-.22,.12,.32,.20,.16,.39,-.41,-.76,.48)*ff5_0+
        mat4(.42,-.07,-.04,.35,-.42,-.28,-.34,-.13,-.11,-.48,-.10,.25,-.14,.18,.21,-.01)*ff5_1+
        mat4(-.05,.02,.59,-.21,-.09,.07,.39,-.40,-.37,.35,.38,-.35,-.20,-.20,-.29,.17)*ff5_2+
        mat4(.56,-.35,.32,.26,-.29,.04,.10,-.12,-.29,-.05,-.13,.20,.15,.02,.29,-.54)*ff5_3+
        mat4(.06,.24,.65,-.25,.08,.00,.36,-.30,-.19,-.42,.50,-.09,-.11,-.03,.49,-.24)*ff5_4+
        mat4(.16,.07,.29,.36,.20,.07,.31,.36,-.08,-.01,-.41,.40,-.15,-.18,-.89,.54)*ff5_5+
        mat4(-.10,.16,.05,-.21,.33,.13,-.12,.21,-.48,-.30,-.14,.04,.04,.12,-.02,.37)*ff5_6+
        mat4(.36,-.69,-.26,.22,-.40,-.08,-.05,.01,.32,-.11,-.10,.05,.34,-.39,-.30,.83)*ff5_7+
        vec4(2.05,1.37,.22,-.66))/2.4+ff5_0;
    vec4 ff6_1=sin(mat4(.02,-.27,-.37,.17,-.10,-.11,-.21,-.10,-.30,-.10,.08,-.34,.81,-.07,.02,.71)*ff5_0+
        mat4(-.06,.02,-.05,.03,.50,-.19,.14,.04,.11,.06,-.31,.08,-.25,.34,-.09,.08)*ff5_1+
        mat4(-.65,.61,.06,-.65,-.53,.40,-.07,-.20,-.39,-.05,.48,-.45,.04,-.32,.07,-.09)*ff5_2+
        mat4(-.58,.47,.03,-.35,.07,-.20,.12,-.19,.00,.15,-.17,.15,-.17,.13,.06,-.12)*ff5_3+
        mat4(-.70,.59,.04,-.72,-.45,.40,-.04,-.45,-.35,.10,-.04,-.27,-.50,.13,.13,-.23)*ff5_4+
        mat4(.28,.05,.11,.17,.08,-.17,-.23,-.17,.43,-.27,-.31,.47,.73,-.64,-.34,.86)*ff5_5+
        mat4(.12,-.21,-.19,.37,-.58,-.26,-.11,-.43,.61,-.16,.17,.03,-.34,-.09,-.28,-.45)*ff5_6+
        mat4(.11,-.13,-.14,-.15,.28,.00,-.00,.28,-.26,.05,-.28,-.00,.68,-.42,-.24,.89)*ff5_7+
        vec4(-.26,1.81,.08,-.78))/2.4+ff5_1;
    vec4 ff6_2=sin(mat4(.01,-.03,-.23,.16,.31,-.16,-.36,.17,-.26,.09,.19,-.46,.17,-.23,.35,.24)*ff5_0+
        mat4(.10,-.19,-.32,.39,.45,.08,.24,-.06,.06,-.40,.22,.24,-.19,-.07,.13,-.25)*ff5_1+
        mat4(-.36,.11,-.24,-.20,.02,-.26,-.62,.13,-.29,.38,.03,-.25,-.04,-.30,.39,.18)*ff5_2+
        mat4(-.19,.09,.16,-.39,-.13,.01,.01,.03,.02,.18,.24,.03,-.25,.14,-.02,-.21)*ff5_3+
        mat4(-.37,.10,-.18,-.30,-.20,.09,-.27,-.56,-.16,-.21,.01,.00,-.29,.25,-.29,-.50)*ff5_4+
        mat4(.16,.03,.20,-.03,.18,.08,.06,-.10,-.01,-.47,.15,.27,.46,-.45,.14,.30)*ff5_5+
        mat4(.28,-.20,-.06,-.04,-.34,-.03,.26,-.22,.06,-.22,.05,.02,.12,.12,.17,-.29)*ff5_6+
        mat4(.26,-.15,.46,.04,-.09,.05,.00,.09,-.46,.19,-.11,-.13,.27,-.28,.79,.82)*ff5_7+
        vec4(1.81,-.15,-.93,-.04))/2.4+ff5_2;
    vec4 ff6_3=sin(mat4(-.31,.32,.30,-.70,.09,.06,.21,.05,-.16,-.44,-.34,.15,-.49,.12,.71,-.72)*ff5_0+
        mat4(.18,.19,-.20,-.01,-.05,.30,.14,-.40,-.17,.37,.48,-.07,.10,.02,-.32,-.11)*ff5_1+
        mat4(.23,-.28,-.54,.65,.34,-.27,-.95,.43,-.19,.19,-.11,-.35,-.02,-.13,.45,-.19)*ff5_2+
        mat4(.41,-.14,-.46,.40,.33,.10,-.19,-.07,-.41,-.03,.50,.08,.12,-.54,-.78,.64)*ff5_3+
        mat4(.40,-.93,-1.05,.62,.03,-.44,-.72,.20,.16,.11,-.22,.52,.16,-.21,-.82,.43)*ff5_4+
        mat4(-.29,.17,.07,-.15,.17,-.02,-.23,-.00,.02,.31,.48,-.09,-.47,.53,1.34,-.69)*ff5_5+
        mat4(-.24,.03,.53,-.24,.04,-.13,-.08,.21,-.27,.08,.51,-.63,-.15,.18,-.28,.09)*ff5_6+
        mat4(-.15,.21,.17,-.31,.15,.21,.27,-.31,.16,.12,-.34,.24,-.39,.67,1.19,-.87)*ff5_7+
        vec4(1.19,.75,-.43,1.05))/2.4+ff5_3;
    vec4 ff6_4=sin(mat4(-.31,-.44,-.37,-.03,.04,-.15,.09,-.23,-.18,.44,.58,.53,-.80,.37,-.90,-.66)*ff5_0+
        mat4(-.15,.11,-.02,.09,-.16,.07,-.43,-.23,-.09,-.02,-.49,-.36,.27,-.02,.20,.40)*ff5_1+
        mat4(.50,.01,.74,.25,.31,.02,1.05,-.21,.38,-.20,.29,.02,-.53,-.17,-.30,.12)*ff5_2+
        mat4(.46,-.10,.45,-.08,.47,-.04,.29,.21,-.41,-.03,-.64,.03,.49,.18,.73,.10)*ff5_3+
        mat4(.52,-.15,1.24,.33,.44,.27,.91,.21,.18,-.22,.53,.19,.48,-.03,.97,-.03)*ff5_4+
        mat4(-.05,-.25,-.09,.26,.07,-.17,.09,.05,-.55,.02,-.67,-.42,-.95,-.54,-1.53,-.44)*ff5_5+
        mat4(-.03,.02,-.48,-.23,-.06,.04,.25,.08,-.50,-.21,-.66,-.34,.04,.32,.52,.37)*ff5_6+
        mat4(.00,-.29,-.19,.34,-.10,.16,-.31,.09,-.03,.06,.19,-.03,-.62,-.08,-1.31,-.83)*ff5_7+
        vec4(.22,1.33,1.39,-1.35))/2.4+ff5_4;
    vec4 ff6_5=sin(mat4(-.22,-.06,-.19,-.06,-.55,-.47,.16,.01,-.25,-.01,.41,-.40,.15,-.07,-.91,.01)*ff5_0+
        mat4(.25,.29,-.28,.19,.02,-.57,.14,.18,-.04,.43,.27,.37,.15,-.09,.18,.01)*ff5_1+
        mat4(.25,.62,.02,-.22,-.33,-.30,.48,-.21,-.20,-.21,.37,-.19,-.16,.14,.14,-.02)*ff5_2+
        mat4(.30,.55,-.16,-.77,.07,-.04,-.16,-.15,.32,.23,-.53,.02,-.06,-.52,.34,-.37)*ff5_3+
        mat4(-.35,.38,.71,-.52,.10,.28,.43,-.39,.28,.28,.06,.03,-.17,-.01,.01,-.38)*ff5_4+
        mat4(.12,-.03,-.36,.17,.18,-.05,-.16,.21,-.17,.21,-.32,.20,.12,.31,-.19,.49)*ff5_5+
        mat4(-.37,-.05,.09,.12,.10,.01,.07,-.20,.01,-.32,-.31,.04,-.20,-.05,-.02,-.38)*ff5_6+
        mat4(.32,.09,-.17,.19,-.30,-.15,.28,.12,.33,-.15,-.20,-.13,.64,.25,-.83,.57)*ff5_7+
        vec4(-.45,.30,1.30,.01))/2.4+ff5_5;
    vec4 ff6_6=sin(mat4(.50,.07,.04,-.31,.42,.26,-.07,.11,-.19,.36,-.44,.15,.18,-.52,.46,-.34)*ff5_0+
        mat4(-.10,-.12,.31,.09,.17,.29,-.04,.03,-.07,-.62,-.13,-.34,-.14,.34,-.30,-.00)*ff5_1+
        mat4(-.11,-.24,-.30,.21,-.28,-.03,.01,.59,.00,.18,-.45,.17,.16,-.47,.26,-.34)*ff5_2+
        mat4(-.57,-.31,-.20,.63,.09,.02,.27,.17,.04,-.06,.31,.06,-.21,.41,-.59,.23)*ff5_3+
        mat4(-.16,-.43,-.18,.67,-.49,.08,-.33,.15,.17,-.22,-.25,-.28,.06,-.06,-.15,.41)*ff5_4+
        mat4(-.04,-.03,.09,.16,-.09,.27,-.24,.19,.04,-.13,.30,-.14,.50,-.66,.43,-.68)*ff5_5+
        mat4(.30,-.02,.10,-.59,-.00,.42,.11,-.17,.20,-.10,.37,-.01,-.42,.19,-.09,.29)*ff5_6+
        mat4(.40,-.49,.06,.27,.30,-.02,.25,-.06,-.13,.24,.19,-.07,.53,-.38,.20,-.65)*ff5_7+
        vec4(.16,-.30,1.82,.75))/2.4+ff5_6;
    vec4 ff6_7=sin(mat4(-.16,.40,-.33,.55,-.16,.32,-.04,-.09,-.09,.06,.01,.01,-.15,.12,-.05,.34)*ff5_0+
        mat4(-.01,.45,-.28,.04,-.16,.15,.16,.12,-.28,-.10,.19,.33,-.12,-.41,.14,-.09)*ff5_1+
        mat4(.15,.11,.43,-.11,.25,.50,.52,-.30,.38,-.17,-.17,-.13,-.15,-.53,-.12,.29)*ff5_2+
        mat4(.38,.35,.12,.10,.11,-.06,-.06,-.28,.22,.42,.16,.21,.02,.17,.54,.37)*ff5_3+
        mat4(.17,.01,-.06,-.03,.06,-.19,.38,-.18,-.14,.22,-.03,.06,-.14,.22,.06,-.36)*ff5_4+
        mat4(.28,-.09,-.00,.01,-.06,-.04,-.12,.03,.21,.34,-.21,.37,-.33,.10,-.35,.54)*ff5_5+
        mat4(-.13,-.38,-.09,.44,-.16,.03,-.47,-.09,-.14,.03,.25,.38,.40,-.15,.27,-.15)*ff5_6+
        mat4(-.10,-.18,-.06,.14,-.24,-.08,-.01,.13,-.10,.29,.35,.30,-.31,.09,-.21,.69)*ff5_7+
        vec4(1.51,.86,-.69,.35))/2.4+ff5_7;
    float return_val2 = dot(ff6_0,vec4(-.04,-.02,.05,-.06))+
        dot(ff6_1,vec4(.05,.02,.00,.04))+
        dot(ff6_2,vec4(.02,.01,-.03,-.02))+
        dot(ff6_3,vec4(.02,-.02,-.03,.03))+
        dot(ff6_4,vec4(.03,.03,-.03,.02))+
        dot(ff6_5,vec4(-.03,-.03,-.04,-.03))+
        dot(ff6_6,vec4(-.03,.01,-.04,.03))+
        dot(ff6_7,vec4(-.04,-.03,-.02,-.04))+
        -0.058* -sin(iTime);
        
        return (return_val1 + return_val2 ) / 2.0;
}

// Function 2818
void hitScene(in vec3 p, in vec3 nv, out int idHit, out vec3 pHit) {
    float travel = 0.0;
    vec3 curPos = p;

    for (int k = 0; k < RAY_STEPS; k++) {
        float sdStep;
        sdGeometry(curPos, sdStep);

        if (abs(sdStep) < MIN_DIST) {
            idHit = ID_GEOMETRY;
            pHit = curPos;
            return;
        }

        curPos += sdStep * nv;
        travel += sdStep;
        if (travel > MAX_DIST) {
            break;
        }
    }

    idHit = ID_NONE;
    pHit = curPos;
}

// Function 2819
vec3 sampleScene(vec2 coord)
{
    vec2 t = coord / iResolution.xy * 2. - 1.;
	t.x *= iResolution.x / iResolution.y;
    
    // Set up primary ray.
    float an=7.;
    vec3 ro=vec3(.3,0.6,15.);
    vec3 rd=normalize(vec3(t.xy,-5.));

    // Intersect with ground plane.
    float groundt=(-1.55-ro.y)/rd.y;

	// Compositional orientation.
    rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;
    ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;

    // Animating orientation.
    mat2 rx=rotmat(cos(time*7.)*.1);
    mat2 rz=rotmat(cos(time*3.)*.1);

    ro.y-=abs(sin(time*7.+PI))/8.+.05;
    ro.yz*=rx;
    rd.yz*=rx;

    ro.xy*=rz;
    rd.xy*=rz;

    // Reject negative ground plane intersection distance.
    if(groundt<0.)
        groundt=1e4;

    float dt=5.,d=0.;
    
    // Trace through SDF.
    for(int i=0;i<140;++i)
    {
        d=f(ro+rd*dt);
        if(abs(d)<1e-3||dt>20.||dt>groundt)
            break;
        dt+=d;
    }

    // Backdrop colour.
    vec3 c=vec3(.5,15,.3)*.9;
    
    if(groundt<dt)
    {
        // Ground is nearer. Just apply some basic shadow shape.
        vec3 rp=ro+rd*groundt;
        c*=mix(.7,1.,linstep(0.,.1,box(rp.xz,vec2(1.))-.5));
    }
    else if(dt<20.)
    {   
        // SDF is nearer.
        float d2=f(ro+rd*dt+normalize(vec3(-2,2,-1))*1e-2);
        float l=.5+.5*(d2-d)/1e-2;

        // Get the intersection point.
        vec3 rp=ro+rd*dt;

        // Determine a colour based on where the ray hit is.
        
        c=vec3(1,1,.2);

        if(bodyWithMouth(rp)>body(rp))
            // Main body.
            c=vec3(1.3,.5,1)/2.*mix(.5,1.,smoothstep(.3,.6,l));
        else if(rp.z<-1.)
            // Face texture.
            c=face(rp.xy);
        else if(rp.y>1.2&&rp.z<0.)
            // Tips of ears.
            c=mix(c,vec3(0),linstep(0.,.01,rp.y-1.7));

        // Stripes on back.
        rp.xz=abs(rp.xz-vec2(0,.3))-vec2(0,.3);
        rp.y-=.8;
        float stripesd=box(rp,vec3(6,.5,.15))-.02;
        c=mix(c,vec3(1,.5,.1)/4.,linstep(.01,0.,stripesd));

		// Apply some directional light.
        c*=mix(vec3(1,1,.8)*.9,vec3(1),smoothstep(.3,.31,l));
    }
    
    return c;
}

// Function 2820
float MapRing(vec3 p, float inRadius, float outRadius, float height)
{
  pR(p.xy, 0.15);
  return max(sdCappedCylinder(p, vec2(outRadius, height)), -sdCappedCylinder(p, vec2(inRadius, 15.)));
}

// Function 2821
vec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor, float id){
    
    const vec2 e = vec2(0.002, 0);
    float ref = bumpFunc(p, n, id);                 
    vec3 grad = (vec3(bumpFunc(p - e.xyy, n, id),
                      bumpFunc(p - e.yxy, n, id),
                      bumpFunc(p - e.yyx, n, id) )-ref)/e.x;                     
          
    grad -= n*dot(n, grad);          
                      
    return normalize( n + grad*bumpfactor );
	
}

// Function 2822
vec3 Scene_GetNormal( const in vec3 vPos )
{
    const float fDelta = 0.0001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + 
        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + 
        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + 
        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;
    
    return normalize( vNormal );
}

// Function 2823
float getDist(vec2 p, vec2 a, vec2 b, bool last)  { 
    if (a == vec2(-1) || b == vec2(-1)) 
    	return 90000000.;
    
    float cosB = dot(normalize(b-p), normalize(b-p));
    float c = cosB * length(b-p);
    /*if (c < 0. || c > length(a-b))
        return 90000000.;*/
    vec2 pa = p - a, ba = b - a, pb = p - b;
    float u = dot(pa, ba)/dot(ba, ba), cu = clamp(u , 0., 1.);
    vec2 d = pa - ba * cu; 
    vec2 tangAB = vec2(ba.y, -ba.x);
    float dist = length(d)*-sign(dot(tangAB, pa));
 	return dist;
}

// Function 2824
float sdf_flame_segment(vec2 uv, vec2 size, vec3 waves)
{
    float h = linear_step(0., size.y, uv.y);
    float width = mix(.5, .005, sqr(h)) * size.x;
    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));
}

// Function 2825
float DistCombineIntersect( const in float v1, const in float v2 )
{
	return mix(v2, v1, step(v2,v1));
}

// Function 2826
vec3 Tonemap_ACESFitted2(vec3 acescg)
{
    vec3 color = acescg * RRT_SAT;
    
   #if 1
    color = ToneTF2(color); 
   #elif 1
    color = RRTAndODTFit(color);
   #elif 1
    color = ToneMapFilmicALU(color);
   #endif
    
    color = color * ACESOutputMat;
    //color = ToneMapFilmicALU(color);

    return color;
}

// Function 2827
float DistanceFromLine(in vec2 v1, in vec2 v2, in vec2 pt)
{
	return length((pt - FindClosestPoint(v1, v2, pt)));
}

// Function 2828
vec2 dstScene(vec3 p) {
    vec2 dst = dstTrack(p);
    dst = dstSmin(dst, dstPylon(p));
    dst = dstUnion(dst, dstGround(p, -10.));
    
    p += vec3(10.,4.,25.);
    vec2 coaster2 = dstSmin(dstTrack(p), dstPylon(p));
    dst = dstUnion(dst, coaster2);
    
    return dst;
}

// Function 2829
vec4 map( in vec3 p )
{
    vec2 d 	= sdBox(p,vec3(1.2,0.2,1.2),vec3(0,-0.21,0),0);
    
    for(int i = 0; i<5; i++){
        d = opU(d,sdSphere(p,vec3(0.8,0.2,-1.0 + 0.5 * float(i)) ,0.2,1 + i));//mat=1~5
    }

    for(int i = 0; i<5; i++){
        d = opU(d,sdSphere(p,vec3(-0.8,0.2,-1.0 + 0.5 * float(i)) ,0.2,6 + i));//mat=6~10
    }
    
    d = opU(d,sdSphere(p,vec3(-0.1,0.30,-0.5) ,0.3,11)); 
    d = opU(d,sdSphere(p,vec3(-0.3,0.15,0.3),0.15 ,12)); 
    d = opU(d,sdSphere(p,vec3(0.2,0.205,0.0) ,0.2,13)); 

    float mat = d.y;
    vec4 res = vec4( d.x, 1.0, 0.0, mat );
    return res;
}

// Function 2830
float map(vec3 p)
{

  vec3 fp = mod(p.xyz, 5.)-2.5;  
  float balle = length(fp)-1.;
  return balle; 
      
}

// Function 2831
float MapWater(vec3 p)
{
  return p.y - (-GetWaterWave(p)*0.05);
}

// Function 2832
int IntersectScene(Ray ray, int ignoreObjId, bool convex, int numSteps, out float out_t, out RoundBox out_box)
{
	int boxId = -1;
	out_t = 1e5;
	out_box = boxes[0]; // none
	for (int i = 0; i < min(0, iFrame) + NUM_BOXES; i++) {
		RoundBox box = boxes[i];
		float t = RayRoundBoxIntersect(ray, box, convex, numSteps);
		if (i != ignoreObjId && t != 0.0 && t < out_t) {
			boxId = i;
			out_t = t;
			out_box = box;
		}
	}
	return boxId;
}

// Function 2833
vec2 map( in vec3 pos )
{
  vec3 r1, r2;
  
//vec2 res = vec2 (sdPlane1(pos), 1.0); 
  vec2 res = vec2 (sdPlane(pos, vec4(0,1,0,0)), 1.0); 
  
  //---0---
    
  res = opU(res, vec2( sdWaveSphere ( pos-p01, 0.18 , 10, sinTime*0.4), 99));

                                    r1 = rotateY (pos-p02, aTime*0.5);
  res = opU(res, vec2( sdDodecahedron(r1, 0.2), 55));

                                    r1 = rotateX (pos-p03, sinTime*0.8);
  res = opU(res, vec2( sdIcosDodecaStar(r1, 0.18), 177));

                                    r1 = rotateZ (pos-p04, sinTime*0.8);
  res = opU(res, vec2( sdIcosahedron(r1, 0.16), 222));
    
                                    float h1 = 0.2 + 0.1 * abs(sinTime);
//  res = opU(res, vec2( sdPyramid4  (pos-p05, vec3(0.8,0.6,h1) ), 8 ) );
  res = opU(res, vec2( sdPyramid  (pos-p05, h1 ), 8));

  //---1---
                                    r1 = rotateY (pos-p11, aTime*0.5);
  res = opU(res, vec2( sdTrianglePrism( r1, 0.1*sinTime + 0.25, 0.05 ), 44));
    
                                    r1 = rotateX (pos-p12, sinTime*0.8);
  res = opU(res, vec2( sdCone      (r1, vec3(0.8, 0.5+0.2*sinTime, 0.3)), 222));
    
  res = opU(res, vec2( sdBlob      (pos-p13, -0.5 - 0.45*sinTime ), 244));
    
                                    h1 = 0.2 + 0.06 * sinTime;
  res = opU(res, vec2( sdCylinder  (pos-p14, vec2(0.1, h1) ), 130));

               vec3 a = vec3( 0.1, 0.0, 0.0);  float sr1 = 0.1+0.05*sinTime;
               vec3 b = vec3(-0.1, 0.3, 0.1);  float sr2 = 0.05;
  res = opU(res, vec2( sdRoundCone( pos-p15, a,b, sr1,sr2), 51.7));

  //---2---
    
  res = opU(res, vec2( CrossInSphere ( pos-p21, 0.2+0.05*sinTime, 0.05), 51));
   
                                    r1 = p22 + rotateY (vec3(-0.22, 0, 0), aTime);
                                    r2 = p22 - rotateY (vec3(-0.22, 0, 0), aTime);
  res = opU(res, vec2( sdCapsule   (pos, r1, r2, 0.1), 32));

                                    r1 = vec3( 0.0, 0.1 + 0.1 * sinTime, 0.0);
  res = opU(res, vec2( sdSphere    (pos-p23-r1, 0.25-0.5*r1.y), 111));
 
  res = opU(res, vec2( sdBox       (pos-p24, vec3(0.20)), 3));
    
  res = opU(res, vec2( sdEgg1      (pos-p24-r1, 0.21), 47));

  res = opU(res, vec2( sdEgg2      (pos-p25, 0.18+h1), 47));

  //---3---
  res = opU(res, vec2( sdBoxMinusSphere (pos-p31, 0.25), 13));
    
                                    r1 = rotateX (pos-p32, aTime*0.5);
  res = opU(res, vec2( sdHexagonalPrism ( r1, 0.25, 0.05 ), 17.0));
    
                                    r1 = rotateX (pos-p33, sinTime*1.2);
                                    r1 = rotateZ (r1, aTime*2.0);
  res = opU(res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0));
    
  res = opU(res, vec2( udRoundBox(  pos-p34, vec3(0.12), 0.05+0.05*+sinTime), 77));
    
  res = opU(res, vec2( sdBallyBall ( pos-p35), 65.0));

  //---4---
    
  res = opU(res, vec2( sdTwistedTorus( pos-p41, 6.0*sinTime ), 46.7));

                                    r1 = rotateY (pos-p42, aTime*0.25);
  res = opU(res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0));
    
  res = opU(res, vec2( sdTorus82(   pos-p43, vec2(0.20-0.05*sinTime, 0.05)), 77));
    
  res = opU(res, vec2( sdRackWheel( pos-p44 ), 51));

                                    r1 = rotateY (pos-p45, aTime*0.25);
  res = opU(res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12));
    
  return res;   // return x=distance, y=color id
}

// Function 2834
vec3 cubeMap(in samplerCube sam, in vec3 v, float size)
{
   float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
   float scale = (float(size) - 1.) / float(size);
   if (abs(v.x) != M) v.x *= scale;
   if (abs(v.y) != M) v.y *= scale;
   if (abs(v.z) != M) v.z *= scale;
   return texture(sam, v).xyz;
}

// Function 2835
vec2 map2sd(vec2 z)
{

  vec2  z2 = z*z;
  float s  = sqrt(1. - (z2.x * z2.y)/(z2.x+z2.y+epsilon));
  return z*s;  
}

// Function 2836
float map( vec3 p ) {
    float d = shape3d(p);
	float s = d*.5, dr = (d-shape3d(p + rd*s))/s; // from eiffie
	return d / (1.+max(dr, 0.)); // this one too
}

// Function 2837
float aoDist(vec3 o, vec3 center, vec3 norm)
{
    vec3 trash;
    o += norm / 5.;
    
    float best = 0.;
    vec3 r;
    
    for (int i = 0; i < 3; ++i)
    {
        // these two lines are equivalent to:
        //   vec3 p = Fv(i)
        //   vec3 q = p;
        // for cubes. This form is for truncated octohedrons.
        // I'm not sure if this generalizes to any other space-filling
        // polyhedra or not.
        //
        // Either way, it looks horrible. Don't do this.
        vec3 p = normalize(Fv(i));
        vec3 q = p - norm * dot(norm, p);
        
        if (dot(o - center, q) > best && dot(norm, p) < 0.95)
        {
            r = q;
            best = dot(o - center, q);
        }
        
        q = -q;
        if (dot(o - center, q) > best && dot(norm, p) < 0.95)
        {
            r = q;
            best = dot(o - center, q);
        }
    }
    
    return traceTruncOct(o, normalize(r), trash, trash, 1);
}

// Function 2838
vec4 scene( vec3 p )
{
	return scene1( p );
}

// Function 2839
float sdf(vec2 uv)
{
    float l1 = length(uv-center()) - 0.3;
    float l2 = length(uv-1.5*center()) - 0.1;
    return min(l1, l2);
}

// Function 2840
float map(vec3 p){
    return opU(
        sdPlane(p),
    	opLathe(p-vec3(0., 1., 0.))
    );
}

// Function 2841
float sdf_7(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    return t;
}

// Function 2842
float distanceEstimation(vec3 pos, out vec3 volumeColor, out vec3 emissionColor) {
    
    vec3 basePos = vec3(0., .0, .0);
    float scale = 1.;
    
    pos /= scale;
    pos += basePos;
    
    volumeColor = vec3(.0);
    emissionColor = vec3(0.);
    
    pos.yz = vec2(pos.z, pos.y);
    
    
    float r = length(pos);
    vec3 z = pos;
    vec3 c = pos;
	float dr = 1.0, theta, phi;
    vec3 orbitTrap = vec3(1.);
	for (int i = 0; i < 8; i++) {
		r = length(z);
		if (r>SceneRadius) break;
        orbitTrap = min(abs(z)*1.2, orbitTrap);
		theta = acos(z.y/r);
		phi = atan(z.z,z.x);
		dr =  pow( r, Power-1.0)*Power*dr + 1.0;
		theta *= Power;
		phi *= Power;
		z = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + c;
	}
    
    float dist = 0.5*log(r)*r/dr*scale;
    
    volumeColor = (1.-orbitTrap)*.98;
    emissionColor = vec3(orbitTrap.z < .0001 ? 20. : 0.);
    
	return dist;
}

// Function 2843
vec3 ApplyTonemap(const in vec3 vLinear) {
	const float kExposure = exposure;
	return 1.0- exp2(vLinear* -kExposure);
}

// Function 2844
float SDF_Mouth(vec3 p)
{
    // Increase the size of the mouth over time
    float yoff = 0.035 * clamp(TimeRatio() * 4.0, 0.0, 1.0) * 2.0;
    
    return udRoundBox(
        // Rotate box so that it cuts into the moon correctly
        RotX(Translate(p, vec3(0.0, -0.275, 0.9 - abs(p.x) * 0.175)), PI * 0.15),
        // Increase the vertical size of mouth
        vec3(0.3, 0.02 + yoff, 0.1),
        // The radius increases as we move along x and y
        0.05 + abs(p.x) * 0.75 * mix(0.0, 1.0, clamp(abs(p.y) / 3.5, 0.0, 1.0)));
}

// Function 2845
vec2 diffSDF(vec2 dist0, vec2 dist1) {
    return dist0.x > -dist1.x? dist0 : vec2(-dist1.x, dist1.y);
}

// Function 2846
vec3 Tonemap( const in vec3 cCol )
{
	// simple Reinhard tonemapping operator      
	return cCol / (1.1 + cCol);
}

// Function 2847
vec3 sampleReflectionMap(vec3 p, float b) {
    vec3 col = textureLod(reflectTex, p, b).rgb;
    
    // fake HDR
    //col *= 1.0 + 1.0 * smoothstep(0.5, 1.0, dot(LUMA, col));
    
    return col;
}

// Function 2848
float sceneSDF2(vec3 p){
    p *= 3.0;
	return 0.5 + sceneSDF1(p/2.0+sceneSDF1(p/5.0));
}

// Function 2849
vec2 sphereIntersectionDistances(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius) {
    vec3 toCenter = sphereOrigin - rayOrigin;
    float toCenterAlongRay = dot(toCenter, rayDirection);
    
    float perpendicularDistanceSquared = dot(toCenter, toCenter) - toCenterAlongRay * toCenterAlongRay;
    float radiusSquared = sphereRadius * sphereRadius;
    
    if (perpendicularDistanceSquared > radiusSquared) { // ray doesnt touch the sphere
        return vec2(0.);
    }
    
    float insideSphereAlongRay = sqrt(radiusSquared - perpendicularDistanceSquared); // half the length of the portion of the ray inside the sphere
    
    float intersection1 = toCenterAlongRay - insideSphereAlongRay;
    float intersection2 = toCenterAlongRay + insideSphereAlongRay;
    if (intersection1 > intersection2) {
        float t = intersection1;
        intersection1 = intersection2;
        intersection2 = t;
    }
    
    if (intersection1 < 0.) { // first intersection is before the start of the ray
        if (intersection2 < 0.) { // ditto second, though that shouldnt happen?
            return vec2(0.);
        } else {
            intersection1 = intersection2;
            intersection2 = 0.;
        }
    }
    
    return vec2(intersection1, intersection2);
}

// Function 2850
float GetDist(vec3 p)
{
    vec4 sphere = vec4(0.,pow(sin(iTime),2.)+1.,6.+pow(sin(iTime),2.)*0.5,1.);
    float d_sphere = length(p-sphere.xyz) - sphere.w;
    float d_plane = p.y;
    float d = min(d_plane,d_sphere);
    return d;
}

// Function 2851
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(1./iResolution.y, 0); 
    
    float f = bumpFunc(p, n); // Hit point function sample.
    
    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.
    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.
    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.
    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.
    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x*2.);
    
    
    // We may as well use the six measurements to obtain a rough curvature value while we're at it.
    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .5, 0., 2.);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 2852
SceneResult GetBoatDistance( vec3 vPos )
{    
    vPos*=0.5;
    vPos.xz=rot(vPos.xz, D2R(-90.));; 
    SceneResult result;
    result.iObjectId = ID_BLACK;
    result.vUVW = vPos;
    
    result.fDist = GetBoatHullDistance(vPos);
    
    SceneResult intResult;
    intResult.iObjectId = ID_WOOD;
    intResult.vUVW = vPos;

    float boatInsideDist = GetBoatHullDistance(vPos - vec3(0,.15,0) );

    boatInsideDist = max( boatInsideDist, -udRoundBox( vPos - vec3(0,0.2,-.8), vec3(1.0, .01, 0.2), 0.05) );
    
    boatInsideDist = max( boatInsideDist, vPos.z);
    
    intResult.fDist = boatInsideDist;
    
    Scene_Subtract( result, intResult );
    

    float boatTopDist = GetBoatTopDistance(vPos);

    result.fDist = -smin(-result.fDist, -boatTopDist, .05 );
    return result;
}

// Function 2853
vec3 map(vec3 p)
{

	vec3 q;
	vec3 d = vec2(0, 1.).yxx;
	float floornoise = .8*noise(3.*p+2.3*iTime)+0.1*noise(20.*p+2.2*iTime);
	dmin(d, min(5.-p.z, 1.5+p.y), 0.1+0.3*step(mod(4.*p.z, 1.), .5), .0); 
	dmin(d, length(p+vec3(0., 0., 1.9+sin(iTime)))-.500, .99, 1.); 		  
	q=p; pR(q.xy, 0.6*iTime);

	dmin(d, length(q+vec3(0, 0., 1.9+sin(iTime)))-.445-0.09*sin(43.*q.x-q.y+10.*iTime), 1., 0.1);
	if( iTime>24. )p.y-=0.1*iTime-2.4; 
	q = abs(p-round(p-.5)-.5);
	if( iTime>24. )p.y+=0.1*iTime-2.4;
	float g = min(min(box(q.xy), box(q.xz)), box(q.yz))-.05;
	float c = min(.6-abs(p.x+p.z), .45-abs(p.y));
	if (iTime>12.) dmin(d, max(g, c), .1, 0.5); //lattice (by Slerpy)

	if( iTime>18. )dmin(d, box(p.zx+vec2(2, 2))-.5, 1., .4); 
	if( iTime>17.3)dmin(d, box(p.zx+vec2(2,-2))-.5, 1.,-.4); 
	return d;

}

// Function 2854
float mapTerrain(vec2 a) {
    //return (cos(a.x*30.0)*sin(a.y*30.0))*0.1;
    float h = perlin(vec3(a.x, a.y, a.x*a.y)*2.1)*0.3;
    h+=smoothNoise(vec3(a.x, a.y, a.x*a.y)*2.0)*0.1;
    h+=smoothNoise(vec3(a.x*a.x, a.y, a.x*a.y)*0.02)*4.0;
    return h;
}

// Function 2855
float SDscene(vec3 p, float t){
	float d = SDMere(vec3(0,0,0),p,.2,t);
	return d;
}

// Function 2856
float map (vec3 p){

	float ax = iTime*0.6;
	float ay = iTime*1.5;
	float az = -iTime*.8;

    float div = iResolution.y*(.7/iResolution.y);
    p.y += .8-abs(sin(iTime*2.5)*1.5);
	p.x +=  -div+(abs(mod(iTime*1.2,div*4.)-div*2.));
    p.xy *= mat2(cos(az),-sin(az),sin(az),cos(az));
    p.zy *= mat2(cos(ax),-sin(ax),sin(ax),cos(ax));
    p.zx *= mat2(cos(ay),-sin(ay),sin(ay),cos(ay));
    
    float sphere1 = length(p)-.75;
    float sphere2 = length(p)-.74;

    float cube1 = length(max(abs(p-vec3(0.0,0.0,-.6))-vec3(.8,.8,.06),0.0))-.01;
    float cube2 = length(max(abs(p-vec3(0.0,0.0,-.3))-vec3(.8,.8,.06),0.0))-.01;
    float cube3 = length(max(abs(p)-vec3(.8,.8,.06),0.0))-.01;
    float cube4 = length(max(abs(p-vec3(0.0,0.0,.3))-vec3(.8,.8,.06),0.0))-.01;
    float cube5 = length(max(abs(p-vec3(0.0,0.0,.6))-vec3(.8,.8,.06),0.0))-.01;
    float cube = min(min(min(cube1,cube2),min(cube3,cube4)),cube5);
    
    return max(-cube,max(sphere1,-sphere2));
}

// Function 2857
float torusDistance(vec3 rayPosition, vec3 torusPosition, vec2 torusSize) {
    vec2 d = vec2( length(rayPosition.xz - torusPosition.xz) - torusSize.x, rayPosition.y - torusPosition.y);
    return length(d) - torusSize.y;
}

// Function 2858
float map( in vec3 pos )
{
    mat=0.0;

    // Deform Space...
    float len = 32.0+sin(iTime*1.3)*17.0;
    float rad =  (1.0/(3.141*2.0)*len);
    float ang = atan(pos.x, pos.y);
    vec2 cyl = vec2(rad-length(pos.xy), pos.z);
    vec3 dp = vec3(cyl, ang * rad);

    if (iMouse.z>0.5)
    {
        dp=pos.zyx;//flat
        dp.xy *= rot(4.7115);
    }
	float dd = chars(dp.zxy);
    return dd*0.5;
}

// Function 2859
void sceneOutrunGrid(vec2 uv, out vec3 params)
{
	uv.y = -abs(uv.y);
	uv.y-=.25;
	vec3 cam = vec3(0,1,0);
	vec3 dir = normalize(vec3(uv,1));

	dir.xz = rotate(dir.xz,sin(iBeat*.2)*2.);
	cam.x += iBeat;

	float t = cam.y / -dir.y;
	vec3 hit = cam+dir*t;

	hit = floor(hit);

	float a = clamp(1.3/t+.1,0.,1.);
	params.x = mod(hit.x+hit.z,2.)<1.?a:0.;
	params.yz = rangePinks;
}

// Function 2860
float sdFluffBall(vec3 p, float s)
{
    float rad2 = s * 0.3;
    s-= rad2 * fbm(p*8.0);
    
    float d = sdSphere(p,s);
    
    return d;
}

// Function 2861
vec2 map( in vec3 pos ){
	return map7(pos);
}

// Function 2862
float sdFloor(vec3 p){
    return p.y;
}

// Function 2863
vec3 Tonemap_ACESFitted2(vec3 acescg)
{
    vec3 color = acescg * RRT_SAT;
    
   #if 1
    color = ToneTF2(color);
   #else
    color = RRTAndODTFit(color);
   #endif
    
    color = color * ACESOutputMat;

    return color;
}

// Function 2864
float smoothDistanceAtt ( float squaredDistance , float invSqrAttRadius )
{
	float factor = squaredDistance * invSqrAttRadius ;
	float smoothFactor = clamp (1. - factor * factor, 0., 1.);
	return smoothFactor * smoothFactor ;
}

// Function 2865
vec3 computeSceneColour(vec3 endPointWS, vec3 rayDirectionWS, float marchedDist,
                       vec4 material)
{
    float normalDt = 0.001 + kPixelConeWithAtUnitLength * marchedDist;
    vec3 normalWS = getNormalWS(endPointWS, normalDt);
    normalWS = fixNormalBackFacingness(rayDirectionWS, normalWS);

    vec3 albedo = oz.xyx;
    vec3 f0Reflectance = oz.xxx * 0.04;
    float roughness = 0.6;
    vec4 emissive = oz.yyyy;
    float ambient = 1.0;

    const vec3 woodAlbedo = vec3(0.15, 0.07, 0.02);

    if(abs(material.x - kMatDefault) < 0.1)
    {
        roughness = material.y;
        float metallicness = material.z;

        albedo = 0.5 * oz.xxx;

        f0Reflectance = mix(0.04*oz.xxx, oz.xxx, metallicness);
        albedo *= 1.0 - metallicness;
    }
    else if(abs(material.x - kMatWoodLog) < 0.1)
    {
        vec2 matUv = material.yz;
        vec3 woodTex = textureLod(iChannel1, matUv * 0.05, 0.0).rgb;
        albedo = woodAlbedo;
        albedo *= woodTex;

        float barkNoise = textureLod(iChannel1, matUv * vec2(0.05, 0.25), 0.0).r;
        float cracks = linearstep(0.5, 0.75, barkNoise);
        float ash = linearstep(0.45, 0.55, 1.0 - barkNoise);
        float isOuterLayer = material.z < -0.999 ? material.y : 1.0;

        material.w += (woodTex.r - cracks*2.0) * 0.2;
        float burnFactor = saturate(material.w*5.0);
        float burntFactor = saturate(material.w*5.0 - 0.2);
        float emissiveStrength = (linearstep(1.0, 0.5, woodTex.r)) * 
            max(0.0, s_globalFireLife*0.75 + 0.25) * linearstep(0.3, 0.8, isOuterLayer);
        emissive = mix(oz.yyyy, vec4(vec3(1.5, 0.07, 0.005)*emissiveStrength, 1.0), burnFactor);

        emissive = mix(emissive, oz.yyyy, burntFactor);
        vec3 burntAlbedo = mix(oz.yyy, oz.xxx * 0.5, ash);
        albedo = mix(albedo, burntAlbedo, burnFactor);

        roughness = mix(0.8, 0.975, burnFactor);
    }
    else if(abs(material.x - kMatRock) < 0.1)
    {
        //Where the rock normal points down will be the contact with the ground
        //We're likely to get shadows/AO there, do reduce the ambient (sky and ground bounce)
        ambient = linearstep(-0.6, -0.0, normalWS.y);
        vec2 matUv = material.yz;
        vec3 rockTex = textureLod(iChannel2, matUv * 0.1, 0.0).rgb;
        albedo = rockTex*0.25;

        float soot = smoothstep(0.5, -0.1, dot(normalWS, normalize(oz.yxy*0.5 - endPointWS)));
        albedo *= (0.05 + 0.95*soot);
        roughness = 0.6 + soot*0.35;
    }
    else if (abs(material.x - kMatGround) < 0.1)
    {
        float groundMat = floor(material.w)/256.0;
        ambient = fract(material.w);

        vec2 matUv = material.yz;
        vec3 albedoTex = textureLod(iChannel1, matUv * 0.5, 0.0).rgb;
        float grass = linearstep(0.4, 0.7, albedoTex.r);
        albedo = mix(vec3(0.07, 0.035, 0.005), vec3(0.01, 0.05, 0.0005), grass);

        float rockBlend = linearstep(0.45, 0.5, groundMat);
        albedo = mix(albedo, albedoTex.rrr*oz.xxx*0.2, rockBlend);
        roughness = mix(0.85, 0.775, grass);
        roughness = mix(roughness, 0.6, rockBlend);
    }
    else if (abs(material.x - kMatCoals) < 0.1)
    {
        float noise = textureLod(iChannel1, endPointWS.xz, 0.0).r;
        noise *= noise;
        albedo = oz.yyy;
        roughness = 0.95;
        
        float randBurnStrength = material.y;
        //material W is the distance to the fire logs
        float isBurning = linearstep(0.075, -0.05, randBurnStrength);
        isBurning *= noise * linearstep(0.3, 0.8, normalWS.y);
        isBurning *= max(0.0, 1.0 - s_globalFireLife*dot(endPointWS, endPointWS)*8.0);
        float emissiveStrength = 1.5 * max(0.0, s_globalFireLife*0.75 + 0.25);
        emissive = vec4(vec3(1.5, 0.05, 0.005) * emissiveStrength, 1.0) * isBurning;
    }

    vec3 sceneColour = computeLighting(endPointWS, rayDirectionWS, normalWS, albedo, 
                                  f0Reflectance, roughness, emissive, ambient);
    
    return sceneColour;
}

// Function 2866
vec2 map( vec3 p )
{
    p.x -= -0.5;
	p.y -= 2.4;
    
    vec2 res = vec2( 2.15+p.y, 0.0 );
    
    // elephant bounding volume
    //float bb = length(p-vec3(1.0,-0.75,0))-2.0;
    //if( bb>res.x )  return res;

    
    vec3 ph = p;
    const float cc = 0.995;
    const float ss = 0.0998745;
    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;
    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;
    
    // head
    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );
    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );

    // nose
    vec2  kk;
    vec2  b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );
    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);
    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );
    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);
    float bd1 = b1.x-tr1;
    float bd2 = b2.x-tr2;
    float nl = b1.y*0.5;
    float bd = bd1;
    if( bd2<bd1 )
    {
        nl = 0.5 + 0.5*b2.y;
        bd = bd2;
    }
    float d2 = bd;
    float xx = nl*120.0;
    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));
    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);

    d2 -= 0.005;
    
    float d = smin(d1,d2,0.2);

    // teeth
    vec3 q = vec3( p.xy, abs(p.z) );
    vec3 qh = vec3( ph.xy, abs(ph.z) );
    {
    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );
    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));
    d = smin( d, d3, 0.1 );
    }
    
    // eyes
    {
    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );
    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));
    d = smin( d, d3, 0.03 );

    float st = length(qh.xy-vec2(-0.31,-0.02));
    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));
        
    const mat3 rot = mat3(0.8,-0.6,0.0,
                          0.6, 0.8,0.0,
                          0.0, 0.0,1.0 );
    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
	d = smax(d, -d4, 0.02 );
    }
   

    // body
    {
    const float co = 0.92106099;
    const float si = 0.38941834;
    vec3 w = p;
    w.xy = mat2(co,si,-si,co)*w.xy;

    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );
	d = smin(d, d4, 0.2 );

    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(2.0,0.6,0.0), vec3(0.9,0.7,0.8) );
	d = smin(d, d4, 0.1 );
    }

    // back-left leg
    {
    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );
    d = smin(d,d3,0.1);
    }
    
    // front-left leg
    {
    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );
    d = smin(d,d3,0.15);
    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );
    d = smin(d,d3,0.15);
    }
    
    // ear
    const float co = 0.8775825619;
    const float si = 0.4794255386;
    vec3 w = qh;
    w.xz = mat2(co,si,-si,co)*w.xz;
    
    vec2 ep = w.zy - vec2(0.5,0.4);
    float aa = atan(ep.x,ep.y);
    float al = length(ep);
    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));
                      
    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);
    r += 0.01*sin(15.0*w.z);
    // section        
    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    
    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    
    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    
    d4 = smax( d4, d5, 0.1 );
    d4 = smax( d4, d6, 0.1 );

    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);
    w.x += 0.05*cos(6.0*w.y);
    
    // cut it!
    d4 = smax( d4, -w.x, 0.03 ); 
    d4 = smax( d4, w.x-wi, 0.03 );     
    
    d = smin( d, d4, 0.3*max(qh.y,0.0) ); // trick -> positional smooth
    
    // conection hear/head
    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );
    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);
    d = smin( d, d3, 0.05 );    
    
    res.x = min( res.x, d );
    
	//------------------
    // teeth
    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );
    d2 = b.x - 0.10 + 0.08*b.y;
    if( d2<res.x ) 
    {
        res = vec2( d2, 1.0 );
    }
    
	//------------------
    //eyeball
    const mat3 rot = mat3(0.8,-0.6,0.0,
                          0.6, 0.8,0.0,
                          0.0, 0.0,1.0 );
    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
    if( d4<res.x ) res = vec2( d4, 2.0 );

    // floor plane
    res.x = smax( res.x, -2.2-p.y, 0.1 );
          
    return res;
}

// Function 2867
vec2 map(in vec3 p) {
	// Terrain
	float h = terrain(p.xz);

    // Snowmens
    vec2 res =  smin(mini(man(p-vec3(-1.3,0,3)), girl(p-vec3(-2,0.25,8))), vec2(p.y - h, 0.));
  
    // Trees
#ifdef TREES
    float dis = trees(p,h);
    return dis<res.x ? vec2(dis, 1.) : res;
#else
    return res;
#endif    
}

// Function 2868
void sceneMap3D(vec3 pos, out float t, out int obj) {
    t = FLOOR_SDF;
    obj = FLOOR_ID;

    float t2 = RED_WALL_SDF
    if (t2 < t) {
        t = t2;
        obj = RED_WALL_ID;
    } 
    t2 = GREEN_WALL_SDF;
    if (t2 < t) {
        t = t2;
        obj = GREEN_WALL_ID;
    }
    t2 = BACK_WALL_SDF;
    if (t2 < t) {
        t = t2;
        obj = BACK_WALL_ID;
    }
    t2 = CEILING_SDF;
    if (t2 < t) {
        t = t2;
        obj = CEILING_ID;
    }
    t2 = TALL_BOX_SDF;
    if (t2 < t) {
        t = t2;
        obj = TALL_BOX_ID;
    }
    t2 = SMALL_BOX_SDF
    if (t2 < t) {
        t = t2;
        obj = SMALL_BOX_ID;
    }
}

// Function 2869
float scene(vec3 p) {
	float b = box(p);
	float s = sphere(p);
	
	//source of all the funkyness
	return min(b,s) - .01/(b-s);
	return min(b,s);
}

// Function 2870
float dist_roundbox( vec3 pos, vec3 size, float r )
{
  return length(max(abs(pos)-size,0.0))-r;
}

// Function 2871
bool intersectSceneFromInside( in vec3 ro, in vec3 rd, float tmax, out float oDis, out vec3 oNor)
{
	intersectObjFromOutside(ro, rd, tmax, oDis, oNor, inner);
    float d2;
    vec3  n2;
    intersectObjFromInside(ro, rd, tmax, d2, n2, outter);
    if(d2 < oDis)
    {
        oDis = d2;
        oNor = n2;
    }
    return oDis < tmax;
}

// Function 2872
float map_plug(vec3 pos)
{
    #ifdef show_plug
    pos = rotateVec2(pos);
    pos+= plugPos;
    
    vec3 pos2 = pos - vec3(0., 0.32, 0.);
    vec3 pos3 = pos - vec3(0., 0.51, 0.);
    vec3 pos4 = (pos - vec3(0., 0.71, 0.))*vec3(1., 1.15, 1.);
    
    float df = sdCone(pos*vec3(1., -1, 1.), vec3(0.8,0.45,0.27));
    df = SoftMaximum(df, -pos.y + 0.02, 50.);
    df = smin(df, sdCylinder(pos2, vec2(0.16, 0.04)), 170.);
    df = smin(df, sdCylinder(pos3, vec2(0.05, 0.08)), 20.8);
    
    float tp = length(pos4) - 0.17;
    float a = atan(pos.x, pos.z);
    tp = SoftMaximum(tp, length(pos.xz) - 0.16*(1. - 0.15*abs(sin(a*5.))), 60.);
    df = smin(df, tp, 45.);
    
    #ifdef dev_mode
    //df = max(df, -pos.x);
    #endif     
    
    return df;
    
    #else
    return 10.;
    #endif
}

// Function 2873
float remap(float a, float b, float c, float d, float t)
{
    return remap01(a, b, t) * (d - c) + c;
}

// Function 2874
float dist_cylinder(vec3 p,vec2 r)
{
	vec2 d=abs(vec2(length(p.xy),p.z))-r;
    return min(max(d.x,d.y),0.0)+length(max(d,0.0))-0.1;

}

// Function 2875
float sceneMap3D(vec3 pos)
{
    // find the smallest t value for marching
    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));

    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));
    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));
    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));
    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));
    t = min(t, box(rotateY(pos + vec3(0, 1, -2), -27.5 * 3.14159 / 180.0), vec3(1.5, 4, 1.5)));
    t = min(t, sphere(pos, 1.3, vec3(-3.5 * sin(iTime), 0.6 + 2.0 * cos(iTime), 2.0 + 3.5 * cos(iTime))));

    return t;
}

// Function 2876
vec2 map(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations
	vec2 res = vec2(OBJ_FLOOR, p.y);
	vec2 obj1 = vec2(OBJ_CEILING, 548.8 - p.y);
	if (obj1.y < res.y) res = obj1;
	vec2 obj2 = vec2(OBJ_BACKWALL, 559.2 - p.z);
	if (obj2.y < res.y) res = obj2;
	vec2 obj3 = vec2(OBJ_LEFTWALL, 556. - p.x);
	if (obj3.y < res.y) res = obj3;
	vec2 obj4 = vec2(OBJ_RIGHTWALL, p.x);
	if (obj4.y < res.y) res = obj4;
	vec2 obj5 = vec2(OBJ_LIGHT, sdBox(p + vec3(-278, -548.8, -292), vec3(65, 0.05, 65)));
	if (obj5.y < res.y) res = obj5;
	vec2 obj6 = mapBlocks(p, ray_dir);
	if (obj6.y < res.y) res = obj6;
	return res;
}

// Function 2877
HitRecord intersectScene(Ray r){
    float tMax=T_MAX;
    float tMin=T_MIN;
    HitRecord hit_record;
    hit_record.isHit=false;
    //interseciton of the spheres 
    for (int i=0;i<sceneList.length();i++)
    {
    	float ts=intersectSphere(r, sceneList[i]);
   		 if (ts>tMin && ts<tMax){
            tMax=ts;
             hit_record.p=r.origin+r.direction*ts;
            hit_record.normal=getSphereNormal(hit_record.p,sceneList[i]);
             hit_record.material=sceneList[i].material;
             hit_record.isHit=true;
         }
        
    }
    //intersection of the Light emitter
    for (int i=0;i<lightList.length();i++)
    {
    	 float tp=intersectRectangle(r,lightList[i]);
   		 if (tp>tMin && tp<tMax){
            tMax=tp;
             hit_record.p=r.origin+r.direction*tp;
            hit_record.normal=getPlaneNormal(hit_record.p,lightList[i].plane);
             hit_record.material=lightList[i].plane.material;
             hit_record.isHit=true;
         }
        
    }
   
    //intersection of the cornell box
    for (int i=0;i<planeList.length();i++)
    {
    	 float tp=intersectRectangle(r,planeList[i]);
   		 if (tp>tMin && tp<tMax){
            tMax=tp;
             hit_record.p=r.origin+r.direction*tp;
            hit_record.normal=getRectangleNormal(r,planeList[i]);
             hit_record.material=planeList[i].plane.material;
             hit_record.isHit=true;
         }
        
    }
     
    return hit_record;

}

// Function 2878
vec2 kodosExteriorSDF(vec3 point){
    float swingTime = 0.0;
    swingTime = PRECOMPUTEDKODOSTIME;
    
    vec3 kodosPoint = translate(point, vec3(3,0,KODOSLIVEHERE));
    vec2 base = vec2(sdCappedCylinder(translate(kodosPoint, vec3(0,-3,0)), vec2(12,3)), KODOSBASECOLOR);
    vec2 lightbulb = vec2(sdSphere(translate(kodosPoint, vec3(-10,-3,-6)), 1.5), KODOSPINKLIGHTBULB);
    vec2 baseBottom = vec2(sdRoundCone( translate(kodosPoint, vec3(0,-13,0)), 12.0, 8.0, 9.0), KODOSGREEN);
    add(base, lightbulb);
    
    vec2 vent = vec2(sdBox(translate(kodosPoint, vec3(0,-3,-11)), vec3(4,1,1)), KODOSVENT);
    add(base, vent);
    
    vec2 vent1 = vec2(sdBox(translate(kodosPoint, vec3(-6.75,-3,-9.5)), vec3(1,1,1)), KODOSVENT);
    add(base, vent1);
    
    vec3 frontRightLegPoint = translate(kodosPoint, vec3(2,-13,-2));
    frontRightLegPoint.xz = opBend(frontRightLegPoint.xz, 0.05);
    frontRightLegPoint.yz = rotate(frontRightLegPoint.yz, PI * 0.6);
    frontRightLegPoint.xy = rotate(frontRightLegPoint.xy, PI * -0.05);
    vec2 frontRightLeg = vec2(sdRoundCone(frontRightLegPoint, 8.0, 2.0, 25.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLeg.x, 1.0), KODOSGREEN);
    
    
    //////
    
    vec3 rightFrontTentaclePoint = translate(kodosPoint, vec3(-2.,-21.,-26));
    vec2 rightFrontTentacle = vec2( sdBezierSansClosestZ(vec3(0.,0.0,0.0), vec3(-3,-5.0,-10.0), vec3(-10.,-5.,-5.0),  rightFrontTentaclePoint, 2.), KODOSGREEN);
    add(base, rightFrontTentacle);
    
    
    ////
    
    vec3 frontLeftLegPoint = translate(kodosPoint, vec3(-2,-13,0));
    frontLeftLegPoint.xz = opBend(frontLeftLegPoint.xz, 0.05);
    frontLeftLegPoint.yz = rotate(frontLeftLegPoint.yz, PI * 0.6);
    frontLeftLegPoint.xy = rotate(frontLeftLegPoint.xy, PI * -0.25);
    vec2 frontLeftLeg = vec2(sdRoundCone(frontLeftLegPoint, 8.0, 2.0, 25.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLeg.x, 1.0), KODOSGREEN);
    
    
    vec3 leftLegPoint = translate(kodosPoint, vec3(-11.5+(2.* abs(swingTime)),-19,0.+(4.* swingTime)));
    leftLegPoint.xz = rotate(leftLegPoint.xz, PI *0.10*swingTime);
    leftLegPoint.yz = rotate(leftLegPoint.yz, PI * 1.);
    leftLegPoint.xy = rotate(leftLegPoint.xy, PI * -0.35);
    
    
    vec2 leftLeg = vec2(sdCappedCone(leftLegPoint, 7.0, 9.5, 5.5), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, leftLeg.x, 1.0), KODOSGREEN);
    
    vec3 leftArmJointPoint = translate(leftLegPoint, vec3(-7,6.5,0));
    leftArmJointPoint.xy = rotate(leftArmJointPoint.xy, PI * 0.51);
    leftArmJointPoint.yz = rotate(leftArmJointPoint.yz, PI * 0.5);
    vec2 leftArmJoint = vec2(sdTorus(leftArmJointPoint, vec2(7.,5.5)), KODOSGREEN);
    vec2 leftArmSlice = vec2(sdPlane(translate(leftArmJointPoint, vec3(-1.5,-1.5,0)), normalize(vec4(-1,0,0,1))), KODOSGREEN);
    diff(leftArmJoint, leftArmSlice);
    
    vec3 leftArmJointSlice = translate(leftArmJointPoint, vec3(-1,-1,0));
    leftArmJointSlice.xz = rotate(leftArmJointSlice.xz, PI * -0.25);
    vec2 leftArmSliceA = vec2(sdPlane(leftArmJointSlice, normalize(vec4(0,0,1,1))), KODOSGREEN);
    diff(leftArmJoint, leftArmSliceA);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, leftArmJoint.x, 0.1), KODOSGREEN);
    //
    vec3 frontLeftLegAPoint = translate(kodosPoint, vec3(-27.+(2.5* abs(swingTime)),-13.,0.+(9.* swingTime)));
    frontLeftLegAPoint.xz = rotate(frontLeftLegAPoint.xz, PI *0.10*swingTime);
    frontLeftLegAPoint.xy = rotate(frontLeftLegAPoint.xy, PI * 0.125);
    vec2 frontLeftLegA = vec2(sdRoundCone(frontLeftLegAPoint, 5.5, 2.0, 15.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLegA.x, 0.1), KODOSGREEN);
    
    vec3 frontLeftLegBPoint = translate(kodosPoint, vec3(-22.+(2.25* abs(swingTime)),2.,0.+(7.75* swingTime)));
    frontLeftLegBPoint.xz = rotate(frontLeftLegBPoint.xz, PI *0.10*swingTime);
    frontLeftLegBPoint.xy = rotate(frontLeftLegBPoint.xy, PI * -0.1);
    vec2 frontLeftLegB = vec2(sdRoundCone(frontLeftLegBPoint, 1.95, 1.5, 3.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontLeftLegB.x, 1.), KODOSGREEN);
    
    vec3 rightLegPoint = translate(kodosPoint, vec3(11.5+(2.* -abs(swingTime)),-19.,0.+(4.* -swingTime)));
    rightLegPoint.xz = rotate(rightLegPoint.xz, PI *0.10*swingTime);
    rightLegPoint.yz = rotate(rightLegPoint.yz, PI * 1.);
    rightLegPoint.xy = rotate(rightLegPoint.xy, PI * 0.35);
    vec2 rightLeg = vec2(sdCappedCone(rightLegPoint, 7.0, 9.5, 5.5), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, rightLeg.x, 1.0), KODOSGREEN);
    
    vec3 rightArmJointPoint = translate(rightLegPoint, vec3(7,6.5,0));
    rightArmJointPoint.xy = rotate(rightArmJointPoint.xy, PI * 0.31);
    rightArmJointPoint.yz = rotate(rightArmJointPoint.yz, PI * 0.5);
    vec2 rightArmJoint = vec2(sdTorus(rightArmJointPoint, vec2(7.,5.5)), KODOSGREEN);
    vec2 rightArmSlice = vec2(sdPlane(translate(rightArmJointPoint, vec3(-1.5,-1.5,0)), normalize(vec4(-1,0,0,1))), KODOSGREEN);
    diff(rightArmJoint, rightArmSlice);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, rightArmJoint.x, 0.1), KODOSGREEN);
    
    vec3 frontRightLegAPoint = translate(kodosPoint, vec3(27.+(2.75* -abs(swingTime)),-13.,0.+(8.75* -swingTime)));
    frontRightLegAPoint.xy = rotate(frontRightLegAPoint.xy, PI * -0.125);
    vec2 frontRightLegA = vec2(sdRoundCone(frontRightLegAPoint, 5.5, 2.0, 15.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLegA.x, 0.1), KODOSGREEN);
    
    vec3 frontRightLegBPoint = translate(kodosPoint, vec3(22.+(3.25* -abs(swingTime)),2.,0.+(9.* -swingTime)));
    frontRightLegBPoint.xz = rotate(frontRightLegBPoint.xz, PI *0.10*-swingTime);
    frontRightLegBPoint.xy = rotate(frontRightLegBPoint.xy, PI * 0.1);
    vec2 frontRightLegB = vec2(sdRoundCone(frontRightLegBPoint, 1.95, 1.5, 3.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, frontRightLegB.x, 1.), KODOSGREEN);
    
    
    vec3 bottomRightLegPoint = translate(kodosPoint, vec3(2,-17,0));
    bottomRightLegPoint.yz = rotate(bottomRightLegPoint.yz, PI * -0.6);
    bottomRightLegPoint.xy = rotate(bottomRightLegPoint.xy, PI * 0.15);
    bottomRightLegPoint.xz = rotate(bottomRightLegPoint.xz, PI * -0.15);
    vec2 bottomRightLeg = vec2(sdRoundCone(bottomRightLegPoint, 8.0, 3.0, 20.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, bottomRightLeg.x, 1.0), KODOSGREEN);
    
    vec3 bottomLeftLegPoint = translate(kodosPoint, vec3(-2,-17,0));
    bottomLeftLegPoint.yz = rotate(bottomLeftLegPoint.yz, PI * -0.6);
    bottomLeftLegPoint.xy = rotate(bottomLeftLegPoint.xy, PI * -0.15);
    bottomLeftLegPoint.xz = rotate(bottomLeftLegPoint.xz, PI * -0.15);
    vec2 bottomLeftLeg = vec2(sdRoundCone(bottomLeftLegPoint, 8.0, 3.0, 20.0), KODOSGREEN);
    baseBottom = vec2(opSmoothUnion(baseBottom.x, bottomLeftLeg.x, 1.0), KODOSGREEN);
    
    add(base, baseBottom);
    return base;
}

// Function 2879
float circleSDF(vec2 st) { // 08
    return length(st - 0.5) * 2.;
}

// Function 2880
float Grip_SDF(in vec3 point)
{
	vec3  tpoint = Translate(point, vec3(0.0, 0.025, 7.35));
    vec3  bounds = vec3(0.125, 0.0005, 1.0);
    float radius = 0.075;
    
    float grip = length(max(abs(
                            vec3(
                                tpoint.x, 
                                tpoint.y, 
                                tpoint.z)) - 
                            vec3(
                                bounds.x - (tpoint.z * 0.045), 
                                bounds.y, 
                                bounds.z) + clamp((cos(tpoint.z * 20.0) * 0.02), 0.0, 1.0), 
                            0.0)) - radius;
   
    return grip;
}

// Function 2881
vec3 mapCoord(vec2 uv)
{
    uv = (fract(uv / 4.) - .5) * 2.;
    return vec3(1., -uv.yx * vec2(1, 1) * (1. - 1. / 1024.));
}

// Function 2882
vec3 DrawScene(vec2 fragCoord)
{
    float y = dot(fragCoord.y / iResolution.y, 1.);
    vec2 uv = (fragCoord - 1. * iResolution.xy) / iResolution.y;
    float bgBlend = smoothstep(0.4, 0.8, y);
    vec2 bgUV = uv * vec2(3.9, 1.15) + vec2(0.5, 0) * iTime * 0.25;
    bgBlend *= Voronoi(bgUV);
    vec3 col = mix(BGLOWER, BGUPPER, saturate(bgBlend));
    
    float stars = Stars(uv, iTime, 75.0);
    LerpWhiteTo(col, STAR_COLOR * 6., saturate(stars));
    
    float moon = Moon(uv);
    moon = 1. - aastep(0.001, moon);
    LerpWhiteTo(col, MOON_COLOR, moon);
    
    vec3 bColor;
    float bd = Buildings(uv, bColor);
    LerpWhiteTo(col, bColor, saturate(1. - sign(bd)));
    
    float overlay = smoothstep(.6, -0.1, y);
    LerpWhiteTo(col, OVERLAY_COLOR, overlay);
    
    vec3 wColor;
    float waterDist = Water(uv, wColor);
    LerpWhiteTo(col, wColor, saturate(1. - sign(waterDist)));
    
    vec4 bubbles = Bubbles(uv);
    LerpWhiteTo(col, bubbles.rgb * 4., saturate(bubbles.a));
    return col;
}

// Function 2883
float dist(vec2 p0, vec2 pf){
     return sqrt((pf.y-p0.y)*(pf.y-p0.y));
}

// Function 2884
float SDF(vec3 p){
    vec3 spherePos = vec3(8,6,25);
    float sphere = length(p-spherePos)-1.;
    float water = p.y+8.+octaves((p.xz/30.)+(iTime/10.)+sin(length(p.xz*2.))*.04);
    float mindst = min(water,sphere);
    return mindst;
}

// Function 2885
vec4 scene(in float rand, in vec3 rO, in vec3 rD, out vec3 colour, out float dis, out vec2 cloud)
{
	float t = Map(rO)*.5*rand;
    dis = 0.0;
	float alpha;
    colour = vec3(0);
	vec4 normal = vec4(0.0);
	vec3 p = vec3(0.0);
     vec2 shade = cloud = vec2(0.0, 0.0);
	for( int j=0; j < 200; j++ )
	{
		if (normal.w > 1.) break;
		p = rO + t*rD;
		float sphereR = sphereRadius(t);
		float h = Map(p);
        
		if( h <= sphereR)
		{
			// Accumulate...
			vec3 nor = getNormal(p, sphereR);
			alpha = (1.0 - normal.w) * ((sphereR-h) / sphereR);
			normal += vec4(nor * alpha, alpha);
            colour += terColour(p.xz)*alpha;
            if (dis == 0.0)dis = t;
		}
		t +=  h*.4 + t * .003;
	}
    
	normal.xyz = normalize(normal.xyz);
	// Scale the alpha up to 1.0...
	normal.w = clamp(normal.w, 0.0, 1.0);
    
    if (p.y <= sphereRadius(t)) specular += .5;
    
    float t2 =.0;
    for(int j=0; j < 120; j++)
	{
        if (t2 > t ||cloud.y >= 1.0) break;
        p = rO + t2*rD;
   		shade.y = mapClouds(p)*.2;
		shade.x = mapClouds(p) - mapClouds(p+sunLight*300.);
        cloud += shade * (1. - cloud.y);
        t2 += 220.0 + t2*.004;
    }
    cloud.x += .5;
    cloud *= .85;
    
	return normal;
}

// Function 2886
float dist2dens(float d) {  	// transition around zero. Tunable sharpness
	return smoothstep(-sharp,sharp,d);
}

// Function 2887
vec4 map( in vec3 p, float time )
{
    // center sphere
    vec4 d = vec4( sdSphere(p,0.12), p );
    
    // gears. There are 18, but we only evaluate 4    
    vec3 qx = vec3(rot(p.zy),p.x); if(abs(qx.x)>abs(qx.y)) qx=qx.zxy;
    vec3 qy = vec3(rot(p.xz),p.y); if(abs(qy.x)>abs(qy.y)) qy=qy.zxy;
    vec3 qz = vec3(rot(p.yx),p.z); if(abs(qz.x)>abs(qz.y)) qz=qz.zxy;
    vec3 qa = abs(p); qa = (qa.x>qa.y && qa.x>qa.z) ? p.zxy : 
                           (qa.z>qa.y             ) ? p.yzx :
                                                      p.xyz;
    vec4 t;
    t = gear( qa,0.0,time ); if( t.x<d.x ) d=t;
    t = gear( qx,1.0,time ); if( t.x<d.x ) d=t;
    t = gear( qz,1.0,time ); if( t.x<d.x ) d=t;
    t = gear( qy,1.0,time ); if( t.x<d.x ) d=t;
    
	return d;
}

// Function 2888
vec3 nmapu(vec3 x){ return x*.5+.5; }

// Function 2889
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c, vn;
  vec2 s, w;
  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;
  bool isImg;
  pgSize = vec3 (2.5, 0.011, 2.5);
  tpCyc = 3.;
  tpWait = 4.;
  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :
     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));
  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));
  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);
  isImg = false;
  dstObj = ExObjRay (ro, rd);
  if (dstObj < dstFarEx) {
    ro += dstObj * rd;
    vn = ExObjNf (ro);
    nDotL = max (dot (vn, ltDirEx), 0.);
    if (idObj <= nPage) {
      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;
      c = HsvToRgb (vec3 ((idPage - 1.) / float (nPage), 0.7, 1.));
      s = pgSize.xz - abs (qHit.xz - vec2 (0.05, 0.));
      col4 = vec4 (0.9, 0.9, 0.8, 0.2);
      if (qHit.y > 0.) {
        w = (qHit.xz - vec2 (0.05, 0.)) / (pgSize.x - 0.05);
        if (min (s.x, s.y) > 0.3) {
          isImg = true;
          ExMain (col, w);
        } else if (min (s.x, s.y) > 0.27) {
          col4 = vec4 (0.6 * c, 0.2);
        } else {
          col4 = vec4 (c, 0.2);
        }
      } else {
        col4 = vec4 (c, 0.2);
      }
    } else if (idObj == nPage + 1) {
      col4 = vec4 (0.9, 0.9, 0.95, 0.2);
      nDotL *= nDotL;
    }
    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);
    if (isImg) col *= 0.2 + 0.8 * sh;
    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);
  } else {
    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);
  }
  return clamp (col, 0., 1.);
}

// Function 2890
float map( in vec3 p )
{
	float d = length(deform(p))-1.5;
	
	return d*.1;
}

// Function 2891
float sdfBox2d(vec2 p, vec2 b) {
  vec2 d = abs(p) - b;
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 2892
vec3 getSceneColor(vec3 ro, vec3 rd) {
	// Raymarch.
	MarchData h;
	float d = .01,
	      den = 0.,
	      maxCloudD = 0.;
	hideCloud = false;
	vec3 p, cloudP;
	for (float steps = 0.; steps < 120.; steps++) {
		p = ro + rd * d;
		h = map(p);
		if (h.d < .0015) {
			if (!h.isCloud) break;
			hideCloud = true;
			cloudP = p;
			maxCloudD = 20. - sdCloud(p + rd * 20.);
		}

		if (d > 55.) break; // Distance limit reached - Stop.
		d += h.d; // No hit, so keep marching.
	}

	if (hideCloud) {
		for (float i = 0.; i < 20.; i++)
			den += clamp(-sdCloud(cloudP + rd * maxCloudD * i / 20.) * .2, 0., 1.);
	}

	hideCloud = false;
	return applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * .05;
}

// Function 2893
float mapIntergalacticCloud(vec3 p, vec4 id) {
	float k = 2.*id.w +.1;  // p/=k;
    return k*(.5 + SpiralNoiseC(p.zxy*.4132+333., id)*3. + pn(p*8.5)*.12);
}

// Function 2894
endif
map( in vec3 pos )
{    
    float angle4 = iTime*TAU*0.25;
    
    MPt res;
    #if INDEXED_MATERIALS
    res.x = 1e38;
    #else
    res.distance = 1e38;
    #endif
    
    #if !INDEXED_MATERIALS
    Material plastic_m;
    plastic_m.color = vec3(1.0);
    plastic_m.diffuse_reflection  = 1.0;
    plastic_m.specular_reflection = 1.0;
    plastic_m.ambient_reflection  = 1.0;
    plastic_m.shininess           = 15.0;

    Material floor_m;
    plastic_m.color = vec3(1.0);
    floor_m.diffuse_reflection  = 1.0;
    floor_m.specular_reflection = 0.2;
    floor_m.ambient_reflection  = 0.5;
    floor_m.shininess           = 1.0;

    Material orange_m = plastic_m;
    orange_m.color = ORANGE_RGB;
    
    Material red_m = plastic_m;
    red_m.color = vec3(1.0,0.0,0.0);
    Material green_m = plastic_m;
    green_m.color = vec3(0.0,1.0,0.0);
    Material blue_m = plastic_m;
    blue_m.color = vec3(0.0,0.0,1.0);
    #endif

    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );
    res = union_op( MPt( plane_sd( pos ),
                        #if INDEXED_MATERIALS
                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m
                        #else
                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )
                        #endif
                       ),
                    res );
    #if 1
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,3.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    #endif
    
        
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_RED
                        #else
                        red_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_GREEN
                        #else
                        green_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_BLUE
                        #else
                        blue_m
                        #endif
                       ),res );

    res = union_op( MPt( sphere_sd( 0.5, at_pos( vec3(2.0,-4.0,0.5), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );

    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );

    res =
       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
#if ALL_PRIMITIVES
    
    res =
       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,6.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,angle4), at_pos(vec3(2.0,10.0,2.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,angle4), at_pos(vec3(2.0,12.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),
                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        vec3(1.0,1.0,-1.0) *
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op(
          intersect_op(
             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
             intersect_op(
                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                ),
                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                )
             )
          ),
          res );
    
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(angle4) ), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( tri_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,30.0,0.0), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( tri_prism_bary_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,32.0,0.288675135), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,32.0,0.288675135), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res =
       union_op( MPt( tri_prism_bary_r_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,34.0,0.5), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,34.0,0.5), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( cline_sd( vec3(2.0,36.0,0.5), vec3(2.0,36,1.5), 0.5, pos ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    res = union_op( MPt( cline_sd( vec3(0.0,0.0,-1.0), vec3(0.0,0.0,1.0), 0.25, at_angle( vec3( QPI * 0.5, 0.0, angle4), at_pos( vec3(2.0,38,1.5), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    res = union_op( MPt( ellipsoid_sd( vec3(0.5,0.25,1.0), at_angle( vec3( 0.0, 0.0, angle4), at_pos( vec3(2.0,40,1.5), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    
    res =
       union_op( MPt( torus82_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,42.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus88_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,44.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere8_sd( 0.5, at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,46.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus42_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,48.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus44_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,50.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere4_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,52.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus32_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,54.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus33_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,56.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere3_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,58.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus2mh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,60.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torusmh2_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,62.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torusmhmh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,64.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( spheremh_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,66.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylinder8_sd( vec2(0.5,0.5), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,68.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylindermh_sd( vec2(0.5,0.5), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,70.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
#endif
	return res;
}

// Function 2895
vec2 GetDistanceWick( const in vec3 vPos )
{
	vec2 vProfilePos = vec2( length(vPos.xz), vPos.y );
	
	float fDistance = vProfilePos.x - 0.015;
	
	float fDistanceTop = vProfilePos.y - (fCandleTop + 0.2);
	if(fDistanceTop > fDistance)
	{
		fDistance = fDistanceTop;
	}
	
	return vec2(fDistance, kMaterialWick);
}

// Function 2896
float mapObjects( in vec3 position )
{
    float modifiedSpeed = iTime * SPEED;
    vec3 sphere1 = vec3(0.,0.,0.);
    vec3 sphere2 = vec3(sin(modifiedSpeed),sin(modifiedSpeed),0.);
    
    float sphere1Distance = sphere(position + sphere1, SPHERE_ONE_SIZE);
    float sphere2Distance = sphere(position + sphere2, SPHERE_TWO_SIZE);
    
    return smoothMin( sphere1Distance, sphere2Distance, BLEND_STRENGTH);
}

// Function 2897
float map( in vec3 p, out vec4 oTrap, in vec4 c )
{
    vec4 z = vec4(p,0.0);
    float md2 = 1.0;
    float mz2 = dot(z,z);

    vec4 trap = vec4(abs(z.xyz),dot(z,z));

    float n = 1.0;
    for( int i=0; i<numIterations; i++ )
    {
        // dz -> 2zdz, meaning |dz| -> 2|z||dz|
        // Now we take the 2.0 out of the loop and do it at the end with an exp2
        md2 *= 4.0*mz2;
        // z  -> z^2 + c
        z = qsqr(z) + c;  

        trap = min( trap, vec4(abs(z.xyz),dot(z,z)) );

        mz2 = qlength2(z);
        if(mz2>4.0) break;
        n += 1.0;
    }
    
    oTrap = trap;

    return 0.25*sqrt(mz2/md2)*log(mz2);  // d = 0.5|z|log|z|/|z'|
}

// Function 2898
Intersection SceneIntersection(Ray r)
{
	Intersection iOut;
	
	Plane plane;
	plane.n = normalize(vec3(0,1,0));
	plane.d = -2.0;
	Intersection iPlane = RayPlane(r, plane);
	iPlane.diffuse = PlaneMaterial(iPlane);
	iPlane.specular = vec3(1,1,1)-iPlane.diffuse;
	iOut = iPlane;
	
	for(int s = 0; s <= 3; s++)
	{
		float fs = float(s);
		float t = iTime*0.3+fs*2.0;
		vec3 pos;
		pos.x = sin(t*2.0)*2.0+sin(t*2.0)*3.0;
		pos.y = abs(sin(t))*2.0;
		pos.z = 6.0+cos(t)*2.0+cos(t*1.5)*2.0;
		Sphere sphere;
		sphere.c = pos;
		sphere.r = 2.0;
		Intersection iSphere = RaySphere(r, sphere);
		iSphere.diffuse = vec3(0.0,0.0,0.2);
		iSphere.specular = vec3(0.2,0.2,0.6);
		iOut = MinIntersection(iOut, iSphere);
	}
	
	return iOut;
}

// Function 2899
vec2 map(in vec3 p) {


    p.xz *= gSceneRot;

    vec2 Q  = vec2(1e9, 0.0);
    const float modSize = 0.3;
    vec3 p1 = vec3(p.x, mod(p.y + modSize / 2.0, modSize) - modSize / 2.0, p.z);

    
    // table
    Q = opUnion(Q, vec2(sdCappedCylinder(p    -       gTablePos, gTableRad, gTableThick), 3.0));    
    Q = opMinus(Q, vec2(sdCylinder(p, gTableHoleRad), 3.0));
    Q = opMinus(Q, vec2(sdSlab(p1, 0.05), 3.0));
    Q.x -= gBevels;
    
    Q = opUnion(Q, vec2(sdTheMainAttraction(p - gPosMain), 1.0));
    Q = opUnion(Q, vec2(sdSphere(p - gPosMain, 0.2), 3.0));


    return Q;
}

// Function 2900
bool Intersect_Scene(vec3 rp, vec3 rd, bool isPrimaryRay, /**/ out float t, out vec3 n, out vec3 a)
{
    vec3 vp, fm;
    bool hit = VoxelRayCast(rp, rd, isPrimaryRay, /*out:*/ vp, fm, t);
    
    n = -fm * sign(rd);
    a = vec3(1.0);
    
    return hit;
}

// Function 2901
float GetDistanceMug( const in vec3 vPos )
{
	float fDistCylinderOutside = length(vPos.xz) - 1.0;
	float fDistCylinderInterior = length(vPos.xz) - 0.9;
	float fTop = vPos.y - 1.0;
       
	float r1 = 0.6;
	float r2 = 0.15;
	vec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);
	float fDistHandle = length(q)-r2;
       
	float fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);
	return fDistMug;
}

// Function 2902
hit traceScene(in ray r) {
	hit ret = nullHit;
    // sort by number of pixels that will be seen to reduce work
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
			lt(ret, tracePOM(r, qdr0, iChannel0, vec3(1.,0.,0.), .1, 1.));
    		qdr0.l.y -= 10.;
            qdr0.c.x += eps;
            
            lt(ret, tracePOM(r, qdr1, iChannel0, vec3(1.,0.,0.), .1, 1.));            
    		qdr1.l.x -= 10.;
            qdr1.c.y += eps;
            
            lt(ret, tracePOM(r, qdr2, iChannel0, vec3(1.,0.,0.), .1, 1.));
    		qdr2.l.y -= 10.;
            qdr2.c.z += eps;
        }
        qdr0.l.y += 50.;
        qdr0.c.x -= eps*5.;
        qdr0.l.z -= 10.;
        
        qdr1.l.x += 50.;
        qdr1.c.y -= eps*5.;
        qdr1.l.z -= 10.;
        
        qdr2.l.y += 50.;
        qdr2.c.z -= eps*5.;
        qdr2.l.x -= 10.;
    }
    return ret;
}

// Function 2903
float Scene(in vec3 rO, in vec3 rD)
{

	float t = .05 * Hash(fcoord);
	
	vec3 p = vec3(0.0);

	for( int j=0; j < 180; j++ )
	{
		if (t > 24.0) break;
		p = rO + t*rD;
		float sphereR = SphereRadius(t);
		float de = Map(p);
		if(abs(de) < sphereR) break;
		t +=  de*.8;
	}

	return t;
}

// Function 2904
float sceneMap3D(vec3 pos) {
    float t;
    int obj;
    sceneMap3D(pos, t, obj);
    return t;
}

// Function 2905
vec2 radialdistort(vec2 coord, vec2 amt)
{
	vec2 cc = coord - 0.5;
	return coord + 2.0 * cc * amt;
}

// Function 2906
Hit shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    Hit finalHit = Hit(start, -1);
    
    for (int i = 0; i < MAX_STEPS; i++) {
        Hit hit = sceneSDF(eye + finalHit.dist * marchingDirection);
        
        finalHit.dist += hit.dist;
        finalHit.id = hit.id;
        
        if (hit.dist < EPSILON) {
			break;
        }
        
        if (finalHit.dist >= end) {
            finalHit = Hit(end, -1);
            break;
        }
    }
    
    return finalHit;
}

// Function 2907
float sdf_half3_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, -pos.x);
}

// Function 2908
float distanceEstimation(vec3 position){
    position *= Rotation;
	vec4 scalevec = vec4(Scale, Scale, Scale, abs(Scale)) / Radius;
	float C1 = abs(Scale-1.0), C2 = pow(abs(Scale), float(1-Iterations));
	vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);
	for (int i=0; i< Iterations; i++) {
    	p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
    	p.xyzw *= clamp(max(Radius/dot(p.xyz, p.xyz), Radius), 0.0, 1.0);
        if(i < 2) p.xyz *= Rotation;
    	p.xyzw = p*scalevec + p0;
	}
	return (length(p.xyz) - C1) / p.w - C2;
}

// Function 2909
float CombineSDF(vec3 p, inout int closest)
{
      
      vec3 pn = vec3(0, -0.6, -0.3) + p*vec3(0.4, 0.2, 0.4);
      pn =  Twist(pn, sin(iTime * 0.942) * 0.22);
  
      float sinf035 = sin(iTime*0.15)*0.90;
      mat3 rmy = CreateRotationY(sinf035*4.925);
      float sd = BoxSDF(pn.xyz,vec3(0.985)); 
      p = rmy*p + vec3(0,1.2*sin(iTime),0);
      float  torus = 
          TorusSDF( (p + vec3(10.0 * sinf035,-5.5,0.0)), 2.09, 0.55);
      float  torus2 = 
          TorusSDF((p + vec3(-10.0 * sinf035,-5.5 ,0.0)), 2.09, 0.55);
      float  torus3 = 
          TorusSDF( (p + vec3(0.0, -5.5 , 10.0 * sinf035)), 2.09, 0.55);
      float  torus4 =
          TorusSDF((p + vec3(0.0, -5.5 , -10.0 * sinf035)), 2.09, 0.55);
      float  torus5 = 
          TorusSDF((p + vec3(7.07* sinf035, -5.5 ,7.07 * sinf035)), 2.09, 0.55);
      float  torus6 = 
          TorusSDF((p + vec3(-7.07* sinf035, -5.5, -7.07* sinf035)), 2.09, 0.55);
    
      sd = smin(torus, sd, 2.40);
      sd = smin(torus2, sd, 2.40);
      sd = smin(torus3, sd, 2.40);
      sd = smin(torus4, sd, 2.40);
      sd = smin(torus5, sd, 2.40);
      sd = smin(torus6, sd, 2.40);
      float pd =  PlaneSDF(p, 5.2); 
      float fin = min(sd, pd);
      closest = OBJECT;
      if(!(abs(fin - pd) > 0.0))
      { 
          closest = FLOOR_PLANE;
      }
      return fin;
}

// Function 2910
vec2 map( in vec3 pos, float time )
{
    float m = 0.0;
	float h = pos.y - terrainMed(pos.xz);

    float sph = tubes( pos, time );
    float k = 60.0;
    float w = clamp( 0.5 + 0.5*(h-sph)/k, 0.0, 1.0 );
    h = mix( h, sph, w ) - k*w*(1.0-w);
    m = mix( m, 1.0, w ) - 1.0*w*(1.0-w);
    m = clamp(m,0.0,1.0);

    return vec2( h, m );
}

// Function 2911
float map(vec3 p )
{
    vec3 q = p;
 // vec3 N = 2.* noise(q/10.) -1.;                // displacement
    vec3 N = divfreenoise(   q/5.)
      ; // + divfreenoise(2.*q/5.) /2.
        // + divfreenoise(4.*q/5.) /4.
        // + divfreenoise(8.*q/5.) /8.;
    q += N;
    float f = // ( 1.2*noise(q/2.+ .1*iTime).x -.2 ) * // source noise
               smoothstep(1.,.8,dot(q,q)/1.5);   // source sphere

 // f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) 
    z = length(q)/2.;                             // depth in sphere
    return f;                        
}

// Function 2912
void RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)
{
    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));
    
    float rayDistance = c_minimumRayHitTime;
    float lastRayDistance = c_minimumRayHitTime;
    
    float lastHitInfoDist = 0.0f;
    
    SRayHitInfo newHitInfo = oldHitInfo;
    newHitInfo.hitAnObject = false;
    
    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)
    {
        vec3 rayPos = startingRayPos + rayDistance * rayDir;
        
        newHitInfo = TestSceneMarch(rayPos);
        
        // these two lines are so that the material code goes away when the test functions are inlined
        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);
        newHitInfo.material = dummyMaterial;
        
        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;
        if (newHitInfo.hitAnObject)
            break;
        
        lastRayDistance = rayDistance;
        rayDistance += max(newHitInfo.dist, c_minStepDistance);

        lastHitInfoDist = newHitInfo.dist;
        
        if (rayDistance > oldHitInfo.dist)
            break;
    }
    
    if (newHitInfo.hitAnObject)
    {
		float refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);
        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);
        
        if (newHitInfo.dist < oldHitInfo.dist)
            oldHitInfo = newHitInfo;
    }
}

// Function 2913
float distSphere( vec3 p, float s )
{
    // Standard UV wrapping for a sphere
    float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / s / .5;
    float v = (.5 - asin(p.y) / 3.14159) / s / .5;
    float disp = texture( iChannel0,
                           vec2(u + iTime * .1,v)).r;
    
    vec3 normal = p;
    // The exponential smooths out the displacement so we don't have crazy looking poles
	return length(p)-s - (disp * 0.1 * exp(1. - abs(normal.y))/exp(1.));
}

// Function 2914
float map( const in vec3 p ) {
    float d = -sdBox( p, vec3( 28., 14., 63. ) );

    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    
    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );
    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      

    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        
    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    
    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );
    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );
    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );
    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); 
    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );
    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );
    
    return d;
}

// Function 2915
float map( in vec3 p )
{
	float d = length(p-vec3(0.0,1.0,0.0))-1.0;
    d = smin( d, p.y, 1.0 );
    return d;
}

// Function 2916
vec4 textureDistorted(const in sampler2D tex, const in vec2 texCoord, const in vec2 direction, const in vec3 distortion) {
  return vec4(textureLimited(tex, (texCoord + (direction * distortion.r))).r,
              textureLimited(tex, (texCoord + (direction * distortion.g))).g,
							textureLimited(tex, (texCoord + (direction * distortion.b))).b,
              1.0);
}

// Function 2917
vec4 SampleScene(vec2 uv)
{
    vec4 buffers[4];
    buffers[0] = texture(iChannel0, uv);
    buffers[1] = texture(iChannel1, uv);
    buffers[2] = texture(iChannel2, uv);
    buffers[3] = texture(iChannel3, uv);
    
    vec4 result = buffers[0];
    
#ifdef ENABLE_COMPOSE
    for(int b = 1; b < 4; ++b)
        result = mix(result, buffers[b], smoothstep(.0, .1, result.w - buffers[b].w));
#else
    result = buffers[BUFFER_DEBUG];
#endif
    
    result.rgb *= smoothstep(MAX_DISTANCE, MAX_DISTANCE - 1.5, result.w);
    
    return result;
}

// Function 2918
float sphereSDF(vec3 p)
{
    return length(p) - 0.25;
}

// Function 2919
float dist(vec3 p)
{	
	vec3 d = textureLod(iChannel0,(p.xz / 32.0), 0.0).rgb;
	p.y += sin(p.x*2.0)*cos(p.z*2.0)*0.85*d.x;
	vec3 p0 = p + d*vec3(0.5,0.4,0.5);
	vec3 p1 = p - d*vec3(0.5,0.4,0.5);
	p0.xz = mod(p0.xz,vec2(0.5)) - vec2(0.25);
	p1.xz = mod(p1.xz,vec2(0.4)) - vec2(0.20);

	vec2 w = vec2(cos(iTime+d.x*1.0),sin(iTime+d.y*1.0)) * (p.y+2.0) * 0.05;
	p0.xz += w;
	p1.xz -= w;
	
	p0 = rotateX(p0,w.x*PI*0.450*p.y*cos(iTime));
	p1 = rotateX(p1,w.y*PI*0.250*p.y*cos(iTime));
	float ground = dot(p,vec3(0.0,1.0,0.0)) + 2.0;
	return min(grass(p0),min(ground,grass(p1)));
}

// Function 2920
float sceneDist(vec3 pos, float len, out float alpha )
{
	// i really should compute this cone radius analytically. i guess
	// it is a cone that is stretched by the aspect ratio
	float pixel_r = cone_r( len );
	
	float dist = min( min( sdSph(pos,sph1), sdSph(pos,sph2) ), sdSph(pos,sph3) );
	dist += pixel_r;
	
	// approximate overlap of pixel cone with shape as a simple proportion of radius
	alpha = 1. - clamp( dist / (2. * pixel_r), 0., 1. ) ;
	
	return dist;
}

// Function 2921
vec2 GetDistOffset(vec2 uv, vec2 pxoffset)
{
    vec2 tocenter = uv.xy+vec2(-0.5,0.5);
    vec3 prep = normalize(vec3(tocenter.y, -tocenter.x, 0.0));
    
    float angle = length(tocenter.xy)*2.221*DISTORTION_BARREL;
    vec3 oldoffset = vec3(pxoffset,0.0);
    float anam = 1.0-DISTORTION_ANAMORPHIC; // Prevents a strange syntax error
    oldoffset.x *= anam;
    
    vec3 rotated = oldoffset * cos(angle) + cross(prep, oldoffset) * sin(angle) + prep * dot(prep, oldoffset) * (1.0-cos(angle));
    
    return rotated.xy;
}

// Function 2922
vec2 mapTransparent( vec3 p, out vec4 matInfo )
{
    matInfo = vec4(0.0);
    
    float d5 = mapDrop( p );
    vec2  res = vec2(d5,4.0);

    float d6 = mapLeafWaterDrops( p );
    res.x = min( res.x, d6 );

    return res;
}

// Function 2923
float dstScene(vec3 p) {
 
    vec3  n = normalize(-p);
    vec2 uv = asin(n.xy) / 3.14159 + .5;
    float d = texture(iChannel0,uv).x*.01;
    
    float dst = length(p)-(1.+d);
    dst = min(dst, p.y + 1.);
    
    return dst;
    
}

// Function 2924
float remap01(float a, float b, float t) {
	return sat((t-a) / (b-a));
}

// Function 2925
vec4 boxmap(sampler2D sam,vec3 p,vec3 n)
{
    vec3 m = pow(abs(n), vec3(32.) );
	vec4 x = texture( sam, p.yz );
	vec4 y = texture( sam, p.zx );
	vec4 z = texture( sam, p.xy );
	return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 2926
float map(vec3 p){
    
    // Perturbing the walls with a sinusoidal function just a bit to give the tunnel a 
    // less man made feel.
    vec3 pert = p*vec3(1, 1, .5);
    pert = sin(pert - cos(pert.yzx*2.))*.25;
    
    //float id = floor(p.z/16.)*16. + 8.;
    //vec3 pos = vec3(path(id), id);
    //vec3 q = p - pos;
     
    // Wrapping the tunnel, vents and floor around the path.
    p.xy -= path(p.z).xy;
    
    // The ground. Nothing fancy. 
    float ground = p.y + 2.375 + pert.y*.125;
    
    
    // A pretty hacky vent shaft object. I'll rewrite this in a better way at some
    // stage, so I wouldn't pay too much attention to it.
    vec3 q = p;
    // Repeting the shafts every 16 units.
    q.z = mod(q.z + 0., 16.) - 8.; // (q.z/16. - floor(q.z/16.))*16. - 8.;
    

    // The shaft cross section. I decided to make them octagonal, for whatever reason, 
    // but it's not mandatory.
    float sCirc = dist(q.xz) - 1.15;
   
    // The ventilation shaft.
    float shafts = max(abs(sCirc) - .1, abs(q.y - (4.6)) - 2.);
    
    // The rim under the vent.
    float rim = dist(vec2(sCirc, q.y - 2.6)) - .15; 
    
    shafts = min(shafts, rim);
    
    
    // Shaft holes. The end bit is needed to stop the shaft holes from continuing
    // through the floor.
    float shaftHoles = max(min(sCirc - .05, rim - .1), -p.y);
    //shaftHoles = smin(shaftHoles, rim, 1.);
    
 
    // Subdividing space into smaller lots to create the vent grids. I probably should
    // had created these separately in order to set unique materials, but I've attached 
    // them to the vent object.
    q.xz = mod(q.xz, .25) - .25/2.;
    q.y -= 3. - .25;
    float ventGrid = length(q.xy) - .035;//min(length(q.yz), length(q.xy)) - .05;
    ventGrid = max(ventGrid, sCirc);
    //shafts = min(shafts, ventGrid);
    
    // Cylindrically mapping the rocky texture onto the walls of the cylinder. The 
    // cylinder has been warped here and then, so it's not an exact fit, but no one
    // will notice.
    float sf = getCylTex(p).a;
    
    // Arrange for the rocky base to effect the sand level ever so slightly.
    ground += (.5 - sf)*.25;

    p.xy *= vec2(.9, 1); // Widen the tunnel just a bit.
    // Add the sinusoidal perturbations to the tunnel via some space warping. You could
    // also do this in height map form, but I chose this way... for some reason that
    // escapes me at present. :)
    p += pert; 
   
    // The tunnel object -- otherwise known as a glorified cylinder. We're approaching
    // the cylinder walls from the inside. Hence, the negative sign.
    float tun =  -(polDist(p.xy) - 2.7);
    
    // There a light sitting about the vents outside the tunnel, so I've given the
    // tunnel a bit of thickness. That's all this is 
    tun = max(tun + (.5-sf)*1., -(tun + 4.));
    // Creating some holes in the tunnel roof for the vents to fit into. A smooth blend
    // is used to smoothen the rocks around the grated end of the vent.
    tun = smax(tun, -shaftHoles, .5);
     
    
    // Save the IDs. For speed, they're sorted outside the loop.
    vObjID = vec4(tun, shafts, ground, ventGrid);
    
    float df = min(min(tun, ventGrid), min(shafts, ground));
    

    // Return the distance -- Actually, a fraction of the distance, since a lot of 
    // this isn't Lipschitz friendly, for want of a better term. :)
    return df*.86;
 
}

// Function 2927
float LocalDistanceToRoundBox(vec3 P, RoundBox box)
{
	return length(max(vec3(0), abs(P) - box.extent + box.roundRadius)) - box.roundRadius;
}

// Function 2928
HitInfo sceneH(const in vec3 p) {
    vec3 q;

    vec3 coe = vec3(0., 0., -EARTH_RADIUS);

    vec2 p1 = vec2(70, 90) + iTime * vec2(-3.3, 3.4);
    vec2 p2 = vec2(70, -30) + iTime * vec2(3.9, -3.4);
    vec2 p3 = vec2(70, 60) + iTime * vec2(3.6, 3.2);

    q = p - coe;
    HitInfo earth = HitInfo(EARTH, sphereSDF(q / EARTH_RADIUS) * EARTH_RADIUS);

    earth = ground(earth, p, p1);
    earth = ground(earth, p, p2);
    earth = ground(earth, p, p3);

    earth = mushroom(earth, p, p1);
    earth = mushroom(earth, p, p2);
    earth = mushroom(earth, p, p3);

    float sky_radius = 2. * EARTH_RADIUS;
    HitInfo sky = HitInfo(SKY, - sphereSDF(p / sky_radius) * sky_radius);

    return unionH(sky, earth);

}

// Function 2929
float map(vec3 p)
{
    return length(max(vec3(dot(sin(p),cos(p))),cos(p))*2.0-1.0) - 3.0;
}

// Function 2930
float scene(vec2 p) {
    objectId = 0;	
    float box = centerBox(p);
    float light = light(p);
    if(box > light) {
    	objectId = 1;
        objectColor = vec3(0,0,1);
    }
    return min(box, light);
}

// Function 2931
vec3 Scene(in vec3 rO, in vec3 rD)
{
    float t = 10.0;
	vec3 p = vec3(0.0);
	vec4 sum = vec4(0.0);
	for( int j=0; j < 80; j++ )
	{
		if (sum.a >= 1.0) break;
		p = rO + t*rD;
		vec4 res = Map(p);

		res.rgb *= res.a;
		sum = sum + res * (1.0 - sum.a);	
		
		t += 0.15;
	}
	return clamp(sum.xyz, 0.0, 1.0);
}

// Function 2932
vec3 tonemap(vec3 color)
{
    // Tonemap (fits colors to 0.0-1.0)
    color = 1.0-exp(-color*exposure);

    // sRGB Color Component Transfer: https://www.color.org/chardata/rgb/sRGB.pdf
    color  = vec3(
    color.r > 0.0031308 ? (pow(color.r, 1.0/2.4)*1.055)-0.055 : color.r*12.92,
    color.g > 0.0031308 ? (pow(color.g, 1.0/2.4)*1.055)-0.055 : color.g*12.92,
    color.b > 0.0031308 ? (pow(color.b, 1.0/2.4)*1.055)-0.055 : color.b*12.92);

    return clamp(color, 0.0, 1.0);
}

// Function 2933
float map( in vec3 pos )
{
    vec2 r = pos.xz - sph1.xz;
    float h = 1.0-2.0/(1.0 + 0.3*dot(r,r));
    return pos.y - h;
}

// Function 2934
float map(vec2 x) {
    return texture(iChannel0, x).x;
}

// Function 2935
float map_trees(vec3 p)
{
    p.y += 0.5f;
	float d = 100.0;
	vec2 n = floor( p.xz );
    vec2 f = fract( p.xz * mix(1.0, 2.0, fbm_hash(p.xz)));
    for( int j=-1; j<=1; j++ )
	for( int i=-1; i<=1; i++ )
	{
		vec2  g = vec2( float(i), float(j) );
		vec2  o = hash22( n + g );
        vec2  v = hash22( n + g + vec2(1.5,1.5) );
		vec2  r = g - f + o;

        float height = TREE_MAX_HEIGHT * (0.4+0.3*v.x);
        float width = 0.3*(0.9 + 0.2*v.x + 0.4*v.y);
        vec3  q = vec3(r.x,p.y-height*0.9,r.y);
        float k = sdEllipsoidY( q, vec2(width*0.8,height*0.9) );

        d = min(d, k);
	}
    
    d-= .2*fbm_hash(2.*p.xz);
	return max(0., d);
}

// Function 2936
float colDist(vec4 c1, vec4 c2)
{
    return dot(c1.xyz-c2.xyz,vec3(.3333));
}

// Function 2937
vec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor){
    
    const vec2 e = vec2(0.002, 0);
    float ref = bumpFunc(p, n);                 
    vec3 grad = (vec3(bumpFunc(p - e.xyy, n),
                      bumpFunc(p - e.yxy, n),
                      bumpFunc(p - e.yyx, n) )-ref)/e.x;                     
          
    grad -= n*dot(n, grad);          
                      
    return normalize( n + grad*bumpfactor );
	
}

// Function 2938
float SDF( vec3 pos )
{
    vec2 d = Map(pos.xz);
    
    const float minH = .3;
    const float houseH = 2. - minH;
    const float scraperH = 6. - houseH;
    const float maxH = minH+houseH+scraperH;
    float h = d.y*houseH + pow(d.y,20.)*scraperH + minH;
    if ( d.y < .1 ) h = 0.; // parks
    
    // need to constrain the gradient - because we don't know how tall adjacent buildings are
    // but this confuses the ambient occlusion, making roofs a bit darker
    float roof = min( pos.y-h, roadRad*2. );
    
    float sdf = max( d.x, roof );
    
    // floor
    sdf = min( sdf, pos.y );
    
    sdf = max( sdf, pos.y-maxH ); // max h, let it ramp up above roadRad so the sky looks good
    
    return sdf;
}

// Function 2939
vec3 acesToneMapping( vec3 col )
{
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (col * (a * col + b)) / (col * (c * col + d) + e);
}

// Function 2940
float dist(vec3 pos)
{
    vec3 pos0=pos;
    pos+=(texture(iChannel0,sph2frag(pos)/iResolution.xy).xyz-.5)*.75;
    float d = 10000.;
    
    // sphere in the middle
	d=min(d,length(pos)-1.);
        
    return d;
}

// Function 2941
float TorusSDF(vec3 p, float R, float r)
{
    
    float xy = length(p.xy) - R;
    float z = length(vec2(xy, p.z)) - r;
    return z;
}

// Function 2942
float sdfEllipse(vec2 center, float a, float b, vec2 coord)
{
    float a2 = a * a;
    float b2 = b * b;
    return (b2 * (coord.x - center.x) * (coord.x - center.x) + 
        a2 * (coord.y - center.y) * (coord.y - center.y) - a2 * b2)/(a2 * b2);
}

// Function 2943
float map(in vec3 rp)
{
    // fetch noise from cache
    float noise = texture(iChannel0, cache_uv(rp)).r;
    
    float l = rp.y - noise * noise_scale();
    
    float bounds = sdBox(rp - map_center(), map_extends());
    l = max(l, bounds);
    
    return l;
}

// Function 2944
vec2 map( vec3 p, out vec3 matInfo )
{
    matInfo = vec3(0.0);
    
    p.x -= -0.5;
	p.y -= 2.4;
    
    //--------------------

    float h = 2.1 + 0.1*textureLod( iChannel2, 0.07*p.xz, 0.0 ).x;
    
    float d2 = p.y + h;
    vec2 res = vec2( d2, 3.0 );

    
    //--------------------
#if 1
    for( int j=ZERO; j<2; j++ )
    {
        float dleaves = 1000.0;

        vec3         pl = p - vec3(-0.85,0.30,2.1);
        vec3         pd = vec3(-0.2,-0.5,-0.3);
        if( j==1 ) { pl = p - vec3(-0.00,0.45,2.2);
                     pd = vec3( 0.2,-0.6, 0.1); };
        
        float pr = dot(pl,pl);
        if( pr<1.5 )
        {
            float sim = 1.0;
            vec2 uv = vec2(0.0);
            for( int i=ZERO; i<9; i++ )
            {
                float h = float(i);
                float hh = float(i+10*j);
                vec3 sc = hash3(hh*13.92);
                vec3 di = sin(vec3(0.0,1.0,2.0)+hh*vec3(10.0,15.0,20.0));
                vec3 of = pd*h/8.0;

                vec3 q = pl - of;
                q = rotationMat( 6.2831*di*vec3(0.1,-0.1,0.9) + 0.04*sin(20.0*hh + 0.7*iTime) ) * q;

                q.z = q.z*sim - 0.22;

                q.xz += q.y*q.y*2.0;

                q *= 0.75 + 0.4*sc.x;

                d2 =          sdSphere( q, vec3(0.0,-0.1,0.0), 0.25 );
                d2 = max( d2, sdSphere( q, vec3(0.0, 0.1,0.0), 0.25 ) );
                d2 = smax( d2, abs(q.x)-0.003, 0.01 );

                d2 /= 0.75 + 0.4*sc.x;

                if( d2<dleaves )
                {
                    dleaves = d2;
                    uv = q.yz;
                }
                sim *= -1.0;
            }
            vec2 s2 = sdSegment( pl, vec3(0.0), pd );
            d2 = s2.x - 0.01;
            dleaves = min(dleaves,d2); 
            if( dleaves<res.x ) 
            {
                res = vec2( dleaves, 6.0 );
                matInfo.x = 0.0;
                matInfo.yz = uv;
            }
        }
    }
#endif

    //--------------------
    
#if 1
    {
    vec2 idb = floor(p.xz/4.0);        
    for( int j=ZERO; j<2; j++ )    
    for( int i=ZERO; i<2; i++ )    
    {
        vec2 id = idb + vec2(float(i),float(j));
        if( id.x>4.0 )
        {
            float h = id.x*7.7 + id.y*13.1;
            float si = hash1(h*31.7);
            float al = hash1(h*41.9);

            if( si>0.5 )
            {
                vec3 bc = vec3(id.x*4.0+2.0,-2.0,id.y*4.0+2.0);
                bc.xz -= 1.0*hash3( h*7.7 ).xy;
                vec3 eli = vec3(1.6*(0.3 + 0.7*si),1.5*(0.5 + 0.5*al),1.6*(0.3 + 0.7*si));

                #if 0
                d2 = sdEllipsoid( p, bc, eli );
                if( d2<res.x ) 
                {
                    res = vec2( d2, 4.0 );
                    matInfo.x = hash1(h*77.7);
                }

                #else
                float d4 = 1000.0;
                float d3 = 0.0;
                for( int j=0; j<12; j++ )
                {
                    float h2 = float(j);
                    vec3 of = normalize((-1.0+2.0*hash3(h*11.11+h2*9.13)));

                    of.y = of.y*of.y - 0.1;
                    of *= eli;

                    vec3 bb = bc + of;
                    d2 = sdEllipsoid( p, bb, 0.5*vec3(1.0,0.85,1.0));

                    if( d2<d4)
                    {
                        d4 = d2;
                        d3 = hash1(h*77.7);
                    }
                }

                float di = textureLod(iChannel2,0.12*p.xz,0.0).x + 
                           textureLod(iChannel2,0.12*p.yz,0.0).x +
                           textureLod(iChannel2,0.12*p.xy,0.0).x;
                di /= 3.0;
                d4 -= 0.4*di*di;

                if( d4<res.x ) 
                {
                    res = vec2( d4, 4.0 );
                    matInfo.x = d3;
                    matInfo.y = di;
                }
                #endif
            }
        }
    }
    }
#endif    
     
#if 1
    {
    vec3 tc1 = vec3(50.0,0.0,-40.0);
    vec3 tc2 = vec3(85.0,0.0,5.0);
    float td1 = dot(p.xz-tc1.xz,p.xz-tc1.xz);
    float td2 = dot(p.xz-tc2.xz,p.xz-tc2.xz);
    vec3 tc = (td1<td2) ? tc1 : tc2;
    float d2 = mapTree( p - tc );
    if( d2<res.x ) 
    {
        res = vec2( d2, 5.0 );
        matInfo.x = 0.0;
    }
    }
#endif
    
    return res;
}

// Function 2945
float map(vec2 pos){
  
  vec2 localUV;
  vec2 cellID;
  float currentCellSize = 2.;// ?
  float s = 1.;

  for(float i = 1.; i < MAX_LEVEL; i++){
    
      localUV = s * pos;
      cellID = floor(localUV);
      float rndID = rnd(cellID);

      
      s *= 2.;
    
    //starting cellSize at 2 because we only break after dividing by 2.
     currentCellSize /=2.;
    //divide by 2 AFTER currentCellSize because otherwise you don't
    //calculate the steps properly at the random exit points
    if( rndID < 0.5 ) break;
  }
  //give back cellsize, that's critical
  return currentCellSize;
}

// Function 2946
vec2 GetDist(vec3 p) {
    vec3 originalP = p;
    
    p.x += sin(iTime*2.2)*0.12;
    p+=noise3d(p*300.0)*0.001;
    vec3 prevP = p;

    p.x = abs(p.x);
    p.x-=0.12;
    vec2 dleg = drawLeg(p-vec3(0.0,-0.42,-0.05));
    p = prevP;
    
    p.x = abs(p.x);
    
    p.x-=0.29;
    p.x*=-1.0;
    vec2 dCannon = drawCannon(p-vec3(0.0,0.42,0.03));
    vec2 darm = drawArm(p-vec3(0.0,0.28,0.0));
    p = prevP;
    vec2 dBody = drawBody(p-vec3(0.0,0.1,0.0));
    vec2 dhead = drawHead(p-vec3(0.0,0.39,0.015));
    
    p = originalP;
    vec2 dBox = drawBox(p-vec3(0.0,-0.47,0.0));
    
    vec2 model = combine(combine(dleg,darm),combine(dBody,dhead));
    return combine(combine(model,dCannon),dBox);
}

// Function 2947
vec3 dsteelSDF (vec3 p) {
    float steelSDFp = steelSDF(p);
    return normalize(
        vec3(
            steelSDF(vec3(p.x+1e-3, p.y, p.z))-steelSDFp,
            steelSDF(vec3(p.x, p.y+1e-3, p.z))-steelSDFp,
            steelSDF(vec3(p.x, p.y, p.z+1e-3))-steelSDFp
        )
    );
}

// Function 2948
hit traceScene(in ray r) {
    //trace objects and lights
    hit ret = nullHit;
    lt(ret, trace(r, pln1));
    lt(ret, trace(r, lit1));
    //lt(ret, trace(r, lit2));
    lt(ret, trace(r, sph1));
    return ret;
}

// Function 2949
float map(float value, float min1, float max1, float min2, float max2) {
  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1),min2, max2);
}

// Function 2950
float spin_icon_dist(vec2 pos, float size, bool flip, bool dim) {
    
    if (flip) { pos.y = -pos.y; }  
    pos.x = abs(pos.x);
    
    vec2 p0 = vec2(0, -0.7)*text_size;
    vec2 p1 = vec2(0.35, -0.7)*text_size;
    vec2 p2 = vec2(0.0, -1.1)*text_size;
    
    float d = max(dline(pos, p0, p1), dline(pos, p1, p2));
    
    if (dim) { 
        d = abs(d + 0.02*text_size) - 0.02*text_size;
    }
    
    return d;
       
}

// Function 2951
Hit scene(vec3 p)
{
    //p.xz = mod(p.xz, 3.0)-1.5;
    
	vec3 q = p;
    float t = 1.5*time;
	float cycle = max(0.0, sin(t)-0.3);
    
	Hit h = Hit(1.0e6, vec3(0.0,0.1,0.3), 0.1, 0.2);

	// box
	float a = opS(sdBox(p, vec3(0.5, 0.3, 0.14)), sdBox(p, vec3(1.0, 0.5, 0.75)));
	float b = sdBox(p-vec3(-0.8, 0.54, 0.0), vec3(0.8, 0.4, 0.8));
	h.d = opS(b, a);

	// lid
	#ifdef LID
	q = p;
	q.xy = rotate(q.xy, -max(0.004, 0.2*smoothstep(0.0, 0.3, cycle)), vec2(1.0, -0.11));
	
	a = sdBox(q-vec3(-0.501, 0.32, 0.0), vec3(0.5, 0.18, 0.75));
	b = sdBox(q-vec3(-0.401, 0.26, 0.0), vec3(0.46, 0.2, 0.71));
	h.d = min(h.d, opS(b, a));
	#endif
	
	// thing
    #ifdef THING
	q = p;
	q.xy = rotate(q.xy, -abs(1.26*smoothstep(0.3, 0.5, 1.0-cycle)), vec2(-0.1, -0.2));
	
	a = opS(sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.4, 0.2)), sdCappedCylinderZ(q-vec3(0.1, 0.18, 0.0), vec2(0.5, 0.08)));
	b = sdBox(q-vec3(0.7, 0.36, 0.0), vec3(0.5));
	h.d = min(h.d, opS(b, a));
	#endif
    
	// switch
    #ifdef SWITCH
	b = sdSegment(p, vec3(0.24, 0.5, 0.0), vec3(0.18+0.14*step(-0.6, sin(t-1.99)), 0.7, 0.0), 0.03);
	b = min(b, sdCappedCylinderY(p-vec3(0.24, 0.42, 0.0), vec2(0.1, 0.1)));
    b = min(b, sdTorus(p-vec3(0.24, 0.525, 0.0), vec2(0.05, 0.018)));
	
	if (b < h.d) 
	{
		h.d = b;
		h.color = vec3(0.1);
		h.spec = 0.7;
		h.ref = 0.3;
	}
	#endif
    
    #ifdef ALIENHAND
    a = alienHand(p-vec3(0.4, 0.71, 0.0), smoothstep(1.0, 0.8, sin(t-4.2)));
    if (a < h.d)
    {
        h.d = a;
        h.color = vec3(0.4);
        h.spec = 0.0;
        h.ref = 0.0;
    }
    #endif
    
    #ifdef FLOOR
    
    #ifdef FLOOR2
    a = dot(p,vec3(0.0, 1.0, 0.0)) + 0.5;
    #else
    a = sdBox(p-vec3(0.0, -0.5, 0.0), vec3(2.0, 0.01, 2.0));
    #endif
    if (a < h.d)
    {
        h.d = a;
        #ifdef FLOOR2
        h.color = vec3(0.5*mod(sin(p.z)-sin(p.x), 0.4)+0.5);
		//h.color = vec3(0.3+0.5*mod(p.z, 0.4));
        #else
        h.color = vec3(0.8);
		#endif
        h.spec = 0.2;
        h.ref = 0.2;
    }
    #endif
    
	return h;
}

// Function 2952
float map(vec3 p){
    
 
    p.xy -= path(p.z); // Wrap the passage around
    
    vec3 w = p; // Saving the position prior to mutation.
    
    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.
   
    
    float ground = p.y + 3.5 + dot(op, vec3(.222))*.3; // Ground plane, slightly perturbed.
 
    p += (op - .25)*.3; // Adding some triangular perturbation.
   
	p = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).
    
    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.01; // Spherize and add the canyon walls.
    
    return min(ground, canyon);

    
}

// Function 2953
float distLine (vec2 p, vec2 a, vec2 b) {
    vec2 pa = p - a;
    vec2 ba = b - a;
    float t = clamp ( dot (pa, ba) / dot (ba, ba), .0, 1.);
    return length (pa - ba*t);
}

// Function 2954
vec2 MapBoxes(vec3 rayPoint)
{
    rayPoint += vec3(0.0, 0.0, -3.0);
    float a = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(4.2, 2.4, 7.2));
    float b = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(3.8, 2.0, 6.5));
    float c = SDFBox(rayPoint + vec3(-0.0, 0.4, -9.0), vec3(2.45, 0.45, 10.0)) - 0.4;
    
    vec3 rep = vec3(0.0, 0.0, 1.3);
    vec3 p = mod(rayPoint, rep) - rep * 0.5;
    float vent = SDFBox(p + vec3(0.0, -2.5, 0.0), vec3(3.1, 0.8, 0.4));
    float scene = max(max(max(a, -b), -c), -vent);
    float d = SDFBox(rayPoint + vec3(-5.2, 0.4, -0.0), vec3(2.45, 0.45, 3.0)) - 0.4;
    
    scene = max(scene, -d);
    
    
    
    return vec2(scene, TYPE_BOX);
}

// Function 2955
float map(vec3 p){
    
    // Floor. Not really used here, but if you changed the block dimensions,
    // the you'd want this.
    float fl = -p.z + .1;

    // The extruded blocks.
    vec4 d4 = blocks(p);
    gID = d4.yzw; // Individual block ID.
    
 
    // Overall object ID.
    objID = fl<d4.x? 1. : 0.;
    
    // Combining the floor with the extruded image
    return  min(fl, d4.x);
 
}

// Function 2956
SDFRes addSDF(in SDFRes f1, SDFRes f2 )
{
    if (f1.d < f2.d)
    	return f1;
    return f2;
}

// Function 2957
vec4 renderScene(in vec3 ro, in vec3 rd, in vec2 fragCoord)
{
    vec4 res = vec4(0.0);
    vec4 scattering = vec4(0.0);
    MarchResult m = raymarchScene(ro, rd, scattering, fragCoord);
    if (m.t > 0.0)
    {
        vec3 p = ro + m.t * rd;
        vec3 N = normalTerrain(p.xz).yzw;
        
        if (m.materialID == 0)
        {
            int numSteps = 256;
            int actualSteps = 0;
            vec3 normal = transpose(getRotation()) * AreaLightNormal;
            vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
            vec3 bitangent = normalize(cross(normal, tangent));
            for (int i = 0; i < numSteps; ++i)
            {
                vec3 R = reflect(rd, N);
                float x0 = rand(rand(fragCoord.y * iResolution.y + p.x * p.y * 6543623.22355) +  float(i) * 3428.532546);
                float x1 = rand(rand(fragCoord.x * iResolution.y +  p.z * p.y * 2124435.5346) + float(i) * 9067.214721);
                float x2 = rand(rand(fragCoord.x * iResolution.x +  p.z * p.x * 352445.3466) + float(i) * 6797.745721);
                R = normalize(R + vec3(x0, x1, x2));
                if (dot(R, N) > 0.0)
                {
                	float it = -dot(p - AreaLightPosition, normal) / dot(R, normal);
                	if (it > 0. && it < AreaLightPosition.z)
                	{
	                    vec3 hit = p + it * R;
	                    float x = dot(hit, tangent);
	                    float y = -dot(hit, bitangent);
                    	if (AreaLightPosition.x - AreaLightSize.x < x && x < AreaLightPosition.x + AreaLightSize.x
                            && AreaLightPosition.y - AreaLightSize.y < y && y < AreaLightPosition.y + AreaLightSize.y)
                        {
                            vec3 lightPosition = AreaLightPosition + x * tangent + y * bitangent;
	                        res.xyz += (getLightIntensity(lightPosition)) * (1.0 / float(numSteps));
                	    }
                	}	
                }
            }     
        }
        else if (m.materialID == 1)
        {
            res.xyz = getLightIntensity(p);
        }
        
        res.xyz = res.xyz * scattering.w + scattering.rgb;
        res.w = 1.0;
    }
    else
        res = vec4(scattering.xyz, 1.0);
    return res;
}

// Function 2958
float scene(vec3 p) {
    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture
    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);
}

// Function 2959
float map( in vec3 p )
{
	float e = r*0.1*sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z);
	
    return tan(-iTime) * 0.1 + min( e + length(p + p.y ) - 1.0, p.y +2.0 );
}

// Function 2960
float sdfSphere(in vec3 p,in vec3 center,in float radius){
	return length(p-center)-radius;
}

// Function 2961
vec2 map ( vec3 r ) {
  
    vec2 flr = vec2(r.y+2., 1.);
    vec2 fin = flr;// FINAL
    vec2 wll = vec2(r.x+2., 2.);
    vec2 wl2 = vec2(-r.z+5., 3.);
    mmn(wll, wl2);
    mmn(fin, wll);
	
    //BED
    
    vec2 mattress = vec2 ( udRoundBox(r-vec3(2, .01, -3), vec3(2, .0003, 4), 1.), 4);
    mattress.x+=texture(iChannel1, (r.xy+r.zy+r.xz*vec2(7, 1))/50.).r/27.;
    mmn(fin, mattress);
    vec2 head = vec2 (udBox(r-vec3(2.5, .7, 1.5), vec3(2.26, 2, .5)), 5.);
    float b = udBox(r-vec3(2,-1.5, -2.9), vec3(2.76, .59, 4.9));
    head.x=min(b,head.x);
    mmn(fin,head);
    
    return fin;
}

// Function 2962
vec2 map_torch(vec3 p, vec3 origin)
{
    p -= origin;
    return sdf_union(map_torch_handle(p), map_flame(p));
}

// Function 2963
float sdf_cone(vec3 p, float radius, float height) {
	vec2 q = vec2(length(p.xy), p.z);
	vec2 tip = q - vec2(0, height);
	vec2 mantleDir = normalize(vec2(height, radius));
	float mantle = dot(tip, mantleDir);
	float d = max(mantle, -q.y);
	float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
	
	// distance to tip
	if ((q.y > height) && (projected < 0.)) {
		d = max(d, length(tip));
	}
	
	// distance to base ring
	if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
		d = max(d, length(q - vec2(radius, 0)));
	}
	return d;
}

// Function 2964
float map(vec3 p){

    // The height value.
    float c = heightMap(p.xy);
    
    // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).
    // Adding some height to the plane from the texture. Not much else to it.
    return 1. - p.z - c*.1;//texture(texChannel0, p.xy).x*.1;

    
    // Smoothed out.
    //float t =  heightMap(p.xy);
    //return 1. - p.z - smoothstep(0.1, .8, t)*.06 - t*t*.03;
    
}

// Function 2965
vec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {
    return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   
 
}

// Function 2966
SDResult sceneDist(in Ray ray) {
    SDResult result;
    
    // Mess with the ray
    vec2 offset = vec2(
        sin(iTime * 0.34), 
        cos(iTime * 0.55)
    );
    float r = 2.0;
    
    ray.origin.xz += offset;
    R(ray.origin.xz, iTime * 0.34);
    ray.origin = smoothBlend(ray.origin, offset.xyx, r);
    ray.origin.zy += offset;
    R(ray.origin.zy, iTime * 0.55);
    ray.origin = smoothBlend(ray.origin, offset.yxy, r);
    ray.origin.yx += offset;
    R(ray.origin.yx, iTime * 0.55);
    ray.origin = smoothBlend(ray.origin, offset.yyx, r);

    ray.origin.xz -= offset;
    
    Box box = Box(vec3(0), vec3(5), 0.4);
    Box innerBox = Box(vec3(0), vec3(4), 0.4);
    
    // get the distance 
    float distToBox = differenceOpU(
        boxDist(ray, box),
        boxDist(ray, innerBox)
        );
    
    Sphere ball = Sphere(vec3(0), 2.0);
    
    float distToBall = sphereDist(ray, ball);
    
    //Find the neares of the floor and box0
    result.d = unionOp(distToBox, distToBall);
    //result.d = distToHouse;
    result.material = result.d == distToBox ? kGLASSMATERIAL : kMIRRORMATERIAL;
    
    return result;
}

// Function 2967
void sceneMap3D(vec3 pos, out float t, out int objectHit) {
    vec3 center = vec3(-4, 0, 15);
    center.y = max(4.*sin(.2*center.x), -.6);

    t = FLOOR_SDF;
    objectHit = FLOOR_ID;
    float t2;
    
    #if RENDER_GRASS
    if ((t2 = TEST_GRASS_SDF)< t){
        if ((t2 = GRASS2_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
        if ((t2 = GRASS4_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
        if ((t2 = GRASS6_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }    
        if ((t2 = GRASS8_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
        if ((t2 = GRASS10_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
        if ((t2 = GRASS12_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
        if ((t2 = GRASS14_SDF) < t) {
            t = t2;
            objectHit = GRASS_ID;
        }
    }
    #endif
    
    #if RENDER_APPLE
    if ((t2 = TEST_APPLE_SDF) < t) {
        if ((t2 = APPLE_FINAL_SDF) < t) {
            t = t2;
            objectHit = APPLE_BITE_ID;
        }
    }
    if ((t2 = APPLE_STEM_SDF) < t) {
        t = t2;
        objectHit = APPLE_STEM_ID;
    }
    #endif
    
    #if RENDER_BEE
    if ((t2 = TEST_BEE_SDF) < t) {
        if ((t2 = BEE_SDF) < t) {
            t = t2;
            objectHit = BEE_ID;
        }
        if ((t2 = BEE_EYE_SDF) < t) {
            t = t2;
            objectHit = BEE_EYE_ID;
        }
        if ((t2 = BEE_WING1_SDF) < t) {
            t = t2;
            objectHit = BEE_WING_ID;
        }
        if ((t2 = BEE_WING2_SDF) < t) {
            t = t2;
            objectHit = BEE_WING_ID;
        }
        if ((t2 = BEE_STINGER_SDF) < t) {
            t = t2;
            objectHit = BEE_STINGER_ID;
        }
    }
    #endif
    
    #if RENDER_CATERPILLAR_BACK
    if ((t2 = TEST_BACK_SDF) < t) {
        center.x += 8.;
        for (int i = 8; i < 20; i++) {
            center.x += 1.;
            center.y = max(4.*sin(.2*center.x), -.6);
            vec3 scale = vec3(1, 2, 1);
            if (i == 16) 
                scale = vec3(1, 1.8, 1);
            else if (i == 17) 
                scale = vec3(.8, 1.5, 1);
            else if (i == 18)
                scale = vec3(.7, 1, 1);
            else if (i == 19)
                scale = vec3(.6, .8, .8);
            if ((t2 = sdfEllipsoid(pos - (center + offset[i]), scale, inverseRotateZ(float(rotate[i].z)))) < t) {
                t = t2; 
                objectHit = i + 1;
            }
    	}
        if ((t2 = FEET5_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        } 
        if ((t2 = FEET6_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        }
    }
    #endif
    
    #if RENDER_CATERPILLAR_FRONT
    if ((t2 = TEST_FRONT_SDF) < t) {
        center = vec3(-4, 0, 15);
        for (int i = 0; i < 9; i++) {
            center.x += 1.;
            center.y = max(4.*sin(.2*center.x), -.6);
            vec3 scale = vec3(1, 2, 1);
            if (i == 16) 
                scale = vec3(1, 1.8, 1);
            else if (i == 17) 
                scale = vec3(.8, 1.5, 1);
            else if (i == 18)
                scale = vec3(.7, 1, 1);
            else if (i == 19)
                scale = vec3(.6, .8, .8);
            if ((t2 = sdfEllipsoid(pos - (center + offset[i]), scale, inverseRotateZ(float(rotate[i].z)))) < t) {
                t = t2; 
                objectHit = i + 1;
            }
    	}
        if ((t2 = FEET1_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        } 
        if ((t2 = FEET2_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        } 
        if ((t2 = FEET3_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        } 
        if ((t2 = FEET4_SDF) < t) {
            t = t2;
            objectHit = FEET_ID;
        }
    }
    if ((t2 = TEST_HEAD_SDF) < t) {
        if ((t2 = HEAD_SDF) < t) {
            t = t2;
            objectHit = HEAD_ID;
        }
        if ((t2 = LEFT_EYEBALL_SDF) < t) {
            t = t2;
            objectHit = LEFT_EYEBALL_ID;
        }
        if ((t2 = RIGHT_EYEBALL_SDF) < t) {
            t = t2;
            objectHit = RIGHT_EYEBALL_ID;
        }
        if ((t2 = LEFT_EYE_SDF) < t) {
            t = t2;
            objectHit = LEFT_EYE_ID;
        }
        if ((t2 = RIGHT_EYE_SDF) < t) {
            t = t2;
            objectHit = RIGHT_EYE_ID;
        }       
        if ((t2 = LEFT_EAR_SDF) < t) {
            t = t2;
            objectHit = LEFT_EAR_ID;
        }
        if ((t2 = RIGHT_EAR_SDF) < t) {
            t = t2;
            objectHit = RIGHT_EAR_ID;
        }
        if ((t2 = MOUTH_SDF) < t) {
            t = t2;
            objectHit = MOUTH_ID;
        } 
    }
    #endif
}

// Function 2968
float sceneDist(vec3 p) {
    return sceneSDF(p).dist;
}

// Function 2969
vec3 ShowScene (vec2 p)
{
  vec3 col;
  float s;
  col = vec3 (0.1, 0.1, 0.6);
  s = HexVor1 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));
  col = mix (col, vec3 (1., 0., 0.), smoothstep (0.02, 0.05, s) *
     SmoothBump (0.35, 0.65, 0.02, mod (8. * s, 1.)));
  s = HexVor2 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));
  col = mix (col, vec3 (0., 1., 0.), smoothstep (0.02, 0.05, s) *
     SmoothBump (0.4, 0.6, 0.02, mod (8. * s, 1.)));
  return col;
}

// Function 2970
float sdf_ellipse(vec2 uv, vec2 center, vec2 r)
{
    return (length((uv-center)/r) - 1.) / min(r.x, r.y);
}

// Function 2971
vec3 GetSceneColor(vec3 p, float iTime)
{
    vec3 color;
    
    float voronoi_scale = cos(iTime / 6.) * 5. + 2.;
    VoronoiDist(p * voronoi_scale, 0., color);
    
    return color;
}

// Function 2972
float GetDist(vec3 p,out float glowDist,out float dC) {
    float objID;
    return GetDist(p,objID,glowDist,dC);
}

// Function 2973
maybe_float get_distance_along_3d_line_to_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B,
    in float r,
    in float h
){
    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));
    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;
    cone = get_distance_along_line_to_union(end, cone);
    return cone;
}

// Function 2974
float sdfSmoothIntersection( float d1, float d2, float k ) {
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) + k*h*(1.0-h); 
}

// Function 2975
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 vn, col;
  float dstObj, dstWat, nDotS;
  bool watRefl, isBg;
  watRefl = false;
  isBg = true;
  bSizeV = 2. * flSpc;
  dstObj = ObjRay (ro, rd);
  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;
  if (dstWat < min (dstObj, dstFar)) {
    watRefl = true;
    ro += dstWat * rd;
    rd = reflect (rd, WaveNf (ro, dstWat));
    ro += 0.01 * rd;
    dstObj = ObjRay (ro, rd);
  }
  if (dstObj < dstFar) {
    ro += rd * dstObj;
    vn = ObjNf (ro);
    if (idObj == idFlr) {
      col4 = vec4 (0.7, 0.4, 0.2, 0.1);
      if (vn.y > 0.99) col4 *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05,
         mod (0.5 * length (ro.xz) / SZ(1.), 1.));
    } else if (idObj == idStr) {
      col4 = vec4 (0.6, 0.3, 0.2, 0.1);
    } else if (idObj == idRl) {
      col4 = vec4 (0.7, 0.7, 0.9, 0.4);
    } else if (idObj == idStn) {
      col4 = vec4 (0.9, 0.9, 0.1, 0.4);
    } else if (idObj == idCln) {
      col4 = vec4 (0.6, 0.8, 0.6, 0.2);
    }
    nDotS = max (dot (vn, sunDir), 0.);
    if (idObj != idFlr && idObj != idStr) nDotS *= nDotS;
    col = col4.rgb * (0.2 + 0.8 * nDotS) +
       col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
    isBg = false;
  } else if (! watRefl && rd.y < 0.) {
    watRefl = true;
    ro += dstWat * rd;
    rd = reflect (rd, WaveNf (ro, dstWat));
  }
  if (isBg) col = BgCol (ro, rd);
  if (watRefl) col = mix (mix (vec3 (0., 0.15, 0.), vec3 (0., 0.1, 0.1),
     smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.8 * col, 1. - pow (abs (rd.y), 4.));
  return pow (clamp (col, 0., 1.), vec3 (0.8));
}

// Function 2976
float mapV( vec3 p ){ return clamp(-map(p), 0., 1.);}

// Function 2977
SRayHitInfo RayVsScene(in vec3 rayPos, in vec3 rayDir)
{
    SRayHitInfo hitInfo;
    hitInfo.dist = c_rayMaxDist;

    // the floor
    if(RayVsPlane(rayPos, rayDir, hitInfo, vec4(0.0f, 1.0f, 0.0f, 0.0f), vec3(0.2f, 0.2f, 0.2f)))
    {
        // uncomment this for a checkerboard floor
        /*
        vec3 hitPos = rayPos + rayDir * hitInfo.dist;
        vec2 uv = floor(hitPos.xz / 100.0f);
        float shade = mix(0.6f, 0.2f, mod(uv.x + uv.y, 2.0f));
        hitInfo.diffuse = vec3(shade, shade, shade);
		*/
    }
    
    // some floating spheres to cast shadows
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 1.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(-30.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 0.0f, 0.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(0.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 1.0f, 0.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(30.0f, 40.0f, 0.0f, 10.0f), vec3(0.0f, 0.0f, 1.0f));
    RayVsSphere(rayPos, rayDir, hitInfo, vec4(60.0f, 40.0f, 0.0f, 10.0f), vec3(1.0f, 1.0f, 0.0f));
    
    // back wall
    {
        vec3 scale = vec3(100.0f, 40.0f, 1.0f);
        vec3 offset = vec3(0.0f, 0.0f, 10.0f);
        vec3 A = vec3(-1.0f, 0.0f, 0.0f) * scale + offset;
        vec3 B = vec3(-1.0f, 1.0f, 0.0f) * scale + offset;
        vec3 C = vec3( 1.0f, 1.0f, 0.0f) * scale + offset;
        vec3 D = vec3( 1.0f, 0.0f, 0.0f) * scale + offset;
    	RayVsQuad(rayPos, rayDir, hitInfo, A, B, C, D, vec3(1.0f, 0.0f, 1.0f), true);
	}     
    
    return hitInfo;
}

// Function 2978
float map (in vec3 p) {
    return min (metaBalls (p), p.y + 2. * (2. * (1. - iMouse.y / iResolution.y) - 1.) );
}

// Function 2979
vec3 Uncharted2Tonemap(vec3 x)
{
   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 2980
vec2 map (in vec3 p) {
    vec2 v = vec2(1.0 - sdBox(p, vec3(1.0)), 1.0);
    return v;
}

// Function 2981
void initSDF(){
    
    float ang1 = 1.5707963268;
    float ang2 = 0.0;
    
    mat3 rotation1 = mat3(
        1,0,0,
        0,cos(ang1),-sin(ang1),
        0,sin(ang1),cos(ang1)
    );
    mat3 rotation2 = mat3(
        cos(ang2),0,-sin(ang2),
        0,1,0,
        sin(ang2),0,cos(ang2)
    );
    rot=rotation1*rotation2;
}

// Function 2982
vec4 sceneColor(vec3 p)
{
    return minVec4(
        vec4(vec3(1, 1, 1), distPlane(p, planePos)),
        minVec4(
        	vec4(vec3(1, 0, 0), distSphere(p)),
        	vec4(vec3(0, 0, 1), distTorus(p, torusSize))
    	)
     );
}

// Function 2983
SceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )
{
    if ( -a.fDist < b.fDist )
    {
        return a;
    }

    SceneResult result;
    result.fDist = -b.fDist;
    result.fObjectId = b.fObjectId;
    result.vUVW = b.vUVW;
    return result;
}

// Function 2984
float mapEgg( vec3 p)
{
    float eggD = sdSphere(p, 4.0);
    return (eggD+voronoi3D(p)*(0.3+sin(iTime*5.0)*0.1));
}

// Function 2985
float sdf_modern_Q(vec2 uv, float age)
{
    float aspect_ratio = iResolution.x/iResolution.y;
    float noise = turb(uv * vec2(31.7,27.9)/aspect_ratio, .7, 1.83);
    float dist = sdf_disk(uv, vec2(.5, .68), .315);
    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .727), .267));
    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, 1.1), .21));
    dist = sdf_union(dist, sdf_modern_nail(uv, vec2(.5, .59), vec2(.08, .52)));
    return dist + (noise * .01 - .005) * sqr(age);
}

// Function 2986
float sdf_inner(vec3 p){
    const float period=.05;
    float z=p.z+iTime*.1;
    p.z=mod(z,period)-.5*.05;
    if(mod(floor(z/period),10.)==0.) color=vec3(.8,.2,.2)*4.;
    else color=vec3(.2,.8,.2)*1.5;
    return sdf_particle(p);
    
    const float blockiness = ITERS>0 ? .5 : 1.;
    const float gap=pow(2.,float(-ITERS))/(1.-pow(2.,float(-ITERS))+blockiness);
    const float final_piece=2.*(pow(2.,float(-ITERS))-gap*(1.-pow(2.,float(-ITERS)))) + PI*.5*gap;
    //color=vec3(fract(p.z), fract(p.z*2.3), fract(p.z*1.7))*2.;
 	
    //float ang=sin(p.z+iTime*1.3)*sin(iTime*3.);
    float ang=p.z*2.;
    float thickness=pow(max(0.,sin(p.z*3.+iTime*3.)-.95)*20.,.4)*.03+.02;
    //float thickness=step(.93,sin(p.z*3.+iTime*3.))*.03+.02;
    //float thickness=.04;
    p.xy*=mat2(cos(ang),sin(ang),-sin(ang),cos(ang));
    p.xy=abs(p.xy);
    //return length(p.xy)-thickness;
    return max(p.x,p.y)-thickness;
}

// Function 2987
float GetDistanceWaxTop( const in vec3 vPos )
{
	vec2 vProfilePos = vec2( length(vPos.xz), vPos.y );

	float fCurve = 1.0;
	
	return vProfilePos.y - fCandleTop - vProfilePos.x * vProfilePos.x * fCurve;	
}

// Function 2988
vec4 mapClouds( in vec3 p )
{
	float d = 1.0-0.3*abs(2.8 - p.y);
	d -= 1.6 * fbm( p*0.35 );

	d = clamp( d, 0.0, 1.0 );
	
	vec4 res = vec4( d );

	res.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );
	res.xyz *= 0.65;
	
	return res;
}

// Function 2989
vec2 map( in vec3 p )
{
    //p = fract(p); 
   	vec2 d = DE(p);

  

   	return d;
}

// Function 2990
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstGrnd, dstObj, nDotL, sh;
  dstObj = ObjRay (ro, rd);
  dstGrnd = GrndRay (ro, rd);
  if (min (dstObj, dstGrnd) < dstFar) {
    if (dstObj < dstGrnd) {
      ro += dstObj * rd;
      vn = ObjNf (ro);
      col4 = vec4 (HsvToRgb (vec3 (0.9 * Hashfv2 (17.1 * gId), 0.3, 0.9)), 0.1);
      if (idObj == idTube || idObj == idEnd) col4 = col4 * (0.93 + 0.07 * smoothstep (-0.1, 0.,
         cos (32. * atan (qHit.z, - qHit.x))));
      else if (idObj == idEx) col4 *= 0.9;
      else if (idObj == idBk) col4 = (PrEllips2Df (qHit.xzy, vec2 (0.5, 1.)) < -0.01) ?
         vec4 (0.8 + 0.2 * sin (32. * pi * tCur), 0., 0., -1.) : col4 *
         (0.9 + 0.1 * smoothstep (-0.7, -0.6, cos (64. * qHit.y)));
      if (col4.a >= 0.) {
        nDotL = max (dot (vn, sunDir), 0.);
        nDotL *= nDotL;
        sh = ObjSShadow (ro + 0.01 * vn, sunDir);
        col = col4.rgb * (0.2 + 0.8 * sh * nDotL) + col4.a * step (0.95, sh) *
           pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
      } else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));
    } else {
      ro += dstGrnd * rd;
      vn = GrndNf (ro);
      vn = VaryNf (ro, vn, 1.);
      col = mix (vec3 (0.4, 0.4, 0.1), vec3 (0.8, 0.7, 0.7), mod (floor (10. * ro.y / ghMax) / 10., 1.));
      col *= 1. - 0.2 * Fbm2 (64. * ro.xz);
      sh = GrndSShadow (ro + 0.01 * vn, sunDir);
      gId = PixToHex (ro.xz / hgSize);
      if (Maxv3 (abs (vec3 (gId, dot (gId, vec2 (1.))))) <= grLim)
         sh = min (sh, ObjSShadow (ro + 0.01 * vn, sunDir));
      col *= 0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.);
    }
    col = mix (col, SkyBg (rd), pow (min (dstObj, dstGrnd) / dstFar, 4.));
  } else {
    col = SkyCol (ro, rd);
  }
  return clamp (col, 0., 1.);
}

// Function 2991
bool ringMap( const in vec3 ro ) {
    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;
}

// Function 2992
float starSDF( vec3 point, vec3 center, float len, float thickness ) {    
    float b = PI2 / 5.0;
    float angle = b * .25;

    float s1 = conoSDF( point, center, len, thickness, angle + b * 0. );
    float s2 = conoSDF( point, center, len, thickness, angle + b * 1. );
    float s3 = conoSDF( point, center, len, thickness, angle + b * 2. );
    float s4 = conoSDF( point, center, len, thickness, angle + b * 3. );
    float s5 = conoSDF( point, center, len, thickness, angle + b * 4. );
  
    return min( s1, min( s2, min( s3, min( s4, s5 ) ) ) ) ;
}

// Function 2993
float map(vec3 p) {
   return scene(p);
}

// Function 2994
float map(vec3 p)
{
    float s = length(p -vec3(0.0, .01*sin(8.0*T), 0.0)) - 0.5;
	s += 0.005*sin(45.0*p.x+10.0*T);
    
    for (int i=0; i<12; ++i) {
        vec4 rnd = hash41(100.0+float(i));        
        vec3 rndPos = 2.0*(normalize(rnd.xyz) -vec3(0.5));
        rndPos.y *= 0.2;
        float timeOffset = rnd.w;
        float phase = fract(timeOffset -0.25*T);
		vec3 offset = mix( 0.1*rndPos, 15.0*rndPos, phase);
        float rnd2 = fract(rnd.x +rnd.y);
        float s0 = length(p +offset) -0.25*mix(0.8 +0.2*rnd2, 0.2 +0.8*rnd2, phase);
        s = smin(s, s0, 0.4);
    }

    s += 0.002*sin(20.0*p.x +10.0*T);
        
    return s;    
}

// Function 2995
vec4 get_distances( vec2 p, Split4 split )
{
#if 1
	return split.d;
#else
// should be same result
	vec4 d;
	d.x = sd_bounds_range( p, split.b00.pmin, split.b00.pmax );
	d.y = sd_bounds_range( p, split.b01.pmin, split.b01.pmax );
	d.z = sd_bounds_range( p, split.b10.pmin, split.b10.pmax );
	d.w = sd_bounds_range( p, split.b11.pmin, split.b11.pmax );
	return d;
#endif
}

// Function 2996
float ndist(vec3 p, vec3 p1, vec3 p2)
{
    p-=p1;
    p2-=p1;
    return length(p-p2*dot(p,p2)/dot(p2,p2));
}

// Function 2997
float TextSDF(vec2 p, float glyph)
{
    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;
    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);
}

// Function 2998
float sdfApple(vec3 pos)
{
    appleTransform[3] = vec4(-3., -1., 2., 1.); 

    pos = vec3(appleScale * vec4(pos, 1.));
    pos = vec3(appleTransform * vec4(pos, 1.));
    return APPLE_BITE_SDF;
}

// Function 2999
float map(vec3 p){
 
     return 1.-abs(p.y) - (0.5-surfFunc(p))*1.5;
 
}

// Function 3000
float map(vec3 p)
{
    float res = 10000.;
    //Pluto sphere
    vec2 sph_uv = polar(p);
    float thickness =0.01*smoothstep(0.1,0.5, Notes[4].x);
    float wipe_thick = WIPE_THICKNESS * smoothstep(0.9,0.8, abs(p.y));
    float wipe_bump = (1.-sphereWipeClean(Notes[4].x, p.y, wipe_thick))*WIPE_BUMP;
    float water_bump =  texture(iChannel1,sph_uv).z*BUMP_STRENGTH;
    vec3  noise_text = texture(iChannel3,sph_uv).xyz;
    float noise_bump = length(noise_text.x)*0.01;
    float rad = PLUTO_RADIUS+water_bump+noise_bump+wipe_bump;
    float earth = length(p)-rad;
    res = min(res, earth);
    return res*0.7;
}

// Function 3001
float cylinderDist(vec3 center, vec2 dimension, vec3 point)
{
  	vec3 p = point - center;   
  	vec2 d = abs(vec2(length(p.xz), p.y)) - dimension;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 3002
float map(vec3 p)
{
    float d = mix(length(p)-1.1,length4(p)-1.,sdfsw-0.3);
    d = min(d, -(length4(p)-4.));
    return d*.95;
}

// Function 3003
float map( in vec3 pos )
{
    
 	float d1 = length(pos)-0.25;
    
    float d2 = pos.y - ( - 0.25);

    float t = iTime / 5.0;
    vec3 rotation = vec3(sin(t), 0.0, cos(t));
    pos += rotation / 3.0;
    float d3 = length(pos)- 0.05;
    
    return min(min(d1, d3), d2);
}

// Function 3004
float map3(vec3 p){
return udQuad(p,
              vec3(5, 0, 100.0),
              vec3(-5.0, 0, 100.0), 
              vec3(-5.0,   (cos(time*0.5))*0.5f, -100.0),
              vec3(5.0,  (cos(time*0.5))*0.5f, -100.0));
  }

// Function 3005
vec2 map_the_world(in vec3 p)
{
    
	//Plane is represented as a vec4 using ax+by+cz+w = 0 formulation
    float to_ground = sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.3)));
    float to_rock = sdTerrain(p, normalize(vec4(0.0,1.0,0.0,0.3)));
    float to_water = abs(sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.0))));
    if (to_water < to_rock) {//early quit since we expect to be closest to water often
        return vec2(to_water,2.0);
    }
    //Rocks at the bottom of the pond
    float pebble_start = 0.45;//play with this range(0.0,1.0)
    float mat = 0.0;
    float height = texture(iChannel1, p.xz*0.15).x;
    if (height > pebble_start){//using pebbles to decide where pebbles are lol (play with numbers)
        //change mat
        float prop = height-pebble_start;
        //nonlinear interp between ground and rocks to make sure it looks like they touch (rocks dont get cut off) 
        to_ground = mix(to_ground,to_rock,1.0 - (1.0/pow(prop+1.0,8.0)));
    	mat = 1.0;
    }
    
    return vec2(to_ground,mat);
}

// Function 3006
float getSdfWithPlane(vec3 p) {
  return min(getSdf(p), sdPlane(p, vec4(0,1,0,1)));
}

// Function 3007
float mapH(vec3 p) {
    return p.y - fbmH(p.xz);
}

// Function 3008
float sdf_simple(vec3 p)
{
    float d = 50.0;
    
    vec3 lidP = lidAnimation(p);
            
    d = min(d, ribbon(lidP));
    d = min(d, ribbon(rotateY(lidP, .5))); 

    d = min(d, centerRibbon(rotateY(lidP, 1.87)));

    d = min(d, strap(rotateY(lidP, -.3)));
    d = min(d, strap(rotateY(lidP, 1.23)));

    d = min(d, mech(p));
    d = min(d, mechGold(p));
    d = min(d, mechInner(p));

    d = min(d, mainBox(p));
    d = min(d, boxLid(lidP));

    d = min(d, lidStraps(lidP));
    d = min(d, p.y + 5.7);

	return d;
}

// Function 3009
DistMat sceneSDF(vec3 p)
{    
    DistMat scene;

    float ground = planeSDF(p - vec3(3.2), vec3(0.0, 1.0, 0.0));
        
    scene = DistMat(ground, MAT_FLOOR);
    scene = sum(scene, DistMat(hexprismSDF(p.xzy - vec3(0.0, 0.0, 2.4), vec2(0.8)), MAT_PRISM));
    scene = sum(scene, DistMat(boxSDF(p - vec3(2.0, 2.8, 1.5), vec3(0.4)), MAT_PRISM));
    scene = sum(scene, DistMat(ringSDF((p - vec3(-1.2, 3.0, -2.0)).yxz, vec2(0.2, 0.5)), MAT_PRISM));

    return scene;
}

// Function 3010
float SDFCircle( in vec2 coords, in vec3 offsetRadius )
{
    coords -= offsetRadius.xy;
    float v = coords.x * coords.x + coords.y * coords.y - offsetRadius.z;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return abs(v)/length(g); 
}

// Function 3011
void sceneMap3D(vec3 pos, out float t, out int obj)
{
    t = BACK_WALL_SDF;
    float t2;
    obj = BACK_WALL; 
    if((t2 = LEFT_WALL_SDF) < t) {
        t = t2;
        obj = LEFT_WALL; 
    }
    if((t2 = RIGHT_WALL_SDF) < t) {
        t = t2;
        obj = RIGHT_WALL; 
    }
    if((t2 = CEILING_SDF) < t) {
        t = t2;
        obj = CEILING; 
    }
    if((t2 = FLOOR_SDF) < t) {
        t = t2;
        obj = FLOOR; 
    }
    if((t2 = TALL_BOX_SDF) < t) {
        t = t2;
        obj = TALL_BOX; 
    }
    if((t2 = SMALL_BOX_SDF) < t) {
        t = t2;
        obj = SMALL_BOX; 
    }
}

// Function 3012
float MapTerrain( vec3 p)
{
  return   p.y+18.5-mix(
    (textureLod(iChannel0, p.xz*0.001, 0.0).r*1.2) + 
    (textureLod(iChannel0, p.xz*0.01, 0.0).r*.7) + 
    (textureLod(iChannel0, p.xz*0.075, 0.0).r*0.91), 
    0., smoothstep(8.0, 18.0, min(distance(p, vec3(0.0, -17.3, 0.)), distance(p, vec3(10.5, -17.3, 2.))*3.5)));
}

// Function 3013
float GetBoatHullDistance( vec3 vPos )
{
    vec3 vBoatDomain = vPos;
    vBoatDomain.x = abs(vBoatDomain.x);
    
    float boatDist = length( vBoatDomain.xyz - vec3(-3.9,3.2,-0.6)) - 5.5;
    float boatRearDist = length( vBoatDomain.xyz - vec3(0,2,3.9)) - 6.0;

    boatDist = -min( -boatDist, - boatRearDist);
    
    float boatBaseDist = length( vBoatDomain.xyz - vec3(0,4,0)) - 4.4;
    boatDist = -min( -boatDist, - boatBaseDist);
    
    
    return boatDist;
}

// Function 3014
vec3 scene(vec3 o,vec3 d,float s){//origin,direction,scattering
;float g=gd(o)*s*.5
,t=g,ao=1.
,f=2./min(iResolution.x,iResolution.y) //AntiAlias pixel size, of [2] pixels.
;vec4 gs=vec4(1e6),ts=vec4(-1)//buffer 4 "smallest values"
 ;for(int i=0;i<iterRm;i++
 ){//start.raymarch
 ;g=gd(o+d*t)
 ;bool ps=all(lessThan(vec2(g,ts.w),vec2(min(f*t,ao),0)))
       //=(g<min(f*t,ao)&&ts.w<.0);
       //=(g<f*t&&g<ao&&ts.w<.0);
 ;if(ps //PushSmall, we remember 4*2 smallest values for AO.
 ){gs=vec4(abs(g),gs.xyz)
  ;ts=vec4(t,ts.xyz);
 ;}
 ;t+=g
 ;ao=g
 ;if(t>zFar||g<eps)break;//raymarch loop break
 ;}//end__.raymarch loop 
 ;if(g<f*t && g<gs.x){gs.x=g;ts.x=t;}//one last PushSmall
 ;vec3 c=Backdrop(d)
     //;return c;
 ;vec3 fcol=c
 ;for(int i=0;i<4;i++ //some AA supersampling shit in here?
 ){//ts and ps values get processed for "occlusion"
  //oh looks like this is just nearSurface() surface stuff.      
  ;if(ts.x<.0)break
  ;float px=f*ts.x
  ;vec3 so=o+d*ts.x
  ;vec4 mcol=vec4(.0)
  #define g3(a) vec3(gd1(so+a.xyy,mcol),gd1(so+a.yxy,mcol),gd1(so+a.yyx,mcol))
  ;vec3 ve=vec3(px,0,0)
  ;vec3 dp=g3(ve),dn=g3(-ve)//positive normal//negative normal
  #ifndef doNormals 
  ;float d1=gd1(so,mcol)
  ;vec3 N=(dp-dn)/(length(dp-vec3(d1))+length(vec3(d1)-dn))//HNF, normalized surface normal.
  #else
  ;vec3 N=normal(so,eps)*.5+.5
   #endif
  //above begs to be inversesqrt?
  ;vec3 spc=mcol.rgb*0.14//specular set to material
  #ifdef doShade
  ;spc=SpecOcc(spc,d,N,so,o,s,mcol)
  #endif
        //near distance can skip fog.
  #ifdef doFog
  ;spc=fog(ts.x,spc,fcol);
  #else 
  //;spc=fog(ts.x,spc,fcol);
  #endif  
  ;c=mix(spc,c,sat(gs.x/px))
  ;gs=gs.yzwx;ts=ts.yzwx//rotate sampling matrix
 ;}
//;if(c!=c)c=vec3(1,0,0);//if(NaN)
;return sat(c*2.)
;}

// Function 3015
float distanceEstimator(vec3 p)
{
	float t = mod(iTime, 70.0);
	vec3 holeP = p - vec3(0.5, 0.5, -3.0);
	p = p - vec3(t, t * 0.5, t * 0.3);
	
	float rpm = 1.0;
	vec3 repeater = mod(p, vec3(rpm * 1.6, rpm, rpm)) - 0.5 * vec3(rpm * 1.6, rpm, rpm);
	//vec3 repeater = fract(p) - vec3(0.5);
	float sphere = length(repeater) - 0.06 * rpm;
	
	float cylinder = length(repeater.xz) - 0.015 * rpm;
	cylinder =  min(cylinder, length(repeater.zy) - 0.015 * rpm);
	cylinder =  min(cylinder, length(repeater.xy) - 0.015 * rpm);
	
	float grid = min(cylinder, sphere);
	
	// just a big sphere, everything outside the sphere is not shown
	float eater  = length(holeP) - 3.3;
	return max(grid, eater);
	
}

// Function 3016
float getDistance(ivec3 chunkPath, vec3 localStart, vec3 localPosition) {
    return length(vec3(chunkPath) + localPosition - localStart);
}

// Function 3017
float sdfInter(float d0, float d1)
{
    return max(d0, d1);
}

// Function 3018
vec3 scene_surface_color( vec3 r, mat2x3 Kr, float t, vec3 V, vec2 uv, bool submerged,
                          inout vec3 albedo, inout vec3 N )
{
    float Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );
    vec4 tsample = ts_sample_fine( g_ts, iChannel1, g_data, r, Krwidth );
    vec2 tshadow = ts_shadow_sample_ao( g_ts, iChannel1, r );
    N = normalize( tsample.xyz );
    vec3 Z = normalize( r );
    float h = tsample.w;
    float pshadow = atm_planet_shadow( dot( g_env.L, Z ), sqrt( max( 0., 1. - g_env.radius * g_env.radius / dot( r, r ) ) ) );
    vec4 sky = atm_skylight_sample( g_ts, iChannel2, r );
    vec3 TL = atm_transmittance( Z * max( g_data.radius, length( r ) ), g_env.L, g_atm, true );
    vec3 F = g_env.sunlight * TL * sky.w * pshadow;
    float slope = length( N / dot( N, Z ) - Z );
    albedo = scene_surface_albedo( r, Kr, h, slope, Z.z, h >= 0. || submerged );
    float d = submerged ?
        max( 0.001, -.25 * h ) :
        max( max( 0.001, 125. * h * h ), 4. * t * sqrt( g_pixelscale ) );
    vec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );
    vec3 L = g_env.L;
    if( submerged )
    {
        F = F * M.w;
        F = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );
        L = normalize( -simple_refract( -L, Z ) );
    }
    float oshadow = scene_raycast_object_shadows( Ray( r, L ) );
    vec3 col = ZERO;
    if( h < 0. && !submerged )
    {
        // water surface
        vec3 To = exp2pp( 1000. * h * g_ocn_beta50 );
        vec4 rsample = atm_reflection_sample( iChannel2, uv );
        vec3 albedo = mix( g_ocn_omega, To * albedo, To );
        F = F * M.w;
        F = F * mix( ONE, vec3( tshadow.x * oshadow ), To );
        const float cld_g = 0.85;
        const float cld_f = cld_g * cld_g;
        float extra_T = pow( sky.w, inversesqrt( 1. - cld_f ) - 1. );
        float a = sqrt( ( .0003 * inversesqrt( g_pixelscale ) + t ) / t ) * 0.8 / g_data.ocn_s2;
        vec3 M = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );
        col = scene_lighting_ocean( albedo, Z, N, M.xyz, g_env.L, V, F, a, sky.xyz, rsample, extra_T );
    }
    else
        if( t < SCN_ZFAR )
        {
            // land surface
            col = scene_lighting_terrain( albedo, N, L, V, Z, F * oshadow, sky.xyz, tshadow );
        }
    return col;
}

// Function 3019
float map(vec3 p) {
    float d = 1000.0, s = 2.0;
    mat3 r = rotationXY(vec2(0.1, PI2 * 0.618034));
    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);
    for (int i = 0; i < 21; i++) {
        d = opU(d, sdPetal(p, s));
        p = r * p;
        p += vec3(0.0, -0.02, 0.0);
        s *= 1.05;
    }
    return d;
}

// Function 3020
float sdf_quarter1_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, max(-pos.y, -pos.x));
}

// Function 3021
vec2 distance_to_obj(in vec3 p)
{
  return obj_union(obj_floor(p), obj_union(obj_torus(p), op_sub(obj_round_box(p), obj_sphere(p))));
}

// Function 3022
vec4 map( in vec3 p )
{
	float d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;

    vec3 q = p;
    float f;
    
    f  = 0.5000*noise( q ); q = q*2.02;
    f += 0.2500*noise( q ); q = q*2.03;
    f += 0.1250*noise( q ); q = q*2.01;
    f += 0.0625*noise( q );
    d += 2.75 * f;

    d = clamp( d, 0.0, 1.0 );
    
    vec4 res = vec4( d );
    
    vec3 col = 1.15 * vec3(1.0,0.95,0.8);
    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);
    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );
    
    return res;
}

// Function 3023
vec2 SDF(vec3 pos)
{
    vec2 floorVal = vec2(pos.y + 0.5, 0.0); // ground plane
    
    // Bend space to mirror-tile the arches on both x and z
    pos.x = abs(mod(pos.x, 2.0) - 1.0);
    pos.z = abs(mod(pos.z, 4.0) - 2.0);
    
    
    float ceilValue = 4.5 - pos.y;
    ceilValue = min(ceilValue, sdBox(pos - vec3(0.0, 4.3, 0.0), vec3(0.2, 0.2, 4.0)));
    vec2 ceilVal = vec2(ceilValue, 1.0); // Ceiling and beams with label 1.0
    
    
    vec2 dist = combine(floorVal, ceilVal);
    
    vec2 arch1 = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.3),vec3(1.0, 3.0, 0.3), 1.15), 3.0);
    arch1 = combine(arch1, vec2(sdBox(pos - vec3(0.0, 5.0, 0.0), vec3(2.0, 1.4, 0.23)), 3.5));
    vec2 arch1Neg = vec2(sdCylinder(pos, vec3(1.0, 3.0, -0.4),vec3(1.0, 3.0, 0.4), 0.78), 3.0);
    arch1 = subtract(subtract(arch1, arch1Neg), vec2(pos.y - 3.0, 3.0));

    
    float colDist = length(pos.xz) - 0.15;
    float pillarBox  = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.16, 1.2, 0.3));
    float pillarBox2 = sdBox(pos - vec3(0.0, 1.85, 0.0), vec3(0.22, 1.2, 0.2));
    float cone = sdCone(pos - vec3(0.0, 1.2, 0.0), normalize(vec2(2.0, -1.0)));
    
	pillarBox = min(pillarBox, pillarBox2);    
    pillarBox = max(pillarBox, cone);
    pillarBox = min(pillarBox, colDist);

    vec2 pillar = vec2(pillarBox, 4.0);


    
    arch1 = combine(pillar, arch1);
    
    
    float arch2 = sdCylinder(pos, vec3(1.0, 1.8, -0.15),vec3(1.0, 1.8, 0.15), 1.13);
    float arch2Neg = sdCylinder(pos, vec3(1.0, 1.8, -0.6),vec3(1.0, 1.8, 0.6), 0.8);
    
    arch2 = subtract(subtract(arch2, arch2Neg), pos.y - 2.0);
    
    vec2 arch2Value = vec2(arch2, 5.0);
    
    dist = combine(dist, arch1);
    dist = combine(dist, arch2Value);
    
    
     
    
	return dist;// + Noise(pos * 3.0) * 0.0003 // a bit of noise make refections an highlights richer
}

// Function 3024
vec3 RomBinDaHouseToneMapping(vec3 color)
{
    color = exp( -1.0 / ( 2.72*color + 0.15 ) );
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 3025
vec2 map (vec3 p)
{
    float dt = .0;
    float dp = .0;
	vec3 w = vec3 (.0);
	vec2 d1 = vec2 (.0);
	mat3 m = rotY (20. * iTime) * rotZ (-20. * iTime);

    // floor
    vec2 d2 = vec2 (plane (p), 2.);

    // yellow warping gyroid
    w = -m * (p + vec3 (.0, -1.5, .0));
    opBend (w, 7. * cos (iTime));
    d1.y = 3.;
    float thickness = .075;
    float cubeSize = 6.;
    float surfaceSide = dot (sin (w), cos (w.yzx));
    d1.x = abs (surfaceSide) - thickness;
    vec3 a = abs (w);
    d1.x = max (d1.x, max(a.x, max (a.y, a.z)) - cubeSize);

    // only the nearest survives :)
    if (d2.x < d1.x) {
        d1 = d2;
    }

	return d1;
}

// Function 3026
float remap( float t, float a, float b ) {
	return sat( (t - a) / (b - a) );
}

// Function 3027
float allMushroomsSDF(in vec3 iPoint) {
    
    float d = mushroomSDF(iPoint, vec2(-0.5, -3.0), 0.6, 2.0, 4.0, 0.1);
    d = min(d, mushroomSDF(iPoint, vec2(-8.0, 3.0), 1.1, 1.8, 4.0, -0.2));   
    d = min(d, mushroomSDF(iPoint, vec2(4.0, 1.0), 1.0, 1.6, 3.0, 0.3));
    d = min(d, mushroomSDF(iPoint, vec2(-7.5, -7.0), 0.5, 1.0, 2.0, 0.1));
	d = min(d, mushroomSDF(iPoint, vec2(-2.5, -9.0), 0.25, 1.0, 0.8, -0.15));
    return d;
    
}

// Function 3028
float map(vec3 p )
{
	vec3 q = p - vec3(0,.1,1)*iTime;
	float f = 0., s=.5;
    for (int i=0; i< 5; i++ , s/= 2. )
        f += s* noise( q ), q *= 2.;

	return clamp(1.+ .5*p.y +3.*f, 0., 1. ); // why not just max(0.,) ?
}

// Function 3029
IntersectionData CheckSceneForIntersection(in vec3 p)
{
    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);  
    IntersectionData cubeIntersectionData = IntersectionData(sdfBox(p + BoxCenter, BoxSize), CUBE);

    return GetClosestIntersection(planeIntersectionData, cubeIntersectionData);
}

// Function 3030
float dstScene(vec3 p) {
 
    vec3 q = mod(p, 9.) - 4.5;
    q.xy = rot2D(q.xy, (iTime*.1+p.x)*45.);
    
    vec2 uv = mod(asin(normalize(q).xy) / 3.14159 + .5, 1.);
    float d = texture(iChannel1, uv*1.).x * .1 * sin(p.x*4.)*2.;
    return length(q)-1.-d;
    
}

// Function 3031
float map(vec3 p) {
  
  float t1=sin(length(p.xz)*0.009);
  float s=12.0;
  for(int i=0; i<6; ++i) {
    p.xz=abs(p.xz)-s;
    p.xz *= rot(0.55+t1+float(i)*0.34);
    s /= 0.85;
  }
  p.x+=3.0;
  
  return min(village(p), -p.y);
}

// Function 3032
vec2 fScene(vec3 p) {
    
    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;
    
 	vec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); 	
    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);
	vec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);
    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);
    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);
	


    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);
    
    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);
}

// Function 3033
vec4 toneMap(vec4 inputColor, vec3 gamma, vec3 exposure)
{
    vec3 gradedColor = vec3(pow(inputColor.r,gamma.r)*exposure.r,pow(inputColor.g,gamma.g)*exposure.g,pow(inputColor.b,gamma.b)*exposure.b);
    vec4 graded = vec4(1.0-1.0/(gradedColor + vec3(1.0)), inputColor.w);
    
    vec3 x = clamp(graded.xyz,0.0001,0.999);
    
    // ACES tone mapping approximation from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return vec4(clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0001,0.999), inputColor.z);
}

// Function 3034
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 vc;
  vec3 col, vn;
  float dstBld, dstFlyer, c, hw;
  HexVorInit ();
  vorScl = 0.3;
  hBase = 5.;
  dstBld = BldRay (ro, rd);
  dstFlyer = FlyerRay (ro, rd);
  if (min (dstFlyer, dstBld) < dstFar) {
    if (dstFlyer < dstBld) {
      ro += dstFlyer * rd;
      col = (idObj == 1) ? vec3 (1., 0., 0.) : ((idObj == 2) ? vec3 (0., 1., 0.) :
         vec3 (0., 0., 1.));
      col = mix (col, vec3 (1., 1., 0.), smoothstep (0.02, 0.03,
         abs (abs (qHit.x - 0.3) - 0.05)) * (1. - smoothstep (0.95, 0.97, qHit.z)));
      vn = FlyerNf (ro);
      col = col * (0.3 + 0.1 * max (- dot (vn, sunDir), 0.) +
         0.7 * max (dot (vn, sunDir), 0.)) +
         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
    } else {
      ro += dstBld * rd;
      vc = HexVor (vorScl * ro.xz);
      vn = BldNf (ro);
      hw = mod (ro.y + 0.5, 1.) - 0.5;
      if (abs (hw) < 0.18 && vn.y < 0.01) col = 0.7 * SkyCol (ro, reflect (rd, vn));
      else {
        c = 0.1 * floor (73. * mod (vc.w, 1.) + 0.5);
        col = HsvToRgb (vec3 (0.1 + 0.8 * c, 0.3 + 0.5 * mod (25. * c, 1.), 1.));
        if (ro.y > 0.1 - hBase) col *= (0.5 + 0.3 * mod (37. * c, 1.)) *
           ((vn.y > 0.99) ? 1.2 : (1. - 0.5 * step (abs (hw), 0.25) * sign (hw)));
        else col = mix (col, vec3 (1.) * (0.1 +
           0.9 * step (abs (vc.x - 0.04), 0.02)), step (vc.x, 0.4));
        col = col * (0.2 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) +
           0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
      }
      col *= 1. + 0.6 * min (ro.y / hBase, 0.);
      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.4, 0.95, dstBld / dstFar));
    }
  } else col = SkyCol (ro, rd);
  return clamp (col, 0., 1.);
}

// Function 3035
float sdfPlane(in vec3 p, in vec4 normal)
{
  	// n must be normalized
	return dot(p, normal.xyz) + normal.w;
}

// Function 3036
float map(vec3 p)
{
    vec3 q = p;

   // pMod3(q, vec3(0.75, 1., 0.8));
    pMod3(q, vec3(1., cos(iTime), 0.));
    
    
    pMod1(p.x, 1.);
    
    float s1 = sphere(p, 0.75); 
    float s2 = sphere(q, 0.5);
    float s3 = sphere(q, 0.7);
    
    float disp = 0.5 * (abs(cos(p.x*10.)) *
                       abs(cos(p.y*10.)) *
                       abs(cos(p.z*10.)) );
    	//s1 += disp;
    	s1 *= disp;
    	
    
    
  	float df1 = min(s1, s2); // Union
    float df2 = max(s1, s2); // Intersection
    float df3 = max(s1, -s3); // Difference
    
    return df3;
}

// Function 3037
vec4 scene(vec2 x)
{
    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));
    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));
    return sdf;
}

// Function 3038
float sdfSub(float d0, float d1)
{
    return max(d0, -d1);
}

// Function 3039
Hit map(Ray r)
{
    const float maxStep = 500.0;
	Hit hit;
    hit.iter = 0.0;
    hit.p = vec3(0.0);
    hit.nrm = vec3(0.0);
    hit.light = 0.0;
    hit.failed = true;
    float d = 0.0;
    Res res;
    for(float i = 0.0; i < maxStep; i++)
    {
        vec3 p = r.o + r.d * d;
        vec3 ll =(mod(p + 3.0, 4.0) - 3.0);
        float sD = length(ll);
        if(sD <= 0.0)
            return hit;
        vec3 sn = normalize(ll);
        sD -= lightSize;
		if(sD < 0.0)
        {
            hit.iter = i / maxStep;
            hit.p = p - r.d*d;
            hit.nrm = sn;
            hit.light = 1.0;
            hit.failed = true;
            return hit;
        }
        res = fr(p);
        if(res.val.x < minStep)
        {
            hit.iter = i / maxStep;
            hit.nrm = nrm(p);
            hit.p = p + hit.nrm * 0.01;
            hit.failed = false;
            return hit;

        }
       	d += abs(min(res.val.x, sD / abs(dot(r.d, sn))));// * (1.0 + (i / maxStep) * 5.0);
    }
    return hit; 
}

// Function 3040
float vehicle_sdf2(in vec3 loc) {
    float ball1 = length(loc - vec3(0.0, -1.8, 0.0)) - 2.0;
    float ball2 = length(loc - vec3(0.0, 2.0, 0.0)) - 2.1;
    float disc = s_max(ball1, ball2, 0.05);
    float ball3 = length(loc - vec3(0.0, 0.07, 0.0)) - 0.2;
    float result = s_min(disc, max(ball3, -loc.y), 0.1);
    float mult = texture(iChannel1, loc).r;
#if CRINKLY_SHIP    
    mult = 1.0 + 0.95 * mult;
#else
    mult = 1.0 + 0.95 * mult * smoothstep(0.025, 0.05, result);    
#endif
    return result * mult;
}

// Function 3041
float map(in vec3 pos) {
    float d = box(pos, vec3(1.0));
    for (float x = -1.0; x <= 1.0; x += 2.0) {
    	for (float y = -1.0; y <= 1.0; y += 2.0) {
    		for (float z = -1.0; z <= 1.0; z += 2.0) {
        		d = opU(d, sphere(pos + vec3(x, y, z), 0.5));
    		}   
    	}
    }
    vec2 arms = vec2(2.0, 0.25);
    d = opS(d, box(pos, arms.xyy));
    d = opS(d, box(pos, arms.yxy));
    d = opS(d, box(pos, arms.yyx));
    
    return d;
}

// Function 3042
vec3 colourScene(vec3 ro, vec3 rd, Scene scene) {
 
    vec3 pc = vec3(0.0);
    
    vec3 rp = ro + rd * scene.t;
    vec3 ld = normalize(lp - rp);
    float lt = length(lp - rp);
    float diff = max(dot(ld, scene.n), 0.03);
    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 16.0);
    float atten = 1.0 / (1.0 + lt * lt * 0.008);
    float sh = 1.0; 
    
    //scene colour
    vec3 sc = vec3(0.05, 0.0, 0.3) * 0.1 * clamp(scene.n.y * -1.0, 0.0, 1.0);
    sc += vec3(0.0, 0.5, 0.0) * diff; 
    sc += vec3(1.0) * spec;
    sc *= atten;
    
    //projection colour
    vec3 prc = vec3(0.0);
    
    if (scene.id == FLOOR) {
        
        sh = sphSoftShadow(rp - (rd * EPS), ld, sphere, 2.0);
        
        prc += floorProjectionColour(rp, vec3(0.0, 1.0, 0.0));

    } else if (scene.id == SPHERE) {
                        
        prc += sphereProjectionColour(rp, vec3(0.0, 1.0, 0.0));
        //back face
        vec3 bfrp = ro + rd * scene.bft;
        prc += sphereProjectionColour(bfrp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene) * 0.8;

        //see through to floor
        vec3 fpc = vec3(0.0);
        float ft = planeIntersection(ro, rd, fn, fo);
        if (ft > 0.0) {
            vec3 frp = ro + rd * ft;
            fpc = floorProjectionColour(frp, vec3(0.0, 1.0, 0.0)) * (1.0 - displayScene);
        }  
        //TODO: this is a bit crap
        prc += fpc;
    }
    
    sc *= sh;
    pc += sc * displayScene;
    
    prc *= atten;
    pc += prc * displayProjection;
    
    return pc;
}

// Function 3043
SDObject SDOMap(in SDObject o,vec3 p)
{
    // o.ray=ray;
    // o.ray.ro+=o.pos;
    //o.d=iSphere(o.ray.ro,o.ray.rd);
    SDPrim d=o.def;

    o.mpos=p;
    vec3 rp=p;
    transform(rp,d);
    o.def.utp=rp;


    if(d.type==1) o.d=sdPlane(rp);
    if(d.type==2) o.d=sdSphere(rp,1.);
    if(d.type==3) o.d=udBox(rp,d.siz);

    o.d*=d.sca;
    return o;
}

// Function 3044
float map(vec3 coord) {
    // Make there be a "ground" and "sky" by there being less rocks
    // when you go higher.
    
    vec3 tex_coord = coord * vec3(0.3, 1.0, 0.3) * 0.2;
    
    float rocks = 0.5 + coord.y * 0.0 - sample_tex(tex_coord);
    return rocks;
}

// Function 3045
void Scene_Clear()
{
    g_scene.vLightDir = normalize( vec3(0, 1, -0.3) );
    g_scene.vLightColor = vec3(1, 1, 1);
    g_scene.vAmbientLight = vec3(0.4);
    
    g_scene.bCharacter = false;
    g_scene.bArmor = false;
        
    g_scene.fCameraRotation = 0.0;
    
	
    Weapon_None();
    
    Pose_Clear( g_scene.pose );
    
    CharDef_Default( g_scene.charDef );
}

// Function 3046
vec1 nmapu(vec1 x){ return x*.5+.5; }

// Function 3047
float circleSDF(vec2 S, vec2 C,float r, float smoothness)
{
    // Sample coordinates relative to circle center.
    float _x = S.x - C.x; float _y = S.y - C.y;
    
    // Signed distance.
    float sd = sqrt(_x * _x + _y *_y) - r;
     
    // Smoothstep interpolation.
    return smoothstep(-smoothness, smoothness, sd);
    //return smoothstep(-smoothness, smoothness, sd * sd); // outline
}

// Function 3048
void PrepareTonemapParams(vec2 p1, vec2 p2, vec2 p3, out TonemapParams tc)
{
	float denom = p2.x - p1.x;
	denom = abs(denom) > 1e-5 ? denom : 1e-5;
	float slope = (p2.y - p1.y) / denom;

	{
		tc.mMid.x = slope;
		tc.mMid.y = p1.y - slope * p1.x;
	}

	{
		float denom = p1.y - slope * p1.x;
		denom = abs(denom) > 1e-5 ? denom : 1e-5;
		tc.mToe.x = slope * p1.x * p1.x * p1.y * p1.y / (denom * denom);
		tc.mToe.y = slope * p1.x * p1.x / denom;
		tc.mToe.z = p1.y * p1.y / denom;
	}

	{
		float denom = slope * (p2.x - p3.x) - p2.y + p3.y;
		denom = abs(denom) > 1e-5 ? denom : 1e-5;
		tc.mShoulder.x = slope * pow(p2.x - p3.x, 2.0) * pow(p2.y - p3.y, 2.0) / (denom * denom);
		tc.mShoulder.y = (slope * p2.x * (p3.x - p2.x) + p3.x * (p2.y - p3.y) ) / denom;
		tc.mShoulder.z = (-p2.y * p2.y + p3.y * (slope * (p2.x - p3.x) + p2.y) ) / denom;
	}

    tc.mBx = vec2(p1.x, p2.x);
	tc.mBy = vec2(p1.y, p2.y);
}

// Function 3049
float map(vec3 p) {
    vec2 q = vec2(p.y+0.02,quadtruchet(p.xz)+0.02);
    q.y = -(length(max(q,vec2(0.0)))+min(max(q.x,q.y),0.0)-0.06);
    q.x = -p.y-0.05;
    return -(length(max(q,vec2(0.0)))+min(max(q.x,q.y),0.0)-0.04);
}

// Function 3050
float map(vec3 p )
{

    R(p.zy, time * .05); R(p.xy, time * .15);
 
    float t = tau;

    // start animation / scale, swirl
    if (iMouse.z > 0.) 
    {

        t = -mod(time, -tau) + 2.0;
        
        R(p.xy, pi + time * .25);

        // make a spiral    
        if (t > 0. && sin(time * .5) > 0.)
            R(p.xz, p.y - 0.001 * pi + time);
    }

    #define wave(p, d, f, s) float(exp(1.0 - sin(length(cross(d, p)) / length(d) * f + s)))
    
    float f6 = 0.0;
    f6 = wave(p * 1.42, p.yxz, 2.01, t);

    float final = 0.0;
    final = (pi * log(f6) / log(2. * tau));
    
    /* // cross-capped disk
    f6 = wave(p , p-vec3(.1), 2., t);
    final = f6;
	*/
    
    //fake translucent https://www.shadertoy.com/view/XtGyzD
    float sp = length(p) - (t * 0.5);
    float edge = 0.0051; //will help with aa by discard edges
    final = -(0.001 - sqrt(edge+max(sp + final, -sp - final)));

    float thickness = 1.5;
    return pow(final, 2./thickness);
}

// Function 3051
vec3 sceneGrad(vec3 p)
{
   float d = scene(p);
   return (vec3(scene(p + EPS.xyy), scene(p + EPS.yxy), scene(p + EPS.yyx)) - vec3(d)) / EPS.x;
}

// Function 3052
vec4 SDF( vec3 p )
{
    p = ReflectSpace(p);
    
    // wrap space into a grid, and take the grid cell index as a hash
    p.xz = p.xz/cellSize.xz+.5;
    
    ivec2 gridCoord = ivec2(floor(p.xz));
    uvec2 gridCoordHash = uvec2(gridCoord) + 1u;
    p.xz = (fract(p.xz)-.5)*cellSize.xz;
    
    vec4 rand = hash4(coord2(gridCoordHash));
    
    // adjust building height randomly and radially
    float h = mix( .1, 1., clamp( 1.2*pow(rand.w/(dot(vec2(gridCoord),vec2(gridCoord))*.004+1.),4.), 0., 1. ) );
    
	// octahedral, but with random distances so some planes won't be seen
    float a = Polygon( p.zy-vec2(0,3.5*h-3.5), 0., uvec3( gridCoordHash, 1u ) );
    float b = Polygon( p.zy-vec2(0,4.5*h-2.5), .5, uvec3( gridCoordHash, 2u ) );
    float c = Polygon( p.zy-vec2(0,5.5*h-1.5), 1., uvec3( gridCoordHash, 3u ) );

/*    vec3 f = vec3(a,min(a,b),min(min(a,b),c));
    f = max( f, vec3(abs(p.x)-.2) );
    return min( f.z, p.y+.5 ); // ground*/
    
    float w = abs(p.x);

    float ground = p.y+.5;
    
    float A = BevelMax(a,w-max(.02,rand.x),.1);
    float B = BevelMax(b,w-max(.02,rand.y),.03);
    float C = BevelMax(c,w-max(.02,rand.z),.1);
    
    float f = min(min(min(A,B),C),ground);
    
    // bounds - make sure we don't need to sample adjacent grid cells to get a valid SDF value
    float bounds = max( .5 + p.y*.01, p.y-7. ); // n.b. don't let it be flat - it breaks the normals
    f = min(f,bounds);
    
    float windowMask = min(min(max(a,w-rand.x+.2),max(max(max(b+.2,-abs(a-.05)+.15),-abs(c-.05)+.1),w-rand.y)),max(c,w-rand.z+.2));

    // indent windows - doesn't work, flat spaces inside the window regions of the SDF
    //f = max(f,-windowMask);//min(-windowMask,f+.01));
    
    return vec4(
        f,
        // mask for windows
        windowMask,
        // mask for stripes
        max(min(a,c),-b)+.1,
        0.);
}

// Function 3053
vec2 map(vec3 pos, bool inside)
{
    float bottle = map_bottle(pos);
    float cognac = map_cognac(pos);
    float glass = map_glass(pos);
    float plug = map_plug(pos);
    vec2 res = opU(vec2(bottle, BOTTLE_OBJ), vec2(cognac, COGNAC_OBJ));
    res = opU(res, vec2(glass, GLASS_OBJ));
    res = opU(res, vec2(plug, PLUG_OBJ));
    if (inside)
        res.x = -res.x; 
    
    float table = map_table(pos);
    float plate = map_plate(pos);
    float label = map_label(pos);
    float neck = map_neck(pos);

    res = opU(res, vec2(table, TABLE_OBJ));
    res = opU(res, vec2(plate, PLATE_OBJ));
    res = opU(res, vec2(label, LABEL_OBJ));
    res = opU(res, vec2(neck, NECK_OBJ));

    return res;
}

// Function 3054
vec3 Uncharted2Tonemap(vec3 x)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 3055
hit sdScene(in ray r, in float md) {
    hit h = nullHit;
	sdf d = nullSdf;
	vec3 l = r.o;
	float t = 0.;
	for (int i = 0; i < 128; ++i) {
		d = sdSmp(l);
		t += d.d;
		if (t > md) break;
		l += r.d * d.d;
		if (d.d < eps * float(i))
            return hit(l, sdNorm(l), seg(vec2(t, t+eps), ivec2(d.o, -d.o)), d.o, d.m);
	}
	return h;
}

// Function 3056
float shapeDistance(vec2 uv, float time)
{
    float A = 60.;
    float B = 0.9*patternRepeat;
    float C = 1.;
    float D = 450.;
    return A*cos( ( length(uv)/B + time/C)*TWOPI ) + D;
}

// Function 3057
void MapFloor(in vec3 world_pos, out Obj obj)
{
	float dist = 150.0-abs(world_pos.y - 150.0);
	if (dist <= EPSILON)
	{
		obj.m_obj_idx = 0;
	}
	
	obj.m_dist = dist;
}

// Function 3058
void RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )
{
    float stepScale = 1.0;
#ifdef ENABLE_CONE_STEPPING
    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );
    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); // represents the biggest gradient in our heightfield
    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );

    float fRdotG = dot( vRayProfile, vGradPerp );
    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );

    stepScale = -fOdotG / fRdotG;

    if ( stepScale < 0.0 )
    {
        intersection.m_objId = OBJ_ID_SKY;
        intersection.m_dist = k_fFarClip;
        return;
    }
#endif
    
    intersection.m_dist = 0.01;
    intersection.m_objId = OBJ_ID_SKY;
    
    float fSceneDist = 0.0;
    
    float oldT = 0.01;
    for( int iter = 0; iter < k_raymarchSteps; iter++ )
    {
        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;
      
        // into sky - early out
        if ( vRayDir.y > 0.0 )
        {
            if( vPos.y > 1.0 )
            {
                intersection.m_objId = OBJ_ID_SKY;
                intersection.m_dist = k_fFarClip;
                break;
            }
        }

      
        fSceneDist = GetSceneDistance( vPos );

        oldT = intersection.m_dist;
        intersection.m_dist += fSceneDist * stepScale;
                
        intersection.m_objId = OBJ_ID_GROUND;
        if ( fSceneDist <= 0.01 )
        {
            break;
        }

        if ( intersection.m_dist > k_fFarClip )
        {
            intersection.m_objId = OBJ_ID_SKY;
            intersection.m_dist = k_fFarClip;
            break;
        }        

        
    }    
    
    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;
}

// Function 3059
float map(vec3 p)
{
float d,m;
ot = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*0.8;
d = sdPlane(p);

if (ef==0)		   m = Boxes(p); 
if (ef==1||ef==3)  m = menger(rotYaxis(p,0.12*iTime));
if (ef==2)		   m = Singlebox(p+0.1*kl*rand1(gl_FragCoord.xy+iTime));
if (ef==4)		   m = min(menger(rotYaxis(p,0.1*iTime)),sdBox(rotYaxis(rotXaxis(p+vec3(0.,0.2,0.),iTime),0.2*iTime),vec3(0.1,0.1,0.04)-0.002*sin(p.x*p.y*440.+iTime))-0.01);
return min (m, d); 
}

// Function 3060
vec3 bumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf, float id){
   
    const vec2 e = vec2(0.001, 0);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n, id), tex3D(tx, p - e.yxy, n, id), tex3D(tx, p - e.yyx, n, id));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n, id), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
    
}

// Function 3061
float Scene( vec3 p, mat3 localToWorld )
{
    p = p * localToWorld;
    
    // ring
    float a = Cylinder( p, 1.0, 0.1 );
    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); 
    float ring = Substract( a, b );
    
    // nail
    float c = Box( p + vec3( -0.8, 0.0, -0.18 ), vec3( 0.4, 0.1, 0.1 ) );
    float d = Box( p + vec3( -0.4, 0.0, -0.18 ), vec3( 0.02, 0.1, 0.25 ) );
    float e = TriPrism( p + vec3( -1.274, 0.0, -0.18 ), vec3( 0.149, 0.1, 0.16 ) );
    float nail = Union( UnionRound( c, d, 0.1 ), e );
    
    // nail2
    float c2 = Box( p + vec3( -0.8, 0.0, 0.18 ), vec3( 0.4, 0.1, 0.1 ) );
    float d2 = Box( p + vec3( -0.4, 0.0, 0.18 ), vec3( 0.02, 0.1, 0.25 ) );
    float e2 = TriPrism( p + vec3( -1.274, 0.0, 0.18 ), vec3( 0.149, 0.1, 0.16 ) );
    float nail2 = Union( UnionRound( c2, d2, 0.1 ), e2 );
    
    // dents
    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );
    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );
    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );
    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );
    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );
    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );
    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );

    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );
    ring = SubstractRound( ring, dents, 0.03 );
    
    float ret = Union(Union( ring, nail ), nail2);
	return ret;
}

// Function 3062
vec2 get_lightmap_offset(int plane_index)
{
	const int NUM_BITS = 9, MASK = (1 << NUM_BITS) - 1;
	int packed_offset = LIGHTMAP_OFFSETS.data[plane_index];
    return (packed_offset >= 0) ?
        LIGHTMAP_OFFSET + vec2(packed_offset & MASK, packed_offset >> NUM_BITS) :
        LIGHTMAP_OFFSET + vec2(-1);
}

// Function 3063
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn;
  float dstObj, sh;
  sRot = sin (0.03 * tCur + vec2 (0.5 * pi, 0.));
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    sh = ObjSShadow (ro, ltDir);
    col = vec3 (0.2, 1., 0.3) * (0.4 + 0.6 * smoothstep (1., 1.02, length (ro)));
    col = col * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (ltDir.xz, 0.).xzy)), 0.) +
       0.8 * sh * max (dot (vn, ltDir), 0.)) +
       0.2 * smoothstep (0.8, 0.9, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
  } else {
    col = mix (vec3 (1., 1., 0.5), vec3 (0., 0., 0.3 * (0.7 + 0.3 * rd.y)),
       smoothstep (0.0035, 0.004, SphFib (rd, 8192.)));
  }
  return clamp (col, 0., 1.);
}

// Function 3064
float map(vec3 p){
    p=mod(p,8.)-4.;
    return length(p) - 2.;
}

// Function 3065
float GetDist(vec3 p){ //p is the sample point
    float t = iTime;
    float t1 = t* 0.9;
    float t2 = t* 0.08;
    float y = -fract(t1)*(fract(t1)-1.);
    y *= 3.;
    float planeDist = p.y;
    
    for(int i = 1; i < 9;i++){
        float j = float(i)*8.;
        float c= fract(sin( float(i) * 100.) * 5377.)* 6.283;
        
        float m = -fract(t2 *float(i)+c)*(fract(t2*float(i)+c)-1.);
        m *= 1.;
    	vec4 sr = vec4(-15.+ float(i)*3. + sin(t2+float(i)),-.3 + m*15. , 0.+cos(t2*float(i))*2., .8 );
        sr.w *= sin(m)*3.;
        sr.xyz += sin(m);
     
        float sdr = length(p - sr.xyz) - sr.w;
        
        vec4 sc = vec4( 0.+cos(t2*float(i))*2.,-.3 + m*15. + cos(t1+float(i))*3.,-15.+ float(i)*3. + sin(t2+float(i)), .8);
        sc.w *= sin(m)*3.;
        sc.xyz += sin(m);
        float sdc = length(p - sc.xyz) - sc.w;
        
        
        float sdf = smin(sdr, sdc , .7);
        
        for(int e; e<5; e++){
            
            float Rr = float(e)*3.;
            
            vec4 sq = vec4(sin(j+Rr)*Rr,-.3+m*15.*((c/6.283)*.3+.7),cos(j)*Rr,.7*m);//around sphere
            sq.xyz += m*1.;
            sq.w += m*.1 + (c/6.283)*.1;
            float sdq = length(p - sq.xyz) - sq.w;

            sdf = smin(sdf, sdq, .7);
        }
        
        
        planeDist = smin(planeDist, sdf, 0.5);
        
    }
    
    vec4 sA = vec4(0, 1.2 + y,0,1);
    float sdA = length(p - sA.xyz) - sA.w;
   
    vec4 sB = vec4(0., -.4 + y , 0, 1.1);
    float sdB = length(p - sB.xyz) - sB.w;
    
    
    float sd = sdB;
    
    float td = sdTorus(p - vec3(0, 2.2 + y*2., 0), vec2(0.7+ y*.3, 0.27));
    sd = smin(sd,td,0.5);
    
    float Cad = sdCapsule(p, vec3(0,1. + y *2.,0), vec3(0, 0,0), 0.7);
    sd = smin(sd, Cad,0.5);
    
    
    float tda = sdTorus(p - vec3(0,fract(-t1)*2., 0), vec2(0.5*(abs(sin(t*2.))), 0.27));//absorb
    sd = smin(sd, tda, 0.5);
    
    vec3 bp = p - vec3(0, 1 , 0);
    bp.xz *= Rot(iTime);
    
    float BoxDist = sdBox(bp, vec3(.7));
    
    float CylDist = sdCylinder(p, vec3(2, 0.3,2), vec3(6, 0.3,5), 0.3);
    
    sd = smin(BoxDist, sd, 0.7);
    float d= smin(sd, planeDist, 0.7); 
    
    //float planeDist1 = 9.- p.y;//ceil
    
   	//d = smin(d, planeDist1, .7);
    
    
    return d;
}

// Function 3066
vec4 tMapSm(samplerCube iCh, vec3 p){
 
    // Using the 3D coordinate to index into the cubemap and read
    // the isovalue. Basically, we need to convert Z to the particular
    // square slice on the 2D map, the read the X and Y values. 
    //
    // mod(p.xy, 100), will read the X and Y values in a square, and 
    // the offset value will tell you how far down (or is it up) that
    // the square will be.
    vec2 offset = mod(floor(vec2(p.z, p.z/10.)), vec2(10, 10));
    vec2 uv = (mod(p.xy, 100.) + offset*100. + .5)/cubeMapRes;
    
    // Back Z face -- Depending on perspective. Either way, so long as
    // you're consistant. I noticed the Y values need to be flipped...
    // I'd like to arrange so that it's not necessary, but it might be
    // and internal thing, so I'm not sure how, yet.
    //
    // You could also use one of the newer texture functions that 
    // doesn't require the ".5" and "iChannelRes0" division, but I'm
    // keeping it oldschool. :) Actually, if the newer ones are
    // superior, let us know.
    return texture(iCh, vec3(fract(uv) - .5, .5));
}

// Function 3067
float sdf_main(vec3 p){
    vec3 ap=abs(p);
    float d_bbox=-1.1+max(max(ap.x,ap.y),ap.z);
    float d_cam=.2-distance(p,cam_pos);
    float d_cuts=max(d_bbox,d_cam);

    float d_curve=sdf_inner(peano_transform(p));
    if(d_cuts>d_curve && abs(d_curve)<1e-2) color=vec3(3.);
    return max(d_cuts,d_curve);
}

// Function 3068
vec3 simpleReinhardToneMapping(vec3 color)
{
    float exposure = 1.5;
    color *= exposure/(1. + color / exposure);
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 3069
vec3 seaHeightMap(vec3 dir) 
{
    vec3 p = vec3(0.0);
    float x = 1000.0;
	
    if (seaGeometryMap(SEA_ORI + dir * x) > 0.0)
    {
		return p;
    }
    
    float mid = 0.0;
    float m = 0.0;
    float heightMiddle = 0.0;
    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) 
    {	    
		mid = mix(m, x, 0.5); 
        p = SEA_ORI + dir * mid;
    	heightMiddle = seaGeometryMap(p);
		if (heightMiddle < 0.0) 
		{
            x = mid;
        } 
		else 
		{
            m = mid;
        }
    }
	
    return p;
}

// Function 3070
maybe_vec2 get_distances_along_line_to_negation(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    return maybe_vec2(
        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),
             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),
        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)
    );
}

// Function 3071
float dist (vec2 a, vec2 b) {
    vec2 c = abs(a-b);
    vec2 r = a-b;
    // return max(abs(r.x)*0.866025+r.y*0.5,-r.y);
	return ((c.x+c.y)+distance(a,b)+ max(abs(r.x)*0.866025+r.y*0.5,-r.y) )/3.; 
}

// Function 3072
float Scene(vec3 p)
{ 
    return max(max(abs(p.x), abs(p.y)), abs(p.z)) - 5.;
}

// Function 3073
float SDF (vec3 p) {
    float SDFp = 1e20;
    SDFp = min(SDFp, SDFwater(p));
    SDFp = min(SDFp, SDFland(p));
    return SDFp;
}

// Function 3074
float map(vec3 point){


wP = point + iCamPos;
    
        //shape finding functions:
        dSphere = sphere(point*iSphereScale, 0.3);
        dCone.l = ConeD(point,0.8,0.4);
       return min(dSphere.l,dCone.l);
       //return min(dSphere.l,point.z+20);
}

// Function 3075
vec4 ProcessScene(in vec2 fragCoord, in vec4 rand)
{
	Ray ray = ComputeRay(vec3(0), camRot, 6.0, 1.0, fragCoord);
    
    RayTraceSceneResult scene = RayTraceScene(ray, false);
    
    vec3 volumetric = vec3(0.);
    int iRand = 0;
    for (int s = 0; s < volSliceCount; ++s)
    {
        float t = float(s)/float(volSliceCount);
        float ct = GetLookupDepth(t) + GetRand(rand, s) * .01;
        float at = volDepthRange * ct;
        if (at > scene.hit.t)
        {
            break;
        }
        vec3 cPos = ray.org + at*ray.dir;
        float lightScattering = GetScatteringFactor(ray.dir, GetLightDirection(cPos));
        float decreaseFactor = GetIntensityFactor(ct);
        volumetric += decreaseFactor * lightScattering * GetLightIntensity(cPos);
    }
    
    vec3 lightIntensity = GetLightIntensity(scene.hit.pos);
    float nl = clamp(dot(scene.hit.nn, GetLightDirection(scene.hit.pos)),.0,1.);
    return vec4(scene.color*lightIntensity*nl + scene.emissive + volumetric,1.0);
}

// Function 3076
vec2 map_entities(vec3 p)
{
    // Finding the closest instance and only mapping it instead of the whole list (even for such tiny lists)
    // shaves about 4.9 seconds off the compilation time on my machine (~7.6 vs ~12.5)

    vec2 entities = vec2(1e+8, MATERIAL_SKY1);
    Closest closest;
    
    if (0u != (g_entities.mask & (ENTITY_MASK_TORCHES << ENTITY_BIT_TORCHES)))
    {
        FIND_CLOSEST(p, closest, g_ent_pos.torches, NUM_TORCHES);
        if (closest.distance_squared > sqr(40.))
            entities = bounding_sphere(closest.distance_squared, 32., MATERIAL_FLAME);
        else
            entities = map_torch(p, closest.point);
    }

    if (0u != (g_entities.mask & (ENTITY_MASK_LARGE_FLAMES << ENTITY_BIT_LARGE_FLAMES)))
    {
        FIND_CLOSEST(p, closest, g_ent_pos.large_flames, NUM_LARGE_FLAMES);
        if (closest.distance_squared > sqr(48.))
            entities = sdf_union(entities, bounding_sphere(closest.distance_squared, 40., MATERIAL_FLAME));
        else
            entities = sdf_union(entities, map_large_flame(p - closest.point));
    }
    
#if 0
    FIND_CLOSEST(p, closest, ZOMBIES);
	entities = sdf_union(entities, map_zombie(p - closest.point));
    //int num_zombies = NO_UNROLL(NUM_ZOMBIES);
    //for (int i=0; i<num_zombies; ++i)
    //    entities = sdf_union(entities, map_zombie(p - zombies[i]));
#endif
    
    if (0u != (g_entities.mask & (1u << ENTITY_BIT_FIREBALL)))
    	entities = sdf_union(entities, map_fireball(p, FIREBALL_ORIGIN));

    add_targets(p, entities);

    #if RENDER_WEAPON
    {
        if ((g_entities.mask & (1u << ENTITY_BIT_VIEWMODEL)) != 0u)
    		entities = sdf_union(entities, map_viewmodel(p));
    }
	#endif
    
    return entities;
}

// Function 3077
vec3 sceneNormal(vec3 pos)
{
	float distancePoint = scene(pos).x;
    float aepsilon = 0.01;
    float x = scene(pos + vec3(AEPSILON, 0.0, 0.0)).x;
    float y = scene(pos + vec3(0.0, AEPSILON, 0.0)).x;
    float z = scene(pos + vec3(0.0, 0.0, AEPSILON)).x;
	return normalize(vec3(x - distancePoint, y - distancePoint, z -distancePoint));
}

// Function 3078
vec2 uvmap(vec2 uv){
    return (2.*uv-iResolution.xy)/iResolution.y;
}

// Function 3079
float evaluateGGXSpecularDistribution(float nhDot, highp float roughness)
{
    // Walter et al. 2007, "Microfacet models for refraction through rough surfaces"
    // http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
    highp float a = roughness * roughness;
    highp float aa = a * a;
    highp float t = nhDot * nhDot * (aa - 1.) + 1.;
    return aa /
        (t * t + 1.e-20);
}

// Function 3080
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, ltVec;
  float dHit, ltDist, sh, spec;
  dHit = ObjRay (ro, rd);
  if (dHit < dstFar) {
    ro += dHit * rd;
    if (idObj >= idDrBod) {
      if (idObj == idDrBod) {
        col = vec3 (0.2, 0.2, 0.9);
        spec = 1.;
      } else if (idObj == idDrLamp) {
        col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),
           step (0., sin (10. * tCur)));
        spec = -1.;
      } else if (idObj == idDrCam) {
        col = vec3 (0.1);
        spec = 1.;
      }
    } else {
      if (idObj == 1) col = vec3 (1., 0.5, 0.);
      else col = vec3 (1., 1., 0.2);
      col *= 0.5 + 0.5 * smoothstep (0., 1., 0.5 + 0.5 * Noisefv3 (500. * ro));
      spec = 0.3;
    }
    vn = ObjNf (ro);
    ltVec = ltPos - ro;
    ltDist = length (ltVec);
    ltVec /= ltDist;
    if (spec >= 0.) {
      sh = ObjSShadow (ro, ltVec);
      col = col * (0.1 + 0.9 * sh * max (dot (vn, ltVec), 0.)) +
         spec * sh * pow (max (dot (normalize (vn - rd), vn), 0.), 64.);
      col *= 1. / (1. + 0.1 * ltDist * ltDist);
    }
  } else col = vec3 (0.);
  return col;
}

// Function 3081
float map(in vec3 p)
{
    float r = rock(p);
	float ground = min(p.y+.5,p.y+r*.5);
    
    float d = min(r, ground);
	d = max(d,p.y-1.);
    
	#ifdef ENABLE_GRASS
	const float grassSize = 100.;
	vec3 pgrass = (p+vec3(0.,ground-p.y,0.)) * grassSize;
    d = min(d, grass(pgrass)/grassSize );
    d = min(d, grass(pgrass+vec3(10.8,0.,1.5))/grassSize );
    d = min(d, grass(pgrass+vec3(-1.3,0.,-10.1))/grassSize );
    #endif
    
    return  d;
}

// Function 3082
vec3 SynthesisTonemap(vec3 color, float m, float a, float s, float L)
{
    float c = SolveC(m, a, s);
    float t = SolveT(m, a, s, c); // slope at y = 0.5 (x = c).
    
    vec3 result;
    result.x = (color.x < 0.5f) ? SynthesisLow(color.x, m, a, s) : SynthesisHigh(color.x, c, t, L);
    result.y = (color.y < 0.5f) ? SynthesisLow(color.y, m, a, s) : SynthesisHigh(color.y, c, t, L);
    result.z = (color.z < 0.5f) ? SynthesisLow(color.z, m, a, s) : SynthesisHigh(color.z, c, t, L);
    
    return result;
}

// Function 3083
vec2 sceneK(vec3 start,vec3 end)
{
    //float t = iTime;
    vec3 center = vec3(0.0,0.0,0.0);
    float radius = 1.5;
    float radius2 = radius * radius;
    float radius2Inv = 1.0/radius2;
    
    float k = 0.0;
    float I = 0.0;
    for(int i=0;i<32;i++)
    {
        vec2 data = K(start,end,center+3.0*random3(i),radius,radius2,radius2Inv,1.0);
        k+=data.x;
        I += data.y;
    }
    return vec2(k,I-0.5);
}

// Function 3084
float distCircleN(vec3 p, vec3 n, float r)
{
    return length(p-normalize(p-n*dot(n,p)/dot(n,n))*r);
}

// Function 3085
vec2 scene(vec3 p, float e) {
    //containing box
    vec2 sr = vec2(-sdBox(p,vec3(30.)),0.);
    
    //red wall
    if (p.x > 29.5) {
        sr.y = 2.;
    }
    
    //green wall
    if (p.x < -29.5) {
        sr.y = 3.;
    }
    
    //point light
    float odst = length(p)-0.5;
    if (odst< sr.x) {
        sr = vec2(odst, 1.);
    }
    
    // box wall
    odst = udBox(p-vec3(10.,0.,5.), vec3(1.,32.,4.));
    if (odst < sr.x) {
        sr = vec2(odst, 0.);
    }
    
    //reflective sphere
    odst = length(p-vec3(-4.,-20.,-4.))-7.0;
    if (odst < sr.x) {
        sr = vec2(odst, 4.);
    }
    
    return sr;
}

// Function 3086
float fetch_distance(in vec3 uvw)
{   
    return fetch_wave_power(uvw);

    // power -> distance
    // w = wavelength
    // p = sq(w) / (sq(4pi) * sq(d))
    // d = (w * sqrt(p)) / (4pi * p)
    
    //float d = (w * sqrt(p)) / (4.0*PI * p);
}

// Function 3087
float sdfBall(vec2 ball, vec2 p) {
    return distance(ball, uvToWorld(p)) - BALL_RADIUS;
}

// Function 3088
vec2 mapSeedt(vec2 uv)
{
    //uv = (uv + 1.)/2.;
    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);
    //return LIGHT_DIST;
    return seedCoord/iResolution.xy-uv;
}

// Function 3089
float groundDistance(vec3 p) {
  float bfact =0.3;
  vec3 post = postPos(p+vec3(0.05, 0.25, 0.0));
  return smin( p.y, length(post)-0.01, bfact );
}

// Function 3090
float getDistance( vec3 p ) {
    float max = 1.;
    float d = length( p );
    if ( d > max ) return d - max +.1;
    
    switch( TEAPOT_VERSION ) {
        case 1: return sirenTeapot1( p );
        case 2: return sirenTeapot2( p );
        case 3: return sirenTeapot3( p );
    }
    

    return sirenBunny( p );
}

// Function 3091
float map( in vec3 p )
{
	float h = terrain2(p.xz);
    return p.y - h;
}

// Function 3092
void sceneFirePlasma(vec2 fragCoord, vec2 uv, out vec3 params)
{
	uv.x=abs(uv.x);
	float t = iBeat*.4;
	float a = sin(dot(uv,vec2(cos(t),sin(t)))*5.);
	float b = sin(length(uv+sin(t)*.3)*8.-t*2.);
	params = vec3(
		((a+b)*.25+.5)*.85+hash2(fragCoord.xy)*.15,
		10,15
	);
}

// Function 3093
float opRep_scene1(vec3 p,vec3 c)
{
    vec3 q;
	q = mod(p+.5*c,c)-.5*c;
    return scene1(q);
}

// Function 3094
float map( vec3 p ){
	p=rotateX(p,rotX);//a little tilted for mo' 3d effect
	p +=shift;
	if (p.x>-0.5 && p.x<64. && p.z>0. && p.z<48.){
	vec4 tex=textureLod(iChannel0,p.xz/vec2(64.0,48.0).xy,0.0);

	float tl=max(.3,tex.r*1.5);//small size vs. big size
	float div=2.;
    p.x = mod( p.x + dist/div, dist ) - dist/div;
    //float dist2=2.75;
    //p.y = (mod( p.y + dist2/div, dist2 ) - dist2/div)-1.5;
   	p.z = mod( p.z + dist/div, dist ) - dist/div;

    	return length( center - p ) - tl;
    	}
    	else return float(1.);
}

// Function 3095
float dist_sphere(vec3 p)
{
	return length(p)-1.0;
}

// Function 3096
float dist(vec2 pos, out vec2 lastPos, out vec2 derivative, out float iter)
{
    vec2 z = vec2(0.0);
    vec2 dz = vec2(0.0);
#if experimental
	float maxIter = abs(sin(iTime*0.5)*100.)+10.;
#else
	const float maxIter = 1024.;
#endif
    
#if experimental
    float power = abs(sin(iTime*0.1)*3.);
#else
    const float power = 2.;
#endif
    
    float m2;
    float i=0.;
    for(;i<maxIter;i++)
    {
        dz = 2.* mat2(z,-z.y,z.x) * dz + 1.;
		z = cPow(z,power)-abs(pos);
        
        m2 = dot(z,z);
        if( m2>escapeRadius)
            break;
    }

	derivative = dz;
    iter = i/maxIter;
    lastPos = z;
    return sqrt( m2/dot(dz, dz))*0.5f*log(m2);
}

// Function 3097
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 rdd, qHitT, col, vn;
  float dstObj, d, reflFac, sh;
  int idObjT;
  bool isTrk;
  dstObj = dstFar;
  d = TrackRay (ro, rd);
  if (d < dstObj) {
    dstObj = d;
    isTrk = true;
  }
  idObjT = idObj;
  qHitT = qHit;
  d = SceneRay (ro, rd);
  if (d < dstObj) {
    dstObj = d;
    isTrk = false;
  } else {
    idObj = idObjT;
    qHit = qHitT;
  }
  reflFac = 0.;
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    idObjT = idObj;
    qHitT = qHit;
    vn = isTrk ? TrackNf (ro) : SceneNf (ro);
    idObj = idObjT;
    qHit = qHitT;
    if (idObj == idCar) {
      rdd = reflect (rd, vn);
      reflFac = (abs (qHit.y - 0.22) < 0.26) ? 0.6 : 0.2;
    }
    if (idObj < idCar) {
      if (idObj == idRbase || idObj == idTun || idObj == idTree) vn = VaryNf (128. * ro, vn, 2.);
      col4 = SceneCol (ro, vn);
    } else col4 = CarCol ();
    col = col4.rgb;
    if (col4.a >= 0.) {
      sh = (showTrn == 1) ? ObjSShadow (ro, ltDir) : 1.;
      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.) +
         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));
    }
  } else if (rd.y < 0.) {
    dstObj = - ro.y / rd.y;
    ro += dstObj * rd;
    vn = vec3 (0., 1., 0.);
    if (showTrn == 1) {
      sh = (dstObj < dstFar) ? ObjSShadow (ro, ltDir) : 1.;
      col = GrndCol (ro, rd);
      col = col * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));
      col = mix (col, SkyCol (abs (rd)), smoothstep (0.7, 1., dstObj / dstFar));
    } else {
      col = (max (abs (ro.x) - 2.8, abs (ro.z) - 3.2) < 0.) ?
         vec3 (0., 0.25, 0.) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) : vec3 (0.15);
    }
  } else {
    col = (showTrn == 1) ? BgCol (ro, rd) : vec3 (0.15);
  }
  if (showTrn == 1 && reflFac > 0.) col = mix (col, 0.7 * BgCol (ro, rdd), reflFac);
  if (! isCol) col = Maxv3 (smoothstep (0., 1., col)) * vec3 (1., 1., 0.9);
  return pow (clamp (col, 0., 1.), vec3 (0.8));
}

// Function 3098
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 vc;
  vec3 vn, col, roo, rdo, vno, rob, rdb, rg;
  float dstObj, dstWat, dstTransObj, a;
  bool watRefl, winRefl, isBm;
  HexVorInit ();
  bmHt = 17.;
  twBase = 4.;
  twRad = 3.;
  tWav = 0.2 * tCur;
  dispCloud = tCur * vec3 (-15., 0., 5.);
  bmAng = tCur;
  winRefl = false;
  watRefl = false;
  isBm = false;
  rob = ro;
  rdb = rd;
  dstObj = ObjRay (ro, rd);
  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;
  dstTransObj = TransObjRay (ro, rd);
  if (dstWat < min (dstObj, dstFar)) {
    watRefl = true;
    ro += dstWat * rd;
    vn = WaveNf (ro, dstWat);
    rd = reflect (rd, vn);
    ro += 0.01 * rd;
    dstObj = ObjRay (ro, rd);
  }
  if (dstTransObj < min (dstFar, dstObj)) {
    ro += rd * dstTransObj;
    roo = ro;
    rdo = rd;
    vno = TransObjNf (ro);
    winRefl = true;
    dstObj = ObjRay (ro, rd);
  }
  if (dstObj < dstFar) {
    ro += rd * dstObj;
    vn = ObjNf (ro);
    if (idObj == idTwr) {
      a = atan (ro.z, - ro.x) / (2. * pi);
      if (ro.y > twBase) {
        if (dot (normalize (ro.xz), vn.xz) > 0.9) {
          col = vec3 (0.9, 0.7, 0.5);
          col *= 0.5 + 0.5 * Fbm2 (vec2 (32. * a, 4. * ro.y));
          rg = ShStagGrid (vec2 (a, ro.y + 0.05), vec2 (30., 3.));
          col *= rg.y;
          if (rg.x == 0.) {
            vn.y += rg.z;
            vn.xz *= sqrt (1. - vn.y * vn.y);
          } else vn.xz = Rot2D (vn.xz, - rg.x);
        } else col = vec3 (0.4, 0.3, 0.2);
        vn = VaryNf (50. * ro, vn, 1.);
      } else {
        col = vec3 (1., 0.8, 0.2);
        col *= 0.7 * (0.5 + 0.5 * Fbm2 (vec2 (64. * a, 4. * ro.y)));
        vn = VaryNf (10. * ro, vn, 5.);
      }
    } else if (idObj == idGrnd) {
      vc = HexVor (ro.xz);
      vn = VaryNf (2. * ro, vn, 5.);
      col = 0.7 * mix (vec3 (1., 0.7, 0.2), vec3 (0.9, 0.8, 0.5),
         0.5 * Noisefv3 (8. * (1. + vc.w) * ro) + 0.5 * vc.w) * (0.7 + 0.3 * smoothstep (0., 0.4, ro.y));
    } else if (idObj == idFlr) {
      col = vec3 (0.5, 0.6, 0.3);
    } else if (idObj == idWfrm) {
      col = vec3 (0.6, 0.5, 0.4);
      vn = VaryNf (50. * ro, vn, 1.);
    } else if (idObj == idTtop) {
      col = vec3 (0.8, 0.7, 0.6);
      vn = VaryNf (50. * ro, vn, 1.);
    } else if (idObj == idLmp) {
      col = vec3 (0.5, 0.5, 0.6);
    } else if (idObj == idBm) {
      isBm = true;
      col = 1.2 * vec3 (1., 1., 0.9) * abs (dot (rd, vn));
    }
    if (! isBm) {
      col = col * (0.1 + 0.05 * max (dot (- normalize (sunDir.xz), normalize (vn.xz)), 0.) +
         0.8 * max (dot (sunDir, vn), 0.)) + 0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);
      if (winRefl) col = mix (col, BgCol (roo, reflect (rdo, vno)), smoothstep (0.5, 0.95,
            1. - pow (abs (dot (- rdo, vno)), 5.)));
    }
  } else if (rd.y < 0.) {
    watRefl = true;
    dstWat = - ro.y / rd.y;
    ro += dstWat * rd;
    col = BgCol (ro, reflect (rd, WaveNf (ro, dstWat)));
  } else {
    col = BgCol (ro, rd);
  }
  if (watRefl) {
    col = mix (mix (vec3 (0.01, 0.01, 0.), vec3 (0., 0.05, 0.05),
       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz))), 0.5 * col, 1. - pow (abs (rd.y), 4.));
  }
  return clamp (col, 0., 1.);
}

// Function 3099
Object map(vec3 p) {
    Object o = NewObject;
    
    vec2 dMain = sdMain(p);
    
	Object mainScene = Object(
    	dMain.x,
        true,
        materials[int(dMain.y)]
    );
    
    o = omin(o, mainScene);
    //o = omin(o, length(p) - 4., materials[2]);
	
    glow += exp(-o.d*1.);    
    o.didHit = true;
    return o;
}

// Function 3100
float SDFCircle( in vec2 coords, in vec2 offset )
{
    coords -= offset;
    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;
    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);
    return v/length(g); 
}

// Function 3101
vec3 envMap(vec3 rd){
    
   
    float c = tetraNoise(rd*3.)*.57 + tetraNoise(rd*6.)*.28 + tetraNoise(rd*12.)*.15; // Noise value.
    c = smoothstep(.4, 1., c); // Darken and add contast for more of a spotlight look.
    
    vec3 col = vec3(c*c*c, c*c, c); // Simple, cool coloring.
    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // Warm color.
    
    // Mix in the reverse color to tone it down and return.
    return mix(col, col.zxy, rd*.25 + .25); 
    
}

// Function 3102
vec2 DistanceToObject(in vec3 p)
{
    // first distort the y with some noise so it doesn't look repetitive.
    //p.xyz = RotateY(p, length(p.xz) + iTime);
    //p.y += 0.1;
    //p.xyz = RotateZ(p, length(p.z) + iTime);
    p.y += noiseTex(p*0.5)*0.5;
    // multiple frequencies of noise, with time added for animation
    float n = noiseTex(p*2.0+iTime*0.6);
    n += noiseTex(p*4.0+iTime*0.7)*0.5;
    n += noiseTex(p*8.0)*0.25;
    n += noiseTex(p*16.0)*0.125;
    n += noiseTex(p*32.0)*0.0625;
    n += noiseTex(p*64.0)*0.0625*0.5;
    n += noiseTex(p*128.0)*0.0625*0.25;
    // subtract off distance for cloud thickness
    float dist = n*0.25 - (0.275);// - abs(p.y*0.02)/* - iTime*0.01*/);
    //dist = smax(dist, -(length(p-camPos) - 0.3), 0.1);	// nice near fade
    // smooth blend subtract repeated layers
    dist = smax(dist, -(abs(fract(p.y*4.0)-0.5) - 0.15), 0.4);
    vec2 distMat = vec2(dist, 0.0);
    // sun in the distance
    distMat = matMin(distMat, vec2(length(p-camLookat - vec3(0.0, 0.5, -1.0)) - 0.6, 6.0));
    return distMat;
}

// Function 3103
float disMap(vec3 p){
    float dis = 0.0;
    float time = mod(iTime * speed + 30.0,200.0);
    float t = (sin(time) * 2.0);
    vec4 texMap;
    
	if(!texBend)
        texMap = texture(iChannel1,(p.zx + vec2(1,1))) *.1;
    if(doRotate){
        float rot = time * mPi * .20 * rotSpeed;
        p.xy *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));
        p.yz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));
        p=normalize(p);
    }
    p = makeItNoisy(time) * p;

	if(texBend)
        texMap = texture(iChannel1,p.xy);
    
	
    dis = length(texMap) ;
    
    dis += noise(p + time);
    
    return dis;
}

// Function 3104
MarchData map(vec3 p) {
    MarchData r = minResult(room(p), ed209(p));
    float gnd = length(p.y + 2.0);
    if (gnd < r.d) {
        r.d = gnd;
        r.mat = vec3(0.0);
    }
    return r;
}

// Function 3105
float starSDF( vec3 point, float len, float thickness ) {
    vec3 a0 = vec3( +0.000 * len, +1.000 * len, .0 ); // @ r:+1.570 , d:90
    vec3 a1 = vec3( -0.952 * len, +0.309 * len, .0 ); // @ r:+2.827 , d:162
    vec3 a2 = vec3( -0.588 * len, -0.810 * len, .0 ); // @ r:+4.084 , d:234
    vec3 a3 = vec3( +0.587 * len, -0.810 * len, .0 ); // @ r:+5.340 , d:306
    vec3 a4 = vec3( +0.951 * len, +0.309 * len, .0 ); // @ r:+6.597 , d:378
    
    float d0 = starSegmentSDF( point, a0, thickness );
    float d1 = starSegmentSDF( point, a1, thickness );
    float d2 = starSegmentSDF( point, a2, thickness );
    float d3 = starSegmentSDF( point, a3, thickness );
    float d4 = starSegmentSDF( point, a4, thickness );

    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );
}

// Function 3106
float scene(vec3 p) 
{
    // tile space mirrored, the transcendental-heavy way isn't as slow as it seems
    p = asin(sin(p+0.));
	// field of spheres
    return length(p)-1.;
}

// Function 3107
vec2 CalculateShadowMapUV(in mat4 shadowMapMatrix, in vec3 position, in float aspectRatio)
{
    vec3 lightPosition = vec3(shadowMapMatrix[3][0], shadowMapMatrix[3][1], shadowMapMatrix[3][2]); 
    
    vec3 lightWorldDirection = normalize(position.xyz - lightPosition);
    vec3 shadowMapCameraRayDirection = (vec4(lightWorldDirection.xyz, 1.0) * shadowMapMatrix).xyz;
    shadowMapCameraRayDirection /= shadowMapCameraRayDirection.z;
    
    vec2 textureCoords = shadowMapCameraRayDirection.xy / vec2(aspectRatio, 1.0);
    textureCoords = textureCoords * 0.5 + 0.5;
    
    return textureCoords;
}

// Function 3108
float map(vec3 p)
{
    float d1 = sdSphere(p, vec3(-2, -1, 0), 1.0);
    float d2 = sdBox(p, vec3(0.5));
    return min(d1, d2);
}

// Function 3109
float distCar(vec3 pos)
{
    pos.x=abs(pos.x);
    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return length(pos)-ObjBoundRadius*0.5;
    float dist = 100000.0;
    dist = min(dist, sdRoundBox(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15)*1.2,0.15));
    pos.y=abs(pos.y);
    dist = smin2(dist, sdRoundBox(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1)*1.2,0.1),10.0);
    dist = max(dist, -(length((pos-WheelFR).yzx)-WheelRadius*1.2));
    dist = min(dist, distTorus((pos-WheelFR).yzx,WheelRadius-0.15,0.15));
    return dist;
}

// Function 3110
float sphereOrCubeDist(vec3 a, vec3 b) {
    return mix(length(a-b), sqrt(sphereDist2(a,b)), sphere_fraction);    
}

// Function 3111
vec2 GetDistancePaper( const in vec3 vPos )
{
	float fDistance = GetDistanceBox(vPos, vec3(1.05, 0.01, 1.485));

	return vec2(fDistance, kMaterialPaper);
}

// Function 3112
float eyeRayToSphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)
{
    vec3 L = rayOrigin - sphereOrigin;
	float a = dot(rayDirection, rayDirection);
	float b = 2.0 * dot(rayDirection, L);
	float c = dot(L, L) - sphereRadius * sphereRadius;
	vec2 results = solveQuadratic(a, b, c);
    return results.x;
    
}

// Function 3113
float sdf( vec3 p ) {
    return length( p ) - 1.2 ;
}

// Function 3114
float SDF_particle(vec3 p0, vec3 p)
{
    particle point = get(fakech0, p0);
    return length(point.pos.xyz - p) - sphere_rad;
}

// Function 3115
vec4 map_land(vec2 fragCoord, bool ocean) {
    vec2 p = fragCoord;
    vec2 grad = vec2(buf(p+E).z - buf(p+W).z, buf(p+N).z - buf(p+S).z);
    float light = cos(atan(grad.y, grad.x) + 0.25*PI) * clamp(0.2 * length(grad), 0., 1.);
    vec4 fragColor = vec4(vec3(0.015 + 0.085 * light), 1);
    if (!ocean) fragColor.rgb *= 3.;
    float y = buf(fragCoord).z;
    if (y < OCEAN_DEPTH) {
        if (ocean)
            fragColor = mix(DEEP_WATER, SHALLOW_WATER, y / OCEAN_DEPTH);
        else
            fragColor.rgb = vec3(0);
    }
    fragColor.w = MAP_HEIGHT(y);
    return fragColor;
}

// Function 3116
MarchData map(vec3 p) {
	MarchData r = minResult(room(p), ed209(p));
	float gnd = length(p.y + 3.);
	if (gnd < r.d) {
		r.d = gnd;
		r.mat = vec3(.1);
	}

	return r;
}

// Function 3117
float sdf_l(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    return t;
}

// Function 3118
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    float t;
    Material res_mtl;
    SurfaceHitInfo currentHit;
    
    vec3 aabbmin, aabbmax;
    float tt;
    int ballid = -1;
    
    rayTableIntersection(ray, distMin, forShadowTest, hit, nearestDist);
    
   /* vec4 laabb = loadAABB(1);
    vec4 raabb = loadAABB(2);
    
    aabbmin = vec3(laabb.x, -1.0, laabb.y) - EPSILON;
    aabbmax = vec3(laabb.z,  1.0, laabb.w) + EPSILON;
    bool hitl = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    
    aabbmin = vec3(raabb.x, -1.0, raabb.y) - EPSILON;
    aabbmax = vec3(raabb.z,  1.0, raabb.w) + EPSILON;
    bool hitr = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    */
    
    vec4 aabb = loadAABB(0);
    aabbmin = vec3(aabb.x, -1.0, aabb.y) - EPSILON;
    aabbmax = vec3(aabb.z,  1.0, aabb.w) + EPSILON;
    bool bhit = rayAABBIntersection(ray, aabbmin, aabbmax, true, tt, currentHit);
    
    if(/*forShadowTest || hitl || hitr*/bhit){
        //intersect balls
        for(int i=0; i<numBalls; i++) {
            Ball ball = loadBall(iChannel0, i);

#ifdef MOTION_BLUR
            vec3 pos = mix(ball.mtx_prev[3].xyz, ball.mtx[3].xyz, ray.time);
#else
            vec3 pos = ball.mtx[3].xyz;
#endif
            if(intersectSphere(ray, pos, t) && (t > distMin) && (t < nearestDist)) {
                if(forShadowTest){
                    return false;
                } else {
                    ballid = i;
                    vec3 p = ray.origin + ray.dir * t;
                    hit.normal_ = /*normalize*/(p - pos);//try to remove it's not needed
                    hit.tangent_ = normalize(orthogonalize(hit.normal_, ball.mtx[1].xyz));
                    hit.position_ = p;

                    mat4 mtx;
#ifdef MOTION_BLUR
            		mtx = mtxLerp2(ball.mtx_prev, ball.mtx, ray.time);
#else
            		mtx = ball.mtx;
#endif
                    mat4 inv_mtx = inverse(mtx);

                    vec3 p_local = toVec3( inv_mtx*vec4(p, 1.0));
                    float rho, phi, theta;
                    cart2sph( p_local, rho, phi, theta );
                    hit.uv_.x = clamp((phi+PI*0.5)/PI, 0.0, 1.0);
                    hit.uv_.y = clamp((theta+PI)/TWO_PI, 0.0, 1.0);
                }

                nearestDist = t;
            }
        }

        if(ballid != -1) {
            hit.mtl_id_ = SURFACE_ID_BASE + num_mtl + ballid;
        }
    }
    
    
    //intersect light
    bool hit_result = rayZPlaneIntersection( ray, light.pos, light.size, forShadowTest, t, currentHit );
    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {
        //Convert results to world space
        currentHit.position_ = ray.origin + ray.dir * t;
        currentHit.normal_   = vec3(0.0, -1.0, 0.0);
        currentHit.tangent_  = vec3(-1.0, 0.0, 0.0);

        nearestDist = t;
        hit = currentHit;
        hit.mtl_id_ = LIGHT_ID_BASE+0;
    }
    
    //intersect cue
    float distToCue;
    Cue cue = readCue(iChannel0);
    mat4 inv_mtx = inverse(cue.mtx);
    Ray rayLocal;
    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );
    
    //float h = (cue.h * cue.r0) / (cue.r0 - cue.r1);
    hit_result = rayConeIntersection( rayLocal, cue.r0, cue.r1, cue.h, forShadowTest, distToCue, currentHit );
    if( hit_result && ( distToCue > distMin ) && ( distToCue < nearestDist ) ) {
        currentHit.position_ = ray.origin + ray.dir * distToCue;
        //currentHit.position_ = toVec3( cue.mtx*vec4( currentHit.position_, 1.0 ) );
        currentHit.normal_   = toVec3( cue.mtx*vec4( currentHit.normal_  , 0.0 ) );
        currentHit.tangent_  = toVec3( cue.mtx*vec4( currentHit.tangent_ , 0.0 ) );
        currentHit.mtl_id_ = SURFACE_ID_BASE+1;

        hit = currentHit;
        nearestDist = distToCue;
    }
    /*
    //intersect chalk
    inv_mtx = inverse(chalk.mtx);
    rayLocal.origin = toVec3( inv_mtx*vec4( ray.origin, 1.0 ) );
    rayLocal.dir 	= toVec3( inv_mtx*vec4( ray.dir   , 0.0 ) );
    
    hit_result = rayAABBIntersection( rayLocal, -vec3(chalk.size*0.5), vec3(chalk.size*0.5), forShadowTest, t, currentHit );
    if( hit_result && ( t > distMin ) && ( t < nearestDist ) ) {
        hit = currentHit;
        hit.position_ = ray.origin + ray.dir * t;
        //currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );
        hit.normal_   = toVec3( chalk.mtx*vec4( currentHit.normal_  , 0.0 ) );
        hit.tangent_  = toVec3( chalk.mtx*vec4( currentHit.tangent_ , 0.0 ) );
        hit.mtl_id_ = SURFACE_ID_BASE+2;

        nearestDist = t;
    }*/
    
    return ( nearestDist < 1000.0 );
}

// Function 3119
float sceneMap3D(vec3 pos, vec3 lightPos)
{
    float t = plane(pos, FLOOR_VEC);
    t = min(t, plane(pos, LEFT_WALL_VEC));
    t = min(t, plane(pos, RIGHT_WALL_VEC));
    t = min(t, plane(pos, BACK_WALL_VEC));
    t = min(t, plane(pos, CEILING_VEC));
    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));
    t = min(t, box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE));
    return t;
}

// Function 3120
float remap(float f, float in1, float in2, float out1, float out2) {
    return mix(out1, out2, clamp((f - in1) / (in2 - in1), -0.1, 0.9));
}

// Function 3121
vec3 getCosineDistribution(vec3 dir)
{
	//dir = normalize(dir);
	vec3 o1 = normalize(ortho(dir));
	vec3 o2 = normalize(cross(dir, o1));
	vec2 r = rand2n(dir.xy,iTime);
	r.x=r.x*2.*3.141592;
	float oneminus = sqrt(1.0-r.y*r.y);
	return cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;
}

// Function 3122
float WaterMap( vec3 pos ) {
    return FBM( vec3( pos.xz, iTime*0.4 )) * 2.;
}

// Function 3123
float map(float t, float a, float b, float c, float d) {
	return (d-c)*clamp((t-a)/(b-a), 0., 1.)+c;
}

// Function 3124
float map(vec3 p) 
{
	#ifdef ROTATION
	R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
	#endif
    
	float NebNoise = abs(NebulaNoise(p/0.5)*0.5);
    
	return NebNoise+0.03;
}

// Function 3125
float mapLo(in vec3 rp)
{
    return sdTorus(rp, vec2(RADIUS, THICKNESS))*.005;
}

// Function 3126
vec2 scene(in vec3 pO) {
    vec3 p = pO;
    vec2 sceneShape = vec2(sdPlane(p), 1.0);
    p -= bunnyPos;
    p = bunnyRotation*p;
    float shape = 1e9;    
    p.y -= 0.15;
#if 1
    p += vec3(0.5);    
    shape = combine(shape, sdEllipsoid(p-vec3(0.579787, 0.326087, 0.587838), vec3(0.306784, 0.294628, 0.319604)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.212766, 0.478261, 0.614865), vec3(0.142153, 0.301739, 0.198772)));  
    shape = combine(shape, sdEllipsoid(p-vec3(0.356383, 0.793478, 0.47973), vec3(0.0686655, 0.0734181, 0.049516)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.31383, 0.0652174, 0.75), vec3(0.121429, 0.043445, 0.111769)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.43617, 0.847826, 0.398649), vec3(0.0525406, 0.0724031, 0.0349506)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.164894, 0.597826, 0.662162), vec3(0.116986, 0.180009, 0.232665)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.531915, 0.277174, 0.290541), vec3(0.141038, 0.143824, 0.0819466)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.797872, 0.173913, 0.587838), vec3(0.152242, 0.124905, 0.157487)));  
    shape = combine(shape, sdEllipsoid(p-vec3(0.521277, 0.0978261, 0.581081), vec3(0.305612, 0.0526198, 0.299388))); 
    shape = combine(shape, sdEllipsoid(p-vec3(0.462766, 0.0815217, 0.837838), vec3(0.068863, 0.0449702, 0.0720527)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.356383, 0.375, 0.47973), vec3(0.260118, 0.217964, 0.14091)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.5, 0.891304, 0.331081), vec3(0.0219774, 0.0667988, 0.0356658)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.287234, 0.73913, 0.533784), vec3(0.0541389, 0.0804187, 0.054103)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.579787, 0.277174, 0.878378), vec3(0.120201, 0.160738, 0.0550283)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.393617, 0.820652, 0.445946), vec3(0.0665282, 0.0758984, 0.0433889)));
    shape = combine(shape, sdEllipsoid(p-vec3(0.0851064, 0.576087, 0.797297), vec3(0.0339068, 0.086274, 0.0683804))); 
        
    if(!showEar)
    {
        p = pO;
        p -= earPos;
   	 	p = earRotation*p;
        p += earDelta;
    }
    
    float earShape = 1e9;
    earShape = combine(earShape, sdEllipsoid(p-vec3(0.18617, 0.88587, 0.101351), vec3(0.0194326, 0.0285867, 0.0526812)));
    earShape = combine(earShape, sdEllipsoid(p-vec3(0.180851, 0.809783, 0.283784), vec3(0.0473297, 0.0466274, 0.0946735)));
    earShape = combine(earShape, sdEllipsoid(p-vec3(0.196809, 0.815217, 0.168919), vec3(0.0283318, 0.0726224, 0.0925792)));
    earShape = combine(earShape, sdEllipsoid(p-vec3(0.18617, 0.744565, 0.385135), vec3(0.0512605, 0.0493519, 0.184969))); 
    
    
    if(!showEar)
    {     
        shape = min(shape, earShape);
    }
    else
    {
        shape = combine(shape, earShape);
    }
           
#else
    for(int i = 0; i < 12; i++)
    	shape = min(shape, sdSphere(p-physProxy[i].xyz, physProxy[i].w));
    if(!showEar)
    {
        p = pO;
        p -= earPos;
   	 	p = earRotation*p;
        p += earDelta-vec3(0.5);
    }
    for(int i = 12; i < NUM_PHYS_SPHERES; i++)
    	shape = min(shape, sdSphere(p-physProxy[i].xyz, physProxy[i].w));
#endif

    return opUnion(vec2(shape, 0.0), sceneShape);
}

// Function 3127
vec2 map_fireball(vec3 p, vec3 origin)
{
    vec3 current_pos = origin + g_entities.fireball.offset;
    p -= current_pos;
    p = rotate(g_entities.fireball.rotation, p);
    float dist = sdf_sphere(p, 3.);
    dist = sdf_smin(dist, sdf_sphere(p - vec3(1.5, 1.5, 4), 4.), 3.);
    dist = sdf_smin(dist, sdf_sphere(p - vec3(2.5,-1.5, 3), 2.5), 3.);
    return vec2(dist, MATERIAL_LAVA1);
}

// Function 3128
vec4 mapFloor ( vec3 pos )
{
    vec4 ret = vec4(0.1,0.1,0.1,1.0);
    ret.w = pos.y;
    return ret;
}

// Function 3129
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
	float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
    	float dist = sceneSDF(eye + depth * marchingDirection);
        if (dist < EPSILON) {
        	return depth;
        }
        
        depth += dist;
        if (depth >= end) {
        	return end;
        }
    }
    return end;
}

// Function 3130
vec3 RenderScene(in vec3 origin, in vec3 rayDirection, out float hitDistance)
{
    vec3 finalColor = vec3(0.0);
    vec3 albedo = vec3(0.0);
    vec3 sphereMaterial = vec3(0.0);

    // returns distance and material
    vec2 hit = RayMarch(origin, rayDirection, sphereMaterial);
    hitDistance = hit.x;
    float material = hit.y;
    
    vec3 sphereColor = vec3(0.13, 0.0, 0.5);
    
    if (material > 0.0)
    {
        // Essential vectors and scalars for lighting calculation
        vec3 position = origin + hitDistance * rayDirection;
        vec3 normal	= CalcNormal(position);
        vec3 viewDir = normalize(-rayDirection);
        vec3 lightDir = normalize(vec3(20.6, 20.7, -20.7) - position);
        vec3 halfVec = normalize(viewDir + lightDir);
        vec3 reflectDir = normalize(reflect(rayDirection, normal));
        
        float NdotL = max(dot(normal, lightDir), 0.0);
        float NdotV = max(dot(normal, viewDir), 0.0);
        float NdotH = max(dot(normal, halfVec), 0.0);
        float LdotH = max(dot(lightDir, halfVec), 0.0);
        float VdotH = max(dot(halfVec, viewDir), 0.0);
        
        float roughness = 0.0, metallic = 0.0;
        vec3 F0 = vec3(0.0);
        
        if (material < 2.0)
        {
            // Checkerboard floor
        	float f = mod(floor(7.5 * position.z) + floor(7.5 * position.x), 2.0);
			albedo = 0.4 + f * vec3(0.6);
            roughness = (f > 0.5 ? 1.0 : 0.18);
            metallic = 0.4;
            // Plastic/Glass F0 value
            F0 = mix(vec3(0.04), albedo, metallic);
        } 
        else if (material < 3.0)
        {
            // Spheres
         	albedo =  sphereMaterial;
            roughness = clamp(SPHERE_ROUGHNESS, 0.0, 1.0);
            metallic = clamp(SPHERE_METALLIC, 0.0, 1.0);
            // Silver F0 value
            F0 = mix(SILVER_F0, albedo, metallic);
        }
         
        
        // Calculate radiance
        //float lightDistance = length(lightDir);
        //float attenuation = 1.0 / (lightDistance * lightDistance);
        float attenuation = ShadowMarch(position, lightDir);
        vec3 radiance = LIGHT_INTENSITY * attenuation;
        
        // Cook-Torrence specular BRDF
        float ndf = NormalDistributionGGX(NdotH, roughness);
        float geometry = GeometrySmith(NdotV, NdotL, roughness);
        vec3 fresnel = FresnelSchlick(VdotH, F0);
        
        vec3 numerator = ndf * geometry * fresnel;
        float denominator = 4.0 * NdotV * NdotL;
        
        vec3 specular = numerator / max(denominator, 0.0001);
        
        // Burley Diffuse BRDF
        float diffuse = DiffuseBurley(roughness * roughness, NdotV, NdotL, LdotH);
        
        // Energy conservation
        vec3 kS = fresnel;
        vec3 kD = vec3(1.0) - kS;
        // Diffuse light decreases as "metal-ness" increases (and vice versa).
        kD *= 1.0 - metallic;
        
        vec3 ambient = 0.05 * albedo;
            
        // Note to self: Hmm, not sure whether to divide diffuse by PI or not. Some implementations
        // do while others don't seem to.
        // Also, note to self: We don't multiply by kS here because it's already done in the calculation
        // of the numerator part of the specular component.
        finalColor += (kD * albedo * diffuse / PI + specular + ambient) * radiance * NdotL;
        
        
        // Indirect Lighting
        sphereMaterial = vec3(0.0);
        vec2 indirectHit = RayMarch(position, reflectDir, sphereMaterial);
        vec3 indirectDiffuse = DiffuseIrradiance(normal) / PI;
        vec3 indirectSpecular = INDIRECT_SPECULAR_OFFSET + reflectDir.y * 0.72;
        
        if (indirectHit.y > 0.0)
        {
            if (indirectHit.y < 2.0)
            {
                vec3 indirectPosition = position + indirectHit.x * reflectDir;
                // Checkerboard floor
                float f = mod(floor(7.5 * indirectPosition.z) + floor(7.5 * indirectPosition.x), 2.0);
				indirectSpecular = 0.4 + f * vec3(0.6);
            }
            else if (indirectHit.y < 3.0)
            {
                // Spheres
                indirectSpecular = sphereMaterial;
            }
        }
        
        vec2 prefilteredSpecularBRDF = PrefilteredEnvApprox(roughness, NdotV);
        vec3 indirectSpecularColor = F0 * prefilteredSpecularBRDF.x + prefilteredSpecularBRDF.y;
        vec3 ibl = albedo * indirectDiffuse + indirectSpecular * indirectSpecularColor;
        
        finalColor += ibl * INDIRECT_INTENSITY;
    }
    
    return finalColor;
}

// Function 3131
vec3 getSceneColor(vec3 ro, vec3 rd) {
	// Raymarch.
	vec3 p;
	float g,
	      d = .01;
	MarchData h;
	for (float steps = 0.; steps < 120.; steps++) {
		p = ro + rd * d;
		h = map(p);
		if (abs(h.d) < .0015 * d) break;
		if (d > 64.) return vec3(0); // Distance limit reached - Stop.
		d += h.d; // No hit, so keep marching.
	}

	// Lighting.
	g = glow;
	return applyLighting(p, rd, d, h) + fireShock() * .3 + g;
}

// Function 3132
float sinSDF(vec2 st, float A, float offset, float f, float phi) {
    return abs((st.y - offset) + sin(st.x * f + phi) * A);
}

// Function 3133
float ellipse_dist(vec2 uv, mat3 M) {
    
    vec3 uv1 = vec3(uv, 1.0);
    
    float k = dot(uv1, M * uv1);
    
    float dist = k / length(vec2(dFdx(k), dFdy(k)));
    
    return abs(dist)-0.5;
    
}

// Function 3134
void initscene()
{
    box0.min = vec3(-1.5, -1.2, -2.0);//room
   	box0.max = vec3( 1.5,  1.2,  2.0);
    
    light = vec3(-0.0, 1.7, 0.6);

    float h = sin(time*3.0)*0.03;
    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;
    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu
   	sfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde
   	sfere[2].center_radius = vec4(0.0, -0.9,1.3,    0.5);//albastru
    sfere[3].center_radius = vec4(light,    0.05);//albastru

}

// Function 3135
float cDistance(in vec2 v,in vec2 p[PointCount]){
 float d[8];for(int i=0;i<PointCount;i++){int e=modi(i);
  d[i]=sdLine2(v,p[i],p[e]);}return min8(d);}

// Function 3136
SRayHitInfo TestSceneMarch(in vec3 rayPos)
{
    SRayHitInfo hitInfo;
    hitInfo.hitAnObject = false;
    hitInfo.dist = c_superFar;
    return hitInfo;
}

// Function 3137
vec2 map( in vec3 p, out vec4 glows)
{	
	vec2 res = distBody(p);

	vec2 filterDist = distModuleObject(p-module1Pos);
	vec2 filterDist2 = distModuleObject(p-module3Pos);
	vec2 cube = distCubeObject(p-module2Pos);
	vec2 cube2 = distCubeObject(p-module4Pos);
	
	if (filterDist.x < res.x) res = filterDist; 
	if (filterDist2.x < res.x) res = filterDist2; 
	if (cube.x < res.x) res = cube; 
	if (cube2.x < res.x) res = cube2; 
	
	glows = vec4(filterDist.x,cube.x,filterDist2.x,cube2.x);
	
	return res;
}

// Function 3138
void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){
    
    
    // UV coordinates.
    //
    // For whatever reason (which I'd love expained), the Y coordinates flip each
    // frame if I don't negate the coordinates here -- I'm assuming this is internal, 
    // a VFlip thing, or there's something I'm missing. If there are experts out there, 
    // any feedback would be welcome. :)
    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));
 
    // Pixel storage.
    vec3 col;
   
    // Initial conditions -- Performed upon initiation.
    if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){
        
        // INITIAL CONDITIONS.
       
        // Sprinkle some hash noise into the RGB channels on the canvas. 
        // Set the wrapping values.
        
        gSc = 512.;
        col = vec3(hash21(uv), hash21(uv + 7.), hash21(uv + 9.));
        
        #if SCHEME == 0
        // Smooth value noise overlay to achieve that pattern within
        // a pattern look.
        gSc = 24.;
        col *= smoothstep(0., .01, n2D(uv*gSc) - .5)*4. + 1.;
        #endif
        
        // Another square combination.
        //gSc = 512.;
        //col = vec3(1)*hash21(floor(uv*64.)/32.);
        //col = max(col, hash21(uv));
        
        /*
        // Just to show that it works with anything, add the "London" texture to 
        // "iChannel1" and uncomment the this block... For better resolution, you
        // might also wish to switch to the SMALL_BLUR option in the "Common" tab, 
        // and take out the scrolling in the "Image" tab.
        vec3 tx = texture(iChannel1, fract(uv*2. + .5)).xyz; tx *= tx; // Rough SRGB to linear.
        #if SCHEME == 1
        tx = vec3(1)*dot(tx, vec3(.299, .587, .114))
        #endif
        col = tx;
        */
        
    }
    else {
            
       	// Formula: Initial value, minus the larger filter differences,
        // plus the smaller filter difference.
 
        vec3 val = tx(iChannel0, uv).xyz;
        
        // Larger kernel sizes give more controlls blurs, and generally thicker patterns,
        // which I like, but they tend to be slightly slower and more costly. Having said 
        // that, the larger blurs require a total of 74 (49 + 25) texel reads, which the 
        // average GPU can do with ease. The smaller blur dimensions require just 34 
        // (25 + 9) reads.
        
        // Inside a raymarching loop, it'd be just the one read. Plus, you could 
        // stop the blurring process entirely, once you're satisfied with the pattern.
        
        // Only odd sizes differing by two will work.
        #ifdef SMALL_BLUR
        const int blurDimL = 5; // Large filter dimension.
        const int blurDimS = 3; // Small filter dimension.
        #else 
        const int blurDimL = 7; // Large filter dimension.
        const int blurDimS = 5; // Small filter dimension.
        #endif
        
        // You could stop filtering at this point. For raymarched patterns, it'd be 
        // worth saving every cycle you can. I think there's a discard option as well.
        //if(iTime<15.){        
            vec3 val3 = BlurTri(iChannel0, uv, blurDimL).xyz;    
            vec3 val2 = BlurTri(iChannel0, uv, blurDimS).xyz; 
        
            // These figures require a bit of coaxing, but they're not too hard
            // to tweak. With small kernel sizes, the larger blurring speed needs
            // to slow down. Once you get them right, they'll work with virtually
            // any normal range pattern.
            #ifdef SMALL_BLUR
            col = val + (val2 - val3) + (val2 - val);
            #else
            col = val + (val2 - val3)*1.6 + (val2 - val);
            #endif
        //}
        //else col = val;
        
       
          
    }
    
    fragColor = vec4(clamp(col, -1., 1.), iResolution.y);
    
}

// Function 3139
float remap0to1(float a, float b, float t)
{
    return sat((t - a) / (b - a));
}

// Function 3140
vec3 Tonemap( vec3 x )
{
#if 0 
    
    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );
    float f = dot( x, luminanceCoeffsBT709 );
    x /= f;        
    f = 1.0f - exp(-f);    
    x *= f;    
    x = mix( x, vec3(f), f*f );
    
    return x;
#else       
    float a = 0.010;
    float b = 0.132;
    float c = 0.010;
    float d = 0.163;
    float e = 0.101;

    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    
#endif    
}

// Function 3141
float distFromPlane(vec3 p){
;return dot(vec3(0,1,0), p)+1.5;}

// Function 3142
float mapgrid_coverage( vec3 r, mat2x3 Kr, float zoom )
{
    vec3 north = normalize( reject( UNIT_Z, r ) );
    vec3 east = cross( north, r );
    float lat = degrees( atan( r.z, length( r.xy ) ) );
    float lng = degrees( atan( r.y, r.x ) );
    float sz = sqrt( 1. - r.z * r.z );
    float Ku = degrees( Linfinity( north * Kr ) );
    float Kv = degrees( Linfinity( east * Kr ) ) / sz;
    const float n = 5.;
    const float log2n = log2( n );
    float levels[] = float[]( 90., 30., 5., 1., .2 );
    int l = zoom < 1. ? 0 : zoom < 6. ? 1 : zoom < 30. ? 2 : 3;
    float grid1 = levels[l];
    float grid2 = levels[l + 1];
    int m = min( l, abs( lat ) >= 90. - grid2 ? 0 :
                    abs( lat ) >= 90. - grid1 ? 1 :
                    abs( lat ) >= 85. ? 2 : 3 );
    float grid1h = levels[m];
    float grid2h = levels[m + 1];
    float latitudes = aaa_stipple( Ku, grid1 / 2. + lat, grid1, .25 * Ku / grid1 );
    float meridians = aaa_stipple( Kv, grid1h / 2. + lng, grid1h, .25 * Kv / grid1h );
    float sub_latitudes = aaa_stipple( Ku, grid2 / 2. + lat, grid2, .0625 * Ku / grid2 );
    float sub_meridians = aaa_stipple( Kv, grid2h / 2. + lng, grid2h, .0625 * Kv / grid2h );
    float meridian_mask = aaa_interval( Ku, lat, 180. - 2. * grid2 / 5. );

    return max(
        latitudes, max(
            meridians * meridian_mask, max(
                sub_latitudes,
                sub_meridians * meridian_mask ) ) );
}

// Function 3143
float map(vec3 p)
{
    vec3 p2 = p;
    p2.xz *= mm2(-time*0.4);
    float d = max(cyl(p, vec2(1.,1.)), -sbox(p2 - vec3(1,1.,0), vec3(1.1+mo.x*0.6, 0.8 - mo.y*2.2, 1.2)));
    return max(d, -cyl(p + vec3(0.,-2.2-mo.y*2.2,0), vec2(0.75+sin(time)*0.2,2.)));
}

// Function 3144
float sceneSmooth(vec2 p, float r)
{
	float accum = sceneDist(p);
	accum += sceneDist(p + vec2(0.0, r));
	accum += sceneDist(p + vec2(0.0, -r));
	accum += sceneDist(p + vec2(r, 0.0));
	accum += sceneDist(p + vec2(-r, 0.0));
	return accum / 5.0;
}

// Function 3145
void initScene() {
    
    //create lights
    createLight(vec3(1.0, 1.0, 0.9), 10.0, lights[0]);
    
    //Create materials
    createMaterial(0, vec3(0.9), materials[0]);
    createMaterial(0, vec3(0.9), materials[1]);
    createMaterial(1, vec3(0.9, 0.5, 0.9), materials[2]);
    createMaterial(0, vec3(0.5, 0.5, 0.9), materials[3]);
    createMaterial(2, vec3(0.5, 0.5, 0.9), materials[4]);
#ifdef BOX
    createMaterial(0, vec3(0.96, 0.02, 0.05), materials[5]);
#endif
    
    //init lights
    float r = 1.3;
    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;
    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;
    float x = xFactor*7.0;
    float z = -3.0-yFactor*5.0;
    float a = -2.2;
    mat4 trans = createCS(	vec3(x, 5.0, z),
                          	vec3(0.0, sin(a), cos(a)),
                  			vec3(1.0, 0.0, 0.0));
#ifdef SPHERE_LIGHT
    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );
#else
    float aa = 2.0 * r;
    float bb = 3.0 * r;
    createPlane(trans, -bb, -aa, bb, aa, LIGHT_ID_BASE+0, objects[0]);
#endif
    
    
    //plane 1
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 4.0, -10.0, 1.0 ));
    createPlane(trans, -10.0, -5.0, 10.0, 5.0, SURFACE_ID_BASE+1, objects[1]);
   
    //plane 2
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, -1.0, 0.0 ),
                    vec4( 0.0, -1.0, 0.0, 0.0 ),
                    vec4( 0.0, -1.0, -5.0, 1.0 ));
    createPlane(trans, -10.0, -5.0, 10.0, 5.0, SURFACE_ID_BASE+1, objects[2]);
 
    
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( -3.5, 0.3, -4.5, 1.0 ));
    createBunny(trans, SURFACE_ID_BASE+2, objects[3]);
    
    vec3 xvec = normalize(vec3(0.8, 0.2, -0.1));
    trans = createCS(	vec3(0.0, 0.3, -5.5),
                        xvec,
                  		vec3(0.0, 1.0, 0.0));
    createBunny(trans, SURFACE_ID_BASE+4, objects[4]);
    
    xvec = normalize(vec3(0.8, 0.2, -0.1));
    trans = createCS(	vec3(3.5, 0.3, -4.5),
                        xvec,
                  		vec3(0.0, 1.0, 0.0));
    createBunny(trans, SURFACE_ID_BASE+3, objects[5]);
    //createSphere(trans, 1.0, SURFACE_ID_BASE+4, objects[5]);
    
#ifdef BOX
    //box
    xvec = normalize(vec3(0.8, 0.0, -0.25));
    trans = createCS(	vec3(0.0, -0.5, -2.5),
                        xvec,
                  		vec3(0.0, 1.0, 0.0));
    createAABB( trans, -vec3(0.5), vec3(0.5), SURFACE_ID_BASE+5, objects[6]);
#endif
}

// Function 3146
float Intersect_Scene(
vec3 rp, vec3 rd,
out float t, out vec3 n, out vec3 a)
{
     float hit;
   
    {
    	vec2 tt; vec3 n0, n1;
		float th = Intersect_Ray_Cube(rp, rd, vec3(0.0, -0.8, 0.0), vec3(1.5, 0.05, 1.5), /*out:*/ tt, n0, n1);
      
        hit = th > 0.0 ? 1.0 : 0.0;
        t = tt.x;
        n = n0;
        a = MapColor(AlbedoPlane0);
        
        vec3 p = rp + rd * tt.x;
        if((p.x > 0.0) == (p.z > 0.0)) a = MapColor(AlbedoPlane1);
    }
    
    {
        vec2 tt;
		float th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 0.5, /*out:*/ tt);
        
        if(th > 0.0)
        if(hit <= 0.0 || tt.x < t)
        {
            t = tt.x;
            n = normalize(rp + rd * tt.x);
            a = MapColor(AlbedoSphere);
            
            hit = 1.0;
        }
    }
    
    return hit;
}

// Function 3147
vec3 torusKnotSqDistanceMinimumInside(vec3 p, TorusKnotParameters tkp)
{
    int sections = 1*int(max(tkp.kq,tkp.kp));
    float sectionLength = 2.*PI/float(sections);
    
    float lerningRate = 1./(max(tkp.kq,tkp.kp)-0.75);
    const int maxIterations = 900;//50
    
    float minDist;
    float bestT;
    
    for(int j = 0; j < sections; j++)
    {
        float t = sectionLength * float(j);
        bool failed = false;
        
        for(int i = 0; i < maxIterations; i++)
        {
            float dt = torusKnotSqDistanceDerivative(t, p, tkp);
            
            if(abs(lerningRate*dt) < 0.003)break;
            
            t -= lerningRate*dt;
            
            
            if(t != clamp(t, sectionLength * (float(j)-1.), sectionLength * (float(j)+1.)))
            {
                failed = true;
                break;
            }
        }
        if(failed)continue;
        
        float sqDist = torusKnotSqDistance(t, p, tkp);
        
        if(sqDist <= sq(tkp.r3))
        {
            return vec3(t, sqDist, 1.);
        }
    }
    
    return vec3(0.);
}

// Function 3148
vec2 GetSceneDistance( vec3 vPos )
{    
	vec3 vCandlestickLocalPos = vPos - vCandlestickPos;	

	vec2 vResult = vec2(1000.0, -1.0);
			
	vec2 vFloor = GetDistanceFloor(vPos);
	if(vFloor.x < vResult.x)
	{
		vResult = vFloor;
	}
	
	vec2 vCandle = GetDistanceCandle(vCandlestickLocalPos);
	if(vCandle.x < vResult.x)
	{
		vResult = vCandle;
	}
	
	
	vec2 vWick = GetDistanceWick(vCandlestickLocalPos);
	if(vWick.x < vResult.x)
	{
		vResult = vWick;
	}	

	vec2 vSolids = GetDistanceShadowCasters(vPos);
	if(vSolids.x < vResult.x)
	{
		vResult = vSolids;
	}	

	return vResult;
}

// Function 3149
float map( in vec3 pos )
{
    float a = 15.0;
    return 0.2 * sdSphere( pos, 1.3 )
                           + 0.03*sin(a*pos.x)*sin(a*pos.y)*sin(a*pos.z);
}

// Function 3150
float sdFlower(in vec2 p, in float c, in float a, in float f) {
    float ang = mod(atan(p.y, p.x) + PI / f, 2.0 * PI / f) - PI / f;
    p = vec2(cos(ang), sin(ang)) * length(p);
    p.y = abs(p.y);

    float t = 0.5 * PI / f;
    if (p.x < c - a && a < 0.5 * c) t *= 1.5;
    if (p.x > c + a) t = f < 4.0 ? 0.25 : 0.1;

    for (int n=0; n < 10; n++) { // 6 seems enough but 10 for extra precision
        vec3 r = vec3(c, 0.0, 0.0) + a * dCos(f * vec3(t, 1.0, 0.0));
        vec3 dx = dMul(dCos(vec3(t, 1.0, 0.0)), r) - vec3(p.x, 0.0, 0.0);
        vec3 dy = dMul(dSin(vec3(t, 1.0, 0.0)), r) - vec3(p.y, 0.0, 0.0);
        vec3 dist = dMul(dx, dx) + dMul(dy, dy);
        t -= dist.y / dist.z;
    }

    float r = c + a * cos(f * ang);
    return length(p - vec2(cos(t), sin(t)) * (c + a * cos(f * t))) * sign(dot(p, p) - r * r);
}

// Function 3151
void RaymarchScene(in Ray ray, inout RayHit hit)
{
    hit.hit = false;
    
    vec2 sdf   = vec2(FarClip, 0.0);
    vec3 hNorm = vec3(0.0);
    
    float depth = NearClip;
    
    for(int steps = 0; (depth < FarClip) && (steps < 80); ++steps)
    {
    	vec3 pos = ray.origin + (ray.direction * depth);
        
        hit.steepness = 0.0;
        hNorm         = Scene_Normal(pos, 0.0, hit);
        hit.steepness = smoothstep(0.75, 1.0, hNorm.y);
        
        sdf = Scene_SDF(pos, hit);
        
        if(sdf.x < Epsilon)
        {
            hit.hit       = true;
            hit.surfPos   = pos;
            hit.surfNorm  = Scene_Normal(pos, 1.0, hit);
            hit.depth     = depth;
            hit.heightmap = sdf.y;
            
            break;
        }
        
        depth += sdf.x;
    }
}

// Function 3152
float fSDF(vec3 posWS)
{
    vec4 mat;
    return fSDF(posWS, true, mat);
}

// Function 3153
float DistCombineSubtract( const in float v1, const in float v2 )
{
	return DistCombineIntersect(v1, -v2);
}

// Function 3154
vec3 getGradDist(vec3 pos,float eps)
{
    vec3 d=vec3(eps,0,0);
    return vec3(
        getDist(pos+d.xyz)-getDist(pos-d.xyz),
        getDist(pos+d.zxy)-getDist(pos-d.zxy),
        getDist(pos+d.yzx)-getDist(pos-d.yzx)
        )/eps/2.;
}

// Function 3155
float HexDist(vec2 p) {
	p = abs(p);
    
    float c = dot(p, normalize(vec2(1,sqrt3)));
    c = max(c, p.x);
    
    return c;
}

// Function 3156
vec2 distort(float x, float x2, float x3, float x4, float y, float y2, float y3, float y4) {
    return vec2(
        	        0.027935f +
            x*      1.095561f +
            y*      0.012740f +
            x2*    -0.039869f +
            x*y*    0.124914f +
            y2*     0.002292f +
            x3*    -0.292835f +
            x2*y*  -0.034783f +
            x*y2*  0.012176f + // un fisheye
            y3*     0.004875f +
            x4*   -0.036597f + // unsquish towards eyes
            x3*y*  -0.110877f +
            x2*y2* -0.043108f +
            x*y3*  -0.062561f +
            y4*     0.019749f
            ,       0.016951f +
            x*     0.042731f + // sad face
            y*      1.076121f +
            x2*     0.185902f +
            x*y*   0.060663f + // like looking at a plane side on
            y2*     0.029832f +
            x3*    -0.044401f +
            x2*y*  -0.349245f +
            x*y2*  -0.008731f +
            y3*    -0.212708f +
            x4*    -0.175194f +
            x3*y*  -0.064730f +
            x2*y2* -0.232783f +
            x*y3*   0.054503f +
            y4*    -0.127740f
	);
}

// Function 3157
vec2 dist(in vec3 p, in vec3 lcen, in vec3 ldir, in vec3 rcen, in vec3 rdir){    
    // some stars?
    vec2 d = vec2(dist1(p, vec3(0.1, 0.2, 0.3), 0.002), 3.0);
    upd(d, vec2(dist1(p, vec3(0.31, 0.41, 0.59), 0.002), 3.0));
    upd(d, vec2(dist1(p, vec3(0.27, 0.18, 0.28), 0.002), 3.0));

    // eyeball
    upd(d, vec2(min(dist1(p, lcen, 0.04), dist1(p, rcen, 0.04)), 0.0));

    // iris
    upd(d, vec2(min(dist1(p, lcen+ldir*0.03, 0.017), dist1(p, rcen+rdir*0.03, 0.017)), 1.0)); 

    // nose?
    vec3 c = (lcen+rcen)*0.5;
    vec3 e = normalize(cross(lcen-rcen, ldir+rdir));
    upd(d, vec2(dist1(p, c+e*0.06, 0.03), 2.0)); 

    return d;
}

// Function 3158
vec3 SceneNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.01, 0.0, 0.0 );
    vec3 nor = vec3(
        Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),
        Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),
        Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );
    return normalize( -nor );
}

// Function 3159
bool intersectHeightMap(vec3 ro, vec3 rd, float maxdist, const bool reflection, out float dist ) {
	float dt = 0.3;
	vec3 pos;
	dist = 0.0;
	bool hit = false;

	for( int i=0; i<MARCHSTEPS; i++) {
		if( hit || dist > maxdist ) break;
		
		dist += dt;
		dt = min( dt*1.1, 0.5 );
		pos = ro + rd*dist;
		if( heightMap( pos ) >= pos.y ) {
			hit = true;
		}
	}
	return hit;
}

// Function 3160
vec3 tonemapping(vec3 color)
{
    //Tonemapping and color grading
    color = pow(color, vec3(1.5));
    color = color / (1.0 + color);
    color = pow(color, vec3(1.0 / 1.5));

    
    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));
    color = pow(color, vec3(1.3, 1.20, 1.0));    

	color = clamp(color * 1.01, 0.0, 1.0);
    
    color = pow(color, vec3(0.7 / 2.2));
    return color;
}

// Function 3161
float GetDistanceWine( vec3 vPos )
{
    vec3 vLocalPos = vPos;
    vLocalPos.y -= 2.0;
    
    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);
    
    vec2 vSphOrigin = vec2(0);
    vec2 vSphPos = vPos2 - vSphOrigin;   
    
    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;
    
    vec3 vWaterNormal = vec3(0,1,0);
    
    vWaterNormal.x = sin( iTime * 5.0) * 0.01;
    vWaterNormal.z = cos( iTime * 5.0) * 0.01;
    
    vWaterNormal = normalize( vWaterNormal );
    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;
        
    return max( fBowlDistance, fWaterLevel );
}

// Function 3162
vec3 map( vec3 p )
{
    // hands
    float d = 1.0;
	if( p.x<-0.8 && p.y<-0.1)
	{
		vec3 hp = p - vec3(-0.9,-0.30,0.12);

		hp.z *= 1.2;
		
		float ss = sign(hp.y+0.05);

		vec4 a1 = vec4(-0.030+0.010*ss, -0.050 +0.050 *ss, 0.06, 0.0225);
		vec4 b1 = vec4(-0.070+0.010*ss, -0.049 +0.051 *ss, 0.05, 0.024);
		vec4 c1 = vec4(-0.145+0.015*ss, -0.0465+0.0535*ss, 0.01, 0.027);
		vec4 d1 = vec4(-0.12,           -0.0465+0.0535*ss,-0.06, 0.030);
		vec3 u1 = vec3(-0.0290+0.011*ss,-0.05  +0.05  *ss, 0.08);
		vec3 v1 = vec3(-0.0185,         -0.05  +0.05  *ss, 0.08);

		float dd =     sdCapsule( hp, a1, b1 ).x;
		dd = smin( dd, sdCapsule( hp, b1, c1 ).x, 0.005 );
		dd = smin( dd, sdCapsule( hp, c1, d1 ).x, 0.005 );
		dd = smax( dd,-sdCapsule( hp, u1, v1, 0.021 ),0.005);
		d = min( d, dd/1.2 );
		
		ss = sign(hp.y+0.1);
		
		if( hp.y>-0.1 )
		{
			const vec4 a2 = vec4(-0.02,-0.050, 0.06, 0.024);
			const vec4 b2 = vec4(-0.06,-0.050, 0.05, 0.0256);
			const vec4 c2 = vec4(-0.15,-0.050, 0.01, 0.0288);
			const vec4 d2 = vec4(-0.13,-0.050,-0.06, 0.032);
			const vec3 u2 = vec3(-0.018,-0.05,0.08);
			const vec3 v2 = vec3(-0.017,-0.05,0.08);

			dd =           sdCapsule( hp, a2, b2 ).x;
			dd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );
			dd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );
			dd = smax( dd,-sdCapsule( hp, u2, v2, 0.021 ),0.005);
		}
		else
		{
			const vec4 a2 = vec4(-0.07,-0.145, 0.06, 0.021);
			const vec4 b2 = vec4(-0.10,-0.145, 0.05, 0.0224);
			const vec4 c2 = vec4(-0.16,-0.145, 0.01, 0.0252);
			const vec4 d2 = vec4(-0.15,-0.145,-0.06, 0.028);
			const vec3 u2 = vec3(-0.07,-0.145,0.08);
			const vec3 v2 = vec3(-0.05,-0.145,0.08);

			dd =           sdCapsule( hp, a2, b2 ).x;
			dd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );
			dd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );
			dd = smax( dd,-sdCapsule( hp, u2, v2, 0.019 ),0.005);
		}
        d = min( d, dd/1.2 );
	}
    
	vec3 res = vec3(d,1.0,1.0);

    // nails
	{
		vec3 np = mat3(0.990,0.0,0.141,
					   0.000,1.0,0.000,
					   -0.141,0.0,0.990)*
					   (p-vec3(-0.9,-0.30,0.12));
		d =       sdEllipsoid(np, vec3(-0.025, 0.000,0.056), vec3(0.022,0.018,0.006) );
		d = min(d,sdEllipsoid(np, vec3(-0.025,-0.050,0.056), vec3(0.023,0.019,0.006) ));
		d = min(d,sdEllipsoid(np, vec3(-0.046,-0.100,0.053), vec3(0.022,0.018,0.006) ));
		d = min(d,sdEllipsoid(np, vec3(-0.073,-0.145,0.048), vec3(0.021,0.017,0.006) ));
		if( d<res.x ) res = vec3(d,9.0,1.0);
	}

	
    // board
	//if( p.x<-0.2 )
	{
	vec3 bp = p - vec3(-0.695,-1.5,0.1 );
    bp.x = 0.15 + sqrt( bp.x*bp.x+0.0002 );
	d = sdEllipsoid( bp, vec3(0.0),vec3(0.65,1.8,0.1) );
	if( d<res.x ) res = vec3(d,6.0,1.0);
	}
	
	return res;
}

// Function 3163
RaycastHit intersectScene(Ray ray) {
 
    RaycastHit sphere = intersectSphere(ray, vec3(0., .2 * sin(iTime * 3.), 1.), .6);
    RaycastHit plane = intersectPlane(ray, -1., vec3(0., 1., 0.));
    
    if(sphere.id == 0) {
     
        return sphere;
        
    }
    
    return plane;
    
}

// Function 3164
float euclidean_dist(vec2 uv) { //Same as "length()" function
    return sqrt(pow(uv.x,2.)+pow(uv.y,2.));
}

// Function 3165
vec2 Distort(vec2 p)
{
    float theta  = atan(p.y, p.x);
    float radius = length(p);
    radius = pow(radius, 1.3);
    p.x = radius * cos(theta);
    p.y = radius * sin(theta);
    return 0.5 * (p + 1.0);
}

// Function 3166
vec4 MyCubeMap_cube(vec3 ro, vec3 rd, vec3 pos, vec3 size)
{
    ro = ro-pos;
    float cullingDir = all(lessThan(abs(ro),size))?1.:-1.;
    vec3 viewSign = cullingDir*sign(rd);
    vec3 t = (viewSign*size-ro)/rd;
    vec2 uvx = (ro.zy+t.x*rd.zy)/size.zy; //face uv : [-1,1]
    vec2 uvy = (ro.xz+t.y*rd.xz)/size.xz;
    vec2 uvz = (ro.xy+t.z*rd.xy)/size.xy;
    if(      all(lessThan(abs(uvx),vec2(1))) && t.x > 0.) return vec4(t.x,(uvx+1.)/2.,0.5-viewSign.x/2.0);
    else if( all(lessThan(abs(uvy),vec2(1))) && t.y > 0.) return vec4(t.y,(uvy+1.)/2.,2.5-viewSign.y/2.0);
    else if( all(lessThan(abs(uvz),vec2(1))) && t.z > 0.) return vec4(t.z,(uvz+1.)/2.,4.5-viewSign.z/2.0);
	return vec4(2000.0,0,0,-1);
}

// Function 3167
float mapDist(vec3 c){
  Shape lobby = LincolnLobby(c);
  return lobby.dist;
}

// Function 3168
vec3 sceneNormal(vec3 p) {
	float d = sceneDistance(p);
    vec2 e = vec2(RAY_MARCH_CLOSE, .0);
    return normalize( d - vec3(
        sceneDistance(p-e.xyy),
        sceneDistance(p-e.yxy),
        sceneDistance(p-e.yyx))
    );
}

// Function 3169
float map5_perlin(vec2 p)  
{	
    float r = 0.;
    float s = 1.;
    float f = 1.;
    
    float w = 0.;
    for(int i = 0;i < 5;i++){
        r += s*noise_perlin(p*f); w += s;
        s /= 2.;
        f *= 2.;
    }
    return r/w;
}

// Function 3170
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, qtTxt, tro, trd, trdd, q, qt, ds;
  float dstTxt, dstBlk, dstObj, db, d, ang, angTxt, angRot, aTw, rad;
  int idT;
  fntSize = vec2 (1.7, 0.6);
  dstTxt = dstFar;
  tro = ro;
  trd = rd;
  rad = 6.;
  bCylRad = rad + 0.4 * fntSize.x;
  bCylHt = 1.4 * fntSize.y;
  dstObj = ObjRay (ro, rd);
  CylHit (ro, rd);
  if (dCylIn < dstFar) {
    angRot = 0.05 * pi * tCur;
    aTw = angRot;
    tro.xz = Rot2D (tro.xz, angRot);
    trd.xz = Rot2D (trd.xz, angRot);
    for (float k = 0.; k < 42.; k ++) {
      idTxt = int (k);
      ang = 2. * pi * (1. - k / 42.);
      qt = - rad * vec3 (sin (ang + vec2 (0., 0.5 * pi)), 0.).xzy;
      q = tro - qt;
      q.xz = Rot2D (q.xz, ang);
      q.yz = Rot2D (q.yz, ang + aTw);
      trdd = trd;
      trdd.xz = Rot2D (trdd.xz, ang);
      trdd.yz = Rot2D (trdd.yz, ang + aTw);
      db = BlkHit (q, trdd, fntSize.xxy * vec3 (0.5, 0.55, 0.55));
      if (db < dstFar) {
        d = db + ObjRayT (q + db * trdd, trdd);
        if (d < dstTxt) {
          dstTxt = d;
          qtTxt = qt;
          angTxt = ang;
          qnTxt = qnFnt;
          idT = idTxt;
        }
      }
    }
  }
  if (min (dstTxt, dstObj) < dstFar) {
    if (dstTxt < dstObj) {
      tro += dstTxt * trd;
      ds = tro - qtTxt;
      ds.xz = Rot2D (ds.xz, angTxt);
      ds.yz = Rot2D (ds.yz, angTxt + aTw);
      col = HsvToRgb (vec3 (mod (0.05 * tCur + ((idT > 25) ? 0.5 : 0.), 1.), 1., 1.));
      if (abs (ds.z) < 0.49 * fntSize.y) {
        vn = normalize (vec3 (qnTxt, 0.00001));
        col = mix (col, vec3 (1.), 0.7);
      } else {
        vn = vec3 (0., 0., sign (ds.z));
      }
      vn.yz = Rot2D (vn.yz, - angTxt - aTw);
      vn.xz = Rot2D (vn.xz, - angRot - angTxt);
      col = col * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +
         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
      col = mix (col, BgCol (reflect (rd, vn)), 0.7 - 0.5 * abs (dot (rd, vn)));
    } else if (dstObj < dstFar) {
      vn = ObjNf (ro + dstObj * rd);
      col = vec3 (0.5, 0.5, 0.6) * (0.2 + 0.8 * max (dot (ltDir, vn), 0.)) +
         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
    }
  } else col = BgCol (rd);
  if (dCylIn < dstFar) {
    col = mix (col,  vec3 (1.) * (0.2 + 0.8 * max (dot (ltDir, vnCylIn), 0.) +
       0.5 * pow (max (dot (normalize (ltDir - rd), vnCylIn), 0.), 32.)), 0.2);
    col = mix (col, BgCol (reflect (rd, vnCylIn)), 0.8 * pow (1. - abs (dot (rd, vnCylIn)), 5.));
  }
  return clamp (col, 0., 1.);
}

// Function 3171
vec3 HeatmapGradient(const in float value) 
	{
		return clamp((pow(value, 1.5) * 0.8 + 0.2) * vec3(smoothstep(0.0, 0.35, value) + value * 0.5, 
													  smoothstep(0.5, 1.0, value), 
													  max(1.0 - value * 1.7, value * 7.0 - 6.0)), 
					 0.0, 1.0);
	}

// Function 3172
float mapWalls( vec3 p )
{
    float angle = atan(p.z, p.x);
    float d1 = sdSphere(p, CAMDIST*1.4);
    float d2 = ((sin(angle*8.0)+1.0)*0.5)*0.5;
    float d3 = sin(p.y*1.0)*0.1;
    return polsmax(max(-d1, d2), d3, 0.3);//d2+d3;
}

// Function 3173
float approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {
  return length(get_distance_vector(b0-p, b1-p, b2-p));
}

// Function 3174
float VoronoiEdgeDist(vec3 p, float threshold, out vec3 color)
{
    vec3 local_p = fract(p); // range [0., +1.]
    
  	vec3 vector_to_closest;
    float min_dist = MAX_DIST;
    
    for (int x = -1; x <= 1; x++)
        for (int y = -1; y <= 1; y++)
            for (int z = -1; z <= 1; z++)
            {
                vec3 offset = vec3(x, y, z);
                vec3 id = floor(offset + p);

                vec3 local_center = R33(id);
                vec3 center = id + local_center;

                vec3 point_to_center = center - p;
                float dist = length(point_to_center);

                if (dist < min_dist)
                {
                    min_dist = dist;
                    color = R33(id);
                    vector_to_closest = point_to_center;
                }
            }

    
    min_dist = MAX_DIST;
    
    for (int x = -1; x <= 1; x++)
        for (int y = -1; y <= 1; y++)
            for (int z = -1; z <= 1; z++)
            {
                vec3 offset = vec3(x, y, z);
                vec3 id = floor(offset + p);
                
                vec3 local_center = R33(id);
                vec3 center = id + local_center;
                
                vec3 point_to_center = center - p;

                vec3 perpendicularToEdge = point_to_center - vector_to_closest;
                
                if (length(perpendicularToEdge) < 0.01)
                    continue;

                float distanceToEdge = dot(
                    (vector_to_closest + point_to_center) / 2.0,
                    normalize(perpendicularToEdge)
                );
                
                min_dist = min(min_dist, distanceToEdge);
            }

    return min_dist - threshold;
}

// Function 3175
float sdf_union(float a, float b)
{
    return min(a, b);
}

// Function 3176
float sphereSDF(vec3 samplePoint, Sphere sphere) {
    return length(samplePoint-sphere.center) - sphere.radius;
}

// Function 3177
float distanceToRoundRect(vec4 rectExtents,vec3 rectCenter,vec3 point) {
	vec3 tPoint = point-rectCenter;
	return(length(max(abs(tPoint)-rectExtents.xyz,0.0)) - rectExtents.w);
}

// Function 3178
float dist(vec2 uv,vec2 x)
{
	return length(uv-x*vec2(1.0,1.0/AR));
}

// Function 3179
vec2 map(vec3 o) {
    return _m(vec2(length(o)-1.,0.),vec2(o.y+1.,1.));
}

// Function 3180
vec2 map(in vec3 pos)
{
    float t;
    float tmin = 9999.0;
    float shmin;
    float sh;
    float f;
    vec3  v = vec3(0.0);
    
#ifdef PERFORMANCE
    
    #define updateClosestSH(shfunc, center) \
    	v = pos - center; \
        sh = shfunc(normalize(v).xzy); \
        t = length(v) - abs(sh); \
        f = step(t, tmin); \
        shmin = sh * f + shmin * (1.0 - f); \
    	tmin = min(tmin, t);
    
	updateClosestSH(y00 , vec3( 0.0*HSEP,  1.0*VSEP, 0.0));
    updateClosestSH(y11_, vec3(-1.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(y10 , vec3( 0.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(y11 , vec3( 1.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(y22_, vec3(-2.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(y21_, vec3(-1.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(y20 , vec3( 0.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(y21 , vec3( 1.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(y22 , vec3( 2.0*HSEP, -1.0*VSEP, 0.0));
    
#else
    
    #define updateClosestSH(l, m, center) \
    	v = pos - center; \
        sh = SH(normalize(v).xzy, l, m); \
        t = length(v) - abs(sh); \
        f = step(t, tmin); \
        shmin = sh * f + shmin * (1.0 - f); \
    	tmin = min(tmin, t);
    
	updateClosestSH(0, 0, vec3( 0.0*HSEP,  1.0*VSEP, 0.0));
    updateClosestSH(1,-1, vec3(-1.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(1, 0, vec3( 0.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(1, 1, vec3( 1.0*HSEP,  0.0*VSEP, 0.0));
    updateClosestSH(2,-2, vec3(-2.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(2,-1, vec3(-1.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(2, 0, vec3( 0.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(2, 1, vec3( 1.0*HSEP, -1.0*VSEP, 0.0));
    updateClosestSH(2, 2, vec3( 2.0*HSEP, -1.0*VSEP, 0.0));
    
#endif
    
    return vec2(tmin, shmin);
}

// Function 3181
Object map(vec3 p) {
    Object o = NewObject;
    
    vec3 q = p;
    
	float off = 20.;
    float sz = 40.;
    
    p.z += sz*0.25;
    
    p.x -= off;
    
    p.x += off*2.;
    
    p.z -= sz*.25;
    p.x -= off;
    
    o = omin(o,mapG(p));
    

    vec3 y = p;    
    p=abs(q);
    q = y;
    
    
    p.xz *= rot(0.125*pi);
    p.xz -= 0.5;
    
    q.xz *= rot(-0.25*pi);
    
    q.x = pmod(q.x, 0.5);
    q.z -= 1.2;
    o = omin(o,sdBox(q,vec3(0.2,15.,0.2)), 4.);
    
    
    o.didHit = true;
    o.d *= 0.6;
    return o;
}

// Function 3182
float distHeart(vec2 pos, float scale) {
	float amp = soundAmp3;

	float size = 1.0 * cos(amp);
	float sizePow = size < 0.0 ? 8.0 : 67.0;
	size = 0.7 + 0.3 * abs(pow(size, sizePow));
	pos /= (scale * size);

	pos.y -= 0.3;
	float xx1 = pos.x * 7.0;
	pos.y += 0.1 * cos(abs(xx1));
	float xx2 = max(0.0, 0.5 - abs(pos.x));
	pos.y += 0.5 * abs(xx2);
	float r = length(pos) * 3.0;

    return 1.0 - clamp(75.0 * (1.0 - r), 0.0, 1.0);
}

// Function 3183
float hmap(vec2 p) {
    return sin(p.x*.2)*1.6+cos(p.y*.5)+sin(p.y*.08)*2.3;
}

// Function 3184
float flowerSDF(vec2 st, int N) {
    st = st * 2. - 1.;
    float r = length(st) * 2.;
    float a = atan(st.y, st.x);
    float v = float(N) * .5;
    return 1. - (abs(cos(a * v)) * .5 + .5) / r;
}

// Function 3185
float map(vec3 p){
    
    // I'm never sure whether I should take constant stuff like the following outside the function, 
    // or not. My 1990s CPU brain tells me outside, but it doesn't seem to make a difference to frame 
    // rate in this environment one way or the other, so I'll keep it where it looks tidy. If a GPU
    // architecture\compiler expert is out there, feel free to let me know.
    
    const vec3 offs = vec3(1, .75, .5); // Offset point.
    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);
    const mat2 m = mat2(a.y, -a.x, a);
    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);
    const mat2 m2 = mat2(a2.y, -a2.x, a2);
    
    const float s = 5.; // Scale factor.
    
    float d = 1e5; // Distance.
    
    
    p  = abs(fract(p*.5)*2. - 1.); // Standard spacial repetition.
     
    
    float amp = 1./s; // Analogous to layer amplitude.
    
   
    // With only two iterations, you could unroll this for more speed,
    // but I'm leaving it this way for anyone who wants to try more
    // iterations.
    for(int i=0; i<2; i++){
        
        // Rotating.
        p.xy = m*p.xy;
        p.yz = m2*p.yz;
        
        p = abs(p);
        
  		// Folding about tetrahedral planes of symmetry... I think, or is it octahedral? 
        // I should know this stuff, but topology was many years ago for me. In fact, 
        // everything was years ago. :)
		// Branchless equivalent to: if (p.x<p.y) p.xy = p.yx;
        p.xy += step(p.x, p.y)*(p.yx - p.xy);
        p.xz += step(p.x, p.z)*(p.zx - p.xz);
        p.yz += step(p.y, p.z)*(p.zy - p.yz);
 
        // Stretching about an offset.
		p = p*s + offs*(1. - s);
        
		// Branchless equivalent to:
        // if( p.z < offs.z*(1. - s)*.5)  p.z -= offs.z*(1. - s);
        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);
        
        // Loosely speaking, construct an object, and combine it with
        // the object from the previous iteration. The object and
        // comparison are a cube and minimum, but all kinds of 
        // combinations are possible.
        p=abs(p);
        d = min(d, max(max(p.x, p.y), p.z)*amp);
        
        amp /= s; // Decrease the amplitude by the scaling factor.
    }
 
 	return d - .035; // .35 is analous to the object size.
}

// Function 3186
vec3 map_light_rgb(vec3 ro, vec3 rd, vec3 nrm) { 
    return map_light_pm(ro, rd);
}

// Function 3187
void mainCubemap( out vec4 fragColor, in vec2 p, in vec3 rayOri, in vec3 rayDir )
{
    //last frame
    vec4 last = T(p,0);
    
    //mouse position on cubemap
    vec2 m = viewportToCube(iMouse.xy);
    
    bool mouseCircle = (1.0-step(15.0/zoom,distance(m,p)))>0.5;
    
    bool space = texelFetch(iChannel2,ivec2(32, 0), 0).x > 0.0;
    bool shift = texelFetch(iChannel2,ivec2(16, 0), 0).x > 0.0;

    bool mask = mouseCircle && space;

    //clear space around ray origin
    if(distance(p,rayOrigin)<50.0/zoom)mask = false; 

    mask = mask || (last.r>0.5);
    
    //erase
    if(shift&&mouseCircle){mask = false;}
    
    //initial noise
    if(iFrame<25){
    
        mask = texture(iChannel3,p/1024.0).g+distance(p,rayOrigin)*0.0005<0.1;
        
        fragColor = vec4(mask,lods,1.0,1.0); return;
    }
    
    
    int largestEmptyLOD = lods;
    
    //find the largest empty LOD (one frame behind)
    for(int i = 0; i <= lods; i++){
    
        if(T(p,i).r>0.0){largestEmptyLOD = max(i-1,0); break;}
    }
    
    //the size of the largest empty LOD
    float size = exp2(float(largestEmptyLOD));
    
    
    // Output to cubemap
    fragColor = vec4(mask,size,1.0,1.0);
}

// Function 3188
float microfacetDistribution(vec3 toEye, vec3 reflectedRay, float roughness)
{
    float alpha = roughness * roughness;
    float dotER = dot(toEye, reflectedRay);
    float f = (dotER * alpha - dotER) * dotER + 1.;
    return alpha / (PI * f * f);
}

// Function 3189
float getUnitDistance(vec3 block, vec3 p)
	{
		vec3 	bumps1 		= fract(block*vec3(0.2342, 0.4564, 0.3342))*2.0,
				bumps2		= fract(block*vec3(-0.7432, 0.8788, 0.9453))*2.0,
				translation	= (fract(block*vec3(0.3450, 0.8342, -0.8324))*2.0-1.0)/1.5;
        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1);
        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);
	
		p = p + (fract(block*vec3(0.2334, 0.5365, 0.4353))*2.0-1.0)*4.0;

		float	s1 	= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,
				s2	= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;
        
		return  smin(s1, s2);
    }

// Function 3190
float SampleShadowMap(in vec2 shadowCoords)
{
    return texture(iChannel0, shadowCoords).r;
}

// Function 3191
vec3 LegDist( vec3 vPos, PoseLeg leg )
{    
    return Chain( 
        vPos,
        vec4(leg.vToe, g_scene.charDef.fToe),
        vec4(leg.vAnkle, g_scene.charDef.fAnkle),
        vec4(leg.vKnee, g_scene.charDef.fKnee), 
        vec4(leg.vHip, g_scene.charDef.fHip), 
        vec3(0.1, 0.4, 0.5 )
    );
}

// Function 3192
float map( vec3 p )
{
    vec3 w = p;
    vec3 q = p;

    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;
    
    float d = sdBox(q,vec3(1.0));
    float s = 1.0;
    for( int m=0; m<6; m++ )
    {
        float h = float(m)/6.0;

        p =  q - 0.5*sin( abs(p.y) + float(m)*3.0+vec3(0.0,3.0,1.0));

        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));

        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;

        d = max( c, d );
   }

    
   float d1 = length(w-vec3(0.22,0.35,0.4)) - 0.09;
   d = min( d, d1 );

   float d2 = w.y + 0.22;
   d =  min( d,d2);

    
   return d;
}

// Function 3193
float distanceToSegment( vec2 a, vec2 b, vec2 p )
{
	vec2 pa = p - a;
	vec2 ba = b - a;
    if(dot(a-b,a-b) == 0.0) return 1.0;
    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );
	return length( pa - ba*h);
}

// Function 3194
float distSmallHearts(vec2 pos) {
	float dis = 1.0;
	int i = 0;
	for (int i = 0 ; i < 32 ; ++i) {
		float ii = 6.28 * float(i) / 32.0;
		float jj = ii;
		float kk = 5.0 * ii;
		float x = cos(jj) + 0.15 * sin(kk + 8.0 * iTime);
		float y = 1.4 * sin(jj + 0.7 * iTime) + 0.35 * cos(kk + 5.4 * iTime);
		vec2 xy = 0.002 * halfRes * vec2(x,y);
		dis = min(dis, distHeart(pos + xy, 0.1));
	}
	return dis;
}

// Function 3195
float GetDist(vec3 p)
{

vec4 s=vec4(6,2,8,2);
vec3 b=vec3(-3,1.,8);
float bd=box(p-b,vec3(1.));
float sl=sphere(s,p);
float l = min(sl,p.y);
l=min(l,bd);
//l=sl;
return l;
}

// Function 3196
float heightmap(vec2 uv) {
    return .2 * moonTexture(uv).r;
}

// Function 3197
surface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {
    return surface_t(
        id,
        length(query_point)  - sphere_radius,
        normalize(query_point)
    );
}

// Function 3198
vec2 distBody( in vec3 p )
{
	float distXZ = length(p.xz) - REACTABLE_RADIUS;
		
	float screen = max(distXZ, abs(p.y) - REACTABLE_SCREENWIDTH);
	
	float borderXZ = abs(distXZ-REACTABLE_BORDER_SIZE)-REACTABLE_BORDER_SIZE;
	float border = max(borderXZ,abs(abs(p.y + REACTABLE_HEIGHT)-REACTABLE_HEIGHT) - (REACTABLE_SCREENWIDTH+REACTABLE_BORDER_HEIGHT));
	
	vec3 q = p;
	q.xz = abs(q.xz) - REACTABLE_LEG_AXE_DISP;
	q.y += REACTABLE_HEIGHT;
	float legs = distBox(q,vec3(0.05,REACTABLE_HEIGHT,0.05));
		
	//cloth
	vec3 q2 = p;
	q2.y += REACTABLE_HEIGHT;
	q2.y = abs(q2.y);
	float reduction = smoothstep(0.0,REACTABLE_HEIGHT,q2.y);
	float cloth = max(q2.y-REACTABLE_HEIGHT,distXZ + mix(0.15,0.0,reduction));
		
	float dist = min(cloth,min(min(screen,border),legs));
	float innerRadius = step(-EPSILON,distXZ);
	float mat = mix(mix(1.0,2.0,innerRadius),mix(0.0,1.0,innerRadius),step(-REACTABLE_BORDER_HEIGHT,p.y));
		
	return vec2(dist,mat);
}

// Function 3199
float DistanceYtoLine(vec2 u,vec2 m,vec2 n
){;m=m-n;;return (u.x-n.x)*m.y/m.x-u.y+n.y;}

// Function 3200
float SDF2(vec3 p){
    p *= 3.0;
	return 0.5 + SDF1(p/2.0+SDF1(p/5.0));
}

// Function 3201
vec2 DistanceToObject(vec3 p)
{
    vec2 distMat = sphereIter(p, 5.2 / outness, cut);
    return distMat;
}

// Function 3202
SDFResult torusSDF( Torus torus, vec3 p )
{
    p -= torus.pos;
    
	vec2 q = vec2(length(p.xz)-torus.ring,p.y);
	return SDFResult(length(q)-torus.radius, torus.matindex);
}

// Function 3203
float asteroidMapDetailed( const in vec3 p, const in vec3 id) {
    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;
    return d;
}

// Function 3204
float Mmap(in vec3 tex) {return 3.*(tex.r*tex.r		// Music map
    							  *(texelFetch(iChannel1,ivec2(1,0),0).x
                                  + texelFetch(iChannel1,ivec2(400,0),0).x))
    					;}

// Function 3205
float scene(vec3 pos)
{
    //float t = iTime;
    vec3 center = vec3(0.0,0.0,0.0);
    float radius = 1.5;
    
    float I = 0.0;
    for(int i=0;i<32;i++)
    {
        
        I += intensity(pos,center+3.0*random3(i),radius);
    }
    return I-0.5;
}

// Function 3206
vec3 ToneMap(vec3 inColor)
{
    inColor *= 1.0;  // Hardcoded Exposure Adjustment
    inColor = inColor/(vec3(1)+inColor);
    vec3 retColor = pow(inColor,vec3(1.0/2.2));
    return retColor;
    
    return inColor;
}

// Function 3207
float mapShell( in vec3 p, out vec4 matInfo ) 
{
    
    const float sc = 1.0/1.0;
    p -= vec3(0.05,0.12,-0.09);    

    p *= sc;

    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,
                   0.7738444477, -0.6034162289, 0.1924931824,
                   0.0081370606,  0.3133626215, 0.9495986813) * p;

    const float b = 0.1759;
    
    float r = length( q.xy );
    float t = atan( q.y, q.x );
 
    // https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/
    float n = (log(r)/b - t)/(2.0*pi);

    const float th = 0.11;
    float nm = (log(th)/b-t)/(2.0*pi);

    n = min(n,nm);
    
    float ni = floor( n );
    
    float r1 = exp( b * (t + 2.0*pi*ni));
    float r2 = r1 * 3.019863;
    
    //-------

    float h1 = q.z + 1.5*r1 - 0.5;
    float d1 = sqrt( (r1-r)*(r1-r) + h1*h1) - r1;
    float h2 = q.z + 1.5*r2 - 0.5;
    float d2 = sqrt( (r2-r)*(r2-r) + h2*h2) - r2;
    
    float d, dx, dy;
    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }
    else        { d = d2; dx=r2-r; dy=h2; }


    float di = texture( iChannel2, vec2(t+r,0.5) ).x;
    d += 0.002*di;
    
    matInfo = vec4(dx,dy,r/0.4,t/3.14159);

    vec3 s = q;
    q = q - vec3(0.34,-0.1,0.03);
    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;
    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);
    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );

    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );
    
    return d/sc;
}

// Function 3208
float map(vec4 p) {
    vec4 p2 = mod(p,4.0)-2.0;
    
    //float transition = clamp(abs(mod(iTime*0.2,2.0)-1.0)*5.0-2.0,0.0,1.0);
    //return min(box(p2,1.0-transition)-transition,length(abs(p2)-1.0)-0.5);
    //return box(p2,1.0-transition)-transition;
    return torus(p2,vec2(1.0,0.3));
}

// Function 3209
float distanceField(in vec3 p, out vec3 col, out float ref, out float trans, out vec3 absorb)
{
  int period = int(PERIOD);
  float i = 10000000.0;
  if (period == 0)      i = impulse1(p, col, ref, trans, absorb);
  else if (period == 1) i = impulse2(p, col, ref, trans, absorb);
  else if (period == 2) i = impulse4(p, col, ref, trans, absorb);
  else if (period == 3) i = impulse3(p, col, ref, trans, absorb);
  else if (period == 4) i = impulse2(p, col, ref, trans, absorb);
  else if (period == 5) i = impulse3(p, col, ref, trans, absorb);
  else if (period == 6) i = impulse2(p, col, ref, trans, absorb);
  else if (period == 7) i = impulse5(p, col, ref, trans, absorb);
  else if (period == 8) i = impulse1(p, col, ref, trans, absorb);

  float rc = sdRoundCube(p - vec3(0.0, -5.05, 0.0), 4.0);

  float d = min(rc, i);
  if (d == rc)
  {
    col    = vec3(1.0);
    ref    = 0.2;
    trans  = 0.0;
  }
  return d;
}

// Function 3210
vec2 map( in vec3 pos, bool showCylinder )
{
    const float rad = 0.9;

    // compute closest point to gPoint on the surace of the sphere
    vec3 closestPoint = closestPointToCyl(gPoint, vec3(0.0,0.,0.4),0.5);
    
    // point
    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );
    
    // closest point
    {
    float d = sdSphere( pos, closestPoint, 0.06 );
    if( d<res.x ) res = vec2( d, 4.0 );
    }
    
    // box (semi-transparent)    
    //if( ((samp.x+samp.y)&1)==0 )
    
    if( showCylinder )
    {
    float d = sdCylinder( pos, vec3(0.,0.,0.4),0.5);
    if( d<res.x ) res =  vec2( d, 5.0 );
    }

    // segment
    {
    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );
    if( d<res.x ) res =  vec2( d, 4.0 );
    }
    
    return res;
}

// Function 3211
vec3 Uncharted2ToneMapping(vec3 color) {
    
    float gamma = 2.2;
    
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 2.;
	color *= exposure;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
	color = pow(color, vec3(1. / gamma));
	return color;

}

// Function 3212
float scene( in vec3 p )
{
    // simple scene
    
    float f = p.y - (-2.0);
    
    f = min( f, length(fract(p.xz/20.0+.4)-.5)*20.0-.8 );
    f = min( f, length(fract(p.xz/31.0)-.5)*30.0-1.8 );
    f = max( f, p.y - 2.0 );
    
    f -= .2*pattern(p).a;
    
    return f;
}

// Function 3213
hit traceScene(in ray r) {
    //trace objects
    hit ret = trace(r, box1);
    ret = lt(ret, trace(r, pln1));
    ret = lt(ret, trace(r, sph1));
    ret = lt(ret, trace(r, sph2));
    ret = lt(ret, trace(r, lit1));
	//mirror normal if needed
    float nmod = step(dot(r.d, ret.n), 0.)*2.-1.;
    ret.n *= nmod;
    return ret;
}

// Function 3214
float circleDist(vec2 p, float radius)
{
	return length(p) - radius;
}

// Function 3215
vec2 MyCubeMap_faceToUV(MyCubeMap_FaceInfo info)
{
    const float freq = 2.5;
    info.id   += (info.id>=4.99 && info.uv.y>0.5)?1.:0.;
#if SEAMLESS
    const float eps = 0.003;
    bool bHalf = (info.id>5.99);
    if(bHalf)
    {
        info.uv.y -= 0.5;
		info.uv.y = min(info.uv.y,0.5-eps);
    }
    info.uv = min(info.uv,1.-eps);
    info.uv = max(info.uv,eps);
#else
    info.uv.y -= (info.id>5.99)?0.5:0.;
#endif    
    
    vec2 huv = vec2(info.uv.x+info.id,info.uv.y);
    huv.y = huv.y/freq+floor(huv.x/freq)/freq;
    return vec2(fract(huv.x/freq),huv.y);
}

// Function 3216
void map2(vec3 p){
    p.xz*=rz2(TAU*.25+sin(iTime*.2)*.5);
    p.xy*=rz2(.8);
    p.xz*=rz2(iTime*.5);
    float l=length(p.xz);
    float at=atan(p.z,p.x);

    float d=INF;
    
    for(int ri=0;ri<15;++ri){
        float RATIO=float(ri)/15.;
        float ANGLE=random(float(ri))*TAU;
        float SPANANGLE=2.0-RATIO*1.;
        float RADIUS=.1+.6*RATIO;
        float HEIGHT=mix(.8,1.,sqrt(RATIO));
        float OPENING=mix(-.1,.5,RATIO);
        
    	float a=amod(at-ANGLE,TAU);
        float dr=min(d,(abs(a)-SPANANGLE)*l);
        float r=atan(p.y*5.)*4./TAU*RADIUS;
        r+=smoothstep(HEIGHT-.5,HEIGHT+.5,p.y)*OPENING*RADIUS;
        dr=max(dr,-length(p.xz)+r);
        dr=max(dr,length(p.xz)-r-.02);
        dr=max(dr,max(p.y-HEIGHT+pow(a,2.)*.2,0.));
        d=min(d,dr);
    }
    
    d=max(d,max(-p.y,0.));
    M mleaves=M(d,PINK);
    
    d=length(p.xz)-exp(-pow(p.y-0.3,2.)*10.)*.3;
    d=max(d,-p.y-.2);
    d=smin(d,length(p.xz-vec2(pow(p.y+.2,2.)*.2,0.))-.03,.02);
    d=max(d,p.y-.2);
    d=max(d,-p.y-2.);
    
    for(int li=0;li<5;++li){
        float RATIO=float(li)/5.;
        vec3 q=p;
        q.x-=pow(q.y+.2,2.)*.2;
        q.y+=.4+float(li)*.3+random(float(li))*.05;
        q.yz*=rz2(-(p.y+.2)*.2);
        q.xz*=rz2(fract(sin(float(li)*13.+45.))*TAU);
        d=smin(d,leaf(q,.5+RATIO*.3),.08);
    }
    
    M mbulb=M(d,GREEN);
    
    m=mmin(mleaves,mbulb);
}

// Function 3217
float distanceFunc(float3 p, out float displace)
{	
	//float d = length(p) - _SphereRadius;	// distance to sphere
	float d = length(p) - (sin(iTime*0.25)+0.5);	// animated radius
	
	// offset distance with pyroclastic noise
	//p = normalize(p) * _SphereRadius;	// project noise point to sphere surface
	displace = fbm(p*_NoiseFreq + _NoiseAnim*iTime);
	d += displace * _NoiseAmp;
	
	return d;
}

// Function 3218
float sdf_5(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));
    return t;
}

// Function 3219
float sdf(vec3 p, out vec3 C, out float t_close)
{	
	float r=0.2;
	t_close = FindClosestPointOnSplineToPoint( p );
	C=GetPosOnSpline(t_close);
	float d = length(p-C)-r;
	
#if 0	
	vec3 b = SplineOrtho(t_close);
	vec3 n = normalize(p-C);
//	float v = acos(dot(b,n));
	d += sin(10.*acos(dot(b,n)))*0.04;
#endif
	
	return d;
}

// Function 3220
vec2 minSDF(vec2 sdf1, vec2 sdf2)
{
    return sdf1.x<sdf2.x ? sdf1 : sdf2;
}

// Function 3221
void Map_UpdateSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout int iSectorId )
{    
    if ( vPrev == vPos )
    {
        return;
    }
    
    if ( !Map_PointInSector( mapSampler, mapInfo, vPos, iSectorId ) )
    {
        int iNewSectorId = Map_SeekSector( mapSampler, mapInfo, vPos );
        
        if ( iNewSectorId != SECTOR_NONE )
        {
        	iSectorId = iNewSectorId;
        }                
    }
}

// Function 3222
float MapTopWing(vec3 p, float mirrored)
{    
  checkPos = p- vec3(1.15, 1.04, -8.5);
  pR(checkPos.xy, -0.15);  
  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));
  if (topWing<.15) //Bounding Box test
  {
    float flapDist = MapTailFlap(checkPos, mirrored);

    checkPos = p- vec3(1.15, 1.04, -8.5);
    pR(checkPos.xy, -0.15);  
    // top border    
    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));

    float flapCutout = sdBox(checkPos- vec3(0., -0.04, -1.19), vec3(0.02, .45, 1.0));
    // tailFlap front cutout
    checkPos = p- vec3(1.15, 2., -7.65);
    pR(checkPos.yz, 1.32);
    flapCutout=max(flapCutout, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));

    // make hole for tail flap
    topWing=max(topWing, -flapCutout);

    // front cutouts
    checkPos = p- vec3(1.15, 2., -7.);
    pR(checkPos.yz, 1.02);
    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 1.6)), 0.05);

    // rear cutout
    checkPos = p- vec3(1.15, 1., -11.25);  
    pR(checkPos.yz, -0.15);
    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);

    // top roll 
    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.3), 0.06)); 

    topWing = min(topWing, flapDist);
  }
  return topWing;
}

// Function 3223
vec3 shadeDistance(float d) {
    float dist = d*150.0;
    float banding = max(sin(dist), 0.0);
    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));
    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);
    
    vec3 color = vec3(pattern);
    
    if (d > 0.0) {
        //red tint
        color *= vec3(1.0,0.56,0.4);
    } else {
        //blue tint
        color *= vec3(0.4,0.9,1.0);
        
    }
    return color;
}

// Function 3224
float map(vec3 p, float SEA_TIME) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_GEOMETRY; i++) {        
    	d = sea_octave((uv+SEA_TIME)*freq,choppy);
    	d += sea_octave((uv-SEA_TIME)*freq,choppy);
        h += d * amp;        
    	uv *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 3225
float opRep_sceneT(vec3 p,vec3 c)
{
    vec3 q;
	q = mod(p+.5*c,c)-.5*c;
    return sceneT(q);
}

// Function 3226
float distfunc(vec3 pos, float ampenv)
{
    ampenv = ampenv*3.0;
    
    float val = sphere(pos, 4.0*ampenv);
    
   
    for(int i =0; i< numbloobs; i++)
    {
        if(float(i)<iTime)
        {
            
            float power = iTime - float(i);
            if(power>1.0)
                power = 1.0;
            
            
        	float a = iTime*0.001;
			float rad = float(i)/3.0+3.0;
        	rad = rad* ampenv*0.8;
        	float xang = texture(iChannel0, vec2(float(i)/30.0 + a,float(i)/20.0)).x;
        	float yang = texture(iChannel1, vec2(1.0 - float(i)/30.0,float(i)/20.0) + a).y;
        
        	float x = rad * cos(xang*6.28) * sin(yang*6.28);
        	float y = rad * sin(xang*6.28) * sin(yang*6.28);
        	float z = rad * cos(yang*6.28);

        	vec3 npos = vec3(x,y,z);
        
        	if(mod(float(i),2.0) == 0.0)
        		val = smin(val, sphere(pos+npos,2.0),boolbyness); //a positive edit
        	else
            	val = smax(-sphere(pos+npos,4.0),val,bloobyness); //a negative edit
        }
    }
    
 
    return val;
}

// Function 3227
float sdFoot(vec3 p) {
	float d = MAX_DIST;
	float bsd = length(p), bsr=0.2500;
	if (bsd > 2.*bsr) return bsd-bsr;
    
	vec3 cpFoot = p;
	{
		vec3 q = cpFoot;
#if SHOW_ANIM
        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;
#else
        float patapata = -.3;
#endif
        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));
        cpFoot=q;
	}
	vec3 cpFoot_Main = cpFoot;
	cpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);
	pElongate(cpFoot_Main.y, 0.0125);
	{
		vec3 q=cpFoot_Main;
        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));
        float ycl = smoothstep(.002,.2,q.y);
        float zcl = 1.-smoothstep(-.2,.5,q.z);
        float zcl2 = smoothstep(-.2,.0,q.z);
        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;
        cpFoot_Main=q;
	}

    // Shoe
    float d1,d2;
	d1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));
	d1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);
	d1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);
    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .001, d1, 0.0080);
	d1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);
	d1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);
	
	// Shoe lace
	d2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);
	d2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);
	d2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);
	d2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);
	d2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);
	
	return min(d1,d2);
}

// Function 3228
float get_distance_along_3d_line_nearest_to_point(
    in vec3 A0,
    in vec3 A,
    in vec3 B0
){
    return dot(B0 - A0, A);
}

// Function 3229
vec4 plotDistance(vec2 A, vec2 B, vec2 C, vec2 m, float rn, vec3 rt[3], vec2 fragCoord, float ss)
{
    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - m;
    vec2 p = fragCoord/iResolution.x;
    p = vec2(p.x*8. - .6, p.y*32. - 2.);
    if (p.x > 2. || p.y > 6.) return vec4(0);
    vec2 r = d + (c + b*p.x)*p.x;
    vec4 col = vec4(0);
    float w, alpha;
    if (rn < 1.5) {
        plotRoot(rt[0],m,p,ss,rcol3,col);
    } else {
        plotRoot(rt[0],m,p,ss,rcol0,col);
        plotRoot(rt[1],m,p,ss,rcol1,col);
        plotRoot(rt[2],m,p,ss,rcol2,col);
    }
    w = p.y-dot(r,r);
    w = smoothstep(fwidth(w)*1.5,0.,abs(w))*(1.-col.w);
    col += vec4(1)*w*.9;
    return col;
}

// Function 3230
vec2 map(vec3 p, vec3 ray_dir//use ray_dir for some optimizations
){vec2 res = vec2(OBJ_FLOOR, p.y)
 ;vec2 obj1 = vec2(OBJ_CEILING, 548.8 - p.y);if (obj1.y < res.y) res = obj1
 ;vec2 obj2 = vec2(OBJ_BACKWALL, 559.2 - p.z);if (obj2.y < res.y) res = obj2
 ;vec2 obj3 = vec2(OBJ_LEFTWALL, 556. - p.x);if (obj3.y < res.y) res = obj3
 ;vec2 obj4 = vec2(OBJ_RIGHTWALL      , p.x);if (obj4.y < res.y) res = obj4
 ;vec2 obj5 = vec2(OBJ_LIGHT, sdBox(p + vec3(-278, -548.8, -292), vec3(65, 0.05, 65)))
 ;if (obj5.y < res.y) res = obj5;vec2 obj6 = mapBlocks(p, ray_dir)
 ;if (obj6.y < res.y) res = obj6;return res;}

// Function 3231
float total_distance(vec3 p) {
	return level_distance(p);
}

// Function 3232
float triDist(vec3 p)
{
    float d=10000.;
    int triNum=int(getPixel(0).y);
    for(int i=0;i<TriPerFrame;i++)
    {
        int i3=-i*3;
        i3+=sort0+((iFrame*TriPerFrame)%triNum)*3;
        vec3 v1=getPixel(i3+0).xyz+vec3(1,0,1)*.0;
        vec3 v2=getPixel(i3+1).xyz+vec3(0,1,1)*.0;
        vec3 v3=getPixel(i3+2).xyz;
        d=min(d,udTriangle(p,v1,v2,v3));
    }
    return d;
}

// Function 3233
void mainScene(inout vec4 col, in vec2 sp ){
    
    float zoom = 1.;
    
    if (keyPress(32)) { zoom = 1./10.; } //SPACE
    if (keyPress(90)) { zoom = 2.0; } //Z
    if (keyPress(88)) { zoom = .5; } //X
    
    //viewport transformation matrix 
    mat3 screenToView = translate(-iResolution.xy / 2.0)*scale(zoom); 
    mat3 screenToView2 = translate(vec2(-iResolution.x / 2.0, -25))*scale(0.025); 
    
    //ui elements
    float ui = 0.;
    vec2 pt1 = controlPoint(1.0, vec2(-125, -40), screenToView, sp, col, ui);
    vec2 pt2 = controlPoint(2.0, vec2(-35, 122), screenToView, sp, col, ui);    
    vec2 pt3 = controlPoint(3.0, vec2(115, 40), screenToView, sp, col, ui);     
    
    float softness = slider(5.0, vec4(1, 0,10, .25), vec2(20, 240), sp, col, ui);
    float offset = slider(6.0, vec4(0, -5, 5, .25), vec2(20, 200), sp, col, ui);
    float width = slider(7.0, vec4(2.5, 0, 10, .25), vec2(20, 160), sp, col, ui);
    
  
    
    ///////////////// output /////////////////
    if(sp.y > 80.){ //viewport 1
        
        
        vec2 p = transform(sp.xy, screenToView);  //viewport pixel position
        // background     
        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient
        col.r -= .03*chessboard(p*.05); //grid2  
        
        // scene
        float lines = merge(dfLine(p, pt1, pt2), dfLine(p, pt3, pt2));
        float bz = usBezier(pt1, pt2, pt3, p);    
        float cc = dfCircle(p, 50.);

        col = mix(col, vec4(1.0, 0.7, 0.9, 1.0), stroke(cc, softness * zoom, offset * zoom, width * zoom));         
        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), stroke(bz, softness * zoom, offset * zoom, width * zoom)); 
        col = mix(col, vec4(0.2, 0.2, 0.2, 1.0), stroke(lines, zoom, .0, .5*zoom));
        
    }else if(sp.y > 5.){ //viewport 2    	
        vec2 p = transform(sp.xy, screenToView2);         
        col = vec4(0.5, 0.5, 0.5, 1.0) * (1.0 - length(iResolution.xy/2.0 - sp.xy)/iResolution.x); //gradient
        col.rgb -= .03*chessboard(p*.5); //grid2         
        
        float fn = stroke(p.x, softness, offset, width);
        float ln = p.y < fn ? -1. : 0.;
        col = mix(col, vec4(.4, 0.4, 0.4, 1.0), simpleFill(ln));
        col = mix(col, vec4(0.5, 0.7, 0.9, 1.0), 1.0-step(simpleFill(ln)*p.y,.0));
        col = mix(col, vec4(.3,.3,.3,1), hardFill(dfRoundedBox(p,vec2(.05,10), .0)));
        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(5,0),vec2(.025,10), .0)));
        col = mix(col, vec4(.2,.2,.2,1), hardFill(dfRoundedBox(p-vec2(-5,0),vec2(.025,10), .0)));
    }
    
    if(sp.y > 5.){ //draw only on non data area
        col = mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));
    }
}

// Function 3234
float map( in vec3 pos ) {
    float time = iTime * 3. ;
    vec3 q = pos + orbit(pos.x/10.+time, (pos.y*2.+time)/1., 1.);
    float d = fCapsule(q,vec3(10.,30.,-8.),vec3(-10.,10.,-5.),6.);
    q = pos + vec3(0.,10.,0.) + orbit(pos.x/10.+time, (pos.y+time)/1., 2.);
    pR(q.yz,1.2);
    d = fOpUnionRound(fTorus(q, 8.,20.),d,5.);
    return d;
}

// Function 3235
float sdf_b(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -6, 0)));
    return t;
}

// Function 3236
float GetSceneTime()
{
	#ifdef LIMIT_FRAMERATE
		return (floor(iTime * kFramesPerSecond) / kFramesPerSecond);
	#else
		return iTime;
	#endif
}

// Function 3237
vec4 dist_floorplates(vec3 pos) {
    pos+=vec3(0.5,0.0,0.5);
    vec3 offset = floor(pos+0.5);
    ivec3 gp = ivec3(int(offset.x),int(offset.y),int(offset.z));
    if (hash(gp) % 7 == 0 || 
        
        ((gp.y%3==0) && (gp.x % 5 == 0 || gp.z%10==0))) {
        pos = max(ORIGIN,abs(fract(pos + 0.5) - 0.5)-PLATE_SIZE);
    	return vec4(pos, length(pos));
    }
    return vec4(pos,3.0); // no ball here, fake it being elsewhere
}

// Function 3238
float RayMarchDist(vec3 ray_origin, vec3 ray_dir, float initial_dist, float iTime)
{
    float dist = initial_dist;
    
    for (int i = 0; i < MAX_STEPS; ++i)
    {
        vec3 p = ray_origin + ray_dir * dist;
        
        float nearest = GetSceneDist(p, iTime);
        
        if (nearest < MIN_DIST)
            break;
        
        dist += nearest;
        
        if (dist > MAX_DIST)
            break;
    }
    
    return dist;
}

// Function 3239
SDFResult sierSDF( vec3 p, int matindex, float time )
{
    mat3 rot = rotationmatrix(vec3(time, time*1.1, time*1.22));
    vec3 va = rot * g_va * 0.7;
    vec3 vb = rot * g_vb * 0.7;
    vec3 vc = rot * g_vc * 0.7;
    vec3 vd = rot * g_vd * 0.7;
    
    p -= vec3(2.0, 1.9, 2.0);
    
    if (length(p) > 1.2)
        return SDFResult(TOO_FAR, matindex);
    
	float a = 0.0;
    float s = 1.0;
    float r = 1.0;
    float dm;
    vec3 v;
    for( int i=0; i<6; i++ )
	{
	    float d, t;
		d = dot(p-va,p-va);              v=va; dm=d; t=0.0;
        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }
        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }
        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }
		p = v + 2.0*(p - v); r*= 2.0;
	}
	
	return SDFResult(((sqrt(dm)-1.0)/r), matindex);
}

// Function 3240
float scene2(vec3 p)
{
	return opRep_scene1(p,vec3(10.0));
}

// Function 3241
float dist_to_line(vec2 p, vec2 a, vec2 b)
{
    vec2 l = normalize(b-a);
    return length((a-p) - dot((a - p), l) * l);    
}

// Function 3242
vec2 map( in vec3 p )
{
    vec2 res = vec2(1000.0,-1.0);
	vec3  po =vec3(0.0,0.0, 8.0);
	
    // terrain
	float h = terrain( p.xz );
	float dd = (p.y - h);
	
    res = vec2(dd, 0.0 );
    
    //monoliths  
    float dis = sdBox(p-po*2.0, vec3(1.0,12.0,2.0));
    if(dis< res.x)
        res = vec2(dis, 3.0);

    dis = sdBox(p-po, vec3(1.0,12.0,2.0));
    if(dis< res.x)
        res = vec2(dis, 3.5);
    
    dis = sdBox(p, vec3(1.0,12.0,2.0));
    if(dis< res.x)
        res = vec2(dis, 4.0);
    
    dis = sdBox(p+po, vec3(1.0,12.0,2.0));
    if(dis< res.x)
        res = vec2(dis, 4.5);
    
    dis = sdBox(p+po*2.0, vec3(1.0,12.0,2.0));
    if(dis< res.x)
        res = vec2(dis, 5.0);
	

    return res;
}

// Function 3243
float map(vec3 p) {
    return length(p) - .5;
}

// Function 3244
float sdfSphere(in vec3 p, in float r)
{ return length(p) - r; }

// Function 3245
vec2 map( in vec3 pos )
{
  vec3 r1, r2;

//vec2 res = vec2 (sdPlane1(pos), 1.0);
  vec2 res = vec2 (sdPlane(pos, vec4(0,1,0,0)), 1.0);

  //---0---

  res = opU(res, vec2( sdWaveSphere ( pos-p01, 0.18 , 10, sinTime*0.4), 99));

                                    r1 = rotateY (pos-p02, aTime*0.5);
  res = opU(res, vec2( sdDodecahedron(r1, 0.2), 55));

                                    r1 = rotateX (pos-p03, sinTime*0.8);
  res = opU(res, vec2( sdIcosDodecaStar(r1, 0.18), 177));

                                    r1 = rotateZ (pos-p04, sinTime*0.8);
  res = opU(res, vec2( sdIcosahedron(r1, 0.16), 222));

                                    float h1 = 0.2 + 0.1 * abs(sinTime);
//  res = opU(res, vec2( sdPyramid4  (pos-p05, vec3(0.8,0.6,h1) ), 8));
  res = opU(res, vec2( sdPyramid  (pos-p05, h1 ), 8));

  //---1---
                                    r1 = rotateY (pos-p11, aTime*0.5);
  res = opU(res, vec2( sdTrianglePrism( r1, 0.1*sinTime + 0.25, 0.05 ), 44));

                                    r1 = rotateX (pos-p12, sinTime*0.8);
  res = opU(res, vec2( sdCone      (r1, vec3(0.8, 0.5+0.2*sinTime, 0.3)), 222));

  res = opU(res, vec2( sdBlob      (pos-p13, -0.5 - 0.45*sinTime ), 244));

                                    h1 = 0.2 + 0.06 * sinTime;
  res = opU(res, vec2( sdCylinder  (pos-p14, vec2(0.1, h1) ), 130));

               vec3 a = vec3( 0.1, 0.0, 0.0);  float sr1 = 0.1+0.05*sinTime;
               vec3 b = vec3(-0.1, 0.3, 0.1);  float sr2 = 0.05;
  res = opU(res, vec2( sdRoundCone( pos-p15, a,b, sr1,sr2), 51.7));

  //---2---

  res = opU(res, vec2( CrossInSphere ( pos-p21, 0.2+0.05*sinTime, 0.05), 51));

                                    r1 = p22 + rotateY (vec3(-0.22, 0, 0), aTime);
                                    r2 = p22 - rotateY (vec3(-0.22, 0, 0), aTime);
  res = opU(res, vec2( sdCapsule   (pos, r1, r2, 0.1), 32));

                                    r1 = vec3( 0.0, 0.1 + 0.1 * sinTime, 0.0);
  res = opU(res, vec2( sdSphere    (pos-p23-r1, 0.25), 111));

  res = opU(res, vec2( sdBox       (pos-p24, vec3(0.20)), 3));

  res = opU(res, vec2( sdEgg1      (pos-p24-r1, 0.21), 47));

  res = opU(res, vec2( sdEgg2      (pos-p25, 0.18+h1), 47));

  //---3---
  res = opU(res, vec2( sdBoxMinusSphere (pos-p31, 0.25), 13));

                                    r1 = rotateX (pos-p32, aTime*0.5);
  res = opU(res, vec2( sdHexagonalPrism ( r1, 0.25, 0.05 ), 17.0));

                                    r1 = rotateX (pos-p33, sinTime*1.2);
                                    r1 = rotateZ (r1, aTime*2.0);
  res = opU(res, vec2( sdTorus(     r1, vec2(0.20, 0.05) ), 25.0));

  res = opU(res, vec2( udRoundBox(  pos-p34, vec3(0.12), 0.05+0.05*+sinTime), 77));

  res = opU(res, vec2( sdBallyBall ( pos-p35), 65.0));

  //---4---

  res = opU(res, vec2( sdTwistedTorus( pos-p41, 6.0*sinTime ), 46.7));

                                    r1 = rotateY (pos-p42, aTime*0.25);
  res = opU(res, vec2( sdTorus88(   r1, vec2(0.20, 0.05) ), 43.0));

  res = opU(res, vec2( sdTorus82(   pos-p43, vec2(0.20-0.05*sinTime, 0.05)), 77.0));

  res = opU(res, vec2( sdRackWheel( pos-p44 ), 51));

                                    r1 = rotateY (pos-p45, aTime*0.25);
  res = opU(res, vec2( sdCylinder6( r1, vec3(0.1, 0.05, 0.25) ), 12));

  return res;   // return x=distance, y=color id
}

// Function 3246
vec2 distance_to_obj(in vec3 p)
{
    float power = (sin(iTime * 0.1 + 40.0) + 1.0) * 0.5 * 12.0 + 1.0;
  	return obj_union(obj_floor(p), obj_mandel(p / 3.0, power));
}

// Function 3247
maybe_float get_distance_along_3d_line_to_capped_cone(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in float r1,
    in float r2
){
    float dh = length(B2 - B1);
    float dr = r2 - r1;
    float rmax = max(r2, r1);
    float rmin = min(r2, r1);
    float hmax = rmax * dr / dh;
    float hmin = rmin * dr / dh;
    vec3 B = sign(dr) * normalize(B2 - B1);
    vec3 Bmax = (r2 > r1? B2 : B1);
    vec3 B0 = Bmax - B * hmax;
    vec3 Bmin = Bmax - B * hmin;
    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);
    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);
    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));
    float c_h = dot(A0 + cone.value * A - B0, B);
    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;
    cone = get_distance_along_line_to_union(cone, end1);
    cone = get_distance_along_line_to_union(cone, end2);
    return cone;
}

// Function 3248
ComplexMatrix2 M_mapTripleTo01I(Complex z0, Complex z1, Complex z2)
{
    return ComplexMatrix2(
        z0 - z2,
        z0 - z1,
        H_multiply(-z1, z0 - z2),
        H_multiply(-z2, z0 - z1));
}

// Function 3249
float sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }

// Function 3250
float map( in vec3 p )
{
    // triangle	
	vec3 v1 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );
	vec3 v2 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );
	vec3 v3 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );
	float d1 = udTriangle( v1, v2, v3, p ) - 0.01;

    // ground plane
	float d2 = p.y + 1.0;

    return min( d1, d2 );	
}

// Function 3251
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 vn, col;
  float dstObj;
  cvWid = mix (0.15, 0.05, smoothstep (10., 30., cvOrd));
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    col = vec3 (0.3, 0.3, 0.6);
    col *= 0.2 + 0.8 * max (dot (vn, ltDir), 0.) +
       0.2 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);
    col = mix (col, BgCol (reflect (rd, vn)), 0.5);
  } else col = vec3 (0.6, 0.8, 0.9);
  return clamp (col, 0., 1.);
}

// Function 3252
float sdf_seriffed_box(vec2 uv, vec2 origin, vec2 size, vec2 top_serif, vec2 bottom_serif)
{
    float h = clamp((uv.y - origin.y) / size.y, 0., 1.);
    float xmul = h < bottom_serif.y ? mix(1.+bottom_serif.x, 1., sqrt(1.-sqr(1.-(h/bottom_serif.y)))) :
    		h > (1.-top_serif.y) ? 1.+top_serif.x*sqr(1.-(1.-h)/(top_serif.y)) :
            1.;
    return sdf_centered_box(uv, vec2(origin.x, origin.y+size.y*.5), vec2(size.x*xmul*.5, size.y*.5));
}

// Function 3253
float dist(vec2 p, vec2 posA, vec2 posB) {
    vec2 dir = posA - posB;
	float dirLen = length(dir);
	vec2 dirN = normalize(dir);
	float dotTemp = clamp(dot(p - posB, dirN), 0.0, dirLen);
	vec2 proj = dotTemp * dirN + posB;
	return distance(p, proj);
}

// Function 3254
bool shadowRaySceneIntersection( in Ray ray, in float distMin ) {
    
}

// Function 3255
float mapSceneMesh(in vec3 p) {
    vec3 cell = floor(p / res) * res;
    vec3 local = fract(p / res);

    float ldb = mapScene(cell);                           // Left, Down, Back
    float rdb = mapScene(cell + vec3(res.x, 0.0, 0.0));   // Right, Down, Back
    float ldf = mapScene(cell + vec3(0.0, 0.0, res.z));   // Left, Down, Front
    float rdf = mapScene(cell + vec3(res.x, 0.0, res.z)); // Right, Down, Front
    float lub = mapScene(cell + vec3(0.0, res.y, 0.0));   // Left, Up, Back
    float rub = mapScene(cell + vec3(res.xy, 0.0));       // Right, Up, Back
    float luf = mapScene(cell + vec3(0.0, res.yz));       // Left, Up, Front
    float ruf = mapScene(cell + res);                     // Right, Up, Front

    return mix(mix(mix(ldb, rdb, local.x),
                   mix(ldf, rdf, local.x),
                   local.z),

               mix(mix(lub, rub, local.x),
                   mix(luf, ruf, local.x),
                   local.z),

               local.y);
}

// Function 3256
maybe_vec2 get_distances_along_3d_line_to_sphere(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in float r
){
    float xz = dot(B0 - A0, A);
    float z = length(A0 + A * xz - B0);
    float y2 = r * r - z * z;
    float dxr = sqrt(max(y2, 1e-10));
    return maybe_vec2(
        vec2(xz - dxr, xz + dxr), 
        y2 > 0.
    );
}

// Function 3257
float mapCar(in vec3 p0){ 
	vec3 p=p0+vec3(0.0,1.24,0.0);
	float r=length(p.yz);
	float d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;
	d=max(d,p.z-1.0);
	p=p0+vec3(0.0,-0.22,0.39);
	p.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);
	r=length(p.yz);
	d=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);
	d=max(d,-max(p.x-0.165,r-0.24));
	float d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;
	d=min(d,d2);

	return d;
}

// Function 3258
float distSphere(vec3 p, float size)
{
    return length(p) - size;
}

// Function 3259
vec3 ArmDist( vec3 vPos, PoseArm arm )
{
    return Chain( 
        vPos,
        vec4(arm.vShoulder, g_scene.charDef.fShoulder), 
        vec4(arm.vElbow, g_scene.charDef.fElbow), 
        vec4(arm.vWrist, g_scene.charDef.fWrist),
        vec4(arm.vHand, g_scene.charDef.fHand),
        vec3(0.5, 0.4, 0.1 )
    );    
}

// Function 3260
Surface map(vec3 p){
  vec3 now = mod(vec3(iDate.w)/vec3(3600,60,1),hmsUnit);
  vec3 idx = floor(mod(vec3(1.-atan(p.z,p.x)/P2)*hmsUnit-.5,hmsUnit));
  vec3 hmsFlag = clamp(now-idx,0.,1.);
  float s12 = clamp(mod(now.z/5.+6.,12.)-idx.x,0.,1.);

  vec3 hcol = _rgb(vec3(idx.x/12.,hmsFlag.x*.6,.9));
  vec3 mcol = _rgb(vec3(idx.y/60.,hmsFlag.y*.3,.9));
  float sm = mod(now.z-idx.y,60.), ism=1.-(sm-1.)/59.;
  vec2 sp = (sm<1.)?vec2(sm,esBounce(sm)):vec2((1.-cos(ism*PI))*.5,(3.+cos(ism*P2))*.25);
  vec3 spos = vec3(6.*sp.x,sp.y*2.8-3.0,0);
  vec3 ms = vec3((1.-hmsFlag.x)*((cos(s12*P2)+1.)*.45+.1),1.25-cos(s12*PI)*2.,0);

  if (iMouse.z > .5) {
    ms.xy = clamp(iMouse.yx/iResolution.yx*1.4-0.2,vec2(0),vec2(1));
    hcol = _rgb(vec3(idx.x/12.,.6,.9));
  }
  mat3 mat = _pmat(ms*PI*vec3(41./180.,2,1));
  vec3 ri = vec3(2.4,2.425,2.45);
  vec3 pos = vec3(2,1.0,2);
  vec3 fcl = textureLod(iChannel1,p.xz*0.1,0.).rgb*(_checker(p.xz,vec2(2.5))*.5+.2);
  return near(
    Surface(dfBox(p-vec3(0,-.52,0), vec3(10,0,10), .5), fcl, vec3(0), vec3(.2), vec3(0)), 
    near(
      Surface(dfBC(repC_XZ(p,7.2,12)*mat+vec3(0,-.86,0), 1.0), vec3(0), hcol, vec3(rr2rl(ri.x)), ri),
      Surface(dfDdc(repC_XZ(p,9.5,60)+spos, 0.2), vec3(0), mcol, vec3(rr2rl(ri.x)), ri)
    )
//    Surface(dfBC(repC_XZ(p,8.,12)*m+vec3(5.,-.86,0), 1.0), col*.1, vec3(0), vec3(.9), ri)
  );
}

// Function 3261
float torusKnotLineSqDistance(float t, Ray ray, TorusKnotParameters tkp)
{
    //|d| = 1
    
    //a^2 = c^2 - b^2
    //a^2 = c^2 - (b/c * c)^2
    //a^2 = c^2 - (cos() * c)^2
    
    return torusKnotSqDistance(t, ray.ro, tkp) - sq(dot(torusKnot(t, tkp) - ray.ro, ray.rd));
}

// Function 3262
void RenderScene(vec3 camPos, vec3 rayVec, inout vec3 finalColor, bool cinematicHack)
{
	RayHit ray = RayTraceScene(camPos, rayVec, 176, cinematicHack);

    if (ray.tMin != bignum)
    {
        // calculate the reflection vector for highlights
        vec3 ref = normalize(reflect(rayVec, ray.normMin));
        vec3 refColor = GetEnvColor2(camPos, ref, vec4(bikeAPos, bikeAAngle), cinematicHack) * 1.5;

        RayHit refRay = RayTraceScene(ray.hitMin + ref*0.01, ref, 16, cinematicHack);
        
        vec3 texColor = CalcTexColor(ray, camPos);
        vec3 lightColor = vec3(1.0) * (saturate(ray.normMin.y *0.5+0.5))*1.25;
        finalColor = texColor * lightColor;
        float fresnel = saturate(1.0 - dot(-rayVec, ray.normMin));
        fresnel = mix(0.5, 1.0, fresnel);
        if ((ray.material == 256.0) && (ray.normMin.y == 1.0)) refColor *= vec3(1.0, 0.5, 0.2)*3.0*dot(ray.normMin, -rayVec);
        finalColor += refColor * fresnel * 0.4;
        // fog
		finalColor = mix(vec3(1.0, 0.41, 0.41) + vec3(1.0), finalColor, exp(-ray.tMin*0.0007));
        if (cinematicHack) {
            // fog the bike as it drives into the distance
            vec3 backCol = texture(iChannel3, RotateZ(rayVec, 0.0)).xyz;
            finalColor *= (rayVec.y * 0.5 + 0.5);
            finalColor = mix(finalColor, backCol, saturate(-bikeAPos.x*0.01));
            // Fade towards bottom so shadow matches photo better
        }

        if (refRay.tMin != bignum) {
	        vec3 refTexColor = CalcTexColor(refRay, camPos);
            finalColor = mix(finalColor, refTexColor, 0.1);
        }
    } else {
        finalColor = GetEnvColor2(camPos, rayVec, vec4(bikeAPos, bikeAAngle), cinematicHack);
    }
    //finalColor = vec3(0.03)*ray.tMin;

/*    if (ray.tMin != bignum)
    {
        finalColor = ray.normMin * 0.5 + 0.5;
	    finalColor.r += pow(sin(ray.hitMin.x*32.0)*0.5+0.5, 64.0);
	    finalColor.g += pow(sin(ray.hitMin.y*32.0)*0.5+0.5, 64.0);
	    finalColor.b += pow(sin(ray.hitMin.z*32.0)*0.5+0.5, 64.0);
        finalColor *= 0.01;
        finalColor.b += ray.hitMin.z*ray.hitMin.z*0.05;
    }*/

}

// Function 3263
float seg_dist(vec2 ba, vec2 pa) {
    float u = clamp(dot(ba,pa)/dot(ba,ba), 0.0, 1.0);
    return length(pa-u*ba);
}

// Function 3264
ctx scene(ctx i) {
    vec3 p = i.point;
        
	//star cluster base cloud
    i.distance_ = max(-(length(p-vec3(0.,0.,-20.))-30.),max(0.,udBox(p, vec3(100.,100.,50.)-10.)-10.));
	i.color = 0.8+0.2*cos(vec3(.2,0.,.9284)*6.+abs(p.yzx*.1)+sin(p*0.034+vec3(.1,.3,2.)*20.834)*64.+cos(p.zxy)*1.1268);//random coloring
    i.deformAmount = 0.7;
    i.deformScale = 10.;
    i.deformRoughness = 0.2;
    i.fluff = 0.94;
    //random emissive points
    float em = (max(0.,hash3(floor(abs(p)/1.)*4.112773)-0.9995)/(1.-.9995))*(1.-length(fract(abs(p))-.5)/0.86602)+
        	   (max(0.,hash3(floor(abs(p)/20.)*7.812773)-0.91)/(1.-.91))*max(0.,1.-length(fract(abs(p/20.))-.5)/0.56602)*0.5;
	i.emission = em*5.;
    i.density = .3+em;
    
    
    //imploded star swirls
    vec3 cp = p-vec3(0.,0.,20.);
    float s = 2.;
    vec2 id = vec2(0.);
    if (length(cp.xy) > 25.) {
        id = floor((cp.xy+50.0)/50.0)*0.1912485;
        cp.xy = abs(abs(cp.xy)-50.0)+vec2(hash(id.y)-0.5,hash(id.x)-0.5)*50.0;
        s = 0.5;
    }
    cp.xy = rot(cp.xy, pow(length(cp.xy)/.25,1./(1.8+cos(length(id)*6.19284)*0.2))+length(id)*10.9187);
    float dst = udBox(cp, vec3(40.*s,0.05,30.))-1.;
    i.distance_ += max(0.,5.*s-dst);
    if (i.distance_ > dst-5.*s) {
        if (s < 1.) i.distance_ = dst;
        i.emission = s*50.0*max(0.,length(i.color)/1.74-.9);
        i.color = vec3(254, 247, 223)/255.;
        i.deformAmount = 0.05;
    } else {
        i.deformAmount = 0.7-max(0.,.7-max(0.,dst)/5.);   
    }
    
    
    return i;
}

// Function 3265
vec2 map( in vec3 p )
{
    // box
    float d = sdBox( p, vec3(1.0) );

    // fbm
    vec2 dt = sdFbm( p+0.5, d );

    dt.y = 1.0+dt.y*2.0; dt.y = dt.y*dt.y;
    
    return dt;
}

// Function 3266
float map_table(vec3 pos)
{
    #ifdef show_table
    pos = rotateVec2(pos);
    #ifdef show_plate
    pos.y+= 1.233 + plateThickness*2.;
    #else
    pos.y+= 1.201;
    #endif
    
    float df = sdCylinder(pos, vec2(7., 0.2));
    
    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    
    return df;
    
    #else
    return 10.;
    #endif
}

// Function 3267
vec4 mapCE(vec3 p, vec3 nor)
{
    vec4 mat;
    p -= drone.xyz;
	p = rot3DXY(p, droneRots.xy);

    const vec4 gunMetal = vec4(.05, .05, .05,.3);
    vec4 body     = vec4(.8, .8, .8,.4);
   
    float dirt1 = smoothstep(-.1, .5,boxMap(iChannel1,p, nor))*.25+.75;
    mat = body*dirt1;
  
    float d = sphere(p+vec3(0,0,.5), 8.9);
    float d2;
    d = max(d, roundedBox(p, vec3(6., 12, 11.0), .72)); 
    if (d < .0 || p.z > 14.5)
    {
        d = sphere(p-vec3(-3.3 , 1.8, -8.1), .9);
        d2 = sphere(p-vec3(3.1 , 1.7, -8.1), .5);
        // EyeCam...
	    if (d < 0.0)
        {
            mat = vec4(1., 0.03, 0.0, .7);
            emitionType = 1;
        }else
		// Scanner...
       	if (d2 < 0.0)
       	{
            d2 = d2 < -.015 ? max(-circle(mod(p.xy-vec2(3.185 , 1.78), .16)-.08, .085)*35.0, 0.0): 1.0;
			mat = vec4(.2+scannerOn*.6, 0.2+scannerOn*.75, 0.2+scannerOn, .7*d2)*d2;
            
			emitionType = 2;
      	}
        else
	        mat = numbers(gunMetal, p.xy);
        // Do hex border line around numbers...
        p = abs(p);
        mat = p.x > p.y*.76 ? mix(mat, vec4(0.0), bumpstep(2.3, 2.4, p.x+p.y*.5)):mix(mat, vec4(0.0), bumpstep(1.82, 1.92, p.y));
        return mat;
    }

     // Gun placements and carriers...
    vec3 v = p;
    
   	//v.yz = rot2D(p.yz, gunMovement.x);
	v =abs(v)-vec3(gunMovement.x, .0, 0.) ;
    v.x -= p.z*.1*gunMovement.y;
	d2 = sphere(v, 10.0);
    d2 = max(d2, -roundedBox(v, vec3(6.55, 12, 4.0), 1.1)); 
    
    d = min(d2, d);
    d2 = min(d,	roundedBox(v-vec3(5.5, 3.5, 3.5), vec3(2.3, .1, .1), .4));
    //d2 = min(d2,roundedBox(v-vec3(5.5, .0, 3.7), vec3(2.3, .1, .1), .4));
    d2 = min(d2, sphere(v-vec3(5., .0, 3.7), 3.8));
    if(d2 < d) mat = vec4(.0, .0, .0, 6.);
    //return mat;
    
    v = vec3(abs(p.x)-gunMovement.x, p.yz);
    v.x -= p.z*.1*gunMovement.y;
    float dirt = (smoothstep(-.1, .5,boxMap(iChannel1,v, nor))*.2+.8);
    body = body * dirt;
 
    v = vec3(abs(p.xy)-vec2(gunMovement.x, .0), p.z);
    v.x -= p.z*.1*gunMovement.y;
    
    if ( v.x > 7.4)  mat =mix(body, gunMetal, smoothstep(2.5, 2.3, v.y))*dirt;
    d2 =  roundedBox(v-vec3(8., 2.3, -10.5), vec3(.4, 1.6, 1.5), .2);
    //if ( d2 < 0.1)  mat = gunMetal*dirt;
    mat= mix(mat, gunMetal*dirt, clamp(-d2*10.0, 0.0, 1.0));
    
    d =  sphere(p+ vec3(.0, 5.6, -6.2), 3.2);
    if ( d < 0.0)
    {
        mat = vec4(0);
        emitionType = 3;
    }

    return mat;
}

// Function 3268
float scenelite(vec3 p)
{
    float d=1e9;
    
    // lamps
    {
        vec3 q=p;
        q.x=abs(q.x);
        q.xy+=vec2(-1.1,1);
        d=min(d,max(
            length(q.yx)-.05,
            abs(mod(q.z-1.,2.)-1.)-.01
        ));
        
        // minus lamps at grill
        d=max(d,1.-abs(p.z));
    }
    
    //lasers
    {
        vec3 q=p;
        q.xy=rotate(q.xy,-pi*.25);
        d = min(d,max(
            abs(q.z)-.1,
            abs(mod(q.y,.2)-.1)-.01
        ));
    }
    
    return d;
}

// Function 3269
float PointSegToroidalDistance(vec2 p, vec2 p0, vec2 p1)
{
    vec2 d = p1 - p0;
    
    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);

    vec2 proj = (1.0-t)*p0 + t*p1;
    
    return dot(proj-p, proj-p);
}

// Function 3270
float sdf(vec3 pos)
{
    float b = 10000.;
    float u = .4;
    float s = .33;
    float k = .5;
    
    combine(b, layer(pos, vec3( 0., 0., s ), vec3(u*3.), vec3(0., u , 0.), k));
    combine(b, layer(pos, vec3( 0., s , 0.), vec3(u*3.), vec3(u , 0., 0.), k));
    combine(b, layer(pos, vec3( s , 0., 0.), vec3(u*3.), vec3(0., 0., u ), k));
    combine(b, layer(pos, vec3( 0., 0.,-s ), vec3(u*3.), vec3(0., -u, 0.), k));
    combine(b, layer(pos, vec3( 0.,-s , 0.), vec3(u*3.), vec3(-u, 0., 0.), k));
    combine(b, layer(pos, vec3(-s , 0., 0.), vec3(u*3.), vec3(0., 0., -u), k));
    
    difference(b, soundSphere(pos, 1.));
    return b;
}

// Function 3271
float distf(vec3 p, inout float m)
{
	float d = pSphere(p, 22.0);
	m = 1.0;
	
	vec3 motion = vec3(0,0,cos(iTime * 2.0) * 6.0);
	p += motion;
	
	// Blade
	fIntersection(d, m, pPlane(p, normalize(vec3(0.01,0.2,1)), -1.0), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(0.01,-0.2,1)), -1.0), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(0.01,0.2,-1)), -1.0), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(0.01,-0.2,-1)), -1.0), 1.0);
	
	// Tip
	fIntersection(d, m, pPlane(p, normalize(vec3(-0.07,-0.2,1)), -1.5), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(-0.07,0.2,1)), -1.5), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(-0.07,-0.2,-1)), -1.5), 1.0);
	fIntersection(d, m, pPlane(p, normalize(vec3(-0.07,0.2,-1)), -1.5), 1.0);
	
	// Base
	fSubtraction(d, m, pSphere(p * vec3(1,2,1) - vec3(22,10,0), 8.0), 1.0);
	fSubtraction(d, m, pSphere(p * vec3(1,2,1) - vec3(22,-10,0), 8.0), 1.0);
	
	// Handle
	fUnion(d, m, pRoundBox(p - vec3(22.0 + cos(p.y * 0.3),0,0),
						   vec3(1,6.0 + cos(p.z * 10.0) * 0.15,1.0 + cos(p.y) * 0.5), 0.1), 2.0);
	fUnion(d, m, pCapsule(p, vec3(23,0,0), vec3(34,0,0), cos(p.x * 3.0) * 0.2 + 1.0), 2.0);
	
	
	// Ground
	p -= motion;
	fUnion(d, m, pPlane(p, vec3(0,0,1), 20.0), 0.0);
	
	return d;
}

// Function 3272
float scene(vec2 p) {
    vec2 p2 = proj(p);
    float d = scene2(p2);
    //since the centre of a circle doesn't map to the centre of its image,
    //we need to iteratively update our estimate with the correct centre
    for (int i = 0; i < 10; i++) {
        //get the projected circle's centre
    	p2 = (proj(p-normalize(p)*d) + proj(p+normalize(p)*d))/2.;
    	d = scene2(p2);
        d = d/(dot(p2,p2)-d*d);
    	d = clamp(d, -1.,1.); //if I don't clamp here, the distance estimate goes wild
    }
    return d;
}

// Function 3273
vec2 map( in vec3 pos )
{
	float bevel = 0.01;
    float side = 0.25;
    
    vec2 res1 =      vec2( sdPlane(       pos), 1.0 );
    
    vec2 res2 = vec2(       udRoundBox(   pos-vec3( 0.0, 0.25, 0.0), vec3(side), bevel ), 3.0 );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.75, 0.0), vec3(side), bevel ), 3.0 ) );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 0.0), vec3(side), bevel ), 3.0 ) );

	res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 0.5), vec3(side), bevel ), 3.0 ) );        

    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.25, 1.0), vec3(side), bevel ), 3.0 ) );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 0.75, 1.0), vec3(side), bevel ), 3.0 ) );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( 0.0, 1.25, 1.0), vec3(side), bevel ), 3.0 ) );        

	res2 = opU( res2, vec2( udRoundBox(   pos-vec3( -0.5, 0.25, 0.0), vec3(side), bevel ), 3.0 ) );
	res2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -0.5, 1.25, 0.0), vec3(side), 0.75 * PI ), 3.0 ) );
   
    res2 = opU( res2, vec2( sdQuaterBox(  pos-vec3( -0.5 + 0.25, 0.0, 1.0), vec3(0.25), vec2( 1.0, -1.0 ) ), 3.0 ) );        

     
    res2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -1.0, 0.25, 0.0), vec3(0.25), 0.75 * PI ), 3.0 ) );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( -1.0, 0.75, 0.0), vec3(side), bevel ), 3.0 ) );       
    
	res2 = opU( res2, vec2( sdHalfBox(    pos-vec3( -1.0, 0.25, 0.5), vec3(0.25), 0.25 * PI ), 3.0 ) );
    res2 = opU( res2, vec2( udRoundBox(   pos-vec3( -1.0, 0.75, 0.5), vec3(side), bevel ), 3.0 ) );

   	res2 = opU( res2, vec2( sdSphere(     pos-vec3( -1.0, 0.25, 1.0), 0.25 ), 46.9 ) );                    
    
    return opU( res1, res2 );
}

// Function 3274
vec3 jodieRoboTonemap(vec3 c){
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc=c/sqrt(c*c+1.);
    return mix(c/sqrt(l*l+1.),tc,tc);
}

// Function 3275
float sdfBox(in vec3 p, in vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3276
vec4 ShowScene (vec3 ro, vec3 rd, vec3 backColor) {
    // Intersection with ground
    float dMin = -ro.y/rd.y;
    idBall = -2;
    vnBall = vec3(0,1,0);        
    // Intersection with pencils
    float d = PencilHit(ro, rd, dMin);
    // Shading
    return vec4(shade(rd, ro + d*rd, vnBall, idBall, d), d);
}

// Function 3277
float map_z(float z)
{
    return z + iTime * speed;
}

// Function 3278
float distanceToSurface(Point3 P) {
	float ignore;
	return distanceToSurface(P, ignore);
}

// Function 3279
vec4 SDF (vec3 p){
    vec3 matCol = vec3(-1.);
    float total = 0.;
    
    float sc = 0.005;
    //modeling
    float mainBody = box3D(vec3(0., 0., 0.48)*sc, vec3(4., 0.5, 0.9)*sc, p);
    float trigger = box3D(vec3(3.5, 0.5, 0.28)*sc, vec3(0.5, 0.5, 1.1)*sc, p);
    
    float curveBody = box3D(vec3(0., 0., -0.9)*sc, vec3(3., 0.5, 0.5)*sc, p);
    float round1 = CappedCylinder(vec3(3.0, 0., -0.4)*sc, p, vec2(1., 0.5)*sc);
    float round2 = CappedCylinder(vec3(-3.0, 0., -0.4)*sc, p, vec2(1., 0.5)*sc);
    
    float homeButton = sphere(vec3(-2., -0.3+sin(iTime), 0.4)*sc, p, 0.5*sc);
    float otherButton = sphere(vec3(-2.+sin(iTime-0.01)*1.,0., 0.4)*sc, p, 0.8*sc);
    //distance field editing
    
    //green section
    total = smin(mainBody, trigger, 0.);
    total = min(curveBody, total);
    round1 = min(round1, trigger);
    total = min(total, round1);
    total = min(total, round2);
    total = min(total, trigger);
    if(total<0.0001&&matCol.x<0.){
        matCol = vec3(0.3, 1., 0.3);
    }
    //textured section
    total = max(total, -otherButton);
    if(total<0.0001&&matCol.x<0.){
        matCol = tex(p*20., iChannel1);
    }
    //black section
    total = smin(total, homeButton, 0.001);
    if(total<0.0001&&matCol.x<0.){
        matCol = vec3(0.);
    }
    return vec4(total, matCol);
}

// Function 3280
vec4 map(vec3 p) {
    return add(vec4(.3,.3,.2, plane(p)), vec4(.95,.2,.4, sphere(p-vec3(0,1,0), .5)));
}

// Function 3281
vec2 map( in vec3 pos )
{
    vec2 res = opU( 
        			vec2( 
        				sdPlane(pos), 
                        1.0 ),
	                vec2(
                        opS(   
                        	sdSphere(
                        		pos-position, 
                        		size*selection[0] 
                        	),
                            opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                            )
						),
                    	color 
                    ) 
    			);
    res = opU( 
        		res, 
        		vec2(
                     opS(                        
                    	sdBox(        				    
                            pos-position,
        			    	vec3(size*selection[1])
                              ),
                         	  opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                            )
                    	), 
                    color
                ) 
    		);
    res = opU( res, vec2( 
        				opS(
        					sdTorus(
                            	pos-position,
        						vec2(size*selection[2])),
                             opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                             )
                        ), 
        				color) 
             );
    res = opU( res, vec2( 
        				opS(
        					sdTriPrism(
        							pos-position, 
        							vec2(size*selection[3]) 
                        	),
                            opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                             )
                        ),
        				color) 
             );
    res = opU( res, vec2( 
        				opS(
        					sdCylinder(   
        							pos-position, 
        							vec2(size*selection[4]) 
                            ),
                            opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                             )
                        ),
        				color) 
             );
    res = opU( res, vec2( 
         				opS(
        					sdHexPrism(
        						pos-position, 
        						vec2(size*selection[5]) 
                            ),
                            opUx(
                            	sdSphere(
                        			pos-intersectorPosition,
                            		intersectorSize*intersectorSelection[0]
                            	),
                                opUx(
                                	sdBox(        				    
                            			pos-intersectorPosition,
        			    				vec3(intersectorSize*intersectorSelection[1])
                              		),
                                    opUx(
                                    	sdTorus(
        									pos-intersectorPosition, 
        									vec2(intersectorSize*intersectorSelection[2]) 
                        				),
                                        sdCylinder(   
                                            pos-intersectorPosition, 
                                            vec2(intersectorSize*intersectorSelection[3]) )
                                    )
                                  
                                )
                             )
                          	
                        ),
        				color) 
             );

        
    return res;
}

// Function 3282
geometry map(vec3 p) {
    p.x -= yC(p.y * .1) * 3.;
    p.z += yC(p.y * .01) * 4.;
    
    float n = pow(abs(fbm(p * .06 )) * 12., 1.3);
    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;
    
    geometry obj;

    obj.dist = max(0., -fCylinderInf(p, s + 18. -n));
    
    p.x -= sin(p.y * .02) * 34. + cos(p.z * 0.01) * 62.;
    
    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));
    
    return obj;
}

// Function 3283
void ray_march_scene(Ray r, float k, inout vec3 c)
{
    float uniform_step = k;
    float jit = 1.;
    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));
   
    float t_gen = 1.;

    float param_t = intersect_sphere(r, m.pos, RADIUS);
    if(param_t <= -1.)
        return;
    vec3 p = ray_interpolation(r, k*jit);        
     
    //rgb transparency               
    
    vec3 t_acc = vec3(1.);	// accumulated parameters for transparency
    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );
    int s = 0;
    
    for(s; s <90; s++)
    {               
        float dist_dist = dot(p-cam.pos, p-cam.pos);
        float dist_center = length(m.pos-cam.pos);
        vec3 center = p-m.pos;

        float d = length(center)-RADIUS-.5-jit*k;
        float size = length(center)/RADIUS;

        if(length(center)-RADIUS < 0.)
        {
            
            #if COLOR            
            #if ANIM      
            	anim = iTime/10.;
            
            #endif
            float n = fbm( ( 
                p/( clamp(0., RADIUS, length(center)) + cos(PI+snoise(p)) - 1./size*anim ) //shockwave stuff
            			) )  ;
            

            float mask = smoothstep(1.,
                                   	20.*RADIUS,
                                  	RADIUS/length(center));

            
            //Optical density/depth : dens for density
            float dens = ( clamp( mask,
                               	  0.,
                                  1.) *n);
            
           if(length(p-cam.pos) >(dist_center+m.radius) || 
           (k*dens  < -9.9))
        	{
         	break;
        	}
            //How colors (rgb) are absorbed at point p in the current iteration
            //k is the step size          
             vec3 rgb_t = exp(-vec3(
                		k * 15. * dens, 
                      	k * 10. * dens,
              	      	k * 15. * 1./size * dens));    
            
            t_acc *= (rgb_t);           
    
    		//blending
   			c += t_acc*vec3(1.)*(1.-rgb_t);
            #endif
        }

        //if it will never be in the shape anymore, return;        
        
        p += r.dir*k;

        k = uniform_step;
    }
    

    //c =float(s)/vec3(50,150,20); return;

    #if COLOR

    #else
    c = vec3(t_gen); return;
    #endif
}

// Function 3284
float Scene_SDF(vec3 point, inout RayHit hit)
{
    return SDF_Moon(point, hit);
}

// Function 3285
float TonemapCompressRangeNorm( float x )
{
	return 1.0f - exp( -x );
}

// Function 3286
float mapMetal(in vec3 position)
{
    vec3  basePosition = vec3(0.0, 0.3, 0.0) - LAMP_ORIGIN;
    vec3  baseMetalTop = vec3(0,-METAL_HEIGHT,0);
    vec3  baseMetalBottom = vec3(0.0);
    float baseMetalTopRadius = 0.7;
    float baseMetalBottomRadius = 0.45;
    float baseMetal = sdfCone(position + basePosition, 
                                baseMetalBottom, 
                                baseMetalTop, 
                                baseMetalTopRadius, 
                                baseMetalBottomRadius);
                                
    float bottomCut   = sdfCone(position + basePosition - vec3(0.0, 0.1, 0.0), 
                                baseMetalBottom, 
                                baseMetalTop, 
                                baseMetalTopRadius * 0.9, 
                                baseMetalBottomRadius * 0.9);
    baseMetal = opSmoothSubtraction(bottomCut, baseMetal, 0.1);
    
    vec3 capPosition = basePosition - vec3(0.0f,GLASS_HEIGHT,0.0f);
    vec3 capMetalTop = vec3(0.0);
    vec3 capMetalBottom = vec3(0.0,0.2,0.0);
    float capMetalTopRadius = 0.25;
    float capMetalBottomRadius = 0.2;
    float capMetal = sdfCone(position + capPosition, 
                             capMetalTop, 
                             capMetalBottom, 
                             capMetalTopRadius, 
                             capMetalBottomRadius);
                             
                             
    float capCutout = sdfCone(position + capPosition + vec3(0.0, 0.1, 0.0), 
                              capMetalTop, 
                              capMetalBottom, 
                              capMetalTopRadius * 0.75, 
                              capMetalBottomRadius * 0.75);
                              
    capMetal = opSmoothSubtraction(capCutout, capMetal, 0.1);
    return min(baseMetal, capMetal);
}

// Function 3287
float sdfMaterial(vec3 p, Ray camera)
{
    p = GetGliderTransform(p, camera);
    return p.y > -.0 ? 1.0 : 0.0;
}

// Function 3288
float SdfPlane(Object obj, vec3 pos){
    return pos.y - obj.pos.y;
}

// Function 3289
vec3 sample_grad_dist(vec2 uv, float font_size) {
    
    vec3 grad_dist = (textureLod(iChannel0, uv, 0.).yzw - TEX_BIAS) * font_size;

    grad_dist.y = -grad_dist.y;
    grad_dist.xy = normalize(grad_dist.xy + 1e-5);
    
    return grad_dist;
    
}

// Function 3290
float SceneIntersect( Ray r, inout Intersection intersec ){
    float d = INFINITY;	
    float t = 0.;
    vec3 normal = vec3(0.);
    for(int i=0;i<spheres.length();i++){
        t = SphereIntersect(spheres[i].radius,spheres[i].position,r);
        if (t < d){
            d = t;
            intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);
            intersec.emission = spheres[i].emission;
            intersec.color = spheres[i].color;
            intersec.roughness = spheres[i].roughness;
            intersec.type = spheres[i].type;
            intersec.id = spheres[i].id;
		}
    }
    for(int i=0;i<quads.length();i++){
        t = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );
        if (t < d){
        	d = t;
            intersec.normal = normalize(quads[i].normal);
            intersec.emission = quads[i].emission;
            intersec.color = quads[i].color;
            intersec.roughness = quads[i].roughness;
            intersec.type = quads[i].type;
            intersec.id = quads[i].id;
        }
    }
    for(int i=0;i<boxes.length();i++){
    	t = BoxIntersect(boxes[0].minCorner,boxes[0].maxCorner,r,normal);
        if(t < d){
        	d = t;
            intersec.normal = normalize(normal);
            intersec.emission = boxes[i].emission;
            intersec.color = boxes[i].color;
            intersec.roughness = boxes[i].roughness;
            intersec.type = boxes[i].type;
        	intersec.id = boxes[i].id;
        }
    }
    
    intersec.distance = d;
    intersec.surface  = r.origin + r.direction * d + intersec.normal*0.00001;
    return d;
}

// Function 3291
Hit intersectScene(Ray r)
{
    vec3 axis1 = randomVector(floor(iTime));
    vec3 axis2 = randomVector(floor(iTime+1.));
    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));
    float translation = 4.*abs(2.*fract(iTime/8.)-1.) - 2.;

    Material weirdMat = Material(0.05 * vec3(0., 0.05, 1.), 0.1 * vec3(1.1, 0.08, 0.01));
    Sphere s = Sphere(1.6, vec3(0., 1.6, 0.), weirdMat);
    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.05), vec3(0.02)));

    Hit hit = noHit;
    compare(hit, intersectPlane(p, r));
    compare(hit, intersectHashedSphere(s, r));
    return hit;
}

// Function 3292
vec2 map(vec3 p)
{
    vec2 pp = sdStage(p);
    vec3 cubePos = p * 2.0;
    cubePos -=  vec3(-4.5, -0.5, -13.0) * 2.0;
    cubePos.xz *= rot(1.);
    
    vec3 cakePos = p * 2.0;
    cakePos -=  vec3(0.0, 0.07, -8.0) * 2.0;
    
    vec2 d = opU(sdCube(cubePos), sdCake(cakePos)) * vec2(0.5, 1.0);
    
    Coord = cubePos;
    
    vec3 deskPos = p - vec3(0.0, -0.8, -8.0);
    deskPos.xz *= rot(0.25);
    
    vec2 desk = sdDesk(deskPos);
    d = opU(d, desk);
    d = opU(d, pp);
    
    vec3 q = p;
    p.xz = pMod(p.xz, 8.0);
    q = p;
    CoreID.w = abs(floor(p.z / 6.0));
    p.z = opRep(p.z, 6.0);
    
    vec2 size = floor(hash12(CoreID.w) * vec2(3.0, 5.0)) + vec2(5.0, 3.0);
	if (abs(CoreID.w) == 2.0) {
    	size = vec2(3.0, 3.0);
    }
    p.z *= -1.0;
    vec2 shelf = sdShelf(p, size);
    shelf.x = max(-q.z + 12.0, shelf.x) * 0.7;
    d = opU(d, shelf);
    return d;
}

// Function 3293
float map(vec3 rayPos, out int hitMaterial)
{
    float minDist = 99999.0;
    hitMaterial = MAT_BACKGROUND;
    
    float tempDist = sdSphere(rayPos, vec3(0.3, 0.0, 0.0), 0.2);
    distCheck(tempDist, minDist, MAT_SPHERE1, hitMaterial);
    tempDist = sdSphere(rayPos, vec3(-0.3, 0.0, 0.0), 0.2);
    distCheck(tempDist, minDist, MAT_SPHERE2, hitMaterial);
    
    return minDist;
}

// Function 3294
float IntersectSDF(float distA, float distB) {
    return max(distA, distB);
}

// Function 3295
float dist2Segment(vec4 z, vec4 n, float r){
	//pmin is the orthogonal projection of z onto the plane defined by p and n
	//then pmin is projected onto the unit sphere
	float zn=dot(z,n),zp=dot(z,p),np=dot(n,p);
	float alpha=zp-zn*np, beta=zn-zp*np;
	vec4 pmin=normalize(alpha*p+min(0.,beta)*n);
	//ca and sa are the cosine and sine of the angle between z and pmin. This is the spherical distance.
	float ca=dot(z,pmin), sa=0.5*length(pmin-z)*length(pmin+z);//sqrt(1.-ca*ca);//
	return DD(ca,sa,r)-SRadius;
}

// Function 3296
float torusSDF( vec3 p, vec2 t )
{
  vec2 q = vec2(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

// Function 3297
float map(vec3 p)
{
    p*=18./N;
    float time= 15.;//mod(iTime, 15.0)+2.;
  
    // Shane's variation
    float d0=dot(sin(p),cos(p.yzx));
    float d2=length(p)-min(9.,time);
    float d=smax(-d0,d2,3.);
   
    return clamp(d,-.5,+.5);
    //return  clamp(p.z  +sin(p.x)+sin(p.y) ,-.5,+.5);
}

// Function 3298
float map(vec3 p){
    
	// Height map to perturb the flat plane. On a side note, I'll usually keep the
    // surface function within a zero to one range, which means I can use it later
    // for a bit of shading, etc. Of course, I could cut things down a bit, but at
    // the expense of confusion elsewhere... if that makes any sense. :)
    float sf = surfFunc(p);

    // Add the height map to the plane.
    return p.y + (.5-sf)*2.; 
 
}

// Function 3299
float sdf_round_box(vec3 p, vec3 b, float r)
{
    return length(max(abs(p) - b, 0.)) - r;
}

// Function 3300
vec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )
{
    float theta = atan(vRayDir.x, vRayDir.y);
    vec4 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );
    float fDist = vScene.x;
	vec3 vPos = vRayOrigin + vRayDir * fDist;
	
    vec3 vNormal = Scene_GetNormal( vPos );
    vec2 vUV = vScene.yz; 
    
    
    if ( fDist > 350.0 )
    {
        vUV = vec2(0);
    }   

#if REVERSE_DIRECTION
    vUV.y = 1.0 - vUV.y;
#endif    
    
    vec3 vTex = MotionTexture(vUV + 0.25, vScene.w );
    
    vTex = vTex * vTex;
    
    
    
    vec3 vResult = vTex;
    
    // Hacked darkening
    if ( vScene.w == 0.0 )
    {
        // darken back wall
        vResult *= 1.0 - (0.6 / (0.2 + Scene_Pillar( vPos ).x));
        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));
        vResult *= 0.8;
    }
    
    if ( vScene.w == 1.0 )
    {
        // darken pillar
        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));
        vResult *= max(0.0, -vNormal.z) * 0.8 + 0.2;
        vResult *= 1.5;
    }

    if ( vScene.w == 2.0 )
    {
        
        vResult *= max(0.0, -vNormal.z);
    }

    
    vResult *= 1.5;

    return sqrt(vResult);
}

// Function 3301
vec3 sdfNormal(vec3 p, float epsilon)
{
    vec3 eps = vec3(epsilon, -epsilon, 0.0);
    
	float dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);
	float dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);
	float dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); 

	return normalize(vec3(dX,dY,dZ));
}

// Function 3302
float GetDist(vec3 p) {

    float d = sdBox(p, vec3(1));
    
    if(iTime>22.95){
        d = sdBox(p, vec3(iTime / 10.,iTime / 10.,iTime / 10.));
    }
    
    if(iTime>35.8){
        d = sdBox(p, vec3(1.+sin(iTime),2. + sin(iTime),3.+sin(iTime)));
    } 
    if(iTime>78.06){

		d = sdBox(p, vec3(1.+sin(iTime),1. + sin(iTime),1.+sin(iTime)));
    }
    return d;
}

// Function 3303
float scene(vec3 pos)
{
    return min(mandelbox(pos), plane(pos-vec3(0.0,-6.5,0.0)));
}

// Function 3304
vec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }

// Function 3305
float distAvgEval( vec2 uv )
{
    float aspect = iResolution.x / iResolution.y;
    const int samples = 32;
    const float fsamples = float(samples);
    vec2 maxdist = 0.075 * vec2( aspect, 1.0 );
    vec2 halfmaxdist = 0.5 * maxdist;
    float stepsize = maxdist.x / fsamples;
    float initial_offset_x = -0.5*fsamples * stepsize;
    uv.x += initial_offset_x;
    #if defined( USE_JITTER )
    uv.x += hash12n(uv+fract(iTime)) * stepsize;
    #endif
    float hit = 0.0;
    for( int i=0; i<samples; ++i )
    {
        float x = uv.x + stepsize * float(i);
        float y = uv.y;
        float fx = function( x );
        float dist = ( y - fx );
        float vt = clamp( dist / halfmaxdist.y -1.0, -1.0, 1.0 );
        hit += vt;
    }
    return 1.0 - abs(hit) / fsamples;
}

// Function 3306
vec4 totalsdf(vec3 pos) {
    vec4 ds = spheresdf(pos);
    vec4 dc = cubesdf(pos);
    return vec4(normalize(ds.xyz * exp(-ds.w * WEIGHT) + dc.xyz * exp(-dc.w * WEIGHT)), min(ds.w, dc.w));
}

// Function 3307
float map(vec3 p){float m;return map(p, m);}

// Function 3308
void SetupScene(){
	spheres[0] = Sphere( 0.2, vec3(-0.1 , 0., 0.), vec3(0.), vec3(0.3,1. ,0.  ), 0.7, SPEC);
	spheres[1] = Sphere( 0.23, vec3(0.2, 0.1, 0.), vec3(0.), vec3(1.,0.,0.05), 0.4, SPEC);
   	spheres[2] = Sphere( 0.4, vec3(0.2, 0.4,0.3),vec3(1.,0.8,0.8),vec3(1.,0.,0.4), 0.05, SPEC);
    ellipsoids[0] = Ellipsoid(vec3(1.,2.,1.),vec3(-1.,0.,1.5),vec3(0.2),vec3(0.,0.8,0.5),0.4,SPEC);
	openCylinders[0] = OpenCylinder(0.3,vec3(0.,0.2,0.),vec3(0.,0.,0.),vec3(0.2),vec3(0.,0.6,0.9),0.4,SPEC);
	cones[0] = Cone(vec3(1.,1.,0.),0.5,vec3(5.,1.,0.), 1., vec3(0.5),vec3(1.,1.,0.),0.4,SPEC);
    disks[0] = Disk(1.0, vec3(0.,2.,0.), vec3(0.,1.,0.), vec3(0.7,0.8,0.7), vec3(0.2,0.3,0.4), 0.2, LIGHT);
    quads[0] = Quad(vec3(0.,0.,1.),vec3(-0.5,0.,-1.), vec3(0.5,0.,-1.), vec3(0.5 ,0.55 ,-1. ), vec3(-0.5,0.55,-1.), vec3(0.6,0.6,0.6), vec3(0.4,0.5,0.6),0.4, LIGHT);
    boxes[0] =  Box(vec3(-0.7,-0.3,-0.7),vec3(0.7,0.0,0.7), vec3(0.,0.,0.), vec3(0.,0.2,0.1), 0.1, DIFF);
}

// Function 3309
float map_detailed(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_FRAGMENT; i++) {        
    	uv += Clubber.rg * 0.1;
    	d = sea_octave((uv+SEA_TIME)*freq+ 2. * Clubber.r,choppy);
    	d += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);
        h += d * amp;        
    	uv *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 3310
vec2 map( in vec3 pos )
{
    float f = float(iFrame),
          dt = .5 + .5*sin(f/16.+cos(iTime));
    
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    dt, pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       dt, pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  dt, pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
	res = opU( res, vec2( sdTorus(     dt, pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   dt, pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdTriPrism(  dt, pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
	res = opU( res, vec2( sdCylinder(  dt, pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
	res = opU( res, vec2( sdCone(      dt, pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
	res = opU( res, vec2( sdTorus82(   dt, pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	res = opU( res, vec2( sdTorus88(   dt, pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
	res = opU( res, vec2( sdCylinder6( dt, pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
	res = opU( res, vec2( sdHexPrism(  dt, pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );

    res = opU( res, vec2( opS(
		             udRoundBox(  1.7-dt, pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
	                 sdSphere(    1.5*dt,pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS(
		             sdTorus82(  1.-dt, pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
	                 sdCylinder( opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831,
											  pos.y,
											  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),
									     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    
	res = opU( res, vec2( 0.7*sdSphere(    dt,pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 
					                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 
                                       65.0 ) );

	res = opU( res, vec2( 0.5*sdTorus( dt, opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );

    res = opU( res, vec2(sdConeSection( dt, pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );

    res = opU( res, vec2(sdEllipsoid( dt, pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
        
    return res;
}

// Function 3311
vec2 map3ds(vec2 z)
{
 // animation specific hacks
 vec2 z2 = z*z;
 vec2 a  = 2.+vec2(z2.x-z2.y, -z2.x+z2.y);
 vec2 b  = twosqrt2*z;
 vec2 p  = a+b;
 vec2 m  = a-b;
 vec2 r  = sgn(p)*sqrt(abs(p))-sgn(m)*sqrt(abs(m));
 return 0.5*r;
}

// Function 3312
float getDistance(vec3 pos)
{
    float k,r2, orb = 1.;
    for(int i=0; i < NB_ITERATION; i++)
    {
        pos = 2.*clamp(pos, mins.xyz, maxs.xyz)-pos;
        r2 = dot(pos,pos);
        orb = min(orb, r2);
        k = max(mins.w/r2,1.);
        pos *= k;
    }
    return kColor.x + kColor.y*sqrt(orb);
}

// Function 3313
float sceneMap3D(vec3 pos)
{
    float minT = 10000.0;
    float t = minT;
    for(int i = 0; i < primitives.length(); i++)
    {
        if(primitives[i].primitiveId == SQUARE_PLANE)
        {
        	vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));
            float maxOffset = max(max(abs(primitives[i].transform.trans.x), 
                                      abs(primitives[i].transform.trans.y)), 
                                      abs(primitives[i].transform.trans.z));
            curNor.w = maxOffset;
        	t = squarePlane(pos, curNor);
        }
        else if(primitives[i].primitiveId == CUBE)
        {
        	t = cube(pos, primitives[i].transform);
        }
        
       
        if(t < minT)
        {
        	minT = t;
        }
    }
    t = minT;
    return t;
}

// Function 3314
SRayHitInfo TestSceneMarch(in vec3 rayPos)
{
    SRayHitInfo hitInfo;
    hitInfo.hitAnObject = false;
    hitInfo.dist = c_superFar;
    
    // glowing triangles
    {

        vec3 A = vec3(0.0f, 0.0f, 0.0f);
        vec3 B = vec3(1.5f, 3.0f, 0.0f);
        vec3 C = vec3(3.0f, 0.0f, 0.0f);
        float lineWidth = 0.1f;
        
        vec3 center = (A + B + C) / 3.0f;
        A -= center;
        B -= center;
        C -= center;
        
        A *= 3.0f;
        B *= 3.0f;
        C *= 3.0f;
        
        // foreground purple one
        SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;            

        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);
        
        // blue one slightly behind
        material.emissive = pow(vec3(0.3f, 0.15f, 1.0f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;
        A += vec3(0.0f, 0.0f, 5.0f);
        B += vec3(0.0f, 0.0f, 5.0f);
        C += vec3(0.0f, 0.0f, 5.0f);
        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);        
        
        // red one behind more
        material.emissive = pow(vec3(1.0f, 0.15f, 0.3f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;
        A += vec3(0.0f, 0.0f, 5.0f);
        B += vec3(0.0f, 0.0f, 5.0f);
        C += vec3(0.0f, 0.0f, 5.0f);
        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);
        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);              
	}    

    // a neon cactus
    {
    	SMaterial material;
        material.diffuse = vec3(0.0f, 0.0f, 0.0f);
        material.specular = vec3(0.0f, 0.0f, 0.0f);
        material.roughness = 0.0f;
        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;
        
        vec3 cactusOffset = vec3(0.0f, 0.0f, 50.0f);
        
        // main body section
        {
            vec3 A = vec3(-40.0f, -10.0f, 0.0f) + cactusOffset;
            vec3 B = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;
            vec3 C = vec3(-40.0f, 20.0f, 0.0f) + cactusOffset;
            TestBezierMarch(rayPos, hitInfo, A, B, C, 2.0f, material);
        }
        
        // Arm going to left
        {
            vec3 A = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;
            vec3 B = vec3(-32.5f, 10.0f, 0.0f) + cactusOffset;
            vec3 C = vec3(-32.5f, 15.0f, -1.0f) + cactusOffset;
            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);
        }
        
        // Arm going to right
        {
            vec3 A = vec3(-40.0f, 2.0f, 1.0f) + cactusOffset;
            vec3 B = vec3(-47.5f, 7.0f, 2.0f) + cactusOffset;
            vec3 C = vec3(-47.5f, 13.0f, 4.0f) + cactusOffset;
            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);
        }        
        
    }

    return hitInfo;
}

// Function 3315
float MapBridge(vec3 p)
{
  p=TranslateBridge(p);
  // AABB
  if (sdBox(p-vec3(10., -1.0, 0.0), vec3(11.5, 2.50, 2.25))>3.) return 10000.;

  vec3 bPos = p+vec3(0.36, 0.0, 0.0);
  // bottom planks
  pModInterval1(bPos.x, 0.35, 0., 60.);
  float d= sdBox(bPos-vec3(0., 0.0, 0.1), vec3(0.12, 0.08, 1.80));

  // bearing balks
  bPos = p-vec3(-1.75, -0.726, -2.);
  pModInterval1(bPos.x, 3.2, 0., 7.);
  d= min(d, sdBox(bPos-vec3(0., .0, 2.1), vec3(0.15, 0.15, 2.00)));
  float m = pModInterval1(bPos.z, 4.2, 0., 1.);
  d= min(d, sdCappedCylinder(bPos+vec3(0., 0.55, 0.), vec2(0.2, 2.8-m)));

  // side rails      
  bPos = p-vec3(10.8, 0., -1.7);
  m = pModInterval1(bPos.z, 3.60, 0., 1.);
   m = pModInterval1(bPos.y, 1.40, 0., 1.-m);
     
  d= min(d, sdBox(bPos, vec3(10., 0.14, .12)));

  return d;
}

// Function 3316
float sdf(vec3 pos){
    Surface surf;
    return sdf(pos, surf);
}

// Function 3317
vec2 map( vec3 p, int octaves ) {
	
	float dMin = dMax; // nearest intersection
	float d; // depth
	float mID = -1.0; // material ID
	
	// terrain
	float h = terrain(p.xz, octaves);
	h += smoothstep(-0.3, 1.5, h); // exaggerate the higher terrain
	h *= smoothstep(-1.5, -0.3, h); // smooth out the lower terrain
	d = p.y - h;	
	if (d<dMin) { 
		dMin = d;
		mID = 0.0;
	}
	
	// trees
	if (h<0.0) { // no need to check for trees at higher elevations
		float f = terrain(p.xz*15.0, octaves);
		f = (0.1*f) - 0.3; // limit the altitude of the trees
		d = p.y - f;
		if (d<dMin) { 
			dMin = d;
			mID = 1.0;
		}
	}	

	return vec2(dMin, mID);
}

// Function 3318
vec4 iScene(vec3 ro, vec3 rd)
{
    mat = matBound;
    float innerScene = iCylinder(ro,rd,vec3(0.),vec3(0.,1.,0.),1.7*T);
    if (innerScene > 0. && (ro+rd*innerScene).y >= -4.) return vec4(innerScene,0.,0.,0.);
    mat = matLight;
    vec4 light = sphIntersect(ro,rd,lightpos,4.);
    if (light.x > 0.) return light;
    mat = matDiffuse;
    float plane = plaIntersect(ro, rd, vec4(0,1,0,4));
    if (plane > 0. && (ro+rd*plane).x >= -10.) return vec4(plane, 0.,1.,0.);
    vec4 curve = iCylinderInverse(ro,rd, vec3(-10.,11.,0.), vec3(0.,0.,1.),15.);
    if (curve.x > 0. && ro.x+rd.x*curve.x <= -10.) return curve;
    return vec4(0);
}

// Function 3319
float map(vec3 p){
    // rotate
    float r = 3.14159*sin(p.z*0.15)+T*0.25;
    R = mat2(cos(r), sin(r), -sin(r), cos(r));
    p.xy *= R;
    vec3 op = p;
    
    // per-cell random values
    float h = hash(floor(p.x+p.y+p.z));
    float h2 = 3.141*hash(floor(-p.x-p.y-p.z));
    
    // bumpy
    #ifdef BUMPY
    float f = pow(texture(iChannel2, p*0.1).b,4.0);
   	vec3 dd = vec3(sin(p.z*71.), cos(p.x*73.), -cos(p.y*77.))
               -0.6*vec3(cos(p.y*141.), sin(p.z*143.), -sin(p.x*147.));
    p = mix(p, p-dd*0.005, f);
    #endif
    
    // repeat lattice
    const float a = 1.0;
    p = mod(p, a)-a*0.5;
    
    // primitives
    // center sphere
    float v = length(p)-(0.02+(0.18*h*(0.6+0.4*sin(3.0*T+h2)) ));
    // four connecting cylinders
    v = smin(v, length(p.xy+0.01*sin(-3.2*T+13.0*op.z))-0.03, 0.2);
    v = smin(v, length(p.xz+0.01*cos(-4.1*T+11.0*(op.y-op.z)))-0.03, 0.2);
    v = smin(v, length(p.yz+0.01*sin(-5.0*T-8.0*(op.x-op.z)))-0.03, 0.2);
    
    return v;
}

// Function 3320
float map(in vec3 p){
   
    
    // Back plane. Six units behind the center of the weaved object.
    float pln = -p.z + 6.;
    
/*  
    // Raytraced sphere hit variable. It saves extra calculation, but
    // complicates things. Plus, it can interfere with shadows, add to 
    // the compile time... It saves a lot of pixel calculations though, 
    // especially in fullscreen... I'll have a think about it. :)
    if(balHit < 0.){
        
        objID = vec4(1e5, 1e5, 1e5, pln);
        return pln;
        
    }
*/   
    
    // Rotate the object.
    p = rotObj(p);
    //p.yz *= rot2(-3.14159/6.);
    
    vec3 oP = p;
    
    
    float d = 1e5, d2 = 1e5, d3 = 1e5;
    
   
    // DjinnKahn's icosahedral distance function that produces a triangular face
    // and allows you to determine between the negative and positive X axis.
    
    // Large hexagonal face positions.
    vec3 hexFace = opIcosahedronWithPolarity(p); 
    
    // Rotating the points above to the dual pentagonal face positions. This saves
    // a lot of extra operations. We're able to do this because of the icosahedron
    // and dodecahedron duality.
    vec3 pentFace = R4*hexFace; 
    
    // Pentagon.
    vec3 p1 = (pentFace - vec3(0, 0, 1));
    d3 = min(d3, dist( p1, .185, .1) );
    d = min(d, spokes);
    d3 = min(d3, sph);
    
    // Hexagon. 
    p1 = basisHex*(hexFace - mid*1.2425);
    d3 = min( d3, dist2( p1, .25, .1) );
    d = min(d, spokes);
    d3 = min(d3, sph);
    
    // Small cogs.
    p1 = basisHexSm1*(hexFace - mix(v0, v2, .333)*1.1547);
    d2 = min( d2, dist3( p1, .16, .1) );
    d = min(d, spokes);
    d3 = min(d3, sph);
    p1 = basisHexSm2*(hexFace - mix(v0, v1, .333)*1.1547);
    d2 = min( d2, dist3( p1, .16, .1) );
    d = min(d, spokes);
    d3 = min(d3, sph);
    
   
    // Capping off the edges of the gears with the outer sphere itself.
    float mainSph = length(oP);
    d = max(d, mainSph - 1.0825);
    d2 = max(d2, mainSph - 1.116);
    d3 = max(d3, mainSph - 1.118);
 
    

    
    // Store the individual object values for sorting later. Sorting multiple objects
    // inside a raymarching loop probably isn't the best idea. :)
    objID = vec4(d, d2, d3, pln);
    
    return min(min(d, d2), min(d3, pln));
}

// Function 3321
vec3 GetEnvMapB(vec3 rayDir) {
    // Make sure this texture is set to the "St. Peter's Basilica" cubemap.
    vec3 tex = texture(iChannel2, rayDir).xyz;
    tex = tex * tex;  // gamma correct - gamma 2.0
    // redish sky color.
    vec3 light = vec3(1.0, 0.9, 0.9)*max(0.0, rayDir.y);
    vec3 texp = pow(tex, vec3(14.0));
    light *= texp;  // Masked into the existing texture's sky
    return (tex + light*56.0);
}

// Function 3322
float sdf_w(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(2, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(2, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(6, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(8, -2, 0), vec3(6, -8, 0)));
    return t;
}

// Function 3323
float map(vec3 p){
    float k = 1.0;
    if (doInversion) {
        k = dot(p,p);
    	p /= k;
    	p.y += 0.5*iTime;
    	p += vec3(0.1,0.2,0.3);
    }

    vec3 q = p-round(p);

    return k*(length(q)-0.3);
}

// Function 3324
vec4 MapPlanet(vec3 p)
{
  vec3 moonPos = p-GetMoonPosition(p);
  vec2 mapPos = PosToSphere(moonPos);
  float heightMap = -fastFBM((moonPos*0.5)*.4);
  float moon = sdSphere(moonPos, 40.+heightMap);
  GetPlanetRotation(p);  
  mapPos = PosToSphere(p);
  heightMap = ((GetTerrainHeight(8.*p)*0.35))*textureLod(iChannel3, 2.*mapPos, log2(mapPos.y*2.)).z*1.5;
  return vec4(min(moon, sdSphere(p, 70.-min(2., (1.-heightMap)))), heightMap, moon, 0.);
}

// Function 3325
vec2 map( vec3 pos , float io ){  
   
    vec2 idx =vec2(1.);
    
    float clock = iTime*4.;
    float phase = (idx.y+idx.x)*3.14159;
    
    float anim = sin(phase + clock);
    
    vec2 crystal = prism( pos, prismSize );
    vec2 flow = goo( pos + vec3(0.,anim*0.025,0.)  );
    
    vec2 res2 = smoothU( crystal , flow , .2 );// vec2(smin(crystal.x, flow.x, 0.15), 3.);
    
    vec2 l = lightMap( pos );
    //res = opU( res , l );
    
    res2.x *= io;

   	return res2;
    
}

// Function 3326
vec2 map(in vec3 l, in sph s) {
    vec3 n = nrm(l, s);
    return map(l, n, s);
}

// Function 3327
vec4 sceneI(const vec3 pos, const vec3 dir) {
    vec3 s = sign(dir);
    float t   = max(0., -(pos.y+s.y*1.3)/dir.y);
    float end = max(0., -(pos.y-s.y*1.0)/dir.y);
    for(int i = 0; i < 16 && t < end; i++) {
        vec3 p = pos+t*dir;
        vec2 fp = floor(p.xz);
        vec2 co = cos(fp*.5+iTime);
        vec4 sI = sphereI(pos, dir, vec3(fp+.5, co.x*co.y).xzy);
        if(sI.w > 0.) return sI;
        vec2 l = (s.xz*.5+.5+fp-p.xz) / dir.xz;
        t += min(l.x, l.y) + .1;
    }
    return vec4(-1.);
}

// Function 3328
float map(vec3 p){
    
	// Surface function to perturb the walls.
    float sf = surfFunc(p);

    // A gyroid object to form the main passage base layer.
    float cav = dot(cos(p*3.14159265/8.), sin(p.yzx*3.14159265/8.)) + 2.;
    
    // Mold everything around the path.
    p.xy -= path(p.z);
    
    // The oval tunnel. Basically, a circle stretched along Y.
    float tun = 1.5 - length(p.xy*vec2(1, .4));
   
    // Smoothly combining the tunnel with the passage base layer,
    // then perturbing the walls.
    tun = smax(tun, 1.-cav, 2.) + .75 + (.5-sf);
    
    float gr = p.y + 7. - cav*.5 + (.5-sf)*.5; // The ground.
    float rf = p.y - 15.; // The roof cutoff point.
    
    // Smoothly combining the passage with the ground, and capping
    // it off at roof height.
    return smax(smin(tun, gr, .1), rf, 1.);
 
 
}

// Function 3329
vec3 SceneNormal(vec3 pos )
{
    float eps = 0.001;
    vec3 n;
	int m;
    float d = Scene(pos, m);
    n.x = Scene( vec3(pos.x+eps, pos.y, pos.z), m ) - d;
    n.y = Scene( vec3(pos.x, pos.y+eps, pos.z),m ) - d;
    n.z = Scene( vec3(pos.x, pos.y, pos.z+eps),m ) - d;
    return normalize(n);
}

// Function 3330
vec2 map(in vec3 l, in vec3 n, in sph s) {
    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);
}

// Function 3331
vec2 map(vec3 p)
{
    vec2 mground = matground(p);
    vec2 mwood = matwood(p);
    float d = min(mground.x, mwood.x);
    float m = max(mground.y, mwood.y);
    return vec2(d, m);
}

// Function 3332
vec3 GetSceneLight(float specLevel, vec3 normal, vec3 pos, vec3 rayDir)
{      
  vec3 light1 = normalize(vec3(-1.0, 2.8, 1.0));
    
  vec3 reflectDir = reflect( rayDir, normal );
  specLevel *= pow(clamp( dot( reflectDir, light1 ), 0.0, 1.0 ), 16.0);

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float diffuse = clamp( dot( normal, light1 ), 0.0, 1.0 );
  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );
  float fill = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 1.0 )*1.0;
  float backLight = clamp( dot( normal, normalize(vec3(-light1.x, 0.0, -light1.z))), 0.0, 1.0 )*5.0;

  diffuse *= SoftShadow( pos, light1);
  skyLight *= SoftShadow( pos, reflectDir);

  vec3 lightTot = 1.30*diffuse*vec3(1.00, 0.80, 0.55);
  lightTot += specLevel*vec3(1.00, 0.90, 0.70)*diffuse;
  lightTot += 0.40*amb*vec3(0.40, 0.60, 1.00);
  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);
  lightTot += 0.50*backLight*vec3(0.25, 0.25, 0.25);

  return lightTot+(0.25*fill*vec3(1.00, 1.00, 1.00));
}

// Function 3333
float mapHeightLQ(in vec3 rp)
{
    return rp.y - mapBottom(rp);
}

// Function 3334
float distFunc(vec3 p)
{
    float k, scale=1.;
    for(int i=0; i < NB_ITERATION; i++)
    {
        p = 2.*clamp(p, mins.xyz, maxs.xyz)-p;
        k = max(mins.w/dot(p,p), 1.);
        p *= k;
        scale *= k;
    }
    float rxy = length(p.xy);
    return .7*max(rxy-maxs.w, /*abs*/(rxy*p.z) / length(p))/scale;
}

// Function 3335
float map(vec3 p) {
    float scene = p.y;
    
    float h = fbmM(p.xz);	
    scene -= h;

  	return scene;
}

// Function 3336
float scene(vec3 p) {
  vec3 tor = p;
  tor = erot(tor, vec3(0,0,1), iTime);
  tor = erot(tor, vec3(0,1,0), 0.6);
  
  vec3 cyl = p - vec3(0,-1,0);
  cyl = erot(cyl, vec3(0,1,0), iTime);
  
  vec3 con = p - vec3(0,1,0);
  con = erot(con, vec3(0,1,0), -iTime);
  
  float best = cylinder(cyl, vec2(0.3, 0.8))-0.01;
  best = min(best, torus(tor, vec2(0.8,0.2)));
  best = min(best, cone(con, vec2(0.5,0.7)))-0.01;
  return min(best, p.z+0.9);
}

// Function 3337
float map(vec3 p)
{
    float d = sdBox(p - vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));
    float d1= sdBox(p + vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));
    if(d < d1){
        matId = 1.0;
    }
    else
    {
        matId = 2.0;
        d = d1;
    }
    d1 = sdBox(p - vec3(0.0, 0.0, 25.0), vec3(25.0, 25.0, 0.1));
    d1 = min(d1, sdBox(abs(p) - vec3(0.0, 25.0, 0.0), vec3(25.0, 0.1, 25.0)));
    
    vec3 rp = p + vec3(-8.0, 18.0, 15.0);
    rp.xz *= rotate(-0.314);
    d1 = min(d1, sdBox(rp, vec3(7)));

    rp = p + vec3(8., 12.0, 0.0);
    rp.xz *= rotate(0.262);
    if(d1 < d)
    {
        matId = 0.0;
        d = d1;
    }
    d1 = sdBox(rp, vec3(7, 14, 7));
    if(d1 < d)
    {
        matId = 4.0;
        d = d1;
    }
    d1 = sdBox(p - light_position, light_dimension);
    if(d1 < d)
    {
        matId = 3.0;
        d = d1;
    }
    
    return d;
}

// Function 3338
void mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )
{
    // --- part indentical on the 6 faces

    U /= iResolution.xy;
    O  = texture(iChannel0, U );           // source image
    float v = 5.*max(0., O.r - O.g );      // stencil to analyze ( ~= flech )

    
    // --- part specific to each of the 6 faces. https://www.shadertoy.com/view/Xlcczj
    
    vec3 A = abs(D); // seek for max direction: i = invmax(abs(D[i]))
    int i=0; 
    float      M = A.x; 
    if (A.y>M) M = A.y, i=1;
    if (A.z>M) M = A.z, i=2;
    int  faceID = i + 3* int(D[i]<0.);
    
    if (faceID==0) // --- raw image
        O.a = v;   // ( redundant )
    if (faceID==1) // --- compute M1 moments E(x),E(y) and M0=E(I) in ultimate MIPmap LOD. (M1 to be normalized by M0) 
        O = vec4( U, 1, 0 ) * v;
    if (faceID==2) // --- compute M2 matrix E(xx),E(yy),E(xy) in ultimate MIPmap LOD (to be normalized by Imean)  
        O = vec4( U*U, U.x*U.y, 0 ) * v;   
    if (faceID>2)  // --- don't need last faces 
        O -= O;
}

// Function 3339
vec3 scene_surface_albedo( vec3 r, mat2x3 Kr, float h, float slope, float sinlat, bool detail )
{
    vec4 col = vec4( 0 );
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        ivec2 addr = ADDR_SCENE_OBJECTS + ivec2( i, 0 );
        SceneObj obj = so_load( iChannel0, addr );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_RUNWAY:
        col = scene_obj_runway( col, obj, r, Kr );
        break;
        }
        if( col.w >= 1. )
            break;
    }
    float Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );
    return trn_albedo( r, Krwidth, h, slope, sinlat, detail ) * ( 1. - col.w ) + col.xyz;
}

// Function 3340
float map_spheres(vec3 pos, vec3 center, float d, float r)
{
    pos-= center;
    pos.xz = rotateVec(pos.xz, iTime*0.5);
    pos.x = abs(pos.x);
    pos.x-= d;
    pos.z = abs(pos.z);
    pos.z-= d;
    return length(pos) - r;   
}

// Function 3341
float sdf_2(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -2, 0)));
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -2, 0)));
    return t;
}

// Function 3342
float Tonemap_Uchimura(float x, float P, float a, float m, float l, float c, float b) {
    // Uchimura 2017, "HDR theory and practice"
    // Math: https://www.desmos.com/calculator/gslcdxvipg
    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp
    float l0 = ((P - m) * l) / a;
    float L0 = m - m / a;
    float L1 = m + (1.0 - m) / a;
    float S0 = m + l0;
    float S1 = m + a * l0;
    float C2 = (a * P) / (P - S1);
    float CP = -C2 / P;

    float w0 = 1.0 - smoothstep(0.0, m, x);
    float w2 = step(m + l0, x);
    float w1 = 1.0 - w0 - w2;

    float T = m * pow(x / m, c) + b;
    float S = P - (P - S1) * exp(CP * (x - S0));
    float L = m + a * (x - m);

    return T * w0 + L * w1 + S * w2;
}

// Function 3343
float floordist(vec3 p)
{
    return p.y+2.85;
}

// Function 3344
float dist(in vec2 p){
    
    return length(p);
    //p = abs(p);
    //return max((p.x + p.y)*.7071, max(p.x, p.y));
    
}

// Function 3345
vec3 sceneNormalEdge(vec3 p, out float edge, float t)
{ 
	const float det = 0.02;
	vec3 e = vec3(0.0,det,0.0);

	float m;
	float d1=scene(p-e.yxx, m, t),d2=scene(p+e.yxx, m, t);
	float d3=scene(p-e.xyx, m, t),d4=scene(p+e.xyx, m, t);
	float d5=scene(p-e.xxy, m, t),d6=scene(p+e.xxy, m, t);
	float d=scene(p, m, t);
	
	edge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder
	//edge=min(1.0, pow(edge, 0.5)*20.0);
	edge *= 100.0;
	edge = clamp(0.0, 1.0, edge);
	return -normalize(vec3(d1-d2,d3-d4,d5-d6));
}

// Function 3346
float distort(vec3 p)
{
    //return sin(p.x + sin(p.y + time * .1) + sin(p.z)*p.z + p.x + p.y + time);
    return dot(tri(p+time) + sin(tri(p+time)), vec3(.666));
}

// Function 3347
vec4 renderScene(const vec3 ro, const vec3 rd)
{
  vec3 col = BACK_COLOR;
  vec2 res = trace(ro, rd);
  float t = res.x;

  vec3 pos = ro + t*rd,
       nor = calcNormal( pos, t),
       ref = reflect( rd, nor),
       lig = LIGHT_VEC;
  // Color
  col = .5 + .5*cos( 6.2831*res.y + vec3(0,1,2) );

  // lighting
  #ifdef WITH_AO
    float occ = calcAO4(pos, nor);
  #else
    float occ = 1.;
  #endif

  #ifdef WITH_SHADOWS
    float sh = .2+.8*shadow( pos, lig); //, 0.1, t );
  #else
    float sh = 1.;
  #endif

  #ifdef ONLY_AO
    col = (vec3)occ*(.5+.5*sh);
  #else
    float amb = .3;
    float dif = clamp( dot( nor, lig ), 0., 1.);
    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.);
    float dom = smoothstep( -.1, .1, ref.y );
    float fre = clamp(1.+dot(nor,rd),0.,1.);
    fre *= fre;
    float spe = pow(clamp( dot( ref, lig ), 0., 1. ),99.);

    vec3 lin = vec3(.3) +
        + 1.3*sh*dif*vec3(1., 0.8, 0.55)
        + 2.0*spe*vec3(1., 0.9, 0.7)*dif
        + 0.5*occ*(0.4*amb*vec3(0.4, 0.6, 1.) +
                   0.5*sh *vec3(0.4, 0.6, 1.) +
                  0.25*fre*vec3(1., 1., 1.));
    col *= lin;
  #endif

  // Shading.
  float atten = 1./(1. + t*.2 + t*.1); // + distlpsp*distlpsp*0.02
  col *= atten*col*occ;
  col = mix(col, BACK_COLOR, smoothstep(0.2, 1., t/MAX_DIST_RAYMARCHING));
  return vec4((col),t);
}

// Function 3348
vec3 distance_normal(vec3 pos){
    float d = surface_distance(pos);
    return normalize(vec3(
    surface_distance(pos + vec3(eps,   0,   0)) - d,
    surface_distance(pos + vec3(  0, eps,   0)) - d,
    surface_distance(pos + vec3(  0,   0, eps)) - d
    ));
}

// Function 3349
float dist(vec3 v){
	float s = 1.3;
	float r = mix(1.6, 1.8, 0.5*sin(2.0*iTime) + 0.5);
	
	float d = 1e10;
	d = d_union(d, -d_box(v, vec3(0), vec3(10.0)));
	d = d_union(d, d_box(v, vec3(0), vec3(2.0*s)));
	d = d_subtract(d, d_sphere(v, vec3(0), r));
	d = d_union(d, d_sphere(v, vec3(0), r*0.75));
	d = d_union(d, d_cylinder(v, vec3(0), vec3(1,0,0), 0.2, 10.0));
	d = d_union(d, d_cylinder(v, vec3(0), vec3(0,1,0), 0.2, 10.0));
	d = d_union(d, d_cylinder(v, vec3(0), vec3(0,0,1), 0.2, 10.0));
	return d;
}

// Function 3350
vec2 map(vec3 p){
    /*
	vec2 d = _sphere(p+vec3(sin(p.y*5.),0.,cos(p.y*5.))*.0,1.5,1.0999);
    d = _min(d, _sphere(p+vec3(sin(iTime*1.7),0.,cos(iTime*1.7))*3.,.5,0.0999));
    d = _min(d, vec2(-p.y+2.,1.5755));
	*/
    
    vec2 d;
    
    d = _sphere(p,2.,0.1300);
    float time = iTime*.15;
    
    for(int i=0;i<10;i++){
        p = abs(p);
        p.zx = rot(p.zx,vec2(0.),3.145*scalesin(time*.11579,.1,.15));
        p.zy = rot(p.zy,vec2(0.),3.145*scalesin(time*.78,.1,.3));
        p-=scalesin(time,1.01,3.);
    }

    d = _min(d,_box(p,vec3(.9,10.,0.9),1.8376*0.+1.9789));
    
    return d;
}

// Function 3351
float map( vec3 p )
{
    float d = p.z+1.13;
    //d = smin(d, 2.6-length(p), 1.5); // Uncomment to trap the man in a bubble
    float t = 1.5*iTime;
    d = min(d, fullMan(p, t));
    d = min(d, buildings(p+vec3(0.,0.,1.13), t));
    return d;
}

// Function 3352
float sample_dist_gaussian(vec2 uv) {
    const int nstep = 3;
    const float w[3] = float[3](1., 2., 1.);
    float d, wij, dsum = 0., wsum = 0.;    
    for (int i=0; i<nstep; ++i) {
        for (int j=0; j<nstep; ++j) {
            vec2 delta = vec2(float(i-1), float(j-1))/1024.;
            d = textureLod(iChannel3, uv-delta, 0.).w - 127./255.;
            wij = w[i]*w[j];
            dsum += wij * d;
            wsum += wij;
        }
    }
    return dsum / wsum;
}

// Function 3353
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 );

    #if (SHAPE == 0)
    res=opU( res, vec3( p.z, 0, 0 ) );
    #elif (SHAPE == 1)
    res = opU( res, vec3( length( p ) - 1.0, 0, 0 ) );
    #elif (SHAPE == 2)
    vec2 h = vec2( 0.95, 0.8 ); vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    res=opU( res, vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), 0, 0 ) );
    #elif (SHAPE == 3)
    vec3 tp=p;tp.zxy=opTwist( tp.zxy, 2.531 );
    res=opU( res, vec3( length( max( abs(tp) - vec3( 0.213 * 3.0, 0.978 * 3.0, 0.213 * 3.0 ), 0.0 ) ) - 0.10, 0, 0 ) );
    #elif (SHAPE == 4)
    res=opU( res, vec3( p.y + 1.5, 0, 0 ) );
    #endif

#if (DISPLACEMENT == 1)
    vec3 normal; Material material;
    material0( p, normal, 0., material );
    res.x -=material.bump/50.;
#endif
    res = opU( res, vec3( length( p - LIGHT1_POS ) - 1.0, 2, 2 ) );

    return res;
}

// Function 3354
vec2 brownConradyDistortion(vec2 uv, float dist)
{
    uv = uv * 2.0 - 1.0;
    // positive values of K1 give barrel distortion, negative give pincushion
    float barrelDistortion1 = 0.1 * dist; // K1 in text books
    float barrelDistortion2 = -0.025 * dist; // K2 in text books

    float r2 = dot(uv,uv);
    uv *= 1.0 + barrelDistortion1 * r2 + barrelDistortion2 * r2 * r2;
    //uv *= 1.0 + barrelDistortion1 * r2;
    
    // tangential distortion (due to off center lens elements)
    // is not modeled in this function, but if it was, the terms would go here
    return uv * 0.5 + 0.5;
}

// Function 3355
float map5( in vec3 p )
{
	vec3 q = p - vec3(0.0,0.1,1.0)*iTime;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q ); q = q*2.01;
    f += 0.06250*noise( q ); q = q*2.02;
    f += 0.03125*noise( q );
	return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

// Function 3356
v0 map(v2 pos, int processedMaterial
){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise
 ;maxGISize = 0.
 ;rayObj = 0
 ;v3 w = v3(pos,1)//worldSpace
 ;beginMaterial(0)
 ;SUB(REbox(w,v2(0,0,0),v2(10,2.5,10)))
 ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))
 ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))
 ;endMaterial()
 ;v3 c=beginObj(oCubeMy,w)//cubespace, not color
 ;//ADD(REbox(c,v2(0,0,0),v2(1)))
 ;//c.xz = abs(c.xz)
 ;for(int i=0;i<4;i++
 ){beginMaterial(i)
  ;ADD(sphere(c,v2(0,0,0),1.))
  ;endMaterial()
  ;c=abs(c)
  ;c=beginObj(oCubeChil,c);}
 ;v3 blackHoleSpace = beginObj(oBlackHole,w)
 ;beginMaterial(8)
 ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))
 ;endMaterial()
 ;v3 tunnelSpace = beginObj(oTunnel,w)
 ;beginMaterial(3)
 ;ADD(REbox(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))
 ;ADD(REbox(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))
 ;endMaterial()
 ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)
 ;beginMaterial(4)
 ;ADD(REbox(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))
 ;ADD(REbox(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))
 ;endMaterial()
 ;v3 trainSpace = beginObj(oTrain,w)
 ;beginMaterial(7)
 ;ADD(REbox(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))
 ;ADD(REbox(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))
 ;ADD(REbox(trainSpace,v2(0)      ,v2(.1,.1,.18)))
 ;ADD(REbox(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))
 ;ADD(REbox(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))
 ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))
 ;endObj()
 ;endMaterial()
 ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))
 ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5
 ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))
 ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)
 ;vma+=(1.-vma)*temp*AccretionDisk
 ;for(int L=0; L<3; L++
 ){
  ;ADD(sphere(w,oliPos[L]
              //o_lights[L].b
              ,0.001))
  ;
  ;v2 relPos = oliPos[L]-pos//o_lights[L].b
  ;oliHal[L]//o_lights[L].haloResult 
      += o*(0.02/(dot(relPos,relPos)+0.01))
  ;}
 ;return o;}

// Function 3357
float distDroid(vec3 p, vec3 pos, float scale) {
 
    float base = distCone(p, (pos + vec3(0.,0.,0.))*scale, vec3(1.));
    float eye  = distBox (p, (pos + vec3(.8,-.8,0.))*scale+vec3(.4,-.6,0.), vec3(.3,.1,.1)*2.);
    return smin(base, eye, 0.1);
    
}

// Function 3358
float o354278_input_sdf_b(vec3 p) {

return ((p)).y+1.0;
}

// Function 3359
float scene(vec3 p) {
	float scale = 1.0;
	float dist = 0.0;
	for (int i = 0; i < MENGER_ITERATIONS; i++) {
		dist = max(dist, -sdCrossRepScale(p, scale));
		scale *= 3.0;
	}
	return dist;
}

// Function 3360
float DistWalls( in vec3 p)
{
	return min(min(-p.z+10.0,-p.x+10.0),-p.y+10.0);
}

// Function 3361
float dist( in vec3 p)
{
    	float d= min(sdBox(mod(p, 2.)-1.,vec3(.1)),plane(p));
    	
    return d;
    
}

// Function 3362
float scene(vec3 p)
{
    // minified version
    p = abs(p);
    p += p.yzx;
    return (max(max(p.x,p.y),p.z)-1.) * sqrt(.5);
    
    // initial version - intersection of 3 planes in a mirrored space
    /*p = abs(p);
    float a = dot(p,normalize(vec3(0,1,1)))-sqrt(2.)*.5;
    float b = dot(p,normalize(vec3(1,0,1)))-sqrt(2.)*.5;
    float c = dot(p,normalize(vec3(1,1,0)))-sqrt(2.)*.5;
    return max(max(a,b),c);*/
}

// Function 3363
float DistRay(ray r, vec3 p) {
    return length(p-ClosestPoint(r,p));
}

// Function 3364
float sdf_Q_top(vec2 uv)
{
    uv.y -= .01;
    float dist = sdf_disk(uv, vec2(.5, .64), .36);
    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .74), .29));
    dist = sdf_union(dist, sdf_nail_v2(uv, vec2(.5, .61), vec2(.125, .57)));
    dist = sdf_exclude(dist, .95 - uv.y);
    return dist;
}

// Function 3365
float SceneSD(vec3 position)
{
    float distance = 1.0;
    
    vec3 repeat = RepeatLimited(position, REPEAT_DIST, vec2(-REPEAT_AMOUNT, REPEAT_AMOUNT));
    
    repeat = Elongate(repeat, vec3(0.5, 0.0, 0.35));
    repeat.y = position.y;
    
    vec3 id = GetID(position, REPEAT_DIST, REPEAT_HALF_DIST);
    
    if(Rand(id.xx) <= Rand(id.zx))
    {
        vec3 offset = repeat + vec3(0.0, -1.0, 0.0);  
        offset.y += sin(iTime * Rand(id.xz));
        
        float newDistance = TorusSD(offset, vec2(0.25, 0.1));
        if(distance > newDistance)
        {
            distance = newDistance;
            layerID = 3;
        }
    }
    
    if(Rand(id.zz) <= Rand(id.xz))
    {
        vec3 offset = repeat + vec3(0.0, -0.5, 0.0);  
        offset.y += sin((iTime * 0.75) * Rand(id.xz));
        
        float newDistance = TorusSD(offset, vec2(0.5, 0.1));
        if(distance > newDistance)
        {
            distance = newDistance;
            layerID = 2;
        }
    }

    {
        vec3 offset = repeat + vec3(0.0, -0.25, 0.0);  
        offset.y += cos((iTime * 0.15) * Rand(id.xz));

        float newDistance =  TorusSD(offset, vec2(0.75, 0.1));
        if(distance > newDistance)
        {
            distance = newDistance;
            layerID = 1;
        }
    }
    
    float newDistance = PlaneSD(position, vec3(0.0, 1.0, 0.0), 2.25);
    if(distance > newDistance)
    {
        distance = newDistance;
        layerID = 0;
    }
    
    return distance;
}

// Function 3366
vec4 map(vec3 p)
{
    float d = 1000.0;
    
    vec3 ip = p;
    
    float bs = 1.0;
    
    float r = 0.0;
    
    for (int i = 0; i < 4; ++i) {

        vec3 q = ip;
        
        float nbs = bs;
        bs *= 0.3;
        
        vec3 s = clamp(q, -nbs, nbs); 
        float fd = length(q) - nbs;
        
        vec3 aip = abs(ip);
        vec3 n = ip / max(aip.x,max(aip.y,aip.z));
        
        aip = abs(n);
        n -= sign(n) * min(aip.x,min(aip.y,aip.z));
        
		ip -= sign(n) * nbs;
        
        if (fd < d) {
            d = fd;
            r = float(i)/3.0;
        }
	}
    
    return vec4(d,vec3(r));
}

// Function 3367
float map(in vec3 p) {
    
    
   // Cubes, for a simpler, more orderly scene.
   //p = abs(fract(p) - .5);    
   //return max(max(p.x, p.y), p.z) - .225;
   
   // Unique identifier for the cube, but needs to be converted to a unique ID
   // for the nearest octahedron. The extra ".5" is to save a couple of 
   // of calculations. See below.
   vec3 ip = floor(p) + .5;
    
   p -= ip; // Break space into cubes. Equivalent to: fract(p) - .5.
    
   // Stepping trick used to identify faces in a cube. The center of the cube face also
   // happens to be the center of the nearest octahedron, so that works out rather well. 
   // The result needs to be factored a little (see the hash line), but it basically  
   // provides a unique octahedral ID. Fizzer provided a visual of this, which is easier 
   // to understand, and worth taking a look at.
   vec3 q = abs(p); 
   q = step(q.yzx, q.xyz)*step(q.zxy, q.xyz)*sign(p); // Used for cube mapping also.
   
   // Put the ID into a hash function to produce a unique random number. Reusing "q" to
   // save declaring a float. Don't know if it's faster, but it looks neater, I guess.
   q.x = fract(sin(dot(ip + q*.5, vec3(111.67, 147.31, 27.53)))*43758.5453);
    
   // Use the random number to orient a square tube in one of three random axial
   // directions... See Fizzer's article explanation. It's better. :) By the way, it's
   // possible to rewrite this in "step" form, but I don't know if it's quicker, so I'll
   // leave it as is for now.
   p.xy = abs(q.x>.333 ? q.x>.666 ? p.xz : p.yz : p.xy);
   return max(p.x, p.y) - .2;   

}

// Function 3368
float map(vec3 p)
{
    return length(shape(length(p),p.xy,length(p)-1.0))-1.5;
}

// Function 3369
vec3 eMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.25;
    rd *= 3.;
    
    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.
    
    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.
    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25+.25); 
    
}

// Function 3370
int Map_SeekSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos )
{    
    for(int iSectorIndex=0; iSectorIndex<NO_UNROLL( mapInfo.iSectorCount ); iSectorIndex++)
    {        
        if ( Map_PointInSector( mapSampler, mapInfo, vPos, iSectorIndex ) )
        {
            return iSectorIndex;
        }        
    }

    return SECTOR_NONE;
}

// Function 3371
float calculateDistanceToQuadraticBezier(vec2 p, vec2 a, vec2 b, vec2 c)
{
	b += mix(vec2(1e-4),vec2(0.),abs(sign(b*2.-a-c)));
	vec2 A = b-a;
	vec2 B = c-b-A;
	vec2 C = p-a;
	vec2 D = A*2.;
	vec2 T = clamp((solveCubic2(vec3(-3.*dot(A,B),dot(C,B)-2.*dd(A),dot(C,A))/-dd(B))),0.,1.);
	return sqrt(min(dd(C-(D+B*T.x)*T.x),dd(C-(D+B*T.y)*T.y)));
}

// Function 3372
vec2 brownConradyDistortion(in vec2 uv, in float k1)
{
    uv = uv * 2.0 - 1.0;	// brown conrady takes [-1:1]

    // positive values of K1 give barrel distortion, negative give pincushion
    float r2 = uv.x*uv.x + uv.y*uv.y;
    uv *= 1.0 + k1 * r2;
    
    // tangential distortion (due to off center lens elements)
    // is not modeled in this function, but if it was, the terms would go here
    
    uv = (uv * .5 + .5);	// restore -> [0:1]
    return uv;
}

// Function 3373
vec4 mipmap(vec2 uv) {
    return texture(iChannel0, uv);
}

// Function 3374
vec2 unionSDF(vec2 dist0, vec2 dist1) {
    return dist0.x < dist1.x? dist0 : dist1;
}

// Function 3375
float crystalSDF(vec3 p, in vec2 cell) {
    float h = cellHeight(cell);
    p.y -= h - 100.0;
    
    //return rbox(-p,vec2(0.4,100.0).xyx);
    
    p.xz = rotateZ(p.xz,sin(iTime)+(h-2.0));
    vec3 rp = vec3(rotateZ(p.xz,PI*0.25),p.y).xzy;
    float d = rbox(-rp,vec2(0.45,100.0).xyx);
	d = max(d, rbox(-p,vec2(0.45,100.0).xyx));
    d = max(d, octahedron(p,100.0));
    return d;
}

// Function 3376
vec4 traceScene(in Camera cam, vec2 seed) {
    vec3 startPos = cam.pos;
    
    vec4 result = vec4(0);
    
    float eps = 0.0;
    
    for (int i=0; i<MAXRAYS; i++) {
    	Ray r = cam.ray;
        
        r.dir.x += (nrand(seed)*2.-1.) * divergence;
        r.dir.y += (nrand(seed.yx)*2.-1.) * divergence;
        r.dir.z += (nrand(seed.xx)*2.-1.) * divergence;
        r.dir = normalize(r.dir);
        vec4 impact = vec4(BRIGHTNESS);
        seed++;
        
        for (int j=0; j<MAXBOUNCES; j++) {
    		HitTest t0 = intersectBox(r, Box(vec3(0,10,0), vec3(30,20,25)));
    		HitTest t1 = intersectSphere(r, Sphere(vec3(-1,2,0), 2.0));
            t1.col = vec4(1);
    		HitTest t2 = intersectSphere(r, Sphere(vec3(4,5,4), 5.0));
            t2.col = vec4(1,1,0,1);
    		HitTest t3 = intersectSphere(r, Sphere(vec3(-10.,6,0.), 1.0));
    		HitTest t4 = intersectSphere(r, Sphere(vec3(0,20,0), 10.0));
    		
    		HitTest test = minT(t0, t1, t2, t4);//, t4);
    	
    		if ((test == t3) && test.hit) { 
        	    result += vec4(1) * impact;
        	    break;
        	} else if ((test == t4) && test.hit) { 
        	    result += vec4(1) * impact;
        	    break;
        	}
    		if (test.hit) {
        	    r.origin += r.dir * test.dist;
                r.origin += test.normal * 0.01;
                vec3 random = vec3(
        		            nrand(r.origin.xy+seed),
        		            nrand(r.origin.yz+seed),
        		            nrand(r.origin.zx+seed)
        		            )*2. - 1.;
               	//random = normalize(random);
                eps += divergence * test.dist*0.1;
                r.dir = normalize(mix(
                    test.normal + random,
                    reflect(r.dir, test.normal),
                    test.ref
                    ));
                r.origin += r.dir * eps;
                //r.dir = test.normal;
        		impact *= test.col;
            } else {
                break;
            }
        }
    }
    return result / float(MAXRAYS);
}

// Function 3377
vec3 eMap(vec3 rd, vec3 sn){
    
    
    // Add a time component, scale, then pass into the noise function.
    rd.y += iTime;
    rd /= 3.;

    // Biotube texturing.
    float ct = cellTile(rd*2. + sin(rd*12.)*.5)*.66 + cellTile(rd*6. + sin(rd*36.)*.5)*.34;
    vec3 texCol = (vec3(.25, .2, .15)*(1.-smoothstep(-.1, .3, ct)) + vec3(0.02, 0.02, 0.53)/6.); 
    return smoothstep(0., 1., texCol);
    
}

// Function 3378
float map( in vec3 q )
{
    float h = q.y;

    q *= 0.01*vec3(0.5,1.0,0.5);
    
	float f;
    f  = 0.500000*abs(noise( q )); q = q*2.02;
    f += 0.250000*abs(noise( q )); q = q*2.03;
    f += 0.125000*abs(noise( q )); q = q*2.01;
    f += 0.062500*abs(noise( q )); q = q*2.02;
    f += 0.031250*abs(noise( q )); q = q*2.03;
  //f += 0.015625*abs(noise( q ));
    f = -1.0 + 2.0*f;
    
    f = mix( f, -0.1, 1.0-smoothstep( h, 50.0, 60.0 ));
    f = mix( f, -0.1, 1.0-smoothstep( h, 250.0, 300.0 ));
    f += 0.17;

    return f;
}

// Function 3379
float map( in vec3 p )
{
	float d = -box(p-vec3(0.,10.,0.),vec3(10.));
	d = min(d, box(rotate(vec3(0.,1.,0.), 1.)*(p-vec3(4.,5.,6.)), vec3(3.,5.,3.)) );
	d = min(d, box(rotate(vec3(0.,1.,0.),-1.)*(p-vec3(-4.,2.,0.)), vec3(2.)) );
	d = max(d, -p.z-9.);
	
	return d;
}

// Function 3380
float distanceToNearestSurface(vec3 p){
    return length(p) - 1.0;
}

// Function 3381
float map2(vec3 p) {
	p=morph(p); // morph the world into plane, cylinder or sphere

	vec3 bp=p;
	vec2 uv=p.xz;

	vec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));
	
	vec2 ad=vec2(0);
	p=kalei(p,ad); // kaleidoscopic folding for the city
	
	float d=box(p, vec3(0.4));
	
	at+=1./(d+0.1);

	float city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );

	d=min(d,city);
	localp=p;

	vec3 rp=p;
	rp.xz=rep(rp.xz,0.5);
	rp.xz+=off*0.05;
	// fields
	float blob=box(p-vec3(3,0,0), vec3(1.6));
	d=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));
	
	vec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));
	d=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid
			
			
	// terrain/mountain
	d=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain
			
	mat=abs(d-city)<0.01?1.:0.;

	d=max(d,0.00001); // anti glitch? avoid some nan/inf values
	
	return d;
}

// Function 3382
vec3 drawPerspectiveScene(Cam perspectiveCam, vec2 uv, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, vec3 cBackground, float fZoom)
{
    vec3 cScene = cBackground;
    cScene = texture(iChannel0,uv+0.5).xyz;
    
	float fLineWidth = 0.0025;
    cScene = drawLine(uv, ssQuad.a, ssQuad.b, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.b, ssQuad.c, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.c, ssQuad.d, cScene, vec3(0), fLineWidth, fZoom);
    cScene = drawLine(uv, ssQuad.d, ssQuad.a, cScene, vec3(0), fLineWidth, fZoom);
    
    float fPointRad = 0.006;
    cScene = drawPoint(uv, ssQuad.a, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.b, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.c, cScene, vec3(0,1,0), fPointRad, fZoom);
    cScene = drawPoint(uv, ssQuad.d, cScene, vec3(0,1,0), fPointRad, fZoom);
    
    //Show results
    fPointRad = 0.004;
    vec2 aDebug = camProj(perspectiveCam,wsQuad.a);
    vec2 bDebug = camProj(perspectiveCam,wsQuad.b);
    vec2 cDebug = camProj(perspectiveCam,wsQuad.c);
    vec2 dDebug = camProj(perspectiveCam,wsQuad.d);
    cScene = drawPoint(uv, aDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, bDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, cDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    cScene = drawPoint(uv, dDebug, cScene, vec3(0,0,1), fPointRad, fZoom);
    
    return cScene;
}

// Function 3383
vec2 uvmap(vec2 uv)
{
    return ( 2.*uv - iResolution.xy)* 1.5 /iResolution.y;
}

// Function 3384
float map(vec3 p) {
    float d = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));
    
    float rot_x = iTime * 3.1415 * 0.2;
    float cx = cos(rot_x);
    float sx = sin(rot_x);
    
    float rot_z = iTime * 3.1415 * 0.125;
    float cz = cos(rot_z);
    float sz = sin(rot_z);
    
    p = vec3(
        p.x,
        p.y * cx - p.z * sx,
        p.z * cx + p.y * sx
    );
    
    p = vec3(
        p.x * cz - p.y * sz,
        p.y * cz + p.x * sz,
        p.z
    );
    
    d = opU(d, sdBox(p - vec3(0.0, 1.5, -1.5), vec3(1.6, 1.5, 0.1)));
    d = opU(d, sdBox(p - vec3(1.5, 1.5, -0.25), vec3(0.1, 0.75, 2.25)));
    
    d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75, 0.75, -0.75), vec3(0.75 - 0.025)) - 0.025, 0.1));
    //d = opU(d, opU_v2(sdSphere(p, 1.0), sdBox(p - vec3(0.75 * 3.0, 0.75, -0.75 * 3.0), vec3(0.75)) - 0.025));
    
    return d;
}

// Function 3385
float waterMap(vec3 p) {
    return p.z - (texture(iChannel0, fract(p.xy)).r+texture(iChannel0, fract(p.xy)).g);
}

// Function 3386
float MapLights( vec3 p)
{
  vec3 pOriginal = p;
  // rotate position 
  p=TranslatePos(p, pitch, roll);   
  // mirror position at x=0.0. Both sides of the plane are equal.
  pMirror(p.x, 0.0);

  return max(sdEllipsoid( p- vec3(0.4, -0.1, -9.5), vec3(0.03, 0.03, 0.03+max(0., (speed*0.07)))), -sdBox(p- vec3(0.4, -0.1, -9.6+2.0), vec3(2.0, 2.0, 2.0)));
}

// Function 3387
float triangleDistance(vec3 p, vec3 v0, vec3 v1, vec3 v2) {
  return distance(p,closestTriangle(p,v0,v1,v2));
}

// Function 3388
vec4 GetDistanceCylinderMaterialSelectorZ(const in vec3 vPos, const in float r, const in float segcount)
{
	
	//+ PI
	vec3 vNorm = normalize(vPos);
	float atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;
	//float segment = (segcount-1.0) - mod((floor(atn * (segcount - 0.5) ) + 2.0),segcount);
	float segment = floor(atn * segcount);

	float seg_norm = mod((segment / segcount) + 0.25, 1.0);
	float d = length(vPos.xy) - (r);// + segment * 0.1);
	return vec4(d,seg_norm , vNorm.x, vNorm.y);
}

// Function 3389
vec3 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    float accum = 0.;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) 
    {
        vec3 current = eye + depth * marchingDirection;
        float dist = sceneSDF( current );
        if (dist < EPSILON) 
        {
            vec3 samplePoint = current;

            // Inversion
            float t = dot( samplePoint, samplePoint );
            samplePoint /= t;

            // Move the points and mod to get a repeating grid.
            float spacing = 0.15;
            samplePoint.xy += vec2( iTime*spacing/2., spacing/2. );
            Mod2D( samplePoint.xy, vec2( spacing, spacing ) );

			// Calc the point intentsity.
            float pint = particleColorInt( samplePoint.xy );
            return vec3( pint, depth, 0. );
        }

        depth += dist;
      
        if (depth >= end) 
        {
            return vec3( 0., end, 0. );
        }
    }
    
    return vec3( 0., end, 0. );
}

// Function 3390
vec4 mapText(vec2 p, vec2 tp, float s, ivec4 text) { 
    vec4 chr = vec4(0.);
    int k = 0;
    p -= tp;
    p+=vec2( .5/s );
    p *= vec2(s);
    int ip = 0;
    float len = 0.;
    for ( int i = 0; i < 20; i++){					 	// ivec4( 0x_01_02_03_04, 0x_05_06_07_08, 0x_09_10_11_12, 0x_13_14_15_16 )
        int chv = map(text,k); // text[k] 
        if (chv == 0) break; 					 	// nothing to process then break
        if (ip == 4) {
            k++; ip=0; // continue; // next index to process
        } else
        {
            //int ch = (chv >> (8*(3-( ip % 4)))) % 256;		// ascii code from ivec4 

            int ch =  modi((shift(chv, 8*(3-(modi((ip),4))))),256); // compatibility mode
            
            if (ch == 0) {
                ip++; //continue; 								// next index to process
            }else
            {
                chr = max(chr,  char(p, ch).x); 				// draw           
                len++;
                p-=vec2(float(.5),0.);						 	// move postion to next char
                ip++;											// next char
            }                
        }
    }  
    return vec4(chr.xyz, len);                   
}

// Function 3391
float map(vec3 rp)
{
    // sphere pos
    vec3 pos = rp - vec3(1.0, -1.0, 0.0); 
    
    pos.z -= 0.035;
    
    // movements
    pos.x += iTime * 0.5;
    pos.y -= m().y*8.0;
    pos.x -= m().x*8.0;
    
    // repeat coordinates
    pos = mod(pos, vec3(2))-0.5 * vec3(2);
    
    // Endless filled space that starts in front of the camera 
    float res = 2.00001 - rp.z;
    
    // subtract from the space using spheres
    res = opSub(length(pos) - 1.33, res);
   
    return res;
}

// Function 3392
float map(vec3 p)
{
    float radius = 0.25; // or change to 0.1 for carpet like look
    vec3 q = fract(p*=2.5) * 1.5 - 0.5;
    
    return sphere(q, radius);
}

// Function 3393
vec2 map(in vec3 pos)
{
    vec2 d = vec2(1e10, 0.0);
    float b= asin(sin(pos.z*.2 +  tt));
    //float an = sin(iTime);
	
    for(int i=0;i<3;i++){
        pos=abs(pos);
        pos.xy*=r2(.000148);
        pos.yz*=r2(iTime*sin(pos.x*.25)*.00025);
    }
    

    vec3 q = pos - vec3(0.0,0.0,0.0);
    q = rotate_x(q, PI * iTime * .25);
    q = rotate_y(q, -PI * iTime * .35);
    q = rotate_z(q, -PI * iTime * .5);
    
    vec2 d1 = sdBox(q, vec3(0.6,0.5,0.6), .5 );
    vec2 d2 = sdBox(q, vec3(0.7,0.1,0.7), .5 ); 
    vec2 dt = max(-d1,d2);
    
    //g+=0.1/(.01+d1.x*d1.x*999.) * sin(tt  * .3);
    //g-=0.1/(0.1*dt.x*dt.x*(20.-abs(sin(abs(q.x*.1)-tt*3.))*1.7));
    
    d = d.x < dt.x  ? d : dt;
    
    q = rotate_y(q,  -PI * iTime * .25);
    
    vec2 d3 = sdBox(q, vec3(0.5,0.5,0.5), .3 );
    vec2 d4 = sdBox(q, vec3(0.6,0.1,0.6), .3 ); 
    dt = max(d3,d4);
    vec2 d5 = sdBox(q, vec3(0.4,0.8,0.4),  .5 );
    vec2 dt2 = max(-d5, dt);
    g+=(0.1/(.01+d5.x*d5.x*999.) * sin(iTime  * .5));
    d = d.x < dt.x  ? d : dt2;
    
    dt = max(-d5,d);
	
    d = d.x < dt.x  ? d : dt;
    
    q = rotate_z(q, PI * iTime * .5);
    vec2 d6 = sdBox(q, vec3(.3,0.1, .3), .7 );
    
    
    d = d.x < d6.x  ? d : d6;
    
    return d;
}

// Function 3394
float distMetric(vec3 p, vec3 b, int id){
    
    
    if(id==0){
    	return (dot(p, p));///2.; // Sphere squared.
    }
    else {
        
        //float d2 = sBoxS(p.xy, b.xy, 0.);
        float d2 = sdHexagon(p.xy, min(b.x, b.y));
        return opExtrusion(d2, p.z, b.z);

        
        //return (dot(p, p));
        //return length(p); // Standard spherical Euclidean distance.

        //return max(max(length(p.xy), length(p.yz)), length(p.xz)); // Cylinder cross.

        //p = max(abs(p)*.8660254 + p.yzx*.5, -p);
        //return max(max(p.x, p.y), p.z); // Triangular.

        // Uncomment this for all metrics below.
        p = abs(p) - b;
        
        
        //p = (p + p.yzx)*.7071;
        //return max(max(p.x, p.y), p.z); // Can't remember -- Diamond related. :)


        return max(max(p.x, p.y), p.z); // Cube.
        //return (p.x + p.y + p.z)*.5;//7735; // Octahedron.

        //p = p*.8660254 + p.yzx*.5;
        //return max(max(p.x, p.y), p.z); // Hex.

/*        
        float taper = (p.x + p.y + p.z)/3.*2.*.65 + .35; // Linear gradient of sorts.
        //float taper = p.y + .5; // Original.
        //taper = mix(taper, max(taper, .5), .35); // Flattening the sharp edge a bit.

        p = abs(p)*2.;
        //p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; // Used with triangle.

        float shape = max(max(p.x, p.y), p.z); // Square.
        //float shape = max(p.x*.866025 - p.y*.5, p.y); // Triangle.
        //float shape = max(p.x*.866025 + p.y*.5, p.y); // Hexagon.
        //float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); // Octagon.
        //float shape = length(p); // Circle.
        //float shape = dot(p, p); // Circle squared.


        //shape = (shape - .125)/(1. - .125);
        //shape = smoothstep(0., 1., shape);


        //return shape;
        return max(shape, taper);
*/
    }
    
}

// Function 3395
float remap_noise_tri_erp( const float v )
{
    float r2 = 0.5 * v;
    float f1 = sqrt( r2 );
    float f2 = 1.0 - sqrt( r2 - 0.25 );    
    return (v < 0.5) ? f1 : f2;
}

// Function 3396
float Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )
{
    float fOcclusion = 0.0;
    float fScale = 1.0;
    for( int i=0; i<5; i++ )
    {
        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;
        vec3 vAOPos = vDir * fOffsetDist + vPos;
        float fDist = Scene_GetDistance( vAOPos ).fDist;
        fOcclusion += (fOffsetDist - fDist) * fScale;
        fScale *= 0.4;
    }
    
    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );
}

// Function 3397
maybe_vec2 get_distances_along_2d_line_to_circle(
    in vec2 A0,
    in vec2 A,
    in vec2 B0,
    in float r
){
    vec2 D = B0 - A0;
    float xz = dot(D, A);
    float z2 = dot(D, D) - xz * xz;
    float y2 = r * r - z2;
    float dxr = sqrt(max(y2, 1e-10));
    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);
}

// Function 3398
float heightmap(vec2 worldPos, int iterations) {
    const float scale = 0.13;
    vec2 p = worldPos * scale;
    vec2 p2 = (artifactOffset.xz - vec2(0.0, 1.0)) * scale;
    float d = clamp(length(p2 - p) / 0.8, 0.0, 1.0);
    d = (1.0 - smoothstep(0.0, 1.0, d)) * 0.8;
    float angle     = 0.0;
    float freq      = 5.0;
    float speed     = 2.0;
    float weight    = 1.9;
    float wave      = 0.0;
    float waveScale = 0.0;
    vec2 dir;
    vec2 res;
    for (int i = 0; i < iterations; i++) {
        dir = vec2(cos(angle), sin(angle));
        res = getWave(p, dir, speed, freq, time);
        p += dir * res.y * weight * 0.05;
        wave += res.x * weight - d;
        angle += 12.0;
        waveScale += weight;
        weight = mix(weight, 0.0, 0.2);
        freq *= 1.18;
        speed *= 1.06;
    }
    return wave / waveScale;
}

// Function 3399
float sceneDistance( vec3 point ) {
    float d = planetSDF( point );
    d = min( d, stars( point ) );
    d = min( d, ufo( point ) );   
    return d;
}

// Function 3400
vec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)
{
    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.
    // Used for reflection off the surface of the object, and refraction out the back of the object.
    
    // if we hit the box, return the lit box color
    vec2 uv;
    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);
    if (rayInfo.x >= 0.0)
        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);
    // else return skybox color
    else
        return texture(iChannel0, rayDir).rgb;
}

// Function 3401
float sdf_half0_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, -pos.y);
}

// Function 3402
maybe_float get_distance_along_3d_line_nearest_to_ray(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 B
){
    vec3 D = B0 - A0;
    // offset
    vec3 R = D - dot(D, A) * A;
    // rejection
    float xB = length(R) / dot(B, normalize(-R));
    // distance along B
    float xA = xB / dot(B, A);
    // distance along A
    return maybe_float(xB, abs(abs(dot(A, B)) - 1.f) > 0.f && xA > 0.f);
}

// Function 3403
float chainsdf(vec3 pos) {
    int i;
    vec3 a = getpos(0.);
    vec3 b = getpos(1.);
    float d = exp(-capsulesdf(pos, a, b) * sharpness);
    for (i=2; i<numpts; i++) {
        a = b;
        b = getpos(float(i));
        d += exp(-capsulesdf(pos, a, b) * sharpness);
    }
    return -log(d) / sharpness;
}

// Function 3404
vec3 sceneGrad(highp vec3 p)
{
    const highp float h = GRAD_EPS;
    highp vec3 g;
    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;
    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;
    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;
    return g;// / (2.0*h);
}

// Function 3405
float charDistance(vec2 p, float char) {
  return texture(
        iChannel0, 
        p/16. + fract( vec2(char, floor(15. - char / 16.)) / 16. )
    ).w;  
}

// Function 3406
vec4 renderScene(vec2 fragCoord, const ivec2 formatSize, const vec3 eyePos, const vec3 eyeTarget, const float focalLength)
	{
		mat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);
		vec2 o = (fragCoord - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));
		vec3 rayOrigin = vec3(o, 0.0) + eyePos,
		     rayDirection = normalize(camera*vec3(o, focalLength));
		vec3 res = castRay(rayOrigin, rayDirection);
		vec3 p = rayOrigin + rayDirection * res.x;
		vec3 n = calcNormal(p, rayDirection);
		return renderMaterial(fragCoord, p, n, res.y);
	}

// Function 3407
float map(vec3 p)
{
    p = p * mat;
    float d = udRoundBox(p, vec3(SIZE/4., SIZE/4., SIZE/4.), SIZE/ 5.0);
    return d;
}

// Function 3408
float mapDE(vec3 p)
{
    float d;
    p.xz *= .3;

    float disp = turbulence(p)*16.0;
    d = smoothstep( 0.1, .7, textureLod(iChannel1, p.xz*.00015+.1, 0.).y)*4.0;
    d += smoothstep( 0.,.8, textureLod(iChannel2, p.xz*.0002+.4, 0.).y)*3.;
    d += smoothstep( 0.,.6, textureLod(iChannel2, p.xz*.0004+.2, 0.).y)*1.5;
    d =  max(d*d*8.0, 0.0)+disp;
    
    // Ridges
    float s = sin(p.x*.02-p.z*.044)*12.0+33.; 
    float w = mod(d, s)/s;
	w = w*w*(3.0-2.0*w);
    d = (floor(d / s) * s) + w * s;
    
    return (p.y +70.0 - d);
}

// Function 3409
vec3 sceneGrad(vec3 p) {
    vec2 epsi = vec2(0.001,0.0);
    float d1 = scene(p);
    return normalize(vec3(
        scene(p+epsi.xyy) - d1,
        scene(p+epsi.yxy) - d1,
        scene(p+epsi.yyx) - d1
    ));
}

// Function 3410
float makeScene(vec3 pos) {
    float blobVelocity = 1.0;
    
    // BECAUSE THIS IS THE CENTER BLOB, THE POSITION IS LEFT EXACTLY AS IT IS
    float s1 = sphere(pos);
    
    // BECAUSE THIS BLOB ROTATES AROUND THE CENTER BLOB, ITS POSITION IS OFFSET USING SIN/COS OSCILLATION.
    // IF THE CENTER OF THE NEW BLOB IS, FOR EXAMPLE, (2,1) AWAY FROM THE TRUE CENTER, THEN WE CALL THE
    // "SPHERE" FUNCTION AGAIN USING THE NEW OFFSET VALUE OF (2,1).
    vec3 posOffset = pos + blobVelocity * vec3(cos(iTime * 0.7),cos(iTime *1.9),cos(iTime * 2.3));
    float s2 = sphere(posOffset);
    
    return makeBlobs(s1, s2);
}

// Function 3411
float map(vec3 p) {
    const float M = 0.6;
    float time = iTime + rsq(iTime*0.5) * 2.0;
    return julia(p,vec4( 
        sin(time*0.96456)*0.451*M,
        cos(time*0.59237)*0.435*M,
        sin(time*0.73426)*0.396*M,
        cos(time*0.42379)*0.425*M
    ));
}

// Function 3412
float scene(vec3 pos)
{
    float dist = 0.0;
    dist = opTwist(pos);
    return dist;
}

// Function 3413
float mapCore (vec3 p) {
    float scene = 1.;
    
    // number of torus repeated
    float count = 10.;
    float a = p.x*2.;
    
    // displace space
    p.xz *= rot(p.y*6.);
    p.xz *= rot(t);
    p.xy *= rot(t*.5);
    p.yz *= rot(t*1.5);
    vec3 p1 = posCore(p, count);
    vec2 size = vec2(.1,.2);
    
    // tentacles torus shape
    scene = min(scene, sdTorus(p1.xzy*1.5,size));
    
    // sphere used for intersection difference with the toruses
    scene = max(-scene, sdSphere(p,.6));
    return scene;
}

// Function 3414
float remap(in float n) {
    return mix(4.333 * sin(iTime * 0.25), 4.333, n);
}

// Function 3415
float beckmannDistribution_6_0(float x, float roughness) {
  float NdotH = max(x, 0.0001);
  float cos2Alpha = NdotH * NdotH;
  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;
  float roughness2 = roughness * roughness;
  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;
  return exp(tan2Alpha / roughness2) / denom;
}

// Function 3416
float remap(float f, float in1, float in2, float out1, float out2) { return mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.)); }

// Function 3417
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){
    
    vec2 e = vec2(2.5/iResolution.y, 0);
    
    float f = bumpFunction(p); 
    
    // Samples about the hit point in each of the axial directions.
    float fx = bumpFunction(p - e.xyy); // Same for the nearby sample in the X-direction.
    float fy = bumpFunction(p - e.yxy); // Same for the nearby sample in the Y-direction.
    float fz = bumpFunction(p - e.yyx); // Same for the nearby sample in the Y-direction.

    // Samples from the other side.
    float fx2 = bumpFunction(p + e.xyy); // Same for the nearby sample in the X-direction.
    float fy2 = bumpFunction(p + e.yxy); // Same for the nearby sample in the Y-direction.
    float fz2 = bumpFunction(p + e.yyx); // Same for the nearby sample in the Y-direction.
    
    // We made three extra function calls, so we may as well use them. Taking measurements
    // from either side of the hit point has a slight antialiasing effect.
    vec3 grad = (vec3(fx - fx2, fy - fy2, fz - fz2))/e.x/2.;   

    // Using the samples to provide an edge measurement.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.)+ abs(fz + fz2 - f*2.);
    edge = smoothstep(0., 1., edge/e.x);
          
    grad -= n*dot(n, grad);          
                      
    return normalize( n + grad*bumpfactor );
	
}

// Function 3418
float sdf_m(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half0_torus(pos, vec3(6, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(8, -4, 0), vec3(8, -8, 0)));
    
    return t;
}

// Function 3419
vec4 distField(vec2 p){

    
    // Offset field position for the central dots. See below.
    vec2 q = p - .5;
    
   
    // Standard square grid ID and local position.
    vec2 ip = floor(p) + .5;
    p -= ip;
    
    // Vertice and edge postions... Probably overkill for such a simple example,
    // but it's a good habit to get into when dealing with more complex setups.
    const vec2[4] v = vec2[4](vec2(-.5, .5), vec2(.5),  vec2(.5, -.5),  vec2(-.5));
    const vec2[4] e = vec2[4](vec2(0, .5), vec2(.5, 0),  vec2(0, -.5),  vec2(-.5, 0));
    
    
    
    // Distance field place holder.
    vec4 d = vec4(1e5);
  
    // Edge width.
    float ew = .13;
    
   
    // Using the cell ID for some unique random numbers.
    float rnd = hash21(ip);
    float rnd2 = hash21(ip + .37);
    #ifdef RANDOM_TRUCHET
    float rnd3 = hash21(ip + .73);
    #endif
    
    // Checkered arrangement: The black and white chessboard arrangement comes up
    // in so many different situations that it's worth committing to memory. In this
    // case we are aligning all double arc tiles either horizontally or vertically,
    // depending upon which checker we're on.
    float check = mod(ip.x + ip.y, 2.);
    
    
    // Render overlapping lined crosses on half the tiles. You could change the
    // percentage, if you wanted.
    if(rnd<.5){
        
        // X and Y nudge factors to produce the Bezier kinks.
        #ifdef STRAIGHT_LINES
        // No kind for the straight lines.
        const vec2 ndgX = vec2(0);
        vec2 ndgY = vec2(0);
        #else
        // Kink the horizontal lines up and the vertical lines
        // to the left. If the tiles get rotated, they will switch
        // to down and right, which makes sense.
        const vec2 ndgX = vec2(-.075, 0);
        vec2 ndgY = vec2(0, .075);
        #endif
        
        // Randomly rotate some of the tiles: This has the effect of putting
        // the top line on the bottom. The nudge factor has to be reversed
        // to keep the line kinks pointing in the right direction.
        if(rnd2<.5) {
            p = rot2(3.14159/2.)*p;
            ndgY *= -1.;
        }  
        
         
        // Rendering the Bezier lines, which aren't much different to normal lines, except there's
        // an additional anchor point to give it a curved appearance. IQ wrote the Bezier algorithm
        // itself, which wouldn't have been easy.
        //
        // Bottome line.... All of these join together at their end points.
        d.x = min(d.x, sdBezier(p, e[2]*1., e[2] + vec2(0, .1), e[2] + vec2(0, .25) + ndgX/3.) - ew);
        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., e[0] - vec2(0, .1), e[0]*1.) - ew);
        d.x = min(d.x, sdBezier(p, e[0] - vec2(0, .25) + ndgX/3., ndgY, e[2] + vec2(0, .25) + ndgX/3.) - ew);
        
        // Top line.
        d.y = min(d.y, sdBezier(p, e[3]*1., e[3] + vec2(.1, 0), e[3] + vec2(.25, 0) + ndgY/3.) - ew);
        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., e[1] - vec2(.1, 0), e[1]*1.) - ew);
        d.y = min(d.y, sdBezier(p, e[1] - vec2(.25, 0) + ndgY/3., ndgY, e[3] + vec2(.25, 0) + ndgY/3.) - ew);
        
        // Tile ID: Zero for a cross.
        d.w = 0.;
    }
    else {
        
        // The line here is the only difference between Paulus Gerdes's Tchokew inspired sand pattern
        // arrangement and a regular double tiled Truchet pattern... If you look at the comments on
        // Fabrice Neyret's original Shadertoy pattern you'll see that I'm kind of convinced of that,
        // but I'm not positive... Either way, it's a pretty pattern, so whatever. :D
        //
        // As you can see, I've provided an option to randomly rotate tiles as well, which will 
        // produce the common double tiled pattern that you've probably seen all over the place.
        //
        #ifdef RANDOM_TRUCHET
        if(rnd3<.5) p = rot2(3.14159/2.)*p; // Random rotation.
        #else
        if(check<.5) p = rot2(3.14159/2.)*p; // Checker pattern constained rotation.
        #endif 
        
        // The two quarter arcs: You could put an arc in each of "d.x" and "d.y," however,
        // we're joining both together in the top layer, just in case there's overlap.
        //d.x = abs(length(p - v[0]) - .5) - ew;
        //d.y = abs(length(p - v[2]) - .5) - ew;
        
        d.y = abs(length(p - v[0]) - .5) - ew;
        d.y = min(d.y, abs(length(p - v[2]) - .5) - ew);
        
        // Tile ID: One for regular double arcs.
        d.w = 1.; 
        
    }
    

    // The distance field for the central black dots.
    vec2 ip2 = floor(q) + .5;
    q -= ip2;
    if(mod(ip2.x + ip2.y, 2.)<.5){
        d.z = min(d.z, length(q));
        d.z -= ew*.8;
	}

    
    // Return the tile one and two, the central dots and ID.
    return d;
}

// Function 3420
float distFunc(vec3 pos)
{
    float d1 = distSphere(pos);
    float d2 = distPlane(pos, planePos);
    float d3 = distTorus(pos, torusSize);
    return min(d3, min(d1, d2));
}

// Function 3421
vec3 spheremapUnpack(vec2 n) {
    vec4 nn = vec4(2.0 * n - 1.0, 1.0, -1.0);
    float l = dot(nn.xyz,-nn.xyw);
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2.0 + vec3(0.0, 0.0, -1.0);
}

// Function 3422
vec2 map_slime(vec3 pos)
{
    pos.y+= 2.8;
    float slime = udRoundBox(pos, vec3(5.35, 1.35, 1.85), 0.6);
    return vec2(max(slime, pos.y -0.45), SLIME_OBJ);
}

// Function 3423
float distanceTo(float x, float y, float centerX, float centerY) {
	float deltaX = x - centerX;
    float deltaY = y - centerY;
    return sqrt(deltaX * deltaX + deltaY * deltaY);
}

// Function 3424
float SphereSDF(vec3 eye, vec3 p, float r)
{ 
	return distance(p,eye) - r;
}

// Function 3425
float distance_to_line_segment(vec2 p, vec2 a, vec2 b){
    vec2 ba = b - a;
    float u = clamp(dot(p - a, ba)/dot(ba, ba), 0.0, 1.0);
    vec2 q = a + u*ba;
    return distance(p, q);
}

// Function 3426
vec3 centerDistribution(vec2 cen){
    vec3 col = vec3(0.0);
    col += vec3(1.0) * pow(random(cen), 30.0);
    col += vec3(0.3, 0.3 , 0.8) * pow(random(cen), 200.0);
    col += vec3(0.8, 0.5, 0.0) * pow(random(cen + random(vec2(random(cen), col))), 20.0);

    return col;
}

// Function 3427
float objdistance(vec3 p){
   return min(plane(p.y,-2.0),plane(-p.y,-1.0));
   //return min(plane(sin(p.z)*0.3+sin(p.x+iTime*8.0)*0.3+p.y,-2.0),plane(-p.y,-1.0)); //use raymarching
}

// Function 3428
float mapstage5 (in vec3 p)
{
   float d1 = length(p) - 1.0;
   //modulate on the x
   d1 += 0.1* sin(10.0 * p.x); 
   float d2 = p.y + 1.0;
   return min (d1,d2);
}

// Function 3429
void intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)
{
    float tSphere6 = intersectSphere(ro, rd, sfere[3]);
    if(tSphere6 < t && bl) { t = tSphere6;i=6;}

   	/*float tSphere = intersectSphere(ro, rd, sfere[0]);
    if(tSphere < t) { t = tSphere;i=0;}
   	tSphere = intersectSphere(ro, rd, sfere[1]);
    if(tSphere < t) { t = tSphere;i=1;}*/
   	float tSphere = intersectSphere(ro, rd, sfere[2]);
    if(tSphere < t) { t = tSphere;i=2;}

}

// Function 3430
vec2 map(in vec3 pos) {	

    float d = mix(sdCube(pos,0.5773), length(pos)-1.0, sphere_fraction);    
    vec2 rval = vec2(d, 3.0);

    return rval;

}

// Function 3431
float map( vec3 p ) {
    // rotate the world
	p.xy *= rot(time*.1);
	p.xz *= rot(time*.2);
    
    // small point light on the center
	float d =  length(p);
	glow += vec3(1.) / ( .1 + d*200.);
    
    // 30 torus
	float s = .25;
	for(int i=0; i<30; i++) {
    	s += .25;
    	p.xy *= rot(time*.05);
    	p.xz *= rot(time*.1);
        
    	float d2 = torus(p,vec2(s, 0.14));
        
        // we accumulate the lighting here
    	float intensity = 1. / ( 1. + pow(abs(d2*att),1.3));
    	if(i == 6 && id == 0.) {
    		glow += vec3(1.,.3,1.) * intensity;
    	} else if(i == 15 && id == 1.) {
      		glow += vec3(1.,1.,.1) * intensity;
    	} else if(i == 20 && id == 2.) {
      		glow += vec3(.1,1.,.1) * intensity;
    	} else if(i == 25 && id == 3.) {
      		glow += vec3(.1,1.,1.) * intensity;
    	}
        
    	d = min(d, d2);
	}
	return d;
}

// Function 3432
vec2 mapArlo( vec3 p )
{

    // body
    vec3 q = p;
    float co = cos(0.2);
    float si = sin(0.2);
    q.xy = mat2(co,si,-si,co)*q.xy;
    float d1 = sdEllipsoid( q, vec3(0.0,0.0,0.0), vec3(1.3,0.75,0.8) );
    float d2 = sdEllipsoid( q, vec3(0.05,0.45,0.0), vec3(0.8,0.6,0.5) );
    float d = smin( d1, d2, 0.4 );
    
    //neck wrinkles
    float r = length(p-vec3(-1.2,0.2,0.0));
    d -= 0.05*abs(sin(35.0*r))*exp(-7.0*abs(r)) * clamp(1.0-(p.y-0.3)*10.0,0.0,1.0);

    // tail
    {
    vec2 b = sdBezier( vec3(1.0,-0.4,0.0), vec3(2.0,-0.96,-0.5), vec3(3.0,-0.5,1.5), p );
    float tr = 0.3 - 0.25*b.y;
    float d3 = b.x - tr;
    d = smin( d, d3, 0.2 );
    }
    
    // neck
    {
    vec2 b = sdBezier( vec3(-0.9,0.3,0.0), vec3(-2.2,0.5,0.0), vec3(-2.6,1.7,0.0), p );
    float tr = 0.35 - 0.23*b.y;
    float d3 = b.x - tr;
    d = smin( d, d3, 0.15 );
    //d = min(d,d3);
	}


    float dn;
    // front-left leg
    {
    vec2 d3 = leg( p, vec3(-0.8,-0.1,0.5), vec3(-1.5,-0.5,0.65), vec3(-1.9,-1.1,0.65), 1.0, 0.0 );
    d = smin(d,d3.x,0.2);
    dn = d3.y;
    }
    // back-left leg
    {
    vec2 d3 = leg( p, vec3(0.5,-0.4,0.6), vec3(0.3,-1.05,0.6), vec3(0.8,-1.6,0.6), 0.5, 1.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    // front-right leg
    {
    vec2 d3 = leg( p, vec3(-0.8,-0.2,-0.5), vec3(-1.0,-0.9,-0.65), vec3(-0.7,-1.6,-0.65), 1.0, 1.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    // back-right leg
    {
    vec2 d3 = leg( p, vec3(0.5,-0.4,-0.6), vec3(0.8,-0.9,-0.6), vec3(1.6,-1.1,-0.7), 0.5, 0.0 );
    d = smin(d,d3.x,0.2);
    dn = min(dn,d3.y);
    }
    
    
    // head
    vec3 s = vec3(p.xy,abs(p.z));
    {
    vec2 l = sdLine( p, vec3(-2.7,2.36,0.0), vec3(-2.6,1.7,0.0) );
    float d3 = l.x - (0.22-0.1*smoothstep(0.1,1.0,l.y));
        
    // mouth
    //l = sdLine( p, vec3(-2.7,2.16,0.0), vec3(-3.35,2.12,0.0) );
    vec3 mp = p-vec3(-2.7,2.16,0.0);
    l = sdLine( mp*vec3(1.0,1.0,1.0-0.2*abs(mp.x)/0.65), vec3(0.0), vec3(-3.35,2.12,0.0)-vec3(-2.7,2.16,0.0) );
        
    float d4 = l.x - (0.12 + 0.04*smoothstep(0.0,1.0,l.y));      
    float d5 = sdEllipsoid( s, vec3(-3.4,2.5,0.0), vec3(0.8,0.5,2.0) );
    d4 = smax( d4, d5, 0.03 );
    
        
    d3 = smin( d3, d4, 0.1 );

        
    // mouth bottom
    {
    vec2 b = sdBezier( vec3(-2.6,1.75,0.0), vec3(-2.7,2.2,0.0), vec3(-3.25,2.12,0.0), p );
    float tr = 0.11 + 0.02*b.y;
    d4 = b.x - tr;
    d3 = smin( d3, d4, 0.001+0.06*(1.0-b.y*b.y) );
    }
        
    // brows    
    vec2 b = sdBezier( vec3(-2.84,2.50,0.04), vec3(-2.81,2.52,0.15), vec3(-2.76,2.4,0.18), s+vec3(0.0,-0.02,0.0) );
    float tr = 0.035 - 0.025*b.y;
    d4 = b.x - tr;
    d3 = smin( d3, d4, 0.025 );


    // eye wholes
    d4 = sdEllipsoid( s, vec3(-2.79,2.36,0.04), vec3(0.12,0.15,0.15) );
    d3 = smax( d3, -d4, 0.025 );    
        
    // nose holes    
    d4 = sdEllipsoid( s, vec3(-3.4,2.17,0.09), vec3(0.1,0.025,0.025) );
    d3 = smax( d3, -d4, 0.04 );    

        
    d = smin( d, d3, 0.01 );
    }
    vec2 res = vec2(d,0.0);
    
    
    // eyes
    float d4 = sdSphere( s, vec3(-2.755,2.36,0.045), 0.16 );
    if( d4<res.x ) res = vec2(d4,1.0);
    
    float te = textureLod( iChannel0, 3.0*p.xy, 0.0 ).x;
    float ve = normalize(p).y;
    res.x -= te*0.01*(1.0-smoothstep(0.6,1.5,length(p)))*(1.0-ve*ve);
    
    if( dn<res.x )  res = vec2(dn,3.0);

    return res;
}

// Function 3433
float mapWDists(vec4 p, out vec4 distsOut) {
  /*
  NB: I suggest only enabling one shape at a time to start with, and only
  have 1 on at a time (at least until you have a feel for things). Careful
  with shapes being on top of each other.
  */

  vec4 dists;
  float d = 999.;

  d = min(d, sdTesseractEdge(p, vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);
  distsOut = dists;  // for more shapes: distsOut = min(distsOut, dists);

  // /* position offset works like normal: */
  // d = min(d, sdTesseractEdge(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);
  // distsOut = min(distsOut, dists);

  // /* "solid" objects (i.e., faces, not edges) work fine */
  // d = min(d, sdTesseractFaces(p - vec4(0,0,0,-1.5), vec4(EDGE_LENGTH), dists) - EDGE_WIDTH);
  // distsOut = min(distsOut, dists);

  // /* hyperspheres are a bit boring. */
  // d = min(d, sdHypersphere(p - vec4(0,0,0,-1.5), EDGE_LENGTH, dists) - EDGE_WIDTH);
  // distsOut = min(distsOut, dists);

  return d;
}

// Function 3434
float map_detailed( const in vec3 p, const in vec3 id) {
    float d = rock(p, id) + fbm3_high(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;
    return d;
}

// Function 3435
Distance distance(vec3 p0)
{         
    vec4 p = vec4(p0, 1.0);
    mat4 m;   
    
        
    vec3 color = vec3(0.7, 0.52, 0.4) * 0.7;// * (sin(p.x*30.0)*sin(p.y*2.0)*sin(p.z*30.0)*0.1+0.7);    
    
    Distance d = Distance(sphere(p0 + vec3(0.0, 100.0, 0.0), 200.0) + sin(p.x/2.0)*cos(p.z/2.0)/2.0, vec3(0.2, 0.8, 0.5));
    
    
    d = smooth_add(d, Distance(capsule(p.xyz, 3.0, 0.6), color), 0.8);     
    
    p *= rotateY(sin(iTime)*2.0+sin(p.y)*2.0); 
    m = translate(vec3(0.0, 3.0, 0.0)) * rotateY(40.0) * rotateX(35.0);    
    p.x = abs(p.x) - 0.05;
    p.z = abs(p.z) - 0.05;    
    p = p * m;    
    d = smooth_add(d, Distance(capsule(p.xyz, 2.0, 0.4), color), 0.1); 
    
    p *= rotateY(10.0+sin(iTime+p.x)*5.0+sin(p.x)*5.0);    
    m = translate(vec3(0.0, 2.0, 0.0)) * rotateY(45.0) * rotateX(30.0);    
    p.x = abs(p.x) - 0.03;
    p.z = abs(p.z) - 0.03;
    p = p * m;    
    d = smooth_add(d, Distance(capsule(p.xyz, 1.5, 0.2), color), 0.1); 
    
    p *= rotateY(15.0+sin(iTime+p.z)*8.0+cos(p.z)*8.0);  
    m = translate(vec3(0.0, 1.5, 0.0)) * rotateY(55.0+sin(p.x)*10.0) * rotateX(35.0);    
    p.x = abs(p.x) - 0.01;
    p.z = abs(p.z) - 0.01;
    p = p * m;    
    d = smooth_add(d, Distance(capsule(p.xyz, 2.3, 0.08), color), 0.1); 
    
    
    float leafSize = min(sin(iTime / 3.0) * 0.06 + 0.11, 0.15);
    vec3 leafColor = hsv2rgb(vec3(cos((iTime) / 3.0 + sin((p.x+p.y+p.z)*5.0)/3.0) * 0.14 + 0.18, 0.7, 0.8));
    
    vec4 r = p;
    r.x = abs(r.x);
    r.z = abs(r.z);
    Distance leafs = Distance(max(sphere(repeat((r.xyz+vec3(0.0, 0.09, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 4.6, 0.2))), leafColor);
    d = add(d, leafs);
    
    p *= rotateY(10.0+sin(iTime+r.x)*10.0+sin(r.x)*10.0);  
    m = translate(vec3(0.0, 1.0, 0.0)) * rotateY(55.0) * rotateX(40.0);    
    p.x = abs(p.x) - 0.01;
    p.z = abs(p.z) - 0.01;
    p = p * m;    
    d = smooth_add(d, Distance(capsule(p.xyz, 1.2, 0.04), color), 0.1); 
    
    p.x = abs(p.x);
    p.z = abs(p.z);
    leafs = Distance(max(sphere(repeat((p.xyz+vec3(0.0, 0.0, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 2.5, 0.2))), leafColor);
    d = add(d, leafs); 
    
    
    return d;
}

// Function 3436
ctx scenePlain(ctx i) {
    return i;
}

// Function 3437
float scene_primitive_sphere( Ray ray, float R, inout float t, inout vec3 N )
{
    vec2 sph = sphere_impact( ray.o, ray.d );
    if( sph.x < R * R )
    {
        float to = sphere_limits( R, sph ).x;
        if( to >= 0. && to < t )
        {
            t = to;
            N = normalize( ray.o + t * ray.d );
        }
    }
    float shadow = 1.;
    if( sph.y < 0. )
    {
        float K = -2. * sph.y * SCN_RAYCAST_SHADOW_UMBRA_INV;
        float u = sqrt( sph.x );
        shadow = 1. - aaa_interval( K, u, 2. * R );
    }
    return shadow;
}

// Function 3438
float distInv(vec3 p)
{	vec3 pos=vec3(-.75,0,0);
	float r=min(laptop_open(at_pos(pos+vec3(0,-0.1,0),p),35.,0.20),
                coconut(at_pos(pos+vec3(.5,0,0),p)));

 	r=min(r,sscreen_bottle(at_pos(pos+vec3(1.0,0,0),p)));  
    return r;
}

// Function 3439
vec4 map_life(vec2 fragCoord) {
    vec4 c = texture(iChannel3, fragCoord/iResolution.xy);
    float vege = c.x;
    float prey = c.y * 2.;
    float pred = max(c.z, 0.);

    vec4 fragColor = map_land(fragCoord, true);
    fragColor = mix(fragColor, vec4(0.0, 1.0, 0.1, 1), 0.75 * smoothstep(0., 5., vege - prey - pred));
    fragColor = mix(fragColor, vec4(0.8, 0.5, 0.0, 1), 0.75 * smoothstep(0., 5., prey - pred));
    fragColor = mix(fragColor, vec4(0.5, 0.0, 0.0, 1), 0.75 * smoothstep(0., 5., pred));
    return fragColor;
}

// Function 3440
float map(in vec3 pos) {
    pos -= vec3(0.19,0.1, 0.10);
    pos = vec3(0.99619469809  * pos.x + 0.08715574274 * pos.z, pos.y, 0.99619469809  * pos.z - 0.08715574274 * pos.x);   
    pos = vec3(0.98480775301 * pos.x + 0.17364817766 * pos.y, 0.98480775301 * pos.y - 0.17364817766 * pos.x, pos.z);
    vec3 saved = pos;
    pos = vec3(pos.x, pos.z, pos.y);
    float m = sdHexPrism(pos, vec2(1.4, 3.0));
    pos = vec3(0.70710678118 * pos.x + 0.70710678118  * pos.y, 0.70710678118 * pos.y - 0.70710678118 * pos.x, pos.z);
    pos = vec3(0.98480775301 * pos.x + 0.17364817766 * pos.z, pos.y, 0.98480775301 * pos.z - 0.17364817766 * pos.x);
    m = max(m-0.02, sdHexPrism(pos, vec2(1.55, 2.5))-0.02);
    m = max(m, sdBox(saved, vec3(1.3, 2.55, 1.4)-0.02));  
    return m-0.02;
}

// Function 3441
float hexDist(vec2 p) {
    #define MULT1 (1.0/tan(PI/3.0))
	#define MULT2 (1.0/sin(PI/3.0))
	float dx = abs(p.x);
	float dy = abs(p.y);
	return max(dx+dy*MULT1, max(dx, dy*MULT2));
}

// Function 3442
vec3 getDistanceColor(vec3 pt) {
  float d = getSdf(pt);
  vec3 color = mix(red, green, 0.5 + 0.5 * sin(d * 3.141592));
  if (fract(d) < 0.05) {
    color = mix(color, black, smoothstep(0.0, 0.05, fract(d)));
  } else if (fract(d) < 0.1) {
    color = mix(black, color, smoothstep(0.05, 0.1, fract(d)));
  }
  return color;
}

// Function 3443
void sceneMap3D(vec3 pos, out float t, out int objId, vec3 lightPos)
{
    // floor
    t = plane(pos, FLOOR_VEC);  
    objId = FLOOR_ID;  

    float t2;
    if((t2 = plane(pos, LEFT_WALL_VEC)) < t)  
    {
        t= t2;
        objId = LEFT_WALL_ID;
    } 
    if((t2 = plane(pos, RIGHT_WALL_VEC)) < t)  
    {
        t= t2;
        objId = RIGHT_WALL_ID;
    }
    if((t2 = plane(pos, BACK_WALL_VEC)) < t)
    {
        t= t2;
        objId = BACK_WALL_ID;
    }
    if((t2 = plane(pos, CEILING_VEC)) < t)
    {
        t= t2;
        objId = CEILING_ID;
    }
    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix
    {
        t= t2;
        objId = LONG_BOX_ID;
    }
    if((t2 = box(rotateY(pos + SHORT_BOX_POS, -27.5 * PI_OVER_180), SHORT_BOX_SCALE)) < t)
    {
        t= t2;
        objId = SHORT_BOX_ID;
    }
}

// Function 3444
Shape map(vec3 c){
  Shape vines = vines(c);
  Shape orbs = orb(c);
    
  float df = mixShapes(vines.dist, orbs.dist, 1.);
  vines.dist = df;
    
  vines.color = mix(vines.color, 
                    orbs.color, 
                    mixColors(orbs.dist, vines.dist, 1.));

  return vines;
}

// Function 3445
float map(in vec3 pos) {
    const float SPHERE_COUNT = 6.0;
    float m2 = 1e20;
    
    for (float i = 0.0; i < SPHERE_COUNT; i++) {
        float dy = sin(i * (TAU / SPHERE_COUNT));
        float dz = cos(i * (TAU / SPHERE_COUNT));
        m2 = opU(m2, sphere(pos + vec3(0.25, 0.25 * dy, 0.25 * dz), 0.25));
        m2 = opU(m2, sphere(pos + vec3(0.0, 0.25 * dz, 0.25 * dy), 0.25));
    }
    
    for (float i = 0.0; i < SPHERE_COUNT; i++) {
        float theta = mod(iTime * 2.0 + i * 2.0, TAU);
        float phi = (TAU / SPHERE_COUNT) * (i * 0.75);
        float r = 2.0;
        
        m2 = opU(m2, sphere(pos + vec3(r * sin(theta) * sin(phi),
                                       r * sin(theta) * cos(phi),
                                       r * cos(theta)), 0.2));
    }
    
    return m2;
}

// Function 3446
float Remap(float v, float omin, float omax, float nmin, float nmax)
{
	return nmin+max(0.0, (v-omin))/(omax-omin)*(nmax-nmin);
}

// Function 3447
vec2 remap(vec2 p)
{
    return p/iResolution.xy*vec2(WIDTH, HEIGHT);
}

// Function 3448
float Mat1SDF( vec3 p )
{
    // 4 walls
    float f = -abs(p.x-2.5)-(-4.);
    f = min(f, -abs(p.z+1.)-(-5.) );
    
    // 4 more walls at 45 degrees for more interesting reflections!
    f = min(f, -abs((p.z+p.x)*.7071+1.)-(-5.) );
    f = min(f, -abs((p.z-+p.x)*.7071+1.5)-(-4.5) );

    return f;
}

// Function 3449
float map(vec3 p){
    vec3 rotPX = rotateX(p, RotX*ROT_SPEED);
    vec3 rotPXY = rotateY(rotPX, RotY*ROT_SPEED);
    if ( iMouse.z > 0. ) {density=iMouse.x/iResolution.x * RUGOSITY_DENSITY_MAX;}
	float rugosity=cos(density*rotPXY.x)*sin(density*rotPXY.y)*sin(density*rotPXY.z)*cos(256.1)*sin(0.8);
	float disp=length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;
    return length(p)-1.+disp+rugosity;}

// Function 3450
float getDist( vec3 p )
{
	float plane = p.y + 0.4;
	
	rotateY( p, -iMouse.x * 0.005 + iTime * 0.2 );
	
	angleRepeatY(p, 5.0);
	
	rotateX( p, max(0.0, (-p.x - RING_RADIUS)) * TWIST);
	
	repeatX( p, 0.5 );
	
	float d = 0.0;
	float ring1 = 0.0;
	float ring2 = 0.0;
	
	float sphere1 = length( p - vec3(0.0, 0.0, 0.0) ) - RING_RADIUS;
	float sphere2 = length( p - vec3(0.0, 0.0,   RING_RADIUS * RING_THICKNESS) ) - RING_RADIUS;
	float sphere3 = length( p - vec3(0.0, 0.0,  -RING_RADIUS * RING_THICKNESS) ) - RING_RADIUS;
	
	rotateX( p, pi * 0.5);
	p.x = mod( p.x, 0.5 ) - 0.25;
	
	float sphere4 = length( p - vec3(0.0, 0.0, 0.0) ) - RING_RADIUS;
	float sphere5 = length( p - vec3(0.0, 0.0,   RING_RADIUS * RING_THICKNESS) ) - RING_RADIUS;
	float sphere6 = length( p - vec3(-0.0, 0.0, -RING_RADIUS * RING_THICKNESS) )  - RING_RADIUS;
    
	ring1 = smax(sphere1, - sphere2, SMOOTHING);
	ring1 = smax(ring1, -sphere3, SMOOTHING);
	ring2 = smax(sphere4, - sphere5, SMOOTHING);
	ring2 = smax(ring2, - sphere6, SMOOTHING);
	d = min( min(ring1, ring2), plane);
	
	return d;
}

// Function 3451
void Scene_Union( inout SceneResult a, const in SceneResult b )
{
    if ( b.fDist < a.fDist )
    {
        a = b;
    }
}

// Function 3452
float RaymarchScene(in Ray ray, inout float nearest)
{
    float sdf = FarClip;
    
    vec3 o = (ray.origin) + (ray.direction * 2.0);
    
    for(float depth = NearClip; depth < FarClip; )
    {
    	vec3 pos = o + (ray.direction * depth);
        
        sdf = Scene_SDF(pos);
        nearest = min(sdf, nearest);
        
        if(sdf < Epsilon)
        {
            return depth;
        }
        
        depth += sdf;
    }
    
    return FarClip;
}

// Function 3453
float mapClouds(vec3 p)
{
    float h = FBM(p*.0001);
	return clamp(h-.64, 0.0, 1.0) * smoothstep(40000.0, 2500.0,p.y) * smoothstep(250.0, 2500.0,p.y);
}

// Function 3454
float mapSeed01(vec2 f)
{
    //uv = (uv + 1.)/2.;
    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);
    return min(LIGHT_DIST, length((floor(seedCoord)-floor(f))/iResolution.x)-seedColor.z*circSizeMult);
}

// Function 3455
vec2 GetDist(vec3 p){
    float box = dBox(p-vec3(0,0,-3), vec3(.5));
    vec2 res = vec2(box,1);
    vec2 box2 = vec2(dBox(p-vec3(2,0,-3), vec3(.5)),2);
    res = colMin(res,box2);
    vec2 box3 = vec2(dBox(p-vec3(-2,0,-3), vec3(.5)),3);
    res = colMin(res,box3);
    
    vec2 box4 = vec2(dBox(p-vec3(2,0,0), vec3(.5)),2);
    res = colMin(res,box4);
    vec2 box5 = vec2(dBox(p-vec3(-2,0,0), vec3(.5)),3);
    res = colMin(res,box5);
    
    return res;
}

// Function 3456
vec3 SceneNormal(vec3 pos)
{
    vec2 eps = vec2(0.001, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy) - Scene(pos - eps.xyy),
                          Scene(pos + eps.yxy) - Scene(pos - eps.yxy),
                          Scene(pos + eps.yyx) - Scene(pos - eps.yyx)));
}

// Function 3457
float SceneSDF(vec3 samplePoint)
{
    return TorusSDF(samplePoint, vec2(1.3, 0.45));
}

// Function 3458
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
    
    //Body (2.0)
    float lBodyCylinder = sdCapsule(  pos -  vec3(0.0, 0.5, 0.0), vec3(0.0, -0.13, 0.0), vec3(0.0, 0.05, 0.0), 0.25);
    float lBodySphereBottom =  sdEllipsoid( pos-vec3(0.0, 0.22, 0.0), vec3(0.23, 0.09, 0.23));
    float lBodySphereTop =  sdEllipsoid( pos-vec3(0.0, 0.72, 0.0), vec3(0.23, 0.14, 0.23));
    float lBodySphereMiddle =  sdEllipsoid( pos-vec3(0.0, 0.45, 0.0), vec3(0.21, 0.2, 0.21));
    float lBody1 = smin(lBodyCylinder, lBodySphereBottom, 16.0);
    float lBody2 = smin(lBody1, lBodySphereTop, 16.0);
    float lBody3 = smin(lBody2, lBodySphereMiddle, 16.0);


   	//Arms (version 2) (2.0)
    vec3 lArmsPos =  opMirrorX(pos);
   	float lArms = opSmoothUnion(sdCapsule( lArmsPos -  vec3(0.34, 0.39, 0.0), vec3(0.02, -0.09, 0.08), vec3(-0.09, 0.07, 0.0), 0.027),
                                sdCapsule( lArmsPos -  vec3(0.34, 0.25, 0.0), vec3(0.02, -0.07, 0.02), vec3(0.015, 0.07, 0.076), 0.024), 0.008);
   	//End Arms

    //Mouth
    mat3 lMouthRot = rotation(X_AXIS, M_PI * 0.5);
    float lMouth = sdEllipsoid( lMouthRot * (pos-vec3(0.00, 0.5, -0.29)), vec3(0.1, 0.08, 0.05));
          lMouth = fOpIntersectionRound(lMouth, -sdEllipsoid( lMouthRot * (pos-vec3(0.00, 0.55, -0.29)), vec3(0.15, 0.06, 0.03)), 0.009);
    float lBody3_2 = fOpIntersectionRound(lBody3, -lMouth, 0.006);
    //End Mouth
	
    float lBody4 = opSmoothUnion(lBody3_2, lArms, 0.016);
    res = opU( res, vec2( lBody4, 2.0 ) );
    //End Body


    //Bib Short (3.0) 
    //Uses lBody3
    float lBibShortCutter = sdCylinder(  pos-vec3( 0.0,0.6,0.0), vec2(0.35,0.3));
    lBibShortCutter = max(lBibShortCutter, -sdBox(       pos-vec3( 0.0,0.35, 0.0), vec3(0.15, 0.1, 0.55) ));
    float lStraps = 		sdCylinder( rotation(Z_AXIS, -0.5) * (opMirrorX(pos)-vec3(0.1, 0.41, 0.0)), vec2(0.3, 0.025));
    lBibShortCutter = max(lBibShortCutter, -lStraps);
    float lBibShort = fOpIntersectionRound(lBody3, -lBibShortCutter, 0.004) - 0.008;
    lBibShort = fOpIntersectionRound(lBibShort, -(lBody3-0.002), 0.0092);
    res = opU( res, vec2( lBibShort, 3.0 ) );
	//End Bib Short
    
	//Teeth
    float lTeeth = sdRoundBox(pos-vec3(0.00, 0.52, -0.25), vec3(0.015, 0.015, 0.005), 0.012);
          lTeeth = min(lTeeth, sdRoundBox(opMirrorX(pos)-vec3(0.052, 0.52, -0.25), vec3(0.015, 0.015, 0.005), 0.012));
    res = opU( res, vec2( lTeeth, 7.0 ) );
    //End Teeth
    
    
    float lBottomBox = sdBox( pos-vec3( 0.0, 0.12, 0.0), vec3(0.42,0.15,0.2) );
    if(res.x > lBottomBox)
    {
        //Legs (3.0)
        res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.02,0.0), vec3(-0.085,0.15,0.0), vec3(-0.080,0.0,0.01), 0.06, 0.04), 3.0 ) );
        res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.02,0.0), vec3( 0.085,0.15,0.0), vec3( 0.080,0.0,0.01), 0.06, 0.04), 3.0 ) );
        //End Legs

        //Shoes (4.0)
        res = opU( res, vec2( sdEllipsoid( opMirrorX(pos)-vec3(0.080, 0.0, 0.0), vec3(0.05, 0.05, 0.08) ), 4.0 ) );
        //End Shotes

        //Hands (4.0)
        mat3 lHandRot = rotation(X_AXIS, -0.5);
        vec3 lHandPos = opMirrorX(pos);
        //palm
        float lHand = sdEllipsoid( lHandRot * (lHandPos - vec3(0.36, 0.19, 0.018)), vec3(0.026, 0.03, 0.03));
        //wrist
        lHand = opSmoothUnion(lHand, sdCone( lHandRot * (lHandPos - vec3(0.36, 0.2, 0.023)), vec3(0.00,0.00,0.0), vec3(0.00,0.04,0.00), 0.026, 0.039), 0.009);
        //fingers
        lHand = opSmoothUnion(lHand,  sdCapsule( lHandPos - vec3(0.365, 0.15, 0.022), vec3(0.0, -0.02, 0.01), vec3(0.0, 0.04, 0.015), 0.016), 0.009);
        lHand = opSmoothUnion(lHand,  sdCapsule( lHandPos - vec3(0.365, 0.16, 0.018), vec3(0.0, -0.027, -0.023),vec3(0.0, 0.04, 0.0), 0.016), 0.009);
        lHand = opSmoothUnion(lHand,  sdCapsule( lHandPos - vec3(0.365, 0.16, 0.012), vec3(0.0, -0.01, -0.05), vec3(0.00, 0.04, -0.01), 0.016), 0.009);
        res = opU( res, vec2(lHand, 4.0) );
        //End Hands
    }

    float lEyeBox = sdBox( pos-vec3( 0.0, 0.67, 0.0), vec3(0.3,0.12,0.35) );
    if(res.x > lEyeBox)
    {
        //Eyes (5.0)
        res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.67, -0.22), 0.10 ), 5.0) );
        //End Eyes
        
        //Glasses Metal (6.0)
        //float lGlassesMetal = sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(0.0,0.0,0.1), vec3(0.0,0.0,0.0), 0.1  );
        mat3 lGlassRot = rotation(X_AXIS, M_PI * 0.5);
        float lGlassesMetal = sdRoundedCylinder(  lGlassRot *  (pos-vec3( 0.0, 0.67, -0.24)), 0.06, 0.04, 0.08  );
        float lGlassesCutter = sdRoundedCylinder( lGlassRot *  (pos-vec3( 0.0, 0.67, -0.24)), 0.04, 0.01, 0.09  );
        float lGlassesMetal1 = fOpIntersectionRound( lGlassesMetal, -lGlassesCutter, 0.05);
        res = opU( res, vec2( lGlassesMetal1, 6.0) );
        //End Glasses Metal

        //Glasses Strap (4.0)
        float lGlassesStrap = sdRoundedCylinder(  (pos-vec3( 0.0, 0.67, 0.0)), 0.14, 0.02, 0.03  );
        lGlassesStrap = max(lGlassesStrap, -lGlassesMetal);
        res = opU( res, vec2( lGlassesStrap, 4.0) );
        //End Glasses Strap
    }
	    
    return res;
}

// Function 3459
float map(in vec3 pos)
{
    float d = 1e10;
    

    // ellipsoide
    {
    vec3 q = pos - vec3(-3.0,0.0,-1.0);
    d = min( d, sdEllipsoid( q.yzx, vec3(0.4,0.2,0.1) ) );
    }
    
    // elongated ellipsoide
    {
    vec3 q = pos - vec3(-3.0,0.0,1.0);
    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );
    d = min( d, w.w+sdEllipsoid( w.yzx, vec3(0.4,0.2,0.1) ) );
    }

    // cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,-1.0);
    d = min( d, sdCappedCylinder( q, vec2(0.4,0.1) ) );
    }
    
    // elongated cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,1.0);
    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );
    d = min( d, w.w+sdCappedCylinder( w.xyz, vec2(0.4,0.1) ) );
    }

    // torus
    {
    vec3 q = pos - vec3(1.0,0.0,-1.0);
    d = min( d, sdTorus( q, vec2(0.4,0.05) ) );
    }
    
    // elongated torus
    {
    vec3 q = pos - vec3(1.0,0.0,1.0);
    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );
    d = min( d, w.w+sdTorus( w.xyz, vec2(0.4,0.05) ) );
    }

    // torus
    {
    vec3 q = pos - vec3(3.0,0.0,-1.0);
    d = min( d, sdTorus( q.xzy, vec2(0.4,0.05) ) );
    }
    
    // elongated torus
    {
    vec3 q = pos - vec3(3.0,0.0,1.0);
    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );
    d = min( d, w.w+sdTorus( w.xzy, vec2(0.4,0.05) ) );
    }

    return d;
}

// Function 3460
vec3 mapMushroom( in vec3 pos, in vec3 cur )
{
    vec3 res = cur;

    vec3 qos = worldToMushrom(pos);
    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;
    if( db<cur.x )
    {

        {

            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );

            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;

            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );
            float d = smax( d1, -d2, 0.1 );
            d *= 0.8;
            if( d<res.x )
            {
                res = vec3( d, MAT_MUSH_HEAD, 0.0 );
            }
        }


        {
            pos.x += 0.3*sin(pos.y) - 0.65;
            float pa = sin( 20.0*atan(pos.z,pos.x) );
            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );

            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);

            float d3 = se.x - tt;

            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);
            d3 += 0.003*pa;
            d3 *= 0.7;
            
            if( d3<res.x )
                res = vec3( d3, MAT_MUSH_NECK, 0.0 );
        }
    
    }
    return res;
}

// Function 3461
bool FIntersectScene(
		vec3 posRay,
		vec3 normalRay,
		out SHit o_hit,
		out int o_cStep)
{
	SMaterial mtlPlane = MtlCreate(vec3(0.2, 0.2, 0.2), 1.0 / 20.0);
	SHit hitPlane = HitPlane(vec4(0, 0, 1, 0), mtlPlane, posRay, normalRay);

	float sRay = 0.0;
	const int cStepMax = 100;
	for (int cStep = 0; cStep < cStepMax; ++cStep)
	{
		o_cStep = cStep;

		vec3 pos = posRay + normalRay * sRay;

		float uRandom = UHashFromPos(pos);
		SSdfSample sdf = SdfScene(PosWrap(pos), uRandom);

		float dSEdge = DSCellEdge(pos);
		const float sEdgeSlop = 100.0;
		sRay += min(sdf.m_s, dSEdge + sEdgeSlop);

		if (sRay >= hitPlane.m_s ||
			pos.z < 0.0 ||
			(pos.z > g_zMax && normalRay.z >= 0.0))
		{
			o_hit = hitPlane;
			return hitPlane.m_s < g_sRayMax;
		}

		if (sdf.m_s < 1.0)
		{
			o_hit.m_s = sRay;
			vec3 posHit = posRay + normalRay * sRay;
			posHit = PosWrap(posHit);
			SSdfSample sdfHit = SdfScene(posHit, uRandom);

			// Construct normal

			SSdfSample sdfHitX = SdfScene(posHit + vec3(0.1, 0, 0), uRandom);
			SSdfSample sdfHitY = SdfScene(posHit + vec3(0, 0.1, 0), uRandom);
			SSdfSample sdfHitZ = SdfScene(posHit + vec3(0, 0, 0.1), uRandom);

			o_hit.m_normal = vec3(
								sdfHitX.m_s - sdfHit.m_s,
								sdfHitY.m_s - sdfHit.m_s,
								sdfHitZ.m_s - sdfHit.m_s);
			o_hit.m_normal = normalize(o_hit.m_normal);

			o_hit.m_mtl = sdfHit.m_mtl;
			return true;
		}
	}

	o_cStep = cStepMax;

	o_hit = hitPlane;
	return hitPlane.m_s < g_sRayMax;
}

// Function 3462
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstObj, dstGrnd, sh;
  bool isBg;
  isBg = false;
  isSh = false;
  dstGrnd = dstFar;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    col4 = CarCol ();
  } else if (rd.y < 0.) {
    dstGrnd = - ro.y / rd.y;
    ro += dstGrnd * rd;
    vn = vec3 (0., 1., 0.);
  } else {
    isBg = true;
    col = ErCol (rd);
  }
  if (! isBg) {
    isSh = true;
    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;
    if (dstObj < dstFar) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +
       col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);
    else col = GrndCol (ro, dstGrnd, sh) * (1. - smoothstep (0.5, 1., dstGrnd / dstFar));
  }
  if (min (dstObj, dstGrnd) >= dstFar || length (col) < 0.03) col += StarPat (rd, 6.);
  return clamp (col, 0., 1.);
}

// Function 3463
vec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {
    float i = tileId( pos, nor );
    if( i > 0. ) {
        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );
        nor = normalize( nor );
    }
    return nor;
}

// Function 3464
float distfunc(vec3 pos)
{
	vec3 gridpos=pos-floor(pos)-0.5;
	float r=length(pos.xy);
	float a=atan(pos.y,pos.x);
	a+=iTime*0.3*sin(pcount(r,3.0)+1.0)*sin(pcount(pos.z,1.0)*13.73);
	return min(max(max(
	periodic(r,3.0,0.2),
	periodic(pos.z,1.0,0.7+0.3*cos(iTime/3.0))),
	periodic(a*r,3.141592*2.0/6.0*r,0.7+0.3*cos(iTime/3.0))),
	0.25);
	//return max(length(gridpos)-0.5,
	//	  abs(r-floor(r)-0.5)-0.1);
}

// Function 3465
vec3 map_light_pm(in vec3 ro, in vec3 rd) { 
    vec3 nrm = map_light_norm(ro);
    return lightCol*brightness*max(0.,dot(-rd, nrm));
}

// Function 3466
Hit scene(vec3 p0)
{
	float d = 10000.0, d1, e = 0.04;
    float spec = CONCRETE_SPEC;
	vec3 col = vec3(0.0);
    
    // floor
    d1 = sdBox(p0-vec3(0.0,-0.92,-19.5),vec3(20.0,0.8,20.0)); 
    if (d1 < d) 
    { 
        d = d1; 
        col = CONCRETE_COLOR; 
        spec = CONCRETE_SPEC;
    }

    // pillars
    vec3 p1=vec3(mod(p0.x,8.0)-4.0,p0.y,p0.z); 
    d1 = sdBox(p1-vec3(1.0,0.6,-0.7),vec3(0.3,3.8,1.0)); 
    if (d1 < d) 
    { 
        d = d1; 
        col = CONCRETE_COLOR; 
        spec = CONCRETE_SPEC;        
    }

    // vertical bars
    vec3 p2=vec3(mod(p0.x,2.0)-1.0,p0.y,p0.z); 
    d1 = sdBox(p2-vec3(0.0,0.0,0.5),vec3(0.04,8.0,0.04)); 
    if (d1 < d) 
    { 
        d = d1; 
        col = WINDOW_BARS_COLOR; 
        spec = WINDOW_BARS_SPEC;
        e = 0.0;
    }

    // horizontal bars
    vec3 p3=vec3(p0.x,mod(p0.y,3.4)-1.7,p0.z); 
    d1 = sdBox(p3-vec3(0.0,1.6,0.5),vec3(20.0,0.04,0.04)); 
    if (d1 < d) 
    { 
        d = d1; 
        col = WINDOW_BARS_COLOR; 
        spec = WINDOW_BARS_SPEC;
        e = 0.0;
    }

    // top wall fragment
    d1 = sdBox(p0-vec3(0.0,5.0,0.5),vec3(20.0,0.8,0.2)); 
    if (d1 < d) 
    { 
        
        d = d1; 
        col = mix(CONCRETE_COLOR, WINDOW_BARS_COLOR, step(p0.y,4.22)); 
        spec = CONCRETE_SPEC;
    }

    // ceiling
    d1 = sdBox(p0-vec3(1.0,5.2,-2.6),vec3(2.65,1.0,2.5)); 
    d1 = max(d1,-sdBox(p0-vec3(1.0,4.2,-2.6),vec3(2.2,0.17,2.0))); 
    d1 = max(d1,-sdBox(p0-vec3(1.0,4.2,-2.6),vec3(1.94,0.4,1.6))); 
    if (d1 < d) 
    { 
        d = d1; 
        col = CONCRETE_COLOR; 
        spec = CONCRETE_SPEC;        
    }
	
    if (p0.y > 0.0)
    {
        d1 = interior(p0);
        if (d1 < d)
        {
            d = d1;
            col = INTERIOR_COLOR;
            spec = INTERIOR_SPEC;
        }
    }    
	return Hit(d, col, e, spec);
}

// Function 3467
float Scene_SDF(vec3 point, inout RayHit hit)
{
    return min(FarClip, SDF_Clocktown(point));
}

// Function 3468
Result scene (in vec3 p)
{
	Result res = Result(.0, 0);

    float floor = sdPlane (p, .7);

    float r = .025 + .01 * cos (iTime);
    float a = 10. * r;
    float b = 2. * r;

    // for construction/debugging
    //p.xz *= r2d (iMouse.x);
    //p.yz *= r2d (iMouse.y);

    // for presenting
    p.xy *= r2d (55. + 12. * iTime);
    p.yz *= r2d (30. + 17. * iTime);
    p.zx *= r2d (65. + 23. * iTime);
    
    p += vec3 (a);

    float torus = sdTorus (p + vec3 (.0, b, .0), vec2 (b, r));
    float bars = sdCylinder (p.yxz + vec3 (b, -a, b), a, r);
    bars = min (bars, sdCylinder (p.yzx + vec3 (b, -a, b), a, r));
    torus = min (bars, torus);
    torus = min (torus, sdTorus (p.zyx + vec3 (.0, b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.xzy + vec3 (-2.*a-b, -a+r, b), a-r, r));
    torus = min (torus, sdTorus (p.xyz + vec3 (.0, b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.yxz + vec3 (2.*r, -a+r, -2.*a-b), a-r, r));

    torus = min (torus, sdTorus (p.xzy + vec3 (-2.*a+b, -2.*a-b, .0), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.xyz + vec3 (-2.*a, -a-b+2.*r, -2.*a-b), a, r));
    torus = min (torus, sdTorus (p.xzy + vec3 (-2.*a+b, -2.*a-b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.yxz + vec3 (-2.*a-b, -a+b, -2.*a-b), a, r));
    torus = min (torus, sdTorus (p.xzy + vec3 (b, -2.*a-b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.xyz + vec3 (2.*b, -a-r, -2.*a-b), a-r, r));

    torus = min (torus, sdTorus (p.zxy + vec3 (-2.*a+b, -2.*a-b, .0), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zyx + vec3 (-2.*a, -a, -2.*a-b), a, r));
    torus = min (torus, sdTorus (p.zxy + vec3 (-2.*a+b, -2.*a-b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.yzx + vec3 (-2.*a-b, -a+b, -2.*a-b), a, r));
    torus = min (torus, sdTorus (p.zxy + vec3 (b, -2.*a-b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zyx + vec3 (2.*b, -a-b+r, -2.*a-b), a-r, r));

    torus = min (torus, sdTorus (p.yxz + vec3 (-b, 2.*b, -2.*a), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.yzx + vec3 (.0, -a, 2.*b), a, r));
    torus = min (torus, sdTorus (p.yxz + vec3 (-b, 2.*b, .0), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zyx + vec3 (b, -a-b, 2.*b), a, r));
    torus = min (torus, sdTorus (p.yxz + vec3 (-2.*a-b, 2.*b, .0), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.yzx + vec3 (-2.*a-2.*b, -a+r, 2.*b), a-r, r));

    torus = min (torus, sdTorus (p.xyz + vec3 (b, -2.*a-2.*b, -2.*a+2.*r), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zxy + vec3 (-2.*a, -a+b, -2.*a-2.*b), a, r));
    torus = min (torus, sdTorus (p.zyx + vec3 (2.*-a+b, -2.*a-2.*b, -2.*a+b), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.xzy + vec3 (-2.*a, -a+b, -2.*a-2.*b), a, r));
    torus = min (torus, sdTorus (p.xzy + vec3 (-2.*a, 2.*b, -b), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zxy + vec3 (2.*b, -a, .0), a, r));

    torus = min (torus, sdTorus (p.xzy + vec3 (.0, 2.*b, -b), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zyx + vec3 (2.*b, -a-b, b), a, r));
    torus = min (torus, sdTorus (p.zyx + vec3 (b, -2.*a-2.*b, -2.*a+b), vec2 (b, r)));
    torus = min (torus, sdCylinder (p.zxy + vec3 (2.*b, -a+r, -2.*a-2.*b), a-r, r));
    torus = min (torus, sdTorus (p.xzy + vec3 (.0, 2.*b, -2.*a-b), vec2 (b, r)));

    res.d = min (torus, floor);
    res.id = (res.d == torus) ? 1 : 2;

    return res;
}

// Function 3469
vec2 maptouv(vec3 p, vec3 div) {
    p=clamp((p/3.0)*0.5+0.5,0.0,0.999);
    float idz=floor((p.z+0.00001)*div.x*div.y)/div.x;
    vec2 uvz=vec2(fract(idz),floor(idz)/div.y);
    return p.xy/div.xy+uvz;
}

// Function 3470
SG WarpDistributionSG(in SG ndf, in vec3 view)
{
    SG warp; 
    warp.Axis = reflect(-view, ndf.Axis);
    warp.Amplitude = ndf.Amplitude;
    warp.Sharpness = ndf.Sharpness;
    warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); 
    return warp;
}

// Function 3471
LightmapSample empty_lightmap_sample()
{
    return LightmapSample(vec4(0), vec4(0));
}

// Function 3472
Scene create_scene()
{
    Scene scene;
    scene.sphere_count = 0;
    scene.parallelogram_count = 0;
    
    return scene;
}

// Function 3473
maybe_float get_distance_along_3d_line_to_tetrahedron(
    in vec3 A0,
    in vec3 A,
    in vec3 B1,
    in vec3 B2,
    in vec3 B3,
    in vec3 B4
){
    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);
    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);
    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);
    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);
    maybe_float hit;
    hit = get_distance_along_line_to_union(hit1, hit2);
    hit = get_distance_along_line_to_union(hit,  hit3);
    hit = get_distance_along_line_to_union(hit,  hit4);
    return hit;
}

// Function 3474
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)
{          
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  vec3 reflectDir = reflect( rayDir, normal );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0/specSize);
  vec3 reflection = vec3(texture(iChannel3, reflectDir ).r*1.5);

  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );
  fre = mix( .03, 1.0, fre );   
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );

  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.998);

  float shadow = SoftShadow(shadowPos, sunPos);
  dif*=shadow;
  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );
  skyLight *= SoftShadow(shadowPos, reflectDir );

  vec3 lightTot = (vec3(0.2)*amb); 
  lightTot+=vec3(0.85)*dif;
  lightTot= mix(lightTot, reflection*max(0.3, shadow), fre );
  lightTot += 1.00*specLevel*dif;
  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);
  lightTot= mix(lightTot*.7, lightTot*1.2, fre );

  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);
  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );
  lightTot = mix( lightTot, lightTot+ vec3(1.6), fre );

  return lightTot*sunColor;
}

// Function 3475
SurfInfo mapScene(in vec3 p) {
    vec3 lp = p + vec3(4.0, 0.0, 0.0);
    float surf1 = sdBox(lp, vec3(2.0, 0.1, 3.0)) - 0.1;

    vec3 rp = p - vec3(4.0, 0.0, 0.0);
    float surf2 = sdBox(rp, vec3(2.0, 0.1, 3.0)) - 0.1;

    SurfInfo baseScene = SurfInfo(surf1, vec3(1.0, 0.0, 0.0), PortalInfo(false, vec3(0.0), vec3(0.0), vec2(0.0)));
    if (surf2 < surf1) {
        baseScene = SurfInfo(surf2, vec3(0.0, 0.0, 1.0), PortalInfo(false, vec3(0.0), vec3(0.0), vec2(0.0)));
    }

    lp.yz -= vec2(1.6, -2.0);
    float portalFrame1 = sdBox(lp, vec3(1.0, 1.5, 0.1)) - 0.1;
    float portal1 = sdBox(lp, vec3(0.8, 1.3, 0.21));
    float port1 = min(portalFrame1, portal1);
    if (port1 < baseScene.dist) {
        baseScene = SurfInfo(port1, vec3(0.0, 0.0, 1.0), PortalInfo(portal1 < portalFrame1, vec3(-4.0, 1.6, 0.0), vec3( 4.0, 1.6, 0.0), vec2(0.0, 0.0)));
    }

    rp.yz -= vec2(1.6, -2.0);
    float portalFrame2 = sdBox(rp, vec3(1.0, 1.5, 0.1)) - 0.1;
    float portal2 = sdBox(rp, vec3(0.8, 1.3, 0.21));
    float port2 = min(portalFrame2, portal2);
    if (port2 < baseScene.dist) {
        baseScene = SurfInfo(port2, vec3(1.0, 0.0, 0.0), PortalInfo(portal2 < portalFrame2, vec3( 4.0, 1.6, 0.0), vec3(-4.0, 1.6, 0.0), vec2(0.0, 0.0)));
    }

    return baseScene;
}

// Function 3476
vec3 eMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.25;
    rd *= 3.;
    
    //vec3 tx = tex3D(iChannel0, rd/3., sn);
    //float c = dot(tx*tx, vec3(.299, .587, .114));
    
    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
    c = smoothstep(0.5, 1., c); // Darken and add contast for more of a spotlight look.
    
    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.
    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)).zyx; // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25+.25); 
    
}

// Function 3477
vec3 map( vec3 p )
{
    vec2 id = floor( (p.xz+1.0)/2.0);
    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;
    
    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));
    
    p.xz += 0.5*sincos(1.0+0.5*iTime+(p.y+11.0*ph)*0.8);

    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iTime+0.0);
    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);
    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);
    
    vec2 h1 = sdSegment(p1, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );
    vec2 h2 = sdSegment(p2, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );
    vec2 h3 = sdSegment(p3, vec3(0.0,-50.0, 0.0), vec3(0.0, 50.0, 0.0) );
    
    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0/3.0, h1.y), 
                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iTime*4.0), ph + 1.0/3.0, h2.y) ), 
                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0/3.0, h3.y) );
}

// Function 3478
vec2 map_zombie(vec3 p)
{
    const vec3
        hip = vec3(2, 3, 2),
    	knee = vec3(-1, 1.5, -9),
    	ankle = vec3(4, 1.25, -21),
    	toe1 = vec3(1.5, 1.6, -24),
    	toe2 = vec3(1, 1.1, -24),
    
        spine1 = vec3(1.5, 0, 2),
        spine2 = vec3(1, 0, 13.5),

        shoulder = vec3(2, 6, 16),
        elbow = vec3(2, 14, 20),
        wrist = vec3(2, 22, 26),

        neck = vec3(1, 0, 18),
        head = vec3(-1.5, 0, 22),
        mouth = vec3(-1.5, 0, 20)
	;
    
    vec3 mp = p;
    mp.y = abs(mp.y);

    float dist = sdf_capsule(mp, ankle, knee, 1., 1.5);
    dist = sdf_smin(dist, sdf_capsule(mp, knee, hip, 1.5, 2.), .05);
    dist = sdf_smin(dist, sdf_capsule(mp, ankle, toe1, 1., .5), .5);
	dist = sdf_smin(dist, sdf_capsule(mp, ankle, toe2, 1., .5), .5);
    
    dist = sdf_smin(dist, sdf_capsule(mp, shoulder, elbow, 1.3, 1.2), 2.);
    dist = sdf_smin(dist, sdf_capsule(mp, elbow, wrist, 1.2, .9), .5);

    dist = sdf_smin(dist, sdf_round_box(p - spine1, vec3(.25, 3., 3.), .25), 1.5);
    dist = sdf_smin(dist, sdf_capsule(p, spine1, spine2, 1.), 4.);
    dist = sdf_smin(dist, sdf_round_box(p - spine2, vec3(.75, 2.5, 2.5), 1.25), 4.);

    dist = sdf_smin(dist, sdf_capsule(p, neck, head, 1.5, 1.1), 1.);
    dist = sdf_smin(dist, sdf_sphere(p - head, 2.5), 2.);
    dist = sdf_smin(dist, sdf_round_box(p - mouth, vec3(.5, .5, .5), 1.), 1.);

    //return vec2(dist, MATERIAL_COP3_4);
    return vec2(dist, MATERIAL_ZOMBIE);
}

// Function 3479
vec3 map( in vec3 p )
{
    vec3 p00 = p;
	
	float r, d; vec3 n, s, res;
	
    #ifdef SHOW_SPHERES
	#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))
	#else
	#define SHAPE (vec3(d-abs(r), sign(r),d))
	#endif
    
	d=length(p00); n=p00/d; r = SH(L, M, n ); s = SHAPE; res = s;
	
	return vec3( res.x, 0.5+0.5*res.y, res.z );
}

// Function 3480
float ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k
){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance
 ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.
 ;if(is_circle//near-circles are special quadratic case of a quartic ellipse
){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)
 ;}else{//ellipse
  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse 
  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself
  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case
  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by
  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients
  ;roots=solve_quartic(coeffs)// solve for up to 4 roots 
  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y
  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.
  ;for(int i=0;i<4;++i//for each root
 ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign
   ;vec2 b=vec2(length(p-c),dot(p-c,c))
   ;float s=sign(ds.x-b.x)*.5+.5
   ;k=k+i*int(s)
   ;ds=mix(ds,b,s)
 ;}}return ds.x*sign(ds.y);}

// Function 3481
float map(vec4 p)
{
    float box = sdTesseract(p, vec4(0.5));
    return box;
}

// Function 3482
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, colB, vn, rdd, p, ltDir;
  float dstObj, dstTrObj, ltDist;
  HexVorInit ();
  szFac = 2.6;
  rLay = transVu ? 0.2 : 0.;
  dstObj = ObjRay (ro, rd);
  if (transVu) {
    if (dstObj < dstFar) {
      p = ro + dstObj * rd;
      vn = ObjNf (p);
      rdd = reflect (rd, vn);
    } else {
      p = ro;
      rdd = rd;
    }
    col = BgCol (p, rdd);
    if (dstObj < dstFar) col *= 0.9; 
    rLay = 0.;
    dstTrObj = ObjRay (ro, rd);
    if (dstTrObj < min (dstObj, dstFar)) {
      p = ro + dstTrObj * rd;
      vn = ObjNf (p);
      col = mix (col, 0.9 * BgCol (p, reflect (rd, vn)), 0.5);
    }
  } else {
    if (dstObj < dstFar) {
      p = ro + dstObj * rd;
      vn = ObjNf (p);
      if (exVu) {
        ltDir = sunDir;
        ltDist = dstFar;
      } else {
        ltDir = ltPos - p;
        ltDist = length (ltDir);
        ltDir /= ltDist;
      }
      colB = vec3 (0.95, 1., 0.95) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.));
      rdd = reflect (rd, vn);
    } else {
      p = ro;
      rdd = rd;
    }
    col = BgCol (p, rdd);
    if (dstObj < dstFar) col = mix (colB, col, 0.9);
  }
  return clamp (col, 0., 1.);
}

// Function 3483
float heightMap2(vec2 p){
    
    p /= 2.; // Extra scaling.
    
    float  h = 0., a = 1., sum = 0.; // Height, amplitude, sum.
    
    for(int i=0; i<4; i++){
    
        p = fract(p)*2.666; // Subdividing space.
        // Far more interesting, mutated subdivision, courtesy of Aiekick.
        //p = fract(p+sin(p.yx*9.)*0.025 + cos(p.yx*9.)*0.025)*3.; 
        // Another one with a time component.
        //p = fract(p + sin(p*9. + cos(p.yx*13. + iTime*2.))*0.02)*3.;
        
        vec2 w = .5 - abs(p - 1.5); // Prepare to make a square. Other shapes are also possible.
        float l = sqrt( max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.))*.5+.5; // Edge shaping.
        w = smoothstep(0., .05, w); // Smooth edge stepping.
        h = max(h, w.x*w.y*a*l); // Producing the smooth edged, shaped square.
        //h += w.x*w.y*a*l;
        //h = max(h, abs(abs(w.x)-abs(w.y))*a*l);
        sum += a; // Keep a total... This could be hardcoded to save cycles.
        a *= .4; // Lower the amplitude for the next subdivision, just because it looks tidier.
        //if(i==2)a*=.75;
    }
    
    return h/sum;
    
}

// Function 3484
vec2 map ( vec3 p ) {
    float t = 1.,t2=5.;
    float h = sin(p.x+iTime*t)+sin(p.z+iTime*t);
       h*=sin(iTime*t2+p.x+p.y);
    h/=10.;
    vec2 f = 
        vec2(
            p.y+h,
            0);
    return f;
}

// Function 3485
float ray_scene_intersect(in vec3 pos, in vec3 dir, out vec3 normal, out bool hit_source)
{
	float tt = INF;

	// source
	vec3 n0;
	float t0 = ray_aabb_intersect(pos, dir, vec3(-0.2, -ROOM_SIZE/3.0, -0.2), vec3(0.2, ROOM_SIZE/3.0, 0.2), n0);
	if (t0 < tt) {
		tt = t0;
		normal = n0;
		hit_source = true;
	}

	// occluder
	vec3 n1;
	float t1 = ray_aabb_intersect(pos, dir, vec3(-0.5, -ROOM_SIZE/2.0, -0.5), vec3(0.5, ROOM_SIZE/2.0, -0.4), n1);
	if (t1 < tt) {
		tt = t1;
		normal = n1;
		hit_source = false;
	}

	if (tt < INF) return tt;

	// room
	hit_source = false;
	return ray_invaabb_intersect(pos, dir, vec3(-ROOM_SIZE, -ROOM_SIZE, -ROOM_SIZE), vec3(ROOM_SIZE, ROOM_SIZE, ROOM_SIZE + ROOM_EXTEND), normal);
}

// Function 3486
float map(vec3 p){
    p.xy = pMod(p.xy,12.);
    p = modC(p,vec3(4.,4.,1.5));
    vec3 q = p;
    q.x -= 1.5;
    q = abs(q);
    float cube = max(q.x,max(q.y,q.z)) - 0.5;
    float sp = length(p) - 0.5;
    float result = min(cube,sp);
    return result;
}

// Function 3487
vec2 lens_distortion(vec2 r, float alpha) {
    return r * (1.0 - alpha * dot(r, r));
}

// Function 3488
float MapStreeLight(  vec3 p)
{
  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);
  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   
  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        
  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  
  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  
  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        
  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); 

  return d;
}

// Function 3489
float dist(vec3 p){
    vec3 p0 = rotate(p, t * 2., vec3(0.0,1.0,0.0)) + vec3(-1.0, 0.0,0.0);
    vec3 p1 = rotate(p, t, vec3(0.0,1.0,0.0)) + vec3(1.0, 0.0,0.0);
    float d = 100.0;
    d = opI(box(p0, vec3(1.2)),
                opU(box(p, vec3(0.8))
                    , box(p1, vec3(0.8))
               	)
           );
    return d;
}

// Function 3490
vec4 scene(vec3 point)
{
 	float v = 1. - textureLod(iChannel1, point.xz * 0.02, 0.0).r;// voronoi(point * 0.2).x;
    float h1 = bump(point.xz);
    float h2 = heightmap(point.xz);
    float valley = pow((min(abs(sin(point.z* 0.03)*0.38 + point.x * 0.08) *0.6,1.)),1.0 + v * 3.2);
    float d = 1. + point.y + (mix(h1 * 0.3, (1.-h1) * 0.9 ,clamp(-0.3+v,0.0,1.0))) - (-3.+h2 * 8.) * valley;
    d = min(d-v*3.2 * valley,d) ;
   
    
    //d = min(d, sdSphere(p2 - vec3(10.),10.0));
    
    return vec4(d,v,h1,h2);
}

// Function 3491
vec2 sceneInsideGlassMaterials(vec3 point){
    vec3 kAdjustPt = point;
    kAdjustPt = translate(kAdjustPt, vec3(-1.75,0,.5));
    kAdjustPt.xz = rotate(kAdjustPt.xz, PI * 0.1);
    vec2 kodos = kodosSDF(kAdjustPt/CHARACTERSCALE);
    kodos.x = kodos.x * CHARACTERSCALE;
    return kodos;
}

// Function 3492
vec3 Uncharted2ToneMapping(vec3 color)
{
	float A = 0.15;
	float B = 0.50;
	float C = 0.10;
	float D = 0.20;
	float E = 0.02;
	float F = 0.30;
	float W = 11.2;
	float exposure = 2.;
	color *= exposure;
	color = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
	float white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;
	color /= white;
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 3493
float dDistance_Cheap(indli=sdSegment_Cheap(vppte
// distance to cubic segment
float dDistance_Expensive(indli=sdSegment_Expensive(vppte

vec3 profile(vec3 x){x=mod(x,12.);return c01(x)-c01(x-4.);}

// Function 3494
float Distance(vec2 pos1, vec2 pos2){
 	return sqrt(pow(pos1.x - pos2.x,2.0) + pow(pos1.y - pos2.y,2.0));   
}

// Function 3495
bool Intersect_Scene(vec3 rp, vec3 rd, bool isPrimaryRay,
                     out float t, out vec3 n, out vec3 a, inout bool hitLight)
{
    bool doTestLight = hitLight;
    hitLight = false;
        
    vec3 vp;
    bool hit = VoxelRayCast(rp, rd, /*out*/ vp, n, t);
    
    //a = vec3(1.0);
    a = mapC(vp);
    
	if(doTestLight)    
    {
        vec2 t0;
		float hit0 = Intersect_Ray_Sphere(rp, rd, LightPos, R2, /*out*/ t0);
        
        if(hit0 == 1.0)
        {
            if(!hit || t0.x < t)
            {
                t = t0.x;
                n = normalize(rp + rd * t0.x - LightPos);
                a = vec3(1.0);
                
                hitLight = true;
            }
            
            hit = true;
        }
    }
    
    return hit;
}

// Function 3496
float sdf_V(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(2, -8, 0)));
    return t;
}

// Function 3497
vec2 map(vec3 p)
{
    vec2 d = vec2(1e+31, 0);
    
    float jiggle = .1 * pow(2.*fract(TAU*float(iFrame))-1., 9.);
    
    dmin(d, p.y + .5, 0.);
    dmin(d, jiggle + length(p.xz) - .5, 2.);
    if(dot(p.xy,p.xy) > 12.25)return d;
    
    p.xz = amod(p.xz, TAU/8.);
    dmin(d, length(p - vec2(0, 2).yxx) - .5, .99);
	return d;
}

// Function 3498
vec4 map_night(vec2 uv) {
    vec2 fragCoord = uv * iResolution.xy;
    float lat = 180. * uv.y - 90.;
    float lon = 360. * uv.x - 180.;
    vec3 p = fromlatlon(lat, lon);
    
    vec2 uv2 = fragCoord / iResolution.y + 1.;
    vec2 wiggle = vec2(FBM(vec3(50. * uv2, 1)), FBM(vec3(50. * uv2, 2))) - 0.5;
    
    float height = MAP_HEIGHT(buf(fragCoord).z);
    float density = 0.75;
    if (height >= 0.) {
        float width = 3e-3;
        density += 0.5 * network(100. * uv2 + 1.0 * wiggle, 100. * width);
        density += 1.0 * network( 30. * uv2 + 0.3 * wiggle,  30. * width);
        density += 2.0 * network( 10. * uv2 + 0.1 * wiggle,  10. * width);
        density += smoothstep(0.1, 0., height); // coast
        density *= 0.1 + clamp(2. * FBM(12. * p) - 0.5, 0., 1.);
        density *= 0.2 + 1.3 * clamp(2. * FBM(1.5 * p) - 0.67, 0., 1.);
    }
    float cities = speckle(1000. * uv, density);
    cities *= 0.5 * FBM(vec3(50. * uv, iTime));
    
    float human = max(-texture(iChannel3, uv).z, 0.);
    float temp = climate(fragCoord, PASS3).y;
    vec3 night = vec3(0.00, 0.00, 0.01);
    if (height > 0.) {
        night = vec3(0.00, 0.00, 0.02);
        night *= 1. + 1.5 * clamp(FBM(50. * p) - 0.15, 0., 1.);
    }
    if (human > 0.) {
        float pop = FBM(vec3(fragCoord,0)) + 0.1;
        pop += clamp(FBM(vec3(fragCoord/7.,0)) - 0.5, 0., 0.25);
        pop = clamp(2. * pop - 1., 0., 1.);
        float lit = pow(pop, 4.) * (0.67 + 0.33 * sin(2.*PI * (hash12(fragCoord) + iTime)));
        vec3 lights = vec3(0.95, 0.76, 0.47);
        lights = mix(lights, vec3(0.91, 0.14, 0.16), smoothstep(30., 35., temp));
        night = mix(night, 0.75 * sqrt(density) * lights, smoothstep(0., 1., cities * human));
        night = clamp(night, 0., 1.);
    }
    return vec4(night, 1);
}

// Function 3499
vec3 GetEnvMapG(vec3 rayDir) {
    // Make sure this texture is set to the "Uffizi gallery" cubemap.
    vec3 tex = texture(iChannel0, rayDir).xyz;
    tex = tex * tex;  // gamma correct - gamma 2.0
    vec3 light = vec3(0.0);
    // overhead softbox, stretched to a rectangle
    if ((rayDir.y > abs(rayDir.x+0.6)*0.29) && (rayDir.y > abs(rayDir.z*2.5))) light = vec3(2.0)*rayDir.y;
    vec3 texp = pow(tex, vec3(14.0));
    light *= texp;  // Masked into the existing texture's sky
    return (tex + light*3.0);
}

// Function 3500
float boxDist(vec2 p, vec2 size, float radius)
{
  	vec2 d = abs(p) - size - radius;
  	return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
}

// Function 3501
float triangleDist(vec2 p){ 
    const float k = sqrt(3.0);
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;
    p.x -= clamp( p.x, -2.0, 0.0 );
    return -length(p)*sign(p.y);
}

// Function 3502
vec3 calcDistPoint( vec3 pos, vec3 v1, vec3 v2, vec3 v3 )
{
    bool found = false;
    float dist = 1024.0;

    vec3 m = vec3(1,0,0);
    vec3 m1 = m.xyz;
    vec3 m2 = m.zxy;
    vec3 m3 = m.yzx;

    vec3 distpos;
#if 1
    // triangle (normal distance to plane)
    vec2 tc=triangleCoord( pos-v1, v2-v1, v3-v1 );
    if ( (tc.x>0.0f) && (tc.y>0.0f) && (tc.x+tc.y<1.0f) ) // check if normal-dist point is within triangle
    {
        distpos=tc.x*(m2-m1)+tc.y*(m3-m1)+m1;
        found = true;
    }
    if(found) return distpos;

    // edges (normal distance to line)
    vec2 linedist;
    linedist=calcLineDist(pos-v1,v2-v1); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m1,m2,linedist.x); found=true; }
    linedist=calcLineDist(pos-v2,v3-v2); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m2,m3,linedist.x); found=true; }
    linedist=calcLineDist(pos-v3,v1-v3); if( linedist.x>0.0 && linedist.x<1.0 && linedist.y<dist ) { dist=linedist.y; distpos=mix(m3,m1,linedist.x); found=true; }
    if(found) return distpos;
#endif
    // points (distance to edge-point)
    float actdist;
    actdist=length(pos-v1); if(actdist<dist) { dist=actdist; distpos=m1; found=true; }
    actdist=length(pos-v2); if(actdist<dist) { dist=actdist; distpos=m2; found=true; }
    actdist=length(pos-v3); if(actdist<dist) { dist=actdist; distpos=m3; found=true; }
    if(found) return distpos;

    return vec3(1,0,0);
}

// Function 3503
vec3 calcNormalmapWater( in vec3 pos, in float ep )
{
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*mapWater(pos+e.xyy*ep) + 
					 e.yyx*mapWater(pos+e.yyx*ep) + 
					 e.yxy*mapWater(pos+e.yxy*ep) + 
					 e.xxx*mapWater(pos+e.xxx*ep) );
}

// Function 3504
float distBox( vec3 pos, vec3 scale ) {
    return length( max( abs( pos ) - scale, vec3( 0.0 ) ) );
}

// Function 3505
vec3 FresnelTermApprox(vec3 toEye, vec3 halfVec, vec3 minVal)
{
    return minVal + (1. - minVal)*pow(1. - dot(toEye, halfVec), 5.);
}

// Function 3506
float octaSDF_mult( vec3 p, float dim){ // an octahedron inside an octahedron inside an octahedron inside an octahedron inside an octahedron
    p = abs(p);
    return fract((p.x+p.y+p.z-dim)*0.57735027);
}

// Function 3507
vec2 map(vec3 p)
{
    vec3 id = floor( (p+3.)/6.0);
    p = mod( p+3., 6.0 ) - 3.;
    float rid = hash(dot(id,vec3(7.,43,113)));
    p = rotx(p,time*.5+rid+sin(rid*5.+time));
    p = roty(p,time*0.5+rid*1.1);
    
    float d = mix((max(abs(p.x),max(abs(p.y),abs(p.z)))-0.5),max(length(p)-1.,-(length(p)-0.4)),rid);
    return vec2(d*.85,rid);
}

// Function 3508
vec3 sceneFromFrag(vec2 frag) {
    return vec3((frag.xy - 0.5*theResolution) * px, px);
}

// Function 3509
float scene(vec3 p)
{  
  float d;
  d = sphere(p,.9);
	d = max(box(p, vec3(1.1)), -d);
  d  = min(d, prim1(p));

	vec3 np = p + vec3(0.0, time*0.2, time*0.1);
  d += texture(iChannel0, -np.xz).r*0.2;
  d += texture(iChannel0, np.yz).r*0.2;
	return d;
}

// Function 3510
float sphereDist(in Ray ray, in Sphere sphere) {
    return length(ray.origin - sphere.pos) - sphere.radius;
}

// Function 3511
float scene(vec3 p)
{
	float cube = length(max(abs(p + vec3(0.75, 1., -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025;
	cube = min(cube, length(max(abs(p + vec3(-0.25, 1.6, -2.4)) - vec3(0.25, 0.07, 1.0), 0.0)) - 0.025);
	float s1 = length(p+vec3(-1.0, -0.5, -1.0)) - 1.3;
	float s2 = length(p+vec3(-2.75, 1.35, 0.)) - 0.05;
	float s3 = length(max(abs(p+vec3(-2.5, -1.3, 0.0)) - vec3(0.05, 2.5, 2.5), 0.0));
    s3 = max(s3, -(length(max(abs(p - vec3(2.5, 0., 2.)) - vec3(0.25, 3.0, 0.035), 0.0)) - 0.025));
    s3 = max(s3, -(max(cylinder(p, vec3(2.5, 1.85, -1.8), 0.35), -cylinder(p, vec3(2.5, 1.85, -1.8), 0.28))));
    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.25, 0.035), 0.0)) - 0.025));
    //s3 = max(s3, -(length(max(abs(p - vec3(2.5, 1.85, -1.8)) - vec3(0.25, 0.035, 0.25), 0.0)) - 0.025));
	float s4 = length(max(abs(p+vec3(0.0, 0.0, 2.5)) - vec3(8.5, 2.95, 0.05), 0.0));
	//s4 = min(s4, length(max(abs(p+vec3(-2.0, 2.0, 0.5)) - vec3(1.75, 0.05, 1.05), 0.0)));
	s4 = min(s4, length(max(abs(p+vec3(0.0, 2.5, 0.0)) - vec3(8.5, 0.05, 8.5), 0.0)));
	s4 = min(s4, length(max(abs(p+vec3(2.0, -2.5, 0.0)) - vec3(4.5, 0.05, 2.5), 0.0)));
	s4 = min(s4, length(max(abs(p+vec3(-0.7, 0.0, -2.5)) - vec3(8.5, 2.5, 0.05), 0.0)));
	s4 = min(s4, length(max(abs(p+vec3(3.75, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));;
	s4 = min(s4, length(max(abs(p+vec3(-3.9, 0.0, 0.0)) - vec3(0.05, 40.5, 40.5), 0.0)));
	return min( min( min( min(cube, s1), s2 ), s3 ), s4);
}

// Function 3512
float distTorus(vec3 pos, float r1, float r2, vec3 z, out float ang)
{
    float pz = dot(pos,normalize(z));
    vec2 r = vec2(length(pos-z*pz)-r1,pz);
    ang = atan(r.y,r.x);
    return length(r)-r2;
}

// Function 3513
vec2 arcdistance( vec3 a, vec3 b )
{
    vec4 an = length_normalize(a);
    vec4 bn = length_normalize(b);
    vec3 dn = an.xyz - bn.xyz;
    float arclen = atan( length( reject( dn, an.xyz ) ), dot( bn.xyz, an.xyz ) );
    return vec2( .5 * ( an.w + bn.w ) * arclen, an.w - bn.w );
}

// Function 3514
float Scene(vec3 p)
{
    float d = 1000.0;
    
    p *= scale;
    
    d = opU(d, -sdPlane(p, vec3(0,0,1)));
    
    #ifndef HIDE_BOX
    d = opU(d, sdBox(p,vec3(3,2,2)));
    d = opS(sdBox(p + vec3(0,0,0.5), vec3(4,1.5,0.75)), d);
    #endif
    
    d = opU(d, sdSphere(p + vec3(2,0,0.5),0.25));
    d = opU(d, sdBox(p + vec3(-2,0,0.5), vec3(0.5,0.5,0.5)));
    
    d = opU(d, -sdSphere(p,32.0));
    
	return d;
}

// Function 3515
float DistanceToObject(vec3 p)
{
    //p += (1.0/p.y)*0.6;

    // Rotate, but only the part that is on the side of rotDir
    if (dot(p, rotDir) > 1.0) p *= rotMat;

    // Repeat our position so we can carve out many cylindrical-like things from our solid
    vec3 rep = fract(p)-0.5;
    //final = max(final, -(length(rep.xz*rep.xz)*1.0 - 0.0326));
    float final = -(length(rep.xy*rep.xz) - 0.109);
    final = max(final, -(length(rep.zy) - 0.33));

    //final = max(final, -(length(rep.xz*rep.xz) - 0.03));
    //final = max(final, -(length(rep.yz*rep.yz) - 0.03));
    //final = max(final, -(length(rep.xy*rep.xy) - 0.030266));

    // Repeat the process of carving things out for smaller scales
    vec3 rep2 = fract(rep*2.0)-0.5;
    final = max(final, -(length(rep2.xz)*0.5 - 0.125));
    final = max(final, -(length(rep2.xy)*0.5 - 0.125));
    final = max(final, -(length(rep2.zy)*0.5 - 0.125));

    vec3 rep3 = fract(rep2*3.0)-0.5;
    final = max(final, -(length(rep3.xz)*0.1667 - 0.25*0.1667));
    final = max(final, -(length(rep3.xy)*0.1667 - 0.25*0.1667));
    final = max(final, -(length(rep3.zy)*0.1667 - 0.25*0.1667));

#ifdef TOO_MUCH_FRACTAL
    vec3 rep4 = fract(rep3*3.0)-0.5;
    final = max(final, -(length(rep4.xz)*0.0555 - 0.25*0.0555));
    final = max(final, -(length(rep4.xy)*0.0555 - 0.25*0.0555));
    final = max(final, -(length(rep4.yz)*0.0555 - 0.25*0.0555));

    vec3 rep5 = fract(rep4*3.0)-0.5;
    final = max(final, -(length(rep5.xz)*0.0185 - 0.25*0.0185));
    final = max(final, -(length(rep5.xy)*0.0185 - 0.25*0.0185));
    final = max(final, -(length(rep5.yz)*0.0185 - 0.25*0.0185));
#endif

    // Cut out stuff outside of outer sphere
    final = max(final, (length(p) - outerSphereRad));
    // Carve out inner sphere
    final = max(final, -(length(p) - 2.8));
    //final = max(final, abs(p.x) - 2.0);	// for that space station look
    //final = (length(p) - outerSphereRad);	// for debugging texture and lighting
    // Slice the object in a 3d grid so it can rotate like a rubik's cube
    float slice = 0.02;
    vec3 grid = -abs(fract(p.xyz)) + slice;
    final = max(final, grid.x);
    final = max(final, grid.y);
    final = max(final, grid.z);
    //final = min(final, abs(p.y));
    return final;
}

// Function 3516
float distChainSeg(vec3 p, float R, float r, float lh)
{
    return length(vec2(length(vec2(max(abs(p.x)-lh,0.),p.y))-R,p.z))-r;
}

// Function 3517
float noseSdf(vec2 p) {
    const float a = noseLength - noseRadius;
    const float b = 1.0 - noseRadius;
    const float r = 0.5 * (a * a + b * b) / b;
    vec2 q = vec2(1.0 - r - noseRadius, tankLength);
    vec2 d = p - q;
    d = d / length(d);
	q += r * d;    
    q.x = max(0.0, q.x);
    q.y = min(tankLength + noseLength - noseRadius, q.y);
    return length(p - q) - noseRadius;
}

// Function 3518
vec2 map(in vec3 p, bool tree, bool landscape) {
    vec2 res = vec2(1000,-1);
    if (tree)      res = opU(res, mapTree(p));
    if (landscape) res = opU(res, mapLandscape(p));
	return res;
}

// Function 3519
float dist(int objId,vec3 p)
{
	return dist(objId,p,make_float3(0.)).x;
}

// Function 3520
float map(vec3 p)
{
    vec3 q = p;

    pMod3(q, vec3(.75, .6, .15));
    pMod3(q, vec3(0.9, 1., 0.6));
    
    pMod1(p.x, 1.);
    	q.y = abs(sin(iTime))-0.1;
    
    float s1 = sphere(p, .65); 
    float s2 = sphere(q, .5);
    float s3 = sphere(q, 1.);
    
    float disp = min(0.5 * (sin(p.x/3.) *
                       sin(p.y) *
                       (sin(p.z*10.)) ), 50.);
    	s1 -= disp;
    	s2 *= disp;
    	s3 *= disp;
    	//s1 -= disp;
    	
    
    
  	float df1 = min(s1, s2); // Union
    float df2 = max(s2, s1); // Intersection
    float df3 = max(max(s1, s3), min(s1, s2)); // Difference
    
    return df3;
}

// Function 3521
float distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3,float r, bool smth)
{
    float d = 10000.0;
    float rnd=getRand01Sph(p1+p2+p3);

    // random rotation of triangle-edges
    // no mirroring
    if      (rnd>.333) { vec3 d=p1; p1=p2; p2=p3; p3=d; }
    else if (rnd>.666) { vec3 d=p1; p1=p3; p3=p2; p2=d; }
    
    vec3 p4=pos-normalize(p1+p2);
    vec3 p5=pos-normalize(p2+p3);
    vec3 p6=pos-normalize(p3+p1);
    vec3 d1=p5-p4;
    vec3 d2=p6-p4;
    
	d=min(d, length( p4 - d1*(dot(p4,d1)/dot(d1,d1)) )-r );
	d=min(d, length( p4 - d2*(dot(p4,d2)/dot(d2,d2)) )-r );
	//d=min(d, length(cross(p4,normalize(p5-p4)))-r );
	//d=min(d, length(cross(p4,normalize(p6-p4)))-r );
	
	if(smth)
	{
        float rnd = .01*(getRand(pos*.3).x);

        d=smin(d,length(p4)-2.2*r,.0065+rnd);
        d=smin(d,length(p5)-2.2*r,.0065+rnd);
        d=smin(d,length(p6)-2.2*r,.0065+rnd);
	}
	else
	{
        d=min(d,length(p4)-2.2*r);
        d=min(d,length(p5)-2.2*r);
        d=min(d,length(p6)-2.2*r);
	}
    return d;
}

// Function 3522
float map( in vec3 pos, out vec4 suvw )
{
    float dis;

	float mindist = pos.y;

	suvw = vec4(0.0,1.0,0.0,0.0);

    //-----------------------------
	// rocas
    if( pos.y<0.5 )
    {
    	mindist -= 0.262 + 0.03*smoothstep( 0.0, 0.5, fbm(vec3(24.0*pos.x+7.7,2.0*pos.y,24.0*pos.z)) );
    }

    float chdis = 100.0;

    float px = pos.x + 0.10*noise3f( 3.0*pos + vec3(0.00, 0.0, 0.0) );
    float py = pos.y + 0.10*noise3f( 3.0*pos + vec3(0.70, 2.3, 0.5) );
    float pz = pos.z + 0.10*noise3f( 3.0*pos + vec3(1.10, 7.6, 7.2) );

    //-----------------------------
	// champi
    if( pos.y<0.40 )
	{
        float ischampi = noise2f( 2.0*pos.xz+vec2(0.0,7.6) );
        if( ischampi > 0.0 )
        {
            float fx = mod( px+128.0, 0.15 ) - 0.075; 
            float fz = mod( pz+128.0, 0.15 ) - 0.075;

            chdis = sqrt( fx*fx + fz*fz );

            if( chdis<0.10 )
            {
                float cpy = py - (0.22 + 0.10*ischampi);
                float gy = cpy*100.0;
                if( gy<1.0 )
                {

                    gy = 1.0 - gy;
                    float r = 0.07 + 6.0*gy*exp2(-3.0*gy);

                    float ang = atan(fx,fz);
                    float ani = 0.5+0.5*sin(11.0*ang);
                    float gyb = clamp(0.15*gy,0.0,1.0);
                    gyb = pow( gyb, 16.0 );

                    r += 0.15*gyb;
                    r += 0.20*ani*r;

                    float ath = 0.5 + 0.05*sin(3.0*ang);
                    float by = ((gy-3.0)*ath);
                    if( by>0.0 && by<1.0 )
                    {
                        by = by*by;
                        by = by*by;
                        r += by*0.08*ani;
                    }
                    float sgy = clamp(gy*0.50-1.10,0.0,1.0);
                    r += 0.06*sin(gy*12.0)*sgy*(1.0-sgy);

                    r *= 0.0269775390625;

                    dis = chdis - r;
                    if( dis<mindist)
                    {
                        mindist = dis;
                        suvw.x = 1.0;
                        suvw.z = gy;
                        suvw.w = ang;
                    }
                }
            }
        }
	}

    //-----------------------------
	// arboles
    {
        px += 1.10*noise3f( 0.21*pos + vec3(0.00, 0.00, 0.00) );
        py += 1.10*noise3f( 0.21*pos + vec3(0.70, 2.30, 0.50) );
        pz += 1.10*noise3f( 0.21*pos + vec3(1.10, 7.60, 7.20) );

        float fx = mod( px+128.0, 1.0 ) - 0.5;
        float fz = mod( pz+128.0, 1.0 ) - 0.5;
        float ra = 0.05/py;
        dis = fx*fx + fz*fz - ra*ra;

        if( dis<mindist )
        {
            float noao = smoothstep(0.5,0.6,pos.y);
            suvw.y = clamp(chdis*15.0,0.0,1.0)*(1.0-noao) + noao;
            mindist = dis;
            suvw.x = 4.0;
        }
    }
    
    //-----------------------------
	// piedras voladoras
	{
        vec3 ff = mod( vec3(px,py,pz)+vec3(128.0), 0.7 ) - 0.5;
        dis = dot(ff,ff);
        if( dis<(mindist+0.10)*(mindist+0.10))
        {
            suvw[0] = 3.0;
            mindist = sqrt(dis)-0.10;
            suvw[1] = 1.0;
        }
	}


	// tubos!
    if( pos.y>0.40 && pos.y<0.60 )
	{
        float fx = mod( 2.0*px+128.0, 1.0 );
        float fy = 2.0*pos.y;
        float id = floor(2.0*px);
        float cx = 0.25 + 0.25*noise3f( vec3(id*16.0,pos.z*2.0,2.0) );
        float cy = 1.00 + 0.16*noise3f( vec3(pos.z*6.0,id*2.0,0.0) );
        float wi = 0.05 + 0.01*noise3f( vec3(pos.z*48.0,id*16.0,0.0) );
        dis = (fy-cy)*(fy-cy) + (fx-cx)*(fx-cx);
        if( dis<(mindist+wi)*(mindist+wi) )
        {
            suvw.x = 2.0;
            mindist = sqrt(dis)-wi;
            suvw.y = 1.0;
        }
	}

    return mindist;
}

// Function 3523
void gs_enter_map_mode( inout GameState gs )
{
    gs.switches |= GS_TRMAP;
    gs.switches &= ~GS_IRCAM;
	gs.mouselook = vec3(
        normalize( -gs.campos.xy ),
        atan( -gs.campos.z, length( gs.campos.xy ) ) );
    gs.camzoom = 16.;
    gs.mapmarker = ZERO;
}

// Function 3524
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c, vn;
  vec2 s, w;
  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;
  bool isImg;
  pgSize = vec3 (2.5, 0.011, 1.6);
  tpCyc = 3.;
  tpWait = 4.;
  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :
     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));
  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));
  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);
  isImg = false;
  dstObj = ExObjRay (ro, rd);
  if (dstObj < dstFarEx) {
    ro += dstObj * rd;
    vn = ExObjNf (ro);
    nDotL = max (dot (vn, ltDirEx), 0.);
    if (idObj <= nPage) {
      idPage = mod ((float (idObj - 1) + npCyc), float (nPage));
      c = (idPage > 0. && idPage < float (nPage - 1)) ?
         HsvToRgb (vec3 ((idPage - 1.) / float (nPage - 2), 0.7, 1.)) : vec3 (0.8);
      s = pgSize.xz - abs (qHit.xz - vec2 (0.05, 0.));
      t = min (s.x, s.y) - 0.3;
      col4 = vec4 (0.9, 0.9, 0.8, 0.2);
      if (qHit.y > 0.) {
        w = (qHit.xz - vec2 (0.05, 0.)) / (pgSize.x - 0.05);
        if (idPage > 0.) {
          if (t > 0.) {
            isImg = true;
            ExMain (col, 2. * w);
          } else col4 = mix (vec4 (c, 0.2), vec4 (0.6 * c, 0.2), step (-0.03, t));
        } else {
          if (t > 0.) col4 = vec4 (ExZeroPg (w), 0.2);
          else col4 = mix (vec4 (c, 0.2), vec4 (0.), step (-0.03, t));
        }
      } else {
        col4 = vec4 (c, 0.2);
      }
    } else if (idObj == nPage + 1) {
      col4 = vec4 (0.9, 0.9, 0.95, 0.2);
      nDotL *= nDotL;
    }
    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);
    if (isImg) col *= 0.5 + 0.5 * sh;
    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);
  } else {
    col = vec3 (1.) * (0.4 + 0.1 * rd.z);
  }
  return clamp (col, 0., 1.);
}

// Function 3525
sdv scene(highp vec3 p)
{
    sdv sphere;
    sphere.idx = IDX_SPHERE;

	vec3 c = vec3(0.0,0.0,0.0);
	float r = 24.0 + 0.5*(sin(0.05*p.x*p.y+Time*5.0));
	sphere.d = length(p-c) - r;
	
    return sphere;
}

// Function 3526
float branchDistance(vec3 p, inout int mat,float E){
 float d=9999.9;mat=0;//2 return values
 const float s=.2,lr=.2,lb=-.2,//leaf branch params
 sg=.5,sb=sg-s*2.;//total space before wrap//branch size allowing for rounded ends
 const vec3 sbo=vec3(.0,lb,.0),sbs=vec3(s,0,0),sbl=vec3(sb,-.8,.8);
 vec3 c=vec3((branchStart+E)*.5,0,0);vec2 cs=vec2(.0,(E-branchStart)*.5-s);//cylinder params
 hardAdd(mat,d,1,dCylinder(p,c,cs,s));
 if(!((p.x>=E)||(p.x<=branchStart))){
  vec3 m=vec3(mod(E-p.x,sg),p.y,abs(p.z));
  float branchX=(floor((E-p.x)/sg)*sg),a=sin(PI*branchX/(E-branchStart));
  d=smoothAdd(dRoundline(m,sbs+sbl*a,sbs,s),d,.2);
  hardAdd(mat,d,2,dRoundline(m,sbs+sbl*(a+.2)+sbo,sbs+sbo,lr));}
 hardAdd(mat,d,2,dCylinder(p,c+vec3(0,lb,0),cs,lr));return d;}

// Function 3527
float getDistance(vec3 p) {
    float d = p.y;
    vec2 tiles = GetStoneTiles(p);;
    vec2 id = floor(tiles);
    float bump = N2(id.x, id.y);

    vec2 tUv = tiles * PI;
    float tileMask = abs(sin(tUv.x)*sin(tUv.y));
    tileMask = 1.0 - pow(1.0 - tileMask, 8.0);
    d -= tileMask * .09 * bump;
 
    vec3 n = N31(id.x + id.y * 165.32);	
    float detail = sin(n.x * p.x * 15.0) * sin(n.y * p.z * 15.0) * 0.05;
    detail += sin(n.z * p.x * p.z * 5.0) * 0.005;
    d += detail;					
   
    return d;
}

// Function 3528
float linedistance2(vec3 p, vec3 A, vec3 B) {
  vec3 d = B-A;
  vec3 q = A+dot(p-A,d)/dot(d,d)*d;
  return dot(p-q,p-q);
}

// Function 3529
vec3 NOISE_volumetricRoughnessMap(vec3 p, float rayLen)
{
    float ROUGHNESS_MAP_UV_SCALE = 6.00;//Valid range : [0.1-100.0]
    vec4 sliderVal = vec4(0.5,0.85,0,0.5);
    ROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);
    
    float f = iTime;
    const mat3 R1  = mat3(0.500, 0.000, -.866,
	                     0.000, 1.000, 0.000,
                          .866, 0.000, 0.500);
    const mat3 R2  = mat3(1.000, 0.000, 0.000,
	                      0.000, 0.500, -.866,
                          0.000,  .866, 0.500);
    const mat3 R = R1*R2;
    p *= ROUGHNESS_MAP_UV_SCALE;
    p = R1*p;
    vec4 v1 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021;
    vec4 v2 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021+1.204*v1.xyz;
    vec4 v3 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021+0.704*v2.xyz;
    vec4 v4 = NOISE_trilinearWithDerivative(p);
    
    return (v1
	      +0.5*(v2+0.25)
	      +0.4*(v3+0.25)
	      +0.6*(v4+0.25)).yzw;
}

// Function 3530
float distanceEstimation(vec3 pos, out int materialIndex){
    float deS = deSpheres(pos);
    float deP = dePlane(pos);
    float deL = deLight(pos);
    float de = min(min(deS, deP), deL);
    if(deS == de)
        materialIndex = SpheresIndex;
    else if(deP == de)
        materialIndex = PlaneIndex;
    else
        materialIndex = LightIndex;
    return de;
}

// Function 3531
float Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )
{
    //return 1.0;
    //return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;
    
	float res = 1.0;
    float t = fMinDist;
    for( int i=0; i<16; i++ )
    {
		float h = Scene_GetDistance( vRayOrigin + vRayDir * t, -1 ).fDist;
        res = min( res, 8.0*h/t );
        t += clamp( h, 0.02, 0.10 );
        if( h<0.0001 || t>fLightDist ) break;
    }
    return clamp( res, 0.0, 1.0 );    
}

// Function 3532
float sdf_t(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -2, 0)));
    return t;
}

// Function 3533
vec2 distanceStar( in vec3 p )
{
	vec3 d = vec3(0.6,0.15,0.2);
	vec2 b = vec2(0.05,0.25); 
	
	float angleFraction = PI*0.25;
	vec3 q = vec3(abs((mod(PI+atan(p.y,p.x),angleFraction)/angleFraction)-0.5)*2.0,length(p.xy),p.z);
	float currentRadius = d.x + pow(1.0 - q.x,1.5)*d.y;
	
	float distInner2D = q.y-(currentRadius-b.x);
	float dist = max(distInner2D,abs(q.z)-d.z);
	float distBorder = max(abs(q.y-currentRadius)-b.x,abs(q.z)-b.y);
	
	return vec2(min(dist,distBorder),mix(0.0,1.0,max(sign(distInner2D+EPSILON),0.0)));
}

// Function 3534
float BSDF_PDF ( float3 N, float3 wi, float3 wo, Material mat ) {
  if ( mat.transmittive > 0.0 ) {
    float3 NN = refract(wi, N, mat.transmittive);
    if ( dot(wo, NN) < cos(mat.alpha) ) return -1.0;
    return 1.0;
  }
    if (mat.diffuse == 0.0) {
        return 0.0f;
    }
  float3 H = normalize(wi+wo);
  float theta = dot(H, N);
  float k = mat.alpha*mat.alpha;
  float pdf;
  pdf = (k*k*theta)/(PI*sqr((k-1.0)*sqr(theta) + 1.0));

  pdf = (pdf/(4.0 * max(dot(H, N), dot(wi, N)) * dot(wo, N)));
  return pdf*(1.0 - mat.diffuse) + PDF_Cosine_Hemisphere(wo, N)*mat.diffuse;
}

// Function 3535
float map( vec3 pos, out uint sid, out uint submat )
{
    submat = 0u;
    float mindist;
    
    //-----------------------
    // suelo
    //-----------------------
    {
	float dis = pos.y;
	
	float ax = 128.0 + (pos.x+pos.z)*6.0;
	float az = 128.0 + (pos.x-pos.z)*6.0;
    uint ix = uint(floor(ax));
    uint iz = uint(floor(az));
    submat = ihash(ix+53u*iz);
    bool ba = ( ((submat>>10)&7u)>6u );
    float peld = max(fract(ax),fract(az));
    peld = smoothstep( 0.975, 1.0, peld );
    if( ba ) peld = 1.0;
    dis += 0.005*peld;
	mindist = dis;
    if( peld>0.0000001 ) sid = 2u; else sid = 0u;
    }
    
    //-----------------------
    // techo
    //-----------------------
	if( pos.y>1.0 ) 
    {
        float dis = techo2( fract(pos.x), pos.y, fract(pos.z) );
        if( dis<mindist )
        {
            mindist = dis;
            sid = 5u;
        }
    }

    //-----------------------
    // columnas
    //-----------------------
    {
	vec3 fc = vec3(fract( pos.x+0.5 )-0.5, pos.y,
	               fract( pos.z+0.5 )-0.5);
    float bb = udSqBox( fc, vec3(0.14, 1.0, 0.14) );
    if( bb < mindist*mindist )
    {
        float dis = columna( fc, 13.1*floor(pos.x)+17.7*floor(pos.z) );
        if( dis<mindist )
        {
            mindist = dis;
            sid = 1u;
        }
    }
    }
    
    //-----------------------
    // bicho
    //-----------------------
    //if( length( pos-vec3(0.64,-2.1,1.5) ) - 2.8 < mindist )
    if( dot2( pos-vec3(0.64,-2.1,1.5) ) < (mindist+2.8)*(mindist+2.8) )
    {
    float dis = bicho( pos, mindist );
    if( dis<mindist )
    {   
        mindist = dis;
        sid = 4u;
    }
    }

    //-----------------------
    // baldosas
    //-----------------------
    if( pos.y-0.02 < mindist )
	{
	int kkr = 65535;
    for( int i=ZERO; i<10; i++ )
    {
        float a = 3.14*sfrand(kkr);
        float co = cos(a);
        float si = sin(a);
        float xc = pos.x - (0.5 + 1.5*sfrand(kkr));
        float zc = pos.z - (1.0 + 1.0*sfrand(kkr));
        float xo = xc*co-si*zc;
        float zo = zc*co+si*xc;
        float dis = sdBox( vec3(xo, pos.y-0.008, zo), vec3(0.07, 0.008, 0.07) );
        if( dis < mindist ) 
        {
            mindist = dis;
            sid = 1u;
        }
    }
	}
    
    return mindist;
}

// Function 3536
float dist(inout ray r){
	float d=MAX_DIST;
	d=min(d,dome(r));
	d=min(d,morph(r,vec3(0.0)));
	return d;
}

// Function 3537
float map( in vec3 pos )
{
    vec3 p2 = vec3( mod(pos.x+1.0,3.0)-1.0, pos.yz );
    vec3 p3 = vec3( mod(pos.x+2.0,3.0)-1.0, pos.yz );
    vec3 p4 = vec3( mod(pos.x+3.0,3.0)-1.0, pos.yz );

    float d1 = sdPlane(    pos-vec3(0.0,0.00,0.0) );
    float d2 = sdSphere(   p2-vec3(0.0,0.30,0.0), 0.4 );
    float d3 = sdBox(      p3-vec3(0.0,0.25,0.0), vec3(0.2,0.5,0.2) );
    float d4 = sdCylinder( p4-vec3(0.0,0.0,0.0), 0.8,0.3 );
      
    return min(min(d1,d2),min(d3,d4));
}

// Function 3538
vec2 dist_march( vec3 ro, vec3 rd, float maxd )
{
    
    float epsilon = 0.001;
    float dist = 10. * epsilon;
    float t = 0.;
    for (int i=0; i < DISTMARCH_STEPS; i++) 
    {
        if ( abs(dist) < epsilon || t > maxd ) break;
        t += dist;
        dist = scenedf( ro + t * rd );
    }


    float objhit = 0.;
    if( t < maxd ) 
    {
        objhit = 1.;
    }

    return vec2(objhit, t);
}

// Function 3539
vec3 Map_GetNormal( vec3 pos )
{
    const float delta = 0.01;
    
    const int normalOctaves = 8;
    vec3 normal = vec3(1.0f, 0.0f, 1.0f) * Map_GetHeight( pos.xz, normalOctaves, true ).height
           + Map_GetHeight( pos.xz + vec2(delta, 0.0f), normalOctaves, true ).height * vec3(-1.0f, 0.0, 0.0)
        + Map_GetHeight( pos.xz + vec2(0.0f, delta), normalOctaves, true ).height * vec3(0.0f, 0.0, -1.0) + vec3(0.0, delta, 0.0);
    
    return normalize( normal );
}

// Function 3540
float map2( in vec3 p )
{
	vec3 q = vec3( 4.0*fract(0.5+p.x/4.0)-2.0, p.y, 4.0*fract(0.5+p.z/4.0)-2.0 );
	vec2 id = floor( 0.5+p.xz/4.0 );
    q.xz += 0.5*(-1.0+2.0*vec2(hash(id.x+113.0*id.y),hash(13.0*id.x+57.0*id.y)));
	q.y -= 0.5;

	return length(q.xz) - 1.1;

}

// Function 3541
float map(vec3 pos)
{
    vec2 hmp = getImageMPos(pos);
    float hm = 0.4*getImageBump(hmp);
    return udRoundBox(pos, vec3(5., 3.4, 0.1), 0.25) - hm;
}

// Function 3542
float word_map(vec2 uv, vec2 pos, int ascii, vec2 unit)
{
    return get_text(uv, pos, ascii, unit, iChannel1);
}

// Function 3543
float map (vec3 p)
{
    float v;
	vec3 location =p;
    
 	p= p*0.009;
    
	v = fbm (p);
   
    v =  (noise(iTime*0.0025+p+0.15*(vec3(v,v,v)))) ;
   
    float d =  saturate((1.-(length(location)/9.)));
  	
    v=v*d-0.1;
    
    return 1.3*saturate(v);
}

// Function 3544
vec4 drawScene(vec3 ro, vec3 rd, int c) {
    vec4 d = texture(iChannel1, rd) * 0.8;
    d.a = FLT_MAX;
    
    float sN = 4.0;
    float spacing = 6.0;
    
    for (int i = 0; i >= 0; i++) {
        if (float(i) > sN) {
            break;
        }
        
        for (int o = 0; o >= 0; o++) {
            if (float(o) > sN) {
                break;
            }
                
            vec3 p = vec3((-0.5 + float(o) / sN) * spacing, 0.1 + sin(iTime * 3.0 + float(o + i)) / 2.0 + 0.5, (-0.5 + float(i) / sN) * spacing);
            
            vec4 nP = drawPoint(ro, rd, p, 1); 
            
            if (nP.a < d.a && nP.a > 0.0) {
                d = nP;

                vec3 s = ro + rd * d.a;

                vec3 n = normalize(s - p);
                rro = s;
                rrd = reflect(normalize(s - ro), n);

                shouldRedrawScene = true;
            }
        }
    }
            
	float t = drawPlane(ro, rd);
    
    if (t >= 0.0) {
        vec3 p = ro + rd * t;
        float t1 = length(p - ro);

        if (d.a > t1) {
            d.rgb = texture(iChannel0, (p - vec3(0.0)).xz / 5.0 - 0.5).rgb;
            d.a = t1;
            
			shouldRedrawScene = false;
        }
    }
    
    return d;
}

// Function 3545
float hexDist(vec2 p) {
    p = abs(p);
    return max(dot(p, vec2(hex_factor, 0.5)), p.y) - 1.0;
}

// Function 3546
vec4 mapCube( vec3 pos )
{
	//vec4 ret = vec4( abs(atan (pos.x ) ) *abs(atan (pos.y ) ), .0, .0, 1.  );
	//vec4 ret = vec4(fract( pos.z ) > .5);
	vec3 col = vec3( .0, .9, .1);
	float dist = Mylength(  pos ) - 5.0;
	return vec4( col, dist );
}

// Function 3547
vec2 map(in vec3 pos, bool refr){
    vec2 res = vec2(TMAX, -1);
    #if SCENE == 1
    	return sceneBalls(pos, refr);
    #elif SCENE == 2
    	res = propose(chess(pos + vec3(-3, 0, 0), refr, 4.0),
                       chess(rotateY(pos, PI) + vec3(-3, 0, 0) , refr, 5.0));
        res = propose(res, vec2(plane(pos + vec3(0, 0.5, 0)), 2.0));
    #endif
    return res;
     
}

// Function 3548
float TriPrism1_SDF(in vec3 p, in vec2 e)
{
	vec3 q = abs(p);
    return max(q.z - e.y, max(q.x * 0.366025 - p.y * 0.9, p.y) - e.x * 0.5);
}

// Function 3549
RMResult map(vec3 p)
{
    float d = FAR;
    float id = -1.;
    
    {// board
        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// bishop
		p += vec3(1., 0., 1.);
        // body
        float r = 0.2 + 1.2 * pow(1. - p.y, 2.) / 8.;
        float d0 = sdCappedCylinder(1., r, p);
        // head
        float d1 = sdRoundCone(vec3(0., 1.2, 0.), vec3(0., 1.7, 0.), 0.34, 0.05, p);
        d0 = smin(d0, d1, 0.05);
        float d2 = sdSphere(vec3(0., 1.75, 0.), 0.08, p);
        d0 = smin(d0, d2, 0.02);
        vec3 p3 = p - vec3(0., 0.86, 0.);
        float d3 = sdEllipsoid(vec3(0.33, 0.08, 0.33), p3);
        d0 = smin(d0, d3, 0.03);
        vec3 p4 = rot(vec2(0., PI / 6.)) * p;
        p4 -= vec3(0., 1.3, -0.58);
        // head slit, mouth ... ?
		float d4 = sdBox(vec3(0.5, 0.3 , 0.01 * (1. - 2. * clamp(p4.y, -1., 1.))), p4) - 0.015;
        d0 = smax(d0, -d4, 0.05);
        // base
        vec3 p5 = p - vec3(0., -1., 0.);
        float d5 = sdTorus(vec2(0.4, 0.46), p5);
        d5 = max(d5, -sdHPlane(0., p5));
        d0 = smin(d0, d5, 0.05);
        float d6 = sdEllipsoid(vec3(0.68, 0.08, 0.68), p - vec3(0., -0.55, 0.));
        d0 = smin(d0, d6, 0.05);
		// stripes
        float d7 = sdTorus(vec2(0.496, 0.01), p - vec3(0., -0.425, 0.));
        d0 = smax(d0, -d7, 0.05);
		float d8 = sdTorus(vec2(0.474, 0.01), p - vec3(0., -0.37, 0.));
        d0 = smax(d0, -d8, 0.05);
        if (d0 < d)
        {
            d = d0;
            id = 1.5;
        }
    }
    
    return RMResult(d, id);
}

// Function 3550
float hexDist(vec2 p) {
    p = abs(p);
    //distance to the diagonal line
    float c = dot(p, normalize(vec2(1., 1.73)));

    // distance to the vertical line
    c = max(c, p.x);
    c += sin(iTime + 4000.) *5. +5.;
    return c;
  }

// Function 3551
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
	res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
	res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
	res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
	res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
	res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
	res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
	res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
	res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opI( sdBox(    pos-vec3( 2.0,0.2, 1.0), vec3(0.20)),
	                           sdSphere( pos-vec3( 2.0,0.2, 1.0), 0.25)), 113.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
	                           sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
	                           sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    // distance deformation (knobbly sphere):
	res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 )
                           + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z)
                         , 65.0 ) );
    
	res = opU( res, vec2( 0.5*sdTorus( opTwist(    pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
	res = opU( res, vec2( 0.3*sdTorus( opCheapBend(pos-vec3( 2.0,0.25,-1.0)),vec2(0.20,0.05)), 46.7 ) );

    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
    // scaled primitive:
    const float scale = .4;
    res = opU( res, vec2( sdSphere((pos - vec3(-2.0, 0.25, -2.0))/scale, 0.25)*scale, 70. ) );
    
    res = opU( res, vec2( opBlend( sdBox(      pos-vec3( 2.0,0.25, 0.0), vec3(.15,.05,.15) ),
                                   sdCylinder( pos-vec3( 2.0,0.25, 0.0), vec2(0.04,0.2))), 75. ) );
    res = opU( res, vec2( sd3PerpenCylInter( pos-vec3(2.0, 0.25, 2.0), vec3(0.15)) ,29.0) );
    res = opU( res, vec2( sd3PerpenCylUnion( pos-vec3(2.0, 0.25, -2.0), vec3(0.15)) ,81.0) );
    return res;
}

// Function 3552
float distf2(vec3 p, inout float m)
{
	float d = 10000.0;
	
	float grass1 = pBox(p+vec3(0,0,abs(cos(p.x)*cos(p.y))),vec3(12.2,12.2,1.2));
	grass1 = fIntersection(grass1,pRoundBox(p+vec3(0,0,1.5),vec3(11,11,0.5), 1.0));
	d = fUnion(d,grass1);
	
	float ground1 = pRoundBox(p+vec3(0,0,4.0),vec3(10.7,10.7,2.5),1.0);
	d = fUnion(d,ground1);
	
	vec2 blocks = pBlockBricks((mod(p/2.0,3.0)-0.5*3.0));
	float blockd = blocks.x;
	
	const float blocksize = 2.95;
	float blocki = pBox(p-vec3(3,3,3),vec3(blocksize,blocksize,blocksize));
	blocki = fUnion(blocki, pBox(p-vec3(3,9,3),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,3,3),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(-9,3,9),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,-9,15),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(9,-9,9),vec3(blocksize,blocksize,blocksize)));
	blocki = fUnion(blocki, pBox(p-vec3(-9,-9,3),vec3(blocksize,blocksize,blocksize)));
	
	blockd = fIntersection(blockd, blocki);
	
	d = fUnion(d,blockd);
	
	
	return d;
}

// Function 3553
vec4 distID( vec3 p, bool Refl )
{
   
    vec4 r = vec4((p.y+1.25),ID_OCEAN,p.xz * .5 );
  
    if (  scene.objs[0].w == 0.0 )
    {
        vec3 lp = scene.objs[0].xyz;
    	float dlp = distance(p,lp);
    	//f = min(f,dlp);
    	if ( dlp < 1. )
    	{
     		r=u(r,laptop_openID(at_pos(scene.objs[0].xyz,p),.45,0.5));
	    }
    }
    r = u( r,
      vec4(
        capped_cone_as_intersections_sd( 200., island_r - 50., 20., at_pos(island_center, p ).xzy ),
        ID_ROCK, atan(p.x-island_center.x,p.z-island_center.z),p.y  ) );
    r=u(r,
  vec4(capped_cone_as_intersections_sd( 20., island_r + 100., island_r, at_pos(island_center+vec3(0,-20.,0), p ).xzy ),ID_SAND,p.xz));
   
   
    {  
      vec3 scp = vec3(0,.07,1.2), cp = scp;
    float f = sphere_sd( .07, at_pos(cp,p)  );
    cp.xz += vec2(.2,0.13);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
    cp.xz += vec2(.02,0.33);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
    cp.xz += vec2(-.32,-0.2);
    f = min( f, sphere_sd( .07, at_pos(cp,p) ) );
	    
    f=min(f,coconut(at_pos(scene.objs[int(OBJ_V_COCONUT)-1].xyz,p)) + 1e37 * scene.objs[int(OBJ_V_COCONUT)-1].w );
    r=u(r,vec4(f,ID_COCONUT,p.xz));
    
    }
    
    
    if ( scene.boat.w == 0.0 )
    {
     SceneResult bsr=GetBoatDistance(at_pos(scene.boat.xyz,p));
    r = u(r, vec4(bsr.fDist,bsr.iObjectId,bsr.vUVW.yz));    
    }
    
    r= u(r, vec4(    little_table(at_pos(vec3(10.,0.5,10.),p)),ID_BLACK,vec2(0))  ); 
    
    r= u(r, vec4(
    sscreen_bottle( at_pos( scene.objs[int(OBJ_V_SSCREEN)-1].xyz, p ) )
        + 1e37 * scene.objs[int(OBJ_V_SSCREEN)-1].w,
                 ID_SSCREEN, vec2(0)) );
    
      r=u(r,towelID(at_pos(vec3( 17, 0, 10),p),90.,ID_BAF_TW) );
    r=u(r,towelID(at_pos(scene.mpallin.xyz-vec3(0.,.11,0.),p),0.,ID_MPA_TW) );
    
      r = u(r,vec4(palm(p),ID_PALM,vec2(0)) );
    {
        vec3 mp = scene.mpallin.xyz;
    	float dmp = distance(p,mp);
    
    	if ( dmp < 2. )
    	{
	    	r=u(r,vec4(mpallin(p),ID_MPAL,p.xz));
	    }
    }
    {
        vec3 mp = scene.bafryce.xyz;
    	float dmp = distance(p,mp);
 
    	if ( dmp < 2. )
    	{
	    	r=u(r,vec4(bafryce(p),ID_BAFRYCE,p.xz));
	    }
    }
    
	return r;
}

// Function 3554
float scene(vec3 p) {
    float s = ground(p);
    s = min(s, cube(cubeDir0 * (p - cubePos0)));
    s = min(s, cube(cubeDir1 * (p - cubePos1)));
    s = min(s, cube(cubeDir2 * (p - cubePos2)));
    s = min(s, cube(cubeDir3 * (p - cubePos3)));
    s = min(s, cube(cubeDir4 * (p - cubePos4)));
    return s;
}

// Function 3555
float IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)
{
    float intersectionT = LARGE_NUMBER;
    vec3 intersectionNormal = vec3(0, 0, 0);

    float t = LARGE_NUMBER;
    normal = vec3(0, 0, 0);
    materialID = INVALID_MATERIAL_ID;

    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)
    {
        UpdateIfIntersected(
            t,
            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),
            intersectionNormal,
            LIGHT_BASE_MATERIAL_ID + lightIndex,
            normal,
            materialID);
    }

    
    UpdateIfIntersected(
        t,
        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),
        intersectionNormal,
        CHECKER_FLOOR_MATERIAL_ID,
        normal,
        materialID);

    
    return t;
}

// Function 3556
float get_map_sdf(vec2 pixel_coord) {
    
    
    // Calculate the tile X and Y IDs for this pixel
    vec2 inner_coord = mod(pixel_coord, 1.0);
    
    ivec2 tile_ids = ivec2(pixel_coord - inner_coord);
    
    float a = float(get_tile(tile_ids));
    float b = float(get_tile(tile_ids + ivec2(1.0, 0.0)));
    float c = float(get_tile(tile_ids + ivec2(0.0, 1.0)));
    float d = float(get_tile(tile_ids + ivec2(1.0, 1.0)));
    
    return mix(
        mix(a, b, inner_coord.x),
        mix(c, d, inner_coord.x),
    	inner_coord.y
    );
}

// Function 3557
int map(ivec4 c, int i)
{
	if (i == 0) return c.x;
	if (i == 1) return c.y;
	if (i == 2) return c.z;
	if (i == 3) return c.w;
    return 0;
}

// Function 3558
vec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )
{
    
//. Ambifix is a "notation" I (@Yambam) invented, my goal is to make learning and making use of maths more intuitive.
//: Comments like this these are statements in a hypothetical shader language based on ambifix, with the values omitted.
    
    //if (xy.x<0.-1.) return vec2(1000.,-1.);
    xy.x = clamp(xy.x,-1.,2.); //clamp((xy.x/size+1.)/(1./size+1.),0.,1.);
    xy.y = clamp(xy.y,0.,1.); //clamp(xy.y,-size,1.+size);
    
    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);
    //float s = round(xy.x*dimensions.x)+(dimensions.x+1.)*floor(xy.y*dimensions.y);
    float px = round(xy.x*dimensions.x)/dimensions.x;
    float py = floor(xy.y*dimensions.y)/dimensions.y;
    //4.00*clamp(-.2+1.4*iMouse.x/iResolution.x,0.,1.)
    vec2 offset =   vec2(xy.x,           xy.y-py)
                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));
    float d = 2.*abs(offset.x)+1.*abs(offset.y);
    //float d = 2.*length(offset);
    
    //Old code:
    //float d =  4.00*(abs(xy.x   -clamp(px,0.,1.))
    //          +1.00* abs(xy.y-py-clamp(xy.y-py,0.+size,1./dimensions.y-size)));
//. //float d =           (-        (clamp  ) -) (abs)
//: //          (+ (-  -) (- (-  -) (clamp  ) -) (abs) +)
    
    //aligned for comparison of GLSL ES infix code versus (hypothetical) ambifix code
    //
   ///                   xy.x                   px                   0.,1.
   ///                   xy.y    py             xy.y    py           0.,.5-size
   //a  float d =   (abs(               - clamp(            ,                   )        )
   //a             + abs(      -        - clamp(      -     ,                   )        ));
//.//a  float d =                      (-                     (clamp            ) -) (abs)
//://a            (+          (-    -) (-            (-    -) (clamp            ) -) (abs) +)
   ///                   xy.x                   px                   0.,1.
   ///                   xy.y    py             xy.y    py           0.,.5-size
    //
	//
    
    return vec2(d,s);
}

// Function 3559
float map(vec3 p){
    float a=0.,cid=rand(floor(p.xz/20.+.5)*10.),d=p.y+gn(p.xz*.1)*4.-1.;
    if(d<.5)
        d-=max(texture(iChannel2,p.xz*.05).g-.6,0.)*.2+
        	max(6.-length(p),0.)+
        	min(texture(iChannel2,p.xz).b,.5)*
        	smoothstep(2.,0.,length(ro-p))*.01+
        	max(gn(p.xz)-.8,0.)*.5
       	;
    vec3 o=p,q;
    p.xz=mod(p.xz+10.,20.)-10.;
    mat2 r=r2d(cid*.7-.3);
    p.y-=1.;
    if(length(o.xz)<7.)p.y-=4.+sin(time*.2),a=1.;
    p.yz*=r,p.xz*=r;
    q=p;q.yz*=r;
    p.xz*=r2d(p.y*.2);
    p=abs(p)-(vec2(2.-max(-p.y,0.)*.5,2.).xyx+vec3(gn(p.zy*vec2(.1,1)*1.5),gn(p.xz)*.5,gn(p.xy*vec2(.1,1)*1.5)));
    d=min(min(d,-length(o)+60.),bmin(
        length(max(p+noise(p*4.)*.3,0.))-.2-a,
        max(max(abs(q.x)+2.,abs(q.z)-3.*cid)-3.,abs(q.y-2.)-.4),
        .5
    )-cid);
    return min(d,max(
        noise(mod(o*5.+vec3(0,-time*3.*sign(o.y-3.5),0),100.)-50.)-.1-step(3.5,o.y)*.05,
        max(length(o.xz)-5.+noise(o.xy*.4)*2.,-o.y-5.))
   	);
}

// Function 3560
v0 map(v2 pos, int processedMaterial
){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise
 ;maxGISize = 0.
 ;rayObj = 0
 ;v3 w = v3(pos,1)//worldSpace
 ;beginMaterial(0)
 ;SUB(box(w,v2(0,0,0),v2(10,2.5,10)))
 ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))
 ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))
 ;endMaterial()
 ;v3 c=beginObj(oCubeMy,w)//cubespace, not color
 ;//ADD(box(c,v2(0,0,0),v2(1)))
 ;//c.xz = abs(c.xz)
 ;for(int i=0;i<4;i++
 ){beginMaterial(i)
  ;ADD(sphere(c,v2(0,0,0),1.))
  ;endMaterial()
  ;c=abs(c)
  ;c=beginObj(oCubeChil,c);}
 ;v3 blackHoleSpace = beginObj(oBlackHole,w)
 ;beginMaterial(8)
 ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))
 ;endMaterial()
 ;v3 tunnelSpace = beginObj(oTunnel,w)
 ;beginMaterial(3)
 ;ADD(box(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))
 ;ADD(box(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))
 ;endMaterial()
 ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)
 ;beginMaterial(4)
 ;ADD(box(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))
 ;ADD(box(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))
 ;endMaterial()
 ;v3 trainSpace = beginObj(oTrain,w)
 ;beginMaterial(7)
 ;ADD(box(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))
 ;ADD(box(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))
 ;ADD(box(trainSpace,v2(0)      ,v2(.1,.1,.18)))
 ;ADD(box(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))
 ;ADD(box(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))
 ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))
 ;endObj()
 ;endMaterial()
 ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))
 ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5
 ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))
 ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)
 ;vma+=(1.-vma)*temp*AccretionDisk
 ;for(int L=0; L<3; L++
 ){
  ;ADD(sphere(w,oliPos[L]
              //o_lights[L].b
              ,0.001))
  ;
  ;v2 relPos = oliPos[L]-pos//o_lights[L].b
  ;oliHal[L]//o_lights[L].haloResult 
      += o*(0.02/(dot(relPos,relPos)+0.01))
  ;}
 ;return o;}

// Function 3561
vec4 distance_field(vec3 co) {
    float rad = clamp(co.z, 0.0, 10.0) * 0.05 + 0.4;
    //co = mod(co, vec3(1.0)) - 0.5;
    co = (co - clamp(round(co), -5.0, 5.0));
    return sphere_sdf(co, rad);
}

// Function 3562
float capsuleSDF(vec3 p, float h, float r)
{
	p.y -= clamp(p.y, 0.0, h);
	return length(p) - r;
}

// Function 3563
float distanceToLine(vec2 p, vec2 nml, float h) {
    return dot(nml, p) - h;	// Rounding error here if nml is not normalized 100%
}

// Function 3564
float MapBox(in vec3 pos, in vec3 half_size)
{//center at (0,0,0)
	vec3 v = abs(pos)-half_size;
	
	if (v.x<0.0 || v.y <0.0 || v.z<0.0)
		return max(max(v.x, v.y), v.z);
	return length(v);
}

// Function 3565
float dist(vec3 position)
{
    float m = 9999.0;
    vec4 audio = texture(iChannel0, vec2(0.0, 0.0));
    vec2 uv = vec2(position.x, position.y) * 1.0;
    vec4 col = texture(iChannel0, uv).rgba;

    Object o = objects[0];
    vec3 p = position + o.pos;

    p = p * o.rot;
    float f = 0.0;

    float a = sdBox(p, o.size);
    float b = sdSphere(p, o.size.x);
    float au = audio.x;

    f = au * a + (1.0 - au) * b;
    f -= sdSphere(p, o.size.x) * (0.3 + au * 0.4);

    m = min(f, m);
    return m;
}

// Function 3566
float sdf_q(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -4, 0), vec3(4, -8, 0)));
    return t;
}

// Function 3567
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn, w;
  vec2 b, ib;
  float dstBall, dstObj, dstSheet, c, dEdge;
  dstBall = BBallHit (ro, rd);
  if (SheetSilHit (ro, rd) < dstFar) {
    if (vuMode == 1.) dstSheet = SBallHit (ro, rd);
    else dstSheet = SheetRay (ro, rd);
  } else dstSheet = dstFar;
  rdSign = sign (rd);
  dstObj = ObjRay (ro, rd);
  col = vec3 (0.);
  if (min (min (dstBall, dstObj), 1.01 * dstSheet) < dstFar) {
    if (dstSheet < min (dstBall, dstObj)) {
      if (vuMode == 0.) {
        vn = SheetNf ();
        b = 13. * qgHit / (0.5 * vec2 (nBallEy - 1)) + vec2 (0., 0.5);
        ib = PixToHex (b);
        dEdge = HexEdgeDist (b - HexToPix (ib));
        c = mod (dot (mod (2. * ib + ib.yx, 3.), vec2 (1., 2.)), 3.);
        col4 = (c == 0.) ? vec4 (0.7, 0.6, 0.2, 0.5) : ((c == 1.) ? vec4 (0.6, 0.2, 0.2, 0.5) :
           vec4 (0.2, 0.6, 0.2, 0.5));
        col4 = mix (vec4 (0., 0., 0.4, 0.1), col4, smoothstep (0.08, 0.13, dEdge));
        if (dot (rd, vn) > 0.) col4 = vec4 (0.8 * col4.rgb, 0.);
        b = abs (qgHit - 0.5 * float (nBallEy - 1)) - 0.5 * float (nBallEy - 1) + 0.1;
#if SCYL
        if (b.y > 0.) col4 = vec4 (0., 1., 1., 0.1);
#else
        if (max (b.x, b.y) > 0.) col4 = vec4 (0., 1., 1., 0.1);
#endif
      } else if (vuMode == 1.) {
        vn = vnSBall;
        col4 = vec4 (0.7, 0.4, 0.1, 0.2);
      } else if (vuMode == 2.) {
        vn = SheetNf ();
        col4 = vec4 (HsvToRgb (vec3 (max (0.7 - nsCount / float (nsMax), 0.), 1., 0.9)), 0.1);
      }
    } else if (dstBall < dstObj) {
      vn = vnBall;
      col4 = vec4 (0.2, 0.2, 0.6, 0.1);
    } else if (dstObj < dstFar) {
      ro += rd * dstObj;
      vn = ObjNf (ro);
      if (idObj == 1) {
        w = smoothstep (0., 0.07, abs (fract (5. * ro / hbLen + 0.5) - 0.5));
        col = vec3 (mix (vec3 (0.4), vec3 (0.5, 0.5, 0.7),
           dot (abs (vn) * w.yzx * w.zxy, vec3 (1.))));
        col *= WallAO (ro);
      } else if (idObj == 2) col = vec3 (0.45);
      col4 = vec4 (col, 0.1);
    }
    col = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +
       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
  }
  return clamp (col, 0., 1.);
}

// Function 3568
vec3 tonemapUncharted2Helper(vec3 x)
{
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

// Function 3569
vec2 map( vec3 pos ){  
   
    
    vec2 ring;


    vec2 res = glasses( pos );
    vec2 plane = vec2( sdPlane( pos , vec4( 0., 1. , 0. , .17 ) ), 20. );
    
    res = opU( res , plane );
    

    
    	
   	return res;
    
}

// Function 3570
vec3 maptex2(vec3 p)
{
 	vec3 g = p;
    vec3 gid = floor(p/20.);
    g.xy *= mm2(-gid.z*.4);
    g.xz = mod(g.xz,20.)-10.;
    return g;
}

// Function 3571
float scene(vec3 p) {
	return sdNoComment(rY(p + vec3( 0.0,  0.0, 4.0) + XY, -T), vec3(0.5, 0.5, 0.5));
}

// Function 3572
float map(vec3 p){
    
    // Floor.
    float fl = -p.z + .03;

    // The extruded blocks.
    vec4 d4 = blocks(p);
    gID = d4.yzw; // Individual block ID.
    
 
    // Overall object ID.
    objID = fl<d4.x? 1. : 0.;
    
    // Combining the floor with the extruded image
    return  min(fl, d4.x);
 
}

// Function 3573
vec2 barrelDistort(in vec2 p, in vec2 alpha) {
    return p / (1.0 - alpha * dot(p, p));
}

// Function 3574
float map(in vec2 xz)
{
    vec2 p = floor(xz*.13)/.13;
    vec2 q = floor((xz-.7)*.21)/.21;
    vec2 r = floor((xz-.3)*.47)/.47;
    
    float Hp = Hsh2(p), Hq = Hsh2(q), Hr = Hsh2(r);
    float Pp = step(.6,Hp), Pq = step(.6,Hq), Pr = step(.5,Hr);
    
    float tex = 1.*Hp*Pp + .5*Hq*Pq +.3*Hr*Pr;	  
    hitScale = Pp + 2.5*Pq + 5.*Pr;
    
    return tex;
    
}

// Function 3575
float sceneSDF(const in vec3 samplePoint) {
    HitInfo hit = sceneH(samplePoint);
    return hit.dist;
}

// Function 3576
float rectSDF( vec2 st, vec2 s){
    st = st*2.-1.;
    return max(abs(st.x/s.x), abs(st.y/s.y));
}

// Function 3577
rayhit rayScene(vec3 rp, vec3 rd) {
    rayhit h;
	h.normal.w = VIEW_DISTANCE;
    
    //your custom scene code goes here
    
    #define wallmat() h.diffuse = vec4(.8,.8,.8,0);\
    h.metallic = 0.;h.opacity = 1.
    
    //floor
    rt(rayPlane(rp,rd,vec3(0,-1,0),vec3(0,1,0)),
    	wallmat();
    );
    
    //ceiling
    rt(rayPlane(rp,rd,vec3(0,1,0),vec3(0,-1,0)),
    	wallmat();
        //light emission
        vec2 hp = abs(rp.xz+rd.xz*s.w);
        h.diffuse.w = max(0.,(.3-max(hp.x,hp.y))*120.);
    );
    
    //back wall
    rt(rayPlane(rp,rd,vec3(0,0,1),vec3(0,0,-1)),
    	h.metallic = 1.;
        h.roughness = 0.001;
        h.specular = vec4(.95,.95,.95,0);
        h.opacity = 1.;
    );
    
    //red right wall
    rt(rayPlane(rp,rd,vec3(1,0,0),vec3(-1,0,0)),
    	h.diffuse = vec4(1,0,0,0);
        h.metallic = 0.;
        h.opacity = 1.;
    );
    
    //green left wall
    rt(rayPlane(rp,rd,vec3(-1,0,0),vec3(1,0,0)),
    	h.diffuse = vec4(0,1,0,0);
        h.metallic = 0.;
        h.opacity = 1.;
    );
    
    //raymarched volumetric cloud cube
    #define CUBE_POS vec3(.5,-.5,-.5)
    rtc(cloudCube(rp-CUBE_POS,rd),CUBE_POS,.5,
        h.metallic = 0.;
        h.diffuse = vec4(1.8,1.8,1.8,0);
        h.opacity = .4;
        h.refrIndex = 1.;
    );
    
    //chromatic refractive triangle prism
    #define PRISM_POS vec3(-.4,-.7,-.2)
    rtc(rayTriPrism(rp-PRISM_POS,rd),PRISM_POS,.5,
    	h.metallic = 1.;
        h.specular = vec4(1,1,1,0);
        h.opacity = 0.;
        CHROMA(h.refrIndex = 1.;,//r
               h.refrIndex = .9;,//g
               h.refrIndex = .8;);//b
    );
    
    return h;
}

// Function 3578
float map (vec3 p) {
    float d = length(p-light.xyz)-light.w;
    d = min(d,max(30.-p.z,0.));
    grp=p*0.01;
    
    p = mm*p;
    for (int i = 0; i < 5; i++) {
        float t = abs(p.y);
        p.y = p.x;
        p.x = t;
        p = mm*(p-.1);
    }
    float q = 5.;
    float a = 1.5*((atan(p.x,p.z)))+0.05*ui;
    mat2 mn = mat2(sin(a),cos(a),-cos(a),sin(a));
    vec2 u = mn*vec2(length(p.xz)-2.,p.y);
    float d1 = d;
    vec2 w = max(abs(u)-vec2(0.1,0.5),0.);
    d = min(d,length(w)-0.1-0.01*(sin(50.*(dot(u,u))+sin(20.*atan(p.x,p.z)))));
    if (d1 != d) grp = vec3(u,atan(p.x,p.z));
    return d;
}

// Function 3579
float scene(vec3 p) {
    return max(length(p)-7.5, mandelbox_dist(p));
}

// Function 3580
float distanceFromTarget(float p)
{
    return 0.0 - p;
}

// Function 3581
vec3 colMap(float v) {

	v=mod(v, PI+1.3)-.8;	
    return vec3(
		sin(sin(v-.6)),
		sin(sin(v)),
		sin(sin(v+.8))
	);

}

// Function 3582
vec3 distMapNormal(vec3 p) {
    return normalize(vec3(
        distMap(vec3(p.x+NORMAL_EPILSON,p.y,p.z))-distMap(vec3(p.x-NORMAL_EPILSON,p.y,p.z)),
        
		distMap(vec3(p.x,p.y+NORMAL_EPILSON,p.z))-distMap(vec3(p.x,p.y-NORMAL_EPILSON,p.z)),
        
        distMap(vec3(p.x,p.y,p.z+NORMAL_EPILSON))-distMap(vec3(p.x,p.y,p.z-NORMAL_EPILSON))
        ));
}

// Function 3583
vec2 sdf(vec3 p){
   vec3 op = p;
   float bt = fract(iTime*.01); // This should be fftIntegrated
  
   p += vec3(6,3.,-0.0); // Offset the planet, to have some composition
   p.xy *= rot(-.785); // Rotation of the planet, yes it's cheap trick and not correct but it works
  
  float tt = texNoise(vec2(atan(p.x,p.z),p.y)*.025+bt,iChannel2).r; // TexNoise to have the planet geology
 
 
  float ttt = texture(iChannel1,fract(vec2(atan(p.x,p.z)+tt*6.+fGlobalTime))).r *.15; // Blyatiful
/*                                ^----^           ^        ^       ^---- So the whole turns around the planet
                                  ^                ^        ^------------ This will shift the line, with the noise texture, creating a nice effect
                                  ^                ^--------------------- Spherical projection (as I phrase it, sorry if it's not correct)
                                  ^-------------------------------------- This is not needed on bonzomatic as the fftTexture is wrapped repeat                        
*/
   tt = floor(tt*100.)/100.; // Create the stairs geology effect
  
  vec2 h;

  h.x = length(p)-5.-tt; // That's a sphere with the displacement
  h.y = 1.-(ttt); // Ok here is the dirty secret, When the fft pass a threshold, it will trigger later the glow
  
  vec2 t; // Boring stuff, that utlimately finished as a space Auror Borealis
   
  op.x -=2.;
   op.z = mod(op.z,5.)-2.5;
   op.y +=sin(op.z*5.+bt);
   op.xy *=rot(fGlobalTime);
   op.xz *=rot(floor(bt*20.)*1.33);
  t.x = box(op,vec3(.9)); // Yeah, a cube as a start, was it necessary ? LOL.
  t.y = 2.;
  
  h = t.x < h.x ? t:h;
  
  h.y = max(h.y,.1);
  return h;
  }

// Function 3584
vec3 TonemapACESFilm(vec3 x)
{
    return saturate((x * (A * x + B)) / (x * (C * x + D) + E));
}

// Function 3585
vec3 RgbIntersectScene(vec3 posRay, vec3 normalRay)
{
	SHit hit;
	vec3 rgbLight = vec3(0);
	float r = 1.0;
	int cStepTotal = 0;

	for (int iBounce = 0; iBounce <= g_cBounce; ++iBounce)
	{
		int cStep = 0;
		bool fIntersect = FIntersectScene(posRay, normalRay, hit, cStep);

		cStepTotal += cStep;

#if DEBUG_DIFFUSE
		// BB Should use exact sRGB conversion

		return (fIntersect) ? pow(hit.m_mtl.m_rgbDiffuse, vec3(1.0 / 2.2)) : vec3(0);
#endif

#if DEBUG_NORMALS
		return (fIntersect) ? hit.m_normal * 0.5 + 0.5 : vec3(0);
#endif

		if (fIntersect)
		{
			vec3 posHit = posRay + normalRay * hit.m_s;

			float rFog = RFog(hit.m_s, posRay, normalRay);
			rgbLight += (1.0 - rFog) * r * RgbFog(normalRay);
			r *= rFog;

			vec3 rgbLightHit = RgbLightHit(posHit, normalRay, hit);

#if DEBUG_AO || DEBUG_SHADOWS
			return rgbLightHit;
#endif

			rgbLight += r * rgbLightHit;

			// Prepare for next bounce

			vec3 normalReflect;

#if ENABLE_IS
			{
				// GGX importance sampling (see Karis notes linked above)

				float gGgxAlphaSqr = GSqr(hit.m_mtl.m_gGgxAlpha);
				float radPhi = 2.0 * g_gPi * g_vecURandomIS.x;
				float gCosTheta = sqrt((1.0 - g_vecURandomIS.y) /
									   (1.0 + (gGgxAlphaSqr - 1.0) * g_vecURandomIS.y));
				float gSinTheta = sqrt(1.0 - GSqr(gCosTheta));

				vec3 normalHalfTangentSpace = vec3(
												gSinTheta * cos(radPhi),
												gSinTheta * sin(radPhi),
												gCosTheta);

				// Construct orthonormal basis (Frisvad method)

				float gA = (hit.m_normal.z > -0.99999) ? 1.0 / (1.0 + hit.m_normal.z) : 0.0;
				float gB = -hit.m_normal.x * hit.m_normal.y * gA;
				vec3 tangent = vec3(1.0 - GSqr(hit.m_normal.x) * gA, gB, -hit.m_normal.x);
				vec3 binormal = vec3(gB, 1.0 - GSqr(hit.m_normal.y) * gA, -hit.m_normal.y);
				vec3 normalHalf = normalHalfTangentSpace.x * tangent +
					normalHalfTangentSpace.y * binormal +
					normalHalfTangentSpace.z * hit.m_normal;

				normalReflect = normalRay - 2.0 * dot(normalRay, normalHalf) * normalHalf;

				float gDotRay = saturate(dot(hit.m_normal, -normalRay));
				float gDotReflect = saturate(dot(hit.m_normal, normalReflect));
				float gDotHalf = saturate(dot(hit.m_normal, normalHalf));
				float gRayDotHalf = saturate(dot(-normalRay, normalHalf));
				if (gDotReflect > 0.0)
				{
					float gVisRcp = GGgxVisRcp(gGgxAlphaSqr, gDotRay) *
									GGgxVisRcp(gGgxAlphaSqr, gDotReflect);
					float uFresnel = UFresnel(gRayDotHalf);
					float rSpecular = mix(g_rSpecular, 1.0, uFresnel);
					r *= 4.0 * rSpecular * gRayDotHalf * gDotReflect / (gVisRcp * gDotHalf);
				}
				else
				{
					// NOTE a break here makes the AMD compiler on Windows unhappy

					r = 0.0;
					posRay = vec3(0.0, 0.0, g_zMax * 10.0);
					normalRay = vec3(0.0, 0.0, 1.0);
				}
			}

#else // !ENABLE_IS
			// BB This works ok for our low roughness values, but for rougher materials would want
			//	something better, e.g. an analytic approximation to the pre-integrated ambient
			//	specular BRDF LUT in Karis's notes.

			normalReflect = reflect(normalRay, hit.m_normal);
			r *= mix(g_rSpecular, 1.0, UFresnel(saturate(dot(normalReflect, hit.m_normal))));
#endif // !ENABLE_IS

			posRay = posHit + normalReflect * 10.0;
			normalRay = normalReflect;
		}
		else
		{
			float rFog = RFog(1e10, posRay, normalRay);
			rgbLight += (1.0 - rFog) * r * RgbFog(normalRay);
			r *= rFog;

			// Sun + sky
			// BB Just hacking here, can probably be simplified a bunch.

			float gDotLight = dot(normalRay, g_normalLight);

			vec3 vecPerp = normalRay - gDotLight * g_normalLight;

			float gPerpDistSqr = dot(vecPerp, vecPerp);
			float rGlow = 20.0;

			bool fDrawSun = true;
#if !ENABLE_IS
			fDrawSun = (iBounce == 0);
#endif

			if (fDrawSun &&
				gDotLight > 0.0 &&
				gPerpDistSqr < GSqr(RLightCone() * rGlow * gDotLight))
			{
				float gSunLum = GLuminance(RgbSunDisc());
				float gK = 0.1;
				gSunLum /= gK + gSunLum;
				float gNewLum = gSunLum * GSqr(smoothstep(
											(RLightCone() * rGlow),
											RLightCone() * 1.0,
											length(vecPerp)));
				gNewLum *= gK / (1.0 - gNewLum);

				float rSun = r;

#if FULL_STRENGTH_SUN
				rSun = 1.0;
#endif

				if (iBounce > 0)
				{
					rSun *= g_rSunSpecScale;
				}

				rgbLight += rSun * gNewLum / GLuminance(RgbSunDisc()) * RgbSunDisc();
			}

			rgbLight += r * RgbSky();

			float u = saturate(
						-gDotLight / (GDotLightCone() + 1.0) + 1.0 / (1.0 / GDotLightCone() + 1.0));
			float g = u / max(1.0 - u, 1e-8);
			float rHaze = exp(-g * 10.0);
			rHaze += rHaze * (1.0 + rHaze * (1.0 + rHaze * (1.0 + rHaze)));
			rgbLight += r * 0.4 * RgbLight() * rHaze;

			// NOTE a break here makes the AMD compiler on Windows unhappy

			r = 0.0;
			posRay = vec3(0.0, 0.0, g_zMax * 10.0);
			normalRay = vec3(0.0, 0.0, 1.0);
		}
	}

#if DEBUG_STEPS
	return vec3(float(cStepTotal) / 100.0);
#endif

	return rgbLight;
}

// Function 3586
vec2 getDist(vec3 p) {

    float matId;
    p.y -= 0.2;
    vec3 orig =  vec3(0, 1, 6.4);
    
    //HEAD
	vec3 headPos = p-orig;
    vec3 direction =  normalize(headPos);
    headPos.x -= (p.y - 1.1) * 0.35 * direction.x;
    headPos.x += pow(abs(sin((p.y + 2.) * 8.)) * 0.1, 1.2 + p.y) * normalize(headPos).x;  

    float head = length(headPos) -1. + p.y * 0.5;
    
    //HAIR
    vec3 hairPos = p-orig;
    float hair = sdRoundedCylinder(hairPos, 0.24, 0.15, 0.27);
    hair += displacement(hairPos) * .005;
    
    if (hair < head) {
       head = smin(hair, head, 0.01);
        matId = 0.;
    } else {
        matId = 2.;
    }
      
    //EYES
    vec3 eyePos = headPos + vec3(0.05 * direction.x, 0.25, .5);
    vec3 eyeOff = vec3(0.19, 0., 0.);
    eyePos.x = abs(eyePos.x);

    float eye = length(eyePos -eyeOff) -0.12;
    if (-eye > head) { head += eye; }
    head = min(eye + 0.01, head);    
    
    vec3 eyeBrowPos = vec3( rot( vec2(eyePos.x * 1.2 - eyeOff.x * 1.3 , eyePos.y -0.17) , 1.5),  eyePos.z+0.1);
    eyeBrowPos.x -= (1. - pow(abs(sin(g_time)), 0.4)) * 0.03;
    eyeBrowPos.x += sin(eyeBrowPos.y * 20. - 1.) * .012;
    float eyeBrow = sdRoundedCylinder(eyeBrowPos, 0.005, 0.04, 0.11);
    
    if (eyeBrow < head) {
        head = smin(eyeBrow, head, 0.1);
        matId = 0.;
    }
    
    //GLASSES
    eyePos.z += 0.2;
    eyeOff.x += 0.02;
    float glass = sdBox(eyePos-eyeOff, vec3(0.15, 0.07 , 0.02));
    eyeOff.x += 0.24;
    eyeOff.z += 0.2;
    float glassb = sdRoundedCylinder(vec3(rot((eyePos-eyeOff).xz, -.4), eyePos.y), 0.005, 0.02, 0.2);    

    eyePos.x *= 2.;
    eyePos.y *= 1.8;
    eyePos.z *= 0.9;
    eyePos.z -= 0.2;
    float glassC = sdCappedTorus( vec3(eyePos.x, rot((eyePos+eyeOff).yz, -1.5)), vec2(0.2, 0.), 0.15, 0.02);

    if (glassC < head) {
        head = min(glassC, head);
        matId = 6.;
    }
    if (glassb < head) {
        head = min(glassb, head);
        matId = 6.;
    }
    
    if (glass < head) {
        head = min(glass, head);
        matId = 1.;
    }
     
    //NOSE
    vec3 nosePos = p-orig;
    nosePos.z += 0.7;
    nosePos.y += 0.15;
    nosePos.yz = rot(nosePos.yz,-0.3);
    float h = smoothstep(0.,0.3,-nosePos.y );
    float nose = 1.;
    nosePos.x = sqrt(nosePos.x*nosePos.x + 0.001);
    nose = smin( nose, sdSphere(nosePos-vec3(0.04, -0.3, 0.037),0.03 ), 0.1);
    nose = smin( nose, sdSphere(nosePos*vec3(1.05,0.95,1.)-vec3(.0, -0.155, 0.05),0.02), 0.19);
    head = smin(head,nose,0.05-0.04*h);
    if (nose - 0.001 < head) {
        matId = 2.;
    }
    
    //EARS
    vec3 earsPos = p-orig;
    earsPos.x = abs(earsPos.x);
    earsPos.y += 0.35;
    earsPos.y *= 0.7;
    earsPos.z += 0.1;
    earsPos.x -= 0.41;
    float ear = sdSphere(earsPos,0.08); 
    if (ear < head) {
        head = smin(head,ear,0.02);
        matId = 2.;
    }

    //MOUTH
    float mT = 0.88 - pow(abs(g_time) / 1.2, 1.8);
    vec3 mPos = p - vec3(orig.x + 0.7 * direction.x * mT, orig.y-.6, orig.z -0.55);
    mPos.y -= pow(abs(sin(abs(p.x))), 1.9 + mT * 0.3);
   	float mouth = length(mPos) - 0.05;
    mPos.x = orig.x + 0.69 * direction.x  * (1.55 - mT);
    mPos.z *= 1.8;
    mPos.z -= 0.064;
    mPos.y -= 0.015;
    mPos.y *= 0.95;
    float outMouth = length(mPos) - 0.05;
    if (-mouth - 0.008 > head ) {
        matId = 3.;
        head = smin(-mouth, head, 0.2);
    }
    
    head = smin(head, outMouth, 0.03);  
    outMouth = length(vec3(mPos.x, mPos.y - 0.01 ,  mPos.z))  - 0.05;
    if (outMouth - 0.022 < head){ matId = 4.; }
    
    //DOLLAR
    vec3 dollaInitialPos = headPos + vec3(1.66, -0.52, 1.6) - vec3(.5*sin(g_time),0., 1.*cos(g_time));
    vec3 dollaPos = dollaInitialPos;
    dollaPos.x *= 0.85 - p.y * 0.01;
    dollaPos.xy *= 2.5;
    dollaPos.y *= 1.1;
    dollaPos.z += sin(iTime + dollaPos.y * 5.) * 0.05;
    dollaPos.xy = rot( dollaPos.xy, 0.9);
    dollaPos.x = dollaPos.y > 0. ? -dollaPos.x + 0.36 : dollaPos.x;
    float dollaA = sdCappedTorus(dollaPos, vec2(sin(iTime-.3), cos(iTime-.3)), 0.22, 0.025);
   
    dollaPos.xy = dollaInitialPos.xy - vec2(0.02, 0.06);
    dollaPos.xy *= 2.;
    dollaPos.xy = rot( dollaPos.xy, -.2);
    dollaPos.x -= 0.05;
    dollaPos.x = abs(dollaPos.x);
    dollaPos.x -= 0.05;
    float dollaB = sdRoundedCylinder(dollaPos, 0.01, 0.02, 0.49 * abs(cos(iTime / 2. - 1.) ));    


   if (dollaA < head) {
       head = min(dollaA, head);
       matId = 5.;
    } 
    if (dollaB < head) {
        head = smin(dollaB, head, 0.075);
        matId = 5.;
    }
    
    return vec2(head, matId);
}

// Function 3587
void mainCubemap( out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    fragColour = textureLod( iChannel0, rayDir, 0. ); // this needs NEAREST filter on the texture
	if ( iFrame == 0 ) fragColour = vec4(0);

    // wait for texture to load (I know the top of the cubemap should not be black)
    if ( textureLod( iChannel1, vec3(0,1,0), 0. ).r == 0. ) return;
    
    // early-out once we've got a good enough result
    if ( fragColour.a > 100.0 ) discard;
    
    const int n = 16;
    for ( int i = 0; i < n; i++ )
    {
        vec3 ray = HemisphereRand(rayDir,uint(i+n*iFrame)+quasi2.y*uint(fragCoord.x)+quasi2.x*uint(fragCoord.y));

        fragColour.rgb += LDRtoHDR(textureLod( iChannel1, ray, 0. ).rgb);
        fragColour.a += 1.;
    }
}

// Function 3588
float DistRay(Ray r, vec3 p) {
	return length(p-ClosestPoint(r, p));
}

// Function 3589
float map(vec3 p){
	float s=.2*sin(iTime+.1*p.z);
    p.xy=p.xy*rot(s)+.5+vec2(-s,s);
    return noise(p) - 0.2;
}

// Function 3590
vec3 DebugSDF(float d)
{
    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);
	col *= 1. - exp(-2.*abs(d));
	col *= .8 + .2*cos(120.*d);
    return mix(col, vec3(1), 1.-smoothstep(.0,.02,abs(d))); // white at zero
}

// Function 3591
float sceneLow(vec3 a) {
   float mainWave;
   float zVal = fractalNoiseLow(vec2(a.x - 5., a.z ), mainWave);
   return a.y + 0.2 + sin(zVal / 6.5);
}

// Function 3592
vec2 scene(vec3 ray ){
    float time = iTime;
    float floor = (ray.y + 1.2) - 
        cos(ray.x * 10.)* 0.2 - sin(ray.y* 10.);
    float radius = 0.5;
    
    
   // ray = mod(ray, modSpace) - 0.5*modSpace;
    
    ray = ray - vec3(0.,0.,2.0);
    vec3 ray2 = ray;
    vec3 ray3 = ray;
        
    pR(ray2.yz,time/3. + n((vec2(time/3. ) / 2.)) * 0.2);
    pR(ray3.yz,time/3.);
    
    vec3 ray4 = mix(ray2,ray3,(sin(time)/5.) + 1.);
    
    pR(ray4.xz, n(vec2(time/4.) ) );
    
    pR(ray4.xy, 0.2*n(vec2(time) ) ); 
    float blob = bloby(ray4);
    float virus = virus(ray4);
	
    float ret = smin(blob,virus,.8  + (0.08* sin(time))) ;
    
    return vec2( ret,length(ray4)-0.5) ;//smin(smin(blob, sphere,0.6), sphere2,0.6) ;
}

// Function 3593
vec3 map(vec3 p) {
    float lat = 90. - acos(p.y / length(p)) * 180./PI;
    float lon = atan(p.x, p.z) * 180./PI;
    vec2 uv = vec2(lon/360., lat/180.) + 0.5;
    vec3 c;
    c.xy = textureSeamless(iChannel0, uv).xy;
    c.x = max(c.x, 0.);
    c.z = speckle(1000. * uv, c.y);
    c.z *= 0.5 * FBM(vec3(50. * uv, iTime));
    return c;
}

// Function 3594
float SDF_MoonBody(vec3 p)
{
    return DispSphere(p, 1.0);
}

// Function 3595
vec4 scene(vec3 p){

    //return sdSphere(p, 0.5, vec3(1,0,0));

    float h = 0.06;
    
    //Body
    vec3 pG = rotateY(p- vec3(-0.5,0.5,0.0), degToRad * -20.0);    
    pG = rotateX(pG, degToRad * sin(iTime) * 20.0 + degToRad * 60.0);
    
    
    vec4 d = body(pG, h, vec3(0.572, 0.313, 0.149));
    d = minVec4(d, neck(pG, vec3(0.133, 0.050, 0.007)));
    d = minVec4(d, strings(pG, vec3(0.827, 0.866, 0.894)));
    
    //float bands = step(mod(d.w * 2.0,1.2),0.5);
    
    float bands = step(fract(p.x * 2.0),0.5);
    
    vec4 pl = sdPlane(p, 0.0, vec3(0.5) * bands);
    
    d = minVec4(d, pl);
    
    return d;
}

// Function 3596
float map(vec3 p) {
    float d = distance(p, vec3(-1, 0, -5)) - 1.;     // sphere at (-1,0,5) with radius 1
    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);    // second sphere
    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);   // and another
    d = min(d, p.y + 1.);                            // horizontal plane at y = -1
    return d;
}

// Function 3597
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 objCol, col, vn;
  float dstHit, dstGrnd, dstObj, dstFlame, f, ao;
  int idObjT;
  dstHit = dstFar;
  dstGrnd = GrndRay (ro, rd);
  wSpan = 13.;
  fusLen = 12.;
  flameLen = 0.25 * fusLen;
  dstFlame = TransObjRay (ro, rd);
  idObj = -1;
  dstObj = ObjRay (ro, rd);
  idObjT = idObj;
  if (dstObj < dstFlame) dstFlame = dstFar;
  bool isGrnd = false;
  if (dstObj < dstGrnd) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    idObj = idObjT;
    objCol = FlyerCol (vn);
    if (idObj == 10) objCol = 0.7 * objCol + 0.5 * SkyCol (ro, reflect (rd, vn));
    float dif = max (dot (vn, sunDir), 0.);
    ao = ObjAO (ro, vn);
    col = objCol * (0.2 * ao * (1. +
       max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.)) +
       max (0., dif) * ObjSShadow (ro, sunDir) *
       (dif + ao * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.)));
    dstHit = dstObj;
  } else {
    dstHit = dstGrnd;
    if (dstHit < dstFar) {
      ro += dstGrnd * rd;
      isGrnd = true;
    } else col = SkyCol (ro, rd);
  }
  if (isGrnd) {
    vn = GrndNf (ro, dstHit);
    vec4 col4 = GrndCol (ro, vn);
    float dif = max (dot (vn, sunDir), 0.);
    col = col4.xyz * sunCol * (0.2 + max (0., dif) * GrndSShadow (ro, sunDir) *
       (dif + col4.w * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.)));
  }
  if (dstFlame < dstFar) col = FlameCol (col);
  if (dstHit < dstFar) {
    f = dstHit / dstFar;
    col = mix (col, SkyBg (rd), clamp (1.03 * f * f, 0., 1.));
  }
  col = sqrt (clamp (col, 0., 1.));
  return clamp (col, 0., 1.);
}

// Function 3598
float scenedf( vec3 pos )
{
    float dist = BIG_FLOAT;

    for (float i = 0.; i < 12.; i += 1.)
    {
        float s = PI * i/6.;
        float r = 5. + 5. * (.5 * cos(PI * i/2. + .2 * iTime) + .5);
        vec3 sphc = vec3(r * cos(s), .7, r * sin(s));
        dist = min(spheredf(pos - sphc, 1.), dist);
    }

    dist = min(yplanedf(pos, -1.3), dist);
	dist = min(cyldf(pos, 15.), dist);
    return dist;
}

// Function 3599
float intersectSDF(float distA, float distB) { return max(distA, distB); }

// Function 3600
vec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)
{
    vec2 lpos = uv - centre;
    float dist = length(lpos);
    float dx = dist / radius;
    vec2 ret = rotate(lpos, r + (dx * amount));
    return ret + centre;
}

// Function 3601
float SDF1(vec3 p){
    return length(sin(p*.6)-sin(p))-1.4;
}

// Function 3602
vec3 ToneMapFilmic_Hejl2015(vec3 hdr, float whitePt) {
    vec4 vh = vec4(hdr, whitePt);
    vec4 va = 1.425 * vh + 0.05;
    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;
    return vf.rgb / vf.www;
}

// Function 3603
float map(vec3 p){

     vec2 tun = p.xy - path(p.z);
     vec2 tun2 = p.xy - path2(p.z);
     return 1.- smoothMinP(length(tun), length(tun2), 4.) + (0.5-surfFunc(p));
 
}

// Function 3604
float map_water(vec3 pos)
{
    float h = (pos.y/tubeRadius + 1.)/2.;
    h+= wavesLev*(noise(pos*wavesFreq + iTime*vec3(0., 0.7, 0.3)) - 0.5);
    return h - waterLevel;   
}

// Function 3605
float dist(in vec4 l,in vec2 p,in vec2 o,in vec2 s,in float w) {
    l = l * s.xyxy * 0.423;
    l += o.xyxy + vec4(0.28, 0.46, 0.28, 0.46) * s.x;
    return w * length(s)/(ldist(l, p)/w); // 14.9250;
}

// Function 3606
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)
{        
  vec3 reflectDir = reflect( rayDir, normal );

  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);
  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);

  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );
  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99);  
  dif *= SoftShadow( shadowPos, sunPos);
  skylight *=SoftShadow(shadowPos, reflectDir);

  vec3 lightTot = vec3(0.0);

    
    
  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);
  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);
      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;
  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);
  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);
  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));
}

// Function 3607
float mapDist(vec3 p) {
    vec3 col;
    return map(p, col, false);
}

// Function 3608
SceneResult Armor_GetDistance( vec3 vPos )
{
    vPos.x = abs(vPos.x);

    vPos.y += 1.;
    
    float fScale = 1.4;
    vPos /= fScale;
    
    float fDist1 = Segment( vPos, vec3(0,10,2), vec3(6, 9, 0), 4., 4. );
    float fDist2 = Segment( vPos, vec3(0,10,0), vec3(0, 5, 0), 5., 6. );
    float fDist = SmoothMin( fDist1, fDist2, 1.5 );

    float fDistHole1 = Segment( vPos, vec3(0,12,-1), vec3(0, -2, -0.5), 3.5, 4.5 );    
    float fDistHole2 = Segment( vPos, vec3(0,10,2), vec3(8, 8, -1), 3.0, 3.0 );
    float fDistHole = SmoothMin( fDistHole1, fDistHole2, 1.5 );

    SceneResult result = SceneResult( fDist, MAT_WHITE, vec3(0.0) );
        
    result = Scene_Subtract( result, SceneResult( fDistHole, MAT_GREY, vec3(0.0) ));
    
    result.fDist *= fScale;
    

    return result;
}

// Function 3609
float distf(int world, vec3 p, inout float m)
{
	float d = 0.0;
	m = 0.0;
	
	if (world == 0) {
		d = 16.0 + p.z;
		m = 1.0;
		
		fUnionMat(d, m, pSphere(vec3(24,22,4) + p, 12.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(6,-35,4) + p, vec3(4,4,11), 1.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(19,-15,0) + p, vec3(4,4,15), 1.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(-12,20,12) + p, vec3(7,7,7), 1.0), 4.0);
	} else {
		d = 16.0 + p.z;
		m = 2.0;
		
		fUnionMat(d, m, pRoundBox(vec3(15,35,6) + p, vec3(4,12,9), 1.0), 5.0);
		fUnionMat(d, m, pRoundBox(vec3(-10,35,10) + p, vec3(15,3,5), 1.0), 5.0);
		fUnionMat(d, m, pRoundBox(vec3(15,-35,6) + p, vec3(12,6,15), 1.0), 5.0);
	}
	
	float portal = pTorus(p, vec2(12,1));
	
	fUnionMat(d, m, portal, 3.0);
	
	return d;
}

// Function 3610
float map( in vec3 pos )
{
    pos.yz *= rot(iTime*0.2);
    
    // Deform Space...
    float rad =  (1.0/(3.141*2.0)*5.0);
    float ang = atan(pos.x, pos.y);
    vec2 cyl = vec2(rad-length(pos.xy), pos.z);
    vec3 dp = vec3(cyl, ang * rad);

    // bounding box distance using deformed domain
    vec3 size = 0.5+sin(vec3(iTime,iTime*1.1,iTime*1.5))*0.5;
    float xs = .85 + (size.x);
    float zs = .65 + (size.y);
    float ys = .25 + (0.1*size.z);
    float boff = 0.2;		// bounding box offset
    float bthick = 0.01;	// bounding box thickness
    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick)-0.1;
    
    
    if (iMouse.z>0.5)
        d1 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff))-0.1;
    
    return d1*0.5;
}

// Function 3611
vec3 scene_color(vec3 q) {
	if (sphere_dist(q) < cylinder_dist(q))
		return vec3(  0.1 * cos(1.5*q + time) + 0.7);

	vec2 qp;
	q.z += 0.3 * sin(q.y + q.x);
	q.x += 0.3 * cos(q.y + q.x);
	qp.x = negmod(q.x, 2.0);
	qp.y = (q.z > 0.) ? negmod(q.z, 2.0) : q.z;
	return vec3(dot(normalize(qp), vec2(0.5, -1.0))*0.2);
}

// Function 3612
float distanceToGraphValue(vec2 p)
{
    //Vertical span for each signal
    float vSpan = float(COUNT)*(iResolution.x/iResolution.y);
    //x pos at pixel p.x
    float x = getDomainValue(p.x);
    
    float graphValues[COUNT];
    graphValues[0] = F(x);
    graphValues[1] = G(x);
    graphValues[2] = H(x);
    graphValues[3] = Func4(x);
    graphValues[4] = Func5(x);
    
    float minDist = INFINITY;
    for(int i=0; i < COUNT; ++i)
    {
        float vOffset = float(COUNT-1-i)/vSpan;
        vec2 p = vec2(p.x,(p.y-vOffset)*vSpan);
		minDist = min(minDist,abs(p.y-graphValues[i]));
    }
	return minDist;
}

// Function 3613
MapInfo ReadMapInfo( sampler2D mapSampler )
{
    MapInfo mapInfo;
    
    vec4 vData = ReadMapData( mapSampler, ivec2(0.0, 0.0) );
    
    mapInfo.iSectorCount = int(vData.x);
    
    return mapInfo;
}

// Function 3614
float heightMap(vec3 p){
 
    return cell(p.xy*2.); // Just one layer.
 
}

// Function 3615
float seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1000.0;    
    float hx = seaMap(ori + dir * tx);
    if(hx > 0.0) return tx;   
    float hm = seaMap(ori + dir * tm);    
    float tmid = 0.0;
    for(int i = 0; i < SEA_NUM_STEPS; i++) {
        tmid = mix(tm,tx, hm/(hm-hx));                   
        p = ori + dir * tmid;                   
    	float hmid = seaMap(p);
		if(hmid < 0.0) {
        	tx = tmid;
            hx = hmid;
        } else {
            tm = tmid;
            hm = hmid;
        }
    }
    return tmid;
}

// Function 3616
float get_angular_radius_of_sphere_at_distance_alternate(
	in float sphere_radius, in float sphere_distance
){
	float r = sphere_radius;
	float h = sphere_distance;
	// "a2": squared distance to the tangent point, found using pythagorean theorem, 
	// scaled so hypoteneuse = 1
	float a2 = 1.0-r*r/(h*h);
	return r * sqrt(a2) / (h * a2);
}

// Function 3617
float fogmap(in vec3 p, in float d, float ti)
{
    p.x *= .4;
    p.x += ti*1.5;
    p.z += sin(p.x*.5);
    p.z *= .4;
    return max(triNoise3d(p*.3/(d+20.),0.2, ti)-.4, 0.)*(smoothstep(0.,25.,p.y));
    //return triNoise3d(p*1.2/(d+20.),0.2, ti)*(1.25-smoothstep(0.,25.,p.y));
}

// Function 3618
float hyperbolic_line_dist(vec2 p, vec2 a, vec2 b){
    if(a == vec2(0.0)){
        return euclidean_line_dist(p,b,vec2(0.0,0.0));
    }
    vec2 p2 = map_to_origin(a, p);
    vec2 b2 = map_to_origin(a, b);
    return euclidean_line_dist(p2,vec2(0.0,0.0),b2);
}

// Function 3619
float distance_field(vec3 rp) {
    float sd = sphere(translate(rp, vec3(1,1,15)), 10.0);
    float sd2 = sphere(translate(rp, vec3(10.0 * sin(iTime),10,15)), 5.0);
    float pd = plane(rp, normalize(vec4(0,1,0,1)));
    sd = min(sd, sd2);
    return min(pd,sd);
}

// Function 3620
float PlaneSDF(vec3 p, vec3 n, float d) {
    return dot(p, n) - d;
}

// Function 3621
float sceneSDF(vec3 samplePoint) {
    return min(spheresSDF(samplePoint),boxSDF(samplePoint));
}

// Function 3622
float map(vec3 p) 
{
   R(p.yz, -25.53);//-0.4+iMouse.y*0.003); //change this string to be able to find "cloudy caves" :)
   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
   return Clouds(p) +  fpn(p*50.+iTime*5.);
}

// Function 3623
float sceneSDF(vec3 samplePoint) {
    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;
    float cubeDist = cubeSDF(samplePoint + vec3(0.0, sin(iTime), 0.0));
    return intersectSDF(cubeDist, sphereDist);
}

// Function 3624
float distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3, float r, inout vec2 uv_)
{
    float d = 10000.0;
    float rnd =getRand01Sph(p1+p2+p3).x;
    float rnd2=getRand01Sph(p1+p2+p3).y;
    // random rotation of torus-start-edges
    //if  (rnd>.33) { vec3 d=p1; p1=p2; p2=p3; p3=d; }
    //if  (rnd>.66) { vec3 d=p1; p1=p2; p2=p3; p3=d; }
    vec3 p1i=p1,p2i=p2,p3i=p3;
    float s1=step(.333,rnd);
    float s2=step(.666,rnd);
    p1=mix(p1i,p2i,s1);
    p2=mix(p2i,p3i,s1);
    p3=mix(p3i,p1i,s1);
    p1=mix(p1,p3i,s2);
    p2=mix(p2,p1i,s2);
    p3=mix(p3,p2i,s2);

    //if(dot(cross(p2-p1,p3-p1),p1)>0.0) { vec3 dummy; dummy=p2; p2=p3; p3=dummy; }
    
    vec3 pos1, pos2, tan1, tan2;
    float R0 = .25;
    
    float sc=exp2(floor(log2(length(p2-p1)/.7)+.5))*.6;
    //sc=.5;
    
    vec2 uv;
    float dold;
    vec3 c;
    c=p1;
    pos1=normalize(mix(p1,p2,R0)); pos2=normalize(mix(p1,p3,R0));
    tan1=-normalize(cross(pos1,p2-p1)+pos1*.25); tan2=-normalize(cross(pos2,p3-p1)+pos2*.25); 
    dold=d;
	d=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,-1.,sc,uv));
	if(d<dold) uv_=uv;
    
    c=p1;
    pos1=normalize(mix(p1,p2,1.-R0)); pos2=normalize(mix(p1,p3,1.-R0)); 
    tan1=-normalize(cross(pos1,p2-p1)-pos1*.25); tan2=-normalize(cross(pos2,p3-p1)-pos2*.25); 
    dold=d;
	d=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,1.,sc,uv));
	if(d<dold) uv_=uv;
    
    c=.5*(p2+p3);
    pos1=normalize(mix(p3,p2,R0)); pos2=normalize(mix(p2,p3,R0)); 
    tan1=normalize(cross(pos1,p3-p2)+pos1*.25); tan2=normalize(cross(pos2,p2-p3)+pos2*.25); 
    dold=d;
	d=min(d,distTanCurveTor(pos,pos1,pos2,tan1,tan2,c,1.,sc,uv));
	if(d<dold) uv_=uv;
	
    // trying to avoid overshooting on triangle boundaries
    // by placing helper dist fields there with negative radius
    float r0=r*1.03+.003;
    #ifdef SHOW_GRID
    r0*=.6;
    #endif
	d=min(d,distCircleN(pos,cross(p1,p2),1.)+r0);
	d=min(d,distCircleN(pos,cross(p2,p3),1.)+r0);
	d=min(d,distCircleN(pos,cross(p3,p1),1.)+r0);
    
    return d;
}

// Function 3625
float dScene(vec2 p)
{
    float S = 15.; // scale
    p /= S;
    float
      dm = dMaze(p) // medial axis maze skeleton
    , dr = dm - .99 // thick round pills
    , dt = abs(dr + .2) - .2 // thin walled pipes
    , dh = max(abs(T(p.x)), abs(T(p.y)))-10. // big squares!
    , ds = max(-dh, dt) // just the pipes
    ;
    return ds*S; 
}

// Function 3626
float sceneDistance( vec3 point ) {
    float len = 0.77;
    
    float count = 4.;
    vec3 o = vec3( -1.4 * count * 0.5, 0., 0. );
    vec3 x = vec3( 7. / count, 0., 0. );
    
    float ufoA = 1.57 + 0.4 * cos( iTime * 2. );

    float star = starSDF( point, o + 0. * x, len, len * .35 );
    float cono = conoSDF( point, o + 1. * x, len, len * .5, iTime );
    float box  = boxSDF(  point, o + 2. * x, vec3( len * .5 ) );
    float ufo  = ufoSDF(  point, o + 3. * x, ufoA, len * .3 );

    return min( star, min( cono, min( box, ufo ) )  );
}

// Function 3627
float map(vec3 p)
{
    float radius = 0.75;
    
    // Transform coordinate space so spheres repeat
    vec3 q = fract(p) * 2.0 - 1.0;

    
    // Signed distance of sphere
    return sphere(q, radius);
}

// Function 3628
vec4 grayscaleMap(int minBrightness, int minValue, int maxValue, int value) {
    if (value < minValue || value > maxValue )
        //error
        return white;//white goes unnoticed
    int range = maxValue - minValue;
	float brightnessIncreasePerUnit;
	if (range > 0)
		brightnessIncreasePerUnit = float(255 - minBrightness)/float(range);
	else
		brightnessIncreasePerUnit = 0.;
    float brightness = (float(value - minValue)*brightnessIncreasePerUnit 
                        + float(minBrightness))/float(255);
	return vec4(brightness, brightness, brightness, 1);
}

// Function 3629
vec2 distCubeObject(in vec3 p)
{
	p.y -= MODULE_SIZE;
	return vec2(distBox(p,vec3(MODULE_SIZE,MODULE_SIZE,MODULE_SIZE)),3.0);
}

// Function 3630
float mapScene(in vec3 p) {
    // Surface control points:
    float v1 = 1.0 + sin(iTime);
    float v2 = 1.0 + sin(iTime + 1.57);
    float v3 = 1.0 + sin(iTime + 3.14);
    float v4 = 1.0 + sin(iTime + 4.71);

    float surface = Curve3D(p + vec3(0.0, 1.0, 0.0), vec2(4.0, 4.0), vec4(v1, v2, v3, v4)) - 0.05;
    return surface * 0.6;
}

// Function 3631
float PrCapsDf (vec3 p, vec2 b)
{
  return length (p - vec3 (0., 0., b.x * clamp (p.z / b.x, -1., 1.))) - b.y;
}

// Function 3632
void sceneRoad(vec2 uv, out vec3 params)
{
	uv.y -= .4;

	vec3 cam = vec3(0,1,0);
	vec3 dir = normalize(vec3(uv,1));
	float t = cam.y / -dir.y;
	vec3 hit = cam+dir*t;
	
	hit.x += sin(hit.z+iBeat)*.3;
	hit.x += sin(iBeat-1.9)*.3;
	hit.z *= 2.;
	hit.z += iBeat*2.;

	vec3 grass = vec3(1.-length(sin(hit.xz*2.))/sqrt(2.), 56,57);
	vec3 road = vec3(.5+normalize(sin(hit.z*PI))*.5, 58, 59);
	vec3 redwhite = vec3(.5+normalize(sin(hit.z*PI*2.))*.5, 31, 35);
	vec2 skyUv = uv*2.+vec2(1,0.37);
	float skyr = length(skyUv);
	vec3 sky = vec3(
		clamp(skyr*1.4-.1,0.,1.),
		60,
		62
	);
	if (skyr < .16)
		sky = vec3(0,63,63);


	if(uv.y > -.2)
		params = sky;
	else if(abs(hit.x)<.8)
		params = road;
	else if(abs(hit.x)<.9)
		params = redwhite;
	else
		params = grass;
}

// Function 3633
vec3 jodieReinhardTonemap(vec3 c){
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc=c/(c+1.);
    return mix(c/(l+1.),tc,tc);
}

// Function 3634
float vehicle_sdf(in vec3 loc) {
    float c = cone_sdf(loc);
    float p = -loc.y;
    float b = -loc.x + 0.2;
    float shell = s_max(c, b, 0.6);
    float back = s_max(cyl_sdf(loc), p, 0.1);
    shell = s_min(shell, back, 0.4);
    shell = s_max(shell,  p, 0.2);
    
    vec3 eye1 = vec3(0.7, 0.3, 0.3);
    vec3 eye2 = vec3(0.7, 0.3, -0.3);
    
    return shell 
        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy - vec2(0.42, 0.0)))
        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy + vec2(0.42, 0.0)))
        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye1))
        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye2))
        - 0.1 * smoothstep(0.2, -0.0, loc.y) * (1.0 + 0.2 * smoothstep(0.4, 0.6, abs(loc.z)));
}

// Function 3635
vec3 mapVertex(vec2 uv)
{
    vec3 v = vec3(uv.x, sampleHeightfield(uv), uv.y);
    v.x += cos(v.x / 2. + iTime) * .4;
    v.z += cos(v.z / 2. + iTime) * .4;
    v.xz += cos(v.z * 2. + iTime) * .4;
    v.x += cos(v.z / 3. + iTime) * .2;
    return v;
}

// Function 3636
de map( vec3 p, vec3 rd) {
    // returns a vec3 with x = distance, y = bump, z = mat transition w = mat id
    de o;
    o.d = 1000.;
    
    float t = iTime;
    
    if(FISH_ONLY) {
       p.x += 1.5;
       o = Fish(p, vec3(0.), 0.); 
    } else {
        rc q;
        vec3 n;
        
        if(FISH) {
            q = Repeat(vec3(p.x+t, p.y, p.z), vec3(11.5, 4.5, 2.5)); // make fishies move forward
            n = hash31(q.id.x+q.id.y*123.231+q.id.z*87.342);

            float camDist = length(p);
            if(n.x>.95) 
                o = Fish(q.p, n, camDist);
            else
                o.d = SkipCell(q, rd);
        }
        
        if(KELP) {										
            q = Repeat(vec3(p.x+sin(t+p.y*.2)*.5, p.y, p.z), vec3(2., 40., 2.)); // make kelp sway
            n = hash31(q.id.x+q.id.z*765.);

            de kelp;
            if(n.z*S(7., 10., length(q.id)) > .9)
                kelp = Kelp(q.p, n);
            else 
                kelp.d = SkipCell(q, rd);

            if(kelp.d<o.d) o=kelp;
        }
        
        if(BUBBLES) {										// Map kelp
            p.y -= t*4.;			// sway with the water
			
            p.y += 40.;
            q = Repeat(p, vec3(4., 4., 4.));
            n = hash31(q.id.x+q.id.y*1234.5234+q.id.z*765.);
			
            de bubbles;
            if(n.z*S(2., 5., length(q.id)) > .95)
                bubbles = SmallBubbles(q, p, n);
            else 
                bubbles.d = SkipCell(q, rd);

            if(bubbles.d<o.d) o=bubbles;
        }
        
    }
    
    return o;
    
}

// Function 3637
vec3 jodieReinhardTonemap(vec3 c){
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);

    return mix(c / (l + 1.0), tc, tc);
}

// Function 3638
vec3 scene(vec3 p0, vec3 r) {
  // Solve from closest point to origin.
  // This make p0.r = 0.
  float tmin = -dot(p0,r);
  p0 += tmin*r;
  Result res = Result(vec3(0),vec3(0),vec3(0),1e8);
  float ttime = 0.5*iTime;
  float rtime = floor(ttime);
  ttime -= rtime;
  vec4 params;
#if __VERSION__ < 300
    params = mix(goursatparams(imod(int(rtime),nparams)),
                 goursatparams(imod(int(rtime)+1,nparams)),
                 ttime);
#else
  int isurface = max(0,keycount(KEY_RIGHT)-keycount(KEY_LEFT));
  isurface %= nparams+1;
  if (isurface == 0) {
    params = mix(goursatparams(int(rtime)%nparams),
                 goursatparams(int(rtime+1.0)%nparams),
                 ttime);
  } else {
    params = goursatparams(isurface-1);
  }
#endif
  Surface surface = Surface(params,vec3(0),1);
  if (!solve(surface,p0,r,-tmin,res)) return vec3(0);
  return applylighting(res.basecolor,res.p,res.n,r);
}

// Function 3639
vec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {
    return textureLod(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   
 
}

// Function 3640
vec2 forward_mapping(vec2 Z,int p, int q, int Fover2){
    //int seed = 0;        // Optionaly keep seed constant for that static randomness look
	int seed = Fover2;
    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry
    int x=int(Z.x);
    int y=int(Z.y);
    
    //Change iterations here to zero to use the identity function as a mapping
    //Some particles seem to have a better chance of getting drawn...
    //But it shows off the artifacts in all their glory, looks pretty cool after a reset
    for(int i = 0; i < mapping_iters; i++){
        x = Zmod(x + IHash(y^seed)%p,p);
        y = Zmod(y + IHash(x^seed)%q,q);
    }
    
	//This is the inverse mapping, only difference is - instead of + and the order of x and y
    //uncommenting should have the same effect as reducing iterations above to zero
    //This is a pretty good test of the one to one property of the mapping
    //Originally it seemed to not be working quite right on some platforms so
    //this can confirm if that is happening. The effect of a non injective mapping is collisions
    //And thus many particles getting lost near the final pass.
    /*
    for(int i = 0; i < 5; i++){
        y = Zmod(y - IHash(x)%q,q);
        x = Zmod(x - IHash(y)%p,p);
    }
	*/
    
    return vec2(x,y)+fract(Z);
    
}

// Function 3641
float GetDist(vec3 op) {
	vec4 s = vec4(0, 1, 0, 1);
    
    float d = MAX_DIST;
    { // Spheres
        vec3 p = mod(op + PORTAL_TRANSLATE, PORTAL_TRANSLATE * 2.) - PORTAL_TRANSLATE;
        d = min(d, sdSphere(p + vec3(0, -1, -2.1 + sin(iTime)), 1.));
    }
    { // Cubes
        vec3 p = mod(op, PORTAL_TRANSLATE * 2.) - PORTAL_TRANSLATE;
        d = min(d, sdBox(p + vec3(0, -1, -2.1 + cos(iTime)), vec3(1.)));
    }
    { // Frame
        vec3 p = mod(op + PORTAL_TRANSLATE*.5, PORTAL_TRANSLATE) - PORTAL_TRANSLATE*.5;
        p.x = -abs(p.x);
        d = min(d, sdBox(p + vec3(PORTAL_WIDTH, 0, 0), vec3(.1, 3, .1)));
        d = min(d, sdBox(p + vec3(0, -3, 0), vec3(PORTAL_WIDTH+.1, .1, .1)));
    }

    d = min(d, op.y);
    return d;
}

// Function 3642
float map(vec3 q){
    
    vec3 p;
	// Scale factor, and distance.
    float s = 3., d = 0.;
    
    for(int i=0; i<3; i++){
 		// Repeat space.
        p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);
		// Repeat Void Cubes. Cubes with a cross taken out.
 		d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);
    	s /= 3.; // Divide space (each dimension) by 3.
    }
 
 	return d;    
}

// Function 3643
vec3 bumpMap2(in vec3 p, in vec3 n, float bumpfactor){
    
    const vec2 e = vec2(0.002, 0);
    float ref = bumpFunc2(p, n);                 
    vec3 grad = (vec3(bumpFunc2(p - e.xyy, n),
                      bumpFunc2(p - e.yxy, n),
                      bumpFunc2(p - e.yyx, n) )-ref)/e.x;                     
          
    grad -= n*dot(n, grad);          
                      
    return normalize( n + grad*bumpfactor );
	
}

// Function 3644
vec3 GetMipMapUVW_Dir(vec3 _uvw,vec3 _axis){
    _uvw = floor((_uvw+1.)*512.)+0.5;
    vec3 a = exp2(floor(log2(_uvw)));
    return normalize((_uvw*2./a - 3.)*(1.-abs(_axis))+_axis);
}

// Function 3645
vec3 simpleReinhardToneMapping(vec3 color)
{
	float exposure = 1.5; // 1.5
	color *= exposure/(1. + color / exposure);
    //return vec3(exposure/(1. + color / exposure));
	color = pow(color, vec3(1. / 1.2)); // gamma = 2.2
	return clamp(color, 0.0, 1.0);
}

// Function 3646
vec2 map( vec3 p ){
    vec2 res = vec2(model(p), 1.);
    return res;
}

// Function 3647
float sdf(in vec3 p) {
    //return mapTest(p);
    return mapShell(p);
}

// Function 3648
float DistanceFieldNoLights( vec3 pos )
{
	return min( min(
			Foliage( pos ),
			Water( pos ) ),
			Solid( pos )
		);
}

// Function 3649
vec3 map_box_norm(vec3 ro) { 
    vec3 d = ro - b1.c;
    //do a nice bevel
    return normalize(step(b1.s * .95, abs(d))*sign(d));
}

// Function 3650
vec3 tonemapping(vec3 color)
{
    //Tonemapping and color grading
    color = pow(color, vec3(1.5));
    color = color / (1.0 + color);
    color = pow(color, vec3(1.0 / 1.5));

    
    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));
    color = pow(color, vec3(1.3, 1.20, 1.0));    

	color = clamp(color * 1.01, 0.0, 1.0);
    
    color = pow(color, vec3(0.7 / 2.2));
    return clamp(color, 0.0, 1.0);
}

// Function 3651
vec4 mapN(vec3 p)
{
    return mapL(p) * noi(p);
}

// Function 3652
vec2 map( vec3 p ) {   
    // little gross...
    
    float x = .0;
    float l = .11;
    float f = .77;
    vec3 p0 = vec3( x ); x += l; l *= f;
    vec3 p1 = vec3( x ); x += l; l *= f;
    vec3 p2 = vec3( x ); x += l; l *= f;
    #ifndef DISARMING
    vec3 p3 = vec3( x ); x += l; l *= f;
    vec3 p4 = vec3( x ); x += l; l *= f;
    #endif
    
    vec2 value = vec2( 1e33, -1. );
    
    for ( int i = 0 ; i < ARM_COUNT ; i++ ) {
        #ifdef DISARMING
            vec2 j = map( p, iTime + float( i ), i, p0, p1, p2 );
        #else
            vec2 j = map( p, iTime + float( i ), i, p0, p1, p2, p3, p4 );
        #endif
        if( j.x < value.x ) value = j;

    }
    
    return value;
}

// Function 3653
float HoleSDF( vec3 pos )
{
    vec3 dhole = pos-holePos;
    dhole.y = min(dhole.y,0.); // sphere bottom with cylinder above
    return holeRad-length(dhole);
}

// Function 3654
vec3 sd_SceneGrad( vec3 p, int lod, TraceOutput to, Ray ray )
{
	// if p is far away the epsilon will vanish in the addition and normal calculation will be broken
	// this was to keep the gradient working even at large-ish distances...
//	vec3 h = max( vec3( 0.006 ), abs( p ) * 1e-6 );
	vec3 h = vec3( 0.001 );
	vec3 n = normalize( vec3( sd_Scene( p + vec3( h.x, 0.0, 0.0 ), lod, to.t, ray ),
							  sd_Scene( p + vec3( 0.0, h.y, 0.0 ), lod, to.t, ray ),
							  sd_Scene( p + vec3( 0.0, 0.0, h.z ), lod, to.t, ray ) ) - to.dist ); // to.dist == sd_Scene( p, lod, to.t, ray ), our last eval 
	// if the normal is backfacing, our point p is likely behind an occluded object (a thin object or an edge we accidentally traced through)
	// this creates distracting salt noise that makes certain lighting components unstable (fresnel)
	// if we care the simplest hack to do that attenuates the artifacts in our scene is to negate
	return dot( n, ray.d ) > 0.0 ? -n : n;
}

// Function 3655
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    vec3 lmn;
    int pageDst;
    lmnFromVCube(rayDir, pageDst, lmn);

    if (pageDst == 1) {
        doPage1(fragColor, lmn);
    } else if (pageDst == 2) {

        #ifdef VORTICITY_CONFINEMENT
        doPage2(fragColor, lmn);
        #else
        discard;
        #endif

    } else if (pageDst == 3) {
        discard;
    }
}

// Function 3656
float sphereSDF(vec3 p, vec3 center, float radius) {
    return length(p - center) - radius;
    // <=>
    //return (length((p - center)/radius) - 1.0)*radius;
}

// Function 3657
vec4 getColDist(vec2 pos)
{
	//return smoothstep(0.5,1.5,getCol(pos,0.)+getRand(pos).xxxx);
	return 1.-smoothstep(0.5,1.5,(1.-getCol(pos,0.))+pow(getRandBlue(pos),vec4(.75))*.75);
	//return smoothstep(0.5,1.5,getCol(pos,0.)+mix(getPatt(pos),getRandBlue(pos),.75));
}

// Function 3658
float MapClouds(in vec3 p)
	{
		p *= 0.001;
		return FBM(p);
	}

// Function 3659
float mapThing( vec3 p)
{
    mat3 rotX = mat3(
        1.0, 0.0, 0.0,
        0.0, cos(map_thing_t), -sin(map_thing_t),
        0.0, sin(map_thing_t), cos(map_thing_t));
    p = p*rotX;
    float T = -voronoi3D(p+vec3(0.0, iTime, 0.0));
    return T+sdCone(p, vec2(1.0, 0.1));
}

// Function 3660
vec4 sdf(vec3 position) {
    float material = 0.0;
    float d = plane(position, vec3(0.0, 1.0, 0.0), 0.0);
    float d1 = box(position - vec3(-4.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5));
    if (d1 < d) {
        material = 1.0;
        d = d1;
    }
    float d2 = cylinder(position - vec3(-2.0, 0.5, 0.0), 0.5, 0.5);
    if (d2 < d) {
        material = 2.0;
        d = d2;
    }
    float d3 = capsule(position - vec3(0.0, 0.6, 0.0), 0.3, 0.6);
    if (d3 < d) {
        material = 3.0;
        d = d3;
    }
    float d4 = sphere(position - vec3(2.0, 0.5,  0.0), 0.5);
    if (d4 < d) {
        material = 4.0;
        d = d4;
    }
    float d5 = ellipsoid(position - vec3(4.0, 0.5, 0.0), vec3(0.75, 0.5, 0.5));
    if (d5 < d) {
        material = 5.0;
        d = d5;
    }
    return vec4(d, material, 0.0, 0.0);
}

// Function 3661
float caveDistance(vec3 p, inout int material){
    
    float distance = 9999.9;
    material = 0;
    
    
    
    
    
    
    
    const float wallLumpDist = 4.0;
    const float lumpsBeforeMod = 4.0;
    
    vec3 wallP = p;
    wallP.x = abs(p.x);
    for(float i=0.0; i<lumpsBeforeMod; i++){
        
        float subOff = (i/lumpsBeforeMod)*wallLumpDist;
        float wallStep = (floor((p.z+subOff)/wallLumpDist)-(i/lumpsBeforeMod))*wallLumpDist + ((p.x<0.0)?60.0:0.0);
        wallP.z = mod(p.z+subOff,wallLumpDist);
        
        float wallDist = 6.0;
        wallDist += sin(wallStep*10.0)*0.1;
        wallDist += sin(wallStep*17.0)*0.1;
        wallDist += sin(wallStep*0.5)*1.0;
        wallDist += sin(wallStep*0.87)*0.25;
        if (p.y > 5.0) wallDist += 6.0;//safe because we're looking up
        
        float curD = obj_cylinder(wallP.yxz,vec3(0.0,wallDist,wallLumpDist*0.5),vec2(0.6,12.0),0.0);
        
        if (i==0.0) {
            hardAdd(material,distance,2,curD);
        } else {
            smoothAdd(distance,curD,0.3);
        }
    }
    
    
    
    hardAdd(material,distance,1,
		p.y-0.0
    );
    
    smoothAdd(distance,
		obj_repeatPebble(p,vec2(0.65,2.01),0.05)
	,0.05);
    smoothAdd(distance,
		obj_repeatPebble(p,vec2(0.47,1.51),0.04)
	,0.04);
    smoothAdd(distance,
		obj_repeatPebble(p,vec2(0.81,1.01),0.03)
	,0.03);
    
    
    
    
    
    vec3 ufoPos = vec3(ufoX,1.1,ufoZ);
    obj_ufo(p,ufoPos,0.0,material,distance);
    
    
    
    return distance;
    
}

// Function 3662
float sdfSmoothSubtraction( float d1, float d2, float k ) {
    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
    return mix( d2, -d1, h ) + k*h*(1.0-h); 
}

// Function 3663
Hit Scene(vec3 p)
{
    float dp = p.y // ground plane +Y
    , r = .5 // ball radius
    , tr = .5 // torus radius
    , tz = 1.5 // torus size
    , db = dsphere(p - vec3(0,r,0), r) // non-moving ball above origin
    , dx = dbox(p - vec3(0,.7,-7.5), vec3(6,.3,.3)) // large box for testing collision
    , dr = dtubey(p - vec3(0,-.0125,0), vec4(64,.0,.625,.125)) // large low cylindrical tube around origin
    , dc = 3.4e38 // other stuff
    ;
    dx = min(dx, dr);
    db = min(db, 
       dsphere(p - prot(vec3(0,r,2.*r), vec3(0,1,0), .5*time), r)); // ball above origin    
    dc = min(dc, dtubey((p - vec3(10,tz+tr,0)).yzx, vec4(tz,0,0,0)) - tr); // big torus to stress shadows
	dc = min(dc, dtubey((p - vec3(-10,tz + .1,0)).zxy, vec4(tz,tz,.1,0)) - 0.);
    Hit h; // = Hit(3.4e38, mSky);
    h = Hit(dp, mGray);
    if (h.d > db) h = Hit(db, mRed);
    if (h.d > dx) h = Hit(dx, mGreen);
    if (h.d > dc) h = Hit(dc, mBlue);
    return h;
}

// Function 3664
float fogmap(in vec3 p, in float d)
{
    p.xz -= time*7.+sin(p.z*.3)*3.;
    p.y -= time*.5;
    return (max(Noise3d(p*.008+.1)-.1,0.0)*Noise3d(p*.1))*.3;
}

// Function 3665
float dist1(in vec3 p, in vec3 cen, float r){
    float a=0.4;
    vec2 di = vec2(a, 0);
    vec2 sn = vec2(1, -1);
    vec3 cen1 = (cen + di.xxy) * sn.yxy;
    vec3 cen2 = (cen + di.yxx) * sn.yyx;
    vec3 cen3 = (cen + di.xyx) * sn.xyy;
	float d = griddist(p-cen, vec3(2.*a), r);
	d = min(d, griddist(p-cen1, vec3(2.*a), r));
	d = min(d, griddist(p-cen2, vec3(2.*a), r));
	d = min(d, griddist(p-cen3, vec3(2.*a), r));
    
	return d;
}

// Function 3666
bool hitScene(Ray ray, float tMin, float tMax,
              out vec3 position, out vec3 normal, out Material material)
{
    float closestSoFar = tMax;
    bool hitAnything = false;
    
    for (int i = 0; i < NUM_SPHERES; i++) {
     	Sphere sphere = scene[i];
        
        vec3 oc = ray.origin - sphere.center;
        float a = dot(ray.direction, ray.direction);
        float b = dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius * sphere.radius;
        float discriminant = b * b - a * c;
        
        if (discriminant > 0.0001) {
			float t = (-b - sqrt(discriminant)) / a;
            if (t < tMin) {
                t = (-b + sqrt(discriminant)) / a;
            }
            
            if (t > tMin && t < closestSoFar) {
                closestSoFar = t;
                hitAnything = true;
                
                vec3 p = rayPointAt(ray, t);
                position = p;
                normal = (p - sphere.center) / sphere.radius;
                material = sphere.material;
            }
        }
    }
    
 	return hitAnything;
}

// Function 3667
float MicrofacetDistribution(float NdotH, float roughness4) {
    float f = (NdotH * roughness4 - NdotH) * NdotH + 1.0;
    return roughness4 / (PI * f * f);
}

// Function 3668
vec4 map(vec2 uv) {
    vec2 p = uv * iResolution.xy;
#ifndef DISABLE_MINIGAME
    if (iTime > STORY_END_TIME) {
        if (keypress(KeyC)) return map_temp(p);
        if (keypress(KeyF)) return map_flow(p);
        if (keypress(KeyL)) return map_life(p);
        if (keypress(KeyR)) return map_rivers(p);
        if (keypress(KeyT)) return map_plates(p);
    }
#endif
    vec4 fragColor = map_sat(p);
    if (iTime < SLOWING_START_TIME - 10.) {
        float s = LAND_END_TIME + 5.;
        float t = iTime + uv.x;
        fragColor = mix(fragColor, map_plates(p), smoothstep(s - 1., s + 1., t)); s += 8.;
        fragColor = mix(fragColor, map_rivers(p), smoothstep(s - 1., s + 1., t)); s += 8.;
        fragColor = mix(fragColor, map_temp(p),   smoothstep(s - 1., s + 1., t)); s += 16.;
        fragColor = mix(fragColor, map_flow(p),   smoothstep(s - 1., s + 1., t)); s += 16.;
        fragColor = mix(fragColor, map_life(p),   smoothstep(s - 1., s + 1., t)); s += 18.;
        fragColor = mix(fragColor, map_sat(p),    smoothstep(s - 1., s + 1., t));
    }
    return fragColor;
}

// Function 3669
float SDF( vec3 pos )
{
    // multi fractal
    const float period = 1.6;
    float tt = fract(iTime/period /*+ texture(iChannel0,pos/20.).x /*break up the pattern - screws up texture filtering and I'm too lazy to fix/hide it*/);
    float t[2] = float[2]( tt*period, (tt-1.)*period );
    vec3 uvw = pos/30.;
    float f[2] = float[2]( .0, .0 );
    
    for ( int i=0; i < 2; i++ )
    {
	    vec3 offset = Flow(pos)*t[i];
        vec3 u = uvw
//            +offset*.25; offset *= .0; // makes the loop more obvious but looks generally good
            +offset*.2; offset *= .2; // makes the loop more obvious but looks generally good
        f[i] += texture(iChannel0,offset+u*2.).x/2.;
        f[i] += texture(iChannel0,offset+u*4.).x/4.;
        f[i] += texture(iChannel0,offset+u*8.).x/8.;
        f[i] += texture(iChannel0,offset+u*16.).x/16.;
        f[i] += texture(iChannel0,offset+u*32.).x/32.;
    }
    
    float ff = mix( f[0], f[1], tt );// actually better with a longer fade imo smoothstep(.4,.6,tt) );
    //this doesn't help: const float p = 1.; float ff = pow( mix( pow(f[0],p), pow(f[1],p), tt ), 1./p );

/*this looks far worse
	f[0] *= smoothstep(1.,.5,tt);
    f[1] *= smoothstep(0.,.5,tt);
    const float p = 20.; float ff = pow( pow(f[0],p) + pow(f[1],p), 1./p );*/
//    float ff = max(f[0],f[1]);

    ff *= .5; // strength of clouds vs bounding shapes

//    float g = length(vec3(pos.yz,max(0.,abs(pos.x)-.5)))-1.2;
//    float g = length(pos.xz)-.7+.5*sin(pos.y-iTime);
//    g = min(g,length(pos-vec3(0,-2,0))-1.2);
//    float g = length(vec2(pos.y,length(pos.xz)-(.5+.5*sin(iTime*.31))*2.)) - 1.; // smoke ring!
//    float g = max(max(abs(pos.x),abs(pos.y)),abs(pos.z)) - 1.; // cube - even hard corners look soft!
    float g = length(vec2(pos.y,length(pos.xz)-.8))-1.;
    
    ff += g*.6;
    
    return ff;
}

// Function 3670
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    int idx = dir2face(rayDir);    
    
    vec3 col = vec3(0);
    
    switch (idx) {
        case FACE_X_POS: col = vec3(1.0,0.0,0.0); break;
        case FACE_X_NEG: col = vec3(0.5,0.0,0.0); break;
        case FACE_Y_POS: col = vec3(0.0,1.0,0.0); break;
        case FACE_Y_NEG: col = vec3(0.0,0.5,0.0); break;
        case FACE_Z_POS: col = vec3(0.0,0.0,1.0); break;
        case FACE_Z_NEG: col = vec3(0.0,0.0,0.5); break;
    }
    
    fragColor = vec4(col, 1);
}

// Function 3671
float scene(
    in vec2 P,
    float T,
    sceneParameters desc)
{
    // Translate and scale center for better view.
    P += desc.offset;

    float t = LMB_IS_HOLD == false ? 
        T :                       // Fixed initialization.
        (MX * 6.0 - 3.0) * 0.5;   // Interactive initialization.
    
    /* Initialize first sample coordinates and 
       minimal distance from test fragment to samples. */
    float x = T, y = T;
    float minDistance = 999999999.9f;

    // Iteratively evaluate dynamic system.
    for (int idx = 0; idx < desc.count; ++idx)
    {
        float xx = x*x, xy = x*y, yy = y*y;
        float yt = y*t, tt = t*t, tx = t*x;
        
        float nextX = 
            desc.xx0 * xx + desc.xy0 * xy + desc.yy0 * yy + 
            desc.yt0 * yt + desc.tt0 * tt + desc.tx0 * tx +
            desc.x0 * x   + desc.y0 * y   + desc.t0 * t;
    
        float nextY = 
            desc.xx1 * xx + desc.xy1 * xy + desc.yy1 * yy + 
            desc.yt1 * yt + desc.tt1 * tt + desc.tx1 * tx +
            desc.x1 * x   + desc.y1  * y  + desc.t1 * t;
            
        // Save new coordinates for next iteration.
        x = nextX;
        y = nextY;
        
        // Find closest sample.
        minDistance = min(circleSDFSD(P, vec2(x, y), desc.radius, desc.smoothness), minDistance);       
        //minDistance = min(circleSDF(P, vec2(x, y), desc.radius, desc.smoothness), minDistance); 
    }    

    return minDistance;
}

// Function 3672
float mapBubbles(vec3 p, vec3 tranformedP, float time) {
    float morphK;
    if (time > split1Time && time < split1TimeEnd) {
        morphK = (time - split1Time) / split1Duration;
    } else if (time >= split1TimeEnd && time < merge1Time) {
        morphK = 1.0;
    } else if (time >= merge1Time && time < merge1TimeEnd) {
        morphK = (merge1TimeEnd - time) / merge1Duration;
    } else if (time >= lift1Time && time < lift1TimeEnd) {
        float frameStart = getLift1FrameStart(time);
        float frameLen = lift1FrameLen;
        morphK = 1. - min(sqr((p.y - (frameStart+frameLen)) / frameLen), 1.);
    } else {
        morphK = 0.0;
    }

    float cellSize = 0.2;
    float bubbleRad = cellSize * 0.3;
    vec3 cellPosBase = floor(p/cellSize);  //realative to cellSize

    //    take into account the nearest cell and 8 neighbour cells
    float totalDist = 1000.;
    // for large bubbles radius +-1 is not enough, but it is no more performance
    for (int x=-1; x<=1; x++)  for (int y=-1; y<=1; y++)  for (int z=-1; z<=1; z++)  {
        vec3 cellPos = cellPosBase + vec3(x,y,z);
        vec3 cellNoise = rand3D(cellPos);
        vec3 bubblePos = (cellPos + cellNoise) * cellSize;
        float rad = bubbleRad * rand(cellPos);
        //    decrease bubbles size on border
        float l = length(spherePos - bubblePos);
        if (rad > sphereRad - l)  rad = mix(rad, sphereRad - l, morphK);
        if (rad < 0.)  continue;

        float dist = length(tranformedP - transform(bubblePos, time)) - rad;
        //dist = min(dist, sphereDist);
        //    merge neighbour bubbles
        float k = mix(cellSize*1.5, cellSize*0.5, morphK);
        float h = clamp(0.5 + 0.5*(totalDist-dist)/k, 0.0, 1.0);
        totalDist = mix(totalDist, dist, h) - k*h*(1.0-h);
    }

    return totalDist;
}

// Function 3673
vec3 sceneColour( vec3 pos, float z )
{
	float d1 = sdSph(pos,sph1), d2 = sdSph(pos,sph2), d3 = sdSph(pos,sph3);
	
	vec3 tint;
	if( d1 < d2 )
	{
		if( d1 < d3 )
			tint = vec3(0.15,0.6,0.2);
		else
			tint = vec3(.9);
	}
	else
	{
		if( d2 < d3 )
			tint = vec3(0.,.3,1.);
		else
			tint = vec3(.9);
	}
	
	return tint * volTex(pos,z);
}

// Function 3674
float sdf(vec3 p)
{
	vec3 wsPos = vec3(.0,.0,.0);
	vec4 a0 = vec4(p, 1.0);
	a0.xz = abs(a0.xz) * vec2(-1.0,1.0);
	vec4 a1 = a0 - vec4(6.24,.0,2.5,.0);
	a1.xz = pModPolar(a1.xz , 4.0);
	float d1 = dot(a1.xyz - vec3(11.49,.0,.0), vec3(-1.0,.0,.0));
	vec4 a2 = a1 - vec4(11.02,2.15,7.28,.0);
	a2.z = domainRepeat1D(a2.z , 2.0);
	vec4 a3 = a2;
	wsPos = a3.xyz - vec3(-2.64,5.05,.0);
	float d3 = fBox(wsPos,vec3(.5,.5,.228));
	wsPos = a3.xyz - vec3(-2.275,5.05,.0);
	d3 = min(d3,fBox(wsPos,vec3(.383,.383,.175)));
	wsPos = a3.xyz - vec3(-2.64,6.97,.0);
	d3 = min(d3,fBox(wsPos,vec3(.5,.283,.111)));
	wsPos = a2.xyz - vec3(-1.28,6.38,.287);
	float d2 = max(-d3,fBox(wsPos,vec3(1.5,1.893,6.673)));
	d1 = min(d1,d2);
	vec4 a4 = a1 - vec4(9.18,-4.5,-.032,.0);
	a4.y = domainRepeat1D(a4.y , 4.5);
	vec4 a5 = a4;
	a5.z = domainRepeat1D(a5.z , 2.5);
	vec4 a6 = a5;
	a6.x = -a6.x;
	vec4 a7 = a6;
	vec4 a8 = a7 - vec4(.05,-.62,.0,.0);
	a8.xyz = rdZ(a8.xyz);
	wsPos = a8.xyz;
	float d8 = (fCylinder(wsPos, 1.398,1.361)*.75);
	wsPos = a8.xyz - vec3(.0,.152,.0);
	d8 = max(-d8,(fCylinder(wsPos, 1.434,.531)*.75));
	wsPos = a7.xyz - vec3(.786,.46,.0);
	float d7 = max(d8,fBox(wsPos,vec3(.523,.747,1.415)));
	vec4 a9 = a6;
	wsPos = a9.xyz - vec3(.47,1.953,.0);
	float d9 = fBox(wsPos,vec3(.5,.075,1.5));
	wsPos = a9.xyz - vec3(.58,2.03,.0);
	d9 = min(d9,fBox(wsPos,vec3(.5,.075,1.5)));
	vec4 a10 = a9 - vec4(.463,-.51,1.179,.0);
	a10.z = domainRepeat1D(a10.z , 2.35);
	wsPos = a10.xyz;
	float d10 = fBox(wsPos,vec3(.24,.033,.24));
	wsPos = a10.xyz - vec3(.0,-.093,.0);
	d10 = min(d10,fBox(wsPos,vec3(.24,.033,.24)));
	wsPos = a10.xyz - vec3(-2.8,-.03,.0);
	d10 = min(d10,fBox(wsPos,vec3(.25,.075,.25)));
	vec4 a11 = a10;
	a11.xz = pModPolar(a11.xz , 8.0);
	wsPos = a11.xyz - vec3(.002,-1.07,.0);
	float d11 = fBox(wsPos,vec3(.17,1.053,.424));
	d10 = min(d10,d11);
	d9 = min(d9,d10);
	vec4 a12 = a9 - vec4(-1.03,-.518,.0,.0);
	vec4 a13 = a12;
	a13.xyz = rdZ(a13.xyz);
	wsPos = (tr[0] * a13).xyz;
	float d13 = fCylinder(wsPos, 1.225,3.0);
	wsPos = a13.xyz;
	d13 = min(d13,fCylinder(wsPos, 1.094,2.061));
	wsPos = a12.xyz - vec3(.12,1.27,.0);
	float d12 = max(-d13,fBox(wsPos,vec3(1.5,1.355,1.551)));
	d9 = min(d9,d12);
	float d6 = min(d7,d9);
	vec4 a14 = a6 - vec4(.463,1.57,1.61,.0);
	wsPos = (tr[1] * a14).xyz;
	float d14 = fCylinder(wsPos, .105,.046);
	wsPos = (tr[2] * a14).xyz;
	d14 = min(d14,fCylinder(wsPos, .025,.582));
	d6 = min(d6,d14);
	float d5 = d6;
	float d4 = d5;
	d1 = min(d1,d4);
	float d0 = min(d1,dot(a0.xyz - vec3(.0,-2.0,.0), vec3(.0,1.0,.0)));
	d0 = min(d0, length(p - vec3(0.0, .35, .0)) - 1.5);
    d0 = min(d0, -(p.y - 11.15));
    return d0;
}

// Function 3675
bool intersectScene(Ray ray, out HitInfo hitInfo) {
    hitInfo.t = 1e10;

    int hitSphere = -1;
    for (int k = 0; k < NUM_SPHERES; k++) {
        HitInfo hitInfoTemp;
        if (intersectSphere(spheres[k], ray, hitInfoTemp)) {
            if (hitInfoTemp.t < hitInfo.t) {
                hitSphere = k;
                hitInfo = hitInfoTemp;
                hitInfo.materialIndex = spheres[hitSphere].materialIndex;
            }
        }
    }
    int hitPlane = -1;
    for (int k = 0; k < NUM_PLANES; k++) {
        HitInfo hitInfoTemp;
        if (intersectPlane(planes[k], ray, hitInfoTemp)) {
            if (hitInfoTemp.t < hitInfo.t) {
                hitPlane = k;
                hitInfo = hitInfoTemp;
                hitInfo.materialIndex = planes[hitPlane].materialIndex;
            }
        }
    }
    
    return hitSphere > -1 || hitPlane > -1;
}

// Function 3676
SurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )
{
    SurfaceInfo surfaceInfo;
    
    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);
    
    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); 
    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;
    surfaceInfo.vAlbedo = vec3(1.0);
    surfaceInfo.vR0 = vec3( 0.02 );
    surfaceInfo.fSmoothness = 1.0;
    surfaceInfo.vEmissive = vec3( 0.0 );
    //return surfaceInfo;
        
    if ( traceResult.iObjectId == MAT_DEFAULT )
    {
    	surfaceInfo.vR0 = vec3( 0.02 );
	    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 2.0, 0.0 ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
                        
    	surfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);
        
    }
    
    if ( traceResult.iObjectId == MAT_SCREEN )
    {
        surfaceInfo.vAlbedo = vec3(0.02); 
        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        
    }

    if ( traceResult.iObjectId == MAT_TV_CASING )
    {
        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); 
	    surfaceInfo.fSmoothness = 0.4;        
    }
    
    if ( traceResult.iObjectId == MAT_TV_TRIM )
    {
        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); 
	    surfaceInfo.fSmoothness = 0.5;
    }    

    if ( traceResult.iObjectId == MAT_CHROME )
    {
        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); 
	    surfaceInfo.fSmoothness = 0.9;
    	surfaceInfo.vR0 = vec3( 0.8 );
    }    
 
    return surfaceInfo;
}

// Function 3677
float dist(vec3 pos)
{
    //pos+=.00015*getRand(pos*1.3).xyz*4.;
    //pos+=.00006*getRand(pos*3.).xyz*4.;
    //pos+=.00040*getRand(pos*.5).xyz*4.;
    vec3 p1,p2,p3;
    float d = 10000.;
    vec2 uv;
    
    // sphere in the middle
	//d=min(d,distSphere(pos,.79));
    
    // start with an icosahedron subdivided once
    getIcosaTri(pos, p1, p2, p3);
    #ifdef SUBDIV1
    getTriSubDiv(pos, p1, p2, p3);
    #endif
    float dold=d;
    d=min(d,distTruchet(pos, p1,p2,p3,.008, uv)-.008);
    if(d<dold) g_uv=uv;
    
    #ifdef SUBDIV2
    float sc = 1.;
    // subdivide again for another detail
    getTriSubDiv(pos,p1,p2,p3);
	sc = 1./.93;
	dold=d;
    d=min(d,distTruchet(pos*sc, p1,p2,p3,.003*sc, uv)/sc-.003);
    if(d<dold) g_uv=uv;
    #endif
    
    // subdivide again for another detail
	//getTriSubDiv(pos,p1,p2,p3);
    //sc = 1./.93;
    //d=min(d,distTruchet(pos*sc, p1,p2,p3,.02)/sc-.007);
    
    return d;
}

// Function 3678
float finalLogoScene(vec3 p, float t) {
	float thickness = 0.1;
	p.y = -p.y;
	float shell = max(sdBox2p(p, vec3(0.0), vec3(3.0)), -sdBox2p(p, vec3(thickness), vec3(8.0)));
	shell = max(shell, -sdBox2p(p, vec3(-8.0), vec3(2.0)));
	shell = max(shell, -sdBox2p(p, vec3(1.0, -1.0, thickness), vec3(4.0, 5.0, 1.0)));
	shell = min(shell, sdBox2p(p, vec3(0.0), vec3(3.0, 1.0, thickness)));
	shell = min(shell, sdBox2p(p, vec3(0.0), vec3(1.4)));
	return shell;
}

// Function 3679
vec3 cmap(float W) {
    vec3 C = vec3 (W);
    if (W < .3) C.y=.0; 
    else W < .6 ? C.z=.0 : C.x=.0;
    return C;
  }

// Function 3680
vec3 mapP( vec3 p )
{
    p.xyz += .1*sin(  (8.- lightDispersing* 3.)*p.zxy )*grow.x;
    p.xyz += 0.20*sin((10.0- lightDispersing* 5.)*p.yzx)*grow.y ;
    p.xyz += 0.2*sin(  12.0*p.yzx )*grow.z;
    p.xyz += 0.10*sin( 23.0*p.yzx)*grow.w;
    return p;
}

// Function 3681
vec3 SimpleToneMapping(vec3 col){
	return 1.0/(1.0+col);
}

// Function 3682
float sceneSDF(vec3 samplePoint) {
    return sphereSDF(samplePoint);
}

// Function 3683
float boxDist(vec2 p, vec4 b) {
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
}

// Function 3684
vec3 mapP( vec3 p )
{
    p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;
    p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;
    p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;
    p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;
    return p;
}

// Function 3685
float	scene(vec3 p)
{
    minf = 1e5;
    mind = 1e5;
    ming = 1e5;
    vec3    op = p;
    vec2	thunder;

    mind = min(mind, length(p-L2-ying)-.1);
    mind = min(mind, length(p-L2-yang)-.1);
	
    minf = dist_func(p.xyz)-1.5;
    mind = min(mind, minf);

    spaghetti = de_0(p.xzy);

    if (minf < 58.) // create artifacts around abs(p.y) == 0.
    {
       	mine = min(mine, length(p)-.1);
    	mine = min(mine, length(p.xz)-.55-exp(.7-.25*( (abs(p.y) )))*.75 );
    	mine = max(mine, -(length(p.xyz)-2.6) );
    	mine = max(mine, (length(p)-6.) );
    	mine = min(mine, sdTorus(p.zyx, vec2(7., 1.1) ) );
        thunder = 
        1.*vec2(
        .5*sin(2.*iTime*8.+p.x*1.-sin(2.*iTime*4.+p.x*2.-sin(p.x*3.-2.*iTime*1.)*.25 )*1.5)
        ,
        .5*cos(iTime*8.+p.x*1.-cos(iTime*4.+p.x*2.-cos(p.x*3.-iTime*1.)*.25 )*1.5) );
        vec2	pop = floor( 1.0*iTime+ p.xy*(mine*mine+1.*sin(+length(p.xy*.5)-.5) )-vec2(.35,.65) );
		float	runaz = Rune(fract( 1.0*iTime+ p.xy*(mine*mine+1.*sin(+length(p.xy*.5)-.5) )-vec2(.35,.65) ), pop).x;
    	rotate(op.yx, 1.57);
        ming = length(op.xz-thunder.yx*.25)+0.001;
        ming = max(ming, -(length(op.zx)-exp(-15.+abs(1.-2.*p.x))+sin(iTime*2.+ct*2.+0.00+(p.x)*.125 ) ) );
        rotate(op.yx, .57);
        ming = min(ming, length(op.xz-thunder.yx*.25)+0.001 );
        ming = max(ming, -(length(op.zx)-exp(-12.+abs(1.-2.*p.x))+sin(iTime*2.+st*2.+1.04+(p.x)*.125 ) ) );
		rotate(op.yx, -2.*.57);
        ming = min(ming, length(op.xz-thunder.yx*.25)+0.001 );
        ming = max(ming, -(length(op.zx)-exp(-12.+abs(1.-2.*p.x))+sin(iTime*2.+ct*2.+2.08+(p.x)*.125 ) ) );
        h2 += ( (sin(t+first*3.14)))*(vec3(.2, .6, .3)*.051/(ming*ming+.001));
	    mind = min(mind, ming);
        //h2 += step(.02, runaz)*-5.*abs(vec3(sin( +(pop.x+pop.y)*4. + 1.04), cos( +(pop.x+pop.y)*4. + 2.08), sin( +(pop.x+pop.y)*4. + 0.00) ) )*vec3(.1,.15,.2)*.1/ max(mine*mine+.2,.6-runaz*runaz);
        mind = min(mind, mine);
    }
    mind = min(mind, spaghetti);
    return mind;
}

// Function 3686
vec3 envMap(vec3 rd, vec3 n){
    
    vec3 col = tex3D(iChannel1, rd/4., n).zyx;
    return smoothstep(.1, 1., col*2.);
}

// Function 3687
float getUnitDistance(float idx, vec3 p)
	{
		vec3 	bumps1 		= sin(idx*vec3(2.542, 1.564, 3.342))+1.0,
				bumps2		= sin(idx*vec3(-1.432, 8.788, 9.453))+1.0,
				translation	= sin(idx*vec3(0.345, 8.342, 3.324))/1.5;
        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1); // avoid 0.0, avoid the spheres...
        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);
		
		p += sin(idx*vec3(0.234, 0.736, 0.213))*3.0;
        
		float	s1 	= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,
				s2	= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;
		return  smin(s1, s2);
    }

// Function 3688
vec2 map(vec3 p){return map(p,vec3(0));}

// Function 3689
vec3 heatmap(float h){
	return mix(vec3(0.1,0.2,0.4),vec3(2.0,1.5-h,0.5)/(1.0+h),h);
}

// Function 3690
float distLeaf(vec3 pos, float angle, float size, out float color){
    float radius = size;
    float c = 0.95 * radius;
    pos.xy = rot(angle) * pos.xy;

    //main part
    pos.y -= 0.02;
    pos.x -= 0.25 * radius;
    pos.z = smoothabs(pos.z, 0.0075);
	pos.y = -abs(pos.y);
    float dist = length(pos - vec3(0., c, -0.05)) - radius;
    
    //color
    float r = length(pos.xz) / radius;
    color = 0.5 + 0.5 * cos(12. * r);
    
    //tip
    pos.x -= 0.175 * radius;
    pos.z += 0.45 * c;
   	return smoothmin2(dist, length(pos - vec3(0., c, 0.)) - (radius * 1.05), 0.005);
}

// Function 3691
float DistYCbCr(const vec3 pixA, const vec3 pixB)
{
	const vec3 w = vec3(0.2627, 0.6780, 0.0593);
	const float scaleB = 0.5 / (1.0 - w.b);
	const float scaleR = 0.5 / (1.0 - w.r);
	vec3 diff = pixA - pixB;
	float Y = dot(diff, w);
	float Cb = scaleB * (diff.b - Y);
	float Cr = scaleR * (diff.r - Y);
		
	return sqrt( ((LUMINANCE_WEIGHT * Y) * (LUMINANCE_WEIGHT * Y)) + (Cb * Cb) + (Cr * Cr) );
}

// Function 3692
vec2 map( vec3 p ) { return vec2( .33, 44. ); }

// Function 3693
vec2 map( vec3 p )
{
    vec2 d2 = vec2( p.y+1.0, 2.0 );

	float r = 1.0;
	float f = smoothstep( 0.0, 0.5, sin(3.0+iTime) );
	float d = 0.5 + 0.5*sin( 4.0*p.x + 0.13*iTime)*
		                sin( 4.0*p.y + 0.11*iTime)*
		                sin( 4.0*p.z + 0.17*iTime);
    r += f*0.4*pow(d,4.0);//*(0.5-0.5*p.y);
    vec2 d1 = vec2( length(p) - r, 1.0 );

    if( d2.x<d1.x) d1=d2;

	p = vec3( length(p.xz)-2.0, p.y, mod(iTime + 6.0*atan(p.z,p.x)/3.14,1.0)-0.5 );
	//p -= vec3( 1.5, 0.0, 0.0 );
    vec2 d3 = vec2( 0.5*(length(p) - 0.2), 3.0 );
    if( d3.x<d1.x) d1=d3;

	
	return d1;
}

// Function 3694
vec2 dist(vec2 s, float d)
{
	return clamp(s * d, -1.0, 1.0);
}

// Function 3695
float map( in vec3 p, in vec3 c, out vec4 resColor )
{
    vec3 z = p;
    float m = dot(z,z);

    vec4 trap = vec4(abs(z),m);
	float dz = 1.0;
    
    
	for( int i=0; i<4; i++ )
    {
		dz = 8.0*pow(m,3.5)*dz;
        
#if 0
        float x1 = z.x; float x2 = x1*x1; float x4 = x2*x2;
        float y1 = z.y; float y2 = y1*y1; float y4 = y2*y2;
        float z1 = z.z; float z2 = z1*z1; float z4 = z2*z2;

        float k3 = x2 + z2;
        float k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );
        float k1 = x4 + y4 + z4 - 6.0*y2*z2 - 6.0*x2*y2 + 2.0*z2*x2;
        float k4 = x2 - y2 + z2;

        z.x = c.x +  64.0*x1*y1*z1*(x2-z2)*k4*(x4-6.0*x2*z2+z4)*k1*k2;
        z.y = c.y + -16.0*y2*k3*k4*k4 + k1*k1;
        z.z = c.z +  -8.0*y1*k4*(x4*x4 - 28.0*x4*x2*z2 + 70.0*x4*z4 - 28.0*x2*z2*z4 + z4*z4)*k1*k2;
#else
        
        float r = length(z);
        float b = 8.0*acos( clamp(z.y/r, -1.0, 1.0));
        float a = 8.0*atan( z.x, z.z );
        z = c + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );
#endif        
        
        trap = min( trap, vec4(abs(z),m) );

        m = dot(z,z);
		if( m > 2.0 )
            break;
    }

    resColor = trap;

    return 0.25*log(m)*sqrt(m)/dz;
}

// Function 3696
float distanceFunction(vec3 p){
    vec4 n = vec4(0.0,1.0,0.0,1.0); 
    float disp;
    disp = .3*sin(1.4*p.x+cos(p.z*1.3))-(1.0-abs(sin(p.x+cos(p.z+fbm(p.zx)))))*.4;
    float plane = dot(p,n.xyz) + n.w;
 
    return (plane+disp);
}

// Function 3697
float scene_raycast_object_shadows( Ray ray )
{
    float result = 1.;
    float t = SCN_ZFAR;
    vec3 albedo, N;
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );
        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_PRIMITIVE:
        result *= scene_obj_primitive( obj, localray, t, albedo, N );
        break;
        }
    }
    return max( 0., result );
}

// Function 3698
vec2 sceneNormal(vec2 p) {
    float e = 0.00001;
    float dx = scene(p-vec2(e,0.0)) - scene(p+vec2(e,0.0));
    float dy = scene(p-vec2(0.0, e)) - scene(p+vec2(0.0,e));
    return normalize(vec2(dx,dy));
}

// Function 3699
float calcDist( vec3 pos, vec3 p1, vec3 p2, vec3 p3, vec3 n1, vec3 n2, vec3 n3, out vec3 d, out vec3 n )
{
    vec3 m = calcDistPoint(pos,p1,p2,p3);
    d = m.x*p1 + m.y*p2 + m.z*p3;
    n = m.x*n1 + m.y*n2 + m.z*n3;
    return length(pos-d);
}

// Function 3700
float linedist(vec2 p, vec2 a, vec2 b) {
    float k = dot(p-a, b-a)/dot(b-a,b-a);
    return distance(p, mix(a, b, clamp(k, 0., 1.)));
}

// Function 3701
float distScene(in vec3 pos, out int object){
	 
    pos.yz = rot(0.2 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;
    pos.xz = rot(0.25 * iTime) * pos.xz;
    pos.y += 0.1 + 0.0125 * sin(iTime);
    
    pos.xy = rot(-0.4) * pos.xy;
    pos.xz = rot(0.6) * pos.xz;
    pos.yz = rot(0.4) * pos.yz;

    //gem
    vec3 p = pos;
    p.y -= 0.155;
    float dist = length(p) - 0.05;
    object = 1;
    
    //gold ?
    p = pos;        
    p.y -= 0.11;
    float distGold = distEllipsoid(p, vec3(0.03, 0.01, 0.03));
    distGold = smoothmin(distGold, max(max(length(p.xz) - 0.0175, p.y), -p.y - 0.25), 0.035);
    distGold = smoothmin(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.01, 0.01, 0.01)), 0.035);
	distGold = min(distGold, distEllipsoid(p, vec3(0.04, 0.01, 0.04)));
    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.05, 0.), vec3(0.0225, 0.01, 0.0225)));
    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.25, 0.), vec3(0.025, 0.01, 0.025)));
    distGold = min(distGold, distEllipsoid(p - vec3(0., -0.175, 0.), vec3(0.0225, 0.01, 0.0225)));

    p.y -= 0.115;
    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.12, 0.0075)), 0.02);
    
    p.y -= 0.015;
    p.xy = rot(3. * PI/2.) * p.xy;
    p.xy = repeat(p.xy, 5.);
    distGold = smoothmin(distGold, max(max(length(p.yz), length(p) - 0.15), -(length(p) - 0.08)), 0.03);
    
    float distStar = distEllipsoid(p, vec3(0.02, 0.02, 0.015));
    p.x -= 0.03;
    distStar = smoothmin(distStar, length(p), 0.03);
	distGold = min(distGold, distStar);
    
    p = pos;
    p.y -= 0.15;
    distGold = smoothmin(distGold, distRing(p.xzy, vec2(0.055, 0.006)), 0.00015);
    p.y += 0.24;
    p.x -= 0.02;
    distGold = min(distGold, distBox(p, vec3(0.02, 0.0075, 0.005)));
    p.y += 0.029;
    distGold = min(distGold, distBox(p, vec3(0.02, 0.01, 0.005)));
    p.y -= 0.01;
    distGold = min(distGold, distBox(p, vec3(0.01, 0.02, 0.005)));
    
    dist = min(dist, distGold);
    
    if(dist == distGold){
        object = 3;
    }
    
    if(dist == distStar){
        object = 4;
    }
    
    //wings
    p = pos;
    p.y -= 0.05 + 0.008 * sin(1.5 * iTime);
    p.x = abs(p.x) - 0.05;
    float distWing = length(p) - 0.015;
    vec3 pBranch = p;
    pBranch -= vec3(0.055, 0.04, 0.);
    float rt = 10. * pBranch.x;
    pBranch.xy = rot(rt * rt) * pBranch.xy;
    distWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.08, 0.015, 0.02)), 0.01);
    pBranch = p;
    pBranch.xy = rot(-0.25) * pBranch.xy;
    pBranch -= vec3(0.052, 0.035, 0.);
    rt = 8. * pBranch.x;
    pBranch.xy = rot(rt * rt) * pBranch.xy;
	distWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.07, 0.015, 0.0175)), 0.005);
    pBranch = p;
    pBranch.xy = rot(-0.5) * pBranch.xy;
    pBranch -= vec3(0.04, 0.025, 0.);
    rt = 8. * pBranch.x;
    pBranch.xy = rot(rt * rt) * pBranch.xy;
	distWing = smoothmin(distWing, distEllipsoid(pBranch, vec3(0.05, 0.0125, 0.015)), 0.0075);
        
    dist = min(dist, distWing);
    if(dist == distWing){
        object = 2;
    }
    return 0.5 * dist;

}

// Function 3702
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 colT;
  vec3 vn, col, ros;
  float dstObj, dstBlk;
  dstBlk = BlkHit (ro, rd, vec3 (4.5, 4.5, 0.002));
  dstObj = ObjRay (ro, rd);
  colT = vec4 (0.);
  if (dstBlk < min (dstObj, dstFar)) {
    ros = ro + rd * dstBlk;
    vn = qnBlk;
    if (abs (vn.z ) > 0.99 && length (ros.xy) < 4.5) {
      colT = LoadTx (0.5 * ros.xy / 4.5 + 0.5);
      colT.rgb =  colT.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +
         0.5 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 6.);
    }
  }
  if (dstObj < dstFar) {
    ro += rd * dstObj;
    vn = ObjNf (ro);
    if (idObj == 1) col = vec3 (0.9, 0.9, 1.);
    else if (idObj == 2) col = vec3 (0.7, 0.7, 0.);
    else if (idObj == 3) col = vec3 (0.5, 0.2, 0.1);
    else if (idObj == 4) col = vec3 (0.7, 0.4, 0.3);
    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +
       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
  } else col = (1. - dot (rd.xy, rd.xy)) * vec3 (0.1, 0.2, 0.3);
  col = mix (col, colT.rgb, colT.a);
  return clamp (col, 0., 1.);
}

// Function 3703
vec3 map(in vec3 pos) {
    vec3 plane = vec3(sdPlane(pos), ID_FLOOR, -1. );

    vec3 res = plane;
#ifdef OBJECT_MAP_FUNCTION    
	res =opU(res, OBJECT_MAP_FUNCTION(pos));    
#else
    float t = mod(iTime*0.1, 4.);
    if (t < 1.) {
    	res = opU(res, map1(pos));
    } else if (t<2.) {
       	res = opU(res, map2(pos));
    } else if (t<3.) {
        res = opU(res, map3(pos));
    } else if (t<4.) {
        res = opU(res, map4(pos));
    }
#endif
    return res;
}

// Function 3704
float sdf(in vec3 p) {
  float d = sdfGrid(p, vec3(GRID_SIZE), vec3(GRID_THICKNESS));
  return d;
}

// Function 3705
float SDF( vec3 pos )
{
    // rotate car to line up more nicely with the background
    pos = WorldToObject( pos );

    pos.x = sabs(pos.x,.1);
    
    return
        smax(
            -pos.y - .5,
            smax(
                smax(
                    //pos.x - 1.,
                    length(pos.xy)-1.,
                    smin(
                        smax(
                        	length( pos - vec3(0,-.3,-1) ) - 1.3,
                        	dot(pos,normalize(vec3(0,1,.05))) - .9,
                            .1
                        ),
                        smin(
                        	dot(pos,normalize(vec3(-.2,1,.07))) - .25,
                        	dot(pos,normalize(vec3(0,1,.08))) - .32,
                            .01
                        ),
	                    .03
                    ),
                    .1
                ),
                max(
                    dot(pos - vec3(0,-.5,2.5),normalize(vec3(.2,1,1))),
                    dot(pos,normalize(vec3(0,-.2,-1))) - 2.5 ),
                .1
            ),
            .05
        );
    
    
/*    return
            (
    	        length(pos)-1.// sphere
	            + dot(normalize(pos),sin(pos.yzx/.1)*.1) // knobbles
            ) * .707 // Keep gradient in [-1,1]. Can probably go higher than this but be on the safe side
        ;*/
}

// Function 3706
vec3 map1(in vec3 pos) {
    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);
    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); 
    res.x =abs(res.x);
 	return res;
}

// Function 3707
float shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {
    float depth = start;
    float eps = EPSILON*2.0;
    int iters = 0;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = sceneSDF(eye + depth * marchingDirection,iters);
        if (abs(dist) < eps*(depth+1.0)*image_scale/2.0) {
			if(iters < 2){
                iters += 1;
                eps /= 2.0;
            }
            else
            return depth;
        }
        depth += dist;
        //eps *= 1.01;
        //eps *= 1.01;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

// Function 3708
float map_Ssph(vec3 ro) {
    return distance(ro, Ssphere.xyz) - Ssphere.w;
}

// Function 3709
float sdf_E(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_quarter2_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -8, 0), vec3(4, -8, 0)));
    return t;
}

// Function 3710
float map(vec2 p)
{
    int m = int(GET_MAP_NUM);
    if(m == 0)
		return map001(p);
    else if(m == 1)
        return map002(p);
    else if(m == 2)
        return map003(p);
    else
        return map004(p);
    
}

// Function 3711
float map(vec3 p){
    
    // Warping the whole field around the path.
    p.xy -= path(p.z);
    
    p/=2.;
    
    // Mutated, first order cellular object... the rocks.
    vec3 q = p + (cos(p*2.52 - sin(p.zxy*3.5)))*.2;
    float sf = max(cellTile(q/5.), 0.); 
    
    // Mutated squashed diamond tube. Used to run the camera through.
    p += (cos(p*.945 + sin(p.zxy*2.625)))*.2;
    #ifdef SMOOTHING
    float t = .1 - abs(p.x*.05) - abs(p.y);
    #else
    float t = .05 - abs(p.x*.05) - abs(p.y);
    #endif  
    
    // Smoothly combine the negative tube space with the rocky field.
    //p = sin(p*4.+cos(p.yzx*4.));
    float n = smaxP(t, (.68 - (1.-sqrt(sf)))*2., 1.);// + abs(p.x*p.y*p.z)*.05;
   
    // A bit hacky... OK, very hacky. :)
    return n*3.;
    
}

// Function 3712
vec4 tMap(samplerCube iCh, vec3 p){

    // Multiplying "p" by 100 was style choice.
    p *= 100.;
    
    // Using the 3D coordinate to index into the cubemap and read
    // the isovalue. Basically, we need to convert Z to the particular
    // square slice on the 2D map, the read the X and Y values. 
    //
    // mod(p.xy, 100), will read the X and Y values in a square, and 
    // the offset value will tell you how far down (or is it up) that
    // the square will be.
    
    vec2 offset = mod(floor(vec2(p.z, p.z/10.)), vec2(10, 10));
    vec2 uv = (mod(floor(p.xy), 100.) + offset*100. + .5)/cubeMapRes;
    
    // Back Z face -- Depending on perspective. Either way, so long as
    // you're consistant.
    return texture(iCh, vec3(fract(uv) - .5, .5));
}

// Function 3713
float uSphereDist(in Ray ray, in Sphere sphere) {
    return abs(length(ray.origin - sphere.pos) - sphere.radius);
}

// Function 3714
float minimum_distance(vec2 v, vec2 w, vec2 p)
{	// Return minimum distance between line segment vw and point p
  	float l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt
  	if (l2 == 0.0) {
		return distance(p, v);   // v == w case
	}
	
	// Consider the line extending the segment, parameterized as v + t (w - v).
  	// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2
  	float t = dot(p - v, w - v) / l2;
  	if(t < 0.0) {
		// Beyond the 'v' end of the segment
		return distance(p, v);
	} else if (t > 1.0) {
		return distance(p, w);  // Beyond the 'w' end of the segment
	}
  	vec2 projection = v + t * (w - v);  // Projection falls on the segment
	return distance(p, projection);
}

// Function 3715
float planeSDF(vec3 p, vec3 n) {
    return -dot(p, n);
}

// Function 3716
Hit intersectScene(Ray r)
{
    vec3 axis1 = randomVector(floor(iTime));
    vec3 axis2 = randomVector(floor(iTime+1.));
    vec3 axis = normalize(mix(axis1, axis2, fract(iTime)));
    float translation = 4.*abs(2.*fract(iTime/8.)-1.) - 2.;

    Sphere s = Sphere(1., vec3(1., 1., 0.), Material(vec3(0.5), 0.04));
    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(0.5, 0.4, 0.3), 0.04));
    Cone c = Cone(0.95, 2., vec3(translation, 2., 1.), -axis, Material(vec3(1., 0., 0.), 0.));

    Hit hit = noHit;
    //compare(hit, intersectPlane(p, r));
    //compare(hit, intersectSphere(s, r));
    compare(hit, intersectCone(c, r));
    return hit;
}

// Function 3717
float Map( float range_a_point, float a0, float a1, float b0, float b1 )
{
    return (((range_a_point - a0) * (abs(b1-b0)))/abs(a1-a0)) + b0;
}

// Function 3718
float distTire(vec3 p, float r)
{
    p=abs(p);
    float d=1000.;
    d=min(d,length(p)-r);
    float ang = atan(p.z,p.y);
    float l=length(p.zy);
    p.x+=cos(ang*100.)*.005*smoothstep(.87*r,1.*r,l);
    d=max(d,distTorus(p.yzx+vec3(0,0,.03),r*.78,r*.28));
    d=max(d,-l+r*.61);
    float dx=.04;
    float xfr=mod(p.x,dx);
    float x=p.x-xfr+dx*.5;
    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.01));
    return d;
}

// Function 3719
float sdfPlane(in vec3 p, in vec4 n)
{
	return dot(p, n.xyz) + n.w; // normal must be normalized
}

// Function 3720
Intersection sceneSDF(vec3 samplePoint) 
{   
    float t = iTime*10.0;
	float N = N3(vec3(iResolution));
    
    Intersection sdf = Intersection(MORE_THAN_MAX_DIST, GREEN, obj_null);
    
    #if( SINGLE >= 1 )
        vec3 txSamplePoint = invRotateX(30.0*deg2rad)*invRotateY(iTime)*samplePoint; //iTime 375.35 -90.0*deg2rad

        //move diagonally up and tilt
        txSamplePoint = invTranslateOp( txSamplePoint, vec3(-24.0,15.0,0.0) );
        mat3 rot = invRotateZ(-50.0*deg2rad) * invRotateX(-20.0*deg2rad);
        txSamplePoint = rot * txSamplePoint;    

        txSamplePoint = invRotateY( iTime ) * txSamplePoint;
    #endif

    #if(USE_BOUNDING_VOLUMES == 1)
        vec3 p_bb = invTranslateOp( txSamplePoint, vec3(0.0,-33.5,0.0) );
        float bbJellyFish = sdCapsule( p_bb, vec3(0.0,27.5,0.0), vec3(0.0,-27.5,0.0), 20.0 );

        if(bbJellyFish <= EPSILON)
        {    
            sdf = JellyFish( txSamplePoint, t, N );
        }
        else
        {
            sdf.t = bbJellyFish;
        }
    #else
    	sdf = JellyFish( txSamplePoint, t, N );
    #endif

    return sdf;
}

// Function 3721
float sdf_y(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -4, 0)));
    t = min(t, sdf_quarter3_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    return t;
}

// Function 3722
float nsdf(vec3 p)
{
//	return sdf(p); 
	
	//for normals, add small bump displacements
	float tex=Tex(p).x;
	float grain = -tex*0.075;

	float d = sdf(p, bvec4(1,1,1,1));
	d -= grain;
	
	return d;
}

// Function 3723
vec3 sampleScene(vec2 ro) {
    vec3 fcol = vec3(0);
    
    for(float i=0.; i < LIGHT_SAMPLES; i++) {
    
        float r = (random(ro + i) + i + fract(iTime)) / LIGHT_SAMPLES * PI * 2.0;

        vec2 rd = vec2(cos(r), sin(r));
        float t = trace(ro, rd);
        vec3 col = vec3(0.);
        
        if(t < 20.) {
            vec2 p = ro + t * rd;
            
            if(materials[id].light) {
                // hit a light
                col = materials[id].emissive * materials[id].intensity;
            }
            else {
                if(t < 0.0001) {
                    // inside object (not light)
                    col = texture(iChannel0, ro * 1.2).rrr;
                }
                else {
                    // hit object; calculate reflection
                    vec2 nor = normal(p);
                    vec2 refl = reflect(rd, nor);
                    int matId = id;
                    float k = trace(p + refl * 0.001, refl);
                    if(k < 20.) {
                        // hit light
                        if(materials[id].light) {
                            col = materials[id].emissive * materials[id].intensity * materials[matId].diffuse;
                        }
                        else {
                            // hit material; calculate second reflection
                            vec2 p2 = p + refl*0.001 + k*refl;
                            nor = normal(p2);
                            refl = reflect(refl, nor);
                            int matId2 = id;
                            float j = trace(p + refl * 0.001, refl);
                            if(j < 20. && materials[id].light) {
                                // hit light
                                col = materials[id].emissive * materials[id].intensity 
                                                             * materials[matId2].diffuse
                                                             * materials[matId].diffuse;
                            }
                        }
                    }
                }
            }
        }
        else col = vec3(0.3); // ambient
        fcol += col;
    }
    
    return fcol / LIGHT_SAMPLES;
}

// Function 3724
vec2 map(vec3 p) {
    return map(p, vec3(0,0,0));
}

// Function 3725
float vesicaSDF(vec2 st, float w) { // 14
    vec2 offset = vec2(w * .5, 0.);
    return max(circleSDF(st - offset), circleSDF(st + offset));
}

// Function 3726
float colorDistFast(vec4 c1, vec4 c2){
	float dr = c1.r - c2.r;
    float dg = c1.g - c2.g;
    float db = c1.b - c2.b;
    return dr * dr + dg * dg + db * db;
}

// Function 3727
float map(vec3 p)
{
    objHit.emit = vec3(0);
    objHit.opaque = 1.;
    objHit.screen = false;
    
    float d = 1e+31;
    
    dmin(d, wall(p-vec3(2.5)));
    dmin(d, max(1.5+p.y, -3.-p.z));
    
    
    const float w = 2.25;
    float t = 3. * round(.5 * p.x/w);
    
    vec3 q = p;
    q.x = mod(p.x + w, 2.*w) - w;
    //q.z -= .1 * sin(t);
    
    float ratio = iResolution.x/iResolution.y;
    
    float screen = sbox(abs(q)-vec3(ratio, 1, 0)-.1);
    dmin(screen, sbox(abs(q-vec3(0, -4, .2))-vec3(-.3*p.y, 4, .2)));
    dmin(screen, sbox(abs(q*rx(-.04)-vec3(0, -1.45, -1.5))-vec3(1, .1, .6)));
    
    if(dmin(d, screen))objHit.opaque = .5;
    objHit.screen = (abs(q.z+.1) < .1) && (box(q.xy/vec2(ratio,1)) < 1.);
    //if(objHit.screen)objHit.opaque = .0;
    
    vec2 tuv = q.xy / vec2(ratio, 1);
    objHit.tuv = vec3(0.5 * tuv + 0.5, t);
    
    
    //if(dmin(d, 2.4-p.z+.02*pow(p.y-1., 2.) ))objHit.emit = vec3(2);
    if(dmin(d, 2.46-p.z))objHit.emit = vec3(2);
    
    if(dmin(d, length(p-vec3(-10, 4, -8))-5.))objHit.emit = vec3(2,1,0) * .3;
    if(dmin(d, length(p-vec3(+10, 4, -8))-5.))objHit.emit = vec3(0,1,2) * .5;
    
    if(dmin(d, length(p.yz-vec2(8, -8))-5.))objHit.emit = vec3(.5);
    
	return d;
}

// Function 3728
float map(vec3 pos)
{
  hit.dist = 9999.;
  minDistance(pos, sphere1);
  minDistance(pos, sphere2);
  minDistance(pos, sphere3);
  minDistance(pos, sphere4);
  minDistance(pos, sphere5);
  return hit.dist;
}

// Function 3729
float map(vec3 p){
    return mapMat(p).x;
}

// Function 3730
vec2 map( in vec3 pos )
{
    return vec2( sdSphere( pos, 1.0 ), 2.0 );
}

// Function 3731
vec3 sdfSquare(vec2 uv, float size, vec2 offset) {
  float x = uv.x - offset.x;
  float y = uv.y - offset.y;
  vec2 rotated = rotate(vec2(x,y), iTime);
  float d = max(abs(rotated.x), abs(rotated.y)) - size;
  
  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);
}

// Function 3732
float distSphere( vec3 samplePos, vec3 spherePos, float radius)
{
	vec3 normal;
	float bump = 0.0;
	if(length(samplePos-spherePos) < radius+BUMP_FACTOR)
	{	
		normal = normalize(samplePos-spherePos);
		bump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;
	}
	return length(samplePos-spherePos)-radius+bump;
}

// Function 3733
float distanceOnNormalizedAngle(float angle, float refPoin)
{
  
  float d =abs( angle - refPoin);
  if(d> 0.5) d = 1. - d;
  return d;
}

// Function 3734
vec3 Scene_GetNormal(const in vec3 vPos)
{
    const float fDelta = 0.01;
    
#if 1    
    // dont unroll normal calculation ( from https://www.shadertoy.com/view/ldd3DX )
    
    vec3 n = vec3(0.0);
    for( int i=0; i<NO_UNROLL(4); i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*Scene_GetDistance(vPos+e*fDelta).fDist;
    }
    
    return normalize( n );
#else
    
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
#endif
}

// Function 3735
vec3 trimap(vec3 p, vec3 n){
    vec3 yz = tex(iChannel0, p.yz).xyz;
    vec3 xz = tex(iChannel0, p.xz).xyz;
    vec3 xy = tex(iChannel0, p.xy).xyz;
   
    n /= (n.x + n.y + n.z);
    return yz*n.x + xz*n.y + xy*n.z;
}

// Function 3736
float dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }

// Function 3737
void map_waypoint( inout vec3 col, vec2 coord )
{
	mat2 I = mat2(1);
    float shape = 0.;
    vec2 s = mc2sc( gs_map_project( g_game, g_game.waypoint ) );
    shape = max( shape, aaa_line( I, coord, s, s + vec2( -6, 12 ), 1. ) );
    shape = max( shape, aaa_line( I, coord, s, s + vec2( +6, 12 ), 1. ) );
    col += vec3( 1, .5, .0 ) * shape;
}

// Function 3738
float uBoxDist(in Ray ray, in Box box) {
    return abs(length(max(abs(ray.origin - box.pos) - (box.size * 0.5), 0.0)) - box.radius);
}

// Function 3739
vec2 map(vec3 pos, bool flame)
{
    float floor = map_floor(pos);
    vec2 res = vec2(floor, FLOOR_OBJ);
    
    float structure = map_structure(pos);
    res = opU(res, vec2(structure, STRUCTURE_OBJ)); 
    
    if (flame)
    {
       float flame = map_flame(pos, false);
       res = opU(res, vec2(flame, FLAME_OBJ));
    }
    
    return res;
}

// Function 3740
bool material_bsdf(HitRecord hit_record,Ray inRay, out Ray outRay,out vec3 attenuation){
    vec3 col=vec3(0.0);
    //lambertian
    if(hit_record.material.matType==LAMBERTIAN){
        vec3 ray_origin=hit_record.p;
        vec3 ray_dir=random_cos_weighted_hemisphere_direction(hit_record.normal,g_seed);
        outRay=Ray(ray_origin,ray_dir);
        attenuation=hit_record.material.albedo;
        return true;
    }else if(hit_record.material.matType==METAL){
     //metal
        vec3 reflected=reflect(inRay.direction,hit_record.normal);
        outRay=Ray(hit_record.p,reflected);
        attenuation=hit_record.material.albedo;
         return true;
    }else if(hit_record.material.matType==DIELETRIC){
     //dieletric
        vec3 outward_normal,refracted;
        float ni_over_nt,cosine,reflect_prob;
        vec3 reflected=reflect(inRay.direction,hit_record.normal);
        if (dot(inRay.direction,hit_record.normal)>0.0){
        	outward_normal=-hit_record.normal;
            ni_over_nt=hit_record.material.ior;
            cosine=dot(inRay.direction,hit_record.normal)/length(inRay.direction);
            cosine=sqrt(1.0-ni_over_nt*ni_over_nt*(1.0-cosine*cosine));
            
        }else{
            outward_normal=hit_record.normal;
        	ni_over_nt = 1.0f / hit_record.material.ior;
            cosine=-dot(inRay.direction,hit_record.normal)/length(inRay.direction);
        }
        if (refractVec(inRay.direction, outward_normal, ni_over_nt, refracted))
            reflect_prob = schlick(cosine, hit_record.material.ior);
        else
            reflect_prob = 1.0f;
  
        if (hash1(g_seed)<reflect_prob)
        {
        	outRay=Ray(hit_record.p,reflected);

        } 	
        else
        {

            outRay=Ray(hit_record.p,refracted);
        }
        attenuation=hit_record.material.albedo;
        return true;

        
    }
    return false;

}

// Function 3741
vec3 mapUnderWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapUnderWater(pt).x;    
    normal.x = mapUnderWater(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapUnderWater(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 3742
float remap01(float x, float m_, float _m)
{
 	return clamp((x-m_)/(_m-m_), 0., 1.);
}

// Function 3743
float artifactDist(vec3 p) {
    p -= artifactOffset;
    p = artifactRotation * p;
    return octahedron(p, 1.2);
}

// Function 3744
RMResult map(vec3 p)
{
    float d = FAR;
    float id = -1.;
    
    {// board
        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));
        if (d0 < d)
        {
            d = d0;
            id = 0.5;
        }
    }
    {// queen
		p += vec3(1., 0., 1.);
        // body
        vec3 p0 = p - vec3(0., 0.5, 0.);
        float r = 0.28 + pow(0.4 - p0.y, 2.) / 6.;
        float d0 = sdCappedCylinder(1.5, r, p0) - 0.02;
        // head
        vec3 p1 = p - vec3(0., 1.9, 0.);
        float d1 = sdCappedCylinder(0.2, r - 0.1, p1);
        d0 = smax(d0, -d1, 0.03);
        vec3 p2 = p  - vec3(0., 2.05, 0.);
        float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;
        float l = length(vec2(p2.x, p2.z));
        p2 = vec3(p2.y, l * cos(a), l * sin(a));
        float d2 = sdCappedCylinder(0.6, 0.12, p2);
        d0 = smax(d0, -d2, 0.07);
        vec3 p3 = p - vec3(0., 2.15, 0.);
        float d3 = sdCone(vec2(sin(PI / 5.), cos(PI / 5.)), 0.22, p3);
        d0 = smin(d0, d3, 0.05);
        float d4 = sdSphere(vec3(0., 2.18, 0.), 0.09, p);
        d0 = smin(d0, d4, 0.03);
        vec3 p5 = p - vec3(0., 1.4, 0.);
        float d5 = sdEllipsoid(vec3(0.5, 0.07, 0.5), p5);
        d0 = smin(d0, d5, 0.03);
        vec3 p6 = p - vec3(0., 1.51, 0.);
        float d6 = sdEllipsoid(vec3(0.42, 0.07, 0.42), p6);
        d0 = smin(d0, d6, 0.03);
        // base
        vec3 p7 = p - vec3(0., -1., 0.);
        float d7 = sdTorus(vec2(0.43, 0.5), p7);
        d7 = max(d7, -sdHPlane(0., p7));
        d0 = smin(d0, d7, 0.05);
        float d8 = sdEllipsoid(vec3(0.77, 0.08, 0.77), p - vec3(0., -0.55, 0.));
        d0 = smin(d0, d8, 0.05);
        // stripes
        float d9 = sdTorus(vec2(0.586, 0.01), p - vec3(0., -0.425, 0.));
        d0 = smax(d0, -d9, 0.05);
        float d10 = sdTorus(vec2(0.553, 0.01), p - vec3(0., -0.345, 0.));
        d0 = smax(d0, -d10, 0.05);
        if (d0 < d)
        {
            d = d0;
            id = 1.5;
        }
    }
    
    return RMResult(d, id);
}

// Function 3745
float sdf(vec3 p, bool detail)
{
	float d = 2.0;
    
    for(float i = 0.0; i < 3.0; i+=1.0)
    	d = min(d, Wall(p + vec3(0.0, i * -0.55, 0.0), 2.0 - (i * .35), i, detail));
    
    if(detail)
    {
    	d += -voronoi(p * 18.0) * .012 * smoothstep(1.0, -0.5, p.y);
    }
    
    return d;
}

// Function 3746
float MapPlane( vec3 p)
{
  float  d=100000.0;
  vec3 pOriginal = p;
  // rotate position 
  p=TranslatePos(p, pitch, roll);
  float mirrored=0.;
  // AABB TEST  
  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    
  if (test>1.0) return test;

  // mirror position at x=0.0. Both sides of the plane are equal.
  mirrored = pMirror(p.x, 0.0);

  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));
  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);
  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   

  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   

  // window
  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));
  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);
  winDist = max(winDist, -body);
  body = min(body, winDist);
  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));
  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));

  // front (nose)
  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));
  checkPos = p-vec3(0, 0, 2.5);
  pR(checkPos.yz, 1.57);
  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);
  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);

  // wings       
  frontWingDist = MapFrontWing(p, mirrored);
  d=min(d, frontWingDist);   
  rearWingDist = MapRearWing(p);
  d=min(d, rearWingDist);
  topWingDist = MapTopWing(p, mirrored);
  d=min(d, topWingDist);

  // bottom
  checkPos = p-vec3(0., -0.6, -5.0);
  pR(checkPos.yz, 0.07);  
  d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);

  float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  
  checkPos = p;
  pR(checkPos.yz, 0.85);
  holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); 
  d=fOpUnionRound(d, holder, 0.25);

  // large bomb
  bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   
  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   
  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   

  d=min(d, bombDist2);

  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    

  checkPos = p- vec3(0, 0.2, -5.0);
  d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);

  d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);

  // engine cutout
  blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); 
  d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.45, 2.4)); 

  // engine
  d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));

  engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);
  checkPos = p- vec3(0.4, -0.1, -8.3);
  pR(checkPos.yz, 1.57);
  engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));
  engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));

  checkPos = p-vec3(0., 0., -9.24);  
  checkPos.xy-=vec2(0.4, -0.1);
  checkPos.xy = pModPolar(checkPos.xy, 22.0);

  float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);
  engineDist=min(engineDist, engineCone);

  d=min(d, engineDist);
  eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0)*0.014), vec3(.17, 0.17, .10));
  d=min(d, eFlameDist);

  d=min(d, winDist);
  d=min(d, body);

  d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); 
  checkPos = p-vec3(0.65, 0.55, -1.4);
  pR(checkPos.yz, -0.35);
  d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));

  return min(d, eFlameDist);
}

// Function 3747
vec4 map( in vec2 p )
{
    vec4 d  = sdLine(p, vec2(-1.0,0.4), vec2(1.1,-0.1), vec3(1.0,0.4,0.1),vec3(0.2,0.5,0.8) )-0.05;
    vec4 d2 = sdLine(p, vec2(-0.3,0.8), vec2(0.2,-0.6), vec3(1.0,1.0,0.2), vec3(0.1,0.7,0.3) )-0.05;
    if( d2.x<d.x ) d = d2;
    
    return d;
}

// Function 3748
float distanceField(vec3 p)
{
	fieldDistance = 10000.0;
	fieldMaterial =    -1.0;
    
    float roundness = 0.1;
	
	opUnion(fieldDistance, fieldMaterial, dfPlane(p, vec3(0, 0, 1), 0.0), 1.0);
	opUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(3, 1, 1.05), vec3(1), roundness), 2.0);
	opUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(-3, 1, 1.05), vec3(1), roundness), 2.0);
	opUnion(fieldDistance, fieldMaterial, dfBox(p - vec3(0, -3, 1.05), vec3(1), roundness), 2.0);
	
	return fieldDistance;
}

// Function 3749
float estimateDist_dn(vec3 F)
{
    float grad_norm = length(F.yz);
    return grad_norm > 1e-10 ? F.x/grad_norm : 1e37;
}

// Function 3750
vec3 SceneNormal( in vec3 pos )
{
	vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 normal = vec3(
	    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),
	    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),
	    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );
	return normalize( normal );
}

// Function 3751
vec3 AcesFilmicToneMap(const vec3 x)
{
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// Function 3752
float map(vec3 p) {
    float falling = opSmoothIntersect(sdSphere(tFallRepeat(p, 0.), BALL_SIZE), -p.y);
    tRotate(p.yz, PI / 3.);
    float split1 = opSmoothIntersect(sdSphere(tFallRepeat(p, -PI / 4.), BALL_SIZE), (p.y - p.x) * SQ2);
    float split2 = opSmoothIntersect(sdSphere(tFallRepeat(p, PI / 4.), BALL_SIZE), (p.y + p.x) * SQ2);
    float split = opSmoothUnion(split1, split2);
    return opSmoothUnion(split, opSmoothUnion(sdSphere(p, 1.), falling));
}

// Function 3753
float sdfSubtraction( float d1, float d2 ) { return max(-d1,d2); }

// Function 3754
vec3 tonemap(vec3 rawColor, float exposure)
{
    float w = 11.2;

    vec3 exposedColor = max(rawColor * exposure, 0.0);

    vec3 linear = pow(exposedColor, vec3(1.0 / 2.2));

    vec3 reinhard = pow(exposedColor / (exposedColor + 1.0), vec3(1.0 / 2.2));

    vec3 x = max(exposedColor - .004, 0.0);
    vec3 hejlBurgessDawson = (x * (x * 6.2 + .5)) / (x * (x * 6.2 + 1.7) + .06);

    float exposureBias = 2.0;
    vec3 curr = hableTonemap(exposedColor * exposureBias);
    float whiteScale = (vec3(1.0) / hableTonemap(vec3(w))).x;
    vec3 color = curr * whiteScale;
    vec3 hable = pow(color, vec3(1.0 / 2.2));

    return
        //linear
        //reinhard
        hejlBurgessDawson
        //hable
        ;
}

// Function 3755
float unionSDF(float distA, float distB) { return min(distA, distB); }

// Function 3756
vec2 map( in vec3 pos ) {
    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    
	float secs = mod( floor(iDate.w),        60.0 );
	float mins = mod( floor(iDate.w/60.0),   60.0 );
	float hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;
    
    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );
    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );
    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );
    
    return map( pos, p1, ps, pm, ph, true, true );
}

// Function 3757
float objectMapReflectiveness(vec3 p){
    mapResult M = map(p);
    float m = M.Md;
    return m > 50.0 ? 0.
         : m == spheres[M.minS].dist ? spheres[M.minS].reflectiveness
         : m == boxes[M.minB].dist ? boxes[M.minB].reflectiveness
         : m == planes[M.minP].dist ? planes[M.minP].reflectiveness : 0.;
}

// Function 3758
float Scene( vec3 p )
{
    float ret = p.y - Terrain( p.xz );

    vec3 t = p;
    t.x = mod( t.x, 200.0 ) - 0.5 * 200.0;
    t.z = mod( t.z, 200.0 ) - 0.5 * 200.0;
    Rotate( t.yz, 0.1 * MATH_PI );      
    ret = UnionRound( ret, RoundBox( t, vec3( 10.0, 100.0, 10.0 ), 2.0 ), 30.0 );
    
    t = p;
    t.x = mod( t.x, 150.0 ) - 0.5 * 150.0;
    t.z = mod( t.z, 150.0 ) - 0.5 * 150.0;
    Rotate( t.yz, -0.2 * MATH_PI );      
    ret = UnionRound( ret, RoundBox( t, vec3( 4.0, 30.0, 4.0 ), 1.0 ), 6.0 );    
    
    t = p;
    t.x = mod( t.x, 30.0 ) - 0.5 * 30.0;
    t.z = mod( t.z, 30.0 ) - 0.5 * 30.0;
    Rotate( t.yz, 0.2 * MATH_PI );
    t.y += 4.0;
    float box2 = RoundBox( t, vec3( 2.0, 10.0, 2.0 ), 0.25 );
    
    t = p;
    t.x = mod( t.x, 70.0 ) - 0.5 * 70.0;
    t.z = abs( t.z ) - 30.0;
	Rotate( t.xz, 0.2 * MATH_PI ); 
    t.y += 4.0;
    box2 = Union( box2, RoundBox( t, vec3( 4.0, 8.0, 10.0 ), 1.0 ) );

    ret = UnionRound( ret, box2, 3.0 );
    
    t = p;
    t.x -= 150.0;
    t.x = mod( t.x, 200.0 ) - 0.5 * 200.0;
    t.y += 2.0;
    t.z = abs( t.z ) - 7.0;
    Rotate( t.yz, -0.1 * MATH_PI );
    float tunnel = RoundBox( t, vec3( 2.0, 13.0, 2.0 ), 0.25 );
    tunnel = Union( tunnel, RoundBox( t + vec3( 8.0, 0.0, 0.0 ), vec3( 2.0, 7.0, 2.0 ), 0.25 ) );
    tunnel = Union( tunnel, RoundBox( t + vec3( 16.0, 0.0, 0.0 ), vec3( 2.0, 9.0, 2.0 ), 0.25 ) );
	tunnel = Union( tunnel, RoundBox( t + vec3( 32.0, 0.0, 0.0 ), vec3( 2.0, 12.0, 2.0 ), 0.25 ) );
	tunnel = Union( tunnel, RoundBox( t + vec3( 40.0, 0.0, 0.0 ), vec3( 2.0, 7.0, 2.0 ), 0.25 ) );
    ret = UnionRound( ret, tunnel, 3.0 );
                   
    return ret;
}

// Function 3759
vec3 objectMapNormals(vec3 pos){
    const float grad_step = 0.02;
	const vec3 dx = vec3( grad_step, 0.0, 0.0 );
	const vec3 dy = vec3( 0.0, grad_step, 0.0 );
	const vec3 dz = vec3( 0.0, 0.0, grad_step );
	return normalize (
		vec3(
			map( pos + dx ).Md - map( pos - dx ).Md,
			map( pos + dy ).Md - map( pos - dy ).Md,
			map( pos + dz ).Md - map( pos - dz ).Md			
		)
	);
}

// Function 3760
vec3 map_Ssph_pm(vec3 ro, vec3 rd) {
    vec3 nrm = map_Ssph_norm(ro),
         rotnrm = rotateXY(nrm, vec2(0., iTime*.5)),
         col = tex(iChannel0, rotnrm).rgb;
    return col*col*max(0.,dot(rd, -nrm));
}

// Function 3761
vec2 hMap(vec2 uv){
    
    // Plain Voronoi value. We're saving it and returning it to use when coloring.
    // It's a little less tidy, but saves the need for recalculation later.
    float h = Voronoi(uv*6.);
    
    // Adding some bordering and returning the result as the height map value.
    float c = smoothstep(0., fwidth(h)*2., h - .09)*h;
    c += (1.-smoothstep(0., fwidth(h)*3., h - .22))*c*.5; 
    
    // Returning the rounded border Voronoi, and the straight Voronoi values.
    return vec2(c, h);
    
}

// Function 3762
vec2 scene(vec3 pos)
{
    Object object[OBJCNT];
    object[0].pos = vec3(0.0, 0.0, 1.0);
    object[0].type = OBJ_SPHERE;
    object[0].material = 2;
    
    object[1].pos = vec3(-1.0, 1.0, 2.0);
    object[1].type = OBJ_BOX;
    object[1].material = 2;
    
    object[2].pos = vec3(2.0, 1.0, 2.0);
    object[2].type = OBJ_CONE;
    object[2].material = 2;
    
    vec2 result = vec2(0.0);
    for(int i = 0; i < OBJCNT; i++)
    {
        if(i == 0)
        {
            result = vec2(traceObject(pos, object[i]), object[i].material);   
        }
    	else
    	{
			result = opU(vec2(traceObject(pos, object[i]), object[i].material), result);
    	}
    }
 	return result;   
}

// Function 3763
float torusSDF_multi( vec3 p, float r, float thickness ){ // a torus inside a torus inside a torus inside a torus inside a torus inside a torus
  vec2 q = fract(vec2(length(p.xz)-r,p.y) *.5);
  return length(q)- thickness;
}

// Function 3764
float raysSDF(vec2 st, int N) { // 30
    st -= .5;
    return fract(atan(st.y, st.x) / TAU * float(N));
}

// Function 3765
float torusKnotLineSqDistanceDerivative(float t, Ray ray, TorusKnotParameters tkp)
{
    //return torusKnotSqDistanceDerivative(t, ray.ro, tkp) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
    //  
	//return 2.*dot(torusKnot(t, tkp) - ray.ro, torusKnotDerivative(t, tkp)) - 2.*dot(torusKnot(t, tkp) - ray.ro, ray.rd)*dot(torusKnotDerivative(t, tkp), ray.rd);
	//  
    
    vec3 tk = torusKnot(t, tkp);
    vec3 tkd = torusKnotDerivative(t, tkp);
        
    //return 2.*dot(tk - ro, tkd) - 2.*dot(tk - ro, rd)*dot(tkd, rd);
    //  
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd)*dot(tkd, rd));
    //  
    //return 2.*(dot(tk - ro, tkd) - rdot(tk - ro, rd*dot(tkd, rd)));
    //  
    return 2.*(dot(tk - ray.ro, tkd - ray.rd*dot(tkd, ray.rd)));
}

// Function 3766
float sdf_6(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_half0_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));
    return t;
}

// Function 3767
vec2 mapMat(vec3 p){
    vec3 q = p;
    p = vec3(p.x + sin(p.z), p.y + cos(p.z), p.z);
    q = vec3(q.x - sin(q.z), q.y - cos(q.z), q.z);
    
    vec2 helixa = vec2(length(p.xy) - 0.5 - (texture(iChannel0, p.xz) * 0.1).y, 2.0);
    vec2 helixb = vec2(length(q.xy) - 0.5 - (texture(iChannel0, q.xz) * 0.1).y, 3.0);

    return vecMin(helixa, helixb);
}

// Function 3768
float sceneDf(vec3 p, out vec3 color1, out vec3 color2)
{
    float dist = asteroidDf(p, color1, color2);
    return dist;
}

// Function 3769
float distanceNGon(vec2 uv, const float N, const float R) {
    uv = -uv.yx; 								 // if you want the corner to be up
    float sa = PI2 / N; 						 // segment angle
    float a = floor(atan(uv.y,uv.x)/sa+0.5)*sa;  // round current angle to closest segment angle
        
    vec2 p1 = vec2(cos(a),sin(a)); 				 // plane to find distance to
    float distr = dot(uv,p1) - R; 				 // signed distance to edge
#ifndef FAST
    float hw = R * tan(sa * 0.5); 				 // half-width of the edge
    float disth = abs(dot(uv,vec2(-p1.y,p1.x))); // horizontal distance to the middle of the edge
    return length(vec2(min(hw-disth,0.0),distr))*sign(distr); // distance to the edge or corner point
#endif
    return distr;
}

// Function 3770
vec3 distCol (float d)
{
    float a = pow(cos(d * 120.) * .5 + .5, 10.)*.8 + .2;
    vec3 c = mix(vec3(.8,.5,0.), vec3(.3,.3,.9), sign(d)*.5 + .5)*a;
    c = mix(c, vec3(.8,.8,1.), 1./(abs(d)*100.+1.));
    return c;
}

// Function 3771
float map( vec3 p ){
  
  //I get a few artifacts with this probably because it's
  //adjusting the height of everything in the scene
  //before instancing. So it's kind of like the unforgivable sin.
   vec3 terrainHohe = vec3(0.,warpedfbm(p.xz/4.)*
                              TERRAIN_HEIGHT,0.);
  
   //field id for moe randomness between feilds
   float feldID = 0.;
   //first field
   float f =  feld(p + terrainHohe, feldID);
   f = min( f, plane( p + terrainHohe ) );
   
   //shift p.xz
   vec3 shift = vec3( 1.9, 0., 1.9 );
   //increment field id
   feldID++;
   f = min( f, feld(  p + terrainHohe + shift, feldID));
   //one more time
   shift = vec3( -1.9, 0., 3.9 );
   feldID++;
   f = min( f, feld(  p + terrainHohe + shift, feldID));

 //add pillars
  f = min(f,pillar(p) );
  //add wisps
  f = wisps(p,f);
  
   return f;
   
  }

// Function 3772
vec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection)
{
    // Determine our camera info
    Ray cameraRay = Ray(cameraPosition, cameraDirection);
       
    vec3 finalColor = vec3(0.0);

    IntersectionData intersection = Intersect(cameraRay);        
    if(intersection.mT < MAX_DISTANCE)
    {   
        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);
        vec3 normal = GetNormal(intersectionPoint);

        vec3 diffuse = vec3(1.0);
        const float ambient = 0.2;
        
        if(intersection.mMaterialIndex == TORUS)
        {
			diffuse = vec3(1.0, 0.4, 0.0);
        }
        else if(intersection.mMaterialIndex == GROUND)
        {
            float tile = mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;
            diffuse = vec3(0.5) + tile;
        }
        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, ambient);         
    }
    
    vec3 fogColor = vec3(0.85, 0.85, 1.0);
    float fogAmount = 1.0 - exp(-intersection.mT * 0.015);
    finalColor = mix(finalColor, fogColor, fogAmount);
                          
    return vec4(finalColor, 1.0);
}

// Function 3773
vec2 map( in vec3 pos, bool showSurface )
{
    const vec3 box_rad = vec3(1.1,0.5,0.6);

    // compute closest point to gPoint on the surace of the box
    vec3 closestPoint = closestPointToBox(gPoint, box_rad );
    
    // point
    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );
    
    // closest point
    {
    float d = sdSphere( pos, closestPoint, 0.06 );
    if( d<res.x ) res = vec2( d, 4.0 );
    }
    
    // box (semi-transparent)    
    if( showSurface )
    {
    float d = sdBox( pos, box_rad );
    if( d<res.x ) res =  vec2( d, 3.0 );
    }

    // segment
    {
    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );
    if( d<res.x ) res =  vec2( d, 4.0 );
    }

    // box edges
    {
    float d = sdBoxFrame( pos, box_rad, 0.01 );
    if( d<res.x ) res =  vec2( d, 5.0 );
    }
    
    return res;
}

// Function 3774
float map3( in vec3 p )
{
	vec3 q = p - vec3(0.0,0.1,1.0)*iTime;
	float f;
    f  = 0.50000*noise( q ); q = q*2.02;
    f += 0.25000*noise( q ); q = q*2.03;
    f += 0.12500*noise( q );
	return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );
}

// Function 3775
float dist(in vec2 pos, in float size, in vec2 fragCoord)
{
    float dist;
    dist = distance(fragCoord.xy, pos);
	dist = size / pow(dist, 2.0);
    return dist;
}

// Function 3776
float perpendicularDistance(Line line)
{
    return length(line.point - dot(line.point, line.direction) * line.direction);
}

// Function 3777
vec4 map4(vec3 p) {
  float k;
  return map4(p,k);
}

// Function 3778
vec4 sceneColor(vec2 uv)
{
    vec4 outColor = vec4(FXAA(uv, iChannel1, 1.0/iResolution.xy), 1.0);
    
    return outColor;
}

// Function 3779
float sdf_8(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_torus(pos, vec3(2, -6, 0)));
    return t;
}

// Function 3780
float ellipse_dist(in vec2 p, in vec2 ab, 
                   out vec4 coeffs,
                   out vec4 roots,
                   out bool is_circle) {
    
    // distance and sign
    vec2 ds = vec2(1e5, -1);
    
    is_circle = abs((ab.x - ab.y) / ab.x) < 1e-2;
    
    // circles need special-case handling because the quartic
    // degenerates into a quadratic.    
    if (is_circle) {
        
        // a and b are pratically equal, so treat this as a circle
        float dc = length(p) - ab.x;
        
        float u = normalize(p).x;
        
        
        
        roots = vec4(u, 0, 0, -u);
        coeffs = vec4(0, 1, 0, -u*u);
        
        ds = vec2(abs(dc), dc);
        
    } else {
        
        // general ellipse case
        
        
        // formulate the quartic polynomial that represents
        // this ellipse. we are solving for the position 
        // u = cos(theta) along the ellipse such that the
        // tangent at the point [a*u, b*sqrt(1-u^2)] is 
        // perpendicular to the displacement between p
        // and the point itself.
        //
        // there may be multiple valid solutions for this 
        // polynomial -- for a full ellipse we could just 
        // grab the maximal root but we actually need
        // to inspect each of them in the arc case.
        
        float l = ab.y*ab.y - ab.x*ab.x;

        float ax = ab.x*p.x / l;
        float by = ab.y*p.y / l;

        float a2x2 = ax*ax;
        float b2y2 = by*by;

        // vector of polynomial coefficients
        coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);

        // solve for up to 4 roots 
        solve_quartic(coeffs, roots);

        // for each root
        for (int i=0; i<4; ++i) {
            
            // construct point on unit circle
            vec2 uv = from_cos(roots[i]);
            
            // need to check this point both above and below x-axis
            for (int j=0; j<2; ++j) {
                
                // get the absolute distance to the closest point on 
                // the ellipse, as well as its sign
                vec2 pc = ab*uv;
                ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));    
                
                // mirror the root point across the x-axis
                uv.y *= -1.;
                
            }
        }        
        
    }
    
    // combine the absolute distance with the sign of the 
    // distance, respecting original sign classification
    // before root finding
    return ds.x*sign(ds.y);
    
}

// Function 3781
void onSetupScene()
{
    lightPos = vec3( 0.0, 8.0, 2.0 );
   
    // Light Visualizer
    spheres[0].position = lightPos;
    spheres[0].radius = 0.5;
    spheres[0].diffuseColor = vec3( 1.0, 1.0, 0.0 );
    spheres[0].shadowCasterIntensity = 1.0;
    spheres[0].lightVisualizer = 1;
    spheres[0].reflectionIntensity = 0.0;
   
    spheres[1].position = vec3( -5.0, 1.0, -3.0 );
    spheres[1].radius = 1.0;
    spheres[1].diffuseColor = vec3( 1.0, 1.4, 1.0 );
    spheres[1].shadowCasterIntensity = 0.5;
    spheres[1].reflectionIntensity = 0.0;
    
    spheres[2].position = vec3( 0.0, 1.0, 1.0 );
    spheres[2].radius = 1.0;
    spheres[2].diffuseColor = vec3( 1.0, 0.4, 1.0 );
    spheres[2].shadowCasterIntensity = 0.5;
    spheres[2].reflectionIntensity = 0.7;
    
    spheres[3].position = vec3( 5.0, 1.0, -3.0 );
    spheres[3].radius = 1.0;
    spheres[3].diffuseColor = vec3( 0.0, 1.0, 1.4 );
    spheres[3].shadowCasterIntensity = 0.5;
    spheres[3].reflectionIntensity = 0.0;
    
    planes[0].pointOnPlane = vec3( 0.0, 0.0, 0.0 );
    planes[0].normal = vec3( 0.0, 1.0, 0.0 );
    planes[0].diffuseColor = vec3( 0.8 );
    planes[0].shadowCasterIntensity = 1.0;
    planes[0].reflectionIntensity = 0.0;
    
    planes[1].pointOnPlane = vec3( -10.0, 0.0, 0.0 );
    planes[1].normal = vec3( 1.0, 0.0, 0.0 );
    planes[1].diffuseColor = vec3( 1.0, 0.0, 0.0 );
    planes[1].shadowCasterIntensity = 1.0;
    planes[1].reflectionIntensity = 0.0;
    
    planes[2].pointOnPlane = vec3( 10.0, 0.0, 0.0 );
    planes[2].normal = vec3( -1.0, 0.0, 0.0 );
    planes[2].diffuseColor = vec3( 0.0, 0.0, 1.0 );
    planes[2].shadowCasterIntensity = 1.0;
    planes[2].reflectionIntensity = 0.0;
    
    planes[3].pointOnPlane = vec3( 0.0, 0.0, -10.0 );
    planes[3].normal = vec3( 0.0, 0.0, 1.0 );
    planes[3].diffuseColor = vec3( 0.0, 1.0, 0.0 );
    planes[3].shadowCasterIntensity = 1.0;
    planes[3].reflectionIntensity = 0.0;
    
    planes[4].pointOnPlane = vec3( 0.0, 15.0, 0.0 );
    planes[4].normal = vec3( 0.0, -1.0, 0.0 );
    planes[4].diffuseColor = vec3( 0.0, 1.0, 1.0 );
    planes[4].shadowCasterIntensity = 1.0;
    planes[4].reflectionIntensity = 0.0;
    
    planes[5].pointOnPlane = vec3( 0.0, 0.0, 15.0 );
    planes[5].normal = vec3( 0.0, 0.0, -1.0 );
    planes[5].diffuseColor = vec3( 1.0, 1.0, 0.0 );
    planes[5].shadowCasterIntensity = 1.0;
    planes[5].reflectionIntensity = 0.0;
}

// Function 3782
geometry map(vec3 p) {
    vec3 bp = p;
    
    p.x -= 8.5;
    
	pModMirror2(p.yz, vec2(34.));
    
    vec2 c =  pMirrorOctant(p.zy, vec2(58., 38. ));
    
    pMirrorOctant(p.xz, vec2(12., 40.));
    
    geometry obj;
  	
    obj = DE(p, 1. );
    obj.material = vec2(1., 0.);
    obj.space = p;
    obj.color = fromRGB(204,141,96); 
    
    geometry obj2;
    
    p.yx += 15.;
    
    obj2 = DE(p, 1.5 * sin(p.x / 10.) * 10.);
    obj2.color = vec3(5.);

    p = bp;
    p += + vec3(-70., 20., 10. + t * 25.);
    
    geometry obj3;
    
    p += vol;
    
    pR(p.xz, t);
    pR(p.yz, p.x / 10. -t);

    vec3 bo = vec3(.1, 1. + vol * 10., .1);
    
	bo.xz += length(p) / 15.;
    obj3.dist = sdCross(p, bo);
    
    pR(p.xy, PI / 4.);
    pR(p.zy, PI / 4.);
    
    obj3.dist = min(obj3.dist, sdCross(p, bo));
    
    pR(p.xy, PI / 2.);
    pR(p.zy, PI / 2. );

    obj3.dist = min(obj3.dist, sdCross(p, bo.zxy));
    obj3.color = fromRGB(204,141,96) + 1. - length(p.xy) / 10.; 
    
    obj3.material = vec2(1. , 0.);
    obj3.dist = smin(obj3.dist, obj.dist, .4);
    
    obj = geoU(obj, obj3);
    
    
    return obj;
}

// Function 3783
float cubeDistance(vec3 rayPosition, vec3 cubePosition, vec3 cubeSize) {
    vec3 d = abs(rayPosition - cubePosition) - cubeSize;
    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));
}

// Function 3784
vec3 SceneNormal(vec3 p, float h, out float d, int izero)
{
	vec3 n, o = vec3(0,0,h);
	vec4 s;
	for (int i = izero+4; i-- > 0; o = vec3(o.yz, 0))
		s[i] = Scene(p + o).d;        
	n = s.yzw - (d = s.x);
	if (dot(n,n) < 1e-7) n = vec3(0,1,0);
	else n = normalize(n);
	return n;
}

// Function 3785
float SdfSphere(Object obj, vec3 pos){
    return length(pos - obj.pos) - obj.scale.x;
}

// Function 3786
float distHearts(vec2 pos) {
	float dis = 1.0;
	
	vec2 smallPos = pos * 1.5 + vec2(0.66, 0.0);
	vec2 bigPos = pos * 1.5 + vec2(-0.66, 0.0);

	dis = min(dis, distSmallHearts(smallPos));
	dis = min(dis, distHeart(bigPos, 1.75));
	return dis;
}

// Function 3787
vec2 map_4( in vec3 pos ) { // scene + ro + one sphere
    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),
	                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );
    
    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );
    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));
    
    return res;
}

// Function 3788
Intersect IntersectScene( vec3 rayStart, vec3 rayDir )
{
    vec3 normal = vec3(0);
    
    vec2 span = vec2(-far,far);
    #define Intersection(a) { vec3 n = normalize(a.xyz); vec2 tt=IntersectPlane(rayStart, rayDir, n, a.w ); if ( tt.x > span.x ) { span.x = tt.x; normal = n; } span.y = min(span.y,tt.y); }
    
    Intersection( vec4( 1,1,1, .2 ) );
    Intersection( vec4( 1,-1,-1, .2 ) );
    Intersection( vec4( -1,1,-1, .2 ) );
    Intersection( vec4( -1,-1,1, .2 ) );

    float t = (span.x < span.y && span.x > 0.) ? span.x : far;
    #define Union(a) { vec3 n = normalize(a.xyz); vec2 tt=IntersectPlane(rayStart, rayDir, n, a.w ); if ( tt.x > 0. && tt.x < t ) { t = tt.x; normal = n; } }

    Union( vec4( 0,1,0, -1. ) );
    Union( vec4( 0,0,-1, -8. ) );
    Union( vec4( -1,-.99,0, -2. ) ); // there's a bug when this hits 1
    Union( vec4( 1,0,-1, -5. ) );
    Union( vec4( 1,0,0, -5. ) );
    Union( vec4( 0,-1,1, -5. ) );
    
    return Intersect( t, normal );
}

// Function 3789
SceneResult Scene_LightBulbSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    SceneResult resultBulb = Scene_GetDistanceBulb( vPos );
    SceneResult_Combine( resultInside, resultOutside, resultBulb, insideObjId );
    
    
    SceneResult resultPendant;
    float yTop = 2.3;
    float yBottom = 1.5;
    float pRad1 = 0.55;
    float pRadTop = 0.5;
    float t = (vPos.y - yBottom) / ( yTop - yBottom );
    resultPendant.fDist = length( vPos.xz ) - mix( pRad1, pRadTop, t );
    resultPendant.fDist = max( resultPendant.fDist, -vPos.y + yBottom );
    resultPendant.fDist = max( resultPendant.fDist, vPos.y - yTop );
    resultPendant.fDist = min( resultPendant.fDist, length( vPos - vec3(0,yTop,0) ) - pRadTop );

    resultPendant.vUVW = vec3(vPos);
    resultPendant.iObjectId = MAT_PENDANT;
    
    float fInnerDist = length( vPos - vec3(0,1.5, 0) ) - 0.4;
    if ( -fInnerDist > resultPendant.fDist )
    {
	    resultPendant.fDist = -fInnerDist;
    	resultPendant.iObjectId = MAT_CHROME;
    }
    
    
    SceneResult_Combine( resultInside, resultOutside, resultPendant, insideObjId );

    
    SceneResult resultFlex;
    resultFlex.fDist = length( vPos.xz ) - 0.05;
    resultFlex.fDist = max( resultFlex.fDist, -vPos.y + 1.5f );
    resultFlex.fDist = max( resultFlex.fDist, vPos.y - 5.0f );
    
    resultFlex.vUVW = vec3(vPos);
    resultFlex.iObjectId = MAT_WHITE_GLOSS;
    
    SceneResult_Combine( resultInside, resultOutside, resultFlex, insideObjId );
    
    
    
    SceneResult resultProngs;
    vec3 vProngDomain = vPos;
    vProngDomain.x = abs( vProngDomain.x );
    resultProngs.fDist = DistanceCapsule( vProngDomain, vec3( 0.4, 1.0, 0), vec3(0.05, 2.0, 0.0), 0.01 );
    resultProngs.vUVW = vec3(vPos);
    resultProngs.iObjectId = MAT_CHROME;
    
    SceneResult_Combine( resultInside, resultOutside, resultProngs, insideObjId );
    
    SceneResult resultFilament;
    //resultFilament.fDist = length( vPos ) - 0.1;
    
    vec3 vFilamentDomain = DomainRotateSymmetry( vPos, 6.0);
	resultFilament.fDist = DistanceCapsule( vFilamentDomain, vec3( 0.0, 0.6, 0.3), vec3(0.0, -0.6, 0.3), 0.02 );

    resultFilament.vUVW = vec3(vPos);
    resultFilament.iObjectId = MAT_FILAMENT;
    
    SceneResult_Combine( resultInside, resultOutside, resultFilament, insideObjId );
    
    SceneResult resultWall;
    
    resultWall.fDist = vPos.z + 2.0;
    resultWall.vUVW = vec3(vPos * 0.2);
    resultWall.iObjectId = MAT_TEXTURED_FLOOR;

    SceneResult_Combine( resultInside, resultOutside, resultWall, insideObjId );
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 3790
float distanceField(vec3 point) {
	float dist = 10000.0;
	
	//point.x+=sin(point.y+iTime) * 0.5;
	
	point=vec3(mod(point.x+tileSize*1.5,tileSize*3.0)-tileSize*1.5,point.y,mod(point.z+tileSize,tileSize*2.0)-tileSize);
	
	vec4 theSphere = vec4(0.0,0.0,0.0,1.0);
	dist = min(dist, distanceToSphere(theSphere,point));
	
	vec3 rectCenter = vec3(3.0,0.0,0.0);
	vec3 rectExtents = vec3(1.0,2.0,1.0);
	dist = min(dist, distanceToRect(rectExtents,rectCenter,point));
	
	rectCenter = vec3(-3.0,0.0,0.0);
	vec4 rectExtents2 = vec4(1.0,1.0,1.0,0.7);
	dist = min(dist,distanceToRoundRect(rectExtents2,rectCenter,point));
	
	dist=min(dist,distanceToFloor(-2.0,point));
	
	return(dist);
}

// Function 3791
float MapFlyingMissile( vec3 p, Missile missile)
{
  TranslateMissilePos(p, missile);  
  // map missile flame
  eFlameDist = min(eFlameDist, sdEllipsoid( p+ vec3(0., 0., 2.2+cos(iTime*90.0)*0.23), vec3(.17, 0.17, 1.0)));
  // map missile 
  return min(MapMissile(p, missile), eFlameDist);
}

// Function 3792
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vng;
  float dstObj, dstGrnd, cylLen, cylRad, w;
  cylLen = 0.5 * sphGap * (nSphObj / 3. - 1.) - 0.8;
  cylRad = 0.5 * sqrt3 * sphGap + 0.2;
  dstObj = CapsHit (ro, rd, cylRad, cylLen);
  dstGrnd = GrndRay (ro, rd);
  if (min (dstObj, dstGrnd) < dstFar) {
    if (dstObj < dstGrnd) {
      ro += dstObj * rd;
      col = HsvToRgb (vec3 (0.7 * float (idHit) / float (nObj), 0.5, 1.)) * (0.5 +
         0.5 * pow (max (- dot (qnHit, rd), 0.), 4.));
    } else {
      ro += dstGrnd * rd;
      vng = VaryNf (64. * ro, vec3 (0., 1., 0.), 0.2);
      w = smoothstep (0., 5., CapsHit (ro, vng, cylRad, cylLen));
      col = mix (vec3 (0.2, 0.2, 0.15), vec3 (0.1, 0.1, 0.15), GrndPat (ro.xz)) +
         0.2 * (1. - w) * (0.5 + 0.5 * pow (max (- dot (qnHit, vng), 0.), 4.)) *
         HsvToRgb (vec3 (0.7 * float (idHit) / float (nObj), 0.5, 1.));
    }
  } else col = vec3 (0.);
  w = clamp (4. * min (dstObj, dstGrnd) / dstFar - 3., 0., 1.);
  if (w > 0.) col = mix (col, StarPat (rd, 4.), w);
  return clamp (col, 0., 1.);
}

// Function 3793
float map(vec3 p) {
  
  
  vec3 bp=p;
  
  p.xy *= rot((p.z*0.023+time*0.1)*0.3);
  p.yz *= rot((p.x*0.087)*0.4);
  
  float t=time*0.5;
  vec3 p2 = fr(p, t * 0.2);
  vec3 p3 = fr(p+vec3(5,0,0), t * 0.23);
  
  float d1 = box(p2, vec3(1,1.3,4));
  float d2 = box(p3, vec3(3,0.7,0.4));
  
  float d = max(abs(d1), abs(d2))-0.2;
  float dist = 1.;
  vec3 p4=(fract(p2/dist-.5)-.5)*dist;
  float d3 = box(p4, vec3(0.4));
  //d = max(d, -d3);
  d = d - d3*0.4;
  
  //d = max(d, length(bp)-15);
  
  
  //float f=p.z + time*4;
  //p.x += sin(f*0.05)*6;
  //p.y += sin(f*0.12)*4;
  //d = max(d, -length(p.xy)+10);
  
  at += 0.13/(0.13+abs(d));
  
  float d5 = box(bp, vec3(4));
  
  float dist2 = 8.;
  vec3 p5=bp;
  p5.z = abs(p5.z)-13.;
  p5.x=(fract(p5.x/dist2-.5)-.5)*dist2;
  float d6 = length(p5.xz)-1.;
  
  at2 += 0.2/(0.15+abs(d5));
  at3 += 0.2/(0.5+abs(d6));
  
  return d;
}

// Function 3794
float sdf_r(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));
    return t;
}

// Function 3795
vec3 envMap(vec3 rd, vec3 sn){
    
    vec3 sRd = rd; // Save rd, just for some mixing at the end.
    
    // Add a time component, scale, then pass into the noise function.
    rd.xy -= iTime*.075;
    rd *= 3.;
    
    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.
    c = smoothstep(0.4, 1., c); // Darken and add contast for more of a spotlight look.
    
    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.
    //vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.
    
    // Mix in some more red to tone it down and return.
    return mix(col, col.yzx, sRd*.25+.25); 
    
}

// Function 3796
float yinDist(vec2 p)
{
    float R = 1.;    
    float r = .15;
    
    float d = length(p)-R;
    
    d = max(d, -(length(p-vec2(0.,R*.5))-R*.5));
    if(p.x>0.)
    {
    	d = max(d, length(p-vec2(0.,R)));
        
    	d = min(d, (length(p-vec2(0.,-R*.5))-R*.5));
    }
    
    d = min(d, length(p-vec2(0., R*.5))-r);
    d = max(d, -(length(p+vec2(0., R*.5))-r));
    
    
    return -d;
}

// Function 3797
float nsdf(vec3 p)
{
//	return sdf(p); 
	
	//for normals, add small bump displacements
	float d = sdf(p);
	
	float stripe = mod(p.y,2.);
	d -= smoothstep(0.,0.04,abs(stripe-1.)*0.5)*0.01;
		
#ifdef LOGO	
 	d -= lego(10.*(fract(p.xz*vec2(0.5/brick_w)+0.5)-0.5))*.05;
#endif
	
	return d;
}

// Function 3798
float abstract_glassy_field_map(inout vec3 _896)
{
    vec2 _907 = _238;
    _907.x = _896.x;
    vec2 _908 = _907;
    _908.y = _896.y;
    vec3 _898;
    abstract_glassy_field_camPath(_898, _896.z);
    vec2 _915 = _238;
    _915.x = _898.x;
    vec2 _916 = _915;
    _916.y = _898.y;
    vec2 _923 = _238;
    _923.x = _908.x - _916.x;
    vec2 _924 = _923;
    _924.y = _908.y - _916.y;
    vec2 _899 = _924;
    abstract_glassy_field_Vec3_assign_xy(_899, _896);
    vec3 _933 = _240;
    _933.x = _896.x * 0.314999997615814208984375;
    vec3 _934 = _933;
    _934.y = _896.y * 0.314999997615814208984375;
    vec3 _935 = _934;
    _935.z = _896.z * 0.314999997615814208984375;
    vec3 _942 = _240;
    _942.x = _935.x * 1.25;
    vec3 _943 = _942;
    _943.y = _935.y * 1.25;
    vec3 _944 = _943;
    _944.z = _935.z * 1.25;
    vec3 _949 = _240;
    _949.x = _896.z;
    vec3 _950 = _949;
    _950.y = _896.x;
    vec3 _951 = _950;
    _951.z = _896.y;
    vec3 _958 = _240;
    _958.x = _951.x * 0.875;
    vec3 _959 = _958;
    _959.y = _951.y * 0.875;
    vec3 _960 = _959;
    _960.z = _951.z * 0.875;
    vec3 _967 = _240;
    _967.x = _960.x * 1.25;
    vec3 _968 = _967;
    _968.y = _960.y * 1.25;
    vec3 _969 = _968;
    _969.z = _960.z * 1.25;
    vec3 _901 = _969;
    vec3 _900;
    abstract_glassy_field_Vec3_sin(_900, _901);
    vec3 _981 = _240;
    _981.x = _944.x + _900.x;
    vec3 _982 = _981;
    _982.y = _944.y + _900.y;
    vec3 _983 = _982;
    _983.z = _944.z + _900.z;
    vec3 _903 = _983;
    vec3 _902;
    abstract_glassy_field_Vec3_cos(_902, _903);
    _896 = _902;
    return (sqrt(((_896.x * _896.x) + (_896.y * _896.y)) + (_896.z * _896.z)) - 1.02499997615814208984375) * 1.33000004291534423828125;
}

// Function 3799
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
	// only use one face of cubemap (z+)
    if( rayDir.z<0.0 || abs(rayDir.x)>abs(rayDir.z) || abs(rayDir.y)>abs(rayDir.z)) discard;

    // Output to cubemap
    mainImage(fragColor,(rayDir.xy/rayDir.z*.5+.5)*Res0);
}

// Function 3800
float sphereSDF(vec3 samplePoint) {
    return length(samplePoint) - 1.0;
}

// Function 3801
float sdf_Q(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -6, 0), vec3(4, -8, 0)));
    return t;
}

// Function 3802
float remap01(float x, float a, float b)
{
	return ((x - a) / (b - a));   
}

// Function 3803
float mapSeed(vec2 uv)
{
    //uv = (uv + 1.)/2.;
    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);
    return min(LIGHT_DIST, length((floor(seedCoord)-floor(uv*iResolution.xy))/iResolution.x)-seedColor.z/60.);
    //return length(seedCoord/iResolution.xy-uv)-seedSize;
}

// Function 3804
int scene_raycast_objects( Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )
{
    int result = -1;
    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )
    {
        float to = t;
        vec3 N = ZERO;
        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );
        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );
        switch( int( obj.tybr.x ) )
        {
        case SCNOBJ_TYPE_PRIMITIVE:
        scene_obj_primitive( obj, localray, to, albedo, N );
        break;
        }
        if( to < t )
            result = i, t = to, out_N = obj.B * N;
    }
    return result;
}

// Function 3805
vec2 map(in vec3 p, bool frame) {
    vec2 res = vec2(0.0, p.y - fBm(p.xz));
    if (frame) {
        float d1 = sdBox(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec3(0.5, 0.0, 0.5));
        vec2 obj = vec2(1.0, max(d1, sdSphere(p - vec3(0.0, 1.0, 0.0), 0.5)));
        if (obj.y < res.y) res = obj;
    }
    float d2 = sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.055));
    float d3 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.055));
    float d4 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.112, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.055));
    vec2 obj = vec2(2.0, smin(smin(smin(sdTorus82(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec2(0.5, 0.05)), d2, 16.0), d3, 16.0), d4, 16.0));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.0, sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.1)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.1, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.122, 1.36, 0.35), -1.25), 3.14159), 0.84), vec2(0.025, 0.055)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.2, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.117, 1.36, -0.35), -1.25), 3.14159), -0.84), vec2(0.025, 0.055)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.3, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.162, 1.0, 0.49), -1.25), 3.14159), 1.6), vec2(0.025, 0.055)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.4, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.162, 1.0, -0.49), -1.25), 3.14159), -1.6), vec2(0.025, 0.055)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.5, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.1)));
    if (obj.y < res.y) res = obj;
    obj = vec2(3.6, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.115, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.1)));
    if (obj.y < res.y) res = obj;

    return res;
}

// Function 3806
float sdf_H(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));
    return t;
}

// Function 3807
RayHit GetDistancePlanet( vec3 origin, vec3 direction, int steps, float maxDist, inout vec3 hitPos)
{
  RayHit result;
  float dist = 1000000.;
  float precis = 0.0, t = 0.0;
  vec3 rayPos;

  for ( int i=0; i<steps+min(0, iFrame); i++ )
  {
    rayPos =origin+direction*t; 
    hitPos = rayPos;
    dist = min(dist, sdSphere(rayPos, 70.));
    t += dist;
  }

  result.hit=(dist<1.);
  result.depth = t; 
  result.dist.x = dist;  
  result.hitPos = origin+((direction*t)); 

  return result;
}

// Function 3808
float dist(vec3 p) {
    float d = p.y+fbm(p.xz);
    d = min(d, p.y+0.6);
    return d;
}

// Function 3809
void scene(in vec3 x, out vec2 d)
{
    d = c.xx;
    float dbound;
    dbox3(x,vec3(.33*c.xx, .2),dbound);
    float da, fac;
    dquadtree(x.xy-.1*iTime, .71, 5., da, fac);
    
    float p = pi/4.;
    vec2 cs = vec2(cos(p),sin(p));
    mat2 m = mat2(cs.x,cs.y,-cs.y,cs.x);
    vec2 y = m*x.xy;
    float da9, fac9;
    dquadtree(y-12.-.1*iTime, .41, 4., da9, fac9);
    smoothmin(da,da9,.01,da);
    
    float r;
    rand(202.*fac*fac9*c.xx+3., r);
    mat = r;
    zextrude(x.z,da,r*.3,da9);
    d.x = min(d.x,da9);
    
    stroke(da, .015, da);
    float db;
    stroke(da, .003, db);
   
    stroke(d.x,.003,d.x);
    dbox3(x,vec3(.33*c.xx, .02),da);
    d.x = min(d.x, da);
    d.x = min(d.x, db);
    
    d.x = max(d.x, dbound);
}

// Function 3810
float distBox(vec3 p, vec3 r){
  vec3 t = abs(p) - r;
  return length(max(t,0.0)) + min(max(t.x,max(t.y,t.z)),0.0);
}

// Function 3811
vec2 map (in vec3 pos, float sg) {
 	vec2 res = vec2(1e5,-1.);
 	vec3 p = pos;
    
    // set path(s) vector(s)
 	vec2 track = p.xy - path(p.z);
    vec3 q = vec3(track,p.z);
    
    float wv = 10.+7.*sin(T*.15);
    vec3 qt = vec3(track,p.z+travelSpeed+wv);
    qt.yz*=turn;
    qt.xz*=turn;
    vec3 r = vec3(abs(q.xy),q.z);

    vec2 ppd = pMirrorOctant(q.xy,vec2(.75),.75+.2*sin(p.z*.6+T*.8));
    float qiz = pMod(q.z,4.5);

    // fractal
    vec2 d1 = fragtail(q);
    if(d1.x<res.x) {
        res = d1;
        hit=q;
    }
    // beams
    float d4 = length(r.xy-vec2(1.25,.75)+.15*sin(p.z*.75-T*3.5))-.025;
    if(d4<res.x && sg > 0.) {
        res = vec2(d4,31.);
        hit=p;
    }

    vec2 d9=radio(qt);
    if(d9.x<res.x) {
        res = d9;
        hit=qt;
    }

    if(sg==1.) glow = clamp(0.,1.,glow+(.0002/(.0075+d4*d4)) );
    if(sg==2.) glow = clamp(0.,1.,glow+(.0001/(.0095+d4*d4)) );
    if(res.y==22. && sg==1.) glow = clamp(0.,1.,glow+(.0012/(.0075+res.x*res.x)) );
 	return res;
}

// Function 3812
maybe_float get_distance_along_3d_line_to_plane(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 N
){
    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);
}

// Function 3813
float sdf_Z(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(0, -8, 0)));
    return t;
}

// Function 3814
vec2 DistanceToObject(vec3 p)
{
    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills
    vec3 rep = p;
    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block
    vec2 distAndMat = CityBlock(rep, floor(p.xz));

    // Set up the cars. This is doing a lot of mirroring and repeating because I
    // only want to do a single call to the car distance function for all the
    // cars in the scene. And there's a lot of traffic!
    vec3 p2 = p;
    rep.xyz = p2;
    float carTime = localTime*0.2;  // Speed of car driving
    float crossStreet = 1.0;  // whether we are north/south or east/west
    float repeatDist = 0.25;  // Car density bumper to bumper
    // If we are going north/south instead of east/west (?) make cars that are
    // stopped in the street so we don't have collisions.
    if (abs(fract(rep.x)-0.5) < 0.35)
    {
        p2.x += 0.05;
        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees
        rep.xz = p2.xz;
        crossStreet = 0.0;
        repeatDist = 0.1;  // Denser traffic on cross streets
    }
    
    rep.z += floor(p2.x);	// shift so less repitition between parallel blocks
    rep.x = Repeat(p2.x - 0.5, 1.0);	// repeat every block
    rep.z = rep.z*sign(rep.x);	// mirror but keep cars facing the right way
    rep.x = (rep.x*sign(rep.x))-0.09;
    rep.z -= carTime * crossStreet;	// make cars move
    float uniqueID = floor(rep.z/repeatDist);	// each car gets a unique ID that we can use for colors
    rep.z = Repeat(rep.z, repeatDist);	// repeat the line of cars every quarter block
    rep.x += (Hash11(uniqueID)*0.075-0.01);	// nudge cars left and right to take both lanes
    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;
    frontBack *= sin(localTime*2.0 + uniqueID);
    rep.z += frontBack * crossStreet; // nudge cars forward back for variation
    vec2 carDist = Car(rep, uniqueID); // car distance function

    // Drop the cars in the scene with materials
    distAndMat = matmin(distAndMat, carDist);

    return distAndMat;
}

// Function 3815
float sdf_A(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -4, 0)));
    return t;
}

// Function 3816
float distTor(vec3 pos)
{
    vec4 q = vec4(0,0,0,1);
    q=multQuat(q,axAng2Quat(vec3(1,0,0),PI2*.125));
    q=multQuat(q,axAng2Quat(vec3(0,0,1),iTime*.5+2.));
    pos=transformVecByQuat(pos,q);
    
    pos+=.100*(noise3Dv4(pos*.015).xyz-.5);
    pos+=.050*(noise3Dv4(pos*.030).xyz-.5);
    pos+=.025*(noise3Dv4(pos*.060).xyz-.5);
    float d=torusDist(pos+vec3(.33,0,0),.66,.25);
    d=min(d,torusDist((pos-vec3(.33,0,0)).xzy,.66,.25));
    return d;
}

// Function 3817
SDResult sceneDist(in Ray ray) {
    SDResult result;
    //float fDist = hmDist(ray);
    float sDist = bumpSphere(ray, Sphere(vec3(0,5,0), 5.0));
    result.d = sDist;//unionOp(fDist, sDist);
    result.material = kMATTEMATERIAL;
    
    return result;
}

// Function 3818
float sdf_Options(vec2 p)
{
    const float
        OFFSET_P = 15.,
        OFFSET_T = 35.,
        OFFSET_I = 53.,
        OFFSET_O = 63.,
        OFFSET_N = 81.,
        OFFSET_S = 98.;

    vec4 box = vec4(0);
    vec3 disk1 = vec3(0), disk2 = vec3(0,0,1), disk3 = vec3(0,0,2);
    float vline_x = 1e3, vline_thickness = 2.5;
    float max_ydist = 6.;
    
    p.x -= 15.;
    
	#define MIRROR(compare, midpoint, value) (compare <= midpoint ? value : midpoint*2.-value)
    
    if (p.x <= 20.)
    {
    	max_ydist = 7.;
        disk1 = vec3(MIRROR(p.x, 8.5, 7.5), 11.5, 8.);
        disk2 = vec3(MIRROR(p.x, 8.5, 12.), 11.5, 9.);
    }
    else if (p.x <= OFFSET_T)
    {
        p.x -= OFFSET_P;
        vline_x = 9.;
        disk1 = vec3(14.5, 13.5, 4.);
        disk2 = vec3(10.5, 13.5, 5.);
    }
    else if (p.x <= OFFSET_I)
    {
        const float
            BOX_X = 4., BOX_Y = 15.5, BOX_SIZE = 1.5,
            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y-BOX_SIZE, R3 = BOX_SIZE * 2.;
        
        p.x -= OFFSET_T;
        disk3 = vec3(MIRROR(p.x, 9., X3), Y3, R3);
        box   = vec4(MIRROR(p.x, 9., BOX_X), BOX_Y, BOX_SIZE, BOX_SIZE);
        vline_x = 9.;
    }
    else if (p.x <= OFFSET_O)
    {
        vline_x = OFFSET_I + 4.5;
    }
    else if (p.x <= OFFSET_N)
    {
        p.x -= OFFSET_O;
        disk1 = vec3(MIRROR(p.x, 9., 8.), 11.5, 7.);
        disk2 = vec3(MIRROR(p.x, 9., 12.), 11.5, 8.);
    }
    else if (p.x <= OFFSET_S)
    {
        p.x -= OFFSET_N;
        vline_x = p.x < 9. ? 4.5 : 15.;
        vline_thickness = 2.;
        box = vec4(clamp(p.x, 5., 14.) * vec2(1, -.75) + vec2(0, 18), 1., 2.);
    }
    else
    {
        const float
            X1 = 8., Y1 = 14., R1 = 3.5,
            X2 = 9.5, Y2 = 15.5, R2 = 2.5,
            BOX_X = 6., BOX_Y = 7., BOX_SIZE = 1.5,
            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y+BOX_SIZE, R3 = BOX_SIZE * 2.;
        
        p.x -= OFFSET_S;
        // TODO: simplify
        if (p.x < 9.)
        {
            disk1 = vec3(X1, Y1, R1);
            disk2 = vec3(X2, Y2, R2);
            disk3 = vec3(X3, Y3, R3);
            box   = vec4(BOX_X, BOX_Y, BOX_SIZE, BOX_SIZE);
        }
        else
        {
            disk1 = vec3(18. - X1, 23. - Y1, R1);
            disk2 = vec3(18. - X2, 23. - Y2, R2);
            disk3 = vec3(18. - X3, 23. - Y3, R3);
            box   = vec4(18. - BOX_X, 23. - BOX_Y, BOX_SIZE, BOX_SIZE);
        }
    }
    
    #undef MIRROR
    
    float dist;
    dist = sdf_disk(p, disk1.xy, disk1.z);
    dist = sdf_exclude(dist, sdf_disk(p, disk2.xy, disk2.z));
    
    dist = sdf_union(dist, sdf_seriffed_box(p, vec2(vline_x, 5.5), vec2(vline_thickness, 12.), vec2(1,.2), vec2(1,.2)));
                       
	float d2 = sdf_centered_box(p, box.xy, box.zw);
    d2 = sdf_exclude(d2, sdf_disk(p, disk3.xy, disk3.z));
    dist = sdf_union(dist, d2);
    dist = sdf_exclude(dist, max_ydist - abs(p.y - 11.5));
   
    return dist;
}

// Function 3819
int IntersectScene(Ray ray, int ignoreObjId, out float out_t, out Object out_obj)
{
	int id = OBJ_ID_NONE;
	out_t = 1e5;
	out_obj = objects[0]; // none
	for (int i = 0; i < NUM_OBJECTS; i++) {
		Object obj = objects[i];
		float t = IntersectObject(ray, obj);
		if (i != ignoreObjId && t != 0.0 && t < out_t) {
			id = i;
			out_t = t;
			out_obj = obj;
		}
	}
	return id;
}

// Function 3820
float map( in vec3 pos )
{
    return sd (pos.zxy);
}

// Function 3821
vec3 scene_lighting_terrain( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,
                             vec3 sky, vec2 shadow )
{
#if WITH_ILLUM_TEST
    float mu0 = max( 0., dot( N, L ) );
    return F * mu0 + sky;
#else
    float mu_0 = mu_stretch( dot( N, L ), .01 );
    float mu = mu_stretch( dot( N, V ), .01 );
    float cosi = dot( N, Z );
    float cosp = dot( L, V );
    vec3 kd = lunar_lambert( albedo, mu, mu_0 );
    float kl = phase_curve( cosp );
    float kj = cosi * .5 + .5;
    vec3 E = F * mu_0 * shadow.x;
    vec3 backbounce = .5 * albedo * F * shadow.y * mu_stretch( dot( N, -L ), .125 )
        * mu_stretch( dot( L, Z ), .005 );
    return E * kd * kl + albedo * ( sky * kj + backbounce );
#endif
}

// Function 3822
vec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )
{
  vec3 m = pow( abs(n), vec3(k) );
  vec4 x = textureLod( sam, p.yz ,0.4);
  vec4 y = textureLod( sam, p.zx ,0.4);
  vec4 z = textureLod( sam, p.xy ,0.4);
  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);
}

// Function 3823
vec3 Scene_Normal(vec3 p)
{
    RayHit hit;
    
    float e = Epsilon;
    
	return clamp(normalize(vec3(
        (Scene_SDF(vec3(p.x + e, p.y, p.z), hit) - Scene_SDF(vec3(p.x - e, p.y, p.z), hit)),
        (Scene_SDF(vec3(p.x, p.y + e, p.z), hit) - Scene_SDF(vec3(p.x, p.y - e, p.z), hit)),
        (Scene_SDF(vec3(p.x, p.y, p.z + e), hit) - Scene_SDF(vec3(p.x, p.y, p.z - e), hit)))), -1.0, 1.0);
}

// Function 3824
vec4 RenderScene(vec2 mUV, vec3 rayOrigin, vec3 rayDirection, inout rayIntersect rIntersec)
{
	rIntersec.mPos = vec3(0.0);
    rIntersec.mUV = mUV;
	rIntersec.nor = vec3(0.0);
	rIntersec.dist = 0.0;
	rIntersec.rd = rayDirection;
    
	// Opaque
    vec3 accum = RayMarchScene(rayOrigin, rIntersec);
    
    float fogFactor = EaseOutSine(rIntersec.dist / FARCLIP);
    
    vec4 colorResult = vec4(clamp(accum, 0.0, 1.0), fogFactor);
    
    return colorResult;
}

// Function 3825
Distance distance2(vec3 p)
{    
    
    Distance d = Distance(box(p - vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5)); 
    d = add(d, Distance(box(p + vec3(0.4, 0.0, 0.0), vec3(0.02, 0.4, 0.42)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p - vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p + vec3(0.0, 0.0, 0.4), vec3(0.42, 0.4, 0.02)), vec3(0.3, 0.7, 0.5))); 
    d = add(d, Distance(box(p + vec3(0.0, 0.4, 0.0), vec3(0.4, 0.02, 0.4)), vec3(0.3, 0.7, 0.5))); 
    
    return d;
}

// Function 3826
float o349467_input_sdf_a(vec3 p) {
    float o360551_0_1_sdf3d = for_min_o360551(vec4((rotate3d(((((p))/p_o538946_s)-vec3(p_o528578_x, p_o528578_y, p_o528578_z)), -vec3((iTime*21.0), (iTime*27.0), (iTime*23.0))*0.01745329251)),1.0));
    vec2 o512498_0_1_sdf3dc = vec2(o360551_0_1_sdf3d, 0.0);
    vec2 o528578_0_1_sdf3dc = o512498_0_1_sdf3dc;
    vec2 o538946_0_in = o528578_0_1_sdf3dc;vec2 o538946_0_1_sdf3dc = vec2(o538946_0_in.x*p_o538946_s, o538946_0_in.y);
    return (o538946_0_1_sdf3dc).x;
    }

// Function 3827
float sdf_window_emblem(vec2 uv)
{
    vec2 uv2 = vec2(min(uv.x, 1.-uv.x), uv.y);
	
    float sdf = sdf_centered_box(uv, vec2(.5, .25), vec2(.375, .1));
    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.36, .1), .15));
    
    float h = linear_step(.35, .8, uv.y);
    float w = mix(.27, .35, sqr(triangle_wave(.5, h))) + sqrt(h) * .15;
    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.5, .6), vec2(w, .26)));
    
    h = linear_step(.95, .6, uv.y);
    w = .6 - around(.9, .8, h) * .5;
    sdf = sdf_exclude(sdf, .75*sdf_centered_box(uv, vec2(.5, .75), vec2(w, .21)));
    
    // eyes
    sdf = sdf_exclude(sdf, sdf_line(uv2, vec2(.45, .4), vec2(.4, .45), .04));

    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.15, .2), .15));
	sdf = sdf_union(sdf, sdf_line(uv, vec2(.5, .125), vec2(.5, .875), .0625));
    return sdf;
}

// Function 3828
float map(vec3 p)
{	
// 	fractalscape 
    float f = -0.05-kifs(.4*p);
	if(meep==0) f+=0.002*noise(p*70.);
	return f;
}

// Function 3829
vec4 scene(vec2 uv)
{
	
	vec4 color = nyan(uv);
	vec3 c2 = background(uv+vec2(0,0));
	vec4 c3 = rainbow(vec2(uv.x+0.4,0.05-uv.y*2.0+.5));
	
	vec4 c4 = mix(vec4(c2,1.0),c3,c3.a);
		
	color = mix(c4,color,color[3]);
	return color;
}

// Function 3830
float linedist (vec3 p, vec3 a, vec3 b) {
  float k = dot(p-a,b-a)/dot(b-a,b-a);
  return distance(p,mix(a,b,clamp(k,0.,1.)));
}

// Function 3831
float distPlane( vec3 pos ) {
    return pos.y;
}

// Function 3832
float mapBk( in vec3 pos )
{
    float l = length(pos.xz);
    float f = smoothstep( 1000.0, 1500.0, l );

    float h = 200.0*f*texture( iChannel2, 0.001 + 0.00003*pos.xz ).x;

    return pos.y-h;
}

// Function 3833
float textSDF( vec2 p, float glyph )
{
    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;
    return 2. * ( texture( iChannel3, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );
}

// Function 3834
float sdf_circle(vec2 pos, vec2 circle_pos, float circle_r) {
	return length(pos - circle_pos) - circle_r;
}

// Function 3835
float ringSDF(vec3 p, vec2 t)
{
  vec2 q = vec2(length(p.yz)-t.y,p.x);
  return length(q)-t.x;
}

// Function 3836
float map(vec3 p)
{
    float de_partic = DE(p); 
    de_partic = min(de_partic, sdPlane(p, vec4(0,0,1,0)));
    return min(de_partic, sdLineBox(p - size3d*0.5, size3d*0.5, 0.5));
}

// Function 3837
void sceneMap3D(vec3 pos, out float t, out int obj)
{
    t = plane(pos, vec4(1.0, 0.0, 0.0, 0.0));
    float t2;
    obj = OBJ_RIGHTWALL; // 0 is center sphere
    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 556.0))) < t) {
        t = t2;
        obj = OBJ_LEFTWALL;        
    }
    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 0.0))) < t) {
        t = t2;
        obj = OBJ_FLOOR;
    }
    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 548.8))) < t) {
        t = t2;
        obj = OBJ_CEILING;
    }
    if((t2 = plane(pos, vec4(0.0, 0.0, -1.0, 559.2))) < t) {
        t = t2;
        obj = OBJ_BACKWALL;
    }
    int blockType;
    float blockDepth = mapBlocks(pos, blockType);
    if(blockDepth < t)
    {
        t = blockDepth;
        obj = blockType;
    }

}

// Function 3838
float map_glass(vec3 pos)
{
    #ifdef show_glass
    pos = rotateVec2(pos);
    pos+= glassPos;

    #ifdef bumped_glass
    pos+= getGlassBump(pos);
    #endif
    
    #ifdef show_plate
    pos.y-= -0.153 + plateThickness*2.;
    #endif
    
    pos*= 0.88;
    
    vec3 pos2 = pos + vec3(0., 0.37, 0.);
    vec3 pos3 = pos + vec3(0., 0.388, 0.);
    vec3 pos4 = pos + vec3(0., 0.73, 0.);
    vec3 pos5 = pos + vec3(0., 0.34, 0.);
    
    float s1 = length(pos*vec3(1., 0.95, 1.) + vec3(0., -0.1, 0.)) - 0.3;
    s1 = mix(s1, length(pos.xz) - 0.34 + pos.y*0.3, smoothstep(-0.15, 0.28, pos.y));
    float dt = 0.004 * smoothstep(0.368, 0.38, pos.y);
    s1-= dt;
    float s2 = map_glass_int(pos);
    
    float df = max(s1, -s2);
    df = SoftMaximum(df, pos.y - 0.39, 80.);
    
    float gsd = 0.04*(0.45 + 6.*pos.y*pos.y);
    df = smin(df, sdCylinder(pos2, vec2(gsd, 0.14)), 27.);
    float gfd = 0.19 - clamp(4.*pos2.y, -0.1, 0.5);
    df = smin(df, sdCylinder(pos3, vec2(gfd, 0.07)), 15.);
    df = SoftMaximum(df, -pos2.y - 0.15, 9.);
    df = smin(df, sdCylinder(pos5, vec2(0.07, 0.01)), 70.);
    df = SoftMaximum(df, -length(pos4) + 0.33, 28.);  
    
    #ifdef dev_mode
    df = max(df, pos.z);
    #endif 
    
    return df;
    #else
    return 10.;
    #endif
}

// Function 3839
float distortion(const in float s, const in float d) {
	return clamp(s * d, -1.0, 1.0);
}

// Function 3840
vec2 Map(vec3 pos) {
	vec2 accm;
    float td = cylXY(pos-vec3(0, 0, TREE_trunk), vec2(1, TREE_trunk)),
        sd = Star(pos-vec3(0, 0, 2.*TREE_trunk + TREE_sepr*float(TREE_rings) ));
    if (td < sd)
        accm = vec2(td, -1);
    else
        accm = vec2(sd, -2);
    
    pos.z -= TREE_trunk*2.;
    for (int i = 0; i < TREE_rings; i++) {
        mat3 mat = euler(vec3(
            rand(i, 0)*pi/12.,
            rand(i, 1)*2.*pi,
        	0));
        float ring = cylXY(pos*mat, vec2(TREE_rad*float(TREE_rings-i), TREE_thick));
    	if (accm.x > ring)
            accm = vec2(ring, rand(i, 10));
        pos.z -= TREE_sepr;
    }
    
    return accm;
}

// Function 3841
vec3 mapH( in vec2 pos )
{
	vec2 fpos = fract( pos ); 
	vec2 ipos = floor( pos );
	
    float f = 0.0;	
	float id = hash( ipos.x + ipos.y*57.0 );
	f += freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 );
	f += freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 );
	f += freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 );
	f += freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 );

    f = pow( clamp( f, 0.0, 1.0 ), 2.0 );
    float h = 2.5*f;

    return vec3( h, id, f );
}

// Function 3842
hit traceScene(in ray r) {
    //trace objects
    hit ret = lt(tracePlane(r, pln1),
                 tracePlane(r, pln2));
    ret = lt(ret,tracePlane(r, pln3));
    ret = lt(ret,tracePlane(r, pln4));
    ret = lt(ret,tracePlane(r, pln5));
    ret = lt(ret,traceSphere(r, lit1));
    ret = lt(ret,traceSphere(r, lit2));
    ret = lt(ret,traceSphere(r, lit3));
    ret = lt(ret,traceSphere(r, sph1));
    ret = lt(ret,traceSphere(r, sph2));
    ret = lt(ret,traceSphere(r, sph3));
    ret = lt(ret,traceBox(r, box1));
    ret = lt(ret,traceBox(r, box2));
    ret = lt(ret,traceBox(r, box3));
	//mirror normal if needed
    float nmod = step(dot(r.d, ret.n), 0.)*2.-1.;
    ret.n *= nmod;
    return ret;
}

// Function 3843
float map(float value, float low1, float high1, float low2, float high2){
	return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
}

// Function 3844
float distf2(int world, vec3 p, inout float m)
{
	float d = 0.0;
	m = 0.0;
	
	if (world == 0) {
		d = 16.0 + p.z;
		m = 1.0;
		
		fUnionMat(d, m, pSphere(vec3(24,22,4) + p, 12.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(6,-35,4) + p, vec3(4,4,11), 1.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(19,-15,0) + p, vec3(4,4,15), 1.0), 4.0);
		fUnionMat(d, m, pRoundBox(vec3(-12,20,12) + p, vec3(7,7,7), 1.0), 4.0);
	} else {
		d = 16.0 + p.z;
		m = 2.0;
		
		fUnionMat(d, m, pRoundBox(vec3(15,35,6) + p, vec3(4,12,9), 1.0), 5.0);
		fUnionMat(d, m, pRoundBox(vec3(-10,35,10) + p, vec3(15,3,5), 1.0), 5.0);
		fUnionMat(d, m, pRoundBox(vec3(15,-35,6) + p, vec3(12,6,15), 1.0), 5.0);
	}
	
	return d;
}

// Function 3845
float getSdf(vec3 p) {
  float f = sdImplicitSurface(p);
  for (int i = 0; i < 6; i++) {
    float t = float(i) + iTime;
    f = min(f, sdBox(
        p - vec3(
            3.0 + 3.0 * cos(t * 3.141592 / 3.0), 
            0, 
            3.0 * sin(t * 3.141592 / 3.0)),
        vec3(0.5)));
  }
  return f;
}

// Function 3846
vec3 Tonemap_ACES(const vec3 x)
{
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// Function 3847
float sdf_P(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));
    return t;
}

// Function 3848
vec3 trn_ripplemap( vec3 pos )
{
    return .20 * texturenoise( pos / .01 ).xyz +
           .30 * texturenoise( pos / .003 ).xyz +
           .30 * texturenoise( pos / .001 ).xyz +
           .20 * texturenoise( pos / .0003 ).xyz;
}

// Function 3849
float scene(vec3 p)
{
    return min(
        sdFloor(p),
        sdSpinningBox(p)
    );
}

// Function 3850
void PaintDistanceTrees(inout vec3 col, in vec2 uv, in float terrainHeight, float seed, float aspectRatio)
{
   vec2 uv_bush_i = floor(uv * vec2(15., 1.));
   vec2 uv_bush_f = fract(uv * vec2(15., 1.));
        uv_bush_f.y = uv_bush_f.y - terrainHeight;
        uv_bush_f.y *= 15. * aspectRatio;
  
   float threshold = 0.3;
   float shoulDraw = step(0.4, rand(uv_bush_i.x +1. + seed));
         threshold-=  shoulDraw;
         
         float treeCenterY = (rand((uv_bush_i.x+seed)*65.)*2.0-1.0) * 0.4;
         
         vec2 toTreeCenter = vec2(0.5, treeCenterY) - uv_bush_f;
         
         float randOne = rand(seed*251.221 + uv_bush_i.x*2.521);
   float f         = length(toTreeCenter);
   float angle     = fract(atan(toTreeCenter.y, toTreeCenter.x) / TAU + 0.5 + 0.25);
   float dis       = GetFarTreeDisplacement(angle, 
                     6.+randOne*10.,
                     0.2,  seed + uv_bush_i.x);
         f        -= dis * distanceOnNormalizedAngle(angle, 0.);
   
   float sinOne = sin((uv_bush_f.x + seed *82.12+ uv_bush_i.x*10.67) *35.);
   float colorFactor = abs(noise(uv_bush_f*2.
   + vec2(0., sinOne*0.1 )));
   
   colorFactor +=  smoothstep(treeCenterY+0.1, treeCenterY-0.3, uv_bush_f.y  + sinOne*0.01);
   
  vec3 bushColor  = mix( bush_color_far, bush_color_far2, colorFactor);
  
    // Draw trunk
    
    float thickness = abs(sin(angle*12. + seed*6.21 + uv_bush_i.x*5.214 + uv.y*30.));
    
    DrawBetweenTwoPoints(vec2(0.5, treeCenterY), vec2(0.5, treeCenterY-0.5),
    uv_bush_f + vec2(0., 0.), 0.005 - shoulDraw + thickness*0.03 , mix(d_tree_outline, bush_color_far, 0.25), col);
    
    // Draw inner leaves
    
    
    float coord_leaves =  distance(uv_bush_f, vec2(0.5, treeCenterY-0.5))*5.;
    float coord_l_i    = floor(coord_leaves);
          coord_leaves = fract(coord_leaves);
    float sinTwo   = sin(uv_bush_f.x *82. + randOne *65.61+ coord_l_i*82.21);
    float sinThree = sin(uv_bush_f.x *10. + randOne *65.61+ coord_l_i*52.21);
          coord_leaves = abs(coord_leaves - 0.5 + sinTwo*0.05+ sinThree*0.4);
          coord_leaves = aaStep(-0.031, coord_leaves  + sinThree*0.1);
    bushColor = mix(bush_color_far2,bushColor, coord_leaves);
    
      bushColor = mix(bushColor, paper_color ,  pow(texture(iChannel0,uv*3.).x,6.));
    
   DrawWithOutline(col, bushColor, d_tree_outline, threshold, f,
   0.008 + thickness*0.01);
   
   
   
}

// Function 3851
vec3 map( vec3 p )
{
    vec3 res=vec3( 1000000, -2, -1 );
    
    #if (SHAPE == 0)
    res=opU( res, vec3( p.z, 0, 0 ) );
    #elif (SHAPE == 1)
    res = opU( res, vec3( length( p ) - 1.0, 0, 0 ) );
    #elif (SHAPE == 2)
    vec2 h = vec2( 0.95, 0.8 ); vec2 d = abs(vec2(length(p.xz),p.y)) - h; 
    res=opU( res, vec3( min(max(d.x,d.y),0.0) + length(max(d,0.0)), 0, 0 ) );
    #elif (SHAPE == 3)
    vec3 tp=p;tp.zxy=opTwist( tp.zxy, 2.531 );
    res=opU( res, vec3( length( max( abs(tp) - vec3( 0.213 * 3.0, 0.978 * 3.0, 0.213 * 3.0 ), 0.0 ) ) - 0.10, 0, 0 ) );
    #elif (SHAPE == 4)
    res=opU( res, vec3( p.y + 1.5, 0, 0 ) );
    #endif

#if (DISPLACEMENT == 1)
    vec3 normal; Material material; 
    material0( p, normal, 0., material ); 
    res.x -=material.bump/50.;
#endif
    res = opU( res, vec3( length( p - LIGHT1_POS ) - 1.0, 2, 2 ) );

    return res;
}

// Function 3852
float fetch_lightmap_texel(ivec2 addr)
{
    addr = clamp(addr, ivec2(0), ivec2(LIGHTMAP_SIZE) - 1);
    int channel = addr.y & 3;
    addr.y >>= 2;
    return decode_lightmap_sample(texelFetch(iChannel1, addr, 0)).values[channel];
}

// Function 3853
float PrECapsDf (vec3 p, float r, float h)
{
  return length (p - vec3 (0., 0., clamp (p.z, 0., h))) - r;
}

// Function 3854
float getDistToObjects( vec3 camPos, vec3 rayDir ) {
    float delta = startDelta;
    float maxDist = 0.002;
    
    for( int i = 0; i < MAX_ITERATIONS; i++ ) {
        float dist = computeDist( camPos + rayDir * delta );
        if( dist <= maxDist || dist > stopDelta )
            break;
        delta += dist;
    }
    
    return delta;
}

// Function 3855
float BoxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - 0.2;
}

// Function 3856
vec4 scene_dist(vec3 p) {
        float obj_dist = 10000.0;
        vec3 obj_color = vec3(1.0);
        int s = 0;
        float minDist = 10000.0;
        for(int r= 0; r < shifters.length(); r++) {
            float dist = length(p - shifters[r].position); 
            if (dist < minDist) {
                s = r;
                minDist = dist;
            }
        }
        //for(int s = 0; s <= shifters.length(); s++) {
        float s_dist = 0.0;
        /*if (length(p - shifters[s].position) > 5.0) {
            continue;
        }*/
        //float boxDist = length(shifters[s].position - p); //sdBox(p, shifters[s].position, vec3(1.0, 1.0, 1.0));
        //if (boxDist > obj_dist) {
            //continue;
        //}
       /*if (sdDiamond(p, shifters[s].position, 2.5) > obj_dist) {
            continue;
        }*/
        /*if (time_period < 3.14 * 2.0) {
            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdTorus(p, vec3(0.0, (sin(time / 1000.0)), 0.0) + 0.05, vec2(1.0, 0.1)), (sin(time / 1000.0) + 1.0) / 2.0);
        } else if (time_period < 3.14 * 4.0) {
            obj_dist = mix(sdBox(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), vec3(1.0, 1.0, 1.0)), sdSphere(p, vec3(0.0, ((sin(time / 1000.0) + 1.0) / 2.0), 0.0), 1.0), (sin(time / 1000.0) + 1.0) / 2.0);
        }*/
        float time_period = mod(iTime + shifters[s].timeOffset, 5.0);
        if (time_period <= 1.0) {
            s_dist = mix(sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), time_period);
        } else if (time_period <= 2.0) {
            s_dist = mix(sdTorus(p, shifters[s].position, vec2(1.0, 0.2)), sdSphere(p, shifters[s].position, 1.0), time_period - 1.0);
        } else if (time_period <= 3.0) {
            s_dist = mix(sdSphere(p, shifters[s].position, 1.0), sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0), time_period - 2.0);
        } else if (time_period <= 4.0) {
            s_dist = mix(sdCone(p, shifters[s].position, vec2(0.5, 0.5), 1.0),  sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)), time_period - 3.0);
        } else if (time_period <= 5.0) {
            s_dist = mix(sdBox(p, shifters[s].position, vec3(0.9, 0.9, 0.9)),sdBoxFrame(p, shifters[s].position, vec3(0.9, 0.9, 0.9), 0.25), time_period - 4.0);
        }
       //s_dist = sdSphere(p, shifters[s].position, 1.0);
            obj_dist = s_dist;
            obj_color =  shifters[s].color;
    //}
        float ground_dist = sdBox(p, vec3(0.0, -1.0, 0.0), vec3(9.5, 0.0, 9.5));
        vec3 color;
        if (ground_dist < obj_dist) {
            color = vec3(0.75);
            if (mod(round(p.x), 2.0) == mod(round(p.z), 2.0)) {
                color = vec3(0.1);
            }
        } else {
            color = obj_color;
        }
        return vec4(min(ground_dist, obj_dist), color);
    }

// Function 3857
float sceneSDF(vec3 p) {
    p /= scale;
    float result = 1.1+dunes(p,10.0)/5.0+max(planet_surface(p),-min(sceneSDF2(p/7.0),min(sceneSDF2(p.xzy/11.0),sceneSDF2(p/13.0))));
    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));
    return result*scale;
}

// Function 3858
vec4 mapping(float dist, float min, float max){	
	
	float distLut = (dist - min) / (max - min);
	int i1;
	for(int i=0;i <NB_LUT;++i){
		if(distLut < LUT_DIST[i+1]){i1 = i;break;}
	}
	vec4 col1,col2;
	float mixVal;
	if		(i1 == 0){
		col1 = LUT[0];col2 = LUT[1];
		mixVal = (distLut - LUT_DIST[0]) / (LUT_DIST[1] - LUT_DIST[0]);
	}else if(i1 == 1){
		col1 = LUT[1];col2 = LUT[2];
		mixVal = (distLut - LUT_DIST[1]) / (LUT_DIST[2] - LUT_DIST[1]);
	}else{
		col1 = LUT[2];col2 = LUT[3];
		mixVal = (distLut - LUT_DIST[2]) / (LUT_DIST[3] - LUT_DIST[2]);
	}
	
	
	//return vec4(mixVal);
	return mix(col1,col2,mixVal);
	
}

// Function 3859
vec3 cubemapRayDir(in vec2 fragCoord, vec2 bufferSize) 
{     
    bufferSize.y = min(bufferSize.y, bufferSize.x*0.66667 + 4.0);
    
    float ts = (bufferSize.y - 2.0) * 0.5;
    
    fragCoord = min(fragCoord, 
                    vec2(ts*3.0 - 1.0, 2.0*ts + 1.0));
    
    vec2 tc = vec2(fragCoord.x / ts, 
                   fragCoord.y*2.0 / bufferSize.y); 
    
    vec2 ti = floor(tc) - vec2(1.0, 0.0);
    vec3 n = -vec3((1.0 - abs(ti.x))*(ti.y*2.0 - 1.0), 
                   ti.x*ti.y, ti.x*(1.0 - ti.y));

    float bpy = min(0.9999, fragCoord.y / ts);
    float tpy = max(1.0, (fragCoord.y - 2.0) / ts);

    vec2 p = fract(vec2(tc.x, (bpy * (1.0 - floor(tc.y)) 
                               + tpy * floor(tc.y)))) - 0.5;
    
    vec3 px = vec3(0.5*n.x, p.y, -p.x*n.x) * step(0.5, n.x)
              + vec3(0.5*n.x, -p.x, -p.y*n.x) * step(n.x, -0.5);
    vec3 py = vec3(-p.x*n.y, 0.5*n.y, p.y) * abs(n.y);
    vec3 pz = vec3(p.x*n.z, p.y, 0.5*n.z) * abs(n.z);
    
    return normalize(px + py + pz);
}

// Function 3860
float sdfCircle(vec2 pnt, vec2 center, float radius) {
  return length(pnt - center) - radius;
}

// Function 3861
vec3 map( vec3 p )
{
    vec2 id = floor( (p.xz+1.0)/2.0);
    p.xz = mod( p.xz+1.0, 2.0 ) - 1.0;
    
    float ph = sin(0.5 + 3.1*id.x + sin(7.1*id.y));
    
    p.xz += 0.5*sincos(1.0+0.5*iTime+(p.y+11.0*ph)*0.8);

    vec3 p1 = p; p1.xz += 0.15*sincos(1.0*p.y-1.0*iTime+0.0);
    vec3 p2 = p; p2.xz += 0.15*sincos(1.0*p.y-1.0*iTime+2.0);
    vec3 p3 = p; p3.xz += 0.15*sincos(1.0*p.y-1.0*iTime+4.0);
    
    vec2 h1 = sdCylinder(p1);
    vec2 h2 = sdCylinder(p2);
    vec2 h3 = sdCylinder(p3);
    
    return opU( opU( vec3(h1.x-0.12,                                         ph + 0.0/3.0, h1.y), 
                     vec3(h2.x-0.12-0.05*cos( 500.0*h2.y - iTime*4.0), ph + 1.0/3.0, h2.y) ), 
                     vec3(h3.x-0.12-0.02*cos(2000.0*h3.y - iTime*4.0), ph + 2.0/3.0, h3.y) );
}

// Function 3862
float sdfSmoothBlend(vec3 p, float sdf1, float sdf2, float k) {
    float h = max(k - abs(sdf1 - sdf2), 0.f) / k;
    float sdf = min(sdf1, sdf2) - h * h * k * (.25f);
    return sdf;
}

// Function 3863
float BoxSDF(vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return length(max(d,0.0)) +
        	min(max(d.x,max(d.y,d.z)),0.0);
}

// Function 3864
float map( in vec3 p )
{
	vec3 q = p - vec3(0.0,0.5,1.0)*iTime;
    float f = fbm(q);
    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;
    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;
    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;
    float s3 = 1.0 - smin(smin(
                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),
                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),
                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;
    
    float t = mod(stepUp(iTime, 4.0, 1.0), 4.0);
    
	float d = mix(s1, s2, clamp(t, 0.0, 1.0));
    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));
    d = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));
    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));
    
	return min(max(0.0, d), 1.0);
}

// Function 3865
vec3 doBumpMap( in vec3 pos, in vec3 nor, float amount )
{
    float e = 0.0015;
    float b = 0.01;

    float ref = fbm( 48.0*pos, nor );
    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;
	
	vec3 tgrad = gra - nor * dot ( nor , gra );
    return normalize ( nor - amount*tgrad );

	
}

// Function 3866
float exteriorSDF(in vec3 p, inout int material)
{
    float d = 1e10;
    
    // stand for the globe
    if (true) {
    	const float h = 1.;
    	const float r = 2.2;
    	const float r0 = r + 1.;
    	const float r1 = r + .8;

        d = sdCone(p - vec3(0, -3., 0), h, r0, r1) - .2;
        material = MAT_STAND;
    }
    
    // musix box handle
    if (true) {
        /*
        float sdCapsule( vec3 p, vec3 a, vec3 b, float r );
        float sdHorizontalCapsule( vec3 p, float h, float r );
        float sdVerticalCapsule( vec3 p, float h, float r );
        float sdCappedXCylinder( vec3 p, vec2 h );
        float sdCappedYCylinder( vec3 p, vec2 h );
        float sdCappedZCylinder( vec3 p, vec2 h );
		*/

        const float r = .08;
        float t = 5. * iTime;
        vec3 h = .4 * vec3(sin(t), cos(t), 0);

        float d_handle =       sdZCapsule(p - vec3(0., -2.5, 3.0), .6, r);        
        d_handle = min(d_handle, sdCapsule(p, vec3(0., -2.5, 3.6), vec3(0., -2.5, 3.6) + h, r));
        d_handle = min(d_handle, sdCapsule(p, vec3(0., -2.5, 3.6) + h, vec3(0., -2.5, 3.6 + .4) + h.xyz, r));
        
        if (d_handle < d) {
            d = d_handle;
            material = MAT_METAL;
        }
    }

    // ground
    if (true) {
        const float r = 75.;
    	const float spread = 4.5;
        const float k = 130.;

        p.y += -3.;
        
        float d_ground = 1e10;
    	d_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3( 17.,  0,  20.)) - r + 12., k);
    	d_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3( 21.,  0, -19.)) - r +  1., k);
    	d_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3(-18.,  0,  15.)) - r +  1., k);
    	d_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3(-15.,  0, -16.)) - r + 20., k);
        
        // one central sphere touching/intersecting slightly with the foot of the snow globe
        d_ground = smin(d_ground, length(p + vec3(0, 12., 0)) - 12. + 10., 10.);
        
        if (d_ground < d) {
            d = d_ground;
            material = MAT_SNOW;
        }
    }
    
    // snow on top of globe
    if (true) {
        const float yoff = 2.6;
        
        float d_cap = opSmoothSubtraction(
            smin(length(p + vec3(-.2, yoff + .8, .0)) - 4.5,
                 length(p + vec3( .1, yoff + .9, .1)) - 4.5,
                 .05),
            length(p + vec3(0, yoff, 0)) - 4.5,
            2.) - .15;

        if (d_cap < d) {
        	d = d_cap;
        	material = MAT_SNOW;
    	}
    }
    
    return d;
}

// Function 3867
float getSphereMappedTexture(in vec3 pointOnSphere)
{
    /* Test to determine which face we are drawing on.
     * Opposing faces are taken care of by the absolute
     * value, leaving us only three tests to perform.
     */
    vec2 st = (
        insideBounds(sphereToCube(pointOnSphere)) +
        insideBounds(sphereToCube(pointOnSphere.zyx)) +
        insideBounds(sphereToCube(pointOnSphere.xzy)));
    
    st *= 12.0;
    float k = GetWaveDisplacement(vec3(st.x,0.0,st.y))*0.5;
    k = clamp(k,0.0,1.0);
	return 1.0-k;
    //return textureFunc(st);
}

// Function 3868
poly2 pa_map(poly2 x, poly2 y, poly2 z) {
	poly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));
    poly2 vz = pa_sub(z,sin(iTime*0.3)*0.4);
	poly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);
	poly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);
	//poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);
    poly2 rx, rz;
    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,iTime*0.5);
    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));
    poly2 cb = cube(rx,y,pa_add(rz,-0.5),0.2);
    
    poly2 d = w;
    poly2 g = pa_hardmax(s,pa_unm(s2));
    d = pa_smin(d, cb, 0.1);    
    d = pa_hardmin(d,g);
    d = pa_hardmin(d, c);    
    
	return d;
}

// Function 3869
float fixDistance (in float d, in float correction, in float k) {
	correction = max (correction, 0.0);
	k = clamp (k, 0.0, 1.0);
	return min (d, max ((d - DELTA) * k + DELTA, d - correction));
}

// Function 3870
float mapWDists(vec3 p, out vec3 dists) {
  mat3 r1 = rot3XY(u_time, 3), r2 = rot3XY(u_time * .48597, 1);
  // r1 = rot3XY(u_time * .0, 3), r2 = rot3XY(u_time * .763 * .0, 2);
  vec4 boxEdges = sldBoxEdges((p - vec3(0.4, 1.0 , 0)) * r2 * r2 * r1, vec3(.3)) - .01;
  vec4 box = sldBox(p * r2 * r1, vec3(.3)) - .01;
  vec4 tri = sdTriangle2((p - vec3(-.4, -.9, 0)) * r2 * r1, .3) - .01;
  vec4 tri2 = sdTriangle1((p - vec3(.4, -1.4, 0)) * r2 * r1, .3) - .01;
  vec4 tet;
  tet.x = sdTetrahedron((p - vec3(.4, 1.9, 0)) * r2 * r1, .3, tet.yzw) - .01;

  vec4 tri3;
  tri3.x = sdTriangleGen((p - vec3(.5, 1.9, 0)) * r2 * r1, .3, tri3.yzw) - .01;

  vec4 m = minWith(boxEdges, vec4(999.));
  m = minWith(m, tri2);

  if (HIGH_RESOURCES == 1) {
    m = minWith(m, box);
    m = minWith(m, tri);
  }

  dists = m.yzw;
  return m.x;
}

// Function 3871
float map(vec3 p)
{
    vec3 q=p;
    p=kifs(p);
    float d1=abs(p.y+1.5);
    
    obj=1;
    
    float d=d1;
    d-=tri_surf(p)*0.2;
    
    vec3 r=q;
    r.xz=abs(r.xz*rot(2.*iTime))-1.9;    
    r.yz=abs(r.yz*rot(2.*iTime))-1.9;

    float d3=oct(r,0.5);
    d=min(d,d3);
    
    float d0=core(q);
    if(d0<d){obj=0;d=d0;}

    return d*0.8;
}

// Function 3872
vec2 sceneK(vec3 start,vec3 end,vec3 dir)
{
    float dist = 0.0;
    dist = scene(start);
    
    vec3 gs = calcGradient(start);
    vec3 ge = calcGradient(end);
    //vec3 gs = calcGradientCheap(start,dist);
    //vec3 ge = calcGradientCheap(end,dist);
    float fds = abs(dot(gs,dir));
    float fde = abs(dot(ge,dir));
    float lam = max(fds,fde);
    
    
    return vec2(lam,dist);
}

// Function 3873
float map2( in vec3 pos )
{
    float dis;
	
	//-----------------------------
	// terrain
	float h = terrain( pos.xz );
	float mindist = pos.y - h;

	// grass
	vec2 gd = grassDistr(pos.xz);
	float g = 0.2*(gd.x * gd.y);
    mindist -= g;


	// mushroom position	
	float rockSca = 2.0;
	vec2  rockWPos = (0.5+floor(rockSca*pos.xz))/rockSca;
	vec3  rockPos = vec3( fract(rockSca*pos.x)-0.5, rockSca*(pos.y-h), fract(rockSca*pos.z)-0.5 );
    float  rockID  = hash( floor(rockSca*pos.xz) );
	float rockToTree = treeBase(rockWPos);
	
	float sh = 0.2 * (0.5 + 1.0*rockID);
	
	
	//-----------------------------
	// trees
	{
	float chsca = 0.2;
	vec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );
	float y = chos.y;
	float r = length( chos.xz );
		
	float ss = exp(-40.0*y*y);
	float dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );
	float sh = 0.08 + (0.1+0.25*ss)*dd;
		
    dis = (r - sh)/chsca;
	mindist = min( dis, mindist );
		
	}
	
	//-----------------------------
	// mushrooms
	if( rockToTree < 0.4)
	{
	float y = rockPos.y - 0.2 * 0.5;
	float r = length( vec3(rockPos.xz,y*2.0) );
	float sh = 0.2 * (0.5 + 1.0*rockID);
    sh *= mushroomAnim( iTime*(1.0+rockID) + 6.28*rockID );
    dis = (r - sh)/rockSca;
	mindist = min( dis, mindist );
		
	}


	
    return mindist;
}

// Function 3874
void mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )
{
    
    ivec3 XYFace = RayDirToXYFace(rayDir);
    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);
    if(XYTall.y < 16){
        int seed = XYFace.x + XYFace.y*16 + iFrame*1024*16;
        seed = IHash(seed);
        O.x = Hash(seed);
    } else  {
        int stage = XYTall.y/16;
        int sortStage = stage-1;
        int ID = XYTall.x*16 + (XYTall.y%16);
        if(stage<106){
            int partner = getPartner(ID,sortStage);
            vec4 A = sampleIDStage(ID, stage-1);
            vec4 B = sampleIDStage(partner, stage-1);
            if(ID > partner){
                if(A.x>B.x){
                    O=A;
                } else {
                    O=B;
                }
            } else {
                if(A.x>B.x){
                    O=B;
                } else {
                    O=A;
                }
            }
        } else if(stage<110){
            //Keep shifting the result down so that JFA pipeline always can find the particles
            O = sampleIDStage(ID, stage-1);
        } else {
            //Detect glitches
            O = vec4(0);
            vec4 A = sampleIDStage(ID-1, stage-1);
            vec4 B = sampleIDStage(ID, stage-1);
            vec4 C = sampleIDStage(ID+1, stage-1);
            if(A.x>B.x || B.x>C.x){
                O += 1.;
            }
            
        }
        
    }
    
    
}

// Function 3875
float sdfWater(vec3 p, state s) {
    float dglass = sdfContainer(p, s);
    float depth = -0.25; // Can add e.g. ripples to the surface here
    float dsurf = sdfPlane(s.p + depth*s.v, -s.v, p);
    return opSubtraction(opSmoothSubtraction(dsurf, dglass, 0.15), dglass);
}

// Function 3876
float scene(vec2 uv) {
    return min(
        (sdfCircle(uv / 1.75 + vec2(0.0, -0.5)) * -1.75),
        min(
            sdfBox(uv / 0.5 + vec2(0.0, 2.5)) * 0.5,
            sdfCircle(uv / 0.25 + vec2(0.1, 3.5)) * 0.25
        )
	);
}

// Function 3877
float doDistance(int part, in vec2 fragCoord, vec2 colorUV) {
    vec2 res = maxRes;
    //vec2 oc = fragCoord / realRes * res;
    vec2 oc = fragCoord;

    int uvIndex = toIndex(colorUV);
    int index3 = binarySearchLeftMost(part, uvIndex, res, oc);
    int index4 = binarySearchRightMost(part, uvIndex, res, oc);

    mRet mret = getM(part, index3, res);
    int foundIndex = mret.Am;
    vec4 v = mret.v;
    float d = distance(colorUV, mret.pos);

    int j = 0;
    int a = min(index3, index4);
    int b = max(index3, index4);
    int maxIter = 10;
    int retIndex = -1;
    for (int j = 0; j < maxIter; j++) {
        int i = a + j - maxIter / 2;
        mRet mret = getM(part, i, res);
        int foundIndex = mret.Am;
        vec4 v = mret.v;
        float d2 = distance(colorUV, mret.pos);
        if (d2 < d) {
            d = d2;
            retIndex = i;
        }
    }

    return float(retIndex);
}

// Function 3878
float dist(vec4 z, vec4 p, vec4 n) {
  // pmin is the orthogonal projection of z onto the plane defined by p and n
  //then pmin is projected onto the unit sphere
  float zn = dot(z,n), zp = dot(z,p), np = dot(n,p);
  float alpha = zp-zn * np, beta = zn-zp * np;
  vec4 pmin = normalize(alpha*p+min(0.0,beta)*n);
  return dist(z,pmin);
}

// Function 3879
Shape map(vec3 c){
  Shape vines = vines(c);
  Shape orbs = orb(c);
    
  float df = mixShapes(vines.dist, orbs.dist, 1.);
  vines.dist = df;
    
  vines.color = mix(vines.color, 
                    orbs.color*2., 
                    mixColors(orbs.dist, vines.dist, 1.));

  return vines;
}

// Function 3880
bool mapCube( ivec3 coord )
{
    if( coord.y < 0)	return true;
//    if( coord.y > 1)	return true;
    return false;
}

// Function 3881
float map(vec2 uv) {
    vec2 repeat = vec2(.5, .6);
    vec2 modUV = mod(uv + vec2(sin(iTime) / 1.5, iTime / 3.), repeat); // split cells, move them
    float sdCells = length(modUV - repeat / 2.) - .1;
    vec2 mouseOffset = iMouse.z > 0. ? (2. * iMouse.xy - iResolution.xy) / iResolution.y : vec2(.0);
    float sdCrawler = length(uv - mouseOffset) - .55;
    return abs(clamp(sdCells / 2.5, 0., 1.) + sdCrawler / 2.); // abs gives the magic embossing
}

// Function 3882
bool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {
    nearestDist = 10000.0;
    for(int i=0; i<7; i++) {
        CHECK_OBJ(objects[i]);
    }
    return ( nearestDist < 1000.0 );
}

// Function 3883
float mapWalls(vec3 p)
{
    float angle = atan(p.z, p.x);
    float d1 = sdSphere(p, ROOMSIZE);
    float d2 = (sin(angle*10.0)+1.0)*0.05;
    float d3 = sin(p.y*8.0)*0.05;
    return p.y-min(min(d1, d2), d3);
}

// Function 3884
float map(vec3 p)
{
    vec3 q = p;
	vec3 qa = p;
    pMod3(q, vec3(0.8, 1., 0.23));
	pMod3(qa, vec3(0.8, 1., 0.18));
    pMod1(p.x, 1.);
    
    float s1 = sphere(p, 0.75); 
    float s2 = sphere(q, 0.5);  	    	
    float s3 = sphere(qa, 0.555);
    
  	float df1 = min(min(s1, s2),s3); // Union

    return df1;
}

// Function 3885
float map(vec3 p)
{   
    vec3 offset = vec3(6,0,0);
    float de = min(voronoiTorus(p-offset),voronoiTorus(p.xzy+offset));
    vec3 co = vec3(cos(iTime),0,sin(iTime))*10.0;
    float s1= abs(sin(iTime))*3.0+2.0;
    float deSG = min(deStella((p-co-offset)/s1),deStella((p-(co-offset).xzy)/s1))*s1;
	G1 +=0.1/(0.1+deSG*deSG*10.0);
    float deS = min(deStella(p-co-offset),deStella(p-(co-offset).xzy));
 	G2 +=0.1/(0.1+deS*deS*10.0);
    de=min(de,deS);    
    return de;
}

// Function 3886
float remap( float t, float a, float b ) {
	return clamp( (t - a) / (b - a), 0.0, 1.0 );
}

// Function 3887
vec3 heatmap(in vec3 c) 
{
  return pow(0.5 * (1.0 + cos(3.1 * c - vec3(2.7, 1.3, -0.2))), vec3(3.0,3.0,4.0));
}

// Function 3888
float map(vec3 p){

    // Cheap, lame distortion, if you wanted it.
    //p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;
    
    // Back plane, placed at vec3(0, 0, 1), with plane normal vec3(0., 0., -1).
    // Adding some height to the plane from the heightmap. Not much else to it.
    float d = 1. - p.z;
    //if (d<0.2) 
        d-= heightMap(p.xy)*.125;
    return d;
    
}

// Function 3889
float map(vec3 p){
	float dist = MAX;
	
	for(int i = 0; i < SHAPES; i++){
		float ang2 = float(i) / float(SHAPES) * TWO_PI;
		float ang = ang2 + cos(2.824 + sin(iTime)) + iTime / 5.;
		dist = min(dist, sphere(p, vec3(sin(ang)*5., cos(1.243 + sin(iTime + ang2*5.)), cos(ang)*5.), 0.5));
	}
	
	return dist;
}

// Function 3890
float map(vec3 p){
	float r=INF, rc;
	
	r= min( r, length(p-tball(vec3(0,0,0)))-.2 );
	
	r= min( r, mball(p-tball(vec3( 0,0,0))) );
	r= min( r, mball(p-tball(vec3( 4,0,0))) );
	r= min( r, mball(p-tball(vec3(-4,0,0))) );
	
	return r;
}

// Function 3891
float SceneIntersect( Ray r, inout Intersection intersec ){
    float d = INFINITY;	
    float t = 0.;
    vec3 normal = vec3(0.);
    for(int i=0;i<spheres.length();i++){
        t = SphereIntersect(spheres[i].radius,spheres[i].position,r);
        if (t < d){
            d = t;
            intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);
            intersec.emission = spheres[i].emission;
            intersec.color = spheres[i].color;
            intersec.roughness = spheres[i].roughness;
            intersec.type = spheres[i].type;
		}
    }
    /*
    for(int i=0;i<ellipsoids.length();i++){
    	t = EllipsoidIntersect(ellipsoids[i].shape,ellipsoids[i].position,r);
        if (t < d){
        	d = t;
            intersec.normal = normalize((r.origin + r.direction * t - ellipsoids[i].position)/(ellipsoids[i].shape*ellipsoids[i].shape));
            intersec.emission = ellipsoids[i].emission;
            intersec.color = ellipsoids[i].color;
            intersec.roughness = ellipsoids[i].roughness;
            intersec.type = ellipsoids[i].type;
        }
    }
    for(int i=0;i<openCylinders.length();i++){
    	t = OpenCylinderIntersect(openCylinders[i].pos1, openCylinders[i].pos2, openCylinders[i].radius, r, normal);
        if (t < d){
        	d = t;
            intersec.normal = normalize(normal);
            intersec.emission = openCylinders[i].emission;
            intersec.color = openCylinders[i].color;
            intersec.roughness = openCylinders[i].roughness;
            intersec.type = openCylinders[i].type;
        }
    }
	*/
    /*
    for(int i=0;i<cones.length();i++){
    	t = ConeIntersect(cones[i].pos0, cones[i].radius0,cones[i].pos1,cones[i].radius1, r, normal);
        //t = OpenCylinderIntersect(openCylinders[i].pos1, openCylinders[i].pos2, openCylinders[i].radius, r, normal);
        if (t < d){
            d = t;
            intersec.normal = normalize(normal);
            intersec.emission = cones[i].emission;
            intersec.color = cones[i].color;
            intersec.roughness = cones[i].roughness;
            intersec.type = cones[i].type;
        }
    }
	*/
	/*
    for(int i=0;i<disks.length();i++){
    	t = DiskIntersect( disks[i].pos, disks[i].normal, disks[i].radiusSq, r );
        if (t < d){
        	d = t;
            intersec.normal = normalize(disks[i].normal);
            intersec.emission = disks[i].emission;
            intersec.color = disks[i].color;
            intersec.roughness = disks[i].roughness;
            intersec.type = disks[i].type;
        }
    }
	*/
    
    for(int i=0;i<quads.length();i++){
        t = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );
        if (t < d){
        	d = t;
            intersec.normal = normalize(quads[i].normal);
            intersec.emission = quads[i].emission;
            intersec.color = quads[i].color;
            intersec.roughness = quads[i].roughness;
            intersec.type = quads[i].type;
        }
    }
	
    for(int i=0;i<boxes.length();i++){
    	t = BoxIntersect(boxes[0].minCorner,boxes[0].maxCorner,r,normal);
        if(t < d){
        	d = t;
            intersec.normal = normalize(normal);
            intersec.emission = boxes[i].emission;
            intersec.color = boxes[i].color;
            intersec.roughness = boxes[i].roughness;
            intersec.type = boxes[i].type;
        }
    }
    intersec.distance = d;
    return d;
}

// Function 3892
vec2 barrel_distort( vec2 ec, float a ) { return ec / max( 0., 1. + a * ( 1. - dot( ec, ec ) ) ); }

// Function 3893
float sdf(vec3 p) {
   return smin(cylinder(vec3(mod(p.x, 1.1)-0.5*1.1,
                             p.y,
                             mod(p.z, 1.1)-1.1/2.0), vec3(0), 0.17, .3),
               plane(p, vec3(0,-0.2,0), vec3(0.0,1.0,0.0)), 0.4);
}

// Function 3894
vec3 Tonemap_ACESFitted(vec3 srgb)
{
    vec3 color = srgb * ACESInputMat;
   
   #if 1
    color = ToneTF2(color);
   #else
    color = RRTAndODTFit(color);
   #endif
    
    color = color * ACESOutputMat;

    return color;
}

// Function 3895
float oceanSDF(vec3 samplePoint, Sphere sphere) {
    return length(samplePoint-sphere.center) - sphere.radius - octaveNoise (samplePoint.xy);
}

// Function 3896
hit traceScene(in ray r) {
    hit ret = traceSphere(r, sph0);
    lt(ret, traceSphere(r, lit0));
    lt(ret, tracePlanePOM(r, pln0, iChannel1, vec3(1.,0.,0.), .02, 1.));
    lt(ret, tracePlanePOM(r, pln1, iChannel1, vec3(0.,1.,0.), .15, 1.));
	//lt(ret, tracePlanePOM(r, pln2, iChannel1, vec3(0.,0.,1.), .1, 1.));
    
    return ret;
}

// Function 3897
SceneResult Scene_GetLampResult( vec3 vPos, vec3 vLampCol )
{
    float fDist = length( vPos.xy );
    
    SceneResult insideEdgeResult;
    insideEdgeResult.fDist = fDist - 0.09;
    insideEdgeResult.vUVW = vPos;
	insideEdgeResult.iObjectId = MAT_LAMP_INNER;
    
    SceneResult insideResult;    
    insideResult.fDist = vPos.z + 0.05 - 0.15;
    insideResult.vUVW = vLampCol;
	insideResult.iObjectId = MAT_LAMP_BULB;
    
    insideResult = Scene_Subtract( insideEdgeResult, insideResult );
    
    SceneResult result;
    
    float fLampDist = fDist - 0.1;    
    
    fLampDist = max( fLampDist, vPos.z - 0.1  - 0.15);
    fLampDist = max( fLampDist, -vPos.z - 0.3  + 0.15);
        
    result.fDist = fLampDist;
    result.vUVW = vPos;
	result.iObjectId = MAT_LAMP;
    
    SceneResult caseResult;    
    caseResult.fDist = fDist - 0.12;
    caseResult.fDist = max( caseResult.fDist, vPos.z - 0.15);
    caseResult.fDist = max( caseResult.fDist, -vPos.z - 0.3 + 0.15);
    caseResult.vUVW = vLampCol;
	caseResult.iObjectId = MAT_LAMP_CASE;
    
    result = Scene_Union( result, caseResult );
    
    result = Scene_Subtract( result, insideResult );
    
    return result;
}

// Function 3898
float sceneSDF(vec3 pos)
{
    return min(min(sphereSDF(pos), cubeSDF(pos)), min(planeSDF(pos), floorSDF(pos)));
}

// Function 3899
vec2 map(vec3 p)
{
    vec2 m = vec2(helmet(p+vec3(0,-.25,0)),1);
    m=un(m,chest(p));
    m=un(m,vec2(feather(p-vec3(0,.35,.05)),3));
    m=un(m,vec2(arms(p),5));
    m=smun(m,legs(p),.1);
    m=un(m,vec2(tower(p),6.));
    return m;
}

// Function 3900
vec2 getDistance(vec3 ro, vec3 rd, float dmax)
{
    //distance for the origine is x and y is the mat id
    vec2 dmat = vec2(0.0);
    
    for(int i = 0; i < MAXSTEP; i++)
    {
        //position along the ray
        vec3 pos = ro + dmat.x*rd;
        
        //get the distance to the nearest sdf surface
        vec2 eval = map(pos);
        
        //if true it mean we are inside a sdf
        if(eval.x < 0.0) return dmat;
        
        dmat.x += max(eval.x,0.00001);
        dmat.y = eval.y;
        
        //true if out of range and set -1.0 for sky id
        if(dmat.x > dmax) return vec2(dmat.x, -1.0);
    }
    return dmat;
}

// Function 3901
endif
map( in vec3 pos )
{
    #if 0
    float r = 1.1;
    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );
    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );
    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;
    pos.x = mirror( pos.x / r ) * r;
    pos.y = mirror( pos.y / r ) * r;
    #else
    vec3 color = ORANGE_RGB;
    #endif
    
    MPt res;
    #if INDEXED_MATERIALS
    res.x = 1e38;
    #else
    res.distance = 1e38;
    #endif
    
    #if !INDEXED_MATERIALS
    Material plastic_m;
    plastic_m.color = vec3(1.0);
    plastic_m.diffuse_reflection  = 1.0;
    plastic_m.specular_reflection = 1.0;
    plastic_m.ambient_reflection  = 1.0;
    plastic_m.shininess           = 15.0;

    Material floor_m;
    plastic_m.color = vec3(1.0);
    floor_m.diffuse_reflection  = 1.0;
    floor_m.specular_reflection = 0.2;
    floor_m.ambient_reflection  = 0.5;
    floor_m.shininess           = 1.0;

    Material orange_m = plastic_m;
    orange_m.color = ORANGE_RGB;
    
    Material red_m = plastic_m;
    red_m.color = vec3(1.0,0.0,0.0);
    Material green_m = plastic_m;
    green_m.color = vec3(0.0,1.0,0.0);
    Material blue_m = plastic_m;
    blue_m.color = vec3(0.0,0.0,1.0);
    #endif

    float sr = 0.5;
    float sd = 0.5;
    #if 0
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),
                          orange_mat ),
	      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),
                          orange_mat ) );
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),
               orange_mat ),
          res );
    #endif
    
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_RED
                        #else
                        red_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_GREEN
                        #else
                        green_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_BLUE
                        #else
                        blue_m
                        #endif
                       ),res );
    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );
    res = union_op( MPt( plane_sd( pos ),
                        #if INDEXED_MATERIALS
                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m
                        #else
                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )
                        #endif
                       ),
                    res );


    res =
       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )
                        #endif
                       ),
                    res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,iTime), at_pos(vec3(2.0,6.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,iTime*TAU/7.0), at_pos(vec3(2.0,10.0,2.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,iTime*TAU/7.0), at_pos(vec3(2.0,12.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
	return res;
}

// Function 3902
vec3 trn_ripplemap( vec3 pos )
{
    return .20 * texturenoise( pos / .01 ).xyz +
        .30 * texturenoise( pos / .003 ).xyz +
        .30 * texturenoise( pos / .001 ).xyz +
        .20 * texturenoise( pos / .0003 ).xyz;
}

// Function 3903
vec3 tonemap_reinhard( vec3 x, float exposure ) { return exposure * tonemap_reinhard( x ); }

// Function 3904
vec2 sdf(dsvec3 p)
{
    vec2 s0 = ds_sub(ds_length(p), vec2(1.0, 0.0));
    dsvec3 q = dsvec3(ds_sub(p.x, vec2(0.141, 0.0)), ds_sub(p.y, vec2(0.1, 0.0)), ds_sub(p.z, vec2(0.9, 0.0)));
    vec2 s1 = ds_sub(ds_length(q), vec2(0.2, 0.0));

    vec2 sd = ds_min(s0, s1);
    vec2 n = ds_mul(rmf(p, 512.0, 2.0), vec2(0.00025, 0.0));
    n = ds_sub(sd, n);
    return n;
    
}

// Function 3905
vec3 scene_grad(vec3 p) {
    vec2 step = vec2(0.02, 0.);
    return vec3(
        scene(p + step.stt) - scene(p - step.stt),
        scene(p + step.tst) - scene(p - step.tst),
        scene(p + step.tts) - scene(p - step.tts)
    );
}

// Function 3906
vec3 sphericalToCubemap(in vec2 sph) {
    return vec3(sin(sph.y) * sin(sph.x), cos(sph.y), sin(sph.y) * cos(sph.x));
}

// Function 3907
float getDistGlass(vec3 pos)
{
    return getDistBox(pos,vec3(Res/Res.x+FRAME_D*2.,0));
}

// Function 3908
float scene_obj_primitive( SceneObj obj, Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )
{
    float to = t, shadow = 1.;
    vec3 N = ZERO;
    switch( int( obj.paramsA.w ) )
    {
    case SCNOBJ_PRIMITIVE_SPHERE:
    shadow = scene_primitive_sphere( ray, obj.paramsB.x, to, N );
    break;
    case SCNOBJ_PRIMITIVE_CUBE:
    shadow = scene_primitive_cube( ray, obj.paramsB.xyz, to, N );
    break;
    case SCNOBJ_PRIMITIVE_CYLINDER:
    shadow = scene_primitive_cylinder( ray, obj.paramsB.xy, to, N );
    break;
    }
    if( to < t )
    {
        t = to;
        out_N = N;
        bool ir = ( g_game.switches & GS_IRCAM ) != 0u;
        if( obj.paramsA.x == -99. )
        {
            float u = ray.o.z + ray.d.z * t;
            float Ku = 2. * sqrt( g_pixelscale ) * t * mix( 1., 1. / dot( -ray.d.xy, N.xy ), square( ray.d.z ) );
            albedo = mix( irselect( g_matdata[ int( obj.paramsA.y ) ].omega, ir ),
                         irselect( g_matdata[ int( obj.paramsA.z ) ].omega, ir ),
                         aaa_stipple( Ku, u - .001, .004, .5 ) );
        }
        else
            albedo = irselect( g_matdata[ int( abs( obj.paramsA.x ) ) ].omega, ir );
    }

    return shadow;
}

// Function 3909
float	dist_func(vec3 p)
{
	float	ret = 1e5;

    ret = length(p);
    return ret;
}

// Function 3910
vec3 getSceneColor_atlogo( in vec3 ro, in vec3 rd )
{
	const float clip_far = 100.0;
	float depth = ray_marching( ro, rd, -10.0, clip_far );
	if ( depth >= clip_far ) {
        return vec3(1.);
	}
	vec3 pos = ro + rd * depth;
	vec3 n = gradient( pos );
	return shading( pos, n, ro );
}

// Function 3911
vec2 map( in vec3 pos ) {
    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );
    p1 = rotateY( p1, CLOCK_ROT_Y );
    
	float secs = mod( floor(TIME),        60.0 );
	float mins = mod( floor(TIME/60.0),   60.0 );
	float hors = mod( floor(TIME/3600.0), 24.0 ) + mins/60.;
    
    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );
    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );
    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );
    
    return map( pos, p1, ps, pm, ph, true, true );
}

// Function 3912
float Scene(vec3 p, out int material)
{	
    float d;
	d = deTorusWarped(p, vec2(10.2,8.0), material);
	float d2 = deTorus(p, vec2(13.3, 4.5));
	d = max(d, -d2);
	d = min(d, p.y+4.0);
	
    return d;
}

// Function 3913
float getMapHeight(float x)
{
    return 0.5 + (sin(x * 0.05 + sin(x * 0.3))) * 0.5;
}

// Function 3914
vec4 getHeightMap(vec2 U) 
{
    vec2 s = vec2(MAP_DIMENSION.x-0.5, MAP_DIMENSION.y-0.5)/(iResolution.xy);
    
    // Scale U
    U*=0.05*s;
    
    if(mod(U.x, 2.0*s.x) > 1.0*s.x) U.x = 1.0*s.x-(mod(U.x,1.0*s.x));
    else U.x = mod(U.x,1.0*s.x);
    if(mod(U.y, 2.0*s.y) > 1.0*s.y) U.y = 1.0*s.y-(mod(U.y,1.0*s.y));
    else U.y = mod(U.y,1.0*s.y);

    return texture(iChannel1, U); 
}

// Function 3915
float map(vec3 p){
  //return conejo(p, 1.);
  vec3 p1 = p;
  p1.x = abs(p1.x)-1.;
  p1.xy *= rot(.5);
  // conejo
  vec3 p2 = p;
  p2.z -= 9.;
  p2.z -= mot;
  float c = conejo(p2, 1.2);
  float d = c;
  
  
  float r1 = 0.5;
  float ama = amanita(p1, r1);
  
  float bgr = bg(p, -2.);
  float trs = trees(p1);
  
  d = min(d, min(ama, trs));
  d = smin(bgr, d, 1.1);
  
  
  
  return d;
}

// Function 3916
vec4 DistanceToBoundaryAndColor(float x)
{
    // There is a boundary at x=0 and x=1. return the distance of whichever is closer.
    // Also give the color at that boundary.
    if (x <= 0.5)
        return vec4(x, colorA);
    else
        return vec4(1.0 - x, colorB);
}

// Function 3917
float map( in vec3 p )
{
	#ifdef IS_BOXED
	    vec3  d = abs(p) - size;
		float d1 = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
    #else
	    // sphere
	    float d1 = length(p) - size;
    #endif

    // saddle
    float d2 = p.y*size - (p.x*p.x*p.x - 3.0*p.x*p.z*p.z);

    return max(d1,d2);
}

// Function 3918
float sdfScene(vec2 pnt) {
  float t = myTime * 0.51;

  float rad = (sin(t) * 0.5 + 1.0) * 7.0;
  float pad1 = rad * 0.95 * (sin(t * 0.27) * 0.21 + 0.19);
  
  vec2 c1 = vec2(sin(t * 1.0), cos(t * 1.2)) * 10.0;
  vec2 c2 = vec2(sin(t * 1.3), cos(t * 1.5)) * 10.0;
  vec2 c3 = vec2(sin(t * 1.6), cos(t * 1.7)) * 10.0;

  float sdfc1 = sdfCircle(pnt, c1, rad);
  float sdfc2 = sdfAnulus(pnt, c2, rad + 2.0, rad + 6.0);
  float sdfc3 = sdfSquare(pnt * rot2(t * -0.81), c3, rad);

  float ret;
  bool usePadded = true;
  usePadded = int(myTime ) / 4 % 2 == 0;
  if (usePadded) {  
    ret = sdfUnionPadded(sdfc1, sdfc2, pad1, pad1);
    ret = sdfUnionPadded(ret  , sdfc3, pad1, pad1);
  }
  else {
    ret = sdfUnion(sdfc1, sdfc2);
    ret = sdfUnion(ret  , sdfc3);
  }
    
  return ret;
}

// Function 3919
vec3 tonemap(vec3 col){
    
	col *= BRIGHTNESS;
	col = ((col * (A * col + C * B) + D * E) / (col * (A * col + B) + D * F)) - E/F;
	return col;
}

// Function 3920
float getDist(vec3 samplePos)
{
		
	return min(distTree(samplePos),
			   distSnow(samplePos));
}

// Function 3921
vec3 GetDist(vec3 p  ) 
{	vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;
	float planeDist1 = p.y+0.0;  //piso inf
   
    p.y=p.y-3.0;
    p.x=opRep1D( p.x,40.0 );
    
    //piso y techo
    float sdb1a= sdBox( p, vec3(25.0,1.0,15.0) );
    float sdb1b= sdBox( p-vec3(0.0,24.0,.0), vec3(25.0,1.0,15.0));
    
    p.x=abs(p.x)-10.0;
    p.z=p.z-5.0;
    
    float sdb2a= sdBox( p-vec3(.0,2.0,.0), vec3(3.0,0.5,3.0) );
    float sdb2b= sdBox( p-vec3(.0,20.0,.0), vec3(2.5,0.5,2.5) );
    
    float sdcy1= sdCylinderXZ( p-vec3(0.0,10.0,0.0), vec2(2.0,10.0) );
    float sdcy1a= sdCylinderXZ( p-vec3(0.0,22.0,0.0), vec2(2.5,2.0) );
    float sdcy1b= sdCylinderXZ( p-vec3(0.0,3.0,0.0), vec2(2.5,2.0) );
     mObj.uvP= vec2(atan(p.z, p.x), p.y * 0.4);
     
    res =opU3(res, vec3(sdb1a,-1.0,5.0));
    res =opU3(res, vec3(sdb1b,-1.0,6.0));
    
    res =opU3(res, vec3(sdcy1,-1.0,10.0));
    res =opU3(res, vec3(sdcy1a,0.0,-1.0));
    res =opU3(res, vec3(sdcy1b,0.0,-1.0));
    
    res =opU3(res, vec3(sdb2a,1.0,-1.0));
    res =opU3(res, vec3(sdb2b,1.0,-1.0));
    return res;
}

// Function 3922
float distTiled(vec3 pos)
{
    ivec3 res=ivec3(getDistRes());
    pos=pos*.5+.5;
    int z1=int(floor(pos.z*float(res.z)));
    int z2=int(ceil(pos.z*float(res.z)));
    float fr=fract(pos.z*float(res.z));
    int xnum=int(iResolution.x)/res.x;
    vec2 t1=vec2(res.x*(z1%xnum),res.y*(z1/xnum))+pos.xy*float(res.xy);
    vec2 t2=vec2(res.x*(z2%xnum),res.y*(z2/xnum))+pos.xy*float(res.xy);
    t1/=iResolution.xy;
    t2/=iResolution.xy;
    return mix(texture(iChannel0,t1).x,texture(iChannel0,t2).x,fr);
}

// Function 3923
vec4 sdf_color_normal(vec3 pose, float dist, bool inside,inout vec3 nor)
{
    float pad = dist * 0.002;
    
    vec3 pos = pose;
    vec3 rot = pos;
    
    rot.xy -= vec2(0.36,-0.4);

    rot.xy = n_rotate(rot.xy,0.245);

    rot.xy += vec2(0.36,-0.4);
    
    if(dist * 0.001 > box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)))
        pos = rot;
            
    //use symetries
    
    // rotate by 90 segments
    vec3 pos_x  = abs(pos.x) < abs(pos.y)  ?  vec3(pos.y < 0.0 ? pos.x : -pos.x, abs(pos.y), pos.z)  :  vec3(pos.x < 0.0 ? -pos.y : pos.y, abs(pos.x), pos.z);
    
    
    //mirror x axis
    vec3 pos_xx = vec3(abs(pos_x.x), pos_x.y, pos_x.z);
    
    
    
    
    vec4 color = vec4(0.25,0.15,0.1,0.2);
    vec4 ns_scale = vec4(10,10,1,0.1) * vec4(pos,1.);
    
    
    
    if(inside)
    {
        
        vec3 ipos = pos;
        ipos.y -= 10.;
        ipos.z -= 0.14;
        
        if(pad > (length(ipos   + vec3( 0.00,   0, 1))-8.7)-0.3) color = vec4(3.,1.2,0.4,0.4);//all pylons
        
        
        if(pad > max(cheap_cyl(ipos          - vec3( 0.00,   0, 0.14),   2., 2.), - cheap_cyl(ipos    - vec3( 0.00, 0,0.74),   0.7, 2.))) color = vec4(0.25,0.15,0.1,1.);//console
        
        if(pad > pln(ipos          - vec3( 0.00,   0, 0.34),  vec3(0,0,1))) color = vec4(0.1);//inside floor
        
        
        if(pad > cheap_cyl(ipos          - vec3( 0.00,   0, 0.12),   5.7, 0.2)) color = vec4(3.,1.5,0.0,0.4);//stairs light
    }
    
    
    
    if(pad > box(pos    - vec3( 0.00, 0.00,1.00),  vec3(0.50,0.50,1.00)))   {color = vec4(0.05,0.20,0.30,0.10);ns_scale = vec4(400,400,10,0.15) * vec4(pos,1.);}//tardis blue
    //horizontal wood
    if(pad > box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//horizontal bars
    if(pad > box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06))) ns_scale = vec4(10,400,400,0.15) * vec4(pos_xx,1.);//sign
    if(pad > box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.5);//base
    if(pad > box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01))) ns_scale = vec4(10,400,400,0.1) * vec4(pos_xx,1.);//phone horizontal
    
    if(pad > box(pos_xx - vec3( 0.00, 0.46,1.55),  vec3(0.325,0.03,.04)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//sign
    
    
    
    float gly = 20.;
        
        gly = min(gly,show_text(pos_x.xz - vec2(-.11,1.55),ivec2(0x504f4c49, 0x43452020), 0.024));//"POLICE  "
        gly = min(gly,show_text(pos_x.xz - vec2(0.33,1.55),ivec2(0x424f5820, 0x20202020), 0.024));//"BOX     "
        gly = min(gly,show_text(pos_x.xz - vec2(0.08,1.565),ivec2(0x5055424c, 0x49432020), 0.01));//"PUBLIC  "
        gly = min(gly,show_text(pos_x.xz - vec2(.105,1.535),ivec2(0x43414c4c, 0x20202020), 0.01));//"CALL    "
        if(gly < 0.0)
            color = vec4(1);
    }
    if(pad > pln(pos    -vec3(0)                 ,vec3(0.00,0.00,1.00) ))   color = vec4(0.30,0.25,0.20,0.01);//floor
    if(pad > cheap_cyl(pos    - vec3( 0.00, 0.00, 1.91),  0.06, 0.05 ))   color = vec4(1);//light
    
    if(!inside)
    {
        if(pad > box(pos    - vec3(-0.19,-0.425, 0.97),  vec3(0.10,0.01,0.11)))  {color = vec4(0.00,0.00,0.00,1.00); ns_scale = vec4(0);//phone sign inside

            float gly = 20.;
            
            
            
            gly = min(gly,show_text(pos.xz - vec2(-.237,1.055),ivec2(0x504f4c49, 0x43452054), .006));//"POLICE T"
            gly = min(gly,show_text(pos.xz - vec2(-.142,1.055),ivec2(0x454c4550, 0x484f4e45), .006));//"ELEPHONE"
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.190,1.025),ivec2(0x46524545, 0x20464f52), .005));//"FREE FOR"
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.220,1.010),ivec2(0x55534520, 0x4f462050), .005));//"USE OF P"
            gly = min(gly,show_text(pos.xz - vec2(-.140,1.010),ivec2(0x55424c49, 0x43202020), .005));//"UBLIC   " 
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.235,0.985),ivec2(0x41445649, 0x43452026), .004));//"ADVICE &"
            gly = min(gly,show_text(pos.xz - vec2(-.160,0.985),ivec2(0x41535349, 0x5354414e), .004));//"ASSISTAN" 
            gly = min(gly,show_text(pos.xz - vec2(-.095,0.985),ivec2(0x43452020, 0x20202020), .004));//"CE      " 
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.247,0.970),ivec2(0x4f425441, 0x494e4142), .004));//"OBTAINAB" 
            gly = min(gly,show_text(pos.xz - vec2(-.182,0.970),ivec2(0x4c452049, 0x4d4d4544), .004));//"LE IMMED" 
            gly = min(gly,show_text(pos.xz - vec2(-.117,0.970),ivec2(0x49415445, 0x4c592020), .004));//"IATELY  " 
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.220,0.940),ivec2(0x4f464649, 0x43455253), .004));//"OFFICERS"
            gly = min(gly,show_text(pos.xz - vec2(-.150,0.940),ivec2(0x26204341, 0x52532020), .004));//"& CARS  "
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.190,0.925),ivec2(0x52455350, 0x4f4e4420), .004));//"RESPOND " 
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.205,0.910),ivec2(0x544f2041, 0x4c4c2043), .004));//"TO ALL C"
            gly = min(gly,show_text(pos.xz - vec2(-.140,0.910),ivec2(0x414c4c53, 0x20202020), .004));//"ALLS    "
            // \n
            // \n
            gly = min(gly,show_text(pos.xz - vec2(-.215,0.885),ivec2(0x50554c4c, 0x20544f20), .006));//"PULL TO "
            gly = min(gly,show_text(pos.xz - vec2(-.115,0.885),ivec2(0x4f50454e, 0x20202020), .006));//"OPEN    "
            
            if(gly < 0.0)
                color = vec4(1);
        }
        
        if(pad > tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)))   color = vec4(0.5,0.5,0.5,1.);//phone handle
        
    
    }
    
        if(pad > cheap_cyl((pos    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005))   color = vec4(0.2,0.15,0.1,1.);//lock
    
    if(inside)
    {
        
        vec3 ipos = pos;
        ipos.y -= 10.;
        ipos.z -= 0.14;
        
        vec2 pl = n_polar(ipos.xy);
        
            
        vec3 tile = vec3(pl,ipos.z);
        
        
        tile.x = (tile.x*72.0 - round(tile.x*72.0-0.5) - 0.5)/72.0;
        
        tile.xy = n_un_polar(tile.xy);
        
        tile.xz = map_hex(2.14*tile.xz) / 2.14;
        
        tile.y -= 7.8;
        
        
        
        
        if(pad > abs(pln(tile-vec3(0,1.9,0),vec3(0,1,0))) - 0.1) color = vec4(0.25,0.15,0.1,0.2);//dome
        
        vec3 things = vec3((pl.x*24.0 - round(pl.x*24.0-0.5) - 0.5)/24.0, pl.y, ipos.z);
            
        things.xy = n_un_polar(things.xy);
        
        things-=vec3(0,8.,1.64 * round(pl.x*24.0+0.5));
        
        things.z = (things.z*0.5 - round(things.z*0.5)) * 2.;
        
        
        things.xz = hex_tile(things.zx);
        
        
        if(round(pl.x*24.0-0.5) > -12. && round(pl.x*24.0-0.5) < 11.)
        {
            if(pad > box(things,vec3(0.4,0.02,0.4))) color = vec4(0.4,0.4,2.0,0.6);//blue hex
            things -= vec3(0.,-0.12,0.6);
            if(pad > box(vec3(things.x,n_rotate(things.yz,-0.1)),vec3(0.8,0.02,0.2))) color = vec4(0.1,0.1,0.1,0.9);//hex surounding
        }
        
        vec3 hex = vec3(hex_tile(ipos.xy),ipos.z);
        
        hex.x = abs(hex.x);

        if(pad > cyl((hex - vec3( 0.00, 4.0,3.94)).yzx, 0.25, 0.25) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint
        if(pad > cyl((hex - vec3( 0.00, 5.4,2.14)).yzx, 0.25, 0.35) - 0.1) color = vec4(0.25,0.15,0.1,0.2);// pylon joint
        
        if(pad > max(dot(vec2(0.447,0.894),vec2(pl.y,ipos.z-1.8)),1.0-ipos.z)) color = vec4(3.,1.2,0.4,0.4);//console
        
        if(pad > cap(hex, vec3( 1.4, 3.,0.35), vec3( .30, 4.3,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light
        if(pad > cap(hex, vec3( 1.5, 2.6,0.35), vec3( .37, 0.65,0.35), 0.02)) color = vec4(3.,1.5,0.0,0.1);//floor light
            
    }
    if(pad > box(pos    -vec3( 0.00, 0.00,0.84),  vec3(0.42,0.42,0.76)))   color = vec4(0.6,0.6,0.6,0.1);//tardis not inside inside
    if(pad > box(pos_xx -vec3(0.19,0.425,1.30),  vec3(0.13,0.005,0.15)))   {color = vec4(0.8,0.8,0.8,1.);ns_scale = vec4(0);}//window
    
    
    
    //"normal map"
    nor = normalize(nor +  ns_scale.w * (2.0 * vec3(noise3d2(ns_scale.xyz),0.5) - 1.0));

    
    
    return color;
}

// Function 3924
float cylinderDistance(vec3 point, float height, float radius) {
    vec2 d = abs(vec2(length(point.xz), point.y)) - vec2(radius, height);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 3925
vec2 CabDist(vec3 p) {
    p.x = abs(p.x);
    
    float cab,d;
    
    float frontGlass = dot(p.yz, vec2(0.9493, 0.3142))-1.506; // front
    float topGlass = dot(p.yz, vec2(0.9938, -0.1110))-1.407;
    float windowBottom = dot(p.yz, vec2(-0.9982, -0.0601))+1.0773;
    
    float side1 = dot(p, vec3(0.9854, -0.1696, -0.0137))-0.580;
    float side2 = dot(p, vec3(0.9661, 0.2583, 0.0037))-0.986;
    float side = max(side1, side2);
    
    float w = .05;
    float hw = .5*w;
    
    float glass = max(frontGlass, topGlass);
    float glassShell = abs( glass+.025 ) -.025; 
    d = min(glassShell, max(abs(p.z-.17),glass+.1)-.05); // center column
    cab = max(d,abs(-side2-w)-w);
    
    // top bar
    d = max(abs(p.z-.43)-w, glassShell);
    d = max(d, side2);
    cab = min(cab, d);
    
    d = max(abs(-side1-w)-w, -windowBottom);	// side wall
    float walls = min(p.y-.3, p.z+.6);
    walls = min(d, walls);
    
    walls = max(walls, glass);
    d = max(walls,side);				// bottom
	cab = min(cab, d);
    
    // front seats
    float cup = cos(p.x*10.);
    vec3 seatPos = p-vec3(.35, .2+cup*.04, .8);
    d = sdBox(seatPos, vec3(.27, .25, .3)*.8)-.05;
    seatPos = p-vec3(.35, .75, .6);
    seatPos.z += S(.0, 1.2, p.y)*.4-cup*.05;
    vec3 seatScale = vec3(.27, .6, .03)*.8;
    seatScale.x *= 1.-S(.9, 1.1, p.y)*.6;
    seatScale.xz *= 1.-S(1.1, 1.3, p.y)*.7;
    
    d = min(d, sdBox(seatPos, seatScale)-.04);
    
    cab = min(cab, d);
    
    // dash
    d = sdBox(p-vec3(0,.5,1.7), vec3(2,.5,.3));
    d = min(d, sdBox(p-vec3(0,.89+(p.z-1.3)*.1,1.5), vec3(2,.07,.3))-.01);
    d = max(d, side1);
    cab = min(cab, d);
    
    // screen
    vec3 scrPos = p-vec3(0,.9,1.15);
    scrPos.yz *= Rot(-.4);
    d = sdBox(scrPos, vec3(.16,.1,-.005))-.02;
    cab = min(cab, d);
    // wheel
	   
   
    return vec2(cab, MAT_CAB);
}

// Function 3926
vec2 reverse_mapping(vec2 Z,int p, int q, int Fover2){
    //int seed = 0;        // Optionaly keep seed constant for that static randomness look
	int seed = Fover2;
    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry
    int x=int(Z.x);
    int y=int(Z.y);
    
    
    
    for(int i = 0; i < mapping_iters; i++){
        y = Zmod(y - IHash(x^seed)%q,q);
        x = Zmod(x - IHash(y^seed)%p,p);
    }
    
    return vec2(x,y)+fract(Z);
    
}

// Function 3927
void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)
{
	vec2 uv   = fragCoord.xy / iResolution.xy;
    vec4 a    = vec4(0.2, 0.4, 1.0, 1.0);
    vec4 b    = vec4(0.85, 0.9, 1.0, 1.0);
	fragColor = vec4(mix(a, b, smoothstep(0.0, 0.5, ov(uv*5.0))));
    
}

// Function 3928
vec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c)
{
    float d0 = max(ip_control(uv, a, b, c, T), ip_aux(uv, a, b, c));
    float point = 0.;
    
#ifdef ANIMATED
    point = ip_point(uv, a, b, c);
#endif
    
    float d1 = ip_curve(uv, a, b, c);
    float rs = max(d0, d1);
    
    return (point < .5)
        ? rs * (d0 > d1 ? COL0 : COL1)
        : point * COL3;
}

// Function 3929
vec2 map(vec3 pos)
    {
        // car light
        vec3 pR = pos;
        pR.z = abs(abs(pR.z) - 0.3);
        gBloom.x = min(gBloom.x, length(pR - vec3(.87, 0.28, 0.05)) - .045);
        vec2 res = vec2(gBloom.x, 5);

        vec3 pC = pos;
        if (gTime < 9.) // gTStart
        {
            pC.x = mod(pC.x + 4.0, 8.0) - 4.0;
            pC.z = mod(pC.z + 1.0, 2.0) - 1.0;
            res = opU(res, vec2(sdEll(pC, vec3(1.2, .6, .6)), 4));
        }
        else
        {
            if (insideBox3D(pos, vec3(0, .5, 0), vec3(2.4, 1., 1.5)) > .5)
            {
                vec3 pW = pC;

                pW.xz = abs(pW.xz);
                pW -= vec3(.6, .15, .4);

                gBloom.y = min(gBloom.y, sdBox(pC - vec3(-0.9, 0.3, 0), vec3(0.1, 0.02, 0.3)) - 0.03);

                float sBody0 = smin(
                                max(
                                    sdEll(abs(pC - vec3(-0.2, 0.2, 0)), vec3(1.3, 0.3, 1.)),
                                    sdBox(pC - vec3(0, 0.2, 0), vec3(1.3, 0.08, 0.34)) - .1
                                ), mix(
                                    sdEll(rotXY(pC, 0.2) - vec3(-0.45, 0.3, 0), vec3(0.6, 0.2, 0.35)),
                                    sdBox(rotXY(pC, 0.2) - vec3(-0.45, 0.3, 0), vec3(0.6, 0.3, 0.35)) - .1,
                                    0.3) - 0.05,
                            0.04),
                    sWheels0 = max(length(pW.xy) - 0.16, abs(pW.z) - 0.11);

                res = opU( 
                        res,
                        opU(
                            vec2( max(-length(pW - .1 * r.zzx) + .12, sWheels0), 3),
                            vec2( max(
                                    max(
                                        max(
                                            max(
                                                -sWheels0 + .02,
                                                max(
                                                    sBody0 - .04, 
                                                    smin(sWheels0, sBody0, .17)
                                                )
                                            ),
                                        -rotXY(pC, .1 * PI).x - .85),
                                        -pC.y + .05
                                    ),
                                    -sdBox(pC -vec3(1, .28, 0), vec3(.15, .04, .4))
                                ),
                                4
                            )
                        )
                    );
            }

            // orb
            vec3 pB = pos - vec3(-12. * gTime + 666.48, 1, 0); // gTTunel
            pB.xz *= rot(8. * gTime);
            mat2 r2 = rot(.25 * PI);
            pB.yz *= r2;
            pB.xy *= r2;
            float box0 = sdBox(pB, vec3(.5));
            gBloom.y = min(gBloom.y, box0);

            // trail
            vec3 pT = pos - vec3(-.9, -.45, 0);
            pT.z = abs(pT.z);
            pT -= vec3(-.02, 0, .3 -.01 * cos( 2.*pT.x+28.*gTime ));
            gBloom.y = min(gBloom.y, sdBox(pT - vec3(-20, .75, -.05), vec3(20, .01, .06)));
            res = opU(res, vec2(gBloom.y, 4));
        }

        pos.x += 12. * gTime;
        // lanes
        vec3 pL = pos;
        pL.z = abs(pL.z);
        pL.x = mod(pL.x + 1.5, 3.) - 1.5;
        res = opU(res, vec2(
                min(sdBox(pL - vec3(0, -.095,  .7), vec3( .5, .1, .06)),
                    sdBox(pL - vec3(0, -.095, 2.1), vec3(1.5, .1, .06))),
                 6));

        // ground
        if (abs(pos.z) > 2.)
        {
            res = opU(res, vec2(
                        pos.y
                        - fbm(pos.xz     ) *  .2 * M((abs(pos.z) - 2.2) /  .4)
                        - fbm(pos.xz * .1) * 4.  * M((abs(pos.z) - 2.6) / 7.4) * M((gTime - 18.)/10.),
                        2));
        }

        return res;
    }

// Function 3930
float map(vec3 pos,out float id)
{
  
  vec3 sp = pos;
  sp.x = abs(sp.x);
  sp.y += sp.x * -0.5;
  float f1 = distance(sp, vec3(0.,2.5,15.)) - 1.;


  pos.xy = rot(pos.xy , pos.z * .01);
  float n = texture(iChannel0,pos.xz * .005 + vec2(0.,iTime * .05)).x * pos.z * .05;

  float f2 = distance(pos.y , -1. + n);

  id = mix(1.,2.,step(f1,f2));

  return min(f1,f2);

}

// Function 3931
vec4 GetDistanceScene( const in vec3 vPos, const in float fTransparentScale )
{          
    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);
            
	float fDistFloor = vPos.y;
	float fDistBrick = fDistFloor;
	
	float fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;
	fDistBrick = max(fDistBrick, -(fDistTrench));
	
	float fDistWall = vPos.x + 1.0;
	fDistBrick = min(fDistBrick, fDistWall);
	
    vec4 vDistFloor = vec4(fDistBrick, kMaterialIdWall, vPos.xz + vec2(vPos.y, 0.0));
    vResult = DistCombineUnion(vResult, vDistFloor);    

    vec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);

    float t= max(vWaterDomain.x / kWaterVelocity, 0.0);
	
	// Equations of motion
	float s = 0.5 * kWaterAccel * t * t;
	float v = -kWaterAccel * t;
	
	vWaterDomain.y -= s;    
                
    float fDistWater = (length(vWaterDomain.yz) - kPipeRadius);
                
    float fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);
    fDistPipe = max(fDistPipe, -fDistWater); // subtract the water from the pipe to make the hole
    vec4 vDistPipe = vec4(fDistPipe, kMaterialIdPipe, vPos.xy);        
        
    vResult = DistCombineUnion(vResult, vDistPipe);    
	
	// compensate for domain distortion of water, otherwise ray sometimes misses
	fDistWater /= (1.0 + v * 0.5);
	
    vec2 vNoiseDomain = vPos.xz;
                
	// modify noise for water in trench
	float fInTrench = step(vPos.y, (-0.1 + 0.05));        
	vec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);
	vNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);
	float fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;
	float fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);
	
	vNoiseDomain *= 30.0; 
	vNoiseDomain.x += -iTime * fWaterSpeed;
	
	float fTrenchWaterDist = vPos.y + 0.1;
	fDistWater = min(fDistWater, fTrenchWaterDist);
	
	fDistWater += Noise(vNoiseDomain) * fNoiseScale;
	
	vec4 vDistWater = vec4(fDistWater, kMaterialIdWater, vPos.xy);        
	vResult = DistCombineUnionTransparent(vResult, vDistWater, fTransparentScale);
              
    return vResult;
}

// Function 3932
void icon_dist_update(inout vec2 blk_gray, 
                      float d, bool enable) {
    
    if (enable) {
        blk_gray.x = min(blk_gray.x, d);
    } else {
        blk_gray.y = min(blk_gray.y, d);
    }
    
}

// Function 3933
float mapstage6 (in vec3 p)
{
   float d1 = length(p) - 1.0;
   //modulate on the x,y,and z - animate on the y
   d1 += 0.1* sin(10.0 * p.x)*sin(5.0 * p.y+2.0*iTime)*sin(10.0 * p.z) ; 
   float d2 = p.y + 1.0;
   return min (d1,d2);
}

// Function 3934
void prepareScene()
{
    int col = 0;
    int row = 0;
    float xStart = float(1 - SphereCols) * spheresRadius - float(SphereCols - 1) * gap;
    float xPos = xStart;
    float zPos = float(1 - SphereRows) * spheresRadius - float(SphereRows - 1) * gap;
    
    for (int i = 0; i < NumSpheres; ++i)
    {
    	spheres[i] = Sphere(vec3(xPos, spheresRadius, zPos), spheresRadius);
        xPos += 2.0 * (spheresRadius + gap);
        
        float tc = float(col) / float(SphereCols - 1);
        float tr = float(row) / float(SphereRows - 1);
        
    #if (COLORIZE)
        float r = 0.5 + 0.5 * cos(0.5 * PI * tc);
        float g = 0.5 + 0.5 * sin(0.5 * PI * tr);
        float b = sqrt(1.0 - (r * r * g * g));
        materials[i].baseColor = pow(vec3(r, g, b), vec3(2.2));
    #else
        materials[i].baseColor = vec3(1.0);
    #endif
        
        materials[i].roughness = tc;
        materials[i].metallness = tr;
        
        ++col;
        if (col == SphereCols)
        {
        	zPos += 2.0 * (spheresRadius + gap);
            xPos = xStart;
            col = 0;
            row++;
        }
	}
    
    planeMaterial.baseColor = vec3(1.0, 1.0, 1.0);
    planeMaterial.roughness = 0.33333;
    planeMaterial.metallness = 0.75;
}

// Function 3935
vec2 map2( vec3 pos ){  
    
    vec3 offset =  vec3( (5. +sin( iTime ))/ 5. , 1. + .1 * sin( pos.x * 40.) , 1. );
   	vec2 res = vec2(length( pos * offset)  - .5 , 0.0 );
    
   	return res;
    
}

// Function 3936
Surface map(vec3 p){
  vec2 ms = vec2(1.-exp(sin(phase/32.)*2.)/exp(2.), .7);
  if (iMouse.z > 0.) ms = iMouse.xy/iResolution.xy;
  mat3 m = _smat((ms*2.-1.)*PI);
  float ri = (ms.y<0.5)?1.6:(ms.y-.5)*3.+1.;
  float st = (ms.y>0.5)?.4:(.5-ms.y)*2.;
  vec3 col = _rgb(vec3(phase/256.,.4,_checker(p.xz,vec2(2.5))*.3+.4));
  vec3 dcl = _rgb(vec3(phase/256.+.33,.8,st));
  vec3 fcl = (textureLod(iChannel1,p.xz*.1,0.).rgb*.5+.3)*col;
  vec3 pos = vec3(2,2.4-max(0.,sin((phase+p.x)/64.*P2)),2);
  return near(
    Surface(dfPlane(p, vec3(0,1,0), 3.), fcl, vec3(0), vec3(.1), vec3(0)), 
    near(
      Surface(dfDdcr(repXZ(p,vec2(12))*m, 2.2, ms.x*10.+2.), dcl*.1, dcl*.9, vec3(rr2rl(ri)), vec3(ri)),
      Surface(dfDdc(repXZ(p+pos,vec2(4)), .5), vec3(0),dcl, vec3(rr2rl(ri)), vec3(ri))
    )
  );
}

// Function 3937
vec3 map_rgb(vec3 ro, vec3 rd, vec3 nrm, vec3 c) {
    int cy = int(c.y);
    //emissive surfaces
    if (cy == mtLight)	  return map_light_rgb(ro, rd, nrm);
    else if (cy == mtSsph)return map_Ssph_rgb(ro, rd, nrm);
	//use total dist (c.z) for ghetto AO
    else if (cy == mtGsph)return map_Gsph_rgb(ro, rd, nrm) * c.z;
    else if (cy == mtBox) return map_box_rgb(ro, rd, nrm) * c.z;
    else return vec3(0.0);
}

// Function 3938
vec2 MapSmokeTrail( vec3 p, Missile missile)
{
  TranslateMissilePos(p, missile);
  float spreadDistance = 1.5;
  p.z+=3.82;

  // map trail by using mod op and ellipsoids
  float s = pModInterval1(p.z, -spreadDistance, .0, min(12., (missile.pos.z-planePos.z)/spreadDistance));     
  float dist = sdEllipsoid(p+vec3(0.0, 0.0, .4), vec3(0.6, 0.6, 3.));   
  dist-= getTrailDensity(p+vec3(10.*s))*0.25;

  return vec2(dist, s);
}

// Function 3939
float map(float t, vec3 p)
{
    float x = 0.;
    float y = 0.;
	float d = 0.;
    if (t < A + B)
	{
        d = BX(t, p, 1.);
	}
    else if (t < 5.)
	{
        d = BX(A + B, p, 1.);
	}
    else if (t < 7.)
    {
        x = BX(A + B, p, M(1.1, 0., t - 5.));
        y = X(p, vec3(.15, .6 * M(0., 1., t - 5. + .4), .15));
        d = S(y, x, .1);
    }
    else
    {
        t -= 7.;
        x = .2 * pow(M(.0, 1., t), .5);
        y = .25 * pow(M(1.2, 3., t), .5);
        d = BO(p, x + y, t);
    }
	return d;
}

// Function 3940
float map( vec2 p, in float time ) 
{
    p *= 0.5;
    float f = 0.5+0.5*sin(0.53*p.x+0.5*time+1.0*sin(p.y*0.24))*
                      sin(0.13*p.y+time);
    f*= 0.75+0.25*sin(1.7*p.x+1.32*time)*sin(1.3*p.y+time*2.1);	
	return kMaxH*(0.005+0.995*f);
}

// Function 3941
float map(vec3 p){
    float d = p.y;
    vec3 q = p;
    p.xz = mod(p.xz, 3.)-1.5;
    p.y-= 1.;
    d = min(length(p)-1., d);
    return d;
}

// Function 3942
float circleDist( vec2 p){
  return length(p) - 1.0;
}

// Function 3943
vec2 map( vec3 pos ){  
    
    vec3 rot = vec3( 0. );//vec3( iTime * .05 + 1., iTime * .02 + 2. , iTime * .03  );
    // Rotating box
   	//vec2 res = vec2( rotatedBox( pos , rot , vec3( 0.7 ) , .1 ) , 1.0 );
   	
    vec2 res = vec2( sdPlanet( pos , .8 ) , 1. );
    
   // for( int i = 0; i < NUM_PLANETS; i++){
    	vec2 res2 = vec2( sdSphere( pos - planet , .1 ), 2. );
   		res = opU( res , res2 );
    //}
    
   	return res;
    
}

// Function 3944
float map(vec3 p)
{
    float amp = 1.0;
    float freq = 2.0;
    for (int i = 0; i < 3; ++i)
    {
        float s = i % 2 == 0? 1.0: -1.0;
        p.xz *= rotate2d(s * (1.0 + 3.0*float(i)) * 0.1 * iTime);
        p += amp * sin(freq * p.zxy);
        amp *= 0.5;
        freq *= 2.1;
    }
    return length(p) - 1.0;
}

// Function 3945
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     	pos), 70.0 ),
                    vec2( sdSphere(    	pos-vec3( 0.0,0.40+abs(0.3*sin(iTime+5.0)), 0.0), 0.40 ), 8.0 ) );
    res = opU( res, vec2( sdTorus(     	pos-vec3( -1.0,0.4, 1.0), vec2(0.3,0.1) ), 90.0+50.0*sin(iTime*0.2)) );
    res = opU( res, vec2( sdCylinder(  	pos-vec3( 1.0,0.55,-1.0), vec2(0.1,0.4) ), 170.0 ) );
    res = opU( res, vec2( 0.25*sdTorus(	opTwist(pos-vec3(1.0,0.55, 1.0)),vec2(0.3,0.1)), 154.1 ) );
    res = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.55 +0.1*sin(iTime),-1.0), vec3(0.8,0.6,0.25) ),80.0 ) );
    return res;
}

// Function 3946
Shape map(vec3 c){
  Shape shape = character(c);
  return shape;
}

// Function 3947
vec3 eMap(vec3 rd, vec3 sn){

    vec3 tx = tex3D(iChannel0, rd, sn);
    return smoothstep(.15, .5, tx); 
    
}

// Function 3948
vec4 textuDist(vec2 pixCoords, float A){;
    float Z =5.0; 
    vec2 uv = (pixCoords / iResolution.xy);// - vec2(0.5,0.5);
    vec2 NewCord = uv*(Z-1.0)/(Z -A);// + vec2(0.5,0.5);
    vec4 tempColor = texture(iChannel0, NewCord);
    return tempColor;
}

// Function 3949
float cubeSDF(vec3 p)
{
    vec3 d = abs(p) - 0.25;
    return min(max(d.x,max(d.y,d.z)), 0.0) + length(max(d, 0.0));
}

// Function 3950
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );

    
    //----- Head -----
    float lHeadBox = sdBox( pos-vec3( 0.0, 0.64, 0.0), vec3(0.26,0.24,0.22) );
    if(res.x > lHeadBox)
    {
        vec3 lHeadStart = rotation(Y_AXIS, 0.5) * (pos - vec3(0.0, 0.64, -0.03));
        mat3 lRotX04 = rotation(X_AXIS, 0.4);
                //Main Head
        float   lHead = sdEllipsoid( lRotX04 * (lHeadStart), vec3(0.18, 0.15, 0.19));
                lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, 0.11, 0.00), vec3(0.15, 0.11, 0.14)), 0.1);
                //Nouse
                lHead = opSmoothUnion(lHead, sdCapsule(lHeadStart - vec3(0.0, 0.04, -0.16), vec3(0.0, 0.0, 0.0),  vec3(0.0, -0.01, -0.04), 0.025), 0.005);
                //Neck
                lHead = opSmoothUnion(lHead, sdCylinder( lHeadStart - vec3(0.0, -0.12, 0.0), vec2(0.05, 0.1) ), 0.03);
                //Ears
        vec3	lEarsPos = rotation(Y_AXIS, 0.6) * (opMirrorX(lHeadStart) - vec3(0.2, 0.018, 0.02));
        float 	lEars = sdEllipsoid( lEarsPos, vec3(0.05, 0.05, 0.02));
                lEars = fOpIntersectionRound(lEars, -sdEllipsoid( lEarsPos - vec3(0.0, 0.0, -0.025), vec3(0.03, 0.03, 0.02)), 0.015);

        lHead = opSmoothUnion(lHead, lEars, 0.02);
        res = opU( res, vec2( lHead, 2.0) );

        //Eyes
        float lEyes = sdEllipsoid(opMirrorX(lHeadStart) - vec3(0.05, 0.07, -0.16),  vec3(0.01, 0.016, 0.01));
        mat3 lRotZEB = rotation(Z_AXIS, 0.6);
        float lEyeBrows = sdEllipsoid(lRotZEB * (opMirrorX(lHeadStart) - vec3(0.06, 0.12, -0.14)),  vec3(0.02, 0.012, 0.03));
              lEyeBrows = fOpIntersectionRound(lEyeBrows, -sdEllipsoid(lRotZEB * (opMirrorX(lHeadStart) - vec3(0.06, 0.114, -0.14)), vec3(0.022, 0.011, 0.03)), 0.003);
              lEyes = min(lEyes, lEyeBrows);
        lEyes = max(lEyes, lHead);
        res = opU( res, vec2( lEyes, 4.0) );
		
        float lMouthBox = sdBox( lHeadStart-vec3(0.0, -0.05, -0.15), vec3(0.12,0.05,0.05) );
        if(res.x > lMouthBox)
        {
        	//Mouth
            vec3 lVariance = vec3(sin((pos.x - 20.14) * 200.0 )*0.003, 0.0, 0.0);
            float 	lMouth = sdEllipsoid(lHeadStart - vec3(0.0, -0.05, -0.15) - lVariance,  vec3(0.1, 0.05, 0.04));
                    lMouth = max(lMouth, -sdEllipsoid(lHeadStart - vec3(0.0, -0.043, -0.15) - lVariance,  vec3(0.098, 0.05, 0.05)));
                    lMouth = opSmoothUnion(lMouth, sdSphere(opMirrorX(lHeadStart) - vec3(0.1, -0.045, -0.15), 0.0045), 0.008);
                    lMouth = max(lMouth, lHead);
            res = opU( res, vec2( lMouth, 4.0) );
        }
        
        float lHairFrontBox = sdBox( lHeadStart-vec3( 0.0, 0.17, -0.11), vec3(0.1,0.05,0.05) );
        if(res.x > lHairFrontBox)
        {
            //Hair Front
            mat3 lRotXHair1 = rotation(X_AXIS, -0.8);
            vec3 	lHairFrontLeftStart = lRotXHair1 * (lHeadStart - vec3(0.03, 0.17, -0.11));
            float 	lHairFrontLeft = sdEllipsoid(lHairFrontLeftStart,  vec3(0.03, 0.02, 0.05));
                    lHairFrontLeft = max(lHairFrontLeft, -sdEllipsoid(lHairFrontLeftStart - vec3(0.0, 0.004, 0.0), vec3(0.025, 0.018, 0.05)));
            vec3 	lHairFrontRightStart = lRotXHair1 * (lHeadStart - vec3(-0.03, 0.18, -0.11));
            float 	lHairFrontRight = sdEllipsoid(lHairFrontRightStart,  vec3(0.04, 0.03, 0.05));
                    lHairFrontRight = max(lHairFrontRight, -sdEllipsoid(lHairFrontRightStart - vec3(0.0, 0.004, 0.0), vec3(0.037, 0.028, 0.05)));
            float	lHairFront = min(lHairFrontLeft, lHairFrontRight);
                    lHairFront = max(lHairFront, lHead);
            res = opU( res, vec2( lHairFront, 4.0) );
        }
        //Hair Back
        //TODO
    }
    //----- End Head ------
    
    vec3 lPosMirrorX = opMirrorX(pos);
    
    float lBottomBox = sdBox( pos-vec3( 0.0, 0.1, -0.05), vec3(0.12,0.1,0.12) );
    //res = opU( res, vec2( lBottomBox, 5.0) );
    if(res.x > lBottomBox)
    {
        //Shoes
        float lShoes = sdEllipsoid( lPosMirrorX - vec3(0.06, -0.0025, -0.05), vec3(0.045 , 0.04, 0.12));
              lShoes = opSmoothUnion(lShoes, sdEllipsoid( lPosMirrorX - vec3(0.06, -0.001, -0.08), vec3(0.028 , 0.03, 0.05)), 0.08);
              lShoes = opSmoothUnion(lShoes, sdEllipsoid( lPosMirrorX - vec3(0.06, -0.001,  0.02), vec3(0.02 , 0.018, 0.015)), 0.08);
        res = opU( res, vec2( lShoes, 5.0) );

        //Cordones
        float lCordones = sdEllipsoid( lPosMirrorX - vec3(0.06, 0.031, -0.12), vec3(0.035 , 0.02, 0.008));
             lCordones = min(lCordones, sdEllipsoid( lPosMirrorX - vec3(0.06, 0.035, -0.1), vec3(0.035 , 0.02, 0.008)));
        res = opU( res, vec2( lCordones, 4.0) );

        //Legs
        float lLegs = sdCone( lPosMirrorX - vec3(0.06, 0.02, -0.03), vec3(0.0), vec3(0.0, 0.15, 0.0), 0.03, 0.028);
        res = opU( res, vec2( lLegs, 2.0) );

        //Socks
        vec3 lVariance = vec3(sin((pos.x - 20.14) * 200.0 )*0.001, 0.0, 0.0);
        float lSocks = sdCone( lPosMirrorX - vec3(0.06, 0.03 + lVariance.x, -0.03), vec3(0.0), vec3(0.0, 0.035, 0.0), 0.04, 0.035);
        res = opU( res, vec2( lSocks, 3.0) );

        //Trousers
        float lTrousers = sdCone( lPosMirrorX - vec3(0.06, 0.1, -0.03), vec3(0.0), vec3(0.0, 0.1, 0.0), 0.05, 0.07);
        res = opU( res, vec2( lTrousers, 4.0) );
    }
    
    float lMiddleBox = sdBox( pos-vec3( 0.0, 0.31, -0.03), vec3(0.18,0.16,0.12) );
    
    //res = opU( res, vec2( lMiddleBox, 5.0) );
    if(res.x > lMiddleBox)
    {
        //Torso
        vec3 lTorsoPos =  pos - vec3(0.0, 0.26, -0.03);
        float lTorso = sdEllipsoid( lTorsoPos - vec3(0.0, -0.26, 0.0), vec3(0.15, 0.47, 0.12));
        float lTorsoCutter = sdBox(pos-vec3( 0.0, -0.14 , 0.0), vec3(0.3,0.3,0.3)); //+ lVariance.x * 0.5
              lTorso = fOpIntersectionRound(lTorso, -lTorsoCutter, 0.02 );
        //float lTorso = sdCone( lTorsoPos, vec3(0.0), vec3(0.0, 0.22, 0.0), 0.14, 0.06);
              //Mangas
        float lMangas = sdEllipsoid( rotation(Z_AXIS,-0.4) * (lPosMirrorX - vec3(0.1, 0.35, -0.03)),vec3(0.03, 0.09, 0.03));
              lMangas = max(lMangas, -sdCone( rotation(Z_AXIS,-0.4) * (lPosMirrorX - vec3(0.15, 0.22, -0.03)), vec3(0.0), vec3(0.0, 0.1, 0.0), 0.04, 0.04));
              lTorso = opSmoothUnion(lTorso, lMangas, 0.005);
		
        float lSolapa = sdTorus(lTorsoPos - vec3(0.0, 0.17, 0.0), vec2(0.051, 0.011));
              lSolapa = max(lSolapa, -sdTorus(lTorsoPos - vec3(0.0, 0.167, 0.0), vec2(0.058, 0.008)));
        float lSolapaCutter = sdEllipsoid(lTorsoPos - vec3(0.0, 0.17, -0.1), vec3(0.02, 0.02, 0.08));
        	  lSolapa = max(lSolapa, -lSolapaCutter);
        	  lTorso = min(lTorso, lSolapa);
        res = opU( res, vec2( lTorso, 3.0) );

        //Arms
        float 	lArms = sdCone( rotation(Z_AXIS,-0.19) * (lPosMirrorX - vec3(0.13, 0.2, -0.03)), vec3(0.0), vec3(0.0, 0.15, 0.0), 0.03, 0.028);
        //Fingers
        float 	lFingers  = 			  	sdEllipsoid( (lPosMirrorX - vec3(0.14, 0.20, -0.060)), vec3(0.010, 0.016, 0.01));
                lFingers  = min(lFingers, 	sdEllipsoid( (lPosMirrorX - vec3(0.148, 0.19, -0.040)), vec3(0.012, 0.015, 0.01)));
                lFingers  = min(lFingers, 	sdEllipsoid( (lPosMirrorX - vec3(0.148, 0.194, -0.025)), vec3(0.012, 0.015, 0.008)));
                lFingers  = min(lFingers, 	sdEllipsoid( (lPosMirrorX - vec3(0.142, 0.198, -0.008)), vec3(0.011, 0.015, 0.007)));
                lArms = opSmoothUnion(lArms, lFingers, 0.014);
        res = opU( res, vec2( lArms, 2.0) );

        //Torso Lines
        vec3 lInitialPos = pos - vec3(0.0, 0.0, -0.03);
        mat3 lAngleRot = rotation(Z_AXIS,  0.27 * M_PI);
        float 	lTorsoBoxes = 				   	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 0.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) );
			  	lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 1.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 2.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.024, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 3.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 4.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 5.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 6.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.024, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		lTorsoBoxes = min(lTorsoBoxes, 	sdBox( ( lAngleRot * ( opMirrorX(rotation(Y_AXIS, 7.0 * 0.25 * M_PI) * lInitialPos)-vec3( 0.018, 0.26, -0.06))), vec3(0.018,0.044,0.08) ));
        		
        
        //lTorsoBoxes = min(lTorsoBoxes, sdBox( (rotation(Z_AXIS, 0.25 * M_PI) * ( opMirrorX(rotation(Y_AXIS, 0.5 * M_PI) * pos)-vec3( 0.025, 0.26, -0.06))), vec3(0.02,0.05,0.1) ));
        
        lTorsoBoxes = max(lTorsoBoxes, lTorso);
        res = opU( res, vec2( lTorsoBoxes, 4.0) );
    }
    
    
    //Debug reference
    //float lFront = sdSphere(pos - vec3(0.0, 0.66, -0.5), 0.08);
    //res = opU( res, vec2( lFront, 4.0) );
    return res;
}

// Function 3951
surface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {
    return surface_t(
        id,
        length(query_point)  - sphere_radius
    );
}

// Function 3952
float noiseSDF( in vec3 p )
{
    vec3 i = floor(p);
    vec3 f = fract(p);

    const float G1 = 0.2;
    const float G2 = 0.7;
    
	#define RAD(r) ((r)*(r)*G2)
    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))
    
    return smin(smin(smin(SPH(i,f,vec3(0,0,0)),
                          SPH(i,f,vec3(0,0,1)),G1),
                     smin(SPH(i,f,vec3(0,1,0)),
                          SPH(i,f,vec3(0,1,1)),G1),G1),
                smin(smin(SPH(i,f,vec3(1,0,0)),
                          SPH(i,f,vec3(1,0,1)),G1),
                     smin(SPH(i,f,vec3(1,1,0)),
                          SPH(i,f,vec3(1,1,1)),G1),G1),G1);
}

// Function 3953
float Map(vec3 pos) 
{
	
	vec4 p = vec4(pos,1);
	vec4 p0 = p;  // p.w is the distance estimate

	for (int i = 0; i < 9; i++)
	{
		p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;

		float r2 = dot(p.xyz, p.xyz);
		p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);

		// scale, translate
		p = p*scale + p0;
	}
	return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Function 3954
vec3 dSDF (vec3 p) {
    float SDFp = SDF(p);
    return normalize(
        vec3(
            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,
            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,
            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp
        )
    );
}

// Function 3955
float idSDF (vec3 p) {
    float SDFlandp = SDFland(p);
    float SDFwaterp = SDFwater(p);
    if (SDFwaterp < SDFlandp) {
        return 1.;
    }
	return 0.;
}

// Function 3956
vec2 EquiRectToCubeMap(vec2 uv)
{
    vec2 gridSize = vec2(4,3); // 4 faces on x, and 3 on y
	vec2 faceSize = 1.0 / gridSize; // 1.0 because normalized coords
    vec2 faceIdXY = floor(uv * gridSize); // face id XY x:0->2 y:0->3
    
    // define the y limit for draw faces
    vec2 limY = vec2(0, uv.y);
    if (faceIdXY.x > 1.5 && faceIdXY.x < 2.5) // top & bottom faces
    	limY = vec2(0,faceSize.y*3.);
    else // all others
        limY = vec2(faceSize.y,faceSize.y*2.);

    // limit display inside the cube faces
    if ( uv.y >= limY.x && uv.y <= limY.y
#ifdef FACE_QUAD_SIZE
        && uv.x <= 1.0 
	#ifdef FACE_QUAD_SIZE_WITH_CENTERING
        && uv.x >= 0.0         
	#endif    
#endif
)
	{
        // get face id
        float faceId = 0.;
        if (faceIdXY.y<0.5) 	faceId = 4.;		 // top
        else if(faceIdXY.y>1.5) faceId = 5.;		 // bottom
        else 				    faceId = faceIdXY.x; // all others

        // face coord uvw
        vec3 p = getFaceUVW(uv,faceId,faceSize);
        
        // spheric to surface
        float theta = atan(p.y,p.x);
        float r = length(p);
        
        // correct spheric distortion for top and bottom faces
        // instead of just atan(p.z,r)
        float phi =  asin(p.z/r);
        
        return 0.5 + vec2(theta / _2pi, -phi / _pi);
    }
    return vec2(0); // outside faces => uv(0,0)
}

// Function 3957
float scene_dist(in vec3 p)
{
    float d =  sphere(p - vec3(0.5, 0.3, 2.0), 0.1);
    d = min(sphere(p - vec3(
        0.17 * cos(0.5 * iTime) + 0.5, 
        0.30 + 0.03 * (cos(.5 * iTime) + sin(0.5 * iTime)), 
        0.17 * sin(0.5 * iTime) + 2.0), 0.04)
      , d);
    return d;
}

// Function 3958
vec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {  return sqrt(pointx*pointx + pointy*pointy); }

// Function 3959
vec3 objectMapMaterial(vec3 p, vec3 v){
    float b = 0.;
    for(int i = 0; i < lights.length(); i++){
        b += shadow(lights[i].position, p);
    }
    b /= float(lights.length());

    mapResult M = map(p);
    float m = M.Md;
    
    vec3 t = texture(iChannel1,p.xz/20.).xyz;
    float b2 = 0.;
    for(int i = 0; i < lights.length(); i++){
        b2 += distance(lights[i].position,p);
    }
    b2 /= float(lights.length());
    b2 = 1.2 - smoothstep(100.,160.,b2); //spotlight effect -- fix this and make it better lol
    //b*=b2;
    vec3 n = objectMapNormals(p);
    
    vec3 refR = reflect(p-v, n);
    
    vec3 skyb = texture(iChannel0, refR).xyz;
    if(objectMapReflectiveness(p)==0.){
        skyb = vec3(1.);
    }
    return m > 50.0 ? vec3(0.)
         : m == spheres[M.minS].dist ? spheres[M.minS].material*b*skyb
         : m == boxes[M.minB].dist ? boxes[M.minB].material*b*skyb
         : m == planes[M.minP].dist ? planes[M.minP].material*t*b*skyb : vec3(1.,0.,0.);
}

// Function 3960
float map(vec3 p)
{
    //p = mod(p,2.)-1.;
    float pz = p.z+iTime;
    vec3 rotx = vec3(sin(pz), cos(pz),0.);
    vec3 roty = vec3(-rotx.y, rotx.x,0.);
    vec3 rotz = normalize(cross(rotx, roty));
  	vec3 op = p;
    p.x = rotx.x*op.x + roty.x*op.y+ rotz.x*op.z;
    p.y = rotx.y*op.x + roty.y*op.y+ rotz.y*op.z;
    p.z = rotx.z*op.x + roty.z*op.y+ rotz.z*op.z;
    p = mod(p,2.)-1.;
    //return sphere(p,sRadius);
    return min(max(box(p,vec3(radius)),-sphere(p,sRadius)),sphere(p,sRadius*0.7));
    //return mix(box(p,vec3(0.25)),sphere(p+vec3(cos(iTime)*.25,0.,sin(iTime)*0.05),.3+.25*sin(iTime*1.5)*0.5),sin(pz*3.33+iTime*.05));
}

// Function 3961
bool scene_intersect(vec3 orig, vec3 dir, out vec3 hit, out vec3 N, out int material) {
  float maxdist = 1e8;
  float dist = maxdist;
  for (int i=0; i < NSPHERES; i++) {
    float dist_i;
    if (ray_intersect(spheres[i],orig, dir, dist_i) && dist_i < dist) {
      dist = dist_i;
      hit = orig + dir*dist_i;
      N = normalize(hit - spheres[i].center);
      material = spheres[i].material;
    }
  }

  if (abs(dir.y) > 1e-3)  {
    float d = -(orig.y+4.0)/dir.y; // the checkerboard plane has equation y = -4
    vec3 pt = orig + dir*d;
    if (d > 0.0 && abs(pt.x) < 10.0 && abs(pt.z) < 10.0 && d < dist) {
      dist = d;
      hit = pt;
      N = vec3(0,1,0);
      int parity = (int(floor(0.5*hit.x)) + int(floor(0.5*hit.z))) & 1;
      material = parity == 0 ? BOARD0 : BOARD1;
    }
  }
  return dist < maxdist;
}

// Function 3962
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4, db4;
  vec3 ror, col, vn, roo, rdo, g;
  vec2 w, wd;
  float dstObj, dstGrnd, sh, r, s, h, bsFac;
  flHide = (idVu > 0);
  roo = ro;
  rdo = rd;
  isSh = false;
  dstGrnd = GrndRay (ro, rd);
  dstObj = ObjRay (ro, rd);
  if (min (dstGrnd, dstObj) < dstFar) {
    if (dstGrnd < dstObj) {
      ro += dstGrnd * rd;
      vn = GrndNf (ro);
      s = 1. - smoothstep (0.3, 0.6, dstGrnd / (3. * grndScl));
      h = s * Fbm2 (ro.xz);
      vn = VaryNf (2. * ro, vn, 2. * s * (1. - 0.8 * smoothstep (0.5, 0.7, h)));
      col = GrndCol (ro, vn, dstGrnd);
      col *= 1. + 0.2 * smoothstep (0.5, 0.7, h);
      w = smoothstep (0.05, 0.1, mod (ro.xz, 5.));
      r = length (ro.xz);
      col *= 1. - 0.15 * (1. - w.x * w.y) * (1. - smoothstep (0.2, 0.3, r / (3. * grndScl)));
      col = mix (vec3 (1., 1., 0.), col, smoothstep (0.05, 0.1, abs (r - 2.)));
      col = mix (vec3 (1., 1., 0.), col, smoothstep (0.2, 0.3, r));
      w = flPos.xz - ro.xz;
      wd = (length (flPos.xz) > 0.) ? 0.5 * normalize (flPos.xz) : vec2 (0.);
      col = mix (vec3 (1., 0.2, 0.2), col, 0.3 + 0.7 * smoothstep (0.15, 0.17, length (w + wd)));
      col = mix (vec3 (0.2, 1., 0.2), col, 0.3 + 0.7 * smoothstep (0.15, 0.17, length (w - wd)));
      col4 = vec4 (col, 0.05);
    } else {
      ro += dstObj * rd;
      vn = ObjNf (ro);
      if (idObj == idBase) {
        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,
           abs (length (qHit.xz) - 1.1) - 0.1));
      } else if (idObj == idLeg) {
        col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 + 0.2 * sin (8. * pi * qHit.x));
      } else if (idObj == idAxl) {
        col4 = vec4 (0.8, 1., 0.8, 0.2) * (1. - 0.2 * sin (4. * atan (qHit.z, qHit.x)));
      } else if (idObj == idProp) {
        col4 = vec4 (1., 0.9, 0.8, 0.2) * (0.9 + 0.1 * sin (8. * pi * length (qHit.xz)));
      } else if (idObj == idCamV) {
        col4 = vec4 (0.1, 0.1, 0.1, 0.2);
      } else if (idObj == idCamH) {
        col4 = mix (vec4 (0.1, 0.1, 0.1, 0.2), vec4 (0.6 + 0.4 * sin (4. * pi * tCur), 0., 0., -1.),
           step (length (qHit.xy), 0.1));
      }
    }
    if (col4.a >= 0.) {
      flHide = false;
      isSh = true;
      sh = ObjSShadow (ro, sunDir);
      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +
         col4.a * step (0.95, sh) * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);
    } else col = col4.rgb * (0.5 - 0.5 * dot (vn, rd));
  } else {
    col = vec3 (0.3, 0.2, 0.1) + StarPat (rd, 8.) +
       vec3 (0.1, 0.1, 1.) * step (1. - dot (rd, normalize (vec3 (0., 0.12, 1.))), 1e-5); 
  }
  if (idVu == 0) {
    roo -= flPos + vec3 (0., 2.8, 0.);
    s = length (roo) / 15.;
    bsFac = (s >= 1.) ? 1. : 0.1 + 0.9 * s;
    roo = roo * vuMat;
    rdo = rdo * vuMat;
    db4 = BlkHit (roo, rdo, bsFac * vec3 (1.6, 0.25, 0.05));
    if (db4.x < min (dstObj, dstFar) && db4.w < 0.) {
      w = (roo + db4.x * rdo).xy / bsFac + vec2 (-0.4, 0.);
      g = floor (vec3 (10. * flPos.xz, 10. * flPos.y) + 0.5);
      wd = 0.9 * vec2 (1., 0.3);
      s = ShowInt (w - vec2 (-1., -0.1), wd, 5., g.x) +
          ShowInt (w - vec2 (0., -0.1), wd, 5., g.y) +
          ShowInt (w - vec2 (0.9, -0.1), wd, 5., g.z);
      col = mix (col, vec3 (0.2, 1., 1.), s);
    }
  }
  return clamp (col, 0., 1.);
}

// Function 3963
vec2 mapMat(vec3 p){
    vec3 q = p;
    p = vec3(mod(p.x, 5.0) - 2.5, p.y, mod(p.z, 5.0) - 2.5);
    float qpi = 3.141592 / 4.0;
    float sub = 10000.0;
    for(float i = 0.0; i < 8.0; i++){
        float x = 0.2 * cos(i * qpi);
        float z = 0.2 * sin(i * qpi);
        vec3 transp = p - vec3(x, 0.0, z);
        vec3 a = vec3(x, 1.2, z);
        vec3 b = vec3(x, -1.2, z);
        sub = min(sub, capsule(transp, a, b, 0.1));
    }
    float ttorus = torus(p - vec3(0.0, -1.5, 0.0), vec2(0.22));
    float btorus = torus(p - vec3(0.0, 1.5, 0.0), vec2(0.22));
    float u = min(btorus, ttorus);
    vec2 column = vec2(min(u, max(-sub, length(p.xz) - 0.35)), 2.0);
    vec2 ctorus = vec2(torus(rotX(iTime) * rotY(iTime) * (q - vec3(0.0, 0.0, 5.0)), vec2(1.0, 0.5)), 2.0);
    vec2 flo = vec2(q.y + 1.5, 1.0);
    vec2 roof = vec2(-q.y + 1.5, 1.0);
    return vecMin(ctorus, vecMin(column, vecMin(flo, roof)));
}

// Function 3964
float map2(vec3 p) {
    return p.y - terrain(p);
}

// Function 3965
vec2 sphDistances( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float c = dot( oc, oc ) - sph.w*sph.w;
    float h = b*b - c;
    float d = sqrt( max(0.0,sph.w*sph.w-h)) - sph.w;
    return vec2( d, -b-sqrt(max(h,0.0)) );
}

// Function 3966
float get_distance_of_3d_point_to_spherical_harmonics_blob(
    in vec3 A0,
    in vec3 B0,
    in float r0,
                                                                in float f00,
                                                 in float f1n1, in float f10, in float f11, 
                                  in float f2n2, in float f2n1, in float f20, in float f21, in float f22, 
                   in float f3n3, in float f3n2, in float f3n1, in float f30, in float f31, in float f32, in float f33,
    in float f4n4, in float f4n3, in float f4n2, in float f4n1, in float f40, in float f41, in float f42, in float f43, in float f44
){
    vec3 D = A0-B0; // offset
    vec3 Dhat = normalize(D);
    float fijYij = get_spherical_harmonics(
        Dhat, 
                                f00,
                          f1n1, f10, f11, 
                    f2n2, f2n1, f20, f21, f22, 
              f3n3, f3n2, f3n1, f30, f31, f32, f33, 
        f4n4, f4n3, f4n2, f4n1, f40, f41, f42, f43, f44
    );

    return length(D) - r0*fijYij; 
}

// Function 3967
Model map(vec3 p) {
    return model(p);
}

// Function 3968
vec2 map_ns(vec3 pos)
{
    float jelly = map_jelly(pos);
    float container = map_container(pos);
    float rods = map_rods(pos);
    vec2 res = opU(vec2(jelly, JELLY_OBJ), vec2(container, CONTAINER_OBJ));
    res = opU(res, vec2(rods, RODS_OBJ));
    return res;
}

// Function 3969
float distBox(vec3 samplePos, vec3 boxPos, vec3 boxDim)
{	
	vec3 normal;
	float bump = 0.0;
	if(length(samplePos-boxPos) < length(boxDim))
	{
	   	normal = normalize(samplePos-boxPos);
 		bump = tex3D(samplePos*TEX_SCALE_FACTOR, normal, iChannel0).r*BUMP_FACTOR;
	}
	vec3 d = abs(samplePos-boxPos) - boxDim;
	return min(max(d.x,max(d.y,d.z)),0.0) +
		length(max(d,0.0))+bump;
}

// Function 3970
dfObject map(in vec3 p) {
    
    dfObject res;
    
    // bottom
    res = dfObject(
                    sdPlaneY(p), 
                    Material(vec3(0.), vec3(0.), MAT_CHECKER)
                );
    
    // yellow sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p-vec3(0.3, 0.3, 1.1), 0.3),
                        Material(vec3(0.9, 0.7, 0.3), vec3(0.), MAT_DIFF)
                    )
                  );
    // shiny sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p - vec3(1.55, 0.5, 1.0), 0.5),
                        Material(vec3(1.0), vec3(0.), MAT_SPEC)
                    )
                  );
    
    // glass sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p - vec3(-0.3, 0.5, 0.5), 0.35),
                        Material(vec3(1.0, 1.0, 1.0), vec3(0.), MAT_GLASS)
                    )
                  );
    
    // cube
    res = dfUnion(res,
                  	dfObject(
                        sdBox(p - vec3(-1.5, 0.6, 1.5), vec3(0.4)),
                        Material(vec3(0.7), vec3(0.), MAT_DIFF)
                    )
                  );
    
    // light sphere
    res = dfUnion(res,
                  	dfObject(
                        sdSphere(p - vec3(-0.3, 2.5, 0.5), 1.0),
                        Material(vec3(1.0, 1.0, 1.0), vec3(20.), MAT_DIFF)
                    )
                  );
    
    
        
    // right wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneX(p - vec3(-3., 0., 0.)),
                        Material(vec3(1.0, 0.0, 0.0), vec3(0.), MAT_DIFF)
                    )
                  );
    // left wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneX(p - vec3(3., 0., 0.)),
                        Material(vec3(0.0, 0.0, 1.0), vec3(0.), MAT_DIFF)
                    )
                  );
    
    // top wall
    res = dfUnion(res,
                  	dfObject(
                        sdPlaneY(p - vec3(0.0, 3.0, 0.0)),
                        Material(vec3(0.5), vec3(0.), MAT_DIFF)
                    )
                  );
   
    
    // back wall
	res = dfUnion(res,
                  	dfObject(
                        sdPlaneZ(p - vec3(0.0, 0.0, 3.0)),
                        Material(vec3(1.0), vec3(0.), MAT_DIFF)
                    )
                  );
    
    // back wall behind cam
	res = dfUnion(res,
                  	dfObject(
                        sdPlaneZ(p - vec3(0.0, 0.0, -3.0)),
                        Material(vec3(0.0), vec3(0.), MAT_DIFF)
                    )
                  );
    //res = dfUnion(res, vec2(sdTorus(p - vec3(-0.3, 1.8, 0), vec2(0.6, 0.1)), 200.9)); // 30.9
    
    // back wall
    
    return res;
}

// Function 3971
vec4 distField(vec2 p){
    
    
    // Shape distance field holder. There are six in all. Four heptagons and two pentagons.
    float[6] pl;
    // Centers of the six individual polygons that represent a single tile. Use the show
    // grid borders option to see more clearly.
    vec2[6] pCntr = vec2[6](vec2(0, 0), vec2(width7s + width7, yDiff), 
                            vec2(0, -apothem7*2.), vec2(width7s + width7, apothem7*2. + yDiff),
                            vec2(0, yDiff/2.), vec2(0, yDiff/2.));
    
    // Shape IDs and local coordinates.
    vec2[6] ip;
    vec2[6] pLoc;
    
    // Using the information above to produce four heptagons.
    vec2 oP = p - pCntr[0];
    ip[0] = floor(p/s2);
    p = mod(p, s2) - s2/2.;
    pLoc[0] = p;
    pl[0] = sdHeptagon(p, apothem7);
   
    p = oP - pCntr[1];
    ip[1] = floor((p)/s2);
    p = mod(p, s2) - s2/2.;
    pLoc[1] = p;
    pl[1] = sdHeptagon((p)*vec2(1, -1), apothem7); 
    
    p = oP - pCntr[2];
    ip[2] = floor((p)/s2);
    p = mod(p, s2) - s2/2.;
    pLoc[2] = p;
    pl[2] = sdHeptagon((p)*vec2(1, -1), apothem7); 
    
    p = oP - pCntr[3];
    ip[3] = floor((p)/s2);
    p = mod(p, s2) - s2/2.;
    pLoc[3] = p;
    pl[3] = sdHeptagon(p, apothem7); 


    // Producing the two pentagons, plus some outer vertex dots.
    p = oP - pCntr[4];
    ip[4] = floor((p)/s);
    
    
    if(mod(ip[4].y, 2.)<.5){
       p.x -= s.x/2.;
       ip[4] = floor((p)/s);
    }

    p = mod(p, s) - s/2.;
    
    ip[5] = ip[4];
   
    // Pentagon vertices.
    vec2[5] v;
    v[0] = vec2(-s.x/2. + side7/2., 0);
    v[1] =  v[0] + rot2(-PI*2./7.)*vec2(side7, 0);
    v[2] = vec2(0, yh);
    v[3] = vec2(0, -yh);
    v[4] =  v[0] + rot2(PI*2./7.)*vec2(side7, 0);
    
    // Pentagon one.
    pl[4] = sdPent(p, vec2[5]( v[0], v[1], v[2], v[3], v[4]));
    
    pCntr[4] = (v[0] + v[1] + v[2] + v[3] + v[4])/5.;
    
    // The pentagon outer dots.
    pDots = 1e5;
    for(int i = 0; i<5; i++){
      pDots = min(pDots, length(p - v[i]));
    }
    
    pLoc[4] = p - pCntr[4];
  
    // Pentagon two. Same vertices, but with the local coordinates mirrored
    // acress the X-axis.
    pl[5] = sdPent(p*vec2(-1, 1), vec2[5]( v[0], v[1], v[2], v[3], v[4]));
    pLoc[5] = p;
    pCntr[5] = (v[0] + v[1] + v[2] + v[3] + v[4])*vec2(-1, 1)/5.;
    pLoc[5] = p - pCntr[5];
    
    // Other pentagon outer dots.
    for(int i = 0; i<5; i++){
      pDots = min(pDots, length(p*vec2(-1, 1) - v[i]));
    }    
    
    // Iterate through each of the six polygons, then return the minimum
    // distance, local coordinates, ID, etc.
    float minD = 1e5;
    vec2 pID = vec2(0);
    vec2 si = s2;
    
    int cID; 
    for(int i = 0; i<6; i++){
        
        if(i>3) si = s;
        if(pl[i]<minD){
            
             minD = pl[i];
             pID = ip[i]*si + pCntr[i];
             cID = i;
             pL = pLoc[i];
           
        }
        
    } 
    
    // Retrun the minimum distance, shape center ID, and shape number.
    return vec4(minD, pID, cID);
}

// Function 3972
void load_mapbits() {
    int exidx = index_idx();
    int imidx = (ipx.y * int(iResolution.x) + ipx.x) - index_idx()*3;
    // load only single pixel(96bits) for data logic, and full map for player(AI) logic(every 3-rd pixel)
    // load 2 pixels if action afc_e (burn lines)
    int iml = 1;
    if(logicw[0]==afc_e)iml=2;
#ifndef debug
    if (imidx == 2) {
        iml = 3;
        imidx = 0;
    }
#endif
    for (int jji = 0 + alp; jji < iml; jji++) {
        int nBits = 8;
        ivec4 pixeldata = loadat(imidx, exidx);
        vec4 unppixeldata[3];
        vec3 val1 = vec3(decodeval16(pixeldata[0]));
        vec3 val2 = vec3(decodeval16(pixeldata[1]));
        vec3 val3 = vec3(decodeval16(pixeldata[2]));
        vec3 val4 = vec3(decodeval16(pixeldata[3]));
        unppixeldata[0] = vec4(val1, val2.x);
        unppixeldata[1] = vec4(val2.yz, val3.xy);
        unppixeldata[2] = vec4(val3.z, val4);
        int gidx = 96 * imidx;
        for (int ii = 0 + alp; ii < 3; ii++)
            for (int jj = 0 + alp; jj < 4; jj++) {
                int n = int(unppixeldata[ii][jj]);
#ifndef debug
                if (n == 0) {gidx += 8;continue;} //work only on free map array
#endif
                for (int i = 0 + alp; i < nBits; ++i, n /= 2) {
                    if (gidx >= msize.x * msize.y)break;
                    switch (n % 2) {
                        case 0:map[gidx] = 0;break;
                        case 1:map[gidx] = 1;break;
                    }
                    gidx++;
                }
            }
        imidx++;
    }
}

// Function 3973
int mapcolor(vec3 p, int parity) {
  vec4 p4 = unproject(p,parity);
  vec2 uv = vec2(atan(p4.w,p4.x)/TWOPI,
                 atan(p4.z,p4.y)/TWOPI);
  uv += 0.1*iTime;
  uv = getuv(uv);
  uv *= 10.0;
  int i = int(uv.x)+int(uv.y);
  uv = fract(uv);
  vec2 border = min(uv-0.2,0.8-uv);
  if (min(border.x,border.y) > 0.0) return 2;
  else return i%2;
}

// Function 3974
float map_metalrings(vec3 pos)
{
    pos.y = abs(pos.y);
    pos.y-= lampsize.y + 0.08;
    pos.y*= 2.2;
    
    return sdTorus(pos, vec2(lampsize.x*.93, 0.2));
}

// Function 3975
vec4 distfunc(vec3 pos)
{
    vec3 col1;
    vec2 d1 = vec2(player(pos, 0.4,col1),1.0);
    vec3 col2;
    vec2 d2 = vec2(Floor(pos,col2), 1.0);
    vec3 col3;
    vec2 d3 = vec2(WallR(pos, 10.0,col3),1.0);
    vec3 col4;
    vec2 d4 = vec2(WallL(pos, 10.0,col4),1.0);
    vec3 col5;
   	vec2 dd1 = vec2( udRoundBox(  pos+blockposition1, vec3(1.),1.0 ,col5 ),1.0);
    vec3 col6;
   	vec2 dd2 = vec2( udRoundBox(  pos+blockposition2, vec3(1.),1.0 ,col6 ),1.0);
    vec3 col7;
   	vec2 dd3 = vec2( udRoundBox(  pos+blockposition3, vec3(1.),1.0 ,col7 ),1.0);
    vec3 col8;
   	vec2 dd4 = vec2( udRoundBox(  pos+blockposition4, vec3(1.),1.0 ,col8 ),1.0);
    vec3 col9;
   	vec2 dd5 = vec2( udRoundBox(  pos+blockposition5, vec3(1.),1.0 ,col9 ),1.0);
    
    
    vec3 col = col1;
    float minimun = d1.x;
	
    if(d2.x<minimun)
    {
        minimun = d2.x;
        col = col2;
    }
    if(d3.x<minimun)
    {
        minimun = d3.x;
        col = col3;
    }
    if(d4.x<minimun)
    {
        minimun = d4.x;
        col = col4;
    }
    if(dd1.x<minimun)
    {
        minimun = dd1.x;
        col = col5;
    }
    if(dd2.x<minimun)
    {
        minimun = dd2.x;
        col = col6;
    }
    if(dd3.x<minimun)
    {
        minimun = dd3.x;
        col = col7;
    }
    if(dd4.x<minimun)
    {
        minimun = dd4.x;
        col = col8;
    }
    if(dd5.x<minimun)
    {
        minimun = dd5.x;
        col = col9;
    }
    
    return vec4(minimun,col);
}

// Function 3976
float MapStreeLight(vec3 p)
{
  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);
  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   
  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        
  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  
  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  
  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        
  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); 

  return d;
}

// Function 3977
MapResult map_torus(vec3 position)
{
	MapResult result;
	result.material.color = vec3(0.0, 0.5, 0.8);
	
	position = (rotationMatrix(vec3(0,0,1), iTime) * vec4(position, 1.0)).xyz;
	position = (rotationMatrix(vec3(0,1,0), iTime) * vec4(position, 1.0)).xyz;
	position = (rotationMatrix(vec3(1,0,0), iTime) * vec4(position, 1.0)).xyz;
	
	vec2 q = vec2(length(position.xz) - 2.5, position.y);
	result.dist = length(q) - 0.2;
			
	return result;
}

// Function 3978
float euclideanDistance(float p1, float p2) {
	float d1 = (p1 - p2);
	return sqrt(pow(d1, 2.0));
}

// Function 3979
vec3 TorsoDistance( vec3 vPos, vec3 vA, vec3 vB, vec3 vC, vec3 vD, float fSizeTop, float fSizeBase )
{    
    vec3 vMidBase = (vA + vB) * 0.5;
    vec3 vMidTop = (vC + vD) * 0.5;
    
    vec3 vAxis = vMidTop - vMidBase;
    float fAxisLen = length( vAxis );
    vec3 vAxisDir = normalize( vAxis );
    
    float fProjection = dot( vAxisDir, vPos - vMidBase );
    
    float fNormProj = fProjection / fAxisLen;
    float fNormProjClamped = clamp( fNormProj, 0., 1. );
    
    //vec3 vProjected = vMidBase + vAxisDir * clamp( fProjection, 0., fAxisLen );
    
    vec3 vSpinePos = mix( vMidBase, vMidTop, fNormProjClamped );

    vec3 vPerpBase = (vB - vA) * 0.5;
    vec3 vPerpTop = (vD - vC) * 0.5;
    
    vec3 vPerp = mix( vPerpBase, vPerpTop, fNormProj );
    vec3 vPerpDir = normalize( vPerp );
    
    float fSideLen = length( vPerp );
    
    float fPerpProj = dot( vPerpDir, vPos - vSpinePos );
    float fPerpProjClamped = clamp( fPerpProj, -fSideLen, fSideLen );
    
	vec3 vBackPlanePos = vSpinePos + vPerpDir * fPerpProjClamped;
    
    float fSize = mix( fSizeBase, fSizeTop, fNormProjClamped );
    
    //float fNormPerpProj = fPerpProj / length(vPerp);
    //float fNormPerpProjClamped = clamp( fNormPerpProj, -1., 1.);
    
    //vec3 vSidePos = vSpinePos + vPerp;
    //vec3 vBackPlanePos = mix( vSpinePos, vSidePos, fNormPerpProjClamped );
    
    
    float fDistance = length(vPos - vBackPlanePos) - fSize;
    
    return vec3( fDistance, fNormProj, fPerpProj / (fSideLen * 2.0) + 0.5);
}

// Function 3980
vec2 gs_map_project( GameState gs, vec3 r )
{
    r = normalize(r) * gs.camframe;
	if( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )
		r.z = log( tan( atan( r.z, length( r.xy ) ) / 2. + PI / 4. ) );
    vec2 coord = vec2( atan( -r.y, -r.x ) , r.z );
    return gs.camzoom * coord;
}

// Function 3981
float sdfUnionPadded(float a, float b, float padA, float padB) {
  // i'm not sure this can be simplified.
  // it can be expressed as five abs() calls plus some divide by fours,
  // but i'm hesitant to go there. i suspect min/max are non-branching in GPUs.
  float sub1 = max(a - padA, -a);
  float sub2 = max(b - padB, -b);
  float sub  = min(sub1, sub2);
  float ret  = max(min(a, b), -sub);
  return ret;
}

// Function 3982
vec3 logToneMap(vec3 c){
    
    // in my experience limit=2.2 and contrast=0.35 gives nice result
    // i prefer to leave a lot of highlights
    // also log curve fades to highlights beautifully
    // however i raised this parameters to make it look
    // somewhat identical to other algorithms here
    
    // according to my information the dynamic range of
    // human eye's light perception is around
    // 2.5 of what monitor can provide
    // though it's hightly questionable in terms of
    // both the data and my understanding of it
    
    // P.S.
    // i noticed that applying inverse tonemap transformation to
    // diffuse textures improves the final render a lot
    
    float limit = 2.5;
    float contrast = 0.3;
    
    // do the tone mapping
    
    c = log(c + 1.0) / log(limit + 1.0);
    
    // clamping for hackyContrast because s_curve
    // does not behave properly outside [0; 1]
    // if you want to keep values outside [0; 1]
    // for example for bloom post-effect
    // you would need comething better than
    // hackyContrast()
    
    c = clamp(c,0.0,1.0);
    
    // hacky contrast s_curve
    // btw it's a freatapproximation for 1-cos(x*3.14)*0.5
    
    c = mix(c, c * c * (3.0 - 2.0 * c), contrast);
    
    // this creates pleasant hue shifting
    // i amplified the effect to demonstrate it more clearly
    // usually i use it very subtle
    
    c = pow(c, vec3(1.05,0.9,1));
    
    // gamma correction
    
    return pow(c, vec3(1. / gamma));
}

// Function 3983
vec3 cubemap(vec3 d, vec3 c1, vec3 c2)
{
	return fbm(d) * mix(c1, c2, d * .5 + .5);
}

// Function 3984
void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {
    vec3 lmn;
    int pageDst;
    lmnFromVCube(rayDir, pageDst, lmn);

    if (pageDst == 1) {
        fragColor = doPage1(lmn);
    } else if (pageDst == 2) {
        fragColor = doPage2(lmn);
    } else {
        discard;
    }
}

// Function 3985
vec2 GetDistanceMirrorGlass( const in vec3 vPos )
{	
	float fDistance = GetDistanceBox(vPos, vMirrorGlassSize);
	return vec2(fDistance, kMaterialChrome);
}

// Function 3986
float sceneHigh(vec3 pos) {
	return pos.y - fbmHigh(pos * 0.006) * 80.0 + 55.0;
}

// Function 3987
maybe_vec2 get_distances_along_2d_line_to_triangle(
    in vec2 A0,
    in vec2 A,
    in vec2 B1,
    in vec2 B2,
    in vec2 B3
){
    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);
    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);
    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);
    return maybe_vec2(
        vec2(min(line1.value, min(line2.value, line3.value)), 
             max(line1.value, max(line2.value, line3.value))), 
        line1.exists || line2.exists || line3.exists
    );
}

// Function 3988
float seaFragmentMap(vec3 p) 
{
    vec2 uv = p.xz * vec2(0.85, 1.0); 
    
    float freq 	 = SEA_FREQ;
    float amp    = SEA_HEIGHT;  
    float choppy = SEA_CHOPPY;
	
    float d = 0.0;
    float h = 0.0;    
    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) 
    {	    
    	d =  seaOctave((uv + gSeaCurrentTime) * freq, choppy);
		d += seaOctave((uv - gSeaCurrentTime) * freq, choppy); 
		h += d * amp;
	
		freq *= SEA_FREQ_MUL; 
		amp  *= SEA_AMPLITUDE_MUL;
	
		choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);
	
		uv *= OCTAVE_MATRIX;
    }
    return p.y - h;
}

// Function 3989
float map(vec3 p)
{

    vec3 q = p;

    vec3 c = vec3(0.2);
    p.z = mod(p.z,c.z)-0.5*c.z;

    
    vec3 p_s;
    
    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), sin(floor(q.z * 10.0) * 10.0) * 4.0 + 0.1 * (time));
    
    float bars = 1000.0;
    int sides = 9; // not really sides
    float angle = 3.1415 * 2.0 / float(sides) + sin(iTime/10.0)+ 1.0;
    
    for ( int i = 0; i < sides; i ++)
    {
        
        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));
        
       	p_s += vec3(
            sin(30.0 * floor(q.z))* 0.5 + 1.0, 
            cos(iTime + sin(q.z* 9.0)), 
            0.0);
        
        vec3 boxdim = vec3(
        	0.05 + 0.05 * sin(q.z*5.0 + iTime* 2.0), 
            sin(q.z * 10.0) * 0.5  + 0.5, 
            0.01 + pow(sin(iTime), 0.5)
        );
     	
        
        bars = min(bars, sdBox(p_s, boxdim));  
    }

        
    
    float result = bars;   
    return result;
}

// Function 3990
float distCar(vec3 pos)
{
    //return length(pos)-.5;
    float sc = 1.;
    vec4 q = vec4(0,0,0,1);
    q=multQuat(q,axAng2Quat(vec3(0,0,1),iTime*.5));
    //q=multQuat(q,axAng2Quat(vec3(1,0,0),iTime*.17));
    vec3 pos2;
    pos=transformVecByQuat(pos,q);

    vec3 tpos=clamp(pos*sc,-.95,.95);
    float d=texture(iChannel1,pos*sc*.5+.5).x/sc;
    //d+=maxcomp(abs(tpos-pos));
    d+=length(tpos-pos*sc)*.5/sc;
    
    return d;
}

// Function 3991
vec3 distfunc(vec3 pos)
{ 
	vec4 baseGeomtry = geom(pos);
       
    pos.y = baseGeomtry.y;
    float hvar = texture(iChannel0, pos.xz*0.075).x;
    float h = height + hvar*heightvar;
    
    vec2 t = iTime * vec2(5.0, 4.3);
    vec2 windNoise = sinNoise(pos.xz*2.5 + t);
    vec2 windNoise2 = sin(vec2(iTime*1.5, iTime + pi) + pos.xz*1.0) * 0.5 + vec2(2.0, 1.0);
    vec2 wind = (windNoise*0.45 + windNoise2*0.3) * (pos.y);

    pos.xz += wind;

    vec3 p1 = opRep(pos, vec3(density));
    p1 = vec3(p1.x, pos.y - h, p1.z);
    float g1 = sdCone(p1, vec3(1.0, thickness, h));
    
    pos.xz *= rot5;
    vec3 p2 = opRep(pos, vec3(density)*0.85);
    p2 = vec3(p2.x, pos.y - h, p2.z);
    float g2 = sdCone(p2, vec3(1.0, thickness, h));
    
    pos.xz *= rot10;
    vec3 p3 = opRep(pos, vec3(density)*0.7);
    p3 = vec3(p3.x, pos.y - h, p3.z);
    float g3 = sdCone(p3, vec3(1.0, thickness, h));
    
    pos.xz *= rot3;
    vec3 p4 = opRep(pos, vec3(density)*0.9);
    p4 = vec3(p4.x, pos.y - h, p4.z);
    float g4 = sdCone(p4, vec3(1.0, thickness, h));
    
    float g = min(min(g1, g2), min(g3, g4));
    
    float id = 1.0;
    
    if(baseGeomtry.z < epsilon)
        id = 0.0;
    
	return vec3(min(g, baseGeomtry.x), id, h);
}

// Function 3992
float planeDistance(vec3 rayPosition) {
    return rayPosition.y;
}

// Function 3993
vec4 MAP_SIMPLE_Scene(vec3 p) {
	float fulldist = 9999.0;
    float dist = fulldist;
    vec3 color = DEFAULT_MESH_COLOR;
    
    // Red Sphere
    {
        vec3 sphereColor = vec3(1.0, 0.0, 0.0);
        float sphereRadius = 1.0;
        vec3 spherePosition = vec3(0.0, 1.0, 0.0);
        float sphereDist = length(p-spherePosition)-sphereRadius;
        if (sphereDist < dist) {
            color = sphereColor;
            dist = sphereDist;
        }
    }
    
    // Ocean
    {
        vec3 oceanColor = vec3(1.0);
        float oceanHeight = 0.0;
        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);
        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;
        if (oceanDist < dist) {
            color = oceanColor;
            dist = oceanDist;
        }
    }
    
    return vec4(color, dist);
}

// Function 3994
HD map(f3 p)
{
	HD scene = HD( sdBox(p, f3(50, 60, 60)), f3(0,0,0), 0., 0., 0., 0., 0., false );
	if (scene.D < .001)
	{
		scene.D = 999.;
		f4 ns = abs(fbmd(p*10.));
		f3 pHand1 = (p + f3(20, -37, 25)) * .7;
		f3 pHand2 = (p + f3(-14, -25, 25)) * .7;
		f3 pHand3 = (p + f3(-12, 5, 15)) * .7;
		pHand2.x *= -1.;

		rot(pHand1.xy, .15);
		rot(pHand1.yz, .5);
		rot(pHand2.xz, .3);
		rot(pHand2.xy, 3.6);
		rot(pHand2.yz, -1.1);
		rot(pHand3.xz, -.5);
		rot(pHand3.xy, -1.4);

		scene = opUnion(scene, cabinet(p));
		if (sdBox(pHand1, f3(20, 20, 40)) < .001)
			scene = opUnion(scene, hand(pHand1, ns, f4(1.1, 1.05, .9, .8), .1));
		if (sdBox(pHand2, f3(10, 10, 30)) < .001)
			scene = opUnion(scene, hand(pHand2, ns, f4(.9, .8, .9, .8), .8));
		if (sdBox(pHand3, f3(30, 20, 50)) < .001)
			scene = opUnion(scene, hand(pHand3, ns, f4(.5, .6, .7, .8), .6));


		f3 eyeOffset = f3(-2.6, 32, 25);

		f1 size = .2;
		f1 eyesSdf = LN(p + eyeOffset) - size;
		eyesSdf = min(eyesSdf, LN(p + eyeOffset + f3(-1, -10.5, 0)) - size);
		HD eyes = HD( eyesSdf, f3(.4, 0, 0), 0., 0., 0., 0., 0., true );

		scene = opUnion(scene, eyes);
	}

	HD light1 = HD( LN(p + f3(-110, -380, 100)) - 250., f3(1, 1, 1)*2., 0., 0., 0., 0., 0., true );
	HD light2 = HD( LN(p + f3(250, -100, 0)) - 105., f3(.5, .3, .3), 0., 0., 0., 0., 0., true );
	scene = opUnion(scene, light1);
	scene = opUnion(scene, light2);

	return scene;
}

// Function 3995
float sdf_disk(vec2 uv, vec2 center, float radius)
{
    return length(uv - center) - radius;
}

// Function 3996
float clampDistance(float d) {
  return max(d, 0.0);
}

// Function 3997
float sdfSegment(vec2 uv, vec2 a, vec2 b) { 
	uv-= a; b -= a; 
	return length(uv - b * clamp(dot(uv,b)/dot(b,b), 0.0, 1.0)); 
}

// Function 3998
float torusDistance(vec3 p, float inner_radius, float outer_radius)
{
	vec3 ring_p = vec3(normalize(p.xy) * outer_radius, 0.0);
	return distance(p, ring_p) - inner_radius;
}

// Function 3999
float dist_to_plot(vec2 p,vec2 fdf){vec2 p0=vec2(p.x,fdf.x);vec2 n=normalize(vec2(-fdf.y,1));return abs(dot(p-p0,n));}

// Function 4000
float Scene(vec3 p)
{
    vec3 absp = vec3(abs(p.x), p.y, abs(p.z));
    absp -= vec3(0.0, 0.0, 40.0);
    
    float result = FarClip;
    
    float steps     = min(Steps(absp), Steps(RotY(absp + vec3(-12.0, -3.4, -20.0), PI * 1.5)));
    float base      = Base(absp);
    float walls     = Walls(absp);
    float hallway   = Hallway(absp);
    
    result = min(result, steps);
    result = min(result, base);
    result = min(result, walls);
    result = max(result, -hallway);
    
    if(p.y < result)
    {
        return p.y;
    }
    
    return result;
}

// Function 4001
float sdist(vec3 a, vec3 b, float r)
{
    vec3 d = a-b;
    return dot(d,d)/(sqr(r)+1e-6);
}

// Function 4002
float sdf_K(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_quarter3_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -6, 0), vec3(4, -8, 0)));
    return t;
}

// Function 4003
void scene (inout vec3 p, inout vec3 d, inout vec4 col, float i) {
	float depth = 1e3;
    vec3 norm=vec3(0);
    vec4 c = vec4(0);
    float t = iTime/pi;
    for (int i = 0; i < 4; i++) {
        tri(p,d,
            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(
               	4,0,0,
                0,4,0,
                0,0,4
            )
        ,c,depth,norm);
    	tri(p,d,
            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(
               	-4,0,0,
                0,-4,0,
                0,0,-4
            )
        ,c,depth,norm);
        tri(p,d,
            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(
               	1,0,0,
                0,1,0,
                0,0,1
            )
        ,c,depth,norm);
        tri(p,d,
            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(
               	-1,0,0,
                0,-1,0,
                0,0,-1
            )
        ,c,depth,norm);
        
        sph (p,d,vec4(sin(t+float(i)),cos(t+float(i)),sin(phi*t+float(i*i)),.2), c, depth, norm);
    } 
    p = p + d*depth;
    d = reflect(d,norm);
    p += 0.0001*d;
    col += 0.6*c/(1.+0.3*i);
}

// Function 4004
float heightMap(in vec2 uv)
{
    uv /= 6.;
    // mirror repeat
	vec2 m1 = mod(uv, 1.), m2 = mod(uv, 2.);
    uv = mix(m1, 1.-m1, max(vec2(0.), sign(m2-1.)));
    
    vec4 k = texture(iChannel1, uv);
	return 0.2*k.x;    
}

// Function 4005
vec3 heatmap(in float c) 
{
  return pow(0.5 * (1.0 + cos(3.1 * c - vec3(2.7, 1.3, -0.2))), vec3(3.0,3.0,4.0));
}

// Function 4006
vec3 MapDisk(vec2 p) {
    float angle = 6.2831853072 * p.y;
    return vec3(cos(angle), sin(angle), p.x);
}

// Function 4007
float sdfSphere(vec3 pt, vec3 center, float radius)
{
    return length(pt - center) - radius;
}

// Function 4008
vec4 SphereMap(sampler2D sam, in vec3 p)
{
  vec2 spherePos = PosToSphere(p);
  return textureLod(sam, spherePos, 2.*log2(spherePos.y*2.));
}

// Function 4009
vec2 DistanceConstraint(vec2 x, vec2 x2, float restlength, float stiffness)
{
    vec2 delta = x2 -x;
    float deltalength = length(delta);
    float diff = (deltalength-restlength) /deltalength;
    return delta*stiffness*diff;
}

// Function 4010
vec4 texMapSmooth(samplerCube tx, vec3 p){

    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. 
	vec2 e = vec2(0, 1);
  
    // Multiplying the coordinate value by 100 to put them in the zero to 100 pixel range.
    // It was a style choice... which I'm standing by, for now. :)
    p *= 100.;
    
    
    vec3 ip = floor(p);
    // Set up the cubic grid.
    p -= ip; // Fractional position within the cube.
    
    // Smoothing - for smooth interpolation. Comment it out to see the
    //p = p*p*p*(p*(p*6. - 15.) + 10.); // Quintic smoothing. Slower, but derivaties are smooth too.
    //p = p*p*(3. - 2.*p); // Cubic smoothing. 
    //p = mix(p, smoothstep(0., 1., p), .5);
    //vec3 w = p*p*p; p = ( 7. + (p - 7.)*w)*p;	// Super smooth, but less practical.
    //p = .5 - .5*cos(p*3.14159); // Cosinusoidal smoothing.
    // No smoothing. Gives a blocky appearance.
    
     // Smoothly interpolating between the eight verticies of the cube. Due to the shared verticies between
    // cubes, the result is blending of random values throughout the 3D space.
    vec4 c = mix(mix(mix(tMapSm(tx, ip + e.xxx), tMapSm(tx, ip + e.yxx), p.x),
                     mix(tMapSm(tx, ip + e.xyx), tMapSm(tx, ip + e.yyx), p.x), p.y),
                 mix(mix(tMapSm(tx, ip + e.xxy), tMapSm(tx, ip + e.yxy), p.x),
                     mix(tMapSm(tx, ip + e.xyy), tMapSm(tx, ip + e.yyy), p.x), p.y), p.z);
/*   
    // For fun, I tried a straight up average. It didn't work. :)
    vec4 c = (tMapSm(tx, ip + e.xxx) + tMapSm(tx, ip + e.yxx) +
              tMapSm(tx, ip + e.xyx) + tMapSm(tx, ip + e.yyx) +
              tMapSm(tx, ip + e.xxy) + tMapSm(tx, ip + e.yxy) +
              tMapSm(tx, ip + e.xyy) + tMapSm(tx, ip + e.yyy))/8.;
*/ 
    
    return c;

}

// Function 4011
vec3 doBumpMap( in vec3 pos, in vec3 nor )
{
    float e = 0.0015;
    float b = 0.005;
    
	float ref = fbm( 48.0*pos, nor );
    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,
                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;
	
	vec3 tgrad = gra - nor * dot ( nor , gra );
    return normalize ( nor - tgrad );
}

// Function 4012
vec3 TriplanarMapping (sampler2D tex, vec3 normal, vec3 position) {
	vec3 normalBlend = BlendNormal(normal);
	vec3 xColor = texture(tex, position.yz).rgb;
	vec3 yColor = texture(tex, position.xz).rgb;
	vec3 zColor = texture(tex, position.xy).rgb;

  	return (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);
}

// Function 4013
float distSq(in vec3 a, in vec3 b) {
    vec3 c = a - b;
    return dot(c, c);
}

// Function 4014
Hit boxSDF( vec3 p, Box b )
{
  vec3 q = abs(p - b.center) - (b.size);
  float radius = 0.02;
  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);
}

// Function 4015
vec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)
{         
  const vec3 sunColor = vec3(1.1, 0.53, 0.27); 
  vec3 reflectDir = reflect( rayDir, normal );

  float occ = 1.;
  #ifdef PERFORM_AO_PASS
    occ = calcAO( rayHit.hitPos, normal );
  #endif

    vec3 lightTot = vec3(0.0);
  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );
  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );
  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 );

  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);
  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);
  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );

  float shadow=1.; 
  #ifdef SHADOWS
    shadow = SoftShadow(rayHit.hitPos+normal*0.001, sunPos);
  #endif
    dif*=shadow;

  lightTot += 1.6*dif*sunColor;

  lightTot += 0.75*amb*vec3(0.35, 0.45, 0.6)*occ;  
  lightTot += 0.270*skylight*GetSkyColor(reflectDir)*occ;
  lightTot += 1.*specLevel*vec3(1., 0.85, 0.75)*dif;  
  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 2.0)*occ;
  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );
  lightTot = mix( lightTot, lightTot+ vec3(3.)*vec3(0.9, 0.6, 0.57), fre );

  return clamp(lightTot, 0., 10.);
}

// Function 4016
float map(vec3 p){
    
    float c = heightMap(p);
    
    //objID = 1.;
    
    return c*.7;
 
}

// Function 4017
void init_scene( void )
{
    // Initialize lights
    float w = float(NUM_LIGHTS)*8.0;
    float lr = w*0.5;
    for( int i = 0; i < NUM_LIGHTS; i++)
    {
    	lights[ i ].pos = vec3( -lr + w*float( i + 1 ) / float( NUM_LIGHTS + 1 ), 2, 3 );
        lights[ i ].col = vec3( 0.8 );
    }
    
    // Initialize camera
    cam.pos = vec3( 0.0, 0.0, 3.9 );

    // Initialize spheres
    float t = iTime * 0.5;
#ifdef DRAW_SPHERES
    for(int i = 0; i < NUM_SPHERES; i++)
    {
        float ifrc = float(i)/float(NUM_SPHERES)*2.0*PI;
        float r = 1.0;
        spheres[ i ].r = r;
        r *= 2.0;
        float ipi = float( i ) * 2.0 * PI / float( NUM_SPHERES );
        spheres[ i ].pos = vec3( r * sin( ipi + t ), r * cos( ipi + t ), -0.0 );
        spheres[ i ].mat.kd = vec3( 0.4 ) + 0.4 * vec3( sin(ifrc + t), sin(ifrc + t + 2.0*PI/3.0), sin(ifrc + t + 2.0*2.0*PI/3.0));      
        spheres[ i ].mat.ka = spheres[ i ].mat.kd;
        spheres[ i ].mat.ks = vec3(0.7);
        spheres[ i ].mat.ns = 128.0;
    }
#endif
#ifdef DRAW_ROOM
    float br = 4.0;
    for( int i = 0; i < NUM_PLANES; i++)
    {
        float fiPI = float(i)*0.5*PI;
        planes[ i ].center = vec3(cos(fiPI)*br,0,-sin(fiPI)*br);
        planes[ i ].normal = -normalize( planes[ i ].center );
        planes[ i ].up     = vec3(0,1,0);
        planes[ i ].dims   = vec2(br);
        planes[ i ].mat.ka = vec3(0.1);
	    planes[ i ].mat.ks = vec3(0.3);
    	planes[ i ].mat.ns = 128.0;

    }
    planes[ 3 ].center = vec3(0,br-EPSILON,0);
    planes[ 3 ].normal = vec3(0,-1,0);
    planes[ 3 ].up     = vec3(0,0,1);
    planes[ 3 ].dims   = vec2(br);
    planes[ 3 ].mat.ka = vec3(0.1);
    planes[ 3 ].mat.ks = vec3(0.0);
    planes[ 3 ].mat.ns = 128.0;
    planes[ 4 ].center = vec3(0,-br+EPSILON,0);
    planes[ 4 ].normal = vec3(0,1,0);
    planes[ 4 ].up     = vec3(0,0,1);
    planes[ 4 ].dims   = vec2(br);
    planes[ 4 ].mat.ka = vec3(0.1);
    planes[ 4 ].mat.ks = vec3(0.0);
    planes[ 4 ].mat.ns = 128.0;
    planes[ 0 ].mat.kd = vec3(0.9,0.1,0.1);
    planes[ 1 ].mat.kd = vec3(0.8,0.8,0.8);
    planes[ 2 ].mat.kd = vec3(0.1,0.9,0.1);
    planes[ 3 ].mat.kd = vec3(0.8,0.8,0.8);
    planes[ 4 ].mat.kd = vec3(0.8,0.8,0.8);
#endif
}

// Function 4018
void sample_BSDF(in Intersection inter, inout DirectionSample ds){
    float n = inter.material.shininess;
    bool is_lambert = n==0.0f;
    vec3 r = float(is_lambert) * inter.normal + 
        	 float(!is_lambert) * reflection(-inter.ray.direction, inter.normal);
    
    ds.direction = randomDirectionHemisphere(r, max(n,1.0f));
    float cosr = dot(r, ds.direction);
    float correct_r = float(cosr > 0.0f) - float(cosr <= 0.0f);
    
    cosr *= correct_r;
    ds.direction *= correct_r;
    
    float coswo = dot(inter.normal, ds.direction);
    bool ok = coswo > 0.0f;
    float cosr_pow_n = pow( abs(cosr),n);
	
	float w = (n + 1.0f + float(is_lambert))/ TWO_PI;
    	
    ds.pdf = w * (float(is_lambert) * coswo + 
                  float(!is_lambert) * cosr_pow_n); 
    ds.bsdf = float(ok) * w * inter.material.albedo * cosr_pow_n ;
}

// Function 4019
vec3 mapNormal(vec3 pt, float e)
{
    vec3 normal;
    normal.y = map(pt).x;    
    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 4020
float map(in vec3 rp)
{
    rp *= rotation;
    float m = length(rp + sin(rp * 32.) * 0.042) - 0.5;
    m += length(sin(rp * 80.0) * 0.0025);
    return m;
    
}

// Function 4021
void sceneDualCircles(vec2 uv, out vec3 params)
{
	uv *= .1+fract(iBeat*.0625*.5)*3.5;
	vec3 p=stereographic(uv);
	
	params = vec3(fract(p.x*2.+iBeat),rangeMoon);
}

// Function 4022
float map(vec3 p, out int material)
{
    float d2, d, b = 0.0;    
    mat3 rot = mat3(1);
    float c, c2;
    d2 = d = b = 200000.;
	
    p.z += CAM_DEPTH;
    
    //FRAME BOX
    d = min(d, sdBox(p + vec3(0.,0.,0.5), vec3(1,1,0.5), rot));
    //d = max(d, -udRoundBox(p + vec3(0.,0.,-0.15), vec3(0.9,0.9,0.4), 0.04, rot));
    d = max(d, -sdBox(p + vec3(0.,0.,-0.15), vec3(0.9,0.9,0.4), rot));
    if(d < b){ material = 0; b = d; }
    
    
    //CENTER PANEL
    d = min(d, udRoundBox(p + vec3(-0.03,-0.6,0.3), vec3(0.4,0.2,0.18), 0.02, rot));
    d = min(d, udRoundBox(p + vec3(0.17,-0.2,0.3), vec3(0.2,0.2,0.18), 0.02, rot));
    d = min(d, udRoundBox(p + vec3(-0.03,-0.6,0.26), vec3(0.35,0.05,0.18), 0.02, rot));
    d = min(d, udRoundBox(p + vec3(0.07,-0.7,0.26), vec3(0.25,0.05,0.18), 0.02, rot));
    d = min(d, udRoundBox(p + vec3(0.17,-0.25,0.26), vec3(0.15,0.2,0.18), 0.02, rot));
    if(d < b){ material = 2; b = d; }
    
     //LEFT TWIN PIPES
    rot = mat3(1);
    d = min(d, sdCappedCylinder( p + vec3(0.775, 0.0, 0.16), vec2(0.1, 1.0), rot));
    d = min(d, sdCappedCylinder( p + vec3(0.56, 0.0, 0.16), vec2(0.1, 1.0), rot));
    if(d < b){ material = 3; b = d; }
    
    //UPPER RIGHT BOXES
    d = min(d, udRoundBox(p + vec3(-0.25,-0.2,0.26), vec3(0.12,0.05,0.18), 0.02, rot));
    d = min(d, udRoundBox(p + vec3(-0.7,-0.73,0.26), vec3(0.08,0.08,0.18), 0.02, rot));
    if(d < b){ material = 5; b = d; }
    
    
    //BOTTOM RIGHT PANEL
    d2 = udRoundBox(p + vec3(-0.6,0.4,0.24), vec3(0.2,0.4,0.18), 0.04, rot);
    d2 = fOpEngrave(d2, udRoundBox(p + vec3(-0.6,0.4,0.1), vec3(0.18,0.38,0.18), 0.01, rot), 0.015);
    d2 = min(d2, sdSphere(p  + vec3(-0.6,0.1,0.0), 0.05));
   
    d = min(d, d2);
    if(d < b){ material = 4; b = d; }
    
    //RIGHT BIG PIPE
    rot = rotation(X_AXIS, PI * 0.5);
    d2 = min(d2, sdTorus( p + vec3(-0.75, -0.33, 0.16), vec2(0.15, 0.1), rot ));
    d2 = max(d2, sdBox( p + vec3(-0.6, -0.47, 0.16), vec3(0.13, 0.15, 0.1), mat3(1) ));
    d = min(d, d2);
    rot = rotation(Z_AXIS, PI * 0.5);
    d = min(d, sdCappedCylinder( p + vec3(-0.86, -0.478, 0.16), vec2(0.1, 0.14), rot));
    rot = mat3(1);
    d = min(d, sdCappedCylinder( p + vec3(-0.6, -0.123, 0.16), vec2(0.1, 0.2), rot));
    d = min(d, sdCappedCylinder( p + vec3(-0.6, 0.8, 0.16), vec2(0.1, 0.2), rot));
    if(d < b){ material = 1; b = d; }
        
   
    //TORUS CORE
    rot = rotation(X_AXIS, PI * 0.5);
    d = min(d, sdTorus82( p + vec3(0.05, 0.5, 0.12), vec2(0.25, 0.06), rot));
    d = min(d, sdTorus82( p + vec3(0.05, 0.5, 0.12), vec2(0.08, 0.04), rot));
    if(d < b){ material = 5; b = d; }
    rot = mat3(1);
    d = min(d, udRoundBox(p + vec3(0.05,0.5,0.38), vec3(0.33,0.33,0.18), 0.02, rot));
    if(d < b){ material = 2; b = d; }

    
    d = min(d, sdCappedCylinder( p + vec3(0.05, 0.64, 0.12), vec2(0.03, 0.06), rot));
    rot = rotation(Z_AXIS, PI * 0.75);
    d = min(d, sdCappedCylinder( p + vec3(0.18, 0.38, 0.12), vec2(0.03, 0.06), rot));
    
    rot = rotation(Z_AXIS, PI * -0.85);
    d = min(d, sdCappedCylinder( p + vec3(-0.08, 0.2, 0.12), vec2(0.03, 0.09), rot));
    rot = rotation(Z_AXIS, PI * 0.5);
    d = min(d, sdCappedCylinder( p + vec3(-0.255, 0.13, 0.12), vec2(0.03, 0.15), rot));
        
    rot = rotation(X_AXIS, PI * 0.5);
    d = min(d, sdTorus( p + vec3(0.05, 0.5, 0.05), vec2(0.25, 0.025), rot) );
    if(d < b){ material = 1; b = d; }
        
    //UPPER RIGHT PIPES
    rot = mat3(1);
    d = min(d, sdCapsule( p + vec3(-0.2,-0.2,0.06), vec3(0.,0.,0.), vec3(0.,0.25,0.), 0.04, rot ));
    d = min(d, sdCapsule( p + vec3(-0.3,-0.2,0.06), vec3(0.,0.,0.), vec3(0.,0.25,0.), 0.04, rot ));    
    d = min(d, sdCapsule( p + vec3(-0.3,-0.73,0.06), vec3(0.,0.,0.), vec3(0.4,0.0,0.), 0.04, rot ));
        
    if(d < b){ material = 1; b = d; }
    
    return d;
}

// Function 4023
float distDeathStar(vec3 p) {
 
    float base = distSphere(p, vec3(3., 0., 10.), 6. );
    float lens = distSphere(p, vec3(1., 1.7, 5. ), 1.3);
    //float trench = distBox(p, vec3(2.,0.,10.),vec3(10.,.05,10.));
    
    float x = max(-lens, base);
    return x;
    //return max(-trench,x);
    
}

// Function 4024
float dist_to_line(vec2 p1, vec2 p2, vec2 uv)
{
	float a = abs(distance(p1, uv));
	float b = abs(distance(p2, uv));
	float c = abs(distance(p1, p2));

	float d = sqrt(c*c + RADIUS*RADIUS);

	if (a >= d || b >= d)	{
        float dist1 = distance(p1, uv);
        float dist2 = distance(p2, uv);
        return min(dist1,dist2);
	}

	float p = (a + b + c) * 0.5;

	float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));
    return h;
}

// Function 4025
float map2(vec3 p) {
  float d4 = plane(p, vec3(0., 1., 0.), .2);
  return d4;
}

// Function 4026
float distCylinder( vec3 p, vec2 h, vec3 rot)
{
	p = rotMat(rot) * p;  
	float u = (.5 + atan(p.z, p.x)
               / (2. * 3.14159)) / h.x;
    float v = p.y / h.y + .5;
    
    float disp = texture(iChannel0, vec2(u * .1 + .1,v * .5 + .1)).r;
    
	vec2 d = abs(vec2(length(p.xz),p.y)) - h;
	return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - (disp * .05);
}

// Function 4027
float dist(vec3 p) { return sdBox(p,vec3(1.5)); }

// Function 4028
vec4 mapNumber( vec2 p, vec2 tp, float s, float v1){
    float vn = abs(v1), vf = fract(vn), count = .0, vc = vn;
    vec4 chr = vec4(0.);
    for (int i = 0; i < 10; i++) { 																			// count digits 
        count++; vc /= 10.;
        if (vc <= 1.0 && i != 0) break;
    }
    if (v1 < 0.) count++;
    p = (p - tp + vec2(.5/s ) + vec2(-count*.05, 0.)) * vec2(s);
    if (v1 < 0.){
        chr = max(chr, char( (p+vec2(float(count-1.)*.5,0.)), 0x2d).x); 						// minus/(-)
	}
    chr = max(chr, char((p-vec2(float(1)*.5,0.)), 0x2e).x); 									// dot/period (.)
    for (int i = 0; i < 10; i++) {
        if (vn >= 1.0 || i == 0)
            chr = max(chr, char( (p+vec2(float(i)*.5,0.)), 48+int(mod(abs(vn),10.))).x); 		// draw int
        vn /= 10.; vf *= 10.;
        if (i < 2)
                chr = max(chr, char( (p-vec2(float(i+2)*.5,0.)), 48+int(mod(abs(vf),10.))).x); // draw dec
    }
    return chr;
}

// Function 4029
float cloudMap( const in vec3 p, const in float ani ) {
	vec3 r = p/CLOUDSCALE;

	float den = -1.8+cos(r.y*5.-4.3);
		
	float f;
	vec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,1.0,15.0)*ani*0.15;
    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;
    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;
    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;
    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;
    f += 0.03125*noise( q );
	
	return 0.065*clamp( den + 4.4*f, 0.0, 1.0 );
}

// Function 4030
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, bgCol, vn, rg;
  vec2 qBlk;
  float dstObj, a, s, sh;
  bool fxz;
  aRot = -0.2 * 2. * pi * tCur;
  aCs = vec2 (cos (aRot), sin (aRot));
  crRad = 2.;
  crLen = 5.;
  crMid.y = -0.5 * crRad * aCs.y;
  crCs = vec2 (cos (asin (crMid.y / crLen)), crMid.y / crLen);
  crMid.x = crLen * crCs.x + crRad * aCs.x;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);
    if (idObj == idBase) {
      col4 = vec4 (0.9, 0.3, 0.1, 0.);
      if (abs (vn.y) < 0.01) {
        rg = ro;
        rg.y += 0.5;
        fxz = (abs (vn.x) > 0.99);
        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));
        rg.xz *= sign (fxz ? vn.x : vn.z);
        if (fxz) {
          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);
          else vn.xz = Rot2D (vn.xz, rg.x);
        } else {
          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);
          else vn.zx = Rot2D (vn.zx, rg.x);
        }
      } else {
        rg = ShGrid (ro.xz);
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);
        if (vn.y > 0.99) {
          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);
          else vn.yx = Rot2D (vn.yx, rg.x);
        }
      }
      vn = VaryNf (32. * ro, vn, 1.);
    } else if (idObj == idCyl) {
      col4 = vec4 (0.7, 0.3, 0.1, 0.2);
      a = atan (qHit.z, - qHit.y) / (2. * pi);
      if (abs (vn.x) > 0.99) {
        col4.r *= 1. - 0.3 * Fbm2 (4. * qHit.yz);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *
           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));
      } else {
        col4.r *= 1. - 0.3 * Fbm2 (4. * vec2 (8. * a, qHit.x));
        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));
      }
    } else if (idObj == idWhl) {
      if (abs (vn.z) < 0.01) qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);
      col4 = vec4 (0.8, 0.6, 0.1, 0.1) * (1. - 0.2 * Noisefv2 (128. * qHit.xy));
    } else if (idObj == idSpk) {
      col4 = 0.9 * vec4 (0.8, 0.6, 0.1, 0.2);
    } else if (idObj == idCrnk) {
      col4 = vec4 (0.6, 0.6, 0.4, 0.2);
    } else if (idObj == idAx) {
      col4 = vec4 (0.7, 0.4, 0.1, 0.3);
    } else if (idObj == idPis) {
      col4 = vec4 (0.4, 0.4, 0.4, 0.3);
    } else if (idObj == idCrod) {
      col4 = vec4 (0.6, 0.5, 0.6, 0.3);
    } else if (idObj == idCylEnt) {
      col4 = vec4 (0.7, 0.4, 0.1, 0.2);
      if (length (qHit.yz) < 0.33) col4.rgb *= 0.5;
    } else if (idObj == idValv) {
       col4 = vec4 (0.7, 0.4, 0.1, 0.2);
       if (vn.x > 0. && length (qHit.yz) < 0.13) col4.rgb *= 0.5;
    } else if (idObj == idPipes) {
       col4 = (length (qHit.xz) > 0.3) ? vec4 (0.7, 0.4, 0.1, 0.2) : vec4 (0.3, 0.2, 0., 0.);
    } else if (idObj == idSup) {
      col4 = vec4 (0.1, 0.6, 0.1, 0.05);
      vn = VaryNf (32. * ro, vn, 1.);
    }
    sh = 0.5 + 0.5 * ObjSShadow (ro, ltDir);
    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
       col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
    col += col4.a * vec3 (0.4) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.05, qBlk.y));
  } else {
    qBlk = mod (4. * BlkHit (ro, rd), 1.);
    col = vec3 (0.6, 0.6, 1.) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +
       vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.05, qBlk.y));
  }
  return clamp (col, 0., 1.);
}

// Function 4031
Hit boxSdf(vec3 p, vec3 c, vec3 s) {
    Hit hit;
    hit.dist = vmax(abs(p - c) - s);
    hit.color = vec3(1.0);
    return hit;
}

// Function 4032
vec2 getEdgeDistAndShading(vec4 uvsf) {
    
    float d = abs(geodesicDist(edges[2], uvsf.xy));
    d = min(d, abs(geodesicDist(edges[1], uvsf.xy)));
    d = min(d, abs(geodesicDist(edges[0], uvsf.xy)));
    
    return vec2(d, mix(uvsf.w < 0. ? 0.8 : 1.0, 0.9, smoothstep(0.5*uvsf.z, 0.0, d)));

}

// Function 4033
vec4 ShowScene (vec2 uv, vec4 col)
{
  vec4 col4;
  vec2 p;
  p = 0.5 * 4.5 * (uv - 0.5);
  col4 = (SegDist (p, ppPen, pPen) < 0.005) ? vec4 (HsvToRgb (vec3 (mod (0.0005 * nStep, 1.), 1., 1.)), 1.) :
     mix (col, vec4 (0.), 0.0005);
  col4 *= step (1./256., col4.a);
  return col4;
}

// Function 4034
float map(vec3 p){
    float d =
        opU(
            udRoundBox(tilePlane(p),vec3(1.,0.1,1.),0.05),
            sdBrain(p)
        );
    
    if(usePuddle) {
    	return opU(d, opPuddle(p));
    } else {
    	return d;
    }
}

// Function 4035
de map( in vec3 p){return map(p, vec3(1.));}

// Function 4036
Model map(vec3 p) {

    globalScale = 1.;
    float t = time;

    float off = .73;
    
    t += 1.;
    float camScale = tweenCamera(p, t - (1.-off)/delay);
    globalScale *= camScale;

    Model model = newModel();
    Model model2;

    t *= delay;
    t += off;

    if (t < 2.6) {
    	model = drawFinalBloom(p, t);
      	model.d *= globalScale;
    }

    for (float i = 0.; i < 3.; i++) {

        // scale
        tweenSkull(p, t);

        if (globalScale <= 0.) {
			break;
        }

        // skull
        model2 = skullWithBlooms(p, t);
        model2.d *= globalScale;
        model = opU(model, model2);

        // translate
        stepTransform(p, t);
        
        // bloom
        model2 = drawFinalBloom(p, t);
        model2.d *= globalScale;
        model2.neg *= globalScale;
        if ( ! model2.isBound) {
            model.d = smax(model.d, -model2.neg, .04 * globalScale);
        }
        model = opU(model, model2);
    }

    return model;
}

// Function 4037
bool intersectScene(vec3 p, vec3 dir,out Hit h)
{
    Hit ht;
    h.t = INF;
    bool hit = false;
    Sphere s1 = Sphere(vec3(0.,0.,0.), 1.);
    
    
   	Box b1 = makeBox(vec3(0.,-2.,0.),vec3(20.,0.5,20.));
    Box b2 = makeBox(vec3(-3.,0.,0.), vec3(1.,1.,1.));
    
    if(intersectSphere(s1,p,dir,ht))
    {
     	h = ht;  
        hit = true;
    }
    if(intersectAABB(b1,p,dir,ht) && ht.t < h.t)
    {
     	h = ht;  
        hit = true;
    }
    if(intersectAABB(b2,p,dir,ht) && ht.t < h.t)
    {
     	h = ht;  
        hit = true;
    }
    
    return hit;
    
}

// Function 4038
float mapHole(vec3 p, float angle) {
    float s = sdSphere(p-vec3(0.0, 0.0, 0.0), 4.0);
    return s * fract(p.y*0.5);
}

// Function 4039
float horizontalDistance(vec2 p, vec2 p0, vec2 p1)
{
    if(p.y < min(p0.y, p1.y) || p.y > max(p0.y, p1.y))
        return 100000000.0*sign(p1.y-p0.y);
    
    float h = p.y-p0.y;
    float slope = (p1.x-p0.x)/(p1.y-p0.y);
    float l = p.x-h*slope - p0.x;
    
    return l*sign(p1.y-p0.y);
}

// Function 4040
float sceneSDF(vec3 p) {
return sceneSDF(p,5);
}

// Function 4041
vec2 mapSquare(in vec2 p)
{
    vec2 ap = abs(p);
    float r = max(ap.x, ap.y);
    float angle = atan(p.y, p.x);

    return r*vec2(cos(angle), sin(angle));
}

// Function 4042
vec3 scene(ray_t camera, vec3 sunDir)
{
    hit_t hit = no_hit;
    intersect_sphere(camera, atmosphere, hit);
    
    vec3 AtmosphereScattering = vec3(0.0);
    bool isGround = false;
    
    const int numSteps = 64;
    const int inscatSteps = 16;
    
    float mu = dot(-sunDir, camera.direction);
    vec3 Sun = SunIntensity * SunColor;
    vec3 T = vec3(0.0);
    
    vec3 P = camera.origin;
    float seg = hit.t / float(numSteps);
    vec3 P_step = camera.direction * seg;
    
    // from eye to the outer end of atmosphere
    for(int i=0; i<numSteps; ++i)
    {
        float height = length(P) - EARTH_RADIUS;
        if(height < 0.0)
        {
            isGround = true;
            break;
        }
        
        // optical depth
        T += seg * (BetaR * exp(-height / Hr));
        T += seg * (BetaM * exp(-height / Hm));
        
        // single scattering
        hit_t hit2 = no_hit;
        ray_t ray2 = ray_t(P, -sunDir);
        intersect_sphere(ray2, atmosphere, hit2);
        
        float segLight = hit2.t / float(inscatSteps);
        vec3 PL_step = ray2.direction * segLight;
        vec3 PL = P;
        
        vec3 TL = vec3(0.0);
        bool applyScattering = true;
        for(int j=0; j<inscatSteps; ++j)
        {
            float height2 = length(PL) - EARTH_RADIUS;
            if(height2 < 0.0)
            {
                applyScattering = false;
                break;
            }
            
            TL += segLight * BetaR * exp(-height2 / Hr);
        	TL += segLight * BetaM * exp(-height2 / Hm);
            
            PL += PL_step;
        }
        if(applyScattering)
        {
            TL = exp(-TL);

            vec3 SingleScattering = vec3(0.0);
            // scattering = transmittance * scattering_coefficient * phase * radiance
            SingleScattering += MAGIC_RAYLEIGH * seg * exp(-T) * (BetaR * exp(-height / Hr)) * phaseR(mu) * (TL * Sun);
            SingleScattering += MAGIC_MIE * seg * exp(-T) * (BetaM * exp(-height / Hm)) * phaseM(mu) * (TL * Sun);
            AtmosphereScattering += SingleScattering;
        }
        
        P += P_step;
    }
    
    // Just magic number
    if(isGround)
    {
        float r = 1.0 - 1.0 / (1.0 + 0.000001 * length(hit.origin - camera.origin));
        return vec3(r, 0.4, 0.2);
    }
    
    T = exp(-T);
    
    // Zero scattering
	vec3 L0 = T * sunImage(camera, sunDir);
    AtmosphereScattering += L0;
    
    return AtmosphereScattering;
}

// Function 4043
vec4 cubemap( sampler2D sam, in vec3 d )
{
    // intersect cube
    vec3 n = abs(d);
    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: 
             (n.y>n.x && n.y>n.z) ? d.yzx:
                                    d.zxy;
    // project to face    
    vec2 q = v.yz/v.x;
    
    // undistort in the edges
    #if METHOD==-1
	int mode = (int(iTime)%5);
    #else
    const int mode = METHOD;
    #endif
    if( mode==0 ) {}
    if( mode==1 ) q  = atan(q*tan(0.868734829276))/0.868734829276;
    if( mode==2 ) q *= 1.50 - 0.50*abs(q);
    if( mode==3 ) q *= 1.45109572583 - 0.451095725826*abs(q);
    if( mode==4 ) q *= 1.25 - 0.25*q*q;

    // sample texture
    vec2 uv = 0.5+0.5*q;
    vec4 c = texture( iChannel0, uv );
    // add wireframe
	vec2 w = 1.0-smoothstep(0.96,1.0,cos(10.0*uv*6.2831));
    return c*w.x*w.y;
}

// Function 4044
float globeInteriorSDF(in vec3 p, inout int material)
{
    float d;

    {
    	vec3 q = 3. * p + vec3(0., 4.5, 0.);
    	d = smin(smin(length(q - vec3(-4., -2., -1.)) - 6.05,
                      length(q - vec3( 3., -3.,  5.)) - 7.13, 3.),
                      length(q - vec3( 1., -3.5, -4.)) - 8.22, 3.) / 3.;
    }

    if (use_locomotive) {
        const float scale = 20.;
        p.x = -p.x;
        vec3 q = scale * p - vec3(7., -2., 0);

        float d_loc = sdTracks(q) / scale;
        d_loc = min(d_loc, sdLocomotive(q, .5 * iTime) / scale - .007);
        if (d_loc < d) {
            d = d_loc;
            material = MAT_METAL_SNOW;
        }
    }
    
    if (use_interior_3d_snow) {
        const float snow_size = .03;

        float d_snow = sdSnow(p - vec3( 0., -.5 * iTime + 0.,  0), snow_size, false);
        p = (rotate(radians(45.), vec3(0, 1, 0)) * vec4(p, 1)).xyz;
        d_snow = min(d_snow, sdSnow(p - vec3(43., -.5 * iTime + 2., 13.), snow_size, false));
        if (d_snow < d) {
            d = d_snow;
            material = MAT_SNOWFLAKE;
        }
    }

    return d;
}

// Function 4045
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){
    
    vec2 e = vec2(2.5/iResolution.y, 0);
    float f = bumpFunction2(p); 
    
    float fx = bumpFunction2(p - e.xyy); // Same for the nearby sample in the X-direction.
    float fy = bumpFunction2(p - e.yxy); // Same for the nearby sample in the Y-direction.
    float fz = bumpFunction2(p - e.yyx); // Same for the nearby sample in the Y-direction.
    
    vec3 grad = (vec3(fx, fy, fz )-f)/e.x; 
          
    grad -= n*dot(n, grad);          
                      
    return normalize( n + grad*bumpfactor );
}

// Function 4046
float sdf(vec3 p, Volume volume)
{
  return length(p - volume.center) - volume.radius;
}

// Function 4047
float map(vec3 p) {
  
  #if 0
  // having fun with repetition and rotations
  float t=time*0.2;
  p.z += t*15;
  p.x += sin(p.z*0.037+t)*33;
  p.y += sin(p.z*0.027+t*0.7)*23;
  p.xy *= rot(p.z*0.02+t*5.0);
  //p.xz *= rot(p.y*0.015+t*0.7);
  
  float dist = 35;
  p.z = (fract(p.z/dist-0.5)-0.5)*dist;
  p=abs(p);
  #endif
    
  // we compute two explosion at the same time
  // offseted in time so one explosion start when the other disappear
  float m1 = explode(p+pos1, time, 0.0);
  float m2 = explode(p+pos2, time, 0.5);
  
  at += 0.8/(2.0+abs(m1));
  at2 += 0.8/(2.0+abs(m2));
  
  float m3 = min(abs(m1),abs(m2));
  
  vec3 bp=p;
  bp += smoothstep(-0.5,0.5,sin(p.yzx*1.0))*0.2;
  float other = (length(bp)-15.0)*0.8;
  
  #if 0
  // Tried to add a "cage" but it's less great
  for(int i=0;i<2;++i) {
    float t3=time*0.1+i;
    p.xz *= rot(0.7);
    p.xy *= rot(0.7);
    p=abs(p)-5.6;
    //p=smin(p, -p, -2.0)-3;
  }
  float s=0.5;
  other=min(other, cyl(p.xy, s));
  other=min(other, cyl(p.yz, s));
  other=min(other, cyl(p.xz, s));
  //other=smin(other, length(bp)-25,-10);
  other=max(other, length(bp)-35);
  
  //other = max(-(length(p)-8.5),sqrt(abs(p.x)+abs(p.y)+abs(p.z))-1.2*3);
  #endif 
  
  metal=other<m3;
  
  return min(m3, other);
}

// Function 4048
LightmapSample decode_lightmap_sample(vec4 encoded)
{
    return LightmapSample(floor(encoded), fract(encoded) * LIGHTMAP_OVERBRIGHT);
}

// Function 4049
float distSphere( vec3 pos, float radius ) {
    return length( pos ) - radius;
}

// Function 4050
vec4 colorDistanceField(vec3 point)
{   
    vec3 moddedPoint	= domainMod(point);
    
    float roadDist		= AABox(roadPt1, roadPt2, moddedPoint);
    float distSphere 	= sphereDist(sphere, moddedPoint);
    float distCylinder 	= cylinderDist(cylinderPos, cylinderSize, moddedPoint);
    float distPlane		= planeDist(plane, point);
    float minDist		= MAX_DIST;
    minDist 			= min(distSphere, distCylinder);    
    minDist 			= min(minDist, distPlane);
    minDist 			= min(minDist, roadDist);
        
    //blend colors
    vec3 color = vec3(0.0);
    color += calcColorWeight(roadDist, minDist) 	* roadColor;
    color += calcColorWeight(distSphere, minDist) 	* lampColor;
    color += calcColorWeight(distCylinder, minDist) * poleColor;
    color += calcColorWeight(distPlane, minDist) 	* groundColor;
    
	return vec4(color, minDist);
}

// Function 4051
vec4 gs_map_unproject_d( GameState gs, vec2 sc, vec2 res, inout vec3 ddx, inout vec3 ddy )
{    
    vec4 coord_x = vec4( 2, 0, 0, 2. * sc.x - res.x ) / ( gs.camzoom * res.y );
    vec4 coord_y = vec4( 0, 2, 0, 2. * sc.y - res.y ) / ( gs.camzoom * res.y );	
    vec4 c = coord_y;	
    if( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )
		c = sin_d( 2. * atan_d( exp_d( coord_y ) ) - const_d( PIHALF ) );
	
    vec4 s = sqrt_d( max_d( const_d( 0. ), const_d( 1. ) - square_d( c ) ) );  
    vec4 x = -mul_d( cos_d( coord_x ), s );
    vec4 y = -mul_d( sin_d( coord_x ), s );
    vec4 z = clamp_d( c, -ONE_D, ONE_D );

    ddx = gs.camframe * vec3( x.x, y.x, z.x );
    ddy = gs.camframe * vec3( x.y, y.y, z.y );
    return vec4( gs.camframe * vec3( x.w, y.w, z.w ), c.w );
}

// Function 4052
vec4 SampleScene( vec2 vPixelCoord, vec2 vResolution, float fLightLevel )
{
    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 32.0);
    vec4 vResult = texture( iChannel3, (vScenePixelCoord + 0.5) / iChannelResolution[2].xy );
    
    vec2 vQuantizedUV = floor(vScenePixelCoord) * (1.0 / vResolution);
    vec4 vViewmodelSprite = ViewmodelSprite( vQuantizedUV, fLightLevel );

    vResult = mix ( vResult, vViewmodelSprite, vViewmodelSprite.a );
    
    if ( vScenePixelCoord.y < 1.0 )
    {
        return vec4((vec3(70./256.)), 1.);
    }   
    
    return vResult;
}

// Function 4053
float map_detailed(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    // bteitler: Compose our wave noise generation ("sea_octave") with different frequencies
    // and offsets to achieve a final height map that looks like an ocean.  Likely lots
    // of black magic / trial and error here to get it to look right.  Each sea_octave has this shape:
    // http://www.wolframalpha.com/input/?i=%7B1-%7B%7B%7BAbs%5BCos%5B0.16x%5D%5D+%2B+Abs%5BCos%5B0.16x%5D%5D+%28%281.+-+Abs%5BSin%5B0.16x%5D%5D%29+-+Abs%5BCos%5B0.16x%5D%5D%29%7D+*+%7BAbs%5BCos%5B0.16y%5D%5D+%2B+Abs%5BCos%5B0.16y%5D%5D+%28%281.+-+Abs%5BSin%5B0.16y%5D%5D%29+-+Abs%5BCos%5B0.16y%5D%5D%29%7D%7D%5E0.65%7D%7D%5E4+from+-20+to+20
    // which should give you an idea of what is going.  You don't need to graph this function because it
    // appears to your left :)
    float d, h = 0.0;    
    for(int i = 0; i < ITER_FRAGMENT; i++) {
        // bteitler: start out with our 2D symmetric wave at the current frequency
    	d = sea_octave((uv+SEA_TIME)*freq,choppy);
        // bteitler: stack wave ontop of itself at an offset that varies over time for more height and wave pattern variance
    	d += sea_octave((uv-SEA_TIME)*freq,choppy);
        
        h += d * amp; // bteitler: Bump our height by the current wave function
        
        // bteitler: "Twist" our domain input into a different space based on a permutation matrix
        // The scales of the matrix values affect the frequency of the wave at this iteration, but more importantly
        // it is responsible for the realistic assymetry since the domain is shiftly differently.
        // This is likely the most important parameter for wave topology.
    	uv *= octave_m;
        
        freq *= 1.9; // bteitler: Exponentially increase frequency every iteration (on top of our permutation)
        amp *= 0.22; // bteitler: Lower the amplitude every frequency, since we are adding finer and finer detail
        // bteitler: finally, adjust the choppy parameter which will effect our base 2D sea_octave shape a bit.  This makes
        // the "waves within waves" have different looking shapes, not just frequency and offset
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 4054
void MapString(in vec3 world_pos, out Obj obj)
{
	vec3 pos = world_pos + place_pos - vec3(0.0, 85.0,80.0);
	
	float re = MapBox(world_pos + place_pos - vec3(0.0, 85.0,80.0), vec3(56.5,0.001,54.0));
	
	float sinv = sin(-0.66);
	float cosv = cos(-0.66);
	pos.z -= 80.0;
	pos.xz = pos.xz * mat2(cosv, -sinv, sinv, cosv);
	float re_2 = MapBox(pos, vec3(130.0,25.0,60.0));
	re = Subtract(re, re_2);
	
	if (re< EPSILON)
	{
		re_2 = (world_pos.x + 56.5)/113.0*88.0;
		re_2 = abs(fract(re_2) - 0.5);
		if (re_2 < 0.499)
			re = max(re, re_2*2.5681818181818181818181818181818);
	}
	
	if (re< EPSILON)
	{
		obj.m_obj_idx = 7;
	}
	obj.m_dist = re;
}

// Function 4055
float iqsVoronoiDistance( vec2 x ) {
    vec2 p = vec2(floor(x));
    vec2 f = fract(x);

    vec2 mb;
    vec2 mr;

    float res = 8.0;
    for(int j = -1; j <= 1; j++) {
        for(int i = -1; i <= 1; i++) {
            vec2 b = vec2(float(i), float(j));
            vec2 o = random2(p + b);
            o = 0.5 + 0.5 * sin(iTime + 6.2831 * o); // 0 to 1 range
            vec2 r = vec2(b) + o - f;
            float d = dot(r,r);

            if( d < res ) {
                res = d;
                mr = r;
                mb = b;
            }
    	}
    }

    res = 8.0;
    for(int j = -2; j <= 2; j++) {
        for(int i = -2; i <= 2; i++) {
            vec2 b = mb + vec2(float(i), float(j));
            vec2 o = random2(p + b);
            o = 0.5 + 0.5 * sin(iTime + 6.2831 * o); // 0 to 1 range
            vec2 r = vec2(b) + o - f;
            float d = dot(0.5 * (mr + r), normalize(r - mr));

            res = min( res, d );
        }
    }

    return res;
}

// Function 4056
vec4 MapTerrainReflections( vec3 p)
{
    treeDist = 10000.;
  float boatDist= 10000.;
  float bridgeDist=10000.;
  float height = GetTerrainHeight(p); 
  float tHeight= height + GetStoneHeight(p.xz, height);
  tHeight*=1.4;
  if (tHeight>0.)
  {
    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;  
               
      #ifdef TREES   
      vec3 treePos = p-vec3(0.,tHeight+2.,0.);
      vec2 mm = floor( treePos.xz/8.0 );	
	treePos.xz = mod( treePos.xz, 8.0 ) - 4.0;

      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);
      
      if(treeHeight>0.05)
      {             
          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));
                     treeDist+=(noise(p*1.26)*.6285);
         treeDist+=(noise(p*3.26)*.395);
           treeDist+=(noise(p*6.26)*.09825);
      }
    #endif
  }
  #ifdef BRIDGE
    bridgeDist=MapBridge(p);   
  #endif
    #ifdef BOAT
    #ifdef ACCURATE_BOAT_REFLECTION
    boatDist=MapBoat(p); 
    #else
    // fake boat by using ellipsoid
    boatDist=sdEllipsoid( TranslateBoat(p)- vec3(0, -0.20, -1.0), vec3(1.65, 1., 3.40));
    #endif
    
  #endif

    // mask tower position by placing a cone
    return  vec4(min(treeDist,min(min(boatDist, bridgeDist), min(p.y - max(tHeight, 0.), sdConeSection(p-vec3(-143, 0., 292)-vec3(0., 13., 0.), 10.45, 3.70, 1.70)))), boatDist, bridgeDist, tHeight);
}

// Function 4057
float MapFlare( vec3 p, Missile missile)
{
  TranslateMissilePos(p, missile);
  return sdEllipsoid( p+ vec3(0., 0., 2.4), vec3(.05, 0.05, .15));
}

// Function 4058
float doDistance(in vec2 fragCoord, vec2 colorUV) {
    vec2 res2 = iResolution.xy;
    float t = 1.0; //(sin(iTime) + 1.0) / 2.0 + 0.1;
    fragCoord = ((fragCoord / res2 - 0.5) * t + 0.5) * res2;
    //vec2 res2 = vec2(256.0);
    //vec3 col = vec3(0.0);
    vec2 powerOfTwoRes = getRes(res2);
    //vec2 res = res2;
    vec2 uv = floor(fragCoord / res2 * powerOfTwoRes);
    ivec2 div = maxDiv(powerOfTwoRes);
    //vec2 colorUV = fragCoord / iResolution.xy;
    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);
    int m = int(res2.x * res2.y);

	//fragColor *= 0.0;
    int uvIndex = toIndex(uv, powerOfTwoRes);
    //uvIndex = m / 2;
    vec4 frcol = vec4(0.0);
    int index3 = binarySearchLeftMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);
    int index4 = binarySearchRightMost(uvIndex, powerOfTwoRes, res2, fragCoord, frcol);
    //int index3 = binarySearchLeftMost(n, iFrame, res, fragCoord, fragColor);
    //return;
    //index3 = binarySearchLeftMost(n, 0, res);

    mRet mret = getM(index3, res2, powerOfTwoRes);
    int foundIndex = mret.Am;
    vec4 v = mret.v;
    float d = distance(colorUV, v.xy);
    /*ivec2 nfc = ivec2(vec2(fromIndex(index3, res)) * iResolution.xy / res);
    vec4 v = condFetch(iChannel0, nfc, 0);
    int foundIndex = toIndex(v.xy * res, res);

	*/

    int j = 0;
    int a = min(index3, index4);
    int b = max(index3, index4);
    int maxIter = 1;
    int retIndex = -1;
    for (int j = 0; j < maxIter; j++) {
        int i = a + j - maxIter / 2;
        //if (i > b) break;
        /*
        ivec2 nfc = ivec2(vec2(fromIndex(i, res)) * iResolution.xy / res);
        vec4 v = condFetch(iChannel0, nfc, 0);
        int foundIndex = toIndex(v.xy * res, res);
        d = min(d, distance(colorUV, v.xy));
		*/
        mRet mret = getM(i, res2, powerOfTwoRes);
        int foundIndex = mret.Am;
        vec4 v = mret.v;
        float d2 = distance(colorUV, v.xy);
        if (d2 < d) {
            d = d2;
            retIndex = i; //foundIndex;
        }
    }

    /*
    ivec2 nfc2 = ivec2(vec2(fromIndex(index3 + 1, res)) * iResolution.xy / res);
    vec4 v2 = condFetch(iChannel0, nfc2, 0);
    ivec2 nfc3 = ivec2(vec2(fromIndex(index3 + 2, res)) * iResolution.xy / res);
    vec4 v3 = condFetch(iChannel0, nfc3, 0);
    ivec2 nfc4 = ivec2(vec2(fromIndex(index3 + 3, res)) * iResolution.xy / res);
    vec4 v4 = condFetch(iChannel0, nfc4, 0);

    float d1 = distance(colorUV, v.xy);
    float d2 = distance(colorUV, v2.xy);
    float d3 = distance(colorUV, v3.xy);
    float d4 = distance(colorUV, v4.xy);
    float d = min(d1, min(d2, min(d3, d4)));
	*/
    //fragColor = vec4(float((index3 + 100 * iFrame) % n) / float(n));
    //fragColor = vec4(float(index3) / float(n));
    //fragColor = vec4(float(abs(index3 - foundIndex)) / 100000.0);
    //float ret = index3 < 0 ? -1.0 : d;
    return float(retIndex);
}

// Function 4059
float map(vec3 p)
{	
    float t = texture(iChannel1, vec2(0.0, 0.)).x;
    float r = SPHERE.w + displacement(p,1.)*t*15.;
	float d = length(p)-r;
    return d;
}

// Function 4060
scene_params_t getSceneParams( float aTime, vec3 aResolution, vec4 aMouse )
{
	scene_params_t scene_params;

	scene_params.enable_cabin_view = 0;
	scene_params.enable_sun_glare = 1;
	scene_params.enable_sun_flares = 1;
	scene_params.fade = 1.0;

	scene_params.cloud_animation_params.xy = unit_vector2( PI ) * aTime * 1000.0;
	scene_params.cloud_animation_params.z = 1.0; // cloud animation
	scene_params.cloud_animation_params.w = aTime;

	float theta_from_sun_direction = radians( 110.0 * iSlider0 ); // note: theta_from_sun_direction can't be zero, our trace doesn't support it (because b)
	float flying_altitude = cloud_end + 1800.0 + ( 30000. - 1800. ) * iSlider1;
	float plane_yaw = 2.0 * PI * iSlider2 * 1.0;
	float plane_roll = 2.0 * PI * iSlider3 * 1.0;
	float plane_pitch = 2.0 * PI * iSlider4 * 1.0;

	scene_params.tan_half_fovy = iTanHalfFovy;

	vec2 mm = vec2( 0.0, 0.0 );
	vec2 mm0 = mm;
	vec2 mm1 = mm;

	{
		// mouse control
		bool sticky_mouse = false;
		if ( aMouse.z > 0.0 || sticky_mouse ) mm0 = ( aMouse.xy - aResolution.xy * 0.5 ) / ( min( aResolution.x, aResolution.y ) * 0.5 );
		mm1 = mm0;
		mm1 = sign( mm1 ) * pow( abs( mm1 ), vec2( 0.9 ) );
		mm = mm1 * 3.0 * scene_params.tan_half_fovy;
	}

	int camera_index = -1;

	float t0 = 15.0;
	float t1 = 28.0;
	float t2 = 26.0;
	
	float time = aTime;

#if 1

	time = mod( time, t0 + t1 + t2  );
	float t = 0.0;

	float fade_time = 0.5;
	scene_params.fade = saturate( 1.0 -( smoothbump( 0.0, fade_time, time )+
										 smoothbump( t0, fade_time, time )+
										 smoothbump( t0 + t1, fade_time, time )+
										 smoothbump( t0 + t1 + t2, fade_time, time ) ) );
	 
	     if ( time < t0      ) { camera_index = 0;                  t = time / t0; }
	else if ( time < t0 + t1 ) { camera_index = 1; time -= t0;      t = time / t1; }
	else                       { camera_index = 2; time -= t0 + t1; t = time / t2; }

#else

	float loop_time = t2;
	camera_index = 2;
	time = mod( time, loop_time );
	float t = time / loop_time;
	
#endif

	if ( camera_index == 0 ) // sunset
	{
		theta_from_sun_direction = radians( 90.0 );
		flying_altitude = cloud_end + 1800.0 * mix( 1.5, 3.5, t );
		mm.x += exp_decay( pow(time,2.0) * 0.015 ) * 1.0;
		mm.y -= t * 0.6;
		
		scene_params.cloud_animation_params.xy = unit_vector2( plane_yaw ) * aTime * 5000.0;
	}
	else if ( camera_index == 1 ) // flight
	{
		theta_from_sun_direction = radians( 80.0 );
		float lookup = 1.0 - 0.82 * exp_decay( time * 0.1 );
		mm.y -= lookup;
	}
	else if ( camera_index == 2 ) // cabin
	{
		theta_from_sun_direction = radians( mix( 91.0, 70.0, t ) );
		flying_altitude = cloud_end + 6000.0;
		scene_params.enable_cabin_view = 1;
		scene_params.tan_half_fovy = 0.51;
		plane_yaw = radians( 39.0 );
		scene_params.cloud_animation_params.xy = -unit_vector2( plane_yaw ) * aTime * 1000.0;

		if ( aMouse.z <= 0.0 )
		{
			mm0.x -= smoothband( time, 6.0, 11.0, 2.0 ) * 0.18;
			mm0.y -= smoothband( time, 6.2, 12.0, 2.0 ) * 0.10;
		}

		// todo: make the clamp below smoother...
		mm1 = clamp( mm0, vec2( -0.2, -0.32 ), vec2( +0.6, +0.3 ) );
		mm1 = sign( mm1 ) * pow( abs( mm1 ), vec2( 0.9 ) );
		mm = mm1 * 3.0 * scene_params.tan_half_fovy;
	}

	mat4 tmp = zup_spherical_coords_to_matrix( theta_from_sun_direction, 0.0 );

	scene_params.sun_direction = vec3( 0., 0., 1. ); // no point in changing this
	vec3 cloud_plane_n = tmp[2].xyz;

	scene_params.b.x = tmp[0].xyz;
	scene_params.b.y = tmp[1].xyz;
	scene_params.b.z = tmp[2].xyz;
	scene_params.b.o = earth_radius * cloud_plane_n; // ground point

	scene_params.camera[0].xyz = tmp[1].xyz;
	scene_params.camera[1].xyz = tmp[2].xyz;
	scene_params.camera[2].xyz = tmp[0].xyz;
	scene_params.camera[3].xyz = cloud_plane_n * ( earth_radius + flying_altitude );

	if ( camera_index == 1 ) applyFlyingCamera( scene_params, time );

	mat4 mouse_rotation = yup_spherical_coords_to_matrix( mm.y, -mm.x );
	scene_params.camera = scene_params.camera * mouse_rotation;

	if ( scene_params.enable_cabin_view == 1 )
	{
		scene_params.plane_to_world = tmp; // plane is local so origin is 0,0,0

		float noise_rotation_amplitude = 1.15;
		scene_params.plane_to_world = scene_params.plane_to_world
			* zup_spherical_coords_to_matrix_rollx(
			unit_vector2( plane_pitch + noise_rotation_amplitude * sin( (time)*2. * PI / 9.0 ) * 0.01 ),
			unit_vector2( plane_yaw + noise_rotation_amplitude * sin( ( time - 3.0 ) * 2. * PI / 10.0 ) * 0.01 ),
			unit_vector2( plane_roll + noise_rotation_amplitude * sin( ( time + 4.0 ) * 2. * PI / 11.0 ) * 0.01 ) );

		// plane needs to be traced with saner float ranges so origin same as plane local offset from here
		scene_params.plane_render_camera[0] = scene_params.plane_to_world[0];
		scene_params.plane_render_camera[1] = scene_params.plane_to_world[2];
		scene_params.plane_render_camera[2] = -scene_params.plane_to_world[1];
		scene_params.plane_render_camera[3] = scene_params.plane_to_world[3]
			+ scene_params.plane_to_world[0] * 0.30 // move along plane
			+ scene_params.plane_to_world[1] * 5.30 // get closer to the window
			+ scene_params.plane_to_world[2] * 0.75 // up and down
		;

		scene_params.plane_render_camera
			= scene_params.plane_render_camera
			* x_rotation( radians( -4.5 ) )
			* y_rotation( radians( 15.0 ) );

		{
			// vector that looks at windows center
			vec3 z = -scene_params.plane_render_camera[3].xyz;

			// move along plane
			scene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[0].xyz
				* ( ( smoothstep( 0.0, 0.12, abs( mm1.x ) ) )
					* max( mm1.x, 0. ) * -1.2 );

			// up and down
			scene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[2].xyz
				* ( smoothstep( 0.1, 0.4, abs( mm1.y ) ) )
				* max( -mm1.y, 0. ) * 0.65;

			// get closer to the window
			scene_params.plane_render_camera[3].xyz -= z
				* maxcomp( smoothstep( 0.1, 0.4, abs( mm1 ) ) * abs( mm1 ) ) * 0.1;

			// translate closer to the window when looking left and down
			scene_params.plane_render_camera[3].xyz += scene_params.plane_to_world[1].xyz
				* smoothstep( 0.0, 0.025, abs( mm1.x ) * max( -mm1.x, 0. ) ) * 0.3;
		}

		scene_params.plane_render_camera = scene_params.plane_render_camera * mouse_rotation;
		
		scene_params.camera[0] = scene_params.plane_render_camera[0];
		scene_params.camera[1] = scene_params.plane_render_camera[1];
		scene_params.camera[2] = scene_params.plane_render_camera[2];
	}

	return scene_params;
}

// Function 4061
float mapEdge(in vec3 rp)
{
    rp.x += getCurve(rp);
    float edgeL = -1.;
    float difx = 1.-abs(rp.x);
    return difx;
}

// Function 4062
float BezierDistance( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in float width)
{    
    vec3 a = B - A;
    vec3 b = A - 2.0*B + C;
    vec3 c = a * 2.0;
    vec3 d = A - pos;
    float kk = 1.0/dot(b,b);
    float kx = kk * dot(a,b);
    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
    float kz = kk * dot(d,a);      
    float res = 0.0;
    float p = ky - kx*kx;
    float p3 = p*p*p;
    float q = kx*(2.0*kx*kx-3.0*ky) + kz;
    float h = q*q + 4.0*p3;
    if( h >= 0.0) 
    { 
        h = sqrt(h);
        vec2 x = (vec2(h,-h)-q)/2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
        res = dot2(d + (c + b*t)*t);
    }
    else
    {
        float z = sqrt(-p);
        float v = acos( q/(p*z*2.0) ) / 3.0;
        float m = cos(v);
        float n = sin(v)*1.732050808;
        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
        res = min( dot2(d+(c+b*t.x)*t.x),
                   dot2(d+(c+b*t.y)*t.y) );
        // the third root cannot be the closest
        // res = min(res,dot2(d+(c+b*t.z)*t.z));
    }
    return sqrt( res ) - width;
}

// Function 4063
float scene(vec3 rayPos)
{
   float dist_a = sphere(rayPos, vec3(-0.0, -0.0, 0.0), 3.0);
   float dist_b = sdPlane(rayPos, vec4(0.0, 1.0, 0.0, 1.0));
   float booleanFloor = max(dist_b, -dist_a); // this cuts a sphere into the plane
  
   //return min(uberSphere(rayPos),booleanFloor); //this combines the floor with our uber sphere for the final scene
   return min(uberSphere(rayPos),dist_b); // simplifed the scene with this line. comment this out and uncomment the above line for some additional boolean logic
}

// Function 4064
vec2 remapUV(vec2 uv) {
    uv = uv * 2. -1.;
    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);
    uv = uv + uv * offset * offset;
    uv = uv * .5 + .5;
    return uv;
}

// Function 4065
vec4 scene_obj_runway( vec4 col, SceneObj obj, vec3 r, mat2x3 Kr )
{
    vec3 dr = 1000. * ( r - obj.r );
    if( dot( dr, dr ) < 2. * dot( obj.paramsB.xy, obj.paramsB.xy ) )
    {
        vec2 uv = ( dr * obj.B ).xy;
        mat2 K = 1000. * mat2( obj.B[0] * Kr, obj.B[1] * Kr );

        // tarmac
        float d;
        d = aaa_box( K, uv, obj.paramsB.xy, obj.paramsB.zw );
        vec3 albedo = irselect( g_matdata[int( abs( obj.paramsA.x ) )].omega, ( g_game.switches & GS_IRCAM ) != 0u );
        col = mix( col, vec4( albedo, 1 ), d );

        // paintings
        if( obj.paramsA.w > 0. )
        {
            d = ( scene_obj_runway_centerline( K, uv, obj.paramsB.xy ) +
                  scene_obj_runway_threshold_markers( K, uv, obj.paramsB.xy ) );
            col = mix( col, vec4( obj.paramsA.www, 1 ), d );
        }
    }
    return col;
}

// Function 4066
float sdfRoundCone( vec3 p, float r1, float r2, float h, mat4 t){
  p = vec3(t * vec4(p, 1));
  vec2 q = vec2( length(p.xz), p.y );
    
  float b = (r1-r2)/h;
  float a = sqrt(1.0-b*b);
  float k = dot(q,vec2(-b,a));
    
  if( k < 0.0 ) return length(q) - r1;
  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;
        
  return dot(q, vec2(a,b) ) - r1;
}

// Function 4067
vec2 sceneFromFrag(vec2 f) {
    return (f - sceneOrigin) * px;
}

// Function 4068
float sea_geometry_map(vec3 p) 
{
    #if WATER_TYPE == WAVES_WATER
    vec2 uv = p.xz * vec2(0.85, 1.0);
	
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    
    float d = 0.0;
    float h = 0.0;    
    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) 
    {   
		#if FANTASY_WATER_PATH
	   	if (uv.x > UV_START_X && uv.x < UV_END_X)
	   	{
			continue;
	   	}
		#endif

    	d =  sea_octave((uv + SEA_CURRENT_TIME) * freq, choppy);
    	d += sea_octave((uv - SEA_CURRENT_TIME) * freq, choppy);
        h += d * amp; 
	    
		freq *= SEA_GEOMETRY_FREQ_MUL; 
		amp  *= SEA_GEOMETRY_AMPLITUDE_MUL;
	    
        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);
	    
		uv *= octave_matrix; 
    }
    return p.y - h;
    #else
    return p.y;
    #endif
}

// Function 4069
vec3 GetSceneNormal( const in vec3 vPos )
{
	// tetrahedron normal
	float fDelta = 0.025;

	vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);
	vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);
	vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);
	vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);

	float f1 = GetDistanceScene( vPos + vOffset1 ).x;
	float f2 = GetDistanceScene( vPos + vOffset2 ).x;
	float f3 = GetDistanceScene( vPos + vOffset3 ).x;
	float f4 = GetDistanceScene( vPos + vOffset4 ).x;

	vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;

	return normalize( vNormal );
}

// Function 4070
vec3 SampleLightsInScene(
	vec3 P,
	vec3 N,
	bool haltonEnabled,
	vec2 offset,
	int objId,
	int frameIndex, // iFrame
	int numLightSamples,
	inout uint wasSampled)
{
	bool sphericalLightIsTextured = false; // enable this if SampleLightColor needs position for spherical lights
	vec3 e = vec3(0);
	for (int lightId = 0; lightId < NO_UNROLL_(NUM_OBJECTS, objId); lightId++) {
		Object light = objects[lightId];
		if (IsQuad(light) && dot(light.pos - P, light.quadNormal) >= 0.0) { // facing away?
			wasSampled |= (1U << lightId); // might as well mark this light as sampled, we won't hit it in the next bounce
			continue;
		}
		if (ShouldSampleLight(P, N, light, e)) {
			vec3 l = vec3(0);
			if (MIS_enabled) {
				float q = MIS_ratio_default; // controls ratio N_h / N_d (hemisphere samples to direct light samples)
				if (MIS_light_dist_enabled && MIS_light_dist_max > 0.0) {
					float dmax = MIS_light_dist_max;
					float dmin = min(dmax - 0.0001, MIS_light_dist_min);
					float ds = 1.0/(dmin - dmax);
					float d0 = -ds*dmax;
					q = clamp(DistanceToObject(P, light)*ds + d0, 0.0, 1.0);
				}
				if (MIS_light_dist_dbg)
					e += vec3(q*q);
				int N_h = int(floor(0.5 + float(numLightSamples)*q)); // [0..numLightSamples]
				int N_d = numLightSamples - N_h; // [0..numLightSamples]
				for (int i = 0; i < N_d; i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_d)) : rand2(seed);
					l += SampleLightMIS_d(light, lightId, objId, P, N, s, float(N_d), float(N_h), sphericalLightIsTextured);
				}
				for (int i = 0; i < N_h; i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*N_h)) : rand2(seed);
					l += SampleLightMIS_h(light, lightId, objId, P, N, s, float(N_d), float(N_h));
				}
			} else {
				for (int i = 0; i < NO_UNROLL_(numLightSamples, objId); i++) {
					vec2 s = haltonEnabled ? fract(offset + Halton23(i + frameIndex*numLightSamples)) : rand2(seed);
					l += SampleLight(light, lightId, objId, P, N, s, sphericalLightIsTextured);
				}
				l /= float(numLightSamples);
			}
			e += l;
			wasSampled |= (1U << lightId);
		}
	}
	return e;
}

// Function 4071
float GetDist(vec4 p) {
    float t = iTime*2. - 5.;

    mat4 R2 = mat4(1);
    
    //Create rotation matrix to rotate our cube
    mat4 R = rotXW(1.0*t) * rotXY(0.25*t) * rotXZ(0.5*t) * rotYZ(1.75*t);// * rotYW(1.0*t) * rotZW(1.0*t);
    //mat4 R = rotationMatrix(vec4(sin(iTime), 0., cos(iTime),0.), iTime/10.);
   
    vec4 cu = vec4(0.,1. ,6. ,0.);
    float c = sdRoundHypercuboid(R*(p-cu),vec4(1.,1.25,1.,1.), 0.4);
    //float c = hypercube(R*(p - cu), 1.25);
    
    //Wobbly, noisy floor
    float floorDist = p.y + 0.005*sin(p.z*80.*(5. + 4.*sin(t/8.))) + sin(t)*8.*pow(sin((p.x + p.w)/20.),2.) + 0.5*sin(p.x/2. + t/2.)*sin(p.z/2. + t/3.)*cos(p.z+p.x) + 1.5;
    
    //Add a wall/sky so that the noisy floor looks like a floor
    float wallDist = (p.w) + 4.0;
    
    float d = min(c, floorDist);
    d = min(d, wallDist);
    
    return d;
}

// Function 4072
bool intersectScene(inout Ray ray, out vec4 color, out HitRecord hitRecord){
    const vec3 objColor = vec3(0.5, 0.2, 0.4);
    const vec3 groundColor = vec3(0.1, 0.8, 0.7);
    const vec3 lightDir = normalize(vec3(1, 1, 1));
    
    bool intersect = false;
    
    float animLength = 6.14;
    float t = iTime - float(int(iTime / animLength)) * animLength;
      
    Plane background;
    background.P0 = - vec3(0, 0, 9000);
    background.N = vec3(0, 0, 1);
        
    const int nSpheresDim = 5;
    const float radius = 75.0;
    vec3 sphereCenter = vec3(float(-nSpheresDim / 2 - 1) * 2.5 * radius, radius, float(-nSpheresDim / 2) * 2.5 * radius);
    vec3 translationX = vec3(2.5 * radius, 0.0, 0.0);
    vec3 translationZ = vec3(0.0, 0.0, 2.5 * radius);
    
    Sphere sphere;
    sphere.center = sphereCenter;
    sphere.radius = radius;
    
    Plane ground;
    ground.P0 = sphereCenter - vec3(0.0, radius, 0.0);
    ground.N = vec3(0, 1, 0);
    
    for(int j = 0; j < nSpheresDim; j++){
        sphere.center = sphereCenter + float(j) * translationZ;
    	for(int i = 0; i < nSpheresDim; i++){        
            int mat_id = 3;

            sphere.center = sphere.center + translationX;
            if(i + j - 2 * ((i+j) / 2) == 1){
                mat_id = 2;
            }

            if(intersect_sphere(ray, sphere, hitRecord)){
               vec3 reflection_vec = reflect(hitRecord.normal, -lightDir);
               hitRecord.mat_id = mat_id;
               hitRecord.color = objColor;
               //color = vec4(objColor * abs(dot(hitRecord.normal, lightDir)), 1.0);
               //color = vec4(objColor, 1.0);
               float ambient  = 0.4;                
               float diffuse  = (dot(hitRecord.normal, -lightDir));
               float specular = pow((dot(reflection_vec, -ray.dir)), 100.0);
               color = vec4(objColor * clamp((diffuse + specular), ambient, 1.0), 1.0);
               intersect = true;
            }
        }
    }
    
    if(intersect_plane(ray, background, hitRecord)){
        hitRecord.mat_id = 0;
        hitRecord.color = (ray.dir + vec3(1.0)) / 2.0;
        color = vec4((ray.dir + vec3(1.0)) / 2.0, 1.0) * vec4(hitRecord.color, 1.0);
        intersect = true;
    }
    
    if(intersect_plane(ray, ground, hitRecord)){
        hitRecord.mat_id = 2;
        hitRecord.color = groundColor;
        color = vec4(groundColor * dot(hitRecord.color, lightDir), 1.0);
        intersect = true;
    }
    
    return intersect;
	//else fragColor = back_color(fragCoord2d);
}

// Function 4073
float pointDistanceToLine(vec2 point, vec2 vert1, vec2 vert2){
    float top = abs((vert2.y-vert1.y)*point.x-(vert2.x-vert1.x)*point.y+vert2.x*vert1.y-vert2.y*vert1.x);
    float bottom = distance(vert1,vert2);
    return top/bottom;
}

// Function 4074
float map(vec3 p){
    
    // Floor.
    float fl = -p.z + 64.251;

    // The extruded blocks.
    vec4 d4 = blocks(p);
    gID = d4.yzw; // Individual block ID.
    
 
    // Overall object ID.
    objID = fl<d4.x? 1. : 0.;
    
    // Combining the floor with the extruded image
    return  min(fl, d4.x);
 
}

// Function 4075
float map2( in vec3 pos )
{
    return min( pos.y+1.0, map(pos).x );
}

// Function 4076
float triangleDist(vec2 p, float radius)
{
	return max(	abs(p).x * 0.866025 + 
			   	p.y * 0.5, -p.y) 
				-radius * 0.5;
}

// Function 4077
float Heightmap(vec3 pos)
{
    float octaves     = TimeLerp(1.0, 7.0, TIME_NoiseScale, TIME_NoiseOctaves);  
    float scale       = TimeLerp(1.0, 0.005, TIME_Noise, TIME_NoiseScale);
    float persistence = 0.35;
    float heightMod   = TimeLerp(1.0, 2.05, TIME_NoiseScale, TIME_NoiseOctaves);
    
    float noise = SimplexNoise(pos, octaves, scale, persistence) * heightMod;
    
    return clamp(((noise / heightMod) + 1.0) * 0.5, 0.0, 1.0);
}

// Function 4078
vec4 scene(vec3 p)
{
    vec3 cent1 = vec3 (6.3, (sin((iTime + 9.0) * 2.3) + 1.0) * 1.3, 0.0);
    vec3 cent2 = vec3 (4.15, (sin((iTime + 6.0) * 2.3) + 1.0) * 1.3, 0.0);
    vec3 cent3 = vec3 (2.075, (sin((iTime + 3.0) * 2.3) + 1.0) * 1.3, 0.0);
    vec3 cent4 = vec3 (0.0, (sin(iTime * 2.3) + 1.0) * 1.3, 0.0);
    vec3 cent5 = vec3 (-2.075, (sin((iTime - 3.0) * 2.3) + 1.0) * 1.3, 0.0);
    vec3 cent6 = vec3 (-4.15, (sin((iTime - 6.0) * 2.3) + 1.0) * 1.3, 0.0);
    
    float sp1 = length (p - cent1) - 1.0;
    float sp2 = length (p - cent2) - 1.0;
    float sp3 = length (p - cent3) - 1.0;
    float sp4 = length (p - cent4) - 1.0;
    float sp5 = length (p - cent5) - 1.0;
    float sp6 = length (p - cent6) - 1.0;
    float finalDist = min (min (min (sp1, sp2), min (sp3, sp4)), min (min (sp5, sp6), p.y + 1.0));
    vec4 retVal;
    
    if ( finalDist == sp1 )
    {
        retVal.gba = cent1;
    }
    else if ( finalDist == sp2 )
    {
        retVal.gba = cent2;
    }
    else if ( finalDist == sp3 )
    {
        retVal.gba = cent3;
    }
    else if ( finalDist == sp4 )
    {
        retVal.gba = cent4;
    }
    else if ( finalDist == sp5 )
    {
        retVal.gba = cent5;
    }
    else if ( finalDist == sp6 )
    {
        retVal.gba = cent6;
    }
    retVal.r = finalDist;
    return retVal;
}

// Function 4079
vec2 map(vec3 p, float i)
{
	float lp = length(p);
    vec3 bg = vec3(0.);   
    vec3 en = path(i,lp);
    
    float ins = smoothstep(0.11,.46,lp);
    float outs = .15+smoothstep(.0,.15,abs(lp-1.));
    p *= ins*outs;
    float id = ins*outs;
    
    float rz = segm(p, bg, en)-0.011;
    return vec2(rz,id);
}

// Function 4080
float scene(vec3 p)
{
	float d = .5-abs(p.y);
	d = min(d, ribbon1(p) );
	d = min(d, ribbon2(p) );
	d = min(d, ribbon3(p) );
	d = min(d, ribbon4(p) );
	
	return d;
}

// Function 4081
float styleIconDist(vec2 p, float sz, int style) {
    
    float s = sign(p.x*p.y);
    
    p = abs(p);
    
    // outside edge dist
    vec2 a = vec2(0, sz);
    vec2 b = vec2(sz, 0);
    float l = lineDist2D(a, b, p);
    
    if (style == STYLE_DRAW_GENERATOR) {
        float c = length( p - (p.x > p.y ? b : a)*0.8 );
        return c - 0.2*sz;
    } else if (style == STYLE_DRAW_POLYGONS) {
        return abs(l + 0.04*sz) - 0.08*sz;
    } else if (style == STYLE_DRAW_TRIANGLES) {
        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;
    } else if (style == STYLE_DRAW_CIRCLES) {
        float c = length(p) - 0.65*sz;
        return max(l, -c);
    } else {
        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);
    }
    
}

// Function 4082
float sdf_intersection(float a, float b)
{
    return max(a, b);
}

// Function 4083
float GGX_Distribution(vec3 wh, float alpha_x, float alpha_y) {
    float tan2Theta = tanTheta2(wh);
    if(alpha_x == alpha_y){
    	//------when alpha_x == alpha_y so
    	float c = alpha_x + tan2Theta/alpha_x;
    	return 1.0/(PI*cosTheta4(wh)*c*c);
	}else{
		float alpha_xy = alpha_x * alpha_y;
		float e_add_1 = 1. + tan2Theta / alpha_xy;
    	return 1.0 / (PI * alpha_xy * cosTheta4(wh) * e_add_1 * e_add_1);
	}
}

// Function 4084
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, bgCol, vn, lVec, rg;
  vec2 vf;
  float dstObj, a, s, fFade;
  bool fxz;
  crRad = 2.;
  crLen = 5.;
  bgCol = mix (0.6 * vec3 (0.4, 0.4, 0.5), vec3 (0.21), smoothstep (-0.01, 0.01, rd.y));
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    cId = floor (ro / bSize);
    SetEngConf ();
    vn = ObjNf (ro);
    vf = vec2 (0.);
    fFade = exp (32. * min (0., 0.7 - dstObj / dstFar));
    if (idObj == idFlr) {
      if (vn.y > 0.99) {
        col4 = vec4 (0.4, 0.4, 0.5, 0.1);
        rg = ShGrid (ro.xz);
        col4.rgb *= mix (1., rg.y, fFade) * (1. - 0.3 * Fbm2 (2. * ro.xz));
        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z * fFade);
        else vn.yx = Rot2D (vn.yx, rg.x * fFade);
        col4 *= (1. - 0.5 * smoothstep (12., 16., length (qHit.xz)));
        vf = vec2 (32., 1.);
      } else if (vn.y < -0.99) {
        col4 = vec4 (vec3 (0.3) * (1. - 0.3 * smoothstep (3., 7.,
           length (abs (qHit.xz) - 6.))), -1.);
      } else {
        col4 = vec4 (0.3, 0.3, 0.3, 0.1);
        vf = vec2 (32., 1.);
      }
    } else if (idObj == idBase) {
      col4 = vec4 (0.6, 0.3, 0.2, 0.1);
      if (abs (vn.y) < 0.01) {
        rg = ro;
        rg.y += 0.5;
        fxz = (abs (vn.x) > 0.99);
        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));
        rg.xz *= sign (fxz ? vn.x : vn.z);
        if (fxz) {
          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);
          else vn.xz = Rot2D (vn.xz, rg.x);
        } else {
          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);
          else vn.zx = Rot2D (vn.zx, rg.x);
        }
      } else {
        rg = ShGrid (ro.xz);
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);
        if (vn.y > 0.99) {
          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);
          else vn.yx = Rot2D (vn.yx, rg.x);
        }
      }
      vf = vec2 (32., 1.);
    } else if (idObj == idCol) {
      col4 = vec4 (0.8, 0.8, 0.75, 0.05);
      vf = vec2 (32., 1.);
    } else if (idObj == idCyl) {
      col4 = vec4 (0.8, 0.8, 0.9, 0.3);
      a = atan (qHit.z, - qHit.y) / (2. * pi);
      if (abs (vn.x) > 0.99) {
        col4.rgb *= 1. - 0.2 * Fbm2 (4. * qHit.yz);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *
           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));
      } else {
        col4.rgb *= 1. - 0.2 * Fbm2 (4. * vec2 (8. * a, qHit.x));
        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));
        a = mod (32. * a, 1.);
        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *
           sign (a - 0.5));
      }
    } else if (idObj == idWhl) {
      if (abs (vn.z) < 0.01) {
        s = length (qHit.xy);
        qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);
        if (s > 4.1) {
          s = mod (4. * qHit.z, 1.);
          vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (ro.z);
          vn = normalize (vn);
        }
      }
      col4 = vec4 (0.5, 0.5, 0.55, 0.05) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));
    } else if (idObj == idSpk) {
      col4 = 1.1 * vec4 (0.5, 0.5, 0.55, 0.2);
    } else if (idObj == idCrnk) {
      col4 = vec4 (0.5, 0.5, 0.6, 0.2);
    } else if (idObj == idAx) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.3);
    } else if (idObj == idPis) {
      col4 = vec4 (0.5, 0.5, 0.2, 0.3);
    } else if (idObj == idCrod) {
      col4 = vec4 (0.6, 0.6, 0.5, 0.3);
    } else if (idObj == idCylEnt) {
      col4 = vec4 (0.7, 0.7, 0.8, 0.2) * (1. - 0.5 * step (length (qHit.yz), 0.33));
    } else if (idObj == idValv) {
      col4 = vec4 (0.7, 0.7, 0.8, 0.5) * (1. - 0.5 * step (0., vn.x) *
         step (length (qHit.yz), 0.13));
      vf = vec2 (32., 0.3);
    } else if (idObj == idPipes) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.1);
      vf = vec2 (32., 0.3);
    } else if (idObj == idSup) {
      col4 = vec4 (0.2, 0.4, 0.1, 0.05);
      vf = vec2 (32., 1.);
    } else if (idObj == idRail) {
      col4 = vec4 (0.2, 0.4, 0.2, 0.1);
      vf = vec2 (32., 0.2);
    } else if (idObj == idLt) {
      qHit.xz = smoothstep (0.05, 0.1, abs (qHit.xz));
      col4 = vec4 (vec3 (1., 1., 0.8) * 0.5 * (1. - vn.y) * (0.7 + 0.3 * qHit.x * qHit.z), -1.);
    }
    if (col4.a >= 0.) {
      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);
      lVec = normalize (vec3 (1., 1.3, 1.));
      col = 0.2 * col4.rgb;
      for (float sx = -1.; sx <= 1.; sx += 2.) {
        for (float sz = -1.; sz <= 1.; sz += 2.) {
          col += 0.5 * col4.rgb * max (dot (vn, lVec * vec3 (sx, 1., sz)), 0.) +
             col4.a * pow (max (dot (normalize (lVec * vec3 (sx, 1., sz) - rd), vn), 0.), 64.);
        }
      }
      col *= 0.7 + 0.3 * ObjSShadow (ro, vec3 (0., 1., 0.));
    } else col = col4.rgb;
    col = clamp (mix (bgCol, col, fFade), 0., 1.);
  } else col = bgCol;
  if (! colImg) col = pow (vec3 (1., 0.59, 0.18) * RgbToVal (col), vec3 (0.9));
  if (marchImg) col = HsvToRgb (vec3 (0.7 * (1. - stepCnt / 180.), 1., 1.));
  return col;
}

// Function 4085
float heightmap(vec2 uv)
{
    return heightMapParams.x*texture(iChannel0, (uv + iTime*heightMapParams.zw)*heightMapParams.y).x;
}

// Function 4086
float map( vec3 q )
{
    vec3 p = mapP( q );
    float d = length( p ) - 1.5;
	return d * 0.05;
}

// Function 4087
vec4 map(vec3 p, vec3 rd) 
{
	float nv = noise((p.xy + p.xz + p.yz) * 3.0);
	float dis = -udRoundBox(p - vec3(0.0, 1.0, 0.0), vec3(23.0, 5.0, 22.0), 5.0);
	vec4 box = vec4(dis, vec3(0.3, 0.3, 0.3));
	vec3 c1 = vec3(3,3,3);
	vec3 q1 = mod(p, c1)- 0.5*c1;
	vec4 floor = vec4(sdBox(vec3(q1.x, p.y + 10.5, q1.z), vec3(1, 1, 1)), vec3(0.3, 0.3, 0.3));
	//floor = disMin(floor, vec4(sdBox(vec3(q1.x, p.y - 13.5, q1.z), vec3(1, 1, 1)), vec3(0.3, 0.3, 0.3)));

	vec2 c = vec2(25, 7);
	vec3 q = vec3(mod(p.x, c.x)- 0.5*c.x, p.y, mod(p.z, c.y) - 0.5*c.y);
	vec4 table = vec4(sdBox(p - vec3(0, -7, 22), vec3(6, 3, 5)), vec3(0.2, 0.2, 0.2));
	table = sun(table, vec4(sdBox(p - vec3(0, -7, 22), vec3(4, 4, 5.3)), vec3(0.2, 0.2, 0.2)));
	vec4 pillars = vec4(sdBox(q - vec3(0, -9, 0), vec3(0.5, 22, 0.5)), vec3(0.2, 0.2, 0.2));
	vec4 disRoom = sun(floor, sun(pillars, sun(table, box)));
	return disMin(symbol(p), disRoom);
}

// Function 4088
float	scene(vec3 p)
{  
    float	var;
    float	mind = 1e5;
    float	cage = 1e5;
    p.z -= sin(iTime*.25+3.14)*4.;
    rotate(p.xz, 1.57-.35*iTime );
    rotate(p.yz, 1.2-1.*.5*iTime );
    float ball = 1e5;
    p.xz = modA(p.xz, 25.);
    p.x -= mix(25., 0., sin(iTime*.125-2.)*.5+.5);
    p.yx = mix(modA(p.yx, 25.), modA(p.yx, 4.), sin(iTime*.5)*.5 + .5);
    p.y -= 20.;

    ball = min(ball, (length(p.xy)-.105101) );
    ball = min(ball, (length(p.zy)-.105101) );
    ball = min(ball, (length(p.y)+.0001) );

    mind = min(mind, ball);
    return (mind);
}

// Function 4089
vec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01)
{
    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));
    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));
    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));
    return linearGammaColor;
}

// Function 4090
vec3 MapColor(vec3 srgb)
{
    #ifdef USE_ACESCG
    return srgb * sRGBtoAP1;
    #else
    return srgb;
    #endif
}

// Function 4091
float map( in vec3 pos )
{
    float d1 = length( pos.xz - sph1.xz );
    float d2 = length( pos.xz - sph2.xz );//#
    float d3 = length( pos.xz - sph3.xz );//#
    
    float d = -log( exp( -d1 ) + exp( -d2 ) + exp( -d3 ));//#
    
    float h = 1.0-2.0/(1.0 + 0.3*d*d);
    
    return pos.y - h;
}

// Function 4092
float getCubeDist(vec3 p) {
    vec3 toCorner = abs(p) - 1.;
    
    //the max is to make sure that the exterior
    //dist is zero when inside the cube
    float exteriorDist = length(max(toCorner, 0.));
    
    //max of z y & z
	float interiorDist = max(toCorner.x, max(toCorner.y, toCorner.z));
    
    //interior dist should never be positive
    interiorDist = min(interiorDist, 0.);
    
    return interiorDist + exteriorDist;
}

// Function 4093
float sdf_x(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -8, 0)));
    return t;
}

// Function 4094
float map(vec3 p)
{
    vec4 tex = texture(iChannel2,p.xy / uvSize);
    float scale = scale;

	float prim =  sphere(p,5.0+scale); 
	float prim3 = curveSphereToPlane(p,prim+1.0);
    
    float dist  = displacement(p / uvSize, prim);
    float dist3 = prim3;
    
    float time = mod(iTime,200.0) * .1;
    dist = smin(dist,dist3, time);
    
    
    return dist * length(tex);
}

// Function 4095
float SceneDf (vec3 p)
{
  vec4 pCar;
  vec3 q;
  float dMin, d;
  int pxcMin;
  dMin = dstFar;
  if (showDec >= 1) {
    q = p;  q.z = abs (q.z - 0.5);
    d = PrBoxDf (q, vec3 (0.3, 0.7 * rlSize.y, 0.3));
    DMIN (idRbase);
    q = p;  q.xy -= vec2 (0.27 * sign (q.z - 0.5), 0.05);
    q.z = abs (q.z - 0.5) - 0.16;
    d = PrCapsDf (q.xzy, 0.017, 0.05);
    DMIN (idXingV);
    q = p;  q -= vec3 (0.25, 0.03, 0.66);
    q.xy = Rot2D (q.xy, angX);  q.xy -= vec2 (-0.22, 0.05);
    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); 
    DMINQ (idXingB);
    q = p;  q -= vec3 (-0.25, 0.03, 0.34);
    q.xy = Rot2D (q.xy, - angX);  q.xy -= vec2 (0.22, 0.05);
    q.x *= -1.;
    d = PrBoxDf (q, vec3 (0.2, 0.008, 0.005)); 
    DMINQ (idXingB);
    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);
    d = PrBoxDf (q, vec3 (0.9, 1.5 * rlSize.y, 0.12));
    DMIN (idPlatB);
    q.x = abs (q.x) - 0.4;  q.yz -= vec2 (0.07, 0.08);
    d = max (PrBoxDf (q, vec3 (0.24, 0.09, 0.035)),
       - PrBoxDf (q, vec3 (0.22, 0.08, 0.04)));
    DMIN (idPlatU);
  }
  if (showDec >= 2) {
    q = p;  q.yz -= vec2 (1.5 * rlSize.y, -2.32);
    q -= vec3 (0.8, 0.1, -0.05);
    d = PrCylDf (q.xzy, 0.01, 0.1);
    DMIN (idSigV);
    q.y -= 0.1;
    d = PrSphDf (q, 0.02);
    DMIN (idSig);
    q = p;  q.x = abs (q.x) - 2.48;  q.z -= 1.5;
    d = max (PrCylAnDf (q, 0.16, 0.005, 0.4), - q.y - 0.04);
    DMINQ (idTun);
    q = p;  q.xz = abs (q.xz) - 1.5;  q.y -= 0.14 - 0.04;
    d = PrCylDf (q.xzy, 0.03 * (1. - q.y), 0.14);
    DMINQ (idTrunk);
    q.y -= 0.17;
    d = PrCapsDf (q.xzy, 0.1 * (1. - 2. * q.y), 0.03);
    DMINQ (idTree);
  }
  if (showTrn > 0) {
    dMin /= szFac;
    pxcMin = 5;
    for (int k = VAR_ZERO; k < N_CAR; k ++) {
      pCar = Loadv4 (pxcMin + (showTrn - 1) * N_CAR + k);
      pCar.y = 2.7 * rlSize.y + 0.06;
      q = p;  q -= pCar.xyz;
      q.xz = Rot2D (q.xz, pCar.w);
      dMin = CarDf (q / szFac, dMin, (k > 0) ? ((k < N_CAR - 1) ? 0. : -1.) : 1.);
    }
    dMin *= szFac;
  }
  return dMin;
}

// Function 4096
vec3 NormalMapTex( vec2 uv )
{
	float eps = -1.0 / 256.0;        
    float a = texture( iChannel2, uv + vec2( 0.0, 0.0 ) ).x;
	float b = texture( iChannel2, uv + vec2( eps, 0.0 ) ).x;
    float c = texture( iChannel2, uv + vec2( 0.0, eps ) ).x;
	return -normalize( vec3( b - a, 0.25, c - a ) );
}

// Function 4097
float dist_sphere( vec3 pos, float r ) {
	return length( pos ) - r;
}

// Function 4098
vec3 sceneSDF_color(vec3 p) {
    vec3 p0 = p;
    p /= scale;
    float jungle1 = jungle(p,(length(p)-planet_size)/300.0);
    float planet_surface = 1.1+length(p)-planet_size;
    //float result = SDF1(p/1000.0+SDF1(p/1000.0));
    float result = min(jungle1,planet_surface);
    
    if(result == planet_surface){
    	return surface_color(p0);
    }
    else if(result == jungle1){
    	return jungle_color(p0);
    }
}

// Function 4099
float mapVol(vec3 p, in float spd)
{
    float f = smoothstep(0.0, 1.25, 1.7-(p.y + dot(p.xz,p.xz)*.62));   
    float g = p.y;
    p.y *= .27;
    p.z += gradm(p*0.73)*3.5;
    p.y += time*6.;
    float d = triNoise3d(p*vec3(0.3,0.27,0.3) - vec3(0,time*.0,0),spd*0.7)*1.4 + 0.01;
    d += max((g-0.)*0.3,0.);    
   	d *= f;
    
    return clamp(d,0.,1.);
}

// Function 4100
vec4 map( vec3 pos )
{
	pos += 0.04*sin(10.0*pos.yzx);
	
	vec3 qpos = mod( 1000.0 + pos+1.0, 2.0 )-1.0;
	
    vec3 off3 = floor( 1000.0 + (pos+1.0)/2.0 );

	qpos *= sign( cos( 0.5*3.1415927*pos.yzx ) );
	
	float off = abs( dot( off3, vec3(1.0, 13.0, 7.0 ) ) );
		
	float mindist = 10000.0;
	vec3 p = vec3(0.0);
	float h = 0.0;
	float rad = 0.04 + 0.15*freqs[0];
	float mint = 0.0;
    for( int i=0; i<16; i++ )
	{
		vec3 op = p;
		
		p  = 0.9*normalize(snoise3( 8.0*h ));

		float orad = rad;
		rad = (0.04 + 0.15*freqs[i])*1.5*1.1;
		
		vec2 disl = sdSegment( op, p, qpos );
		float t = h + disl.y/16.0;

		float dis = disl.x - mix(orad,rad,disl.y);
		
		if( dis<mindist ){ mindist = dis; mint=t; }
		h += (1.0/16.0);
	}

	float dsp = sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z);
	dsp = dsp*dsp*dsp;
	mindist += -0.02*dsp;
	
	mindist += 0.01*sin(180.0*mint + iTime);
	
	
    return vec4(mindist,1.0,dsp,mint);
}

// Function 4101
float distSmooth( float a, float b, float k ){
    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);
    return mix(b,a,h) - k*h*(1.0-h);
}

// Function 4102
vec2 Map(in vec3 p)
{
	vec2 h = Terrain(p.xz);
    return vec2(p.y - h.x, h.y);
}

// Function 4103
float distanceToSphere(vec3 p, float r) {
    return length(p)-r;   
}

// Function 4104
SceneResult Scene_Union( const in SceneResult a, const in SceneResult b )
{
    if ( a.fDist < b.fDist )
    {
        return a;
    }
    return b;
}

// Function 4105
float sdfBox(vec2 p) {
  vec2 d = abs(p) - vec2(1.0);
  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// Function 4106
float scene(in vec2 position ) {
    float sphere_radius = 0.25;

    vec2 sphere_position = vec2(1.0, sin(iTime)) / 4.0;
    sphere_position = position - sphere_position;

    vec2 box_position = vec2(0.0, 0.5);
    vec2 box_size     = vec2(pow(sin(iTime), 2.0), 0.25);
    
    // Compute distance functions
    float plane_distance = signedDistanceVertical(position - vec2(sin(iTime/2.0)-0.75,0.0));
    float sphere_distance = signedDistanceSphere(sphere_position, sphere_radius );
	float box_distance = signedDistanceBox(position - box_position, box_size);
    
    // Compose distance functions
    float result = unionOperation(plane_distance, sphere_distance);
    result = unionOperation(box_distance, result);
    return result;
}

// Function 4107
float sdf_s(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -4, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(4, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -4, 0)));
    return t;
}

// Function 4108
float map(vec3 p){
    p.x = mod(p.x, 2.0);
    p.y = (p.y, 2.0);
    p.z = mod(p.z, 2.0);
    return length(p-vec3(1.0,1.0,1.0)) - 0.5;
}

// Function 4109
float cylinderSDF(vec3 p, float h, float r) {
    // How far inside or outside the cylinder the point is, radially
    float inOutRadius = length(p.xy) - r;
    
    // How far inside or outside the cylinder is, axially aligned with the cylinder
    float inOutHeight = abs(p.z) - h/2.0;
    
    // Assuming p is inside the cylinder, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);

    // Assuming p is outside the cylinder, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 4110
float scene(vec3 p)
{
	return smin(
	    smin(
			p.y,
			funnysphere(p)
    	),
    	metaballs(p)
  	);
}

// Function 4111
float scene(vec3 pos)
{
    return sphere(pos, vec3(0.0, 0.0, 5.0), 3.0);
}

// Function 4112
float dist_box( vec3 pos, vec3 size ) {
	return length( max( abs( pos ) - size, 0.0 ) );
}

// Function 4113
vec3 Tonemap_ACES(const vec3 x) {
    // Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

// Function 4114
vec3 ShowScene (vec3 ro, vec3 rd, vec2 uv)
{
  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;
  float dstObj, at, nDotL, sh;
  for (int k = 0; k < 3; k ++) {
    ltPos[k] = vec3 (0., 1., 3.);
    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. - 0.2 * pi * tCur);
  }
  ltPos[3] = vec3 (0., 5., 0.);
  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.22 * pi * tCur)));
  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
      c = abs(erot(vec3(0.4,0.6,0.9), normalize(vn), ro.z*.6));
      if (idObj == 2){
          //vn = VaryNf (64. * ro, vn, 0.1);
          c = vec3(1., .7, 0.);
      }
    dfTot = vec3 (0.);
    spTot = vec3 (0.);
    for (int k = 0; k < 4; k ++) {
      ltDir = normalize (ltPos[k]);
      at = smoothstep (0.6, 0.95, dot (normalize (ltPos[k] - ro), ltDir));
      sh = ObjSShadow (ro + 0.05 * vn, ltDir);
     // c = vec3(1., .7, 0.);//HsvToRgb (vec3 (0.9 - 0.25 * float (k), 0.9, 1.));
      nDotL = max (dot (vn, ltDir), 0.);
      dfTot += c * (0.05 + 0.95 * at * sh * nDotL * nDotL);
      spTot += 0.5 * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);
    }
      
      vec3 local = ro;
    
     if (idObj == 2) {
        float ang = atan(rd.x,rd.y);
        float ang2 = atan(rd.x,rd.y);
        //local = vec3(ang2/2.,length(ro.xy)*40.,local.z);
        vn = normalize(vec3(cos(ang*2.),sin(ang*2.),1));
    }
      
     vec3 r = reflect(rd,vn);
  	
    //rough texture
    float sharpness = texture(iChannel0,local/2.).x;
    sharpness = sqrt(texture(iChannel0,local*vec3(1,4,.5)+sharpness*.1).x);
    sharpness *= pow(texture(iChannel0,local/10.+sharpness*.1).x, 2.);
    sharpness = sharpness*.5+.9;
    
    float spec = length(sin(r*8.*sharpness)*.4+.6)/sqrt(3.) * smoothstep(-1.,-.0,ro.z);
    float fres = 1.-abs(dot(rd,vn))*.5;
    
      	
	 vec3 env=texture(iChannel1, r*r*r).xyz;
     //col =  env;
      
      float ao = calcAO(rd, vn);
          
      col = dfTot;//+ spTot;
      col *=  env * spec + pow(spec, 4.*sharpness)  * ao *  fres * 1.6;
      
  	
      
  } else {
    col = vec3 (0.1);
  }
  return clamp (col, 0., 1.);
}

// Function 4115
float map(vec3 p, inout vec4 orbitTrap)
{
    const float s = 1.0;//0.97;
    const float horizontalWrap = sqrt(s*2.0)/2.0;
    
	float scale = 1.0;

	orbitTrap = vec4(1000.0); 
    
    for(int i=0; i<9; i++)
	{
        p.xz /= horizontalWrap;
        vec3 pOffset = (0.5*p+0.5);

        vec3 pOffsetWrap = 2.0*fract(pOffset);
        
        p = -1.0 + pOffsetWrap;
        p.xz *= horizontalWrap;
        
		float r2 = dot(p,p);
		
        if(i < 2)
        {
	        orbitTrap.z = min(orbitTrap.z, vec4(abs(p),r2).z);
        }
        if(i > 2)
        {
            orbitTrap.xyw = min(orbitTrap.xyw, vec4(abs(p),r2).xyw);
        }
        
		float k = s/r2;
		p     *= k;
		scale *= k;
	}
	
	float fractal = 0.33*abs(p.y)/scale;
    return fractal;
}

// Function 4116
float PrEllipsDf (vec3 p, vec3 r)
{
  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));
}

// Function 4117
void scene(in vec2 pos, out vec3 color, out float dist) {
    dist = 1e9; color = vec3(0,0,0);
    AddObj(dist, color, boxSDF(pos - vec2(-3,1), vec2(1,1)), vec3(.6,.8,1.));
    AddObj(dist, color, sphereSDF(pos - vec2(3,1), 1.), vec3(1,.9,.8));
    AddObj(dist, color, sphereSDF(pos - vec2(.3*sin(iTime),-2), 0.5), vec3(0,.1,0));
    AddObj(dist, color, boxSDF(pos - vec2(0,1), vec2(1.5,0.1)), vec3(.3,.1,.1));
}

// Function 4118
vec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )
{
    float e = 0.002;
    float b = 0.03;
    
	float ref = fbm6( 4.0*pos );
    hei = ref;
    
    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,
                        e,
                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )/e;
	
	vec3 tgrad = gra - nor*dot( nor, gra );
    return normalize( nor - tgrad );
}

// Function 4119
float map(vec3 p) {
    float lat = 90. - acos(p.y / length(p)) * 180./PI;
    float lon = atan(p.x, p.z) * 180./PI;
    vec2 uv = vec2(lon/360., lat/180.) + 0.5;
    return texture(iChannel0, uv).x;
}

// Function 4120
float dist2Segments(vec4 z, float r){
	float da=dist2Segment(z, vec4(1.,0.,0.,0.), r);
	float db=dist2Segment(z, vec4(0.,1.,0.,0.), r);
	float dc=dist2Segment(z, nc, r);
	float dd=dist2Segment(z, nd, r);
	
	return min(min(da,db),min(dc,dd));
}

// Function 4121
float manhattanDistance(vec2 p1, vec2 p2) {
	float d1 = abs(p1.x - p2.x);
	float d2 = abs(p1.y - p2.y);
	return d1 + d2;
}

// Function 4122
float fallingSnowSDF(in vec3 p, inout int material)
{
    const float snow_scale = 4.;
    const float snow_size = .02;
    float d = sdSnow((p - vec3(0, - 2. * iTime, 0)) / snow_scale, snow_size, use_snowflakes);

    // avoid aliasing "gaps" between groups of snowflaks
    // (comment out to see the difference)
    p = (rotate(45., normalize(vec3(0, 1, 0))) * vec4(p, 1.)).xyz;

    d = min(d, sdSnow((p - vec3(29.1, 3. - 2. * iTime, 173.114)) / snow_scale, snow_size, use_snowflakes));
    d *= snow_scale;

    material = MAT_SNOWFLAKE;
    return d;
}

// Function 4123
float UConeTraceScene(vec3 posRay, vec3 normalRay, float rConeWidth, float dS, float dUOccMax, bool fCrossCells)
{
	float sRay = 3.0;

	float uOcclusion = 1.0;

	float uRandom = 0.0;

	// rConeNoOcc is the non-occluded portion of the cone (tan of the cone half-angle)

	float rConeNoOcc = rConeWidth;

	if (!fCrossCells)
	{
		uRandom = UHashFromPos(posRay);
		posRay = PosWrap(posRay);
	}

	for (int iStep = 0; iStep < 50; ++iStep)
	{
		vec3 pos = posRay + normalRay * sRay;

		float sConeWidth = sRay * rConeWidth;

		// Compute min step size. The second argument to max() is the step size yielding a maximum occlusion change of
		//	dUOccMax.

		float dSMin = max(dS, 2.0 * dUOccMax * sRay * rConeWidth);

		// Find sRay_new such that sRay_new - sRay_old == sdf.m_s - rConeNoOcc * sRay_new
		//	i.e., march until until new cone potentially touches surface
		//	Solution is: sRay_new := (sdf.m_s - sRay_old * rConeNoOcc) / (1.0 + rConeNoOcc)
        //  Then add dSMin to potentially get some occlusion.

		SSdfSample sdf;
		if (fCrossCells)
		{
			uRandom = UHashFromPos(pos);
			sdf = SdfScene(PosWrap(pos), uRandom);

			float dSCellEdge = DSCellEdge(pos);
			const float sEdgeSlop = 10.0;
			sRay += max(
						0.0,
						(min(dSCellEdge + sEdgeSlop, sdf.m_s) - sRay * rConeNoOcc) /
						(1.0 + rConeNoOcc));
            sRay += dSMin;
		}
		else
		{
			sdf = SdfScene(pos, uRandom);

			sRay += max(0.0, (sdf.m_s - sRay * rConeNoOcc) / (1.0 + rConeNoOcc));
            sRay += dSMin;
		}

		// Update occlusion and non-occluded cone width

		uOcclusion = min(uOcclusion, saturate(0.5 * (1.0 + sdf.m_s / sConeWidth)));
		rConeNoOcc = rConeWidth * saturate(2.0 * uOcclusion - 1.0);

		if (uOcclusion < 0.01 ||
			pos.z < 0.0 ||
			(pos.z > g_zMax && normalRay.z >= 0.0))
		{
			return uOcclusion;
		}
	}

	return uOcclusion;
}

// Function 4124
float mapDebug(vec3 p) {
    float d = map(p);
    #ifndef DEBUG
        return d;
    #endif
    float plane = min(abs(p.z), abs(p.y));
    hitDebugPlane = plane < abs(d);
    //hitDebugPlane = true;
    return hitDebugPlane ? plane : d;
}

// Function 4125
float scene (vec3 p, out float mat)
{
    mat = 0.0;
    float walls = p.y + 1.0;
    walls = min (walls, -p.z + 1.0);
    
    float lamp = sceneLum(p);
    
    float sceneSDF = min (lamp, walls);
    
    if ( sceneSDF == lamp ) mat = 1.0;
    else mat = 0.0;

    return sceneSDF;
}

// Function 4126
float map(vec3 p)
{
    p.y += height(p.zx);
    
    vec3 bp = p;
    vec2 hs = nmzHash22(floor(p.zx/4.));
    p.zx = mod(p.zx,4.)-2.;
    
    float d = p.y+0.5;
    p.y -= hs.x*0.4-0.15;
    p.zx += hs*1.3;
    d = smin(d, length(p)-hs.x*0.4);
    
    d = smin(d, vine(bp+vec3(1.8,0.,0),15.,.8) );
    d = smin(d, vine(bp.zyx+vec3(0.,0,17.),20.,0.75) );
    
    return d*1.1;
}

// Function 4127
float map(vec3 p, vec2 iMouse, float iTime) {
    vec3 shift = (p - vec3(0., 0.06, 0.01)) * rotate(iTime);
    
    float s1 = sdApple(shift.xy, 1./3.);
    s1 = opExtrussion(shift, s1, 0.066);
    // if inside of apple, flip it
    s1 = abs(s1);

    float s2 = sdSphere(p - vec3(0., -1.7, 0.), 1.43);    

    return opUnion(s1, s2);
}

// Function 4128
vec3 map_ray(vec3 ro, vec3 rd, vec3 nrm, int c) { 
    if (c == mtLight)	 return map_light_ray(ro, rd, nrm);
    else if (c == mtSsph)return map_Ssph_ray(ro, rd, nrm);
    else if (c == mtGsph)return map_Gsph_ray(ro, rd, nrm);
    else if (c == mtBox) return map_box_ray(ro, rd, nrm);
    else return rd;
}

// Function 4129
float remap(in float value, in float original_min, in float original_max, in float new_min, in float new_max)
{
	return new_min + ( ((value - original_min) / (original_max - original_min)) * (new_max - new_min) );
}

// Function 4130
float distToBox( in vec3 p, in vec3 abc )
{
	vec3 di = max(abs(p)-abc,0.0);
	return dot(di,di);
}

// Function 4131
vec3 filmicToneMapping(vec3 color)
{
    color = max(vec3(0.), color - vec3(0.004));
    color = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);
    return color;
}

// Function 4132
vec3 scene( vec3 ro, vec3 rd )
{
	float stride=2.0*(MAX_T-MIN_T)/float(GLOBAL_STEPS);
	float t=MIN_T,ot=t,d=0.0;
	vec3 p1=F(t),p2;
	for(int i=0;i<GLOBAL_STEPS;i++){//stepping thru the whole curve to find possible roots
		t+=max(stride*0.2,stride*log(d+1.15));
		p2=F(t);
		d=SegD(p1-ro,p2-p1,rd);
		zStack(d,t,ot);
		if(t>MAX_T)break;
		ot=t;
		p1=p2;
	}
	d=100.0;
	for(int j=0;j<4;j++){//stepping thru the possible roots
		float near=TN.x,far=TF.x;
		for(int i=0;i<LOCAL_STEPS;i++){//...and finding local minima
			float mid=(near+far)*0.5;
			p1=F(mid);
			float mdrv=SegD(p1-ro,F(far)-p1,rd)-SegD(p1-ro,F(near)-p1,rd);
			if(mdrv > 0.0)far=mid;else near=mid;
		}
		p1=F(near);p2=F(far);
		d=min(d,SegD(p1-ro,p2-p1,rd));
		TN=TN.yzwx;TF=TF.yzwx;
	}
	vec3 col=vec3(smoothstep(0.0,0.0001,d));
	d=Arms(time*0.5,ro,rd);
	col=mix(vec3(0.0,0.75,0.0),col,smoothstep(0.0,0.0001,d));
	return col;
}

// Function 4133
float sceneMap3D(vec3 pos)
{

    float t = plane(pos, vec4(1.0, 0.0, 0.0, 0.0));
    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 556.0)));
    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 0.0)));
    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 548.8)));
    t = min(t, plane(pos, vec4(0.0, 0.0, -1.0, 559.2)));
    int m;
    t = min(t, mapBlocks(pos, m));

    return t;
}

// Function 4134
float minkowskiDistance(vec2 p1, vec2 p2, float power) {
	float d1 = pow(abs(p1.x - p2.x), power);
	float d2 = pow(abs(p1.y - p2.y), power);
	return pow(d1 + d2, 1.0 / power);
}

// Function 4135
float map(vec3 p) {
   	float pl = 10.0;
    float gr = p.y + sin((iTime*2.0) + p.x * pl)/pl*0.5 + snoise(vec2((iTime*5.)+p.x,100.)/pl) + cos((-iTime*4.0)+p.z*pl)/pl+1.;
    float n1 = abs(snoise(vec2(iTime*0.8,666.0)));
	float znoise = snoise(vec2(iTime*0.25,558.0))*3.0;
	float d = 0.0;
	vec2 size = vec2(10.);
    vec2 c = floor((p.xz + size * 0.5)/size);
    p.xz  = mod(p.xz + size * 0.5, size)-size*0.5;
    vec2 r1 = vec2(random(c));
    n1 = abs(snoise(vec2(iTime * r1.x * 0.15, 556.)));
    vec4 sphere = vec4(cos((iTime+r1.x*0.0012)), abs(sin(-iTime*4.+(r1.x+0.03)))*MAX_HEIGHT*n1, znoise, 1.0)*SPH_RAD/2.0;
    float distSphere = length(p-r1.x - sphere.xyz)-(sphere.w);
 	float s1 = smin(gr, distSphere, BLOB_SIZE);
    return s1;
}

// Function 4136
float map(vec3 p){
    
    // spheres
    float d = (-1.*length(p)+3.)+1.5*noise(p);    
    d = min(d, (length(p)-1.5)+1.5*noise(p) );  
    
    // links
    float m = 1.5; float s = .03;    
    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          
    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    
    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    
    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    
    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );
    
    return d;
}

// Function 4137
float scene(vec3 p)
{
    float ground = sdGround(p);

    p.xz = tickspin(p.xz);

    float ink = sdInk(p);
    float gold = sdGold(p);
    float best = min(min(ink,gold),ground);
    if(ink==best)
        mat=0;
    else if(gold==best)
        mat=1;
  else
    mat=2;
  return best;
}

// Function 4138
float scene(vec3 p) {
  p = mapp(p);
  
  float dist = 100000.;
  for (int i = 0; i < 5; i++) {
    float d = comp(p, rand3(float(i)), rand3(cos(float(i))));
    if (d < dist) jort = float(i);
    dist = smin(d,dist,0.1);
  }
  return (dist + max(length(p)-1.5,0.)*0.25);
}

// Function 4139
vec4 scene(vec3 p)
{
    vec3 tp = p;
    tp.z *= 5.0;
    
    tp.xy -= iTime * 20.0;
    tp.z += iTime * 1000.0;
    
    vec4 d = MAX_VEC;
    float n = fbm(tp*0.1);
    float r = n*5.0 + 20.0;
    float c = length(p.xy)-r;
    c = max(c, r-0.1-length(p.xy));
    d = min4(d, vec4(
        mix(
            mix(vec3(1.000,0.000,0.502), vec3(0.173,0.369,0.173), saturate(n*n+n)),
            mix(vec3(0.627,0.376,0.745), vec3(0.490,0.729,0.627), saturate(n*n+n)),
            n
        ) * n*2.0, 
    c));
    
    return d;
}

// Function 4140
vec4 scene(vec3 pos, vec3 dir, float t, out float dist)
{
    float rad1 = 0.4, rad2 = 0.35;
    float d = sphere(pos, rad1);
    d -= rad2 * fbm(pos * mix(1.5, 3.5, sin(t/DURATION*2.*PI)*.5+.5) + iTime * 0.1);
    dist = d;
    vec4 color;
    float r = length(pos) / rad1;
    color.a = smoothstep(1., 0., clamp(d / .05, 0., 1.));
    color.a *= smoothstep(1., 0., clamp((r - 1.25) * 2., 0., 1.));
    color.rgb = 1.2 * mix(vec3(1.0,0.95,0.2), vec3(1.0,0.35,0.), clamp((r - 1.1)*3., 0., 1.));
    color.rgb = mix(color.rgb, vec3(0.95,0.95,1.0)*0.25, clamp((r - 1.3)*3., 0., 1.));
    return color;
}

// Function 4141
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, bgCol, vn, rg;
  vec2 qBlk;
  float dstObj, a, s, sh;
  bool fxz;
  aRot = -0.3 * 2. * pi * tCur;
  aCs[0] = vec2 (cos (aRot), sin (aRot));
  aCs[1] = vec2 (cos (aRot + pi), sin (aRot + pi));
  crRad = 2.;
  crLen = 5.;
  for (int k = 0; k < 2; k ++) {
    crMid[k].y = -0.5 * crRad * aCs[k].y;
    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);
    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;
  }
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);
    if (idObj == idBase) {
      col4 = vec4 (0.1, 0.6, 0.1, 0.1);
      if (abs (vn.y) < 0.01) {
        rg = ro;
        rg.y += 0.5;
        fxz = (abs (vn.x) > 0.99);
        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));
        rg.xz *= sign (fxz ? vn.x : vn.z);
        if (fxz) {
          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);
          else vn.xz = Rot2D (vn.xz, rg.x);
        } else {
          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);
          else vn.zx = Rot2D (vn.zx, rg.x);
        }
      } else {
        rg = ShGrid (ro.xz);
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);
        if (vn.y > 0.99) {
          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);
          else vn.yx = Rot2D (vn.yx, rg.x);
        }
      }
      vn = VaryNf (32. * ro, vn, 1.);
    } else if (idObj == idCyl) {
      col4 = vec4 (0.7, 0.3, 0.1, 0.2);
      a = atan (qHit.z, - qHit.y) / (2. * pi);
      if (abs (vn.x) > 0.99) {
        col4.r *= 1. - 0.3 * Fbm2 (4. * qHit.yz);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *
           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));
      } else {
        col4.r *= 1. - 0.3 * Fbm2 (4. * vec2 (8. * a, qHit.x));
        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));
        a = mod (32. * a, 1.);
        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *
           sign (a - 0.5) * sign (ro.z));
      }
    } else if (idObj == idWhl) {
      if (abs (vn.z) < 0.01) qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);
      col4 = vec4 (0.5, 0.5, 0.6, 0.1) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));
    } else if (idObj == idSpk) {
      col4 = 1.1 * vec4 (0.5, 0.5, 0.6, 0.2);
    } else if (idObj == idCrnk) {
      col4 = vec4 (0.4, 0.4, 0.5, 0.2);
    } else if (idObj == idAx) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.3);
    } else if (idObj == idPis) {
      col4 = vec4 (0.5, 0.5, 0.2, 0.3);
    } else if (idObj == idCrod) {
      col4 = vec4 (0.6, 0.5, 0.6, 0.3);
    } else if (idObj == idCylEnt) {
      col4 = vec4 (0.7, 0.4, 0.1, 0.2);
      if (length (qHit.yz) < 0.33) col4.rgb *= 0.5;
    } else if (idObj == idValv) {
       col4 = vec4 (0.7, 0.4, 0.1, 0.2);
       if (vn.x > 0. && length (qHit.yz) < 0.13) col4.rgb *= 0.5;
    } else if (idObj == idPipes) {
       col4 = (qHit.y < 0. || length (qHit.xz) > 0.3) ?
          vec4 (0.7, 0.4, 0.1, 0.2) : vec4 (0.3, 0.2, 0., 0.);
    } else if (idObj == idSup) {
      col4 = vec4 (0.5, 0.3, 0.1, 0.05);
      vn = VaryNf (32. * ro, vn, 1.);
    }
    sh = 0.5 + 0.5 * ObjSShadow (ro, ltDir);
    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
       col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
    col += col4.a * vec3 (0.4) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.05, qBlk.y));
  } else {
    qBlk = mod (4. * BlkHit (ro, rd), 1.);
    col = vec3 (1., 0.6, 0.6) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +
       vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.1, qBlk.y));
  }
  return clamp (col, 0., 1.);
}

// Function 4142
float cyl_sdf(in vec3 loc) {
    float r = length(loc.yz) - 0.5;
    float cap1 = loc.x - 0.5;
    float cap2 = -0.75 - loc.x;
    return s_max(cap1, s_max(cap2, r, 0.2), 0.2);
}

// Function 4143
vec3 map(vec3 p)
{
    vec3 d = vec2(0, 1e+31).yxx;
    
    dmin(d, .75-abs(p.y), 1., 0.);
    dmin(d, length(p)-.5, 0., 0.);
    
    if(length(p.xz) > 10.)return d;
    
    vec3 q = abs(p-round(p-.5)-.5);
    float g = min(min(box(q.xy), box(q.xz)),box(q.yz))-.05;
    float c = min(.6-abs(p.x+p.z), .45-abs(p.y));
    dmin(d, max(g, c), .1, 0.);
    
    dmin(d, box(p.xz-2.)-.5, 8., -.5);
    dmin(d, box(p.xz+2.)-.5, 8., +.5);
    
	return d;
}

// Function 4144
float map(vec3 p) {
    float h = fbm(p.zx*0.2);
    return p.y-h;
}

// Function 4145
vec3 SceneNormal(in vec3 pos, in float depth)
{
    vec2 eps = vec2(0.001 * depth, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,
                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,
                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));
}

// Function 4146
vec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )
{
    const vec2 e = vec2(0.001, 0);
    
    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,
                   tex3D(tex, p - e.yxy, n).rgb,
                   tex3D(tex, p - e.yyx, n).rgb);
    
    vec3 g = vec3(0.299, 0.587, 0.114) * m;
    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;
    g -= n * dot(n, g);
                      
    return normalize( n + g*bf );
    
}

// Function 4147
poly2 pa_map(vec3 ro, vec3 rd, float t) {
    poly2 dt = pa_init(t);
    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));
    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));
    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));
    return pa_map(x,y,z);    
}

// Function 4148
float griddist(in vec3 p, in vec3 scale, float r){
	vec3 rp = round(p/scale)*scale;
    return length(p-rp)-r;
}

// Function 4149
float mapShell(in vec3 p, out vec3 col, bool req_color) {
    p -= vec3(0.7, 0, 0);

    // r=exp(b*)
    const float b = 0.17;

    // Catesian to cylindrical
    float r = length(p.xy);  // r
    float a = mix(0.0, 0.45, smoothstep(0.0, 1.0, 0.5*(r-0.6)));  // rotate by this angle
    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;  // rotation
    float t = atan(p.y, p.x);  // 

    // shell opening, kill discontinuities of the spiral
    float ro = exp(b*PI);  // center of the "ring"
    float d = length(vec2(length(p.xz-vec2(-ro,0))-ro,p.y));  // distance to the "ring"
    float u = t, dx = r-ro, dy = p.z;  // longitude and two numbers to determine latitude

    // spiral
    // r(n) = exp(b*(2.*PI*n+t)), (x-r)^2+y^2=r^2, solve for n
    float n = (log((r*r+p.z*p.z)/(2.*r))/b-t)/(2.0*PI);  // decimal n
    n = min(n, 0.0);  // clamp to opening
    float n0 = floor(n), n1 = ceil(n);  // test two boundaries
    float r0 = exp(b*(2.*PI*n0+t)), r1 = exp(b*(2.*PI*n1+t));  // two r
    float d0 = abs(length(vec2(r-r0,p.z))-r0);  // distance to inner
    float d1 = abs(length(vec2(r-r1,p.z))-r1);  // distance to outer
    if (d0 < d) d = d0, u = 2.*PI*n0+t, dx = r-r0, dy = p.z;  // update distance
    if (d1 < d) d = d1, u = 2.*PI*n1+t, dx = r-r1, dy = p.z;  // update distance

    // septa/chambers
    const float f = 2.4;  // "frequency" of chambers
    float s0 = t + 2.0*PI*(n0+0.5);  // longitude parameter
    float v = fract(n);  // 0-1, distance from inner circle
    float s = f*s0 + 1.0*pow(0.25-(v-0.5)*(v-0.5), 0.5)+0.5*v;  // curve of septa
    s += pow(min(1.0/(40.0*length(vec2(v-0.5,p.z))+1.0), 0.5), 2.0);  // hole on septa
    float sf = fract(s);  // periodic
    sf = s0>-1.8 ? abs(s+3.25) :  // outer-most septa, possibly cause discontinuities
         min(sf, 1.0-sf);  // inner septa
    float w = sf/f*exp(b*(s0+PI));  // adjust distance field
    if (length(p*vec3(1,1,1.5))<3.0)  // prevent outer discontinuity
        d = min(d, 0.5*w+0.012);  // union chambers

    d += 0.00012*r*sin(200.*u);  // geometric texture
    d = abs(d)-0.8*max(0.02*pow(r,0.4),0.02);  // thickness of shell
    d = max(d, max(cut.x-p.z,p.z-cut.y));  // cut it open
    if (!req_color) return d;  // distance calculation finished

    // color
    v = atan(dy, dx);  // latitude parameter
    w = length(vec2(dx,dy)) / exp(b*u);  // section radius parameter
    for (float i=0.;i<6.;i+=1.) {  // distort the parameters
        float f = pow(2., i);
        float du = 0.15/f*sin(f*u)*cos(f*v);
        float dv = 0.15/f*cos(f*u)*sin(f*v);
        u+=du, v+=dv;
    }
    float f1 = cos(50.*u);  // middle stripes
    float f2 = cos(21.3*u)+0.1;  // side stripes
    float tex = mix(f1, f2, 0.5-0.5*tanh(1.0-3.0*sin(v)*sin(v)))  // blend stripes
         + 0.5-0.6*cos(v);  // fading at sides
    tex += 0.5+0.5*tanh(4.0*(u-2.0));  // fading near opening
    col = n==0.0 ? vec3(0.9,0.85,0.8) : vec3(0.95,0.85,0.7);  // base color, outer and inner
    if (w>1.0 && w<1.1)  // on the surface of the shell
        col = (u-0.3*cos(v)<-2.6 ? 1.0-0.6*min(exp(2.+0.5*u),1.0) : 1.0)  // black inside the opening
            * mix(vec3(0.6,0.3,0.2), col, clamp(8.0*tex+0.5,0.,1.));  // apply stripes

    return d;
}

// Function 4150
MapResult map_floor(vec3 position)
{
	MapResult result;
	result.dist = dot(position, vec3(0.0, 1.0, 0.0)) + 2.5;
	result.material.color = textureLod(iChannel0, position.xz * 0.15, 0.0).rgb;
	
	return result;
}

// Function 4151
float scene(vec3 ra, vec3 dir)
{
    
    
    float d = 0.0;
    bool hit = false;
    for (int i = 0; i <40; i++)
    {
        float h = map(ra + dir * d);
        if (h < 0.04)
        {
            hit = true;
            break;
        }
        d += h;
    }
    if (!hit) d= -100.0;
    return d;
}

// Function 4152
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn;
  float dstObj;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    col = vec3 (0., 0.9, 0.) * (0.2 + 0.2 * max (dot (vn, - ltDir), 0.) +
       0.7 * pow (max (dot (vn, ltDir), 0.), 2.)) +
       0.3 * vec3 (1., 0., 0.) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 16.);
  } else col = vec3 (0., 0., 0.3 * (0.7 - 0.2 * rd.y));
  return col;
}

// Function 4153
float cylSDF(vec3 p, float h, float r) {
    float a = abs(p.y) - (h/2.0);
    float b = length(p.xz)-r;
    if (b > 0.0 && a > 0.0) {
    	return length(vec2(a,b));
    }
    
    return max(a,b);
}

// Function 4154
ivec2 cross_distribution(int i)
{
    return (1<<(2*(i/4))) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );
}

// Function 4155
vec2 map( vec3 p )
{
    vec3 q = p; q.x = abs(q.x);
    vec3 hp = (mtxHead*vec4(p,1.0)).xyz;

    // body
    p.yz = mat2(0.98,-0.2,0.2,0.98)*p.yz;
    
    float d1 = sdEllipsoid( p, vec3(0.0,0.15,0.0), vec3(0.41,0.83,0.41) );
    float d2 = sdSphere( p, vec4(0.0,1.4,0.0,1.2) );
    float d9 = sdCapsule( q, vec3(0.5,-0.6,0.02), vec3(0.45,0.07,-0.02), 0.15 );
    float body = smax( d1, -d2, 0.03 );
    body = smax( body, -d9, 0.01 );
    
    
    // head
    float d3 = sdSphere( hp, vec4(0.0,0.0,0.0,0.4) );
    float d4 = sdSphere( hp, vec4(0.0,0.45,0.008,0.65) );
    float head = smax( d3, d4, 0.05 );
    // head hole    
    float d5 = sdEllipsoid( hp, vec3(0.0,0.0,0.4), vec3(0.48,0.3,0.2) );
    //d5 = smax( d5, sdSphere( hp, vec4(0.0,0.34,0.2, 0.46 )), 0.07 );
    d5 = smax( d5, sdSphere( hp, vec4(0.0,0.49,0.2, 0.6 )), 0.07 );
    head = smax( head, -d5, 0.025 );
    
    // face
    float d6 = sdSphere( hp, vec4(0.0,0.04,-0.05,0.41) );
    float m2 = smax(d6,d5,0.01);

    
    // arm
    float d7 = sdEllipsoid( q, vec3(0.5,-0.15,0.0), vec3(0.1,0.35,0.1) );
    float d8 = sdEllipsoid( q, vec3(0.54,-0.15,0.0), vec3(0.1,0.35,0.1) );
//    d8 = sdCapsule( q, vec3(0.6,-0.6,0.02), vec3(0.55,0.09,-0.02), 0.15 );
    d7 = max( d7, d8 );
    float arm = d7;
    

    float m1 = min( min( body, head ), arm );
                        
    return minx( vec2(m1,0.0),
                 vec2(m2,1.0) );
}

// Function 4156
float sphereSDF(const in vec3 p) {
    return length(p) - 1.0;
}

// Function 4157
float lineDist(vec2 p, vec2 start, vec2 end, float width)
{
	vec2 dir = start - end;
	float lngth = length(dir);
	dir /= lngth;
	vec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;
	return length( (start - p) - proj ) - (width / 2.0);
}

// Function 4158
float sdfPlane(in vec3 p, in vec4 normal)
{
  	// n must be normalized
  	return dot(p, normal.xyz) + normal.w;
}

// Function 4159
vec3 NormalMap( vec3 normal, vec3 pos, vec3 triPlanarWeights )
{
    return normalize( normal + NormalMapTex( pos.yz ) * triPlanarWeights.x + NormalMapTex( pos.xz ) * triPlanarWeights.y + NormalMapTex( pos.xy ) * triPlanarWeights.z );
}

// Function 4160
float sceneDf(vec3 p) {
  // Sphere parameters
  vec3 centre = vec3(0);
  float radius = 1.0;
  return sphereDf(p,centre,radius);
}

// Function 4161
vec3 distObj(vec3 pos,vec3 ray,float radius,float minr)
{
    float b = dot(ray,pos);
  	float c = dot(pos,pos) - b*b;
    
    float sta=radius-minr;
    float invm=1.0/sta;
    float rq=radius*radius;
    vec3 dist=ray*10000.0;
    if(c <rq)
    {
        vec3 r1 = (ray*(abs(b)-sqrt(rq-c))-pos);
		float maxs=abs(dot(r1,ray));//*0.5;
        if (c<minr*minr) {
            vec3 r2 = (ray*(abs(b)-sqrt(minr*minr-c))-pos);
            maxs=maxs-abs(dot(r2,ray));
        }// else {
            maxs*=0.5;
        //}
        float len;
        float h;

        for (float m=0.0; (m<iterations); m+=1.0) {
            len=length(r1);
            vec3 d=r1/len;
            h=sta*heightMap(d,(len-minr)*invm)+minr;
            if (abs(h-len)<0.0001) break;
            maxs=abs(maxs);
            if (len<h) maxs=-maxs;
            r1+=ray*maxs*abs(len-h);
            maxs*=0.99;
        }
        if (len<h+0.1) dist=r1+pos;
    }
    return dist;
}

// Function 4162
vec3 nmap(vec2 t, sampler2D tx, float str)
{
	float d=1.0/1024.0;

	float xy=texture(tx,t).x;
	float x2=texture(tx,t+vec2(d,0)).x;
	float y2=texture(tx,t+vec2(0,d)).x;
	
	float s=(1.0-str)*1.2;
	s*=s;
	s*=s;
	
	return normalize(vec3(x2-xy,y2-xy,s/8.0));///2.0+0.5;
}

// Function 4163
float distfunc(vec3 pos)
{
    vec3 p2 = pos;
    p2.x += sin(p2.z*3.0 + p2.y*5.0)*0.15;
    p2.xy *= rot(floor(p2.z*2.0)*twist.y);
    pos.xy *= rot(pos.z*twist.x);
    
    float h = heightmap(pos.xz)*heightInfluence.x;
    
    vec3 columnsrep = vec3(0.75,1.0,0.5);
    vec3 reppos = (mod(p2 + vec3(iTime*0.01 + sin(pos.z*0.5),0.0,0.0),columnsrep)-0.5*columnsrep);
    
    float columnsScaleX = 1.0 + sin(p2.y*20.0*sin(p2.z) + iTime*5.0 + pos.z)*0.15;
    float columnsScaleY = (sin(iTime + pos.z*4.0)*0.5+0.5);
    
    float columns = sphere(vec3(reppos.x, pos.y+0.25, reppos.z), 0.035, vec3(columnsScaleX,columnsScaleY,columnsScaleX));
    float corridor = planesDistance - abs(pos.y) + h;
    float d = smin(corridor, columns, 0.25); 
           
    return d;
}

// Function 4164
void BSDF_Oren_Nayar_Setup(inout OrenNayarBsdf bsdf){
	float sigma = bsdf.roughness;
	sigma = clamp(sigma,0.,1.);
	float div = 1. / (M_PI_F + ((3. * M_PI_F - 4.) / 6.) * sigma);
	bsdf.a = div;
	bsdf.b = sigma * div;
}

// Function 4165
float distfunc(vec3 pos)
{
	float t = iTime * 2.0;
    
    float last_dist = 10000.0;
    for (float i = -1.0; i < 2.0; i += 1.0)
    {
        for (float j = -1.0; j < 2.0; j += 1.0)
    	{
            for (float k = -1.0; k < 2.0; k += 1.0)
    		{
                float a = W(pi / 2.0);
                float b = W(pi);
                float c = W(0.0);
                vec3 rotpos = pos;
                rotpos.yz *= rot(-pi / 5.0);
                rotpos.xz *= rot(pi / 4.0);
        		float next_dist = box(rotpos + vec3(i * a, j * b, k * c), vec3(cube_size)) * scale;
        		last_dist = min(last_dist, next_dist);
            }
        }
    }
    
    return last_dist;
}

// Function 4166
float plateSDF(const in vec2 p, const in vec2 dim) {
    vec2 d = (abs(p) - dim);
    return max(d.x, d.y);
}

// Function 4167
vec2 bishop_sdf(vec3 point, vec3 offset, float color, float scale){
    vec3 p = point/scale;
    vec3 BISHOP_POS = offset/scale;
 
    float tip = bishop_tip(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 5.0, BISHOP_POS.z));
    
    float base = bishop_base(p-vec3(BISHOP_POS.x, BISHOP_POS.y + 0.5, BISHOP_POS.z));
   
    float shaft = bishop_shaft(p - vec3(BISHOP_POS.x, BISHOP_POS.y + 1.0, BISHOP_POS.z));
    
    float peen = opSmoothUnion(opSmoothUnion(base, shaft,.65),tip,0.5);
    
    return vec2(peen*scale, color);
}

// Function 4168
float DistantTreeIntersect( vec3 p, vec3 origin, vec2 c, float noiseValue )
{
  return sdCone(p, origin, c) + 2.9 * noiseValue;
}

// Function 4169
float map(vec3 p){
 
    
    // Retrieve the 2D surface value from a cube map face.
    float sf2D = surfFunc2D(p);
    
     
    // Path function. Not used here.
    //vec2 pth = path(p.z); 

    
    // Tunnel. Not used here.
    //float tun = 1. - dist((p.xy - pth)*vec2(.7, 1));

    // Mover the mirrored ball object.
    vec3 q = moveBall(p);
    
     
    // Terrain.
    float ter = p.y - sf2D*.5;
    
    // Place a crater beneath the object.
    vec3 q2 = p - vec3(0, 1, 0) - vec3(0, 5. - .55 - 1., 0);
    ter = smax(ter, -(length(q2) - 5.), .5);
    ter += (.0 - sf2D*.5); 
    
    
 
    // Hollowing the tunnel out of the terrain. Not used here.
    //ter = smax(ter, tun, 3.);
    
    // The polyhedral object.
        
    // Face, line and vertex distances. 
    float face = 1e5, line = 1e5, vert = 1e5;

 
    
    #ifdef PENTAKIS_ICOSAHEDRON
    
        // A Pentakis icosahedron: Like an icosahedron, but with 80 sides.
    
        // Construct a regular 20 sided icosahedron, then use the vertices to 
        // subdivide into four extra triangles to produce an 80 sided Pentakis
        // icosahedron. Subdivision is achieved by using the known triangle 
        // face vertex points to precalculate the edge points and triangle center 
        // via basic trigonometry. See e0, e1, e2 above.
        //
        // On a side note, I'd imagine there's a way to fold space directly into a 
        // Pentakis icosahedron, but I got lazy and took the slower subdivided 
        // icosahedron route. If anyone knows how to do it more directly, feel free 
        // to let me know.


        // Local object cell coordinates.
        vec3 objP = opIcosahedron(q);

        // Vertices.
        vert = min(vert, length(objP - v0) - .05); 
        vert = min(vert, length(objP - e0) - .05); 

        // Lines or edges.
        line = min(line, sdCapsule(objP, v0, e0) - .02);
        line = min(line, sdCapsule(objP, e0, e2) - .02);

        float ndg = .97;

        // Vertex triangle facets -- Due to the nature of folding space,
        // all three of these are rendered simultaneously.
        face = min(face, udTriangle(objP, v0*ndg, e0*ndg, e2*ndg) - .03);
        // Middle face.
        face = min(face, udTriangle(objP, e0*ndg, e1*ndg, e2*ndg) - .03);
    
    #else
    
        // The second polyhedral object option:
        //
        // This is an exert from Knighty's awesome Polyhedras with control example, here:
        // https://www.shadertoy.com/view/MsKGzw
        //
        // Here's a very brief explanation: Folding space about various planes will produce various
        // objects -- The simplest object would be a cube, where you're folding once about the YZ, XZ, 
        // and XY planes: p = abs(p); p -= vec3(a, b, c); dist = max(max(p.x, p.y), p.z);
        //
        // Things like icosahedrons require more folds and more advanced plane calculations, but the
        // idea is the same. It's also possible to mix objects, which is what Knighty has cleverly 
        // and elegantly done here. In particular, a Triakis icosahedron (bas = vec3(1, 0, 0), an 
        // icosahedron (bas = vec3(0, 1, 0) and a dodecahedron (bas = vec3(0, 0, 1). Mixtures, like 
        // the default (bas = vec3(1), will give you a compounded mixture of three platonic solids, 
        // which each have their own names, but I'll leave you to investigate that. :)

        // Setup: Folding plane calculation, etc. I've made some minor changes, but it's essesntially
        // Knighty's original code.
        //
        // Animating through various platonic solid compounds.
        //vec3 bas = vec3(sin(iTime/4.)*.5 + .5, cos(iTime*1.25/4.)*.5 + .5,  cos(iTime/1.25/4.)*.5 + .5);
        // A nice blend of all three base solids.
        const vec3 bas = vec3(1);

        vec3 pbc = vec3(scospin, 0, .5); // No normalization so 'barycentric' coordinates work evenly.
        vec3 pca = vec3(0, scospin, cospin);
        //U, V and W are the 'barycentric' coordinates. Not sure if they are really barycentric...
        vec3 pg = normalize(mat3(pab, pbc, pca)*bas); 
        // For slightly better DE. In reality it's not necesary to apply normalization. :) 
        pbc = normalize(pbc); pca = normalize(pca);
        
        p = q; // Initial coordinates set to the ball's position.

        // Fold space.
        for(int i = 0; i<5; i++){
            p.xy = abs(p.xy); // Fold about xz and yz planes.
            p -= 2.*min(dot(p, nc), 0.)*nc; // Fold about nc plane.
        }

        // Analogous to moving local space out to the surface.
        p -= pg;

        // Object face distance.
        float d0 = dot(p, pab), d1 = dot(p, pbc), d2 = dot(p, pca);
        face = max(max(d0, d1), d2);
        //face -= abs((d0 + d1 + d2)/3. - face)*.25; // Subtle surface sparkle.

        // Object line distance.
        float dla = length(p - min(p.x, 0.)*vec3(1, 0, 0));
        float dlb = length(p - min(p.y, 0.)*vec3(0, 1, 0));
        float dlc = length(p - min(dot(p,nc), 0.)*nc);
        line = min(min(dla, dlb), dlc) - .025;

        // Vertices.
        vert = length(p) - .05;
    #endif
 
   
    
    // Storing the terrain, line, face and vertex information.
    vRID = vec4(ter, line, face, vert);

    // Return the minimum distance.
    return min(min(ter, line), min(face, vert));
 
}

// Function 4170
vec3 colormap(float x) {
    float s = sin(x*6.28);
    if (x > 0.) {
    	return vec3(1,1,1.+s)/2.;
    } else {
        return vec3(1,1.+s,1)/2.;
    }
}

// Function 4171
vec3 i_spheremap_16( uint data )
{
    vec2 v = unpackSnorm2x8(data);
    float f = dot(v,v);
    return vec3( 2.0*v*sqrt(1.0-f), 1.0-2.0*f );
}

// Function 4172
float mapOcreeeTruchet(vec3 p) {
    
    vec3 fp;
    vec3 lp;
    float len;
    float i;
    float size = 1.0;
    
    //r is the truchet cell you want the random 
    vec3 r = p;
    float j;
    checktree(limit);
    i = j;
    
    //the position in the bottom left corner of the truchet cell
    fp = floor(p*exp2(i))*exp2(-i);

    //the local position on the truchet cell (always 0-1)
    lp = fract(p*exp2(i));
    
    int type = int(hash13((fp+exp2(-i-1.0))*vec3(0.93,0.89,1.23))*4.0);
    len = truchet(lp,type)*exp2(-i);
    while (i <= limit) {
        //the position in the bottom left corner of the truchet cell
        fp = floor(p*exp2(i))*exp2(-i);
        //the local position on the truchet cell (always 0-1)
        lp = fract(p*exp2(i));
        //check for the overlapping black dots
        vec3 p2 = p*exp2(i);
        vec3 fp2 = floor(p2-0.5);
        for(int x = -0; x <= 1; x++) {
            for(int y = -0; y <= 1; y++) {
                for(int z = -0; z <= 1; z++) {
                    r = (fp2+vec3(x,y,z))*exp2(-i);
                    //this branch doesn't do anything, but it skips the random() once
                    if (r != fp)
                    {
                        checktree(i);

                        if (i==j) {
                            vec3 q = abs(p2-fp2-vec3(x,y,z)-0.5);
                            
                            vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));
                            q = min(q,q.yzx);
                            q2.y = max(max(q.x,q.y),q.z);
                            
                            float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;
                            
                            len = max(-outside*exp2(-i),len);
                        }
                    }
                }
            }
        }
        size *= 0.5;
        len *= -1.0;
        i++;
    }
    //len *= size;
    return len;
    
    /*vec3 q = abs(p-0.5);
    
    vec3 q2 = vec3(min(min(q.x,q.y),q.z),0,max(max(q.x,q.y),q.z));
    q = min(q,q.yzx);
    q2.y = max(max(q.x,q.y),q.z);
    
    float inside = length(abs(max(q2.yz-vec2(0.0,0.5),0.0)))-0.1667;
    float outside = length(abs(q2.yz-vec2(0.5,0.5)))-0.3333;
    
    if (floor(p) == vec3(0)) {
    	len = -outside;
    } else {
        len = inside;
    }
    return len;*/
    //return outside;

}

// Function 4173
surface_t box_sdf(vec3 query_point, int id, vec3 dimensions) {
	vec3 q = abs(query_point) - dimensions;  
  
    return surface_t(
        id,
        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)
    );
}

// Function 4174
vec3 SceneNormal(in vec3 p, in float d)
{
    vec2 eps = vec2(0.001 * d, 0.0);
    return normalize(vec3(Scene(p + eps.xyy).x - Scene(p - eps.xyy).x,
                          Scene(p + eps.yxy).x - Scene(p - eps.yxy).x,
                          Scene(p + eps.yyx).x - Scene(p - eps.yyx).x));
}

// Function 4175
float cyl_sdf(in highp vec3 point) {
	return soft_min(orig_cyl_sdf(point), sphere_sdf(point), 0.2);
}

// Function 4176
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.
    const vec2 e = vec2(.001, 0); 
    
    // Gradient vector: vec3(df/dx, df/dy, df/dz);
    float ref = bumpSurf3D(p);
   
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),
                      bumpSurf3D(p - e.yxy),
                      bumpSurf3D(p - e.yyx)) - ref)/e.x; 
    
    /*
    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.
    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),
                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),
                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;
    */ 
  
    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind 
    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.
    grad -= nor*dot(nor, grad);          
         
    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.
    return normalize(nor + grad*bumpfactor);
	
}

// Function 4177
vec3 map(in vec2 p, in float unit) {
    p *= 5.0;

    float n = 0.0;
    float nscale = 1.0;
    float tscale = 0.0;

    for (int o=0; o < 5; o++) {
        n += snoise(p) * nscale;
        tscale += nscale;
        nscale *= 0.5;
        p *= 2.0;
    }

    n /= tscale;
    return mix(vec3(0.0, 0.0, 1.0 - n), mix(vec3(0.0, 1.0, 0.0), vec3(0.8, 0.4, 0.0), n * n), smoothstep(0.5 - unit, 0.5 + unit, n));
}

// Function 4178
float dist(vec4 p, vec4 q, vec4 r) {
  mat2 m = inverse(mat2(dot(q,q),dot(q,r),dot(q,r),dot(r,r)));
  vec2 ab = m*vec2(dot(p,q),dot(p,r));
  // p1 in plane of q,r, on hypersphere
  ab = max(ab,0.0); // Clip to segment
  vec4 p1 = normalize(ab[0]*q + ab[1]*r);
  // And return the distance to the closest point.
  return dist(p,p1);
}

// Function 4179
vec2 map( in vec3 pos )
{
    vec2 mo = iMouse.xy/iResolution.xy;
    float dBox = sdBox(    pos-vec3( mo.x,mo.y, -0.5), vec3(0.25) );
    float dSphere = sdSphere(pos-vec3( 0.0, 0.5, 0.0), 0.25 );
    
    float approxDist = abs(func(pos)) / length(grad(pos)*2.0)-0.001;
    
    vec2 res = vec2(approxDist, (dBox+dSphere)*50.0);
    
    res = opU( res, vec2(dBox, 469.0 ) );
    res = opU( res, vec2(dSphere,50.0 ));
    
    res.x = opI( res.x, sdSphere(pos, 2.0));
       
    return res;
}

// Function 4180
SceneResult intersectScene(in Ray r, in float t) {
	SceneResult s;
	s.ref = 0.0;
	s.gloss = 0.0;
    
    HitTest test = NOHIT;
	
    if (intersectBox(r, Box(vec3(-20,0,-20), vec3(20,20,20)), test)) {
		// Room
		vec3 op = r.origin+r.dir*test.dist;
		
		float y = step(19.9, op.y);
        vec2 chk = floor(op.xz*0.2);
        chk = mod(chk, 2.0);
        float st = step(0.1, op.y);
        float c = st + mod(chk.x+chk.y, 2.) * (1. - st);
        
		s.col.rgb = mix(vec3(0.8) * c, vec3(1., 0.95, 0.9), y);
		s.col.a = y*3.;     
    }
    
    if (intersectSphere(r, Sphere(vec3(-8,6.0 + abs(sin(t*2.) * 6.),14), 6.0), test) ) {
        // silver ball
		s.col = vec4(.4,.5,.8,0.0);
		s.gloss = 0.3;
        s.ref = 0.0;
    }
    
    Triangle tri;
    float speed = sin(t*0.5) * 20.0;
    vec3 v0 = vec3(0,0,0);
    vec3 v1 = vec3(sin( speed), 1, cos( speed)) * 6.;
    vec3 v2 = vec3(sin( speed + PI * 0.5), 1, cos( speed + PI * 0.5)) * 6.;
    vec3 v3 = vec3(sin( speed + PI), 1, cos(speed + PI)) * 6.;
    vec3 v4 = vec3(sin( speed + PI * 1.5), 1, cos( speed + PI * 1.5)) * 6.;
    
    vec3 edgeA = v1-v0;
    vec3 edgeB = v2-v0;
    vec3 edgeC = v3-v0;
    vec3 edgeD = v4-v0;
    
	tri.v0 = v0;
    tri.edgeA = edgeB;
    tri.edgeB = edgeA;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    
    bool hitTri = false;
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    tri.edgeA = edgeC;
    tri.edgeB = edgeB;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    tri.edgeA = edgeD;
    tri.edgeB = edgeC;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    tri.edgeA = edgeA;
    tri.edgeB = edgeD;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    // top
    
    edgeA = v2-v1;
    edgeB = v4-v1;
    edgeC = v2-v3;
    edgeD = v4-v3;
    
    tri.v0 = v1;
    tri.edgeA = edgeA;
    tri.edgeB = edgeB;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    tri.v0 = v3;
    tri.edgeA = edgeD;
    tri.edgeB = edgeC;
    tri.n = normalize(cross(tri.edgeA, tri.edgeB));
    hitTri = hitTri || intersectTriangle(r, tri, test);
    
    if (hitTri) {
        // Triangle
        s.col = vec4(.8,.5,.5,0);
		s.ref = 1.0;
		s.gloss = 0.0;
    }
    
    if (intersectBox(r, Box(vec3(4,0,-4), vec3(20, 5, -14)), test)) {
        // gold box
        s.col = vec4(0.9, 0.9, 0.6, 0);
        s.ref = 0.9;
        s.gloss = 0.0;
    }
    s.dist = test.dist;
    s.normal = test.normal;
	
	return s;
}

// Function 4181
vec4 map( in vec2 p ) {
	vec3 pos = vec3(1, 1, 0);
    vec3 neg = vec3(0, 0, 0);
    vec3 green = vec3(0, 0, 1);
    
    vec4 d  = sdLine(p, vec2(-0.3, -0.3),  vec2(-0.3, 0.7), green, pos)-0.05;
    vec4 d2 = sdLine(p, vec2(0.7, 0.1), vec2(0.7, 0.7), pos, green)-0.05;
    vec4 d3 = sdLine(p, vec2(-0.3, -0.3),  vec2(0.7, -0.3), pos, green)-0.05;
    vec4 d4 = sdLine(p, vec2(-0.3, 0.7),  vec2(0.7, 0.7), green, pos)-0.05;
  
    if( d2.x<d.x ) d = d2;
    if( d3.x<d.x ) d = d3;
    if( d4.x<d.x ) d = d4;

    return d;
}

// Function 4182
SceneResult Scene_PipelineSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    
    SceneResult resultFloor;
    
    resultFloor.fDist = vPos.y;
    resultFloor.vUVW = vec3(vPos.zxy * 0.1);
    resultFloor.iObjectId = MAT_GRASS;

    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );
    
    
    float fRepeat = 5.0;
    float fOffset = fRepeat / 2.0;
    vec3 vPosRepeat = vPos;
    vPosRepeat.x = fract((vPosRepeat.x + fOffset) / fRepeat) * fRepeat - fOffset;
    
    
    vec3 vSphDomain = vPosRepeat;
    
    SceneResult pipeResult;
    
    vec3 vPipePos =  vSphDomain - vec3(0,1,0);
    
    float fAng = atan( vPipePos.x, vPipePos.y );
    
    pipeResult.fDist = length(vPipePos.xy) - 1.0;
    pipeResult.vUVW = vec3(vPos);
    pipeResult.vUVW.x = fAng;
    pipeResult.vUVW.y = vPos.z * 0.1;
    pipeResult.iObjectId = MAT_PIPE;
    
	SceneResult_Combine( resultInside, resultOutside, pipeResult, insideObjId );        
    
    
    {
        vec3 vPosRepeat2 = vPosRepeat;
        
    
    	float fRepeat = 4.0;
    	float fOffset = fRepeat / 2.0;
    	vec3 vPosRepeat = vPos;
    	vPosRepeat2.z = fract((vPosRepeat2.z + fOffset) / fRepeat) * fRepeat - fOffset;        
        
        
        vec3 vDiskPos =  vPosRepeat2 - vec3(0,1,0);
    	SceneResult diskResult;
        
        diskResult.fDist = length(vDiskPos.xy) - 1.2;
        diskResult.fDist = max( diskResult.fDist, vDiskPos.z - 0.1);
        diskResult.fDist = max( diskResult.fDist, -vDiskPos.z - 0.1);
        //pipeResult.fDist = min( pipeResult.fDist, -(vPosRepeat2.z -0.1) );
        //pipeResult.fDist = min( pipeResult.fDist, -0.1 );
        diskResult.vUVW = vec3(vPos);
    	//diskResult.vUVW.x = fAng * 0.01 + 0.3;
        diskResult.vUVW.x = fAng * 0.5 + 0.3;
    	diskResult.vUVW.y = vDiskPos.z + 0.9 + length( vDiskPos.xy); 
        
        diskResult.iObjectId = MAT_PIPE;

        SceneResult_Combine( resultInside, resultOutside, diskResult, insideObjId );        
         
    }
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 4183
float GetLightmapSphereFaceRes(Object obj)
{
    // assume 3x2 grid ..
	return (obj.lightmapBounds.w - obj.lightmapBounds.y)*0.5;
}

// Function 4184
float sdFrame(vec3 p)
{
    vec3 q = p;
    p *= 6.0; // normalize frame size
    p=abs(p) - 4.0;
    float d = sdChamferedCube1(p, vec3(2.0), 0.5);
    
	if (p.x>p.y) {p.xy = p.yx;}
	if (p.x>p.z) {p.xz = p.zx;}
    p.x += 3.5;
    p.zy -= 0.7;
    d = min(d, sdChamferedCube2(p, vec3(1.0, 1.0, 1.0), 0.2));
    
    p = q;
    p = abs(p);
	if (p.x<p.y) {p.xy = p.yx;}
	if (p.x<p.z) {p.xz = p.zx;}
    p.x -= 2.79;
    return max(-sdSphere(p, 2.0), d/6.0);
}

// Function 4185
float waterMap( vec2 pos ) {
	vec2 posm = pos * m2;
	
	return abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;
}

// Function 4186
vec3 BSDF(in Intersection inter, vec3 wi, vec3 wo){
 	float n = inter.material.shininess;
    bool is_lambert = n == 0.0f;
    float coswi = dot(inter.normal, wi);
    vec3 r = float(is_lambert) * inter.normal + 
        	 float(!is_lambert) * reflection(wo, inter.normal);
    float cosr = dot(wi, r);
    float coswo = clamp(dot(inter.normal, wo), -1.0f, 1.0f);
    bool ok = (coswi > 0.0f) && (cosr > 0.0f) && (coswo > 0.0f) ;
	
    vec3 bsdf = float(ok) * inter.material.albedo * pow(abs(cosr), n) * (n + 1.0f + float(is_lambert)) / TWO_PI;
    return bsdf;
}

// Function 4187
vec3 colorMap(in vec3 pos) {
    if (length(pos) < 1.0) {
        float gb = mix(0.0, 0.75, pos.x * 3.0 + 0.75);
        return vec3(0.75, gb, gb);
        
    } else {
    	return vec3(length(pos) * 0.15,
	                length(pos) * 0.2,
	                length(pos) * 0.2);
    }
}

// Function 4188
vec3 getSceneColor(in vec2 uv )
{
    vec4 fragColor;
//	vec2 uv = fragCoord.xy / iResolution.xy;
    
    if(uv.y > .666)
		fragColor = vec4(gradient(uv.x, color3, color2, colorC, colorD),1);
    else if(uv.y > .333)
		fragColor = vec4(gradient(uv.x, color2, color3, color4, color5, color6),1);
    else
		fragColor = vec4(gradient(uv.x, color0, color1, color2, color3, color4, color5, color6, color7, color8, color9, colorA, colorB, colorC, colorD, colorE, colorF),1);


    // post-processing courtesy of IQ ( https://www.shadertoy.com/view/ll2GD3 )

    // band
    float f = fract(uv.y*3.0);
    // borders
    fragColor.rgb *= smoothstep( 0.49, 0.47, abs(f-0.5) );
    // shadowing
    fragColor.rgb *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));
    
    return fragColor.rgb;
}

// Function 4189
vec2 map( in vec3 pos ) {
	float d= smin( sdPlane(pos), sdCube(pos-vec3( 0.0, 0.5, 0.0), 0.5 ) );
	return vec2(d,1.);
}

// Function 4190
vec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {
	
  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ,,()
  
  if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);
	
  float f=b*d-a*a; // ()
  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;
  vec2 gf=2.0*(b*d21+d*d10+a*d20);
  gf=vec2(gf.y,-gf.x); // ()
  vec2 pp=-f*gf/dot(gf,gf); // 
  vec2 d0p=b0-pp; //  to origin
  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ,()
  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))
  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // 
  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // = ()

}

// Function 4191
SDObject mapTablet(vec3 p,vec3 pos,vec3 ori,float tanim,int ignore,bool solo)
{

    SDObject body=newSDObject(10,Material(3,vec3(.04),Reflectivity(.60,0.45),0.,0.),
                              SDPrim(3,vec3((1.-tanim)*-1.,.5,-1.)+pos-(1.-tanim)*2.,ori,vec3(1.6,.1,.9),(1.),vec3(0.)));

    SDObject screen=newSDObject(10,Material(2,vec3(0.5),Reflectivity(.60,0.95),0.,.94),
                                SDPrim(3,vec3((1.-tanim)*-1.,.551,-1.)+pos+(1.-tanim),ori,vec3(1.6*0.9,.05,.9*0.85),(1.),vec3(0.)));

    SDObject led=newSDObject(10,Material(3,SCREEN_POWER==1?vec3(0.1,0.1,2.2):vec3(0.2),Reflectivity(.0,0.05),0.,.94*float(SCREEN_POWER)),
                             SDPrim(3,vec3(0.,.551,-1.+.9*0.92)+pos,ori,vec3(0.1,.05,0.025),(1.),vec3(0.)));

    SDObject res= SDOMap(body,p);
    res= SDUnion(res,SDOMap(screen,p),ignore,solo);
    res= SDUnion(res,SDOMap(led,p),ignore,solo);
    return res;
}

// Function 4192
float map(vec2 uv, mat2 q, vec2 l) {
    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));
}

// Function 4193
vec3 colormap(float value) {
	float maxv = ClampLevel;
	vec3 c1,c2;
	float t;
	if (value < maxv / 3.) {
		c1 = vec3(1.);   	   c2 = vec3(1., 1., .5);
		t =  1./3.;
	} else if (value < maxv * 2. / 3.) {
		c1 = vec3(1., 1., .5); c2 = vec3(1., 0,  0.);
		t =  2./3. ;
	} else {
		c1 = vec3(1., 0., 0.); c2 = vec3(0.);
		t =  1.;
	}
	t = (t*maxv-value)/(maxv/3.);
	return t*c1 + (1.-t)*c2;
}

// Function 4194
vec2 MapScene(vec3 rayPoint)
{
    vec2 spheres = MapSpheres(rayPoint);
    vec2 boxes = MapBoxes(rayPoint);
    vec3 p = rayPoint + vec3(0.0, -1.0, -9.5);
    pModInterval1(p.x, 2.0, -1.0, 1.0);
    vec2 box2 = vec2(SDFBox(p, vec3(0.3, 0.1, 0.2)), TYPE_BOX2);
    
    vec3 hp = rayPoint + vec3(0.05, 1.1, -4.1);
    Rotate(hp.xz, 3.15/2.5);
    Rotate(hp.yz, -3.15/4.3);
    float hex = SDFBox(hp, vec3(0.8, 1.2, 0.1)) - 0.05;
    
    box2 = Union(box2, vec2(hex, TYPE_BOX3));
    
    return Union(Union(spheres, boxes), box2);
}

// Function 4195
float mapSeedEmitter(vec2 uv){
    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);
    return length(seedCoord/iResolution.xy-uv)-seedSize;
}

// Function 4196
float sdfHex(vec2 uv) { vec2 auv = abs(uv); return max(auv.x * .866 + auv.y * .5, auv.y)-.5; }

// Function 4197
float sdf(vec3 p, int mask) 
{
	p= rotatey(p,iTime);
	float r = 100.;
    
    if ((mask&1)>0)
    {
        r = p.y;
        color = vec3(.7,.7,.7);
    }
    
    if ((mask&2)>0)
    {
        float r2 = box(p-vec3(2,2,0),vec3(1));
        if (r2<r)
        {
            r=r2;
            color = vec3(1,0,0);
        }
    } 
    
    if ((mask&4)>0)
    {
        float r2 = length(p-vec3(-2,3,0))-1.;
        if (r2<r)
        {
            r=r2;
            color = vec3(0,0,1);
        }
    }  
	return r;
}

// Function 4198
vec2 map( vec3 p, bool autoMode, float choice )
{	
	vec2 closest = vec2( 0.0 );
	if ( autoMode )
    {
        choice = mod( iTime, TOTAL_TIME ) / DISPLAY_PERIOD;
    }

	//========================================================
	if ( choice < 1.0 )	// SIMPLE SILVER SPHERE
	{
		// Animation
		//---------------------------------------
		// Animate object rotating around x-axis:
		p.yz = rot( p.yz, iTime * 0.19 );
	
		// Animate object rotating around y-axis:
		p.xz = rot( p.xz, iTime * 0.25 );
	
		// Animate object rotating around z-axis:
		p.xy = rot( p.xy, iTime * 0.17 );
	
		// Domain repetitions
		// ---------------------------------------------------	
		p.xz = rotsim( p.xz, 30.0 );
		p.z -= 1.5 + 0.5 * sin( iTime * 0.23 );
		
		p.yz = rotsim( p.yz, 32.0 );
		p.z -= 18.0 + 0.5 * sin( iTime * 0.29 );
		
		p.xy = rotsim( p.xy, 9.0 );
		p.y -= 1.0 + 0.5 * sin( iTime * 0.31 );
		
		p = sim( p, 22.0 );
		
		// Objects
		//--------		
		float objID = 1.0;
		float d1 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d2 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d3 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d4 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d5 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d6 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d7 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		
		p.xy = rot( p.xy, PI * -0.25 );	
		float d8 = fCone( p, 0.1, 5.0 + 4.0 * sin( iTime ) );
		      
		vec2 obj1 = vec2( min( min( min( min( min( min( min( d1, d2 ), d3 ), 
		                                 d4 ), d5 ), d6 ), d7 ), d8 ), objID );
                                           	      		
		// Distance comparisons to find closest object
		//--------------------------------------------
		closest = obj1;	
		
	} // end if ( choice < 1.0 )		
	//========================================================
	else if ( choice < 2.0 )	// SILVER SPIKED SPHERE
	{
		p.x -= 7.0 * sin( iTime * 0.23 );
        p.z -= 3.0 + 2.5 * sin( iTime * 0.17 );
        
        vec3 p2 = p;
		
		p.yz = p2.yz = rot( p.yz, iTime * 0.29 );
		p.xz = p2.xz = rot( p.xz, iTime * 0.31 );
		p.xy = rot( p.xy, iTime * 0.23 );
	
		p2.yz = rotsim( p2.yz, 9.0 );
		p2.z -= 0.1;
		
		p2.xz = rotsim( p2.xz, 80.0 );
		p2.z -= 5.0;
		
		p = sim( p, 24.0 );
		
		float objID = 2.0;
		float d1 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d2 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d3 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d4 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d5 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d6 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d7 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d8 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d9 = fCone( p2, 0.1, 1.0 );
		
		p2.yz = rot( p2.yz, PI * -0.1111 );	
		float d10 = fCone( p2, 0.1, 1.0 );
		      
		vec2 obj1 = 
		vec2( min( min( min( min( min( min( min( min( min( d1, d2 ), d3 ), 
		                    d4 ), d5 ), d6 ), d7 ), d8 ), d9 ), d10 ), objID );
				
		objID = 3.0;
		vec2 obj2 = vec2( sdSphere( p, 4.9 ), objID );
		
		closest = obj1.s < obj2.s ? obj1 : obj2;
		
	} // end else if ( choice < 2.0 )
	//========================================================
	else if ( choice < 3.0 )	// CUBED SPHERE FIREWORKS
	{
		p.yz = rot( p.yz, iTime * 0.79 );
		p.xz = rot( p.xz, iTime * 0.61 );
		p.xy = rot( p.xy, iTime * 0.87 );
	
		pMirror( p.x, 2.0 );
		pMirror( p.y, 2.0 );
		pMirror( p.z, 2.0 );
	
		pMirrorOctant( p.xz, vec2( 2.0 ) );
		
		p.yz = rotsim( p.yz, 10.0 + 9.0 * sin( iTime * 0.83 ) );
		p.z -= 1.0;
		
		p.xz = rotsim( p.xz, 10.0 + 9.0 * sin( iTime * 0.67 ) );
		p.z -= 2.0;
		
		p.xy = rotsim( p.xy, 10.0 + 9.0 * sin( iTime * 0.53 ) );
		p.y -= 0.1;
	
		p = sim( p, 6.0 );
	
		float objID = 4.0;
		vec2 obj1 = vec2( sdBox( p - vec3( 0.0, 0.0, 0.0 ), 
		                                      vec3( 1.0, 0.1, 0.1 ) ), objID );
		closest = obj1;	
		
	} // end else if ( choice < 3.0 )
	//========================================================	
	else if ( choice < 4.0 )	// UFO
	{
		p.x -= 12.0 * sin( iTime * 0.9 );
		p.z -= 8.0 * sin( iTime * 0.23 );
		p.y -= 1.5 * ( 1.0 + sin( iTime * 0.7 ) );
		
		vec3 p2 = p,
		     p3 = p,
		     p4 = p,
		     p5 = p;
	
		p.xz = p2.xz = rotsim( p.xz, 4.5 );
		p2.z -= 4.0;
		p.z -= 4.0;
		
		p.xz = p2.xz = rotsim( p.xz, 4.5 );
		p2.z -= 2.925;
		p.z -= 2.925;

		p3.x = repeat( p3.x, 25.0 );
		p3.y = repeat( p3.y, 15.0 );
		p3.z = repeat( p3.z, 30.0 );
	
		p4.x = repeat( p4.x, 25.0 );
		p4.y = repeat( p4.y, 15.0 );
		p4.z = repeat( p4.z, 30.0 );
	
		p5.x = repeat( p5.x, 25.0 );
		p5.y = repeat( p5.y, 15.0 );
		p5.z = repeat( p5.z, 30.0 );
	
		float objID = 5.0;
		vec2 obj1 = vec2( sdPlane( p - vec3( 0.0, -10.0, 0.0 ) ), objID );
		
		objID = 6.0;	
		// Rotate pyramid so flat face is facing screen.
		p2.xz = rot( p2.xz, PI * 0.25 );
		float d1 = pyramid( p2, 1.5 ),
		      d2 = modPyramid( p - vec3( 0.0, 0.1, 0.0 ), 1.35, 1.35 );
		vec2 obj2 = vec2( max( d1, -d2 ), objID );
		
		objID = 7.0;
		d1 = sdSphere( p - vec3( 0.0, 1.25, 0.0 ), 2.0 );
		d2 = sdSphere( p - vec3( 0.0, 1.25, 0.0 ), 1.9 );
		float d3 = fCylinder( p.xzy - vec3( 0.0, 0.0, 1.2 ), 1.15, 3.25 ),
		      d4 = fCylinder( p.zxy - vec3( 0.0, 0.0, 1.2 ), 1.15, 3.25 );
		vec2 obj3 = vec2( max( d1, max( max( -d2, -d3 ), -d4 ) ), objID ) ;	      
		      		
		objID = 8.0;
		vec2 obj4 = vec2( sdSphere( p - vec3( 0.0, 0.5 + 0.75 * 
		                           -sin( iTime ), 0.0 ), 0.25 ), objID );
		
		p.xz = rot( p.xz, -3.0 * iTime );			
		objID = 9.0;
		vec2 obj5 = vec2( pyramid( p - vec3( 0.0, 2.0, 0.0 ), 0.25 ), objID );
		
		objID = 10.0;
		vec2 obj6 = 
        vec2( sdTorus( p - vec3( 0.0, 0.9375 + 0.9375 * sin( iTime ), 
               0.0 ), vec2( 0.8 + 0.7 * -sin( iTime ), 0.05 ) ), objID );	
		
		objID = 6.0; 
		p3.xy = rot( p3.xy, iTime * 0.37 );
		p3.xz = rot( p3.xz, iTime * 0.51 );
		p3.yz = rot( p3.yz, iTime * 0.71 );
		vec2 obj7 = 
				  vec2( sdSphere( p3 - vec3( 16.0, 0.0, 0.0 ), 0.07 ), objID );
		
		objID = 8.0;
		p4.xy = rot( p4.xy, iTime * 0.57 );
		p4.xz = rot( p4.xz, iTime * 0.71 );
		p4.yz = rot( p4.yz, iTime * 0.83 );
		vec2 obj8 = 
		         vec2( sdSphere( p4 - vec3( -16.0, 0.0, 0.0 ), 0.08 ), objID );
		
		objID = 9.0;
		p5.xy = rot( p5.xy, iTime * 0.47 );
		p5.xz = rot( p5.xz, iTime * 0.87 );
		p5.yz = rot( p5.yz, iTime * 0.67 );
		vec2 obj9 = 
		           vec2( sdSphere( p5 - vec3( 8.0, 8.0, 0.0 ), 0.06 ), objID );
		
		closest = obj1.s < obj2.s ? obj1 : obj2;
		closest = closest.s < obj3.s ? closest : obj3;
		closest = closest.s < obj4.s ? closest : obj4;
		closest = closest.s < obj5.s ? closest : obj5;
		closest = closest.s < obj6.s ? closest : obj6;
		closest = closest.s < obj7.s ? closest : obj7;
		closest = closest.s < obj8.s ? closest : obj8;
		closest = closest.s < obj9.s ? closest : obj9;
		
	} // end else if ( choice < 4.0 )
	//========================================================	
	else if ( choice < 5.0 )	// SPACE STATION
	{
		p.x -= 10.0 * sin( iTime * 0.19 );
		vec3 p2 = p,
		     p3 = p;
		
		p.yz = p2.yz = rot( p.yz, iTime * 0.19 );
		p.xz = p2.xz = rot( p.xz, iTime * 0.29 );
		p.xy = p2.xy = rot( p.xy, iTime * 0.13 );
	
		p.xz = rotsim( p.xz, 8.0 );
		p.z -= 8.0 + 2.0 * sin( iTime * 0.23);
		
		p.yz = rotsim( p.yz, 8.0 );                    
		p.z -= 3.0 + 1.25 * sin( iTime * 0.19 );
		
		p.xy = rotsim( p.xy, 2.0 );
	
		float objID = 11.0; 
		vec2 obj1 = vec2( fCone( p, 0.25, 1.0 ), objID );
		                                         	
		objID = 12.0; 
		vec2 obj2 = 
		      vec2( fCone( p.xzy - vec3( 0.0, 0.2, 0.0 ), 0.25, 1.0 ), objID );
		                                                            
		p.xz = rot( p.xz, PI );
		objID = 13.0;
		vec2 obj3 = 
		      vec2( fCone( p.xzy - vec3( 0.0, 0.2, 0.0 ), 0.25, 1.0 ), objID );
		                                                            		
		objID = 14.0;
		vec2 obj4 = vec2( sdSphere( p - vec3( 0.0, 1.0, 1.5 ), 0.1 ), objID );		             
		                                                            			
		objID = 15.0;
		vec2 obj5 = vec2( sdSphere( p - vec3( 0.0, 0.0, 3.0 ), 0.15 ), objID ); 
		                                                            			
		objID = 16.0;
		vec2 obj6 = vec2( sdSphere( p - vec3( 0.0, 0.0, -1.5 ), 0.05 ), objID );
		                                                            			
		objID = 17.0;
		   vec2 obj7 = vec2( sdEllipsoid( p2, vec3( 1.5, 3.0, 1.5 ) ), objID );

		objID = 18.0;
		    vec2 obj8 = vec2( sdPlane( p3 - vec3( 0.0, -13.0, 0.0 ) ), objID );

		closest = obj1.s < obj2.s ? obj1 : obj2;
		closest = closest.s < obj3.s ? closest : obj3;
		closest = closest.s < obj4.s ? closest : obj4;
		closest = closest.s < obj5.s ? closest : obj5;
		closest = closest.s < obj6.s ? closest : obj6;
		closest = closest.s < obj7.s ? closest : obj7;
		closest = closest.s < obj8.s ? closest : obj8;
		
	} // end else if ( choice < 5.0 )
	//========================================================	
	else if ( choice < 6.0 )	// SILVER SOCKET STARS
	{
		p.yz = rot( p.yz, iTime * 0.11 );
		p.xz = rot( p.xz, iTime * 0.13 );
		p.xy = rot( p.xy, iTime * 0.07 );
	
		p.yz = rotsim( p.yz, 8.0 );
		p.z -= 1.0;
	
		p.xz = rotsim( p.xz, 8.0 );
		p.z -= 18.0;
	
		p.xy = rotsim( p.xy, 3.0 );
		p.y -= 0.5;
		
		p = sim( p, 15.0 );
	
		float objID = 19.0;
		vec2 obj1 = vec2( cutoutPyramid( p, 3.0 ), objID );
		
		closest = obj1;	
		
	} // end else if ( choice < 6.0 )
	//========================================================	
		
	return closest;	
}

// Function 4199
void scene(){
	sphere ball;
	ball.pos=vec3(0.,-3.,10.);
	ball.size=17.;
	if(resolveRaySphereIntersection(ball))
	for(float reflection=0.; reflection<=6.; reflection++){
		
	polygon test2;
	test2.A=vec3(9., -10., 10.);
	test2.B=vec3(4., -10., -10.);
	test2.C=vec3(9., 10., 10.);
	test2.color=vec3(.61,.8,.51);
	resolveRayPolygonIntersection(test2);
	polygon test3;
	test3.C=vec3(-12., -10., 10.);
	test3.B=vec3(-7., -10., -10.);
	test3.A=vec3(-1., 30., 0.);
	test3.color=vec3(.8,.5,.5);
	resolveRayPolygonIntersection(test3);
		
	for(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){
			polygon ympyraPala;
			ympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));
			ympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));
			ympyraPala.C=vec3(0.0, 4.+1.*sin(iTime*3.782562261), 0.0);
			ympyraPala.color=vec3(.31,.0,.0);
			resolveRayPolygonIntersection(ympyraPala);
	}
	for(float i=3.14*2000.0; i<3.14*4000.0; i+=3.14*400.0){
			polygon ympyraPala;
			ympyraPala.A=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));
			ympyraPala.B=vec3(4.0*cos(i+3.14*400.), -1.0, 4.0*sin(i+3.14*400.));
			ympyraPala.C=vec3(4.0*cos(i), -1.0, 4.0*sin(i));
			ympyraPala.color=vec3(.31,.0,.0);
			resolveRayPolygonIntersection(ympyraPala);
			ympyraPala.C=vec3(5.0*cos(i+3.14*400.), -3.0+1.*sin(iTime*3.782562261-1.), 5.0*sin(i+3.14*400.));
			ympyraPala.B=vec3(5.0*cos(i), -3.0+1.*sin(iTime*3.782562261-1.0), 5.0*sin(i));
			ympyraPala.A=vec3(4.0*cos(i), -1.0, 4.0*sin(i));
			ympyraPala.color=vec3(.31,.0,.0);
			resolveRayPolygonIntersection(ympyraPala);
	}
	polygon RR;
	RR.A=vec3(-10., -6., -10.);
	RR.B=vec3(10., -6., -10.);
	RR.C=vec3(-10., -6., 10.);
	RR.color=vec3(.104,.1,.31);
	resolveRayPolygonIntersection(RR);
	RR.A=vec3(10., -6., -10.);
	RR.B=vec3(10., -6., 10.);
	RR.C=vec3(-10., -6., 10.);
	RR.color=vec3(.104,.1,.31);
	resolveRayPolygonIntersection(RR);
		
	for(float j=-1.0; j<4.0; j++)
		for(float i=-2.0; i<2.0; i++){
			polygon tasoPalaA;
			tasoPalaA.C=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);
			tasoPalaA.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);
			tasoPalaA.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);
			tasoPalaA.color=vec3(.41,.41,.41);
			resolveRayPolygonIntersection(tasoPalaA);
			polygon tasoPalaB;
			tasoPalaB.C=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., 4.0*j);
			tasoPalaB.B=vec3(4.0*i+4.0, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);
			tasoPalaB.A=vec3(4.0*i, -4.0+sin((i+j+iTime)*.71)*2., -4.0+4.0*j);
			tasoPalaB.color=vec3(.41,.41,.41);
			resolveRayPolygonIntersection(tasoPalaB);
		}
		resolveRay(reflection);
		color+=vec3(min(resolveRayLightIntersection(sun),0.0));
	closestPoint.distanceFromCamera=100000.;
	}
}

// Function 4200
vec2
Map(vec3 p)
{
    vec2 res = vec2(1e10, -1.0);

    //Interior
    UOP(sdSphere(p - vec3(0.2, 0.0, -0.5), 0.1), SPHERE_ID);
    vec3 q = p;
    q.xz = rotate(q.xz, -0.4);
    UOP(sdBox(q - vec3(-0.2, 0.0, -0.2), vec3(0.1, 0.3, 0.1)), BOX_ID);

    //Exterior box
    UOP(sdBox(p - vec3(0.0, -0.1, 0.0), vec3(0.5, EPS, 1.0)), WALL_ID);
    UOP(sdBox(p - vec3(-0.5, 0.2, 0.0), vec3(EPS, 0.5, 1.0)), LEFT_WALL_ID);
    UOP(sdBox(p - vec3(0.5, 0.2, 0.0), vec3(EPS, 0.5, 1.0)), RIGHT_WALL_ID);
    UOP(sdBox(p - vec3(0.0, 0.7, 0.0), vec3(0.5, EPS, 1.0)), LIGHT_ID);
    UOP(sdBox(p - vec3(0.0, 0.0, 0.3), vec3(1.0, 1.0, EPS)), WALL_ID);
    
    return res;
}

// Function 4201
vec3 filmicToneMapping(vec3 color)
{
	color = max(vec3(0.), color - vec3(0.004));
	color = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);
	return color;
}

// Function 4202
float Map(in vec3 P)
{
    // Room walls.
    vec3 t = roomsize - abs(vec3(P.x, P.y - roomsize.y, P.z));
    float d = min(t.x, min(t.y, t.z));
    
    // Repeated sphere.
    P.xz = mod(P.xz + vec2(0.0, -0.75), 4.0);
    d = min(d, length(P - vec3(2.0, 3.25, 2.0)) - 1.2);
    return d;
}

// Function 4203
float map(float value, float inMin, float inMax, float outMin, float outMax) {
  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
}

// Function 4204
float map(vec3 p, bool setMat){
    float c = 10.;
    p.x = mod(p.x+c*0.5,c)-c*0.5;
    p.z = mod(p.z+c*0.5,c)-c*0.5;
    vec3 cylPos = vec3 (0.,0.,0.); 
    float bulb = roundCone(p+vec3(0,-11.0,0),1.2,1.4,1.);
    float tip1 = sphere(p+vec3(0,-13.35,0),0.3);
    float tip2 = sphere(p+vec3(0,-13.1,0),0.5);
    
    float minD =min(tip1,
               	min(tip2,
               	min(bulb,
               	smoothUnion(torus(p+vec3(0,-10.2,0),vec2(0.7,0.4)),
        		smoothUnion(octagon(p+vec3(0,6.5,0),vec3(1.05,0.4,1.05)),
               	smoothUnion(torus(p+vec3(0,-8.6,0),vec2(0.53,0.1)),
                smoothUnion(torus(p+vec3(0,-7.8,0),vec2(0.56,0.1)),
                smoothUnion(cyl(p+cylPos),lampBase(p),1.0),0.1),0.1),0.1),0.5))));
    
    if(setMat){
    if(minD == bulb ||minD == tip1 ||minD == tip2){//Lamp Light
            mat = 2;
    }else{mat =3;}//Lamp Body
        
    }
    return minD;
    
}

// Function 4205
vec3 getSceneColor(in vec3 ro, in vec3 rd)
{
    vec3 bgcol = getCubeColor(ro,rd);
	return getTextColor(bgcol);
}

// Function 4206
float distanceEstimation(vec3 pos) {
    if(length(pos) > 1.5) return length(pos) - 1.2;
    vec3 z = pos;
    float dr = 1.0, r = 0.0, theta, phi;
    for (int i = 0; i < 15; i++) {
        r = length(z);
        if (r>1.5) break;
        dr =  pow( r, Power-1.0)*Power*dr + 1.0;
        theta = acos(z.z/r) * Power + ThetaShift;
        phi = atan(z.y,z.x) * Power + PhiShift;
        float sinTheta = sin(theta);
        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;
    }
    return 0.5*log(r)*r/dr;
}

// Function 4207
float sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz;
    float b = dot( oc, rd );
    float h = dot( oc, oc ) - b*b;
    return sqrt( max(0.0,h)) - sph.w;
}

// Function 4208
Hit mapDistance(vec3 p){
    Hit h = hit();
    

    float mont = abs(.2*cos(p.x+cos(p.x)+.1*cos((p.x+p.y)*22.2)+sin(p.z)));
    float mont2 = .3*min(0., 8.-length(p.xz*.1))*(cos((p.x+.1+5000.1)*0.003)+(cos((p.z+1100.)*0.002)));//;
    Hit hl = hit(1, p, p.y+1.+ mont + mont2);

    h = join(h, hl);
    //h = join(h,  hit(3, p, -p.y+300.));

    Hit hc = hit();
    hc = join(hc, hit(2, p, abs(sdBox(abs(p)*.5-1.,vec3(-0.1,-1.,-.1), vec3(.2,0.5,0.2)))-.01));
    hc = join(hc, hit(2, p, abs(sdBox(abs(p)*.5-1.,vec3(-0.5), vec3(.11,1.0,0.1)))-.01));
    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.), vec3(.5,1.0,0.5)))-.01));
    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.), 1.*vec3(.9,.1,.9)))-.01));
    hc = join(hc, hit(2, p, abs(sdBox((p)*.5,vec3(0.,-0.3,0.), vec3(1.,.2,1.)))-.01));
  
    h = join(h, hc);

    return h;
}

// Function 4209
void traceScene(in vec3 ro, in vec3 rd, out float d, out vec3 n)
{
    d = MAX_DEPTH;
    n = vec3(0,1,0);
    intersectPlane(vec3(0,1,0), vec3(0,-.333,0), ro, rd, n, d);
    intersectPlane(vec3(0,-1,0), vec3(0,.333,0), ro, rd, n,d );
    
    float h = min(iTime*.667, .667);
    #define XWALL(x,z,l) intersectQuad(vec3(x,-.333,z),vec3(l,0,0),vec3(0,h,0),ro,rd,n,d)
    #define ZWALL(x,z,l) intersectQuad(vec3(x,-.333,z),vec3(0,0,l),vec3(0,h,0),ro,rd,n,d);
    XWALL(-4,-4,8);
    XWALL(4,4,-8);
    ZWALL(-4,-4,8);
    ZWALL(4,4,-8);
    
    XWALL(-4,-3, 1);
    ZWALL(-2,-4, 2);
    XWALL(-3,-2, 1);
    ZWALL(-3,-2, 3);
    XWALL(-4, 2, 2);
    ZWALL(-2, 1, 1);
    XWALL(-2, 1, 1);
    ZWALL(-1,-3, 4);
    XWALL(-3, 0, 1);
    XWALL(-2,-1, 1);
    XWALL(-1,-3, 1);
    ZWALL( 1,-4, 2);
    XWALL( 0,-2, 1);
    ZWALL( 0,-2, 1);
    XWALL(-1, 0, 2);
    XWALL( 1,-1, 2);
    ZWALL( 2,-3, 2);
    XWALL( 2,-3, 1);
    XWALL( 3,-2, 1);
    XWALL( 2, 0, 2);
    ZWALL( 2, 0, 2);
    XWALL( 0, 1, 2);
    ZWALL( 0, 1, 1);
    XWALL(-1, 2, 1);
    ZWALL(-1, 2, 1);
    XWALL(-3, 3, 2);
    ZWALL( 0, 3, 1);
    ZWALL( 1, 2, 1);
    XWALL( 1, 3, 3);
    XWALL( 2, 2, 1);
    ZWALL( 3, 1, 1);
    
    #undef XWALL
    #undef ZWALL
}

// Function 4210
float sceneSDF(vec3 samplePoint) {    
    // Slowly spin the whole scene
    samplePoint = rotateY(iTime / 2.0) * samplePoint;
    
    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;
    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);
    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);
    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);
    
    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));
    
    float sphere = sphereSDF(samplePoint, 1.2);
    
    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);
    float ballRadius = 0.3;
    float balls = sphereSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);
    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));
    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));
    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));
    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));
    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));
    
    
    
    float csgNut = differenceSDF(intersectSDF(cube, sphere),
                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));
    
    return unionSDF(balls, csgNut);
}

// Function 4211
result distanceFieldShadow(vec3 p, float t)
{
	result res;
	res = bouncyBoi(p,t);
	res = compare(res, world(p,t));
	return res;
}

// Function 4212
float distFunc(vec3 p)
{
    // Basic shape
    float d1 = distSphere(p - sphere1Pos, sphere1Rad);
    float d2 = distSphere(p - sphere2Pos, sphere2Rad);
    float d3 = distSphere(p - sphere3Pos, sphere3Rad);    
    float d4 = distCylinder(p - cylinder1Pos, cylinder1Size, cylinder1Rotate);
    float d5 = distCylinder(p - cylinder2Pos, cylinder2Size, cylinder2Rotate);
    
    // Eyebrows
    float d6 = distCylinder(p - eyebrow1Pos, eyebrow1Size, eyebrow1Rotate);
    float d7 = distCylinder(p - eyebrow2Pos, eyebrow2Size, eyebrow2Rotate);
    float d8 = distCylinder(p - eyebrow3Pos, eyebrow3Size, eyebrow3Rotate);
    float d9 = distCylinder(p - eyebrow4Pos, eyebrow4Size, eyebrow4Rotate);
       
    return smin(smin(smin(smin(smin(smin(min(min( d1, d2), d3), d4), d5), d6), d7), d8), d9);
}

// Function 4213
vec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)
{
	float white = 2.;
	float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
	float toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);
	color *= toneMappedLuma / luma;
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 4214
vec3 colormap(int index, float t) {
    float c = float(index) + 1.;
    return .5 + .45*cos(2.*PI  * pow(t, 0.4) * c + vec3(c, c+2., c+1.) / .6 + vec3(0, 1, 2));
}

// Function 4215
float getDist(vec3 ro, vec3 rd, vec3 vs, out vec3 vc)
{
	float ds = -1.0;
	
	vec3 p = ro;
    for (int i=0;i<layers;i++)
	{
		vc = (floor(p / vs) + 0.5) * vs; // voxel center
		ds = getPrimitive(ro, rd, vc); 	// distance to analytic primitve
		if (ds > 0.0) break; 		// hit => exit
		p += rd * vs;			// move point to next voxel along ray if no hit
	}
    
    // for render when no hit after all layers
	if (ds < 0.0)
		ds = float(layers);
	
	return ds;
}

// Function 4216
float DifferenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

// Function 4217
float map_bulb(vec3 pos)
{
    pos.y*=0.6;
    return length(pos) - 0.65;
}

// Function 4218
float RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}

// Function 4219
maybe_float get_distance_along_3d_line_to_ellipsoid(
    in vec3 A0,
    in vec3 A,
    in vec3 B0,
    in vec3 R
){
    // NOTE: shamelessly copy pasted, all credit goes to Inigo: 
    // https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
    vec3 Or = (A0 - B0) / R;
    vec3 Ar = A / R;
    float ArAr = dot(Ar, Ar);
    float OrAr = dot(Or, Ar);
    float OrOr = dot(Or, Or);
    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);
    return maybe_float(
        (-OrAr - sqrt(h)) / ArAr, 
        h >= 0.0
    );
}

// Function 4220
vec2 map(vec3 pos)
{
    vec3 posr = rotateVec2(pos);
    //return vec2(map_s(posr), LAMPG_OBJ);
    #ifdef bulb
    vec2 res = opU(vec2(map_lampg(posr), LAMPG_OBJ),
                   vec2(map_bulb(posr),  BULB_OBJ));
    #else
    vec2 res = vec2(map_lampg(posr), LAMPG_OBJ);
    #endif
    #ifdef metal_rings
    res = opU(res, vec2(map_metalrings(posr),  METALRINGS_OBJ));
    #endif
    #ifdef supports
    res = opU(res, vec2(map_supports(posr),  SUPPORTS_OBJ));
    #endif
    return res;
}

// Function 4221
float SDF( vec3 pos )
{
    return min(min(min(
        	TreeSDF(pos),
        	Baubles1(pos)),
        	Baubles2(pos)),
        	Baubles3(pos));
}

// Function 4222
float distanceField(vec3 p)
{
    vec3 c, q;
    float xBox, yBox, zBox;
    float dist = MAX_DIST;
    float minor = 0.05;
    float major = 2.5;
    float soften = 0.05;
    float separation = 5.;
    
    #ifdef ORBS
        c = vec3(5.);
        q = mod(p,c)-0.5*c;
        dist = min(dist, sdSphere(q, 0.47));
    #endif
    
    #ifdef SCAFFOLDS
        c = vec3(separation);
        q = mod(p,c)-0.5*c;

        xBox = udRoundBox(q, vec3(major,minor,minor), soften);
        yBox = udRoundBox(q, vec3(minor,major,minor), soften);
        zBox = udRoundBox(q, vec3(minor,minor,major), soften);

        dist = min(dist, min(min(xBox, yBox), zBox));
    #endif
    
    #ifdef CAMERA_TARGET
    	q = p - cameraTarget;
    
    	xBox = udRoundBox(q, vec3(major,minor,minor), soften);
        yBox = udRoundBox(q, vec3(minor,major,minor), soften);
        zBox = udRoundBox(q, vec3(minor,minor,major), soften);

        dist = min(dist, min(min(xBox, yBox), zBox));
    #endif
    
    return dist;
}

// Function 4223
float sdf_J(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(4, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));
    return t;
}

// Function 4224
float distToEnterPlanet(float mu, float r) {
    float discriminant = r * r * (mu * mu - 1.0) + A_r * A_r;
    return max(-r * mu - sqrt(max(discriminant, 0.)), 0.);
}

// Function 4225
vec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c, in vec2 d)
{
    float d0 = ip_control(uv, a, b, c, d);
    float point = 0.;
    
#ifdef ANIMATED
    point = ip_point(uv, a, b, c, d);
#endif
    
    float d1 = ip_curve(uv, a, b, c, d);    
    float rs = max(d0, d1);
    
    return (point < .5)
        ? rs * (d0 > d1 ? COL0 : COL1)
        : point * COL3;
}

// Function 4226
vec3 Tonemap(vec3 color)
{
    #if TONEMAP_TYPE == LINEAR_TONEMAP
    color *= vec3(TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP
    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);
    #endif
    #if TONEMAP_TYPE == REINHARD_TONEMAP
    color *= TONEMAP_EXPOSURE;
    color = color / (1.0 + color);
    #endif
    #if TONEMAP_TYPE == FILMIC_TONEMAP    
    color *= TONEMAP_EXPOSURE;
    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);
    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));
    color = tonemapedColor * whiteScale;
    #endif
   
    return color;
}

// Function 4227
float scene(vec3 p)
{
	return max(-(length(mod(p,vec3(40.))-.5*vec3(40.))-24.),max(-(length(mod(p,vec3(10.))-.5*vec3(10.))-6.),max(-(length(mod(p,vec3(2.5))-.5*vec3(2.5))-1.5),-(length(mod(p,vec3(.625))-.5*vec3(.625))-.375))));
}

// Function 4228
float sdf_M(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half0_torus(pos, vec3(6, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(8, -2, 0), vec3(8, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -8, 0)));
    return t;
}

// Function 4229
float map(vec3 p){

    // A bit of cheap, lame distortion for the heaving in and out effect.
    p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;
    
    // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).
    // Adding some height to the plane from the texture. Not much else to it.
    return 1. - p.z - texture(iChannel0, p.xy).x*.1;

    
    // Flattened tops.
    //float t = texture(iChannel0, p.xy).x;
    //return 1. - p.z - smoothstep(0., .7, t)*.06 - t*t*.03;
    
}

// Function 4230
void map_orbit_track( inout vec3 col, vec2 sc )
{
    vec3 dpdx = ZERO, dpdy = ZERO;    
    vec4 p = gs_map_unproject_d( g_game, sc, iResolution.xy, dpdx, dpdy );    
    vec4 px = vec4( dpdx.x, dpdy.x, 0, p.x );
    vec4 py = vec4( dpdx.y, dpdy.y, 0, p.y );
    vec4 pz = vec4( dpdx.z, dpdy.z, 0, p.z );    
    vec4 plng = atan2_d( py, px );

    vec3 r = g_vehicle.localr;
    vec3 v = g_vehicle.orbitv * g_planet.B; // not: localv!     
    Kepler K = Kepler( 0., 0., 0., 0., 0. );
    float nu = kepler_init( K, r, v, g_data.GM );  
    float M = cvt_E2M( cvt_nu2E( nu, K.e ), K.e );    
    vec3 h = cross( r, v );
    float invsin_i = length(h) / length( h.xy );
    float invtan_i = h.z / length( h.xy );
    if( K.e < .00005 )
    {
		K.w = asin( clamp( normalize(r).z * invsin_i, -1., 1. ) );
        if( v.z < 0. )
            K.w = PI - K.w;
    }
    
    vec4 dlng = asin_d( clamp_d( div_d( pz, hypot_d( px, py ) ) * invtan_i, -ONE_D, ONE_D ) );
    vec4 dnu = asin_d( clamp_d( pz * invsin_i, -ONE_D, ONE_D ) );        
    float dMdt = sqrt( g_data.GM * cube( abs( 1. - K.e * K.e ) / K.p ) );
    float dphidM = g_planet.omega / dMdt;    
    mat2x4 ll = mat2x4( const_d( K.O ) + dlng, const_d( K.O ) - dlng - const_d(PI) );
    mat2x4 nn = mat2x4( const_d( -K.w ) + dnu, const_d( -K.w ) - dnu - const_d(PI) );
    mat2x4 MM = mat2x4( cvt_E2M_d( cvt_nu2E_d( nn[0], K.e ), K.e ), cvt_E2M_d( cvt_nu2E_d( nn[1], K.e ), K.e ) );
    mat2x4 aa = MM - mat2x4( const_d(M), const_d(M) );   
    vec2 KK = vec2( length( ll[0].xy - plng.xy - aa[0].xy * dphidM ), length( ll[1].xy - plng.xy - aa[1].xy * dphidM ) );
    vec2 JJ = vec2( length( aa[0].xy ), length( aa[1].xy ) );
    
    vec3[3] colors = vec3[3]( 
        vec3( .9, .7, .1 ),
        vec3( .4, .4, .4 ),
        vec3( .1, .1, .1 ) );
    
    float stipple = 15. * dMdt;
    float mask = aaa_interval( dFdy(p.w), p.w, 2. );   
    float revlimit = 3. * TAU;
    
#define w2vec2( _a ) vec2( _a[0].w, _a[1].w )
    
    if( mask >= FRACT_1_64 )
    for( int i = 0; i < ( K.e < .99995 ? 3 : 1 ); ++i )
    {    
		float shape = 0.;
        float k = float(i) * TAU;
        vec2 d = ( K.e < .99995 ? ( mod( w2vec2( aa ), TAU ) + k ) : w2vec2( aa ) ) * dphidM;
    	vec2 u = mod( w2vec2( ll ) - plng.w - d + PI, TAU ) - PI;        
        vec2 s = aaa_interval2( KK, u, KK ) * aaa_stipple2( JJ, w2vec2( aa ), vec2( stipple ), vec2(.5) ) * 
            aaa_step2( JJ, revlimit - d ) * ( K.e < 1. ? vec2(1.) : aaa_step2( KK, w2vec2( aa ) ) );
        col += mask * hmax(s) * colors[ min( i, 3 ) ];
    }
    
#undef w2vec2
}

// Function 4231
vec2 Scene_SDF(vec3 point, inout RayHit hit)
{
    float sdf = FarClip;
    
    float heightmap = Heightmap(vec3(point.xz, 0.0));
    float heightMod = TimeLerp(1.0, MaxHeight, TIME_3DLookUp, TIME_3DExtrude);
    
    if(SteepnessRatio(hit.steepness) > (1.0 - Epsilon) && (point.y > Shoreline + 0.55))
    {
        // 'Tree' generation is done here. Just applies a displacement to the heightmap
        // value if the steepness is gentle enough and we are above the shoreline.
        sdf = (point.y - (heightmap * heightMod + treeNoise(point.xz) * 1.75 * TimeLerp(0.0, 1.0, TIME_Water, TIME_Trees)));
    }
    else
    {
    	sdf = (point.y - heightmap * heightMod);
    }
                          
    return vec2(sdf, heightmap);
}

// Function 4232
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    const vec2 e = vec2(6.201, 0);
    float ref = bumpSurf3D(p, nor);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),
                      bumpSurf3D(p - e.yxy, nor),
                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     
          
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 4233
float dist(vec3 p)
{
    float t = iTime*.5;
    float a = min(fract(t)/.9,1.);
    //Quintic interpolion
    a *= a*a*(a*(a*6.-15.)+10.) * 1.57;
    
    //Rotation
    mat2 r = mat2(cos(a),sin(a),-sin(a),cos(a));
    vec3 m = p;
    //Swap axis of rotation
    mod(t,2.)>1.? m.xz*=r : m.zy*=r;
    return max(length(m.xy),max(length(m.yz),length(m.zx)))-.5;
}

// Function 4234
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){
   
    const vec2 e = vec2(0.001, 0);
    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);
                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
	
}

// Function 4235
vec2 scene(vec3 position)
{
    vec3 translate = vec3(0.0, 0.5, 1.0);
    
    vec2 res = map(position);
    
    float distance = res.x;
    float materialID = res.y;
    
    return vec2(distance, materialID);
}

// Function 4236
float mapScene(in vec3 p) {
    p.yz *= mat2(0.965925826289068, 0.258819045102521, -0.258819045102521, 0.965925826289068);

    float r = (iMouse.x / iResolution.x - 0.5) * 3.1415926535;
    float c = cos(r), s = sin(r);
    p.xz *= mat2(c, -s, s, c);

    float printObj = sdPrintObject(p);

    float time = max(0.0, iTime - 1.0);
    float animTime = time;
    if (time > 10.0) animTime = time * 10.0 - 100.0;
    if (time > 20.0) animTime = time * 100.0 - 2000.0;
    if (time > 30.0) animTime = time * 1000.0 - 30000.0;

    p += 1.35;
    vec3 pos = floor(mod(animTime / vec3(1.0, 18225.0, 135.0), 2.7) / 0.02) * 0.02;
    if (animTime > 49207.5) pos = vec3(2.7);

    float stack = p.y - pos.y;
    float layer = max(stack - 0.02, p.z - pos.z);
    float row = max(max(stack - 0.02, p.z - pos.z - 0.02), p.x - pos.x);

    vec3 bp = p;
    bp.xz -= 1.35;
    float base = sdBox(vec3(bp.x, bp.y + 0.5, bp.z), vec3(3.25, 0.25, 3.25)) - 0.1;

    vec3 lp = bp;
    lp.xz = abs(lp.xz) - 2.5;
    lp.y -= 2.25;
    float lifts = sdThreadedCylinder(lp, 2.5, 0.1, 15.0, pos.y * 10.0, 0.05);

    vec3 rp = vec3(lp.x, bp.y - pos.y - 2.0, bp.z);
    float risers = sdBox(lp - vec3(0.0, pos.y - 0.25, 0.0), vec3(0.4)) - 0.1;
    risers = min(risers, sdThreadedCylinder(rp.xzy, 2.5, 0.1, 15.0, pos.z * 10.0, 0.05));

    vec3 sp = vec3(rp.x, rp.y, rp.z + 1.35 - pos.z);
    float sliders = sdBox(sp, vec3(0.4)) - 0.1;
    sliders = min(sliders, sdThreadedCylinder(vec3(sp.y, bp.x, sp.z), 2.5, 0.1, 15.0, pos.x * 10.0, 0.05));

    vec3 hp = p - pos;
    hp.y = 1.0 - hp.y;
    float head = sdPyramid(hp, 1.0) - 0.05;
    hp.y += 0.65;
    head = min(head, sdBox(hp, vec3(0.45, 0.65, 0.45)) - 0.1);

    float printer = min(base, min(min(lifts, min(risers, sliders)), head));

    return min(printer, max(printObj, min(stack, min(layer, row))));
}

// Function 4237
vec4 SceneCol (vec3 ro)
{
  vec4 objCol, carCol, carCol2;
  float a, r, h;
  r = length (ro.xz);
  a = (r > 0.) ? atan (ro.z, - ro.x) / (2. * pi) : 0.;
  if (idObj == idEng || idObj == idCar || idObj == idFun) {
    h = Hashff (5. * idCyc + 17.1);
    carCol = vec4 (HsvToRgb (vec3 (mod (h, 1.), 0.8, 0.9)), 0.2);
    carCol2 = vec4 (HsvToRgb (vec3 (mod (h + 0.5, 1.), 0.8, 0.9)), 0.3);
    if (idObj == idEng) {
      objCol = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.35) ? carCol2 : carCol;
      if (qHit.y < -1.15) objCol *= 0.5;
      if (abs (abs (qHit.x) - 0.5) < 0.4 && abs (qHit.y - 1.1) < 0.2) objCol *= 0.7;
      else if (abs (abs (qHit.z - 1.) - 1.5) < 0.1 && qHit.y > -1.1) objCol *= 0.7;
      if (qHit.z > 3.1 && qHit.y < -1.) objCol = carCol;
      if (qHit.z < - 2.8 && qHit.y > 0.1) objCol = vec4 (vec3 (0.01), 0.);
    } else if (idObj == idCar) {
      objCol = (abs (qHit.y + 0.2) < 0.05 || qHit.y > 1.4) ? carCol2 : carCol;
      if (qHit.y < -1.15) objCol *= 0.5;
      if (abs (qHit.y - 0.6) < 0.6 && (abs (qHit.x) < 0.5 || abs (abs (qHit.z) - 1.2) < 1.1))
         objCol *= 0.7;
    } else if (idObj == idFun) {
      objCol = (qHit.y > 1.35) ? carCol : carCol2;
    }
  } else if (idObj == idTun) {
    if (tunWl == 0.) {
      if (abs (r - trkRad) < 0.2 * trkWid && abs (mod (32. * a, 1.) - 0.125) < 0.04)
         objCol = vec4 (0.8, 0.8, 0.4, -1.);
      else if (length (vec2 (abs (ro.y - tunUp + 0.5 * tunRad),
         2. * (mod (16. * a + 0.5, 1.) - 0.5))) < 0.02) objCol = vec4 (0., 0.3, 0., -1.);
      else objCol = vec4 (0.2, 0.2, 0.22, 0.) * (0.7 + 0.3 * SmoothBump (0.02, 0.98, 0.005,
         mod (128. * a, 1.)));
    } else {
      if (max (abs (r - trkRad), abs (ro.y - tunUp - tunRad)) < 0.1 * trkWid)
         objCol = (trDir * ro.x > 0.) ? vec4 (0., 1., 0., -1.) : vec4 (1., 0., 0., -1.);
      else objCol = mix (vec4 (0.4, 0.4, 0.44, 0.1), vec4 (0.8, 0.8, 0.85, 0.1),
         step (2.05, ro.z - 0.3 * ro.y) * smoothstep (0., 0.1, ro.y - tunUp -
         0.3 * tunRad * Fbm1 (8. * ro.z)));
    }
  } else if (idObj == idVia) {
    objCol = vec4 (0.7, 0.6, 0.4, 0.1);
    if (ro.y > -0.03) objCol.rgb *= 1. - 0.2 * smoothstep (0.4, 0.6, Fbm2 (128. * vec2 (a, r)));
  } else if (idObj == idTie) objCol = vec4 (0.4, 0.4, 0.45, 0.1);
  else if (idObj == idRail) objCol = vec4 (0.7, 0.7, 0.75, 0.5);
  else if (idObj == idRbase) objCol = vec4 (0.5, 0.4, 0.3, 0.) *
     (1. - 0.07 * floor (8. * Noisefv2 (64. * ro.xz)));
  else if (idObj == idSlp) objCol = vec4 (0.5, 0.3, 0.1, 0.) * (1. -
     0.7 * step (abs (abs (r - trkRad) - trkWid), 2.5 * rlWid) *
     step (abs (mod (256. * a + 0.5, 1.) - 0.5), 0.03));
  else if (idObj == idAxle) objCol = vec4 (0.4, 0.4, 0.5, 0.3);
  else if (idObj == idWheel) objCol = vec4 (0.5, 0.5, 0.6, 0.3);
  else if (idObj == idCrod) objCol = vec4 (0.7, 0.7, 0.1, 0.3);
  else if (idObj == idLamp) objCol = (mod (tCur, 2.) < 1.) ? vec4 (1., 1., 0.7, -1.) :
     vec4 (0.8, 0.8, 0.4, -1.);
  return objCol;
}

// Function 4238
float steelSDF (vec3 p) {
    // return length(p-vec3(0., 0., 5.))-2.;
    // return p.y+(gnoise(p.x/7., p.z/7.)-.5)*1.;
    return p.y+sin(p.x);
    float SDFp = 1e6;
    float fx = floor(p.x);
    float fz = floor(p.z);
    vec2 q;
    SDFp = min(SDFp, p.y+h(fx, fz));
    for (float x=-1.; x<=1.; ++x) {
        if (x == 0.) {
            continue;
        }
        if (p.y+h(fx+x, fz) < 0.) {
        	SDFp = min(SDFp, min(fract(p.x), 1.-fract(p.x) ));
        }
    }
    for (float z=-1.; z<=1.; ++z) {
        if (z == 0.) {
            continue;
        }
        if (p.y+h(fx, fz+z) < 0.) {
        	SDFp = min(SDFp, min(fract(p.z), 1.-fract(p.z) ));
        }
    }
    SDFp = p.y+h(p.x, p.z);
    return SDFp;
}

// Function 4239
float map(vec3 p){
    
    float n = (.5-cellTile(p))*1.5;
    return p.y + dot(sin(p/2. + cos(p.yzx/2. + 3.14159/2.)), vec3(.5)) + n;
 
}

// Function 4240
Result resultSDF(vec3 p)
{
    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), TOO_FAR, TOO_FAR, 0.0, g_magen);
    SDFResult res2 = SDFResult(TOO_FAR, MAGEN);
    res2 = sceneSDF(p);
#ifdef SLOW_NORMALS    
    result.normal.x = sceneSDF(p + vec3(EPSILON, 0.0, 0.0)).dist - res2.dist;
    result.normal.y = sceneSDF(p + vec3(0.0, EPSILON, 0.0)).dist - res2.dist;
    result.normal.z = sceneSDF(p + vec3(0.0, 0.0, EPSILON)).dist - res2.dist;
#else
    result.normal = vec3(0.0);
    for( int i=min(iFrame,0); i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);
        result.normal += e*sceneSDF(p+EPSILON*e).dist;
    }
#endif  
    result.normal = normalize(result.normal);        
    
    SDFResult res = SDFResult(TOO_FAR, MAGEN);    
    res = sceneSDF(p);
            
    result.mat=g_mats[res.matindex];
        
    result.pos = p;
    result.t = res2.dist;
    return result;
}

// Function 4241
SDFResult vertcapSDF2( VertCap cap, vec3 axis, vec3 p )
{
    p -= cap.pos;
    float y = dot(axis, p);
    p -= axis*clamp( y, 0.0, cap.height);
    return SDFResult(length( p ) - cap.radius, cap.matindex);
}

// Function 4242
float marchScene(in vec3 rO, in vec3 rD, vec2 co)
{
	float t = 5.+10.*hash12(co);
    float oldT = 0.;
	vec2 dist = vec2(1000);
	vec3 p;
    bool hit = false;
    
    #ifdef MOVIE

    for( int j=0; j < 1000; j++ )
    #else
    for( int j=0; j < 200; j++ )
    #endif
	{
		if (t >= FAR) break;
		p = rO + t*rD;

		float h = map(p, t*0.002);
 		if(h < 0.01)
		{
            dist = vec2(oldT, t);
            break;
	     }
        oldT = t;
        #ifdef MOVIE
        t += h * .2;
        #else
        t += h * .35 + t*.001;
        #endif
	}
    if (t < FAR) 
    {
       t = BinarySubdivision(rO, rD, dist);
    }
    return t;
}

// Function 4243
float rounded_cylinder_sdf( vec3 p, float ra, float rb, float h )
{
  vec2 d = vec2( length(p.xz)- 2.0*ra+rb, abs(p.y) - h );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;
}

// Function 4244
float sceneT(vec3 p)
{
	vec3 pr = p;
    pr.xy *= rot(iTime*.8);    //vec3 pr = 
    pr.yz *= rot(iTime*.7);    //vec3 pr = 
    float d4 = sdTorus(pr,vec2(.125,.03125));
    return d4;
}

// Function 4245
float map(vec2 p){
	// Reading distance fields from a texture means taking scaling into
    // consideration. If you zoom coordinates by a scalar (4, in this case), 
    // you need to scale the return distance value accordingly... Why does 
    // everything have to be so difficult? :D
    const float sc = 4.;
    vec4 tex = tx(iChannel0, p/sc);
    gIP = tex.yz; // The object ID is stored in the YZ channels..
    return tex.x*sc;
}

// Function 4246
void sceneSquareTunnel(vec2 uv, out vec3 params)
{
	if (iBeat >= 48.){
		uv = abs(uv);
		uv=vec2(max(uv.x,uv.y),min(uv.x,uv.y));
	}
	
	uv = rotate(uv,iBeat*.125);
	params.x = fract(1./mlength(uv*2.)+iBeat);
	params.yz = iBeat < 48. ? vec2(29,31) : rangeBooks;
	if(mlength(uv)<.2)
		params.yz = rangeBlack;
}

// Function 4247
float SDFfloor (vec3 p) {
    return p.y+sin(p.x*20.+sin(p.z*10.))*.02*0.;
}

// Function 4248
vec3 tonemap(vec3 x) 
{
    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;
    return (x*(a*x+b))/(x*(c*x+d)+e);
}

// Function 4249
vec2 map(vec3 p)
{
    vec3 q = mod(p+0.5*2.,2.)-2.*.5;
    vec2 pl = vec2(.7+p.y,0.);
    
    vec2 sphere = vec2(length(q) - .3,1.);
    
    vec2 box = vec2(sdOctahedron(q,.25),1.);
    
    vec2 morph = vec2(mix(sphere.x,box.x,sin(iTime)),1);

//    sdf = min(sdf,sphere);
	return (morph.x < pl.x) ? morph : pl;

}

// Function 4250
float scenedist(vec3 p){ // this defines what is actually in the scene
	float s1 = length(p)-1.; 				// this is just a sphere
	float s2 = length(p-vec3(1.,0.,0.))-0.3;// this is a smaller sphere, shifted x-wards
	return min(s1,s2); // add them together (like boolean OR)
	// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)
}

// Function 4251
float DistanceField( vec3 pos )
{
	//pos = abs(pos);
	//return max( pos.x, max( pos.y, pos.z ) )-1.0;
	
	return (length(pos-vec3(0,-1,0))-2.0 + sin(sqrt(pow(atan(length(pos.xz),pos.y),2.0)+1.0)*20.0-iTime)/20.0)*.707;
	
	//return (pos.y + sin(pos.x*1.0)*sin(pos.z*1.0)/1.0)*.7;
}

// Function 4252
float map( in vec3 pos )
{
    pos.y += 0.4;
    pos.xy = (mat2(4,3,-3,4)/5.0)*pos.xy;
    
    return sdSolidAngle(pos, vec2(3,4)/5.0, 0.7 );
}

// Function 4253
vec2 UVMapping( vec2 target )
{
	// need to march vertically to absorb vertical creases, and horizontally for horizontal ones
	// cheat, by seperating these two
	vec2 uv = vec2(0);
	
	const int n = 16;
	const float fudge = 1.0; // use values > 1 to allow for extra ripples we're not measuring
	vec2 d = target/float(n);
	vec2 l;
	l.x = RippleHeight( vec2(0,target.y) );
	l.y = RippleHeight( vec2(target.x,0) );
	for ( int i=0; i < n; i++ )
	{
		vec2 s;
		s.x = RippleHeight( vec2(d.x*float(i),target.y) );
		s.y = RippleHeight( vec2(target.x,d.y*float(i)) );
		//uv.x += sign(d.x)*sqrt(pow(fudge*,2.0)+d.x*d.x);
		//uv.y += sign(d.y)*sqrt(pow(fudge*,2.0)+d.y*d.y);
		uv += sign(d)*sqrt(pow(fudge*(s-l),vec2(2.0))+d*d);
		l = s;
	}
	
	return (uv+vec2(0,1))/vec2(3.0,2.0);
}

// Function 4254
vec3 tonemapping(vec3 color)
{ // by Zavie (lslGzl)
	color = max(vec3(0.), color-vec3(0.004));
	color = (color * (6.2*color+.5))/(color*(6.2*color+1.7)+0.06);
	return color;
}

// Function 4255
float CylinderSDF(vec3 p,float radius)
{
    
    float d = length(p.xz)-radius;
    d = max(d, p.y - 1.0);
    d = max(d,-p.y - 1.0);
    return d;
}

// Function 4256
float nremap (float value, float from1, float to1, float from2, float to2) {
	return ((value - from1) / (to1 - from1) * (to2 - from2) + from2);
}

// Function 4257
float scene(vec3 p)
{
  float b = sphere(p, 1.6);
  if(b > 0.001) return b; // optimisation

  vec3 disp = vec3(0);
  float f = 0.5;
  disp.x = texture(iChannel0, p.zy * 0.05 + iTime * 0.02).x * f;
  disp.z = texture(iChannel0, p.xy * 0.05 + iTime * 0.03).z * f;
  disp.y = texture(iChannel0, p.xz * 0.05 + iTime * 0.04).y * f;

  return sphere(p + disp, 1.0 + sin(iTime*2.4) * 0.15);
}

// Function 4258
float csDist( in vec3 p )
{
    float r = baseTunnel(p);
    return min(r,cauldrons(p));
}

// Function 4259
float lineDist(vec3 p, vec3 a, vec3 b)
{
    vec3 pa = p-a;
    vec3 ba = b-a;
    float t = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);
    return length(pa-ba*t);
}

// Function 4260
vec4 DistCombineUnionTransparent( const in vec4 v1, const in vec4 v2, const in float fTransparentScale )
{    
	//if( fCondition < 0.0 )
	//            return v1;
	
	// Negate the distance to the transparency object if transparent scale is 0.0     
	// This allows us to ratrace "out" of transparency
	
	vec4 vScaled = vec4(v2.x * (fTransparentScale * 2.0 - 1.0), v2.yzw);
                
	// The condition allows us to ignore transparency for secondary rays
    return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, fTransparentScale));
}

// Function 4261
vec4 sphere_sdf(vec3 query_point, float sphere_radius) {
    float l = length(query_point);
    float df = l - sphere_radius;
    
    return vec4(
        query_point / l,
        df
    );
}

// Function 4262
vec2 SdScene(in vec3 p, inout vec3 mtl)
{
    float uniformRandom = UniformHashFromPos(p);
    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    
    float smin1 = SdSmoothMin(
                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),
                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2),
        					 SPHERE0_RGB, SPHERE1_RGB, mtl
				  );
    float smin2 = SdSmoothMin(smin1, SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19),
                              mtl, SPHERE2_RGB, mtl);
    return SdUnion(vec2(SdPlane(p), 1.0), vec2(smin2, 2.0));
}

// Function 4263
SceneResult Scene_GetDistance( vec3 vPos )
{
    SceneResult result;

    float fFloorDist = vPos.y;
        
    result.fDist = fFloorDist; 
    result.vUVW = vPos;
	result.iObjectId = MAT_FLOOR;
    
    // Screen
    
    float fScreenDist = -vPos.z;

    SceneResult resultScreen;
    resultScreen.fDist = fScreenDist; 
    resultScreen.vUVW = vPos;
	resultScreen.iObjectId = MAT_DEFAULT;
    
    result = Scene_Union( result, resultScreen );
    
    float fViewScreenPos = -5.0;
    
#if DRAW_PARTITION    
    // Partition
    
    float fPartitionDist = abs( vPos.x ) - 0.005;
    fPartitionDist = max( fPartitionDist, vPos.y - 2.0 );
    fPartitionDist = max( fPartitionDist, fViewScreenPos - vPos.z);

    SceneResult resultPartition;
    resultPartition.fDist = fPartitionDist; 
    resultPartition.vUVW = vPos.zyx;
	resultPartition.iObjectId = MAT_PARTITION;
    
    result = Scene_Union( result, resultPartition );
#endif    
    
    
#if DRAW_VIEW_SCREEN    
    // View Screen

    
    float fViewScreenDist = abs( vPos.z - fViewScreenPos ) - 0.005;
    float fScreenHeight = 0.8;
#if BLOCKING_SCREEN     
	fScreenHeight = 2.0;    
#endif    
    
    fViewScreenDist = max( fViewScreenDist, vPos.y - fScreenHeight );
    fViewScreenDist = max( fViewScreenDist, abs( vPos.x )  - 1.0 );
    
    vec2 vHolePos = vec2(0.05, 0.75);
    float fHoleRadius = 0.02;
    vec2 vHoleDomain = vPos.xy;
    vHoleDomain.x = abs( vHoleDomain.x );
    vHoleDomain -= vHolePos;
    float fHoleDist = length( vHoleDomain ) - fHoleRadius;

    fViewScreenDist = max( fViewScreenDist, -fHoleDist );
    
    SceneResult resultViewScreen;
    resultViewScreen.fDist = fViewScreenDist; 
    resultViewScreen.vUVW = vPos;
	resultViewScreen.iObjectId = MAT_PARTITION;
    
    result = Scene_Union( result, resultViewScreen );
#endif    
    
    int iClosestLamp = 0;
    
    float fClosestDist = 1000.0;

    vec3 vLampPos;
    vec3 vLampTarget;
    vec3 vLampCol;
    vec3 vLampCaseCol;
    for ( int lightIndex=0; lightIndex< iLampCount; lightIndex++ )
    {
		GetLampInfo( lightIndex, vLampPos, vLampTarget, vLampCol, vLampCaseCol );
        
        float fDist = length( vLampPos.xz - vPos.xz );
        if ( fDist < fClosestDist )
        {
            fClosestDist = fDist;
            iClosestLamp = lightIndex;
        }
    }
    
    if ( iLampCount > 0 )
    {
		GetLampInfo( iClosestLamp, vLampPos, vLampTarget, vLampCol, vLampCaseCol );
        
        
        vec3 vLampFd = normalize( vLampTarget - vLampPos );
        vec3 vLampRt = normalize( cross( vLampFd, vec3(0,1,0) ) );
        vec3 vLampUp = cross( vLampFd, vLampRt );
        
        vec3 vLampWorldOffset = vPos - vLampPos;
        
        vec3 vLampDomain;
        vLampDomain.x = dot( vLampRt, vLampWorldOffset );
        vLampDomain.y = dot( vLampUp, vLampWorldOffset );
        vLampDomain.z = dot( vLampFd, vLampWorldOffset );
        
        if ( iClosestLamp == 0 )
        {
            vLampCaseCol = vec3(0.5);
        }
        
    	SceneResult resultLamp = Scene_GetLampResult( vLampDomain, vLampCaseCol );        
	    result = Scene_Union( result, resultLamp );
        
        {
            vec3 vOffset = vLampTarget - vLampPos;
            vOffset.y = 0.0;
            
            vec3 vStandFd = normalize( vOffset );
            vec3 vStandRt = normalize( cross( vStandFd, vec3(0,1,0) ) );
            vec3 vStandUp = cross( vStandFd, vStandRt );
            
            vec3 vStandDomain;
            vStandDomain.x = dot( vStandRt, vLampWorldOffset );
            vStandDomain.y = dot( vStandUp, vLampWorldOffset );
            vStandDomain.z = dot( vStandFd, vLampWorldOffset );
            
            SceneResult resultLampStand;
            
            vec3 vForkProngDomain = vec3( vStandDomain );
            vForkProngDomain.x = abs( vForkProngDomain.x );
            vForkProngDomain.x -= 0.13;

            float fForkProngDist = length( vForkProngDomain.xz ) - 0.01;            
            fForkProngDist = max( fForkProngDist, -vStandDomain.y - 0.02);
            fForkProngDist = max( fForkProngDist, vStandDomain.y - 0.25);
            
            vec3 vCrossbarDomain = vStandDomain;
            vCrossbarDomain.y -= 0.25;
            
            
            float fCrossbarDist = length( vCrossbarDomain.yz ) - 0.01;
            
            fCrossbarDist = max( fCrossbarDist, abs( vCrossbarDomain.x ) - 0.13 );
            
            float fStandDist = min( fForkProngDist, fCrossbarDist );
            
            float fStandPoleDist = length( vCrossbarDomain.xz ) - 0.02;
            fStandPoleDist = max( fStandPoleDist, -vCrossbarDomain.y );
            fStandDist = min( fStandDist, fStandPoleDist );
            
            float fStandBaseDist = length( vCrossbarDomain.xz ) - 0.15;
            fStandBaseDist = max( fStandBaseDist, vPos.y - 0.01 );
            
            fStandDist = min( fStandDist, fStandBaseDist );
            

            resultLampStand.fDist = fStandDist; 
            resultLampStand.vUVW = vPos;
            resultLampStand.iObjectId = MAT_LAMP;
            
	    	result = Scene_Union( result, resultLampStand );	            
        }
    }
    
    // controls
    
#if DRAW_DIALS    
    {
        vec3 vDialPosWorldOffset = vPos - vec3(0, 0.7, -5.01 );

        vec3 vDialUp = normalize( vec3(0,0.5,-1) );
        vec3 vDialFd = cross(  vec3(1,0,0) , vDialUp );
        
        vec3 vDialPanelDomain;
        vDialPanelDomain.x = vDialPosWorldOffset.x;
        vDialPanelDomain.y = dot( vDialPosWorldOffset, vDialUp );
        vDialPanelDomain.z = dot( vDialPosWorldOffset, vDialFd );

        
        vec3 vPanelSize = vec3(0.2,0.01, 0.1);
                    
        vDialPanelDomain.y += vPanelSize.y;
        vDialPanelDomain.z += vPanelSize.z;
        
		SceneResult resultDialPanel;
        resultDialPanel.fDist = sdBox(vDialPanelDomain, vPanelSize ); 
        resultDialPanel.vUVW = vDialPanelDomain;
        resultDialPanel.iObjectId = MAT_PANEL;

        result = Scene_Union( result, resultDialPanel );
        
        
        vec3 vDialPos = vDialPanelDomain - vec3(0,0.011, 0);
        
        SceneResult resultDial;
        
        vec3 vDialCol = gLampCaseColor[2];
        
        float fDialPos = GetDialG();
        
        float fDialSpacing = 0.125;
        float fDialSize = 0.04;
        
        if ( vDialPos.x < -fDialSpacing * 0.5 )
        {
            vDialPos.x += fDialSpacing;
            fDialPos = GetDialR();
            vDialCol = gLampCaseColor[1];
        }
        if ( vDialPos.x > fDialSpacing * 0.5 )
        {
            vDialPos.x -= fDialSpacing;
            fDialPos = GetDialB();
            vDialCol = gLampCaseColor[3];
        }
        
        
        vDialPos /= fDialSize;
        
        float fRot = mix( 0.0, -PI, fDialPos * 0.5 + 0.5);
        
        float s = sin( fRot );
        float c = cos( fRot );
        
        vDialPos.xz = vec2( vDialPos.x * s + vDialPos.z * -c, vDialPos.x * c + vDialPos.z * s );
        
        float t = atan( vDialPos.x, vDialPos.z );
        
        float fDialDist = length(vDialPos.xz);
        
        float fDialDist1 = fDialDist - 0.5 + vDialPos.y * 0.1 + sin(t * 40.0) * 0.02;
        fDialDist1 = max( fDialDist1, vDialPos.y - 1.0);
        fDialDist1 = max( fDialDist1, -vDialPos.y );

        float fDialDist2 = fDialDist - 1.0 + sin(t * 20.0) * 0.02;
        fDialDist2 = max( fDialDist2, vDialPos.y - 0.2);
        fDialDist2 = max( fDialDist2, -vDialPos.y );
        
        float fDialDist3 = length( vDialPos.xy - vec2(0,0.2)) - 0.05;
        fDialDist3 = max( fDialDist3, vDialPos.z );
        fDialDist3 = max( fDialDist3, -vDialPos.z - 1.05) ;
        
        resultDial.fDist =   min( fDialDist1, fDialDist2 );
                
        resultDial.vUVW = vDialCol;
        
        resultDial.iObjectId = MAT_DIAL_CHROME; 
        if ( fDialDist3 <= resultDial.fDist )
        {
        	resultDial.iObjectId = MAT_DIAL;  
            resultDial.fDist = fDialDist3;
        }
        
        if ( vDialPos.y > 0.95 )
        {
        	resultDial.iObjectId = MAT_DIAL;    
        }
	    
        resultDial.fDist *= fDialSize;
        
        result = Scene_Union( result, resultDial );	            
                
    }
#endif     
    
    return result;
}

// Function 4264
float heightMapWaterDetailed(vec3 p, float t)
{
    float h = 0.0;
    vec3 op = p;
    #ifdef FLOOD
    float w = (-p.z+sin(TIME*WAVES_SPEED))*FLOOD_AMP;
    #endif
    float a = WATER_AMP;
    float f = WATER_FREQ;
    float T = TIME(t)*WATER_SPEED;
    float R = hash1D(t);
    mat2 M = mat2(cos(R), -sin(R), sin(R), cos(R));
    vec2 W = vec2(T, T);
    //h = a*(-1.0+fbm2Dsimple(p.xz*f+T)+fbm2Dsimple(p.xz*f-T));
    for(int i = 0;i < 4; ++i)
    {
//     e((2ikn)/N   )
        float ffta = 1.0;//exp((-2.0*3.14*float(i))/7.0);
        h += a*abs(sin(fbm2Dsimple(f*p.xz+W)-0.5)*3.14);
        a*= 0.8;
        f *= 1.2;
        W = mat2(0.2, -0.8, 0.8, 0.2)*W;
    }
    //for(int i=0;i<5;++i) {
    //}
    #ifdef WAVES
    h+= wave(op,
             mix(0.05, 0.9, min(1.0, max(0.0,p.z)/3.2)),
             T*5.0)
        *gaussianNoise(op.xz*0.1+T)*(0.8/p.y);
    #endif
    #ifdef FLOOD
    return h+w;
    #else
    return h;
    #endif   
}

// Function 4265
float map( vec2 p ) 
{
	float f = texture( iChannel0, p/iChannelResolution[0].xy, -100.0 ).x;
	
	f *= sqrt( texture( iChannel2, (0.03*p + 2.0*gAnimTime)/256.0 ).x );
	return 22.0*f;
}

// Function 4266
float remap(float l,float h,float x){return sat((x-l)/(h-l));}

// Function 4267
float shadow_sdf(vec3 pose, bool inside)
{
    
    vec3 pos = pose;
    vec3 rot = pos;
    
    rot.xy -= vec2(0.36,-0.4);

    rot.xy = n_rotate(rot.xy,0.245);

    rot.xy += vec2(0.36,-0.4);
    
    float door_box = box(rot    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67));
    
    if(door_box < 0.001)
        pos = rot;
        
        
    
    //use symetries:
        
        //mirror at axes
        vec3 pos_x  = vec3(abs(pos.x),abs(pos.y),pos.z);
        
        //mirror at diagonals
        vec3 pos_xx = pos_x.x < pos_x.y  ?  pos_x.xyz  :  pos_x.yxz;
        
    
    
    
     float d = 1000.;
    
    
    if(pos.z > 1.55)
    {
        float roof = box(pos    -vec3( 0.00, 0.00,1.74),  vec3(0.40,0.40,0.06));//roof2
        roof = max(roof, pln(pos_xx -vec3( 0.00, 0.00,1.80),  vec3(0.00,0.148,0.989)));//roof2 slope
        d = min(d,roof);
        
        d = min(d, box(pos    -vec3( 0.00, 0.00,1.79),  vec3(0.09,0.09,0.03)));//light base
        float tar_rad = length(pos.xy);
        d = min(d, max(tar_rad - 0.05, abs(pos.z - 1.84) - 0.05));//light pole
        d = min(d, max(tar_rad - 0.06, abs(pos.z - 1.91) - 0.05));//light
        d = min(d, max(dot(vec2(0.447,0.894),vec2(tar_rad,pos.z-2.)),1.96-pos.z));//light roof
    }
    else
    {
        if(door_box > 0.001)
            d = min(d,door_box+0.001);
    
        if(pos.z > 0.73)
        {
            d = min(d, box(pos_xx -vec3(0.20,.425,1.30),  vec3(0.15,0.01,.005)));//window bar
            d = min(d, box(vec3(abs(pos_xx.x-.19),pos_xx.yz)-vec3(0.045,0.425,1.30),  vec3(.005,0.01,0.15)));//window vertical bar
            
            
            d = min(d, box(pos_xx -vec3(0.20,0.425,1.30),  vec3(0.15,.005,0.15)) + 0.001+ 0.001*sin(pos_xx.x*400.));//window
            
            if(pos.y < -0.4)
            {
                d = min(d, tor((max(vec3(0.0),abs(pos    + vec3( 0.30, 0.44,-0.98))+vec3(-0.003,0,-0.02))).yxz,  vec2(0.01,0.002)));//phone handle
                
                d = min(d, box(vec3(abs(pos.x+.19)-0.11,pos.yz)    -vec3(0.,-0.435,0.97),  vec3(0.01,0.005,0.13)));//phone sign border vertical
                d = min(d, box(vec3(pos.xy,abs(pos.z-.97)-0.12)    -vec3(-0.19,-0.435,0.00),  vec3(0.10,0.005,0.01)));//phone sign border horizontal
                
                d = min(d, cheap_cyl((rot    + vec3(-0.04,.441,-0.98)).xzy,.017,0.005));//lock
            }
            
            
        }
        else
        {
            float base = box(pos    -vec3( 0.00,0.00,0.06),  vec3(0.50,0.50,0.06));//base
            base = max(base, pln(pos_xx -vec3( 0.00,0.47,0.12),  vec3(0.00,0.514,0.857)));//base chamfer (slope)
            d = min(d,base);
        }
        
        d = min(d, box(vec3(pos_xx.xy,(pos_xx.z-0.15) - round((pos_xx.z-0.15)*3.05)/3.05) -vec3(0.19,0.425,0.0),  vec3(0.13,0.02,0.03)));//horizontal bars
        
        
        d = min(d, box(pos_xx -vec3(0.20,.425,0.65),  vec3(0.15,0.01,0.50)));//panels
        
        d = min(d, box(vec3(abs(pos_xx.x-0.19)+0.19,pos_xx.yz) -vec3(0.35,.425,0.82),  vec3(0.03,0.02,0.70)));//door vertical bar
        
        d = min(d, box(pos_xx -vec3(0.00,0.44,0.82),  vec3(0.02,0.01,0.70)));//center vertical bar
        
        d = min(d, box(pos_xx -vec3(.365,0.45,0.82 ),  vec3(.005,.005,0.70)));//border vertical bar
        d = min(d, box(pos_xx -vec3(0.00,0.45,1.485),  vec3(0.36,.005,.005)));//border horizontal bar
    }
    
    d = min(d, box(pos_xx -vec3( 0.00, 0.45, 1.55),  vec3(0.45,.05,0.06)));//sign
    d = max(d,-box(pos_xx -vec3( 0.00, 0.52, 1.55),  vec3(0.325,0.03,.04)));//sign inside
    
    d = min(d, box(pos_x  -vec3( .42, .42, 0.90),  vec3(0.05,0.05,0.78)));//corner pole
    
    d = min(d, box(pos    -vec3( 0.00, 0.00, 1.655),  vec3(0.425,0.425,0.055)));//roof1
    
    if(inside)
        d = max(d,-box(pos    -vec3(0.,0.45,0.81),  vec3(0.36,.2,0.68)));//open back
    
    d = max(d,-box(pose    -vec3(0.18,-0.425,0.82),  vec3(0.18,0.04,0.67)));//open door
    
    if(door_box < 0.001)
         d = max(d,door_box+0.001);
      
    
    
     
    return (d);
}

// Function 4268
float calc_dist_ground(in vec3 point, out int obj_id)
{ 
    obj_id = OBJ_GROUND;
    float ground_height = -0.9 + ground_height(point.xz); 
	return point.y - ground_height;
}

// Function 4269
float map(vec3 p) {
	float d = 1.0E10;
	horizon=0;
	p.z=p.z+camera_pos;

	d =  disp(p,1.0)+sdSphere(p+   vec3(0.0,0.0,sin(T*5.234)),2.0) ;
    for (int x=0; x<BLOBS; x++) {
        float ff=float(x);
        float where=mod(T*1.22+ff*ff,2.0*PI);
        if ((where<PI*0.5 || (where>PI && where<1.5*PI)) ) {
                float d2 = ( 1.0-(0.5+sin(2.0*where+.5*PI)/2.0) )*disp(p,1.0) +sdSphere(p + vec3(0.0,0.0,sin(T*5.234)) +  ( rotateX(ff+T*0.33) * rotateY(ff+T*0.45) * rotateZ(ff+T*0.56) * vec4( 0.0+sin(where)*2.0, 0.0+sin(where)*2.0,  sin(where)*10.0  ,  1.0  )).xyz    ,   1.33*( 1.0-(0.5+sin(2.0*where+1.5*PI)/2.0) ));    d = smin(d,d2,0.3);
        }
    }


    d = min(1.0E10 , d );
    if (d>= 1.0E10) horizon=1;
	return d;

}

// Function 4270
float sceneSdf2(vec3 p)
{
    float plane_dist = planeSdf(p);
    float cone_dist = coneSdf(p);
    return min(plane_dist, cone_dist);
}

// Function 4271
float distCircleNn(vec3 p, vec3 n, float r)
{
    return length(p-normalize(p-n*dot(n,p))*r);
}

// Function 4272
void map_id(out vec4 fragColor) {
    vec4 retc = loadval(ipx);
    if (lll().x >= 0.) {
        fragColor = vec4(0.);
        return;
    }
    if (retc.y < 0.)
        if (iMouse.z > 0.) {
            //copy of main_c in image
            vec2 p = (iMouse.zw) / iResolution.y - res_g / 2.0;
            float bsz = 1. / 25.;
            vec2 bpp = vec2((bsz * 10.) / 2., 0.45);
            if (abs(p.x) <= bpp.x + 0.02) {

            } else {
                float zo = 5.;
                vec2 msize = vec2(msize);
                if (((abs(p.x) >= 0.5 * (msize.x / msize.y) / zo + 2. * (msize.x / msize.y) / zo))&&
                        ((abs(p.x) <= 0.5 * (msize.x / msize.y) / zo + 9. * (msize.x / msize.y) / zo))) {
                    vec2 szt = vec2(7., 5.);
                    bool pl = p.x < 0.;
                    p *= zo;
                    vec2 vt = vec2(float(msize.x) / float(msize.y), 1.);
                    p += vt / 2.;
                    float tv = pl ? (lgs().z) : (lgs().w);
                    p.y += (mod(tv, szt.y));
                    vec2 rt = vec2(1.815, 1.2);
                    int mid = int(floor((p.y + rt.y * zo / 2.) / vt.y - 1.) * szt.x + floor(mod((p.x + rt.x * zo / 2.) / vt.x, 12.) - 1.));
                    mid += int((tv < 0. ? -(5. - tv) : tv) / 5.) * int(szt.y * szt.x);
                    p = mod(p, vt) - vt / 2.;
                    if ((mid >= 0)&&(mid < gaio())) {
                        retc.x = float(mid);
                    }
                }
            }

        }
    retc.y = iMouse.z > 0. ? 1. : -1.;
    retc.z = float(key_control());
    fragColor = retc;
}

// Function 4273
float PlaneDistance(in vec4 plane, in vec3 point)
{
    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);
}

// Function 4274
float MicrofacetDistribution(PBRInfo pbrInputs) {
    float roughnessSq = pbrInputs.AlphaRoughness * pbrInputs.AlphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

// Function 4275
float Scene(vec3 p)
{
    vec3 f;
    //f = fract(p); f -= .5; // center in cell
    ivec3 i = voxid(p);
	f = p - voxpos(i); // relative to closest cell
    int id = ComputeHitId(i);
    return shape(f, id);
}

// Function 4276
float mapNormCurv(vec3 p, out vec3 n, out float c)
{
    Dual dualX = Dual(p.x, mat3x2(1, 0, 0, 0, 0, 0));
    Dual dualY = Dual(p.y, mat3x2(0, 0, 1, 0, 0, 0));
    Dual dualZ = Dual(p.z, mat3x2(0, 0, 0, 0, 1, 0));
    
    Dual d = dAdd(dSub(dLength(dAdd(dualX, dMul(dSin(dAdd(dAdd(dMul(dualY, dConst(4.000000)),
                dConst(time)), dSin(dualZ))), dConst(0.150000))), dualY, dualZ), dConst(1.000000)),
                dMul(dMul(dSin(dAdd(dAdd(dMul(dAdd(dualX, dMul(dSin(dAdd(dAdd(dMul(dualY, dConst(4.000000)),
                dConst(time)), dSin(dualZ))), dConst(0.150000))), dConst(10.000000)), dMul(dConst(time),
                dConst(0.300000))), dSin(dAdd(dAdd(dMul(dualZ, dConst(10.000000)), dMul(dConst(time),
                dConst(0.500000))), dSin(dAdd(dMul(dualY, dConst(10.000000)), dMul(dConst(time),
                dConst(0.700000)))))))), dConst(0.075000)), dAdd(dMul(dSin(dMul(dConst(time),
                dConst(0.420000))), dConst(0.500000)), dConst(0.500000))));
                
    n = normalize(vec3(d.d[0].x, d.d[1].x, d.d[2].x));

    c = d.d[0].y + d.d[1].y + d.d[2].y;
    
    return d.f;
}

// Function 4277
vec2 map2(vec3 pos)
{
    pos = rotateVec2(pos);

    vec2 obj;
    
    float ypos = getCylYPos();
    float ypos2 = cl - 1.2;
    
    float c1a = sdCylinder(pos - vec3(-ce/2., ypos + ypos2, 0.), vec2(cr, cl));
    float c2a = sdCylinder(pos - vec3(ce/2., -ypos + ypos2, 0.), vec2(cr, cl));
    float c1b = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr, 10.));
    float c2b = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr, 10.));
    float c1b2 = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr - 0.005, 10.));
    float c2b2 = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr - 0.01, 10.));
    float c1b3 = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr + 0.005, 10.));
    float c2b3 = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr + 0.005, 10.));
    float c1c = opS(c1a, c2b);
    float c2c = opS(c2a, c1b);
    
    float cca = max(c1b2, c2b2);
    float mposy = max(ypos, -ypos);
    cca = max(cca, pos.y - mposy - cl - ypos2);
    cca = max(cca, -pos.y + mposy - cl - ypos2);
    
    float cbc = sdCylinder(pos.yxz + vec3(-mposy + 0.85, 0., 0.), vec2(0.12, 0.5));
    float bbc = sdBox(pos - vec3(0., mposy - 1.08, 0.), vec3(0.5, 0.22, 0.12)); 
    cca = opS(cca, cbc);
    cca = opS(cca, bbc);
    
    float cb1 = sdCylinder(pos.yxz + vec3(-ypos + 0.85, 0.17, 0.), vec2(0.115, 0.12));
    c1c = min(c1c, cb1);
    
    float cb2 = sdCylinder(pos.yxz + vec3(ypos + 0.85, -0.17, 0.), vec2(0.115, 0.12));
    c2c = min(c2c, cb2);
    
    vec2 c1 = vec2(c1c, C1_OBJ);
    vec2 c2 = vec2(c2c, C2_OBJ);
    vec2 cc = vec2(cca, CC_OBJ);
    
    float boxa = sdBox(pos - vec3(0., boxYPos, 0.), boxSize);
    boxa = opS(boxa, c1b3);
    boxa = opS(boxa, c2b3);
    float boxi = sdBox(pos - vec3(0., boxYPos - 0.65, 0.), boxSize*0.85);
    boxa = opS(boxa, boxi);
    float cbox = sdCylinder(pos.yxz + vec3(1.8, 0., 0.), vec2(0.12, boxSize.x*1.1));
    boxa = opS(boxa, cbox);
    
    vec2 box = vec2(boxa, BOX_OBJ);
    
    vec3 posr = pos;
    posr.y+= 1.8;
    posr.yz = rotateVec(posr.yz, cms*iTime - pi*0.5);
    float wc0 = sdCylinder(posr.yxz + vec3(0., 0.25, 0.), vec2(0.115, boxSize.x*1.2));
    float wc1 = sdCylinder(posr.yxz + vec3(cma, -ce*0.5 - 0.1, 0.), vec2(0.6, 0.2));
    float wc2 = sdCylinder(posr.yxz + vec3(-cma, ce*0.5 + 0.1, 0.), vec2(0.6, 0.2));
    float wc3 = sdCylinder(posr.yxz + vec3(0., boxSize.x*1.25, 0.), vec2(0.65, 0.1));
    float wc4 = sdCylinder(posr.yxz + vec3(0.55, boxSize.x*1.33, 0.), vec2(0.08, 0.2));
    float wheela = min(min(min(min(wc0, wc1), wc2), wc3), wc4);
    vec2 wheel = vec2(wheela, WHEEL_OBJ);
    
    obj = opU(c1, c2);
    obj = opU(obj, cc);
    obj = opU(obj, box);
 
    #ifndef always_cut
    if (cut_obj)
    #endif
       obj.x = max(obj.x, pos.z);

    obj = opU(obj, wheel);
    
    return obj;
}

// Function 4278
vec3 lumaBasedReinhardToneMapping(vec3 color)
{
	float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
	float toneMappedLuma = luma / (1. + luma);
	color *= toneMappedLuma / luma;
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 4279
Shape map(vec3 c){
  Shape taft = Building(c);
  return taft;
}

// Function 4280
float map_structure(vec3 pos)
{
   pos.x = abs(pos.x);
    
   float a = atan(pos.x - e, pos.z); 
   float r1b = r1*(1. - gd*smoothstep(-0.7, 1., sin(a*ng))*smoothstep(1.95*h, 1.8*h, pos.y));
   float c = sdCylinder(pos - vec3(e, h, 0.), vec2(r1b, h*1.0));
   float t = max(-pos.y + h*2., max(-pos.x + e - r2, sdTorus(pos.xzy - vec3(e - r2, 0., h*2.), vec2(r2, r1))));
   c = min(c, t);
   c = min(c, sdCylinder(pos.yxz - vec3(h*2. + r2, e - r2 - l, 0.), vec2(r1, l)));
   float r2b = r2*(1. + sa*sin(pos.x*sf)*smoothstep(e - r2 - l - r2*0.85, e - r2 - l - r2*0.65, pos.x));
   c = smin(c, length(pos - vec3(e - r2 - l - r3, h*2. + r2b, 0.)) - r3, 0.15);
   c = smax(c, -length(pos - vec3(e - r2 - l - r3*f1, h*2. + r2, 0.)) + r3*f2, 0.06);
   c = max(c, -pos.x + e - r2 - l - r3*0.35);
       
   return c;
}

// Function 4281
float map(vec3 p)
{
    vec3 pA = p + vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);
    vec3 pB = p - vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);
    mat2 r0 = rot(iTime);
    mat2 r1 = rot(-iTime);
    pA.xz *= r0;
    pB.xz *= r1;
	float a = box(pA, vec3(1.0, 6.0, 1.0))-0.3;
    float b = length(pB) - 1.2;
    float dist = fOpUnionRound(a,b,0.5);
    if (a < b) 
    {
    	P = pA;
        tr = r0;
    }
    else
    {
    	P = pB;
    	tr = r1;
    }
	return dist;
}

// Function 4282
float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// Function 4283
Hit scene(vec3 p)
{
	float d, d1;
	
	d = far;
	vec4 col = vec4(0.0);
	
	p.xy -= track(p.z);
	vec3 w = p; w.xy += vec2(0.5*sin(p.z)*sin(p.z*0.2), 0.1*cos(p.z));
	vec3 q = vec3(atan(w.x, w.y) * 8.0 / pi2, length(w.xy), w.z);
	vec2 uv = 0.18*q.xz;
	vec4 tex = texture(iChannel0, uv);
	col = 0.15*texture(iChannel1, uv) + 0.1*tex;
	col.a = 0.3;

	vec4 col1 = texture(iChannel1, 0.18*p.yz);
	vec4 col2 = texture(iChannel0, 0.18*p.yx);
	
	
	// tunnel
	d = 1.0-length(w.xy-0.02*tex.rg);
	
	// lights (could be)
	#if 0
	float r = 20.0;
	q.z = mod(q.z, r)-0.5*r;
	d1 = udBox(q-vec3(-2.0, 1.0, 0.0), vec3(0.04, 0.05, 0.1));
	if (d1 < d) { d = d1; col = vec4(0.9, 0.9, 0.9, 1.0); }
	#endif
	
	// floor
	d = smin(d, sdPlane(p-vec3(0.0, -0.6+0.01*tex.r, 0.0), vec4(0.0, 1.0, 0.0, 0.0)), 0.2);

	#ifdef PILLARS
	q = vec3(abs(w.x)-0.93,w.y+0.57, mod(w.z,5.0)-2.5); 
	d1 = min(udBox(q-vec3(0.0, 0.5, 0.0), vec3(0.1, 0.7, 0.04)),
			 udBox(q-vec3(-0.5, 1.2, 0.0), vec3(0.5, 0.06, 0.04)));
	if (d1 < d) { d = d1; col = vec4(0.1*(col1.rgb + col2.rgb)*vec3(1.5, 0.9, 0.9), 0.0); }
	#endif
	
	#ifdef RAILS
		q = vec3(abs(p.x)-0.23,p.y+0.57, mod(p.z,5.0)-2.5); 
		d1 =              udBox(q-vec3(0.0,0.07,0.0),   vec3(0.02,0.01,2.49)); 
		d1 = min(d1, smin(udBox(q-vec3(0.0,0.04,0.0),   vec3(0.01,0.04,2.49)),
						  udBox(q-vec3(0.0,-0.01 ,0.0), vec3(0.04,0.02,2.49)),0.03)); 
		if (d1 < d) { d = d1; col = vec4(0.06, 0.05, 0.063, 1.0); }
		
		q = vec3(p.x, p.y+0.6-col.x*0.08, mod(p.z,1.0)-0.5);
		d1 = sdBox(q, vec3(0.4,0.02,0.1)); 
		if (d1 < d) { d = d1; col = 0.7*col + vec4(0.04, 0.0, 0.0, 0.05); }
		
		q.x = abs(q.x)-0.23;
		q.y -= 0.02;
		d1 = sdBox(q, vec3(0.07,0.01,0.01)); 
		if (d1 < d) { d = d1; col = vec4(.2, .2, .2, 1.0); }
	#endif
	
	#ifdef CART
		float z = (mouse.z > 0.0 ? 0.6 : 4.0)+atime;
		tex = texture(iChannel2, p.xy*1.3);
		vec4 ccol = vec4(0.2*tex.rgb,0.3);
	
		// basket
		d1 = max(min(max(
				smin(
					udBox(p-vec3(0.0,-0.07,z), vec3(0.1,0.1,0.27)), // top
				  	udBox(p-vec3(0.0,-0.24,z), vec3(0.1,0.15,0.3)), // bottom
					0.4),
				-sdBox(p-vec3(0.0, 0.0, z), vec3(0.28, 0.1, 0.4))), // cut top
				 sdBox(p-vec3(0.0, -0.138, z), vec3(0.21, 0.03, 0.4))), // frame
				-sdBox(p-vec3(0.0, 0.0, z), vec3(0.18, 0.25, 0.31))); // cut inner
		if (d1 < d) { d = d1; col = ccol*1.6; }
		
	
		// base plate
		d1 = min(udBox(p-vec3(0.0,-0.4,z),vec3(0.185,0.015,0.41)), 
				 udBox(p-vec3(0.0,-0.43,z), vec3(0.19, 0.03, 0.28))); 
		if (d1 < d) { d = d1; col = ccol; }
	
		// wheels
		tex = texture(iChannel2, p.xz); // moving with z
		q = vec3(abs(p.x)-0.21,p.y+0.44, p.z-z+0.2); 
		vec2 ws = vec2(0.06-sign(q.x)*0.01, 0.02);
	
		d1 = min(sdCappedCylinder(q, ws),
				 sdCappedCylinder(q-vec3(0.0, 0.0, 0.4), ws));
		if (d1 < d) { d = d1; col = vec4(tex.rgb*0.4, 0.7); }
	#endif
	
	return Hit(d, col);
}

// Function 4284
float sdfEqTri(  in vec2 p ) {
    const float k = sqrt(3.0);
    
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0/k;
    
    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;
    
    p.x -= clamp( p.x, -2.0, 0.0 );
    
    return -length(p)*sign(p.y);
}

// Function 4285
vec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )
{
    vec3 vResult = vec3(0.0);

    vec3 d = vec3(1.0, 1.0, 3.0) / vRayDir;
	float t = -d.y;
    if( (t > 0.0) && (t < 20.0))
    {
		vec3 vPos = vRayOrigin + vRayDir * t + vec3(0.5);
		vResult = mix(vec3(1.0), vec3(0.0), Checker(vPos.xz) );
        if(vPos.x > 0.0)
            vResult *= 0.5;
    }
 
    vec3 vLight0Colour = mix(vec3(1.0, 1.0, 0.1), vec3(0.1, 0.05, 0.0),  floor(fract(iTime) * 2.0)) * 10.0;
    
    vResult += GetLight(GetSource0Pos(iTime), vLight0Colour, vRayOrigin, vRayDir);

    vec3 vLight1Colour = vec3(0.2, 0.9, 2.0) * 10.0;
    //vec3 vLight1Colour = mix(vec3(0.2, 0.9, 2.0), vec3(0.0, 0.25, 0.5),  floor(fract(iTime + 0.5) * 2.0)) * 10.0;
    vResult += GetLight(GetSource1Pos(iTime), vLight1Colour, vRayOrigin, vRayDir);

    return vResult;
}

// Function 4286
vec2 mapMat(vec3 p){
    vec2 sphere = vec2(length(p - vec3(0.0, 0.0, 4.0)) - 1.5 - texture(iChannel0, p.xy).r * 0.03, 2.0);
    vec2 flo = vec2(p.y + 1.5, 1.0);
    vec2 wall = vec2(-p.z + 10.0, 1.0);
    return vecMin(wall, vecMin(sphere, flo));
}

// Function 4287
Medium Scene_GetMedium( WaveInfo wave, int iObjectId )
{
    Medium medium;
    
    medium.fScatteringDensity = 0.0; //0.0025;//0.0015;
    medium.fRefractiveIndex = 1.0;
        
    bool bGlass = false;
    vec3 vAbsorb = vec3(1.0)  - vec3(0.99);
      
#if SPECTRAL
		float fRefractionWavelength_nm = wave.wavelength;
#else    
    	float fRefractionWavelength_nm = 540.0;        
#endif 
    
    if ( iObjectId == MAT_WINE )
    {
    	vAbsorb = vec3(1.0)  - vec3(0.9, 0.9, 0.3);
        //medium.fRefractiveIndex = 1.330;
        medium.fRefractiveIndex = Cauchy( fRefractionWavelength_nm,1.330, 0.00743 );
        
    }
    
    if ( iObjectId == MAT_COLORLESS_GLASS || iObjectId == MAT_FROSTED_GLASS )
    {
    	vAbsorb = vec3(1.0)  - vec3(0.9);
        bGlass = true;
    }
    
    if ( iObjectId == MAT_COLORED_GLASS )
    {
    	vAbsorb = vec3(1.0)  - vec3(0.9, 0.1, 0.1);
        medium.fScatteringDensity = 0.3;
        
        #if TEST_TUBES_SCENE
			//medium.fScatteringDensity = 2.0;
	    	vAbsorb = vec3(0, 3, 4);
        #endif
        bGlass = true;
    }
    
    if ( iObjectId == MAT_COLORED_GLASS_2 )
    {
    	vAbsorb = vec3(1.0)  - vec3(0.1, 0.3, 0.9 );
        
        #if TEST_TUBES_SCENE
			//medium.fScatteringDensity = 2.0;
	    	vAbsorb = vec3(4, 3, 0);
        #endif        
        medium.fScatteringDensity = 0.3;
        bGlass = true;
    }
    
    if ( bGlass )
    {                  
#if 0
        medium.fRefractiveIndex = Cauchy( fRefractionWavelength_nm, 1.5220, 0.00459 );
#else
        
        vec3 B = vec3(1.03961212, 0.231792344, 1.01046945);
        vec3 C = vec3(6.00069867e-3, 2.00179144e-2, 1.03560653e2);
        medium.fRefractiveIndex = Sellmeier( fRefractionWavelength_nm, B, C );
        
#endif        
    }
    
    medium.cAbsorb = ColorScale_sRGB( wave, vAbsorb );
    return medium;
}

// Function 4288
vec2 GetDist(vec3 p) {
    float time = iTime;
    p.xz *= Rot(time*.01*6.2831);        
    p.yz *= Rot(time*.005*6.2831);        
	time=time*.2;
	vec3 q=p;
    vec4 ico = icosahedronVertex(q);
    float id = ico.w;
    q*=orientMatrix(ico.xyz,vec3(0.,1.,0.));
    float rocket = sdRocket(3.*animateRocket(q,time+id))*.333;
    float earth = length(p)-.7;
	float c = -sdCone(q,vec2(sin(PI/6.),cos(PI/6.)));   // disance to domain bouding cone 
    float d=min(rocket,earth);    
    d=min(d,max(c,.5));  // this is trying to slow down the ray marcher when approaching the bound of the cone over the face of the dode
    return vec2(d,id);
}

// Function 4289
float floorSDF(vec3 pos)
{
    // Just a few tiles
    // Rounded box distance function by iq
    // https://www.youtube.com/watch?v=62-pRVZuS5c
    pos.xy -= 3.*round(pos.xy/3.);
    vec3 c = vec3(0., 0., -0.2);
    float rounded = 0.1;
    vec3 r = vec3(0.75, 0.75, 0.2)-rounded;
    vec3 q = abs(pos - c) - r;
    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;
}

// Function 4290
vec3 calculateGradientFromDistanceField(vec3 p) {
    
    float d = 0.001;
    float Dx = (distanceToObjects(p+vec3(d,0.0,0.0))-distanceToObjects(p+vec3(-d,0.0,0.0)))/(2.0*d);
    float Dy = (distanceToObjects(p+vec3(0.0,d,0.0))-distanceToObjects(p+vec3(0.0,-d,0.0)))/(2.0*d);
    float Dz = (distanceToObjects(p+vec3(0.0,0.0,d))-distanceToObjects(p+vec3(0.0,0.0,-d)))/(2.0*d);
    return vec3(Dx,Dy,Dz);
}

// Function 4291
void mainCubemap( out vec4 O, vec2 U,  vec3 C, vec3 D )
{
    ivec2 I = ivec2(U)/128;                                      // tile bi-Id
    vec3 A = abs(D);
    int  f = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2,  // faceId
         s = I.x + 8*I.y,                                        // tile Id
         i = int(1023.* T( mod(U,128.) ) );                      // discretize signal
    if ( D[f] < 0. ) f += 3;                                     // full face Id.
    O = f<4 ? vec4( equal( ivec4(i), s + 64*ivec4(0,1,2,3) + 256*f )) // isolate one value within 256                                
            : vec4(T(U/R*128.),0,0,0);                           //  2 useless : free to show the image ! 
 // O = .5*vec4(  ( s + 64*ivec4(0,1,2,3) + 256*f) );    // cubeMap calibration
}

// Function 4292
vec3 renderMinecraftSubscene(
        Minecraft mine, TraceSubsceneResult t, vec3 orig, vec3 dir)
{
    vec3 minePos = toMinePos(mine, t.globalTrace, orig, dir);
    return renderMinecraftGrass(mine, t.subTrace, minePos, dir);
}

// Function 4293
Shape map(vec3 c){
  Shape face = character(c);
  Shape background = bg(c);
    
    face.dist = min(face.dist, background.dist);
    face.color = mix(face.color, background.color,
                     mixColors(background.dist, face.dist, .5));
    
  return face;
}

// Function 4294
vec2 barrelDistortion(vec2 coord, float amt, float zoom)
{ // based on gtoledo3 (XslGz8)
  // added zoomimg
	vec2 cc = coord-0.5;
    vec2 p = cc*zoom;
    coord = p+0.5;
	float dist = dot(cc, cc);
	return coord +cc*dist*amt;
}

// Function 4295
float Scene_SDF(vec3 point, inout RayHit hit)
{
  	float sdf = FarClip;
    
    float blade = Blade_SDF(point);
    AssignM(blade, MaterialPolishedSteel);
    
    float guard = Guard_SDF(point);
    AssignM(guard, MaterialSteel);
    
    float grip = Grip_SDF(point);
    AssignM(grip, MaterialLeather);
    
    float pommel = Pommel_SDF(point);
    AssignM(pommel, MaterialSteel);
    
    return sdf;
}

// Function 4296
float heightMap3(in vec2 pos)
{
    pos /= 7.;
    vec2 m1 = mod(pos, 1.), m2 = mod(pos, 2.);
    pos = mix(m1, 1.-m1, max(vec2(0.), sign(m2-1.)));
    //if (m2.x >= 1.) m1.x = 1. - m1.x;
    //pos = m1;
    pos += vec2(4,.5);
    vec3 p = vec3(pos, 1.);
    float d = 0.;
    for (int i=0; i<24; ++i)
    {
        p = abs(p) / dot(p.xy, p.xy);
        //d = min(d, exp(- p.x/p.z));
        d += 1.*( exp(-p.x/p.z*(1.+1.*float(i*i))) )/float(1+i);
        if (float(i)>(18.+6.*sin(iTime)))
            break;
        p.xy -= .99;//+.02*sin(iTime);
    }
    return d;//smoothstep(0.1,.0, d);
}

// Function 4297
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn, rg;
  vec2 qBlk;
  float dstObj, a, s, sh;
  bool fxz;
  aRot = -0.4 * 2. * pi * tCur;
  aCs[0] = vec2 (cos (aRot), sin (aRot));
  aCs[1] = vec2 (cos (aRot + pi * 2./3.), sin (aRot + pi * 2./3.));
  aCs[2] = vec2 (cos (aRot + pi * 4./3.), sin (aRot + pi * 4./3.));
  crRad = 2.;
  crLen = 5.;
  for (int k = 0; k < 3; k ++) {
    crMid[k].y = -0.5 * crRad * aCs[k].y;
    crCs[k] = vec2 (cos (asin (crMid[k].y / crLen)), crMid[k].y / crLen);
    crMid[k].x = crLen * crCs[k].x + crRad * aCs[k].x;
  }
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);
    if (idObj == idBase) {
      col4 = vec4 (0.3, 0.5, 0.6, 0.1);
      if (abs (vn.y) < 0.01) {
        rg = ro;
        rg.y += 0.5;
        fxz = (abs (vn.x) > 0.99);
        rg = ShStagGrid ((fxz ? rg.zy : rg.xy), vec2 (1., 2.));
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * (fxz ? ro.zy : ro.xy));
        rg.xz *= sign (fxz ? vn.x : vn.z);
        if (fxz) {
          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);
          else vn.xz = Rot2D (vn.xz, rg.x);
        } else {
          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);
          else vn.zx = Rot2D (vn.zx, rg.x);
        }
      } else {
        rg = ShGrid (ro.xz);
        col4.r *= rg.y;
        col4.rgb *= 1. - 0.3 * Fbm2 (2. * ro.xz);
        if (vn.y > 0.99) {
          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);
          else vn.yx = Rot2D (vn.yx, rg.x);
        }
      }
      vn = VaryNf (32. * ro, vn, 1.);
    } else if (idObj == idCyl) {
      col4 = vec4 (0.6, 0.3, 0.1, 0.2);
      a = atan (qHit.z, - qHit.y) / (2. * pi);
      if (abs (vn.x) > 0.99) {
        col4.r *= 1. - 0.3 * Fbm2 (4. * qHit.yz);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *
           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));
      } else {
        col4.r *= 1. - 0.3 * Fbm2 (4. * vec2 (8. * a, qHit.x));
        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));
        a = mod (32. * a, 1.);
        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *
           sign (a - 0.5));
      }
    } else if (idObj == idWhl) {
      if (abs (vn.z) < 0.01) {
        s = length (qHit.xy);
        qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);
        if (s > 4.1) {
          s = mod (4. * qHit.z, 1.);
          vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (ro.z);
          vn = normalize (vn);
        }
      }
      col4 = vec4 (0.5, 0.5, 0.55, 0.05) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));
    } else if (idObj == idSpk) {
      col4 = 1.1 * vec4 (0.5, 0.5, 0.55, 0.2);
    } else if (idObj == idCrnk) {
      col4 = vec4 (0.5, 0.5, 0.6, 0.2);
    } else if (idObj == idAx) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.3);
    } else if (idObj == idPis) {
      col4 = vec4 (0.5, 0.5, 0.2, 0.3);
    } else if (idObj == idCrod) {
      col4 = vec4 (0.6, 0.6, 0.5, 0.3);
    } else if (idObj == idCylEnt) {
      col4 = vec4 (0.5, 0.4, 0.1, 0.2);
      if (length (qHit.yz) < 0.33) col4.rgb *= 0.5;
    } else if (idObj == idValv) {
      col4 = vec4 (0.6, 0.3, 0.1, 0.2);
      if (vn.x > 0. && length (qHit.yz) < 0.13) col4.rgb *= 0.5;
      vn = VaryNf (32. * qHit, vn, 0.3);
    } else if (idObj == idPipes) {
      col4 = vec4 (0.7, 0.5, 0.1, 0.2);
      vn = VaryNf (32. * ro, vn, 0.3);
    } else if (idObj == idSup) {
      col4 = vec4 (0.3, 0.5, 0.1, 0.05);
      vn = VaryNf (32. * ro, vn, 1.);
    }
    sh = 0.5 + 0.5 * ObjSShadow (ro, ltDir);
    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +
       col4.a * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);
    col += col4.a * vec3 (0.4) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.05, qBlk.y));
  } else {
    qBlk = mod (4. * BlkHit (ro, rd), 1.);
    col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +
       vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *
       SmoothBump (0.25, 0.75, 0.1, qBlk.y));
  }
  return clamp (col, 0., 1.);
}

// Function 4298
float DistanceField( vec3 p, float t )
{
	return
			min(min(min(min(min(min(min(min(
				Sphere(p,vec3(0,.48,0),.1),
				Oct(p,vec3(0,.2,0),.2)),
				CubeFrame(p,vec3(0,-.05,0),.3)),
				Sphere(p,vec3(0,-.6,0),.4)),
				Cube(p,vec3(0,-1.7,0),1.0)),
				Cube(p,vec3(0,-2.9,0),2.0)),
				Cube(p,vec3(0,-8.0,0),8.0)),
				Cube(p,vec3(0,3,-11),8.0)),
				CubeFrame(p,vec3(0),4.0));

	// spiral candle
/*	p.xz = p.xz*cos(p.y*4.0)+vec2(1,-1)*p.zx*sin(p.y*4.0);
	return max(
				max( p.y-.5, -p.y-1.),
				(min(
					max(abs(p.x),abs(p.z)),
					max(abs(p.x+p.z),abs(p.z-p.x))/sqrt(2.0)
				)-.15)*.8);*/
}

// Function 4299
float sphereDist2(vec3 a, vec3 b) {
	// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2
    return 2.0-2.0*dot(normalize(a),normalize(b));
}

// Function 4300
float remap(float v,float min1,float max1,float min2,float max2
){return min2+(max2-min2)*(v-min1)/(max1-min1);}

// Function 4301
float stringDist(vec2 textPos, float textSize, ivec4 chars) {  
    
    
    int len = int(chars.w) >> 24;
    float flen = float(len);
    
    float xsize = 0.8*textSize;
    
    float x0 = -0.5*(flen-1.)*xsize;
    float xRel = textPos.x - x0;

    float cidx = floor(xRel/xsize + 0.5);
    
    if (cidx < 0. || cidx >= flen || abs(textPos.y) > textSize) {
        return 1e5;
    }
    
    float xChar = x0 + cidx*xsize;

    int i = int(cidx);
    int c = chars[i>>2] >> ((i&0x3)<<3);

    int lo = c & 0xF;
    int hi = (c >> 4) & 0xF;

    vec2 offset = vec2(float(lo), 15.-float(hi));

    return fontDist(textPos - vec2(xChar, 0), textSize, offset);
    
}

// Function 4302
void mainCubemap( out vec4 fragColor, in vec2 _fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    int page;
    vec2 fragCoord;
    fragCoordFromVCube(rayDir, page, fragCoord);

    if (page == 1) {
        writePage1(fragColor, fragCoord);
    } else if (page == 2) {
        writePage2(fragColor, fragCoord);
    } else if (page == 3) {
        writePage3(fragColor, fragCoord);
    } else if (page == 4) {
        writePage4(fragColor, fragCoord);
    } else if (page == 5) {
        writePage5(fragColor, fragCoord);
    } else {
        discard;
    }
}

// Function 4303
float planeSDF(vec3 p) {
    return abs(p.y);
}

// Function 4304
vec4 scene(vec3 ro,vec3 rd)
{
	
	vec3 p = vec3(0.0);
	
	vec2 res = castRay(ro,rd, 4.0);
	
	float t = res.x;
	float m = res.y;	
	
	
	vec4 color = vec4(0.0);
	if (m>-1.0) {
		vec3 pos = ro + rd*t;
		float previous_density;
		// ray-march into volume
		for(int i=0; i<furLayers; i++) {
			
			float density = density_function(pos);
			vec4 c = compute_color(pos, density);
			
			if(density != previous_density)
			{
				vec3 normal = compute_normal(pos, density);
				c = compute_shading(c, pos, normal);
				previous_density = density;
			}
						
			c.a = 1.0 - pow(abs(1.0 - c.a), 100.0*rayStep);
			
			if(c.a > 0.0)
			{
				float t = c.a *(1.0 - color.a);
				color += vec4(t*c.r, t*c.g, t*c.b, t);
			}
			
			// march further along the ray
			if( c.a>0.99 ) break;
			pos += rd*rayStep;
		}
	}
	
	return color;
}

// Function 4305
vec2 mapElephant( vec3 p, out vec3 matInfo )
{
    matInfo = vec3(0.0);
    
    p.x -= -0.5;
	p.y -= 2.4;
    
    vec3 ph = p;
    float cc = 0.995;
    float ss = 0.0998745;
    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;
    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;
    
    // head
    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );
    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );

    // nose
    vec2 kk;
    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );
    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);
    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );
    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);
    float bd1 = b1.x-tr1;
    float bd2 = b2.x-tr2;
    float nl = b1.y*0.5;
    float bd = bd1;
    if( bd2<bd1 )
    {
        nl = 0.5 + 0.5*b2.y;
        bd = bd2;
    }
    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);
    float d2 = bd;
    float xx = nl*120.0;
    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));
    //ff *= smoothstep(0.0,0.01,kk.y);
    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);

    d2 -= (0.05 - 0.05*(1.0-pow(textureLod( iChannel0, vec2(1.0*nl,p.z*0.12), 0.0 ).x,1.0)))*nl*(1.0-nl)*0.5;
    
    float d = smin(d1,d2,0.2);

    // teeth
    vec3 q = vec3( p.xy, abs(p.z) );
    vec3 qh = vec3( ph.xy, abs(ph.z) );
    {
    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );
    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));
    d = smin( d, d3, 0.1 );
    }
    
    // eyes
    {
    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );
    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));
    d = smin( d, d3, 0.03 );

    float st = length(qh.xy-vec2(-0.31,-0.02));
    //d += 0.005*sin(250.0*st)*exp(-110.0*st*st );
    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));

        
    mat3 rot = mat3(0.8,-0.6,0.0,
                    0.6, 0.8,0.0,
                    0.0, 0.0,1.0 );
    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
	d = smax(d, -d4, 0.02 );
    }
   

    // body
    {
    float co = cos(0.4);
    float si = sin(0.4);
    vec3 w = p;
    w.xy = mat2(co,si,-si,co)*w.xy;

    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );
	d = smin(d, d4, 0.2 );

    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );
	d = smin(d, d4, 0.1 );
    }

    // back-left leg
    {
    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );
    d = smin(d,d3,0.1);
    }
    
	// tail
    #if 0
    {
    vec2 b = sdBezier( vec3(2.8,0.2,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );
    float tr = 0.10 - 0.07*b.y;
    float d2 = b.x - tr;
    d = smin( d, d2, 0.05 );
    }
    #endif
        
    // front-left leg
    #if 0
    {
    float d3 = leg( q, vec3(0.8,-0.4,0.3), vec3(0.5,-1.55,0.3), vec3(0.5,-2.1,0.3), 1.0, 0.0 );
    d = smin(d,d3,0.15);
    }
    #else
    {
    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );
    d = smin(d,d3,0.15);
    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );
    d = smin(d,d3,0.15);
    }
    #endif
    
#if 1
    // ear
    float co = cos(0.5);
    float si = sin(0.5);
    vec3 w = qh;
    w.xz = mat2(co,si,-si,co)*w.xz;
    
    vec2 ep = w.zy - vec2(0.5,0.4);
    float aa = atan(ep.x,ep.y);
    float al = length(ep);
    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));
    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.5+0.05*sin(aa)), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));
                      
    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);
    r += 0.01*sin(15.0*w.z);
    // section        
    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    
    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    
    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    
    d4 = smax( d4, d5, 0.1 );
    d4 = smax( d4, d6, 0.1 );

    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);
    w.x += 0.05*cos(6.0*w.y);
    
    // cut it!
    d4 = smax( d4, -w.x, 0.03 ); 
    d4 = smax( d4, w.x-wi, 0.03 ); 
    
	matInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));
    
    d = smin( d, d4, 0.3*max(qh.y,0.0) ); // trick -> positional smooth
    
    // conection hear/head
    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );
    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);
    d = smin( d, d3, 0.05 );
    
#endif

    d -= 0.002*textureLod( iChannel1, 0.5*p.yz, 0.0 ).x;
    d -= 0.002*textureLod( iChannel1, 0.5*p.yx, 0.0 ).x;
    d += 0.003;
    d -= 0.005*textureLod( iChannel0, 0.5*p.yx, 0.0 ).x*(0.2 + 0.8*smoothstep( 0.8, 1.3, length(p-vec3(-0.5,0.0,0.0)) ));

    
    vec2 res = vec2(d,0.0);
	//=====================
    // teeth
    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );
    float tr = 0.10 - 0.08*b.y;
    d2 = b.x - tr;
    if( d2<res.x ) 
    {
        res = vec2( d2, 1.0 );
        matInfo.x = b.y;
    }
	//------------------
    //eyeball
    mat3 rot = mat3(0.8,-0.6,0.0,
                    0.6, 0.8,0.0,
                    0.0, 0.0,1.0 );
    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
    if( d4<res.x ) res = vec2( d4, 2.0 );

    return res;
}

// Function 4306
vec2 map(vec3 p) {
    vec3 pp = p;
    pp.xz *= rot(-.5);
    
    float surface = -p.y - sdSurface(p.xz);
    float t = time * 0.6;
    surface += (0.5 + 0.5 * (sin(p.z * 0.2 + t) + sin((p.z + p.x) * 0.1 + t * 2.0))) * 0.4;
    
    return min2(vec2(surface, 1.5),
           min2(vec2(sdChest(pp + vec3(2.0, 4.4, 0.0)), 2.5),
           min2(vec2(sdFloor(p), 3.5),
           min2(vec2(sdPlants(p - vec3(6.0, 0.0, 7.0)), 5.5),
           min2(vec2(sdManta(p), 6.5),
           min2(vec2(sdBubble(pp, time - 0.3), 4.5),
                vec2(sdBubble(pp, time), 4.5)))))));
}

// Function 4307
float sdf_crystal(vec3 p, float scale) {
	vec3 fp = fold(p * scale);
	float cryst = dot(fp, normalize(sign(fp))) - .1 - sin(fp.y*.2)*2. - sin(fp.y*.7)*1.;
	cryst += min(fp.x*1., sin(fp.y*.3));

	fp = fold(fp) - vec3(.2, .57, -.2);
	fp = fold(fp) - vec3(-.14, .99, -2.4);
	fp = fold(fp) - vec3(-.03, 1., -.3);
	fp = fold(fp) - vec3(0, .26, 0);
	cryst += sin(fp.y*.18)*5.;
	cryst *= .6;

	return cryst / scale;
}

// Function 4308
float map(vec3 p) {
	float w = plane(p, vec4(0.0,0.0,1.0,-0.6));
	float s = sphere(p - vec3(1.0,0.0,0.0), 0.5);
	float s2 = sphere(p - vec3(0.67,0.0,0.0), 0.2);
	float c = cone(p - vec3(-0.5,0.0,-0.3), normalize(vec2(1.0,0.5)), 0.5);
	return min(c, min(max(s,-s2),w));
}

// Function 4309
vec2 GetDist(vec3 p){
    //p.z+=sin(iTime*.3+4.)*4.+4.;
    float sphere = length(p)-.5;
    vec2 res = vec2(sphere,1);
    vec2 sphere2 = vec2(length(p-vec3(0,-1,0))-.5,1);
    res = colMin(res,sphere2);
    vec2 sphere3 = vec2(length(p-vec3(0,1,0))-.5,1);
    res = colMin(res,sphere3);
    return res;
}

// Function 4310
float map(vec3 p) {
    float k;
    vec4 p4 = inverseStereographic(p,k);

    pR(p4.zy, time * -PI / 2.);
    pR(p4.xw, time * -PI / 2.);

    // A thick walled clifford torus intersected with a sphere

    float d = fTorus(p4);
    d = abs(d);
    d -= .2;
    d = fixDistance(d, k);
    d = smax(d, length(p) - 1.85, .2);

    return d;
}

// Function 4311
float3 TonemapWithWeight(float3 c, float w) { return c * (w * rcp(max3(c.r, c.g, c.b) + 1.0)); }

// Function 4312
vec2 Scene( vec3 P )
{
	return doPepe(P, iTime);
}

// Function 4313
vec3 map( vec3 p )
{
    // --- Exported by RaySupreme.com
    vec3 res=vec3( 1000000, -2, -1 ); mat4 mat; vec3 tp, temp;
    vec3 gResult1, gResult2;
    gResult1 = vec3( 1000000, -2, -1 );
    tp=p;
    gResult1=opU( gResult1, vec3( length( max( abs( tp) - vec3( 399.741, 399.741, 399.741 ), 0.0 ) ) - 0.259, 0, 0 ) );
    tp=p;
    tp.y = tp.y + -19.0000;
    gResult1.x=opS( gResult1.x, length( max( abs( tp) - vec3( 84.000, 3.000, 3.000 ), 0.0 ) ) - 16.000);
    res=opU( res, gResult1 );
    tp=p;
    tp = tp + vec3(-2.0000,-2.0000,-4.0000);
    res=opU( res, vec3( length( tp ) - 1.000, 1, 3 ) );
    tp=p;
    tp = tp + vec3(4.0000,-1.5000,-4.0000);
    res=opU( res, vec3( length( tp ) - 0.300, 1, 4 ) );
    gResult1 = vec3( 1000000, -2, -1 );
    gResult2 = vec3( 1000000, -2, -1 );
    tp=p;
    tp.x = tp.x + -0.3542;
    tp /= vec3( 1.300, 1.300, 1.300 );
    gResult2=opU( gResult2, vec3( sdCylinder( tp, vec2( 1.000, 0.030) ), 3, 5 ) );
    tp=p;
    tp.xy = tp.xy + vec2(-0.3542,-0.1300);
    tp /= vec3( 1.300, 1.300, 1.300 );
#if (DISPLACEMENT == 1)
    vec3 bumpNormal; Material bumpMaterial;
    material0( p, bumpNormal, 0., bumpMaterial );
    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) )- bumpMaterial.bump/50., 2, 6 ), 16.7396 );
 #else
    gResult2 = opBlend( gResult2, vec3( sdCylinder( tp, vec2( 0.800, 0.030) ), 2, 6 ), 16.7396 );
 #endif
    tp=p;
    tp.xy = tp.xy + vec2(-0.3542,-0.1560);
    tp /= vec3( 1.300, 1.300, 1.300 );
    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.700, 0.040) ));
    gResult1=opU( gResult1, gResult2 );
    gResult2 = vec3( 1000000, -2, -1 );
    tp=p;
    mat=mat4(0.3323,-0.1160,-0.9360,0.0000
    ,0.3295,0.9442,0.0000,0.0000
    ,0.8838,-0.3084,0.3519,0.0000
    ,-0.4378,-0.8764,0.3315,1.0000);
    tp=(mat * vec4(tp, 1.0)).xyz;
    tp /= vec3( 1.495, 1.495, 1.495 );
#if (DISPLACEMENT == 1)
    material0( p, bumpNormal, 0., bumpMaterial );
    gResult2=opU( gResult2, vec3( length( tp ) - 0.600- bumpMaterial.bump/50., 2, 9 ) );
#else
    gResult2=opU( gResult2, vec3( length( tp ) - 0.600, 2, 9 ) );
#endif
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.3472,-1.4950,-2.3441);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, length( tp ) - 1.280);
    tp=p;
    mat=mat4(0.8400,0.0942,-0.5344,0.0000
    ,-0.0000,0.9848,0.1736,0.0000
    ,0.5426,-0.1459,0.8272,0.0000
    ,-0.2975,-0.9904,0.0205,1.0000);
    tp=(mat * vec4(tp, 1.0)).xyz;
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, sdCylinder( tp, vec2( 0.630, 0.030) ));
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.2975,-0.9717,0.1922);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2.x=opS( gResult2.x, length( tp ) - 0.550);
    tp=p;
    tp.xz = mat2(0.8400,-0.5426,0.5426,0.8400) * tp.xz;
    tp = tp + vec3(-0.2975,-0.9717,0.1922);
    tp /= vec3( 1.495, 1.495, 1.495 );
    gResult2=opU( gResult2, vec3( length( tp ) - 0.520, 0, 13 ) );
    gResult1=opU( gResult1, gResult2 );
    res=opU( res, gResult1 );
    return res;
}

// Function 4314
float UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)
{
    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab
    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)
    //The clamp provides the line seg limits. e is therefore the "capped orthogogal projection".
    //       p
    //      /
    //     /
    //    a--e-------b
    vec2 ap = p-a;
    vec2 ab = b-a;
    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 4315
float map(vec3 p)
{
	float d = 100000.0;

    fUnion(d, pRoundBox(p - vec3(0,-2.0,0), vec3(4,0.1,4), 0.2));
	fUnion(d, pSphere(p - vec3(2,0,2), 1.5));
    fUnion(d, pSphere(p - vec3(3.5,-1.0,0.0), 0.8));
    fUnion(d, pTorus(p - vec3(-2,0,2), vec2(1,0.3)));
	fUnion(d, pTorus2(p - vec3(-3,0,2), vec2(1,0.3)));
    fUnion(d, pRoundBox(p - vec3(2,0.6,-2), vec3(0.1,0.1,1), 0.3));
	fUnion(d, pRoundBox(p - vec3(2,0,-2), vec3(0.1,1.5,0.1), 0.3));
	fUnion(d, pRoundBox(p - vec3(2,-0.4,-2), vec3(1.2,0.1,0.1), 0.3));
    fUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-2,-1,-1.0), 0.3));
	fUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-1.0,-1,-2.5), 0.3));
	fUnion(d, pCapsule(p, vec3(-2,1.5,-2), vec3(-3.0,-1,-2.5), 0.3));
	
	return d;
}

// Function 4316
vec3 Tonemap_Uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {
    // Uchimura 2017, "HDR theory and practice"
    // Math: https://www.desmos.com/calculator/gslcdxvipg
    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp
    float l0 = ((P - m) * l) / a;
    float L0 = m - m / a;
    float L1 = m + (1.0 - m) / a;
    float S0 = m + l0;
    float S1 = m + a * l0;
    float C2 = (a * P) / (P - S1);
    float CP = -C2 / P;

    vec3 w0 = 1.0 - smoothstep(vec3(0.0), vec3(m), x);
    vec3 w2 = step(vec3(m + l0), x);
    vec3 w1 = 1.0 - w0 - w2;

    vec3 T = m * pow(x / m, vec3(c)) + b;
    vec3 S = P - (P - S1) * exp(CP * (x - S0));
    vec3 L = m + a * (x - m);

    return T * w0 + L * w1 + S * w2;
}

// Function 4317
float map(float val, float amin, float amax, float bmin, float bmax) {
    float n = (val - amin) / (amax-amin);
    float m = bmin + n * (bmax-bmin);
    return m;
}

// Function 4318
float map(vec3 p){
 
    
    // Grid scale. Smaller values give a denser mesh, which obviously fit the isosurface 
    // better. I deliberately chose a less dense mesh in order to display the individual 
    // triangles more clearly.
    const float sc = .75;
 
    // Partitioning space into cubes, which are further subdivided into six tetrahedra. 
    // Note that no skewing is performed. You could, but I hear that it's not necessary.
    vec3 i = floor(p/sc)*sc;  p -= i;
    // Partioning into tetrahedra - Determined by checking which side of a couple 
    // of diagonal planes we're on.
    vec3 i1 = step(p.yzx, p)*sc, i2 = max(i1, sc - i1.zxy); i1 = min(i1, sc - i1.zxy);    
    
    // The four vertices of the individual tetrahedron.
    vec3 p0 = vec3(0), p1 = i1, p2 = i2, p3 = vec3(1)*sc;
    
    // Places for six vertices. Difference combinations require two triangles. "va" hold
    // the round vertex places.
    vec3 v1, v2, v3, v4, v5, v6, va;
        
     ///////////    
     
    // The four surface isolvalues at each of the four vertices. Yes, taking four isovalues
    // per distance function is crazy. In fact, we're rendering the continuous surface as
    // well, so that makes five... Don't try this at home, folks. :D
    vec4 ps = vec4(isoMap(i+p0), isoMap(i+p1), isoMap(i+p2), isoMap(i+p3));
 
    // The continuous isosurface value. Actually, it's a little smaller, just so it can 
    // fit inside the polygonized mesh a little better. I deliberately left a bit of
    // overlap for stylistic purposes, and to show that the mesh is an approximation.
    float surface = isoMap(p + i) + .1;
    
    // The mesh and vertice values.
    float mesh = 1e8, verts = 1e8;
 
    // A flag to determine whether one, two, or zero triangle arrangements should be drawn.
    float tri = 0.;
    
    
    // Edge thickness and isolevel threshold constants.
    const float r1 = .04;
    
    // The threshold doesn't have to be zero, but it makes more sense this way, since it's
    // analogous to the zero distance mark. Ie, a surface hit.
    const float isolevel = 0.;
 
    int index = 0; 
    
    // An old power-of-two flag trick. For instance, if point ps[0] and ps[2] are below the
    // isolevel - or, in other words, inside the surface, the "index" variable will have a 
    // unique value of 5.
    index += ps[0] < isolevel ? 1 : 0;
    index += ps[1] < isolevel ? 2 : 0;
    index += ps[2] < isolevel ? 4 : 0;
    index += ps[3] < isolevel ? 8 : 0;
 
    
    
    // If there are no verices with isovalues below the threshold, then we are
    // effectively in open space. The question at this point is, "How far do we
    // advance the ray?" What we should be doing is tetrahedral traversal, but 
    // instead, we'll cheat a little and use the continuous isosurface value.
    // It's not ideal, but it simplifies things greatly.
         
    // No vertices inside.
    if(index == 0) { 
        
        // In theory, a tetrahedral grid traversal is necessary here, but it's slow and 
        // cumbersome, so I'm hacking through it with a bit of fudge, which is prone to
        // artifacts. However, it's a lot simpler and hones in on the surface faster.        
        //mesh = rayTetra(p, p0, p1, p2, p3, svRd) + .05; //rayBox(p);
        
        mesh = surface + .005;  
         
    }
    // All vertices inside.
    else if(index == 15){
        
        // Also requires a tetrahedral grid traversal. However, this way is cheaper.
        //mesh = rayTetra(p, p0, p1, p2, p3, svRd) + .05;
        
        mesh = rayBox(p) + .05;
    	 
    }
    
    // Determining triangle arrangement based on how the four vertex isovalues
    // relate to the threshold. To me it's common sense, but in general, if
    // only one of the four isovalues is above the zero point threshold or only
    // one is below, then one triangle should cut through the three edges it's
    // connected to. That accounts for the first 8 (4x2) cases you see.
    // That leaves the two isovalue above or below case. In that instance, a 
    // two triangle arrangement is necessary. As mentioned, look at the pictures
    // in the article provided above, and that should make it clearer.
    
    // Because we're not concerned with triangular orientation, we can handle
    // two cases at once, which saves half the decision making. When triangle 
    // orientation is important, you can handle the cases seperately. It's been
    // while, but I'm pretty sure you can just reverse the order in once of 
    // the cases... Either way, if you weren't sure, a quick arrangement and
    // visual test would do the trick.
    
    // Single triangle cases:
    //
    // Vertex 0 only is inside (index = 1) or outside (index = 14) the isosurface 
    // (Ie: 1, 2 and 3 are inside).
    if(index == 1 || index == 14){
        
        //objID = 1.;
        tri = 1.;
        
        // This particular triangle will cut through the three edges connecting to 
        // vertex 0. Where the three vertices cut the edge will depend upon where the
        // isosurface touches the edge. You can determine that via simple interpolation.
        // For instance, if "ps[0]" has a value of "1" and "ps[1]" has a value of "-2,"
        // then you'd expect the triangle vertex to cut the edge one third of the 
        // way along the edge from "ps[0]."
        v1 = inter(p0, p1, ps[0], ps[1], isolevel);
        v2 = inter(p0, p2, ps[0], ps[2], isolevel);
        v3 = inter(p0, p3, ps[0], ps[3], isolevel);
        
    }    
    // Vertex 1 only is inside or outside.
    else if(index == 2 || index == 13){

        tri = 1.;
        v1 = inter(p1, p0, ps[1], ps[0], isolevel);
        v2 = inter(p1, p3, ps[1], ps[3], isolevel);
        v3 = inter(p1, p2, ps[1], ps[2], isolevel);
        
        
    }
    // Vertex 2 only is inside or outside.
    else if(index == 4 || index == 11){
        
        tri = 1.;
        v1 = inter(p2, p0, ps[2], ps[0], isolevel);
        v2 = inter(p2, p1, ps[2], ps[1], isolevel);
        v3 = inter(p2, p3, ps[2], ps[3], isolevel);

        
    } 
    // Vertex 3 only is inside or outside.
    else if(index == 7 || index == 8){
        
        tri = 1.;
        v1 = inter(p3, p0, ps[3], ps[0], isolevel);
        v2 = inter(p3, p2, ps[3], ps[2], isolevel);
        v3 = inter(p3, p1, ps[3], ps[1], isolevel);
        
    }
    
 
    
    
    // Two triangle cases.
    //
	// Vertices 0 and 1 are inside or vertices 2 and 3 are inside.
    if(index == 3 || index == 12){
        
        tri = 2.;
        
        v1 = inter(p0, p3, ps[0], ps[3], isolevel);
        v2 = inter(p0, p2, ps[0], ps[2], isolevel);
        v3 = inter(p1, p3, ps[1], ps[3], isolevel);
        
        v4 = v3;
        v5 = inter(p1, p2, ps[1], ps[2], isolevel);
        v6 = v2;

    
    }
    // Vertices 0 and 2 are inside or vertices 1 and 3 are inside.   
    else if(index == 5 || index == 10){
        
        tri = 2.;
        
        v1 = inter(p0, p1, ps[0], ps[1], isolevel);
        v2 = inter(p2, p3, ps[2], ps[3], isolevel);
        v3 = inter(p0, p3, ps[0], ps[3], isolevel);
        
        v4 = v1;
        v5 = inter(p1, p2, ps[1], ps[2], isolevel);
        v6 = v2;

    } 
    // Vertices 1 and 2 are inside or vertices 0 and 3 are inside.
    else if(index == 6 || index == 9){
        
        tri = 2.;
        
        v1 = inter(p0, p1, ps[0], ps[1], isolevel);
        v2 = inter(p1, p3, ps[1], ps[3], isolevel);
        v3 = inter(p2, p3, ps[2], ps[3], isolevel);
        
        v4 = v1;
        v5 = inter(p0, p2, ps[0], ps[2], isolevel);
        v6 = v3;

    }
    
    // Some notes on producing the vertex list - Per Dave Hoskins's request.
    //
    // Performing marching tetrahedra inside a pixel shader is a bit of a novelty, so as you 
    // could imagine, you wouldn't produce the actual vertex list within the shader. The idea 
    // would be to take this algorithm outside the pixel shader environment and produced the 
    // vertices there, where it'd be trivial. Basically, you'd visit every cube just once 
    // (instead of the multiple times required here). You'd subdivide each cube into tetrahedra 
    // using the 8 cube vertices (no need for step arithmetic), take the four isovalues, then 
    // proceed from there.
    
    // int vIndex = 0; // Counter to the vertex list. 
 
    // If necessary, draw a single triangle arrangement - in this case, three triangle edges.
    // All edges together form the mesh.
    if(tri>.5){
        
         mesh = sdCapsule(p, v1, v2, r1);
         mesh = min(mesh, sdCapsule(p, v2, v3, r1));
         mesh = min(mesh, sdCapsule(p, v3, v1, r1)); 
        
         // Imaginary vertex list array. Just keep adding vertices. Groups of three make 
         // up a triangle. "i" is the relative position of each cube, and v1, v2 and v3
         // are unique to each tetrahedron. Obviously, this would be performed outside the
         // the shader environment. You'd have to perform this over a 3 dimensional cubic
         // grid, then run through all six tetrahedra for each cube.
         // Splitting a cube into six tetrhedra. c0 to c7 represent the cube vertices.
		 // 1st [c0, c2, c3, c7], 2nd [c0, c2, c6, c7], 3rd [c0, c4, c6, c7],
		 // 4th [c0, c6, c1, c2], 5th [c0, c6, c1, c4], 6th [c5, c6, c1, c4].
         // For instance the first tetrahedron would be:
         // 1st [i, i + vec3(0, 0, 1), i + vec3(1, 0, 1), i + vec3(1, -1, 1)].
         //vertexList[vIndex++] = i + v1;
         //vertexList[vIndex++] = i + v2;
         //vertexList[vIndex++] = i + v3;
    } 
    
    // If a second triangle arrangement is required, draw it too.
    if(tri>1.5){
         mesh = min(mesh, sdCapsule(p, v4, v5, r1));
         mesh = min(mesh, sdCapsule(p, v5, v6, r1));
         mesh = min(mesh, sdCapsule(p, v6, v4, r1));
        
         // Imaginary vertex list array. Just keep adding triangles.
         //vertexList[vIndex++] = i + v4;
         //vertexList[vIndex++] = i + v5;
         //vertexList[vIndex++] = i + v6;
         
    } 
    
    
    // If necessary, draw little spheres to represent the vertex points for one
    // or two triangles.
    if(tri>.001) {
        va = vec3(dot(p - v1, p - v1), dot(p - v2, p - v2), dot(p - v3, p - v3));
        verts = sqrt(min(min(va.x, va.y), va.z)) - .06; 
    }
    if(tri>1.001) {
        va = vec3(dot(p - v4, p - v4), dot(p - v5, p - v5), dot(p - v6, p - v6));
        verts = min(verts, sqrt(min(min(va.x, va.y), va.z)) - .06);
    }

    // Add the vertices to the mesh.
    mesh = min(mesh, verts);

    // Object identification. Either the mesh or the encased isosurface.
    objID = mesh > surface ? 0. : 1.;
    
    // Combine the mesh with the continuous, encased surface.
    return min(mesh, surface);
    
    
    
}

// Function 4319
float cloudSDF( vec3 pos )
{
    return Multifractal(pos/300.);
}

// Function 4320
float segmentDistance(vec3 point, vec3 a, vec3 b) {
    vec3 aToPoint = point - a;
    vec3 aToB = b - a;

    float time = clamp(dot(aToPoint, aToB) / dot(aToB, aToB), 0.0, 1.0);
    return distance(point, a + time * aToB);
}

// Function 4321
vec3 DistanceRepetition(in vec3 point, in vec3 repetition ){
    vec3 q = mod(point, repetition)-.5*repetition;return q;}

// Function 4322
float cubeSDF(cube cb, vec3 p) {
    p-=cb.p;
    p/=cb.size;
    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z
    // So if all components of d are negative, then p is inside the unit cube
    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 4323
vec3 scene(vec3 ro, vec3 rd){
	float maxt=(-RADIUS+0.005-ro.y)/rd.y;
	float tball=Sphere(ro,rd,vec3(bp.x,0.0,bp.y),RADIUS);
	float t=(RADIUS+0.005-ro.y)/rd.y,d,od=1.0;
	for(int i=0;i<24;i++){
		t+=d=DE(ro+rd*t);
		if(d<0.001 || t>maxt)break;
		od=d;
	}
	vec3 col=vec3(0.0);
	vec2 p=ro.xz+rd.xz*maxt;
	float d2=min(max(abs(p.x)-1.0,abs(p.y)-1.55),length(p-vec2(0.0,1.5))-1.0);
	if(d2<0.0){
		vec3 P=ro+rd*maxt+vec3(-0.03,0.0,0.03);
		d2=DE(P);
		d2=min(d2,length(P-vec3(bp.x,-RADIUS+0.005,bp.y)));
		d2=smoothstep(0.0,0.1,d2);
		col=texture(iChannel1,p.yx).rgb*(0.7+0.3*d2)+abs(sin(floor(p.x*20.0)))*0.2*d2;
	}
	if(d<0.01){
		float dif=clamp(1.0-d/od,0.6,1.0);
		col=mix(Color(ro+rd*t)*dif,col,smoothstep(0.0,0.01,d));
	}
	if(tball<t){
		t=tball;
		vec3 N=normalize(ro+rd*tball-vec3(bp.x,0.0,bp.y));
		d=dot(N,-rd);
		float dif=max(0.0,d);
		col=mix(col,vec3(1.0,1.0,0.7)*dif,smoothstep(0.0,0.56,d));
	}
	if(st2.x>0.0){
		col+=st2.x*vec3(1.0)/(0.5+1000.0*mld*mld);
	}
	return col;
}

// Function 4324
uint spheremap_32( in vec3 nor )
{
    vec2 v = nor.xy * inversesqrt(2.0*nor.z+2.0);
    return packSnorm2x16(v);
}

// Function 4325
void initScene() {
    float time = iTime;
    
    //init lights
    float r = 0.1;
    
    vec3 z = sphericalToCartesian(1.0,sin(iTime),cos(iTime));
    vec3 x = z.x<0.8?vec3(1.0,0.0,0.0):vec3(0.0,0.0,1.0);
    vec3 y = normalize(cross(z,x));
    x = cross(y,z);
    mat4 trans = mat4( 	vec4( x, 0.0 ), 
    					vec4( y, 0.0 ),
    					vec4( z, 0.0 ),
    					vec4( 0.0, 4.0, -3.0, 1.0 ));
    createCylinder(trans, 0.1, 0.0, 7.0, TWO_PI, MTL_LIGHT, objects[0]);
    
    
    //plane 1
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 5.0, -10.0, 1.0 ));
    createPlane(trans, -10.0, -2.0, 10.0, 4.0, MTL_DIFFUSE, objects[1]);
   
    //plane 2
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, -1.0, 0.0 ),
                    vec4( 0.0, -1.0, 0.0, 0.0 ),
                    vec4( 0.0, -1.0, -4.0, 1.0 ));
    createPlane(trans, -10.0, -4.0, 10.0, 2.0, MTL_DIFFUSE, objects[2]);
 
    //Cylinder
    trans = mat4(	vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( -0.0, 3.0, -6.0, 1.0 ));
    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, MTL_DIFFUSE, objects[3] );
    
    //sphere 1
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 2.5, 0.0, -2.0, 1.0 ));

    createSphere(trans, 1.0, MTL_DIFFUSE, objects[4] );
    
    //sphere 2
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( -1.0, 0.0, -5.0, 1.0 ));

    createSphere(trans, 1.0, MTL_DIFFUSE, objects[5] );
    
    //box
    trans = createCS(	vec3(-1.5, -1.0, -3.0),
                     	vec3(0.0, 1.0, 0.0),
                     	vec3(0.2, 0.0, -0.7));
    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), MTL_DIFFUSE, objects[6]);
}

// Function 4326
float distMap(vec3 p)
{
	float ret = 0.0;
	vec3 q = rotate(p,  iTime-slowt, vec3(2.0, 1.0, 5.0));
	//ret = distSphere(p, 1.0);
	ret = distBox(q, vec3(0.5, 0.5, 0.5));
    
    //ret = min(distBox(q+1.0, vec3(0.5, 0.5, 0.5)),distBox(q, vec3(0.3, 0.3, 0.3)));
    
	return ret;
}

// Function 4327
float remap(float value, float low2,float high2,bool c){return remap(value,0.,1.,low2,high2,c);}

// Function 4328
float map_floor(vec3 pos)
{
   return pos.y;
}

// Function 4329
vec3 samplescene (vec2 uv, float time)
{
    vec2 uvsize = (iResolution.xy / iResolution.x);
    vec2 uvsizeHalf = uvsize * 0.5;
    vec3 final = vec3(0.0);
    
    // Prepare rect properties
    vec2 rectHalfSize = vec2(0.4, 0.225);
    const float rectUVScale = 1.5;
    vec2 rectUV = (uv - (uvsizeHalf - rectHalfSize)) * rectUVScale;
    
    // Downscale the rectangle's resolution
    const float crunchfactor = 64.0;
    vec2 uvcrunchy = floor(rectUV * crunchfactor) / crunchfactor;
    vec2 uvcrunchylocal = fract(rectUV * crunchfactor);
    
    // Commodore colours
    vec3 colourBG = HEXRGB(0x887ecb);
    vec3 colourRect = HEXRGB(0x50459b);
    
    // Background C64 loading screen-like raster bars
    float rasterScale = 15.0;
    float rasterOff = time * 0.5;
    float rasterMix = floor(fract((uv.y + rasterOff) * rasterScale + (uv.x * sin(time * 3.0)) * 0.5) + 0.5);
    const vec3 colours[3] = vec3[3](HEXRGB(0x6abfc6), HEXRGB(0xa1683c), HEXRGB(0x9ae29b));
    
    colourBG = mix(colours[int(time) % 3], HEXRGB(0xadadad), rasterMix);
    
    // Foreground : 10PRINT
    const float uvdownscaleFactor = 64.0;
    vec2 uvdownscale = (rectUV * uvdownscaleFactor + 0.5);
    vec2 uvdownscaleLocal = fract(uvdownscale);
    uvdownscale = floor(uvdownscale) / uvdownscaleFactor;
    
    vec3 rectBG = samplerectBG(uv, uvdownscale, time);
    float rectBGLuma = clamp(dot(rectBG, rectBG), 0.0, 1.0);
    
    // apply LED light effect to foreground's 10PRINT BG(??)
    float ledDiscRadius = 0.25 * rectBGLuma + 0.20;
    const float ledDiscRadiusSmooth = 0.1;
    float ledDiscDelta = distance(vec2(0.5), uvdownscaleLocal);
    float ledDiscMix = smoothstep(ledDiscRadius + ledDiscRadiusSmooth, ledDiscRadius, ledDiscDelta);
    colourRect = mix(rectBG * 0.5, rectBG, ledDiscMix);
    colourRect = clamp(colourRect + pow(1.0 - ledDiscDelta, 2.0) * 0.2, 0.0, 1.0);

    // Foreground : Sprites
    vec2 sprUV;
    float sprAnimTime = time * 2.0;
    float sprRot = sin(sprAnimTime);
    float sprScale = 8.0;
    vec2 sprOff = vec2(sin(time * 0.5 + cos(time * 0.1) * 0.01) * 0.05, cos(time * 0.5) * 0.025 + sin(time * 0.1) * 0.01);
    
    // body
    float rot = radians(pow(sprRot, 4.0) * 12.0 * 0.1);
    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;
    //sprUV.y -= 0.75;
    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
    sprUV += 0.5;
    sprUV.y *= -1.0;
    sprUV.y += -0.6;
    colourRect = mixSpriteBody2(colourRect, sprUV);
    
    // body
    rot = radians(pow(sprRot, 3.0) * 12.0 * 0.3);
    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;
    //sprUV.y -= 0.75;
    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
    sprUV += 0.5;
    sprUV.y *= -1.0;
    sprUV.y += -0.65 + sin(sprAnimTime * 2.0) * 0.05;
    colourRect = mixSpriteBody1(colourRect, sprUV);
    
    // head
    rot = radians(sprRot * 12.0 * -0.5);
    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;
    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));
    sprUV += 0.5;
    sprUV.y *= -1.0;
    sprUV.y += sin(sprAnimTime * 2.0) * 0.1;
    colourRect = mixSpriteHead(colourRect, sprUV);
    
    // debug light
    //float lightCircleMix = smoothstep(0.01, -0.01, length(lightDelta.xy) - 0.01);
    //colourRect = mix(colourRect, vec3(0.0, 1.0, 1.0), lightCircleMix);
    
    // Draw commodore 64-esque screen
    // shadow
    vec2 centerDelta = uvsizeHalf - uv + vec2(0.025, -0.025);
    float rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);
    float rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));
    vec3 rect = mix(colourBG, colourBG * vec3(0.5), rectfactor);
    
    // screen
    centerDelta = uvsizeHalf - uv;
    rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);
    rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));
    rect = mix(rect, colourRect, rectfactor);
    
	return rect;
}

// Function 4330
float map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );
    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );
    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
        
    return res.x;
}

// Function 4331
bool intersectScene(Ray ray, float t_min, float t_max, out IntersectInfo rec)
{
        IntersectInfo temp_rec;

        bool hit_anything = false;
        float closest_so_far = t_max;

        for (int i = 0; i < sceneList.length(); i++)
        {
            Sphere sphere = sceneList[i];

            if (Sphere_hit(sphere, ray, t_min, closest_so_far, temp_rec))
            {
                hit_anything   = true;
                closest_so_far = temp_rec.t;
                rec            = temp_rec;
            }
        }

        return hit_anything;
}

// Function 4332
Intersection SceneIntersection(Ray r)
{
	Intersection iOut;
	
	Plane plane;
	plane.n = normalize(vec3(0,1,0));
	plane.d = -2.0;
	Intersection iPlane = RayPlane(r, plane);
	iPlane.diffuse = PlaneMaterial(iPlane);
	iPlane.specular = vec3(0.0);
	iOut = iPlane;
	
    vec3 pos = lm;
    Sphere sphere;
    sphere.c = pos;
    sphere.r = 2.0;
    Intersection iSphere = RaySphere(r, sphere);
    iSphere.diffuse = vec3(0.2);
    iSphere.specular = vec3(0.7);
    iOut = MinIntersection(iOut, iSphere);

	return iOut;
}

// Function 4333
vec3 bsdfSample(out vec3 wi, const in vec3 wo, const in vec3 X, const in vec3 Y,  out float pdf, const in SurfaceInteraction interaction, const in MaterialInfo material) {
    
    vec3 f = vec3(0.);
    pdf = 0.0;
	wi = vec3(0.);
    
    vec2 u = vec2(random(), random());
    float rnd = random();
	if( rnd <= 0.3333 ) {
       disneyDiffuseSample(wi, wo, pdf, u, interaction.normal, material);
    }
    else if( rnd >= 0.3333 && rnd < 0.6666 ) {
       disneyMicrofacetAnisoSample(wi, wo, X, Y, u, interaction, material);
    }
    else {
       disneyClearCoatSample(wi, wo, u, interaction, material);
    }
    f = bsdfEvaluate(wi, wo, X, Y, interaction, material);
    pdf = bsdfPdf(wi, wo, X, Y, interaction, material);
    if( pdf < EPSILON )
        return vec3(0.);
	return f;
}

// Function 4334
vec2 map( in vec3 pos, in float cuttingPlane ) {
	vec2 res = vec2(-interiorMap(pos).x, 2.0);
#if MARCH
    res = opD(res, vec2(-sdPlane(pos.xzx - cuttingPlane), 3.0));
#endif
    return res;
}

// Function 4335
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    const vec2 e = vec2(0.001, 0);
    float ref = bumpSurf3D(p);                 
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),
                      bumpSurf3D(p - e.yxy),
                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     
          
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 4336
float GetSceneTime()
{
    //return iTime;
    return 1.0;
}

// Function 4337
float get_distance(vec3 point) {
  return opU(opU(opU(Torus(point,vec2(0.9,0.1)),Sphere(point,0.8)),Box(rY(point,time),vec3(0.1,1.,0.1))),Torus(vec3(point.y,point.z,point.x),vec2(1.1,0.1)))+(texture(iChannel0,point.xy+vec2(sin(point.z*2.),0.)).r*0.03);
}

// Function 4338
float isoMap(vec3 p){
     
    p.xy -= path(p.z).xy; // Perturb the object around the camera path.
    
	p = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.
    
    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.

    // It's an easy field to create, but not so great to hone in one. The "1.4" fudge factor
    // is there to get a little extra distance... Obtained by trial and error.
    return (n - 1.);
    
}

// Function 4339
float sceneMap3D(vec3 pos, vec3 lightPos)
{
    float t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));
    t = min(t, sphere(pos, 2.0, greenSpherePos));
    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));
    return t;
}

// Function 4340
float distMod(float x, float y, float m){
    float d = mod(x-y,m);
    return min( abs(d) , abs(m-d) );
}

// Function 4341
vec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in vec2 uv)
{
    int toggle = int(floor(mod(iTime, 5.0)));
    Ray cameraRay = Ray(cameraPosition, cameraDirection);
       
    vec3 finalColor = vec3(0.0);

    IntersectionData intersection = Intersect(cameraRay);        
    if(intersection.mT < MAX_DISTANCE)
    {   
        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);
        vec3 normal = GetNormal(intersectionPoint);

        vec3 diffuse = vec3(1.0);
        if(intersection.mMaterial == CUBE)
        {
			diffuse = ParallaxMapping(intersectionPoint, normal, intersection.mT, toggle);
        }
        else if(intersection.mMaterial == GROUND)
        {
            diffuse = vec3(0.5) + mod(floor(0.001 * intersectionPoint.z) + floor(0.001 * intersectionPoint.x), 2.0) * 0.1;
        }
        finalColor = CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, 0.2);     
    }
    finalColor = mix(finalColor, vec3(0.85, 0.85, 1.0), 1.0 - exp(-intersection.mT * 0.015));

    
    float character = 0.0;
    if(toggle == 0)
    {
        DrawNone(character, uv);
    }
    else if(toggle == 1)
    {
        DrawNormal(character, uv);
        uv.x -= 0.5;
        DrawMapping(character, uv);
    }
    else if(toggle == 2)
    {
        DrawParallax(character, uv);
        uv.x -= 0.5;
        DrawMapping(character, uv);
    }
    else if(toggle == 3)
    {
        DrawSteep(character, uv);
        uv.x -= 0.5;
        DrawParallax(character, uv);
        uv.x -= 0.5;
        DrawMapping(character, uv);
    }
    else if(toggle == 4)
    {
        character += DrawCharacter(uv, 80); 
        character += DrawCharacter(uv, 79); 
        character += DrawCharacter(uv, 77);
    }
    return vec4(mix(finalColor, vec3(1.0), character), 1.0);
}

// Function 4342
float map(vec3 pos, out int type) {
  int parity;
  pos = fold(pos,parity);
  return scene(pos,parity,type);
}

// Function 4343
vec2 map(vec3 p) { 
  vec2 d = opU( vec2(groundDistance(p), 1.0), 
             vec2(postDistance(p), 2.0)) ; 
  d = opU(d, vec2(wireDistance(p), 3.0));
  return d;
}

// Function 4344
float point2rayDistSq(vec3 p, vec3 ray) {
    vec3 dd = p - dot(p, ray) / dot(ray, ray) * ray;
    return dot(dd, dd);
}

// Function 4345
bool intersectScene(Ray r, out Hit hit[2]) {
  Sphere s = Sphere(vec3(0),1.0);
  if (intersectSphere(s,r,hit)) {
    return true;
  }
  return false;
}

// Function 4346
float sdf_Q(vec2 uv)
{
    float dist = sdf_disk(uv, vec2(.5, .67), .32);
    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .735), .27));
    dist = sdf_union(dist, sdf_nail(uv, vec2(.5, .59), vec2(.09, .52)));
    return dist;
}

// Function 4347
vec3 map( vec3 pos )
{
pos /= 15.;
    float sid = 0.0;
    float dis;

    vec4 suvw;
    float info; 
    
    // floor

    //float mindist = pos.y;
//-----------------------------
	// terrain
	float h = terrain( pos.xz );
	float mindist = pos.y - h;

    float t = treeBase( pos.xz );
	float treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);
	suvw = vec4( 0.0, 0.0, 0.0, treeOcc );
       // columns
	vec2 tfc = fract( pos.xz+128.5 ) - 0.5;
	vec2 tdis2 = column( tfc.x, pos.y, tfc.y );
		
    if(tdis2.x<mindist )
    {
        mindist = tdis2.x;
        sid = tdis2.y;
    }
	


	// grass
	vec2 gd = grassDistr(pos.xz);
	float hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );
	float g = 0.2*hi * (gd.x * gd.y);
    mindist -= g;

    
    	//-----------------------------
	// trees
	{
	float chsca = 0.2;
	vec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );
	float y = chos.y;
	float r = length( chos.xz );
		
	float ss = exp(-40.0*y*y);
	float dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );
	float sh = 0.08 + (0.1+0.25*ss)*dd;
		
    dis = (r - sh)/chsca;
	if( dis<mindist )
	{
		mindist = dis;
		suvw.x = 1.0;
		suvw.y = y;
		suvw.z = smoothstep( 0.0, 1.0, dd );
		suvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);
		info = atan( chos.x, chos.z );
        sid = info;
	}		
		
	}
	
    
    // ceilin
	float x = fract( pos.x+128.0 ) - 0.5;
	float z = fract( pos.z+128.0 ) - 0.5;
    float y = 1.0 - pos.y;
	dis = -sqrt( y*y + min(x*x,z*z)) + 0.14;
	dis = max( dis, y );
    if( dis<mindist )
    {
        mindist = dis;
        sid = 1.0;
    }

   /*
   dis = MapBird(pos );
   if( dis<mindist )
    {
        mindist = dis  ;
        sid = pos.y ;
    }
   */
    
    // columns
	vec2 fc = fract( pos.xz+28.5 ) - 0.5;
    float nn = noise( fc );
    
	vec2 dis2 = column( fc.x  , pos.y, fc.y + nn );
		
    if( dis2.x<mindist )
    {
        mindist = dis2.x + .03*nn ;
        sid = dis2.y ;
    }
	
	//float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(6.0*pos.y)*sin(50.0*pos.x)*sin(4.0*6.2831*pos.z));
    //float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(12.0*pos.y)*sin(100.0*pos.x)*sin(8.0*6.2831*pos.z));
    float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(8.0*6.2831*pos.z));
	
    mindist -= dsp*0.03*0.25;

    return vec3(mindist*15.,sid,dsp);
}

// Function 4348
float sceneDist(vec3 p) {
	float planeDist = p.y;
    vec3 spherePos = vec3(0,1,8);
    float sphereRadius = 1.;
    
    float objDist = sphereDist(p-spherePos);
    
    float dist = min(planeDist, objDist);
    
    return dist;
}

// Function 4349
void initScene() {
    createLight(vec3(1.0, 1.0, 0.9), 8.0, vec3(0.0, 20.0, 0.0), vec2(40.0, 8.0), light);

    //Create materials
    //diff color, diff_tex, roughness, roughness_tex, weight, weight_tex, normal_map, tex_scale
    mtl[0] = createMaterial(vec3(0.2, 0.6, 0.3),  5, 0.015, -1, false, 0.0, -1, -1, 1.0);//fabric
    mtl[1] = createMaterial(vec3(1.0, 1.0, 1.0),  4, 0.000,  1, false, 0.3, -1, -1, 1.0);//cue
    mtl[2] = createMaterial(vec3(0.2, 0.5, 0.8), -1, 0.400, -1, false, 0.2, -1, -1, 1.0);//chalk
    mtl[3] = createMaterial(vec3(0.5, 0.3, 0.0), -1, 0.100, -1, false, 0.6, -1, -1, 1.0);//table wood
    mtl[4] = createMaterial(vec3(0.9, 0.9, 0.5), -1, 0.030, -1, false, 0.9, -1, -1, 1.0);//chalk metal head
}

// Function 4350
float floorDist(in Ray ray) {
    float dist = ray.origin.y;
    return dist;
}

// Function 4351
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.
    const vec2 e = vec2(0.001, 0); 
    
    // Gradient vector: vec3(df/dx, df/dy, df/dz);
    float ref = bumpSurf3D(p);
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),
                      bumpSurf3D(p - e.yxy),
                      bumpSurf3D(p - e.yyx)) - ref)/e.x; 
    
    /*
    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.
    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),
                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),
                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;
    */
       
    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind 
    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.
    grad -= nor*dot(nor, grad);          
         
    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.
    return normalize(nor + grad*bumpfactor);
	
}

// Function 4352
vec2 mapTerrain( vec3 p )
{
    float h = -2.5;
    h -= 1.5*sin( 5.0 + 0.2*p.z);
    h += 1.5*sin( 0.0 - 0.05*p.x - 0.05*p.z);
    float g = h;
    if( (p.y-h)<0.15 )
    h += 0.1*(textureLod( iChannel0, 0.1*p.xz, 0.0 ).x);

    float d1 = 0.2*(p.y-h);
        
    vec2 res = vec2( d1, 1.0 );
    
#if 1
    if( -p.z>11.0 )
    {
    float ss = 4.0;
    vec3 q = p;
    vec2 id = floor( (q.xz+0.5*ss)/ss );
    q.xz = mod( q.xz+0.5*ss, ss ) - 0.5*ss;
    

    float r1 = hash(121.11*id.x+id.y*117.4);
    float r2 = hash( 71.72*id.x+id.y* 61.9);
    float r3 = hash( 31.74*id.x+id.y*317.1);
    mat4 rm = matRotate( vec3(1.0*r1,313.13*r2,0.2) );
    
    vec3 r = (rm*vec4(q,0.0)).xyz;
    r.y -= g + 0.25;
    
    float d2 = 0.8*udRoundBox( r, vec3(2.,0.01+0.2*r3,0.1+0.5*r3), 0.002 );
    res.x = min( d1, d2 );
    }
#endif
        
    return res;
}

// Function 4353
result distanceField(vec3 p, float t)
{
	result res;
	res = bouncyBoi(p,t);
	res = compare(res, ghost(p,t));
	res = compare(res, world(p,t));
	return res;
}

// Function 4354
float Map2Box(in vec3 pos, in vec2 top_half_size, in vec2 bottom_half_size, in float half_h)
{//center at (0,0,0)
	float y = abs(pos.y) - half_h;
	float p = pos.y*0.5/half_h + 0.5;
	p = clamp(p, 0.0,1.0);//bottom---top
	float x = abs(pos.x) - mix(bottom_half_size.x, top_half_size.x, p);
	float z = abs(pos.z) - mix(bottom_half_size.y, top_half_size.y, p);
	
	if (x<0.0 || y <0.0 || z<0.0)
		return max(max(x, y), z);
	return sqrt(x*x + y*y + z*z);
}

// Function 4355
vec2 SDFscene(vec3 r)
{
	float t=999999.0;
    
    vec3 curpoint;
    curpoint.x=sin(iTime)*0.2;
    curpoint.y=-3.0+cos(iTime)*0.3;
    if (iTime<28.0) curpoint.z=13.4+iTime-(iTime*0.06);
    else curpoint.z=11.0+iTime;
    r=r-vec3(curpoint.x,curpoint.y+2.0,curpoint.z);

    t=sdPaperplane(r);

    if (t!=999999.0) return vec2(t,1.0);
    
    return vec2(-1.0);    
}

// Function 4356
vec2 stdNormalMap(in vec2 uv) 
{
    float height = texture(heightMap, uv).r;
    return -vec2(dFdx(height), dFdy(height)) * pixelToTexelRatio;
}

// Function 4357
float distCylR( vec3 p, float r, float h, float R )
{
  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );
  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;
}

// Function 4358
float signedDistanceBox(in vec2 p, in vec2 b) { return length(max((abs(p)-b),0.0)); }

// Function 4359
float PlaneSDF(vec3 eye, vec3 p, vec4 n)
{ // NOTE: n must be normalized
    return dot(eye-p, n.xyz) + n.w;
}

// Function 4360
float hexSDF(vec2 st) { // 27
    st = abs(st * 2. - 1.);
    return max(abs(st.y), st.x * 0.866025 + st.y * .5);
}

// Function 4361
float dist(vec3 p) { 
    float lmin=min(FRes.x,min(FRes.y,FRes.z));
    #ifdef CUT_MIDDLE
    float dbox=sdBox(p-distPos(FRes*.25)*vec3(1,0,0),FRes/lmin*.99*vec3(.5,1,1));
    #else
    float dbox=sdBox(p,FRes/lmin*.99);
    #endif
    float d=1000.;
    //if(box_enable) return dbox;
    if(box_enable) return box_neg?-dbox:dbox;
    //float v=length(getVal((p*.5+.5)*FRes));
    float v=length(getVal(fluidPos(p)));
    float v0=v;
    #ifdef VELOCITY_VAL
    v=abs(v-VELOCITY_VAL);
    d=min(d,v*.1/length(getVelGrad(p,1./dot(FRes,vec3(.333)))));
    #else
    v=abs(fract(v/.5)*.5-.25);
    //d=min(d,v/v0*.1);
    d=min(d,v*.1/length(getVelGrad(p,1./dot(FRes,vec3(.333)))));
    #endif
    //if(!box_enable) d=min(d,-dbox+.01);
#ifdef OBSTACLE
#ifdef RENDER_OBSTACLE
    d=min(d,obstacleDist(p));
#endif
#endif
    d=max(d,dbox);
    return d;
}

// Function 4362
float sphereSDF(vec3 p, Sphere sphere) {
    float dSphere = length(p - sphere.position.xyz) - sphere.radius;
    return dSphere;
}

// Function 4363
float GetDist(vec3 p) {

	vec4 sphere = vec4(0,sin(iTime)+1.,0,.5);
    float distanceToSphere = length(p-sphere.xyz)-sphere.w;
    
    vec3 torusLoc = vec3(0,sin(iTime),0);
    vec2 test = vec2(1.,.1);
    float distToOcta = sdTorus(p+torusLoc,test);
    

    float distanceToPlane = p.y;
    
    float totalDistance = smin(distanceToSphere, distanceToPlane, 0.4);
    totalDistance = smin(totalDistance, distToOcta, 0.4);
    return totalDistance;
    
}

// Function 4364
float map(vec3 p)
{
    return DE(p);
}

// Function 4365
float map(in vec3 tex){ return 6.*tex.r*tex.r; }

// Function 4366
poly2 pa_map(poly2 x, poly2 y, poly2 z) {
#if 0
	poly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));
    poly2 vz = pa_sub(z,sin(anim_time*0.3)*0.4);
	poly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);
	poly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);
	//poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);
    poly2 rx, rz;
    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,anim_time*0.5);
    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));
    poly2 cb = cube(rx,y,pa_add(rz,-0.5),0.2);

    poly2 d = pa_hardmax(s,pa_unm(s2));
    d = pa_hardmin(d,w);
    d = pa_hardmin(d, c);
    d = pa_hardmin(d, cb);
#else
    float a = iTime;//.5;
    rotate(x,y,x,y,a*0.79);//anim_time*0.5);
    //rotate(y,z,y,z,a*0.49);//anim_time*0.5);
    rotate(x,z,x,z,a*0.69);

    //poly2 d = ellipsoid(x,y,z, vec3(0.5,0.4,0.3));
    //poly2 d = ellipsoid(x,y,z, vec3(0.5,0.45,0.2));
    poly2 d = quadric(x,y,z, vec3(1.0/0.5,1.0/0.45,1.0/0.2), 1.0);
    //poly2 d = plane(x,y,z, vec4(0.0,0.0,1.0,-0.6));
    //poly2 d = cube(x,y,z,0.5);
    //poly2 d = sphere(x,y,z, 0.5);
#endif
	return d;
}

// Function 4367
float TonemapFloat( float x )
{
	return 1.0f - exp( -x ); // can change the tonemap function here 
}

// Function 4368
float map(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec2 uv = p.xz; uv.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_GEOMETRY; i++) {
        d = sea_octave((uv+SEA_TIME)*freq + 2. * Clubber.r,choppy);
    	d += sea_octave((uv-SEA_TIME)*freq + 2. * Clubber.g,choppy);
        h += d * amp;        
    	uv *= octave_m ; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 4369
float heightMap(vec3 rad,float d)
{
    float iline=1.0/(1.0-line);
    float a=noise3(rad*1.6)*0.885;
    float na=a;
    if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;
    if (abs(d-a)<0.2) {
        na+=noise3(rad*8.0)*0.1;
        a=na;
        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;
    }
    if (abs(d-a)<0.02) {
        na+=noise3(rad*32.0)*0.01;
        a=na;
        if (a>line) a=pow((a-line)*iline,1.8)*(1.0-line)+line;
    }
    if (abs(d-a)<0.01) a+=noise3(rad*128.0)*0.005;
    return a;
}

// Function 4370
float Map(vec3 p)
{
	float h = FBM(p);
	return h-cloudy-.42;
}

// Function 4371
Model map(vec3 p) {

    float part, d, t1, t2, t3, t4;
    float lead = guiLead;
    float innerRatio = guiInnerRatio;
    vec2 uv1, uv2, uv3;

    p /= guiModelScale;

    vec3 pp = p;

    d = 1e12;

    float s = mix(.5, 0., innerRatio);

    float scale = 1./pow(1./s, time);

    pR(p.xy, PI * -.5 * time + guiRotateModel * PI * 2.);
    
    p *= scale;
    p.z += .5;

    scale *= pModHelixUnwrap(p, lead, innerRatio, time);
    p.x *= -1.;
    scale *= pModHelixScale(p, lead, innerRatio);
    p.x *= -1.;

    #ifdef ANOTHER_LEVEL
        scale *= pModHelixScale(p, lead, innerRatio);
        p.x *= -1.;
    #endif

    d = min(d, length(p.yz) - .5);
    d /= scale;

    unzipHelixModel(d, scale, p, lead, innerRatio, -1., 1.);
    unzipHelixModel(d, scale, p, lead, innerRatio, 0., -1.);
    unzipHelixModel(d, scale, p, lead, innerRatio, 1., 1.);

    d *= guiModelScale;

    return Model(d, vec3(0), 1);
}

// Function 4372
float map(vec3 p){
    //if ( iMouse.z > 0. ) {density=iMouse.x/iResolution.x * RUGOSITY_DENSITY_MAX;}
	
    float rugosity = cos(density*p.x)*sin(density*p.y)*sin(density*p.z)*cos(256.1)*sin(0.8);
	
    float disp = length(vec4(voronoiSphereMapping(normalize(p)),1.))*0.4-0.8;
    
    return length(p)-1.6-disp-rugosity;
}

// Function 4373
float dist_field( vec3 p ) {
//  p = sdRep( p, vec3( 4.0 ) );
//  p = sdTwist( p, 3.0 );
    
    float d0 = sdBox( p, vec3(0.5) );
    float d1 = sdSphere( p, 0.6 );
    
    float d = sdInter( d1, d0 );

    return d;
    //return d + sfDisp( p * 2.5 );
    //return sdUnion_s( d + sfDisp( p * 2.5 * sin( iTime * 1.01 ) ), d1, 0.1 );
}

// Function 4374
vec3 envMap(vec3 rd){
    
  
    float c = n3D(rd*4.)*.66 + n3D(rd*8.)*.34; // Noise value.
    c = smoothstep(.3, 1., c); // Darken and add contast for more of a spotlight look.
    
    return vec3(c*c*c, c*c, c); // Simple, cool coloring.
    
}

// Function 4375
float map( vec3 p )
{
    p.xz *= 0.8;
    p.xyz += 1.000*sin(  2.0*p.yzx );
    p.xyz -= 0.500*sin(  4.0*p.yzx );
    float d = length( p.xyz ) - 1.5;
	return d * 0.25;
}

// Function 4376
float triangleDist(vec2 p, float width, float height)
{
  vec2 n = normalize(vec2(height, width / 2.0));
  return max(	abs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);
}

// Function 4377
float polygonDistanceField(in vec2 pixelPos, in int N) {
    // N = number of corners
    float a = atan(pixelPos.y, pixelPos.x) + PI/2.; // angle
    float r = TWO_PI/float(N); // ~?
    // shapping function that modulates the distances
    float distanceField = cos(floor(0.5 + a/r) * r - a) * length(pixelPos);
    return distanceField;
}

// Function 4378
float sceneSDF1(vec3 p) {
    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;
    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));
}

// Function 4379
vec2 sdf(vec3 p) {
    // A hack: for efficiency, we only evaluate piece distance for the piece
    // in the current square. If there is no piece in the current square then
    // we return INF distance as a lower-bound distance to pieces in adjacent squares
    // without needing to evaluate them.
    const float INF = 1.0;

    float r = min(INF, p.y + 4.0);
    vec2 res = vec2(r, BOARD_MAT);

    // Discretize coordinates onto board.
    vec2 ip = p.xz / 8.0 + 4.0;
    int ix = int(ip.x) & 7;
    int iy = int(ip.y) & 7;
    int piece = (board_cache[7 - iy] >> (ix * 4)) & 0xF;
    if (piece == 0)
        return vec2(min(res.x, INF), res.y);
    
    vec2 pp2 = mod(p.xz, 8.0) - 4.0;
    vec3 pp3 = vec3(pp2.x, p.y, pp2.y);
    float is_white = piece < 7 ? 1.0 : 0.0;
    piece = (piece - 1) % 6;
    pp3.z *= (is_white * 2.0 - 1.0); // black knight are flipped on z-axis
    
    float d_piece;
    if (piece == 0)
        d_piece = pawn(pp3);
    else if (piece == 1)
        d_piece = rook(pp3, base1(pp3));
    else if (piece == 2)
        d_piece = knight(pp3, base1(pp3));
    else if (piece == 3)
        d_piece = bishop(pp3, base1(pp3));
    else if (piece == 4)
        d_piece = king(pp3, base2(pp3));
    else
        d_piece = queen(pp3, base2(pp3));

    float bound = max(abs(p.x) - 32.0, abs(p.z) - 32.0);
    r = max(bound, d_piece);

    if (r < res.x)
        res = vec2(r, BLACK_MAT - is_white);
    
    return res;
}

// Function 4380
void RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)
{
    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));
    
    float rayDistance = c_minimumRayHitTime;
    float lastRayDistance = c_minimumRayHitTime;
    
    float lastHitInfoDist = 0.0f;
    
    SRayHitInfo newHitInfo = oldHitInfo;
    newHitInfo.hitAnObject = false;
    
    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)
    {
        vec3 rayPos = startingRayPos + rayDistance * rayDir;
        
        newHitInfo = TestSceneMarch(rayPos);
        
        // these two lines are so that the material code goes away when the test functions are inlines
        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);
        newHitInfo.material = dummyMaterial;
        
        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;
        if (newHitInfo.hitAnObject)
            break;
        
        lastRayDistance = rayDistance;
        rayDistance += max(newHitInfo.dist, c_minStepDistance);

        lastHitInfoDist = newHitInfo.dist;
        
        if (rayDistance > oldHitInfo.dist)
            break;
    }
    
    if (newHitInfo.hitAnObject)
    {
		float refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);
        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);
        
        if (newHitInfo.dist < oldHitInfo.dist)
            oldHitInfo = newHitInfo;
    }
}

// Function 4381
float sdf_v(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(2, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(2, -8, 0)));
    return t;
}

// Function 4382
float remap01(float minInput, float maxInput, float domain)
{
    return clamp( (domain - minInput) / (maxInput - minInput), 0., 1.); 
}

// Function 4383
vec3 sceneEmittance(highp int idx)
{
    return vec3(0.0);
}

// Function 4384
Shape map(vec3 c){
  Shape enviro = environment(c);
  return enviro;
}

// Function 4385
float augenMap(vec3 p, float alle){

float PosX, PosY;
    //PosX = 3.14;// - iMouse.x/iResolution.x*8. + 1.5;//0.2*2.*(rechts - links);
    //PosY = -0.3;// - iMouse.y/iResolution.y*8. + 1.5;
    
    //p.z+=1.;

    //float alle = 100.;
	p*=0.8;
    //p.y-=0.2;
//gluende augen
    vec3 sp = p;
    //sp.x = abs(sp.x) -1.2;
    float augen = length(sp - vec3(-1.2, 0.2, 5.94)) - 0.1;
    alle = min(alle, augen);
    if(min(augen, alle) == augen){
        glow2 += abs(max(0.0001,(0.00005/(0.005*pow((augen),1.)))));//* (.5-augen*1.5);
    }
    
    //snake eye
    sp=p+vec3(1.3, -0.41, .51);
    sp.x = abs(sp.x)-0.15;
    float tmp = length(sp)-0.001;
    if(min(tmp,alle) == tmp){
    //glow2 += abs(max(0.0001,(0.00005/(0.005*pow((tmp),1.)))))/4.;//* (.5-augen*1.5);
    
    }
    alle = min(alle, tmp);
    
    return alle;
}

// Function 4386
float map(vec3 p)
{
	float d = length(p.xy) - 1.0;
    
    return -d;
}

// Function 4387
float map(vec3 p){
    
    objID = 0.;
    
    #ifdef OBJECT_CAMERA_WRAP
    // Wrap the scene around the path. Optional. See the bump mapping function also.    
    p.xy -= camPath(p.z).xy;
    #else   
    p.x += 4.;
    #endif
    
    float d = lattice(p);

     
    return d*.95;//*.7;
}

// Function 4388
float DistCombineUnion( const in float v1, const in float v2 )
{
	//if(v1.x < v2.x) return v1; else return v2;
	return mix(v1, v2, step(v2, v1));
}

// Function 4389
float sdf_nail_v2(vec2 uv, vec2 top, vec2 size)
{
    const float
        head_flat_frac = .1,
    	head_round_frac = .1,
    	body_thickness = .5;

    float h = clamp((top.y - uv.y) / size.y, 0., 1.);
    float w = (h < head_flat_frac) ? 1. :
        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :
    	h > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;
    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));
}

// Function 4390
vec2 map(vec3 _p)
{
	vec2 d0 = vec2(100000.,0.);
    vec2 d = d0;
	
    vec2 sphere1 = vec2(sphere(_p,vec3(.0,0.,.0),.6),.5);
    vec2 sphere2 = vec2(sphere(_p,vec3(sn,-.5,cn),.8),.8);
    vec2 sphere3 = vec2(sphere(_p,vec3(-sn,-.5,-cn),.8),.8);
    vec2 plane1 = vec2(plane(_p,-1.),MAT_PLANE);
    vec2 light1 = vec2(sphere(_p,KL.p/30.,.1),MAT_KEYLIGHT);
    vec2 light2 = vec2(sphere(_p,FL.p/30.,.1),MAT_KEYLIGHT);
    
	d = opU(sphere2,sphere3);
	d = opI(d,sphere1);
    d = opU(d,plane1);
    
    // lights
    //d = opU(d,light1);
    //d = opU(d,light2);
    
    #ifdef debug_sphere
    d = opU(d0,sphere1);
    d = opU(d,plane1);
    #endif
    
	return d;	
}

// Function 4391
vec3 GetSceneColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, out float sceneDist )
{
    vec3 result = vec3(0);

    float wetDiffuseFactor = 0.5;
    
    int waterOctaves = 3;
    MapTraceResult mapTrace = Map_Trace( rayOrigin, rayDir, waterOctaves, false );
    
    if ( mapTrace.dist < 0.0 )
    {        
        result.rgb = GetSkyColour( env, rayOrigin, rayDir, 0.0f, true );
        sceneDist = 10000.0;
    }
    else
    if ( mapTrace.dist >= 0.0 )
    {        
        sceneDist = mapTrace.dist;
        
        vec3 hitPos = rayOrigin + rayDir * mapTrace.dist;
        vec3 normal = Map_GetNormal( hitPos );
                

        float vR0 = 0.02f;
        
        float roughness = 0.0002f;

        vec3 albedo = vec3(1);
        float transparency = 1.0f;
        vec3 colTransmitted = vec3(0);
        
        if ( mapTrace.objectId == 1 )
        {
            vec3 waterExtinction = GetExtinction( hitPos.xz );
            {
                
                float terrainHeight = Terrain_GetHeight( iChannelRockTexture, hitPos.xz, false, true );
                
                float water_terrain_dh = hitPos.y - terrainHeight;
                
                float foamAmount = clamp( 1.0 - water_terrain_dh * (1.0f / 0.5f), 0.0f, 1.0f );
                foamAmount = foamAmount * foamAmount;
                
				float waveFactor = GetShorelineWaves( hitPos.xz, water_terrain_dh ).y;
                
                foamAmount = max( foamAmount, waveFactor );

                vec2 foamMapUV = hitPos.xz; //mix(hitPos.xz, refractHitPos.xz, 0.25);
                foamMapUV = foamMapUV * 20.0 + water_terrain_dh * 100.0;
                
                
	            //normal.xz += (SmoothNoise2( foamMapUV * 2.0) * 2.0f - 1.0f) * foamAmount * 0.2;
                //normal = normalize( normal );
                
	            vec3 rayRefracted = refract( rayDir, normal, 1.0f / 1.3333f );
                
                
                
                MapTraceResult refractTrace = Map_Trace( hitPos, rayRefracted, 0, false );
                vec3 refractHitPos = hitPos + rayRefracted * refractTrace.dist;
                
                float dh = refractHitPos.y - hitPos.y;

                vec3 diffuseCol = GetSandCol( refractHitPos, (log( refractTrace.dist )+1.) * 4.0).rgb;
                
                diffuseCol *= wetDiffuseFactor;

                vec3 seabedLighting = WaterCaustics( env, refractHitPos );
                
                float seabedNdotL = env.sunDir.y;
                vec3 diffuseLight  = seabedNdotL * seabedLighting * exp( (-dh / -env.sunDir.y) * waterExtinction );
                
                diffuseLight += env.ambientCol * exp( dh * waterExtinction );
                                
                colTransmitted = diffuseLight * diffuseCol;
                
                vec3 extinction = exp( (-refractTrace.dist ) * waterExtinction );

                
                colTransmitted *= extinction;  

                {
                    float inscatterFactor = clamp( 1.0 - rayRefracted.y, 0.0f, 1.0f );

                    //vec3 inscatterScale =  exp( -inscatterFactor * waterExtinction * inscatterScaleFactor );

                    float lookupU = atan(rayRefracted.x, rayRefracted.z);
                             

                    float lookupV = clamp( -rayRefracted.y, 0.0f, 1.0f);
                    vec3 inscatterScale = GetInscatter( env, lookupU, lookupV, waterExtinction );
					colTransmitted += inscatterScale;
                }
            //}
            
				//colTransmitted *= RadianceChange( IOR_AIR, IOR_WATER );                
	            //colTransmitted *= RadianceChange( IOR_WATER, IOR_AIR );
                
            //{

                
                //float foam = SmoothNoise2( foamMapUV ).x;
                vec2 foamSampleUV = foamMapUV * 0.005 + iTime * 0.1;
                vec4 foamSample = texture( iChannel1, foamSampleUV, 0.0 );
                float foam = foamSample.x;
                
                
                foam = 1.f - foam;
                foam = 1.f - foam* foam;
                
                float foamFactor = foamAmount * 0.8f;
                
                foamFactor = max( 0.0, foamFactor - foam * (1.0f - foamFactor));
                
                //foamFactor *= 0.25 + 0.75 * SmoothNoise2( hitPos.xz * 10000.0 ).x;
                                
                float foamThicknessFactor = 1.0;
                //if ( abs( dh ) < 0.02 ) { foamThicknessFactor = 0.5; }
                
                // foam shadow
                colTransmitted *= 1.0 - foamFactor * foamThicknessFactor;
                
                // foam bubbles
                //colTransmitted += diffuseLight * exp( -foamAmount * waterExtinction * 10.0 ) * foamSample.b * 0.2;
                
                //albedo = vec3( SmoothNoise2( hitPos.xz * 10000.0 ).x * 0.5 + 0.5 );
                albedo = vec3( 1.0f );
                
                normal.x += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0.2, 0), 0.0 ).x) * foamFactor * 0.4;
                normal.z += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0, 0.2), 0.0 ).x) * foamFactor * 0.4;
                normal = normalize( normal );
                
                
                transparency = 1.0 - foamFactor * foamThicknessFactor;                                
                roughness = mix( roughness, 0.3f, foamFactor * foamFactor );                
            }            
        }
        else
        {
            vec3 mapPos = rayOrigin + rayDir * mapTrace.dist;
            
            vec4 sandColSample = GetSandCol( mapPos, 0.0f );
            albedo = sandColSample.rgb;
            transparency = 0.0f;
            
            float wetness = 0.0f;
            
            vec2 noiseLow = SmoothNoise22(mapPos.xz * 0.2);

            roughness = 1.0f - sandColSample.a * (0.5 + sandColSample.r * 0.5);
            
            //float roughnessHeight = smoothstep( 2.0, 1.2, mapPos.y );            
            //roughness = mix( roughness, noiseLow.y * 0.08, roughnessHeight );
            
#if 1
            
            
            //float wetRoughness = mix( 2.0f, 1.2f, noiseLow.x );
            float wetnessHeightFactor = smoothstep( 1.5, 0.6, mapPos.y );
            float wetnessHeight = mix( wetness, 0.8+noiseLow.x * 0.2, wetnessHeightFactor);
            
            wetness = max( wetness, wetnessHeight );
                        
                        
                                                
#endif      
            
	        float waterOldHeight = Water_GetHeight(mapPos.xz, 2, iTime - 0.05 );                        
            float wetnessShorline = smoothstep( 0.4, 0.0, mapPos.y - waterOldHeight);
            
            wetnessShorline *= 1.0;
                
            wetness = max( wetness, wetnessShorline );
            
            
            roughness = mix ( roughness, 0.001, wetness );            
            albedo *= (1.0 - wetness ) * (1.0f - wetDiffuseFactor) + wetDiffuseFactor;
            
            //albedo = clamp( albedo + max(0.0f, wetnessShorline - 0.9), 0.0, 1.0); // attempt to hack persistent foam
        }

        vec3 h = normalize( -rayDir + env.sunDir );
        float NdotL = max( 0.0f, dot( normal, env.sunDir ) );
        float NdotH = dot( h, normal );
        float NdotV = dot( rayDir, normal );
               
        vec3 diffuseIntensity = (NdotL * env.sunLightCol + env.ambientCol) * albedo;

        colTransmitted = mix( diffuseIntensity, colTransmitted, transparency );
        
        roughness = roughness * 0.995 + 0.005;
        
        float gloss = (1.0f - roughness);
        float glossFactor = pow( gloss, 20.0 );
        
        vec3 rayReflected = reflect( rayDir, normal );
        
        vec3 colReflected = GetSkyColour( env, hitPos, rayReflected, glossFactor * 16.0, false );
        
        {
			float alpha = roughness;
            float alphaSqr = alpha * alpha;
            float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0f;
            float k = alpha / 2.0;
            float vis = GIV(NdotL, k) * GIV(NdotV, k);
            float f = alphaSqr / (PI * denom * denom);
            colReflected += f * NdotL * env.sunLightCol;
        }
        
        
        {
            float NdotV = max( 0.0, dot( rayDir, -normal ) );

            vec3 fresnel = vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * glossFactor;

            result.rgb = mix( colTransmitted, colReflected, fresnel );
        }            
        
    
        float dist = mapTrace.dist;
        float fogFactor = 1.0 - exp( dist * -env.fogDensity );
        result.rgb = mix ( result.rgb, env.fogCol, fogFactor );
	}

    vec3 sunGlow = GetSunGlow( env, rayDir );
    result.rgb += sunGlow;

    return result;
}

// Function 4392
float map(vec3 p){
    
    
    // Reflecting the wall opposite to give the light something to relect off of.
    //p.y =  abs(p.y - .25) - .75;
    
    // Wall behind the pylons to stop the light getting through.
    vec3 q = p;
    
    q.yz *= rot2(3.14159/4.);
    q.xy *= rot2(-3.14159/5.);
    float wall = 1e5;//q.y - .7071 + .1;//abs(q.y - .7017 + 1.) - 1.;//1.5*.7071;
    
 
    // Blocks.
    vec4 d4 = blocks(p);
    gID = d4.yzw; // Individual block ID.
    
    
    // Move and render the die.
    
    // Initial point.
    q = p - gOff- lTotDist*GSCALE.x; 
    // Bounce.
    q.y -= gBounce;
    // Pivot about the pivot point.
    q -= lPivot;
    // Depending on direction rotate around the XY plane or the YZ one.
    if(abs(dirI.x)>.5) q.xy = lRot*q.xy;
    else q.yz = lRot*q.yz;
    // Pivot back.
    q += lPivot;
 
    // Factor in the total rotation for each direction.
    q.xy = rot2(mod(lTotDist.x, 2.)*PI)*q.xy;
    q.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*q.yz;

    // Keep a global texture copy for texturing later. 
    gTxP = q; 
    
    // Render the smooth edged rounded cube.
    float bx = sBox(q, vec3(GSCALE.x/2.), .07);
    bx = smax(bx, length(q) - GSCALE.x/2.*1.55, .1);
    
 
    // Overall object ID.
    objID = (wall<d4.x && wall<bx)? 2 : d4.x<bx? 0 : 1;
    
    // Combining the wall with the extruded blocks.
    return min(wall, min(d4.x, bx));
 
}

// Function 4393
float distField( vec3 pos ) {
	// ...add objects here...
	

	float d0 =  udRoundBox(pos, size, 0.2);
	

	float d1 = sdSphere(pos, 2.0);
		
	// union     : min( d0,  d1 )
	// intersect : max( d0,  d1 )
	// subtract  : max( d1, -d0 )
	//return max( -d1, d0 );

	return max( d0,  -d1 );
}

// Function 4394
float distfunc(vec3 pos)
{
    vec3 t = repeatTime(vec3(0.4,0.0,0.0));
    float s1 = sin(t.x)*0.5+0.5;
    float s2 = sin(t.x - 0.4)*0.5+0.5 + 0.2;
    
    float attenuationY = 1.0 - clamp(pos.y*0.25,0.0,1.0);
    float attenuationXZ = 1.0 - clamp(length(pos.xz*0.05),0.0,1.0);
    
    vec3 n1 = noise(pos, vec3(1.4,1.5,1.25), vec3(0.0,1.0,2.0), vec3(0.2,0.5,0.1));
	float n2 = sin(length(pos.xz) - iTime*7.0);
    vec3 nGround = (n2+n1*0.1)*attenuationXZ*(1.0 - s2);
    vec3 nObj = n1*0.2*(1.0 - s2)*attenuationY - vec3(0.0,s1*6.0 - 3.0,0.0);
    
    float ground = infinitePlane(pos+nGround, 0.0);
    vec3 rotPos = rotationY(pos, iTime);
    float box1 = box(rotPos + nObj, vec3(1.5,1.5,1.5));
    float box2 = box(rotPos + nObj, vec3(1.75,1.0,1.0));
    float box3 = box(rotPos + nObj, vec3(1.0,1.0,1.75)); 
    float box4 = min(box1, min(box2, box3));
    float sphere1 = sphere(pos + nObj, 3.0);
	return smin(ground, mix(sphere1, box4, s1*0.9), 1.0);
}

// Function 4395
float boxDist(vec2 p, vec4 b) {
    
    p = abs(p - b.xy) - b.zw;
    return max(p.x, p.y);
    
}

// Function 4396
void sceneChecker(vec2 uv, out vec3 params)
{
	for(int I=0;I<20;I++){
		float z=float(I)-fract(iBeat);
		vec2 d=checker_checkerboard(checker_uvs(uv,z));
		if(d.y>.5)
		{
			params=vec3(fract((float(I)+floor(iBeat))/5.),rangeRainbow);
			return;
		}
	}
	params = vec3(0, rangeBlack);
}

// Function 4397
float semiCircleDist(vec2 p, float radius, float angle, float width)
{
	width /= 2.0;
	radius -= width;
	return substract(pie(p, angle), 
					 abs(circleDist(p, radius)) - width);
}

// Function 4398
float map_terrain(vec3 p)
{
    return p.y+fbm_hash(p.xz*1.0)*2.0;//cos((p.x+p.z))*0.5+sin((0.5+p.z))*0.5;
}

// Function 4399
void mainCubemap( out vec4 fragColour, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    fragColour = textureLod( iChannel0, rayDir, 0. ); // this needs NEAREST filter on the texture
	if ( iFrame == 0 ) fragColour = vec4(0);

    // wait for texture to load (I know the top of the cubemap should not be black)
    if ( textureLod( iChannel1, vec3(0,1,0), 0. ).r == 0. ) return;
    
    // early-out once we've got a good enough result
    if ( fragColour.a > 16.*60.*3. ) return;
    
    const int n = 16;
    for ( int i = 0; i < n; i++ )
    {
        vec3 ray = HemisphereRand(rayDir,uint(i+n*iFrame));

        fragColour.rgb += LDRtoHDR(textureLod( iChannel1, ray, 0. ).rgb);
        fragColour.a += 1.;
    }
}

// Function 4400
vec4 mapDistanceColor(const in vec3 point) {
  vec4 tmpPrim_97 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);
vec4 tmpPrim_98 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), 0.4) * 1.0, vec3(0.5,0.5,1.0));
vec4 tmpComb_241 = opUnionRound(tmpPrim_97, tmpPrim_98, 1.0);
vec4 tmpPrim_99 = vec4(sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec4(0.2,0.4,0.8,0.1)) * 1.0, vec3(0.5,0.5,1.0));
vec4 tmpComb_242 = tmpComb_241;
vec4 tmpComb_243 = opUnionRound(tmpComb_242, tmpPrim_99, 1.0);
vec4 tmpPrim_100 = vec4(sdTorus(pMod((mat4(0.4235779345035553,0.0,0.0,0.0,0.0,0.4235779345035553,0.0,0.0,0.0,0.0,0.4235779345035553,0.0,0.0,-0.18355792760849,-0.6719846725463867,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(0.4,0.05)) * 2.3608405590057373, vec3(0.5,0.5,1.0));
vec4 tmpComb_244 = tmpComb_243;
vec4 tmpComb_245 = opUnionRound(tmpComb_244, tmpPrim_100, 1.0);
vec4 tmpPrim_101 = vec4(sdBox(pMod((mat4(0.05644333362579346,0.017791423946619034,-0.998214066028595,0.0,-0.025665316730737686,0.9995034337043762,0.016363179311156273,0.0,0.9980428218841553,0.02469668537378311,0.05687381699681282,0.0,0.10439714044332504,-1.5119545459747314,-0.07225281745195389,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec4(0.2,0.4,0.8,0.1)) * 1.000033005974318, vec3(0.5,0.5,1.0));
vec4 tmpComb_246 = tmpComb_245;
vec4 tmpComb_247 = opUnionRound(tmpComb_246, tmpPrim_101, 1.0);
vec4 tmpPrim_102 = vec4(sdEllipsoid(pMod((mat4(17.42844581604004,0.0,0.0,0.0,0.0,-0.573193371295929,-17.419015884399414,0.0,0.0,17.419015884399414,-0.573193371295929,0.0,0.0,-26.98288345336914,-12.640543937683105,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.2,0.4,0.8)) * 0.057377465069293976, vec3(0.5,0.5,1.0));
vec4 tmpComb_248 = tmpComb_247;
vec4 tmpComb_249 = opUnionStairs(tmpComb_248, tmpPrim_102, vec2(0.79,3.0));
return tmpComb_249;
}

// Function 4401
SceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist, int insideObjId )
{	
    SceneResult result;
    result.fDist = 0.0;
    result.vUVW = vec3(0.0);
    result.iObjectId = -1;
    
	float t = minDist;
	const int kRaymarchMaxIter = 128;
	for(int i=0; i<NO_UNROLL(kRaymarchMaxIter); i++)
	{		
        float epsilon = 0.0001 * t;
		result = Scene_GetDistance( vRayOrigin + vRayDir * t, insideObjId );
        if ( abs(result.fDist) < epsilon )
		{
			break;
		}
                        
        if ( t > maxDist )
        {
            result.iObjectId = -1;
	        t = maxDist;
            break;
        }       
        
        if ( result.fDist > 1.0 )
        {
            result.iObjectId = -1;            
        }    
        
        t += result.fDist;        
	}
    
    result.fDist = t;

    return result;
}

// Function 4402
float dist(vec2 p, float rnd){
    
    
    #ifdef LEAFY
    // Leaves.
    
    	p = rot2(6.2831*rnd + fract(rnd*57. + .37)*iTime/2.)*p;
    
        #if 1
        // Leaf 1.
        float r = length(p) + sqrt(abs(p.x/8.));
        #else
        // Leaf 2.
        float r = pow(dot(pow(abs(p), vec2(2.)), vec2(1)), 1./2.) + abs(p.x);
        #endif
        return r/1.4142 - .0;
    #else 
    // Bubbles -- Much simpler. :)
        return length(p);

    #endif
    
}

// Function 4403
Object mapG(vec3 p){
    Object o = NewObject;

	o.d = 10e6;

    o.material = 2.;
    float octa = 10e7;
    float sc = 1.;
    float sep = 1.3;
    
    vec3 q = p;
    float rhomb= coolCahedron(q,S*sc);
    
    
    float dBalls = 10e7;
    
    float dXtal = 10e7;
    
    float reps = 4.;
    pmodpol(p.xy,reps);
    pmodpol(p.yz,reps);
    pmodpol(p.xz,reps);
    p *= 0.65;
    
    for(float i = 0.; i < 4. + min(float(iFrame),0.); i++){
        
        sc = pow(0.54, i+1.);
        if(mod(i+2.,2.) > 0.){
            float db = length(p)-0.4*sc;
            if(db< dBalls){
            	dBalls = db;
                materials[3].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;
                materials[3].albedo = max(materials[3].albedo,0.);
                
            }
        }
        
        float sepi = sep*sc;
        p=abs(p);
        p.x -= sepi;
        vec3 v = p;
    	octa= min(octa,coolCahedron(p,S*sc));
        
        if(mod(i+3.,2.) < 1.){
            float db = sdOctahedron(p,S*sc*0.9);
            if(db< dXtal){
            	dXtal = db;
                materials[4].albedo = 0.5 + sin(vec3(1.,0.5,0.1)+i+2.)/2.;
            }
        }
        
        p.x += sepi;
        p.y -= sepi;
        
        vec3 b = p;
    	octa= min(octa,coolCahedron(p,S*sc));
        
        if(mod(i+3.,2.) < 1.){
            float db = sdOctahedron(p,S*sc*0.9);
            if(db< dXtal){
            	dXtal = db;
            }
        }
        
        p.y += sepi;
        p.z -= sepi;
    	octa= min(octa,coolCahedron(p,S*sc));

        if(mod(i+3.,2.) < 1.){
            float db = sdOctahedron(p,S*sc*0.9);
            vec3 q = abs(p);
            if(i<3.){
                q.xz *= rot(0.25*pi);
                q.xy *= rot(0.25*pi);
                vec3 bSz = vec3(S*sc*0.9);
                bSz.x *= 0.05;
                bSz.y *= 100.;
                bSz.z *= 0.05;
                db = min(db,sdBox(q,bSz));
            
            }
            if(db< dXtal){
                dXtal = db;
            }
        }	
    }
    

    
    o.d = min(o.d,octa);
    
    o = omin(o,dBalls, 3.);
    
    return o;
}

// Function 4404
float map(vec3 p0) { 
    
	float d= 999.;
    float h = Terrain(p0.xz*.3);
        
    malaxSpace(p0);
 	d = p0.y - h*mix(.002,.04, smoothstep(.1,3.,sign(p0.z)*abs(p0.x))*smoothstep(10.,MAX_DIST,length(p0.xz)));
    
    vec3 p = p0;
    float dc = length(p.xz-vec2(0,2));
    
 	// Rempart
    d = min(d, max(-min(.8-p.y, dc-6.-.3),sdCone(p-vec3(0,6.*8.4,2.), normalize(vec2(1.,.13)))));   
	d = min(d, sdRoundCreneaux(p-vec3(0,.9,2.), 6.55));
    d = min(d, sdStairs(p-vec3(1.2,-.45,8.2))); // Escaliers 
    
    vec3 p1 = p-vec3(0,0,2);
    pMirrorOctant(p1.xz, vec2(3.9)); // pour faire 4 tours d'un coups
    
    p.x = abs(p.x);
    d = min(d, max(-1.1+p1.y, sdCone(p1 - vec3(2.4,5.,-2.4), normalize(vec2(1.,.1))))); // Tour rampart
    d = max(d, -sdTorus82(p-vec3(0,.91,2.), 6.375, vec2(.08, .15))); // Porte tour rampart
    d = min(d, sdRoundCreneaux(p1-vec3(2.4,1.3,-2.4), .5));

    p.z += .05;
  
    vec3 p2 = p, ph = p;

    // Chemin de ronde
    p.z -= .1;
    pReflect(p, normalize(vec3(-1.,0,1.)),1.7);
    pReflect(p, normalize(vec3( 1.,0,1.)),1.2);

    p1 = p;
    p1.x = abs(p1.x); // Pour doubler les tours
    p1 -= vec3(1.2,0.,0.);

    // Tour du chemin de ronde
    d = min(d, max(-1.7+p1.y, sdCone(p1 - vec3(0,7.,0.), normalize(vec2(1.,.05)))));
    d = min(d, sdRoundCreneaux(p1-vec3(0,1.9,0), .35));
    d = min(d, sdWall(p-vec3(.5,0.,-.07), 1.1,1.));  // Mur droit
    d = min(d, sdLineCreneaux(p-vec3(0.,1.3,.0)));

    // Donjon
    d = min(d, sdHouse((vec3(p.x-.2,p.y,p.z+1.2)).zyx*1.6)/1.6);
    d = min(d, sdWall(p-vec3(.0,0.,-1.28),2.,1.));
    
    // Tour du donjon
    float d2 = sdLineCreneaux(p-vec3(0.,2.2,-1.2));
    d2 = min(d2, sdCapsule(p, vec3(.28,1.9,-1.3), vec3(.28,2.7,-1.3), .09, .17));

#ifdef FULL_MAP    
    d = fOpUnionStairs(d, d2, .04, 3.);
#else
    d = min(d, d2);
#endif
    d = min(d, max(-p.y+2.7,
                   min(sdCone((p-vec3(.28,3.3,-1.3)), vec2(1.,.4)),
                       sdCone((p-vec3(.28,3.6,-1.3)), vec2(1.,.22)))));
 	float dWin = sdWindow(p.xy-vec2(.28,2.45));
  
	d = -fOpUnionStairs(dWin,-d, .05,2.);

    ph.z -= .5;
	pR45(ph.zx);
    ph.z -= 4.6;
    ph.x += 1.;
 
    pReflect(ph, normalize(vec3(-1.,0,.7)),1.);
    
    d = min(d, fBlob((ph-vec3(0,1.,0))*4.)/4.); // arbre feuilles
    d = min(d, max(ph.y-1.,length(ph.xz)-.04)); // arbre tronc

    pMirrorOctant(ph.xz, vec2(1.5,1.6));

    // Petites maisons
    d = min(d, sdHouse((vec3(ph.x-.2,ph.y,ph.z+.6))*3.)/3.);
#ifdef FULL_MAP  
    d = min(d, fBoxCheap(ph-vec3(.15,0.,-.95), vec3(.05,.9,.05)));  // cheminee
#endif  
    
    d = min(d, sdStairs(p2-vec3(1.2,-.01,-.285)));    // escaliers

   // r = length(p0.yz-vec2(.4,-2.2));
   // d = min(d, max(abs(p0.x)-.2, r-.04)); 
    
    // Grande porte
    p0.x = abs(p0.x)+.1; // gothique    
 
    float dDoor = min(fCylinder(p0.xzy-vec3(0.,3.5,0.5),.2,6.), fBoxCheap(p0-vec3(0.,.35,3.5), vec3(.2,.18,6.)));

	d = max(-fBoxCheap(p-vec3(1.5,1.35,-.15), vec3(3.5,.15,.07)), d); // Porte chemin de ronde
    d = fOpUnionStairs(d, fBoxCheap(p0-vec3(0,.18,-1.35),vec3(.4,.6,.1)),.1,5.);
    d = -fOpUnionStairs(-d, fBoxCheap(p0-vec3(0,.18,-1.1),vec3(.37,.57,.1)),.02,2.);
    d = fOpDifferenceColumns(d, dDoor, .03,3.);
    d = min(d, fBoxCheap(p0-vec3(0,.185,-1.2),vec3(.38,.05,.1)));
    d = min(d,.025*sdCircleStairs(40.*(vec3(.45-p0.x,p0.y+.09,p0.z+1.1)))); // escalier circulaires de l'entree
	d = min(d, fBoxCheap(vec3(p.x,abs(p.y-1.15)-.95,p.z+1.8), vec3(10.5,.02,0.5)));

    // Puit
    float r = length(p0.xz-vec2(3.,3.1));
    d = min(d, max(p0.y-.3, r-.2)); 
	d = max(d, .14-r);

    return d;
}

// Function 4405
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {
    if (iFrame > 1) discard; // cache
    vec3 p = 1.5 * rayDir;
    fragColor.x = 0.;
    for (float i = 0.; i < 5.; i++) {
        float c = craters(0.4 * pow(2.2, i) * p);
        float noise = 0.4 * exp(-3. * c) * FBM(10. * p);
        float w = clamp(3. * pow(0.4, i), 0., 1.);
		fragColor.x += w * (c + noise);
	}
    fragColor.x = pow(fragColor.x, 3.);
}

// Function 4406
void write_map_data(inout vec4 fragColor, vec2 fragCoord)
{
    if (is_inside(fragCoord, ADDR_LIGHTING) > 0.)
    {
        Lighting lighting;
        if (iFrame == 0)
            clear(lighting);
        else
            from_vec4(lighting, fragColor);

        lighting.progress = clamp(min(float(iFrame)/float(NUM_WAIT_FRAMES), iTime/LOADING_TIME), 0., 1.);
        if (lighting.progress >= 1. && lighting.bake_time <= 0.)
            lighting.bake_time = iTime;
        
        to_vec4(fragColor, lighting);
        return;
    }
    
#if WRITE_MAP_DATA
    if (iFrame > 0)
#endif
        return;
    
    ivec2 offset;

    if (is_inside(fragCoord, ADDR_RANGE_NONAXIAL_PLANES, offset))
    {
        int index = offset.y * int(ADDR_RANGE_NONAXIAL_PLANES.z) + offset.x;
        if (uint(index) < uint(NUM_MAP_NONAXIAL_PLANES + 1))
            fragColor = planes.data[index];
    }
    else if (is_inside(fragCoord, ADDR_RANGE_LIGHTS, offset))
    {
        if (uint(offset.x) < uint(NUM_LIGHTS + 1))
        	fragColor = lights.data[offset.x];
    }
    else if (is_inside(fragCoord, ADDR_RANGE_LMAP_TILES, offset))
    {
        int index = offset.y * int(ADDR_RANGE_LMAP_TILES.z) + offset.x;
        if (uint(index) < uint(NUM_MAP_PLANES))
        {
            int tile = LIGHTMAP_TILES.data[index];
            bool delta_encoded = (tile & 1) != 0;
            if (delta_encoded)
            {
                int offset = (tile >> 1) & 7;
                tile = (tile >> 3) ^ LIGHTMAP_TILES.data[index - offset - 1];
            }
            tile >>= 1;
            
            int x = tile & 255,
                y = (tile >> 8) & 511,
                w = (tile >> 17) & 63,
                h = (tile >> 23) & 63;
            
            fragColor = vec4(x, y, w, h);
        }
    }
    else if (is_inside(fragCoord, ADDR_RANGE_COLLISION_PLANES, offset))
    {
        if (uint(offset.x) < uint(NUM_MAP_COLLISION_PLANES + 1))
        	fragColor = cm_planes.data[offset.x];
    }
}

// Function 4407
float Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )
{
    float fOcclusion = 0.0;
    float fScale = 1.0;
    for( int i=0; i<5; i++ )
    {
        float fOffsetDist = 0.01 + 1.0*float(i)/4.0;
        vec3 vAOPos = vDir * fOffsetDist + vPos;
        float fDist = Scene_GetDistance( vAOPos, -1 ).fDist;
        fOcclusion += (fOffsetDist - fDist) * fScale;
        fScale *= 0.4;
    }
    
    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );
}

// Function 4408
float sdDistancePlanes(vec3 p)
{
    if (_ambOccMarch == true || keyInfo(74.,2.) > 0. || keyInfo(72.,2.) > 0.) return 1e10;
    
    float d = 1e10;
    
    if ((_plane_xz == true && _ortho == false) || (_ortho == true && _plane_xy == false && _plane_yz == false))
    d = min(d,abs(p.y));
    
    if (_plane_xy == true)
    d = min(d,abs(p.z));
    
    if (_plane_yz == true)
    d = min(d,abs(p.x));
    
    return d;
}

// Function 4409
float triangleDist(vec2 p, float width, float height)
{
	vec2 n = normalize(vec2(height, width / 2.0));
	return max(	abs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);
}

// Function 4410
float sdf_B(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(2, -8, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -6, 0)));
    return t;
}

// Function 4411
float spheresSDF(vec3 samplePoint) {
    float spheresDist = MAX_DIST;

    for(int i=0; i<numberOfSpheres-1; i++)
    {
        spheresDist = min(spheresDist, sphereSDF(samplePoint, spheres[i]));
    }
    spheresDist = min(spheresDist, oceanSDF(samplePoint, spheres[numberOfSpheres-1]));

    return spheresDist;
}

// Function 4412
vec4 Map(in vec3 p)
{
	vec3 col = vec3(0.0);
	float di = length(p)-8.0;

	if (di > 0.0)
	{
		di -= Noise(p * 1.5 + vec3(0.0, 0.0, gTime * 1.5)) * 8.0 + cos(gTime * .5) * 4.0 + 6.0;
		
		vec3 loops = p + vec3(0.0, 0.0, gTime * 5.0);
		loops.xy = Rotate2D(loops.xy, di * .15 - gTime * .15);
		
		float h = Voronoi(loops * .2);
		di = di + pow(h, 12.0)*500.0;
		col = FlameColour(clamp(-di*.13, 0.0, 1.0));
	}else
	{
		col = vec3(1.0);
		di *= 20.0;
	}
	return vec4(col, -di*.006);
}

// Function 4413
float cappedCylinderSDF(vec3 p, vec2 h) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 4414
float3 Tonemap(float3 c) { return c * rcp(max3(c.r, c.g, c.b) + 1.0); }

// Function 4415
bool Map_PointInSector( sampler2D mapSampler, MapInfo mapInfo, vec2 vPos, int iSectorId )
{
    if ( !Map_ValidSectorId(mapInfo, iSectorId) )
    {
        return false;
    }

    Sector sector = Map_ReadSector( mapSampler, iSectorId );

    return Map_PointInSector( mapSampler, vPos, sector );
}

// Function 4416
float sdist(vec3 a, vec3 b) {
    return acos(clamp(dot(a, b), -1.0, 1.0));
}

// Function 4417
float map(vec3 p){
    
    // Retrieve the 3D surface value. Note (in the function) that the 3D value has been 
    // normalized. That way, everything points toward the center.
    float sf3D = surfFunc3D(p);
    
    // Retrieve the 2D surface value from another cube map face.
    float sf2D = surfFunc2D(p);
     
    // Path function.
    vec2 pth = path(p.z); 

    
    // The tunnel itself.
    float tun = 2. - dist((p.xy - pth)*vec2(.7, 1));

    // Second tunnel --- Needs work, so not used here.
    //tun = smax(tun, 2. - dist((p.xy - path(p.z*1.5 + .5)*1.35)), 4.);
    
    
    // Terrain.
    float ter = p.y + (.5 - sf2D)*4. - sf2D*2.75;
 
    // Hollowing the tunnel out of the terrain.
    ter = smax(ter, tun, 3.);
     
    // Adding a bit more of the 2D texture and 3D texture.
    ter += (.5 - sf2D) +  (.5 - sf3D); 

    
    // The sand layer upon which the sand pattern sits -- The 
    // sand pattern itself is added later via bump mapping.
    float snd = p.y - pth.y - sf2D*2. + 2.65; 

    // Storing the terrain and sand layer distance for later usage.
    vRID = vec2(ter, snd);

    // Return the minimum distance.
    return min(ter, snd);
 
}

// Function 4418
float MapToScene( const in vec3 vPos )
{   
	float fResult = 1000.0;
	
	float fFloorDist = vPos.y + 3.2;	
	fResult = min(fResult, fFloorDist);
	
	vec3 vBuilding1Pos = vec3(68.8, 0.0, 55.0);
	const float fBuilding1Radius = 58.5;
	vec3 vBuilding1Offset = vBuilding1Pos - vPos;
	float fBuilding1Dist = length(vBuilding1Offset.xz) - fBuilding1Radius;
	
	fResult = min(fResult, fBuilding1Dist);
	
	vec3 vBuilding2Pos = vec3(60.0, 0.0, 55.0);
	const float fBuilding2Radius = 100.0;
	vec3 vBuilding2Offset = vBuilding2Pos - vPos;
	float fBuilding2Dist = length(vBuilding2Offset.xz) - fBuilding2Radius;
	fBuilding2Dist = max(vBuilding2Offset.z - 16.0, -fBuilding2Dist); // back only
	
	fResult = min(fResult, fBuilding2Dist);

	vec3 vBollardDomain = vPos;
	vBollardDomain -= vec3(1.0, -2.0, 14.2);
	//vBollardDomain = RotateY(vBollardDomain, 0.6);
	float fBollardDist = RoundBox(vBollardDomain, vec3(-0.2, .75, -.2));
		
	fResult = min(fResult, fBollardDist);
	
	vec3 vFenceDomain = vPos;
	vFenceDomain -= vec3(-5.5, -2.5, 7.0);
	vFenceDomain = RotateY(vFenceDomain, 1.5);
	float fFenceDist = GetDistanceBox(vFenceDomain, vec3(0.5, 1.2, 0.2));
		
	fResult = min(fResult, fFenceDist);
	
	vec3 vCabDomain = vPos;
	vCabDomain -= vec3(-1.4, -1.55,29.5);
	vCabDomain = RotateY(vCabDomain, 0.1);
	float fCabDist = RoundBox(vCabDomain+vec3(0.0, .85, 0.0), vec3(.8, .54, 2.5));
	fResult = min(fResult, fCabDist);
	fCabDist = RoundBox(vCabDomain, vec3(.6, 1.2, 1.2));
	fResult = sMin(fResult, fCabDist);

	vec3 vBusDomain = vPos;
	vBusDomain -= vec3(-15., 0.0, 29.5);
	vBusDomain = RotateY(vBusDomain, 0.35);
	float fBusDist = RoundBox(vBusDomain, vec3(.55, 1.8, 4.0));
		
	fResult = min(fResult, fBusDist);
		
	vec3 vBusShelter = vPos;
	vBusShelter -= vec3(7.5, -2.0, 30.0);
	vBusShelter = RotateY(vBusShelter, 0.3);
	float fBusShelterDist = RoundBox(vBusShelter, vec3(.725, 5.3, 1.7));
		
	fResult = min(fResult, fBusShelterDist);
	
	vec3 vRailings = vPos;
	vRailings -= vec3(15.0, -.55, 18.0);
	vRailings = RotateY(vRailings, 0.3);
	float fRailings = RoundBox(vRailings, vec3(.0, -.1, 7.5));
		
	fResult = min(fResult, fRailings);
	
	vec3 vCentralPavement = vPos;
	vCentralPavement -= vec3(5.3, -3.0, 8.0);
	vCentralPavement = RotateY(vCentralPavement, 0.6);
	float fCentralPavementDist = GetDistanceBox(vCentralPavement, vec3(0.8, 0.2, 8.0));
		
	fResult = min(fResult, fCentralPavementDist);
	
	return fResult;
}

// Function 4419
float TreeSDF( vec3 pos )
{
    float bounds = TreeBoundsSDF(pos);
    
    if ( bounds > 1. ) return bounds-.0;
    
    pos += PATTERN_SCROLL*iTime;
	TreeSpace ts = GetTreeSpace(pos);

	float branchRand = hash1(coord2(uvec2(ts.branchGrid+0x10000)));
    float branchEndLength = .3*(branchRand-.5);
    
    return
        min(
            max(
                min(
                    min(
                        // twig
                        length(ts.twig.xy)-.005,
                        // needle
                        length( vec3( ts.needle.xy, max(0.,ts.needle.z-.05) ) ) - .003
                    ),
                    // branch
                    max(
                    	(length(ts.branch.xy
                               + .004*sin(vec2(0,6.283/4.)+ts.branch.z*6.283/.1) // spiral wobble
                              )-.01)*.9,
                    	bounds - branchEndLength - .2 // trim branches shorter than twigs
                    )
            	),
            	// branch length (with rounded tip to clip twigs nicely)
                length( vec3(ts.branch.xy,max(0.,bounds
                                              -branchEndLength  // this seems to cause more floating twigs (or more obvious ones)
                                             )) )-.3
            ),
            max(
                // trunk
                length(pos.xz)-.03,
                bounds  // this will give a sharp point - better to just chop it - but might not show it
            )
        )*.7; // the helical distortion bends the SDF, so gradient can get higher than 1:1
}

// Function 4420
vec4 traceScene(vec3 ro, vec3 rd, out int objid, inout vec3 out_uvw)
{
    float mt = 1e3;
    vec3 normal;
    
    out_uvw = vec3(-1.);
    
    for(int i = 0; i < N; ++i)
    {
        int j = (i + 1) % N;
        int k = (i + 2) % N;
        
        // The polynomial coefficients can be expressed as a linear combination of the 3 contributing
        // control points.
        
        mat2x3 cp0 = controlPoints(i);
        mat2x3 cp1 = controlPoints(j);
        mat2x3 cp2 = controlPoints(k);

        for(int m = 0; m < 2; ++m)
        {
            vec2 sphere_is = intersectSphere(ro, rd, cp0[m], .03);
            if(sphere_is.x < sphere_is.y && sphere_is.x > 0. && sphere_is.x < mt)
            {
                out_uvw = vec3(.5, .5, 13.);
                normal = ro + rd * sphere_is.x - cp0[m];
                mt = sphere_is.x;
            }
            float capsule_is = capIntersect(ro, rd, cp0[m], cp1[m], .01);
            if(capsule_is > 0. && capsule_is < mt)
            {
                out_uvw = vec3(.5, .5, 18.);
                normal = capNormal(ro + rd * capsule_is, cp0[m], cp1[m], .01);
                mt = capsule_is;
            }
        }
        
        
        mat3 b = mat3(coeffsForCP(2.), coeffsForCP(1.), coeffsForCP(0.));

        mat3 scp0 = mat3(cp0[0] - ro, cp1[0] - ro, cp2[0] - ro) * transpose(b);
		mat3 scp1 = mat3(cp0[1] - ro, cp1[1] - ro, cp2[1] - ro) * transpose(b);

        // Get the worldspace Bezier-style control points for calculating a bounding box.
        
        vec3 P0 = scp0[2];
        vec3 P1 = (scp0[1] + 2. * scp0[2]) / 2.;
        vec3 P2 = scp0[0] + 2. * P1 - P0;

        vec3 Q0 = scp1[2];
        vec3 Q1 = (scp1[1] + 2. * scp1[2]) / 2.;
        vec3 Q2 = scp1[0] + 2. * Q1 - Q0;
        
        vec3 box_min = min(Q0, min(Q1, min(Q2, min(P0, min(P1, P2)))));
        vec3 box_max = max(Q0, max(Q1, max(Q2, max(P0, max(P1, P2)))));
        
        // Test bounding box.
        
        vec2 box_is = box(vec3(0), rd, box_min, box_max);
        
      	if(box_is.y < 0. || box_is.x > box_is.y)
       		continue;
        
        // Start ray at bounding surface to help improve precision (slightly).
        vec3 ro2 = ro + box_is.x * rd;
        
        scp0 = mat3(cp0[0] - ro2, cp1[0] - ro2, cp2[0] - ro2) * transpose(b);
		scp1 = mat3(cp0[1] - ro2, cp1[1] - ro2, cp2[1] - ro2) * transpose(b);
        
        vec2 uv = vec2(-1.);
    	vec4 res = intersectSection(rd, scp0, scp1, uv);

        if(res.x > 1e-3)
        {
            res.x += box_is.x;

            if(res.x < mt)
            {
                // A closer hit has been found.
                out_uvw = vec3(uv, float(i));
                normal = res.yzw;
                mt = res.x;
            }
        }
    }
    
    return vec4(mt, normal);
}

// Function 4421
float MapGlass(  vec3 p)
{   

  p.y-=21.25;
  vec3 checkPos = p;
  // tower windows
  float d = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.00, .8));
  checkPos.xz = pModPolar(p.xz, 6.0);
  // upper windows
  #ifdef HIGH_QUALITY
  d = min(d, sdBox(checkPos-vec3(1.550, 1.1, 0.), vec3(0.01, .60, 0.3)));   
  #else
  d = min(d, sdBox(checkPos-vec3(1.62, 1.1, 0.), vec3(0.01, .60, 0.3)));   
  #endif  
  checkPos.xz = pModPolar(p.xz, 5.0);
  // middle and lower windows 
  #ifdef HIGH_QUALITY
  checkPos-=vec3(2.03, -6.8, 0.);
  #else
  checkPos-=vec3(2.18, -6.8, 0.);
  #endif
    float m=pModInterval1(checkPos.y, 3.5, 0., 1.);
  return min(d, sdBox(checkPos+mix(vec3(0.), vec3(0.28, 0.0, 0.), m), vec3(0.01, 0.4, .3)));
}

// Function 4422
float waterHeightMap( vec2 pos ) {
    return 0.9+.1*snoise( pos/2. +iTime/3.);
}

// Function 4423
float sdf_0(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -6, 0)));
    return t;
}

// Function 4424
vec3 map(vec3 p){
    vec2 a = vec2(1);
    vec2 b = vec2(1);
    float c = 0.;
    float t = iTime; 

    float size = 0.062; //Thickness of spiral curls
    float scale = size-0.01; //Space between spiral curls
    
    float expand = 0.04; //Corner Rounding Amount 

    float m2 = size*6.0; //Repetition Sizes
    float m = pi*scale; //Repetition Sizes
    
    float ltime = 10.0; //How often the spirals rolls repeat
    
    p.y-=(t/ltime)*size*6.; //Move everything upwards so it stays in frame
    
    p.x-=3.;  //small offset for framing
    
    float width = 0.5; //Lane Width
    float count = 6.0; //Number of spirals (x2)
    
    float modwidth = width*2.0+0.04+0.06;
    
    float id3 = idlim(p.z,modwidth,-count,count);
    t+=h11(id3*0.76)*8.0; //it took like 15 minutes to find this seed
    p.z = lim(p.z,modwidth,-count,count);
    
    #ifdef FUN_MODE
        scale+=(sin(t)*0.5+0.5)*0.05;
        m = pi*scale;
    #endif
    
    float to = t;
    vec3 po = p;

    //Spiral 1
    float stack = -floor(t/ltime);
    float id2 = idlim2(p.y,m2,stack);
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    a.x = spiral(p.xy,t,m,scale,size,expand);
    c = a.x;
    
    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal
    
    //Spiral 2
    p = po;
    t = to;
    p.y+=size*2.0;
    t-=ltime/3.0;
    stack = -floor(t/ltime);
    id2 = idlim2(p.y,m2,stack);
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    b.x = spiral(p.xy,t,m,scale,size,expand);
    c = min(c,b.x);
    a=(a.x<b.x)?a:b;
    
    a.x = min(a.x,max(p.y+size*5.,p.x));//Artifact Removal
    
    //Spiral 3
    p = po;
    t = to;
    p.y+=size*4.0;
    t-=2.*ltime/3.0;
    stack = -floor(t/ltime);
    id2 = idlim2(p.y,m2,stack);    
    t+=id2*ltime;
    p.y = lim2(p.y,m2,stack);
    b.x = spiral(p.xy,t,m,scale,size,expand);
    c = min(c,b.x);
    a=(a.x<b.x)?a:b;
    
    a.x = min(a.x,max(p.y+size*5.,p.x)); //Artifact Removal
    
    a.x = ext(po.yzx,a.x,width-expand*0.5+0.02)-expand;
    //SDF without intersection boundries for AO
    c = ext(po.yzx,c,width-expand*0.5+0.02)-expand; 
    
    //Intersection distance to plane between each lane
    b.x = diplane(po ,vec3(modwidth)*0.5, rdg); //Artifact Removal
    b.y = 0.;

    a=(a.x<b.x)?a:b; //Artifact Removal
    
    return vec3(a,c);
}

// Function 4425
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 q, vn, col, blkSph, blkGap;
  float dstFlr, dstBlk, gCol, spec, sh, t;
  bool useBg;
  blkSph = vec3 (5., 3., 2.);
  blkGap = vec3 (1., 0.8, 0.4);
  bSize = 0.5 * blkGap * (blkSph - 1.) + 0.4;
  HexVorInit ();
  dstFlr = (rd.y < 0.) ? - (ro.y - 0.5) / rd.y : dstFar;
  dstBlk = BlkHit (ro, rd);
  useBg = false;
  if (min (dstBlk, dstFlr) < dstFar) {
    if (dstFlr < dstBlk) {
      ro += rd * dstFlr;
      vn = vec3 (0., 1., 0.);
      useBg = true;
    } else {
      ro += rd * dstBlk;
      vn = fcBlk;
      q = vec3 (qBlk.yx, 0.);
      q = (abs (fcBlk.y) == 1.) ? q.yzx : ((abs (fcBlk.x) == 1.) ? q.zyx : q);
      if (abs (fcBlk.x) == 1.) t = abs (length (qBlk) - 0.45);
      else t = abs (length (max (abs (qBlk) - 0.45 * ((abs (fcBlk.x) == 1.) ?
         bSize.zy : ((abs (fcBlk.y) == 1.) ? bSize.xz : bSize.yx)), 0.)) - 0.2);
      gCol = (t < 0.07) ? 1. - 0.5 * smoothstep (0.04, 0.07, t) : 0.;
      if (gCol > 0.) {
        col = vec3 (1., 1., 0.1) * gCol;
        vn = VaryNf (50. * q, vn, 0.2);
        spec = 10.;
      } else {
        col = vec3 (0.5, 0.3, 0.15) * (1. - 0.3 * Fbm2 (20. * qBlk));
        vn = VaryNf (20. * q, vn, 2.);
        spec = 0.3;
      }
      vn = QtToRMat (Loadv4 (4 + 4 * idBlk + 2)) * vn;
    }
  } else useBg = true;
  sh = (! useBg || rd.y < 0.) ? BlkHitSh (ro + 0.01 * sunDir, sunDir, 15.) : 1.;
  if (! useBg) col = col * (0.1 + 0.9 * sh * max (dot (vn, sunDir), 0.) +
     0.1 * max (dot (vn, vec3 (- sunDir.x, 0., - sunDir.z)), 0.)) +
     spec * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
  else col = BgCol (ro, rd, sh);
  return pow (clamp (col, 0., 1.), vec3 (0.8));
}

// Function 4426
float mapVoxel(in vec3 p) {
    p=fract(p/minsize);
    return mix( mix(mix(v[0],v[1],p.x),mix(v[2],v[3],p.x),p.y),
                mix(mix(v[4],v[5],p.x),mix(v[6],v[7],p.x),p.y),  
            p.z) ;   
}

// Function 4427
vec2 remap01to_11(vec2 a)
{
    return vec2(remap01to_11(a.x), remap01to_11(a.y));
}

// Function 4428
float capsuleSDF( vec3 p, vec3 a, vec3 b, float radius ) {
  vec3 pa = p - a, ba = b - a;
  return length(pa - ba*clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 ))- radius;
}

// Function 4429
float sphereSDF(vec3 p) {
    return length(p) - sphereSize ;
}

// Function 4430
vec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )
{
	return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));
}

// Function 4431
Dst dstScene(vec3 p) {
 
    Dst scn = dstBox(p, vec3(-5.,5.,12.), vec3(1.,5.,1.));
    scn = minDst(scn, dstBox(p, vec3(5.,5.,12.), vec3(1.,5.,1.)));
    scn = minDst(scn, dstBox(p, vec3(5.,5.,22.), vec3(1.,5.,1.)));
    scn = minDst(scn, dstBox(p, vec3(-5.,5.,22.), vec3(1.,5.,1.)));
    scn = minDst(scn, dstBox(p, vec3(0.,7.,17.), vec3(6.,1.,6.)));
    
    return scn;
    //return Dst(0.,-1);
    
}

// Function 4432
float map( in vec3 p )
{
float t= iTime*2.5; 
p= vec3(p.x*cos(t)-p.z*sin(t ),p.y,p.z*cos(t )+p.x*sin(t )) ;
    // triangles	
	vec3 p0 = vec3(0,-.8+cos(t+3.)*0.2,0. );
	vec3 p1 =  vec3(0,.47+cos(t),-1. );
	vec3 p2 =  vec3(1.0,0.3+sin(t/2.),1. );
	vec3 p3 =  vec3(-1.0,0.3+sin(t/2.7),1. );
    vec3 p4 =  mix(vec3(0,0.5,0.5 ),p0,sin(iTime/2.7)*0.99);
float mesh= Mypolyhedron(p);
    // ground plane here
	float d2 = p.y + 1.0;
    // sphere here
	vec3 ps = vec3(sin(-iTime),cos(-iTime),sin(2.-iTime)*2. )*0.7;
    float sphere=sdSphere(p-ps,0.5);  

    
    return smin( max(-sphere,mesh), d2,0.5+sin(iTime/3.)*0.5 );	
}

// Function 4433
float map(vec3 p)
{
    float mind = 1e5;
    
    vec2 tcd;
    p.z += -15.;
    rotate(p.xz, -.4+sin(iTime*.5)*.25);
    rotate(p.zy, 5.4+iTime*.0);
    rotate(p.xz, 1.+iTime*.0+3.4);
    
    vec3 np = normalize(p);
    tcd.x = p.x*(9./iChannelResolution[0].x )+.5;
    tcd.y = p.y*(9./iChannelResolution[0].y )+.5;//tcd = np.yx;
    #ifdef BALL
    rotate(np.xz, 1.5);
    tcd.x = .5+atan(np.z, np.x)/6.28;
	tcd.y = .5-asin(np.y)/3.14;
    #endif
    tcd = mix(tcd, floor(tcd*300.)/(300.), .5+.5*sin(iTime+(p.x+p.y)*.5) );
    float to = .1*( texture(iChannel0, tcd).x*1.);
    
    #ifdef BALL
    mind = min(mind, length(p)-10.+to*10.);
    mind = max(mind, -(length(p)-8.5-to*10. ) );
    #else
    mind = max(p.z-.5, -p.z-.5)-to*10.;
    mind = max(mind, abs(p.x)-16.+.0*-10000.0/iChannelResolution[0].x);
    mind = max(mind, abs(p.y)-16.+.0*-10000.0/iChannelResolution[0].x);
    #endif
    h += 1.*vec3(.45, .5, .4)*1./max(.1, mind*mind*1. + 15.);
    float mint = max(mind, .01);
    h -= 1.*vec3(.05, .40, .50)*1./max(.00001, mint*mint*1000.001 + 20.);
    
    return mind*.421;
}

// Function 4434
float sdFloat(vec3 p, float s) {
	return length(p)-s;
}

// Function 4435
float getdist(vec3 p) {
  float d = eval(p)/length(cgrad(p));
  d *= rosign;
  return d;
}

// Function 4436
float Scene(in vec3 rO, in vec3 rD)
{
    //float t = 0.0;
	float t = .1 * Hash(fcoord*fract(iTime));
	float  alphaAcc = 0.0;
	vec3 p = vec3(0.0);
    int hits = 0;

	for( int j=0; j < 80; j++ )
	{
		if (hits == 8 || alphaAcc >= 1.0 || t > 10.0) break;
		p = rO + t*rD;
		float sphereR = SphereRadius(t);
		float h = Map(p);
        // Is it within the sphere?...
		if( h < sphereR)
		{
			// Accumulate the alphas with the scoop of geometry from the sphere...
            // Think of it as an expanding ice-cream scoop flying out of the camera! 
			float alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);
			// put it on the 2 stacks, alpha and distance...
			aStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;
			aStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;
			dStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;
			dStack[0].yzw = dStack[0].xyz; dStack[0].x = t;
			alphaAcc += alpha;
			hits++;
		}
		t +=  h*.85+t*.001;
        
	}
	
	return clamp(alphaAcc, 0.0, 1.0);
}

// Function 4437
float GetDist(vec3 p, vec3 ro) {
	float time = iTime*.3;
    vec3 pd = p;
    pd.x = abs(p.x) + tan(p.z*.2) * cos(-p.y*.3);
    pd.y *= pd.x<0.0 ? -2.0 : 1.1;
    pd.z = mix( pd.z, pd.x, sin(p.z)*.15-.1 );
    
    float scalar = sin( dot(normalize(ro-pd),pd)*.1) * (pd.x+pd.z)*.4;
    pd.z = mix( -pd.z, pd.y+pd.x, abs(scalar) );

   
    vec2 tUv = vec2( sin(pd.x*.01+scalar*.1), cos(pd.z*.1+scalar*.01)) *.1+.5;
    vec3 tex = texture(iChannel0, tUv ).rgb;

    vec3 slicer = normalize( vec3(sin(time+pd.z-pd.x+1.2)*.50+.5, -0.71, cos(time+pd.z+pd.y)*.10+.2) );
	slicer -= texture(iChannel1, slicer.rg*.01).rgb;
    float plane = dot(pd, slicer); // Dot Plane 1
    
    
    slicer = vec3( sin(-time*1.5+pd.z+tex.g+5.1)*2.0, .90, cos(time+pd.y+tex.g)*2.0 );
 
    float pa = dot( pd*vec3(1.27,.07,.95), slicer ); // Dot Plane 2
    plane = plane*abs(pa); // Combine both cutting planes
    
    float box = sdBox(pd+vec3(.0,.15,.0), vec3(.7)); // Warped Box Math 1
    
    slicer = vec3( sin(-time*1.5+pd.x+tex.g), .0, cos(time+pd.y+tex.g)*2.0 );
    float boxf = sdBox( pd*vec3(-1,1,-1)-vec3(0.0,.2,1.0), vec3(-slicer*0.5+.5) ); // Warped Box Math 2
    box = box+abs(boxf)-0.10; // Combine both boxes
    
    float d = max( plane, box) * min(1.0,length(pd));
    
    return d;
}

// Function 4438
float sdf_line3(vec2 uv, vec2 vert_A, vec2 vert_B){
    vec2 dvec_AB = vert_A - vert_B;
    float angle = atan(dvec_AB.y, dvec_AB.x);  // Compute angle using atan2; it has branching, and it's slow.
    uv = rotate_2D(angle) * uv;  //  Rotate vertex `uv` by `angle`
    return -uv.y;  // Signed distance!
    // return abs(uv.y);  // Unsigned distance!
}

// Function 4439
void calcSceneFast(in Camera cam,in vec2 fragCoord,out float3 col,out float4 debug_col)
{
    float nx = iResolution.x;
    float ny = iResolution.y;
    const int ns = kNumSamplesFast;
    
	col = float3(0.0);
    debug_col = float4(0.0);
#ifndef FORCE_DEBUG_RAY_FROM_THE_SIDE    
    Ray r_debug = cameraGetRay(cam,(iMouse.xy+float2(0.5))/iResolution.xy);
#else
 	Ray r_debug = rayConstruct(float3(-2.0,0.0,-1.0),float3(1.0,-0.252,0.0));   
#endif    
    
    for(int s = 0;s < ns; ++s)
    {
    	float2 uv = float2(fragCoord.x+rand(),fragCoord.y+rand())/float2(nx,ny);
        Ray r = cameraGetRay(cam,uv);
       	

        col += color(r);
#ifdef DEBUG_RAY        
        debug_col += debug_trace(r_debug,r);
#endif      
    }
    col/=float(ns); 
}

// Function 4440
float sphereSDF(vec3 samplePoint, float r) {
    return length(samplePoint) - r;
}

// Function 4441
float sdfCappedCone( vec3 p, float r1, float r2, float h,  mat4 t )
{
  p = vec3(t * vec4(p, 1));
  vec2 q = vec2( length(p.xz), p.y );
  vec2 k1 = vec2(r2,h);
  vec2 k2 = vec2(r2-r1,2.0*h);
  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );
  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
  return s*sqrt( min(dot2(ca),dot2(cb)) );
}

// Function 4442
vec2 map_1( in vec3 pos ) { // scene + ro
    vec2 res = map_0(pos);
    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),2. ) );
    return res;
}

// Function 4443
float sceneSDF(vec3 p, mat3 modelMatrix)
{
    p *= modelMatrix;
    return udRoundBox(p, vec3(BOX_EXTENTS), RADIUS);
}

// Function 4444
MapResult map(vec3 position)
{
	MapResult result;
	
	result = map_floor(position);
	
	result = combine(result, map_cube(position));
	result = combine(result, map_torus(position));
		
	return result;
}

// Function 4445
vec3 intersectScene( vec3 ro, vec3 ta, vec2 p,  bool intersectPlane ) {    
    mat3 ca = setCamera( ro, ta, 0.0 );
    vec3 rd = ca * normalize( vec3(p.xy,1.0) );
    
    float d = 1000.;
    // sphere intersections ..
    if( intersectPlane ) {
	    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 0.));
    } else {
    	d = min( d, sphIntersect( ro, rd, vec4(-1,0,-5,1) ));
   		d = min( d, sphIntersect( ro, rd, vec4(2,0,-3,1) ));
  	  	d = min( d, sphIntersect( ro, rd, vec4(-2,0,-2,1) ));

	    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 1.));
    }
    
    if( d < 100. ) {
        return ro + d*rd;
    } else {
        return vec3(-1,0,-4);
    }
}

// Function 4446
float calcLoadDist(void) {
	vec2 chunks = floor(iResolution.xy / packedChunkSize);
    float gridSize = min(chunks.x, chunks.y);
    return floor((gridSize - 1.) / 2.);
}

// Function 4447
float sdFat(const vec3 p)
{
    float k=1.0 + 0.1;
 	vec3 r=pins(ROOT,2),t,n,s,l,sl,sr;
//	float z = sdCap2(p,r,s=pins(SPINE),0.15,0.13);
    float z = sdSph(p-r,0.26);
    z = oB(z, sdSph(p-(pins(SPINE)+vec3(0.,.07,0. )),0.23) );
    vec3 oass=vec3(0.,0.1,0.);
    
    vec3 lhip=pins(LHIP,3);
    vec3 rhip=pins(RHIP,3);
    vec3 back=-cross(rhip-lhip,vec3(0.,1.,0.)) * 0.35;
    z = smin(z, sdSph(p-(rhip + back   ),0.20) , 50.);
     z =smin(z, sdSph(p-(lhip + back   ),0.20) ,50.);
    z = smin(z,sdCap2(p,r=pins(RHIP,2),t=pins(RKNEE),0.20,0.09));
    
    z = smin(z,sdCap2(p,r=pins(LHIP,2),t=pins(LKNEE),0.20,0.09));

 	z-=0.031;
	return z;
}

// Function 4448
Hit traceScene(Ray ray)
{
    Hit hit;
    hit.t = t_max;
   
    hit = compareHit(hit, traceSphere(ray, blueLight));
    hit = compareHit(hit, traceSphere(ray, greenLight));
    
    hit = compareHit(hit, traceSphere(ray, witchBall));
  	hit = compareHit(hit, traceSphere(ray, sphere));
    
    hit = compareHit(hit, tracePlane(ray, plane));
    hit = compareHit(hit, traceCylinder(ray, stand));

    return hit;   
}

// Function 4449
vec2 map(vec3 p) {
    float d1 = sdSphere(p);
    float d2 = sdPlane(p);
    float id = (d1 < d2) ? 0.: 1.;
    return vec2(min(d1, d2), id);
}

// Function 4450
float BaublesSDF( vec3 pos, uint seed, float spacing, float radius, float power, float twist )
{
    // avoid looping over every bauble - find closest one from a handful of candidates, using a jittered grid
    float f = BaubleBoundsSDF(pos);
    f -= radius;
    
    float margin = .1; // distance at which to start computing bauble SDFs - affects speed of marching (trial and error suggests .1 is fairly optimal)
    if ( f > margin ) return f;
    
	vec3 offset = spacing*(hash3(coord1(seed))-.5); // use a different grid for each set of baubles
    offset += PATTERN_SCROLL*iTime;
	pos += offset;

    // find closest centre point
    vec3 c = floor(pos/spacing);
    ivec3 ic = ivec3(c);
    c = (c+.5)*spacing; // centre of the grid square
    
    c += (spacing*.5 - radius /*- margin*/) * ( hash1(coord3(uvec3(ic+63356))^seed)*2. - 1. );
    
    // cull it if it's outside bounds
    if ( BaubleBoundsSDF(c-offset) > 0. ) return margin; // could do max (margin, distance to grid cell edge)
    
//    float f = length(pos-c)-radius;
    vec3 v = pos-c;
    v.xz = v.xz*cos(v.y*twist) + v.zx*vec2(1,-1)*sin(v.y*twist);
    v = abs(v)/radius;
    f = (pow(dot(v,pow(v,vec3(power-1.))),1./power)-1.)*radius;
    return min( f, margin ); // don't return values > margin otherwise we'll overshoot in next cell!
}

// Function 4451
vec2 SDFGrad(vec2 p){
	vec2 e=vec2(.001,0.);
    return normalize(vec2(exSDF(p+e.xy)-exSDF(p-e.xy),
                          exSDF(p+e.yx)-exSDF(p-e.yx)));
}

// Function 4452
vec2 map( in vec3 pos )
{
    vec2 res = vec2( sdPlane(pos), 1.0 );
    float speed = 0.6;
    float ang = iTime*speed;
    //float ang45 = 45./180.*3.141592;
    float c  = cos(ang*2.),s  = sin(ang*2.);
    float c2 = cos(ang*3.),s2 = sin(ang*3.);
    float c3 = cos(ang*7.),s3 = sin(ang*7.);
 ///zxc
    vec3 npos = pos-vec3( 0.0,0.8, 0.0);
    //npos = opRot(npos,0.,1.,vec3(0.,0.,1.));
	npos = opRot(npos,c,s,vec3(1.,0.,0.));
	res = opU( res, vec2( sdTorus88(npos, vec2(0.7 ,0.05)), 10.0 ) );
    npos = opRot(npos,c2,s2,vec3(0.,0.,1.));
	res = opU( res, vec2( sdTorus88(npos, vec2(0.58 ,0.05)), 11.0 ) );
    //npos = opRot(npos,0.,1.,vec3(0.,1.,0.));
	//npos = opRot(npos,c3,s3,vec3(0.,0.,1.));
	npos = opRot(npos,c3,s3,vec3(1.,0.,0.));
	res = opU( res,  vec2( sdTorus88(npos, vec2(0.46 ,0.05)), 12.0 ) );

    //res = opU( res, vec2( sdTorus88(opRipple(pos), vec2(0.7 ,0.05)), 76.9 ) );
    
    
    //res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );
    //res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );
	//res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );
    //res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );
	//res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );
	//res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );
	//res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );
	//res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	//res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );
	//res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );
	//res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );
	//res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );
    // res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),
	//                            sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );
    // res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),
	//                            sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );
	//res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );
	// res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );
    //res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );
    //res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );
        
    return res;
}

// Function 4453
float fontDist(vec2 tpos, float size, vec2 offset) {

    float scl = 0.63/size;
      
    vec2 uv = tpos*scl;
    vec2 font_uv = (uv+offset+0.5)*(1.0/16.0);
    
    float k = texture(iChannel1, font_uv, -100.0).w + 1e-6;
    
    vec2 box = abs(uv)-0.5;
        
    return max(k-127.0/255.0, max(box.x, box.y))/scl;
    
}

// Function 4454
void SetupScene(){
   	spheres[0] = Sphere( 0.6, vec3(0., 0.3,-0.35),vec3(0.,0.,0.),vec3(1.,1.,1.), 1., DIFF,CenterSphere);
    quads[0] = Quad(normalize(vec3(0.,-0.37,1.)),vec3(4.45624,2.70023,-16.2667), vec3(-4.45624,2.70023,-16.2667), vec3(-4.45624 ,11.247,-13.7397), vec3(4.45624,11.247,-13.7397), 2.*LIGHTCOLOR, vec3(1.),0.4, LIGHT,AreLighing);
    quads[1] = Quad(vec3(0.,1.,0.),vec3(-300000,0.,-200000.), vec3(300000.,0.,-200000.), vec3(200000.,0.,200000.), vec3(-200000.,0.,200000.), vec3(0.,0.,0.), vec3(1.),0.05, DIFF,Floor);
    boxes[0] =  Box(vec3(-0.7,1.,0.8),vec3(0.7,0.0,0.94), vec3(0.,0.,0.), vec3(0.,1.,0.), 0.1, DIFF,Cuboid);
}

// Function 4455
float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1000.0; // bteitler: a really far distance, this could likely be tweaked a bit as desired

    // bteitler: At a really far away distance along the ray, what is it's height relative
    // to the ocean in ONLY the Y direction?
    float hx = map(ori + dir * tx);
    
    // bteitler: A positive height relative to the ocean surface (in Y direction) at a really far distance means
    // this pixel is pure sky.  Quit early and return the far distance constant.
    if(hx > 0.0) return tx;   

    // bteitler: hm starts out as the height of the camera position relative to ocean.
    float hm = map(ori + dir * tm); 
   
    // bteitler: This is the main ray marching logic.  This is probably the single most confusing part of the shader
    // since height mapping is not an exact distance field (tells you distance to surface if you drop a line down to ocean
    // surface in the Y direction, but there could have been a peak at a very close point along the x and z 
    // directions that is closer).  Therefore, it would be possible/easy to overshoot the surface using the raw height field
    // as the march distance.  The author uses a trick to compensate for this.
    float tmid = tm;
    for(int i = 0; i < NUM_STEPS; i++) { // bteitler: Constant number of ray marches per ray that hits the water
        // bteitler: Move forward along ray in such a way that has the following properties:
        // 1. If our current height relative to ocean is higher, move forward more
        // 2. If the height relative to ocean floor very far along the ray is much lower
        //    below the ocean surface, move forward less
        // Idea behind 1. is that if we are far above the ocean floor we can risk jumping
        // forward more without shooting under ocean, because the ocean is mostly level.
        // The idea behind 2. is that if extruding the ray goes farther under the ocean, then 
        // you are looking more orthgonal to ocean surface (as opposed to looking towards horizon), and therefore
        // movement along the ray gets closer to ocean faster, so we need to move forward less to reduce risk
        // of overshooting.
        //tmid = mix(tm,tx, hm/(hm-hx));
        p = ori + dir * tmid; 
                  
    	float hmid = map(p); // bteitler: Re-evaluate height relative to ocean surface in Y axis
        tmid += hmid;

        /*if(hmid < 0.0) { // bteitler: We went through the ocean surface if we are negative relative to surface now
            // bteitler: So instead of actually marching forward to cross the surface, we instead
            // assign our really far distance and height to be where we just evaluated that crossed the surface.
            // Next iteration will attempt to go forward more and is less likely to cross the boundary.
            // A naive implementation might have returned <tmid> immediately here, which
            // results in a much poorer / somewhat indeterministic quality rendering.
            tx = tmid;
            hx = hmid;
        } else {
            // Haven't hit surface yet, easy case, just march forward
            tm = tmid;
            hm = hmid;
        }*/
    }

    // bteitler: Return the distance, which should be really close to the height map without going under the ocean
    return tmid;
}

// Function 4456
float mapAll(vec3 p, vec3 origin, out bool matchLight, inout bool insideSphere, float time) {
    float d = map(p, insideSphere, time);
    if (d < epsilon) {
        matchLight = false;
        return d;
    } else {
        matchLight = true;
        return min(d, mapLight(p, origin));
    }
}

// Function 4457
Model map( vec3 p ){
    Model res = Model(1000000., vec3(0), 0.);
    p *= modelRotation();
    res = opU(res, model(p));
   	return res;
}

// Function 4458
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, vn, ltDir[4];
  float dstHit, sh, dfSum, spSum;
  int idObjT;
  ltDir[0] = normalize (vec3 (1., 1., 0.));
  ltDir[1] = normalize (vec3 (0., 1., 1.));
  ltDir[2] = normalize (vec3 (1., 0., 1.));
  idObj = -1;
  dstHit = ObjRay (ro, rd);
  if (dstHit < dstFar) {
    ro += dstHit * rd;
    idObjT = idObj;
    vn = ObjNf (ro);
    if (idObjT == 1) {
      col = mix (vec3 (0.6, 0.9, 0.6), vec3 (0.9, 0.9, 1.),
         clamp (1.2 * length (ro) / bxSize, 0., 1.));
      col = col * clamp (1. - 1.2 * qnStep * qnStep, 0.2, 1.);
    }
    dfSum = 0.;
    spSum = 0.;
    for (int j = 0; j < 3; j ++) {
      sh = 0.1 + ObjSShadow (ro, ltDir[j]);
      dfSum += sh * (0.2 + max (dot (vn, ltDir[j]), 0.));
      spSum += sh * pow (max (0., dot (ltDir[j], reflect (rd, vn))), 32.);
    }
    col = col * dfSum + 1.3 * spSum;
    ltDir[3] = normalize (- ro);
    sh = ObjSShadow (ro, ltDir[3]);
    col = mix (col, vec3 (0.9, 0., 0.),
       0.5 * (1. + cos (20. * tCur)) * sh * max (dot (vn, ltDir[3]), 0.) /
       dot (ro, ro));
  } else {
    col = mix (vec3 (0., 0., 0.8), vec3 (1.),
       0.3 + 0.2 * (1. - smoothstep (0.8, 0.9, abs (rd.y))) *
       Fbm2 (8. * vec2 (2. * abs (atan (rd.z, rd.x)) / pi, rd.y)));
  }
  return pow (clamp (col, 0., 1.), vec3 (0.7));
}

// Function 4459
float map(vec3 p , out float idx)
{
    float d1 = dsphere(p,vec3(0.0),1.0);
    d1+=0.05*sin(p.x*10.0+iTime*2.0)*sin(p.y*10.0)*sin(p.z*10.0);
    
    float d2 = dsphere(p,vec3(2.15,0.0,0.0),0.5);
    d2 += 0.02*sin(p.x*10.0 + iTime*3.0);
    
    float d3 = dplane(p,vec3(0.0),normalize(vec3(0.0,1.0,0.0)),-1.5);
    
    float d4 = opB(d1,d2,1.3);
    
    return opU(d3,d4,idx);
}

// Function 4460
ComplexMatrix2 M_mapTripleToTriple(
    Complex a, Complex b, Complex c, 
	Complex p, Complex q, Complex r)
{
	return M_multiply(M_inverse(M_mapTripleTo01I(p, q, r)), M_mapTripleTo01I(a, b, c));
}

// Function 4461
SDFResult tapsSDF( vec3 p )
{
    SDFResult res = SDFResult(TOO_FAR, MAGEN);
    res = roundboxSDF(RoundBox(vec3(2.0, 0.4, 1.5), vec3(0.04, 0.14, 0.01), 0.01, CHROM), p);
    res = opSmoothAdd(roundboxSDF(RoundBox(vec3(2.0, 0.5, 1.5), vec3(0.04, 0.01, 0.09), 0.01, CHROM), p), res, 0.01);
    res = opSmoothAdd(roundboxSDF(RoundBox(vec3(2.0, 0.55, 1.5), vec3(0.04, 0.005, 0.09), 0.01, CHROM), p), res, 0.01);    
	return res;
}

// Function 4462
vec3 tonemapUncharted(vec3 color) {
   color *= 1.0;  // Hardcoded Exposure Adjustment

   float ExposureBias = 2.0;
   vec3 curr = Uncharted2Tonemap(ExposureBias * color);

   vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));
   color = curr*whiteScale;
      
   return color;
}

// Function 4463
bool TraceScene(vec3 p,vec3 dir,bool A)
{
  	vec4 c;  
    //vec4 h=vec4(MAX_DIST,ID_VOID,dir.xy);
	vec4 r=Raymarcher(p,dir,A);
    if(r.x>MAX_DIST)
        return false;  // skycolor.
    
    trc.p =p+r.x*dir;
    trc.uv = r.zw;
	
    trc.id = int(r.y);
    trc.z = r.x;
    if(trc.id<=int(ID_SKIN))
    {
    	trc.n =GetNormal(trc.p,A);
        trc.uv = getUV(trc.n);
        if(faceted>0.)
      		trc.n = faceted_normal(trc.n);

    }
    else    
   		 trc.n =   trc.id==int(ID_FLOOR)?vec3(0,1,0):vec3(0,0,1);
    return true;
}

// Function 4464
void makeScene(int f) {
    float radius=0.8;
    vec3 center = vec3(0, 0, -6); 
    vec3 color = vec3(random(), random(), random());
    int count = -1;
    spheres[++count] = Sphere(radius, center, color);
    count = addSixSpheres(spheres[0], count);
    count = addSixSpheres(spheres[1], count);
    count = addSixSpheres(spheres[2], count);
    count = addSixSpheres(spheres[3], count);
    count = addSixSpheres(spheres[4], count);
    count = addSixSpheres(spheres[5], count);
    count = addSixSpheres(spheres[6], count);

    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1));
    rotateSceneTenDegrees(f);   
}

// Function 4465
float mapHyper(vec3 p){ 
  return fog(p,vec3(0,0,0),0.5,0.1);
  }

// Function 4466
float map(in vec3 p)
{
    float res = 0.;
    vec3 c = p;
    for (int i = 0; i < MAP_OCTAVE; ++i)
    {
        p =.7*abs(p)/dot(p,p) -.7;
        p.yz += csqr(p.yz);
        p=p.zxy;
        res += exp(-25.0 * abs(dot(p,c)));
    }
    return res;
}

// Function 4467
float map(vec3 p){

    // Cheap, lame distortion, if you wanted it.
    //p.xy += sin(p.xy*7. + cos(p.yx*13. + iTime))*.01;
    
    // Back plane, placed at vec3(0, 0, 1), with plane normal vec3(0., 0., -1).
    // Adding some height to the plane from the heightmap. Not much else to it.
    return 1. - p.z - heightMap(p.xy)*.125;
    
}

// Function 4468
float tetrahedronPlaneDistance(vec3 p, vec3 pa, vec3 pb, vec3 pc, vec3 pd, vec4 plane)
{
    vec3 tn0 = cross(pb - pa, pc - pa);
    vec3 tn1 = cross(pb - pd, pa - pd);
    vec3 tn2 = cross(pc - pd, pb - pd);
    vec3 tn3 = cross(pa - pd, pc - pd);
    
    vec3 n = normalize(plane.xyz);

    vec3 b0 = normalize(cross(n, cross(n, tn0)));
    vec3 b1 = normalize(cross(n, cross(n, tn1)));
    vec3 b2 = normalize(cross(n, cross(n, tn2)));
    vec3 b3 = normalize(cross(n, cross(n, tn3)));
    
    vec3 c0 = p + b0 * dot(pa - p, tn0) / dot(b0, tn0);
    vec3 c1 = p + b1 * dot(pd - p, tn1) / dot(b1, tn1);
    vec3 c2 = p + b2 * dot(pd - p, tn2) / dot(b2, tn2);
    vec3 c3 = p + b3 * dot(pd - p, tn3) / dot(b3, tn3);
    
    float td0 = dot(p - c0, b0);
    float td1 = dot(p - c1, b1);
    float td2 = dot(p - c2, b2);
    float td3 = dot(p - c3, b3);
	
    return min(abs(td0), min(abs(td1), min(abs(td2), abs(td3))));
}

// Function 4469
float map(vec3 p)
{
	float dist = 10.;
    
    vec3 cp = p;
    vec4 hex = hexGrid(p.xy * 2. * length(p.xy * 4.));
    p.xy += (noise21(hex.zw + iTime)- .5) * .25;
    
    return length(p) - 1.;
}

// Function 4470
vec3 BakingLabACESTonemap(vec3 color, bool isInverse)
{
	const float A = 0.0245786;
    const float B = 0.000090537;
    const float C = 0.983729;
    const float D = 0.4329510;
    const float E = 0.238081;
    
    if (!isInverse)
    {
        color = (
            (color * (color + A) - B) /
            (color * (C * color + D) + E));
        color = clamp(color, 0.0, 1.0);
        
        return color;
    }
    
    color = abs(
        (
            (A - D * color) -
            sqrt(
                pow(abs(D * color - A), vec3(2.0)) -
                4.0 * (C * color - 1.0) * (B + E * color))
        ) /
        (2.0 * (C * color - 1.0))
    );
    
    return color;
}

// Function 4471
float distanceWithAspectRatio(vec2 v1, vec2 v2, float aspectRatio)
{
   vec2 t = v2 - v1; 
   return sqrt(t.x* t.x*(aspectRatio*aspectRatio)  + t.y *t.y);
}

// Function 4472
void mainCubemap( out vec4 O, vec2 U,  vec3 C, vec3 D )
{
    ivec2 I = ivec2(U)/128;                                      // tile bi-Id
    vec3 A = abs(D);
    int  f = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2,  // faceId
         s = I.x + 8*I.y,                                        // tile Id
         i = int(1023.* T( mod(U,128.) ) );                      // discretize signal
    if ( D[f] < 0. ) f += 3;                                     // full face Id.
    O = f<4 ? vec4( equal( ivec4(i), s + 64*ivec4(0,1,2,3) + 256*f )) // isolate one value within 256                                
            : vec4(T(U/R*128.),0,0,0);                           //  2 useless : free to show the image ! 

// O = .5*vec4(  ( s + 64*ivec4(0,1,2,3) + 256*f) );    // cubeMap calibration
}

// Function 4473
float map(in vec3 p) {
  float d1,d2;
  d1 = sph(p);
  d2 = plane(p);
  return min(d1,d2);
}

// Function 4474
float scene_raycast_terrain( Ray ray, float wlevel, float tmax2nd, inout float t0, inout vec3 r )
{
    bool submerged = length( ray.o ) - g_data.radius < wlevel;
    float t = 0., h = 0., alt = 0.;
    float lasth = 0., lastt = 0., lasta = 0.;
    vec4 tsmpl = vec4( 0 );
    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );
    float C0 = length( ray.o ) - g_data.radius;
    float C1 = dot( ray.o, ray.d ) / length( ray.o );
    float C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; i++ )
    {
        r = ray.o + t * ray.d;
        tsmpl = ts_sample( g_ts, iChannel1, r );
        lasta = alt;
        alt =
        #if WITH_TRN_HIGHP_RAYCAST
            t < t_switch ? C0 + t * C1 + t * t * C2 :
        #endif
            length( r ) - g_data.radius;
        lasth = h;
        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );
        if( h < 0. )
        {
            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );
            r = ray.o + t * ray.d;
            return t;
        }
        else
            if( submerged && alt >= wlevel )
            {
                if( t0 > 0. )
                    break;
                t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );
                r = ray.o + t * ray.d;
                vec3 Z = normalize( r );
                vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );
                ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );
                ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );
                ray.o = r;
                t0 = t;
                t = 0.;
            #if WITH_TRN_HIGHP_RAYCAST
                C0 = length( ray.o ) - g_data.radius;
                C1 = dot( ray.o, ray.d ) / length( ray.o );
                C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
            #endif
                alt = wlevel;
                h = wlevel - ts_sample( g_ts, iChannel1, r ).w;
            }
        lastt = t;
        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );
        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) || ( t0 > 0. && t + t0 >= tmax2nd ) )
            break;
    }
    return SCN_ZFAR;
}

// Function 4475
float cubeRotDistance(vec3 pos) {
    vec3 center = vec3(0.0, 0.0, 0.0);
    vec3 size = vec3(1.0, 1.0, 1.0);
    pos += vec3(0.0,0.0,-1.5);
    pos *= yrotate(iTime) * zrotate(iTime);
	return boxDistance(pos, center, size);
}

// Function 4476
Dst dstScene(vec3 p, bool shadow) {
 
    Dst dst = dstLightpole(p, vec3(1.3,-.25,.5));
    dst = minDst(dst, dstLightpole(p, vec3(-1.3,-.25,.5)));
    dst = minDst(dst, dstGround(p, -1., shadow));
    
    return dst;
    
}

// Function 4477
vec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax, bool refrSph) {
    vec3 res = vec3(ID_NONE);
    float t = tmin;
    for (int i = 0; i < 250; i++) {
        vec3 p = ro + rd * t;
        res = vec3(intersect(p, refrSph), t);
        float d = res.y;
        if (d < (0.001 * t) || t > tmax)
            break;
        t += 0.5 * d;
    }
    return res.xz;
}

// Function 4478
float map (vec3 p, float t) {
    vec3 b = vec3 (0.5, 2.0, 0.5);
    float r = 0.1;
 	return length(max(abs(p)-b,0.0))-r; //length(max(abs(p) - b, 0.0));
}

// Function 4479
float map(vec3 p, out float m)
{
    float dist = mapE(p, m);
    
    float cavern = -(length(p.xy * vec2(0.25, 1.0)) - 1.0) + texture(iChannel1, p.xz * 0.05).x - texture(iChannel1, p.xz * 0.25).x * 0.2;
    if(cavern < dist)
    {
        dist = cavern;
        m = 0.0;
    }
    
    return dist;
}

// Function 4480
float calcLoadDist(vec2 iResolutionxy,float limit) {
    
	vec2 chunks = floor(iResolutionxy / packedChunkSize);
    float gridSize = min(chunks.x, chunks.y);
    return min(floor((gridSize - 1.) / 2.),limit);
}

// Function 4481
MapValue map(vec3 p){
   float t  = iTime;
   mat3 R = rotationMatrix(orbit(0.2*t),0.67*t);
   float r = 0.8; 
    
   MapValue objects = sphere(p,0.3,blackMat);
   
   // Add the five platonic solids
   objects = addObjects(objects,cube( R*(p + r*orbit(t)),0.25,whiteMat));
   objects = addObjects(objects,tetrahedron(R*(p + r*orbit(t+ TWO_PI*0.2)),0.25,whiteMat));
   objects = addObjects(objects,octahedron(R*(p + r*orbit(t+ TWO_PI*0.4)),0.35,whiteMat));
   objects = addObjects(objects,dodecahedron(R*(p + r*orbit(t+ TWO_PI*0.6)),0.25,whiteMat));
   objects = addObjects(objects,icosahedron(R*(p + r*orbit(t+ TWO_PI*0.8)),0.25,whiteMat));
   
   //add a floor and a cieling
   objects = addObjects(objects,xzPlane(p,-0.75,blueMat));
   objects = addObjects(objects,xzPlane(-p,-2.0,yellowMat));
    
   return objects;
}

// Function 4482
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, bgCol, vn, lVec, rg, ff;
  vec2 qBlk, vf;
  float dstObj, a, s, fFade;
  bool fxz;
  crRad = 2.;
  crLen = 5.;
  if (repObj) bgCol = mix (0.6 * vec3 (0.4, 0.4, 0.5), vec3 (0.21), smoothstep (-0.01, 0.01, rd.y));
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    if (repObj) {
      cId = floor (ro / gSize);
      SetEngConf ();
    }
    vn = ObjNf (ro);
    qBlk = mod (2. * BlkHit (ro, reflect (rd, vn)), 1.);
    vf = vec2 (0.);
    ff = vec3 (0.);
    fFade = exp (32. * min (0., 0.7 - dstObj / dstFar));
    if (idObj == idFlr) {
      if (vn.y > 0.99) {
        col4 = vec4 (0.4, 0.4, 0.5, 0.1);
        rg = ShGrid (ro.xz, false);
        ff = vec3 (2. * ro.xz, 0.3);
        col4.rgb *= mix (1., rg.y, fFade);
        if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z * fFade);
        else vn.yx = Rot2D (vn.yx, rg.x * fFade);
        col4 *= (1. - 0.5 * smoothstep (12., 16., length (qHit.xz)));
        vf = vec2 (32., 1.);
      } else if (vn.y < -0.99) {
        col4 = vec4 (vec3 (0.3) * (1. - 0.3 * smoothstep (3., 7.,
           length (abs (qHit.xz) - 6.))), -1.);
      } else {
        col4 = vec4 (0.3, 0.3, 0.3, 0.1);
        vf = vec2 (32., 1.);
      }
    } else if (idObj == idBase) {
      col4 = (nCyl == 3) ? vec4 (0.3, 0.5, 0.6, 0.1) : ((nCyl == 2) ?
         vec4 (0.3, 0.6, 0.2, 0.1) : vec4 (0.6, 0.3, 0.2, 0.1));
      if (abs (vn.y) < 0.01) {
        rg = ro;
        rg.y += 0.5;
        fxz = (abs (vn.x) > 0.99);
        rg = ShGrid ((fxz ? rg.zy : rg.xy) * vec2 (1., 2.), true);
        col4.r *= rg.y;
        ff = vec3 (2. * (fxz ? ro.zy : ro.xy), 0.3);
        rg.xz *= sign (fxz ? vn.x : vn.z);
        if (fxz) {
          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);
          else vn.xz = Rot2D (vn.xz, rg.x);
        } else {
          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);
          else vn.zx = Rot2D (vn.zx, rg.x);
        }
      } else {
        rg = ShGrid (ro.xz, false);
        col4.r *= rg.y;
        ff = vec3 (2. * ro.xz, 0.3);
        if (vn.y > 0.99) {
          if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);
          else vn.yx = Rot2D (vn.yx, rg.x);
        }
      }
      vf = vec2 (32., 1.);
    } else if (idObj == idCol) {
      col4 = vec4 (0.8, 0.8, 0.75, 0.05);
      vf = vec2 (32., 1.);
    } else if (idObj == idCyl) {
      col4 = vec4 (0.8, 0.7, 0.7, 0.3);
      a = atan (qHit.z, - qHit.y) / (2. * pi);
      if (abs (vn.x) > 0.99) {
        ff = vec3 (4. * qHit.yz, 0.2);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.2, 0.4, 0.01, mod (16. * a + 0.5, 1.)) *
           SmoothBump (0.05, 0.13, 0.01, 1. - length (qHit.yz) / 1.5));
      } else {
        ff = vec3 (4. * vec2 (8. * a, qHit.x), 0.2);
        col4.rgb *= (1. - 0.5 * SmoothBump (0.03, 0.06, 0.01, 1. - abs (qHit.x) / 3.5));
        a = mod (32. * a, 1.);
        if (abs (qHit.x) < 3.3) vn.yz = Rot2D (vn.yz, 0.4 * SmoothBump (0.25, 0.75, 0.2, a) *
           sign (a - 0.5));
      }
    } else if (idObj == idWhl) {
      if (abs (vn.z) < 0.01) {
        s = length (qHit.xy);
        qHit.xy = vec2 (8. * atan (qHit.x, - qHit.y) / pi, qHit.z);
        if (s > 4.1) {
          s = mod (4. * qHit.z, 1.);
          vn.z = -0.2 * SmoothBump (0.25, 0.75, 0.15, s) * sign (s - 0.5) * sign (ro.z);
          vn = normalize (vn);
        }
      }
      col4 = vec4 (0.5, 0.5, 0.55, 0.05) * (1. + 0.2 * Noisefv2 (128. * qHit.xy));
    } else if (idObj == idSpk) {
      col4 = vec4 (0.55, 0.55, 0.6, 0.2);
    } else if (idObj == idCrnk) {
      col4 = vec4 (0.5, 0.5, 0.6, 0.2);
    } else if (idObj == idAx) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.3);
    } else if (idObj == idPis) {
      col4 = vec4 (0.5, 0.5, 0.2, 0.3);
    } else if (idObj == idCrod) {
      col4 = vec4 (0.6, 0.6, 0.5, 0.3);
    } else if (idObj == idCylEnt) {
      col4 = vec4 (0.7, 0.7, 0.8, 0.2) * (1. - 0.5 * step (length (qHit.yz), 0.33));
    } else if (idObj == idValv) {
      col4 = vec4 (0.7, 0.6, 0.6, 0.5) * (1. - 0.5 * step (0., vn.x) *
         step (length (qHit.yz), 0.13));
      vf = vec2 (32., 0.3);
    } else if (idObj == idPipes) {
      col4 = vec4 (0.6, 0.4, 0.1, 0.1);
      vf = vec2 (32., 0.3);
    } else if (idObj == idSup) {
      col4 = vec4 (0.4, 0.2, 0.1, 0.05);
      vf = vec2 (32., 1.);
    } else if (idObj == idRail) {
      col4 = vec4 (0.2, 0.4, 0.2, 0.1);
      vf = vec2 (32., 0.2);
    } else if (idObj == idLt) {
      qHit.xz = smoothstep (0.05, 0.1, abs (qHit.xz));
      col4 = vec4 (vec3 (1., 1., 0.8) * 0.5 * (1. - vn.y) * (0.7 + 0.3 * qHit.x * qHit.z), -1.);
    }
    if (ff.z > 0.) col4.rgb *= 1. - ff.z * Fbm2 (ff.xy);
    if (col4.a >= 0.) {
      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);
      lVec = normalize (vec3 (1., 1.3, 1.));
      col = 0.2 * col4.rgb;
      for (float sx = -1.; sx <= 1.; sx += 2.) {
        for (float sz = -1.; sz <= 1.; sz += 2.) {
          col += 0.5 * col4.rgb * max (dot (vn, lVec * vec3 (sx, 1., sz)), 0.) +
             col4.a * pow (max (dot (normalize (lVec * vec3 (sx, 1., sz) - rd), vn), 0.), 64.);
        }
      }
      col = col * (0.7 + 0.3 * ObjSShadow (ro, vec3 (0., 1., 0.))) +
         col4.a * vec3 (0.1) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *
         SmoothBump (0.25, 0.75, 0.05, qBlk.y));
    } else col = col4.rgb;
    if (repObj) col = clamp (mix (bgCol, col, fFade), 0., 1.);
  } else {
    if (repObj) {
      col = bgCol;
    } else {
      qBlk = mod (4. * BlkHit (ro, rd), 1.);
      col = vec3 (0.4, 0.5, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +
         vec3 (0.2) * (0.8 + 0.2 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *
         SmoothBump (0.25, 0.75, 0.1, qBlk.y));
    }
  }
  return col;
}

// Function 4483
float Dist2D(vec3 pos)
{
	float d=0.0;
	
	d+=Distance(pos,cama,camb,camc,camd,vec2(2.1913,15.4634),70.0000);
	d+=Distance(pos,lighta,lightb,lightc,lightd,vec2(0.3814,12.7206),17.0590);
	d+=Distance(pos,vec2(2.7377,-1.2462),vec2(-0.1914,-0.2339),vec2(-1.3698,-0.6855),vec2(0.1049,-0.1347),vec2(-1.1157,13.6200),27.3718);
	d+=Distance(pos,vec2(-2.3815,0.2382),vec2(-0.1528,-0.1475),vec2(0.9996,-2.1459),vec2(-0.0566,-0.0854),vec2(0.3287,12.1713),21.8130);
	d+=Distance(pos,vec2(-2.7424,4.8901),vec2(-0.1257,0.2561),vec2(-0.4138,2.6706),vec2(-0.1355,0.1648),vec2(2.8162,14.8847),32.2235);
	d+=Distance(pos,vec2(-2.2158,4.5260),vec2(0.2834,0.2319),vec2(4.2578,-2.5997),vec2(-0.0391,-0.2070),vec2(2.2086,13.0546),30.9920);
	d+=Distance(pos,vec2(0.9824,4.4131),vec2(0.2281,-0.2955),vec2(-0.6033,0.4780),vec2(-0.1544,0.1360),vec2(3.2020,12.2138),29.1169);
	d+=Distance(pos,vec2(1.2733,-2.4752),vec2(-0.2821,-0.1180),vec2(3.4862,-0.7046),vec2(0.0224,0.2024),vec2(-2.2714,9.7317),6.3008);
	d+=Distance(pos,vec2(2.6860,2.3608),vec2(-0.1486,0.2376),vec2(2.0568,1.5440),vec2(0.0367,0.1594),vec2(-2.0396,10.2225),25.5348);
	d+=Distance(pos,vec2(0.5009,0.9612),vec2(0.1818,-0.1669),vec2(0.0698,-2.0880),vec2(0.1424,0.1063),vec2(1.7980,11.2733),35.7880);
	
	return d;
}

// Function 4484
float map(vec3 p){
  
    p.xy -= path(p.z); // Wrap the scene around a path.

    p += cos(p.zxy*1.5707963)*.2; // Perturb slightly. The mutation gives it a bit more of an organic feel.

    // If you're not familiar with a gyroid lattice, this is basically it. Not so great to hone in on, but
    // pretty cool looking and simple to produce.
    float d = dot(cos(p*1.5707963), sin(p.yzx*1.5707963)) + 1.;

	// Biotube lattice. The final time-based term makes is heave in and out.
    float bio = d + .25 +  dot(sin(p*1. + iTime*6.283 + sin(p.yzx*.5)), vec3(.033));

    // The tunnel. Created with a bit of trial and error. The smooth maximum against the gyroid rounds it off
    // a bit. The abs term at the end just adds some variation via the beveled edges. Also trial and error.
    float tun = smaxP(3.25 - length(p.xy - vec2(0, 1)) + .5*cos(p.z*3.14159/32.), .75-d, 1.) - abs(1.5-d)*.375;;// - sf*.25;


    objID = step(tun, bio); // Tunnel and biolattice IDs, for coloring, lighting, bumping, etc, later.

    return min(tun, bio); // Return the distance to the scene.

 
}

// Function 4485
Intersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)
{
    float t;
    int hitObj;
    march(eye, dir, t, hitObj, lightPos);

    vec3 isect = eye + t * dir;
    vec3 nor = computeNormal(isect, lightPos);
    vec3 lightDir = normalize(lightPos - isect);
    
    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));
    
    return Intersection(t, surfaceColor, isect, hitObj);
}

// Function 4486
float sdFloor(vec3 p)
{
    return sdBox(p+vec3(-NUM,NUM,-NUM)*.5, vec3(NUM * .5));
}

// Function 4487
float map(vec3 p)
   {
       //p = fract(p);
     p.y+=sin(p.z*2.+iTime)/200.;
      p.x+=sin(p.y*2.+iTime)/200.;
    float re = 0.0;
       float scale = 1.;
       
       for(int i=0; i<2 ;i++)
       {
        
        scale*=3.;
        re = max(re, -rcScale(p, scale)  );

       }
        
    return re;//rect(p, vec3(2.5));
    }

// Function 4488
float SdfRDodeca(Object obj, vec3 pos){
    pos = pos - obj.pos;

    vec3 normals[6];
    float dists[6];
    float signs[6];

    // The rhombic dodecahedron has 6 pairs of opposite faces.
    // Assign a normal to each pair of faces.
    normals[0] = vec3(1.  ,   0.           , 0.          );
    normals[1] = vec3(0.5 ,   0.           , sqrt3 / 2.  );
    normals[2] = vec3(0.5 ,   0.           , - sqrt3 / 2.);
    normals[3] = vec3(0.  , - sqrt2 / sqrt3, 1. / sqrt3  );
    normals[4] = vec3(0.5 ,   sqrt2 / sqrt3, sqrt3 / 6.  );
    normals[5] = vec3(0.5 , - sqrt2 / sqrt3, - sqrt3 / 6.);

    // Compute the distance to each face (the sign tells which face of the pair of faces is closest)
    for (int i = 0; i < 6; i++){
        dists[i] = dot(normals[i], pos);
        signs[i] = sign(dists[i]);
        dists[i] = max(0., abs(dists[i]) - obj.scale.x);
    }

    bool sorted = false;
    while(!sorted){
        sorted = true;
        for (int i = 0; i < 5; i++){
            if (dists[i] < dists[i+1]){
                vec3 n = normals[i];
                float d = dists[i];
                float s = signs[i];
                normals[i] = normals[i+1];
                dists[i] = dists[i+1];
                signs[i] = signs[i+1];
                normals[i+1] = n;
                dists[i+1] = d;
                signs[i+1] = s;
                sorted = false;
            }
        }
    }
    
    if (dists[1] < dists[0] * 0.5){
        // case where the closest point is on a face
        return dists[0];
    }
    else if (max(dists[2], dists[2] + dists[3]) < 0.35 * (dists[0] + dists[1])){
        // case where the closest point is on an edge
		// the faces play symmetrical roles. This implies a symmetrical matrix
		float f = 4. / 3.;
		float g = -2. / 3.;
        vec2 v = vec2(f);
        mat2 m = mat2(v, v) + mat2(g - f);
        vec2 w = m * vec2(dists[1], dists[0]);
        return length( w.x * signs[0] * normals[0]
                     + w.y * signs[1] * normals[1]);
    }
    else if (dists[2] > 0.35 * (dists[0]+dists[1]) && dists[3] == 0.){
        // case where the closest point is on a vertex shared by three faces
        float f = 0.35 * 2.38;
		float g = -0.49 * 2.38;
        vec3 v = vec3(f);
        mat3 m = mat3(v, v, v) + mat3(g - f);
        vec3 w = m * vec3(dists[2], dists[1], dists[0]);
        return length( w.x * signs[0] * normals[0]
                     + w.y * signs[1] * normals[1]
                     + w.z * signs[2] * normals[2]);
    }
    else {
		// case where the closest point is on a vertex shared by four faces
        float f = 0.3756;
		float g = -0.628;
        vec4 v = vec4(f);
        mat4 m = mat4(v, v, v, v) + mat4(g - f);
        vec4 w = m * vec4(dists[3], dists[2], dists[1], dists[0]);
        return length( w.x * signs[0] * normals[0]
                     + w.y * signs[1] * normals[1]
                     + w.z * signs[2] * normals[2]
                     + w.w * signs[3] * normals[3]);
    }
}

// Function 4489
float map(vec3 rp){
    vec3 sp = rp/length(rp);
    vec3 cell = floor(sp*60.);
    vec2 index = floor(iResolution.xy*hash23(cell));
    vec3 ABc = vec3(0);
    vec3 d;
    for(d.x = -1.; d.x <= 1.; d.x++){
        for(d.y = -1.; d.y <= 1.; d.y++){
            for(d.z = -1.; d.z <= 1.; d.z++){
                if(dot(d,d)==0.) d.z++;
                vec2 neighborIndex = floor(iResolution.xy*hash23(cell+d));
                vec4 neighbor = texelFetch(iChannel0, ivec2(neighborIndex),0);
                vec3 neighborp = vec3(sin(neighbor.x)*cos(neighbor.y),sin(neighbor.y),cos(neighbor.x)*cos(neighbor.y));
                float s = exp(-100.*length(neighborp-sp));
                ABc += vec3(neighbor.zw,1)*s;
            }
        }
    }
    ABc /= max(.01,ABc.z);
    return min(length(rp)-1.-ABc.x*.10+ABc.y*.01,10.-length(rp));
}

// Function 4490
float rmap(vec3 uv, RSet3 rs) {
    return RAND(map(uv, rs.q, rs.l), rs.r);
}

// Function 4491
hit traceSceneThickness(in ray r) {
    //trace objects only
    hit ret = nullHit;
    tlt(ret, trace(r, pln1));
    tlt(ret, trace(r, sph1));
	return ret;
}

// Function 4492
float hitScene(vec3 camPos, vec3 ray) {
    return min(hitPlane(camPos, ray), hitSphere(camPos, ray));
}

// Function 4493
vec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )
{
    vec2 vEdgeDir = sideDef.vB - sideDef.vA;
    vec2 vOA = sideDef.vA - vRayPos;
    float fDenom = Cross2d( vRayDir, vEdgeDir );
    float fRcpDenom = 1.0 / fDenom;
    
    vec3 vHitTUD;
    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;
    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;
    vHitTUD.z = fDenom;
    
    return vHitTUD;    
}

// Function 4494
float map(vec3 rp){
    float d = 999.;
    
    rp.xy*=rot(rp.z*.23);
    vec3 p = rp, p0 = rp;
    
    float tId = floor(p.z / sep);
    float to = hash11(tId*999.)*5.;
   
    p.y -= cos(tId*2.) * .2;
    float tX = iTime*.78 * sign(cos(tId*4.))*min(to, .8);
    
    float trackHeight = h(p.x + to);
    
    p.zy = mod(p.zy, sep)-sep*.5;
    p.y += trackHeight;
    
    p.x = mod(p.x, 0.2)-0.2*.5;
    d = min(line(p, vec3(0., 0., -tw), vec3(0., 0., tw), 0.01), d);
    p.xy*=rot(3.14/2.);
    d = min(rcyl(ref(p, vec3(0., 0.0, tw)), .006, .001, .2), d);
    
    p = p0;
    p.y -= cos(tId*2.) * .2;
    p.x -= tX;
    
    float cId = floor(p.x);
    
    float carHeight = h(tX + cId + cs.x*2. + .35 + to);
    float trackDer = hp(tX + cId + cs.x*2. + .35 + to);
    
    p.x = mod(p.x, 1.)-1.*.5;
    p.zy = mod(p.zy, sep)-sep*.5;
    
    p.xy *= rot(trackDer);
    p.y += carHeight - cs.y + .11;
    
    d = min(rbox(p + vec3(0., 0., 0.), cs, 0.05), d);
    
    return d;
}

// Function 4495
float light_map(vec3 p, float time)
{
    float sd = sdSphere(p - vec3(-10.*cos(0.0*time),-10.*cos(0.0*time), 5.), 1.);
    //sd = min(sd, sdSphere(p - vec3(5.*cos(0.8*iTime+3.14),5.*sin(0.8*iTime+3.14), 2.), 0.5));
    return sd;
}

// Function 4496
vec2 map1ds(vec2 z)
{
  float r = length(z);
  float t = atan(z.y,z.x);
   if (t < -.25*PI) t += 2.0*PI;
    
   if (t < .25*PI) {
      return vec2(r,(4.0/PI)*r*t );
    } 
    else if (t < .75*PI) {
      return vec2(-(4.0/PI)*r*(t-.5*PI), r);
    } 
    else if (t < 1.25*PI) {
      return vec2(-r, -(4.0/PI)*r*(t-PI));
    } 
    else {
      return vec2((4.0/PI)*r*(t-1.5*PI), -r);
    }
}

// Function 4497
float coeffDistPoint(vec2 uv,vec2 colPoint,float scale)
{    
    //float dist = length(uv - colPoint) * scale;
    //dist = pow(dist,0.25);
    //dist = 1.0 - smoothstep(0.0,1.0,dist);
    
    vec2 uv_ = (uv - colPoint)*scale*24.0;
    float dist = dot(uv_,uv_);
    return  1.0 / ( 1.0 + dist );
}

// Function 4498
SurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, WaveInfo wave, SceneResult traceResult, int insideObjId )
{
    SurfaceInfo surfaceInfo;
    
    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);
    
    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos, insideObjId ); 
    
    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;
    surfaceInfo.vAlbedo = vec3(1.0);
#if SPECTRAL    
    surfaceInfo.cR0 = PathColor( 0.02 );
#endif
#if RGB
    surfaceInfo.cR0 = PathColor( vec3( 0.02 ) );
#endif
    
    surfaceInfo.fGloss = 1.0;
    surfaceInfo.cEmissive = PathColor_Zero();
    surfaceInfo.fTransparency = 0.0;
    

    
    if ( traceResult.iObjectId == MAT_WINE )
    {
        surfaceInfo.fTransparency = 1.0;
        surfaceInfo.fGloss = 1.0;
    }
    
    if ( traceResult.iObjectId == MAT_COLORLESS_GLASS )
    {
        surfaceInfo.fGloss = 1.0;
        surfaceInfo.vAlbedo = vec3(0.01);
        surfaceInfo.fTransparency = 1.0;
    }

    if ( traceResult.iObjectId == MAT_FROSTED_GLASS )
    {
        surfaceInfo.fGloss = 0.3;
        surfaceInfo.vAlbedo = vec3(0.01);
        surfaceInfo.fTransparency = 1.0;        
    }
    
    if ( traceResult.iObjectId == MAT_COLORED_GLASS )
    {
        surfaceInfo.fGloss = 0.5;
        surfaceInfo.fTransparency = 1.0;
    }

    if ( traceResult.iObjectId == MAT_COLORED_GLASS_2 )
    {
        surfaceInfo.fGloss = 1.0;
        surfaceInfo.fTransparency = 1.0;
    }    
    
    if ( traceResult.iObjectId == MAT_TEXTURED_FLOOR )
    {
    	surfaceInfo.vAlbedo = textureLod(iChannel2, traceResult.vUVW.xy, 0.0 ).rgb;
        surfaceInfo.fGloss = 1.0 - clamp( surfaceInfo.vAlbedo.r * 1.8 - 0.5, 0.0, 1.0);
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        
        //surfaceInfo.vAlbedo = vec3(0.25);
        
        
        /*
        // The floor is lava
        float t = 1.0 - surfaceInfo.vAlbedo.r;
        surfaceInfo.cEmissive = BlackBody(wave, 2200.0 * t * t, 3e-9);
        surfaceInfo.vAlbedo *= 1.0 - t;
        */
    }
    
    if ( traceResult.iObjectId == MAT_STAND )
    {
    	surfaceInfo.vAlbedo = textureLod(iChannel2, traceResult.vUVW.xy, 0.0 ).rgb;
        surfaceInfo.fGloss = 1.0 - clamp( surfaceInfo.vAlbedo.r * 2.8 - 0.3, 0.0, 1.0);
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        surfaceInfo.vAlbedo *= vec3(1.0, 0.4, 0.2);
        
        //surfaceInfo.vAlbedo = vec3(0.25);
        
        
        /*
        // The floor is lava
        float t = 1.0 - surfaceInfo.vAlbedo.r;
        surfaceInfo.cEmissive = BlackBody(wave, 2200.0 * t * t, 3e-9);
        surfaceInfo.vAlbedo *= 1.0 - t;
        */
    }    
    
    if ( traceResult.iObjectId == MAT_EMISSIVE_LIGHT || traceResult.iObjectId == MAT_FILAMENT )
    {
        float t = 6500.0;
        float i = 3e-12;                
        
        if ( mod( surfaceInfo.vPos.x, 20.0) < 10.0 )
        {
            t += 2000.0;
        }
        else
        {
            t -= 1000.0;
        }
        
        if ( traceResult.iObjectId == MAT_FILAMENT )
        {
            t = 6500.0 - 3000.0;
            i = 3e-10;            
        }
            
        
        if ( traceResult.vUVW.z > 1.5 || traceResult.vUVW.z < -1.5 || traceResult.vUVW.y > 5.0 )
        {
            i = 0.0;
            surfaceInfo.fGloss = 1.0f;
		    surfaceInfo.cR0 = PathColor_One();
        }
        
        surfaceInfo.cEmissive = BlackBody( wave, t, i );
    }

    if ( traceResult.iObjectId == MAT_CHROME )
    {
    	surfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;
        surfaceInfo.fGloss = 1.0;        
		surfaceInfo.cR0 = PathColor_One();
    }

    
#if PIPELINE_SCENE    
    if ( traceResult.iObjectId == MAT_PIPE )
    {
    	//surfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;
        //surfaceInfo.fGloss = 1.0;        
        
    	surfaceInfo.vAlbedo = textureLod(iChannel2, traceResult.vUVW.xy, 0.0 ).rgb;
        surfaceInfo.fGloss = 1.0 - clamp( surfaceInfo.vAlbedo.r * 1.8 - 0.5, 0.0, 1.0);
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        
        //surfaceInfo.fGloss = pow( surfaceInfo.fGloss, 0.1);
        
        
		//surfaceInfo.cR0 = PathColor_One();        
    }    
    
    
    if ( traceResult.iObjectId == MAT_GRASS )
    {
    	surfaceInfo.vAlbedo = textureLod(iChannel2, traceResult.vUVW.xy, 0.0 ).rgb;
        surfaceInfo.fGloss = 1.0 - clamp( surfaceInfo.vAlbedo.r * 1.8 - 0.5, 0.0, 1.0);
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        
        surfaceInfo.vAlbedo = mix( vec3(0.4, 0.5, 0.1) * 0.1, vec3( 0.6, 0.8, 0.05), surfaceInfo.vAlbedo );
        
        //surfaceInfo.vAlbedo = vec3(0.25);
        
        
        /*
        // The floor is lava
        float t = 1.0 - surfaceInfo.vAlbedo.r;
        surfaceInfo.cEmissive = BlackBody(wave, 2200.0 * t * t, 3e-9);
        surfaceInfo.vAlbedo *= 1.0 - t;
        */
    }     
#endif    
    
#if GEARS_SCENE    
    if ( traceResult.iObjectId == MAT_GEAR )
    {
    	//surfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;
        //surfaceInfo.fGloss = 1.0;        
        
    	surfaceInfo.vAlbedo = textureLod(iChannel2, traceResult.vUVW.xy * 4.0 + vec2(0.0, 0.5), 0.0 ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        surfaceInfo.vAlbedo.g *= 0.5;
        surfaceInfo.vAlbedo.b *= 0.2;
        surfaceInfo.vAlbedo *= 0.5;

        float fDirt = textureLod(iChannel2, traceResult.vUVW.yx * 5.0 + 0.25, 0.0 ).b;        
        fDirt = clamp( fDirt * 3.0 - 0.4, 0.0, 1.0);
        //fDirt = 1.0;

        float fGloss = textureLod(iChannel2, traceResult.vUVW.yx * 3.0, 0.0 ).g;
        
        fGloss = fGloss * fGloss;
        
        surfaceInfo.fGloss = mix( fGloss, 1.0, fDirt );
        
        surfaceInfo.vAlbedo = mix( vec3(0.1), surfaceInfo.vAlbedo, fDirt);
        
        //surfaceInfo.cR0 = PathColor_One();        
        //surfaceInfo.fGloss = pow( surfaceInfo.fGloss, 0.1);
        
        surfaceInfo.cR0 = ColorScale_sRGB( wave, mix( vec3( 0.6, 0.55, 0.5 ), vec3(0.02), fDirt) );
    }       
#endif    
    
    
   

    if ( traceResult.iObjectId == MAT_GOLD )
    {
    	surfaceInfo.vAlbedo = vec3(0.9, 0.5, 0.05) * 0.1;
        surfaceInfo.fGloss = 1.0;        
		surfaceInfo.cR0 = PathColor_One();
        
        surfaceInfo.cR0 = ColorScale_sRGB( wave, vec3( 0.9, 0.5, 0.05 ) );
    }    
    if ( traceResult.iObjectId == MAT_WHITE_GLOSS )
    {
    	surfaceInfo.vAlbedo = vec3(0.9, 0.9, 0.9);
        surfaceInfo.fGloss = 1.0;        
    }    
    
    if ( traceResult.iObjectId == MAT_PENDANT )
    {
    	surfaceInfo.vAlbedo = vec3(0.9, 0.9, 0.9);
        surfaceInfo.fGloss = 1.0;        
        if ( traceResult.vUVW.y > 2.0 && traceResult.vUVW.y < 2.1 )
        {
	    	surfaceInfo.vAlbedo = vec3(0.3);
        }    
    }
    
    if ( traceResult.iObjectId == MAT_WHITE_MATT )
    {
    	surfaceInfo.vAlbedo = vec3(1.0, 1.0, 1.0);
        surfaceInfo.fGloss = 0.0;        
    }    
    
    return surfaceInfo;
}

// Function 4499
float PrTorusDf (vec3 p, float ri, float rc)
{
  return length (vec2 (length (p.xy) - rc, p.z)) - ri;
}

// Function 4500
vec2 mapRMDetailed(vec3 p) {
    vec2 d = vec2(-1.0, -1.0);
    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);
    //d = opU(d, vec2(mapWaterDetailed(p-vec3(0.0, WATER_LEVEL, 0.0)), TYPE_WATER));
    //d = opU(d, vec2(sdBox(p-BOATPOS, vec3(1.0, 1.0, 1.0)), TYPE_BOAT));
    return d;
}

// Function 4501
float cubeSDF(vec3 p) {
    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z
    // So if all components of d are negative, then p is inside the unit cube
    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);
    
    // Assuming p is inside the cube, how far is it from the surface?
    // Result will be negative or zero.
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    
    // Assuming p is outside the cube, how far is it from the surface?
    // Result will be positive or zero.
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance;
}

// Function 4502
float SDF_Giants(vec3 point)
{
    float sdf = FarClip;
    
    float upperLegsR = saturate(length(point - LegPoints[0]) / length(LegPoints[1] - LegPoints[0]));
	float lowerLegsR = saturate(length(point - LegPoints[1]) / length(LegPoints[2] - LegPoints[1]));
    
    float head = length(point - vec3(-1.0, -1.11, 0.0)) - 0.175;
    
    float legs = min(sdCapsule(point, LegPoints[0], LegPoints[1], mix(0.075, 0.05, upperLegsR)),
                     sdCapsule(point, LegPoints[1], LegPoints[2], mix(0.05, 0.025, lowerLegsR)));
    
    float arms = min(sdCapsule(point, ArmPoints[0], ArmPoints[1], 0.05),
                     sdCapsule(point, ArmPoints[1], ArmPoints[2], 0.04));
    
    
    sdf = min(head, min(arms, legs));
    
    return sdf;
}

// Function 4503
SDFResult sinkSDF( vec3 p )
{
    SDFResult res = SDFResult(TOO_FAR, MAGEN);  
    vec3 orig = vec3(2.0, -1.0, 1.0);        

    vec3 centre = vec3(0.0, 1.0, 0.0)+orig;
    const float radius = 1.3;
    if (length(p-centre) < radius) 
    {   
        // pedestal
        res = roundboxSDF(RoundBox(vec3(0.0, 0.2, 0.4)+orig, vec3(0.2, 0.6, 0.1), 0.1, WHITE), p);
        // bowl 
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.2, 0.2)+orig, vec3(0.5, 0.2, 0.15), 0.15, WHITE), p), res, 0.1);
        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 1.7, 0.2)+orig, vec3(0.5, 0.2, 0.15), 0.15, MAGEN), p), res, 0.1);
        // base
        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.0, 0.6)+orig, vec3(0.3, 0.05, 0.35), 0.05, WHITE), p), res, 0.1);
        // taps
#ifdef STUFF2
		res = opSmoothAdd(tapsSDF(p), res, 0.01);
#endif //STUFF2
    }
    return res;
}

// Function 4504
vec3 Tonemap_Uchimura_RGB(vec3 v) {
  return vec3(Tonemap_Uchimura(v.r), Tonemap_Uchimura(v.g), Tonemap_Uchimura(v.b));
}

// Function 4505
vec4 map(vec3 p, inout float scale) {
  if (doinvert) {
    float c = cos(0.25*iTime);
    float r = 1.0/c;
    float r2 = r*r;
    p.x -= r-c;
    float k = r2/dot(p,p);
    p *= k;
    scale *= k;
    p.x += r-c;
  }
  vec4 p4 = iproject(p);
  return p4;
}

// Function 4506
float sdf_shell(vec3 p, float scale) {
	vec3 fp = fold(p * scale);
	float dist = dot(fp, normalize(sign(fp))) - .0 - sin(fp.y*.2)*2. - sin(fp.y*.5)*1.;
    //g+=(0.1/(.01+dist*dist*999.) * sin(iTime  * .5));
    
	dist += min(fp.x*1., sin(fp.y*.4)) + fbm(fp )* .03;
	//g+=(0.1/(.01+dist*dist*995.) * sin(iTime  * .5));
	fp = fold(fp) - vec3(.4, 2, -2.3);
	fp = fold(fp) - vec3(.8, 1, .1);
	fp = fold(fp) - vec3(0, .3, 0);
	dist += sin(fp.y*.1)*.1;
    
	dist *= 1.;
	//g+=(0.1/(.01+dist*dist*9995.));// * sin(iTime  * .5));
    
	return dist / scale;
}

// Function 4507
float map (vec3 pos) {
    vec3 camOffset = vec3(-4,0,0.);

    float scene = 1000.;
    vec3 p = pos + camOffset;
    float segments = PI*radius;
    float indexX, indexY, salt;
    vec2 seed;

    // donut distortion
    vec3 pDonut = p;
    pDonut.x += donut;
    pDonut.y += radius;
    pDonut.xz = displaceLoop(pDonut.xz, donut);
    pDonut.z *= donut;
    pDonut.xzy = pDonut.xyz;
    pDonut.xz *= rot(time*.05*speed);

    // ground
    p = pDonut;
    scene = min(scene, sdCylinder(p.xz, radius-height));

    // walls
    p = pDonut;
    float py = p.y + time * speed;
    indexY = floor(py / (cell+thin));
    p.y = repeat(py, cell+thin);
    scene = min(scene, max(abs(p.y)-thin, sdCylinder(p.xz, radius)));
    amod(p.xz, segments);
    p.x -= radius;
    scene = min(scene, max(abs(p.z)-thin, p.x));

    // horizontal windot
    p = pDonut;
    p.xz *= rot(PI/segments);
    py = p.y + time * speed;
    indexY = floor(py / (cell+thin));
    p.y = repeat(py, cell+thin);
    indexX = amodIndex(p.xz, segments);
    amod(p.xz, segments);
    seed = vec2(indexX, indexY);
    salt = rng(seed);
    p.x -= radius;
    vec2 dimension = vec2(.75,.5);
    p.x +=  dimension.x * 1.5;
    scene = max(scene, -sdBox(p, vec3(dimension.x, .1, dimension.y)));
    scene = min(scene, window(p.xzy, dimension, salt));

    // vertical window
    p = pDonut;
    py = p.y + cell/2. + time * speed;
    indexY = floor(py / (cell+thin));
    p.y = repeat(py, cell+thin);
    indexX = amodIndex(p.xz, segments);
    amod(p.xz, segments);
    seed = vec2(indexX, indexY);
    salt = rng(seed);
    p.x -= radius;
    dimension.y = 1.5;
    p.x +=  dimension.x * 1.25;
    scene = max(scene, -sdBox(p, vec3(dimension, .1)));
    scene = min(scene, window(p, dimension, salt));

    // elements
    p = pDonut;
    p.xz *= rot(PI/segments);
    py = p.y + cell/2. + time * speed;
    indexY = floor(py / (cell+thin));
    p.y = repeat(py, cell+thin);
    indexX = amodIndex(p.xz, segments);
    amod(p.xz, segments);
    seed = vec2(indexX, indexY);
    salt = rng(seed);
    p.x -= radius - height;
    scene = min(scene, boxes(p, salt));

    return scene;
}

// Function 4508
float sdf_Y(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, 0, 0), vec3(4, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, -4, 0), vec3(2, -8, 0)));
    return t;
}

// Function 4509
vec3 draw3DScene(Cam perspectiveCam, Cam sceneCam, vec2 uv, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad)
{
    vec3 o = sceneCam.O;
    vec3 d = ray(uv,sceneCam);
    
    vec3 cScene = vec3(0);
    
    float t = rayPlaneIntersec(o,d, vec3(0,-1.0,0), vec3(0,1,0));
    if(t<0.0)
    {
        t = 1000.0;
        cScene = apply_atmosphere(t,vec3(1),o+t*d);
    }
    else
    {
		vec3 pFloor = o+t*d;
    	vec3 cFloor = texture(iChannel1,pFloor.xz*0.25).xyz;
    	cScene = apply_atmosphere(t,cFloor,pFloor);
    }
    
    float fZoom = 3.0*iResolution.x/1920.;
    vec2 aDebug = camProj(sceneCam,wsQuad.a);
    vec2 bDebug = camProj(sceneCam,wsQuad.b);
    vec2 cDebug = camProj(sceneCam,wsQuad.c);
    vec2 dDebug = camProj(sceneCam,wsQuad.d);
    vec2 oDebug = camProj(sceneCam,perspectiveCam.O);
    cScene = drawPoint(uv,aDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,bDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,cDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,dDebug,cScene,vec3(1,0,0),0.005, fZoom);
    cScene = drawPoint(uv,oDebug,cScene,vec3(0,0,1),0.005, fZoom);
    cScene = drawLine(uv,aDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,bDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,cDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,dDebug,oDebug,cScene,vec3(0,0.8,1),0.0025, fZoom);
    cScene = drawLine(uv,aDebug,bDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,bDebug,cDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,cDebug,dDebug,cScene,vec3(0),0.0025, fZoom);
    cScene = drawLine(uv,dDebug,aDebug,cScene,vec3(0),0.0025, fZoom);
    
    //Projection Plane (camera near plane)
    float tImage = rayPlaneIntersec(o,d, perspectiveCam.O+normalize(perspectiveCam.D), perspectiveCam.D);
    if(tImage>0.0) //tImage < 0 when the ray never intersects the floor plane (intersection happens behind camera)
    {
        vec3 pImage = o+tImage*d;
        vec2 uv = camProj(perspectiveCam,pImage);
        
        if(abs(uv.x)<0.5 && abs(uv.y)<0.5*iResolution.y/iResolution.x)
        {
            vec3 cPersp = drawPerspectiveScene(perspectiveCam, uv, ssQuad, wsQuad, vec3(0.55), fZoom*0.1);
            cScene = alphaBlend(cScene,cPersp,0.5);
        }
    }
    
    //
    vec3 nQuad = cross((wsQuad.b-wsQuad.a),(wsQuad.d-wsQuad.a));
    float tQuad = rayPlaneIntersec(o,d, wsQuad.a, nQuad);
    if(tQuad>0.0) //tQuad < 0 when the ray never intersects the floor plane (intersection happens behind camera)
    {
        vec2 uv = findParallelogramUV(o,d,wsQuad);
        if(uv.x>0.0 && uv.x<1.0 &&
           uv.y>0.0 && uv.y<1.0 )
        {
            vec2 tuv = inversePerspective_uv(perspectiveCam, uv, ssQuad, wsQuad);
        	vec3 cTest = drawPerspectiveScene(perspectiveCam, tuv, ssQuad, wsQuad, vec3(0.55), fZoom*0.25);
            cScene = alphaBlend(cScene,cTest,0.5);
        }
    }
    
    return cScene;
}

// Function 4510
Hit traceScene(Ray ray)
{
    Hit hit;
    hit.t = t_max;
   
   if(traceSphere(ray,sphereBounding0).hit == true)
   {
    	hit = compareHit(hit,traceSphere(ray,sphere0));
    	hit = compareHit(hit,traceSphere(ray,sphere1));
    	hit = compareHit(hit,traceSphere(ray,sphere2));
    	hit = compareHit(hit,traceSphere(ray,sphere3));
    	hit = compareHit(hit,traceSphere(ray,sphere4));
   		//hit = compareHit(hit,traceSphere(ray,sphere6));
     	//hit = compareHit(hit,traceSphere(ray,sphere7));
   }
    
    hit = compareHit(hit,traceSphere(ray,sphere5));
   

    return hit;   
}

// Function 4511
vec4 mapColor(vec3 c){
  Shape lobby = LincolnLobby(c);
  return lobby.color;
}

// Function 4512
vec4 distanceMetric(vec4 px, vec4 py, uint metric)
{
    switch (metric)
    {
        case 0u:
            // squared euclidean
            return px * px + py * py;
        case 1u:
            // manhattam   
            return abs(px) + abs(py);
        case 2u:
            // chebyshev
            return max(abs(px), abs(py));
        default:
            // triangular
            return max(abs(px) * 0.866025 + py * 0.5, -py);
    }
}

// Function 4513
float getDistBox( vec3 p, vec3 b )
{
  vec3 d = abs(p) - b;
  return length(max(d,0.0))
         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf 
}

// Function 4514
float map(vec3 p)
{
    float rep = 5.5;
    float idx = float(int((p.x+rep*.5)/rep))*15.;
    float rep2 = 5.;
    float ht = sin(float(int((p.z+iTime*15.+rep2*.5)/rep2))*15.);
    p.z = mod(p.z+iTime*15.+rep2*.5,rep2)-rep2*.5;
    p.x = mod(p.x+rep*.5, rep)-rep*.5;
    
    return sdBox(p-vec3(0.,.5+0.8*sin(idx+3.8), 0.), vec3(.4, 2.+ht*.5+.5, .3), idx);
}

// Function 4515
float dist(vec3 p)
{
    p.x=abs(p.x);
    vec3 p0=p;
    // torus
    float d=10000.,d2;
    p=p0-vec3(-p.y*.02,0,0);
    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);
    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);
    yfall=mix(yfall,yfall2,step(0.,-p.z));
    d2=distBoxR(p,vec3(BodySize.xz,100).xzy*.5*vec3(exp(-abs(p.y)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),max(.02,-1.*p.z-.07*p.y));
    d=min(d,d2);
    d2=dot(p-.5*BodySize*vec3(.55,0,1.+.15*yfall),normalize(vec3(.8,0,1.-.9*yfall)));
    d=max(d,d2);
    
    // hood
    vec3 n=normalize(vec3(0,1,2.5));
    float dpx=max(p.x-1.,-.5);
    float dpy=max(p.y-.9+.4*dpx,0.);
    vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);
    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);
    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));
    d=max(d,d2);
    
    p-=vec3(0,-1.6,.5);
    d2=distBoxR(p+vec3(0,0,-p.y*.12),vec3(BodySize.x*.25*1.1-p.y*.2+p.z*.4,1,.3),.02);
    d=max(d,-d2);

    d2=abs(p0.y)-BodySize.y*.5;
    d=-smin_(-d,-d2,.01);

    vec3 p1;
    p1=BodySize*.5*vec3(1, .59,-.65);
    p2=BodySize*.5*vec3(1,-.63,-.65);
    d=max(d,-distCylR((p0-p1).yzx,.35,.8,.05));
    d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));
    d=min(d,distCylR((p0-p1-vec3(-.17,0,.04)).yzx,.31,.27,.08));
    d=min(d,distCylR((p0-p2-vec3(-.12,0,.04)).yzx,.31,.27,.08));
    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));

    p=p0-vec3(p.y*.02,0,0);
    
    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;
    //d=min(d,d2);
    return d;
}

// Function 4516
float torusSDF( vec3 p, float r, float thickness ){
  vec2 q = vec2(length(p.xz)-r,p.y);
  return length(q)- thickness;
}

// Function 4517
float Map( in vec3 p)
{
    d,d1,d2,d3,d4,d5,d6,d7,d8,d9 = 100000.0;
    
  d8 = ControllerBase(p, vec3(0, -0.51, 1.0), 1.05);
  d = ControllerBase(p, vec3(0, -0.3, 1.0), 1.0);

  // button ring
  d=  max(d, -sdCappedCylinder(p-vec3(-1.45, -0.22, 1.0), vec2(0.8, 0.02)));
  d8=  min(d8, sdCappedCylinder(p-vec3(-1.45, -0.25, 1.0), vec2(0.765, 0.03)));
  d8=  min(d8, sdEllipsoid(p-vec3(-1.45, -0.25, 1.0), vec3(0.7, 0.1, 0.7)));

  // button holes
  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, 1.40), vec3(0.32, 0.06, 0.32)));
  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, .60), vec3(0.32, 0.06, 0.32)));
  d8=  max(d8, -sdEllipsoid(p-vec3(-1.90, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));
  d8=  max(d8, -sdEllipsoid(p-vec3(-1.00, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));

  // buttons
  d2= sdCappedCylinder(p-vec3(-1.45, -0.3, 1.40), vec2(0.18, 0.12));
  d9= sdCappedCylinder(p-vec3(-1.45, -0.3, 0.60), vec2(0.18, 0.12));
  d2= min(d2, sdCappedCylinder(p-vec3(-1.90, -0.3, 1.0), vec2(0.18, 0.12)));
  d9= min(d9, sdCappedCylinder(p-vec3(-1.0, -0.3, 1.0), vec2(0.18, 0.12)));

  // button details       
  d2=  max(d2, -sdEllipsoid(p-vec3(-1.45, -0.16, 1.40), vec3(0.25, 0.04, 0.25)));
  d9=  max(d9, -sdEllipsoid(p-vec3(-1.45, -0.16, .60), vec3(0.25, 0.04, 0.25)));
  d2=  max(d2, -sdEllipsoid(p-vec3(-1.90, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));
  d9=  max(d9, -sdEllipsoid(p-vec3(-1.0, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));

  // cross cutout
  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(0.7, 0.1, 0.7)));
  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(1.0, 0.03, 1.0)));
  d3 = sdEllipsoid(p-vec3(1.55, -0.265, 1.0), vec3(.46, 0.06, .46));

  // cross
  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.4, 0.06, 0.13)));
  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.13, 0.06, 0.4)));

  // cross details
  d3=  max(d3, -sdEllipsoid(p-vec3(1.55, -0.2, 1.0), vec3(0.16, 0.04, 0.16)));

  // calculate button arrows and perform boolean
  vec3 pPos = p-vec3(1.55, -0.13, 1.25);
  pPos.xz *=rotate(radians(120.0));
  pPos.zy *=rotate(radians(90.0));
  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));

  pPos = p-vec3(1.55, -0.13, 0.75);
  pPos.xz *=rotate(radians(300.0));
  pPos.zy *=rotate(radians(90.0));
  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));

  pPos = p-vec3(1.8, -0.13, 1.0);
  pPos.xz *=rotate(radians(210.0));
  pPos.zy *=rotate(radians(90.0));
  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));

  pPos = p-vec3(1.3, -0.13, 1.0);
  pPos.xz *=rotate(radians(30.0));
  pPos.zy *=rotate(radians(90.0));
  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));

  // cable input
  d=max(d, -sdCapsule(p-vec3(.0, -0.4, 2.1), vec3(0.0, 0.0, -0.5), vec3(0.0, 0.0, 3.0), 0.13));   
  d=min(d, sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, -0.1), vec3(0.0, 0.0, -0.1), 0.11));   

  // cable
  d4 = sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, 0), vec3(0.0, 0.0, 0), 0.11);       
  d4=min(d4, Cable(p-vec3(.0, -0.4, 2.1), vec3(0., 0., -1.0), vec3(0., 0., 70.0), 0.072));   

  // analog buttons
  d= max(d, -sdEllipsoid(p-vec3(0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));
  d= max(d, -sdEllipsoid(p-vec3(-0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));

  d5=  sdEllipsoid(p-vec3(0.35, -0.35, .50), vec3(0.3, 0.18, 0.3));
  d5= min(d5, sdCappedCylinder(p-vec3(0.35, -0.35, .50), vec2(0.15, 0.3)));
  d5=  min(d5, sdEllipsoid(p-vec3(0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));

  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.35, .50), vec3(0.3, 0.18, 0.3)));
  d5= min(d5, sdCappedCylinder(p-vec3(-0.35, -0.35, .50), vec2(0.15, 0.3)));
  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));

  // start select cutouts
  d=max(d, -sdCapsule(p-vec3(-.1, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   
  d=max(d, -sdCapsule(p-vec3(.45, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   

  // start select buttons
  d7=sdCapsule(p-vec3(-.1, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095);   
  d7=min(d7, sdCapsule(p-vec3(.45, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095));   

  d6 = ShoulderButtons(p, d, vec3(0, -0.3, 1.0), 1.0);

    
  return  min(d,min(d2,min(d3,min(d4,min(d5,min(d6,min(d7,min(d8,min(d9,p.y+0.75)))))))));
}

// Function 4518
float DistSq( mat4 MG,  float s, vec3 p )
{
	vec3 spline_pos = Spline_Evaluate(MG, s );
	vec3 d = spline_pos - p;		
	float dist_sq = dot(d,d);
	return dist_sq;
}

// Function 4519
float distanceFunc(vec3 p)
{	

	// distance to sphere
    float d = length(p) - _SphereRadius;
	// offset distance with noise
	d += fbm(p*_NoiseFreq + _NoiseAnim*iTime) * _NoiseAmp;
	return d;
}

// Function 4520
void initScene() {
    //init lights
    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );
	lights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );
	lights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );
	lights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );
    
    float moveSize = 0.7;
    float a = 0.0;
    float speed = 2.0;
    float val;
    
    //1
    val = a+iTime*speed;    
    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //2
    val = a+iTime*speed;    
    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //3
    val = a+iTime*speed;    
    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //4
    val = a+iTime*speed;    
    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);
    a += 0.4;
    
    //init walls
    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );
    //walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );
    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );
    
#ifdef SHOW_PLANES
    //init planes
    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );
    planes[0].abcd = vec4( planeNormal, 3.8 );
    planeZRanges[0].min_ = -5.8;
    planeZRanges[0].max_ = -5.0;
    
    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );
    planes[1].abcd = vec4( planeNormal, 2.8 );
    planeZRanges[1].min_ = -4.8;
    planeZRanges[1].max_ = -4.0;
    
    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );
    planes[2].abcd = vec4( planeNormal, 1.8 );
    planeZRanges[2].min_ = -3.8;
    planeZRanges[2].max_ = -3.0;
#endif
}

// Function 4521
vec4 nmapu(vec4 x){ return x*.5+.5; }

// Function 4522
float height_map( vec2 p )
{
	 mat2 m = mat2( 0.9563*1.4,  -0.2924*1.4,  0.2924*1.4,  0.9563*1.4 );
	 
	 p = p*6.;
	 
	 float 
	 f  = 0.6000*seaNoise( p );  p = m * p * 1.10;
	 f += 0.2500*seaNoise( p );  p = m * p * 1.32;
	 f += 0.1666*seaNoise( p );  p = m * p * 1.11;
	 f += 0.0834*seaNoise( p );  p = m * p * 1.12;
	 f += 0.0634*seaNoise( p );  p = m * p * 1.13;
	 f += 0.0444*seaNoise( p );  p = m * p * 1.14;
	 f += 0.0274*seaNoise( p );  p = m * p * 1.15;
	 f += 0.0134*seaNoise( p );  p = m * p * 1.16;
	 f += 0.0104*seaNoise( p );  p = m * p * 1.17;
	 f += 0.0084*seaNoise( p );  p = m * p * 1.18;
	 f += 0.0064*seaNoise( p );
	
	 return clamp(f*2.0, 0., 10.);
}

// Function 4523
float flakeDistance(vec3 p){
    
    const float snowflakeMaxDist = 20.0;
    if ( (abs(p.x) > snowflakeMaxDist) || (abs(p.y) > snowflakeMaxDist) || (abs(p.z) > snowflakeMaxDist) ) return 9999.9;
    
    float snowPush = 1.25*iTime;
    
    p.x += snowPush*-10.0;
    p.y += snowPush*1.5;
    p.z += snowPush*-0.25;
    
    const float modDist = 4.0;
    
    float stepX = floor(p.x/modDist);
    float stepY = floor(p.y/modDist);
    float stepZ = floor(p.z/modDist);
    
    vec3 flakeP = vec3(
        mod(p.x,modDist),
        mod(p.y,modDist),
        mod(p.z,modDist)
    );
    
    vec3 flakePos = vec3(modDist*0.5);
    
    flakePos.x += sin(snowPush+stepY*1.0)*(2.0/5.0)*modDist;
    flakePos.y += sin(snowPush+stepZ*1.3)*(2.0/5.0)*modDist;
    flakePos.z += sin(snowPush+stepX*1.7)*(2.0/5.0)*modDist;
	
    
    return obj_ball(flakeP, flakePos, 0.08);
    
}

// Function 4524
float heightMap(in vec3 p){

    // The stone texture is tileable, or repeatable, which means the pattern is slightly
    // repetitive, but not too bad, all things considered. Note that the offscreen buffer 
    // doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].
    //return Voronoi(p.xy*2.);//texture2D(texChannel0, fract(p/2.), -100.).w;
    
    const float sc = 1.;
    vec4 h = getHex(p.xz*sc, -p.y*sc);
    
    v2Rnd = h.zw;
    
    gLitID = h.y;
        
    return h.x/sc;

}

// Function 4525
vec3 colormapInferno(float t) {
    return vec3(
        1.0 - (t - 1.0)*(t - 1.0),
        t*t,
        t * (3.0*t - 2.0)*(3.0*t - 2.0)
    );
}

// Function 4526
float dist2seg(vec2 pos, vec2 P0, vec2 P1) {
	if (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }
	vec2 P0P1 = P1-P0, P0Pos = pos-P0;
	float d, l2_01=dist2(P0,P1);

	// --- if projection out of segment bounds, dist to extremity
	// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)
	float l = dot(P0Pos, P0P1)/l2_01;
	if      (l <= 0.) return distance(pos,P0);
	else if (l >= 1.) return distance(pos,P1);

	// --- dist to seg = dist to line
	else if (SIGNED_DIST) 
	    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }
	else return distance(pos, P0+l*P0P1);
}

// Function 4527
Intersection sdf3D(vec3 eye, vec3 dir) {
    float t;
    int objectHit;
    march(eye, dir, t, objectHit);
    vec3 isect = eye + t * dir;
    
    vec3 nor = computeNormal(isect);
    
    vec3 lightPos = vec3(0, 20, -8);
    
    vec3 color = vec3(.7, .9, 1);
    
    if (objectHit != -1) {
    	color = computeMaterial(objectHit, isect, nor, lightPos, normalize(eye - isect));
        
       	// don't cast shadow for grass, eyes and mouth on face because they look weird
        if ((objectHit < 21 || objectHit > 24) && objectHit != MOUTH_ID && objectHit != HEAD_ID && objectHit != GRASS_ID) { 
            color *= shadow(normalize(lightPos - isect), isect, 14.0, int(abs(lightPos - isect)) + 40);
        }
    } 
    
    return Intersection(t, color, isect, objectHit);
}

// Function 4528
float getDist(vec3 p){   
    float disp = fbm(p.xz*0.08);
    //return disp;
    return (p.y+disp*50.)*.3;
}

// Function 4529
vec3 sceneNorm(vec3 p)
{
   float d = sceneDist(p);
   return normalize(vec3(sceneDist(p + EPS.xyy) - d, sceneDist(p + EPS.yxy) - d,
                           sceneDist(p + EPS.yyx) - d));
}

// Function 4530
vec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}

// Function 4531
float sdFace1(vec3 p) {
    vec3 pArch = vec3( min(abs(p.x),abs(p.z)), p.y, max(abs(p.x),abs(p.z)) );
    float dO = sdArchA(HALF_OUTER_DIAM, HALF_OUTER_DIAM, pArch);
    float dI = sdArchB(HALF_INNER_DIAM, HALF_INNER_DIAM, pArch);

    return min(dI, dO);
}

// Function 4532
vec3 aces_tonemap(vec3 x){	
	
    
	return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;;
}

// Function 4533
Result resultSDF(vec3 p)
{
    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), TOO_FAR, TOO_FAR, 0.0, g_magen);
    SDFResult res2 = SDFResult(TOO_FAR, MAGEN);
    res2 = sceneSDF(p);

    // normal calculation
    result.normal = vec3(0.0);
    for( int i=min(iFrame,0); i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);
        result.normal += e*sceneSDF(p+EPSILON*e).dist;
    }
    result.normal = normalize(result.normal);        
    
    SDFResult res = SDFResult(TOO_FAR, MAGEN);    
    res = sceneSDF(p);
                
    result.mat=g_mats[res.matindex];
        
    result.pos = p;
    result.t = res2.dist;
    return result;
}

// Function 4534
vec2 GetDistanceMirrorFrame( const in vec3 vPos )
{
	float fDistanceOuterFrame = GetDistanceBox(vPos, vMirrorGlassSize + vec3(fMirrorFrameSize)) - 0.2;
	float fDistanceFrameHole = GetDistanceBox(vPos + vec3(0.0, 0.0, fMirrorFrameSize * 2.0), vMirrorGlassSize + vec3(0.0, 0.0, fMirrorFrameSize * 2.0));
	
	float fDistance = max(fDistanceOuterFrame, -fDistanceFrameHole);
	
	return vec2(fDistance, kMaterialWood);
}

// Function 4535
float GetDist(vec3 p) 
{
	vec4 s = MAINSPHERE;
    
    float sphereDist =  length(p-s.xyz)-s.w;
    float d=sphereDist;
    
	float sphere2Radius = 0.25;
	for(int i=0;i<SUBSPHERE_COUNT;i++)
    {
		vec4 secSpj = secondaries[i] ;
		float secondarySphereDist = length(p- secSpj.xyz - MAINSPHERE.xyz)-secSpj.w;
		d = smin(d, secondarySphereDist, .1);
    }
    
    return d;
}

// Function 4536
float SDF_EyeSocket(vec3 p)
{
    float m  = sign(p.x);              // We are either sampling the left or right socket based on p.x
    float r  = 0.06 + abs(p.x) * 0.5;  // Socket size increases as we move along x
    float xa = 0.25 * m;
    float xb = 0.4 * m;
    
    return sdCapsule(p, vec3(xa, 0.2, 1.0), vec3(xb, 0.25, 1.0), r);
}

// Function 4537
float sceneMaterial(vec3 p)
{
    p=p.xzy;

    float material2=step(mountains(p),2.0)*2.0;

    // Name=Brush1247
    float material_d=min(cuboid(p,vec3(-16.00,-992.00,688.00),vec3(224.00,-864.00,2208.00)),
                         cuboid(p,vec3(384.00,-992.00,688.00),vec3(624.00,-864.00,2208.00)));

    // Name=Brush72
    material_d=min(material_d,smallerTower(p.xzy));

    return max(material2,max(step(material_d,1.0+step(-1600.0,p.y)),step(7640.0,p.z)));
}

// Function 4538
float sdf_nail(vec2 uv, vec2 top, vec2 size)
{
    const float head_flat_frac = .02;
    const float head_round_frac = .08;
    const float body_thickness = .5;

    float h = clamp((top.y - uv.y) / size.y, 0., 1.);
    float w = (h < head_flat_frac) ? 1. :
        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :
    	h > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;
    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));
}

// Function 4539
vec2
map( in vec3 pos )
{    
    float angle4 = iTime*TAU*0.25;
    
    MPt res;
    res.distance = 1e38;

    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );
    res = union_op( MPt( plane_sd( pos ),
                         MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m ),
                    res );
    
    const float axis_r = 0.05;
    res = union_op( MPt( sphere_sd( axis_r*2.0, at_pos( vec3(0.0), pos ) ),
                         MAT_PLASTIC ), res );
    res = union_op( MPt( cline_sd( vec3(0.0), vec3(1.0,0.0,0.0), axis_r, pos ),
                         MAT_RED ),res );
    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,1.0,0.0), axis_r, pos ),
                         MAT_GREEN ),res );
    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,0.0,1.0), axis_r, pos ),
                         MAT_BLUE ),res );
    
    
    
    
    // NOTE(theGiallo): light
    float lamp_r = 0.2, pole_hh=0.5;
    vec3 lp = repeated( rep,at_pos( point_light_pos + vec3(0.0,0.0,0.15), pos ));
    res =
       union_op(
           MPt( capped_cylinder_sd( vec2(0.02,pole_hh) , at_pos( vec3(0.0,0.0,lamp_r+pole_hh),lp ) ), MAT_PLASTIC ),
           res
       );
    res =
       union_op(
           intersect_op(
              subtract_op(
                 MPt( sphere_sd(
                         lamp_r-0.01, lp
                      ), MAT_PLASTIC
                    ),
                 MPt( sphere_sd(
                         lamp_r, lp
                      ), MAT_PLASTIC
                    )
               ),
               MPt( aab_sd( vec3(lamp_r*2.0), at_pos( vec3(0.0,0.0,lamp_r),lp) ), MAT_PLASTIC )
            ), res );
    
    vec3 op = pos;
    pos = repeated( vec3(0.0,4.0,0.0), pos );
    
    // NOTE(theGiallo): tunnel section
    float X = 12.0;
    vec3 P = at_pos(vec3(X,0.0,2.5), pos );
    res =
       union_op(
          subtract_op(
             union_op(
                MPt( capped_cylinder_sd (vec2(2.0,5.0),
                                         at_angle( vec3(HPI,0.0,0.0),
                                                   P ) ), MAT_TUNNEL_WALL_W ),
                intersect_op(
                   MPt( capped_cylinder_sd (vec2(2.05,0.25),
                                            at_angle( vec3(HPI,0.0,0.0),
                                                      repeated( vec3(0.0,1.0,0.0),
                                                                P ) ) ), MAT_ORANGE ),
                   MPt( aab_sd(vec3(5.0,4.0,3.0),at_pos(vec3(0.0,0.0,1.0),P) ), MAT_TUNNEL_WALL_W ) )
                ),
             MPt( aab_sd(vec3(5.0,4.05,5.0),P ), MAT_TUNNEL_WALL_W )
          ),
          res );

    // NOTE(theGiallo): grid
    res =
       union_op(
          subtract_op(
             MPt( aab_sd( vec3(0.02,0.02,0.1),
                          repeated( vec3(0.02,0.02,0.0), at_angle( vec3(0.0,0.0,QPI),
                                    at_pos( vec3(X,0.0,1.0),
                                            pos) ) ) ), MAT_METAL_GRID ),
             MPt( aab_sd(vec3(2.5,4.0,0.02),at_pos(vec3(X,0.0,1.0),pos) ), MAT_METAL_GRID )
          ),
          res );

    
    pos = op;
    
    

	return res;
}

// Function 4540
float GetDistanceCylinderZ(const in vec3 vPos, const in float r)
{
	return length(vPos.xy) - r;
}

// Function 4541
float distline(vec3 ro, vec3 rd, vec3 p) {
	return length(cross(p-ro, rd));
}

// Function 4542
CastRes DistFunc(CastRes d)
{
	#define SEL_OBJ(oid) if(dd < d.dist) {d.dist = dd; d.id = oid;}
	float dd;		
	d.id = ID_NONE;
	d.dist = length(d.pos);
	
	if(d.pos.y > 5.){
	
		return d;
	}
	
	dd = sdHPlane(d.pos, 0.0);
	float wave = cos(d.pos.z)*0.6 + 0.1, wave1 = cos(d.pos.x)*0.5+0.3;
	float rv = wave  + wave1 + noise(d.pos);
	dd += -1.5 + rv + rand(d.pos)*0.00007;//sin(1.1*d.pos.x) * sin(1.1*d.pos.y) * sin(0.7*d.pos.z);
	SEL_OBJ(ID_PLANE);
	sp_pos = vec3(1.+2.0*cos(time), 1.0 + 1.0*cos(time), 0.0+2.0*sin(time));
	dd = sdSphere(d.pos - sp_pos, 0.15);
	
	SEL_OBJ(ID_SPHERE);	
	
	vec3 dt = vec3(0);
	dd = opU(opU(sdSphere(d.pos - vec3(1.0, 0, 0.0)+dt, 0.5), sdSphere(dt+d.pos - vec3(1.0, 0.7, 0.0), 0.4)),sdSphere(dt + d.pos - vec3(1.0, 1.3, 0.0),0.3));
	dd += rand(d.pos)*0.00001;
	 
	SEL_OBJ(ID_SNEG);
	
	dd =  sdSphere(dt + d.pos - vec3(1.1, 1.3, 0.3), 0.05);
	dd = opU(dd, sdSphere(dt + d.pos - vec3(0.9, 1.3, 0.3), 0.05));		
	SEL_OBJ(ID_EYE);
		
	dd = opI( sdCone(dt + d.pos - vec3(1., 1.25, 0.6), normalize(vec2(0.5,0.1))), -sdPlane( dt + d.pos - vec3(2, 2.25, -0.1), normalize(vec4(0 ,0, 0.5, 0))) );
	dd = opI(opU(dd, sdCone(dt + d.pos - vec3(1., 2.4, 0), vec3(0.6,0.12, 0.9))), sdPlane(dt +  d.pos - vec3(2, 1.8, -0.1), normalize(vec4(0 ,1, 0.0, 0))));
	SEL_OBJ(ID_CONE);
	
	vec3 q = d.pos; // generate army of fir-tree
	q += vec3(-2.0, 0.0, -2.0);	
	q.x = mod(q.x, 4.);
	q.z = mod(q.z, 4.);
    q -= vec3(2.0, 0.0, 2.0);

	q.x = abs(q.x);  // mirror in X	

	
	dd = sdCylinder(q - vec3(2.0, 0.0, 0.0), vec2(.2, 2.0));
	SEL_OBJ(ID_STVOL);
	
	
	dd = sdCone(q - vec3(2.0, 2.4, 0.0), vec3(0.6,0.4,0.5));
	dd = opU(dd, sdCone(q - vec3(2.0, 2.14, 0.0), vec3(0.4,0.3,0.6)));
	dd = opU(dd, sdCone(q - vec3(2.0, 1.69, 0.0), vec3(0.3,0.3,0.6)));      
   		
	SEL_OBJ(ID_ELKA);
	
return d;
}

// Function 4543
float planeSdf( vec3 p )
{
    return p.z;
}

// Function 4544
vec3 map_Ssph_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return reflect(rd, nrm);
}

// Function 4545
float SeaMap(in vec2 pos)
{

	return SeaFBM(pos) * (20.0 + cloudy*170.0);
}

// Function 4546
vec2 SdScene(vec3 p)
{
    float uniformRandom = UniformHashFromPos(p);
    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),
							vec3(0.25, 0.25, 0.1), uniformRandom);
    return SdUnion(vec2(SdPlane(p), 1.0), 
                   vec2(
                       SdSmoothMin(
                           SdSmoothMin(
                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),
                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2)
		     	    	   ),
                       	   SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19)
                       ),
                       2.0
                   )
           );
}

// Function 4547
vec3 cubemapColor(vec3 raydir)
{
    return vec4(texture(iChannel1, raydir).rgb, 1.0).xyz;
}

// Function 4548
vec3 Scene_GetNormal(const in vec3 vPos, const int iInsideObject)
{
    const float fDelta = 0.001;
    vec2 e = vec2( -1, 1 );
    
    vec3 vNormal = 
        Scene_GetDistance( vPos + e.yxx * fDelta, iInsideObject ).fDist * e.yxx + 
        Scene_GetDistance( vPos + e.xxy * fDelta, iInsideObject ).fDist * e.xxy + 
        Scene_GetDistance( vPos + e.xyx * fDelta, iInsideObject ).fDist * e.xyx + 
        Scene_GetDistance( vPos + e.yyy * fDelta, iInsideObject ).fDist * e.yyy;
    
    if ( dot( vNormal, vNormal ) < 0.00001 )
    {
        return vec3(0, 1, 0);
    }
    
    return normalize( vNormal );
}

// Function 4549
hit scene(vec4 o, vec4 d, inout vec3 col){
    // initialize hit
    hit h = hit(1e20, vec4(0), vec4(0));
    
    // balls
    for(int i=0; i<4; i++){
        vec4 b = vec4(0);
        b[i] = 1.;
        hit nh = ball(o, d, b, 0.1);
        if(nh.t<h.t){
            h = nh;
            col = poleColors[i];
        }
    }
    
    // antipodal balls
    for(int i=0; i<4; i++){
        vec4 b = vec4(0);
        b[i] = -1.;
        hit nh = ball(o, d, b, 0.1);
        if(nh.t<h.t){
            h = nh;
            col = poleColors[i+4];
        }
    }
    
    // "axis"
    int c = 0;
    for(int i=0; i<4; i++){
    	for(int j=i+1; j<4; j++){
            vec4 a = vec4(0);
            vec4 b = vec4(0);
            a[i] = 1.;
            b[j] = 1.;
            hit nh = axis(o, d, a, b, 0.05);
            if(nh.t<h.t){
                h = nh;
                col = axisColors[c];                
            }
            c++;
        }
    }
    
    return h;
}

// Function 4550
float distanceToSurface(Point3 P, out float AO) {
	// Rotate the query point into the reference frame of the function
	P = rotation * P;
	AO = 1.0;
	
	// Sample distance function for a sphere:
	// return length(P) - 1.0;
	
	// Unit rounded box (http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)
	//return length(max(abs(P) - 1.0, 0.0)) - 0.1;	
	
	// This is a 3D analog of the 2D Mandelbrot set. Altering the mandlebulbExponent
	// affects the shape.
	// See the equation at
	// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/	
	Point3 Q = P;
	
	// Put the whole shape in a bounding sphere to 
	// speed up distant ray marching. This is necessary
	// to ensure that we don't expend all ray march iterations
	// before even approaching the surface
	{
		const float externalBoundingRadius = 1.2;
		float r = length(P) - externalBoundingRadius;
		// If we're more than 1 unit away from the
		// surface, return that distance
		if (r > 1.0) { return r; }
	}

	// Embed a sphere within the fractal to fill in holes under low iteration counts
	const float internalBoundingRadius = 0.72;

	// Used to smooth discrete iterations into continuous distance field
	// (similar to the trick used for coloring the Mandelbrot set)	
	float derivative = 1.0;
	
	for (int i = 0; i < ITERATIONS; ++i) {
		// Darken as we go deeper
		AO *= 0.725;
		float r = length(Q);
		
		if (r > 2.0) {	
			// The point escaped. Remap AO for more brightness and return
			AO = min((AO + 0.075) * 4.1, 1.0);
			return min(length(P) - internalBoundingRadius, 0.5 * log(r) * r / derivative);
		} else {		
			// Convert to polar coordinates and then rotate by the power
			float theta = acos(Q.z / r) * power;
			float phi   = atan(Q.y, Q.x) * power;			
			
			// Update the derivative
			derivative = pow(r, power - 1.0) * power * derivative + 1.0;
			
			// Convert back to Cartesian coordinates and 
			// offset by the original point (which we're orbiting)
			float sinTheta = sin(theta);
			
			Q = Vector3(sinTheta * cos(phi),
					    sinTheta * sin(phi),
					    cos(theta)) * pow(r, power) + P;
		}			
	}
	
	// Never escaped, so either already in the set...or a complete miss
	return minimumDistanceToSurface;
}

// Function 4551
vec2 map(in vec3 pos)
{
	 
	vec2 res = opU(vec2(sdPlane(pos) + dunes(pos) , 1.0),
				   vec2( 
					   sdSphere(    
						   pos-vec3( 0.0,dunes(pos)-.6, 0.0 - iTime + pn(pos)),
						   0.025 ),
					46.9 ) );
	return res;
}

// Function 4552
vec2 mapSnail( vec3 p, out vec4 matInfo )
{
    vec3 head = vec3(-0.76,0.6,-0.3);
    
    vec3 q = p - head;

    // body
#if 1
    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );
    float d1 = b1.x;
    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));
    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );
    float d2 = b1.x;
    d2 -= 0.1 - 0.06*b1.y;
    d1 = smin( d1, d2, 0.03 );
    matInfo.xyz = b1.yzw;
#else
    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.11,0.0), head+vec3(0.05,0.01-0.02,0.0), p );
    float d1 = b1.x;
    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.75*0.07*smoothstep(0.5,1.0,b1.y));
    matInfo.xyz = b1.yzw;
    float d2;
#endif
    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );
    d1 = smin( d1, d2, 0.03 );
    
    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );
    
    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;

    vec3 sq = vec3( q.xy, abs(q.z) );
    
    // top antenas
    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );
    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );
    float d3 = b2.x;
    d3 -= 0.03 - 0.025*b2.y;
    d1 = smin( d1, d3, 0.04 );
    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );
    d1 = smin( d1, d3, 0.01 );    
    
    // bottom antenas
    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );
    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );
    d3 = b3.x;
    d3 -= 0.025 - 0.02*b3.y;
    d1 = smin( d1, d3, 0.06 );
    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );
    d1 = smin( d1, d3, 0.02 );
    
    // bottom
    vec3 pp = p-vec3(-0.17,0.15,0.0);
    float co = 0.988771078;
    float si = 0.149438132;
    pp.xy = mat2(co,-si,si,co)*pp.xy;
    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );
    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );
    
    // disp
    float dis = textureLod( iChannel1, 5.0*p.xy, 0. ).x;
    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));
    d1 -= 0.005*dis*dx*0.5;
        
    return vec2(d1,1.0);
}

// Function 4553
float sphere_sdf( vec3 p, vec3 c, float r)
{
  return length(p - c) - r;
}

// Function 4554
vec2 map(vec3 p){
    vec2 res = vec2(1e5,0.);
    float cutbox = cap(p, 7.,5.);

    vec3 q = p;
    q.xz*=turn;
 
    float gdens = 1.35, g1 = 0.;

    g2 = sdGry(q, gdens*8., .028, .2);
    g5 = sdGry(q, gdens*7., .058, .2)*.5;

    g1 = sdGry(q, gdens, .008, .5);
    g1 = max(g1-.05,g2);

    g1 = max(cutbox,g1*.5); 
    if(g1<res.x&&uv.x>dz) {
        res=vec2(g1,1.);
        hit=q;
    }

    g1 = sdGry(q, gdens, .02, .8);
    g1 = max(g1,g5);
    
    g1 = max(cutbox,g1*.5); 
    if(g1<res.x&&uv.x>-dz) {
        res=vec2(g1,2.);
        hit=q;
    }
    
    g1 = sdGry(q, gdens, .098, 1.15);
    g1 = max(g1,g5);
    
    g1 = max(cutbox,g1*.5); 
    if(g1<res.x) {
        res=vec2(g1,3.);
        hit=q;
    }
 
    return res;
}

// Function 4555
vec3 Tonemap(const TonemapParams tc, vec3 x)
{
	vec3 toe = - tc.mToe.x / (x + tc.mToe.y) + tc.mToe.z;
	vec3 mid = tc.mMid.x * x + tc.mMid.y;
	vec3 shoulder = - tc.mShoulder.x / (x + tc.mShoulder.y) + tc.mShoulder.z;

	vec3 result = mix(toe, mid, step(tc.mBx.x, x));
	result = mix(result, shoulder, step(tc.mBx.y, x));
	return result;
}

// Function 4556
float equidistantPoint(vec3 d, object o0, object o1)
{
    
    return 0.;
}

// Function 4557
float sceneSDF(vec3 p) {
    p /= scale*3000.0;

    float
        size1 = 1100.0,
    	i = 1.0;
    for(int j = 0; j < iterations; j++){
        i *= multiplier;
        p += sin(p.yzx*i)/i/(1.0+length(sin(p*i+iTime)));

    }
    return vines(p,size1)/(i)/10.0;
}

// Function 4558
float scenedist(vec3 p){ // this defines what is actually in the scene
	float s1 = length(p)-1.; 				// this is just a sphere
	float s2 = length(p-vec3(.8, 0., 0.))-.5;
	return min(s1,s2); // add them together (like boolean OR)
    // min combines them because it will return the distance to the closest, the other is irrelevant right?
	// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)
}

// Function 4559
vec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {

	vec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;

	// makes the quadri convex if not: the 4 turns must have same sign.
	//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:
	// all same, 1 different ('>'), 2 + then 2 - ('X').
	// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.

	// measure turns direction
#define ssign(v) (((v)>=0.) ? 1 : -1)
	int t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),	
		t2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));
	if (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside
		{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } 
	else  FLIP = false;
	int t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.
	
	float d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), 
		  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);
	// take care: dji != -dij at extremities since must be always positive outside
	float d0, d1;
	
	if ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30
			{ d0 = amin( amin( d01, d12 ), d23);	d1 = d30; } 

	else {
	  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);
	  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;

	  if (t==0)         // --- 'X' shape
		if(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320
		    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }
			  d0 = amin(d01,d13);					d1 = amin(d02,d23); }
	    else 	    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30
			{ d0 = amin( amin( d02, d21 ), d13);	d1 = d30; }		

	  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle
		if (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30
			{ d0 = amin( d02, d23);					d1 = d30; }
		else if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30
			{ d0 = amin( d01, d13);					d1 = d30; }
		else              // it's P0 or P3: in facts, that's fine.
			{ d0 = amin( amin( d01, d12 ), d23);	d1 = d30; }
	  }

	return vec2( amin(d0,d1), amax(d0,d1) );
}

// Function 4560
float sdf_exclude(float from, float what)
{
    return max(from, -what);
}

// Function 4561
vec3 aces_tonemap(vec3 color){	
	vec3 v = m1 * color;
    //vec3 v = color;
	vec3 a = v * (v + 0.0245786) - 0.000090537;
	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
	return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));	
    //return pow(clamp((a / b), 0.0, 1.0), vec3(1.0 / 2.2));	
}

// Function 4562
float hexSDF(vec2 st){
    st = abs(st*2.-1.);
    return max(abs(st.y), st.x * 0.866025 + st.y*0.5);
}

// Function 4563
vec3 Heatmap(float x) {
    vec3 t = vec3(4, 2, 0) - 4.0 * x;
    return x * clamp(2.0 - abs(t), 0.0, 1.0);
}

// Function 4564
float SphereDist(vec3 p, vec3 c, float r)
{
    return length(p - c) - r;
}

// Function 4565
float chess_dist(vec2 uv) {
    return max(abs(uv.x),abs(uv.y));
}

// Function 4566
float sceneSDF(const int scene, in vec3 p, out int material)
{
    // default
    material = MAT_SNOW;
    
    switch (scene) {
    case SCENE_INTERIOR:
        return globeInteriorSDF(p, material);
    case SCENE_EXTERIOR:
        return exteriorSDF(p, material);
	case SCENE_SNOWFLAKES:
        return fallingSnowSDF(p, material);
    }
}

// Function 4567
float distTorus(vec3 p, float R, float r)
{
    return length(p-vec3(normalize(p.xy),0)*R)-r;
}

// Function 4568
float combinedDistanceOnly(vec3 pos) {
	mat3 d = combinedDistance(pos);
    return d[0].x;
}

// Function 4569
float sdf_particle(vec3 p){
    return length(p.xy)-.02;
    float z=p.z*7.+iTime;
    p.xy*=mat2(cos(z*1.3),sin(z*1.3),-sin(z*1.3),cos(z*1.3));
    p.yz*=mat2(cos(z*1.7),sin(z*1.7),-sin(z*1.7),cos(z*1.7));
    p.zx*=mat2(cos(z*2.1),sin(z*2.1),-sin(z*2.1),cos(z*2.1));
    p=abs(p);
    //return max(max(p.x,p.y),p.z)-.02;
    return length(p)-.02;
}

// Function 4570
float sdf_torus(vec3 p, vec2 t)
{
    vec2 q = vec2(length(p.xz)-t.x,p.y);
    return length(q)-t.y;
}

// Function 4571
float sdf2(in vec2 p) {
    p.x -= 0.45;
    float frac = fract(iTime);
    p.y -= frac * (1.0 - frac) - 0.1;
    Rotate(p, -2.0 * iTime);
    float a = 0.25;
    return sdHorseshoe(p, vec2(sin(a), cos(a)), vec2(0.2, 0.1), 0.2);
}

// Function 4572
float MapGlass(  vec3 p)
{  
  vec3 checkPos = p;

  float dist = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.02, .8));
  checkPos.xz = pModPolar(p.xz, 6.0);
  dist = min(dist, sdBox(checkPos-vec3(1.60, 1.1, 0.), vec3(0.01, .60, 0.35)));   
  checkPos.xz = pModPolar(p.xz, 5.0);
  dist = min(dist, sdBox(checkPos-vec3(1.84, -3.33, 0.), vec3(0.01, 0.30, .3))); 
  return min(dist, sdBox(checkPos-vec3(2.12, -6.83, 0.), vec3(0.01, 0.30, .3)));
}

// Function 4573
void SceneResult_Combine( inout SceneResult inside, inout SceneResult outside, SceneResult newObject, int insideObj )
{
    if ( newObject.iObjectId == insideObj )
    {
	    outside = SceneResult_Subtract( outside, newObject );
    }
    else
    {
	    inside = SceneResult_Union( inside, newObject );
    }    
}

// Function 4574
float sdfInterval(float a, float b, float x) {
    return abs(x - 0.5*(a+b)) - 0.5*(b-a);
}

// Function 4575
vec2 map(vec3 p) {
    vec2 d = vec2(-1.0, -1.0);
    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);
    //d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));
    return d;
}

// Function 4576
Dist distToScene(vec3 p) {
 
    float s    = sin(iTime);
    float c    = cos(iTime);
    vec3  bp   = vec3(0.,0.,2.3) + (vec3(c,s,0.)*vec3(.6));
    
    float ball = distBall(p, vec3(0.,0.,2.), .2);
    float box  = distBox (p, bp, vec3(.3));
    
    return Dist(smin(ball, box, 32.), 0);
    
}

// Function 4577
float NormalDistributionGGX(float NdotH, float roughness)
{    
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH2 = NdotH * NdotH;
    
    float numerator = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom *= denom * PI;
    
    return numerator / denom;
}

// Function 4578
void ColorScene(inout rayIntersect rIntersec)
{
	#ifndef DEBUG_NO_TERRAIN
    	//if(rIntersec.mat.microsurface - 0.5 < 1.0)
    {
        rIntersec.mat.albedo = vec3(244.0, 164.0, 96.0)/255.0;//vec3(0.929412, 0.788235, 0.686275);
        rIntersec.mat.reflectivity = 0.9;
        rIntersec.nor = CalcTerrainNormal(rIntersec.mPos, rIntersec.dist);
        return;
    }

    rIntersec.nor = vec3(0.0, 1.0, 0.0);
    
    #endif
}

// Function 4579
float distriGGX (in vec3 N, in vec3 H, in float roughness) {
    float a2     = roughness * roughness;
    float NdotH  = max (dot (N, H), .0);
    float NdotH2 = NdotH * NdotH;

    float nom    = a2;
    float denom  = (NdotH2 * (a2 - 1.) + 1.);
    denom        = PI * denom * denom;

    return nom / denom;
}

// Function 4580
float map(vec3 p)
{
    p.y += height(p.zx);
    float d = p.y+.5;
    
    d = smin(d, vine(p+vec3(.8,0.,0),30.,3.3) );
    d = smin(d, vine(p.zyx+vec3(0.,0,17.),33.,1.4) );
    d += Noise3d(p*.05)*(p.y*1.2);
    p.xz *=.2;
    d+= Noise3d(p*.3);
    return d;
}

// Function 4581
float CappedCylinderSDF( vec3 p, vec2 h )
{
  vec2 d = abs(vec2(length(p.xz),p.y)) - h;
  return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}

// Function 4582
float distanceToSegment( vec2 a, vec2 b, vec2 p )
{
	vec2 pa = p - a;
	vec2 ba = b - a;
	float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
	
	return length( pa - ba*h );
}

// Function 4583
vec2 mapUnderWater(vec3 p) {
    vec2 d = vec2(-1.0, -1.0);
    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);
    d = opU(d, vec2(mapSand(p-vec3(0.0, FLOOR_LEVEL, 0.0)), TYPE_SAND));
    return d;
}

// Function 4584
vec3 map( vec3 p )
{
	float k = 1.0;
	float m = 1e10;
	for( int i=0; i<22; i++ ) 
	{
		m = min( m, dot(p,p)/(k*k) );
		p = (mm*vec4((abs(p)),1.0)).xyz;
		k*= s;
	}
	

	float d = (length(p)-0.25)/k;
	
	float h = p.z - 0.35*p.x;
	
	return vec3( d, m, h );
}

// Function 4585
vec4 normalMap(sampler2D channel, vec2 uv) {
  return vec4(
    bumpFromDepth(
      channel,
      uv
    ).rgb * .5 + .5, 
    1.
  );
}

// Function 4586
float sphereSDF(vec3 p, float radius){
    return length(p) - radius; 
}

// Function 4587
float distCircleNnAng(vec3 p, vec3 n, float r, inout float ang)
{
    vec3 pr=p-normalize(p-n*dot(n,p))*r;
    float lpr=length(pr);
    ang=acos(dot(pr,n)/lpr);
    return lpr;
}

// Function 4588
VOX_MAR sdf_MarchIntoVoxel(
        VOX_000 vox_000
    ,   V_3     xyz
    ,   V_3     rwN
    )
    {

        VOX_MAR vox_mar;
        vox_mar.exit=U32( 1 );


        return( vox_mar );
    }

// Function 4589
float map( in vec3 p )
{
    return length(p)-1.5;
}

// Function 4590
vec3 map_center()
{
    return vec3(0.0, 0.4, 0.0);
}

// Function 4591
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   
    const vec2 e = vec2(0.001, 0);    
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));    
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                      
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.    
}

// Function 4592
int iScene(in vec3 ro, in vec3 rd, out float tmin, out vec3 nor)
{
	int oid = -1;
	tmin = 10000.0;

	for (int i = 0; i < bd.length(); i++)
	{
		mat4 ttxi; 
		mat4 ttxx;
		vec3 siz;
		boxParams(i, ttxx, ttxi, siz);

		vec4 res = iBox( ro, rd, ttxx, ttxi, siz);

		if( res.x>0.0 && res.x<tmin )
		{
			tmin = res.x; 
			nor = res.yzw;
			oid = i;
		}
	}

	return oid;
}

// Function 4593
float scene_raycast_terrain( Ray ray, float wlevel,
                             inout float t0, inout vec3 r, int mode )
{
	bool submerged = length( ray.o ) - g_data.radius < wlevel;
    float t = 0., h = 0., alt = 0.;
    float lasth = 0., lastt = 0., lasta = 0.;
    vec4 tsmpl = vec4(0);
    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );
    float C0 = length( ray.o ) - g_data.radius;
    float C1 = dot( ray.o, ray.d ) / length( ray.o );
    float C2 = ( lensq( ray.o ) * lensq( ray.d ) - square( dot( ray.o, ray.d ) ) ) / ( length( ray.o ) * lensq( ray.o ) );
    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; ++i )
    {
        r = ray.o + t * ray.d;
        tsmpl = ts_sample( g_ts, iChannel1, r );
        lasta = alt;
        alt =
#if WITH_TRN_HIGHP_RAYCAST
            t < t_switch ? C0 + t * C1 + t * t * C2 :
#endif
        	length(r) - g_data.radius;
        lasth = h;
        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );
        if( h < 0. )
        {
            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );
        	r = ray.o + t * ray.d;
    		return t;
        }
        else
        if( submerged && alt >= wlevel )
        {
            if( t0 > 0. )
                break;
            t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );
			r = ray.o + t * ray.d;
            vec3 Z = normalize( r );
            vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );
            if( mode == 1 )
            {
	            r = normalize( simple_refract( ray.d, N ) );
            	break;
        	}
            ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );
            ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );
           	ray.o = r;
            t0 = t;
            t = 0.;
		#if WITH_TRN_HIGHP_RAYCAST
    		C0 = length( ray.o ) - g_data.radius;
    		C1 = dot( ray.o, ray.d ) / length( ray.o );
    		C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );
		#endif
            alt = wlevel;
            h = wlevel - ts_sample( g_ts, iChannel1, r ).w;
        }
        lastt = t;
        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );
        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) )
        	break;
    }
    return SCN_ZFAR;
}

// Function 4594
vec3 Tonemap(vec3 col)
{
    #if 1
    #ifdef USE_ACESCG
	col = Tonemap_ACESFitted2(col);
    #else
	col = Tonemap_ACESFitted(col);
    #endif
    #endif
    
    col = clamp01(col);
    
    return col;
}

// Function 4595
vec3 sceneTransformInv(vec3 p) { 
    p = hyperTranslate(p, vec3(-sceneCenter.xy, sceneCenter.z));
    p.xy = p.xy * sceneRotate;
    p = hyperTranslate(p, vec3(-sceneWrap.xy, sceneWrap.z));
    return p;
}

// Function 4596
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {
    if (iFrame > 1) discard;
    fragColor -= fragColor;
    fragColor = height(rayDir);
    //fragColor.gba = normal(rayDir);
}

// Function 4597
float sdfContainer(vec3 p, state s) {
    vec3 d = abs(p - s.p);
    vec3 d2 = d*d;
    float sdBase = pow(dot(d2,d2), 0.25) - 2.0;

    float sdInner = length(d.xz) - 0.6;

    return opSmoothSubtraction(sdInner, sdBase, 0.5);
}

// Function 4598
float dist(HalfPlane2 r, vec2 p)
{
    float d0 = dist(HalfPlane(r.org, r.dir0.yx*vec2(-1.,1.)), p);
    float d1 = dist(HalfPlane(r.org, r.dir1.yx*vec2(-1.,1.)), p);
    
    /*
    if(dot(r.dir0+r.dir1, p-r.org)<0.)
        return dist(r.org, p);
	//*/
    
    return max(min(d0, d1), min(-d0, -d1));
}

// Function 4599
vec3 mapNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = mapDetailed(pt).x;    
    normal.x = mapDetailed(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;
    normal.z = mapDetailed(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 4600
float distanceToLineSeg3D(vec3 p, vec3 a, vec3 b)
{
    vec3 ap = p-a;
    vec3 ab = b-a;
    vec3 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;
    return length(p-e);
}

// Function 4601
vec3 doBumpMap( in vec3 pos, in vec3 nor )
{
    float e = 0.002;
    float b = 0.015;
    
	float ref = fbm6( 4.0*pos );
    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,
                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,
                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )/e;
	
	vec3 tgrad = gra - nor * dot ( nor , gra );
    return normalize( nor - tgrad );
}

// Function 4602
float GetDist(vec3 p)
{
    vec4 sphere = vec4(0.,pow(sin(iTime),2.)+1.,6.+pow(sin(iTime),2.)*0.5,1.);
    float d_sphere = length(p-sphere.xyz) - sphere.w - 0.8*sin((p.x+iTime)*3.)*cos((p.y+iTime)*1.4) - cos((p.y+iTime)*2.1313)*sin((p.x+iTime)*1.2)*0.7 - abs(cos((p.x*p.y*p.z*0.1-iTime*0.1)*2.2412421 - 0.6214))*0.5;
    //float d_plane = p.y - (0.1*sin((sin(p.x+iTime+p.z)*0.6+p.x+iTime)*5.)*cos((p.z+sin(iTime)*0.1)*2.)*2. - cos((p.z+iTime)*2.)*cos((sin(p.y*0.2)+sin(iTime)*0.1)*2.)*0.1)*(1.-sin((p.x+p.z+iTime)*0.2)) + 0.5*sin((p.x+p.z+iTime)*0.2)+0.5;
    float d = d_sphere;//min(d_plane,d_sphere);
    return d;
}

// Function 4603
vec2 log_map(vec2 uv)
{
    float scale = 1.0+saw(time/PI)*2.0;
    uv = uv*2.0-1.0;
    uv.x *= iResolution.x/iResolution.y;
    uv += sin(vec2(time, time/PI*E*GR))*scale/2.0;
    float r = length(uv);
    vec2 uv0 = uv;
    uv = normalize(uv)/log(r+1.0);
    uv += sin(vec2(time, time/PI*E*GR))*scale/2.0;
    return saw(uv*PI)*2.0-1.0;
}

// Function 4604
float scene (vec3 p) {
   // return length(p) - 1.0;
    vec3 box = vec3(1.25, 1.0, 0.5);
    float s = 0.0;
    vec3 boxS = vec3(1.0 - s, 0.75 - s, 2.0);
    float sc = opS(udRoundBox(p-vec3(0.0, 0.0, -2.35), boxS, 0.05), udRoundBox(p, box, 0.05));
    sc = min(sc, udRoundBox(rotY(-0.2) * p - vec3(2.25, -0.5, 0.0), vec3(0.5, 1.0, 1.0), 0.05));
    sc = min(sc, udRoundBox(rotY(0.2) * p - vec3(0.0, -1.5, -1.75), vec3(1.25, 0.025, 0.5), 0.025));
    sc = min(sc, udRoundBox(p - vec3(0.0,0.0,0.5), box - vec3(0.25, 0.25, 0.0), 0.05));
    return min(min(sc, udRoundBox(p - vec3(0.0, -1.5, 0.0), vec3(0.5, 0.05, 0.5), 0.05)), udRoundBox(p - vec3(0.0, -0.5, 0.0), vec3(0.2, 1.0, 0.2), 0.05));
}

// Function 4605
float map(vec3 pos)
{
    float angle = mod(iTime*.8, 2.*pi);
    vec3 posr = vec3(pos.x*cos(angle) + pos.z*sin(angle), pos.y, pos.x*sin(angle) - pos.z*cos(angle));
    
    float d1 = length(posr) - 1.35;
    float d2 = pow(1.1 - sqrt(pow(posr.x, 2.)+pow(posr.y, 2.)), 2.) + pow(posr.z, 2.) - 0.1;
    float d3 = max(max(abs(posr.y), abs(posr.z)), abs(posr.x)) - 1.;
    float mx = iMouse.x/iResolution.x*1.2 - 0.3;
    float my = iMouse.y/iResolution.y*1.6 -  0.3;
    return mix(mix(d1, d2, mx), d3, my);
    return d3;
}

// Function 4606
float sdf_mask(float sdf, float px)
{
    return clamp(1. - sdf/px, 0., 1.);
}

// Function 4607
vec4 mapClouds( in vec3 pos )
{
	vec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);
	
	float d;
    d  = 0.5000*noise( q ); q = q*2.02;
    d += 0.2500*noise( q ); q = q*2.03;
    d += 0.1250*noise( q ); q = q*2.01;
    d += 0.0625*noise( q );
		
	d = d - 0.55;
	d *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );

	d = clamp( d, 0.0, 1.0 );
	
	vec4 res = vec4( d );

	res.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );
	res.xyz *= 0.25;
	res.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );
	
	return res;
}

// Function 4608
vec2 sdf(vec3 pos) {
    float h1 = chainsdf(pos);
    float h2 = torussdf(pos);
    return h1 < h2 ? vec2(h1, 2.) : vec2(h2, 1.);
}

// Function 4609
float map_color(float in_value, float threshold) {
	return clamp (in_value / threshold, 0.0, 1.0);
}

// Function 4610
float floorDist(in Ray ray) {
    // We can cheap and trace this. It's more expensive, but results in the ray intersecting the
    // floor in 1 step, best case (huge win when ray is nearly parallel!)
    float dist = ray.origin.y / -ray.dir.y;
    if( dist <= 0.0001 ) { return kINFINITY; }
    
    return dist;
}

// Function 4611
float SDF( vec3 pos, bool grass )
{
    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations
    
    vec2 gridSize = vec2(.1);//.04);
    vec2 uv = pos.xz/gridSize;
    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);
    uv -= floor(uv);
    
    uvec2 d = uvec2(0,1);
    vec4 rand00 = hash4(coord2(idx00+d.xx));
    vec4 rand01 = hash4(coord2(idx00+d.yx));
    vec4 rand10 = hash4(coord2(idx00+d.xy));
    vec4 rand11 = hash4(coord2(idx00+d.yy));

//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it

    vec2 uvlo = smoothstep(1.,.5,uv);
    vec2 uvhi = smoothstep(0.,.5,uv);

    return min( pos.y,
                min(
                    min(
                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),
                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )
                    ),
                    min(
                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),
                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )
                    )
                )
			) * 1.;
/*    return mix(
                    mix(
                        Tile( pos, uv.x*uv.y, rand00, grass ),
                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),
                        uv.x
                    ),
                    mix(
                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),
                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),
                        uv.x
                    ),
        			uv.y
                );*/
}

// Function 4612
vec3 maptex(vec3 p)
{
 	p.z -= hash(floor(p.x/c+1.))*(time*12.+92.);
    p.y -= hash(floor(p.z/c+1.))*(time*3.+89.);
    vec3 iq = floor(p);
    p = fract(p)-0.5;
    p.xz *= mm2(time*2.+iq.x);
    p.xy *= mm2(time*0.6+iq.y);
    return p;
}

// Function 4613
vec3 NOISE_volumetricRoughnessMap(vec3 p, float rayLen)
{
    vec4 sliderVal = vec4(0.5,0.85,0,0.5);
    ROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);
    
    float f = iTime;
    const mat3 R1  = mat3(0.500, 0.000, -.866,
	                     0.000, 1.000, 0.000,
                          .866, 0.000, 0.500);
    const mat3 R2  = mat3(1.000, 0.000, 0.000,
	                      0.000, 0.500, -.866,
                          0.000,  .866, 0.500);
    const mat3 R = R1*R2;
    p *= ROUGHNESS_MAP_UV_SCALE;
    p = R1*p;
    vec4 v1 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021;
    vec4 v2 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021+1.204*v1.xyz;
    vec4 v3 = NOISE_trilinearWithDerivative(p);
    p = R1*p*2.021+0.704*v2.xyz;
    vec4 v4 = NOISE_trilinearWithDerivative(p);
    
    return (v1
	      +0.5*(v2+0.25)
	      +0.4*(v3+0.25)
	      +0.6*(v4+0.25)).yzw;
}

// Function 4614
float map(vec3 p){
    
    // Mobius object, sitting a bit above the terrain.
    float obj = Mobius(p - vec3(0, .4, 0));
    
    float ter = terrain(p); // The terrain.
 
    float fl = p.y  - ter; // Adding it to a flat plane.
    
    // Creating a flat area to sit the Mobius object on.
    fl =  smax(fl, -max(length(p - vec3(0, 2.5, 0)) - 3., - p.y - .0), .5);
 
    // Object ID.
    objID = step(obj, fl);
    
    // Putting the Mobius object on the terrain.
    return min(fl, obj);
 
}

// Function 4615
float map(vec3 p)
{
    vec2 w = 1./iChannelResolution[0].xy;
    const float dmx = .6;
    
    float df = 100.;
    
    float d[5];
    
    #if 1
    vec4 sp = textureLod(iChannel0, vec2(1.5, 0.5)*w, 0.);
    d[0] = length(p - sp.xyz)-sp.w;
    sp = textureLod(iChannel0, vec2(2.5, 0.5)*w, 0.);
    d[1] = length(p - sp.xyz)-sp.w;
    sp = textureLod(iChannel0, vec2(3.5, 0.5)*w, 0.);
    d[2] = length(p - sp.xyz)-sp.w;
    sp = textureLod(iChannel0, vec2(4.5, 0.5)*w, 0.);
    d[3] = length(p - sp.xyz)-sp.w;
    sp = textureLod(iChannel0, vec2(5.5, 0.5)*w, 0.);
    d[4] = length(p - sp.xyz)-sp.w;
    #else
    d[0] = length(p+vec3(0,sin(time*3.)*0.5,0))-1.;
    d[1] = length(p+vec3(1.2+cos(time*3.)*1.,sin(time*6.+0.7)*0.5,1))-1.;
    d[2] = length(p+vec3(.2+cos(time*2.+1.)*1.,-1.2,0))-.9;
    d[3] = length(p+vec3(.2+cos(time*2.+5.)*1.,-0.2,-.9))-.9;
    d[4] = length(p+vec3(.2+cos(time*2.+5.)*1.,-0.9,.9))-.9;
    #endif
    
    float dm = 100.;
    
    for (int j=0; j<5; j++)
    {
        dm = d[j];
        for (int i=0; i<5; i++)
        {
            if (i == j) continue;
			dm = mix(smax(dm, -d[i]),dm, dmx);
        }
        if (dm < df) matid = float(j);
        df = min(df,dm);
    }
    
    
    float box = - sbox(p, vec3(2.2,2.2,2.2));
    df = smax(df, -box);
    
    return df;
}

// Function 4616
float dist3(vec3 p0,vec3 p1,vec3 p2,vec3 x,float t)
{
    t = clamp(t, 0., 1.);
    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);
}

// Function 4617
float map(vec3 q){
    
    // basic tri planar add
    float dsp = 0.02;
    q.z += dot(texture(iChannel1, q.xy).rgb, vec3(dsp));
	q.x += dot(texture(iChannel1, q.yz).rgb, vec3(dsp));
	q.y += dot(texture(iChannel1, q.xz).rgb, vec3(dsp));
	
    // Layer one. The ".05" on the end varies the hole size.
 	vec3 p = abs(fract(q/3.)*3. - 1.5);
 	float d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;
    
    // Layer two.
    p =  abs(fract(q) - .5);
 	d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);
   
    // Layer three. 3D space is divided by two, instead of three, to give some variance.
    p =  abs(fract(q*2.)*.5 - .25);
 	d = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); 

    // Layer four. The little holes, for fine detailing.
    p =  abs(fract(q*3./.5)*.5/3. - .3/6.);
 	return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);
    //return max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);
    //return max(d, length(p) - 1./18. - .048);
    
    //p =  abs(fract(q*3.)/3. - .5/3.);
 	//return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .04);
}

// Function 4618
RayMarchObject GetScene(vec3 p) 
{
    p.xz = Rot(0.3) * p.xz;
    float distBox = sdBox(p + vec3(0.03, 0.02, -0.04), vec3(0.03, 0.07, 0.03));
    RayMarchObject box = RayMarchObject(0, distBox);
    p.xz = Rot(-0.3) * p.xz;
    
    p.xz = Rot(-0.3) * p.xz;
    float distCube = sdBox(p - vec3(0.04, -0.05, -0.01), vec3(0.025));
    RayMarchObject cube = RayMarchObject(0, distCube);
    p.xz = Rot(0.3) * p.xz;
    
    float greenBoxDist = sdBox(p + vec3(0.1, -0.025, 0.0), vec3(0.002, 0.1, 0.1));
    RayMarchObject greenBox = RayMarchObject(1, greenBoxDist);
    
    float redBoxDist = sdBox(p - vec3(0.1, 0.025, 0.0), vec3(0.002, 0.1, 0.1));
    RayMarchObject redBox = RayMarchObject(2, redBoxDist);
    
    float groundBoxDist = sdBox(p - vec3(0.0, -0.075, 0.0), vec3(0.1, 0.002, 0.1));
    RayMarchObject groundBox = RayMarchObject(0, groundBoxDist);
    
    float topBoxDist = sdBox(p - vec3(0.0, 0.125, 0.0), vec3(0.1, 0.002, 0.1));
    RayMarchObject topBox = RayMarchObject(0, topBoxDist);
    
    float backBoxDist = sdBox(p - vec3(0.0, 0.025, 0.1), vec3(0.1, 0.1, 0.002));
    RayMarchObject backBox = RayMarchObject(0, backBoxDist);
    
    float lampDist = sdBox(p - vec3(0.0, 0.123, 0.0), vec3(0.035, 0.002, 0.035));
    RayMarchObject lamp = RayMarchObject(3, lampDist);
    
    const int objectCount = 8;
    RayMarchObject[objectCount] allObjects = RayMarchObject[objectCount](
        box, cube, greenBox, redBox, groundBox, backBox, topBox, lamp
    );
    
    //////////////////////////////////////////
    
    RayMarchObject finalObject = allObjects[0];
    
    for (int i = 0; i < objectCount - 1; i++) {
        RayMarchObject currentObj = allObjects[i + 1];
        if(currentObj.dist < finalObject.dist) finalObject = currentObj;
    }
    
    return finalObject;
}

// Function 4619
float map(vec3 p, int vol) 
{
    float d = 1.;
	vec3 r = p;
 
// sphere ship
    float ship = length(r-lightpos)-0.1; 

// cone light
	vec3 schein=(r-lightpos);
#ifdef mouse
    pR(schein.zx,iMouse.x*-0.03);
    pR(schein.yz,iMouse.y*0.03);
#else
    pR(schein.zx,-lightscene_interpolated.y);
    pR(schein.yz,lightscene_interpolated.x); 
#endif    
	float s= sdCone(schein,normalize(vec2(1,1)))/length(schein*schein)+0.2*noise(10.*p+2.*sin(.2*iTime))+0.1*noise(p*23.+sin(0.3*iTime))+0.2*rnd(p.xy);
	scatter += max(-s,0.)*0.07;
     

// scene: falling objects
	if (scene==1)
	{
        vec3 c= vec3(1.5);
        p.y+=.4*iTime;
        vec3 q = mod(p,c)-.5*c;

        d=max(length(q)-0.1,p.z-3.);
        d-=.2*noise(6.*p)+0.005*noise(80.*p);
        d=min(d,p.z+4.);
    } 
    
// scene: wobble floor
    if (scene==2)
    {
    	d=p.y-0.01*noise(50.*p)+0.4*noise(2.*p+0.2*iTime)+0.09*noise(7.*p);
    }
   
// scene: room with stone
	if (scene==3)
    {
		d = p.y-log(1.*pow(length(p.xz),1.)+0.2);
		d = min(d,length(p)-0.4-0.04*noise(p*70.)-0.5*noise(p*4.+iTime)-0.02*noise(p*114.+iTime));
		d +=0.05*noise(p*10.)-0.009*noise(p*-40.)+noise(p*2.);;
	}    
    
// scene: kleinian fractal
    if (scene==4)
    {
		vec4 q = vec4(p,1.);
		q*=.5;
        q.x +=.5;
		q.z+=1.;
		for(int i=0;i<8;i++) 
    	{
			q.xyz=-1.+2.*fract(.5+.5*q.xyz);
			q=1.3*q/max(dot(q.xyz,q.xyz),.1);
		}
		d=max(0.9*abs(q.y)/q.w,length(p)-3.5)-0.002*noise(50.*p); // with bounding circle
 		test =1.-1./(q.w);//	highlight fractal area
    }
    
     
// scene: wtf
	if (scene==5)
	{
        p.z+=3.5;
        p.y-=0.1*(iTime-120.);
        p.z-=0.1*(iTime-120.);
            d = .5*mapy(p);
    }   

    return min(ship,d);
}

// Function 4620
float sceneDist(vec3 p) { return f(p); }

// Function 4621
vec2  mapScene(in vec3 pos)
{
	vec2  a = vec2(kFarPlaneDist, 0), b = a;
b   = vec2(sdPlane(pos+vec3(0,0.15,0), vec4(0,1,0,0)), 0.); MIN(a, b);	// Floor.
    
    vec2 res = a;
     float t = gSongTime;
    
    vec2 d0 = pMod2(pos.zx, vec2(1.));
    
    vec2 d = fract(d0 * .1);
    float f0 = 1., f1 = 2.;
    
    pos.xy*=1.+mod(d0.xy,vec2(.4));

    pos.y -= abs(sin(t*kTau*f1+d0.x+d0.y)*.1)*(d.x+d.y);

//pos.x*=mod(d0.x,.5)+.5;
    
    pos = rotation(Y_AXIS, sin(d.x*30.+d.y*12.)*.1) * pos;
    
	vec3 lHeadStart = rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) * (pos - vec3(-0.03, 0.7, 0.0)); // rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) *
	lHeadStart.z += f0*sin(t*kTau*4.+d.x+d.y)*0.07;
    //Main Head
    float   lHead = sdEllipsoid( lHeadStart, vec3(0.165, 0.15, 0.165));
    lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, -0.15, 0.00), vec3(0.15, 0.2, 0.15)), 0.1);
    float   lTorso = sdEllipsoid( pos - vec3(0.0, 0.26, 0.0), vec3(0.2, 0.22, 0.18));
    //Ears
    vec3 lEarsPos = rotation(Z_AXIS, 0.22) * opMirrorX(lHeadStart * vec3(1.0, 0.9, 1.0));
    float lEars = sdRoundCone( lEarsPos - vec3(0.07, 0.14, 0.0), 0.04, 0.075, 0.15 );
    
	float lEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.11), vec3(0.1, 0.15, 0.1));
    	  lEarsCutter =  min(lEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.11), vec3(0.1, 0.15, 0.1)));
    	  lEars = max(lEars, -lEarsCutter);
    lHead = opSmoothUnion(lHead, lEars, 0.02);
    float lBody = opSmoothUnion(lHead, lTorso, 0.04);

    //lLegs
    vec3 pos2 = rotation(X_AXIS, -sin(t*kTau*f1)*.1) * pos;
    if (f1 == 0.) pos2 = pos;
    float lLegs = sdCylinder( opMirrorX(pos2) - vec3(0.09, 0.0, 0.0), vec2(0.07, 0.2) );
    lBody = opSmoothUnion(lBody, lLegs, 0.07);
    
    //Arms
    float lArms  = sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.18, 0.28, 0.0)), vec3(0.06, 0.12, 0.06));
    lBody = fOpIntersectionRound(lBody, -lArms, 0.02);
    //Arms Top
    lArms  = opSmoothUnion(lArms, sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.125, 0.35, 0.0)), vec3(0.065, 0.08, 0.065)), 0.04);
    //Hands
    float lHands  = sdEllipsoid( rotation(Z_AXIS, -0.2) * (opMirrorX(pos) - vec3(0.235, 0.19, 0.0)), vec3(0.026, 0.065, 0.045));
    	  lHands  = min(lHands, sdEllipsoid( (opMirrorX(pos) - vec3(0.2, 0.17, -0.035)), vec3(0.012, 0.02, 0.012)));
    lArms = opSmoothUnion(lArms, lHands, 0.02);
    lBody = opSmoothUnion(lBody, lArms, 0.008);
    
    
    
    //Mouth Cavity
    float lMouthCavity = sdEllipsoid( rotation(Z_AXIS, -0.2) * (lHeadStart - vec3(0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));
    float lMouthCavity2 = sdEllipsoid( rotation(Z_AXIS, 0.2) * (lHeadStart - vec3(-0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));
    float lMouthCavity3 = sdEllipsoid( lHeadStart - vec3(0.0, -0.11, -0.105), vec3(0.07, 0.03, 0.07));
    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity2, 0.03);
    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity3, 0.02);
    lBody = fOpIntersectionRound(lBody, -lMouthCavity, 0.01);
    lMouthCavity = max(lBody + 0.001, lMouthCavity) - 0.002;
    res = opU( res, vec2( lBody, 3.0) );
    res = opU( res, vec2( lMouthCavity, 6.0) );
    
    //Labios
    float lLabios = sdEllipsoid( lHeadStart - vec3(0.0, -0.09, -0.1), vec3(0.13, 0.08, 0.25));
    	  lLabios = opSmoothUnion(lLabios, sdEllipsoid( lHeadStart - vec3(0.0, -0.12, -0.1), vec3(0.12, 0.08, 0.25)), 0.02);
    lLabios = max(lLabios, lBody);
    res = opU( res, vec2( lLabios, 2.0) );
    
    //Teeth
    float lTeeth = sdRoundBox(rotation(Z_AXIS, -0.02) * (opMirrorX(lHeadStart) - vec3(0.044, -0.068, -0.14)), vec3(0.01, 0.015*(1.+d.x*.3+d.y*.3), 0.001), 0.012);
    res = opU( res, vec2( lTeeth, 3.0 ) );
    
    //Tripa
    float lTripa = sdEllipsoid( pos - vec3(0.0, 0.27, -0.1), vec3(0.12, 0.145, 0.12));
    lTripa = max(lTripa, lBody);
    res = opU( res, vec2( lTripa, 2.0) );
    
    //Inner Ears
    float lInnerEars = sdRoundCone( lEarsPos - vec3(0.07, 0.18, 0.0), 0.03, 0.05, 0.11 );
    float lInnerEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.12), vec3(0.1, 0.15, 0.1));
    	  lInnerEarsCutter =  min(lInnerEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.1), vec3(0.1, 0.15, 0.1)));
    	  lInnerEars = max(lInnerEars, -lInnerEarsCutter);
        //sdEllipsoid( lEarsPos - vec3(0.09, 0.26, -0.02), vec3(0.04, 0.08, 0.03));
    lInnerEars = max(lInnerEars, lBody);
    res = opU( res, vec2( lInnerEars, 2.0) );
    //Eyes
    vec3 lEyePos = opMirrorX(lHeadStart) - vec3(0.1, 0.0, -0.17);
    lEyePos.y*=.5+.5*fract(d.x*.5+d.y*.5);
    float lEyelids = sdSphere( lEyePos, 0.036 );
    float 	lEyeCutter = sdBox( rotation(X_AXIS, 0.2) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05));
    		lEyeCutter = min(lEyeCutter, sdBox( rotation(X_AXIS, 0.5) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05)));
    lEyelids = fOpIntersectionRound(lEyelids, -lEyeCutter, 0.004);
    res = opU( res, vec2( lEyelids, 2.0) );
    
    float lEyeSpheres = sdSphere( lEyePos, 0.033 );
    res = opU( res, vec2( lEyeSpheres, 5.0) );
    //res = opU( res, vec2( lEyeCutter, 4.0) );
    a=res;
    
    return	a;
}

// Function 4622
float dist2(vec3 p, float r1, float r2){
    
    
    // See the comments in the "dist" function.
    
    ///p.xy *= rot2(mod(iTime/1.8, 3.*6.2831/18.) + 3.*6.2831/18.);
    p.xy *= rot2(mod(iTime/1.8, 6.2831/6.) + 6.2831/6.);
    
    float a = atan(p.y, abs(p.x)); // Note the "abs" call.
    
    p.z = -p.z;
    
    r1 *= (.9 + p.z);
    
    vec3 q = p; 
    
    float ia = floor(a/6.2831*18.) + .5;
    q.xy = rot2(ia*6.2831/18.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.
    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.
    q = abs(q);
    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);
    float d2 = max(spike, q.z - r2);
    
    q = p; 
    ia = floor(a/6.2831*6.) + .5;
    q.xy = rot2(ia*6.2831/6.)*q.xy;
    sph = max(max(abs(q.x), abs(q.y)) - .0275, abs(q.z - .07) - .06);
    //sph = max(length(q.xy) - .0275, abs(q.z - .07) - .06);
    q = abs(q + vec3(r1/2., 0, -.07));
    //spokes = max(max(q.x - r1/2. + .02, q.y - .03), q.z - .01);
    spokes = max(q.x - r1/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .03));
    
    p = abs(p);
    float d = length(p.xy);
    float di = abs(d  -  r1 + .1/2.) - .05/2.;
    d = abs(d  -  r1 + .075/2.) - .075/2.;
    d = min(max(d , p.z - r2), max(di , p.z - r2 - .0115));
    
    return min(d, d2);
    
}

// Function 4623
float GetSphereDist(vec3 p) {
    
    // All spheres will have this radius.
    // Note that there appear to be more spheres along the
    // z-axis due to the repeated rendering that we do below.
    
    // Radius will be in range [0.09, 0.99]
    float radius = (sin(iTime / 6.) + 1.1) * .09;
    
    float minDist = FLOAT_MAX;
    
    // Calculate the distance to the closest sphere.
    // Note that the position of the spheres is randomly generated
    // based on 'i' in the loop below.
    for (float i = 0.; i < SPHERE_AMOUNT; i++) {
        // Every sphere's 'real' position will be at z = Z_PLANE.
        // However, due to the repeated rendering (see below)
        // there appear to be many more spheres.
        vec3 pos = vec3(hash21(i), Z_PLANE);
        
        // Convert values from [0, 1] to [-interval, interval].
        pos.xy = pos.xy * INTERVAL * 2. - INTERVAL;
            
    	// Repeater set-up based on Bekre's UFO shader, retrieved from:
    	// https://www.shadertoy.com/view/4dXGD4
		vec3 repeater = mod(p - pos, REPEAT) - 0.5 * REPEAT;
		float dist = length(repeater) - radius;
        
        if (dist < minDist) {
            minDist = dist;
        }    
    }
    
    return minDist;
}

// Function 4624
vec3 ExShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, c, vn;
  vec2 s, w;
  float dstObj, sh, npCyc, tpCyc, tpWait, nDotL, t;
  bool isImg;
  pgSize = vec3 (3.2, 0.011, 1.8);
  tpCyc = 3.;
  tpWait = 4.;
  t = (tpBook < 0.) ? (- tpBook * float (nPage - 1) * (tpCyc + tpWait)) :
     mod (tpBook - tpWait, float (nPage) * (tpCyc + tpWait));
  npCyc = mod (floor (t / (tpCyc + tpWait)), float (nPage));
  phsTurn = min (mod (t / (tpCyc + tpWait), 1.) * (tpCyc + tpWait) / tpCyc, 1.);
  isImg = false;
  dstObj = ExObjRay (ro, rd);
  if (dstObj < dstFarEx) {
    ro += dstObj * rd;
    vn = ExObjNf (ro);
    nDotL = max (dot (vn, ltDirEx), 0.);
    if (idObj <= nPage) {
      idPage = mod ((float (idObj - 1) + npCyc), float (nPage)) + 1.;
      c = vec3 (0.9, 0.9, 0.8) * (0.85 + 0.15 * Fbm2 (8. * qHit.xz));
      col4 = vec4 (c, 0.2);
      s = pgSize.xz - abs (qHit.xz);
      if (qHit.y > 0.) {
        w = qHit.xz / pgSize.z;
        if (min (s.x, s.y) > 0.3) {
          isImg = true;
          ExMain (col, w);
        } else if (min (s.x, s.y) > 0.27) {
          col4 = vec4 (0.6 * c, 0.2);
        } else {
          col4 = vec4 (c, 0.2);
        }
      }
    } else if (idObj == nPage + 1) {
      col4 = vec4 (0.9, 0.9, 0.8, 0.2);
      nDotL *= nDotL;
    }
    sh = ExObjSShadow (ro + 0.001 * vn, ltDirEx);
    if (isImg) col *= 0.2 + 0.8 * sh;
    else col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +
       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDirEx - rd), vn), 0.), 32.);
  } else {
    col = vec3 (1., 1., 0.9) * (0.5 + 0.2 * rd.y);
  }
  return clamp (col, 0., 1.);
}

// Function 4625
float sdf_sphere(in vec3 pos, in vec3 offset) {
    return length(pos - offset) - THICKNESS;
}

// Function 4626
float distBall(vec3 p, vec3 pos, float radius) {
 
    float sph1 = distSphere(p, pos + vec3(0.,0.,.5), radius + .4);
    float sph2 = distSphere(p, pos + vec3(.3,0.,0.),  radius	   );
    
    return max(-sph2,sph1);
    
}

// Function 4627
vec4 map(in vec3 p)
{	
    float ground = sdPlane(p, 1.8);
    
    p.xz = mod(p.xz + 2.0, 2.0) - 1.0;
    p.y  = mod(p.y  + 1.0, 2.0) - 1.0;
	
    float d = mandelbox(p + vec3(0.0, 0.25, 0.0));
    vec4 res = vec4(d, 1.0, 0.0, 2.0);
    
    return opU(res, vec4(ground, 1.0, 0.0, 1.0));
}

// Function 4628
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 objCol;
  vec3 col, vn, bgCol;
  float dstGrnd, dstBall, sh, c;
  bgCol = vec3 (0.4, 0.4, 0.45);
  dstGrnd = GrndRay (ro, rd);
  dstBall = BallHit (ro, rd);
  if (min (dstBall, dstGrnd) < dstFar) {
    if (dstGrnd < dstBall) {
      ro += rd * dstGrnd;
      vn = GrndNf (ro);
      objCol = vec4 (mix (vec3 (0.35, 0.3, 0.1), vec3 (0.4, 0.6, 0.2),
         clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.)) *
         (1. - 0.1 * Noisefv2 (10. * ro.xz)), 0.);
      sh = min (BallHitSh (ro + 0.01 * sunDir, sunDir, 10.),
         GrndSShadow (ro, sunDir));
    } else {
      ro += rd * dstBall;
      c = float (idBall / 16) / float (nBall / 16);
      objCol = vec4 (HsvToRgb (vec3 (mod (c, 1.), 1., 1.)), 1.);
      objCol.rgb *= BallChqr (idBall, vnBall);
      vn = vnBall;
      sh = 1.;
    }
    col = objCol.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +
       objCol.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 256.);
    col = mix (col, bgCol, clamp (3. * min (dstBall, dstGrnd) / dstFar - 2.,
       0., 1.));
  } else col = bgCol;
  return pow (clamp (col, 0., 1.), vec3 (0.8));
}

// Function 4629
float rmap(vec4 uv, RSet4 rs) {
    return RAND(map(uv, rs.q, rs.l), rs.r);
}

// Function 4630
float SDFQuadratic( in vec2 coords )
{
    float v = coords.x * coords.x - coords.y - 5.0;
    vec2  g = vec2(2.0 * coords.x, -1.0);
    return abs(v)/length(g);    
}

// Function 4631
float scene5(vec3 p)
{
    vec3 torusmove = vec3(0.);//.7*sin(vec3(iTime,iTime*1.1,iTime*1.3));
    //float d3 = sdSphere(p + vec3(-1,-.75,1.0),.25); // p or pr, it's a sphere
    float d3 = sdSphere(p + vec3(0.,0.,5.),.25); // p or pr, it's a sphere
    float d3_2 = sdSphere(p + vec3(-1.,0.,4.),.25); // p or pr, it's a sphere
    float d3_3 = sdSphere(p + vec3(-2.,0.,3.),.25); // p or pr, it's a sphere
    float c0 = sdSphere(p + vec3(-10.,0.,-10.),.5); // p or pr, it's a sphere
    float c1 = sdSphere(p + vec3(10.,0.,-10.),.5); // p or pr, it's a sphere
    float c2 = sdSphere(p + vec3(-10.,0.,10.),.5); // p or pr, it's a sphere
    float c3 = sdSphere(p + vec3(10.,0.,10.),.5); // p or pr, it's a sphere
    d3 = opU(opU(opU(opU(c0,c1),c2),c3),d3);
    d3 = opU(d3_3,opU(d3,d3_2));
    vec3 pr;
    pr.xz = p.xz * rot(1.57);
    pr.y = p.y;
    sceneCol = fract(pr*8.0);
    float d1 = sdBox(pr,vec3(.5,1.0,1.5));
    pr.xy *= rot(1.57);
    // +Y+Z+X
	float d2 = sdCappedCylinder(pr,vec2(.50,12));
    pr -= vec3(1.,0.,0.)+torusmove;
    //pr.xy *= rot(iTime*.2);
   	//pr.xz *= rot(iTime*.5);
    //float d4 = sdTorus(pr,vec2(.5,.125));
    //float d4 = opRep_sceneT(pr,vec3(1.));
    float d4 = opRepLimitCenter_sceneT(pr,vec3(1.),vec3(2.0,3.0,4.0));
//    float d4 = sdTorus(pr + vec3(-.75,-1.5,-1.0)+vec3(0.0,torusmove,0.0),vec2(.5,.125));
    return opU(d3,opU(d4,opS(d1,d2)));
    //return sdCylinder(pr,vec3(1.0));
}

// Function 4632
float MapFrontWing(vec3 p, float mirrored)
{
  missileDist=10000.0;

  checkPos = p;
  pR(checkPos.xy, -0.02);
  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); 

  if (wing<5.) //Bounding Box test
  {
    // cutouts
    checkPos = p-vec3(3.0, 0.3, -.30);
    pR(checkPos.xz, -0.5);
    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);

    checkPos = p - vec3(8.0, 0.3, -8.80);
    pR(checkPos.xz, -0.05);
    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);

    checkPos = p- vec3(9.5, 0.3, -8.50);
    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);

    // join wing and engine
    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));
    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    

    checkPos = p;
    pR(checkPos.xz, -0.03);
    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   

    checkPos = p;
    pR(checkPos.yz, 0.75);
    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); 
    pR(checkPos.yz, -1.95);
    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); 

    checkPos = p- vec3(0.47, 0.0, -4.3);
    pR(checkPos.yz, 1.57);
    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   

    // flaps
    wing =max(wing, -sdBox( p- vec3(3.565, 0.1, -6.4), vec3(1.50, 1.4, .5)));
    wing =max(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))));

    checkPos = p- vec3(3.565, 0.18, -6.20+0.30);
    pR(checkPos.yz, -0.15+(0.8*pitch));
    wing =min(wing, sdBox( checkPos+vec3(0.0, 0.0, 0.30), vec3(1.46, 0.007, 0.3)));

    // missile holder
    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));

    checkPos = p;
    pR(checkPos.yz, 0.85);
    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); 
    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); 
    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); 

    // bomb
    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   
    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   
    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   

    // missiles
    checkPos = p-vec3(2.9, -0.45, -4.50);

    // check if any missile has been fired. If so, do NOT mod missile position  
    float maxMissiles =0.; 
    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));
    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); 

    pModInterval1(checkPos.x, 1.8, .0, maxMissiles);
    holder = min(holder, MapMissile(checkPos));

    // ESM Pod
    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));

    // wheelholder
    wing=min(wing, sdBox( p- vec3(0.6, -0.25, -3.8), vec3(0.8, 0.4, .50)));

    wing=min(bombDist, min(wing, holder));
  }

  return wing;
}

// Function 4633
float getDist(vec3 pos)
{
    return getDistM(pos).x;
}

// Function 4634
SDFResult sceneSDF(vec3 p )
{
    SDFResult res = wallsSDF(p);   
#ifdef POO    
    res = opSmoothAdd(pooSDF(p, g_poo, BROWN), res, 0.01);
#endif //POO
#ifdef STUFF
    res = opSmoothAdd(toiletSDF(p), res, 0.01);
    res = opSmoothAdd(sinkSDF(p), res, 0.01);
    res = opSmoothAdd(bathSDF(p), res, 0.01);
#endif //STUFF
#ifdef MRSPOO
    //res = opAdd(sierSDF(p, SIERP, iTime), res);
    res = opAdd(pooSDF(p, g_poo2, GREY), res);
#endif //MRSPOO            
	return res;
}

// Function 4635
float boxDistance(vec2 pos, vec2 center, vec2 normal, vec2 scale) {
    mat2 rot = mat2(normal.x, -normal.y, normal.y, normal.x);
	vec2 delta = rot * (pos - center);
    delta = clamp(delta, -scale, scale);
    vec2 clampPos = center + delta * rot;
    return length(clampPos - pos);
}

// Function 4636
float map(in vec3 pos)
{
    float d = 1e10;
    

    // triangle
    {
    vec3 q = pos - vec3(-3.0,0.0,-1.0);
    d = min( d, udTriangle( q, vec3(0.7,0.1,0.1), vec3(-0.2,-0.2,0.3), vec3(0.1,0.2,-0.1) ) );
    }
    
    // rounded triangle
    {
    vec3 q = pos - vec3(-3.0,0.0,1.0);
    d = min( d, rounding( udTriangle( q, vec3(0.7,0.1,0.1), vec3(-0.2,-0.2,0.3), vec3(0.1,0.2,-0.1) ), 0.1 ) );
    }

    // cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,-1.0);
    d = min( d, sdCappedCylinder( q, vec2(0.4,0.1) ) );
    }
    
    // rounded cylinder
    {
    vec3 q = pos - vec3(-1.0,0.0,1.0);
    d = min( d, rounding(sdCappedCylinder( q, vec2(0.4,0.1) ), 0.1) );
    }

    // hexagon
    {
    vec3 q = pos - vec3(1.0,0.0,-1.0);
    d = min( d, sdHexPrism( q, vec2(0.4,0.05) ) );
    }
    
    // rounded hexagon
    {
    vec3 q = pos - vec3(1.0,0.0,1.0);
    d = min( d, rounding(sdHexPrism( q, vec2(0.4,0.05) ), 0.1) );
    }

    // cone
    {
    vec3 q = pos - vec3(3.0,0.0,-1.0);
    d = min( d, sdCappedCone( q, 0.5,0.3,0.05 ) );
    }
    
    // rounded cone
    {
    vec3 q = pos - vec3(3.0,0.0,1.0);
    d = min( d, rounding(sdCappedCone( q, 0.4,0.3,0.05 ), 0.1) );
    }

    return d;
}

// Function 4637
vec2 heightmapNormal(vec2 p)
{
    return vec2(sin(p.x+iTime*0.25)*0.15, sin(p.y-iTime*0.125)*0.15);
}

// Function 4638
float map(vec3 p, inout object co)
{
    //find closest voronoi cell
    float DE = 0.5*findClosest(p, co, 64); //works well for spheres
    
    return min(DE, p.z+0.5);
}

// Function 4639
float  mapSmallElephantSimple( vec3 p )
{
    
    const float sca = 2.0;
    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;
    p *= sca;
    
    p -= vec3(-1.1,2.4,-2.0);
    
    vec3 ph = p;
    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;
        
    // head
    float d = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.35) );

    vec3 qh = vec3( ph.xy, abs(ph.z) );

    vec3 q = vec3( p.xy, abs(p.z) );

    // body
    {
    float co = cos(0.4);
    float si = sin(0.4);
    vec3 w = p;
    w.xy = mat2(co,si,-si,co)*w.xy;
        
    float d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );
	d = smin(d, d4, 0.2 );

    }

    // back-left leg
    {
    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75  );
    d = smin(d,d3,0.1);
    }
    
    
    // front-left leg
    {
    float d3 = leg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );
    d = smin(d,d3,0.15);
    d3 = leg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );
    d = smin(d,d3,0.15);

    }
    
    return d/sca;
}

// Function 4640
float map(vec3 ray) {
    float map = distance(ray, vec3(0,0,0)) - 0.35;
    return map;


}

// Function 4641
float heightMap(vec2 p){
    
    p /= 2.; // Extra scaling.
    
    float  h = 0., a = 1., sum = 0.; // Height, amplitude, sum.
    
    for(int i=0; i<4; i++){
    
        p = fract(p)*3.; // Subdividing space.
        // Far more interesting, mutated subdivision, courtesy of Aiekick.
        //p = fract(p+sin(p.yx*9.)*0.025 + cos(p.yx*9.)*0.025)*3.; 
        // Another one with a time component.
        //p = fract(p + sin(p*9. + cos(p.yx*13. + iTime*2.))*0.02)*3.;
        
        vec2 w = .5 - abs(p - 1.5); // Prepare to make a square. Other shapes are also possible.
        float l = sqrt( max(16.0*w.x*w.y*(1.0-w.x)*(1.0-w.y), 0.))*.5+.5; // Edge shaping.
        w = smoothstep(0., .05, w); // Smooth edge stepping.
        h = max(h, w.x*w.y*a*l); // Producing the smooth edged, shaped square.
        //h += w.x*w.y*a*l;
        //h = max(h, abs(abs(w.x)-abs(w.y))*a*l);
        sum += a; // Keep a total... This could be hardcoded to save cycles.
        a *= .4; // Lower the amplitude for the next subdivision, just because it looks tidier.
        //if(i==2)a*=.75;
    }
    
    return h/sum;
    
}

// Function 4642
float sdf_S(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_quarter2_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -2, 0)));
    return t;
}

// Function 4643
float remap01to_11(float a)
{
    return a * 2.0 + 1.0;
}

// Function 4644
float map(vec2 p) {
    id = 0;
    float t = iTime / 20.;
    float ljs = 0.6; // lissajous size for lights
    
    // Cutted box
    float size = 1.1;
    vec2 modp = mod(1.1*p, 1.0) - 0.5;
    float d = sdCuttedBox(rot(PI/4.)*size*p) / size;
    
    // Light 1
    float lx1 = cos(23.*t/4. + 2.) * R.x/R.y *ljs;
    float ly1 = sin(31.*t/4.) * ljs; 
    float circle = sdCircle(p + vec2(lx1, ly1), 0.05);
    if(circle < d) {
        id = 1;
    }
    d = min(d, circle);
    
    // Light 2
    float lx2 = cos(17.*t + 1.) * R.x/R.y *ljs;
    float ly2 = sin(7.*t) * ljs;
    float circle2 = sdCircle(p + vec2(lx2, ly2), 0.05);
    if(circle2 < d) {
        id = 2;
    }
    d = min(d, circle2);
    
    // Horse shoe
    vec2 absX = p;
    absX.x = abs(absX.x);
    absX.x = -absX.x;
    
    float a = PI/2.;
    float b = -0.6;
    vec2 ra = vec2(cos(a), sin(a));
    vec2 rb = vec2(cos(b), sin(b));
    float arc = sdArc(absX - vec2(-0.5*R.x/R.y + 0.1, 0), ra, rb, 0.8, 0.05);
    if(arc < d) {
        id = 0;
    }
    d = min(d, arc);
    
    lastMapValue = d;
    return d;
}

// Function 4645
float MapExplosion( vec3 p, Explosion ex)
{ 
  checkPos = (ex.pos)-vec3(planePos.x, 0., planePos.z); 
  checkPos=p-checkPos;

  float testDist = fSphere(checkPos, 20.0);
  if (testDist>10.)  return testDist;

  float intensity =GetExplosionIntensity(ex);
  float d= fSphere(checkPos, intensity*15.);  

  // terrain clipping
  #ifdef EXACT_EXPLOSIONS
    d=max(d, -MapTerrain(p));
  #else
    d = max(d, -sdBox(checkPos+vec3(0., 50., 0.), vec3(50., 50.0, 50.0)));
  #endif

  // add explosion "noise/flames"
  float displace = fbm(((checkPos) + vec3(1, -2, -1)*iTime)*0.5);
  return d + (displace * 1.5*max(0., 4.*intensity));
}

// Function 4646
float map( in vec3 p, out vec4 color, const in bool doColor )
{
    float lp = length(p);
    float dmin = lp-1.0;
    {
    vec3 w = p/lp;
    vec4 fibo = inverseSF(w, 700.0);
    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));
    dmin -= 0.07*hh;
    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));
    }
    
    
    float s = 1.0;
    
    #ifdef INTERACTIVE
  //float tt = mod(iTime,5.0);
    float tt = 4.0*iMouse.x/iResolution.x;
    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));
    #endif
    
    for( int i=0; i<3; i++ )
    {
        float h = float(i)/float(3-1);
        
        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);
        
        // snap
        p -= f.xyz;

        // orient to surface
        p = p*makeBase(f.xyz);

        // scale
        float scale = 6.6 + 2.0*sin(111.0*f.w);
        p *= scale;
        p.xy *= 1.2;
        
        //translate
        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);
            
        // measure distance
        s *= scale;
        #ifdef INTERACTIVE
        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );
        #else
        float d = sdCapsule( p, -6.0, 0.42 );
        #endif
        d /= s;

        if( d<dmin )
        {
            if( doColor )
            {
                color.w *= smoothstep(0.0, 5.0/s, dmin-d);

                if( i==0 ) 
                {
                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall
                  //color.xyz = vec3(0.4,0.8,0.1);         // summer
                  //color.xyz = vec3(0.4,0.4,0.8);         // winter
                }

                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));
                color.xyz = max(color.xyz,0.0);
            }
            dmin = d;
        }
        else
        {
          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));
        }
    }
    
    return dmin;
}

// Function 4647
float boxSDF(vec2 p, vec2 size) {
	vec2 r = abs(p) - size;
    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));
}

// Function 4648
vec2 uvmap(vec2 pixels)
{
	vec2 uv = pixels / iResolution.xy;
	uv = uv * 2.0 - vec2(1.0);
	uv.x *= iResolution.x / iResolution.y;
	return uv;
}

// Function 4649
float sdf_capsule(vec3 p, vec3 a, vec3 b, float radius)
{
    vec3 ab = b - a;
    vec3 ap = p - a;
    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);
    return sdf_sphere(p - mix(a, b, t), radius);
}

// Function 4650
float map(vec3 p)
{  
    float s = smoothstep( -0.7, 0.7, sin(0.5*T));
    float a = mix(0.5, 2.0, s);
    float t = 1.0*T;
    
	float s1 = sphere(p +a*vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7)), 1.0);
    float s2 = sphere(p +a*vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3)), 1.2);
    float s3 = sphere(p +a*vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1)), 1.5);
    float s4 = sphere(p +a*vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7)), 0.4);
    float s5 = sphere(p +a*vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9)), 1.0);
    
    return blob5(s1, s2, s3, s4, s5);
}

// Function 4651
void scene(in vec2 pos, out vec3 color, out float dist) {
    dist = 100.0; color = vec3(0,0,0);
    AddObj(dist, color, boxSDF(pos - vec2(-3,1), vec2(1,1)), vec3(1.+sin(iTime)));
    AddObj(dist, color, sphereSDF(pos - vec2(3,1), 1.+sin(iTime/5.)/2.), vec3(2,2,1));
    AddObj(dist, color, sphereSDF(pos - vec2(3.3*sin(iTime*2.5),-2.0+sin(iTime*5.0)), 0.5), vec3(0,.2,.2));
    AddObj(dist, color, boxSDF(pos - vec2(0,2), vec2(1.5,0.25)), vec3(.5,.1,.1));
}

// Function 4652
float mapMaterial( vec3 p ) {
    float zorig = p.z;
    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);
    
    float x = p.x*2., y = p.y-0.8, z = p.z;
    vec2 d = vec2( -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) ), 5.);

	d = opS( d, vec2( sdBox( p, vec3( 2.5, 2., 5.75 ) ), 3. ) );
    d = opU( d, vec2( sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ), 1. ) );    
    d = opU( d, vec2( sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ), 4. ) );
    d = opU( d, vec2( sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ), 4. ) );
    

    d = opU( d, vec2( 2.2-p.y, 5. ) );
    d = opU( d, vec2( p.y+2.03, 2. ) );  
    d = opU( d, vec2( sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2), 6.) );
    
    if( getSectorId(zorig).y > 0.75 ) {
        d = opS( d, vec2( sdCylinder( vec3(p.x, p.y-4., p.z), vec2(1.5,2.) ), 5.) );

        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);
        d = opU( d, vec2( sdBox( pr, vec3(3.0,0.1,0.1) ), 4.) );
        d = opU( d, vec2( sdBox( pr, vec3(0.1,0.1,3.0) ), 4.) );
    } 
    
#ifdef SPHERE
    d = opU( d,  vec2( sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2), 7.) );
#endif
    
	return abs(d.y);
}

// Function 4653
float Box_SDF(in vec3 point, in vec3 bounds)
{
 	return length(max(abs(point) - bounds, 0.0));   
}

// Function 4654
float SphereDist(vec3 position, vec3 rposition, float radius)
{
    return length(position - rposition) - radius;
}

// Function 4655
bool Map_SectorInGridCell( sampler2D mapSampler, MapInfo mapInfo, vec2 vGridCellMin, vec2 vGridCellMax, int iSectorId )
{
    Sector sector;
    
    sector = Map_ReadSector( mapSampler, iSectorId );
    
    float fInOutTest = 0.0;
    
    for(int iSideDefIndex=0; iSideDefIndex<NO_UNROLL( MAX_SIDEDEF_COUNT ); iSideDefIndex++)
    {        
        SideDef sideDef = Map_ReadSideDefInfo( mapSampler, sector.iSectorId, iSideDefIndex );                        
        
        if ( sideDef.fLength <= 0.0)
        {
            break;
        }

        if ( LineInGridCell( sideDef.vA, sideDef.vB, vGridCellMin, vGridCellMax ) )
        {
            return true;
        }
    }
    
    return false;
}

// Function 4656
float sceneSDF(vec3 samplePoint) {
    return cubeSDF(samplePoint);
}

// Function 4657
float waterHeightMap( vec2 pos ) {
	vec2 posm = pos * mr;
	posm.x += 0.25*time;
	float f = fbm( vec3( posm*1.9, time*0.27 ));
	float height = 0.5+0.1*f;
	height += 0.13*sin( posm.x*6.0 + 10.0*f );

#ifdef SHOWBOTTLE	
	float d = length(pos-vec2(-3., 0.));
	height += 0.1 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );
#endif
	
	return  height;
}

// Function 4658
vec2 track_distort(vec2 pos)
{
    pos *= 0.5;    
    pos -= vec2(cos(pos.y * 2.4), sin(pos.x * 2.0 - 0.3 * sin(pos.y * 4.0))) * 0.59;
    return pos;
}

// Function 4659
vec2 mapLandscape(in vec3 p) {
	return vec2(sdLandscape(p), 1.);
}

// Function 4660
float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
	
    return num / denom;
}

// Function 4661
float map(vec2 p){
	// Reading distance fields from a texture means taking scaling into
    // consideration. If you zoom coordinates by a scalar (4, in this case), 
    // you need to scale the return distance value accordingly... Why does 
    // everything have to be so difficult? :D
    const float sc = 4.;
    vec4 tex = tx(iChannel0, p/sc);
    gIP = tex.yz; // The object ID is stored in the YZ channels..
    gObjID = tex.w;
    return tex.x*sc;
}

// Function 4662
float sdf_half1_torus(in vec3 pos, in vec3 offset) {
    pos -= offset;
    vec2 q = vec2(length(pos.xy) - torus.x, pos.z);
    return max(length(q) - torus.y, pos.y);
}

// Function 4663
float scene_primitive_cube( Ray ray, vec3 size, inout float t, inout vec3 N )
{
    vec3 dn = ray.o + sign( ray.d ) * size;
    vec3 to = -dn / ray.d;
    if( to.x >= 0. && to.x < t &&
        hmax( abs( ray.o.yz + ray.d.yz * to.x ) - size.yz ) < 0. )
    {
        t = to.x;
        N = sign( ray.o.x ) * UNIT_X;
    }
    if( to.y >= 0. && to.y < t &&
        hmax( abs( ray.o.zx + ray.d.zx * to.y ) - size.zx ) < 0. )
    {
        t = to.y;
        N = sign( ray.o.y ) * UNIT_Y;
    }
    if( to.z >= 0. && to.z < t &&
        hmax( abs( ray.o.xy + ray.d.xy * to.z ) - size.xy ) < 0. )
    {
        t = to.z;
        N = sign( ray.o.z ) * UNIT_Z;
    }
    float shadow = 1.;
    if( hmax( to ) >= 0. )
    {
        vec3 K = 2. * max( ZERO, max( to.yzx, to.zxy ) ) * SCN_RAYCAST_SHADOW_UMBRA_INV;
        vec3 R = size.yzx * abs( ray.d ).zxy + size.zxy * abs( ray.d ).yzx;
        vec3 u = cross( ray.o, ray.d );
        shadow = 1. - aaa_interval( K.x, u.x, 2. * R.x )
            * aaa_interval( K.y, u.y, 2. * R.y )
            * aaa_interval( K.z, u.z, 2. * R.z );
    }
    return shadow;
}

// Function 4664
float dstScene(vec3 p) {
	float dst = length(p)-1.;
    dst = min(dst, length(max(abs(vec3(0.,0.,5.6)-p)-vec3(6.,3.,1.),0.)));
    return dst;
}

// Function 4665
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 objCol;
  vec3 col, vn, bgCol;
  float dstBlk, dstGrnd, sh, f;
  bgCol = BgCol (ro, rd);
  dstBlk = BlkHit (ro, rd);
  dstGrnd = GrndRay (ro, rd);
  if (min (dstBlk, dstGrnd) < dstFar) {
    if (dstBlk < dstGrnd) {
      ro += rd * dstBlk;
      vn = vnBlk;
      if (length (qBlk) > 0.65) objCol = vec4 (0.7, 0.4, 0.2, 0.3);
      else objCol = vec4 (0.9 * (1. - abs (fcBlk)), 0.5);
      sh = 1.;
    } else {
      ro += rd * dstGrnd;
      vn = GrndNf (ro);
      f = 1. - clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.);
      vn = VaryNf (4. * ro, vn, 4. * f * f);
      objCol = vec4 (mix (vec3 (0.4, 0.7, 0.2), vec3 (0.3, 0.3, 0.3), f) *
         (1. - 0.1 * Noisefv2 (8. * ro.xz)), 0.);
      sh = GrndSShadow (ro, sunDir);
    }
    sh = 0.6 + 0.4 * min (sh, BlkHitSh (ro + 0.01 * sunDir, sunDir, 30.));
    col = objCol.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.) +
       0.1 * max (- dot (vn.xz, normalize (sunDir.xz)), 0.)) +
       objCol.a * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);
    col = mix (col, bgCol, clamp (4. * min (dstBlk, dstGrnd) / dstFar - 3., 0., 1.));
  } else col = bgCol;
  return clamp (col, 0., 1.);
}

// Function 4666
float SphereDist(vec3 position)
{
	return length(position - ExpPosition) - Radius;
}

// Function 4667
vec4 mapDistanceColor(const in vec3 point) {
  vec4 tmpPrim_156 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);
vec4 tmpPrim_157 = vec4(sdTorus(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-2.41)), vec2(1.49,0.26)) * 1.0, vec3(0.845866875,0.85,0.7983359375));
vec4 tmpComb_399 = opUnion(tmpPrim_156, tmpPrim_157);
vec4 tmpPrim_158 = vec4(sdTorus(pMod((mat4(1.0101120471954346,0.28705546259880066,0.0,0.0,-0.28705546259880066,1.0101120471954346,0.0,0.0,0.0,0.0,1.0501081943511963,0.0,0.06102079153060913,-0.21472446620464325,-0.2601988911628723,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.36,0.5)) * 0.9522828440977849, vec3(0.845866875,0.85,0.7983359375));
vec4 tmpComb_400 = tmpComb_399;
vec4 tmpComb_401 = opSubStairs(tmpComb_400, tmpPrim_158, vec2(0.17,1.69));
vec4 tmpPrim_159 = vec4(sdEllipsoid(pMod((mat4(0.25112131237983704,-0.2825120985507965,-0.9258104562759399,0.0,0.7474100589752197,0.6643630266189575,4.644800100095381e-9,0.0,0.6150742173194885,-0.6919600367546082,0.3779881000518799,0.0,0.362551212310791,-0.4078710079193115,0.268617182970047,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.5,1.52,0.5)) * 1.0000000012999473, vec3(0.46729687500000006,0.5884537500000001,0.9));
vec4 tmpComb_402 = tmpComb_401;
vec4 tmpComb_403 = opUnionStairs(tmpComb_402, tmpPrim_159, vec2(0.84,1.62));
vec4 tmpPrim_160 = vec4(sdTorus(pMod((mat4(0.5727498531341553,0.8041792511940002,-0.15891283750534058,0.0,-0.8191083073616028,0.5539072751998901,-0.14915919303894043,0.0,-0.03192776069045067,0.21559768915176392,0.9759598970413208,0.0,0.701280951499939,-0.5455323457717896,0.421924889087677,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec2(1.09,0.07)) * 0.9999999171907704, vec3(0.6595734375,0.9299999999999999,0.8326464374999999));
vec4 tmpComb_404 = tmpComb_403;
vec4 tmpComb_405 = opUnionRound(tmpComb_404, tmpPrim_160, 0.14);
vec4 tmpPrim_161 = vec4(sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,0.9679820537567139,-0.25101903080940247,0.0,0.0,0.25101903080940247,0.9679820537567139,0.0,0.4602626860141754,-1.420561671257019,0.592455267906189,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0)), vec3(0.71,0.4,1.0)) * 1.0, vec3(0.6006421874999999,0.97,0.8370311874999998));
vec4 tmpComb_406 = tmpComb_405;
vec4 tmpComb_407 = opSubColumns(tmpComb_406, tmpPrim_161, vec2(0.17,7.97));
return tmpComb_407;
}

// Function 4668
float floorsdf(vec3 pos) {
    return pos.z - (sin(pos.x * 5.) + sin(pos.y * 5.)) * 0.1;// * sin(iTime / 10.);
}

// Function 4669
float BoxSDF(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 4670
float dist(vec3 pos)
{
    return distUV(pos).x;
}

// Function 4671
float get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {
	
  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ,,()
  
  float f=b*d-a*a; // ()
  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;
  vec2 gf=2.0*(b*d21+d*d10+a*d20);
  gf=vec2(gf.y,-gf.x); // ()
  vec2 pp=-f*gf/dot(gf,gf); // 
  vec2 d0p=b0-pp; //  to origin
  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ,()
  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))
//  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // 
  float t=(ap+bp)/(2.0*a+b+d); // 
  return t;

}

// Function 4672
vec3 mapRMWaterNormal(vec3 pt, float e) {
    vec3 normal;
    normal.y = sdPlane(pt)+waterDetails(pt, iTime);    
    normal.x = (sdPlane(pt)+waterDetails(vec3(pt.x+e,pt.y,pt.z), iTime)) - normal.y;
    normal.z = (sdPlane(pt)+waterDetails(vec3(pt.x,pt.y,pt.z+e), iTime)) - normal.y;
    normal.y = e;
    return normalize(normal);
}

// Function 4673
float distanceFunction(vec3 pos){
    
    float disp = sin(pos.x*9.)*sin(pos.y*9.)*sin(pos.z*9.);
    disp*=.05;
    
    //pos.y+=sin(time);
    float sph = (length(pos) - 2.2);
   
    return sph+disp;
}

// Function 4674
float sceneMap3D(vec3 pos) {
    float t = SPHERE_1_SDF;
    
    float t2;
    if((t2 = SPHERE_2_SDF) < t) {
        t = t2;
    }
    
    return t;
}

// Function 4675
float map(in vec3 pos)
{
    float d = 1e10;
    

    // vesica 2D
    {
    vec3 q = pos - vec3(-3.0,0.0,-1.0);
    d = min(d,opExtrussion( q, sdVesica( q.xy, 0.7, 0.3 ), 0.005 ));
    }
    
    // extruded vesica
    {
    vec3 q = pos - vec3(-3.0,0.0,1.0);
    d = min(d,opExtrussion( q, sdVesica( q.xy, 0.7, 0.3 ), 0.4 ));
    }

    // cross 2D
    {
    vec3 q = pos - vec3(-1.0,0.0,-1.0);
    d = min(d,opExtrussion( q, sdCross( q.xy, vec2(0.8,0.35), 0.2 ), 0.005 ));
    }
    
    // extruded cross
    {
    vec3 q = pos - vec3(-1.0,0.0,1.0);
    d = min(d,opExtrussion( q, sdCross( q.xy, vec2(0.8,0.35), 0.2 ), 0.4 ));
    }

    // vesica 2D
    {
    vec3 q = pos - vec3(1.0,0.0,-1.0);
    d = min(d,opExtrussion( q, sdVesica( q.xy, 0.7, 0.3 ), 0.005 ));
    }
    
    // revolved vesica
    {
    vec3 q = pos - vec3(1.0,0.0,1.0);
     d = min( d, sdVesica(opRevolution(q,0.15-0.15*sin(iTime)), 0.7, 0.3 ) );
            
    }

    // cross 2D
    {
    vec3 q = pos - vec3(3.0,0.0,-1.0);
    d = min(d,opExtrussion( q, sdCross( q.xy, vec2(0.55,0.2), 0.1 ), 0.005 ));
    }
    
    // revolved cross
    {
    vec3 q = pos - vec3(3.0,0.0,1.0);
    d = min(d, sdCross( opRevolution(q,0.2+0.2*sin(iTime)), vec2(0.5,0.15), 0.1) );
    }

    return d;
}

// Function 4676
float map(in vec3 rp)
{
    vec3 v =  cos(T*.15+rp*15.)+ sin(T*.25+rp*10.);
    return sdTorus(rp, vec2(RADIUS, THICKNESS))-dot(v, v)*.005;
}

// Function 4677
Hit sphereSdf(vec3 p, vec3 c, float r) {
    Hit hit;
    hit.dist = length(p - c) - r;
    hit.color = vec3(1.0);
    return hit;
}

// Function 4678
vec4 CubeMap( sampler2D sam,  vec3 hitPos,  vec3 n,  float k)
{ 
    vec3 m = pow( abs( n ), vec3(k) );
	vec4 x = textureLod( sam, hitPos.yz,2. );
	vec4 y = textureLod( sam, hitPos.zx, 2. );
	vec4 z = textureLod( sam, hitPos.xy, 2. );
	return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);
}

// Function 4679
vec2 lineSegDist2D(vec2 a, vec2 b, vec2 p) {

    p -= a;
    b -= a;
    
    vec2 n = normalize(perp(b));
    
    float u = clamp(dot(p, b)/dot(b, b), 0., 1.);
    
    return vec2(dot(b, n) - dot(p, n), length(p-u*b));
    
}

// Function 4680
float scene(vec3 p) {
   //pR45(p.xz);
   pR(p.xz, touch.x*0.01); //time);
   pR(p.yz, touch.y*0.01);
   float sc, sc2, sc3, sc4, sc5;
   vec3 p2 = p, p3 = p;
   //p2.y+=cos(time);
   pMirrorOctant(p2.yz, vec2(0.50, 0.0));
   pModPolar(p2.yz, 6.0);
   p2 += v3(0.0, cos(time)*0.25, 0.0);
   sc = piston(p2);
   sc2 = nut(p);
   //sc /= fCylinder(p2, 0.25, 0.5);
   //sc2 = fCylinder(p2+v3(0.25, 0.0, 0.0), 0.125, 0.5);
   //sc3 = fOpUnionChamfer(sc, sc2, 0.125);
   sc3 = fOpUnionStairs (sc, sc2, 0.25, 8.0);
   pR(p3.xy, 1.5);
   sc4 = fCylinder(p3, 0.25, 0.05);
   sc5 = fOpEngrave( sc3, sc4, 0.25);
   p*= 2.0;
   vec3 p4 = pMod3(p,v3(1.0,2.0,0.50));
   float sco = fOpPipe(sc3, fBox(p,abs(fract(p2))), 0.01);//0.1);
   sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);
sco = min(sco, sco*1.25);


return sco;
}

// Function 4681
float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
    float tm = 0.0;
    float tx = 1000.0;    
    float hx = map(ori + dir * tx);
    if(hx > 0.0) return tx;   
    float hm = map(ori + dir * tm);    
    float tmid = 0.0;
    for(int i = 0; i < NUM_STEPS; i++) {
        tmid = mix(tm,tx, hm/(hm-hx));                   
        p = ori + dir * tmid;                   
    	float hmid = map(p);
		if(hmid < 0.0) {
        	tx = tmid;
            hx = hmid;
        } else {
            tm = tmid;
            hm = hmid;
        }
    }
    return tmid;
}

// Function 4682
vec3 tonemap(vec3 color)
{
    // Clamp Values Less Than 0.0
    color = max(color, 0.0);

    // Image Gamma
    const vec3 imageGamma = vec3(1.0/gamma);

    // Reinhard and Gamma-Correction
    color = pow(color/(color+1.0), imageGamma);
    //color = pow(tanh(color), imageGamma);

    // Return Tone-Mapped Color
    return clamp(color, 0.0, 1.0);
}

// Function 4683
float map(vec3 p){
    
 
    p.xy -= path(p.z); // Wrap the passage around
    
    vec3 w = p; // Saving the position prior to mutation.
    
    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*2.)); // Triangle perturbation.
   
    
    float ground = p.y + 0.02 + dot(op, vec3(.111))*.02; // Ground plane, slightly perturbed.
 
    p += (op - 0.05)*.33; // Adding some triangular perturbation.
   
	p = cos(p*.51*0.51 + sin(p.zxy*1.19*1.12)); // Applying the sinusoidal field (the rocky bit).
    
    float canyon = (length(p) - 0.72)*.45 - (w.x*w.x)*0.45; // Spherize and add the canyon walls.
    
    return min(ground, canyon);

    
}

// Function 4684
float map(vec3 p) {
   p.z += 1.;
   R(p.yz, -25.5);// -1.0+iMouse.y*0.003);
   R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
   return SunSurface(p) +  fpn(p*50.+iTime*25.) * 0.45;
}

// Function 4685
void minDistance (vec3 pos, sSphere sphere)
{ 
  vec3 rp = rotateZ (pos+sphere.position, iTime);
  float sd = Sphere(rp, sphere);
  if (sd > hit.dist) return;     // if no hit -> return 
  hit.color = sphere.color;      // save color
  hit.dist  = sd;                // save distance
}

// Function 4686
SDFResult sphereSDF(Sphere sphere, vec3 p) 
{
    vec3 diff = (sphere.pos - p);
    diff.y *= 0.65;
    return SDFResult(length(diff) - sphere.radius, sphere.matindex);
}

// Function 4687
float Mat2SDF( vec3 p )
{
    // blob
    vec3 p1 = p - .7*sin(vec3(1,quasirand2)*iTime);
	vec3 p2 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.x);
	vec3 p3 = p - .7*sin(vec3(1,quasirand2)*iTime*quasirand2.y);
    
    float r = .0;
    float a = length(p )-.8+.4;
    float b = length(p1)-.5+.4;
    float c = length(p2)-.5+.4;
    float d = length(p3)-.5+.4;
    
    // I based this on a smooth-min function, it didn't work as intended but it's pretty!
    float avg = (a+b+c+d)/4.;
    a -= avg;
    b -= avg;
    c -= avg;
    d -= avg;
    return (avg - sqrt( a*a+b*b+c*c+d*d+r*r ))*.8;
}

// Function 4688
float dstScene(vec3 p) {
    
    float dst = dstFloor(p, -1.);
    float sphDst = dstSphere(p, vec3(0.), 1.);
    sphDst = smin(sphDst, dstSphere(p, vec3(1.5 * sin(iTime),.5,-.5), .5), .1);
    sphDst = smin(sphDst, dstSphere(p, vec3(-1.5* sin(iTime),.25,-.5), .5), .1);
    
    dst = min(dst, sphDst);
    return dst;
    
}

// Function 4689
float map(vec3 p, inout object co)
{
    //find closest voronoi cell
    findClosest(p, co, 32);
    float DE = sdObj(p, co); //works well for spheres
    
    //improve distance estimate by using 
    //4 closest objects by sdf in this voronoi cell 
    //in this direction
    //you need this for arbitrary sdfs, like triangles
    int dir = int(inverseSF(normalize(p - co.X), float(link0)).x);
    vec4 nb = texel(ch0, i2xy(ivec3(co.id, dir%link0, 2)));
    for(int i = min(0, iFrame); i < 4; i++)
    {
        DE = min(DE, sdObj( p, getObject(int(nb[i])) ));
    }
    
    return min(DE, p.z+0.5);
}

// Function 4690
vec2 barrelDistortion( vec2 coord, float amt, float zoom )
{ // based on gtoledo3 (XslGz8)
  // added zoomimg
	vec2 cc = coord - 0.6;
    vec2 p = cc * zoom;
    coord = p + 0.6;
	float dist = dot( cc, cc );
	return coord + cc * dist * amt;
}

// Function 4691
vec3 heatColorMap(float t)
{
    t *= 4.;
    return clamp(vec3(min(t-1.5, 4.5-t), 
                      min(t-0.5, 3.5-t), 
                      min(t+0.5, 2.5-t)), 
                 0., 1.);
}

// Function 4692
float HexDist(vec2 p) {
	p = abs(p);
    float c = dot(p, normalize(vec2(1,1.73)));
    c = max(c, p.x);
    return c;
}

// Function 4693
IntersectionData CheckSceneForIntersection(in vec3 p)
{
    IntersectionData planeIntersectionData = IntersectionData(sdfPlane(p, vec4(0.0, 1.0, 0.0, 2.0)), GROUND);
    
    float curveScale = 2.0 / (3.0 - cos(2.0 * iTime));
    vec3 curvePoint = vec3(cos(iTime) * curveScale, -2.0 + sin(iTime * 0.5) * 2.0, sin(2.0 * iTime) * 0.5 * curveScale); 
    IntersectionData torusIntersectionData = IntersectionData(sdfTorus(p + curvePoint, vec2(2.0, 0.5)), TORUS);

    return GetClosestIntersection(planeIntersectionData, torusIntersectionData);
}

// Function 4694
vec3 calcNormalmap( in vec3 pos, in float ep )
{
#if 0    
    vec2 e = vec2(1.0,-1.0)*0.5773;
    return normalize(e.xyy*map(pos+e.xyy*ep).x + 
					 e.yyx*map(pos+e.yyx*ep).x + 
					 e.yxy*map(pos+e.yxy*ep).x + 
					 e.xxx*map(pos+e.xxx*ep).x );
#else
    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times
    vec3 n = vec3(0.0);
    for( int i=ZERO; i<4; i++ )
    {
        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);
        n += e*map(pos+e*ep).x;
    }
    return normalize(n);
#endif    
}

// Function 4695
vec3 GetReadMipMapUVW_Dir(vec3 _uvw,vec3 _axis){
    return normalize(
        ((_uvw+3.)*exp2(vec3(5.-10.,8.-10.,2.-10.))-1.)
        * (1.-abs(_axis)) 
        + _axis
    );
}

// Function 4696
SceneResult Scene_Union( SceneResult a, SceneResult b )
{
    if ( b.fDist < a.fDist )
    {
        return b;
    }
    return a;
}

// Function 4697
float sdf_centered_box(vec2 uv, vec2 center, vec2 size)
{
    return max(abs(uv.x-center.x) - size.x, abs(uv.y-center.y) - size.y);
}

// Function 4698
float dist(vec3 p, float r1, float r2){
    
    // Using inverse time values, and wrapping the polar angles to cooincide with
    // the underlying icosaheral segments.
    //p.xy *= rot2(mod(iTime/1.5, 3.*6.2831/15.) + 6.2831/2.);
    p.xy *= rot2(mod(iTime/1.5, 6.2831/5.) + 3.14159265);
    
    float a = atan(p.y, abs(p.x)); // Note the "abs" call.
    
    // The outer gear radius needs to taper as it approaches the center to avoid
    // overlap.
    r1 *= (.9 + p.z);
    
    // The outer cog teeth. Basically, we're applying the repeat polar space thing.
    vec3 q = p; 
    float ia = floor(a/6.2831*15.) + .5;
    q.xy = rot2(ia*6.2831/15.)*q.xy; // Convert to polar coordinates. X -> radius, Y -> angle.
    q.x += r1;// - .03/3.; // Move the radial coordinate out to the edge of the rim.
    q = abs(q);
    float spike = mix(max(q.x - .05, q.y - .02), length(q.xy*vec2(.7, 1)) - .025, .5);
    float d2 = max(spike, q.z - r2);
   
    // The inner spokes.
    q = p; 
    ia = floor(a/6.2831*5.) + .5;
    q.xy = rot2(ia*6.2831/5.)*q.xy;
    sph = max(max(abs(q.x), abs(q.y)) - .0225, abs(q.z - .07) - .06);
    //sph = max(length(q.xy) - .0225, abs(q.z - .07) - .06);
    q = abs(q + vec3(r1/2., 0, -.07));
    //spokes = max(max(q.x - r1/2. + .02, q.y - .03), q.z - .01);
    spokes = max(q.x - r1/2. + .02, max(max(q.y - .05, q.z - .015), (q.y + q.z)*.7071 - .025));
    
    // The inner cylindrical cog bit.
    p = abs(p);
    float d = length(p.xy);
    float di = abs(d  -  r1 + .1/2.) - .05/2.;
    d = abs(d  -  r1 + .075/2.) - .075/2.;
    d = min(max(d , p.z - r2), max(di , p.z - r2 - .01));
    
    // Return the minimum of the inner cog and teeth. The inner spokes have been kept global
    // for ID purposes and isn't include here... Yeah, messy, but this is a fiddly example
    // to work with. :)
    return min(d, d2);
    
}

// Function 4699
float distModel(vec3 pos, float time)
{
    float dist = SquareSize;
    //Look at the nearby files of the board to prevent artifacts
    //For some convenient reason, it works without examining the nearby ranks
    for(float dx = -1.0; dx < 2.0; dx += 1.0)
    {
        vec3 offset = vec3(dx, 0.0, 0.0) * SquareSize;
        if(piecePresent(pos + offset, time))
        {
        	dist = min(dist, pawn(worldToPawnCoords(pos + offset, time) - offset));
        }
    }
   
    dist = min(dist, pos.y - GroundHeight);
    return dist;
}

// Function 4700
float map003(vec2 p)
{
	float h;
    h = triangle(p, vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2));
    h = min(h, triangle(p-vec2(0.5, 0.4), vec2(0., -0.2), vec2(-0.2, 0.2), vec2(0.2, 0.2)));
    h = min(h, triangle(p-vec2(-0.5, 0.4), vec2(0., -0.2), vec2(-0.2, 0.2), vec2(0.2, 0.2)));
    
    h = min(h, triangle(p-vec2(0.5, -0.4), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));
    h = min(h, triangle(p-vec2(-0.5, -0.4), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));
    
    h = min(h, triangle(p-vec2(-1.0, 0.), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));
    h = min(h, triangle(p-vec2(1.0, 0.), vec2(0., 0.2), vec2(-0.2, -0.2), vec2(0.2, -0.2)));
    
    return h;
}

// Function 4701
float scene(vec3 p){
    p += vec3(0.08, 0.475, 0.0);
    p = p.zxy;
    // SDF is undefined outside the unit sphere, uncomment to witness the abominations
    if(length(p) > 1.0){
        return length(p)-0.8;
    }
    // Neural Networks can be really compact... When they want to be
    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));
    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));
    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));
    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));
    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+
        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+
        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+
        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+
        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;
    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+
        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+
        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+
        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+
        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;
    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+
        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+
        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+
        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+
        vec4(3.38,1.20,.84,1.41))/1.0+f02;
    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+
        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+
        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+
        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+
        vec4(-.34,-3.28,.43,-.52))/1.0+f03;
    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+
        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+
        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+
        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+
        vec4(.48,.87,-.87,-2.06))/1.4+f10;
    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+
        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+
        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+
        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+
        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;
    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+
        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+
        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+
        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+
        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;
    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+
        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+
        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+
        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+
        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;
    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+
        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;
}

// Function 4702
float mapEnv(in vec3 rp)
{
    _mapRP = rp + getMapHeight(rp.x);
    g_fbm = fbm  (abs(rp.xz) * ENV_P) * ENV_B;
    
    float d = groundDetail(_mapRP);
    _mapRP.y += d * .35 * g_fbm;
    rp.xy += g_fbm;
    return _mapEnv(rp);
}

// Function 4703
bool scene(Point3 X, inout float distance) {
    Material ignoreMaterial;
    return scene(X, distance, ignoreMaterial); 
}

// Function 4704
float map( vec3 p ) 
{
	//vec3 q = mod(pos,c)-0.5*c;
	p *= rotXY(vec2(time*.9,time*0.6));
	const float w = 1.5;
	vec3 q = abs(p);
	float d = max(max(q.z,q.y),q.x*0.15)-w;
	q*= .7;
	d = min(d,max(max(q.z,q.x),q.y*0.15))-w;
	q*= .5;
	d = min(d,max(max(q.x,q.y),q.z*0.15))-w;
	
	return d;
}

// Function 4705
float3 TonemapInvert(float3 c) { return c * rcp(1.0 - max3(c.r, c.g, c.b)); }

// Function 4706
float sdFakeRoundCone(vec3 p, float b, float r1, float r2)
{
    float h = clamp( p.y/b, 0.0, 1.0 );
    p.y -= b*h;
	return length(p) - mix(r1,r2,h);
}

// Function 4707
float Scene_SDF(vec3 p)
{
    return length(p) - 1.0;
}

// Function 4708
float map(vec3 p) {
	vec3 op;
    p.xz *= r2d(.1 * iTime);

	// pseudo free camera for debug
	//p.yz *= r2d(m2 * 3.14);

	

    // The floor (double floor for small noise + clean opUnionStairs
	float plan = p.y + 7. + noise(p.xz*.05);
	float plan2 = p.y + 8.;

	op = p;

	// cheap & lazy random pyramids
	pMirrorOctant(p.xz, vec2(50., 150));
	pMirrorOctant(p.xz, vec2(10., 50.));
	p.x = abs(p.x) - 100.;
	p.z = abs(p.z) - 90.;
	float d = fOctahedron(p + vec2(0., 20.).xyx, 40.);


	p = op;

    // centered octo
	p.y -= 10. + cos(iTime*1.5) * 2.;
	d = min(d, fOctahedron(p, 3.));
	p = op;

    // cheap & lazy stairs
	d = min(d, fBoxCheap(p - vec3(35., -3.3, 0.), vec3(3.)));
	d = fOpUnionStairs(d, fBoxCheap(p - vec3(40., -6.6, 0.), vec3(3.)), 3.2, 4.);

    
    // Here start the temple
	pMirrorOctant(p.xz, vec2(10., 6.));

	p.x = -abs(p.x) + 15.;

    // pillars
	p.y -= 3.;
	float torus = fTorus(p, 1., 2.2);
	float cylinder = fCylinder(p, 2., 16.);
	float cylinder2 = fCylinder(p, 2.2, 1.5);
	p.y += 3.8;
	float box = fBox(p, vec3(3.2));
	p.y += 2.5;
	float box2 = fBox(p, vec3(3.6));

	float box3 = fBox(p - vec2(0., 22.).xyx, vec3(2.7, 1., 2.7));
	float box4 = fBox(p - vec2(0., 21.).xyx, vec3(2.4, .3, 2.4));

	d = min(d, fOpUnionStairs(cylinder2, torus, .3, 3.));
	d = fOpUnionRound(box, d, .05);
	d = min(d, cylinder);
	d = min(d, box2);

	//d = min(d, fBox(p - vec2(15. + cos(iTime*0.75) * 4., 0.).xyy, vec3(6., 4., 6.)));

	d = min(d, fOpUnionColumns(box3, box4, .2, 3.));

	op = p;
    
    // roof
	p.y -= 25.;
	d = fOpUnionChamfer(d, fHexagonIncircle(p.yzx, vec2(3., 20.)), 1.2);

	//d = min(d, fBox(p.xyz, vec3(6, 1., 5.)));

	p = op;

    // temple's floor
	p.y += 7.;
	d = min(d, fBox(p, vec3(10.)));

	return min(plan, fOpUnionStairs(plan2, d, 3., 3.));

}

// Function 4709
vec3 mapBiome(vec3 x )
{
    x = planetRotation * x;
    
    vec3 p = floor( x );
    vec3 f = fract( x );

	float id = 0.0;
    
    // distance to closest and second closest
    vec2 res = vec2( 100.0 );
    // biome ID for closest and second closest
    vec2 resId = vec2(-1., -1.);
    
    for( int k=-1; k<=1; k++ )
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    {
        vec3 b = vec3(float(i), float(j), float(k));
        vec3 r = vec3( b ) - f + hash( p + b );
        float d = length(r);
        id = mod(abs(dot( p+b, vec3(1.0,57.0,113.0 ))), 3.);

        if( d < res.x )
        {
            res = vec2( d, res.x );
            resId = vec2( id, resId.x );
        }
        else if( d < res.y )
        {
            res.y = d;
            resId.y = id;
        }
    }
    
    float diff = res.y - res.x;
    
    // this is a giant hack. need a better way to blend between the voronoi regions.
    float ratio1 = min(1., pow(smoothstep(1., 3., clamp(res.y / res.x, 1., 3.)), .35) + .5);
    float ratio2 = 1. - ratio1;
        
    return vec3(resId.x == 0. ? ratio1 : resId.y == 0. ? ratio2 : 0.,
                resId.x == 1. ? ratio1 : resId.y == 1. ? ratio2 : 0.,
               	resId.x == 2. ? ratio1 : resId.y == 2. ? ratio2 : 0.);
}

// Function 4710
float shadowMap (vec3 ro, vec3 nor, Celestial o) {
	
	// Light data
	float lRad = sun.radius;
	vec3 lDir = sun.origin - ro;
	float lDis = length(lDir);
	lDir = normalize(lDir);
	
	// Occluder data
	float oRad = o.radius;
	vec3 oDir = o.origin - ro;
	float oDis = length(oDir);
	oDir = normalize(oDir);
	
	// Determine light visible "around" the occluder
	float l = lDis * ( length(cross(lDir, oDir)) - (oRad / oDis) );
	l = smoothstep(-1.0, 1.0, -l / lRad);
    l *= smoothstep(0.0, 0.2, dot(lDir, oDir));
	l *= smoothstep(0.0, oRad, lDis - oDis);
	
	// Return a multiplier representing our softshadow
	return 1.0-l;
}

// Function 4711
vec2 scene(vec3 pos)
{
	float vtree = tree(pos);
	#ifdef GRASS
	float vgrass = grass(pos);
	float v = min(vtree, vgrass);
	#else
	float v = vtree;
	#endif
	return vec2(v, v == vtree ? 2.0 : 1.0);
}

// Function 4712
vec2 map( vec2 p, in float offset )
{
	p.x += 0.1*sin( iTime + 2.0*p.y ) ;
	p.y += 0.1*sin( iTime + 2.0*p.x ) ;
	
	float a = noise(p*1.5 + sin(0.1*iTime))*6.2831;
	a -= offset;
	return vec2( cos(a), sin(a) );
}

// Function 4713
float distanceestimator(vec3 p){
    float plane = distance(p, vec3(p.x, -7.0, p.z))-1.0;
    float scale = 2.0;
	vec3 offset = p;
	float dr = 1.0;
	for (int n = 0; n < iterations; n++){
		boxFold(p, dr);
		sphereFold(p, dr);
        p = scale*p+offset;
        dr = dr*abs(scale)+1.0;}
	float r = length(p);
	return min(plane, r/abs(dr));}

// Function 4714
vec3 robobo1221sTonemap(vec3 x){
	return sqrt(x / (x + 1.0f / x)) - abs(x) + x;
}

// Function 4715
void construct_scene(inout Scene scene, inout vec3 Le, uint scene_idx)
{
    if (scene_idx==0u) /* First scene: Some spheres */
    {
        Le = vec3(1.0);
        
        int mat_idx;
        mat_idx = add(scene, create_Lambertian(vec3(1.0, 0.3, 0.1)));
        add(scene, 
            Sphere(vec3(0,0,0), 1.0, mat_idx)
        );
        
        mat_idx = add(scene, create_Lambertian(vec3(0.8)));
        add(scene, 
            Sphere(vec3(0,-101, 0), 100.0, mat_idx)
        );

        mat_idx = add(scene, create_Lambertian(vec3(0.3, 1.0, 0.0)));
        add(scene, 
            Sphere(vec3(1,3,-1), 1.7, mat_idx)
        );
    }
    else /* Second scene: Cornell Box */
    {
        Le = vec3(0.05);
        int mat_idx;
        /* Cornell box */
        float scale = 8.0;
        vec3 cb_offset = vec3(0);
        vec3 dim = scale*vec3(1.3, 1.7, 1.0);
        vec3 v1,e1,e2;
        vec3 col;

        /* back wall */
        v1 = 0.5*vec3(-dim.x, -dim.y, dim.z);
        e1 = vec3(dim.x, 0, 0);
        e2 = vec3(0, dim.y, 0);
        col = vec3(0.5, 0.5, 0.2);

        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* left wall */
        v1 = -0.5*dim;
        e1 = vec3(0,0,dim.z);
        e2 = vec3(0,dim.y,0);
        col = vec3(1.0, 0.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* right wall */
        v1 = 0.5*vec3(dim.x, -dim.y, -dim.z);
        e1 = vec3(0,0,dim.z);
        e2 = vec3(0,dim.y,0);
        col = vec3(0.1, 0.1, 1.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* top wall */
        v1 = 0.5*vec3(-dim.x, dim.y, -dim.z);
        e1 = vec3(0,0,dim.z);
        e2 = vec3(dim.x,0,0);
        col = vec3(0.0, 1.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        //float flicker_speed = 0.0;
        //scene.materials[mat_idx].Le = vec3((1.0+sin(flicker_speed*iTime))*vec2(1.0),0.0);
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );

        /* bottom wall */
        v1 = -0.5*dim;
        e1 = vec3(0,0,dim.z);
        e2 = vec3(dim.x,0,0);
        col = vec3(1.0, 1.0, 1.0);
        mat_idx = add(scene, create_Lambertian(col));
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );
        
        /* lamp */
        float lamp_scale = 0.5;
        v1 = 0.5*vec3(-lamp_scale*dim.x, dim.y*0.98, -lamp_scale*dim.z);
        e1 = lamp_scale*vec3(0,0,dim.z);
        e2 = lamp_scale*vec3(dim.x,0,0);
        col = vec3(0.0, 0.0, 0.0);
        mat_idx = add(scene, create_Lambertian(col));
        scene.materials[mat_idx].Le = vec3(5.0);
        /*add(scene, 
            Sphere(
                vec3(0), 3.0, 
                mat_idx
            )
        );*/
        add(scene, 
            Parallelogram(
                cb_offset+v1, cb_offset+v1+e1, cb_offset+v1+e2, 
                mat_idx
            )
        );
        
    }
}

// Function 4716
void raytrace_scene(
	vec4 ray_origin,
	vec4 ray_direction,
	out vec3 out_ray_color,
	out float out_ray_depth)
{
    out_ray_color = vec3(0.0, 0.0, 0.0);
    out_ray_depth = 10.0;
    
#ifdef ENABLE_HYPERSPHERES
    for (int bloblet_index = 0; bloblet_index < k_bloblet_count; bloblet_index++)
    {
        raytrace_sphere(
            s_bloblet_positions[bloblet_index],
            s_bloblet_radii[bloblet_index],
            ray_origin,
            ray_direction,
        	out_ray_color,
        	out_ray_depth);
    }
#endif
    
    vec4 tesseract_scale = vec4(0.6);
    //tesseract_scale = vec4(0.8, 0.2, 0.2, 0.7);
    tesseract_scale = vec4(0.6, 0.6, 0.6, 0.2);
      
    raytrace_tesseract(
		vec4(0.0, 0.3, 0.0, 0.0), // tesseract_center
        tesseract_scale,
    	ray_origin,
        ray_direction,
        out_ray_color,
        out_ray_depth);
        
    raytrace_plane(
    	vec4(0.0, -0.8, 0.0, 0.0),
    	normalize(vec4(0.0, 1.0, 0.0, 0.0)),
        ray_origin,
        ray_direction,
        out_ray_color,
        out_ray_depth);
}

// Function 4717
float mapWater( in vec3 p )
{
    float w = 0.0;
    float s = 0.5;
    vec2 q = p.xz;
    for( int i=0; i<4; i++ )
    {
        w += s*noise(q*vec2(0.5,1.0));
        q = 2.01*(q + vec2(0.03,0.07));
        s = 0.5*s;
    }
    w /= 0.9375;
    
    
    float h = hmin + (hmax-hmin)*w;
    

    float cr = 0.0;
    float wh = 0.2 + 0.8*smoothstep( 0.0, 75.0, -p.z );
    vec2 pp = p.xz/50.0;
    float d = 1e20;
    for( int j=-2; j<=2; j++ )
    for( int i=-2; i<=2; i++ )
    {
        vec2 o = floor( pp );
        o += vec2( float(i), float(j) );
        vec4 ra = texelFetch( iChannel0, ivec2(o)&255, 0 );
        o += ra.xy;
        vec3 r = p - vec3(o.x*50.0,-4.0-(1.0-wh)*5.0+ra.z*ra.z*2.0-3.0,o.y*50.0 + mod(10.0*iTime*0.2,50.0));
        r.yz = mat2(0.99,0.141,-0.141,0.99)*r.yz;
        d = smin( d, sdEllipsoid( r, vec3(0.0,0.0,0.0), (0.2+0.8*wh)*vec3(35.0,(0.1+0.9*ra.z*ra.z)*3.0,15.0)), 2.10 );
        
        float pm = (0.1+0.9*wh)*15.0;
        float cc = 1.0-smoothstep( 0.0, 2.0, abs(abs(r.z)-pm) );
        cr = max( cr, cc );
    }
    d = d - w*0.5;
    d = smin( d, p.y+4.0, 1.0);
    d = d - w*0.03;

    return d;
}

// Function 4718
void setupScene()
{
    materials[0] = makeLight(vec3(10.0, 11.0, 12.0));
    
    materials[1] = makeDiffuse(vec3(1.0, 1.0, 1.0));
    materials[2] = makeDiffuse(vec3(1.0, 0.5, 0.0));
    materials[3] = makeDiffuse(vec3(0.0, 0.5, 1.0));
    
    materials[4] = makeMetal(vec3(0.8, 0.3, 0.16));
    materials[5] = makePlastic(vec3(0.1, 0.7, 0.25));
    materials[6] = makeGlass(vec3(1.0, 1.0, 1.0));
    
    // shapes[0] = makeSphere(vec3(0.0, 10.0, 0.0), 10.0, 6);
    
    //*
    shapes[0] = makeSphere(vec3(-6.0, 3.0, 6.0), 3.0, 4);
    shapes[1] = makeSphere(vec3(+5.0, 5.0, 2.0), 5.0, 5);
    shapes[2] = makeSphere(vec3(-10.0, 15.0, 0.0), 5.0, 6);
    
    shapes[3] = makeBox(vec3(0.0, 0.0, 0.0), vec3(30.05, 0.2, 20.05), 1);
    shapes[4] = makeBox(vec3(0.0, 20.05, 0.0), vec3(30.05, 0.2, 20.05), 1);
    shapes[5] = makeBox(vec3(-15.0, 10.0, 0.0), vec3(0.1, 20.55, 20.55), 2);
    shapes[6] = makeBox(vec3(+15.0, 10.0, 0.0), vec3(0.1, 20.55, 20.55), 3);
    shapes[7] = makeBox(vec3(0.0, 10.0, -10.0), vec3(30.05, 20.05, 0.1), 1);
    
    shapes[8] = makeBox(vec3(0.0, 15.0, -9.0), vec3(19.99, 5.0, 1.0), 4);
    
    shapes[9] = makeBox(vec3(0.0, 20.0, 0.0), vec3(0.1, 0.2, 10.0), 0);
    shapes[10] = makeBox(vec3(0.0, 20.0, 0.0), vec3(10.0, 0.2, 0.1), 0);
	// */
}

// Function 4719
float map( vec3 r ) {
	return 
         (r.y-height(vec3(r.xz/10.,0))*2.)+noise(r/((tnt(iChannel2, r.xz/10., r.x+r.z).r+1.)/3.))/5./3.;	
}

// Function 4720
vec3 sceneGrad(highp vec3 p)
{
    const highp float h = GRAD_EPS;
    highp vec3 g;
    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;
    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;
    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;
    return g / (2.0*h);
}

// Function 4721
float map( in vec3 pos, out vec4 suvw, out float info )
{
    float dis;
	
	//-----------------------------
	// terrain
	float h = terrain( pos.xz );
	float mindist = pos.y - h;

	float t = treeBase( pos.xz );
	float treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);
	suvw = vec4( 0.0, 0.0, 0.0, treeOcc );

	// grass
	vec2 gd = grassDistr(pos.xz);
	float hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );
	float g = 0.2*hi * (gd.x * gd.y);
    mindist -= g;


	// mushroom position	
	float mushSca = 2.0;
	vec2  mushWPos = (0.5+floor(mushSca*pos.xz))/mushSca;
	vec3  mushPos = vec3( fract(mushSca*pos.x)-0.5, mushSca*(pos.y-h), fract(mushSca*pos.z)-0.5 );
    float mushID  = hash( floor(mushSca*pos.xz) );
	float mushToTree = treeBase(mushWPos);
	
	float sh = 0.2 * (0.5 + 1.0*mushID);
	
	suvw.w *= mix( 0.33 + 0.67*clamp( (length( mushPos.xz )-sh)*5.0, 0.0, 1.0 ), 1.0, 1.0*smoothstep( 0.35, 0.45, mushToTree + 0.5*(gd.x * gd.y) ) );
	suvw.w *= mix( smoothstep( 0.5, 1.0, hi ), 1.0, 1.0-gd.x );
	suvw.w *= 0.2 + 0.8*clamp( 2.0*abs(gd.x-0.5), 0.0, 1.0 );
	
	//-----------------------------
	// trees
	{
	float chsca = 0.2;
	vec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );
	float y = chos.y;
	float r = length( chos.xz );
		
	float ss = exp(-40.0*y*y);
	float dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );
	float sh = 0.08 + (0.1+0.25*ss)*dd;
		
    dis = (r - sh)/chsca;
	if( dis<mindist )
	{
		mindist = dis;
		suvw.x = 1.0;
		suvw.y = y;
		suvw.z = smoothstep( 0.0, 1.0, dd );
		suvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);
		info = atan( chos.x, chos.z );
	}		
		
	}
	
	//-----------------------------
	// mushrooms
	if( mushToTree < 0.4)
	{
    float an = mushroomAnim( iTime*(1.0+mushID) + 6.28*mushID );		

	float y = mushPos.y - 0.2 * 0.5;
	float r = length( vec3(mushPos.xz,y*2.0) );
	float sh = 0.2 * (0.5 + 1.0*mushID);
    sh *= an;		
    dis = (r - sh)/mushSca;
	if( dis<mindist )
	{
		mindist = dis;
		suvw.x = 2.0;
		suvw.y = mushID;
		suvw.z = mushPos.x / an;
		suvw.w = clamp( 0.5 + 0.5*y/.1, 0.0, 1.0 ) * treeOcc;
		info = mushPos.z / an;
	}		
		
	}


	
    return mindist * 0.5;
}

// Function 4722
float dist(vec2 v)
{
    float i = iso(v);
    vec2 g = grad(v);
    return abs(i) / length(g);
}

// Function 4723
float map(vec3 p) {
    float freq = SEA_FREQ;
    float amp = SEA_HEIGHT;
    float choppy = SEA_CHOPPY;
    vec3 uvt = vec3(p.xz, SEA_TIME); uvt.x *= 0.75;
    
    float d, h = 0.0;    
    for(int i = 0; i < ITER_GEOMETRY; i++) {        
    	d = sea_octave((uvt)*freq,choppy);
    	d += sea_octave((uvt)*freq,choppy);
        h += d * amp;        
    	uvt.xy *= octave_m; freq *= 1.9; amp *= 0.22;
        choppy = mix(choppy,1.0,0.2);
    }
    return p.y - h;
}

// Function 4724
SDFResult boxSDF2( RoundBox box, vec3 p )
{    
    p -= box.pos;
    vec3 d = abs(p) - box.dimensions;
    float l = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);

    float ridgex = mod(p.x, 1.0)-0.5;
    float ridgey = mod(p.y, 1.0)-0.5;
    float ridgez = mod(p.z, 1.0)-0.5;
    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;
    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;
    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;    
 
    return SDFResult((l - ridgex - ridgey - ridgez), box.matindex);
}

// Function 4725
vec2 map(vec3 pos)
{
    return map2(pos);
}

// Function 4726
float map(vec2 uv)
{
    float d = BOX1;
    d = min(d,BOX2);
    d = min(d,BOX3);
    d = min(d,BOX4);
    d = min(d,BOX5);
    d = min(d,BOX6);
    d = min(d,BOX7);
    d = min(d,BOX8);
    d = min(d,LIGHT_DIST);
    d = min(d,LIGHT_DIST2);
    return d;
}

// Function 4727
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 col, colR, vn;
  float dstObj;
  isRefl = false;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn = ObjNf (ro);
    col = ObjCol (rd, vn);
    if (idObj == 2) {
      rd = reflect (rd, vn);
      ro += 0.01 * rd;
      isRefl = true;
      dstObj = ObjRay (ro, rd);
      if (dstObj < dstFar) {
        ro += dstObj * rd;
        vn = ObjNf (ro);
        colR = ObjCol (rd, vn);
      } else colR = vec3 (0.1, 0.1, 0.2);
      col = mix (col, colR, 0.7);
    }
  } else col = vec3 (0.1, 0.1, 0.2);
  return clamp (col, 0., 1.);
}

// Function 4728
float sdfSphere(vec3 p){
	return length(p)-(sin(p.y*sin(p.x*2.)*3.)*1.3)-1.;
}

// Function 4729
float VoronoiDist(vec3 p, float threshold, out vec3 color)
{
    float min_dist = MAX_DIST;
        
    vec3 local_p = fract(p); // range [0., +1.]
    
    for(int x = -1; x <= 1; x++)
        for(int y = -1; y <= 1; y++)
            for(int z = -1; z <= 1; z++)
            {
                vec3 offset = vec3(x, y, z);
                vec3 id = floor(offset + p);

                vec3 local_center = R33(id);
                vec3 center = id + local_center;
                
                float dist = length(p - center);
                
                if (dist < min_dist)
                {
                    min_dist = dist;
                    color = R33(id);
                }
            }
    
    return min_dist - threshold;
}

// Function 4730
float SceneSDF(vec3 point) {

    float dist = SphereSDF(point + getSphere(0).xyz, Radius);
    
    for(int i = 1; i < NUM_SPHERES; ++i) {
        vec4 sphere = getSphere(i);
        float distA = SphereSDF(point + sphere.xyz, Radius);
        dist = SmoothMinSDF(dist, distA, sphere.a * SMOOTHFACTOR);
    }

    return dist;
}

// Function 4731
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec4 col4;
  vec3 col, vn;
  float dstHit, dstGrnd, dstObj, dstFlame, f, bk, sh;
  int idObjT;
  bool isGrnd;
  dstHit = dstFar;
  dstGrnd = GrndRay (ro, rd);
  dstFlame = TransObjRay (ro, rd);
  idObj = -1;
  dstObj = ObjRay (ro, rd);
  idObjT = idObj;
  if (dstObj < dstFlame) dstFlame = dstFar;
  isGrnd = false;
  if (dstObj < dstGrnd) {
    ro += dstObj * rd;
    dstHit = dstObj;
    vn = ObjNf (ro);
    idObj = idObjT;
    col4 = ObjCol (vn);
    if (idObj == idRfl) col4.rgb = 0.5 * col4.rgb +
       0.3 * SkyCol (ro, reflect (rd, vn));
    sh = ObjSShadow (ro, sunDir);
    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);
    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +
       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);
  } else {
    dstHit = dstGrnd;
    if (dstHit < dstFar) {
      ro += dstGrnd * rd;
      isGrnd = true;
    } else col = SkyCol (ro, rd);
  }
  if (isGrnd) {
    vn = VaryNf (3.2 * ro, GrndNf (ro, dstHit), 1.5);
    col4 = GrndCol (ro, vn);
    sh = GrndSShadow (ro, sunDir);
    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);
    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +
       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);
  }
  if (dstFlame < dstFar) col = FlameCol (col);
  if (dstHit < dstFar) {
    f = dstHit / dstFar;
    col = mix (col, 0.8 * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));
  }
  return sqrt (clamp (col, 0., 1.));
}

// Function 4732
float Map(float v, vec2 org, vec2 new){
    if(v <= org.x) return new.x;
    if(v >= org.y) return new.y;
    return (v-org.x)/(org.y-org.x)*(new.y-new.x) + new.x;
}

// Function 4733
vec3 SceneColor( C_Ray ray )
{
    float fHitDist = TraceScene(ray);
	vec3 vHitPos = ray.vOrigin + ray.vDir * fHitDist;
	
	vec3 vResult = texture(iChannel0, vHitPos.xyz).rgb;	
	vResult = vResult * vResult;
	
	#ifdef FORCE_SHADOW
	if( abs(vHitPos.z) > 9.48)
	{
		if( abs(vHitPos.x) < 20.0)
		{
			float fIntensity = length(vResult);
			
			fIntensity = min(fIntensity, 0.05);
			
			vResult = normalize(vResult) * fIntensity;
		}
	}
	#endif	
	
	#ifdef ENABLE_REFLECTION
	if(vHitPos.y < -1.4)
	{
		float fDelta = -0.1;
		float vSampleDx = texture(iChannel0, vHitPos.xyz + vec3(fDelta, 0.0, 0.0)).r;	
		vSampleDx = vSampleDx * vSampleDx;

		float vSampleDy = texture(iChannel0, vHitPos.xyz + vec3(0.0, 0.0, fDelta)).r;	
		vSampleDy = vSampleDy * vSampleDy;
		
		vec3 vNormal = vec3(vResult.r - vSampleDx, 2.0, vResult.r - vSampleDy);
		vNormal = normalize(vNormal);
		
		vec3 vReflect = reflect(ray.vDir, vNormal);
		
		float fDot = clamp(dot(-ray.vDir, vNormal), 0.0, 1.0);
		
		float r0 = 0.1;
		float fSchlick =r0 + (1.0 - r0) * (pow(1.0 - fDot, 5.0));
		
		vec3 vResult2 = texture(iChannel1, vReflect).rgb;	
		vResult2 = vResult2 * vResult2;
		float shade = smoothstep(0.3, 0.0, vResult.r);
		vResult += shade * vResult2 * fSchlick * 5.0;
	}
	#endif
	
	if(iMouse.z > 0.0)
	{
		vec3 vGrid =  step(vec3(0.9), fract(vHitPos + 0.01));
		float fGrid = min(dot(vGrid, vec3(1.0)), 1.0);
		vResult = mix(vResult, vec3(0.0, 0.0, 1.0), fGrid);
	}
	
	return sqrt(vResult);    
}

// Function 4734
SceneResult Scene_TubesSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    float fTime = 0.0f;
    
    
    SceneResult resultFloor;
    
    resultFloor.fDist = vPos.y;
    resultFloor.vUVW = vec3(vPos.zxy * 0.1);
    resultFloor.iObjectId = MAT_TEXTURED_FLOOR;

            
    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );            	
        
    SceneResult resultTube;
    
    float fTubeRadius = 0.1;
    float fTubeHeight = 1.5;
    
    vec3 vTubeDomain = vPos - vec3( 0, fTubeRadius, 0);
    
    float fStandBaseHeight = 0.2;
    vTubeDomain.y -= fStandBaseHeight;
    
    vec2 vTile;
    vec2 vRepeatSpacing = vec2(0.5, 0.5);
    vec2 vRepeatMax = vec2(1,3);
    vTubeDomain = DomainRepeatXZLimitGetTile( vTubeDomain, vRepeatSpacing, vRepeatMax, vTile ); 
    
    float fLipDist = length( vec2(length(vTubeDomain.xz)-fTubeRadius - 0.02,vTubeDomain.y - fTubeHeight) ) - 0.01;
    
    float fClosestY = clamp( vTubeDomain.y, 0.0, fTubeHeight );
    float fTubeDist = length( vTubeDomain - vec3(0, fClosestY, 0 )) - fTubeRadius;
    float fGlassDist = abs( fTubeDist ) - 0.02;    
    fGlassDist = max( fGlassDist, vTubeDomain.y - fTubeHeight);
    fGlassDist = min( fGlassDist, fLipDist );
    resultTube.fDist = fGlassDist;
    resultTube.vUVW = vPos;
    resultTube.iObjectId = MAT_COLORLESS_GLASS;

    SceneResult_Combine( resultInside, resultOutside, resultTube, insideObjId );            	

    float fLiquidHeight = 0.75 + sin(vTile.x * 12.234 + vTile.y * 3.456) * 0.6;
    
    float fLiquidDist = fTubeDist;
    fLiquidDist = max( fLiquidDist, vTubeDomain.y - fLiquidHeight );

    SceneResult liquidResult;
    liquidResult.fDist = fLiquidDist;
    liquidResult.vUVW = vPos;
    liquidResult.iObjectId = MAT_COLORED_GLASS;

    if ( HashWang( uint(vTile.x + vTile.y * vRepeatMax.x + 5.) ) % 2u == 0u )
	{
	    liquidResult.iObjectId = MAT_COLORED_GLASS_2;
    }
    
    SceneResult_Combine( resultInside, resultOutside, liquidResult, insideObjId );      


    float fStandDist = 100.0;
    {
        float fBevel = 0.05;
        float fBorder = 0.3;
        vec3 vStandMin = vec3(-fBorder, 0.0, -fBorder);    
        vec3 vStandMax = vec3(fBorder, fStandBaseHeight, fBorder);
        vStandMax.xz += vec2(vRepeatMax * vRepeatSpacing);
        vec3 vClosest = clamp( vPos, vStandMin + fBevel, vStandMax - fBevel );
        fStandDist = min( fStandDist, length( vClosest - vPos ) - fBevel );
    }
    
    {
        float fBevel = 0.05;
        float fBorder = 0.2;
        float fStandRackHeight = 1.0;
        float fStandRackSize = 0.1;
        vec3 vStandMin = vec3(-fBorder, fStandRackHeight, -fBorder);    
        vec3 vStandMax = vec3(fBorder, fStandRackHeight + fStandRackSize, fBorder);
        vStandMax.xz += vec2(vRepeatMax * vRepeatSpacing);
        vec3 vClosest = clamp( vPos, vStandMin + fBevel, vStandMax - fBevel );
        float fRackDist = length( vClosest - vPos ) - fBevel;
        fRackDist = max( fRackDist, -(fTubeDist - 0.04) );
        fStandDist = min( fStandDist, fRackDist );
    }
    
    {
        vec3 vStandPoleDomain = vPos;
        vStandPoleDomain.x -= vRepeatSpacing.x * 0.5;
        float fMirror = 0.8;
        vStandPoleDomain.z = (-abs(vStandPoleDomain.z - fMirror) + fMirror);
        float fPoleDist = length(vStandPoleDomain.xz) - 0.05;

        fPoleDist = max( fPoleDist, (vStandPoleDomain.y - 1.0) );
        
        fStandDist = min( fStandDist, fPoleDist );
        
    }
    
  	SceneResult standResult;
    standResult.fDist = fStandDist;
    standResult.vUVW = vPos;
    standResult.iObjectId = MAT_STAND;

    SceneResult_Combine( resultInside, resultOutside, standResult, insideObjId );      
    
  	SceneResult sph1result;
    
    vec3 vSph1Pos =  vPos - vec3(3,2,0);
    sph1result.fDist = length(vSph1Pos) - 0.5;
    sph1result.vUVW = vec3(vPos);
    sph1result.iObjectId = MAT_EMISSIVE_LIGHT;
    
    SceneResult_Combine( resultInside, resultOutside, sph1result, insideObjId );      
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 4735
vec3 SceneNormal(in vec3 pos, in float depth)
{
    vec2 eps = vec2(0.001 * depth, 0.0);
    return normalize(vec3(Scene(pos + eps.xyy, 0.0).x - Scene(pos - eps.xyy, 0.0).x,
                          Scene(pos + eps.yxy, 0.0).x - Scene(pos - eps.yxy, 0.0).x,
                          Scene(pos + eps.yyx, 0.0).x - Scene(pos - eps.yyx, 0.0).x));
}

// Function 4736
vec2 fastMap( in vec3 pos ) {
    return opU( vec2( fastObjPrentenTentoonstelling( pos), 1.0 ),
	            vec2( udBox( (pos+vec3(3.30, -4.55, -5.55)), vec3( 0.55, 0.7, 0.01 ) ), 2. ) );
}

// Function 4737
float SDFCubic( in vec2 coords )
{
    float v = coords.x * coords.x * coords.x - coords.y;
    vec2  g = vec2(3.0 * coords.x * coords.x, -1.0);
    return abs(v)/length(g);    
}

// Function 4738
vec2 Scene(in vec3 p)
{
    return U(ShaderBall(p), 
             vec2(Box(p + vec3(0.0, 0.5, 0.0), vec3(10.0, 0.5, 4.0)), 1.0));  // Wood platform/table
}

// Function 4739
float backgroundMap(vec2 uv) {
    float scale = 1.5;
    float repeat = 3.55;

    uv.y *= -1.;
    uv /= scale;

    vec2 uv2 = uv;
    uv.x += time * repeat;
    vec2 uv3 = uv;

    pMod1(uv.x, repeat);
    uv.x += 1.2;

    pR(uv3, PI * .5);
    uv3 -= time * repeat;

    vec2 warp = vec2(0);
    warp += sin((uv3 / repeat * PI * 1.) * 2.) * .2;
    warp *= sin(uv2.x * PI * 1.5 + PI / 2.) * .5 + .5;
    warp += sin(uv2 * PI + PI / 2.) * .1;

    uv += warp;

    float d = fNova(uv, .06) * scale;

    return smoothstep(-0.01, .0, d);
}

// Function 4740
vec2 interiorMap( in vec3 pos ) {
    float r1 = 0.4;
    float r2 = 0.19;
    float k = 16.0; 
    return vec2(-smin(
        sdTorus((pos - vec3( r1 + r2 * 0.8, r1 + r2, 0.0)).yzx, vec2(r1, r2)),
        sdTorus(pos - vec3( -r1 - r2 * 0.8, r1 + r2, 0.0), vec2(r1, r2)),
    k), f(pos));
}

// Function 4741
float get_player_distance(vec3 position, vec4 plane)
{
    return dot(position, plane.xyz) + plane.w - get_player_radius(plane.xyz);
}

// Function 4742
float intersectSDF(float distA, float distB)
	{ return max(distA, distB);}

// Function 4743
float dist_func(vec3 p)
{
    float rot = 60.0*3.14 / 180.0;
	rot *= iTime;
	vec3 q = rotate(p,rot,vec3(1,1,1));
    
    q.x*=sin(iTime*0.5);
    vec3 e=trans(q);
   
    float d2=dist_cube(e);
    float d1=dist_tolus(e,vec2(1.5,0.25));
    float d3=dist_cylinder(e,vec2(0.75,0.25));
    
    return smooth_min(smooth_min(d1,d2,16.0),d3,16.0) ;
}

// Function 4744
vec3 tonemap( vec3 linearRGB )
{
    const float limitHardness = 1.5;
    
    vec3 okl = rgb_to_oklab(linearRGB);
    
    // Limit luminance.
    okl.x = okl.x / pow(pow(okl.x, limitHardness) + 1., 1./limitHardness);
    
    // Limit magnitude of chrominance.
    {
        float mag = length(okl.yz);
        float magAfter = mag;
        // Limit the magnitude to 0.25 to avoid RGB clipping.
        magAfter *= 4.;
        magAfter = magAfter / pow(pow(magAfter, limitHardness) + 1., 1./limitHardness);
        magAfter /= 4.;
        okl.yz *= magAfter/mag;
    }
    
    linearRGB = oklab_to_rgb(okl);
  
    return Srgb3(linearRGB);
}

// Function 4745
void TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
{

     // to move the scene around, since we can't move the camera yet
    vec3 sceneTranslation = vec3(0.0f, 0.0f,50.0f);
    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);
    
   	// back wall
    {
        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 B = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 C = vec3( 24.f,  24.f, 48.0f) + sceneTranslation;
        vec3 D = vec3(-24.f,  24.f, 48.0f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        }
	}    
    
    // floor
    {
        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 B = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 C = vec3( 24.f, -24.f, 0.0f) + sceneTranslation;
        vec3 D = vec3(-24.f, -24.f, 0.0f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        }        
    }
    
    // cieling
    {
        vec3 A = vec3(-24.f, 24.f, 48.0f) + sceneTranslation;
        vec3 B = vec3( 24.f, 24.f, 48.0f) + sceneTranslation;
        vec3 C = vec3( 24.f, 24.f, 0.0f) + sceneTranslation;
        vec3 D = vec3(-24.f, 24.f, 0.0f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        }        
    }    
    
    // left wall
    {
        vec3 A = vec3(-24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 B = vec3(-24.f, -24.f, 0.0f) + sceneTranslation;
        vec3 C = vec3(-24.f,  24.f, 0.0f) + sceneTranslation;
        vec3 D = vec3(-24.f,  24.f, 48.0f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);
            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        }        
    }
    
    // right wall 
    {
        vec3 A = vec3( 24.f, -24.f, 48.0f) + sceneTranslation;
        vec3 B = vec3( 24.f, -24.f, 0.0f) + sceneTranslation;
        vec3 C = vec3( 24.f,  24.f, 0.0f) + sceneTranslation;
        vec3 D = vec3( 24.f,  24.f, 48.0f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.1f, 0.1f, 0.7f);
            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        }        
    }    
    
    // light
    {
        vec3 A = vec3(-9.0f, 24.0f,  30.f) + sceneTranslation;
        vec3 B = vec3( 9.0f, 24.0f,  30.f) + sceneTranslation;
        vec3 C = vec3( 9.0f, 24.0f,  16.f) + sceneTranslation;
        vec3 D = vec3(-9.0f, 24.0f,  16.f) + sceneTranslation;
        if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
        {
            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);
            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 50.0f;
        }        
    }
    
    //left reflective sphere
	if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-12.0f, -16.f, 30.0f, 8.0f)+sceneTranslation4))
    {
        hitInfo.material.albedo = vec3(1.f, 1.f, 1.f);
        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);     
                 
        hitInfo.material.specularChance = 0.9f;
        hitInfo.material.specularRoughness = 0.005;
        hitInfo.material.specularColor = vec3(1.0f, 1.0f, 1.0f);
        hitInfo.material.IOR = 1.f;
        hitInfo.material.refractionChance = 0.0f;
        hitInfo.material.refractionRoughness = 0.f;
        hitInfo.material.refractionColor = vec3(0.0f, 0.0f, 0.0f);
    } 
    
    //right refractive sphere
	if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(12.0f, -16.f, 20.0f, 8.0f)+sceneTranslation4))
    {
        hitInfo.material.albedo = vec3(1.f, 1.f, 1.f);
        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);     
                 
        hitInfo.material.specularChance = 0.001f;
        hitInfo.material.specularRoughness = 0.0;
        hitInfo.material.specularColor = vec3(1.0f, 1.0f, 1.0f);
        hitInfo.material.IOR = 1.5f;
        hitInfo.material.refractionChance = 1.f;
        hitInfo.material.refractionRoughness = 0.0f;  
    }    
      


}

// Function 4746
float map(in vec4 p) {
    // The object
	float d;
    	 if (Step == 0.) d = sdCubicalCylinder(p, vec3(.325,.4,.3));
    else if (Step == 2.) d = sdDuoCylinder(p, vec2(.325,.45));
    else if (Step == 3.) d = sdBox(p, vec4(.2,.25,.35,.35));
    //else sdSphere(p,.45)
    else    	     	 d = max(sdCubicalCylinder(p, vec3(.35,.24,.3)),-sdDuoCylinder(p, vec2(.225,.55)));
    // The 4 Axes
	d = min(d, min(min(min(length(p.xyz),
						   length(p.wxy)),
						   length(p.zwx)),
						   length(p.yzw)) - .025);
   // d = min(d, abs(-pos.x)-.02); // add this for nice effect !  :-)
    return d;
}

// Function 4747
vec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){
    
    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.
    const vec2 e = vec2(.001, 0); 
    
    // Gradient vector: vec3(df/dx, df/dy, df/dz);
    float ref = bumpSurf3D(p);
    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),
                      bumpSurf3D(p - e.yxy),
                      bumpSurf3D(p - e.yyx)) - ref)/e.x; 
    
    /*
    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.
    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),
                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),
                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;
    */
       
    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind 
    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.
    grad -= nor*dot(nor, grad);          
         
    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.
    return normalize(nor + grad*bumpfactor);
	
}

// Function 4748
float Map(in vec3 p)
{
	float h = terrain(p.xz); 
    return p.y - h;
}

// Function 4749
float getSDF(vec3 position, inout int id) {
    float dist = 1e10;
    float oldDist = dist;

    //Two variables for temporary position manipulation
    vec3 q;
    vec4 w;

    //Unused here
    vec3 n;
    
    //Head
    q = position;
   	setPosition(q, n, HEAD);
    w = opElongate(q, vec3(-0.08, 0, 0));
    dist = min(dist, sphereSDF(w.xyz, 0.7));
    trackMaterial(oldDist, dist, id, HEAD);
    
    //Ears, mirrored
    q = position;
    q.z = abs(q.z);
    setPosition(q, n, EARS);
    dist = min(dist, torusSDF(q, 0.12, 0.12));
    trackMaterial(oldDist, dist, id, EARS);
   
    //Snout
    q = position;
    setPosition(q, n, SNOUT);
    w = opElongate(q, vec3(-0.08, 0, 0));
    dist = min(dist, sphereSDF(w.xyz, 0.3));
    trackMaterial(oldDist, dist, id, SNOUT);
    
    //Body
    q = position;
    setPosition(q, n, BODY);
    w = opElongate(q, vec3(-0.2, 0.2, -0.08));
    dist = min(dist, sphereSDF(w.xyz, 0.75));
    trackMaterial(oldDist, dist, id, BODY);
    
    //Arms, mirrored
    q = position;
    q.z = abs(q.z);
    setPosition(q, n, ARMS);
    dist = min(dist, sdRoundCone(q, 0.3, 0.28, 0.7));
    trackMaterial(oldDist, dist, id, ARMS);
	
    //Legs, mirrored
    q = position;
    q.z = abs(q.z);
    setPosition(q, n, LEGS);
    dist = min(dist, sdRoundCone(q, 0.3, 0.3, 0.7));
    trackMaterial(oldDist, dist, id, LEGS);
    
    //Nose
    q = position;
    setPosition(q, n, NOSE);
	w = opElongate(q, vec3(-0.04,0.0, 0.02) );
    dist = min(dist, sphereSDF(w.xyz, 0.08));
    trackMaterial(oldDist, dist, id, NOSE);
    
    //Eyes, mirrored
    q = position;
    q.z = abs(q.z);
    setPosition(q, n, EYES);
    dist = min(dist, sphereSDF(q, 0.05));
    trackMaterial(oldDist, dist, id, EYES);
    
    //Tail
    q = position;
    setPosition(q, n, TAIL);
    dist = min(dist, sphereSDF(q, 0.15));
    trackMaterial(oldDist, dist, id, TAIL);

    return dist;
}

// Function 4750
float map(vec3 p){
    
    // Sampling the 2D jigsaw pattern value from the texture, then passing it
    // into a relatively cheap 3D extrusion function to give the final distance
    // value.
    vec4 jigDist = texture(iChannel0, p.xy/4. + .5);
    vec2 jig = jigsaw(p - vec3(moveXY(iTime), 0), jigDist);
    
    //surf2D = jig.y; // Just the 2D value. Used for some cheap edging.
 
    return jig.x*.866; // 3D extruded distance field value.
    
    
}

// Function 4751
vec3 normalMap(in vec3 p){
  
    vec2 e = vec2(-1., 1.)*.001;  
    
	float d1 = detail(p + e.yxx), d2 = detail(p + e.xxy);
	float d3 = detail(p + e.xyx), d4 = detail(p + e.yyy); 
    
    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );
	return n1;   
}

// Function 4752
vec2 map(in vec3 l, in qdr q) {
	//https://en.wikipedia.org/wiki/Quadric#Projective_geometry ???
    return (l.xz - l.y) - (q.l.xz - q.l.y) ;
}

// Function 4753
float mapThing( vec3 p)
{
    float T = -voronoi3D(p);
    return T + sdCapsule(p, vec3(0.0, 20.0, 0.0), vec3(0.0, -20.0, 0.0), 1.0);
    return T+sdCone(p, vec2(2.0, 0.1));
}

// Function 4754
float getSphereMappedTexture(in vec3 pointOnSphere) {
    /* Test to determine which face we are drawing on.
     * Opposing faces are taken care of by the absolute
     * value, leaving us only three tests to perform.
     */
    vec2 st = abs(
        insideBounds(sphereToCube(pointOnSphere    )) +
        insideBounds(sphereToCube(pointOnSphere.zyx)) +
        insideBounds(sphereToCube(pointOnSphere.xzy)));
    return textureFunc(st);
}

// Function 4755
vec3 sceneNormal(vec3 point, float worldTime) {
  #if 0
    float epsilon = 0.0001;
    vec3 xOffset = vec3(epsilon, 0.0, 0.0);
    vec3 yOffset = vec3(0.0, epsilon, 0.0);
    vec3 zOffset = vec3(0.0, 0.0, epsilon);
    
    vec3 direction = vec3(
        sceneDistance(point + xOffset, worldTime) - sceneDistance(point - xOffset, worldTime),
        sceneDistance(point + yOffset, worldTime) - sceneDistance(point - yOffset, worldTime),
        sceneDistance(point + zOffset, worldTime) - sceneDistance(point - zOffset, worldTime)
    );
    
    return normalize(direction);
  #else
    // Snagged from iq's "Raymarching - Primitives" shader,
    // which in turn says this is inspired by tdhooper and klems.
    vec3 n = vec3(0.0);
    for(int i = ZERO; i < 4; i += 1) {
        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);
        n += e * sceneDistance(point + 0.0005 * e, worldTime);
    }

    return normalize(n);
  #endif
}

// Function 4756
Hit map2(vec3 p) {
    Hit res = jerryfish(p);
    res = opUnion(res, bubbles(p));
    return res;
}

// Function 4757
float sdfMap(vec2 uv) { return sdfEqTri(uv); }

// Function 4758
vec3 marchScene(vec3 ro, vec3 rd
){vec2 m=1.-iMouse.xy/iResolution.xy;//m could be identical to ScreenSpace.xy
 //[l] lazily coutneracts overstepping for higher precision in its gradient descent.
 //     by intentional understepping, assuming lipschits constant >1,
 float l=m.x;//set by iMouse.x
 //dynamic number of iterations lacks backwards compatibility.
 float iterMax=450.*m.y;//set by Mouse.y
 //float EPS=0.001; ish.
 //loop accumulators:
 float t=.0,     // t=distanceToCamera (without epsilon)
       g=.0;     // VolumeMarched smoothstep glow: +=lerp((exp(-SquaredDistanceToGlowCenter)))
 vec2  r=vec2(0);// .x=distanceToSurface .y=MaterialID
 for (float i = 0.; i < iterMax; i++){
     vec3 p=ro + rd * t;//pointOnRay
     vec2 r = map(p);   //shortest euclideanPointDistance to distanceField of pointOnRay.
 #ifdef DynamicEps
     if (t>FAR|| log(t*t*EPS/r.x)>0.) break;//zFar || logEps        exits
     //above is very basic logeps, IFF (scene is scaled properly) it relpaces the line below.
 #else
     if (t>FAR||         EPS>r.x    ) break;//zFar || zNearSurface  exits
 #endif
     g += smoothstep(0.,1.,1.2*exp(-dot(p,p)));//increment glow
     t += r.x*l ;}//march along ray
 return vec3(t,g,r.y);}

// Function 4759
vec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )
{
    pos.xz = rot(pos.xz,0.2);

    vec4 res = vec4(pos.y+36.0,0,0,0);    
    
    outMat = 1.0;
    uvw = pos;
    
    //-------
    {
    vec2 d2 = sdBridge(pos);
    if( d2.x<res.x )
    {
        res.xy = d2;
        outMat = 2.0;
    }
    }
    //-------
    float d = sdGround(pos);
    if( d<res.x )
    {
        res.x = d;
        outMat = 4.0;
    }
    //-------
    float bb = pos.z+450.0;
    if( bb<d )
    {
    vec3 d2 = sdForest(pos,d);
    if( d2.x<res.x )
    {
        res.x = d2.x;
        res.y = d2.y;
        res.z = d2.z;
        outMat = 3.0;
    }
    }
    
    return res;
}

// Function 4760
float signed_distance(in vec3 p) {
    float displacement = -fractal_brownian_motion(p*3.4 + vec3(0.1, 0.1, 0.1)*iTime)*noise_amplitude;
    return length(p) - (sphere_radius + displacement) * (0.1 + 0.9*sin(mod(iTime*(2./3.1416), 3.1416/2.)));
}

// Function 4761
float dist(vec3 v){
	float s = 1.3;
	float r = mix(s, s*1.75, 0.5*sin(2.0*iTime) + 0.5);
	
	vec3 c = vec3(s*8.0);
	v = mod(v, c) - 0.5*c;
	
	float d = d_box(v, vec3(0), vec3(2.0*s));
	d = d_subtract(d, d_sphere(v, vec3(0), r));
	d = d_union(d, d_sphere(v, vec3(0), r*0.9));
	return d;
}

// Function 4762
float map_cognac(vec3 pos)
{
    #ifdef show_cognac
    if (!traceGlass)
        return 10.;
    
    #ifdef show_glass
    vec3 pos2 = (pos + glassPos)*0.88;

    #ifdef bumped_glass
    pos2+= getGlassBump(pos2);
    #endif
    #ifdef show_plate
    pos2.y-= -0.153 + plateThickness*2.;
    #endif
    
    float gc = map_glass_int(pos2);
    float be2 = 1./(pow(abs(gc - 0.01), 2.5));
    gc = max(gc, pos2.y - 0.03 - clamp(0.0000002*be2, 0., 0.026)) + 0.015;
    #endif
    
    pos = rotateVec2(pos);
    pos+= vec3(0.02, 0.56, 0.03);
    pos*= 1.25;
    
    float lev = 0.35; //iTime*0.01;
    float intb = map_bottle_int(pos);
    float be = 1./(0.000015 + pow(abs(intb), 2.5));
    float df = max(intb, pos.y + 0.48 - clamp(0., 1., lev)*3.15 - clamp(0.0000004*be, 0., 0.05));

    #ifdef show_glass
    df = min(gc, df);
    #endif
    
    #ifdef dev_mode
    df = max(df, pos2.z);
    #endif 
    return df;
    #else
    return 10.;
    #endif
}

// Function 4763
float map(vec3 p){
   
    float tx = heightMap(p);
    
    return 1.2 - p.z + (.5 - tx)*.125;
    
}

// Function 4764
float distanceEstimator(Point3 X) {
    float d = inf;
    scene(X, d);
    return d;
}

// Function 4765
float map( vec2 c ) 
{
	return 20.0*textureLod( iChannel0, fract((c+0.5)/iChannelResolution[0].xy), 0.0 ).x;
}

// Function 4766
float Map(vec3 p)
{
	float h = -(FBM(p)-cloudy-.6);
    
	return h;
}

// Function 4767
vec2 mapSmallElephant( vec3 p, out vec3 matInfo )
{
    matInfo = vec3(0.0);
    vec3 oop = p;
    const float sca = 2.0;
    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;
    p *= sca;
    
    p -= vec3(-1.1,2.4,-2.0);
        
    vec3 ph = p;
    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;
        
    // head
    float d1 = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.38) );

    // nose
    vec2 kk;
    
    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,-0.2,-0.1), vec3(-0.7,-0.5,0.1), ph, kk );    
    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);
    vec2 b2 = sdBezier( vec3(-0.7,-0.5,0.1), vec3(-0.7,-0.8,0.3), vec3(-0.4,-0.8,0.8), ph, kk );
    
    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);
    float bd1 = b1.x-tr1;
    float bd2 = b2.x-tr2;
    float nl = b1.y*0.5;
    float bd = bd1;
    if( bd2<bd1 )
    {
        nl = 0.5 + 0.5*b2.y;
        bd = bd2;
    }
    
    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);
            
    float d2 = bd;
    float xx = nl*120.0;
    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));
    d2 += 0.005*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);

    float d = smin(d1,d2,0.2);

    vec3 qh = vec3( ph.xy, abs(ph.z) );

    // eyes
    {
    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.23) );
    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));
    d = smin( d, d3, 0.03 );
    mat3 rot = mat3(0.8,-0.6,0.0,
                    0.6, 0.8,0.0,
                    0.0, 0.0,1.0 );
    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
	d = smax(d, -d4, 0.04 );
    }


    vec3 q = vec3( p.xy, abs(p.z) );

    // body
    {
    float co = cos(0.4);
    float si = sin(0.4);
    vec3 w = p;
    w.xy = mat2(co,si,-si,co)*w.xy;
        
    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );
	d = smin(d, d4, 0.1 );

    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );
	d = smin(d, d4, 0.2 );
    }

    // back-left leg
    {
    float d3 = sleg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75 );
    d = smin(d,d3,0.1);
    }
    
	// tail
    #if 0
    {
    vec2 b = sdBezier( vec3(2.6,0.,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );
    float tr = 0.10 - 0.07*b.y;
    float d2 = b.x - tr;
    d = smin( d, d2, 0.05 );
    }
    #endif
    
    // front-left leg
    {
    float d3 = sleg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );
    d = smin(d,d3,0.15);
    d3 = sleg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );
    d = smin(d,d3,0.15);
    }
            
#if 1
    // ear
    float co = cos(0.5);
    float si = sin(0.5);
    vec3 w = qh;
    w.xz = mat2(co,si,-si,co)*w.xz;
    
    vec2 ep = w.zy - vec2(0.5,0.4);
    float aa = atan(ep.x,ep.y);
    float al = length(ep);
    w.x += 0.003*sin( 24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));
    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.15*aa/3.1416), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));
                      
    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);
    r += 0.01*sin(15.0*w.z);
    // section        
    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    
    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    
    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    
    d4 = smax( d4, d5, 0.1 );
    d4 = smax( d4, d6, 0.1 );

    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);
    w.x += 0.05*cos(6.0*w.y);
    
    // cut it!
    d4 = smax( d4, -w.x, 0.03 ); 
    d4 = smax( d4, w.x-wi, 0.03 ); 
    
	matInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));
    
    d = smin( d, d4, 0.3*max(qh.y+0.2,0.0) ); // trick -> positional smooth
    
    // conection hear/head
    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );
    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);
    d = smin( d, d3, 0.05 );
    
#endif
    
    d -= 0.008*textureLod( iChannel1, 0.25*p.yz, 0.0 ).x;
    d -= 0.008*textureLod( iChannel1, 0.25*p.yx, 0.0 ).x;
    d += 0.010;
    d -= 0.012*textureLod( iChannel0, 0.25*p.yx, 0.0 ).x*(0.3 + 0.7*smoothstep( 0.5, 1.0, length(p-vec3(-0.5,0.0,0.0)) ));
    
    vec2 res = vec2(d,0.0);
	//=====================
    //eyeball
    mat3 rot = mat3(0.8,-0.6,0.0,
                    0.6, 0.8,0.0,
                    0.0, 0.0,1.0 );
    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );
    
    if( d4<res.x ) res = vec2( d4, 2.0 );

    res.x /= sca;
        
    return res;
}

// Function 4768
float mapSimpleTerrain( in vec3 p ) {	
	p.x += getXoffset( p.z );	
	p.x = -abs( p.x );
	vec2 res = vec2( udBox( vec3(p.x+30., p.y-1., p.z) , vec3( 20., 100.25, 99999. ) ), 1.);

#ifdef SHOW_BRIDGES
	float zcenter = mod(p.z+60.,120.)-70.;
	res = opU( res, vec2( baseBridge( vec3( p.x, p.y, zcenter) ), 8. ) ); // bridge
#endif
	
	return min( res.x, p.y+10. );
}

// Function 4769
float map2 ( vec3 v ) {
	return min(map(v),FLR);    
}

// Function 4770
void intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)
{
    float tSphere6 = intersectSphere(ro, rd, sfere[3]);
    if(tSphere6 < t && bl) { t = tSphere6;i=6;}

   	/*float tSphere = intersectSphere(ro, rd, sfere[0]);
    if(tSphere < t) { t = tSphere;i=0;}
   	tSphere = intersectSphere(ro, rd, sfere[1]);
    if(tSphere < t) { t = tSphere;i=1;}
   	tSphere = intersectSphere(ro, rd, sfere[2]);
    if(tSphere < t) { t = tSphere;i=2;}
	*/
    
    
	float tcyl = iCylinder(ro, rd, cylinder[0]);
    if(tcyl<t) {t = tcyl; i = 10;}
    tcyl = iCylinder(ro, rd, cylinder[1]);
    if(tcyl<t) {t = tcyl; i = 11;}
    tcyl = iCylinder(ro, rd, cylinder[2]);
    if(tcyl<t) {t = tcyl; i = 12;}
    tcyl = iCylinder(ro, rd, cylinder[3]);
	if(tcyl<t) {t = tcyl; i = 13;}
    
	vec2 tboxc = intersectCube(ro, rd, boxe[0]); 
    if(tboxc.x>0.0 && tboxc.x<tboxc.y && tboxc.x < t) {t = tboxc.x; i = 20;}
    vec2 tboxf = intersectCube(ro, rd, boxe[1]); 
    //if(tboxf.x>0.0 && tboxf.x<tboxf.y && tboxf.x < t) {t = tboxf.x; i = 21;}
    vec2 tbox = intersectCube(ro, rd, boxe[2]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}
    tbox = intersectCube(ro, rd, boxe[3]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}
    tbox = intersectCube(ro, rd, boxe[4]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}
    tbox = intersectCube(ro, rd, boxe[5]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 25;}    
    tbox = intersectCube(ro, rd, boxe[6]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 26;} 

    float t1 = 200000.0;
    float t2 = 200000.0;  
    if(tboxf.x>0.0 && tboxf.x<tboxf.y) {t1 = tboxf.y; t2=tboxf.x;}
    if(t1>t && t2<t && i==20) {t=t1; i=21;}

    tbox = intersectCube(ro, rd, boxe[7]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}
    tbox = intersectCube(ro, rd, boxe[8]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}
    tbox = intersectCube(ro, rd, boxe[9]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}
    tbox = intersectCube(ro, rd, boxe[10]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}
    tbox = intersectCube(ro, rd, boxe[11]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}
    tbox = intersectCube(ro, rd, boxe[12]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}
    tbox = intersectCube(ro, rd, boxe[13]); 
	if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}
    
    tbox = intersectCube(ro, rd, boxe[14]); 
    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}
}

// Function 4771
vec2 map( in vec3 pos, bool showSphere )
{
    const float rad = 0.9;

    // compute closest point to gPoint on the surace of the sphere
    vec3 closestPoint = closestPointToSphere(gPoint, vec3(0.0), rad );
    
    // point
    vec2 res = vec2( sdSphere( pos, gPoint, 0.06 ), 1.0 );
    
    // closest point
    {
    float d = sdSphere( pos, closestPoint, 0.06 );
    if( d<res.x ) res = vec2( d, 4.0 );
    }
    
    // box (semi-transparent)    
    //if( ((samp.x+samp.y)&1)==0 )
    
    if( showSphere )
    {
    float d = sdSphere( pos, vec3(0.0), rad );
    if( d<res.x ) res =  vec2( d, 5.0 );
    }

    // segment
    {
    float d = sdCapsule( pos, gPoint, closestPoint, 0.015 );
    if( d<res.x ) res =  vec2( d, 4.0 );
    }
    
    return res;
}

// Function 4772
float map(vec3 p) {
	vec3 n = vec3(0, 1, 0);
	float k1 = 1.9;
	float k2 = (sin(p.x * k1) + sin(p.z * k1)) * 0.8;
	float k3 = (sin(p.y * k1) + sin(p.z * k1)) * 0.8;
	float w1 = 4.0 - dot(abs(p), normalize(n)) + k2;
	float w2 = 4.0 - dot(abs(p), normalize(n.yzx)) + k3;
	float s1 = length(mod(p.xy + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.5), 2.0) - 1.0) - 0.2;
	float s2 = length(mod(0.5+p.yz + vec2(sin((p.z + p.x) * 2.0) * 0.3, cos((p.z + p.x) * 1.0) * 0.3), 2.0) - 1.0) - 0.2;
	return min(w1, min(w2, min(s1, s2)));
}

// Function 4773
float map(vec3 p)
{	
	p.z-=1.0;
    p*=0.9;
    pR(p.yz,bounce*1.+0.4*p.x);
    return sdBox(p+vec3(0,sin(1.6*time),0),vec3(20.0, 0.05, 1.2))-.4*noise(8.*p+3.*bounce);
}

// Function 4774
float map(vec3 p)
{
    vec3 q = p;

    pMod3(q, vec3(0.75, 1., 0.8));
    //pMod3(q, vec3(1., 0., 0.));
    
    
    pMod1(p.x, 1.);
    
    float s1 = sphere(p, 0.72); 
    float s2 = sphere(q, 0.5);
    float s3 = sphere(q, 0.7);
    
    float disp = 0.5 * (abs(cos(p.x*10.)) *
                       abs(cos(p.y*10.)) *
                       abs(cos(p.z*10.)) );
    	//s1 += disp;
    	s1 /= disp;
    	
    
    
  	float df1 = min(s1, s2); // Union
    float df2 = max(-s1, s2); // Intersection
    float df3 = max(-s1, -s3); // Difference
    
    return df3;
}

// Function 4775
vec2 mapCarbonite( vec3 p )
{
    // displacement steal
    float prec = 0.035; // displacement scale
    float disp = 1. - smoothstep(0., 1., dot(texture(iChannel1, p.xy/1.8).rgb, vec3(prec)));
    p.z += disp;
    
    // head position and orientation
    vec3 q = p - vec3(-.1,0.1,0.45);
    q *= getRotYMat(0.3) * getRotXMat(0.15);
    q.y -= 2.;
    vec2 res = mapHead(q);

    // left arm // bras
    //vec2 Larm = sdSegment(LarmS, LarmE, p);
    //res.x = smin(res.x, Larm.x-thickArm, 0.05);
    
    // left wrist // poignet
    vec2 Lwrist = sdSegment(LarmE, LwristE, p);
    res.x = smin(res.x, Lwrist.x-thickWrist, 0.05);
    
    // left hand // main
    vec2 Lhand11 = sdSegment(LwristE, LFinger11, p);
    res.x = smin(res.x, Lhand11.x-thickHand, 0.03);
    vec2 Lhand21 = sdSegment(LwristE, LFinger21, p);
    res.x = smin(res.x, Lhand21.x-thickHand, 0.03);
    vec2 Lhand31 = sdSegment(LwristE, LFinger31, p);
    res.x = smin(res.x, Lhand31.x-thickHand, 0.03);
    vec2 Lhand12 = sdSegment(LFinger11, LFinger12, p);
    res.x = smin(res.x, Lhand12.x-thickHand, 0.03);
    vec2 Lhand22 = sdSegment(LFinger21, LFinger22, p);
    res.x = smin(res.x, Lhand22.x-thickHand, 0.03);
    vec2 Lhand32 = sdSegment(LFinger31, LFinger32, p);
    res.x = smin(res.x, Lhand32.x-thickHand, 0.03);
    
    // left knee // genou
    vec2 Lknee = sdSegment(LkneeS, LkneeE, p);
    res.x = smin(res.x, Lknee.x-thickKnee, 0.08);
    
    // left leg // molet
    vec2 Lleg = sdSegment(LkneeE, LlegE, p);
    res.x = smin(res.x, Lleg.x-thickLeg, 0.05);
    
    // left foot // pied
    vec2 LFoot1 = sdSegment(LlegE, LFootE1, p);
    res.x = smin(res.x, LFoot1.x-thickFoot, 0.05);
    vec2 LFoot2 = sdSegment(LlegE, LFootE2, p);
    res.x = smin(res.x, LFoot2.x-thickFoot, 0.05);
    vec2 LFoot3 = sdSegment(LlegE, LFootE3, p);
    res.x = smin(res.x, LFoot3.x-thickFoot, 0.05);
    
    // right arm // bras
    //vec2 Rarm = sdSegment(RarmS, RarmE, p);
    //res.x = smin(res.x, Rarm.x-thickArm, 0.05);
    
    // right hand // main
    vec2 Rhand11 = sdSegment(RwristE, RFinger11, p);
    res.x = smin(res.x, Rhand11.x-thickHand, 0.03);
    vec2 Rhand21 = sdSegment(RwristE, RFinger21, p);
    res.x = smin(res.x, Rhand21.x-thickHand, 0.03);
    vec2 Rhand31 = sdSegment(RwristE, RFinger31, p);
    res.x = smin(res.x, Rhand31.x-thickHand, 0.03);
    vec2 Rhand12 = sdSegment(RFinger11, RFinger12, p);
    res.x = smin(res.x, Rhand12.x-thickHand, 0.03);
    vec2 Rhand22 = sdSegment(RFinger21, RFinger22, p);
    res.x = smin(res.x, Rhand22.x-thickHand, 0.03);
    vec2 Rhand32 = sdSegment(RFinger31, RFinger32, p);
    res.x = smin(res.x, Rhand32.x-thickHand, 0.03);
        
    // right wrist // poignet
    vec2 Rwrist = sdSegment(RarmE, RwristE, p);
    res.x = smin(res.x, Rwrist.x-thickWrist, 0.05);
    
    // right knee // genou
    vec2 Rknee = sdSegment(RkneeS, RkneeE, p);
    res.x = smin(res.x, Rknee.x-thickKnee, 0.05);
    
    // right leg // molet
    vec2 Rleg = sdSegment(RkneeE, RlegE, p);
    res.x = smin(res.x, Rleg.x-thickLeg, 0.05);
    
    // right foot // pied
    
    // carbonite box
    float box = udBox(p-vec3(0.,0.,-0.13), vec3(1.5,4.,0.65));
   	res.x = smin(res.x, box, 0.05);
    
    return res;
}

// Function 4776
float DebugSDFPattern(float d, float offset, float aa)
{
    d = fract(d);
    return smoothstep(offset, offset + aa, d) * smoothstep(1.0 - offset, 1.0 - offset - aa, d);
}

// Function 4777
float SDF(vec3 p){
	float to_return = SDF1(p);
    for(int i = 1; i <5;i++){
        p += p.yzx/float(i);
    	to_return = min(to_return,SDF1(p));
    }
    return to_return/float(scale);
}

// Function 4778
void initScene() {
    float time = 100.0;//iTime;
    
    //create lights
    createLight(vec3(1.0, 1.0, 0.9), 40.0, lights[0]);
    
    //Create materials
    createMaterial(vec3(0.6, 1.0, 0.6), -1, vec3(0.5, 1.0, 0.5), 0.15, -1, 0.6, -1, -1, 1.0, materials[0]);
    createMaterial(vec3(1.0, 1.0, 1.0), 0, vec3(1.0, 1.0, 1.0), 0.0, 0, 0.2, -1, 0, 2.0, materials[1]);
    createMaterial(vec3(0.3, 0.5, 1.0), 1, vec3(1.0, 1.0, 1.0), 0.0, 1, 0.4, 1, 1, 1.0, materials[2]);
    createMaterial(vec3(0.5, 0.5, 0.5), -1, vec3(0.9, 0.9, 1.0), 0.03, -1, 1.0, -1, -1, 1.0, materials[3]);
    createMaterial(vec3(1.0, 1.0, 1.0), 2, vec3(1.0, 1.0, 1.0), 0.0, 2, 0.4, 2, 2, 1.0, materials[4]);
    
    //init lights
    float r = 1.0;
    float xFactor = (iMouse.x==0.0)?0.0:2.0*(iMouse.x/iResolution.x) - 1.0;
    float yFactor = (iMouse.y==0.0)?0.0:2.0*(iMouse.y/iResolution.y) - 1.0;
    float x = xFactor*7.0;
    float z = -3.0-yFactor*5.0;
    float a = -1.2+sin(time*0.23);
    mat4 trans = createCS(	vec3(x, 5.0+sin(time), z),
                          	vec3(0.0, sin(a), cos(a)),
                  			vec3(1.0, 0.0, 0.0));
#ifdef SPHERE_LIGHT
    createSphere(trans, r, LIGHT_ID_BASE+0, objects[0] );
#else
    createPlane(trans, -2.0, -1.0, 2.0, 1.0, LIGHT_ID_BASE+0, objects[0]);
#endif
    
    
    //plane 1
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 5.0, -10.0, 1.0 ));
    createPlane(trans, -10.0, -2.0, 10.0, 4.0, SURFACE_ID_BASE+1, objects[1]);
   
    //plane 2
    trans = mat4(	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, -1.0, 0.0 ),
                    vec4( 0.0, -1.0, 0.0, 0.0 ),
                    vec4( 0.0, -1.0, -4.0, 1.0 ));
    createPlane(trans, -10.0, -4.0, 10.0, 2.0, SURFACE_ID_BASE+1, objects[2]);
 
    //Cylinder
    trans = mat4(	vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( -0.0, 3.0, -6.0, 1.0 ));
    createCylinder(trans, 4.0, -10.0, 10.0, PI/2.0, SURFACE_ID_BASE+1, objects[3] );
    
    //sphere 1
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 1.5, -0.3, -2.0, 1.0 ));

    createSphere(trans, 0.7, SURFACE_ID_BASE+2, objects[4] );
    
    //sphere 2
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 0.0, 0.0, -4.5, 1.0 ));

    createSphere(trans, 1.0, SURFACE_ID_BASE+3, objects[5] );
    
    //box
    trans = createCS(	vec3(-1.5, -1.0, -3.0),
                     	vec3(0.0, 1.0, 0.0),
                     	vec3(0.2, 0.0, -0.7));
    createAABB( trans, -vec3(0.5, 0.5, 0.0), vec3(0.5, 0.5, 2.5), SURFACE_ID_BASE+0, objects[6]);
    
    trans = mat4( 	vec4( 1.0, 0.0, 0.0, 0.0 ),
                    vec4( 0.0, 1.0, 0.0, 0.0 ),
                    vec4( 0.0, 0.0, 1.0, 0.0 ),
                    vec4( 3.5, 0.5, -4.2, 1.0 ));

    createSphere(trans, 1.5, SURFACE_ID_BASE+4, objects[7] );
    /*
    //torus
    trans = createCS(	vec3(3.0, 1.0, -4.0),
                        vec3(-0.5, 0.0, 0.5),
                  	    vec3(1.0, 0.0, 0.0));
    createTorus(trans, 1.5, 0.3, SURFACE_ID_BASE+4, objects[7]);*/
}

// Function 4779
float boxSDF( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// Function 4780
float sdf(vec3 p)
{
	//floor!
	float f = p.y-floor_height;
	vec2 D = vec2(f);

	//bricks
	//vec2 D = BrickSDFY(p) );
 	D = UY(D,BrickSDFY(p) ); 
	D = UY(D,RedBrickSDFY(p));
#ifdef BUILD_UP_AND_DOWN	
	//build up and down
	float t = mod(iTime,20.);
	t = t > 10. ? 20.-t : t;
	t *= 2.;
	t = floor(t);
	float bh = 1.+2.*floor(t);
	D.x = ClipY(D.x,p,bh-0.08);
	D.y = ClipY(D.y,p,bh);
#endif	
	return AddStuds(D,p);
}

// Function 4781
float dist(float s, float d)
{
	return clamp(s * d, -1.0, 1.0);
}

// Function 4782
vec2 map( in vec3 p )
{
	// white keys
    vec2 res = vec2( obj1( p ), 0.0 );

	// black keys
    vec2 ob2 = vec2( obj2( p, res.x ), 1.0 );
	if( ob2.x<res.x ) res=ob2;

    // piano body
    vec2 ob3 = vec2( obj3( p ), 2.0 );
    if( ob3.x<res.x ) res=ob3;

    // floor
    vec2 ob4 = vec2( obj4( p ), 3.0 );
    if( ob4.x<res.x ) res=ob4;

    // wall
    vec2 ob5 = vec2( obj5( p ), 4.0 );
    if( ob5.x<res.x ) res=ob5;

	// paper
    vec2 ob6 = vec2( obj6( p ), 5.0 );
    if( ob6.x<res.x ) res=ob6;
	
	// pedals
    vec2 ob7 = vec2( obj7( p ), 6.0 );
    if( ob7.x<res.x ) res=ob7;

	// bench
    vec2 ob8 = vec2( obj8( p ), 7.0 );
    if( ob8.x<res.x ) res=ob8;

	return res;
}

// Function 4783
vec3 scene_object_lighting( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,
                            vec3 skyZ, vec3 skyL, vec3 skyR, vec3 ground )
{
    float mu_0 = mu_stretch( dot( N, L ), .01 );
    float mu = mu_stretch( dot( N, V ), .01 );
    float cosi = dot( N, Z );
    float cosp = dot( L, V );
    float cost = dot( normalize( reject( N, Z ) ), normalize( reject( L, Z ) ) );
    vec3 kd = lunar_lambert( albedo, mu, mu_0 );
    float kl = phase_curve( cosp );
    vec3 E = F * mu_0;
    //*
    vec3 sky = mix( mix( skyR, skyL, .5 + .5 * cost ), skyZ, cosi * .3333 + .6667 );
    return E * kd * kl + albedo * mix( ground, sky, cosi * .5 + .5 );
    /*/
    float cosi2 = cosi * cosi;
    vec3 skyH = ( skyL + skyR ) / 2.;
    vec3 skyJ = ( skyL - skyR ) / 2.;
    vec3 sky = skyZ / 8. * ( 2.6667 + cosi * ( 3.5 + cosi2 * ( -0.3333 + cosi2 * ( -0.5 + cosi2 ) ) ) ) +
               skyH / 8. * ( 1.3333 + cosi * ( 0.5 + cosi2 * ( +0.3333 + cosi2 * ( +0.5 + cosi2 ) ) ) ) +
               skyJ * cost / ( 105. * PI ) * ( 30. - cosi2 * ( 6. + cosi2 * ( 8. + cosi2 * 16. ) ) );
    return E * kd * kl + albedo * ( sky + ground * ( 1. - cosi ) / 2. );
    //*/
}

// Function 4784
float GetSDFValue(vec2 uv)
{
    vec2 msdfUnit = pxRange/vec2(textureSize(iChannel0, 0));
    vec3 texel = texture(iChannel0, uv).rgb;
    float sigDist = median(texel.r, texel.g, texel.b) - 0.5;
    sigDist *= dot(msdfUnit, 0.5/fwidth(uv));
    return clamp(sigDist + 0.5, 0.0, 1.0);
}

// Function 4785
float map(in vec3 p)
{
	orbitTrap = vec4(10.0);
	d = sdPlane(p);

	if (efx == 0) {			// balls and cube
	m = Balls(p); 
	}
	if (efx == 1) {			// milky menger
	m = NewMenger(rotYaxis(rotXaxis(p-vec3(0.0,sin(iTime/0.63)+0.2,0.0),0.15*iTime),0.24*iTime));
	}
	if (efx == 2) {			// mandelbulb
	m = Mandelbulb(rotYaxis(rotXaxis(p,iTime*0.1),0.21*iTime));
	}
	if (efx == 3) {			// kalibox
	m = Kalibox(rotYaxis(rotXaxis(p,1.50),0.1*iTime));
	}
	if (efx == 4 || efx == 5) { // tunnel or swirl
	vec3 c = vec3(2.0, 8.0, 2.0);
	vec3 q = mod(p-vec3(1.0,0.1*iTime,1.0),c)-0.5*c;
	float kali = Kalibox(rotYaxis(q,0.04*iTime));
	m = max(kali,-sdCylinder(p,vec3(0.0,0.0,0.30+0.1*sin(iTime*0.2))) );
	}
	d = sminPoly (m, d, 0.04); 
   	return d;
}

// Function 4786
float SphereSDF(vec3 p,float r)
{
    return length(p) - r;
}

// Function 4787
vec3 TriplanarTextureMapping(const vec3 p, const vec3 n, const int texID)
{
    mat3 samples;
    
    switch(texID)
    {
        // iChannel0 is for the SkyBox
        case 1:
        	samples = mat3 (texture(iChannel1, p.yz).rgb,
                         	texture(iChannel1, p.xz).rgb,
                         	texture(iChannel1, p.xy).rgb );
        	break;
        case 2:
        	samples = mat3 (texture(iChannel2, p.yz).rgb,
                         	texture(iChannel2, p.xz).rgb,
                         	texture(iChannel2, p.xy).rgb );
        	break;
        case 3:
        	samples = mat3 (texture(iChannel3, p.yz).rgb,
                         	texture(iChannel3, p.xz).rgb,
                         	texture(iChannel3, p.xy).rgb );
        	break;
        default:
        	samples = mat3(0);
        	break;
    }
    
    // Weight the samples with the normal to get the one more aligned
    return samples * abs(n);
}

// Function 4788
vec2 map(vec3 q3){
    vec2 res = vec2(100.,0.);

    float k = 5.0/dot(q3,q3); 
    q3 *= k;

    q3.z += speed;

    vec3 qm = q3;
    vec3 qd = q3+hlf;
    qd.xz*=t90;
    vec3 qid=drep(qm);
    vec3 did=drep(qd);
    
    float ht = hash21(qid.xy+qid.z);
    float hy = hash21(did.xz+did.y);
    
    float chk1 = mod(qid.y + qid.x,2.) * 2. - 1.;
    float chk2 = mod(did.y + did.x,2.) * 2. - 1.;

    // truchet build parts
    float thx = .115;
    float thz = .200;

    if(ht>.5) qm.x *= -1.;
    if(hy>.5) qd.x *= -1.;

    float t = truchet(qm,vec3(hlf,hlf,.0),vec2(hlf,thx));
    if(t<res.x) {
        sid = qid;
        hit = qm;
        chx = chk1;
        sdir = ht>.5 ? -1. : 1.;
        res = vec2(t,2.);
    }

    float d = truchet(qd,vec3(hlf,hlf,.0),vec2(hlf,thz));
    if(d<res.x) {

        sid = did;
        hit = qd;
        chx = chk2;
        sdir = hy>.5 ? -1. : 1.;
        res = vec2(d,1.);
    }

    float mul = 1.0/k;
    res.x = res.x * mul / shorten;
    
    return res;
}

// Function 4789
float distanceMetric(vec2 pos, uint metric)
{
    switch (metric)
    {
        case 0u:
            // squared euclidean
            return dot(pos, pos);
        case 1u:
            // manhattam   
            return dot(abs(pos), vec2(1.0));
        case 2u:
            // chebyshev
            return max(abs(pos.x), abs(pos.y));
        default:
            // triangular
            return  max(abs(pos.x) * 0.866025 + pos.y * 0.5, -pos.y);
    }
}

// Function 4790
float fogmap(in vec3 p, in float d)
{
    vec3 q = p;
    q.z-=0.0;
    p.x -= iTime*0.05;
    vec3 turb = vec3(noise(80.0*p.xyz+iTime*0.51)*0.5, noise(160.0*p.xzy+iTime*0.2)*0.3, noise(60.0*p.zyx+iTime*0.1)*0.2);
    p += turb;
    float fog = (max(noise(p*64.0+0.1)-0.1, 0.0)*noise(p*16.0))*0.03;
    
    return fog;
}

// Function 4791
vec3 scene_lighting_ocean( vec3 albedo, vec3 Z, vec3 N, vec3 M, vec3 L, vec3 V, vec3 F,
                           float a, vec3 sky,
                           vec4 refl, float extra_T )
{
#if WITH_ILLUM_TEST
    float mu0 = max( 0., dot( N, L ) );
    return F * mu0 + refl.xyz;
#else
    // variation of the KSK microfacet model
    vec3 L_refract = normalize( -simple_refract( -L, Z ) );
    float mu0_refract = max( 0., dot( N, L_refract ) ) * max( 0., dot( L, Z ) );
    float mu0 = max( 0., dot( M, L ) );
    float mu = max( 0., dot( M, V ) );
    vec3 H = normalize( L + V );
    float cosxi = max( 0., dot( M, H ) );
    float cospsi = max( .0625, dot( L, H ) );
    float fr_mu = refl.w;
    float fr_psi = fresnel_schlick( .02, cospsi );
    float kd = ( 1. - fr_mu );
    float ks = extra_T * NDFdisk( cosxi, a, .5 * square( 7487. / 321226. ) ) / ( 4. * cospsi * cospsi );
    return F * mix( mu0_refract * albedo * kd, mu0 * vec3( ks ), fr_psi ) +
        albedo * sky * ( 1. - fr_mu ) + refl.xyz;
#endif
}

// Function 4792
float map_flame(vec3 pos)
{
    #ifdef show_candle
    #ifdef show_flame
    if (!traceFlame)
        return 10.;
    pos = rotateVec2(pos);
    pos+= vec3(-0.01, 0.1 + burnPos, -0.035);
    pos*= 0.75 + 5.*smoothstep(0.44, 0.47, burningSpeed*iTime);
    vec3 fm = getFlameMovement(pos);
    vec3 pos2 = pos - fm; 
    
    float is = length(pos2*vec3(1., 0.5, 1.) + vec3(0., 0.04, 0.)) - 0.04;
    pos2.xz*= 1. + pos2.y*1.7;
    pos2.y/= 0.6 + 1.8/pow(abs(pos2.y), 0.2 + 1.3*pos2.y);
    
    float df = length(pos2) - 0.07;
    df = max(df, -is);

    #ifdef dev_mode
    df = max(df, -pos.x);
    #endif
    return df;
    #else
    return 10.;
    #endif
    #else
    return 10.;
    #endif
}

// Function 4793
float sdfSphere(in vec3 pos, in float radius) {
	return length(pos) - radius;   
}

// Function 4794
float cDistance( in vec2 v )
{
    float d0 = sdLine2( v, p0, p1 );
    float d1 = sdLine2( v, p1, p2 );
    float d2 = sdLine2( v, p2, p3 );
    float d3 = sdLine2( v, p3, p4 );
    float d4 = sdLine2( v, p4, p5 );
    float d5 = sdLine2( v, p5, p6 );
    float d6 = sdLine2( v, p6, p7 );
    float d7 = sdLine2( v, p7, p0 );
    return sqrt( min(d0,min(d1,min(d2,min(d3,min(d4,min(d5,min(d6,d7))))))) );
}

// Function 4795
SurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )
{
    SurfaceInfo surfaceInfo;
    
    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);
    
    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); 
    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;
    surfaceInfo.vAlbedo = vec3(1.0);
    surfaceInfo.vR0 = vec3( 0.02 );
    surfaceInfo.fGloss = 1.0;
    surfaceInfo.vEmissive = vec3( 0.0 );
        
    if ( traceResult.iObjectId == MAT_DEFAULT )
    {
        surfaceInfo.vAlbedo = vec3(0.75, 0.75, 0.75); 
	    surfaceInfo.fGloss = 0.01;
    	surfaceInfo.vR0 = vec3( 0.02 );
    }

    if ( traceResult.iObjectId == MAT_PARTITION )
    {
        surfaceInfo.vAlbedo = textureLod(iChannel1, traceResult.vUVW.xy, 0.0 ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        surfaceInfo.vAlbedo *= 0.15; 
        surfaceInfo.vAlbedo += 0.1;
        
	    surfaceInfo.fGloss = 0.01;
    	surfaceInfo.vR0 = vec3( 0.02 );
    }

    if ( traceResult.iObjectId == MAT_LAMP )
    {
        surfaceInfo.vAlbedo = vec3( 0.1 ); 
	    surfaceInfo.fGloss = 0.8;
    	surfaceInfo.vR0 = vec3( 0.02 );        
    }           

    if ( traceResult.iObjectId == MAT_LAMP_INNER )
    {
        surfaceInfo.vAlbedo = vec3( 0.01 ); 
	    surfaceInfo.fGloss = 0.8;
    	surfaceInfo.vR0 = vec3( 0.5 );        
    }     
    
    if ( traceResult.iObjectId == MAT_LAMP_BULB )
    {
        surfaceInfo.vAlbedo = vec3( 0.1 );
	    surfaceInfo.fGloss = 0.8;
    	surfaceInfo.vR0 = vec3( 0.02 );
        surfaceInfo.vEmissive = traceResult.vUVW * 4.0; 
    }           

    if ( traceResult.iObjectId == MAT_LAMP_CASE )
    {
        surfaceInfo.vAlbedo = vec3( traceResult.vUVW ); 
	    surfaceInfo.fGloss = 0.8;
    	surfaceInfo.vR0 = vec3( 0.02 );        
    }    
    
    if ( traceResult.iObjectId == MAT_DIAL )
    {
        surfaceInfo.vAlbedo = vec3( traceResult.vUVW );
	    surfaceInfo.fGloss = 0.8;
    	surfaceInfo.vR0 = vec3( 0.02 );
    }           
   
    if ( traceResult.iObjectId == MAT_DIAL_CHROME )
    {
        surfaceInfo.vAlbedo = vec3( 0.7 );
	    surfaceInfo.fGloss = 0.9;
    	surfaceInfo.vR0 = vec3( 0.1 );
    }     
    
    if ( traceResult.iObjectId == MAT_FLOOR )
    {
        surfaceInfo.vAlbedo = textureLod(iChannel1, traceResult.vUVW.xz, 0.0 ).rgb;
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;
        
        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * 0.5 + 0.5;
	    surfaceInfo.fGloss = 0.9;
    	surfaceInfo.vR0 = vec3( 0.02 );
    }
    
    if ( traceResult.iObjectId == MAT_PANEL )
    {
        surfaceInfo.vAlbedo = vec3(0.3, 0.4, 0.45); 
	    surfaceInfo.fGloss = 0.9;
    	surfaceInfo.vR0 = vec3( 0.04 );
    }
    
    
        
    return surfaceInfo;
}

// Function 4796
float remap(float l, float h, float x){return clamp((x-l) / (h-l), 0.0, 1.0);}

// Function 4797
vec4 traceScene(in Camera cam, vec2 seed, float lastB) {
    vec3 startPos = cam.pos;
    
    vec4 result = vec4(0);
    
    int maxI = int(float(MAXRAYS) * lastB);
    for (int i=0; i<MAXRAYS; i++) {
        if (i==maxI) break;
    	Ray r = cam.ray;
        
        r.dir.x += (nrand(seed)*2.-1.) * divergence;
        r.dir.y += (nrand(seed.yx)*2.-1.) * divergence;
        r.dir.z += (nrand(seed.xx)*2.-1.) * divergence;
        r.dir = normalize(r.dir);
        vec4 impact = vec4(BRIGHTNESS);
        seed++;
        
        //float maxJF = float(MAXBOUNCES) * lastB;
        int maxJ = int(float(MAXBOUNCES) * lastB);
        for (int j=0; j<MAXBOUNCES; j++) {
           //	if (j==maxJ) break;
    		HitTest t0 = intersectBox(r, Box(vec3(-5,10,-5), vec3(30,20,25)));
    		HitTest t1 = intersectSphere(r, Sphere(vec3(-1,2,0), 2.0));
            t1.col = vec4(0.5, 0.6, 0.9, 0.0);
    		HitTest t2 = intersectSphere(r, Sphere(vec3(4,5,4), 5.0));
            t2.col = vec4(0.9,0.9,0,0);
            t2.ref = 0.8;
    		HitTest t3 = intersectSphere(r, Sphere(vec3(-5,4,4), 4.0));
            t3.col = vec4(0.3,0.9,0.6,sin(t * 0.6)*3.0);
            t3.ref = 0.0;
    		HitTest t4 = intersectSphere(r, Sphere(vec3(4,2.5,-2), 2.5));
            t4.col = vec4(1,0.5,0.2,sin(t * 0.7)*3.);
            t4.ref = 0.0;
    		
    		HitTest test = minT(t0, t1, t2, t3, t4);
    	
    		if (test.hit) {
        		impact *= test.col;
                if (test.col.a > 0.0) { 
        	    	result += test.col * impact * test.col.a;
        	    	//break;
        		}
                
        	    r.origin += r.dir * test.dist;
                r.origin += test.normal * 0.01;
                
                vec3 random = vec3(
        		            nrand(r.origin.xy+seed),
        		            nrand(r.origin.yz+seed),
        		            nrand(r.origin.zx+seed)
        		            )*2. - 1.;
                
                if (test != t0 && test != t2) {
                    vec3 refl = reflect(r.dir, test.normal);
                    vec3 matte = normalize(test.normal + random);
                    
                    float s = max(0.0, -dot(test.normal, r.dir));
        			s = step(pow(s, 0.5), nrand(seed));
                    r.dir = refl * s + matte * (1.-s);
                } else {
                
                	r.dir = normalize(mix(
                   	 	test.normal + random,
                    	reflect(r.dir, test.normal),
                    	test.ref
                    ));
                }
            } else {
                break;
            }
        }
    }
    return result / float(MAXRAYS);
}

// Function 4798
float remap(float a, float b, float c, float d, float t) {
    return ((t-a)/(b-a)) * (d-c) + b;
}

// Function 4799
float scene(vec3 p) {
    //sdf is undefined outside the unit sphere, uncomment to witness the abominations
    if (length(p) > 1.) {
        return length(p)-.8;
    }
    vec4 f0_0=sin(p.y*vec4(-2.80,-2.31,.26,-2.53)+p.z*vec4(.26,-1.03,1.17,.23)+p.x*vec4(-1.95,4.96,-2.87,1.54)+vec4(-4.29,-.00,5.61,.86));
vec4 f0_1=sin(p.y*vec4(1.01,-.08,-3.52,1.54)+p.z*vec4(1.46,5.40,-1.15,-1.06)+p.x*vec4(-.20,-.83,-3.83,3.54)+vec4(6.65,-5.90,5.95,1.87));
vec4 f0_2=sin(p.y*vec4(1.98,3.74,2.36,-.30)+p.z*vec4(3.43,-1.41,-1.83,-2.14)+p.x*vec4(1.26,2.06,4.76,-1.32)+vec4(.57,-6.02,-1.16,-1.88));
vec4 f0_3=sin(p.y*vec4(-2.08,-3.32,-3.79,2.97)+p.z*vec4(-.67,-4.30,4.51,-1.44)+p.x*vec4(1.83,-.32,1.52,.87)+vec4(-1.11,-6.22,5.26,3.87));
vec4 f1_0=sin(mat4(.47,.24,-.26,.24,.07,.01,-.02,-.32,.59,-.77,.45,.10,.31,.74,-.41,.31)*f0_0+
    mat4(.03,.09,-.40,-.38,-.42,.56,.05,.05,-.18,.15,.47,.57,-.77,.09,.62,-.44)*f0_1+
    mat4(-.28,-.04,.46,-.25,.04,-.74,-.05,.00,-.33,-.50,-.37,-.15,-.08,.25,-.36,1.19)*f0_2+
    mat4(.11,-.35,.17,-.23,.52,-.14,-.14,-.29,.04,-.15,.53,.08,.91,.13,-.27,.01)*f0_3+
    vec4(2.84,.27,.66,2.51))/1.0+f0_0;
vec4 f1_1=sin(mat4(.75,-.12,-.35,.10,-.50,-.08,-.41,.14,-.13,.01,-.78,-.12,-.07,.97,-.31,-.42)*f0_0+
    mat4(-.80,-.78,-.87,.05,.48,-.28,-.33,.01,-.01,-.28,.40,-.38,-.63,.60,-.58,1.00)*f0_1+
    mat4(-.47,.15,-.34,.37,-1.15,-.34,-.55,.17,-.47,.08,-.53,.36,.52,-.41,.24,-.05)*f0_2+
    mat4(-.17,.04,1.11,.02,.62,-.33,.01,.32,1.09,.05,.02,.02,-.42,-.44,.01,-.52)*f0_3+
    vec4(1.55,2.24,.75,-.89))/1.0+f0_1;
vec4 f1_2=sin(mat4(.12,-.41,-.01,-.62,-.14,.14,-.03,-.01,.82,-.44,.67,.13,-.18,-.41,-.06,.61)*f0_0+
    mat4(-.39,-.58,-.31,.38,-.30,-.63,-.29,-.02,-.22,-.17,.36,.60,.63,-.07,-.12,-.33)*f0_1+
    mat4(-.81,.33,-.22,-.41,-.11,.04,.32,-.09,-.15,-.04,.18,-.02,-1.03,.15,.09,.21)*f0_2+
    mat4(-1.29,-.37,-.34,-.21,-.44,.57,.22,-.04,-.17,-.45,-.11,.09,.01,-.10,.37,.34)*f0_3+
    vec4(-2.45,-2.02,-1.93,3.64))/1.0+f0_2;
vec4 f1_3=sin(mat4(.09,.16,.42,.42,-.30,-.04,.34,-.01,.05,.04,-.47,-.17,.10,-.73,-.57,.25)*f0_0+
    mat4(-.29,-.60,-.74,-.12,-.20,-.69,-.03,-.08,.12,-.00,.15,.19,-.01,-.14,1.17,-.76)*f0_1+
    mat4(.48,-.28,-.13,.05,-.31,-.37,-.53,.02,-.47,-.16,.49,-.51,-.29,-.53,-.76,-.40)*f0_2+
    mat4(-.44,-.05,-1.13,.28,-.09,.06,.01,.05,.01,.05,.43,-.47,-.28,.11,.12,.22)*f0_3+
    vec4(2.78,-1.21,3.27,-.87))/1.0+f0_3;
vec4 f2_0=sin(mat4(-.47,-.93,-.13,-.16,-.56,.06,.15,-.02,-.44,.29,.44,-.20,-.44,.32,.34,-.42)*f1_0+
    mat4(.02,.30,.48,-.40,-.03,.87,.24,.26,.25,.89,-.51,-.33,-.05,-.21,.04,.26)*f1_1+
    mat4(-.24,.17,-.36,.20,.93,.39,-.24,-.56,-.47,-.35,.36,.07,-.21,.24,.25,-.44)*f1_2+
    mat4(-.26,.24,.32,-.15,.53,-.21,1.01,-.12,-.39,.25,.60,.28,.96,-.47,-.17,-.93)*f1_3+
    vec4(-2.52,-1.31,1.30,-.88))/1.4+f1_0;
vec4 f2_1=sin(mat4(-.74,.26,.76,-.23,-.02,-.62,-.26,-.47,-.04,-.04,-.08,-.09,-.53,-.24,-.16,-.77)*f1_0+
    mat4(.82,-.04,-.18,.39,.39,-.16,.17,-.25,-1.06,-.74,-.14,-.23,-.30,-.26,-.34,.08)*f1_1+
    mat4(1.07,.17,.96,-.04,-.63,.86,-.52,.03,-.96,-.46,-.69,-.30,-.77,-.32,.52,-.25)*f1_2+
    mat4(.29,.04,.04,-.20,-.38,.56,-.20,-.79,.02,-.71,.10,-.78,-.47,1.40,.42,-.96)*f1_3+
    vec4(.83,-1.77,-1.56,3.58))/1.4+f1_1;
vec4 f2_2=sin(mat4(.46,.25,-.46,-.07,.31,-.43,-.03,.48,.20,-.40,.03,-.02,.46,-.47,.07,-.42)*f1_0+
    mat4(.04,-.27,.36,.45,.50,-.06,.51,.44,-.36,.72,.21,-.09,.64,.13,-.46,.81)*f1_1+
    mat4(-1.09,.14,.45,-.06,-.16,-.01,-.58,-.44,.53,-.30,-.20,.59,-.99,.17,-.06,-.88)*f1_2+
    mat4(.13,.20,.60,-.39,.29,-.02,-.42,-.46,.09,.06,.15,.20,-.24,-.06,-.22,-.23)*f1_3+
    vec4(-3.89,-2.54,3.60,2.42))/1.4+f1_2;
vec4 f2_3=sin(mat4(.31,.97,-.73,-.10,.49,.23,-.34,-.35,-.04,-.74,.21,.26,-.08,.56,.44,-.47)*f1_0+
    mat4(-.13,-.20,.37,.13,-.35,-.26,.32,.17,.06,.35,.42,-.53,.39,-.23,-1.23,-.12)*f1_1+
    mat4(-1.00,.09,-.46,-.04,.40,.47,-.29,.08,.63,.20,-.56,-.07,.55,.02,.73,-.23)*f1_2+
    mat4(-.38,-.28,.36,.42,.38,.41,-.38,.36,-.13,.16,-.07,-.45,.22,.82,-.33,.49)*f1_3+
    vec4(-.80,.50,3.67,-2.49))/1.4+f1_3;
return dot(f2_0,vec4(-.06,.03,-.03,-.08))+
    dot(f2_1,vec4(-.03,.06,-.04,-.05))+
    dot(f2_2,vec4(.03,-.06,-.10,.05))+
    dot(f2_3,vec4(.08,-.06,.04,-.08))+
    0.137;
}

// Function 4800
vec4 scene(vec3 ro, vec3 rd) {
	float t=0.0,d=0.0;
	for(int i=0;i<48;i++){
		t+=d=DE(ro+rd*t);
		if(t>10.0 || d<0.01)break;
	}
	float lt=pow(dot(rd,normalize(-ro)),10.0);
	float t2=0.2*rand(gl_FragCoord.xy);
	vec3 sum=vec3(0.0);
	for(int i=0;i<48;i++){
		t2+=0.2+t2*t2*0.01;
		//if((t2>t && d<0.2) || t2>100.0)break;
        if(t2>t && d<0.2)break;
        //t2=min(t2,10.0);
        if(t2>9.0)t2-=0.75+0.25*sin(float(i*2));
		vec3 vr=normalize(ro+rd*t2);
		if(vr==vr)sum+=(vr*0.5+0.5)*volLiteMask(vr)*(0.1+0.2*sinNoise3d((ro+rd*t2)));
	}
	vec3 col=clamp(lt*sum,0.0,1.0);
	return vec4(col,t);
}

// Function 4801
vec2 distID(vec3 p)
{
	vec2 r = u( vec2(pillars(p), ID_PILLAR), vec2(rafters(p), ID_RAFTER) );
	r = u( r, vec2(garage(p), ID_GARAGE) );
    r = u( r, vec2(bollards(p), ID_BOLLARDS) );
    r = u( r, vec2(lights(p), ID_LIGHTS) );
    r = u( r, vec2(pipes(p), ID_PIPES) );
    r = u( r, vec2(wires(p), ID_WIRES));
	return r;
}

// Function 4802
vec4 Scene_Pillar( vec3 vPos )
{
    float fPillarRadius = 1.0 - cos( vPos.y * 2.0 );
    fPillarRadius = 0.4 + fPillarRadius * fPillarRadius * 0.5;
    vec2 vPillarOffset = vPos.xz - vec2(0.0, 3.0);
    float fPillarDist = length( vPillarOffset ) - fPillarRadius;
    vec2 vPillarUV = vec2( vPos.y * 4.0, 2.5 * atan( vPillarOffset.y, vPillarOffset.x ) );
    vec4 vPillarResult = vec4( fPillarDist, vPillarUV, 1.0 );
    
    return vPillarResult;
}

// Function 4803
float DistributionGGX(vec3 N, vec3 H, float roughness){
    float a = roughness*roughness;
    float a2 = a*a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;

    float nom   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}

// Function 4804
float distFunc(in vec3 p)
{
    float d = distPlane(p, plane);
    vec4 tex = texture(iChannel0, mod(p.xz * 0.2, 1.0));
    tex *= heightFactor;
	return d - tex.x;
}

// Function 4805
float lnsegDist2(vec2 uv, vec2 p, vec2 d)
{
    vec2 q = uv - p;
    float lp = dot(q, d) / dot(d, d);
    lp = clamp(lp, 0.0, 1.0);
    q -= lp * d;
    return dot(q, q);
}

// Function 4806
float map(vec3 p)
{
    float d1 = sdSphere(p, vec3(-1, sin(iTime)*-1., 0), 1.0);
    float d2 = sdBox(p, vec3(0.5));
    return smin(d1, d2, .4);
}

// Function 4807
float distanceFromSegment(vec2 U, vec2 A, vec2 B) 
{
	vec2 UA = U - A;
    vec2 BA = (B - A);
    
    float s = dot(UA, BA) / length(BA);   // scalar projection of U-A on B-A
    s = s / length(BA); 				  // normalize the projection value in the range [0,1], 
    								      //  a value of 0 means the projection correspond to A, 1 to B,
    									  //  in between the projection is inside the segment, 
                                          //  outside [0,1] the projection is outside the segment.
    s = clamp(s, 0., 1.);                 // If the scalar projection is outside [0,1], its value is clamped to 
                                          //  0 or 1 ...
   	
    return length(UA - s*BA);          	  // ... so here we compute the distance of U from its projection if it is
                                          // inside the segment, or from the extreme points A or B if it is outside
}

// Function 4808
float traceSceneRay(vec3 ro, vec3 rd, out vec3 normal, out vec4 color) {
  const vec3 up = vec3(0.0, 1.0, 0.0);

  float minT = 1e10;
  color = vec4(1.0, 1.0, 1.0, 0.0);

  for (int i = 0; i < sceneSpheres.length(); i++) {
    Sphere sphere = sceneSpheres[i];
    vec3 p = sphere.position;
    float r2 = sphere.radius * sphere.radius;
    float t = intersectRaySphere(ro, rd, p, r2);
    if (t > 0.0 && t < minT) {
      normal = (ro + rd * t) - p;
      color = sphere.color;
      minT = t;
    }
  }

  for (int i = 0; i < sceneTris.length(); i++) {
    Tri tri = sceneTris[i];
    float t = intersectRayTri(ro, rd, tri.v0, tri.v1, tri.v2);
    if (t > 0.0 && t < minT) {
      normal = normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));
      color = tri.color;
      minT = t;
    }
  }

  return minT;
}

// Function 4809
vec2 mapDetailed(vec3 p) {
    vec2 d = vec2(-1.0, -1.0);
    d = vec2(mapTerrain(p-vec3(0.0, FLOOR_LEVEL, 0.0), FLOOR_TEXTURE_AMP), TYPE_FLOOR);
    return d;
}

// Function 4810
vec3 map3(in vec3 pos) {
    
    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);
    res.x =abs(res.x);
    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); 
    res.x =abs(res.x);
	return res;
}

// Function 4811
vec2 map( in vec3 pos )
{
    vec2 res = vec2( sdPlane(     pos), 1.0 );
    res = opU( res, vec2( sdBounceBalls( pos),1.) );
    res = opU( res, vec2( sdBridge( pos),1.) );
    pos -=vec3(-1,0.,-.5);
    
    float deg = 1.*3.14159/180.;
    pos = rY(pos,sin(deg),cos(deg));
    res = opU( res, vec2( sdBoat( pos),1.) );
    return res;
}

// Function 4812
Hit map(vec3 p) {
	Hit h = sdTerrain(p);
	minH(h, sdTies(p));
	return h;
}

// Function 4813
float dstScene(vec3 p) {
    
    float disp = sin(p.x*10.+iTime*3.)*.1;
    disp += cos(p.y*5.-iTime*5.)*.1;    
    
    float dst = length(p) - 1. + disp;
    dst = smin(dst, sdPlane(p, vec4(0.,0.,-1.,1.)), 1.);
    
    return dst;
    
}

// Function 4814
vec3 map_light_ray(vec3 ro, vec3 rd, vec3 nrm) {
    return rd;
}

// Function 4815
vec2 heightmap(vec2 p) {

    // get polygon distance
    float dpoly = dseg(p, O, A);
    dpoly = min(dpoly, dseg(p, A, B));
    dpoly = min(dpoly, dseg(p, B, C));
    dpoly = min(dpoly, dseg(p, C, D));
    dpoly = min(dpoly, dseg(p, D, O));
    
    // offset from edge
    float k = 0.08;
    
    // base height
    float z = k + 0.01 * noise(5.*p);
    
    if (dpoly < k) {
        // semicircular shoulder
        float w = (dpoly/k - 1.0);
        z *= sqrt(1.0 - w*w);
    } else {
        // depression inwards from edge
        z *= (1.0 - 0.03*smoothstep(k, 2.0*k, dpoly));
    }
    
    // return height and polygon distance
    return vec2(z, dpoly);
    
}

// Function 4816
vec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){
   
    const float eps = 0.001;
    float ref = tex3D(tex,  p , nor);                 
    vec3 grad = vec3( tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)-ref,
                      tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)-ref,
                      tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)-ref )/eps;
             
    grad -= nor*dot(nor, grad);          
                      
    return normalize( nor + grad*bumpfactor );
	
}

// Function 4817
vec3 dist_hyperbola(vec2 p, float a, float c)
{

    float a2 = a*a;
    float c2 = c*c;
    float b2 = c2 - a2;
    float b = sqrt(b2);
    
    float A = a*p.x/(a2 + b2);
    float B = b*p.y/(a2 + b2);
    
    float t = 0.0;
    
    int i;
    for (i = 0; i < 1000;i++) {
        float ch = cosh(t);
        float sh = sinh(t);
        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);
        t = t - dt;
        if (abs(dt) < 1.0e-3) break;
    }
    
    vec2 P = vec2(a*cosh(t), b*sinh(t));
    
    return vec3(length(P - p), float(i), t);
}

// Function 4818
float scene(vec3 p) {
    // the sphere
	float s = length(p-vec3(0,.3,0)) - 1.;

    // the ocean is just a plane with different levels of noise going opposite directions and with different scale
    // of course this breaks continuity so we compensate by undershooting our marching
  	float pl = p.y +
  	0.1 * texture(iChannel0, sin( t*.008)+t*.008+p.xz*.50).r +
  	0.2 * texture(iChannel0, cos(-t*.004)-t*.004+p.xz*.15).r +
  	0.9 * texture(iChannel0, sin( t*.020)+t*.010+p.xz*.05).r;

  	return min(s,pl);
}

// Function 4819
vec3 remap(vec3 col) { // map range -1 to 1, to, range 0 to 1
  return col * 0.5 + 0.5;
}

// Function 4820
float sceneWithFloor(vec3 p)
{
    return min(
        scene(p),
        1.+p.y
    );
}

// Function 4821
vec2 map(in vec3 p) {
    return map(p, true);
}

// Function 4822
vec4 MAP_Scene(vec3 p, vec3 eye, int mode) { // Main Scene
	float fulldist = 9999.0;
    float dist = fulldist;
    vec3 color = DEFAULT_MESH_COLOR;
    vec3 n = mode == 1 ? GetNormal(p) : vec3(0.0);
    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);
    
    // Red Sphere
    {
        vec3 sphereColor = vec3(1.0, 0.0, 0.0);
        float sphereRadius = 1.0;
        vec3 spherePosition = vec3(0.0, 1.0, 0.0);
        float sphereDist = length(p-spherePosition)-sphereRadius;
        if (sphereDist < dist) {
            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(p+n*SURFACE_DISTANCE, reflect(-normalize(eye-p), n)) : vec3(1.0);
            color = mix(sphereColor, reflected, 0.5)*diff;
            dist = sphereDist;
        }
    }
    
    // Ocean
    {
        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);
        float oceanHeight = 0.0;
        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 2, 1.0);
        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;
        if (oceanDist < dist) {
            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(oceanP+n*SURFACE_DISTANCE, reflect(-normalize(eye-oceanP), n)) : vec3(1.0);
            color = mix(oceanColor, reflected, max(dot(normalize(eye-p), n), 0.0)/5.0);
            dist = oceanDist;
        }
    }
    
    return vec4(color, dist);
}

// Function 4823
vec3 calcSceneColorNonDerivative(in vec3 vCamPos, in vec3 vRayDir)
{
	float d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);
	if (vRayDir.y > 0.)
	{
		return skyColor(vRayDir);
	}
	else
	{
		vec3 vHitPos = vCamPos + vRayDir * d;
		float vDer = floorGrid(vHitPos.xz, d - acos(vRayDir.y)*d*0.4);
		return clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - vDer), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);
	}
}

// Function 4824
float map(in vec3 p) {
    float box = sdBox(p, vec3(0.8, 0.8, 0.8));
	float rsphere = sdSphere(p, 1.0);
    float rbox1 = sdBox(p, vec3(2.0, 0.1, 2.0));
    float rbox2 = sdBox(p.yzx, vec3(2.0, 0.1, 2.0));
    float rbox3 = sdBox(p.zxy, vec3(2.0, 0.1, 2.0));
    return sdDifference(box, sdUnion(rsphere, rbox1, rbox2, rbox3));
}

// Function 4825
float map( in vec3 pos )
{
    // animate
    pos.y += 0.5*iTime;

    // paramteres
    const float le = 0.13, r1 = 0.2, r2 = 0.09;
    
    // make a chain out of sdLink's
    vec3 a = pos; a.y = fract(a.y    )-0.5;
    vec3 b = pos; b.y = fract(b.y+0.5)-0.5;
    
    // evaluate two links
    return min(sdLink(a.xyz,le,r1,r2),
               sdLink(b.zyx,le,r1,r2));
}

// Function 4826
vec4 getBWDist(vec2 pos)
{
    return vec4(smoothstep(.9,1.1,getVal(pos,0.)*.9+htPattern(pos*.7)));
}

// Function 4827
vec3 uvtomap(vec2 uv, vec3 div) {
    vec2 fuv=floor(uv*div.xy);
    float pz=fuv.x+fuv.y*div.x;
    return vec3(fract(uv*div.xy)*vec2(2.0)-vec2(1.0),(pz/(div.x*div.y))*2.0-1.0)*3.0;
}

// Function 4828
float sdfBox(vec3 p, vec3 b)
{
  return length(max(abs(p) - b, 0.0));
}

// Function 4829
vec2 map(vec3 pos)
{
    float ball = map_ball(pos);
    vec2 res = vec2(ball, BALL_OBJ);
    
    return res;
}

// Function 4830
float distFrac(vec3 p)
{
	const float scale = 1.8;
	const float offset = 2.0;

	for(int n=0; n< FRACTALITERATIONS; n++)
	{
		p.xy = (p.x+p.y < 0.0) ? -p.yx : p.xy;
		p.xz = (p.x+p.z < 0.0) ? -p.zx : p.xz;
		p.zy = (p.z+p.y < 0.0) ? -p.yz : p.zy;

		p = scale*p-offset*(scale-1.0);
	}
 
	return length(p) * pow(scale, -float(FRACTALITERATIONS));
}

// Function 4831
float dist(vec4 p, vec4 q) {
  return acos(clamp(dot(p,q),-1.0,1.0));
}

// Function 4832
float sdFibSphere(in vec3 pos, in float rad1, in float rad2) {

    float d = 1e9;
    
    // early-out.
    // this approach to bounding volume destroys exactness of SDF.
    // discussion in https://www.shadertoy.com/view/ssBXRG
    float sdBounds = abs(sdSphere(pos, rad1)) - rad2;
    if (sdBounds > rad2 * 0.2) {
        return sdBounds;
    }

    // golden angle
    const float phi = 3.14159265359 * (3.0 - sqrt(5.0));
    
    const float num           = 50.0;
    const float num_minus_one = num - 1.0;
    
    for (float n = 0.0; n < num; ++n) {
        // y goes from 1 to -1
        float y = 1.0 - (n / num_minus_one * 2.0);
        
        // radius at y
        float radius = sqrt(1.0 - y * y);
        
        // shrink the ones near the top
        float rad2Fac = smoothstep(1.0, 0.0, abs(y)) * 0.4 + 0.6;
        
        float theta = phi * n;
        
        float x = cos(theta) * radius;
        float z = sin(theta) * radius;
        
        d = min(d, sdSphere(pos - vec3(x, y, z) * rad1, rad2 * rad2Fac));
    }
    
    return d;
}

// Function 4833
SceneResult Scene_TestSceneGetDistance( vec3 vPos, int insideObjId )
{    
    SceneResult resultInside = SceneResult_Default();
    SceneResult resultOutside = SceneResult_Default();
    if ( insideObjId != -1 )
    {
    	resultOutside.fDist = -10000.0;
    }
    
    
    SceneResult resultFloor;
    
    resultFloor.fDist = vPos.y;
    resultFloor.vUVW = vec3(vPos.zxy * 0.1);
    resultFloor.iObjectId = MAT_TEXTURED_FLOOR;

    SceneResult_Combine( resultInside, resultOutside, resultFloor, insideObjId );

    vec2 vRepeat = vec2(15.0);
    vec2 vOffset = vRepeat / 2.0;
    vec3 vPosRepeat = vPos;
    vPosRepeat.xz = fract((vPos.xz + vOffset) / vRepeat) * vRepeat - vOffset;
    
    
    vec3 vSphDomain = vPosRepeat;
    vSphDomain.z = abs(vSphDomain.z + 1.5) - 1.5;
    
    SceneResult sph1result;
    
    vec3 vSph1Pos =  vSphDomain - vec3(0,1,0);
    sph1result.fDist = length(vSph1Pos) - 1.0;
    sph1result.vUVW = vec3(vPos);
    sph1result.iObjectId = MAT_COLORED_GLASS;
    
    if ( vPosRepeat.z < -2.0 )
    {
        sph1result.iObjectId = MAT_COLORED_GLASS_2;
    }
    SceneResult_Combine( resultInside, resultOutside, sph1result, insideObjId );    
    
    SceneResult sph4result;
    
    vec3 vSph4Pos =  vSphDomain - vec3(3,1,0.0);
    sph4result.fDist = length( vSph4Pos) - 1.0;
    sph4result.vUVW = vec3(vPos);
    sph4result.iObjectId = MAT_CHROME;
    
    if ( vPosRepeat.z < -2.0 )
    {
        sph4result.iObjectId = MAT_GOLD;
    }

    SceneResult_Combine( resultInside, resultOutside, sph4result, insideObjId );
    
    SceneResult sph5result;
    vec3 vSph5Pos =  vSphDomain - vec3(-3,1.0,0.0);
    sph5result.fDist = length( vSph5Pos) - 1.0;
    //sph5result.fDist = GetDistanceWineGlass( vSph5Pos - vec3(0,-1,0) );
    //sph5result.fDist = GetDistanceMug( vSph5Pos );
    sph5result.vUVW = vec3(vPos);
    sph5result.iObjectId = MAT_WHITE_GLOSS;
    
    if ( vPosRepeat.z < -2.0 )
    {
	    sph5result.iObjectId = MAT_WHITE_MATT;
    }    
    
    SceneResult_Combine( resultInside, resultOutside, sph5result, insideObjId );     
  

    SceneResult lightResult;
    
    vec3 vPosRepeat2 = vPos;
    vec2 vOffset2 = vec2(5.0);
    vPosRepeat2.xz = fract((vPos.xz + vOffset2) / 10.0) * 10.0 - vOffset2;
    
    lightResult.fDist = DistanceCapsule( vPosRepeat2, vec3(0.0,5.0,-1.5), vec3(0.0,5.0,1.5), 0.25);
    lightResult.vUVW = vec3(vPosRepeat2);
    lightResult.iObjectId = MAT_EMISSIVE_LIGHT;

    SceneResult_Combine( resultInside, resultOutside, lightResult, insideObjId );
    
    {
        vec3 vSphPos = vec3(1,4,0) - vSphDomain;

        SceneResult glassSphResult;
        glassSphResult.fDist = length( vSphPos ) - 1.0;
    	glassSphResult.vUVW = vec3(vPos);
    	glassSphResult.iObjectId = MAT_FROSTED_GLASS;
        
        if ( vPosRepeat.z < -2.0 )
        {
            glassSphResult.iObjectId = MAT_COLORLESS_GLASS;
        }
	    SceneResult_Combine( resultInside, resultOutside, glassSphResult, insideObjId );
    }
    
    {
    	vec3 vGlassPos =  vPosRepeat - vec3(4.5,0, -2.5);

        //sph1result.fDist = min( sph1result.fDist, GetDistanceWineGlass( vGlassPos - vec3(0,-1,0) ) );
        
        SceneResult glassResult;
    
    	glassResult.fDist = GetDistanceWineGlass( vGlassPos );
                
    	glassResult.vUVW = vec3(vPos);
    	glassResult.iObjectId = MAT_COLORLESS_GLASS;
    
	    SceneResult_Combine( resultInside, resultOutside, glassResult, insideObjId );
        
        
        SceneResult resultWine;

        resultWine.fDist = GetDistanceWine( vGlassPos );
        resultWine.vUVW = vec3(vPos);
        resultWine.iObjectId = MAT_WINE;
        
    
	    SceneResult_Combine( resultInside, resultOutside, resultWine, insideObjId );        
    }

    SceneResult resultPrism;
    vec3 vPrismPos = vPosRepeat - vec3(5, 4.0, 0.0 );
    resultPrism.fDist = vPrismPos.y;
    vPrismPos = DomainRotateSymmetry( vPrismPos, 3.0 );
    resultPrism.fDist = max( resultPrism.fDist, vPrismPos.z - 0.4 );
    //resultPrism.fDist = length( vPrismPos.xz ) - 0.4;
    resultPrism.vUVW = vec3(vPos);
    resultPrism.iObjectId = MAT_COLORLESS_GLASS;

    SceneResult_Combine( resultInside, resultOutside, resultPrism, insideObjId );        
    
    
    
    return SceneResult_Union( resultInside, resultOutside );
}

// Function 4834
float map(vec3 u, int processedMaterial
){float o=0.//0. if first operation is a SUB(), 1e10 otherwise
 ;rayObj=0
 ;vec4 w=vec4(u,1)//worldSpace
 ;beginMaterial(0)
 ;SUB(w.w*box(w.xyz-vec3(0),vec3(10,2.5,10)))
 ;ADD(w.w*cylinderY(w.xyz-vec3(-6,0,-2.),0.1,3.))
 ;ADD(w.w*cylinderY(w.xyz-vec3( 5,0,-2.),0.1,3.))
 ;endMaterial()     
 ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color
 ;for(int i=0;i<4;i++
 ){beginMaterial(i)
  ;ADD(c.w*sphere(c.xyz,1.))
  ;endMaterial()
  ;c=abs(c)
  ;c=beginObj(oCubeChil,c);}
 ;vec4 blackHoleSpace = beginObj(oBlackHole,w)
 ;beginMaterial(8)
 ;ADD(blackHoleSpace.w*sphere(blackHoleSpace.xyz,.5))
 ;endMaterial()
 ;vec4 tunnelSpace = beginObj(oTunnel,w)
 ;beginMaterial(3)
 ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0, .5,0),vec3(.2,.1,1.5)))
 ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0,-.5,0),vec3(.2,.1,1.5)))
 ;endMaterial()
 ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)
 ;beginMaterial(4)
 ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0, 1.4),vec3(.2,.4,0.1)))
 ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0,-1.4),vec3(.2,.4,0.1)))
 ;endMaterial()
 ;vec4 trainSpace = beginObj(oTrain,w)
 ;beginMaterial(7)
 ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.8),vec3(.1,.1,.18)))
 ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.4),vec3(.1,.1,.18)))
 ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,0),vec3(.1,.1,.18)))
 ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.4),vec3(.1,.1,.18)))
 ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.68),vec3(.1,.1,.06)))
 ;ADD(trainSpace.w*cylinderZ(trainSpace.xyz-vec3(0,.04,.8),.07,.18))
 ;endObj()
 ;endMaterial()
 ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))
 ;float tmpGauss = length(blackHoleSpace.xz)-1.5
 ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))
 ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)
 ;vma+=(1.-vma)*temp*AccretionDisk
 ;for(int L=0;L<3;L++
 ){ADD(w.w*sphere(w.xyz-oliPos[L],.001))
  ;vec3 relPos=oliPos[L]-pos
  ;oliHal[L]+=o*(0.02/(dot(relPos,relPos)+.01));}
 ;return o;}

// Function 4835
vec3 ShowScene (vec3 ro, vec3 rd)
{
  vec3 vn, objCol;
  float dstHit;
  vec3 col = vec3 (0., 0., 0.04);
  idObj = -1;
  dstHit = ObjRay (ro, rd);
  if (idObj < 0) dstHit = dstFar;
  if (dstHit < dstFar) {
    ro += rd * dstHit;
    int idObjT = idObj;
    if (idObj != idGrnd) vn = ObjNf (ro);
    else vn = vec3 (0., 1., 0.);
    idObj = idObjT;
    vec4 col4 = ObjCol (vn);
    objCol = col4.xyz;
    float spec = col4.w;
    float dif = max (dot (vn, ltDir), 0.);
    float ao = ObjAO (ro, vn);
    float sh;
    if (idObj != idGrnd || length (qHit.xy) > trkRad - 3. * trkWid)
       sh = ObjSShadow (ro, ltDir);
    else sh = 1.;
    col = objCol * (0.2 * ao * (1. +
       max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.)) +
       max (0., dif) * sh * (dif + ao * spec *
       pow (max (0., dot (ltDir, reflect (rd, vn))), 64.)));
  }
  col = sqrt (clamp (col, 0., 1.));
  return col;
}

// Function 4836
vec2 sdfBalloon( vec3 currentRayPosition ){
  
  // First we define our balloon position
  vec3 balloonPosition = vec3( .3 , .3 , -0.4 );
    
  // than we define our balloon radius
  float balloonRadius = 1.1;
    
  // Here we get the distance to the surface of the balloon
  float distanceToBalloon = length( currentRayPosition - balloonPosition );
    
  // finally we get the distance to the balloon surface
  // by substacting the balloon radius. This means that if
  // the distance to the balloon is less than the balloon radius
  // the value we get will be negative! giving us the 'Signed' in
  // Signed Distance Field!
  float distanceToBalloonSurface = distanceToBalloon - balloonRadius;
    
  
  // Finally we build the full balloon information, by giving it an ID
  float balloonID = 1.;
    	
  // And there we have it! A fully described balloon!
  vec2 balloon = vec2( distanceToBalloonSurface,  balloonID );
    
  return balloon;
    
}

// Function 4837
float greatCircleDist(vec2 p, vec2 lp)
{
    float phi_1 = p.y;
    float phi_2 = lp.y;
    float delta_lambda = p.x-lp.x;
    return acos(sin(phi_1)*sin(phi_2) + cos(phi_1)*cos(phi_2)*cos(delta_lambda));
}

// Function 4838
float map(vec3 p, ivec4 piece) {
    p = mod(p,1.0)-0.5;
    p.xz *= rot(pi*float(piece.y));
    if (piece.x == CASTLE) {
    	return castle(p);
    } else if (piece.x == PAWN) {
        return pawn(p);
    } else if (piece.x == BISHOP) {
        return bishop(p);
    } else if (piece.x == HORSE) {
        return horse(p);
    } else if (piece.x == KING) {
        return king(p);
    } else if (piece.x == QUEEN) {
        return queen(p);
    } else {
        return far;
    }
}

// Function 4839
Hit mapShort(Ray r)
{
    const float maxStep = 200.0;
	Hit hit;
    hit.iter = 0.0;
    hit.p = vec3(0.0);
    hit.nrm = vec3(0.0);
    hit.light = 0.0;
    hit.failed = true;
    float d = 0.0;
    Res res;
    for(float i = 0.0; i < maxStep; i++)
    {
        vec3 p = r.o + r.d * d;
        vec3 ll =(mod(p + 3.0, 4.0) - 3.0);
        float sD = length(ll);
        if(sD <= 0.0)
            return hit;
        vec3 sn = normalize(ll);
        sD -= lightSize;
		if(sD < 0.0)
        {
            hit.iter = i / maxStep;
            hit.p = p - r.d*d;
            hit.nrm = sn;
            hit.p = p + hit.nrm* 0.01;
            hit.light = 1.0;
            hit.failed = true;
            return hit;
        }
        res = fr(p);
        if(res.val.x < minStep)
        {
            hit.iter = i / maxStep;
            
            hit.nrm = nrm(p);
            hit.p = p + hit.nrm * 0.01;
            hit.failed = false;
            return hit;

        }
       	d += abs(min(res.val.x, sD / abs(dot(r.d, sn))));// * (1.0 + (i / maxStep) * 5.0);
    }
    return hit;
}

// Function 4840
float DistanceFields(vec3 ro, vec3 rd, out int hit, out vec3 pos)
{
	float len = .0;
	float d;
	hit = 0;
	int m = 0;
	for (int st = 0; st < 22; st++)
	{
		pos = ro + rd * len;
		d = Scene(pos, m);
		if (d < 0.01)
		{
			hit = m+1;
			break;
		}
			len += d;
	}
	return len;
}

// Function 4841
float scenetunnel(vec3 p)
{
    vec3 pbox = vec3(p.x-20.,p.y,p.z+20.);
    vec3 ptor = vec3(p.x,p.y-3.1,p.z);
	vec3 pd = deform_torus(ptor);
	float dtorm = sdTorus(pd,vec2(10.,1.5));
	float db = sdBox(pbox,vec3(20.));
    float d = opS(db,dtorm);
    //float d = dtorm;
    //float d = dtorm;
    return d;
}

// Function 4842
float scene(vec3 p) 
{
	// main shape
	const float scale = 3.;
	vec2 disp = advfbm(scale*p.xz,.5)/scale;

#if MODE==0
	float h = length(disp);
#elif MODE==1
	vec3 pp = p+vec3(disp,0.)+time*vec3(1.,0.,0.);
	float h = texture(iChannel0,.05*pp.xy).x;
#else
	vec3 pp = p+vec3(disp,0.)+time*vec3(1.,0.,0.);
	float h = fbm(pp);
#endif
	
	// planet shape.
	h -= .05*dot(p.xz,p.xz);
	_h = h; 
	
	// distance estimate from ray pos to surface
	return  .2*(p.y-h);
}

// Function 4843
SurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )
{
    SurfaceLighting surfaceLighting;
    
    surfaceLighting.vDiffuse = vec3(0.0);
    surfaceLighting.vSpecular = vec3(0.0);    

    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );
        
    vec3 vSpotPos, vSpotTarget, vSpotCol, vSpotCaseCol;

    for ( int lightIndex=0; lightIndex< iLampCount; lightIndex++ )
    {
		GetLampInfo( lightIndex, vSpotPos, vSpotTarget, vSpotCol, vSpotCaseCol );
        
        vec3 vSpotDir = normalize( vSpotTarget - vSpotPos );    

        Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos + vSpotDir * 0.15, vSpotDir, radians(10.0), radians(20.0), vSpotCol );
        Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vSpotPos + vSpotDir * 0.24, vSpotCol * 0.05);
    }    
    
    #if OUTDOOR_LIGHTS
    // Sun & sky
    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor * g_fOutdoorLightScale );    
    surfaceLighting.vDiffuse += fAO  * g_vAmbientColor * g_fOutdoorLightScale;
    #endif 
    
    surfaceLighting.vDiffuse += fAO * fAmbient;
    
    return surfaceLighting;
}

// Function 4844
float SDFLine( in vec2 coords, in vec3 offsetSlope )
{
    coords -= offsetSlope.xy;
    float v = coords.x * offsetSlope.z - coords.y;
    vec2  g = vec2(offsetSlope.z,-1.0);
    return abs(v)/length(g);
}

// Function 4845
vec4 map(vec3 p){
    float noiseVal = simplex_noise(vec3(p.xz, iTime * .1)) * .5 + .5;
    if (p.y > .25){
        return vec4(opSubtraction(.3 - p.y, noiseVal - (.2 - smoothstep(.285, .3, p.y) * .01)), GRAY);
    }
    if (p.y > .2){
        return vec4(opSubtraction(.25 - p.y, noiseVal - (.3 - smoothstep(.235, .25, p.y) * .01)), GRAY);
    }
    if (p.y > .15){
        return vec4(opSubtraction(.2 - p.y, noiseVal - (.4 - smoothstep(.185, .2, p.y) * .01)), GRAY);
    }
    if (p.y > .1)
        return vec4(opSubtraction(.15 - p.y, noiseVal - (.5 - smoothstep(.135, .15, p.y) * .01)), GRAY);
    if (p.y > .05)
        return vec4(opSubtraction(.1 - p.y, noiseVal - (.6 - smoothstep(.085, .1, p.y) * .01)), ORANGE);
    
    return vec4(0., GRAY);
}

// Function 4846
DF SDF(vec2 p) {
    DF df=DF(Box(p,vec2(SimRes,8.)),vec3(1.)); //Vgg under
    	minn(df,DF(Box(p,vec2(4.,SimRes)),vec3(0.,1.,0.))); //Grn vgg
    	minn(df,DF(Box(p-vec2(SimRes-4.,0.),vec2(4.,128.)),vec3(1.))); //Vit vgg sida
    	minn(df,DF(Box(p-vec2(0.,124.),vec2(128.,4.)),vec3(1.))); //Vit vgg ver
    		minn(df,DF(Box(p-vec2(SimRes-128.,124.),vec2(128.,4.)),vec3(1.)));
    	//Interior
    		minn(df,DF(Box(p-vec2(SimRes-128.,32.),vec2(4.,128.-32.)),vec3(1.))); //Liten vit vgg sida
    		minn(df,DF(Line(p,vec2(SimRes-80.,28.),vec2(SimRes-24.,80.))-8.,vec3(0.9,0.,0.))); //Linje
    			minn(df,DF(Line(p,vec2(SimRes-70.,116.),vec2(SimRes-40.,116.))-3.,vec3(2.)));
    		
    minn(df,DF(length((p-vec2(SimRes*0.5,SimRes-80.))*vec2(0.75,2.))-50.,vec3(1.,1.,0.))); //Gul ellips
    //Return
    return df;
}

// Function 4847
vec2 sceneSDF(vec3 p) {
    
    // x is distance to scene, y is object id

    float id = 0.0;
    float cr = 5.0;

    vec3 q = p - vec3(0.0, 0.0, 10.0);
    vec3 ca = vec3(-cr,  cr,  cr);
    vec3 cb = vec3( cr,  cr,  cr);
    vec3 cc = vec3(-cr, -cr,  cr);
    vec3 cd = vec3( cr, -cr,  cr);
    vec3 ce = vec3(-cr,  cr, -cr);
    vec3 cf = vec3( cr,  cr, -cr);
    vec3 cg = vec3(-cr, -cr, -cr);
    vec3 ch = vec3( cr, -cr, -cr);

    vec3 b1 = vec3(1.0);
    float box1 = udfBox(p - vec3(-2.0, -cr+b1.y, 10.0), b1);

    vec3 b2 = vec3(1.5, 3.0, 1.5);
    float box2 = udfBox(p - vec3(2.0, -cr+b2.y, 9.0), b2);

    float tot = FAR;

    float back = udfQuad(q, ca, cb, cd, cc);
    float right = udfQuad(q, cb, cf, ch, cd);
    if (right < EPSILON) { id = 1.0; }
    float left = udfQuad(q, ce, ca, cc, cg);
    if (left < EPSILON) { id = 2.0; }
    float top = udfQuad(q, ce, cf, cb, ca);
    float bottom = udfQuad(q, cc, cd, ch, cg);

    tot = min(tot, back);
    tot = min(tot, right);
    tot = min(tot, left);
    tot = min(tot, top);
    tot = min(tot, bottom);
    tot = min(tot, box1);
    tot = min(tot, box2);

    return vec2(tot, id);
}

// Function 4848
void calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )
{
	A = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );
	B = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );
	C = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );
	D = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );
	E = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );
}

// Function 4849
float PrEVCapsDf (vec3 p, vec4 u, float r)
{
  return length (p - clamp (dot (p, u.xyz), 0., u.w) * u.xyz) - r;
}

// Function 4850
float sdfTri(vec2 uv) { return max(abs(uv.x) * .866 + uv.y * .5, -uv.y)-.577; }

// Function 4851
float Scene( vec3 p, mat3 localToWorld )
{
    p = p * localToWorld;
    
    // ring
    float a = Cylinder( p, 1.0, 0.1 );
    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); 
    float ring = Substract( a, b );
    
    // nail
    float c = Box( p + vec3( -0.8, 0.0, 0.0 ), vec3( 0.4, 0.1, 0.1 ) );
    float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );
    float e = TriPrism( p + vec3( -1.274, 0.0, 0.0 ), vec3( 0.149, 0.1, 0.16 ) );
    float nail = Union( UnionRound( c, d, 0.1 ), e );
    
    // dents
    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );
    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );
    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );
    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );
    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );
    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );
    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );

    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );
    ring = SubstractRound( ring, dents, 0.03 );
    
    float ret = Union( ring, nail );
	return ret;
}

// Function 4852
float scene(vec4 p) {
  vec4 q = abs(p) - 1.;
  float cube = length(max(q,0.0)) + min(max(max(q.x,q.w),max(q.y,q.z)),0.0) - 0.1;
  float scale = 1.;
  vec4 p2 = p+iTime*0.2;
  p2 = (stri(p2/scale, .9)-0.5)*scale;
  float spheres = length(p2)-0.2;
  spheres = -smin(-(length(p) - 2.), -spheres, 0.1);
  return smin(cube, spheres, 0.5);
}

// Function 4853
vec2 map(vec3 p, int octaves) {
	float dMin = 28.0;
	float d;
	float mID = -1.0;
	
	// Mountains
	float h = terrain(p.xz, octaves);
	//h += smoothstep(0.0, 1.1, h);
    //h += smoothstep(-0.1, 1.0, p.y)*0.6;
	d = p.y - h;
	if (d<dMin) { 
		dMin = d;
		mID = 0.0;
	}

	return vec2(dMin, mID);
}

// Function 4854
float map(vec3 p){  
	
    p.y+=0.9;
    
    float sphere_radius = 0.35;
    vec3 sp = p;
    float alle  = 1000.;
    
    sp = p;
    sp.y += 0.5;
    vec3 csp = sp;
    sp.xz = fract(p.xz)-0.5;
    
    ////////////////////CYL!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    float ride = spinner(p);
    
    
    /////////////////////SEGS////////////////////////////
    vec2 id = floor(p.xz);
    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);
    float t =  iTime/6.;
    
    
    float gross = 1.3;
    float depth = 0.6;
    
    float height = fbm2(id+t)*gross+depth;
    float heightL = fbm2((id + vec2(0.,1.))+t)*gross+depth;
    float heightR = fbm2((id + vec2(0.,-1.))+t)*gross+depth;
    float heightV = fbm2((id + vec2(-1.,0.))+t)*gross+depth;
    float heightH = fbm2((id + vec2(1.,0.))+t)*gross+depth;
    
    vec3 vor = vec3(-1.,heightV,0.);
    vec3 hin = vec3(1.0,heightH,0.0);
    vec3 links = vec3(0.,heightR,-1.);
    vec3 rechts = vec3(0., heightL,1.0);
    vec3 zentrum = vec3(0.,height,0.);
    
    
    float k = seggy(sp, zentrum, vor);
    float segs = k;
    k = seggy(sp, zentrum, links);
    segs = min(segs, k);
    k = seggy(sp, zentrum, rechts);
    segs = min(segs, k);
    k = seggy(sp, zentrum, hin);
    segs = min(segs, k);
    
    k = seggy(sp, zentrum, vec3(0.,-depth,0.));
    segs = min(segs, k);
    
    alle = min(segs,alle);
    
    //#######################BALL0000000000000000000000000000000000
    
    
    float ball = length(sp - vec3(0.,height,0.))-0.03-ball_gross*0.02;
    
    
    
    alle = min(alle, ball);
    
    ////////////////PLANE_____________________________________
    float plane = sp.y+0.6;
    
    ////////////////////ID@!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if(plane < alle && plane < segs && plane < ride)mid = 2.;
    else if(ball < plane && ball < segs && ball < ride){
        mid = 1.;
        //glow += (0.00001/(0.75*pow((ball),2.)));
        }
    else if (segs < plane && segs < ball && segs < ride)mid = 0.;
    else if (ride < plane && ride < ball)mid = 3.;
    
    //float ride = 
    alle = min(alle,ride);
    return min(alle, plane);//-fbm4(p.xz));
}

// Function 4855
void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )
{
    // Project ray direction on to the unit cube.
    vec3 absRayDir = abs(rayDir);
    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));

    
    // Get the index of the current face being rendered.
    
    int faceIndex = 0;

    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)
    {
        faceIndex = 2;
    }
    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)
    {
        faceIndex = 4;
    }

    if(rayDir[faceIndex / 2] > 0.)
        faceIndex |= 1;

    fragColor = vec4(0);

    if(faceIndex != 1)
        return;

    vec2 uv = fragCoord.xy / 1024.;
    
    // Resample
    fragColor.rg = sampleSnowflakes(uv);
}

// Function 4856
float mapmask(vec3 p, vec3 div) {
    vec3 cp=clamp((p/3.0),-1.0,1.0)*3.0;
    return clamp(length(p-cp)*100.0,0.0,1.0);
}

// Function 4857
vec3 map(vec3 ro, vec3 rd, float t) {
    poly2 f = pa_map(ro, rd, t);
    return vec3(f.a[0], nextevent(f), f.a[1]);
}

// Function 4858
Hit sceneSDF(vec3 p)
{
    p -= vec3(-0.3, -0.2, 0.2);
    Hit scene = Hit(planeSDF(p + vec3(1.5), vec3(0.0, 1.0, 0.0)), 1);
    
    scene = minHit(scene, Hit(sphereSDF(p - vec3(-0.5, 0.2, 0.0), 0.7), 2));
    scene = minHit(scene, Hit(torusSDF(p - vec3(0.5, -0.4, 1.1), vec2(0.45, 0.3)), 3));
    scene = minHit(scene, Hit(capsuleSDF(p - vec3(1.1, -0.2, -0.7), 0.7, 0.5), 4));
    
    return scene;
}

// Function 4859
vec3 Tonemap( vec3 x )
{
    float a = 0.010;
    float b = 0.132;
    float c = 0.010;
    float d = 0.163;
    float e = 0.101;

    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );
}

// Function 4860
float map_bottle_ext(vec3 pos)
{
    #ifdef bumped_glass
    pos+= getBottleBump(pos);
    #endif
    
    vec3 pos2 = pos;
    float p = 1. - 4.4*pow(smoothstep(0.5, 1.75, pos.y), 1.3);
    pos2.xz/=(1. + 0.16*pos.y*p);
    vec3 pos3 = pos;
    pos3.y-= 0.73;
    pos3.y*= 1.6;
    vec3 pos4 = pos;
    pos4.y-= 2.1;
    pos4.xz*=(1. + 0.3*pos4.y);
    vec3 pos5 = pos;
    pos5.y-= 2.82;
    vec3 pos6 = pos;
    pos6.y+= 1.55;
    pos6.y*= 0.39;
    vec3 pos7 = pos;
    pos7+= vec3(0., -1., -0.8);
    pos7.yz = rotateVec(pos7.yz, -pi*0.3);
    vec3 pos8 = pos.zxy + vec3(1.15, 0, -0.7);
    
    float df = sdCylinder(pos2, vec2(0.83, 1.35));
    df = smin(sdCylinder(pos4, vec2(0.2, 0.93)), df, 5.);
    df = smin(sdCylinder(pos5, vec2(0.2, 0.088)), df, 27.);
    df = SoftMaximum(df, -pos.y - 0.57, 10.);
    df = SoftMaximum(df, -length(pos6) + 0.55 - 0.5*pos.y*pos.y*pos.y, 18.);
    #ifdef bottle_inset
    df = SoftMaximum(df, -sdCylinder(pos8, vec2(0.72, 1.)), 8.);
    #endif
    
    #ifdef show_label 
    df = smin(df, sdCylinder(pos7, vec2(0.18, 0.02)), 35.);
    df = SoftMaximum(df, -sdCylinder(pos7 + vec3(0., -0.025, 0.), vec2(0.15, 0.03)), 80.);
    #endif
    
    #ifdef bottle_ticks
    float a = atan(pos.x, pos.z);
    float l = length(pos.xz);
    float d = 1.1*smoothstep(0.53, 0.6, l)*smoothstep(0.67, 0.61, l);
    df-= 0.01*d*smoothstep(1. - d, 1., sin(85.*a))*(pos.y>0.?0.:1.);
    #endif
    
    return df; 
}

// Function 4861
float cubeSDF(vec3 pos)
{
    // One more box..?
    vec3 c = vec3(0., -2., 0.3);
    float rounded = 0.1;
    vec3 r = vec3(0.5, 0.5, 0.3)-rounded;
    vec3 q = abs(pos - c) - r;
    //return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;
    return 1000.; // Nah.
}

// Function 4862
vec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){
    const float eps = 0.001;
    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),
                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),
                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));
    
    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             
    grad -= nor*dot(nor, grad);          
    return normalize( nor + grad*bumpfactor );
	
}

// Function 4863
vec2 kodosSDF(vec3 point) {
    float swingTime = 0.0;
    swingTime = PRECOMPUTEDKODOSTIME;
    
    vec3 kodosPoint = translate(point, vec3(4,4,KODOSLIVEHERE));
    vec3 headPoint = translate(kodosPoint, vec3(0,0,0));
    vec3 mouthCapPoint = translate(kodosPoint, vec3(0,6,-5));
    
    vec2 mouthCap = vec2(sdTorus(mouthCapPoint, vec2(4, 4.5)), BLACKASNIGHT);
    mouthCapPoint.xy = rotate(mouthCapPoint.xy, PI * -0.5);
    vec2 mouthCap2 = vec2(sdCappedCylinder(translate(mouthCapPoint, vec3(0,0,-2)), vec2(5.5, 20)), BLACKASNIGHT);
    add(mouthCap, mouthCap2);
    
    vec2 head = vec2(sdRoundCone( headPoint, 9., 11.0, 22.0), KODOSGREEN);
    
    vec2 headTopSlice = vec2(sdPlane(translate(headPoint, vec3(0,29,0)), normalize(vec4(0,-1,0,1))), WHITEASMYSOUL);
    head = vec2(opSmoothSubtraction( headTopSlice.x,head.x, 0.8), KODOSGREEN);
    
    vec3 headInsidePoint = translate(headPoint, vec3(0,7,-2));
    headInsidePoint.xz = rotate(headInsidePoint.xz, PI * 0.5);
    vec2 headInside = vec2(sdEllipsoid( headInsidePoint, vec3(4., 10.0, 10.0)), BLACKASNIGHT);
    
    diff(head,mouthCap);
    
    vec3 eyePoint = translate(kodosPoint, vec3(0,18,-7.5));
    
    vec2 eye = vec2(sdSphere(eyePoint, 5.0),97.0);
    
    
    makeMouthSide(kodosPoint, vec3(5,6.2,-5), -0.46, -0.3, head);
    makeMouthSide(kodosPoint, vec3(-5,6.2,-5), -0.55, 0.3, head);
    
    vec3 lipPoint = translate(kodosPoint, vec3(0,12,-5));
    lipPoint.xz = rotate(lipPoint.xz, PI * -0.5);
    lipPoint.xy = rotate(lipPoint.xy, PI * 0.35);
    vec2 lip = vec2(sdEllipsoid( lipPoint, vec3(3., 7.0, 10.0)), KODOSGREEN);
    head =  vec2(opSmoothUnion(head.x, lip.x, 0.55), KODOSGREEN);
    
    vec3 lipPointB = translate(kodosPoint, vec3(0,-0.4,-3.));
    lipPointB.xz = rotate(lipPointB.xz, PI * -0.5);
    lipPointB.xy = rotate(lipPointB.xy, PI * -0.45);
    vec2 lipB = vec2(sdEllipsoid( lipPointB, vec3(3., 7.0, 10.0)), KODOSGREEN);
    head =  vec2(opSmoothUnion(head.x, lipB.x, 0.55), KODOSGREEN);
    
    add(head, headInside);
    
    makeATooth(kodosPoint,vec3(-3,4,-7), vec3(2.5, 1.5, 0.0), head);
    makeATooth(kodosPoint,vec3(-7,3,-5), vec3(2.5, 1.5, 0.0), head);
    makeATooth(kodosPoint,vec3(3,4,-7), vec3(2.5, 1.5, 0.0), head);
    makeATooth(kodosPoint,vec3(7,3,-5), vec3(2.5, 1.5, 0.0), head);
    makeATooth(kodosPoint,vec3(-2,6,-8.5), vec3(3.5,0.0, 1.5), head);
    makeATooth(kodosPoint,vec3(-6,7,-6.5), vec3(3., 0.0, 1.5), head);
    makeATooth(kodosPoint,vec3(2,6,-8.5), vec3(3.5, 0.0, 1.5), head);
    makeATooth(kodosPoint,vec3(6,7,-6.5), vec3(3., 0.0, 1.5), head);
    
    vec3 tooth1Point = translate(kodosPoint, vec3(-3,4,-7));
    vec3 droolPoint = translate(tooth1Point, vec3(-2,-2,1));
    droolPoint.yz = rotate(droolPoint.yz, PI * 0.25);
    vec2 drool = vec2(sdEllipsoid(droolPoint, vec3(2., 2., 2.0)), DROOLBLUE);
    
    vec3 drool1Point = translate(tooth1Point, vec3(-2,-2,-1));
    drool1Point.yz = rotate(drool1Point.yz, PI * 0.25);
    vec2 drool1 = vec2(sdEllipsoid(drool1Point, vec3(1., 1., 2.0)), DROOLBLUE);
    drool = vec2(opSmoothUnion(drool.x, drool1.x, 1.0), DROOLBLUE);
    add(head, drool);
    
    vec3 drool2Point = translate(drool1Point, vec3(-1,-2,-5));
    drool2Point.xy = rotate(drool2Point.xy, PI * -0.75);
    vec2 drool2 = vec2(sdEllipsoid(drool2Point, vec3(0.5, 0.5, 1.)), DROOLBLUE);
    add(head, drool2);
    
    eyePoint.xz = rotate(eyePoint.xz, PI * -0.025);
    vec3 pupilPoint = translate(eyePoint, vec3(0,0,-4.5));
    vec2 pupil = vec2(sdVesica(opRevolution(pupilPoint,0.15), 3., 2. ), BLOODREDEYE);
    eyePoint.xz = rotate(eyePoint.xz, PI * 0.025);
    
    vec3 browPoint = translate(eyePoint, vec3(0,1,-2));
    browPoint.x *= .8;
    browPoint.yz = rotate(browPoint.yz, PI * 0.65);
    vec2 brow = vec2(sdTorus(browPoint, vec2(4.25, 1)), KODOSGREEN);
    add(head, brow);
    
    vec3 browPointB = translate(eyePoint, vec3(0,-1.75,-0.5));
    browPointB.x *= .8;
    browPointB.yz = rotate(browPointB.yz, PI * -0.75);
    vec2 browB = vec2(sdTorus(browPointB, vec2(4.25, 1)), KODOSGREEN);
    add(head, browB);
    
    
    vec3 leftEarPoint = translate(kodosPoint, vec3(-11,15,0));
    vec2 leftEarSlice = vec2(sdPlane(translate(leftEarPoint, vec3(0,0,0)), normalize(vec4(0,0,1,1))), KODOSGREEN);
    leftEarPoint.xy = rotate(leftEarPoint.xy, PI * -0.15);
    vec2 leftEar = vec2(sdRoundCone( leftEarPoint, 2.5, 1.0, 9.0), KODOSGREEN);
    
    vec3 leftEarTubePoint = translate(leftEarPoint, vec3(1.5,0,-1.75));
    leftEarTubePoint.xy = rotate(leftEarTubePoint.xy, PI * -0.05);
    leftEarTubePoint.yz = rotate(leftEarTubePoint.yz, PI * -0.085);
    vec2 leftEarTube = vec2(sdRoundCone( leftEarTubePoint, 1.0, 0.8, 11.0), KODOSGREEN);
    
    diff(leftEar, leftEarSlice);
    add(leftEar, leftEarTube);
    add(head, leftEar);
    
    vec3 rightEarPoint = translate(kodosPoint, vec3(11,15,0));
    vec2 rightEarSlice = vec2(sdPlane(translate(rightEarPoint, vec3(0,0,0)), normalize(vec4(0,0,1,1))), KODOSGREEN);
    rightEarPoint.xy = rotate(rightEarPoint.xy, PI * 0.15);
    vec2 rightEar = vec2(sdRoundCone( rightEarPoint, 2.5, 1.0, 9.0), KODOSGREEN);
    
    vec3 rightEarTubePoint = translate(rightEarPoint, vec3(-1.5,0,-1.75));
    rightEarTubePoint.xy = rotate(rightEarTubePoint.xy, PI * 0.05);
    rightEarTubePoint.yz = rotate(rightEarTubePoint.yz, PI * -0.085);
    vec2 rightEarTube = vec2(sdRoundCone( rightEarTubePoint, 1.0, 0.8, 11.0), KODOSGREEN);
    
    diff(rightEar, rightEarSlice);
    add(rightEar, rightEarTube);
    add(head, rightEar);
    
    add(head, pupil);
    add(head, eye);
    
    
    vec2 baseBottom = vec2(sdRoundCone( translate(kodosPoint, vec3(0,-10,0)), 10.0, 6.0, 9.0), KODOSGREEN);
    add(head, baseBottom);
    
    vec2 liverSpot1 = vec2(sdEllipsoid(translate(kodosPoint, vec3(10,25,0)), vec3(1., 2, 2.0)), LIVERSPOTS);
    add(head, liverSpot1);
    
    vec3 liverSpot2Point = translate(kodosPoint, vec3(-3,26,-8));
    liverSpot2Point.xy = rotate(liverSpot2Point.xy, PI * 0.5);
    liverSpot2Point.yz = rotate(liverSpot2Point.yz, PI * 0.5);
    vec2 liverSpot2 = vec2(sdEllipsoid(liverSpot2Point, vec3(1., 2., 2.0)), LIVERSPOTS);
    add(head, liverSpot2);
    
    vec3 liverSpot3Point = translate(kodosPoint, vec3(4,27,-8));
    liverSpot3Point.xy = rotate(liverSpot3Point.xy, PI * 0.25);
    liverSpot3Point.yz = rotate(liverSpot3Point.yz, PI * 0.5);
    vec2 liverSpot3 = vec2(sdEllipsoid(liverSpot3Point, vec3(2., 1., 1.0)), LIVERSPOTS);
    add(head, liverSpot3);
    
    vec3 liverSpot4Point = translate(kodosPoint, vec3(-7,27,-6));
    liverSpot4Point.xy = rotate(liverSpot4Point.xy, PI * 0.25);
    liverSpot4Point.yz = rotate(liverSpot4Point.yz, PI * 0.5);
    vec2 liverSpot4 = vec2(sdEllipsoid(liverSpot4Point, vec3(1., 1., 2.0)), LIVERSPOTS);
    add(head, liverSpot4);
    
    
    return head;
}

// Function 4864
float BaseHeightmap( vec2 uv )
{
    uv *= 0.00001;
    
#ifdef BICUBIC
    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy);
	float noise = texture_bicubic( iChannel0, uv, texelSize ).x;
#else
    float noise = texture( iChannel0, uv ).x;
#endif
    return noise;
}

// Function 4865
float dist_field( vec3 p ) {
            
    float c = cos(twist*sin(iTime*2.0)*p.y);
    float s = sin(twist*sin(iTime*2.0)*p.y);
    mat2  m = mat2(c,-s,s,c);
    vec3  q = vec3(m*p.xz,p.y);

    float v = 1000.0;
    if (iTime < cube_disappear) {
        v = sdBox( q, vec3(0.5) );
        v += displacement(q);

        if (iTime > 40.0) {
            float sphereDist = -sdSphere(p+vec3(0.3*sin(2.0*iTime+2.0), 0.3*cos(iTime), 0.1*sin(2.1*iTime)), 0.3*r );
            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.5*sin(iTime), 0.5*cos(iTime), sin(2.1*iTime)), 0.6*r ));
            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.2*sin(2.*iTime), 0.3*cos(4.*iTime), 0.5*sin(1.*iTime)), 0.4*r ));
            sphereDist = max(sphereDist, -sdSphere(p+vec3(0.1*sin(4.*iTime), 0.1*cos(3.*iTime), 0.2*sin(0.5*iTime)), 0.5*r ));
        	v = max( v, sphereDist);
        }
	}
    v = min(v, sdSphere(p, 0.3*r) + 0.005*sin(p.y*32.0 + iTime*2.0));

    return v;
}

// Function 4866
float SDF_particle_wlink(vec3 p0, vec3 p, vec3 p1)
{
    particle point = get(fakech0, p0);
    float pde = length(point.pos.xyz - p) - sphere_rad;
    #ifdef LINKS
        if(length(point.pos.xyz - p1) < 4.)
        {
             pde = min(pde, sdCapsule(p, point.pos.xyz, p1, sphere_rad*0.2));
        }
    #endif
    return pde;
}

// Function 4867
float glyph_dist2(in vec2 pt, float angle) {
	float len = length(pt);
	float rad = 1.0- len;
	return rad- abs(sin(angle* spokes/ 2.0))* 0.6;
}

// Function 4868
Hit traceScene(Ray ray)
{
    Hit hit;
    hit.t = t_max;
   

    hit = compareHit(hit,traceSphere(ray,sphere0));
    hit = compareHit(hit,traceSphere(ray,sphere1));
    hit = compareHit(hit,traceSphere(ray,sphere2));
    hit = compareHit(hit,traceSphere(ray,sphere3));
    hit = compareHit(hit,traceSphere(ray,sphere4));
  	hit = compareHit(hit,traceSphere(ray,sphere6));
    //hit = compareHit(hit,traceSphere(ray,sphere7));
   
    
    hit = compareHit(hit,traceSphere(ray,sphere5));
   

    return hit;   
}

// Function 4869
float tankSdf(vec2 p) {
	const float halfTank = 0.5 * (tankLength);
    vec2 q = abs(p - vec2(0.0, halfTank)) - vec2(1.0, halfTank);
    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);
}

// Function 4870
float distanceSqr(vec2 A, vec2 B) {
    vec2 C = A - B;
    return dot( C, C );
}

// Function 4871
void intersectScene(
	vec3 rayOrigin,
	vec3 rayDir,
	inout float rayT,
	inout vec3 geomNormal)
{
	intersectSphere(rayOrigin, rayDir, vec3(-0.5,  0.5, 0.3), 0.25, rayT, geomNormal);
	intersectSphere(rayOrigin, rayDir, vec3( 0.5, -0.5, 0.3), 0.25, rayT, geomNormal);
	intersectSphere(rayOrigin, rayDir, vec3( 0.5,  0.5, 0.3), 0.25, rayT, geomNormal);
}

// Function 4872
vec3 mapC(vec3 p)
{
    p += 0.5;
    vec3 b = abs(p);
    
    vec3 c = vec3(1.0);
    
    if(b.y < 7.0 && p.z > -7.0) 
        if(p.x < -7.0) 
            c = vec3(1.0, 0.2, 0.01);//orange wall
        else if(p.x > 7.0) 
            c = vec3(0.01, 0.3, 1.0);// blue wall
        

    return c;
}

// Function 4873
float distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }

// Function 4874
void reinhardTonemap(inout vec3 color) {

    color *= 8.0;

    //color  = max0(color - 0.005);
    color  = color / (1.0 + color) * 1.08;
    
    float luminance = dot(color, vec3(0.2125, 0.7154, 0.0721));
    color = mix(vec3(luminance), color, 1.0);
}

// Function 4875
float mapWithElephants( vec3 p )
{
    vec3 kk;
    float res = map( p, kk ).x;

    res = min( res, mapElephantSimple(p) );
    res = min( res, mapSmallElephantSimple(p) );

    return res;
}

// Function 4876
float map(vec3 p){

    float sphere = sdfSphere(p);
    float plane = sdfPlane(p);
    float best = min(sphere,plane);
    if(best == sphere){matID = 2;}
    if(best == plane){matID=3;}
    return best;
}

// Function 4877
float mapTerrain( in vec3 p ) {
	vec3 c = p  + terrainOffset;
	return base(c)+7.0+0.03*base(c*10.)+2.0*p.y*terrainYFactor;
}

// Function 4878
bool Map_ValidSectorId( MapInfo mapInfo, int iSectorId )
{
    return ( iSectorId >= 0 && iSectorId < mapInfo.iSectorCount );
}

// Function 4879
vec2 map( in vec3 pos )
{
    vec2 res = vec2(1e9, 0.9);
    res = opU( res, vec2( sdTorus82(pos.xzy, vec2(1.0,0.05) ), 25.0 ));
    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(HALF_WIDTH, 0.0, 0.4), vec2(0.05,0.05) ), 95.0 ));
    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(-HALF_WIDTH, 0.0, 0.6), vec2(0.05,0.05) ), 95.0 ));
    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(-HALF_WIDTH, 0.0, -0.4), vec2(0.05,0.05) ), 95.0 ));
    res = opU( res, vec2( sdTorus82(   pos.xzy - vec3(HALF_WIDTH, 0.0, -0.6), vec2(0.05,0.05) ), 95.0 ));
    res = opU( res, vec2( sdBox(   pos.xzy - vec3(HALF_WIDTH, 0.0, -0.1), vec3(0.05,0.05,0.55) ), 95.0 ));
    res = opU( res, vec2( sdBox(   pos.xzy - vec3(-HALF_WIDTH, 0.0, 0.1), vec3(0.05,0.05,0.55) ), 95.0 ));
    res = opU( res, vec2( sdBox(  (ROT * pos.xzy), vec3(0.05,0.05,0.35) ), 95.0 ));
    return res;
}

// Function 4880
vec2 DistanceToObject(vec3 p)
{
	// Load the font texture's distance field.
    float letterDistField = (SampleFontTex(p.xy).w - 0.5+1.0/256.0);
    // intersect it with a box.
    float cropBox = sdBox(p, vec3(0.5 + 5.0, 3.5, 0.25));
    vec2 letters = matmax(vec2(letterDistField, 0.0), vec2(cropBox, 1.0));
    return letters;
}

// Function 4881
float sSDF( float d1, float d2 ) { return max(-d1,d2); }

// Function 4882
float dist(vec3 p)
{
	return dist2(p).x;
}

// Function 4883
float boxSDF(vec3 p, vec3 size, float r) {
    vec3 d = abs(p) - (size / 2.0) + r;
    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);
    float outsideDistance = length(max(d, 0.0));
    
    return insideDistance + outsideDistance - r;
}

// Function 4884
void onAnimateScene()
{
    float animationTime = TimeValue * 0.5;
 
    float radius = 5.0;
    //lightPos = vec3( 0.0, 8.0, 2.0 ) + vec3(cos(animationTime)*radius, cos(animationTime)*6.0, sin(animationTime)*radius);
    
	lightPos = vec3( 0.0, 10.0, 9.0 );
	
    spheres[0].position = lightPos;
    
    spheres[2].position.x += sin( animationTime * 1.0 ) * 3.0;
    spheres[2].position.y += abs( sin( animationTime * 4.0 ) * 4.0 );
    spheres[2].position.z += sin( cos( animationTime)  *    3.0 ) * 2.0;
}

// Function 4885
float Tonemap_UC2_W( float x )
{
	float W = 11.2;
    x = Tonemap_UC2( 2.4f * x );
	x *= 1.0f / Tonemap_UC2( 11.2f );
    return x;
}

// Function 4886
float intersectionDist(float d1, float d2) {
    return max(d1, d2);
}

// Function 4887
vec3 SphereMap( vec2 uv )
{
    // uv is in the range [0,1)
    // map this range onto a unit sphere, with a uniform distribution of points
    
    // use the fact that the surface area of a slice of a sphere is the same
    // as the surface area of a cylinder with the height of the slice and the
    // radius of the sphere
    
    // wrap the 2D space around a cylinder
    float h = uv.y*2.-1.; // height up cylinder
    float a = uv.x*tau; // angle around the circle
    
    // position on the circular slice of the cylinder at this height
    vec2 v = vec2(sin(a),cos(a));
    
    // project onto the corresponding slice of the sphere
    // by multiplying by width of sphere at this height
    v = v * sqrt(1.-h*h);
    
    return vec3(v,h);
}

// Function 4888
vec2 map(vec3 p) {
    
    float t=spin_speed*iTime;

    // system rotation
    R(p.xy, pi*iTime*0.02);
   
    float StarD = Star(p,p,vec3(-1.0,6.5,0.0),2.5);
    float VortexD = Vortex(p/0.02, vec3(45.0,-100.0,0.0), 80.0, 1.0)*0.02;
    //---------------------------    
    float Radius = 0.98;
    //float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.125+p.z*.80)*p.xy*80.,p.z*40.-t)*6.0) * length(p) * 0.34; //old variant
    float DiskD = Disk(p,vec3(1.0,Radius,0.35)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * length(p) * 0.34;
    float r = (sqrt(dot(p,p))/sqrt(2.0))*0.6;
	float a = atan(p.y, p.x);
	float dOffset = cos( (a+r*r*20.0)*2.-iTime*2.5) * .5 + .5;
	dOffset *= 1.0-r/Radius;
	DiskD += dOffset * .2;
    //---------------------------
    //float d4 = Star(p,p.yzx,vec3(0.0,0.0,0.0),0.05)*.8;
    //---------------------------
    vec3 q = p;
    R(q.yz, -0.25*pi*2.);
    float Jet1D = Vortex(q/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;
    //---------------------------
    q = p;
    R(q.yz, 0.25*pi*2.);
    float Jet2D = Vortex(q/0.012, vec3(0.0,130.0,0.0), 90.0, 0.0)*0.012 + pn(vec3(Spin(t*4.5+p.z*.80)*p.xy*80.,p.z*40.-t)) * 0.18;
    //---------------------------
    vec2 result = vec2(smin(smin(VortexD,DiskD/*smin(DiskD,d4,0.1)*/,1.0),StarD,1.5), 1.0);
    
    result = vec2(min(min(Jet1D,Jet2D),result.x), step(min(Jet1D,Jet2D),result.x));
    
    return result;
}

// Function 4889
float insetTriDist(vec3 ipos) {
    
    vec3 opos = origFromInset(ipos);
    
    float d0 = -geodesicDist(edges[0], opos.xy);
    float d1 = -geodesicDist(edges[1], opos.xy);
    float d2 = -geodesicDist(edges[2], opos.xy);
    
    return max(d0, max(d1, d2)) / opos.z;
    
}

// Function 4890
float distCapsule(vec3 pos, vec3 a, vec3 b, float r, sampler2D image, float scale)
{
	pos.xz += sin(pos.zx)*.25;
	pos.xz = mod(pos.xz,TREE_REP.xz);
	pos.xz -= vec2(TREE_REP.xz*.5);
	
    vec3 pa = (pos) - a;
	vec3 ba = b - a;
    float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );
	
	float bump = 0.0;
	float dist = length( pa - ba*h ) - r;
	if(dist < FEATURE_BUMP_FACTOR)
	{
		vec2 normal = normalize(pos.xy);
		vec3(normal.x, 0.0, normal.y);
		bump = tex3D(pos*scale, vec3(normal.x, 0.0, normal.y), image).r*FEATURE_BUMP_FACTOR*.5;
	}
	return dist + bump;
}

// Function 4891
vec4 mapTerrain( in vec3 pos )
{
	vec3 q = pos*0.5;
    
    vec3  dir = vec3(0.0,1.0,0.0);
	float spe = 0.04;
	float time = 5.0 + (iTime-10.0)*0.5;
	
	q.xyz += 2.0*noise( 2.0*q )*vec3(1.0,3.0,1.0);
	
	float f;
	q *= vec3(1.0,2.0,1.0);
	q += dir*time*8.0*spe; f  = 0.50000*noise( q ); q = q*2.02;
	q += dir*time*4.0*spe; f += 0.25000*noise( q ); q = q*2.03;
	q += dir*time*2.0*spe; f += 0.12500*noise( q ); q = q*2.01;
    q += dir*time*1.0*spe; f += 0.06250*noise( q );
    
	float d =  pos.y + 0.9 - 2.0*f;
    mocc = f;
	return vec4(q,d);
}

// Function 4892
vec2 sceneWithMaterials(vec3 point){
    vec2 base;
    bool skipKodos = false;
    for (int i = 0; i < 3; ++i) {
        int yayOrNay = sceneStack[i];
        if (i == 0) {
            if (yayOrNay == 1) {
                base = homerSDF(point/CHARACTERSCALE);
                base.x = base.x * CHARACTERSCALE;
            } else {
                base = kodosExteriorSDF(point/CHARACTERSCALE);
                base.x = base.x * CHARACTERSCALE;
                skipKodos = true;
            }
        } else if (i == 1) {
            if (yayOrNay == 1 && !skipKodos) {
                vec2 kodosExterior = kodosExteriorSDF(point/CHARACTERSCALE);
                kodosExterior.x = kodosExterior.x * CHARACTERSCALE;
                add(base, kodosExterior);
            }
        } else if (i == 2) {
            vec2 donut = spinningDonut(point/CHARACTERSCALE);
            donut.x = donut.x * CHARACTERSCALE;
            add(base, donut);
        }
    }
    return base;
}

// Function 4893
float cloudMap( vec3 n, mat4 camera, float bias, LameTweaks lame_tweaks )
{
	vec3 n0 = n;
#ifdef EARTH_ROTATION
	n.xy = rotate_with_angle( n.xy, lame_tweaks.earth_rot_time * earth_angular_velocity );
#endif
	float theta = acos( n.z );
	float phi = calc_angle( n.xy ) + PI; // assume range 0,1

	return cloudSphereMap( vec2( phi * 0.5, theta ) * ( 1.0 / PI ), camera, n0, bias, lame_tweaks );
}

// Function 4894
float rabdist(vec3 p)
{
    float an=.5*.5*2.*6. +iMouse.x/iResolution.x*6.;
    p.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*p.xz;
    
    float time2=time*2.4;

    p.y+=2.3;
    p.xy*=rotmat(cos(time2+1.)*.04);
    p.y-=2.3;

    vec3 op=p;

    vec3 p2=p;
    p2.xy*=rotmat(cos(time2)*.1);

    vec3 p3=p;
    p3.xy*=rotmat(cos(time2-.0-length(p)/2.)*.13);

    float d=1e4;
    p.x=abs(p.x);
    p2.x=abs(p2.x);
    p3.x=abs(p3.x);

    d=smin(length(p2-vec3(-.75,0.,-.1))-.4,length(p2-vec3(.75,0.,-.1))-.5,2.);
    d=smin(d,length(p2-vec3(0,0.4,-.1))-.9,1.6);
    d+=.1;  
    
    // Ears 1
    d=smin(d,distance(vec3(.7,clamp(p3.y,0.,2.2),0.),p3.xyz)-.4,.14);   
    d=smax(d,-(length(p3-vec3(.7,1.7,-0.5))-.5),.2);

    // Neck
    d=smin(d,distance(vec3(0.,clamp(p.y,-1.6,-1.1),0.),p.xyz)-.6,.04);   
    
    // Legs
    vec3 p4=op;
    float ld=-.75;
    p4.y-=ld;
    p4.yz*=rotmat(cos(time*2.+3.1415926/1.*0.)*.1);
    p4.y+=ld;
    p4.y-=max(0.,cos(time*2.+3.1415926/2.))*.1;
    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz)-.3,.1);
    p4=op;
    p4.y-=ld;
    p4.yz*=rotmat(cos(time*2.+3.1415926/1.*1.)*.1);
    p4.y+=ld;
    p4.y-=max(0.,cos(time*2.+3.1415926/2.+3.1415926/1.*1.))*.1;
    d=smin(d,distance(vec3(.3,clamp(p4.y,-2.6,-2.),0.),p4.xyz*vec3(-1,1,1))-.3,.1);   
    
    // Belly
    d=smin(d,distance(vec3(0.,-1.5,-.2),p)-.5+cos(time*3.)*.03,.4);   

    // Ears 2
    d=smin(d,distance(vec3(1.1,2.3,-.1),p3)-.2,.8);   

    // Tail
    d=smin(d,distance(vec3(0,-1.7,.6),p)-.3,.1);   

    vec3 q=vec3(0.35,.4,-1);

    if(mod(time-1.,4.)>.04)
    {
        d=smax(d,-(cylinder(p2-q,normalize(q-p2),.3,.1)-.0001),.05);
        d=smin(d,(length(p2-q*.9)-.2),.24);

        // Eye pupils
        if(op.x>0.)
            pupdist=(length(p2-vec3(.39,.32,-1.))-.2);
        else
            pupdist=(length(p2-vec3(.28,.32,-1.02))-.2);

        d=smin(d,pupdist,.005);
    }

    // Nose
    d=smin(d,(length(p2-vec3(0,.1,-1.02))-.2),.02);

    // Mouth (two states)
    float d3=smax(-(length(p-vec3(-.05,-.29,-1.02))-.1),-(length(p-vec3(.05,-.29,-1.02))-.1),.1);

    float d2=max(p2.z,distance(p2,vec3(clamp(p2.x,0.,.3),-.2,clamp(p2.z,-2.,2.)))+.01);

    float time4=time/8.;
    float gg=smoothstep(0.,1.,clamp((min(fract(time4),1.-fract(time4))-.25)*64.,0.,1.));
    d=smax(d,mix(-d2,d3,gg),.1);

    // Tooth
    d=min(d,(length(p-vec3(.0,-.2,-1.02))-.08));

    p.y+=.2;
    p.xy*=rotmat(.4+cos(time2*2.)*.02);

    // Arms
    float armd=smin(distance(vec3(.2,clamp(p.y,-1.8,-0.),0.),p.xyz)-.2,
                    distance(p,vec3(0.2,-1.7,0))-.2,.2);

    d=smin(d,armd,.05);   

    return d;
}

// Function 4895
vec4 MipMap(vec2 pvt) {
    return (texture(iChannel0,pvt)
    +texture(iChannel0,pvt+vec2(oX,0.))
    +texture(iChannel0,pvt+vec2(0.,oY))
    +texture(iChannel0,pvt+vec2(oX,oY))
    +texture(iChannel0,pvt+vec2(oZ,0.))
    +texture(iChannel0,pvt+vec2(oZ+oX,0.))
    +texture(iChannel0,pvt+vec2(oZ,oY))
    +texture(iChannel0,pvt+vec2(oZ+oX,oY)))*i8;
}

// Function 4896
float DistanceToPlane(vec3 eye, vec3 dir, float start, float end){
    float old_dist;
    float depth = start;
    for (int i = 0; i < MAX_STEPS; i++) {
        vec3 cur_eye = eye + depth*dir;
        float dist = planeSD(cur_eye);
        if (dist < EPSILON) {
            vec3 old_eye = eye - old_dist * dir;
            return depth - old_dist + old_dist * (old_dist - old_eye.y) / (cur_eye.y - old_eye.y - dist + old_dist);
        }
        depth += dist * 0.5;
        old_dist = dist;
        if (depth >= end) {
            return end;
        }     
    }
    return end; 
}

// Function 4897
float sdfRect(vec2 uv, vec2 s) {vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }

// Function 4898
float Scene(in vec3 rO, in vec3 rD)
{
    //float t = 0.0;
	float t = 8.0 * Hash(fcoord);
	float  alphaAcc = 0.0;
	vec3 p = vec3(0.0);
    int hits = 0;

	for( int j=0; j < 95; j++ )
	{
		if (hits == 8  || t > 1250.0) break;
		p = rO + t*rD;
		float sphereR = ScoopRadius(t);
		float h =Map(p);
		if(h < sphereR)
		{
			// Accumulate the alphas...
			float alpha = (1.0 - alphaAcc) * min(((sphereR-h) / sphereR), 1.0);
            // If high enough to contribute nicely...
            if (alpha > (1./8.0))
            {
				// If a peice of the lanscape is scooped as a suitable alpha,
                // then it's put on the stacks...
			// put it on the 2 stacks, alpha and distance...
                aStack[1].yzw = aStack[1].xyz; aStack[1].x = aStack[0].w;
                aStack[0].yzw = aStack[0].xyz; aStack[0].x = alpha;
                dStack[1].yzw = dStack[1].xyz; dStack[1].x = dStack[0].w;
                dStack[0].yzw = dStack[0].xyz; dStack[0].x = t;
                alphaAcc += alpha;	
                hits++;
            }
            
		}
		t +=  h * .5 + t * 0.004;
       
	}
    
	return clamp(alphaAcc, 0.0, 1.0);
}

// Function 4899
vec3 map( vec3 p )
{

	vec3 dl = vec3( length( p ) - 1.5 );
    vec3 dlOne = vec3( p.y + 2.0 );
    if( dl.y < dlOne.y ) dlOne = dl;
    return dlOne;

}

// Function 4900
float sdf_R(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(0, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, 0, 0), vec3(2, 0, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -4, 0), vec3(2, -4, 0)));
    t = min(t, sdf_half3_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_quarter1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -6, 0), vec3(4, -8, 0)));
    return t;
}

// Function 4901
float map (vec3 p) {
  vec3 p1 = p;
  p1.xz *= rotate(iTime * .3);
  p1.yz *= rotate(iTime * .2);
  float s1 = sphereSDF(p1, .6);
  s1 += sin((p1.x + p1.y * p1.z) * (3.14 * 10.) - iTime * 2.) * 
      .015 - sin((p1.x - p1.y * p1.z) * (3.14 * 12.) - iTime) * .01;

  p.z -= iTime * .2;
  vec3 c = vec3(2., 1.3, 2.);
  p = mod(p, c) - .5 * c;

  float s2 = sphereSDF(p, .3);
  s2 += sin((p.x + p.y * p.z) * 20. + iTime * 2.) * 
      .03 + cos(length(p.x - p.y * p.z) * 65. - iTime) * .01;

  return min(s1 * .3, s2 * .28);
}

// Function 4902
float dist2bisector(vec3 dir, int i)
{
    vec4 nb = texel(ch0, i2xy(ivec3(obj.id, i, 1)));
    object nbo = getObject(int(nb.x));  
    return dirBisectDist(dir, obj.X, nbo.X, distance(nbo.X, obj.X));
}

// Function 4903
float map(vec3 p) {
   // Animate
   p.z += iTime/2.0;
    
   // This makes everything below repeat infinitely.
   p = mod(p, 0.2) - vec3(0.1);
   
   // You can select a different shape by uncommenting lines below.
    
   // A ball with radius 0.05
   return length(p) - 0.05;
   
   // Octagon shape.
   // return dot(abs(p), vec3(1.0/sqrt(3.0))) - 0.05;

   // Cube shape
   // return length(p - clamp(p, vec3(-0.05), vec3(0.05)));
}

// Function 4904
vec2 sceneBalls(in vec3 pos, bool refr){
    vec2 res = vec2(TMAX, -1.0);
 	float x = 0.05 * (sin(iTime + 50.0 * pos.x)  * cos(iTime + 20.0 * pos.y) * sin(iTime + 30.0 * pos.z));
    float y = 0.04 * (cos(15.0 * sin(iTime) * pos.x) * sin(20.0 * sin(iTime) * pos.y) * sin(15.0 * sin(iTime) * pos.z));
    float other = sphere(pos - SPHERE_POS + vec3(0.0, sin(iTime) / 2.0, cos(iTime) / 2.0), 0.1);
    float other1 = sphere(pos - SPHERE_POS + vec3(cos(iTime) / 2.0, sin(iTime) / 2.0, 0.0), 0.1);
    float other2 = sphere(pos - SPHERE_POS + vec3(cos(iTime) / 2.0, 0.0,  sin(iTime) / 2.0), 0.1);

    res = propose(res, vec2(blend(blend(blend(sphere(pos - SPHERE_POS, SPHERE_RADIUS), other, 0.1), other1, 0.1), other2, 0.1), 3.0));
    if(!refr){
    	res = propose(res, vec2(displacement(sphere(pos - vec3(2.0*SPHERE_RADIUS + 0.5, 0, 0) - SPHERE_POS, SPHERE_RADIUS), x), 1.0));
    	res = propose(res, vec2(displacement(sphere(pos + vec3(2.0*SPHERE_RADIUS + 0.5, 0, 0) - SPHERE_POS, SPHERE_RADIUS), y), 1.0));
    }
    res = propose(res, vec2(plane(pos - vec3(0, -0.5, 0)), 2.0));
    return res;
}

// Function 4905
float map_lamps(vec3 pos)
{
    float tc = tunnel_curve(pos.z);
    float dc = dev_tunnel_curve(pos.z);
    pos.x-= tc;
    float zz = pos.z;
    pos.z = 0.;
    float a = atan(dc);
    pos.xz = rotateVec (pos.xz, a);
    pos.z = zz;
    
    pos.y-= tunnel_curve_y(pos.z);
    lmppos = pos;
    a = atan(pos.x, pos.y);
    float tsf2 = tsf/(2.*pi);
    pos.z+= tsf2;
    ltr = 0.9;
    ltr+= 2.*(1. - smoothstep(0.6, 0.65, a)*smoothstep(0.95, 0.9, a))*
         (1. - smoothstep(-0.6, -0.65, a)*smoothstep(-0.95, -0.9, a));
    
    ltr+= 0.3*(1. - smoothstep(0.42, 0.58, abs(pos.z - floor(pos.z*tsf2 + 0.5)/tsf2)));
    float df = -length(pos.xy) + tubeRadius*ltr;
    return df;
}

// Function 4906
vec2 map_hex(vec2 uv)
{
    vec3 t;
    
    t.x =  dot(uv.xy,vec2(0.559, 1));
    t.y = -dot(uv.xy,vec2(0.559,-1));
    t.z = uv.x * 1.118;
    
    vec3 p = fract(t*0.5);
    vec3 b = fract(t);
    
    float sum = floor(t.x) + floor(t.y);
    
    float fr = mod(sum, 6.);
    
    vec2 res;
    
    if(p.z < 0.5)
    {
        fr = mod(sum + 3., 6.);
    }
    
    
        if(fr < 6.)
        res = vec2(1.-b.y,1.-b.z);
        if(fr < 5.)
        res = vec2(   b.y,1.-b.x);
        if(fr < 4.)
        res = vec2(1.-b.z,   b.x);
        
        if(fr < 3.)
        res = vec2(1.-b.x,   b.z);
        if(fr < 2.)
        res = vec2(   b.x,1.-b.y);
        if(fr < 1.)
        res = vec2(   b.z,   b.y);
        
        
        
    return
    vec2(
    1. - (res.x + res.y * 0.5),
    res.y * 0.894
    );
}

// Function 4907
float MapSH(vec3 p)
{
	
	float h = -(FBM(p)-cloudy-.6);
    //h *= smoothstep(CLOUD_LOWER, CLOUD_LOWER+100., p.y);
    //h *= smoothstep(CLOUD_LOWER-500., CLOUD_LOWER, p.y);
    h *= smoothstep(CLOUD_UPPER+100., CLOUD_UPPER, p.y);
	return h;
}

// Function 4908
vec2 getBRDFIntegrationMap(vec2 coord, vec2 scaleSize){
    // Avoid reading outside the tile in the atlas
    coord = clamp(coord, 1e-5, 0.99);
    vec2 texCoord = vec2(coord.x/2.0, coord.y / 2.0 + 0.5);
    texCoord *= scaleSize;
    return texture(iChannel2, texCoord).rg;
}

// Function 4909
vec3 BSDF_Oren_Nayar_Sample(OrenNayarBsdf bsdf,vec3 Ng,vec3 vDir,float x1, float x2,out vec3 eval,out vec3 wi,out float pdf){
	//pre values
    BSDF_Oren_Nayar_Setup(bsdf);
    wi = sample_uniform_hemisphere(bsdf.nDir, x1, x2, pdf);
	if(dot(Ng, wi) > 0.){
		eval = BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);
	}
	else{
		pdf = 0.;
		eval = vec3(0.);
	}
	return eval;
}

// Function 4910
void scene(
	inout bit3d_shape shape,
	bit3d_coordinate coord
)
{
	vec3 frame = (abs(fract(coord.position/16.0)-0.5)-0.5)*16.;
	vec3 utframe = (fract(coord.position/16.0+0.5)-0.5)*16.0;
	shape.diffuse = vec3(0.11,0.5,0.89);
	shape.ambient = vec3(0.0);
	shape.specular = vec3(0.2);
	shape.specPower = 5.0;
	shape.stepk = false;
	shape.reflection = 0.0;
	shape.ambientOcclusion = 0.5;
	float holes = min(length(frame.xy)-0.8,length(frame.zy)-0.8);
	holes = min(holes,length(frame.xz)-0.1);
	float setcube = op_mix(box(frame,vec3(5.0)),holes,0.52);
	float h = op_subtract(0.2-holes,box(frame,vec3(5.0)));
	setcube = op_mix(setcube,(1.0-crossh(frame)),0.3);
	if (coord.portal == 0) {
		shape.surface = 0.2-setcube;
		if (holes >= 0.2) {
			shape.reflection = 0.0;
			shape.ambientOcclusion = 0.54;
		} else if (h < 0.2 && shape.surface <= edge*2.0) {
			shape.portal = 1;
		}
	} else if (coord.portal == 1) {
		vec3 hu = utframe;
		hu.y-= pow(abs(hu.x),0.75);
		shape.surface = op_mix(pow(capsphere(hu,5.77),0.25)-1.0,-0.5+sphere(frame,vec3(1.7,1.7,1.)),0.9);
		if (h > 0.2 && shape.surface <= edge) shape.portal = 0;
	 shape.diffuse = vec3(0.9,0.5,0.7);
	 shape.ambientOcclusion = 0.8;
	}
}

// Function 4911
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
	
    //Body
    		//Torso
    float 	lBody = sdEllipsoid( pos - vec3(0.0, 0.39, 0.0), vec3(0.16, 0.28, 0.15));
    		//Espalda
    		lBody = opSmoothUnion(lBody, sdEllipsoid( pos - vec3(0.0, 0.31, 0.05), vec3(0.18, 0.25, 0.18)), 0.1);
    		//Barriguita
    		lBody = opSmoothUnion(lBody, sdEllipsoid( pos - vec3(0.0, 0.25, -0.02), vec3(0.1, 0.1, 0.1)), 0.1);
    		//Piernas
    	  	lBody = opSmoothUnion(lBody, sdEllipsoid( opMirrorX(pos) - vec3(0.15, 0.13, 0.0), vec3(0.08 , 0.1, 0.08)), 0.1);
    		//Pies
    	  	lBody = opSmoothUnion(lBody, sdEllipsoid( opMirrorX(pos) - vec3(0.15, -0.0025, -0.03), vec3(0.036 , 0.035, 0.09)), 0.02);
    		//Brazos
    		lBody = opSmoothUnion(lBody, sdEllipsoid( rotation(Y_AXIS, 0.6) * rotation(X_AXIS, -0.8) * rotation(Z_AXIS, 0.5) * (opMirrorX(pos) - vec3(0.121, 0.36, -0.10)), vec3(0.05, 0.14, 0.032)), 0.01);		
    
    //Head
    vec3 lHeadPos = pos - vec3(0.0, 0.56, 0.0);
    vec3 lMirrorHeadPos = opMirrorX(pos) - vec3(0.0, 0.56, 0.0);
    		//Cabeza
    float   lHead = sdEllipsoid( lHeadPos, vec3(0.18, 0.19, 0.17));
    		//Morro
    	    lHead = opSmoothUnion(lHead, sdEllipsoid( rotation(X_AXIS, 0.8) * (lHeadPos - vec3(0.0, -0.02, -0.13)), vec3(0.12, 0.08, 0.06)), 0.04);
    		//Orejas
    		lHead = opSmoothUnion(lHead, sdEllipsoid( rotation(Z_AXIS, 0.6) * (lHeadPos - vec3(0.17, 0.22, 0.0)), vec3(0.04, 0.15, 0.034)), 0.02);
            lHead = opSmoothUnion(lHead, sdEllipsoid( rotation(Z_AXIS, -1.2) * (lHeadPos - vec3(-0.22, 0.20, 0.0)), vec3(0.04, 0.15, 0.034)), 0.02);
    
    float lEarsCutter = sdTorus( rotation(X_AXIS, M_PI * 0.5) * (lHeadPos - vec3(-0.02, 0.15, 0.0)), vec2(0.34, 0.07) );
    lEarsCutter = max(lHead, lEarsCutter);
    //Head + Body
    lBody = opSmoothUnion(lBody, lHead, 0.006);
    
    //Ears black
    res = opU( res, vec2( lBody, 2.0 ) );
    
    if(pos.y > 0.7)
    {
    	res = opU( res, vec2( lEarsCutter, 4.0 ) );
    }
    
    
    //Morrito black
    float lMorrito = sdEllipsoid( lHeadPos - vec3(0.0, 0.02, -0.19), vec3(0.02, 0.01, 0.01));
    float lMouth = sdEllipsoid( lMirrorHeadPos - vec3(0.02, -0.01, -0.198), vec3(0.03, 0.011, 0.01));
    	  lMouth = max(lMouth, -sdEllipsoid( lMirrorHeadPos - vec3(0.02, -0.006, -0.198), vec3(0.03, 0.011, 0.012)));
    	  lMouth = max(lMouth, lHead);
    lMorrito = min(lMorrito, lMouth);
    res = opU( res, vec2( lMorrito, 4.0 ) );
    
    //Mofletes
    float lMofletes = sdSphere( lMirrorHeadPos - vec3( 0.15, 0.02, -0.1), 0.04 );
    lMofletes = max(lMofletes, lHead);
	res = opU( res, vec2( lMofletes, 3.0) );
    
	//Eyes
    float lEyes = sdSphere( lMirrorHeadPos-vec3( 0.077, 0.07, -0.13), 0.028 );
    lEyes = max(lEyes, lHead);
	res = opU( res, vec2( lEyes, 4.0) );
    float lEyesWhite = sdSphere( lMirrorHeadPos-vec3( 0.073, 0.075, -0.13), 0.019 );
    lEyesWhite =  max(lEyes, lEyesWhite);
    res = opU( res, vec2( lEyesWhite, 5.0) );
    
    //Back marks
    float 	lBackMarks = sdEllipsoid( lHeadPos - vec3(0.0, -0.13, 0.18), vec3(0.2, 0.03, 0.1));
    		lBackMarks = min(lBackMarks, sdEllipsoid( lHeadPos - vec3(0.0, -0.25, 0.18), vec3(0.2, 0.03, 0.1)));
    		lBackMarks = max(lBackMarks, lBody);
    res = opU( res, vec2( lBackMarks, 6.0) );
    
    
    //Tail
    mat3 lTailAnimRot = rotation(Y_AXIS, sin(iTime*0.8) * 0.4);
    vec3 lTailPos = rotation(X_AXIS, 0.22) * lTailAnimRot * (pos - vec3(0.0, 0.18, 0.18));
    
    float 	lTail = 			sdCone( lTailPos, vec3(0.0, 0.00, 0.00), vec3(0.0, 0.00, 0.14), 0.01, 0.02);
	    	lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.00, 0.12), vec3(0.0, 0.1, 0.13), 0.02, 0.03));
    		lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.08, 0.1),  vec3(0.0, 0.08, 0.25), 0.025, 0.04));
    		lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.05, 0.22), vec3(0.0, 0.2, 0.22), 0.035, 0.045));
    		lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.16, 0.20), vec3(0.0, 0.16, 0.37), 0.04, 0.05));
    		lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.12, 0.33), vec3(0.0, 0.36, 0.34), 0.04, 0.06));
    		lTail = min(lTail, 	sdCone( lTailPos, vec3(0.0, 0.34, 0.28), vec3(0.0, 0.36, 0.57), 0.05, 0.072));
    float lBoxCutter = sdBox( opMirrorX(lTailAnimRot * (pos - vec3(0.0, 0.0, 0.2))) - vec3(0.1, 0.4, 0.4), vec3(0.093,0.4,0.4) );
    lTail = max(lTail, -lBoxCutter);
    res = opU( res, vec2( lTail, 2.0) );
    //res = opU( res, vec2( lBoxCutter, 4.0) );
    float   lTailBrown = sdCone( lTailPos, vec3(0.0, 0.00, 0.00), vec3(0.0, 0.00, 0.15), 0.02, 0.02);
    lTailBrown = max(lTailBrown, -lBoxCutter);
    lTailBrown = max(lTailBrown, lTail);
    res = opU( res, vec2( lTailBrown, 6.0) );
    
    return res;
}

// Function 4912
float scene(vec3 p) {
#ifdef HQ
    vec4 f0_0=sin(p.y*vec4(-.457,-1.677,4.049,-.637)+p.z*vec4(-4.147,3.464,-.490,-3.429)+p.x*vec4(.881,-2.806,-2.436,2.944)+vec4(-5.805,-5.301,2.820,4.142));
    vec4 f0_1=sin(p.y*vec4(-3.478,-1.759,-.866,-1.437)+p.z*vec4(-2.949,.345,-2.974,3.582)+p.x*vec4(-2.618,-.577,-2.612,-1.013)+vec4(5.642,1.587,3.873,-6.802));
    vec4 f0_2=sin(p.y*vec4(1.627,3.407,-2.026,4.314)+p.z*vec4(1.562,1.503,.845,-1.547)+p.x*vec4(1.282,-.772,.203,.748)+vec4(.520,-2.268,2.342,-7.744));
    vec4 f0_3=sin(p.y*vec4(.163,-3.674,.545,1.558)+p.z*vec4(.160,-2.532,-4.114,-2.112)+p.x*vec4(-1.901,-.462,-1.025,-.160)+vec4(5.351,6.056,-3.355,-6.112));
    vec4 f0_4=sin(p.y*vec4(3.969,2.343,1.534,-1.648)+p.z*vec4(-4.982,-3.768,3.133,-.045)+p.x*vec4(-1.942,.726,-2.290,-3.270)+vec4(-4.753,-4.248,-5.483,6.229));
    vec4 f0_5=sin(p.y*vec4(2.772,-3.577,-4.241,-2.440)+p.z*vec4(1.451,4.102,.975,-1.648)+p.x*vec4(-.684,1.291,.855,-2.203)+vec4(-1.037,.725,-7.480,6.271));
    vec4 f0_6=sin(p.y*vec4(-1.958,-2.650,-.485,3.993)+p.z*vec4(-3.058,4.974,1.612,2.065)+p.x*vec4(3.693,-2.088,-.722,.334)+vec4(-7.137,1.341,-4.161,7.088));
    vec4 f0_7=sin(p.y*vec4(3.846,.969,1.813,3.714)+p.z*vec4(.027,-.803,-.495,.809)+p.x*vec4(-2.879,-2.035,1.320,1.097)+vec4(-2.257,.642,1.640,4.828));
    vec4 f1_0=sin(mat4(.272,.286,-.836,.225,-.528,.223,-.070,.105,-.109,-.375,-.132,-.487,-.034,-.162,-.318,-.176)*f0_0+
        mat4(.473,.155,-.052,-.322,.021,.586,.169,-.252,.674,-.426,.083,.371,.049,.015,-.064,-.241)*f0_1+
        mat4(-.159,-.157,-.191,-.698,-.125,-.270,-.172,-.397,.549,.006,.055,-.315,-.525,-.206,-.234,-.058)*f0_2+
        mat4(.551,.135,.127,-.437,-.890,-.146,.135,.445,.223,.580,.463,-.107,.414,-.400,-.480,.162)*f0_3+
        mat4(.078,-.424,-.198,.078,.561,-.354,.128,-.158,-.498,.302,.244,.851,.153,.558,-.804,.269)*f0_4+
        mat4(-.471,.063,.534,-.515,-.569,.494,-.136,-.581,-.501,-.035,.157,.054,.054,-.170,-.261,.202)*f0_5+
        mat4(.053,-.073,.461,.571,-.062,.687,.291,.507,.100,.062,-.050,-.151,.684,-.173,-.243,.036)*f0_6+
        mat4(.549,-.623,.132,-.026,-.503,.302,-.312,-.204,-.243,.438,.336,.438,-.562,-.806,.267,.176)*f0_7+
        vec4(-1.535,2.191,-2.234,-.635))/1.0+f0_0;
    vec4 f1_1=sin(mat4(.242,.283,-.005,.154,.514,-.006,.523,.253,.288,-.543,-.118,-.213,.687,.918,-.159,-.013)*f0_0+
        mat4(-.208,.486,.262,-.969,.033,-.113,.474,.020,1.202,.170,-.124,-.182,-.633,.313,-.120,.138)*f0_1+
        mat4(-.089,.145,.023,.115,-.377,.066,-.401,-.015,.392,.242,.347,-.383,-.062,-.295,.350,.809)*f0_2+
        mat4(.345,.274,-.057,-.216,.236,-.091,-.144,.281,-.443,-.226,-.178,.287,.483,.228,.258,-.414)*f0_3+
        mat4(.332,.281,-.011,.299,.083,-.233,.073,-.503,.704,.399,.427,.829,-.261,-.084,.432,-.561)*f0_4+
        mat4(.354,.152,.086,.116,.334,.246,-.054,.338,-.485,-.043,-.305,-.327,-.437,-.259,-.377,-.536)*f0_5+
        mat4(.533,-.096,.047,-.237,-.036,-.130,-.218,-.243,-.404,-.176,.145,.033,-.497,.144,.376,-.603)*f0_6+
        mat4(.140,-.270,-.010,-.044,-.418,.086,.438,.151,-.144,-.439,-.084,.292,.537,-.275,.415,.305)*f0_7+
        vec4(.589,1.519,1.533,.737))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.335,.386,.288,-.402,.296,.581,.423,-.606,-.348,-.128,.067,-.344,-.412,.200,-.016,-.103)*f0_0+
        mat4(-.394,.031,.435,.375,-.003,-.154,-.112,-.120,.502,.197,.338,.268,.096,-.744,.030,-.054)*f0_1+
        mat4(.183,.030,.540,.219,-.239,.188,.393,-.232,-.021,.051,.316,.219,.060,-.020,-.233,.104)*f0_2+
        mat4(-.348,-.315,.937,.163,.284,.874,-.296,.040,.205,.485,.210,-.301,-.096,-.006,.205,.555)*f0_3+
        mat4(.138,-.197,-.159,-.265,-.403,.191,-.202,.224,-.036,-.125,-.564,.112,-.349,.457,-.271,-.259)*f0_4+
        mat4(-.159,-.443,.239,-.305,.316,.056,.302,-.265,-.787,.187,.214,-.355,-.283,-.092,-.342,.247)*f0_5+
        mat4(.221,-.370,-.430,.049,-.087,-.340,-.852,-.121,-.091,.064,.196,-.146,-.223,-.228,.137,-.153)*f0_6+
        mat4(.432,-.247,-.005,-.058,-.497,.125,-.722,-.155,.179,.488,-.221,-.049,.375,.150,-.487,.608)*f0_7+
        vec4(.509,-.969,-.495,.896))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.400,-.322,-.558,-.307,-.172,.343,.052,.273,-.137,-.248,-.475,-.202,.222,.350,.979,.003)*f0_0+
        mat4(.212,-.570,.204,-.076,-.064,.045,.158,-.103,.392,.565,-.070,.592,.306,.408,-.147,.456)*f0_1+
        mat4(-.328,-.629,.515,-.176,.060,-.023,-.092,-.163,-.070,-.440,.195,-.380,.460,.351,-.636,-.562)*f0_2+
        mat4(.510,.024,-.290,.423,-.084,.674,.159,-.035,-.051,-.707,-.331,-.590,.170,-.364,.265,-.111)*f0_3+
        mat4(.414,-.357,-.371,-.120,-.312,.793,.267,.229,-.189,.507,-.178,-.342,-.616,-.032,-.135,-.347)*f0_4+
        mat4(.114,.032,.026,.117,-.164,.321,.104,-.001,-.071,-.323,-.031,-.962,.379,-.604,-.504,-.076)*f0_5+
        mat4(-.331,.287,-.035,-.203,-.309,-.323,-.246,-.585,.144,.379,-.087,-.656,.141,-.721,.152,-.073)*f0_6+
        mat4(.683,.433,.333,.450,.056,-.617,.235,-.154,-.082,-.076,.061,-.010,-.484,.444,-.164,-.190)*f0_7+
        vec4(2.154,.240,-1.468,-1.893))/1.0+f0_3;
    vec4 f1_4=sin(mat4(-.013,.184,-.221,-.351,-.018,.070,.735,.139,.048,-.423,.417,.003,-.538,.037,-.375,.381)*f0_0+
        mat4(-.654,.875,-.088,-.596,-.292,-.093,-.073,.218,-.145,.181,-.523,-.184,.215,-.531,.401,.237)*f0_1+
        mat4(-.220,-.154,-.293,-.390,-.390,.211,-.597,.367,.120,.143,.122,-.247,.108,-.562,.508,-.464)*f0_2+
        mat4(-.359,.615,-.190,-.075,.232,-.690,-.244,.942,.096,-.178,.090,-.414,.039,.319,.213,-.002)*f0_3+
        mat4(-.348,-.457,1.317,1.026,-.368,.738,-.711,-.446,-.070,.162,.005,-.073,-.004,.327,-.388,.077)*f0_4+
        mat4(-.730,.051,.042,.687,-.053,.004,-.713,.266,.229,.638,-.633,-.049,-.042,-.265,.594,.067)*f0_5+
        mat4(.083,-.019,.167,-.500,.181,-.291,.302,-.031,-.013,-.220,.255,-.312,.192,.497,.673,-.563)*f0_6+
        mat4(-.178,.234,.419,-.157,.087,.173,.022,.158,.088,-.022,-.188,-.321,-.268,-.261,.407,-.227)*f0_7+
        vec4(-.231,-.374,-1.509,.954))/1.0+f0_4;
    vec4 f1_5=sin(mat4(-.279,.033,-.611,.412,-.710,.354,.298,-.313,-.315,.078,-.012,-.329,-.096,.364,-.016,.461)*f0_0+
        mat4(-.273,-.669,-.247,-.054,.160,-.010,.038,-.090,-.435,.030,.626,.198,.573,.219,-.087,-.392)*f0_1+
        mat4(-.471,-.365,-.128,.135,-.219,.203,-.225,-.299,-.410,-.036,.342,.063,-.511,-.751,-.093,-.150)*f0_2+
        mat4(.631,-.279,-.420,.127,.069,.495,.091,-.232,.064,-.382,-.178,.259,-.601,-.272,.362,-.077)*f0_3+
        mat4(.024,.098,.620,-.544,.382,.127,.184,.104,-.666,.293,.023,.341,-.838,-.227,-.023,.069)*f0_4+
        mat4(.066,.700,.022,.063,.578,.289,-.350,-.239,.408,.512,-.306,-.100,.275,.535,.160,-.117)*f0_5+
        mat4(.057,.237,.140,.648,-.503,.144,-.241,.203,.499,.099,.519,-.151,-.082,-.356,-.007,.190)*f0_6+
        mat4(-.062,-.293,.211,.004,.313,.322,.020,-.182,-.160,.095,.122,-.196,.657,-.471,.298,.104)*f0_7+
        vec4(3.035,-2.163,1.582,1.699))/1.0+f0_5;
    vec4 f1_6=sin(mat4(-.408,.708,-.781,.115,-.177,.531,-.359,-.084,-.262,.014,.192,-.106,.035,.267,.404,.637)*f0_0+
        mat4(-.323,.011,.451,-.791,-.202,-.186,-.570,.289,.519,.228,-.447,.377,-.247,-.443,-.498,.114)*f0_1+
        mat4(.114,-.212,-.475,-.144,-.426,.240,-.050,.218,.541,.311,-.498,.091,-.497,.137,.666,-.750)*f0_2+
        mat4(.163,.189,.319,.358,-.117,.318,-.630,.540,-.137,.243,-.013,.303,.494,.200,-.293,-.536)*f0_3+
        mat4(.263,-.132,.625,-.562,.914,-.425,.055,.628,.375,.883,-.755,.401,-.181,.348,.485,.157)*f0_4+
        mat4(.040,.297,-.796,-.255,-.692,.385,.012,-.198,-.046,.112,-1.163,.509,.280,-.017,.603,-.080)*f0_5+
        mat4(.250,.092,-.056,-.032,.676,.168,.274,-.355,-.038,-.106,.286,-.058,-.396,-.402,1.009,-.907)*f0_6+
        mat4(.035,-.263,.757,-.595,-.119,.009,-.866,.246,-.037,.167,-.362,.392,.770,.093,.336,-.486)*f0_7+
        vec4(1.168,.861,1.560,.918))/1.0+f0_6;
    vec4 f1_7=sin(mat4(-.026,-.091,.321,-.773,.214,-.743,-.167,-.224,.746,.248,.389,-.127,.545,-.229,-.397,.345)*f0_0+
        mat4(.071,1.185,.260,-.667,.078,.163,.180,.178,.347,.012,.045,.070,.480,-.135,-.229,.131)*f0_1+
        mat4(-.303,-.360,-.544,.297,.205,.440,.132,-.199,.219,.036,-.003,.456,.354,-.556,.023,-.743)*f0_2+
        mat4(.172,.213,-.410,-.465,.056,-1.045,.101,.936,-.360,-.140,-.000,-.077,-.369,-.288,-.320,-.204)*f0_3+
        mat4(.319,-.863,-.065,.007,-.272,.556,.432,.044,.125,-.283,-.151,-.793,-.035,.380,-.334,-.043)*f0_4+
        mat4(-.118,.134,.009,-.127,-.149,-.318,.295,.623,-.584,.471,-.095,.146,-.060,.658,.004,-.327)*f0_5+
        mat4(-.210,.115,.590,-.576,-.309,.424,.079,-.160,-.360,.530,-.046,.077,-.168,.769,-.023,-1.103)*f0_6+
        mat4(-.104,-.547,-.269,-.229,.126,-.060,-.350,-.194,-.481,.164,.027,-.018,.539,-.552,-.317,-.366)*f0_7+
        vec4(.960,1.256,-1.505,-.841))/1.0+f0_7;
    vec4 f2_0=sin(mat4(.299,.197,-.114,.072,-.261,-.166,.014,-.014,.160,-.302,-.154,.519,.253,.282,-1.154,.915)*f1_0+
        mat4(-.744,-.657,-.126,.279,-.366,.085,-.190,-.109,.057,-.342,-.175,.355,.770,-.598,.121,-.640)*f1_1+
        mat4(-.661,.214,-.181,-.225,.223,-.003,-.189,-.068,.829,-.589,.366,-.377,-.343,.501,-.289,-.281)*f1_2+
        mat4(.176,.375,-1.081,.032,-.440,-.033,.137,-.135,-.391,.316,.308,-.238,.441,-.169,.923,.506)*f1_3+
        mat4(.663,.035,-.172,-.018,-1.014,.468,.423,.674,-.547,-.079,-.356,.093,-.434,-.254,.460,-.088)*f1_4+
        mat4(.376,-.092,-.383,-.428,.384,.305,-.774,.564,-.642,.419,-.173,-.682,.167,.768,-.486,.025)*f1_5+
        mat4(-.558,-.242,.279,-.868,.106,.060,-.841,-.169,-.030,.096,-.383,-.043,-.470,.279,-.540,.393)*f1_6+
        mat4(.691,.693,-.358,-.148,-.401,.879,-.906,.199,.173,.010,.012,-.827,.281,-.194,-.184,.465)*f1_7+
        vec4(-1.556,1.019,.309,.194))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-.350,1.253,-.136,.360,-.151,.287,.303,.636,-.190,-.407,.144,.133,.682,.108,.595,.651)*f1_0+
        mat4(1.090,-.303,-.131,.257,.414,.270,-.092,.182,-.586,-.066,-.007,-.192,-.283,-.343,-.021,-.207)*f1_1+
        mat4(.850,-.334,.258,-.541,.268,-.773,-.379,-.052,-1.140,.108,.663,.099,-.236,-.965,.050,.167)*f1_2+
        mat4(1.038,-1.131,.305,-.132,.252,.466,.091,.062,.577,-.275,-.413,.241,-.050,.649,-.233,.101)*f1_3+
        mat4(-.547,.388,-.076,.553,1.209,.185,-.598,.535,.813,-.861,-.438,.301,-.362,.400,.224,-.422)*f1_4+
        mat4(-.039,-.375,.262,.041,.084,-.871,-.063,-.123,-.176,-.273,-.163,-.268,.033,-.261,.348,.352)*f1_5+
        mat4(-.228,.200,.085,.175,-.526,-.240,.450,-.046,.089,.064,.479,-.116,.342,-1.206,.017,-.205)*f1_6+
        mat4(-.683,.193,.444,.123,.331,.074,.620,.299,-.363,-.504,.452,-.183,.148,-.785,.394,-.224)*f1_7+
        vec4(.049,.855,-1.814,-.238))/1.4+f1_1;
    vec4 f2_2=sin(mat4(.536,.587,-.097,-.073,-.461,-.462,.285,.355,-.481,.145,-.242,.201,.232,.053,-.097,.442)*f1_0+
        mat4(.246,.133,.043,.246,-.293,-.307,.282,-.069,-.527,.074,.293,.224,-.400,-.359,-.029,.116)*f1_1+
        mat4(.536,-.369,-.728,.503,.249,-.114,.017,-.208,-.182,-.038,-.379,-.804,.083,.077,-.193,-.072)*f1_2+
        mat4(.361,.018,.014,-.384,.052,-.111,.606,.460,.557,-.227,-.003,.153,-.484,-.425,.701,-.008)*f1_3+
        mat4(.332,.310,.223,-.169,.147,-.611,.033,-.013,.564,.026,-.064,-.113,.485,.242,.228,-.432)*f1_4+
        mat4(.526,.244,-.486,.161,-.131,.882,-.092,-.120,-.272,-.345,.129,.361,-.454,.029,.030,-.006)*f1_5+
        mat4(-.347,.603,-.217,.217,.140,.069,-.451,-.504,.004,.004,-.283,.222,-.203,.631,-.352,.497)*f1_6+
        mat4(-.361,-.067,.147,.377,.428,-.161,-.357,.579,-.133,-.353,-.049,-.114,.069,.345,-.334,.241)*f1_7+
        vec4(.367,-.439,1.643,1.025))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.804,-.782,1.165,-.725,-.246,-.050,-.387,-.677,-.080,.163,.340,-.153,-.504,-1.181,-.071,-2.046)*f1_0+
        mat4(.056,-.803,-.467,-.484,-.354,-.409,-.063,-.321,.286,-.048,.030,-.573,-.490,.237,.369,.547)*f1_1+
        mat4(.736,-.310,.142,-.051,.099,.763,-.173,.290,.274,-.381,.479,.893,-.432,.697,-.186,.545)*f1_2+
        mat4(.449,-.748,-.427,-1.234,.076,-.726,-.290,-.536,.935,-.422,.370,.090,.963,.227,-.629,-.399)*f1_3+
        mat4(-.588,-.173,-.103,-.136,.213,.229,-.820,.001,.287,-.081,-.612,-.411,-.453,.359,-.027,.655)*f1_4+
        mat4(-.542,-.857,.472,-.284,.565,.032,.298,-.703,-.639,.093,-.225,.041,.083,.820,.435,.162)*f1_5+
        mat4(-.073,-.436,.859,.351,.027,.096,-.315,-.121,-.391,-.645,.142,-.356,.552,.014,.059,-.174)*f1_6+
        mat4(.632,.549,.812,-.643,-.488,-.868,-.006,-.593,.327,-.322,.318,-.182,.304,.260,-.068,-.198)*f1_7+
        vec4(2.130,.814,1.575,2.609))/1.4+f1_3;
    vec4 f2_4=sin(mat4(-.001,.073,.684,-.693,.002,.011,.196,-.631,.005,.334,-.356,.081,.171,1.462,-.621,-.698)*f1_0+
        mat4(.597,-.142,-.720,-.838,.392,.514,-.243,.169,.426,-.465,-.041,-.908,-.496,.006,-.077,-.717)*f1_1+
        mat4(.603,-.489,.699,.043,.147,-.162,-.344,.798,-.925,-.949,-.116,.870,-.540,-.603,-.372,1.535)*f1_2+
        mat4(-.390,-.557,-1.003,-.516,-.027,.255,.956,-1.219,.087,-.234,.349,.039,.739,-.072,.450,-.208)*f1_3+
        mat4(-.886,.053,-.312,-.202,1.676,.710,-.314,.089,.586,.168,-.030,.084,.219,.032,1.016,.464)*f1_4+
        mat4(-.988,-.553,-.405,.394,.241,.164,.320,-.855,.155,.128,-.029,.270,-.218,-.315,.125,.260)*f1_5+
        mat4(-.087,.110,.485,.222,-.535,.133,-1.001,-.169,-.129,.527,-.324,-.302,.427,-.473,-.028,.093)*f1_6+
        mat4(-.676,.245,.690,-.193,.124,.161,-.337,-.787,.010,-.405,.105,.347,.428,.255,-.124,.699)*f1_7+
        vec4(-1.122,.262,.466,1.380))/1.4+f1_4;
    vec4 f2_5=sin(mat4(-.664,-.178,-.275,.334,.255,.214,.065,.301,.261,.771,.568,.161,-.526,-.892,.362,-.735)*f1_0+
        mat4(-.175,.120,-.537,.393,-.273,-.115,-.090,.054,.162,-.027,-.438,.091,.515,-.169,-.028,-.399)*f1_1+
        mat4(.221,.013,.059,-1.299,.550,.544,.436,.270,-.003,.714,.234,.340,.212,-.201,.043,.665)*f1_2+
        mat4(-.398,-.187,.003,-.817,-.911,-.343,.110,-.710,.320,.582,.298,.208,.822,.264,-.014,-.690)*f1_3+
        mat4(-.542,-.239,-.037,.288,.709,.105,-.129,-.607,.346,.161,-.026,.381,-.559,.358,-.673,.899)*f1_4+
        mat4(-.099,-.434,-.388,.205,-.230,.037,-.521,.185,.043,-.234,-.476,.332,-.109,.314,-.184,.143)*f1_5+
        mat4(-.302,.023,-.690,.509,-.154,-.280,-.144,.066,-.070,-.505,.164,-.923,.072,.478,.178,.171)*f1_6+
        mat4(-.492,-.066,-.484,-.307,-.356,-.418,-.409,-.728,.471,-.443,.003,-.794,.355,-.408,-.083,-.593)*f1_7+
        vec4(1.293,1.476,-2.465,.779))/1.4+f1_5;
    vec4 f2_6=sin(mat4(-.235,.889,-.728,-.325,-.532,.258,-.088,-.392,-.696,-.318,1.081,1.004,-.267,-.221,.330,-.316)*f1_0+
        mat4(.737,.054,.000,-.891,-.578,.201,-.382,.242,-.377,-.044,.031,.012,-.308,-.086,.670,.124)*f1_1+
        mat4(-.168,.163,-.561,.416,.244,-1.041,.689,.524,.531,.073,.167,-.668,-.661,-.734,.120,.241)*f1_2+
        mat4(.466,-.402,.426,.047,-.662,.218,-.735,.225,.545,-.381,-.024,.399,1.030,.988,.162,.292)*f1_3+
        mat4(-.004,-.031,-.265,-.089,.608,.023,-.302,.429,.168,-.371,.518,.374,-.196,-.098,-.479,.022)*f1_4+
        mat4(-.524,-.341,-.394,-.454,-.282,-.330,.164,.371,-.722,.041,-.416,-.178,-.632,-.159,.363,.592)*f1_5+
        mat4(.097,.637,-.176,-.115,.535,-.266,.485,-.081,.063,.192,-.003,-.294,-.014,-.226,.478,.656)*f1_6+
        mat4(-.433,-.025,-.610,-.057,-.236,-.479,-.216,-.344,.350,.329,.640,-.125,-1.277,-.214,-.256,.684)*f1_7+
        vec4(.047,.826,1.232,-.647))/1.4+f1_6;
    vec4 f2_7=sin(mat4(-.592,.476,.646,.073,.401,.763,-.417,-.220,-.266,-.521,.007,-.320,-.093,1.370,-.854,-.191)*f1_0+
        mat4(-.067,.686,-.709,.596,.245,.750,-.824,.137,-.351,1.162,-.595,-.158,.378,-.911,-.090,-.439)*f1_1+
        mat4(.214,.735,.276,.425,-.039,.270,.401,-.275,.021,-.779,.261,-.429,-.173,-.523,-.019,-.426)*f1_2+
        mat4(.195,.802,-.621,.203,-.266,.406,.020,-.050,.109,.370,.238,.285,.557,-.493,-.283,.040)*f1_3+
        mat4(.280,-.403,.118,-.014,.037,.410,-.385,.277,.241,.520,-.053,.248,-.228,-.679,.162,.541)*f1_4+
        mat4(-.285,.387,.095,-.062,-.145,.205,.422,-.047,.635,.684,-.314,.196,.294,-.696,.454,-1.002)*f1_5+
        mat4(-.114,-.569,.238,.278,.289,.399,-.316,.140,.558,-.069,-.633,-.154,.245,.477,.403,-.053)*f1_6+
        mat4(.093,.122,.565,-.336,-.524,.994,.256,-.195,.195,.036,.060,.670,-.100,.306,.507,-.624)*f1_7+
        vec4(1.502,-.102,1.739,.664))/1.4+f1_7;
    float d = dot(f2_0,vec4(.038,.038,-.079,-.057))+
        dot(f2_1,vec4(-.031,.051,.064,-.045))+
        dot(f2_2,vec4(-.022,-.045,.060,.053))+
        dot(f2_3,vec4(-.028,.019,.018,-.049))+
        dot(f2_4,vec4(-.062,-.043,.032,.021))+
        dot(f2_5,vec4(-.050,-.055,.049,.021))+
        dot(f2_6,vec4(.022,.054,-.031,-.042))+
        dot(f2_7,vec4(.051,-.036,-.060,-.046))+
        -0.103;
#else
    vec4 f0_0=sin(p.y*vec4(1.026,-2.818,2.722,-2.015)+p.z*vec4(1.985,2.198,4.116,-3.089)+p.x*vec4(2.305,-.184,3.339,2.463)+vec4(4.824,1.642,3.488,-6.207));
    vec4 f0_1=sin(p.y*vec4(2.085,-3.256,3.989,-4.321)+p.z*vec4(1.083,-1.116,.834,1.472)+p.x*vec4(1.097,.431,.002,-1.445)+vec4(-7.593,-5.675,3.609,-2.978));
    vec4 f0_2=sin(p.y*vec4(-1.512,2.104,2.273,.393)+p.z*vec4(.030,-3.560,-3.902,.731)+p.x*vec4(1.316,2.017,2.993,2.127)+vec4(-1.902,2.607,2.783,-.490));
    vec4 f0_3=sin(p.y*vec4(.162,-2.536,2.728,2.398)+p.z*vec4(-3.005,-3.234,-3.560,2.654)+p.x*vec4(-1.294,3.243,-3.988,-.656)+vec4(4.229,-6.442,7.018,-5.828));
    vec4 f1_0=sin(mat4(.616,-.018,-.204,.151,-.099,-.635,.015,-.793,.480,.259,.240,-.168,-.071,.215,-.506,-.184)*f0_0+
        mat4(.064,-1.173,-.104,-.888,.150,.052,-.679,-.248,-.210,.068,-.192,.268,-.881,-.059,.598,-.022)*f0_1+
        mat4(-.428,-.407,-.281,-.472,-.329,-.161,-.357,.287,.285,-.011,.237,-.434,.106,.432,-.213,.337)*f0_2+
        mat4(-.214,.098,.375,.196,-.033,-.213,.526,-.107,.247,-.041,-.026,-.211,.305,.305,.749,.222)*f0_3+
        vec4(.459,.442,1.555,-1.978))/1.0+f0_0;
    vec4 f1_1=sin(mat4(-.038,-.015,-.495,.157,.151,-.210,-.086,.274,.382,.288,.502,-.218,.567,-.231,.127,-1.170)*f0_0+
        mat4(.862,-.545,.178,-.047,.456,-.801,.236,.256,-.023,.358,-.374,.124,.051,-.286,.606,-.488)*f0_1+
        mat4(-.252,-.881,-.475,.868,-.648,.635,-.147,.039,.310,-.457,.103,.783,.088,.296,-.366,.405)*f0_2+
        mat4(.216,.305,.590,-.476,.251,.003,-.012,.567,.143,.152,.118,-.105,.225,.482,.325,-.498)*f0_3+
        vec4(-2.439,1.759,.413,1.178))/1.0+f0_1;
    vec4 f1_2=sin(mat4(.083,-.238,.418,.866,-.041,.134,-.293,.162,.195,-.172,.479,.279,.030,-.798,-.055,-.385)*f0_0+
        mat4(-.337,.513,-.348,-.341,-.425,-.392,-.152,-.053,.337,.339,-.236,.446,.520,-.311,.171,.036)*f0_1+
        mat4(.169,.524,-.446,.185,.435,-.320,.014,-.431,-.110,.057,.114,.104,.151,-.326,-.341,.057)*f0_2+
        mat4(.258,.520,-.360,-.507,-.565,.777,.771,.207,.266,.175,-.007,.155,.066,-.256,.674,-.278)*f0_3+
        vec4(.692,-2.006,.605,1.886))/1.0+f0_2;
    vec4 f1_3=sin(mat4(-.601,.328,-1.203,.443,-.012,.628,-.319,.496,.066,.149,-.024,.185,.697,-.084,-.340,.309)*f0_0+
        mat4(.444,-.295,.203,-.300,-.599,-.065,.357,.421,-.316,.290,.338,-.974,-.263,.476,-.601,.114)*f0_1+
        mat4(-.396,.260,-1.048,1.051,-.002,-.618,1.178,.220,.179,.363,-1.779,-.275,-.597,.621,-.148,1.264)*f0_2+
        mat4(.505,.473,-.267,-.893,-.015,-.089,.292,.108,-.115,.455,.048,-.370,.153,-.052,-.105,-.156)*f0_3+
        vec4(-.362,-2.135,1.362,2.107))/1.0+f0_3;
    vec4 f2_0=sin(mat4(-.108,.046,-.876,.200,2.003,-.929,-.812,.061,-.205,-.162,-.062,-.424,-.671,.053,-.027,-1.169)*f1_0+
        mat4(.401,-.491,-.433,.024,.391,-.602,.027,.141,.084,.231,.164,1.687,-.328,-.392,-.405,-.448)*f1_1+
        mat4(1.366,.072,.815,-.238,-.353,.059,.081,.289,-.381,-.143,.063,-.482,.331,-.262,-.042,-.536)*f1_2+
        mat4(.742,.013,-.090,.214,.965,-.328,-.486,.832,.749,-.389,-.380,.463,.142,-.509,.058,.458)*f1_3+
        vec4(.319,-1.797,-3.946,2.354))/1.4+f1_0;
    vec4 f2_1=sin(mat4(-.901,.045,.626,.022,-.919,-.736,-.311,-.523,-.043,-.148,-.009,.042,-.210,.139,.402,.049)*f1_0+
        mat4(-.403,1.005,.366,-.348,-.658,1.176,.076,1.622,.158,.074,-.305,.360,.176,-.165,-.427,.322)*f1_1+
        mat4(-.368,-.052,.547,-.593,.239,-.710,.058,-.071,-.304,.963,.942,-.396,.959,.642,.588,.158)*f1_2+
        mat4(.027,.425,-.506,.673,.074,-.433,.305,-.094,-.097,-.140,-.414,.164,-.718,.336,-.072,1.248)*f1_3+
        vec4(3.302,-.626,2.399,.960))/1.4+f1_1;
    vec4 f2_2=sin(mat4(.067,-.710,.566,-.350,.474,-1.658,.394,-.228,-.193,-.529,.162,.136,-.248,.514,.461,.200)*f1_0+
        mat4(.521,-.247,.418,.516,-.259,-.562,-.762,.694,-.466,-.995,-.117,-.104,.218,-.690,-.188,-.066)*f1_1+
        mat4(-.086,-.711,.870,-.246,-.903,.023,-.924,-.999,.381,1.356,.560,.486,-.266,-.545,.013,.485)*f1_2+
        mat4(-.555,-1.032,-.846,.147,.632,-.639,.865,-.375,.206,-.524,.470,.167,-.058,.389,-.726,-.333)*f1_3+
        vec4(.737,1.081,2.460,-1.769))/1.4+f1_2;
    vec4 f2_3=sin(mat4(.152,-.170,.169,.230,-.444,-1.104,-.129,-.434,-.412,.056,.384,-.214,-.392,.214,1.083,-.908)*f1_0+
        mat4(.155,-.554,-1.008,1.282,.338,.242,.692,1.308,-.946,.613,-.613,-.233,.346,.860,2.130,-.937)*f1_1+
        mat4(.029,-.879,-.821,.021,-.339,.004,.055,.335,.599,.089,-.547,.900,.612,-.163,-.296,.752)*f1_2+
        mat4(.499,-.043,.340,.503,-.017,-.651,-.788,-.276,-.218,-.556,-.330,.034,-.467,.793,1.013,.173)*f1_3+
        vec4(-.810,-3.040,.184,.585))/1.4+f1_3;
    vec4 f3_0=sin(mat4(.302,-.619,.520,-.605,.214,.232,-.186,.454,-.676,-.339,-.069,-.085,-.486,-.602,.372,-.331)*f2_0+
        mat4(.211,-.752,-.692,-.366,-.303,-.612,-.320,-.228,-1.159,-.052,.401,.247,.531,.646,.195,-1.163)*f2_1+
        mat4(-.668,.193,-.316,.997,.111,-.358,.760,.531,-.562,.260,-.041,-.048,.004,-.248,-.617,.203)*f2_2+
        mat4(-.943,.378,.159,.378,.786,-.450,-.501,-.590,-.367,-.410,-.656,-.765,.286,.007,-.440,-.555)*f2_3+
        vec4(-2.357,.938,1.189,-.314))/1.7+f2_0;
    vec4 f3_1=sin(mat4(-.968,.162,-1.253,1.270,.314,-.026,.246,.121,.136,.430,-.015,-.607,-.104,-.088,-.274,.019)*f2_0+
        mat4(-.458,.505,.188,.318,.301,.162,-.076,.257,-1.302,.169,-.836,1.470,-.596,-.013,-.261,-.647)*f2_1+
        mat4(-.305,.344,-.272,.446,-.615,.294,-1.140,1.128,.523,-.677,.353,-1.127,.107,.248,.458,1.042)*f2_2+
        mat4(.419,.286,.121,-.344,-.690,.129,-.593,.176,.467,-.050,.539,-.254,-.178,-.974,.621,-.574)*f2_3+
        vec4(-1.771,1.195,.419,1.457))/1.7+f2_1;
    vec4 f3_2=sin(mat4(-.196,.018,.568,-.655,.013,-.197,.565,.914,.404,.044,-1.165,-.376,.766,-.706,-.128,-.291)*f2_0+
        mat4(1.325,-1.039,-.815,-1.138,-.174,.074,-.990,-.069,-.086,.533,-.902,-.889,.371,-.644,.623,-.444)*f2_1+
        mat4(.372,.684,.173,-.727,.254,-.428,-.049,-.924,-.313,.344,.449,.288,.150,-.065,-1.214,-1.119)*f2_2+
        mat4(-.392,1.185,-.040,.143,.823,-.633,-1.146,-1.212,-.073,-.010,-.326,.492,-.005,.036,-.390,.613)*f2_3+
        vec4(-.080,2.674,-.934,.651))/1.7+f2_2;
    vec4 f3_3=sin(mat4(1.316,.176,.887,.394,.340,.618,-1.671,.148,-.470,.053,-.182,-.230,-.273,-.333,-.121,-.675)*f2_0+
        mat4(-.899,.030,.442,-.344,-.015,.480,.096,.543,.064,1.055,.764,.164,.936,-.616,-.225,.126)*f2_1+
        mat4(-.853,1.663,2.048,.541,-.280,-.060,.020,.789,.305,.032,1.448,.540,-.808,.123,-.170,.651)*f2_2+
        mat4(-.544,.315,-.462,.542,.764,-.397,.292,-.199,.298,-.669,-.331,-.787,.623,-.746,-1.273,-.949)*f2_3+
        vec4(1.684,-.713,1.876,.277))/1.7+f2_3;
    float d = dot(f3_0,vec4(-.039,-.078,.084,-.086))+
        dot(f3_1,vec4(-.066,.090,-.092,.029))+
        dot(f3_2,vec4(.103,-.073,-.042,.095))+
        dot(f3_3,vec4(.067,.050,.027,.034))+
        0.033;
#endif
    d = opSubtraction(d, d-0.02);
    d = opIntersection(d, sdBox(p, vec3(0.75)));
    d = opIntersection(d, opNoisyBox(p+vec3(0.,0.,sin(iTime)+0.5), vec3(1.)));
    return d;
}

// Function 4913
float map001(vec2 p)
{
	float h;
    h = line(p, vec2(-asp, -0.8), vec2(-asp*0.8, -0.8));
    h = min(h, line(p,  vec2(-asp*0.8, -0.8),  vec2(-asp*0.8, 0.2)));
    h = min(h, line(p,  vec2(-asp*0.8, 0.2),   vec2(-asp*0.5, 0.2)));
    h = min(h, line(p,  vec2(-asp*0.5, 0.2),   vec2(-asp*0.5, -0.8)));
    h = min(h, line(p,  vec2(-asp*0.5, -0.8),  vec2(-asp*0.05, -0.8)));
    h = min(h, line(p,  vec2(-asp*0.05, -0.8), vec2(asp*0.2, -0.4)));
    h = min(h, line(p,  vec2(asp*0.2, -0.4),   vec2(asp*0.45, -0.8)));
    h = min(h, line(p,  vec2(asp*0.45, -0.8), vec2(asp, -0.8)));
    return h;
}

// Function 4914
float GetDist(vec3 p  ) 
{	

    float d, dif1, dif2;
    vec2 res;
    vec3 pp,p1, p2,p3;
    
    res = vec2(9999, 0);
    
  
    vec3 u=p;
    
    
    float cx=30.0;
    float cy=3.0;
    float cz=20.0;
    
    
   
    u.z = mod(u.z+0.5*cz,cz)-0.5*cz;
    
    
    float sdc1= sdCylinderXY( u- vec3(0.0,0.0,0.0), vec2(10.0,20.0) );
    float sdc2= sdCylinderXY( u- vec3(0.0,0.0,0.0), vec2(8.0,21.0) );
    float dif= differenceSDF(sdc1, sdc2);
    res =opU(res, vec2(dif,100.0)); 
    
    
    vec3 q=p;
   
    float sds1= sdSphere(q- vec3(0.0,0.0,0.0+ itime) , 6.0 );
    res =opU(res, vec2(sds1,301.0)); 
    
    
    
    res =opU(res, vec2(1.0,0.0)); 
    
    
    d = res.x;
    mObj.dist = res.x;
    mObj.tipo = res.y;
    
    return d;
}

// Function 4915
float scene(vec3 p)
{
    mat=0;
    
    const float K =  .75;
    const float KK = K+.1;
    const float L = K*2.;
    const float J = K*.5;
    
    float ground = p.y+1.;
    
    // mirror
    p.xz=abs(p.xz);
    p.xz=vec2(max(p.x,p.z),min(p.x,p.z));

    // can't actually see this in the final render, whoops
    float column = min(
        max(
	        sdBox3(p,vec3(0,11.25,0),vec3(12,22.5,9)),
	        -sdBox3(p,vec3(6,11.25,0),vec3(3,23,5))
	    ),
        sdCylinder(p,vec3(4.5,11.25,4.5),vec2(1.5,22.5))
	);

    // backup p and loop the space for the support columns
    vec3 sp = p;
    sp.z = abs(abs(abs(sp.z)-2.5)-2.5)-2.5;
    
    // vertically mirror p
    p.y=abs(p.y-13.)+13.;
    
    float trim4 = min(
        sdScallopBox(p,vec3(0,15.-J,0),vec3(45,K,17)),
        min(
        	sdScallopBox(p,vec3(0,15.-J,0),vec3(35,K,25)),
        	sdScallopBox(p,vec3(0,15.-J,0),vec3(29,K,29))
        )
    );
    
    float trim5 = min(
        sdScallopBox(p,vec3(0,18.-J,0),vec3(35,K,17)),
    	sdScallopBox(p,vec3(0,18.-J,0),vec3(25,K,25))
    );
    
    float trim6 = sdScallopBox(p,vec3(0,21.-J,0),vec3(25,K,17));

    float trimProxy = min(
        min(
        	sdBox3(p,vec3(0,15.-J,0),vec3(45,KK,17)),
        	sdBox3(p,vec3(0,15.-J,0),vec3(35,KK,25))
        ),
        min(
            min(
        		sdBox3(p,vec3(0,15.-J,0),vec3(29,KK,29)),
        		sdBox3(p,vec3(0,18.-J,0),vec3(35,KK,17))
            ),
            min(
    			sdBox3(p,vec3(0,18.-J,0),vec3(25,KK,25)),
				sdBox3(p,vec3(0,21.-J,0),vec3(25,KK,17))
            )
        )
    );

    // backup p and modulo it for the slats
    vec3 qp = fract(p-vec3(.5,.2,.5))-.5;
    float trimSlats = max(trimProxy, sdBox2(qp,vec3(1,.4,.4)));
    
    float mirror4 = min(
        sdBox3(p,vec3(0,13,0),vec3(45,2.+2.-L,17)),
        min(
        	sdBox3(p,vec3(0,13,0),vec3(35,2.+2.-L,25)),
        	sdBox3(p,vec3(0,13,0),vec3(29,2.+2.-L,29))
        )
    );
    
    float mirror5 = min(
        sdBox3(p,vec3(0,16.+.5-J,0),vec3(35,2.+1.-K,17)),
    	sdBox3(p,vec3(0,16.+.5-J,0),vec3(25,2.+1.-K,25))
    );
    
    float mirror6 = sdBox3(p,vec3(0,19.+.5-J,0),vec3(25,2.+1.-K,17));
    
    float trim = min(trim4, min(trim5, trim6));
    float mirror = min(mirror4, min(mirror5, mirror6));
    
    p.xz = fract(p.xz)-.5;
    float mirrorPoles = sdBox2(p,vec3(.02,100,.02));
	mirrorPoles = min(mirrorPoles, max(mirror,trim-.04));
    
    float mirrorEdges = max(mirror,mirrorPoles)-.01;
    float mirrorPanes = max(mirror,-mirrorPoles)+.01;
    
    float support = sdBox3(sp,vec3(0,8,0), vec3(48,8,.5));
    support = max(support, dot(vec4(sp,1),vec4(normalize(vec3(-5,8,0)),2.)));
    support = min(support, sdBox3(sp,vec3(0,5,0),vec3(25,2,.5)));
    support = min(support, sdBox3(sp,vec3(7.5,5,0),vec3(25,2,.5).bgr));
    support = max(support, dot(vec4(sp,1),vec4(normalize(vec3(2,-3,0)),-4.)));
    
	trim = max(trim, -trimSlats);
    
    float best = min(min(min(trim,column), min(mirrorEdges,mirrorPanes)), min(support,ground));
    
    if (best == mirrorPanes)
		mat = matMirror;
    else if (best == mirrorEdges)
        mat = matBlack;
    else
        mat = matDiffuse;
        
    return best;
}

// Function 4916
vec2 map( in vec3 pos )
{
    vec2 res = vec2( 1e10, 0.0 );
	
    
    vec3 lHeadStart = rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) * (pos - vec3(-0.03, 0.7, 0.0)); // rotation(X_AXIS, -0.1) * rotation(Z_AXIS, -0.1) *
    //vec3 lHeadStart = pos - vec3(0.0, 0.7, 0.0); 
    //Main Head
    float   lHead = sdEllipsoid( lHeadStart, vec3(0.165, 0.15, 0.165));
    lHead = opSmoothUnion(lHead, sdEllipsoid( lHeadStart - vec3(0.0, -0.15, 0.00), vec3(0.15, 0.2, 0.15)), 0.1);
    float   lTorso = sdEllipsoid( pos - vec3(0.0, 0.26, 0.0), vec3(0.2, 0.22, 0.18));
    //Ears
    vec3 lEarsPos = rotation(Z_AXIS, 0.22) * opMirrorX(lHeadStart * vec3(1.0, 0.9, 1.0));
    float lEars = sdRoundCone( lEarsPos - vec3(0.07, 0.14, 0.0), 0.04, 0.075, 0.15 );
    
	float lEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.11), vec3(0.1, 0.15, 0.1));
    	  lEarsCutter =  min(lEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.11), vec3(0.1, 0.15, 0.1)));
    	  lEars = max(lEars, -lEarsCutter);
    lHead = opSmoothUnion(lHead, lEars, 0.02);
    float lBody = opSmoothUnion(lHead, lTorso, 0.04);
    
    //lLegs
    float lLegs = sdCylinder( opMirrorX(pos) - vec3(0.09, 0.0, 0.0), vec2(0.07, 0.2) );
    lBody = opSmoothUnion(lBody, lLegs, 0.07);
    
    //Arms
    float lArms  = sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.18, 0.28, 0.0)), vec3(0.06, 0.12, 0.06));
    lBody = fOpIntersectionRound(lBody, -lArms, 0.02);
    //Arms Top
    lArms  = opSmoothUnion(lArms, sdEllipsoid( rotation(Z_AXIS, -0.28) * (opMirrorX(pos) - vec3(0.125, 0.35, 0.0)), vec3(0.065, 0.08, 0.065)), 0.04);
    //Hands
    float lHands  = sdEllipsoid( rotation(Z_AXIS, -0.2) * (opMirrorX(pos) - vec3(0.235, 0.19, 0.0)), vec3(0.026, 0.065, 0.045));
    	  lHands  = min(lHands, sdEllipsoid( (opMirrorX(pos) - vec3(0.2, 0.17, -0.035)), vec3(0.012, 0.02, 0.012)));
    lArms = opSmoothUnion(lArms, lHands, 0.02);
    lBody = opSmoothUnion(lBody, lArms, 0.008);
    
    
    
    //Mouth Cavity
    float lMouthCavity = sdEllipsoid( rotation(Z_AXIS, -0.2) * (lHeadStart - vec3(0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));
    float lMouthCavity2 = sdEllipsoid( rotation(Z_AXIS, 0.2) * (lHeadStart - vec3(-0.04, -0.1, -0.105)), vec3(0.065, 0.04, 0.07));
    float lMouthCavity3 = sdEllipsoid( lHeadStart - vec3(0.0, -0.11, -0.105), vec3(0.07, 0.03, 0.07));
    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity2, 0.03);
    lMouthCavity = opSmoothUnion(lMouthCavity, lMouthCavity3, 0.02);
    lBody = fOpIntersectionRound(lBody, -lMouthCavity, 0.01);
    lMouthCavity = max(lBody + 0.001, lMouthCavity) - 0.002;
    res = opU( res, vec2( lBody, 3.0) );
    res = opU( res, vec2( lMouthCavity, 6.0) );
    
    
    //Labios
    float lLabios = sdEllipsoid( lHeadStart - vec3(0.0, -0.09, -0.1), vec3(0.13, 0.08, 0.25));
    	  lLabios = opSmoothUnion(lLabios, sdEllipsoid( lHeadStart - vec3(0.0, -0.12, -0.1), vec3(0.12, 0.08, 0.25)), 0.02);
    lLabios = max(lLabios, lBody);
    res = opU( res, vec2( lLabios, 2.0) );
    
    //Teeth
    float lTeeth = sdRoundBox(rotation(Z_AXIS, -0.02) * (opMirrorX(lHeadStart) - vec3(0.044, -0.068, -0.14)), vec3(0.01, 0.015, 0.001), 0.012);
    res = opU( res, vec2( lTeeth, 3.0 ) );
    
    //Tripa
    float lTripa = sdEllipsoid( pos - vec3(0.0, 0.27, -0.1), vec3(0.12, 0.145, 0.12));
    lTripa = max(lTripa, lBody);
    res = opU( res, vec2( lTripa, 2.0) );
    
    //Inner Ears
    float lInnerEars = sdRoundCone( lEarsPos - vec3(0.07, 0.18, 0.0), 0.03, 0.05, 0.11 );
    float lInnerEarsCutter =  sdBox(lEarsPos -  vec3(0.09, 0.26, -0.12), vec3(0.1, 0.15, 0.1));
    	  lInnerEarsCutter =  min(lInnerEarsCutter, sdBox(lEarsPos -  vec3(0.09, 0.26, 0.1), vec3(0.1, 0.15, 0.1)));
    	  lInnerEars = max(lInnerEars, -lInnerEarsCutter);
        //sdEllipsoid( lEarsPos - vec3(0.09, 0.26, -0.02), vec3(0.04, 0.08, 0.03));
    lInnerEars = max(lInnerEars, lBody);
    res = opU( res, vec2( lInnerEars, 2.0) );
    
    //Eyes
    vec3 lEyePos = opMirrorX(lHeadStart) - vec3(0.1, 0.0, -0.17);
    float lEyelids = sdSphere( lEyePos, 0.036 );
    float 	lEyeCutter = sdBox( rotation(X_AXIS, 0.2) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05));
    		lEyeCutter = min(lEyeCutter, sdBox( rotation(X_AXIS, 0.5) * lEyePos - vec3(0.0, 0.05, -0.055), vec3(0.05, 0.05, 0.05)));
    lEyelids = fOpIntersectionRound(lEyelids, -lEyeCutter, 0.004);
    res = opU( res, vec2( lEyelids, 2.0) );
    
    float lEyeSpheres = sdSphere( lEyePos, 0.033 );
    res = opU( res, vec2( lEyeSpheres, 5.0) );
    //res = opU( res, vec2( lEyeCutter, 4.0) );
    
    //Plunger
	float lPlungerWood = sdRoundCone( rotation(X_AXIS, M_PI * -0.5) * (pos - vec3(0.216, 0.148, -0.21)), 0.012, 0.016, 0.35 );
    res = opU( res, vec2( lPlungerWood, 27.0) );
    
    vec3 lRubberPos = pos - vec3(0.216, 0.148, -0.31);
    float lPlungerRubber = sdSphere( lRubberPos, 0.1);
    	  lPlungerRubber = max(lPlungerRubber, -sdSphere( lRubberPos - vec3(0.0, 0.0, 0.0), 0.085));
    	  lPlungerRubber = max(lPlungerRubber, -sdBox(  lRubberPos - vec3(0.0, 0.00, -0.12), vec3(0.2, 0.2, 0.1)));
          lPlungerRubber = min(lPlungerRubber, sdTorus(rotation(X_AXIS, M_PI * -0.5) * (lRubberPos - vec3(0.0, 0.0, -0.02)), vec2(0.091, 0.017)));
    res = opU( res, vec2( lPlungerRubber, 28.0) );
    
    //Debug reference
    //float lFront = sdSphere(pos - vec3(0.0, 0.66, -0.5), 0.08);
    //res = opU( res, vec2( lFront, 4.0) );
    return res;
}

// Function 4917
float map_ball(vec3 pos, vec3 ballPos, float ballR)
{   
    float d = length(pos-ballPos) - ballR;
    
    return d;
}

// Function 4918
float map(const in vec3 p, const in int cur_space, out int closest_space) {
    #define m(myid, dp) do { \
        float _dp=(dp); \
        if(cur_space == myid) break; \
        if(_dp < dist) { \
            dist = _dp; \
            closest_space = myid; \
        } \
    } while(false)
    float dist = 1e30;

    // indices should start at 1, because 0 is "the air"
    m(1, plane(vec4(0.0,1.0,0.0,-5.0), p));
    
    m(2, min(min(
        segm(vec3(-5.0,0.0,0.0), vec3(5.0,0.0,0.0), p)-.1,
        segm(vec3(0.0,-5.0,0.0), vec3(0.0,5.0,0.0), p)-.1),
        segm(vec3(0.0,0.0,-5.0), vec3(0.0,0.0,5.0), p)-.1));

    m(3, length(p-vec3(0.0,sin(iTime*0.5)*10.0,5.0))-4.0);
    m(4, length(p-vec3(10.0,0.0,0.0))-5.0);
    m(5, length(p-vec3(0.0,10.0,10.0))-3.0);
    
    m(6, length(p-vec3(0.0,0.0,-5.0+cos(iTime)))-2.0);
    m(7, sdOctahedron(p, 5.0));

    if(cur_space == closest_space) closest_space = 0;

    return dist;
}

// Function 4919
vec2 map(vec3 pos)
 {
     vec2 dl = vec2(terrainheightmap(pos),1.);
     dl = un(dl,vec2(water(pos),2.));
     return dl;
 }

// Function 4920
vec2 mapMat(vec3 p){
    
    vec2 box = vec2(mandelbox(rotZ(radians(lastx) / 1.5) * rotX(radians(lasty) / 1.5) * p), 3.0);
    
    #ifdef DISABLE_BG
    
    return box;
    
    #endif
    
    vec2 cmap = vec2(-length(p) + 15.0, 1.0);
    
    return vecMin(box, cmap);
}

// Function 4921
Surface map(vec3 p, float time)
{
    vec3 pp = mod(p, 1.5) - 0.75;
    
    float beat = time * 120.0 / 60.0;
    beat = mod(beat, 64.0);
    
    //kick
    float kick = mod(beat,1.);
    float scale = 3.4 - mix(0.00, 0.25, clamp(kick, 0.0, 1.0));
    
    // hihat
    float pinpon = beat < 16.0 ? 0.0 : pingPong(beat + 0.5, 1.0, 10.0) * 0.1;
    mat3 rot = rotateMat(0.1-pinpon,-pinpon, 0.4-pinpon);
    
    //snare
    float snare = beat < 32.0 ? 0.0 : lerpStep(beat - 32.0 - 1.0, 0.5, 2.0);
    vec3 angle = mod(vec3(snare * 1.3, snare * 0.27, snare * 0.69), vec3(TAU) * 0.5);
    if (beat > 63.5) {
        angle = mix(angle, vec3(0.0), (beat - 63.5) * 2.0);
    }
    
    Surface surface;
    surface.dist = 99999.9;
    
    intersectStage(surface, pp, rot, scale);
    intersectStage(surface, pp, rotateMat(angle.x, angle.y, angle.z) * rot, scale);
    
    rot = rotateMat(sin(time),cos(time), sin(time * .33));
    intersectSphere(surface, (p - sp) * rot);

    return surface;
}

// Function 4922
float sdf( vec3 p ) {
	vec3 n = pow(vec3(sin(iDate.w * 0.5), sin(iDate.w * 0.3), cos(iDate.w * 0.2)), vec3(2.0));
	vec3 q = 0.1 * noise3(p + n);
  
	return length(q + p)-3.5;
}

// Function 4923
float heightmap(vec2 uv) {
	float height = texture(iChannel0, uv*0.15).x*0.04+0.01;
	return height - (wake(vec2(0.28,0.0)-uv)+wake(-uv)+0.1*wake(vec2(-0.3,0.0)-uv))*0.025;
}

// Function 4924
vec3 GetReflectionMap(vec3 rayDir, vec3 normal)
{
  return texture(iChannel3, reflect( rayDir, normal )).rgb;
}

// Function 4925
vec3 envMap(vec3 p){
   
    // Some functions work, and others don't. The surface is created with the function
    // below, so that makes it somewhat believable.
    float c = cellTile(p*6.);
    c = smoothstep(0.2, 1., c); // Contract gives it more of a lit look... kind of.
    
    return vec3(pow(c, 8.), c*c, c); // Icy glow... for whatever reason. :)
    // Alternate firey glow.
    //return vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.));

}

// Function 4926
float numDist(vec2 p, float progress, float order) {
    vec2 a = abs(vec2(p) - 1./32.);
    p -= vec2(-floor(mod(progress * order, 10.)), 4.) / 16.;
    return max(a.x, a.y) > 1./32. ? 10000. : (2. * texture(iChannel0, p).a - 1.);
}

// Function 4927
vec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   
    const vec2 e = vec2(0.001, 0);
    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    
    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));
    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.
    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; 
    g -= n*dot(n, g);
    return normalize( n + g*bf ); // Bumped normal. "bf" - bump factor.
}

// Function 4928
float boxsdf(in vec3 ro, in vec3 r) {
    vec3 mo = abs(ro);
    vec3 b = mo - r;
    float d = max(b.x, max(b.y, b.z));
    // triplanar projection of animated noise for water effect
    vec3 mask = step(mo.zxy, mo.xyz) * step(mo.yzx, mo.xyz);
    ro *= 2.;
    float disp = mask.x * fractalnoise(ro.yz + vec2(0., iTime), 0.25) + mask.y * fractalnoise(ro.zx + vec2(iTime, 0.), 0.25) + mask.z * fractalnoise(ro.xy, 0.5);
    d += 0.015 * disp;
    return d;
}

// Function 4929
vec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)
{
  vec4 col4, vn4;
  vec3 col, vn;
  float dstObj;
  dMiss = dstFar;
  dstObj = ObjRay (ro, rd);
  if (dstObj < dstFar) {
    ro += dstObj * rd;
    vn4 = ObjNfL (ro);
    vn = vn4.xyz;
    col4 = ObjCol (vn);
    col = vec3 (1., 0.98, 0.96) * pow (Maxv3 (col4.rgb), 0.7);
    col *= (1. - 0.5 * smoothstep (0.5, 1., abs (vn4.w) / 64.)) *
       (0.9 + 0.2 * Noisefv2 (Rot2D (uv, 0.2 * pi) * vec2 (16., 256.))) *
       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));
    dMiss = dstFar;
  } else {
    col = vec3 (1.);
  }
  col = mix (col, vec3 (0.3), exp (- 64. * dMiss));
  return clamp (col, 0., 1.);
}

// Function 4930
float computeDist( vec3 pos ) {
    
    // floor
    float dist = distPlane( pos - vec3( 0.0 ) );
    
    // spheres
    dist = min( dist, distSphere( pos - vec3( -0.2, 1.25 + 0.15 * sin( iTime * 1.5 ), 0.3 ), 1.0 ) );
    dist = min( dist, distSphere( pos - vec3( cos( iTime ), 0.0, sin( iTime ) ) * 2.0, 0.6 ) );
    dist = min( dist, distSphere( pos - vec3( sin( iTime ), 2.0, cos( iTime ) ), 0.33 ) );
    
    // boxes
    dist = min( dist, distBox( pos - vec3( -0.2, 0.0, -0.0 ), 0.8 * vec3( 1.0, 0.1, 1.0 ) ) );
    dist = min( dist, distBox( pos - vec3( 0.7, 0.0, -0.8 ), 0.6 * vec3( 0.5, 0.1, 0.5 ) ) );
    
    return dist;
}

// Function 4931
MapInfo map(vec3 origin) {
    // red plane at origin
    MapInfo mapInfo = plane(origin, MATERIAL_LIGHTGRAY);
    // blue sphere at 1.5, 1.0, 1.5 with radius 1.0
    mapInfo = opUnion(mapInfo, sphere(origin + vec3(1.5, 1.0, 1.5), 1.0, MATERIAL_BLUE));
    // green box at -1.5, 1.0, 1.5 with size 1.0 x 1.0 x 1.0
    mapInfo = opUnion(mapInfo, box(origin + vec3(-1.5, 1.0, 1.5), vec3(1.0), MATERIAL_GREEN));
    mapInfo = opUnion(mapInfo, opSubtract( // subtract sphere from box
        sphere(origin + vec3(-1.5, 1.0, -1.5), 1.2, MATERIAL_PURPLE),  // purple sphere at -1.5, 1.0, -1.5 with radius 1.2
        // purple box at -1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0
        box(origin + vec3(-1.5, 1.0, -1.5), vec3(1.0), MATERIAL_PURPLE))
    );
    mapInfo = opUnion(mapInfo, opIntersect( // intersect sphere with box
        box(origin + vec3(1.5, 1.0, -1.5), vec3(1.0), MATERIAL_YELLOW), // yellow box at 1.5, 1.0, -1.5 with size 1.0 x 1.0 x 1.0
        // yellow sphere at 1.5, 1.0, -1.5 with radius 1.2
        sphere(origin + vec3(1.5, 1.0, -1.5), 1.2, MATERIAL_YELLOW))
    );
    return mapInfo;
}

// Function 4932
Shape map(vec3 c){
  Shape hall = Hallway(c);
  return hall;
}

// Function 4933
float distCone(vec3 pos, float radiusBase, float height)
{
    float slope = radiusBase / height;
    float r = length(pos.xz);
    float dist = r - (radiusBase - pos.y * slope);
    dist = soft_max2(dist, -pos.y, 1.0);
    return dist;
}

// Function 4934
float mapOLD(vec3 p, float t) {
    p+=vec3(0,2,0);
    float s1 = sph(p, 0.8);
    float s2 = sph(p+vec3(0,0.5,0), 0.8);
    float c1 = cyl2(p.xzy,0.3);
    float base = smax(smin(s1,s2,0.1),-c1,0.2);
    
    for(int i=0; i<200; ++i) {
        float t3 = t+float(i);
        vec3 off=vec3(sin(t3), cos(t3), cos(t3*1.42));
    	base=smax(base, -sph(p+off, 0.5),  0.05);   
    }
    
    for(int i=0; i<200; ++i) {
        float t3 = t*0.2+float(i);
        vec3 off=vec3(sin(t3)*2.0, cos(t3)*1.5, cos(t3*1.42)*2.2);
    	base=smin(base, sph(p+off, 0.2),  0.05);   
    }
    
    return base;
    //return sph(p, 0.5);
}

// Function 4935
float mapAlien( vec3 p)
{
    float c = cos(2.0*p.y+2.0);
    float s = sin(2.0*p.y+2.0);
    mat2  m = mat2(c,-s,s,c);
    p = vec3(m*p.xz,p.y);
    p = RotXV3(p, -0.785);
    float alienD = sdCapsule(p, vec3(0.0, 3.0, 0.0), vec3(0.0, -2.0, 0.0), 0.4);
    float alienHead = sdSphere(p+vec3(0.0, 2.0, 0.0), 0.8);
    return opU(alienHead, alienD);
}

// Function 4936
float sdf_arrow(vec2 uv, float norm, float angle, float head_height, float stem_width){
    uv = vec2(cos(angle) * uv.x + sin(angle) * uv.y, -sin(angle) * uv.x + cos(angle) * uv.y);

    norm -= head_height;  // Make sure the norm INCLUDES the arrow head
    uv.x -= norm;  // Place the arrow's origin at the stem's base!

    uv.y = abs(uv.y);
    float head = max(ollj_rotate(uv) - head_height, -uv.x);

    uv.x = m_stretch_neg(uv.x, norm);
    uv.y = m_stretch_pos(uv.y, stem_width);
    float stem = length(uv);

    return min(head, stem);  // Join head and stem!
}

// Function 4937
float map(vec3 p){
    float d = 999.;
    vec3 n = normalize(p);
    
    trn(p);
    trn(n);
    
    float h = trimap((p+iTime*.2)*.26, abs(n)).x;
    float r = 1. + h *.7;
    
    float dis = length(p)-r;
    float reg = length(p)-1.;
    
    d = mix(dis, reg, val(p));
    
    return d;
}

// Function 4938
vec3 sdfNormal(vec3 p)
{
    float s = sdf(p);
    vec3 eps = vec3(EPSILON_NORMAL, -EPSILON_NORMAL, 0.0);    
	float dX = s - sdf(p + eps.yzz);
	float dY = s - sdf(p + eps.zyz);
	float dZ = s - sdf(p + eps.zzy);
	return normalize(vec3(dX,dY,dZ));
}

// Function 4939
float PlaneSDF(vec3 p, float y)
{
    return p.y + y;
}

// Function 4940
bool intersectScene(Ray R, float minDist, float maxDist, inout Surfel surfel) {
    if (intersectSceneLoop(R, minDist, maxDist, surfel)) {
        const float eps = 0.0001;
        
        float d = inf;
        scene(surfel.position, d, surfel.material, false);
        surfel.normal =
            normalize(Vector3(distanceEstimator(surfel.position + Vector3(eps, 0, 0)), 
                              distanceEstimator(surfel.position + Vector3(0, eps, 0)), 
                              distanceEstimator(surfel.position + Vector3(0, 0, eps))) - 
                              d);
        return true;
    } else {
        return false;
    }
}

// Function 4941
float dist(vec3 p){
    float plane = fPlane(p, vec3(0.0, 1.0, 0.0), 1.0)-
        smoothstep(0.0, 1.0, noise(p*(sqrt(5.0)*0.5 + 0.5)*0.2+iTime*0.25));
    return plane;
}

// Function 4942
float distSphere(vec3 p, float r)
{
	return length(p) - r;
}

// Function 4943
float scene4(vec3 p)
{
	float rs1 = opRepLimitCenter_scene1(p,vec3(5.0),vec3(9.0));
    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));
    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));
    p.y -= 1.9;
    vec3 pd = deform_torus(p);
	//float tor0 = sdTorus(pd,vec2(8.5,.1));
	float tor1 = sdTorus(pd,vec2(9.5,.1));
	float tor2 = sdTorus(pd,vec2(10.5,.1));
	//float tor3 = sdTorus(pd,vec2(11.5,.1));
    //float tor = opU(opU(opU(tor0,tor1),tor2),tor3);
    float tor = opU(tor1,tor2);
    //return opU(rs1,pn);
    return opU(rs1,tor);
}

// Function 4944
float heightMapTracing(vec3 ori, vec3 dir, out vec3 p, float SEA_TIME) {  
    float tm = 0.0;
    float tx = 1000.0;    
    float hx = map(ori + dir * tx, SEA_TIME);
    if(hx > 0.0) return tx;   
    float hm = map(ori + dir * tm, SEA_TIME);    
    float tmid = 0.0;
    for(int i = 0; i < NUM_STEPS; i++) {
        tmid = mix(tm,tx, hm/(hm-hx));                   
        p = ori + dir * tmid;                   
    	float hmid = map(p, SEA_TIME);
		if(hmid < 0.0) {
        	tx = tmid;
            hx = hmid;
        } else {
            tm = tmid;
            hm = hmid;
        }
    }
    return tmid;
}

// Function 4945
vec3 envMap(vec3 rd, vec3 n){
    
    vec3 col = tex3D(iChannel0, rd, n);
    col = smoothstep(.15, .5, col);
    #ifdef WARM
    col *= vec3(1.35, 1, .65);
    #endif
    //col = col*.5 + vec3(1)*pow(min(vec3(1.5, 1, 1)*dot(col, vec3(.299, .587, .114)), 1.), vec3(1, 3, 10))*.5; // Contrast, coloring. 
    
    return col;

}

// Function 4946
float	real_scene(vec3 p)
{
    float   ret, hammer_d, scene_d;
    vec3    text = vec3(0.5);
    //text = texture(iChannel0, p.xyz*.001).xyz;
    vec2	dp = p.xz*.5;			// used for hexagonal tiling
    hit_hammer = 0.;
	hit_plane  = 0.;
    hit_scene = 0.;
    ret = 1e5;
    dp.x += (mod(floor(dp.y),2.)==.0)?0.0:0.5;
    vec2	s = vec2(floor(p.xz-fract(dp)+.5 ) );
    float	displ = 4.*cos(length(s)/5.-iTime*10.);
    dp = fract(dp)-.5;
    plane_d = 
        p.y+17.
        -15.*text.y/(exp(1.-t)+1.)
        +displ*1.*step(.5, t)*exp(-t*1.+0.)*sin(length(p.xz*.1)-iTime*10.*exp(-t*3.+1.))*4.
//        +
//        (exp(1.-t))
//        *
//        (
//        step(.5, t)
//        *
//    	step(max(((dp.x) ), ((dp.y)+abs(dp.x)*.5 )), .5 )
//        *
//        step(.45-.005*((length(p.xz*.05)-1.5)*(length(p.xz*.05)-1.5)), max(((dp.x) ), ((dp.y)+abs(dp.x)*.5 )) )
//        )
    ;

    p.y -= anims.x;

    hammer_d = hammer(p);
    p.z = abs(p.z)-26.;
    scene_d = scene(p);

    ret = min(ret, hammer_d);
    ret = min(ret, plane_d);
    ret = min(ret, scene_d);
    hit_hammer += (ret == hammer_d ? 1. : .0);
    hit_plane += (ret == plane_d ? 1. : .0);
    hit_scene += (ret == scene_d ? 1. : .0);

    h2 += 100.*step(.42, t)
            *
            exp(-t*10.)
            *
            vec3(.7,.40,.50)
        	/
        	(.00061251*max(hammer_d*hammer_d, 1.) )
        	;
    return ret;
}

// Function 4947
vec2 map( in vec3 pos )
{
    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),
	                vec2( sdSphere(    pos-vec3( 1.0,0.25, -0.5), 0.5 ), 46.9 ) );
    res = opU( res, vec2( opS(
		             udRoundBox(  pos-vec3(-1.0,0.4, -0.5), vec3(0.30),0.1),
	                 sdSphere(    pos-vec3(-1.0,0.4, -0.5), 0.5)), 13.0 ) );
//	res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );
	res = opU( res, vec2( sdTorus88(   pos-vec3(0.0,0.5, 1.0), vec2(0.30,0.10) ),43.0 ) );
	res = opU( res, vec2( sdTorus882(   pos-vec3(0.0,0.5, 1.0), vec2(0.30,0.10) ),43.0 ) );
	res = opU( res, vec2( sdTorus883(   pos-vec3(0.0,0.5, 1.0), vec2(0.30,0.10) ),43.0 ) );
//	res = opU( res, vec2( 0.5*sdTorus82( opTwist(pos-vec3(-0.95,0.45, -0.95)),vec2(0.40,0.05)), 46.7 ) );
    return res;
}

// Function 4948
float map_container(vec3 pos)
{
    pos.y+= 2.8;
    float outside = udRoundBox(pos, vec3(5.5, 1.5, 2.), 0.6);
    float inside = udRoundBox(pos, vec3(5.35, 1.35, 1.85), 0.6);
    float bottom = max(max(outside, -inside), pos.y - 1.);
    
    pos.y-= 4.3;
    outside = udRoundBox(pos, vec3(5., 0.8, 1.), 0.45);
    inside = udRoundBox(pos, vec3(4.9, 0.35, 0.9), 0.45);
    float top = max(max(outside, -inside), - pos.y + 0.25);
    
    pos.y-= 5.4;
    float top2 = udRoundBox(pos, vec3(2.8, 4., 0.7), 0.3);
    return min(bottom, smin(top, top2, 0.45));
}

// Function 4949
vec4 dist_ball(vec3 pos) {
    vec3 offset = floor(pos+0.5);
    ivec3 gp = ivec3(int(offset.x),int(offset.y),int(offset.z));
    if (hash(gp) % 0x0f == 0) {
        pos = abs(fract(pos+0.5)-0.5);
    	return vec4(pos, length(pos)-0.15);
    }
    return vec4(pos,3.0); // no ball here, fake it being elsewhere
}

// Function 4950
vec3 GetDist(vec3 p  ) 
{	vec3 res= vec3(9999.0, -1.0,-1.0);  vec3 pp=p;
	float planeDist1 = p.y+0.0;  //piso inf
   
    res =opU3(res, vec3(planeDist1,-1.0,5.0)); //inf
    p.y=p.y-25.0;
    
    vec3 mn1= MoverNave(p);
    res =opU3(res, mn1); 
    
    float alto=25.0;
    float sb1= sdBox( p-vec3(0.0,0.0,90.0), vec3(100.0,alto,100.0) );
    float sb2= sdBox( p-vec3(0.0,1.0,-1.0), vec3(25.0,alto,10.0) );
    float sb3= sdBox( p-vec3(20.0,1.0,0.0), vec3(15.0,alto,45.0) );
    
    p=rotate_y( p-vec3(43.0,1.0,70.0), radians(135.0));
    float sb4= sdBox( p, vec3(10.0,alto,45.0) );
    
    
    float dif=differenceSDF(sb1, sb2);
    dif=differenceSDF(dif, sb3);
    dif=differenceSDF(dif, sb4);
    
    res =opU3(res, vec3(dif,100.0,-1.0)); //inf
    return res;
}

// Function 4951
float postDistance(vec3 p) {
  float dist1 = sdCylinder(postPos(p), vec2(0.035, 0.25));

  return dist1;
}

// Function 4952
vec2 fragFromScene(vec2 s) {
    return s / px + sceneOrigin;
}

// Function 4953
vec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)
{
    vec3 res = cur;
    
    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));
    pos.xz = mod(pos.xz+2.0,4.0)-2.0;
    float dm = 1e10;
    for( int i=ZERO; i<4; i++ )
    {
        vec3 o = vec3(0.0,3.2,0.0);
        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));
        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));
        float d = length2(pos - o);
        dm = min(d,dm);
    }
    dm = sqrt(dm)-0.02;
    
    if( dm<res.x )
        res = vec3( dm,MAT_CITA,0);
    
    return res;
}

// Function 4954
float map(vec3 p)
{
    float t=0.7*iTime;
	float d1 = Disk(p,vec3(2.0,1.,0.05)) + fpn(vec3(Spin(t*0.25+p.z*.10)*p.xy*20.,p.z*20.-t)*5.0) * 0.545;
    float d2 = Ring(p);
    return smin(d1,d2,1.0);

}

// Function 4955
float SceneSDF(vec3 point) {

    float dist = SphereSDF(point + getSphere(0).xyz, Radius);

    for(int i = 1; i < NUM_SPHERES; ++i) {
        vec4 sphere = getSphere(i);
        float distA = SphereSDF(point + sphere.xyz, Radius);
        dist = SmoothMinSDF(dist, distA, sphere.a * SMOOTHFACTOR);
    }

    return dist;
}

// Function 4956
float sdfDisp(vec3 p)
{
    return sin(p.x) * sin(p.y) * sin(p.z);
}

// Function 4957
float dist(vec3 pos) {
    // This function takes ~all of the rendering time, the trigonometry is super expensive
    // So if there are any faster approximations, they should definitely be used
	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
    for (int i = 0; i < Iterations; i++) {
		r = length(z);
		if (r>Bailout) break;
        
		// convert to polar coordinates
		float theta = acos(z.z/r);
        #if ANIMATE
        theta += iTime*0.5;
        #endif
		float phi = atan(z.y,z.x);
        #if ANIMATE
        phi += iTime*0.5;
        #endif
		dr = pow( r, Power-1.0)*Power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow( r,Power);
		theta = theta*Power;
		phi = phi*Power;
		
		// convert back to cartesian coordinates
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
        z+=pos;
	}
	return 0.5*log(r)*r/dr;
}

// Function 4958
float map( in vec3 pos ) {
    pos.y -= 23.;
    pR(pos.xy,pos.z/20.-time);
    vec3 bp = pos;
    pMod1(bp.z,40.);
    float b = fBoxCheap(bp,vec3(10.,10.,2.));
    	  b = max(b,-fBox2Cheap(pos.xy,vec2(8.+sin(pos.z/10.)))); 
	float d = min(b,-fBox2Cheap(pos.xy, vec2(10.)));
    return d;
}

// Function 4959
float boxSDF(vec3 samplePoint) {
    float boxDist = MAX_DIST;

    for(int i=0; i<numberOfPlanes; i++)
    {
        boxDist = min(boxDist, planeSDF(samplePoint, box[i]));
    }

    return boxDist;
}

// Function 4960
void gs_process_map_mode( inout GameState gs )
{
    if( keypress( KEY_TAB ) == 1. )
        gs.menustate.x = gs.menustate.x != 0 ? 0 : MENU_MAP;

	float zoomspeed = max( keystatepress( KEY_W ), keystatepress( KEY_Z ) ) -
                           keystatepress( KEY_S );
    zoomspeed *= ( keystate( KEY_SHIFT ) > 0. ? .25 : 1. );
	gs.camzoom = clamp( gs.camzoom * exp2pp( iTimeDelta * zoomspeed ), 0.5, 2048. * TRN_SCALE );

    if( iMouse.z < 0. && gs.dragstate.xy == -iMouse.zw )
    {
        vec4 marker = gs_map_unproject( gs, iMouse.xy + .5, iResolution.xy );
        if( abs( marker.w ) < 1. )
        {            
            marker *= ( g_data.radius + texelFetch( iChannel1, ivec2( iMouse.xy ), 0 ).w );
            if( marker.xyz == gs.mapmarker )
                gs.mapmarker = ZERO;
            else
                gs.mapmarker = marker.xyz;
        }
        gs.dragstate.xy = vec2(0);        
    }
}

// Function 4961
float map(vec3 q){

    // Debug usage to compare rigid moving objects with
    // objects that flow with the Truchet tubing.
    #define RIGID_OBJECTS

    // Scaling factor.
    const float sc = 2.;
    
    // Moving object time; A bit redundant here, but helpful when 
    // you want to change the speed without having to refactor everywhere.
    float tm = iTime;
  

    // Back wall
    float wall = -q.z + .1; // Thick wall: (abs(p.z - .2) - .2) + .1;


    // Local hexagonal cell coordinate and cell ID.
    vec4 h = getGrid(q.xy*sc);
    
    // Using the idetifying coordinate - stored in "h.zw," to produce a unique random number
    // for the hexagonal grid cell.
    float rnd = hash21(h.zw + vec2(.11, .31));
    //rnd = fract(rnd + floor(iTime/3.)/10.); // Periodically changing the random number.
    float rnd2 = hash21(h.zw + vec2(.37, 7.83)); // Another random number.
   
    
    // It's possible to control the randomness to form some kind of repeat pattern.
    //rnd = mod(h.z + h.w, 2.)/2.;
    
    
    // Storing the local hexagon cell coordinates in "p". This serves no other
    // purpose than to not have to write "h.xy" everywhere. :)
    vec2 p = h.xy;
    

    // Using the local coordinates to render three arcs, and the cell ID
    // to randomly rotate the local coordinates by factors of PI/3.
    rnd = floor(rnd*144.);
    
    // Random rotation and flow direction..
    float dir = mod(rnd, 2.)*2. - 1.;
    float ang = rnd*3.14159/3.;

    p = rot2(ang)*p; // Random rotate.
    
    
    // Arc radii and thickness variables.
    const float rSm = s.y/6.; // .5/1.732 -> 1.732/2./3.
    const float th = .1; // Arc thickness.

    // The three segment (arc) distances.
    vec3 d;
    
   
    // Metal.
    float mtl = 1e5;
 
    #ifndef RIGID_OBJECTS
    // Angle for non rigid objects.
    float a3;
    #endif
    
    // The Truchet distance.
    float tr = 1e5;
    
    // A scaling constant.
    const float aSc = 1.;
    
    // Is the piece and arc or not. This is an orientation hack that I'll
    // fix later.
    float isArc = 1.;
    
    // Z-based value and a redundant height value that gets used in
    // another example.
    vec3 qZ3, hgt = vec3(0);
    
    // Rotation and minimum coordinate.
    vec2 qR, minP;
    
    if(rnd2<.5){
    
        // Relative local coordinate centers of the two arc and line.
        vec2 p0 = p - vec2(0, -s.y/3.);
        vec2 p1 = p - vec2(0, s.y/3.);
        vec2 p2 = p;
        // Distances.
        d.x = length(p0) - rSm;
        d.y = length(p1) - rSm;
        d.z = abs(p2.y);
        
        d = abs(d)/sc; // Turning the circles into arc segments and scaling.

        // Move the Z-position out to the correct position for all three tubes. 
        // There's a redundant relative height value there for crossover tubes.
        qZ3 = q.z + .045 + hgt;

        // A rounded or square Truchet tube. Look up the torus formula, if you're
        // not sure about this. However, essentially, you place the rounded curve
        // bit in one vector position and the Z depth in the other, etc. Trust me,
        // it's not hard. :)

        // Technically, I could get away with using the minimum 2D arc length and 
        // calculate just one of these, but I'll be extending to include crossover
        // arcs, so I'll leave it in this form.
        d.x = length(vec2(d.x, qZ3.x)) - .05;
        d.y = length(vec2(d.y, qZ3.y)) - .05;
        d.z = length(vec2(d.z, qZ3.z)) - .05;
    /*    
        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);
        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);
        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);
    */    

        
        
        // Arc segment angle calculation.
        if(min(d.x, d.y)<d.z){
            
            // Minimum 
            minP = p1;
            
            // Reverse the direction of the first arc.
            if(d.x<d.y) {
               minP = p0; 
               dir *= -1.;
            }
            
            #ifdef RIGID_OBJECTS
            minP *= rot2(dir*tm); // Animation occurs here.
            float a = atan(minP.y, minP.x); // Polar angle.
            a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.
            // Polar coordinate.
            qR = rot2(a*6.2831853)*minP; 
            qR.x -= rSm; 
            #else
            a3 = atan(minP.x, minP.y);
            a3 = (a3*(6./6.2831)*aSc - tm*dir);
            #endif
            
        }
        else {
            
            // I guessed a time dialation figure of 3.14159 based on the relative 
            // length of a full circle tube (broken into thirds) and a straight
            // tube (broken into thirds). Pure fluke, but I'll take it. :)
            // Circle tube: length = diameter*PI;
            // Straight tube:  length = diameter;
            // Basically, the objects in the tube will travel just a few percentage
            // points slower than those in the arcs in order to meet up perfectly, 
            // but you'll never notice.
            minP = p2;
            #ifdef RIGID_OBJECTS
            qR = p2;
            qR.x = mod(qR.x - dir*tm/3.14159, 1./3.) - 1./6.;
            isArc = 0.; // Not an arc piece.
            #else
            a3 = minP.x;
            a3 = (a3*(3.)*aSc - tm*dir - aSc*.5);
            #endif
            
        }

    }
    else {
    
        vec2 p0 = p - vec2(-.5, -.5/s.y);
        vec2 p1 = p - vec2(.5, -.5/s.y);
        vec2 p2 = p - vec2(0, s.y/3.);
        d.x = length(p0) - rSm;
        d.y = length(p1) - rSm;
        d.z = length(p2) - rSm;
        
        d = abs(d)/sc; // Turning the circles into arc segments and scaling.

        // Move the Z-position out to the correct position for all three tubes.
        qZ3 = q.z + .045 + hgt;

        // A rounded or square Truchet tube.
        d.x = length(vec2(d.x, qZ3.x)) - .05;
        d.y = length(vec2(d.y, qZ3.y)) - .05;
        d.z = length(vec2(d.z, qZ3.z)) - .05;
    /*    
        d.x = sBoxS(vec2(d.x, qZ3.x), vec2(.05, .05), .025);
        d.y = sBoxS(vec2(d.y, qZ3.y), vec2(.05, .05), .025);
        d.z = sBoxS(vec2(d.z, qZ3.z), vec2(.05, .05), .025);
    */    
        
        // Since the moving objects reside within the tubes, the minimum 3D arc 
        // distance should provide the minimum coordinate upon which to calculate 
        // the angle of the object flowing through it... It will work with this 
        // example, but sometimes, you'll have to calculate all three.
        minP = d.x<d.y && d.x<d.z? p0 : d.y<d.z? p1 : p2;
        
        ///// 
        #ifdef RIGID_OBJECTS
        
        minP *= rot2(dir*tm); // Animation occurs here.
        float a = atan(minP.y, minP.x); // Polar angle.
        a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.
        // Polar coordinate.
        qR = rot2(a*6.2831853)*minP; 
        qR.x -= rSm; 
        
        #else
      
        // Calculating, scaling and moving the angles.
        a3 = atan(minP.x, minP.y);
        a3 = (a3*(6./6.2831)*aSc - tm*dir);
        
        #endif
        ///// 
    
    }
    
    // The Truchet tube distance is the minimum of all. I could save a couple
    // of "min" calls and set this above, but this will do.
    tr = min(min(d.x, d.y), d.z);
 

    ///// 
    #ifdef RIGID_OBJECTS
    
    // 3D ball position. "qR" is based on "p," which has been scalle
    // by the factor "sc," so needs to be scaled back. "q.z" has not been
    // scaled... Yeah, it can be confusing. :)
    vec3 bq = vec3(qR/2.,  qZ3.x); // All heights are equal, in this example.
    //if(isArc==0.) bq = bq.yxz;
    //float obj =  max(length(bq.zx) - .02, abs(bq.y) - .04); // Cylinder.
    float obj = length(bq) - .02; // Ball.
    // obj = min(tr + .035 + .01, ball); // Adding in the railing.
    
    #else
   
    a3 = abs(fract(a3) - .5) - .25;
    a3 /= (6.*aSc/sc);
    float obj = max(tr + .0325, a3);
    
    #endif
    ///// 
    
    
    // Metallic elements, which includes the joins, metal ball joints
    // and the tracks they're propogating along.
    //
    // Joins.
    vec2 rp = p;
    rp *= rot2(-3.14159/6.); // Animation occurs here.
    float a = atan(rp.y, rp.x); // Polar angle.
    a = (floor(a/6.2831853*6.) + .5)/6.; // Repeat central angular cell position.
    // Polar coordinate.
    rp = rot2(a*6.2831853)*rp; 
    rp.x -= .5; // Moving the element along the radial line to the edge.

    // Construct the joiner rings.
    rp = abs(rp);
    mtl = rp.x - .02;//max(rp.x, rp.y) - .025;
    mtl = max(max(mtl, tr - .015), -(tr - .005));
    
    // Tracks.
    mtl = min(mtl, tr + .045);
    

    
    
    // Hollowing out the Truchet tubing. If you don't do this, it can cause
    // refraction issues, but I wanted the tubes to be hollow anyway. I've 
    // made the walls kind of thick. Obviously, the thickness can effect
    // the way light bounces around, and ultimately the look.
    tr = max(tr, -(tr + .02)); 
    
    
   
    // Debug: Take out the glass tubing, brackets, tracks, etc, to see the inner
    // objects unobstructed.
    //tr += 1e5;
    //mtl += 1e5;
    
   
    // Storing the object ID.
    vObjID = vec4(wall, tr, mtl, obj);
    
    // Returning the closest object.
    return min(min(wall, tr), min(mtl, obj));



}

// Function 4962
float fogmap(in vec3 p, in float d, float ti)
{
    p.xz *= .4;
    p.z += ti*1.5;
    return max(triNoise3d(p*.3/(d+20.),0.2, ti)*1.8-.7, 0.)*(smoothstep(0.,25.,p.y));
}

// Function 4963
void colonial_maple_223() {
rho_d = vec3(0.100723, 0.0356306, 0.0162408);
rho_s = vec3(0.059097, 0.0661341, 0.11024);
alpha = vec3(0.0197628, 0.0279336, 0.0621265);
p = vec3(0.0311867, 0.112022, 0.344348);
F_0 = vec3(0.0576683, 0.0617498, 0.0479061);
F_1 = vec3(-0.0503364, -0.0382196, -0.0382636);
K_ap = vec3(50.7952, 34.6835, 14.201);
sh_lambda = vec3(6.03342, 6.01053, 4.56588);
sh_c = vec3(18.9034, 0.087246, 1.03757e-07);
sh_k = vec3(18.3749, 21.6159, 26.9347);
sh_theta0 = vec3(0.801289, 0.544191, -0.139944);
}

// Function 4964
float npolySDF (float r, float n, float t, vec2 p)
{
    n *= .5;
    float o = phi/n;
    float a = atan(p.y/p.x);
    if (p.x < 0.) a += pi;
    float s = round((a + t)/pi*n)/n*pi - t;
    float d = round((a + o + t)/pi*n)/n*pi - o - t;
    vec2 c = vec2(cos(d),sin(d))*r;
    vec2 f = vec2(cos(s),sin(s));
    float b = length(p-c);
    float l = dot(p, f);
    l -= cos(o)*r;
    float m = b;
    if (abs(dot(vec2(p.x,-p.y), f.yx)) <= sin(o)*r) m = l;
    return m;
}

// Function 4965
SDFResult testSDF(vec3 p)
{
    const vec3 basepos = vec3(0.0, 0.0, 0.0);
    vec3 porig = p;
    const float space = 2.2;
    p.xz = mod(p.xz + vec3(space*0.5).xz, space) - vec3(space*0.5).xz;
    vec3 delta = p - basepos;
    
    float thingy = sin(iTime+porig.x+porig.z*1.41);
    
    mat3 mat = rotaxis(vec3(-1.0, 0.0, 1.0)*0.85, 0.4+thingy*0.1);
    mat3 matt = rotaxis(vec3(0.0, 1.0, 0.0), sin(iTime*0.6)*0.5);
    mat = mat*matt;
    
    float baselen = 0.5;
    float baseradius = 0.1;
    SDFResult res = vertcapSDF( VertCap(basepos, baselen, baseradius, TREES), delta );
    
    for (int i=0; i<6; i++)
    {
        baselen *= 0.9;
        baseradius *= 0.8;
        delta.x = abs(delta.x);
        delta.z = abs(delta.z);     
        delta.y -= baselen;
        delta = delta*mat;    
        res = opSmoothAdd(res, vertcapSDF( VertCap(basepos, baselen, baseradius, TREES), delta ), baseradius);                
    }

    if (porig.z<5.0)
    	res = opAdd(sphereSDF( Sphere(basepos + vec3(0.0, baselen*1.1, 0.0), baseradius*1.5, BASIC), delta ), res);                
       
	return res;    
}

// Function 4966
float mapDamage( vec3 p ) {
    float d = map( p );

    float n = max( max( 1.-abs(p.z*.01), 0. )*
                   max( 1.-abs(p.y*.2-1.2), 0. ) *
                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);
   
	return d + n;
}

// Function 4967
vec2 map(in vec3 pos)
{
    float t = 9999.0;
    t = min(t, dsphere(pos, vec3(0.0), 1.0));
    return vec2(t, 0.0);
}

// Function 4968
float scene(in vec3 pos)
{
    return 0.1 - length(pos) * 0.05 + fbm(pos * 0.3);
}

// Function 4969
float Scene(vec3 p) 
{
    float bump = texture(iChannel1, (p).zy * .1).r * .5;
    	  bump *= 1. - saturate(p.y * .5 - 5.); // ceiling mask
    
    p.y -= bump;
    
    float dist = ObjWeb(p);
          dist = OpSmoothUnion(dist, ObjGround(p), 2.5);
          dist = OpSmoothUnion(dist, ObjTunnel((p)), 2.0);
          //dist = OpSmoothUnion(dist, ObjTeeth(p), .2);
    
    return dist;
}

// Function 4970
float mapE(vec3 p, out float m)
{
    p.y += sin(p.z * 0.3) * 0.75;
    m = sign(p.x);
    p.x = abs(p.x);
    p.x -= 1.0;
    pR(p.xy, p.z);
    p.x += sin(p.z * 0.125 + iTime) * 0.25;
    return length(p.xy) - 0.01 - pow(sin(p.z * 2.0 + iTime * 12.0) * 0.5 + 0.5, 12.0) * 0.01;
}

// Function 4971
float getDist(vec3 p) {
	vec2 angle = getAngle(p);
    
    angle.x -= iTime * 0.2;
    
    float r1 = supershape(angle.x,
                          12.0,
                          abs(cos(iTime*0.75)) + 0.1,
                          abs(sin(iTime*0.075)) + 0.1,
                          abs(cos(iTime*0.05)) + 0.1);
    
    float r2 = supershape(angle.y, 
                          4.0 + sin(iTime*0.123) * 8.0, 
                          (abs(sin(iTime*0.0756)) + 0.234) * 100.0,
                          (abs(cos(iTime*0.0765)) + 0.234) * 100.0,
                          (abs(cos(iTime*0.0675)) + 0.234) * 10.0);
    
    vec3 f = vec3(r1 * sin(angle.x) * r2 * cos(angle.y),
                  r1 * sin(angle.x) * r2 * sin(angle.y),
                  r2 * cos(angle.x));
    
    return (length(p) - length(f)) * 0.2;
}

// Function 4972
float dist(vec3 p) { return distM(p).x; }

// Function 4973
float map(vec3 p){
    p = rotY(iTime * .2) * p;
    
    float scene = min(1000. /* mb(p) */, box(p, vec3(1., 1., 1.)));
    
    
    return mb(p);
}

// Function 4974
float scene(vec3 p)
{
    return (max(
	    abs(p.x+p.y)-p.z,
	    abs(p.x-p.y)+p.z
	)-1.)/sqrt(3.);
    
    /*float a = +p.x +p.y;
    float c = +p.x -p.y;
	return (max(max(a,-a)-p.z,max(c,-c)+p.z)-r)/sqrt(3.);*/
    
    /*float a = +p.x +p.y -p.z;
    float b = -p.x -p.y -p.z;
    float c = +p.x -p.y +p.z;
    float d = -p.x +p.y +p.z;
	return (max(max(a,b),max(c,d))-r)/sqrt(3.);*/
    
    /*vec3 p2 = abs(p)-1.;
    float d = max(max(p2.x,p2.y),p2.z);
    d = max(d, dot(p, vec3(1,1,-1))-r);
    d = max(d, dot(p, vec3(-1,-1,-1))-r);
    d = max(d, dot(p, vec3(1,-1,1))-r);
    d = max(d, dot(p, vec3(-1,1,1))-r);
	return d/sqrt(3.);*/
}

// Function 4975
vec4 fake_cubemap_blur(in vec3 in_dir) {
    const float lod_level = 5.0;
    vec3 dir = in_dir / max(abs(in_dir.z), max(abs(in_dir.x), abs(in_dir.y)));
    vec4 colz = textureLod(iChannel0, 0.5 + 0.5 * dir.z * dir.xy, lod_level);
    vec4 colx = textureLod(iChannel0, 0.5 + 0.5 * dir.x * dir.yz, lod_level);
    vec4 coly = textureLod(iChannel0, 0.5 + 0.5 * dir.y * dir.zx, lod_level);
    
	vec3 weights = smoothstep(vec3(0.9), vec3(1.0), abs(dir));
    
    return (weights.x * colx + weights.y * coly + weights.z * colz) / dot(vec3(1.0), weights);
}

// Function 4976
float map(vec3 p)
{
    return sdGrassField(p);//min(sdSphere(p),);
}

// Function 4977
vec2 Scene(vec3 p)
{
    vec2 d = vec2(MAX_DIST, SKYDOME);
    //d = opU(opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d), 
    //        opU(sdPlane(p, vec4(0, 0.5,-1, 0), FLOOR), d)) ;
    
    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);
    //d = opU(sdBox(vec3(p.x-25.1, p.y, p.z-15.4), vec3(5.5, 0.5,15.5), OCTAGON), d);
	//d = opU(sdBox(vec3(p.x-10.1, p.y-2., p.z-10.4), vec3(5.5, 0.5,15.5), OCTAGON), d);    
    //d = opU(sdOct(vec3(p.x-30.1, p.y, p.z+0.2*2.), 0.5, OCTAGON), d);    
    
	return d;
}

// Function 4978
maybe_vec2 get_distances_along_line_to_union(
    in maybe_vec2 shape1,
    in maybe_vec2 shape2
) {
    return maybe_vec2(
        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),
             !shape1.exists ? shape2.value.y  : !shape2.exists ? shape1.value.y  : max(shape1.value.y,  shape2.value.y )),
        shape1.exists || shape2.exists
    );
}

// Function 4979
float map_tablet(vec3 pos, vec3 orig, vec3 size, float flatn, float r, bool btext)
{
    pos.z*= flatn;
    return length(max(abs(pos-orig)-size,0.0)) - r + (!btext || inPic(pos)?0.:0.008*texture(iChannel1, pos.xy*0.6).x);
}

// Function 4980
float dist(Bezier4 BB, vec2 p)
{
    vec2 A = BB.A, B = BB.D;
    
    float ppt;
    float At = .0;
    float Bt = 1.;
    
    vec2 pp;
    
    float dis = dist(pp, p);
    
    for(int i=0; i<5; ++i)
    {
        ppt = (At+Bt)*.5;
        pp = getPt(BB, ppt);
        
        if(dist(Segment(A, pp), p) < dist(Segment(pp, B), p))
        {
            Bt = ppt;
        	B = getPt(BB, Bt);
        }
        else
        {
            At = ppt;
        	A = getPt(BB, At);
        }
            
    }
    
    return min(dist(Segment(A, pp), p), dist(Segment(B, pp), p));
}

// Function 4981
float GetSceneDistance(vec3 ro, vec3 rd)
{
    float dO=0.;
 
    vec2 inter = sphIntersect( ro, rd, PLANETCENTER, PLANETRADIUS);
	if (inter.x>=0.0)
        return inter.x;
    else
        return MAX_DIST;
}

// Function 4982
vec4 drawMap(vec3 ro, vec3 rd, vec3 ww, vec3 uu, vec3 vv, vec2 U)
{
    vec4 result = vec4(0.0);
    
    // Set map position on screen
    U.y+=0.7;
    U.y+=0.5;
    U.x-=1.3;
    
    if(abs(U.x) < 0.3 && abs(U.y) < 0.3)
    {
        vec3 cp=state.camPosition; 
        result = getHeightMap( (Translate(cp.x,cp.z,0.0)*RotateZ(-state.camAngle.x)*vec4(U*20.0,0.0,1.0)).xy );
    }
    
    return result;
}

// Function 4983
vec3 lumaBasedReinhardToneMapping(vec3 color)
{
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
    float toneMappedLuma = luma / (1. + luma);
    color *= toneMappedLuma / luma;
    color = pow(color, vec3(1. / gamma));
    return color;
}

// Function 4984
float Map(vec3 p)
{
  float  d=100000.0;
  checkPos = p;
  steelDist=platformDist=waterDist=terrainDist=100000.0;

  d=min(d, sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45)));
  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));
  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));
  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));
  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));
    
  if(sdCappedCylinder(p-vec3(0.0, -19.0, 0), vec2(22.0, 7.))<10.0)
  {
  // platform 
  platformDist = fHexagonCircumcircle(p-vec3(0.0, -16.05, 0), vec2(radius+8.2, 1.4));  
  platformDist=fOpUnionChamfer(platformDist, fHexagonCircumcircle(p-vec3(0.0, -15.05, 0), vec2(radius+8.7, 0.15)), 0.25);  

  checkPos.xz = pModPolar(p.xz, 12.0);   
  platformDist= min(platformDist, fHexagonCircumcircle(p-vec3(0.0, -16.42, 0), vec2(radius+8.3, 0.2)));  
  platformDist=fOpIntersectionChamfer(platformDist, -sdBox(checkPos-vec3(radius+8.8, -16.55, 0.), vec3(1.0, 1., 1.8)), 0.1); 
  platformDist=fOpIntersectionChamfer(platformDist, -sdCappedCylinder(p-vec3(0., -14.4, 0), vec2(radius+7.4, .25)), 0.5);   

  // railing (platform) 
  checkPos.xz = pModPolar(p.xz, 32.0);   
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   
  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));
  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));
  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));

  checkPos.xz = pModPolar(p.xz, 7.0); 
  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  
  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));      
  platformDist=max(platformDist, -sdBox(p-vec3(13.3, -12.5, 0.), vec3(4.6, 12.5, 3.5)));   
       
  terrainDist = MapTerrain(p);
  }
  
  checkPos = p-vec3(11.70, -15.8, 0); 
    
  pModSingle1(checkPos.x, 6.); 
  if(sdBox(checkPos-vec3(0,-1.0, 0), vec3(3.6, 2.3, 4.))<6.0)
  {
  float bridge = sdBox(checkPos-vec3(0, 0.8, 0), vec3(3.0, 0.1, 3.6)); 
  bridge=fOpUnionChamfer(bridge, sdBox(checkPos+vec3(0, 1., 0), vec3(3.0, 1.9, 3.3)), 0.15);   
  bridge=fOpIntersectionChamfer(bridge, -sdBox(checkPos-vec3(0, 0.9, 0), vec3(6.0, 0.2, 3.3)), 0.10); 
  bridge=min(fOpPipe(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6), 0.15), max(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6)));
  platformDist = min(platformDist, bridge);

    
  // railing (bridge)
  checkPos = p-vec3(9.50, -14.42, 0.); 
  pModSingle1(checkPos.x, 2.); 
  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, 3.5), vec2(0.05, .45)));              
  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, 3.5), 0.02, 29.45));  
  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, 3.5), 0.02, 29.45));  
  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, 3.5), 0.04, 29.45));  

  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, -3.5), vec2(0.05, .45)));                    
  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, -3.5), 0.02, 29.45));  
  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, -3.5), 0.02, 29.45));  
  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, -3.5), 0.04, 29.45));  
  }

 
  waterDist = p.y+17.5;

  return  min(d, min(waterDist, min(terrainDist, min(platformDist, steelDist))));
}

// Function 4985
float map (vec3 p) {
    
    p = camera(p);
    float treespace = 8.;
    float treeindex = abs(floor(p.x/treespace)+floor(p.z/treespace));
    p.xz = mod(p.xz,treespace)-treespace*.5;
    
    float blendRoots = .2;
    float blendTrunk = .02;
    float trunkWidth = 1.+.25*(.5+.5*sin(-p.y*.5+t*2.+treeindex*3.));
    float hostTrunk = cyl(p.xz, trunkWidth);
    
    // fat
    float seed1 = treeindex*4.+t+p.y*.25+sin(p.y*.2+t);
    float seed2 = treeindex*3.+t+p.y*-.1+sin(p.y*.2+t);
    float roots = root(p, 2.+mod(treeindex,6.), seed1, trunkWidth, .2);
    roots = smin(roots, root(p, 2.+mod(treeindex,6.), seed2, trunkWidth+.1+sin(p.y*.3+t*3.+treeindex)*.3, .3), blendRoots);
    // middle
    float seed3 = treeindex*2.+3.*p.y*-.1+sin(-p.y*.2+t*2.);
    float seed3b = treeindex*2.+.1*p.y+sin(-p.y*.2+t*2.);
    roots = smin(roots, root(p, 3., seed3, trunkWidth+.1, .2), blendRoots);
    roots = smin(roots, root(p, 6.+mod(treeindex,6.), seed3b, trunkWidth+.1, .2), blendRoots);
    // thin
    float seed4 = treeindex*8.+p.y*.5+sin(p.y*2.5+t*3.)*.2;
    float seed5 = treeindex*4.+p.y*-.5+sin(p.y*1.5+t*5.)*.2;
    roots = smin(roots, root(p, 8., seed4, trunkWidth+.1, .09), blendRoots);
    roots = smin(roots, root(p, 6., seed5, trunkWidth+.2, .08), blendRoots);
    
    float scene = smin(roots, hostTrunk, blendTrunk);
    infos.pos = p;
    infos.blend = scolor(hostTrunk, roots, blendTrunk);
    return scene;
}

// Function 4986
float map2(vec3 pos)
{
    pos.xy = rotateVec(pos.xy, 0.15*smoothstep(40., 200., iTime)*cos(rot*2.));
    pos.zy = rotateVec(pos.zy, 0.15*smoothstep(40., 200., iTime)*sin(rot*2.));
    return length(pos.xz)*0.72 - 0.55*smoothstep(0.2, 0.7, abs(pos.y - campos.y/17.))*smoothstep(1.4 - abs(campos.y)/24., 0.7, abs(pos.y - campos.y/17.));
}

// Function 4987
TraceOutput traceScene( Ray ray, int lod, float shadow_sharpness, float tmax, bool warp_trace, float max_iterations )
{
	TraceOutput to;
	to.t = 0.0;
	to.num_iterations = 0.0;
	to.dist = 0.0;
	to.shadow = 1.0;

#ifdef RAYTRACE_FIRST_MARCH_DISTANCE
	if ( warp_trace ) { to.t += warpTrace( ray ); if ( to.t == FLT_MAX ) return to; } // jump close to first hit
#endif

	for ( int i = 0; i < MAX_ITERATIONS; ++i )
	{
		float d = sd_Scene( ray.o + to.t * ray.d, lod, to.t, ray );
		to.dist = d;
		if ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > tmax ) break;
		to.shadow = min( to.shadow, shadow_sharpness * to.dist / to.t ); // iq's awesome trick http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows
		to.t += to.dist * TFRAC;
		to.num_iterations += 1.0;
		if ( to.num_iterations >= max_iterations ) break;
	}

	to.shadow = max( 0.0, to.shadow ); // fixes some artifacts
	return to;
}

// Function 4988
vec2 sceneSDF( vec3 pos )
{
    vec2 res = vec2( TOO_FAR, ERROR );
    vec2 res2 = vec2( TOO_FAR, ERROR );
    
    pos.z -= iTime*g_movespeed;
        
    for (float i=0.0; i<=32.0; i++)
    {
        float rad = 0.06 + sin(3.14159*i/32.0)*0.02;
        vec3 p=vec3(0.0,-0.2,6.5 - i*3.0/32.0);
        p.x=anim(p);
        res = opsU(res, vec2(sdSphere((pos-p)*vec3(1.0, 0.4, 1.0), rad), 8.0), rad*1.75);
    }    
    return res;
}

// Function 4989
vec3 Scene(vec2 pix){
 	vec3 col = Background(pix);
    
    vec3 circle1 = vec3(0.0, -0.3, 0.5);
    vec3 circle2 = vec3(0.2, 0.2, 0.7);   
    circle1.xy = Mouse();	
    circle1.z = 0.7 + abs(0.1*sin(0.3*iTime));
    
    col += vec3(0.1, 0.2, 0.7) * Circle(pix, circle1);
    col += vec3(0.7, 0.0, 0.3) * Circle(pix, circle2);

    vec4 iC = IntersectCircles(circle1, circle2);
    col -= (0.7*col-vec3(0.1, 0.9, 0.7)) * (Point(pix, iC.xy) + Point(pix, iC.zw));
    
    return col;
}

// Function 4990
float distCone(vec3 p, vec3 pos, vec3 c) {
 
    p -= pos;
    vec2 q = vec2( length(p.xz), p.y );
    vec2 v = vec2( c.z*c.y/c.x, -c.z );
    vec2 w = v - q;
    vec2 vv = vec2( dot(v,v), v.x*v.x );
    vec2 qv = vec2( dot(v,w), v.x*w.x );
    vec2 d = max(qv,0.0)*qv/vv;
    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));
    
}

// Function 4991
float map(vec3 c)
{
 
    vec3 p= c * vec3(1./hScale,1./hScale, 1./zScale);
    
    //overworld
    float  d= (-54. + p.z)*.66 - mix(0., 40., pow(.5 + .5 * snoise(p.xy /135. ), 2.)) * snoise(p / 16.51 );
    
    //caves
    float d2= snoise(p.yxz / 19.99 ) + smoothstep(3., 0., p.z)*.7 + 0.2* smoothstep(32., 54., p.z);

    d=max(d,-d2);
    return d<0.?1.:-1.; 
}

// Function 4992
float DistantTreeGridIntersect( vec3 p, vec3 origin, vec2 c, float interval, vec3 l, float noiseValue)
{
    p -= origin;
    vec3 q = p-interval*clamp(round(p/interval),-l,l);
    return DistantTreeIntersect( q, vec3(0.0), c, noiseValue);
}

// Function 4993
float mapBottom(in vec3 rp)
{
    rp.x += getCurve(rp);
    float bottom = -.6;
    float ax = abs(rp.x);
    bottom += smoothstep(1., 10., ax);
    bottom += (0.5 + 0.5 * noise(rp.xz * .3)) * .5;
    float hill = smoothstep(65., 80., ax);
    bottom += hill * 15.;
    bottom += hill * sin(rp.z * .1) * 2.;
    bottom += hill * sin(rp.z * .15) * 1.;
    return bottom; 
}

// Function 4994
vec2 GetDist(vec3 p) {
    vec2 car = sdCar(p);
    vec3 wp = p-vec3(0,0,.14);
    wp.xz = abs(wp.xz);
    wp-=vec3(.7383, .365, 1.5);
    
    if(p.z>0.) wp.xz *= Rot(.3*sign(p.x));
    vec2 wheel = sdWheel(wp);
    
    float y = p.y;
    
    #ifdef GROUND_DISPLACEMENT
    float centerDist = dot(p.xz, p.xz);
    if(centerDist<100.&&p.y<.01) {
        y = SmoothNoise(p.xz*2.)+SmoothNoise(p.xz*5.)*.5+SmoothNoise(p.xz*23.)*.05;
        y += SmoothNoise(y*p.xz);
        
        float fade = S(100.,0.,centerDist);
        fade *= fade*fade;
        
        y = y*y*.03*fade;
        y *= S(.0, .6, dot(wp.xz,wp.xz));
    }
	y+=p.y;
    #endif
    
    if(min(y, min(car.x, wheel.x))==y)
        return vec2(y, MAT_GROUND);
    else 
    	return car.x<wheel.x ? car : wheel;
}

// Function 4995
vec4 icosahedronAxisDistance(vec3 p) {
    vec3 iv = icosahedronVertex(p);
    vec3 originalIv = iv;

    vec3 pn = normalize(p);
    pModIcosahedron(pn);
    pModIcosahedron(iv);

    float boundryDist = dot(pn, vec3(1, 0, 0));
    float boundryMax = dot(iv, vec3(1, 0, 0));
    boundryDist /= boundryMax;

    float roundDist = length(iv - pn);
    float roundMax = length(iv - vec3(0, 0, 1.));
    roundDist /= roundMax;
    roundDist = -roundDist + 1.;

    float blend = 1. - boundryDist;
    blend = pow(blend, 6.);
    
    float dist = mix(roundDist, boundryDist, blend);

    return vec4(originalIv, dist);
}

// Function 4996
vec3 map2(in vec3 pos) {
   vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.4,0), vec2(0.8,0.5))), ID_GLASS_WALL, ETA);
    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); 
    res.x =abs(res.x);
 	return res;
}

// Function 4997
vec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){
    
    // Resolution independent sample distance... Basically, I want the lines to be about
    // the same pixel width, regardless of resolution... Coding is annoying sometimes. :)
    vec2 e = vec2(1.5/iResolution.y, 0); 
    
    float f = bumpFunction(p); // Hit point function sample.
    
    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.
    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.
    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.
    
    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.
    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.
    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.
    
     
    // The gradient vector. Making use of the extra samples to obtain a more locally
    // accurate value. It has a bit of a smoothing effect, which is a bonus.
    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  
    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.


    // Using the above samples to obtain an edge value. In essence, you're taking some
    // surrounding samples and determining how much they differ from the hit point
    // sample. It's really no different in concept to 2D edging.
    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);
    edge = smoothstep(0., 1., edge/e.x);
    
    
    // We may as well use the six measurements to obtain a rough curvature value while we're at it.
    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);
    
    // Some kind of gradient correction. I'm getting so old that I've forgotten why you
    // do this. It's a simple reason, and a necessary one. I remember that much. :D
    grad -= n*dot(n, grad);          
                      
    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.
	
}

// Function 4998
bool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )
{
    float t = 8.;
	float oldT = 0.0;
	float delta = 0.4;
    bool ret = false;
	for( int j=0; j<110; j++ )
	{
		if (t > 220.0) break; // ...Too far awway
	    vec3 p = rO + t*rD;

		vec2 h = Map(p); // ...Get this position's height mapping.
		// Are we inside, and close enough to fudge a hit?...
		if( h.x < 0.1)
		{
			// Yes! So home in on height map...
///			resT = BinarySubdivision(rO, rD, t, oldT);
			type = h.y;
            ret = true;
			break;
		}
		// Delta ray advance - a fudge between the height returned
		// and the distance already travelled.
		// It's a really fiddly compromise between speed and accuracy
		delta = max(0.02, 0.5*h.x) + (t*0.005);
		oldT = t;
		t += delta;
	}
    if (ret) resT = BinarySubdivision(rO, rD, t, oldT);

	return ret;
}

// Function 4999
vec2 map(vec3 q3){
    vec2 res = vec2(1000.,0.);

    q3.xy -= vec2(T*.05,T*.4);
    vec2 p,
         ip,
         id = vec2(0),
         ct = vec2(0);

    float t = 1e5;
    
    for(int i =0; i<4; i++){
        ct = ps4[i]/2. -  ps4[0]/2.;    
        p = q3.xy - ct*s;               
        ip = floor(p/s) + .5;           
        p -= (ip)*s;                   
        vec2 idi = (ip + ct)*s;
		float hs = hash21(idi);
        float back = floor(hs*5.)*(l.x*.5);
        float bz = back*sin(hs+T*.2);
        vec3 q = vec3(p.x,p.y,q3.z+bz);

		if(hs>txx) q.x *= -1.;

        float b = fBox(q,l.xyx*.455,.045 * scale);
        if(b<t) {
            t = b;
            sid = ps4[i];
            shp = q;
            saveHash=hs;
        }
        
    }

  	if(t<res.x) res = vec2(t,2.);
    return res;
}

// Function 5000
int sdfMaterial(vec3 p)
{   
    int material = 0;
    float d = 10.0;
    p.y -= 1.7;
    
    for(int i = 0; i < 3; ++i)
    {
        pR(p.xz, .65);
        vec3 towerP = p;
        
        float index = pModPolar(towerP.xz, 12.0);
        float h1 = hash11(index * 487.01);
		
        towerP.xy += vec2(-mix(.75, .9, h1), h1*h1);
        float t = Tower(towerP, .2 + h1*h1 * .2, 0.5, false);
        
        if(t < d)
        {
            if(towerP.y > .55)
                material = 1;
            
			d = t;
        }
    }
    
    p.y = 2.1 * (p.y - .8);
    
    // Face it towards us
    pR(p.yz, .5);
    
    float tree = length(p) - 1.35 + smoothstep(.35, -.2, p.y) * .5;
    
    if(tree < d)
        material = 2;
    
    return material;
}

// Function 5001
vec3 linearToneMapping(vec3 color)
{
	float exposure = 1.;
	color = clamp(exposure * color, 0., 1.);
	color = pow(color, vec3(1. / gamma));
	return color;
}

// Function 5002
vec3 mapImage( vec2 fragCoord )
{

    vec2 uv = fragCoord.xy / iResolution.xy;

    float srat=iResolution.y/iResolution.x;
    vec3 vlight=getLight(uv);
    float light=(vlight.x+2.5)*0.3;

    uv.x/=srat;
    vec3 col=vec3(0.);
    vec2 wmapuv=uv;
    wmapuv.x=mod(wmapuv.x-0.070,1./srat);
    wmapuv.x*=srat*1.004; 
    wmapuv.y+=0.01;
    wmapuv.y*=1.02;

    col=render(vec3(0.,0.,0.5),vec3(.8,.8,.3),getMap(wmapuv)*1.003);

    vec2 pcoord=vec2(remap(LOCATION.x,-180.,180.,0.,1.,true)/srat,remap(LOCATION.y,-90.,90.,0.,1.,true));


    if(light>1.) col*=render(vec3(0.2),vec3(1.,1.,1.),light);
    else col= 0.8 * col* pow(smoothstep(.089,1.,light),0.2)*light + col*0.2;

    float gv=graph(vec2((uv.x*srat),uv.y+0.5-pcoord.y));

    col=render(col,mix(col,vec3(1.,2.0,02.),0.15),gv);
    col+=0.7*render(vec3(0.),vec3(1.,0.,0.),
                    clamp(1.0+(0.5+0.5*sin(iTime*2.))*0.005-distance(vec2(uv.x*0.75,uv.y),vec2(pcoord.x*0.75,pcoord.y)),0.,
                          1.));

    col+=getGrid(vec2(uv.x*srat,uv.y))*0.3;
    return col;
}

// Function 5003
vec2 scene(vec3 ray)  
{
    vec2 objs = opU(c(ray), sdPlane(ray), MAT_TREE, MAT_PLANE);
    return objs ;
}

// Function 5004
vec4 colorMap() {
	return texture(iChannel0,rayPos.xz*0.1)*(pow(getHeight(rayPos.xz*0.01)/20.0,2.0));
}

// Function 5005
float sdf_z(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -2, 0), vec3(4, -2, 0)));
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(0, -8, 0)));
    return t;
}

// Function 5006
float map(vec3 pos)
{
	float instance = floor(pos.z / 6.0 + 0.5);
	
	if (pos.x > 0.0) pos.z += 3.0; // Left vs Right
	pos.x -= 3.0 * sign(pos.x);
	
	// Repeat into distance
	vec3 rp = vec3(
		pos.x,
		pos.y,
		repeat(pos.z, 6.0)-2.0
	);
	
	// Make different heights
	rp.x += sin(instance * 17.0 + iTime * 0.9) * 0.05;
	rp.y += sin(instance * 10.0) * 0.4 + pow(cos(instance * 17.0 + iTime), 2.0) * 0.08;
	
	float minesSpikes = spikes(vec3(rotate(rp.xy, sin(instance)*0.2), rp.z));
	float minesMain = sphere(rp, 1.0);
	
	return min(min(chains(rp, instance), minesMain), minesSpikes);
}

// Function 5007
float scenediff(vec3 p)
{
    float d = 1e9;
    
    float tunnel = length(p.yx)-1.5;
    d=-tunnel;
    
    // ridges
    {
        vec3 q=p;
    	q.z=mod(q.z,.4)-.2;
    	d=min(d,sdTorus(q.xzy,vec2(1.51,.02)));
    }
    
    // floor
    float ground = p.y+1.;
    d=min(d,ground);
    
    // tiles
    {
        vec3 q=p;
        q.y+=.998;
        q.xz=rotate(q.xz,-pi*.25);
        q.xz=mod(q.xz,.1)-.05;
        d=max(d,.005-length(q.yx));
        d=max(d,.005-length(q.yz));
    }
    
    return d;
}

// Function 5008
float PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}

// Function 5009
float sdf_1(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_capsule(pos, vec3(0, -8, 0), vec3(4, -8, 0)));
    t = min(t, sdf_capsule(pos, vec3(2, 0, 0), vec3(2, -8, 0)));
    t = min(t, sdf_quarter0_torus(pos, vec3(2, -2, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -2, 0)));
    return t;
}

// Function 5010
float distFieldBlackHole(vec3 position){
	float dist = length(position - circlePos);
    
    return dist;
}

// Function 5011
RaycastHit intersectScene(Ray ray) {
 
    RaycastHit hit = RaycastHit(vec3(1./0.),vec3(0.),-1);
    
    for(int i = 0; i < 4; i++) {
     
        vec3 p = vec3(-.9 + float(i)*1.05,0.,float(i)/1.5);
        RaycastHit sph = intersectSphere(p, .6, ray);
        
        if(distance(sph.p, ray.ori) < distance(hit.p, ray.ori)) {
         
            hit = sph;
            
        }
        
    }
    
    return hit;
    
}

// Function 5012
SDResult sceneDist(in Ray ray) {
    SDResult result;
    result.d = ray.origin.y;
    
    float hash = hashForCell(ray.origin, 20.0);
    ray.origin.xz = mod(ray.origin.xz, 20.0)-10.0;
    
   	//R(ray.origin.yz, sin(hash) * 0.2);
    float bDist1 = boxDist(ray, Box(vec3(0,8,0), vec3(0.5,16,0.5), 0.5));
    float bDist2 = boxDist(ray, Box(vec3(0,11,0), vec3(8,0.5,0.5), 0.5));
    float x = unionOp(bDist1, bDist2);
    result.d = unionOp(result.d, x);
   
    result.material = result.d == ray.origin.y ? kFLOORMATERIAL : kMATTEMATERIAL;
    return result;
}

// Function 5013
void accumulate_lightmap(inout vec4 fragColor, ivec2 address)
{
    if (uint(address.x) >= LIGHTMAP_SIZE.x || uint(address.y) >= LIGHTMAP_SIZE.y/4u)
        return;
    if (iFrame >= NUM_LIGHTMAP_FRAMES + NUM_POSTPROCESS_PASSES)
        return;

    if (postprocess(fragColor, address))
        return;
    
    int region = iFrame & 3;
    int base_y = region * int(LIGHTMAP_SIZE.y/16u);
    if (uint(address.y - base_y) >= LIGHTMAP_SIZE.y/16u)
        return;

    address.y = (address.y - base_y) * 4;
    vec4 light = vec4
        (
            texelFetch(iChannel0, address + ivec2(0,0), 0).x,
            texelFetch(iChannel0, address + ivec2(0,1), 0).x,
            texelFetch(iChannel0, address + ivec2(0,2), 0).x,
            texelFetch(iChannel0, address + ivec2(0,3), 0).x
		);

    vec4 weights = step(vec4(0), light);
    vec4 values = max(light, 0.);
    
    LightmapSample total = decode_lightmap_sample(fragColor);
    accumulate(total, LightmapSample(weights, values));
    fragColor = encode(total);
}

// Function 5014
mat3 distort(vec2 k) {
    return mat3(1.0, 0.0, k.x,
                0.0, 1.0, k.y,
                0.0, 0.0, 1.0);
                
}

// Function 5015
vec2 traceScene(vec3 ro, vec3 rd, inout vec3 outn, inout vec3 uvw)
{
    vec3 p = vec3(-1),q = vec3(1);
    vec2 b = box(ro, rd, p, q);

    float mint = 1e4;
    float id = 0.;

    // First box test
    if(b.y > 0. && b.x < b.y && b.y < mint)
    {
        mint = b.y;
        id = 1.;
        uvw = ro + rd * mint;
        outn = -boxNormal(uvw, p, q);
        uvw = (uvw - p) / (q - p) * 2. - 1.;
    }
    else
        return vec2(mint, id);

    p = vec3(-.5, -.9, -.5), q = vec3(.5, -.5, .5);
    b = box(ro, rd, p, q);

    // Second box test
    if(b.x > 0. && b.x < b.y && b.x < mint)
    {
        mint = b.x;
        id = 2.;
        uvw = ro + rd * mint;
        outn = boxNormal(uvw, p, q);
        uvw = (uvw - p) / (q - p) * 2. - 1.;
    }

    float a = 3.9;
    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));   

    ro.xz *= m;
    rd.xz *= m;

    ro.xy *= m;
    rd.xy *= m;

    ro.yz *= m;
    rd.yz *= m;

    p = vec3(-.26), q = vec3(.26);
    b = box(ro, rd, p, q);

    // Third box test
    if(b.x > 0. && b.x < b.y && b.x < mint)
    {
        mint = b.x;
        id = 3.;
        vec3 rp = ro + rd * mint;
        outn = (rp - (p + q) / 2.) / (q - p);
        outn = normalize(pow(abs(outn), vec3(32)) * sign(outn));      

        m = transpose(m);
        outn.yz *= m;
        outn.xy *= m;
        outn.xz *= m;
    }

    return vec2(mint, id);
}

// Function 5016
vec2 map( vec3 p )
{
    vec3 a = vec3(0.0,-1.0,0.0);
    vec3 b = vec3(0.0, 0.0,0.0);
    vec3 c = vec3(0.0, 0.5,-0.5);
	float th = 0.0;
	float hm = 0.0;
	float id = 0.0;
    
    float dm = length(p-a);

    for( int i=0; i<8; i++ )
	{	
        vec3 bboxMi = min(a,min(b,c))-0.3;
    	vec3 bboxMa = max(a,max(b,c))+0.3;
        
        float bv = sdBox( p-0.5*(bboxMa+bboxMi), 0.5*(bboxMa-bboxMi) );
        //if( bv<dm )
        {            
            vec2 h = sdBezier( p, a, b, c );
            float kh = (th + h.y)/8.0;
            float ra = 0.3 - 0.28*kh + 0.3*exp(-15.0*kh);
            float d = h.x - ra;
            if( d<dm ) { dm=d; hm=kh; }
    	}
		
        vec3 na = c;
		vec3 nb = c + (c-b);
		vec3 dir = normalize(-1.0+2.0*hash3( id+13.0 ));
		vec3 nc = nb + 1.0*dir*sign(-dot(c-b,dir));

		id += 3.71;
		a = na;
		b = nb;
		c = nc;
		th += 1.0;
	}

	return vec2( dm*0.5, hm );
}

// Function 5017
vec3 tonemap( vec3 linearRGB )
{
    const float limitHardness = 1.5;
    
    vec3 okl = rgb_to_oklab(linearRGB);
    
    // Limit luminance.
    /*okl.x = okl.x / pow(pow(okl.x, limitHardness) + 1., 1./limitHardness);
    
    // Limit magnitude of chrominance.
    {
        float mag = length(okl.yz);
        float magAfter = mag;
        magAfter *= 4.;
        magAfter = magAfter / pow(pow(magAfter, limitHardness) + 1., 1./limitHardness);
        magAfter /= 4.;
        okl.yz *= magAfter/mag;
    }*/
    
    linearRGB = oklab_to_rgb(okl);

    // Try to keep the resulting value within the RGB gamut while
    // preserving chrominance and compensating for negative clipping.
    {
        {
            // Compensate for negative clipping.
            float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
            linearRGB = max(vec3(0), linearRGB);
            float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
            linearRGB *= lumBefore/lumAfter;
            
            // Keep the resulting value within the RGB gamut.
            linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));
        }
        
        for(int i = 0; i < 3; i++)
        {
            vec3 okl2 = rgb_to_oklab(linearRGB);

            // Control level of L preservation.
            okl2.x = mix(okl2.x, okl.x, 1.0);
             
            // Enforce hue correction.
            okl2.yz = okl.yz * (length(okl2.yz) / length(okl.yz));
            
            // Control level of ab preservation.
            okl2.yz = mix(okl2.yz, okl.yz, 0.1);

            linearRGB = oklab_to_rgb(okl2);  
  
            {
                // Compensate for negative clipping.
                float lumBefore = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
                linearRGB = max(vec3(0), linearRGB);
                float lumAfter = dot(linearRGB, vec3(0.2126, 0.7152, 0.0722));
                linearRGB *= lumBefore/lumAfter;
                
                // Keep the resulting value within the RGB gamut.
                linearRGB = linearRGB / pow(pow(linearRGB, vec3(limitHardness)) + vec3(1), vec3(1./limitHardness));
            }
        }
    }
        
  
    return Srgb3(linearRGB);
}

// Function 5018
HitInfo shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, int steps) {
    float depth = start;
    int i;
    int mat;
    
    for (i = 0; i < steps; i++) {
        DistMat dist = sceneSDF(eye + depth * marchingDirection);
        dist.dist *= 0.7;
        
        depth += dist.dist;
        mat = dist.mat;
        
        if (dist.dist < EPSILON) {
	    break;
        }
        
        if (depth >= end) {
            depth = end;
            mat = MAT_NONE;
            break;
        }
    }
    
    return HitInfo(depth, i, mat);
}

// Function 5019
float sceneMap3D(vec3 pos)
{
    float t = BACK_WALL_SDF;
    t = min(t, LEFT_WALL_SDF);
    t = min(t, RIGHT_WALL_SDF);
    t = min(t, CEILING_SDF);
    t = min(t, FLOOR_SDF);
    t = min(t, TALL_BOX_SDF);
    t = min(t, SMALL_BOX_SDF);
    return t;
}

// Function 5020
float sdfBox(vec3 p, vec3 b)
{
    vec3 d = abs(p) - b;

    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

// Function 5021
float remap(float val, float min, float max)
{
    return sat((val - min) / (max - min));
}

// Function 5022
float objectsDist(vec3 p) {
    return artifactDist(p);
}

// Function 5023
float sceneSDF1(vec3 p) {
    p /= 20.0;
    //p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;
    return  2.0+sin(p.x)+sin(p.y+p.z)*sin(length(p));
}

// Function 5024
float remap( float a, float b, float v )
{
	return clamp( (v-a) / (b-a), 0.0, 1.0 );
}

// Function 5025
float cloudSphereMap( vec2 p, mat4 camera, vec3 n, float bias, LameTweaks lame_tweaks )
{
	vec2 p0 = p;

	float pole = 0.1;
	p.y = ( p.y - pole ) / ( 1.0 - 2.0 * pole );

	// p0 is in x 0,1
	// q0 is in x 0,2

	vec3 q = vec3( p * vec2( 2, 1 ), 0.0 );

	vec3 q0 = q;

//	q += vortex_bombing( q.xy,  1.0, 1.0, 1.0, 0.0 ) * POW0( 0.5 ); // 1
//	q += vortex_bombing( q.xy,  2.0, 1.0, 1.0, 0.0 ) * POW1( 0.5 ); // 2
//	q += vortex_bombing( q.xy,  4.0, 1.0, 1.0, 0.0 ) * POW2( 0.5 ); // 3
	q += vortex_bombing( q.xy,  8.0, 3.0, 1.0, 0.9 ) * POW3( 0.5 ); // 4
//	q += vortex_bombing( q.xy, 16.0, 3.0, 1.0, 1.0 ) * POW4( 0.5 ); // 5
	q += vortex_bombing( q.xy, 32.0, 2.7, 5.5, 0.85 ) * POW5( 0.5 ); // 6
//	q += vortex_bombing( q.xy, 64.0, 1.0, 1.0, 0.0 ) * POW6( 0.5 ); // 7

	vec2 qoff = vec2( 0.0, 0 );
#ifdef CLOUD_FLOW
	qoff.x = lame_tweaks.cloud_flow_time * earth_angular_velocity; //cloud flow (doesn't fix black line)
#endif

	NoiseTiledParams ntp;
	ntp.eye = camera[3].xyz;
	ntp.n = n;
	ntp.p = n * earth_radius;
	ntp.bias = bias;

	float a = fbm5_tiled_clouds( q.xy * 4.0 + qoff, ntp );

	a *= 1.0 - smoothstep( 0.5 - pole * 3.4, 0.5, abs( p0.y - 0.5 ) ); // would like to do better than that...

	float a0 = a;

	{
		//increase density on areas that have vortices
		a += length( q - q0 ) * 0.5;
		a += q.z * q.z * 5.0;
	}

	// add a little bit more oompf detail, helps overall + on cloud close ups
	a += a0 * fbm5_tiled_clouds( q.xy * 8.0 + qoff, ntp ) * 0.5;

	a = contrast( a + 0.05, 2.75 ); // higher contrast = deeper blue if we keep negative cloud
	a = soft_max( a, 0.0, 15.0 );
	return a;
}

// Function 5026
float decorIconDist(vec2 p, float sz, int style) {
    
    float s = sign(p.x*p.y);
    
    p = abs(p);
    
    vec2 a = vec2(0, sz);
    vec2 b = vec2(sz, 0);
    
    float l = lineDist2D(a, b, p);
    float c = length( p - (p.x > p.y ? b : a)*0.8 );
    
    if (style == 0) {
        return c - 0.2*sz;
    } else if (style == 1) {
        return abs(l + 0.04*sz) - 0.08*sz;
    } else if (style == 2) {
        return min(abs(l), max(min(p.x, p.y), l)) - 0.03*sz;
    } else {
        return min(max(min(s*p.x, s*p.y), l), abs(l)-0.03*sz);
        
    }
    
}

// Function 5027
SceneDist map(in vec3 p)
{
    vec3 rep = vec3(25.0, 0.0, 25.0);
    vec3 p2 = mod(p + vec3(0, -40.0, 0.0), rep) - rep * 0.5;
   
    SceneDist s0 = SceneDist(length(p + vec3(0.4, -1.1, -0.6)) - 0.8, kMatRed);
    SceneDist s1 = SceneDist(length(p + vec3(-1.2, 0.5, 0.0)) - 1.0, kMatBlue);
    SceneDist s2 = SceneDist(length(p + vec3(0.0, 0.4, -1.0)) - 1.5, kMatGreen);
    SceneDist b0 = SceneDist(sdBox(p2 , vec3(10.0, 1.0, 10.0)), kMatLight);
    SceneDist b1 = SceneDist(
        min(
            sdBox(vec3(0.0, -1.0, 0.0) + p + vec3(-2.5, 0.0, -5.0), vec3(4.0, 1.3, 0.3)),
            sdBox(vec3(0.0, -1.0, 0.0) + p + vec3(4.5, 0.0, 2.5), vec3(0.3, 1.3, 4.5))
        )-.1
    , kMatGreen);
    SceneDist fl = SceneDist(p.y + 1.0, kMatWhite);
    
    return unions(unions(unions(fl, unions(unions(s0, s1), s2)), b0), b1);
}

// Function 5028
float map(vec3 p){
    return smoothMinP(min(water(p), seaPillars(p)), seaGround(p), 1.13);
}

// Function 5029
void tonemap(inout float color)
{
    // Rough ACES tonemap
    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
    color =
        sat((color * (2.51 * color + .03)) /
            (color * (2.43 * color + .59) + .14));

    // The volume is noisy so let's do things grayscale and grain things up
    // to lean on the whole "artsy" noir/vintage look
    float brightness = max(color, .001);
    float grain = sat(pow(rnd(), 8.) / 100.);
    color = mix(sat(color - grain), sat(color + grain), exp(brightness));
    grain = sat(pow(rnd(), 8.) * .15);
    color -= grain * brightness;

    // Gamma correction, of course
    color = pow(color, .45);
}

// Function 5030
float dist2Line(vec2 a, vec2 b, vec2 p) { 
    p -= a, b -= a;
	float h = clamp(dot(p, b) / dot(b, b), 0., 1.); 
	return length( p - b * h );                       
}

// Function 5031
Hit map(vec3 p, bool shield) {
	vec3 pp, op,
	     rp = p;
	rp.xz *= rot(S(-1., 1., 1.5 * sin(cos(t * .5))) - .5);
	pp = rp;
	pp.z += .05;
	float bd, bdd, eye, mx, lxz, d,
	      chin = max(cap(pp, .6, .5), -pp.z - .45);
	chin = max(chin, rp.y - .6);
	pp.y -= 1.3 + pp.z * .2;
	pp.z += 1.1;
	bd = max(min(cap(rp, .7, .45), max(chin, -box(pp, vec3(1)))), .15 - rp.y + rp.z * .5);
	pp = rp;
	pp.x = abs(pp.x) - .2;
	pp.yz = rp.yz - vec2(.6, -.4);
	op = pp;
	bd = min(max(bd, .12 - length(pp)), cyl(rp - vec3(0, .7, 0), vec2(.5, .02)));
	eye = max(length(pp - vec3(0, 0, .1)) - .1, abs(pp.y) - S(1., .8, sin(t * .9)) + .05);
	g += 1e-4 / (.001 + eye * eye);
	Hit orb,
	    h = Hit(eye, 3, rp);
	mx = abs(p.x);
	pp.x = mx - .2;
	pp.yz = p.yz - vec2(.6, -.4);
	lxz = length(p.xz);
	d = .25 + .35 * step(p.y, -1.) * mix(.8, 1., sat(2. * abs(sin(p.y * 10.))));
	bdd = max(max(lxz - d, p.y - 1.), -p.y - 2.5);
	d = max(max(max(length(p.xz * vec2(.5, .9)) - (p.y + 6.2) * .12, p.y + 1.), -p.y - 2.), -box(pp + vec3(0, 2.4, 0), vec3(-pp.y * .18, .3, 1)));
	bd = min(bd, d);
	pp.x -= .4;
	pp.y += 1.4;
	pp.xz *= rot(.4);
	pp.xy *= rot(-.1);
	bd = min(bd, .9 * box(pp, vec3(.8, .5 + pp.z * .4, .25)));
	pp = p;
	pp.x = mx - 1.58;
	pp.xy *= rot(.1);
	pp.y += .8;
	bd = min(bd, limb(pp, -.2, .4, .7));
	d = box(pp + vec3(-.1, .9, 0), vec3(0, .2, .2));
	pp.xy *= rot(-.7 - sin(t) * .025);
	bd = min(bd, min(d, box(pp + vec3(-.8, 1, 0), vec3(0, .2, .2))) - .1 + .03 * abs(sin(pp.z * 20.75)));
	pp = p;
	pp.y += 3.2;
	pp.x = floor(mx * 5.) / 5.;
	minH(Hit(min(bdd, cap(pp, 1., .3)), 2, p));
	bd = min(bd, max(length(pp.zy) - .15, lxz - 1.));
	pp.x = mx - 1.;
	bd = min(bd, limb(pp, .2, -.2, 1.));
	pp.y += 1.4;
	bd = min(bd, max(max(hex(pp, vec2(.4, 1.2)), -pp.y), pp.z - .3));
	minH(Hit(bd, 1, p));
	op = p - vec3(10, -7, 30);
	orb = Hit(length(op) - 25., 0, op);
	g += .01 / (orb.d * orb.d * .1 + 1.);
	if (shield) minH(orb);
	pp = p - vec3(p.y + 74.875 + sin(p.y * 15.) * .05, n21(pp.xy * .5) * .2, -11.22);
	d = n21(pp.xz * .2);
	minH(Hit(pp.y - 2. * pow(d, 10.) + 7.1, 4, vec3(pp.xz, d)));
	op.xz *= rot(1.);
	p = op;
	op.xz = abs(op.xz) - 8.;
	pp = op;
	op.xz *= rot(op.y / 12.7348);
	d = 4. - 2.8 * pow(sin(.5 * pow(op.y * .39, .65) + .2), 1.8);
	d = min(max(box(op, vec3(d, 20, d)) - .1, box(pp, vec3(3.25, 20, 3.25))), box(p, vec3(12, .3, 12)) - .2);
	minH(Hit(d, 5, op));
	d = cyl(p.yxz, vec2(.7 - p.y * 0.12, 4.0)) - .5;
	minH(Hit(d, 2, op));
	p.y -= 5.;
	orb = Hit(length(p) - .7 + n31(p * 3. + t) * .4, 0, op);
	g += .01 / (orb.d * orb.d * .1 + 1.);
	minH(orb);
	return h;
}

// Function 5032
float sdf_j(in vec3 pos, in vec3 offset) {
    pos -= offset;
    float t = 1000.0;
    t = min(t, sdf_half1_torus(pos, vec3(2, -6, 0)));
    t = min(t, sdf_capsule(pos, vec3(4, -2, 0), vec3(4, -6, 0)));
    t = min(t, sdf_sphere(pos, vec3(4, -0.5, 0)));
    t = min(t, sdf_sphere(pos, vec3(0, -6, 0)));
    return t;
}

// Function 5033
float getUnitDistanceSimple(vec3 p)
    {
        return length(p)-4.8; // The coefficient is a bit ad-hoc here. The goal is to quickly catch a "leaking ray".
    }

// Function 5034
float sdf( vec3 p, bvec4 sdf_bound_test )
{
	float d = Hill(p);
//	return Hill(p);
//	
//	p.y += 0.2*sin(p.z*0.5+iTime);

	vec3 tex=Tex(p);
	
	//floor!
//	float d = p.y-floor_height+tex.x*.25-.05-sin(p.z)*.1;
//	float d = p.y-floor_height;
	
//	if (p.x < 0.)
//	if (sdf_bound_test.z)
		d = U(d,Gate(p));
//	else
//	if (sdf_bound_test.w)
		d = U(d,House(p));
	
//	p = RotY(p,iTime);
	
	vec3 q = p;
	p=TowerReflect(p);
	
#if 1	
	//walls
//	if (sdf_bound_test.y)
	{
		d = U(d,Wall(p));
		d = U(d,Wall(p.zyx));
	}
	
//	if (sdf_bound_test.x)
	{
		//main tower
		float w = 5.0*0.25;
		float h = 10.0*0.5;
		float hh = q.x > 0. ? h : 10.*0.3;
		float w_fat = w + clamp(p.y-3.5-(hh-h),0.,0.9)*0.2;
		d = U(d, BevelBox(p-vec3(0.,(hh-h),0.),vec3(w_fat,h,w_fat),.05));
	
		float foot = 0.1*w + clamp(-p.y-3.,0.,1.)*0.2;
		float foot_d = BevelBox(abs(p)-vec3(w,0.,w), vec3(foot,h,foot),.05);
		foot_d = ClipY(foot_d,p,hh);
		d = U(d, foot_d);
		
		//hollow out
		d = S(d,Box(p,vec3(w*0.8,h*2.0,w*0.8)));
		
		//window
		float wind_h = h*.15;
		float wind_w = w*0.2; // - clamp(p.y*.5,0.,1.);
		vec3 wind_p = p;
		wind_p.y -= 2.+(hh-h);
		d = S(d,Box(wind_p,vec3(w*1.25,wind_h,wind_w)));
		d = S(d,Box(wind_p,vec3(wind_w,wind_h,w*1.2)));
	
		//sil
		wind_p.xz=abs(wind_p.xz);
		vec3 sil_off = vec3(w,-h*.15,0.);
		vec3 sil = vec3(w*.15,h*.0125,w*0.25);
		d = U(d,Box(wind_p-sil_off,sil));
		d = U(d,Box(wind_p-sil_off.zyx,sil.zyx));
					
		//crenulate towers
		p.xz=abs(p.xz);
		float cren_w=w*0.3;
		d = U(d, BevelBox(p-vec3(w,hh*1.1,w),vec3(cren_w,h*0.15,cren_w),.1));
				
		d = U(d,Flag(q));
	}
#endif	
	
	return d;
}

// Function 5035
vec2 remap_11to01(vec2 a)
{
    return vec2(remap_11to01(a.x), remap_11to01(a.y));
}

// Function 5036
float sdfEllipsoid( vec3 p, vec3 r, mat4 t )
{
  p = vec3(t * vec4(p, 1));
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

// Function 5037
float mandelbox_dist(vec3 pos) {
    vec4 p = vec4(pos, 1.0), p0 = p;
    float minRad2 = 0.25;
    vec4 scale = vec4(2.0) / minRad2;
    float absScalem1 = abs(2.0 - 1.0);
    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));
    for (int i=0; i<20; i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;
        float r2 = dot(p.xyz, p.xyz);
        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);
        p = p * scale + p0;
    }
    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
}

// Function 5038
Object map( vec3 p )
{
  return Object(sphere(p,1.0),rotate(p,vec3(0.0,1.0,1.0),iTime/8.0));
}

// Function 5039
vec2 map(in vec3 pos) {
    
    query_t Q;
    
    construct(pos, Q);
    
    mat4x2 tm;
    
    // distance to sphere
    vec2 sphere = vec2(length(pos)-1., 2);
    
    // distance to polyhedron
	tm[0] = vec2(Q.fdist_face, 2);
    
    // distance to ball-and-stick web (cylinders/spheres)
    vec2 dv = vec2(Q.fdist_vertex-0.07, 0);
    vec2 de = vec2(Q.fdist_edge-0.04, 1);    
    tm[1] = dv.x < de.x ? dv : de;                  

    // distance to polyhedral net (faceted edges)
    tm[2] = vec2(max(-(Q.pdist_poly_perp+0.08),
                     max(Q.fdist_face, -0.08-Q.fdist_face)), 1);
    
    // distance to polyhedron dilated by sphere
    tm[3] = vec2(Q.fdist_face-0.15, 2);
          
    // sphere coefficient
    float k = 1.0 - dot(distance_function, vec4(1));
    
    // return final linear combination
    return (k*sphere + tm * distance_function);

}

// Function 5040
float LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)
{
	vec3 AP = point - A;
    vec3 AB = B - A;
    
    // from https://www.youtube.com/watch?v=PMltMdi1Wzg
    // added normal calculation though
    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));
    vec3 closestPoint = A + h * AB;
    normal = normalize(point - closestPoint);
    return length(point - closestPoint) - width;
}

// Function 5041
vec4 map( in vec3 p )
{
    float d = sdBox(p,vec3(1.0));
    vec4 res = vec4( d, 1.0, 0.0, 0.0 );

    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );
	float off = 1.5*sin( 0.01*iTime );
	
    float s = 1.0;
    for( int m=0; m<4; m++ )
    {
        p = mix( p, ma*(p+off), ani );
	   
        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;

        if( c>d )
        {
          d = c;
          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );
        }
    }

    return res;
}

// Function 5042
float scene(vec3 rayPosition)
{
	float entity = planeDistance(rayPosition);
    entity = min(entity, cubeDistance(rayPosition, cubePosition, cubeSize));
    entity = min(entity, sphereDistance(rayPosition, spherePosition, sphereRadius));
    entity = min(entity, torusDistance(rayPosition, torusPosition, torusSize));

    return entity;
}

// Function 5043
float	scene(vec3 p)
{
    float	mind = 1e5;
    a = (t*1.5) + 1.5*cos( .8*(p.y*.015+p.x*.015+p.z *.15)  + t);
    #ifdef	CAM_PATH
    vec2	rot = vec2( cos(a+1.57), sin(a+1.57) );
    #else
    vec2	rot = vec2( cos(t*.5), sin(t*.5) );
    #endif
    #ifndef CENTERED
	 #ifdef	CAM_PATH
      #if CAM_PATH == 0
		p.x += rot.x*2.+sin(t*4.)/2.;
		p.y += rot.y*2.+cos(t*4.)/2.;
      #elif CAM_PATH == 1
    	p.x += rot.x*2.+sin(t*2.);
		p.y += rot.y*2.+cos(t*2.);
      #endif
     #else
    	p.x += rot.x*4.;
		p.y += rot.y*4.;
 	 #endif
    #endif
    #ifdef OUTSIDE
    vec2	rot1 = vec2( .54, .84 );				// cos(1.), sin(1.)
    p.xz *= mat2(rot1.x, rot1.y, -rot1.y, rot1.x);
	#endif
	mind = de_2(p);
	
    return(mind);
}

// Function 5044
float DistanceToObject(vec3 P, Object obj)
{
	if (IsQuad(obj))
		return DistanceToQuad(P, obj);
	else
		return DistanceToSphere(P, obj);
}

// Function 5045
void setupScene() {
    
    float timeline = mod(T, 20.0);
    
    if (timeline < 5.0) {
        displayScene = 1.0;
        displayProjection = 0.0;
        rotateProjection = 0.0;
    } else if (timeline < 10.0) {
        displayScene = 1.0;
        displayProjection += clamp((timeline - 5.0) * 0.5, 0.0, 1.0);
        rotateProjection = 0.0;
    } else if (timeline < 15.0) {
        displayScene = clamp(1.0 - (timeline - 10.0) * 0.5, 0.0, 1.0);
        displayProjection = 1.0;
        rotateProjection = 1.0;
        rotation = timeline - 10.0;
    } else if (timeline < 20.0) {
        displayScene = clamp((timeline - 15.0) * 0.5, 0.0, 1.0);
        displayProjection = clamp(1.0 - (timeline - 15.0) * 0.5, 0.0, 1.0);
        rotateProjection = 1.0;
        rotation = timeline - 10.0;        
    }
}

// Function 5046
vec4 texMapSmoothCh(samplerCube tx, vec3 p){

    // Voxel corner helper vector.
	//const vec3 e = vec3(0, 1, 1./4.);
	const vec2 e = vec2(0, 1);

    // Technically, this will center things, but it's relative, and not necessary here.
    //p -= .5/dimsVox.x;
    
    p *= dimsVox;
    vec3 ip = floor(p);
    p -= ip;

    
    //int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  //int(mod(ip.x, 4.))
    //ip.x /= 4.;
/*
    float c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch).x, txChSm(tx, ip + e.yxx, chNxt).x, p.x),
                     mix(txChSm(tx, ip + e.xyx, ch).x, txChSm(tx, ip + e.yyx, chNxt).x, p.x), p.y),
                 mix(mix(txChSm(tx, ip + e.xxy, ch).x, txChSm(tx, ip + e.yxy, chNxt).x, p.x),
                     mix(txChSm(tx, ip + e.xyy, ch).x, txChSm(tx, ip + e.yyy, chNxt).x, p.x), p.y), p.z);
*/
    
     vec4 txA = txChSm(tx, ip + e.xxx);
     vec4 txB = txChSm(tx, ip + e.yxx);

     float c = mix(mix(mix(txA.x, txB.x, p.x), mix(txA.y, txB.y, p.x), p.y),
                   mix(mix(txA.z, txB.z, p.x), mix(txA.w, txB.w, p.x), p.y), p.z);

 
 	/*   
    // For fun, I tried a straight up average. It didn't work. :)
    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +
             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +
             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +
             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;
 	*/
    
    return vec4(c);

}

// Function 5047
vec2 DistToLine2(vec2 p, vec2 a, vec2 b)
{
    vec2 pa = p - a;
    vec2 ba = b - a;
    
    float frac = clamp((dot(pa, ba) / dot(ba, ba)), 0.0, 1.0);
    
    return vec2(length(pa - (ba * frac)), frac);
}

// Function 5048
float map(vec3 p){
    p.xz*= m(t*0.4);p.xy*= m(t*0.3);
    vec3 q = p*2.+t;
    return length(p+vec3(sin(t*0.7)))*log(length(p)+1.) + sin(q.x+sin(q.z+sin(q.y)))*0.5 - 1.;
}

// Function 5049
float TraceScene( const in C_Ray ray )
{        
    float fDistance = kMaxDist;
        
	float fFloorHeight = -1.5;
	fDistance = min(fDistance, TraceFloor( ray, fFloorHeight ));
	
	// end of row
	fDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMax, fFloorHeight, -100.0), vec3(fBuildingMax+1.0, 100.0, 100.0) ));
	fDistance = min(fDistance, TraceBox( ray, vec3(fBuildingMin, fFloorHeight, -100.0), vec3(fBuildingMin-1.0, 100.0, 100.0) ));
		
	fDistance = min(fDistance, TraceBuildingSide( ray ));
	
	C_Ray ray2;					
	ray2.vOrigin = ray.vOrigin * vec3(1.0, 1.0, -1.0);
	ray2.vDir = ray.vDir * vec3(1.0, 1.0, -1.0);
	ray2.vOrigin.z -= 0.3;
	fDistance = min(fDistance, TraceBuildingSide( ray2 ));
					
	return fDistance;
}

// Function 5050
float llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs
	float lx2z=l.x/(l.x+l.z),h=l.y*lx2z;
	vec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));
	q+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));
	vec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;
	u=p-j0;q=j1-j0;
	h=clamp(dot(u,q)/dot(q,q),0.0,1.0);
	float d=length(u-q*h)-r.x-(r.y-r.x)*h;
	u=p-j1;q=j2-j1;
	h=clamp(dot(u,q)/dot(q,q),0.0,1.0);
	d=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);
	u=p-j2;q=j3-j2;
	h=clamp(dot(u,q)/dot(q,q),0.0,1.0);
	return min(d,length(u-q*h)-r.z-(r.w-r.z)*h);
}

// Function 5051
float map(vec3 p) {
	vec4 q = vec4(p, 1.0);
	q.x += 1.0;

	for(int i = 0; i < 6; i++) {
		q.xyz = -1.0 + 2.0*fract(0.5 + 0.5*q.xyz);
		q = 1.2*q/max(dot(q.xyz, q.xyz), 0.1);
	}

	vec2 tun = abs(p.xy - path(p.z))*vec2(0.6, 0.5);

	return min(0.25*abs(q.y)/q.w, 1.0 - max(tun.x, tun.y));
}

// Function 5052
float distanceToScene(vec3 pos)
{
	float d = 10000.0;
	vec4  p = vec4(pos, 0.0);
	vec4 dp = vec4(1.0, 0.0, 0.0, 0.0);
	vec4  C = vec4(0.0303, -0.0303, 0.01516, 0.21);
    
	for (int i = 0; i < 6; i++)
    {
		dp = 2.0*vec4(p.x*dp.x - dot(p.yzw, dp.yzw), p.x*dp.yzw + dp.x*p.yzw + cross(p.yzw, dp.yzw));
		p = vec4(p.x*p.x - dot(p.yzw, p.yzw), vec3(2.0*p.x*p.yzw)) + C;

		float r = c3(p.yxz);
		d = min(d, 0.5 * r / length(dp));

        float p2 = dot(p, p);
		orbitTrap = min(orbitTrap, abs(p.zxy));
		if (p2 > 14.286) break;
	}

	return 0.45*min(d, length(pos) - 0.9771);
}

// Function 5053
float map(vec3 p){
    
    
    float c = heightMap(p.xy); // Height map.
    // Wrapping, or folding the height map values over, to produce the nicely lined-up, wavy patterns.
    c = cos(c*6.283*1.) + cos(c*6.283*2.);
    c = (clamp(c*.6+.5, 0., 1.));

    
    // Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).
    // Adding some height to the plane from the heightmap. Not much else to it.
    return 1. - p.z - c*.025;

    
}

// Function 5054
float map(vec3 p) {

    float tt = knobtime(0);
    
    vec3 bp=p;
    
    p.xz*=rot(time*0.1);
    p.xy*=rot(time*0.12);
        
    vec2 mm = fractal(p);
    
    float d = abs(mm.x)-0.3;
    float dist = rnd(mm.y);

    float t1 = max(d,sph(bp, 60.0));
    float t2 = sph(bp, 40.0 + sin(tt*0.1+dist*32.0 + pow(fract(bpm),5.0))*20.0);
    t2 = abs(t2)-0.3;
    t2 = max(t2, -d+0.3);
    
    d=min(t1, t2);
    
    p=bp;
    
    p+=tunnel(p);
    
    vec3 bp2 = p;
    
    p.xy *= rot(sin(p.z*0.01 + tt*0.1));
    p.yz *= rot(sin(p.z*0.01 + tt*0.1)*0.3);
    p+=noise(p*0.02)*30.0;
    p=repeat(p, 40.0);
    float t3 = boxgrid(p, 7.0, 0.2);
    t3 = min(t3, cyl(p.xy, 1.0));
    t3 = min(t3, cyl(p.yz, 1.0));
    t3 = min(t3, max(abs(cyl(bp.xy, 100.0 + sin(tt*0.3 + bp.z*0.05)*20.0))-3.0, abs(p.z)-0.4)*0.7);
    t3=max(t3, -cyl(bp.xy, 80.0)); 
    
    d=min(d, t3);
    
    float t5=abs(octa(bp2, 120.0))-1.0;
    t5 = max(t5, mm.x-0.2);
    oo+=0.2/(0.2+t5);
    d=min(d, t5);
    
    
    tra=(t1<=d)?1.0:0.0;
        
    return d;
}

// Function 5055
void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {
    
    if (iFrame > 1) {
        discard;
        return;
    }
    
    vec3 col = vec3(0.);
    for (float i = float(ZERO); i < 1.; i += IBL_smp) {
        for (float j = float(ZERO); j < 1.; j += IBL_smp) {
            // sample cosine hemisphere weighted colors
            vec3 smp = cosWeightedHemisphereDirection(rayDir, vec2(i, j));
            col += srgb_linear(textureLod(iChannel0, smp, 5.5).rgb);
        }
    }
    
    // normalize
    fragColor = vec4(col * IBL_smp2, 1.);
}

// Function 5056
vec4 readMapTex(vec2 pos) {
 	return texture(iChannel1, (floor(pos) + 0.5) / iChannelResolution[0].xy);   
}

// Function 5057
float SDFLine( in vec2 coords )
{
    float v = coords.x * 2.0 - coords.y;
    vec2  g = vec2(2.0,-1.0);
    return abs(v)/length(g);
}

// Function 5058
float getMap(vec2 p){ float res=0.;
                     #ifdef USE_MAP
                     res=max(res,LINE(vec2(0.233333,0.991667), vec2(0.291667,0.991667))); res=max(res,LINE(vec2(0.341667,0.991667), vec2(0.408333,0.991667))); 
                     res=max(res,LINE(vec2(0.208333,0.983333), vec2(0.283333,0.983333))); res=max(res,LINE(vec2(0.3,0.983333), vec2(0.425,0.983333))); 
                     res=max(res,LINE(vec2(0.208333,0.975), vec2(0.416667,0.975))); res=max(res,LINE(vec2(0.5,0.975), vec2(0.5,0.975))); res=max(res,LINE(vec2(0.516667,0.975), vec2(0.533333,0.975))); res=max(res,LINE(vec2(0.6,0.975), vec2(0.6,0.975))); res=max(res,LINE(vec2(0.625,0.975), vec2(0.625,0.975))); res=max(res,LINE(vec2(0.716667,0.975), vec2(0.733333,0.975))); 
                     res=max(res,LINE(vec2(0.158333,0.966667), vec2(0.166667,0.966667))); res=max(res,LINE(vec2(0.183333,0.966667), vec2(0.2,0.966667))); res=max(res,LINE(vec2(0.216667,0.966667), vec2(0.258333,0.966667))); res=max(res,LINE(vec2(0.275,0.966667), vec2(0.408333,0.966667))); res=max(res,LINE(vec2(0.5,0.966667), vec2(0.525,0.966667))); res=max(res,LINE(vec2(0.741667,0.966667), vec2(0.75,0.966667))); 
                     res=max(res,LINE(vec2(0.141667,0.958333), vec2(0.158333,0.958333))); res=max(res,LINE(vec2(0.208333,0.958333), vec2(0.208333,0.958333))); res=max(res,LINE(vec2(0.233333,0.958333), vec2(0.25,0.958333))); res=max(res,LINE(vec2(0.275,0.958333), vec2(0.416667,0.958333))); res=max(res,LINE(vec2(0.508333,0.958333), vec2(0.525,0.958333))); res=max(res,LINE(vec2(0.75,0.958333), vec2(0.75,0.958333))); 
                     res=max(res,LINE(vec2(0.133333,0.95), vec2(0.191667,0.95))); res=max(res,LINE(vec2(0.216667,0.95), vec2(0.216667,0.95))); res=max(res,LINE(vec2(0.241667,0.95), vec2(0.25,0.95))); res=max(res,LINE(vec2(0.283333,0.95), vec2(0.408333,0.95))); res=max(res,LINE(vec2(0.633333,0.95), vec2(0.65,0.95))); res=max(res,LINE(vec2(0.716667,0.95), vec2(0.775,0.95))); res=max(res,LINE(vec2(0.85,0.95), vec2(0.858333,0.95))); 
                     res=max(res,LINE(vec2(0.125,0.941667), vec2(0.141667,0.941667))); res=max(res,LINE(vec2(0.158333,0.941667), vec2(0.158333,0.941667))); res=max(res,LINE(vec2(0.208333,0.941667), vec2(0.208333,0.941667))); res=max(res,LINE(vec2(0.225,0.941667), vec2(0.241667,0.941667))); res=max(res,LINE(vec2(0.316667,0.941667), vec2(0.408333,0.941667))); res=max(res,LINE(vec2(0.625,0.941667), vec2(0.625,0.941667))); res=max(res,LINE(vec2(0.708333,0.941667), vec2(0.775,0.941667))); 
                     res=max(res,LINE(vec2(0.125,0.933333), vec2(0.15,0.933333))); res=max(res,LINE(vec2(0.175,0.933333), vec2(0.175,0.933333))); res=max(res,LINE(vec2(0.191667,0.933333), vec2(0.258333,0.933333))); res=max(res,LINE(vec2(0.316667,0.933333), vec2(0.4,0.933333))); res=max(res,LINE(vec2(0.616667,0.933333), vec2(0.616667,0.933333))); res=max(res,LINE(vec2(0.658333,0.933333), vec2(0.658333,0.933333))); res=max(res,LINE(vec2(0.691667,0.933333), vec2(0.791667,0.933333))); res=max(res,LINE(vec2(0.808333,0.933333), vec2(0.816667,0.933333))); 
                     res=max(res,LINE(vec2(0.125,0.925), vec2(0.175,0.925))); res=max(res,LINE(vec2(0.191667,0.925), vec2(0.208333,0.925))); res=max(res,LINE(vec2(0.225,0.925), vec2(0.266667,0.925))); res=max(res,LINE(vec2(0.316667,0.925), vec2(0.4,0.925))); res=max(res,LINE(vec2(0.608333,0.925), vec2(0.616667,0.925))); res=max(res,LINE(vec2(0.658333,0.925), vec2(0.658333,0.925))); res=max(res,LINE(vec2(0.683333,0.925), vec2(0.816667,0.925))); res=max(res,LINE(vec2(0.841667,0.925), vec2(0.875,0.925))); 
                     res=max(res,LINE(vec2(0.025,0.916667), vec2(0.075,0.916667))); res=max(res,LINE(vec2(0.108333,0.916667), vec2(0.125,0.916667))); res=max(res,LINE(vec2(0.15,0.916667), vec2(0.183333,0.916667))); res=max(res,LINE(vec2(0.208333,0.916667), vec2(0.208333,0.916667))); res=max(res,LINE(vec2(0.225,0.916667), vec2(0.275,0.916667))); res=max(res,LINE(vec2(0.316667,0.916667), vec2(0.4,0.916667))); res=max(res,LINE(vec2(0.533333,0.916667), vec2(0.55,0.916667))); res=max(res,LINE(vec2(0.658333,0.916667), vec2(0.658333,0.916667))); res=max(res,LINE(vec2(0.675,0.916667), vec2(0.9,0.916667))); 
                     res=max(res,LINE(vec2(0.0166667,0.908333), vec2(0.275,0.908333))); res=max(res,LINE(vec2(0.325,0.908333), vec2(0.391667,0.908333))); res=max(res,LINE(vec2(0.508333,0.908333), vec2(0.566667,0.908333))); res=max(res,LINE(vec2(0.6,0.908333), vec2(0.6,0.908333))); res=max(res,LINE(vec2(0.625,0.908333), vec2(0.958333,0.908333))); 
                     res=max(res,LINE(vec2(0.025,0.9), vec2(0.241667,0.9))); res=max(res,LINE(vec2(0.258333,0.9), vec2(0.258333,0.9))); res=max(res,LINE(vec2(0.275,0.9), vec2(0.291667,0.9))); res=max(res,LINE(vec2(0.325,0.9), vec2(0.375,0.9))); res=max(res,LINE(vec2(0.508333,0.9), vec2(0.575,0.9))); res=max(res,LINE(vec2(0.6,0.9), vec2(0.658333,0.9))); res=max(res,LINE(vec2(0.675,0.9), vec2(0.975,0.9))); 
                     res=max(res,LINE(vec2(0.0166667,0.891667), vec2(0.233333,0.891667))); res=max(res,LINE(vec2(0.266667,0.891667), vec2(0.275,0.891667))); res=max(res,LINE(vec2(0.291667,0.891667), vec2(0.291667,0.891667))); res=max(res,LINE(vec2(0.325,0.891667), vec2(0.366667,0.891667))); res=max(res,LINE(vec2(0.408333,0.891667), vec2(0.425,0.891667))); res=max(res,LINE(vec2(0.508333,0.891667), vec2(0.558333,0.891667))); res=max(res,LINE(vec2(0.583333,0.891667), vec2(0.983333,0.891667))); 
                     res=max(res,LINE(vec2(0.0166667,0.883333), vec2(0.241667,0.883333))); res=max(res,LINE(vec2(0.258333,0.883333), vec2(0.283333,0.883333))); res=max(res,LINE(vec2(0.325,0.883333), vec2(0.35,0.883333))); res=max(res,LINE(vec2(0.408333,0.883333), vec2(0.425,0.883333))); res=max(res,LINE(vec2(0.5,0.883333), vec2(0.958333,0.883333))); res=max(res,LINE(vec2(0.975,0.883333), vec2(0.975,0.883333))); 
                     res=max(res,LINE(vec2(0,0.875), vec2(0,0.875))); res=max(res,LINE(vec2(0.0166667,0.875), vec2(0.216667,0.875))); res=max(res,LINE(vec2(0.233333,0.875), vec2(0.241667,0.875))); res=max(res,LINE(vec2(0.275,0.875), vec2(0.283333,0.875))); res=max(res,LINE(vec2(0.333333,0.875), vec2(0.35,0.875))); res=max(res,LINE(vec2(0.491667,0.875), vec2(0.516667,0.875))); res=max(res,LINE(vec2(0.533333,0.875), vec2(0.958333,0.875))); 
                     res=max(res,LINE(vec2(0.0166667,0.866667), vec2(0.208333,0.866667))); res=max(res,LINE(vec2(0.258333,0.866667), vec2(0.266667,0.866667))); res=max(res,LINE(vec2(0.333333,0.866667), vec2(0.35,0.866667))); res=max(res,LINE(vec2(0.483333,0.866667), vec2(0.508333,0.866667))); res=max(res,LINE(vec2(0.533333,0.866667), vec2(0.941667,0.866667))); 
                     res=max(res,LINE(vec2(0.00833333,0.858333), vec2(0.208333,0.858333))); res=max(res,LINE(vec2(0.258333,0.858333), vec2(0.275,0.858333))); res=max(res,LINE(vec2(0.341667,0.858333), vec2(0.341667,0.858333))); res=max(res,LINE(vec2(0.483333,0.858333), vec2(0.516667,0.858333))); res=max(res,LINE(vec2(0.533333,0.858333), vec2(0.891667,0.858333))); res=max(res,LINE(vec2(0.916667,0.858333), vec2(0.933333,0.858333))); 
                     res=max(res,LINE(vec2(0.025,0.85), vec2(0.0416667,0.85))); res=max(res,LINE(vec2(0.0916667,0.85), vec2(0.208333,0.85))); res=max(res,LINE(vec2(0.258333,0.85), vec2(0.275,0.85))); res=max(res,LINE(vec2(0.291667,0.85), vec2(0.291667,0.85))); res=max(res,LINE(vec2(0.458333,0.85), vec2(0.458333,0.85))); res=max(res,LINE(vec2(0.483333,0.85), vec2(0.516667,0.85))); res=max(res,LINE(vec2(0.533333,0.85), vec2(0.85,0.85))); res=max(res,LINE(vec2(0.866667,0.85), vec2(0.891667,0.85))); res=max(res,LINE(vec2(0.908333,0.85), vec2(0.916667,0.85))); 
                     res=max(res,LINE(vec2(0.0333333,0.841667), vec2(0.0333333,0.841667))); res=max(res,LINE(vec2(0.05,0.841667), vec2(0.05,0.841667))); res=max(res,LINE(vec2(0.1,0.841667), vec2(0.208333,0.841667))); res=max(res,LINE(vec2(0.258333,0.841667), vec2(0.291667,0.841667))); res=max(res,LINE(vec2(0.45,0.841667), vec2(0.458333,0.841667))); res=max(res,LINE(vec2(0.5,0.841667), vec2(0.508333,0.841667))); res=max(res,LINE(vec2(0.533333,0.841667), vec2(0.85,0.841667))); res=max(res,LINE(vec2(0.9,0.841667), vec2(0.908333,0.841667))); 
                     res=max(res,LINE(vec2(0.0333333,0.833333), vec2(0.0333333,0.833333))); res=max(res,LINE(vec2(0.1,0.833333), vec2(0.225,0.833333))); res=max(res,LINE(vec2(0.25,0.833333), vec2(0.291667,0.833333))); res=max(res,LINE(vec2(0.45,0.833333), vec2(0.458333,0.833333))); res=max(res,LINE(vec2(0.491667,0.833333), vec2(0.508333,0.833333))); res=max(res,LINE(vec2(0.525,0.833333), vec2(0.841667,0.833333))); res=max(res,LINE(vec2(0.9,0.833333), vec2(0.908333,0.833333))); 
                     res=max(res,LINE(vec2(0.0166667,0.825), vec2(0.0166667,0.825))); res=max(res,LINE(vec2(0.108333,0.825), vec2(0.308333,0.825))); res=max(res,LINE(vec2(0.441667,0.825), vec2(0.458333,0.825))); res=max(res,LINE(vec2(0.491667,0.825), vec2(0.491667,0.825))); res=max(res,LINE(vec2(0.516667,0.825), vec2(0.841667,0.825))); res=max(res,LINE(vec2(0.9,0.825), vec2(0.908333,0.825))); 
                     res=max(res,LINE(vec2(0.00833333,0.816667), vec2(0.00833333,0.816667))); res=max(res,LINE(vec2(0.116667,0.816667), vec2(0.308333,0.816667))); res=max(res,LINE(vec2(0.441667,0.816667), vec2(0.466667,0.816667))); res=max(res,LINE(vec2(0.483333,0.816667), vec2(0.858333,0.816667))); res=max(res,LINE(vec2(0.9,0.816667), vec2(0.9,0.816667))); 
                     res=max(res,LINE(vec2(0.116667,0.808333), vec2(0.308333,0.808333))); res=max(res,LINE(vec2(0.441667,0.808333), vec2(0.441667,0.808333))); res=max(res,LINE(vec2(0.458333,0.808333), vec2(0.466667,0.808333))); res=max(res,LINE(vec2(0.483333,0.808333), vec2(0.858333,0.808333))); res=max(res,LINE(vec2(0.9,0.808333), vec2(0.9,0.808333))); res=max(res,LINE(vec2(0.966667,0.808333), vec2(0.975,0.808333))); 
                     res=max(res,LINE(vec2(0.116667,0.8), vec2(0.3,0.8))); res=max(res,LINE(vec2(0.475,0.8), vec2(0.858333,0.8))); 
                     res=max(res,LINE(vec2(0.125,0.791667), vec2(0.283333,0.791667))); res=max(res,LINE(vec2(0.308333,0.791667), vec2(0.316667,0.791667))); res=max(res,LINE(vec2(0.466667,0.791667), vec2(0.858333,0.791667))); 
                     res=max(res,LINE(vec2(0.125,0.783333), vec2(0.216667,0.783333))); res=max(res,LINE(vec2(0.233333,0.783333), vec2(0.283333,0.783333))); res=max(res,LINE(vec2(0.308333,0.783333), vec2(0.316667,0.783333))); res=max(res,LINE(vec2(0.458333,0.783333), vec2(0.841667,0.783333))); 
                     res=max(res,LINE(vec2(0.133333,0.775), vec2(0.3,0.775))); res=max(res,LINE(vec2(0.466667,0.775), vec2(0.558333,0.775))); res=max(res,LINE(vec2(0.575,0.775), vec2(0.6,0.775))); res=max(res,LINE(vec2(0.616667,0.775), vec2(0.625,0.775))); res=max(res,LINE(vec2(0.641667,0.775), vec2(0.841667,0.775))); 
                     res=max(res,LINE(vec2(0.133333,0.766667), vec2(0.233333,0.766667))); res=max(res,LINE(vec2(0.25,0.766667), vec2(0.275,0.766667))); res=max(res,LINE(vec2(0.291667,0.766667), vec2(0.291667,0.766667))); res=max(res,LINE(vec2(0.466667,0.766667), vec2(0.541667,0.766667))); res=max(res,LINE(vec2(0.558333,0.766667), vec2(0.558333,0.766667))); res=max(res,LINE(vec2(0.575,0.766667), vec2(0.591667,0.766667))); res=max(res,LINE(vec2(0.608333,0.766667), vec2(0.625,0.766667))); res=max(res,LINE(vec2(0.641667,0.766667), vec2(0.841667,0.766667))); 
                     res=max(res,LINE(vec2(0.133333,0.758333), vec2(0.233333,0.758333))); res=max(res,LINE(vec2(0.25,0.758333), vec2(0.275,0.758333))); res=max(res,LINE(vec2(0.45,0.758333), vec2(0.483333,0.758333))); res=max(res,LINE(vec2(0.5,0.758333), vec2(0.5,0.758333))); res=max(res,LINE(vec2(0.516667,0.758333), vec2(0.541667,0.758333))); res=max(res,LINE(vec2(0.583333,0.758333), vec2(0.591667,0.758333))); res=max(res,LINE(vec2(0.608333,0.758333), vec2(0.833333,0.758333))); res=max(res,LINE(vec2(0.858333,0.758333), vec2(0.866667,0.758333))); 
                     res=max(res,LINE(vec2(0.133333,0.75), vec2(0.266667,0.75))); res=max(res,LINE(vec2(0.45,0.75), vec2(0.475,0.75))); res=max(res,LINE(vec2(0.491667,0.75), vec2(0.508333,0.75))); res=max(res,LINE(vec2(0.525,0.75), vec2(0.541667,0.75))); res=max(res,LINE(vec2(0.558333,0.75), vec2(0.558333,0.75))); res=max(res,LINE(vec2(0.583333,0.75), vec2(0.6,0.75))); res=max(res,LINE(vec2(0.616667,0.75), vec2(0.825,0.75))); res=max(res,LINE(vec2(0.85,0.75), vec2(0.858333,0.75))); 
                     res=max(res,LINE(vec2(0.133333,0.741667), vec2(0.266667,0.741667))); res=max(res,LINE(vec2(0.45,0.741667), vec2(0.466667,0.741667))); res=max(res,LINE(vec2(0.491667,0.741667), vec2(0.491667,0.741667))); res=max(res,LINE(vec2(0.508333,0.741667), vec2(0.6,0.741667))); res=max(res,LINE(vec2(0.616667,0.741667), vec2(0.791667,0.741667))); res=max(res,LINE(vec2(0.808333,0.741667), vec2(0.816667,0.741667))); 
                     res=max(res,LINE(vec2(0.133333,0.733333), vec2(0.258333,0.733333))); res=max(res,LINE(vec2(0.441667,0.733333), vec2(0.475,0.733333))); res=max(res,LINE(vec2(0.491667,0.733333), vec2(0.491667,0.733333))); res=max(res,LINE(vec2(0.525,0.733333), vec2(0.6,0.733333))); res=max(res,LINE(vec2(0.616667,0.733333), vec2(0.8,0.733333))); res=max(res,LINE(vec2(0.816667,0.733333), vec2(0.816667,0.733333))); res=max(res,LINE(vec2(0.85,0.733333), vec2(0.85,0.733333))); 
                     res=max(res,LINE(vec2(0.133333,0.725), vec2(0.258333,0.725))); res=max(res,LINE(vec2(0.45,0.725), vec2(0.458333,0.725))); res=max(res,LINE(vec2(0.508333,0.725), vec2(0.508333,0.725))); res=max(res,LINE(vec2(0.525,0.725), vec2(0.525,0.725))); res=max(res,LINE(vec2(0.541667,0.725), vec2(0.6,0.725))); res=max(res,LINE(vec2(0.616667,0.725), vec2(0.791667,0.725))); res=max(res,LINE(vec2(0.816667,0.725), vec2(0.816667,0.725))); res=max(res,LINE(vec2(0.85,0.725), vec2(0.85,0.725))); 
                     res=max(res,LINE(vec2(0.133333,0.716667), vec2(0.258333,0.716667))); res=max(res,LINE(vec2(0.45,0.716667), vec2(0.45,0.716667))); res=max(res,LINE(vec2(0.475,0.716667), vec2(0.491667,0.716667))); res=max(res,LINE(vec2(0.533333,0.716667), vec2(0.533333,0.716667))); res=max(res,LINE(vec2(0.55,0.716667), vec2(0.791667,0.716667))); res=max(res,LINE(vec2(0.816667,0.716667), vec2(0.816667,0.716667))); res=max(res,LINE(vec2(0.841667,0.716667), vec2(0.85,0.716667))); 
                     res=max(res,LINE(vec2(0.141667,0.708333), vec2(0.25,0.708333))); res=max(res,LINE(vec2(0.45,0.708333), vec2(0.491667,0.708333))); res=max(res,LINE(vec2(0.533333,0.708333), vec2(0.533333,0.708333))); res=max(res,LINE(vec2(0.558333,0.708333), vec2(0.791667,0.708333))); res=max(res,LINE(vec2(0.816667,0.708333), vec2(0.816667,0.708333))); res=max(res,LINE(vec2(0.833333,0.708333), vec2(0.85,0.708333))); 
                     res=max(res,LINE(vec2(0.15,0.7), vec2(0.25,0.7))); res=max(res,LINE(vec2(0.45,0.7), vec2(0.491667,0.7))); res=max(res,LINE(vec2(0.566667,0.7), vec2(0.791667,0.7))); res=max(res,LINE(vec2(0.825,0.7), vec2(0.833333,0.7))); 
                     res=max(res,LINE(vec2(0.15,0.691667), vec2(0.241667,0.691667))); res=max(res,LINE(vec2(0.441667,0.691667), vec2(0.508333,0.691667))); res=max(res,LINE(vec2(0.525,0.691667), vec2(0.525,0.691667))); res=max(res,LINE(vec2(0.566667,0.691667), vec2(0.8,0.691667))); res=max(res,LINE(vec2(0.825,0.691667), vec2(0.825,0.691667))); 
                     res=max(res,LINE(vec2(0.15,0.683333), vec2(0.241667,0.683333))); res=max(res,LINE(vec2(0.441667,0.683333), vec2(0.8,0.683333))); 
                     res=max(res,LINE(vec2(0.158333,0.675), vec2(0.216667,0.675))); res=max(res,LINE(vec2(0.241667,0.675), vec2(0.241667,0.675))); res=max(res,LINE(vec2(0.441667,0.675), vec2(0.591667,0.675))); res=max(res,LINE(vec2(0.608333,0.675), vec2(0.8,0.675))); 
                     res=max(res,LINE(vec2(0.166667,0.666667), vec2(0.2,0.666667))); res=max(res,LINE(vec2(0.241667,0.666667), vec2(0.241667,0.666667))); res=max(res,LINE(vec2(0.425,0.666667), vec2(0.8,0.666667))); 
                     res=max(res,LINE(vec2(0.158333,0.658333), vec2(0.158333,0.658333))); res=max(res,LINE(vec2(0.175,0.658333), vec2(0.2,0.658333))); res=max(res,LINE(vec2(0.25,0.658333), vec2(0.25,0.658333))); res=max(res,LINE(vec2(0.433333,0.658333), vec2(0.6,0.658333))); res=max(res,LINE(vec2(0.616667,0.658333), vec2(0.791667,0.658333))); 
                     res=max(res,LINE(vec2(0.175,0.65), vec2(0.2,0.65))); res=max(res,LINE(vec2(0.258333,0.65), vec2(0.258333,0.65))); res=max(res,LINE(vec2(0.433333,0.65), vec2(0.558333,0.65))); res=max(res,LINE(vec2(0.575,0.65), vec2(0.608333,0.65))); res=max(res,LINE(vec2(0.633333,0.65), vec2(0.8,0.65))); 
                     res=max(res,LINE(vec2(0.166667,0.641667), vec2(0.191667,0.641667))); res=max(res,LINE(vec2(0.425,0.641667), vec2(0.558333,0.641667))); res=max(res,LINE(vec2(0.575,0.641667), vec2(0.625,0.641667))); res=max(res,LINE(vec2(0.658333,0.641667), vec2(0.783333,0.641667))); res=max(res,LINE(vec2(0.8,0.641667), vec2(0.8,0.641667))); 
                     res=max(res,LINE(vec2(0.183333,0.633333), vec2(0.191667,0.633333))); res=max(res,LINE(vec2(0.25,0.633333), vec2(0.25,0.633333))); res=max(res,LINE(vec2(0.266667,0.633333), vec2(0.266667,0.633333))); res=max(res,LINE(vec2(0.425,0.633333), vec2(0.625,0.633333))); res=max(res,LINE(vec2(0.658333,0.633333), vec2(0.775,0.633333))); 
                     res=max(res,LINE(vec2(0.183333,0.625), vec2(0.2,0.625))); res=max(res,LINE(vec2(0.225,0.625), vec2(0.225,0.625))); res=max(res,LINE(vec2(0.258333,0.625), vec2(0.266667,0.625))); res=max(res,LINE(vec2(0.425,0.625), vec2(0.625,0.625))); res=max(res,LINE(vec2(0.666667,0.625), vec2(0.7,0.625))); res=max(res,LINE(vec2(0.725,0.625), vec2(0.758333,0.625))); 
                     res=max(res,LINE(vec2(0.0416667,0.616667), vec2(0.0416667,0.616667))); res=max(res,LINE(vec2(0.183333,0.616667), vec2(0.2,0.616667))); res=max(res,LINE(vec2(0.225,0.616667), vec2(0.225,0.616667))); res=max(res,LINE(vec2(0.266667,0.616667), vec2(0.275,0.616667))); res=max(res,LINE(vec2(0.425,0.616667), vec2(0.566667,0.616667))); res=max(res,LINE(vec2(0.583333,0.616667), vec2(0.625,0.616667))); res=max(res,LINE(vec2(0.666667,0.616667), vec2(0.7,0.616667))); res=max(res,LINE(vec2(0.725,0.616667), vec2(0.75,0.616667))); res=max(res,LINE(vec2(0.766667,0.616667), vec2(0.766667,0.616667))); 
                     res=max(res,LINE(vec2(0.191667,0.608333), vec2(0.225,0.608333))); res=max(res,LINE(vec2(0.258333,0.608333), vec2(0.266667,0.608333))); res=max(res,LINE(vec2(0.283333,0.608333), vec2(0.283333,0.608333))); res=max(res,LINE(vec2(0.425,0.608333), vec2(0.566667,0.608333))); res=max(res,LINE(vec2(0.583333,0.608333), vec2(0.616667,0.608333))); res=max(res,LINE(vec2(0.675,0.608333), vec2(0.691667,0.608333))); res=max(res,LINE(vec2(0.733333,0.608333), vec2(0.766667,0.608333))); res=max(res,LINE(vec2(0.8,0.608333), vec2(0.8,0.608333))); 
                     res=max(res,LINE(vec2(0.2,0.6), vec2(0.225,0.6))); res=max(res,LINE(vec2(0.4,0.6), vec2(0.4,0.6))); res=max(res,LINE(vec2(0.425,0.6), vec2(0.566667,0.6))); res=max(res,LINE(vec2(0.591667,0.6), vec2(0.608333,0.6))); res=max(res,LINE(vec2(0.675,0.6), vec2(0.691667,0.6))); res=max(res,LINE(vec2(0.733333,0.6), vec2(0.758333,0.6))); res=max(res,LINE(vec2(0.8,0.6), vec2(0.8,0.6))); 
                     res=max(res,LINE(vec2(0.216667,0.591667), vec2(0.233333,0.591667))); res=max(res,LINE(vec2(0.425,0.591667), vec2(0.575,0.591667))); res=max(res,LINE(vec2(0.591667,0.591667), vec2(0.608333,0.591667))); res=max(res,LINE(vec2(0.675,0.591667), vec2(0.683333,0.591667))); res=max(res,LINE(vec2(0.741667,0.591667), vec2(0.758333,0.591667))); res=max(res,LINE(vec2(0.8,0.591667), vec2(0.8,0.591667))); res=max(res,LINE(vec2(0.866667,0.591667), vec2(0.866667,0.591667))); 
                     res=max(res,LINE(vec2(0.216667,0.583333), vec2(0.233333,0.583333))); res=max(res,LINE(vec2(0.3,0.583333), vec2(0.3,0.583333))); res=max(res,LINE(vec2(0.425,0.583333), vec2(0.575,0.583333))); res=max(res,LINE(vec2(0.591667,0.583333), vec2(0.6,0.583333))); res=max(res,LINE(vec2(0.675,0.583333), vec2(0.683333,0.583333))); res=max(res,LINE(vec2(0.741667,0.583333), vec2(0.766667,0.583333))); res=max(res,LINE(vec2(0.8,0.583333), vec2(0.8,0.583333))); 
                     res=max(res,LINE(vec2(0.233333,0.575), vec2(0.233333,0.575))); res=max(res,LINE(vec2(0.425,0.575), vec2(0.583333,0.575))); res=max(res,LINE(vec2(0.675,0.575), vec2(0.683333,0.575))); res=max(res,LINE(vec2(0.75,0.575), vec2(0.766667,0.575))); res=max(res,LINE(vec2(0.8,0.575), vec2(0.808333,0.575))); 
                     res=max(res,LINE(vec2(0.233333,0.566667), vec2(0.233333,0.566667))); res=max(res,LINE(vec2(0.266667,0.566667), vec2(0.275,0.566667))); res=max(res,LINE(vec2(0.291667,0.566667), vec2(0.3,0.566667))); res=max(res,LINE(vec2(0.425,0.566667), vec2(0.6,0.566667))); res=max(res,LINE(vec2(0.675,0.566667), vec2(0.683333,0.566667))); res=max(res,LINE(vec2(0.75,0.566667), vec2(0.758333,0.566667))); res=max(res,LINE(vec2(0.808333,0.566667), vec2(0.808333,0.566667))); 
                     res=max(res,LINE(vec2(0.233333,0.558333), vec2(0.233333,0.558333))); res=max(res,LINE(vec2(0.266667,0.558333), vec2(0.3,0.558333))); res=max(res,LINE(vec2(0.433333,0.558333), vec2(0.6,0.558333))); res=max(res,LINE(vec2(0.683333,0.558333), vec2(0.683333,0.558333))); res=max(res,LINE(vec2(0.741667,0.558333), vec2(0.741667,0.558333))); res=max(res,LINE(vec2(0.758333,0.558333), vec2(0.758333,0.558333))); res=max(res,LINE(vec2(0.791667,0.558333), vec2(0.791667,0.558333))); 
                     res=max(res,LINE(vec2(0.241667,0.55), vec2(0.3,0.55))); res=max(res,LINE(vec2(0.433333,0.55), vec2(0.6,0.55))); res=max(res,LINE(vec2(0.741667,0.55), vec2(0.741667,0.55))); res=max(res,LINE(vec2(0.808333,0.55), vec2(0.808333,0.55))); 
                     res=max(res,LINE(vec2(0.258333,0.541667), vec2(0.308333,0.541667))); res=max(res,LINE(vec2(0.441667,0.541667), vec2(0.6,0.541667))); res=max(res,LINE(vec2(0.691667,0.541667), vec2(0.691667,0.541667))); res=max(res,LINE(vec2(0.741667,0.541667), vec2(0.741667,0.541667))); res=max(res,LINE(vec2(0.808333,0.541667), vec2(0.808333,0.541667))); 
                     res=max(res,LINE(vec2(0.258333,0.533333), vec2(0.316667,0.533333))); res=max(res,LINE(vec2(0.441667,0.533333), vec2(0.458333,0.533333))); res=max(res,LINE(vec2(0.483333,0.533333), vec2(0.6,0.533333))); res=max(res,LINE(vec2(0.733333,0.533333), vec2(0.75,0.533333))); res=max(res,LINE(vec2(0.783333,0.533333), vec2(0.791667,0.533333))); 
                     res=max(res,LINE(vec2(0.258333,0.525), vec2(0.325,0.525))); res=max(res,LINE(vec2(0.491667,0.525), vec2(0.591667,0.525))); res=max(res,LINE(vec2(0.733333,0.525), vec2(0.733333,0.525))); res=max(res,LINE(vec2(0.75,0.525), vec2(0.75,0.525))); res=max(res,LINE(vec2(0.783333,0.525), vec2(0.791667,0.525))); 
                     res=max(res,LINE(vec2(0.258333,0.516667), vec2(0.325,0.516667))); res=max(res,LINE(vec2(0.5,0.516667), vec2(0.591667,0.516667))); res=max(res,LINE(vec2(0.741667,0.516667), vec2(0.75,0.516667))); res=max(res,LINE(vec2(0.775,0.516667), vec2(0.783333,0.516667))); 
                     res=max(res,LINE(vec2(0.25,0.508333), vec2(0.325,0.508333))); res=max(res,LINE(vec2(0.5,0.508333), vec2(0.583333,0.508333))); res=max(res,LINE(vec2(0.733333,0.508333), vec2(0.75,0.508333))); res=max(res,LINE(vec2(0.766667,0.508333), vec2(0.816667,0.508333))); 
                     res=max(res,LINE(vec2(0.216667,0.5), vec2(0.216667,0.5))); res=max(res,LINE(vec2(0.25,0.5), vec2(0.333333,0.5))); res=max(res,LINE(vec2(0.5,0.5), vec2(0.55,0.5))); res=max(res,LINE(vec2(0.566667,0.5), vec2(0.583333,0.5))); res=max(res,LINE(vec2(0.741667,0.5), vec2(0.75,0.5))); res=max(res,LINE(vec2(0.766667,0.5), vec2(0.783333,0.5))); res=max(res,LINE(vec2(0.816667,0.5), vec2(0.825,0.5))); 
                     res=max(res,LINE(vec2(0.25,0.491667), vec2(0.341667,0.491667))); res=max(res,LINE(vec2(0.5,0.491667), vec2(0.575,0.491667))); res=max(res,LINE(vec2(0.75,0.491667), vec2(0.75,0.491667))); res=max(res,LINE(vec2(0.775,0.491667), vec2(0.783333,0.491667))); res=max(res,LINE(vec2(0.8,0.491667), vec2(0.816667,0.491667))); res=max(res,LINE(vec2(0.833333,0.491667), vec2(0.841667,0.491667))); 
                     res=max(res,LINE(vec2(0.25,0.483333), vec2(0.358333,0.483333))); res=max(res,LINE(vec2(0.5,0.483333), vec2(0.575,0.483333))); res=max(res,LINE(vec2(0.75,0.483333), vec2(0.758333,0.483333))); res=max(res,LINE(vec2(0.775,0.483333), vec2(0.783333,0.483333))); res=max(res,LINE(vec2(0.8,0.483333), vec2(0.8,0.483333))); res=max(res,LINE(vec2(0.833333,0.483333), vec2(0.85,0.483333))); res=max(res,LINE(vec2(0.883333,0.483333), vec2(0.883333,0.483333))); 
                     res=max(res,LINE(vec2(0.25,0.475), vec2(0.358333,0.475))); res=max(res,LINE(vec2(0.5,0.475), vec2(0.575,0.475))); res=max(res,LINE(vec2(0.75,0.475), vec2(0.75,0.475))); res=max(res,LINE(vec2(0.8,0.475), vec2(0.8,0.475))); res=max(res,LINE(vec2(0.833333,0.475), vec2(0.858333,0.475))); res=max(res,LINE(vec2(0.883333,0.475), vec2(0.883333,0.475))); 
                     res=max(res,LINE(vec2(0.25,0.466667), vec2(0.366667,0.466667))); res=max(res,LINE(vec2(0.5,0.466667), vec2(0.575,0.466667))); res=max(res,LINE(vec2(0.758333,0.466667), vec2(0.758333,0.466667))); res=max(res,LINE(vec2(0.85,0.466667), vec2(0.875,0.466667))); res=max(res,LINE(vec2(0.891667,0.466667), vec2(0.891667,0.466667))); 
                     res=max(res,LINE(vec2(0.25,0.458333), vec2(0.366667,0.458333))); res=max(res,LINE(vec2(0.508333,0.458333), vec2(0.541667,0.458333))); res=max(res,LINE(vec2(0.558333,0.458333), vec2(0.575,0.458333))); res=max(res,LINE(vec2(0.758333,0.458333), vec2(0.775,0.458333))); res=max(res,LINE(vec2(0.85,0.458333), vec2(0.866667,0.458333))); 
                     res=max(res,LINE(vec2(0.25,0.45), vec2(0.366667,0.45))); res=max(res,LINE(vec2(0.508333,0.45), vec2(0.566667,0.45))); res=max(res,LINE(vec2(0.783333,0.45), vec2(0.8,0.45))); res=max(res,LINE(vec2(0.858333,0.45), vec2(0.858333,0.45))); res=max(res,LINE(vec2(0.908333,0.45), vec2(0.908333,0.45))); 
                     res=max(res,LINE(vec2(0.258333,0.441667), vec2(0.366667,0.441667))); res=max(res,LINE(vec2(0.508333,0.441667), vec2(0.575,0.441667))); res=max(res,LINE(vec2(0.808333,0.441667), vec2(0.808333,0.441667))); res=max(res,LINE(vec2(0.875,0.441667), vec2(0.875,0.441667))); 
                     res=max(res,LINE(vec2(0.258333,0.433333), vec2(0.358333,0.433333))); res=max(res,LINE(vec2(0.508333,0.433333), vec2(0.575,0.433333))); res=max(res,LINE(vec2(0.825,0.433333), vec2(0.825,0.433333))); res=max(res,LINE(vec2(0.841667,0.433333), vec2(0.841667,0.433333))); res=max(res,LINE(vec2(0.858333,0.433333), vec2(0.858333,0.433333))); 
                     res=max(res,LINE(vec2(0.258333,0.425), vec2(0.358333,0.425))); res=max(res,LINE(vec2(0.508333,0.425), vec2(0.575,0.425))); res=max(res,LINE(vec2(0.825,0.425), vec2(0.841667,0.425))); res=max(res,LINE(vec2(0.858333,0.425), vec2(0.858333,0.425))); 
                     res=max(res,LINE(vec2(0.0666667,0.416667), vec2(0.0666667,0.416667))); res=max(res,LINE(vec2(0.258333,0.416667), vec2(0.358333,0.416667))); res=max(res,LINE(vec2(0.5,0.416667), vec2(0.575,0.416667))); res=max(res,LINE(vec2(0.6,0.416667), vec2(0.6,0.416667))); res=max(res,LINE(vec2(0.816667,0.416667), vec2(0.841667,0.416667))); res=max(res,LINE(vec2(0.858333,0.416667), vec2(0.858333,0.416667))); res=max(res,LINE(vec2(0.983333,0.416667), vec2(0.983333,0.416667))); 
                     res=max(res,LINE(vec2(0.266667,0.408333), vec2(0.358333,0.408333))); res=max(res,LINE(vec2(0.5,0.408333), vec2(0.575,0.408333))); res=max(res,LINE(vec2(0.591667,0.408333), vec2(0.6,0.408333))); res=max(res,LINE(vec2(0.808333,0.408333), vec2(0.841667,0.408333))); res=max(res,LINE(vec2(0.858333,0.408333), vec2(0.858333,0.408333))); res=max(res,LINE(vec2(0.925,0.408333), vec2(0.925,0.408333))); 
                     res=max(res,LINE(vec2(0.275,0.4), vec2(0.358333,0.4))); res=max(res,LINE(vec2(0.5,0.4), vec2(0.566667,0.4))); res=max(res,LINE(vec2(0.591667,0.4), vec2(0.6,0.4))); res=max(res,LINE(vec2(0.808333,0.4), vec2(0.841667,0.4))); res=max(res,LINE(vec2(0.858333,0.4), vec2(0.866667,0.4))); 
                     res=max(res,LINE(vec2(0.275,0.391667), vec2(0.35,0.391667))); res=max(res,LINE(vec2(0.5,0.391667), vec2(0.566667,0.391667))); res=max(res,LINE(vec2(0.591667,0.391667), vec2(0.6,0.391667))); res=max(res,LINE(vec2(0.8,0.391667), vec2(0.866667,0.391667))); 
                     res=max(res,LINE(vec2(0.275,0.383333), vec2(0.35,0.383333))); res=max(res,LINE(vec2(0.508333,0.383333), vec2(0.558333,0.383333))); res=max(res,LINE(vec2(0.591667,0.383333), vec2(0.6,0.383333))); res=max(res,LINE(vec2(0.625,0.383333), vec2(0.625,0.383333))); res=max(res,LINE(vec2(0.8,0.383333), vec2(0.866667,0.383333))); res=max(res,LINE(vec2(0.916667,0.383333), vec2(0.916667,0.383333))); 
                     res=max(res,LINE(vec2(0.275,0.375), vec2(0.35,0.375))); res=max(res,LINE(vec2(0.508333,0.375), vec2(0.558333,0.375))); res=max(res,LINE(vec2(0.591667,0.375), vec2(0.6,0.375))); res=max(res,LINE(vec2(0.783333,0.375), vec2(0.875,0.375))); res=max(res,LINE(vec2(0.925,0.375), vec2(0.925,0.375))); 
                     res=max(res,LINE(vec2(0.275,0.366667), vec2(0.35,0.366667))); res=max(res,LINE(vec2(0.508333,0.366667), vec2(0.558333,0.366667))); res=max(res,LINE(vec2(0.591667,0.366667), vec2(0.591667,0.366667))); res=max(res,LINE(vec2(0.783333,0.366667), vec2(0.875,0.366667))); 
                     res=max(res,LINE(vec2(0.275,0.358333), vec2(0.333333,0.358333))); res=max(res,LINE(vec2(0.508333,0.358333), vec2(0.558333,0.358333))); res=max(res,LINE(vec2(0.591667,0.358333), vec2(0.591667,0.358333))); res=max(res,LINE(vec2(0.783333,0.358333), vec2(0.883333,0.358333))); 
                     res=max(res,LINE(vec2(0.275,0.35), vec2(0.333333,0.35))); res=max(res,LINE(vec2(0.508333,0.35), vec2(0.55,0.35))); res=max(res,LINE(vec2(0.591667,0.35), vec2(0.591667,0.35))); res=max(res,LINE(vec2(0.783333,0.35), vec2(0.883333,0.35))); 
                     res=max(res,LINE(vec2(0.275,0.341667), vec2(0.333333,0.341667))); res=max(res,LINE(vec2(0.508333,0.341667), vec2(0.55,0.341667))); res=max(res,LINE(vec2(0.783333,0.341667), vec2(0.883333,0.341667))); 
                     res=max(res,LINE(vec2(0.275,0.333333), vec2(0.333333,0.333333))); res=max(res,LINE(vec2(0.516667,0.333333), vec2(0.55,0.333333))); res=max(res,LINE(vec2(0.783333,0.333333), vec2(0.883333,0.333333))); 
                     res=max(res,LINE(vec2(0.275,0.325), vec2(0.325,0.325))); res=max(res,LINE(vec2(0.516667,0.325), vec2(0.55,0.325))); res=max(res,LINE(vec2(0.783333,0.325), vec2(0.883333,0.325))); 
                     res=max(res,LINE(vec2(0.275,0.316667), vec2(0.325,0.316667))); res=max(res,LINE(vec2(0.516667,0.316667), vec2(0.55,0.316667))); res=max(res,LINE(vec2(0.783333,0.316667), vec2(0.883333,0.316667))); 
                     res=max(res,LINE(vec2(0.275,0.308333), vec2(0.316667,0.308333))); res=max(res,LINE(vec2(0.516667,0.308333), vec2(0.541667,0.308333))); res=max(res,LINE(vec2(0.783333,0.308333), vec2(0.808333,0.308333))); res=max(res,LINE(vec2(0.841667,0.308333), vec2(0.883333,0.308333))); 
                     res=max(res,LINE(vec2(0.275,0.3), vec2(0.316667,0.3))); res=max(res,LINE(vec2(0.516667,0.3), vec2(0.533333,0.3))); res=max(res,LINE(vec2(0.783333,0.3), vec2(0.791667,0.3))); res=max(res,LINE(vec2(0.85,0.3), vec2(0.875,0.3))); 
                     res=max(res,LINE(vec2(0.275,0.291667), vec2(0.308333,0.291667))); res=max(res,LINE(vec2(0.841667,0.291667), vec2(0.875,0.291667))); res=max(res,LINE(vec2(0.941667,0.291667), vec2(0.941667,0.291667))); 
                     res=max(res,LINE(vec2(0.266667,0.283333), vec2(0.308333,0.283333))); res=max(res,LINE(vec2(0.85,0.283333), vec2(0.875,0.283333))); 
                     res=max(res,LINE(vec2(0.266667,0.275), vec2(0.308333,0.275))); res=max(res,LINE(vec2(0.858333,0.275), vec2(0.866667,0.275))); res=max(res,LINE(vec2(0.95,0.275), vec2(0.95,0.275))); 
                     res=max(res,LINE(vec2(0.266667,0.266667), vec2(0.291667,0.266667))); res=max(res,LINE(vec2(0.95,0.266667), vec2(0.95,0.266667))); 
                     res=max(res,LINE(vec2(0.266667,0.258333), vec2(0.291667,0.258333))); res=max(res,LINE(vec2(0.866667,0.258333), vec2(0.866667,0.258333))); res=max(res,LINE(vec2(0.941667,0.258333), vec2(0.95,0.258333))); 
                     res=max(res,LINE(vec2(0.266667,0.25), vec2(0.291667,0.25))); res=max(res,LINE(vec2(0.866667,0.25), vec2(0.866667,0.25))); res=max(res,LINE(vec2(0.941667,0.25), vec2(0.941667,0.25))); 
                     res=max(res,LINE(vec2(0.266667,0.241667), vec2(0.283333,0.241667))); res=max(res,LINE(vec2(0.933333,0.241667), vec2(0.933333,0.241667))); 
                     res=max(res,LINE(vec2(0.266667,0.233333), vec2(0.283333,0.233333))); res=max(res,LINE(vec2(0.925,0.233333), vec2(0.933333,0.233333))); 
                     res=max(res,LINE(vec2(0.266667,0.225), vec2(0.283333,0.225))); 
                     res=max(res,LINE(vec2(0.266667,0.216667), vec2(0.283333,0.216667))); 
                     res=max(res,LINE(vec2(0.266667,0.208333), vec2(0.275,0.208333))); res=max(res,LINE(vec2(0.658333,0.208333), vec2(0.658333,0.208333))); 
                     res=max(res,LINE(vec2(0.266667,0.2), vec2(0.275,0.2))); 
                     res=max(res,LINE(vec2(0.266667,0.191667), vec2(0.275,0.191667))); res=max(res,LINE(vec2(0.3,0.191667), vec2(0.3,0.191667))); 
                     res=max(res,LINE(vec2(0.266667,0.183333), vec2(0.275,0.183333))); 
                     res=max(res,LINE(vec2(0.316667,0.141667), vec2(0.316667,0.141667))); res=max(res,LINE(vec2(0.341667,0.141667), vec2(0.341667,0.141667))); 
                     res=max(res,LINE(vec2(0.3,0.133333), vec2(0.3,0.133333))); 
                     res=max(res,LINE(vec2(0.308333,0.125), vec2(0.308333,0.125))); 
                     res=max(res,LINE(vec2(0.291667,0.116667), vec2(0.3,0.116667))); res=max(res,LINE(vec2(0.75,0.116667), vec2(0.75,0.116667))); 
                     res=max(res,LINE(vec2(0.283333,0.108333), vec2(0.3,0.108333))); res=max(res,LINE(vec2(0.6,0.108333), vec2(0.616667,0.108333))); res=max(res,LINE(vec2(0.708333,0.108333), vec2(0.783333,0.108333))); res=max(res,LINE(vec2(0.8,0.108333), vec2(0.808333,0.108333))); res=max(res,LINE(vec2(0.825,0.108333), vec2(0.85,0.108333))); 
                     res=max(res,LINE(vec2(0.283333,0.1), vec2(0.283333,0.1))); res=max(res,LINE(vec2(0.591667,0.1), vec2(0.65,0.1))); res=max(res,LINE(vec2(0.691667,0.1), vec2(0.866667,0.1))); 
                     res=max(res,LINE(vec2(0.275,0.0916667), vec2(0.291667,0.0916667))); res=max(res,LINE(vec2(0.558333,0.0916667), vec2(0.566667,0.0916667))); res=max(res,LINE(vec2(0.583333,0.0916667), vec2(0.65,0.0916667))); res=max(res,LINE(vec2(0.675,0.0916667), vec2(0.9,0.0916667))); 
                     res=max(res,LINE(vec2(0.275,0.0833333), vec2(0.3,0.0833333))); res=max(res,LINE(vec2(0.45,0.0833333), vec2(0.458333,0.0833333))); res=max(res,LINE(vec2(0.475,0.0833333), vec2(0.65,0.0833333))); res=max(res,LINE(vec2(0.666667,0.0833333), vec2(0.925,0.0833333))); 
                     res=max(res,LINE(vec2(0.191667,0.075), vec2(0.2,0.075))); res=max(res,LINE(vec2(0.266667,0.075), vec2(0.3,0.075))); res=max(res,LINE(vec2(0.441667,0.075), vec2(0.933333,0.075))); 
                     res=max(res,LINE(vec2(0.125,0.0666667), vec2(0.141667,0.0666667))); res=max(res,LINE(vec2(0.191667,0.0666667), vec2(0.3,0.0666667))); res=max(res,LINE(vec2(0.425,0.0666667), vec2(0.925,0.0666667))); 
                     res=max(res,LINE(vec2(0.0916667,0.0583333), vec2(0.158333,0.0583333))); res=max(res,LINE(vec2(0.183333,0.0583333), vec2(0.291667,0.0583333))); res=max(res,LINE(vec2(0.425,0.0583333), vec2(0.916667,0.0583333))); 
                     res=max(res,LINE(vec2(0.0583333,0.05), vec2(0.283333,0.05))); res=max(res,LINE(vec2(0.391667,0.05), vec2(0.908333,0.05))); 
                     res=max(res,LINE(vec2(0.0333333,0.0416667), vec2(0.266667,0.0416667))); res=max(res,LINE(vec2(0.341667,0.0416667), vec2(0.341667,0.0416667))); res=max(res,LINE(vec2(0.375,0.0416667), vec2(0.925,0.0416667))); 
                     res=max(res,LINE(vec2(0.025,0.0333333), vec2(0.025,0.0333333))); res=max(res,LINE(vec2(0.05,0.0333333), vec2(0.25,0.0333333))); res=max(res,LINE(vec2(0.275,0.0333333), vec2(0.275,0.0333333))); res=max(res,LINE(vec2(0.333333,0.0333333), vec2(0.341667,0.0333333))); res=max(res,LINE(vec2(0.375,0.0333333), vec2(0.908333,0.0333333))); 
                     res=max(res,LINE(vec2(0.0666667,0.025), vec2(0.258333,0.025))); res=max(res,LINE(vec2(0.283333,0.025), vec2(0.3,0.025))); res=max(res,LINE(vec2(0.316667,0.025), vec2(0.341667,0.025))); res=max(res,LINE(vec2(0.383333,0.025), vec2(0.908333,0.025))); 
                     res=max(res,LINE(vec2(0.05,0.0166667), vec2(0.291667,0.0166667))); res=max(res,LINE(vec2(0.325,0.0166667), vec2(0.908333,0.0166667))); 
                     res=max(res,LINE(vec2(0.05,0.00833333), vec2(0.933333,0.00833333))); 
                     res=max(res,LINE(vec2(0.0583333,0), vec2(0.983333,0))); 
                     #endif
                     return res;}

// Function 5059
vec3 tonemapGamma(vec3 color, float exposure)
{
    color *= exposure;
    return pow(color, vec3(1.0 / 2.2));
}

// Function 5060
float scene(vec3 p)
{
    float d = 1e9;
    
    // bounce-light orb
    d=min(d,length(p-vec3(0,5,0))-2.5);
    
    // light direction debug orb
    //d=min(d,length(p-vec3(0,.5,0))-.5);

    // poles
    vec3 r=p;
    r.x=abs(r.x-1.1)-.2;
    float dpole = max(length(r.xz+vec2(0,5.))-.01,r.y-5.);

    vec3 q=p;
    if(p.y <.3){
    	// snow roughness
		p.y += texture(iChannel1,p.xz*.125).r*.0009;
		p.y += texture(iChannel1,p.xz*2.*.125).r*.0011;
		p.y += texture(iChannel1,p.xz*4.*.125).r*.0021;
	    p.y += texture(iChannel1,p.xz*4.*.0625).r*.0051;
	    p.y += texture(iChannel1,p.xz*4.*.03125).r*.01;
        p.y += sin(p.x*2.)*.05;
        
        // gentle curvature
        p.y -= length(sin(p.xz*.5))*.1;

        
        // footprint meandering
        p.z += sin(p.x*.5)*.5;
        
        // footprint zigzag
        p.z += step(.5,mod(p.x,1.))*.3-.15;
        
        // footprints
        float depth = .03;
        p.x = mod(p.x,.5)-.25;
        float dfoot = footprint(p.xz);
        float foot = smoothstep(.1,.13,dfoot);
        p.y += .1- foot*depth;
        
        // raised snow around footprints
        p.y -= smoothstep(.05,.0,abs(dfoot-.16))*.004;
        
        // footprint stripe pattern
        p.y -= (1.-foot)*.01*ridges(p.xz);
        
    }
    
    // extra mounds
    p.y -= smoothstep(2.,0.,length(q.xz+vec2(-1.5,3.5)))*.2;
    p.y -= smoothstep(2.,0.,length(q.xz+vec2(1,-2)))*.2;
    
    // floor
    float ground = p.y;
    d=min(d,ground);
    
    m=(dpole<d)?1:0;
    d=min(d,dpole);
    
    return d*.9;
}

// Function 5061
float map(in vec3 p){
    float t = time;
    float r3 = 1.5+(sin(t+p.x)*cos(t*cos(t*.5)+p.y)*cos(t+p.z))*.6;

    float scene = esf(p, r3);
  
    vec3 p1 = p;
    p1.xz *= rot(cos(p1.y*0.02+time)*1.);
    p1.zy *= rot(sin(p1.x*0.02+time)*1.);
    
    vec3 p2 = rep(p1-vec3(speed,0,speed), 2., 1.);
    p2.xz *= rot(p2.y*0.02+time*0.2);
    //p2.zy *= rot(p2.x*0.02+time);
	vec3 p3 = abs(p2);
    p3.xz *= rot(p3.z*.2+cross(p3, p2).z)+speed*0.15+2.;
    
    
    float
        e1 = box(p1, 2.6),
        e2 = cil(p3, 0.00001)*0.2,
        e3 = esf(p1, r3)*2.;
    purple += .2/(.05+e1);
    blue += .1/(.05+e2);
    
    scene = max(-scene, e2);
    scene = min(scene, e1);
    scene = min(scene, e3);
    
    l+= smoothstep(0., 1.,p1+speed*.5)*0.4;
    lpos -= cos(speed+p1)*0.5;
    
    slm = e3;
    
    return scene;
}

// Function 5062
endif
map( in vec3 pos )
{
    #if 0
    float r = 1.1;
    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );
    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );
    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;
    pos.x = mirror( pos.x / r ) * r;
    pos.y = mirror( pos.y / r ) * r;
    #else
    vec3 color = ORANGE_RGB;
    #endif
    
    float angle4 = iTime*TAU*0.25;
    
    MPt res;
    #if INDEXED_MATERIALS
    res.x = 1e38;
    #else
    res.distance = 1e38;
    #endif
    
    #if !INDEXED_MATERIALS
    Material plastic_m;
    plastic_m.color = vec3(1.0);
    plastic_m.diffuse_reflection  = 1.0;
    plastic_m.specular_reflection = 1.0;
    plastic_m.ambient_reflection  = 1.0;
    plastic_m.shininess           = 15.0;

    Material floor_m;
    plastic_m.color = vec3(1.0);
    floor_m.diffuse_reflection  = 1.0;
    floor_m.specular_reflection = 0.2;
    floor_m.ambient_reflection  = 0.5;
    floor_m.shininess           = 1.0;

    Material orange_m = plastic_m;
    orange_m.color = ORANGE_RGB;
    
    Material red_m = plastic_m;
    red_m.color = vec3(1.0,0.0,0.0);
    Material green_m = plastic_m;
    green_m.color = vec3(0.0,1.0,0.0);
    Material blue_m = plastic_m;
    blue_m.color = vec3(0.0,0.0,1.0);
    #endif

    float sr = 0.5;
    float sd = 0.5;
    #if 0
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),
                          orange_mat ),
	      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),
                          orange_mat ) );
    res =
       union_op(
          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),
               orange_mat ),
          res );
    #endif
    
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_RED
                        #else
                        red_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_GREEN
                        #else
                        green_m
                        #endif
                       ),res );
    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_BLUE
                        #else
                        blue_m
                        #endif
                       ),res );
    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );
    res = union_op( MPt( plane_sd( pos ),
                        #if INDEXED_MATERIALS
                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m
                        #else
                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )
                        #endif
                       ),
                    res );


    res =
       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                       ),
                    res );
    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )
                        #endif
                       ),
                    res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,6.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,angle4), at_pos(vec3(2.0,10.0,2.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,angle4), at_pos(vec3(2.0,12.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),
                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                        vec3(1.0,1.0,-1.0) *
                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),
                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op(
          intersect_op(
             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),
                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
             intersect_op(
                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                ),
                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),
                     #if INDEXED_MATERIALS
                      MAT_ORANGE
                     #else
                      orange_m
                     #endif
                )
             )
          ),
          res );
    
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );  
    res =
       union_op( MPt( capped_cone_as_intersections_sd(
                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(angle4) ), pos) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( tri_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,30.0,0.0), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res =
       union_op( MPt( tri_prism_bary_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,32.0,0.288675135), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,32.0,0.288675135), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res =
       union_op( MPt( tri_prism_bary_r_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,34.0,0.5), pos) ) ),
                      #if INDEXED_MATERIALS
                       MAT_ORANGE
                      #else
                       orange_m
                      #endif
                    ),
                 res );
    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,34.0,0.5), pos ) ),
                        #if INDEXED_MATERIALS
                         MAT_PLASTIC
                        #else
                        plastic_m
                        #endif
                       ), res );
    res = union_op( MPt( cline_sd( vec3(2.0,36.0,0.5), vec3(2.0,36,1.5), 0.5, pos ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    res = union_op( MPt( cline_sd( vec3(0.0,0.0,-1.0), vec3(0.0,0.0,1.0), 0.25, at_angle( vec3( QPI * 0.5, 0.0, angle4), at_pos( vec3(2.0,38,1.5), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    res = union_op( MPt( ellipsoid_sd( vec3(0.5,0.25,1.0), at_angle( vec3( 0.0, 0.0, angle4), at_pos( vec3(2.0,40,1.5), pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                        orange_m
                        #endif
                       ), res );
    
    res =
       union_op( MPt( torus82_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,42.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus88_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,44.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere8_sd( 0.5, at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,46.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus42_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,48.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus44_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,50.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere4_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,52.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus32_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,54.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus33_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,56.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( sphere3_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,58.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torus2mh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,60.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torusmh2_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,62.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( torusmhmh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,64.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
    
    res =
       union_op( MPt( spheremh_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,66.0,1.0),pos) ) ),
                        #if INDEXED_MATERIALS
                         MAT_ORANGE
                        #else
                         orange_m
                        #endif
                    ),
                 res );
	return res;
}

// Function 5063
float ellipse_arc_dist(vec2 p, vec2 ab, vec2 alim) {
    
	// constants    
    const float PI = 3.141592653589793;
    
    // distance and sign
    vec2 ds = vec2(1e5, -1);
    
    // needed for deciding sign for distance later
    float orig_sign = -1.;
    
    // are we going all the way around ellipse?
    bool full_ellipse = (alim[1] == 0. || abs(alim[1]) >= 2.*PI);

    // construct unit vectors corresp. to start and end angles
    vec2 n0 = from_angle(alim.x);
    vec2 n1 = from_angle(alim.x + alim.y);

    // determine some tangent vectors along ellipse at 
    // endpoints
    float delta_sign = sign(alim.y);
    vec2 t0 = -perp(n0)*delta_sign;
    vec2 t1 = perp(n1)*delta_sign;
    
    // angular extents bigger than 1/2 rotation are
    // treated differently than those less 
    float wedge_sign = 1.;
    
    if (abs(alim[1]) > PI) {
        t0 = -t0;
        t1 = -t1;
        wedge_sign = -1.;
    }

    // determine endpoints of ellipse 
    vec2 p0 = ab * n0;
    vec2 p1 = ab * n1;

    // determine whether we are inside the wedge
    // formed by the normal vectors at the endpoints
    if (!full_ellipse) {
        orig_sign = sign(max(dot(p - p0, ab.yx*n0), dot(p - p1, ab.yx*n1)));
        ds = vec2(min(length(p - p0), length(p - p1)), orig_sign);
    }
    
    
    // circles need special-case handling because the quartic
    // degenerates into a quadratic.    
    if (abs((ab.x - ab.y) / ab.x) < 1e-2) {
        
        // a and b are pratically equal, so treat this as a circle
        
        float dc = length(p) - ab.x;
        
        if (full_ellipse || max(dot(p, t0), dot(p, t1))*wedge_sign <= .0) {
            ds = smaller_x(ds, vec2(abs(dc), dc));
        }
        
    } else {
        
        // general ellipse case
        
        // the quartic is numerically ill-conditioned
        // near the y-axis, so keep on the nicely behaved
        // side of the diagonal
        if (abs(p.x) < abs(p.y)) {
            p.xy = p.yx;
            ab.xy = ab.yx;
            t0 = t0.yx;
            t1 = t1.yx;
        }
        
        // formulate the quartic polynomial that represents
        // this ellipse. we are solving for the position 
        // u = cos(theta) along the ellipse such that the
        // tangent at the point [a*u, b*sqrt(1-u^2)] is 
        // perpendicular to the displacement between p
        // and the point itself.
        //
        // there may be multiple valid solutions for this 
        // polynomial -- for a full ellipse we could just 
        // grab the maximal root but we actually need
        // to inspect each of them in the arc case.
        
        float l = ab.y*ab.y - ab.x*ab.x;

        float ax = ab.x*p.x / l;
        float by = ab.y*p.y / l;

        float a2x2 = ax*ax;
        float b2y2 = by*by;

        // vector of polynomial coefficients
        vec4 coeffs = vec4(2.*ax, (a2x2 + b2y2) - 1., -2.*ax, -a2x2);

        // solve for up to 4 roots 
        vec4 roots;
        solve_quartic(coeffs, roots);

        // for each root
        for (int i=0; i<4; ++i) {
            
            // construct point on unit circle
            vec2 uv = from_cos(roots[i]);
            
            // need to check this point both above and below x-axis
            for (int j=0; j<2; ++j) {
                
                // if we are considering the entire ellipse or
                // the given uv is inside the angle clip region,
                if (full_ellipse ||
                    max(dot(uv, t0), dot(uv, t1))*wedge_sign <= .0) {
                    
                    // get the absolute distance to the closest point on 
                    // the ellipse, as well as its sign
                    vec2 pc = ab*uv;
                    ds = smaller_x(ds, vec2(length(p - pc), dot(p-pc, pc)));
                    
                }
                
                // mirror the root point across the x-axis
                uv.y *= -1.;
                
            }
        }
        
    }
    
    // combine the absolute distance with the sign of the 
    // distance, respecting original sign classification
    // before root finding
    return ds.x*max(sign(ds.y), orig_sign);
    
}

// Function 5064
float sdFont(vec2 p, int c) {
    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;
    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), sample_dist_gaussian(uv));
}

// Function 5065
float mapSupernovaRemnant(vec3 p) {
	p*=2.;
    float noi = Disk(p.xzy,vec3(2.0,1.8,1.25))+
    	+ fbm(p*90.)
    	+ SpiralNoiseC2(p.zxy*0.5123+100.0)*3.0;
	return abs(noi*.5)+0.07;
}

// Function 5066
float dist(in vec2 uv, in vec2 p, in float level)
{
    float h = level;
    uv = pow(abs(uv - p), vec2(h));
    return pow( uv.x + uv.y, 1./h) ;  
}

// Function 5067
vec2 square_map(vec2 uv)
{
    return (rotatePoint(vec3(uv+vec2(cos(seedling*PI), cos(seedling*GR)), 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy*(GR)*(1.0+.25*saw(seedling*seedling*PI/4.0))
            +vec2(cos(time+seedling)+sin(time+seedling*seedling*seedling)));
}

// Function 5068
float _dist(vec3 pos, float t) {
    vec3 SPHERE_CENTER = sphereCenter(t);
    vec3 relPos = pos - SPHERE_CENTER;
    float disp1 = displacement(pos, t);
	return length(relPos) - 0.5 + 0.2* (disp1);
}

// Function 5069
float mapTree( vec3 p )
{
    float f = length(p);
    if( f>8.0 )
        return f - 8.0 + 0.1;

    vec3 q = p;   
    
    p.xz += 0.1*sin(4.0*p.y+vec2(0.0,1.0));
    vec2 s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-2.0,3.3,4.0) );
    float d2 = s1.x - (0.25 - 0.12*s1.y);
    s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,0.0) );
    float d4 = s1.x - (0.25 - 0.12*s1.y);
    d2 = min( d2, d4 );
    s1 = sdSegment( p, mix( vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,-1.0), 0.35 ), vec3(-2.0,3.3,-4.0) );
    d4 = s1.x - (0.25 - 0.12*s1.y);
    d2 = min( d2, d4 );
    
    p.y += length(p.xz)*0.1;
    p.y += 0.5*sin(p.x);
    
    float nn = textureLod(iChannel2,0.1*q.zy, 0.0).x;
    d4 = sdEllipsoid( p, vec3( 0.0,3.3,0.0), vec3(4.5,0.9,4.5)*(1.0+nn) );
    
    d4 += max(0.0,3.0*sin(1.5*q.x)*sin(1.5*q.y)*sin(1.5*q.z)*clamp( 1.0 - d4/3.0, 0.0, 1.0 ));

    return min( d2, d4 );
}

// Function 5070
float line_sqdist(vec2 uv, vec2 a, vec2 b)
{
    vec2 ab = b-a, ap = uv-a;
    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);
    return length_squared(uv - (ab*t + a));
}

// Function 5071
float3 BSDF_Sample ( float3 N, float3 wi, float3 P, Material mat, out float pdf,
                     inout float seed) {
  if ( mat.transmittive > 0.0 ) {
    pdf = 1.0f;
    return refract(wi, N, mat.transmittive);
  }
    if (mat.diffuse == 0.0) { pdf = 1.0f; return reflect(wi, N); }
  float diff_chance = Sample_Uniform(seed);
  if ( diff_chance < mat.diffuse ) {
    return Sample_Cos_Hemisphere(wi, N, pdf, seed);
  }
  float2 xi = Sample_Uniform2(seed);
  float k = mat.alpha*mat.alpha;
  float phi   = TAU * xi.x,
        theta = asin( sqrt( ( k*log(1.0-xi.y) )/( k*log(1.0-xi.y)-1.0 )));
  float3 wo = Reorient_Hemisphere(normalize(To_Cartesian(theta, phi)), N); 
  pdf = PDF_Cosine_Hemisphere(wi, N);
  return wo;
}

// Function 5072
float scene(vec3 q) {
	return min(sphere_dist(q), cylinder_dist(q));
}

// Function 5073
float scene(vec3 p) {
  float scale =0.2;
  
  vec2 id = floor(p.xy*scale);
  float dist = 10000.;
  for (int i = -1; i < 2; i++) {
    for (int j = -1; j < 2; j++) {
      vec2 currid = vec2(id)+vec2(i,j);
      vec2 pi = piston(p, currid, scale);
      if (pi.x < dist) {
        dist = pi.x;
        mat = pi.y;
        bestid = currid;
      }
    }
  }
  return dist;
}

// Function 5074
vec3 heightmap (vec3 n)
{
	return vec3(fbm((5.0 * n) + fbm((5.0 * n) * 3.0 - 1000.0) * 0.05),0,0);
}

// Function 5075
float SDF (vec3 p)
{
    float anim = exp(-fract(PI*time*BPM/2.)*6.)*8.;
    p.x += texNoise(p.yz*anim).r*0.5;
    return min(tunnel(p), min(strings(p),jellyfish(p)));
}

// Function 5076
vec4 gs_map_unproject( GameState gs, vec2 sc, vec2 res )
	{ vec3 _; return gs_map_unproject_d( gs, sc, res, _, _ ); }

// Function 5077
float map5_perlin1(vec3 p)  
{	
    float r = 0.;
    float s = 1.;
    float f = 1.;
    
    float w = 0.;
    for(int i = 0;i < 5;i++){
        r += s*noise_perlin1(p*f); w += s;
        s /= 2.;
        f *= 2.;
    }
    return r/w;
}

// Function 5078
float map1(vec3 U) {
    float d = dot(U,U), r = float((N+1)/2);
    if (d > 4. ) return sqrt(d)-1.;           // bounding sphere
    //d = 1e3;   // why useless ?
    for (int k=0; k< N*N*N; k++) {            // complex object. Stub: grid of spheres
        vec3 C = vec3( k%N -N/2, k/N%N -N/2, k/(N*N) -N/2) / r;
        d = min( d, length(U-C) - .3/r) ;
    }
    return d;
}

// Function 5079
float opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)
{
    vec3 lm1 = lim-vec3(1.0);
    p += c*.5*lm1;
    vec3 q;
	q = min(p,mod(p+.5*c,c)-.5*c); // less than 0
    q = max(q,p-(lim-vec3(1.0))*c); // more than limit
    return scene1(q);
}

// Function 5080
float map(vec3 p)
{

    ivec3 c =ivec3(p) +16;
    if(any(greaterThan(c,ivec3(31))) || any(lessThan(c,ivec3(0)))) return 4.;

    return  clamp(-1.*voxel(c.x,c.y,c.z)+.5,-4.,4.);
}

// Function 5081
void dmap (out vec3 c, vec3 p)
{
	c = p.y > EPS ? 
		(p.y > 9.54 ? (p.y > 10.45 ? vec3(1, 0, 0) : vec3(0)): vec3(1))
		: vec3(.8);
		
	if (length(p - vec3(0, 10, -10)) < 1.5) c = vec3(1);
	else if (length(p - vec3(0, 10, -10)) < 1.8) c = vec3(0);
}

// Function 5082
float surfaceSDF(vec4 p)
{
    float edge = 0.01;	// thickness of edge
    return wireHypCube(p) - edge;	// suggested by iapafoto
}

// Function 5083
float map( in vec3 pos )
{
    mat=0.0;
    float c = pMod1(pos.z,6.0);

    pos.yx *= rot(.55*c-iTime*3.2);
    
    
    // Deform Space...
    
    float len = 24.0+(sin(iTime)*12.0);
    
    float rad =  (1.0/(3.141*2.0)*len);
    float ang = atan(pos.x, pos.y);
    vec2 cyl = vec2(rad-length(pos.xy), pos.z);
    vec3 dp = vec3(cyl, ang * rad);

    float xs = .45;
    float zs = 5.65;
    float ys = .65;
    float boff = 0.2;		// bounding box offset
    float bthick = 0.2;	// bounding box thickness

    float d1 =  sdBoundingBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs+boff,ys+boff,zs+boff),bthick);
    float d2 = sdBox(dp.yxz+vec3(0.0,.8,0.0),vec3(xs,ys,zs));
    mat = step(d1,d2);
    d1 = min(d1,d2);
    return d1*0.5;
}

// Function 5084
float mapGalaxy(vec3 p, vec4 id) {  
	float d1 = spiralArm(p.xzy*.2, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);
#ifdef WITH_DOUBLE_GALAXY
    if (id.z<.25) {
   		float d2 = spiralArm(vec3(-p.y,p.z,p.x)*.205, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);        
   		return min(d2, d1);
     } 
#endif    
     return d1;
}

// Function 5085
vec3 Heatmap2(float x) {
    vec3 t = vec3(1, 0.5, 0) - x;
    return iSqrt2Pi * exp(-12.5 * t * t);
}

// Function 5086
vec3 sampleBSDF(	in vec3 x,
                  	in vec3 ng,
                  	in vec3 ns,
                	in vec3 wi,
                  	in Material mtl,
                  	in bool useMIS,
                  	in int strataCount,
                  	in int strataIndex,
                	out vec3 wo,
                	out float brdfPdfW,
                	out vec3 fr,
                	out bool hitRes,
                	out SurfaceHitInfo hit,
               		out float spec) {
    float strataSize = 1.0 / float(strataCount);
    vec3 Lo = vec3(0.0);
    for(int i=0; i<DL_SAMPLES; i++){
        vec2 xi = vec2(rnd(), strataSize * (float(strataIndex) + rnd()));
        fr = mtlSample(mtl, ng, ns, wi, xi, wo, brdfPdfW, spec);
        
        //fr = eval(mtl, ng, ns, wi, wo);

        float dotNWo = dot(wo, ns);
        //Continue if sampled direction is under surface
        if ((dot(fr,fr)>0.0) && (brdfPdfW > EPSILON)) {
            Ray shadowRay = Ray(x, wo);

            //abstractLight* pLight = 0;
            float cosAtLight = 1.0;
            float distanceToLight = -1.0;
            vec3 Li = vec3(0.0);

            {
                float distToHit;

                if(raySceneIntersection( shadowRay, EPSILON, false, hit, distToHit )) {
                    if(hit.mtl_id_>=LIGHT_ID_BASE) {
                        distanceToLight = distToHit;
                        cosAtLight = dot(hit.normal_, -wo);
                        if(cosAtLight > 0.0) {
                            Li = getRadiance(hit.uv_);
                            //Li = lights[0].color_*lights[0].intensity_;
                        }
                    } else {
                        hitRes = true;
                    }
                } else {
                    hitRes = false;
                    //TODO check for infinite lights
                }
            }

            if (distanceToLight>0.0) {
                if (cosAtLight > 0.0) {
                    vec3 contribution = (Li * fr * dotNWo) / brdfPdfW;

                    if (useMIS/* && !(mtl->isSingular())*/) {
                        float lightPickPdf = 1.0;//lightPickingPdf(x, n);
                        float lightPdfW = sampleLightSourcePdf( x, wi, distanceToLight, cosAtLight );
                        //float lightPdfW = sphericalLightSamplingPdf( x, wi );//pLight->pdfIlluminate(x, wo, distanceToLight, cosAtLight) * lightPickPdf;

                        contribution *= misWeight(brdfPdfW, lightPdfW);
                    }

                    Lo += contribution;
                }
            }
        }
    }

    return Lo*(1.0/float(DL_SAMPLES));
}


```